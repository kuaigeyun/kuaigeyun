# 接口管理最佳实践

## 📋 模块概述

**模块名称**：接口管理（API Management）  
**优先级**：⭐⭐⭐⭐（高优先级）  
**预计时间**：2-3 周  
**依赖**：无（独立功能）

**功能范围**：
- 接口定义（接口名称、路径、方法、参数、响应格式）
- 接口管理（CRUD）
- 接口测试（测试调用、响应预览）
- 接口文档生成（OpenAPI）

---

## 🔍 库选择评估

### 接口管理实现方案

**结论**：✅ **使用自定义实现 + httpx（推荐，已使用）**

#### 方案一：httpx（已使用） ⭐⭐⭐⭐⭐（强烈推荐）

**优势**：
- ✅ **已使用**，无需额外安装
- ✅ 异步支持，性能好
- ✅ 功能完整，支持所有 HTTP 方法
- ✅ 与 FastAPI 完美集成
- ✅ 支持自定义请求头、参数、请求体
- ✅ 支持超时、重试、代理等高级功能

**劣势**：
- ⚠️ 需要自己实现接口测试逻辑（但逻辑简单）

**适用场景**：
- ✅ 需要接口定义和管理功能
- ✅ 需要接口测试功能
- ✅ 需要多租户接口隔离
- ✅ 需要异步接口测试

**实现复杂度**：⭐⭐（简单，httpx 已使用，只需封装测试逻辑）

---

#### 方案二：requests ⭐⭐⭐（备选，不推荐）

**优势**：
- ✅ 简单易用，API 直观
- ✅ 文档完善，社区活跃
- ✅ 同步请求，逻辑简单

**劣势**：
- ❌ 同步请求，性能不如 httpx
- ❌ 需要额外安装依赖
- ❌ 与 FastAPI 异步架构不匹配

**结论**：httpx 已使用且功能更强，无需切换到 requests。

---

#### 方案三：httpie ⭐⭐⭐（可选，不推荐）

**优势**：
- ✅ 命令行工具，使用简单
- ✅ 输出格式美观

**劣势**：
- ❌ 主要用于命令行，不适合程序集成
- ❌ 需要额外安装依赖
- ❌ 功能不如 httpx 完整

**结论**：httpx 已满足需求，无需集成 httpie。

---

### 最终推荐方案

**推荐**：✅ **继续使用 httpx（已使用）**

**理由**：
1. ✅ **httpx 已使用**，无需额外依赖
2. ✅ **功能完整**，支持所有接口测试需求
3. ✅ **异步支持**，性能好，与 FastAPI 架构匹配
4. ✅ **多租户是核心需求**，自定义实现天然支持
5. ✅ **完全符合框架规范**，代码风格统一
6. ✅ **维护成本低**，团队完全掌控代码

**API 测试库选择**：
- ✅ **httpx** ⭐ **已选定**（接口测试库）
  - 安装：`pip install httpx`（已安装）
  - 用于接口测试调用
  - 支持异步请求
  - 支持自定义请求头、参数、请求体
  - 支持超时、重试、代理等高级功能

---

## 🗄️ 数据库设计

### 接口表（root_apis）

```sql
CREATE TABLE root_apis (
    id SERIAL PRIMARY KEY,
    uuid VARCHAR(36) NOT NULL UNIQUE,        -- 业务ID（UUID，对外暴露，安全且唯一）
    tenant_id INTEGER NOT NULL,
    
    -- 接口基本信息
    name VARCHAR(100) NOT NULL,             -- 接口名称
    code VARCHAR(50) NOT NULL,             -- 接口代码（唯一，用于程序识别）
    description TEXT,                       -- 接口描述
    path VARCHAR(500) NOT NULL,             -- 接口路径
    method VARCHAR(10) NOT NULL,            -- 请求方法（GET、POST、PUT、DELETE等）
    
    -- 请求配置
    request_headers JSONB,                   -- 请求头（JSON格式）
    request_params JSONB,                   -- 请求参数（JSON格式）
    request_body JSONB,                     -- 请求体（JSON格式）
    
    -- 响应配置
    response_format JSONB,                  -- 响应格式（JSON格式）
    response_example JSONB,                 -- 响应示例（JSON格式）
    
    -- 接口状态
    is_active BOOLEAN DEFAULT TRUE,          -- 是否启用
    is_system BOOLEAN DEFAULT FALSE,        -- 是否系统接口（系统接口不可删除）
    
    -- 标准字段
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL,
    
    -- 索引
    CONSTRAINT uk_root_apis_tenant_code UNIQUE (tenant_id, code),
    INDEX idx_root_apis_tenant_id (tenant_id),
    INDEX idx_root_apis_uuid (uuid),
    INDEX idx_root_apis_code (code),
    INDEX idx_root_apis_method (method),
    INDEX idx_root_apis_created_at (created_at)
);
```

**设计要点**：
- ✅ **混合ID方案**：`id`（自增ID，内部使用）+ `uuid`（UUID，对外暴露）
- ✅ `code` 字段用于程序识别，与 `name` 分离（支持多语言）
- ✅ `request_headers`、`request_params`、`request_body` 使用 JSONB 存储
- ✅ `response_format`、`response_example` 使用 JSONB 存储
- ✅ `tenant_id + code` 唯一约束，确保组织内接口代码唯一
- ✅ 软删除支持（`deleted_at`）

---

## 🐍 后端模型设计

### 接口模型（API）

```python
# riveredge-backend/src/tree_root/models/api.py
from tortoise.models import Model
from tortoise import fields
from typing import Optional, Dict, Any
from .base import BaseModel


class API(BaseModel):
    """
    接口模型
    
    用于定义和管理组织内的接口，支持接口定义、测试、文档生成等功能。
    支持多组织隔离，每个组织的接口相互独立。
    
    注意：继承自 BaseModel，自动包含 uuid、tenant_id、created_at、updated_at 字段。
    """
    id = fields.IntField(pk=True, description="接口ID（主键，自增ID，内部使用）")
    # uuid 字段由 BaseModel 提供
    # tenant_id 字段由 BaseModel 提供
    
    name = fields.CharField(max_length=100, description="接口名称")
    code = fields.CharField(max_length=50, description="接口代码（唯一，用于程序识别）")
    description = fields.TextField(null=True, description="接口描述")
    path = fields.CharField(max_length=500, description="接口路径")
    method = fields.CharField(max_length=10, description="请求方法（GET、POST、PUT、DELETE等）")
    
    request_headers = fields.JSONField(null=True, description="请求头（JSON格式）")
    request_params = fields.JSONField(null=True, description="请求参数（JSON格式）")
    request_body = fields.JSONField(null=True, description="请求体（JSON格式）")
    
    response_format = fields.JSONField(null=True, description="响应格式（JSON格式）")
    response_example = fields.JSONField(null=True, description="响应示例（JSON格式）")
    
    is_active = fields.BooleanField(default=True, description="是否启用")
    is_system = fields.BooleanField(default=False, description="是否系统接口（系统接口不可删除）")
    
    class Meta:
        table = "root_apis"
        indexes = [
            ("tenant_id", "code"),  # 唯一索引
            ("method",),
        ]
        unique_together = [("tenant_id", "code")]
    
    def __str__(self):
        return f"{self.name} ({self.method} {self.path})"
```

---

## 📝 Schema 设计

### 接口 Schema

```python
# riveredge-backend/src/tree_root/schemas/api.py
from pydantic import BaseModel, Field, ConfigDict
from typing import Optional, Dict, Any
from datetime import datetime
from uuid import UUID


class APIBase(BaseModel):
    """接口基础 Schema"""
    name: str = Field(..., max_length=100, description="接口名称")
    code: str = Field(..., max_length=50, description="接口代码")
    description: Optional[str] = Field(None, description="接口描述")
    path: str = Field(..., max_length=500, description="接口路径")
    method: str = Field(..., max_length=10, description="请求方法")
    request_headers: Optional[Dict[str, Any]] = Field(None, description="请求头")
    request_params: Optional[Dict[str, Any]] = Field(None, description="请求参数")
    request_body: Optional[Dict[str, Any]] = Field(None, description="请求体")
    response_format: Optional[Dict[str, Any]] = Field(None, description="响应格式")
    response_example: Optional[Dict[str, Any]] = Field(None, description="响应示例")
    is_active: bool = Field(True, description="是否启用")
    is_system: bool = Field(False, description="是否系统接口")


class APICreate(APIBase):
    """创建接口 Schema"""
    pass


class APIUpdate(BaseModel):
    """更新接口 Schema"""
    name: Optional[str] = Field(None, max_length=100, description="接口名称")
    code: Optional[str] = Field(None, max_length=50, description="接口代码")
    description: Optional[str] = Field(None, description="接口描述")
    path: Optional[str] = Field(None, max_length=500, description="接口路径")
    method: Optional[str] = Field(None, max_length=10, description="请求方法")
    request_headers: Optional[Dict[str, Any]] = Field(None, description="请求头")
    request_params: Optional[Dict[str, Any]] = Field(None, description="请求参数")
    request_body: Optional[Dict[str, Any]] = Field(None, description="请求体")
    response_format: Optional[Dict[str, Any]] = Field(None, description="响应格式")
    response_example: Optional[Dict[str, Any]] = Field(None, description="响应示例")
    is_active: Optional[bool] = Field(None, description="是否启用")


class APIResponse(APIBase):
    """接口响应 Schema"""
    uuid: UUID = Field(..., description="接口UUID")
    tenant_id: int = Field(..., description="组织ID")
    created_at: datetime = Field(..., description="创建时间")
    updated_at: datetime = Field(..., description="更新时间")
    
    model_config = ConfigDict(from_attributes=True)


class APITestRequest(BaseModel):
    """接口测试请求 Schema"""
    headers: Optional[Dict[str, Any]] = Field(None, description="请求头（覆盖接口定义）")
    params: Optional[Dict[str, Any]] = Field(None, description="请求参数（覆盖接口定义）")
    body: Optional[Dict[str, Any]] = Field(None, description="请求体（覆盖接口定义）")


class APITestResponse(BaseModel):
    """接口测试响应 Schema"""
    status_code: int = Field(..., description="响应状态码")
    headers: Dict[str, Any] = Field(..., description="响应头")
    body: Any = Field(..., description="响应体")
    elapsed_time: float = Field(..., description="请求耗时（秒）")
```

---

## 🔧 Service 层设计

### 接口服务（APIService）

**核心功能**：
1. 接口 CRUD（创建、读取、更新、删除）
2. 接口测试（使用 httpx 调用接口）
3. 接口文档生成（OpenAPI 格式）

**关键实现要点**：
- ✅ 使用 `httpx` 进行接口测试（已使用，无需额外安装）
- ✅ 接口测试支持覆盖接口定义的参数
- ✅ 接口文档生成使用 FastAPI 的 OpenAPI 功能
- ✅ 接口测试结果包含状态码、响应头、响应体、耗时等信息

### 接口测试服务实现

```python
# riveredge-backend/src/tree_root/services/api_service.py
import httpx
from typing import Dict, Any, Optional
from datetime import datetime
import time

class APIService:
    """
    接口服务
    
    负责接口的 CRUD 操作和接口测试。
    """
    
    async def test_api(
        self,
        api: API,
        headers: Optional[Dict[str, Any]] = None,
        params: Optional[Dict[str, Any]] = None,
        body: Optional[Dict[str, Any]] = None,
        timeout: float = 30.0,
    ) -> Dict[str, Any]:
        """
        测试接口调用
        
        Args:
            api: 接口对象
            headers: 请求头（覆盖接口定义的请求头）
            params: 请求参数（覆盖接口定义的参数）
            body: 请求体（覆盖接口定义的请求体）
            timeout: 请求超时时间（秒）
            
        Returns:
            {
                "status_code": 200,
                "headers": {...},
                "body": {...},
                "elapsed_time": 0.123
            }
        """
        # 1. 合并请求头（测试请求头优先）
        request_headers = api.request_headers or {}
        if headers:
            request_headers.update(headers)
        
        # 2. 合并请求参数（测试参数优先）
        request_params = api.request_params or {}
        if params:
            request_params.update(params)
        
        # 3. 合并请求体（测试请求体优先）
        request_body = api.request_body or {}
        if body:
            request_body.update(body)
        
        # 4. 构建完整URL
        url = api.path
        if not url.startswith("http://") and not url.startswith("https://"):
            # 相对路径，需要添加基础URL
            from soil.config import settings
            base_url = settings.BASE_URL
            url = f"{base_url}{url}"
        
        # 5. 发送请求
        start_time = time.time()
        try:
            async with httpx.AsyncClient(timeout=timeout) as client:
                # 根据请求方法发送请求
                if api.method.upper() == "GET":
                    response = await client.get(
                        url,
                        headers=request_headers,
                        params=request_params,
                    )
                elif api.method.upper() == "POST":
                    response = await client.post(
                        url,
                        headers=request_headers,
                        params=request_params,
                        json=request_body,
                    )
                elif api.method.upper() == "PUT":
                    response = await client.put(
                        url,
                        headers=request_headers,
                        params=request_params,
                        json=request_body,
                    )
                elif api.method.upper() == "DELETE":
                    response = await client.delete(
                        url,
                        headers=request_headers,
                        params=request_params,
                    )
                else:
                    raise ValueError(f"不支持的请求方法: {api.method}")
                
                # 6. 解析响应
                elapsed_time = time.time() - start_time
                
                # 尝试解析 JSON 响应
                try:
                    response_body = response.json()
                except Exception:
                    # 如果不是 JSON，返回文本
                    response_body = response.text
                
                return {
                    "status_code": response.status_code,
                    "headers": dict(response.headers),
                    "body": response_body,
                    "elapsed_time": round(elapsed_time, 3),
                }
        except httpx.TimeoutException:
            elapsed_time = time.time() - start_time
            return {
                "status_code": 0,
                "headers": {},
                "body": {"error": "请求超时"},
                "elapsed_time": round(elapsed_time, 3),
            }
        except httpx.RequestError as e:
            elapsed_time = time.time() - start_time
            return {
                "status_code": 0,
                "headers": {},
                "body": {"error": f"请求失败: {str(e)}"},
                "elapsed_time": round(elapsed_time, 3),
            }
        except Exception as e:
            elapsed_time = time.time() - start_time
            return {
                "status_code": 0,
                "headers": {},
                "body": {"error": f"未知错误: {str(e)}"},
                "elapsed_time": round(elapsed_time, 3),
            }
```

### httpx 使用说明

**httpx 特性**：
- ✅ **异步支持**：使用 `httpx.AsyncClient` 进行异步请求
- ✅ **超时控制**：支持请求超时设置
- ✅ **自动重试**：可配置重试策略（需要额外实现）
- ✅ **代理支持**：支持 HTTP/HTTPS 代理
- ✅ **SSL 验证**：支持 SSL 证书验证
- ✅ **Cookie 管理**：自动管理 Cookie

**httpx 优势**：
- ✅ 与 FastAPI 完美集成（FastAPI 使用 httpx 进行测试）
- ✅ 性能好，异步非阻塞
- ✅ API 简洁，易于使用
- ✅ 功能完整，支持所有 HTTP 特性

---

## 🌐 API 设计

### 接口管理 API

**路由前缀**：`/api/tree-root/apis`

**接口列表**：
1. `POST /` - 创建接口
2. `GET /list` - 获取接口列表（分页、搜索、筛选）
3. `GET /{uuid}` - 获取接口详情
4. `PUT /{uuid}` - 更新接口
5. `DELETE /{uuid}` - 删除接口
6. `POST /{uuid}/test` - 测试接口调用
7. `GET /{uuid}/doc` - 获取接口文档（OpenAPI）

---

## 🎨 前端页面设计

### 接口管理页面

**页面路径**：`pages/system/apis/list/index.tsx`

**核心功能**：
1. 接口列表展示（UniTable，支持表格视图）
2. 接口创建/编辑（Modal + ProForm）
3. 接口测试（测试调用、响应预览）
4. 接口文档查看（OpenAPI 文档）
5. 接口删除（单个删除、批量删除）
6. 接口搜索和筛选（按名称、方法、路径）

**布局规范**：
- ✅ 使用 `UniTable` 组件展示列表
- ✅ 使用高级搜索（`showAdvancedSearch={true}`）
- ✅ 使用 `searchFormValues` 获取搜索条件
- ✅ 创建/编辑使用 Modal + ProForm
- ✅ 接口测试使用 Drawer 展示测试结果

---

## ⚠️ 重要注意事项

### 1. 吸取第一、第二阶段经验教训

**必须遵守的规范**：
1. ✅ **禁止假设和猜测**：必须直接查看实际代码，使用完全相同的值
2. ✅ **禁止擅作主张**：只做用户明确要求的事，不做额外"优化"
3. ✅ **数据库迁移规范**：必须使用 Aerich 迁移系统，禁止直接使用 SQL
4. ✅ **前端搜索规范**：必须使用高级搜索（`showAdvancedSearch={true}`），使用 `searchFormValues` 获取搜索条件
5. ✅ **UniTable 规范**：`request` 函数必须接收四个参数：`(params, sort, _filter, searchFormValues)`

### 2. 接口测试注意事项

#### 2.1 httpx 使用规范

**基本使用**：
- ✅ 使用 `httpx.AsyncClient` 进行异步请求
- ✅ 支持 GET、POST、PUT、DELETE、PATCH 等方法
- ✅ 支持自定义请求头、参数、请求体
- ✅ 支持超时设置（默认 30 秒）
- ✅ 捕获异常并返回错误信息

**请求示例**：
```python
# GET 请求
async with httpx.AsyncClient() as client:
    response = await client.get(
        url,
        headers={"Authorization": "Bearer token"},
        params={"key": "value"},
    )

# POST 请求
async with httpx.AsyncClient() as client:
    response = await client.post(
        url,
        headers={"Content-Type": "application/json"},
        json={"key": "value"},
    )
```

**高级功能**：
- ✅ **超时控制**：`timeout=30.0`（秒）
- ✅ **重试机制**：可配置重试策略（需要额外实现）
- ✅ **代理支持**：`proxies={"http://": "http://proxy:8080"}`
- ✅ **SSL 验证**：`verify=True/False`
- ✅ **Cookie 管理**：自动管理 Cookie

#### 2.2 接口测试安全

**安全限制**：
- ✅ **组织隔离**：接口测试仅限组织内接口
- ✅ **URL 验证**：禁止测试外部接口（防止 SSRF 攻击）
- ✅ **白名单机制**：可配置允许测试的域名白名单
- ✅ **结果不保存**：接口测试结果不保存，仅用于预览

**URL 验证实现**：
```python
def validate_test_url(url: str, tenant_id: int) -> bool:
    """
    验证测试URL是否安全
    
    只允许测试组织内的接口（同域名或配置的白名单域名）
    """
    from soil.config import settings
    
    # 允许的域名列表（从配置读取）
    allowed_domains = settings.API_TEST_ALLOWED_DOMAINS or []
    
    # 解析URL
    from urllib.parse import urlparse
    parsed = urlparse(url)
    
    # 检查是否在允许的域名列表中
    if parsed.netloc in allowed_domains:
        return True
    
    # 检查是否是相对路径（组织内接口）
    if not parsed.netloc:
        return True
    
    # 检查是否是当前服务的域名
    base_url = settings.BASE_URL
    base_parsed = urlparse(base_url)
    if parsed.netloc == base_parsed.netloc:
        return True
    
    return False
```

#### 2.3 接口测试最佳实践

**测试流程**：
1. 验证接口定义（检查 URL、方法、参数等）
2. 验证测试URL安全性（防止 SSRF 攻击）
3. 合并请求参数（测试参数覆盖接口定义）
4. 发送请求（使用 httpx）
5. 解析响应（JSON 或文本）
6. 返回测试结果（状态码、响应头、响应体、耗时）

**错误处理**：
- ✅ 捕获超时异常（`httpx.TimeoutException`）
- ✅ 捕获请求异常（`httpx.RequestError`）
- ✅ 捕获其他异常（返回错误信息）
- ✅ 记录错误日志（便于排查问题）

**性能优化**：
- ✅ 使用异步请求（`httpx.AsyncClient`）
- ✅ 设置合理的超时时间（避免长时间等待）
- ✅ 限制并发请求数（防止资源耗尽）

---

## 📚 相关文档

- [前端页面布局规范.md](./前端页面布局规范.md)
- [系统级功能文件结构规划.md](./系统级功能文件结构规划.md)
- [建设进度.md](./建设进度.md)

---

**最后更新**：2025-01-XX

