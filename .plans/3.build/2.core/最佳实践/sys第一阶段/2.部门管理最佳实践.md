# 部门管理最佳实践

## 📋 模块概述

**模块名称**：部门管理（Department Management）  
**优先级**：⭐⭐⭐⭐⭐（最高优先级）  
**预计时间**：1 周  
**依赖**：角色权限管理（需要权限控制）

**功能范围**：
- 部门模型（支持树形结构）
- 部门管理 API（CRUD）
- 部门树查询 API
- 部门排序功能
- 部门拖拽排序（前端）

---

## 🔍 库选择评估

### 树形结构实现方案

#### 方案一：Tortoise ORM 自关联 ⭐⭐⭐⭐⭐（推荐）

**简介**：使用 Tortoise ORM 的 `ForeignKeyField` 实现自关联，通过 `parent_id` 字段建立父子关系。

**优势**：
- ✅ Tortoise ORM 原生支持，无需额外库
- ✅ 实现简单，易于理解
- ✅ 查询灵活，支持递归查询
- ✅ 完全符合框架规范

**劣势**：
- ⚠️ 深度递归查询可能性能较差（可通过缓存优化）

**适用场景**：
- ✅ 部门层级相对固定（通常不超过 5 层）
- ✅ 需要灵活的查询和操作
- ✅ 需要完全符合框架规范

**实现复杂度**：⭐⭐（简单）

---

#### 方案二：闭包表（Closure Table） ⭐⭐⭐（可选）

**简介**：使用额外的关联表存储所有父子关系路径，查询性能更好。

**优势**：
- ✅ 查询性能好（无需递归）
- ✅ 支持快速查询任意层级的子部门

**劣势**：
- ⚠️ 需要额外的关联表
- ⚠️ 插入/更新时需要维护关联表
- ⚠️ 实现复杂度较高

**适用场景**：
- 部门层级很深（超过 5 层）
- 需要频繁查询所有子部门
- 对查询性能要求很高

**实现复杂度**：⭐⭐⭐⭐（较高）

---

### 最终推荐方案

**推荐**：✅ **使用 Tortoise ORM 自关联**

**理由**：
1. ✅ Tortoise ORM 原生支持，无需额外库
2. ✅ 实现简单，符合框架规范
3. ✅ 部门层级通常不会太深（3-5 层）
4. ✅ 可以通过缓存优化性能

**如果未来部门层级很深或性能有问题**，再考虑迁移到闭包表。

---

## 🗄️ 数据库设计

### 部门表（root_departments）

```sql
CREATE TABLE root_departments (
    id SERIAL PRIMARY KEY,
    uuid VARCHAR(36) NOT NULL UNIQUE,        -- 业务ID（UUID，对外暴露，安全且唯一）
    tenant_id INTEGER NOT NULL,
    
    -- 部门基本信息
    name VARCHAR(100) NOT NULL,              -- 部门名称
    code VARCHAR(50),                        -- 部门代码（可选，用于程序识别）
    description TEXT,                        -- 部门描述
    manager_id INTEGER,                       -- 部门负责人ID（外键，关联 root_users，内部使用自增ID）
    
    -- 树形结构
    parent_id INTEGER,                       -- 父部门ID（自关联，NULL 表示根部门，内部使用自增ID）
    
    -- 排序和状态
    sort_order INTEGER DEFAULT 0,            -- 排序顺序（同级部门排序）
    is_active BOOLEAN DEFAULT TRUE,          -- 是否启用
    
    -- 标准字段
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL,
    
    -- 索引
    INDEX idx_root_departments_tenant_id (tenant_id),
    INDEX idx_root_departments_uuid (uuid),
    INDEX idx_root_departments_parent_id (parent_id),
    INDEX idx_root_departments_manager_id (manager_id),
    INDEX idx_root_departments_sort_order (sort_order),
    INDEX idx_root_departments_created_at (created_at),
    
    -- 外键
    FOREIGN KEY (parent_id) REFERENCES root_departments(id) ON DELETE SET NULL,
    FOREIGN KEY (manager_id) REFERENCES root_users(id) ON DELETE SET NULL
);
```

**设计要点**：
- ✅ **混合ID方案**：`id`（自增ID，内部使用，性能优先）+ `uuid`（UUID，对外暴露，安全且唯一）
- ✅ `uuid` 字段用于对外API，避免暴露自增ID（安全性）
- ✅ `id` 字段用于内部关联和查询（性能）
- ✅ `parent_id` 自关联，`NULL` 表示根部门（内部使用自增ID）
- ✅ `sort_order` 用于同级部门排序
- ✅ `manager_id` 关联部门负责人（可选，内部使用自增ID）
- ✅ `code` 可选，用于程序识别
- ✅ 软删除支持（`deleted_at`）
- ✅ `ON DELETE SET NULL`：删除父部门时，子部门的 `parent_id` 设为 `NULL`（成为根部门）

---

## 🐍 后端模型设计

### 部门模型（Department）

```python
# riveredge-backend/src/tree-root/models/department.py
from tortoise.models import Model
from tortoise import fields
from typing import Optional, List
from .base import BaseModel


class Department(BaseModel):
    """
    部门模型
    
    支持树形结构，通过 parent_id 实现父子关系。
    每个组织可以定义自己的部门树。
    
    注意：继承自 BaseModel，自动包含 uuid、tenant_id、created_at、updated_at 字段。
    """
    id = fields.IntField(pk=True, description="部门ID（主键，自增ID，内部使用）")
    # uuid 字段由 BaseModel 提供，无需重复定义
    # tenant_id 字段由 BaseModel 提供，无需重复定义
    
    name = fields.CharField(max_length=100, description="部门名称")
    code = fields.CharField(max_length=50, null=True, description="部门代码（可选，用于程序识别）")
    description = fields.TextField(null=True, description="部门描述")
    manager_id = fields.IntField(null=True, description="部门负责人ID（外键，关联 User，内部使用自增ID）")
    
    # 树形结构：自关联
    parent = fields.ForeignKeyField(
        "models.Department",
        related_name="children",
        null=True,
        description="父部门（自关联，NULL 表示根部门）"
    )
    
    # 排序和状态
    sort_order = fields.IntField(default=0, description="排序顺序（同级部门排序）")
    is_active = fields.BooleanField(default=True, description="是否启用")
    
    class Meta:
        table = "root_departments"
        indexes = [
            ("tenant_id",),
            ("parent_id",),
            ("manager_id",),
            ("sort_order",),
            ("created_at",),
        ]
    
    def __str__(self):
        return f"{self.name} ({self.code or 'N/A'})"
    
    async def get_children(self) -> List["Department"]:
        """
        获取直接子部门列表
        
        Returns:
            List[Department]: 子部门列表（按 sort_order 排序）
        """
        return await Department.filter(
            tenant_id=self.tenant_id,
            parent_id=self.id,
            deleted_at__isnull=True
        ).order_by("sort_order", "id").all()
    
    async def get_all_children(self) -> List["Department"]:
        """
        获取所有子部门（递归，包括子部门的子部门）
        
        Returns:
            List[Department]: 所有子部门列表
        """
        children = []
        direct_children = await self.get_children()
        
        for child in direct_children:
            children.append(child)
            # 递归获取子部门的子部门
            grandchildren = await child.get_all_children()
            children.extend(grandchildren)
        
        return children
    
    async def get_path(self) -> List["Department"]:
        """
        获取从根部门到当前部门的路径
        
        Returns:
            List[Department]: 路径列表（从根到当前）
        """
        path = [self]
        current = self
        
        while current.parent_id:
            current = await Department.get(id=current.parent_id)
            path.insert(0, current)
        
        return path
```

**设计要点**：
- ✅ 使用 `ForeignKeyField` 自关联实现树形结构
- ✅ `related_name="children"` 用于反向查询子部门
- ✅ 提供便捷方法：`get_children()`、`get_all_children()`、`get_path()`
- ✅ 所有查询自动过滤 `tenant_id` 和 `deleted_at`

---

## 📡 API 设计

### 1. 部门管理 API

**路由前缀**：`/api/v1/departments`  
**Tags**：`Departments`（英文）

#### 1.1 创建部门

```python
POST /api/v1/departments

Request Body:
{
    "name": "技术部",
    "code": "tech",
    "description": "技术研发部门",
    "parent_uuid": "550e8400-e29b-41d4-a716-446655440001",  // 可选，父部门UUID（NULL 表示根部门）
    "manager_uuid": "550e8400-e29b-41d4-a716-446655440002",  // 可选，部门负责人UUID
    "sort_order": 0,             // 可选，排序顺序
    "is_active": true
}

Response 201:
{
    "id": 2,
    "uuid": "550e8400-e29b-41d4-a716-446655440000",  // UUID（对外暴露）
    "tenant_id": 1,
    "name": "技术部",
    "code": "tech",
    "description": "技术研发部门",
    "parent_id": 1,
    "manager_id": 5,
    "sort_order": 0,
    "is_active": true,
    "created_at": "2025-01-01T00:00:00",
    "updated_at": "2025-01-01T00:00:00"
}
```

**实现要点**：
- ✅ 自动设置 `tenant_id`（从当前用户上下文获取）
- ✅ **请求体使用 `parent_uuid` 和 `manager_uuid`**（需要在Service层转换为ID）
- ✅ 验证 `parent_uuid` 属于当前组织（如果提供）
- ✅ 验证 `manager_uuid` 属于当前组织（如果提供）
- ✅ 需要组织管理员或超级用户权限
- ✅ 如果 `parent_uuid` 为 `NULL`，创建根部门

#### 1.2 获取部门列表（扁平列表）

```python
GET /api/v1/departments?page=1&page_size=20&keyword=技术&parent_uuid=550e8400-e29b-41d4-a716-446655440001&is_active=true

Response 200:
{
    "items": [
        {
            "id": 1,
            "uuid": "550e8400-e29b-41d4-a716-446655440000",  // UUID（对外暴露）
            "name": "技术部",
            "code": "tech",
            "description": "技术研发部门",
            "parent_id": null,
            "manager_id": 5,
            "sort_order": 0,
            "is_active": true,
            "children_count": 3,      // 子部门数量
            "user_count": 10          // 部门用户数量
        }
    ],
    "total": 10,
    "page": 1,
    "page_size": 20
}
```

**实现要点**：
- ✅ 自动过滤组织（只返回当前组织的部门）
- ✅ 支持分页（`page`, `page_size`）
- ✅ 支持关键词搜索（`keyword`：搜索部门名称、代码、描述）
- ✅ 支持筛选（`parent_uuid`, `is_active`，`parent_uuid` 需要在Service层转换为ID）
- ✅ 返回子部门数量和用户数量（用于前端显示）

#### 1.3 获取部门树

```python
GET /api/v1/departments/tree

Response 200:
{
    "items": [
        {
            "id": 1,
            "uuid": "550e8400-e29b-41d4-a716-446655440000",  // UUID（对外暴露）
            "name": "技术部",
            "code": "tech",
            "description": "技术研发部门",
            "parent_id": null,
            "manager_id": 5,
            "sort_order": 0,
            "is_active": true,
            "children_count": 3,
            "user_count": 10,
            "children": [              // 子部门列表（递归）
                {
                    "id": 2,
                    "uuid": "550e8400-e29b-41d4-a716-446655440001",
                    "name": "前端组",
                    "code": "frontend",
                    "parent_id": 1,
                    "sort_order": 0,
                    "children": []
                }
            ]
        }
    ]
}
```

**实现要点**：
- ✅ 自动过滤组织
- ✅ 返回完整的部门树（递归结构）
- ✅ 只返回根部门，子部门嵌套在 `children` 字段中
- ✅ 按 `sort_order` 排序

#### 1.4 获取部门详情

```python
GET /api/v1/departments/{department_uuid}

Response 200:
{
    "id": 1,
    "uuid": "550e8400-e29b-41d4-a716-446655440000",  // UUID（对外暴露）
    "name": "技术部",
    "code": "tech",
    "description": "技术研发部门",
    "parent_id": null,
    "parent": {                        // 父部门信息（如果存在）
        "id": null,
        "uuid": null,
        "name": null
    },
    "manager_id": 5,
    "manager": {                       // 部门负责人信息（如果存在）
        "id": 5,
        "uuid": "550e8400-e29b-41d4-a716-446655440002",
        "username": "zhangsan",
        "full_name": "张三"
    },
    "sort_order": 0,
    "is_active": true,
    "children_count": 3,
    "user_count": 10,
    "path": [                          // 从根到当前的路径
        {
            "id": 1,
            "uuid": "550e8400-e29b-41d4-a716-446655440000",
            "name": "技术部"
        }
    ],
    "created_at": "2025-01-01T00:00:00",
    "updated_at": "2025-01-01T00:00:00"
}
```

**实现要点**：
- ✅ **使用 UUID 作为路径参数**（`{department_uuid}`），而不是 `{department_id}`
- ✅ 自动验证组织权限
- ✅ 返回部门完整信息（包括父部门、负责人、路径等）
- ✅ 响应中包含 `uuid` 字段（对外暴露），`id` 字段保留（内部使用）

#### 1.5 更新部门

```python
PUT /api/v1/departments/{department_uuid}

Request Body:
{
    "name": "技术研发部",
    "description": "更新后的描述",
    "parent_uuid": null,               // 可以修改父部门（使用UUID）
    "sort_order": 1,
    "is_active": true
}

Response 200:
{
    "id": 1,
    "uuid": "550e8400-e29b-41d4-a716-446655440000",
    "name": "技术研发部",
    ...
}
```

**实现要点**：
- ✅ **使用 UUID 作为路径参数**（`{department_uuid}`），而不是 `{department_id}`
- ✅ **请求体使用 `parent_uuid`**（UUID），而不是 `parent_id`（需要在Service层转换为ID）
- ✅ 自动验证组织权限
- ✅ 验证 `parent_uuid` 不能是自己或自己的子部门（防止循环引用）
- ✅ 支持部分更新（Pydantic 的 `exclude_unset=True`）
- ✅ 如果修改 `parent_uuid`，需要重新计算 `sort_order`

#### 1.6 删除部门

```python
DELETE /api/v1/departments/{department_uuid}

Response 204: No Content
```

**实现要点**：
- ✅ **使用 UUID 作为路径参数**（`{department_uuid}`），而不是 `{department_id}`
- ✅ 自动验证组织权限
- ✅ 检查是否有子部门（如果有，返回错误提示）
- ✅ 检查是否有用户（如果有，返回错误提示）
- ✅ 软删除（设置 `deleted_at`）
- ✅ 删除后，子部门的 `parent_id` 设为 `NULL`（成为根部门）

#### 1.7 批量更新排序

```python
PUT /api/v1/departments/sort

Request Body:
{
    "items": [
        {"uuid": "550e8400-e29b-41d4-a716-446655440000", "sort_order": 0},
        {"uuid": "550e8400-e29b-41d4-a716-446655440001", "sort_order": 1},
        {"uuid": "550e8400-e29b-41d4-a716-446655440002", "sort_order": 2}
    ]
}

Response 200:
{
    "success": true,
    "message": "排序更新成功"
}
```

**实现要点**：
- ✅ **请求体使用 `uuid`**（UUID列表），而不是 `id`（需要在Service层转换为ID）
- ✅ 批量更新多个部门的 `sort_order`
- ✅ 验证所有部门属于当前组织
- ✅ 用于前端拖拽排序

---

## 🔧 Service 层设计

### 部门服务（DepartmentService）

```python
# riveredge-backend/src/tree-root/services/department_service.py
from typing import List, Optional, Dict, Any
from tortoise.exceptions import IntegrityError
from models.department import Department
from models.user import User
from schemas.department import DepartmentCreate, DepartmentUpdate
from core.exceptions import NotFoundError, ValidationError, PermissionDeniedError


class DepartmentService:
    """
    部门服务类
    
    提供部门的 CRUD 操作和树形结构管理。
    """
    
    @staticmethod
    async def create_department(
        tenant_id: int,
        data: DepartmentCreate,
        current_user_id: int
    ) -> Department:
        """
        创建部门
        
        Args:
            tenant_id: 组织ID
            data: 部门创建数据
            current_user_id: 当前用户ID
            
        Returns:
            Department: 创建的部门对象
            
        Raises:
            ValidationError: 当父部门不存在或不属于当前组织时抛出
            PermissionDeniedError: 当用户无权限时抛出
        """
        # 验证权限
        # TODO: 实现权限验证逻辑
        
        # 验证父部门（如果提供）
        parent_id = None
        if data.parent_uuid:
            parent = await Department.filter(
                uuid=data.parent_uuid,
                tenant_id=tenant_id,
                deleted_at__isnull=True
            ).first()
            
            if not parent:
                raise ValidationError("父部门不存在或不属于当前组织")
            
            parent_id = parent.id  # 转换为ID用于数据库关联
        
        # 验证部门负责人（如果提供）
        manager_id = None
        if data.manager_uuid:
            manager = await User.filter(
                uuid=data.manager_uuid,
                tenant_id=tenant_id
            ).first()
            
            if not manager:
                raise ValidationError("部门负责人不存在或不属于当前组织")
            
            manager_id = manager.id  # 转换为ID用于数据库关联
        
        # 创建部门
        department = await Department.create(
            tenant_id=tenant_id,
            name=data.name,
            code=data.code,
            description=data.description,
            parent_id=parent_id,
            manager_id=manager_id,
            sort_order=data.sort_order if data.sort_order is not None else 0,
            is_active=data.is_active if data.is_active is not None else True,
        )
        
        return department
    
    @staticmethod
    async def get_department_tree(
        tenant_id: int,
        parent_id: Optional[int] = None
    ) -> List[Dict[str, Any]]:
        """
        获取部门树（递归）
        
        Args:
            tenant_id: 组织ID
            parent_id: 父部门ID（None 表示根部门）
            
        Returns:
            List[Dict]: 部门树列表
        """
        # 获取直接子部门
        departments = await Department.filter(
            tenant_id=tenant_id,
            parent_id=parent_id,
            deleted_at__isnull=True
        ).order_by("sort_order", "id").all()
        
        result = []
        for dept in departments:
            # 获取子部门数量
            children_count = await Department.filter(
                tenant_id=tenant_id,
                parent_id=dept.id,
                deleted_at__isnull=True
            ).count()
            
            # 获取用户数量
            user_count = await User.filter(
                tenant_id=tenant_id,
                department_id=dept.id  # 假设 User 模型有 department_id 字段
            ).count()
            
            # 递归获取子部门
            children = await DepartmentService.get_department_tree(
                tenant_id=tenant_id,
                parent_id=dept.id
            )
            
            result.append({
                "id": dept.id,
                "name": dept.name,
                "code": dept.code,
                "description": dept.description,
                "parent_id": dept.parent_id,
                "manager_id": dept.manager_id,
                "sort_order": dept.sort_order,
                "is_active": dept.is_active,
                "children_count": children_count,
                "user_count": user_count,
                "children": children,
            })
        
        return result
    
    @staticmethod
    async def update_department(
        tenant_id: int,
        department_id: int,
        data: DepartmentUpdate,
        current_user_id: int
    ) -> Department:
        """
        更新部门
        
        Args:
            tenant_id: 组织ID
            department_id: 部门ID
            data: 部门更新数据
            current_user_id: 当前用户ID
            
        Returns:
            Department: 更新后的部门对象
            
        Raises:
            NotFoundError: 当部门不存在时抛出
            ValidationError: 当父部门循环引用时抛出
        """
        # 验证权限
        # TODO: 实现权限验证逻辑
        
        # 获取部门
        department = await Department.filter(
            id=department_id,
            tenant_id=tenant_id,
            deleted_at__isnull=True
        ).first()
        
        if not department:
            raise NotFoundError("部门不存在")
        
        # 验证父部门不能是自己或自己的子部门（防止循环引用）
        parent_id = department.parent_id  # 默认保持原值
        if data.parent_uuid is not None:
            if data.parent_uuid:
                parent = await Department.filter(
                    uuid=data.parent_uuid,
                    tenant_id=tenant_id,
                    deleted_at__isnull=True
                ).first()
                
                if not parent:
                    raise ValidationError("父部门不存在或不属于当前组织")
                
                if parent.id == department_id:
                    raise ValidationError("不能将部门设置为自己的父部门")
                
                # 检查是否是自己子部门
                all_children = await department.get_all_children()
                if any(child.id == parent.id for child in all_children):
                    raise ValidationError("不能将部门设置为子部门的子部门")
                
                parent_id = parent.id  # 转换为ID用于数据库关联
            else:
                parent_id = None  # parent_uuid 为 null，表示设为根部门
        
        # 验证部门负责人（如果提供）
        manager_id = department.manager_id  # 默认保持原值
        if data.manager_uuid is not None:
            if data.manager_uuid:
                manager = await User.filter(
                    uuid=data.manager_uuid,
                    tenant_id=tenant_id
                ).first()
                
                if not manager:
                    raise ValidationError("部门负责人不存在或不属于当前组织")
                
                manager_id = manager.id  # 转换为ID用于数据库关联
            else:
                manager_id = None  # manager_uuid 为 null，表示取消关联
        
        # 更新部门
        update_data = data.dict(exclude_unset=True, exclude={"parent_uuid", "manager_uuid"})
        update_data["parent_id"] = parent_id
        update_data["manager_id"] = manager_id
        for key, value in update_data.items():
            setattr(department, key, value)
        
        await department.save()
        
        return department
    
    @staticmethod
    async def delete_department(
        tenant_id: int,
        department_id: int,
        current_user_id: int
    ) -> None:
        """
        删除部门
        
        Args:
            tenant_id: 组织ID
            department_id: 部门ID
            current_user_id: 当前用户ID
            
        Raises:
            NotFoundError: 当部门不存在时抛出
            ValidationError: 当部门有子部门或用户时抛出
        """
        # 验证权限
        # TODO: 实现权限验证逻辑
        
        # 获取部门
        department = await Department.filter(
            id=department_id,
            tenant_id=tenant_id,
            deleted_at__isnull=True
        ).first()
        
        if not department:
            raise NotFoundError("部门不存在")
        
        # 检查是否有子部门
        children_count = await Department.filter(
            tenant_id=tenant_id,
            parent_id=department_id,
            deleted_at__isnull=True
        ).count()
        
        if children_count > 0:
            raise ValidationError("部门下有子部门，无法删除")
        
        # 检查是否有用户（department_id 关联）
        user_count = await User.filter(
            tenant_id=tenant_id,
            department_id=department_id
        ).count()
        
        if user_count > 0:
            raise ValidationError("部门下有用户，无法删除")
        
        # 检查是否有部门负责人（manager_id 关联）
        manager_count = await Department.filter(
            tenant_id=tenant_id,
            manager_id=department.manager_id,
            deleted_at__isnull=True
        ).count()
        
        # 注意：这里检查的是当前部门是否被其他部门设置为负责人
        # 实际上 manager_id 是关联到用户的，所以这里应该检查是否有用户被设置为负责人
        # 但删除部门时，manager_id 会自动设为 NULL（ON DELETE SET NULL），所以不需要检查
        
        # 软删除
        from datetime import datetime
        department.deleted_at = datetime.now()
        await department.save()
```

---

## 🎨 前端页面设计

### 部门管理页面

**路径**：`/system/departments`  
**组件**：`DepartmentManagementPage`

**功能**：
- ✅ 部门树形列表（使用 Ant Design Tree 组件，可按最佳实践灵活设计布局）
- ✅ 创建部门（Modal 表单，支持选择父部门）
- ✅ 编辑部门（Modal 表单）
- ✅ 删除部门（Popconfirm 确认）
- ✅ 拖拽排序（使用 `react-sortable-tree` 或 Ant Design Tree 的拖拽功能）
- ✅ 查看部门详情（Drawer 抽屉）

**⚠️ 布局说明**：
- ✅ 树形结构页面可按最佳实践灵活设计，不必拘泥固定布局
- ✅ 可参考 [前端页面布局规范.md](./前端页面布局规范.md) 中的树形结构布局方案
- ✅ 核心交互方式（创建/编辑/删除）参考组织管理页面

**树形列表组件**：
```typescript
import { Tree, Button, Space, Modal, Drawer } from 'antd';
import type { DataNode } from 'antd/es/tree';

const DepartmentTree: React.FC = () => {
  const [treeData, setTreeData] = useState<DataNode[]>([]);
  
  // 加载部门树
  const loadTree = async () => {
    const response = await getDepartmentTree();
    setTreeData(convertToTreeData(response.items));
  };
  
  // 转换数据格式
  const convertToTreeData = (departments: Department[]): DataNode[] => {
    return departments.map(dept => ({
      title: (
        <Space>
          <span>{dept.name}</span>
          <span style={{ color: '#999' }}>({dept.user_count}人)</span>
          <Button size="small" onClick={() => handleEdit(dept)}>编辑</Button>
          <Button size="small" danger onClick={() => handleDelete(dept.id)}>删除</Button>
        </Space>
      ),
      key: dept.id,
      children: convertToTreeData(dept.children || []),
    }));
  };
  
  return (
    <Tree
      treeData={treeData}
      draggable
      onDrop={handleDrop}
      defaultExpandAll
    />
  );
};
```

**列定义**（如果使用表格视图）：
```typescript
const columns: ProColumns<Department>[] = [
  {
    title: '部门名称',
    dataIndex: 'name',
    width: 200,
    render: (_, record) => (
      <Space>
        <span>{record.name}</span>
        {record.code && <Tag>{record.code}</Tag>}
      </Space>
    ),
  },
  {
    title: '父部门',
    dataIndex: 'parent_id',
    width: 150,
    hideInSearch: true,
    render: (_, record) => record.parent?.name || '-',
  },
  {
    title: '负责人',
    dataIndex: 'manager_id',
    width: 120,
    hideInSearch: true,
    render: (_, record) => record.manager?.full_name || '-',
  },
  {
    title: '用户数',
    dataIndex: 'user_count',
    width: 100,
    hideInSearch: true,
  },
  {
    title: '状态',
    dataIndex: 'is_active',
    width: 100,
    valueType: 'switch',
    render: (_, record) => (
      <Tag color={record.is_active ? 'green' : 'default'}>
        {record.is_active ? '启用' : '禁用'}
      </Tag>
    ),
  },
  {
    title: '操作',
    valueType: 'option',
    width: 200,
    render: (_, record) => [
      <Button key="edit" onClick={() => handleEdit(record)}>编辑</Button>,
      <Button key="children" onClick={() => handleAddChild(record)}>添加子部门</Button>,
      <Popconfirm
        key="delete"
        title="确定删除此部门吗？"
        onConfirm={() => handleDelete(record.id)}
      >
        <Button danger>删除</Button>
      </Popconfirm>,
    ],
  },
];
```

---

## ✅ 实现检查清单

### 数据库设计
- [ ] 创建 `root_departments` 表
- [ ] 创建所有必要的索引
- [ ] 创建外键约束（自关联、用户关联）

### 后端实现
- [ ] 创建 `Department` 模型
- [ ] 实现树形结构方法（`get_children()`, `get_all_children()`, `get_path()`）
- [ ] 创建 `DepartmentService` 服务类
- [ ] 创建部门管理 API（CRUD）
- [ ] 创建部门树查询 API
- [ ] 实现批量排序 API
- [ ] 实现组织隔离（所有查询自动过滤 `tenant_id`）
- [ ] 实现循环引用检查（防止父部门是自己或子部门）

### 前端实现
- [ ] 创建部门管理页面
- [ ] 创建部门树形组件
- [ ] 创建部门表单组件（创建/编辑）
- [ ] 实现拖拽排序功能
- [ ] 集成 `UniTable` 组件（如果使用表格视图）
- [ ] 实现权限验证（前端根据权限显示/隐藏功能）

### 测试
- [ ] 单元测试（Service 层）
- [ ] API 测试（集成测试）
- [ ] 前端组件测试
- [ ] 树形结构测试（递归查询、循环引用检查）
- [ ] 多组织隔离测试

---

## ⚠️ 关键注意事项

### 1. 组织隔离
- ✅ 所有查询必须自动过滤 `tenant_id`
- ✅ 所有创建必须自动设置 `tenant_id`
- ✅ 所有更新必须验证 `tenant_id` 权限
- ✅ 禁止跨组织数据访问

### 2. 循环引用检查
- ✅ 更新 `parent_id` 时，不能是自己
- ✅ 更新 `parent_id` 时，不能是自己的子部门
- ✅ 删除部门时，检查是否有子部门

### 3. 删除保护
- ✅ 删除部门前，检查是否有子部门（`parent_id` 关联）
- ✅ 删除部门前，检查是否有用户（`department_id` 关联）
- ✅ 删除部门时，`manager_id` 会自动设为 `NULL`（`ON DELETE SET NULL`），无需检查
- ✅ 如果有子部门或用户，返回明确的错误提示

### 4. 性能优化
- ✅ 部门树查询使用缓存（Redis）
- ✅ 深度递归查询限制层级（如最多 10 层）
- ✅ 使用 `prefetch_related` 预加载关联数据

### 5. 代码规范
- ✅ 所有代码使用中文注释
- ✅ API Tags 使用英文（`Departments`）
- ✅ API 描述使用中文（函数文档字符串）
- ✅ 遵循命名规范（snake_case/PascalCase）

---

## 📚 相关文档

- [系统级功能建设计划.md](../系统级功能建设计划.md)
- [系统级功能实施路线图.md](../系统级功能实施路线图.md)
- [系统级功能文件结构规划.md](./系统级功能文件结构规划.md) - ⭐ 文件结构规划
- [前端页面布局规范.md](./前端页面布局规范.md) - ⭐ 前端页面开发规范（树形结构布局）
- [1.角色权限管理最佳实践.md](./1.角色权限管理最佳实践.md) - 依赖：需要权限控制
- [3.职位管理最佳实践.md](./3.职位管理最佳实践.md) - 关联：职位关联部门
- [4.账户管理最佳实践.md](./4.账户管理最佳实践.md) - 关联：部门负责人关联用户，用户关联部门
- [API设计规范.md](../../2.rules/6.API设计规范.md)
- [数据库命名规范.md](../../2.rules/3.数据库命名规范.md)

---

**最后更新**：2025-01-XX

