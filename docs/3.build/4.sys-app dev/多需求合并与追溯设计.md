# 多需求合并与追溯设计

> 销售、计划、采购流程重组优化 - Phase 0 产出  
> 定义 DemandComputation 多需求支持、DemandComputationItem 追溯、混合合并逻辑

## 1. 模型扩展

### 1.1 DemandComputation

| 变更 | 说明 |
|------|------|
| 新增 `demand_ids` | JSONField，存储 `[int]`，表示参与计算的需求 ID 列表 |
| 兼容 `demand_id` | 单需求时，`demand_ids` 仅含一个元素；创建接口同时支持 `demand_id`（单个）和 `demand_ids`（多个） |

**迁移策略**：现有 `demand_id` 保留，新增 `demand_ids`；若 `demand_ids` 为空，从 `demand_id` 构造 `[demand_id]`。

### 1.2 DemandComputationItem

| 变更 | 说明 |
|------|------|
| 新增 `demand_item_ids` | JSONField，存储 `[int]`，表示该计算行由哪些 DemandItem 汇总而来 |
| 填写规则 | BOM 展开时，顶层需求明细 id 写入；下层 BOM 展开行可为空（或记录顶层 id 以简化追溯） |

## 2. 追溯链路

```
WorkOrder / PurchaseOrderItem
    → demand_computation_item_id
        → DemandComputationItem.demand_item_ids
            → DemandItem (DemandItem.id in demand_item_ids)
                → Demand (DemandItem.demand_id)
                    → source_type, source_id (SalesForecast / SalesOrder)
```

### 2.1 追溯接口

| 接口 | 说明 |
|------|------|
| `GET /apps/kuaizhizao/work-orders/{id}/demand-source-chain` | 工单的需求来源链路 |
| `GET /apps/kuaizhizao/purchase-orders/{id}/demand-source-chain` | 采购单的需求来源链路 |
| `GET /apps/kuaizhizao/purchase-requisitions/{id}/demand-source-chain` | 采购申请的需求来源链路 |

**返回示例：**

```json
{
  "chain": [
    { "type": "DemandComputation", "id": 1, "code": "MRP-20250201-001" },
    { "type": "Demand", "id": 1, "code": "D-001", "source_type": "sales_order", "source_id": 10 },
    { "type": "SalesOrder", "id": 10, "code": "SO-20250201-001" }
  ]
}
```

## 3. 混合合并逻辑

### 3.1 允许混合

- 支持销售预测与销售订单混合合并到一个需求计算
- 创建时传入多个 `demand_id`，可来自不同 `demand_type`（sales_forecast / sales_order）

### 3.2 计算类型推断

| 需求组合 | computation_type 推断 |
|----------|------------------------|
| 仅销售预测 | MRP |
| 仅销售订单 | LRP |
| 混合 | 有订单则 LRP 优先；全预测则 MRP |

**执行逻辑**：MRP 与 LRP 分支在计算引擎内保留，按 `computation_type` 执行；混合时按「有订单则 LRP」选择。

### 3.3 需求明细汇总

- 多需求合并时，相同物料的需求数量按需求明细汇总
- `DemandComputationItem.demand_item_ids` 记录参与汇总的 DemandItem.id 列表

## 4. 创建/执行逻辑伪代码

### 4.1 创建需求计算

```
input: demand_ids (List[int]) or demand_id (int)

if demand_ids provided:
    demand_id_list = demand_ids
else:
    demand_id_list = [demand_id]

demands = fetch Demands where id in demand_id_list
validate: all demands audited

computation_type = infer from demands:
    if any d.business_mode == "MTO": "LRP"
    else: "MRP"

create DemandComputation(demand_ids=demand_id_list, computation_type=...)
```

### 4.2 执行需求计算（多需求）

```
for each demand_id in demand_ids:
    demand_items = DemandItem.filter(demand_id=demand_id)
    for item in demand_items:
        expand BOM, create DemandComputationItem
        for each computation item:
            if top-level: set demand_item_ids = [item.id]
            else: set demand_item_ids from parent or []

merge same material_id items (sum quantities, merge demand_item_ids)
```

## 5. 界面展示

### 5.1 需求来源展示

在工单、采购单、采购申请详情中：

- 展示「需求来源」区块
- 可展开链路：销售订单/预测 → 需求 → 需求计算 → 当前单据
- 多需求时，展示多个来源链

### 5.2 需求计算创建

- 支持多选需求（需求管理列表中勾选多个）
- 下推时创建 demand_ids 包含所选需求的 DemandComputation
