# 单据/基础数据编码规则对接改造指导

本文档说明如何将业务页面（基础数据或单据类）对接「编码规则」的自动编码能力，供后续页面改造时按步骤执行。对接后：新建时按规则预填编码（可改），提交时在「未改编码」的前提下正式占用序号，避免重复与空号。

---

## 一、适用场景与参考示例

| 类型     | 适用页面示例                         | 参考实现 |
|----------|--------------------------------------|----------|
| 基础数据 | 厂区、车间、产线、工位、仓库、物料等 | 厂区管理 `master-data/factory/plants` |
| 业务单据 | 销售订单、工单、采购单、出库单等     | 销售订单 `kuaizhizao/sales-management/sales-orders` |

编码字段使用 **普通输入框**（如 `ProFormText`），不接带「生成」按钮的 `CodeField`；自动编码逻辑在页面的「新建」「提交」中手写，与厂区、销售订单保持一致。

---

## 二、前置条件

### 2.1 编码规则页面配置已就绪

- **后端**：在 `riveredge-backend/src/core/config/code_rule_pages.py` 的 `CODE_RULE_PAGES` 中，已存在本页面对应项，且包含：
  - `page_code`：页面唯一标识，如 `kuaizhizao-sales-order`
  - `code_field`：编码在表单中的字段名，如 `order_code`
  - `code_field_label`：如「销售订单编码」
  - `rule_code`：关联的编码规则代码，如 `SALES_ORDER_CODE`
- **前端**：在 `riveredge-frontend/src/config/codeRulePages.ts` 的 `CODE_RULE_PAGES` 中，有相同 `pageCode`、`codeField`、`codeFieldLabel`、`ruleCode` 的配置。

管理员在「系统管理 → 编码规则」中，可为该页面绑定具体规则并勾选「启用自动生成」；前端通过 `utils/codeRulePage` 的 `isAutoGenerateEnabled(pageCode)`、`getPageRuleCode(pageCode)` 读取（含 localStorage 中的用户配置）。

### 2.2 单据类需后端在「创建时兜底」

若为**业务单据**（如销售订单），应在**后端创建接口**中，当编码为空时优先用编码规则生成，失败时再回退到原有默认生成逻辑，保证即使用户不填、前端未预填也能得到合法编码。

---

## 三、前端改造步骤

### 3.1 引入依赖

```ts
import { generateCode, testGenerateCode } from '@/services/codeRule';  // 或按相对路径
import { isAutoGenerateEnabled, getPageRuleCode } from '@/utils/codeRulePage';
```

不再使用 `CodeField` 组件。

### 3.2 增加「预览编码」状态

用于区分「用户沿用预填」与「用户手动修改」，仅在「沿用或为空」时在提交时正式占号。

```ts
const [previewCode, setPreviewCode] = useState<string | null>(null);
```

将上面占位中的 `pageCode`、表单字段名、接口等替换成你当前页面的实际值（下同）。

### 3.3 新建时：预填编码（不占序号）

在 **handleCreate**（或等价「打开新建弹窗」的逻辑）中，在 `resetFields` 之后追加：

```ts
const handleCreate = async () => {
  setIsEdit(false);
  // ... 其它状态与 resetFields、setModalVisible 等

  if (isAutoGenerateEnabled('你的-pageCode')) {
    const ruleCode = getPageRuleCode('你的-pageCode');
    if (ruleCode) {
      try {
        const codeResponse = await testGenerateCode({ rule_code: ruleCode });
        const preview = codeResponse.code;
        setPreviewCode(preview ?? null);
        formRef.current?.setFieldsValue({ 你的编码字段名: preview ?? '' });
      } catch (error: any) {
        console.warn('编码预生成失败:', error);
        setPreviewCode(null);
      }
    } else {
      setPreviewCode(null);
    }
  } else {
    setPreviewCode(null);
  }
};
```

- 仅当「启用自动编码」且有 `ruleCode` 时请求 `testGenerateCode`。
- `testGenerateCode` 只按规则计算下一个编码，**不**更新库中序号。
- 用 `setFieldsValue` 把预览编码填进表单，用户可修改。

### 3.4 提交时：未改编码则正式占号

在 **handleSubmit** 的「创建」分支中，在调用创建 API 之前插入：

```ts
// 创建分支内、调用 createXxx(values) 之前
if (!isEdit && isAutoGenerateEnabled('你的-pageCode')) {
  const ruleCode = getPageRuleCode('你的-pageCode');
  const currentCode = values.你的编码字段名;
  if (ruleCode && (currentCode === previewCode || !currentCode)) {
    try {
      const codeResponse = await generateCode({ rule_code: ruleCode });
      values.你的编码字段名 = codeResponse.code;
    } catch (error: any) {
      console.warn('正式生成编码失败，使用预览编码:', error);
    }
  }
}
await createXxx(values);  // 使用可能被替换后的 values
```

- 仅当「新建 + 启用自动编码」且「编码未改或为空」时调用 `generateCode`，真正占用序号。
- 若用户改了编码，直接使用用户输入，不再调 `generateCode`。

提交成功或关闭弹窗时清空预览状态，避免影响下一次新建：

```ts
setPreviewCode(null);
```

建议在「提交成功」和「Modal onCancel」两处都执行一次。

### 3.5 编码表单项：普通输入框，无「生成」按钮

用 `ProFormText`（或当前项目同类型表单项）即可，**不要**使用 `CodeField`：

```tsx
<ProFormText
  name="你的编码字段名"
  label="编码标签"
  placeholder={
    isAutoGenerateEnabled('你的-pageCode')
      ? '编码将根据编码规则自动生成，可修改'
      : '请输入编码'
  }
  rules={[{ required: true, message: '请输入编码' }]}
  fieldProps={{ disabled: isEdit }}
/>
```

- 编辑时 `disabled: isEdit`，与厂区/销售订单一致。
- 不提供「生成」按钮，避免与「打开新建即预填、提交时正式占号」的流程混淆。

---

## 四、后端改造（仅业务单据需要）

适用于：工单、销售订单、采购单、出库单等「业务单据」创建时，若请求体中编码为空，需要按编码规则生成并写回，失败时再回退到原有逻辑。

### 4.1 在创建方法中「编码为空时生成」

在对应的 Service 的 `create_xxx` 中，在组业务实体、落库之前：

```python
if not payload.编码字段名:
    from core.config.code_rule_pages import CODE_RULE_PAGES
    from core.services.business.code_generation_service import CodeGenerationService

    rule_code = next(
        (p.get("rule_code") for p in CODE_RULE_PAGES if p.get("page_code") == "你的-page-code"),
        None,
    )
    context = {}
    # 若规则中引用业务字段（如 order_date），可放入 context
    if getattr(payload, "order_date", None):
        d = payload.order_date
        context["order_date"] = d.isoformat() if hasattr(d, "isoformat") else str(d)

    code_value = None
    if rule_code:
        try:
            code_value = await CodeGenerationService.generate_code(
                tenant_id=tenant_id,
                rule_code=rule_code,
                context=context or None,
            )
        except Exception as e:
            logger.warning("编码规则生成失败，回退默认: %s", e)
    if not code_value:
        code_value = await self._原有默认生成方法(tenant_id, ...)
    payload.编码字段名 = code_value
```

- `page_code`、`rule_code`、`编码字段名` 与前端及 `code_rule_pages` 配置一致。
- 有业务上下文（日期、类型等）时写入 `context`，供规则表达式或组件使用。

### 4.2 若需「测试生成 + 重复校验」：扩展 _check_code_exists

当前端或其它逻辑会调用「测试生成」且需要按业务实体查重时，需在编码生成服务中为该实体增加分支。  
文件：`riveredge-backend/src/core/services/business/code_generation_service.py`，方法 `_check_code_exists`：

```python
if entity_type == '你的_entity_type':
    from apps.你的应用.models.你的模型 import YourModel
    existing = await YourModel.filter(
        tenant_id=tenant_id,
        编码字段=code,
        deleted_at__isnull=True,
    ).first()
    return existing is not None
```

- `entity_type` 与前端调用 `testGenerateCode(…, entity_type: '你的_entity_type')` 一致（若前端使用测试生成且传了 `entity_type`）。
- 销售订单示例：`entity_type == 'sales_order'`，查 `Demand` 表 `demand_type='sales_order'`, `demand_code=code`。

---

## 五、配置与占位对照表

改造时把下面占位换成你页面的实际值：

| 占位               | 含义           | 示例（销售订单）        |
|--------------------|----------------|-------------------------|
| 你的-pageCode      | 功能页唯一标识 | `kuaizhizao-sales-order` |
| 你的-page-code     | 同上（后端用） | `kuaizhizao-sales-order` |
| 你的编码字段名     | 表单/DTO 字段  | `order_code`            |
| 编码标签           | 表单项 label   | 订单编码                |
| 你的_entity_type   | 测试生成查重用 | `sales_order`           |
| 你的应用/你的模型  | 后端模型所在包 | `kuaizhizao.models.demand` / `Demand` |
| 编码字段           | 模型表字段     | `demand_code`           |

---

## 六、流程小结

1. **打开新建**：若启用自动编码，`testGenerateCode` → 写入表单 + `setPreviewCode(preview)`。
2. **用户**：可沿用预填，也可修改编码。
3. **提交创建**：若编码仍为 `previewCode` 或为空，则 `generateCode` 正式占号并写回 `values`，再调创建 API；否则直接用当前表单编码提交。
4. **后端**（仅单据）：若入参编码为空，优先用编码规则生成并回填，失败再走原有默认逻辑。
5. **编码表单项**：始终为普通输入框，编辑时禁用，不提供「生成」按钮。

按上述步骤改造后，行为与厂区管理、销售订单的编码逻辑一致，便于维护与扩展。

---

**参考文件索引**

- 厂区管理（基础数据）：`riveredge-frontend/src/apps/master-data/pages/factory/plants/index.tsx`
- 销售订单（单据）：`riveredge-frontend/src/apps/kuaizhizao/pages/sales-management/sales-orders/index.tsx`
- 销售订单创建逻辑：`riveredge-backend/src/apps/kuaizhizao/services/sales_order_service.py` 中 `create_sales_order`
- 编码规则页面配置：`core/config/code_rule_pages.py`、前端 `config/codeRulePages.ts`
- 编码生成与查重：`core/services/business/code_generation_service.py`（`generate_code`、`test_generate_code`、`_check_code_exists`）
