# 编码规则字段引用功能说明

> 本文档说明编码规则中如何使用字段引用功能，实现将单据上的字段值设置到编码规则中。

**创建日期**：2026-01-08  
**功能版本**：v1.0  
**适用范围**：所有使用编码规则的业务单据

---

## 目录

1. [功能概述](#1-功能概述)
2. [字段引用语法](#2-字段引用语法)
3. [支持的字段](#3-支持的字段)
4. [使用示例](#4-使用示例)
5. [实现原理](#5-实现原理)
6. [注意事项](#6-注意事项)

---

## 1. 功能概述

### 1.1 功能说明

编码规则字段引用功能允许在编码规则表达式中引用单据上的字段值，实现根据单据字段自动生成编码。

**典型应用场景**：
- 物料编码规则：根据物料分组编码自动生成物料编码
- 工单编码规则：根据产品编码自动生成工单编码
- 其他业务单据：根据关联单据的字段值生成编码

### 1.2 功能优势

- **灵活配置**：支持在编码规则中引用任意字段值
- **自动关联**：系统自动获取字段值，无需手动输入
- **统一管理**：编码规则集中管理，易于维护
- **向后兼容**：兼容现有的编码规则表达式

---

## 2. 字段引用语法

### 2.1 基本语法

字段引用使用 `{FIELD:field_name}` 格式，其中 `field_name` 是字段名称。

**语法格式**：
```
{FIELD:field_name}
```

**示例**：
- `{FIELD:group_code}` - 引用物料分组编码
- `{FIELD:material_type}` - 引用物料类型
- `{FIELD:name}` - 引用物料名称

### 2.2 与其他变量组合使用

字段引用可以与其他编码规则变量组合使用：

**支持的变量类型**：
- `{YYYY}` - 年份（4位）
- `{YY}` - 年份（2位）
- `{MM}` - 月份
- `{DD}` - 日期
- `{SEQ}` - 序号
- `{SEQ:4}` - 序号（4位，不足补0）
- `{DICT:dict_code}` - 数据字典值（待实现）
- `{FIELD:field_name}` - 字段引用（新增）

**组合示例**：
```
{FIELD:group_code}-{YYYY}{MM}{DD}-{SEQ:4}
```

---

## 3. 支持的字段

### 3.1 物料管理字段

物料编码规则支持以下字段引用：

| 字段名称 | 字段标签 | 字段类型 | 说明 |
|---------|---------|---------|------|
| `group_code` | 物料分组编码 | string | 物料所属分组的编码 |
| `group_name` | 物料分组名称 | string | 物料所属分组的名称 |
| `material_type` | 物料类型 | string | 物料类型（FIN/SEMI/RAW/PACK/AUX） |
| `name` | 物料名称 | string | 物料名称 |

### 3.2 扩展字段

系统支持在编码规则页面配置中定义可用字段列表，每个页面可以配置不同的可用字段。

**配置位置**：`riveredge-backend/src/core/config/code_rule_pages.py`

**配置格式**：
```python
{
    "page_code": "master-data-material",
    "page_name": "物料管理",
    "available_fields": [
        {
            "field_name": "group_code",
            "field_label": "物料分组编码",
            "field_type": "string",
            "description": "物料所属分组的编码"
        },
        # ... 更多字段
    ]
}
```

---

## 4. 使用示例

### 4.1 示例1：物料编码包含分组编码

**需求**：物料编码格式为 `{分组编码}-{类型}-{序号}`

**编码规则表达式**：
```
{FIELD:group_code}-{FIELD:material_type}-{SEQ:4}
```

**生成结果**：
- 分组编码：`RAW-MAT`
- 物料类型：`RAW`
- 序号：`0001`
- 生成的编码：`RAW-MAT-RAW-0001`

### 4.2 示例2：物料编码包含分组编码和日期

**需求**：物料编码格式为 `{分组编码}-{日期}-{序号}`

**编码规则表达式**：
```
{FIELD:group_code}-{YYYY}{MM}{DD}-{SEQ:4}
```

**生成结果**：
- 分组编码：`FIN-PROD`
- 日期：`20260108`
- 序号：`0001`
- 生成的编码：`FIN-PROD-20260108-0001`

### 4.3 示例3：物料编码包含分组编码和物料名称首字母

**需求**：物料编码格式为 `{分组编码}-{名称首字母}-{序号}`

**编码规则表达式**：
```
{FIELD:group_code}-{FIELD:name}-{SEQ:4}
```

**注意**：如果需要在编码规则中对字段值进行处理（如提取首字母），需要在后端服务中实现字段值的预处理逻辑。

---

## 5. 实现原理

### 5.1 编码生成流程

1. **获取编码规则**：根据规则代码获取编码规则配置
2. **构建上下文变量**：从单据数据中提取字段值，构建上下文变量字典
3. **渲染表达式**：使用上下文变量替换表达式中的变量占位符
4. **生成编码**：返回生成的编码字符串

### 5.2 字段值获取

字段值的获取逻辑在业务服务中实现，例如物料创建服务：

```python
# 构建上下文变量
context = {}

# 如果指定了分组，添加分组信息到上下文
if group:
    context["group_code"] = group.code
    context["group_name"] = group.name

# 添加物料类型
context["material_type"] = data.material_type

# 添加物料名称
context["name"] = data.name

# 使用编码规则生成编码
main_code = await CodeGenerationService.generate_code(
    tenant_id=tenant_id,
    rule_code="MATERIAL_CODE",
    context=context
)
```

### 5.3 表达式渲染

编码生成服务中的表达式渲染逻辑：

```python
# 替换字段引用变量 {FIELD:field_name}
field_pattern = r'\{FIELD:([^}]+)\}'
def replace_field(match):
    field_name = match.group(1)
    if context and field_name in context:
        return str(context[field_name])
    # 如果字段不存在，返回占位符
    return f"[FIELD:{field_name}]"

code = re.sub(field_pattern, replace_field, code)
```

---

## 6. 注意事项

### 6.1 字段值要求

- **字段必须存在**：如果引用的字段不存在，系统会使用占位符 `[FIELD:field_name]`
- **字段值不能为空**：如果字段值为空，可能导致生成的编码不符合预期
- **字段值格式**：字段值会转换为字符串后使用，确保字段值格式正确

### 6.2 编码规则配置

- **规则代码**：必须在页面配置中指定 `rule_code`
- **自动生成**：页面配置中的 `auto_generate` 必须为 `true`
- **可用字段**：在页面配置中定义 `available_fields` 列表

### 6.3 性能考虑

- **字段查询**：系统会在创建单据时查询关联数据（如物料分组），确保性能
- **缓存机制**：建议对频繁使用的字段值进行缓存（待实现）

### 6.4 错误处理

- **编码规则不存在**：如果编码规则不存在或未启用，系统会回退到默认生成方式
- **字段值缺失**：如果字段值缺失，系统会使用占位符，不会阻止单据创建
- **编码冲突**：如果生成的编码已存在，系统会抛出验证错误

---

## 7. 扩展开发

### 7.1 添加新字段

要为某个页面添加新的可用字段，需要：

1. **更新页面配置**：在 `code_rule_pages.py` 中添加字段定义
2. **更新业务服务**：在创建单据时，将字段值添加到 `context` 中
3. **更新文档**：在本文档中说明新字段的用途

### 7.2 字段值预处理

如果需要对字段值进行预处理（如提取首字母、截取字符串等），可以在业务服务中实现：

```python
# 示例：提取物料名称首字母
if data.name:
    context["name_first_char"] = data.name[0].upper()
```

### 7.3 字段值验证

建议在业务服务中对字段值进行验证，确保字段值符合编码规则的要求：

```python
# 示例：验证分组编码格式
if group and not re.match(r'^[A-Z0-9-]+$', group.code):
    raise ValidationError("分组编码格式不正确")
```

---

## 8. 测试建议

### 8.1 功能测试

- 测试字段引用是否正确替换
- 测试字段值缺失时的处理
- 测试字段值格式是否正确
- 测试编码规则不存在时的回退逻辑

### 8.2 边界测试

- 测试字段值为空字符串
- 测试字段值包含特殊字符
- 测试字段值长度超限
- 测试多个字段引用组合使用

### 8.3 性能测试

- 测试大量并发创建时的性能
- 测试字段查询的性能影响
- 测试编码生成的响应时间

---

**文档结束**
