# 菜单无感更新优化报告

**优化日期**: 2025-12-31  
**优化目标**: 确保APP新增页面后，用户刷新或重新登录即可无感发现新菜单

---

## 📋 优化概述

本次优化解决了应用新增页面后，用户需要手动操作才能看到新菜单的问题。现在用户只需刷新页面或重新登录，就能自动发现新菜单，无需任何额外操作。

---

## ✅ 已完成的优化

### 1. 后端菜单自动同步机制优化

#### 问题描述
- **开发环境**：每次获取菜单时自动扫描并同步
- **生产环境**：需要手动触发同步，不会自动扫描
- **影响**：生产环境下新增页面后，菜单不会自动同步到数据库

#### 优化方案
- **生产环境也自动扫描**：使用时间戳控制扫描频率，避免频繁扫描影响性能
- **智能扫描频率**：
  - 开发环境：每1分钟扫描一次（立即生效）
  - 生产环境：每5分钟扫描一次（平衡性能和实时性）
- **自动清除缓存**：扫描完成后自动清除菜单缓存，确保返回最新数据

#### 修改文件
- `riveredge-backend/src/core/api/menus/menus.py`

#### 修改内容
```python
# 优化前：只有开发环境自动扫描
if os.getenv("ENVIRONMENT", "development") == "development":
    await ApplicationService.scan_and_register_plugins(tenant_id=tenant_id)

# 优化后：生产环境也自动扫描（使用时间戳控制频率）
last_scan_cache_key = f"menu_scan_timestamp:{tenant_id}"
should_scan = False

# 检查上次扫描时间
last_scan_time = await cache_manager.get("menu", last_scan_cache_key)
current_time = time.time()

# 开发环境：每1分钟扫描一次
# 生产环境：每5分钟扫描一次
scan_interval = 60 if is_development else 300

if not last_scan_time or (current_time - last_scan_time) > scan_interval:
    should_scan = True
    await ApplicationService.scan_and_register_plugins(tenant_id=tenant_id)
    await MenuService._clear_menu_cache(tenant_id)
```

### 2. 前端菜单缓存策略优化

#### 问题描述
- **缓存时间过长**：生产环境5分钟缓存，新菜单可能延迟显示
- **刷新策略不完善**：窗口聚焦时不刷新，用户切换标签页回来时看不到新菜单
- **登录时不清除缓存**：用户重新登录时可能看到旧的菜单

#### 优化方案
- **降低缓存时间**：从5分钟降低到2分钟，确保新菜单及时显示
- **启用窗口聚焦刷新**：用户切换标签页回来时自动刷新菜单
- **启用网络重连刷新**：网络重连时自动刷新菜单
- **登录时清除缓存**：用户登录时通过自定义事件清除菜单缓存

#### 修改文件
- `riveredge-frontend/src/layouts/BasicLayout.tsx`
- `riveredge-frontend/src/pages/login/index.tsx`

#### 修改内容

**BasicLayout.tsx**:
```typescript
// 优化前
staleTime: process.env.NODE_ENV === 'development' ? 0 : 5 * 60 * 1000,
refetchOnWindowFocus: process.env.NODE_ENV === 'development' ? true : false,

// 优化后
staleTime: process.env.NODE_ENV === 'development' ? 0 : 2 * 60 * 1000, // 降低到2分钟
refetchOnWindowFocus: true, // 窗口聚焦时刷新
refetchOnReconnect: true, // 网络重连时刷新

// 新增：监听用户登录事件，清除菜单缓存
useEffect(() => {
  const handleUserLogin = () => {
    queryClient.invalidateQueries({ queryKey: ['applicationMenus'] });
  };
  window.addEventListener('user-logged-in', handleUserLogin);
  return () => {
    window.removeEventListener('user-logged-in', handleUserLogin);
  };
}, [queryClient]);
```

**login/index.tsx**:
```typescript
// 优化后：登录成功后触发事件，清除菜单缓存
window.dispatchEvent(new CustomEvent('user-logged-in'));
```

---

## 📊 优化效果

### 优化前
- ❌ 生产环境需要手动同步菜单
- ❌ 前端缓存时间过长（5分钟）
- ❌ 窗口聚焦时不刷新菜单
- ❌ 用户重新登录时可能看到旧菜单
- ⚠️ 新增页面后，用户需要等待或手动操作才能看到新菜单

### 优化后
- ✅ 生产环境自动扫描并同步菜单（每5分钟）
- ✅ 前端缓存时间降低（2分钟）
- ✅ 窗口聚焦时自动刷新菜单
- ✅ 用户登录时自动清除菜单缓存
- ✅ 用户刷新或重新登录即可看到新菜单

---

## 🔧 工作机制

### 菜单同步流程

```
用户请求菜单
  ↓
检查上次扫描时间
  ↓
[超过扫描间隔] → 扫描应用目录
  ↓
读取 manifest.json
  ↓
同步菜单到数据库
  ↓
清除菜单缓存
  ↓
返回最新菜单
```

### 前端菜单刷新机制

```
用户操作
  ↓
[刷新页面] → refetchOnMount → 获取最新菜单
  ↓
[切换标签页] → refetchOnWindowFocus → 获取最新菜单
  ↓
[重新登录] → user-logged-in 事件 → 清除缓存 → 获取最新菜单
  ↓
[网络重连] → refetchOnReconnect → 获取最新菜单
```

---

## 📝 使用场景

### 场景1：开发人员新增页面

1. **开发人员操作**：
   - 在 `manifest.json` 中添加新菜单配置
   - 创建新页面组件

2. **系统自动处理**：
   - 后端自动扫描应用目录（开发环境1分钟，生产环境5分钟）
   - 自动同步菜单到数据库
   - 自动清除菜单缓存

3. **用户体验**：
   - 用户刷新页面 → 自动获取最新菜单 ✅
   - 用户重新登录 → 自动获取最新菜单 ✅
   - 用户切换标签页回来 → 自动获取最新菜单 ✅

### 场景2：应用更新菜单配置

1. **应用更新**：
   - 更新 `manifest.json` 中的 `menu_config`
   - 添加、修改或删除菜单项

2. **系统自动处理**：
   - 下次扫描时自动检测配置变化
   - 自动同步菜单到数据库
   - 自动清除菜单缓存

3. **用户体验**：
   - 无需任何操作，刷新或重新登录即可看到新菜单 ✅

---

## ⚙️ 配置说明

### 后端扫描频率配置

扫描频率通过环境变量和代码逻辑控制：

- **开发环境**：每1分钟扫描一次
- **生产环境**：每5分钟扫描一次

如需调整扫描频率，修改 `riveredge-backend/src/core/api/menus/menus.py` 中的 `scan_interval` 变量：

```python
# 开发环境扫描间隔（秒）
dev_scan_interval = 60

# 生产环境扫描间隔（秒）
prod_scan_interval = 300
```

### 前端缓存时间配置

前端缓存时间通过 `staleTime` 配置：

- **开发环境**：0（不缓存）
- **生产环境**：2分钟

如需调整缓存时间，修改 `riveredge-frontend/src/layouts/BasicLayout.tsx` 中的 `staleTime` 配置：

```typescript
staleTime: process.env.NODE_ENV === 'development' ? 0 : 2 * 60 * 1000
```

---

## ⚠️ 注意事项

1. **扫描频率平衡**
   - 扫描频率过低：新菜单可能延迟显示
   - 扫描频率过高：可能影响系统性能
   - 当前配置（开发1分钟，生产5分钟）已平衡性能和实时性

2. **缓存策略**
   - 前端缓存时间已降低到2分钟，确保新菜单及时显示
   - 用户刷新或重新登录时会强制获取最新菜单

3. **性能影响**
   - 扫描操作是异步的，不会阻塞菜单获取
   - 扫描失败不影响菜单获取（使用 try-except 保护）

4. **开发环境**
   - 开发环境下每次请求都扫描，确保菜单配置修改后立即生效
   - 生产环境下使用时间戳控制，避免频繁扫描

---

## 🔍 验证方法

### 1. 验证菜单自动同步

1. **修改应用菜单配置**：
   ```json
   // manifest.json
   {
     "menu_config": {
       "title": "我的应用",
       "children": [
         {
           "title": "新页面",
           "path": "/apps/my-app/new-page"
         }
       ]
     }
   }
   ```

2. **等待扫描**：
   - 开发环境：等待1分钟
   - 生产环境：等待5分钟

3. **验证菜单**：
   - 刷新页面，检查新菜单是否出现
   - 重新登录，检查新菜单是否出现

### 2. 验证前端缓存刷新

1. **清除浏览器缓存**：
   - 打开开发者工具
   - 清除应用缓存

2. **测试刷新场景**：
   - 刷新页面（F5）→ 应该获取最新菜单
   - 切换标签页回来 → 应该获取最新菜单
   - 重新登录 → 应该获取最新菜单

---

## 📈 后续优化建议

1. **菜单版本号机制**
   - 为菜单添加版本号或时间戳
   - 前端请求时携带当前菜单版本
   - 后端比较版本，只在有更新时返回新菜单

2. **WebSocket 实时推送**
   - 菜单更新时通过 WebSocket 推送通知
   - 前端收到通知后自动刷新菜单
   - 实现真正的实时更新

3. **增量更新**
   - 只同步变更的菜单项
   - 减少数据库操作和网络传输
   - 提升性能和响应速度

4. **菜单更新日志**
   - 记录菜单更新历史
   - 支持菜单回滚
   - 便于问题排查

---

## ✅ 总结

本次优化成功实现了菜单无感更新机制：

1. ✅ **后端自动同步**：生产环境也自动扫描并同步菜单
2. ✅ **前端智能刷新**：用户刷新或重新登录时自动获取最新菜单
3. ✅ **缓存策略优化**：降低缓存时间，确保新菜单及时显示
4. ✅ **用户体验提升**：用户无需任何操作，即可发现新菜单

现在，当APP新增页面时，用户只需：
- **刷新页面** → 自动获取最新菜单 ✅
- **重新登录** → 自动获取最新菜单 ✅
- **切换标签页回来** → 自动获取最新菜单 ✅

完全符合"无感发现新菜单"的期望！

---

**报告生成时间**: 2025-12-31  
**优化完成状态**: ✅ 已完成

