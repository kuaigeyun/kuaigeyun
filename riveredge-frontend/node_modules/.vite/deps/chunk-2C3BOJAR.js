import {
  dispatch_default,
  timer
} from "./chunk-A3W4J62T.js";
import {
  require_color_string
} from "./chunk-OERZF2CA.js";
import {
  _asyncToGenerator,
  _regeneratorRuntime
} from "./chunk-ARQYEDIX.js";
import {
  __assign,
  __classPrivateFieldGet,
  __extends,
  __read,
  __rest,
  __spreadArray,
  __values
} from "./chunk-WJK6EJH2.js";
import {
  _callSuper,
  _classCallCheck,
  _createClass,
  _createForOfIteratorHelper,
  _defineProperty,
  _getPrototypeOf,
  _inherits,
  _objectSpread2,
  _objectWithoutProperties,
  _slicedToArray,
  _toConsumableArray,
  init_defineProperty
} from "./chunk-ZY7H3YXG.js";
import {
  __commonJS,
  __export,
  __pow,
  __toESM
} from "./chunk-JMNN7AZU.js";

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss",
        // Latin Extended-A block.
        "Ā": "A",
        "Ă": "A",
        "Ą": "A",
        "ā": "a",
        "ă": "a",
        "ą": "a",
        "Ć": "C",
        "Ĉ": "C",
        "Ċ": "C",
        "Č": "C",
        "ć": "c",
        "ĉ": "c",
        "ċ": "c",
        "č": "c",
        "Ď": "D",
        "Đ": "D",
        "ď": "d",
        "đ": "d",
        "Ē": "E",
        "Ĕ": "E",
        "Ė": "E",
        "Ę": "E",
        "Ě": "E",
        "ē": "e",
        "ĕ": "e",
        "ė": "e",
        "ę": "e",
        "ě": "e",
        "Ĝ": "G",
        "Ğ": "G",
        "Ġ": "G",
        "Ģ": "G",
        "ĝ": "g",
        "ğ": "g",
        "ġ": "g",
        "ģ": "g",
        "Ĥ": "H",
        "Ħ": "H",
        "ĥ": "h",
        "ħ": "h",
        "Ĩ": "I",
        "Ī": "I",
        "Ĭ": "I",
        "Į": "I",
        "İ": "I",
        "ĩ": "i",
        "ī": "i",
        "ĭ": "i",
        "į": "i",
        "ı": "i",
        "Ĵ": "J",
        "ĵ": "j",
        "Ķ": "K",
        "ķ": "k",
        "ĸ": "k",
        "Ĺ": "L",
        "Ļ": "L",
        "Ľ": "L",
        "Ŀ": "L",
        "Ł": "L",
        "ĺ": "l",
        "ļ": "l",
        "ľ": "l",
        "ŀ": "l",
        "ł": "l",
        "Ń": "N",
        "Ņ": "N",
        "Ň": "N",
        "Ŋ": "N",
        "ń": "n",
        "ņ": "n",
        "ň": "n",
        "ŋ": "n",
        "Ō": "O",
        "Ŏ": "O",
        "Ő": "O",
        "ō": "o",
        "ŏ": "o",
        "ő": "o",
        "Ŕ": "R",
        "Ŗ": "R",
        "Ř": "R",
        "ŕ": "r",
        "ŗ": "r",
        "ř": "r",
        "Ś": "S",
        "Ŝ": "S",
        "Ş": "S",
        "Š": "S",
        "ś": "s",
        "ŝ": "s",
        "ş": "s",
        "š": "s",
        "Ţ": "T",
        "Ť": "T",
        "Ŧ": "T",
        "ţ": "t",
        "ť": "t",
        "ŧ": "t",
        "Ũ": "U",
        "Ū": "U",
        "Ŭ": "U",
        "Ů": "U",
        "Ű": "U",
        "Ų": "U",
        "ũ": "u",
        "ū": "u",
        "ŭ": "u",
        "ů": "u",
        "ű": "u",
        "ų": "u",
        "Ŵ": "W",
        "ŵ": "w",
        "Ŷ": "Y",
        "ŷ": "y",
        "Ÿ": "Y",
        "Ź": "Z",
        "Ż": "Z",
        "Ž": "Z",
        "ź": "z",
        "ż": "z",
        "ž": "z",
        "Ĳ": "IJ",
        "ĳ": "ij",
        "Œ": "Oe",
        "œ": "oe",
        "ŉ": "'n",
        "ſ": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root2 = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index2 = -1, length5 = array == null ? 0 : array.length;
        while (++index2 < length5) {
          var value = array[index2];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index2 = -1, length5 = array == null ? 0 : array.length;
        while (++index2 < length5) {
          if (iteratee(array[index2], index2, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length5 = array == null ? 0 : array.length;
        while (length5--) {
          if (iteratee(array[length5], length5, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index2 = -1, length5 = array == null ? 0 : array.length;
        while (++index2 < length5) {
          if (!predicate(array[index2], index2, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index2 = -1, length5 = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index2 < length5) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length5 = array == null ? 0 : array.length;
        return !!length5 && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index2 = -1, length5 = array == null ? 0 : array.length;
        while (++index2 < length5) {
          if (comparator(value, array[index2])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index2 = -1, length5 = array == null ? 0 : array.length, result = Array(length5);
        while (++index2 < length5) {
          result[index2] = iteratee(array[index2], index2, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index2 = -1, length5 = values.length, offset = array.length;
        while (++index2 < length5) {
          array[offset + index2] = values[index2];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index2 = -1, length5 = array == null ? 0 : array.length;
        if (initAccum && length5) {
          accumulator = array[++index2];
        }
        while (++index2 < length5) {
          accumulator = iteratee(accumulator, array[index2], index2, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length5 = array == null ? 0 : array.length;
        if (initAccum && length5) {
          accumulator = array[--length5];
        }
        while (length5--) {
          accumulator = iteratee(accumulator, array[length5], length5, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index2 = -1, length5 = array == null ? 0 : array.length;
        while (++index2 < length5) {
          if (predicate(array[index2], index2, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length5 = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index2-- : ++index2 < length5) {
          if (predicate(array[index2], index2, array)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index2 = fromIndex - 1, length5 = array.length;
        while (++index2 < length5) {
          if (comparator(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length5 = array == null ? 0 : array.length;
        return length5 ? baseSum(array, iteratee) / length5 : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index2, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length5 = array.length;
        array.sort(comparer);
        while (length5--) {
          array[length5] = array[length5].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index2 = -1, length5 = array.length;
        while (++index2 < length5) {
          var current = iteratee(array[index2]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index2 = -1, result = Array(n);
        while (++index2 < n) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index2 = -1, length5 = strSymbols.length;
        while (++index2 < length5 && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index2 = strSymbols.length;
        while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function countHolders(array, placeholder) {
        var length5 = array.length, result = 0;
        while (length5--) {
          if (array[length5] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data2, result = [];
        while (!(data2 = iterator.next()).done) {
          result.push(data2.value);
        }
        return result;
      }
      function mapToArray(map2) {
        var index2 = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index2] = [key, value];
        });
        return result;
      }
      function overArg(func, transform2) {
        return function(arg) {
          return func(transform2(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index2 = -1, length5 = array.length, resIndex = 0, result = [];
        while (++index2 < length5) {
          var value = array[index2];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index2] = PLACEHOLDER;
            result[resIndex++] = index2;
          }
        }
        return result;
      }
      function setToArray(set7) {
        var index2 = -1, result = Array(set7.size);
        set7.forEach(function(value) {
          result[++index2] = value;
        });
        return result;
      }
      function setToPairs(set7) {
        var index2 = -1, result = Array(set7.size);
        set7.forEach(function(value) {
          result[++index2] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index2 = fromIndex - 1, length5 = array.length;
        while (++index2 < length5) {
          if (array[index2] === value) {
            return index2;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index2 = fromIndex + 1;
        while (index2--) {
          if (array[index2] === value) {
            return index2;
          }
        }
        return index2;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index2 = string.length;
        while (index2-- && reWhitespace.test(string.charAt(index2))) {
        }
        return index2;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root2 : _2.defaults(root2.Object(), context, _2.pick(root2, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto2 = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty4 = objectProto2.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto2.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root2._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty4).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto2.propertyIsEnumerable, splice4 = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike2(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty4.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = /* @__PURE__ */ function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length5 = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length5, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length5 && takeCount == length5) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length5-- && resIndex < takeCount) {
              index2 += dir;
              var iterIndex = -1, value = array[index2];
              while (++iterIndex < iterLength) {
                var data2 = iteratees[iterIndex], iteratee2 = data2.iteratee, type = data2.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index2 = -1, length5 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length5) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data2 = this.__data__;
          if (nativeCreate) {
            var result2 = data2[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty4.call(data2, key) ? data2[key] : undefined2;
        }
        function hashHas(key) {
          var data2 = this.__data__;
          return nativeCreate ? data2[key] !== undefined2 : hasOwnProperty4.call(data2, key);
        }
        function hashSet(key, value) {
          var data2 = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data2[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index2 = -1, length5 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length5) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data2 = this.__data__, index2 = assocIndexOf(data2, key);
          if (index2 < 0) {
            return false;
          }
          var lastIndex = data2.length - 1;
          if (index2 == lastIndex) {
            data2.pop();
          } else {
            splice4.call(data2, index2, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data2 = this.__data__, index2 = assocIndexOf(data2, key);
          return index2 < 0 ? undefined2 : data2[index2][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data2 = this.__data__, index2 = assocIndexOf(data2, key);
          if (index2 < 0) {
            ++this.size;
            data2.push([key, value]);
          } else {
            data2[index2][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index2 = -1, length5 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length5) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data2 = getMapData(this, key), size3 = data2.size;
          data2.set(key, value);
          this.size += data2.size == size3 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index2 = -1, length5 = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index2 < length5) {
            this.add(values2[index2]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data2 = this.__data__ = new ListCache(entries);
          this.size = data2.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data2 = this.__data__, result2 = data2["delete"](key);
          this.size = data2.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data2 = this.__data__;
          if (data2 instanceof ListCache) {
            var pairs = data2.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data2.size;
              return this;
            }
            data2 = this.__data__ = new MapCache(pairs);
          }
          data2.set(key, value);
          this.size = data2.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType2, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length5 = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty4.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length5)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length5 = array.length;
          return length5 ? array[baseRandom(0, length5 - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty4.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length5 = array.length;
          while (length5--) {
            if (eq(array[length5][0], key)) {
              return length5;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys2(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index2 = -1, length5 = paths.length, result2 = Array2(length5), skip = object == null;
          while (++index2 < length5) {
            result2[index2] = skip ? undefined2 : get(object, paths[index2]);
          }
          return result2;
        }
        function baseClamp(number2, lower, upper) {
          if (number2 === number2) {
            if (upper !== undefined2) {
              number2 = number2 <= upper ? number2 : upper;
            }
            if (lower !== undefined2) {
              number2 = number2 >= lower ? number2 : lower;
            }
          }
          return number2;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray2(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys2(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length5 = props.length;
          if (object == null) {
            return !length5;
          }
          object = Object2(object);
          while (length5--) {
            var key = props[length5], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index2 = -1, includes2 = arrayIncludes, isCommon = true, length5 = array.length, result2 = [], valuesLength = values2.length;
          if (!length5) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index2 < length5) {
              var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index2, collection2) {
            result2 = !!predicate(value, index2, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index2 = -1, length5 = array.length;
          while (++index2 < length5) {
            var value = array[index2], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length5 = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length5 ? 0 : length5 + start;
          }
          end = end === undefined2 || end > length5 ? length5 : toInteger(end);
          if (end < 0) {
            end += length5;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index2, collection2) {
            if (predicate(value, index2, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index2 = -1, length5 = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index2 < length5) {
            var value = array[index2];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys2);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys2);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction2(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index2 = 0, length5 = path.length;
          while (object != null && index2 < length5) {
            object = object[toKey(path[index2++])];
          }
          return index2 && index2 == length5 ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty4.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number2, start, end) {
          return number2 >= nativeMin(start, end) && number2 < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length5 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length5 >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index2 = -1, seen = caches[0];
          outer:
            while (++index2 < length5 && result2.length < maxLength) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last2(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike2(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike2(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike2(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty4.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty4.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike2(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index2 = matchData.length, length5 = index2, noCustomizer = !customizer;
          if (object == null) {
            return !length5;
          }
          object = Object2(object);
          while (index2--) {
            var data2 = matchData[index2];
            if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
              return false;
            }
          }
          while (++index2 < length5) {
            data2 = matchData[index2];
            var key = data2[0], objValue = object[key], srcValue = data2[1];
            if (noCustomizer && data2[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike2(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike2(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity5;
          }
          if (typeof value == "object") {
            return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype2(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty4.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype2(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty4.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index2 = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index2] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray2(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction2(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length5 = array.length;
          if (!length5) {
            return;
          }
          n += n < 0 ? length5 : 0;
          return isIndex(n, length5) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray2(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity5];
          }
          var index2 = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index2, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index2 = -1, length5 = paths.length, result2 = {};
          while (++index2 < length5) {
            var path = paths[index2], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf4 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length5 = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index2 < length5) {
            var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf4(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice4.call(seen, fromIndex, 1);
              }
              splice4.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length5 = array ? indexes.length : 0, lastIndex = length5 - 1;
          while (length5--) {
            var index2 = indexes[length5];
            if (length5 == lastIndex || index2 !== previous) {
              var previous = index2;
              if (isIndex(index2)) {
                splice4.call(array, index2, 1);
              } else {
                baseUnset(array, index2);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step2, fromRight) {
          var index2 = -1, length5 = nativeMax(nativeCeil((end - start) / (step2 || 1)), 0), result2 = Array2(length5);
          while (length5--) {
            result2[fromRight ? length5 : ++index2] = start;
            start += step2;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity5), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index2 = -1, length5 = path.length, lastIndex = length5 - 1, nested = object;
          while (nested != null && ++index2 < length5) {
            var key = toKey(path[index2]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index2 != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity5 : function(func, data2) {
          metaMap.set(func, data2);
          return func;
        };
        var baseSetToString = !defineProperty ? identity5 : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index2 = -1, length5 = array.length;
          if (start < 0) {
            start = -start > length5 ? 0 : length5 + start;
          }
          end = end > length5 ? length5 : end;
          if (end < 0) {
            end += length5;
          }
          length5 = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length5);
          while (++index2 < length5) {
            result2[index2] = array[index2 + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index2, collection2) {
            result2 = predicate(value, index2, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity5, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index2 = -1, length5 = array.length, resIndex = 0, result2 = [];
          while (++index2 < length5) {
            var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
            if (!index2 || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray2(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index2 = -1, includes2 = arrayIncludes, length5 = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length5 >= LARGE_ARRAY_SIZE) {
            var set8 = iteratee2 ? null : createSet(array);
            if (set8) {
              return setToArray(set8);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index2 < length5) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last2(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length5 = array.length, index2 = fromRight ? length5 : -1;
          while ((fromRight ? index2-- : ++index2 < length5) && predicate(array[index2], index2, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length5) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length5 : index2);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length5 = arrays.length;
          if (length5 < 2) {
            return length5 ? baseUniq(arrays[0]) : [];
          }
          var index2 = -1, result2 = Array2(length5);
          while (++index2 < length5) {
            var array = arrays[index2], othIndex = -1;
            while (++othIndex < length5) {
              if (othIndex != index2) {
                result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index2 = -1, length5 = props.length, valsLength = values2.length, result2 = {};
          while (++index2 < length5) {
            var value = index2 < valsLength ? values2[index2] : undefined2;
            assignFunc(result2, props[index2], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity5;
        }
        function castPath(value, object) {
          if (isArray2(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString3(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length5 = array.length;
          end = end === undefined2 ? length5 : end;
          return !start && end >= length5 ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id3) {
          return root2.clearTimeout(id3);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length5 = buffer.length, result2 = allocUnsafe ? allocUnsafe(length5) : new buffer.constructor(length5);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array(result2).set(new Uint8Array(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length5 = objCriteria.length, ordersLength = orders.length;
          while (++index2 < length5) {
            var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
            if (result2) {
              if (index2 >= ordersLength) {
                return result2;
              }
              var order = orders[index2];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index2 = -1, length5 = source.length;
          array || (array = Array2(length5));
          while (++index2 < length5) {
            array[index2] = source[index2];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index2 = -1, length5 = props.length;
          while (++index2 < length5) {
            var key = props[index2];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index2 = -1, length5 = sources.length, customizer = length5 > 1 ? sources[length5 - 1] : undefined2, guard = length5 > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length5--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length5 < 3 ? undefined2 : customizer;
              length5 = 1;
            }
            object = Object2(object);
            while (++index2 < length5) {
              var source = sources[index2];
              if (source) {
                assigner(object, source, index2, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike2(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length5 = collection.length, index2 = fromRight ? length5 : -1, iterable = Object2(collection);
            while (fromRight ? index2-- : ++index2 < length5) {
              if (iteratee2(iterable[index2], index2, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index2 = -1, iterable = Object2(object), props = keysFunc(object), length5 = props.length;
            while (length5--) {
              var key = props[fromRight ? length5 : ++index2];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString3(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length5 = arguments.length, args = Array2(length5), index2 = length5, placeholder = getHolder(wrapper);
            while (index2--) {
              args[index2] = arguments[index2];
            }
            var holders = length5 < 3 && args[0] !== placeholder && args[length5 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length5 -= holders.length;
            if (length5 < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length5
              );
            }
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike2(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys2(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index2 = findIndexFunc(collection, predicate, fromIndex);
            return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length5 = funcs.length, index2 = length5, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index2--) {
              var func = funcs[index2];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index2 = wrapper ? index2 : length5;
            while (++index2 < length5) {
              func = funcs[index2];
              var funcName = getFuncName(func), data2 = funcName == "wrapper" ? getData2(func) : undefined2;
              if (data2 && isLaziable(data2[0]) && data2[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data2[4].length && data2[9] == 1) {
                wrapper = wrapper[getFuncName(data2[0])].apply(wrapper, data2[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray2(value)) {
                return wrapper.plant(value).value();
              }
              var index3 = 0, result2 = length5 ? funcs[index3].apply(this, args) : value;
              while (++index3 < length5) {
                result2 = funcs[index3].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length5 = arguments.length, args = Array2(length5), index2 = length5;
            while (index2--) {
              args[index2] = arguments[index2];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length5 -= holdersCount;
            if (isCurried && length5 < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length5
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length5 = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length5 > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length5) {
              args.length = ary2;
            }
            if (this && this !== root2 && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length5, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length5) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length5 / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length5).join("") : result2.slice(0, length5);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step2) {
            if (step2 && typeof step2 != "number" && isIterateeCall(start, end, step2)) {
              end = step2 = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step2 = step2 === undefined2 ? start < end ? 1 : -1 : toFinite(step2);
            return baseRange(start, end, step2, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number2, precision) {
            number2 = toNumber(number2);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number2)) {
              var pair = (toString3(number2) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString3(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number2);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length5 = partials ? partials.length : 0;
          if (!length5) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length5 -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data2 = isBindKey ? undefined2 : getData2(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data2) {
            mergeData(newData, data2);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length5, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data2 ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto2[key]) && !hasOwnProperty4.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject2(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index2 < arrLength) {
            var arrValue = array[index2], othValue = other[index2];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index2 = objLength;
          while (index2--) {
            var key = objProps[index2];
            if (!(isPartial ? key in other : hasOwnProperty4.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index2 < objLength) {
            key = objProps[index2];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten2), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys2, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData2 = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length5 = hasOwnProperty4.call(realNames, result2) ? array.length : 0;
          while (length5--) {
            var data2 = array[length5], otherFunc = data2.func;
            if (otherFunc == null || otherFunc == func) {
              return data2.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty4.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map3, key) {
          var data2 = map3.__data__;
          return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
        }
        function getMatchData(object) {
          var result2 = keys2(object), length5 = result2.length;
          while (length5--) {
            var key = result2[length5], value = object[key];
            result2[length5] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty4.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index2 = -1, length5 = transforms.length;
          while (++index2 < length5) {
            var data2 = transforms[index2], size3 = data2.size;
            switch (data2.type) {
              case "drop":
                start += size3;
                break;
              case "dropRight":
                end -= size3;
                break;
              case "take":
                end = nativeMin(end, start + size3);
                break;
              case "takeRight":
                start = nativeMax(start, end - size3);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index2 = -1, length5 = path.length, result2 = false;
          while (++index2 < length5) {
            var key = toKey(path[index2]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index2 != length5) {
            return result2;
          }
          length5 = object == null ? 0 : object.length;
          return !!length5 && isLength(length5) && isIndex(key, length5) && (isArray2(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length5 = array.length, result2 = new array.constructor(length5);
          if (length5 && typeof array[0] == "string" && hasOwnProperty4.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length5 = details.length;
          if (!length5) {
            return source;
          }
          var lastIndex = length5 - 1;
          details[lastIndex] = (length5 > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length5 > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length5) {
          var type = typeof value;
          length5 = length5 == null ? MAX_SAFE_INTEGER : length5;
          return !!length5 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length5);
        }
        function isIterateeCall(value, index2, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index2;
          if (type == "number" ? isArrayLike2(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
            return eq(object[index2], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray2(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data2 = getData2(other);
          return !!data2 && func === data2[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction2 : stubFalse;
        function isPrototype2(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize3(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data2, source) {
          var bitmask = data2[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data2[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data2;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data2[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data2[3];
            data2[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data2[4] = partials ? replaceHolders(data2[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data2[5];
            data2[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data2[6] = partials ? replaceHolders(data2[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data2[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data2[8] = data2[8] == null ? source[8] : nativeMin(data2[8], source[8]);
          }
          if (data2[9] == null) {
            data2[9] = source[9];
          }
          data2[0] = source[0];
          data2[1] = newBitmask;
          return data2;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform3) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index2 = -1, length5 = nativeMax(args.length - start, 0), array = Array2(length5);
            while (++index2 < length5) {
              array[index2] = args[start + index2];
            }
            index2 = -1;
            var otherArgs = Array2(start + 1);
            while (++index2 < start) {
              otherArgs[index2] = args[index2];
            }
            otherArgs[start] = transform3(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length5 = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length5--) {
            var index2 = indexes[length5];
            array[length5] = isIndex(index2, arrLength) ? oldArray[index2] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root2.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size3) {
          var index2 = -1, length5 = array.length, lastIndex = length5 - 1;
          size3 = size3 === undefined2 ? length5 : size3;
          while (++index2 < size3) {
            var rand = baseRandom(index2, lastIndex), value = array[rand];
            array[rand] = array[index2];
            array[index2] = value;
          }
          array.length = size3;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number2, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size3, guard) {
          if (guard ? isIterateeCall(array, size3, guard) : size3 === undefined2) {
            size3 = 1;
          } else {
            size3 = nativeMax(toInteger(size3), 0);
          }
          var length5 = array == null ? 0 : array.length;
          if (!length5 || size3 < 1) {
            return [];
          }
          var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length5 / size3));
          while (index2 < length5) {
            result2[resIndex++] = baseSlice(array, index2, index2 += size3);
          }
          return result2;
        }
        function compact(array) {
          var index2 = -1, length5 = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index2 < length5) {
            var value = array[index2];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length5 = arguments.length;
          if (!length5) {
            return [];
          }
          var args = Array2(length5 - 1), array = arguments[0], index2 = length5;
          while (index2--) {
            args[index2 - 1] = arguments[index2];
          }
          return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference2 = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last2(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last2(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length5 = array == null ? 0 : array.length;
          if (!length5) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length5);
        }
        function dropRight(array, n, guard) {
          var length5 = array == null ? 0 : array.length;
          if (!length5) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length5 - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length5 = array == null ? 0 : array.length;
          if (!length5) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length5;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length5 = array == null ? 0 : array.length;
          if (!length5) {
            return -1;
          }
          var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index2 < 0) {
            index2 = nativeMax(length5 + index2, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index2);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length5 = array == null ? 0 : array.length;
          if (!length5) {
            return -1;
          }
          var index2 = length5 - 1;
          if (fromIndex !== undefined2) {
            index2 = toInteger(fromIndex);
            index2 = fromIndex < 0 ? nativeMax(length5 + index2, 0) : nativeMin(index2, length5 - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
        }
        function flatten2(array) {
          var length5 = array == null ? 0 : array.length;
          return length5 ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length5 = array == null ? 0 : array.length;
          return length5 ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length5 = array == null ? 0 : array.length;
          if (!length5) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index2 = -1, length5 = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index2 < length5) {
            var pair = pairs[index2];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head2(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf3(array, value, fromIndex) {
          var length5 = array == null ? 0 : array.length;
          if (!length5) {
            return -1;
          }
          var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index2 < 0) {
            index2 = nativeMax(length5 + index2, 0);
          }
          return baseIndexOf(array, value, index2);
        }
        function initial(array) {
          var length5 = array == null ? 0 : array.length;
          return length5 ? baseSlice(array, 0, -1) : [];
        }
        var intersection2 = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last2(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last2(array) {
          var length5 = array == null ? 0 : array.length;
          return length5 ? array[length5 - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length5 = array == null ? 0 : array.length;
          if (!length5) {
            return -1;
          }
          var index2 = length5;
          if (fromIndex !== undefined2) {
            index2 = toInteger(fromIndex);
            index2 = index2 < 0 ? nativeMax(length5 + index2, 0) : nativeMin(index2, length5 - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length5 = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index2) {
            return isIndex(index2, length5) ? +index2 : index2;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index2 = -1, indexes = [], length5 = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index2 < length5) {
            var value = array[index2];
            if (predicate(value, index2, array)) {
              result2.push(value);
              indexes.push(index2);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length5 = array == null ? 0 : array.length;
          if (!length5) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length5;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length5 : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex2(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length5 = array == null ? 0 : array.length;
          if (length5) {
            var index2 = baseSortedIndex(array, value);
            if (index2 < length5 && eq(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length5 = array == null ? 0 : array.length;
          if (length5) {
            var index2 = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length5 = array == null ? 0 : array.length;
          return length5 ? baseSlice(array, 1, length5) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length5 = array == null ? 0 : array.length;
          if (!length5) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length5 - n;
          return baseSlice(array, n < 0 ? 0 : n, length5);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last2(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last2(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq2(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length5 = 0;
          array = arrayFilter(array, function(group2) {
            if (isArrayLikeObject(group2)) {
              length5 = nativeMax(group2.length, length5);
              return true;
            }
          });
          return baseTimes(length5, function(index2) {
            return arrayMap(array, baseProperty(index2));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group2) {
            return apply(iteratee2, undefined2, group2);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last2(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last2(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length5 = arrays.length, iteratee2 = length5 > 1 ? arrays[length5 - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length5 = paths.length, start = length5 ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length5 > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length5 ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length5 && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone9 = wrapperClone(parent2);
            clone9.__index__ = 0;
            clone9.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone9;
            } else {
              result2 = clone9;
            }
            var previous = clone9;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty4.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray2(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter2(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find5 = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map2(collection, iteratee2), depth);
        }
        function forEach4(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy3 = createAggregator(function(result2, value, key) {
          if (hasOwnProperty4.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike2(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length5 = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length5 + fromIndex, 0);
          }
          return isString2(collection) ? fromIndex <= length5 && collection.indexOf(value, fromIndex) > -1 : !!length5 && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index2] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map2(collection, iteratee2) {
          var func = isArray2(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray2(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray2(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce2(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, negate4(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray2(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray2(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size2(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike2(collection)) {
            return isString2(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray2(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length5 = iteratees.length;
          if (length5 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length5 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root2.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce2(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize3(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize3.Cache || MapCache)();
          return memoized;
        }
        memoize3.Cache = MapCache;
        function negate4(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index2 = -1, length5 = nativeMin(args.length, funcsLength);
            while (++index2 < length5) {
              args[index2] = transforms[index2].call(this, args[index2]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce2(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray2(value) ? value : [value];
        }
        function clone8(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys2(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike2(value) && hasOwnProperty4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray2 = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike2(value) {
          return value != null && isLength(value.length) && !isFunction2(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike2(value) && isArrayLike2(value);
        }
        function isBoolean2(value) {
          return value === true || value === false || isObjectLike2(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement3(value) {
          return isObjectLike2(value) && value.nodeType === 1 && !isPlainObject2(value);
        }
        function isEmpty2(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike2(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype2(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty4.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual2(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike2(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction2(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger2(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike2(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch2(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber2(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull2(value) {
          return value === null;
        }
        function isNil2(value) {
          return value == null;
        }
        function isNumber2(value) {
          return typeof value == "number" || isObjectLike2(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject2(value) {
          if (!isObjectLike2(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty4.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger2(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString2(value) {
          return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike2(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined2(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike2(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike2(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike2(value)) {
            return isString2(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString3(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign2 = createAssigner(function(object, source) {
          if (isPrototype2(source) || isArrayLike2(source)) {
            copyObject(source, keys2(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty4.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys2(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create7(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index2 = -1;
          var length5 = sources.length;
          var guard = length5 > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length5 = 1;
          }
          while (++index2 < length5) {
            var source = sources[index2];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto2[key]) && !hasOwnProperty4.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys2(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert4 = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity5));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty4.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys2(object) {
          return isArrayLike2(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit2 = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length5 = paths.length;
          while (length5--) {
            baseUnset(result2, paths[length5]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate4(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index2 = -1, length5 = path.length;
          if (!length5) {
            length5 = 1;
            object = undefined2;
          }
          while (++index2 < length5) {
            var value = object == null ? undefined2 : object[toKey(path[index2])];
            if (value === undefined2) {
              index2 = length5;
              value = defaultValue;
            }
            object = isFunction2(value) ? value.call(object) : value;
          }
          return object;
        }
        function set7(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys2);
        var toPairsIn = createToPairs(keysIn);
        function transform2(object, iteratee2, accumulator) {
          var isArr = isArray2(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
            return iteratee2(accumulator, value, index2, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update2(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys2(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp2(number2, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number2), lower, upper);
        }
        function inRange2(number2, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number2 = toNumber(number2);
          return baseInRange(number2, start, end);
        }
        function random5(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word2, index2) {
          word2 = word2.toLowerCase();
          return result2 + (index2 ? capitalize(word2) : word2);
        });
        function capitalize(string) {
          return upperFirst2(toString3(string).toLowerCase());
        }
        function deburr(string) {
          string = toString3(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString3(string);
          target = baseToString(target);
          var length5 = string.length;
          position = position === undefined2 ? length5 : baseClamp(toInteger(position), 0, length5);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString3(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString3(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word2, index2) {
          return result2 + (index2 ? "-" : "") + word2.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word2, index2) {
          return result2 + (index2 ? " " : "") + word2.toLowerCase();
        });
        var lowerFirst2 = createCaseFirst("toLowerCase");
        function pad2(string, length5, chars) {
          string = toString3(string);
          length5 = toInteger(length5);
          var strLength = length5 ? stringSize(string) : 0;
          if (!length5 || strLength >= length5) {
            return string;
          }
          var mid = (length5 - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length5, chars) {
          string = toString3(string);
          length5 = toInteger(length5);
          var strLength = length5 ? stringSize(string) : 0;
          return length5 && strLength < length5 ? string + createPadding(length5 - strLength, chars) : string;
        }
        function padStart(string, length5, chars) {
          string = toString3(string);
          length5 = toInteger(length5);
          var strLength = length5 ? stringSize(string) : 0;
          return length5 && strLength < length5 ? createPadding(length5 - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString3(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString3(string), n);
        }
        function replace() {
          var args = arguments, string = toString3(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word2, index2) {
          return result2 + (index2 ? "_" : "") + word2.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString3(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word2, index2) {
          return result2 + (index2 ? " " : "") + upperFirst2(word2);
        });
        function startsWith2(string, target, position) {
          string = toString3(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString3(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index2 = 0, interpolate3 = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate3.source + "|" + (interpolate3 === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty4.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index2 = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty4.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString3(value).toLowerCase();
        }
        function toUpper(value) {
          return toString3(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString3(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString3(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString3(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length5 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length5 = "length" in options ? toInteger(options.length) : length5;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString3(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length5 >= strLength) {
            return string;
          }
          var end = length5 - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString3(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index2 = result2.lastIndexOf(separator);
            if (index2 > -1) {
              result2 = result2.slice(0, index2);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString3(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word2, index2) {
          return result2 + (index2 ? " " : "") + word2.toUpperCase();
        });
        var upperFirst2 = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString3(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length5 = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length5 ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index2 = -1;
            while (++index2 < length5) {
              var pair = pairs[index2];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity5(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys2(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys2(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root2._ === this) {
            root2._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index2 = MAX_ARRAY_LENGTH, length5 = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length5, iteratee2);
          while (++index2 < n) {
            iteratee2(index2);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray2(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString3(value)));
        }
        function uniqueId3(prefix) {
          var id3 = ++idCounter;
          return toString3(prefix) + id3;
        }
        var add9 = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil4 = createRound("ceil");
        var divide4 = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor4 = createRound("floor");
        function max6(array) {
          return array && array.length ? baseExtremum(array, identity5, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity5);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min5(array) {
          return array && array.length ? baseExtremum(array, identity5, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply7 = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round5 = createRound("round");
        var subtract6 = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity5) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign2;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create7;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce2;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference2;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter2;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten2;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy3;
        lodash.initial = initial;
        lodash.intersection = intersection2;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert4;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys2;
        lodash.keysIn = keysIn;
        lodash.map = map2;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize3;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate4;
        lodash.nthArg = nthArg;
        lodash.omit = omit2;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set7;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform2;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq2;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update2;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add9;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil4;
        lodash.clamp = clamp2;
        lodash.clone = clone8;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide4;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find5;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor4;
        lodash.forEach = forEach4;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head2;
        lodash.identity = identity5;
        lodash.includes = includes;
        lodash.indexOf = indexOf3;
        lodash.inRange = inRange2;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray2;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike2;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean2;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate2;
        lodash.isElement = isElement3;
        lodash.isEmpty = isEmpty2;
        lodash.isEqual = isEqual2;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction2;
        lodash.isInteger = isInteger2;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch2;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil2;
        lodash.isNull = isNull2;
        lodash.isNumber = isNumber2;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike2;
        lodash.isPlainObject = isPlainObject2;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString2;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined2;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last2;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst2;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max6;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min5;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply7;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad2;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random5;
        lodash.reduce = reduce2;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round5;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size2;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex2;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith2;
        lodash.subtract = subtract6;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString3;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId3;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst2;
        lodash.each = forEach4;
        lodash.eachRight = forEachRight;
        lodash.first = head2;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty4.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index2) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
          var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index2) {
          var takeName = "take" + (index2 ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index2) {
          var dropName = "drop" + (index2 ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity5);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate4(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray2(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray2(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty4.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _2 = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root2._ = _2;
        define(function() {
          return _2;
        });
      } else if (freeModule) {
        (freeModule.exports = _2)._ = _2;
        freeExports._ = _2;
      } else {
        root2._ = _2;
      }
    }).call(exports);
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter3() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter3.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter3.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter3.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len5 = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len5) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len5 - 1); i < len5; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length5 = listeners.length, j;
        for (i = 0; i < length5; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len5) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len5 - 1); j < len5; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter3.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter3.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter3.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length5 = listeners.length; i < length5; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
    EventEmitter3.prefixed = prefix;
    EventEmitter3.EventEmitter = EventEmitter3;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter3;
    }
  }
});

// node_modules/svg-path-parser/parser.js
var require_parser = __commonJS({
  "node_modules/svg-path-parser/parser.js"(exports, module) {
    "use strict";
    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }
    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }
    peg$subclass(peg$SyntaxError, Error);
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        "class": function(expectation) {
          var escapedParts = "", i;
          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }
          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function(expectation) {
          return "any character";
        },
        end: function(expectation) {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex2(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s2) {
        return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex2(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex2(ch);
        });
      }
      function classEscape(s2) {
        return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex2(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex2(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = new Array(expected2.length), i, j;
        for (i = 0; i < expected2.length; i++) {
          descriptions[i] = describeExpectation(expected2[i]);
        }
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {}, peg$startRuleFunctions = { svg_path: peg$parsesvg_path }, peg$startRuleFunction = peg$parsesvg_path, peg$c0 = function(data2) {
        if (!data2) return [];
        for (var cmds2 = [], i = 0; i < data2.length; i++) cmds2 = cmds2.concat.apply(cmds2, data2[i]);
        var first = cmds2[0];
        if (first && first.code == "m") {
          delete first.relative;
          first.code = "M";
        }
        return cmds2;
      }, peg$c1 = function(first, more) {
        return merge(first, more);
      }, peg$c2 = /^[Mm]/, peg$c3 = peg$classExpectation(["M", "m"], false, false), peg$c4 = function(c2, first, more) {
        var move = commands(c2, [first]);
        if (more) move = move.concat(commands(c2 == "M" ? "L" : "l", more[1]));
        return move;
      }, peg$c5 = /^[Zz]/, peg$c6 = peg$classExpectation(["Z", "z"], false, false), peg$c7 = function() {
        return commands("Z");
      }, peg$c8 = /^[Ll]/, peg$c9 = peg$classExpectation(["L", "l"], false, false), peg$c10 = function(c2, args) {
        return commands(c2, args);
      }, peg$c11 = /^[Hh]/, peg$c12 = peg$classExpectation(["H", "h"], false, false), peg$c13 = function(c2, args) {
        return commands(c2, args.map(function(x3) {
          return { x: x3 };
        }));
      }, peg$c14 = /^[Vv]/, peg$c15 = peg$classExpectation(["V", "v"], false, false), peg$c16 = function(c2, args) {
        return commands(c2, args.map(function(y3) {
          return { y: y3 };
        }));
      }, peg$c17 = /^[Cc]/, peg$c18 = peg$classExpectation(["C", "c"], false, false), peg$c19 = function(a2, b, c2) {
        return { x1: a2.x, y1: a2.y, x2: b.x, y2: b.y, x: c2.x, y: c2.y };
      }, peg$c20 = /^[Ss]/, peg$c21 = peg$classExpectation(["S", "s"], false, false), peg$c22 = function(b, c2) {
        return { x2: b.x, y2: b.y, x: c2.x, y: c2.y };
      }, peg$c23 = /^[Qq]/, peg$c24 = peg$classExpectation(["Q", "q"], false, false), peg$c25 = function(a2, b) {
        return { x1: a2.x, y1: a2.y, x: b.x, y: b.y };
      }, peg$c26 = /^[Tt]/, peg$c27 = peg$classExpectation(["T", "t"], false, false), peg$c28 = /^[Aa]/, peg$c29 = peg$classExpectation(["A", "a"], false, false), peg$c30 = function(rx, ry, xrot, large, sweep, xy) {
        return { rx, ry, xAxisRotation: xrot, largeArc: large, sweep, x: xy.x, y: xy.y };
      }, peg$c31 = function(x3, y3) {
        return { x: x3, y: y3 };
      }, peg$c32 = function(n) {
        return n * 1;
      }, peg$c33 = function(parts) {
        return parts.join("") * 1;
      }, peg$c34 = /^[01]/, peg$c35 = peg$classExpectation(["0", "1"], false, false), peg$c36 = function(bit) {
        return bit == "1";
      }, peg$c37 = function() {
        return "";
      }, peg$c38 = ",", peg$c39 = peg$literalExpectation(",", false), peg$c40 = function(parts) {
        return parts.join("");
      }, peg$c41 = ".", peg$c42 = peg$literalExpectation(".", false), peg$c43 = /^[eE]/, peg$c44 = peg$classExpectation(["e", "E"], false, false), peg$c45 = /^[+\-]/, peg$c46 = peg$classExpectation(["+", "-"], false, false), peg$c47 = /^[0-9]/, peg$c48 = peg$classExpectation([["0", "9"]], false, false), peg$c49 = function(digits) {
        return digits.join("");
      }, peg$c50 = /^[ \t\n\r]/, peg$c51 = peg$classExpectation([" ", "	", "\n", "\r"], false, false), peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{ line: 1, column: 1 }], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error2(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos], p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsesvg_path() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsewsp();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsewsp();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsemoveTo_drawTo_commandGroups();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsewsp();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsewsp();
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c0(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemoveTo_drawTo_commandGroups() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsemoveTo_drawTo_commandGroup();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = [];
          s5 = peg$parsewsp();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parsewsp();
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsemoveTo_drawTo_commandGroup();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = [];
            s5 = peg$parsewsp();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parsewsp();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsemoveTo_drawTo_commandGroup();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemoveTo_drawTo_commandGroup() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsemoveto();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = [];
          s5 = peg$parsewsp();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parsewsp();
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsedrawto_command();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = [];
            s5 = peg$parsewsp();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parsewsp();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsedrawto_command();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedrawto_command() {
        var s0;
        s0 = peg$parseclosepath();
        if (s0 === peg$FAILED) {
          s0 = peg$parselineto();
          if (s0 === peg$FAILED) {
            s0 = peg$parsehorizontal_lineto();
            if (s0 === peg$FAILED) {
              s0 = peg$parsevertical_lineto();
              if (s0 === peg$FAILED) {
                s0 = peg$parsecurveto();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsesmooth_curveto();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsequadratic_bezier_curveto();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsesmooth_quadratic_bezier_curveto();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseelliptical_arc();
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsemoveto() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        if (peg$c2.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsewsp();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsecoordinate_pair();
            if (s3 !== peg$FAILED) {
              s4 = peg$currPos;
              s5 = peg$parsecomma_wsp();
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parselineto_argument_sequence();
                if (s6 !== peg$FAILED) {
                  s5 = [s5, s6];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 === peg$FAILED) {
                s4 = null;
              }
              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c4(s1, s3, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclosepath() {
        var s0, s1;
        s0 = peg$currPos;
        if (peg$c5.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c7();
        }
        s0 = s1;
        return s0;
      }
      function peg$parselineto() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (peg$c8.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c9);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsewsp();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parselineto_argument_sequence();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parselineto_argument_sequence() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsecoordinate_pair();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecoordinate_pair();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsecoordinate_pair();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsehorizontal_lineto() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (peg$c11.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c12);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsewsp();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsecoordinate_sequence();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c13(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecoordinate_sequence() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsenumber();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsenumber();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsenumber();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsevertical_lineto() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (peg$c14.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c15);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsewsp();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsecoordinate_sequence();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c16(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecurveto() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (peg$c17.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c18);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsewsp();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsecurveto_argument_sequence();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecurveto_argument_sequence() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsecurveto_argument();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecurveto_argument();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsecurveto_argument();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecurveto_argument() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsecoordinate_pair();
        if (s1 !== peg$FAILED) {
          s2 = peg$parsecomma_wsp();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsecoordinate_pair();
            if (s3 !== peg$FAILED) {
              s4 = peg$parsecomma_wsp();
              if (s4 === peg$FAILED) {
                s4 = null;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsecoordinate_pair();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c19(s1, s3, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesmooth_curveto() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (peg$c20.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c21);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsewsp();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsesmooth_curveto_argument_sequence();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesmooth_curveto_argument_sequence() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsesmooth_curveto_argument();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsesmooth_curveto_argument();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsesmooth_curveto_argument();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesmooth_curveto_argument() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parsecoordinate_pair();
        if (s1 !== peg$FAILED) {
          s2 = peg$parsecomma_wsp();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsecoordinate_pair();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c22(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsequadratic_bezier_curveto() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (peg$c23.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsewsp();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsequadratic_bezier_curveto_argument_sequence();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsequadratic_bezier_curveto_argument_sequence() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsequadratic_bezier_curveto_argument();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsequadratic_bezier_curveto_argument();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsequadratic_bezier_curveto_argument();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsequadratic_bezier_curveto_argument() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parsecoordinate_pair();
        if (s1 !== peg$FAILED) {
          s2 = peg$parsecomma_wsp();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsecoordinate_pair();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c25(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesmooth_quadratic_bezier_curveto() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (peg$c26.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c27);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsewsp();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsesmooth_quadratic_bezier_curveto_argument_sequence();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesmooth_quadratic_bezier_curveto_argument_sequence() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsecoordinate_pair();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecoordinate_pair();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsecoordinate_pair();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseelliptical_arc() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (peg$c28.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c29);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsewsp();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsewsp();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseelliptical_arc_argument_sequence();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseelliptical_arc_argument_sequence() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parseelliptical_arc_argument();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseelliptical_arc_argument();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseelliptical_arc_argument();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseelliptical_arc_argument() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
        s0 = peg$currPos;
        s1 = peg$parsenonnegative_number();
        if (s1 !== peg$FAILED) {
          s2 = peg$parsecomma_wsp();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsenonnegative_number();
            if (s3 !== peg$FAILED) {
              s4 = peg$parsecomma_wsp();
              if (s4 === peg$FAILED) {
                s4 = null;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsenumber();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parsecomma_wsp();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseflag();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parsecomma_wsp();
                      if (s8 === peg$FAILED) {
                        s8 = null;
                      }
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseflag();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parsecomma_wsp();
                          if (s10 === peg$FAILED) {
                            s10 = null;
                          }
                          if (s10 !== peg$FAILED) {
                            s11 = peg$parsecoordinate_pair();
                            if (s11 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c30(s1, s3, s5, s7, s9, s11);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecoordinate_pair() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parsenumber();
        if (s1 !== peg$FAILED) {
          s2 = peg$parsecomma_wsp();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsenumber();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c31(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsenonnegative_number() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parsefloating_point_constant();
        if (s1 === peg$FAILED) {
          s1 = peg$parsedigit_sequence();
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c32(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsenumber() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parsesign();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsefloating_point_constant();
          if (s3 !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s2 = peg$parsesign();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsedigit_sequence();
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c33(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseflag() {
        var s0, s1;
        s0 = peg$currPos;
        if (peg$c34.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c36(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsecomma_wsp() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsewsp();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsewsp();
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsecomma();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsewsp();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsewsp();
            }
            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parsecomma();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsewsp();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsewsp();
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c37();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsecomma() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 44) {
          s0 = peg$c38;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c39);
          }
        }
        return s0;
      }
      function peg$parsefloating_point_constant() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parsefractional_constant();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseexponent();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s2 = peg$parsedigit_sequence();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseexponent();
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c40(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsefractional_constant() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parsedigit_sequence();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s3 = peg$c41;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c42);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsedigit_sequence();
            if (s4 !== peg$FAILED) {
              s2 = [s2, s3, s4];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s2 = peg$parsedigit_sequence();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s3 = peg$c41;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c42);
              }
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c40(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseexponent() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (peg$c43.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c44);
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsesign();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsedigit_sequence();
            if (s4 !== peg$FAILED) {
              s2 = [s2, s3, s4];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c40(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsesign() {
        var s0;
        if (peg$c45.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c46);
          }
        }
        return s0;
      }
      function peg$parsedigit_sequence() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        if (peg$c47.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$c47.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c48);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c49(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsewsp() {
        var s0, s1;
        s0 = peg$currPos;
        if (peg$c50.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c51);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c37();
        }
        s0 = s1;
        return s0;
      }
      function merge(first, more) {
        if (!more) return [first];
        for (var a2 = [first], i = 0, l = more.length; i < l; i++) a2[i + 1] = more[i][1];
        return a2;
      }
      var cmds = { m: "moveto", l: "lineto", h: "horizontal lineto", v: "vertical lineto", c: "curveto", s: "smooth curveto", q: "quadratic curveto", t: "smooth quadratic curveto", a: "elliptical arc", z: "closepath" };
      for (var code in cmds) cmds[code.toUpperCase()] = cmds[code];
      function commands(code2, args) {
        if (!args) args = [{}];
        for (var i = args.length; i--; ) {
          var cmd = { code: code2, command: cmds[code2] };
          if (code2 == code2.toLowerCase()) cmd.relative = true;
          for (var k in args[i]) cmd[k] = args[i][k];
          args[i] = cmd;
        }
        return args;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    module.exports = {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }
});

// node_modules/svg-path-parser/index.js
var require_svg_path_parser = __commonJS({
  "node_modules/svg-path-parser/index.js"(exports, module) {
    var parserFunction = require_parser().parse;
    parserFunction.parseSVG = parserFunction;
    parserFunction.makeAbsolute = makeSVGPathCommandsAbsolute;
    module.exports = parserFunction;
    function makeSVGPathCommandsAbsolute(commands) {
      var subpathStart, prevCmd = { x: 0, y: 0 };
      var attr2 = { x: "x0", y: "y0", x1: "x0", y1: "y0", x2: "x0", y2: "y0" };
      commands.forEach(function(cmd) {
        if (cmd.command === "moveto") subpathStart = cmd;
        cmd.x0 = prevCmd.x;
        cmd.y0 = prevCmd.y;
        for (var a2 in attr2) if (a2 in cmd) cmd[a2] += cmd.relative ? cmd[attr2[a2]] : 0;
        if (!("x" in cmd)) cmd.x = prevCmd.x;
        if (!("y" in cmd)) cmd.y = prevCmd.y;
        cmd.relative = false;
        cmd.code = cmd.code.toUpperCase();
        if (cmd.command == "closepath") {
          cmd.x = subpathStart.x;
          cmd.y = subpathStart.y;
        }
        prevCmd = cmd;
      });
      return commands;
    }
  }
});

// node_modules/@antv/util/esm/lodash/is-array-like.js
var isArrayLike = function(value) {
  return value !== null && typeof value !== "function" && isFinite(value.length);
};
var is_array_like_default = isArrayLike;

// node_modules/@antv/util/esm/lodash/filter.js
var filter = function(arr, func) {
  if (!is_array_like_default(arr)) {
    return arr;
  }
  var result = [];
  for (var index2 = 0; index2 < arr.length; index2++) {
    var value = arr[index2];
    if (func(value, index2)) {
      result.push(value);
    }
  }
  return result;
};
var filter_default = filter;

// node_modules/@antv/util/esm/lodash/is-function.js
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/@antv/util/esm/lodash/is-nil.js
function isNil(value) {
  return value === null || value === void 0;
}

// node_modules/@antv/util/esm/lodash/is-array.js
function isArray(value) {
  return Array.isArray(value);
}

// node_modules/@antv/util/esm/lodash/is-object.js
var is_object_default = function(value) {
  var type = typeof value;
  return value !== null && type === "object" || type === "function";
};

// node_modules/@antv/util/esm/lodash/is-object-like.js
var isObjectLike = function(value) {
  return typeof value === "object" && value !== null;
};
var is_object_like_default = isObjectLike;

// node_modules/@antv/util/esm/lodash/is-type.js
var toString = {}.toString;
var isType = function(value, type) {
  return toString.call(value) === "[object " + type + "]";
};
var is_type_default = isType;

// node_modules/@antv/util/esm/lodash/is-plain-object.js
var isPlainObject = function(value) {
  if (!is_object_like_default(value) || !is_type_default(value, "Object")) {
    return false;
  }
  if (Object.getPrototypeOf(value) === null) {
    return true;
  }
  var proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
};
var is_plain_object_default = isPlainObject;

// node_modules/@antv/util/esm/lodash/is-string.js
function isString(value) {
  return typeof value === "string";
}

// node_modules/@antv/util/esm/lodash/group-by.js
var hasOwnProperty = Object.prototype.hasOwnProperty;
function groupBy(data2, condition) {
  if (!condition || !isArray(data2)) {
    return {};
  }
  var result = {};
  var predicate = isFunction(condition) ? condition : function(item2) {
    return item2[condition];
  };
  var key;
  for (var i = 0; i < data2.length; i++) {
    var item = data2[i];
    key = predicate(item);
    if (hasOwnProperty.call(result, key)) {
      result[key].push(item);
    } else {
      result[key] = [item];
    }
  }
  return result;
}
var group_by_default = groupBy;

// node_modules/@antv/util/esm/lodash/clamp.js
var clamp = function(a2, min5, max6) {
  if (a2 < min5) {
    return min5;
  } else if (a2 > max6) {
    return max6;
  }
  return a2;
};
var clamp_default = clamp;

// node_modules/@antv/util/esm/lodash/is-number.js
function isNumber(value) {
  return typeof value === "number";
}

// node_modules/@antv/util/esm/lodash/to-string.js
var to_string_default = function(value) {
  if (isNil(value))
    return "";
  return value.toString();
};

// node_modules/@antv/util/esm/lodash/lower-first.js
var lowerFirst = function(value) {
  var str7 = to_string_default(value);
  return str7.charAt(0).toLowerCase() + str7.substring(1);
};
var lower_first_default = lowerFirst;

// node_modules/@antv/util/esm/lodash/upper-first.js
var upperFirst = function(value) {
  var str7 = to_string_default(value);
  return str7.charAt(0).toUpperCase() + str7.substring(1);
};
var upper_first_default = upperFirst;

// node_modules/@antv/util/esm/lodash/is-boolean.js
var isBoolean = function(value) {
  return is_type_default(value, "Boolean");
};
var is_boolean_default = isBoolean;

// node_modules/@antv/util/esm/lodash/is-date.js
function isDate(value) {
  return value instanceof Date;
}

// node_modules/@antv/util/esm/lodash/is-undefined.js
var isUndefined = function(value) {
  return value === void 0;
};
var is_undefined_default = isUndefined;

// node_modules/@antv/util/esm/lodash/debounce.js
function debounce(func, wait, immediate) {
  var timeout;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
}
var debounce_default = debounce;

// node_modules/@antv/util/esm/lodash/memoize.js
function flru(max6) {
  var num, curr, prev;
  var limit = max6 || 1;
  function keep(key, value) {
    if (++num > limit) {
      prev = curr;
      reset(1);
      ++num;
    }
    curr[key] = value;
  }
  function reset(isPartial) {
    num = 0;
    curr = /* @__PURE__ */ Object.create(null);
    isPartial || (prev = /* @__PURE__ */ Object.create(null));
  }
  reset();
  return {
    clear: reset,
    has: function(key) {
      return curr[key] !== void 0 || prev[key] !== void 0;
    },
    get: function(key) {
      var val = curr[key];
      if (val !== void 0)
        return val;
      if ((val = prev[key]) !== void 0) {
        keep(key, val);
        return val;
      }
    },
    set: function(key, value) {
      if (curr[key] !== void 0) {
        curr[key] = value;
      } else {
        keep(key, value);
      }
    }
  };
}
var CacheMap = /* @__PURE__ */ new Map();
function memoize(fn, resolver, maxSize) {
  if (maxSize === void 0) {
    maxSize = 128;
  }
  var memoized = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    if (!CacheMap.has(fn))
      CacheMap.set(fn, flru(maxSize));
    var cache = CacheMap.get(fn);
    if (cache.has(key))
      return cache.get(key);
    var result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
  return memoized;
}

// node_modules/@antv/util/esm/lodash/deep-mix.js
var MAX_MIX_LEVEL = 5;
function hasOwn(object, property) {
  if (Object.hasOwn) {
    return Object.hasOwn(object, property);
  }
  if (object == null) {
    throw new TypeError("Cannot convert undefined or null to object");
  }
  return Object.prototype.hasOwnProperty.call(Object(object), property);
}
function _deepMix(dist4, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL;
  for (var key in src) {
    if (hasOwn(src, key)) {
      var value = src[key];
      if (value !== null && is_plain_object_default(value)) {
        if (!is_plain_object_default(dist4[key])) {
          dist4[key] = {};
        }
        if (level < maxLevel) {
          _deepMix(dist4[key], value, level + 1, maxLevel);
        } else {
          dist4[key] = src[key];
        }
      } else if (isArray(value)) {
        dist4[key] = [];
        dist4[key] = dist4[key].concat(value);
      } else if (value !== void 0) {
        dist4[key] = value;
      }
    }
  }
}
var deepMix = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i = 0; i < args.length; i += 1) {
    _deepMix(rst, args[i]);
  }
  return rst;
};
var deep_mix_default = deepMix;

// node_modules/@antv/util/esm/lodash/get-type.js
var toString2 = {}.toString;
var getType = function(value) {
  return toString2.call(value).replace(/^\[object /, "").replace(/]$/, "");
};
var get_type_default = getType;

// node_modules/@antv/util/esm/lodash/is-prototype.js
var objectProto = Object.prototype;
var isPrototype = function(value) {
  var Ctor = value && value.constructor;
  var proto = typeof Ctor === "function" && Ctor.prototype || objectProto;
  return value === proto;
};
var is_prototype_default = isPrototype;

// node_modules/@antv/util/esm/lodash/is-empty.js
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
function isEmpty(value) {
  if (isNil(value)) {
    return true;
  }
  if (is_array_like_default(value)) {
    return !value.length;
  }
  var type = get_type_default(value);
  if (type === "Map" || type === "Set") {
    return !value.size;
  }
  if (is_prototype_default(value)) {
    return !Object.keys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty2.call(value, key)) {
      return false;
    }
  }
  return true;
}
var is_empty_default = isEmpty;

// node_modules/@antv/util/esm/lodash/is-equal.js
var isEqual = function(value, other) {
  if (value === other) {
    return true;
  }
  if (!value || !other) {
    return false;
  }
  if (isString(value) || isString(other)) {
    return false;
  }
  if (is_array_like_default(value) || is_array_like_default(other)) {
    if (value.length !== other.length) {
      return false;
    }
    var rst = true;
    for (var i = 0; i < value.length; i++) {
      rst = isEqual(value[i], other[i]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  if (is_object_like_default(value) || is_object_like_default(other)) {
    var valueKeys = Object.keys(value);
    var otherKeys = Object.keys(other);
    if (valueKeys.length !== otherKeys.length) {
      return false;
    }
    var rst = true;
    for (var i = 0; i < valueKeys.length; i++) {
      rst = isEqual(value[valueKeys[i]], other[valueKeys[i]]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  return false;
};
var is_equal_default = isEqual;

// node_modules/@antv/util/esm/lodash/get.js
var get_default = function(obj, key, defaultValue) {
  var p = 0;
  var keyArr = isString(key) ? key.split(".") : key;
  while (obj && p < keyArr.length) {
    obj = obj[keyArr[p++]];
  }
  return obj === void 0 || p < keyArr.length ? defaultValue : obj;
};

// node_modules/@antv/util/esm/lodash/set.js
var set_default = function(obj, path, value) {
  var o = obj;
  var keyArr = isString(path) ? path.split(".") : path;
  keyArr.forEach(function(key, idx) {
    if (idx < keyArr.length - 1) {
      if (!is_object_default(o[key])) {
        o[key] = isNumber(keyArr[idx + 1]) ? [] : {};
      }
      o = o[key];
    } else {
      o[key] = value;
    }
  });
  return obj;
};

// node_modules/@antv/util/esm/lodash/each.js
function each(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (isArray(elements)) {
    for (var i = 0, len5 = elements.length; i < len5; i++) {
      rst = func(elements[i], i);
      if (rst === false) {
        break;
      }
    }
  } else if (is_object_default(elements)) {
    for (var k in elements) {
      if (elements.hasOwnProperty(k)) {
        rst = func(elements[k], k);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var each_default = each;

// node_modules/@antv/util/esm/lodash/pick.js
var hasOwnProperty3 = Object.prototype.hasOwnProperty;
var pick_default = function(object, keys2) {
  if (object === null || !is_plain_object_default(object)) {
    return {};
  }
  var result = {};
  each_default(keys2, function(key) {
    if (hasOwnProperty3.call(object, key)) {
      result[key] = object[key];
    }
  });
  return result;
};

// node_modules/@antv/util/esm/lodash/reduce.js
var reduce = function(arr, fn, init) {
  if (!isArray(arr) && !is_plain_object_default(arr)) {
    return arr;
  }
  var result = init;
  each_default(arr, function(data2, i) {
    result = fn(result, data2, i);
  });
  return result;
};
var reduce_default = reduce;

// node_modules/@antv/util/esm/lodash/omit.js
var omit_default = function(obj, keys2) {
  return reduce_default(obj, function(r, curr, key) {
    if (!keys2.includes(key)) {
      r[key] = curr;
    }
    return r;
  }, {});
};

// node_modules/@antv/util/esm/lodash/throttle.js
var throttle_default = function(func, wait, options) {
  var timeout, context, args, result;
  var previous = 0;
  if (!options)
    options = {};
  var later = function() {
    previous = options.leading === false ? 0 : Date.now();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout)
      context = args = null;
  };
  var throttled = function() {
    var now = Date.now();
    if (!previous && options.leading === false)
      previous = now;
    var remaining = wait - (now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      result = func.apply(context, args);
      if (!timeout)
        context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };
  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };
  return throttled;
};

// node_modules/@antv/util/esm/lodash/unique-id.js
var map = {};
var unique_id_default = function(prefix) {
  prefix = prefix || "g";
  if (!map[prefix]) {
    map[prefix] = 1;
  } else {
    map[prefix] += 1;
  }
  return prefix + map[prefix];
};

// node_modules/@antv/util/esm/lodash/contains.js
var contains = function(arr, value) {
  if (!is_array_like_default(arr)) {
    return false;
  }
  return arr.indexOf(value) > -1;
};
var contains_default = contains;

// node_modules/@antv/util/esm/lodash/difference.js
var difference = function(arr, values) {
  if (values === void 0) {
    values = [];
  }
  return filter_default(arr, function(value) {
    return !contains_default(values, value);
  });
};
var difference_default = difference;

// node_modules/@antv/util/esm/lodash/keys.js
var keys = Object.keys ? function(obj) {
  return Object.keys(obj);
} : function(obj) {
  var result = [];
  each_default(obj, function(value, key) {
    if (!(isFunction(obj) && key === "prototype")) {
      result.push(key);
    }
  });
  return result;
};
var keys_default = keys;

// node_modules/@antv/util/esm/lodash/is-match.js
function isMatch(obj, attrs) {
  var _keys = keys_default(attrs);
  var length5 = _keys.length;
  if (isNil(obj))
    return !length5;
  for (var i = 0; i < length5; i += 1) {
    var key = _keys[i];
    if (attrs[key] !== obj[key] || !(key in obj)) {
      return false;
    }
  }
  return true;
}
var is_match_default = isMatch;

// node_modules/@antv/util/esm/lodash/find.js
function find(arr, predicate) {
  if (!isArray(arr))
    return null;
  var _predicate;
  if (isFunction(predicate)) {
    _predicate = predicate;
  }
  if (is_plain_object_default(predicate)) {
    _predicate = function(a2) {
      return is_match_default(a2, predicate);
    };
  }
  if (_predicate) {
    for (var i = 0; i < arr.length; i += 1) {
      if (_predicate(arr[i])) {
        return arr[i];
      }
    }
  }
  return null;
}
var find_default = find;

// node_modules/@antv/util/esm/lodash/flatten.js
var flatten = function(arr) {
  if (!isArray(arr)) {
    return [];
  }
  var rst = [];
  for (var i = 0; i < arr.length; i++) {
    rst = rst.concat(arr[i]);
  }
  return rst;
};
var flatten_default = flatten;

// node_modules/@antv/util/esm/lodash/max.js
function max(arr) {
  if (!Array.isArray(arr))
    return -Infinity;
  var length5 = arr.length;
  if (!length5)
    return -Infinity;
  var max6 = arr[0];
  for (var i = 1; i < length5; i++) {
    max6 = Math.max(max6, arr[i]);
  }
  return max6;
}

// node_modules/@antv/util/esm/lodash/min.js
var min_default = function(arr) {
  if (!isArray(arr)) {
    return void 0;
  }
  return arr.reduce(function(prev, curr) {
    return Math.min(prev, curr);
  }, arr[0]);
};

// node_modules/@antv/util/esm/lodash/pull.js
var arrPrototype = Array.prototype;
var splice = arrPrototype.splice;
var indexOf = arrPrototype.indexOf;

// node_modules/@antv/util/esm/lodash/pull-at.js
var splice2 = Array.prototype.splice;

// node_modules/@antv/util/esm/lodash/uniq.js
function uniq(arr, cache) {
  if (cache === void 0) {
    cache = /* @__PURE__ */ new Map();
  }
  var r = [];
  if (Array.isArray(arr)) {
    for (var i = 0, len5 = arr.length; i < len5; i++) {
      var item = arr[i];
      if (!cache.has(item)) {
        r.push(item);
        cache.set(item, true);
      }
    }
  }
  return r;
}

// node_modules/@antv/util/esm/lodash/head.js
function head(o) {
  if (is_array_like_default(o)) {
    return o[0];
  }
  return void 0;
}

// node_modules/@antv/util/esm/lodash/last.js
function last(o) {
  if (is_array_like_default(o)) {
    var arr = o;
    return arr[arr.length - 1];
  }
  return void 0;
}

// node_modules/@antv/util/esm/lodash/is-number-equal.js
var PRECISION = 1e-5;
function isNumberEqual(a2, b, precision) {
  if (precision === void 0) {
    precision = PRECISION;
  }
  return a2 === b || Math.abs(a2 - b) < precision;
}

// node_modules/@antv/util/esm/lodash/max-by.js
var max_by_default = function(arr, fn) {
  if (!isArray(arr)) {
    return void 0;
  }
  var maxItem;
  var max6 = -Infinity;
  for (var i = 0; i < arr.length; i++) {
    var item = arr[i];
    var v = isFunction(fn) ? fn(item) : item[fn];
    if (v > max6) {
      maxItem = item;
      max6 = v;
    }
  }
  return maxItem;
};

// node_modules/@antv/util/esm/lodash/min-by.js
var min_by_default = function(arr, fn) {
  if (!isArray(arr)) {
    return void 0;
  }
  var minItem;
  var min5 = Infinity;
  for (var i = 0; i < arr.length; i++) {
    var item = arr[i];
    var v = isFunction(fn) ? fn(item) : item[fn];
    if (v < min5) {
      minItem = item;
      min5 = v;
    }
  }
  return minItem;
};

// node_modules/@antv/util/esm/lodash/mod.js
var mod = function(n, m2) {
  return (n % m2 + m2) % m2;
};
var mod_default = mod;

// node_modules/@antv/util/esm/lodash/to-degree.js
var DEGREE = 180 / Math.PI;

// node_modules/@antv/util/esm/lodash/to-radian.js
var RADIAN = Math.PI / 180;

// node_modules/@antv/util/esm/lodash/substitute.js
function substitute(str7, o) {
  if (!str7 || !o) {
    return str7;
  }
  return str7.replace(/\\?\{([^{}]+)\}/g, function(match, name) {
    if (match.charAt(0) === "\\") {
      return match.slice(1);
    }
    return o[name] === void 0 ? "" : o[name];
  });
}
var substitute_default = substitute;

// node_modules/@antv/util/esm/lodash/is-null.js
function isNull(value) {
  return value === null;
}

// node_modules/@antv/util/esm/lodash/is-element.js
function isElement(value) {
  return value instanceof Element || value instanceof Document;
}

// node_modules/@antv/util/esm/lodash/mix.js
function _mix(dist4, obj) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key) && key !== "constructor" && obj[key] !== void 0) {
      dist4[key] = obj[key];
    }
  }
}
function mix(dist4, src1, src2, src3) {
  if (src1)
    _mix(dist4, src1);
  if (src2)
    _mix(dist4, src2);
  if (src3)
    _mix(dist4, src3);
  return dist4;
}

// node_modules/@antv/util/esm/lodash/clone.js
var clone = function(obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  var rst;
  if (isArray(obj)) {
    rst = [];
    for (var i = 0, l = obj.length; i < l; i++) {
      if (typeof obj[i] === "object" && obj[i] != null) {
        rst[i] = clone(obj[i]);
      } else {
        rst[i] = obj[i];
      }
    }
  } else {
    rst = {};
    for (var k in obj) {
      if (typeof obj[k] === "object" && obj[k] != null) {
        rst[k] = clone(obj[k]);
      } else {
        rst[k] = obj[k];
      }
    }
  }
  return rst;
};
var clone_default = clone;

// node_modules/@antv/util/esm/lodash/index-of.js
var indexOf2 = function(arr, obj) {
  if (!is_array_like_default(arr)) {
    return -1;
  }
  var m2 = Array.prototype.indexOf;
  if (m2) {
    return m2.call(arr, obj);
  }
  var index2 = -1;
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] === obj) {
      index2 = i;
      break;
    }
  }
  return index2;
};
var index_of_default = indexOf2;

// node_modules/@antv/util/esm/lodash/map-values.js
var identity = function(v) {
  return v;
};
var map_values_default = function(object, func) {
  if (func === void 0) {
    func = identity;
  }
  var r = {};
  if (is_object_default(object) && !isNil(object)) {
    Object.keys(object).forEach(function(key) {
      r[key] = func(object[key], key);
    });
  }
  return r;
};

// node_modules/@antv/util/esm/lodash/noop.js
var noop_default = function() {
};

// node_modules/@antv/util/esm/lodash/identity.js
var identity_default = function(v) {
  return v;
};

// node_modules/@antv/util/esm/lodash/size.js
function size(o) {
  if (isNil(o)) {
    return 0;
  }
  if (is_array_like_default(o)) {
    return o.length;
  }
  return Object.keys(o).length;
}

// node_modules/@antv/util/esm/lodash/cache.js
var default_1 = (
  /** @class */
  function() {
    function default_12() {
      this.map = {};
    }
    default_12.prototype.has = function(key) {
      return this.map[key] !== void 0;
    };
    default_12.prototype.get = function(key, def) {
      var v = this.map[key];
      return v === void 0 ? def : v;
    };
    default_12.prototype.set = function(key, value) {
      this.map[key] = value;
    };
    default_12.prototype.clear = function() {
      this.map = {};
    };
    default_12.prototype.delete = function(key) {
      delete this.map[key];
    };
    default_12.prototype.size = function() {
      return Object.keys(this.map).length;
    };
    return default_12;
  }()
);

// node_modules/@antv/util/esm/dom/create-dom.js
function createDOM(str7) {
  var container = document.createElement("div");
  container.innerHTML = str7;
  var dom = container.childNodes[0];
  if (dom && container.contains(dom)) {
    container.removeChild(dom);
  }
  return dom;
}

// node_modules/@antv/util/esm/color/arr2rgb.js
function toHex(value) {
  var x16Value = Math.round(value).toString(16);
  return x16Value.length === 1 ? "0".concat(x16Value) : x16Value;
}
function arr2rgb(arr) {
  return "#".concat(toHex(arr[0])).concat(toHex(arr[1])).concat(toHex(arr[2]));
}

// node_modules/@antv/util/esm/color/torgb.js
var RGB_REG = /rgba?\(([\s.,0-9]+)\)/;
function getTmp() {
  var i = document.getElementById("antv-web-colour-picker");
  if (i) {
    return i;
  }
  i = document.createElement("i");
  i.id = "antv-web-colour-picker";
  i.title = "Web Colour Picker";
  i.style.display = "none";
  document.body.appendChild(i);
  return i;
}
function toRGBString(color2) {
  if (color2[0] === "#" && color2.length === 7) {
    return color2;
  }
  var iEl = getTmp();
  iEl.style.color = color2;
  var rst = document.defaultView.getComputedStyle(iEl, "").getPropertyValue("color");
  var matches = RGB_REG.exec(rst);
  var cArray = matches[1].split(/\s*,\s*/).map(function(s2) {
    return Number(s2);
  });
  rst = arr2rgb(cArray);
  return rst;
}
var toRGB = memoize(toRGBString, function(color2) {
  return color2;
}, 256);

// node_modules/gl-matrix/esm/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
var ANGLE_ORDER = "zyx";
function round(a2) {
  if (a2 >= 0) return Math.round(a2);
  return a2 % 0.5 === 0 ? Math.floor(a2) : Math.round(a2);
}
var degree = Math.PI / 180;
var radian = 180 / Math.PI;

// node_modules/gl-matrix/esm/mat3.js
var mat3_exports = {};
__export(mat3_exports, {
  add: () => add,
  adjoint: () => adjoint,
  clone: () => clone2,
  copy: () => copy,
  create: () => create,
  determinant: () => determinant,
  equals: () => equals,
  exactEquals: () => exactEquals,
  frob: () => frob,
  fromMat2d: () => fromMat2d,
  fromMat4: () => fromMat4,
  fromQuat: () => fromQuat,
  fromRotation: () => fromRotation,
  fromScaling: () => fromScaling,
  fromTranslation: () => fromTranslation,
  fromValues: () => fromValues,
  identity: () => identity2,
  invert: () => invert,
  mul: () => mul,
  multiply: () => multiply,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  normalFromMat4: () => normalFromMat4,
  projection: () => projection,
  rotate: () => rotate,
  scale: () => scale,
  set: () => set,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  translate: () => translate,
  transpose: () => transpose
});
function create() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function fromMat4(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[4];
  out[4] = a2[5];
  out[5] = a2[6];
  out[6] = a2[8];
  out[7] = a2[9];
  out[8] = a2[10];
  return out;
}
function clone2(a2) {
  var out = new ARRAY_TYPE(9);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  out[4] = a2[4];
  out[5] = a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  return out;
}
function copy(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  out[4] = a2[4];
  out[5] = a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  return out;
}
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function identity2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function transpose(out, a2) {
  if (out === a2) {
    var a01 = a2[1], a02 = a2[2], a12 = a2[5];
    out[1] = a2[3];
    out[2] = a2[6];
    out[3] = a01;
    out[5] = a2[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a2[0];
    out[1] = a2[3];
    out[2] = a2[6];
    out[3] = a2[1];
    out[4] = a2[4];
    out[5] = a2[7];
    out[6] = a2[2];
    out[7] = a2[5];
    out[8] = a2[8];
  }
  return out;
}
function invert(out, a2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2];
  var a10 = a2[3], a11 = a2[4], a12 = a2[5];
  var a20 = a2[6], a21 = a2[7], a22 = a2[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function adjoint(out, a2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2];
  var a10 = a2[3], a11 = a2[4], a12 = a2[5];
  var a20 = a2[6], a21 = a2[7], a22 = a2[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
function determinant(a2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2];
  var a10 = a2[3], a11 = a2[4], a12 = a2[5];
  var a20 = a2[6], a21 = a2[7], a22 = a2[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply(out, a2, b) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2];
  var a10 = a2[3], a11 = a2[4], a12 = a2[5];
  var a20 = a2[6], a21 = a2[7], a22 = a2[8];
  var b00 = b[0], b01 = b[1], b02 = b[2];
  var b10 = b[3], b11 = b[4], b12 = b[5];
  var b20 = b[6], b21 = b[7], b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate(out, a2, v) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a10 = a2[3], a11 = a2[4], a12 = a2[5], a20 = a2[6], a21 = a2[7], a22 = a2[8], x3 = v[0], y3 = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x3 * a00 + y3 * a10 + a20;
  out[7] = x3 * a01 + y3 * a11 + a21;
  out[8] = x3 * a02 + y3 * a12 + a22;
  return out;
}
function rotate(out, a2, rad2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a10 = a2[3], a11 = a2[4], a12 = a2[5], a20 = a2[6], a21 = a2[7], a22 = a2[8], s2 = Math.sin(rad2), c2 = Math.cos(rad2);
  out[0] = c2 * a00 + s2 * a10;
  out[1] = c2 * a01 + s2 * a11;
  out[2] = c2 * a02 + s2 * a12;
  out[3] = c2 * a10 - s2 * a00;
  out[4] = c2 * a11 - s2 * a01;
  out[5] = c2 * a12 - s2 * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale(out, a2, v) {
  var x3 = v[0], y3 = v[1];
  out[0] = x3 * a2[0];
  out[1] = x3 * a2[1];
  out[2] = x3 * a2[2];
  out[3] = y3 * a2[3];
  out[4] = y3 * a2[4];
  out[5] = y3 * a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  return out;
}
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
function fromRotation(out, rad2) {
  var s2 = Math.sin(rad2), c2 = Math.cos(rad2);
  out[0] = c2;
  out[1] = s2;
  out[2] = 0;
  out[3] = -s2;
  out[4] = c2;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromMat2d(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = 0;
  out[3] = a2[2];
  out[4] = a2[3];
  out[5] = 0;
  out[6] = a2[4];
  out[7] = a2[5];
  out[8] = 1;
  return out;
}
function fromQuat(out, q) {
  var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
  var x22 = x3 + x3;
  var y22 = y3 + y3;
  var z2 = z + z;
  var xx = x3 * x22;
  var yx = y3 * x22;
  var yy = y3 * y22;
  var zx = z * x22;
  var zy = z * y22;
  var zz = z * z2;
  var wx = w * x22;
  var wy = w * y22;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
function normalFromMat4(out, a2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
  var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
  var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
  var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
function str(a2) {
  return "mat3(" + a2[0] + ", " + a2[1] + ", " + a2[2] + ", " + a2[3] + ", " + a2[4] + ", " + a2[5] + ", " + a2[6] + ", " + a2[7] + ", " + a2[8] + ")";
}
function frob(a2) {
  return Math.sqrt(a2[0] * a2[0] + a2[1] * a2[1] + a2[2] * a2[2] + a2[3] * a2[3] + a2[4] * a2[4] + a2[5] * a2[5] + a2[6] * a2[6] + a2[7] * a2[7] + a2[8] * a2[8]);
}
function add(out, a2, b) {
  out[0] = a2[0] + b[0];
  out[1] = a2[1] + b[1];
  out[2] = a2[2] + b[2];
  out[3] = a2[3] + b[3];
  out[4] = a2[4] + b[4];
  out[5] = a2[5] + b[5];
  out[6] = a2[6] + b[6];
  out[7] = a2[7] + b[7];
  out[8] = a2[8] + b[8];
  return out;
}
function subtract(out, a2, b) {
  out[0] = a2[0] - b[0];
  out[1] = a2[1] - b[1];
  out[2] = a2[2] - b[2];
  out[3] = a2[3] - b[3];
  out[4] = a2[4] - b[4];
  out[5] = a2[5] - b[5];
  out[6] = a2[6] - b[6];
  out[7] = a2[7] - b[7];
  out[8] = a2[8] - b[8];
  return out;
}
function multiplyScalar(out, a2, b) {
  out[0] = a2[0] * b;
  out[1] = a2[1] * b;
  out[2] = a2[2] * b;
  out[3] = a2[3] * b;
  out[4] = a2[4] * b;
  out[5] = a2[5] * b;
  out[6] = a2[6] * b;
  out[7] = a2[7] * b;
  out[8] = a2[8] * b;
  return out;
}
function multiplyScalarAndAdd(out, a2, b, scale9) {
  out[0] = a2[0] + b[0] * scale9;
  out[1] = a2[1] + b[1] * scale9;
  out[2] = a2[2] + b[2] * scale9;
  out[3] = a2[3] + b[3] * scale9;
  out[4] = a2[4] + b[4] * scale9;
  out[5] = a2[5] + b[5] * scale9;
  out[6] = a2[6] + b[6] * scale9;
  out[7] = a2[7] + b[7] * scale9;
  out[8] = a2[8] + b[8] * scale9;
  return out;
}
function exactEquals(a2, b) {
  return a2[0] === b[0] && a2[1] === b[1] && a2[2] === b[2] && a2[3] === b[3] && a2[4] === b[4] && a2[5] === b[5] && a2[6] === b[6] && a2[7] === b[7] && a2[8] === b[8];
}
function equals(a2, b) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3], a4 = a2[4], a5 = a2[5], a6 = a2[6], a7 = a2[7], a8 = a2[8];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
}
var mul = multiply;
var sub = subtract;

// node_modules/gl-matrix/esm/mat4.js
var mat4_exports = {};
__export(mat4_exports, {
  add: () => add2,
  adjoint: () => adjoint2,
  clone: () => clone3,
  copy: () => copy2,
  create: () => create2,
  decompose: () => decompose,
  determinant: () => determinant2,
  equals: () => equals2,
  exactEquals: () => exactEquals2,
  frob: () => frob2,
  fromQuat: () => fromQuat3,
  fromQuat2: () => fromQuat2,
  fromRotation: () => fromRotation2,
  fromRotationTranslation: () => fromRotationTranslation,
  fromRotationTranslationScale: () => fromRotationTranslationScale,
  fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
  fromScaling: () => fromScaling2,
  fromTranslation: () => fromTranslation2,
  fromValues: () => fromValues2,
  fromXRotation: () => fromXRotation,
  fromYRotation: () => fromYRotation,
  fromZRotation: () => fromZRotation,
  frustum: () => frustum,
  getRotation: () => getRotation,
  getScaling: () => getScaling,
  getTranslation: () => getTranslation,
  identity: () => identity3,
  invert: () => invert2,
  lookAt: () => lookAt,
  mul: () => mul2,
  multiply: () => multiply2,
  multiplyScalar: () => multiplyScalar2,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd2,
  ortho: () => ortho,
  orthoNO: () => orthoNO,
  orthoZO: () => orthoZO,
  perspective: () => perspective,
  perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
  perspectiveNO: () => perspectiveNO,
  perspectiveZO: () => perspectiveZO,
  rotate: () => rotate2,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  scale: () => scale2,
  set: () => set2,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  targetTo: () => targetTo,
  translate: () => translate2,
  transpose: () => transpose2
});
function create2() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone3(a2) {
  var out = new ARRAY_TYPE(16);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  out[4] = a2[4];
  out[5] = a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  out[9] = a2[9];
  out[10] = a2[10];
  out[11] = a2[11];
  out[12] = a2[12];
  out[13] = a2[13];
  out[14] = a2[14];
  out[15] = a2[15];
  return out;
}
function copy2(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  out[4] = a2[4];
  out[5] = a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  out[9] = a2[9];
  out[10] = a2[10];
  out[11] = a2[11];
  out[12] = a2[12];
  out[13] = a2[13];
  out[14] = a2[14];
  out[15] = a2[15];
  return out;
}
function fromValues2(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function set2(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity3(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose2(out, a2) {
  if (out === a2) {
    var a01 = a2[1], a02 = a2[2], a03 = a2[3];
    var a12 = a2[6], a13 = a2[7];
    var a23 = a2[11];
    out[1] = a2[4];
    out[2] = a2[8];
    out[3] = a2[12];
    out[4] = a01;
    out[6] = a2[9];
    out[7] = a2[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a2[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a2[0];
    out[1] = a2[4];
    out[2] = a2[8];
    out[3] = a2[12];
    out[4] = a2[1];
    out[5] = a2[5];
    out[6] = a2[9];
    out[7] = a2[13];
    out[8] = a2[2];
    out[9] = a2[6];
    out[10] = a2[10];
    out[11] = a2[14];
    out[12] = a2[3];
    out[13] = a2[7];
    out[14] = a2[11];
    out[15] = a2[15];
  }
  return out;
}
function invert2(out, a2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
  var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
  var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
  var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function adjoint2(out, a2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
  var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
  var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
  var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  out[0] = a11 * b11 - a12 * b10 + a13 * b09;
  out[1] = a02 * b10 - a01 * b11 - a03 * b09;
  out[2] = a31 * b05 - a32 * b04 + a33 * b03;
  out[3] = a22 * b04 - a21 * b05 - a23 * b03;
  out[4] = a12 * b08 - a10 * b11 - a13 * b07;
  out[5] = a00 * b11 - a02 * b08 + a03 * b07;
  out[6] = a32 * b02 - a30 * b05 - a33 * b01;
  out[7] = a20 * b05 - a22 * b02 + a23 * b01;
  out[8] = a10 * b10 - a11 * b08 + a13 * b06;
  out[9] = a01 * b08 - a00 * b10 - a03 * b06;
  out[10] = a30 * b04 - a31 * b02 + a33 * b00;
  out[11] = a21 * b02 - a20 * b04 - a23 * b00;
  out[12] = a11 * b07 - a10 * b09 - a12 * b06;
  out[13] = a00 * b09 - a01 * b07 + a02 * b06;
  out[14] = a31 * b01 - a30 * b03 - a32 * b00;
  out[15] = a20 * b03 - a21 * b01 + a22 * b00;
  return out;
}
function determinant2(a2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
  var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
  var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
  var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
  var b0 = a00 * a11 - a01 * a10;
  var b1 = a00 * a12 - a02 * a10;
  var b2 = a01 * a12 - a02 * a11;
  var b3 = a20 * a31 - a21 * a30;
  var b4 = a20 * a32 - a22 * a30;
  var b5 = a21 * a32 - a22 * a31;
  var b6 = a00 * b5 - a01 * b4 + a02 * b3;
  var b7 = a10 * b5 - a11 * b4 + a12 * b3;
  var b8 = a20 * b2 - a21 * b1 + a22 * b0;
  var b9 = a30 * b2 - a31 * b1 + a32 * b0;
  return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;
}
function multiply2(out, a2, b) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
  var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
  var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
  var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate2(out, a2, v) {
  var x3 = v[0], y3 = v[1], z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a2 === out) {
    out[12] = a2[0] * x3 + a2[4] * y3 + a2[8] * z + a2[12];
    out[13] = a2[1] * x3 + a2[5] * y3 + a2[9] * z + a2[13];
    out[14] = a2[2] * x3 + a2[6] * y3 + a2[10] * z + a2[14];
    out[15] = a2[3] * x3 + a2[7] * y3 + a2[11] * z + a2[15];
  } else {
    a00 = a2[0];
    a01 = a2[1];
    a02 = a2[2];
    a03 = a2[3];
    a10 = a2[4];
    a11 = a2[5];
    a12 = a2[6];
    a13 = a2[7];
    a20 = a2[8];
    a21 = a2[9];
    a22 = a2[10];
    a23 = a2[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x3 + a10 * y3 + a20 * z + a2[12];
    out[13] = a01 * x3 + a11 * y3 + a21 * z + a2[13];
    out[14] = a02 * x3 + a12 * y3 + a22 * z + a2[14];
    out[15] = a03 * x3 + a13 * y3 + a23 * z + a2[15];
  }
  return out;
}
function scale2(out, a2, v) {
  var x3 = v[0], y3 = v[1], z = v[2];
  out[0] = a2[0] * x3;
  out[1] = a2[1] * x3;
  out[2] = a2[2] * x3;
  out[3] = a2[3] * x3;
  out[4] = a2[4] * y3;
  out[5] = a2[5] * y3;
  out[6] = a2[6] * y3;
  out[7] = a2[7] * y3;
  out[8] = a2[8] * z;
  out[9] = a2[9] * z;
  out[10] = a2[10] * z;
  out[11] = a2[11] * z;
  out[12] = a2[12];
  out[13] = a2[13];
  out[14] = a2[14];
  out[15] = a2[15];
  return out;
}
function rotate2(out, a2, rad2, axis) {
  var x3 = axis[0], y3 = axis[1], z = axis[2];
  var len5 = Math.sqrt(x3 * x3 + y3 * y3 + z * z);
  var s2, c2, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len5 < EPSILON) {
    return null;
  }
  len5 = 1 / len5;
  x3 *= len5;
  y3 *= len5;
  z *= len5;
  s2 = Math.sin(rad2);
  c2 = Math.cos(rad2);
  t = 1 - c2;
  a00 = a2[0];
  a01 = a2[1];
  a02 = a2[2];
  a03 = a2[3];
  a10 = a2[4];
  a11 = a2[5];
  a12 = a2[6];
  a13 = a2[7];
  a20 = a2[8];
  a21 = a2[9];
  a22 = a2[10];
  a23 = a2[11];
  b00 = x3 * x3 * t + c2;
  b01 = y3 * x3 * t + z * s2;
  b02 = z * x3 * t - y3 * s2;
  b10 = x3 * y3 * t - z * s2;
  b11 = y3 * y3 * t + c2;
  b12 = z * y3 * t + x3 * s2;
  b20 = x3 * z * t + y3 * s2;
  b21 = y3 * z * t - x3 * s2;
  b22 = z * z * t + c2;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a2 !== out) {
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  return out;
}
function rotateX(out, a2, rad2) {
  var s2 = Math.sin(rad2);
  var c2 = Math.cos(rad2);
  var a10 = a2[4];
  var a11 = a2[5];
  var a12 = a2[6];
  var a13 = a2[7];
  var a20 = a2[8];
  var a21 = a2[9];
  var a22 = a2[10];
  var a23 = a2[11];
  if (a2 !== out) {
    out[0] = a2[0];
    out[1] = a2[1];
    out[2] = a2[2];
    out[3] = a2[3];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  out[4] = a10 * c2 + a20 * s2;
  out[5] = a11 * c2 + a21 * s2;
  out[6] = a12 * c2 + a22 * s2;
  out[7] = a13 * c2 + a23 * s2;
  out[8] = a20 * c2 - a10 * s2;
  out[9] = a21 * c2 - a11 * s2;
  out[10] = a22 * c2 - a12 * s2;
  out[11] = a23 * c2 - a13 * s2;
  return out;
}
function rotateY(out, a2, rad2) {
  var s2 = Math.sin(rad2);
  var c2 = Math.cos(rad2);
  var a00 = a2[0];
  var a01 = a2[1];
  var a02 = a2[2];
  var a03 = a2[3];
  var a20 = a2[8];
  var a21 = a2[9];
  var a22 = a2[10];
  var a23 = a2[11];
  if (a2 !== out) {
    out[4] = a2[4];
    out[5] = a2[5];
    out[6] = a2[6];
    out[7] = a2[7];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  out[0] = a00 * c2 - a20 * s2;
  out[1] = a01 * c2 - a21 * s2;
  out[2] = a02 * c2 - a22 * s2;
  out[3] = a03 * c2 - a23 * s2;
  out[8] = a00 * s2 + a20 * c2;
  out[9] = a01 * s2 + a21 * c2;
  out[10] = a02 * s2 + a22 * c2;
  out[11] = a03 * s2 + a23 * c2;
  return out;
}
function rotateZ(out, a2, rad2) {
  var s2 = Math.sin(rad2);
  var c2 = Math.cos(rad2);
  var a00 = a2[0];
  var a01 = a2[1];
  var a02 = a2[2];
  var a03 = a2[3];
  var a10 = a2[4];
  var a11 = a2[5];
  var a12 = a2[6];
  var a13 = a2[7];
  if (a2 !== out) {
    out[8] = a2[8];
    out[9] = a2[9];
    out[10] = a2[10];
    out[11] = a2[11];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  out[0] = a00 * c2 + a10 * s2;
  out[1] = a01 * c2 + a11 * s2;
  out[2] = a02 * c2 + a12 * s2;
  out[3] = a03 * c2 + a13 * s2;
  out[4] = a10 * c2 - a00 * s2;
  out[5] = a11 * c2 - a01 * s2;
  out[6] = a12 * c2 - a02 * s2;
  out[7] = a13 * c2 - a03 * s2;
  return out;
}
function fromTranslation2(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromScaling2(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation2(out, rad2, axis) {
  var x3 = axis[0], y3 = axis[1], z = axis[2];
  var len5 = Math.sqrt(x3 * x3 + y3 * y3 + z * z);
  var s2, c2, t;
  if (len5 < EPSILON) {
    return null;
  }
  len5 = 1 / len5;
  x3 *= len5;
  y3 *= len5;
  z *= len5;
  s2 = Math.sin(rad2);
  c2 = Math.cos(rad2);
  t = 1 - c2;
  out[0] = x3 * x3 * t + c2;
  out[1] = y3 * x3 * t + z * s2;
  out[2] = z * x3 * t - y3 * s2;
  out[3] = 0;
  out[4] = x3 * y3 * t - z * s2;
  out[5] = y3 * y3 * t + c2;
  out[6] = z * y3 * t + x3 * s2;
  out[7] = 0;
  out[8] = x3 * z * t + y3 * s2;
  out[9] = y3 * z * t - x3 * s2;
  out[10] = z * z * t + c2;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromXRotation(out, rad2) {
  var s2 = Math.sin(rad2);
  var c2 = Math.cos(rad2);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c2;
  out[6] = s2;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s2;
  out[10] = c2;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromYRotation(out, rad2) {
  var s2 = Math.sin(rad2);
  var c2 = Math.cos(rad2);
  out[0] = c2;
  out[1] = 0;
  out[2] = -s2;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s2;
  out[9] = 0;
  out[10] = c2;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad2) {
  var s2 = Math.sin(rad2);
  var c2 = Math.cos(rad2);
  out[0] = c2;
  out[1] = s2;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s2;
  out[5] = c2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotationTranslation(out, q, v) {
  var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
  var x22 = x3 + x3;
  var y22 = y3 + y3;
  var z2 = z + z;
  var xx = x3 * x22;
  var xy = x3 * y22;
  var xz = x3 * z2;
  var yy = y3 * y22;
  var yz = y3 * z2;
  var zz = z * z2;
  var wx = w * x22;
  var wy = w * y22;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromQuat2(out, a2) {
  var translation = new ARRAY_TYPE(3);
  var bx = -a2[0], by = -a2[1], bz = -a2[2], bw = a2[3], ax = a2[4], ay = a2[5], az = a2[6], aw = a2[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a2, translation);
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
function decompose(out_r, out_t, out_s, mat) {
  out_t[0] = mat[12];
  out_t[1] = mat[13];
  out_t[2] = mat[14];
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out_s[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out_s[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out_s[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
  var is1 = 1 / out_s[0];
  var is2 = 1 / out_s[1];
  var is3 = 1 / out_s[2];
  var sm11 = m11 * is1;
  var sm12 = m12 * is2;
  var sm13 = m13 * is3;
  var sm21 = m21 * is1;
  var sm22 = m22 * is2;
  var sm23 = m23 * is3;
  var sm31 = m31 * is1;
  var sm32 = m32 * is2;
  var sm33 = m33 * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out_r[3] = 0.25 * S;
    out_r[0] = (sm23 - sm32) / S;
    out_r[1] = (sm31 - sm13) / S;
    out_r[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out_r[3] = (sm23 - sm32) / S;
    out_r[0] = 0.25 * S;
    out_r[1] = (sm12 + sm21) / S;
    out_r[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out_r[3] = (sm31 - sm13) / S;
    out_r[0] = (sm12 + sm21) / S;
    out_r[1] = 0.25 * S;
    out_r[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out_r[3] = (sm12 - sm21) / S;
    out_r[0] = (sm31 + sm13) / S;
    out_r[1] = (sm23 + sm32) / S;
    out_r[2] = 0.25 * S;
  }
  return out_r;
}
function fromRotationTranslationScale(out, q, v, s2) {
  var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
  var x22 = x3 + x3;
  var y22 = y3 + y3;
  var z2 = z + z;
  var xx = x3 * x22;
  var xy = x3 * y22;
  var xz = x3 * z2;
  var yy = y3 * y22;
  var yz = y3 * z2;
  var zz = z * z2;
  var wx = w * x22;
  var wy = w * y22;
  var wz = w * z2;
  var sx = s2[0];
  var sy = s2[1];
  var sz = s2[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromRotationTranslationScaleOrigin(out, q, v, s2, o) {
  var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
  var x22 = x3 + x3;
  var y22 = y3 + y3;
  var z2 = z + z;
  var xx = x3 * x22;
  var xy = x3 * y22;
  var xz = x3 * z2;
  var yy = y3 * y22;
  var yz = y3 * z2;
  var zz = z * z2;
  var wx = w * x22;
  var wy = w * y22;
  var wz = w * z2;
  var sx = s2[0];
  var sy = s2[1];
  var sz = s2[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
function fromQuat3(out, q) {
  var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
  var x22 = x3 + x3;
  var y22 = y3 + y3;
  var z2 = z + z;
  var xx = x3 * x22;
  var yx = y3 * x22;
  var yy = y3 * y22;
  var zx = z * x22;
  var zy = z * y22;
  var zz = z * z2;
  var wx = w * x22;
  var wy = w * y22;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2);
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    var nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2);
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    var nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  var xScale = 2 / (leftTan + rightTan);
  var yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
var ortho = orthoNO;
function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center, up) {
  var x0, x1, x22, y0, y1, y22, z0, z1, z2, len5;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity3(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len5 = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len5;
  z1 *= len5;
  z2 *= len5;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x22 = upx * z1 - upy * z0;
  len5 = Math.sqrt(x0 * x0 + x1 * x1 + x22 * x22);
  if (!len5) {
    x0 = 0;
    x1 = 0;
    x22 = 0;
  } else {
    len5 = 1 / len5;
    x0 *= len5;
    x1 *= len5;
    x22 *= len5;
  }
  y0 = z1 * x22 - z2 * x1;
  y1 = z2 * x0 - z0 * x22;
  y22 = z0 * x1 - z1 * x0;
  len5 = Math.sqrt(y0 * y0 + y1 * y1 + y22 * y22);
  if (!len5) {
    y0 = 0;
    y1 = 0;
    y22 = 0;
  } else {
    len5 = 1 / len5;
    y0 *= len5;
    y1 *= len5;
    y22 *= len5;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x22;
  out[9] = y22;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x22 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y22 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function targetTo(out, eye, target, up) {
  var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
  var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
  var len5 = z0 * z0 + z1 * z1 + z2 * z2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
    z0 *= len5;
    z1 *= len5;
    z2 *= len5;
  }
  var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x22 = upx * z1 - upy * z0;
  len5 = x0 * x0 + x1 * x1 + x22 * x22;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
    x0 *= len5;
    x1 *= len5;
    x22 *= len5;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x22;
  out[3] = 0;
  out[4] = z1 * x22 - z2 * x1;
  out[5] = z2 * x0 - z0 * x22;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
function str2(a2) {
  return "mat4(" + a2[0] + ", " + a2[1] + ", " + a2[2] + ", " + a2[3] + ", " + a2[4] + ", " + a2[5] + ", " + a2[6] + ", " + a2[7] + ", " + a2[8] + ", " + a2[9] + ", " + a2[10] + ", " + a2[11] + ", " + a2[12] + ", " + a2[13] + ", " + a2[14] + ", " + a2[15] + ")";
}
function frob2(a2) {
  return Math.sqrt(a2[0] * a2[0] + a2[1] * a2[1] + a2[2] * a2[2] + a2[3] * a2[3] + a2[4] * a2[4] + a2[5] * a2[5] + a2[6] * a2[6] + a2[7] * a2[7] + a2[8] * a2[8] + a2[9] * a2[9] + a2[10] * a2[10] + a2[11] * a2[11] + a2[12] * a2[12] + a2[13] * a2[13] + a2[14] * a2[14] + a2[15] * a2[15]);
}
function add2(out, a2, b) {
  out[0] = a2[0] + b[0];
  out[1] = a2[1] + b[1];
  out[2] = a2[2] + b[2];
  out[3] = a2[3] + b[3];
  out[4] = a2[4] + b[4];
  out[5] = a2[5] + b[5];
  out[6] = a2[6] + b[6];
  out[7] = a2[7] + b[7];
  out[8] = a2[8] + b[8];
  out[9] = a2[9] + b[9];
  out[10] = a2[10] + b[10];
  out[11] = a2[11] + b[11];
  out[12] = a2[12] + b[12];
  out[13] = a2[13] + b[13];
  out[14] = a2[14] + b[14];
  out[15] = a2[15] + b[15];
  return out;
}
function subtract2(out, a2, b) {
  out[0] = a2[0] - b[0];
  out[1] = a2[1] - b[1];
  out[2] = a2[2] - b[2];
  out[3] = a2[3] - b[3];
  out[4] = a2[4] - b[4];
  out[5] = a2[5] - b[5];
  out[6] = a2[6] - b[6];
  out[7] = a2[7] - b[7];
  out[8] = a2[8] - b[8];
  out[9] = a2[9] - b[9];
  out[10] = a2[10] - b[10];
  out[11] = a2[11] - b[11];
  out[12] = a2[12] - b[12];
  out[13] = a2[13] - b[13];
  out[14] = a2[14] - b[14];
  out[15] = a2[15] - b[15];
  return out;
}
function multiplyScalar2(out, a2, b) {
  out[0] = a2[0] * b;
  out[1] = a2[1] * b;
  out[2] = a2[2] * b;
  out[3] = a2[3] * b;
  out[4] = a2[4] * b;
  out[5] = a2[5] * b;
  out[6] = a2[6] * b;
  out[7] = a2[7] * b;
  out[8] = a2[8] * b;
  out[9] = a2[9] * b;
  out[10] = a2[10] * b;
  out[11] = a2[11] * b;
  out[12] = a2[12] * b;
  out[13] = a2[13] * b;
  out[14] = a2[14] * b;
  out[15] = a2[15] * b;
  return out;
}
function multiplyScalarAndAdd2(out, a2, b, scale9) {
  out[0] = a2[0] + b[0] * scale9;
  out[1] = a2[1] + b[1] * scale9;
  out[2] = a2[2] + b[2] * scale9;
  out[3] = a2[3] + b[3] * scale9;
  out[4] = a2[4] + b[4] * scale9;
  out[5] = a2[5] + b[5] * scale9;
  out[6] = a2[6] + b[6] * scale9;
  out[7] = a2[7] + b[7] * scale9;
  out[8] = a2[8] + b[8] * scale9;
  out[9] = a2[9] + b[9] * scale9;
  out[10] = a2[10] + b[10] * scale9;
  out[11] = a2[11] + b[11] * scale9;
  out[12] = a2[12] + b[12] * scale9;
  out[13] = a2[13] + b[13] * scale9;
  out[14] = a2[14] + b[14] * scale9;
  out[15] = a2[15] + b[15] * scale9;
  return out;
}
function exactEquals2(a2, b) {
  return a2[0] === b[0] && a2[1] === b[1] && a2[2] === b[2] && a2[3] === b[3] && a2[4] === b[4] && a2[5] === b[5] && a2[6] === b[6] && a2[7] === b[7] && a2[8] === b[8] && a2[9] === b[9] && a2[10] === b[10] && a2[11] === b[11] && a2[12] === b[12] && a2[13] === b[13] && a2[14] === b[14] && a2[15] === b[15];
}
function equals2(a2, b) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
  var a4 = a2[4], a5 = a2[5], a6 = a2[6], a7 = a2[7];
  var a8 = a2[8], a9 = a2[9], a10 = a2[10], a11 = a2[11];
  var a12 = a2[12], a13 = a2[13], a14 = a2[14], a15 = a2[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
  var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
  var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul2 = multiply2;
var sub2 = subtract2;

// node_modules/gl-matrix/esm/quat.js
var quat_exports = {};
__export(quat_exports, {
  add: () => add5,
  calculateW: () => calculateW,
  clone: () => clone6,
  conjugate: () => conjugate,
  copy: () => copy5,
  create: () => create5,
  dot: () => dot3,
  equals: () => equals5,
  exactEquals: () => exactEquals5,
  exp: () => exp,
  fromEuler: () => fromEuler,
  fromMat3: () => fromMat3,
  fromValues: () => fromValues5,
  getAngle: () => getAngle,
  getAxisAngle: () => getAxisAngle,
  identity: () => identity4,
  invert: () => invert3,
  len: () => len3,
  length: () => length3,
  lerp: () => lerp3,
  ln: () => ln,
  mul: () => mul5,
  multiply: () => multiply5,
  normalize: () => normalize3,
  pow: () => pow,
  random: () => random3,
  rotateX: () => rotateX3,
  rotateY: () => rotateY3,
  rotateZ: () => rotateZ3,
  rotationTo: () => rotationTo,
  scale: () => scale5,
  set: () => set5,
  setAxes: () => setAxes,
  setAxisAngle: () => setAxisAngle,
  slerp: () => slerp2,
  sqlerp: () => sqlerp,
  sqrLen: () => sqrLen3,
  squaredLength: () => squaredLength3,
  str: () => str5
});

// node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add3,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone4,
  copy: () => copy3,
  create: () => create3,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals3,
  exactEquals: () => exactEquals3,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues3,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max2,
  min: () => min,
  mul: () => mul3,
  multiply: () => multiply3,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  round: () => round2,
  scale: () => scale3,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set3,
  slerp: () => slerp,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str3,
  sub: () => sub3,
  subtract: () => subtract3,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone4(a2) {
  var out = new ARRAY_TYPE(3);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  return out;
}
function length(a2) {
  var x3 = a2[0];
  var y3 = a2[1];
  var z = a2[2];
  return Math.sqrt(x3 * x3 + y3 * y3 + z * z);
}
function fromValues3(x3, y3, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x3;
  out[1] = y3;
  out[2] = z;
  return out;
}
function copy3(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  return out;
}
function set3(out, x3, y3, z) {
  out[0] = x3;
  out[1] = y3;
  out[2] = z;
  return out;
}
function add3(out, a2, b) {
  out[0] = a2[0] + b[0];
  out[1] = a2[1] + b[1];
  out[2] = a2[2] + b[2];
  return out;
}
function subtract3(out, a2, b) {
  out[0] = a2[0] - b[0];
  out[1] = a2[1] - b[1];
  out[2] = a2[2] - b[2];
  return out;
}
function multiply3(out, a2, b) {
  out[0] = a2[0] * b[0];
  out[1] = a2[1] * b[1];
  out[2] = a2[2] * b[2];
  return out;
}
function divide(out, a2, b) {
  out[0] = a2[0] / b[0];
  out[1] = a2[1] / b[1];
  out[2] = a2[2] / b[2];
  return out;
}
function ceil(out, a2) {
  out[0] = Math.ceil(a2[0]);
  out[1] = Math.ceil(a2[1]);
  out[2] = Math.ceil(a2[2]);
  return out;
}
function floor(out, a2) {
  out[0] = Math.floor(a2[0]);
  out[1] = Math.floor(a2[1]);
  out[2] = Math.floor(a2[2]);
  return out;
}
function min(out, a2, b) {
  out[0] = Math.min(a2[0], b[0]);
  out[1] = Math.min(a2[1], b[1]);
  out[2] = Math.min(a2[2], b[2]);
  return out;
}
function max2(out, a2, b) {
  out[0] = Math.max(a2[0], b[0]);
  out[1] = Math.max(a2[1], b[1]);
  out[2] = Math.max(a2[2], b[2]);
  return out;
}
function round2(out, a2) {
  out[0] = round(a2[0]);
  out[1] = round(a2[1]);
  out[2] = round(a2[2]);
  return out;
}
function scale3(out, a2, b) {
  out[0] = a2[0] * b;
  out[1] = a2[1] * b;
  out[2] = a2[2] * b;
  return out;
}
function scaleAndAdd(out, a2, b, scale9) {
  out[0] = a2[0] + b[0] * scale9;
  out[1] = a2[1] + b[1] * scale9;
  out[2] = a2[2] + b[2] * scale9;
  return out;
}
function distance(a2, b) {
  var x3 = b[0] - a2[0];
  var y3 = b[1] - a2[1];
  var z = b[2] - a2[2];
  return Math.sqrt(x3 * x3 + y3 * y3 + z * z);
}
function squaredDistance(a2, b) {
  var x3 = b[0] - a2[0];
  var y3 = b[1] - a2[1];
  var z = b[2] - a2[2];
  return x3 * x3 + y3 * y3 + z * z;
}
function squaredLength(a2) {
  var x3 = a2[0];
  var y3 = a2[1];
  var z = a2[2];
  return x3 * x3 + y3 * y3 + z * z;
}
function negate(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  out[2] = -a2[2];
  return out;
}
function inverse(out, a2) {
  out[0] = 1 / a2[0];
  out[1] = 1 / a2[1];
  out[2] = 1 / a2[2];
  return out;
}
function normalize(out, a2) {
  var x3 = a2[0];
  var y3 = a2[1];
  var z = a2[2];
  var len5 = x3 * x3 + y3 * y3 + z * z;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = a2[0] * len5;
  out[1] = a2[1] * len5;
  out[2] = a2[2] * len5;
  return out;
}
function dot(a2, b) {
  return a2[0] * b[0] + a2[1] * b[1] + a2[2] * b[2];
}
function cross(out, a2, b) {
  var ax = a2[0], ay = a2[1], az = a2[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a2, b, t) {
  var ax = a2[0];
  var ay = a2[1];
  var az = a2[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function slerp(out, a2, b, t) {
  var angle3 = Math.acos(Math.min(Math.max(dot(a2, b), -1), 1));
  var sinTotal = Math.sin(angle3);
  var ratioA = Math.sin((1 - t) * angle3) / sinTotal;
  var ratioB = Math.sin(t * angle3) / sinTotal;
  out[0] = ratioA * a2[0] + ratioB * b[0];
  out[1] = ratioA * a2[1] + ratioB * b[1];
  out[2] = ratioA * a2[2] + ratioB * b[2];
  return out;
}
function hermite(out, a2, b, c2, d2, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a2[0] * factor1 + b[0] * factor2 + c2[0] * factor3 + d2[0] * factor4;
  out[1] = a2[1] * factor1 + b[1] * factor2 + c2[1] * factor3 + d2[1] * factor4;
  out[2] = a2[2] * factor1 + b[2] * factor2 + c2[2] * factor3 + d2[2] * factor4;
  return out;
}
function bezier(out, a2, b, c2, d2, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a2[0] * factor1 + b[0] * factor2 + c2[0] * factor3 + d2[0] * factor4;
  out[1] = a2[1] * factor1 + b[1] * factor2 + c2[1] * factor3 + d2[1] * factor4;
  out[2] = a2[2] * factor1 + b[2] * factor2 + c2[2] * factor3 + d2[2] * factor4;
  return out;
}
function random(out, scale9) {
  scale9 = scale9 === void 0 ? 1 : scale9;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale9;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale9;
  return out;
}
function transformMat4(out, a2, m2) {
  var x3 = a2[0], y3 = a2[1], z = a2[2];
  var w = m2[3] * x3 + m2[7] * y3 + m2[11] * z + m2[15];
  w = w || 1;
  out[0] = (m2[0] * x3 + m2[4] * y3 + m2[8] * z + m2[12]) / w;
  out[1] = (m2[1] * x3 + m2[5] * y3 + m2[9] * z + m2[13]) / w;
  out[2] = (m2[2] * x3 + m2[6] * y3 + m2[10] * z + m2[14]) / w;
  return out;
}
function transformMat3(out, a2, m2) {
  var x3 = a2[0], y3 = a2[1], z = a2[2];
  out[0] = x3 * m2[0] + y3 * m2[3] + z * m2[6];
  out[1] = x3 * m2[1] + y3 * m2[4] + z * m2[7];
  out[2] = x3 * m2[2] + y3 * m2[5] + z * m2[8];
  return out;
}
function transformQuat(out, a2, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var vx = a2[0], vy = a2[1], vz = a2[2];
  var tx = qy * vz - qz * vy;
  var ty = qz * vx - qx * vz;
  var tz = qx * vy - qy * vx;
  tx = tx + tx;
  ty = ty + ty;
  tz = tz + tz;
  out[0] = vx + qw * tx + qy * tz - qz * ty;
  out[1] = vy + qw * ty + qz * tx - qx * tz;
  out[2] = vz + qw * tz + qx * ty - qy * tx;
  return out;
}
function rotateX2(out, a2, b, rad2) {
  var p = [], r = [];
  p[0] = a2[0] - b[0];
  p[1] = a2[1] - b[1];
  p[2] = a2[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad2) - p[2] * Math.sin(rad2);
  r[2] = p[1] * Math.sin(rad2) + p[2] * Math.cos(rad2);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY2(out, a2, b, rad2) {
  var p = [], r = [];
  p[0] = a2[0] - b[0];
  p[1] = a2[1] - b[1];
  p[2] = a2[2] - b[2];
  r[0] = p[2] * Math.sin(rad2) + p[0] * Math.cos(rad2);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad2) - p[0] * Math.sin(rad2);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ2(out, a2, b, rad2) {
  var p = [], r = [];
  p[0] = a2[0] - b[0];
  p[1] = a2[1] - b[1];
  p[2] = a2[2] - b[2];
  r[0] = p[0] * Math.cos(rad2) - p[1] * Math.sin(rad2);
  r[1] = p[0] * Math.sin(rad2) + p[1] * Math.cos(rad2);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a2, b) {
  var ax = a2[0], ay = a2[1], az = a2[2], bx = b[0], by = b[1], bz = b[2], mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz)), cosine = mag && dot(a2, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str3(a2) {
  return "vec3(" + a2[0] + ", " + a2[1] + ", " + a2[2] + ")";
}
function exactEquals3(a2, b) {
  return a2[0] === b[0] && a2[1] === b[1] && a2[2] === b[2];
}
function equals3(a2, b) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2));
}
var sub3 = subtract3;
var mul3 = multiply3;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
  var vec = create3();
  return function(a2, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a2.length);
    } else {
      l = a2.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a2[i];
      vec[1] = a2[i + 1];
      vec[2] = a2[i + 2];
      fn(vec, vec, arg);
      a2[i] = vec[0];
      a2[i + 1] = vec[1];
      a2[i + 2] = vec[2];
    }
    return a2;
  };
}();

// node_modules/gl-matrix/esm/vec4.js
var vec4_exports = {};
__export(vec4_exports, {
  add: () => add4,
  ceil: () => ceil2,
  clone: () => clone5,
  copy: () => copy4,
  create: () => create4,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot2,
  equals: () => equals4,
  exactEquals: () => exactEquals4,
  floor: () => floor2,
  forEach: () => forEach2,
  fromValues: () => fromValues4,
  inverse: () => inverse2,
  len: () => len2,
  length: () => length2,
  lerp: () => lerp2,
  max: () => max3,
  min: () => min2,
  mul: () => mul4,
  multiply: () => multiply4,
  negate: () => negate2,
  normalize: () => normalize2,
  random: () => random2,
  round: () => round3,
  scale: () => scale4,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set4,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen2,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength2,
  str: () => str4,
  sub: () => sub4,
  subtract: () => subtract4,
  transformMat4: () => transformMat42,
  transformQuat: () => transformQuat2,
  zero: () => zero2
});
function create4() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone5(a2) {
  var out = new ARRAY_TYPE(4);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  return out;
}
function fromValues4(x3, y3, z, w) {
  var out = new ARRAY_TYPE(4);
  out[0] = x3;
  out[1] = y3;
  out[2] = z;
  out[3] = w;
  return out;
}
function copy4(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  return out;
}
function set4(out, x3, y3, z, w) {
  out[0] = x3;
  out[1] = y3;
  out[2] = z;
  out[3] = w;
  return out;
}
function add4(out, a2, b) {
  out[0] = a2[0] + b[0];
  out[1] = a2[1] + b[1];
  out[2] = a2[2] + b[2];
  out[3] = a2[3] + b[3];
  return out;
}
function subtract4(out, a2, b) {
  out[0] = a2[0] - b[0];
  out[1] = a2[1] - b[1];
  out[2] = a2[2] - b[2];
  out[3] = a2[3] - b[3];
  return out;
}
function multiply4(out, a2, b) {
  out[0] = a2[0] * b[0];
  out[1] = a2[1] * b[1];
  out[2] = a2[2] * b[2];
  out[3] = a2[3] * b[3];
  return out;
}
function divide2(out, a2, b) {
  out[0] = a2[0] / b[0];
  out[1] = a2[1] / b[1];
  out[2] = a2[2] / b[2];
  out[3] = a2[3] / b[3];
  return out;
}
function ceil2(out, a2) {
  out[0] = Math.ceil(a2[0]);
  out[1] = Math.ceil(a2[1]);
  out[2] = Math.ceil(a2[2]);
  out[3] = Math.ceil(a2[3]);
  return out;
}
function floor2(out, a2) {
  out[0] = Math.floor(a2[0]);
  out[1] = Math.floor(a2[1]);
  out[2] = Math.floor(a2[2]);
  out[3] = Math.floor(a2[3]);
  return out;
}
function min2(out, a2, b) {
  out[0] = Math.min(a2[0], b[0]);
  out[1] = Math.min(a2[1], b[1]);
  out[2] = Math.min(a2[2], b[2]);
  out[3] = Math.min(a2[3], b[3]);
  return out;
}
function max3(out, a2, b) {
  out[0] = Math.max(a2[0], b[0]);
  out[1] = Math.max(a2[1], b[1]);
  out[2] = Math.max(a2[2], b[2]);
  out[3] = Math.max(a2[3], b[3]);
  return out;
}
function round3(out, a2) {
  out[0] = round(a2[0]);
  out[1] = round(a2[1]);
  out[2] = round(a2[2]);
  out[3] = round(a2[3]);
  return out;
}
function scale4(out, a2, b) {
  out[0] = a2[0] * b;
  out[1] = a2[1] * b;
  out[2] = a2[2] * b;
  out[3] = a2[3] * b;
  return out;
}
function scaleAndAdd2(out, a2, b, scale9) {
  out[0] = a2[0] + b[0] * scale9;
  out[1] = a2[1] + b[1] * scale9;
  out[2] = a2[2] + b[2] * scale9;
  out[3] = a2[3] + b[3] * scale9;
  return out;
}
function distance2(a2, b) {
  var x3 = b[0] - a2[0];
  var y3 = b[1] - a2[1];
  var z = b[2] - a2[2];
  var w = b[3] - a2[3];
  return Math.sqrt(x3 * x3 + y3 * y3 + z * z + w * w);
}
function squaredDistance2(a2, b) {
  var x3 = b[0] - a2[0];
  var y3 = b[1] - a2[1];
  var z = b[2] - a2[2];
  var w = b[3] - a2[3];
  return x3 * x3 + y3 * y3 + z * z + w * w;
}
function length2(a2) {
  var x3 = a2[0];
  var y3 = a2[1];
  var z = a2[2];
  var w = a2[3];
  return Math.sqrt(x3 * x3 + y3 * y3 + z * z + w * w);
}
function squaredLength2(a2) {
  var x3 = a2[0];
  var y3 = a2[1];
  var z = a2[2];
  var w = a2[3];
  return x3 * x3 + y3 * y3 + z * z + w * w;
}
function negate2(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  out[2] = -a2[2];
  out[3] = -a2[3];
  return out;
}
function inverse2(out, a2) {
  out[0] = 1 / a2[0];
  out[1] = 1 / a2[1];
  out[2] = 1 / a2[2];
  out[3] = 1 / a2[3];
  return out;
}
function normalize2(out, a2) {
  var x3 = a2[0];
  var y3 = a2[1];
  var z = a2[2];
  var w = a2[3];
  var len5 = x3 * x3 + y3 * y3 + z * z + w * w;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = x3 * len5;
  out[1] = y3 * len5;
  out[2] = z * len5;
  out[3] = w * len5;
  return out;
}
function dot2(a2, b) {
  return a2[0] * b[0] + a2[1] * b[1] + a2[2] * b[2] + a2[3] * b[3];
}
function cross2(out, u, v, w) {
  var A3 = v[0] * w[1] - v[1] * w[0], B3 = v[0] * w[2] - v[2] * w[0], C3 = v[0] * w[3] - v[3] * w[0], D = v[1] * w[2] - v[2] * w[1], E = v[1] * w[3] - v[3] * w[1], F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C3 - J * B3;
  out[2] = G * E - H * C3 + J * A3;
  out[3] = -(G * D) + H * B3 - I * A3;
  return out;
}
function lerp2(out, a2, b, t) {
  var ax = a2[0];
  var ay = a2[1];
  var az = a2[2];
  var aw = a2[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
function random2(out, scale9) {
  scale9 = scale9 === void 0 ? 1 : scale9;
  var v1, v2, v3, v4;
  var s1, s2;
  var rand;
  rand = RANDOM();
  v1 = rand * 2 - 1;
  v2 = (4 * RANDOM() - 2) * Math.sqrt(rand * -rand + rand);
  s1 = v1 * v1 + v2 * v2;
  rand = RANDOM();
  v3 = rand * 2 - 1;
  v4 = (4 * RANDOM() - 2) * Math.sqrt(rand * -rand + rand);
  s2 = v3 * v3 + v4 * v4;
  var d2 = Math.sqrt((1 - s1) / s2);
  out[0] = scale9 * v1;
  out[1] = scale9 * v2;
  out[2] = scale9 * v3 * d2;
  out[3] = scale9 * v4 * d2;
  return out;
}
function transformMat42(out, a2, m2) {
  var x3 = a2[0], y3 = a2[1], z = a2[2], w = a2[3];
  out[0] = m2[0] * x3 + m2[4] * y3 + m2[8] * z + m2[12] * w;
  out[1] = m2[1] * x3 + m2[5] * y3 + m2[9] * z + m2[13] * w;
  out[2] = m2[2] * x3 + m2[6] * y3 + m2[10] * z + m2[14] * w;
  out[3] = m2[3] * x3 + m2[7] * y3 + m2[11] * z + m2[15] * w;
  return out;
}
function transformQuat2(out, a2, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var vx = a2[0], vy = a2[1], vz = a2[2];
  var tx = qy * vz - qz * vy;
  var ty = qz * vx - qx * vz;
  var tz = qx * vy - qy * vx;
  tx = tx + tx;
  ty = ty + ty;
  tz = tz + tz;
  out[0] = vx + qw * tx + qy * tz - qz * ty;
  out[1] = vy + qw * ty + qz * tx - qx * tz;
  out[2] = vz + qw * tz + qx * ty - qy * tx;
  out[3] = a2[3];
  return out;
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}
function str4(a2) {
  return "vec4(" + a2[0] + ", " + a2[1] + ", " + a2[2] + ", " + a2[3] + ")";
}
function exactEquals4(a2, b) {
  return a2[0] === b[0] && a2[1] === b[1] && a2[2] === b[2] && a2[3] === b[3];
}
function equals4(a2, b) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
var sub4 = subtract4;
var mul4 = multiply4;
var div2 = divide2;
var dist2 = distance2;
var sqrDist2 = squaredDistance2;
var len2 = length2;
var sqrLen2 = squaredLength2;
var forEach2 = function() {
  var vec = create4();
  return function(a2, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a2.length);
    } else {
      l = a2.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a2[i];
      vec[1] = a2[i + 1];
      vec[2] = a2[i + 2];
      vec[3] = a2[i + 3];
      fn(vec, vec, arg);
      a2[i] = vec[0];
      a2[i + 1] = vec[1];
      a2[i + 2] = vec[2];
      a2[i + 3] = vec[3];
    }
    return a2;
  };
}();

// node_modules/gl-matrix/esm/quat.js
function create5() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity4(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad2) {
  rad2 = rad2 * 0.5;
  var s2 = Math.sin(rad2);
  out[0] = s2 * axis[0];
  out[1] = s2 * axis[1];
  out[2] = s2 * axis[2];
  out[3] = Math.cos(rad2);
  return out;
}
function getAxisAngle(out_axis, q) {
  var rad2 = Math.acos(q[3]) * 2;
  var s2 = Math.sin(rad2 / 2);
  if (s2 > EPSILON) {
    out_axis[0] = q[0] / s2;
    out_axis[1] = q[1] / s2;
    out_axis[2] = q[2] / s2;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad2;
}
function getAngle(a2, b) {
  var dotproduct = dot3(a2, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
function multiply5(out, a2, b) {
  var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX3(out, a2, rad2) {
  rad2 *= 0.5;
  var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
  var bx = Math.sin(rad2), bw = Math.cos(rad2);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY3(out, a2, rad2) {
  rad2 *= 0.5;
  var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
  var by = Math.sin(rad2), bw = Math.cos(rad2);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ3(out, a2, rad2) {
  rad2 *= 0.5;
  var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
  var bz = Math.sin(rad2), bw = Math.cos(rad2);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function calculateW(out, a2) {
  var x3 = a2[0], y3 = a2[1], z = a2[2];
  out[0] = x3;
  out[1] = y3;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1 - x3 * x3 - y3 * y3 - z * z));
  return out;
}
function exp(out, a2) {
  var x3 = a2[0], y3 = a2[1], z = a2[2], w = a2[3];
  var r = Math.sqrt(x3 * x3 + y3 * y3 + z * z);
  var et = Math.exp(w);
  var s2 = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x3 * s2;
  out[1] = y3 * s2;
  out[2] = z * s2;
  out[3] = et * Math.cos(r);
  return out;
}
function ln(out, a2) {
  var x3 = a2[0], y3 = a2[1], z = a2[2], w = a2[3];
  var r = Math.sqrt(x3 * x3 + y3 * y3 + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x3 * t;
  out[1] = y3 * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x3 * x3 + y3 * y3 + z * z + w * w);
  return out;
}
function pow(out, a2, b) {
  ln(out, a2);
  scale5(out, out, b);
  exp(out, out);
  return out;
}
function slerp2(out, a2, b, t) {
  var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function random3(out) {
  var u1 = RANDOM();
  var u2 = RANDOM();
  var u3 = RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
  return out;
}
function invert3(out, a2) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
  var dot7 = a0 * a0 + a1 * a1 + a22 * a22 + a3 * a3;
  var invDot = dot7 ? 1 / dot7 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a22 * invDot;
  out[3] = a3 * invDot;
  return out;
}
function conjugate(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  out[2] = -a2[2];
  out[3] = a2[3];
  return out;
}
function fromMat3(out, m2) {
  var fTrace = m2[0] + m2[4] + m2[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m2[5] - m2[7]) * fRoot;
    out[1] = (m2[6] - m2[2]) * fRoot;
    out[2] = (m2[1] - m2[3]) * fRoot;
  } else {
    var i = 0;
    if (m2[4] > m2[0]) i = 1;
    if (m2[8] > m2[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m2[i * 3 + i] - m2[j * 3 + j] - m2[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m2[j * 3 + k] - m2[k * 3 + j]) * fRoot;
    out[j] = (m2[j * 3 + i] + m2[i * 3 + j]) * fRoot;
    out[k] = (m2[k * 3 + i] + m2[i * 3 + k]) * fRoot;
  }
  return out;
}
function fromEuler(out, x3, y3, z) {
  var order = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : ANGLE_ORDER;
  var halfToRad = Math.PI / 360;
  x3 *= halfToRad;
  z *= halfToRad;
  y3 *= halfToRad;
  var sx = Math.sin(x3);
  var cx = Math.cos(x3);
  var sy = Math.sin(y3);
  var cy = Math.cos(y3);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  switch (order) {
    case "xyz":
      out[0] = sx * cy * cz + cx * sy * sz;
      out[1] = cx * sy * cz - sx * cy * sz;
      out[2] = cx * cy * sz + sx * sy * cz;
      out[3] = cx * cy * cz - sx * sy * sz;
      break;
    case "xzy":
      out[0] = sx * cy * cz - cx * sy * sz;
      out[1] = cx * sy * cz - sx * cy * sz;
      out[2] = cx * cy * sz + sx * sy * cz;
      out[3] = cx * cy * cz + sx * sy * sz;
      break;
    case "yxz":
      out[0] = sx * cy * cz + cx * sy * sz;
      out[1] = cx * sy * cz - sx * cy * sz;
      out[2] = cx * cy * sz - sx * sy * cz;
      out[3] = cx * cy * cz + sx * sy * sz;
      break;
    case "yzx":
      out[0] = sx * cy * cz + cx * sy * sz;
      out[1] = cx * sy * cz + sx * cy * sz;
      out[2] = cx * cy * sz - sx * sy * cz;
      out[3] = cx * cy * cz - sx * sy * sz;
      break;
    case "zxy":
      out[0] = sx * cy * cz - cx * sy * sz;
      out[1] = cx * sy * cz + sx * cy * sz;
      out[2] = cx * cy * sz + sx * sy * cz;
      out[3] = cx * cy * cz - sx * sy * sz;
      break;
    case "zyx":
      out[0] = sx * cy * cz - cx * sy * sz;
      out[1] = cx * sy * cz + sx * cy * sz;
      out[2] = cx * cy * sz - sx * sy * cz;
      out[3] = cx * cy * cz + sx * sy * sz;
      break;
    default:
      throw new Error("Unknown angle order " + order);
  }
  return out;
}
function str5(a2) {
  return "quat(" + a2[0] + ", " + a2[1] + ", " + a2[2] + ", " + a2[3] + ")";
}
var clone6 = clone5;
var fromValues5 = fromValues4;
var copy5 = copy4;
var set5 = set4;
var add5 = add4;
var mul5 = multiply5;
var scale5 = scale4;
var dot3 = dot2;
var lerp3 = lerp2;
var length3 = length2;
var len3 = length3;
var squaredLength3 = squaredLength2;
var sqrLen3 = squaredLength3;
var normalize3 = normalize2;
var exactEquals5 = exactEquals4;
function equals5(a2, b) {
  return Math.abs(dot2(a2, b)) >= 1 - EPSILON;
}
var rotationTo = function() {
  var tmpvec3 = create3();
  var xUnitVec3 = fromValues3(1, 0, 0);
  var yUnitVec3 = fromValues3(0, 1, 0);
  return function(out, a2, b) {
    var dot7 = dot(a2, b);
    if (dot7 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a2);
      if (len(tmpvec3) < 1e-6) cross(tmpvec3, yUnitVec3, a2);
      normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot7 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a2, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot7;
      return normalize3(out, out);
    }
  };
}();
var sqlerp = function() {
  var temp1 = create5();
  var temp2 = create5();
  return function(out, a2, b, c2, d2, t) {
    slerp2(temp1, a2, d2, t);
    slerp2(temp2, b, c2, t);
    slerp2(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
var setAxes = function() {
  var matr = create();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize3(out, fromMat3(out, matr));
  };
}();

// node_modules/gl-matrix/esm/vec2.js
var vec2_exports = {};
__export(vec2_exports, {
  add: () => add6,
  angle: () => angle2,
  ceil: () => ceil3,
  clone: () => clone7,
  copy: () => copy6,
  create: () => create6,
  cross: () => cross3,
  dist: () => dist3,
  distance: () => distance3,
  div: () => div3,
  divide: () => divide3,
  dot: () => dot4,
  equals: () => equals6,
  exactEquals: () => exactEquals6,
  floor: () => floor3,
  forEach: () => forEach3,
  fromValues: () => fromValues6,
  inverse: () => inverse3,
  len: () => len4,
  length: () => length4,
  lerp: () => lerp4,
  max: () => max4,
  min: () => min3,
  mul: () => mul6,
  multiply: () => multiply6,
  negate: () => negate3,
  normalize: () => normalize4,
  random: () => random4,
  rotate: () => rotate3,
  round: () => round4,
  scale: () => scale6,
  scaleAndAdd: () => scaleAndAdd3,
  set: () => set6,
  signedAngle: () => signedAngle,
  sqrDist: () => sqrDist3,
  sqrLen: () => sqrLen4,
  squaredDistance: () => squaredDistance3,
  squaredLength: () => squaredLength4,
  str: () => str6,
  sub: () => sub5,
  subtract: () => subtract5,
  transformMat2: () => transformMat2,
  transformMat2d: () => transformMat2d,
  transformMat3: () => transformMat32,
  transformMat4: () => transformMat43,
  zero: () => zero3
});
function create6() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone7(a2) {
  var out = new ARRAY_TYPE(2);
  out[0] = a2[0];
  out[1] = a2[1];
  return out;
}
function fromValues6(x3, y3) {
  var out = new ARRAY_TYPE(2);
  out[0] = x3;
  out[1] = y3;
  return out;
}
function copy6(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  return out;
}
function set6(out, x3, y3) {
  out[0] = x3;
  out[1] = y3;
  return out;
}
function add6(out, a2, b) {
  out[0] = a2[0] + b[0];
  out[1] = a2[1] + b[1];
  return out;
}
function subtract5(out, a2, b) {
  out[0] = a2[0] - b[0];
  out[1] = a2[1] - b[1];
  return out;
}
function multiply6(out, a2, b) {
  out[0] = a2[0] * b[0];
  out[1] = a2[1] * b[1];
  return out;
}
function divide3(out, a2, b) {
  out[0] = a2[0] / b[0];
  out[1] = a2[1] / b[1];
  return out;
}
function ceil3(out, a2) {
  out[0] = Math.ceil(a2[0]);
  out[1] = Math.ceil(a2[1]);
  return out;
}
function floor3(out, a2) {
  out[0] = Math.floor(a2[0]);
  out[1] = Math.floor(a2[1]);
  return out;
}
function min3(out, a2, b) {
  out[0] = Math.min(a2[0], b[0]);
  out[1] = Math.min(a2[1], b[1]);
  return out;
}
function max4(out, a2, b) {
  out[0] = Math.max(a2[0], b[0]);
  out[1] = Math.max(a2[1], b[1]);
  return out;
}
function round4(out, a2) {
  out[0] = round(a2[0]);
  out[1] = round(a2[1]);
  return out;
}
function scale6(out, a2, b) {
  out[0] = a2[0] * b;
  out[1] = a2[1] * b;
  return out;
}
function scaleAndAdd3(out, a2, b, scale9) {
  out[0] = a2[0] + b[0] * scale9;
  out[1] = a2[1] + b[1] * scale9;
  return out;
}
function distance3(a2, b) {
  var x3 = b[0] - a2[0], y3 = b[1] - a2[1];
  return Math.sqrt(x3 * x3 + y3 * y3);
}
function squaredDistance3(a2, b) {
  var x3 = b[0] - a2[0], y3 = b[1] - a2[1];
  return x3 * x3 + y3 * y3;
}
function length4(a2) {
  var x3 = a2[0], y3 = a2[1];
  return Math.sqrt(x3 * x3 + y3 * y3);
}
function squaredLength4(a2) {
  var x3 = a2[0], y3 = a2[1];
  return x3 * x3 + y3 * y3;
}
function negate3(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  return out;
}
function inverse3(out, a2) {
  out[0] = 1 / a2[0];
  out[1] = 1 / a2[1];
  return out;
}
function normalize4(out, a2) {
  var x3 = a2[0], y3 = a2[1];
  var len5 = x3 * x3 + y3 * y3;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = a2[0] * len5;
  out[1] = a2[1] * len5;
  return out;
}
function dot4(a2, b) {
  return a2[0] * b[0] + a2[1] * b[1];
}
function cross3(out, a2, b) {
  var z = a2[0] * b[1] - a2[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
function lerp4(out, a2, b, t) {
  var ax = a2[0], ay = a2[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
function random4(out, scale9) {
  scale9 = scale9 === void 0 ? 1 : scale9;
  var r = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r) * scale9;
  out[1] = Math.sin(r) * scale9;
  return out;
}
function transformMat2(out, a2, m2) {
  var x3 = a2[0], y3 = a2[1];
  out[0] = m2[0] * x3 + m2[2] * y3;
  out[1] = m2[1] * x3 + m2[3] * y3;
  return out;
}
function transformMat2d(out, a2, m2) {
  var x3 = a2[0], y3 = a2[1];
  out[0] = m2[0] * x3 + m2[2] * y3 + m2[4];
  out[1] = m2[1] * x3 + m2[3] * y3 + m2[5];
  return out;
}
function transformMat32(out, a2, m2) {
  var x3 = a2[0], y3 = a2[1];
  out[0] = m2[0] * x3 + m2[3] * y3 + m2[6];
  out[1] = m2[1] * x3 + m2[4] * y3 + m2[7];
  return out;
}
function transformMat43(out, a2, m2) {
  var x3 = a2[0];
  var y3 = a2[1];
  out[0] = m2[0] * x3 + m2[4] * y3 + m2[12];
  out[1] = m2[1] * x3 + m2[5] * y3 + m2[13];
  return out;
}
function rotate3(out, a2, b, rad2) {
  var p0 = a2[0] - b[0], p1 = a2[1] - b[1], sinC = Math.sin(rad2), cosC = Math.cos(rad2);
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
function angle2(a2, b) {
  var ax = a2[0], ay = a2[1], bx = b[0], by = b[1];
  return Math.abs(Math.atan2(ay * bx - ax * by, ax * bx + ay * by));
}
function signedAngle(a2, b) {
  var ax = a2[0], ay = a2[1], bx = b[0], by = b[1];
  return Math.atan2(ax * by - ay * bx, ax * bx + ay * by);
}
function zero3(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str6(a2) {
  return "vec2(" + a2[0] + ", " + a2[1] + ")";
}
function exactEquals6(a2, b) {
  return a2[0] === b[0] && a2[1] === b[1];
}
function equals6(a2, b) {
  var a0 = a2[0], a1 = a2[1];
  var b0 = b[0], b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
var len4 = length4;
var sub5 = subtract5;
var mul6 = multiply6;
var div3 = divide3;
var dist3 = distance3;
var sqrDist3 = squaredDistance3;
var sqrLen4 = squaredLength4;
var forEach3 = function() {
  var vec = create6();
  return function(a2, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a2.length);
    } else {
      l = a2.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a2[i];
      vec[1] = a2[i + 1];
      fn(vec, vec, arg);
      a2[i] = vec[0];
      a2[i + 1] = vec[1];
    }
    return a2;
  };
}();

// node_modules/@antv/util/esm/path/parser/params-parser.js
var paramsParser = {
  x1: 0,
  y1: 0,
  x2: 0,
  y2: 0,
  x: 0,
  y: 0,
  qx: null,
  qy: null
};

// node_modules/@antv/util/esm/path/process/fix-arc.js
function fixArc(pathArray, allPathCommands, i) {
  if (pathArray[i].length > 7) {
    pathArray[i].shift();
    var pi = pathArray[i];
    var ni = i;
    while (pi.length) {
      allPathCommands[i] = "A";
      pathArray.splice(ni += 1, 0, ["C"].concat(pi.splice(0, 6)));
    }
    pathArray.splice(i, 1);
  }
}

// node_modules/@antv/util/esm/path/parser/params-count.js
var paramsCount = {
  a: 7,
  c: 6,
  h: 1,
  l: 2,
  m: 2,
  r: 4,
  q: 4,
  s: 4,
  t: 2,
  v: 1,
  z: 0
};

// node_modules/@antv/util/esm/path/util/is-path-array.js
function isPathArray(path) {
  return Array.isArray(path) && path.every(function(seg) {
    var lk = seg[0].toLowerCase();
    return paramsCount[lk] === seg.length - 1 && "achlmqstvz".includes(lk);
  });
}

// node_modules/@antv/util/esm/path/util/is-absolute-array.js
function isAbsoluteArray(path) {
  return isPathArray(path) && // @ts-ignore -- `isPathArray` also checks if it's `Array`
  path.every(function(_a2) {
    var x3 = _a2[0];
    return x3 === x3.toUpperCase();
  });
}

// node_modules/@antv/util/esm/path/util/is-normalized-array.js
function isNormalizedArray(path) {
  return isAbsoluteArray(path) && path.every(function(_a2) {
    var pc = _a2[0];
    return "ACLMQZ".includes(pc);
  });
}

// node_modules/@antv/util/esm/path/parser/finalize-segment.js
function finalizeSegment(path) {
  var pathCommand = path.pathValue[path.segmentStart];
  var LK = pathCommand.toLowerCase();
  var data2 = path.data;
  while (data2.length >= paramsCount[LK]) {
    if (LK === "m" && data2.length > 2) {
      path.segments.push([pathCommand].concat(data2.splice(0, 2)));
      LK = "l";
      pathCommand = pathCommand === "m" ? "l" : "L";
    } else {
      path.segments.push([pathCommand].concat(data2.splice(0, paramsCount[LK])));
    }
    if (!paramsCount[LK]) {
      break;
    }
  }
}

// node_modules/@antv/util/esm/path/parser/scan-flag.js
function scanFlag(path) {
  var index2 = path.index, pathValue = path.pathValue;
  var code = pathValue.charCodeAt(index2);
  if (code === 48) {
    path.param = 0;
    path.index += 1;
    return;
  }
  if (code === 49) {
    path.param = 1;
    path.index += 1;
    return;
  }
  path.err = '[path-util]: invalid Arc flag "'.concat(pathValue[index2], '", expecting 0 or 1 at index ').concat(index2);
}

// node_modules/@antv/util/esm/path/parser/is-digit-start.js
function isDigitStart(code) {
  return code >= 48 && code <= 57 || code === 43 || code === 45 || code === 46;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}

// node_modules/@antv/util/esm/path/parser/scan-param.js
function scanParam(path) {
  var max6 = path.max, pathValue = path.pathValue, start = path.index;
  var index2 = start;
  var zeroFirst = false;
  var hasCeiling = false;
  var hasDecimal = false;
  var hasDot = false;
  var ch;
  if (index2 >= max6) {
    path.err = "[path-util]: Invalid path value at index ".concat(index2, ', "pathValue" is missing param');
    return;
  }
  ch = pathValue.charCodeAt(index2);
  if (ch === 43 || ch === 45) {
    index2 += 1;
    ch = pathValue.charCodeAt(index2);
  }
  if (!isDigit(ch) && ch !== 46) {
    path.err = "[path-util]: Invalid path value at index ".concat(index2, ', "').concat(pathValue[index2], '" is not a number');
    return;
  }
  if (ch !== 46) {
    zeroFirst = ch === 48;
    index2 += 1;
    ch = pathValue.charCodeAt(index2);
    if (zeroFirst && index2 < max6) {
      if (ch && isDigit(ch)) {
        path.err = "[path-util]: Invalid path value at index ".concat(start, ', "').concat(pathValue[start], '" illegal number');
        return;
      }
    }
    while (index2 < max6 && isDigit(pathValue.charCodeAt(index2))) {
      index2 += 1;
      hasCeiling = true;
    }
    ch = pathValue.charCodeAt(index2);
  }
  if (ch === 46) {
    hasDot = true;
    index2 += 1;
    while (isDigit(pathValue.charCodeAt(index2))) {
      index2 += 1;
      hasDecimal = true;
    }
    ch = pathValue.charCodeAt(index2);
  }
  if (ch === 101 || ch === 69) {
    if (hasDot && !hasCeiling && !hasDecimal) {
      path.err = "[path-util]: Invalid path value at index ".concat(index2, ', "').concat(pathValue[index2], '" invalid float exponent');
      return;
    }
    index2 += 1;
    ch = pathValue.charCodeAt(index2);
    if (ch === 43 || ch === 45) {
      index2 += 1;
    }
    if (index2 < max6 && isDigit(pathValue.charCodeAt(index2))) {
      while (index2 < max6 && isDigit(pathValue.charCodeAt(index2))) {
        index2 += 1;
      }
    } else {
      path.err = "[path-util]: Invalid path value at index ".concat(index2, ', "').concat(pathValue[index2], '" invalid integer exponent');
      return;
    }
  }
  path.index = index2;
  path.param = +path.pathValue.slice(start, index2);
}

// node_modules/@antv/util/esm/path/parser/is-space.js
function isSpace(ch) {
  var specialSpaces = [
    5760,
    6158,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8199,
    8200,
    8201,
    8202,
    8239,
    8287,
    12288,
    65279
  ];
  return ch === 10 || ch === 13 || ch === 8232 || ch === 8233 || // Line terminators
  // White spaces
  ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && specialSpaces.includes(ch);
}

// node_modules/@antv/util/esm/path/parser/skip-spaces.js
function skipSpaces(path) {
  var pathValue = path.pathValue, max6 = path.max;
  while (path.index < max6 && isSpace(pathValue.charCodeAt(path.index))) {
    path.index += 1;
  }
}

// node_modules/@antv/util/esm/path/parser/is-path-command.js
function isPathCommand(code) {
  switch (code | 32) {
    case 109:
    case 122:
    case 108:
    case 104:
    case 118:
    case 99:
    case 115:
    case 113:
    case 116:
    case 97:
      return true;
    default:
      return false;
  }
}

// node_modules/@antv/util/esm/path/parser/is-arc-command.js
function isArcCommand(code) {
  return (code | 32) === 97;
}

// node_modules/@antv/util/esm/path/parser/scan-segment.js
function scanSegment(path) {
  var max6 = path.max, pathValue = path.pathValue, index2 = path.index;
  var cmdCode = pathValue.charCodeAt(index2);
  var reqParams = paramsCount[pathValue[index2].toLowerCase()];
  path.segmentStart = index2;
  if (!isPathCommand(cmdCode)) {
    path.err = '[path-util]: Invalid path value "'.concat(pathValue[index2], '" is not a path command');
    return;
  }
  path.index += 1;
  skipSpaces(path);
  path.data = [];
  if (!reqParams) {
    finalizeSegment(path);
    return;
  }
  for (; ; ) {
    for (var i = reqParams; i > 0; i -= 1) {
      if (isArcCommand(cmdCode) && (i === 3 || i === 4))
        scanFlag(path);
      else
        scanParam(path);
      if (path.err.length) {
        return;
      }
      path.data.push(path.param);
      skipSpaces(path);
      if (path.index < max6 && pathValue.charCodeAt(path.index) === 44) {
        path.index += 1;
        skipSpaces(path);
      }
    }
    if (path.index >= path.max) {
      break;
    }
    if (!isDigitStart(pathValue.charCodeAt(path.index))) {
      break;
    }
  }
  finalizeSegment(path);
}

// node_modules/@antv/util/esm/path/parser/path-parser.js
var PathParser = (
  /** @class */
  /* @__PURE__ */ function() {
    function PathParser2(pathString) {
      this.pathValue = pathString;
      this.segments = [];
      this.max = pathString.length;
      this.index = 0;
      this.param = 0;
      this.segmentStart = 0;
      this.data = [];
      this.err = "";
    }
    return PathParser2;
  }()
);

// node_modules/@antv/util/esm/path/parser/parse-path-string.js
function parsePathString(pathInput) {
  if (isPathArray(pathInput)) {
    return [].concat(pathInput);
  }
  var path = new PathParser(pathInput);
  skipSpaces(path);
  while (path.index < path.max && !path.err.length) {
    scanSegment(path);
  }
  return path.err ? path.err : path.segments;
}

// node_modules/@antv/util/esm/path/convert/path-2-absolute.js
function path2Absolute(pathInput) {
  if (isAbsoluteArray(pathInput)) {
    return [].concat(pathInput);
  }
  var path = parsePathString(pathInput);
  var x3 = 0;
  var y3 = 0;
  var mx = 0;
  var my = 0;
  return path.map(function(segment) {
    var values = segment.slice(1).map(Number);
    var pathCommand = segment[0];
    var absCommand = pathCommand.toUpperCase();
    if (pathCommand === "M") {
      x3 = values[0], y3 = values[1];
      mx = x3;
      my = y3;
      return ["M", x3, y3];
    }
    var absoluteSegment;
    if (pathCommand !== absCommand) {
      switch (absCommand) {
        case "A":
          absoluteSegment = [
            absCommand,
            values[0],
            values[1],
            values[2],
            values[3],
            values[4],
            values[5] + x3,
            values[6] + y3
          ];
          break;
        case "V":
          absoluteSegment = [absCommand, values[0] + y3];
          break;
        case "H":
          absoluteSegment = [absCommand, values[0] + x3];
          break;
        default: {
          var absValues = values.map(function(n, j) {
            return n + (j % 2 ? y3 : x3);
          });
          absoluteSegment = [absCommand].concat(absValues);
        }
      }
    } else {
      absoluteSegment = [absCommand].concat(values);
    }
    var segLength = absoluteSegment.length;
    switch (absCommand) {
      case "Z":
        x3 = mx;
        y3 = my;
        break;
      case "H":
        x3 = absoluteSegment[1];
        break;
      case "V":
        y3 = absoluteSegment[1];
        break;
      default:
        x3 = absoluteSegment[segLength - 2];
        y3 = absoluteSegment[segLength - 1];
        if (absCommand === "M") {
          mx = x3;
          my = y3;
        }
    }
    return absoluteSegment;
  });
}

// node_modules/@antv/util/esm/path/process/normalize-segment.js
function normalizeSegment(segment, params) {
  var pathCommand = segment[0];
  var px1 = params.x1, py1 = params.y1, px2 = params.x2, py2 = params.y2;
  var values = segment.slice(1).map(Number);
  var result = segment;
  if (!"TQ".includes(pathCommand)) {
    params.qx = null;
    params.qy = null;
  }
  if (pathCommand === "H") {
    result = ["L", segment[1], py1];
  } else if (pathCommand === "V") {
    result = ["L", px1, segment[1]];
  } else if (pathCommand === "S") {
    var x1 = px1 * 2 - px2;
    var y1 = py1 * 2 - py2;
    params.x1 = x1;
    params.y1 = y1;
    result = ["C", x1, y1].concat(values);
  } else if (pathCommand === "T") {
    var qx = px1 * 2 - params.qx;
    var qy = py1 * 2 - params.qy;
    params.qx = qx;
    params.qy = qy;
    result = ["Q", qx, qy].concat(values);
  } else if (pathCommand === "Q") {
    var nqx = values[0], nqy = values[1];
    params.qx = nqx;
    params.qy = nqy;
  }
  return result;
}

// node_modules/@antv/util/esm/path/process/normalize-path.js
function normalizePath(pathInput) {
  if (isNormalizedArray(pathInput)) {
    return [].concat(pathInput);
  }
  var path = path2Absolute(pathInput);
  var params = __assign({}, paramsParser);
  for (var i = 0; i < path.length; i += 1) {
    path[i] = normalizeSegment(path[i], params);
    var segment = path[i];
    var seglen = segment.length;
    params.x1 = +segment[seglen - 2];
    params.y1 = +segment[seglen - 1];
    params.x2 = +segment[seglen - 4] || params.x1;
    params.y2 = +segment[seglen - 3] || params.y1;
  }
  return path;
}

// node_modules/@antv/util/esm/path/util/is-curve-array.js
function isCurveArray(path) {
  return isNormalizedArray(path) && path.every(function(_a2) {
    var pc = _a2[0];
    return "MC".includes(pc);
  });
}

// node_modules/@antv/util/esm/path/util/rotate-vector.js
function rotateVector(x3, y3, rad2) {
  var X = x3 * Math.cos(rad2) - y3 * Math.sin(rad2);
  var Y = x3 * Math.sin(rad2) + y3 * Math.cos(rad2);
  return { x: X, y: Y };
}

// node_modules/@antv/util/esm/path/process/arc-2-cubic.js
function arcToCubic(X1, Y1, RX, RY, angle3, LAF, SF, X2, Y2, recursive) {
  var x1 = X1;
  var y1 = Y1;
  var rx = RX;
  var ry = RY;
  var x22 = X2;
  var y22 = Y2;
  var d120 = Math.PI * 120 / 180;
  var rad2 = Math.PI / 180 * (+angle3 || 0);
  var res = [];
  var xy;
  var f1;
  var f2;
  var cx;
  var cy;
  if (!recursive) {
    xy = rotateVector(x1, y1, -rad2);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotateVector(x22, y22, -rad2);
    x22 = xy.x;
    y22 = xy.y;
    var x3 = (x1 - x22) / 2;
    var y3 = (y1 - y22) / 2;
    var h = x3 * x3 / (rx * rx) + y3 * y3 / (ry * ry);
    if (h > 1) {
      h = Math.sqrt(h);
      rx *= h;
      ry *= h;
    }
    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k = (LAF === SF ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y3 * y3 - ry2 * x3 * x3) / (rx2 * y3 * y3 + ry2 * x3 * x3)));
    cx = k * rx * y3 / ry + (x1 + x22) / 2;
    cy = k * -ry * x3 / rx + (y1 + y22) / 2;
    f1 = Math.asin(((y1 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
    f2 = Math.asin(((y22 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x22 < cx ? Math.PI - f2 : f2;
    if (f1 < 0)
      f1 = Math.PI * 2 + f1;
    if (f2 < 0)
      f2 = Math.PI * 2 + f2;
    if (SF && f1 > f2) {
      f1 -= Math.PI * 2;
    }
    if (!SF && f2 > f1) {
      f2 -= Math.PI * 2;
    }
  } else {
    f1 = recursive[0], f2 = recursive[1], cx = recursive[2], cy = recursive[3];
  }
  var df = f2 - f1;
  if (Math.abs(df) > d120) {
    var f2old = f2;
    var x2old = x22;
    var y2old = y22;
    f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);
    x22 = cx + rx * Math.cos(f2);
    y22 = cy + ry * Math.sin(f2);
    res = arcToCubic(x22, y22, rx, ry, angle3, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  var c1 = Math.cos(f1);
  var s1 = Math.sin(f1);
  var c2 = Math.cos(f2);
  var s2 = Math.sin(f2);
  var t = Math.tan(df / 4);
  var hx = 4 / 3 * rx * t;
  var hy = 4 / 3 * ry * t;
  var m1 = [x1, y1];
  var m2 = [x1 + hx * s1, y1 - hy * c1];
  var m3 = [x22 + hx * s2, y22 - hy * c2];
  var m4 = [x22, y22];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];
  if (recursive) {
    return m2.concat(m3, m4, res);
  }
  res = m2.concat(m3, m4, res);
  var newres = [];
  for (var i = 0, ii = res.length; i < ii; i += 1) {
    newres[i] = i % 2 ? rotateVector(res[i - 1], res[i], rad2).y : rotateVector(res[i], res[i + 1], rad2).x;
  }
  return newres;
}

// node_modules/@antv/util/esm/path/process/quad-2-cubic.js
function quadToCubic(x1, y1, qx, qy, x22, y22) {
  var r13 = 1 / 3;
  var r23 = 2 / 3;
  return [
    r13 * x1 + r23 * qx,
    // cpx1
    r13 * y1 + r23 * qy,
    // cpy1
    r13 * x22 + r23 * qx,
    // cpx2
    r13 * y22 + r23 * qy,
    // cpy2
    x22,
    y22
    // x,y
  ];
}

// node_modules/@antv/util/esm/path/util/mid-point.js
function midPoint(a2, b, t) {
  var ax = a2[0];
  var ay = a2[1];
  var bx = b[0];
  var by = b[1];
  return [ax + (bx - ax) * t, ay + (by - ay) * t];
}

// node_modules/@antv/util/esm/path/process/line-2-cubic.js
var lineToCubic = function(x1, y1, x22, y22) {
  var t = 0.5;
  var mid = midPoint([x1, y1], [x22, y22], t);
  return __spreadArray(__spreadArray([], mid, true), [x22, y22, x22, y22], false);
};

// node_modules/@antv/util/esm/path/process/segment-2-cubic.js
function segmentToCubic(segment, params) {
  var pathCommand = segment[0];
  var values = segment.slice(1).map(Number);
  var x3 = values[0], y3 = values[1];
  var args;
  var px1 = params.x1, py1 = params.y1, px2 = params.x, py = params.y;
  if (!"TQ".includes(pathCommand)) {
    params.qx = null;
    params.qy = null;
  }
  switch (pathCommand) {
    case "M":
      params.x = x3;
      params.y = y3;
      return segment;
    case "A":
      args = [px1, py1].concat(values);
      return ["C"].concat(arcToCubic(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]));
    case "Q":
      params.qx = x3;
      params.qy = y3;
      args = [px1, py1].concat(values);
      return ["C"].concat(quadToCubic(args[0], args[1], args[2], args[3], args[4], args[5]));
    case "L":
      return ["C"].concat(lineToCubic(px1, py1, x3, y3));
    case "Z":
      if (px1 === px2 && py1 === py) {
        return ["C", px1, py1, px2, py, px2, py];
      }
      return ["C"].concat(lineToCubic(px1, py1, px2, py));
    default:
  }
  return segment;
}

// node_modules/@antv/util/esm/path/convert/path-2-curve.js
function path2Curve(pathInput, needZCommandIndexes) {
  if (needZCommandIndexes === void 0) {
    needZCommandIndexes = false;
  }
  if (isCurveArray(pathInput)) {
    var cloned = [].concat(pathInput);
    if (needZCommandIndexes) {
      return [cloned, []];
    } else {
      return cloned;
    }
  }
  var path = normalizePath(pathInput);
  var params = __assign({}, paramsParser);
  var allPathCommands = [];
  var pathCommand = "";
  var ii = path.length;
  var segment;
  var seglen;
  var zCommandIndexes = [];
  for (var i = 0; i < ii; i += 1) {
    if (path[i])
      pathCommand = path[i][0];
    allPathCommands[i] = pathCommand;
    var curveSegment = segmentToCubic(path[i], params);
    path[i] = curveSegment;
    fixArc(path, allPathCommands, i);
    ii = path.length;
    if (pathCommand === "Z") {
      zCommandIndexes.push(i);
    }
    segment = path[i];
    seglen = segment.length;
    params.x1 = +segment[seglen - 2];
    params.y1 = +segment[seglen - 1];
    params.x2 = +segment[seglen - 4] || params.x1;
    params.y2 = +segment[seglen - 3] || params.y1;
  }
  if (needZCommandIndexes) {
    return [path, zCommandIndexes];
  } else {
    return path;
  }
}

// node_modules/@antv/util/esm/path/process/clone-path.js
function clonePath(path) {
  return path.map(function(x3) {
    return Array.isArray(x3) ? [].concat(x3) : x3;
  });
}

// node_modules/@antv/util/esm/path/process/reverse-curve.js
function reverseCurve(pathArray) {
  var rotatedCurve = pathArray.slice(1).map(function(x3, i, curveOnly) {
    return !i ? pathArray[0].slice(1).concat(x3.slice(1)) : curveOnly[i - 1].slice(-2).concat(x3.slice(1));
  }).map(function(x3) {
    return x3.map(function(y3, i) {
      return x3[x3.length - i - 2 * (1 - i % 2)];
    });
  }).reverse();
  return [["M"].concat(rotatedCurve[0].slice(0, 2))].concat(rotatedCurve.map(function(x3) {
    return ["C"].concat(x3.slice(2));
  }));
}

// node_modules/@antv/util/esm/path/util/distance-square-root.js
function distanceSquareRoot(a2, b) {
  return Math.sqrt((a2[0] - b[0]) * (a2[0] - b[0]) + (a2[1] - b[1]) * (a2[1] - b[1]));
}

// node_modules/@antv/util/esm/path/util/segment-line-factory.js
function segmentLineFactory(x1, y1, x22, y22, distance6) {
  var length5 = distanceSquareRoot([x1, y1], [x22, y22]);
  var point2 = { x: 0, y: 0 };
  if (typeof distance6 === "number") {
    if (distance6 <= 0) {
      point2 = { x: x1, y: y1 };
    } else if (distance6 >= length5) {
      point2 = { x: x22, y: y22 };
    } else {
      var _a2 = midPoint([x1, y1], [x22, y22], distance6 / length5), x3 = _a2[0], y3 = _a2[1];
      point2 = { x: x3, y: y3 };
    }
  }
  return {
    length: length5,
    point: point2,
    min: {
      x: Math.min(x1, x22),
      y: Math.min(y1, y22)
    },
    max: {
      x: Math.max(x1, x22),
      y: Math.max(y1, y22)
    }
  };
}

// node_modules/@antv/util/esm/path/util/segment-arc-factory.js
function angleBetween(v0, v1) {
  var v0x = v0.x, v0y = v0.y;
  var v1x = v1.x, v1y = v1.y;
  var p = v0x * v1x + v0y * v1y;
  var n = Math.sqrt((Math.pow(v0x, 2) + Math.pow(v0y, 2)) * (Math.pow(v1x, 2) + Math.pow(v1y, 2)));
  var sign = v0x * v1y - v0y * v1x < 0 ? -1 : 1;
  var angle3 = sign * Math.acos(p / n);
  return angle3;
}
function getPointAtArcSegmentLength(x1, y1, RX, RY, angle3, LAF, SF, x3, y3, t) {
  var abs = Math.abs, sin = Math.sin, cos = Math.cos, sqrt = Math.sqrt, PI = Math.PI;
  var rx = abs(RX);
  var ry = abs(RY);
  var xRot = (angle3 % 360 + 360) % 360;
  var xRotRad = xRot * (PI / 180);
  if (x1 === x3 && y1 === y3) {
    return { x: x1, y: y1 };
  }
  if (rx === 0 || ry === 0) {
    return segmentLineFactory(x1, y1, x3, y3, t).point;
  }
  var dx = (x1 - x3) / 2;
  var dy = (y1 - y3) / 2;
  var transformedPoint = {
    x: cos(xRotRad) * dx + sin(xRotRad) * dy,
    y: -sin(xRotRad) * dx + cos(xRotRad) * dy
  };
  var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
  if (radiiCheck > 1) {
    rx *= sqrt(radiiCheck);
    ry *= sqrt(radiiCheck);
  }
  var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cRadicand = cSquareNumerator / cSquareRootDenom;
  cRadicand = cRadicand < 0 ? 0 : cRadicand;
  var cCoef = (LAF !== SF ? 1 : -1) * sqrt(cRadicand);
  var transformedCenter = {
    x: cCoef * (rx * transformedPoint.y / ry),
    y: cCoef * (-(ry * transformedPoint.x) / rx)
  };
  var center = {
    x: cos(xRotRad) * transformedCenter.x - sin(xRotRad) * transformedCenter.y + (x1 + x3) / 2,
    y: sin(xRotRad) * transformedCenter.x + cos(xRotRad) * transformedCenter.y + (y1 + y3) / 2
  };
  var startVector = {
    x: (transformedPoint.x - transformedCenter.x) / rx,
    y: (transformedPoint.y - transformedCenter.y) / ry
  };
  var startAngle = angleBetween({ x: 1, y: 0 }, startVector);
  var endVector = {
    x: (-transformedPoint.x - transformedCenter.x) / rx,
    y: (-transformedPoint.y - transformedCenter.y) / ry
  };
  var sweepAngle = angleBetween(startVector, endVector);
  if (!SF && sweepAngle > 0) {
    sweepAngle -= 2 * PI;
  } else if (SF && sweepAngle < 0) {
    sweepAngle += 2 * PI;
  }
  sweepAngle %= 2 * PI;
  var alpha = startAngle + sweepAngle * t;
  var ellipseComponentX = rx * cos(alpha);
  var ellipseComponentY = ry * sin(alpha);
  var point2 = {
    x: cos(xRotRad) * ellipseComponentX - sin(xRotRad) * ellipseComponentY + center.x,
    y: sin(xRotRad) * ellipseComponentX + cos(xRotRad) * ellipseComponentY + center.y
  };
  return point2;
}
function segmentArcFactory(X1, Y1, RX, RY, angle3, LAF, SF, X2, Y2, distance6, options) {
  var _a2;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length5 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 30 : _d;
  var distanceIsNumber = typeof distance6 === "number";
  var x3 = X1;
  var y3 = Y1;
  var LENGTH = 0;
  var prev = [x3, y3, LENGTH];
  var cur = [x3, y3];
  var t = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x: x3, y: y3 }];
  if (distanceIsNumber && distance6 <= 0) {
    POINT = { x: x3, y: y3 };
  }
  for (var j = 0; j <= sampleSize; j += 1) {
    t = j / sampleSize;
    _a2 = getPointAtArcSegmentLength(X1, Y1, RX, RY, angle3, LAF, SF, X2, Y2, t), x3 = _a2.x, y3 = _a2.y;
    if (bbox) {
      POINTS.push({ x: x3, y: y3 });
    }
    if (length5) {
      LENGTH += distanceSquareRoot(cur, [x3, y3]);
    }
    cur = [x3, y3];
    if (distanceIsNumber && LENGTH >= distance6 && distance6 > prev[2]) {
      var dv = (LENGTH - distance6) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x3, y3, LENGTH];
  }
  if (distanceIsNumber && distance6 >= LENGTH) {
    POINT = { x: X2, y: Y2 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    }
  };
}

// node_modules/@antv/util/esm/path/util/segment-cubic-factory.js
function getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x22, y22, t) {
  var t1 = 1 - t;
  return {
    x: Math.pow(t1, 3) * x1 + 3 * Math.pow(t1, 2) * t * c1x + 3 * t1 * Math.pow(t, 2) * c2x + Math.pow(t, 3) * x22,
    y: Math.pow(t1, 3) * y1 + 3 * Math.pow(t1, 2) * t * c1y + 3 * t1 * Math.pow(t, 2) * c2y + Math.pow(t, 3) * y22
  };
}
function segmentCubicFactory(x1, y1, c1x, c1y, c2x, c2y, x22, y22, distance6, options) {
  var _a2;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length5 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
  var distanceIsNumber = typeof distance6 === "number";
  var x3 = x1;
  var y3 = y1;
  var LENGTH = 0;
  var prev = [x3, y3, LENGTH];
  var cur = [x3, y3];
  var t = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x: x3, y: y3 }];
  if (distanceIsNumber && distance6 <= 0) {
    POINT = { x: x3, y: y3 };
  }
  for (var j = 0; j <= sampleSize; j += 1) {
    t = j / sampleSize;
    _a2 = getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x22, y22, t), x3 = _a2.x, y3 = _a2.y;
    if (bbox) {
      POINTS.push({ x: x3, y: y3 });
    }
    if (length5) {
      LENGTH += distanceSquareRoot(cur, [x3, y3]);
    }
    cur = [x3, y3];
    if (distanceIsNumber && LENGTH >= distance6 && distance6 > prev[2]) {
      var dv = (LENGTH - distance6) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x3, y3, LENGTH];
  }
  if (distanceIsNumber && distance6 >= LENGTH) {
    POINT = { x: x22, y: y22 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    }
  };
}

// node_modules/@antv/util/esm/path/util/segment-quad-factory.js
function getPointAtQuadSegmentLength(x1, y1, cx, cy, x22, y22, t) {
  var t1 = 1 - t;
  return {
    x: Math.pow(t1, 2) * x1 + 2 * t1 * t * cx + Math.pow(t, 2) * x22,
    y: Math.pow(t1, 2) * y1 + 2 * t1 * t * cy + Math.pow(t, 2) * y22
  };
}
function segmentQuadFactory(x1, y1, qx, qy, x22, y22, distance6, options) {
  var _a2;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length5 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
  var distanceIsNumber = typeof distance6 === "number";
  var x3 = x1;
  var y3 = y1;
  var LENGTH = 0;
  var prev = [x3, y3, LENGTH];
  var cur = [x3, y3];
  var t = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x: x3, y: y3 }];
  if (distanceIsNumber && distance6 <= 0) {
    POINT = { x: x3, y: y3 };
  }
  for (var j = 0; j <= sampleSize; j += 1) {
    t = j / sampleSize;
    _a2 = getPointAtQuadSegmentLength(x1, y1, qx, qy, x22, y22, t), x3 = _a2.x, y3 = _a2.y;
    if (bbox) {
      POINTS.push({ x: x3, y: y3 });
    }
    if (length5) {
      LENGTH += distanceSquareRoot(cur, [x3, y3]);
    }
    cur = [x3, y3];
    if (distanceIsNumber && LENGTH >= distance6 && distance6 > prev[2]) {
      var dv = (LENGTH - distance6) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x3, y3, LENGTH];
  }
  if (distanceIsNumber && distance6 >= LENGTH) {
    POINT = { x: x22, y: y22 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n) {
        return n.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n) {
        return n.y;
      }))
    }
  };
}

// node_modules/@antv/util/esm/path/util/path-length-factory.js
function pathLengthFactory(pathInput, distance6, options) {
  var _a2, _b, _c, _d, _e, _f;
  var path = normalizePath(pathInput);
  var distanceIsNumber = typeof distance6 === "number";
  var isM;
  var data2 = [];
  var pathCommand;
  var x3 = 0;
  var y3 = 0;
  var mx = 0;
  var my = 0;
  var seg;
  var MIN = [];
  var MAX = [];
  var length5 = 0;
  var min5 = { x: 0, y: 0 };
  var max6 = min5;
  var point2 = min5;
  var POINT = min5;
  var LENGTH = 0;
  for (var i = 0, ll = path.length; i < ll; i += 1) {
    seg = path[i];
    pathCommand = seg[0];
    isM = pathCommand === "M";
    data2 = !isM ? [x3, y3].concat(seg.slice(1)) : data2;
    if (isM) {
      mx = seg[1], my = seg[2];
      min5 = { x: mx, y: my };
      max6 = min5;
      length5 = 0;
      if (distanceIsNumber && distance6 < 1e-3) {
        POINT = min5;
      }
    } else if (pathCommand === "L") {
      _a2 = segmentLineFactory(data2[0], data2[1], data2[2], data2[3], (distance6 || 0) - LENGTH), length5 = _a2.length, min5 = _a2.min, max6 = _a2.max, point2 = _a2.point;
    } else if (pathCommand === "A") {
      _b = segmentArcFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], data2[6], data2[7], data2[8], (distance6 || 0) - LENGTH, options || {}), length5 = _b.length, min5 = _b.min, max6 = _b.max, point2 = _b.point;
    } else if (pathCommand === "C") {
      _c = segmentCubicFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], data2[6], data2[7], (distance6 || 0) - LENGTH, options || {}), length5 = _c.length, min5 = _c.min, max6 = _c.max, point2 = _c.point;
    } else if (pathCommand === "Q") {
      _d = segmentQuadFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], (distance6 || 0) - LENGTH, options || {}), length5 = _d.length, min5 = _d.min, max6 = _d.max, point2 = _d.point;
    } else if (pathCommand === "Z") {
      data2 = [x3, y3, mx, my];
      _e = segmentLineFactory(data2[0], data2[1], data2[2], data2[3], (distance6 || 0) - LENGTH), length5 = _e.length, min5 = _e.min, max6 = _e.max, point2 = _e.point;
    }
    if (distanceIsNumber && LENGTH < distance6 && LENGTH + length5 >= distance6) {
      POINT = point2;
    }
    MAX.push(max6);
    MIN.push(min5);
    LENGTH += length5;
    _f = pathCommand !== "Z" ? seg.slice(-2) : [mx, my], x3 = _f[0], y3 = _f[1];
  }
  if (distanceIsNumber && distance6 >= LENGTH) {
    POINT = { x: x3, y: y3 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, MIN.map(function(n) {
        return n.x;
      })),
      y: Math.min.apply(null, MIN.map(function(n) {
        return n.y;
      }))
    },
    max: {
      x: Math.max.apply(null, MAX.map(function(n) {
        return n.x;
      })),
      y: Math.max.apply(null, MAX.map(function(n) {
        return n.y;
      }))
    }
  };
}

// node_modules/@antv/util/esm/path/util/get-total-length.js
function getTotalLength(pathInput, options) {
  return pathLengthFactory(pathInput, void 0, __assign(__assign({}, options), { bbox: false, length: true })).length;
}

// node_modules/@antv/util/esm/path/util/get-rotated-curve.js
function getRotations(a2) {
  var segCount = a2.length;
  var pointCount = segCount - 1;
  return a2.map(function(f, idx) {
    return a2.map(function(p, i) {
      var oldSegIdx = idx + i;
      var seg;
      if (i === 0 || a2[oldSegIdx] && a2[oldSegIdx][0] === "M") {
        seg = a2[oldSegIdx];
        return ["M"].concat(seg.slice(-2));
      }
      if (oldSegIdx >= segCount)
        oldSegIdx -= pointCount;
      return a2[oldSegIdx];
    });
  });
}
function getRotatedCurve(a2, b) {
  var segCount = a2.length - 1;
  var lineLengths = [];
  var computedIndex = 0;
  var sumLensSqrd = 0;
  var rotations = getRotations(a2);
  rotations.forEach(function(r, i) {
    a2.slice(1).forEach(function(s2, j) {
      sumLensSqrd += distanceSquareRoot(a2[(i + j) % segCount].slice(-2), b[j % segCount].slice(-2));
    });
    lineLengths[i] = sumLensSqrd;
    sumLensSqrd = 0;
  });
  computedIndex = lineLengths.indexOf(Math.min.apply(null, lineLengths));
  return rotations[computedIndex];
}

// node_modules/@antv/util/esm/path/util/get-path-area.js
function getCubicSegArea(x1, y1, c1x, c1y, c2x, c2y, x22, y22) {
  return 3 * ((y22 - y1) * (c1x + c2x) - (x22 - x1) * (c1y + c2y) + c1y * (x1 - c2x) - c1x * (y1 - c2y) + y22 * (c2x + x1 / 3) - x22 * (c2y + y1 / 3)) / 20;
}
function getPathArea(path) {
  var x3 = 0;
  var y3 = 0;
  var len5 = 0;
  return path2Curve(path).map(function(seg) {
    var _a2;
    switch (seg[0]) {
      case "M":
        x3 = seg[1], y3 = seg[2];
        return 0;
      default:
        var _b = seg.slice(1), c1x = _b[0], c1y = _b[1], c2x = _b[2], c2y = _b[3], x22 = _b[4], y22 = _b[5];
        len5 = getCubicSegArea(x3, y3, c1x, c1y, c2x, c2y, x22, y22);
        _a2 = seg.slice(-2), x3 = _a2[0], y3 = _a2[1];
        return len5;
    }
  }).reduce(function(a2, b) {
    return a2 + b;
  }, 0);
}

// node_modules/@antv/util/esm/path/util/get-draw-direction.js
function getDrawDirection(pathArray) {
  return getPathArea(pathArray) >= 0;
}

// node_modules/@antv/util/esm/path/util/get-point-at-length.js
function getPointAtLength(pathInput, distance6, options) {
  return pathLengthFactory(pathInput, distance6, __assign(__assign({}, options), { bbox: false, length: true })).point;
}

// node_modules/@antv/util/esm/path/util/equalize-segments.js
var MAX_RECURSION_DEPTH = 50;
function splitCubic(pts, t) {
  if (t === void 0) {
    t = 0.5;
  }
  var p0 = pts.slice(0, 2);
  var p1 = pts.slice(2, 4);
  var p2 = pts.slice(4, 6);
  var p3 = pts.slice(6, 8);
  var p4 = midPoint(p0, p1, t);
  var p5 = midPoint(p1, p2, t);
  var p6 = midPoint(p2, p3, t);
  var p7 = midPoint(p4, p5, t);
  var p8 = midPoint(p5, p6, t);
  var p9 = midPoint(p7, p8, t);
  return [
    // @ts-ignore
    ["C"].concat(p4, p7, p9),
    // @ts-ignore
    ["C"].concat(p8, p6, p3)
  ];
}
function getCurveArray(segments) {
  return segments.map(function(segment, i, pathArray) {
    var segmentData = i && pathArray[i - 1].slice(-2).concat(segment.slice(1));
    var curveLength = i ? segmentCubicFactory(segmentData[0], segmentData[1], segmentData[2], segmentData[3], segmentData[4], segmentData[5], segmentData[6], segmentData[7], segmentData[8], { bbox: false }).length : 0;
    var subsegs;
    if (i) {
      subsegs = curveLength ? splitCubic(segmentData) : [segment, segment];
    } else {
      subsegs = [segment];
    }
    return {
      s: segment,
      ss: subsegs,
      l: curveLength
    };
  });
}
function equalizeSegments(path1, path2, TL, depth) {
  if (depth === void 0) {
    depth = 0;
  }
  if (depth > MAX_RECURSION_DEPTH) {
    console.warn("Maximum recursion depth reached in equalizeSegments");
    return [path1, path2];
  }
  var c1 = getCurveArray(path1);
  var c2 = getCurveArray(path2);
  var L1 = c1.length;
  var L2 = c2.length;
  var l1 = c1.filter(function(x3) {
    return x3.l;
  }).length;
  var l2 = c2.filter(function(x3) {
    return x3.l;
  }).length;
  var m1 = c1.filter(function(x3) {
    return x3.l;
  }).reduce(function(a2, _a2) {
    var l = _a2.l;
    return a2 + l;
  }, 0) / l1 || 0;
  var m2 = c2.filter(function(x3) {
    return x3.l;
  }).reduce(function(a2, _a2) {
    var l = _a2.l;
    return a2 + l;
  }, 0) / l2 || 0;
  var tl = TL || Math.max(L1, L2);
  var mm = [m1, m2];
  var dif = [tl - L1, tl - L2];
  var canSplit = 0;
  var result = [c1, c2].map(function(x3, i) {
    return x3.l === tl ? x3.map(function(y3) {
      return y3.s;
    }) : x3.map(function(y3, j) {
      canSplit = j && dif[i] && y3.l >= mm[i];
      dif[i] -= canSplit ? 1 : 0;
      return canSplit ? y3.ss : [y3.s];
    }).flat();
  });
  return result[0].length === result[1].length ? result : equalizeSegments(result[0], result[1], tl, depth + 1);
}

// node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);
var eventemitter3_default = import_index.default;

// node_modules/@antv/g-lite/dist/index.esm.js
init_defineProperty();

// node_modules/@babel/runtime/helpers/esm/superPropBase.js
function _superPropBase(t, o) {
  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)); ) ;
  return t;
}

// node_modules/@babel/runtime/helpers/esm/get.js
function _get() {
  return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {
    var p = _superPropBase(e, t);
    if (p) {
      var n = Object.getOwnPropertyDescriptor(p, t);
      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
    }
  }, _get.apply(null, arguments);
}

// node_modules/@babel/runtime/helpers/esm/superPropGet.js
function _superPropGet(t, o, e, r) {
  var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e);
  return 2 & r && "function" == typeof p ? function(t2) {
    return p.apply(e, t2);
  } : p;
}

// node_modules/@antv/g-math/dist/index.esm.js
function distance4(x1, y1, x22, y22) {
  var dx = x1 - x22;
  var dy = y1 - y22;
  return Math.sqrt(dx * dx + dy * dy);
}
function getBBoxByArray(xArr, yArr) {
  var minX = Math.min.apply(Math, _toConsumableArray(xArr));
  var minY = Math.min.apply(Math, _toConsumableArray(yArr));
  var maxX = Math.max.apply(Math, _toConsumableArray(xArr));
  var maxY = Math.max.apply(Math, _toConsumableArray(yArr));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function xExtrema(rx, ry, xRotation) {
  return Math.atan(-ry / rx * Math.tan(xRotation));
}
function yExtrema(rx, ry, xRotation) {
  return Math.atan(ry / (rx * Math.tan(xRotation)));
}
function xAt(cx, cy, rx, ry, xRotation, angle3) {
  return rx * Math.cos(xRotation) * Math.cos(angle3) - ry * Math.sin(xRotation) * Math.sin(angle3) + cx;
}
function yAt(cx, cy, rx, ry, xRotation, angle3) {
  return rx * Math.sin(xRotation) * Math.cos(angle3) + ry * Math.cos(xRotation) * Math.sin(angle3) + cy;
}
function box$5(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
  var xDim = xExtrema(rx, ry, xRotation);
  var minX = Infinity;
  var maxX = -Infinity;
  var xs = [startAngle, endAngle];
  for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
    var xAngle = xDim + i;
    if (startAngle < endAngle) {
      if (startAngle < xAngle && xAngle < endAngle) {
        xs.push(xAngle);
      }
    } else if (endAngle < xAngle && xAngle < startAngle) {
      xs.push(xAngle);
    }
  }
  for (var _i = 0; _i < xs.length; _i++) {
    var x3 = xAt(cx, cy, rx, ry, xRotation, xs[_i]);
    if (x3 < minX) {
      minX = x3;
    }
    if (x3 > maxX) {
      maxX = x3;
    }
  }
  var yDim = yExtrema(rx, ry, xRotation);
  var minY = Infinity;
  var maxY = -Infinity;
  var ys = [startAngle, endAngle];
  for (var _i2 = -Math.PI * 2; _i2 <= Math.PI * 2; _i2 += Math.PI) {
    var yAngle = yDim + _i2;
    if (startAngle < endAngle) {
      if (startAngle < yAngle && yAngle < endAngle) {
        ys.push(yAngle);
      }
    } else if (endAngle < yAngle && yAngle < startAngle) {
      ys.push(yAngle);
    }
  }
  for (var _i3 = 0; _i3 < ys.length; _i3++) {
    var y3 = yAt(cx, cy, rx, ry, xRotation, ys[_i3]);
    if (y3 < minY) {
      minY = y3;
    }
    if (y3 > maxY) {
      maxY = y3;
    }
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
var EPSILON2 = 1e-4;
function nearestPoint$2(xArr, yArr, x3, y3, tCallback, length5) {
  var t = -1;
  var d2 = Infinity;
  var v0 = [x3, y3];
  var segNum = 20;
  if (length5 && length5 > 200) {
    segNum = length5 / 10;
  }
  var increaseRate = 1 / segNum;
  var interval = increaseRate / 10;
  for (var i = 0; i <= segNum; i++) {
    var _t = i * increaseRate;
    var v1 = [tCallback.apply(void 0, _toConsumableArray(xArr.concat([_t]))), tCallback.apply(void 0, _toConsumableArray(yArr.concat([_t])))];
    var d1 = distance4(v0[0], v0[1], v1[0], v1[1]);
    if (d1 < d2) {
      t = _t;
      d2 = d1;
    }
  }
  if (t === 0) {
    return {
      x: xArr[0],
      y: yArr[0]
    };
  }
  if (t === 1) {
    var count = xArr.length;
    return {
      x: xArr[count - 1],
      y: yArr[count - 1]
    };
  }
  d2 = Infinity;
  for (var _i = 0; _i < 32; _i++) {
    if (interval < EPSILON2) {
      break;
    }
    var prev = t - interval;
    var next = t + interval;
    var _v = [tCallback.apply(void 0, _toConsumableArray(xArr.concat([prev]))), tCallback.apply(void 0, _toConsumableArray(yArr.concat([prev])))];
    var _d = distance4(v0[0], v0[1], _v[0], _v[1]);
    if (prev >= 0 && _d < d2) {
      t = prev;
      d2 = _d;
    } else {
      var v2 = [tCallback.apply(void 0, _toConsumableArray(xArr.concat([next]))), tCallback.apply(void 0, _toConsumableArray(yArr.concat([next])))];
      var d22 = distance4(v0[0], v0[1], v2[0], v2[1]);
      if (next <= 1 && d22 < d2) {
        t = next;
        d2 = d22;
      } else {
        interval *= 0.5;
      }
    }
  }
  return {
    x: tCallback.apply(void 0, _toConsumableArray(xArr.concat([t]))),
    y: tCallback.apply(void 0, _toConsumableArray(yArr.concat([t])))
  };
}
function length$4(x1, y1, x22, y22) {
  return distance4(x1, y1, x22, y22);
}
function pointAt$3(x1, y1, x22, y22, t) {
  return {
    x: (1 - t) * x1 + t * x22,
    y: (1 - t) * y1 + t * y22
  };
}
function pointToLine(x1, y1, x22, y22, x3, y3) {
  var d2 = [x22 - x1, y22 - y1];
  if (vec2_exports.exactEquals(d2, [0, 0])) {
    return Math.sqrt((x3 - x1) * (x3 - x1) + (y3 - y1) * (y3 - y1));
  }
  var u = [-d2[1], d2[0]];
  vec2_exports.normalize(u, u);
  var a2 = [x3 - x1, y3 - y1];
  return Math.abs(vec2_exports.dot(a2, u));
}
function cubicAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;
}
function extrema$1(p0, p1, p2, p3) {
  var a2 = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
  var b = 6 * p0 - 12 * p1 + 6 * p2;
  var c2 = 3 * p1 - 3 * p0;
  var extremas = [];
  var t1;
  var t2;
  var discSqrt;
  if (isNumberEqual(a2, 0)) {
    if (!isNumberEqual(b, 0)) {
      t1 = -c2 / b;
      if (t1 >= 0 && t1 <= 1) {
        extremas.push(t1);
      }
    }
  } else {
    var disc = b * b - 4 * a2 * c2;
    if (isNumberEqual(disc, 0)) {
      extremas.push(-b / (2 * a2));
    } else if (disc > 0) {
      discSqrt = Math.sqrt(disc);
      t1 = (-b + discSqrt) / (2 * a2);
      t2 = (-b - discSqrt) / (2 * a2);
      if (t1 >= 0 && t1 <= 1) {
        extremas.push(t1);
      }
      if (t2 >= 0 && t2 <= 1) {
        extremas.push(t2);
      }
    }
  }
  return extremas;
}
function box$3(x1, y1, x22, y22, x3, y3, x4, y4) {
  var xArr = [x1, x4];
  var yArr = [y1, y4];
  var xExtrema2 = extrema$1(x1, x22, x3, x4);
  var yExtrema2 = extrema$1(y1, y22, y3, y4);
  for (var i = 0; i < xExtrema2.length; i++) {
    xArr.push(cubicAt(x1, x22, x3, x4, xExtrema2[i]));
  }
  for (var _i = 0; _i < yExtrema2.length; _i++) {
    yArr.push(cubicAt(y1, y22, y3, y4, yExtrema2[_i]));
  }
  return getBBoxByArray(xArr, yArr);
}
function nearestPoint$1(x1, y1, x22, y22, x3, y3, x4, y4, x0, y0, length5) {
  return nearestPoint$2([x1, x22, x3, x4], [y1, y22, y3, y4], x0, y0, cubicAt, length5);
}
function pointDistance$3(x1, y1, x22, y22, x3, y3, x4, y4, x0, y0, length5) {
  var point2 = nearestPoint$1(x1, y1, x22, y22, x3, y3, x4, y4, x0, y0, length5);
  return distance4(point2.x, point2.y, x0, y0);
}
function lengthOfSegment(points) {
  if (points.length < 2) {
    return 0;
  }
  var totalLength = 0;
  for (var i = 0; i < points.length - 1; i++) {
    var from = points[i];
    var to = points[i + 1];
    totalLength += distance4(from[0], from[1], to[0], to[1]);
  }
  return totalLength;
}
function length$2(points) {
  return lengthOfSegment(points);
}
function quadraticAt(p0, p1, p2, t) {
  var onet = 1 - t;
  return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
}
function extrema(p0, p1, p2) {
  var a2 = p0 + p2 - 2 * p1;
  if (isNumberEqual(a2, 0)) {
    return [0.5];
  }
  var rst = (p0 - p1) / a2;
  if (rst <= 1 && rst >= 0) {
    return [rst];
  }
  return [];
}
function box(x1, y1, x22, y22, x3, y3) {
  var xExtrema2 = extrema(x1, x22, x3)[0];
  var yExtrema2 = extrema(y1, y22, y3)[0];
  var xArr = [x1, x3];
  var yArr = [y1, y3];
  if (xExtrema2 !== void 0) {
    xArr.push(quadraticAt(x1, x22, x3, xExtrema2));
  }
  if (yExtrema2 !== void 0) {
    yArr.push(quadraticAt(y1, y22, y3, yExtrema2));
  }
  return getBBoxByArray(xArr, yArr);
}
function nearestPoint(x1, y1, x22, y22, x3, y3, x0, y0) {
  return nearestPoint$2([x1, x22, x3], [y1, y22, y3], x0, y0, quadraticAt);
}
function pointDistance(x1, y1, x22, y22, x3, y3, x0, y0) {
  var point2 = nearestPoint(x1, y1, x22, y22, x3, y3, x0, y0);
  return distance4(point2.x, point2.y, x0, y0);
}

// node_modules/@antv/g-lite/dist/index.esm.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var rbush = { exports: {} };
(function(module, exports) {
  (function(global2, factory) {
    module.exports = factory();
  })(commonjsGlobal, function() {
    function quickselect(arr, k, left, right, compare) {
      quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
    }
    function quickselectStep(arr, k, left, right, compare) {
      while (right > left) {
        if (right - left > 600) {
          var n = right - left + 1;
          var m2 = k - left + 1;
          var z = Math.log(n);
          var s2 = 0.5 * Math.exp(2 * z / 3);
          var sd = 0.5 * Math.sqrt(z * s2 * (n - s2) / n) * (m2 - n / 2 < 0 ? -1 : 1);
          var newLeft = Math.max(left, Math.floor(k - m2 * s2 / n + sd));
          var newRight = Math.min(right, Math.floor(k + (n - m2) * s2 / n + sd));
          quickselectStep(arr, k, newLeft, newRight, compare);
        }
        var t = arr[k];
        var i = left;
        var j = right;
        swap(arr, left, k);
        if (compare(arr[right], t) > 0) {
          swap(arr, left, right);
        }
        while (i < j) {
          swap(arr, i, j);
          i++;
          j--;
          while (compare(arr[i], t) < 0) {
            i++;
          }
          while (compare(arr[j], t) > 0) {
            j--;
          }
        }
        if (compare(arr[left], t) === 0) {
          swap(arr, left, j);
        } else {
          j++;
          swap(arr, j, right);
        }
        if (j <= k) {
          left = j + 1;
        }
        if (k <= j) {
          right = j - 1;
        }
      }
    }
    function swap(arr, i, j) {
      var tmp2 = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp2;
    }
    function defaultCompare(a2, b) {
      return a2 < b ? -1 : a2 > b ? 1 : 0;
    }
    var RBush2 = function RBush3(maxEntries) {
      if (maxEntries === void 0) maxEntries = 9;
      this._maxEntries = Math.max(4, maxEntries);
      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
      this.clear();
    };
    RBush2.prototype.all = function all() {
      return this._all(this.data, []);
    };
    RBush2.prototype.search = function search2(bbox) {
      var node = this.data;
      var result = [];
      if (!intersects(bbox, node)) {
        return result;
      }
      var toBBox = this.toBBox;
      var nodesToSearch = [];
      while (node) {
        for (var i = 0; i < node.children.length; i++) {
          var child = node.children[i];
          var childBBox = node.leaf ? toBBox(child) : child;
          if (intersects(bbox, childBBox)) {
            if (node.leaf) {
              result.push(child);
            } else if (contains2(bbox, childBBox)) {
              this._all(child, result);
            } else {
              nodesToSearch.push(child);
            }
          }
        }
        node = nodesToSearch.pop();
      }
      return result;
    };
    RBush2.prototype.collides = function collides(bbox) {
      var node = this.data;
      if (!intersects(bbox, node)) {
        return false;
      }
      var nodesToSearch = [];
      while (node) {
        for (var i = 0; i < node.children.length; i++) {
          var child = node.children[i];
          var childBBox = node.leaf ? this.toBBox(child) : child;
          if (intersects(bbox, childBBox)) {
            if (node.leaf || contains2(bbox, childBBox)) {
              return true;
            }
            nodesToSearch.push(child);
          }
        }
        node = nodesToSearch.pop();
      }
      return false;
    };
    RBush2.prototype.load = function load(data2) {
      if (!(data2 && data2.length)) {
        return this;
      }
      if (data2.length < this._minEntries) {
        for (var i = 0; i < data2.length; i++) {
          this.insert(data2[i]);
        }
        return this;
      }
      var node = this._build(data2.slice(), 0, data2.length - 1, 0);
      if (!this.data.children.length) {
        this.data = node;
      } else if (this.data.height === node.height) {
        this._splitRoot(this.data, node);
      } else {
        if (this.data.height < node.height) {
          var tmpNode = this.data;
          this.data = node;
          node = tmpNode;
        }
        this._insert(node, this.data.height - node.height - 1, true);
      }
      return this;
    };
    RBush2.prototype.insert = function insert(item) {
      if (item) {
        this._insert(item, this.data.height - 1);
      }
      return this;
    };
    RBush2.prototype.clear = function clear() {
      this.data = createNode([]);
      return this;
    };
    RBush2.prototype.remove = function remove(item, equalsFn) {
      if (!item) {
        return this;
      }
      var node = this.data;
      var bbox = this.toBBox(item);
      var path = [];
      var indexes = [];
      var i, parent, goingUp;
      while (node || path.length) {
        if (!node) {
          node = path.pop();
          parent = path[path.length - 1];
          i = indexes.pop();
          goingUp = true;
        }
        if (node.leaf) {
          var index2 = findItem(item, node.children, equalsFn);
          if (index2 !== -1) {
            node.children.splice(index2, 1);
            path.push(node);
            this._condense(path);
            return this;
          }
        }
        if (!goingUp && !node.leaf && contains2(node, bbox)) {
          path.push(node);
          indexes.push(i);
          i = 0;
          parent = node;
          node = node.children[0];
        } else if (parent) {
          i++;
          node = parent.children[i];
          goingUp = false;
        } else {
          node = null;
        }
      }
      return this;
    };
    RBush2.prototype.toBBox = function toBBox(item) {
      return item;
    };
    RBush2.prototype.compareMinX = function compareMinX(a2, b) {
      return a2.minX - b.minX;
    };
    RBush2.prototype.compareMinY = function compareMinY(a2, b) {
      return a2.minY - b.minY;
    };
    RBush2.prototype.toJSON = function toJSON() {
      return this.data;
    };
    RBush2.prototype.fromJSON = function fromJSON(data2) {
      this.data = data2;
      return this;
    };
    RBush2.prototype._all = function _all(node, result) {
      var nodesToSearch = [];
      while (node) {
        if (node.leaf) {
          result.push.apply(result, node.children);
        } else {
          nodesToSearch.push.apply(nodesToSearch, node.children);
        }
        node = nodesToSearch.pop();
      }
      return result;
    };
    RBush2.prototype._build = function _build(items, left, right, height) {
      var N = right - left + 1;
      var M = this._maxEntries;
      var node;
      if (N <= M) {
        node = createNode(items.slice(left, right + 1));
        calcBBox(node, this.toBBox);
        return node;
      }
      if (!height) {
        height = Math.ceil(Math.log(N) / Math.log(M));
        M = Math.ceil(N / Math.pow(M, height - 1));
      }
      node = createNode([]);
      node.leaf = false;
      node.height = height;
      var N2 = Math.ceil(N / M);
      var N1 = N2 * Math.ceil(Math.sqrt(M));
      multiSelect(items, left, right, N1, this.compareMinX);
      for (var i = left; i <= right; i += N1) {
        var right2 = Math.min(i + N1 - 1, right);
        multiSelect(items, i, right2, N2, this.compareMinY);
        for (var j = i; j <= right2; j += N2) {
          var right3 = Math.min(j + N2 - 1, right2);
          node.children.push(this._build(items, j, right3, height - 1));
        }
      }
      calcBBox(node, this.toBBox);
      return node;
    };
    RBush2.prototype._chooseSubtree = function _chooseSubtree(bbox, node, level, path) {
      while (true) {
        path.push(node);
        if (node.leaf || path.length - 1 === level) {
          break;
        }
        var minArea = Infinity;
        var minEnlargement = Infinity;
        var targetNode = void 0;
        for (var i = 0; i < node.children.length; i++) {
          var child = node.children[i];
          var area = bboxArea(child);
          var enlargement = enlargedArea(bbox, child) - area;
          if (enlargement < minEnlargement) {
            minEnlargement = enlargement;
            minArea = area < minArea ? area : minArea;
            targetNode = child;
          } else if (enlargement === minEnlargement) {
            if (area < minArea) {
              minArea = area;
              targetNode = child;
            }
          }
        }
        node = targetNode || node.children[0];
      }
      return node;
    };
    RBush2.prototype._insert = function _insert(item, level, isNode) {
      var bbox = isNode ? item : this.toBBox(item);
      var insertPath = [];
      var node = this._chooseSubtree(bbox, this.data, level, insertPath);
      node.children.push(item);
      extend2(node, bbox);
      while (level >= 0) {
        if (insertPath[level].children.length > this._maxEntries) {
          this._split(insertPath, level);
          level--;
        } else {
          break;
        }
      }
      this._adjustParentBBoxes(bbox, insertPath, level);
    };
    RBush2.prototype._split = function _split(insertPath, level) {
      var node = insertPath[level];
      var M = node.children.length;
      var m2 = this._minEntries;
      this._chooseSplitAxis(node, m2, M);
      var splitIndex = this._chooseSplitIndex(node, m2, M);
      var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
      newNode.height = node.height;
      newNode.leaf = node.leaf;
      calcBBox(node, this.toBBox);
      calcBBox(newNode, this.toBBox);
      if (level) {
        insertPath[level - 1].children.push(newNode);
      } else {
        this._splitRoot(node, newNode);
      }
    };
    RBush2.prototype._splitRoot = function _splitRoot(node, newNode) {
      this.data = createNode([node, newNode]);
      this.data.height = node.height + 1;
      this.data.leaf = false;
      calcBBox(this.data, this.toBBox);
    };
    RBush2.prototype._chooseSplitIndex = function _chooseSplitIndex(node, m2, M) {
      var index2;
      var minOverlap = Infinity;
      var minArea = Infinity;
      for (var i = m2; i <= M - m2; i++) {
        var bbox1 = distBBox(node, 0, i, this.toBBox);
        var bbox2 = distBBox(node, i, M, this.toBBox);
        var overlap = intersectionArea(bbox1, bbox2);
        var area = bboxArea(bbox1) + bboxArea(bbox2);
        if (overlap < minOverlap) {
          minOverlap = overlap;
          index2 = i;
          minArea = area < minArea ? area : minArea;
        } else if (overlap === minOverlap) {
          if (area < minArea) {
            minArea = area;
            index2 = i;
          }
        }
      }
      return index2 || M - m2;
    };
    RBush2.prototype._chooseSplitAxis = function _chooseSplitAxis(node, m2, M) {
      var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
      var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
      var xMargin = this._allDistMargin(node, m2, M, compareMinX);
      var yMargin = this._allDistMargin(node, m2, M, compareMinY);
      if (xMargin < yMargin) {
        node.children.sort(compareMinX);
      }
    };
    RBush2.prototype._allDistMargin = function _allDistMargin(node, m2, M, compare) {
      node.children.sort(compare);
      var toBBox = this.toBBox;
      var leftBBox = distBBox(node, 0, m2, toBBox);
      var rightBBox = distBBox(node, M - m2, M, toBBox);
      var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
      for (var i = m2; i < M - m2; i++) {
        var child = node.children[i];
        extend2(leftBBox, node.leaf ? toBBox(child) : child);
        margin += bboxMargin(leftBBox);
      }
      for (var i$1 = M - m2 - 1; i$1 >= m2; i$1--) {
        var child$1 = node.children[i$1];
        extend2(rightBBox, node.leaf ? toBBox(child$1) : child$1);
        margin += bboxMargin(rightBBox);
      }
      return margin;
    };
    RBush2.prototype._adjustParentBBoxes = function _adjustParentBBoxes(bbox, path, level) {
      for (var i = level; i >= 0; i--) {
        extend2(path[i], bbox);
      }
    };
    RBush2.prototype._condense = function _condense(path) {
      for (var i = path.length - 1, siblings = void 0; i >= 0; i--) {
        if (path[i].children.length === 0) {
          if (i > 0) {
            siblings = path[i - 1].children;
            siblings.splice(siblings.indexOf(path[i]), 1);
          } else {
            this.clear();
          }
        } else {
          calcBBox(path[i], this.toBBox);
        }
      }
    };
    function findItem(item, items, equalsFn) {
      if (!equalsFn) {
        return items.indexOf(item);
      }
      for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) {
          return i;
        }
      }
      return -1;
    }
    function calcBBox(node, toBBox) {
      distBBox(node, 0, node.children.length, toBBox, node);
    }
    function distBBox(node, k, p, toBBox, destNode) {
      if (!destNode) {
        destNode = createNode(null);
      }
      destNode.minX = Infinity;
      destNode.minY = Infinity;
      destNode.maxX = -Infinity;
      destNode.maxY = -Infinity;
      for (var i = k; i < p; i++) {
        var child = node.children[i];
        extend2(destNode, node.leaf ? toBBox(child) : child);
      }
      return destNode;
    }
    function extend2(a2, b) {
      a2.minX = Math.min(a2.minX, b.minX);
      a2.minY = Math.min(a2.minY, b.minY);
      a2.maxX = Math.max(a2.maxX, b.maxX);
      a2.maxY = Math.max(a2.maxY, b.maxY);
      return a2;
    }
    function compareNodeMinX(a2, b) {
      return a2.minX - b.minX;
    }
    function compareNodeMinY(a2, b) {
      return a2.minY - b.minY;
    }
    function bboxArea(a2) {
      return (a2.maxX - a2.minX) * (a2.maxY - a2.minY);
    }
    function bboxMargin(a2) {
      return a2.maxX - a2.minX + (a2.maxY - a2.minY);
    }
    function enlargedArea(a2, b) {
      return (Math.max(b.maxX, a2.maxX) - Math.min(b.minX, a2.minX)) * (Math.max(b.maxY, a2.maxY) - Math.min(b.minY, a2.minY));
    }
    function intersectionArea(a2, b) {
      var minX = Math.max(a2.minX, b.minX);
      var minY = Math.max(a2.minY, b.minY);
      var maxX = Math.min(a2.maxX, b.maxX);
      var maxY = Math.min(a2.maxY, b.maxY);
      return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
    }
    function contains2(a2, b) {
      return a2.minX <= b.minX && a2.minY <= b.minY && b.maxX <= a2.maxX && b.maxY <= a2.maxY;
    }
    function intersects(a2, b) {
      return b.minX <= a2.maxX && b.minY <= a2.maxY && b.maxX >= a2.minX && b.maxY >= a2.minY;
    }
    function createNode(children) {
      return {
        children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
      };
    }
    function multiSelect(arr, left, right, n, compare) {
      var stack = [left, right];
      while (stack.length) {
        right = stack.pop();
        left = stack.pop();
        if (right - left <= n) {
          continue;
        }
        var mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);
        stack.push(left, mid, mid, right);
      }
    }
    return RBush2;
  });
})(rbush);
var RBush = rbush.exports;
var Shape = function(Shape2) {
  Shape2["GROUP"] = "g";
  Shape2["FRAGMENT"] = "fragment";
  Shape2["CIRCLE"] = "circle";
  Shape2["ELLIPSE"] = "ellipse";
  Shape2["IMAGE"] = "image";
  Shape2["RECT"] = "rect";
  Shape2["LINE"] = "line";
  Shape2["POLYLINE"] = "polyline";
  Shape2["POLYGON"] = "polygon";
  Shape2["TEXT"] = "text";
  Shape2["PATH"] = "path";
  Shape2["HTML"] = "html";
  Shape2["MESH"] = "mesh";
  return Shape2;
}({});
var ClipSpaceNearZ = function(ClipSpaceNearZ2) {
  ClipSpaceNearZ2[ClipSpaceNearZ2["ZERO"] = 0] = "ZERO";
  ClipSpaceNearZ2[ClipSpaceNearZ2["NEGATIVE_ONE"] = 1] = "NEGATIVE_ONE";
  return ClipSpaceNearZ2;
}({});
var AbstractRendererPlugin = function() {
  function AbstractRendererPlugin2() {
    _classCallCheck(this, AbstractRendererPlugin2);
    this.plugins = [];
  }
  return _createClass(AbstractRendererPlugin2, [{
    key: "addRenderingPlugin",
    value: function addRenderingPlugin(plugin) {
      this.plugins.push(plugin);
      this.context.renderingPlugins.push(plugin);
    }
  }, {
    key: "removeAllRenderingPlugins",
    value: function removeAllRenderingPlugins() {
      var _this2 = this;
      this.plugins.forEach(function(plugin) {
        var index2 = _this2.context.renderingPlugins.indexOf(plugin);
        if (index2 >= 0) {
          _this2.context.renderingPlugins.splice(index2, 1);
        }
      });
    }
  }]);
}();
var AbstractRenderer = function() {
  function AbstractRenderer2(config) {
    _classCallCheck(this, AbstractRenderer2);
    this.clipSpaceNearZ = ClipSpaceNearZ.NEGATIVE_ONE;
    this.plugins = [];
    this.config = _objectSpread2({
      /**
       * only dirty object will cause re-render
       */
      enableDirtyCheck: true,
      enableCulling: false,
      /**
       * enable auto rendering by default
       */
      enableAutoRendering: true,
      /**
       * enable dirty rectangle rendering by default
       */
      enableDirtyRectangleRendering: true,
      enableDirtyRectangleRenderingDebug: false,
      enableSizeAttenuation: true,
      enableRenderingOptimization: false
    }, config);
  }
  return _createClass(AbstractRenderer2, [{
    key: "registerPlugin",
    value: function registerPlugin(plugin) {
      var index2 = this.plugins.findIndex(function(p) {
        return p === plugin;
      });
      if (index2 === -1) {
        this.plugins.push(plugin);
      }
    }
  }, {
    key: "unregisterPlugin",
    value: function unregisterPlugin(plugin) {
      var index2 = this.plugins.findIndex(function(p) {
        return p === plugin;
      });
      if (index2 > -1) {
        this.plugins.splice(index2, 1);
      }
    }
  }, {
    key: "getPlugins",
    value: function getPlugins() {
      return this.plugins;
    }
  }, {
    key: "getPlugin",
    value: function getPlugin(name) {
      return this.plugins.find(function(plugin) {
        return plugin.name === name;
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      return this.config;
    }
  }, {
    key: "setConfig",
    value: function setConfig(config) {
      Object.assign(this.config, config);
    }
  }]);
}();
var addVec3 = vec3_exports.add;
var copyVec3 = vec3_exports.copy;
var maxVec3 = vec3_exports.max;
var minVec3 = vec3_exports.min;
var scaleVec3 = vec3_exports.scale;
var subVec3 = vec3_exports.sub;
var AABB = function() {
  function AABB2() {
    _classCallCheck(this, AABB2);
    this.center = [0, 0, 0];
    this.halfExtents = [0, 0, 0];
    this.min = [0, 0, 0];
    this.max = [0, 0, 0];
  }
  return _createClass(AABB2, [{
    key: "update",
    value: function update2(center, halfExtents) {
      copyVec3(this.center, center);
      copyVec3(this.halfExtents, halfExtents);
      subVec3(this.min, this.center, this.halfExtents);
      addVec3(this.max, this.center, this.halfExtents);
    }
  }, {
    key: "setMinMax",
    value: function setMinMax(min5, max6) {
      addVec3(this.center, max6, min5);
      scaleVec3(this.center, this.center, 0.5);
      subVec3(this.halfExtents, max6, min5);
      scaleVec3(this.halfExtents, this.halfExtents, 0.5);
      copyVec3(this.min, min5);
      copyVec3(this.max, max6);
    }
  }, {
    key: "getMin",
    value: function getMin() {
      return this.min;
    }
  }, {
    key: "getMax",
    value: function getMax() {
      return this.max;
    }
  }, {
    key: "add",
    value: function add9(aabb) {
      if (AABB2.isEmpty(aabb)) {
        return;
      }
      if (AABB2.isEmpty(this)) {
        this.setMinMax(aabb.getMin(), aabb.getMax());
        return;
      }
      var tc = this.center;
      var tcx = tc[0];
      var tcy = tc[1];
      var tcz = tc[2];
      var th = this.halfExtents;
      var thx = th[0];
      var thy = th[1];
      var thz = th[2];
      var tminx = tcx - thx;
      var tmaxx = tcx + thx;
      var tminy = tcy - thy;
      var tmaxy = tcy + thy;
      var tminz = tcz - thz;
      var tmaxz = tcz + thz;
      var oc = aabb.center;
      var ocx = oc[0];
      var ocy = oc[1];
      var ocz = oc[2];
      var oh = aabb.halfExtents;
      var ohx = oh[0];
      var ohy = oh[1];
      var ohz = oh[2];
      var ominx = ocx - ohx;
      var omaxx = ocx + ohx;
      var ominy = ocy - ohy;
      var omaxy = ocy + ohy;
      var ominz = ocz - ohz;
      var omaxz = ocz + ohz;
      if (ominx < tminx) {
        tminx = ominx;
      }
      if (omaxx > tmaxx) {
        tmaxx = omaxx;
      }
      if (ominy < tminy) {
        tminy = ominy;
      }
      if (omaxy > tmaxy) {
        tmaxy = omaxy;
      }
      if (ominz < tminz) {
        tminz = ominz;
      }
      if (omaxz > tmaxz) {
        tmaxz = omaxz;
      }
      tc[0] = (tminx + tmaxx) * 0.5;
      tc[1] = (tminy + tmaxy) * 0.5;
      tc[2] = (tminz + tmaxz) * 0.5;
      th[0] = (tmaxx - tminx) * 0.5;
      th[1] = (tmaxy - tminy) * 0.5;
      th[2] = (tmaxz - tminz) * 0.5;
      this.min[0] = tminx;
      this.min[1] = tminy;
      this.min[2] = tminz;
      this.max[0] = tmaxx;
      this.max[1] = tmaxy;
      this.max[2] = tmaxz;
    }
  }, {
    key: "setFromTransformedAABB",
    value: function setFromTransformedAABB(aabb, m2) {
      var bc = this.center;
      var br = this.halfExtents;
      var ac = aabb.center;
      var ar = aabb.halfExtents;
      var mx0 = m2[0];
      var mx1 = m2[4];
      var mx2 = m2[8];
      var my0 = m2[1];
      var my1 = m2[5];
      var my2 = m2[9];
      var mz0 = m2[2];
      var mz1 = m2[6];
      var mz2 = m2[10];
      var mx0a = Math.abs(mx0);
      var mx1a = Math.abs(mx1);
      var mx2a = Math.abs(mx2);
      var my0a = Math.abs(my0);
      var my1a = Math.abs(my1);
      var my2a = Math.abs(my2);
      var mz0a = Math.abs(mz0);
      var mz1a = Math.abs(mz1);
      var mz2a = Math.abs(mz2);
      bc[0] = m2[12] + mx0 * ac[0] + mx1 * ac[1] + mx2 * ac[2];
      bc[1] = m2[13] + my0 * ac[0] + my1 * ac[1] + my2 * ac[2];
      bc[2] = m2[14] + mz0 * ac[0] + mz1 * ac[1] + mz2 * ac[2];
      br[0] = mx0a * ar[0] + mx1a * ar[1] + mx2a * ar[2];
      br[1] = my0a * ar[0] + my1a * ar[1] + my2a * ar[2];
      br[2] = mz0a * ar[0] + mz1a * ar[1] + mz2a * ar[2];
      subVec3(this.min, bc, br);
      addVec3(this.max, bc, br);
    }
  }, {
    key: "intersects",
    value: function intersects(aabb) {
      var aMax = this.getMax();
      var aMin = this.getMin();
      var bMax = aabb.getMax();
      var bMin = aabb.getMin();
      return aMin[0] <= bMax[0] && aMax[0] >= bMin[0] && aMin[1] <= bMax[1] && aMax[1] >= bMin[1] && aMin[2] <= bMax[2] && aMax[2] >= bMin[2];
    }
  }, {
    key: "intersection",
    value: function intersection2(aabb) {
      if (!this.intersects(aabb)) {
        return null;
      }
      var intersection3 = new AABB2();
      var min5 = maxVec3([0, 0, 0], this.getMin(), aabb.getMin());
      var max6 = minVec3([0, 0, 0], this.getMax(), aabb.getMax());
      intersection3.setMinMax(min5, max6);
      return intersection3;
    }
    /**
     * get n-vertex
     * @param plane plane of CullingVolume
     */
  }, {
    key: "getNegativeFarPoint",
    value: function getNegativeFarPoint(plane) {
      if (plane.pnVertexFlag === 273) {
        return copyVec3([0, 0, 0], this.min);
      }
      if (plane.pnVertexFlag === 272) {
        return [this.min[0], this.min[1], this.max[2]];
      }
      if (plane.pnVertexFlag === 257) {
        return [this.min[0], this.max[1], this.min[2]];
      }
      if (plane.pnVertexFlag === 256) {
        return [this.min[0], this.max[1], this.max[2]];
      }
      if (plane.pnVertexFlag === 17) {
        return [this.max[0], this.min[1], this.min[2]];
      }
      if (plane.pnVertexFlag === 16) {
        return [this.max[0], this.min[1], this.max[2]];
      }
      if (plane.pnVertexFlag === 1) {
        return [this.max[0], this.max[1], this.min[2]];
      }
      return [this.max[0], this.max[1], this.max[2]];
    }
    /**
     * get p-vertex
     * @param plane plane of CullingVolume
     */
  }, {
    key: "getPositiveFarPoint",
    value: function getPositiveFarPoint(plane) {
      if (plane.pnVertexFlag === 273) {
        return copyVec3([0, 0, 0], this.max);
      }
      if (plane.pnVertexFlag === 272) {
        return [this.max[0], this.max[1], this.min[2]];
      }
      if (plane.pnVertexFlag === 257) {
        return [this.max[0], this.min[1], this.max[2]];
      }
      if (plane.pnVertexFlag === 256) {
        return [this.max[0], this.min[1], this.min[2]];
      }
      if (plane.pnVertexFlag === 17) {
        return [this.min[0], this.max[1], this.max[2]];
      }
      if (plane.pnVertexFlag === 16) {
        return [this.min[0], this.max[1], this.min[2]];
      }
      if (plane.pnVertexFlag === 1) {
        return [this.min[0], this.min[1], this.max[2]];
      }
      return [this.min[0], this.min[1], this.min[2]];
    }
  }], [{
    key: "isEmpty",
    value: function isEmpty2(aabb) {
      return !aabb || aabb.halfExtents[0] === 0 && aabb.halfExtents[1] === 0 && aabb.halfExtents[2] === 0;
    }
  }]);
}();
var Plane = function() {
  function Plane2(distance6, normal) {
    _classCallCheck(this, Plane2);
    this.distance = distance6 || 0;
    this.normal = normal || vec3_exports.fromValues(0, 1, 0);
    this.updatePNVertexFlag();
  }
  return _createClass(Plane2, [{
    key: "updatePNVertexFlag",
    value: function updatePNVertexFlag() {
      this.pnVertexFlag = (Number(this.normal[0] >= 0) << 8) + (Number(this.normal[1] >= 0) << 4) + Number(this.normal[2] >= 0);
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(point2) {
      return vec3_exports.dot(point2, this.normal) - this.distance;
    }
  }, {
    key: "normalize",
    value: function normalize8() {
      var invLen = 1 / vec3_exports.len(this.normal);
      vec3_exports.scale(this.normal, this.normal, invLen);
      this.distance *= invLen;
    }
  }, {
    key: "intersectsLine",
    value: function intersectsLine(start, end, point2) {
      var d0 = this.distanceToPoint(start);
      var d1 = this.distanceToPoint(end);
      var t = d0 / (d0 - d1);
      var intersects = t >= 0 && t <= 1;
      if (intersects && point2) {
        vec3_exports.lerp(point2, start, end, t);
      }
      return intersects;
    }
  }]);
}();
var Mask = function(Mask2) {
  Mask2[Mask2["OUTSIDE"] = 4294967295] = "OUTSIDE";
  Mask2[Mask2["INSIDE"] = 0] = "INSIDE";
  Mask2[Mask2["INDETERMINATE"] = 2147483647] = "INDETERMINATE";
  return Mask2;
}({});
var Frustum = function() {
  function Frustum2(planes) {
    _classCallCheck(this, Frustum2);
    this.planes = [];
    if (planes) {
      this.planes = planes;
    } else {
      for (var i = 0; i < 6; i++) {
        this.planes.push(new Plane());
      }
    }
  }
  return _createClass(Frustum2, [{
    key: "extractFromVPMatrix",
    value: function extractFromVPMatrix(projectionMatrix) {
      var _projectionMatrix = _slicedToArray(projectionMatrix, 16), m0 = _projectionMatrix[0], m1 = _projectionMatrix[1], m2 = _projectionMatrix[2], m3 = _projectionMatrix[3], m4 = _projectionMatrix[4], m5 = _projectionMatrix[5], m6 = _projectionMatrix[6], m7 = _projectionMatrix[7], m8 = _projectionMatrix[8], m9 = _projectionMatrix[9], m10 = _projectionMatrix[10], m11 = _projectionMatrix[11], m12 = _projectionMatrix[12], m13 = _projectionMatrix[13], m14 = _projectionMatrix[14], m15 = _projectionMatrix[15];
      vec3_exports.set(this.planes[0].normal, m3 - m0, m7 - m4, m11 - m8);
      this.planes[0].distance = m15 - m12;
      vec3_exports.set(this.planes[1].normal, m3 + m0, m7 + m4, m11 + m8);
      this.planes[1].distance = m15 + m12;
      vec3_exports.set(this.planes[2].normal, m3 + m1, m7 + m5, m11 + m9);
      this.planes[2].distance = m15 + m13;
      vec3_exports.set(this.planes[3].normal, m3 - m1, m7 - m5, m11 - m9);
      this.planes[3].distance = m15 - m13;
      vec3_exports.set(this.planes[4].normal, m3 - m2, m7 - m6, m11 - m10);
      this.planes[4].distance = m15 - m14;
      vec3_exports.set(this.planes[5].normal, m3 + m2, m7 + m6, m11 + m10);
      this.planes[5].distance = m15 + m14;
      this.planes.forEach(function(plane) {
        plane.normalize();
        plane.updatePNVertexFlag();
      });
    }
  }]);
}();
var Point = function() {
  function Point3() {
    var x3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    _classCallCheck(this, Point3);
    this.x = 0;
    this.y = 0;
    this.x = x3;
    this.y = y3;
  }
  return _createClass(Point3, [{
    key: "clone",
    value: function clone8() {
      return new Point3(this.x, this.y);
    }
  }, {
    key: "copyFrom",
    value: function copyFrom(p) {
      this.x = p.x;
      this.y = p.y;
    }
  }]);
}();
var Rectangle = function() {
  function Rectangle2(x3, y3, width, height) {
    _classCallCheck(this, Rectangle2);
    this.x = x3;
    this.y = y3;
    this.width = width;
    this.height = height;
    this.left = x3;
    this.right = x3 + width;
    this.top = y3;
    this.bottom = y3 + height;
  }
  return _createClass(Rectangle2, [{
    key: "toJSON",
    value: function toJSON() {
    }
  }], [{
    key: "fromRect",
    value: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMRect/fromRect_static
       */
      function fromRect(rect) {
        return new Rectangle2(rect.x, rect.y, rect.width, rect.height);
      }
    )
    /**
     * will return a new rect instance
     */
  }, {
    key: "applyTransform",
    value: function applyTransform(rect, matrix2) {
      var topLeft = vec4_exports.fromValues(rect.x, rect.y, 0, 1);
      var topRight = vec4_exports.fromValues(rect.x + rect.width, rect.y, 0, 1);
      var bottomLeft = vec4_exports.fromValues(rect.x, rect.y + rect.height, 0, 1);
      var bottomRight = vec4_exports.fromValues(rect.x + rect.width, rect.y + rect.height, 0, 1);
      var transformedTopLeft = vec4_exports.create();
      var transformedTopRight = vec4_exports.create();
      var transformedBottomLeft = vec4_exports.create();
      var transformedBottomRight = vec4_exports.create();
      vec4_exports.transformMat4(transformedTopLeft, topLeft, matrix2);
      vec4_exports.transformMat4(transformedTopRight, topRight, matrix2);
      vec4_exports.transformMat4(transformedBottomLeft, bottomLeft, matrix2);
      vec4_exports.transformMat4(transformedBottomRight, bottomRight, matrix2);
      var minX = Math.min(transformedTopLeft[0], transformedTopRight[0], transformedBottomLeft[0], transformedBottomRight[0]);
      var minY = Math.min(transformedTopLeft[1], transformedTopRight[1], transformedBottomLeft[1], transformedBottomRight[1]);
      var maxX = Math.max(transformedTopLeft[0], transformedTopRight[0], transformedBottomLeft[0], transformedBottomRight[0]);
      var maxY = Math.max(transformedTopLeft[1], transformedTopRight[1], transformedBottomLeft[1], transformedBottomRight[1]);
      return Rectangle2.fromRect({
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      });
    }
  }]);
}();
var ERROR_MSG_METHOD_NOT_IMPLEMENTED = "Method not implemented.";
var ERROR_MSG_USE_DOCUMENT_ELEMENT = "Use document.documentElement instead.";
var ERROR_MSG_APPEND_DESTROYED_ELEMENT = "Cannot append a destroyed element.";
function getAngle2(angle3) {
  if (angle3 === void 0) {
    return 0;
  }
  if (angle3 > 360 || angle3 < -360) {
    return angle3 % 360;
  }
  return angle3;
}
var $vec3$3 = vec3_exports.create();
function createVec3(x3) {
  var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  var clone8 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  if (Array.isArray(x3) && x3.length === 3) {
    return clone8 ? vec3_exports.clone(x3) : vec3_exports.copy($vec3$3, x3);
  }
  if (isNumber(x3)) {
    return clone8 ? vec3_exports.fromValues(x3, y3, z) : vec3_exports.set($vec3$3, x3, y3, z);
  }
  return clone8 ? vec3_exports.fromValues(x3[0], x3[1] || y3, x3[2] || z) : vec3_exports.set($vec3$3, x3[0], x3[1] || y3, x3[2] || z);
}
var DEG_RAD = Math.PI / 180;
function deg2rad(deg2) {
  return deg2 * DEG_RAD;
}
var RAD_DEG = 180 / Math.PI;
function rad2deg(rad2) {
  return rad2 * RAD_DEG;
}
function turn2deg(turn2) {
  return 360 * turn2;
}
var HALF_PI = Math.PI / 2;
function getEulerFromQuat(out, quat2) {
  var x3 = quat2[0];
  var y3 = quat2[1];
  var z = quat2[2];
  var w = quat2[3];
  var x22 = x3 * x3;
  var y22 = y3 * y3;
  var z2 = z * z;
  var w2 = w * w;
  var unit = x22 + y22 + z2 + w2;
  var test = x3 * w - y3 * z;
  if (test > 0.499995 * unit) {
    out[0] = HALF_PI;
    out[1] = 2 * Math.atan2(y3, x3);
    out[2] = 0;
  } else if (test < -0.499995 * unit) {
    out[0] = -HALF_PI;
    out[1] = 2 * Math.atan2(y3, x3);
    out[2] = 0;
  } else {
    out[0] = Math.asin(2 * (x3 * z - w * y3));
    out[1] = Math.atan2(2 * (x3 * w + y3 * z), 1 - 2 * (z2 + w2));
    out[2] = Math.atan2(2 * (x3 * y3 + z * w), 1 - 2 * (y22 + z2));
  }
  return out;
}
function getEulerFromMat4(out, m2) {
  var x3;
  var z;
  var _mat4$getScaling = mat4_exports.getScaling(vec3_exports.create(), m2), _mat4$getScaling2 = _slicedToArray(_mat4$getScaling, 3), sx = _mat4$getScaling2[0], sy = _mat4$getScaling2[1], sz = _mat4$getScaling2[2];
  var y3 = Math.asin(-m2[2] / sx);
  if (y3 < HALF_PI) {
    if (y3 > -HALF_PI) {
      x3 = Math.atan2(m2[6] / sy, m2[10] / sz);
      z = Math.atan2(m2[1] / sx, m2[0] / sx);
    } else {
      z = 0;
      x3 = -Math.atan2(m2[4] / sy, m2[5] / sy);
    }
  } else {
    z = 0;
    x3 = Math.atan2(m2[4] / sy, m2[5] / sy);
  }
  out[0] = x3;
  out[1] = y3;
  out[2] = z;
  return out;
}
function getEuler(out, quat2) {
  if (quat2.length === 16) {
    return getEulerFromMat4(out, quat2);
  }
  return getEulerFromQuat(out, quat2);
}
function fromRotationTranslationScale2(rotation, x3, y3, scaleX2, scaleY2) {
  var cos = Math.cos(rotation);
  var sin = Math.sin(rotation);
  return mat3_exports.fromValues(scaleX2 * cos, scaleY2 * sin, 0, -scaleX2 * sin, scaleY2 * cos, 0, x3, y3, 1);
}
function makePerspective(out, left, right, top, bottom, near, far) {
  var zero4 = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
  var twoNear = 2 * near;
  var rightMinusLeft = right - left;
  var topMinusBottom = top - bottom;
  var x3 = twoNear / rightMinusLeft;
  var y3 = twoNear / topMinusBottom;
  var a2 = (right + left) / rightMinusLeft;
  var b = (top + bottom) / topMinusBottom;
  var c2;
  var d2;
  var farMinusNear = far - near;
  var farMulNear = far * near;
  if (zero4) {
    c2 = -far / farMinusNear;
    d2 = -farMulNear / farMinusNear;
  } else {
    c2 = -(far + near) / farMinusNear;
    d2 = -2 * farMulNear / farMinusNear;
  }
  out[0] = x3;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = y3;
  out[6] = 0;
  out[7] = 0;
  out[8] = a2;
  out[9] = b;
  out[10] = c2;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = d2;
  out[15] = 0;
  return out;
}
function decompose2(mat) {
  var row0x = mat[0];
  var row0y = mat[1];
  var row1x = mat[3];
  var row1y = mat[4];
  var scalingX = Math.sqrt(row0x * row0x + row0y * row0y);
  var scalingY = Math.sqrt(row1x * row1x + row1y * row1y);
  var determinant3 = row0x * row1y - row0y * row1x;
  if (determinant3 < 0) {
    if (row0x < row1y) {
      scalingX = -scalingX;
    } else {
      scalingY = -scalingY;
    }
  }
  if (scalingX) {
    var invScalingX = 1 / scalingX;
    row0x *= invScalingX;
    row0y *= invScalingX;
  }
  if (scalingY) {
    var invScalingY = 1 / scalingY;
    row1x *= invScalingY;
    row1y *= invScalingY;
  }
  var rotation = Math.atan2(row0y, row0x);
  var angle3 = rad2deg(rotation);
  return [mat[6], mat[7], scalingX, scalingY, angle3];
}
var tmp = mat4_exports.create();
var perspectiveMatrix = mat4_exports.create();
var tmpVec4 = vec4_exports.create();
var row = [vec3_exports.create(), vec3_exports.create(), vec3_exports.create()];
var pdum3 = vec3_exports.create();
function decomposeMat4(matrix2, translation, scale9, skew2, perspective2, quaternion) {
  if (!normalize5(tmp, matrix2)) return false;
  mat4_exports.copy(perspectiveMatrix, tmp);
  perspectiveMatrix[3] = 0;
  perspectiveMatrix[7] = 0;
  perspectiveMatrix[11] = 0;
  perspectiveMatrix[15] = 1;
  if (Math.abs(mat4_exports.determinant(perspectiveMatrix)) < 1e-8) return false;
  var a03 = tmp[3];
  var a13 = tmp[7];
  var a23 = tmp[11];
  var a30 = tmp[12];
  var a31 = tmp[13];
  var a32 = tmp[14];
  var a33 = tmp[15];
  if (a03 !== 0 || a13 !== 0 || a23 !== 0) {
    tmpVec4[0] = a03;
    tmpVec4[1] = a13;
    tmpVec4[2] = a23;
    tmpVec4[3] = a33;
    var ret = mat4_exports.invert(perspectiveMatrix, perspectiveMatrix);
    if (!ret) return false;
    mat4_exports.transpose(perspectiveMatrix, perspectiveMatrix);
    vec4_exports.transformMat4(perspective2, tmpVec4, perspectiveMatrix);
  } else {
    perspective2[0] = perspective2[1] = perspective2[2] = 0;
    perspective2[3] = 1;
  }
  translation[0] = a30;
  translation[1] = a31;
  translation[2] = a32;
  mat3from4(row, tmp);
  scale9[0] = vec3_exports.length(row[0]);
  vec3_exports.normalize(row[0], row[0]);
  skew2[0] = vec3_exports.dot(row[0], row[1]);
  combine(row[1], row[1], row[0], 1, -skew2[0]);
  scale9[1] = vec3_exports.length(row[1]);
  vec3_exports.normalize(row[1], row[1]);
  skew2[0] /= scale9[1];
  skew2[1] = vec3_exports.dot(row[0], row[2]);
  combine(row[2], row[2], row[0], 1, -skew2[1]);
  skew2[2] = vec3_exports.dot(row[1], row[2]);
  combine(row[2], row[2], row[1], 1, -skew2[2]);
  scale9[2] = vec3_exports.length(row[2]);
  vec3_exports.normalize(row[2], row[2]);
  skew2[1] /= scale9[2];
  skew2[2] /= scale9[2];
  vec3_exports.cross(pdum3, row[1], row[2]);
  if (vec3_exports.dot(row[0], pdum3) < 0) {
    for (var i = 0; i < 3; i++) {
      scale9[i] *= -1;
      row[i][0] *= -1;
      row[i][1] *= -1;
      row[i][2] *= -1;
    }
  }
  quaternion[0] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] - row[1][1] - row[2][2], 0));
  quaternion[1] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] + row[1][1] - row[2][2], 0));
  quaternion[2] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] - row[1][1] + row[2][2], 0));
  quaternion[3] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] + row[1][1] + row[2][2], 0));
  if (row[2][1] > row[1][2]) quaternion[0] = -quaternion[0];
  if (row[0][2] > row[2][0]) quaternion[1] = -quaternion[1];
  if (row[1][0] > row[0][1]) quaternion[2] = -quaternion[2];
  return true;
}
function normalize5(out, mat) {
  var m44 = mat[15];
  if (m44 === 0) return false;
  var scale9 = 1 / m44;
  for (var i = 0; i < 16; i++) out[i] = mat[i] * scale9;
  return true;
}
function mat3from4(out, mat4x4) {
  out[0][0] = mat4x4[0];
  out[0][1] = mat4x4[1];
  out[0][2] = mat4x4[2];
  out[1][0] = mat4x4[4];
  out[1][1] = mat4x4[5];
  out[1][2] = mat4x4[6];
  out[2][0] = mat4x4[8];
  out[2][1] = mat4x4[9];
  out[2][2] = mat4x4[10];
}
function combine(out, a2, b, scale1, scale22) {
  out[0] = a2[0] * scale1 + b[0] * scale22;
  out[1] = a2[1] * scale1 + b[1] * scale22;
  out[2] = a2[2] * scale1 + b[2] * scale22;
}
var CameraType = function(CameraType2) {
  CameraType2[CameraType2["ORBITING"] = 0] = "ORBITING";
  CameraType2[CameraType2["EXPLORING"] = 1] = "EXPLORING";
  CameraType2[CameraType2["TRACKING"] = 2] = "TRACKING";
  return CameraType2;
}({});
var CameraTrackingMode = function(CameraTrackingMode2) {
  CameraTrackingMode2[CameraTrackingMode2["DEFAULT"] = 0] = "DEFAULT";
  CameraTrackingMode2[CameraTrackingMode2["ROTATIONAL"] = 1] = "ROTATIONAL";
  CameraTrackingMode2[CameraTrackingMode2["TRANSLATIONAL"] = 2] = "TRANSLATIONAL";
  CameraTrackingMode2[CameraTrackingMode2["CINEMATIC"] = 3] = "CINEMATIC";
  return CameraTrackingMode2;
}({});
var CameraProjectionMode = function(CameraProjectionMode2) {
  CameraProjectionMode2[CameraProjectionMode2["ORTHOGRAPHIC"] = 0] = "ORTHOGRAPHIC";
  CameraProjectionMode2[CameraProjectionMode2["PERSPECTIVE"] = 1] = "PERSPECTIVE";
  return CameraProjectionMode2;
}({});
var CameraEvent = {
  UPDATED: "updated"
};
var MIN_DISTANCE = 2e-4;
var Camera = function() {
  function Camera2() {
    _classCallCheck(this, Camera2);
    this.clipSpaceNearZ = ClipSpaceNearZ.NEGATIVE_ONE;
    this.eventEmitter = new eventemitter3_default();
    this.matrix = mat4_exports.create();
    this.right = vec3_exports.fromValues(1, 0, 0);
    this.up = vec3_exports.fromValues(0, 1, 0);
    this.forward = vec3_exports.fromValues(0, 0, 1);
    this.position = vec3_exports.fromValues(0, 0, 1);
    this.focalPoint = vec3_exports.fromValues(0, 0, 0);
    this.distanceVector = vec3_exports.fromValues(0, 0, -1);
    this.distance = 1;
    this.azimuth = 0;
    this.elevation = 0;
    this.roll = 0;
    this.relAzimuth = 0;
    this.relElevation = 0;
    this.relRoll = 0;
    this.dollyingStep = 0;
    this.maxDistance = Infinity;
    this.minDistance = -Infinity;
    this.zoom = 1;
    this.rotateWorld = false;
    this.fov = 30;
    this.near = 0.1;
    this.far = 1e3;
    this.aspect = 1;
    this.projectionMatrix = mat4_exports.create();
    this.projectionMatrixInverse = mat4_exports.create();
    this.jitteredProjectionMatrix = void 0;
    this.enableUpdate = true;
    this.type = CameraType.EXPLORING;
    this.trackingMode = CameraTrackingMode.DEFAULT;
    this.projectionMode = CameraProjectionMode.PERSPECTIVE;
    this.frustum = new Frustum();
    this.orthoMatrix = mat4_exports.create();
  }
  return _createClass(Camera2, [{
    key: "isOrtho",
    value: (
      // constructor(type = CameraType.EXPLORING, trackingMode = CameraTrackingMode.DEFAULT) {
      //   this.setType(type, trackingMode);
      // }
      function isOrtho() {
        return this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC;
      }
    )
  }, {
    key: "getProjectionMode",
    value: function getProjectionMode() {
      return this.projectionMode;
    }
  }, {
    key: "getPerspective",
    value: function getPerspective() {
      return this.jitteredProjectionMatrix || this.projectionMatrix;
    }
  }, {
    key: "getPerspectiveInverse",
    value: function getPerspectiveInverse() {
      return this.projectionMatrixInverse;
    }
  }, {
    key: "getFrustum",
    value: function getFrustum() {
      return this.frustum;
    }
  }, {
    key: "getPosition",
    value: function getPosition() {
      return this.position;
    }
  }, {
    key: "getFocalPoint",
    value: function getFocalPoint() {
      return this.focalPoint;
    }
  }, {
    key: "getDollyingStep",
    value: function getDollyingStep() {
      return this.dollyingStep;
    }
  }, {
    key: "getNear",
    value: function getNear() {
      return this.near;
    }
  }, {
    key: "getFar",
    value: function getFar() {
      return this.far;
    }
  }, {
    key: "getZoom",
    value: function getZoom() {
      return this.zoom;
    }
  }, {
    key: "getOrthoMatrix",
    value: function getOrthoMatrix() {
      return this.orthoMatrix;
    }
  }, {
    key: "getView",
    value: function getView() {
      return this.view;
    }
  }, {
    key: "setEnableUpdate",
    value: function setEnableUpdate(enabled) {
      this.enableUpdate = enabled;
    }
  }, {
    key: "setType",
    value: function setType(type, trackingMode) {
      this.type = type;
      if (this.type === CameraType.EXPLORING) {
        this.setWorldRotation(true);
      } else {
        this.setWorldRotation(false);
      }
      this._getAngles();
      if (this.type === CameraType.TRACKING && trackingMode !== void 0) {
        this.setTrackingMode(trackingMode);
      }
      return this;
    }
  }, {
    key: "setProjectionMode",
    value: function setProjectionMode(projectionMode) {
      this.projectionMode = projectionMode;
      return this;
    }
  }, {
    key: "setTrackingMode",
    value: function setTrackingMode(trackingMode) {
      if (this.type !== CameraType.TRACKING) {
        throw new Error("Impossible to set a tracking mode if the camera is not of tracking type");
      }
      this.trackingMode = trackingMode;
      return this;
    }
    /**
     * If flag is true, it reverses the azimuth and elevation angles.
     * Subsequent calls to rotate, setAzimuth, setElevation,
     * changeAzimuth or changeElevation will cause the inverted effect.
     * setRoll or changeRoll is not affected by this method.
     *
     * This inversion is useful when one wants to simulate that the world
     * is moving, instead of the camera.
     *
     * By default the camera angles are not reversed.
     * @param {Boolean} flag the boolean flag to reverse the angles.
     */
  }, {
    key: "setWorldRotation",
    value: function setWorldRotation(flag) {
      this.rotateWorld = flag;
      this._getAngles();
      return this;
    }
    /**
     * 计算 MV 矩阵，为相机矩阵的逆矩阵
     */
  }, {
    key: "getViewTransform",
    value: function getViewTransform() {
      return mat4_exports.invert(mat4_exports.create(), this.matrix);
    }
  }, {
    key: "getWorldTransform",
    value: function getWorldTransform() {
      return this.matrix;
    }
  }, {
    key: "jitterProjectionMatrix",
    value: function jitterProjectionMatrix(x3, y3) {
      var translation = mat4_exports.fromTranslation(mat4_exports.create(), [x3, y3, 0]);
      this.jitteredProjectionMatrix = mat4_exports.multiply(mat4_exports.create(), translation, this.projectionMatrix);
    }
  }, {
    key: "clearJitterProjectionMatrix",
    value: function clearJitterProjectionMatrix() {
      this.jitteredProjectionMatrix = void 0;
    }
    /**
     * 设置相机矩阵
     */
  }, {
    key: "setMatrix",
    value: function setMatrix(matrix2) {
      this.matrix = matrix2;
      this._update();
      return this;
    }
    /**
     * Set projection matrix manually.
     */
  }, {
    key: "setProjectionMatrix",
    value: function setProjectionMatrix(matrix2) {
      this.projectionMatrix = matrix2;
    }
  }, {
    key: "setFov",
    value: function setFov(fov) {
      this.setPerspective(this.near, this.far, fov, this.aspect);
      return this;
    }
  }, {
    key: "setAspect",
    value: function setAspect(aspect) {
      this.setPerspective(this.near, this.far, this.fov, aspect);
      return this;
    }
  }, {
    key: "setNear",
    value: function setNear(near) {
      if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(near, this.far, this.fov, this.aspect);
      } else {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, near, this.far);
      }
      return this;
    }
  }, {
    key: "setFar",
    value: function setFar(far) {
      if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(this.near, far, this.fov, this.aspect);
      } else {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, far);
      }
      return this;
    }
    /**
     * Sets an offset in a larger frustum, used in PixelPicking
     */
  }, {
    key: "setViewOffset",
    value: function setViewOffset(fullWidth, fullHeight, x3, y3, width, height) {
      this.aspect = fullWidth / fullHeight;
      if (this.view === void 0) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x3;
      this.view.offsetY = y3;
      this.view.width = width;
      this.view.height = height;
      if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(this.near, this.far, this.fov, this.aspect);
      } else {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
      }
      return this;
    }
  }, {
    key: "clearViewOffset",
    value: function clearViewOffset() {
      if (this.view !== void 0) {
        this.view.enabled = false;
      }
      if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(this.near, this.far, this.fov, this.aspect);
      } else {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
      }
      return this;
    }
  }, {
    key: "setZoom",
    value: function setZoom(zoom) {
      this.zoom = zoom;
      if (this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
      } else if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(this.near, this.far, this.fov, this.aspect);
      }
      return this;
    }
    /**
     * Zoom by specified point in viewport coordinates.
     */
  }, {
    key: "setZoomByViewportPoint",
    value: function setZoomByViewportPoint(zoom, viewportPoint) {
      var _this$canvas$viewport = this.canvas.viewport2Canvas({
        x: viewportPoint[0],
        y: viewportPoint[1]
      }), ox = _this$canvas$viewport.x, oy = _this$canvas$viewport.y;
      var roll = this.roll;
      this.rotate(0, 0, -roll);
      this.setPosition(ox, oy);
      this.setFocalPoint(ox, oy);
      this.setZoom(zoom);
      this.rotate(0, 0, roll);
      var _this$canvas$viewport2 = this.canvas.viewport2Canvas({
        x: viewportPoint[0],
        y: viewportPoint[1]
      }), cx = _this$canvas$viewport2.x, cy = _this$canvas$viewport2.y;
      var dvec = vec3_exports.fromValues(cx - ox, cy - oy, 0);
      var dx = vec3_exports.dot(dvec, this.right) / vec3_exports.length(this.right);
      var dy = vec3_exports.dot(dvec, this.up) / vec3_exports.length(this.up);
      var _this$getPosition = this.getPosition(), _this$getPosition2 = _slicedToArray(_this$getPosition, 2), px2 = _this$getPosition2[0], py = _this$getPosition2[1];
      var _this$getFocalPoint = this.getFocalPoint(), _this$getFocalPoint2 = _slicedToArray(_this$getFocalPoint, 2), fx = _this$getFocalPoint2[0], fy = _this$getFocalPoint2[1];
      this.setPosition(px2 - dx, py - dy);
      this.setFocalPoint(fx - dx, fy - dy);
      return this;
    }
  }, {
    key: "setPerspective",
    value: function setPerspective(near, far, fov, aspect) {
      var _this$view;
      this.projectionMode = CameraProjectionMode.PERSPECTIVE;
      this.fov = fov;
      this.near = near;
      this.far = far;
      this.aspect = aspect;
      var top = this.near * Math.tan(deg2rad(0.5 * this.fov)) / this.zoom;
      var height = 2 * top;
      var width = this.aspect * height;
      var left = -0.5 * width;
      if ((_this$view = this.view) !== null && _this$view !== void 0 && _this$view.enabled) {
        var fullWidth = this.view.fullWidth;
        var fullHeight = this.view.fullHeight;
        left += this.view.offsetX * width / fullWidth;
        top -= this.view.offsetY * height / fullHeight;
        width *= this.view.width / fullWidth;
        height *= this.view.height / fullHeight;
      }
      makePerspective(this.projectionMatrix, left, left + width, top - height, top, near, this.far, this.clipSpaceNearZ === ClipSpaceNearZ.ZERO);
      mat4_exports.invert(this.projectionMatrixInverse, this.projectionMatrix);
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "setOrthographic",
    value: function setOrthographic(l, r, t, b, near, far) {
      var _this$view2;
      this.projectionMode = CameraProjectionMode.ORTHOGRAPHIC;
      this.rright = r;
      this.left = l;
      this.top = t;
      this.bottom = b;
      this.near = near;
      this.far = far;
      var dx = (this.rright - this.left) / (2 * this.zoom);
      var dy = (this.top - this.bottom) / (2 * this.zoom);
      var cx = (this.rright + this.left) / 2;
      var cy = (this.top + this.bottom) / 2;
      var left = cx - dx;
      var right = cx + dx;
      var top = cy + dy;
      var bottom = cy - dy;
      if ((_this$view2 = this.view) !== null && _this$view2 !== void 0 && _this$view2.enabled) {
        var scaleW = (this.rright - this.left) / this.view.fullWidth / this.zoom;
        var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        left += scaleW * this.view.offsetX;
        right = left + scaleW * this.view.width;
        top -= scaleH * this.view.offsetY;
        bottom = top - scaleH * this.view.height;
      }
      if (this.clipSpaceNearZ === ClipSpaceNearZ.NEGATIVE_ONE) {
        mat4_exports.ortho(this.projectionMatrix, left, right, top, bottom, near, far);
      } else {
        mat4_exports.orthoZO(this.projectionMatrix, left, right, top, bottom, near, far);
      }
      mat4_exports.invert(this.projectionMatrixInverse, this.projectionMatrix);
      this._getOrthoMatrix();
      this.triggerUpdate();
      return this;
    }
    /**
     * Move the camera in world coordinates.
     * It will keep looking at the current focal point.
     *
     * support scalars or vectors.
     * @example
     * setPosition(1, 2, 3);
     * setPosition([1, 2, 3]);
     */
  }, {
    key: "setPosition",
    value: function setPosition(x3) {
      var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.position[1];
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.position[2];
      var position = createVec3(x3, y3, z);
      this._setPosition(position);
      this.setFocalPoint(this.focalPoint);
      this.triggerUpdate();
      return this;
    }
    /**
     * Sets the focal point of this camera in world coordinates.
     *
     * support scalars or vectors.
     * @example
     * setFocalPoint(1, 2, 3);
     * setFocalPoint([1, 2, 3]);
     */
  }, {
    key: "setFocalPoint",
    value: function setFocalPoint(x3) {
      var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.focalPoint[1];
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.focalPoint[2];
      var up = vec3_exports.fromValues(0, 1, 0);
      this.focalPoint = createVec3(x3, y3, z);
      if (this.trackingMode === CameraTrackingMode.CINEMATIC) {
        var d2 = vec3_exports.subtract(vec3_exports.create(), this.focalPoint, this.position);
        x3 = d2[0];
        y3 = d2[1];
        z = d2[2];
        var r = vec3_exports.length(d2);
        var el = rad2deg(Math.asin(y3 / r));
        var az = 90 + rad2deg(Math.atan2(z, x3));
        var m2 = mat4_exports.create();
        mat4_exports.rotateY(m2, m2, deg2rad(az));
        mat4_exports.rotateX(m2, m2, deg2rad(el));
        up = vec3_exports.transformMat4(vec3_exports.create(), [0, 1, 0], m2);
      }
      mat4_exports.invert(this.matrix, mat4_exports.lookAt(mat4_exports.create(), this.position, this.focalPoint, up));
      this._getAxes();
      this._getDistance();
      this._getAngles();
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "getDistance",
    value: function getDistance() {
      return this.distance;
    }
  }, {
    key: "getDistanceVector",
    value: function getDistanceVector() {
      return this.distanceVector;
    }
    /**
     * Moves the camera towards/from the focal point.
     */
  }, {
    key: "setDistance",
    value: function setDistance(d2) {
      if (this.distance === d2 || d2 < 0) {
        return this;
      }
      this.distance = d2;
      if (this.distance < MIN_DISTANCE) {
        this.distance = MIN_DISTANCE;
      }
      this.dollyingStep = this.distance / 100;
      var pos = vec3_exports.create();
      d2 = this.distance;
      var n = this.forward;
      var f = this.focalPoint;
      pos[0] = d2 * n[0] + f[0];
      pos[1] = d2 * n[1] + f[1];
      pos[2] = d2 * n[2] + f[2];
      this._setPosition(pos);
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "setMaxDistance",
    value: function setMaxDistance(d2) {
      this.maxDistance = d2;
      return this;
    }
  }, {
    key: "setMinDistance",
    value: function setMinDistance(d2) {
      this.minDistance = d2;
      return this;
    }
    /**
     * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
     * the azimuth in degrees
     */
  }, {
    key: "setAzimuth",
    value: function setAzimuth(az) {
      this.azimuth = getAngle2(az);
      this.computeMatrix();
      this._getAxes();
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        this._getPosition();
      } else if (this.type === CameraType.TRACKING) {
        this._getFocalPoint();
      }
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "getAzimuth",
    value: function getAzimuth() {
      return this.azimuth;
    }
    /**
     * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
     */
  }, {
    key: "setElevation",
    value: function setElevation(el) {
      this.elevation = getAngle2(el);
      this.computeMatrix();
      this._getAxes();
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        this._getPosition();
      } else if (this.type === CameraType.TRACKING) {
        this._getFocalPoint();
      }
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "getElevation",
    value: function getElevation() {
      return this.elevation;
    }
    /**
     * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
     */
  }, {
    key: "setRoll",
    value: function setRoll(angle3) {
      this.roll = getAngle2(angle3);
      this.computeMatrix();
      this._getAxes();
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        this._getPosition();
      } else if (this.type === CameraType.TRACKING) {
        this._getFocalPoint();
      }
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "getRoll",
    value: function getRoll() {
      return this.roll;
    }
    /**
     * 根据相机矩阵重新计算各种相机参数
     */
  }, {
    key: "_update",
    value: function _update() {
      this._getAxes();
      this._getPosition();
      this._getDistance();
      this._getAngles();
      this._getOrthoMatrix();
      this.triggerUpdate();
    }
    /**
     * 计算相机矩阵
     */
  }, {
    key: "computeMatrix",
    value: function computeMatrix() {
      var rotZ = quat_exports.setAxisAngle(quat_exports.create(), [0, 0, 1], deg2rad(this.roll));
      mat4_exports.identity(this.matrix);
      var rotX = quat_exports.setAxisAngle(quat_exports.create(), [1, 0, 0], deg2rad((this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.elevation));
      var rotY = quat_exports.setAxisAngle(quat_exports.create(), [0, 1, 0], deg2rad((this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.azimuth));
      var rotQ = quat_exports.multiply(quat_exports.create(), rotY, rotX);
      rotQ = quat_exports.multiply(quat_exports.create(), rotQ, rotZ);
      var rotMatrix = mat4_exports.fromQuat(mat4_exports.create(), rotQ);
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        mat4_exports.translate(this.matrix, this.matrix, this.focalPoint);
        mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
        mat4_exports.translate(this.matrix, this.matrix, [0, 0, this.distance]);
      } else if (this.type === CameraType.TRACKING) {
        mat4_exports.translate(this.matrix, this.matrix, this.position);
        mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
      }
    }
    /**
     * Sets the camera position in the camera matrix
     */
  }, {
    key: "_setPosition",
    value: function _setPosition(x3, y3, z) {
      this.position = createVec3(x3, y3, z);
      var m2 = this.matrix;
      m2[12] = this.position[0];
      m2[13] = this.position[1];
      m2[14] = this.position[2];
      m2[15] = 1;
      this._getOrthoMatrix();
    }
    /**
     * Recalculates axes based on the current matrix
     */
  }, {
    key: "_getAxes",
    value: function _getAxes() {
      vec3_exports.copy(this.right, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [1, 0, 0, 0], this.matrix)));
      vec3_exports.copy(this.up, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 1, 0, 0], this.matrix)));
      vec3_exports.copy(this.forward, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 0, 1, 0], this.matrix)));
      vec3_exports.normalize(this.right, this.right);
      vec3_exports.normalize(this.up, this.up);
      vec3_exports.normalize(this.forward, this.forward);
    }
    /**
     * Recalculates euler angles based on the current state
     */
  }, {
    key: "_getAngles",
    value: function _getAngles() {
      var x3 = this.distanceVector[0];
      var y3 = this.distanceVector[1];
      var z = this.distanceVector[2];
      var r = vec3_exports.length(this.distanceVector);
      if (r === 0) {
        this.elevation = 0;
        this.azimuth = 0;
        return;
      }
      if (this.type === CameraType.TRACKING) {
        this.elevation = rad2deg(Math.asin(y3 / r));
        this.azimuth = rad2deg(Math.atan2(-x3, -z));
      } else if (this.rotateWorld) {
        this.elevation = rad2deg(Math.asin(y3 / r));
        this.azimuth = rad2deg(Math.atan2(-x3, -z));
      } else {
        this.elevation = -rad2deg(Math.asin(y3 / r));
        this.azimuth = -rad2deg(Math.atan2(-x3, -z));
      }
    }
    /**
     * 重新计算相机位置，只有 ORBITING 模式相机位置才会发生变化
     */
  }, {
    key: "_getPosition",
    value: function _getPosition() {
      vec3_exports.copy(this.position, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 0, 0, 1], this.matrix)));
      this._getDistance();
    }
    /**
     * 重新计算视点，只有 TRACKING 模式视点才会发生变化
     */
  }, {
    key: "_getFocalPoint",
    value: function _getFocalPoint() {
      vec3_exports.transformMat3(this.distanceVector, [0, 0, -this.distance], mat3_exports.fromMat4(mat3_exports.create(), this.matrix));
      vec3_exports.add(this.focalPoint, this.position, this.distanceVector);
      this._getDistance();
    }
    /**
     * 重新计算视距
     */
  }, {
    key: "_getDistance",
    value: function _getDistance() {
      this.distanceVector = vec3_exports.subtract(vec3_exports.create(), this.focalPoint, this.position);
      this.distance = vec3_exports.length(this.distanceVector);
      this.dollyingStep = this.distance / 100;
    }
  }, {
    key: "_getOrthoMatrix",
    value: function _getOrthoMatrix() {
      if (this.projectionMode !== CameraProjectionMode.ORTHOGRAPHIC) {
        return;
      }
      var position = this.position;
      var rotZ = quat_exports.setAxisAngle(quat_exports.create(), [0, 0, 1], -this.roll * Math.PI / 180);
      mat4_exports.fromRotationTranslationScaleOrigin(this.orthoMatrix, rotZ, vec3_exports.fromValues((this.rright - this.left) / 2 - position[0], (this.top - this.bottom) / 2 - position[1], 0), vec3_exports.fromValues(this.zoom, this.zoom, 1), position);
    }
  }, {
    key: "triggerUpdate",
    value: function triggerUpdate() {
      if (this.enableUpdate) {
        var viewMatrix = this.getViewTransform();
        var vpMatrix = mat4_exports.multiply(mat4_exports.create(), this.getPerspective(), viewMatrix);
        this.getFrustum().extractFromVPMatrix(vpMatrix);
        this.eventEmitter.emit(CameraEvent.UPDATED);
      }
    }
  }, {
    key: "rotate",
    value: function rotate6(azimuth, elevation, roll) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "pan",
    value: function pan(tx, ty) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "dolly",
    value: function dolly(value) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "createLandmark",
    value: function createLandmark(name, params) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "gotoLandmark",
    value: function gotoLandmark(name, options) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "cancelLandmarkAnimation",
    value: function cancelLandmarkAnimation() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }]);
}();
var Strategy = function(Strategy2) {
  Strategy2[Strategy2["Standard"] = 0] = "Standard";
  return Strategy2;
}({});
var SortReason = function(SortReason2) {
  SortReason2[SortReason2["ADDED"] = 0] = "ADDED";
  SortReason2[SortReason2["REMOVED"] = 1] = "REMOVED";
  SortReason2[SortReason2["Z_INDEX_CHANGED"] = 2] = "Z_INDEX_CHANGED";
  return SortReason2;
}({});
var $vec3$2 = vec3_exports.create();
var $mat4$1 = mat4_exports.create();
var $quat$2 = quat_exports.create();
function updateLocalTransform(transform2) {
  if (!transform2.localDirtyFlag) {
    return;
  }
  var hasSkew = transform2.localSkew[0] !== 0 || transform2.localSkew[1] !== 0;
  if (hasSkew) {
    mat4_exports.fromRotationTranslationScaleOrigin(transform2.localTransform, transform2.localRotation, transform2.localPosition, vec3_exports.fromValues(1, 1, 1), transform2.origin);
    if (transform2.localSkew[0] !== 0 || transform2.localSkew[1] !== 0) {
      mat4_exports.identity($mat4$1);
      $mat4$1[4] = Math.tan(transform2.localSkew[0]);
      $mat4$1[1] = Math.tan(transform2.localSkew[1]);
      mat4_exports.multiply(transform2.localTransform, transform2.localTransform, $mat4$1);
    }
    var scaling = mat4_exports.fromRotationTranslationScaleOrigin($mat4$1, quat_exports.set($quat$2, 0, 0, 0, 1), vec3_exports.set($vec3$2, 1, 1, 1), transform2.localScale, transform2.origin);
    mat4_exports.multiply(transform2.localTransform, transform2.localTransform, scaling);
  } else {
    var localTransform = transform2.localTransform, localPosition = transform2.localPosition, localRotation = transform2.localRotation, localScale = transform2.localScale, origin = transform2.origin;
    var hasPosition = localPosition[0] !== 0 || localPosition[1] !== 0 || localPosition[2] !== 0;
    var hasRotation = localRotation[3] !== 1 || localRotation[0] !== 0 || localRotation[1] !== 0 || localRotation[2] !== 0;
    var hasScale = localScale[0] !== 1 || localScale[1] !== 1 || localScale[2] !== 1;
    var hasOrigin = origin[0] !== 0 || origin[1] !== 0 || origin[2] !== 0;
    if (!hasRotation && !hasScale && !hasOrigin) {
      if (hasPosition) {
        mat4_exports.fromTranslation(localTransform, localPosition);
      } else {
        mat4_exports.identity(localTransform);
      }
    } else {
      mat4_exports.fromRotationTranslationScaleOrigin(localTransform, localRotation, localPosition, localScale, origin);
    }
  }
  transform2.localDirtyFlag = false;
}
function updateWorldTransform(transform2, parentTransform) {
  if (!transform2.dirtyFlag) {
    return;
  }
  if (!parentTransform) {
    mat4_exports.copy(transform2.worldTransform, transform2.localTransform);
  } else {
    mat4_exports.multiply(transform2.worldTransform, parentTransform.worldTransform, transform2.localTransform);
  }
  transform2.dirtyFlag = false;
}
var EMPTY_PARSED_PATH = {
  absolutePath: [],
  hasArc: false,
  segments: [],
  polygons: [],
  polylines: [],
  curve: null,
  totalLength: 0,
  rect: new Rectangle(0, 0, 0, 0)
};
var PropertySyntax = function(PropertySyntax2) {
  PropertySyntax2["COORDINATE"] = "<coordinate>";
  PropertySyntax2["COLOR"] = "<color>";
  PropertySyntax2["PAINT"] = "<paint>";
  PropertySyntax2["NUMBER"] = "<number>";
  PropertySyntax2["ANGLE"] = "<angle>";
  PropertySyntax2["OPACITY_VALUE"] = "<opacity-value>";
  PropertySyntax2["SHADOW_BLUR"] = "<shadow-blur>";
  PropertySyntax2["LENGTH"] = "<length>";
  PropertySyntax2["PERCENTAGE"] = "<percentage>";
  PropertySyntax2["LENGTH_PERCENTAGE"] = "<length> | <percentage>";
  PropertySyntax2["LENGTH_PERCENTAGE_12"] = "[<length> | <percentage>]{1,2}";
  PropertySyntax2["LENGTH_PERCENTAGE_14"] = "[<length> | <percentage>]{1,4}";
  PropertySyntax2["LIST_OF_POINTS"] = "<list-of-points>";
  PropertySyntax2["PATH"] = "<path>";
  PropertySyntax2["FILTER"] = "<filter>";
  PropertySyntax2["Z_INDEX"] = "<z-index>";
  PropertySyntax2["OFFSET_DISTANCE"] = "<offset-distance>";
  PropertySyntax2["DEFINED_PATH"] = "<defined-path>";
  PropertySyntax2["MARKER"] = "<marker>";
  PropertySyntax2["TRANSFORM"] = "<transform>";
  PropertySyntax2["TRANSFORM_ORIGIN"] = "<transform-origin>";
  PropertySyntax2["TEXT"] = "<text>";
  PropertySyntax2["TEXT_TRANSFORM"] = "<text-transform>";
  return PropertySyntax2;
}({});
function define2(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define2(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m2, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m2 = reHex.exec(format2)) ? (l = m2[1].length, m2 = parseInt(m2[1], 16), l === 6 ? rgbn(m2) : l === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format2)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format2)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format2)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format2)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a2) {
  if (a2 <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a2);
}
function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define2(Rgb, rgb, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a2 = clampa(this.opacity);
  return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s2, l, a2) {
  if (a2 <= 0) h = s2 = l = NaN;
  else if (l <= 0 || l >= 1) h = s2 = NaN;
  else if (s2 <= 0) h = NaN;
  return new Hsl(h, s2, l, a2);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min5 = Math.min(r, g, b), max6 = Math.max(r, g, b), h = NaN, s2 = max6 - min5, l = (max6 + min5) / 2;
  if (s2) {
    if (r === max6) h = (g - b) / s2 + (g < b) * 6;
    else if (g === max6) h = (b - r) / s2 + 2;
    else h = (r - g) / s2 + 4;
    s2 /= l < 0.5 ? max6 + min5 : 2 - max6 - min5;
    h *= 60;
  } else {
    s2 = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s2, l, o.opacity);
}
function hsl(h, s2, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define2(Hsl, hsl, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a2 = clampa(this.opacity);
    return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
function memoize2(func, resolver) {
  if (typeof func !== "function" || resolver != null && typeof resolver !== "function") {
    throw new TypeError("Expected a function");
  }
  var _memoized = function memoized() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    var cache = _memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    _memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  _memoized.cache = new (memoize2.Cache || Map)();
  memoize2.cacheList.push(_memoized.cache);
  return _memoized;
}
memoize2.Cache = Map;
memoize2.cacheList = [];
memoize2.clearCache = function() {
  memoize2.cacheList.forEach(function(cache) {
    return cache.clear();
  });
};
var UnitType = function(UnitType2) {
  UnitType2[UnitType2["kUnknown"] = 0] = "kUnknown";
  UnitType2[UnitType2["kNumber"] = 1] = "kNumber";
  UnitType2[UnitType2["kPercentage"] = 2] = "kPercentage";
  UnitType2[UnitType2["kEms"] = 3] = "kEms";
  UnitType2[UnitType2["kPixels"] = 4] = "kPixels";
  UnitType2[UnitType2["kRems"] = 5] = "kRems";
  UnitType2[UnitType2["kDegrees"] = 6] = "kDegrees";
  UnitType2[UnitType2["kRadians"] = 7] = "kRadians";
  UnitType2[UnitType2["kGradians"] = 8] = "kGradians";
  UnitType2[UnitType2["kTurns"] = 9] = "kTurns";
  UnitType2[UnitType2["kMilliseconds"] = 10] = "kMilliseconds";
  UnitType2[UnitType2["kSeconds"] = 11] = "kSeconds";
  UnitType2[UnitType2["kInteger"] = 12] = "kInteger";
  return UnitType2;
}({});
var UnitCategory = function(UnitCategory2) {
  UnitCategory2[UnitCategory2["kUNumber"] = 0] = "kUNumber";
  UnitCategory2[UnitCategory2["kUPercent"] = 1] = "kUPercent";
  UnitCategory2[UnitCategory2["kULength"] = 2] = "kULength";
  UnitCategory2[UnitCategory2["kUAngle"] = 3] = "kUAngle";
  UnitCategory2[UnitCategory2["kUTime"] = 4] = "kUTime";
  UnitCategory2[UnitCategory2["kUOther"] = 5] = "kUOther";
  return UnitCategory2;
}({});
var Nested = function(Nested2) {
  Nested2[Nested2["kYes"] = 0] = "kYes";
  Nested2[Nested2["kNo"] = 1] = "kNo";
  return Nested2;
}({});
var ParenLess = function(ParenLess2) {
  ParenLess2[ParenLess2["kYes"] = 0] = "kYes";
  ParenLess2[ParenLess2["kNo"] = 1] = "kNo";
  return ParenLess2;
}({});
var data = [
  {
    name: "em",
    unit_type: UnitType.kEms
  },
  // {
  //   name: 'ex',
  //   unit_type: UnitType.kExs,
  // },
  {
    name: "px",
    unit_type: UnitType.kPixels
  },
  // {
  //   name: "cm",
  //   unit_type: UnitType.kCentimeters,
  // },
  // {
  //   name: "mm",
  //   unit_type: UnitType.kMillimeters,
  // },
  // {
  //   name: "q",
  //   unit_type: UnitType.kQuarterMillimeters,
  // },
  // {
  //   name: "in",
  //   unit_type: UnitType.kInches,
  // },
  // {
  //   name: "pt",
  //   unit_type: UnitType.kPoints,
  // },
  // {
  //   name: "pc",
  //   unit_type: UnitType.kPicas,
  // },
  {
    name: "deg",
    unit_type: UnitType.kDegrees
  },
  {
    name: "rad",
    unit_type: UnitType.kRadians
  },
  {
    name: "grad",
    unit_type: UnitType.kGradians
  },
  {
    name: "ms",
    unit_type: UnitType.kMilliseconds
  },
  {
    name: "s",
    unit_type: UnitType.kSeconds
  },
  // {
  //   name: "hz",
  //   unit_type: UnitType.kHertz,
  // },
  // {
  //   name: "khz",
  //   unit_type: UnitType.kKilohertz,
  // },
  // {
  //   name: "dpi",
  //   unit_type: "kDotsPerInch",
  // },
  // {
  //   name: "dpcm",
  //   unit_type: "kDotsPerCentimeter",
  // },
  // {
  //   name: "dppx",
  //   unit_type: "kDotsPerPixel",
  // },
  // {
  //   name: "x",
  //   unit_type: "kDotsPerPixel",
  // },
  // {
  //   name: "vw",
  //   unit_type: "kViewportWidth",
  // },
  // {
  //   name: "vh",
  //   unit_type: "kViewportHeight",
  // },
  // {
  //   name: "vi",
  //   unit_type: "kViewportInlineSize",
  // },
  // {
  //   name: "vb",
  //   unit_type: "kViewportBlockSize",
  // },
  // {
  //   name: "vmin",
  //   unit_type: UnitType.kViewportMin,
  // },
  // {
  //   name: "vmax",
  //   unit_type: UnitType.kViewportMax,
  // },
  // {
  //   name: "svw",
  //   unit_type: "kSmallViewportWidth",
  // },
  // {
  //   name: "svh",
  //   unit_type: "kSmallViewportHeight",
  // },
  // {
  //   name: "svi",
  //   unit_type: "kSmallViewportInlineSize",
  // },
  // {
  //   name: "svb",
  //   unit_type: "kSmallViewportBlockSize",
  // },
  // {
  //   name: "svmin",
  //   unit_type: "kSmallViewportMin",
  // },
  // {
  //   name: "svmax",
  //   unit_type: "kSmallViewportMax",
  // },
  // {
  //   name: "lvw",
  //   unit_type: "kLargeViewportWidth",
  // },
  // {
  //   name: "lvh",
  //   unit_type: "kLargeViewportHeight",
  // },
  // {
  //   name: "lvi",
  //   unit_type: "kLargeViewportInlineSize",
  // },
  // {
  //   name: "lvb",
  //   unit_type: "kLargeViewportBlockSize",
  // },
  // {
  //   name: "lvmin",
  //   unit_type: UnitType.kLargeViewportMin,
  // },
  // {
  //   name: "lvmax",
  //   unit_type: UnitType.kLargeViewportMax,
  // },
  // {
  //   name: "dvw",
  //   unit_type: UnitType.kDynamicViewportWidth,
  // },
  // {
  //   name: "dvh",
  //   unit_type: UnitType.kDynamicViewportHeight,
  // },
  // {
  //   name: "dvi",
  //   unit_type: UnitType.kDynamicViewportInlineSize,
  // },
  // {
  //   name: "dvb",
  //   unit_type: UnitType.kDynamicViewportBlockSize,
  // },
  // {
  //   name: "dvmin",
  //   unit_type: UnitType.kDynamicViewportMin,
  // },
  // {
  //   name: "dvmax",
  //   unit_type: UnitType.kDynamicViewportMax,
  // },
  // {
  //   name: "cqw",
  //   unit_type: UnitType.kContainerWidth,
  // },
  // {
  //   name: "cqh",
  //   unit_type: UnitType.kContainerHeight,
  // },
  // {
  //   name: "cqi",
  //   unit_type: UnitType.kContainerInlineSize,
  // },
  // {
  //   name: "cqb",
  //   unit_type: UnitType.kContainerBlockSize,
  // },
  // {
  //   name: "cqmin",
  //   unit_type: UnitType.kContainerMin,
  // },
  // {
  //   name: "cqmax",
  //   unit_type: UnitType.kContainerMax,
  // },
  {
    name: "rem",
    unit_type: UnitType.kRems
  },
  // {
  //   name: 'fr',
  //   unit_type: UnitType.kFraction,
  // },
  {
    name: "turn",
    unit_type: UnitType.kTurns
  }
  // {
  //   name: 'ch',
  //   unit_type: UnitType.kChs,
  // },
  // {
  //   name: '__qem',
  //   unit_type: UnitType.kQuirkyEms,
  // },
];
var CSSStyleValueType = function(CSSStyleValueType2) {
  CSSStyleValueType2[CSSStyleValueType2["kUnknownType"] = 0] = "kUnknownType";
  CSSStyleValueType2[CSSStyleValueType2["kUnparsedType"] = 1] = "kUnparsedType";
  CSSStyleValueType2[CSSStyleValueType2["kKeywordType"] = 2] = "kKeywordType";
  CSSStyleValueType2[CSSStyleValueType2["kUnitType"] = 3] = "kUnitType";
  CSSStyleValueType2[CSSStyleValueType2["kSumType"] = 4] = "kSumType";
  CSSStyleValueType2[CSSStyleValueType2["kProductType"] = 5] = "kProductType";
  CSSStyleValueType2[CSSStyleValueType2["kNegateType"] = 6] = "kNegateType";
  CSSStyleValueType2[CSSStyleValueType2["kInvertType"] = 7] = "kInvertType";
  CSSStyleValueType2[CSSStyleValueType2["kMinType"] = 8] = "kMinType";
  CSSStyleValueType2[CSSStyleValueType2["kMaxType"] = 9] = "kMaxType";
  CSSStyleValueType2[CSSStyleValueType2["kClampType"] = 10] = "kClampType";
  CSSStyleValueType2[CSSStyleValueType2["kTransformType"] = 11] = "kTransformType";
  CSSStyleValueType2[CSSStyleValueType2["kPositionType"] = 12] = "kPositionType";
  CSSStyleValueType2[CSSStyleValueType2["kURLImageType"] = 13] = "kURLImageType";
  CSSStyleValueType2[CSSStyleValueType2["kColorType"] = 14] = "kColorType";
  CSSStyleValueType2[CSSStyleValueType2["kUnsupportedColorType"] = 15] = "kUnsupportedColorType";
  return CSSStyleValueType2;
}({});
var stringToUnitType = function stringToUnitType2(name) {
  return data.find(function(item) {
    return item.name === name;
  }).unit_type;
};
var unitFromName = function unitFromName2(name) {
  if (!name) {
    return UnitType.kUnknown;
  }
  if (name === "number") {
    return UnitType.kNumber;
  }
  if (name === "percent" || name === "%") {
    return UnitType.kPercentage;
  }
  return stringToUnitType(name);
};
var unitTypeToUnitCategory = function unitTypeToUnitCategory2(type) {
  switch (type) {
    case UnitType.kNumber:
    case UnitType.kInteger:
      return UnitCategory.kUNumber;
    case UnitType.kPercentage:
      return UnitCategory.kUPercent;
    case UnitType.kPixels:
      return UnitCategory.kULength;
    case UnitType.kMilliseconds:
    case UnitType.kSeconds:
      return UnitCategory.kUTime;
    case UnitType.kDegrees:
    case UnitType.kRadians:
    case UnitType.kGradians:
    case UnitType.kTurns:
      return UnitCategory.kUAngle;
    default:
      return UnitCategory.kUOther;
  }
};
var canonicalUnitTypeForCategory = function canonicalUnitTypeForCategory2(category) {
  switch (category) {
    case UnitCategory.kUNumber:
      return UnitType.kNumber;
    case UnitCategory.kULength:
      return UnitType.kPixels;
    case UnitCategory.kUPercent:
      return UnitType.kPercentage;
    case UnitCategory.kUTime:
      return UnitType.kSeconds;
    case UnitCategory.kUAngle:
      return UnitType.kDegrees;
    default:
      return UnitType.kUnknown;
  }
};
var conversionToCanonicalUnitsScaleFactor = function conversionToCanonicalUnitsScaleFactor2(unit_type) {
  var factor = 1;
  switch (unit_type) {
    case UnitType.kPixels:
    case UnitType.kDegrees:
    case UnitType.kSeconds:
      break;
    case UnitType.kMilliseconds:
      factor = 1e-3;
      break;
    case UnitType.kRadians:
      factor = 180 / Math.PI;
      break;
    case UnitType.kGradians:
      factor = 0.9;
      break;
    case UnitType.kTurns:
      factor = 360;
      break;
  }
  return factor;
};
var unitTypeToString = function unitTypeToString2(type) {
  switch (type) {
    case UnitType.kNumber:
    case UnitType.kInteger:
      return "";
    case UnitType.kPercentage:
      return "%";
    case UnitType.kEms:
      return "em";
    case UnitType.kRems:
      return "rem";
    case UnitType.kPixels:
      return "px";
    case UnitType.kDegrees:
      return "deg";
    case UnitType.kRadians:
      return "rad";
    case UnitType.kGradians:
      return "grad";
    case UnitType.kMilliseconds:
      return "ms";
    case UnitType.kSeconds:
      return "s";
    case UnitType.kTurns:
      return "turn";
  }
  return "";
};
var CSSStyleValue = function() {
  function CSSStyleValue2() {
    _classCallCheck(this, CSSStyleValue2);
  }
  return _createClass(CSSStyleValue2, [{
    key: "toString",
    value: (
      // protected abstract toCSSValue(): CSSValue;
      function toString3() {
        return this.buildCSSText(Nested.kNo, ParenLess.kNo, "");
      }
    )
  }, {
    key: "isNumericValue",
    value: function isNumericValue() {
      return this.getType() >= CSSStyleValueType.kUnitType && this.getType() <= CSSStyleValueType.kClampType;
    }
  }], [{
    key: "isAngle",
    value: (
      // static parse(propertyName: string, value: string): CSSStyleValue {
      //   return parseCSSStyleValue(propertyName, value)[0];
      // }
      // static parseAll(propertyName: string, value: string): CSSStyleValue[] {
      //   return parseCSSStyleValue(propertyName, value);
      // }
      function isAngle(unit) {
        return unit === UnitType.kDegrees || unit === UnitType.kRadians || unit === UnitType.kGradians || unit === UnitType.kTurns;
      }
    )
    // static isViewportPercentageLength(type: UnitType) {
    //   return type >= UnitType.kViewportWidth && type <= UnitType.kDynamicViewportMax;
    // }
    // static isContainerPercentageLength(type: UnitType) {
    //   return type >= UnitType.kContainerWidth && type <= UnitType.kContainerMax;
    // }
  }, {
    key: "isLength",
    value: function isLength(type) {
      return type >= UnitType.kEms && type < UnitType.kDegrees;
    }
  }, {
    key: "isRelativeUnit",
    value: function isRelativeUnit(type) {
      return type === UnitType.kPercentage || type === UnitType.kEms || // type === UnitType.kExs ||
      type === UnitType.kRems;
    }
  }, {
    key: "isTime",
    value: function isTime(unit) {
      return unit === UnitType.kSeconds || unit === UnitType.kMilliseconds;
    }
    // static isFrequency(unit: UnitType) {
    //   return unit == UnitType.kHertz || unit == UnitType.kKilohertz;
    // }
    // static isResolution(type: UnitType) {
    //   return type >= UnitType.kDotsPerPixel && type <= UnitType.kDotsPerCentimeter;
    // }
    // static isFlex(unit: UnitType) {
    //   return unit === UnitType.kFraction;
    // }
  }]);
}();
var CSSColorValue = function(_CSSStyleValue) {
  function CSSColorValue2(colorSpace) {
    var _this2;
    _classCallCheck(this, CSSColorValue2);
    _this2 = _callSuper(this, CSSColorValue2);
    _this2.colorSpace = colorSpace;
    return _this2;
  }
  _inherits(CSSColorValue2, _CSSStyleValue);
  return _createClass(CSSColorValue2, [{
    key: "getType",
    value: function getType3() {
      return CSSStyleValueType.kColorType;
    }
    /**
     * @see https://drafts.css-houdini.org/css-typed-om-1/#dom-csscolorvalue-to
     */
  }, {
    key: "to",
    value: function to(colorSpace) {
      return this;
    }
  }]);
}(CSSStyleValue);
var GradientType = function(GradientType2) {
  GradientType2[GradientType2["Constant"] = 0] = "Constant";
  GradientType2[GradientType2["LinearGradient"] = 1] = "LinearGradient";
  GradientType2[GradientType2["RadialGradient"] = 2] = "RadialGradient";
  return GradientType2;
}({});
var CSSGradientValue = function(_CSSStyleValue) {
  function CSSGradientValue2(type, value) {
    var _this2;
    _classCallCheck(this, CSSGradientValue2);
    _this2 = _callSuper(this, CSSGradientValue2);
    _this2.type = type;
    _this2.value = value;
    return _this2;
  }
  _inherits(CSSGradientValue2, _CSSStyleValue);
  return _createClass(CSSGradientValue2, [{
    key: "clone",
    value: function clone8() {
      return new CSSGradientValue2(this.type, this.value);
    }
  }, {
    key: "buildCSSText",
    value: function buildCSSText(n, p, result) {
      return result;
    }
  }, {
    key: "getType",
    value: function getType3() {
      return CSSStyleValueType.kColorType;
    }
  }]);
}(CSSStyleValue);
var CSSKeywordValue = function(_CSSStyleValue) {
  function CSSKeywordValue2(value) {
    var _this2;
    _classCallCheck(this, CSSKeywordValue2);
    _this2 = _callSuper(this, CSSKeywordValue2);
    _this2.value = value;
    return _this2;
  }
  _inherits(CSSKeywordValue2, _CSSStyleValue);
  return _createClass(CSSKeywordValue2, [{
    key: "clone",
    value: function clone8() {
      return new CSSKeywordValue2(this.value);
    }
  }, {
    key: "getType",
    value: function getType3() {
      return CSSStyleValueType.kKeywordType;
    }
  }, {
    key: "buildCSSText",
    value: function buildCSSText(n, p, result) {
      return result + this.value;
    }
  }]);
}(CSSStyleValue);
var formatInfinityOrNaN = function formatInfinityOrNaN2(number2) {
  var suffix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  var result = "";
  if (!Number.isFinite(number2)) {
    if (number2 > 0) result = "infinity";
    else result = "-infinity";
  } else {
    result = "NaN";
  }
  return result += suffix;
};
var toCanonicalUnit = function toCanonicalUnit2(unit) {
  return canonicalUnitTypeForCategory(unitTypeToUnitCategory(unit));
};
var CSSUnitValue = function(_CSSStyleValue) {
  function CSSUnitValue2(value) {
    var _this2;
    var unitOrName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : UnitType.kNumber;
    _classCallCheck(this, CSSUnitValue2);
    _this2 = _callSuper(this, CSSUnitValue2);
    var unit;
    if (typeof unitOrName === "string") {
      unit = unitFromName(unitOrName);
    } else {
      unit = unitOrName;
    }
    _this2.unit = unit;
    _this2.value = value;
    return _this2;
  }
  _inherits(CSSUnitValue2, _CSSStyleValue);
  return _createClass(CSSUnitValue2, [{
    key: "clone",
    value: function clone8() {
      return new CSSUnitValue2(this.value, this.unit);
    }
  }, {
    key: "equals",
    value: function equals7(other) {
      var other_unit_value = other;
      return this.value === other_unit_value.value && this.unit === other_unit_value.unit;
    }
  }, {
    key: "getType",
    value: function getType3() {
      return CSSStyleValueType.kUnitType;
    }
  }, {
    key: "convertTo",
    value: function convertTo(target_unit) {
      if (this.unit === target_unit) {
        return new CSSUnitValue2(this.value, this.unit);
      }
      var canonical_unit = toCanonicalUnit(this.unit);
      if (canonical_unit !== toCanonicalUnit(target_unit) || canonical_unit === UnitType.kUnknown) {
        return null;
      }
      var scale_factor = conversionToCanonicalUnitsScaleFactor(this.unit) / conversionToCanonicalUnitsScaleFactor(target_unit);
      return new CSSUnitValue2(this.value * scale_factor, target_unit);
    }
  }, {
    key: "buildCSSText",
    value: function buildCSSText(n, p, result) {
      var text;
      switch (this.unit) {
        case UnitType.kUnknown:
          break;
        case UnitType.kInteger:
          text = Number(this.value).toFixed(0);
          break;
        case UnitType.kNumber:
        case UnitType.kPercentage:
        case UnitType.kEms:
        case UnitType.kRems:
        case UnitType.kPixels:
        case UnitType.kDegrees:
        case UnitType.kRadians:
        case UnitType.kGradians:
        case UnitType.kMilliseconds:
        case UnitType.kSeconds:
        case UnitType.kTurns: {
          var kMinInteger = -999999;
          var kMaxInteger = 999999;
          var value = this.value;
          var unit = unitTypeToString(this.unit);
          if (value < kMinInteger || value > kMaxInteger) {
            var _unit = unitTypeToString(this.unit);
            if (!Number.isFinite(value) || Number.isNaN(value)) {
              text = formatInfinityOrNaN(value, _unit);
            } else {
              text = value + (_unit || "");
            }
          } else {
            text = "".concat(value).concat(unit);
          }
        }
      }
      result += text;
      return result;
    }
  }]);
}(CSSStyleValue);
var Opx = new CSSUnitValue(0, "px");
new CSSUnitValue(1, "px");
var Odeg = new CSSUnitValue(0, "deg");
var CSSRGB = function(_CSSColorValue) {
  function CSSRGB2(r, g, b) {
    var _this2;
    var alpha = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
    var isNone = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
    _classCallCheck(this, CSSRGB2);
    _this2 = _callSuper(this, CSSRGB2, ["rgb"]);
    _this2.r = r;
    _this2.g = g;
    _this2.b = b;
    _this2.alpha = alpha;
    _this2.isNone = isNone;
    return _this2;
  }
  _inherits(CSSRGB2, _CSSColorValue);
  return _createClass(CSSRGB2, [{
    key: "clone",
    value: function clone8() {
      return new CSSRGB2(this.r, this.g, this.b, this.alpha);
    }
  }, {
    key: "buildCSSText",
    value: function buildCSSText(n, p, result) {
      return "".concat(result, "rgba(").concat(this.r, ",").concat(this.g, ",").concat(this.b, ",").concat(this.alpha, ")");
    }
  }]);
}(CSSColorValue);
var unsetKeywordValue = new CSSKeywordValue("unset");
var initialKeywordValue = new CSSKeywordValue("initial");
var inheritKeywordValue = new CSSKeywordValue("inherit");
var keywordCache = {
  "": unsetKeywordValue,
  unset: unsetKeywordValue,
  initial: initialKeywordValue,
  inherit: inheritKeywordValue
};
var getOrCreateKeyword = function getOrCreateKeyword2(name) {
  if (!keywordCache[name]) {
    keywordCache[name] = new CSSKeywordValue(name);
  }
  return keywordCache[name];
};
var noneColor = new CSSRGB(0, 0, 0, 0, true);
var transparentColor = new CSSRGB(0, 0, 0, 0);
var getOrCreateRGBA = memoize2(function(r, g, b, a2) {
  return new CSSRGB(r, g, b, a2);
}, function(r, g, b, a2) {
  return "rgba(".concat(r, ",").concat(g, ",").concat(b, ",").concat(a2, ")");
});
var getOrCreateUnitValue = function getOrCreateUnitValue2(value) {
  var unitOrName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : UnitType.kNumber;
  return new CSSUnitValue(value, unitOrName);
};
new CSSUnitValue(50, "%");
function colorStopToString(colorStop) {
  var type = colorStop.type, value = colorStop.value;
  if (type === "hex") {
    return "#".concat(value);
  }
  if (type === "literal") {
    return value;
  }
  if (type === "rgb") {
    return "rgb(".concat(value.join(","), ")");
  }
  return "rgba(".concat(value.join(","), ")");
}
var parseGradient$1 = /* @__PURE__ */ function() {
  var tokens = {
    linearGradient: /^(linear\-gradient)/i,
    repeatingLinearGradient: /^(repeating\-linear\-gradient)/i,
    radialGradient: /^(radial\-gradient)/i,
    repeatingRadialGradient: /^(repeating\-radial\-gradient)/i,
    /**
     * @see https://projects.verou.me/conic-gradient/
     */
    conicGradient: /^(conic\-gradient)/i,
    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
    extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /^\#([0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^rgb/i,
    rgbaColor: /^rgba/i,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
  };
  var input = "";
  function error2(msg) {
    throw new Error("".concat(input, ": ").concat(msg));
  }
  function getAST() {
    var ast = matchListDefinitions();
    if (input.length > 0) {
      error2("Invalid input not EOF");
    }
    return ast;
  }
  function matchListDefinitions() {
    return matchListing(matchDefinition);
  }
  function matchDefinition() {
    return matchGradient("linear-gradient", tokens.linearGradient, matchLinearOrientation) || matchGradient("repeating-linear-gradient", tokens.repeatingLinearGradient, matchLinearOrientation) || matchGradient("radial-gradient", tokens.radialGradient, matchListRadialOrientations) || matchGradient("repeating-radial-gradient", tokens.repeatingRadialGradient, matchListRadialOrientations) || matchGradient("conic-gradient", tokens.conicGradient, matchListRadialOrientations);
  }
  function matchGradient(gradientType, pattern, orientationMatcher) {
    return matchCall(pattern, function(captures) {
      var orientation = orientationMatcher();
      if (orientation) {
        if (!scan(tokens.comma)) {
          error2("Missing comma before color stops");
        }
      }
      return {
        type: gradientType,
        orientation,
        colorStops: matchListing(matchColorStop)
      };
    });
  }
  function matchCall(pattern, callback) {
    var captures = scan(pattern);
    if (captures) {
      if (!scan(tokens.startCall)) {
        error2("Missing (");
      }
      var result = callback(captures);
      if (!scan(tokens.endCall)) {
        error2("Missing )");
      }
      return result;
    }
  }
  function matchLinearOrientation() {
    return matchSideOrCorner() || matchAngle();
  }
  function matchSideOrCorner() {
    return match("directional", tokens.sideOrCorner, 1);
  }
  function matchAngle() {
    return match("angular", tokens.angleValue, 1);
  }
  function matchListRadialOrientations() {
    var radialOrientations;
    var radialOrientation = matchRadialOrientation();
    var lookaheadCache;
    if (radialOrientation) {
      radialOrientations = [];
      radialOrientations.push(radialOrientation);
      lookaheadCache = input;
      if (scan(tokens.comma)) {
        radialOrientation = matchRadialOrientation();
        if (radialOrientation) {
          radialOrientations.push(radialOrientation);
        } else {
          input = lookaheadCache;
        }
      }
    }
    return radialOrientations;
  }
  function matchRadialOrientation() {
    var radialType = matchCircle() || matchEllipse();
    if (radialType) {
      radialType.at = matchAtPosition();
    } else {
      var extent = matchExtentKeyword();
      if (extent) {
        radialType = extent;
        var positionAt = matchAtPosition();
        if (positionAt) {
          radialType.at = positionAt;
        }
      } else {
        var defaultPosition = matchPositioning();
        if (defaultPosition) {
          radialType = {
            type: "default-radial",
            // @ts-ignore
            at: defaultPosition
          };
        }
      }
    }
    return radialType;
  }
  function matchCircle() {
    var circle2 = match("shape", /^(circle)/i, 0);
    if (circle2) {
      circle2.style = matchLength() || matchExtentKeyword();
    }
    return circle2;
  }
  function matchEllipse() {
    var ellipse = match("shape", /^(ellipse)/i, 0);
    if (ellipse) {
      ellipse.style = matchDistance() || matchExtentKeyword();
    }
    return ellipse;
  }
  function matchExtentKeyword() {
    return match("extent-keyword", tokens.extentKeywords, 1);
  }
  function matchAtPosition() {
    if (match("position", /^at/, 0)) {
      var positioning = matchPositioning();
      if (!positioning) {
        error2("Missing positioning value");
      }
      return positioning;
    }
  }
  function matchPositioning() {
    var location = matchCoordinates();
    if (location.x || location.y) {
      return {
        type: "position",
        value: location
      };
    }
  }
  function matchCoordinates() {
    return {
      x: matchDistance(),
      y: matchDistance()
    };
  }
  function matchListing(matcher) {
    var captures = matcher();
    var result = [];
    if (captures) {
      result.push(captures);
      while (scan(tokens.comma)) {
        captures = matcher();
        if (captures) {
          result.push(captures);
        } else {
          error2("One extra comma");
        }
      }
    }
    return result;
  }
  function matchColorStop() {
    var color2 = matchColor();
    if (!color2) {
      error2("Expected color definition");
    }
    color2.length = matchDistance();
    return color2;
  }
  function matchColor() {
    return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor();
  }
  function matchLiteralColor() {
    return match("literal", tokens.literalColor, 0);
  }
  function matchHexColor() {
    return match("hex", tokens.hexColor, 1);
  }
  function matchRGBColor() {
    return matchCall(tokens.rgbColor, function() {
      return {
        type: "rgb",
        value: matchListing(matchNumber)
      };
    });
  }
  function matchRGBAColor() {
    return matchCall(tokens.rgbaColor, function() {
      return {
        type: "rgba",
        value: matchListing(matchNumber)
      };
    });
  }
  function matchNumber() {
    return scan(tokens.number)[1];
  }
  function matchDistance() {
    return match("%", tokens.percentageValue, 1) || matchPositionKeyword() || matchLength();
  }
  function matchPositionKeyword() {
    return match("position-keyword", tokens.positionKeywords, 1);
  }
  function matchLength() {
    return match("px", tokens.pixelValue, 1) || match("em", tokens.emValue, 1);
  }
  function match(type, pattern, captureIndex) {
    var captures = scan(pattern);
    if (captures) {
      return {
        type,
        value: captures[captureIndex]
      };
    }
  }
  function scan(regexp) {
    var blankCaptures = /^[\n\r\t\s]+/.exec(input);
    if (blankCaptures) {
      consume(blankCaptures[0].length);
    }
    var captures = regexp.exec(input);
    if (captures) {
      consume(captures[0].length);
    }
    return captures;
  }
  function consume(size2) {
    input = input.substring(size2);
  }
  return function(code) {
    input = code;
    return getAST();
  };
}();
function computeLinearGradient(min5, width, height, angle3) {
  var rad2 = deg2rad(angle3.value);
  var rx = 0;
  var ry = 0;
  var rcx = rx + width / 2;
  var rcy = ry + height / 2;
  var length5 = Math.abs(width * Math.cos(rad2)) + Math.abs(height * Math.sin(rad2));
  var x1 = min5[0] + rcx - Math.cos(rad2) * length5 / 2;
  var y1 = min5[1] + rcy - Math.sin(rad2) * length5 / 2;
  var x22 = min5[0] + rcx + Math.cos(rad2) * length5 / 2;
  var y22 = min5[1] + rcy + Math.sin(rad2) * length5 / 2;
  return {
    x1,
    y1,
    x2: x22,
    y2: y22
  };
}
function computeRadialGradient(min5, width, height, cx, cy, size2) {
  var x3 = cx.value;
  var y3 = cy.value;
  if (cx.unit === UnitType.kPercentage) {
    x3 = cx.value / 100 * width;
  }
  if (cy.unit === UnitType.kPercentage) {
    y3 = cy.value / 100 * height;
  }
  var r = Math.max(distanceSquareRoot([0, 0], [x3, y3]), distanceSquareRoot([0, height], [x3, y3]), distanceSquareRoot([width, height], [x3, y3]), distanceSquareRoot([width, 0], [x3, y3]));
  if (size2) {
    if (size2 instanceof CSSUnitValue) {
      r = size2.value;
    } else if (size2 instanceof CSSKeywordValue) {
      if (size2.value === "closest-side") {
        r = Math.min(x3, width - x3, y3, height - y3);
      } else if (size2.value === "farthest-side") {
        r = Math.max(x3, width - x3, y3, height - y3);
      } else if (size2.value === "closest-corner") {
        r = Math.min(distanceSquareRoot([0, 0], [x3, y3]), distanceSquareRoot([0, height], [x3, y3]), distanceSquareRoot([width, height], [x3, y3]), distanceSquareRoot([width, 0], [x3, y3]));
      }
    }
  }
  return {
    x: x3 + min5[0],
    y: y3 + min5[1],
    r
  };
}
var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
function spaceColorStops(colorStops) {
  var _colorStops$length;
  var length5 = colorStops.length;
  colorStops[length5 - 1].length = (_colorStops$length = colorStops[length5 - 1].length) !== null && _colorStops$length !== void 0 ? _colorStops$length : {
    type: "%",
    value: "100"
  };
  if (length5 > 1) {
    var _colorStops$0$length;
    colorStops[0].length = (_colorStops$0$length = colorStops[0].length) !== null && _colorStops$0$length !== void 0 ? _colorStops$0$length : {
      type: "%",
      value: "0"
    };
  }
  var previousIndex = 0;
  var previousOffset = Number(colorStops[0].length.value);
  for (var i = 1; i < length5; i++) {
    var _colorStops$i$length;
    var offset = (_colorStops$i$length = colorStops[i].length) === null || _colorStops$i$length === void 0 ? void 0 : _colorStops$i$length.value;
    if (!isNil(offset) && !isNil(previousOffset)) {
      for (var j = 1; j < i - previousIndex; j++) colorStops[previousIndex + j].length = {
        type: "%",
        value: "".concat(previousOffset + (Number(offset) - previousOffset) * j / (i - previousIndex))
      };
      previousIndex = i;
      previousOffset = Number(offset);
    }
  }
}
var SideOrCornerToDegMap = {
  left: 270 - 90,
  top: 0 - 90,
  bottom: 180 - 90,
  right: 90 - 90,
  "left top": 315 - 90,
  "top left": 315 - 90,
  "left bottom": 225 - 90,
  "bottom left": 225 - 90,
  "right top": 45 - 90,
  "top right": 45 - 90,
  "right bottom": 135 - 90,
  "bottom right": 135 - 90
};
var angleToDeg = memoize2(function(orientation) {
  var angle3;
  if (orientation.type === "angular") {
    angle3 = Number(orientation.value);
  } else {
    angle3 = SideOrCornerToDegMap[orientation.value] || 0;
  }
  return getOrCreateUnitValue(angle3, "deg");
});
var positonToCSSUnitValue = memoize2(function(position) {
  var cx = 50;
  var cy = 50;
  var unitX = "%";
  var unitY = "%";
  if ((position === null || position === void 0 ? void 0 : position.type) === "position") {
    var _position$value = position.value, x3 = _position$value.x, y3 = _position$value.y;
    if ((x3 === null || x3 === void 0 ? void 0 : x3.type) === "position-keyword") {
      if (x3.value === "left") {
        cx = 0;
      } else if (x3.value === "center") {
        cx = 50;
      } else if (x3.value === "right") {
        cx = 100;
      } else if (x3.value === "top") {
        cy = 0;
      } else if (x3.value === "bottom") {
        cy = 100;
      }
    }
    if ((y3 === null || y3 === void 0 ? void 0 : y3.type) === "position-keyword") {
      if (y3.value === "left") {
        cx = 0;
      } else if (y3.value === "center") {
        cy = 50;
      } else if (y3.value === "right") {
        cx = 100;
      } else if (y3.value === "top") {
        cy = 0;
      } else if (y3.value === "bottom") {
        cy = 100;
      }
    }
    if ((x3 === null || x3 === void 0 ? void 0 : x3.type) === "px" || (x3 === null || x3 === void 0 ? void 0 : x3.type) === "%" || (x3 === null || x3 === void 0 ? void 0 : x3.type) === "em") {
      unitX = x3 === null || x3 === void 0 ? void 0 : x3.type;
      cx = Number(x3.value);
    }
    if ((y3 === null || y3 === void 0 ? void 0 : y3.type) === "px" || (y3 === null || y3 === void 0 ? void 0 : y3.type) === "%" || (y3 === null || y3 === void 0 ? void 0 : y3.type) === "em") {
      unitY = y3 === null || y3 === void 0 ? void 0 : y3.type;
      cy = Number(y3.value);
    }
  }
  return {
    cx: getOrCreateUnitValue(cx, unitX),
    cy: getOrCreateUnitValue(cy, unitY)
  };
});
var parseGradient = memoize2(function(colorStr) {
  if (colorStr.indexOf("linear") > -1 || colorStr.indexOf("radial") > -1) {
    var ast = parseGradient$1(colorStr);
    return ast.map(function(_ref) {
      var type2 = _ref.type, orientation = _ref.orientation, colorStops = _ref.colorStops;
      spaceColorStops(colorStops);
      var steps2 = colorStops.map(function(colorStop) {
        return {
          offset: getOrCreateUnitValue(Number(colorStop.length.value), "%"),
          color: colorStopToString(colorStop)
        };
      });
      if (type2 === "linear-gradient") {
        return new CSSGradientValue(GradientType.LinearGradient, {
          angle: orientation ? angleToDeg(orientation) : Odeg,
          steps: steps2
        });
      }
      if (type2 === "radial-gradient") {
        if (!orientation) {
          orientation = [{
            type: "shape",
            value: "circle"
          }];
        }
        if (orientation[0].type === "shape" && orientation[0].value === "circle") {
          var _positonToCSSUnitValu = positonToCSSUnitValue(orientation[0].at), cx = _positonToCSSUnitValu.cx, cy = _positonToCSSUnitValu.cy;
          var size2;
          if (orientation[0].style) {
            var _orientation$0$style = orientation[0].style, _type = _orientation$0$style.type, value = _orientation$0$style.value;
            if (_type === "extent-keyword") {
              size2 = getOrCreateKeyword(value);
            } else {
              size2 = getOrCreateUnitValue(value, _type);
            }
          }
          return new CSSGradientValue(GradientType.RadialGradient, {
            cx,
            cy,
            size: size2,
            steps: steps2
          });
        }
      }
      return void 0;
    });
  }
  var type = colorStr[0];
  if (colorStr[1] === "(" || colorStr[2] === "(") {
    if (type === "l") {
      var arr = regexLG.exec(colorStr);
      if (arr) {
        var _arr$2$match;
        var steps = ((_arr$2$match = arr[2].match(regexColorStop)) === null || _arr$2$match === void 0 ? void 0 : _arr$2$match.map(function(stop) {
          return stop.split(":");
        })) || [];
        return [new CSSGradientValue(GradientType.LinearGradient, {
          angle: getOrCreateUnitValue(parseFloat(arr[1]), "deg"),
          steps: steps.map(function(_ref2) {
            var _ref3 = _slicedToArray(_ref2, 2), offset = _ref3[0], color2 = _ref3[1];
            return {
              offset: getOrCreateUnitValue(Number(offset) * 100, "%"),
              color: color2
            };
          })
        })];
      }
    } else if (type === "r") {
      var parsedRadialGradient = parseRadialGradient(colorStr);
      if (parsedRadialGradient) {
        if (isString(parsedRadialGradient)) {
          colorStr = parsedRadialGradient;
        } else {
          return [new CSSGradientValue(GradientType.RadialGradient, parsedRadialGradient)];
        }
      }
    } else if (type === "p") {
      return parsePattern(colorStr);
    }
  }
});
function parseRadialGradient(gradientStr) {
  var arr = regexRG.exec(gradientStr);
  if (arr) {
    var _arr$4$match;
    var steps = ((_arr$4$match = arr[4].match(regexColorStop)) === null || _arr$4$match === void 0 ? void 0 : _arr$4$match.map(function(stop) {
      return stop.split(":");
    })) || [];
    return {
      cx: getOrCreateUnitValue(50, "%"),
      cy: getOrCreateUnitValue(50, "%"),
      steps: steps.map(function(_ref4) {
        var _ref5 = _slicedToArray(_ref4, 2), offset = _ref5[0], color2 = _ref5[1];
        return {
          offset: getOrCreateUnitValue(Number(offset) * 100, "%"),
          color: color2
        };
      })
    };
  }
  return null;
}
function parsePattern(patternStr) {
  var arr = regexPR.exec(patternStr);
  if (arr) {
    var repetition = arr[1];
    var src = arr[2];
    switch (repetition) {
      case "a":
        repetition = "repeat";
        break;
      case "x":
        repetition = "repeat-x";
        break;
      case "y":
        repetition = "repeat-y";
        break;
      case "n":
        repetition = "no-repeat";
        break;
      default:
        repetition = "no-repeat";
    }
    return {
      image: src,
      // @ts-ignore
      repetition
    };
  }
  return null;
}
function isPattern(object) {
  return object && !!object.image;
}
function isCSSRGB(object) {
  return object && !isNil(object.r) && !isNil(object.g) && !isNil(object.b);
}
var parseColor = memoize2(function(colorStr) {
  if (isPattern(colorStr)) {
    return _objectSpread2({
      repetition: "repeat"
    }, colorStr);
  }
  if (isNil(colorStr)) {
    colorStr = "";
  }
  if (colorStr === "transparent") {
    return transparentColor;
  }
  if (colorStr === "currentColor") {
    colorStr = "black";
  } else if (colorStr === "none") {
    return noneColor;
  }
  var g = parseGradient(colorStr);
  if (g) {
    return g;
  }
  var color$1 = color(colorStr);
  var rgba2 = [0, 0, 0, 0];
  if (color$1 !== null) {
    rgba2[0] = color$1.r || 0;
    rgba2[1] = color$1.g || 0;
    rgba2[2] = color$1.b || 0;
    rgba2[3] = color$1.opacity;
  }
  return getOrCreateRGBA.apply(void 0, rgba2);
});
function mergeColors(left, right) {
  if (!isCSSRGB(left) || !isCSSRGB(right)) {
    return;
  }
  return [[Number(left.r), Number(left.g), Number(left.b), Number(left.alpha)], [Number(right.r), Number(right.g), Number(right.b), Number(right.alpha)], function(color2) {
    var rgba2 = color2.slice();
    if (rgba2[3]) {
      for (var i = 0; i < 3; i++) rgba2[i] = Math.round(clamp_default(rgba2[i], 0, 255));
    }
    rgba2[3] = clamp_default(rgba2[3], 0, 1);
    return "rgba(".concat(rgba2.join(","), ")");
  }];
}
function parseDimension(unitRegExp, string) {
  if (isNil(string)) {
    return getOrCreateUnitValue(0, "px");
  }
  string = "".concat(string).trim().toLowerCase();
  if (isFinite(Number(string))) {
    if ("px".search(unitRegExp) >= 0) {
      return getOrCreateUnitValue(Number(string), "px");
    }
    if ("deg".search(unitRegExp) >= 0) {
      return getOrCreateUnitValue(Number(string), "deg");
    }
  }
  var matchedUnits = [];
  string = string.replace(unitRegExp, function(match) {
    matchedUnits.push(match);
    return "U".concat(match);
  });
  var taggedUnitRegExp = "U(".concat(unitRegExp.source, ")");
  return matchedUnits.map(function(unit) {
    return getOrCreateUnitValue(Number(string.replace(new RegExp("U".concat(unit), "g"), "").replace(new RegExp(taggedUnitRegExp, "g"), "*0")), unit);
  })[0];
}
var parseLengthUnmemoize = function parseLengthUnmemoize2(css) {
  return parseDimension(new RegExp("px", "g"), css);
};
var parseLength = memoize2(parseLengthUnmemoize);
var parserPercentageUnmemoize = function parserPercentageUnmemoize2(css) {
  return parseDimension(new RegExp("%", "g"), css);
};
memoize2(parserPercentageUnmemoize);
var parseLengthOrPercentageUnmemoize = function parseLengthOrPercentageUnmemoize2(css) {
  if (isNumber(css) || isFinite(Number(css))) {
    return getOrCreateUnitValue(Number(css) || 0, "px");
  }
  return parseDimension(new RegExp("px|%|em|rem", "g"), css);
};
var parseLengthOrPercentage = memoize2(parseLengthOrPercentageUnmemoize);
var parseAngleUnmemoize = function parseAngleUnmemoize2(css) {
  return parseDimension(new RegExp("deg|rad|grad|turn", "g"), css);
};
var parseAngle = memoize2(parseAngleUnmemoize);
function mergeDimensions(left, right, target, nonNegative) {
  var index2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  var unit = "";
  var leftValue = left.value || 0;
  var rightValue = right.value || 0;
  var canonicalUnit = toCanonicalUnit(left.unit);
  var leftCanonicalUnitValue = left.convertTo(canonicalUnit);
  var rightCanonicalUnitValue = right.convertTo(canonicalUnit);
  if (leftCanonicalUnitValue && rightCanonicalUnitValue) {
    leftValue = leftCanonicalUnitValue.value;
    rightValue = rightCanonicalUnitValue.value;
    unit = unitTypeToString(left.unit);
  } else if (CSSUnitValue.isLength(left.unit) || CSSUnitValue.isLength(right.unit)) {
    leftValue = convertPercentUnit(left, index2, target);
    rightValue = convertPercentUnit(right, index2, target);
    unit = "px";
  }
  return [leftValue, rightValue, function(value) {
    if (nonNegative) {
      value = Math.max(value, 0);
    }
    return value + unit;
  }];
}
function convertAngleUnit(value) {
  var deg2 = 0;
  if (value.unit === UnitType.kDegrees) {
    deg2 = value.value;
  } else if (value.unit === UnitType.kRadians) {
    deg2 = rad2deg(Number(value.value));
  } else if (value.unit === UnitType.kTurns) {
    deg2 = turn2deg(Number(value.value));
  } else if (value.value) {
    deg2 = value.value;
  }
  return deg2;
}
function parseDimensionArrayFormat(string, size2) {
  var parsed;
  if (Array.isArray(string)) {
    parsed = string.map(function(segment) {
      return Number(segment);
    });
  } else if (isString(string)) {
    parsed = string.split(" ").map(function(segment) {
      return Number(segment);
    });
  } else if (isNumber(string)) {
    parsed = [string];
  }
  if (size2 === 2) {
    if (parsed.length === 1) {
      return [parsed[0], parsed[0]];
    }
    return [parsed[0], parsed[1]];
  }
  if (size2 === 4) {
    if (parsed.length === 1) {
      return [parsed[0], parsed[0], parsed[0], parsed[0]];
    }
    if (parsed.length === 2) {
      return [parsed[0], parsed[1], parsed[0], parsed[1]];
    }
    if (parsed.length === 3) {
      return [parsed[0], parsed[1], parsed[2], parsed[1]];
    }
    return [parsed[0], parsed[1], parsed[2], parsed[3]];
  }
  if (size2 === "even" && parsed.length % 2 === 1) {
    return [].concat(_toConsumableArray(parsed), _toConsumableArray(parsed));
  }
  return parsed;
}
function convertPercentUnit(valueWithUnit, vec3Index, target) {
  var useMin = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (valueWithUnit.unit === UnitType.kPixels) {
    return Number(valueWithUnit.value);
  }
  if (valueWithUnit.unit === UnitType.kPercentage && target) {
    var bounds = target.nodeName === Shape.GROUP ? target.getLocalBounds() : target.getGeometryBounds();
    return (useMin ? bounds.min[vec3Index] : 0) + valueWithUnit.value / 100 * bounds.halfExtents[vec3Index] * 2;
  }
  return 0;
}
var parseParam = function parseParam2(css) {
  return parseDimension(/deg|rad|grad|turn|px|%/g, css);
};
var supportedFilters = ["blur", "brightness", "drop-shadow", "contrast", "grayscale", "sepia", "saturate", "hue-rotate", "invert"];
function parseFilter() {
  var filterStr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  filterStr = filterStr.toLowerCase().trim();
  if (filterStr === "none") {
    return [];
  }
  var filterRegExp = /\s*([\w-]+)\(([^)]*)\)/g;
  var result = [];
  var match;
  var prevLastIndex = 0;
  while (match = filterRegExp.exec(filterStr)) {
    if (match.index !== prevLastIndex) {
      return [];
    }
    prevLastIndex = match.index + match[0].length;
    if (supportedFilters.indexOf(match[1]) > -1) {
      result.push({
        name: match[1],
        params: match[2].split(" ").map(function(p) {
          return parseParam(p) || parseColor(p);
        })
      });
    }
    if (filterRegExp.lastIndex === filterStr.length) {
      return result;
    }
  }
  return [];
}
function numberToString(x3) {
  return x3.toString();
}
var parseNumberUnmemoize = function parseNumberUnmemoize2(string) {
  if (typeof string === "number") {
    return getOrCreateUnitValue(string);
  }
  if (/^\s*[-+]?(\d*\.)?\d+\s*$/.test(string)) {
    return getOrCreateUnitValue(Number(string));
  }
  return getOrCreateUnitValue(0);
};
var parseNumber = memoize2(parseNumberUnmemoize);
memoize2(function(string) {
  if (isString(string)) {
    return string.split(" ").map(parseNumber);
  }
  return string.map(parseNumber);
});
function mergeNumbers(left, right) {
  return [left, right, numberToString];
}
function clampedMergeNumbers(min5, max6) {
  return function(left, right) {
    return [left, right, function(x3) {
      return numberToString(clamp_default(x3, min5, max6));
    }];
  };
}
function mergeNumberLists(left, right) {
  if (left.length !== right.length) {
    return;
  }
  return [left, right, function(numberList) {
    return numberList;
  }];
}
function getOrCalculatePathTotalLength(path) {
  if (path.parsedStyle.d.totalLength === 0) {
    path.parsedStyle.d.totalLength = getTotalLength(path.parsedStyle.d.absolutePath);
  }
  return path.parsedStyle.d.totalLength;
}
function getOrCalculatePolylineTotalLength(polyline) {
  if (polyline.parsedStyle.points.totalLength === 0) {
    polyline.parsedStyle.points.totalLength = length$2(polyline.parsedStyle.points.points);
  }
  return polyline.parsedStyle.points.totalLength;
}
function removeRedundantMCommand(path) {
  for (var i = 0; i < path.length; i++) {
    var prevSegment = path[i - 1];
    var segment = path[i];
    var cmd = segment[0];
    if (cmd === "M") {
      if (prevSegment) {
        var prevCmd = prevSegment[0];
        var srcPoint = [segment[1], segment[2]];
        var destPoint = void 0;
        if (prevCmd === "L" || prevCmd === "M") {
          destPoint = [prevSegment[1], prevSegment[2]];
        } else if (prevCmd === "C" || prevCmd === "A" || prevCmd === "Q") {
          destPoint = [prevSegment[prevSegment.length - 2], prevSegment[prevSegment.length - 1]];
        }
        if (destPoint && isSamePoint(srcPoint, destPoint)) {
          path.splice(i, 1);
          i--;
        }
      }
    }
  }
}
function hasArcOrBezier(path) {
  var hasArc = false;
  var count = path.length;
  for (var i = 0; i < count; i++) {
    var params = path[i];
    var cmd = params[0];
    if (cmd === "C" || cmd === "A" || cmd === "Q") {
      hasArc = true;
      break;
    }
  }
  return hasArc;
}
function extractPolygons(pathArray) {
  var polygons = [];
  var polylines = [];
  var points = [];
  for (var i = 0; i < pathArray.length; i++) {
    var params = pathArray[i];
    var cmd = params[0];
    if (cmd === "M") {
      if (points.length) {
        polylines.push(points);
        points = [];
      }
      points.push([params[1], params[2]]);
    } else if (cmd === "Z") {
      if (points.length) {
        polygons.push(points);
        points = [];
      }
    } else {
      points.push([params[1], params[2]]);
    }
  }
  if (points.length > 0) {
    polylines.push(points);
  }
  return {
    polygons,
    polylines
  };
}
function isSamePoint(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}
function getPathBBox2(segments, lineWidth) {
  var xArr = [];
  var yArr = [];
  var segmentsWithAngle = [];
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
    var box2 = void 0;
    switch (segment.command) {
      case "Q":
        box2 = box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
        break;
      case "C":
        box2 = box$3(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
        break;
      case "A":
        var arcParams = segment.arcParams;
        box2 = box$5(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
        break;
      default:
        xArr.push(currentPoint[0]);
        yArr.push(currentPoint[1]);
        break;
    }
    if (box2) {
      segment.box = box2;
      xArr.push(box2.x, box2.x + box2.width);
      yArr.push(box2.y, box2.y + box2.height);
    }
    if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) {
      segmentsWithAngle.push(segment);
    }
  }
  xArr = xArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  yArr = yArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  var minX = min_default(xArr);
  var minY = min_default(yArr);
  var maxX = max(xArr);
  var maxY = max(yArr);
  if (segmentsWithAngle.length === 0) {
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  for (var _i = 0; _i < segmentsWithAngle.length; _i++) {
    var _segment = segmentsWithAngle[_i];
    var _currentPoint = _segment.currentPoint;
    var extra = void 0;
    if (_currentPoint[0] === minX) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      minX -= extra.xExtra;
    } else if (_currentPoint[0] === maxX) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      maxX += extra.xExtra;
    }
    if (_currentPoint[1] === minY) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      minY -= extra.yExtra;
    } else if (_currentPoint[1] === maxY) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      maxY += extra.yExtra;
    }
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getExtraFromSegmentWithAngle(segment, lineWidth) {
  var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
  var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
  var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
  var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
  var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
  if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {
    return {
      xExtra: 0,
      yExtra: 0
    };
  }
  var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
  var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
  xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
  yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
  var extra = {
    // 水平方向投影
    xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
    // 垂直方向投影
    yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
  };
  return extra;
}
function toSymmetry(point2, center) {
  return [center[0] + (center[0] - point2[0]), center[1] + (center[1] - point2[1])];
}
var angleBetween2 = function angleBetween3(v0, v1) {
  var p = v0.x * v1.x + v0.y * v1.y;
  var n = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)));
  var sign = v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1;
  var angle3 = sign * Math.acos(p / n);
  return angle3;
};
var pointOnEllipticalArc = function pointOnEllipticalArc2(p0, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p1, t) {
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  xAxisRotation = mod_default(xAxisRotation, 360);
  var xAxisRotationRadians = deg2rad(xAxisRotation);
  if (p0.x === p1.x && p0.y === p1.y) {
    return {
      x: p0.x,
      y: p0.y,
      ellipticalArcAngle: 0
    };
  }
  if (rx === 0 || ry === 0) {
    return {
      x: 0,
      y: 0,
      ellipticalArcAngle: 0
    };
  }
  var dx = (p0.x - p1.x) / 2;
  var dy = (p0.y - p1.y) / 2;
  var transformedPoint = {
    x: Math.cos(xAxisRotationRadians) * dx + Math.sin(xAxisRotationRadians) * dy,
    y: -Math.sin(xAxisRotationRadians) * dx + Math.cos(xAxisRotationRadians) * dy
  };
  var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
  if (radiiCheck > 1) {
    rx *= Math.sqrt(radiiCheck);
    ry *= Math.sqrt(radiiCheck);
  }
  var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cRadicand = cSquareNumerator / cSquareRootDenom;
  cRadicand = cRadicand < 0 ? 0 : cRadicand;
  var cCoef = (largeArcFlag !== sweepFlag ? 1 : -1) * Math.sqrt(cRadicand);
  var transformedCenter = {
    x: cCoef * (rx * transformedPoint.y / ry),
    y: cCoef * (-(ry * transformedPoint.x) / rx)
  };
  var center = {
    x: Math.cos(xAxisRotationRadians) * transformedCenter.x - Math.sin(xAxisRotationRadians) * transformedCenter.y + (p0.x + p1.x) / 2,
    y: Math.sin(xAxisRotationRadians) * transformedCenter.x + Math.cos(xAxisRotationRadians) * transformedCenter.y + (p0.y + p1.y) / 2
  };
  var startVector = {
    x: (transformedPoint.x - transformedCenter.x) / rx,
    y: (transformedPoint.y - transformedCenter.y) / ry
  };
  var startAngle = angleBetween2({
    x: 1,
    y: 0
  }, startVector);
  var endVector = {
    x: (-transformedPoint.x - transformedCenter.x) / rx,
    y: (-transformedPoint.y - transformedCenter.y) / ry
  };
  var sweepAngle = angleBetween2(startVector, endVector);
  if (!sweepFlag && sweepAngle > 0) {
    sweepAngle -= 2 * Math.PI;
  } else if (sweepFlag && sweepAngle < 0) {
    sweepAngle += 2 * Math.PI;
  }
  sweepAngle %= 2 * Math.PI;
  var angle3 = startAngle + sweepAngle * t;
  var ellipseComponentX = rx * Math.cos(angle3);
  var ellipseComponentY = ry * Math.sin(angle3);
  var point2 = {
    x: Math.cos(xAxisRotationRadians) * ellipseComponentX - Math.sin(xAxisRotationRadians) * ellipseComponentY + center.x,
    y: Math.sin(xAxisRotationRadians) * ellipseComponentX + Math.cos(xAxisRotationRadians) * ellipseComponentY + center.y,
    ellipticalArcStartAngle: startAngle,
    ellipticalArcEndAngle: startAngle + sweepAngle,
    ellipticalArcAngle: angle3,
    ellipticalArcCenter: center,
    resultantRx: rx,
    resultantRy: ry
  };
  return point2;
};
function path2Segments(path) {
  var segments = [];
  var currentPoint = null;
  var nextParams = null;
  var startMovePoint = null;
  var lastStartMovePointIndex = 0;
  var count = path.length;
  for (var i = 0; i < count; i++) {
    var params = path[i];
    nextParams = path[i + 1];
    var command = params[0];
    var segment = {
      command,
      prePoint: currentPoint,
      params,
      startTangent: null,
      endTangent: null,
      currentPoint: null,
      nextPoint: null,
      arcParams: null,
      box: null,
      cubicParams: null
    };
    switch (command) {
      case "M":
        startMovePoint = [params[1], params[2]];
        lastStartMovePointIndex = i;
        break;
      case "A":
        var arcParams = getArcParams(currentPoint, params);
        segment.arcParams = arcParams;
        break;
    }
    if (command === "Z") {
      currentPoint = startMovePoint;
      nextParams = path[lastStartMovePointIndex + 1];
    } else {
      var len5 = params.length;
      currentPoint = [params[len5 - 2], params[len5 - 1]];
    }
    if (nextParams && nextParams[0] === "Z") {
      nextParams = path[lastStartMovePointIndex];
      if (segments[lastStartMovePointIndex]) {
        segments[lastStartMovePointIndex].prePoint = currentPoint;
      }
    }
    segment.currentPoint = currentPoint;
    if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
      segments[lastStartMovePointIndex].prePoint = segment.prePoint;
    }
    var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
    segment.nextPoint = nextPoint;
    var prePoint = segment.prePoint;
    if (["L", "H", "V"].includes(command)) {
      segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
      segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
    } else if (command === "Q") {
      var cp = [params[1], params[2]];
      segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
      segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
    } else if (command === "T") {
      var preSegment = segments[i - 1];
      var _cp = toSymmetry(preSegment.currentPoint, prePoint);
      if (preSegment.command === "Q") {
        segment.command = "Q";
        segment.startTangent = [prePoint[0] - _cp[0], prePoint[1] - _cp[1]];
        segment.endTangent = [currentPoint[0] - _cp[0], currentPoint[1] - _cp[1]];
      } else {
        segment.command = "TL";
        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
      }
    } else if (command === "C") {
      var cp1 = [params[1], params[2]];
      var cp2 = [params[3], params[4]];
      segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
      segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
        segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
      }
      if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
        segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
      }
    } else if (command === "S") {
      var _preSegment = segments[i - 1];
      var _cp2 = toSymmetry(_preSegment.currentPoint, prePoint);
      var _cp3 = [params[1], params[2]];
      if (_preSegment.command === "C") {
        segment.command = "C";
        segment.startTangent = [prePoint[0] - _cp2[0], prePoint[1] - _cp2[1]];
        segment.endTangent = [currentPoint[0] - _cp3[0], currentPoint[1] - _cp3[1]];
      } else {
        segment.command = "SQ";
        segment.startTangent = [prePoint[0] - _cp3[0], prePoint[1] - _cp3[1]];
        segment.endTangent = [currentPoint[0] - _cp3[0], currentPoint[1] - _cp3[1]];
      }
    } else if (command === "A") {
      var _getTangentAtRatio = getTangentAtRatio(segment, 0), dx1 = _getTangentAtRatio.x, dy1 = _getTangentAtRatio.y;
      var _getTangentAtRatio2 = getTangentAtRatio(segment, 1, false), dx2 = _getTangentAtRatio2.x, dy2 = _getTangentAtRatio2.y;
      segment.startTangent = [dx1, dy1];
      segment.endTangent = [dx2, dy2];
    }
    segments.push(segment);
  }
  return segments;
}
function getTangentAtRatio(segment, ratio) {
  var sign = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var _segment$arcParams = segment.arcParams, _segment$arcParams$rx = _segment$arcParams.rx, rx = _segment$arcParams$rx === void 0 ? 0 : _segment$arcParams$rx, _segment$arcParams$ry = _segment$arcParams.ry, ry = _segment$arcParams$ry === void 0 ? 0 : _segment$arcParams$ry, xRotation = _segment$arcParams.xRotation, arcFlag = _segment$arcParams.arcFlag, sweepFlag = _segment$arcParams.sweepFlag;
  var p1 = pointOnEllipticalArc({
    x: segment.prePoint[0],
    y: segment.prePoint[1]
  }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, {
    x: segment.currentPoint[0],
    y: segment.currentPoint[1]
  }, ratio);
  var p2 = pointOnEllipticalArc({
    x: segment.prePoint[0],
    y: segment.prePoint[1]
  }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, {
    x: segment.currentPoint[0],
    y: segment.currentPoint[1]
  }, sign ? ratio + 5e-3 : ratio - 5e-3);
  var xDist = p2.x - p1.x;
  var yDist = p2.y - p1.y;
  var dist4 = Math.sqrt(xDist * xDist + yDist * yDist);
  return {
    x: -xDist / dist4,
    y: -yDist / dist4
  };
}
function vMag(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio(u, v) {
  return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
}
function vAngle(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}
function getArcParams(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = mod_default(deg2rad(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  var x22 = params[6];
  var y22 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x22) / 2 + Math.sin(xRotation) * (y1 - y22) / 2;
  var yp = -1 * Math.sin(xRotation) * (x1 - x22) / 2 + Math.cos(xRotation) * (y1 - y22) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
  if (arcFlag === sweepFlag) {
    f *= -1;
  }
  if (isNaN(f)) {
    f = 0;
  }
  var cxp = ry ? f * rx * yp / ry : 0;
  var cyp = rx ? f * -ry * xp / rx : 0;
  var cx = (x1 + x22) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y22) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var theta = vAngle([1, 0], u);
  var dTheta = vAngle(u, v);
  if (vRatio(u, v) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta -= 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta += 2 * Math.PI;
  }
  return {
    cx,
    cy,
    // 弧形的起点和终点相同时，长轴和短轴的长度按 0 处理
    rx: isSamePoint(startPoint, [x22, y22]) ? 0 : rx,
    ry: isSamePoint(startPoint, [x22, y22]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation,
    arcFlag,
    sweepFlag
  };
}
function commandsToPathString(commands, object, transform2) {
  return commands.reduce(function(prev, cur) {
    var path = "";
    if (cur[0] === "M" || cur[0] === "L") {
      var p = vec3_exports.fromValues(cur[1], cur[2], 0);
      if (transform2) {
        vec3_exports.transformMat4(p, p, transform2);
      }
      path = "".concat(cur[0]).concat(p[0], ",").concat(p[1]);
    } else if (cur[0] === "Z") {
      path = cur[0];
    } else if (cur[0] === "C") {
      var p1 = vec3_exports.fromValues(cur[1], cur[2], 0);
      var p2 = vec3_exports.fromValues(cur[3], cur[4], 0);
      var p3 = vec3_exports.fromValues(cur[5], cur[6], 0);
      if (transform2) {
        vec3_exports.transformMat4(p1, p1, transform2);
        vec3_exports.transformMat4(p2, p2, transform2);
        vec3_exports.transformMat4(p3, p3, transform2);
      }
      path = "".concat(cur[0]).concat(p1[0], ",").concat(p1[1], ",").concat(p2[0], ",").concat(p2[1], ",").concat(p3[0], ",").concat(p3[1]);
    } else if (cur[0] === "A") {
      var c2 = vec3_exports.fromValues(cur[6], cur[7], 0);
      if (transform2) {
        vec3_exports.transformMat4(c2, c2, transform2);
      }
      path = "".concat(cur[0]).concat(cur[1], ",").concat(cur[2], ",").concat(cur[3], ",").concat(cur[4], ",").concat(cur[5], ",").concat(c2[0], ",").concat(c2[1]);
    } else if (cur[0] === "Q") {
      var _p = vec3_exports.fromValues(cur[1], cur[2], 0);
      var _p2 = vec3_exports.fromValues(cur[3], cur[4], 0);
      if (transform2) {
        vec3_exports.transformMat4(_p, _p, transform2);
        vec3_exports.transformMat4(_p2, _p2, transform2);
      }
      path = "".concat(cur[0]).concat(cur[1], ",").concat(cur[2], ",").concat(cur[3], ",").concat(cur[4], "}");
    }
    return prev += path;
  }, "");
}
function lineToCommands(x1, y1, x22, y22) {
  return [["M", x1, y1], ["L", x22, y22]];
}
function ellipseToCommands(rx, ry, cx, cy) {
  var factor = (-1 + Math.sqrt(2)) / 3 * 4;
  var dx = rx * factor;
  var dy = ry * factor;
  var left = cx - rx;
  var right = cx + rx;
  var top = cy - ry;
  var bottom = cy + ry;
  return [["M", left, cy], ["C", left, cy - dy, cx - dx, top, cx, top], ["C", cx + dx, top, right, cy - dy, right, cy], ["C", right, cy + dy, cx + dx, bottom, cx, bottom], ["C", cx - dx, bottom, left, cy + dy, left, cy], ["Z"]];
}
function polygonToCommands(points, closed) {
  var result = points.map(function(point2, i) {
    return [i === 0 ? "M" : "L", point2[0], point2[1]];
  });
  if (closed) {
    result.push(["Z"]);
  }
  return result;
}
function rectToCommands(width, height, x3, y3, radius) {
  if (radius) {
    var _radius = _slicedToArray(radius, 4), tlr = _radius[0], trr = _radius[1], brr = _radius[2], blr = _radius[3];
    var signX = width > 0 ? 1 : -1;
    var signY = height > 0 ? 1 : -1;
    var sweepFlag = signX + signY !== 0 ? 1 : 0;
    return [["M", signX * tlr + x3, y3], ["L", width - signX * trr + x3, y3], trr ? ["A", trr, trr, 0, 0, sweepFlag, width + x3, signY * trr + y3] : null, ["L", width + x3, height - signY * brr + y3], brr ? ["A", brr, brr, 0, 0, sweepFlag, width + x3 - signX * brr, height + y3] : null, ["L", x3 + signX * blr, height + y3], blr ? ["A", blr, blr, 0, 0, sweepFlag, x3, height + y3 - signY * blr] : null, ["L", x3, signY * tlr + y3], tlr ? ["A", tlr, tlr, 0, 0, sweepFlag, signX * tlr + x3, y3] : null, ["Z"]].filter(function(command) {
      return command;
    });
  }
  return [["M", x3, y3], ["L", x3 + width, y3], ["L", x3 + width, y3 + height], ["L", x3, y3 + height], ["Z"]];
}
function convertToPath(object) {
  var transform2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : object.getLocalTransform();
  var commands = [];
  switch (object.nodeName) {
    case Shape.LINE:
      var _parsedStyle = object.parsedStyle, _parsedStyle$x = _parsedStyle.x1, x1 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = _parsedStyle.y1, y1 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, _parsedStyle$x2 = _parsedStyle.x2, x22 = _parsedStyle$x2 === void 0 ? 0 : _parsedStyle$x2, _parsedStyle$y2 = _parsedStyle.y2, y22 = _parsedStyle$y2 === void 0 ? 0 : _parsedStyle$y2;
      commands = lineToCommands(x1, y1, x22, y22);
      break;
    case Shape.CIRCLE: {
      var _parsedStyle2 = object.parsedStyle, _parsedStyle2$r = _parsedStyle2.r, r = _parsedStyle2$r === void 0 ? 0 : _parsedStyle2$r, _parsedStyle2$cx = _parsedStyle2.cx, cx = _parsedStyle2$cx === void 0 ? 0 : _parsedStyle2$cx, _parsedStyle2$cy = _parsedStyle2.cy, cy = _parsedStyle2$cy === void 0 ? 0 : _parsedStyle2$cy;
      commands = ellipseToCommands(r, r, cx, cy);
      break;
    }
    case Shape.ELLIPSE: {
      var _parsedStyle3 = object.parsedStyle, _parsedStyle3$rx = _parsedStyle3.rx, rx = _parsedStyle3$rx === void 0 ? 0 : _parsedStyle3$rx, _parsedStyle3$ry = _parsedStyle3.ry, ry = _parsedStyle3$ry === void 0 ? 0 : _parsedStyle3$ry, _parsedStyle3$cx = _parsedStyle3.cx, _cx = _parsedStyle3$cx === void 0 ? 0 : _parsedStyle3$cx, _parsedStyle3$cy = _parsedStyle3.cy, _cy = _parsedStyle3$cy === void 0 ? 0 : _parsedStyle3$cy;
      commands = ellipseToCommands(rx, ry, _cx, _cy);
      break;
    }
    case Shape.POLYLINE:
    case Shape.POLYGON:
      var points = object.parsedStyle.points;
      commands = polygonToCommands(points.points, object.nodeName === Shape.POLYGON);
      break;
    case Shape.RECT:
      var _parsedStyle4 = object.parsedStyle, _parsedStyle4$width = _parsedStyle4.width, width = _parsedStyle4$width === void 0 ? 0 : _parsedStyle4$width, _parsedStyle4$height = _parsedStyle4.height, height = _parsedStyle4$height === void 0 ? 0 : _parsedStyle4$height, _parsedStyle4$x = _parsedStyle4.x, x3 = _parsedStyle4$x === void 0 ? 0 : _parsedStyle4$x, _parsedStyle4$y = _parsedStyle4.y, y3 = _parsedStyle4$y === void 0 ? 0 : _parsedStyle4$y, radius = _parsedStyle4.radius;
      var hasRadius = radius && radius.some(function(r2) {
        return r2 !== 0;
      });
      commands = rectToCommands(width, height, x3, y3, hasRadius && radius.map(function(r2) {
        return clamp_default(r2, 0, Math.min(Math.abs(width) / 2, Math.abs(height) / 2));
      }));
      break;
    case Shape.PATH:
      var absolutePath = object.parsedStyle.d.absolutePath;
      commands = _toConsumableArray(absolutePath);
      break;
  }
  if (commands.length) {
    return commandsToPathString(commands, object, transform2);
  }
}
var internalParsePath = function internalParsePath2(path) {
  if (path === "" || Array.isArray(path) && path.length === 0) {
    return {
      absolutePath: [],
      hasArc: false,
      segments: [],
      polygons: [],
      polylines: [],
      curve: null,
      totalLength: 0,
      rect: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }
    };
  }
  var absolutePath;
  try {
    absolutePath = normalizePath(path);
  } catch (_unused) {
    absolutePath = normalizePath("");
    console.error("[g]: Invalid SVG Path definition: ".concat(path));
  }
  removeRedundantMCommand(absolutePath);
  var hasArc = hasArcOrBezier(absolutePath);
  var _extractPolygons = extractPolygons(absolutePath), polygons = _extractPolygons.polygons, polylines = _extractPolygons.polylines;
  var segments = path2Segments(absolutePath);
  var _getPathBBox = getPathBBox2(segments, 0), x3 = _getPathBBox.x, y3 = _getPathBBox.y, width = _getPathBBox.width, height = _getPathBBox.height;
  return {
    absolutePath,
    hasArc,
    segments,
    polygons,
    polylines,
    // curve,
    // Delay the calculation of length.
    totalLength: 0,
    rect: {
      x: Number.isFinite(x3) ? x3 : 0,
      y: Number.isFinite(y3) ? y3 : 0,
      width: Number.isFinite(width) ? width : 0,
      height: Number.isFinite(height) ? height : 0
    }
  };
};
var memoizedParsePath = memoize2(internalParsePath);
function parsePath(path) {
  return isString(path) ? memoizedParsePath(path) : internalParsePath(path);
}
function mergePaths(left, right, object) {
  var curve1 = left.curve;
  var curve2 = right.curve;
  if (!curve1 || curve1.length === 0) {
    curve1 = path2Curve(left.absolutePath, false);
    left.curve = curve1;
  }
  if (!curve2 || curve2.length === 0) {
    curve2 = path2Curve(right.absolutePath, false);
    right.curve = curve2;
  }
  var curves = [curve1, curve2];
  if (curve1.length !== curve2.length) {
    curves = equalizeSegments(curve1, curve2);
  }
  var curve0 = getDrawDirection(curves[0]) !== getDrawDirection(curves[1]) ? reverseCurve(curves[0]) : clonePath(curves[0]);
  return [curve0, getRotatedCurve(curves[1], curve0), function(pathArray) {
    return pathArray;
  }];
}
function parsePoints(pointsOrStr, object) {
  var points;
  if (isString(pointsOrStr)) {
    points = pointsOrStr.split(" ").map(function(pointStr) {
      var _pointStr$split = pointStr.split(","), _pointStr$split2 = _slicedToArray(_pointStr$split, 2), x3 = _pointStr$split2[0], y3 = _pointStr$split2[1];
      return [Number(x3), Number(y3)];
    });
  } else {
    points = pointsOrStr;
  }
  return {
    points,
    totalLength: 0,
    segments: []
  };
}
function mergePoints(left, right) {
  return [left.points, right.points, function(points) {
    return points;
  }];
}
var _ = null;
var TRANSFORM_REGEXP = /\s*(\w+)\(([^)]*)\)/g;
function cast(pattern) {
  return function(contents) {
    var i = 0;
    return pattern.map(function(x3) {
      return x3 === _ ? contents[i++] : x3;
    });
  };
}
function id(x3) {
  return x3;
}
var transformFunctions = {
  // @ts-ignore
  matrix: ["NNNNNN", [_, _, 0, 0, _, _, 0, 0, 0, 0, 1, 0, _, _, 0, 1], id],
  matrix3d: ["NNNNNNNNNNNNNNNN", id],
  rotate: ["A"],
  rotateX: ["A"],
  rotateY: ["A"],
  rotateZ: ["A"],
  rotate3d: ["NNNA"],
  perspective: ["L"],
  scale: ["Nn", cast([_, _, new CSSUnitValue(1)]), id],
  scaleX: ["N", cast([_, new CSSUnitValue(1), new CSSUnitValue(1)]), cast([_, new CSSUnitValue(1)])],
  scaleY: ["N", cast([new CSSUnitValue(1), _, new CSSUnitValue(1)]), cast([new CSSUnitValue(1), _])],
  scaleZ: ["N", cast([new CSSUnitValue(1), new CSSUnitValue(1), _])],
  scale3d: ["NNN", id],
  skew: ["Aa", null, id],
  skewX: ["A", null, cast([_, Odeg])],
  skewY: ["A", null, cast([Odeg, _])],
  translate: ["Tt", cast([_, _, Opx]), id],
  translateX: ["T", cast([_, Opx, Opx]), cast([_, Opx])],
  translateY: ["T", cast([Opx, _, Opx]), cast([Opx, _])],
  translateZ: ["L", cast([Opx, Opx, _])],
  translate3d: ["TTL", id]
};
function parseArrayTransform(transform2) {
  var result = [];
  var length5 = transform2.length;
  for (var i = 0; i < length5; i++) {
    var item = transform2[i];
    var name = item[0];
    var args = item.slice(1);
    if (name === "translate" || name === "skew") {
      if (args.length === 1) args.push(0);
    } else if (name === "scale") {
      if (args.length === 1) args.push(args[0]);
    }
    var functionData = transformFunctions[name];
    if (!functionData) return [];
    var parsedArgs = args.map(function(value) {
      return getOrCreateUnitValue(value);
    });
    result.push({
      t: name,
      d: parsedArgs
    });
  }
  return result;
}
function parseTransform(transform2) {
  if (Array.isArray(transform2)) {
    return parseArrayTransform(transform2);
  }
  transform2 = (transform2 || "none").trim();
  if (transform2 === "none") {
    return [];
  }
  var result = [];
  var match;
  var prevLastIndex = 0;
  TRANSFORM_REGEXP.lastIndex = 0;
  while (match = TRANSFORM_REGEXP.exec(transform2)) {
    if (match.index !== prevLastIndex) {
      return [];
    }
    prevLastIndex = match.index + match[0].length;
    var functionName = match[1];
    var functionData = transformFunctions[functionName];
    if (!functionData) {
      return [];
    }
    var args = match[2].split(",");
    var argTypes = functionData[0];
    if (argTypes.length < args.length) {
      return [];
    }
    var parsedArgs = [];
    for (var i = 0; i < argTypes.length; i++) {
      var arg = args[i];
      var type = argTypes[i];
      var parsedArg = void 0;
      if (!arg) {
        parsedArg = {
          a: Odeg,
          n: parsedArgs[0],
          t: Opx
        }[type];
      } else {
        parsedArg = {
          A: function A3(s2) {
            return s2.trim() === "0" ? Odeg : parseAngle(s2);
          },
          N: parseNumber,
          T: parseLengthOrPercentage,
          L: parseLength
        }[type.toUpperCase()](arg);
      }
      if (parsedArg === void 0) {
        return [];
      }
      parsedArgs.push(parsedArg);
    }
    result.push({
      t: functionName,
      d: parsedArgs
    });
    if (TRANSFORM_REGEXP.lastIndex === transform2.length) {
      return result;
    }
  }
  return [];
}
function parseTransformUnmemoize(transform2) {
  if (Array.isArray(transform2)) {
    return parseArrayTransform(transform2);
  }
  transform2 = (transform2 || "none").trim();
  if (transform2 === "none") {
    return [];
  }
  var result = [];
  var match;
  var prevLastIndex = 0;
  TRANSFORM_REGEXP.lastIndex = 0;
  while (match = TRANSFORM_REGEXP.exec(transform2)) {
    if (match.index !== prevLastIndex) {
      return [];
    }
    prevLastIndex = match.index + match[0].length;
    var functionName = match[1];
    var functionData = transformFunctions[functionName];
    if (!functionData) {
      return [];
    }
    var args = match[2].split(",");
    var argTypes = functionData[0];
    if (argTypes.length < args.length) {
      return [];
    }
    var parsedArgs = [];
    for (var i = 0; i < argTypes.length; i++) {
      var arg = args[i];
      var type = argTypes[i];
      var parsedArg = void 0;
      if (!arg) {
        parsedArg = {
          a: Odeg,
          n: parsedArgs[0],
          t: Opx
        }[type];
      } else {
        parsedArg = {
          A: function A3(s2) {
            return s2.trim() === "0" ? Odeg : parseAngleUnmemoize(s2);
          },
          N: parseNumberUnmemoize,
          T: parseLengthOrPercentageUnmemoize,
          L: parseLengthUnmemoize
        }[type.toUpperCase()](arg);
      }
      if (parsedArg === void 0) {
        return [];
      }
      parsedArgs.push(parsedArg);
    }
    result.push({
      t: functionName,
      d: parsedArgs
    });
    if (TRANSFORM_REGEXP.lastIndex === transform2.length) {
      return result;
    }
  }
  return [];
}
function convertItemToMatrix(item) {
  var x3;
  var y3;
  var z;
  var angle3;
  switch (item.t) {
    case "rotateX":
      angle3 = deg2rad(convertAngleUnit(item.d[0]));
      return [1, 0, 0, 0, 0, Math.cos(angle3), Math.sin(angle3), 0, 0, -Math.sin(angle3), Math.cos(angle3), 0, 0, 0, 0, 1];
    case "rotateY":
      angle3 = deg2rad(convertAngleUnit(item.d[0]));
      return [Math.cos(angle3), 0, -Math.sin(angle3), 0, 0, 1, 0, 0, Math.sin(angle3), 0, Math.cos(angle3), 0, 0, 0, 0, 1];
    case "rotate":
    case "rotateZ":
      angle3 = deg2rad(convertAngleUnit(item.d[0]));
      return [Math.cos(angle3), Math.sin(angle3), 0, 0, -Math.sin(angle3), Math.cos(angle3), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "rotate3d":
      x3 = item.d[0].value;
      y3 = item.d[1].value;
      z = item.d[2].value;
      angle3 = deg2rad(convertAngleUnit(item.d[3]));
      var sqrLength = x3 * x3 + y3 * y3 + z * z;
      if (sqrLength === 0) {
        x3 = 1;
        y3 = 0;
        z = 0;
      } else if (sqrLength !== 1) {
        var length5 = Math.sqrt(sqrLength);
        x3 /= length5;
        y3 /= length5;
        z /= length5;
      }
      var s2 = Math.sin(angle3 / 2);
      var sc = s2 * Math.cos(angle3 / 2);
      var sq = s2 * s2;
      return [1 - 2 * (y3 * y3 + z * z) * sq, 2 * (x3 * y3 * sq + z * sc), 2 * (x3 * z * sq - y3 * sc), 0, 2 * (x3 * y3 * sq - z * sc), 1 - 2 * (x3 * x3 + z * z) * sq, 2 * (y3 * z * sq + x3 * sc), 0, 2 * (x3 * z * sq + y3 * sc), 2 * (y3 * z * sq - x3 * sc), 1 - 2 * (x3 * x3 + y3 * y3) * sq, 0, 0, 0, 0, 1];
    case "scale":
      return [item.d[0].value, 0, 0, 0, 0, item.d[1].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "scaleX":
      return [item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "scaleY":
      return [1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "scaleZ":
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1];
    case "scale3d":
      return [item.d[0].value, 0, 0, 0, 0, item.d[1].value, 0, 0, 0, 0, item.d[2].value, 0, 0, 0, 0, 1];
    case "skew":
      var xAngle = deg2rad(convertAngleUnit(item.d[0]));
      var yAngle = deg2rad(convertAngleUnit(item.d[1]));
      return [1, Math.tan(yAngle), 0, 0, Math.tan(xAngle), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "skewX":
      angle3 = deg2rad(convertAngleUnit(item.d[0]));
      return [1, 0, 0, 0, Math.tan(angle3), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "skewY":
      angle3 = deg2rad(convertAngleUnit(item.d[0]));
      return [1, Math.tan(angle3), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "translate":
      x3 = convertPercentUnit(item.d[0], 0, null) || 0;
      y3 = convertPercentUnit(item.d[1], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x3, y3, 0, 1];
    case "translateX":
      x3 = convertPercentUnit(item.d[0], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x3, 0, 0, 1];
    case "translateY":
      y3 = convertPercentUnit(item.d[0], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, y3, 0, 1];
    case "translateZ":
      z = convertPercentUnit(item.d[0], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, z, 1];
    case "translate3d":
      x3 = convertPercentUnit(item.d[0], 0, null) || 0;
      y3 = convertPercentUnit(item.d[1], 0, null) || 0;
      z = convertPercentUnit(item.d[2], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x3, y3, z, 1];
    case "perspective":
      var t = convertPercentUnit(item.d[0], 0, null) || 0;
      var p = t ? -1 / t : 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, p, 0, 0, 0, 1];
    case "matrix":
      return [item.d[0].value, item.d[1].value, 0, 0, item.d[2].value, item.d[3].value, 0, 0, 0, 0, 1, 0, item.d[4].value, item.d[5].value, 0, 1];
    case "matrix3d":
      return item.d.map(function(d2) {
        return d2.value;
      });
  }
}
function multiplyMatrices(a2, b) {
  return [a2[0] * b[0] + a2[4] * b[1] + a2[8] * b[2] + a2[12] * b[3], a2[1] * b[0] + a2[5] * b[1] + a2[9] * b[2] + a2[13] * b[3], a2[2] * b[0] + a2[6] * b[1] + a2[10] * b[2] + a2[14] * b[3], a2[3] * b[0] + a2[7] * b[1] + a2[11] * b[2] + a2[15] * b[3], a2[0] * b[4] + a2[4] * b[5] + a2[8] * b[6] + a2[12] * b[7], a2[1] * b[4] + a2[5] * b[5] + a2[9] * b[6] + a2[13] * b[7], a2[2] * b[4] + a2[6] * b[5] + a2[10] * b[6] + a2[14] * b[7], a2[3] * b[4] + a2[7] * b[5] + a2[11] * b[6] + a2[15] * b[7], a2[0] * b[8] + a2[4] * b[9] + a2[8] * b[10] + a2[12] * b[11], a2[1] * b[8] + a2[5] * b[9] + a2[9] * b[10] + a2[13] * b[11], a2[2] * b[8] + a2[6] * b[9] + a2[10] * b[10] + a2[14] * b[11], a2[3] * b[8] + a2[7] * b[9] + a2[11] * b[10] + a2[15] * b[11], a2[0] * b[12] + a2[4] * b[13] + a2[8] * b[14] + a2[12] * b[15], a2[1] * b[12] + a2[5] * b[13] + a2[9] * b[14] + a2[13] * b[15], a2[2] * b[12] + a2[6] * b[13] + a2[10] * b[14] + a2[14] * b[15], a2[3] * b[12] + a2[7] * b[13] + a2[11] * b[14] + a2[15] * b[15]];
}
function convertToMatrix(transformList) {
  if (transformList.length === 0) {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  return transformList.map(convertItemToMatrix).reduce(multiplyMatrices);
}
function makeMatrixDecomposition(transformList) {
  var translate5 = [0, 0, 0];
  var scale9 = [1, 1, 1];
  var skew2 = [0, 0, 0];
  var perspective2 = [0, 0, 0, 1];
  var quaternion = [0, 0, 0, 1];
  decomposeMat4(
    // @ts-ignore
    convertToMatrix(transformList),
    translate5,
    scale9,
    skew2,
    perspective2,
    quaternion
  );
  return [[translate5, scale9, skew2, quaternion, perspective2]];
}
var composeMatrix = /* @__PURE__ */ function() {
  function multiply7(a2, b) {
    var result = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];
    for (var i = 0; i < 4; i++) {
      for (var j = 0; j < 4; j++) {
        for (var k = 0; k < 4; k++) {
          result[i][j] += b[i][k] * a2[k][j];
        }
      }
    }
    return result;
  }
  function is2D(m2) {
    return m2[0][2] === 0 && m2[0][3] === 0 && m2[1][2] === 0 && m2[1][3] === 0 && m2[2][0] === 0 && m2[2][1] === 0 && m2[2][2] === 1 && m2[2][3] === 0 && m2[3][2] === 0 && m2[3][3] === 1;
  }
  function composeMatrix2(translate5, scale9, skew2, quat2, perspective2) {
    var matrix2 = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    for (var i = 0; i < 4; i++) {
      matrix2[i][3] = perspective2[i];
    }
    for (var _i = 0; _i < 3; _i++) {
      for (var j = 0; j < 3; j++) {
        matrix2[3][_i] += translate5[j] * matrix2[j][_i];
      }
    }
    var x3 = quat2[0];
    var y3 = quat2[1];
    var z = quat2[2];
    var w = quat2[3];
    var rotMatrix = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    rotMatrix[0][0] = 1 - 2 * (y3 * y3 + z * z);
    rotMatrix[0][1] = 2 * (x3 * y3 - z * w);
    rotMatrix[0][2] = 2 * (x3 * z + y3 * w);
    rotMatrix[1][0] = 2 * (x3 * y3 + z * w);
    rotMatrix[1][1] = 1 - 2 * (x3 * x3 + z * z);
    rotMatrix[1][2] = 2 * (y3 * z - x3 * w);
    rotMatrix[2][0] = 2 * (x3 * z - y3 * w);
    rotMatrix[2][1] = 2 * (y3 * z + x3 * w);
    rotMatrix[2][2] = 1 - 2 * (x3 * x3 + y3 * y3);
    matrix2 = multiply7(matrix2, rotMatrix);
    var temp = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    if (skew2[2]) {
      temp[2][1] = skew2[2];
      matrix2 = multiply7(matrix2, temp);
    }
    if (skew2[1]) {
      temp[2][1] = 0;
      temp[2][0] = skew2[0];
      matrix2 = multiply7(matrix2, temp);
    }
    if (skew2[0]) {
      temp[2][0] = 0;
      temp[1][0] = skew2[0];
      matrix2 = multiply7(matrix2, temp);
    }
    for (var _i2 = 0; _i2 < 3; _i2++) {
      for (var _j = 0; _j < 3; _j++) {
        matrix2[_i2][_j] *= scale9[_i2];
      }
    }
    if (is2D(matrix2)) {
      return [matrix2[0][0], matrix2[0][1], matrix2[1][0], matrix2[1][1], matrix2[3][0], matrix2[3][1]];
    }
    return matrix2[0].concat(matrix2[1], matrix2[2], matrix2[3]);
  }
  return composeMatrix2;
}();
function numberToLongString(x3) {
  return x3.toFixed(6).replace(".000000", "");
}
function mergeMatrices(left, right) {
  var leftArgs;
  var rightArgs;
  if (left.decompositionPair !== right) {
    left.decompositionPair = right;
    leftArgs = makeMatrixDecomposition(left);
  }
  if (right.decompositionPair !== left) {
    right.decompositionPair = left;
    rightArgs = makeMatrixDecomposition(right);
  }
  if (leftArgs[0] === null || rightArgs[0] === null) return [
    // @ts-ignore
    [false],
    // @ts-ignore
    [true],
    // @ts-ignore
    function(x3) {
      return x3 ? right[0].d : left[0].d;
    }
  ];
  leftArgs[0].push(0);
  rightArgs[0].push(1);
  return [
    leftArgs,
    rightArgs,
    // @ts-ignore
    function(list) {
      var q = quat(leftArgs[0][3], rightArgs[0][3], list[5]);
      var mat = composeMatrix(list[0], list[1], list[2], q, list[4]);
      var stringifiedArgs = mat.map(numberToLongString).join(",");
      return stringifiedArgs;
    }
  ];
}
function dot5(v1, v2) {
  var result = 0;
  for (var i = 0; i < v1.length; i++) {
    result += v1[i] * v2[i];
  }
  return result;
}
function quat(fromQ, toQ, f) {
  var product = dot5(fromQ, toQ);
  product = clamp_default(product, -1, 1);
  var quat2 = [];
  if (product === 1) {
    quat2 = fromQ;
  } else {
    var theta = Math.acos(product);
    var w = Math.sin(f * theta) * 1 / Math.sqrt(1 - product * product);
    for (var i = 0; i < 4; i++) {
      quat2.push(fromQ[i] * (Math.cos(f * theta) - product * w) + toQ[i] * w);
    }
  }
  return quat2;
}
function typeTo2D(type) {
  return type.replace(/[XY]/, "");
}
function typeTo3D(type) {
  return type.replace(/(X|Y|Z|3d)?$/, "3d");
}
var isMatrixOrPerspective = function isMatrixOrPerspective2(lt, rt) {
  return lt === "perspective" && rt === "perspective" || (lt === "matrix" || lt === "matrix3d") && (rt === "matrix" || rt === "matrix3d");
};
function mergeTransforms(left, right, target) {
  var flipResults = false;
  if (!left.length || !right.length) {
    if (!left.length) {
      flipResults = true;
      left = right;
      right = [];
    }
    var _loop = function _loop2() {
      var _left$i = left[i], type2 = _left$i.t, args = _left$i.d;
      var defaultValue = type2.substring(0, 5) === "scale" ? 1 : 0;
      right.push({
        t: type2,
        d: args.map(function(arg) {
          if (typeof arg === "number") {
            return getOrCreateUnitValue(defaultValue);
          }
          return getOrCreateUnitValue(defaultValue, arg.unit);
        })
      });
    };
    for (var i = 0; i < left.length; i++) {
      _loop();
    }
  }
  var leftResult = [];
  var rightResult = [];
  var types = [];
  if (left.length !== right.length) {
    var merged = mergeMatrices(left, right);
    leftResult = [merged[0]];
    rightResult = [merged[1]];
    types = [["matrix", [merged[2]]]];
  } else {
    for (var _i3 = 0; _i3 < left.length; _i3++) {
      var leftType = left[_i3].t;
      var rightType = right[_i3].t;
      var leftArgs = left[_i3].d;
      var rightArgs = right[_i3].d;
      var leftFunctionData = transformFunctions[leftType];
      var rightFunctionData = transformFunctions[rightType];
      var type = void 0;
      if (isMatrixOrPerspective(leftType, rightType)) {
        var _merged = mergeMatrices([left[_i3]], [right[_i3]]);
        leftResult.push(_merged[0]);
        rightResult.push(_merged[1]);
        types.push(["matrix", [_merged[2]]]);
        continue;
      } else if (leftType === rightType) {
        type = leftType;
      } else if (leftFunctionData[2] && rightFunctionData[2] && typeTo2D(leftType) === typeTo2D(rightType)) {
        type = typeTo2D(leftType);
        leftArgs = leftFunctionData[2](leftArgs);
        rightArgs = rightFunctionData[2](rightArgs);
      } else if (leftFunctionData[1] && rightFunctionData[1] && typeTo3D(leftType) === typeTo3D(rightType)) {
        type = typeTo3D(leftType);
        leftArgs = leftFunctionData[1](leftArgs);
        rightArgs = rightFunctionData[1](rightArgs);
      } else {
        var _merged2 = mergeMatrices(left, right);
        leftResult = [_merged2[0]];
        rightResult = [_merged2[1]];
        types = [["matrix", [_merged2[2]]]];
        break;
      }
      var leftArgsCopy = [];
      var rightArgsCopy = [];
      var stringConversions = [];
      for (var j = 0; j < leftArgs.length; j++) {
        var _merged3 = mergeDimensions(leftArgs[j], rightArgs[j], target, false, j);
        leftArgsCopy[j] = _merged3[0];
        rightArgsCopy[j] = _merged3[1];
        stringConversions.push(_merged3[2]);
      }
      leftResult.push(leftArgsCopy);
      rightResult.push(rightArgsCopy);
      types.push([type, stringConversions]);
    }
  }
  if (flipResults) {
    var tmp2 = leftResult;
    leftResult = rightResult;
    rightResult = tmp2;
  }
  return [leftResult, rightResult, function(list) {
    return list.map(function(args, i2) {
      var stringifiedArgs = args.map(function(arg, j2) {
        return types[i2][1][j2](arg);
      }).join(",");
      if (types[i2][0] === "matrix" && stringifiedArgs.split(",").length === 16) {
        types[i2][0] = "matrix3d";
      }
      if (types[i2][0] === "matrix3d" && stringifiedArgs.split(",").length === 6) {
        types[i2][0] = "matrix";
      }
      return "".concat(types[i2][0], "(").concat(stringifiedArgs, ")");
    }).join(" ");
  }];
}
var parseTransformOrigin = memoize2(function(value) {
  if (isString(value)) {
    if (value === "text-anchor") {
      return [getOrCreateUnitValue(0, "px"), getOrCreateUnitValue(0, "px")];
    }
    var values = value.split(" ");
    if (values.length === 1) {
      if (values[0] === "top" || values[0] === "bottom") {
        values[1] = values[0];
        values[0] = "center";
      } else {
        values[1] = "center";
      }
    }
    if (values.length !== 2) {
      return null;
    }
    return [parseLengthOrPercentage(convertKeyword2Percent(values[0])), parseLengthOrPercentage(convertKeyword2Percent(values[1]))];
  }
  return [getOrCreateUnitValue(value[0] || 0, "px"), getOrCreateUnitValue(value[1] || 0, "px")];
});
function convertKeyword2Percent(keyword) {
  if (keyword === "center") {
    return "50%";
  }
  if (keyword === "left" || keyword === "top") {
    return "0%";
  }
  if (keyword === "right" || keyword === "bottom") {
    return "100%";
  }
  return keyword;
}
var BUILT_IN_PROPERTIES = [
  {
    /**
     * used in CSS Layout API
     * eg. `display: 'flex'`
     */
    n: "display",
    k: ["none"]
  },
  {
    /**
     * range [0.0, 1.0]
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/opacity
     */
    n: "opacity",
    "int": true,
    inh: true,
    d: "1",
    syntax: PropertySyntax.OPACITY_VALUE
  },
  {
    /**
     * inheritable, range [0.0, 1.0]
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-opacity
     * @see https://svgwg.org/svg2-draft/painting.html#FillOpacity
     */
    n: "fillOpacity",
    "int": true,
    inh: true,
    d: "1",
    syntax: PropertySyntax.OPACITY_VALUE
  },
  {
    /**
     * inheritable, range [0.0, 1.0]
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-opacity
     * @see https://svgwg.org/svg2-draft/painting.html#StrokeOpacity
     */
    n: "strokeOpacity",
    "int": true,
    inh: true,
    d: "1",
    syntax: PropertySyntax.OPACITY_VALUE
  },
  {
    /**
     * background-color is not inheritable
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes
     */
    n: "fill",
    "int": true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.PAINT
  },
  {
    n: "fillRule",
    k: ["nonzero", "evenodd"],
    d: "nonzero"
  },
  /**
   * default to none
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke#usage_notes
   */
  {
    n: "stroke",
    "int": true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.PAINT,
    /**
     * Stroke 'none' won't affect geometry but others will.
     */
    l: true
  },
  {
    n: "shadowType",
    k: ["inner", "outer", "both"],
    d: "outer",
    l: true
  },
  {
    n: "shadowColor",
    "int": true,
    syntax: PropertySyntax.COLOR
  },
  {
    n: "shadowOffsetX",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "shadowOffsetY",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "shadowBlur",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.SHADOW_BLUR
  },
  {
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-width
     */
    n: "lineWidth",
    "int": true,
    inh: true,
    d: "1",
    l: true,
    a: ["strokeWidth"],
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "increasedLineWidthForHitTesting",
    inh: true,
    d: "0",
    l: true,
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "lineJoin",
    inh: true,
    l: true,
    a: ["strokeLinejoin"],
    k: ["miter", "bevel", "round"],
    d: "miter"
  },
  {
    n: "lineCap",
    inh: true,
    l: true,
    a: ["strokeLinecap"],
    k: ["butt", "round", "square"],
    d: "butt"
  },
  {
    n: "lineDash",
    "int": true,
    inh: true,
    k: ["none"],
    a: ["strokeDasharray"],
    syntax: PropertySyntax.LENGTH_PERCENTAGE_12
  },
  {
    n: "lineDashOffset",
    "int": true,
    inh: true,
    d: "0",
    a: ["strokeDashoffset"],
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "offsetPath",
    syntax: PropertySyntax.DEFINED_PATH
  },
  {
    n: "offsetDistance",
    "int": true,
    syntax: PropertySyntax.OFFSET_DISTANCE
  },
  {
    n: "dx",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "dy",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "zIndex",
    ind: true,
    "int": true,
    d: "0",
    k: ["auto"],
    syntax: PropertySyntax.Z_INDEX
  },
  {
    n: "visibility",
    k: ["visible", "hidden"],
    ind: true,
    inh: true,
    /**
     * support interpolation
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/visibility#interpolation
     */
    "int": true,
    d: "visible"
  },
  {
    n: "pointerEvents",
    inh: true,
    k: [
      "none",
      "auto",
      "stroke",
      "fill",
      "painted",
      "visible",
      "visiblestroke",
      "visiblefill",
      "visiblepainted",
      // 'bounding-box',
      "all"
    ],
    d: "auto"
  },
  {
    n: "filter",
    ind: true,
    l: true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.FILTER
  },
  {
    n: "clipPath",
    syntax: PropertySyntax.DEFINED_PATH
  },
  {
    n: "textPath",
    syntax: PropertySyntax.DEFINED_PATH
  },
  {
    n: "textPathSide",
    k: ["left", "right"],
    d: "left"
  },
  {
    n: "textPathStartOffset",
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "transform",
    p: 100,
    "int": true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.TRANSFORM
  },
  {
    n: "transformOrigin",
    p: 100,
    d: "0 0",
    // // int: true,
    // d: (nodeName: string) => {
    //   if (nodeName === Shape.CIRCLE || nodeName === Shape.ELLIPSE) {
    //     return 'center';
    //   }
    //   if (nodeName === Shape.TEXT) {
    //     return 'text-anchor';
    //   }
    //   return 'left top';
    // },
    l: true,
    syntax: PropertySyntax.TRANSFORM_ORIGIN
  },
  {
    n: "cx",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "cy",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "cz",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "r",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "rx",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "ry",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  // Rect Image Group
  {
    // x in local space
    n: "x",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    // y in local space
    n: "y",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    // z in local space
    n: "z",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "width",
    "int": true,
    l: true,
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/width
     */
    k: ["auto", "fit-content", "min-content", "max-content"],
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "height",
    "int": true,
    l: true,
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/height
     */
    k: ["auto", "fit-content", "min-content", "max-content"],
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "radius",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE_14
  },
  // Line
  {
    n: "x1",
    "int": true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "y1",
    "int": true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "z1",
    "int": true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "x2",
    "int": true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "y2",
    "int": true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "z2",
    "int": true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  // Path
  {
    n: "d",
    "int": true,
    l: true,
    d: "",
    syntax: PropertySyntax.PATH,
    p: 50
  },
  // Polyline & Polygon
  {
    n: "points",
    /**
     * support interpolation
     */
    "int": true,
    l: true,
    syntax: PropertySyntax.LIST_OF_POINTS,
    p: 50
  },
  // Text
  {
    n: "text",
    l: true,
    d: "",
    syntax: PropertySyntax.TEXT,
    p: 50
  },
  {
    n: "textTransform",
    l: true,
    inh: true,
    k: ["capitalize", "uppercase", "lowercase", "none"],
    d: "none",
    syntax: PropertySyntax.TEXT_TRANSFORM,
    p: 51
    // it must get parsed after text
  },
  {
    n: "font",
    l: true
  },
  {
    n: "fontSize",
    "int": true,
    inh: true,
    /**
     * @see https://www.w3schools.com/css/css_font_size.asp
     */
    d: "16px",
    l: true,
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "fontFamily",
    l: true,
    inh: true,
    d: "sans-serif"
  },
  {
    n: "fontStyle",
    l: true,
    inh: true,
    k: ["normal", "italic", "oblique"],
    d: "normal"
  },
  {
    n: "fontWeight",
    l: true,
    inh: true,
    k: ["normal", "bold", "bolder", "lighter"],
    d: "normal"
  },
  {
    n: "fontVariant",
    l: true,
    inh: true,
    k: ["normal", "small-caps"],
    d: "normal"
  },
  {
    n: "lineHeight",
    l: true,
    syntax: PropertySyntax.LENGTH,
    "int": true,
    d: "0"
  },
  {
    n: "letterSpacing",
    l: true,
    syntax: PropertySyntax.LENGTH,
    "int": true,
    d: "0"
  },
  {
    n: "miterLimit",
    l: true,
    syntax: PropertySyntax.NUMBER,
    d: function d(nodeName) {
      if (nodeName === Shape.PATH || nodeName === Shape.POLYGON || nodeName === Shape.POLYLINE) {
        return "4";
      }
      return "10";
    }
  },
  {
    n: "wordWrap",
    l: true
  },
  {
    n: "wordWrapWidth",
    l: true
  },
  {
    n: "maxLines",
    l: true
  },
  {
    n: "textOverflow",
    l: true,
    d: "clip"
  },
  {
    n: "leading",
    l: true
  },
  {
    n: "textBaseline",
    l: true,
    inh: true,
    k: ["top", "hanging", "middle", "alphabetic", "ideographic", "bottom"],
    d: "alphabetic"
  },
  {
    n: "textAlign",
    l: true,
    inh: true,
    k: ["start", "center", "middle", "end", "left", "right"],
    d: "start"
  },
  // {
  //   n: 'whiteSpace',
  //   l: true,
  // },
  {
    n: "markerStart",
    syntax: PropertySyntax.MARKER
  },
  {
    n: "markerEnd",
    syntax: PropertySyntax.MARKER
  },
  {
    n: "markerMid",
    syntax: PropertySyntax.MARKER
  },
  {
    n: "markerStartOffset",
    syntax: PropertySyntax.LENGTH,
    l: true,
    "int": true,
    d: "0"
  },
  {
    n: "markerEndOffset",
    syntax: PropertySyntax.LENGTH,
    l: true,
    "int": true,
    d: "0"
  }
];
var GEOMETRY_ATTRIBUTE_NAMES = new Set(BUILT_IN_PROPERTIES.filter(function(n) {
  return !!n.l;
}).map(function(n) {
  return n.n;
}));
var propertyMetadataCache = {};
var DefaultStyleValueRegistry = function() {
  function DefaultStyleValueRegistry2(runtime2) {
    var _this2 = this;
    _classCallCheck(this, DefaultStyleValueRegistry2);
    this.runtime = runtime2;
    BUILT_IN_PROPERTIES.forEach(function(property) {
      _this2.registerMetadata(property);
    });
  }
  return _createClass(DefaultStyleValueRegistry2, [{
    key: "registerMetadata",
    value: function registerMetadata(metadata) {
      [metadata.n].concat(_toConsumableArray(metadata.a || [])).forEach(function(name) {
        propertyMetadataCache[name] = metadata;
      });
    }
  }, {
    key: "getPropertySyntax",
    value: function getPropertySyntax(syntax) {
      return this.runtime.CSSPropertySyntaxFactory[syntax];
    }
    /**
     * * parse value, eg.
     * fill: 'red' => CSSRGB
     * translateX: '10px' => CSSUnitValue { unit: 'px', value: 10 }
     * fontSize: '2em' => { unit: 'px', value: 32 }
     *
     * * calculate used value
     * * post process
     */
  }, {
    key: "processProperties",
    value: function processProperties(object, attributes) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        skipUpdateAttribute: false,
        skipParse: false,
        forceUpdateGeometry: false,
        usedAttributes: [],
        memoize: true
      };
      Object.assign(object.attributes, attributes);
      var oldClipPath = object.parsedStyle.clipPath;
      var oldOffsetPath = object.parsedStyle.offsetPath;
      assignParsedStyle(object, attributes);
      var needUpdateGeometry = !!options.forceUpdateGeometry;
      if (!needUpdateGeometry) {
        for (var i in attributes) {
          if (GEOMETRY_ATTRIBUTE_NAMES.has(i)) {
            needUpdateGeometry = true;
            break;
          }
        }
      }
      var list = getParsedStyleListOf(object);
      if (list.has("fill") && attributes.fill) {
        object.parsedStyle.fill = parseColor(attributes.fill);
      }
      if (list.has("stroke") && attributes.stroke) {
        object.parsedStyle.stroke = parseColor(attributes.stroke);
      }
      if (list.has("shadowColor") && attributes.shadowColor) {
        object.parsedStyle.shadowColor = parseColor(attributes.shadowColor);
      }
      if (list.has("filter") && attributes.filter) {
        object.parsedStyle.filter = parseFilter(attributes.filter);
      }
      if (list.has("radius") && !isNil(attributes.radius)) {
        object.parsedStyle.radius = parseDimensionArrayFormat(
          // @ts-ignore
          attributes.radius,
          4
        );
      }
      if (list.has("lineDash") && !isNil(attributes.lineDash)) {
        object.parsedStyle.lineDash = parseDimensionArrayFormat(attributes.lineDash, "even");
      }
      if (list.has("points") && attributes.points) {
        object.parsedStyle.points = parsePoints(attributes.points);
      }
      if (list.has("d") && attributes.d === "") {
        object.parsedStyle.d = _objectSpread2({}, EMPTY_PARSED_PATH);
      }
      if (list.has("d") && attributes.d) {
        object.parsedStyle.d = parsePath(
          // @ts-ignore
          attributes.d
        );
      }
      if (list.has("textTransform") && attributes.textTransform) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.TEXT_TRANSFORM].calculator(null, null, {
          value: attributes.textTransform
        }, object, null);
      }
      if (list.has("clipPath") && !is_undefined_default(attributes.clipPath)) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.DEFINED_PATH].calculator("clipPath", oldClipPath, attributes.clipPath, object, this.runtime);
      }
      if (list.has("offsetPath") && attributes.offsetPath) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.DEFINED_PATH].calculator("offsetPath", oldOffsetPath, attributes.offsetPath, object, this.runtime);
      }
      if (list.has("transform") && attributes.transform) {
        object.parsedStyle.transform = parseTransform(attributes.transform);
      }
      if (list.has("transformOrigin") && attributes.transformOrigin) {
        object.parsedStyle.transformOrigin = parseTransformOrigin(attributes.transformOrigin);
      }
      if (list.has("markerStart") && attributes.markerStart) {
        object.parsedStyle.markerStart = this.runtime.CSSPropertySyntaxFactory[PropertySyntax.MARKER].calculator(
          null,
          // @ts-ignore
          attributes.markerStart,
          // @ts-ignore
          attributes.markerStart,
          null,
          null
        );
      }
      if (list.has("markerEnd") && attributes.markerEnd) {
        object.parsedStyle.markerEnd = this.runtime.CSSPropertySyntaxFactory[PropertySyntax.MARKER].calculator(
          null,
          // @ts-ignore
          attributes.markerEnd,
          // @ts-ignore
          attributes.markerEnd,
          null,
          null
        );
      }
      if (list.has("markerMid") && attributes.markerMid) {
        object.parsedStyle.markerMid = this.runtime.CSSPropertySyntaxFactory[PropertySyntax.MARKER].calculator(
          "",
          // @ts-ignore
          attributes.markerMid,
          // @ts-ignore
          attributes.markerMid,
          null,
          null
        );
      }
      if (list.has("zIndex") && !isNil(attributes.zIndex)) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.Z_INDEX].postProcessor(object);
      }
      if (list.has("offsetDistance") && !isNil(attributes.offsetDistance)) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.OFFSET_DISTANCE].postProcessor(object);
      }
      if (list.has("transform") && attributes.transform) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.TRANSFORM].postProcessor(object);
      }
      if (list.has("transformOrigin") && attributes.transformOrigin) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.TRANSFORM_ORIGIN].postProcessor(object);
      }
      if (needUpdateGeometry) {
        object.geometry.dirty = true;
        object.dirty(true, true);
        if (!options.forceUpdateGeometry) {
          this.runtime.sceneGraphService.dirtyToRoot(object);
        }
      }
    }
    /**
     * update geometry when relative props changed,
     * eg. r of Circle, width/height of Rect
     */
  }, {
    key: "updateGeometry",
    value: function updateGeometry(object) {
      var nodeName = object.nodeName;
      var geometryUpdater = this.runtime.geometryUpdaterFactory[nodeName];
      if (geometryUpdater) {
        var geometry = object.geometry;
        if (!geometry.contentBounds) {
          geometry.contentBounds = new AABB();
        }
        if (!geometry.renderBounds) {
          geometry.renderBounds = new AABB();
        }
        var parsedStyle = object.parsedStyle;
        var _geometryUpdater$upda = geometryUpdater.update(parsedStyle, object), _geometryUpdater$upda2 = _geometryUpdater$upda.cx, cx = _geometryUpdater$upda2 === void 0 ? 0 : _geometryUpdater$upda2, _geometryUpdater$upda3 = _geometryUpdater$upda.cy, cy = _geometryUpdater$upda3 === void 0 ? 0 : _geometryUpdater$upda3, _geometryUpdater$upda4 = _geometryUpdater$upda.cz, cz = _geometryUpdater$upda4 === void 0 ? 0 : _geometryUpdater$upda4, _geometryUpdater$upda5 = _geometryUpdater$upda.hwidth, hwidth = _geometryUpdater$upda5 === void 0 ? 0 : _geometryUpdater$upda5, _geometryUpdater$upda6 = _geometryUpdater$upda.hheight, hheight = _geometryUpdater$upda6 === void 0 ? 0 : _geometryUpdater$upda6, _geometryUpdater$upda7 = _geometryUpdater$upda.hdepth, hdepth = _geometryUpdater$upda7 === void 0 ? 0 : _geometryUpdater$upda7;
        var halfExtents = [Math.abs(hwidth), Math.abs(hheight), hdepth];
        var stroke = parsedStyle.stroke, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$increase = parsedStyle.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _parsedStyle$increase === void 0 ? 0 : _parsedStyle$increase, _parsedStyle$shadowTy = parsedStyle.shadowType, shadowType = _parsedStyle$shadowTy === void 0 ? "outer" : _parsedStyle$shadowTy, shadowColor = parsedStyle.shadowColor, _parsedStyle$filter = parsedStyle.filter, filter2 = _parsedStyle$filter === void 0 ? [] : _parsedStyle$filter, transformOrigin = parsedStyle.transformOrigin;
        var center = [cx, cy, cz];
        geometry.contentBounds.update(center, halfExtents);
        var expansion = nodeName === Shape.POLYLINE || nodeName === Shape.POLYGON || nodeName === Shape.PATH ? Math.SQRT2 : 0.5;
        var hasStroke = stroke && !stroke.isNone;
        if (hasStroke) {
          var halfLineWidth = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) * expansion;
          halfExtents[0] += halfLineWidth;
          halfExtents[1] += halfLineWidth;
        }
        geometry.renderBounds.update(center, halfExtents);
        if (shadowColor && shadowType && shadowType !== "inner") {
          var _geometry$renderBound = geometry.renderBounds, min5 = _geometry$renderBound.min, max6 = _geometry$renderBound.max;
          var shadowBlur = parsedStyle.shadowBlur, shadowOffsetX = parsedStyle.shadowOffsetX, shadowOffsetY = parsedStyle.shadowOffsetY;
          var shadowBlurInPixels = shadowBlur || 0;
          var shadowOffsetXInPixels = shadowOffsetX || 0;
          var shadowOffsetYInPixels = shadowOffsetY || 0;
          var shadowLeft = min5[0] - shadowBlurInPixels + shadowOffsetXInPixels;
          var shadowRight = max6[0] + shadowBlurInPixels + shadowOffsetXInPixels;
          var shadowTop = min5[1] - shadowBlurInPixels + shadowOffsetYInPixels;
          var shadowBottom = max6[1] + shadowBlurInPixels + shadowOffsetYInPixels;
          min5[0] = Math.min(min5[0], shadowLeft);
          max6[0] = Math.max(max6[0], shadowRight);
          min5[1] = Math.min(min5[1], shadowTop);
          max6[1] = Math.max(max6[1], shadowBottom);
          geometry.renderBounds.setMinMax(min5, max6);
        }
        filter2.forEach(function(_ref) {
          var name = _ref.name, params = _ref.params;
          if (name === "blur") {
            var blurRadius = params[0].value;
            geometry.renderBounds.update(geometry.renderBounds.center, vec3_exports.add(geometry.renderBounds.halfExtents, geometry.renderBounds.halfExtents, [blurRadius, blurRadius, 0]));
          } else if (name === "drop-shadow") {
            var _shadowOffsetX = params[0].value;
            var _shadowOffsetY = params[1].value;
            var _shadowBlur = params[2].value;
            var _geometry$renderBound2 = geometry.renderBounds, _min = _geometry$renderBound2.min, _max = _geometry$renderBound2.max;
            var _shadowLeft = _min[0] - _shadowBlur + _shadowOffsetX;
            var _shadowRight = _max[0] + _shadowBlur + _shadowOffsetX;
            var _shadowTop = _min[1] - _shadowBlur + _shadowOffsetY;
            var _shadowBottom = _max[1] + _shadowBlur + _shadowOffsetY;
            _min[0] = Math.min(_min[0], _shadowLeft);
            _max[0] = Math.max(_max[0], _shadowRight);
            _min[1] = Math.min(_min[1], _shadowTop);
            _max[1] = Math.max(_max[1], _shadowBottom);
            geometry.renderBounds.setMinMax(_min, _max);
          }
        });
        object.geometry.dirty = false;
        var flipY = hwidth < 0;
        var flipX = hheight < 0;
        var usedOriginXValue = (flipY ? -1 : 1) * (transformOrigin ? convertPercentUnit(transformOrigin[0], 0, object, true) : 0);
        var usedOriginYValue = (flipX ? -1 : 1) * (transformOrigin ? convertPercentUnit(transformOrigin[1], 1, object, true) : 0);
        if (usedOriginXValue || usedOriginYValue) {
          object.setOrigin(usedOriginXValue, usedOriginYValue);
        }
      }
    }
  }, {
    key: "updateSizeAttenuation",
    value: function updateSizeAttenuation(node, zoom) {
      if (node.style.isSizeAttenuation) {
        if (!node.style.rawLineWidth) {
          node.style.rawLineWidth = node.style.lineWidth;
        }
        node.style.lineWidth = (node.style.rawLineWidth || 1) / zoom;
        if (node.nodeName === Shape.CIRCLE) {
          if (!node.style.rawR) {
            node.style.rawR = node.style.r;
          }
          node.style.r = (node.style.rawR || 1) / zoom;
        }
      } else {
        if (node.style.rawLineWidth) {
          node.style.lineWidth = node.style.rawLineWidth;
          delete node.style.rawLineWidth;
        }
        if (node.nodeName === Shape.CIRCLE) {
          if (node.style.rawR) {
            node.style.r = node.style.rawR;
            delete node.style.rawR;
          }
        }
      }
    }
  }]);
}();
function assignParsedStyle(object, attributes) {
  var list = getParsedStyleListOf(object);
  for (var key in attributes) {
    if (list.has(key)) {
      object.parsedStyle[key] = attributes[key];
    }
  }
}
function getParsedStyleListOf(object) {
  return object.constructor.PARSED_STYLE_LIST;
}
var CSSPropertyAngle = function() {
  function CSSPropertyAngle2() {
    _classCallCheck(this, CSSPropertyAngle2);
    this.mixer = mergeNumbers;
  }
  return _createClass(CSSPropertyAngle2, [{
    key: "calculator",
    value: function calculator(name, oldParsed, parsed, object) {
      return convertAngleUnit(parsed);
    }
  }]);
}();
var CSSPropertyClipPath = function() {
  function CSSPropertyClipPath2() {
    _classCallCheck(this, CSSPropertyClipPath2);
  }
  return _createClass(CSSPropertyClipPath2, [{
    key: "calculator",
    value: function calculator(name, oldPath, newPath, object, runtime2) {
      if (newPath instanceof CSSKeywordValue) {
        newPath = null;
      }
      runtime2.sceneGraphService.updateDisplayObjectDependency(name, oldPath, newPath, object);
      if (name === "clipPath") {
        object.forEach(function(leaf) {
          if (leaf.childNodes.length === 0) {
            runtime2.sceneGraphService.dirtyToRoot(leaf);
          }
        });
      }
      return newPath;
    }
  }]);
}();
var CSSPropertyColor = function() {
  function CSSPropertyColor2() {
    _classCallCheck(this, CSSPropertyColor2);
    this.parser = parseColor;
    this.mixer = mergeColors;
  }
  return _createClass(CSSPropertyColor2, [{
    key: "calculator",
    value: function calculator(name, oldParsed, parsed, object) {
      if (parsed instanceof CSSKeywordValue) {
        return parsed.value === "none" ? noneColor : transparentColor;
      }
      return parsed;
    }
  }]);
}();
var CSSPropertyFilter = function() {
  function CSSPropertyFilter2() {
    _classCallCheck(this, CSSPropertyFilter2);
  }
  return _createClass(CSSPropertyFilter2, [{
    key: "calculator",
    value: function calculator(name, oldParsed, parsed) {
      if (parsed instanceof CSSKeywordValue) {
        return [];
      }
      return parsed;
    }
  }]);
}();
function getFontSize(object) {
  var _ref = object.parsedStyle, fontSize = _ref.fontSize;
  return isNil(fontSize) ? null : fontSize;
}
var CSSPropertyLengthOrPercentage = function() {
  function CSSPropertyLengthOrPercentage2() {
    _classCallCheck(this, CSSPropertyLengthOrPercentage2);
    this.mixer = mergeNumbers;
  }
  return _createClass(CSSPropertyLengthOrPercentage2, [{
    key: "calculator",
    value: (
      /**
       * according to parent's bounds
       *
       * @example
       * CSS.percent(50) -> CSS.px(0.5 * parent.width)
       */
      function calculator(name, oldParsed, computed, object, runtime2) {
        if (isNumber(computed)) {
          return computed;
        }
        if (CSSUnitValue.isRelativeUnit(computed.unit)) {
          if (computed.unit === UnitType.kPercentage) {
            return 0;
          }
          if (computed.unit === UnitType.kEms) {
            if (object.parentNode) {
              var fontSize = getFontSize(object.parentNode);
              if (fontSize) {
                fontSize *= computed.value;
                return fontSize;
              }
            }
            return 0;
          }
          if (computed.unit === UnitType.kRems) {
            var _object$ownerDocument;
            if (object !== null && object !== void 0 && (_object$ownerDocument = object.ownerDocument) !== null && _object$ownerDocument !== void 0 && _object$ownerDocument.documentElement) {
              var _fontSize = getFontSize(object.ownerDocument.documentElement);
              if (_fontSize) {
                _fontSize *= computed.value;
                return _fontSize;
              }
            }
            return 0;
          }
        } else {
          return computed.value;
        }
      }
    )
  }]);
}();
var CSSPropertyLengthOrPercentage12 = function() {
  function CSSPropertyLengthOrPercentage122() {
    _classCallCheck(this, CSSPropertyLengthOrPercentage122);
    this.mixer = mergeNumberLists;
  }
  return _createClass(CSSPropertyLengthOrPercentage122, [{
    key: "calculator",
    value: function calculator(name, oldParsed, computed) {
      return computed.map(function(c2) {
        return c2.value;
      });
    }
  }]);
}();
var CSSPropertyLengthOrPercentage14 = function() {
  function CSSPropertyLengthOrPercentage142() {
    _classCallCheck(this, CSSPropertyLengthOrPercentage142);
    this.mixer = mergeNumberLists;
  }
  return _createClass(CSSPropertyLengthOrPercentage142, [{
    key: "calculator",
    value: function calculator(name, oldParsed, computed) {
      return computed.map(function(c2) {
        return c2.value;
      });
    }
  }]);
}();
var CSSPropertyMarker = function() {
  function CSSPropertyMarker2() {
    _classCallCheck(this, CSSPropertyMarker2);
  }
  return _createClass(CSSPropertyMarker2, [{
    key: "calculator",
    value: function calculator(name, oldMarker, newMarker, object) {
      var _newMarker;
      if (newMarker instanceof CSSKeywordValue) {
        newMarker = null;
      }
      var cloned = (_newMarker = newMarker) === null || _newMarker === void 0 ? void 0 : _newMarker.cloneNode(true);
      if (cloned) {
        cloned.style.isMarker = true;
      }
      return cloned;
    }
  }]);
}();
var CSSPropertyNumber = function() {
  function CSSPropertyNumber2() {
    _classCallCheck(this, CSSPropertyNumber2);
    this.mixer = mergeNumbers;
  }
  return _createClass(CSSPropertyNumber2, [{
    key: "calculator",
    value: function calculator(name, oldParsed, computed) {
      return computed.value;
    }
  }]);
}();
var CSSPropertyOffsetDistance = function() {
  function CSSPropertyOffsetDistance2() {
    _classCallCheck(this, CSSPropertyOffsetDistance2);
    this.mixer = clampedMergeNumbers(0, 1);
  }
  return _createClass(CSSPropertyOffsetDistance2, [{
    key: "calculator",
    value: function calculator(name, oldParsed, computed) {
      return computed.value;
    }
  }, {
    key: "postProcessor",
    value: function postProcessor(object) {
      var _object$parsedStyle = object.parsedStyle, offsetPath = _object$parsedStyle.offsetPath, offsetDistance = _object$parsedStyle.offsetDistance;
      if (!offsetPath) {
        return;
      }
      var nodeName = offsetPath.nodeName;
      if (nodeName === Shape.LINE || nodeName === Shape.PATH || nodeName === Shape.POLYLINE) {
        var point2 = offsetPath.getPoint(offsetDistance);
        if (point2) {
          object.setLocalPosition(point2.x, point2.y);
        }
      }
    }
  }]);
}();
var CSSPropertyOpacity = function() {
  function CSSPropertyOpacity2() {
    _classCallCheck(this, CSSPropertyOpacity2);
    this.mixer = clampedMergeNumbers(0, 1);
  }
  return _createClass(CSSPropertyOpacity2, [{
    key: "calculator",
    value: function calculator(name, oldParsed, computed) {
      return computed.value;
    }
  }]);
}();
var CSSPropertyPath = function() {
  function CSSPropertyPath2() {
    _classCallCheck(this, CSSPropertyPath2);
    this.parser = parsePath;
    this.mixer = mergePaths;
  }
  return _createClass(CSSPropertyPath2, [{
    key: "calculator",
    value: function calculator(name, oldParsed, parsed) {
      if (parsed instanceof CSSKeywordValue && parsed.value === "unset") {
        return {
          absolutePath: [],
          hasArc: false,
          segments: [],
          polygons: [],
          polylines: [],
          curve: null,
          totalLength: 0,
          rect: new Rectangle(0, 0, 0, 0)
        };
      }
      return parsed;
    }
  }]);
}();
var CSSPropertyPoints = _createClass(function CSSPropertyPoints2() {
  _classCallCheck(this, CSSPropertyPoints2);
  this.mixer = mergePoints;
});
var CSSPropertyShadowBlur = function(_CSSPropertyLengthOrP) {
  function CSSPropertyShadowBlur2() {
    var _this2;
    _classCallCheck(this, CSSPropertyShadowBlur2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, CSSPropertyShadowBlur2, [].concat(args));
    _this2.mixer = clampedMergeNumbers(0, Infinity);
    return _this2;
  }
  _inherits(CSSPropertyShadowBlur2, _CSSPropertyLengthOrP);
  return _createClass(CSSPropertyShadowBlur2);
}(CSSPropertyLengthOrPercentage);
var CSSPropertyText = function() {
  function CSSPropertyText2() {
    _classCallCheck(this, CSSPropertyText2);
  }
  return _createClass(CSSPropertyText2, [{
    key: "calculator",
    value: function calculator(name, oldParsed, parsed, object) {
      if (parsed instanceof CSSKeywordValue) {
        if (parsed.value === "unset") {
          return "";
        }
        return parsed.value;
      }
      return "".concat(parsed);
    }
  }, {
    key: "postProcessor",
    value: function postProcessor(object) {
      object.nodeValue = "".concat(object.parsedStyle.text) || "";
    }
  }]);
}();
var CSSPropertyTextTransform = function() {
  function CSSPropertyTextTransform2() {
    _classCallCheck(this, CSSPropertyTextTransform2);
  }
  return _createClass(CSSPropertyTextTransform2, [{
    key: "calculator",
    value: function calculator(name, oldParsed, parsed, object) {
      var rawText = object.getAttribute("text");
      if (rawText) {
        var transformedText = rawText;
        if (parsed.value === "capitalize") {
          transformedText = rawText.charAt(0).toUpperCase() + rawText.slice(1);
        } else if (parsed.value === "lowercase") {
          transformedText = rawText.toLowerCase();
        } else if (parsed.value === "uppercase") {
          transformedText = rawText.toUpperCase();
        }
        object.parsedStyle.text = transformedText;
      }
      return parsed.value;
    }
  }]);
}();
var CANVAS_Map = /* @__PURE__ */ new WeakMap();
function cleanExistedCanvas(container, canvas, cleanUp) {
  if (container) {
    var $dom = typeof container === "string" ? document.getElementById(container) : container;
    if (CANVAS_Map.has($dom)) CANVAS_Map.get($dom).destroy(cleanUp);
    CANVAS_Map.set($dom, canvas);
  }
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
function isElement2(target) {
  return !!target.getAttribute;
}
function sortedIndex(array, value) {
  var low = 0;
  var high = array.length;
  while (low < high) {
    var mid = low + high >>> 1;
    if (sortByZIndex(array[mid], value) < 0) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return low;
}
function sortByZIndex(o1, o2) {
  var zIndex1 = Number(o1.parsedStyle.zIndex || 0);
  var zIndex2 = Number(o2.parsedStyle.zIndex || 0);
  if (zIndex1 === zIndex2) {
    var parent = o1.parentNode;
    if (parent) {
      var children = parent.childNodes || [];
      return children.indexOf(o1) - children.indexOf(o2);
    }
  }
  return zIndex1 - zIndex2;
}
function findClosestClipPathTarget(object) {
  var el = object;
  do {
    var _el$parsedStyle;
    var clipPath = (_el$parsedStyle = el.parsedStyle) === null || _el$parsedStyle === void 0 ? void 0 : _el$parsedStyle.clipPath;
    if (clipPath) return el;
    el = el.parentElement;
  } while (el !== null);
  return null;
}
var PX_SUFFIX = "px";
function setDOMSize($el, width, height) {
  if (isBrowser && $el.style) {
    $el.style.width = width + PX_SUFFIX;
    $el.style.height = height + PX_SUFFIX;
  }
}
function getStyle($el, property) {
  if (isBrowser) {
    return document.defaultView.getComputedStyle($el, null).getPropertyValue(property);
  }
}
function getWidth($el) {
  var width = getStyle($el, "width");
  if (width === "auto") {
    return $el.offsetWidth;
  }
  return parseFloat(width);
}
function getHeight($el) {
  var height = getStyle($el, "height");
  if (height === "auto") {
    return $el.offsetHeight;
  }
  return parseFloat(height);
}
var MOUSE_POINTER_ID = 1;
var TOUCH_TO_POINTER = {
  touchstart: "pointerdown",
  touchend: "pointerup",
  touchendoutside: "pointerupoutside",
  touchmove: "pointermove",
  touchcancel: "pointercancel"
};
var clock = typeof performance === "object" && performance.now ? performance : Date;
function isInFragment(node) {
  if (node.nodeName === Shape.FRAGMENT) return true;
  return node.getRootNode().nodeName === Shape.FRAGMENT;
}
function isFillOrStrokeAffected() {
  var pointerEvents = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "auto";
  var fill = arguments.length > 1 ? arguments[1] : void 0;
  var stroke = arguments.length > 2 ? arguments[2] : void 0;
  var hasFill = false;
  var hasStroke = false;
  var isFillOtherThanNone = !!fill && !fill.isNone;
  var isStrokeOtherThanNone = !!stroke && !stroke.isNone;
  if (pointerEvents === "visiblepainted" || pointerEvents === "painted" || pointerEvents === "auto") {
    hasFill = isFillOtherThanNone;
    hasStroke = isStrokeOtherThanNone;
  } else if (pointerEvents === "visiblefill" || pointerEvents === "fill") {
    hasFill = true;
  } else if (pointerEvents === "visiblestroke" || pointerEvents === "stroke") {
    hasStroke = true;
  } else if (pointerEvents === "visible" || pointerEvents === "all") {
    hasFill = true;
    hasStroke = true;
  }
  return [hasFill, hasStroke];
}
var uId = 1;
var uniqueId = function uniqueId2() {
  return uId++;
};
var root = (
  // eslint-disable-next-line no-nested-ternary
  typeof self === "object" && self.self === self ? self : (
    // @ts-ignore
    typeof global === "object" && global.global === global ? (
      // @ts-ignore
      global
    ) : {}
  )
);
var nowOffset = Date.now();
var pnow = function pnow2() {
  if (root.performance && typeof root.performance.now === "function") {
    return root.performance.now();
  }
  return Date.now() - nowOffset;
};
var reservedCBs = {};
var lastTime = Date.now();
var polyfillRaf = function polyfillRaf2(callback) {
  if (typeof callback !== "function") {
    throw new TypeError("".concat(callback, " is not a function"));
  }
  var currentTime = Date.now();
  var gap = currentTime - lastTime;
  var delay = gap > 16 ? 0 : 16 - gap;
  var id3 = uniqueId();
  reservedCBs[id3] = callback;
  if (Object.keys(reservedCBs).length > 1) return id3;
  setTimeout(function() {
    lastTime = currentTime;
    var copied = reservedCBs;
    reservedCBs = {};
    Object.keys(copied).forEach(function(key) {
      return copied[key](pnow());
    });
  }, delay);
  return id3;
};
var polyfillCaf = function polyfillCaf2(id3) {
  delete reservedCBs[id3];
};
var vendorPrefixes = ["", "webkit", "moz", "ms", "o"];
var getRequestAnimationFrame = function getRequestAnimationFrame2(vp2) {
  if (typeof vp2 !== "string") return polyfillRaf;
  if (vp2 === "") return root.requestAnimationFrame;
  return root["".concat(vp2, "RequestAnimationFrame")];
};
var getCancelAnimationFrame = function getCancelAnimationFrame2(vp2) {
  if (typeof vp2 !== "string") return polyfillCaf;
  if (vp2 === "") return root.cancelAnimationFrame;
  return root["".concat(vp2, "CancelAnimationFrame")] || root["".concat(vp2, "CancelRequestAnimationFrame")];
};
var find2 = function find3(arr, predicate) {
  var i = 0;
  while (arr[i] !== void 0) {
    if (predicate(arr[i])) return arr[i];
    i += 1;
  }
};
var vp = find2(vendorPrefixes, function(vp2) {
  return !!getRequestAnimationFrame(vp2);
});
var raf = getRequestAnimationFrame(vp);
var caf = getCancelAnimationFrame(vp);
root.requestAnimationFrame = raf;
root.cancelAnimationFrame = caf;
var AsyncParallelHook = function() {
  function AsyncParallelHook2() {
    _classCallCheck(this, AsyncParallelHook2);
    this.callbacks = [];
  }
  return _createClass(AsyncParallelHook2, [{
    key: "getCallbacksNum",
    value: function getCallbacksNum() {
      return this.callbacks.length;
    }
  }, {
    key: "tapPromise",
    value: function tapPromise(options, fn) {
      this.callbacks.push(fn);
    }
  }, {
    key: "promise",
    value: function promise() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return Promise.all(this.callbacks.map(function(callback) {
        return callback.apply(void 0, args);
      }));
    }
  }]);
}();
var AsyncSeriesWaterfallHook = function() {
  function AsyncSeriesWaterfallHook2() {
    _classCallCheck(this, AsyncSeriesWaterfallHook2);
    this.callbacks = [];
  }
  return _createClass(AsyncSeriesWaterfallHook2, [{
    key: "tapPromise",
    value: function tapPromise(options, fn) {
      this.callbacks.push(fn);
    }
  }, {
    key: "promise",
    value: function() {
      var _promise = _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
        var _this$callbacks, result, i, callback, _args = arguments;
        return _regeneratorRuntime().wrap(function(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!this.callbacks.length) {
                _context.next = 6;
                break;
              }
              _context.next = 1;
              return (_this$callbacks = this.callbacks)[0].apply(_this$callbacks, _args);
            case 1:
              result = _context.sent;
              i = 0;
            case 2:
              if (!(i < this.callbacks.length - 1)) {
                _context.next = 5;
                break;
              }
              callback = this.callbacks[i];
              _context.next = 3;
              return callback(result);
            case 3:
              result = _context.sent;
            case 4:
              i++;
              _context.next = 2;
              break;
            case 5:
              return _context.abrupt("return", result);
            case 6:
              return _context.abrupt("return", null);
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function promise() {
        return _promise.apply(this, arguments);
      }
      return promise;
    }()
  }]);
}();
var SyncHook = function() {
  function SyncHook2() {
    _classCallCheck(this, SyncHook2);
    this.callbacks = [];
  }
  return _createClass(SyncHook2, [{
    key: "tap",
    value: function tap(options, fn) {
      this.callbacks.push(fn);
    }
  }, {
    key: "call",
    value: function call() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var argsArr = arguments;
      this.callbacks.forEach(function(callback) {
        callback.apply(void 0, argsArr);
      });
    }
  }]);
}();
var SyncWaterfallHook = function() {
  function SyncWaterfallHook2() {
    _classCallCheck(this, SyncWaterfallHook2);
    this.callbacks = [];
  }
  return _createClass(SyncWaterfallHook2, [{
    key: "tap",
    value: function tap(options, fn) {
      this.callbacks.push(fn);
    }
  }, {
    key: "call",
    value: function call() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (this.callbacks.length) {
        var argsArr = arguments;
        var result = this.callbacks[0].apply(void 0, argsArr);
        for (var i = 0; i < this.callbacks.length - 1; i++) {
          var callback = this.callbacks[i];
          result = callback(result);
        }
        return result;
      }
      return null;
    }
  }]);
}();
var genericFontFamilies = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"];
var stringRegExp = /([\"\'])[^\'\"]+\1/;
function getFontAttr(attributes) {
  var _attributes$fontSize = attributes.fontSize, fontSize = _attributes$fontSize === void 0 ? 16 : _attributes$fontSize, _attributes$fontFamil = attributes.fontFamily, fontFamily = _attributes$fontFamil === void 0 ? "sans-serif" : _attributes$fontFamil, _attributes$fontStyle = attributes.fontStyle, fontStyle = _attributes$fontStyle === void 0 ? "normal" : _attributes$fontStyle, _attributes$fontVaria = attributes.fontVariant, fontVariant = _attributes$fontVaria === void 0 ? "normal" : _attributes$fontVaria, _attributes$fontWeigh = attributes.fontWeight, fontWeight = _attributes$fontWeigh === void 0 ? "normal" : _attributes$fontWeigh;
  return {
    fontSize,
    fontFamily,
    fontStyle,
    fontVariant,
    fontWeight
  };
}
var toFontString = memoize2(function toFontStringRaw(attributes) {
  var _getFontAttr = getFontAttr(attributes), fontSize = _getFontAttr.fontSize, fontFamily = _getFontAttr.fontFamily, fontStyle = _getFontAttr.fontStyle, fontVariant = _getFontAttr.fontVariant, fontWeight = _getFontAttr.fontWeight;
  var fontSizeString = isNumber(fontSize) && "".concat(fontSize, "px") || "16px";
  var fontFamilies = fontFamily.split(",");
  for (var i = fontFamilies.length - 1; i >= 0; i--) {
    var _fontFamily = fontFamilies[i].trim();
    if (!stringRegExp.test(_fontFamily) && genericFontFamilies.indexOf(_fontFamily) < 0) {
      _fontFamily = '"'.concat(_fontFamily, '"');
    }
    fontFamilies[i] = _fontFamily;
  }
  return "".concat(fontStyle, " ").concat(fontVariant, " ").concat(fontWeight, " ").concat(fontSizeString, " ").concat(fontFamilies.join(","));
}, function(attributes) {
  var _getFontAttr2 = getFontAttr(attributes), fontSize = _getFontAttr2.fontSize, fontFamily = _getFontAttr2.fontFamily, fontStyle = _getFontAttr2.fontStyle, fontVariant = _getFontAttr2.fontVariant, fontWeight = _getFontAttr2.fontWeight;
  return "".concat(fontStyle, "_").concat(fontVariant, "_").concat(fontWeight, "_").concat(fontSize, "_").concat(fontFamily);
});
var MIN_SCALE = 1e-6;
var clampScale = function clampScale2(item) {
  return Math.max(item, MIN_SCALE);
};
function createSkewMatrix(skewMatrix, skewX2, skewY2) {
  mat4_exports.identity(skewMatrix);
  skewMatrix[4] = Math.tan(skewX2);
  skewMatrix[1] = Math.tan(skewY2);
  return skewMatrix;
}
var $mat4_1 = mat4_exports.create();
var $mat4_2 = mat4_exports.create();
var parser = {
  scale: function scale7(d2) {
    mat4_exports.fromScaling($mat4_1, [d2[0].value, d2[1].value, 1].map(function(item) {
      return clampScale(item);
    }));
  },
  scaleX: function scaleX(d2) {
    mat4_exports.fromScaling($mat4_1, [d2[0].value, 1, 1].map(function(item) {
      return clampScale(item);
    }));
  },
  scaleY: function scaleY(d2) {
    mat4_exports.fromScaling($mat4_1, [1, d2[0].value, 1].map(function(item) {
      return clampScale(item);
    }));
  },
  scaleZ: function scaleZ(d2) {
    mat4_exports.fromScaling($mat4_1, [1, 1, d2[0].value].map(function(item) {
      return clampScale(item);
    }));
  },
  scale3d: function scale3d(d2) {
    mat4_exports.fromScaling($mat4_1, [d2[0].value, d2[1].value, d2[2].value].map(function(item) {
      return clampScale(item);
    }));
  },
  translate: function translate3(d2) {
    mat4_exports.fromTranslation($mat4_1, [d2[0].value, d2[1].value, 0]);
  },
  translateX: function translateX(d2) {
    mat4_exports.fromTranslation($mat4_1, [d2[0].value, 0, 0]);
  },
  translateY: function translateY(d2) {
    mat4_exports.fromTranslation($mat4_1, [0, d2[0].value, 0]);
  },
  translateZ: function translateZ(d2) {
    mat4_exports.fromTranslation($mat4_1, [0, 0, d2[0].value]);
  },
  translate3d: function translate3d(d2) {
    mat4_exports.fromTranslation($mat4_1, [d2[0].value, d2[1].value, d2[2].value]);
  },
  rotate: function rotate4(d2) {
    mat4_exports.fromZRotation($mat4_1, deg2rad(convertAngleUnit(d2[0])));
  },
  rotateX: function rotateX4(d2) {
    mat4_exports.fromXRotation($mat4_1, deg2rad(convertAngleUnit(d2[0])));
  },
  rotateY: function rotateY4(d2) {
    mat4_exports.fromYRotation($mat4_1, deg2rad(convertAngleUnit(d2[0])));
  },
  rotateZ: function rotateZ4(d2) {
    mat4_exports.fromZRotation($mat4_1, deg2rad(convertAngleUnit(d2[0])));
  },
  rotate3d: function rotate3d(d2) {
    mat4_exports.fromRotation($mat4_1, deg2rad(convertAngleUnit(d2[3])), [d2[0].value, d2[1].value, d2[2].value]);
  },
  skew: function skew(d2) {
    createSkewMatrix($mat4_1, deg2rad(d2[0].value), deg2rad(d2[1].value));
  },
  skewX: function skewX(d2) {
    createSkewMatrix($mat4_1, deg2rad(d2[0].value), 0);
  },
  skewY: function skewY(d2) {
    createSkewMatrix($mat4_1, 0, deg2rad(d2[0].value));
  },
  matrix: function matrix(d2) {
    mat4_exports.set($mat4_1, d2[0].value, d2[1].value, 0, 0, d2[2].value, d2[3].value, 0, 0, 0, 0, 1, 0, d2[4].value, d2[5].value, 0, 1);
  },
  matrix3d: function matrix3d(d2) {
    mat4_exports.set.apply(mat4_exports, [$mat4_1].concat(_toConsumableArray(d2.map(function(s2) {
      return s2.value;
    }))));
  }
};
var $vec3One$1 = vec3_exports.fromValues(1, 1, 1);
var $vec3Zero$1 = vec3_exports.create();
var optimizer = {
  translate: function translate4(object, d2) {
    runtime.sceneGraphService.setLocalScale(object, $vec3One$1, false);
    runtime.sceneGraphService.setLocalEulerAngles(object, $vec3Zero$1, void 0, void 0, false);
    runtime.sceneGraphService.setLocalPosition(object, [d2[0].value, d2[1].value, 0], false);
    runtime.sceneGraphService.dirtyLocalTransform(object, object.transformable);
  }
};
function parsedTransformToMat4(transform2, object) {
  if (transform2.length) {
    if (transform2.length === 1 && optimizer[transform2[0].t]) {
      optimizer[transform2[0].t](object, transform2[0].d);
      return;
    }
    var m2 = mat4_exports.identity($mat4_2);
    for (var i = 0; i < transform2.length; i++) {
      var _transform$i = transform2[i], t = _transform$i.t, d2 = _transform$i.d;
      var p = parser[t];
      if (p) {
        p(d2);
        mat4_exports.mul(m2, m2, $mat4_1);
      }
    }
    object.setLocalTransform(m2);
  } else {
    object.resetLocalTransform();
  }
  return object.getLocalTransform();
}
var CSSPropertyTransform = function() {
  function CSSPropertyTransform2() {
    _classCallCheck(this, CSSPropertyTransform2);
    this.parser = parseTransformUnmemoize;
    this.mixer = mergeTransforms;
  }
  return _createClass(CSSPropertyTransform2, [{
    key: "calculator",
    value: function calculator(name, oldParsed, parsed, object) {
      if (parsed instanceof CSSKeywordValue) {
        return [];
      }
      return parsed;
    }
  }, {
    key: "postProcessor",
    value: function postProcessor(object) {
      parsedTransformToMat4(object.parsedStyle.transform, object);
    }
  }]);
}();
var CSSPropertyTransformOrigin = function() {
  function CSSPropertyTransformOrigin2() {
    _classCallCheck(this, CSSPropertyTransformOrigin2);
  }
  return _createClass(CSSPropertyTransformOrigin2, [{
    key: "postProcessor",
    value: function postProcessor(object) {
      var transformOrigin = object.parsedStyle.transformOrigin;
      if (transformOrigin[0].unit === UnitType.kPixels && transformOrigin[1].unit === UnitType.kPixels) {
        object.setOrigin(transformOrigin[0].value, transformOrigin[1].value);
      } else {
        object.getGeometryBounds();
      }
    }
  }]);
}();
var CSSPropertyZIndex = function() {
  function CSSPropertyZIndex2() {
    _classCallCheck(this, CSSPropertyZIndex2);
  }
  return _createClass(CSSPropertyZIndex2, [{
    key: "calculator",
    value: function calculator(name, oldParsed, computed, object) {
      return computed.value;
    }
  }, {
    key: "postProcessor",
    value: function postProcessor(object) {
      if (object.parentNode) {
        var parentEntity = object.parentNode;
        var parentRenderable = parentEntity.renderable;
        var parentSortable = parentEntity.sortable;
        if (parentRenderable) {
          parentEntity.dirty();
        }
        if (parentSortable) {
          parentSortable.dirty = true;
          parentSortable.dirtyReason = SortReason.Z_INDEX_CHANGED;
        }
      }
    }
  }]);
}();
var CircleUpdater = function() {
  function CircleUpdater2() {
    _classCallCheck(this, CircleUpdater2);
  }
  return _createClass(CircleUpdater2, [{
    key: "update",
    value: function update2(parsedStyle, object) {
      var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, _parsedStyle$r = parsedStyle.r, r = _parsedStyle$r === void 0 ? 0 : _parsedStyle$r;
      return {
        cx,
        cy,
        hwidth: r,
        hheight: r
      };
    }
  }]);
}();
var EllipseUpdater = function() {
  function EllipseUpdater2() {
    _classCallCheck(this, EllipseUpdater2);
  }
  return _createClass(EllipseUpdater2, [{
    key: "update",
    value: function update2(parsedStyle, object) {
      var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, _parsedStyle$rx = parsedStyle.rx, rx = _parsedStyle$rx === void 0 ? 0 : _parsedStyle$rx, _parsedStyle$ry = parsedStyle.ry, ry = _parsedStyle$ry === void 0 ? 0 : _parsedStyle$ry;
      return {
        cx,
        cy,
        hwidth: rx,
        hheight: ry
      };
    }
  }]);
}();
var LineUpdater = function() {
  function LineUpdater2() {
    _classCallCheck(this, LineUpdater2);
  }
  return _createClass(LineUpdater2, [{
    key: "update",
    value: function update2(parsedStyle) {
      var x1 = parsedStyle.x1, y1 = parsedStyle.y1, x22 = parsedStyle.x2, y22 = parsedStyle.y2;
      var minX = Math.min(x1, x22);
      var maxX = Math.max(x1, x22);
      var minY = Math.min(y1, y22);
      var maxY = Math.max(y1, y22);
      var width = maxX - minX;
      var height = maxY - minY;
      var hwidth = width / 2;
      var hheight = height / 2;
      return {
        cx: minX + hwidth,
        cy: minY + hheight,
        hwidth,
        hheight
      };
    }
  }]);
}();
var PathUpdater = function() {
  function PathUpdater2() {
    _classCallCheck(this, PathUpdater2);
  }
  return _createClass(PathUpdater2, [{
    key: "update",
    value: function update2(parsedStyle) {
      var d2 = parsedStyle.d;
      var _d$rect = d2.rect, x3 = _d$rect.x, y3 = _d$rect.y, width = _d$rect.width, height = _d$rect.height;
      var hwidth = width / 2;
      var hheight = height / 2;
      return {
        cx: x3 + hwidth,
        cy: y3 + hheight,
        hwidth,
        hheight
      };
    }
  }]);
}();
var PolylineUpdater = function() {
  function PolylineUpdater2() {
    _classCallCheck(this, PolylineUpdater2);
  }
  return _createClass(PolylineUpdater2, [{
    key: "update",
    value: function update2(parsedStyle) {
      if (parsedStyle.points && isArray(parsedStyle.points.points)) {
        var points = parsedStyle.points.points;
        var minX = Math.min.apply(Math, _toConsumableArray(points.map(function(point2) {
          return point2[0];
        })));
        var maxX = Math.max.apply(Math, _toConsumableArray(points.map(function(point2) {
          return point2[0];
        })));
        var minY = Math.min.apply(Math, _toConsumableArray(points.map(function(point2) {
          return point2[1];
        })));
        var maxY = Math.max.apply(Math, _toConsumableArray(points.map(function(point2) {
          return point2[1];
        })));
        var width = maxX - minX;
        var height = maxY - minY;
        var hwidth = width / 2;
        var hheight = height / 2;
        return {
          cx: minX + hwidth,
          cy: minY + hheight,
          hwidth,
          hheight
        };
      }
      return {
        cx: 0,
        cy: 0,
        hwidth: 0,
        hheight: 0
      };
    }
  }]);
}();
var RectUpdater = function() {
  function RectUpdater2() {
    _classCallCheck(this, RectUpdater2);
  }
  return _createClass(RectUpdater2, [{
    key: "update",
    value: function update2(parsedStyle, object) {
      var _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, src = parsedStyle.src, _parsedStyle$width = parsedStyle.width, width = _parsedStyle$width === void 0 ? 0 : _parsedStyle$width, _parsedStyle$height = parsedStyle.height, height = _parsedStyle$height === void 0 ? 0 : _parsedStyle$height;
      var contentWidth = width;
      var contentHeight = height;
      if (src && !isString(src)) {
        if (!contentWidth) {
          contentWidth = src.width;
          parsedStyle.width = contentWidth;
        }
        if (!contentHeight) {
          contentHeight = src.height;
          parsedStyle.height = contentHeight;
        }
      }
      return {
        cx: x3 + contentWidth / 2,
        cy: y3 + contentHeight / 2,
        hwidth: contentWidth / 2,
        hheight: contentHeight / 2
      };
    }
  }]);
}();
var TextUpdater = function() {
  function TextUpdater2(globalRuntime) {
    _classCallCheck(this, TextUpdater2);
    this.globalRuntime = globalRuntime;
  }
  return _createClass(TextUpdater2, [{
    key: "isReadyToMeasure",
    value: function isReadyToMeasure(parsedStyle, object) {
      var text = parsedStyle.text;
      return text;
    }
  }, {
    key: "update",
    value: function update2(parsedStyle, object) {
      var _object$ownerDocument;
      var text = parsedStyle.text, _parsedStyle$textAlig = parsedStyle.textAlign, textAlign = _parsedStyle$textAlig === void 0 ? "start" : _parsedStyle$textAlig, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$textBase = parsedStyle.textBaseline, textBaseline = _parsedStyle$textBase === void 0 ? "alphabetic" : _parsedStyle$textBase, _parsedStyle$dx = parsedStyle.dx, dx = _parsedStyle$dx === void 0 ? 0 : _parsedStyle$dx, _parsedStyle$dy = parsedStyle.dy, dy = _parsedStyle$dy === void 0 ? 0 : _parsedStyle$dy, _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y;
      if (!this.isReadyToMeasure(parsedStyle, object)) {
        parsedStyle.metrics = {
          font: "",
          width: 0,
          height: 0,
          lines: [],
          lineWidths: [],
          lineHeight: 0,
          maxLineWidth: 0,
          fontProperties: {
            ascent: 0,
            descent: 0,
            fontSize: 0
          },
          lineMetrics: []
        };
        return {
          hwidth: 0,
          hheight: 0,
          cx: 0,
          cy: 0
        };
      }
      var _ref = (object === null || object === void 0 || (_object$ownerDocument = object.ownerDocument) === null || _object$ownerDocument === void 0 || (_object$ownerDocument = _object$ownerDocument.defaultView) === null || _object$ownerDocument === void 0 ? void 0 : _object$ownerDocument.getConfig()) || {}, offscreenCanvas = _ref.offscreenCanvas;
      var metrics = this.globalRuntime.textService.measureText(text, parsedStyle, offscreenCanvas);
      parsedStyle.metrics = metrics;
      var width = metrics.width, height = metrics.height;
      var hwidth = width / 2;
      var hheight = height / 2;
      var lineXOffset = x3 + hwidth;
      if (textAlign === "center" || textAlign === "middle") {
        lineXOffset += lineWidth / 2 - hwidth;
      } else if (textAlign === "right" || textAlign === "end") {
        lineXOffset += lineWidth - hwidth * 2;
      }
      var lineYOffset = y3 - hheight;
      if (textBaseline === "middle") {
        lineYOffset += hheight;
      } else if (textBaseline === "top" || textBaseline === "hanging") {
        lineYOffset += hheight * 2;
      } else if (textBaseline === "alphabetic") ;
      else if (textBaseline === "bottom" || textBaseline === "ideographic") {
        lineYOffset += 0;
      }
      if (dx) {
        lineXOffset += dx;
      }
      if (dy) {
        lineYOffset += dy;
      }
      return {
        cx: lineXOffset,
        cy: lineYOffset,
        hwidth,
        hheight
      };
    }
  }]);
}();
var GroupUpdater = function() {
  function GroupUpdater2() {
    _classCallCheck(this, GroupUpdater2);
  }
  return _createClass(GroupUpdater2, [{
    key: "update",
    value: function update2(parsedStyle, object) {
      return {
        cx: 0,
        cy: 0,
        hwidth: 0,
        hheight: 0
      };
    }
  }]);
}();
var HTMLUpdater = function() {
  function HTMLUpdater2() {
    _classCallCheck(this, HTMLUpdater2);
  }
  return _createClass(HTMLUpdater2, [{
    key: "update",
    value: function update2(parsedStyle, object) {
      var _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, _parsedStyle$width = parsedStyle.width, width = _parsedStyle$width === void 0 ? 0 : _parsedStyle$width, _parsedStyle$height = parsedStyle.height, height = _parsedStyle$height === void 0 ? 0 : _parsedStyle$height;
      return {
        cx: x3 + width / 2,
        cy: y3 + height / 2,
        hwidth: width / 2,
        hheight: height / 2
      };
    }
  }]);
}();
var FederatedEvent = function() {
  function FederatedEvent2(manager) {
    _classCallCheck(this, FederatedEvent2);
    this.eventPhase = FederatedEvent2.prototype.NONE;
    this.bubbles = true;
    this.cancelBubble = true;
    this.cancelable = false;
    this.defaultPrevented = false;
    this.propagationStopped = false;
    this.propagationImmediatelyStopped = false;
    this.layer = new Point();
    this.page = new Point();
    this.canvas = new Point();
    this.viewport = new Point();
    this.composed = false;
    this.NONE = 0;
    this.CAPTURING_PHASE = 1;
    this.AT_TARGET = 2;
    this.BUBBLING_PHASE = 3;
    this.manager = manager;
  }
  return _createClass(FederatedEvent2, [{
    key: "name",
    get: (
      /**
       * The type of event, supports the following:
       * * pointerdown
       * * touchstart
       * * mousedown
       * * rightdown
       * * ...
       */
      /**
       * @deprecated
       */
      function get() {
        return this.type;
      }
    )
  }, {
    key: "layerX",
    get: function get() {
      return this.layer.x;
    }
  }, {
    key: "layerY",
    get: function get() {
      return this.layer.y;
    }
  }, {
    key: "pageX",
    get: function get() {
      return this.page.x;
    }
  }, {
    key: "pageY",
    get: function get() {
      return this.page.y;
    }
  }, {
    key: "x",
    get: function get() {
      return this.canvas.x;
    }
  }, {
    key: "y",
    get: function get() {
      return this.canvas.y;
    }
  }, {
    key: "canvasX",
    get: function get() {
      return this.canvas.x;
    }
  }, {
    key: "canvasY",
    get: function get() {
      return this.canvas.y;
    }
  }, {
    key: "viewportX",
    get: function get() {
      return this.viewport.x;
    }
  }, {
    key: "viewportY",
    get: function get() {
      return this.viewport.y;
    }
  }, {
    key: "composedPath",
    value: (
      /**
       * The propagation path for this event
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/composedPath
       *
       * So composedPath()[0] represents the original target.
       * @see https://polymer-library.polymer-project.org/3.0/docs/devguide/events#retargeting
       */
      function composedPath() {
        if (this.manager && (!this.path || this.path[0] !== this.target)) {
          this.path = this.target ? this.manager.propagationPath(this.target) : [];
        }
        return this.path;
      }
    )
    /**
     * @deprecated
     */
  }, {
    key: "propagationPath",
    get: function get() {
      return this.composedPath();
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault
     */
  }, {
    key: "preventDefault",
    value: function preventDefault() {
      if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
        this.nativeEvent.preventDefault();
      }
      this.defaultPrevented = true;
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopImmediatePropagation
     */
  }, {
    key: "stopImmediatePropagation",
    value: function stopImmediatePropagation() {
      this.propagationImmediatelyStopped = true;
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation
     */
  }, {
    key: "stopPropagation",
    value: function stopPropagation() {
      this.propagationStopped = true;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/view
     */
  }, {
    key: "initEvent",
    value: (
      /**
       * added for compatibility with DOM Event,
       * deprecated props and methods
       */
      function initEvent() {
      }
    )
  }, {
    key: "initUIEvent",
    value: function initUIEvent() {
    }
  }, {
    key: "clone",
    value: function clone8() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }]);
}();
var FederatedMouseEvent = function(_ref) {
  function FederatedMouseEvent2() {
    var _this2;
    _classCallCheck(this, FederatedMouseEvent2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, FederatedMouseEvent2, [].concat(args));
    _this2.client = new Point();
    _this2.movement = new Point();
    _this2.offset = new Point();
    _this2.global = new Point();
    _this2.screen = new Point();
    return _this2;
  }
  _inherits(FederatedMouseEvent2, _ref);
  return _createClass(FederatedMouseEvent2, [{
    key: "clientX",
    get: function get() {
      return this.client.x;
    }
  }, {
    key: "clientY",
    get: function get() {
      return this.client.y;
    }
  }, {
    key: "movementX",
    get: function get() {
      return this.movement.x;
    }
  }, {
    key: "movementY",
    get: function get() {
      return this.movement.y;
    }
  }, {
    key: "offsetX",
    get: function get() {
      return this.offset.x;
    }
  }, {
    key: "offsetY",
    get: function get() {
      return this.offset.y;
    }
  }, {
    key: "globalX",
    get: function get() {
      return this.global.x;
    }
  }, {
    key: "globalY",
    get: function get() {
      return this.global.y;
    }
  }, {
    key: "screenX",
    get: function get() {
      return this.screen.x;
    }
  }, {
    key: "screenY",
    get: function get() {
      return this.screen.y;
    }
  }, {
    key: "getModifierState",
    value: function getModifierState(key) {
      return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
    }
  }, {
    key: "initMouseEvent",
    value: function initMouseEvent() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }]);
}(FederatedEvent);
var FederatedPointerEvent = function(_FederatedMouseEvent) {
  function FederatedPointerEvent2() {
    var _this2;
    _classCallCheck(this, FederatedPointerEvent2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, FederatedPointerEvent2, [].concat(args));
    _this2.width = 0;
    _this2.height = 0;
    _this2.isPrimary = false;
    return _this2;
  }
  _inherits(FederatedPointerEvent2, _FederatedMouseEvent);
  return _createClass(FederatedPointerEvent2, [{
    key: "getCoalescedEvents",
    value: (
      /**
       * The type of pointer that triggered the event.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType
       */
      /**
       * Pressure applied by the pointing device during the event.
       *s
       * A Touch's force property will be represented by this value.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure
       */
      /**
       * Barrel pressure on a stylus pointer.
       *
       * @see https://w3c.github.io/pointerevents/#pointerevent-interface
       */
      /**
       * The angle, in degrees, between the pointer device and the screen.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX
       */
      /**
       * The angle, in degrees, between the pointer device and the screen.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY
       */
      /**
       * Twist of a stylus pointer.
       *
       * @see https://w3c.github.io/pointerevents/#pointerevent-interface
       */
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/getCoalescedEvents
       */
      function getCoalescedEvents() {
        if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
          return [this];
        }
        return [];
      }
    )
    /**
     * @see https://chromestatus.com/feature/5765569655603200
     */
  }, {
    key: "getPredictedEvents",
    value: function getPredictedEvents() {
      throw new Error("getPredictedEvents is not supported!");
    }
    /**
     * @see https://github.com/antvis/G/issues/1115
     * We currently reuses event objects in the event system,
     * avoiding the creation of a large number of event objects.
     * Reused objects are only used to carry different data,
     * such as coordinate information, native event objects,
     * and therefore the lifecycle is limited to the event handler,
     * which can lead to unintended consequences if an attempt is made to cache the entire event object.
     *
     * Therefore, while keeping the above performance considerations in mind, it is possible to provide a clone method that creates a new object when the user really wants to cache it, e.g.
     */
  }, {
    key: "clone",
    value: function clone8() {
      return this.manager.clonePointerEvent(this);
    }
  }]);
}(FederatedMouseEvent);
var FederatedWheelEvent = function(_FederatedMouseEvent) {
  function FederatedWheelEvent2() {
    _classCallCheck(this, FederatedWheelEvent2);
    return _callSuper(this, FederatedWheelEvent2, arguments);
  }
  _inherits(FederatedWheelEvent2, _FederatedMouseEvent);
  return _createClass(FederatedWheelEvent2, [{
    key: "clone",
    value: (
      /**
       * The units of `deltaX`, `deltaY`, and `deltaZ`. This is one of `DOM_DELTA_LINE`,
       * `DOM_DELTA_PAGE`, `DOM_DELTA_PIXEL`.
       */
      /** Horizontal scroll amount */
      /** Vertical scroll amount */
      /** z-axis scroll amount. */
      function clone8() {
        return this.manager.cloneWheelEvent(this);
      }
    )
  }]);
}(FederatedMouseEvent);
var CustomEvent = function(_FederatedEvent) {
  function CustomEvent2(eventName, object) {
    var _this2;
    _classCallCheck(this, CustomEvent2);
    _this2 = _callSuper(this, CustomEvent2, [null]);
    _this2.type = eventName;
    _this2.detail = object;
    Object.assign(_this2, object);
    return _this2;
  }
  _inherits(CustomEvent2, _FederatedEvent);
  return _createClass(CustomEvent2);
}(FederatedEvent);
var EventTarget = function() {
  function EventTarget2() {
    _classCallCheck(this, EventTarget2);
    this.emitter = new eventemitter3_default();
  }
  return _createClass(EventTarget2, [{
    key: "on",
    value: (
      /**
       * @deprecated
       * @alias addEventListener
       */
      function on(type, listener, options) {
        this.addEventListener(type, listener, options);
        return this;
      }
    )
    /**
     * support `capture` & `once` in options
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener
     */
  }, {
    key: "addEventListener",
    value: function addEventListener(type, listener, options) {
      var capture = false;
      var once = false;
      if (is_boolean_default(options)) capture = options;
      else if (options) {
        var _options$capture = options.capture;
        capture = _options$capture === void 0 ? false : _options$capture;
        var _options$once = options.once;
        once = _options$once === void 0 ? false : _options$once;
      }
      if (capture) type += "capture";
      listener = isFunction(listener) ? listener : listener.handleEvent;
      var context = isFunction(listener) ? void 0 : listener;
      if (once) this.emitter.once(type, listener, context);
      else this.emitter.on(type, listener, context);
      return this;
    }
    /**
     * @deprecated
     * @alias removeEventListener
     */
  }, {
    key: "off",
    value: function off(type, listener, options) {
      if (type) {
        this.removeEventListener(type, listener, options);
      } else {
        this.removeAllEventListeners();
      }
      return this;
    }
  }, {
    key: "removeAllEventListeners",
    value: function removeAllEventListeners() {
      var _this$emitter;
      (_this$emitter = this.emitter) === null || _this$emitter === void 0 || _this$emitter.removeAllListeners();
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, listener, options) {
      var _listener;
      if (!this.emitter) return this;
      var capture = is_boolean_default(options) ? options : options === null || options === void 0 ? void 0 : options.capture;
      if (capture) type += "capture";
      listener = isFunction(listener) ? listener : (_listener = listener) === null || _listener === void 0 ? void 0 : _listener.handleEvent;
      var context = isFunction(listener) ? void 0 : listener;
      this.emitter.off(type, listener, context);
      return this;
    }
    /**
     * @deprecated
     * @alias dispatchEvent
     */
  }, {
    key: "emit",
    value: function emit(eventName, object) {
      this.dispatchEvent(new CustomEvent(eventName, object));
    }
  }, {
    key: "dispatchEventToSelf",
    value: function dispatchEventToSelf(e) {
      e.target || (e.target = this);
      e.currentTarget = this;
      this.emitter.emit(e.type, e);
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(e) {
      var skipPropagate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var dispatchToSelf = arguments.length > 2 ? arguments[2] : void 0;
      if (dispatchToSelf) {
        this.dispatchEventToSelf(e);
        return true;
      }
      var canvas;
      if (this.document) {
        canvas = this;
      } else if (this.defaultView) {
        canvas = this.defaultView;
      } else {
        var _ownerDocument;
        canvas = (_ownerDocument = this.ownerDocument) === null || _ownerDocument === void 0 ? void 0 : _ownerDocument.defaultView;
      }
      if (canvas) {
        e.manager = canvas.getEventService();
        if (!e.manager) return false;
        e.defaultPrevented = false;
        if (e.path) {
          e.path.length = 0;
        } else {
          e.page = [];
        }
        if (!skipPropagate) {
          e.target = this;
        }
        e.manager.dispatchEvent(e, e.type, skipPropagate);
      } else {
        this.dispatchEventToSelf(e);
      }
      return !e.defaultPrevented;
    }
  }]);
}();
var Node = function(_EventTarget) {
  function Node2() {
    var _this2;
    _classCallCheck(this, Node2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Node2, [].concat(args));
    _this2.shadow = false;
    _this2.ownerDocument = null;
    _this2.isConnected = false;
    _this2.baseURI = "";
    _this2.childNodes = [];
    _this2.nodeType = 0;
    _this2.nodeName = "";
    _this2.nodeValue = null;
    _this2.parentNode = null;
    _this2.destroyed = false;
    return _this2;
  }
  _inherits(Node2, _EventTarget);
  return _createClass(Node2, [{
    key: "textContent",
    get: (
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent
       */
      function get() {
        var out = "";
        if (this.nodeName === Shape.TEXT) {
          out += this.style.text;
        }
        var _iterator = _createForOfIteratorHelper(this.childNodes), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _child = _step.value;
            if (_child.nodeName === Shape.TEXT) {
              out += _child.nodeValue;
            } else {
              out += _child.textContent;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return out;
      }
    ),
    set: function set7(content) {
      var _this2 = this;
      this.childNodes.slice().forEach(function(child) {
        _this2.removeChild(child);
      });
      if (this.nodeName === Shape.TEXT) {
        this.style.text = "".concat(content);
      }
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/getRootNode
     */
  }, {
    key: "getRootNode",
    value: function getRootNode() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (this.parentNode) {
        return this.parentNode.getRootNode(opts);
      }
      if (opts.composed && this.host) {
        return this.host.getRootNode(opts);
      }
      return this;
    }
  }, {
    key: "hasChildNodes",
    value: function hasChildNodes() {
      return this.childNodes.length > 0;
    }
  }, {
    key: "isDefaultNamespace",
    value: function isDefaultNamespace(namespace) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "lookupNamespaceURI",
    value: function lookupNamespaceURI(prefix) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "lookupPrefix",
    value: function lookupPrefix(namespace) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "normalize",
    value: function normalize8() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/isEqualNode
     */
  }, {
    key: "isEqualNode",
    value: function isEqualNode(otherNode) {
      return this === otherNode;
    }
  }, {
    key: "isSameNode",
    value: function isSameNode(otherNode) {
      return this.isEqualNode(otherNode);
    }
  }, {
    key: "parent",
    get: (
      /**
       * @deprecated
       * @alias parentNode
       */
      function get() {
        return this.parentNode;
      }
    )
  }, {
    key: "parentElement",
    get: function get() {
      return null;
    }
  }, {
    key: "nextSibling",
    get: function get() {
      return null;
    }
  }, {
    key: "previousSibling",
    get: function get() {
      return null;
    }
  }, {
    key: "firstChild",
    get: function get() {
      return this.childNodes.length > 0 ? this.childNodes[0] : null;
    }
  }, {
    key: "lastChild",
    get: function get() {
      return this.childNodes.length > 0 ? this.childNodes[this.childNodes.length - 1] : null;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
     * @see https://github.com/b-fuze/deno-dom/blob/master/src/dom/node.ts#L338
     */
  }, {
    key: "compareDocumentPosition",
    value: function compareDocumentPosition(other) {
      if (other === this) {
        return 0;
      }
      var node1Root = other;
      var node2Root = this;
      var node1Hierarchy = [node1Root];
      var node2Hierarchy = [node2Root];
      while ((_node1Root$parentNode = node1Root.parentNode) !== null && _node1Root$parentNode !== void 0 ? _node1Root$parentNode : node2Root.parentNode) {
        var _node1Root$parentNode;
        node1Root = node1Root.parentNode ? (node1Hierarchy.push(node1Root.parentNode), node1Root.parentNode) : node1Root;
        node2Root = node2Root.parentNode ? (node2Hierarchy.push(node2Root.parentNode), node2Root.parentNode) : node2Root;
      }
      if (node1Root !== node2Root) {
        return Node2.DOCUMENT_POSITION_DISCONNECTED | Node2.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node2.DOCUMENT_POSITION_PRECEDING;
      }
      var longerHierarchy = node1Hierarchy.length > node2Hierarchy.length ? node1Hierarchy : node2Hierarchy;
      var shorterHierarchy = longerHierarchy === node1Hierarchy ? node2Hierarchy : node1Hierarchy;
      if (longerHierarchy[longerHierarchy.length - shorterHierarchy.length] === shorterHierarchy[0]) {
        return longerHierarchy === node1Hierarchy ? (
          // other is a child of this
          Node2.DOCUMENT_POSITION_CONTAINED_BY | Node2.DOCUMENT_POSITION_FOLLOWING
        ) : (
          // this is a child of other
          Node2.DOCUMENT_POSITION_CONTAINS | Node2.DOCUMENT_POSITION_PRECEDING
        );
      }
      var longerStart = longerHierarchy.length - shorterHierarchy.length;
      for (var i = shorterHierarchy.length - 1; i >= 0; i--) {
        var shorterHierarchyNode = shorterHierarchy[i];
        var longerHierarchyNode = longerHierarchy[longerStart + i];
        if (longerHierarchyNode !== shorterHierarchyNode) {
          var siblings = shorterHierarchyNode.parentNode.childNodes;
          if (siblings.indexOf(shorterHierarchyNode) < siblings.indexOf(longerHierarchyNode)) {
            if (shorterHierarchy === node1Hierarchy) {
              return Node2.DOCUMENT_POSITION_PRECEDING;
            }
            return Node2.DOCUMENT_POSITION_FOLLOWING;
          }
          if (longerHierarchy === node1Hierarchy) {
            return Node2.DOCUMENT_POSITION_PRECEDING;
          }
          return Node2.DOCUMENT_POSITION_FOLLOWING;
        }
      }
      return Node2.DOCUMENT_POSITION_FOLLOWING;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/cloneNode
     */
  }, {
    key: "contain",
    value: (
      /**
       * @deprecated
       * @alias contains
       */
      function contain2(other) {
        return this.contains(other);
      }
    )
  }, {
    key: "contains",
    value: function contains2(other) {
      var tmp2 = other;
      while (tmp2 && this !== tmp2) {
        tmp2 = tmp2.parentNode;
      }
      return !!tmp2;
    }
  }, {
    key: "getAncestor",
    value: function getAncestor(n) {
      var temp = this;
      while (n > 0 && temp) {
        temp = temp.parentNode;
        n--;
      }
      return temp;
    }
  }, {
    key: "forEach",
    value: function forEach4(callback) {
      var stack = [this];
      while (stack.length > 0) {
        var node = stack.pop();
        var result = callback(node);
        if (result === false) {
          break;
        }
        for (var i = node.childNodes.length - 1; i >= 0; i--) {
          stack.push(node.childNodes[i]);
        }
      }
    }
  }], [{
    key: "isNode",
    value: function isNode(target) {
      return !!target.childNodes;
    }
  }]);
}(EventTarget);
Node.DOCUMENT_POSITION_DISCONNECTED = 1;
Node.DOCUMENT_POSITION_PRECEDING = 2;
Node.DOCUMENT_POSITION_FOLLOWING = 4;
Node.DOCUMENT_POSITION_CONTAINS = 8;
Node.DOCUMENT_POSITION_CONTAINED_BY = 16;
Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
var PROPAGATION_LIMIT = 2048;
var EventService = function() {
  function EventService2(globalRuntime, context) {
    var _this2 = this;
    _classCallCheck(this, EventService2);
    this.nativeHTMLMap = /* @__PURE__ */ new WeakMap();
    this.cursor = "default";
    this.mappingTable = {};
    this.mappingState = {
      trackingData: {}
    };
    this.eventPool = /* @__PURE__ */ new Map();
    this.tmpMatrix = mat4_exports.create();
    this.tmpVec3 = vec3_exports.create();
    this.onPointerDown = function(from) {
      var e = _this2.createPointerEvent(from);
      _this2.dispatchEvent(e, "pointerdown");
      if (e.pointerType === "touch") {
        _this2.dispatchEvent(e, "touchstart");
      } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
        var isRightButton = e.button === 2;
        _this2.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");
      }
      var trackingData = _this2.trackingData(from.pointerId);
      trackingData.pressTargetsByButton[from.button] = e.composedPath();
      _this2.freeEvent(e);
    };
    this.onPointerUp = function(from) {
      var now = clock.now();
      var e = _this2.createPointerEvent(from, void 0, void 0, _this2.context.config.alwaysTriggerPointerEventOnCanvas ? _this2.rootTarget : void 0);
      _this2.dispatchEvent(e, "pointerup");
      if (e.pointerType === "touch") {
        _this2.dispatchEvent(e, "touchend");
      } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
        var isRightButton = e.button === 2;
        _this2.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");
      }
      var trackingData = _this2.trackingData(from.pointerId);
      var pressTarget = _this2.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
      var clickTarget = pressTarget;
      if (pressTarget && !e.composedPath().includes(pressTarget)) {
        var currentTarget = pressTarget;
        while (currentTarget && !e.composedPath().includes(currentTarget)) {
          e.currentTarget = currentTarget;
          _this2.notifyTarget(e, "pointerupoutside");
          if (e.pointerType === "touch") {
            _this2.notifyTarget(e, "touchendoutside");
          } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
            var _isRightButton = e.button === 2;
            _this2.notifyTarget(e, _isRightButton ? "rightupoutside" : "mouseupoutside");
          }
          if (Node.isNode(currentTarget)) {
            currentTarget = currentTarget.parentNode;
          }
        }
        delete trackingData.pressTargetsByButton[from.button];
        clickTarget = currentTarget;
      }
      if (clickTarget) {
        var _e$detail;
        var clickEvent = _this2.clonePointerEvent(e, "click");
        clickEvent.target = clickTarget;
        clickEvent.path = [];
        if (!trackingData.clicksByButton[from.button]) {
          trackingData.clicksByButton[from.button] = {
            clickCount: 0,
            target: clickEvent.target,
            timeStamp: now
          };
        }
        var canvas = _this2.context.renderingContext.root.ownerDocument.defaultView;
        var clickHistory = trackingData.clicksByButton[from.button];
        if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < canvas.getConfig().dblClickSpeed) {
          ++clickHistory.clickCount;
        } else {
          clickHistory.clickCount = 1;
        }
        clickHistory.target = clickEvent.target;
        clickHistory.timeStamp = now;
        clickEvent.detail = clickHistory.clickCount;
        if (!((_e$detail = e.detail) !== null && _e$detail !== void 0 && _e$detail.preventClick)) {
          if (!_this2.context.config.useNativeClickEvent && (clickEvent.pointerType === "mouse" || clickEvent.pointerType === "touch")) {
            _this2.dispatchEvent(clickEvent, "click");
          }
          _this2.dispatchEvent(clickEvent, "pointertap");
        }
        _this2.freeEvent(clickEvent);
      }
      _this2.freeEvent(e);
    };
    this.onPointerMove = function(from) {
      var e = _this2.createPointerEvent(from, void 0, void 0, _this2.context.config.alwaysTriggerPointerEventOnCanvas ? _this2.rootTarget : void 0);
      var isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
      var trackingData = _this2.trackingData(from.pointerId);
      var outTarget = _this2.findMountedTarget(trackingData.overTargets);
      if (trackingData.overTargets && outTarget !== e.target) {
        var outType = from.type === "mousemove" ? "mouseout" : "pointerout";
        var outEvent = _this2.createPointerEvent(from, outType, outTarget || void 0);
        _this2.dispatchEvent(outEvent, "pointerout");
        if (isMouse) _this2.dispatchEvent(outEvent, "mouseout");
        if (!e.composedPath().includes(outTarget)) {
          var leaveEvent = _this2.createPointerEvent(from, "pointerleave", outTarget || void 0);
          leaveEvent.eventPhase = leaveEvent.AT_TARGET;
          while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {
            leaveEvent.currentTarget = leaveEvent.target;
            _this2.notifyTarget(leaveEvent);
            if (isMouse) {
              _this2.notifyTarget(leaveEvent, "mouseleave");
            }
            if (Node.isNode(leaveEvent.target)) {
              leaveEvent.target = leaveEvent.target.parentNode;
            }
          }
          _this2.freeEvent(leaveEvent);
        }
        _this2.freeEvent(outEvent);
      }
      if (outTarget !== e.target) {
        var overType = from.type === "mousemove" ? "mouseover" : "pointerover";
        var overEvent = _this2.clonePointerEvent(e, overType);
        _this2.dispatchEvent(overEvent, "pointerover");
        if (isMouse) _this2.dispatchEvent(overEvent, "mouseover");
        var overTargetAncestor = outTarget && Node.isNode(outTarget) && outTarget.parentNode;
        while (overTargetAncestor && overTargetAncestor !== (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
          if (overTargetAncestor === e.target) break;
          overTargetAncestor = overTargetAncestor.parentNode;
        }
        var didPointerEnter = !overTargetAncestor || overTargetAncestor === (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode);
        if (didPointerEnter) {
          var enterEvent = _this2.clonePointerEvent(e, "pointerenter");
          enterEvent.eventPhase = enterEvent.AT_TARGET;
          while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
            enterEvent.currentTarget = enterEvent.target;
            _this2.notifyTarget(enterEvent);
            if (isMouse) _this2.notifyTarget(enterEvent, "mouseenter");
            if (Node.isNode(enterEvent.target)) {
              enterEvent.target = enterEvent.target.parentNode;
            }
          }
          _this2.freeEvent(enterEvent);
        }
        _this2.freeEvent(overEvent);
      }
      _this2.dispatchEvent(e, "pointermove");
      if (e.pointerType === "touch") _this2.dispatchEvent(e, "touchmove");
      if (isMouse) {
        _this2.dispatchEvent(e, "mousemove");
        _this2.cursor = _this2.getCursor(e.target);
      }
      trackingData.overTargets = e.composedPath();
      _this2.freeEvent(e);
    };
    this.onPointerOut = function(from) {
      var trackingData = _this2.trackingData(from.pointerId);
      if (trackingData.overTargets) {
        var isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
        var outTarget = _this2.findMountedTarget(trackingData.overTargets);
        var outEvent = _this2.createPointerEvent(from, "pointerout", outTarget || void 0);
        _this2.dispatchEvent(outEvent);
        if (isMouse) _this2.dispatchEvent(outEvent, "mouseout");
        var leaveEvent = _this2.createPointerEvent(from, "pointerleave", outTarget || void 0);
        leaveEvent.eventPhase = leaveEvent.AT_TARGET;
        while (leaveEvent.target && leaveEvent.target !== (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
          leaveEvent.currentTarget = leaveEvent.target;
          _this2.notifyTarget(leaveEvent);
          if (isMouse) {
            _this2.notifyTarget(leaveEvent, "mouseleave");
          }
          if (Node.isNode(leaveEvent.target)) {
            leaveEvent.target = leaveEvent.target.parentNode;
          }
        }
        trackingData.overTargets = null;
        _this2.freeEvent(outEvent);
        _this2.freeEvent(leaveEvent);
      }
      _this2.cursor = null;
    };
    this.onPointerOver = function(from) {
      var trackingData = _this2.trackingData(from.pointerId);
      var e = _this2.createPointerEvent(from);
      var isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
      _this2.dispatchEvent(e, "pointerover");
      if (isMouse) _this2.dispatchEvent(e, "mouseover");
      if (e.pointerType === "mouse") _this2.cursor = _this2.getCursor(e.target);
      var enterEvent = _this2.clonePointerEvent(e, "pointerenter");
      enterEvent.eventPhase = enterEvent.AT_TARGET;
      while (enterEvent.target && enterEvent.target !== (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
        enterEvent.currentTarget = enterEvent.target;
        _this2.notifyTarget(enterEvent);
        if (isMouse) {
          _this2.notifyTarget(enterEvent, "mouseenter");
        }
        if (Node.isNode(enterEvent.target)) {
          enterEvent.target = enterEvent.target.parentNode;
        }
      }
      trackingData.overTargets = e.composedPath();
      _this2.freeEvent(e);
      _this2.freeEvent(enterEvent);
    };
    this.onPointerUpOutside = function(from) {
      var trackingData = _this2.trackingData(from.pointerId);
      var pressTarget = _this2.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
      var e = _this2.createPointerEvent(from);
      if (pressTarget) {
        var currentTarget = pressTarget;
        while (currentTarget) {
          e.currentTarget = currentTarget;
          _this2.notifyTarget(e, "pointerupoutside");
          if (e.pointerType === "touch") ;
          else if (e.pointerType === "mouse" || e.pointerType === "pen") {
            _this2.notifyTarget(e, e.button === 2 ? "rightupoutside" : "mouseupoutside");
          }
          if (Node.isNode(currentTarget)) {
            currentTarget = currentTarget.parentNode;
          }
        }
        delete trackingData.pressTargetsByButton[from.button];
      }
      _this2.freeEvent(e);
    };
    this.onWheel = function(from) {
      var wheelEvent = _this2.createWheelEvent(from);
      _this2.dispatchEvent(wheelEvent);
      _this2.freeEvent(wheelEvent);
    };
    this.onClick = function(from) {
      if (_this2.context.config.useNativeClickEvent) {
        var e = _this2.createPointerEvent(from);
        _this2.dispatchEvent(e);
        _this2.freeEvent(e);
      }
    };
    this.onPointerCancel = function(from) {
      var e = _this2.createPointerEvent(from, void 0, void 0, _this2.context.config.alwaysTriggerPointerEventOnCanvas ? _this2.rootTarget : void 0);
      _this2.dispatchEvent(e);
      _this2.freeEvent(e);
    };
    this.globalRuntime = globalRuntime;
    this.context = context;
  }
  return _createClass(EventService2, [{
    key: "init",
    value: function init() {
      this.rootTarget = this.context.renderingContext.root.parentNode;
      this.addEventMapping("pointerdown", this.onPointerDown);
      this.addEventMapping("pointerup", this.onPointerUp);
      this.addEventMapping("pointermove", this.onPointerMove);
      this.addEventMapping("pointerout", this.onPointerOut);
      this.addEventMapping("pointerleave", this.onPointerOut);
      this.addEventMapping("pointercancel", this.onPointerCancel);
      this.addEventMapping("pointerover", this.onPointerOver);
      this.addEventMapping("pointerupoutside", this.onPointerUpOutside);
      this.addEventMapping("wheel", this.onWheel);
      this.addEventMapping("click", this.onClick);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.mappingTable = {};
      this.mappingState = {};
      this.eventPool.clear();
    }
  }, {
    key: "getScale",
    value: function getScale() {
      var bbox = this.context.contextService.getBoundingClientRect();
      var scaleX2 = 1;
      var scaleY2 = 1;
      var $el = this.context.contextService.getDomElement();
      if ($el && bbox) {
        var offsetWidth = $el.offsetWidth, offsetHeight = $el.offsetHeight;
        if (offsetWidth && offsetHeight) {
          scaleX2 = bbox.width / offsetWidth;
          scaleY2 = bbox.height / offsetHeight;
        }
      }
      return {
        scaleX: scaleX2,
        scaleY: scaleY2,
        bbox
      };
    }
    /**
     * Should account for CSS Transform applied on container.
     * @see https://github.com/antvis/G/issues/1161
     * @see https://github.com/antvis/G/issues/1677
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/offsetX
     */
  }, {
    key: "client2Viewport",
    value: function client2Viewport(client) {
      var _this$getScale = this.getScale(), scaleX2 = _this$getScale.scaleX, scaleY2 = _this$getScale.scaleY, bbox = _this$getScale.bbox;
      return new Point((client.x - ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0)) / scaleX2, (client.y - ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0)) / scaleY2);
    }
  }, {
    key: "viewport2Client",
    value: function viewport2Client(canvas) {
      var _this$getScale2 = this.getScale(), scaleX2 = _this$getScale2.scaleX, scaleY2 = _this$getScale2.scaleY, bbox = _this$getScale2.bbox;
      return new Point((canvas.x + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0)) * scaleX2, (canvas.y + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0)) * scaleY2);
    }
  }, {
    key: "viewport2Canvas",
    value: function viewport2Canvas(_ref) {
      var x3 = _ref.x, y3 = _ref.y;
      var canvas = this.rootTarget.defaultView;
      var camera = canvas.getCamera();
      var _this$context$config = this.context.config, width = _this$context$config.width, height = _this$context$config.height;
      var projectionMatrixInverse = camera.getPerspectiveInverse();
      var worldMatrix = camera.getWorldTransform();
      var vpMatrix = mat4_exports.multiply(this.tmpMatrix, worldMatrix, projectionMatrixInverse);
      var viewport = vec3_exports.set(this.tmpVec3, x3 / width * 2 - 1, (1 - y3 / height) * 2 - 1, 0);
      vec3_exports.transformMat4(viewport, viewport, vpMatrix);
      return new Point(viewport[0], viewport[1]);
    }
  }, {
    key: "canvas2Viewport",
    value: function canvas2Viewport(canvasP) {
      var canvas = this.rootTarget.defaultView;
      var camera = canvas.getCamera();
      var projectionMatrix = camera.getPerspective();
      var viewMatrix = camera.getViewTransform();
      var vpMatrix = mat4_exports.multiply(this.tmpMatrix, projectionMatrix, viewMatrix);
      var clip = vec3_exports.set(this.tmpVec3, canvasP.x, canvasP.y, 0);
      vec3_exports.transformMat4(this.tmpVec3, this.tmpVec3, vpMatrix);
      var _this$context$config2 = this.context.config, width = _this$context$config2.width, height = _this$context$config2.height;
      return new Point((clip[0] + 1) / 2 * width, (1 - (clip[1] + 1) / 2) * height);
    }
  }, {
    key: "setPickHandler",
    value: function setPickHandler(pickHandler) {
      this.pickHandler = pickHandler;
    }
  }, {
    key: "addEventMapping",
    value: function addEventMapping(type, fn) {
      if (!this.mappingTable[type]) {
        this.mappingTable[type] = [];
      }
      this.mappingTable[type].push({
        fn,
        priority: 0
      });
      this.mappingTable[type].sort(function(a2, b) {
        return a2.priority - b.priority;
      });
    }
  }, {
    key: "mapEvent",
    value: function mapEvent(e) {
      if (!this.rootTarget) {
        return;
      }
      var mappers = this.mappingTable[e.type];
      if (mappers) {
        for (var i = 0, j = mappers.length; i < j; i++) {
          mappers[i].fn(e);
        }
      } else {
        console.warn("[EventService]: Event mapping not defined for ".concat(e.type));
      }
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(e, type, skipPropagate) {
      if (!skipPropagate) {
        e.propagationStopped = false;
        e.propagationImmediatelyStopped = false;
        this.propagate(e, type);
      } else {
        e.eventPhase = e.AT_TARGET;
        var canvas = this.rootTarget.defaultView || null;
        e.currentTarget = canvas;
        this.notifyListeners(e, type);
      }
    }
  }, {
    key: "propagate",
    value: function propagate(e, type) {
      if (!e.target) {
        return;
      }
      var composedPath = e.composedPath();
      e.eventPhase = e.CAPTURING_PHASE;
      for (var i = composedPath.length - 1; i >= 1; i--) {
        e.currentTarget = composedPath[i];
        this.notifyTarget(e, type);
        if (e.propagationStopped || e.propagationImmediatelyStopped) return;
      }
      e.eventPhase = e.AT_TARGET;
      e.currentTarget = e.target;
      this.notifyTarget(e, type);
      if (e.propagationStopped || e.propagationImmediatelyStopped) return;
      var index2 = composedPath.indexOf(e.currentTarget);
      e.eventPhase = e.BUBBLING_PHASE;
      for (var _i = index2 + 1; _i < composedPath.length; _i++) {
        e.currentTarget = composedPath[_i];
        this.notifyTarget(e, type);
        if (e.propagationStopped || e.propagationImmediatelyStopped) return;
      }
    }
  }, {
    key: "propagationPath",
    value: function propagationPath(target) {
      var propagationPath2 = [target];
      var canvas = this.rootTarget.defaultView || null;
      if (canvas && canvas === target) {
        propagationPath2.unshift(canvas.document);
        return propagationPath2;
      }
      for (var i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {
        if (Node.isNode(target) && target.parentNode) {
          propagationPath2.push(target.parentNode);
          target = target.parentNode;
        }
      }
      if (canvas) {
        propagationPath2.push(canvas);
      }
      return propagationPath2;
    }
  }, {
    key: "hitTest",
    value: function hitTest(position) {
      var viewportX = position.viewportX, viewportY = position.viewportY;
      var _this$context$config3 = this.context.config, width = _this$context$config3.width, height = _this$context$config3.height, disableHitTesting = _this$context$config3.disableHitTesting;
      if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
        return null;
      }
      return !disableHitTesting && this.pickHandler(position) || this.rootTarget || // return Document
      null;
    }
    /**
     * whether the native event trigger came from Canvas,
     * should account for HTML shape
     */
  }, {
    key: "isNativeEventFromCanvas",
    value: function isNativeEventFromCanvas($el, nativeEvent) {
      var _target;
      var target = nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.target;
      if ((_target = target) !== null && _target !== void 0 && _target.shadowRoot) {
        target = nativeEvent.composedPath()[0];
      }
      if (target) {
        if (target === $el) {
          return true;
        }
        if ($el && $el.contains) {
          return $el.contains(target);
        }
      }
      if (nativeEvent !== null && nativeEvent !== void 0 && nativeEvent.composedPath) {
        return nativeEvent.composedPath().indexOf($el) > -1;
      }
      return false;
    }
    /**
     * Find HTML from composed path in native UI event.
     */
  }, {
    key: "getExistedHTML",
    value: function getExistedHTML(event) {
      if (event.nativeEvent.composedPath) {
        for (var _i2 = 0, _arr = event.nativeEvent.composedPath(); _i2 < _arr.length; _i2++) {
          var eventTarget = _arr[_i2];
          var existed = this.nativeHTMLMap.get(eventTarget);
          if (existed) {
            return existed;
          }
        }
      }
      return null;
    }
  }, {
    key: "pickTarget",
    value: function pickTarget(event) {
      return this.hitTest({
        clientX: event.clientX,
        clientY: event.clientY,
        viewportX: event.viewportX,
        viewportY: event.viewportY,
        x: event.canvasX,
        y: event.canvasY
      });
    }
  }, {
    key: "createPointerEvent",
    value: function createPointerEvent(from, type, target, fallbackTarget) {
      var event = this.allocateEvent(FederatedPointerEvent);
      this.copyPointerData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from;
      var existedHTML = this.getExistedHTML(event);
      var $el = this.context.contextService.getDomElement();
      event.target = target !== null && target !== void 0 ? target : existedHTML || this.isNativeEventFromCanvas($el, event.nativeEvent) && this.pickTarget(event) || fallbackTarget;
      if (typeof type === "string") {
        event.type = type;
      }
      return event;
    }
  }, {
    key: "createWheelEvent",
    value: function createWheelEvent(from) {
      var event = this.allocateEvent(FederatedWheelEvent);
      this.copyWheelData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from;
      var existedHTML = this.getExistedHTML(event);
      var $el = this.context.contextService.getDomElement();
      event.target = existedHTML || this.isNativeEventFromCanvas($el, event.nativeEvent) && this.pickTarget(event);
      return event;
    }
  }, {
    key: "trackingData",
    value: function trackingData(id3) {
      if (!this.mappingState.trackingData[id3]) {
        this.mappingState.trackingData[id3] = {
          pressTargetsByButton: {},
          clicksByButton: {},
          overTarget: null
        };
      }
      return this.mappingState.trackingData[id3];
    }
  }, {
    key: "cloneWheelEvent",
    value: function cloneWheelEvent(from) {
      var event = this.allocateEvent(FederatedWheelEvent);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from.originalEvent;
      this.copyWheelData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.target = from.target;
      event.path = from.composedPath().slice();
      event.type = from.type;
      return event;
    }
  }, {
    key: "clonePointerEvent",
    value: function clonePointerEvent(from, type) {
      var event = this.allocateEvent(FederatedPointerEvent);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from.originalEvent;
      this.copyPointerData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.target = from.target;
      event.path = from.composedPath().slice();
      event.type = type !== null && type !== void 0 ? type : event.type;
      return event;
    }
  }, {
    key: "copyPointerData",
    value: function copyPointerData(from, to) {
      to.pointerId = from.pointerId;
      to.width = from.width;
      to.height = from.height;
      to.isPrimary = from.isPrimary;
      to.pointerType = from.pointerType;
      to.pressure = from.pressure;
      to.tangentialPressure = from.tangentialPressure;
      to.tiltX = from.tiltX;
      to.tiltY = from.tiltY;
      to.twist = from.twist;
    }
  }, {
    key: "copyMouseData",
    value: function copyMouseData(from, to) {
      to.altKey = from.altKey;
      to.button = from.button;
      to.buttons = from.buttons;
      to.ctrlKey = from.ctrlKey;
      to.metaKey = from.metaKey;
      to.shiftKey = from.shiftKey;
      to.client.copyFrom(from.client);
      to.movement.copyFrom(from.movement);
      to.canvas.copyFrom(from.canvas);
      to.screen.copyFrom(from.screen);
      to.global.copyFrom(from.global);
      to.offset.copyFrom(from.offset);
    }
  }, {
    key: "copyWheelData",
    value: function copyWheelData(from, to) {
      to.deltaMode = from.deltaMode;
      to.deltaX = from.deltaX;
      to.deltaY = from.deltaY;
      to.deltaZ = from.deltaZ;
    }
  }, {
    key: "copyData",
    value: function copyData(from, to) {
      to.isTrusted = from.isTrusted;
      to.timeStamp = clock.now();
      to.type = from.type;
      to.detail = from.detail;
      to.view = from.view;
      to.page.copyFrom(from.page);
      to.viewport.copyFrom(from.viewport);
    }
  }, {
    key: "allocateEvent",
    value: function allocateEvent(constructor) {
      if (!this.eventPool.has(constructor)) {
        this.eventPool.set(constructor, []);
      }
      var event = this.eventPool.get(constructor).pop() || new constructor(this);
      event.eventPhase = event.NONE;
      event.currentTarget = null;
      event.path = [];
      event.target = null;
      return event;
    }
  }, {
    key: "freeEvent",
    value: function freeEvent(event) {
      if (event.manager !== this) throw new Error("It is illegal to free an event not managed by this EventBoundary!");
      var constructor = event.constructor;
      if (!this.eventPool.has(constructor)) {
        this.eventPool.set(constructor, []);
      }
      this.eventPool.get(constructor).push(event);
    }
  }, {
    key: "notifyTarget",
    value: function notifyTarget(e, type) {
      type = type !== null && type !== void 0 ? type : e.type;
      var key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? "".concat(type, "capture") : type;
      this.notifyListeners(e, key);
      if (e.eventPhase === e.AT_TARGET) {
        this.notifyListeners(e, type);
      }
    }
  }, {
    key: "notifyListeners",
    value: function notifyListeners(e, type) {
      var emitter = e.currentTarget.emitter;
      var listeners = emitter._events[type];
      if (!listeners) return;
      if ("fn" in listeners) {
        if (listeners.once) {
          emitter.removeListener(type, listeners.fn, void 0, true);
        }
        listeners.fn.call(e.currentTarget || listeners.context, e);
      } else {
        for (var i = 0; i < listeners.length && !e.propagationImmediatelyStopped; i++) {
          if (listeners[i].once) {
            emitter.removeListener(type, listeners[i].fn, void 0, true);
          }
          listeners[i].fn.call(e.currentTarget || listeners[i].context, e);
        }
      }
    }
    /**
     * some detached nodes may exist in propagation path, need to skip them
     */
  }, {
    key: "findMountedTarget",
    value: function findMountedTarget(propagationPath) {
      if (!propagationPath) {
        return null;
      }
      var currentTarget = propagationPath[propagationPath.length - 1];
      for (var i = propagationPath.length - 2; i >= 0; i--) {
        var target = propagationPath[i];
        if (target === this.rootTarget || Node.isNode(target) && target.parentNode === currentTarget) {
          currentTarget = propagationPath[i];
        } else {
          break;
        }
      }
      return currentTarget;
    }
  }, {
    key: "getCursor",
    value: function getCursor(target) {
      var tmp2 = target;
      while (tmp2) {
        var cursor = isElement2(tmp2) && tmp2.getAttribute("cursor");
        if (cursor) {
          return cursor;
        }
        tmp2 = Node.isNode(tmp2) && tmp2.parentNode;
      }
    }
  }]);
}();
var OffscreenCanvasCreator = function() {
  function OffscreenCanvasCreator2() {
    _classCallCheck(this, OffscreenCanvasCreator2);
  }
  return _createClass(OffscreenCanvasCreator2, [{
    key: "getOrCreateCanvas",
    value: function getOrCreateCanvas(offscreenCanvas, contextAttributes) {
      if (this.canvas) {
        return this.canvas;
      }
      if (offscreenCanvas || runtime.offscreenCanvas) {
        this.canvas = offscreenCanvas || runtime.offscreenCanvas;
        this.context = this.canvas.getContext("2d", _objectSpread2({
          willReadFrequently: true
        }, contextAttributes));
      } else {
        try {
          this.canvas = new window.OffscreenCanvas(0, 0);
          this.context = this.canvas.getContext("2d", _objectSpread2({
            willReadFrequently: true
          }, contextAttributes));
          if (!this.context || !this.context.measureText) {
            this.canvas = document.createElement("canvas");
            this.context = this.canvas.getContext("2d");
          }
        } catch (_unused) {
          this.canvas = document.createElement("canvas");
          this.context = this.canvas.getContext("2d", _objectSpread2({
            willReadFrequently: true
          }, contextAttributes));
        }
      }
      this.canvas.width = 10;
      this.canvas.height = 10;
      return this.canvas;
    }
  }, {
    key: "getOrCreateContext",
    value: function getOrCreateContext(offscreenCanvas, contextAttributes) {
      if (this.context) {
        return this.context;
      }
      this.getOrCreateCanvas(offscreenCanvas, contextAttributes);
      return this.context;
    }
  }], [{
    key: "createCanvas",
    value: (
      /**
       * @returns new canvas instance
       */
      function createCanvas() {
        try {
          return new window.OffscreenCanvas(0, 0);
        } catch (_unused2) {
        }
        try {
          return document.createElement("canvas");
        } catch (_unused3) {
        }
        return null;
      }
    )
  }]);
}();
var RenderReason = function(RenderReason2) {
  RenderReason2[RenderReason2["CAMERA_CHANGED"] = 0] = "CAMERA_CHANGED";
  RenderReason2[RenderReason2["DISPLAY_OBJECT_CHANGED"] = 1] = "DISPLAY_OBJECT_CHANGED";
  RenderReason2[RenderReason2["NONE"] = 2] = "NONE";
  return RenderReason2;
}({});
var RenderingService = function() {
  function RenderingService2(globalRuntime, context) {
    _classCallCheck(this, RenderingService2);
    this.inited = false;
    this.stats = {
      /**
       * total display objects in scenegraph
       */
      total: 0,
      /**
       * number of display objects need to render in current frame
       */
      rendered: 0
    };
    this.zIndexCounter = 0;
    this.hooks = {
      /**
       * called before any frame rendered
       */
      init: new SyncHook(),
      initAsync: new AsyncParallelHook(),
      /**
       * only dirty object which has sth changed will be rendered
       */
      dirtycheck: new SyncWaterfallHook(),
      /**
       * do culling
       */
      cull: new SyncWaterfallHook(),
      /**
       * called at beginning of each frame, won't get called if nothing to re-render
       */
      beginFrame: new SyncHook(),
      /**
       * called before every dirty object get rendered
       */
      beforeRender: new SyncHook(),
      /**
       * called when every dirty object rendering even it's culled
       */
      render: new SyncHook(),
      /**
       * called after every dirty object get rendered
       */
      afterRender: new SyncHook(),
      /**
       * commit - draw the result on the canvas
       */
      endFrame: new SyncHook(),
      destroy: new SyncHook(),
      /**
       * use async but faster method such as GPU-based picking in `g-plugin-device-renderer`
       */
      pick: new AsyncSeriesWaterfallHook(),
      /**
       * Unsafe but sync version of pick.
       */
      pickSync: new SyncWaterfallHook(),
      /**
       * used in event system
       */
      pointerDown: new SyncHook(),
      pointerUp: new SyncHook(),
      pointerMove: new SyncHook(),
      pointerOut: new SyncHook(),
      pointerOver: new SyncHook(),
      pointerWheel: new SyncHook(),
      pointerCancel: new SyncHook(),
      click: new SyncHook()
    };
    this.globalRuntime = globalRuntime;
    this.context = context;
  }
  return _createClass(RenderingService2, [{
    key: "init",
    value: function init(callback) {
      var _this2 = this;
      var context = _objectSpread2(_objectSpread2({}, this.globalRuntime), this.context);
      this.context.renderingPlugins.forEach(function(plugin) {
        plugin.apply(context, _this2.globalRuntime);
      });
      this.hooks.init.call();
      if (this.hooks.initAsync.getCallbacksNum() === 0) {
        this.inited = true;
        callback();
      } else {
        this.hooks.initAsync.promise().then(function() {
          _this2.inited = true;
          callback();
        })["catch"](function(err) {
        });
      }
    }
  }, {
    key: "getStats",
    value: function getStats() {
      return this.stats;
    }
    /**
     * Meet the following conditions:
     * * disable DirtyRectangleRendering
     * * camera changed
     */
  }, {
    key: "disableDirtyRectangleRendering",
    value: function disableDirtyRectangleRendering() {
      var renderer = this.context.config.renderer;
      var _renderer$getConfig = renderer.getConfig(), enableDirtyRectangleRendering = _renderer$getConfig.enableDirtyRectangleRendering;
      return !enableDirtyRectangleRendering || this.context.renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED);
    }
  }, {
    key: "render",
    value: function render(canvasConfig, frame, rerenderCallback) {
      var _this2 = this;
      this.stats.total = 0;
      this.stats.rendered = 0;
      this.zIndexCounter = 0;
      var renderingContext = this.context.renderingContext;
      this.globalRuntime.sceneGraphService.syncHierarchy(renderingContext.root);
      this.globalRuntime.sceneGraphService.triggerPendingEvents();
      if (renderingContext.renderReasons.size && this.inited) {
        renderingContext.dirtyRectangleRenderingDisabled = this.disableDirtyRectangleRendering();
        var onlyCameraChanged = renderingContext.renderReasons.size === 1 && renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED);
        var shouldTriggerRenderHooks = !canvasConfig.disableRenderHooks || !onlyCameraChanged;
        if (shouldTriggerRenderHooks) {
          this.renderDisplayObject(renderingContext.root, canvasConfig, renderingContext);
        }
        this.hooks.beginFrame.call(frame);
        if (shouldTriggerRenderHooks) {
          renderingContext.renderListCurrentFrame.forEach(function(object) {
            _this2.hooks.beforeRender.call(object);
            _this2.hooks.render.call(object);
            _this2.hooks.afterRender.call(object);
          });
        }
        this.hooks.endFrame.call(frame);
        renderingContext.renderListCurrentFrame = [];
        renderingContext.renderReasons.clear();
        rerenderCallback();
      }
    }
  }, {
    key: "renderDisplayObject",
    value: function renderDisplayObject(displayObject, canvasConfig, renderingContext) {
      var self2 = this;
      var _canvasConfig$rendere = canvasConfig.renderer.getConfig(), enableDirtyCheck = _canvasConfig$rendere.enableDirtyCheck, enableCulling = _canvasConfig$rendere.enableCulling;
      function internalRenderSingleDisplayObject(object) {
        var renderable = object.renderable, sortable = object.sortable;
        var objectChanged = enableDirtyCheck ? (
          // @ts-ignore
          renderable.dirty || renderingContext.dirtyRectangleRenderingDisabled ? object : null
        ) : object;
        var objectToRender = null;
        if (objectChanged) {
          objectToRender = enableCulling ? self2.hooks.cull.call(objectChanged, self2.context.camera) : objectChanged;
          if (objectToRender) {
            self2.stats.rendered += 1;
            renderingContext.renderListCurrentFrame.push(objectToRender);
          }
        }
        object.dirty(false);
        sortable.renderOrder = self2.zIndexCounter;
        self2.zIndexCounter += 1;
        self2.stats.total += 1;
        if (sortable.dirty) {
          self2.sort(object, sortable);
          sortable.dirty = false;
          sortable.dirtyChildren = [];
          sortable.dirtyReason = void 0;
        }
      }
      var stack = [displayObject];
      while (stack.length > 0) {
        var _currentObject$sortab;
        var currentObject = stack.pop();
        internalRenderSingleDisplayObject(currentObject);
        var objects = ((_currentObject$sortab = currentObject.sortable) === null || _currentObject$sortab === void 0 || (_currentObject$sortab = _currentObject$sortab.sorted) === null || _currentObject$sortab === void 0 ? void 0 : _currentObject$sortab.length) > 0 ? currentObject.sortable.sorted : currentObject.childNodes;
        for (var i = objects.length - 1; i >= 0; i--) {
          stack.push(objects[i]);
        }
      }
    }
  }, {
    key: "sort",
    value: function sort(displayObject, sortable) {
      var _sortable$sorted, _sortable$sorted2;
      if ((sortable === null || sortable === void 0 || (_sortable$sorted = sortable.sorted) === null || _sortable$sorted === void 0 ? void 0 : _sortable$sorted.length) > 0 && sortable.dirtyReason !== SortReason.Z_INDEX_CHANGED) {
        sortable.dirtyChildren.forEach(function(child) {
          var sortIndex = sortable.sorted.indexOf(child);
          if (sortIndex > -1) {
            sortable.sorted.splice(sortIndex, 1);
          }
          var index2 = displayObject.childNodes.indexOf(child);
          if (index2 > -1) {
            if (sortable.sorted.length === 0) {
              sortable.sorted.push(child);
            } else {
              var _index = sortedIndex(sortable.sorted, child);
              sortable.sorted.splice(_index, 0, child);
            }
          }
        });
      } else {
        sortable.sorted = displayObject.childNodes.slice().sort(sortByZIndex);
      }
      if (((_sortable$sorted2 = sortable.sorted) === null || _sortable$sorted2 === void 0 ? void 0 : _sortable$sorted2.length) > 0 && displayObject.childNodes.filter(function(child) {
        return child.parsedStyle.zIndex;
      }).length === 0) {
        sortable.sorted = [];
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.inited = false;
      this.hooks.destroy.call();
      this.globalRuntime.sceneGraphService.clearPendingEvents();
    }
  }, {
    key: "dirtify",
    value: function dirtify() {
      this.context.renderingContext.renderReasons.add(RenderReason.DISPLAY_OBJECT_CHANGED);
    }
  }]);
}();
var ATTRIBUTE_REGEXP = /\[\s*(.*)=(.*)\s*\]/;
var DefaultSceneGraphSelector = function() {
  function DefaultSceneGraphSelector2() {
    _classCallCheck(this, DefaultSceneGraphSelector2);
  }
  return _createClass(DefaultSceneGraphSelector2, [{
    key: "selectOne",
    value: function selectOne(query, root2) {
      var _this2 = this;
      if (query.startsWith(".")) {
        return root2.find(function(node) {
          return ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this2.getIdOrClassname(query)) > -1;
        });
      }
      if (query.startsWith("#")) {
        return root2.find(function(node) {
          return node.id === _this2.getIdOrClassname(query);
        });
      }
      if (query.startsWith("[")) {
        var _this$getAttribute = this.getAttribute(query), name = _this$getAttribute.name, value = _this$getAttribute.value;
        if (name) {
          return root2.find(function(node) {
            return root2 !== node && (name === "name" ? node.name === value : _this2.attributeToString(node, name) === value);
          });
        }
        return null;
      }
      return root2.find(function(node) {
        return root2 !== node && node.nodeName === query;
      });
    }
  }, {
    key: "selectAll",
    value: function selectAll(query, root2) {
      var _this2 = this;
      if (query.startsWith(".")) {
        return root2.findAll(function(node) {
          return root2 !== node && ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this2.getIdOrClassname(query)) > -1;
        });
      }
      if (query.startsWith("#")) {
        return root2.findAll(function(node) {
          return root2 !== node && node.id === _this2.getIdOrClassname(query);
        });
      }
      if (query.startsWith("[")) {
        var _this$getAttribute2 = this.getAttribute(query), name = _this$getAttribute2.name, value = _this$getAttribute2.value;
        if (name) {
          return root2.findAll(function(node) {
            return root2 !== node && (name === "name" ? node.name === value : _this2.attributeToString(node, name) === value);
          });
        }
        return [];
      }
      return root2.findAll(function(node) {
        return root2 !== node && node.nodeName === query;
      });
    }
  }, {
    key: "is",
    value: function is(query, node) {
      if (query.startsWith(".")) {
        return node.className === this.getIdOrClassname(query);
      }
      if (query.startsWith("#")) {
        return node.id === this.getIdOrClassname(query);
      }
      if (query.startsWith("[")) {
        var _this$getAttribute3 = this.getAttribute(query), name = _this$getAttribute3.name, value = _this$getAttribute3.value;
        return name === "name" ? node.name === value : this.attributeToString(node, name) === value;
      }
      return node.nodeName === query;
    }
  }, {
    key: "getIdOrClassname",
    value: function getIdOrClassname(query) {
      return query.substring(1);
    }
  }, {
    key: "getAttribute",
    value: function getAttribute(query) {
      var matches = query.match(ATTRIBUTE_REGEXP);
      var name = "";
      var value = "";
      if (matches && matches.length > 2) {
        name = matches[1].replace(/"/g, "");
        value = matches[2].replace(/"/g, "");
      }
      return {
        name,
        value
      };
    }
  }, {
    key: "attributeToString",
    value: function attributeToString(node, name) {
      if (!node.getAttribute) {
        return "";
      }
      var value = node.getAttribute(name);
      if (isNil(value)) {
        return "";
      }
      if (value.toString) {
        return value.toString();
      }
      return "";
    }
  }]);
}();
var ElementEvent = function(ElementEvent2) {
  ElementEvent2["ATTR_MODIFIED"] = "DOMAttrModified";
  ElementEvent2["INSERTED"] = "DOMNodeInserted";
  ElementEvent2["MOUNTED"] = "DOMNodeInsertedIntoDocument";
  ElementEvent2["REMOVED"] = "removed";
  ElementEvent2["UNMOUNTED"] = "DOMNodeRemovedFromDocument";
  ElementEvent2["REPARENT"] = "reparent";
  ElementEvent2["DESTROY"] = "destroy";
  ElementEvent2["BOUNDS_CHANGED"] = "bounds-changed";
  ElementEvent2["CULLED"] = "culled";
  return ElementEvent2;
}({});
var MutationEvent = function(_FederatedEvent) {
  function MutationEvent2(typeArg, relatedNode, prevValue, newValue, attrName, attrChange, prevParsedValue, newParsedValue) {
    var _this2;
    _classCallCheck(this, MutationEvent2);
    _this2 = _callSuper(this, MutationEvent2, [null]);
    _this2.relatedNode = relatedNode;
    _this2.prevValue = prevValue;
    _this2.newValue = newValue;
    _this2.attrName = attrName;
    _this2.attrChange = attrChange;
    _this2.prevParsedValue = prevParsedValue;
    _this2.newParsedValue = newParsedValue;
    _this2.type = typeArg;
    return _this2;
  }
  _inherits(MutationEvent2, _FederatedEvent);
  return _createClass(MutationEvent2);
}(FederatedEvent);
MutationEvent.ADDITION = 2;
MutationEvent.MODIFICATION = 1;
MutationEvent.REMOVAL = 3;
var reparentEvent = new MutationEvent(ElementEvent.REPARENT, null, "", "", "", 0, "", "");
var $vec2Zero = vec2_exports.create();
var $vec3Zero = vec3_exports.create();
var $vec3One = vec3_exports.fromValues(1, 1, 1);
var $mat4Identity = mat4_exports.create();
var $vec2 = vec2_exports.create();
var $vec3$1 = vec3_exports.create();
var $mat4 = mat4_exports.create();
var $quat$1 = quat_exports.create();
var $setLocalTransform_1 = vec3_exports.create();
var $setLocalTransform_2 = quat_exports.create();
var $setLocalTransform_3 = vec3_exports.create();
var $setLocalPosition = vec3_exports.create();
var $setPosition_1 = vec3_exports.create();
var $setPosition_ParentInvertMatrix = mat4_exports.create();
var $setEulerAngles_InvParentRot = quat_exports.create();
var $rotateLocal = quat_exports.create();
var $rotate_ParentInvertRotation = quat_exports.create();
var $triggerPendingEvents_detail = {
  affectChildren: true
};
var DefaultSceneGraphService = function() {
  function DefaultSceneGraphService2(runtime2) {
    _classCallCheck(this, DefaultSceneGraphService2);
    this.pendingEvents = /* @__PURE__ */ new Map();
    this.boundsChangedEvent = new CustomEvent(ElementEvent.BOUNDS_CHANGED);
    this.displayObjectDependencyMap = /* @__PURE__ */ new WeakMap();
    this.runtime = runtime2;
  }
  return _createClass(DefaultSceneGraphService2, [{
    key: "matches",
    value: function matches(query, root2) {
      return this.runtime.sceneGraphSelector.is(query, root2);
    }
  }, {
    key: "querySelector",
    value: function querySelector(query, root2) {
      return this.runtime.sceneGraphSelector.selectOne(query, root2);
    }
  }, {
    key: "querySelectorAll",
    value: function querySelectorAll(query, root2) {
      return this.runtime.sceneGraphSelector.selectAll(query, root2);
    }
  }, {
    key: "attach",
    value: function attach(child, parent, index2) {
      var _sortable$sorted;
      var detached = false;
      if (child.parentNode) {
        detached = child.parentNode !== parent;
        this.detach(child);
      }
      var isChildFragment = child.nodeName === Shape.FRAGMENT;
      var isAttachToFragment = isInFragment(parent);
      child.parentNode = parent;
      var nodes = isChildFragment ? child.childNodes : [child];
      if (isNumber(index2)) {
        nodes.forEach(function(node) {
          parent.childNodes.splice(index2, 0, node);
          node.parentNode = parent;
        });
      } else {
        nodes.forEach(function(node) {
          parent.childNodes.push(node);
          node.parentNode = parent;
        });
      }
      var _ref = parent, sortable = _ref.sortable;
      if (sortable !== null && sortable !== void 0 && (_sortable$sorted = sortable.sorted) !== null && _sortable$sorted !== void 0 && _sortable$sorted.length || sortable.dirty || child.parsedStyle.zIndex) {
        if (sortable.dirtyChildren.indexOf(child) === -1) {
          sortable.dirtyChildren.push(child);
        }
        sortable.dirty = true;
        sortable.dirtyReason = SortReason.ADDED;
      }
      if (isAttachToFragment) return;
      if (isChildFragment) {
        this.dirtifyFragment(child);
      } else {
        var transform2 = child.transformable;
        if (transform2) {
          this.dirtyWorldTransform(child, transform2);
        }
      }
      if (detached) {
        var _parent$ownerDocument;
        var enableCancelEventPropagation = ((_parent$ownerDocument = parent.ownerDocument) === null || _parent$ownerDocument === void 0 || (_parent$ownerDocument = _parent$ownerDocument.defaultView) === null || _parent$ownerDocument === void 0 || (_parent$ownerDocument = _parent$ownerDocument.getConfig()) === null || _parent$ownerDocument === void 0 || (_parent$ownerDocument = _parent$ownerDocument.future) === null || _parent$ownerDocument === void 0 ? void 0 : _parent$ownerDocument.experimentalCancelEventPropagation) === true;
        child.dispatchEvent(reparentEvent, enableCancelEventPropagation, enableCancelEventPropagation);
      }
    }
  }, {
    key: "detach",
    value: function detach(child) {
      var _sortable$sorted2, _style;
      if (!child.parentNode) {
        return;
      }
      var transform2 = child.transformable;
      var _ref2 = child.parentNode, sortable = _ref2.sortable;
      if (sortable !== null && sortable !== void 0 && (_sortable$sorted2 = sortable.sorted) !== null && _sortable$sorted2 !== void 0 && _sortable$sorted2.length || (_style = child.style) !== null && _style !== void 0 && _style.zIndex) {
        if (sortable.dirtyChildren.indexOf(child) === -1) {
          sortable.dirtyChildren.push(child);
        }
        sortable.dirty = true;
        sortable.dirtyReason = SortReason.REMOVED;
      }
      var index2 = child.parentNode.childNodes.indexOf(child);
      if (index2 > -1) {
        child.parentNode.childNodes.splice(index2, 1);
      }
      if (transform2) {
        this.dirtyWorldTransform(child, transform2);
      }
      child.parentNode = null;
    }
    // #region local-transform ----------------------------------------------------------------
  }, {
    key: "getLocalPosition",
    value: function getLocalPosition(element) {
      return element.transformable.localPosition;
    }
  }, {
    key: "getLocalRotation",
    value: function getLocalRotation(element) {
      return element.transformable.localRotation;
    }
  }, {
    key: "getLocalScale",
    value: function getLocalScale(element) {
      return element.transformable.localScale;
    }
  }, {
    key: "getLocalSkew",
    value: function getLocalSkew(element) {
      return element.transformable.localSkew;
    }
  }, {
    key: "getLocalTransform",
    value: function getLocalTransform(element) {
      var transform2 = element.transformable;
      updateLocalTransform(transform2);
      return transform2.localTransform;
    }
    /**
     * move to position in local space
     */
  }, {
    key: "setLocalPosition",
    value: function setLocalPosition(element, position) {
      var _position$;
      var dirtify = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var transform2 = element.transformable;
      $setLocalPosition[0] = position[0];
      $setLocalPosition[1] = position[1];
      $setLocalPosition[2] = (_position$ = position[2]) !== null && _position$ !== void 0 ? _position$ : 0;
      if (vec3_exports.equals(transform2.localPosition, $setLocalPosition)) {
        return;
      }
      vec3_exports.copy(transform2.localPosition, $setLocalPosition);
      if (dirtify) {
        this.dirtyLocalTransform(element, transform2);
      }
    }
    /**
     * translate in local space
     *
     * @example
     * ```
     * translateLocal(x, y, z)
     * translateLocal(vec3(x, y, z))
     * ```
     */
  }, {
    key: "translateLocal",
    value: function translateLocal(element, translation) {
      var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      if (typeof translation === "number") {
        translation = vec3_exports.fromValues(translation, y3, z);
      }
      var transform2 = element.transformable;
      if (vec3_exports.equals(translation, $vec3Zero)) return;
      vec3_exports.transformQuat(translation, translation, transform2.localRotation);
      vec3_exports.add(transform2.localPosition, transform2.localPosition, translation);
      this.dirtyLocalTransform(element, transform2);
    }
  }, {
    key: "setLocalRotation",
    value: function setLocalRotation(element, rotation, y3, z, w) {
      var dirtify = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
      if (typeof rotation === "number") {
        rotation = quat_exports.set($quat$1, rotation, y3, z, w);
      }
      var transform2 = element.transformable;
      quat_exports.copy(transform2.localRotation, rotation);
      if (dirtify) {
        this.dirtyLocalTransform(element, transform2);
      }
    }
    /**
     * rotate in local space
     * @see @see https://docs.microsoft.com/en-us/windows/win32/api/directxmath/nf-directxmath-xmquaternionrotationrollpitchyaw
     */
  }, {
    key: "rotateLocal",
    value: function rotateLocal(element, degrees) {
      var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      if (typeof degrees === "number") {
        degrees = vec3_exports.fromValues(degrees, y3, z);
      }
      var transform2 = element.transformable;
      quat_exports.fromEuler($rotateLocal, degrees[0], degrees[1], degrees[2]);
      quat_exports.mul(transform2.localRotation, transform2.localRotation, $rotateLocal);
      this.dirtyLocalTransform(element, transform2);
    }
  }, {
    key: "setLocalScale",
    value: function setLocalScale(element, scaling) {
      var _scaling$;
      var dirtify = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var transform2 = element.transformable;
      vec3_exports.set($vec3$1, scaling[0], scaling[1], (_scaling$ = scaling[2]) !== null && _scaling$ !== void 0 ? _scaling$ : transform2.localScale[2]);
      if (vec3_exports.equals($vec3$1, transform2.localScale)) {
        return;
      }
      vec3_exports.copy(transform2.localScale, $vec3$1);
      if (dirtify) {
        this.dirtyLocalTransform(element, transform2);
      }
    }
    /**
     * scale in local space
     */
  }, {
    key: "scaleLocal",
    value: function scaleLocal(element, scaling) {
      var _scaling$2;
      var transform2 = element.transformable;
      vec3_exports.multiply(transform2.localScale, transform2.localScale, vec3_exports.set($vec3$1, scaling[0], scaling[1], (_scaling$2 = scaling[2]) !== null && _scaling$2 !== void 0 ? _scaling$2 : 1));
      this.dirtyLocalTransform(element, transform2);
    }
  }, {
    key: "setLocalSkew",
    value: function setLocalSkew(element, skew2, y3) {
      var dirtify = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      if (typeof skew2 === "number") {
        skew2 = vec2_exports.set($vec2, skew2, y3);
      }
      var transform2 = element.transformable;
      vec2_exports.copy(transform2.localSkew, skew2);
      if (dirtify) {
        this.dirtyLocalTransform(element, transform2);
      }
    }
    /**
     * set euler angles(degrees) in local space
     */
  }, {
    key: "setLocalEulerAngles",
    value: function setLocalEulerAngles(element, degrees) {
      var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var dirtify = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
      if (typeof degrees === "number") {
        degrees = vec3_exports.fromValues(degrees, y3, z);
      }
      var transform2 = element.transformable;
      quat_exports.fromEuler(transform2.localRotation, degrees[0], degrees[1], degrees[2]);
      if (dirtify) {
        this.dirtyLocalTransform(element, transform2);
      }
    }
  }, {
    key: "setLocalTransform",
    value: function setLocalTransform(element, transform2) {
      var t = mat4_exports.getTranslation($setLocalTransform_1, transform2);
      var r = mat4_exports.getRotation($setLocalTransform_2, transform2);
      var s2 = mat4_exports.getScaling($setLocalTransform_3, transform2);
      this.setLocalScale(element, s2, false);
      this.setLocalPosition(element, t, false);
      this.setLocalRotation(element, r, void 0, void 0, void 0, false);
      this.dirtyLocalTransform(element, element.transformable);
    }
  }, {
    key: "resetLocalTransform",
    value: function resetLocalTransform(element) {
      this.setLocalScale(element, $vec3One, false);
      this.setLocalPosition(element, $vec3Zero, false);
      this.setLocalEulerAngles(element, $vec3Zero, void 0, void 0, false);
      this.setLocalSkew(element, $vec2Zero, void 0, false);
      this.dirtyLocalTransform(element, element.transformable);
    }
    // #endregion local-transform
    // #region transform ----------------------------------------------------------------
  }, {
    key: "getPosition",
    value: function getPosition(element) {
      var transform2 = element.transformable;
      return mat4_exports.getTranslation(transform2.position, this.getWorldTransform(element, transform2));
    }
  }, {
    key: "getRotation",
    value: function getRotation2(element) {
      var transform2 = element.transformable;
      return mat4_exports.getRotation(transform2.rotation, this.getWorldTransform(element, transform2));
    }
  }, {
    key: "getScale",
    value: function getScale(element) {
      var transform2 = element.transformable;
      return mat4_exports.getScaling(transform2.scaling, this.getWorldTransform(element, transform2));
    }
  }, {
    key: "getOrigin",
    value: function getOrigin(element) {
      element.getGeometryBounds();
      return element.transformable.origin;
    }
  }, {
    key: "getWorldTransform",
    value: function getWorldTransform(element) {
      var transform2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : element.transformable;
      if (!transform2.localDirtyFlag && !transform2.dirtyFlag) {
        return transform2.worldTransform;
      }
      if (element.parentNode && element.parentNode.transformable) {
        this.getWorldTransform(element.parentNode);
      }
      this.internalUpdateTransform(element);
      return transform2.worldTransform;
    }
    /**
     * move to position in world space
     *
     * 对应 g 原版的 move/moveTo
     * @see https://github.com/antvis/g/blob/master/packages/g-base/src/abstract/element.ts#L684-L689
     */
  }, {
    key: "setPosition",
    value: function setPosition(element, position) {
      var _position$2;
      var transform2 = element.transformable;
      $setPosition_1[0] = position[0];
      $setPosition_1[1] = position[1];
      $setPosition_1[2] = (_position$2 = position[2]) !== null && _position$2 !== void 0 ? _position$2 : 0;
      if (vec3_exports.equals(this.getPosition(element), $setPosition_1)) {
        return;
      }
      vec3_exports.copy(transform2.position, $setPosition_1);
      if (element.parentNode === null || !element.parentNode.transformable) {
        vec3_exports.copy(transform2.localPosition, $setPosition_1);
      } else {
        var parentTransform = element.parentNode.transformable;
        mat4_exports.copy($setPosition_ParentInvertMatrix, parentTransform.worldTransform);
        mat4_exports.invert($setPosition_ParentInvertMatrix, $setPosition_ParentInvertMatrix);
        vec3_exports.transformMat4(transform2.localPosition, $setPosition_1, $setPosition_ParentInvertMatrix);
      }
      this.dirtyLocalTransform(element, transform2);
    }
    /**
     * translate in world space
     *
     * @example
     * ```
     * translate(x, y, z)
     * translate(vec3(x, y, z))
     * ```
     *
     * 对应 g 原版的 translate 2D
     * @see https://github.com/antvis/g/blob/master/packages/g-base/src/abstract/element.ts#L665-L676
     */
  }, {
    key: "translate",
    value: function translate5(element, translation) {
      var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      if (typeof translation === "number") {
        translation = vec3_exports.set($vec3$1, translation, y3, z);
      }
      if (vec3_exports.equals(translation, $vec3Zero)) return;
      vec3_exports.add($vec3$1, this.getPosition(element), translation);
      this.setPosition(element, $vec3$1);
    }
  }, {
    key: "setRotation",
    value: function setRotation(element, rotation, y3, z, w) {
      var transform2 = element.transformable;
      if (typeof rotation === "number") {
        rotation = quat_exports.fromValues(rotation, y3, z, w);
      }
      if (element.parentNode === null || !element.parentNode.transformable) {
        this.setLocalRotation(element, rotation);
      } else {
        var parentRot = this.getRotation(element.parentNode);
        quat_exports.copy($quat$1, parentRot);
        quat_exports.invert($quat$1, $quat$1);
        quat_exports.multiply(transform2.localRotation, $quat$1, rotation);
        quat_exports.normalize(transform2.localRotation, transform2.localRotation);
        this.dirtyLocalTransform(element, transform2);
      }
    }
    /**
     * rotate in world space
     */
  }, {
    key: "rotate",
    value: function rotate6(element, degrees) {
      var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      if (typeof degrees === "number") {
        degrees = vec3_exports.fromValues(degrees, y3, z);
      }
      var transform2 = element.transformable;
      if (element.parentNode === null || !element.parentNode.transformable) {
        this.rotateLocal(element, degrees);
      } else {
        var rotation = $quat$1;
        quat_exports.fromEuler(rotation, degrees[0], degrees[1], degrees[2]);
        var rot = this.getRotation(element);
        var parentRot = this.getRotation(element.parentNode);
        quat_exports.copy($rotate_ParentInvertRotation, parentRot);
        quat_exports.invert($rotate_ParentInvertRotation, $rotate_ParentInvertRotation);
        quat_exports.multiply(rotation, $rotate_ParentInvertRotation, rotation);
        quat_exports.multiply(transform2.localRotation, rotation, rot);
        quat_exports.normalize(transform2.localRotation, transform2.localRotation);
        this.dirtyLocalTransform(element, transform2);
      }
    }
    /**
     * same as pivot in Pixi.js
     *
     * @see https://stackoverflow.com/questions/40748452/how-to-change-css-transform-origin-but-preserve-transformation
     */
  }, {
    key: "setOrigin",
    value: function setOrigin(element, origin) {
      var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      if (typeof origin === "number") {
        origin = [origin, y3, z];
      }
      var transform2 = element.transformable;
      if (origin[0] === transform2.origin[0] && origin[1] === transform2.origin[1] && origin[2] === transform2.origin[2]) {
        return;
      }
      var originVec = transform2.origin;
      originVec[0] = origin[0];
      originVec[1] = origin[1];
      originVec[2] = origin[2] || 0;
      this.dirtyLocalTransform(element, transform2);
    }
    /**
     * set euler angles(degrees) in world space
     */
  }, {
    key: "setEulerAngles",
    value: function setEulerAngles(element, degrees) {
      var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      if (typeof degrees === "number") {
        degrees = vec3_exports.fromValues(degrees, y3, z);
      }
      var transform2 = element.transformable;
      if (element.parentNode === null || !element.parentNode.transformable) {
        this.setLocalEulerAngles(element, degrees);
      } else {
        quat_exports.fromEuler(transform2.localRotation, degrees[0], degrees[1], degrees[2]);
        var parentRotation = this.getRotation(element.parentNode);
        quat_exports.copy($setEulerAngles_InvParentRot, quat_exports.invert($quat$1, parentRotation));
        quat_exports.mul(transform2.localRotation, transform2.localRotation, $setEulerAngles_InvParentRot);
        this.dirtyLocalTransform(element, transform2);
      }
    }
    // #endregion transform
    // #region bbox ----------------------------------------------------------------
  }, {
    key: "getTransformedGeometryBounds",
    value: function getTransformedGeometryBounds(element) {
      var render = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var existedAABB = arguments.length > 2 ? arguments[2] : void 0;
      var bounds = this.getGeometryBounds(element, render);
      if (!AABB.isEmpty(bounds)) {
        var aabb = existedAABB || new AABB();
        aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
        return aabb;
      }
      return null;
    }
    /**
     * won't account for children
     */
  }, {
    key: "getGeometryBounds",
    value: function getGeometryBounds(element) {
      var render = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var _ref3 = element, geometry = _ref3.geometry;
      if (geometry.dirty) {
        runtime.styleValueRegistry.updateGeometry(element);
      }
      var bounds = render ? geometry.renderBounds : geometry.contentBounds || null;
      return bounds || new AABB();
    }
    /**
     * account for children in world space
     */
  }, {
    key: "getBounds",
    value: function getBounds2(element) {
      var _this2 = this;
      var render = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var _ref4 = element, renderable = _ref4.renderable;
      if (!renderable.boundsDirty && !render && renderable.bounds) {
        return renderable.bounds;
      }
      if (!renderable.renderBoundsDirty && render && renderable.renderBounds) {
        return renderable.renderBounds;
      }
      var existedAABB = render ? renderable.renderBounds : renderable.bounds;
      var aabb = this.getTransformedGeometryBounds(element, render, existedAABB);
      var children = element.childNodes;
      children.forEach(function(child) {
        var childBounds = _this2.getBounds(child, render);
        if (childBounds) {
          if (!aabb) {
            aabb = existedAABB || new AABB();
            aabb.update(childBounds.center, childBounds.halfExtents);
          } else {
            aabb.add(childBounds);
          }
        }
      });
      if (!aabb) {
        aabb = new AABB();
      }
      if (render) {
        var clipped = findClosestClipPathTarget(element);
        if (clipped) {
          var clipPathBounds = clipped.parsedStyle.clipPath.getBounds(render);
          if (!aabb) {
            aabb.update(clipPathBounds.center, clipPathBounds.halfExtents);
          } else if (clipPathBounds) {
            aabb = clipPathBounds.intersection(aabb);
          }
        }
      }
      if (render) {
        renderable.renderBounds = aabb;
        renderable.renderBoundsDirty = false;
      } else {
        renderable.bounds = aabb;
        renderable.boundsDirty = false;
      }
      return aabb;
    }
    /**
     * account for children in local space
     */
  }, {
    key: "getLocalBounds",
    value: function getLocalBounds(element) {
      if (element.parentNode) {
        var parentInvert = $mat4Identity;
        if (element.parentNode.transformable) {
          parentInvert = mat4_exports.invert($mat4, this.getWorldTransform(element.parentNode));
        }
        var bounds = this.getBounds(element);
        if (!AABB.isEmpty(bounds)) {
          var localBounds = new AABB();
          localBounds.setFromTransformedAABB(bounds, parentInvert);
          return localBounds;
        }
      }
      return this.getBounds(element);
    }
  }, {
    key: "getBoundingClientRect",
    value: function getBoundingClientRect(element) {
      var _element$ownerDocumen;
      var aabb;
      var bounds = this.getGeometryBounds(element);
      if (!AABB.isEmpty(bounds)) {
        aabb = new AABB();
        aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
      }
      var bbox = (_element$ownerDocumen = element.ownerDocument) === null || _element$ownerDocumen === void 0 || (_element$ownerDocumen = _element$ownerDocumen.defaultView) === null || _element$ownerDocumen === void 0 ? void 0 : _element$ownerDocumen.getContextService().getBoundingClientRect();
      if (aabb) {
        var _aabb$getMin = aabb.getMin(), _aabb$getMin2 = _slicedToArray(_aabb$getMin, 2), left = _aabb$getMin2[0], top = _aabb$getMin2[1];
        var _aabb$getMax = aabb.getMax(), _aabb$getMax2 = _slicedToArray(_aabb$getMax, 2), right = _aabb$getMax2[0], bottom = _aabb$getMax2[1];
        return new Rectangle(left + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), top + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0), right - left, bottom - top);
      }
      return new Rectangle((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0, (bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0, 0, 0);
    }
    // #endregion bbox
    // #region other ----------------------------------------------------------------
  }, {
    key: "internalUpdateTransform",
    value: function internalUpdateTransform(element) {
      var _element$parentNode;
      var parentTransform = (_element$parentNode = element.parentNode) === null || _element$parentNode === void 0 ? void 0 : _element$parentNode.transformable;
      updateLocalTransform(element.transformable);
      updateWorldTransform(element.transformable, parentTransform);
    }
  }, {
    key: "internalUpdateElement",
    value: function internalUpdateElement(element, ancestors) {
      var _element$ownerDocumen2, _element$transformabl, _element$renderable, _element$renderable2;
      var enableAttributeUpdateOptimization = ((_element$ownerDocumen2 = element.ownerDocument) === null || _element$ownerDocumen2 === void 0 || (_element$ownerDocumen2 = _element$ownerDocumen2.defaultView) === null || _element$ownerDocumen2 === void 0 || (_element$ownerDocumen2 = _element$ownerDocumen2.getConfig()) === null || _element$ownerDocumen2 === void 0 || (_element$ownerDocumen2 = _element$ownerDocumen2.future) === null || _element$ownerDocumen2 === void 0 ? void 0 : _element$ownerDocumen2.experimentalAttributeUpdateOptimization) === true;
      var parent = ancestors[ancestors.length - 1];
      var transformDirty = (parent === null || parent === void 0 ? void 0 : parent.transformDirty) || ((_element$transformabl = element.transformable) === null || _element$transformabl === void 0 ? void 0 : _element$transformabl.localDirtyFlag);
      if (element.transformable) {
        var _element$transformabl2;
        (_element$transformabl2 = element.transformable).dirtyFlag || (_element$transformabl2.dirtyFlag = transformDirty);
      }
      this.internalUpdateTransform(element);
      if (transformDirty) {
        var _element$dirty;
        (_element$dirty = element.dirty) === null || _element$dirty === void 0 || _element$dirty.call(element, true, true);
      }
      var shapeUpdated = ((_element$renderable = element.renderable) === null || _element$renderable === void 0 ? void 0 : _element$renderable.boundsDirty) || ((_element$renderable2 = element.renderable) === null || _element$renderable2 === void 0 ? void 0 : _element$renderable2.renderBoundsDirty);
      if ((transformDirty || shapeUpdated) && (parent === null || parent === void 0 ? void 0 : parent.shapeUpdated) === false && enableAttributeUpdateOptimization) {
        var tempElIndex = ancestors.length - 1;
        while (tempElIndex >= 0) {
          var _dirty, _ref5;
          var tempEl = ancestors[tempElIndex];
          if (tempEl.shapeUpdated) {
            break;
          }
          (_dirty = (_ref5 = tempEl.node).dirty) === null || _dirty === void 0 || _dirty.call(_ref5, true, true);
          tempEl.shapeUpdated = true;
          tempElIndex -= 1;
        }
      }
      return transformDirty;
    }
  }, {
    key: "syncHierarchy",
    value: function syncHierarchy(rootNode) {
      var _transformable, _transformable2;
      var stack = [rootNode];
      var ancestors = rootNode.parentNode ? [{
        node: rootNode.parentNode,
        transformDirty: ((_transformable = rootNode.parentNode.transformable) === null || _transformable === void 0 ? void 0 : _transformable.localDirtyFlag) || ((_transformable2 = rootNode.parentNode.transformable) === null || _transformable2 === void 0 ? void 0 : _transformable2.dirtyFlag),
        shapeUpdated: false
      }] : [];
      while (stack.length > 0) {
        var node = stack.pop();
        var parent = ancestors[ancestors.length - 1];
        while (ancestors.length > 0 && node.parentNode !== parent.node) {
          parent = ancestors.pop();
        }
        var transformDirty = this.internalUpdateElement(node, ancestors);
        if (node.childNodes.length > 0) {
          for (var i = node.childNodes.length - 1; i >= 0; i--) {
            stack.push(node.childNodes[i]);
          }
          ancestors.push({
            node,
            transformDirty,
            shapeUpdated: false
          });
        }
      }
    }
  }, {
    key: "dirtyLocalTransform",
    value: function dirtyLocalTransform(element, transform2) {
      if (isInFragment(element)) return;
      if (!transform2.localDirtyFlag) {
        transform2.localDirtyFlag = true;
        if (!transform2.dirtyFlag) {
          this.dirtyWorldTransform(element, transform2);
        }
      }
    }
  }, {
    key: "dirtyWorldTransform",
    value: function dirtyWorldTransform(element, transform2) {
      this.dirtifyWorldInternal(element, transform2);
      this.dirtyToRoot(element, true);
    }
  }, {
    key: "dirtifyWorldInternal",
    value: function dirtifyWorldInternal(element, transform2) {
      var _element$ownerDocumen3, _this2 = this;
      var enableAttributeUpdateOptimization = ((_element$ownerDocumen3 = element.ownerDocument) === null || _element$ownerDocumen3 === void 0 || (_element$ownerDocumen3 = _element$ownerDocumen3.defaultView) === null || _element$ownerDocumen3 === void 0 || (_element$ownerDocumen3 = _element$ownerDocumen3.getConfig()) === null || _element$ownerDocumen3 === void 0 || (_element$ownerDocumen3 = _element$ownerDocumen3.future) === null || _element$ownerDocumen3 === void 0 ? void 0 : _element$ownerDocumen3.experimentalAttributeUpdateOptimization) === true;
      if (!transform2.dirtyFlag) {
        transform2.dirtyFlag = true;
        element.dirty(true, true);
        if (!enableAttributeUpdateOptimization) {
          element.childNodes.forEach(function(child) {
            var childTransform = child.transformable;
            _this2.dirtifyWorldInternal(child, childTransform);
          });
        }
      }
    }
  }, {
    key: "dirtyToRoot",
    value: function dirtyToRoot(element) {
      var _element$ownerDocumen4;
      var affectChildren = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var p = element;
      var enableAttributeUpdateOptimization = ((_element$ownerDocumen4 = element.ownerDocument) === null || _element$ownerDocumen4 === void 0 || (_element$ownerDocumen4 = _element$ownerDocumen4.defaultView) === null || _element$ownerDocumen4 === void 0 || (_element$ownerDocumen4 = _element$ownerDocumen4.getConfig()) === null || _element$ownerDocumen4 === void 0 || (_element$ownerDocumen4 = _element$ownerDocumen4.future) === null || _element$ownerDocumen4 === void 0 ? void 0 : _element$ownerDocumen4.experimentalAttributeUpdateOptimization) === true;
      while (p) {
        var _dirty2, _ref6;
        (_dirty2 = (_ref6 = p).dirty) === null || _dirty2 === void 0 || _dirty2.call(_ref6, true, true);
        if (enableAttributeUpdateOptimization) {
          break;
        } else {
          p = p.parentNode;
        }
      }
      if (affectChildren) {
        element.forEach(function(e) {
          var _e$dirty;
          (_e$dirty = e.dirty) === null || _e$dirty === void 0 || _e$dirty.call(e, true, true);
        });
      }
      this.informDependentDisplayObjects(element);
      this.pendingEvents.set(element, affectChildren);
    }
  }, {
    key: "dirtifyFragment",
    value: function dirtifyFragment(element) {
      var _dirty3, _ref7;
      var transform2 = element.transformable;
      if (transform2) {
        transform2.dirtyFlag = true;
        transform2.localDirtyFlag = true;
      }
      (_dirty3 = (_ref7 = element).dirty) === null || _dirty3 === void 0 || _dirty3.call(_ref7, true, true);
      var length5 = element.childNodes.length;
      for (var i = 0; i < length5; i++) {
        this.dirtifyFragment(element.childNodes[i]);
      }
      if (element.nodeName === Shape.FRAGMENT) {
        this.pendingEvents.set(element, false);
      }
    }
  }, {
    key: "triggerPendingEvents",
    value: function triggerPendingEvents() {
      var _this3 = this;
      var triggered = /* @__PURE__ */ new Set();
      var enableCancelEventPropagation;
      var enableAttributeUpdateOptimization;
      var trigger = function trigger2(element, detail) {
        if (!element.isConnected || triggered.has(element) || element.nodeName === Shape.FRAGMENT) {
          return;
        }
        _this3.boundsChangedEvent.detail = detail;
        _this3.boundsChangedEvent.target = element;
        if (element.isMutationObserved) {
          element.dispatchEvent(_this3.boundsChangedEvent);
        } else {
          if (enableCancelEventPropagation === void 0) {
            var _element$ownerDocumen5;
            enableCancelEventPropagation = ((_element$ownerDocumen5 = element.ownerDocument.defaultView) === null || _element$ownerDocumen5 === void 0 || (_element$ownerDocumen5 = _element$ownerDocumen5.getConfig()) === null || _element$ownerDocumen5 === void 0 || (_element$ownerDocumen5 = _element$ownerDocumen5.future) === null || _element$ownerDocumen5 === void 0 ? void 0 : _element$ownerDocumen5.experimentalCancelEventPropagation) === true;
          }
          element.ownerDocument.defaultView.dispatchEvent(_this3.boundsChangedEvent, true, enableCancelEventPropagation);
        }
        triggered.add(element);
      };
      this.pendingEvents.forEach(function(affectChildren, element) {
        if (element.nodeName === Shape.FRAGMENT) {
          return;
        }
        if (enableAttributeUpdateOptimization === void 0) {
          var _element$ownerDocumen6;
          enableAttributeUpdateOptimization = ((_element$ownerDocumen6 = element.ownerDocument) === null || _element$ownerDocumen6 === void 0 || (_element$ownerDocumen6 = _element$ownerDocumen6.defaultView) === null || _element$ownerDocumen6 === void 0 || (_element$ownerDocumen6 = _element$ownerDocumen6.getConfig()) === null || _element$ownerDocumen6 === void 0 || (_element$ownerDocumen6 = _element$ownerDocumen6.future) === null || _element$ownerDocumen6 === void 0 ? void 0 : _element$ownerDocumen6.experimentalAttributeUpdateOptimization) === true;
        }
        $triggerPendingEvents_detail.affectChildren = affectChildren;
        if (enableAttributeUpdateOptimization) {
          trigger(element, $triggerPendingEvents_detail);
        } else {
          if (affectChildren) {
            element.forEach(function(e) {
              trigger(e, $triggerPendingEvents_detail);
            });
          } else {
            trigger(element, $triggerPendingEvents_detail);
          }
        }
      });
      triggered.clear();
      this.clearPendingEvents();
    }
  }, {
    key: "clearPendingEvents",
    value: function clearPendingEvents() {
      this.pendingEvents.clear();
    }
  }, {
    key: "updateDisplayObjectDependency",
    value: function updateDisplayObjectDependency(name, oldPath, newPath, object) {
      if (oldPath && oldPath !== newPath) {
        var oldDependencyMap = this.displayObjectDependencyMap.get(oldPath);
        if (oldDependencyMap && oldDependencyMap[name]) {
          var index2 = oldDependencyMap[name].indexOf(object);
          oldDependencyMap[name].splice(index2, 1);
        }
      }
      if (newPath) {
        var newDependencyMap = this.displayObjectDependencyMap.get(newPath);
        if (!newDependencyMap) {
          this.displayObjectDependencyMap.set(newPath, {});
          newDependencyMap = this.displayObjectDependencyMap.get(newPath);
        }
        if (!newDependencyMap[name]) {
          newDependencyMap[name] = [];
        }
        newDependencyMap[name].push(object);
      }
    }
  }, {
    key: "informDependentDisplayObjects",
    value: function informDependentDisplayObjects(object) {
      var _object$ownerDocument, _this4 = this;
      var dependencyMap = this.displayObjectDependencyMap.get(object);
      if (!dependencyMap) {
        return;
      }
      var enableCancelEventPropagation = (_object$ownerDocument = object.ownerDocument) === null || _object$ownerDocument === void 0 || (_object$ownerDocument = _object$ownerDocument.defaultView) === null || _object$ownerDocument === void 0 || (_object$ownerDocument = _object$ownerDocument.getConfig()) === null || _object$ownerDocument === void 0 || (_object$ownerDocument = _object$ownerDocument.future) === null || _object$ownerDocument === void 0 ? void 0 : _object$ownerDocument.experimentalCancelEventPropagation;
      Object.keys(dependencyMap).forEach(function(name) {
        dependencyMap[name].forEach(function(target) {
          _this4.dirtyToRoot(target, true);
          target.dispatchEvent(new MutationEvent(ElementEvent.ATTR_MODIFIED, target, _this4, _this4, name, MutationEvent.MODIFICATION, _this4, _this4), enableCancelEventPropagation, enableCancelEventPropagation);
          if (target.isCustomElement && target.isConnected) {
            if (target.attributeChangedCallback) {
              target.attributeChangedCallback(name, _this4, _this4);
            }
          }
        });
      });
    }
  }]);
}();
var LRU = function() {
  function LRU2(capacity) {
    _classCallCheck(this, LRU2);
    if (capacity <= 0) {
      throw new Error("LRU capacity must be a positive number.");
    }
    this.capacity = capacity;
    this.cache = /* @__PURE__ */ new Map();
  }
  return _createClass(LRU2, [{
    key: "get",
    value: function get(key) {
      if (!this.cache.has(key)) {
        return void 0;
      }
      var value = this.cache.get(key);
      this.cache["delete"](key);
      this.cache.set(key, value);
      return value;
    }
    /**
     * Adds or updates an item in the cache. Marks the item as recently used.
     * If the cache is full, it removes the least recently used item.
     * @param key The key of the item.
     * @param value The value of the item.
     */
  }, {
    key: "put",
    value: function put(key, value) {
      if (this.cache.has(key)) {
        this.cache["delete"](key);
      }
      this.cache.set(key, value);
      if (this.cache.size > this.capacity) {
        var leastRecentlyUsedKey = this.cache.keys().next().value;
        this.cache["delete"](leastRecentlyUsedKey);
      }
    }
    /**
     * Returns the current number of items in the cache.
     */
  }, {
    key: "len",
    value: function len5() {
      return this.cache.size;
    }
    /**
     * Clears all items from the cache.
     */
  }, {
    key: "clear",
    value: function clear() {
      this.cache.clear();
    }
  }]);
}();
var TEXT_METRICS = {
  MetricsString: "|ÉqÅ",
  BaselineSymbol: "M",
  BaselineMultiplier: 1.4,
  HeightMultiplier: 2,
  Newlines: [
    10,
    // line feed
    13
    // carriage return
  ],
  BreakingSpaces: [
    9,
    // character tabulation
    32,
    // space
    8192,
    // en quad
    8193,
    // em quad
    8194,
    // en space
    8195,
    // em space
    8196,
    // three-per-em space
    8197,
    // four-per-em space
    8198,
    // six-per-em space
    8200,
    // punctuation space
    8201,
    // thin space
    8202,
    // hair space
    8287,
    // medium mathematical space
    12288
    // ideographic space
  ]
};
var LATIN_REGEX = /[a-zA-Z0-9\u00C0-\u00D6\u00D8-\u00f6\u00f8-\u00ff!"#$%&'()*+,-./:;]/;
var regexCannotStartZhCn = /[!%),.:;?\]}¢°·'""†‡›℃∶、。〃〆〕〗〞﹚﹜！＂％＇），．：；？！］｝～]/;
var regexCannotEndZhCn = /[$(£¥·'"〈《「『【〔〖〝﹙﹛＄（．［｛￡￥]/;
var regexCannotStartZhTw = /[!),.:;?\]}¢·–—'"•"、。〆〞〕〉》」︰︱︲︳﹐﹑﹒﹓﹔﹕﹖﹘﹚﹜！），．：；？︶︸︺︼︾﹀﹂﹗］｜｝､]/;
var regexCannotEndZhTw = /[([{£¥'"‵〈《「『〔〝︴﹙﹛（｛︵︷︹︻︽︿﹁﹃﹏]/;
var regexCannotStartJaJp = /[)\]｝〕〉》」』】〙〗〟'"｠»ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻‐゠–〜?!‼⁇⁈⁉・、:;,。.]/;
var regexCannotEndJaJp = /[([｛〔〈《「『【〘〖〝'"｟«—...‥〳〴〵]/;
var regexCannotStartKoKr = /[!%),.:;?\]}¢°'"†‡℃〆〈《「『〕！％），．：；？］｝]/;
var regexCannotEndKoKr = /[$([{£¥'"々〇〉》」〔＄（［｛｠￥￦#]/;
var regexCannotStart = new RegExp("".concat(regexCannotStartZhCn.source, "|").concat(regexCannotStartZhTw.source, "|").concat(regexCannotStartJaJp.source, "|").concat(regexCannotStartKoKr.source));
var regexCannotEnd = new RegExp("".concat(regexCannotEndZhCn.source, "|").concat(regexCannotEndZhTw.source, "|").concat(regexCannotEndJaJp.source, "|").concat(regexCannotEndKoKr.source));
var TextService = function() {
  function TextService2(runtime2) {
    var _this2 = this;
    _classCallCheck(this, TextService2);
    this.fontMetricsCache = {};
    this.shouldBreakByKinsokuShorui = function(_char, nextChar) {
      if (_this2.isBreakingSpace(nextChar)) return false;
      if (_char) {
        if (regexCannotEnd.exec(nextChar) || regexCannotStart.exec(_char)) {
          return true;
        }
      }
      return false;
    };
    this.trimByKinsokuShorui = function(prev) {
      var next = _toConsumableArray(prev);
      var prevLine = next[next.length - 2];
      if (!prevLine) {
        return prev;
      }
      var lastChar = prevLine[prevLine.length - 1];
      next[next.length - 2] = prevLine.slice(0, -1);
      next[next.length - 1] = lastChar + next[next.length - 1];
      return next;
    };
    this.runtime = runtime2;
    this.charWidthCache = new LRU(100);
  }
  return _createClass(TextService2, [{
    key: "measureFont",
    value: (
      /**
       * A global cache for character widths, keyed by font string.
       * e.g. { '16px Arial': { 'a': 8, 'b': 9 } }
       */
      /**
       * Calculates the ascent, descent and fontSize of a given font-style.
       */
      function measureFont(font, offscreenCanvas) {
        if (this.fontMetricsCache[font]) {
          return this.fontMetricsCache[font];
        }
        var properties = {
          ascent: 0,
          descent: 0,
          fontSize: 0
        };
        var canvas = this.runtime.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
        var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas, {
          willReadFrequently: true
        });
        context.font = font;
        var metricsString = TEXT_METRICS.MetricsString + TEXT_METRICS.BaselineSymbol;
        var width = Math.ceil(context.measureText(metricsString).width);
        var baseline = Math.ceil(context.measureText(TEXT_METRICS.BaselineSymbol).width);
        var height = TEXT_METRICS.HeightMultiplier * baseline;
        baseline = baseline * TEXT_METRICS.BaselineMultiplier | 0;
        canvas.width = width;
        canvas.height = height;
        context.fillStyle = "#f00";
        context.fillRect(0, 0, width, height);
        context.font = font;
        context.textBaseline = "alphabetic";
        context.fillStyle = "#000";
        context.fillText(metricsString, 0, baseline);
        var imagedata = context.getImageData(0, 0, width || 1, height || 1).data;
        var pixels = imagedata.length;
        var line2 = width * 4;
        var i = 0;
        var idx = 0;
        var stop = false;
        for (i = 0; i < baseline; ++i) {
          for (var j = 0; j < line2; j += 4) {
            if (imagedata[idx + j] !== 255) {
              stop = true;
              break;
            }
          }
          if (!stop) {
            idx += line2;
          } else {
            break;
          }
        }
        properties.ascent = baseline - i;
        idx = pixels - line2;
        stop = false;
        for (i = height; i > baseline; --i) {
          for (var _j = 0; _j < line2; _j += 4) {
            if (imagedata[idx + _j] !== 255) {
              stop = true;
              break;
            }
          }
          if (!stop) {
            idx -= line2;
          } else {
            break;
          }
        }
        properties.descent = i - baseline;
        properties.fontSize = properties.ascent + properties.descent;
        this.fontMetricsCache[font] = properties;
        return properties;
      }
    )
  }, {
    key: "measureText",
    value: function measureText(text, parsedStyle, offscreenCanvas) {
      var _parsedStyle$fontSize = parsedStyle.fontSize, fontSize = _parsedStyle$fontSize === void 0 ? 16 : _parsedStyle$fontSize, _parsedStyle$wordWrap = parsedStyle.wordWrap, wordWrap = _parsedStyle$wordWrap === void 0 ? false : _parsedStyle$wordWrap, strokeHeight = parsedStyle.lineHeight, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$textBase = parsedStyle.textBaseline, textBaseline = _parsedStyle$textBase === void 0 ? "alphabetic" : _parsedStyle$textBase, _parsedStyle$textAlig = parsedStyle.textAlign, textAlign = _parsedStyle$textAlig === void 0 ? "start" : _parsedStyle$textAlig, _parsedStyle$letterSp = parsedStyle.letterSpacing, letterSpacing = _parsedStyle$letterSp === void 0 ? 0 : _parsedStyle$letterSp, textPath = parsedStyle.textPath;
      parsedStyle.textPathSide;
      parsedStyle.textPathStartOffset;
      var _parsedStyle$leading = parsedStyle.leading, leading = _parsedStyle$leading === void 0 ? 0 : _parsedStyle$leading;
      var font = toFontString(parsedStyle);
      var fontProperties = this.measureFont(font, offscreenCanvas);
      if (fontProperties.fontSize === 0) {
        fontProperties.fontSize = fontSize;
        fontProperties.ascent = fontSize;
      }
      var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
      context.font = font;
      parsedStyle.isOverflowing = false;
      var outputText = wordWrap ? this.wordWrap(text, parsedStyle, offscreenCanvas) : text;
      var lines = outputText.split(/(?:\r\n|\r|\n)/);
      var lineWidths = new Array(lines.length);
      var maxLineWidth = 0;
      if (textPath) {
        textPath.getTotalLength();
        for (var i = 0; i < lines.length; i++) {
          context.measureText(lines[i]).width + (lines[i].length - 1) * letterSpacing;
        }
      } else {
        for (var _i = 0; _i < lines.length; _i++) {
          var _lineWidth = context.measureText(lines[_i]).width + (lines[_i].length - 1) * letterSpacing;
          lineWidths[_i] = _lineWidth;
          maxLineWidth = Math.max(maxLineWidth, _lineWidth);
        }
        var _width = maxLineWidth + lineWidth;
        var lineHeight = strokeHeight || fontProperties.fontSize + lineWidth;
        var height = Math.max(lineHeight, fontProperties.fontSize + lineWidth) + (lines.length - 1) * (lineHeight + leading);
        lineHeight += leading;
        var offsetY = 0;
        if (textBaseline === "middle") {
          offsetY = -height / 2;
        } else if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
          offsetY = -height;
        } else if (textBaseline === "top" || textBaseline === "hanging") {
          offsetY = 0;
        }
        return {
          font,
          width: _width,
          height,
          lines,
          lineWidths,
          lineHeight,
          maxLineWidth,
          fontProperties,
          lineMetrics: lineWidths.map(function(width, i2) {
            var offsetX = 0;
            if (textAlign === "center" || textAlign === "middle") {
              offsetX -= width / 2;
            } else if (textAlign === "right" || textAlign === "end") {
              offsetX -= width;
            }
            return new Rectangle(offsetX - lineWidth / 2, offsetY + i2 * lineHeight, width + lineWidth, lineHeight);
          })
        };
      }
    }
  }, {
    key: "wordWrap",
    value: function wordWrap(text, parsedStyle, offscreenCanvas) {
      var _this2 = this;
      var chars = Array.from(text);
      if (chars.length === 0) {
        return "";
      }
      var self2 = this;
      var _parsedStyle$wordWrap2 = parsedStyle.wordWrapWidth, wordWrapWidth = _parsedStyle$wordWrap2 === void 0 ? 0 : _parsedStyle$wordWrap2, _parsedStyle$letterSp2 = parsedStyle.letterSpacing, letterSpacing = _parsedStyle$letterSp2 === void 0 ? 0 : _parsedStyle$letterSp2, _parsedStyle$maxLines = parsedStyle.maxLines, maxLines = _parsedStyle$maxLines === void 0 ? Infinity : _parsedStyle$maxLines, textOverflow = parsedStyle.textOverflow;
      var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
      var maxWidth = wordWrapWidth + letterSpacing;
      var ellipsis = "";
      if (textOverflow === "ellipsis") {
        ellipsis = "...";
      } else if (textOverflow && textOverflow !== "clip") {
        ellipsis = textOverflow;
      }
      var lines = [""];
      var currentLineIndex = 0;
      var currentLineWidth = 0;
      var prevLineLastCharIndex = -1;
      var font = toFontString(parsedStyle);
      var charCache = this.charWidthCache.get(font);
      if (!charCache) {
        charCache = new LRU(500);
        this.charWidthCache.put(font, charCache);
      }
      var calcWidth = function calcWidth2(_char2) {
        return _this2.getFromCache(_char2, letterSpacing, charCache, context);
      };
      var ellipsisWidth = calcWidth(ellipsis);
      function findCharIndexClosestWidthThreshold(lineTxt, txtLastCharIndex, txtStartCharIndex, widthThreshold) {
        while (calcWidth(lineTxt) < widthThreshold && txtLastCharIndex < chars.length - 1) {
          if (self2.isNewline(chars[txtLastCharIndex + 1])) {
            break;
          }
          txtLastCharIndex += 1;
          lineTxt += chars[txtLastCharIndex];
        }
        while (calcWidth(lineTxt) > widthThreshold && // @see https://github.com/antvis/G/issues/1932
        txtLastCharIndex >= txtStartCharIndex) {
          txtLastCharIndex -= 1;
          lineTxt = lineTxt.slice(0, -1);
        }
        return {
          lineTxt,
          txtLastCharIndex
        };
      }
      function appendEllipsis(lineIndex, textCharIndex) {
        if (ellipsisWidth <= 0 || ellipsisWidth > maxWidth) {
          return;
        }
        if (!lines[lineIndex]) {
          lines[lineIndex] = ellipsis;
          return;
        }
        var result2 = findCharIndexClosestWidthThreshold(lines[lineIndex], textCharIndex, prevLineLastCharIndex + 1, maxWidth - ellipsisWidth);
        lines[lineIndex] = result2.lineTxt + ellipsis;
      }
      for (var i = 0; i < chars.length; i++) {
        var _char3 = chars[i];
        var prevChar = chars[i - 1];
        var nextChar = chars[i + 1];
        var charWidth = calcWidth(_char3);
        if (this.isNewline(_char3)) {
          if (currentLineIndex + 1 >= maxLines) {
            if (i < chars.length - 1) {
              appendEllipsis(currentLineIndex, i - 1);
            }
            parsedStyle.isOverflowing = true;
            break;
          }
          prevLineLastCharIndex = i - 1;
          currentLineIndex += 1;
          currentLineWidth = 0;
          lines[currentLineIndex] = "";
          continue;
        }
        if (charWidth > maxWidth) {
          appendEllipsis(currentLineIndex, i - 1);
          parsedStyle.isOverflowing = true;
          break;
        }
        if (currentLineWidth > 0 && currentLineWidth + charWidth > maxWidth) {
          var result = findCharIndexClosestWidthThreshold(lines[currentLineIndex], i - 1, prevLineLastCharIndex + 1, maxWidth);
          if (result.txtLastCharIndex !== i - 1) {
            lines[currentLineIndex] = result.lineTxt;
            if (result.txtLastCharIndex === chars.length - 1) {
              break;
            }
            i = result.txtLastCharIndex + 1;
            _char3 = chars[i];
            prevChar = chars[i - 1];
            nextChar = chars[i + 1];
            charWidth = calcWidth(_char3);
          }
          if (currentLineIndex + 1 >= maxLines) {
            appendEllipsis(currentLineIndex, i - 1);
            parsedStyle.isOverflowing = true;
            break;
          }
          prevLineLastCharIndex = i - 1;
          currentLineIndex += 1;
          currentLineWidth = 0;
          lines[currentLineIndex] = "";
          if (this.isBreakingSpace(_char3)) {
            continue;
          }
          if (!this.canBreakInLastChar(_char3)) {
            lines = this.trimToBreakable(lines);
            currentLineWidth = this.sumTextWidthByCache(lines[currentLineIndex] || "", calcWidth);
          }
          if (this.shouldBreakByKinsokuShorui(_char3, nextChar)) {
            lines = this.trimByKinsokuShorui(lines);
            currentLineWidth += calcWidth(prevChar || "");
          }
        }
        currentLineWidth += charWidth;
        lines[currentLineIndex] += _char3;
      }
      return lines.join("\n");
    }
  }, {
    key: "isBreakingSpace",
    value: function isBreakingSpace(_char4) {
      if (typeof _char4 !== "string") {
        return false;
      }
      return TEXT_METRICS.BreakingSpaces.indexOf(_char4.charCodeAt(0)) >= 0;
    }
  }, {
    key: "isNewline",
    value: function isNewline(_char5) {
      if (typeof _char5 !== "string") {
        return false;
      }
      return TEXT_METRICS.Newlines.indexOf(_char5.charCodeAt(0)) >= 0;
    }
  }, {
    key: "trimToBreakable",
    value: function trimToBreakable(prev) {
      var next = _toConsumableArray(prev);
      var prevLine = next[next.length - 2];
      var index2 = this.findBreakableIndex(prevLine);
      if (index2 === -1 || !prevLine) return next;
      var trimmedChar = prevLine.slice(index2, index2 + 1);
      var isTrimmedWithSpace = this.isBreakingSpace(trimmedChar);
      var trimFrom = index2 + 1;
      var trimTo = index2 + (isTrimmedWithSpace ? 0 : 1);
      next[next.length - 1] += prevLine.slice(trimFrom, prevLine.length);
      next[next.length - 2] = prevLine.slice(0, trimTo);
      return next;
    }
  }, {
    key: "canBreakInLastChar",
    value: function canBreakInLastChar(_char6) {
      if (_char6 && LATIN_REGEX.test(_char6)) return false;
      return true;
    }
  }, {
    key: "sumTextWidthByCache",
    value: function sumTextWidthByCache(text, calcWidthWithCache) {
      return text.split("").reduce(function(sum, c2) {
        return sum + calcWidthWithCache(c2);
      }, 0);
    }
  }, {
    key: "findBreakableIndex",
    value: function findBreakableIndex(line2) {
      for (var i = line2.length - 1; i >= 0; i--) {
        if (!LATIN_REGEX.test(line2[i])) return i;
      }
      return -1;
    }
  }, {
    key: "getFromCache",
    value: function getFromCache(key, letterSpacing, cache, context) {
      var width = cache.get(key);
      if (typeof width !== "number") {
        var spacing = key.length * letterSpacing;
        var metrics = context.measureText(key);
        width = metrics.width + spacing;
        cache.put(key, width);
      }
      return width;
    }
  }, {
    key: "clearCache",
    value: function clearCache() {
      this.fontMetricsCache = {};
      this.charWidthCache.clear();
    }
  }]);
}();
var runtime = {};
var geometryUpdaterFactory = function(_ref) {
  var rectUpdater = new RectUpdater();
  var polylineUpdater = new PolylineUpdater();
  return _ref = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_ref, Shape.FRAGMENT, null), Shape.CIRCLE, new CircleUpdater()), Shape.ELLIPSE, new EllipseUpdater()), Shape.RECT, rectUpdater), Shape.IMAGE, rectUpdater), Shape.GROUP, new GroupUpdater()), Shape.LINE, new LineUpdater()), Shape.TEXT, new TextUpdater(runtime)), Shape.POLYLINE, polylineUpdater), Shape.POLYGON, polylineUpdater), _defineProperty(_defineProperty(_defineProperty(_ref, Shape.PATH, new PathUpdater()), Shape.HTML, new HTMLUpdater()), Shape.MESH, null);
}();
var CSSPropertySyntaxFactory = function(_ref2) {
  var color2 = new CSSPropertyColor();
  var length5 = new CSSPropertyLengthOrPercentage();
  return _ref2 = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_ref2, PropertySyntax.PERCENTAGE, null), PropertySyntax.NUMBER, new CSSPropertyNumber()), PropertySyntax.ANGLE, new CSSPropertyAngle()), PropertySyntax.DEFINED_PATH, new CSSPropertyClipPath()), PropertySyntax.PAINT, color2), PropertySyntax.COLOR, color2), PropertySyntax.FILTER, new CSSPropertyFilter()), PropertySyntax.LENGTH, length5), PropertySyntax.LENGTH_PERCENTAGE, length5), PropertySyntax.LENGTH_PERCENTAGE_12, new CSSPropertyLengthOrPercentage12()), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_ref2, PropertySyntax.LENGTH_PERCENTAGE_14, new CSSPropertyLengthOrPercentage14()), PropertySyntax.COORDINATE, new CSSPropertyLengthOrPercentage()), PropertySyntax.OFFSET_DISTANCE, new CSSPropertyOffsetDistance()), PropertySyntax.OPACITY_VALUE, new CSSPropertyOpacity()), PropertySyntax.PATH, new CSSPropertyPath()), PropertySyntax.LIST_OF_POINTS, new CSSPropertyPoints()), PropertySyntax.SHADOW_BLUR, new CSSPropertyShadowBlur()), PropertySyntax.TEXT, new CSSPropertyText()), PropertySyntax.TEXT_TRANSFORM, new CSSPropertyTextTransform()), PropertySyntax.TRANSFORM, new CSSPropertyTransform()), _defineProperty(_defineProperty(_defineProperty(_ref2, PropertySyntax.TRANSFORM_ORIGIN, new CSSPropertyTransformOrigin()), PropertySyntax.Z_INDEX, new CSSPropertyZIndex()), PropertySyntax.MARKER, new CSSPropertyMarker());
}();
var getGlobalThis = function getGlobalThis2() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
  return {};
};
runtime.CameraContribution = Camera;
runtime.AnimationTimeline = null;
runtime.EasingFunction = null;
runtime.offscreenCanvasCreator = new OffscreenCanvasCreator();
runtime.sceneGraphSelector = new DefaultSceneGraphSelector();
runtime.sceneGraphService = new DefaultSceneGraphService(runtime);
runtime.textService = new TextService(runtime);
runtime.geometryUpdaterFactory = geometryUpdaterFactory;
runtime.CSSPropertySyntaxFactory = CSSPropertySyntaxFactory;
runtime.styleValueRegistry = new DefaultStyleValueRegistry(runtime);
runtime.layoutRegistry = null;
runtime.globalThis = getGlobalThis();
runtime.enableStyleSyntax = true;
runtime.enableSizeAttenuation = false;
var entityCounter = 0;
var insertedEvent = new MutationEvent(ElementEvent.INSERTED, null, "", "", "", 0, "", "");
var removedEvent = new MutationEvent(ElementEvent.REMOVED, null, "", "", "", 0, "", "");
var destroyEvent = new CustomEvent(ElementEvent.DESTROY);
var Element2 = function(_Node) {
  function Element3() {
    var _this2;
    _classCallCheck(this, Element3);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Element3, [].concat(args));
    _this2.entity = entityCounter++;
    _this2.transformable = {
      dirtyFlag: false,
      localDirtyFlag: false,
      localPosition: [0, 0, 0],
      localRotation: [0, 0, 0, 1],
      localScale: [1, 1, 1],
      localTransform: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
      localSkew: [0, 0],
      position: [0, 0, 0],
      rotation: [0, 0, 0, 1],
      scaling: [1, 1, 1],
      worldTransform: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
      origin: [0, 0, 0]
    };
    _this2.renderable = {
      bounds: void 0,
      boundsDirty: true,
      renderBounds: void 0,
      renderBoundsDirty: true,
      dirtyRenderBounds: void 0,
      dirty: false
    };
    _this2.geometry = {
      contentBounds: void 0,
      renderBounds: void 0,
      dirty: true
    };
    _this2.cullable = {
      strategy: Strategy.Standard,
      visibilityPlaneMask: -1,
      visible: true,
      enable: true
    };
    _this2.sortable = {
      dirty: false,
      sorted: void 0,
      renderOrder: 0,
      dirtyChildren: [],
      dirtyReason: void 0
    };
    _this2.rBushNode = {
      aabb: void 0
    };
    _this2.namespaceURI = "g";
    _this2.scrollLeft = 0;
    _this2.scrollTop = 0;
    _this2.clientTop = 0;
    _this2.clientLeft = 0;
    _this2.style = {};
    _this2.computedStyle = {};
    _this2.parsedStyle = {
      // opacity: '',
      // fillOpacity: '',
      // strokeOpacity: '',
      // transformOrigin: '',
      // visibility: '',
      // pointerEvents: '',
      // lineWidth: '',
      // lineCap: '',
      // lineJoin: '',
      // increasedLineWidthForHitTesting: '',
      // fontSize: '',
      // fontFamily: '',
      // fontStyle: '',
      // fontWeight: '',
      // fontVariant: '',
      // textAlign: '',
      // textBaseline: '',
      // textTransform: '',
    };
    _this2.attributes = {};
    return _this2;
  }
  _inherits(Element3, _Node);
  return _createClass(Element3, [{
    key: "dirty",
    value: (
      /**
       * @param flag - default `true`, whether the object needs to be updated
       * @param updateShape - default `false`, whether the bounding box of the object is updated
       */
      function dirty() {
        var flag = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        var updateShape = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        this.renderable.dirty = flag;
        if (updateShape) {
          this.renderable.boundsDirty = flag;
          this.renderable.renderBoundsDirty = flag;
        }
      }
    )
  }, {
    key: "className",
    get: (
      /**
       * used with `getElementById()`
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/id
       */
      /**
       * used in `getElementsByClassName`
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
       */
      function get() {
        return this.getAttribute("class") || "";
      }
    ),
    set: function set7(className) {
      this.setAttribute("class", className);
    }
    /**
     * used in `getElementsByName`
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByName
     */
  }, {
    key: "classList",
    get: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/classList
       */
      function get() {
        return this.className.split(" ").filter(function(c2) {
          return c2 !== "";
        });
      }
    )
  }, {
    key: "tagName",
    get: function get() {
      return this.nodeName;
    }
  }, {
    key: "children",
    get: function get() {
      return this.childNodes;
    }
  }, {
    key: "childElementCount",
    get: function get() {
      return this.childNodes.length;
    }
  }, {
    key: "firstElementChild",
    get: function get() {
      return this.firstChild;
    }
  }, {
    key: "lastElementChild",
    get: function get() {
      return this.lastChild;
    }
  }, {
    key: "parentElement",
    get: function get() {
      return this.parentNode;
    }
  }, {
    key: "nextSibling",
    get: function get() {
      if (this.parentNode) {
        var index2 = this.parentNode.childNodes.indexOf(this);
        return this.parentNode.childNodes[index2 + 1] || null;
      }
      return null;
    }
  }, {
    key: "previousSibling",
    get: function get() {
      if (this.parentNode) {
        var index2 = this.parentNode.childNodes.indexOf(this);
        return this.parentNode.childNodes[index2 - 1] || null;
      }
      return null;
    }
  }, {
    key: "cloneNode",
    value: function cloneNode(deep2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "appendChild",
    value: function appendChild(child, index2) {
      var _this$ownerDocument;
      if (child.destroyed) {
        throw new Error(ERROR_MSG_APPEND_DESTROYED_ELEMENT);
      }
      runtime.sceneGraphService.attach(child, this, index2);
      if ((_this$ownerDocument = this.ownerDocument) !== null && _this$ownerDocument !== void 0 && _this$ownerDocument.defaultView) {
        if (!isInFragment(this) && child.nodeName === Shape.FRAGMENT) {
          this.ownerDocument.defaultView.mountFragment(child);
        } else {
          this.ownerDocument.defaultView.mountChildren(child);
        }
      }
      if (this.isMutationObserved) {
        insertedEvent.relatedNode = this;
        child.dispatchEvent(insertedEvent);
      }
      return child;
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(newChild, refChild) {
      if (!refChild) {
        this.appendChild(newChild);
      } else {
        if (newChild.parentElement) {
          newChild.parentElement.removeChild(newChild);
        }
        var index2 = this.childNodes.indexOf(refChild);
        if (index2 === -1) {
          this.appendChild(newChild);
        } else {
          this.appendChild(newChild, index2);
        }
      }
      return newChild;
    }
  }, {
    key: "replaceChild",
    value: function replaceChild(newChild, oldChild) {
      var index2 = this.childNodes.indexOf(oldChild);
      this.removeChild(oldChild);
      this.appendChild(newChild, index2);
      return oldChild;
    }
  }, {
    key: "removeChild",
    value: function removeChild(child) {
      var _this$ownerDocument2, _child$ownerDocument;
      var enableCancelEventPropagation = ((_this$ownerDocument2 = this.ownerDocument) === null || _this$ownerDocument2 === void 0 || (_this$ownerDocument2 = _this$ownerDocument2.defaultView) === null || _this$ownerDocument2 === void 0 || (_this$ownerDocument2 = _this$ownerDocument2.getConfig().future) === null || _this$ownerDocument2 === void 0 ? void 0 : _this$ownerDocument2.experimentalCancelEventPropagation) === true;
      removedEvent.relatedNode = this;
      child.dispatchEvent(removedEvent, enableCancelEventPropagation, enableCancelEventPropagation);
      if ((_child$ownerDocument = child.ownerDocument) !== null && _child$ownerDocument !== void 0 && _child$ownerDocument.defaultView) {
        child.ownerDocument.defaultView.unmountChildren(child);
      }
      runtime.sceneGraphService.detach(child);
      return child;
    }
    /**
     * Remove all children which can be appended to its original parent later again.
     */
  }, {
    key: "removeChildren",
    value: function removeChildren() {
      for (var i = this.childNodes.length - 1; i >= 0; i--) {
        var child = this.childNodes[i];
        this.removeChild(child);
      }
    }
    /**
     * Recursively destroy all children which can not be appended to its original parent later again.
     */
  }, {
    key: "destroyChildren",
    value: function destroyChildren() {
      for (var i = this.childNodes.length - 1; i >= 0; i--) {
        var child = this.childNodes[i];
        if (child.childNodes.length > 0) {
          child.destroyChildren();
        }
        child.destroy();
      }
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/matches
     */
  }, {
    key: "matches",
    value: function matches(selector) {
      return runtime.sceneGraphService.matches(selector, this);
    }
  }, {
    key: "getElementById",
    value: function getElementById(id3) {
      return runtime.sceneGraphService.querySelector("#".concat(id3), this);
    }
  }, {
    key: "getElementsByName",
    value: function getElementsByName(name) {
      return runtime.sceneGraphService.querySelectorAll('[name="'.concat(name, '"]'), this);
    }
  }, {
    key: "getElementsByClassName",
    value: function getElementsByClassName(className) {
      return runtime.sceneGraphService.querySelectorAll(".".concat(className), this);
    }
  }, {
    key: "getElementsByTagName",
    value: function getElementsByTagName(tagName) {
      return runtime.sceneGraphService.querySelectorAll(tagName, this);
    }
  }, {
    key: "querySelector",
    value: function querySelector(selectors) {
      return runtime.sceneGraphService.querySelector(selectors, this);
    }
  }, {
    key: "querySelectorAll",
    value: function querySelectorAll(selectors) {
      return runtime.sceneGraphService.querySelectorAll(selectors, this);
    }
    /**
     * should traverses the element and its parents (heading toward the document root)
     * until it finds a node that matches the specified CSS selector.
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/closest
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#polyfill
     */
  }, {
    key: "closest",
    value: function closest(selectors) {
      var el = this;
      do {
        if (runtime.sceneGraphService.matches(selectors, el)) return el;
        el = el.parentElement;
      } while (el !== null);
      return null;
    }
    /**
     * search in scene group, but should not include itself
     */
  }, {
    key: "find",
    value: function find5(filter2) {
      var _this2 = this;
      var target = null;
      this.forEach(function(object) {
        if (object !== _this2 && filter2(object)) {
          target = object;
          return false;
        }
        return true;
      });
      return target;
    }
  }, {
    key: "findAll",
    value: function findAll(filter2) {
      var _this3 = this;
      var objects = [];
      this.forEach(function(object) {
        if (object !== _this3 && filter2(object)) {
          objects.push(object);
        }
      });
      return objects;
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/after
     */
  }, {
    key: "after",
    value: function after() {
      var _this4 = this;
      if (this.parentNode) {
        var index2 = this.parentNode.childNodes.indexOf(this);
        for (var _len2 = arguments.length, nodes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          nodes[_key2] = arguments[_key2];
        }
        nodes.forEach(function(node, i) {
          var _this4$parentNode;
          return (_this4$parentNode = _this4.parentNode) === null || _this4$parentNode === void 0 ? void 0 : _this4$parentNode.appendChild(node, index2 + i + 1);
        });
      }
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/before
     */
  }, {
    key: "before",
    value: function before() {
      if (this.parentNode) {
        var _ref;
        var index2 = this.parentNode.childNodes.indexOf(this);
        for (var _len3 = arguments.length, nodes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          nodes[_key3] = arguments[_key3];
        }
        var first = nodes[0], rest = nodes.slice(1);
        this.parentNode.appendChild(first, index2);
        (_ref = first).after.apply(_ref, _toConsumableArray(rest));
      }
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/replaceWith
     */
  }, {
    key: "replaceWith",
    value: function replaceWith() {
      this.after.apply(this, arguments);
      this.remove();
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/append
     */
  }, {
    key: "append",
    value: function append() {
      var _this5 = this;
      for (var _len4 = arguments.length, nodes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        nodes[_key4] = arguments[_key4];
      }
      nodes.forEach(function(node) {
        return _this5.appendChild(node);
      });
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/prepend
     */
  }, {
    key: "prepend",
    value: function prepend() {
      var _this6 = this;
      for (var _len5 = arguments.length, nodes = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        nodes[_key5] = arguments[_key5];
      }
      nodes.forEach(function(node, i) {
        return _this6.appendChild(node, i);
      });
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/replaceChildren
     */
  }, {
    key: "replaceChildren",
    value: function replaceChildren2() {
      while (this.childNodes.length && this.firstChild) {
        this.removeChild(this.firstChild);
      }
      this.append.apply(this, arguments);
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/remove
     */
  }, {
    key: "remove",
    value: function remove() {
      if (this.parentNode) {
        return this.parentNode.removeChild(this);
      }
      return this;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this$ownerDocument3;
      var enableCancelEventPropagation = ((_this$ownerDocument3 = this.ownerDocument) === null || _this$ownerDocument3 === void 0 || (_this$ownerDocument3 = _this$ownerDocument3.defaultView) === null || _this$ownerDocument3 === void 0 || (_this$ownerDocument3 = _this$ownerDocument3.getConfig().future) === null || _this$ownerDocument3 === void 0 ? void 0 : _this$ownerDocument3.experimentalCancelEventPropagation) === true;
      this.destroyChildren();
      this.dispatchEvent(destroyEvent, enableCancelEventPropagation, enableCancelEventPropagation);
      this.remove();
      this.emitter.removeAllListeners();
      this.destroyed = true;
    }
  }, {
    key: "getGeometryBounds",
    value: function getGeometryBounds() {
      return runtime.sceneGraphService.getGeometryBounds(this);
    }
  }, {
    key: "getRenderBounds",
    value: function getRenderBounds() {
      return runtime.sceneGraphService.getBounds(this, true);
    }
    /**
     * get bounds in world space, account for children
     */
  }, {
    key: "getBounds",
    value: function getBounds2() {
      return runtime.sceneGraphService.getBounds(this);
    }
    /**
     * get bounds in local space, account for children
     */
  }, {
    key: "getLocalBounds",
    value: function getLocalBounds() {
      return runtime.sceneGraphService.getLocalBounds(this);
    }
    /**
     * account for context's bounds in client space,
     * but not accounting for children
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
     */
  }, {
    key: "getBoundingClientRect",
    value: function getBoundingClientRect() {
      return runtime.sceneGraphService.getBoundingClientRect(this);
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getClientRects
     */
  }, {
    key: "getClientRects",
    value: function getClientRects() {
      return [this.getBoundingClientRect()];
    }
  }, {
    key: "computedStyleMap",
    value: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/computedStyleMap
       * eg. circle.computedStyleMap().get('fill');
       */
      function computedStyleMap() {
        return new Map(Object.entries(this.computedStyle));
      }
    )
  }, {
    key: "getAttributeNames",
    value: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNames
       */
      function getAttributeNames() {
        return Object.keys(this.attributes);
      }
    )
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute
     */
  }, {
    key: "getAttribute",
    value: function getAttribute(name) {
      if (typeof name === "symbol") {
        return void 0;
      }
      var value = this.attributes[name];
      if (value === void 0) {
        return value;
      }
      return value;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/hasAttribute
     */
  }, {
    key: "hasAttribute",
    value: function hasAttribute(qualifiedName) {
      return this.getAttributeNames().includes(qualifiedName);
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/hasAttributes
     */
  }, {
    key: "hasAttributes",
    value: function hasAttributes() {
      return !!this.getAttributeNames().length;
    }
    /**
     * should use removeAttribute() instead of setting the attribute value to null either directly or using setAttribute(). Many attributes will not behave as expected if you set them to null.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute
     */
  }, {
    key: "removeAttribute",
    value: function removeAttribute(attributeName) {
      this.setAttribute(attributeName, null);
      delete this.attributes[attributeName];
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute
     */
  }, {
    key: "setAttribute",
    value: function setAttribute(attributeName, value, force, memoize3) {
      this.attributes[attributeName] = value;
    }
  }, {
    key: "getAttributeNS",
    value: function getAttributeNS(namespace, localName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "getAttributeNode",
    value: function getAttributeNode(qualifiedName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "getAttributeNodeNS",
    value: function getAttributeNodeNS(namespace, localName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "hasAttributeNS",
    value: function hasAttributeNS(namespace, localName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "removeAttributeNS",
    value: function removeAttributeNS(namespace, localName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "removeAttributeNode",
    value: function removeAttributeNode(attr2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "setAttributeNS",
    value: function setAttributeNS(namespace, qualifiedName, value) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "setAttributeNode",
    value: function setAttributeNode(attr2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "setAttributeNodeNS",
    value: function setAttributeNodeNS(attr2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "toggleAttribute",
    value: function toggleAttribute(qualifiedName, force) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }]);
}(Node);
function isDisplayObject(value) {
  return !!(value !== null && value !== void 0 && value.nodeName);
}
var Proxy = runtime.globalThis.Proxy ? runtime.globalThis.Proxy : function() {
};
var attrModifiedEvent = new MutationEvent(ElementEvent.ATTR_MODIFIED, null, null, null, null, MutationEvent.MODIFICATION, null, null);
var $vec3 = vec3_exports.create();
var $quat = quat_exports.create();
var DisplayObject = function(_Element) {
  function DisplayObject2(config) {
    var _this2;
    _classCallCheck(this, DisplayObject2);
    _this2 = _callSuper(this, DisplayObject2);
    _this2.isCustomElement = false;
    _this2.isMutationObserved = false;
    _this2.activeAnimations = [];
    _this2.config = config;
    _this2.id = config.id || "";
    _this2.name = config.name || "";
    if (config.className || config["class"]) {
      _this2.className = config.className || config["class"];
    }
    _this2.nodeName = config.type || Shape.GROUP;
    if (config.initialParsedStyle) {
      Object.assign(_this2.parsedStyle, config.initialParsedStyle);
    }
    _this2.initAttributes(config.style);
    if (runtime.enableStyleSyntax) {
      _this2.style = new Proxy(
        // @ts-ignore
        {
          // ...this.attributes,
          setProperty: function setProperty(propertyName, value) {
            _this2.setAttribute(propertyName, value);
          },
          getPropertyValue: function getPropertyValue(propertyName) {
            return _this2.getAttribute(propertyName);
          },
          removeProperty: function removeProperty(propertyName) {
            _this2.removeAttribute(propertyName);
          },
          item: function item() {
            return "";
          }
        },
        {
          get: function get(target, name) {
            if (target[name] !== void 0) {
              return target[name];
            }
            return _this2.getAttribute(name);
          },
          set: function set7(_2, prop, value) {
            _this2.setAttribute(prop, value);
            return true;
          }
        }
      );
    }
    return _this2;
  }
  _inherits(DisplayObject2, _Element);
  return _createClass(DisplayObject2, [{
    key: "destroy",
    value: function destroy() {
      _superPropGet(DisplayObject2, "destroy", this, 3)([]);
      this.getAnimations().forEach(function(animation) {
        animation.cancel();
      });
    }
  }, {
    key: "cloneNode",
    value: function cloneNode(deep2, customCloneFunc) {
      var clonedStyle = _objectSpread2({}, this.attributes);
      for (var attributeName in clonedStyle) {
        var attribute = clonedStyle[attributeName];
        if (isDisplayObject(attribute) && // share the same clipPath if possible
        attributeName !== "clipPath" && attributeName !== "offsetPath" && attributeName !== "textPath") {
          clonedStyle[attributeName] = attribute.cloneNode(deep2);
        }
        if (customCloneFunc) {
          clonedStyle[attributeName] = customCloneFunc(attributeName, attribute);
        }
      }
      var cloned = new this.constructor(_objectSpread2(_objectSpread2({}, this.config), {}, {
        style: clonedStyle
      }));
      cloned.setLocalTransform(this.getLocalTransform());
      if (deep2) {
        this.children.forEach(function(child) {
          if (!child.style.isMarker) {
            var clonedChild = child.cloneNode(deep2);
            cloned.appendChild(clonedChild);
          }
        });
      }
      return cloned;
    }
  }, {
    key: "initAttributes",
    value: function initAttributes() {
      var attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var options = {
        forceUpdateGeometry: true
      };
      runtime.styleValueRegistry.processProperties(this, attributes, options);
      this.dirty();
    }
  }, {
    key: "setAttribute",
    value: function setAttribute(name, value) {
      var force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var memoize3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      if (is_undefined_default(value)) {
        return;
      }
      if (force || value !== this.attributes[name]) {
        this.internalSetAttribute(name, value, {
          memoize: memoize3
        });
        _superPropGet(DisplayObject2, "setAttribute", this, 3)([name, value]);
      }
    }
    /**
     * called when attributes get changed or initialized
     */
  }, {
    key: "internalSetAttribute",
    value: function internalSetAttribute(name, value) {
      var parseOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var oldValue = this.attributes[name];
      var oldParsedValue = this.parsedStyle[name];
      runtime.styleValueRegistry.processProperties(this, _defineProperty({}, name, value), parseOptions);
      this.dirty();
      var newParsedValue = this.parsedStyle[name];
      if (this.isConnected) {
        attrModifiedEvent.relatedNode = this;
        attrModifiedEvent.prevValue = oldValue;
        attrModifiedEvent.newValue = value;
        attrModifiedEvent.attrName = name;
        attrModifiedEvent.prevParsedValue = oldParsedValue;
        attrModifiedEvent.newParsedValue = newParsedValue;
        if (this.isMutationObserved) {
          this.dispatchEvent(attrModifiedEvent);
        } else {
          var _this$ownerDocument$d;
          var enableCancelEventPropagation = ((_this$ownerDocument$d = this.ownerDocument.defaultView.getConfig().future) === null || _this$ownerDocument$d === void 0 ? void 0 : _this$ownerDocument$d.experimentalCancelEventPropagation) === true;
          attrModifiedEvent.target = this;
          this.ownerDocument.defaultView.dispatchEvent(attrModifiedEvent, true, enableCancelEventPropagation);
        }
      }
      if (this.isCustomElement && this.isConnected || !this.isCustomElement) {
        var _attributeChangedCall, _ref;
        (_attributeChangedCall = (_ref = this).attributeChangedCallback) === null || _attributeChangedCall === void 0 || _attributeChangedCall.call(_ref, name, oldValue, value, oldParsedValue, newParsedValue);
      }
    }
    // #region transformable
    /**
     * returns different values than getBoundingClientRect(), as the latter returns value relative to the viewport
     * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement/getBBox
     *
     * FIXME: It is worth noting that getBBox responds to original untransformed values of a drawn object.
     * @see https://www.w3.org/Graphics/SVG/IG/resources/svgprimer.html#getBBox
     */
  }, {
    key: "getBBox",
    value: function getBBox2() {
      var aabb = this.getBounds();
      var _aabb$getMin = aabb.getMin(), _aabb$getMin2 = _slicedToArray(_aabb$getMin, 2), left = _aabb$getMin2[0], top = _aabb$getMin2[1];
      var _aabb$getMax = aabb.getMax(), _aabb$getMax2 = _slicedToArray(_aabb$getMax, 2), right = _aabb$getMax2[0], bottom = _aabb$getMax2[1];
      return new Rectangle(left, top, right - left, bottom - top);
    }
  }, {
    key: "setOrigin",
    value: function setOrigin(position) {
      var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      runtime.sceneGraphService.setOrigin(this, createVec3(position, y3, z, false));
      return this;
    }
  }, {
    key: "getOrigin",
    value: function getOrigin() {
      return runtime.sceneGraphService.getOrigin(this);
    }
    /**
     * set position in world space
     */
  }, {
    key: "setPosition",
    value: function setPosition(position) {
      var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      runtime.sceneGraphService.setPosition(this, createVec3(position, y3, z, false));
      return this;
    }
    /**
     * set position in local space
     */
  }, {
    key: "setLocalPosition",
    value: function setLocalPosition(position) {
      var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      runtime.sceneGraphService.setLocalPosition(this, createVec3(position, y3, z, false));
      return this;
    }
    /**
     * translate in world space
     */
  }, {
    key: "translate",
    value: function translate5(position) {
      var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      runtime.sceneGraphService.translate(this, createVec3(position, y3, z, false));
      return this;
    }
    /**
     * translate in local space
     */
  }, {
    key: "translateLocal",
    value: function translateLocal(position) {
      var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      runtime.sceneGraphService.translateLocal(this, createVec3(position, y3, z, false));
      return this;
    }
  }, {
    key: "getPosition",
    value: function getPosition() {
      return runtime.sceneGraphService.getPosition(this);
    }
  }, {
    key: "getLocalPosition",
    value: function getLocalPosition() {
      return runtime.sceneGraphService.getLocalPosition(this);
    }
    /**
     * compatible with G 3.0
     *
     * scaling in local space
     * scale(10) = scale(10, 10, 10)
     *
     * we can't set scale in world space
     */
  }, {
    key: "scale",
    value: function scale9(scaling, y3, z) {
      return this.scaleLocal(scaling, y3, z);
    }
  }, {
    key: "scaleLocal",
    value: function scaleLocal(scaling, y3, z) {
      if (typeof scaling === "number") {
        y3 = y3 || scaling;
        z = z || scaling;
        scaling = createVec3(scaling, y3, z, false);
      }
      runtime.sceneGraphService.scaleLocal(this, scaling);
      return this;
    }
    /**
     * set scaling in local space
     */
  }, {
    key: "setLocalScale",
    value: function setLocalScale(scaling, y3, z) {
      if (typeof scaling === "number") {
        y3 = y3 || scaling;
        z = z || scaling;
        scaling = createVec3(scaling, y3, z, false);
      }
      runtime.sceneGraphService.setLocalScale(this, scaling);
      return this;
    }
    /**
     * get scaling in local space
     */
  }, {
    key: "getLocalScale",
    value: function getLocalScale() {
      return runtime.sceneGraphService.getLocalScale(this);
    }
    /**
     * get scaling in world space
     */
  }, {
    key: "getScale",
    value: function getScale() {
      return runtime.sceneGraphService.getScale(this);
    }
    /**
     * only return degrees of Z axis in world space
     */
  }, {
    key: "getEulerAngles",
    value: function getEulerAngles() {
      var _getEuler = getEuler($vec3, runtime.sceneGraphService.getWorldTransform(this)), _getEuler2 = _slicedToArray(_getEuler, 3), ez = _getEuler2[2];
      return rad2deg(ez);
    }
    /**
     * only return degrees of Z axis in local space
     */
  }, {
    key: "getLocalEulerAngles",
    value: function getLocalEulerAngles() {
      var _getEuler3 = getEuler($vec3, runtime.sceneGraphService.getLocalRotation(this)), _getEuler4 = _slicedToArray(_getEuler3, 3), ez = _getEuler4[2];
      return rad2deg(ez);
    }
    /**
     * set euler angles(degrees) in world space
     */
  }, {
    key: "setEulerAngles",
    value: function setEulerAngles(z) {
      runtime.sceneGraphService.setEulerAngles(this, 0, 0, z);
      return this;
    }
    /**
     * set euler angles(degrees) in local space
     */
  }, {
    key: "setLocalEulerAngles",
    value: function setLocalEulerAngles(z) {
      runtime.sceneGraphService.setLocalEulerAngles(this, 0, 0, z);
      return this;
    }
  }, {
    key: "rotateLocal",
    value: function rotateLocal(x3, y3, z) {
      if (isNil(y3) && isNil(z)) {
        runtime.sceneGraphService.rotateLocal(this, 0, 0, x3);
      } else {
        runtime.sceneGraphService.rotateLocal(this, x3, y3, z);
      }
      return this;
    }
  }, {
    key: "rotate",
    value: function rotate6(x3, y3, z) {
      if (isNil(y3) && isNil(z)) {
        runtime.sceneGraphService.rotate(this, 0, 0, x3);
      } else {
        runtime.sceneGraphService.rotate(this, x3, y3, z);
      }
      return this;
    }
  }, {
    key: "setRotation",
    value: function setRotation(rotation, y3, z, w) {
      runtime.sceneGraphService.setRotation(this, rotation, y3, z, w);
      return this;
    }
  }, {
    key: "setLocalRotation",
    value: function setLocalRotation(rotation, y3, z, w) {
      runtime.sceneGraphService.setLocalRotation(this, rotation, y3, z, w);
      return this;
    }
  }, {
    key: "setLocalSkew",
    value: function setLocalSkew(skew2, y3) {
      runtime.sceneGraphService.setLocalSkew(this, skew2, y3);
      return this;
    }
  }, {
    key: "getRotation",
    value: function getRotation2() {
      return runtime.sceneGraphService.getRotation(this);
    }
  }, {
    key: "getLocalRotation",
    value: function getLocalRotation() {
      return runtime.sceneGraphService.getLocalRotation(this);
    }
  }, {
    key: "getLocalSkew",
    value: function getLocalSkew() {
      return runtime.sceneGraphService.getLocalSkew(this);
    }
  }, {
    key: "getLocalTransform",
    value: function getLocalTransform() {
      return runtime.sceneGraphService.getLocalTransform(this);
    }
  }, {
    key: "getWorldTransform",
    value: function getWorldTransform() {
      return runtime.sceneGraphService.getWorldTransform(this);
    }
  }, {
    key: "setLocalTransform",
    value: function setLocalTransform(transform2) {
      runtime.sceneGraphService.setLocalTransform(this, transform2);
      return this;
    }
  }, {
    key: "resetLocalTransform",
    value: function resetLocalTransform() {
      runtime.sceneGraphService.resetLocalTransform(this);
    }
    // #endregion transformable
    // #region animatable
    /**
     * returns an array of all Animation objects affecting this element
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAnimations
     */
  }, {
    key: "getAnimations",
    value: function getAnimations() {
      return this.activeAnimations;
    }
    /**
     * create an animation with WAAPI
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/animate
     */
  }, {
    key: "animate",
    value: function animate2(keyframes, options) {
      var _this$ownerDocument;
      var timeline = (_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : _this$ownerDocument.timeline;
      if (timeline) {
        return timeline.play(this, keyframes, options);
      }
      return null;
    }
    // #endregion animatable
    // #region visible
    /**
     * shortcut for Used value of `visibility`
     */
  }, {
    key: "isVisible",
    value: function isVisible() {
      var _this$parsedStyle;
      return ((_this$parsedStyle = this.parsedStyle) === null || _this$parsedStyle === void 0 ? void 0 : _this$parsedStyle.visibility) !== "hidden";
    }
  }, {
    key: "interactive",
    get: function get() {
      return this.isInteractive();
    },
    set: function set7(b) {
      this.style.pointerEvents = b ? "auto" : "none";
    }
  }, {
    key: "isInteractive",
    value: function isInteractive() {
      var _this$parsedStyle2;
      return ((_this$parsedStyle2 = this.parsedStyle) === null || _this$parsedStyle2 === void 0 ? void 0 : _this$parsedStyle2.pointerEvents) !== "none";
    }
  }, {
    key: "isCulled",
    value: function isCulled() {
      return !!(this.cullable && this.cullable.enable && !this.cullable.visible);
    }
    /**
     * bring to front in current group
     */
  }, {
    key: "toFront",
    value: function toFront() {
      if (this.parentNode) {
        this.style.zIndex = Math.max.apply(Math, _toConsumableArray(this.parentNode.children.map(function(child) {
          return Number(child.style.zIndex);
        }))) + 1;
      }
      return this;
    }
    /**
     * send to back in current group
     */
  }, {
    key: "toBack",
    value: function toBack() {
      if (this.parentNode) {
        this.style.zIndex = Math.min.apply(Math, _toConsumableArray(this.parentNode.children.map(function(child) {
          return Number(child.style.zIndex);
        }))) - 1;
      }
      return this;
    }
    // #endregion visible
    // #region deprecated
    /**
     * compatible with G 3.0
     * @alias object.config
     * @deprecated
     */
  }, {
    key: "getConfig",
    value: function getConfig() {
      return this.config;
    }
    /**
     * @alias style
     * @example
     * circle.style.r = 10;
     * const r = circle.style;
     * @deprecated
     */
  }, {
    key: "attr",
    value: function attr2() {
      var _this2 = this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var name = args[0], value = args[1];
      if (!name) {
        return this.attributes;
      }
      if (is_object_default(name)) {
        Object.keys(name).forEach(function(key) {
          _this2.setAttribute(key, name[key]);
        });
        return this;
      }
      if (args.length === 2) {
        this.setAttribute(name, value);
        return this;
      }
      return this.attributes[name];
    }
    /**
     * return 3x3 matrix in world space
     * @deprecated
     */
  }, {
    key: "getMatrix",
    value: function getMatrix(transformMat44) {
      var transform2 = transformMat44 || this.getWorldTransform();
      var _mat4$getTranslation = mat4_exports.getTranslation($vec3, transform2), _mat4$getTranslation2 = _slicedToArray(_mat4$getTranslation, 2), tx = _mat4$getTranslation2[0], ty = _mat4$getTranslation2[1];
      var _mat4$getScaling = mat4_exports.getScaling($vec3, transform2), _mat4$getScaling2 = _slicedToArray(_mat4$getScaling, 2), sx = _mat4$getScaling2[0], sy = _mat4$getScaling2[1];
      var rotation = mat4_exports.getRotation($quat, transform2);
      var _getEuler5 = getEuler($vec3, rotation), _getEuler6 = _slicedToArray(_getEuler5, 3), eux = _getEuler6[0], euz = _getEuler6[2];
      return fromRotationTranslationScale2(eux || euz, tx, ty, sx, sy);
    }
    /**
     * return 3x3 matrix in local space
     * @deprecated
     */
  }, {
    key: "getLocalMatrix",
    value: function getLocalMatrix() {
      return this.getMatrix(this.getLocalTransform());
    }
    /**
     * set 3x3 matrix in world space
     * @deprecated
     */
  }, {
    key: "setMatrix",
    value: function setMatrix(mat) {
      var _decompose = decompose2(mat), _decompose2 = _slicedToArray(_decompose, 5), tx = _decompose2[0], ty = _decompose2[1], scalingX = _decompose2[2], scalingY = _decompose2[3], angle3 = _decompose2[4];
      this.setEulerAngles(angle3).setPosition(tx, ty).setLocalScale(scalingX, scalingY);
    }
    /**
     * set 3x3 matrix in local space
     * @deprecated
     */
  }, {
    key: "setLocalMatrix",
    value: function setLocalMatrix(mat) {
      var _decompose3 = decompose2(mat), _decompose4 = _slicedToArray(_decompose3, 5), tx = _decompose4[0], ty = _decompose4[1], scalingX = _decompose4[2], scalingY = _decompose4[3], angle3 = _decompose4[4];
      this.setLocalEulerAngles(angle3).setLocalPosition(tx, ty).setLocalScale(scalingX, scalingY);
    }
    /**
     * Use `visibility: visible` instead.
     * @deprecated
     */
  }, {
    key: "show",
    value: function show2() {
      this.forEach(function(object) {
        object.style.visibility = "visible";
      });
    }
    /**
     * Use `visibility: hidden` instead.
     * @deprecated
     */
  }, {
    key: "hide",
    value: function hide2() {
      this.forEach(function(object) {
        object.style.visibility = "hidden";
      });
    }
    /**
     * Use `childElementCount` instead.
     * @deprecated
     */
  }, {
    key: "getCount",
    value: function getCount() {
      return this.childElementCount;
    }
    /**
     * Use `parentElement` instead.
     * @deprecated
     */
  }, {
    key: "getParent",
    value: function getParent() {
      return this.parentElement;
    }
    /**
     * Use `children` instead.
     * @deprecated
     */
  }, {
    key: "getChildren",
    value: function getChildren() {
      return this.children;
    }
    /**
     * Use `firstElementChild` instead.
     * @deprecated
     */
  }, {
    key: "getFirst",
    value: function getFirst() {
      return this.firstElementChild;
    }
    /**
     * Use `lastElementChild` instead.
     * @deprecated
     */
  }, {
    key: "getLast",
    value: function getLast() {
      return this.lastElementChild;
    }
    /**
     * Use `this.children[index]` instead.
     * @deprecated
     */
  }, {
    key: "getChildByIndex",
    value: function getChildByIndex(index2) {
      return this.children[index2] || null;
    }
    /**
     * Use `appendChild` instead.
     * @deprecated
     */
  }, {
    key: "add",
    value: function add9(child, index2) {
      return this.appendChild(child, index2);
    }
    /**
     * @deprecated
     */
  }, {
    key: "set",
    value: function set7(name, value) {
      this.config[name] = value;
    }
    /**
     * @deprecated
     */
  }, {
    key: "get",
    value: function get(name) {
      return this.config[name];
    }
    /**
     * Use `setPosition` instead.
     * @deprecated
     */
  }, {
    key: "moveTo",
    value: function moveTo(position) {
      var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      this.setPosition(position, y3, z);
      return this;
    }
    /**
     * Use `setPosition` instead.
     * @deprecated
     */
  }, {
    key: "move",
    value: function move(position) {
      var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      this.setPosition(position, y3, z);
      return this;
    }
    /**
     * Use `this.style.zIndex` instead.
     * @deprecated
     */
  }, {
    key: "setZIndex",
    value: function setZIndex(zIndex) {
      this.style.zIndex = zIndex;
      return this;
    }
    // #endregion deprecated
  }]);
}(Element2);
DisplayObject.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className", "clipPath", "cursor", "display", "draggable", "droppable", "fill", "fillOpacity", "fillRule", "filter", "increasedLineWidthForHitTesting", "lineCap", "lineDash", "lineDashOffset", "lineJoin", "lineWidth", "miterLimit", "hitArea", "offsetDistance", "offsetPath", "offsetX", "offsetY", "opacity", "pointerEvents", "shadowColor", "shadowType", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "stroke", "strokeOpacity", "strokeWidth", "strokeLinecap", "strokeLineJoin", "strokeDasharray", "strokeDashoffset", "transform", "transformOrigin", "textTransform", "visibility", "zIndex"]);
var Circle = function(_DisplayObject) {
  function Circle2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Circle2);
    return _callSuper(this, Circle2, [_objectSpread2({
      type: Shape.CIRCLE
    }, options)]);
  }
  _inherits(Circle2, _DisplayObject);
  return _createClass(Circle2);
}(DisplayObject);
Circle.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["cx", "cy", "cz", "r", "isBillboard", "isSizeAttenuation"]));
var _excluded$6 = ["style"];
var CustomElement = function(_DisplayObject) {
  function CustomElement2() {
    var _this2;
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$6);
    _classCallCheck(this, CustomElement2);
    _this2 = _callSuper(this, CustomElement2, [_objectSpread2({
      style
    }, rest)]);
    _this2.isCustomElement = true;
    return _this2;
  }
  _inherits(CustomElement2, _DisplayObject);
  return _createClass(CustomElement2);
}(DisplayObject);
CustomElement.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className", "clipPath", "cursor", "draggable", "droppable", "opacity", "pointerEvents", "transform", "transformOrigin", "zIndex", "visibility"]);
var Ellipse = function(_DisplayObject) {
  function Ellipse2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Ellipse2);
    return _callSuper(this, Ellipse2, [_objectSpread2({
      type: Shape.ELLIPSE
    }, options)]);
  }
  _inherits(Ellipse2, _DisplayObject);
  return _createClass(Ellipse2);
}(DisplayObject);
Ellipse.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["cx", "cy", "cz", "rx", "ry", "isBillboard", "isSizeAttenuation"]));
var Fragment = function(_DisplayObject) {
  function Fragment2() {
    _classCallCheck(this, Fragment2);
    return _callSuper(this, Fragment2, [{
      type: Shape.FRAGMENT
    }]);
  }
  _inherits(Fragment2, _DisplayObject);
  return _createClass(Fragment2);
}(DisplayObject);
Fragment.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className"]);
var Group = function(_DisplayObject) {
  function Group2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Group2);
    return _callSuper(this, Group2, [_objectSpread2({
      type: Shape.GROUP
    }, options)]);
  }
  _inherits(Group2, _DisplayObject);
  return _createClass(Group2);
}(DisplayObject);
Group.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className", "clipPath", "cursor", "draggable", "droppable", "opacity", "pointerEvents", "transform", "transformOrigin", "zIndex", "visibility"]);
var _excluded$5 = ["style"];
var HTML = function(_DisplayObject) {
  function HTML2() {
    var _this2;
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$5);
    _classCallCheck(this, HTML2);
    _this2 = _callSuper(this, HTML2, [_objectSpread2({
      type: Shape.HTML,
      style
    }, rest)]);
    _this2.cullable.enable = false;
    return _this2;
  }
  _inherits(HTML2, _DisplayObject);
  return _createClass(HTML2, [{
    key: "getDomElement",
    value: function getDomElement() {
      return this.parsedStyle.$el;
    }
    /**
     * override with $el.getBoundingClientRect
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect
     *
     * ! The calculation logic of the html element should be consistent with that of the canvas element
     */
    // getBoundingClientRect(): Rectangle {
    //   if (this.parsedStyle.$el) {
    //     return this.parsedStyle.$el.getBoundingClientRect();
    //   } else {
    //     const { x, y, width, height } = this.parsedStyle;
    //     return new Rectangle(x, y, width, height);
    //   }
    // }
  }, {
    key: "getClientRects",
    value: function getClientRects() {
      return [this.getBoundingClientRect()];
    }
    // getBounds() {
    //   const clientRect = this.getBoundingClientRect();
    //   // calc context's offset
    //   // @ts-ignore
    //   const canvasRect = this.ownerDocument?.defaultView
    //     ?.getContextService()
    //     .getBoundingClientRect();
    //   const aabb = new AABB();
    //   const minX = clientRect.left - (canvasRect?.left || 0);
    //   const minY = clientRect.top - (canvasRect?.top || 0);
    //   aabb.setMinMax(
    //     [minX, minY, 0],
    //     [minX + clientRect.width, minY + clientRect.height, 0],
    //   );
    //   return aabb;
    // }
  }, {
    key: "getLocalBounds",
    value: function getLocalBounds() {
      if (this.parentNode) {
        var parentInvert = mat4_exports.invert(mat4_exports.create(), this.parentNode.getWorldTransform());
        var bounds = this.getBounds();
        if (!AABB.isEmpty(bounds)) {
          var localBounds = new AABB();
          localBounds.setFromTransformedAABB(bounds, parentInvert);
          return localBounds;
        }
      }
      return this.getBounds();
    }
  }]);
}(DisplayObject);
HTML.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x", "y", "$el", "innerHTML", "width", "height"]));
var Image2 = function(_DisplayObject) {
  function Image3() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Image3);
    return _callSuper(this, Image3, [_objectSpread2({
      type: Shape.IMAGE
    }, options)]);
  }
  _inherits(Image3, _DisplayObject);
  return _createClass(Image3);
}(DisplayObject);
Image2.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x", "y", "z", "src", "width", "height", "isBillboard", "billboardRotation", "isSizeAttenuation", "keepAspectRatio"]));
var _excluded$4 = ["style"];
var Line = function(_DisplayObject) {
  function Line2() {
    var _this2;
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$4);
    _classCallCheck(this, Line2);
    _this2 = _callSuper(this, Line2, [_objectSpread2({
      type: Shape.LINE,
      style: _objectSpread2({
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        z1: 0,
        z2: 0
      }, style)
    }, rest)]);
    _this2.markerStartAngle = 0;
    _this2.markerEndAngle = 0;
    var _this$parsedStyle = _this2.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd;
    if (markerStart && isDisplayObject(markerStart)) {
      _this2.markerStartAngle = markerStart.getLocalEulerAngles();
      _this2.appendChild(markerStart);
    }
    if (markerEnd && isDisplayObject(markerEnd)) {
      _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
      _this2.appendChild(markerEnd);
    }
    _this2.transformMarker(true);
    _this2.transformMarker(false);
    return _this2;
  }
  _inherits(Line2, _DisplayObject);
  return _createClass(Line2, [{
    key: "attributeChangedCallback",
    value: function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
      if (attrName === "x1" || attrName === "y1" || attrName === "x2" || attrName === "y2" || attrName === "markerStartOffset" || attrName === "markerEndOffset") {
        this.transformMarker(true);
        this.transformMarker(false);
      } else if (attrName === "markerStart") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerStartAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerStartAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(true);
        }
      } else if (attrName === "markerEnd") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerEndAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerEndAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(false);
        }
      }
    }
  }, {
    key: "transformMarker",
    value: function transformMarker(isStart) {
      var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset, x1 = _this$parsedStyle2.x1, x22 = _this$parsedStyle2.x2, y1 = _this$parsedStyle2.y1, y22 = _this$parsedStyle2.y2;
      var marker = isStart ? markerStart : markerEnd;
      if (!marker || !isDisplayObject(marker)) {
        return;
      }
      var rad2 = 0;
      var x3;
      var y3;
      var ox;
      var oy;
      var offset;
      var originalAngle;
      if (isStart) {
        ox = x1;
        oy = y1;
        x3 = x22 - x1;
        y3 = y22 - y1;
        offset = markerStartOffset || 0;
        originalAngle = this.markerStartAngle;
      } else {
        ox = x22;
        oy = y22;
        x3 = x1 - x22;
        y3 = y1 - y22;
        offset = markerEndOffset || 0;
        originalAngle = this.markerEndAngle;
      }
      rad2 = Math.atan2(y3, x3);
      marker.setLocalEulerAngles(rad2 * 180 / Math.PI + originalAngle);
      marker.setLocalPosition(ox + Math.cos(rad2) * offset, oy + Math.sin(rad2) * offset);
    }
  }, {
    key: "getPoint",
    value: function getPoint(ratio) {
      var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var _this$parsedStyle3 = this.parsedStyle, x1 = _this$parsedStyle3.x1, y1 = _this$parsedStyle3.y1, x22 = _this$parsedStyle3.x2, y22 = _this$parsedStyle3.y2;
      var _linePointAt = pointAt$3(x1, y1, x22, y22, ratio), x3 = _linePointAt.x, y3 = _linePointAt.y;
      var transformed = vec3_exports.transformMat4(vec3_exports.create(), vec3_exports.fromValues(x3, y3, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
      return new Point(transformed[0], transformed[1]);
    }
  }, {
    key: "getPointAtLength",
    value: function getPointAtLength2(distance6) {
      var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return this.getPoint(distance6 / this.getTotalLength(), inWorldSpace);
    }
  }, {
    key: "getTotalLength",
    value: function getTotalLength2() {
      var _this$parsedStyle4 = this.parsedStyle, x1 = _this$parsedStyle4.x1, y1 = _this$parsedStyle4.y1, x22 = _this$parsedStyle4.x2, y22 = _this$parsedStyle4.y2;
      return length$4(x1, y1, x22, y22);
    }
  }]);
}(DisplayObject);
Line.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x1", "y1", "x2", "y2", "z1", "z2", "isBillboard", "isSizeAttenuation", "markerStart", "markerEnd", "markerStartOffset", "markerEndOffset"]));
var _excluded$3 = ["style"];
var Path = function(_DisplayObject) {
  function Path2() {
    var _this2;
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$3);
    _classCallCheck(this, Path2);
    _this2 = _callSuper(this, Path2, [_objectSpread2({
      type: Shape.PATH,
      style,
      initialParsedStyle: {
        miterLimit: 4,
        d: _objectSpread2({}, EMPTY_PARSED_PATH)
      }
    }, rest)]);
    _this2.markerStartAngle = 0;
    _this2.markerEndAngle = 0;
    _this2.markerMidList = [];
    var _this$parsedStyle = _this2.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd, markerMid = _this$parsedStyle.markerMid;
    if (markerStart && isDisplayObject(markerStart)) {
      _this2.markerStartAngle = markerStart.getLocalEulerAngles();
      _this2.appendChild(markerStart);
    }
    if (markerMid && isDisplayObject(markerMid)) {
      _this2.placeMarkerMid(markerMid);
    }
    if (markerEnd && isDisplayObject(markerEnd)) {
      _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
      _this2.appendChild(markerEnd);
    }
    _this2.transformMarker(true);
    _this2.transformMarker(false);
    return _this2;
  }
  _inherits(Path2, _DisplayObject);
  return _createClass(Path2, [{
    key: "attributeChangedCallback",
    value: function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
      if (attrName === "d") {
        this.transformMarker(true);
        this.transformMarker(false);
        this.placeMarkerMid(this.parsedStyle.markerMid);
      } else if (attrName === "markerStartOffset" || attrName === "markerEndOffset") {
        this.transformMarker(true);
        this.transformMarker(false);
      } else if (attrName === "markerStart") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerStartAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerStartAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(true);
        }
      } else if (attrName === "markerEnd") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerEndAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerEndAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(false);
        }
      } else if (attrName === "markerMid") {
        this.placeMarkerMid(newParsedValue);
      }
    }
  }, {
    key: "transformMarker",
    value: function transformMarker(isStart) {
      var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset;
      var marker = isStart ? markerStart : markerEnd;
      if (!marker || !isDisplayObject(marker)) {
        return;
      }
      var rad2 = 0;
      var x3;
      var y3;
      var ox;
      var oy;
      var offset;
      var originalAngle;
      if (isStart) {
        var _this$getStartTangent = this.getStartTangent(), _this$getStartTangent2 = _slicedToArray(_this$getStartTangent, 2), p1 = _this$getStartTangent2[0], p2 = _this$getStartTangent2[1];
        ox = p2[0];
        oy = p2[1];
        x3 = p1[0] - p2[0];
        y3 = p1[1] - p2[1];
        offset = markerStartOffset || 0;
        originalAngle = this.markerStartAngle;
      } else {
        var _this$getEndTangent = this.getEndTangent(), _this$getEndTangent2 = _slicedToArray(_this$getEndTangent, 2), _p = _this$getEndTangent2[0], _p2 = _this$getEndTangent2[1];
        ox = _p2[0];
        oy = _p2[1];
        x3 = _p[0] - _p2[0];
        y3 = _p[1] - _p2[1];
        offset = markerEndOffset || 0;
        originalAngle = this.markerEndAngle;
      }
      rad2 = Math.atan2(y3, x3);
      marker.setLocalEulerAngles(rad2 * 180 / Math.PI + originalAngle);
      marker.setLocalPosition(ox + Math.cos(rad2) * offset, oy + Math.sin(rad2) * offset);
    }
  }, {
    key: "placeMarkerMid",
    value: function placeMarkerMid(marker) {
      var segments = this.parsedStyle.d.segments;
      this.markerMidList.forEach(function(marker2) {
        marker2.remove();
      });
      if (marker && isDisplayObject(marker)) {
        for (var i = 1; i < segments.length - 1; i++) {
          var _segments$i$currentPo = _slicedToArray(segments[i].currentPoint, 2), ox = _segments$i$currentPo[0], oy = _segments$i$currentPo[1];
          var cloned = i === 1 ? marker : marker.cloneNode(true);
          this.markerMidList.push(cloned);
          this.appendChild(cloned);
          cloned.setLocalPosition(ox, oy);
        }
      }
    }
    /**
     * Returns the total length of the path.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getTotalLength
     */
  }, {
    key: "getTotalLength",
    value: function getTotalLength2() {
      return getOrCalculatePathTotalLength(this);
    }
    /**
     * Returns the point at a given distance along the path.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getPointAtLength
     */
  }, {
    key: "getPointAtLength",
    value: function getPointAtLength$1(distance6) {
      var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var absolutePath = this.parsedStyle.d.absolutePath;
      var _getPointAtLength2 = getPointAtLength(absolutePath, distance6), x3 = _getPointAtLength2.x, y3 = _getPointAtLength2.y;
      var transformed = vec3_exports.transformMat4(vec3_exports.create(), vec3_exports.fromValues(x3, y3, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
      return new Point(transformed[0], transformed[1]);
    }
    /**
     * Returns the point at a given ratio of the total length in path.
     */
  }, {
    key: "getPoint",
    value: function getPoint(ratio) {
      var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return this.getPointAtLength(ratio * getOrCalculatePathTotalLength(this), inWorldSpace);
    }
    /**
     * Get start tangent vector
     */
  }, {
    key: "getStartTangent",
    value: function getStartTangent() {
      var segments = this.parsedStyle.d.segments;
      var result = [];
      if (segments.length > 1) {
        var startPoint = segments[0].currentPoint;
        var endPoint = segments[1].currentPoint;
        var tangent = segments[1].startTangent;
        result = [];
        if (tangent) {
          result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
          result.push([startPoint[0], startPoint[1]]);
        } else {
          result.push([endPoint[0], endPoint[1]]);
          result.push([startPoint[0], startPoint[1]]);
        }
      }
      return result;
    }
    /**
     * Get end tangent vector
     */
  }, {
    key: "getEndTangent",
    value: function getEndTangent() {
      var segments = this.parsedStyle.d.segments;
      var length5 = segments.length;
      var result = [];
      if (length5 > 1) {
        var startPoint = segments[length5 - 2].currentPoint;
        var endPoint = segments[length5 - 1].currentPoint;
        var tangent = segments[length5 - 1].endTangent;
        result = [];
        if (tangent) {
          result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
          result.push([endPoint[0], endPoint[1]]);
        } else {
          result.push([startPoint[0], startPoint[1]]);
          result.push([endPoint[0], endPoint[1]]);
        }
      }
      return result;
    }
  }]);
}(DisplayObject);
Path.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["d", "markerStart", "markerMid", "markerEnd", "markerStartOffset", "markerEndOffset", "isBillboard", "isSizeAttenuation"]));
var _excluded$2 = ["style"];
var Polygon = function(_DisplayObject) {
  function Polygon2() {
    var _this2;
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$2);
    _classCallCheck(this, Polygon2);
    _this2 = _callSuper(this, Polygon2, [_objectSpread2({
      type: Shape.POLYGON,
      style,
      initialParsedStyle: {
        points: {
          points: [],
          totalLength: 0,
          segments: []
        },
        miterLimit: 4,
        isClosed: true
      }
    }, rest)]);
    _this2.markerStartAngle = 0;
    _this2.markerEndAngle = 0;
    _this2.markerMidList = [];
    var _this$parsedStyle = _this2.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd, markerMid = _this$parsedStyle.markerMid;
    if (markerStart && isDisplayObject(markerStart)) {
      _this2.markerStartAngle = markerStart.getLocalEulerAngles();
      _this2.appendChild(markerStart);
    }
    if (markerMid && isDisplayObject(markerMid)) {
      _this2.placeMarkerMid(markerMid);
    }
    if (markerEnd && isDisplayObject(markerEnd)) {
      _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
      _this2.appendChild(markerEnd);
    }
    _this2.transformMarker(true);
    _this2.transformMarker(false);
    return _this2;
  }
  _inherits(Polygon2, _DisplayObject);
  return _createClass(Polygon2, [{
    key: "attributeChangedCallback",
    value: function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
      if (attrName === "points") {
        this.transformMarker(true);
        this.transformMarker(false);
        this.placeMarkerMid(this.parsedStyle.markerMid);
      } else if (attrName === "markerStartOffset" || attrName === "markerEndOffset") {
        this.transformMarker(true);
        this.transformMarker(false);
      } else if (attrName === "markerStart") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerStartAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerStartAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(true);
        }
      } else if (attrName === "markerEnd") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerEndAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerEndAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(false);
        }
      } else if (attrName === "markerMid") {
        this.placeMarkerMid(newParsedValue);
      }
    }
  }, {
    key: "transformMarker",
    value: function transformMarker(isStart) {
      var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset, P = _this$parsedStyle2.points;
      var _ref2 = P || {}, points = _ref2.points;
      var marker = isStart ? markerStart : markerEnd;
      if (!marker || !isDisplayObject(marker) || !points) {
        return;
      }
      var rad2 = 0;
      var x3;
      var y3;
      var ox;
      var oy;
      var offset;
      var originalAngle;
      ox = points[0][0];
      oy = points[0][1];
      if (isStart) {
        x3 = points[1][0] - points[0][0];
        y3 = points[1][1] - points[0][1];
        offset = markerStartOffset || 0;
        originalAngle = this.markerStartAngle;
      } else {
        var length5 = points.length;
        if (!this.parsedStyle.isClosed) {
          ox = points[length5 - 1][0];
          oy = points[length5 - 1][1];
          x3 = points[length5 - 2][0] - points[length5 - 1][0];
          y3 = points[length5 - 2][1] - points[length5 - 1][1];
        } else {
          x3 = points[length5 - 1][0] - points[0][0];
          y3 = points[length5 - 1][1] - points[0][1];
        }
        offset = markerEndOffset || 0;
        originalAngle = this.markerEndAngle;
      }
      rad2 = Math.atan2(y3, x3);
      marker.setLocalEulerAngles(rad2 * 180 / Math.PI + originalAngle);
      marker.setLocalPosition(ox + Math.cos(rad2) * offset, oy + Math.sin(rad2) * offset);
    }
  }, {
    key: "placeMarkerMid",
    value: function placeMarkerMid(marker) {
      var P = this.parsedStyle.points;
      var _ref3 = P || {}, points = _ref3.points;
      this.markerMidList.forEach(function(marker2) {
        marker2.remove();
      });
      this.markerMidList = [];
      if (marker && isDisplayObject(marker) && points) {
        for (var i = 1; i < (this.parsedStyle.isClosed ? points.length : points.length - 1); i++) {
          var ox = points[i][0];
          var oy = points[i][1];
          var cloned = i === 1 ? marker : marker.cloneNode(true);
          this.markerMidList.push(cloned);
          this.appendChild(cloned);
          cloned.setLocalPosition(ox, oy);
        }
      }
    }
  }]);
}(DisplayObject);
Polygon.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["points", "markerStart", "markerMid", "markerEnd", "markerStartOffset", "markerEndOffset", "isClosed", "isBillboard", "isSizeAttenuation"]));
var _excluded$1 = ["style"];
var Polyline = function(_Polygon) {
  function Polyline2() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$1);
    _classCallCheck(this, Polyline2);
    return _callSuper(this, Polyline2, [_objectSpread2({
      type: Shape.POLYLINE,
      style,
      initialParsedStyle: {
        points: {
          points: [],
          totalLength: 0,
          segments: []
        },
        miterLimit: 4,
        isClosed: false
      }
    }, rest)]);
  }
  _inherits(Polyline2, _Polygon);
  return _createClass(Polyline2, [{
    key: "getTotalLength",
    value: function getTotalLength2() {
      return getOrCalculatePolylineTotalLength(this);
    }
  }, {
    key: "getPointAtLength",
    value: function getPointAtLength2(distance6) {
      var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return this.getPoint(distance6 / this.getTotalLength(), inWorldSpace);
    }
  }, {
    key: "getPoint",
    value: function getPoint(ratio) {
      var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var points = this.parsedStyle.points.points;
      if (this.parsedStyle.points.segments.length === 0) {
        var segments = [];
        var tempLength = 0;
        var segmentT;
        var segmentL;
        var totalLength = this.getTotalLength();
        points.forEach(function(p, i) {
          if (points[i + 1]) {
            segmentT = [0, 0];
            segmentT[0] = tempLength / totalLength;
            segmentL = length$4(p[0], p[1], points[i + 1][0], points[i + 1][1]);
            tempLength += segmentL;
            segmentT[1] = tempLength / totalLength;
            segments.push(segmentT);
          }
        });
        this.parsedStyle.points.segments = segments;
      }
      var subt = 0;
      var index2 = 0;
      this.parsedStyle.points.segments.forEach(function(v, i) {
        if (ratio >= v[0] && ratio <= v[1]) {
          subt = (ratio - v[0]) / (v[1] - v[0]);
          index2 = i;
        }
      });
      var _linePointAt = pointAt$3(points[index2][0], points[index2][1], points[index2 + 1][0], points[index2 + 1][1], subt), x3 = _linePointAt.x, y3 = _linePointAt.y;
      var transformed = vec3_exports.transformMat4(vec3_exports.create(), vec3_exports.fromValues(x3, y3, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
      return new Point(transformed[0], transformed[1]);
    }
  }, {
    key: "getStartTangent",
    value: function getStartTangent() {
      var points = this.parsedStyle.points.points;
      var result = [];
      result.push([points[1][0], points[1][1]]);
      result.push([points[0][0], points[0][1]]);
      return result;
    }
  }, {
    key: "getEndTangent",
    value: function getEndTangent() {
      var points = this.parsedStyle.points.points;
      var l = points.length - 1;
      var result = [];
      result.push([points[l - 1][0], points[l - 1][1]]);
      result.push([points[l][0], points[l][1]]);
      return result;
    }
  }]);
}(Polygon);
Polyline.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(Polygon.PARSED_STYLE_LIST), ["points", "markerStart", "markerMid", "markerEnd", "markerStartOffset", "markerEndOffset", "isBillboard"]));
var Rect = function(_DisplayObject) {
  function Rect2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Rect2);
    return _callSuper(this, Rect2, [_objectSpread2({
      type: Shape.RECT
    }, options)]);
  }
  _inherits(Rect2, _DisplayObject);
  return _createClass(Rect2);
}(DisplayObject);
Rect.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x", "y", "z", "width", "height", "isBillboard", "isSizeAttenuation", "radius"]));
var _excluded = ["style"];
var Text = function(_DisplayObject) {
  function Text3() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded);
    _classCallCheck(this, Text3);
    return _callSuper(this, Text3, [_objectSpread2({
      type: Shape.TEXT,
      style: _objectSpread2({
        fill: "black"
      }, style)
    }, rest)]);
  }
  _inherits(Text3, _DisplayObject);
  return _createClass(Text3, [{
    key: "getComputedTextLength",
    value: function getComputedTextLength() {
      var _this$parsedStyle$met;
      this.getGeometryBounds();
      return ((_this$parsedStyle$met = this.parsedStyle.metrics) === null || _this$parsedStyle$met === void 0 ? void 0 : _this$parsedStyle$met.maxLineWidth) || 0;
    }
  }, {
    key: "getLineBoundingRects",
    value: function getLineBoundingRects() {
      var _this$parsedStyle$met2;
      this.getGeometryBounds();
      return ((_this$parsedStyle$met2 = this.parsedStyle.metrics) === null || _this$parsedStyle$met2 === void 0 ? void 0 : _this$parsedStyle$met2.lineMetrics) || [];
    }
  }, {
    key: "isOverflowing",
    value: function isOverflowing() {
      this.getGeometryBounds();
      return !!this.parsedStyle.isOverflowing;
    }
  }]);
}(DisplayObject);
Text.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x", "y", "z", "isBillboard", "billboardRotation", "isSizeAttenuation", "text", "textAlign", "textBaseline", "fontStyle", "fontSize", "fontFamily", "fontWeight", "fontVariant", "lineHeight", "letterSpacing", "leading", "wordWrap", "wordWrapWidth", "maxLines", "textOverflow", "isOverflowing", "textPath", "textDecorationLine", "textDecorationColor", "textDecorationStyle", "textPathSide", "textPathStartOffset", "metrics", "dx", "dy"]));
var CustomElementRegistry = function() {
  function CustomElementRegistry2() {
    _classCallCheck(this, CustomElementRegistry2);
    this.registry = {};
    this.define(Shape.CIRCLE, Circle);
    this.define(Shape.ELLIPSE, Ellipse);
    this.define(Shape.RECT, Rect);
    this.define(Shape.IMAGE, Image2);
    this.define(Shape.LINE, Line);
    this.define(Shape.GROUP, Group);
    this.define(Shape.PATH, Path);
    this.define(Shape.POLYGON, Polygon);
    this.define(Shape.POLYLINE, Polyline);
    this.define(Shape.TEXT, Text);
    this.define(Shape.HTML, HTML);
  }
  return _createClass(CustomElementRegistry2, [{
    key: "define",
    value: function define3(name, constructor) {
      this.registry[name] = constructor;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/get
     */
  }, {
    key: "get",
    value: function get(name) {
      return this.registry[name];
    }
  }]);
}();
var CSS = {
  /**
   * <number>
   * @see https://drafts.csswg.org/css-values-4/#number-value
   */
  number: function number(n) {
    return new CSSUnitValue(n);
  },
  /**
   * <percentage>
   * @see https://drafts.csswg.org/css-values-4/#percentage-value
   */
  percent: function percent(n) {
    return new CSSUnitValue(n, "%");
  },
  /**
   * <length>
   */
  px: function px(n) {
    return new CSSUnitValue(n, "px");
  },
  /**
   * <length>
   */
  em: function em(n) {
    return new CSSUnitValue(n, "em");
  },
  rem: function rem(n) {
    return new CSSUnitValue(n, "rem");
  },
  /**
   * <angle>
   */
  deg: function deg(n) {
    return new CSSUnitValue(n, "deg");
  },
  /**
   * <angle>
   */
  grad: function grad(n) {
    return new CSSUnitValue(n, "grad");
  },
  /**
   * <angle>
   */
  rad: function rad(n) {
    return new CSSUnitValue(n, "rad");
  },
  /**
   * <angle>
   */
  turn: function turn(n) {
    return new CSSUnitValue(n, "turn");
  },
  /**
   * <time>
   */
  s: function s(n) {
    return new CSSUnitValue(n, "s");
  },
  /**
   * <time>
   */
  ms: function ms(n) {
    return new CSSUnitValue(n, "ms");
  },
  /**
   * CSS Properties & Values API
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS_Properties_and_Values_API
   * @see https://drafts.css-houdini.org/css-properties-values-api/#registering-custom-properties
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS/RegisterProperty
   */
  registerProperty: function registerProperty(definition) {
    var name = definition.name, inherits = definition.inherits, interpolable = definition.interpolable, initialValue = definition.initialValue, syntax = definition.syntax;
    runtime.styleValueRegistry.registerMetadata({
      n: name,
      inh: inherits,
      "int": interpolable,
      d: initialValue,
      syntax
    });
  },
  /**
   * CSS Layout API
   * register layout
   *
   * @see https://github.com/w3c/css-houdini-drafts/blob/main/css-layout-api/EXPLAINER.md
   * @see https://developer.mozilla.org/en-US/docs/Web/Guide/Houdini#css_layout_api
   */
  registerLayout: function registerLayout(name, clazz) {
    runtime.layoutRegistry.registerLayout(name, clazz);
  }
};
var Document2 = function(_Node) {
  function Document3() {
    var _this2;
    _classCallCheck(this, Document3);
    _this2 = _callSuper(this, Document3);
    _this2.defaultView = null;
    _this2.ownerDocument = null;
    _this2.nodeName = "document";
    try {
      _this2.timeline = new runtime.AnimationTimeline(_this2);
    } catch (_unused) {
    }
    var initialStyle = {};
    BUILT_IN_PROPERTIES.forEach(function(_ref) {
      var n = _ref.n, inh = _ref.inh, d2 = _ref.d;
      if (inh && d2) {
        initialStyle[n] = isFunction(d2) ? d2(Shape.GROUP) : d2;
      }
    });
    _this2.documentElement = new Group({
      id: "g-root",
      style: initialStyle
    });
    _this2.documentElement.ownerDocument = _this2;
    _this2.documentElement.parentNode = _this2;
    _this2.childNodes = [_this2.documentElement];
    return _this2;
  }
  _inherits(Document3, _Node);
  return _createClass(Document3, [{
    key: "children",
    get: function get() {
      return this.childNodes;
    }
  }, {
    key: "childElementCount",
    get: function get() {
      return this.childNodes.length;
    }
  }, {
    key: "firstElementChild",
    get: function get() {
      return this.firstChild;
    }
  }, {
    key: "lastElementChild",
    get: function get() {
      return this.lastChild;
    }
  }, {
    key: "createElement",
    value: (
      /**
       * @example const circle = document.createElement('circle', { style: { r: 10 } });
       */
      function createElement2(tagName, options) {
        if (tagName === "svg") {
          return this.documentElement;
        }
        var clazz = this.defaultView.customElements.get(tagName);
        if (!clazz) {
          console.warn("Unsupported tagName: ", tagName);
          clazz = tagName === "tspan" ? Text : Group;
        }
        var shape = new clazz(options);
        shape.ownerDocument = this;
        return shape;
      }
    )
  }, {
    key: "createElementNS",
    value: function createElementNS(namespaceURI, tagName, options) {
      return this.createElement(tagName, options);
    }
  }, {
    key: "cloneNode",
    value: function cloneNode(deep2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      try {
        this.documentElement.destroyChildren();
        this.timeline.destroy();
      } catch (_unused2) {
      }
    }
    /**
     * Picking 2D graphics with RBush based on BBox, fast but inaccurate.
     */
  }, {
    key: "elementsFromBBox",
    value: function elementsFromBBox(minX, minY, maxX, maxY) {
      var rBush = this.defaultView.context.rBushRoot;
      var rBushNodes = rBush.search({
        minX,
        minY,
        maxX,
        maxY
      });
      var hitTestList = [];
      rBushNodes.forEach(function(_ref2) {
        var displayObject = _ref2.displayObject;
        var _displayObject$parsed = displayObject.parsedStyle.pointerEvents, pointerEvents = _displayObject$parsed === void 0 ? "auto" : _displayObject$parsed;
        var isVisibilityAffected = ["auto", "visiblepainted", "visiblefill", "visiblestroke", "visible"].includes(pointerEvents);
        if ((!isVisibilityAffected || isVisibilityAffected && displayObject.isVisible()) && !displayObject.isCulled() && displayObject.isInteractive()) {
          hitTestList.push(displayObject);
        }
      });
      hitTestList.sort(function(a2, b) {
        return b.sortable.renderOrder - a2.sortable.renderOrder;
      });
      return hitTestList;
    }
  }, {
    key: "elementFromPointSync",
    value: function elementFromPointSync(x3, y3) {
      var _this$defaultView$can = this.defaultView.canvas2Viewport({
        x: x3,
        y: y3
      }), viewportX = _this$defaultView$can.x, viewportY = _this$defaultView$can.y;
      var _this$defaultView$get = this.defaultView.getConfig(), width = _this$defaultView$get.width, height = _this$defaultView$get.height;
      if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
        return null;
      }
      var _this$defaultView$vie = this.defaultView.viewport2Client({
        x: viewportX,
        y: viewportY
      }), clientX = _this$defaultView$vie.x, clientY = _this$defaultView$vie.y;
      var _this$defaultView$get2 = this.defaultView.getRenderingService().hooks.pickSync.call({
        topmost: true,
        position: {
          x: x3,
          y: y3,
          viewportX,
          viewportY,
          clientX,
          clientY
        },
        picked: []
      }), picked = _this$defaultView$get2.picked;
      return picked && picked[0] || this.documentElement;
    }
    /**
     * Do picking with API instead of triggering interactive events.
     *
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementFromPoint
     */
  }, {
    key: "elementFromPoint",
    value: function() {
      var _elementFromPoint = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(x3, y3) {
        var _this$defaultView$can2, viewportX, viewportY, _this$defaultView$get3, width, height, _this$defaultView$vie2, clientX, clientY, _yield$this$defaultVi, picked;
        return _regeneratorRuntime().wrap(function(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _this$defaultView$can2 = this.defaultView.canvas2Viewport({
                x: x3,
                y: y3
              }), viewportX = _this$defaultView$can2.x, viewportY = _this$defaultView$can2.y;
              _this$defaultView$get3 = this.defaultView.getConfig(), width = _this$defaultView$get3.width, height = _this$defaultView$get3.height;
              if (!(viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height)) {
                _context.next = 1;
                break;
              }
              return _context.abrupt("return", null);
            case 1:
              _this$defaultView$vie2 = this.defaultView.viewport2Client({
                x: viewportX,
                y: viewportY
              }), clientX = _this$defaultView$vie2.x, clientY = _this$defaultView$vie2.y;
              _context.next = 2;
              return this.defaultView.getRenderingService().hooks.pick.promise({
                topmost: true,
                position: {
                  x: x3,
                  y: y3,
                  viewportX,
                  viewportY,
                  clientX,
                  clientY
                },
                picked: []
              });
            case 2:
              _yield$this$defaultVi = _context.sent;
              picked = _yield$this$defaultVi.picked;
              return _context.abrupt("return", picked && picked[0] || this.documentElement);
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function elementFromPoint(_x, _x2) {
        return _elementFromPoint.apply(this, arguments);
      }
      return elementFromPoint;
    }()
  }, {
    key: "elementsFromPointSync",
    value: function elementsFromPointSync(x3, y3) {
      var _this$defaultView$can3 = this.defaultView.canvas2Viewport({
        x: x3,
        y: y3
      }), viewportX = _this$defaultView$can3.x, viewportY = _this$defaultView$can3.y;
      var _this$defaultView$get4 = this.defaultView.getConfig(), width = _this$defaultView$get4.width, height = _this$defaultView$get4.height;
      if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
        return [];
      }
      var _this$defaultView$vie3 = this.defaultView.viewport2Client({
        x: viewportX,
        y: viewportY
      }), clientX = _this$defaultView$vie3.x, clientY = _this$defaultView$vie3.y;
      var _this$defaultView$get5 = this.defaultView.getRenderingService().hooks.pickSync.call({
        topmost: false,
        position: {
          x: x3,
          y: y3,
          viewportX,
          viewportY,
          clientX,
          clientY
        },
        picked: []
      }), picked = _this$defaultView$get5.picked;
      if (picked[picked.length - 1] !== this.documentElement) {
        picked.push(this.documentElement);
      }
      return picked;
    }
    /**
     * Do picking with API instead of triggering interactive events.
     *
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementsFromPoint
     */
  }, {
    key: "elementsFromPoint",
    value: function() {
      var _elementsFromPoint = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(x3, y3) {
        var _this$defaultView$can4, viewportX, viewportY, _this$defaultView$get6, width, height, _this$defaultView$vie4, clientX, clientY, _yield$this$defaultVi2, picked;
        return _regeneratorRuntime().wrap(function(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _this$defaultView$can4 = this.defaultView.canvas2Viewport({
                x: x3,
                y: y3
              }), viewportX = _this$defaultView$can4.x, viewportY = _this$defaultView$can4.y;
              _this$defaultView$get6 = this.defaultView.getConfig(), width = _this$defaultView$get6.width, height = _this$defaultView$get6.height;
              if (!(viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height)) {
                _context2.next = 1;
                break;
              }
              return _context2.abrupt("return", []);
            case 1:
              _this$defaultView$vie4 = this.defaultView.viewport2Client({
                x: viewportX,
                y: viewportY
              }), clientX = _this$defaultView$vie4.x, clientY = _this$defaultView$vie4.y;
              _context2.next = 2;
              return this.defaultView.getRenderingService().hooks.pick.promise({
                topmost: false,
                position: {
                  x: x3,
                  y: y3,
                  viewportX,
                  viewportY,
                  clientX,
                  clientY
                },
                picked: []
              });
            case 2:
              _yield$this$defaultVi2 = _context2.sent;
              picked = _yield$this$defaultVi2.picked;
              if (picked[picked.length - 1] !== this.documentElement) {
                picked.push(this.documentElement);
              }
              return _context2.abrupt("return", picked);
            case 3:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function elementsFromPoint(_x3, _x4) {
        return _elementsFromPoint.apply(this, arguments);
      }
      return elementsFromPoint;
    }()
  }, {
    key: "appendChild",
    value: function appendChild(newChild, index2) {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(newChild, refChild) {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
  }, {
    key: "removeChild",
    value: function removeChild(oldChild, destroy) {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
  }, {
    key: "replaceChild",
    value: function replaceChild(newChild, oldChild, destroy) {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
  }, {
    key: "append",
    value: function append() {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
  }, {
    key: "prepend",
    value: function prepend() {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
    /**
     * Execute query on documentElement.
     */
  }, {
    key: "getElementById",
    value: function getElementById(id3) {
      return this.documentElement.getElementById(id3);
    }
  }, {
    key: "getElementsByName",
    value: function getElementsByName(name) {
      return this.documentElement.getElementsByName(name);
    }
  }, {
    key: "getElementsByTagName",
    value: function getElementsByTagName(tagName) {
      return this.documentElement.getElementsByTagName(tagName);
    }
  }, {
    key: "getElementsByClassName",
    value: function getElementsByClassName(className) {
      return this.documentElement.getElementsByClassName(className);
    }
  }, {
    key: "querySelector",
    value: function querySelector(selectors) {
      return this.documentElement.querySelector(selectors);
    }
  }, {
    key: "querySelectorAll",
    value: function querySelectorAll(selectors) {
      return this.documentElement.querySelectorAll(selectors);
    }
  }, {
    key: "find",
    value: function find5(filter2) {
      return this.documentElement.find(filter2);
    }
  }, {
    key: "findAll",
    value: function findAll(filter2) {
      return this.documentElement.findAll(filter2);
    }
  }]);
}(Node);
var CullingPlugin = function() {
  function CullingPlugin2(strategies) {
    _classCallCheck(this, CullingPlugin2);
    this.strategies = strategies;
  }
  return _createClass(CullingPlugin2, [{
    key: "apply",
    value: function apply(context) {
      var config = context.config, camera = context.camera, renderingService = context.renderingService, renderingContext = context.renderingContext;
      var strategies = this.strategies;
      renderingService.hooks.cull.tap(CullingPlugin2.tag, function(object) {
        if (object) {
          var _config$future;
          var cullable = object.cullable;
          if (strategies.length === 0) {
            cullable.visible = renderingContext.unculledEntities.indexOf(object.entity) > -1;
          } else {
            cullable.visible = strategies.every(function(strategy) {
              return strategy.isVisible(camera, object);
            });
          }
          if (!object.isCulled() && object.isVisible()) {
            return object;
          }
          var enableCancelEventPropagation = ((_config$future = config.future) === null || _config$future === void 0 ? void 0 : _config$future.experimentalCancelEventPropagation) === true;
          object.dispatchEvent(new CustomEvent(ElementEvent.CULLED), enableCancelEventPropagation, enableCancelEventPropagation);
          return null;
        }
        return object;
      });
      renderingService.hooks.afterRender.tap(CullingPlugin2.tag, function(object) {
        object.cullable.visibilityPlaneMask = -1;
      });
    }
  }]);
}();
CullingPlugin.tag = "Culling";
var EventPlugin = function() {
  function EventPlugin2() {
    var _this2 = this;
    _classCallCheck(this, EventPlugin2);
    this.autoPreventDefault = false;
    this.rootPointerEvent = new FederatedPointerEvent(null);
    this.rootWheelEvent = new FederatedWheelEvent(null);
    this.onPointerMove = function(nativeEvent) {
      var _this$context$renderi;
      var canvas = (_this$context$renderi = _this2.context.renderingContext.root) === null || _this$context$renderi === void 0 || (_this$context$renderi = _this$context$renderi.ownerDocument) === null || _this$context$renderi === void 0 ? void 0 : _this$context$renderi.defaultView;
      if (canvas.supportsTouchEvents && nativeEvent.pointerType === "touch") return;
      var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
      var _iterator = _createForOfIteratorHelper(normalizedEvents), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var normalizedEvent = _step.value;
          var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
          _this2.context.eventService.mapEvent(event);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      _this2.setCursor(_this2.context.eventService.cursor);
    };
    this.onClick = function(nativeEvent) {
      var _this$context$renderi2;
      var canvas = (_this$context$renderi2 = _this2.context.renderingContext.root) === null || _this$context$renderi2 === void 0 || (_this$context$renderi2 = _this$context$renderi2.ownerDocument) === null || _this$context$renderi2 === void 0 ? void 0 : _this$context$renderi2.defaultView;
      var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
      var _iterator2 = _createForOfIteratorHelper(normalizedEvents), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var normalizedEvent = _step2.value;
          var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
          _this2.context.eventService.mapEvent(event);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      _this2.setCursor(_this2.context.eventService.cursor);
    };
  }
  return _createClass(EventPlugin2, [{
    key: "apply",
    value: function apply(context) {
      var _this2 = this;
      this.context = context;
      var renderingService = context.renderingService;
      var canvas = this.context.renderingContext.root.ownerDocument.defaultView;
      this.context.eventService.setPickHandler(function(position) {
        var _this2$context$render = _this2.context.renderingService.hooks.pickSync.call({
          position,
          picked: [],
          topmost: true
          // we only concern the topmost element
        }), picked = _this2$context$render.picked;
        return picked[0] || null;
      });
      renderingService.hooks.pointerWheel.tap(EventPlugin2.tag, function(nativeEvent) {
        var wheelEvent = _this2.normalizeWheelEvent(nativeEvent);
        _this2.context.eventService.mapEvent(wheelEvent);
      });
      renderingService.hooks.pointerDown.tap(EventPlugin2.tag, function(nativeEvent) {
        if (canvas.supportsTouchEvents && nativeEvent.pointerType === "touch") return;
        var events = _this2.normalizeToPointerEvent(nativeEvent, canvas);
        if (_this2.autoPreventDefault && events[0].isNormalized) {
          var cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
          if (cancelable) {
            nativeEvent.preventDefault();
          }
        }
        var _iterator3 = _createForOfIteratorHelper(events), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var event = _step3.value;
            var federatedEvent = _this2.bootstrapEvent(_this2.rootPointerEvent, event, canvas, nativeEvent);
            _this2.context.eventService.mapEvent(federatedEvent);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        _this2.setCursor(_this2.context.eventService.cursor);
      });
      renderingService.hooks.pointerUp.tap(EventPlugin2.tag, function(nativeEvent) {
        if (canvas.supportsTouchEvents && nativeEvent.pointerType === "touch") return;
        var $element = _this2.context.contextService.getDomElement();
        var isNativeEventFromCanvas = _this2.context.eventService.isNativeEventFromCanvas($element, nativeEvent);
        var outside = !isNativeEventFromCanvas ? "outside" : "";
        var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
        var _iterator4 = _createForOfIteratorHelper(normalizedEvents), _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
            var normalizedEvent = _step4.value;
            var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
            event.type += outside;
            _this2.context.eventService.mapEvent(event);
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        _this2.setCursor(_this2.context.eventService.cursor);
      });
      renderingService.hooks.pointerMove.tap(EventPlugin2.tag, this.onPointerMove);
      renderingService.hooks.pointerOver.tap(EventPlugin2.tag, this.onPointerMove);
      renderingService.hooks.pointerOut.tap(EventPlugin2.tag, this.onPointerMove);
      renderingService.hooks.click.tap(EventPlugin2.tag, this.onClick);
      renderingService.hooks.pointerCancel.tap(EventPlugin2.tag, function(nativeEvent) {
        var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
        var _iterator5 = _createForOfIteratorHelper(normalizedEvents), _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
            var normalizedEvent = _step5.value;
            var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
            _this2.context.eventService.mapEvent(event);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
        _this2.setCursor(_this2.context.eventService.cursor);
      });
    }
  }, {
    key: "bootstrapEvent",
    value: function bootstrapEvent(event, normalizedEvent, view, nativeEvent) {
      event.view = view;
      event.originalEvent = null;
      event.nativeEvent = nativeEvent;
      event.pointerId = normalizedEvent.pointerId;
      event.width = normalizedEvent.width;
      event.height = normalizedEvent.height;
      event.isPrimary = normalizedEvent.isPrimary;
      event.pointerType = normalizedEvent.pointerType;
      event.pressure = normalizedEvent.pressure;
      event.tangentialPressure = normalizedEvent.tangentialPressure;
      event.tiltX = normalizedEvent.tiltX;
      event.tiltY = normalizedEvent.tiltY;
      event.twist = normalizedEvent.twist;
      this.transferMouseData(event, normalizedEvent);
      var _this$context$eventSe = this.context.eventService.client2Viewport({
        x: normalizedEvent.clientX,
        y: normalizedEvent.clientY
      }), x3 = _this$context$eventSe.x, y3 = _this$context$eventSe.y;
      event.viewport.x = x3;
      event.viewport.y = y3;
      var _this$context$eventSe2 = this.context.eventService.viewport2Canvas(event.viewport), canvasX = _this$context$eventSe2.x, canvasY = _this$context$eventSe2.y;
      event.canvas.x = canvasX;
      event.canvas.y = canvasY;
      event.global.copyFrom(event.canvas);
      event.offset.copyFrom(event.canvas);
      event.isTrusted = nativeEvent.isTrusted;
      if (event.type === "pointerleave") {
        event.type = "pointerout";
      }
      if (event.type.startsWith("mouse")) {
        event.type = event.type.replace("mouse", "pointer");
      }
      if (event.type.startsWith("touch")) {
        event.type = TOUCH_TO_POINTER[event.type] || event.type;
      }
      return event;
    }
  }, {
    key: "normalizeWheelEvent",
    value: function normalizeWheelEvent(nativeEvent) {
      var event = this.rootWheelEvent;
      this.transferMouseData(event, nativeEvent);
      event.deltaMode = nativeEvent.deltaMode;
      event.deltaX = nativeEvent.deltaX;
      event.deltaY = nativeEvent.deltaY;
      event.deltaZ = nativeEvent.deltaZ;
      var _this$context$eventSe3 = this.context.eventService.client2Viewport({
        x: nativeEvent.clientX,
        y: nativeEvent.clientY
      }), x3 = _this$context$eventSe3.x, y3 = _this$context$eventSe3.y;
      event.viewport.x = x3;
      event.viewport.y = y3;
      var _this$context$eventSe4 = this.context.eventService.viewport2Canvas(event.viewport), canvasX = _this$context$eventSe4.x, canvasY = _this$context$eventSe4.y;
      event.canvas.x = canvasX;
      event.canvas.y = canvasY;
      event.global.copyFrom(event.canvas);
      event.offset.copyFrom(event.canvas);
      event.nativeEvent = nativeEvent;
      event.type = nativeEvent.type;
      return event;
    }
    /**
     * Transfers base & mouse event data from the nativeEvent to the federated event.
     */
  }, {
    key: "transferMouseData",
    value: function transferMouseData(event, nativeEvent) {
      event.isTrusted = nativeEvent.isTrusted;
      event.srcElement = nativeEvent.srcElement;
      event.timeStamp = clock.now();
      event.type = nativeEvent.type;
      event.altKey = nativeEvent.altKey;
      event.metaKey = nativeEvent.metaKey;
      event.shiftKey = nativeEvent.shiftKey;
      event.ctrlKey = nativeEvent.ctrlKey;
      event.button = nativeEvent.button;
      event.buttons = nativeEvent.buttons;
      event.client.x = nativeEvent.clientX;
      event.client.y = nativeEvent.clientY;
      event.movement.x = nativeEvent.movementX;
      event.movement.y = nativeEvent.movementY;
      event.page.x = nativeEvent.pageX;
      event.page.y = nativeEvent.pageY;
      event.screen.x = nativeEvent.screenX;
      event.screen.y = nativeEvent.screenY;
      event.relatedTarget = null;
    }
  }, {
    key: "setCursor",
    value: function setCursor(cursor) {
      this.context.contextService.applyCursorStyle(cursor || this.context.config.cursor || "default");
    }
  }, {
    key: "normalizeToPointerEvent",
    value: function normalizeToPointerEvent(event, canvas) {
      var normalizedEvents = [];
      if (canvas.isTouchEvent(event)) {
        for (var i = 0; i < event.changedTouches.length; i++) {
          var touch = event.changedTouches[i];
          if (is_undefined_default(touch.button)) touch.button = 0;
          if (is_undefined_default(touch.buttons)) touch.buttons = 1;
          if (is_undefined_default(touch.isPrimary)) {
            touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
          }
          if (is_undefined_default(touch.width)) touch.width = touch.radiusX || 1;
          if (is_undefined_default(touch.height)) touch.height = touch.radiusY || 1;
          if (is_undefined_default(touch.tiltX)) touch.tiltX = 0;
          if (is_undefined_default(touch.tiltY)) touch.tiltY = 0;
          if (is_undefined_default(touch.pointerType)) touch.pointerType = "touch";
          if (is_undefined_default(touch.pointerId)) touch.pointerId = touch.identifier || 0;
          if (is_undefined_default(touch.pressure)) touch.pressure = touch.force || 0.5;
          if (is_undefined_default(touch.twist)) touch.twist = 0;
          if (is_undefined_default(touch.tangentialPressure)) touch.tangentialPressure = 0;
          touch.isNormalized = true;
          touch.type = event.type;
          normalizedEvents.push(touch);
        }
      } else if (canvas.isMouseEvent(event)) {
        var tempEvent = event;
        if (is_undefined_default(tempEvent.isPrimary)) tempEvent.isPrimary = true;
        if (is_undefined_default(tempEvent.width)) tempEvent.width = 1;
        if (is_undefined_default(tempEvent.height)) tempEvent.height = 1;
        if (is_undefined_default(tempEvent.tiltX)) tempEvent.tiltX = 0;
        if (is_undefined_default(tempEvent.tiltY)) tempEvent.tiltY = 0;
        if (is_undefined_default(tempEvent.pointerType)) tempEvent.pointerType = "mouse";
        if (is_undefined_default(tempEvent.pointerId)) tempEvent.pointerId = MOUSE_POINTER_ID;
        if (is_undefined_default(tempEvent.pressure)) tempEvent.pressure = 0.5;
        if (is_undefined_default(tempEvent.twist)) tempEvent.twist = 0;
        if (is_undefined_default(tempEvent.tangentialPressure)) tempEvent.tangentialPressure = 0;
        tempEvent.isNormalized = true;
        normalizedEvents.push(tempEvent);
      } else {
        normalizedEvents.push(event);
      }
      return normalizedEvents;
    }
  }]);
}();
EventPlugin.tag = "Event";
var shape2D = [Shape.CIRCLE, Shape.ELLIPSE, Shape.IMAGE, Shape.RECT, Shape.LINE, Shape.POLYLINE, Shape.POLYGON, Shape.TEXT, Shape.PATH, Shape.HTML];
var FrustumCullingStrategy = function() {
  function FrustumCullingStrategy2() {
    _classCallCheck(this, FrustumCullingStrategy2);
  }
  return _createClass(FrustumCullingStrategy2, [{
    key: "isVisible",
    value: function isVisible(camera, object) {
      var _object$parentNode;
      var cullable = object.cullable;
      if (!cullable.enable) {
        return true;
      }
      var renderBounds = object.getRenderBounds();
      if (AABB.isEmpty(renderBounds)) {
        return false;
      }
      var frustum2 = camera.getFrustum();
      var parentVisibilityPlaneMask = (_object$parentNode = object.parentNode) === null || _object$parentNode === void 0 || (_object$parentNode = _object$parentNode.cullable) === null || _object$parentNode === void 0 ? void 0 : _object$parentNode.visibilityPlaneMask;
      cullable.visibilityPlaneMask = this.computeVisibilityWithPlaneMask(object, renderBounds, parentVisibilityPlaneMask || Mask.INDETERMINATE, frustum2.planes);
      cullable.visible = cullable.visibilityPlaneMask !== Mask.OUTSIDE;
      return cullable.visible;
    }
    /**
     *
     * @see「Optimized View Frustum Culling Algorithms for Bounding Boxes」
     * @see https://github.com/antvis/GWebGPUEngine/issues/3
     *
     * * 基础相交测试 the basic intersection test
     * * 标记 masking @see https://cesium.com/blog/2015/08/04/fast-hierarchical-culling/
     * * TODO: 平面一致性测试 the plane-coherency test
     * * TODO: 支持 mesh 指定自身的剔除策略，参考 Babylon.js @see https://doc.babylonjs.com/how_to/optimizing_your_scene#changing-mesh-culling-strategy
     *
     * @param aabb aabb
     * @param parentPlaneMask mask of parent
     * @param planes planes of frustum
     */
  }, {
    key: "computeVisibilityWithPlaneMask",
    value: function computeVisibilityWithPlaneMask(object, aabb, parentPlaneMask, planes) {
      if (parentPlaneMask === Mask.OUTSIDE || parentPlaneMask === Mask.INSIDE) {
        return parentPlaneMask;
      }
      var mask = Mask.INSIDE;
      var isShape2D = shape2D.indexOf(object.nodeName) > -1;
      for (var k = 0, len5 = planes.length; k < len5; ++k) {
        var flag = 1 << k;
        if ((parentPlaneMask & flag) === 0) {
          continue;
        }
        if (isShape2D && (k === 4 || k === 5)) {
          continue;
        }
        var _planes$k = planes[k], normal = _planes$k.normal, distance6 = _planes$k.distance;
        if (vec3_exports.dot(normal, aabb.getPositiveFarPoint(planes[k])) + distance6 < 0) {
          return Mask.OUTSIDE;
        }
        if (vec3_exports.dot(normal, aabb.getNegativeFarPoint(planes[k])) + distance6 < 0) {
          mask |= flag;
        }
      }
      return mask;
    }
  }]);
}();
var PrepareRendererPlugin = function() {
  function PrepareRendererPlugin2() {
    _classCallCheck(this, PrepareRendererPlugin2);
    this.syncTasks = /* @__PURE__ */ new Map();
    this.isFirstTimeRendering = true;
    this.syncing = false;
    this.isFirstTimeRenderingFinished = false;
  }
  return _createClass(PrepareRendererPlugin2, [{
    key: "apply",
    value: function apply(context) {
      var _this2 = this, _runtime$globalThis$r, _config$future;
      var config = context.config, renderingService = context.renderingService, renderingContext = context.renderingContext, rBushRoot = context.rBushRoot;
      var canvas = renderingContext.root.ownerDocument.defaultView;
      this.rBush = rBushRoot;
      var handleAttributeChanged = function handleAttributeChanged2(e) {
        renderingService.dirtify();
      };
      var handleBoundsChanged = function handleBoundsChanged2(e) {
        _this2.syncTasks.set(e.target, e.detail.affectChildren);
        renderingService.dirtify();
      };
      var handleMounted = function handleMounted2(e) {
        var object = e.target;
        if (runtime.enableSizeAttenuation) {
          runtime.styleValueRegistry.updateSizeAttenuation(object, canvas.getCamera().getZoom());
        }
      };
      var handleUnmounted = function handleUnmounted2(e) {
        var object = e.target;
        var rBushNode = object.rBushNode;
        if (rBushNode !== null && rBushNode !== void 0 && rBushNode.aabb) {
          _this2.rBush.remove(rBushNode.aabb);
        }
        _this2.syncTasks["delete"](object);
        runtime.sceneGraphService.dirtyToRoot(object);
        renderingService.dirtify();
      };
      renderingService.hooks.init.tap(PrepareRendererPlugin2.tag, function() {
        canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        canvas.addEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
      });
      renderingService.hooks.destroy.tap(PrepareRendererPlugin2.tag, function() {
        canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        canvas.removeEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
        _this2.syncTasks.clear();
      });
      var ric = (_runtime$globalThis$r = runtime.globalThis.requestIdleCallback) !== null && _runtime$globalThis$r !== void 0 ? _runtime$globalThis$r : raf.bind(runtime.globalThis);
      var enableRICSyncRTree = ((_config$future = config.future) === null || _config$future === void 0 ? void 0 : _config$future.experimentalRICSyncRTree) === true;
      renderingService.hooks.endFrame.tap(PrepareRendererPlugin2.tag, function() {
        if (_this2.isFirstTimeRendering) {
          _this2.isFirstTimeRendering = false;
          _this2.syncing = true;
          ric(function() {
            _this2.syncRTree(true);
            _this2.isFirstTimeRenderingFinished = true;
          });
        } else if (enableRICSyncRTree && runtime.globalThis.requestIdleCallback && runtime.globalThis.cancelIdleCallback) {
          runtime.globalThis.cancelIdleCallback(_this2.ricSyncRTreeId);
          _this2.ricSyncRTreeId = runtime.globalThis.requestIdleCallback(function() {
            return _this2.syncRTree();
          });
        } else {
          _this2.syncRTree();
        }
      });
    }
  }, {
    key: "syncNode",
    value: function syncNode(node) {
      var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!node.isConnected) return;
      var rBushNode = node.rBushNode;
      if (rBushNode.aabb) this.rBush.remove(rBushNode.aabb);
      var renderBounds = node.getRenderBounds();
      if (renderBounds) {
        var renderable = node.renderable;
        if (force) {
          if (!renderable.dirtyRenderBounds) {
            renderable.dirtyRenderBounds = new AABB();
          }
          renderable.dirtyRenderBounds.update(renderBounds.center, renderBounds.halfExtents);
        }
        var _renderBounds$getMin = renderBounds.getMin(), _renderBounds$getMin2 = _slicedToArray(_renderBounds$getMin, 2), minX = _renderBounds$getMin2[0], minY = _renderBounds$getMin2[1];
        var _renderBounds$getMax = renderBounds.getMax(), _renderBounds$getMax2 = _slicedToArray(_renderBounds$getMax, 2), maxX = _renderBounds$getMax2[0], maxY = _renderBounds$getMax2[1];
        if (!rBushNode.aabb) {
          rBushNode.aabb = {};
        }
        rBushNode.aabb.displayObject = node;
        rBushNode.aabb.minX = minX;
        rBushNode.aabb.minY = minY;
        rBushNode.aabb.maxX = maxX;
        rBushNode.aabb.maxY = maxY;
      }
      if (rBushNode.aabb) {
        if (!isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.minX) && !isNaN(rBushNode.aabb.minY)) {
          return rBushNode.aabb;
        }
      }
    }
  }, {
    key: "syncRTree",
    value: function syncRTree() {
      var _this2 = this;
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (!force && (this.syncing || this.syncTasks.size === 0)) {
        return;
      }
      this.syncing = true;
      var bulk = [];
      var synced = /* @__PURE__ */ new Set();
      var sync = function sync2(node) {
        if (!synced.has(node) && node.renderable) {
          var aabb = _this2.syncNode(node, force);
          if (aabb) {
            bulk.push(aabb);
            synced.add(node);
          }
        }
      };
      this.syncTasks.forEach(function(affectChildren, node) {
        if (affectChildren) {
          node.forEach(sync);
        }
        var parent = node;
        while (parent) {
          sync(parent);
          parent = parent.parentElement;
        }
      });
      this.rBush.load(bulk);
      bulk.length = 0;
      this.syncing = false;
    }
  }]);
}();
PrepareRendererPlugin.tag = "Prepare";
var CanvasEvent = function(CanvasEvent2) {
  CanvasEvent2["READY"] = "ready";
  CanvasEvent2["BEFORE_RENDER"] = "beforerender";
  CanvasEvent2["RERENDER"] = "rerender";
  CanvasEvent2["AFTER_RENDER"] = "afterrender";
  CanvasEvent2["BEFORE_DESTROY"] = "beforedestroy";
  CanvasEvent2["AFTER_DESTROY"] = "afterdestroy";
  CanvasEvent2["RESIZE"] = "resize";
  CanvasEvent2["DIRTY_RECTANGLE"] = "dirtyrectangle";
  CanvasEvent2["RENDERER_CHANGED"] = "rendererchanged";
  return CanvasEvent2;
}({});
var DEFAULT_CAMERA_Z = 500;
var DEFAULT_CAMERA_NEAR = 0.1;
var DEFAULT_CAMERA_FAR = 1e3;
var mountedEvent = new CustomEvent(ElementEvent.MOUNTED);
var unmountedEvent = new CustomEvent(ElementEvent.UNMOUNTED);
var beforeRenderEvent = new CustomEvent(CanvasEvent.BEFORE_RENDER);
var rerenderEvent = new CustomEvent(CanvasEvent.RERENDER);
var afterRenderEvent = new CustomEvent(CanvasEvent.AFTER_RENDER);
var Canvas = function(_EventTarget) {
  function Canvas2(config) {
    var _this2;
    _classCallCheck(this, Canvas2);
    _this2 = _callSuper(this, Canvas2);
    _this2.Element = DisplayObject;
    _this2.inited = false;
    _this2.context = {};
    var container = config.container, canvas = config.canvas, renderer = config.renderer, width = config.width, height = config.height, background = config.background, cursor = config.cursor, supportsMutipleCanvasesInOneContainer = config.supportsMutipleCanvasesInOneContainer, _config$cleanUpOnDest = config.cleanUpOnDestroy, cleanUpOnDestroy = _config$cleanUpOnDest === void 0 ? true : _config$cleanUpOnDest, offscreenCanvas = config.offscreenCanvas, devicePixelRatio = config.devicePixelRatio, requestAnimationFrame2 = config.requestAnimationFrame, cancelAnimationFrame2 = config.cancelAnimationFrame, createImage = config.createImage, supportsTouchEvents = config.supportsTouchEvents, supportsPointerEvents = config.supportsPointerEvents, isTouchEvent = config.isTouchEvent, isMouseEvent = config.isMouseEvent, dblClickSpeed = config.dblClickSpeed;
    var canvasWidth = width;
    var canvasHeight = height;
    var dpr = devicePixelRatio || isBrowser && window.devicePixelRatio || 1;
    dpr = dpr >= 1 ? Math.ceil(dpr) : 1;
    if (canvas) {
      canvasWidth = width || getWidth(canvas) || canvas.width / dpr;
      canvasHeight = height || getHeight(canvas) || canvas.height / dpr;
    }
    _this2.customElements = new CustomElementRegistry();
    _this2.devicePixelRatio = dpr;
    _this2.requestAnimationFrame = requestAnimationFrame2 !== null && requestAnimationFrame2 !== void 0 ? requestAnimationFrame2 : raf.bind(runtime.globalThis);
    _this2.cancelAnimationFrame = cancelAnimationFrame2 !== null && cancelAnimationFrame2 !== void 0 ? cancelAnimationFrame2 : caf.bind(runtime.globalThis);
    _this2.createImage = createImage !== null && createImage !== void 0 ? createImage : function() {
      return new window.Image();
    };
    _this2.supportsTouchEvents = supportsTouchEvents !== null && supportsTouchEvents !== void 0 ? supportsTouchEvents : "ontouchstart" in runtime.globalThis;
    _this2.supportsPointerEvents = supportsPointerEvents !== null && supportsPointerEvents !== void 0 ? supportsPointerEvents : !!runtime.globalThis.PointerEvent;
    _this2.isTouchEvent = isTouchEvent !== null && isTouchEvent !== void 0 ? isTouchEvent : function(event) {
      return _this2.supportsTouchEvents && event instanceof runtime.globalThis.TouchEvent;
    };
    _this2.isMouseEvent = isMouseEvent !== null && isMouseEvent !== void 0 ? isMouseEvent : function(event) {
      return !runtime.globalThis.MouseEvent || event instanceof runtime.globalThis.MouseEvent && (!_this2.supportsPointerEvents || !(event instanceof runtime.globalThis.PointerEvent));
    };
    if (offscreenCanvas) {
      runtime.offscreenCanvas = offscreenCanvas;
    }
    _this2.document = new Document2();
    _this2.document.defaultView = _this2;
    if (!supportsMutipleCanvasesInOneContainer) {
      cleanExistedCanvas(container, _this2, cleanUpOnDestroy);
    }
    _this2.initRenderingContext(_objectSpread2(_objectSpread2({}, config), {}, {
      width: canvasWidth,
      height: canvasHeight,
      background: background !== null && background !== void 0 ? background : "transparent",
      cursor: cursor !== null && cursor !== void 0 ? cursor : "default",
      cleanUpOnDestroy,
      devicePixelRatio: dpr,
      requestAnimationFrame: _this2.requestAnimationFrame,
      cancelAnimationFrame: _this2.cancelAnimationFrame,
      createImage: _this2.createImage,
      supportsTouchEvents: _this2.supportsTouchEvents,
      supportsPointerEvents: _this2.supportsPointerEvents,
      isTouchEvent: _this2.isTouchEvent,
      isMouseEvent: _this2.isMouseEvent,
      dblClickSpeed: dblClickSpeed !== null && dblClickSpeed !== void 0 ? dblClickSpeed : 200
    }));
    _this2.initDefaultCamera(canvasWidth, canvasHeight, renderer.clipSpaceNearZ);
    _this2.initRenderer(renderer, true);
    return _this2;
  }
  _inherits(Canvas2, _EventTarget);
  return _createClass(Canvas2, [{
    key: "initRenderingContext",
    value: function initRenderingContext(mergedConfig) {
      this.context.config = mergedConfig;
      this.context.renderingContext = {
        /**
         * the root node in scene graph
         */
        root: this.document.documentElement,
        unculledEntities: [],
        renderListCurrentFrame: [],
        renderReasons: /* @__PURE__ */ new Set(),
        force: false,
        dirty: false
      };
    }
  }, {
    key: "initDefaultCamera",
    value: function initDefaultCamera(width, height, clipSpaceNearZ) {
      var _this2 = this;
      var camera = new runtime.CameraContribution();
      camera.clipSpaceNearZ = clipSpaceNearZ;
      camera.setType(CameraType.EXPLORING, CameraTrackingMode.DEFAULT).setPosition(width / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width / 2, height / 2, 0).setOrthographic(width / -2, width / 2, height / 2, height / -2, DEFAULT_CAMERA_NEAR, DEFAULT_CAMERA_FAR);
      camera.canvas = this;
      camera.eventEmitter.on(CameraEvent.UPDATED, function() {
        _this2.context.renderingContext.renderReasons.add(RenderReason.CAMERA_CHANGED);
        if (runtime.enableSizeAttenuation && _this2.getConfig().renderer.getConfig().enableSizeAttenuation) {
          _this2.updateSizeAttenuation();
        }
      });
      this.context.camera = camera;
    }
  }, {
    key: "updateSizeAttenuation",
    value: function updateSizeAttenuation() {
      var zoom = this.getCamera().getZoom();
      this.document.documentElement.forEach(function(node) {
        runtime.styleValueRegistry.updateSizeAttenuation(node, zoom);
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      return this.context.config;
    }
    /**
     * get the root displayObject in scenegraph
     * @alias this.document.documentElement
     */
  }, {
    key: "getRoot",
    value: function getRoot() {
      return this.document.documentElement;
    }
    /**
     * get the camera of canvas
     */
  }, {
    key: "getCamera",
    value: function getCamera() {
      return this.context.camera;
    }
  }, {
    key: "getContextService",
    value: function getContextService() {
      return this.context.contextService;
    }
  }, {
    key: "getEventService",
    value: function getEventService() {
      return this.context.eventService;
    }
  }, {
    key: "getRenderingService",
    value: function getRenderingService() {
      return this.context.renderingService;
    }
  }, {
    key: "getRenderingContext",
    value: function getRenderingContext() {
      return this.context.renderingContext;
    }
  }, {
    key: "getStats",
    value: function getStats() {
      return this.getRenderingService().getStats();
    }
    // /**
    //  * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle
    //  */
    // getComputedStyle(node: DisplayObject) {
    //   return node.computedStyle;
    // }
  }, {
    key: "ready",
    get: function get() {
      var _this3 = this;
      if (!this.readyPromise) {
        this.readyPromise = new Promise(function(resolve) {
          _this3.resolveReadyPromise = function() {
            resolve(_this3);
          };
        });
        if (this.inited) {
          this.resolveReadyPromise();
        }
      }
      return this.readyPromise;
    }
    /**
     * @param cleanUp - whether to clean up all the internal services of Canvas
     * @param skipTriggerEvent - whether to skip trigger destroy event
     */
  }, {
    key: "destroy",
    value: function destroy() {
      var _this$getConfig$futur;
      var cleanUp = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      var skipTriggerEvent = arguments.length > 1 ? arguments[1] : void 0;
      memoize2.clearCache();
      var enableCancelEventPropagation = ((_this$getConfig$futur = this.getConfig().future) === null || _this$getConfig$futur === void 0 ? void 0 : _this$getConfig$futur.experimentalCancelEventPropagation) === true;
      if (!skipTriggerEvent) {
        this.dispatchEvent(new CustomEvent(CanvasEvent.BEFORE_DESTROY), enableCancelEventPropagation, enableCancelEventPropagation);
      }
      if (this.frameId) {
        this.cancelAnimationFrame(this.frameId);
      }
      var root2 = this.getRoot();
      if (cleanUp) {
        this.unmountChildren(root2);
        this.document.destroy();
        this.getEventService().destroy();
      }
      this.getRenderingService().destroy();
      this.getContextService().destroy();
      if (this.context.rBushRoot) {
        this.context.rBushRoot.clear();
      }
      if (!skipTriggerEvent) {
        this.dispatchEvent(new CustomEvent(CanvasEvent.AFTER_DESTROY), enableCancelEventPropagation, enableCancelEventPropagation);
      }
      var clearEventRetain = function clearEventRetain2(event) {
        event.currentTarget = null;
        event.manager = null;
        event.target = null;
        event.relatedNode = null;
      };
      clearEventRetain(mountedEvent);
      clearEventRetain(unmountedEvent);
      clearEventRetain(beforeRenderEvent);
      clearEventRetain(rerenderEvent);
      clearEventRetain(afterRenderEvent);
      clearEventRetain(attrModifiedEvent);
      clearEventRetain(insertedEvent);
      clearEventRetain(removedEvent);
      clearEventRetain(destroyEvent);
      runtime.textService.clearCache();
    }
    /**
     * compatible with G 3.0
     * @deprecated
     * @alias resize
     */
  }, {
    key: "changeSize",
    value: function changeSize(width, height) {
      this.resize(width, height);
    }
  }, {
    key: "resize",
    value: function resize(width, height) {
      var _canvasConfig$future;
      var canvasConfig = this.context.config;
      canvasConfig.width = width;
      canvasConfig.height = height;
      this.getContextService().resize(width, height);
      var camera = this.context.camera;
      var projectionMode = camera.getProjectionMode();
      camera.setPosition(width / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width / 2, height / 2, 0);
      if (projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
        camera.setOrthographic(width / -2, width / 2, height / 2, height / -2, camera.getNear(), camera.getFar());
      } else {
        camera.setAspect(width / height);
      }
      var enableCancelEventPropagation = ((_canvasConfig$future = canvasConfig.future) === null || _canvasConfig$future === void 0 ? void 0 : _canvasConfig$future.experimentalCancelEventPropagation) === true;
      this.dispatchEvent(new CustomEvent(CanvasEvent.RESIZE, {
        width,
        height
      }), enableCancelEventPropagation, enableCancelEventPropagation);
    }
    // proxy to document.documentElement
  }, {
    key: "appendChild",
    value: function appendChild(child, index2) {
      return this.document.documentElement.appendChild(child, index2);
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(newChild, refChild) {
      return this.document.documentElement.insertBefore(newChild, refChild);
    }
  }, {
    key: "removeChild",
    value: function removeChild(child) {
      return this.document.documentElement.removeChild(child);
    }
    /**
     * Remove all children which can be appended to its original parent later again.
     */
  }, {
    key: "removeChildren",
    value: function removeChildren() {
      this.document.documentElement.removeChildren();
    }
    /**
     * Recursively destroy all children which can not be appended to its original parent later again.
     * But the canvas remains running which means display objects can be appended later.
     */
  }, {
    key: "destroyChildren",
    value: function destroyChildren() {
      this.document.documentElement.destroyChildren();
    }
  }, {
    key: "render",
    value: function render(frame) {
      var _this$getConfig$futur2, _this4 = this;
      if (frame) {
        beforeRenderEvent.detail = frame;
        afterRenderEvent.detail = frame;
      }
      var enableCancelEventPropagation = ((_this$getConfig$futur2 = this.getConfig().future) === null || _this$getConfig$futur2 === void 0 ? void 0 : _this$getConfig$futur2.experimentalCancelEventPropagation) === true;
      this.dispatchEvent(beforeRenderEvent, enableCancelEventPropagation, enableCancelEventPropagation);
      var renderingService = this.getRenderingService();
      renderingService.render(this.getConfig(), frame, function() {
        _this4.dispatchEvent(rerenderEvent, enableCancelEventPropagation, enableCancelEventPropagation);
      });
      this.dispatchEvent(afterRenderEvent, enableCancelEventPropagation, enableCancelEventPropagation);
    }
  }, {
    key: "run",
    value: function run() {
      var _this5 = this;
      var _tick = function tick2(time, frame) {
        _this5.render(frame);
        _this5.frameId = _this5.requestAnimationFrame(_tick);
      };
      _tick();
    }
  }, {
    key: "initRenderer",
    value: function initRenderer(renderer) {
      var _this6 = this;
      var firstContentfullPaint = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!renderer) {
        throw new Error("Renderer is required.");
      }
      this.inited = false;
      this.readyPromise = void 0;
      this.context.rBushRoot = new RBush();
      this.context.renderingPlugins = [];
      this.context.renderingPlugins.push(
        new EventPlugin(),
        new PrepareRendererPlugin(),
        // new DirtyCheckPlugin(),
        new CullingPlugin([new FrustumCullingStrategy()])
      );
      this.loadRendererContainerModule(renderer);
      this.context.contextService = new this.context.ContextService(_objectSpread2(_objectSpread2({}, runtime), this.context));
      this.context.renderingService = new RenderingService(runtime, this.context);
      this.context.eventService = new EventService(runtime, this.context);
      this.context.eventService.init();
      if (this.context.contextService.init) {
        this.context.contextService.init();
        this.initRenderingService(renderer, firstContentfullPaint, true);
      } else {
        this.context.contextService.initAsync().then(function() {
          _this6.initRenderingService(renderer, firstContentfullPaint);
        })["catch"](function(err) {
          console.error(err);
        });
      }
    }
  }, {
    key: "initRenderingService",
    value: function initRenderingService(renderer) {
      var _this7 = this;
      var firstContentfullPaint = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var async = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      this.context.renderingService.init(function() {
        var _this7$getConfig$futu;
        _this7.inited = true;
        var enableCancelEventPropagation = ((_this7$getConfig$futu = _this7.getConfig().future) === null || _this7$getConfig$futu === void 0 ? void 0 : _this7$getConfig$futu.experimentalCancelEventPropagation) === true;
        if (firstContentfullPaint) {
          if (async) {
            _this7.requestAnimationFrame(function() {
              _this7.dispatchEvent(new CustomEvent(CanvasEvent.READY), enableCancelEventPropagation, enableCancelEventPropagation);
            });
          } else {
            _this7.dispatchEvent(new CustomEvent(CanvasEvent.READY), enableCancelEventPropagation, enableCancelEventPropagation);
          }
        } else {
          _this7.dispatchEvent(new CustomEvent(CanvasEvent.RENDERER_CHANGED), enableCancelEventPropagation, enableCancelEventPropagation);
        }
        if (_this7.readyPromise) {
          _this7.resolveReadyPromise();
        }
        if (!firstContentfullPaint) {
          _this7.getRoot().forEach(function(node) {
            var _dirty, _ref;
            (_dirty = (_ref = node).dirty) === null || _dirty === void 0 || _dirty.call(_ref, true, true);
          });
        }
        _this7.mountChildren(_this7.getRoot());
        if (renderer.getConfig().enableAutoRendering) {
          _this7.run();
        }
      });
    }
  }, {
    key: "loadRendererContainerModule",
    value: function loadRendererContainerModule(renderer) {
      var _this8 = this;
      var plugins = renderer.getPlugins();
      plugins.forEach(function(plugin) {
        plugin.context = _this8.context;
        plugin.init(runtime);
      });
    }
  }, {
    key: "setRenderer",
    value: function setRenderer(renderer) {
      var canvasConfig = this.getConfig();
      if (canvasConfig.renderer === renderer) {
        return;
      }
      var oldRenderer = canvasConfig.renderer;
      canvasConfig.renderer = renderer;
      this.destroy(false, true);
      _toConsumableArray((oldRenderer === null || oldRenderer === void 0 ? void 0 : oldRenderer.getPlugins()) || []).reverse().forEach(function(plugin) {
        plugin.destroy(runtime);
      });
      this.initRenderer(renderer);
    }
  }, {
    key: "setCursor",
    value: function setCursor(cursor) {
      var canvasConfig = this.getConfig();
      canvasConfig.cursor = cursor;
      this.getContextService().applyCursorStyle(cursor);
    }
  }, {
    key: "unmountChildren",
    value: function unmountChildren(parent) {
      var _this9 = this;
      parent.childNodes.forEach(function(child) {
        _this9.unmountChildren(child);
      });
      if (this.inited) {
        if (parent.isMutationObserved) {
          parent.dispatchEvent(unmountedEvent);
        } else {
          var _this$getConfig$futur3;
          var enableCancelEventPropagation = ((_this$getConfig$futur3 = this.getConfig().future) === null || _this$getConfig$futur3 === void 0 ? void 0 : _this$getConfig$futur3.experimentalCancelEventPropagation) === true;
          unmountedEvent.target = parent;
          this.dispatchEvent(unmountedEvent, true, enableCancelEventPropagation);
        }
        if (parent !== this.document.documentElement) {
          parent.ownerDocument = null;
        }
        parent.isConnected = false;
      }
      if (parent.isCustomElement) {
        if (parent.disconnectedCallback) {
          parent.disconnectedCallback();
        }
      }
    }
  }, {
    key: "mountChildren",
    value: function mountChildren(child) {
      var _this0 = this;
      var skipTriggerEvent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : isInFragment(child);
      if (this.inited) {
        if (!child.isConnected) {
          child.ownerDocument = this.document;
          child.isConnected = true;
          if (!skipTriggerEvent) {
            if (child.isMutationObserved) {
              child.dispatchEvent(mountedEvent);
            } else {
              var _this$getConfig$futur4;
              var enableCancelEventPropagation = ((_this$getConfig$futur4 = this.getConfig().future) === null || _this$getConfig$futur4 === void 0 ? void 0 : _this$getConfig$futur4.experimentalCancelEventPropagation) === true;
              mountedEvent.target = child;
              this.dispatchEvent(mountedEvent, true, enableCancelEventPropagation);
            }
          }
        }
      } else {
        console.warn("[g]: You are trying to call `canvas.appendChild` before canvas' initialization finished. You can either await `canvas.ready` or listen to `CanvasEvent.READY` manually.", "appended child: ", child.nodeName);
      }
      child.childNodes.forEach(function(c2) {
        _this0.mountChildren(c2, skipTriggerEvent);
      });
      if (child.isCustomElement) {
        if (child.connectedCallback) {
          child.connectedCallback();
        }
      }
    }
  }, {
    key: "mountFragment",
    value: function mountFragment(child) {
      this.mountChildren(child, false);
    }
  }, {
    key: "client2Viewport",
    value: function client2Viewport(client) {
      return this.getEventService().client2Viewport(client);
    }
  }, {
    key: "viewport2Client",
    value: function viewport2Client(canvas) {
      return this.getEventService().viewport2Client(canvas);
    }
  }, {
    key: "viewport2Canvas",
    value: function viewport2Canvas(viewport) {
      return this.getEventService().viewport2Canvas(viewport);
    }
  }, {
    key: "canvas2Viewport",
    value: function canvas2Viewport(canvas) {
      return this.getEventService().canvas2Viewport(canvas);
    }
    /**
     * @deprecated
     * @alias client2Viewport
     */
  }, {
    key: "getPointByClient",
    value: function getPointByClient(clientX, clientY) {
      return this.client2Viewport({
        x: clientX,
        y: clientY
      });
    }
    /**
     * @deprecated
     * @alias viewport2Client
     */
  }, {
    key: "getClientByPoint",
    value: function getClientByPoint(x3, y3) {
      return this.viewport2Client({
        x: x3,
        y: y3
      });
    }
  }]);
}(EventTarget);

// node_modules/@antv/g-camera-api/dist/index.esm.js
var AdvancedCamera = function(_Camera) {
  function AdvancedCamera2() {
    var _this2;
    _classCallCheck(this, AdvancedCamera2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, AdvancedCamera2, [].concat(args));
    _this2.landmarks = [];
    return _this2;
  }
  _inherits(AdvancedCamera2, _Camera);
  return _createClass(AdvancedCamera2, [{
    key: "rotate",
    value: (
      /**
       * Changes the azimuth and elevation with respect to the current camera axes
       * @param {Number} azimuth the relative azimuth
       * @param {Number} elevation the relative elevation
       * @param {Number} roll the relative roll
       */
      function rotate6(azimuth, elevation, roll) {
        this.relElevation = getAngle2(elevation);
        this.relAzimuth = getAngle2(azimuth);
        this.relRoll = getAngle2(roll);
        this.elevation += this.relElevation;
        this.azimuth += this.relAzimuth;
        this.roll += this.relRoll;
        if (this.type === CameraType.EXPLORING) {
          var rotX = quat_exports.setAxisAngle(quat_exports.create(), [1, 0, 0], deg2rad((this.rotateWorld ? 1 : -1) * this.relElevation));
          var rotY = quat_exports.setAxisAngle(quat_exports.create(), [0, 1, 0], deg2rad((this.rotateWorld ? 1 : -1) * this.relAzimuth));
          var rotZ = quat_exports.setAxisAngle(quat_exports.create(), [0, 0, 1], deg2rad(this.relRoll));
          var rotQ = quat_exports.multiply(quat_exports.create(), rotY, rotX);
          rotQ = quat_exports.multiply(quat_exports.create(), rotQ, rotZ);
          var rotMatrix = mat4_exports.fromQuat(mat4_exports.create(), rotQ);
          mat4_exports.translate(this.matrix, this.matrix, [0, 0, -this.distance]);
          mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
          mat4_exports.translate(this.matrix, this.matrix, [0, 0, this.distance]);
        } else {
          if (Math.abs(this.elevation) > 90) {
            return this;
          }
          this.computeMatrix();
        }
        this._getAxes();
        if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
          this._getPosition();
        } else if (this.type === CameraType.TRACKING) {
          this._getFocalPoint();
        }
        this._update();
        return this;
      }
    )
    /**
     * 沿水平(right) & 垂直(up)平移相机
     */
  }, {
    key: "pan",
    value: function pan(tx, ty) {
      var coords = createVec3(tx, ty, 0);
      var pos = vec3_exports.clone(this.position);
      vec3_exports.add(pos, pos, vec3_exports.scale(vec3_exports.create(), this.right, coords[0]));
      vec3_exports.add(pos, pos, vec3_exports.scale(vec3_exports.create(), this.up, coords[1]));
      this._setPosition(pos);
      this.triggerUpdate();
      return this;
    }
    /**
     * 沿 n 轴移动，当距离视点远时移动速度较快，离视点越近速度越慢
     */
  }, {
    key: "dolly",
    value: function dolly(value) {
      var n = this.forward;
      var pos = vec3_exports.clone(this.position);
      var step2 = value * this.dollyingStep;
      var updatedDistance = this.distance + value * this.dollyingStep;
      step2 = Math.max(Math.min(updatedDistance, this.maxDistance), this.minDistance) - this.distance;
      pos[0] += step2 * n[0];
      pos[1] += step2 * n[1];
      pos[2] += step2 * n[2];
      this._setPosition(pos);
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        this._getDistance();
      } else if (this.type === CameraType.TRACKING) {
        vec3_exports.add(this.focalPoint, pos, this.distanceVector);
      }
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "cancelLandmarkAnimation",
    value: function cancelLandmarkAnimation() {
      if (this.landmarkAnimationID !== void 0) {
        this.canvas.cancelAnimationFrame(this.landmarkAnimationID);
      }
    }
  }, {
    key: "createLandmark",
    value: function createLandmark(name) {
      var _position$, _position$2, _focalPoint$, _focalPoint$2;
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _params$position = params.position, position = _params$position === void 0 ? this.position : _params$position, _params$focalPoint = params.focalPoint, focalPoint = _params$focalPoint === void 0 ? this.focalPoint : _params$focalPoint, roll = params.roll, zoom = params.zoom;
      var camera = new runtime.CameraContribution();
      camera.setType(this.type, void 0);
      camera.setPosition(position[0], (_position$ = position[1]) !== null && _position$ !== void 0 ? _position$ : this.position[1], (_position$2 = position[2]) !== null && _position$2 !== void 0 ? _position$2 : this.position[2]);
      camera.setFocalPoint(focalPoint[0], (_focalPoint$ = focalPoint[1]) !== null && _focalPoint$ !== void 0 ? _focalPoint$ : this.focalPoint[1], (_focalPoint$2 = focalPoint[2]) !== null && _focalPoint$2 !== void 0 ? _focalPoint$2 : this.focalPoint[2]);
      camera.setRoll(roll !== null && roll !== void 0 ? roll : this.roll);
      camera.setZoom(zoom !== null && zoom !== void 0 ? zoom : this.zoom);
      var landmark = {
        name,
        matrix: mat4_exports.clone(camera.getWorldTransform()),
        right: vec3_exports.clone(camera.right),
        up: vec3_exports.clone(camera.up),
        forward: vec3_exports.clone(camera.forward),
        position: vec3_exports.clone(camera.getPosition()),
        focalPoint: vec3_exports.clone(camera.getFocalPoint()),
        distanceVector: vec3_exports.clone(camera.getDistanceVector()),
        distance: camera.getDistance(),
        dollyingStep: camera.getDollyingStep(),
        azimuth: camera.getAzimuth(),
        elevation: camera.getElevation(),
        roll: camera.getRoll(),
        relAzimuth: camera.relAzimuth,
        relElevation: camera.relElevation,
        relRoll: camera.relRoll,
        zoom: camera.getZoom()
      };
      this.landmarks.push(landmark);
      return landmark;
    }
  }, {
    key: "gotoLandmark",
    value: function gotoLandmark(name) {
      var _this2 = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var landmark = isString(name) ? this.landmarks.find(function(l) {
        return l.name === name;
      }) : name;
      if (landmark) {
        var _ref = isNumber(options) ? {
          duration: options
        } : options, _ref$easing = _ref.easing, easing = _ref$easing === void 0 ? "linear" : _ref$easing, _ref$duration = _ref.duration, duration = _ref$duration === void 0 ? 100 : _ref$duration, _ref$easingFunction = _ref.easingFunction, easingFunction = _ref$easingFunction === void 0 ? void 0 : _ref$easingFunction, _ref$onfinish = _ref.onfinish, onfinish = _ref$onfinish === void 0 ? void 0 : _ref$onfinish, _ref$onframe = _ref.onframe, onframe = _ref$onframe === void 0 ? void 0 : _ref$onframe;
        var epsilon = 0.01;
        this.cancelLandmarkAnimation();
        var destPosition = landmark.position;
        var destFocalPoint = landmark.focalPoint;
        var destZoom = landmark.zoom;
        var destRoll = landmark.roll;
        var easingFunc = easingFunction || runtime.EasingFunction(easing);
        var timeStart;
        var end = function end2() {
          _this2.setFocalPoint(destFocalPoint);
          _this2.setPosition(destPosition);
          _this2.setRoll(destRoll);
          _this2.setZoom(destZoom);
          _this2.computeMatrix();
          _this2.triggerUpdate();
          onfinish === null || onfinish === void 0 || onfinish();
        };
        if (duration === 0) return end();
        var _animate = function animate2(timestamp) {
          if (timeStart === void 0) {
            timeStart = timestamp;
          }
          var elapsed = timestamp - timeStart;
          if (elapsed >= duration) {
            end();
            return;
          }
          var t = easingFunc(elapsed / duration);
          var interFocalPoint = vec3_exports.create();
          var interPosition = vec3_exports.create();
          var interZoom = 1;
          var interRoll = 0;
          vec3_exports.lerp(interFocalPoint, _this2.focalPoint, destFocalPoint, t);
          vec3_exports.lerp(interPosition, _this2.position, destPosition, t);
          interRoll = _this2.roll * (1 - t) + destRoll * t;
          interZoom = _this2.zoom * (1 - t) + destZoom * t;
          _this2.setFocalPoint(interFocalPoint);
          _this2.setPosition(interPosition);
          _this2.setRoll(interRoll);
          _this2.setZoom(interZoom);
          var dist4 = vec3_exports.dist(interFocalPoint, destFocalPoint) + vec3_exports.dist(interPosition, destPosition);
          if (dist4 <= epsilon && destZoom === void 0 && destRoll === void 0) {
            return end();
          }
          _this2.computeMatrix();
          _this2.triggerUpdate();
          if (elapsed < duration) {
            onframe === null || onframe === void 0 || onframe(t);
            _this2.landmarkAnimationID = _this2.canvas.requestAnimationFrame(_animate);
          }
        };
        this.canvas.requestAnimationFrame(_animate);
      }
    }
    /**
     * Sets the camera to a distance such that the area covered by the bounding box is viewed.
     */
    // shot(displayObject: DisplayObject) {
    //   const aabb = displayObject.getBounds();
    //   if (!AABB.isEmpty(aabb)) {
    //     this.setElevation(0);
    //     this.setAzimuth(0);
    //     this.setRoll(0);
    //     const { halfExtents, center } = aabb;
    //     const maxDim = Math.max(halfExtents[0] * 2, halfExtents[1] * 2);
    //     const cc = center.map((c: number) => Math.round(c * 1000) / 1000) as [number, number, number];
    //     if (maxDim !== 0) {
    //       const d = (1.5 * maxDim) / Math.tan(this.fov * DEG_2_RAD);
    //       this.setPosition([cc[0], cc[1], cc[2] + d]);
    //     }
    //     this.setFocalPoint(cc);
    //   }
    // }
  }]);
}(Camera);
runtime.CameraContribution = AdvancedCamera;

// node_modules/@antv/g-dom-mutation-observer-api/dist/index.esm.js
var MutationRecord = function() {
  function MutationRecord2(type, target) {
    _classCallCheck(this, MutationRecord2);
    this.addedNodes = [];
    this.attributeName = null;
    this.attributeNamespace = null;
    this.nextSibling = null;
    this.oldValue = null;
    this.previousSibling = null;
    this.removedNodes = [];
    this.type = type;
    this.target = target;
  }
  return _createClass(MutationRecord2, null, [{
    key: "copy",
    value: function copy7(original) {
      var record = new MutationRecord2(original.type, original.target);
      record.addedNodes = original.addedNodes.slice();
      record.removedNodes = original.removedNodes.slice();
      record.previousSibling = original.previousSibling;
      record.nextSibling = original.nextSibling;
      record.attributeName = original.attributeName;
      record.attributeNamespace = original.attributeNamespace;
      record.oldValue = original.oldValue;
      return record;
    }
  }]);
}();
var uidCounter = 0;
var registrationsTable = /* @__PURE__ */ new WeakMap();
var Registration = function() {
  function Registration2(observer, target, options) {
    _classCallCheck(this, Registration2);
    this.transientObservedNodes = [];
    this.observer = observer;
    this.target = target;
    this.options = options;
  }
  return _createClass(Registration2, [{
    key: "enqueue",
    value: function enqueue(record) {
      var records = this.observer.records;
      var length5 = records.length;
      if (records.length > 0) {
        var lastRecord = records[length5 - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length5 - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }
      records[length5] = record;
    }
  }, {
    key: "addListeners",
    value: function addListeners() {
      this.addListeners_(this.target);
    }
  }, {
    key: "addListeners_",
    value: function addListeners_(node) {
      var options = this.options;
      if (options.attributes) node.addEventListener(ElementEvent.ATTR_MODIFIED, this, true);
      if (options.childList) node.addEventListener(ElementEvent.INSERTED, this, true);
      if (options.childList || options.subtree) node.addEventListener(ElementEvent.REMOVED, this, true);
    }
  }, {
    key: "removeListeners",
    value: function removeListeners() {
      this.removeListeners_(this.target);
    }
  }, {
    key: "removeListeners_",
    value: function removeListeners_(node) {
      var options = this.options;
      if (options.attributes) node.removeEventListener(ElementEvent.ATTR_MODIFIED, this, true);
      if (options.childList) node.removeEventListener(ElementEvent.INSERTED, this, true);
      if (options.childList || options.subtree) node.removeEventListener(ElementEvent.REMOVED, this, true);
    }
    /**
     * Adds a transient observer on node. The transient observer gets removed
     * next time we deliver the change records.
     */
    // addTransientObserver(node: IElement) {
    //   // Don't add transient observers on the target itself. We already have all
    //   // the required listeners set up on the target.
    //   if (node === this.target) return;
    //   this.addListeners_(node);
    //   this.transientObservedNodes.push(node);
    //   let registrations = registrationsTable.get(node);
    //   if (!registrations) registrationsTable.set(node, (registrations = []));
    //   // We know that registrations does not contain this because we already
    //   // checked if node === this.target.
    //   registrations.push(this);
    // }
  }, {
    key: "removeTransientObservers",
    value: function removeTransientObservers() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];
      transientObservedNodes.forEach(function(node) {
        this.removeListeners_(node);
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
    }
  }, {
    key: "handleEvent",
    value: function handleEvent(e) {
      e.stopImmediatePropagation();
      var record;
      var target;
      switch (e.type) {
        case ElementEvent.ATTR_MODIFIED:
          var name = e.attrName;
          var namespace = e.relatedNode.namespaceURI;
          target = e.target;
          record = getRecord("attributes", target);
          record.attributeName = name;
          record.attributeNamespace = namespace;
          var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
          forEachAncestorAndObserverEnqueueRecord(target, function(options) {
            if (!options.attributes) return;
            if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
              return;
            }
            if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
            return record;
          });
          break;
        case ElementEvent.REMOVED:
        case ElementEvent.INSERTED:
          target = e.relatedNode;
          var changedNode = e.target;
          var addedNodes;
          var removedNodes;
          if (e.type === ElementEvent.INSERTED) {
            addedNodes = [changedNode];
            removedNodes = [];
          } else {
            addedNodes = [];
            removedNodes = [changedNode];
          }
          var previousSibling = changedNode.previousSibling;
          var nextSibling = changedNode.nextSibling;
          record = getRecord("childList", target);
          record.addedNodes = addedNodes;
          record.removedNodes = removedNodes;
          record.previousSibling = previousSibling;
          record.nextSibling = nextSibling;
          forEachAncestorAndObserverEnqueueRecord(target, function(options) {
            if (!options.childList) return;
            return record;
          });
      }
      clearRecords();
    }
  }]);
}();
var MutationObserver = function() {
  function MutationObserver2(callback) {
    _classCallCheck(this, MutationObserver2);
    this.nodes = [];
    this.records = [];
    this.uid = uidCounter++;
    this.callback = callback;
  }
  return _createClass(MutationObserver2, [{
    key: "observe",
    value: function observe(target, options) {
      if (!options.childList && !options.attributes && !options.characterData || // 1.2
      options.attributeOldValue && !options.attributes || // 1.3
      options.attributeFilter && options.attributeFilter.length && !options.attributes || // 1.4
      options.characterDataOldValue && !options.characterData) {
        throw new SyntaxError();
      }
      var registrations = registrationsTable.get(target);
      if (!registrations) registrationsTable.set(target, registrations = []);
      var registration;
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes.push(target);
      }
      registration.addListeners();
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      var _this2 = this;
      this.nodes.forEach(function(node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === _this2) {
            registration.removeListeners();
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
      this.records = [];
    }
  }, {
    key: "takeRecords",
    value: function takeRecords() {
      var copyOfRecords = this.records;
      this.records = [];
      return copyOfRecords;
    }
  }]);
}();
var currentRecord;
var recordWithOldValue;
function getRecord(type, target) {
  return currentRecord = new MutationRecord(type, target);
}
function getRecordWithOldValue(oldValue) {
  if (recordWithOldValue) return recordWithOldValue;
  recordWithOldValue = MutationRecord.copy(currentRecord);
  recordWithOldValue.oldValue = oldValue;
  return recordWithOldValue;
}
function clearRecords() {
  currentRecord = recordWithOldValue = void 0;
}
function recordRepresentsCurrentMutation(record) {
  return record === recordWithOldValue || record === currentRecord;
}
function selectRecord(lastRecord, newRecord) {
  if (lastRecord === newRecord) return lastRecord;
  if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
  return null;
}
function removeTransientObserversFor(observer) {
  observer.nodes.forEach(function(node) {
    var registrations = registrationsTable.get(node);
    if (!registrations) return;
    registrations.forEach(function(registration) {
      if (registration.observer === observer) registration.removeTransientObservers();
    });
  });
}
function forEachAncestorAndObserverEnqueueRecord(target, callback) {
  for (var node = target; node; node = node.parentNode) {
    var registrations = registrationsTable.get(node);
    if (registrations) {
      for (var j = 0; j < registrations.length; j++) {
        var registration = registrations[j];
        var _options = registration.options;
        if (node !== target && !_options.subtree) continue;
        var record = callback(_options);
        if (record) registration.enqueue(record);
      }
    }
  }
}
var isScheduled = false;
var scheduledObservers = [];
function scheduleCallback(observer) {
  scheduledObservers.push(observer);
  if (!isScheduled) {
    isScheduled = true;
    if (typeof runtime.globalThis !== "undefined") {
      runtime.globalThis.setTimeout(dispatchCallbacks);
    } else {
      dispatchCallbacks();
    }
  }
}
function dispatchCallbacks() {
  isScheduled = false;
  var observers = scheduledObservers;
  scheduledObservers = [];
  observers.sort(function(o1, o2) {
    return o1.uid - o2.uid;
  });
  var anyNonEmpty = false;
  observers.forEach(function(observer) {
    var queue = observer.takeRecords();
    removeTransientObserversFor(observer);
    if (queue.length) {
      observer.callback(queue, observer);
      anyNonEmpty = true;
    }
  });
  if (anyNonEmpty) dispatchCallbacks();
}

// node_modules/@antv/g-web-animations-api/dist/index.esm.js
var AnimationEvent = function(_FederatedEvent) {
  function AnimationEvent2(manager, target, currentTime, timelineTime) {
    var _this2;
    _classCallCheck(this, AnimationEvent2);
    _this2 = _callSuper(this, AnimationEvent2, [manager]);
    _this2.currentTime = currentTime;
    _this2.timelineTime = timelineTime;
    _this2.target = target;
    _this2.type = "finish";
    _this2.bubbles = false;
    _this2.currentTarget = target;
    _this2.defaultPrevented = false;
    _this2.eventPhase = _this2.AT_TARGET;
    _this2.timeStamp = Date.now();
    _this2.currentTime = currentTime;
    _this2.timelineTime = timelineTime;
    return _this2;
  }
  _inherits(AnimationEvent2, _FederatedEvent);
  return _createClass(AnimationEvent2);
}(FederatedEvent);
var sequenceNumber = 0;
var Animation = function() {
  function Animation2(effect, timeline) {
    var _this$effect;
    _classCallCheck(this, Animation2);
    this.currentTimePending = false;
    this._idle = true;
    this._paused = false;
    this._finishedFlag = true;
    this._currentTime = 0;
    this._playbackRate = 1;
    this._inTimeline = true;
    this.effect = effect;
    effect.animation = this;
    this.timeline = timeline;
    this.id = "".concat(sequenceNumber++);
    this._inEffect = !!this.effect.update(0);
    this._totalDuration = Number((_this$effect = this.effect) === null || _this$effect === void 0 ? void 0 : _this$effect.getComputedTiming().endTime);
    this._holdTime = 0;
    this._paused = false;
    this.oldPlayState = "idle";
    this.updatePromises();
  }
  return _createClass(Animation2, [{
    key: "pending",
    get: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/effect
       */
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/timeline
       */
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/id
       */
      // animation: InternalAnimation | null;
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/pending
       */
      function get() {
        return this._startTime === null && !this._paused && this.playbackRate !== 0 || this.currentTimePending;
      }
    )
  }, {
    key: "playState",
    get: function get() {
      if (this._idle) return "idle";
      if (this._isFinished) return "finished";
      if (this._paused) return "paused";
      return "running";
    }
    /**
     * record previos state
     */
  }, {
    key: "ready",
    get: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/ready
       * @example
        animation.pause();
        animation.ready.then(function() {
          // Displays 'running'
          alert(animation.playState);
        });
        animation.play();
       */
      function get() {
        var _this2 = this;
        if (!this.readyPromise) {
          if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
            this.timeline.animationsWithPromises.push(this);
          }
          this.readyPromise = new Promise(function(resolve, reject) {
            _this2.resolveReadyPromise = function() {
              resolve(_this2);
            };
            _this2.rejectReadyPromise = function() {
              reject(new Error());
            };
          });
          if (!this.pending) {
            this.resolveReadyPromise();
          }
        }
        return this.readyPromise;
      }
    )
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/finished
     * @example
      Promise.all(
        elem.getAnimations().map(
          function(animation) {
            return animation.finished
          }
        )
      ).then(
        function() {
          return elem.remove();
        }
      );
     */
  }, {
    key: "finished",
    get: function get() {
      var _this2 = this;
      if (!this.finishedPromise) {
        if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
          this.timeline.animationsWithPromises.push(this);
        }
        this.finishedPromise = new Promise(function(resolve, reject) {
          _this2.resolveFinishedPromise = function() {
            resolve(_this2);
          };
          _this2.rejectFinishedPromise = function() {
            reject(new Error());
          };
        });
        if (this.playState === "finished") {
          this.resolveFinishedPromise();
        }
      }
      return this.finishedPromise;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/onfinish
     */
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/oncancel
     */
    /**
     * get called after each frame when running
     */
  }, {
    key: "currentTime",
    get: function get() {
      this.updatePromises();
      return this._idle || this.currentTimePending ? null : this._currentTime;
    },
    set: function set7(newTime) {
      newTime = Number(newTime);
      if (isNaN(newTime)) return;
      this.timeline.restart();
      if (!this._paused && this._startTime !== null) {
        var _this$timeline;
        this._startTime = Number((_this$timeline = this.timeline) === null || _this$timeline === void 0 ? void 0 : _this$timeline.currentTime) - newTime / this.playbackRate;
      }
      this.currentTimePending = false;
      if (this._currentTime === newTime) {
        return;
      }
      if (this._idle) {
        this._idle = false;
        this._paused = true;
      }
      this.tickCurrentTime(newTime, true);
      this.timeline.applyDirtiedAnimation(this);
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/startTime
     */
  }, {
    key: "startTime",
    get: function get() {
      return this._startTime;
    },
    set: function set7(newTime) {
      if (newTime !== null) {
        this.updatePromises();
        newTime = Number(newTime);
        if (isNaN(newTime)) return;
        if (this._paused || this._idle) return;
        this._startTime = newTime;
        this.tickCurrentTime((Number(this.timeline.currentTime) - this._startTime) * this.playbackRate);
        this.timeline.applyDirtiedAnimation(this);
        this.updatePromises();
      }
    }
  }, {
    key: "playbackRate",
    get: function get() {
      return this._playbackRate;
    },
    set: function set7(value) {
      if (value === this._playbackRate) {
        return;
      }
      this.updatePromises();
      var oldCurrentTime = this.currentTime;
      this._playbackRate = value;
      this.startTime = null;
      if (this.playState !== "paused" && this.playState !== "idle") {
        this._finishedFlag = false;
        this._idle = false;
        this.ensureAlive();
        this.timeline.applyDirtiedAnimation(this);
      }
      if (oldCurrentTime !== null) {
        this.currentTime = oldCurrentTime;
      }
      this.updatePromises();
    }
  }, {
    key: "_isFinished",
    get: function get() {
      return !this._idle && (this._playbackRate > 0 && Number(this._currentTime) >= this._totalDuration || this._playbackRate < 0 && Number(this._currentTime) <= 0);
    }
  }, {
    key: "totalDuration",
    get: function get() {
      return this._totalDuration;
    }
  }, {
    key: "_needsTick",
    get: function get() {
      return this.pending || this.playState === "running" || !this._finishedFlag;
    }
  }, {
    key: "updatePromises",
    value: function updatePromises() {
      var _this$effect$target;
      if ((_this$effect$target = this.effect.target) !== null && _this$effect$target !== void 0 && _this$effect$target.destroyed) {
        this.readyPromise = void 0;
        this.finishedPromise = void 0;
        return false;
      }
      var oldPlayState = this.oldPlayState;
      var newPlayState = this.pending ? "pending" : this.playState;
      if (this.readyPromise && newPlayState !== oldPlayState) {
        if (newPlayState === "idle") {
          this.rejectReadyPromise();
          this.readyPromise = void 0;
        } else if (oldPlayState === "pending") {
          this.resolveReadyPromise();
        } else if (newPlayState === "pending") {
          this.readyPromise = void 0;
        }
      }
      if (this.finishedPromise && newPlayState !== oldPlayState) {
        if (newPlayState === "idle") {
          this.rejectFinishedPromise();
          this.finishedPromise = void 0;
        } else if (newPlayState === "finished") {
          this.resolveFinishedPromise();
        } else if (oldPlayState === "finished") {
          this.finishedPromise = void 0;
        }
      }
      this.oldPlayState = newPlayState;
      return this.readyPromise || this.finishedPromise;
    }
  }, {
    key: "play",
    value: function play() {
      this.updatePromises();
      this._paused = false;
      if (this._isFinished || this._idle) {
        this.rewind();
        this._startTime = null;
      }
      this._finishedFlag = false;
      this._idle = false;
      this.ensureAlive();
      this.timeline.applyDirtiedAnimation(this);
      if (this.timeline.animations.indexOf(this) === -1) {
        this.timeline.animations.push(this);
      }
      this.updatePromises();
    }
  }, {
    key: "pause",
    value: function pause() {
      this.updatePromises();
      if (this.currentTime) {
        this._holdTime = this.currentTime;
      }
      if (!this._isFinished && !this._paused && !this._idle) {
        this.currentTimePending = true;
      } else if (this._idle) {
        this.rewind();
        this._idle = false;
      }
      this._startTime = null;
      this._paused = true;
      this.updatePromises();
    }
  }, {
    key: "finish",
    value: function finish() {
      this.updatePromises();
      if (this._idle) return;
      this.currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
      this._startTime = this._totalDuration - this.currentTime;
      this.currentTimePending = false;
      this.timeline.applyDirtiedAnimation(this);
      this.updatePromises();
    }
  }, {
    key: "cancel",
    value: function cancel() {
      var _this3 = this;
      this.updatePromises();
      if (!this._inEffect) return;
      this._inEffect = false;
      this._idle = true;
      this._paused = false;
      this._finishedFlag = true;
      this._currentTime = 0;
      this._startTime = null;
      this.effect.update(null);
      this.timeline.applyDirtiedAnimation(this);
      this.updatePromises();
      if (this.oncancel) {
        var event = new AnimationEvent(null, this, this.currentTime, null);
        setTimeout(function() {
          _this3.oncancel(event);
        });
      }
    }
  }, {
    key: "reverse",
    value: function reverse() {
      this.updatePromises();
      var oldCurrentTime = this.currentTime;
      this.playbackRate *= -1;
      this.play();
      if (oldCurrentTime !== null) {
        this.currentTime = oldCurrentTime;
      }
      this.updatePromises();
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/updatePlaybackRate
     */
  }, {
    key: "updatePlaybackRate",
    value: function updatePlaybackRate(playbackRate) {
      this.playbackRate = playbackRate;
    }
  }, {
    key: "targetAnimations",
    value: function targetAnimations() {
      var _this$effect2;
      var target = (_this$effect2 = this.effect) === null || _this$effect2 === void 0 ? void 0 : _this$effect2.target;
      return target.getAnimations();
    }
  }, {
    key: "markTarget",
    value: function markTarget() {
      var animations = this.targetAnimations();
      if (animations.indexOf(this) === -1) {
        animations.push(this);
      }
    }
  }, {
    key: "unmarkTarget",
    value: function unmarkTarget() {
      var animations = this.targetAnimations();
      var index2 = animations.indexOf(this);
      if (index2 !== -1) {
        animations.splice(index2, 1);
      }
    }
  }, {
    key: "tick",
    value: function tick2(timelineTime, isAnimationFrame) {
      if (!this._idle && !this._paused) {
        if (this._startTime === null) {
          if (isAnimationFrame) {
            this.startTime = timelineTime - this._currentTime / this.playbackRate;
          }
        } else if (!this._isFinished) {
          this.tickCurrentTime((timelineTime - this._startTime) * this.playbackRate);
        }
      }
      if (isAnimationFrame) {
        this.currentTimePending = false;
        this.fireEvents(timelineTime);
      }
    }
  }, {
    key: "rewind",
    value: function rewind() {
      if (this.playbackRate >= 0) {
        this.currentTime = 0;
      } else if (this._totalDuration < Infinity) {
        this.currentTime = this._totalDuration;
      } else {
        throw new Error("Unable to rewind negative playback rate animation with infinite duration");
      }
    }
  }, {
    key: "persist",
    value: function persist() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(type, listener, options) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, listener, options) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "commitStyles",
    value: (
      // replaceState: AnimationReplaceState;
      function commitStyles() {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    )
  }, {
    key: "ensureAlive",
    value: function ensureAlive() {
      if (this.playbackRate < 0 && this.currentTime === 0) {
        var _this$effect3;
        this._inEffect = !!((_this$effect3 = this.effect) !== null && _this$effect3 !== void 0 && _this$effect3.update(-1));
      } else {
        var _this$effect4;
        this._inEffect = !!((_this$effect4 = this.effect) !== null && _this$effect4 !== void 0 && _this$effect4.update(this.currentTime));
      }
      if (!this._inTimeline && (this._inEffect || !this._finishedFlag)) {
        this._inTimeline = true;
        this.timeline.animations.push(this);
      }
    }
  }, {
    key: "tickCurrentTime",
    value: function tickCurrentTime(newTime, ignoreLimit) {
      if (newTime !== this._currentTime) {
        this._currentTime = newTime;
        if (this._isFinished && !ignoreLimit) {
          this._currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
        }
        this.ensureAlive();
      }
    }
  }, {
    key: "fireEvents",
    value: function fireEvents(baseTime) {
      var _this4 = this;
      if (this._isFinished) {
        if (!this._finishedFlag) {
          if (this.onfinish) {
            var event = new AnimationEvent(null, this, this.currentTime, baseTime);
            setTimeout(function() {
              if (_this4.onfinish) {
                _this4.onfinish(event);
              }
            });
          }
          this._finishedFlag = true;
        }
      } else {
        if (this.onframe && this.playState === "running") {
          var _event = new AnimationEvent(null, this, this.currentTime, baseTime);
          this.onframe(_event);
        }
        this._finishedFlag = false;
      }
    }
  }]);
}();
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 1e-3;
var SUBDIVISION_PRECISION = 1e-7;
var SUBDIVISION_MAX_ITERATIONS = 10;
var kSplineTableSize = 11;
var kSampleStepSize = 1 / (kSplineTableSize - 1);
var float32ArraySupported = typeof Float32Array === "function";
var A = function A2(aA1, aA2) {
  return 1 - 3 * aA2 + 3 * aA1;
};
var B = function B2(aA1, aA2) {
  return 3 * aA2 - 6 * aA1;
};
var C = function C2(aA1) {
  return 3 * aA1;
};
var calcBezier = function calcBezier2(aT, aA1, aA2) {
  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
};
var getSlope = function getSlope2(aT, aA1, aA2) {
  return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
};
var binarySubdivide = function binarySubdivide2(aX, aA, aB, mX1, mX2) {
  var currentX;
  var currentT;
  var i = 0;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0) aB = currentT;
    else aA = currentT;
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
  return currentT;
};
var newtonRaphsonIterate = function newtonRaphsonIterate2(aX, aGuessT, mX1, mX2) {
  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
    var currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0) return aGuessT;
    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
};
var bezier2 = function bezier3(mX1, mY1, mX2, mY2) {
  if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) throw new Error("bezier x values must be in [0, 1] range");
  if (mX1 === mY1 && mX2 === mY2) return function(t) {
    return t;
  };
  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  for (var i = 0; i < kSplineTableSize; ++i) {
    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
  }
  var getTForX = function getTForX2(aX) {
    var intervalStart = 0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;
    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) intervalStart += kSampleStepSize;
    --currentSample;
    var dist4 = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    var guessForT = intervalStart + dist4 * kSampleStepSize;
    var initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE) return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    if (initialSlope === 0) return guessForT;
    return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
  };
  return function(t) {
    if (t === 0 || t === 1) return t;
    return calcBezier(getTForX(t), mY1, mY2);
  };
};
var convertToDash = function convertToDash2(str7) {
  str7 = str7.replace(/([A-Z])/g, function(letter) {
    return "-".concat(letter.toLowerCase());
  });
  return str7.charAt(0) === "-" ? str7.substring(1) : str7;
};
var Quad = function Quad2(t) {
  return Math.pow(t, 2);
};
var Cubic = function Cubic2(t) {
  return Math.pow(t, 3);
};
var Quart = function Quart2(t) {
  return Math.pow(t, 4);
};
var Quint = function Quint2(t) {
  return Math.pow(t, 5);
};
var Expo = function Expo2(t) {
  return Math.pow(t, 6);
};
var Sine = function Sine2(t) {
  return 1 - Math.cos(t * Math.PI / 2);
};
var Circ = function Circ2(t) {
  return 1 - Math.sqrt(1 - t * t);
};
var Back = function Back2(t) {
  return t * t * (3 * t - 2);
};
var Bounce = function Bounce2(t) {
  var pow2;
  var b = 4;
  while (t < ((pow2 = Math.pow(2, --b)) - 1) / 11) {
  }
  return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);
};
var Elastic = function Elastic2(t) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var _params = _slicedToArray(params, 2), _params$ = _params[0], amplitude = _params$ === void 0 ? 1 : _params$, _params$2 = _params[1], period = _params$2 === void 0 ? 0.5 : _params$2;
  var a2 = clamp_default(Number(amplitude), 1, 10);
  var p = clamp_default(Number(period), 0.1, 2);
  if (t === 0 || t === 1) return t;
  return -a2 * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p / (Math.PI * 2) * Math.asin(1 / a2)) * (Math.PI * 2) / p);
};
var Spring = function Spring2(t) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var duration = arguments.length > 2 ? arguments[2] : void 0;
  var _params2 = _slicedToArray(params, 4), _params2$ = _params2[0], mass = _params2$ === void 0 ? 1 : _params2$, _params2$2 = _params2[1], stiffness = _params2$2 === void 0 ? 100 : _params2$2, _params2$3 = _params2[2], damping = _params2$3 === void 0 ? 10 : _params2$3, _params2$4 = _params2[3], velocity = _params2$4 === void 0 ? 0 : _params2$4;
  mass = clamp_default(mass, 0.1, 1e3);
  stiffness = clamp_default(stiffness, 0.1, 1e3);
  damping = clamp_default(damping, 0.1, 1e3);
  velocity = clamp_default(velocity, 0.1, 1e3);
  var w0 = Math.sqrt(stiffness / mass);
  var zeta = damping / (2 * Math.sqrt(stiffness * mass));
  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
  var a2 = 1;
  var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;
  var progress = duration ? duration * t / 1e3 : t;
  if (zeta < 1) {
    progress = Math.exp(-progress * zeta * w0) * (a2 * Math.cos(wd * progress) + b * Math.sin(wd * progress));
  } else {
    progress = (a2 + b * progress) * Math.exp(-progress * w0);
  }
  if (t === 0 || t === 1) return t;
  return 1 - progress;
};
var Steps = function Steps2(t) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var _ref = params, _ref2 = _slicedToArray(_ref, 2), _ref2$ = _ref2[0], steps = _ref2$ === void 0 ? 10 : _ref2$, type = _ref2[1];
  var trunc = type === "start" ? Math.ceil : Math.floor;
  return trunc(clamp_default(t, 0, 1) * steps) / steps;
};
var Bezier = function Bezier2(t) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var _params3 = _slicedToArray(params, 4), mX1 = _params3[0], mY1 = _params3[1], mX2 = _params3[2], mY2 = _params3[3];
  return bezier2(mX1, mY1, mX2, mY2)(t);
};
var easein = bezier2(0.42, 0, 1, 1);
var EaseOut = function EaseOut2(ease2) {
  return function(t) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var duration = arguments.length > 2 ? arguments[2] : void 0;
    return 1 - ease2(1 - t, params, duration);
  };
};
var EaseInOut = function EaseInOut2(ease2) {
  return function(t) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var duration = arguments.length > 2 ? arguments[2] : void 0;
    return t < 0.5 ? ease2(t * 2, params, duration) / 2 : 1 - ease2(t * -2 + 2, params, duration) / 2;
  };
};
var EaseOutIn = function EaseOutIn2(ease2) {
  return function(t) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var duration = arguments.length > 2 ? arguments[2] : void 0;
    return t < 0.5 ? (1 - ease2(1 - t * 2, params, duration)) / 2 : (ease2(t * 2 - 1, params, duration) + 1) / 2;
  };
};
var EasingFunctions = {
  steps: Steps,
  "step-start": function stepStart(t) {
    return Steps(t, [1, "start"]);
  },
  "step-end": function stepEnd(t) {
    return Steps(t, [1, "end"]);
  },
  linear: function linear(t) {
    return t;
  },
  "cubic-bezier": Bezier,
  ease: function ease(t) {
    return Bezier(t, [0.25, 0.1, 0.25, 1]);
  },
  "in": easein,
  out: EaseOut(easein),
  "in-out": EaseInOut(easein),
  "out-in": EaseOutIn(easein),
  "in-quad": Quad,
  "out-quad": EaseOut(Quad),
  "in-out-quad": EaseInOut(Quad),
  "out-in-quad": EaseOutIn(Quad),
  "in-cubic": Cubic,
  "out-cubic": EaseOut(Cubic),
  "in-out-cubic": EaseInOut(Cubic),
  "out-in-cubic": EaseOutIn(Cubic),
  "in-quart": Quart,
  "out-quart": EaseOut(Quart),
  "in-out-quart": EaseInOut(Quart),
  "out-in-quart": EaseOutIn(Quart),
  "in-quint": Quint,
  "out-quint": EaseOut(Quint),
  "in-out-quint": EaseInOut(Quint),
  "out-in-quint": EaseOutIn(Quint),
  "in-expo": Expo,
  "out-expo": EaseOut(Expo),
  "in-out-expo": EaseInOut(Expo),
  "out-in-expo": EaseOutIn(Expo),
  "in-sine": Sine,
  "out-sine": EaseOut(Sine),
  "in-out-sine": EaseInOut(Sine),
  "out-in-sine": EaseOutIn(Sine),
  "in-circ": Circ,
  "out-circ": EaseOut(Circ),
  "in-out-circ": EaseInOut(Circ),
  "out-in-circ": EaseOutIn(Circ),
  "in-back": Back,
  "out-back": EaseOut(Back),
  "in-out-back": EaseInOut(Back),
  "out-in-back": EaseOutIn(Back),
  "in-bounce": Bounce,
  "out-bounce": EaseOut(Bounce),
  "in-out-bounce": EaseInOut(Bounce),
  "out-in-bounce": EaseOutIn(Bounce),
  "in-elastic": Elastic,
  "out-elastic": EaseOut(Elastic),
  "in-out-elastic": EaseInOut(Elastic),
  "out-in-elastic": EaseOutIn(Elastic),
  spring: Spring,
  "spring-in": Spring,
  "spring-out": EaseOut(Spring),
  "spring-in-out": EaseInOut(Spring),
  "spring-out-in": EaseOutIn(Spring)
};
var complexEasingSyntax = function complexEasingSyntax2(ease2) {
  return convertToDash(ease2).replace(/^ease-/, "").replace(/(\(|\s).+/, "").toLowerCase().trim();
};
var getEasingFunction = function getEasingFunction2(ease2) {
  return EasingFunctions[complexEasingSyntax(ease2)] || EasingFunctions.linear;
};
var linear2 = function linear3(x3) {
  return x3;
};
var Start = 1;
var Middle = 0.5;
var End = 0;
function step(count, pos) {
  return function(x3) {
    if (x3 >= 1) {
      return 1;
    }
    var stepSize = 1 / count;
    x3 += pos * stepSize;
    return x3 - x3 % stepSize;
  };
}
var numberString = "\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*";
var cubicBezierRe = new RegExp("cubic-bezier\\(".concat(numberString, ",").concat(numberString, ",").concat(numberString, ",").concat(numberString, "\\)"));
var step1Re = /steps\(\s*(\d+)\s*\)/;
var step2Re = /steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/;
function parseEasingFunction(normalizedEasing) {
  var cubicData = cubicBezierRe.exec(normalizedEasing);
  if (cubicData) {
    return bezier2.apply(void 0, _toConsumableArray(cubicData.slice(1).map(Number)));
  }
  var step1Data = step1Re.exec(normalizedEasing);
  if (step1Data) {
    return step(Number(step1Data[1]), End);
  }
  var step2Data = step2Re.exec(normalizedEasing);
  if (step2Data) {
    return step(Number(step2Data[1]), {
      start: Start,
      middle: Middle,
      end: End
    }[step2Data[2]]);
  }
  return getEasingFunction(normalizedEasing);
}
function calculateActiveDuration(timing) {
  return Math.abs(repeatedDuration(timing) / (timing.playbackRate || 1));
}
function repeatedDuration(timing) {
  var _timing$iterations;
  if (timing.duration === 0 || timing.iterations === 0) {
    return 0;
  }
  return (timing.duration === "auto" ? 0 : Number(timing.duration)) * ((_timing$iterations = timing.iterations) !== null && _timing$iterations !== void 0 ? _timing$iterations : 1);
}
var PhaseNone = 0;
var PhaseBefore = 1;
var PhaseAfter = 2;
var PhaseActive = 3;
function calculatePhase(activeDuration, localTime, timing) {
  if (localTime === null) {
    return PhaseNone;
  }
  var endTime = timing.endTime;
  if (localTime < Math.min(timing.delay, endTime)) {
    return PhaseBefore;
  }
  if (localTime >= Math.min(timing.delay + activeDuration + timing.endDelay, endTime)) {
    return PhaseAfter;
  }
  return PhaseActive;
}
function calculateActiveTime(activeDuration, fillMode, localTime, phase, delay) {
  switch (phase) {
    case PhaseBefore:
      if (fillMode === "backwards" || fillMode === "both") return 0;
      return null;
    case PhaseActive:
      return localTime - delay;
    case PhaseAfter:
      if (fillMode === "forwards" || fillMode === "both") return activeDuration;
      return null;
    case PhaseNone:
      return null;
  }
}
function calculateOverallProgress(iterationDuration, phase, iterations, activeTime, iterationStart) {
  var overallProgress = iterationStart;
  if (iterationDuration === 0) {
    if (phase !== PhaseBefore) {
      overallProgress += iterations;
    }
  } else {
    overallProgress += activeTime / iterationDuration;
  }
  return overallProgress;
}
function calculateSimpleIterationProgress(overallProgress, iterationStart, phase, iterations, activeTime, iterationDuration) {
  var simpleIterationProgress = overallProgress === Infinity ? iterationStart % 1 : overallProgress % 1;
  if (simpleIterationProgress === 0 && phase === PhaseAfter && iterations !== 0 && (activeTime !== 0 || iterationDuration === 0)) {
    simpleIterationProgress = 1;
  }
  return simpleIterationProgress;
}
function calculateCurrentIteration(phase, iterations, simpleIterationProgress, overallProgress) {
  if (phase === PhaseAfter && iterations === Infinity) {
    return Infinity;
  }
  if (simpleIterationProgress === 1) {
    return Math.floor(overallProgress) - 1;
  }
  return Math.floor(overallProgress);
}
function calculateDirectedProgress(playbackDirection, currentIteration, simpleIterationProgress) {
  var currentDirection = playbackDirection;
  if (playbackDirection !== "normal" && playbackDirection !== "reverse") {
    var d2 = currentIteration;
    if (playbackDirection === "alternate-reverse") {
      d2 += 1;
    }
    currentDirection = "normal";
    if (d2 !== Infinity && d2 % 2 !== 0) {
      currentDirection = "reverse";
    }
  }
  if (currentDirection === "normal") {
    return simpleIterationProgress;
  }
  return 1 - simpleIterationProgress;
}
function calculateIterationProgress(activeDuration, localTime, timing) {
  var phase = calculatePhase(activeDuration, localTime, timing);
  var activeTime = calculateActiveTime(activeDuration, timing.fill, localTime, phase, timing.delay);
  if (activeTime === null) return null;
  var duration = timing.duration === "auto" ? 0 : timing.duration;
  var overallProgress = calculateOverallProgress(duration, phase, timing.iterations, activeTime, timing.iterationStart);
  var simpleIterationProgress = calculateSimpleIterationProgress(overallProgress, timing.iterationStart, phase, timing.iterations, activeTime, duration);
  var currentIteration = calculateCurrentIteration(phase, timing.iterations, simpleIterationProgress, overallProgress);
  var directedProgress = calculateDirectedProgress(timing.direction, currentIteration, simpleIterationProgress);
  timing.currentIteration = currentIteration;
  timing.progress = directedProgress;
  return timing.easingFunction(directedProgress);
}
function convertEffectInput(keyframes, timing, target) {
  var propertySpecificKeyframeGroups = makePropertySpecificKeyframeGroups(keyframes, timing);
  var interpolations = makeInterpolations(propertySpecificKeyframeGroups, target);
  return function(target2, fraction) {
    if (fraction !== null) {
      interpolations.filter(function(interpolation) {
        return fraction >= interpolation.applyFrom && fraction < interpolation.applyTo;
      }).forEach(function(interpolation) {
        var offsetFraction = fraction - interpolation.startOffset;
        var localDuration = interpolation.endOffset - interpolation.startOffset;
        var scaledLocalTime = localDuration === 0 ? 0 : offsetFraction / localDuration;
        target2.setAttribute(
          interpolation.property,
          interpolation.interpolation(scaledLocalTime),
          false,
          false
          // disable memoize
        );
      });
    } else {
      for (var property in propertySpecificKeyframeGroups) if (isNotReservedWord(property)) {
        target2.setAttribute(property, null);
      }
    }
  };
}
function isNotReservedWord(member) {
  return member !== "offset" && member !== "easing" && member !== "composite" && member !== "computedOffset";
}
function makePropertySpecificKeyframeGroups(keyframes, timing) {
  var propertySpecificKeyframeGroups = {};
  for (var i = 0; i < keyframes.length; i++) {
    for (var member in keyframes[i]) {
      if (isNotReservedWord(member)) {
        var propertySpecificKeyframe = {
          offset: keyframes[i].offset,
          computedOffset: keyframes[i].computedOffset,
          easing: keyframes[i].easing,
          easingFunction: parseEasingFunction(keyframes[i].easing) || timing.easingFunction,
          value: keyframes[i][member]
        };
        propertySpecificKeyframeGroups[member] = propertySpecificKeyframeGroups[member] || [];
        propertySpecificKeyframeGroups[member].push(propertySpecificKeyframe);
      }
    }
  }
  return propertySpecificKeyframeGroups;
}
function makeInterpolations(propertySpecificKeyframeGroups, target) {
  var interpolations = [];
  for (var groupName in propertySpecificKeyframeGroups) {
    var keyframes = propertySpecificKeyframeGroups[groupName];
    for (var i = 0; i < keyframes.length - 1; i++) {
      var startIndex = i;
      var endIndex = i + 1;
      var startOffset = keyframes[startIndex].computedOffset;
      var endOffset = keyframes[endIndex].computedOffset;
      var applyFrom = startOffset;
      var applyTo = endOffset;
      if (i === 0) {
        applyFrom = -Infinity;
        if (endOffset === 0) {
          endIndex = startIndex;
        }
      }
      if (i === keyframes.length - 2) {
        applyTo = Infinity;
        if (startOffset === 1) {
          startIndex = endIndex;
        }
      }
      interpolations.push({
        applyFrom,
        applyTo,
        startOffset: keyframes[startIndex].computedOffset,
        endOffset: keyframes[endIndex].computedOffset,
        easingFunction: keyframes[startIndex].easingFunction,
        property: groupName,
        interpolation: propertyInterpolation(groupName, keyframes[startIndex].value, keyframes[endIndex].value, target)
      });
    }
  }
  interpolations.sort(function(leftInterpolation, rightInterpolation) {
    return leftInterpolation.startOffset - rightInterpolation.startOffset;
  });
  return interpolations;
}
var InterpolationFactory = function InterpolationFactory2(from, to, convertToString) {
  return function(f) {
    var interpolated = interpolate(from, to, f);
    return isNumber(interpolated) ? interpolated : convertToString(interpolated);
  };
};
function propertyInterpolation(property, left, right, target) {
  var metadata = propertyMetadataCache[property];
  if (metadata && metadata.syntax && metadata["int"]) {
    var propertyHandler = runtime.styleValueRegistry.getPropertySyntax(metadata.syntax);
    if (propertyHandler) {
      var parser2 = propertyHandler.parser;
      var usedLeft = parser2 ? parser2(left, target) : left;
      var usedRight = parser2 ? parser2(right, target) : right;
      var interpolationArgs = propertyHandler.mixer(usedLeft, usedRight, target);
      if (interpolationArgs) {
        var interp = InterpolationFactory.apply(void 0, _toConsumableArray(interpolationArgs));
        return function(t) {
          if (t === 0) return left;
          if (t === 1) return right;
          return interp(t);
        };
      }
    }
  }
  return InterpolationFactory(false, true, function(bool) {
    return bool ? right : left;
  });
}
function interpolate(from, to, f) {
  if (typeof from === "number" && typeof to === "number") {
    return from * (1 - f) + to * f;
  }
  if (typeof from === "boolean" && typeof to === "boolean" || typeof from === "string" && typeof to === "string") {
    return f < 0.5 ? from : to;
  }
  if (Array.isArray(from) && Array.isArray(to)) {
    var fromLength = from.length;
    var toLength = to.length;
    var length5 = Math.max(fromLength, toLength);
    var r = [];
    for (var i = 0; i < length5; i++) {
      r.push(interpolate(from[i < fromLength ? i : fromLength - 1], to[i < toLength ? i : toLength - 1], f));
    }
    return r;
  }
  throw new Error("Mismatched interpolation arguments ".concat(from, ":").concat(to));
}
var AnimationEffectTiming = function() {
  function AnimationEffectTiming2() {
    _classCallCheck(this, AnimationEffectTiming2);
    this.delay = 0;
    this.direction = "normal";
    this.duration = "auto";
    this._easing = "linear";
    this.easingFunction = linear2;
    this.endDelay = 0;
    this.fill = "auto";
    this.iterationStart = 0;
    this.iterations = 1;
    this.currentIteration = null;
    this.progress = null;
  }
  return _createClass(AnimationEffectTiming2, [{
    key: "easing",
    get: function get() {
      return this._easing;
    },
    set: function set7(value) {
      this.easingFunction = parseEasingFunction(value);
      this._easing = value;
    }
  }]);
}();
function convertToArrayForm(effectInput) {
  var normalizedEffectInput = [];
  for (var property in effectInput) {
    if (property in ["easing", "offset", "composite"]) {
      continue;
    }
    var values = effectInput[property];
    if (!Array.isArray(values)) {
      values = [values];
    }
    var numKeyframes = values.length;
    for (var i = 0; i < numKeyframes; i++) {
      if (!normalizedEffectInput[i]) {
        var keyframe = {};
        if ("offset" in effectInput) {
          keyframe.offset = Number(effectInput.offset);
        }
        if ("easing" in effectInput) {
          keyframe.easing = effectInput.easing;
        }
        if ("composite" in effectInput) {
          keyframe.composite = effectInput.composite;
        }
        normalizedEffectInput[i] = keyframe;
      }
      if (values[i] !== void 0 && values[i] !== null) {
        normalizedEffectInput[i][property] = values[i];
      }
    }
  }
  normalizedEffectInput.sort(function(a2, b) {
    return (a2.computedOffset || 0) - (b.computedOffset || 0);
  });
  return normalizedEffectInput;
}
function normalizeKeyframes(effectInput, timing) {
  if (effectInput === null) {
    return [];
  }
  if (!Array.isArray(effectInput)) {
    effectInput = convertToArrayForm(effectInput);
  }
  var keyframes = effectInput.map(function(originalKeyframe) {
    var keyframe = {};
    if (timing !== null && timing !== void 0 && timing.composite) {
      keyframe.composite = "auto";
    }
    for (var member in originalKeyframe) {
      var memberValue = originalKeyframe[member];
      if (member === "offset") {
        if (memberValue !== null) {
          memberValue = Number(memberValue);
          if (!isFinite(memberValue)) throw new Error("Keyframe offsets must be numbers.");
          if (memberValue < 0 || memberValue > 1) throw new Error("Keyframe offsets must be between 0 and 1.");
          keyframe.computedOffset = memberValue;
        }
      } else if (member === "composite") {
        if (["replace", "add", "accumulate", "auto"].indexOf(memberValue) === -1) {
          throw new Error("".concat(memberValue, " compositing is not supported"));
        }
      } else ;
      keyframe[member] = memberValue;
    }
    if (keyframe.offset === void 0) {
      keyframe.offset = null;
    }
    if (keyframe.easing === void 0) {
      keyframe.easing = (timing === null || timing === void 0 ? void 0 : timing.easing) || "linear";
    }
    if (keyframe.composite === void 0) {
      keyframe.composite = "auto";
    }
    return keyframe;
  });
  var everyFrameHasOffset = true;
  var previousOffset = -Infinity;
  for (var i = 0; i < keyframes.length; i++) {
    var offset = keyframes[i].offset;
    if (!isNil(offset)) {
      if (offset < previousOffset) {
        throw new TypeError("Keyframes are not loosely sorted by offset. Sort or specify offsets.");
      }
      previousOffset = offset;
    } else {
      everyFrameHasOffset = false;
    }
  }
  keyframes = keyframes.filter(function(keyframe) {
    return Number(keyframe.offset) >= 0 && Number(keyframe.offset) <= 1;
  });
  function spaceKeyframes() {
    var _keyframes$offset;
    var _keyframes = keyframes, length5 = _keyframes.length;
    keyframes[length5 - 1].computedOffset = Number((_keyframes$offset = keyframes[length5 - 1].offset) !== null && _keyframes$offset !== void 0 ? _keyframes$offset : 1);
    if (length5 > 1) {
      var _keyframes$0$offset;
      keyframes[0].computedOffset = Number((_keyframes$0$offset = keyframes[0].offset) !== null && _keyframes$0$offset !== void 0 ? _keyframes$0$offset : 0);
    }
    var previousIndex = 0;
    var previousOffset2 = Number(keyframes[0].computedOffset);
    for (var _i = 1; _i < length5; _i++) {
      var _offset = keyframes[_i].computedOffset;
      if (!isNil(_offset) && !isNil(previousOffset2)) {
        for (var j = 1; j < _i - previousIndex; j++) keyframes[previousIndex + j].computedOffset = previousOffset2 + (Number(_offset) - previousOffset2) * j / (_i - previousIndex);
        previousIndex = _i;
        previousOffset2 = Number(_offset);
      }
    }
  }
  if (!everyFrameHasOffset) spaceKeyframes();
  return keyframes;
}
var fills = "backwards|forwards|both|none".split("|");
var directions = "reverse|alternate|alternate-reverse".split("|");
function makeTiming(timingInput, forGroup) {
  var timing = new AnimationEffectTiming();
  if (forGroup) {
    timing.fill = "both";
    timing.duration = "auto";
  }
  if (typeof timingInput === "number" && !isNaN(timingInput)) {
    timing.duration = timingInput;
  } else if (timingInput !== void 0) {
    Object.keys(timingInput).forEach(function(property) {
      if (timingInput[property] !== void 0 && timingInput[property] !== null && timingInput[property] !== "auto") {
        if (typeof timing[property] === "number" || property === "duration") {
          if (typeof timingInput[property] !== "number" || isNaN(timingInput[property])) {
            return;
          }
        }
        if (property === "fill" && fills.indexOf(timingInput[property]) === -1) {
          return;
        }
        if (property === "direction" && directions.indexOf(timingInput[property]) === -1) {
          return;
        }
        timing[property] = timingInput[property];
      }
    });
  }
  return timing;
}
function normalizeTimingInput(timingInput, forGroup) {
  timingInput = numericTimingToObject(timingInput !== null && timingInput !== void 0 ? timingInput : {
    duration: "auto"
  });
  return makeTiming(timingInput, forGroup);
}
function numericTimingToObject(timingInput) {
  if (typeof timingInput === "number") {
    if (isNaN(timingInput)) {
      timingInput = {
        duration: "auto"
      };
    } else {
      timingInput = {
        duration: timingInput
      };
    }
  }
  return timingInput;
}
var KeyframeEffect = function() {
  function KeyframeEffect2(target, effectInput, timingInput) {
    var _this2 = this;
    _classCallCheck(this, KeyframeEffect2);
    this.composite = "replace";
    this.iterationComposite = "replace";
    this.target = target;
    this.timing = normalizeTimingInput(timingInput, false);
    this.timing.effect = this;
    this.timing.activeDuration = calculateActiveDuration(this.timing);
    this.timing.endTime = Math.max(0, this.timing.delay + this.timing.activeDuration + this.timing.endDelay);
    this.normalizedKeyframes = normalizeKeyframes(effectInput, this.timing);
    this.interpolations = convertEffectInput(this.normalizedKeyframes, this.timing, this.target);
    var Proxy2 = runtime.globalThis.Proxy;
    this.computedTiming = Proxy2 ? new Proxy2(this.timing, {
      get: function get(target2, prop) {
        if (prop === "duration") {
          return target2.duration === "auto" ? 0 : target2.duration;
        }
        if (prop === "fill") {
          return target2.fill === "auto" ? "none" : target2.fill;
        }
        if (prop === "localTime") {
          return _this2.animation && _this2.animation.currentTime || null;
        }
        if (prop === "currentIteration") {
          if (!_this2.animation || _this2.animation.playState !== "running") {
            return null;
          }
          return target2.currentIteration || 0;
        }
        if (prop === "progress") {
          if (!_this2.animation || _this2.animation.playState !== "running") {
            return null;
          }
          return target2.progress || 0;
        }
        return target2[prop];
      },
      set: function set7() {
        return true;
      }
    }) : this.timing;
  }
  return _createClass(KeyframeEffect2, [{
    key: "applyInterpolations",
    value: function applyInterpolations() {
      this.interpolations(this.target, Number(this.timeFraction));
    }
  }, {
    key: "update",
    value: function update2(localTime) {
      if (localTime === null) {
        return false;
      }
      this.timeFraction = calculateIterationProgress(this.timing.activeDuration, localTime, this.timing);
      return this.timeFraction !== null;
    }
  }, {
    key: "getKeyframes",
    value: function getKeyframes() {
      return this.normalizedKeyframes;
    }
  }, {
    key: "setKeyframes",
    value: function setKeyframes(keyframes) {
      this.normalizedKeyframes = normalizeKeyframes(keyframes);
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getComputedTiming
     */
  }, {
    key: "getComputedTiming",
    value: function getComputedTiming() {
      return this.computedTiming;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getTiming
     */
  }, {
    key: "getTiming",
    value: function getTiming() {
      return this.timing;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/updateTiming
     */
  }, {
    key: "updateTiming",
    value: function updateTiming(timing) {
      var _this2 = this;
      Object.keys(timing || {}).forEach(function(name) {
        _this2.timing[name] = timing[name];
      });
    }
  }]);
}();
function compareAnimations(leftAnimation, rightAnimation) {
  return Number(leftAnimation.id) - Number(rightAnimation.id);
}
var AnimationTimeline = function() {
  function AnimationTimeline2(document2) {
    var _this2 = this;
    _classCallCheck(this, AnimationTimeline2);
    this.animations = [];
    this.ticking = false;
    this.timelineTicking = false;
    this.hasRestartedThisFrame = false;
    this.animationsWithPromises = [];
    this.inTick = false;
    this.pendingEffects = [];
    this.currentTime = null;
    this.rafId = 0;
    this.rafCallbacks = [];
    this.webAnimationsNextTick = function(t) {
      _this2.currentTime = t;
      _this2.discardAnimations();
      if (_this2.animations.length === 0) {
        _this2.timelineTicking = false;
      } else {
        _this2.requestAnimationFrame(_this2.webAnimationsNextTick);
      }
    };
    this.processRafCallbacks = function(t) {
      var processing = _this2.rafCallbacks;
      _this2.rafCallbacks = [];
      if (t < Number(_this2.currentTime)) t = Number(_this2.currentTime);
      _this2.animations.sort(compareAnimations);
      _this2.animations = _this2.tick(t, true, _this2.animations)[0];
      processing.forEach(function(entry) {
        entry[1](t);
      });
      _this2.applyPendingEffects();
    };
    this.document = document2;
  }
  return _createClass(AnimationTimeline2, [{
    key: "getAnimations",
    value: function getAnimations() {
      this.discardAnimations();
      return this.animations.slice();
    }
  }, {
    key: "isTicking",
    value: function isTicking() {
      return this.inTick;
    }
  }, {
    key: "play",
    value: function play(target, keyframes, options) {
      var effect = new KeyframeEffect(target, keyframes, options);
      var animation = new Animation(effect, this);
      this.animations.push(animation);
      this.restartWebAnimationsNextTick();
      animation.updatePromises();
      animation.play();
      animation.updatePromises();
      return animation;
    }
    // RAF is supposed to be the last script to occur before frame rendering but not
    // all browsers behave like this. This function is for synchonously updating an
    // animation's effects whenever its state is mutated by script to work around
    // incorrect script execution ordering by the browser.
  }, {
    key: "applyDirtiedAnimation",
    value: function applyDirtiedAnimation(animation) {
      var _this2 = this;
      if (this.inTick) {
        return;
      }
      animation.markTarget();
      var animations = animation.targetAnimations();
      animations.sort(compareAnimations);
      var inactiveAnimations = this.tick(Number(this.currentTime), false, animations.slice())[1];
      inactiveAnimations.forEach(function(animation2) {
        var index2 = _this2.animations.indexOf(animation2);
        if (index2 !== -1) {
          _this2.animations.splice(index2, 1);
        }
      });
      this.applyPendingEffects();
    }
  }, {
    key: "restart",
    value: function restart() {
      if (!this.ticking) {
        this.ticking = true;
        this.requestAnimationFrame(function() {
        });
        this.hasRestartedThisFrame = true;
      }
      return this.hasRestartedThisFrame;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.document.defaultView.cancelAnimationFrame(this.frameId);
    }
  }, {
    key: "applyPendingEffects",
    value: function applyPendingEffects() {
      this.pendingEffects.forEach(function(effect) {
        effect === null || effect === void 0 || effect.applyInterpolations();
      });
      this.pendingEffects = [];
    }
  }, {
    key: "updateAnimationsPromises",
    value: function updateAnimationsPromises() {
      this.animationsWithPromises = this.animationsWithPromises.filter(function(animation) {
        return animation.updatePromises();
      });
    }
  }, {
    key: "discardAnimations",
    value: function discardAnimations() {
      this.updateAnimationsPromises();
      this.animations = this.animations.filter(function(animation) {
        return animation.playState !== "finished" && animation.playState !== "idle";
      });
    }
  }, {
    key: "restartWebAnimationsNextTick",
    value: function restartWebAnimationsNextTick() {
      if (!this.timelineTicking) {
        this.timelineTicking = true;
        this.requestAnimationFrame(this.webAnimationsNextTick);
      }
    }
  }, {
    key: "rAF",
    value: function rAF(f) {
      var id3 = this.rafId++;
      if (this.rafCallbacks.length === 0) {
        this.frameId = this.document.defaultView.requestAnimationFrame(this.processRafCallbacks);
      }
      this.rafCallbacks.push([id3, f]);
      return id3;
    }
  }, {
    key: "requestAnimationFrame",
    value: function requestAnimationFrame2(f) {
      var _this3 = this;
      return this.rAF(function(x3) {
        _this3.updateAnimationsPromises();
        f(x3);
        _this3.updateAnimationsPromises();
      });
    }
  }, {
    key: "tick",
    value: function tick2(t, isAnimationFrame, updatingAnimations) {
      var _this4 = this, _this$pendingEffects, _this$pendingEffects2;
      this.inTick = true;
      this.hasRestartedThisFrame = false;
      this.currentTime = t;
      this.ticking = false;
      var newPendingClears = [];
      var newPendingEffects = [];
      var activeAnimations = [];
      var inactiveAnimations = [];
      updatingAnimations.forEach(function(animation) {
        animation.tick(t, isAnimationFrame);
        if (!animation._inEffect) {
          newPendingClears.push(animation.effect);
          animation.unmarkTarget();
        } else {
          newPendingEffects.push(animation.effect);
          animation.markTarget();
        }
        if (animation._needsTick) _this4.ticking = true;
        var alive = animation._inEffect || animation._needsTick;
        animation._inTimeline = alive;
        if (alive) {
          activeAnimations.push(animation);
        } else {
          inactiveAnimations.push(animation);
        }
      });
      (_this$pendingEffects = this.pendingEffects).push.apply(_this$pendingEffects, newPendingClears);
      (_this$pendingEffects2 = this.pendingEffects).push.apply(_this$pendingEffects2, newPendingEffects);
      if (this.ticking) this.requestAnimationFrame(function() {
      });
      this.inTick = false;
      return [activeAnimations, inactiveAnimations];
    }
  }]);
}();
runtime.EasingFunction = parseEasingFunction;
runtime.AnimationTimeline = AnimationTimeline;

// node_modules/@antv/g-plugin-canvas-path-generator/dist/index.esm.js
init_defineProperty();
function generatePath$6(context, parsedStyle) {
  var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, r = parsedStyle.r;
  context.arc(cx, cy, r, 0, Math.PI * 2, false);
}
function generatePath$5(context, parsedStyle) {
  var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, rx = parsedStyle.rx, ry = parsedStyle.ry;
  if (context.ellipse) {
    context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);
  } else {
    var r = rx > ry ? rx : ry;
    var scaleX2 = rx > ry ? 1 : rx / ry;
    var scaleY2 = rx > ry ? ry / rx : 1;
    context.save();
    context.scale(scaleX2, scaleY2);
    context.arc(cx, cy, r, 0, Math.PI * 2);
  }
}
function generatePath$4(context, parsedStyle) {
  var x1 = parsedStyle.x1, y1 = parsedStyle.y1, x22 = parsedStyle.x2, y22 = parsedStyle.y2, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad2 = 0;
  var x3;
  var y3;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    x3 = x22 - x1;
    y3 = y22 - y1;
    rad2 = Math.atan2(y3, x3);
    startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    x3 = x1 - x22;
    y3 = y1 - y22;
    rad2 = Math.atan2(y3, x3);
    endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
  }
  context.moveTo(x1 + startOffsetX, y1 + startOffsetY);
  context.lineTo(x22 + endOffsetX, y22 + endOffsetY);
}
function generatePath$3(context, parsedStyle) {
  var markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var _parsedStyle$d = parsedStyle.d, absolutePath = _parsedStyle$d.absolutePath, segments = _parsedStyle$d.segments;
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad2 = 0;
  var x3;
  var y3;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    var _getStartTangent = markerStart.parentNode.getStartTangent(), _getStartTangent2 = _slicedToArray(_getStartTangent, 2), p1 = _getStartTangent2[0], p2 = _getStartTangent2[1];
    x3 = p1[0] - p2[0];
    y3 = p1[1] - p2[1];
    rad2 = Math.atan2(y3, x3);
    startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    var _getEndTangent = markerEnd.parentNode.getEndTangent(), _getEndTangent2 = _slicedToArray(_getEndTangent, 2), _p = _getEndTangent2[0], _p2 = _getEndTangent2[1];
    x3 = _p[0] - _p2[0];
    y3 = _p[1] - _p2[1];
    rad2 = Math.atan2(y3, x3);
    endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
  }
  for (var i = 0; i < absolutePath.length; i++) {
    var params = absolutePath[i];
    var command = params[0];
    var nextSegment = absolutePath[i + 1];
    var useStartOffset = i === 0 && (startOffsetX !== 0 || startOffsetY !== 0);
    var useEndOffset = (i === absolutePath.length - 1 || nextSegment && (nextSegment[0] === "M" || nextSegment[0] === "Z")) && endOffsetX !== 0 && endOffsetY !== 0;
    var _ref = useStartOffset ? [startOffsetX, startOffsetY] : [0, 0], _ref2 = _slicedToArray(_ref, 2), startOffsetXTemp = _ref2[0], startOffsetYTemp = _ref2[1];
    var _ref3 = useEndOffset ? [endOffsetX, endOffsetY] : [0, 0], _ref4 = _slicedToArray(_ref3, 2), endOffsetXTemp = _ref4[0], endOffsetYTemp = _ref4[1];
    switch (command) {
      case "M":
        context.moveTo(params[1] + startOffsetXTemp, params[2] + startOffsetYTemp);
        break;
      case "L":
        context.lineTo(params[1] + endOffsetXTemp, params[2] + endOffsetYTemp);
        break;
      case "Q":
        context.quadraticCurveTo(params[1], params[2], params[3] + endOffsetXTemp, params[4] + endOffsetYTemp);
        break;
      case "C":
        context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] + endOffsetXTemp, params[6] + endOffsetYTemp);
        break;
      case "A": {
        var arcParams = segments[i].arcParams;
        var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;
        if (context.ellipse) {
          context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, !!(1 - sweepFlag));
        } else {
          var r = rx > ry ? rx : ry;
          var scaleX2 = rx > ry ? 1 : rx / ry;
          var scaleY2 = rx > ry ? ry / rx : 1;
          context.translate(cx, cy);
          context.rotate(xRotation);
          context.scale(scaleX2, scaleY2);
          context.arc(0, 0, r, startAngle, endAngle, !!(1 - sweepFlag));
          context.scale(1 / scaleX2, 1 / scaleY2);
          context.rotate(-xRotation);
          context.translate(-cx, -cy);
        }
        if (useEndOffset) {
          context.lineTo(params[6] + endOffsetX, params[7] + endOffsetY);
        }
        break;
      }
      case "Z":
        context.closePath();
        break;
    }
  }
}
function generatePath$2(context, parsedStyle) {
  var markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var points = parsedStyle.points.points;
  var length5 = points.length;
  var x1 = points[0][0];
  var y1 = points[0][1];
  var x22 = points[length5 - 1][0];
  var y22 = points[length5 - 1][1];
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad2 = 0;
  var x3;
  var y3;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    x3 = points[1][0] - points[0][0];
    y3 = points[1][1] - points[0][1];
    rad2 = Math.atan2(y3, x3);
    startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    x3 = points[length5 - 1][0] - points[0][0];
    y3 = points[length5 - 1][1] - points[0][1];
    rad2 = Math.atan2(y3, x3);
    endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
  }
  context.moveTo(x1 + (startOffsetX || endOffsetX), y1 + (startOffsetY || endOffsetY));
  for (var i = 1; i < length5 - 1; i++) {
    var point2 = points[i];
    context.lineTo(point2[0], point2[1]);
  }
  context.lineTo(x22, y22);
}
function generatePath$1(context, parsedStyle) {
  var markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var points = parsedStyle.points.points;
  var length5 = points.length;
  var x1 = points[0][0];
  var y1 = points[0][1];
  var x22 = points[length5 - 1][0];
  var y22 = points[length5 - 1][1];
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad2 = 0;
  var x3;
  var y3;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    x3 = points[1][0] - points[0][0];
    y3 = points[1][1] - points[0][1];
    rad2 = Math.atan2(y3, x3);
    startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    x3 = points[length5 - 2][0] - points[length5 - 1][0];
    y3 = points[length5 - 2][1] - points[length5 - 1][1];
    rad2 = Math.atan2(y3, x3);
    endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
  }
  context.moveTo(x1 + startOffsetX, y1 + startOffsetY);
  for (var i = 1; i < length5 - 1; i++) {
    var point2 = points[i];
    context.lineTo(point2[0], point2[1]);
  }
  context.lineTo(x22 + endOffsetX, y22 + endOffsetY);
}
function generatePath(context, parsedStyle) {
  var _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, radius = parsedStyle.radius, width = parsedStyle.width, height = parsedStyle.height;
  var w = width;
  var h = height;
  var hasRadius = radius && radius.some(function(r) {
    return r !== 0;
  });
  if (!hasRadius) {
    context.rect(x3, y3, w, h);
  } else {
    var signX = width > 0 ? 1 : -1;
    var signY = height > 0 ? 1 : -1;
    var sweepFlag = signX + signY === 0;
    var _radius$map = radius.map(function(r) {
      return clamp_default(r, 0, Math.min(Math.abs(w) / 2, Math.abs(h) / 2));
    }), _radius$map2 = _slicedToArray(_radius$map, 4), tlr = _radius$map2[0], trr = _radius$map2[1], brr = _radius$map2[2], blr = _radius$map2[3];
    context.moveTo(signX * tlr + x3, y3);
    context.lineTo(w - signX * trr + x3, y3);
    if (trr !== 0) {
      context.arc(w - signX * trr + x3, signY * trr + y3, trr, -signY * Math.PI / 2, signX > 0 ? 0 : Math.PI, sweepFlag);
    }
    context.lineTo(w + x3, h - signY * brr + y3);
    if (brr !== 0) {
      context.arc(w - signX * brr + x3, h - signY * brr + y3, brr, signX > 0 ? 0 : Math.PI, signY > 0 ? Math.PI / 2 : 1.5 * Math.PI, sweepFlag);
    }
    context.lineTo(signX * blr + x3, h + y3);
    if (blr !== 0) {
      context.arc(signX * blr + x3, h - signY * blr + y3, blr, signY > 0 ? Math.PI / 2 : -Math.PI / 2, signX > 0 ? Math.PI : 0, sweepFlag);
    }
    context.lineTo(x3, signY * tlr + y3);
    if (tlr !== 0) {
      context.arc(signX * tlr + x3, signY * tlr + y3, tlr, signX > 0 ? Math.PI : 0, signY > 0 ? Math.PI * 1.5 : Math.PI / 2, sweepFlag);
    }
  }
}
var Plugin = function(_AbstractRendererPlug) {
  function Plugin8() {
    var _this2;
    _classCallCheck(this, Plugin8);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Plugin8, [].concat(args));
    _this2.name = "canvas-path-generator";
    return _this2;
  }
  _inherits(Plugin8, _AbstractRendererPlug);
  return _createClass(Plugin8, [{
    key: "init",
    value: function init() {
      var _pathGeneratorFactory;
      var pathGeneratorFactory = (_pathGeneratorFactory = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_pathGeneratorFactory, Shape.CIRCLE, generatePath$6), Shape.ELLIPSE, generatePath$5), Shape.RECT, generatePath), Shape.LINE, generatePath$4), Shape.POLYLINE, generatePath$1), Shape.POLYGON, generatePath$2), Shape.PATH, generatePath$3), Shape.TEXT, void 0), Shape.GROUP, void 0), Shape.IMAGE, void 0), _defineProperty(_defineProperty(_defineProperty(_pathGeneratorFactory, Shape.HTML, void 0), Shape.MESH, void 0), Shape.FRAGMENT, void 0));
      this.context.pathGeneratorFactory = pathGeneratorFactory;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      delete this.context.pathGeneratorFactory;
    }
  }]);
}(AbstractRendererPlugin);

// node_modules/@antv/g-plugin-canvas-picker/dist/index.esm.js
init_defineProperty();
var tmpVec3a = vec3_exports.create();
var tmpVec3b = vec3_exports.create();
var tmpVec3c = vec3_exports.create();
var tmpMat4 = mat4_exports.create();
var CanvasPickerPlugin = function() {
  function CanvasPickerPlugin2() {
    var _this2 = this;
    _classCallCheck(this, CanvasPickerPlugin2);
    this.isHit = function(displayObject, position, worldTransform, isClipPath) {
      var pick = _this2.context.pointInPathPickerFactory[displayObject.nodeName];
      if (pick) {
        var invertWorldMat = mat4_exports.invert(tmpMat4, worldTransform);
        var localPosition = vec3_exports.transformMat4(tmpVec3b, vec3_exports.set(tmpVec3c, position[0], position[1], 0), invertWorldMat);
        if (pick(displayObject, new Point(localPosition[0], localPosition[1]), isClipPath, _this2.isPointInPath, _this2.context, _this2.runtime)) {
          return true;
        }
      }
      return false;
    };
    this.isPointInPath = function(displayObject, position) {
      var context = _this2.runtime.offscreenCanvasCreator.getOrCreateContext(_this2.context.config.offscreenCanvas);
      var generatePath2 = _this2.context.pathGeneratorFactory[displayObject.nodeName];
      if (generatePath2) {
        context.beginPath();
        generatePath2(context, displayObject.parsedStyle);
        context.closePath();
      }
      return context.isPointInPath(position.x, position.y);
    };
  }
  return _createClass(CanvasPickerPlugin2, [{
    key: "apply",
    value: function apply(context, runtime2) {
      var _renderingContext$roo, _this2 = this;
      var renderingService = context.renderingService, renderingContext = context.renderingContext;
      this.context = context;
      this.runtime = runtime2;
      var document2 = (_renderingContext$roo = renderingContext.root) === null || _renderingContext$roo === void 0 ? void 0 : _renderingContext$roo.ownerDocument;
      renderingService.hooks.pick.tapPromise(CanvasPickerPlugin2.tag, function() {
        var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(result) {
          return _regeneratorRuntime().wrap(function(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", _this2.pick(document2, result));
              case 1:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        return function(_x) {
          return _ref.apply(this, arguments);
        };
      }());
      renderingService.hooks.pickSync.tap(CanvasPickerPlugin2.tag, function(result) {
        return _this2.pick(document2, result);
      });
    }
  }, {
    key: "pick",
    value: function pick(document2, result) {
      var topmost = result.topmost, _result$position = result.position, x3 = _result$position.x, y3 = _result$position.y;
      var position = vec3_exports.set(tmpVec3a, x3, y3, 0);
      var hitTestList = document2.elementsFromBBox(position[0], position[1], position[0], position[1]);
      var pickedDisplayObjects = [];
      var _iterator = _createForOfIteratorHelper(hitTestList), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _displayObject = _step.value;
          var worldTransform = _displayObject.getWorldTransform();
          var isHitOriginShape = this.isHit(_displayObject, position, worldTransform, false);
          if (isHitOriginShape) {
            var clipped = findClosestClipPathTarget(_displayObject);
            if (clipped) {
              var clipPath = clipped.parsedStyle.clipPath;
              var isHitClipPath = this.isHit(clipPath, position, clipPath.getWorldTransform(), true);
              if (isHitClipPath) {
                if (topmost) {
                  result.picked = [_displayObject];
                  return result;
                }
                pickedDisplayObjects.push(_displayObject);
              }
            } else {
              if (topmost) {
                result.picked = [_displayObject];
                return result;
              }
              pickedDisplayObjects.push(_displayObject);
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      result.picked = pickedDisplayObjects;
      return result;
    }
  }]);
}();
CanvasPickerPlugin.tag = "CanvasPicker";
function isPointInPath$8(displayObject, position, isClipPath) {
  var _ref = displayObject.parsedStyle, _ref$cx = _ref.cx, cx = _ref$cx === void 0 ? 0 : _ref$cx, _ref$cy = _ref.cy, cy = _ref$cy === void 0 ? 0 : _ref$cy, r = _ref.r, fill = _ref.fill, stroke = _ref.stroke, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
  var halfLineWidth = (lineWidth + increasedLineWidthForHitTesting) / 2;
  var absDistance = distance4(cx, cy, position.x, position.y);
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
  if (hasFill && hasStroke || isClipPath) {
    return absDistance <= r + halfLineWidth;
  }
  if (hasFill) {
    return absDistance <= r;
  }
  if (hasStroke) {
    return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;
  }
  return false;
}
function ellipseDistance(squareX, squareY, rx, ry) {
  return squareX / (rx * rx) + squareY / (ry * ry);
}
function isPointInPath$7(displayObject, position, isClipPath) {
  var _ref = displayObject.parsedStyle, _ref$cx = _ref.cx, cx = _ref$cx === void 0 ? 0 : _ref$cx, _ref$cy = _ref.cy, cy = _ref$cy === void 0 ? 0 : _ref$cy, rx = _ref.rx, ry = _ref.ry, fill = _ref.fill, stroke = _ref.stroke, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
  var x3 = position.x, y3 = position.y;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
  var halfLineWith = (lineWidth + increasedLineWidthForHitTesting) / 2;
  var squareX = (x3 - cx) * (x3 - cx);
  var squareY = (y3 - cy) * (y3 - cy);
  if (hasFill && hasStroke || isClipPath) {
    return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
  }
  if (hasFill) {
    return ellipseDistance(squareX, squareY, rx, ry) <= 1;
  }
  if (hasStroke) {
    return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
  }
  return false;
}
function inBox(minX, minY, width, height, x3, y3) {
  return x3 >= minX && x3 <= minX + width && y3 >= minY && y3 <= minY + height;
}
function inRect(minX, minY, width, height, lineWidth, x3, y3) {
  var halfWidth = lineWidth / 2;
  return inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x3, y3) || // 上边
  inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x3, y3) || // 右边
  inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x3, y3) || // 下边
  inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x3, y3);
}
function inArc(cx, cy, r, startAngle, endAngle, lineWidth, x3, y3) {
  var angle3 = (Math.atan2(y3 - cy, x3 - cx) + Math.PI * 2) % (Math.PI * 2);
  var point2 = {
    x: cx + r * Math.cos(angle3),
    y: cy + r * Math.sin(angle3)
  };
  return distance4(point2.x, point2.y, x3, y3) <= lineWidth / 2;
}
function inLine(x1, y1, x22, y22, lineWidth, x3, y3) {
  var minX = Math.min(x1, x22);
  var maxX = Math.max(x1, x22);
  var minY = Math.min(y1, y22);
  var maxY = Math.max(y1, y22);
  var halfWidth = lineWidth / 2;
  if (!(x3 >= minX - halfWidth && x3 <= maxX + halfWidth && y3 >= minY - halfWidth && y3 <= maxY + halfWidth)) {
    return false;
  }
  return pointToLine(x1, y1, x22, y22, x3, y3) <= lineWidth / 2;
}
function inPolyline(points, lineWidth, x3, y3, isClose) {
  var count = points.length;
  if (count < 2) {
    return false;
  }
  for (var i = 0; i < count - 1; i++) {
    var x1 = points[i][0];
    var y1 = points[i][1];
    var x22 = points[i + 1][0];
    var y22 = points[i + 1][1];
    if (inLine(x1, y1, x22, y22, lineWidth, x3, y3)) {
      return true;
    }
  }
  if (isClose) {
    var first = points[0];
    var last2 = points[count - 1];
    if (inLine(first[0], first[1], last2[0], last2[1], lineWidth, x3, y3)) {
      return true;
    }
  }
  return false;
}
var tolerance = 1e-6;
function dcmp(x3) {
  if (Math.abs(x3) < tolerance) {
    return 0;
  }
  return x3 < 0 ? -1 : 1;
}
function onSegment(p1, p2, q) {
  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
function inPolygon(points, x3, y3) {
  var isHit = false;
  var n = points.length;
  if (n <= 2) {
    return false;
  }
  for (var i = 0; i < n; i++) {
    var p1 = points[i];
    var p2 = points[(i + 1) % n];
    if (onSegment(p1, p2, [x3, y3])) {
      return true;
    }
    if (dcmp(p1[1] - y3) > 0 !== dcmp(p2[1] - y3) > 0 && dcmp(x3 - (y3 - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}
function inPolygons(polygons, x3, y3) {
  var isHit = false;
  for (var i = 0; i < polygons.length; i++) {
    var points = polygons[i];
    isHit = inPolygon(points, x3, y3);
    if (isHit) {
      break;
    }
  }
  return isHit;
}
function isPointInPath$6(displayObject, position, isClipPath) {
  var _ref = displayObject.parsedStyle, x1 = _ref.x1, y1 = _ref.y1, x22 = _ref.x2, y22 = _ref.y2, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents, fill = _ref.fill, stroke = _ref.stroke;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasStroke = _isFillOrStrokeAffect2[1];
  if (!hasStroke && !isClipPath || !lineWidth) {
    return false;
  }
  return inLine(x1, y1, x22, y22, lineWidth + increasedLineWidthForHitTesting, position.x, position.y);
}
function isPointInStroke2(segments, lineWidth, px2, py, length5) {
  var isHit = false;
  var halfWidth = lineWidth / 2;
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box2 = segment.box;
    if (box2 && !inBox(box2.x - halfWidth, box2.y - halfWidth, box2.width + lineWidth, box2.height + lineWidth, px2, py)) {
      continue;
    }
    switch (segment.command) {
      case "L":
      case "Z":
        isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, px2, py);
        if (isHit) {
          return true;
        }
        break;
      case "Q":
        var qDistance = pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], px2, py);
        isHit = qDistance <= lineWidth / 2;
        if (isHit) {
          return true;
        }
        break;
      case "C":
        var cDistance = pointDistance$3(
          prePoint[0],
          // 上一段结束位置, 即 C 的起始点
          prePoint[1],
          params[1],
          // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点
          params[2],
          params[3],
          params[4],
          params[5],
          params[6],
          px2,
          py,
          length5
        );
        isHit = cDistance <= lineWidth / 2;
        if (isHit) {
          return true;
        }
        break;
      case "A":
        if (!segment.cubicParams) {
          segment.cubicParams = arcToCubic(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6], params[7], void 0);
        }
        var args = segment.cubicParams;
        var prePointInCubic = prePoint;
        for (var _i = 0; _i < args.length; _i += 6) {
          var _cDistance = pointDistance$3(
            prePointInCubic[0],
            // 上一段结束位置, 即 C 的起始点
            prePointInCubic[1],
            args[_i],
            args[_i + 1],
            args[_i + 2],
            args[_i + 3],
            args[_i + 4],
            args[_i + 5],
            px2,
            py,
            length5
          );
          prePointInCubic = [args[_i + 4], args[_i + 5]];
          isHit = _cDistance <= lineWidth / 2;
          if (isHit) {
            return true;
          }
        }
        break;
    }
  }
  return isHit;
}
function isPointInPath$5(displayObject, position, isClipPath, isPointInPath2, renderingPluginContext, runtime2) {
  var _ref = displayObject.parsedStyle, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, stroke = _ref.stroke, fill = _ref.fill, d2 = _ref.d, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
  var segments = d2.segments, hasArc = d2.hasArc, polylines = d2.polylines, polygons = d2.polygons;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(
    pointerEvents,
    // Only a closed path can be filled.
    (polygons === null || polygons === void 0 ? void 0 : polygons.length) && fill,
    stroke
  ), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
  var totalLength = getOrCalculatePathTotalLength(displayObject);
  var isHit = false;
  if (hasFill || isClipPath) {
    if (hasArc) {
      isHit = isPointInPath2(displayObject, position);
    } else {
      isHit = inPolygons(polygons, position.x, position.y) || inPolygons(polylines, position.x, position.y);
    }
    return isHit;
  }
  if (hasStroke || isClipPath) {
    isHit = isPointInStroke2(segments, lineWidth + increasedLineWidthForHitTesting, position.x, position.y, totalLength);
  }
  return isHit;
}
function isPointInPath$4(displayObject, position, isClipPath) {
  var _ref = displayObject.parsedStyle, stroke = _ref.stroke, fill = _ref.fill, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, points = _ref.points, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
  var isHit = false;
  if (hasStroke || isClipPath) {
    isHit = inPolyline(points.points, lineWidth + increasedLineWidthForHitTesting, position.x, position.y, true);
  }
  if (!isHit && (hasFill || isClipPath)) {
    isHit = inPolygon(points.points, position.x, position.y);
  }
  return isHit;
}
function isPointInPath$3(displayObject, position, isClipPath) {
  var _ref = displayObject.parsedStyle, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, points = _ref.points, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents, fill = _ref.fill, stroke = _ref.stroke;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasStroke = _isFillOrStrokeAffect2[1];
  if (!hasStroke && !isClipPath || !lineWidth) {
    return false;
  }
  return inPolyline(points.points, lineWidth + increasedLineWidthForHitTesting, position.x, position.y, false);
}
function isPointInPath$2(displayObject, position, isClipPath, isPointInPath2, runtime2) {
  var _ref = displayObject.parsedStyle, radius = _ref.radius, fill = _ref.fill, stroke = _ref.stroke, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, _ref$x = _ref.x, x3 = _ref$x === void 0 ? 0 : _ref$x, _ref$y = _ref.y, y3 = _ref$y === void 0 ? 0 : _ref$y, width = _ref.width, height = _ref.height, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
  var hasRadius = radius && radius.some(function(r) {
    return r !== 0;
  });
  var lineWidthForHitTesting = lineWidth + increasedLineWidthForHitTesting;
  if (!hasRadius) {
    var halfWidth = lineWidthForHitTesting / 2;
    if (hasFill && hasStroke || isClipPath) {
      return inBox(x3 - halfWidth, y3 - halfWidth, width + halfWidth, height + halfWidth, position.x, position.y);
    }
    if (hasFill) {
      return inBox(x3, y3, width, height, position.x, position.y);
    }
    if (hasStroke) {
      return inRect(x3, y3, width, height, lineWidthForHitTesting, position.x, position.y);
    }
  } else {
    var isHit = false;
    if (hasStroke || isClipPath) {
      isHit = inRectWithRadius(x3, y3, width, height, radius.map(function(r) {
        return clamp_default(r, 0, Math.min(Math.abs(width) / 2, Math.abs(height) / 2));
      }), lineWidthForHitTesting, position.x, position.y);
    }
    if (!isHit && (hasFill || isClipPath)) {
      isHit = isPointInPath2(displayObject, position);
    }
    return isHit;
  }
  return false;
}
function inRectWithRadius(minX, minY, width, height, radiusArray, lineWidth, x3, y3) {
  var _radiusArray = _slicedToArray(radiusArray, 4), tlr = _radiusArray[0], trr = _radiusArray[1], brr = _radiusArray[2], blr = _radiusArray[3];
  return inLine(minX + tlr, minY, minX + width - trr, minY, lineWidth, x3, y3) || inLine(minX + width, minY + trr, minX + width, minY + height - brr, lineWidth, x3, y3) || inLine(minX + width - brr, minY + height, minX + blr, minY + height, lineWidth, x3, y3) || inLine(minX, minY + height - blr, minX, minY + tlr, lineWidth, x3, y3) || inArc(minX + width - trr, minY + trr, trr, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x3, y3) || inArc(minX + width - brr, minY + height - brr, brr, 0, 0.5 * Math.PI, lineWidth, x3, y3) || inArc(minX + blr, minY + height - blr, blr, 0.5 * Math.PI, Math.PI, lineWidth, x3, y3) || inArc(minX + tlr, minY + tlr, tlr, Math.PI, 1.5 * Math.PI, lineWidth, x3, y3);
}
function isPointInPath$1(displayObject, position, isClipPath, isPointInPath2, renderingPluginContext, runtime2) {
  var _ref = displayObject.parsedStyle, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents, _ref$x = _ref.x, x3 = _ref$x === void 0 ? 0 : _ref$x, _ref$y = _ref.y, y3 = _ref$y === void 0 ? 0 : _ref$y, width = _ref.width, height = _ref.height;
  if (pointerEvents === "non-transparent-pixel") {
    var offscreenCanvas = renderingPluginContext.config.offscreenCanvas;
    var canvas = runtime2.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
    var context = runtime2.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas, {
      willReadFrequently: true
    });
    canvas.width = width;
    canvas.height = height;
    renderingPluginContext.defaultStyleRendererFactory[Shape.IMAGE].render(context, _objectSpread2(_objectSpread2({}, displayObject.parsedStyle), {}, {
      x: 0,
      y: 0
    }), displayObject, void 0, void 0, void 0);
    var imagedata = context.getImageData(position.x - x3, position.y - y3, 1, 1).data;
    return imagedata.every(function(component) {
      return component !== 0;
    });
  }
  return true;
}
function isPointInPath(displayObject, position, isClipPath, isPointInPath2) {
  var bounds = displayObject.getGeometryBounds();
  return position.x >= bounds.min[0] && position.y >= bounds.min[1] && position.x <= bounds.max[0] && position.y <= bounds.max[1];
}
var Plugin2 = function(_AbstractRendererPlug) {
  function Plugin8() {
    var _this2;
    _classCallCheck(this, Plugin8);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Plugin8, [].concat(args));
    _this2.name = "canvas-picker";
    return _this2;
  }
  _inherits(Plugin8, _AbstractRendererPlug);
  return _createClass(Plugin8, [{
    key: "init",
    value: function init() {
      var _pointInPathPickerFac;
      var pointInPathPickerFactory = (_pointInPathPickerFac = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_pointInPathPickerFac, Shape.CIRCLE, isPointInPath$8), Shape.ELLIPSE, isPointInPath$7), Shape.RECT, isPointInPath$2), Shape.LINE, isPointInPath$6), Shape.POLYLINE, isPointInPath$3), Shape.POLYGON, isPointInPath$4), Shape.PATH, isPointInPath$5), Shape.TEXT, isPointInPath), Shape.GROUP, null), Shape.IMAGE, isPointInPath$1), _defineProperty(_defineProperty(_pointInPathPickerFac, Shape.HTML, null), Shape.MESH, null));
      this.context.pointInPathPickerFactory = pointInPathPickerFactory;
      this.addRenderingPlugin(new CanvasPickerPlugin());
    }
  }, {
    key: "destroy",
    value: function destroy() {
      delete this.context.pointInPathPickerFactory;
      this.removeAllRenderingPlugins();
    }
  }]);
}(AbstractRendererPlugin);

// node_modules/@antv/g-plugin-canvas-renderer/dist/index.esm.js
init_defineProperty();

// node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js
function _classPrivateFieldBase(e, t) {
  if (!{}.hasOwnProperty.call(e, t)) throw new TypeError("attempted to use private field on non-instance");
  return e;
}

// node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js
var id2 = 0;
function _classPrivateFieldKey(e) {
  return "__private_" + id2++ + "_" + e;
}

// node_modules/@antv/g-plugin-image-loader/dist/index.esm.js
var RefCountCache = function() {
  function RefCountCache2() {
    _classCallCheck(this, RefCountCache2);
    this.cacheStore = /* @__PURE__ */ new Map();
  }
  return _createClass(RefCountCache2, [{
    key: "onRefAdded",
    value: function onRefAdded2(ref) {
    }
  }, {
    key: "has",
    value: function has(key) {
      return this.cacheStore.has(key);
    }
  }, {
    key: "put",
    value: function put(key, item, ref) {
      if (this.cacheStore.has(key)) {
        return false;
      }
      this.cacheStore.set(key, {
        value: item,
        counter: /* @__PURE__ */ new Set([ref.entity])
      });
      this.onRefAdded(ref);
      return true;
    }
  }, {
    key: "get",
    value: function get(key, ref) {
      var cacheItem = this.cacheStore.get(key);
      if (!cacheItem) {
        return null;
      }
      if (!cacheItem.counter.has(ref.entity)) {
        cacheItem.counter.add(ref.entity);
        this.onRefAdded(ref);
      }
      return cacheItem.value;
    }
  }, {
    key: "update",
    value: function update2(key, value, ref) {
      var cacheItem = this.cacheStore.get(key);
      if (!cacheItem) {
        return false;
      }
      cacheItem.value = _objectSpread2(_objectSpread2({}, cacheItem.value), value);
      if (!cacheItem.counter.has(ref.entity)) {
        cacheItem.counter.add(ref.entity);
        this.onRefAdded(ref);
      }
      return true;
    }
  }, {
    key: "release",
    value: function release(key, ref) {
      var cacheItem = this.cacheStore.get(key);
      if (!cacheItem) {
        return false;
      }
      cacheItem.counter["delete"](ref.entity);
      if (cacheItem.counter.size <= 0) {
        this.cacheStore["delete"](key);
      }
      return true;
    }
  }, {
    key: "releaseRef",
    value: function releaseRef(ref) {
      var _this2 = this;
      Array.from(this.cacheStore.keys()).forEach(function(key) {
        _this2.release(key, ref);
      });
    }
  }, {
    key: "getSize",
    value: function getSize() {
      return this.cacheStore.size;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.cacheStore.clear();
    }
  }]);
}();
var tasks = [];
var nextFrameTasks = [];
var ImageSlicer = function() {
  function ImageSlicer2() {
    _classCallCheck(this, ImageSlicer2);
  }
  return _createClass(ImageSlicer2, null, [{
    key: "stop",
    value: function stop() {
      var api = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ImageSlicer2.api;
      if (ImageSlicer2.rafId) {
        api.cancelAnimationFrame(ImageSlicer2.rafId);
        ImageSlicer2.rafId = null;
      }
    }
  }, {
    key: "executeTask",
    value: function executeTask() {
      var api = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ImageSlicer2.api;
      if (tasks.length <= 0 && nextFrameTasks.length <= 0) {
        return;
      }
      nextFrameTasks.forEach(function(task) {
        return task();
      });
      nextFrameTasks = tasks.splice(0, ImageSlicer2.TASK_NUM_PER_FRAME);
      ImageSlicer2.rafId = api.requestAnimationFrame(function() {
        ImageSlicer2.executeTask(api);
      });
    }
  }, {
    key: "sliceImage",
    value: function sliceImage(image, sliceWidth, sliceHeight, rerender) {
      var overlap = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
      var api = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : ImageSlicer2.api;
      var imageWidth = image.naturalWidth || image.width;
      var imageHeight = image.naturalHeight || image.height;
      var strideW = sliceWidth - overlap;
      var strideH = sliceHeight - overlap;
      var gridCols = Math.ceil(imageWidth / strideW);
      var gridRows = Math.ceil(imageHeight / strideH);
      var result = {
        tileSize: [sliceWidth, sliceHeight],
        gridSize: [gridRows, gridCols],
        tiles: Array(gridRows).fill(null).map(function() {
          return Array(gridCols).fill(null);
        })
      };
      var _loop = function _loop2(row3) {
        var _loop22 = function _loop23(col2) {
          tasks.push(function() {
            var startX = col2 * strideW;
            var startY = row3 * strideH;
            var _ref = [Math.min(sliceWidth, imageWidth - startX), Math.min(sliceHeight, imageHeight - startY)], tempSliceWidth = _ref[0], tempSliceHeight = _ref[1];
            var sliceCanvas = api.createCanvas();
            sliceCanvas.width = sliceWidth;
            sliceCanvas.height = sliceHeight;
            var sliceCtx = sliceCanvas.getContext("2d");
            sliceCtx.drawImage(image, startX, startY, tempSliceWidth, tempSliceHeight, 0, 0, tempSliceWidth, tempSliceHeight);
            result.tiles[row3][col2] = {
              x: startX,
              y: startY,
              tileX: col2,
              tileY: row3,
              data: sliceCanvas
            };
            rerender();
          });
        };
        for (var col = 0; col < gridCols; col++) {
          _loop22(col);
        }
      };
      for (var row2 = 0; row2 < gridRows; row2++) {
        _loop(row2);
      }
      ImageSlicer2.stop();
      ImageSlicer2.executeTask();
      return result;
    }
  }]);
}();
ImageSlicer.TASK_NUM_PER_FRAME = 10;
var IMAGE_CACHE = new RefCountCache();
IMAGE_CACHE.onRefAdded = function onRefAdded(ref) {
  var _this2 = this;
  ref.addEventListener(ElementEvent.DESTROY, function() {
    _this2.releaseRef(ref);
  }, {
    once: true
  });
};
var ImagePool = function() {
  function ImagePool2(context, runtime2) {
    _classCallCheck(this, ImagePool2);
    this.gradientCache = {};
    this.patternCache = {};
    this.context = context;
    this.runtime = runtime2;
  }
  return _createClass(ImagePool2, [{
    key: "getImageSync",
    value: function getImageSync(src, ref, callback) {
      var imageSource = isString(src) ? src : src.src;
      if (IMAGE_CACHE.has(imageSource)) {
        var imageCache = IMAGE_CACHE.get(imageSource, ref);
        if (imageCache.img.complete) {
          callback === null || callback === void 0 || callback(imageCache);
          return imageCache;
        }
      }
      this.getOrCreateImage(src, ref).then(function(cache) {
        callback === null || callback === void 0 || callback(cache);
      })["catch"](function(reason) {
        console.error(reason);
      });
      return null;
    }
  }, {
    key: "getOrCreateImage",
    value: function getOrCreateImage(src, ref) {
      var _this2 = this;
      var imageSource = isString(src) ? src : src.src;
      if (!isString(src) && !IMAGE_CACHE.has(imageSource)) {
        var imageCache = {
          img: src,
          size: [src.naturalWidth || src.width, src.naturalHeight || src.height],
          tileSize: calculateImageTileSize(src)
        };
        IMAGE_CACHE.put(imageSource, imageCache, ref);
      }
      if (IMAGE_CACHE.has(imageSource)) {
        var _imageCache = IMAGE_CACHE.get(imageSource, ref);
        if (_imageCache.img.complete) {
          return Promise.resolve(_imageCache);
        }
        return new Promise(function(resolve, reject) {
          _imageCache.img.addEventListener("load", function() {
            _imageCache.size = [_imageCache.img.naturalWidth || _imageCache.img.width, _imageCache.img.naturalHeight || _imageCache.img.height];
            _imageCache.tileSize = calculateImageTileSize(_imageCache.img);
            resolve(_imageCache);
          });
          _imageCache.img.addEventListener("error", function(ev) {
            reject(ev);
          });
        });
      }
      return new Promise(function(resolve, reject) {
        var image = _this2.context.config.createImage();
        if (image) {
          var _imageCache2 = {
            img: image,
            size: [0, 0],
            tileSize: calculateImageTileSize(image)
          };
          IMAGE_CACHE.put(imageSource, _imageCache2, ref);
          image.onload = function() {
            _imageCache2.size = [image.naturalWidth || image.width, image.naturalHeight || image.height];
            _imageCache2.tileSize = calculateImageTileSize(_imageCache2.img);
            resolve(_imageCache2);
          };
          image.onerror = function(ev) {
            reject(ev);
          };
          image.crossOrigin = "Anonymous";
          image.src = imageSource;
        }
      });
    }
  }, {
    key: "createDownSampledImage",
    value: function() {
      var _createDownSampledImage = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(src, ref) {
        var imageCache, enableLargeImageOptimization, _ref, _ref$maxDownSampledIm, maxDownSampledImageSize, _ref$downSamplingRate, downSamplingRateThreshold, createImageBitmapFunc, _imageCache$size, originWidth, originHeight, resizedImage, downSamplingRate, updateCache;
        return _regeneratorRuntime().wrap(function(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 1;
              return this.getOrCreateImage(src, ref);
            case 1:
              imageCache = _context.sent;
              if (!(typeof imageCache.downSamplingRate !== "undefined")) {
                _context.next = 2;
                break;
              }
              return _context.abrupt("return", imageCache);
            case 2:
              enableLargeImageOptimization = this.context.config.enableLargeImageOptimization;
              _ref = typeof enableLargeImageOptimization === "boolean" ? {} : enableLargeImageOptimization, _ref$maxDownSampledIm = _ref.maxDownSampledImageSize, maxDownSampledImageSize = _ref$maxDownSampledIm === void 0 ? 2048 : _ref$maxDownSampledIm, _ref$downSamplingRate = _ref.downSamplingRateThreshold, downSamplingRateThreshold = _ref$downSamplingRate === void 0 ? 0.5 : _ref$downSamplingRate;
              createImageBitmapFunc = this.runtime.globalThis.createImageBitmap;
              _imageCache$size = _slicedToArray(imageCache.size, 2), originWidth = _imageCache$size[0], originHeight = _imageCache$size[1];
              resizedImage = imageCache.img;
              downSamplingRate = Math.min((maxDownSampledImageSize + maxDownSampledImageSize) / (originWidth + originHeight), Math.max(0.01, Math.min(downSamplingRateThreshold, 0.5)));
              updateCache = _objectSpread2(_objectSpread2({}, imageCache), {}, {
                downSamplingRate
              });
              IMAGE_CACHE.update(imageCache.img.src, updateCache, ref);
              if (!createImageBitmapFunc) {
                _context.next = 7;
                break;
              }
              _context.prev = 3;
              _context.next = 4;
              return createImageBitmapFunc(imageCache.img, {
                resizeWidth: originWidth * downSamplingRate,
                resizeHeight: originHeight * downSamplingRate
              });
            case 4:
              resizedImage = _context.sent;
              _context.next = 6;
              break;
            case 5:
              _context.prev = 5;
              _context["catch"](3);
              downSamplingRate = 1;
            case 6:
              _context.next = 8;
              break;
            case 7:
              downSamplingRate = 1;
            case 8:
              updateCache = _objectSpread2(_objectSpread2({}, this.getImageSync(src, ref)), {}, {
                downSampled: resizedImage,
                downSamplingRate
              });
              IMAGE_CACHE.update(imageCache.img.src, updateCache, ref);
              return _context.abrupt("return", updateCache);
            case 9:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[3, 5]]);
      }));
      function createDownSampledImage(_x, _x2) {
        return _createDownSampledImage.apply(this, arguments);
      }
      return createDownSampledImage;
    }()
  }, {
    key: "createImageTiles",
    value: function() {
      var _createImageTiles = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(src, tiles, rerender, ref) {
        var imageCache, _ref$ownerDocument$de, requestAnimationFrame2, cancelAnimationFrame2, updateCache;
        return _regeneratorRuntime().wrap(function(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 1;
              return this.getOrCreateImage(src, ref);
            case 1:
              imageCache = _context2.sent;
              _ref$ownerDocument$de = ref.ownerDocument.defaultView, requestAnimationFrame2 = _ref$ownerDocument$de.requestAnimationFrame, cancelAnimationFrame2 = _ref$ownerDocument$de.cancelAnimationFrame;
              ImageSlicer.api = {
                requestAnimationFrame: requestAnimationFrame2,
                cancelAnimationFrame: cancelAnimationFrame2,
                createCanvas: function createCanvas() {
                  return OffscreenCanvasCreator.createCanvas();
                }
              };
              updateCache = _objectSpread2(_objectSpread2({}, imageCache), ImageSlicer.sliceImage(imageCache.img, imageCache.tileSize[0], imageCache.tileSize[0], rerender));
              IMAGE_CACHE.update(imageCache.img.src, updateCache, ref);
              return _context2.abrupt("return", updateCache);
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function createImageTiles(_x3, _x4, _x5, _x6) {
        return _createImageTiles.apply(this, arguments);
      }
      return createImageTiles;
    }()
  }, {
    key: "releaseImage",
    value: function releaseImage(src, ref) {
      IMAGE_CACHE.release(isString(src) ? src : src.src, ref);
    }
  }, {
    key: "releaseImageRef",
    value: function releaseImageRef(ref) {
      IMAGE_CACHE.releaseRef(ref);
    }
  }, {
    key: "getOrCreatePatternSync",
    value: function getOrCreatePatternSync(object, pattern, context, $offscreenCanvas, dpr, min5, callback) {
      var patternKey = this.generatePatternKey(pattern);
      if (patternKey && this.patternCache[patternKey]) {
        return this.patternCache[patternKey];
      }
      var image = pattern.image, repetition = pattern.repetition, transform2 = pattern.transform;
      var src;
      var needScaleWithDPR = false;
      if (isString(image)) {
        var imageCache = this.getImageSync(image, object, callback);
        src = imageCache === null || imageCache === void 0 ? void 0 : imageCache.img;
      } else if ($offscreenCanvas) {
        src = $offscreenCanvas;
        needScaleWithDPR = true;
      } else {
        src = image;
      }
      var canvasPattern = src && context.createPattern(src, repetition);
      if (canvasPattern) {
        var mat;
        if (transform2) {
          mat = parsedTransformToMat4(parseTransform(transform2), new DisplayObject({}));
        } else {
          mat = mat4_exports.identity(mat4_exports.create());
        }
        if (needScaleWithDPR) {
          mat4_exports.scale(mat, mat, [1 / dpr, 1 / dpr, 1]);
        }
        canvasPattern.setTransform({
          a: mat[0],
          b: mat[1],
          c: mat[4],
          d: mat[5],
          e: mat[12] + min5[0],
          f: mat[13] + min5[1]
        });
      }
      if (patternKey && canvasPattern) {
        this.patternCache[patternKey] = canvasPattern;
      }
      return canvasPattern;
    }
  }, {
    key: "getOrCreateGradient",
    value: function getOrCreateGradient(params, context) {
      var key = this.generateGradientKey(params);
      var type = params.type, steps = params.steps, min5 = params.min, width = params.width, height = params.height, angle3 = params.angle, cx = params.cx, cy = params.cy, size2 = params.size;
      if (this.gradientCache[key]) {
        return this.gradientCache[key];
      }
      var gradient2 = null;
      if (type === GradientType.LinearGradient) {
        var _computeLinearGradien = computeLinearGradient(min5, width, height, angle3), x1 = _computeLinearGradien.x1, y1 = _computeLinearGradien.y1, x22 = _computeLinearGradien.x2, y22 = _computeLinearGradien.y2;
        gradient2 = context.createLinearGradient(x1, y1, x22, y22);
      } else if (type === GradientType.RadialGradient) {
        var _computeRadialGradien = computeRadialGradient(min5, width, height, cx, cy, size2), x3 = _computeRadialGradien.x, y3 = _computeRadialGradien.y, r = _computeRadialGradien.r;
        gradient2 = context.createRadialGradient(x3, y3, 0, x3, y3, r);
      }
      if (gradient2) {
        steps.forEach(function(_ref2) {
          var offset = _ref2.offset, color2 = _ref2.color;
          if (offset.unit === UnitType.kPercentage) {
            var _gradient;
            (_gradient = gradient2) === null || _gradient === void 0 || _gradient.addColorStop(offset.value / 100, color2.toString());
          }
        });
        this.gradientCache[key] = gradient2;
      }
      return this.gradientCache[key];
    }
  }, {
    key: "generateGradientKey",
    value: function generateGradientKey(params) {
      var type = params.type, min5 = params.min, width = params.width, height = params.height, steps = params.steps, angle3 = params.angle, cx = params.cx, cy = params.cy, size2 = params.size;
      return "gradient-".concat(type, "-").concat((angle3 === null || angle3 === void 0 ? void 0 : angle3.toString()) || 0, "-").concat((cx === null || cx === void 0 ? void 0 : cx.toString()) || 0, "-").concat((cy === null || cy === void 0 ? void 0 : cy.toString()) || 0, "-").concat((size2 === null || size2 === void 0 ? void 0 : size2.toString()) || 0, "-").concat(min5[0], "-").concat(min5[1], "-").concat(width, "-").concat(height, "-").concat(steps.map(function(_ref3) {
        var offset = _ref3.offset, color2 = _ref3.color;
        return "".concat(offset).concat(color2);
      }).join("-"));
    }
  }, {
    key: "generatePatternKey",
    value: function generatePatternKey(pattern) {
      var image = pattern.image, repetition = pattern.repetition;
      if (isString(image)) {
        return "pattern-".concat(image, "-").concat(repetition);
      }
      if (image.nodeName === "rect") {
        return "pattern-".concat(image.entity, "-").concat(repetition);
      }
    }
  }]);
}();
ImagePool.isSupportTile = !!OffscreenCanvasCreator.createCanvas();
function calculateImageTileSize(img) {
  if (!img.complete) {
    return [0, 0];
  }
  var width = img.naturalWidth || img.width, height = img.naturalHeight || img.height;
  var tileSize = 256;
  [256, 512].forEach(function(size2) {
    var rows = Math.ceil(height / size2);
    var cols = Math.ceil(width / size2);
    if (rows * cols < 1e3) {
      tileSize = size2;
    }
  });
  return [tileSize, tileSize];
}
var LoadImagePlugin = function() {
  function LoadImagePlugin2() {
    _classCallCheck(this, LoadImagePlugin2);
  }
  return _createClass(LoadImagePlugin2, [{
    key: "apply",
    value: function apply(context) {
      var renderingService = context.renderingService, renderingContext = context.renderingContext, imagePool = context.imagePool;
      var canvas = renderingContext.root.ownerDocument.defaultView;
      var calculateWithAspectRatio = function calculateWithAspectRatio2(object, imageWidth, imageHeight) {
        var _object$parsedStyle = object.parsedStyle, width = _object$parsedStyle.width, height = _object$parsedStyle.height;
        if (width && !height) {
          object.setAttribute("height", imageHeight / imageWidth * width);
        } else if (!width && height) {
          object.setAttribute("width", imageWidth / imageHeight * height);
        }
      };
      var handleMounted = function handleMounted2(e) {
        var object = e.target;
        var nodeName = object.nodeName, attributes = object.attributes;
        if (nodeName === Shape.IMAGE) {
          var src = attributes.src, keepAspectRatio = attributes.keepAspectRatio;
          imagePool.getImageSync(src, object, function(_ref) {
            var _ref$img = _ref.img, width = _ref$img.width, height = _ref$img.height;
            if (keepAspectRatio) {
              calculateWithAspectRatio(object, width, height);
            }
            object.renderable.dirty = true;
            renderingService.dirtify();
          });
        }
      };
      var handleAttributeChanged = function handleAttributeChanged2(e) {
        var object = e.target;
        var attrName = e.attrName, prevValue = e.prevValue, newValue = e.newValue;
        if (object.nodeName !== Shape.IMAGE || attrName !== "src") {
          return;
        }
        if (prevValue !== newValue) {
          imagePool.releaseImage(prevValue, object);
        }
        if (isString(newValue)) {
          imagePool.getOrCreateImage(newValue, object).then(function(_ref2) {
            var _ref2$img = _ref2.img, width = _ref2$img.width, height = _ref2$img.height;
            if (object.attributes.keepAspectRatio) {
              calculateWithAspectRatio(object, width, height);
            }
            object.renderable.dirty = true;
            renderingService.dirtify();
          })["catch"](function() {
          });
        }
      };
      renderingService.hooks.init.tap(LoadImagePlugin2.tag, function() {
        canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
      });
      renderingService.hooks.destroy.tap(LoadImagePlugin2.tag, function() {
        canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
      });
    }
  }]);
}();
LoadImagePlugin.tag = "LoadImage";
var Plugin3 = function(_AbstractRendererPlug) {
  function Plugin8() {
    var _this2;
    _classCallCheck(this, Plugin8);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Plugin8, [].concat(args));
    _this2.name = "image-loader";
    return _this2;
  }
  _inherits(Plugin8, _AbstractRendererPlug);
  return _createClass(Plugin8, [{
    key: "init",
    value: function init(runtime2) {
      this.context.imagePool = new ImagePool(this.context, runtime2);
      this.addRenderingPlugin(new LoadImagePlugin());
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.removeAllRenderingPlugins();
    }
  }]);
}(AbstractRendererPlugin);

// node_modules/@antv/g-plugin-canvas-renderer/dist/index.esm.js
var _renderState = _classPrivateFieldKey("renderState");
var CanvasRendererPlugin = function() {
  function CanvasRendererPlugin2(canvasRendererPluginOptions) {
    _classCallCheck(this, CanvasRendererPlugin2);
    this.removedRBushNodeAABBs = [];
    this.renderQueue = [];
    Object.defineProperty(this, _renderState, {
      writable: true,
      value: {
        restoreStack: [],
        prevObject: null,
        currentContext: /* @__PURE__ */ new Map()
      }
    });
    this.clearFullScreenLastFrame = false;
    this.clearFullScreen = false;
    this.vpMatrix = mat4_exports.create();
    this.dprMatrix = mat4_exports.create();
    this.tmpMat4 = mat4_exports.create();
    this.vec3a = vec3_exports.create();
    this.vec3b = vec3_exports.create();
    this.vec3c = vec3_exports.create();
    this.vec3d = vec3_exports.create();
    this.canvasRendererPluginOptions = canvasRendererPluginOptions;
  }
  return _createClass(CanvasRendererPlugin2, [{
    key: "apply",
    value: function apply(context, runtime2) {
      var _this2 = this;
      this.context = context;
      var _this$context = this.context, config = _this$context.config, camera = _this$context.camera, renderingService = _this$context.renderingService, renderingContext = _this$context.renderingContext, rBushRoot = _this$context.rBushRoot, pathGeneratorFactory = _this$context.pathGeneratorFactory;
      var enableRenderingOptimization = config.renderer.getConfig().enableRenderingOptimization;
      config.renderer.getConfig().enableDirtyCheck = false;
      config.renderer.getConfig().enableDirtyRectangleRendering = false;
      this.rBush = rBushRoot;
      this.pathGeneratorFactory = pathGeneratorFactory;
      var contextService = context.contextService;
      var canvas = renderingContext.root.ownerDocument.defaultView;
      var handleUnmounted = function handleUnmounted2(e) {
        var object = e.target;
        var rBushNode = object.rBushNode;
        if (rBushNode !== null && rBushNode !== void 0 && rBushNode.aabb) {
          _this2.removedRBushNodeAABBs.push(rBushNode.aabb);
        }
      };
      var handleCulled = function handleCulled2(e) {
        var object = e.target;
        var rBushNode = object.rBushNode;
        if (rBushNode.aabb) {
          _this2.removedRBushNodeAABBs.push(rBushNode.aabb);
        }
      };
      renderingService.hooks.init.tap(CanvasRendererPlugin2.tag, function() {
        canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.addEventListener(ElementEvent.CULLED, handleCulled);
        var dpr = contextService.getDPR();
        var width = config.width, height = config.height;
        var context2 = contextService.getContext();
        _this2.clearRect(context2, 0, 0, width * dpr, height * dpr, config.background);
      });
      renderingService.hooks.destroy.tap(CanvasRendererPlugin2.tag, function() {
        canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.removeEventListener(ElementEvent.CULLED, handleCulled);
        _this2.renderQueue = [];
        _this2.removedRBushNodeAABBs = [];
        _classPrivateFieldBase(_this2, _renderState)[_renderState] = {
          restoreStack: [],
          prevObject: null,
          currentContext: null
        };
      });
      var beforeDraw = function beforeDraw2() {
        var _canvas$context$rende;
        var context2 = contextService.getContext();
        var dpr = contextService.getDPR();
        var width = config.width, height = config.height;
        var _this$canvasRendererP = _this2.canvasRendererPluginOptions, dirtyObjectNumThreshold = _this$canvasRendererP.dirtyObjectNumThreshold, dirtyObjectRatioThreshold = _this$canvasRendererP.dirtyObjectRatioThreshold;
        var _renderingService$get = renderingService.getStats(), total = _renderingService$get.total, rendered = _renderingService$get.rendered;
        var ratio = rendered / total;
        _this2.clearFullScreen = _this2.clearFullScreenLastFrame || // @ts-ignore
        !((_canvas$context$rende = canvas.context.renderingPlugins[1]) !== null && _canvas$context$rende !== void 0 && _canvas$context$rende.isFirstTimeRenderingFinished) || renderingService.disableDirtyRectangleRendering() || rendered > dirtyObjectNumThreshold && ratio > dirtyObjectRatioThreshold;
        if (!context2) {
          return;
        }
        if (typeof context2.resetTransform === "function") {
          context2.resetTransform();
        } else {
          context2.setTransform(1, 0, 0, 1, 0, 0);
        }
        if (_this2.clearFullScreen) {
          _this2.clearRect(context2, 0, 0, width * dpr, height * dpr, config.background);
        }
      };
      var renderByZIndex = function renderByZIndex2(object, context2) {
        var stack = [object];
        while (stack.length > 0) {
          var _currentObject$sortab;
          var currentObject = stack.pop();
          if (currentObject.isVisible() && !currentObject.isCulled()) {
            if (enableRenderingOptimization) {
              _this2.renderDisplayObjectOptimized(currentObject, context2, _this2.context, _classPrivateFieldBase(_this2, _renderState)[_renderState], runtime2);
            } else {
              _this2.renderDisplayObject(currentObject, context2, _this2.context, _classPrivateFieldBase(_this2, _renderState)[_renderState], runtime2);
            }
          }
          var objects = ((_currentObject$sortab = currentObject.sortable) === null || _currentObject$sortab === void 0 || (_currentObject$sortab = _currentObject$sortab.sorted) === null || _currentObject$sortab === void 0 ? void 0 : _currentObject$sortab.length) > 0 ? currentObject.sortable.sorted : currentObject.childNodes;
          for (var i = objects.length - 1; i >= 0; i--) {
            stack.push(objects[i]);
          }
        }
      };
      renderingService.hooks.endFrame.tap(CanvasRendererPlugin2.tag, function() {
        beforeDraw();
        if (renderingContext.root.childNodes.length === 0) {
          _this2.clearFullScreenLastFrame = true;
          return;
        }
        enableRenderingOptimization = config.renderer.getConfig().enableRenderingOptimization;
        _classPrivateFieldBase(_this2, _renderState)[_renderState] = {
          restoreStack: [],
          prevObject: null,
          currentContext: _classPrivateFieldBase(_this2, _renderState)[_renderState].currentContext
        };
        _classPrivateFieldBase(_this2, _renderState)[_renderState].currentContext.clear();
        _this2.clearFullScreenLastFrame = false;
        var context2 = contextService.getContext();
        var dpr = contextService.getDPR();
        mat4_exports.fromScaling(_this2.dprMatrix, [dpr, dpr, 1]);
        mat4_exports.multiply(_this2.vpMatrix, _this2.dprMatrix, camera.getOrthoMatrix());
        if (_this2.clearFullScreen) {
          if (enableRenderingOptimization) {
            context2.save();
            renderByZIndex(renderingContext.root, context2);
            context2.restore();
          } else {
            renderByZIndex(renderingContext.root, context2);
          }
          _this2.removedRBushNodeAABBs = [];
        } else {
          var dirtyRenderBounds = _this2.safeMergeAABB.apply(_this2, [_this2.mergeDirtyAABBs(_this2.renderQueue)].concat(_toConsumableArray(_this2.removedRBushNodeAABBs.map(function(_ref) {
            var minX = _ref.minX, minY = _ref.minY, maxX = _ref.maxX, maxY = _ref.maxY;
            var aabb = new AABB();
            aabb.setMinMax(
              // vec3.fromValues(minX, minY, 0),
              // vec3.fromValues(maxX, maxY, 0),
              [minX, minY, 0],
              [maxX, maxY, 0]
            );
            return aabb;
          }))));
          _this2.removedRBushNodeAABBs = [];
          if (AABB.isEmpty(dirtyRenderBounds)) {
            _this2.renderQueue = [];
            return;
          }
          var dirtyRect = _this2.convertAABB2Rect(dirtyRenderBounds);
          var x3 = dirtyRect.x, y3 = dirtyRect.y, width = dirtyRect.width, height = dirtyRect.height;
          var tl = vec3_exports.transformMat4(_this2.vec3a, [x3, y3, 0], _this2.vpMatrix);
          var tr = vec3_exports.transformMat4(_this2.vec3b, [x3 + width, y3, 0], _this2.vpMatrix);
          var bl = vec3_exports.transformMat4(_this2.vec3c, [x3, y3 + height, 0], _this2.vpMatrix);
          var br = vec3_exports.transformMat4(_this2.vec3d, [x3 + width, y3 + height, 0], _this2.vpMatrix);
          var minx = Math.min(tl[0], tr[0], br[0], bl[0]);
          var miny = Math.min(tl[1], tr[1], br[1], bl[1]);
          var maxx = Math.max(tl[0], tr[0], br[0], bl[0]);
          var maxy = Math.max(tl[1], tr[1], br[1], bl[1]);
          var ix = Math.floor(minx);
          var iy = Math.floor(miny);
          var iwidth = Math.ceil(maxx - minx);
          var iheight = Math.ceil(maxy - miny);
          context2.save();
          _this2.clearRect(context2, ix, iy, iwidth, iheight, config.background);
          context2.beginPath();
          context2.rect(ix, iy, iwidth, iheight);
          context2.clip();
          context2.setTransform(_this2.vpMatrix[0], _this2.vpMatrix[1], _this2.vpMatrix[4], _this2.vpMatrix[5], _this2.vpMatrix[12], _this2.vpMatrix[13]);
          var _config$renderer$getC = config.renderer.getConfig(), enableDirtyRectangleRenderingDebug = _config$renderer$getC.enableDirtyRectangleRenderingDebug;
          if (enableDirtyRectangleRenderingDebug) {
            canvas.dispatchEvent(new CustomEvent(CanvasEvent.DIRTY_RECTANGLE, {
              dirtyRect: {
                x: ix,
                y: iy,
                width: iwidth,
                height: iheight
              }
            }));
          }
          var dirtyObjects = _this2.searchDirtyObjects(dirtyRenderBounds);
          dirtyObjects.sort(function(a2, b) {
            return a2.sortable.renderOrder - b.sortable.renderOrder;
          }).forEach(function(object) {
            if (object && object.isVisible() && !object.isCulled()) {
              _this2.renderDisplayObject(object, context2, _this2.context, _classPrivateFieldBase(_this2, _renderState)[_renderState], runtime2);
            }
          });
          context2.restore();
          _this2.renderQueue.forEach(function(object) {
            _this2.saveDirtyAABB(object);
          });
          _this2.renderQueue = [];
        }
        _classPrivateFieldBase(_this2, _renderState)[_renderState].restoreStack.forEach(function() {
          context2.restore();
        });
        _classPrivateFieldBase(_this2, _renderState)[_renderState].restoreStack = [];
      });
      renderingService.hooks.render.tap(CanvasRendererPlugin2.tag, function(object) {
        if (!_this2.clearFullScreen) {
          _this2.renderQueue.push(object);
        }
      });
    }
  }, {
    key: "clearRect",
    value: function clearRect(context, x3, y3, width, height, background) {
      context.clearRect(x3, y3, width, height);
      if (background) {
        context.fillStyle = background;
        context.fillRect(x3, y3, width, height);
      }
    }
  }, {
    key: "renderDisplayObjectOptimized",
    value: function renderDisplayObjectOptimized(object, context, canvasContext, renderState, runtime2) {
      var nodeName = object.nodeName;
      var updateTransform = false;
      var clipDraw = false;
      var styleRenderer = this.context.styleRendererFactory[nodeName];
      var generatePath2 = this.pathGeneratorFactory[nodeName];
      var clipPath = object.parsedStyle.clipPath;
      if (clipPath) {
        updateTransform = !renderState.prevObject || !mat4_exports.exactEquals(clipPath.getWorldTransform(), renderState.prevObject.getWorldTransform());
        if (updateTransform) {
          this.applyWorldTransform(context, clipPath);
          renderState.prevObject = null;
        }
        var _generatePath = this.pathGeneratorFactory[clipPath.nodeName];
        if (_generatePath) {
          context.save();
          clipDraw = true;
          context.beginPath();
          _generatePath(context, clipPath.parsedStyle);
          context.closePath();
          context.clip();
        }
      }
      if (styleRenderer) {
        updateTransform = !renderState.prevObject || !mat4_exports.exactEquals(object.getWorldTransform(), renderState.prevObject.getWorldTransform());
        if (updateTransform) {
          this.applyWorldTransform(context, object);
        }
        var forceUpdateStyle = !renderState.prevObject;
        if (!forceUpdateStyle) {
          var prevNodeName = renderState.prevObject.nodeName;
          if (nodeName === Shape.TEXT) {
            forceUpdateStyle = prevNodeName !== Shape.TEXT;
          } else if (nodeName === Shape.IMAGE) {
            forceUpdateStyle = prevNodeName !== Shape.IMAGE;
          } else {
            forceUpdateStyle = prevNodeName === Shape.TEXT || prevNodeName === Shape.IMAGE;
          }
        }
        styleRenderer.applyStyleToContext(context, object, forceUpdateStyle, renderState);
        renderState.prevObject = object;
      }
      if (generatePath2) {
        context.beginPath();
        generatePath2(context, object.parsedStyle);
        if (nodeName !== Shape.LINE && nodeName !== Shape.PATH && nodeName !== Shape.POLYLINE) {
          context.closePath();
        }
      }
      if (styleRenderer) {
        styleRenderer.drawToContext(context, object, _classPrivateFieldBase(this, _renderState)[_renderState], this, runtime2);
      }
      if (clipDraw) {
        context.restore();
      }
      object.dirty(false);
    }
  }, {
    key: "renderDisplayObject",
    value: function renderDisplayObject(object, context, canvasContext, renderState, runtime2) {
      var nodeName = object.nodeName;
      var parent = renderState.restoreStack[renderState.restoreStack.length - 1];
      if (parent && !(object.compareDocumentPosition(parent) & Node.DOCUMENT_POSITION_CONTAINS)) {
        context.restore();
        renderState.restoreStack.pop();
      }
      var styleRenderer = this.context.styleRendererFactory[nodeName];
      var generatePath2 = this.pathGeneratorFactory[nodeName];
      var clipPath = object.parsedStyle.clipPath;
      if (clipPath) {
        this.applyWorldTransform(context, clipPath);
        var _generatePath2 = this.pathGeneratorFactory[clipPath.nodeName];
        if (_generatePath2) {
          context.save();
          renderState.restoreStack.push(object);
          context.beginPath();
          _generatePath2(context, clipPath.parsedStyle);
          context.closePath();
          context.clip();
        }
      }
      if (styleRenderer) {
        this.applyWorldTransform(context, object);
        context.save();
        this.applyAttributesToContext(context, object);
      }
      if (generatePath2) {
        context.beginPath();
        generatePath2(context, object.parsedStyle);
        if (nodeName !== Shape.LINE && nodeName !== Shape.PATH && nodeName !== Shape.POLYLINE) {
          context.closePath();
        }
      }
      if (styleRenderer) {
        styleRenderer.render(context, object.parsedStyle, object, canvasContext, this, runtime2);
        context.restore();
      }
      object.dirty(false);
    }
  }, {
    key: "applyAttributesToContext",
    value: function applyAttributesToContext(context, object) {
      var _ref2 = object.parsedStyle, stroke = _ref2.stroke, fill = _ref2.fill, opacity = _ref2.opacity, lineDash = _ref2.lineDash, lineDashOffset = _ref2.lineDashOffset;
      if (lineDash) {
        context.setLineDash(lineDash);
      }
      if (!isNil(lineDashOffset)) {
        context.lineDashOffset = lineDashOffset;
      }
      if (!isNil(opacity)) {
        context.globalAlpha *= opacity;
      }
      if (!isNil(stroke) && !Array.isArray(stroke) && !stroke.isNone) {
        context.strokeStyle = object.attributes.stroke;
      }
      if (!isNil(fill) && !Array.isArray(fill) && !fill.isNone) {
        context.fillStyle = object.attributes.fill;
      }
    }
  }, {
    key: "convertAABB2Rect",
    value: function convertAABB2Rect(aabb) {
      var min5 = aabb.getMin();
      var max6 = aabb.getMax();
      var minX = Math.floor(min5[0]);
      var minY = Math.floor(min5[1]);
      var maxX = Math.ceil(max6[0]);
      var maxY = Math.ceil(max6[1]);
      var width = maxX - minX;
      var height = maxY - minY;
      return {
        x: minX,
        y: minY,
        width,
        height
      };
    }
    /**
     * TODO: merge dirty rectangles with some strategies.
     * For now, we just simply merge all the rectangles into one.
     * @see https://idom.me/articles/841.html
     */
  }, {
    key: "mergeDirtyAABBs",
    value: function mergeDirtyAABBs(dirtyObjects) {
      var aabb = new AABB();
      dirtyObjects.forEach(function(object) {
        var renderBounds = object.getRenderBounds();
        aabb.add(renderBounds);
        var dirtyRenderBounds = object.renderable.dirtyRenderBounds;
        if (dirtyRenderBounds) {
          aabb.add(dirtyRenderBounds);
        }
      });
      return aabb;
    }
  }, {
    key: "searchDirtyObjects",
    value: function searchDirtyObjects(dirtyRectangle) {
      var _dirtyRectangle$getMi = dirtyRectangle.getMin(), _dirtyRectangle$getMi2 = _slicedToArray(_dirtyRectangle$getMi, 2), minX = _dirtyRectangle$getMi2[0], minY = _dirtyRectangle$getMi2[1];
      var _dirtyRectangle$getMa = dirtyRectangle.getMax(), _dirtyRectangle$getMa2 = _slicedToArray(_dirtyRectangle$getMa, 2), maxX = _dirtyRectangle$getMa2[0], maxY = _dirtyRectangle$getMa2[1];
      var rBushNodes = this.rBush.search({
        minX,
        minY,
        maxX,
        maxY
      });
      return rBushNodes.map(function(_ref3) {
        var displayObject = _ref3.displayObject;
        return displayObject;
      });
    }
  }, {
    key: "saveDirtyAABB",
    value: function saveDirtyAABB(object) {
      var renderable = object.renderable;
      if (!renderable.dirtyRenderBounds) {
        renderable.dirtyRenderBounds = new AABB();
      }
      var renderBounds = object.getRenderBounds();
      if (renderBounds) {
        renderable.dirtyRenderBounds.update(renderBounds.center, renderBounds.halfExtents);
      }
    }
  }, {
    key: "applyWorldTransform",
    value: function applyWorldTransform(context, object, matrix2) {
      if (matrix2) {
        mat4_exports.copy(this.tmpMat4, object.getLocalTransform());
        mat4_exports.multiply(this.tmpMat4, matrix2, this.tmpMat4);
        mat4_exports.multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);
      } else {
        mat4_exports.copy(this.tmpMat4, object.getWorldTransform());
        mat4_exports.multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);
      }
      context.setTransform(this.tmpMat4[0], this.tmpMat4[1], this.tmpMat4[4], this.tmpMat4[5], this.tmpMat4[12], this.tmpMat4[13]);
    }
  }, {
    key: "safeMergeAABB",
    value: function safeMergeAABB() {
      var merged = new AABB();
      for (var _len = arguments.length, aabbs = new Array(_len), _key = 0; _key < _len; _key++) {
        aabbs[_key] = arguments[_key];
      }
      aabbs.forEach(function(aabb) {
        merged.add(aabb);
      });
      return merged;
    }
  }]);
}();
CanvasRendererPlugin.tag = "CanvasRenderer";
function getPattern(pattern, object, context, canvasContext, plugin, runtime2, imagePool) {
  var $offscreenCanvas;
  var dpr;
  if (pattern.image.nodeName === "rect") {
    var _parsedStyle = pattern.image.parsedStyle, width = _parsedStyle.width, height = _parsedStyle.height;
    dpr = canvasContext.contextService.getDPR();
    var offscreenCanvas = canvasContext.config.offscreenCanvas;
    $offscreenCanvas = runtime2.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
    $offscreenCanvas.width = width * dpr;
    $offscreenCanvas.height = height * dpr;
    var offscreenCanvasContext = runtime2.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
    var renderState = {
      restoreStack: [],
      prevObject: null,
      currentContext: /* @__PURE__ */ new Map()
    };
    pattern.image.forEach(function(object2) {
      plugin.renderDisplayObject(object2, offscreenCanvasContext, canvasContext, renderState, runtime2);
    });
    renderState.restoreStack.forEach(function() {
      offscreenCanvasContext.restore();
    });
  }
  var canvasPattern = imagePool.getOrCreatePatternSync(object, pattern, context, $offscreenCanvas, dpr, object.getGeometryBounds().min, function() {
    object.dirty();
    canvasContext.renderingService.dirtify();
  });
  return canvasPattern;
}
function getColor(parsedColor, object, context, imagePool) {
  var color2;
  if (parsedColor.type === GradientType.LinearGradient || parsedColor.type === GradientType.RadialGradient) {
    var bounds = object.getGeometryBounds();
    var width = bounds && bounds.halfExtents[0] * 2 || 1;
    var height = bounds && bounds.halfExtents[1] * 2 || 1;
    var min5 = bounds && bounds.min || [0, 0];
    color2 = imagePool.getOrCreateGradient(_objectSpread2(_objectSpread2({
      type: parsedColor.type
    }, parsedColor.value), {}, {
      min: min5,
      width,
      height
    }), context);
  }
  return color2;
}
var SHADOW_NUMBER_STYLE = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"];
var STROKE_STYLE = ["lineCap", "lineJoin", "miterLimit"];
var DEFAULT_STYLE = {
  // common
  globalAlpha: 1,
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  filter: "none",
  globalCompositeOperation: "source-over",
  // stroke/fill
  strokeStyle: "#000",
  strokeOpacity: 1,
  lineWidth: 1,
  lineDash: [],
  lineDashOffset: 0,
  lineCap: "butt",
  lineJoin: "miter",
  miterLimit: 10,
  fillStyle: "#000",
  fillOpacity: 1
  // image
};
var defaultParsedStyle = {};
function updateContextIfNotHitCache(context, key, value, cache) {
  var prevValue = cache.has(key) ? cache.get(key) : DEFAULT_STYLE[key];
  if (prevValue !== value) {
    if (key === "lineDash") {
      context.setLineDash(value);
    } else {
      context[key] = value;
    }
    cache.set(key, value);
  }
  return prevValue;
}
var OptimizedDefaultRenderer = function() {
  function OptimizedDefaultRenderer2(imagePool) {
    _classCallCheck(this, OptimizedDefaultRenderer2);
    this.imagePool = imagePool;
  }
  return _createClass(OptimizedDefaultRenderer2, [{
    key: "applyAttributesToContext",
    value: function applyAttributesToContext(context, object) {
    }
  }, {
    key: "render",
    value: function render(context, parsedStyle, object, canvasContext, plugin, runtime2) {
    }
    // #region common style
  }, {
    key: "applyCommonStyleToContext",
    value: function applyCommonStyleToContext(context, object, forceUpdate, renderState) {
      var prevStyle = forceUpdate ? defaultParsedStyle : renderState.prevObject.parsedStyle;
      var style = object.parsedStyle;
      if (forceUpdate || style.opacity !== prevStyle.opacity) {
        updateContextIfNotHitCache(context, "globalAlpha", !isNil(style.opacity) ? style.opacity : DEFAULT_STYLE.globalAlpha, renderState.currentContext);
      }
      if (forceUpdate || style.blend !== prevStyle.blend) {
        updateContextIfNotHitCache(
          context,
          "globalCompositeOperation",
          // @ts-ignore
          !isNil(style.blend) ? (
            // @ts-ignore
            style.blend
          ) : DEFAULT_STYLE.globalCompositeOperation,
          renderState.currentContext
        );
      }
    }
    // #endregion common style
    // #region stroke/fill style
  }, {
    key: "applyStrokeFillStyleToContext",
    value: function applyStrokeFillStyleToContext(context, object, forceUpdate, renderState) {
      var prevStyle = forceUpdate ? defaultParsedStyle : renderState.prevObject.parsedStyle;
      var style = object.parsedStyle;
      var _style$lineWidth = style.lineWidth, lineWidth = _style$lineWidth === void 0 ? DEFAULT_STYLE.lineWidth : _style$lineWidth;
      var hasFill = style.fill && !style.fill.isNone;
      var hasStroke = style.stroke && !style.stroke.isNone && lineWidth > 0;
      if (hasStroke) {
        if (forceUpdate || object.attributes.stroke !== renderState.prevObject.attributes.stroke) {
          var value = !isNil(style.stroke) && !Array.isArray(style.stroke) && !style.stroke.isNone ? object.attributes.stroke : DEFAULT_STYLE.strokeStyle;
          updateContextIfNotHitCache(context, "strokeStyle", value, renderState.currentContext);
        }
        if (forceUpdate || style.lineWidth !== prevStyle.lineWidth) {
          updateContextIfNotHitCache(context, "lineWidth", !isNil(style.lineWidth) ? style.lineWidth : DEFAULT_STYLE.lineWidth, renderState.currentContext);
        }
        if (forceUpdate || style.lineDash !== prevStyle.lineDash) {
          updateContextIfNotHitCache(context, "lineDash", style.lineDash || DEFAULT_STYLE.lineDash, renderState.currentContext);
        }
        if (forceUpdate || style.lineDashOffset !== prevStyle.lineDashOffset) {
          updateContextIfNotHitCache(context, "lineDashOffset", !isNil(style.lineDashOffset) ? style.lineDashOffset : DEFAULT_STYLE.lineDashOffset, renderState.currentContext);
        }
        for (var i = 0; i < STROKE_STYLE.length; i++) {
          var styleName = STROKE_STYLE[i];
          if (forceUpdate || style[styleName] !== prevStyle[styleName]) {
            updateContextIfNotHitCache(context, styleName, !isNil(style[styleName]) ? style[styleName] : DEFAULT_STYLE[styleName], renderState.currentContext);
          }
        }
      }
      if (hasFill && (forceUpdate || object.attributes.fill !== renderState.prevObject.attributes.fill)) {
        var _value = !isNil(style.fill) && !Array.isArray(style.fill) && !style.fill.isNone ? object.attributes.fill : DEFAULT_STYLE.fillStyle;
        updateContextIfNotHitCache(context, "fillStyle", _value, renderState.currentContext);
      }
    }
    // #endregion stroke/fill style
  }, {
    key: "applyStyleToContext",
    value: function applyStyleToContext(context, object, forceUpdate, renderState) {
      var nodeName = object.nodeName;
      this.applyCommonStyleToContext(context, object, forceUpdate, renderState);
      if (nodeName === Shape.IMAGE) ;
      else {
        this.applyStrokeFillStyleToContext(context, object, forceUpdate, renderState);
      }
    }
  }, {
    key: "applyShadowAndFilterStyleToContext",
    value: function applyShadowAndFilterStyleToContext(context, object, hasShadow, renderState) {
      var style = object.parsedStyle;
      if (hasShadow) {
        updateContextIfNotHitCache(context, "shadowColor", style.shadowColor.toString(), renderState.currentContext);
        for (var i = 0; i < SHADOW_NUMBER_STYLE.length; i++) {
          var styleName = SHADOW_NUMBER_STYLE[i];
          updateContextIfNotHitCache(context, styleName, style[styleName] || DEFAULT_STYLE[styleName], renderState.currentContext);
        }
      }
      if (style.filter && style.filter.length) {
        updateContextIfNotHitCache(
          context,
          "filter",
          // use raw filter string
          object.attributes.filter,
          renderState.currentContext
        );
      }
    }
  }, {
    key: "clearShadowAndFilterStyleForContext",
    value: function clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState) {
      var onlyClearShadowFilter = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      if (hasShadow) {
        updateContextIfNotHitCache(context, "shadowColor", DEFAULT_STYLE.shadowColor, renderState.currentContext);
        for (var i = 0; i < SHADOW_NUMBER_STYLE.length; i++) {
          var styleName = SHADOW_NUMBER_STYLE[i];
          updateContextIfNotHitCache(context, styleName, DEFAULT_STYLE[styleName], renderState.currentContext);
        }
      }
      if (hasFilter) {
        if (hasShadow && onlyClearShadowFilter) {
          var oldFilter = context.filter;
          if (!isNil(oldFilter) && oldFilter.indexOf("drop-shadow") > -1) {
            updateContextIfNotHitCache(context, "filter", oldFilter.replace(/drop-shadow\([^)]*\)/, "").trim() || DEFAULT_STYLE.filter, renderState.currentContext);
          }
        } else {
          updateContextIfNotHitCache(context, "filter", DEFAULT_STYLE.filter, renderState.currentContext);
        }
      }
    }
  }, {
    key: "fillToContext",
    value: function fillToContext(context, object, renderState, plugin, runtime2) {
      var _this2 = this;
      var _object$parsedStyle = object.parsedStyle, fill = _object$parsedStyle.fill, fillRule = _object$parsedStyle.fillRule;
      var resetStyle = null;
      if (Array.isArray(fill) && fill.length > 0) {
        fill.forEach(function(gradient2) {
          var prevStyle = updateContextIfNotHitCache(context, "fillStyle", getColor(gradient2, object, context, _this2.imagePool), renderState.currentContext);
          resetStyle = resetStyle !== null && resetStyle !== void 0 ? resetStyle : prevStyle;
          if (fillRule) {
            context.fill(fillRule);
          } else {
            context.fill();
          }
        });
      } else {
        if (isPattern(fill)) {
          var pattern = getPattern(fill, object, context, object.ownerDocument.defaultView.context, plugin, runtime2, this.imagePool);
          if (pattern) {
            context.fillStyle = pattern;
            resetStyle = true;
          }
        }
        if (fillRule) {
          context.fill(fillRule);
        } else {
          context.fill();
        }
      }
      if (resetStyle !== null) {
        updateContextIfNotHitCache(context, "fillStyle", resetStyle, renderState.currentContext);
      }
    }
  }, {
    key: "strokeToContext",
    value: function strokeToContext(context, object, renderState, plugin, runtime2) {
      var _this2 = this;
      var stroke = object.parsedStyle.stroke;
      var resetStyle = null;
      if (Array.isArray(stroke) && stroke.length > 0) {
        stroke.forEach(function(gradient2) {
          var prevStyle2 = updateContextIfNotHitCache(context, "strokeStyle", getColor(gradient2, object, context, _this2.imagePool), renderState.currentContext);
          resetStyle = resetStyle !== null && resetStyle !== void 0 ? resetStyle : prevStyle2;
          context.stroke();
        });
      } else {
        if (isPattern(stroke)) {
          var pattern = getPattern(stroke, object, context, object.ownerDocument.defaultView.context, plugin, runtime2, this.imagePool);
          if (pattern) {
            var prevStyle = updateContextIfNotHitCache(context, "strokeStyle", pattern, renderState.currentContext);
            resetStyle = resetStyle !== null && resetStyle !== void 0 ? resetStyle : prevStyle;
          }
        }
        context.stroke();
      }
      if (resetStyle !== null) {
        updateContextIfNotHitCache(context, "strokeStyle", resetStyle, renderState.currentContext);
      }
    }
  }, {
    key: "drawToContext",
    value: function drawToContext(context, object, renderState, plugin, runtime2) {
      var _style$fill;
      var nodeName = object.nodeName;
      var style = object.parsedStyle;
      var _style$opacity = style.opacity, opacity = _style$opacity === void 0 ? DEFAULT_STYLE.globalAlpha : _style$opacity, _style$fillOpacity = style.fillOpacity, fillOpacity = _style$fillOpacity === void 0 ? DEFAULT_STYLE.fillOpacity : _style$fillOpacity, _style$strokeOpacity = style.strokeOpacity, strokeOpacity = _style$strokeOpacity === void 0 ? DEFAULT_STYLE.strokeOpacity : _style$strokeOpacity, _style$lineWidth2 = style.lineWidth, lineWidth = _style$lineWidth2 === void 0 ? DEFAULT_STYLE.lineWidth : _style$lineWidth2;
      var hasFill = style.fill && !style.fill.isNone;
      var hasStroke = style.stroke && !style.stroke.isNone && lineWidth > 0;
      if (!hasFill && !hasStroke) {
        return;
      }
      var hasShadow = !isNil(style.shadowColor) && style.shadowBlur > 0;
      var isInnerShadow = style.shadowType === "inner";
      var isFillTransparent = ((_style$fill = style.fill) === null || _style$fill === void 0 ? void 0 : _style$fill.alpha) === 0;
      var hasFilter = !!(style.filter && style.filter.length);
      var shouldDrawShadowWithStroke = hasShadow && hasStroke && (nodeName === Shape.PATH || nodeName === Shape.LINE || nodeName === Shape.POLYLINE || isFillTransparent || isInnerShadow);
      var originGlobalAlpha = null;
      if (hasFill) {
        if (!shouldDrawShadowWithStroke) {
          this.applyShadowAndFilterStyleToContext(context, object, hasShadow, renderState);
        }
        var updateOpacity = opacity * fillOpacity;
        originGlobalAlpha = updateContextIfNotHitCache(context, "globalAlpha", updateOpacity, renderState.currentContext);
        this.fillToContext(context, object, renderState, plugin, runtime2);
        if (!shouldDrawShadowWithStroke) {
          this.clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState);
        }
      }
      if (hasStroke) {
        var clearShadowAndFilter = false;
        var _updateOpacity = opacity * strokeOpacity;
        var prevOpacity = updateContextIfNotHitCache(context, "globalAlpha", _updateOpacity, renderState.currentContext);
        originGlobalAlpha = hasFill ? originGlobalAlpha : prevOpacity;
        if (shouldDrawShadowWithStroke) {
          this.applyShadowAndFilterStyleToContext(context, object, hasShadow, renderState);
          clearShadowAndFilter = true;
          if (isInnerShadow) {
            var originBlend = context.globalCompositeOperation;
            context.globalCompositeOperation = "source-atop";
            this.strokeToContext(context, object, renderState, plugin, runtime2);
            context.globalCompositeOperation = originBlend;
            this.clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState, true);
          }
        }
        this.strokeToContext(context, object, renderState, plugin, runtime2);
        if (clearShadowAndFilter) {
          this.clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState);
        }
      }
      if (originGlobalAlpha !== null) {
        updateContextIfNotHitCache(context, "globalAlpha", originGlobalAlpha, renderState.currentContext);
      }
    }
  }]);
}();
var DefaultRenderer = function(_OptimizedDefaultRend) {
  function DefaultRenderer2() {
    _classCallCheck(this, DefaultRenderer2);
    return _callSuper(this, DefaultRenderer2, arguments);
  }
  _inherits(DefaultRenderer2, _OptimizedDefaultRend);
  return _createClass(DefaultRenderer2, [{
    key: "render",
    value: function render(context, parsedStyle, object, canvasContext, plugin, runtime2) {
      var fill = parsedStyle.fill, fillRule = parsedStyle.fillRule, _parsedStyle$opacity = parsedStyle.opacity, opacity = _parsedStyle$opacity === void 0 ? 1 : _parsedStyle$opacity, _parsedStyle$fillOpac = parsedStyle.fillOpacity, fillOpacity = _parsedStyle$fillOpac === void 0 ? 1 : _parsedStyle$fillOpac, stroke = parsedStyle.stroke, _parsedStyle$strokeOp = parsedStyle.strokeOpacity, strokeOpacity = _parsedStyle$strokeOp === void 0 ? 1 : _parsedStyle$strokeOp, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, lineCap = parsedStyle.lineCap, lineJoin = parsedStyle.lineJoin, shadowType = parsedStyle.shadowType, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur, filter2 = parsedStyle.filter, miterLimit = parsedStyle.miterLimit;
      var hasFill = fill && !fill.isNone;
      var hasStroke = stroke && !stroke.isNone && lineWidth > 0;
      var isFillTransparent = (fill === null || fill === void 0 ? void 0 : fill.alpha) === 0;
      var hasFilter = !!(filter2 && filter2.length);
      var hasShadow = !isNil(shadowColor) && shadowBlur > 0;
      var nodeName = object.nodeName;
      var isInnerShadow = shadowType === "inner";
      var shouldDrawShadowWithStroke = hasStroke && hasShadow && (nodeName === Shape.PATH || nodeName === Shape.LINE || nodeName === Shape.POLYLINE || isFillTransparent || isInnerShadow);
      if (hasFill) {
        context.globalAlpha = opacity * fillOpacity;
        if (!shouldDrawShadowWithStroke) {
          setShadowAndFilter(object, context, hasShadow);
        }
        applyFill(context, object, fill, fillRule, canvasContext, plugin, runtime2, this.imagePool);
        if (!shouldDrawShadowWithStroke) {
          this.clearShadowAndFilter(context, hasFilter, hasShadow);
        }
      }
      if (hasStroke) {
        context.globalAlpha = opacity * strokeOpacity;
        context.lineWidth = lineWidth;
        if (!isNil(miterLimit)) {
          context.miterLimit = miterLimit;
        }
        if (!isNil(lineCap)) {
          context.lineCap = lineCap;
        }
        if (!isNil(lineJoin)) {
          context.lineJoin = lineJoin;
        }
        if (shouldDrawShadowWithStroke) {
          if (isInnerShadow) {
            context.globalCompositeOperation = "source-atop";
          }
          setShadowAndFilter(object, context, true);
          if (isInnerShadow) {
            applyStroke(context, object, stroke, canvasContext, plugin, runtime2, this.imagePool);
            context.globalCompositeOperation = DEFAULT_STYLE.globalCompositeOperation;
            this.clearShadowAndFilter(context, hasFilter, true);
          }
        }
        applyStroke(context, object, stroke, canvasContext, plugin, runtime2, this.imagePool);
      }
    }
  }, {
    key: "clearShadowAndFilter",
    value: function clearShadowAndFilter(context, hasFilter, hasShadow) {
      if (hasShadow) {
        context.shadowColor = "transparent";
        context.shadowBlur = 0;
      }
      if (hasFilter) {
        var oldFilter = context.filter;
        if (!isNil(oldFilter) && oldFilter.indexOf("drop-shadow") > -1) {
          context.filter = oldFilter.replace(/drop-shadow\([^)]*\)/, "").trim() || "none";
        }
      }
    }
  }]);
}(OptimizedDefaultRenderer);
function setShadowAndFilter(object, context, hasShadow) {
  var _object$parsedStyle = object.parsedStyle, filter2 = _object$parsedStyle.filter, shadowColor = _object$parsedStyle.shadowColor, shadowBlur = _object$parsedStyle.shadowBlur, shadowOffsetX = _object$parsedStyle.shadowOffsetX, shadowOffsetY = _object$parsedStyle.shadowOffsetY;
  if (filter2 && filter2.length) {
    context.filter = object.style.filter;
  }
  if (hasShadow) {
    context.shadowColor = shadowColor.toString();
    context.shadowBlur = shadowBlur || 0;
    context.shadowOffsetX = shadowOffsetX || 0;
    context.shadowOffsetY = shadowOffsetY || 0;
  }
}
function applyFill(context, object, fill, fillRule, canvasContext, plugin, runtime2, imagePool) {
  var skipFill = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : false;
  if (Array.isArray(fill)) {
    fill.forEach(function(gradient2) {
      context.fillStyle = getColor(gradient2, object, context, imagePool);
      if (!skipFill) {
        fillRule ? context.fill(fillRule) : context.fill();
      }
    });
  } else {
    if (isPattern(fill)) {
      context.fillStyle = getPattern(fill, object, context, canvasContext, plugin, runtime2, imagePool);
    }
    if (!skipFill) {
      fillRule ? context.fill(fillRule) : context.fill();
    }
  }
}
function applyStroke(context, object, stroke, canvasContext, plugin, runtime2, imagePool) {
  var skipStroke = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
  if (Array.isArray(stroke)) {
    stroke.forEach(function(gradient2) {
      context.strokeStyle = getColor(gradient2, object, context, imagePool);
      if (!skipStroke) {
        context.stroke();
      }
    });
  } else {
    if (isPattern(stroke)) {
      context.strokeStyle = getPattern(stroke, object, context, canvasContext, plugin, runtime2, imagePool);
    }
    if (!skipStroke) {
      context.stroke();
    }
  }
}
function calculateOverlapRect(rect1, rect2) {
  var _rect = _slicedToArray(rect1, 4), x1 = _rect[0], y1 = _rect[1], w1 = _rect[2], h1 = _rect[3];
  var _rect2 = _slicedToArray(rect2, 4), x22 = _rect2[0], y22 = _rect2[1], w2 = _rect2[2], h2 = _rect2[3];
  var overlapLeft = Math.max(x1, x22);
  var overlapTop = Math.max(y1, y22);
  var overlapRight = Math.min(x1 + w1, x22 + w2);
  var overlapBottom = Math.min(y1 + h1, y22 + h2);
  if (overlapRight <= overlapLeft || overlapBottom <= overlapTop) {
    return null;
  }
  return [overlapLeft, overlapTop, overlapRight - overlapLeft, overlapBottom - overlapTop];
}
function transformRect(rect, matrix2) {
  var tl = vec3_exports.transformMat4(vec3_exports.create(), [rect[0], rect[1], 0], matrix2);
  var tr = vec3_exports.transformMat4(vec3_exports.create(), [rect[0] + rect[2], rect[1], 0], matrix2);
  var bl = vec3_exports.transformMat4(vec3_exports.create(), [rect[0], rect[1] + rect[3], 0], matrix2);
  var br = vec3_exports.transformMat4(vec3_exports.create(), [rect[0] + rect[2], rect[1] + rect[3], 0], matrix2);
  return [Math.min(tl[0], tr[0], bl[0], br[0]), Math.min(tl[1], tr[1], bl[1], br[1]), Math.max(tl[0], tr[0], bl[0], br[0]) - Math.min(tl[0], tr[0], bl[0], br[0]), Math.max(tl[1], tr[1], bl[1], br[1]) - Math.min(tl[1], tr[1], bl[1], br[1])];
}
var ImageRenderer = function(_DefaultRenderer) {
  function ImageRenderer2() {
    _classCallCheck(this, ImageRenderer2);
    return _callSuper(this, ImageRenderer2, arguments);
  }
  _inherits(ImageRenderer2, _DefaultRenderer);
  return _createClass(ImageRenderer2, [{
    key: "renderDownSampled",
    value: function renderDownSampled(context, parsedStyle, object, data2) {
      var src = data2.src, imageCache = data2.imageCache;
      if (!imageCache.downSampled) {
        this.imagePool.createDownSampledImage(src, object).then(function() {
          if (!object.ownerDocument) {
            return;
          }
          object.dirty();
          object.ownerDocument.defaultView.context.renderingService.dirtify();
        })["catch"](function(reason) {
          console.error(reason);
        });
        return;
      }
      context.drawImage(imageCache.downSampled, Math.floor(data2.drawRect[0]), Math.floor(data2.drawRect[1]), Math.ceil(data2.drawRect[2]), Math.ceil(data2.drawRect[3]));
    }
  }, {
    key: "renderTile",
    value: function renderTile(context, parsedStyle, object, data2) {
      var src = data2.src, imageCache = data2.imageCache, imageRect = data2.imageRect, drawRect = data2.drawRect;
      var originalSize = imageCache.size;
      var _context$getTransform = context.getTransform(), a2 = _context$getTransform.a, b = _context$getTransform.b, c2 = _context$getTransform.c, d2 = _context$getTransform.d, e = _context$getTransform.e, f = _context$getTransform.f;
      context.resetTransform();
      if (!(imageCache !== null && imageCache !== void 0 && imageCache.gridSize)) {
        this.imagePool.createImageTiles(src, [], function() {
          if (!object.ownerDocument) {
            return;
          }
          object.dirty();
          object.ownerDocument.defaultView.context.renderingService.dirtify();
        }, object)["catch"](function(reason) {
          console.error(reason);
        });
        return;
      }
      var scaleToOrigin = [originalSize[0] / imageRect[2], originalSize[1] / imageRect[3]];
      var scaledTileSize = [imageCache.tileSize[0] / scaleToOrigin[0], imageCache.tileSize[1] / scaleToOrigin[1]];
      var _ref = [Math.floor((drawRect[0] - imageRect[0]) / scaledTileSize[0]), Math.ceil((drawRect[0] + drawRect[2] - imageRect[0]) / scaledTileSize[0])], startTileX = _ref[0], endTileX = _ref[1];
      var _ref2 = [Math.floor((drawRect[1] - imageRect[1]) / scaledTileSize[1]), Math.ceil((drawRect[1] + drawRect[3] - imageRect[1]) / scaledTileSize[1])], startTileY = _ref2[0], endTileY = _ref2[1];
      for (var tileY = startTileY; tileY <= endTileY; tileY++) {
        for (var tileX = startTileX; tileX <= endTileX; tileX++) {
          var item = imageCache.tiles[tileY][tileX];
          if (item) {
            var tileRect = [Math.floor(imageRect[0] + item.tileX * scaledTileSize[0]), Math.floor(imageRect[1] + item.tileY * scaledTileSize[1]), Math.ceil(scaledTileSize[0]), Math.ceil(scaledTileSize[1])];
            context.drawImage(item.data, tileRect[0], tileRect[1], tileRect[2], tileRect[3]);
          }
        }
      }
      context.setTransform(a2, b, c2, d2, e, f);
    }
  }, {
    key: "render",
    value: function render(context, parsedStyle, object) {
      var _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, width = parsedStyle.width, height = parsedStyle.height, src = parsedStyle.src, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur;
      var imageCache = this.imagePool.getImageSync(src, object);
      var image = imageCache === null || imageCache === void 0 ? void 0 : imageCache.img;
      var iw = width;
      var ih = height;
      if (!image) {
        return;
      }
      iw || (iw = image.width);
      ih || (ih = image.height);
      var hasShadow = !isNil(shadowColor) && shadowBlur > 0;
      setShadowAndFilter(object, context, hasShadow);
      try {
        var _object$ownerDocument = object.ownerDocument.defaultView.getContextService().getDomElement(), viewWidth = _object$ownerDocument.width, viewHeight = _object$ownerDocument.height;
        var currentTransform = context.getTransform();
        var a2 = currentTransform.a, b = currentTransform.b, c2 = currentTransform.c, d2 = currentTransform.d, e = currentTransform.e, f = currentTransform.f;
        var transformMatrix = mat4_exports.fromValues(a2, c2, 0, 0, b, d2, 0, 0, 0, 0, 1, 0, e, f, 0, 1);
        var imageRect = transformRect([x3, y3, iw, ih], transformMatrix);
        var drawRect = calculateOverlapRect([0, 0, viewWidth, viewHeight], imageRect);
        if (!drawRect) {
          return;
        }
        if (!object.ownerDocument.defaultView.getConfig().enableLargeImageOptimization) {
          ImageRenderer2.renderFull(context, parsedStyle, object, {
            image,
            drawRect: [x3, y3, iw, ih]
          });
          return;
        }
        var sizeOfOrigin = imageRect[2] / imageCache.size[0];
        if (sizeOfOrigin < (imageCache.downSamplingRate || 0.5)) {
          this.renderDownSampled(context, parsedStyle, object, {
            src,
            imageCache,
            drawRect: [x3, y3, iw, ih]
          });
          return;
        }
        if (!ImagePool.isSupportTile) {
          ImageRenderer2.renderFull(context, parsedStyle, object, {
            image,
            drawRect: [x3, y3, iw, ih]
          });
          return;
        }
        this.renderTile(context, parsedStyle, object, {
          src,
          imageCache,
          imageRect,
          drawRect
        });
      } catch (_unused) {
      }
    }
    // ---
  }, {
    key: "drawToContext",
    value: function drawToContext(context, object, renderState, plugin, runtime2) {
      this.render(context, object.parsedStyle, object);
    }
  }], [{
    key: "renderFull",
    value: function renderFull(context, parsedStyle, object, data2) {
      context.drawImage(data2.image, Math.floor(data2.drawRect[0]), Math.floor(data2.drawRect[1]), Math.ceil(data2.drawRect[2]), Math.ceil(data2.drawRect[3]));
    }
  }]);
}(DefaultRenderer);
var TextRenderer = function(_DefaultRenderer) {
  function TextRenderer2() {
    _classCallCheck(this, TextRenderer2);
    return _callSuper(this, TextRenderer2, arguments);
  }
  _inherits(TextRenderer2, _DefaultRenderer);
  return _createClass(TextRenderer2, [{
    key: "render",
    value: function render(context, parsedStyle, object, canvasContext, plugin, runtime2) {
      object.getBounds();
      var _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$textAlig = parsedStyle.textAlign, textAlign = _parsedStyle$textAlig === void 0 ? "start" : _parsedStyle$textAlig, _parsedStyle$textBase = parsedStyle.textBaseline, textBaseline = _parsedStyle$textBase === void 0 ? "alphabetic" : _parsedStyle$textBase, _parsedStyle$lineJoin = parsedStyle.lineJoin, lineJoin = _parsedStyle$lineJoin === void 0 ? "miter" : _parsedStyle$lineJoin, _parsedStyle$miterLim = parsedStyle.miterLimit, miterLimit = _parsedStyle$miterLim === void 0 ? 10 : _parsedStyle$miterLim, _parsedStyle$letterSp = parsedStyle.letterSpacing, letterSpacing = _parsedStyle$letterSp === void 0 ? 0 : _parsedStyle$letterSp, stroke = parsedStyle.stroke, fill = parsedStyle.fill, fillRule = parsedStyle.fillRule, _parsedStyle$fillOpac = parsedStyle.fillOpacity, fillOpacity = _parsedStyle$fillOpac === void 0 ? 1 : _parsedStyle$fillOpac, _parsedStyle$strokeOp = parsedStyle.strokeOpacity, strokeOpacity = _parsedStyle$strokeOp === void 0 ? 1 : _parsedStyle$strokeOp, _parsedStyle$opacity = parsedStyle.opacity, opacity = _parsedStyle$opacity === void 0 ? 1 : _parsedStyle$opacity, metrics = parsedStyle.metrics, _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, dx = parsedStyle.dx, dy = parsedStyle.dy, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur;
      var font = metrics.font, lines = metrics.lines, height = metrics.height, lineHeight = metrics.lineHeight, lineMetrics = metrics.lineMetrics;
      context.font = font;
      context.lineWidth = lineWidth;
      context.textAlign = textAlign === "middle" ? "center" : textAlign;
      var formattedTextBaseline = textBaseline;
      if (formattedTextBaseline === "alphabetic") {
        formattedTextBaseline = "bottom";
      }
      context.lineJoin = lineJoin;
      if (!isNil(miterLimit)) {
        context.miterLimit = miterLimit;
      }
      var linePositionY = y3;
      if (textBaseline === "middle") {
        linePositionY += -height / 2 - lineHeight / 2;
      } else if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
        linePositionY += -height;
      } else if (textBaseline === "top" || textBaseline === "hanging") {
        linePositionY += -lineHeight;
      }
      var offsetX = x3 + (dx || 0);
      linePositionY += dy || 0;
      if (lines.length === 1) {
        if (formattedTextBaseline === "bottom") {
          formattedTextBaseline = "middle";
          linePositionY -= 0.5 * height;
        } else if (formattedTextBaseline === "top") {
          formattedTextBaseline = "middle";
          linePositionY += 0.5 * height;
        }
      }
      context.textBaseline = formattedTextBaseline;
      var hasShadow = !isNil(shadowColor) && shadowBlur > 0;
      setShadowAndFilter(object, context, hasShadow);
      for (var i = 0; i < lines.length; i++) {
        var linePositionX = lineWidth / 2 + offsetX;
        linePositionY += lineHeight;
        if (!isNil(stroke) && !stroke.isNone && lineWidth) {
          this.drawLetterSpacing(context, object, lines[i], lineMetrics[i], textAlign, linePositionX, linePositionY, letterSpacing, fill, fillRule, fillOpacity, stroke, strokeOpacity, opacity, true, canvasContext, plugin, runtime2);
        }
        if (!isNil(fill)) {
          this.drawLetterSpacing(context, object, lines[i], lineMetrics[i], textAlign, linePositionX, linePositionY, letterSpacing, fill, fillRule, fillOpacity, stroke, strokeOpacity, opacity, false, canvasContext, plugin, runtime2);
        }
      }
    }
  }, {
    key: "drawLetterSpacing",
    value: function drawLetterSpacing(context, object, text, lineMetrics, textAlign, x3, y3, letterSpacing, fill, fillRule, fillOpacity, stroke, strokeOpacity, opacity, isStroke, canvasContext, plugin, runtime2) {
      if (letterSpacing === 0) {
        if (isStroke) {
          this.strokeText(context, object, text, x3, y3, stroke, strokeOpacity, canvasContext, plugin, runtime2);
        } else {
          this.fillText(context, object, text, x3, y3, fill, fillRule, fillOpacity, opacity, canvasContext, plugin, runtime2);
        }
        return;
      }
      var currentTextAlign = context.textAlign;
      context.textAlign = "left";
      var currentPosition = x3;
      if (textAlign === "center" || textAlign === "middle") {
        currentPosition = x3 - lineMetrics.width / 2;
      } else if (textAlign === "right" || textAlign === "end") {
        currentPosition = x3 - lineMetrics.width;
      }
      var stringArray = Array.from(text);
      var previousWidth = context.measureText(text).width;
      var currentWidth = 0;
      for (var i = 0; i < stringArray.length; ++i) {
        var currentChar = stringArray[i];
        if (isStroke) {
          this.strokeText(context, object, currentChar, currentPosition, y3, stroke, strokeOpacity, canvasContext, plugin, runtime2);
        } else {
          this.fillText(context, object, currentChar, currentPosition, y3, fill, fillRule, fillOpacity, opacity, canvasContext, plugin, runtime2);
        }
        currentWidth = context.measureText(text.substring(i + 1)).width;
        currentPosition += previousWidth - currentWidth + letterSpacing;
        previousWidth = currentWidth;
      }
      context.textAlign = currentTextAlign;
    }
  }, {
    key: "fillText",
    value: function fillText(context, object, text, x3, y3, fill, fillRule, fillOpacity, opacity, canvasContext, plugin, runtime2) {
      applyFill(context, object, fill, fillRule, canvasContext, plugin, runtime2, this.imagePool, true);
      var currentGlobalAlpha;
      var applyOpacity = !isNil(fillOpacity) && fillOpacity !== 1;
      if (applyOpacity) {
        currentGlobalAlpha = context.globalAlpha;
        context.globalAlpha = fillOpacity * opacity;
      }
      context.fillText(text, x3, y3);
      if (applyOpacity) {
        context.globalAlpha = currentGlobalAlpha;
      }
    }
  }, {
    key: "strokeText",
    value: function strokeText(context, object, text, x3, y3, stroke, strokeOpacity, canvasContext, plugin, runtime2) {
      applyStroke(context, object, stroke, canvasContext, plugin, runtime2, this.imagePool, true);
      var currentGlobalAlpha;
      var applyOpacity = !isNil(strokeOpacity) && strokeOpacity !== 1;
      if (applyOpacity) {
        currentGlobalAlpha = context.globalAlpha;
        context.globalAlpha = strokeOpacity;
      }
      context.strokeText(text, x3, y3);
      if (applyOpacity) {
        context.globalAlpha = currentGlobalAlpha;
      }
    }
    // ---
  }, {
    key: "drawToContext",
    value: function drawToContext(context, object, renderState, plugin, runtime2) {
      this.render(context, object.parsedStyle, object, object.ownerDocument.defaultView.context, plugin, runtime2);
    }
  }]);
}(DefaultRenderer);
var Plugin4 = function(_AbstractRendererPlug) {
  function Plugin8() {
    var _this2;
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Plugin8);
    _this2 = _callSuper(this, Plugin8);
    _this2.name = "canvas-renderer";
    _this2.options = options;
    return _this2;
  }
  _inherits(Plugin8, _AbstractRendererPlug);
  return _createClass(Plugin8, [{
    key: "init",
    value: function init() {
      var _defaultStyleRenderer;
      var canvasRendererPluginOptions = _objectSpread2({
        dirtyObjectNumThreshold: 500,
        dirtyObjectRatioThreshold: 0.8
      }, this.options);
      var imagePool = this.context.imagePool;
      var defaultRenderer = new DefaultRenderer(imagePool);
      var defaultStyleRendererFactory = (_defaultStyleRenderer = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defaultStyleRenderer, Shape.CIRCLE, defaultRenderer), Shape.ELLIPSE, defaultRenderer), Shape.RECT, defaultRenderer), Shape.IMAGE, new ImageRenderer(imagePool)), Shape.TEXT, new TextRenderer(imagePool)), Shape.LINE, defaultRenderer), Shape.POLYLINE, defaultRenderer), Shape.POLYGON, defaultRenderer), Shape.PATH, defaultRenderer), Shape.GROUP, void 0), _defineProperty(_defineProperty(_defineProperty(_defaultStyleRenderer, Shape.HTML, void 0), Shape.MESH, void 0), Shape.FRAGMENT, void 0));
      this.context.defaultStyleRendererFactory = defaultStyleRendererFactory;
      this.context.styleRendererFactory = defaultStyleRendererFactory;
      this.addRenderingPlugin(new CanvasRendererPlugin(canvasRendererPluginOptions));
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.removeAllRenderingPlugins();
      delete this.context.defaultStyleRendererFactory;
      delete this.context.styleRendererFactory;
    }
  }]);
}(AbstractRendererPlugin);

// node_modules/@antv/g-plugin-dom-interaction/dist/index.esm.js
var DOMInteractionPlugin = function() {
  function DOMInteractionPlugin2() {
    _classCallCheck(this, DOMInteractionPlugin2);
  }
  return _createClass(DOMInteractionPlugin2, [{
    key: "apply",
    value: function apply(context, runtime2) {
      var _this2 = this;
      var renderingService = context.renderingService, renderingContext = context.renderingContext, config = context.config;
      this.context = context;
      var canvas = renderingContext.root.ownerDocument.defaultView;
      var onPointerMove = function onPointerMove2(ev) {
        renderingService.hooks.pointerMove.call(ev);
      };
      var onPointerUp = function onPointerUp2(ev) {
        renderingService.hooks.pointerUp.call(ev);
      };
      var onPointerDown = function onPointerDown2(ev) {
        renderingService.hooks.pointerDown.call(ev);
      };
      var onPointerOver = function onPointerOver2(ev) {
        renderingService.hooks.pointerOver.call(ev);
      };
      var onPointerOut = function onPointerOut2(ev) {
        renderingService.hooks.pointerOut.call(ev);
      };
      var onPointerCancel = function onPointerCancel2(ev) {
        renderingService.hooks.pointerCancel.call(ev);
      };
      var onPointerWheel = function onPointerWheel2(ev) {
        renderingService.hooks.pointerWheel.call(ev);
      };
      var onClick = function onClick2(ev) {
        renderingService.hooks.click.call(ev);
      };
      var addPointerEventListener = function addPointerEventListener2($el) {
        runtime2.globalThis.document.addEventListener("pointermove", onPointerMove, true);
        $el.addEventListener("pointerdown", onPointerDown, true);
        $el.addEventListener("pointerleave", onPointerOut, true);
        $el.addEventListener("pointerover", onPointerOver, true);
        runtime2.globalThis.addEventListener("pointerup", onPointerUp, true);
        runtime2.globalThis.addEventListener("pointercancel", onPointerCancel, true);
      };
      var addTouchEventListener = function addTouchEventListener2($el) {
        $el.addEventListener("touchstart", onPointerDown, true);
        $el.addEventListener("touchend", onPointerUp, true);
        $el.addEventListener("touchmove", onPointerMove, true);
        $el.addEventListener("touchcancel", onPointerCancel, true);
      };
      var addMouseEventListener = function addMouseEventListener2($el) {
        runtime2.globalThis.document.addEventListener("mousemove", onPointerMove, true);
        $el.addEventListener("mousedown", onPointerDown, true);
        $el.addEventListener("mouseout", onPointerOut, true);
        $el.addEventListener("mouseover", onPointerOver, true);
        runtime2.globalThis.addEventListener("mouseup", onPointerUp, true);
      };
      var removePointerEventListener = function removePointerEventListener2($el) {
        runtime2.globalThis.document.removeEventListener("pointermove", onPointerMove, true);
        $el.removeEventListener("pointerdown", onPointerDown, true);
        $el.removeEventListener("pointerleave", onPointerOut, true);
        $el.removeEventListener("pointerover", onPointerOver, true);
        runtime2.globalThis.removeEventListener("pointerup", onPointerUp, true);
        runtime2.globalThis.removeEventListener("pointercancel", onPointerCancel, true);
      };
      var removeTouchEventListener = function removeTouchEventListener2($el) {
        $el.removeEventListener("touchstart", onPointerDown, true);
        $el.removeEventListener("touchend", onPointerUp, true);
        $el.removeEventListener("touchmove", onPointerMove, true);
        $el.removeEventListener("touchcancel", onPointerCancel, true);
      };
      var removeMouseEventListener = function removeMouseEventListener2($el) {
        runtime2.globalThis.document.removeEventListener("mousemove", onPointerMove, true);
        $el.removeEventListener("mousedown", onPointerDown, true);
        $el.removeEventListener("mouseout", onPointerOut, true);
        $el.removeEventListener("mouseover", onPointerOver, true);
        runtime2.globalThis.removeEventListener("mouseup", onPointerUp, true);
      };
      renderingService.hooks.init.tap(DOMInteractionPlugin2.tag, function() {
        var $el = _this2.context.contextService.getDomElement();
        if (runtime2.globalThis.navigator.msPointerEnabled) {
          $el.style.msContentZooming = "none";
          $el.style.msTouchAction = "none";
        } else if (canvas.supportsPointerEvents) {
          $el.style.touchAction = "none";
        }
        if (canvas.supportsPointerEvents) {
          addPointerEventListener($el);
        } else {
          addMouseEventListener($el);
        }
        if (canvas.supportsTouchEvents) {
          addTouchEventListener($el);
        }
        if (config.useNativeClickEvent) {
          $el.addEventListener("click", onClick, true);
        }
        $el.addEventListener("wheel", onPointerWheel, {
          passive: true,
          capture: true
        });
      });
      renderingService.hooks.destroy.tap(DOMInteractionPlugin2.tag, function() {
        var $el = _this2.context.contextService.getDomElement();
        if (runtime2.globalThis.navigator.msPointerEnabled) {
          $el.style.msContentZooming = "";
          $el.style.msTouchAction = "";
        } else if (canvas.supportsPointerEvents) {
          $el.style.touchAction = "";
        }
        if (canvas.supportsPointerEvents) {
          removePointerEventListener($el);
        } else {
          removeMouseEventListener($el);
        }
        if (canvas.supportsTouchEvents) {
          removeTouchEventListener($el);
        }
        if (config.useNativeClickEvent) {
          $el.removeEventListener("click", onClick, true);
        }
        $el.removeEventListener("wheel", onPointerWheel, true);
      });
    }
  }]);
}();
DOMInteractionPlugin.tag = "DOMInteraction";
var Plugin5 = function(_AbstractRendererPlug) {
  function Plugin8() {
    var _this2;
    _classCallCheck(this, Plugin8);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Plugin8, [].concat(args));
    _this2.name = "dom-interaction";
    return _this2;
  }
  _inherits(Plugin8, _AbstractRendererPlug);
  return _createClass(Plugin8, [{
    key: "init",
    value: function init() {
      this.addRenderingPlugin(new DOMInteractionPlugin());
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.removeAllRenderingPlugins();
    }
  }]);
}(AbstractRendererPlugin);

// node_modules/@antv/g-plugin-html-renderer/dist/index.esm.js
var CANVAS_CAMERA_ID = "g-canvas-camera";
var HTMLRenderingPlugin = function() {
  function HTMLRenderingPlugin2() {
    _classCallCheck(this, HTMLRenderingPlugin2);
    this.displayObjectHTMLElementMap = /* @__PURE__ */ new WeakMap();
  }
  return _createClass(HTMLRenderingPlugin2, [{
    key: "joinTransformMatrix",
    value: (
      /**
       * ! The reason for adding `offset` is that the `transform-origin` coordinate system of DOM is the local coordinate system of the element, while the `transform-origin` coordinate system of canvas drawing is the local coordinate system of the element's parent element. At the same time, the `transform` attribute value of the DOM element does not include `transform-origin`.
       */
      function joinTransformMatrix(matrix2) {
        var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
        return "matrix(".concat([matrix2[0], matrix2[1], matrix2[4], matrix2[5], matrix2[12] + offset[0], matrix2[13] + offset[1]].join(","), ")");
      }
    )
  }, {
    key: "apply",
    value: function apply(context, runtime2) {
      var _this2 = this;
      var camera = context.camera, renderingContext = context.renderingContext, renderingService = context.renderingService;
      this.context = context;
      var canvas = renderingContext.root.ownerDocument.defaultView;
      var nativeHTMLMap = canvas.context.eventService.nativeHTMLMap;
      var setTransform = function setTransform2(object, $el) {
        $el.style.transform = _this2.joinTransformMatrix(object.getWorldTransform(), object.getOrigin());
      };
      var handleMounted = function handleMounted2(e) {
        var object = e.target;
        if (object.nodeName === Shape.HTML) {
          if (!_this2.$camera) {
            _this2.$camera = _this2.createCamera(camera);
          }
          var $el = _this2.getOrCreateEl(object);
          _this2.$camera.appendChild($el);
          Object.keys(object.attributes).forEach(function(name) {
            _this2.updateAttribute(name, object);
          });
          setTransform(object, $el);
          nativeHTMLMap.set($el, object);
        }
      };
      var handleUnmounted = function handleUnmounted2(e) {
        var object = e.target;
        if (object.nodeName === Shape.HTML && _this2.$camera) {
          var $el = _this2.getOrCreateEl(object);
          if ($el) {
            $el.remove();
            nativeHTMLMap["delete"]($el);
          }
        }
      };
      var handleAttributeChanged = function handleAttributeChanged2(e) {
        var object = e.target;
        if (object.nodeName === Shape.HTML) {
          var attrName = e.attrName;
          _this2.updateAttribute(attrName, object);
        }
      };
      var handleBoundsChanged = function handleBoundsChanged2(e) {
        var object = e.target;
        var nodes = object.nodeName === Shape.FRAGMENT ? object.childNodes : [object];
        nodes.forEach(function(node) {
          if (node.nodeName === Shape.HTML) {
            var $el = _this2.getOrCreateEl(node);
            setTransform(node, $el);
          }
        });
      };
      var handleCanvasResize = function handleCanvasResize2() {
        if (_this2.$camera) {
          var _this$context$config = _this2.context.config, width = _this$context$config.width, height = _this$context$config.height;
          _this2.$camera.parentElement.style.width = "".concat(width || 0, "px");
          _this2.$camera.parentElement.style.height = "".concat(height || 0, "px");
        }
      };
      renderingService.hooks.init.tap(HTMLRenderingPlugin2.tag, function() {
        canvas.addEventListener(CanvasEvent.RESIZE, handleCanvasResize);
        canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        canvas.addEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
      });
      renderingService.hooks.endFrame.tap(HTMLRenderingPlugin2.tag, function() {
        if (_this2.$camera && renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED)) {
          _this2.$camera.style.transform = _this2.joinTransformMatrix(camera.getOrthoMatrix());
        }
      });
      renderingService.hooks.destroy.tap(HTMLRenderingPlugin2.tag, function() {
        if (_this2.$camera) {
          _this2.$camera.remove();
        }
        canvas.removeEventListener(CanvasEvent.RESIZE, handleCanvasResize);
        canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        canvas.removeEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
      });
    }
  }, {
    key: "createCamera",
    value: function createCamera(camera) {
      var _this$context$config2 = this.context.config, doc = _this$context$config2.document, width = _this$context$config2.width, height = _this$context$config2.height;
      var $canvas = this.context.contextService.getDomElement();
      var $container = $canvas.parentNode;
      if ($container) {
        var cameraId = CANVAS_CAMERA_ID;
        var $existedCamera = $container.querySelector("#".concat(cameraId));
        if (!$existedCamera) {
          var $cameraContainer = (doc || document).createElement("div");
          $cameraContainer.style.overflow = "hidden";
          $cameraContainer.style.pointerEvents = "none";
          $cameraContainer.style.position = "absolute";
          $cameraContainer.style.left = "0px";
          $cameraContainer.style.top = "0px";
          $cameraContainer.style.width = "".concat(width || 0, "px");
          $cameraContainer.style.height = "".concat(height || 0, "px");
          var $camera = (doc || document).createElement("div");
          $existedCamera = $camera;
          $camera.id = cameraId;
          $camera.style.position = "absolute";
          $camera.style.left = "".concat($canvas.offsetLeft || 0, "px");
          $camera.style.top = "".concat($canvas.offsetTop || 0, "px");
          $camera.style.transformOrigin = "left top";
          $camera.style.transform = this.joinTransformMatrix(camera.getOrthoMatrix());
          $camera.style.pointerEvents = "none";
          $camera.style.width = "100%";
          $camera.style.height = "100%";
          $cameraContainer.appendChild($camera);
          $container.appendChild($cameraContainer);
        }
        return $existedCamera;
      }
      return null;
    }
  }, {
    key: "getOrCreateEl",
    value: function getOrCreateEl(object) {
      var doc = this.context.config.document;
      var $existedElement = this.displayObjectHTMLElementMap.get(object);
      if (!$existedElement) {
        $existedElement = (doc || document).createElement("div");
        object.parsedStyle.$el = $existedElement;
        this.displayObjectHTMLElementMap.set(object, $existedElement);
        if (object.id) {
          $existedElement.id = object.id;
        }
        if (object.name) {
          $existedElement.setAttribute("name", object.name);
        }
        if (object.className) {
          $existedElement.className = object.className;
        }
        $existedElement.style.position = "absolute";
        $existedElement.style["will-change"] = "transform";
        $existedElement.style.transform = this.joinTransformMatrix(object.getWorldTransform(), object.getOrigin());
      }
      return $existedElement;
    }
  }, {
    key: "updateAttribute",
    value: function updateAttribute(name, object) {
      var $el = this.getOrCreateEl(object);
      switch (name) {
        case "innerHTML":
          var innerHTML = object.parsedStyle.innerHTML;
          if (isString(innerHTML)) {
            $el.innerHTML = innerHTML;
          } else {
            $el.innerHTML = "";
            $el.appendChild(innerHTML);
          }
          break;
        case "x":
          $el.style.left = "".concat(object.parsedStyle.x, "px");
          break;
        case "y":
          $el.style.top = "".concat(object.parsedStyle.y, "px");
          break;
        case "transformOrigin":
          var transformOrigin = object.parsedStyle.transformOrigin;
          $el.style["transform-origin"] = "".concat(transformOrigin[0].buildCSSText(null, null, ""), " ").concat(transformOrigin[1].buildCSSText(null, null, ""));
          break;
        case "width":
          var width = object.parsedStyle.width;
          $el.style.width = isNumber(width) ? "".concat(width, "px") : width.toString();
          break;
        case "height":
          var height = object.parsedStyle.height;
          $el.style.height = isNumber(height) ? "".concat(height, "px") : height.toString();
          break;
        case "zIndex":
          var zIndex = object.parsedStyle.zIndex;
          $el.style["z-index"] = "".concat(zIndex);
          break;
        case "visibility":
          var visibility2 = object.parsedStyle.visibility;
          $el.style.visibility = visibility2;
          break;
        case "pointerEvents":
          var _object$parsedStyle$p = object.parsedStyle.pointerEvents, pointerEvents = _object$parsedStyle$p === void 0 ? "auto" : _object$parsedStyle$p;
          $el.style.pointerEvents = pointerEvents;
          break;
        case "opacity":
          var opacity = object.parsedStyle.opacity;
          $el.style.opacity = "".concat(opacity);
          break;
        case "fill":
          var fill = object.parsedStyle.fill;
          var color2 = "";
          if (isCSSRGB(fill)) {
            if (fill.isNone) {
              color2 = "transparent";
            } else {
              color2 = object.getAttribute("fill");
            }
          } else if (Array.isArray(fill)) {
            color2 = object.getAttribute("fill");
          } else if (isPattern(fill)) ;
          $el.style.background = color2;
          break;
        case "stroke":
          var stroke = object.parsedStyle.stroke;
          var borderColor = "";
          if (isCSSRGB(stroke)) {
            if (stroke.isNone) {
              borderColor = "transparent";
            } else {
              borderColor = object.getAttribute("stroke");
            }
          } else if (Array.isArray(stroke)) {
            borderColor = object.getAttribute("stroke");
          } else if (isPattern(stroke)) ;
          $el.style["border-color"] = borderColor;
          $el.style["border-style"] = "solid";
          break;
        case "lineWidth":
          var lineWidth = object.parsedStyle.lineWidth;
          $el.style["border-width"] = "".concat(lineWidth || 0, "px");
          break;
        case "lineDash":
          $el.style["border-style"] = "dashed";
          break;
        case "filter":
          var filter2 = object.style.filter;
          $el.style.filter = filter2;
          break;
        default:
          if (!isNil(object.style[name]) && object.style[name] !== "") {
            $el.style[name] = object.style[name];
          }
      }
    }
  }]);
}();
HTMLRenderingPlugin.tag = "HTMLRendering";
var Plugin6 = function(_AbstractRendererPlug) {
  function Plugin8() {
    var _this2;
    _classCallCheck(this, Plugin8);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Plugin8, [].concat(args));
    _this2.name = "html-renderer";
    return _this2;
  }
  _inherits(Plugin8, _AbstractRendererPlug);
  return _createClass(Plugin8, [{
    key: "init",
    value: function init() {
      this.addRenderingPlugin(new HTMLRenderingPlugin());
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.removeAllRenderingPlugins();
    }
  }]);
}(AbstractRendererPlugin);

// node_modules/@antv/g-canvas/dist/index.esm.js
var Canvas2DContextService = function() {
  function Canvas2DContextService2(context) {
    _classCallCheck(this, Canvas2DContextService2);
    this.renderingContext = context.renderingContext;
    this.canvasConfig = context.config;
  }
  return _createClass(Canvas2DContextService2, [{
    key: "init",
    value: function init() {
      var _this$canvasConfig = this.canvasConfig, container = _this$canvasConfig.container, canvas = _this$canvasConfig.canvas;
      if (canvas) {
        this.$canvas = canvas;
        if (container && canvas.parentElement !== container) {
          container.appendChild(canvas);
        }
        this.$container = canvas.parentElement;
        this.canvasConfig.container = this.$container;
      } else if (container) {
        this.$container = isString(container) ? document.getElementById(container) : container;
        if (this.$container) {
          var $canvas = document.createElement("canvas");
          this.$container.appendChild($canvas);
          if (!this.$container.style.position) {
            this.$container.style.position = "relative";
          }
          this.$canvas = $canvas;
        }
      }
      this.context = this.$canvas.getContext("2d");
      this.resize(this.canvasConfig.width, this.canvasConfig.height);
    }
  }, {
    key: "getContext",
    value: function getContext() {
      return this.context;
    }
  }, {
    key: "getDomElement",
    value: function getDomElement() {
      return this.$canvas;
    }
  }, {
    key: "getDPR",
    value: function getDPR() {
      return this.dpr;
    }
  }, {
    key: "getBoundingClientRect",
    value: function getBoundingClientRect() {
      if (this.$canvas.getBoundingClientRect) {
        return this.$canvas.getBoundingClientRect();
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.$container && this.$canvas && this.$canvas.parentNode) {
        this.$container.removeChild(this.$canvas);
      }
    }
  }, {
    key: "resize",
    value: function resize(width, height) {
      var dpr = this.canvasConfig.devicePixelRatio;
      this.dpr = dpr;
      if (this.$canvas) {
        this.$canvas.width = this.dpr * width;
        this.$canvas.height = this.dpr * height;
        setDOMSize(this.$canvas, width, height);
      }
      this.renderingContext.renderReasons.add(RenderReason.CAMERA_CHANGED);
    }
  }, {
    key: "applyCursorStyle",
    value: function applyCursorStyle(cursor) {
      if (this.$container && this.$container.style) {
        this.$container.style.cursor = cursor;
      }
    }
  }, {
    key: "toDataURL",
    value: function() {
      var _toDataURL = _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
        var options, type, encoderOptions, _args = arguments;
        return _regeneratorRuntime().wrap(function(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              options = _args.length > 0 && _args[0] !== void 0 ? _args[0] : {};
              type = options.type, encoderOptions = options.encoderOptions;
              return _context.abrupt("return", this.context.canvas.toDataURL(type, encoderOptions));
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function toDataURL() {
        return _toDataURL.apply(this, arguments);
      }
      return toDataURL;
    }()
  }]);
}();
var ContextRegisterPlugin = function(_AbstractRendererPlug) {
  function ContextRegisterPlugin2() {
    var _this2;
    _classCallCheck(this, ContextRegisterPlugin2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, ContextRegisterPlugin2, [].concat(args));
    _this2.name = "canvas-context-register";
    return _this2;
  }
  _inherits(ContextRegisterPlugin2, _AbstractRendererPlug);
  return _createClass(ContextRegisterPlugin2, [{
    key: "init",
    value: function init() {
      this.context.ContextService = Canvas2DContextService;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      delete this.context.ContextService;
    }
  }]);
}(AbstractRendererPlugin);
var Renderer = function(_AbstractRenderer) {
  function Renderer2(config) {
    var _this2;
    _classCallCheck(this, Renderer2);
    _this2 = _callSuper(this, Renderer2, [config]);
    _this2.registerPlugin(new ContextRegisterPlugin());
    _this2.registerPlugin(new Plugin3());
    _this2.registerPlugin(new Plugin());
    _this2.registerPlugin(new Plugin4());
    _this2.registerPlugin(new Plugin5());
    _this2.registerPlugin(new Plugin2());
    _this2.registerPlugin(new Plugin6());
    return _this2;
  }
  _inherits(Renderer2, _AbstractRenderer);
  return _createClass(Renderer2);
}(AbstractRenderer);

// node_modules/@antv/event-emitter/esm/index.js
var WILDCARD = "*";
var EventEmitter2 = (
  /** @class */
  function() {
    function EventEmitter3() {
      this._events = {};
    }
    EventEmitter3.prototype.on = function(evt, callback, once) {
      if (!this._events[evt]) {
        this._events[evt] = [];
      }
      this._events[evt].push({
        callback,
        once: !!once
      });
      return this;
    };
    EventEmitter3.prototype.once = function(evt, callback) {
      return this.on(evt, callback, true);
    };
    EventEmitter3.prototype.emit = function(evt) {
      var _this2 = this;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var events = this._events[evt] || [];
      var wildcardEvents = this._events[WILDCARD] || [];
      var doEmit = function(es) {
        var length5 = es.length;
        for (var i = 0; i < length5; i++) {
          if (!es[i]) {
            continue;
          }
          var _a2 = es[i], callback = _a2.callback, once = _a2.once;
          if (once) {
            es.splice(i, 1);
            if (es.length === 0) {
              delete _this2._events[evt];
            }
            length5--;
            i--;
          }
          callback.apply(_this2, args);
        }
      };
      doEmit(events);
      doEmit(wildcardEvents);
    };
    EventEmitter3.prototype.off = function(evt, callback) {
      if (!evt) {
        this._events = {};
      } else {
        if (!callback) {
          delete this._events[evt];
        } else {
          var events = this._events[evt] || [];
          var length_1 = events.length;
          for (var i = 0; i < length_1; i++) {
            if (events[i].callback === callback) {
              events.splice(i, 1);
              length_1--;
              i--;
            }
          }
          if (events.length === 0) {
            delete this._events[evt];
          }
        }
      }
      return this;
    };
    EventEmitter3.prototype.getEvents = function() {
      return this._events;
    };
    return EventEmitter3;
  }()
);
var esm_default = EventEmitter2;

// node_modules/d3-force/src/center.js
function center_default(x3, y3) {
  var nodes, strength = 1;
  if (x3 == null) x3 = 0;
  if (y3 == null) y3 = 0;
  function force() {
    var i, n = nodes.length, node, sx = 0, sy = 0;
    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }
    for (sx = (sx / n - x3) * strength, sy = (sy / n - y3) * strength, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
  };
  force.x = function(_2) {
    return arguments.length ? (x3 = +_2, force) : x3;
  };
  force.y = function(_2) {
    return arguments.length ? (y3 = +_2, force) : y3;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = +_2, force) : strength;
  };
  return force;
}

// node_modules/d3-quadtree/src/add.js
function add_default(d2) {
  const x3 = +this._x.call(null, d2), y3 = +this._y.call(null, d2);
  return add7(this.cover(x3, y3), x3, y3, d2);
}
function add7(tree, x3, y3, d2) {
  if (isNaN(x3) || isNaN(y3)) return tree;
  var parent, node = tree._root, leaf = { data: d2 }, x0 = tree._x0, y0 = tree._y0, x1 = tree._x1, y1 = tree._y1, xm, ym, xp, yp, right, bottom, i, j;
  if (!node) return tree._root = leaf, tree;
  while (node.length) {
    if (right = x3 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y3 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x3 === xp && y3 === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x3 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y3 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));
  return parent[j] = node, parent[i] = leaf, tree;
}
function addAll(data2) {
  var d2, i, n = data2.length, x3, y3, xz = new Array(n), yz = new Array(n), x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
  for (i = 0; i < n; ++i) {
    if (isNaN(x3 = +this._x.call(null, d2 = data2[i])) || isNaN(y3 = +this._y.call(null, d2))) continue;
    xz[i] = x3;
    yz[i] = y3;
    if (x3 < x0) x0 = x3;
    if (x3 > x1) x1 = x3;
    if (y3 < y0) y0 = y3;
    if (y3 > y1) y1 = y3;
  }
  if (x0 > x1 || y0 > y1) return this;
  this.cover(x0, y0).cover(x1, y1);
  for (i = 0; i < n; ++i) {
    add7(this, xz[i], yz[i], data2[i]);
  }
  return this;
}

// node_modules/d3-quadtree/src/cover.js
function cover_default(x3, y3) {
  if (isNaN(x3 = +x3) || isNaN(y3 = +y3)) return this;
  var x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1;
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x3)) + 1;
    y1 = (y0 = Math.floor(y3)) + 1;
  } else {
    var z = x1 - x0 || 1, node = this._root, parent, i;
    while (x0 > x3 || x3 >= x1 || y0 > y3 || y3 >= y1) {
      i = (y3 < y0) << 1 | x3 < x0;
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0:
          x1 = x0 + z, y1 = y0 + z;
          break;
        case 1:
          x0 = x1 - z, y1 = y0 + z;
          break;
        case 2:
          x1 = x0 + z, y0 = y1 - z;
          break;
        case 3:
          x0 = x1 - z, y0 = y1 - z;
          break;
      }
    }
    if (this._root && this._root.length) this._root = node;
  }
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}

// node_modules/d3-quadtree/src/data.js
function data_default() {
  var data2 = [];
  this.visit(function(node) {
    if (!node.length) do
      data2.push(node.data);
    while (node = node.next);
  });
  return data2;
}

// node_modules/d3-quadtree/src/extent.js
function extent_default(_2) {
  return arguments.length ? this.cover(+_2[0][0], +_2[0][1]).cover(+_2[1][0], +_2[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}

// node_modules/d3-quadtree/src/quad.js
function quad_default(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}

// node_modules/d3-quadtree/src/find.js
function find_default2(x3, y3, radius) {
  var data2, x0 = this._x0, y0 = this._y0, x1, y1, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q, i;
  if (node) quads.push(new quad_default(node, x0, y0, x32, y32));
  if (radius == null) radius = Infinity;
  else {
    x0 = x3 - radius, y0 = y3 - radius;
    x32 = x3 + radius, y32 = y3 + radius;
    radius *= radius;
  }
  while (q = quads.pop()) {
    if (!(node = q.node) || (x1 = q.x0) > x32 || (y1 = q.y0) > y32 || (x22 = q.x1) < x0 || (y22 = q.y1) < y0) continue;
    if (node.length) {
      var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2;
      quads.push(
        new quad_default(node[3], xm, ym, x22, y22),
        new quad_default(node[2], x1, ym, xm, y22),
        new quad_default(node[1], xm, y1, x22, ym),
        new quad_default(node[0], x1, y1, xm, ym)
      );
      if (i = (y3 >= ym) << 1 | x3 >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    } else {
      var dx = x3 - +this._x.call(null, node.data), dy = y3 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d3 = Math.sqrt(radius = d2);
        x0 = x3 - d3, y0 = y3 - d3;
        x32 = x3 + d3, y32 = y3 + d3;
        data2 = node.data;
      }
    }
  }
  return data2;
}

// node_modules/d3-quadtree/src/remove.js
function remove_default2(d2) {
  if (isNaN(x3 = +this._x.call(null, d2)) || isNaN(y3 = +this._y.call(null, d2))) return this;
  var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x3, y3, xm, ym, right, bottom, i, j;
  if (!node) return this;
  if (node.length) while (true) {
    if (right = x3 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y3 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3]) retainer = parent, j = i;
  }
  while (node.data !== d2) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;
  if (previous) return next ? previous.next = next : delete previous.next, this;
  if (!parent) return this._root = next, this;
  next ? parent[i] = next : delete parent[i];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }
  return this;
}
function removeAll(data2) {
  for (var i = 0, n = data2.length; i < n; ++i) this.remove(data2[i]);
  return this;
}

// node_modules/d3-quadtree/src/root.js
function root_default() {
  return this._root;
}

// node_modules/d3-quadtree/src/size.js
function size_default() {
  var size2 = 0;
  this.visit(function(node) {
    if (!node.length) do
      ++size2;
    while (node = node.next);
  });
  return size2;
}

// node_modules/d3-quadtree/src/visit.js
function visit_default(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new quad_default(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new quad_default(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new quad_default(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new quad_default(child, x0, y0, xm, ym));
    }
  }
  return this;
}

// node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new quad_default(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new quad_default(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new quad_default(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new quad_default(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

// node_modules/d3-quadtree/src/x.js
function defaultX(d2) {
  return d2[0];
}
function x_default(_2) {
  return arguments.length ? (this._x = _2, this) : this._x;
}

// node_modules/d3-quadtree/src/y.js
function defaultY(d2) {
  return d2[1];
}
function y_default(_2) {
  return arguments.length ? (this._y = _2, this) : this._y;
}

// node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x3, y3) {
  var tree = new Quadtree(x3 == null ? defaultX : x3, y3 == null ? defaultY : y3, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x3, y3, x0, y0, x1, y1) {
  this._x = x3;
  this._y = y3;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy7 = { data: leaf.data }, next = copy7;
  while (leaf = leaf.next) next = next.next = { data: leaf.data };
  return copy7;
}
var treeProto = quadtree.prototype = Quadtree.prototype;
treeProto.copy = function() {
  var copy7 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
  if (!node) return copy7;
  if (!node.length) return copy7._root = leaf_copy(node), copy7;
  nodes = [{ source: node, target: copy7._root = new Array(4) }];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({ source: child, target: node.target[i] = new Array(4) });
        else node.target[i] = leaf_copy(child);
      }
    }
  }
  return copy7;
};
treeProto.add = add_default;
treeProto.addAll = addAll;
treeProto.cover = cover_default;
treeProto.data = data_default;
treeProto.extent = extent_default;
treeProto.find = find_default2;
treeProto.remove = remove_default2;
treeProto.removeAll = removeAll;
treeProto.root = root_default;
treeProto.size = size_default;
treeProto.visit = visit_default;
treeProto.visitAfter = visitAfter_default;
treeProto.x = x_default;
treeProto.y = y_default;

// node_modules/d3-force/src/constant.js
function constant_default(x3) {
  return function() {
    return x3;
  };
}

// node_modules/d3-force/src/jiggle.js
function jiggle_default(random5) {
  return (random5() - 0.5) * 1e-6;
}

// node_modules/d3-force/src/collide.js
function x(d2) {
  return d2.x + d2.vx;
}
function y(d2) {
  return d2.y + d2.vy;
}
function collide_default(radius) {
  var nodes, radii, random5, strength = 1, iterations = 1;
  if (typeof radius !== "function") radius = constant_default(radius == null ? 1 : +radius);
  function force() {
    var i, n = nodes.length, tree, node, xi, yi, ri, ri2;
    for (var k = 0; k < iterations; ++k) {
      tree = quadtree(nodes, x, y).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }
    function apply(quad, x0, y0, x1, y1) {
      var data2 = quad.data, rj = quad.r, r = ri + rj;
      if (data2) {
        if (data2.index > node.index) {
          var x3 = xi - data2.x - data2.vx, y3 = yi - data2.y - data2.vy, l = x3 * x3 + y3 * y3;
          if (l < r * r) {
            if (x3 === 0) x3 = jiggle_default(random5), l += x3 * x3;
            if (y3 === 0) y3 = jiggle_default(random5), l += y3 * y3;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x3 *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y3 *= l) * r;
            data2.vx -= x3 * (r = 1 - r);
            data2.vy -= y3 * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }
  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }
  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random5 = _random;
    initialize();
  };
  force.iterations = function(_2) {
    return arguments.length ? (iterations = +_2, force) : iterations;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = +_2, force) : strength;
  };
  force.radius = function(_2) {
    return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : radius;
  };
  return force;
}

// node_modules/d3-force/src/link.js
function index(d2) {
  return d2.index;
}
function find4(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("node not found: " + nodeId);
  return node;
}
function link_default(links) {
  var id3 = index, strength = defaultStrength, strengths, distance6 = constant_default(30), distances, nodes, count, bias, random5, iterations = 1;
  if (links == null) links = [];
  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }
  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x3, y3, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x3 = target.x + target.vx - source.x - source.vx || jiggle_default(random5);
        y3 = target.y + target.vy - source.y - source.vy || jiggle_default(random5);
        l = Math.sqrt(x3 * x3 + y3 * y3);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x3 *= l, y3 *= l;
        target.vx -= x3 * (b = bias[i]);
        target.vy -= y3 * b;
        source.vx += x3 * (b = 1 - b);
        source.vy += y3 * b;
      }
    }
  }
  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, m2 = links.length, nodeById = new Map(nodes.map((d2, i2) => [id3(d2, i2, nodes), d2])), link;
    for (i = 0, count = new Array(n); i < m2; ++i) {
      link = links[i], link.index = i;
      if (typeof link.source !== "object") link.source = find4(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find4(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }
    for (i = 0, bias = new Array(m2); i < m2; ++i) {
      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }
    strengths = new Array(m2), initializeStrength();
    distances = new Array(m2), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes) return;
    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }
  function initializeDistance() {
    if (!nodes) return;
    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance6(links[i], i, links);
    }
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random5 = _random;
    initialize();
  };
  force.links = function(_2) {
    return arguments.length ? (links = _2, initialize(), force) : links;
  };
  force.id = function(_2) {
    return arguments.length ? (id3 = _2, force) : id3;
  };
  force.iterations = function(_2) {
    return arguments.length ? (iterations = +_2, force) : iterations;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default(+_2), initializeStrength(), force) : strength;
  };
  force.distance = function(_2) {
    return arguments.length ? (distance6 = typeof _2 === "function" ? _2 : constant_default(+_2), initializeDistance(), force) : distance6;
  };
  return force;
}

// node_modules/d3-force/src/lcg.js
var a = 1664525;
var c = 1013904223;
var m = 4294967296;
function lcg_default() {
  let s2 = 1;
  return () => (s2 = (a * s2 + c) % m) / m;
}

// node_modules/d3-force/src/simulation.js
function x2(d2) {
  return d2.x;
}
function y2(d2) {
  return d2.y;
}
var initialRadius = 10;
var initialAngle = Math.PI * (3 - Math.sqrt(5));
function simulation_default(nodes) {
  var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step2), event = dispatch_default("tick", "end"), random5 = lcg_default();
  if (nodes == null) nodes = [];
  function step2() {
    tick2();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }
  function tick2(iterations) {
    var i, n = nodes.length, node;
    if (iterations === void 0) iterations = 1;
    for (var k = 0; k < iterations; ++k) {
      alpha += (alphaTarget - alpha) * alphaDecay;
      forces.forEach(function(force) {
        force(alpha);
      });
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (node.fy == null) node.y += node.vy *= velocityDecay;
        else node.y = node.fy, node.vy = 0;
      }
    }
    return simulation;
  }
  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i), angle3 = i * initialAngle;
        node.x = radius * Math.cos(angle3);
        node.y = radius * Math.sin(angle3);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes, random5);
    return force;
  }
  initializeNodes();
  return simulation = {
    tick: tick2,
    restart: function() {
      return stepper.restart(step2), simulation;
    },
    stop: function() {
      return stepper.stop(), simulation;
    },
    nodes: function(_2) {
      return arguments.length ? (nodes = _2, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },
    alpha: function(_2) {
      return arguments.length ? (alpha = +_2, simulation) : alpha;
    },
    alphaMin: function(_2) {
      return arguments.length ? (alphaMin = +_2, simulation) : alphaMin;
    },
    alphaDecay: function(_2) {
      return arguments.length ? (alphaDecay = +_2, simulation) : +alphaDecay;
    },
    alphaTarget: function(_2) {
      return arguments.length ? (alphaTarget = +_2, simulation) : alphaTarget;
    },
    velocityDecay: function(_2) {
      return arguments.length ? (velocityDecay = 1 - _2, simulation) : 1 - velocityDecay;
    },
    randomSource: function(_2) {
      return arguments.length ? (random5 = _2, forces.forEach(initializeForce), simulation) : random5;
    },
    force: function(name, _2) {
      return arguments.length > 1 ? (_2 == null ? forces.delete(name) : forces.set(name, initializeForce(_2)), simulation) : forces.get(name);
    },
    find: function(x3, y3, radius) {
      var i = 0, n = nodes.length, dx, dy, d2, node, closest;
      if (radius == null) radius = Infinity;
      else radius *= radius;
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x3 - node.x;
        dy = y3 - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }
      return closest;
    },
    on: function(name, _2) {
      return arguments.length > 1 ? (event.on(name, _2), simulation) : event.on(name);
    }
  };
}

// node_modules/d3-force/src/manyBody.js
function manyBody_default() {
  var nodes, node, random5, alpha, strength = constant_default(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
  function force(_2) {
    var i, n = nodes.length, tree = quadtree(nodes, x2, y2).visitAfter(accumulate);
    for (alpha = _2, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
  }
  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node2;
    strengths = new Array(n);
    for (i = 0; i < n; ++i) node2 = nodes[i], strengths[node2.index] = +strength(node2, i, nodes);
  }
  function accumulate(quad) {
    var strength2 = 0, q, c2, weight = 0, x3, y3, i;
    if (quad.length) {
      for (x3 = y3 = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c2 = Math.abs(q.value))) {
          strength2 += q.value, weight += c2, x3 += c2 * q.x, y3 += c2 * q.y;
        }
      }
      quad.x = x3 / weight;
      quad.y = y3 / weight;
    } else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do
        strength2 += strengths[q.data.index];
      while (q = q.next);
    }
    quad.value = strength2;
  }
  function apply(quad, x1, _2, x22) {
    if (!quad.value) return true;
    var x3 = quad.x - node.x, y3 = quad.y - node.y, w = x22 - x1, l = x3 * x3 + y3 * y3;
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x3 === 0) x3 = jiggle_default(random5), l += x3 * x3;
        if (y3 === 0) y3 = jiggle_default(random5), l += y3 * y3;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x3 * quad.value * alpha / l;
        node.vy += y3 * quad.value * alpha / l;
      }
      return true;
    } else if (quad.length || l >= distanceMax2) return;
    if (quad.data !== node || quad.next) {
      if (x3 === 0) x3 = jiggle_default(random5), l += x3 * x3;
      if (y3 === 0) y3 = jiggle_default(random5), l += y3 * y3;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }
    do
      if (quad.data !== node) {
        w = strengths[quad.data.index] * alpha / l;
        node.vx += x3 * w;
        node.vy += y3 * w;
      }
    while (quad = quad.next);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random5 = _random;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : strength;
  };
  force.distanceMin = function(_2) {
    return arguments.length ? (distanceMin2 = _2 * _2, force) : Math.sqrt(distanceMin2);
  };
  force.distanceMax = function(_2) {
    return arguments.length ? (distanceMax2 = _2 * _2, force) : Math.sqrt(distanceMax2);
  };
  force.theta = function(_2) {
    return arguments.length ? (theta2 = _2 * _2, force) : Math.sqrt(theta2);
  };
  return force;
}

// node_modules/d3-force/src/radial.js
function radial_default(radius, x3, y3) {
  var nodes, strength = constant_default(0.1), strengths, radiuses;
  if (typeof radius !== "function") radius = constant_default(+radius);
  if (x3 == null) x3 = 0;
  if (y3 == null) y3 = 0;
  function force(alpha) {
    for (var i = 0, n = nodes.length; i < n; ++i) {
      var node = nodes[i], dx = node.x - x3 || 1e-6, dy = node.y - y3 || 1e-6, r = Math.sqrt(dx * dx + dy * dy), k = (radiuses[i] - r) * strengths[i] * alpha / r;
      node.vx += dx * k;
      node.vy += dy * k;
    }
  }
  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    radiuses = new Array(n);
    for (i = 0; i < n; ++i) {
      radiuses[i] = +radius(nodes[i], i, nodes);
      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2, initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : strength;
  };
  force.radius = function(_2) {
    return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : radius;
  };
  force.x = function(_2) {
    return arguments.length ? (x3 = +_2, force) : x3;
  };
  force.y = function(_2) {
    return arguments.length ? (y3 = +_2, force) : y3;
  };
  return force;
}

// node_modules/d3-force/src/x.js
function x_default2(x3) {
  var strength = constant_default(0.1), nodes, strengths, xz;
  if (typeof x3 !== "function") x3 = constant_default(x3 == null ? 0 : +x3);
  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }
  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x3(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : strength;
  };
  force.x = function(_2) {
    return arguments.length ? (x3 = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : x3;
  };
  return force;
}

// node_modules/d3-force/src/y.js
function y_default2(y3) {
  var strength = constant_default(0.1), nodes, strengths, yz;
  if (typeof y3 !== "function") y3 = constant_default(y3 == null ? 0 : +y3);
  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }
  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y3(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : strength;
  };
  force.y = function(_2) {
    return arguments.length ? (y3 = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : y3;
  };
  return force;
}

// node_modules/@antv/component/esm/util/angle-converter.js
function degToRad(deg2) {
  return deg2 * Math.PI / 180;
}
function radToDeg(rad2) {
  return Number((rad2 * 180 / Math.PI).toPrecision(5));
}

// node_modules/@antv/component/esm/util/bbox.js
var BBox = (
  /** @class */
  function() {
    function BBox2(x3, y3, width, height) {
      if (x3 === void 0) {
        x3 = 0;
      }
      if (y3 === void 0) {
        y3 = 0;
      }
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      this.x = 0;
      this.y = 0;
      this.width = 0;
      this.height = 0;
      this.x = x3;
      this.y = y3;
      this.width = width;
      this.height = height;
    }
    Object.defineProperty(BBox2.prototype, "bottom", {
      get: function() {
        return this.y + this.height;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "left", {
      get: function() {
        return this.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "right", {
      get: function() {
        return this.x + this.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "top", {
      get: function() {
        return this.y;
      },
      enumerable: false,
      configurable: true
    });
    BBox2.fromRect = function(other) {
      return new BBox2(other.x, other.y, other.width, other.height);
    };
    BBox2.prototype.toJSON = function() {
      return {
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height,
        top: this.top,
        right: this.right,
        bottom: this.bottom,
        left: this.left
      };
    };
    BBox2.prototype.isPointIn = function(x3, y3) {
      return x3 >= this.left && x3 <= this.right && y3 >= this.top && y3 <= this.bottom;
    };
    return BBox2;
  }()
);

// node_modules/@antv/component/esm/util/callback.js
function getCallbackValue(value, params) {
  return isFunction(value) ? value.apply(void 0, __spreadArray([], __read(params), false)) : value;
}

// node_modules/@antv/component/esm/util/classnames.js
var classNames = function(cls, prefix) {
  var PREFIX = function(str7) {
    return "".concat(prefix, "-").concat(str7);
  };
  var obj = Object.fromEntries(Object.entries(cls).map(function(_a2) {
    var _b = __read(_a2, 2), k = _b[0], v = _b[1];
    var name = PREFIX(v);
    return [
      k,
      {
        name,
        class: ".".concat(name),
        id: "#".concat(name),
        toString: function() {
          return name;
        }
      }
    ];
  }));
  Object.assign(obj, { prefix: PREFIX });
  return obj;
};

// node_modules/@antv/component/esm/util/deep-assign.js
var MAX_MIX_LEVEL2 = 5;
var deep = function(dist4, src, level, maxLevel) {
  if (level === void 0) {
    level = 0;
  }
  if (maxLevel === void 0) {
    maxLevel = MAX_MIX_LEVEL2;
  }
  Object.entries(src).forEach(function(_a2) {
    var _b = __read(_a2, 2), key = _b[0], value = _b[1];
    var res = dist4;
    if (Object.prototype.hasOwnProperty.call(src, key)) {
      if (!value) {
        res[key] = value;
      } else if (is_plain_object_default(value)) {
        if (!is_plain_object_default(dist4[key])) {
          res[key] = {};
        }
        if (level < maxLevel) {
          deep(dist4[key], value, level + 1, maxLevel);
        } else {
          res[key] = src[key];
        }
      } else if (isArray(value)) {
        res[key] = [];
        res[key] = res[key].concat(value);
      } else {
        res[key] = value;
      }
    }
  });
};
var deepAssign = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i = 0; i < args.length; i += 1) {
    deep(rst, args[i]);
  }
  return rst;
};

// node_modules/@antv/component/esm/util/defined.js
var defined = function(x3) {
  return x3 !== void 0 && x3 != null && !Number.isNaN(x3);
};

// node_modules/@antv/component/esm/util/text.js
var ctx;
var mockMeasureTextWidth;
var measureTextWidth = memoize(function(text, font) {
  var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  if (mockMeasureTextWidth) {
    return mockMeasureTextWidth(text, fontSize);
  }
  if (!ctx) {
    ctx = runtime.offscreenCanvasCreator.getOrCreateContext(void 0);
  }
  ctx.font = [fontStyle, fontVariant, fontWeight, "".concat(fontSize, "px"), fontFamily].join(" ");
  return ctx.measureText(text).width;
}, function(text, font) {
  return [text, Object.values(font || getFont(text)).join()].join("");
}, 4096);
var getFont = function(textShape) {
  var fontFamily = textShape.style.fontFamily || "sans-serif";
  var fontWeight = textShape.style.fontWeight || "normal";
  var fontStyle = textShape.style.fontStyle || "normal";
  var fontVariant = textShape.style.fontVariant;
  var fontSize = textShape.style.fontSize;
  fontSize = typeof fontSize === "object" ? fontSize.value : fontSize;
  return { fontSize, fontFamily, fontWeight, fontStyle, fontVariant };
};
function textOf(node) {
  if (node.nodeName === "text") {
    return node;
  }
  if (node.nodeName === "g" && node.children.length === 1 && node.children[0].nodeName === "text") {
    return node.children[0];
  }
  return null;
}
function applyToText(node, style) {
  var text = textOf(node);
  if (text)
    text.attr(style);
}

// node_modules/@antv/component/esm/util/ellipsis.js
function ellipsisIt(node, w, suffix) {
  if (suffix === void 0) {
    suffix = "...";
  }
  applyToText(node, { wordWrap: true, wordWrapWidth: w, maxLines: 1, textOverflow: suffix });
}

// node_modules/@antv/component/esm/util/wrap.js
function wrapIt(node, wordWrapWidth, maxLines, textBaseline) {
  if (maxLines === void 0) {
    maxLines = 2;
  }
  if (textBaseline === void 0) {
    textBaseline = "top";
  }
  applyToText(node, { wordWrap: true, wordWrapWidth, maxLines, textBaseline });
}

// node_modules/@antv/component/esm/util/event.js
function getEventPos(e) {
  var canvas = e.canvas, touches = e.touches, offsetX = e.offsetX, offsetY = e.offsetY;
  if (canvas) {
    var x3 = canvas.x, y3 = canvas.y;
    return [x3, y3];
  }
  if (touches) {
    var _a2 = touches[0], clientX = _a2.clientX, clientY = _a2.clientY;
    return [clientX, clientY];
  }
  if (offsetX && offsetY)
    return [offsetX, offsetY];
  return [0, 0];
}
function getEventViewportPos(e) {
  var nativeEvent = e.nativeEvent, touches = e.touches, clientX = e.clientX, clientY = e.clientY;
  if (nativeEvent) {
    return [nativeEvent.clientX, nativeEvent.clientY];
  }
  if (touches) {
    var _a2 = touches[0], clientX_1 = _a2.clientX, clientY_1 = _a2.clientY;
    return [clientX_1, clientY_1];
  }
  if (typeof clientX === "number" && typeof clientY === "number")
    return [clientX, clientY];
  return [0, 0];
}

// node_modules/@antv/component/esm/util/traverse.js
function traverse(element, callback) {
  callback(element);
  if (element.children) {
    element.children.forEach(function(child) {
      if (child)
        traverse(child, callback);
    });
  }
}

// node_modules/@antv/component/esm/util/visibility.js
function show(element) {
  visibility(element, true);
}
function hide(element) {
  visibility(element, false);
}
function visibility(element, visible) {
  var value = visible ? "visible" : "hidden";
  traverse(element, function(node) {
    node.attr("visibility", value);
  });
}

// node_modules/@antv/component/esm/util/offscreen.js
var OffscreenGroup = (
  /** @class */
  function(_super) {
    __extends(OffscreenGroup2, _super);
    function OffscreenGroup2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var _this2 = _super.apply(this, __spreadArray([], __read(args), false)) || this;
      _this2.isMutationObserved = true;
      _this2.addEventListener(ElementEvent.INSERTED, function() {
        hide(_this2);
      });
      return _this2;
    }
    return OffscreenGroup2;
  }(Group)
);
function createOffscreenGroup(container) {
  var group2 = container.appendChild(new OffscreenGroup({
    class: "offscreen"
  }));
  hide(group2);
  return group2;
}
function isInOffscreenGroup(group2) {
  var ancestor = group2;
  while (ancestor) {
    if (ancestor.className === "offscreen") {
      return true;
    }
    ancestor = ancestor.parent;
  }
  return false;
}

// node_modules/@antv/component/esm/shapes/Text.js
var Text2 = (
  /** @class */
  function(_super) {
    __extends(Text3, _super);
    function Text3(_a2) {
      if (_a2 === void 0) {
        _a2 = {};
      }
      var style = _a2.style, restOptions = __rest(_a2, ["style"]);
      return _super.call(this, __assign({ style: __assign({ text: "", fill: "black", fontFamily: "sans-serif", fontSize: 16, fontStyle: "normal", fontVariant: "normal", fontWeight: "normal", lineWidth: 1, textAlign: "start", textBaseline: "middle" }, style) }, restOptions)) || this;
    }
    Object.defineProperty(Text3.prototype, "offscreenGroup", {
      get: function() {
        if (!this._offscreen)
          this._offscreen = createOffscreenGroup(this);
        return this._offscreen;
      },
      enumerable: false,
      configurable: true
    });
    Text3.prototype.disconnectedCallback = function() {
      var _a2;
      (_a2 = this._offscreen) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    };
    return Text3;
  }(Text)
);

// node_modules/@antv/component/esm/util/extend-display-object.js
function renderExtDo(el) {
  if (typeof el === "function")
    return el();
  return isString(el) || isNumber(el) ? new Text2({ style: { text: String(el) } }) : el;
}
function renderHtmlExtDo(el, style) {
  if (typeof el === "function")
    return el();
  return isString(el) || isNumber(el) ? new HTML({
    style: __assign(__assign({ pointerEvents: "auto" }, style), { innerHTML: el })
  }) : el;
}

// node_modules/@antv/component/esm/util/geometry/lines-intersection.js
function inside(x1, x22, y1, y22, xk, yk) {
  return (x1 === x22 || Math.min(x1, x22) <= xk && xk <= Math.max(x1, x22)) && (y1 === y22 || Math.min(y1, y22) <= yk && yk <= Math.max(y1, y22));
}
function update(ans, x3, y3) {
  var out = ans;
  if (!ans.length || x3 < ans[0] || x3 === ans[0] && y3 < ans[1]) {
    out[0] = x3;
    out[1] = y3;
  }
}
function intersection(_a2, _b, _c, _d) {
  var _e = __read(_a2, 2), x1 = _e[0], y1 = _e[1];
  var _f = __read(_b, 2), x22 = _f[0], y22 = _f[1];
  var _g = __read(_c, 2), x3 = _g[0], y3 = _g[1];
  var _h = __read(_d, 2), x4 = _h[0], y4 = _h[1];
  var ans = [];
  if ((y4 - y3) * (x22 - x1) === (y22 - y1) * (x4 - x3)) {
    if ((y22 - y1) * (x3 - x1) === (y3 - y1) * (x22 - x1)) {
      if (inside(x1, x22, y1, y22, x3, y3)) {
        update(ans, x3, y3);
      }
      if (inside(x1, x22, y1, y22, x4, y4)) {
        update(ans, x4, y4);
      }
      if (inside(x3, x4, y3, y4, x1, y1)) {
        update(ans, x1, y1);
      }
      if (inside(x3, x4, y3, y4, x22, y22)) {
        update(ans, x22, y22);
      }
    }
  } else {
    var t1 = (x3 * (y4 - y3) + y1 * (x4 - x3) - y3 * (x4 - x3) - x1 * (y4 - y3)) / ((x22 - x1) * (y4 - y3) - (x4 - x3) * (y22 - y1));
    var t2 = (x1 * (y22 - y1) + y3 * (x22 - x1) - y1 * (x22 - x1) - x3 * (y22 - y1)) / ((x4 - x3) * (y22 - y1) - (x22 - x1) * (y4 - y3));
    if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
      ans[0] = x1 + t1 * (x22 - x1);
      ans[1] = y1 + t1 * (y22 - y1);
    }
  }
  return ans;
}

// node_modules/@antv/component/esm/util/geometry/line-length.js
function lineLen(_a2, _b) {
  var _c = __read(_a2, 2), x1 = _c[0], y1 = _c[1];
  var _d = __read(_b, 2), x22 = _d[0], y22 = _d[1];
  return Math.pow(Math.pow(x1 - x22, 2) + Math.pow(y1 - y22, 2), 0.5);
}

// node_modules/@antv/component/esm/util/group-by.js
function groupBy2(source, by) {
  return source.reduce(function(acc, curr) {
    (acc[curr[by]] = acc[curr[by]] || []).push(curr);
    return acc;
  }, {});
}

// node_modules/@antv/component/esm/util/if-show.js
function ifShow(show2, container, creator, removeChildren, removeHandler) {
  if (removeChildren === void 0) {
    removeChildren = true;
  }
  if (removeHandler === void 0) {
    removeHandler = function(g) {
      g.node().removeChildren();
    };
  }
  if (show2) {
    return creator(container);
  }
  if (removeChildren)
    removeHandler(container);
  return null;
}

// node_modules/@antv/component/esm/util/in-range.js
function inRange(n, start, end, includeLeft, includeRight) {
  if (includeLeft === void 0) {
    includeLeft = true;
  }
  if (includeRight === void 0) {
    includeRight = false;
  }
  if (includeLeft && n === start || includeRight && n === end)
    return true;
  return n > start && n < end;
}

// node_modules/@antv/component/esm/util/interpolate.js
var numberInterpolate = function(from, to) {
  return function(t) {
    return from * (1 - t) + to * t;
  };
};
function arrayInterpolate(from, to) {
  var nb = to ? to.length : 0;
  var na = from ? Math.min(nb, from.length) : 0;
  return function(t) {
    var x3 = new Array(na);
    var c2 = new Array(nb);
    var i = 0;
    for (i = 0; i < na; ++i)
      x3[i] = interpolate2(from[i], to[i]);
    for (; i < nb; ++i)
      c2[i] = to[i];
    for (i = 0; i < na; ++i)
      c2[i] = x3[i](t);
    return c2;
  };
}
function objectInterpolate(from, to) {
  if (from === void 0) {
    from = {};
  }
  if (to === void 0) {
    to = {};
  }
  var i = {};
  var c2 = {};
  Object.entries(to).forEach(function(_a2) {
    var _b = __read(_a2, 2), k = _b[0], v = _b[1];
    if (k in from)
      i[k] = interpolate2(from[k], v);
    else
      c2[k] = v;
  });
  return function(t) {
    Object.entries(i).forEach(function(_a2) {
      var _b = __read(_a2, 2), k = _b[0], v = _b[1];
      return c2[k] = v(t);
    });
    return c2;
  };
}
function interpolate2(from, to) {
  if (typeof from === "number" && typeof to === "number") {
    return numberInterpolate(from, to);
  }
  if (Array.isArray(from) && Array.isArray(to)) {
    return arrayInterpolate(from, to);
  }
  if (typeof from === "object" && typeof to === "object") {
    return objectInterpolate(from, to);
  }
  return function(t) {
    return from;
  };
}

// node_modules/@antv/component/esm/util/keyframe-interpolate.js
function keyframeInterpolate(element, from, to, options) {
  if (!options) {
    element.attr("__keyframe_data__", to);
    return null;
  }
  var _a2 = options.duration, duration = _a2 === void 0 ? 0 : _a2;
  var int = interpolate2(from, to);
  var count = Math.ceil(+duration / 16);
  var keyframes = new Array(count).fill(0).map(function(datum, index2, array) {
    return { __keyframe_data__: int(index2 / (array.length - 1)) };
  });
  return element.animate(keyframes, __assign({ fill: "both" }, options));
}

// node_modules/@antv/component/esm/util/layout/utils/helper.js
function getItemsBBox(items) {
  var minX = Infinity;
  var minY = Infinity;
  var maxX = -Infinity;
  var maxY = -Infinity;
  for (var i = 0; i < items.length; i++) {
    var _a2 = items[i], x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
    var _b = __read([x3 + width, y3 + height], 2), X = _b[0], Y = _b[1];
    if (x3 < minX)
      minX = x3;
    if (y3 < minY)
      minY = y3;
    if (X > maxX)
      maxX = X;
    if (Y > maxY)
      maxY = Y;
  }
  return new BBox(minX, minY, maxX - minX, maxY - minY);
}

// node_modules/@antv/component/esm/util/layout/flex/index.js
var flex = function(container, children, config) {
  var width = container.width, height = container.height;
  var _a2 = config.flexDirection, flexDirection = _a2 === void 0 ? "row" : _a2, _b = config.flexWrap, flexWrap = _b === void 0 ? "nowrap" : _b, _c = config.justifyContent, justifyContent = _c === void 0 ? "flex-start" : _c, _d = config.alignContent, alignContent = _d === void 0 ? "flex-start" : _d, _e = config.alignItems, alignItems = _e === void 0 ? "flex-start" : _e;
  var isHorizontalFlow = flexDirection === "row";
  var isLeftToRightFlow = flexDirection === "row" || flexDirection === "column";
  var direction3 = isHorizontalFlow ? isLeftToRightFlow ? [1, 0] : [-1, 0] : isLeftToRightFlow ? [0, 1] : [0, -1];
  var _f = __read([0, 0], 2), offsetX = _f[0], offsetY = _f[1];
  var itemsFromDirection = children.map(function(child) {
    var _a3;
    var width2 = child.width, height2 = child.height;
    var _b2 = __read([offsetX, offsetY], 2), x3 = _b2[0], y3 = _b2[1];
    _a3 = __read([offsetX + width2 * direction3[0], offsetY + height2 * direction3[1]], 2), offsetX = _a3[0], offsetY = _a3[1];
    return new BBox(x3, y3, width2, height2);
  });
  var itemsForJustifyContentBBox = getItemsBBox(itemsFromDirection);
  var justifyContentOffset = {
    "flex-start": 0,
    "flex-end": isHorizontalFlow ? width - itemsForJustifyContentBBox.width : height - itemsForJustifyContentBBox.height,
    center: isHorizontalFlow ? (width - itemsForJustifyContentBBox.width) / 2 : (height - itemsForJustifyContentBBox.height) / 2
  };
  var itemsFromJustifyContent = itemsFromDirection.map(function(item) {
    var x3 = item.x, y3 = item.y;
    var itemBox = BBox.fromRect(item);
    itemBox.x = isHorizontalFlow ? x3 + justifyContentOffset[justifyContent] : x3;
    itemBox.y = isHorizontalFlow ? y3 : y3 + justifyContentOffset[justifyContent];
    return itemBox;
  });
  var itemsForAlignItemsBBox = getItemsBBox(itemsFromJustifyContent);
  var calcAlignItemsOffset = function(box2) {
    var _a3 = __read(isHorizontalFlow ? ["height", height] : ["width", width], 2), key = _a3[0], size2 = _a3[1];
    switch (alignItems) {
      case "flex-start":
        return 0;
      case "flex-end":
        return size2 - box2[key];
      case "center":
        return size2 / 2 - box2[key] / 2;
      default:
        return 0;
    }
  };
  var itemsFromAlignItems = itemsFromJustifyContent.map(function(item) {
    var x3 = item.x, y3 = item.y;
    var itemBox = BBox.fromRect(item);
    itemBox.x = isHorizontalFlow ? x3 : x3 + calcAlignItemsOffset(itemBox);
    itemBox.y = isHorizontalFlow ? y3 + calcAlignItemsOffset(itemBox) : y3;
    return itemBox;
  });
  var finalItems = itemsFromAlignItems.map(function(item) {
    var _a3, _b2;
    var itemBox = BBox.fromRect(item);
    itemBox.x += (_a3 = container.x) !== null && _a3 !== void 0 ? _a3 : 0;
    itemBox.y += (_b2 = container.y) !== null && _b2 !== void 0 ? _b2 : 0;
    return itemBox;
  });
  return finalItems;
};

// node_modules/@antv/component/esm/util/layout/grid/index.js
var grid = function(container, children, config) {
  return [];
};

// node_modules/@antv/component/esm/util/layout/executer.js
var executer_default = function(container, children, config) {
  if (children.length === 0)
    return [];
  var callers = { flex, grid };
  var caller = config.display in callers ? callers[config.display] : null;
  return (caller === null || caller === void 0 ? void 0 : caller.call(null, container, children, config)) || [];
};

// node_modules/@antv/component/esm/util/matrix.js
function scale8(vec, s2) {
  return [vec[0] * s2, vec[1] * s2];
}
function add8(vec1, vec2) {
  return [vec1[0] + vec2[0], vec1[1] + vec2[1]];
}
function sub6(vec1, vec2) {
  return [vec1[0] - vec2[0], vec1[1] - vec2[1]];
}
function min4(vec1, vec2) {
  return [Math.min(vec1[0], vec2[0]), Math.min(vec1[1], vec2[1])];
}
function max5(vec1, vec2) {
  return [Math.max(vec1[0], vec2[0]), Math.max(vec1[1], vec2[1])];
}
function distance5(vec1, vec2) {
  return Math.sqrt(Math.pow(vec1[0] - vec2[0], 2) + Math.pow(vec1[1] - vec2[1], 2));
}
function normalize6(vec) {
  if (vec[0] === 0 && vec[1] === 0)
    return [0, 0];
  var len5 = Math.sqrt(Math.pow(vec[0], 2) + Math.pow(vec[1], 2));
  return [vec[0] / len5, vec[1] / len5];
}
function rotate5(vec, origin, angle3) {
  var _a2 = __read(vec, 2), x3 = _a2[0], y3 = _a2[1];
  var _b = __read(origin, 2), ox = _b[0], oy = _b[1];
  var dx = x3 - ox;
  var dy = y3 - oy;
  var sin = Math.sin(angle3);
  var cos = Math.cos(angle3);
  return [dx * cos - dy * sin + ox, dx * sin + dy * cos + oy];
}
function vertical2(vec, flag) {
  return flag ? [vec[1], -vec[0]] : [-vec[1], vec[0]];
}

// node_modules/@antv/component/esm/util/number.js
function toPrecision(num, precision) {
  return +num.toPrecision(precision);
}

// node_modules/@antv/component/esm/util/omit.js
function omit(obj, keys2) {
  var res = {};
  var innerKeys = Array.isArray(keys2) ? keys2 : [keys2];
  for (var key in obj) {
    if (!innerKeys.includes(key)) {
      res[key] = obj[key];
    }
  }
  return res;
}

// node_modules/@antv/component/esm/util/path.js
function smoothBezier(points, smooth2, isLoop, constraint) {
  var _a2;
  var cps = [];
  var hasConstraint = !!constraint;
  var prevPoint;
  var nextPoint;
  var min5 = [Infinity, Infinity];
  var max6 = [-Infinity, -Infinity];
  var nextCp0;
  var cp1;
  var cp0;
  if (hasConstraint) {
    _a2 = __read(constraint, 2), min5 = _a2[0], max6 = _a2[1];
    for (var i = 0, l = points.length; i < l; i += 1) {
      var point2 = points[i];
      min5 = min4(min5, point2);
      max6 = max5(max6, point2);
    }
  }
  for (var i = 0, len5 = points.length; i < len5; i += 1) {
    var point2 = points[i];
    if (i === 0 && !isLoop) {
      cp0 = point2;
    } else if (i === len5 - 1 && !isLoop) {
      cp1 = point2;
      cps.push(cp0);
      cps.push(cp1);
    } else {
      var prevIdx = [i ? i - 1 : len5 - 1, i - 1][isLoop ? 0 : 1];
      prevPoint = points[prevIdx];
      nextPoint = points[isLoop ? (i + 1) % len5 : i + 1];
      var v = [0, 0];
      v = sub6(nextPoint, prevPoint);
      v = scale8(v, smooth2);
      var d0 = distance5(point2, prevPoint);
      var d1 = distance5(point2, nextPoint);
      var sum = d0 + d1;
      if (sum !== 0) {
        d0 /= sum;
        d1 /= sum;
      }
      var v1 = scale8(v, -d0);
      var v2 = scale8(v, d1);
      cp1 = add8(point2, v1);
      nextCp0 = add8(point2, v2);
      nextCp0 = min4(nextCp0, max5(nextPoint, point2));
      nextCp0 = max5(nextCp0, min4(nextPoint, point2));
      v1 = sub6(nextCp0, point2);
      v1 = scale8(v1, -d0 / d1);
      cp1 = add8(point2, v1);
      cp1 = min4(cp1, max5(prevPoint, point2));
      cp1 = max5(cp1, min4(prevPoint, point2));
      v2 = sub6(point2, cp1);
      v2 = scale8(v2, d1 / d0);
      nextCp0 = add8(point2, v2);
      if (hasConstraint) {
        cp1 = max5(cp1, min5);
        cp1 = min4(cp1, max6);
        nextCp0 = max5(nextCp0, min5);
        nextCp0 = min4(nextCp0, max6);
      }
      cps.push(cp0);
      cps.push(cp1);
      cp0 = nextCp0;
    }
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
}
function catmullRom2Bezier(crp, z, constraint) {
  var _a2;
  if (z === void 0) {
    z = false;
  }
  if (constraint === void 0) {
    constraint = [
      [0, 0],
      [1, 1]
    ];
  }
  var isLoop = !!z;
  var pointList = [];
  for (var i = 0, l = crp.length; i < l; i += 2) {
    pointList.push([crp[i], crp[i + 1]]);
  }
  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
  var len5 = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p;
  for (var i = 0; i < len5 - 1; i += 1) {
    cp1 = controlPointList[i * 2];
    cp2 = controlPointList[i * 2 + 1];
    p = pointList[i + 1];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  if (isLoop) {
    cp1 = controlPointList[len5];
    cp2 = controlPointList[len5 + 1];
    _a2 = __read(pointList, 1), p = _a2[0];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  return d1;
}

// node_modules/@antv/component/esm/util/primitive.js
var PRIMILTIVE_ATTRIBUTES = [
  "$el",
  "cx",
  "cy",
  "d",
  "dx",
  "dy",
  "fill",
  "fillOpacity",
  "filter",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontVariant",
  "fontWeight",
  "height",
  "img",
  "increasedLineWidthForHitTesting",
  "innerHTML",
  "isBillboard",
  "billboardRotation",
  "isSizeAttenuation",
  "isClosed",
  "isOverflowing",
  "leading",
  "letterSpacing",
  "lineDash",
  "lineHeight",
  "lineWidth",
  "markerEnd",
  "markerEndOffset",
  "markerMid",
  "markerStart",
  "markerStartOffset",
  "maxLines",
  "metrics",
  "miterLimit",
  "offsetX",
  "offsetY",
  "opacity",
  "path",
  "points",
  "r",
  "radius",
  "rx",
  "ry",
  "shadowColor",
  "src",
  "stroke",
  "strokeOpacity",
  "text",
  "textAlign",
  "textBaseline",
  "textDecorationColor",
  "textDecorationLine",
  "textDecorationStyle",
  "textOverflow",
  "textPath",
  "textPathSide",
  "textPathStartOffset",
  "transform",
  "transformOrigin",
  "visibility",
  "width",
  "wordWrap",
  "wordWrapWidth",
  "x",
  "x1",
  "x2",
  "y",
  "y1",
  "y2",
  "z1",
  "z2",
  "zIndex"
];
function isPrimitiveAttribute(key) {
  return PRIMILTIVE_ATTRIBUTES.includes(key);
}
function getPrimitiveAttributes(attributes) {
  var object = {};
  for (var key in attributes) {
    if (isPrimitiveAttribute(key))
      object[key] = attributes[key];
  }
  return object;
}

// node_modules/@antv/component/esm/util/sampling.js
function sampling(data2, size2) {
  if (data2.length <= size2)
    return data2;
  var step2 = Math.floor(data2.length / size2);
  var result = [];
  for (var i = 0; i < data2.length; i += step2) {
    result.push(data2[i]);
  }
  return result;
}

// node_modules/@antv/component/esm/util/scale-to-pixel.js
function scaleToPixel(el, size2, applyScale) {
  if (applyScale === void 0) {
    applyScale = false;
  }
  var _a2 = el.getBBox(), width = _a2.width, height = _a2.height;
  var scale9 = size2 / Math.max(width, height);
  if (applyScale) {
    el.style.transform = "scale(".concat(scale9, ")");
  }
  return scale9;
}

// node_modules/@antv/component/esm/util/group.js
function group(array, keyFunc) {
  var grouped = /* @__PURE__ */ new Map();
  array.forEach(function(item) {
    var key = keyFunc(item);
    if (!grouped.has(key)) {
      grouped.set(key, []);
    }
    grouped.get(key).push(item);
  });
  return grouped;
}

// node_modules/@antv/component/esm/util/selection.js
function error(msg) {
  throw new Error(msg);
}
var Selection = (
  /** @class */
  function() {
    function Selection2(elements, data2, parent, document2, selections, transitions, updateElements) {
      if (elements === void 0) {
        elements = null;
      }
      if (data2 === void 0) {
        data2 = null;
      }
      if (parent === void 0) {
        parent = null;
      }
      if (document2 === void 0) {
        document2 = null;
      }
      if (selections === void 0) {
        selections = [null, null, null, null, null];
      }
      if (transitions === void 0) {
        transitions = [];
      }
      if (updateElements === void 0) {
        updateElements = [];
      }
      _Selection_instances.add(this);
      this._elements = Array.from(elements);
      this._data = data2;
      this._parent = parent;
      this._document = document2;
      this._enter = selections[0];
      this._update = selections[1];
      this._exit = selections[2];
      this._merge = selections[3];
      this._split = selections[4];
      this._transitions = transitions;
      this._facetElements = updateElements;
    }
    Selection2.prototype.selectAll = function(selector) {
      var elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
      return new _a2(elements, null, this._elements[0], this._document);
    };
    Selection2.prototype.selectFacetAll = function(selector) {
      var elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
      return new _a2(this._elements, null, this._parent, this._document, void 0, void 0, elements);
    };
    Selection2.prototype.select = function(selector) {
      var element = typeof selector === "string" ? this._parent.querySelectorAll(selector)[0] || null : selector;
      return new _a2([element], null, element, this._document);
    };
    Selection2.prototype.append = function(node) {
      var _this2 = this;
      var callback = typeof node === "function" ? node : function() {
        return _this2.createElement(node);
      };
      var elements = [];
      if (this._data !== null) {
        for (var i = 0; i < this._data.length; i++) {
          var d2 = this._data[i];
          var _b = __read(Array.isArray(d2) ? d2 : [d2, null], 2), datum = _b[0], from = _b[1];
          var newElement = callback(datum, i);
          newElement.__data__ = datum;
          if (from !== null)
            newElement.__fromElements__ = from;
          this._parent.appendChild(newElement);
          elements.push(newElement);
        }
        return new _a2(elements, null, this._parent, this._document);
      }
      for (var i = 0; i < this._elements.length; i++) {
        var element = this._elements[i];
        var datum = element.__data__;
        var newElement = callback(datum, i);
        element.appendChild(newElement);
        elements.push(newElement);
      }
      return new _a2(elements, null, elements[0], this._document);
    };
    Selection2.prototype.maybeAppend = function(id3, node) {
      var element = __classPrivateFieldGet(this, _Selection_instances, "m", _Selection_maybeAppend).call(this, id3[0] === "#" ? id3 : "#".concat(id3), node);
      element.attr("id", id3);
      return element;
    };
    Selection2.prototype.maybeAppendByClassName = function(className, node) {
      var cls = className.toString();
      var element = __classPrivateFieldGet(this, _Selection_instances, "m", _Selection_maybeAppend).call(this, cls[0] === "." ? cls : ".".concat(cls), node);
      element.attr("className", cls);
      return element;
    };
    Selection2.prototype.maybeAppendByName = function(name, node) {
      var element = __classPrivateFieldGet(this, _Selection_instances, "m", _Selection_maybeAppend).call(this, '[name="'.concat(name, '"]'), node);
      element.attr("name", name);
      return element;
    };
    Selection2.prototype.data = function(data2, id3, groupId) {
      var e_1, _b;
      if (id3 === void 0) {
        id3 = function(d2) {
          return d2;
        };
      }
      if (groupId === void 0) {
        groupId = function() {
          return null;
        };
      }
      var enter = [];
      var update2 = [];
      var exit = new Set(this._elements);
      var merge = [];
      var split = /* @__PURE__ */ new Set();
      var keyElement = new Map(this._elements.map(function(d2, i2) {
        return [id3(d2.__data__, i2), d2];
      }));
      var keyUpdateElement = new Map(this._facetElements.map(function(d2, i2) {
        return [id3(d2.__data__, i2), d2];
      }));
      var groupKeyElements = group(this._elements, function(d2) {
        return groupId(d2.__data__);
      });
      for (var i = 0; i < data2.length; i++) {
        var datum = data2[i];
        var key = id3(datum, i);
        var groupKey = groupId(datum, i);
        if (keyElement.has(key)) {
          var element = keyElement.get(key);
          element.__data__ = datum;
          element.__facet__ = false;
          update2.push(element);
          exit.delete(element);
          keyElement.delete(key);
        } else if (keyUpdateElement.has(key)) {
          var element = keyUpdateElement.get(key);
          element.__data__ = datum;
          element.__facet__ = true;
          update2.push(element);
          keyUpdateElement.delete(key);
        } else if (groupKeyElements.has(key)) {
          var group_2 = groupKeyElements.get(key);
          merge.push([datum, group_2]);
          try {
            for (var group_1 = (e_1 = void 0, __values(group_2)), group_1_1 = group_1.next(); !group_1_1.done; group_1_1 = group_1.next()) {
              var element = group_1_1.value;
              exit.delete(element);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (group_1_1 && !group_1_1.done && (_b = group_1.return)) _b.call(group_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          groupKeyElements.delete(key);
        } else if (keyElement.has(groupKey)) {
          var element = keyElement.get(groupKey);
          if (element.__toData__)
            element.__toData__.push(datum);
          else
            element.__toData__ = [datum];
          split.add(element);
          exit.delete(element);
        } else {
          enter.push(datum);
        }
      }
      var S = [
        new _a2([], enter, this._parent, this._document),
        new _a2(update2, null, this._parent, this._document),
        new _a2(exit, null, this._parent, this._document),
        new _a2([], merge, this._parent, this._document),
        new _a2(split, null, this._parent, this._document)
      ];
      return new _a2(this._elements, null, this._parent, this._document, S);
    };
    Selection2.prototype.merge = function(other) {
      var elements = __spreadArray(__spreadArray([], __read(this._elements), false), __read(other._elements), false);
      var transitions = __spreadArray(__spreadArray([], __read(this._transitions), false), __read(other._transitions), false);
      return new _a2(elements, null, this._parent, this._document, void 0, transitions);
    };
    Selection2.prototype.createElement = function(type) {
      if (this._document) {
        return this._document.createElement(type, {});
      }
      var Ctor = _a2.registry[type];
      if (Ctor)
        return new Ctor();
      return error("Unknown node type: ".concat(type));
    };
    Selection2.prototype.join = function(enter, update2, exit, merge, split) {
      if (enter === void 0) {
        enter = function(d2) {
          return d2;
        };
      }
      if (update2 === void 0) {
        update2 = function(d2) {
          return d2;
        };
      }
      if (exit === void 0) {
        exit = function(d2) {
          return d2.remove();
        };
      }
      if (merge === void 0) {
        merge = function(d2) {
          return d2;
        };
      }
      if (split === void 0) {
        split = function(d2) {
          return d2.remove();
        };
      }
      var newEnter = enter(this._enter);
      var newUpdate = update2(this._update);
      var newExit = exit(this._exit);
      var newMerge = merge(this._merge);
      var newSplit = split(this._split);
      return newUpdate.merge(newEnter).merge(newExit).merge(newMerge).merge(newSplit);
    };
    Selection2.prototype.remove = function() {
      var _loop_1 = function(i2) {
        var element = this_1._elements[i2];
        var transition2 = this_1._transitions[i2];
        if (transition2) {
          transition2.then(function() {
            return element.remove();
          });
        } else {
          element.remove();
        }
      };
      var this_1 = this;
      for (var i = 0; i < this._elements.length; i++) {
        _loop_1(i);
      }
      return new _a2([], null, this._parent, this._document, void 0, this._transitions);
    };
    Selection2.prototype.each = function(callback) {
      for (var i = 0; i < this._elements.length; i++) {
        var element = this._elements[i];
        var datum = element.__data__;
        callback.call(element, datum, i);
      }
      return this;
    };
    Selection2.prototype.attr = function(key, value) {
      var callback = typeof value !== "function" ? function() {
        return value;
      } : value;
      return this.each(function(d2, i) {
        if (value !== void 0)
          this[key] = callback.call(this, d2, i);
      });
    };
    Selection2.prototype.style = function(key, value, callable) {
      if (callable === void 0) {
        callable = true;
      }
      var callback = typeof value !== "function" || !callable ? function() {
        return value;
      } : value;
      return this.each(function(d2, i) {
        if (value !== void 0)
          this.style[key] = callback.call(this, d2, i);
      });
    };
    Selection2.prototype.styles = function(style, callable) {
      if (style === void 0) {
        style = {};
      }
      if (callable === void 0) {
        callable = true;
      }
      return this.each(function(d2, i) {
        var _this2 = this;
        Object.entries(style).forEach(function(_b) {
          var _c = __read(_b, 2), key = _c[0], value = _c[1];
          var callback = typeof value !== "function" || !callable ? function() {
            return value;
          } : value;
          if (value !== void 0)
            _this2.attr(key, callback.call(_this2, d2, i));
        });
      });
    };
    Selection2.prototype.update = function(option, callable) {
      if (callable === void 0) {
        callable = true;
      }
      var callback = typeof option !== "function" || !callable ? function() {
        return option;
      } : option;
      return this.each(function(d2, i) {
        if (option && this.update)
          this.update(callback.call(this, d2, i));
      });
    };
    Selection2.prototype.maybeUpdate = function(option, callable) {
      if (callable === void 0) {
        callable = true;
      }
      var callback = typeof option !== "function" || !callable ? function() {
        return option;
      } : option;
      return this.each(function(d2, i) {
        if (option && this.update)
          this.update(callback.call(this, d2, i));
      });
    };
    Selection2.prototype.transition = function(callback) {
      var T = this._transitions;
      var newTransitions = new Array(this._elements.length);
      this.each(function(d2, i) {
        newTransitions[i] = callback.call(this, d2, i);
      });
      this._transitions = flatten_default(newTransitions);
      return this;
    };
    Selection2.prototype.on = function(event, handler) {
      this.each(function() {
        this.addEventListener(event, handler);
      });
      return this;
    };
    Selection2.prototype.call = function(callback) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      callback.call.apply(callback, __spreadArray([this._parent, this], __read(args), false));
      return this;
    };
    Selection2.prototype.node = function() {
      return this._elements[0];
    };
    Selection2.prototype.nodes = function() {
      return this._elements;
    };
    Selection2.prototype.transitions = function() {
      return this._transitions.filter(function(t) {
        return !!t;
      });
    };
    Selection2.prototype.parent = function() {
      return this._parent;
    };
    var _Selection_instances, _a2, _Selection_maybeAppend;
    _a2 = Selection2, _Selection_instances = /* @__PURE__ */ new WeakSet(), _Selection_maybeAppend = function _Selection_maybeAppend2(selector, node) {
      var element = this._elements[0];
      var child = element.querySelector(selector);
      if (child)
        return new _a2([child], null, this._parent, this._document);
      var newChild = typeof node === "string" ? this.createElement(node) : node();
      element.appendChild(newChild);
      return new _a2([newChild], null, this._parent, this._document);
    };
    Selection2.registry = {
      g: Group,
      rect: Rect,
      circle: Circle,
      path: Path,
      text: Text2,
      ellipse: Ellipse,
      image: Image2,
      line: Line,
      polygon: Polygon,
      polyline: Polyline,
      html: HTML
    };
    return Selection2;
  }()
);
function select(node) {
  return new Selection([node], null, node, node.ownerDocument);
}
function maybeAppend(parent, selector, node) {
  if (!parent.querySelector(selector)) {
    return select(parent).append(node);
  }
  return select(parent).select(selector);
}

// node_modules/@antv/component/esm/util/series.js
function parseSeriesAttr(series) {
  if (isNumber(series)) {
    return [series, series, series, series];
  }
  if (isArray(series)) {
    var len5 = series.length;
    if (len5 === 1) {
      return [series[0], series[0], series[0], series[0]];
    }
    if (len5 === 2) {
      return [series[0], series[1], series[0], series[1]];
    }
    if (len5 === 3) {
      return [series[0], series[1], series[2], series[1]];
    }
    if (len5 === 4) {
      return series;
    }
  }
  return [0, 0, 0, 0];
}

// node_modules/@antv/component/esm/util/shape.js
function getShapeSpace(shape) {
  var bounds = shape && shape.getRenderBounds();
  if (!bounds)
    return {
      width: 0,
      height: 0
    };
  var max6 = bounds.getMax();
  var min5 = bounds.getMin();
  return {
    width: max6[0] - min5[0],
    height: max6[1] - min5[1]
  };
}
function getLocalBBox(shape) {
  var _a2 = shape.getLocalBounds(), min5 = _a2.min, max6 = _a2.max;
  var _b = __read([min5, max6], 2), _c = __read(_b[0], 2), x1 = _c[0], y1 = _c[1], _d = __read(_b[1], 2), x22 = _d[0], y22 = _d[1];
  return { x: x1, y: y1, width: x22 - x1, height: y22 - y1, left: x1, bottom: y22, top: y1, right: x22 };
}
function isHorizontal(p1, p2) {
  var _a2 = __read(p1, 2), x1 = _a2[0], y1 = _a2[1];
  var _b = __read(p2, 2), x22 = _b[0], y22 = _b[1];
  return x1 !== x22 && y1 === y22;
}
function copyAttributes(target, source) {
  var e_1, _a2;
  var attributes = source.attributes;
  try {
    for (var _b = __values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
      if (key !== "id" && key !== "className")
        target.attr(key, value);
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
}

// node_modules/@antv/component/esm/util/string.js
function toUppercaseFirstLetter(string) {
  return string.toString().charAt(0).toUpperCase() + string.toString().slice(1);
}
function toLowercaseFirstLetter(string) {
  return string.toString().charAt(0).toLowerCase() + string.toString().slice(1);
}
function addPrefix(string, prefix) {
  return "".concat(prefix).concat(toUppercaseFirstLetter(string));
}
function removePrefix(string, prefix, lowercaseFirstLetter) {
  var _a2;
  if (lowercaseFirstLetter === void 0) {
    lowercaseFirstLetter = true;
  }
  var inferPrefix = prefix || ((_a2 = string.match(/^([a-z][a-z0-9]+)/)) === null || _a2 === void 0 ? void 0 : _a2[0]) || "";
  var withoutPrefix = string.replace(new RegExp("^(".concat(inferPrefix, ")")), "");
  return lowercaseFirstLetter ? toLowercaseFirstLetter(withoutPrefix) : withoutPrefix;
}

// node_modules/@antv/component/esm/util/style.js
function applyStyleSheet(element, style) {
  Object.entries(style).forEach(function(_a2) {
    var _b = __read(_a2, 2), selector = _b[0], styleString = _b[1];
    __spreadArray([element], __read(element.querySelectorAll(selector)), false).filter(function(el) {
      return el.matches(selector);
    }).forEach(function(target) {
      if (!target)
        return;
      var temp = target;
      temp.style.cssText += Object.entries(styleString).reduce(function(total, currVal) {
        return "".concat(total).concat(currVal.join(":"), ";");
      }, "");
    });
  });
}
var startsWith = function(text, prefix) {
  if (!(text === null || text === void 0 ? void 0 : text.startsWith(prefix)))
    return false;
  var nextChart = text[prefix.length];
  return nextChart >= "A" && nextChart <= "Z";
};
function subStyleProps(style, prefix, invert4) {
  if (invert4 === void 0) {
    invert4 = false;
  }
  var result = {};
  Object.entries(style).forEach(function(_a2) {
    var _b = __read(_a2, 2), key = _b[0], value = _b[1];
    if (key === "className" || key === "class") {
    } else if (startsWith(key, "show") && startsWith(removePrefix(key, "show"), prefix) !== invert4) {
      if (key === addPrefix(prefix, "show"))
        result[key] = value;
      else
        result[key.replace(new RegExp(toUppercaseFirstLetter(prefix)), "")] = value;
    } else if (!startsWith(key, "show") && startsWith(key, prefix) !== invert4) {
      var name_1 = removePrefix(key, prefix);
      if (name_1 === "filter" && typeof value === "function") {
      } else
        result[name_1] = value;
    }
  });
  return result;
}
function superStyleProps(style, prefix) {
  return Object.entries(style).reduce(function(acc, _a2) {
    var _b = __read(_a2, 2), key = _b[0], value = _b[1];
    if (key.startsWith("show"))
      acc["show".concat(prefix).concat(key.slice(4))] = value;
    else
      acc["".concat(prefix).concat(toUppercaseFirstLetter(key))] = value;
    return acc;
  }, {});
}
function splitStyle(style, ignoreStyleDict) {
  if (ignoreStyleDict === void 0) {
    ignoreStyleDict = ["x", "y", "class", "className"];
  }
  var groupStyleDict = [
    "transform",
    "transformOrigin",
    "anchor",
    "visibility",
    "pointerEvents",
    "zIndex",
    "cursor",
    "clipPath",
    "clipPathTargets",
    "offsetPath",
    "offsetPathTargets",
    "offsetDistance",
    "draggable",
    "droppable"
  ];
  var output = {};
  var groupStyle = {};
  Object.entries(style).forEach(function(_a2) {
    var _b = __read(_a2, 2), key = _b[0], val = _b[1];
    if (ignoreStyleDict.includes(key)) {
    } else if (groupStyleDict.indexOf(key) !== -1)
      groupStyle[key] = val;
    else
      output[key] = val;
  });
  return [output, groupStyle];
}

// node_modules/@antv/component/esm/util/svg2marker.js
var import_svg_path_parser = __toESM(require_svg_path_parser());

// node_modules/@antv/component/esm/util/time.js
function formatTime(date, mask) {
  var timeMap = {
    YYYY: date.getFullYear(),
    MM: date.getMonth() + 1,
    DD: date.getDate(),
    HH: date.getHours(),
    mm: date.getMinutes(),
    ss: date.getSeconds()
  };
  var strftime = mask;
  Object.keys(timeMap).forEach(function(key) {
    var val = timeMap[key];
    strftime = strftime.replace(key, key === "YYYY" ? "".concat(val) : "".concat(val).padStart(2, "0"));
  });
  return strftime;
}

// node_modules/@antv/component/esm/util/transform.js
function getTranslate(node, x3, y3) {
  var _a2 = node.getBBox(), width = _a2.width, height = _a2.height;
  var _b = __read([x3, y3].map(function(v, i) {
    var _a3;
    return v.includes("%") ? parseFloat(((_a3 = v.match(/[+-]?([0-9]*[.])?[0-9]+/)) === null || _a3 === void 0 ? void 0 : _a3[0]) || "0") / 100 * (i === 0 ? width : height) : v;
  }), 2), tx = _b[0], ty = _b[1];
  return [tx, ty];
}
function percentTransform(node, val) {
  if (!val)
    return;
  try {
    var reg = /translate\(([+-]*[\d]+[%]*),[ ]*([+-]*[\d]+[%]*)\)/g;
    var computedVal = val.replace(reg, function(match, x3, y3) {
      return "translate(".concat(getTranslate(node, x3, y3), ")");
    });
    node.attr("transform", computedVal);
  } catch (e) {
  }
}

// node_modules/@antv/component/esm/util/transpose.js
function transpose3(m2) {
  var _a2;
  return ((_a2 = m2[0]) === null || _a2 === void 0 ? void 0 : _a2.map(function(x3, i) {
    return m2.map(function(x4) {
      return x4[i];
    });
  })) || [];
}

// node_modules/@antv/component/esm/util/replace-children.js
var replaceChildren = function(el, content) {
  if (content == null) {
    el.innerHTML = "";
    return;
  }
  if (el.replaceChildren) {
    if (Array.isArray(content)) {
      el.replaceChildren.apply(el, __spreadArray([], __read(content), false));
    } else {
      el.replaceChildren(content);
    }
  } else {
    el.innerHTML = "";
    if (Array.isArray(content)) {
      content.forEach(function(child) {
        return el.appendChild(child);
      });
    } else {
      el.appendChild(content);
    }
  }
};

// node_modules/@antv/component/esm/util/pase-position.js
function parsePosition(position) {
  if (!/\S+-\S+/g.test(position))
    return position.length > 2 ? [position[0]] : position.split("");
  return position.split("-").map(function(str7) {
    return str7[0];
  });
}

// node_modules/@antv/component/esm/util/parse-height-from-html.js
var parseHeightFromHTML = function(html) {
  var parser2 = new DOMParser();
  var doc = parser2.parseFromString(html, "text/html");
  var el = doc.body.firstElementChild;
  console.log(el === null || el === void 0 ? void 0 : el.getClientRects(), 11);
  if (!el)
    return 0;
  var style = el.getAttribute("style") || "";
  var rules = Object.fromEntries(style.split(";").map(function(r) {
    return r.trim();
  }).filter(function(r) {
    return r.includes(":");
  }).map(function(r) {
    var _a2 = __read(r.split(":").map(function(s2) {
      return s2.trim();
    }), 2), key = _a2[0], value = _a2[1];
    return [key.toLowerCase(), value];
  }));
  var parsePx = function(v) {
    if (!v)
      return 0;
    var match2 = v.match(/([\d.]+)px/);
    return match2 ? parseFloat(match2[1]) : 0;
  };
  if (rules.height) {
    return parsePx(rules.height);
  }
  var fontSize = parsePx(rules["font-size"]) || 16;
  var lineHeight = rules["line-height"];
  var baseHeight;
  if (!lineHeight || lineHeight === "normal") {
    baseHeight = 1.2 * fontSize;
  } else if (lineHeight.endsWith("px")) {
    baseHeight = parsePx(lineHeight);
  } else if (/^[\d.]+$/.test(lineHeight)) {
    baseHeight = parseFloat(lineHeight) * fontSize;
  } else {
    baseHeight = fontSize;
  }
  var paddingTop = parsePx(rules["padding-top"]);
  var paddingBottom = parsePx(rules["padding-bottom"]);
  if (rules.padding) {
    var parts = rules.padding.split(/\s+/).map(parsePx);
    if (parts.length === 1) {
      paddingTop = parts[0];
      paddingBottom = parts[0];
    } else if (parts.length === 2) {
      paddingTop = parts[0];
      paddingBottom = parts[0];
    } else if (parts.length === 3) {
      paddingTop = parts[0];
      paddingBottom = parts[2];
    } else if (parts.length === 4) {
      paddingTop = parts[0];
      paddingBottom = parts[2];
    }
  }
  var borderTop = parsePx(rules["border-top-width"]);
  var borderBottom = parsePx(rules["border-bottom-width"]);
  if (rules.border) {
    var match = rules.border.match(/([\d.]+)px/);
    if (match) {
      borderTop = parseFloat(match[1]);
      borderBottom = parseFloat(match[1]);
    }
  }
  if (rules["border-width"]) {
    var parts = rules["border-width"].split(/\s+/).map(parsePx);
    if (parts.length === 1) {
      borderTop = parts[0];
      borderBottom = parts[0];
    } else if (parts.length === 2) {
      borderTop = parts[0];
      borderBottom = parts[0];
    } else if (parts.length === 3) {
      borderTop = parts[0];
      borderBottom = parts[2];
    } else if (parts.length === 4) {
      borderTop = parts[0];
      borderBottom = parts[2];
    }
  }
  return baseHeight + paddingTop + paddingBottom + borderTop + borderBottom;
};

// node_modules/@antv/component/esm/animation/utils.js
function isStandardAnimationOption(option) {
  if (typeof option === "boolean")
    return false;
  return "enter" in option && "update" in option && "exit" in option;
}
function parseAnimationOption(option) {
  if (!option)
    return { enter: false, update: false, exit: false };
  var keys2 = ["enter", "update", "exit"];
  var baseOption = Object.fromEntries(Object.entries(option).filter(function(_a2) {
    var _b = __read(_a2, 1), k = _b[0];
    return !keys2.includes(k);
  }));
  return Object.fromEntries(keys2.map(function(k) {
    if (isStandardAnimationOption(option)) {
      if (option[k] === false)
        return [k, false];
      return [k, __assign(__assign({}, option[k]), baseOption)];
    }
    return [k, baseOption];
  }));
}
function onAnimateFinished(animation, callback) {
  if (!animation)
    callback();
  else
    animation.finished.then(callback);
}
function onAnimatesFinished(animations, callback) {
  if (animations.length === 0)
    callback();
  else
    Promise.all(animations.map(function(a2) {
      return a2 === null || a2 === void 0 ? void 0 : a2.finished;
    })).then(callback);
}
function attr(target, value) {
  if ("update" in target)
    target.update(value);
  else
    target.attr(value);
}
function animate(target, keyframes, options) {
  if (keyframes.length === 0)
    return null;
  if (!options) {
    var state = keyframes.slice(-1)[0];
    attr(target, { style: state });
    return null;
  }
  return target.animate(keyframes, options);
}
function identicalTextNode(source, target) {
  if (source.nodeName !== "text" || target.nodeName !== "text")
    return false;
  if (source.attributes.text !== target.attributes.text)
    return false;
  return true;
}
function transitionShape(source, target, options, after) {
  if (after === void 0) {
    after = "destroy";
  }
  if (identicalTextNode(source, target)) {
    source.remove();
    return [null];
  }
  var afterTransition = function() {
    if (after === "destroy")
      source.destroy();
    else if (after === "hide")
      hide(source);
    if (target.isVisible())
      show(target);
  };
  if (!options) {
    afterTransition();
    return [null];
  }
  var _a2 = options.duration, duration = _a2 === void 0 ? 0 : _a2, _b = options.delay, delay = _b === void 0 ? 0 : _b;
  var middle = Math.ceil(+duration / 2);
  var offset = +duration / 4;
  var _c = __read(source.getGeometryBounds().center, 2), sx = _c[0], sy = _c[1];
  var _d = __read(target.getGeometryBounds().center, 2), ex = _d[0], ey = _d[1];
  var _e = __read([(sx + ex) / 2 - sx, (sy + ey) / 2 - sy], 2), mx = _e[0], my = _e[1];
  var _f = source.style.opacity, so = _f === void 0 ? 1 : _f;
  var _g = target.style.opacity, to = _g === void 0 ? 1 : _g;
  var st = source.style.transform || "";
  var tt = target.style.transform || "";
  var sourceAnimation = source.animate([
    { opacity: so, transform: "translate(0, 0) ".concat(st) },
    { opacity: 0, transform: "translate(".concat(mx, ", ").concat(my, ") ").concat(st) }
  ], __assign(__assign({ fill: "both" }, options), { duration: delay + middle + offset }));
  var targetAnimation = target.animate([
    { opacity: 0, transform: "translate(".concat(-mx, ", ").concat(-my, ") ").concat(tt), offset: 0.01 },
    { opacity: to, transform: "translate(0, 0) ".concat(tt) }
  ], __assign(__assign({ fill: "both" }, options), { duration: middle + offset, delay: delay + middle - offset }));
  onAnimateFinished(targetAnimation, afterTransition);
  return [sourceAnimation, targetAnimation];
}
function transition(target, state, options) {
  var from = {};
  var to = {};
  Object.entries(state).forEach(function(_a2) {
    var _b = __read(_a2, 2), key = _b[0], tarStyle = _b[1];
    if (!isNil(tarStyle)) {
      var currStyle = target.style[key] || target.parsedStyle[key] || 0;
      if (currStyle !== tarStyle) {
        from[key] = currStyle;
        to[key] = tarStyle;
      }
    }
  });
  if (!options) {
    attr(target, to);
    return null;
  }
  return animate(target, [from, to], __assign({ fill: "both" }, options));
}

// node_modules/@antv/component/esm/animation/fadeOut.js
function fadeOut_default(element, options) {
  if (!element.style.opacity)
    element.style.opacity = 1;
  return transition(element, { opacity: 0 }, options);
}

// node_modules/@antv/component/esm/core/component.js
function applyVisibility() {
  visibility(this, this.attributes.visibility !== "hidden");
}
var Component = (
  /** @class */
  function(_super) {
    __extends(Component2, _super);
    function Component2(options, defaultStyleProps) {
      if (defaultStyleProps === void 0) {
        defaultStyleProps = {};
      }
      var _this2 = _super.call(this, deepAssign({}, { style: defaultStyleProps }, options)) || this;
      _this2.initialized = false;
      _this2._defaultOptions = defaultStyleProps;
      return _this2;
    }
    Object.defineProperty(Component2.prototype, "offscreenGroup", {
      get: function() {
        if (!this._offscreen)
          this._offscreen = createOffscreenGroup(this);
        return this._offscreen;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Component2.prototype, "defaultOptions", {
      get: function() {
        return this._defaultOptions;
      },
      enumerable: false,
      configurable: true
    });
    Component2.prototype.connectedCallback = function() {
      this.render(this.attributes, this);
      this.bindEvents(this.attributes, this);
      this.initialized = true;
    };
    Component2.prototype.disconnectedCallback = function() {
      var _a2;
      (_a2 = this._offscreen) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    };
    Component2.prototype.attributeChangedCallback = function(name) {
      if (name === "visibility") {
        applyVisibility.call(this);
      }
    };
    Component2.prototype.update = function(attr2, animate2) {
      var _a2;
      this.attr(deepAssign({}, this.attributes, attr2 || {}));
      return (_a2 = this.render) === null || _a2 === void 0 ? void 0 : _a2.call(this, this.attributes, this, animate2);
    };
    Component2.prototype.clear = function() {
      this.removeChildren();
    };
    Component2.prototype.bindEvents = function(attributes, container) {
    };
    Component2.prototype.getSubShapeStyle = function(attributes) {
      var x3 = attributes.x, y3 = attributes.y, transform2 = attributes.transform, transformOrigin = attributes.transformOrigin, _class = attributes.class, className = attributes.className, zIndex = attributes.zIndex, style = __rest(attributes, ["x", "y", "transform", "transformOrigin", "class", "className", "zIndex"]);
      return style;
    };
    return Component2;
  }(CustomElement)
);

// node_modules/@antv/component/esm/ui/axis/classname-map.js
var CLASSNAME_SUFFIX_MAP = {
  // group
  gridGroup: "grid-group",
  mainGroup: "main-group",
  lineGroup: "line-group",
  tickGroup: "tick-group",
  labelGroup: "label-group",
  titleGroup: "title-group",
  // content
  grid: "grid",
  line: "line",
  lineFirst: "line-first",
  lineSecond: "line-second",
  tick: "tick",
  tickItem: "tick-item",
  label: "label",
  labelItem: "label-item",
  title: "title"
};

// node_modules/@antv/component/esm/ui/axis/constant.js
var AXIS_BASE_DEFAULT_ATTR = {
  data: [],
  animate: {
    enter: false,
    update: {
      duration: 100,
      easing: "ease-in-out-sine",
      fill: "both"
    },
    exit: {
      duration: 100,
      fill: "both"
    }
  },
  showArrow: true,
  showGrid: true,
  showLabel: true,
  showLine: true,
  showTick: true,
  showTitle: true,
  showTrunc: false,
  dataThreshold: 100,
  lineLineWidth: 1,
  lineStroke: "black",
  crossPadding: 10,
  titleFill: "black",
  titleFontSize: 12,
  titlePosition: "lb",
  titleSpacing: 0,
  titleTextAlign: "center",
  titleTextBaseline: "middle",
  lineArrow: function() {
    return new Path({
      style: {
        d: [["M", 10, 10], ["L", -10, 0], ["L", 10, -10], ["L", 0, 0], ["L", 10, 10], ["Z"]],
        fill: "black",
        transformOrigin: "center"
      }
    });
  },
  labelAlign: "parallel",
  labelDirection: "positive",
  labelFontSize: 12,
  labelSpacing: 0,
  gridConnect: "line",
  gridControlAngles: [],
  gridDirection: "positive",
  gridLength: 0,
  gridType: "segment",
  lineArrowOffset: 15,
  lineArrowSize: 10,
  tickDirection: "positive",
  tickLength: 5,
  tickLineWidth: 1,
  tickStroke: "black",
  labelOverlap: [
    // { type: 'rotate', optionalAngles: [0, 45, 90] },
    // { type: 'ellipsis', suffix: '...', minLength: 14, maxLength: 160 },
    // { type: 'hide' },
  ]
};
var ARC_DEFAULT_OPTIONS = deep_mix_default({}, AXIS_BASE_DEFAULT_ATTR, {
  style: {
    type: "arc"
  }
});
var HELIX_DEFAULT_OPTIONS = deep_mix_default({}, AXIS_BASE_DEFAULT_ATTR, {
  style: {}
});
var CLASS_NAMES = classNames({
  mainGroup: CLASSNAME_SUFFIX_MAP.mainGroup,
  gridGroup: CLASSNAME_SUFFIX_MAP.gridGroup,
  grid: CLASSNAME_SUFFIX_MAP.grid,
  lineGroup: CLASSNAME_SUFFIX_MAP.lineGroup,
  line: CLASSNAME_SUFFIX_MAP.line,
  tickGroup: CLASSNAME_SUFFIX_MAP.tickGroup,
  tick: CLASSNAME_SUFFIX_MAP.tick,
  tickItem: CLASSNAME_SUFFIX_MAP.tickItem,
  labelGroup: CLASSNAME_SUFFIX_MAP.labelGroup,
  label: CLASSNAME_SUFFIX_MAP.label,
  labelItem: CLASSNAME_SUFFIX_MAP.labelItem,
  titleGroup: CLASSNAME_SUFFIX_MAP.titleGroup,
  title: CLASSNAME_SUFFIX_MAP.title,
  lineFirst: CLASSNAME_SUFFIX_MAP.lineFirst,
  lineSecond: CLASSNAME_SUFFIX_MAP.lineSecond
}, "axis");

// node_modules/@antv/component/esm/ui/grid/index.js
var CLASS_NAMES2 = classNames({
  lineGroup: "line-group",
  line: "line",
  regionGroup: "region-group",
  region: "region"
}, "grid");
function getStraightPath(points) {
  return points.reduce(function(acc, curr, idx) {
    acc.push(__spreadArray([idx === 0 ? "M" : "L"], __read(curr), false));
    return acc;
  }, []);
}
function getSurroundPath(points, attr2, reversed) {
  var _a2 = attr2.connect, connect = _a2 === void 0 ? "line" : _a2, center = attr2.center;
  if (connect === "line")
    return getStraightPath(points);
  if (!center)
    return [];
  var radius = distance5(points[0], center);
  var sweepFlag = reversed ? 0 : 1;
  return points.reduce(function(r, p, idx) {
    if (idx === 0)
      r.push(__spreadArray(["M"], __read(p), false));
    else
      r.push(__spreadArray(["A", radius, radius, 0, 0, sweepFlag], __read(p), false));
    return r;
  }, []);
}
function getLinePath(points, cfg, reversed) {
  if (cfg.type === "surround")
    return getSurroundPath(points, cfg, reversed);
  return getStraightPath(points);
}
function connectPaths(from, to, cfg) {
  var type = cfg.type, connect = cfg.connect, center = cfg.center, closed = cfg.closed;
  var closeFlag = closed ? [["Z"]] : [];
  var _a2 = __read([getLinePath(from, cfg), getLinePath(to.slice().reverse(), cfg, true)], 2), path1 = _a2[0], path2 = _a2[1];
  var _b = __read([from[0], to.slice(-1)[0]], 2), startOfFrom = _b[0], endOfTo = _b[1];
  var createPath = function(insertA, insertB) {
    return [path1, insertA, path2, insertB, closeFlag].flat();
  };
  if (connect === "line" || type === "surround") {
    return createPath([__spreadArray(["L"], __read(endOfTo), false)], [__spreadArray(["L"], __read(startOfFrom), false)]);
  }
  if (!center)
    throw new Error("Arc grid need to specified center");
  var _c = __read([distance5(endOfTo, center), distance5(startOfFrom, center)], 2), raduis1 = _c[0], radius2 = _c[1];
  return createPath([
    __spreadArray(["A", raduis1, raduis1, 0, 0, 1], __read(endOfTo), false),
    __spreadArray(["L"], __read(endOfTo), false)
  ], [
    __spreadArray(["A", radius2, radius2, 0, 0, 0], __read(startOfFrom), false),
    __spreadArray(["L"], __read(startOfFrom), false)
  ]);
}
function renderGridLine(container, data2, attr2, style) {
  var animate2 = attr2.animate, isBillboard = attr2.isBillboard;
  var lines = data2.map(function(item, idx) {
    return {
      id: item.id || "grid-line-".concat(idx),
      d: getLinePath(item.points, attr2)
    };
  });
  return container.selectAll(CLASS_NAMES2.line.class).data(lines, function(d2) {
    return d2.id;
  }).join(function(enter) {
    return enter.append("path").each(function(datum, index2) {
      var lineStyle = getCallbackValue(getPrimitiveAttributes(__assign({ d: datum.d }, style)), [datum, index2, lines]);
      this.attr(__assign({ class: CLASS_NAMES2.line.name, stroke: "#D9D9D9", lineWidth: 1, lineDash: [4, 4], isBillboard }, lineStyle));
    });
  }, function(update2) {
    return update2.transition(function(datum, index2) {
      var lineStyle = getCallbackValue(getPrimitiveAttributes(__assign({ d: datum.d }, style)), [datum, index2, lines]);
      return transition(this, lineStyle, animate2.update);
    });
  }, function(exit) {
    return exit.transition(function() {
      var _this2 = this;
      var animation = fadeOut_default(this, animate2.exit);
      onAnimateFinished(animation, function() {
        return _this2.remove();
      });
      return animation;
    });
  }).transitions();
}
function renderAlternateRegion(container, data2, style) {
  var animate2 = style.animate, connect = style.connect, areaFill = style.areaFill;
  if (data2.length < 2 || !areaFill || !connect)
    return [];
  var colors = Array.isArray(areaFill) ? areaFill : [areaFill, "transparent"];
  var getColor3 = function(idx2) {
    return colors[idx2 % colors.length];
  };
  var regions = [];
  for (var idx = 0; idx < data2.length - 1; idx++) {
    var _a2 = __read([data2[idx].points, data2[idx + 1].points], 2), prev = _a2[0], curr = _a2[1];
    var path = connectPaths(prev, curr, style);
    regions.push({ d: path, fill: getColor3(idx) });
  }
  return container.selectAll(CLASS_NAMES2.region.class).data(regions, function(_2, i) {
    return i;
  }).join(function(enter) {
    return enter.append("path").each(function(datum, index2) {
      var regionStyle = getCallbackValue(datum, [datum, index2, regions]);
      this.attr(regionStyle);
    }).attr("className", CLASS_NAMES2.region.name);
  }, function(update2) {
    return update2.transition(function(datum, index2) {
      var regionStyle = getCallbackValue(datum, [datum, index2, regions]);
      return transition(this, regionStyle, animate2.update);
    });
  }, function(exit) {
    return exit.transition(function() {
      var _this2 = this;
      var animation = fadeOut_default(this, animate2.exit);
      onAnimateFinished(animation, function() {
        return _this2.remove();
      });
      return animation;
    });
  }).transitions();
}
function getData(attr2) {
  var _a2 = attr2.data, data2 = _a2 === void 0 ? [] : _a2, closed = attr2.closed;
  if (!closed)
    return data2;
  return data2.map(function(datum) {
    var points = datum.points;
    var _a3 = __read(points, 1), start = _a3[0];
    return __assign(__assign({}, datum), { points: __spreadArray(__spreadArray([], __read(points), false), [start], false) });
  });
}
var Grid = (
  /** @class */
  function(_super) {
    __extends(Grid2, _super);
    function Grid2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Grid2.prototype.render = function(attributes, container) {
      var type = attributes.type, center = attributes.center, areaFill = attributes.areaFill, closed = attributes.closed, style = __rest(attributes, ["type", "center", "areaFill", "closed"]);
      var data2 = getData(attributes);
      var lineGroup = select(container).maybeAppendByClassName(CLASS_NAMES2.lineGroup, "g");
      var regionGroup = select(container).maybeAppendByClassName(CLASS_NAMES2.regionGroup, "g");
      var lineTransitions = renderGridLine(lineGroup, data2, attributes, style);
      var reigionTransitions = renderAlternateRegion(regionGroup, data2, attributes);
      return __spreadArray(__spreadArray([], __read(lineTransitions), false), __read(reigionTransitions), false);
    };
    return Grid2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/axis/guides/utils.js
function getCallbackStyle(style, params) {
  return Object.fromEntries(Object.entries(style).map(function(_a2) {
    var _b = __read(_a2, 2), key = _b[0], val = _b[1];
    return [key, getCallbackValue(val, params)];
  }));
}
function filterExec(data2, filter2) {
  return !!filter2 && isFunction(filter2) ? data2.filter(filter2) : data2;
}
function getLineAngle(value, attr2) {
  var startAngle = attr2.startAngle, endAngle = attr2.endAngle;
  return (endAngle - startAngle) * value + startAngle;
}
function getLineTangentVector(value, attr2) {
  if (attr2.type === "linear") {
    var _a2 = __read(attr2.startPos, 2), startX = _a2[0], startY = _a2[1], _b = __read(attr2.endPos, 2), endX = _b[0], endY = _b[1];
    var _c = __read([endX - startX, endY - startY], 2), dx = _c[0], dy = _c[1];
    return normalize6([dx, dy]);
  }
  var angle3 = degToRad(getLineAngle(value, attr2));
  return [-Math.sin(angle3), Math.cos(angle3)];
}
function getDirectionVector(value, direction3, attr2) {
  var tangentVector = getLineTangentVector(value, attr2);
  return vertical2(tangentVector, direction3 !== "positive");
}
function getLabelVector(value, attr2) {
  return getDirectionVector(value, attr2.labelDirection, attr2);
}

// node_modules/@antv/component/esm/ui/axis/utils/classname.js
function getAxisClassName(baseClassName, suffix, classNamePrefix) {
  if (!classNamePrefix)
    return baseClassName;
  return "".concat(baseClassName, " ").concat(classNamePrefix, "axis-").concat(suffix);
}
function applyClassName(selection, baseClassName, suffix, classNamePrefix) {
  if (classNamePrefix) {
    selection.attr("className", getAxisClassName(baseClassName.name, suffix, classNamePrefix));
  }
  return selection;
}

// node_modules/@antv/component/esm/ui/axis/guides/line.js
function getLinearValuePos(value, attr2) {
  var _a2 = __read(attr2.startPos, 2), sx = _a2[0], sy = _a2[1], _b = __read(attr2.endPos, 2), ex = _b[0], ey = _b[1];
  var _c = __read([ex - sx, ey - sy], 2), dx = _c[0], dy = _c[1];
  return [sx + dx * value, sy + dy * value];
}
function getArcValuePos(value, attr2) {
  var radius = attr2.radius, _a2 = __read(attr2.center, 2), cx = _a2[0], cy = _a2[1];
  var angle3 = degToRad(getLineAngle(value, attr2));
  return [cx + radius * Math.cos(angle3), cy + radius * Math.sin(angle3)];
}
function getValuePos(value, attr2) {
  if (attr2.type === "linear")
    return getLinearValuePos(value, attr2);
  return getArcValuePos(value, attr2);
}
function isAxisHorizontal(attr2) {
  return getLineTangentVector(0, attr2)[1] === 0;
}
function isAxisVertical(attr2) {
  return getLineTangentVector(0, attr2)[0] === 0;
}
function isCircle(startAngle, endAngle) {
  return endAngle - startAngle === 360;
}
function getArcPath(startAngle, endAngle, cx, cy, radius) {
  var diffAngle = endAngle - startAngle;
  var _a2 = __read([radius, radius], 2), rx = _a2[0], ry = _a2[1];
  var _b = __read([degToRad(startAngle), degToRad(endAngle)], 2), startAngleRadians = _b[0], endAngleRadians = _b[1];
  var getPosByAngle = function(angle3) {
    return [cx + radius * Math.cos(angle3), cy + radius * Math.sin(angle3)];
  };
  var _c = __read(getPosByAngle(startAngleRadians), 2), x1 = _c[0], y1 = _c[1];
  var _d = __read(getPosByAngle(endAngleRadians), 2), x22 = _d[0], y22 = _d[1];
  if (isCircle(startAngle, endAngle)) {
    var middleAngleRadians = (endAngleRadians + startAngleRadians) / 2;
    var _e = __read(getPosByAngle(middleAngleRadians), 2), xm = _e[0], ym = _e[1];
    return [
      ["M", x1, y1],
      ["A", rx, ry, 0, 1, 0, xm, ym],
      ["A", rx, ry, 0, 1, 0, x22, y22]
    ];
  }
  var large = diffAngle > 180 ? 1 : 0;
  var sweep = startAngle > endAngle ? 0 : 1;
  var isClosePath = false;
  return isClosePath ? "M".concat(cx, ",").concat(cy, ",L").concat(x1, ",").concat(y1, ",A").concat(rx, ",").concat(ry, ",0,").concat(large, ",").concat(sweep, ",").concat(x22, ",").concat(y22, ",L").concat(cx, ",").concat(cy) : "M".concat(x1, ",").concat(y1, ",A").concat(rx, ",").concat(ry, ",0,").concat(large, ",").concat(sweep, ",").concat(x22, ",").concat(y22);
}
function getArcAttr(arc) {
  var _a2 = arc.attributes, startAngle = _a2.startAngle, endAngle = _a2.endAngle, center = _a2.center, radius = _a2.radius;
  return __spreadArray(__spreadArray([startAngle, endAngle], __read(center), false), [radius], false);
}
function renderArc(container, attr2, style, animate2) {
  var startAngle = attr2.startAngle, endAngle = attr2.endAngle, center = attr2.center, radius = attr2.radius, classNamePrefix = attr2.classNamePrefix;
  return container.selectAll(CLASS_NAMES.line.class).data([{ d: getArcPath.apply(void 0, __spreadArray(__spreadArray([startAngle, endAngle], __read(center), false), [radius], false)) }], function(d2, i) {
    return i;
  }).join(function(enter) {
    var line2 = enter.append("path").attr("className", CLASS_NAMES.line.name).styles(attr2).styles({ d: function(d2) {
      return d2.d;
    } });
    applyClassName(line2, CLASS_NAMES.line, CLASSNAME_SUFFIX_MAP.line, classNamePrefix);
    return line2;
  }, function(update2) {
    return update2.transition(function() {
      var _this2 = this;
      var animation = keyframeInterpolate(this, getArcAttr(this), __spreadArray(__spreadArray([startAngle, endAngle], __read(center), false), [radius], false), animate2.update);
      if (animation) {
        var layout = function() {
          var data2 = get_default(_this2.attributes, "__keyframe_data__");
          _this2.style.d = getArcPath.apply(void 0, __spreadArray([], __read(data2), false));
        };
        animation.onframe = layout;
        animation.onfinish = layout;
      }
      return animation;
    }).styles(attr2);
  }, function(exit) {
    return exit.remove();
  }).styles(style).transitions();
}
function renderTruncation(container, _a2) {
  var truncRange = _a2.truncRange, truncShape = _a2.truncShape, lineExtension = _a2.lineExtension;
}
function extendLine(startPos, endPos, range) {
  if (range === void 0) {
    range = [0, 0];
  }
  var _a2 = __read([startPos, endPos, range], 3), _b = __read(_a2[0], 2), x1 = _b[0], y1 = _b[1], _c = __read(_a2[1], 2), x22 = _c[0], y22 = _c[1], _d = __read(_a2[2], 2), l1 = _d[0], l2 = _d[1];
  var _e = __read([x22 - x1, y22 - y1], 2), x3 = _e[0], y3 = _e[1];
  var L = Math.sqrt(Math.pow(x3, 2) + Math.pow(y3, 2));
  var _f = __read([-l1 / L, l2 / L], 2), s1 = _f[0], s2 = _f[1];
  return [s1 * x3, s1 * y3, s2 * x3, s2 * y3];
}
function getLinePath2(points) {
  var _a2 = __read(points, 2), _b = __read(_a2[0], 2), x1 = _b[0], y1 = _b[1], _c = __read(_a2[1], 2), x22 = _c[0], y22 = _c[1];
  return { x1, y1, x2: x22, y2: y22 };
}
function renderLinear(container, attr2, style, animate2) {
  var showTrunc = attr2.showTrunc, startPos = attr2.startPos, endPos = attr2.endPos, truncRange = attr2.truncRange, lineExtension = attr2.lineExtension, classNamePrefix = attr2.classNamePrefix;
  var _a2 = __read([startPos, endPos], 2), _b = __read(_a2[0], 2), x1 = _b[0], y1 = _b[1], _c = __read(_a2[1], 2), x22 = _c[0], y22 = _c[1];
  var _d = __read(lineExtension ? extendLine(startPos, endPos, lineExtension) : new Array(4).fill(0), 4), ox1 = _d[0], oy1 = _d[1], ox2 = _d[2], oy2 = _d[3];
  var renderLine = function(data2) {
    return container.selectAll(CLASS_NAMES.line.class).data(data2, function(d2, i) {
      return i;
    }).join(function(enter) {
      var lines = enter.append("line").styles(style).transition(function(d2) {
        return transition(this, getLinePath2(d2.line), false);
      });
      lines.attr("className", function(d2) {
        if (!classNamePrefix) {
          return "".concat(CLASS_NAMES.line.name, " ").concat(d2.className);
        }
        var baseLineClassName = getAxisClassName(CLASS_NAMES.line.name, CLASSNAME_SUFFIX_MAP.line, classNamePrefix);
        if (d2.className === CLASS_NAMES.lineFirst.name) {
          var specificClassName = getAxisClassName(CLASS_NAMES.lineFirst.name, CLASSNAME_SUFFIX_MAP.lineFirst, classNamePrefix);
          return "".concat(baseLineClassName, " ").concat(specificClassName);
        }
        if (d2.className === CLASS_NAMES.lineSecond.name) {
          var specificClassName = getAxisClassName(CLASS_NAMES.lineSecond.name, CLASSNAME_SUFFIX_MAP.lineSecond, classNamePrefix);
          return "".concat(baseLineClassName, " ").concat(specificClassName);
        }
        return baseLineClassName;
      });
      return lines;
    }, function(update2) {
      return update2.styles(style).transition(function(_a3) {
        var line2 = _a3.line;
        return transition(this, getLinePath2(line2), animate2.update);
      });
    }, function(exit) {
      return exit.remove();
    }).transitions();
  };
  if (!showTrunc || !truncRange) {
    return renderLine([
      {
        line: [
          [x1 + ox1, y1 + oy1],
          [x22 + ox2, y22 + oy2]
        ],
        className: CLASS_NAMES.line.name
      }
    ]);
  }
  var _e = __read(truncRange, 2), r1 = _e[0], r2 = _e[1];
  var dx = x22 - x1;
  var dy = y22 - y1;
  var _f = __read([x1 + dx * r1, y1 + dy * r1], 2), x3 = _f[0], y3 = _f[1];
  var _g = __read([x1 + dx * r2, y1 + dy * r2], 2), x4 = _g[0], y4 = _g[1];
  var animation = renderLine([
    {
      line: [
        [x1 + ox1, y1 + oy1],
        [x3, y3]
      ],
      className: CLASS_NAMES.lineFirst.name
    },
    {
      line: [
        [x4, y4],
        [x22 + ox2, y22 + oy2]
      ],
      className: CLASS_NAMES.lineSecond.name
    }
  ]);
  renderTruncation(container, attr2);
  return animation;
}
function renderAxisArrow(container, type, attr2, style) {
  var showArrow = attr2.showArrow, showTrunc = attr2.showTrunc, lineArrow = attr2.lineArrow, lineArrowOffset = attr2.lineArrowOffset, lineArrowSize = attr2.lineArrowSize;
  var shapeToAddArrow;
  if (type === "arc") {
    shapeToAddArrow = container.select(CLASS_NAMES.line.class);
  } else if (showTrunc) {
    shapeToAddArrow = container.select(CLASS_NAMES.lineSecond.class);
  } else {
    shapeToAddArrow = container.select(CLASS_NAMES.line.class);
  }
  if (!showArrow || !lineArrow || attr2.type === "arc" && isCircle(attr2.startAngle, attr2.endAngle)) {
    var node = shapeToAddArrow.node();
    if (node)
      node.style.markerEnd = void 0;
    return;
  }
  var arrow2 = renderExtDo(lineArrow);
  arrow2.attr(style);
  scaleToPixel(arrow2, lineArrowSize, true);
  shapeToAddArrow.style("markerEnd", arrow2).style("markerEndOffset", -lineArrowOffset);
}
function renderAxisLine(container, attr2, animate2) {
  var type = attr2.type;
  var animation;
  var style = subStyleProps(attr2, "line");
  if (type === "linear")
    animation = renderLinear(container, attr2, omit(style, "arrow"), animate2);
  else
    animation = renderArc(container, attr2, omit(style, "arrow"), animate2);
  renderAxisArrow(container, type, attr2, style);
  return animation;
}

// node_modules/@antv/component/esm/ui/axis/guides/grid.js
function getGridVector(value, attr2) {
  return getDirectionVector(value, attr2.gridDirection, attr2);
}
function getGridCenter(attr2) {
  var type = attr2.type, gridCenter = attr2.gridCenter;
  if (type === "linear")
    return gridCenter;
  return gridCenter || attr2.center;
}
function renderStraight(data2, attr2) {
  var gridLength = attr2.gridLength;
  return data2.map(function(_a2, index2) {
    var value = _a2.value;
    var _b = __read(getValuePos(value, attr2), 2), x3 = _b[0], y3 = _b[1];
    var _c = __read(scale8(getGridVector(value, attr2), gridLength), 2), dx = _c[0], dy = _c[1];
    return {
      id: index2,
      points: [
        [x3, y3],
        [x3 + dx, y3 + dy]
      ]
    };
  });
}
function renderSurround(data2, attr2) {
  var controlAngles = attr2.gridControlAngles;
  var center = getGridCenter(attr2);
  if (!center)
    throw new Error("grid center is not provide");
  if (data2.length < 2)
    throw new Error("Invalid grid data");
  if (!controlAngles || controlAngles.length === 0)
    throw new Error("Invalid gridControlAngles");
  var _a2 = __read(center, 2), cx = _a2[0], cy = _a2[1];
  return data2.map(function(_a3, index2) {
    var value = _a3.value;
    var _b = __read(getValuePos(value, attr2), 2), sx = _b[0], sy = _b[1];
    var _c = __read([sx - cx, sy - cy], 2), dx = _c[0], dy = _c[1];
    var points = [];
    controlAngles.forEach(function(angle3) {
      var angleInRad = degToRad(angle3);
      var _a4 = __read([Math.cos(angleInRad), Math.sin(angleInRad)], 2), cosa = _a4[0], sina = _a4[1];
      var x3 = dx * cosa - dy * sina + cx;
      var y3 = dx * sina + dy * cosa + cy;
      points.push([x3, y3]);
    });
    return { points, id: index2 };
  });
}
function renderGrid(container, data2, attr2, animate2) {
  var classNamePrefix = attr2.classNamePrefix;
  var gridAttr = subStyleProps(attr2, "grid");
  var type = gridAttr.type, areaFill = gridAttr.areaFill;
  var center = getGridCenter(attr2);
  var finalData = filterExec(data2, attr2.gridFilter);
  var gridItems = type === "segment" ? renderStraight(finalData, attr2) : renderSurround(finalData, attr2);
  var style = __assign(__assign({}, gridAttr), { center, areaFill: isFunction(areaFill) ? finalData.map(function(datum, index2) {
    return getCallbackValue(areaFill, [datum, index2, finalData]);
  }) : areaFill, animate: animate2, data: gridItems });
  return container.selectAll(CLASS_NAMES.grid.class).data([1]).join(function(enter) {
    var grid2 = enter.append(function() {
      return new Grid({ style });
    }).attr("className", CLASS_NAMES.grid.name);
    applyClassName(grid2, CLASS_NAMES.grid, CLASSNAME_SUFFIX_MAP.grid, classNamePrefix);
    return grid2;
  }, function(update2) {
    return update2.transition(function() {
      return this.update(style);
    });
  }, function(exit) {
    return exit.remove();
  }).transitions();
}

// node_modules/@antv/component/esm/ui/axis/utils/bounds.js
var Bounds = (
  /** @class */
  function() {
    function Bounds2(x1, y1, x22, y22) {
      this.set(x1, y1, x22, y22);
    }
    Object.defineProperty(Bounds2.prototype, "left", {
      get: function() {
        return this.x1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "top", {
      get: function() {
        return this.y1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "right", {
      get: function() {
        return this.x2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "bottom", {
      get: function() {
        return this.y2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "width", {
      get: function() {
        return this.defined("x2") && this.defined("x1") ? this.x2 - this.x1 : void 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "height", {
      get: function() {
        return this.defined("y2") && this.defined("y1") ? this.y2 - this.y1 : void 0;
      },
      enumerable: false,
      configurable: true
    });
    Bounds2.prototype.rotatedPoints = function(radian2, x3, y3) {
      var _a2 = this, x1 = _a2.x1, y1 = _a2.y1, x22 = _a2.x2, y22 = _a2.y2;
      var cos = Math.cos(radian2);
      var sin = Math.sin(radian2);
      var cx = x3 - x3 * cos + y3 * sin;
      var cy = y3 - x3 * sin - y3 * cos;
      var points = [
        [cos * x1 - sin * y22 + cx, sin * x1 + cos * y22 + cy],
        [cos * x22 - sin * y22 + cx, sin * x22 + cos * y22 + cy],
        [cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy],
        [cos * x22 - sin * y1 + cx, sin * x22 + cos * y1 + cy]
      ];
      return points;
    };
    Bounds2.prototype.set = function(x1, y1, x22, y22) {
      if (x22 < x1) {
        this.x2 = x1;
        this.x1 = x22;
      } else {
        this.x1 = x1;
        this.x2 = x22;
      }
      if (y22 < y1) {
        this.y2 = y1;
        this.y1 = y22;
      } else {
        this.y1 = y1;
        this.y2 = y22;
      }
      return this;
    };
    Bounds2.prototype.defined = function(key) {
      return this[key] !== Number.MAX_VALUE && this[key] !== -Number.MAX_VALUE;
    };
    return Bounds2;
  }()
);
function getBounds(item, margin) {
  var angle3 = item.getEulerAngles() || 0;
  item.setEulerAngles(0);
  var _a2 = item.getBounds(), _b = __read(_a2.min, 2), x3 = _b[0], y3 = _b[1], _c = __read(_a2.max, 2), right = _c[0], bottom = _c[1];
  var _d = item.getBBox(), w = _d.width, h = _d.height;
  var height = h;
  var dx = 0;
  var dy = 0;
  var anchorX = x3;
  var anchorY = y3;
  var text = textOf(item);
  if (text) {
    height -= 1.5;
    var a2 = text.style.textAlign;
    var b_1 = text.style.textBaseline;
    if (a2 === "center") {
      anchorX = (x3 + right) / 2;
    } else if (a2 === "right" || a2 === "end") {
      anchorX = right;
    } else {
    }
    if (b_1 === "middle") {
      anchorY = (y3 + bottom) / 2;
    } else if (b_1 === "bottom") {
      anchorY = bottom;
    }
  }
  var _e = __read(parseSeriesAttr(margin), 4), _f = _e[0], t = _f === void 0 ? 0 : _f, _g = _e[1], r = _g === void 0 ? 0 : _g, _h = _e[2], b = _h === void 0 ? t : _h, _j = _e[3], l = _j === void 0 ? r : _j;
  var bounds = new Bounds((dx += x3) - l, (dy += y3) - t, dx + w + r, dy + height + b);
  item.setEulerAngles(angle3);
  return bounds.rotatedPoints(degToRad(angle3), anchorX, anchorY);
}

// node_modules/@antv/component/esm/ui/axis/utils/contain.js
function onLine(line2, point2) {
  return point2[0] <= Math.max(line2[0][0], line2[1][0]) && point2[0] <= Math.min(line2[0][0], line2[1][0]) && point2[1] <= Math.max(line2[0][1], line2[1][1]) && point2[1] <= Math.min(line2[0][1], line2[1][1]);
}
function direction2(a2, b, c2) {
  var val = (b[1] - a2[1]) * (c2[0] - b[0]) - (b[0] - a2[0]) * (c2[1] - b[1]);
  if (val === 0)
    return 0;
  return val < 0 ? 2 : 1;
}
function isIntersect(line1, line2) {
  var dir1 = direction2(line1[0], line1[1], line2[0]);
  var dir2 = direction2(line1[0], line1[1], line2[1]);
  var dir3 = direction2(line2[0], line2[1], line1[0]);
  var dir4 = direction2(line2[0], line2[1], line1[1]);
  if (dir1 !== dir2 && dir3 !== dir4)
    return true;
  if (dir1 === 0 && onLine(line1, line2[0]))
    return true;
  if (dir2 === 0 && onLine(line1, line2[1]))
    return true;
  if (dir3 === 0 && onLine(line2, line1[0]))
    return true;
  if (dir4 === 0 && onLine(line2, line1[1]))
    return true;
  return false;
}
function isPointInsideRectangle(polygon, point2) {
  var n = polygon.length;
  if (n < 3)
    return false;
  var lineToInfinity = [point2, [9999, point2[1]]];
  var count = 0;
  var i = 0;
  do {
    var side = [polygon[i], polygon[(i + 1) % n]];
    if (isIntersect(side, lineToInfinity)) {
      if (direction2(side[0], point2, side[1]) === 0)
        return onLine(side, point2);
      count++;
    }
    i = (i + 1) % n;
  } while (i !== 0);
  return !!(count & 1);
}
function isRectangleBInsideA(rectA, rectB) {
  return rectB.every(function(point2) {
    return isPointInsideRectangle(rectA, point2);
  });
}
function contain(container, child, margin) {
  var x1 = container.x1, x22 = container.x2, y1 = container.y1, y22 = container.y2;
  var parent = [
    [x1, y1],
    [x22, y1],
    [x22, y22],
    [x1, y22]
  ];
  var element = getBounds(child, margin);
  return isRectangleBInsideA(parent, element);
}

// node_modules/@antv/component/esm/ui/axis/utils/intersect.js
function lineToLine(line1, line2) {
  var _a2 = __read(line1, 4), x0 = _a2[0], y0 = _a2[1], x1 = _a2[2], y1 = _a2[3];
  var _b = __read(line2, 4), x22 = _b[0], y22 = _b[1], x3 = _b[2], y3 = _b[3];
  var s10x = x1 - x0;
  var s10y = y1 - y0;
  var s32x = x3 - x22;
  var s32y = y3 - y22;
  var denom = s10x * s32y - s32x * s10y;
  if (denom === 0)
    return false;
  var denomPositive = denom > 0;
  var s02x = x0 - x22;
  var s02y = y0 - y22;
  var sNum = s10x * s02y - s10y * s02x;
  if (sNum < 0 === denomPositive)
    return false;
  var tNum = s32x * s02y - s32y * s02x;
  if (tNum < 0 === denomPositive)
    return false;
  if (sNum > denom === denomPositive || tNum > denom === denomPositive)
    return false;
  return true;
}
function intersectBoxLine(box2, line2) {
  var lines = [
    [box2[0], box2[1], box2[2], box2[3]],
    [box2[2], box2[3], box2[4], box2[5]],
    [box2[4], box2[5], box2[6], box2[7]],
    [box2[6], box2[7], box2[0], box2[1]]
  ];
  return lines.some(function(boxLine) {
    return lineToLine(line2, boxLine);
  });
}
function intersect(a2, b, margin) {
  var e_1, _a2;
  var p = getBounds(a2, margin).flat(1);
  var q = getBounds(b, margin).flat(1);
  var linesP = [
    [p[0], p[1], p[2], p[3]],
    [p[0], p[1], p[4], p[5]],
    [p[4], p[5], p[6], p[7]],
    [p[2], p[3], p[6], p[7]]
  ];
  try {
    for (var linesP_1 = __values(linesP), linesP_1_1 = linesP_1.next(); !linesP_1_1.done; linesP_1_1 = linesP_1.next()) {
      var line2 = linesP_1_1.value;
      if (intersectBoxLine(q, line2))
        return true;
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (linesP_1_1 && !linesP_1_1.done && (_a2 = linesP_1.return)) _a2.call(linesP_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  return false;
}

// node_modules/@antv/component/esm/ui/axis/utils/test.js
function createCrossBBox(attr2, padding) {
  var type = attr2.type, labelDirection = attr2.labelDirection, crossSize = attr2.crossSize;
  if (!crossSize)
    return false;
  if (type === "arc") {
    var center = attr2.center, radius = attr2.radius;
    var _a2 = __read(center, 2), cx = _a2[0], cy = _a2[1];
    var size2 = labelDirection === "negative" ? 0 : crossSize;
    var dMin = -radius - size2;
    var dMax = radius + size2;
    var _b = __read(parseSeriesAttr(padding), 4), top_1 = _b[0], right_1 = _b[1], bottom_1 = _b[2], left_1 = _b[3];
    return new Bounds(cx + dMin - left_1, cy + dMin - top_1, cx + dMax + right_1, cy + dMax + bottom_1);
  }
  var _c = __read(attr2.startPos, 2), sx = _c[0], sy = _c[1], _d = __read(attr2.endPos, 2), ex = _d[0], ey = _d[1];
  var _e = __read(isAxisVertical(attr2) ? [-padding, 0, padding, 0] : [0, padding, 0, -padding], 4), top = _e[0], right = _e[1], bottom = _e[2], left = _e[3];
  var labelVector = getLabelVector(0, attr2);
  var diff = scale8(labelVector, crossSize);
  var bbox = new Bounds(sx, sy, ex, ey);
  bbox.x1 += left;
  bbox.y1 += top;
  bbox.x2 += right + diff[0];
  bbox.y2 += bottom + diff[1];
  return bbox;
}
function boundTest(items, attr2, margin) {
  var e_1, _a2;
  var crossPadding = attr2.crossPadding;
  var resultSet = /* @__PURE__ */ new Set();
  var prev = null;
  var crossBBox = createCrossBBox(attr2, crossPadding);
  var testContain = function(item) {
    if (crossBBox)
      return contain(crossBBox, item);
    return true;
  };
  var testIntersect = function(prevItem, currItem) {
    if (!prevItem || !prevItem.firstChild)
      return true;
    return !intersect(prevItem.firstChild, currItem.firstChild, parseSeriesAttr(margin));
  };
  try {
    for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
      var curr = items_1_1.value;
      if (!testContain(curr)) {
        resultSet.add(curr);
      } else if (!prev || testIntersect(prev, curr)) {
        prev = curr;
      } else {
        resultSet.add(prev);
        resultSet.add(curr);
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (items_1_1 && !items_1_1.done && (_a2 = items_1.return)) _a2.call(items_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  return Array.from(resultSet);
}

// node_modules/@antv/component/esm/ui/axis/overlap/autoEllipsis.js
function parseLengthString(str7, font) {
  if (font === void 0) {
    font = {};
  }
  if (isNil(str7))
    return 0;
  if (typeof str7 === "number")
    return str7;
  return Math.floor(measureTextWidth(str7, font));
}
function ellipseLabels(labels, overlapCfg, attr2, utils) {
  if (labels.length <= 0)
    return;
  var _a2 = overlapCfg.suffix, suffix = _a2 === void 0 ? "..." : _a2, minLength = overlapCfg.minLength, _b = overlapCfg.maxLength, maxLength = _b === void 0 ? Infinity : _b, _c = overlapCfg.step, ellipsisStep = _c === void 0 ? " " : _c, _d = overlapCfg.margin, margin = _d === void 0 ? [0, 0, 0, 0] : _d;
  var font = getFont(utils.getTextShape(labels[0]));
  var step2 = parseLengthString(ellipsisStep, font);
  var min5 = minLength ? parseLengthString(minLength, font) : step2;
  var max6 = parseLengthString(maxLength, font);
  if (isNil(max6) || max6 === Infinity) {
    max6 = Math.max.apply(null, labels.map(function(d2) {
      return d2.getBBox().width;
    }));
  }
  var source = labels.slice();
  var _e = __read(margin, 4), _f = _e[0], top = _f === void 0 ? 0 : _f, _g = _e[1], right = _g === void 0 ? 0 : _g, _h = _e[2], bottom = _h === void 0 ? top : _h, _j = _e[3], left = _j === void 0 ? right : _j;
  var _loop_1 = function(allowedLength2) {
    source.forEach(function(label) {
      utils.ellipsis(utils.getTextShape(label), allowedLength2, suffix);
    });
    source = boundTest(labels, attr2, margin);
    if (source.length < 1)
      return { value: void 0 };
  };
  for (var allowedLength = max6; allowedLength > min5 + step2; allowedLength -= step2) {
    var state_1 = _loop_1(allowedLength);
    if (typeof state_1 === "object")
      return state_1.value;
  }
}

// node_modules/@antv/component/esm/ui/axis/overlap/autoHide.js
var methods = {
  parity: function(items, _a2) {
    var _b = _a2.seq, seq = _b === void 0 ? 2 : _b;
    return items.filter(function(item, i) {
      return i % seq ? (hide(item), false) : true;
    });
  }
};
var filterDefined = function(arr) {
  return arr.filter(defined);
};
function hideLabels(labels, overlapCfg, attr2, utils) {
  var count = labels.length;
  var keepHeader = overlapCfg.keepHeader, keepTail = overlapCfg.keepTail;
  if (count <= 1 || count === 2 && keepHeader && keepTail)
    return;
  var parityHide = methods.parity;
  var reset = function(els) {
    return els.forEach(utils.show), els;
  };
  var seq = 2;
  var source = labels.slice();
  var target = labels.slice();
  var minLabelWidth = Math.min.apply(Math, __spreadArray([1], __read(labels.map(function(d2) {
    return d2.getBBox().width;
  })), false));
  if (attr2.type === "linear" && (isAxisHorizontal(attr2) || isAxisVertical(attr2))) {
    var minX = getLocalBBox(labels[0]).left;
    var maxX = getLocalBBox(labels[count - 1]).right;
    var distance6 = Math.abs(maxX - minX) || 1;
    seq = Math.max(Math.floor(count * minLabelWidth / distance6), seq);
  }
  var first;
  var last2;
  if (keepHeader)
    first = source.splice(0, 1)[0];
  if (keepTail) {
    last2 = source.splice(-1, 1)[0];
    source.reverse();
  }
  reset(source);
  while (seq < labels.length && boundTest(filterDefined(last2 ? __spreadArray(__spreadArray([last2], __read(target), false), [first], false) : __spreadArray([first], __read(target), false)), attr2, overlapCfg === null || overlapCfg === void 0 ? void 0 : overlapCfg.margin).length) {
    if (last2 && !first && seq % 2 === 0) {
      var rest = source.splice(0, 1);
      rest.forEach(utils.hide);
    } else if (last2 && first) {
      var rest = source.splice(0, 1);
      rest.forEach(utils.hide);
    }
    target = parityHide(reset(source), { seq });
    seq++;
  }
}

// node_modules/@antv/component/esm/ui/axis/overlap/autoRotate.js
function rotateLabels(labels, overlapCfg, attr2, utils) {
  var e_1, _a2;
  var _b = overlapCfg.optionalAngles, optionalAngles = _b === void 0 ? [0, 45, 90] : _b, margin = overlapCfg.margin, _c = overlapCfg.recoverWhenFailed, recoverWhenFailed = _c === void 0 ? true : _c;
  var defaultAngles = labels.map(function(label) {
    return label.getLocalEulerAngles();
  });
  var runAndPassed = function() {
    return boundTest(labels, attr2, margin).length < 1;
  };
  var setLabelsRotate = function(angle4) {
    return labels.forEach(function(label, index2) {
      var rotate6 = Array.isArray(angle4) ? angle4[index2] : angle4;
      utils.rotate(label, +rotate6);
    });
  };
  try {
    for (var optionalAngles_1 = __values(optionalAngles), optionalAngles_1_1 = optionalAngles_1.next(); !optionalAngles_1_1.done; optionalAngles_1_1 = optionalAngles_1.next()) {
      var angle3 = optionalAngles_1_1.value;
      setLabelsRotate(angle3);
      if (runAndPassed())
        return;
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (optionalAngles_1_1 && !optionalAngles_1_1.done && (_a2 = optionalAngles_1.return)) _a2.call(optionalAngles_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  if (recoverWhenFailed) {
    setLabelsRotate(defaultAngles);
  }
}

// node_modules/@antv/component/esm/ui/axis/overlap/autoWrap.js
function inferTextBaseline(attr2) {
  var type = attr2.type, labelDirection = attr2.labelDirection;
  if (type === "linear" && isAxisHorizontal(attr2)) {
    return labelDirection === "negative" ? "bottom" : "top";
  }
  return "middle";
}
function wrapLabels(labels, overlapCfg, attr2, utils, main) {
  var _a2;
  var _b = overlapCfg.maxLines, maxLines = _b === void 0 ? 3 : _b, _c = overlapCfg.recoverWhenFailed, recoverWhenFailed = _c === void 0 ? true : _c, _d = overlapCfg.margin, margin = _d === void 0 ? [0, 0, 0, 0] : _d;
  var wordWrapWidth = getCallbackValue((_a2 = overlapCfg.wordWrapWidth) !== null && _a2 !== void 0 ? _a2 : 50, [main]);
  var defaultLines = labels.map(function(label) {
    return label.attr("maxLines") || 1;
  });
  var minLines = Math.min.apply(Math, __spreadArray([], __read(defaultLines), false));
  var runAndPassed = function() {
    return boundTest(labels, attr2, margin).length < 1;
  };
  var textBaseline = inferTextBaseline(attr2);
  var setLabelsWrap = function(lines2) {
    return labels.forEach(function(label, index2) {
      var maxLines2 = Array.isArray(lines2) ? lines2[index2] : lines2;
      utils.wrap(label, wordWrapWidth, maxLines2, textBaseline);
    });
  };
  if (minLines > maxLines)
    return;
  if (attr2.type === "linear" && isAxisHorizontal(attr2)) {
    setLabelsWrap(maxLines);
    if (runAndPassed()) {
      return;
    }
  } else {
    for (var lines = minLines; lines <= maxLines; lines++) {
      setLabelsWrap(lines);
      if (runAndPassed())
        return;
    }
  }
  if (recoverWhenFailed) {
    setLabelsWrap(defaultLines);
  }
}

// node_modules/@antv/component/esm/ui/axis/overlap/index.js
var OverlapUtils = /* @__PURE__ */ new Map([
  ["hide", hideLabels],
  ["rotate", rotateLabels],
  ["ellipsis", ellipseLabels],
  ["wrap", wrapLabels]
]);
function canProcessOverlap(labels, attr2, type) {
  if (attr2.labelOverlap.length < 1)
    return false;
  if (type === "hide")
    return !isInOffscreenGroup(labels[0]);
  if (type === "rotate")
    return !labels.some(function(label) {
      var _a2;
      return !!((_a2 = label.attr("transform")) === null || _a2 === void 0 ? void 0 : _a2.includes("rotate"));
    });
  if (type === "ellipsis" || type === "wrap")
    return labels.filter(function(item) {
      return item.querySelector("text");
    }).length >= 1;
  return true;
}
function processOverlap(labels, attr2, main, utils) {
  var _a2 = attr2.labelOverlap, labelOverlap = _a2 === void 0 ? [] : _a2;
  if (!labelOverlap.length)
    return;
  labelOverlap.forEach(function(overlapCfg) {
    var type = overlapCfg.type;
    var util = OverlapUtils.get(type);
    if (canProcessOverlap(labels, attr2, type))
      util === null || util === void 0 ? void 0 : util(labels, overlapCfg, attr2, utils, main);
  });
}

// node_modules/@antv/component/esm/ui/axis/utils/index.js
function getFactor() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var fn = function(str7) {
    return str7 === "positive" ? -1 : 1;
  };
  return args.reduce(function(acc, cur) {
    return acc * fn(cur);
  }, 1);
}

// node_modules/@antv/component/esm/ui/axis/guides/labels.js
function angleNormalizer(angle3) {
  var normalizedAngle = angle3;
  while (normalizedAngle < 0)
    normalizedAngle += 360;
  return Math.round(normalizedAngle % 360);
}
function getAngle3(v1, v2) {
  var _a2 = __read(v1, 2), x1 = _a2[0], y1 = _a2[1];
  var _b = __read(v2, 2), x22 = _b[0], y22 = _b[1];
  var _c = __read([x1 * x22 + y1 * y22, x1 * y22 - y1 * x22], 2), dot7 = _c[0], det = _c[1];
  return Math.atan2(det, dot7);
}
function correctLabelRotation(_rotate) {
  var rotate6 = (_rotate + 360) % 180;
  if (!inRange(rotate6, -90, 90))
    rotate6 += 180;
  return rotate6;
}
function getLabelRotation(datum, label, attr2) {
  var _a2;
  var labelAlign = attr2.labelAlign;
  var customRotate = (_a2 = label.style.transform) === null || _a2 === void 0 ? void 0 : _a2.includes("rotate");
  if (customRotate)
    return label.getLocalEulerAngles();
  var rotate6 = 0;
  var labelVector = getLabelVector(datum.value, attr2);
  var tangentVector = getLineTangentVector(datum.value, attr2);
  if (labelAlign === "horizontal")
    return 0;
  if (labelAlign === "perpendicular")
    rotate6 = getAngle3([1, 0], labelVector);
  else
    rotate6 = getAngle3([tangentVector[0] < 0 ? -1 : 1, 0], tangentVector);
  return correctLabelRotation(radToDeg(rotate6));
}
function getLabelStyle(value, rotate6, attr2) {
  var type = attr2.type, labelAlign = attr2.labelAlign;
  var labelVector = getLabelVector(value, attr2);
  var labelAngle = angleNormalizer(rotate6);
  var tickAngle = angleNormalizer(radToDeg(getAngle3([1, 0], labelVector)));
  var textAlign = "center";
  var textBaseline = "middle";
  if (type === "linear") {
    if ([90, 270].includes(tickAngle) && labelAngle === 0) {
      textAlign = "center";
      textBaseline = labelVector[1] === 1 ? "top" : "bottom";
    } else if (!(tickAngle % 180) && [90, 270].includes(labelAngle)) {
      textAlign = "center";
    } else if (tickAngle === 0) {
      if (inRange(labelAngle, 0, 90, false, true)) {
        textAlign = "start";
      } else if (inRange(labelAngle, 0, 90) || inRange(labelAngle, 270, 360)) {
        textAlign = "start";
      }
    } else if (tickAngle === 90) {
      if (inRange(labelAngle, 0, 90, false, true)) {
        textAlign = "start";
      } else if (inRange(labelAngle, 90, 180) || inRange(labelAngle, 270, 360)) {
        textAlign = "end";
      }
    } else if (tickAngle === 270) {
      if (inRange(labelAngle, 0, 90, false, true)) {
        textAlign = "end";
      } else if (inRange(labelAngle, 90, 180) || inRange(labelAngle, 270, 360)) {
        textAlign = "start";
      }
    } else if (tickAngle === 180) {
      if (labelAngle === 90) {
        textAlign = "start";
      } else if (inRange(labelAngle, 0, 90) || inRange(labelAngle, 270, 360)) {
        textAlign = "end";
      }
    }
  } else {
    if (labelAlign === "parallel") {
      if (inRange(tickAngle, 0, 180, true)) {
        textBaseline = "top";
      } else {
        textBaseline = "bottom";
      }
    } else if (labelAlign === "horizontal") {
      if (inRange(tickAngle, 90, 270, false)) {
        textAlign = "end";
      } else if (inRange(tickAngle, 270, 360, false) || inRange(tickAngle, 0, 90)) {
        textAlign = "start";
      }
    } else if (labelAlign === "perpendicular") {
      if (inRange(tickAngle, 90, 270)) {
        textAlign = "end";
      } else {
        textAlign = "start";
      }
    }
  }
  return { textAlign, textBaseline };
}
function setRotateAndAdjustLabelAlign(rotate6, group2, attr2) {
  group2.setLocalEulerAngles(rotate6);
  var value = group2.__data__.value;
  var textStyle = getLabelStyle(value, rotate6, attr2);
  var label = group2.querySelector(CLASS_NAMES.labelItem.class);
  if (label)
    applyTextStyle(label, textStyle);
}
function getLabelPos(datum, data2, attr2) {
  var showTick = attr2.showTick, tickLength = attr2.tickLength, tickDirection = attr2.tickDirection, labelDirection = attr2.labelDirection, labelSpacing = attr2.labelSpacing;
  var index2 = data2.indexOf(datum);
  var finalLabelSpacing = getCallbackValue(labelSpacing, [datum, index2, data2]);
  var _a2 = __read([getLabelVector(datum.value, attr2), getFactor(labelDirection, tickDirection)], 2), labelVector = _a2[0], unionFactor = _a2[1];
  var extraLength = unionFactor === 1 ? getCallbackValue(showTick ? tickLength : 0, [datum, index2, data2]) : 0;
  var _b = __read(add8(scale8(labelVector, finalLabelSpacing + extraLength), getValuePos(datum.value, attr2)), 2), x3 = _b[0], y3 = _b[1];
  return { x: x3, y: y3 };
}
function formatter(datum, index2, data2, attr2) {
  var labelFormatter2 = attr2.labelFormatter;
  var element = isFunction(labelFormatter2) ? function() {
    return renderExtDo(getCallbackValue(labelFormatter2, [datum, index2, data2, getLabelVector(datum.value, attr2)]));
  } : function() {
    return renderExtDo(datum.label || "");
  };
  return element;
}
function renderHTMLLabel(datum, index2, data2, attr2) {
  var labelRender = attr2.labelRender;
  var elementWidth = (get_default(attr2, "endPos.0", 400) - get_default(attr2, "startPos.0", 0)) / data2.length;
  var elStr = isFunction(labelRender) ? getCallbackValue(labelRender, [datum, index2, data2, getLabelVector(datum.value, attr2)]) : datum.label || "";
  var elementHeight = parseHeightFromHTML(elStr) || 30;
  return function() {
    return renderHtmlExtDo(elStr, {
      width: elementWidth,
      height: elementHeight
    });
  };
}
var STYLE_OMIT_MAP = {
  html: ["fill"],
  text: []
};
function applyTextStyle(node, style) {
  if (["text", "html"].includes(node.nodeName))
    node.attr(omit(style, STYLE_OMIT_MAP[node.nodeName]));
}
function overlapHandler(attr2, main) {
  processOverlap(this.node().childNodes, attr2, main, {
    hide,
    show,
    rotate: function(label, angle3) {
      setRotateAndAdjustLabelAlign(+angle3, label, attr2);
    },
    ellipsis: function(label, len5, suffix) {
      label && ellipsisIt(label, len5 || Infinity, suffix);
    },
    wrap: function(label, width, lines) {
      label && wrapIt(label, width, lines);
    },
    getTextShape: function(label) {
      return label.querySelector(CLASS_NAMES.labelItem.class);
    }
  });
}
function renderLabel(container, datum, data2, style, attr2) {
  var index2 = data2.indexOf(datum);
  var labelRender = attr2.labelRender, classNamePrefix = attr2.classNamePrefix;
  var label = select(container).append(labelRender ? renderHTMLLabel(datum, index2, data2, attr2) : formatter(datum, index2, data2, attr2)).attr("className", CLASS_NAMES.labelItem.name).node();
  applyClassName(select(label), CLASS_NAMES.labelItem, CLASSNAME_SUFFIX_MAP.labelItem, classNamePrefix);
  var _a2 = __read(splitStyle(getCallbackStyle(style, [datum, index2, data2])), 2), labelStyle = _a2[0], _b = _a2[1], transform2 = _b.transform, groupStyle = __rest(_b, ["transform"]);
  percentTransform(label, transform2);
  var rotate6 = getLabelRotation(datum, label, attr2);
  if (!label.getLocalEulerAngles()) {
    label.setLocalEulerAngles(rotate6);
  }
  applyTextStyle(label, __assign(__assign({}, getLabelStyle(datum.value, rotate6, attr2)), labelStyle));
  if (label.nodeName === "html") {
    var bbox = label.getBBox();
    var currentX = label.style.x || 0;
    label.attr("x", currentX - bbox.width / 2);
  }
  container.attr(groupStyle);
  return label;
}
function renderLabels(container, data2, attr2, animate2, main) {
  var classNamePrefix = attr2.classNamePrefix;
  var finalData = filterExec(data2, attr2.labelFilter);
  var style = subStyleProps(attr2, "label");
  var _exit;
  var transitions = container.selectAll(CLASS_NAMES.label.class).data(finalData, function(d2, i) {
    return i;
  }).join(function(enter) {
    var labels = enter.append("g").attr("className", CLASS_NAMES.label.name).transition(function(datum) {
      renderLabel(this, datum, data2, style, attr2);
      var _a2 = getLabelPos(datum, data2, attr2), x3 = _a2.x, y3 = _a2.y;
      this.style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
      return null;
    });
    applyClassName(labels, CLASS_NAMES.label, CLASSNAME_SUFFIX_MAP.label, classNamePrefix);
    return labels;
  }, function(update2) {
    return update2.transition(function(datum) {
      var prevLabel = this.querySelector(CLASS_NAMES.labelItem.class);
      var label = renderLabel(this, datum, data2, style, attr2);
      var shapeAnimation = transitionShape(prevLabel, label, animate2.update);
      var _a2 = getLabelPos(datum, data2, attr2), x3 = _a2.x, y3 = _a2.y;
      var animation = transition(this, { transform: "translate(".concat(x3, ", ").concat(y3, ")") }, animate2.update);
      return __spreadArray(__spreadArray([], __read(shapeAnimation), false), [animation], false);
    });
  }, function(exit) {
    _exit = exit;
    exit.transition(function() {
      var _this2 = this;
      var animation = fadeOut_default(this.childNodes[0], animate2.exit);
      onAnimateFinished(animation, function() {
        return select(_this2).remove();
      });
      return animation;
    });
    return _exit;
  }).transitions();
  onAnimatesFinished(transitions, function() {
    overlapHandler.call(container, attr2, main);
  });
  return transitions;
}

// node_modules/@antv/component/esm/ui/axis/guides/ticks.js
function getTickVector(value, attr2) {
  return getDirectionVector(value, attr2.tickDirection, attr2);
}
function getTickPoints(unitVector, tickLength) {
  var _a2 = __read(unitVector, 2), dx = _a2[0], dy = _a2[1];
  return [
    [0, 0],
    [dx * tickLength, dy * tickLength]
  ];
}
function getTickLineLayout(datum, index2, data2, tickVector, attr2) {
  var tickLength = attr2.tickLength;
  var _a2 = __read(getTickPoints(tickVector, getCallbackValue(tickLength, [datum, index2, data2])), 2), _b = __read(_a2[0], 2), x1 = _b[0], y1 = _b[1], _c = __read(_a2[1], 2), x22 = _c[0], y22 = _c[1];
  return { x1, x2: x22, y1, y2: y22 };
}
function createTickEl(container, datum, index2, data2, attr2) {
  var formatter2 = attr2.tickFormatter, classNamePrefix = attr2.classNamePrefix;
  var tickVector = getTickVector(datum.value, attr2);
  var el = "line";
  if (isFunction(formatter2))
    el = function() {
      return getCallbackValue(formatter2, [datum, index2, data2, tickVector]);
    };
  var tick2 = container.append(el).attr("className", CLASS_NAMES.tickItem.name);
  applyClassName(tick2, CLASS_NAMES.tickItem, CLASSNAME_SUFFIX_MAP.tickItem, classNamePrefix);
  return tick2;
}
function applyTickStyle(datum, index2, data2, tick2, group2, attr2, style) {
  var tickVector = getTickVector(datum.value, attr2);
  var _a2 = getTickLineLayout(datum, index2, data2, tickVector, attr2), x1 = _a2.x1, x22 = _a2.x2, y1 = _a2.y1, y22 = _a2.y2;
  var _b = __read(splitStyle(getCallbackStyle(style, [datum, index2, data2, tickVector])), 2), tickStyle = _b[0], groupStyle = _b[1];
  tick2.node().nodeName === "line" && tick2.styles(__assign({ x1, x2: x22, y1, y2: y22 }, tickStyle));
  group2.attr(groupStyle);
  tick2.styles(tickStyle);
}
function createTick(datum, index2, data2, attr2, tickAttr, animate2) {
  var tick2 = createTickEl(select(this), datum, index2, data2, attr2);
  applyTickStyle(datum, index2, data2, tick2, this, attr2, tickAttr);
  var _a2 = __read(getValuePos(datum.value, attr2), 2), x3 = _a2[0], y3 = _a2[1];
  return transition(this, { transform: "translate(".concat(x3, ", ").concat(y3, ")") }, animate2);
}
function renderTicks(container, axisData, attr2, animate2) {
  var classNamePrefix = attr2.classNamePrefix;
  var finalData = filterExec(axisData, attr2.tickFilter);
  var tickAttr = subStyleProps(attr2, "tick");
  return container.selectAll(CLASS_NAMES.tick.class).data(finalData, function(d2) {
    return d2.id || d2.label;
  }).join(function(enter) {
    var ticks = enter.append("g").attr("className", CLASS_NAMES.tick.name).transition(function(datum, index2) {
      return createTick.call(this, datum, index2, finalData, attr2, tickAttr, false);
    });
    applyClassName(ticks, CLASS_NAMES.tick, CLASSNAME_SUFFIX_MAP.tick, classNamePrefix);
    return ticks;
  }, function(update2) {
    return update2.transition(function(datum, index2) {
      this.removeChildren();
      return createTick.call(this, datum, index2, finalData, attr2, tickAttr, animate2.update);
    });
  }, function(exit) {
    return exit.transition(function() {
      var _this2 = this;
      var animation = fadeOut_default(this.childNodes[0], animate2.exit);
      onAnimateFinished(animation, function() {
        return _this2.remove();
      });
      return animation;
    });
  }).transitions();
}

// node_modules/@antv/component/esm/ui/axis/guides/title.js
function getTitlePosition(mainGroup, titleGroup, attr2) {
  var _a2 = attr2.titlePosition, position = _a2 === void 0 ? "lb" : _a2, spacing = attr2.titleSpacing;
  var pos = parsePosition(position);
  var _b = mainGroup.node().getLocalBounds(), _c = __read(_b.min, 2), mainX = _c[0], mainY = _c[1], _d = __read(_b.halfExtents, 2), mainHalfWidth = _d[0], mainHalfHeight = _d[1];
  var _e = __read(titleGroup.node().getLocalBounds().halfExtents, 2), titleHalfWidth = _e[0], titleHalfHeight = _e[1];
  var _f = __read([mainX + mainHalfWidth, mainY + mainHalfHeight], 2), x3 = _f[0], y3 = _f[1];
  var _g = __read(parseSeriesAttr(spacing), 4), spacingTop = _g[0], spacingRight = _g[1], spacingBottom = _g[2], spacingLeft = _g[3];
  if (["start", "end"].includes(position) && attr2.type === "linear") {
    var startPos = attr2.startPos, endPos = attr2.endPos;
    var _h = __read(position === "start" ? [startPos, endPos] : [endPos, startPos], 2), from = _h[0], to = _h[1];
    var direction3 = normalize6([-to[0] + from[0], -to[1] + from[1]]);
    var _j = __read(scale8(direction3, spacingTop), 2), dx = _j[0], dy = _j[1];
    return { x: from[0] + dx, y: from[1] + dy };
  }
  if (pos.includes("t"))
    y3 -= mainHalfHeight + titleHalfHeight + spacingTop;
  if (pos.includes("r"))
    x3 += mainHalfWidth + titleHalfWidth + spacingRight;
  if (pos.includes("l"))
    x3 -= mainHalfWidth + titleHalfWidth + spacingLeft;
  if (pos.includes("b"))
    y3 += mainHalfHeight + titleHalfHeight + spacingBottom;
  return { x: x3, y: y3 };
}
function inferTransform(n, direction3, position) {
  var halfExtents = n.getGeometryBounds().halfExtents;
  var height = halfExtents[1] * 2;
  if (direction3 === "vertical") {
    if (position === "left")
      return "rotate(-90) translate(0, ".concat(height / 2, ")");
    if (position === "right")
      return "rotate(-90) translate(0, -".concat(height / 2, ")");
  }
  return "";
}
function applyTitleStyle(title, group2, axis, attr2, animate2) {
  var style = subStyleProps(attr2, "title");
  var _a2 = __read(splitStyle(style), 2), titleStyle = _a2[0], _b = _a2[1], specified = _b.transform, transformOrigin = _b.transformOrigin, groupStyle = __rest(_b, ["transform", "transformOrigin"]);
  group2.styles(groupStyle);
  var transform2 = specified || inferTransform(title.node(), titleStyle.direction, titleStyle.position);
  title.styles(__assign(__assign({}, titleStyle), { transformOrigin }));
  percentTransform(title.node(), transform2);
  var _c = getTitlePosition(
    // @ts-ignore
    select(axis._offscreen || axis.querySelector(CLASS_NAMES.mainGroup.class)),
    group2,
    attr2
  ), x3 = _c.x, y3 = _c.y;
  var animation = transition(group2.node(), { transform: "translate(".concat(x3, ", ").concat(y3, ")") }, animate2);
  return animation;
}
function renderTitle(container, axis, attr2, animate2) {
  var titleText = attr2.titleText, classNamePrefix = attr2.classNamePrefix;
  return container.selectAll(CLASS_NAMES.title.class).data([{ title: titleText }].filter(function(d2) {
    return !!d2.title;
  }), function(d2, i) {
    return d2.title;
  }).join(function(enter) {
    var titles = enter.append(function() {
      return renderExtDo(titleText);
    }).attr("className", CLASS_NAMES.title.name).transition(function() {
      return applyTitleStyle(select(this), container, axis, attr2, animate2.enter);
    });
    applyClassName(titles, CLASS_NAMES.title, CLASSNAME_SUFFIX_MAP.title, classNamePrefix);
    return titles;
  }, function(update2) {
    return update2.transition(function() {
      return applyTitleStyle(select(this), container, axis, attr2, animate2.update);
    });
  }, function(exit) {
    return exit.remove();
  }).transitions();
}

// node_modules/@antv/component/esm/ui/axis/axis.js
function renderAxisMain(attributes, container, data2, animation) {
  var showLine = attributes.showLine, showTick = attributes.showTick, showLabel = attributes.showLabel, classNamePrefix = attributes.classNamePrefix;
  var lineGroup = container.maybeAppendByClassName(CLASS_NAMES.lineGroup, "g");
  applyClassName(lineGroup, CLASS_NAMES.lineGroup, CLASSNAME_SUFFIX_MAP.lineGroup, classNamePrefix);
  var lineTransitions = ifShow(showLine, lineGroup, function(group2) {
    return renderAxisLine(group2, attributes, animation);
  }) || [];
  var tickGroup = container.maybeAppendByClassName(CLASS_NAMES.tickGroup, "g");
  applyClassName(tickGroup, CLASS_NAMES.tickGroup, CLASSNAME_SUFFIX_MAP.tickGroup, classNamePrefix);
  var tickTransitions = ifShow(showTick, tickGroup, function(group2) {
    return renderTicks(group2, data2, attributes, animation);
  }) || [];
  var labelGroup = container.maybeAppendByClassName(CLASS_NAMES.labelGroup, "g");
  applyClassName(labelGroup, CLASS_NAMES.labelGroup, CLASSNAME_SUFFIX_MAP.labelGroup, classNamePrefix);
  var labelTransitions = ifShow(showLabel, labelGroup, function(group2) {
    return renderLabels(group2, data2, attributes, animation, container.node());
  }) || [];
  return __spreadArray(__spreadArray(__spreadArray([], __read(lineTransitions), false), __read(tickTransitions), false), __read(labelTransitions), false).filter(function(t) {
    return !!t;
  });
}
var Axis = (
  /** @class */
  function(_super) {
    __extends(Axis2, _super);
    function Axis2(options) {
      return _super.call(this, options, AXIS_BASE_DEFAULT_ATTR) || this;
    }
    Axis2.prototype.render = function(attributes, container, specificAnimation) {
      var _this2 = this;
      var titleText = attributes.titleText, data2 = attributes.data, animate2 = attributes.animate, showTitle = attributes.showTitle, showGrid = attributes.showGrid, dataThreshold = attributes.dataThreshold, truncRange = attributes.truncRange, classNamePrefix = attributes.classNamePrefix;
      var baseClassName = container.className || "axis";
      if (classNamePrefix) {
        container.attr("className", "".concat(baseClassName, " ").concat(classNamePrefix, "axis"));
      } else if (!container.className) {
        container.attr("className", "axis");
      }
      var sampledData = sampling(data2, dataThreshold).filter(function(_a2) {
        var value = _a2.value;
        if (truncRange && value > truncRange[0] && value < truncRange[1])
          return false;
        return true;
      });
      var finalAnimation = parseAnimationOption(specificAnimation === void 0 ? animate2 : specificAnimation);
      var gridGroup = select(container).maybeAppendByClassName(CLASS_NAMES.gridGroup, "g");
      applyClassName(gridGroup, CLASS_NAMES.gridGroup, CLASSNAME_SUFFIX_MAP.gridGroup, classNamePrefix);
      var gridTransitions = ifShow(showGrid, gridGroup, function(group2) {
        return renderGrid(group2, sampledData, attributes, finalAnimation);
      }) || [];
      var mainGroup = select(container).maybeAppendByClassName(CLASS_NAMES.mainGroup, "g");
      applyClassName(mainGroup, CLASS_NAMES.mainGroup, CLASSNAME_SUFFIX_MAP.mainGroup, classNamePrefix);
      if (titleText && (!this.initialized && finalAnimation.enter || this.initialized && finalAnimation.update)) {
        renderAxisMain(attributes, select(this.offscreenGroup), sampledData, parseAnimationOption(false));
      }
      var mainTransitions = renderAxisMain(attributes, select(mainGroup.node()), sampledData, finalAnimation);
      var titleGroup = select(container).maybeAppendByClassName(CLASS_NAMES.titleGroup, "g");
      applyClassName(titleGroup, CLASS_NAMES.titleGroup, CLASSNAME_SUFFIX_MAP.titleGroup, classNamePrefix);
      var titleTransitions = ifShow(showTitle, titleGroup, function(group2) {
        return renderTitle(group2, _this2, attributes, finalAnimation);
      }) || [];
      return __spreadArray(__spreadArray(__spreadArray([], __read(gridTransitions), false), __read(mainTransitions), false), __read(titleTransitions), false).flat().filter(function(t) {
        return !!t;
      });
    };
    return Axis2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/utils/classname.js
function getLegendClassName(baseClassName, suffix, classNamePrefix) {
  if (!classNamePrefix)
    return baseClassName;
  return "".concat(baseClassName, " ").concat(classNamePrefix, "legend-").concat(suffix);
}

// node_modules/@antv/component/esm/ui/marker/symbol.js
var circle = function(x3, y3, r) {
  return [["M", x3 - r, y3], ["A", r, r, 0, 1, 0, x3 + r, y3], ["A", r, r, 0, 1, 0, x3 - r, y3], ["Z"]];
};
var point = circle;
var square = function(x3, y3, r) {
  return [["M", x3 - r, y3 - r], ["L", x3 + r, y3 - r], ["L", x3 + r, y3 + r], ["L", x3 - r, y3 + r], ["Z"]];
};
var diamond = function(x3, y3, r) {
  return [["M", x3 - r, y3], ["L", x3, y3 - r], ["L", x3 + r, y3], ["L", x3, y3 + r], ["Z"]];
};
var triangle = function(x3, y3, r) {
  var diffY = r * Math.sin(1 / 3 * Math.PI);
  return [["M", x3 - r, y3 + diffY], ["L", x3, y3 - diffY], ["L", x3 + r, y3 + diffY], ["Z"]];
};
var triangleDown = function(x3, y3, r) {
  var diffY = r * Math.sin(1 / 3 * Math.PI);
  return [["M", x3 - r, y3 - diffY], ["L", x3 + r, y3 - diffY], ["L", x3, y3 + diffY], ["Z"]];
};
var hexagon = function(x3, y3, r) {
  var diffX = r / 2 * Math.sqrt(3);
  return [
    ["M", x3, y3 - r],
    ["L", x3 + diffX, y3 - r / 2],
    ["L", x3 + diffX, y3 + r / 2],
    ["L", x3, y3 + r],
    ["L", x3 - diffX, y3 + r / 2],
    ["L", x3 - diffX, y3 - r / 2],
    ["Z"]
  ];
};
var bowtie = function(x3, y3, r) {
  var diffY = r - 1.5;
  return [["M", x3 - r, y3 - diffY], ["L", x3 + r, y3 + diffY], ["L", x3 + r, y3 - diffY], ["L", x3 - r, y3 + diffY], ["Z"]];
};
var line = function(x3, y3, r) {
  return [
    ["M", x3, y3 + r],
    ["L", x3, y3 - r]
  ];
};
var cross4 = function(x3, y3, r) {
  return [
    ["M", x3 - r, y3 - r],
    ["L", x3 + r, y3 + r],
    ["M", x3 + r, y3 - r],
    ["L", x3 - r, y3 + r]
  ];
};
var tick = function(x3, y3, r) {
  return [
    ["M", x3 - r / 2, y3 - r],
    ["L", x3 + r / 2, y3 - r],
    ["M", x3, y3 - r],
    ["L", x3, y3 + r],
    ["M", x3 - r / 2, y3 + r],
    ["L", x3 + r / 2, y3 + r]
  ];
};
var plus = function(x3, y3, r) {
  return [
    ["M", x3 - r, y3],
    ["L", x3 + r, y3],
    ["M", x3, y3 - r],
    ["L", x3, y3 + r]
  ];
};
var hyphen = function(x3, y3, r) {
  return [
    ["M", x3 - r, y3],
    ["L", x3 + r, y3]
  ];
};
var dot6 = function(x3, y3, r) {
  return [
    ["M", x3 - r, y3],
    ["L", x3 + r, y3]
  ];
};
var dash = dot6;
var smooth = function(x3, y3, r) {
  return [
    ["M", x3 - r, y3],
    ["A", r / 2, r / 2, 0, 1, 1, x3, y3],
    ["A", r / 2, r / 2, 0, 1, 0, x3 + r, y3]
  ];
};
var hv = function(x3, y3, r) {
  return [
    ["M", x3 - r - 1, y3 - 2.5],
    ["L", x3, y3 - 2.5],
    ["L", x3, y3 + 2.5],
    ["L", x3 + r + 1, y3 + 2.5]
  ];
};
var vh = function(x3, y3, r) {
  return [
    ["M", x3 - r - 1, y3 + 2.5],
    ["L", x3, y3 + 2.5],
    ["L", x3, y3 - 2.5],
    ["L", x3 + r + 1, y3 - 2.5]
  ];
};
var hvh = function(x3, y3, r) {
  return [
    ["M", x3 - (r + 1), y3 + 2.5],
    ["L", x3 - r / 2, y3 + 2.5],
    ["L", x3 - r / 2, y3 - 2.5],
    ["L", x3 + r / 2, y3 - 2.5],
    ["L", x3 + r / 2, y3 + 2.5],
    ["L", x3 + r + 1, y3 + 2.5]
  ];
};
function vhv(x3, y3) {
  return [
    ["M", x3 - 5, y3 + 2.5],
    ["L", x3 - 5, y3],
    ["L", x3, y3],
    ["L", x3, y3 - 3],
    ["L", x3, y3 + 3],
    ["L", x3 + 6.5, y3 + 3]
  ];
}
var button = function(x3, y3, r) {
  return [["M", x3 - r, y3 - r], ["L", x3 + r, y3], ["L", x3 - r, y3 + r], ["Z"]];
};
var focus = function(x3, y3, r) {
  var outerRadius = r;
  var innerRadius = r * 0.2;
  var crossLength = r * 0.7;
  return [
    // 外圆
    ["M", x3 - outerRadius, y3],
    ["A", outerRadius, outerRadius, 0, 1, 0, x3 + outerRadius, y3],
    ["A", outerRadius, outerRadius, 0, 1, 0, x3 - outerRadius, y3],
    ["Z"],
    // 水平十字线 (简单线条)
    ["M", x3 - crossLength, y3],
    ["L", x3 - innerRadius, y3],
    ["M", x3 + innerRadius, y3],
    ["L", x3 + crossLength, y3],
    // 垂直十字线 (简单线条)
    ["M", x3, y3 - crossLength],
    ["L", x3, y3 - innerRadius],
    ["M", x3, y3 + innerRadius],
    ["L", x3, y3 + crossLength]
  ];
};

// node_modules/@antv/component/esm/ui/marker/utils.js
function parseMarker(icon) {
  var type = "default";
  if (is_object_default(icon) && icon instanceof Image)
    type = "image";
  else if (isFunction(icon))
    type = "symbol";
  else if (isString(icon)) {
    var dataURLsPattern = new RegExp("data:(image|text)");
    if (icon.match(dataURLsPattern)) {
      type = "base64";
    } else if (/^(https?:\/\/(([a-zA-Z0-9]+-?)+[a-zA-Z0-9]+\.)+[a-zA-Z]+)(:\d+)?(\/.*)?(\?.*)?(#.*)?$/.test(icon)) {
      type = "url";
    } else {
      type = "symbol";
    }
  }
  return type;
}

// node_modules/@antv/component/esm/ui/marker/index.js
function getType2(symbol) {
  var markerType = parseMarker(symbol);
  if (["base64", "url", "image"].includes(markerType)) {
    return "image";
  }
  if (symbol && markerType === "symbol") {
    return "path";
  }
  return null;
}
var Marker = (
  /** @class */
  function(_super) {
    __extends(Marker2, _super);
    function Marker2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Marker2.prototype.render = function(attributes, container) {
      var _a2 = attributes.x, x3 = _a2 === void 0 ? 0 : _a2, _b = attributes.y, y3 = _b === void 0 ? 0 : _b;
      var _c = this.getSubShapeStyle(attributes), symbol = _c.symbol, _d = _c.size, size2 = _d === void 0 ? 16 : _d, style = __rest(_c, ["symbol", "size"]);
      var type = getType2(symbol);
      ifShow(!!type, select(container), function(group2) {
        group2.maybeAppendByClassName("marker", type).attr("className", "marker ".concat(type, "-marker")).call(function(selection) {
          if (type === "image") {
            var r = size2 * 2;
            selection.styles({
              img: symbol,
              width: r,
              height: r,
              x: x3 - size2,
              y: y3 - size2
            });
          } else {
            var r = size2 / 2;
            var symbolFn = isFunction(symbol) ? symbol : Marker2.getSymbol(symbol);
            selection.styles(__assign({ d: symbolFn === null || symbolFn === void 0 ? void 0 : symbolFn(x3, y3, r) }, style));
          }
        });
      });
    };
    Marker2.MARKER_SYMBOL_MAP = /* @__PURE__ */ new Map();
    Marker2.registerSymbol = function(type, symbol) {
      Marker2.MARKER_SYMBOL_MAP.set(type, symbol);
    };
    Marker2.getSymbol = function(type) {
      return Marker2.MARKER_SYMBOL_MAP.get(type);
    };
    Marker2.getSymbols = function() {
      return Array.from(Marker2.MARKER_SYMBOL_MAP.keys());
    };
    return Marker2;
  }(Component)
);
Marker.registerSymbol("cross", cross4);
Marker.registerSymbol("hyphen", hyphen);
Marker.registerSymbol("line", line);
Marker.registerSymbol("plus", plus);
Marker.registerSymbol("tick", tick);
Marker.registerSymbol("circle", circle);
Marker.registerSymbol("point", point);
Marker.registerSymbol("bowtie", bowtie);
Marker.registerSymbol("hexagon", hexagon);
Marker.registerSymbol("square", square);
Marker.registerSymbol("diamond", diamond);
Marker.registerSymbol("triangle", triangle);
Marker.registerSymbol("triangle-down", triangleDown);
Marker.registerSymbol("line", line);
Marker.registerSymbol("dot", dot6);
Marker.registerSymbol("dash", dash);
Marker.registerSymbol("smooth", smooth);
Marker.registerSymbol("hv", hv);
Marker.registerSymbol("vh", vh);
Marker.registerSymbol("hvh", hvh);
Marker.registerSymbol("vhv", vhv);
Marker.registerSymbol("focus", focus);

// node_modules/@antv/component/esm/ui/legend/utils.js
function getStepValueByValue(value, step2, min5) {
  var count = Math.round((value - min5) / step2);
  return min5 + count * step2;
}
function hiddenHandle(x3, y3, r) {
  var ratio = 1.4;
  var diffY = ratio * r;
  return [["M", x3 - r, y3 - diffY], ["L", x3 + r, y3 - diffY], ["L", x3 + r, y3 + diffY], ["L", x3 - r, y3 + diffY], ["Z"]];
}
var HANDLE_HEIGHT_RATIO = 1.4;
var HANDLE_TRIANGLE_RATIO = 0.4;
function verticalHandle(x3, y3, r) {
  var width = r;
  var height = width * HANDLE_HEIGHT_RATIO;
  var halfWidth = width / 2;
  var oneSixthWidth = width / 6;
  var triangleX = x3 + height * HANDLE_TRIANGLE_RATIO;
  return [
    ["M", x3, y3],
    ["L", triangleX, y3 + halfWidth],
    ["L", x3 + height, y3 + halfWidth],
    ["L", x3 + height, y3 - halfWidth],
    ["L", triangleX, y3 - halfWidth],
    ["Z"],
    // 绘制两条横线
    ["M", triangleX, y3 + oneSixthWidth],
    ["L", x3 + height - 2, y3 + oneSixthWidth],
    ["M", triangleX, y3 - oneSixthWidth],
    ["L", x3 + height - 2, y3 - oneSixthWidth]
  ];
}
function horizontalHandle(x3, y3, r) {
  var width = r;
  var height = width * HANDLE_HEIGHT_RATIO;
  var halfWidth = width / 2;
  var oneSixthWidth = width / 6;
  var triangleY = y3 + height * HANDLE_TRIANGLE_RATIO;
  return [
    ["M", x3, y3],
    ["L", x3 - halfWidth, triangleY],
    ["L", x3 - halfWidth, y3 + height],
    ["L", x3 + halfWidth, y3 + height],
    ["L", x3 + halfWidth, triangleY],
    ["Z"],
    // 绘制两条竖线
    ["M", x3 - oneSixthWidth, triangleY],
    ["L", x3 - oneSixthWidth, y3 + height - 2],
    ["M", x3 + oneSixthWidth, triangleY],
    ["L", x3 + oneSixthWidth, y3 + height - 2]
  ];
}
Marker.registerSymbol("hiddenHandle", hiddenHandle);
Marker.registerSymbol("verticalHandle", verticalHandle);
Marker.registerSymbol("horizontalHandle", horizontalHandle);
function getSafetySelections(domain, newSelection, oldSelection, precision) {
  var _a2;
  if (precision === void 0) {
    precision = 4;
  }
  var _b = __read(domain, 2), min5 = _b[0], max6 = _b[1];
  var _c = __read(newSelection, 2), start = _c[0], end = _c[1];
  var _d = __read(oldSelection, 2), prevStart = _d[0], prevEnd = _d[1];
  var _e = __read([start, end], 2), startVal = _e[0], endVal = _e[1];
  var range = endVal - startVal;
  if (startVal > endVal) {
    _a2 = __read([endVal, startVal], 2), startVal = _a2[0], endVal = _a2[1];
  }
  if (range > max6 - min5) {
    return [min5, max6];
  }
  if (startVal < min5) {
    if (prevStart === min5 && prevEnd === endVal) {
      return [min5, endVal];
    }
    return [min5, range + min5];
  }
  if (endVal > max6) {
    if (prevEnd === max6 && prevStart === startVal) {
      return [startVal, max6];
    }
    return [max6 - range, max6];
  }
  return [startVal, endVal];
}
function ifHorizontal(orientation, a2, b) {
  if (orientation === void 0) {
    orientation = "horizontal";
  }
  return orientation === "horizontal" ? a2 : b;
}

// node_modules/@antv/component/esm/ui/legend/classname-map.js
var CLASSNAME_SUFFIX_MAP2 = {
  // Common elements
  title: "title",
  // Category legend elements
  item: "item",
  marker: "marker",
  label: "label",
  value: "value",
  focusIcon: "focus-icon",
  background: "background",
  // Continuous legend elements
  ribbon: "ribbon",
  track: "track",
  selection: "selection",
  handle: "handle",
  handleMarker: "handle-marker",
  handleLabel: "handle-label",
  indicator: "indicator",
  // Navigator elements (reserved)
  prevBtn: "prev-btn",
  nextBtn: "next-btn",
  pageInfo: "page-info"
};

// node_modules/@antv/component/esm/ui/legend/continuous/handle.js
var CLASS_NAMES3 = classNames({
  markerGroup: "marker-group",
  marker: "marker",
  labelGroup: "label-group",
  label: "label"
}, "handle");
var DEFAULT_HANDLE_CFG = {
  showLabel: true,
  formatter: function(val) {
    return val.toString();
  },
  markerSize: 25,
  markerStroke: "#c5c5c5",
  markerFill: "#fff",
  markerLineWidth: 1,
  labelFontSize: 12,
  labelFill: "#c5c5c5",
  labelText: "",
  orientation: "vertical",
  spacing: 0
};
var Handle = (
  /** @class */
  function(_super) {
    __extends(Handle3, _super);
    function Handle3(options) {
      return _super.call(this, options, DEFAULT_HANDLE_CFG) || this;
    }
    Handle3.prototype.render = function(attributes, container) {
      var markerGroup = select(container).maybeAppendByClassName(CLASS_NAMES3.markerGroup, "g");
      this.renderMarker(markerGroup);
      var labelGroup = select(container).maybeAppendByClassName(CLASS_NAMES3.labelGroup, "g");
      this.renderLabel(labelGroup);
    };
    Handle3.prototype.renderMarker = function(container) {
      var _this2 = this;
      var _a2 = this.attributes, orientation = _a2.orientation, classNamePrefix = _a2.classNamePrefix, _b = _a2.markerSymbol, markerSymbol = _b === void 0 ? ifHorizontal(orientation, "horizontalHandle", "verticalHandle") : _b;
      ifShow(!!markerSymbol, container, function(group2) {
        var handleStyle = subStyleProps(_this2.attributes, "marker");
        var markerStyle = __assign({ symbol: markerSymbol }, handleStyle);
        var markerClassName = getLegendClassName(CLASS_NAMES3.marker.name, CLASSNAME_SUFFIX_MAP2.handleMarker, classNamePrefix);
        _this2.marker = group2.maybeAppendByClassName(CLASS_NAMES3.marker, function() {
          return new Marker({
            style: markerStyle,
            className: markerClassName
          });
        }).update(markerStyle);
        if (classNamePrefix) {
          var markerElement = _this2.marker.node().querySelector(".marker");
          if (markerElement) {
            var currentClass = markerElement.getAttribute("class") || "";
            var baseClass = currentClass.split(" ")[0];
            var legendClassName = getLegendClassName(baseClass, CLASSNAME_SUFFIX_MAP2.handleMarker, classNamePrefix);
            markerElement.setAttribute("class", legendClassName);
          }
        }
      });
    };
    Handle3.prototype.renderLabel = function(container) {
      var _this2 = this;
      var _a2 = this.attributes, showLabel = _a2.showLabel, orientation = _a2.orientation, _b = _a2.spacing, spacing = _b === void 0 ? 0 : _b, formatter2 = _a2.formatter, classNamePrefix = _a2.classNamePrefix;
      ifShow(showLabel, container, function(group2) {
        var _a3;
        var _b2 = subStyleProps(_this2.attributes, "label"), text = _b2.text, labelStyle = __rest(_b2, ["text"]);
        var _c = ((_a3 = group2.select(CLASS_NAMES3.marker.class)) === null || _a3 === void 0 ? void 0 : _a3.node().getBBox()) || {}, _d = _c.width, width = _d === void 0 ? 0 : _d, _e = _c.height, height = _e === void 0 ? 0 : _e;
        var _f = __read(ifHorizontal(orientation, [0, height + spacing, "center", "top"], [width + spacing, 0, "start", "middle"]), 4), x3 = _f[0], y3 = _f[1], textAlign = _f[2], textBaseline = _f[3];
        var labelClassName = getLegendClassName(CLASS_NAMES3.label.name, CLASSNAME_SUFFIX_MAP2.handleLabel, classNamePrefix);
        group2.maybeAppendByClassName(CLASS_NAMES3.label, "text").attr("className", labelClassName).styles(__assign(__assign({}, labelStyle), { x: x3, y: y3, text: formatter2(text).toString(), textAlign, textBaseline }));
      });
    };
    return Handle3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/constant.js
var LEGEND_BASE_DEFAULT_OPTIONS = {
  showTitle: true,
  padding: 0,
  orientation: "horizontal",
  backgroundFill: "transparent",
  titleText: "",
  titleSpacing: 4,
  titlePosition: "top-left",
  titleFill: "#2C3542",
  titleFontWeight: "bold",
  titleFontFamily: "sans-serif",
  titleFontSize: 12
};
var CATEGORY_DEFAULT_OPTIONS = deepAssign({}, LEGEND_BASE_DEFAULT_OPTIONS, {});
var CONTINUOUS_DEFAULT_OPTIONS = deepAssign({}, LEGEND_BASE_DEFAULT_OPTIONS, superStyleProps(DEFAULT_HANDLE_CFG, "handle"), {
  color: [
    "#d0e3fa",
    "#acc7f6",
    "#8daaf2",
    "#6d8eea",
    "#4d73cd",
    "#325bb1",
    "#5a3e75",
    "#8c3c79",
    "#e23455",
    "#e7655b"
  ],
  indicatorBackgroundFill: "#262626",
  indicatorLabelFill: "white",
  indicatorLabelFontSize: 12,
  indicatorVisibility: "hidden",
  labelAlign: "value",
  labelDirection: "positive",
  labelSpacing: 5,
  showHandle: true,
  showIndicator: true,
  showLabel: true,
  slidable: true,
  titleText: "",
  type: "continuous"
});
var STEP_RATIO = 0.01;
var CLASS_NAMES4 = classNames({
  title: "title",
  html: "html",
  titleGroup: "title-group",
  items: "items",
  itemsGroup: "items-group",
  contentGroup: "content-group",
  ribbonGroup: "ribbon-group",
  ribbon: "ribbon",
  handlesGroup: "handles-group",
  handle: "handle",
  startHandle: "start-handle",
  endHandle: "end-handle",
  labelGroup: "label-group",
  label: "label",
  indicator: "indicator"
}, "legend");

// node_modules/@antv/component/esm/ui/legend/title/index.js
var CLASS_NAMES5 = classNames({
  text: "text"
}, "title");
function getBBox(title, content) {
  var _a2 = title.attributes, position = _a2.position, spacing = _a2.spacing, inset = _a2.inset, text = _a2.text;
  var titleBBox = title.getBBox();
  var contentBBox = content.getBBox();
  var pos = parsePosition(position);
  var _b = __read(parseSeriesAttr(text ? spacing : 0), 4), spacingTop = _b[0], spacingRight = _b[1], spacingBottom = _b[2], spacingLeft = _b[3];
  var _c = __read(parseSeriesAttr(inset), 4), insetTop = _c[0], insetRight = _c[1], insetBottom = _c[2], insetLeft = _c[3];
  var _d = __read([spacingLeft + spacingRight, spacingTop + spacingBottom], 2), spacingWidth = _d[0], spacingHeight = _d[1];
  var _e = __read([insetLeft + insetRight, insetTop + insetBottom], 2), insetWidth = _e[0], insetHeight = _e[1];
  if (pos[0] === "l") {
    return new BBox(titleBBox.x, titleBBox.y, contentBBox.width + titleBBox.width + spacingWidth + insetWidth, Math.max(contentBBox.height + insetHeight, titleBBox.height));
  }
  if (pos[0] === "t") {
    return new BBox(titleBBox.x, titleBBox.y, Math.max(contentBBox.width + insetWidth, titleBBox.width), contentBBox.height + titleBBox.height + spacingHeight + insetHeight);
  }
  var _f = __read([
    content.attributes.width || contentBBox.width,
    content.attributes.height || contentBBox.height
  ], 2), contentWidth = _f[0], contentHeight = _f[1];
  return new BBox(contentBBox.x, contentBBox.y, contentWidth + titleBBox.width + spacingWidth + insetWidth, contentHeight + titleBBox.height + spacingHeight + insetHeight);
}
function mayApplyStyle(el, style) {
  var finalStyle = Object.entries(style).reduce(function(acc, _a2) {
    var _b = __read(_a2, 2), key = _b[0], value = _b[1];
    var currAttr = el.node().attr(key);
    if (!currAttr)
      acc[key] = value;
    return acc;
  }, {});
  el.styles(finalStyle);
}
function getTitleLayout(cfg) {
  var _a2, _b, _c, _d;
  var _e = cfg, width = _e.width, height = _e.height, position = _e.position;
  var _f = __read([+width / 2, +height / 2], 2), hW = _f[0], hH = _f[1];
  var _g = __read([+hW, +hH, "center", "middle"], 4), x3 = _g[0], y3 = _g[1], textAlign = _g[2], textBaseline = _g[3];
  var pos = parsePosition(position);
  if (pos.includes("l"))
    _a2 = __read([0, "start"], 2), x3 = _a2[0], textAlign = _a2[1];
  if (pos.includes("r"))
    _b = __read([+width, "end"], 2), x3 = _b[0], textAlign = _b[1];
  if (pos.includes("t"))
    _c = __read([0, "top"], 2), y3 = _c[0], textBaseline = _c[1];
  if (pos.includes("b"))
    _d = __read([+height, "bottom"], 2), y3 = _d[0], textBaseline = _d[1];
  return { x: x3, y: y3, textAlign, textBaseline };
}
var Title = (
  /** @class */
  function(_super) {
    __extends(Title2, _super);
    function Title2(options) {
      return _super.call(this, options, {
        text: "",
        width: 0,
        height: 0,
        fill: "#4a505a",
        fontWeight: "bold",
        fontSize: 12,
        fontFamily: "sans-serif",
        inset: 0,
        spacing: 0,
        position: "top-left"
      }) || this;
    }
    Title2.prototype.getAvailableSpace = function() {
      var container = this;
      var _a2 = this.attributes, containerWidth = _a2.width, containerHeight = _a2.height, position = _a2.position, spacing = _a2.spacing, inset = _a2.inset;
      var title = container.querySelector(CLASS_NAMES5.text.class);
      if (!title)
        return new BBox(0, 0, +containerWidth, +containerHeight);
      var _b = title.getBBox(), titleWidth = _b.width, titleHeight = _b.height;
      var _c = __read(parseSeriesAttr(spacing), 4), spacingTop = _c[0], spacingRight = _c[1], spacingBottom = _c[2], spacingLeft = _c[3];
      var _d = __read([0, 0, +containerWidth, +containerHeight], 4), x3 = _d[0], y3 = _d[1], width = _d[2], height = _d[3];
      var pos = parsePosition(position);
      if (pos.includes("i"))
        return new BBox(x3, y3, width, height);
      pos.forEach(function(p, i) {
        var _a3, _b2, _c2, _d2;
        if (p === "t")
          _a3 = __read(i === 0 ? [titleHeight + spacingBottom, +containerHeight - titleHeight - spacingBottom] : [0, +containerHeight], 2), y3 = _a3[0], height = _a3[1];
        if (p === "r")
          _b2 = __read([+containerWidth - titleWidth - spacingLeft], 1), width = _b2[0];
        if (p === "b")
          _c2 = __read([+containerHeight - titleHeight - spacingTop], 1), height = _c2[0];
        if (p === "l")
          _d2 = __read(i === 0 ? [titleWidth + spacingRight, +containerWidth - titleWidth - spacingRight] : [0, +containerWidth], 2), x3 = _d2[0], width = _d2[1];
      });
      var _e = __read(parseSeriesAttr(inset), 4), insetTop = _e[0], insetRight = _e[1], insetBottom = _e[2], insetLeft = _e[3];
      var _f = __read([insetLeft + insetRight, insetTop + insetBottom], 2), insetWidth = _f[0], insetHeight = _f[1];
      return new BBox(x3 + insetLeft, y3 + insetTop, width - insetWidth, height - insetHeight);
    };
    Title2.prototype.getBBox = function() {
      if (this.title)
        return this.title.getBBox();
      return new BBox(0, 0, 0, 0);
    };
    Title2.prototype.render = function(attributes, container) {
      var _this2 = this;
      var width = attributes.width, height = attributes.height, position = attributes.position, spacing = attributes.spacing, classNamePrefix = attributes.classNamePrefix, restStyle = __rest(attributes, ["width", "height", "position", "spacing", "classNamePrefix"]);
      var _a2 = __read(splitStyle(restStyle), 1), titleStyle = _a2[0];
      var _b = getTitleLayout(attributes), x3 = _b.x, y3 = _b.y, textAlign = _b.textAlign, textBaseline = _b.textBaseline;
      ifShow(!!restStyle.text, select(container), function(group2) {
        var titleClassName = getLegendClassName(CLASS_NAMES5.text.name, CLASSNAME_SUFFIX_MAP2.title, classNamePrefix);
        _this2.title = group2.maybeAppendByClassName(CLASS_NAMES5.text, "text").attr("className", titleClassName).styles(titleStyle).call(mayApplyStyle, { x: x3, y: y3, textAlign, textBaseline }).node();
      });
    };
    return Title2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/navigator/index.js
var CLASS_NAMES6 = classNames({
  prevBtnGroup: "prev-btn-group",
  prevBtn: "prev-btn",
  nextBtnGroup: "next-btn-group",
  nextBtn: "next-btn",
  pageInfoGroup: "page-info-group",
  pageInfo: "page-info",
  playWindow: "play-window",
  contentGroup: "content-group",
  controller: "controller",
  clipPath: "clip-path"
}, "navigator");
var Navigator = (
  /** @class */
  function(_super) {
    __extends(Navigator2, _super);
    function Navigator2(options) {
      var _this2 = _super.call(this, options, {
        x: 0,
        y: 0,
        animate: {
          easing: "linear",
          duration: 200,
          fill: "both"
        },
        buttonCursor: "pointer",
        buttonFill: "black",
        buttonD: button(0, 0, 6),
        buttonSize: 12,
        controllerPadding: 5,
        controllerSpacing: 5,
        formatter: function(curr, total) {
          return "".concat(curr, "/").concat(total);
        },
        defaultPage: 0,
        loop: false,
        orientation: "horizontal",
        pageNumFill: "black",
        pageNumFontSize: 12,
        pageNumTextAlign: "start",
        pageNumTextBaseline: "middle"
      }) || this;
      _this2.playState = "idle";
      _this2.contentGroup = _this2.appendChild(new Group({ class: CLASS_NAMES6.contentGroup.name }));
      _this2.playWindow = _this2.contentGroup.appendChild(new Group({ class: CLASS_NAMES6.playWindow.name }));
      _this2.innerCurrPage = _this2.defaultPage;
      return _this2;
    }
    Object.defineProperty(Navigator2.prototype, "defaultPage", {
      get: function() {
        var defaultPage = this.attributes.defaultPage;
        return clamp_default(defaultPage, 0, Math.max(this.pageViews.length - 1, 0));
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Navigator2.prototype, "pageViews", {
      get: function() {
        return this.playWindow.children;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Navigator2.prototype, "controllerShape", {
      // todo fixme
      get: function() {
        return this.totalPages > 1 ? { width: 55, height: 0 } : { width: 0, height: 0 };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Navigator2.prototype, "pageShape", {
      get: function() {
        var pageViews = this.pageViews;
        var _a2 = __read(transpose3(pageViews.map(function(pageView) {
          var _a3 = pageView.getBBox(), width = _a3.width, height = _a3.height;
          return [width, height];
        })).map(function(arr) {
          return Math.max.apply(Math, __spreadArray([], __read(arr), false));
        }), 2), maxWidth = _a2[0], maxHeight = _a2[1];
        var _b = this.attributes, _c = _b.pageWidth, pageWidth = _c === void 0 ? maxWidth : _c, _d = _b.pageHeight, pageHeight = _d === void 0 ? maxHeight : _d;
        return { pageWidth, pageHeight };
      },
      enumerable: false,
      configurable: true
    });
    Navigator2.prototype.getContainer = function() {
      return this.playWindow;
    };
    Object.defineProperty(Navigator2.prototype, "totalPages", {
      get: function() {
        return this.pageViews.length;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Navigator2.prototype, "currPage", {
      get: function() {
        return this.innerCurrPage;
      },
      enumerable: false,
      configurable: true
    });
    Navigator2.prototype.getBBox = function() {
      var _a2 = _super.prototype.getBBox.call(this), x3 = _a2.x, y3 = _a2.y;
      var controllerShape = this.controllerShape;
      var _b = this.pageShape, pageWidth = _b.pageWidth, pageHeight = _b.pageHeight;
      return new BBox(x3, y3, pageWidth + controllerShape.width, pageHeight);
    };
    Navigator2.prototype.goTo = function(pageNum) {
      var _this2 = this;
      var animateOptions = this.attributes.animate;
      var _a2 = this, currPage = _a2.currPage, playState = _a2.playState, playWindow = _a2.playWindow, pageViews = _a2.pageViews;
      if (playState !== "idle" || pageNum < 0 || pageViews.length <= 0 || pageNum >= pageViews.length)
        return null;
      pageViews[currPage].setLocalPosition(0, 0);
      this.prepareFollowingPage(pageNum);
      var _b = __read(this.getFollowingPageDiff(pageNum), 2), dx = _b[0], dy = _b[1];
      this.playState = "running";
      var animation = animate(playWindow, [{ transform: "translate(0, 0)" }, { transform: "translate(".concat(-dx, ", ").concat(-dy, ")") }], animateOptions);
      onAnimateFinished(animation, function() {
        _this2.innerCurrPage = pageNum;
        _this2.playState = "idle";
        _this2.setVisiblePages([pageNum]);
        _this2.updatePageInfo();
      });
      return animation;
    };
    Navigator2.prototype.prev = function() {
      var loop = this.attributes.loop;
      var pages = this.pageViews.length;
      var page = this.currPage;
      if (!loop && page <= 0)
        return null;
      var following = loop ? (page - 1 + pages) % pages : clamp_default(page - 1, 0, pages);
      return this.goTo(following);
    };
    Navigator2.prototype.next = function() {
      var loop = this.attributes.loop;
      var pages = this.pageViews.length;
      var page = this.currPage;
      if (!loop && page >= pages - 1)
        return null;
      var following = loop ? (page + 1) % pages : clamp_default(page + 1, 0, pages);
      return this.goTo(following);
    };
    Navigator2.prototype.renderClipPath = function(container) {
      var _a2 = this.pageShape, pageWidth = _a2.pageWidth, pageHeight = _a2.pageHeight;
      if (!pageWidth || !pageHeight) {
        this.contentGroup.style.clipPath = void 0;
        return;
      }
      this.clipPath = container.maybeAppendByClassName(CLASS_NAMES6.clipPath, "rect").styles({
        width: pageWidth,
        height: pageHeight
      });
      this.contentGroup.attr("clipPath", this.clipPath.node());
    };
    Navigator2.prototype.setVisiblePages = function(pages) {
      this.playWindow.children.forEach(function(page, index2) {
        if (pages.includes(index2))
          show(page);
        else
          hide(page);
      });
    };
    Navigator2.prototype.adjustControllerLayout = function() {
      var _a2 = this, prevBtn = _a2.prevBtnGroup, nextBtn = _a2.nextBtnGroup, pageNum = _a2.pageInfoGroup;
      var _b = this.attributes, orientation = _b.orientation, padding = _b.controllerPadding;
      var _c = pageNum.getBBox(), pW = _c.width, pH = _c.height;
      var _d = __read(orientation === "horizontal" ? [-180, 0] : [-90, 90], 2), r1 = _d[0], r2 = _d[1];
      prevBtn.setLocalEulerAngles(r1);
      nextBtn.setLocalEulerAngles(r2);
      var _e = prevBtn.getBBox(), bpW = _e.width, bpH = _e.height;
      var _f = nextBtn.getBBox(), bnW = _f.width, bnH = _f.height;
      var maxWidth = Math.max(bpW, pW, bnW);
      var _g = orientation === "horizontal" ? {
        offset: [
          [0, 0],
          [bpW / 2 + padding, 0],
          [bpW + pW + padding * 2, 0]
        ],
        textAlign: "start"
      } : {
        offset: [
          [maxWidth / 2, -bpH - padding],
          [maxWidth / 2, 0],
          [maxWidth / 2, bnH + padding]
        ],
        textAlign: "center"
      }, _h = __read(_g.offset, 3), _j = __read(_h[0], 2), o1x = _j[0], o1y = _j[1], _k = __read(_h[1], 2), o2x = _k[0], o2y = _k[1], _l = __read(_h[2], 2), o3x = _l[0], o3y = _l[1], textAlign = _g.textAlign;
      var pageNumText = pageNum.querySelector("text");
      pageNumText && (pageNumText.style.textAlign = textAlign);
      prevBtn.setLocalPosition(o1x, o1y);
      pageNum.setLocalPosition(o2x, o2y);
      nextBtn.setLocalPosition(o3x, o3y);
    };
    Navigator2.prototype.updatePageInfo = function() {
      var _a2;
      var _b = this, currPage = _b.currPage, pageViews = _b.pageViews, formatter2 = _b.attributes.formatter;
      if (pageViews.length < 2)
        return;
      (_a2 = this.pageInfoGroup.querySelector(CLASS_NAMES6.pageInfo.class)) === null || _a2 === void 0 ? void 0 : _a2.attr("text", formatter2(currPage + 1, pageViews.length));
      this.adjustControllerLayout();
    };
    Navigator2.prototype.getFollowingPageDiff = function(pageNum) {
      var currPage = this.currPage;
      if (currPage === pageNum)
        return [0, 0];
      var orientation = this.attributes.orientation;
      var _a2 = this.pageShape, pageWidth = _a2.pageWidth, pageHeight = _a2.pageHeight;
      var sign = pageNum < currPage ? -1 : 1;
      return orientation === "horizontal" ? [sign * pageWidth, 0] : [0, sign * pageHeight];
    };
    Navigator2.prototype.prepareFollowingPage = function(pageNum) {
      var _a2 = this, currPage = _a2.currPage, pageViews = _a2.pageViews;
      this.setVisiblePages([pageNum, currPage]);
      if (pageNum !== currPage) {
        var _b = __read(this.getFollowingPageDiff(pageNum), 2), dx = _b[0], dy = _b[1];
        pageViews[pageNum].setLocalPosition(dx, dy);
      }
    };
    Navigator2.prototype.renderController = function(container) {
      var _this2 = this;
      var _a2 = this.attributes, spacing = _a2.controllerSpacing, _b = _a2.classNamePrefix, classNamePrefix = _b === void 0 ? "" : _b;
      var _c = this.pageShape, pageWidth = _c.pageWidth, pageHeight = _c.pageHeight;
      var visible = this.pageViews.length >= 2;
      var group2 = container.maybeAppendByClassName(CLASS_NAMES6.controller, "g");
      visibility(group2.node(), visible);
      if (!visible)
        return;
      var style = subStyleProps(this.attributes, "button");
      var textStyle = subStyleProps(this.attributes, "pageNum");
      var _d = __read(splitStyle(style), 2), _e = _d[0], groupStyle = _d[1], size2 = _e.size, pathStyle = __rest(_e, ["size"]);
      var whetherToAddEventListener = !group2.select(CLASS_NAMES6.prevBtnGroup.class).node();
      var prevBtnGroup = group2.maybeAppendByClassName(CLASS_NAMES6.prevBtnGroup, "g").styles(groupStyle);
      this.prevBtnGroup = prevBtnGroup.node();
      var prevBtn = prevBtnGroup.maybeAppendByClassName(CLASS_NAMES6.prevBtn, "path");
      if (classNamePrefix) {
        var prevBtnClassName = getLegendClassName(CLASS_NAMES6.prevBtn.name, CLASSNAME_SUFFIX_MAP2.prevBtn, classNamePrefix);
        prevBtn.node().setAttribute("class", prevBtnClassName);
      }
      var nextBtnGroup = group2.maybeAppendByClassName(CLASS_NAMES6.nextBtnGroup, "g").styles(groupStyle);
      this.nextBtnGroup = nextBtnGroup.node();
      var nextBtn = nextBtnGroup.maybeAppendByClassName(CLASS_NAMES6.nextBtn, "path");
      if (classNamePrefix) {
        var nextBtnClassName = getLegendClassName(CLASS_NAMES6.nextBtn.name, CLASSNAME_SUFFIX_MAP2.nextBtn, classNamePrefix);
        nextBtn.node().setAttribute("class", nextBtnClassName);
      }
      [prevBtn, nextBtn].forEach(function(btn) {
        btn.styles(__assign(__assign({}, pathStyle), { transformOrigin: "center" }));
        scaleToPixel(btn.node(), size2, true);
      });
      var pageInfoGroup = group2.maybeAppendByClassName(CLASS_NAMES6.pageInfoGroup, "g");
      this.pageInfoGroup = pageInfoGroup.node();
      var pageInfoElement = pageInfoGroup.maybeAppendByClassName(CLASS_NAMES6.pageInfo, "text");
      pageInfoElement.styles(textStyle);
      if (classNamePrefix) {
        var pageInfoClassName = getLegendClassName(CLASS_NAMES6.pageInfo.name, CLASSNAME_SUFFIX_MAP2.pageInfo, classNamePrefix);
        pageInfoElement.node().setAttribute("class", pageInfoClassName);
      }
      this.updatePageInfo();
      group2.node().setLocalPosition(pageWidth + spacing, pageHeight / 2);
      if (whetherToAddEventListener) {
        this.prevBtnGroup.addEventListener("click", function() {
          _this2.prev();
        });
        this.nextBtnGroup.addEventListener("click", function() {
          _this2.next();
        });
      }
    };
    Navigator2.prototype.render = function(attributes, container) {
      var _a2 = attributes.x, x3 = _a2 === void 0 ? 0 : _a2, _b = attributes.y, y3 = _b === void 0 ? 0 : _b;
      this.attr("transform", "translate(".concat(x3, ", ").concat(y3, ")"));
      var containerSelection = select(container);
      this.renderClipPath(containerSelection);
      this.renderController(containerSelection);
      this.setVisiblePages([this.defaultPage]);
      this.goTo(this.defaultPage);
    };
    Navigator2.prototype.bindEvents = function() {
      var _this2 = this;
      var render = debounce_default(function() {
        return _this2.render(_this2.attributes, _this2);
      }, 50);
      this.playWindow.addEventListener(ElementEvent.INSERTED, render);
      this.playWindow.addEventListener(ElementEvent.REMOVED, render);
    };
    return Navigator2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/poptip/constant.js
var _a;
var POPTIP_ID = "component-poptip";
var CLASS_NAME = {
  CONTAINER: "component-poptip",
  ARROW: "component-poptip-arrow",
  TEXT: "component-poptip-text"
};
var POPTIP_STYLE = (_a = {}, // 容器 默认 style
_a[".".concat(CLASS_NAME.CONTAINER)] = {
  visibility: "visible",
  position: "absolute",
  "background-color": "rgba(0, 0, 0)",
  "box-shadow": "0px 0px 10px #aeaeae",
  "border-radius": "3px",
  color: "#fff",
  opacity: 0.8,
  "font-size": "12px",
  padding: "4px 6px",
  display: "flex",
  "justify-content": "center",
  "align-items": "center",
  "z-index": 8,
  transition: "visibility 50ms"
}, // 文本内容 默认 style
_a[".".concat(CLASS_NAME.TEXT)] = {
  "text-align": "center"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top']")] = {
  transform: "translate(-50%, -100%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left']")] = {
  transform: "translate(-100%, -50%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right']")] = {
  transform: "translate(0, -50%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom']")] = {
  transform: "translate(-50%, 0)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top-left']")] = {
  transform: "translate(0,-100%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top-right']")] = {
  transform: "translate(-100%,-100%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left-top']")] = {
  transform: "translate(-100%, 0)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left-bottom']")] = {
  transform: "translate(-100%, -100%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right-top']")] = {
  transform: "translate(0, 0)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right-bottom']")] = {
  transform: "translate(0, -100%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom-left']")] = {
  transform: "translate(0, 0)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom-right']")] = {
  transform: "translate(-100%, 0)"
}, _a[".".concat(CLASS_NAME.ARROW)] = {
  width: "4px",
  height: "4px",
  transform: "rotate(45deg)",
  "background-color": "rgba(0, 0, 0)",
  position: "absolute",
  "z-index": -1
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top']")] = {
  transform: "translate(-50%, calc(-100% - 5px))"
}, _a["[data-position='top'] .".concat(CLASS_NAME.ARROW)] = {
  bottom: "-2px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left']")] = {
  transform: "translate(calc(-100% - 5px), -50%)"
}, _a["[data-position='left'] .".concat(CLASS_NAME.ARROW)] = {
  right: "-2px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right']")] = {
  transform: "translate(5px, -50%)"
}, _a["[data-position='right'] .".concat(CLASS_NAME.ARROW)] = {
  left: "-2px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom']")] = {
  transform: "translate(-50%, 5px)"
}, _a["[data-position='bottom'] .".concat(CLASS_NAME.ARROW)] = {
  top: "-2px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top-left']")] = {
  transform: "translate(0, calc(-100% - 5px))"
}, _a["[data-position='top-left'] .".concat(CLASS_NAME.ARROW)] = {
  left: "10px",
  bottom: "-2px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top-right']")] = {
  transform: "translate(-100%, calc(-100% - 5px))"
}, _a["[data-position='top-right'] .".concat(CLASS_NAME.ARROW)] = {
  right: "10px",
  bottom: "-2px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left-top']")] = {
  transform: "translate(calc(-100% - 5px), 0)"
}, _a["[data-position='left-top'] .".concat(CLASS_NAME.ARROW)] = {
  right: "-2px",
  top: "8px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left-bottom']")] = {
  transform: "translate(calc(-100% - 5px), -100%)"
}, _a["[data-position='left-bottom'] .".concat(CLASS_NAME.ARROW)] = {
  right: "-2px",
  bottom: "8px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right-top']")] = {
  transform: "translate(5px, 0)"
}, _a["[data-position='right-top'] .".concat(CLASS_NAME.ARROW)] = {
  left: "-2px",
  top: "8px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right-bottom']")] = {
  transform: "translate(5px, -100%)"
}, _a["[data-position='right-bottom'] .".concat(CLASS_NAME.ARROW)] = {
  left: "-2px",
  bottom: "8px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom-left']")] = {
  transform: "translate(0, 5px)"
}, _a["[data-position='bottom-left'] .".concat(CLASS_NAME.ARROW)] = {
  top: "-2px",
  left: "8px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom-right']")] = {
  transform: "translate(-100%, 5px)"
}, _a["[data-position='bottom-right'] .".concat(CLASS_NAME.ARROW)] = {
  top: "-2px",
  right: "8px"
}, _a);

// node_modules/@antv/component/esm/ui/poptip/utils.js
var _this = void 0;
function getPositionXY(clientX, clientY, target, position, arrowPointAtCenter, follow) {
  if (arrowPointAtCenter === void 0) {
    arrowPointAtCenter = false;
  }
  if (follow === void 0) {
    follow = false;
  }
  if (follow)
    return [clientX, clientY];
  var _a2 = target.getBoundingClientRect(), x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
  switch (position) {
    case "top":
      return arrowPointAtCenter ? [x3 + width / 2, y3] : [clientX, y3];
    case "left":
      return arrowPointAtCenter ? [x3, y3 + height / 2] : [x3, clientY];
    case "bottom":
      return arrowPointAtCenter ? [x3 + width / 2, y3 + height] : [clientX, y3 + height];
    case "right":
      return arrowPointAtCenter ? [x3 + width, y3 + height / 2] : [x3 + width, clientY];
    case "top-right":
    case "right-top":
      return [x3 + width, y3];
    case "left-bottom":
    case "bottom-left":
      return [x3, y3 + height];
    case "right-bottom":
    case "bottom-right":
      return [x3 + width, y3 + height];
    case "top-left":
    case "left-top":
    default:
      return [x3, y3];
  }
}
var getSingleTon = function(fn) {
  var instance;
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!instance)
      instance = fn.apply(_this, args);
    return instance;
  };
};
function createElement(id3) {
  var div4 = id3 && document.getElementById(id3);
  if (!div4) {
    div4 = document.createElement("div");
    div4.setAttribute("id", id3);
    document.body.appendChild(div4);
  }
  return div4;
}
function getSingleTonElement(id3) {
  var element = getSingleTon(createElement)(id3);
  return element;
}

// node_modules/@antv/component/esm/ui/poptip/index.js
var Poptip = (
  /** @class */
  function(_super) {
    __extends(Poptip2, _super);
    function Poptip2(options) {
      var _this2 = _super.call(this, deep_mix_default({ style: { id: POPTIP_ID } }, Poptip2.defaultOptions, options)) || this;
      _this2.visibility = "visible";
      _this2.map = /* @__PURE__ */ new Map();
      _this2.domStyles = "";
      _this2.initShape();
      _this2.render(_this2.attributes, _this2);
      return _this2;
    }
    Object.defineProperty(Poptip2.prototype, "visible", {
      get: function() {
        return this.visibility === "visible";
      },
      enumerable: false,
      configurable: true
    });
    Poptip2.prototype.render = function(attributes, container) {
      this.visibility = this.style.visibility;
      this.updatePoptipElement();
    };
    Poptip2.prototype.update = function(cfg) {
      this.attr(deep_mix_default({}, this.style, cfg));
      this.render(this.attributes, this);
    };
    Poptip2.prototype.bind = function(element, callback) {
      var _this2 = this;
      if (!element)
        return;
      var defaultText = this.style.text;
      var onmousemove = function(e) {
        var target = element;
        var options = _this2.style;
        var text = defaultText;
        if (callback) {
          var _a2 = typeof callback === "function" ? callback.call(null, e) : callback, html = _a2.html, ele = _a2.target, restOptions = __rest(_a2, ["html", "target"]);
          options = mix({}, _this2.style, restOptions);
          if (ele || ele === false)
            target = ele;
          if (typeof html === "string")
            text = html;
        }
        var position = options.position, arrowPointAtCenter = options.arrowPointAtCenter, follow = options.follow, offset = options.offset;
        if (target) {
          var _b = e, clientX = _b.clientX, clientY = _b.clientY;
          var _c = __read(getPositionXY(clientX, clientY, target, position, arrowPointAtCenter, follow), 2), x3 = _c[0], y3 = _c[1];
          _this2.showTip(x3, y3, { text, position, offset });
        } else {
          _this2.hideTip();
        }
      };
      var onmouseleave = function() {
        _this2.hideTip();
      };
      element.addEventListener("mousemove", onmousemove);
      element.addEventListener("mouseleave", onmouseleave);
      this.map.set(element, [onmousemove, onmouseleave]);
    };
    Poptip2.prototype.unbind = function(element) {
      if (this.map.has(element)) {
        var _a2 = __read(this.map.get(element) || [], 2), listener1 = _a2[0], listener2 = _a2[1];
        listener1 && element.removeEventListener("mousemove", listener1);
        listener2 && element.removeEventListener("mouseleave", listener2);
        this.map.delete(element);
      }
    };
    Poptip2.prototype.clear = function() {
      this.container.innerHTML = "";
    };
    Poptip2.prototype.destroy = function() {
      var _this2 = this;
      var _a2;
      __spreadArray([], __read(this.map.keys()), false).forEach(function(ele) {
        return _this2.unbind(ele);
      });
      (_a2 = this.container) === null || _a2 === void 0 ? void 0 : _a2.remove();
      _super.prototype.destroy.call(this);
    };
    Poptip2.prototype.showTip = function(x3, y3, options) {
      var text = get_default(options, "text");
      if (text && typeof text !== "string")
        return;
      this.applyStyles();
      if (x3 && y3 && options) {
        var offset = options.offset, position = options.position;
        position && this.container.setAttribute("data-position", position);
        this.setOffsetPosition(x3, y3, offset);
        if (typeof text === "string") {
          var textElement = this.container.querySelector(".".concat(CLASS_NAME.TEXT));
          if (textElement) {
            textElement.innerHTML = text;
          }
        }
        this.visibility = "visible";
        this.container.style.visibility = "visible";
      }
    };
    Poptip2.prototype.hideTip = function() {
      this.visibility = "hidden";
      this.container.style.visibility = "hidden";
    };
    Poptip2.prototype.getContainer = function() {
      return this.container;
    };
    Poptip2.prototype.getClassName = function() {
      var containerClassName = this.style.containerClassName;
      return "".concat(CLASS_NAME.CONTAINER).concat(containerClassName ? " ".concat(containerClassName) : "");
    };
    Poptip2.prototype.initShape = function() {
      var _this2 = this;
      var id3 = this.style.id;
      this.container = getSingleTonElement(id3);
      this.container.className = this.getClassName();
      this.container.addEventListener("mousemove", function() {
        return _this2.showTip();
      });
      this.container.addEventListener("mouseleave", function() {
        return _this2.hideTip();
      });
    };
    Poptip2.prototype.updatePoptipElement = function() {
      var container = this.container;
      this.clear();
      var _a2 = this.style, id3 = _a2.id, template = _a2.template, text = _a2.text;
      this.container.setAttribute("id", id3);
      this.container.className = this.getClassName();
      var arrowNode = '<span class="'.concat(CLASS_NAME.ARROW, '"></span>');
      container.innerHTML = arrowNode;
      if (isString(template)) {
        container.innerHTML += template;
      } else if (template && isElement(template)) {
        container.appendChild(template);
      }
      if (text) {
        container.getElementsByClassName(CLASS_NAME.TEXT)[0].textContent = text;
      }
      this.applyStyles();
      this.container.style.visibility = this.visibility;
    };
    Poptip2.prototype.applyStyles = function() {
      var styles = deepAssign({}, POPTIP_STYLE, this.style.domStyles);
      var styleStr = Object.entries(styles).reduce(function(r, _a2) {
        var _b = __read(_a2, 2), key = _b[0], value = _b[1];
        var styleStr2 = Object.entries(value).reduce(function(r2, _a3) {
          var _b2 = __read(_a3, 2), k = _b2[0], v = _b2[1];
          return "".concat(r2).concat(k, ": ").concat(v, ";");
        }, "");
        return "".concat(r).concat(key, "{").concat(styleStr2, "}");
      }, "");
      if (this.domStyles !== styleStr) {
        this.domStyles = styleStr;
        var styleDOM = this.container.querySelector("style");
        if (styleDOM)
          this.container.removeChild(styleDOM);
        styleDOM = document.createElement("style");
        styleDOM.innerHTML = styleStr;
        this.container.appendChild(styleDOM);
      }
    };
    Poptip2.prototype.setOffsetPosition = function(x3, y3, offset) {
      if (offset === void 0) {
        offset = this.style.offset;
      }
      var _a2 = __read(offset, 2), _b = _a2[0], offsetX = _b === void 0 ? 0 : _b, _c = _a2[1], offsetY = _c === void 0 ? 0 : _c;
      this.container.style.left = "".concat(x3 + offsetX, "px");
      this.container.style.top = "".concat(y3 + offsetY, "px");
    };
    Poptip2.tag = "poptip";
    Poptip2.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        target: null,
        visibility: "hidden",
        text: "",
        position: "top",
        follow: false,
        offset: [0, 0],
        domStyles: POPTIP_STYLE,
        template: '<div class="'.concat(CLASS_NAME.TEXT, '"></div>')
      }
    };
    return Poptip2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/category/item.js
var CLASS_NAMES7 = classNames({
  layout: "flex",
  markerGroup: "marker-group",
  marker: "marker",
  labelGroup: "label-group",
  label: "label",
  valueGroup: "value-group",
  focusGroup: "focus-group",
  focus: "focus",
  value: "value",
  backgroundGroup: "background-group",
  background: "background"
}, "legend-category-item");
var DEFAULT_POPTIP_PROPS = {
  offset: [0, 20],
  domStyles: {
    ".component-poptip": {
      opacity: "1",
      padding: "8px 12px",
      background: "#fff",
      boxShadow: "0 2px 8px rgba(0, 0, 0, 0.15)"
    },
    ".component-poptip-arrow": {
      display: "none"
    },
    ".component-poptip-text": {
      color: "#000",
      lineHeight: "20px"
    }
  }
};
function styleOfMarker(group2) {
  var marker = group2.querySelector(CLASS_NAMES7.marker.class);
  if (marker)
    return marker.style;
  return {};
}
var CategoryItem = (
  /** @class */
  function(_super) {
    __extends(CategoryItem2, _super);
    function CategoryItem2(options, keyFields) {
      var _this2 = _super.call(this, options, {
        span: [1, 1],
        marker: function() {
          return new Circle({ style: { r: 6 } });
        },
        markerSize: 10,
        labelFill: "#646464",
        valueFill: "#646464",
        labelFontSize: 12,
        valueFontSize: 12,
        labelTextBaseline: "middle",
        valueTextBaseline: "middle"
      }) || this;
      _this2.keyFields = {};
      _this2.keyFields = keyFields || {};
      return _this2;
    }
    Object.defineProperty(CategoryItem2.prototype, "showValue", {
      get: function() {
        var valueText = this.attributes.valueText;
        if (!valueText)
          return false;
        if (typeof valueText === "string" || typeof valueText === "number")
          return valueText !== "";
        if (typeof valueText === "function")
          return true;
        return valueText.attr("text") !== "";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "actualSpace", {
      get: function() {
        var label = this.labelGroup;
        var value = this.valueGroup;
        var _a2 = this.attributes, markerSize = _a2.markerSize, focus2 = _a2.focus, focusMarkerSize = _a2.focusMarkerSize;
        var _b = label.node().getBBox(), labelWidth = _b.width, labelHeight = _b.height;
        var _c = value.node().getBBox(), valueWidth = _c.width, valueHeight = _c.height;
        var focusWidth = focus2 ? focusMarkerSize !== null && focusMarkerSize !== void 0 ? focusMarkerSize : 12 : 0;
        return {
          markerWidth: markerSize,
          labelWidth,
          valueWidth,
          focusWidth,
          height: Math.max(markerSize, labelHeight, valueHeight)
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "span", {
      get: function() {
        var span = this.attributes.span;
        if (!span)
          return [1, 1];
        var _a2 = __read(parseSeriesAttr(span), 2), span1 = _a2[0], innerSpan = _a2[1];
        var span2 = this.showValue ? innerSpan : 0;
        var basis = span1 + span2;
        return [span1 / basis, span2 / basis];
      },
      enumerable: false,
      configurable: true
    });
    CategoryItem2.prototype.setAttribute = function(n, v) {
      _super.prototype.setAttribute.call(this, n, v);
    };
    Object.defineProperty(CategoryItem2.prototype, "shape", {
      get: function() {
        var _a2;
        var _b = this.attributes, markerSize = _b.markerSize, fullWidth = _b.width;
        var actualSpace = this.actualSpace;
        var markerWidth = actualSpace.markerWidth, focusWidth = actualSpace.focusWidth, height = actualSpace.height;
        var _c = this.actualSpace, labelWidth = _c.labelWidth, valueWidth = _c.valueWidth;
        var _d = __read(this.spacing, 3), spacing1 = _d[0], spacing2 = _d[1], spacing3 = _d[2];
        if (fullWidth) {
          var width_1 = fullWidth - markerSize - spacing1 - spacing2 - focusWidth - spacing3;
          var _e = __read(this.span, 2), span1 = _e[0], span2 = _e[1];
          _a2 = __read([span1 * width_1, span2 * width_1], 2), labelWidth = _a2[0], valueWidth = _a2[1];
        }
        var width = markerWidth + labelWidth + valueWidth + spacing1 + spacing2 + focusWidth + spacing3;
        return { width, height, markerWidth, labelWidth, valueWidth, focusWidth };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "spacing", {
      get: function() {
        var _a2 = this.attributes, spacing = _a2.spacing, focus2 = _a2.focus;
        if (!spacing)
          return [0, 0, 0];
        var _b = __read(parseSeriesAttr(spacing), 3), spacing1 = _b[0], spacing2 = _b[1], spacing3 = _b[2];
        return [spacing1, this.showValue ? spacing2 : 0, focus2 ? spacing3 : 0];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "layout", {
      get: function() {
        var _a2 = this.shape, markerWidth = _a2.markerWidth, labelWidth = _a2.labelWidth, valueWidth = _a2.valueWidth, focusWidth = _a2.focusWidth, width = _a2.width, height = _a2.height;
        var _b = __read(this.spacing, 3), spacing1 = _b[0], spacing2 = _b[1], spacing3 = _b[2];
        return {
          height,
          width,
          markerWidth,
          labelWidth,
          valueWidth,
          focusWidth,
          position: [
            markerWidth / 2,
            markerWidth + spacing1,
            markerWidth + labelWidth + spacing1 + spacing2,
            markerWidth + labelWidth + valueWidth + spacing1 + spacing2 + spacing3 + focusWidth / 2
          ]
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "scaleSize", {
      get: function() {
        var markerShapeStyle = styleOfMarker(this.markerGroup.node());
        var _a2 = this.attributes, markerSize = _a2.markerSize, _b = _a2.markerStrokeWidth, markerStrokeWidth = _b === void 0 ? markerShapeStyle.strokeWidth : _b, _c = _a2.markerLineWidth, markerLineWidth = _c === void 0 ? markerShapeStyle.lineWidth : _c, _d = _a2.markerStroke, markerStroke = _d === void 0 ? markerShapeStyle.stroke : _d;
        var strokeWidth = +(markerStrokeWidth || markerLineWidth || (markerStroke ? 1 : 0)) * Math.sqrt(2);
        var _e = this.markerGroup.node().getBBox(), width = _e.width, height = _e.height;
        return (1 - strokeWidth / Math.max(width, height)) * markerSize;
      },
      enumerable: false,
      configurable: true
    });
    CategoryItem2.prototype.renderMarker = function(container) {
      var _this2 = this;
      var _a2 = this.attributes, marker = _a2.marker, classNamePrefix = _a2.classNamePrefix;
      var style = subStyleProps(this.attributes, "marker");
      this.markerGroup = container.maybeAppendByClassName(CLASS_NAMES7.markerGroup, "g").style("zIndex", 0);
      ifShow(!!marker, this.markerGroup, function() {
        var _a3;
        var parent = _this2.markerGroup.node();
        var oldMarker = (_a3 = parent.childNodes) === null || _a3 === void 0 ? void 0 : _a3[0];
        var markerClassName = getLegendClassName(CLASS_NAMES7.marker.name, CLASSNAME_SUFFIX_MAP2.marker, classNamePrefix);
        var newMarker = typeof marker === "string" ? new Marker({ style: { symbol: marker }, className: markerClassName }) : marker();
        if (!oldMarker) {
          if (!(newMarker instanceof Marker)) {
            var markerClassName_1 = getLegendClassName(CLASS_NAMES7.marker.name, CLASSNAME_SUFFIX_MAP2.marker, classNamePrefix);
            newMarker.className = markerClassName_1;
            select(newMarker).styles(style);
          }
          parent.appendChild(newMarker);
        } else if (newMarker.nodeName === oldMarker.nodeName) {
          if (oldMarker instanceof Marker)
            oldMarker.update(__assign(__assign({}, style), { symbol: marker }));
          else {
            copyAttributes(oldMarker, newMarker);
            select(oldMarker).styles(style);
          }
        } else {
          oldMarker.remove();
          if (!(newMarker instanceof Marker)) {
            var markerClassName_2 = getLegendClassName(CLASS_NAMES7.marker.name, CLASSNAME_SUFFIX_MAP2.marker, classNamePrefix);
            newMarker.className = markerClassName_2;
          }
          select(newMarker).styles(style);
          parent.appendChild(newMarker);
        }
        _this2.markerGroup.node().scale(1 / _this2.markerGroup.node().getScale()[0]);
        var scale9 = scaleToPixel(_this2.markerGroup.node(), _this2.scaleSize, true);
        _this2.markerGroup.node().style._transform = "scale(".concat(scale9, ")");
      });
    };
    CategoryItem2.prototype.renderLabel = function(container) {
      var _a2 = subStyleProps(this.attributes, "label"), label = _a2.text, style = __rest(_a2, ["text"]);
      var classNamePrefix = this.attributes.classNamePrefix;
      this.labelGroup = container.maybeAppendByClassName(CLASS_NAMES7.labelGroup, "g").style("zIndex", 0);
      var labelClassName = getLegendClassName(CLASS_NAMES7.label.name, CLASSNAME_SUFFIX_MAP2.label, classNamePrefix);
      var labelElement = this.labelGroup.maybeAppendByClassName(CLASS_NAMES7.label, function() {
        return renderExtDo(label);
      });
      labelElement.node().setAttribute("class", labelClassName);
      labelElement.styles(style);
    };
    CategoryItem2.prototype.renderValue = function(container) {
      var _this2 = this;
      var _a2 = subStyleProps(this.attributes, "value"), value = _a2.text, style = __rest(_a2, ["text"]);
      var classNamePrefix = this.attributes.classNamePrefix;
      this.valueGroup = container.maybeAppendByClassName(CLASS_NAMES7.valueGroup, "g").style("zIndex", 0);
      ifShow(this.showValue, this.valueGroup, function() {
        var valueClassName = getLegendClassName(CLASS_NAMES7.value.name, CLASSNAME_SUFFIX_MAP2.value, classNamePrefix);
        var valueElement = _this2.valueGroup.maybeAppendByClassName(CLASS_NAMES7.value, function() {
          return renderExtDo(value);
        });
        valueElement.node().setAttribute("class", valueClassName);
        valueElement.styles(style);
      });
    };
    CategoryItem2.prototype.createPoptip = function() {
      var poptip = this.attributes.poptip;
      var _a2 = poptip || {}, render = _a2.render, poptipStyle = __rest(_a2, ["render"]);
      var poptipGroup = new Poptip({ style: deepAssign(DEFAULT_POPTIP_PROPS, poptipStyle) });
      this.poptipGroup = poptipGroup;
      return poptipGroup;
    };
    CategoryItem2.prototype.bindPoptip = function(node) {
      var _this2 = this;
      var poptip = this.attributes.poptip;
      if (!poptip)
        return;
      var poptipGroup = this.poptipGroup || this.createPoptip();
      poptipGroup.bind(node, function() {
        var _a2 = _this2.attributes, labelText = _a2.labelText, valueText = _a2.valueText, markerFill = _a2.markerFill;
        var label = typeof labelText === "string" ? labelText : labelText === null || labelText === void 0 ? void 0 : labelText.attr("text");
        var value = typeof valueText === "string" ? valueText : valueText === null || valueText === void 0 ? void 0 : valueText.attr("text");
        if (typeof poptip.render === "function") {
          return { html: poptip.render(__assign(__assign({}, _this2.keyFields), { label, value, color: markerFill })) };
        }
        var html = "";
        if (typeof label === "string" || typeof label === "number") {
          html += '<div class="component-poptip-label">'.concat(label, "</div>");
        }
        if (typeof value === "string" || typeof value === "number") {
          html += '<div class="component-poptip-value">'.concat(value, "</div>");
        }
        return { html };
      });
    };
    CategoryItem2.prototype.renderFocus = function(ctn) {
      var _this2 = this;
      var _a2 = this.attributes, focus2 = _a2.focus, focusMarkerSize = _a2.focusMarkerSize, classNamePrefix = _a2.classNamePrefix;
      var defaultOptions = {
        x: 0,
        y: 0,
        size: focusMarkerSize,
        opacity: 0.6,
        symbol: "focus",
        stroke: "#aaaaaa",
        lineWidth: 1
      };
      if (is_undefined_default(focus2))
        return;
      this.focusGroup = ctn.maybeAppendByClassName(CLASS_NAMES7.focusGroup, "g").style("zIndex", 0);
      ifShow(focus2, this.focusGroup, function() {
        var focusClassName = getLegendClassName(CLASS_NAMES7.focus.name, CLASSNAME_SUFFIX_MAP2.focusIcon, classNamePrefix);
        var marker = new Marker({
          style: __assign(__assign({}, defaultOptions), { symbol: "focus" }),
          className: focusClassName
        });
        var interactiveCircle = new Circle({
          style: {
            r: defaultOptions.size / 2,
            fill: "transparent"
          }
        });
        var container = _this2.focusGroup.node();
        container.appendChild(interactiveCircle);
        container.appendChild(marker);
        marker.update({ opacity: 0 });
        ctn.node().addEventListener("pointerenter", function() {
          marker.update({ opacity: 1 });
        });
        ctn.node().addEventListener("pointerleave", function() {
          marker.update({ opacity: 0 });
        });
      });
    };
    CategoryItem2.prototype.renderPoptip = function(ctn) {
      var _this2 = this;
      var poptip = this.attributes.poptip;
      if (!poptip)
        return;
      var valueNode = ctn.maybeAppendByClassName(CLASS_NAMES7.value, "g").node();
      var labelNode = ctn.maybeAppendByClassName(CLASS_NAMES7.label, "g").node();
      [valueNode, labelNode].forEach(function(node) {
        if (node) {
          _this2.bindPoptip(node);
        }
      });
    };
    CategoryItem2.prototype.renderBackground = function(container) {
      var _a2 = this.shape, width = _a2.width, height = _a2.height;
      var style = subStyleProps(this.attributes, "background");
      this.background = container.maybeAppendByClassName(CLASS_NAMES7.backgroundGroup, "g").style("zIndex", -1);
      var backgroundElement = this.background.maybeAppendByClassName(CLASS_NAMES7.background, "rect");
      backgroundElement.styles(__assign({ width, height }, style));
      var _b = this.attributes.classNamePrefix, classNamePrefix = _b === void 0 ? "" : _b;
      if (classNamePrefix) {
        var backgroundClassName = getLegendClassName(CLASS_NAMES7.background.name, CLASSNAME_SUFFIX_MAP2.background, classNamePrefix);
        backgroundElement.node().setAttribute("class", backgroundClassName);
      }
    };
    CategoryItem2.prototype.adjustLayout = function() {
      var _a2 = this.layout, labelWidth = _a2.labelWidth, valueWidth = _a2.valueWidth, height = _a2.height, _b = __read(_a2.position, 4), markerX = _b[0], labelX = _b[1], valueX = _b[2], focusX = _b[3];
      var halfHeight = height / 2;
      this.markerGroup.styles({
        transform: "translate(".concat(markerX, ", ").concat(halfHeight, ")").concat(this.markerGroup.node().style._transform)
      });
      this.labelGroup.styles({ transform: "translate(".concat(labelX, ", ").concat(halfHeight, ")") });
      if (this.focusGroup)
        this.focusGroup.styles({ transform: "translate(".concat(focusX, ", ").concat(halfHeight, ")") });
      ellipsisIt(this.labelGroup.select(CLASS_NAMES7.label.class).node(), Math.ceil(labelWidth));
      if (this.showValue) {
        this.valueGroup.styles({ transform: "translate(".concat(valueX, ", ").concat(halfHeight, ")") });
        ellipsisIt(this.valueGroup.select(CLASS_NAMES7.value.class).node(), Math.ceil(valueWidth));
      }
    };
    CategoryItem2.prototype.render = function(attributes, container) {
      var ctn = select(container);
      var _a2 = attributes.x, x3 = _a2 === void 0 ? 0 : _a2, _b = attributes.y, y3 = _b === void 0 ? 0 : _b;
      ctn.styles({ transform: "translate(".concat(x3, ", ").concat(y3, ")") });
      this.renderMarker(ctn);
      this.renderLabel(ctn);
      this.renderValue(ctn);
      this.renderBackground(ctn);
      this.renderPoptip(ctn);
      this.renderFocus(ctn);
      this.adjustLayout();
    };
    return CategoryItem2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/category/items.js
var CLASS_NAMES8 = classNames({
  page: "item-page",
  navigator: "navigator",
  item: "item"
}, "items");
var ifSatisfied = function(value, rule, defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = true;
  }
  if (value) {
    return rule(value);
  }
  return defaultValue;
};
var CategoryItems = (
  /** @class */
  function(_super) {
    __extends(CategoryItems2, _super);
    function CategoryItems2(options) {
      var _this2 = _super.call(this, options, {
        data: [],
        gridRow: Infinity,
        gridCol: void 0,
        padding: 0,
        width: 1e3,
        height: 100,
        rowPadding: 0,
        colPadding: 0,
        layout: "flex",
        orientation: "horizontal",
        click: noop_default,
        mouseenter: noop_default,
        mouseleave: noop_default
      }) || this;
      _this2.navigatorShape = [0, 0];
      return _this2;
    }
    Object.defineProperty(CategoryItems2.prototype, "pageViews", {
      get: function() {
        return this.navigator.getContainer();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItems2.prototype, "grid", {
      get: function() {
        var _a2 = this.attributes, gridRow = _a2.gridRow, gridCol = _a2.gridCol, data2 = _a2.data;
        if (!gridRow && !gridCol)
          throw new Error("gridRow and gridCol can not be set null at the same time");
        if (!!gridRow && !!gridCol)
          return [gridRow, gridCol];
        if (gridRow)
          return [gridRow, data2.length];
        return [data2.length, gridCol];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItems2.prototype, "renderData", {
      get: function() {
        var _a2 = this.attributes, data2 = _a2.data, layout = _a2.layout, poptip = _a2.poptip, focus2 = _a2.focus, focusMarkerSize = _a2.focusMarkerSize, classNamePrefix = _a2.classNamePrefix;
        var style = subStyleProps(this.attributes, "item");
        var d2 = data2.map(function(datum, index2) {
          var _a3 = datum.id, id3 = _a3 === void 0 ? index2 : _a3, labelText = datum.label, valueText = datum.value;
          return {
            id: "".concat(id3),
            index: index2,
            style: __assign({ layout, labelText, valueText, poptip, focus: focus2, focusMarkerSize, classNamePrefix }, Object.fromEntries(Object.entries(style).map(function(_a4) {
              var _b = __read(_a4, 2), key = _b[0], val = _b[1];
              return [key, getCallbackValue(val, [datum, index2, data2])];
            })))
          };
        });
        return d2;
      },
      enumerable: false,
      configurable: true
    });
    CategoryItems2.prototype.getGridLayout = function() {
      var _this2 = this;
      var _a2 = this.attributes, orientation = _a2.orientation, width = _a2.width, rowPadding = _a2.rowPadding, colPadding = _a2.colPadding;
      var _b = __read(this.navigatorShape, 1), navWidth = _b[0];
      var _c = __read(this.grid, 2), gridRow = _c[0], gridCol = _c[1];
      var pageSize = gridCol * gridRow;
      var prevOffset = 0;
      return this.pageViews.children.map(function(item, index2) {
        var _a3, _b2;
        var page = Math.floor(index2 / pageSize);
        var pageIndex = index2 % pageSize;
        var dir = _this2.ifHorizontal(gridCol, gridRow);
        var pos = [Math.floor(pageIndex / dir), pageIndex % dir];
        if (orientation === "vertical")
          pos.reverse();
        var _c2 = __read(pos, 2), row2 = _c2[0], col = _c2[1];
        var colWidth = (width - navWidth - (gridCol - 1) * colPadding) / gridCol;
        var rowHeight = item.getBBox().height;
        var _d = __read([0, 0], 2), x3 = _d[0], y3 = _d[1];
        if (orientation === "horizontal") {
          _a3 = __read([prevOffset, row2 * (rowHeight + rowPadding)], 2), x3 = _a3[0], y3 = _a3[1];
          prevOffset = col === gridCol - 1 ? 0 : prevOffset + colWidth + colPadding;
        } else {
          _b2 = __read([col * (colWidth + colPadding), prevOffset], 2), x3 = _b2[0], y3 = _b2[1];
          prevOffset = row2 === gridRow - 1 ? 0 : prevOffset + rowHeight + rowPadding;
        }
        return { page, index: index2, row: row2, col, pageIndex, width: colWidth, height: rowHeight, x: x3, y: y3 };
      });
    };
    CategoryItems2.prototype.getFlexLayout = function() {
      var _a2 = this.attributes, maxWidth = _a2.width, maxHeight = _a2.height, rowPadding = _a2.rowPadding, cP = _a2.colPadding;
      var _b = __read(this.navigatorShape, 1), navWidth = _b[0];
      var _c = __read(this.grid, 2), gridRow = _c[0], gridCol = _c[1];
      var _d = __read([maxWidth - navWidth, maxHeight], 2), limitWidth = _d[0], limitHeight = _d[1];
      var _e = __read([0, 0, 0, 0, 0, 0, 0, 0], 8), x3 = _e[0], y3 = _e[1], page = _e[2], pageIndex = _e[3], col = _e[4], row2 = _e[5], prevWidth = _e[6], prevHeight = _e[7];
      return this.pageViews.children.map(function(item, index2) {
        var _a3, _b2, _c2, _d2;
        var _e2 = item.getBBox(), width = _e2.width, height = _e2.height;
        var colPadding = prevWidth === 0 ? 0 : cP;
        var nextWidth = prevWidth + colPadding + width;
        if (nextWidth <= limitWidth && ifSatisfied(col, function(c2) {
          return c2 < gridCol;
        })) {
          _a3 = __read([prevWidth + colPadding, prevHeight, nextWidth], 3), x3 = _a3[0], y3 = _a3[1], prevWidth = _a3[2];
          return { width, height, x: x3, y: y3, page, index: index2, pageIndex: pageIndex++, row: row2, col: col++ };
        }
        _b2 = __read([row2 + 1, 0, 0, prevHeight + height + rowPadding], 4), row2 = _b2[0], col = _b2[1], prevWidth = _b2[2], prevHeight = _b2[3];
        var nextHeight = prevHeight + height;
        if (nextHeight <= limitHeight && ifSatisfied(row2, function(r) {
          return r < gridRow;
        })) {
          _c2 = __read([prevWidth, prevHeight, width], 3), x3 = _c2[0], y3 = _c2[1], prevWidth = _c2[2];
          return { width, height, x: x3, y: y3, page, index: index2, pageIndex: pageIndex++, row: row2, col: col++ };
        }
        _d2 = __read([0, 0, width, 0, page + 1, 0, 0, 0], 8), x3 = _d2[0], y3 = _d2[1], prevWidth = _d2[2], prevHeight = _d2[3], page = _d2[4], pageIndex = _d2[5], row2 = _d2[6], col = _d2[7];
        return { width, height, x: x3, y: y3, page, index: index2, pageIndex: pageIndex++, row: row2, col: col++ };
      });
    };
    Object.defineProperty(CategoryItems2.prototype, "itemsLayout", {
      get: function() {
        this.navigatorShape = [0, 0];
        var cb = this.attributes.layout === "grid" ? this.getGridLayout : this.getFlexLayout;
        var layout = cb.call(this);
        if (layout.slice(-1)[0].page > 0) {
          this.navigatorShape = [55, 0];
          return cb.call(this);
        }
        return layout;
      },
      enumerable: false,
      configurable: true
    });
    CategoryItems2.prototype.ifHorizontal = function(a2, b) {
      var orientation = this.attributes.orientation;
      return ifHorizontal(orientation, a2, b);
    };
    CategoryItems2.prototype.flattenPage = function(container) {
      container.querySelectorAll(CLASS_NAMES8.item.class).forEach(function(item) {
        container.appendChild(item);
      });
      container.querySelectorAll(CLASS_NAMES8.page.class).forEach(function(page) {
        var removedPage = container.removeChild(page);
        removedPage.destroy();
      });
    };
    CategoryItems2.prototype.renderItems = function(container) {
      var _a2 = this.attributes, click = _a2.click, mouseenter = _a2.mouseenter, mouseleave = _a2.mouseleave, classNamePrefix = _a2.classNamePrefix;
      this.flattenPage(container);
      var dispatchCustomEvent = this.dispatchCustomEvent.bind(this);
      var itemClassName = getLegendClassName(CLASS_NAMES8.item.name, CLASSNAME_SUFFIX_MAP2.item, classNamePrefix);
      select(container).selectAll(CLASS_NAMES8.item.class).data(this.renderData, function(d2) {
        return d2.id;
      }).join(function(enter) {
        return enter.append(function(_a3) {
          var style = _a3.style, rest = __rest(_a3, ["style"]);
          return new CategoryItem({ style }, rest);
        }).attr("className", itemClassName).on("click", function() {
          click === null || click === void 0 ? void 0 : click(this);
          dispatchCustomEvent("itemClick", { item: this });
        }).on("pointerenter", function() {
          mouseenter === null || mouseenter === void 0 ? void 0 : mouseenter(this);
          dispatchCustomEvent("itemMouseenter", { item: this });
        }).on("pointerleave", function() {
          mouseleave === null || mouseleave === void 0 ? void 0 : mouseleave(this);
          dispatchCustomEvent("itemMouseleave", { item: this });
        });
      }, function(update2) {
        return update2.each(function(_a3) {
          var style = _a3.style;
          this.update(style);
        });
      }, function(exit) {
        return exit.remove();
      });
    };
    CategoryItems2.prototype.relayoutNavigator = function() {
      var _a2;
      var _b = this.attributes, layout = _b.layout, width = _b.width;
      var height = ((_a2 = this.pageViews.children[0]) === null || _a2 === void 0 ? void 0 : _a2.getBBox().height) || 0;
      var _c = __read(this.navigatorShape, 2), navWidth = _c[0], navHeight = _c[1];
      this.navigator.update(layout === "grid" ? { pageWidth: width - navWidth, pageHeight: height - navHeight } : {});
    };
    CategoryItems2.prototype.adjustLayout = function() {
      var _this2 = this;
      var itemsLayouts = Object.entries(groupBy2(this.itemsLayout, "page")).map(function(_a2) {
        var _b = __read(_a2, 2), page = _b[0], layouts = _b[1];
        return {
          page,
          layouts
        };
      });
      var categoryItems = __spreadArray([], __read(this.navigator.getContainer().children), false);
      itemsLayouts.forEach(function(_a2) {
        var layouts = _a2.layouts;
        var page = _this2.pageViews.appendChild(new Group({ className: CLASS_NAMES8.page.name }));
        layouts.forEach(function(layout) {
          var x3 = layout.x, y3 = layout.y, index2 = layout.index, width = layout.width, height = layout.height;
          var item = categoryItems[index2];
          page.appendChild(item);
          set_default(item, "__layout__", layout);
          item.update({ x: x3, y: y3, width, height });
        });
      });
      this.relayoutNavigator();
    };
    CategoryItems2.prototype.renderNavigator = function(container) {
      var _a2 = this.attributes, orientation = _a2.orientation, classNamePrefix = _a2.classNamePrefix;
      var navStyle = subStyleProps(this.attributes, "nav");
      var style = deepAssign({ orientation, classNamePrefix }, navStyle);
      var that = this;
      container.selectAll(CLASS_NAMES8.navigator.class).data(["nav"]).join(function(enter) {
        return enter.append(function() {
          return new Navigator({ style });
        }).attr("className", CLASS_NAMES8.navigator.name).each(function() {
          that.navigator = this;
        });
      }, function(update2) {
        return update2.each(function() {
          this.update(style);
        });
      }, function(exit) {
        return exit.remove();
      });
      return this.navigator;
    };
    CategoryItems2.prototype.getBBox = function() {
      return this.navigator.getBBox();
    };
    CategoryItems2.prototype.render = function(attributes, container) {
      var data2 = this.attributes.data;
      if (!data2 || data2.length === 0)
        return;
      var navigator = this.renderNavigator(select(container));
      this.renderItems(navigator.getContainer());
      this.adjustLayout();
    };
    CategoryItems2.prototype.dispatchCustomEvent = function(type, payload) {
      var evt = new CustomEvent(type, {
        detail: payload
      });
      this.dispatchEvent(evt);
    };
    return CategoryItems2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/category.js
var HtmlLegend = (
  /** @class */
  function(_super) {
    __extends(HtmlLegend2, _super);
    function HtmlLegend2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HtmlLegend2.prototype.update = function(options) {
      this.attr(options);
    };
    return HtmlLegend2;
  }(HTML)
);
var Category = (
  /** @class */
  function(_super) {
    __extends(Category2, _super);
    function Category2(options) {
      return _super.call(this, options, CATEGORY_DEFAULT_OPTIONS) || this;
    }
    Category2.prototype.renderTitle = function(container, width, height) {
      var _a2 = this.attributes, showTitle = _a2.showTitle, titleText = _a2.titleText, classNamePrefix = _a2.classNamePrefix;
      var style = subStyleProps(this.attributes, "title");
      var _b = __read(splitStyle(style), 2), titleStyle = _b[0], groupStyle = _b[1];
      this.titleGroup = container.maybeAppendByClassName(CLASS_NAMES4.titleGroup, "g").styles(groupStyle);
      var finalTitleStyle = __assign(__assign({ width, height }, titleStyle), { text: showTitle ? titleText : "", classNamePrefix });
      this.title = this.titleGroup.maybeAppendByClassName(CLASS_NAMES4.title, function() {
        return new Title({ style: finalTitleStyle });
      }).update(finalTitleStyle);
    };
    Category2.prototype.renderCustom = function(container) {
      var data2 = this.attributes.data;
      var style = {
        innerHTML: this.attributes.render(data2),
        pointerEvents: "auto"
      };
      container.maybeAppendByClassName(CLASS_NAMES4.html, function() {
        return new HtmlLegend({
          className: CLASS_NAMES4.html.name,
          style
        });
      }).update(style);
    };
    Category2.prototype.renderItems = function(container, bbox) {
      var x3 = bbox.x, y3 = bbox.y, width = bbox.width, height = bbox.height;
      var style = subStyleProps(this.attributes, "title", true);
      var _a2 = __read(splitStyle(style), 2), partialItemStyle = _a2[0], groupStyle = _a2[1];
      var itemStyle = __assign(__assign({}, partialItemStyle), { width, height, x: 0, y: 0 });
      this.itemsGroup = container.maybeAppendByClassName(CLASS_NAMES4.itemsGroup, "g").styles(__assign(__assign({}, groupStyle), { transform: "translate(".concat(x3, ", ").concat(y3, ")") }));
      var that = this;
      this.itemsGroup.selectAll(CLASS_NAMES4.items.class).data(["items"]).join(function(enter) {
        return enter.append(function() {
          return new CategoryItems({ style: itemStyle });
        }).attr("className", CLASS_NAMES4.items.name).each(function() {
          that.items = select(this);
        });
      }, function(update2) {
        return update2.update(itemStyle);
      }, function(exit) {
        return exit.remove();
      });
    };
    Category2.prototype.adjustLayout = function() {
      var showTitle = this.attributes.showTitle;
      if (showTitle) {
        var _a2 = this.title.node().getAvailableSpace(), x3 = _a2.x, y3 = _a2.y;
        this.itemsGroup.node().style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
      }
    };
    Object.defineProperty(Category2.prototype, "availableSpace", {
      get: function() {
        var _a2 = this.attributes, showTitle = _a2.showTitle, width = _a2.width, height = _a2.height;
        if (!showTitle)
          return new BBox(0, 0, width, height);
        return this.title.node().getAvailableSpace();
      },
      enumerable: false,
      configurable: true
    });
    Category2.prototype.getBBox = function() {
      var _a2, _b;
      var title = (_a2 = this.title) === null || _a2 === void 0 ? void 0 : _a2.node();
      var items = (_b = this.items) === null || _b === void 0 ? void 0 : _b.node();
      if (!title || !items)
        return _super.prototype.getBBox.call(this);
      return getBBox(title, items);
    };
    Category2.prototype.render = function(attributes, container) {
      var _a2 = this.attributes, width = _a2.width, height = _a2.height, _b = _a2.x, x3 = _b === void 0 ? 0 : _b, _c = _a2.y, y3 = _c === void 0 ? 0 : _c, classNamePrefix = _a2.classNamePrefix, render = _a2.render;
      var ctn = select(container);
      var baseClassName = container.className || "legend-category";
      if (classNamePrefix) {
        container.attr("className", "".concat(baseClassName, " ").concat(classNamePrefix, "legend"));
      } else if (!container.className) {
        container.attr("className", "legend-category");
      }
      container.style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
      if (render) {
        this.renderCustom(ctn);
      } else {
        this.renderTitle(ctn, width, height);
        this.renderItems(ctn, this.availableSpace);
        this.adjustLayout();
      }
    };
    return Category2;
  }(Component)
);

// node_modules/@antv/component/node_modules/@antv/scale/esm/utils/compose.js
function compose(fn, ...rest) {
  return rest.reduce((pre, cur) => (x3) => pre(cur(x3)), fn);
}

// node_modules/@antv/component/node_modules/@antv/scale/esm/utils/normalize.js
function createNormalize(a2, b) {
  return b - a2 ? (t) => (t - a2) / (b - a2) : (_2) => 0.5;
}

// node_modules/@antv/component/node_modules/@antv/scale/esm/utils/clamp.js
function createClamp(a2, b) {
  const lo = b < a2 ? b : a2;
  const hi = a2 > b ? a2 : b;
  return (x3) => Math.min(Math.max(lo, x3), hi);
}

// node_modules/@antv/component/node_modules/@antv/scale/esm/utils/bisect.js
function bisect(array, x3, lo, hi, getter) {
  let i = lo || 0;
  let j = hi || array.length;
  const get = getter || ((x4) => x4);
  while (i < j) {
    const mid = Math.floor((i + j) / 2);
    if (get(array[mid]) > x3) {
      j = mid;
    } else {
      i = mid + 1;
    }
  }
  return i;
}

// node_modules/@antv/component/node_modules/@antv/scale/esm/utils/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickIncrement(start, stop, count) {
  const step2 = (stop - start) / Math.max(0, count);
  const power = Math.floor(Math.log(step2) / Math.LN10);
  const error2 = step2 / __pow(10, power);
  if (power >= 0) {
    return (error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e2 ? 2 : 1) * __pow(10, power);
  }
  return -__pow(10, -power) / (error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e2 ? 2 : 1);
}

// node_modules/@antv/component/node_modules/@antv/scale/esm/utils/d3-linear-nice.js
var d3LinearNice = (min5, max6, count = 5) => {
  const d2 = [min5, max6];
  let i0 = 0;
  let i1 = d2.length - 1;
  let start = d2[i0];
  let stop = d2[i1];
  let step2;
  if (stop < start) {
    [start, stop] = [stop, start];
    [i0, i1] = [i1, i0];
  }
  step2 = tickIncrement(start, stop, count);
  if (step2 > 0) {
    start = Math.floor(start / step2) * step2;
    stop = Math.ceil(stop / step2) * step2;
    step2 = tickIncrement(start, stop, count);
  } else if (step2 < 0) {
    start = Math.ceil(start * step2) / step2;
    stop = Math.floor(stop * step2) / step2;
    step2 = tickIncrement(start, stop, count);
  }
  if (step2 > 0) {
    d2[i0] = Math.floor(start / step2) * step2;
    d2[i1] = Math.ceil(stop / step2) * step2;
  } else if (step2 < 0) {
    d2[i0] = Math.ceil(start * step2) / step2;
    d2[i1] = Math.floor(stop * step2) / step2;
  }
  return d2;
};

// node_modules/@antv/component/node_modules/@antv/scale/esm/utils/time-interval.js
var DURATION_SECOND = 1e3;
var DURATION_MINUTE = DURATION_SECOND * 60;
var DURATION_HOUR = DURATION_MINUTE * 60;
var DURATION_DAY = DURATION_HOUR * 24;
var DURATION_WEEK = DURATION_DAY * 7;
var DURATION_MONTH = DURATION_DAY * 30;
var DURATION_YEAR = DURATION_DAY * 365;
function createInterval(duration, floorish, offseti, field) {
  const adjust2 = (date, step2) => {
    const test = (date2) => field(date2) % step2 === 0;
    let i = step2;
    while (i && !test(date)) {
      offseti(date, -1);
      i -= 1;
    }
    return date;
  };
  const floori = (date, step2) => {
    if (step2)
      adjust2(date, step2);
    floorish(date);
  };
  const floor4 = (date, step2) => {
    const d2 = /* @__PURE__ */ new Date(+date);
    floori(d2, step2);
    return d2;
  };
  const ceil4 = (date, step2) => {
    const d2 = new Date(+date - 1);
    floori(d2, step2);
    offseti(d2, step2);
    floori(d2);
    return d2;
  };
  const range = (start, stop, step2, shouldAdjust) => {
    const ticks = [];
    const roundStep = Math.floor(step2);
    const t = shouldAdjust ? ceil4(start, step2) : ceil4(start);
    for (let i = t; i < stop; offseti(i, roundStep), floori(i)) {
      ticks.push(/* @__PURE__ */ new Date(+i));
    }
    return ticks;
  };
  return {
    ceil: ceil4,
    floor: floor4,
    range,
    duration
  };
}
var millisecond = createInterval(1, (date) => date, (date, step2 = 1) => {
  date.setTime(+date + step2);
}, (date) => date.getTime());
var second = createInterval(DURATION_SECOND, (date) => {
  date.setMilliseconds(0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_SECOND * step2);
}, (date) => date.getSeconds());
var minute = createInterval(DURATION_MINUTE, (date) => {
  date.setSeconds(0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_MINUTE * step2);
}, (date) => date.getMinutes());
var hour = createInterval(DURATION_HOUR, (date) => {
  date.setMinutes(0, 0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_HOUR * step2);
}, (date) => date.getHours());
var day = createInterval(DURATION_DAY, (date) => {
  date.setHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_DAY * step2);
}, (date) => date.getDate() - 1);
var month = createInterval(DURATION_MONTH, (date) => {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  const month2 = date.getMonth();
  date.setMonth(month2 + step2);
}, (date) => date.getMonth());
var week = createInterval(DURATION_WEEK, (date) => {
  date.setDate(date.getDate() - date.getDay() % 7);
  date.setHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  date.setDate(date.getDate() + 7 * step2);
}, (date) => {
  const start = month.floor(date);
  const end = /* @__PURE__ */ new Date(+date);
  return Math.floor((+end - +start) / DURATION_WEEK);
});
var year = createInterval(DURATION_YEAR, (date) => {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  const year2 = date.getFullYear();
  date.setFullYear(year2 + step2);
}, (date) => date.getFullYear());

// node_modules/@antv/component/node_modules/@antv/scale/esm/utils/utc-interval.js
var utcMillisecond = createInterval(1, (date) => date, (date, step2 = 1) => {
  date.setTime(+date + step2);
}, (date) => date.getTime());
var utcSecond = createInterval(DURATION_SECOND, (date) => {
  date.setUTCMilliseconds(0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_SECOND * step2);
}, (date) => date.getUTCSeconds());
var utcMinute = createInterval(DURATION_MINUTE, (date) => {
  date.setUTCSeconds(0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_MINUTE * step2);
}, (date) => date.getUTCMinutes());
var utcHour = createInterval(DURATION_HOUR, (date) => {
  date.setUTCMinutes(0, 0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_HOUR * step2);
}, (date) => date.getUTCHours());
var utcDay = createInterval(DURATION_DAY, (date) => {
  date.setUTCHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_DAY * step2);
}, (date) => date.getUTCDate() - 1);
var utcMonth = createInterval(DURATION_MONTH, (date) => {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  const month2 = date.getUTCMonth();
  date.setUTCMonth(month2 + step2);
}, (date) => date.getUTCMonth());
var utcWeek = createInterval(DURATION_WEEK, (date) => {
  date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7) % 7);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_WEEK * step2);
}, (date) => {
  const start = utcMonth.floor(date);
  const end = /* @__PURE__ */ new Date(+date);
  return Math.floor((+end - +start) / DURATION_WEEK);
});
var utcYear = createInterval(DURATION_YEAR, (date) => {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  const year2 = date.getUTCFullYear();
  date.setUTCFullYear(year2 + step2);
}, (date) => date.getUTCFullYear());

// node_modules/@antv/component/node_modules/@antv/scale/esm/utils/is-valid.js
function isValid(x3) {
  return !is_undefined_default(x3) && !isNull(x3) && !Number.isNaN(x3);
}

// node_modules/@antv/component/node_modules/@antv/scale/esm/utils/interpolatize.js
var createInterpolatorRound = (interpolator) => {
  return (t) => {
    const res = interpolator(t);
    return isNumber(res) ? Math.round(res) : res;
  };
};
function interpolatize(rangeOf3, normalizeDomain3) {
  return (Scale) => {
    Scale.prototype.rescale = function() {
      this.initRange();
      this.nice();
      const [transform2] = this.chooseTransforms();
      this.composeOutput(transform2, this.chooseClamp(transform2));
    };
    Scale.prototype.initRange = function() {
      const { interpolator } = this.options;
      this.options.range = rangeOf3(interpolator);
    };
    Scale.prototype.composeOutput = function(transform2, clamp2) {
      const { domain, interpolator, round: round5 } = this.getOptions();
      const normalize8 = normalizeDomain3(domain.map(transform2));
      const interpolate3 = round5 ? createInterpolatorRound(interpolator) : interpolator;
      this.output = compose(interpolate3, normalize8, clamp2, transform2);
    };
    Scale.prototype.invert = void 0;
  };
}

// node_modules/@antv/component/node_modules/@antv/scale/esm/utils/color.js
var import_color_string = __toESM(require_color_string());
function hue2rgb(p, q, m2) {
  let t = m2;
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}
function hsl2rbg(hsl2) {
  const h = hsl2[0] / 360;
  const s2 = hsl2[1] / 100;
  const l = hsl2[2] / 100;
  const a2 = hsl2[3];
  if (s2 === 0)
    return [l * 255, l * 255, l * 255, a2];
  const q = l < 0.5 ? l * (1 + s2) : l + s2 - l * s2;
  const p = 2 * l - q;
  const r = hue2rgb(p, q, h + 1 / 3);
  const g = hue2rgb(p, q, h);
  const b = hue2rgb(p, q, h - 1 / 3);
  return [r * 255, g * 255, b * 255, a2];
}
function string2rbg(s2) {
  const color2 = import_color_string.default.get(s2);
  if (!color2)
    return null;
  const { model, value } = color2;
  if (model === "rgb")
    return value;
  if (model === "hsl")
    return hsl2rbg(value);
  return null;
}

// node_modules/@antv/component/node_modules/@antv/scale/esm/utils/interpolate.js
var createInterpolateNumber = (a2, b) => {
  return (t) => a2 * (1 - t) + b * t;
};
var createInterpolateColor = (a2, b) => {
  const c1 = string2rbg(a2);
  const c2 = string2rbg(b);
  if (c1 === null || c2 === null)
    return c1 ? () => a2 : () => b;
  return (t) => {
    const values = new Array(4);
    for (let i = 0; i < 4; i += 1) {
      const from = c1[i];
      const to = c2[i];
      values[i] = from * (1 - t) + to * t;
    }
    const [r, g, b2, a3] = values;
    return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b2)}, ${a3})`;
  };
};
var createInterpolateValue = (a2, b) => {
  if (typeof a2 === "number" && typeof b === "number")
    return createInterpolateNumber(a2, b);
  if (typeof a2 === "string" && typeof b === "string")
    return createInterpolateColor(a2, b);
  return () => a2;
};
var createInterpolateRound = (a2, b) => {
  const interpolateNumber = createInterpolateNumber(a2, b);
  return (t) => Math.round(interpolateNumber(t));
};

// node_modules/@antv/component/node_modules/@antv/scale/esm/utils/internMap.js
function internGet({ map: map2, initKey }, value) {
  const key = initKey(value);
  return map2.has(key) ? map2.get(key) : value;
}
function internSet({ map: map2, initKey }, value) {
  const key = initKey(value);
  if (map2.has(key))
    return map2.get(key);
  map2.set(key, value);
  return value;
}
function internDelete({ map: map2, initKey }, value) {
  const key = initKey(value);
  if (map2.has(key)) {
    value = map2.get(key);
    map2.delete(key);
  }
  return value;
}
function keyof(value) {
  return typeof value === "object" ? value.valueOf() : value;
}
var InternMap = class extends Map {
  constructor(entries) {
    super();
    this.map = /* @__PURE__ */ new Map();
    this.initKey = keyof;
    if (entries !== null) {
      for (const [key, value] of entries) {
        this.set(key, value);
      }
    }
  }
  get(key) {
    return super.get(internGet({ map: this.map, initKey: this.initKey }, key));
  }
  has(key) {
    return super.has(internGet({ map: this.map, initKey: this.initKey }, key));
  }
  set(key, value) {
    return super.set(internSet({ map: this.map, initKey: this.initKey }, key), value);
  }
  delete(key) {
    return super.delete(internDelete({ map: this.map, initKey: this.initKey }, key));
  }
};

// node_modules/@antv/component/node_modules/@antv/scale/esm/scales/base.js
var Base = class {
  /**
   * 构造函数，根据自定义的选项和默认选项生成当前选项
   * @param options 需要自定义配置的选项
   */
  constructor(options) {
    this.options = deep_mix_default({}, this.getDefaultOptions());
    this.update(options);
  }
  /**
   * 返回当前的所有选项
   * @returns 当前的所有选项
   */
  getOptions() {
    return this.options;
  }
  /**
   * 更新选项和比例尺的内部状态
   * @param updateOptions 需要更新的选项
   */
  update(updateOptions = {}) {
    this.options = deep_mix_default({}, this.options, updateOptions);
    this.rescale(updateOptions);
  }
  /**
   * 根据需要更新 options 和更新后的 options 更新 scale 的内部状态，
   * 在函数内部可以用 this.options 获得更新后的 options
   * @param options 需要更新的 options
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  rescale(options) {
  }
};

// node_modules/@antv/component/node_modules/@antv/scale/esm/scales/ordinal.js
var defaultUnknown = Symbol("defaultUnknown");
function updateIndexMap(target, arr, key) {
  for (let i = 0; i < arr.length; i += 1) {
    if (!target.has(arr[i])) {
      target.set(key(arr[i]), i);
    }
  }
}
function mapBetweenArrByMapIndex(options) {
  const { value, from, to, mapper, notFoundReturn } = options;
  let mappedIndex = mapper.get(value);
  if (mappedIndex === void 0) {
    if (notFoundReturn !== defaultUnknown) {
      return notFoundReturn;
    }
    mappedIndex = from.push(value) - 1;
    mapper.set(value, mappedIndex);
  }
  return to[mappedIndex % to.length];
}
function createKey(d2) {
  if (d2 instanceof Date)
    return (d3) => `${d3}`;
  if (typeof d2 === "object")
    return (d3) => JSON.stringify(d3);
  return (d3) => d3;
}
var Ordinal = class _Ordinal extends Base {
  // 覆盖默认配置
  getDefaultOptions() {
    return {
      domain: [],
      range: [],
      unknown: defaultUnknown
    };
  }
  // 显示指定 options 的类型为 OrdinalOptions，从而推断出 O 的类型
  constructor(options) {
    super(options);
  }
  map(x3) {
    if (this.domainIndexMap.size === 0) {
      updateIndexMap(this.domainIndexMap, this.getDomain(), this.domainKey);
    }
    return mapBetweenArrByMapIndex({
      value: this.domainKey(x3),
      mapper: this.domainIndexMap,
      from: this.getDomain(),
      to: this.getRange(),
      notFoundReturn: this.options.unknown
    });
  }
  invert(y3) {
    if (this.rangeIndexMap.size === 0) {
      updateIndexMap(this.rangeIndexMap, this.getRange(), this.rangeKey);
    }
    return mapBetweenArrByMapIndex({
      value: this.rangeKey(y3),
      mapper: this.rangeIndexMap,
      from: this.getRange(),
      to: this.getDomain(),
      notFoundReturn: this.options.unknown
    });
  }
  // 因为 ordinal 比例尺更新内部状态的开销较大，所以按需更新
  rescale(options) {
    const [d2] = this.options.domain;
    const [r] = this.options.range;
    this.domainKey = createKey(d2);
    this.rangeKey = createKey(r);
    if (!this.rangeIndexMap) {
      this.rangeIndexMap = /* @__PURE__ */ new Map();
      this.domainIndexMap = /* @__PURE__ */ new Map();
      return;
    }
    if (!options || options.range) {
      this.rangeIndexMap.clear();
    }
    if (!options || options.domain || options.compare) {
      this.domainIndexMap.clear();
      this.sortedDomain = void 0;
    }
  }
  clone() {
    return new _Ordinal(this.options);
  }
  getRange() {
    return this.options.range;
  }
  getDomain() {
    if (this.sortedDomain)
      return this.sortedDomain;
    const { domain, compare } = this.options;
    this.sortedDomain = compare ? [...domain].sort(compare) : domain;
    return this.sortedDomain;
  }
};

// node_modules/@antv/component/node_modules/@antv/scale/esm/scales/band.js
function normalize7(array) {
  const min5 = Math.min(...array);
  return array.map((d2) => d2 / min5);
}
function splice3(array, n) {
  const sn = array.length;
  const diff = n - sn;
  return diff > 0 ? [...array, ...new Array(diff).fill(1)] : diff < 0 ? array.slice(0, n) : array;
}
function pretty(n) {
  return Math.round(n * 1e12) / 1e12;
}
function computeFlexBandState(options) {
  const { domain, range, paddingOuter, paddingInner, flex: F, round: round5, align } = options;
  const n = domain.length;
  const flex2 = splice3(F, n);
  const [start, end] = range;
  const width = end - start;
  const ratio = 2 / n * paddingOuter + 1 - 1 / n * paddingInner;
  const stepSum = width / ratio;
  const PI = stepSum * paddingInner / n;
  const bandWidthSum = stepSum - n * PI;
  const normalizedFlex = normalize7(flex2);
  const flexSum = normalizedFlex.reduce((sum, value) => sum + value);
  const minBandWidth = bandWidthSum / flexSum;
  const valueBandWidth = new InternMap(domain.map((d2, i) => {
    const bandWidth = normalizedFlex[i] * minBandWidth;
    return [d2, round5 ? Math.floor(bandWidth) : bandWidth];
  }));
  const valueStep = new InternMap(domain.map((d2, i) => {
    const bandWidth = normalizedFlex[i] * minBandWidth;
    const step2 = bandWidth + PI;
    return [d2, round5 ? Math.floor(step2) : step2];
  }));
  const finalStepSum = Array.from(valueStep.values()).reduce((sum, value) => sum + value);
  const outerPaddingSum = width - (finalStepSum - finalStepSum / n * paddingInner);
  const offset = outerPaddingSum * align;
  const bandStart = start + offset;
  let prev = round5 ? Math.round(bandStart) : bandStart;
  const adjustedRange = new Array(n);
  for (let i = 0; i < n; i += 1) {
    adjustedRange[i] = pretty(prev);
    const value = domain[i];
    prev += valueStep.get(value);
  }
  return {
    valueBandWidth,
    valueStep,
    adjustedRange
  };
}
function computeBandState(options) {
  var _a2;
  const { domain } = options;
  const n = domain.length;
  if (n === 0) {
    return {
      valueBandWidth: void 0,
      valueStep: void 0,
      adjustedRange: []
    };
  }
  const hasFlex = !!((_a2 = options.flex) === null || _a2 === void 0 ? void 0 : _a2.length);
  if (hasFlex) {
    return computeFlexBandState(options);
  }
  const { range, paddingOuter, paddingInner, round: round5, align } = options;
  let step2;
  let bandWidth;
  let rangeStart = range[0];
  const rangeEnd = range[1];
  const deltaRange = rangeEnd - rangeStart;
  const outerTotal = paddingOuter * 2;
  const innerTotal = n - paddingInner;
  step2 = deltaRange / Math.max(1, outerTotal + innerTotal);
  if (round5) {
    step2 = Math.floor(step2);
  }
  rangeStart += (deltaRange - step2 * (n - paddingInner)) * align;
  bandWidth = step2 * (1 - paddingInner);
  if (round5) {
    rangeStart = Math.round(rangeStart);
    bandWidth = Math.round(bandWidth);
  }
  const adjustedRange = new Array(n).fill(0).map((_2, i) => rangeStart + i * step2);
  return {
    valueStep: step2,
    valueBandWidth: bandWidth,
    adjustedRange
  };
}
var Band = class _Band extends Ordinal {
  // 覆盖默认配置
  getDefaultOptions() {
    return {
      domain: [],
      range: [0, 1],
      align: 0.5,
      round: false,
      paddingInner: 0,
      paddingOuter: 0,
      padding: 0,
      unknown: defaultUnknown,
      flex: []
    };
  }
  // 显示指定 options 的类型为 OrdinalOptions，从而推断出 O 的类型
  constructor(options) {
    super(options);
  }
  clone() {
    return new _Band(this.options);
  }
  getStep(x3) {
    if (this.valueStep === void 0)
      return 1;
    if (typeof this.valueStep === "number") {
      return this.valueStep;
    }
    if (x3 === void 0)
      return Array.from(this.valueStep.values())[0];
    return this.valueStep.get(x3);
  }
  getBandWidth(x3) {
    if (this.valueBandWidth === void 0)
      return 1;
    if (typeof this.valueBandWidth === "number") {
      return this.valueBandWidth;
    }
    if (x3 === void 0)
      return Array.from(this.valueBandWidth.values())[0];
    return this.valueBandWidth.get(x3);
  }
  getRange() {
    return this.adjustedRange;
  }
  getPaddingInner() {
    const { padding, paddingInner } = this.options;
    return padding > 0 ? padding : paddingInner;
  }
  getPaddingOuter() {
    const { padding, paddingOuter } = this.options;
    return padding > 0 ? padding : paddingOuter;
  }
  rescale() {
    super.rescale();
    const { align, domain, range, round: round5, flex: flex2 } = this.options;
    const { adjustedRange, valueBandWidth, valueStep } = computeBandState({
      align,
      range,
      round: round5,
      flex: flex2,
      paddingInner: this.getPaddingInner(),
      paddingOuter: this.getPaddingOuter(),
      domain
    });
    this.valueStep = valueStep;
    this.valueBandWidth = valueBandWidth;
    this.adjustedRange = adjustedRange;
  }
};

// node_modules/@antv/component/node_modules/@antv/scale/esm/tick-methods/d3-ticks.js
var d3Ticks = (begin, end, count) => {
  let n;
  let ticks;
  let start = begin;
  let stop = end;
  if (start === stop && count > 0) {
    return [start];
  }
  let step2 = tickIncrement(start, stop, count);
  if (step2 === 0 || !Number.isFinite(step2)) {
    return [];
  }
  if (step2 > 0) {
    start = Math.ceil(start / step2);
    stop = Math.floor(stop / step2);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    for (let i = 0; i < n; i += 1) {
      ticks[i] = (start + i) * step2;
    }
  } else {
    step2 = -step2;
    start = Math.ceil(start * step2);
    stop = Math.floor(stop * step2);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    for (let i = 0; i < n; i += 1) {
      ticks[i] = (start + i) / step2;
    }
  }
  return ticks;
};

// node_modules/@antv/component/node_modules/@antv/scale/esm/tick-methods/wilkinson-extended.js
var eps = Number.EPSILON * 100;

// node_modules/@antv/component/node_modules/@antv/scale/esm/scales/continuous.js
var createBiMap = (domain, range, createInterpolate) => {
  const [d0, d1] = domain;
  const [r0, r1] = range;
  let normalize8;
  let interpolate3;
  if (d0 < d1) {
    normalize8 = createNormalize(d0, d1);
    interpolate3 = createInterpolate(r0, r1);
  } else {
    normalize8 = createNormalize(d1, d0);
    interpolate3 = createInterpolate(r1, r0);
  }
  return compose(interpolate3, normalize8);
};
var createPolyMap = (domain, range, createInterpolate) => {
  const len5 = Math.min(domain.length, range.length) - 1;
  const normalizeList = new Array(len5);
  const interpolateList = new Array(len5);
  const reverse = domain[0] > domain[len5];
  const ascendingDomain = reverse ? [...domain].reverse() : domain;
  const ascendingRange = reverse ? [...range].reverse() : range;
  for (let i = 0; i < len5; i += 1) {
    normalizeList[i] = createNormalize(ascendingDomain[i], ascendingDomain[i + 1]);
    interpolateList[i] = createInterpolate(ascendingRange[i], ascendingRange[i + 1]);
  }
  return (x3) => {
    const i = bisect(domain, x3, 1, len5) - 1;
    const normalize8 = normalizeList[i];
    const interpolate3 = interpolateList[i];
    return compose(interpolate3, normalize8)(x3);
  };
};
var choosePiecewise = (domain, range, interpolate3, shouldRound) => {
  const n = Math.min(domain.length, range.length);
  const createPiecewise = n > 2 ? createPolyMap : createBiMap;
  const createInterpolate = shouldRound ? createInterpolateRound : interpolate3;
  return createPiecewise(domain, range, createInterpolate);
};
var Continuous = class extends Base {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      nice: false,
      clamp: false,
      round: false,
      interpolate: createInterpolateNumber,
      tickCount: 5
    };
  }
  /**
   * y = interpolate(normalize(clamp(transform(x))))
   */
  map(x3) {
    if (!isValid(x3))
      return this.options.unknown;
    return this.output(x3);
  }
  /**
   * x = transform(clamp(interpolate(normalize(y))))
   */
  invert(x3) {
    if (!isValid(x3))
      return this.options.unknown;
    return this.input(x3);
  }
  nice() {
    if (!this.options.nice)
      return;
    const [min5, max6, tickCount, ...rest] = this.getTickMethodOptions();
    this.options.domain = this.chooseNice()(min5, max6, tickCount, ...rest);
  }
  getTicks() {
    const { tickMethod } = this.options;
    const [min5, max6, tickCount, ...rest] = this.getTickMethodOptions();
    return tickMethod(min5, max6, tickCount, ...rest);
  }
  getTickMethodOptions() {
    const { domain, tickCount } = this.options;
    const min5 = domain[0];
    const max6 = domain[domain.length - 1];
    return [min5, max6, tickCount];
  }
  chooseNice() {
    return d3LinearNice;
  }
  rescale() {
    this.nice();
    const [transform2, untransform] = this.chooseTransforms();
    this.composeOutput(transform2, this.chooseClamp(transform2));
    this.composeInput(transform2, untransform, this.chooseClamp(untransform));
  }
  chooseClamp(transform2) {
    const { clamp: shouldClamp, range } = this.options;
    const domain = this.options.domain.map(transform2);
    const n = Math.min(domain.length, range.length);
    return shouldClamp ? createClamp(domain[0], domain[n - 1]) : identity_default;
  }
  composeOutput(transform2, clamp2) {
    const { domain, range, round: round5, interpolate: interpolate3 } = this.options;
    const piecewise = choosePiecewise(domain.map(transform2), range, interpolate3, round5);
    this.output = compose(piecewise, clamp2, transform2);
  }
  composeInput(transform2, untransform, clamp2) {
    const { domain, range } = this.options;
    const piecewise = choosePiecewise(range, domain.map(transform2), createInterpolateNumber);
    this.input = compose(untransform, clamp2, piecewise);
  }
};

// node_modules/@antv/component/node_modules/@antv/scale/esm/scales/linear.js
var Linear = class _Linear extends Continuous {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      unknown: void 0,
      nice: false,
      clamp: false,
      round: false,
      interpolate: createInterpolateValue,
      tickMethod: d3Ticks,
      tickCount: 5
    };
  }
  chooseTransforms() {
    return [identity_default, identity_default];
  }
  clone() {
    return new _Linear(this.options);
  }
};

// node_modules/fecha/lib/fecha.js
var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
var twoDigitsOptional = "\\d\\d?";
var twoDigits = "\\d\\d";
var threeDigits = "\\d{3}";
var fourDigits = "\\d{4}";
var word = "[^\\s]+";
var literal = /\[([^]*?)\]/gm;
function shorten(arr, sLen) {
  var newArr = [];
  for (var i = 0, len5 = arr.length; i < len5; i++) {
    newArr.push(arr[i].substr(0, sLen));
  }
  return newArr;
}
var monthUpdate = function(arrName) {
  return function(v, i18n) {
    var lowerCaseArr = i18n[arrName].map(function(v2) {
      return v2.toLowerCase();
    });
    var index2 = lowerCaseArr.indexOf(v.toLowerCase());
    if (index2 > -1) {
      return index2;
    }
    return null;
  };
};
function assign(origObj) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var _a2 = 0, args_1 = args; _a2 < args_1.length; _a2++) {
    var obj = args_1[_a2];
    for (var key in obj) {
      origObj[key] = obj[key];
    }
  }
  return origObj;
}
var dayNames = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday"
];
var monthNames = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthNamesShort = shorten(monthNames, 3);
var dayNamesShort = shorten(dayNames, 3);
var defaultI18n = {
  dayNamesShort,
  dayNames,
  monthNamesShort,
  monthNames,
  amPm: ["am", "pm"],
  DoFn: function(dayOfMonth) {
    return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
  }
};
var globalI18n = assign({}, defaultI18n);
var pad = function(val, len5) {
  if (len5 === void 0) {
    len5 = 2;
  }
  val = String(val);
  while (val.length < len5) {
    val = "0" + val;
  }
  return val;
};
var formatFlags = {
  D: function(dateObj) {
    return String(dateObj.getDate());
  },
  DD: function(dateObj) {
    return pad(dateObj.getDate());
  },
  Do: function(dateObj, i18n) {
    return i18n.DoFn(dateObj.getDate());
  },
  d: function(dateObj) {
    return String(dateObj.getDay());
  },
  dd: function(dateObj) {
    return pad(dateObj.getDay());
  },
  ddd: function(dateObj, i18n) {
    return i18n.dayNamesShort[dateObj.getDay()];
  },
  dddd: function(dateObj, i18n) {
    return i18n.dayNames[dateObj.getDay()];
  },
  M: function(dateObj) {
    return String(dateObj.getMonth() + 1);
  },
  MM: function(dateObj) {
    return pad(dateObj.getMonth() + 1);
  },
  MMM: function(dateObj, i18n) {
    return i18n.monthNamesShort[dateObj.getMonth()];
  },
  MMMM: function(dateObj, i18n) {
    return i18n.monthNames[dateObj.getMonth()];
  },
  YY: function(dateObj) {
    return pad(String(dateObj.getFullYear()), 4).substr(2);
  },
  YYYY: function(dateObj) {
    return pad(dateObj.getFullYear(), 4);
  },
  h: function(dateObj) {
    return String(dateObj.getHours() % 12 || 12);
  },
  hh: function(dateObj) {
    return pad(dateObj.getHours() % 12 || 12);
  },
  H: function(dateObj) {
    return String(dateObj.getHours());
  },
  HH: function(dateObj) {
    return pad(dateObj.getHours());
  },
  m: function(dateObj) {
    return String(dateObj.getMinutes());
  },
  mm: function(dateObj) {
    return pad(dateObj.getMinutes());
  },
  s: function(dateObj) {
    return String(dateObj.getSeconds());
  },
  ss: function(dateObj) {
    return pad(dateObj.getSeconds());
  },
  S: function(dateObj) {
    return String(Math.round(dateObj.getMilliseconds() / 100));
  },
  SS: function(dateObj) {
    return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
  },
  SSS: function(dateObj) {
    return pad(dateObj.getMilliseconds(), 3);
  },
  a: function(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
  },
  A: function(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
  },
  ZZ: function(dateObj) {
    var offset = dateObj.getTimezoneOffset();
    return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
  },
  Z: function(dateObj) {
    var offset = dateObj.getTimezoneOffset();
    return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
  }
};
var monthParse = function(v) {
  return +v - 1;
};
var emptyDigits = [null, twoDigitsOptional];
var emptyWord = [null, word];
var amPm = [
  "isPm",
  word,
  function(v, i18n) {
    var val = v.toLowerCase();
    if (val === i18n.amPm[0]) {
      return 0;
    } else if (val === i18n.amPm[1]) {
      return 1;
    }
    return null;
  }
];
var timezoneOffset = [
  "timezoneOffset",
  "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
  function(v) {
    var parts = (v + "").match(/([+-]|\d\d)/gi);
    if (parts) {
      var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
      return parts[0] === "+" ? minutes : -minutes;
    }
    return 0;
  }
];
var parseFlags = {
  D: ["day", twoDigitsOptional],
  DD: ["day", twoDigits],
  Do: ["day", twoDigitsOptional + word, function(v) {
    return parseInt(v, 10);
  }],
  M: ["month", twoDigitsOptional, monthParse],
  MM: ["month", twoDigits, monthParse],
  YY: [
    "year",
    twoDigits,
    function(v) {
      var now = /* @__PURE__ */ new Date();
      var cent = +("" + now.getFullYear()).substr(0, 2);
      return +("" + (+v > 68 ? cent - 1 : cent) + v);
    }
  ],
  h: ["hour", twoDigitsOptional, void 0, "isPm"],
  hh: ["hour", twoDigits, void 0, "isPm"],
  H: ["hour", twoDigitsOptional],
  HH: ["hour", twoDigits],
  m: ["minute", twoDigitsOptional],
  mm: ["minute", twoDigits],
  s: ["second", twoDigitsOptional],
  ss: ["second", twoDigits],
  YYYY: ["year", fourDigits],
  S: ["millisecond", "\\d", function(v) {
    return +v * 100;
  }],
  SS: ["millisecond", twoDigits, function(v) {
    return +v * 10;
  }],
  SSS: ["millisecond", threeDigits],
  d: emptyDigits,
  dd: emptyDigits,
  ddd: emptyWord,
  dddd: emptyWord,
  MMM: ["month", word, monthUpdate("monthNamesShort")],
  MMMM: ["month", word, monthUpdate("monthNames")],
  a: amPm,
  A: amPm,
  ZZ: timezoneOffset,
  Z: timezoneOffset
};
var globalMasks = {
  default: "ddd MMM DD YYYY HH:mm:ss",
  shortDate: "M/D/YY",
  mediumDate: "MMM D, YYYY",
  longDate: "MMMM D, YYYY",
  fullDate: "dddd, MMMM D, YYYY",
  isoDate: "YYYY-MM-DD",
  isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
  shortTime: "HH:mm",
  mediumTime: "HH:mm:ss",
  longTime: "HH:mm:ss.SSS"
};
var format = function(dateObj, mask, i18n) {
  if (mask === void 0) {
    mask = globalMasks["default"];
  }
  if (i18n === void 0) {
    i18n = {};
  }
  if (typeof dateObj === "number") {
    dateObj = new Date(dateObj);
  }
  if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
    throw new Error("Invalid Date pass to format");
  }
  mask = globalMasks[mask] || mask;
  var literals = [];
  mask = mask.replace(literal, function($0, $1) {
    literals.push($1);
    return "@@@";
  });
  var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
  mask = mask.replace(token, function($0) {
    return formatFlags[$0](dateObj, combinedI18nSettings);
  });
  return mask.replace(/@@@/g, function() {
    return literals.shift();
  });
};

// node_modules/@antv/component/node_modules/@antv/scale/esm/scales/sequential.js
var __decorate = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d2 = decorators[i]) r = (c2 < 3 ? d2(r) : c2 > 3 ? d2(target, key, r) : d2(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var Sequential_1;
function rangeOf(interpolator) {
  return [interpolator(0), interpolator(1)];
}
var normalizeDomain = (domain) => {
  const [d0, d1] = domain;
  const normalize8 = compose(createInterpolateNumber(0, 1), createNormalize(d0, d1));
  return normalize8;
};
var Sequential = Sequential_1 = class Sequential2 extends Linear {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      unknown: void 0,
      nice: false,
      clamp: false,
      round: false,
      interpolator: identity_default,
      tickMethod: d3Ticks,
      tickCount: 5
    };
  }
  constructor(options) {
    super(options);
  }
  clone() {
    return new Sequential_1(this.options);
  }
};
Sequential = Sequential_1 = __decorate([
  interpolatize(rangeOf, normalizeDomain)
], Sequential);

// node_modules/@antv/component/node_modules/@antv/scale/esm/scales/diverging.js
var __decorate2 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d2 = decorators[i]) r = (c2 < 3 ? d2(r) : c2 > 3 ? d2(target, key, r) : d2(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var Diverging_1;
function rangeOf2(interpolator) {
  return [interpolator(0), interpolator(0.5), interpolator(1)];
}
var normalizeDomain2 = (domain) => {
  const [d0, d1, d2] = domain;
  const normalizeLeft = compose(createInterpolateNumber(0, 0.5), createNormalize(d0, d1));
  const normalizeRight = compose(createInterpolateNumber(0.5, 1), createNormalize(d1, d2));
  return (x3) => {
    if (d0 > d2) {
      return x3 < d1 ? normalizeRight(x3) : normalizeLeft(x3);
    } else {
      return x3 < d1 ? normalizeLeft(x3) : normalizeRight(x3);
    }
  };
};
var Diverging = Diverging_1 = class Diverging2 extends Linear {
  getDefaultOptions() {
    return {
      domain: [0, 0.5, 1],
      unknown: void 0,
      nice: false,
      clamp: false,
      round: false,
      interpolator: identity_default,
      tickMethod: d3Ticks,
      tickCount: 5
    };
  }
  constructor(options) {
    super(options);
  }
  clone() {
    return new Diverging_1(this.options);
  }
};
Diverging = Diverging_1 = __decorate2([
  interpolatize(rangeOf2, normalizeDomain2)
], Diverging);

// node_modules/@antv/component/esm/ui/indicator/constant.js
var DEFAULT_INDICATOR_STYLE_PROPS = {
  backgroundFill: "#262626",
  backgroundLineCap: "round",
  backgroundLineWidth: 1,
  backgroundStroke: "#333",
  backgroundZIndex: -1,
  formatter: function(val) {
    return val.toString();
  },
  labelFill: "#fff",
  labelFontSize: 12,
  labelTextBaseline: "middle",
  padding: [2, 4],
  position: "right",
  radius: 0,
  zIndex: 999
};

// node_modules/@antv/component/esm/ui/indicator/indicator.js
var CLASS_NAMES9 = classNames({
  background: "background",
  labelGroup: "label-group",
  label: "label"
}, "indicator");
var Indicator = (
  /** @class */
  function(_super) {
    __extends(Indicator2, _super);
    function Indicator2(options) {
      var _this2 = _super.call(this, options, DEFAULT_INDICATOR_STYLE_PROPS) || this;
      _this2.point = [0, 0];
      _this2.group = _this2.appendChild(new Group({}));
      _this2.isMutationObserved = true;
      return _this2;
    }
    Indicator2.prototype.renderBackground = function() {
      if (!this.label)
        return;
      var _a2 = this.attributes, position = _a2.position, padding = _a2.padding;
      var _b = __read(parseSeriesAttr(padding), 4), t = _b[0], r = _b[1], b = _b[2], l = _b[3];
      var _c = this.label.node().getLocalBounds(), min5 = _c.min, max6 = _c.max;
      var bbox = new BBox(min5[0] - l, min5[1] - t, max6[0] + r - min5[0] + l, max6[1] + b - min5[1] + t);
      var path = this.getPath(position, bbox);
      var style = subStyleProps(this.attributes, "background");
      this.background = select(this.group).maybeAppendByClassName(CLASS_NAMES9.background, "path").styles(__assign(__assign({}, style), { d: path }));
      this.group.appendChild(this.label.node());
    };
    Indicator2.prototype.renderLabel = function() {
      var _a2 = this.attributes, formatter2 = _a2.formatter, labelText = _a2.labelText;
      var style = subStyleProps(this.attributes, "label");
      var _b = __read(splitStyle(style), 2), _c = _b[0], groupStyle = _b[1], rawText = _c.text, textStyle = __rest(_c, ["text"]);
      this.label = select(this.group).maybeAppendByClassName(CLASS_NAMES9.labelGroup, "g").styles(groupStyle);
      if (!labelText)
        return;
      var text = this.label.maybeAppendByClassName(CLASS_NAMES9.label, function() {
        return renderExtDo(formatter2(labelText));
      }).style("text", formatter2(labelText).toString());
      text.selectAll("text").styles(textStyle);
    };
    Indicator2.prototype.adjustLayout = function() {
      var _a2 = __read(this.point, 2), dx = _a2[0], dy = _a2[1];
      var _b = this.attributes, x3 = _b.x, y3 = _b.y;
      this.group.attr("transform", "translate(".concat(x3 - dx, ", ").concat(y3 - dy, ")"));
    };
    Indicator2.prototype.getPath = function(position, bbox) {
      var r = this.attributes.radius;
      var x3 = bbox.x, y3 = bbox.y, width = bbox.width, height = bbox.height;
      var pathArray = [
        // 0 开始路径
        ["M", x3 + r, y3],
        // 1 上边线
        ["L", x3 + width - r, y3],
        // 2 右上角圆弧
        ["A", r, r, 0, 0, 1, x3 + width, y3 + r],
        // 3 右边线
        ["L", x3 + width, y3 + height - r],
        // 4 右下角圆弧
        ["A", r, r, 0, 0, 1, x3 + width - r, y3 + height],
        // 5 下边线
        ["L", x3 + r, y3 + height],
        // 6 左下角圆弧
        ["A", r, r, 0, 0, 1, x3, y3 + height - r],
        // 7 左边线
        ["L", x3, y3 + r],
        // 8 左上角圆弧
        ["A", r, r, 0, 0, 1, x3 + r, y3],
        // 9 关闭路径
        ["Z"]
      ];
      var revertPositionMap = { top: 4, right: 6, bottom: 0, left: 2 };
      var index2 = revertPositionMap[position];
      var newPath = this.createCorner([pathArray[index2].slice(-2), pathArray[index2 + 1].slice(-2)]);
      pathArray.splice.apply(pathArray, __spreadArray([index2 + 1, 1], __read(newPath), false));
      pathArray[0][0] = "M";
      return pathArray;
    };
    Indicator2.prototype.createCorner = function(edge, size2) {
      if (size2 === void 0) {
        size2 = 10;
      }
      var cornerScale = 0.8;
      var isH = isHorizontal.apply(void 0, __spreadArray([], __read(edge), false));
      var _a2 = __read(edge, 2), _b = __read(_a2[0], 2), x0 = _b[0], y0 = _b[1], _c = __read(_a2[1], 2), x1 = _c[0], y1 = _c[1];
      var _d = __read(isH ? [x1 - x0, [x0, x1]] : [y1 - y0, [y0, y1]], 2), len5 = _d[0], _e = __read(_d[1], 2), b0 = _e[0], b1 = _e[1];
      var hL = len5 / 2;
      var sign = len5 / Math.abs(len5);
      var cL = size2 * sign;
      var hCL = cL / 2;
      var cS = cL * Math.sqrt(3) / 2 * cornerScale;
      var _f = __read([b0, b0 + hL - hCL, b0 + hL, b0 + hL + hCL, b1], 5), a0 = _f[0], a1 = _f[1], a2 = _f[2], a3 = _f[3], a4 = _f[4];
      if (isH) {
        this.point = [a2, y0 - cS];
        return [
          ["L", a0, y0],
          ["L", a1, y0],
          ["L", a2, y0 - cS],
          ["L", a3, y0],
          ["L", a4, y0]
        ];
      }
      this.point = [x0 + cS, a2];
      return [
        ["L", x0, a0],
        ["L", x0, a1],
        ["L", x0 + cS, a2],
        ["L", x0, a3],
        ["L", x0, a4]
      ];
    };
    Indicator2.prototype.applyVisibility = function() {
      var visibility2 = this.attributes.visibility;
      if (visibility2 === "hidden")
        hide(this);
      else
        show(this);
    };
    Indicator2.prototype.bindEvents = function() {
      this.label.on(ElementEvent.BOUNDS_CHANGED, this.renderBackground);
    };
    Indicator2.prototype.render = function() {
      this.renderLabel();
      this.renderBackground();
      this.adjustLayout();
      this.applyVisibility();
    };
    return Indicator2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/slider/constant.js
var HANDLE_ICON_DEFAULT_CFG = {
  fill: "#fff",
  lineWidth: 1,
  radius: 2,
  size: 10,
  stroke: "#bfbfbf",
  strokeOpacity: 1,
  zIndex: 0
};
var HANDLE_LABEL_DEFAULT_CFG = {
  fill: "#000",
  fillOpacity: 0.45,
  fontSize: 12,
  textAlign: "center",
  textBaseline: "middle",
  zIndex: 1
};
var HANDLE_DEFAULT_CFG = {
  x: 0,
  y: 0,
  orientation: "horizontal",
  showLabel: true,
  type: "start"
};
var CLASS_NAMES10 = classNames({
  foreground: "foreground",
  handle: "handle",
  selection: "selection",
  sparkline: "sparkline",
  sparklineGroup: "sparkline-group",
  track: "track",
  brushArea: "brush-area"
}, "slider");

// node_modules/@antv/component/esm/ui/slider/handle.js
var CLASS_NAMES11 = classNames({
  labelGroup: "label-group",
  label: "label",
  iconGroup: "icon-group",
  icon: "icon",
  iconRect: "icon-rect",
  iconLine: "icon-line"
}, "handle");
var HandleIcon = (
  /** @class */
  function(_super) {
    __extends(HandleIcon2, _super);
    function HandleIcon2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HandleIcon2.prototype.render = function(attributes, container) {
      var x3 = attributes.x, y3 = attributes.y, _a2 = attributes.size, size2 = _a2 === void 0 ? 10 : _a2, _b = attributes.radius, radius = _b === void 0 ? size2 / 4 : _b, orientation = attributes.orientation, classNamePrefix = attributes.classNamePrefix, iconStyle = __rest(attributes, ["x", "y", "size", "radius", "orientation", "classNamePrefix"]);
      var width = size2;
      var height = width * 2.4;
      var rectClassName = classNamePrefix ? "".concat(CLASS_NAMES11.iconRect.name, " ").concat(classNamePrefix, "handle-icon-rect") : CLASS_NAMES11.iconRect.name;
      var lineClassName = function(index2) {
        return classNamePrefix ? "".concat(CLASS_NAMES11.iconLine, "-").concat(index2, " ").concat(classNamePrefix, "handle-icon-line") : "".concat(CLASS_NAMES11.iconLine, "-").concat(index2);
      };
      var rect = select(container).maybeAppendByClassName(CLASS_NAMES11.iconRect, "rect").attr("className", rectClassName).styles(__assign(__assign({}, iconStyle), { width, height, radius, x: x3 - width / 2, y: y3 - height / 2, transformOrigin: "center" }));
      var x1 = x3 + 1 / 3 * width - width / 2;
      var x22 = x3 + 2 / 3 * width - width / 2;
      var y1 = y3 + 1 / 4 * height - height / 2;
      var y22 = y3 + 3 / 4 * height - height / 2;
      rect.maybeAppendByClassName("".concat(CLASS_NAMES11.iconLine, "-1"), "line").attr("className", lineClassName(1)).styles(__assign({ x1, x2: x1, y1, y2: y22 }, iconStyle));
      rect.maybeAppendByClassName("".concat(CLASS_NAMES11.iconLine, "-2"), "line").attr("className", lineClassName(2)).styles(__assign({ x1: x22, x2: x22, y1, y2: y22 }, iconStyle));
      if (orientation === "vertical")
        rect.node().style.transform = "rotate(90)";
    };
    return HandleIcon2;
  }(Component)
);
var Handle2 = (
  /** @class */
  function(_super) {
    __extends(Handle3, _super);
    function Handle3(options) {
      return _super.call(this, options, HANDLE_DEFAULT_CFG) || this;
    }
    Handle3.prototype.renderLabel = function(container) {
      var _this2 = this;
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, showLabel = _a2.showLabel;
      var _b = subStyleProps(this.attributes, "label"), _c = _b.x, labelX = _c === void 0 ? 0 : _c, _d = _b.y, labelY = _d === void 0 ? 0 : _d, transform2 = _b.transform, transformOrigin = _b.transformOrigin, style = __rest(_b, ["x", "y", "transform", "transformOrigin"]);
      var _e = __read(splitStyle(style, []), 2), labelStyle = _e[0], groupStyle = _e[1];
      var labelGroup = select(container).maybeAppendByClassName(CLASS_NAMES11.labelGroup, "g").styles(groupStyle);
      var _f = __assign(__assign({}, HANDLE_LABEL_DEFAULT_CFG), labelStyle), text = _f.text, rest = __rest(_f, ["text"]);
      ifShow(!!showLabel, labelGroup, function(group2) {
        _this2.label = group2.maybeAppendByClassName(CLASS_NAMES11.label, "text").styles(__assign(__assign({}, rest), { x: x3 + labelX, y: y3 + labelY, transform: transform2, transformOrigin, text: "".concat(text) }));
        _this2.label.on("mousedown", function(e) {
          e.stopPropagation();
        });
        _this2.label.on("touchstart", function(e) {
          e.stopPropagation();
        });
      });
    };
    Handle3.prototype.renderIcon = function(container) {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, orientation = _a2.orientation, type = _a2.type, classNamePrefix = _a2.classNamePrefix;
      var iconStyle = __assign(__assign({ x: x3, y: y3, orientation, classNamePrefix }, HANDLE_ICON_DEFAULT_CFG), subStyleProps(this.attributes, "icon"));
      var _b = this.attributes.iconShape, iconShape = _b === void 0 ? function() {
        return new HandleIcon({ style: iconStyle });
      } : _b;
      var iconGroup = select(container).maybeAppendByClassName(CLASS_NAMES11.iconGroup, "g");
      iconGroup.selectAll(CLASS_NAMES11.icon.class).data([iconShape]).join(function(enter) {
        return enter.append(typeof iconShape === "string" ? iconShape : function() {
          return iconShape(type);
        }).attr("className", CLASS_NAMES11.icon.name);
      }, function(update2) {
        return update2.update(iconStyle);
      }, function(exit) {
        return exit.remove();
      });
    };
    Handle3.prototype.render = function(attributes, container) {
      this.renderIcon(container);
      this.renderLabel(container);
    };
    return Handle3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/continuous/utils.js
function search(array, value) {
  for (var i = 1; i < array.length; i += 1) {
    var st = array[i - 1];
    var end = array[i];
    if (value >= st && value <= end) {
      return [st, end];
    }
  }
  return [value, value];
}
function getBlockColor(partition, color2, orientation) {
  var colors = Array.from(color2);
  var count = partition.length;
  return new Array(count).fill(0).reduce(function(r, v, idx) {
    var c2 = colors[idx % colors.length];
    return r += " ".concat(partition[idx], ":").concat(c2).concat(idx < count - 1 ? " ".concat(partition[idx + 1], ":").concat(c2) : "");
  }, "l(".concat(orientation === "horizontal" ? "0" : "270", ")"));
}
function getNextTickValue(ticks, value) {
  var _a2 = __read(search(ticks, value), 2), v1 = _a2[0], v2 = _a2[1];
  return { tick: value > (v1 + v2) / 2 ? v2 : v1, range: [v1, v2] };
}

// node_modules/@antv/component/esm/ui/legend/continuous/ribbon.js
var CLASS_NAMES12 = classNames({
  trackGroup: "background-group",
  track: "background",
  selectionGroup: "ribbon-group",
  selection: "ribbon",
  clipPath: "clip-path"
}, "ribbon");
function getShape(attr2) {
  var orientation = attr2.orientation, size2 = attr2.size, length5 = attr2.length;
  return ifHorizontal(orientation, [length5, size2], [size2, length5]);
}
function getTrackPath(attr2) {
  var type = attr2.type;
  var _a2 = __read(getShape(attr2), 2), cw = _a2[0], ch = _a2[1];
  if (type === "size") {
    return [["M", 0, ch], ["L", 0 + cw, 0], ["L", 0 + cw, ch], ["Z"]];
  }
  return [["M", 0, ch], ["L", 0, 0], ["L", 0 + cw, 0], ["L", 0 + cw, ch], ["Z"]];
}
function getSelectionPath(attr2) {
  return getTrackPath(attr2);
}
function getColor2(attr2) {
  var orientation = attr2.orientation, color2 = attr2.color, block = attr2.block, partition = attr2.partition;
  var colors;
  if (isFunction(color2)) {
    var len5 = 20;
    colors = new Array(len5).fill(0).map(function(_2, index2, arr) {
      return color2(index2 / (arr.length - 1));
    });
  } else
    colors = color2;
  var count = colors.length;
  var genericColor = colors.map(function(c2) {
    return parseColor(c2).toString();
  });
  if (!count)
    return "";
  if (count === 1)
    return genericColor[0];
  if (block)
    return getBlockColor(partition, genericColor, orientation);
  return genericColor.reduce(function(r, c2, idx) {
    return r += " ".concat(idx / (count - 1), ":").concat(c2);
  }, "l(".concat(ifHorizontal(orientation, "0", "270"), ")"));
}
function getClipPath(attr2) {
  var orientation = attr2.orientation, range = attr2.range;
  if (!range)
    return [];
  var _a2 = __read(getShape(attr2), 2), width = _a2[0], height = _a2[1];
  var _b = __read(range, 2), st = _b[0], et = _b[1];
  var x3 = ifHorizontal(orientation, st * width, 0);
  var y3 = ifHorizontal(orientation, 0, st * height);
  var w = ifHorizontal(orientation, et * width, width);
  var h = ifHorizontal(orientation, height, et * height);
  return [["M", x3, y3], ["L", x3, h], ["L", w, h], ["L", w, y3], ["Z"]];
}
function renderTrack(container, attr2) {
  var style = subStyleProps(attr2, "track");
  var classNamePrefix = attr2.classNamePrefix;
  var trackClassName = getLegendClassName(CLASS_NAMES12.track.name, CLASSNAME_SUFFIX_MAP2.track, classNamePrefix);
  container.maybeAppendByClassName(CLASS_NAMES12.track, "path").attr("className", trackClassName).styles(__assign({ d: getTrackPath(attr2) }, style));
}
function renderSelection(container, attr2) {
  var style = subStyleProps(attr2, "selection");
  var fill = getColor2(attr2);
  var classNamePrefix = attr2.classNamePrefix;
  var selectionClassName = getLegendClassName(CLASS_NAMES12.selection.name, CLASSNAME_SUFFIX_MAP2.selection, classNamePrefix);
  var ribbon = container.maybeAppendByClassName(CLASS_NAMES12.selection, "path").attr("className", selectionClassName).styles(__assign({ d: getSelectionPath(attr2), fill }, style));
  var clipPath = ribbon.maybeAppendByClassName(CLASS_NAMES12.clipPath, "path").styles({ d: getClipPath(attr2) }).node();
  ribbon.style("clipPath", clipPath);
}
var Ribbon = (
  /** @class */
  function(_super) {
    __extends(Ribbon2, _super);
    function Ribbon2(options) {
      return _super.call(this, options, {
        type: "color",
        orientation: "horizontal",
        size: 30,
        range: [0, 1],
        length: 200,
        block: false,
        partition: [],
        color: ["#fff", "#000"],
        trackFill: "#e5e5e5"
      }) || this;
    }
    Ribbon2.prototype.render = function(attribute, container) {
      var trackGroup = select(container).maybeAppendByClassName(CLASS_NAMES12.trackGroup, "g");
      renderTrack(trackGroup, attribute);
      var ribbonGroup = select(container).maybeAppendByClassName(CLASS_NAMES12.selectionGroup, "g");
      renderSelection(ribbonGroup, attribute);
    };
    return Ribbon2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/continuous.js
function getMinMax(data2) {
  return {
    min: Math.min.apply(Math, __spreadArray([], __read(data2.map(function(d2) {
      return d2.value;
    })), false)),
    max: Math.max.apply(Math, __spreadArray([], __read(data2.map(function(d2) {
      return d2.value;
    })), false))
  };
}
var Continuous2 = (
  /** @class */
  function(_super) {
    __extends(Continuous3, _super);
    function Continuous3(options) {
      var _this2 = _super.call(this, options, CONTINUOUS_DEFAULT_OPTIONS) || this;
      _this2.eventToOffsetScale = new Linear({});
      _this2.innerRibbonScale = new Linear({});
      _this2.cacheLabelBBox = null;
      _this2.cacheHandleBBox = null;
      _this2.onHovering = function(e) {
        var _a2 = _this2.attributes, data2 = _a2.data, block = _a2.block;
        e.stopPropagation();
        var value = _this2.getValueByCanvasPoint(e);
        if (block) {
          var range = getNextTickValue(data2.map(function(_a3) {
            var value2 = _a3.value;
            return value2;
          }), value).range;
          var selection = _this2.getRealSelection(range);
          _this2.showIndicator((range[0] + range[1]) / 2, "".concat(selection[0], "-").concat(selection[1]));
          _this2.dispatchIndicated(value, range);
        } else {
          var safetyValue = _this2.getTickValue(value);
          _this2.showIndicator(safetyValue, "".concat(_this2.getRealValue(safetyValue)));
          _this2.dispatchIndicated(safetyValue);
        }
      };
      _this2.onDragStart = function(target) {
        return function(e) {
          e.stopPropagation();
          if (!_this2.attributes.slidable)
            return;
          _this2.target = target;
          _this2.prevValue = _this2.getTickValue(_this2.getValueByCanvasPoint(e));
          document.addEventListener("mousemove", _this2.onDragging);
          document.addEventListener("touchmove", _this2.onDragging);
          document.addEventListener("mouseleave", _this2.onDragEnd);
          document.addEventListener("mouseup", _this2.onDragEnd);
          document.addEventListener("mouseup", _this2.onDragEnd);
          document.addEventListener("touchend", _this2.onDragEnd);
        };
      };
      _this2.onDragging = function(e) {
        var target = _this2.target;
        _this2.updateMouse();
        var _a2 = __read(_this2.selection, 2), start = _a2[0], end = _a2[1];
        var currValue = _this2.getTickValue(_this2.getValueByCanvasPoint(e));
        var diffValue = currValue - _this2.prevValue;
        if (target === "start")
          start !== currValue && _this2.updateSelection(currValue, end);
        else if (target === "end")
          end !== currValue && _this2.updateSelection(start, currValue);
        else if (target === "ribbon" && diffValue !== 0) {
          _this2.prevValue = currValue;
          _this2.updateSelection(diffValue, diffValue, true);
        }
      };
      _this2.onDragEnd = function() {
        _this2.style.cursor = "pointer";
        document.removeEventListener("mousemove", _this2.onDragging);
        document.removeEventListener("touchmove", _this2.onDragging);
        document.removeEventListener("mouseup", _this2.onDragEnd);
        document.removeEventListener("touchend", _this2.onDragEnd);
      };
      return _this2;
    }
    Object.defineProperty(Continuous3.prototype, "handleOffsetRatio", {
      get: function() {
        return this.ifHorizontal(0.5, 0.5);
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.getBBox = function() {
      var _a2 = this.attributes, width = _a2.width, height = _a2.height;
      return new BBox(0, 0, width, height);
    };
    Continuous3.prototype.render = function(attributes, container) {
      var _this2 = this;
      var classNamePrefix = attributes.classNamePrefix;
      var baseClassName = container.className || "legend-continuous";
      if (classNamePrefix) {
        container.attr("className", "".concat(baseClassName, " ").concat(classNamePrefix, "legend"));
      } else if (!container.className) {
        container.attr("className", "legend-continuous");
      }
      var showLabel = attributes.showLabel;
      this.renderTitle(select(container));
      var _a2 = this.availableSpace, x3 = _a2.x, y3 = _a2.y;
      var contentGroup = select(container).maybeAppendByClassName(CLASS_NAMES4.contentGroup, "g").styles({ transform: "translate(".concat(x3, ", ").concat(y3, ")") });
      var labelGroup = contentGroup.maybeAppendByClassName(CLASS_NAMES4.labelGroup, "g").styles({ zIndex: 1 });
      ifShow(!!showLabel, labelGroup, function(group2) {
        _this2.renderLabel(group2);
      });
      var ribbonGroup = contentGroup.maybeAppendByClassName(CLASS_NAMES4.ribbonGroup, "g").styles({ zIndex: 0 });
      this.handlesGroup = contentGroup.maybeAppendByClassName(CLASS_NAMES4.handlesGroup, "g").styles({ zIndex: 2 });
      this.renderHandles();
      this.renderRibbon(ribbonGroup);
      this.renderIndicator(contentGroup);
      this.adjustLabel();
      this.adjustHandles();
    };
    Object.defineProperty(Continuous3.prototype, "range", {
      get: function() {
        var _a2 = this.attributes, data2 = _a2.data, domain = _a2.domain;
        return domain ? { min: domain[0], max: domain[1] } : getMinMax(data2);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "ribbonScale", {
      get: function() {
        var _a2 = this.range, min5 = _a2.min, max6 = _a2.max;
        this.innerRibbonScale.update({
          domain: [min5, max6],
          range: [0, 1]
        });
        return this.innerRibbonScale;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "ribbonRange", {
      get: function() {
        var _a2 = __read(this.selection, 2), min5 = _a2[0], max6 = _a2[1];
        var scale9 = this.ribbonScale;
        return [scale9.map(min5), scale9.map(max6)];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "selection", {
      get: function() {
        var _a2 = this.range, min5 = _a2.min, max6 = _a2.max;
        var _b = this.attributes.defaultValue, _c = _b === void 0 ? [min5, max6] : _b, _d = __read(_c, 2), start = _d[0], end = _d[1];
        return [start, end];
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.ifHorizontal = function(a2, b) {
      return ifHorizontal(this.attributes.orientation, typeof a2 === "function" ? a2() : a2, typeof b === "function" ? b() : b);
    };
    Continuous3.prototype.renderTitle = function(container) {
      var _a2 = this.attributes, showTitle = _a2.showTitle, titleText = _a2.titleText, width = _a2.width, height = _a2.height, classNamePrefix = _a2.classNamePrefix;
      var style = subStyleProps(this.attributes, "title");
      var finalTitleStyle = __assign(__assign({}, style), { width, height, text: titleText, classNamePrefix });
      var that = this;
      container.selectAll(CLASS_NAMES4.title.class).data(showTitle ? [titleText] : []).join(function(enter) {
        return enter.append(function() {
          return new Title({ style: finalTitleStyle });
        }).attr("className", CLASS_NAMES4.title.name).each(function() {
          that.title = this;
        });
      }, function(update2) {
        return update2.update(finalTitleStyle);
      }, function(exit) {
        return exit.each(function() {
          that.title = void 0;
        }).remove();
      });
    };
    Object.defineProperty(Continuous3.prototype, "availableSpace", {
      get: function() {
        if (this.title)
          return this.title.getAvailableSpace();
        var _a2 = this.attributes, width = _a2.width, height = _a2.height;
        return new BBox(0, 0, width, height);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "labelFixedSpacing", {
      get: function() {
        var showTick = this.attributes.showTick;
        return showTick ? 5 : 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "labelPosition", {
      get: function() {
        var _a2 = this.attributes, orientation = _a2.orientation, labelDirection = _a2.labelDirection;
        var positions = {
          vertical: { positive: "right", negative: "left" },
          horizontal: { positive: "bottom", negative: "top" }
        };
        return positions[orientation][labelDirection];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "labelBBox", {
      get: function() {
        var _a2;
        var showLabel = this.attributes.showLabel;
        if (!showLabel)
          return new BBox(0, 0, 0, 0);
        if (this.cacheLabelBBox)
          return this.cacheLabelBBox;
        var _b = ((_a2 = this.label.querySelector(CLASS_NAMES.labelGroup.class)) === null || _a2 === void 0 ? void 0 : _a2.children.slice(-1)[0]).getBBox(), width = _b.width, height = _b.height;
        this.cacheLabelBBox = new BBox(0, 0, width, height);
        return this.cacheLabelBBox;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "labelShape", {
      get: function() {
        var _a2 = this.attributes, showLabel = _a2.showLabel, _b = _a2.labelSpacing, labelSpacing = _b === void 0 ? 0 : _b;
        if (!showLabel)
          return { width: 0, height: 0, size: 0, length: 0 };
        var _c = this.labelBBox, width = _c.width, height = _c.height;
        var size2 = this.ifHorizontal(height, width) + labelSpacing + this.labelFixedSpacing;
        var length5 = this.ifHorizontal(width, height);
        return { width, height, size: size2, length: length5 };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "ribbonBBox", {
      get: function() {
        var _a2 = this.attributes, showHandle = _a2.showHandle, userDefinedRibbonSize = _a2.ribbonSize;
        var _b = this.availableSpace, availableWidth = _b.width, availableHeight = _b.height;
        var _c = this.labelShape, labelSize = _c.size, labelLength = _c.length;
        var _d = __read(this.ifHorizontal([availableHeight, availableWidth], [availableWidth, availableHeight]), 2), availableSize = _d[0], availableLength = _d[1];
        var _e = showHandle ? this.handleShape : { size: 0, length: 0 }, handleSize = _e.size, handleLength = _e.length;
        var handleRatio = this.handleOffsetRatio;
        var ribbonSize = 0;
        var labelPosition = this.labelPosition;
        if (userDefinedRibbonSize) {
          ribbonSize = userDefinedRibbonSize;
        } else if (["bottom", "right"].includes(labelPosition)) {
          ribbonSize = Math.min(availableSize - labelSize, (availableSize - handleSize) / handleRatio);
        } else if (availableSize * (1 - handleRatio) > handleSize) {
          ribbonSize = Math.max(availableSize - labelSize, 0);
        } else
          ribbonSize = Math.max((availableSize - labelSize - handleSize) / handleRatio, 0);
        var edgeLength = Math.max(handleLength, labelLength);
        var ribbonLength = availableLength - edgeLength;
        var _f = __read(this.ifHorizontal([ribbonLength, ribbonSize], [ribbonSize, ribbonLength]), 2), width = _f[0], height = _f[1];
        var finalLabelOccupy = ["top", "left"].includes(labelPosition) ? labelSize : 0;
        var _g = __read(this.ifHorizontal([edgeLength / 2, finalLabelOccupy], [finalLabelOccupy, edgeLength / 2]), 2), x3 = _g[0], y3 = _g[1];
        return new BBox(x3, y3, width, height);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "ribbonShape", {
      get: function() {
        var _a2 = this.ribbonBBox, width = _a2.width, height = _a2.height;
        return this.ifHorizontal({ size: height, length: width }, { size: width, length: height });
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.renderRibbon = function(container) {
      var _a2 = this.attributes, data2 = _a2.data, type = _a2.type, orientation = _a2.orientation, color2 = _a2.color, block = _a2.block, classNamePrefix = _a2.classNamePrefix;
      var ribbonStyle = subStyleProps(this.attributes, "ribbon");
      var _b = this.range, min5 = _b.min, max6 = _b.max;
      var _c = this.ribbonBBox, x3 = _c.x, y3 = _c.y;
      var _d = this.ribbonShape, length5 = _d.length, size2 = _d.size;
      var style = deepAssign({
        transform: "translate(".concat(x3, ", ").concat(y3, ")"),
        length: length5,
        size: size2,
        type,
        orientation,
        color: color2,
        block,
        partition: data2.map(function(d2) {
          return (d2.value - min5) / (max6 - min5);
        }),
        range: this.ribbonRange,
        classNamePrefix
      }, ribbonStyle);
      var ribbonClassName = getLegendClassName(CLASS_NAMES4.ribbon.name, CLASSNAME_SUFFIX_MAP2.ribbon, classNamePrefix);
      this.ribbon = container.maybeAppendByClassName(CLASS_NAMES4.ribbon, function() {
        return new Ribbon({
          style,
          className: ribbonClassName
        });
      }).update(style);
    };
    Continuous3.prototype.getHandleClassName = function(type) {
      return "".concat(CLASS_NAMES4.prefix("".concat(type, "-handle")));
    };
    Continuous3.prototype.renderHandles = function() {
      var _a2 = this.attributes, showHandle = _a2.showHandle, orientation = _a2.orientation, classNamePrefix = _a2.classNamePrefix;
      var handleStyle = subStyleProps(this.attributes, "handle");
      var _b = __read(this.selection, 2), min5 = _b[0], max6 = _b[1];
      var style = __assign(__assign({}, handleStyle), { orientation, classNamePrefix });
      var _c = handleStyle.shape, shape = _c === void 0 ? "slider" : _c;
      var HandleCtor = shape === "basic" ? Handle : Handle2;
      var that = this;
      var baseHandleClassName = getLegendClassName(CLASS_NAMES4.handle.name, CLASSNAME_SUFFIX_MAP2.handle, classNamePrefix);
      this.handlesGroup.selectAll(CLASS_NAMES4.handle.class).data(showHandle ? [
        { value: min5, type: "start" },
        { value: max6, type: "end" }
      ] : [], function(d2) {
        return d2.type;
      }).join(function(enter) {
        return enter.append(function() {
          return new HandleCtor({ style, className: baseHandleClassName });
        }).attr("className", function(_a3) {
          var type = _a3.type;
          return "".concat(baseHandleClassName, " ").concat(that.getHandleClassName(type));
        }).each(function(_a3) {
          var type = _a3.type, labelText = _a3.value;
          this.update({ labelText });
          var name = "".concat(type, "Handle");
          that[name] = this;
          this.addEventListener("pointerdown", that.onDragStart(type));
        });
      }, function(update2) {
        return update2.update(style).each(function(_a3) {
          var labelText = _a3.value;
          this.update({ labelText });
        });
      }, function(exit) {
        return exit.each(function(_a3) {
          var type = _a3.type;
          var name = "".concat(type, "Handle");
          that[name] = void 0;
        }).remove();
      });
    };
    Continuous3.prototype.adjustHandles = function() {
      var _a2 = __read(this.selection, 2), min5 = _a2[0], max6 = _a2[1];
      this.setHandlePosition("start", min5);
      this.setHandlePosition("end", max6);
      var _b = this.attributes, classNamePrefix = _b.classNamePrefix, showHandle = _b.showHandle;
      var _c = subStyleProps(this.attributes, "handle").shape, shape = _c === void 0 ? "slider" : _c;
      if (showHandle && shape === "slider" && classNamePrefix) {
        if (this.startHandle)
          this.updateSliderHandleClassNames(this.startHandle, classNamePrefix);
        if (this.endHandle)
          this.updateSliderHandleClassNames(this.endHandle, classNamePrefix);
      }
    };
    Continuous3.prototype.updateSliderHandleClassNames = function(handle, classNamePrefix) {
      var container = handle.container || handle;
      var iconRect = container.querySelector(".handle-icon-rect");
      if (iconRect) {
        var markerClassName = getLegendClassName("handle-icon-rect", CLASSNAME_SUFFIX_MAP2.handleMarker, classNamePrefix);
        iconRect.setAttribute("class", markerClassName);
        var iconLines = iconRect.querySelectorAll("line");
        iconLines.forEach(function(line2) {
          var currentClass = line2.getAttribute("class") || "";
          var baseClass = currentClass.split(" ")[0];
          var markerClassName2 = getLegendClassName(baseClass, CLASSNAME_SUFFIX_MAP2.handleMarker, classNamePrefix);
          line2.setAttribute("class", markerClassName2);
        });
      }
      var label = container.querySelector(".handle-label");
      if (label) {
        var labelClassName = getLegendClassName("handle-label", CLASSNAME_SUFFIX_MAP2.handleLabel, classNamePrefix);
        label.setAttribute("class", labelClassName);
      }
    };
    Object.defineProperty(Continuous3.prototype, "handleBBox", {
      get: function() {
        if (this.cacheHandleBBox)
          return this.cacheHandleBBox;
        if (!this.attributes.showHandle)
          return new BBox(0, 0, 0, 0);
        var _a2 = this.startHandle.getBBox(), startHandleWidth = _a2.width, startHandleHeight = _a2.height;
        var _b = this.endHandle.getBBox(), endHandleWidth = _b.width, endHandleHeight = _b.height;
        var _c = __read([Math.max(startHandleWidth, endHandleWidth), Math.max(startHandleHeight, endHandleHeight)], 2), width = _c[0], height = _c[1];
        this.cacheHandleBBox = new BBox(0, 0, width, height);
        return this.cacheHandleBBox;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "handleShape", {
      /**
       *  因为 handle label 的宽高是动态的，所以 handle bbox 是第一次渲染时的 bbox
       */
      get: function() {
        var _a2 = this.handleBBox, width = _a2.width, height = _a2.height;
        var _b = __read(this.ifHorizontal([height, width], [width, height]), 2), size2 = _b[0], length5 = _b[1];
        return { width, height, size: size2, length: length5 };
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.setHandlePosition = function(type, value) {
      var handleFormatter = this.attributes.handleFormatter;
      var _a2 = this.ribbonBBox, ribbonX = _a2.x, ribbonY = _a2.y;
      var ribbonSize = this.ribbonShape.size;
      var offset = this.getOffset(value);
      var _b = __read(this.ifHorizontal([ribbonX + offset, ribbonY + ribbonSize * this.handleOffsetRatio], [ribbonX + ribbonSize * this.handleOffsetRatio, ribbonY + offset]), 2), x3 = _b[0], y3 = _b[1];
      var handle = this.handlesGroup.select(".".concat(this.getHandleClassName(type))).node();
      handle === null || handle === void 0 ? void 0 : handle.update({ transform: "translate(".concat(x3, ", ").concat(y3, ")"), formatter: handleFormatter });
    };
    Continuous3.prototype.renderIndicator = function(container) {
      var classNamePrefix = this.attributes.classNamePrefix;
      var style = subStyleProps(this.attributes, "indicator");
      var indicatorClassName = getLegendClassName(CLASS_NAMES4.indicator.name, CLASSNAME_SUFFIX_MAP2.indicator, classNamePrefix);
      this.indicator = container.maybeAppendByClassName(CLASS_NAMES4.indicator, function() {
        return new Indicator({
          style,
          className: indicatorClassName
        });
      }).update(style);
    };
    Object.defineProperty(Continuous3.prototype, "labelData", {
      get: function() {
        var _this2 = this;
        var data2 = this.attributes.data;
        return data2.reduce(function(acc, curr, index2, arr) {
          var _a2, _b;
          var id3 = (_a2 = curr === null || curr === void 0 ? void 0 : curr.id) !== null && _a2 !== void 0 ? _a2 : index2.toString();
          acc.push(__assign(__assign({}, curr), { id: id3, index: index2, type: "value", label: (_b = curr === null || curr === void 0 ? void 0 : curr.label) !== null && _b !== void 0 ? _b : curr.value.toString(), value: _this2.ribbonScale.map(curr.value) }));
          if (index2 < arr.length - 1) {
            var next = arr[index2 + 1];
            var _c = __read([curr.value, next.value], 2), cr = _c[0], nx = _c[1];
            var midVal = (cr + nx) / 2;
            acc.push(__assign(__assign({}, curr), { id: id3, index: index2, type: "range", range: [cr, nx], label: [cr, nx].join("~"), value: _this2.ribbonScale.map(midVal) }));
          }
          return acc;
        }, []);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "labelStyle", {
      get: function() {
        var _a2 = __read(["center", "middle"], 2), labelTextAlign = _a2[0], labelTextBaseline = _a2[1];
        var labelPosition = this.labelPosition;
        if (labelPosition === "top")
          labelTextBaseline = "bottom";
        else if (labelPosition === "bottom")
          labelTextBaseline = "top";
        else if (labelPosition === "left")
          labelTextAlign = "end";
        else if (labelPosition === "right")
          labelTextAlign = "start";
        return {
          labelTextAlign,
          labelTextBaseline
        };
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.renderLabel = function(container) {
      var _a2 = this.attributes, _b = _a2.showTick, showTick = _b === void 0 ? false : _b, labelFilter = _a2.labelFilter, labelFormatter2 = _a2.labelFormatter;
      var tickStyle = subStyleProps(this.attributes, "tick");
      var labelStyle = subStyleProps(this.attributes, "label");
      var align = labelStyle.align;
      var style = deepAssign(__assign({ showLine: false, showGrid: false, showTick, type: "linear", startPos: [0, 0], endPos: [0, 0], tickDirection: "negative", labelTransform: "rotate(0)" }, this.labelStyle), superStyleProps(tickStyle, "tick"), superStyleProps(labelStyle, "label"), { data: this.labelData });
      var functionStyle = {
        tickFilter: function(datum, index2, data2) {
          if ((datum === null || datum === void 0 ? void 0 : datum.type) !== "value")
            return false;
          if (labelFilter)
            return labelFilter(datum, datum.index, data2.filter(function(d2) {
              return d2.type !== "value";
            }));
          return true;
        },
        labelFilter: function(datum, index2, data2) {
          if ((datum === null || datum === void 0 ? void 0 : datum.type) !== align)
            return false;
          if (labelFilter)
            return labelFilter(datum, datum.index, data2.filter(function(d2) {
              return d2.type === align;
            }));
          return true;
        },
        labelFormatter: labelFormatter2
      };
      var finalLabelStyle = __assign(__assign(__assign({}, style), functionStyle), { labelOverlap: [{ type: "hide" }] });
      this.label = container.maybeAppendByClassName(CLASS_NAMES4.label, function() {
        return new Axis({ style: finalLabelStyle });
      }).node();
      this.label.update(finalLabelStyle, false);
    };
    Object.defineProperty(Continuous3.prototype, "labelAxisStyle", {
      get: function() {
        var _a2 = this.attributes, showTick = _a2.showTick, labelDirection = _a2.labelDirection, labelSpacing = _a2.labelSpacing, definedTickLength = _a2.tickLength;
        var ribbonSize = this.ribbonShape.size;
        var labelPosition = this.labelPosition;
        var labelFixedSpacing = this.labelFixedSpacing;
        var _b = __read([0, 0, 0], 3), offset = _b[0], spacing = _b[1], tickLength = _b[2];
        var internalVal = definedTickLength !== null && definedTickLength !== void 0 ? definedTickLength : ribbonSize;
        if (showTick) {
          tickLength = internalVal;
          spacing = labelFixedSpacing;
          if (labelDirection === "positive") {
            if (labelPosition === "right") {
              offset = internalVal;
              tickLength = internalVal;
            } else if (labelPosition === "bottom")
              offset = tickLength;
          } else if (labelDirection === "negative") {
            if (labelPosition === "top")
              offset = ribbonSize;
            else if (labelPosition === "left")
              offset = ribbonSize;
          }
        } else if (labelDirection === "positive") {
          if (labelPosition === "right")
            spacing = internalVal;
          else if (labelPosition === "bottom") {
            offset = ribbonSize + labelFixedSpacing;
            spacing = labelSpacing;
          }
        } else if (labelDirection === "negative") {
          if (labelPosition === "left")
            spacing = labelSpacing;
          else if (labelPosition === "top")
            spacing = labelSpacing;
        }
        return { offset, spacing, tickLength };
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.adjustLabel = function() {
      var showLabel = this.attributes.showLabel;
      if (!showLabel)
        return;
      var _a2 = this.ribbonBBox, x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
      var _b = this.labelAxisStyle, axisOffset = _b.offset, axisSpacing = _b.spacing, axisTickLength = _b.tickLength;
      var _c = __read(this.ifHorizontal([
        [x3, y3 + axisOffset],
        [x3 + width, y3 + axisOffset]
      ], [
        [x3 + axisOffset, y3 + height],
        [x3 + axisOffset, y3]
      ]), 2), startPos = _c[0], endPos = _c[1];
      this.label.update({
        startPos,
        endPos,
        tickLength: axisTickLength,
        labelSpacing: axisSpacing
      }, false);
    };
    Continuous3.prototype.bindEvents = function() {
      this.style.cursor = "pointer";
      this.ribbon.on("pointerdown", this.onDragStart("ribbon"));
      this.ribbon.on("pointermove", this.onHovering);
      this.addEventListener("pointerout", this.hideIndicator);
    };
    Continuous3.prototype.showIndicator = function(value, text) {
      if (text === void 0) {
        text = "".concat(value);
      }
      var showIndicator = this.attributes.showIndicator;
      if (!showIndicator || typeof value !== "number") {
        this.hideIndicator();
        return;
      }
      var _a2 = this.range, min5 = _a2.min, max6 = _a2.max;
      var _b = this.ribbonBBox, x3 = _b.x, y3 = _b.y;
      var safeValue = clamp_default(value, min5, max6);
      var offset = this.getOffset(safeValue);
      var pos = this.ifHorizontal([offset + x3, y3], [x3, offset + y3]);
      this.indicator.update({
        x: pos[0],
        y: pos[1],
        position: this.ifHorizontal("top", "left"),
        labelText: text
      });
      show(this.indicator.node());
    };
    Continuous3.prototype.hideIndicator = function() {
      hide(this.indicator.node());
    };
    Continuous3.prototype.updateMouse = function() {
      if (this.attributes.slidable)
        this.style.cursor = "grabbing";
    };
    Continuous3.prototype.setSelection = function(start, end) {
      this.updateSelection(start, end);
    };
    Continuous3.prototype.updateSelection = function(stVal, endVal, isOffset) {
      var _a2;
      if (isOffset === void 0) {
        isOffset = false;
      }
      var _b = __read(this.selection, 2), currSt = _b[0], currEnd = _b[1];
      var _c = __read([stVal, endVal], 2), start = _c[0], end = _c[1];
      if (isOffset) {
        start += currSt;
        end += currEnd;
      }
      var _d = this.range, min5 = _d.min, max6 = _d.max;
      _a2 = __read(getSafetySelections([min5, max6], [start, end], this.selection), 2), start = _a2[0], end = _a2[1];
      this.update({ defaultValue: [start, end] });
      this.dispatchSelection();
    };
    Object.defineProperty(Continuous3.prototype, "step", {
      get: function() {
        var _a2 = this.attributes.step, step2 = _a2 === void 0 ? 1 : _a2;
        var _b = this.range, min5 = _b.min, max6 = _b.max;
        if (is_undefined_default(step2))
          return toPrecision((max6 - min5) * STEP_RATIO, 0);
        return step2;
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.getTickValue = function(value) {
      var _a2 = this.attributes, data2 = _a2.data, block = _a2.block;
      var min5 = this.range.min;
      if (block)
        return getNextTickValue(data2.map(function(_a3) {
          var value2 = _a3.value;
          return value2;
        }), value).tick;
      return getStepValueByValue(value, this.step, min5);
    };
    Continuous3.prototype.getValueByCanvasPoint = function(e) {
      var _a2 = this.range, min5 = _a2.min, max6 = _a2.max;
      var _b = __read(this.ribbon.node().getPosition(), 2), x3 = _b[0], y3 = _b[1];
      var startPos = this.ifHorizontal(x3, y3);
      var currValue = this.ifHorizontal.apply(this, __spreadArray([], __read(getEventPos(e)), false));
      var offset = currValue - startPos;
      var value = clamp_default(this.getOffset(offset, true), min5, max6);
      return value;
    };
    Continuous3.prototype.getOffset = function(value, reverse) {
      if (reverse === void 0) {
        reverse = false;
      }
      var _a2 = this.range, min5 = _a2.min, max6 = _a2.max;
      var ribbonLen = this.ribbonShape.length;
      var scale9 = this.eventToOffsetScale;
      scale9.update({ domain: [min5, max6], range: [0, ribbonLen] });
      if (reverse)
        return scale9.invert(value);
      return scale9.map(value);
    };
    Continuous3.prototype.getRealSelection = function(range) {
      var max6 = this.range.max;
      var _a2 = __read(range, 2), start = _a2[0], end = _a2[1];
      return this.ifHorizontal([start, end], [max6 - end, max6 - start]);
    };
    Continuous3.prototype.getRealValue = function(value) {
      var max6 = this.range.max;
      return this.ifHorizontal(value, max6 - value);
    };
    Continuous3.prototype.dispatchSelection = function() {
      var selection = this.getRealSelection(this.selection);
      var evt = new CustomEvent("valuechange", {
        detail: {
          value: selection
        }
      });
      this.dispatchEvent(evt);
    };
    Continuous3.prototype.dispatchIndicated = function(value, range) {
      var _this2 = this;
      var max6 = this.range.max;
      var detail = this.ifHorizontal(function() {
        return {
          value,
          range
        };
      }, function() {
        return {
          value: max6 - value,
          range: range ? _this2.getRealSelection(range) : void 0
        };
      });
      var evt = new CustomEvent("indicate", {
        detail
      });
      this.dispatchEvent(evt);
    };
    return Continuous3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/tooltip/constant.js
function getClassNames(prefixCls) {
  if (prefixCls === void 0) {
    prefixCls = "";
  }
  return {
    CONTAINER: "".concat(prefixCls, "tooltip"),
    TITLE: "".concat(prefixCls, "tooltip-title"),
    LIST: "".concat(prefixCls, "tooltip-list"),
    LIST_ITEM: "".concat(prefixCls, "tooltip-list-item"),
    NAME: "".concat(prefixCls, "tooltip-list-item-name"),
    MARKER: "".concat(prefixCls, "tooltip-list-item-marker"),
    NAME_LABEL: "".concat(prefixCls, "tooltip-list-item-name-label"),
    VALUE: "".concat(prefixCls, "tooltip-list-item-value"),
    CROSSHAIR_X: "".concat(prefixCls, "tooltip-crosshair-x"),
    CROSSHAIR_Y: "".concat(prefixCls, "tooltip-crosshair-y")
  };
}
var TEXT_OVERFLOW_STYLE = {
  overflow: "hidden",
  "white-space": "nowrap",
  "text-overflow": "ellipsis"
};
function getDefaultTooltipStyle(prefixCls) {
  var _a2;
  if (prefixCls === void 0) {
    prefixCls = "";
  }
  var CLASS_NAME2 = getClassNames(prefixCls);
  return _a2 = {}, _a2[".".concat(CLASS_NAME2.CONTAINER)] = {
    position: "absolute",
    visibility: "visible",
    // 'white-space': 'nowrap',
    "z-index": 8,
    transition: "visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)",
    "background-color": "rgba(255, 255, 255, 0.96)",
    "box-shadow": "0 6px 12px 0 rgba(0, 0, 0, 0.12)",
    "border-radius": "4px",
    color: "rgba(0, 0, 0, 0.65)",
    "font-size": "12px",
    // 'font-family': ,
    "line-height": "20px",
    padding: "12px",
    "min-width": "120px",
    "max-width": "360px",
    "font-family": "Roboto-Regular"
  }, _a2[".".concat(CLASS_NAME2.TITLE)] = {
    color: "rgba(0, 0, 0, 0.45)"
  }, _a2[".".concat(CLASS_NAME2.LIST)] = {
    margin: "0px",
    "list-style-type": "none",
    padding: "0px"
  }, _a2[".".concat(CLASS_NAME2.LIST_ITEM)] = {
    "list-style-type": "none",
    display: "flex",
    "line-height": "2em",
    "align-items": "center",
    "justify-content": "space-between",
    "white-space": "nowrap"
  }, _a2[".".concat(CLASS_NAME2.MARKER)] = {
    width: "8px",
    height: "8px",
    "border-radius": "50%",
    display: "inline-block",
    "margin-right": "4px"
  }, _a2[".".concat(CLASS_NAME2.NAME)] = {
    display: "flex",
    "align-items": "center",
    "max-width": "216px"
  }, _a2[".".concat(CLASS_NAME2.NAME_LABEL)] = __assign({ flex: 1 }, TEXT_OVERFLOW_STYLE), _a2[".".concat(CLASS_NAME2.VALUE)] = __assign({ display: "inline-block", float: "right", flex: 1, "text-align": "right", "min-width": "28px", "margin-left": "30px", color: "rgba(0, 0, 0, 0.85)" }, TEXT_OVERFLOW_STYLE), _a2[".".concat(CLASS_NAME2.CROSSHAIR_X)] = {
    position: "absolute",
    width: "1px",
    "background-color": "rgba(0, 0, 0, 0.25)"
  }, _a2[".".concat(CLASS_NAME2.CROSSHAIR_Y)] = {
    position: "absolute",
    height: "1px",
    "background-color": "rgba(0, 0, 0, 0.25)"
  }, _a2;
}

// node_modules/@antv/component/esm/ui/tooltip/index.js
var Tooltip = (
  /** @class */
  function(_super) {
    __extends(Tooltip2, _super);
    function Tooltip2(options) {
      var _this2 = this;
      var _a2, _b;
      var prefixCls = (_b = (_a2 = options.style) === null || _a2 === void 0 ? void 0 : _a2.template) === null || _b === void 0 ? void 0 : _b.prefixCls;
      var CLASS_NAME2 = getClassNames(prefixCls);
      _this2 = _super.call(this, options, {
        data: [],
        x: 0,
        y: 0,
        visibility: "visible",
        title: "",
        position: "bottom-right",
        offset: [5, 5],
        enterable: false,
        container: {
          x: 0,
          y: 0
        },
        bounding: null,
        template: {
          prefixCls: "",
          container: '<div class="'.concat(CLASS_NAME2.CONTAINER, '"></div>'),
          title: '<div class="'.concat(CLASS_NAME2.TITLE, '"></div>'),
          item: '<li class="'.concat(CLASS_NAME2.LIST_ITEM, '" data-index={index}>\n        <span class="').concat(CLASS_NAME2.NAME, '">\n          <span class="').concat(CLASS_NAME2.MARKER, '" style="background:{color}"></span>\n          <span class="').concat(CLASS_NAME2.NAME_LABEL, '" title="{name}">{name}</span>\n        </span>\n        <span class="').concat(CLASS_NAME2.VALUE, '" title="{value}">{value}</span>\n      </li>')
        },
        style: getDefaultTooltipStyle(prefixCls)
      }) || this;
      _this2.timestamp = -1;
      _this2.prevCustomContentKey = _this2.attributes.contentKey;
      _this2.initShape();
      _this2.render(_this2.attributes, _this2);
      return _this2;
    }
    Object.defineProperty(Tooltip2.prototype, "HTMLTooltipElement", {
      get: function() {
        return this.element;
      },
      enumerable: false,
      configurable: true
    });
    Tooltip2.prototype.getContainer = function() {
      return this.element;
    };
    Object.defineProperty(Tooltip2.prototype, "elementSize", {
      get: function() {
        var width = this.element.offsetWidth;
        var height = this.element.offsetHeight;
        return { width, height };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Tooltip2.prototype, "HTMLTooltipItemsElements", {
      get: function() {
        var _a2 = this.attributes, data2 = _a2.data, template = _a2.template;
        return data2.map(function(_a3, idx) {
          var _b = _a3.name, name = _b === void 0 ? "" : _b, _c = _a3.color, color2 = _c === void 0 ? "black" : _c, index2 = _a3.index, rest = __rest(_a3, ["name", "color", "index"]);
          var datum = __assign({ name, color: color2, index: index2 !== null && index2 !== void 0 ? index2 : idx }, rest);
          return createDOM(substitute_default(template.item, datum));
        });
      },
      enumerable: false,
      configurable: true
    });
    Tooltip2.prototype.render = function(attributes, container) {
      this.renderHTMLTooltipElement();
      this.updatePosition();
    };
    Tooltip2.prototype.destroy = function() {
      var _a2;
      (_a2 = this.element) === null || _a2 === void 0 ? void 0 : _a2.remove();
      _super.prototype.destroy.call(this);
    };
    Tooltip2.prototype.show = function(x3, y3) {
      var _this2 = this;
      if (x3 !== void 0 && y3 !== void 0) {
        var isToggle = this.element.style.visibility === "hidden";
        var setPosition = function() {
          _this2.attributes.x = x3 !== null && x3 !== void 0 ? x3 : _this2.attributes.x;
          _this2.attributes.y = y3 !== null && y3 !== void 0 ? y3 : _this2.attributes.y;
          _this2.updatePosition();
        };
        isToggle ? this.closeTransition(setPosition) : setPosition();
      }
      this.element.style.visibility = "visible";
    };
    Tooltip2.prototype.hide = function(x3, y3) {
      if (x3 === void 0) {
        x3 = 0;
      }
      if (y3 === void 0) {
        y3 = 0;
      }
      var enterable = this.attributes.enterable;
      if (enterable && this.isCursorEntered(x3, y3))
        return;
      this.element.style.visibility = "hidden";
    };
    Tooltip2.prototype.initShape = function() {
      var template = this.attributes.template;
      this.element = createDOM(template.container);
      if (this.id)
        this.element.setAttribute("id", this.id);
    };
    Tooltip2.prototype.renderCustomContent = function() {
      if (this.prevCustomContentKey !== void 0 && this.prevCustomContentKey === this.attributes.contentKey)
        return;
      this.prevCustomContentKey = this.attributes.contentKey;
      var content = this.attributes.content;
      if (!content)
        return;
      if (typeof content === "string")
        this.element.innerHTML = content;
      else
        replaceChildren(this.element, content);
    };
    Tooltip2.prototype.renderHTMLTooltipElement = function() {
      var _a2, _b;
      var _c = this.attributes, template = _c.template, title = _c.title, enterable = _c.enterable, style = _c.style, content = _c.content;
      var CLASS_NAME2 = getClassNames(template.prefixCls);
      var container = this.element;
      this.element.style.pointerEvents = enterable ? "auto" : "none";
      if (content)
        this.renderCustomContent();
      else {
        if (title) {
          container.innerHTML = template.title;
          container.getElementsByClassName(CLASS_NAME2.TITLE)[0].innerHTML = title;
        } else
          (_b = (_a2 = container.getElementsByClassName(CLASS_NAME2.TITLE)) === null || _a2 === void 0 ? void 0 : _a2[0]) === null || _b === void 0 ? void 0 : _b.remove();
        var itemsElements = this.HTMLTooltipItemsElements;
        var ul = document.createElement("ul");
        ul.className = CLASS_NAME2.LIST;
        replaceChildren(ul, itemsElements);
        var list = this.element.querySelector(".".concat(CLASS_NAME2.LIST));
        if (list)
          list.replaceWith(ul);
        else
          container.appendChild(ul);
      }
      applyStyleSheet(container, style);
    };
    Tooltip2.prototype.getRelativeOffsetFromCursor = function(assignPosition) {
      var _a2 = this.attributes, position = _a2.position, offset = _a2.offset;
      var interPosition = assignPosition || position;
      var finalPosition = interPosition.split("-");
      var positionScore = { left: [-1, 0], right: [1, 0], top: [0, -1], bottom: [0, 1] };
      var _b = this.elementSize, width = _b.width, height = _b.height;
      var absolutelyOffset = [-width / 2, -height / 2];
      finalPosition.forEach(function(pos) {
        var _a3 = __read(absolutelyOffset, 2), abs1 = _a3[0], abs2 = _a3[1];
        var _b2 = __read(positionScore[pos], 2), pos1 = _b2[0], pos2 = _b2[1];
        absolutelyOffset = [abs1 + (width / 2 + offset[0]) * pos1, abs2 + (height / 2 + offset[1]) * pos2];
      });
      return absolutelyOffset;
    };
    Tooltip2.prototype.setOffsetPosition = function(_a2) {
      var _b = __read(_a2, 2), offsetX = _b[0], offsetY = _b[1];
      var _c = this.attributes, _d = _c.x, x3 = _d === void 0 ? 0 : _d, _e = _c.y, y3 = _e === void 0 ? 0 : _e, _f = _c.container, cx = _f.x, cy = _f.y;
      this.element.style.left = "".concat(+x3 + cx + offsetX, "px");
      this.element.style.top = "".concat(+y3 + cy + offsetY, "px");
    };
    Tooltip2.prototype.updatePosition = function() {
      var _a2 = this.attributes.showDelay, showDelay = _a2 === void 0 ? 60 : _a2;
      var currentTimestamp = Date.now();
      if (this.timestamp > 0 && currentTimestamp - this.timestamp < showDelay)
        return;
      this.timestamp = currentTimestamp;
      this.setOffsetPosition(this.autoPosition(this.getRelativeOffsetFromCursor()));
    };
    Tooltip2.prototype.autoPosition = function(_a2) {
      var _b = __read(_a2, 2), offsetX = _b[0], offsetY = _b[1];
      var _c = this.attributes, cursorX = _c.x, cursorY = _c.y, bounding = _c.bounding, position = _c.position;
      if (!bounding)
        return [offsetX, offsetY];
      var _d = this.element, offsetWidth = _d.offsetWidth, offsetHeight = _d.offsetHeight;
      var _e = __read([+cursorX + offsetX, +cursorY + offsetY], 2), expectLeft = _e[0], expectTop = _e[1];
      var inversion = {
        left: "right",
        right: "left",
        top: "bottom",
        bottom: "top"
      };
      var boundingX = bounding.x, boundingY = bounding.y, boundingWidth = bounding.width, boundingHeight = bounding.height;
      var edgeCompare = {
        left: expectLeft < boundingX,
        right: expectLeft + offsetWidth > boundingX + boundingWidth,
        top: expectTop < boundingY,
        bottom: expectTop + offsetHeight > boundingY + boundingHeight
      };
      var correctivePosition = [];
      position.split("-").forEach(function(pos) {
        if (edgeCompare[pos])
          correctivePosition.push(inversion[pos]);
        else
          correctivePosition.push(pos);
      });
      var correctedPositionString = correctivePosition.join("-");
      return this.getRelativeOffsetFromCursor(correctedPositionString);
    };
    Tooltip2.prototype.isCursorEntered = function(clientX, clientY) {
      if (this.element) {
        var _a2 = this.element.getBoundingClientRect(), x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
        return new BBox(x3, y3, width, height).isPointIn(clientX, clientY);
      }
      return false;
    };
    Tooltip2.prototype.closeTransition = function(callback) {
      var _this2 = this;
      var transition2 = this.element.style.transition;
      this.element.style.transition = "none";
      callback();
      setTimeout(function() {
        _this2.element.style.transition = transition2;
      }, 10);
    };
    Tooltip2.tag = "tooltip";
    return Tooltip2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/sparkline/columns.js
var Columns = (
  /** @class */
  function(_super) {
    __extends(Columns2, _super);
    function Columns2(_a2) {
      var _this2 = this;
      var style = _a2.style, rest = __rest(_a2, ["style"]);
      _this2 = _super.call(this, deep_mix_default({}, { type: "column" }, __assign({ style }, rest))) || this;
      _this2.columnsGroup = new Group({ name: "columns" });
      _this2.appendChild(_this2.columnsGroup);
      _this2.render();
      return _this2;
    }
    Columns2.prototype.render = function() {
      var _a2 = this.attributes, columns = _a2.columns, x3 = _a2.x, y3 = _a2.y;
      this.columnsGroup.style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
      select(this.columnsGroup).selectAll(".column").data(columns.flat()).join(function(enter) {
        return enter.append("rect").attr("className", "column").each(function(style) {
          this.attr(style);
        });
      }, function(update2) {
        return update2.each(function(style) {
          this.attr(style);
        });
      }, function(exit) {
        return exit.remove();
      });
    };
    Columns2.prototype.update = function(attr2) {
      this.attr(deepAssign({}, this.attributes, attr2));
      this.render();
    };
    Columns2.prototype.clear = function() {
      this.removeChildren();
    };
    return Columns2;
  }(DisplayObject)
);

// node_modules/@antv/component/esm/ui/sparkline/lines.js
var Lines = (
  /** @class */
  function(_super) {
    __extends(Lines2, _super);
    function Lines2(_a2) {
      var _this2 = this;
      var style = _a2.style, rest = __rest(_a2, ["style"]);
      _this2 = _super.call(this, deep_mix_default({}, { type: "lines" }, __assign({ style }, rest))) || this;
      _this2.linesGroup = _this2.appendChild(new Group());
      _this2.areasGroup = _this2.appendChild(new Group());
      _this2.render();
      return _this2;
    }
    Lines2.prototype.render = function() {
      var _a2 = this.attributes, lines = _a2.lines, areas = _a2.areas, x3 = _a2.x, y3 = _a2.y;
      this.style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
      if (lines)
        this.renderLines(lines);
      if (areas)
        this.renderAreas(areas);
    };
    Lines2.prototype.clear = function() {
      this.linesGroup.removeChildren();
      this.areasGroup.removeChildren();
    };
    Lines2.prototype.update = function(attr2) {
      this.attr(deepAssign({}, this.attributes, attr2));
      this.render();
    };
    Lines2.prototype.renderLines = function(lines) {
      select(this.linesGroup).selectAll(".line").data(lines).join(function(enter) {
        return enter.append("path").attr("className", "line").each(function(style) {
          this.attr(style);
        });
      }, function(update2) {
        return update2.each(function(style) {
          this.attr(style);
        });
      }, function(exit) {
        return exit.remove();
      });
    };
    Lines2.prototype.renderAreas = function(areas) {
      select(this.linesGroup).selectAll(".area").data(areas).join(function(enter) {
        return enter.append("path").attr("className", "area").each(function(style) {
          this.attr(style);
        });
      }, function(update2) {
        return update2.each(function(style) {
          this.style(style);
        });
      }, function(exit) {
        return exit.remove();
      });
    };
    return Lines2;
  }(DisplayObject)
);

// node_modules/@antv/component/esm/ui/sparkline/path.js
function dataToLines(data2, scales) {
  var _a2;
  var x3 = scales.x, y3 = scales.y;
  var _b = __read(y3.getOptions().range || [0, 0], 2), max6 = _b[0], min5 = _b[1];
  if (min5 > max6)
    _a2 = __read([max6, min5], 2), min5 = _a2[0], max6 = _a2[1];
  return data2.map(function(points) {
    var lines = points.map(function(val, idx) {
      return [x3.map(idx), clamp_default(y3.map(val), min5, max6)];
    });
    return lines;
  });
}
function lineToLinePath(line2, reverse) {
  if (reverse === void 0) {
    reverse = false;
  }
  var M = reverse ? line2.length - 1 : 0;
  var linePath = line2.map(function(point2, idx) {
    return __spreadArray([idx === M ? "M" : "L"], __read(point2), false);
  });
  return reverse ? linePath.reverse() : linePath;
}
function lineToCurvePath(line2, reverse) {
  if (reverse === void 0) {
    reverse = false;
  }
  if (line2.length <= 2) {
    return lineToLinePath(line2);
  }
  var data2 = [];
  var len5 = line2.length;
  for (var idx = 0; idx < len5; idx += 1) {
    var point2 = reverse ? line2[len5 - idx - 1] : line2[idx];
    if (!is_equal_default(point2, data2.slice(-2))) {
      data2.push.apply(data2, __spreadArray([], __read(point2), false));
    }
  }
  var path = catmullRom2Bezier(data2, false);
  if (reverse) {
    path.unshift(__spreadArray(["M"], __read(line2[len5 - 1]), false));
  } else {
    path.unshift(__spreadArray(["M"], __read(line2[0]), false));
  }
  return path;
}
function closePathByBaseLine(path, width, baseline) {
  var closedPath = clone_default(path);
  closedPath.push(["L", width, baseline], ["L", 0, baseline], ["Z"]);
  return closedPath;
}
function linesToAreaPaths(lines, smooth2, width, baseline) {
  return lines.map(function(line2) {
    return closePathByBaseLine(smooth2 ? lineToCurvePath(line2) : lineToLinePath(line2), width, baseline);
  });
}
function linesToStackAreaPaths(lines, width, baseline) {
  var paths = [];
  for (var idx = lines.length - 1; idx >= 0; idx -= 1) {
    var currLine = lines[idx];
    var currCurvePath = lineToLinePath(currLine);
    var path = void 0;
    if (idx === 0) {
      path = closePathByBaseLine(currCurvePath, width, baseline);
    } else {
      var belowLine = lines[idx - 1];
      var belowCurvePath = lineToLinePath(belowLine, true);
      belowCurvePath[0][0] = "L";
      path = __spreadArray(__spreadArray(__spreadArray([], __read(currCurvePath), false), __read(belowCurvePath), false), [["Z"]], false);
    }
    paths.push(path);
  }
  return paths;
}
function linesToStackCurveAreaPaths(lines, width, baseline) {
  var paths = [];
  for (var idx = lines.length - 1; idx >= 0; idx -= 1) {
    var currLine = lines[idx];
    var currCurvePath = lineToCurvePath(currLine);
    var path = void 0;
    if (idx === 0) {
      path = closePathByBaseLine(currCurvePath, width, baseline);
    } else {
      var belowLine = lines[idx - 1];
      var belowCurvePath = lineToCurvePath(belowLine, true);
      var A3 = currLine[0];
      belowCurvePath[0][0] = "L";
      path = __spreadArray(__spreadArray(__spreadArray([], __read(currCurvePath), false), __read(belowCurvePath), false), [__spreadArray(["M"], __read(A3), false), ["Z"]], false);
    }
    paths.push(path);
  }
  return paths;
}

// node_modules/@antv/component/esm/ui/sparkline/utils.js
function getRange(data2) {
  if (data2.length === 0)
    return [0, 0];
  return [
    min_default(min_by_default(data2, function(arr) {
      return min_default(arr) || 0;
    })),
    max(max_by_default(data2, function(arr) {
      return max(arr) || 0;
    }))
  ];
}
function getStackedData(_2) {
  var data2 = clone_default(_2);
  var datumLen = data2[0].length;
  var _a2 = __read([Array(datumLen).fill(0), Array(datumLen).fill(0)], 2), positivePrev = _a2[0], negativePrev = _a2[1];
  for (var i = 0; i < data2.length; i += 1) {
    var datum = data2[i];
    for (var j = 0; j < datumLen; j += 1) {
      if (datum[j] >= 0) {
        datum[j] += positivePrev[j];
        positivePrev[j] = datum[j];
      } else {
        datum[j] += negativePrev[j];
        negativePrev[j] = datum[j];
      }
    }
  }
  return data2;
}

// node_modules/@antv/component/esm/ui/sparkline/index.js
var Sparkline = (
  /** @class */
  function(_super) {
    __extends(Sparkline2, _super);
    function Sparkline2(options) {
      return _super.call(this, options, {
        type: "line",
        x: 0,
        y: 0,
        width: 200,
        height: 20,
        isStack: false,
        color: ["#83daad", "#edbf45", "#d2cef9", "#e290b3", "#6f63f4"],
        smooth: true,
        lineLineWidth: 1,
        areaOpacity: 0,
        isGroup: false,
        columnLineWidth: 1,
        columnStroke: "#fff",
        scale: 1,
        spacing: 0
      }) || this;
    }
    Object.defineProperty(Sparkline2.prototype, "rawData", {
      /**
       * 将data统一格式化为数组形式
       * 如果堆叠，则生成堆叠数据
       */
      get: function() {
        var rawData = this.attributes.data;
        if (!rawData || (rawData === null || rawData === void 0 ? void 0 : rawData.length) === 0)
          return [[]];
        var data2 = clone_default(rawData);
        return isNumber(data2[0]) ? [data2] : data2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "data", {
      get: function() {
        if (this.attributes.isStack)
          return getStackedData(this.rawData);
        return this.rawData;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "scales", {
      get: function() {
        return this.createScales(this.data);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "baseline", {
      /**
       * 基准线，默认为 0
       */
      get: function() {
        var y3 = this.scales.y;
        var _a2 = __read(y3.getOptions().domain || [0, 0], 2), y1 = _a2[0], y22 = _a2[1];
        if (y22 < 0) {
          return y3.map(y22);
        }
        return y3.map(y1 < 0 ? 0 : y1);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "containerShape", {
      get: function() {
        var _a2 = this.attributes, width = _a2.width, height = _a2.height;
        return { width, height };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "linesStyle", {
      get: function() {
        var _this2 = this;
        var _a2 = this.attributes, type = _a2.type, isStack = _a2.isStack, smooth2 = _a2.smooth;
        if (type !== "line")
          throw new Error("linesStyle can only be used in line type");
        var areaStyle = subStyleProps(this.attributes, "area");
        var lineStyle = subStyleProps(this.attributes, "line");
        var width = this.containerShape.width;
        var data2 = this.data;
        if (data2[0].length === 0)
          return { lines: [], areas: [] };
        var _b = this.scales, x3 = _b.x, y3 = _b.y;
        var lines = dataToLines(data2, { type: "line", x: x3, y: y3 });
        var areas = [];
        if (areaStyle) {
          var baseline = this.baseline;
          if (isStack) {
            areas = smooth2 ? linesToStackCurveAreaPaths(lines, width, baseline) : linesToStackAreaPaths(lines, width, baseline);
          } else {
            areas = linesToAreaPaths(lines, smooth2, width, baseline);
          }
        }
        return {
          lines: lines.map(function(line2, idx) {
            return __assign({ stroke: _this2.getColor(idx), d: smooth2 ? lineToCurvePath(line2) : lineToLinePath(line2) }, lineStyle);
          }),
          areas: areas.map(function(path, idx) {
            return __assign({ d: path, fill: _this2.getColor(idx) }, areaStyle);
          })
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "columnsStyle", {
      get: function() {
        var _this2 = this;
        var columnStyle = subStyleProps(this.attributes, "column");
        var _a2 = this.attributes, isStack = _a2.isStack, type = _a2.type, scale9 = _a2.scale;
        if (type !== "column")
          throw new Error("columnsStyle can only be used in column type");
        var height = this.containerShape.height;
        var data2 = this.rawData;
        if (!data2)
          return { columns: [] };
        if (isStack)
          data2 = getStackedData(data2);
        var _b = this.createScales(data2), x3 = _b.x, y3 = _b.y;
        var _c = __read(getRange(data2), 2), minVal = _c[0], maxVal = _c[1];
        var heightScale = new Linear({
          domain: [0, maxVal - (minVal > 0 ? 0 : minVal)],
          range: [0, height * scale9]
        });
        var bandWidth = x3.getBandWidth();
        var rawData = this.rawData;
        return {
          columns: data2.map(function(column, i) {
            return column.map(function(val, j) {
              var barWidth = bandWidth / data2.length;
              var getShape2 = function() {
                return {
                  x: x3.map(j) + barWidth * i,
                  y: val >= 0 ? y3.map(val) : y3.map(0),
                  width: barWidth,
                  height: heightScale.map(Math.abs(val))
                };
              };
              var getStackShape = function() {
                return {
                  x: x3.map(j),
                  y: y3.map(val),
                  width: bandWidth,
                  height: heightScale.map(rawData[i][j])
                };
              };
              return __assign(__assign({ fill: _this2.getColor(i) }, columnStyle), isStack ? getStackShape() : getShape2());
            });
          })
        };
      },
      enumerable: false,
      configurable: true
    });
    Sparkline2.prototype.render = function(attributes, container) {
      maybeAppend(container, ".container", "rect").attr("className", "container").node();
      var type = attributes.type, x3 = attributes.x, y3 = attributes.y;
      var className = "spark".concat(type);
      var style = __assign({ x: x3, y: y3 }, type === "line" ? this.linesStyle : this.columnsStyle);
      select(container).selectAll(".spark").data([type]).join(function(enter) {
        return enter.append(function(type2) {
          if (type2 === "line")
            return new Lines({ className, style });
          return new Columns({ className, style });
        }).attr("className", "spark ".concat(className));
      }, function(update2) {
        return update2.update(style);
      }, function(exit) {
        return exit.remove();
      });
    };
    Sparkline2.prototype.getColor = function(index2) {
      var color2 = this.attributes.color;
      if (isArray(color2)) {
        return color2[index2 % color2.length];
      }
      if (isFunction(color2)) {
        return color2.call(null, index2);
      }
      return color2;
    };
    Sparkline2.prototype.createScales = function(data2) {
      var _a2, _b;
      var _c = this.attributes, type = _c.type, scale9 = _c.scale, _d = _c.range, range = _d === void 0 ? [] : _d, spacing = _c.spacing;
      var _e = this.containerShape, width = _e.width, height = _e.height;
      var _f = __read(getRange(data2), 2), minVal = _f[0], maxVal = _f[1];
      var yScale = new Linear({
        domain: [(_a2 = range[0]) !== null && _a2 !== void 0 ? _a2 : minVal, (_b = range[1]) !== null && _b !== void 0 ? _b : maxVal],
        range: [height, height * (1 - scale9)]
      });
      if (type === "line") {
        return {
          type,
          x: new Linear({
            domain: [0, data2[0].length - 1],
            range: [0, width]
          }),
          y: yScale
        };
      }
      return {
        type,
        x: new Band({
          domain: data2[0].map(function(val, idx) {
            return idx;
          }),
          range: [0, width],
          paddingInner: spacing,
          paddingOuter: spacing / 2,
          align: 0.5
        }),
        y: yScale
      };
    };
    Sparkline2.tag = "sparkline";
    return Sparkline2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/slider/index.js
var Slider = (
  /** @class */
  function(_super) {
    __extends(Slider2, _super);
    function Slider2(options) {
      var _this2 = _super.call(this, options, __assign(__assign(__assign({ x: 0, y: 0, animate: { duration: 100, fill: "both" }, brushable: true, formatter: function(val) {
        return val.toString();
      }, handleSpacing: 2, orientation: "horizontal", padding: 0, autoFitLabel: true, scrollable: true, selectionFill: "#5B8FF9", selectionFillOpacity: 0.45, selectionZIndex: 2, showHandle: true, showLabel: true, slidable: true, trackFill: "#416180", trackLength: 200, trackOpacity: 0.05, trackSize: 20, trackZIndex: -1, values: [0, 1], type: "range", selectionType: "select", handleIconOffset: 0 }, superStyleProps(HANDLE_DEFAULT_CFG, "handle")), superStyleProps(HANDLE_ICON_DEFAULT_CFG, "handleIcon")), superStyleProps(HANDLE_LABEL_DEFAULT_CFG, "handleLabel"))) || this;
      _this2.range = [0, 1];
      _this2.onDragStart = function(target) {
        return function(e) {
          e.stopPropagation();
          _this2.target = target;
          _this2.prevPos = _this2.getOrientVal(getEventViewportPos(e));
          var _a2 = _this2.availableSpace, x3 = _a2.x, y3 = _a2.y;
          var _b = _this2.getBBox(), X = _b.x, Y = _b.y;
          _this2.selectionStartPos = _this2.getRatio(_this2.prevPos - _this2.getOrientVal([x3, y3]) - _this2.getOrientVal([+X, +Y]));
          _this2.selectionWidth = 0;
          document.addEventListener("pointermove", _this2.onDragging);
          document.addEventListener("pointerup", _this2.onDragEnd);
        };
      };
      _this2.onDragging = function(e) {
        var _a2 = _this2.attributes, slidable = _a2.slidable, brushable = _a2.brushable, type = _a2.type;
        e.stopPropagation();
        var currPos = _this2.getOrientVal(getEventViewportPos(e));
        var diffPos = currPos - _this2.prevPos;
        if (!diffPos)
          return;
        var deltaVal = _this2.getRatio(diffPos);
        switch (_this2.target) {
          case "start":
            if (slidable)
              _this2.setValuesOffset(deltaVal);
            break;
          case "end":
            if (slidable)
              _this2.setValuesOffset(0, deltaVal);
            break;
          case "selection":
            if (slidable)
              _this2.setValuesOffset(deltaVal, deltaVal);
            break;
          case "track":
            if (!brushable)
              return;
            _this2.selectionWidth += deltaVal;
            if (type === "range") {
              _this2.innerSetValues([_this2.selectionStartPos, _this2.selectionStartPos + _this2.selectionWidth].sort(), true);
            } else
              _this2.innerSetValues([0, _this2.selectionStartPos + _this2.selectionWidth], true);
            break;
          default:
            break;
        }
        _this2.prevPos = currPos;
      };
      _this2.onDragEnd = function() {
        document.removeEventListener("pointermove", _this2.onDragging);
        document.removeEventListener("pointermove", _this2.onDragging);
        document.removeEventListener("pointerup", _this2.onDragEnd);
        _this2.target = "";
        _this2.updateHandlesPosition(false);
      };
      _this2.onValueChange = function(oldValue) {
        var _a2 = _this2.attributes, onChange = _a2.onChange, type = _a2.type;
        var internalOldValue = type === "range" ? oldValue : oldValue[1];
        var value = type === "range" ? _this2.getValues() : _this2.getValues()[1];
        var evt = new CustomEvent("valuechange", {
          detail: { oldValue: internalOldValue, value }
        });
        _this2.dispatchEvent(evt);
        onChange === null || onChange === void 0 ? void 0 : onChange(value);
      };
      _this2.selectionStartPos = 0;
      _this2.selectionWidth = 0;
      _this2.prevPos = 0;
      _this2.target = "";
      return _this2;
    }
    Object.defineProperty(Slider2.prototype, "values", {
      get: function() {
        return this.attributes.values;
      },
      set: function(values) {
        this.attributes.values = this.clampValues(values);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Slider2.prototype, "sparklineStyle", {
      get: function() {
        var orientation = this.attributes.orientation;
        if (orientation !== "horizontal")
          return null;
        var attr2 = subStyleProps(this.attributes, "sparkline");
        return __assign(__assign({ zIndex: 0 }, this.availableSpace), attr2);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Slider2.prototype, "shape", {
      get: function() {
        var _a2 = this.attributes, trackLength = _a2.trackLength, trackSize = _a2.trackSize;
        var _b = __read(this.getOrientVal([
          [trackLength, trackSize],
          [trackSize, trackLength]
        ]), 2), width = _b[0], height = _b[1];
        return { width, height };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Slider2.prototype, "availableSpace", {
      get: function() {
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, padding = _a2.padding;
        var _b = __read(parseSeriesAttr(padding), 4), top = _b[0], right = _b[1], bottom = _b[2], left = _b[3];
        var _c = this.shape, width = _c.width, height = _c.height;
        return {
          x: left,
          y: top,
          width: width - (left + right),
          height: height - (top + bottom)
        };
      },
      enumerable: false,
      configurable: true
    });
    Slider2.prototype.getValues = function() {
      return this.values;
    };
    Slider2.prototype.setValues = function(values, animate2) {
      if (values === void 0) {
        values = [0, 0];
      }
      if (animate2 === void 0) {
        animate2 = false;
      }
      this.attributes.values = values;
      var animation = animate2 === false ? false : this.attributes.animate;
      this.updateSelectionArea(animation);
      this.updateHandlesPosition(animation);
    };
    Slider2.prototype.updateSelectionArea = function(animation) {
      var newSelectionArea = this.calcSelectionArea();
      this.foregroundGroup.selectAll(CLASS_NAMES10.selection.class).each(function(datum, index2) {
        transition(this, newSelectionArea[index2], animation);
      });
    };
    Slider2.prototype.updateHandlesPosition = function(animation) {
      if (!this.attributes.showHandle)
        return;
      this.startHandle && transition(this.startHandle, this.getHandleStyle("start"), animation);
      this.endHandle && transition(this.endHandle, this.getHandleStyle("end"), animation);
    };
    Slider2.prototype.innerSetValues = function(values, trigger) {
      if (values === void 0) {
        values = [0, 0];
      }
      if (trigger === void 0) {
        trigger = false;
      }
      var oldValues = this.values;
      var newValues = this.clampValues(values);
      this.attributes.values = newValues;
      this.setValues(newValues);
      if (trigger) {
        this.onValueChange(oldValues);
      }
    };
    Slider2.prototype.renderTrack = function(container) {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y;
      var style = subStyleProps(this.attributes, "track");
      this.trackShape = select(container).maybeAppendByClassName(CLASS_NAMES10.track, "rect").styles(__assign(__assign({ x: x3, y: y3 }, this.shape), style));
    };
    Slider2.prototype.renderBrushArea = function(container) {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, brushable = _a2.brushable;
      this.brushArea = select(container).maybeAppendByClassName(CLASS_NAMES10.brushArea, "rect").styles(__assign({ x: x3, y: y3, fill: "transparent", cursor: brushable ? "crosshair" : "default" }, this.shape));
    };
    Slider2.prototype.renderSparkline = function(container) {
      var _this2 = this;
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, orientation = _a2.orientation;
      var sparklineGroup = select(container).maybeAppendByClassName(CLASS_NAMES10.sparklineGroup, "g");
      ifShow(orientation === "horizontal", sparklineGroup, function(group2) {
        var style = __assign(__assign({}, _this2.sparklineStyle), { x: x3, y: y3 });
        group2.maybeAppendByClassName(CLASS_NAMES10.sparkline, function() {
          return new Sparkline({ style });
        }).update(style);
      });
    };
    Slider2.prototype.renderHandles = function() {
      var _this2 = this;
      var _a2;
      var _b = this.attributes, showHandle = _b.showHandle, type = _b.type;
      var availableHandle = type === "range" ? ["start", "end"] : ["end"];
      var data2 = showHandle ? availableHandle : [];
      var that = this;
      (_a2 = this.foregroundGroup) === null || _a2 === void 0 ? void 0 : _a2.selectAll(CLASS_NAMES10.handle.class).data(data2.map(function(type2) {
        return { type: type2 };
      }), function(d2) {
        return d2.type;
      }).join(function(enter) {
        return enter.append(function(_a3) {
          var type2 = _a3.type;
          return new Handle2({ style: _this2.getHandleStyle(type2) });
        }).each(function(_a3) {
          var type2 = _a3.type;
          this.attr("class", "".concat(CLASS_NAMES10.handle.name, " ").concat(type2, "-handle"));
          var name = "".concat(type2, "Handle");
          that[name] = this;
          this.addEventListener("pointerdown", that.onDragStart(type2));
        });
      }, function(update2) {
        return update2.each(function(_a3) {
          var type2 = _a3.type;
          this.update(that.getHandleStyle(type2));
        });
      }, function(exit) {
        return exit.each(function(_a3) {
          var type2 = _a3.type;
          var name = "".concat(type2, "Handle");
          that[name] = void 0;
        }).remove();
      });
    };
    Slider2.prototype.renderSelection = function(container) {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, type = _a2.type, selectionType = _a2.selectionType;
      this.foregroundGroup = select(container).maybeAppendByClassName(CLASS_NAMES10.foreground, "g");
      var selectionStyle = subStyleProps(this.attributes, "selection");
      var applyStyle = function(selection) {
        return selection.style("visibility", function(d2) {
          return d2.show ? "visible" : "hidden";
        }).style("cursor", function(d2) {
          if (selectionType === "select")
            return "grab";
          if (selectionType === "invert")
            return "crosshair";
          return "default";
        }).styles(__assign(__assign({}, selectionStyle), { transform: "translate(".concat(x3, ", ").concat(y3, ")") }));
      };
      var that = this;
      this.foregroundGroup.selectAll(CLASS_NAMES10.selection.class).data(type === "value" ? [] : this.calcSelectionArea().map(function(area, index2) {
        return {
          style: __assign({}, area),
          index: index2,
          // 是否可见
          show: selectionType === "select" ? index2 === 1 : index2 !== 1
        };
      }), function(d2) {
        return d2.index;
      }).join(function(enter) {
        return enter.append("rect").attr("className", CLASS_NAMES10.selection.name).call(applyStyle).each(function(datum, index2) {
          var _this2 = this;
          if (index2 === 1) {
            that.selectionShape = select(this);
            this.on("pointerdown", function(e) {
              _this2.attr("cursor", "grabbing");
              that.onDragStart("selection")(e);
            });
            that.dispatchCustomEvent(this, "pointerenter", "selectionMouseenter");
            that.dispatchCustomEvent(this, "pointerleave", "selectionMouseleave");
            that.dispatchCustomEvent(this, "click", "selectionClick");
            this.addEventListener("pointerdown", function() {
              _this2.attr("cursor", "grabbing");
            });
            this.addEventListener("pointerup", function() {
              _this2.attr("cursor", "pointer");
            });
            this.addEventListener("pointerover", function() {
              _this2.attr("cursor", "pointer");
            });
          } else {
            this.on("pointerdown", that.onDragStart("track"));
          }
        });
      }, function(update2) {
        return update2.call(applyStyle);
      }, function(exit) {
        return exit.remove();
      });
      this.updateSelectionArea(false);
      this.renderHandles();
    };
    Slider2.prototype.render = function(attributes, container) {
      this.renderTrack(container);
      this.renderSparkline(container);
      this.renderBrushArea(container);
      this.renderSelection(container);
    };
    Slider2.prototype.clampValues = function(values, precision) {
      var _a2;
      if (precision === void 0) {
        precision = 4;
      }
      var _b = __read(this.range, 2), min5 = _b[0], max6 = _b[1];
      var _c = __read(this.getValues().map(function(num) {
        return toPrecision(num, precision);
      }), 2), prevStart = _c[0], prevEnd = _c[1];
      var internalValues = Array.isArray(values) ? values : [prevStart, values !== null && values !== void 0 ? values : prevEnd];
      var _d = __read((internalValues || [prevStart, prevEnd]).map(function(num) {
        return toPrecision(num, precision);
      }), 2), startVal = _d[0], endVal = _d[1];
      if (this.attributes.type === "value")
        return [0, clamp_default(endVal, min5, max6)];
      if (startVal > endVal) {
        _a2 = __read([endVal, startVal], 2), startVal = _a2[0], endVal = _a2[1];
      }
      var range = endVal - startVal;
      if (range > max6 - min5)
        return [min5, max6];
      if (startVal < min5) {
        if (prevStart === min5 && prevEnd === endVal)
          return [min5, endVal];
        return [min5, range + min5];
      }
      if (endVal > max6) {
        if (prevEnd === max6 && prevStart === startVal)
          return [startVal, max6];
        return [max6 - range, max6];
      }
      return [startVal, endVal];
    };
    Slider2.prototype.calcSelectionArea = function(values) {
      var _a2 = __read(this.clampValues(values), 2), start = _a2[0], end = _a2[1];
      var _b = this.availableSpace, x3 = _b.x, y3 = _b.y, width = _b.width, height = _b.height;
      return this.getOrientVal([
        [
          { y: y3, height, x: x3, width: start * width },
          { y: y3, height, x: start * width + x3, width: (end - start) * width },
          { y: y3, height, x: end * width, width: (1 - end) * width }
        ],
        [
          { x: x3, width, y: y3, height: start * height },
          { x: x3, width, y: start * height + y3, height: (end - start) * height },
          { x: x3, width, y: end * height, height: (1 - end) * height }
        ]
      ]);
    };
    Slider2.prototype.calcHandlePosition = function(handleType) {
      var handleIconOffset = this.attributes.handleIconOffset;
      var _a2 = this.availableSpace, x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
      var _b = __read(this.clampValues(), 2), stVal = _b[0], endVal = _b[1];
      var offset = handleType === "start" ? -handleIconOffset : handleIconOffset;
      var L = (handleType === "start" ? stVal : endVal) * this.getOrientVal([width, height]) + offset;
      return {
        x: x3 + this.getOrientVal([L, width / 2]),
        y: y3 + this.getOrientVal([height / 2, L])
      };
    };
    Slider2.prototype.inferTextStyle = function(handleType) {
      var orientation = this.attributes.orientation;
      if (orientation === "horizontal")
        return {};
      if (handleType === "start")
        return { transformOrigin: "left center", transform: "rotate(90)", textAlign: "start" };
      if (handleType === "end")
        return { transformOrigin: "right center", transform: "rotate(90)", textAlign: "end" };
      return {};
    };
    Slider2.prototype.calcHandleText = function(handleType) {
      var _a2;
      var _b = this.attributes, type = _b.type, orientation = _b.orientation, formatter2 = _b.formatter, autoFitLabel = _b.autoFitLabel;
      var handleStyle = subStyleProps(this.attributes, "handle");
      var labelStyle = subStyleProps(handleStyle, "label");
      var spacing = handleStyle.spacing;
      var size2 = this.getHandleSize();
      var values = this.clampValues();
      var value = handleType === "start" ? values[0] : values[1];
      var text = formatter2(value);
      var temp = new Text2({
        style: __assign(__assign(__assign({}, labelStyle), this.inferTextStyle(handleType)), { text })
      });
      var _c = temp.getBBox(), textWidth = _c.width, textHeight = _c.height;
      temp.destroy();
      if (!autoFitLabel) {
        if (type === "value")
          return { text, x: 0, y: -textHeight - spacing };
        var finaleWidth = spacing + size2 + (orientation === "horizontal" ? textWidth / 2 : 0);
        return _a2 = { text }, _a2[orientation === "horizontal" ? "x" : "y"] = handleType === "start" ? -finaleWidth : finaleWidth, _a2;
      }
      var x3 = 0;
      var y3 = 0;
      var _d = this.availableSpace, iW = _d.width, iH = _d.height;
      var _e = this.calcSelectionArea()[1], fX = _e.x, fY = _e.y, fW = _e.width, fH = _e.height;
      var totalSpacing = spacing + size2;
      if (orientation === "horizontal") {
        var finalWidth = totalSpacing + textWidth / 2;
        if (handleType === "start") {
          var left = fX - totalSpacing - textWidth;
          x3 = left > 0 ? -finalWidth : finalWidth;
        } else {
          var sign = iW - fX - fW - totalSpacing > textWidth;
          x3 = sign ? finalWidth : -finalWidth;
        }
      } else {
        var positiveSize = totalSpacing;
        var negativeSize = textHeight + totalSpacing;
        if (handleType === "start") {
          y3 = fY - size2 > textHeight ? -negativeSize : positiveSize;
        } else {
          y3 = iH - (fY + fH) - size2 > textHeight ? negativeSize : -positiveSize;
        }
      }
      return { x: x3, y: y3, text };
    };
    Slider2.prototype.getHandleLabelStyle = function(handleType) {
      var style = subStyleProps(this.attributes, "handleLabel");
      return __assign(__assign(__assign({}, style), this.calcHandleText(handleType)), this.inferTextStyle(handleType));
    };
    Slider2.prototype.getHandleIconStyle = function() {
      var shape = this.attributes.handleIconShape;
      var style = subStyleProps(this.attributes, "handleIcon");
      var cursor = this.getOrientVal(["ew-resize", "ns-resize"]);
      var size2 = this.getHandleSize();
      return __assign({ cursor, shape, size: size2 }, style);
    };
    Slider2.prototype.getHandleStyle = function(handleType) {
      var _a2 = this.attributes, ox = _a2.x, oy = _a2.y, showLabel = _a2.showLabel, showLabelOnInteraction = _a2.showLabelOnInteraction, orientation = _a2.orientation;
      var _b = this.calcHandlePosition(handleType), x3 = _b.x, y3 = _b.y;
      var textStyle = this.calcHandleText(handleType);
      var internalShowLabel = showLabel;
      if (!showLabel && showLabelOnInteraction) {
        if (this.target)
          internalShowLabel = true;
        else
          internalShowLabel = false;
      }
      return __assign(__assign(__assign({}, superStyleProps(this.getHandleIconStyle(), "icon")), superStyleProps(__assign(__assign({}, this.getHandleLabelStyle(handleType)), textStyle), "label")), { transform: "translate(".concat(x3 + ox, ", ").concat(y3 + oy, ")"), orientation, showLabel: internalShowLabel, type: handleType, zIndex: 3 });
    };
    Slider2.prototype.getHandleSize = function() {
      var _a2 = this.attributes, size2 = _a2.handleIconSize, width = _a2.width, height = _a2.height;
      if (size2)
        return size2;
      return Math.floor((this.getOrientVal([+height, +width]) + 4) / 2.4);
    };
    Slider2.prototype.getOrientVal = function(_a2) {
      var _b = __read(_a2, 2), x3 = _b[0], y3 = _b[1];
      var orientation = this.attributes.orientation;
      return orientation === "horizontal" ? x3 : y3;
    };
    Slider2.prototype.setValuesOffset = function(stOffset, endOffset) {
      if (endOffset === void 0) {
        endOffset = 0;
      }
      var type = this.attributes.type;
      var _a2 = __read(this.getValues(), 2), oldStartVal = _a2[0], oldEndVal = _a2[1];
      var internalStartOffset = type === "range" ? stOffset : 0;
      var values = [oldStartVal + internalStartOffset, oldEndVal + endOffset].sort();
      this.innerSetValues(values, true);
    };
    Slider2.prototype.getRatio = function(val) {
      var _a2 = this.availableSpace, width = _a2.width, height = _a2.height;
      return val / this.getOrientVal([width, height]);
    };
    Slider2.prototype.dispatchCustomEvent = function(target, event, name) {
      var _this2 = this;
      target.on(event, function(e) {
        e.stopPropagation();
        _this2.dispatchEvent(new CustomEvent(name, { detail: e }));
      });
    };
    Slider2.prototype.bindEvents = function() {
      this.addEventListener("wheel", this.onScroll);
      var brushArea = this.brushArea;
      this.dispatchCustomEvent(brushArea, "click", "trackClick");
      this.dispatchCustomEvent(brushArea, "pointerenter", "trackMouseenter");
      this.dispatchCustomEvent(brushArea, "pointerleave", "trackMouseleave");
      brushArea.on("pointerdown", this.onDragStart("track"));
    };
    Slider2.prototype.onScroll = function(event) {
      var scrollable = this.attributes.scrollable;
      if (scrollable) {
        var deltaX = event.deltaX, deltaY = event.deltaY;
        var offset = deltaY || deltaX;
        var deltaVal = this.getRatio(offset);
        this.setValuesOffset(deltaVal, deltaVal);
      }
    };
    Slider2.tag = "slider";
    return Slider2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/select/option.js
var Option = (
  /** @class */
  function(_super) {
    __extends(Option2, _super);
    function Option2(options) {
      var _this2 = _super.call(this, deepAssign({}, Option2.defaultOptions, options)) || this;
      _this2.hoverColor = "#f5f5f5";
      _this2.selectedColor = "#e6f7ff";
      _this2.background = _this2.appendChild(new Rect({}));
      _this2.label = _this2.background.appendChild(new Group({}));
      return _this2;
    }
    Object.defineProperty(Option2.prototype, "padding", {
      get: function() {
        return parseSeriesAttr(this.style.padding);
      },
      enumerable: false,
      configurable: true
    });
    Option2.prototype.renderLabel = function() {
      var _a2 = this.style, label = _a2.label, value = _a2.value;
      var labelStyle = subStyleProps(this.attributes, "label");
      select(this.label).maybeAppend(".label", function() {
        return renderExtDo(label);
      }).attr("className", "label").styles(labelStyle);
      this.label.attr("__data__", value);
    };
    Option2.prototype.renderBackground = function() {
      var labelBBox = this.label.getBBox();
      var _a2 = __read(this.padding, 4), top = _a2[0], right = _a2[1], bottom = _a2[2], left = _a2[3];
      var labelWidth = labelBBox.width, labelHeight = labelBBox.height;
      var backgroundWidth = labelWidth + left + right;
      var backgroundHeight = labelHeight + top + bottom;
      var backgroundStyle = subStyleProps(this.attributes, "background");
      var _b = this.style, _c = _b.width, styleWidth = _c === void 0 ? 0 : _c, _d = _b.height, styleHeight = _d === void 0 ? 0 : _d, selected = _b.selected;
      this.background.attr(__assign(__assign({}, backgroundStyle), { width: Math.max(backgroundWidth, styleWidth), height: Math.max(backgroundHeight, styleHeight), fill: selected ? this.selectedColor : "#fff" }));
      this.label.attr({ transform: "translate(".concat(left, ", ").concat((backgroundHeight - labelHeight) / 2, ")") });
    };
    Option2.prototype.render = function() {
      this.renderLabel();
      this.renderBackground();
    };
    Option2.prototype.bindEvents = function() {
      var _this2 = this;
      this.addEventListener("pointerenter", function() {
        if (_this2.style.selected)
          return;
        _this2.background.attr("fill", _this2.hoverColor);
      });
      this.addEventListener("pointerleave", function() {
        if (_this2.style.selected)
          return;
        _this2.background.attr("fill", _this2.style.backgroundFill);
      });
      var item = this;
      this.addEventListener("click", function() {
        var _a2 = _this2.style, label = _a2.label, value = _a2.value, onClick = _a2.onClick;
        onClick === null || onClick === void 0 ? void 0 : onClick(value, { label, value }, item);
      });
    };
    Option2.defaultOptions = {
      style: {
        value: "",
        label: "",
        cursor: "pointer"
      }
    };
    return Option2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/select/select.js
var Select = (
  /** @class */
  function(_super) {
    __extends(Select2, _super);
    function Select2(options) {
      var _a2, _b;
      var _this2 = _super.call(this, deepAssign({}, Select2.defaultOptions, options)) || this;
      _this2.currentValue = (_a2 = Select2.defaultOptions.style) === null || _a2 === void 0 ? void 0 : _a2.defaultValue;
      _this2.isPointerInSelect = false;
      _this2.select = _this2.appendChild(new Rect({
        className: "select",
        style: {
          cursor: "pointer",
          width: 0,
          height: 0
        }
      }));
      _this2.dropdown = _this2.appendChild(new Rect({
        className: "dropdown"
      }));
      var defaultValue = _this2.style.defaultValue;
      if (defaultValue && ((_b = _this2.style.options) === null || _b === void 0 ? void 0 : _b.some(function(option) {
        return option.value === defaultValue;
      }))) {
        _this2.currentValue = defaultValue;
      }
      return _this2;
    }
    Select2.prototype.setValue = function(value) {
      this.currentValue = value;
      this.render();
    };
    Select2.prototype.getValue = function() {
      return this.currentValue;
    };
    Object.defineProperty(Select2.prototype, "dropdownPadding", {
      get: function() {
        return parseSeriesAttr(this.style.dropdownPadding);
      },
      enumerable: false,
      configurable: true
    });
    Select2.prototype.renderSelect = function() {
      var _this2 = this;
      var _a2;
      var _b = this.style, x3 = _b.x, y3 = _b.y, width = _b.width, height = _b.height, bordered = _b.bordered, showDropdownIcon = _b.showDropdownIcon;
      var selectStyle = subStyleProps(this.attributes, "select");
      var placeholderStyle = subStyleProps(this.attributes, "placeholder");
      this.select.attr(__assign(__assign({ x: x3, y: y3, width, height }, selectStyle), { fill: "#fff", strokeWidth: bordered ? 1 : 0 }));
      var padding = this.dropdownPadding;
      var iconSize = 10;
      if (showDropdownIcon) {
        select(this.select).maybeAppend(".dropdown-icon", "path").style("d", "M-5,-3.5 L0,3.5 L5,-3.5").style("transform", "translate(".concat(x3 + width - iconSize - padding[1] - padding[3], ", ").concat(y3 + height / 2, ")")).style("lineWidth", 1).style("stroke", this.select.style.stroke);
      }
      var currentOption = (_a2 = this.style.options) === null || _a2 === void 0 ? void 0 : _a2.find(function(option) {
        return option.value === _this2.currentValue;
      });
      var finalPlaceholderStyle = __assign({ x: x3 + padding[3] }, placeholderStyle);
      select(this.select).selectAll(".placeholder").data(!currentOption ? [1] : []).join(function(enter) {
        return enter.append("text").attr("className", "placeholder").styles(finalPlaceholderStyle).style("y", function() {
          var bbox = this.getBBox();
          return y3 + (height - bbox.height) / 2;
        });
      }, function(update2) {
        return update2.styles(finalPlaceholderStyle);
      }, function(exit) {
        return exit.remove();
      });
      var labelStyle = subStyleProps(this.attributes, "optionLabel");
      var finalValueStyle = __assign({ x: x3 + padding[3] }, labelStyle);
      select(this.select).selectAll(".value").data(currentOption ? [currentOption] : []).join(function(enter) {
        return enter.append(function(datum) {
          return renderExtDo(datum.label);
        }).attr("className", "value").styles(finalValueStyle).style("y", function() {
          var bbox = this.getBBox();
          return y3 + (height - bbox.height) / 2;
        });
      }, function(update2) {
        return update2.styles(finalValueStyle);
      }, function(exit) {
        return exit.remove();
      });
    };
    Select2.prototype.renderDropdown = function() {
      var _this2 = this;
      var _a2, _b;
      var _c = this.style, x3 = _c.x, y3 = _c.y, width = _c.width, height = _c.height, options = _c.options, onSelect = _c.onSelect, open = _c.open;
      var dropdownStyle = subStyleProps(this.attributes, "dropdown");
      var optionStyle = subStyleProps(this.attributes, "option");
      var padding = this.dropdownPadding;
      select(this.dropdown).maybeAppend(".dropdown-container", "g").attr("className", "dropdown-container").selectAll(".dropdown-item").data(options, function(datum) {
        return datum.value;
      }).join(function(enter) {
        return enter.append(function(datum) {
          return new Option({
            className: "dropdown-item",
            style: __assign(__assign(__assign({}, datum), optionStyle), { width: width - padding[1] - padding[3], selected: datum.value === _this2.currentValue, onClick: function(value, option, item) {
              _this2.setValue(value);
              onSelect === null || onSelect === void 0 ? void 0 : onSelect(value, option, item);
              _this2.dispatchEvent(new CustomEvent("change", { detail: { value, option, item } }));
              hide(_this2.dropdown);
            } })
          });
        }).each(function(datum, i) {
          var _a3;
          var nodes = (_a3 = this.parentNode) === null || _a3 === void 0 ? void 0 : _a3.children;
          var accHeight = nodes.reduce(function(acc, curr, index2) {
            if (index2 < i) {
              acc += curr.getBBox().height;
            }
            return acc;
          }, 0);
          this.attr("transform", "translate(".concat(padding[3], ", ").concat(padding[0] + accHeight, ")"));
        });
      }, function(update2) {
        return update2.update(function(datum) {
          return { selected: datum.value === _this2.currentValue };
        });
      }, function(exit) {
        return exit.remove();
      });
      var bbox = (_b = (_a2 = this.dropdown.getElementsByClassName("dropdown-container")) === null || _a2 === void 0 ? void 0 : _a2[0]) === null || _b === void 0 ? void 0 : _b.getBBox();
      var spacing = dropdownStyle.spacing;
      this.dropdown.attr(__assign({ transform: "translate(".concat(x3, ", ").concat(y3 + height + spacing, ")"), width: bbox.width + padding[1] + padding[3], height: bbox.height + padding[0] + padding[2] }, dropdownStyle));
      !open && hide(this.dropdown);
    };
    Select2.prototype.render = function() {
      this.renderSelect();
      this.renderDropdown();
    };
    Select2.prototype.bindEvents = function() {
      var _this2 = this;
      this.addEventListener("click", function(e) {
        e.stopPropagation();
      });
      this.select.addEventListener("click", function() {
        if (_this2.dropdown.style.visibility === "visible")
          hide(_this2.dropdown);
        else {
          show(_this2.dropdown);
        }
      });
      this.addEventListener("pointerenter", function() {
        _this2.isPointerInSelect = true;
      });
      this.addEventListener("pointerleave", function() {
        _this2.isPointerInSelect = false;
      });
      document === null || document === void 0 ? void 0 : document.addEventListener("click", function() {
        if (!_this2.isPointerInSelect) {
          hide(_this2.dropdown);
        }
      });
    };
    Select2.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        width: 140,
        height: 32,
        options: [],
        bordered: true,
        defaultValue: "",
        selectRadius: 8,
        selectStroke: "#d9d9d9",
        showDropdownIcon: true,
        placeholderText: "请选择",
        placeholderFontSize: 12,
        placeholderTextBaseline: "top",
        placeholderFill: "#c2c2c2",
        dropdownFill: "#fff",
        dropdownStroke: "#d9d9d9",
        dropdownRadius: 8,
        dropdownShadowBlur: 4,
        dropdownShadowColor: "rgba(0, 0, 0, 0.08)",
        dropdownPadding: 8,
        dropdownSpacing: 10,
        optionPadding: [8, 12],
        optionFontSize: 12,
        optionTextBaseline: "top",
        optionBackgroundFill: "#fff",
        optionBackgroundRadius: 4,
        optionLabelFontSize: 12,
        optionLabelTextBaseline: "top"
      }
    };
    return Select2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/timebar/icons.js
var IconBase = (
  /** @class */
  function(_super) {
    __extends(IconBase2, _super);
    function IconBase2(options) {
      var _this2 = _super.call(this, deepAssign({}, { style: { backgroundOpacity: IconBase2.backgroundOpacities.default } }, IconBase2.defaultOptions, options)) || this;
      _this2.showBackground = true;
      _this2.background = _this2.appendChild(new Rect({}));
      _this2.icon = _this2.appendChild(new Group({}));
      return _this2;
    }
    Object.defineProperty(IconBase2.prototype, "label", {
      get: function() {
        return "BaseIcon";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(IconBase2.prototype, "lineWidth", {
      get: function() {
        return Math.log10(this.attributes.size);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(IconBase2.prototype, "padding", {
      get: function() {
        return parseSeriesAttr(this.attributes.size / 5);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(IconBase2.prototype, "iconSize", {
      get: function() {
        var size2 = this.attributes.size;
        var _a2 = __read(this.padding, 4), top = _a2[0], right = _a2[1], bottom = _a2[2], left = _a2[3];
        return Math.max(size2 - Math.max(left + right, top + bottom), this.lineWidth * 2 + 1);
      },
      enumerable: false,
      configurable: true
    });
    IconBase2.prototype.renderBackground = function() {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, size2 = _a2.size;
      var halfSize = size2 / 2;
      var backgroundStyle = subStyleProps(this.attributes, "background");
      this.background.attr(__assign({ x: x3 - halfSize, y: y3 - halfSize, width: size2, height: size2 }, backgroundStyle));
    };
    IconBase2.prototype.showIndicator = function() {
      if (!this.label)
        return;
      var size2 = this.attributes.size;
      var _a2 = this.background.getBBox(), x3 = _a2.x, y3 = _a2.y;
      this.indicator.update({ x: x3 + size2 / 2, y: y3 - 5, labelText: this.label, visibility: "visible" });
    };
    IconBase2.prototype.hideIndicator = function() {
      this.indicator.update({ visibility: "hidden" });
    };
    IconBase2.prototype.connectedCallback = function() {
      var _a2;
      _super.prototype.connectedCallback.call(this);
      var size2 = this.attributes.size;
      var _b = this.background.getBBox(), x3 = _b.x, y3 = _b.y;
      var canvas = (_a2 = this.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView;
      if (canvas) {
        this.indicator = canvas.appendChild(new Indicator({
          style: {
            x: x3 + size2 / 2,
            y: y3 - size2 / 2,
            visibility: "hidden",
            position: "top",
            radius: 3,
            zIndex: 100
          }
        }));
      }
    };
    IconBase2.prototype.disconnectedCallback = function() {
      this.indicator.destroy();
    };
    IconBase2.prototype.render = function() {
      this.renderIcon();
      if (this.showBackground)
        this.renderBackground();
    };
    IconBase2.prototype.bindEvents = function() {
      var _this2 = this;
      var onClick = this.attributes.onClick;
      this.addEventListener("click", function() {
        onClick === null || onClick === void 0 ? void 0 : onClick(_this2);
      });
      if (this.showBackground) {
        var resetBackground_1 = function() {
          return _this2.background.attr({ opacity: IconBase2.backgroundOpacities.default });
        };
        var hoverBackground_1 = function() {
          return _this2.background.attr({ opacity: IconBase2.backgroundOpacities.hover });
        };
        var activeBackground_1 = function() {
          return _this2.background.attr({ opacity: IconBase2.backgroundOpacities.active });
        };
        this.addEventListener("pointerenter", function() {
          hoverBackground_1();
          _this2.showIndicator();
        });
        this.addEventListener("pointerleave", function() {
          resetBackground_1();
          _this2.hideIndicator();
        });
        this.addEventListener("pointerdown", function() {
          activeBackground_1();
        });
        this.addEventListener("pointerup", function() {
          resetBackground_1();
        });
      }
    };
    IconBase2.tag = "IconBase";
    IconBase2.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        size: 10,
        color: "#565758",
        backgroundRadius: 4,
        backgroundFill: "#e2e2e2"
      }
    };
    IconBase2.backgroundOpacities = {
      default: 0,
      hover: 0.8,
      active: 1
    };
    return IconBase2;
  }(Component)
);
var arrow = function(size2, color2) {
  if (color2 === void 0) {
    color2 = "#565758";
  }
  return new Path({
    style: {
      fill: color2,
      d: "M ".concat(size2, ",").concat(size2, " L -").concat(size2, ",0 L ").concat(size2, ",-").concat(size2, " Z"),
      transformOrigin: "center"
    }
  });
};
var Reset = (
  /** @class */
  function(_super) {
    __extends(Reset2, _super);
    function Reset2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Reset2.prototype.arcPath = function(cx, cy, radius) {
      var _a2 = __read([radius, radius], 2), rx = _a2[0], ry = _a2[1];
      var getPosByAngle = function(angle3) {
        return [cx + radius * Math.cos(angle3), cy + radius * Math.sin(angle3)];
      };
      var _b = __read(getPosByAngle(-5 / 4 * Math.PI), 2), x1 = _b[0], y1 = _b[1];
      var _c = __read(getPosByAngle(1 / 4 * Math.PI), 2), x22 = _c[0], y22 = _c[1];
      return "M".concat(x1, ",").concat(y1, ",A").concat(rx, ",").concat(ry, ",0,1,1,").concat(x22, ",").concat(y22);
    };
    Object.defineProperty(Reset2.prototype, "label", {
      get: function() {
        return "重置";
      },
      enumerable: false,
      configurable: true
    });
    Reset2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color2 = _a2.color;
      var size2 = this.iconSize;
      var lineWidth = this.lineWidth;
      var arrowSize = lineWidth + 0.5;
      select(this.icon).maybeAppend(".reset", "path").styles({
        stroke: color2,
        lineWidth,
        d: this.arcPath(x3, y3, size2 / 2 - lineWidth),
        markerStart: arrow(arrowSize, color2)
      });
    };
    return Reset2;
  }(IconBase)
);
var Backward = (
  /** @class */
  function(_super) {
    __extends(Backward2, _super);
    function Backward2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Backward2.prototype, "label", {
      get: function() {
        return "快退";
      },
      enumerable: false,
      configurable: true
    });
    Backward2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color2 = _a2.color;
      var size2 = this.iconSize;
      var deltaX = size2 / 2;
      var deltaY = size2 / 2 / Math.pow(3, 0.5);
      var points = [
        [x3, y3],
        [x3, y3 - deltaY],
        [x3 - deltaX, y3],
        [x3, y3 + deltaY],
        [x3, y3],
        [x3 + deltaX, y3 - deltaY],
        [x3 + deltaX, y3 + deltaY],
        [x3, y3]
      ];
      select(this.icon).maybeAppend(".backward", "polygon").styles({
        points,
        fill: color2
      });
    };
    return Backward2;
  }(IconBase)
);
var Forward = (
  /** @class */
  function(_super) {
    __extends(Forward2, _super);
    function Forward2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Forward2.prototype, "label", {
      get: function() {
        return "快进";
      },
      enumerable: false,
      configurable: true
    });
    Forward2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color2 = _a2.color;
      var size2 = this.iconSize;
      var deltaX = size2 / 2;
      var deltaY = size2 / 2 / Math.pow(3, 0.5);
      var points = [
        [x3, y3],
        [x3, y3 - deltaY],
        [x3 + deltaX, y3],
        [x3, y3 + deltaY],
        [x3, y3],
        [x3 - deltaX, y3 - deltaY],
        [x3 - deltaX, y3 + deltaY],
        [x3, y3]
      ];
      select(this.icon).maybeAppend(".forward", "polygon").styles({
        points,
        fill: color2
      });
    };
    return Forward2;
  }(IconBase)
);
var Play = (
  /** @class */
  function(_super) {
    __extends(Play2, _super);
    function Play2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Play2.prototype, "label", {
      get: function() {
        return "播放";
      },
      enumerable: false,
      configurable: true
    });
    Play2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color2 = _a2.color;
      var size2 = this.iconSize;
      var deltaX = size2 / 3 * Math.pow(3, 0.5) * 0.8;
      var points = [
        [x3 + deltaX, y3],
        [x3 - deltaX / 2, y3 - size2 / 2 * 0.8],
        [x3 - deltaX / 2, y3 + size2 / 2 * 0.8],
        [x3 + deltaX, y3]
      ];
      select(this.icon).maybeAppend(".play", "polygon").styles({
        points,
        fill: color2
      });
    };
    return Play2;
  }(IconBase)
);
var Pause = (
  /** @class */
  function(_super) {
    __extends(Pause2, _super);
    function Pause2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Pause2.prototype, "label", {
      get: function() {
        return "暂停";
      },
      enumerable: false,
      configurable: true
    });
    Pause2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color2 = _a2.color;
      var size2 = this.iconSize;
      var deltaX = size2 / 3;
      var points = [
        [x3 - deltaX, y3 - size2 / 2],
        [x3 - deltaX, y3 + size2 / 2],
        [x3 - deltaX / 2, y3 + size2 / 2],
        [x3 - deltaX / 2, y3 - size2 / 2],
        [x3 - deltaX, y3 - size2 / 2],
        [x3 + deltaX / 2, y3 - size2 / 2],
        [x3 + deltaX / 2, y3 + size2 / 2],
        [x3 + deltaX, y3 + size2 / 2],
        [x3 + deltaX, y3 - size2 / 2]
      ];
      select(this.icon).maybeAppend(".pause", "polygon").styles({
        points,
        fill: color2
      });
    };
    return Pause2;
  }(IconBase)
);
var Range = (
  /** @class */
  function(_super) {
    __extends(Range2, _super);
    function Range2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Range2.prototype, "label", {
      get: function() {
        return "范围时间";
      },
      enumerable: false,
      configurable: true
    });
    Range2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color2 = _a2.color;
      var _b = this, size2 = _b.iconSize, lineWidth = _b.lineWidth;
      var gap = lineWidth;
      select(this.icon).maybeAppend(".left-line", "line").styles({
        x1: x3 - size2 / 2,
        y1: y3 - size2 / 2,
        x2: x3 - size2 / 2,
        y2: y3 + size2 / 2,
        stroke: color2,
        lineWidth
      });
      select(this.icon).maybeAppend(".right-line", "line").styles({
        x1: x3 + size2 / 2,
        y1: y3 - size2 / 2,
        x2: x3 + size2 / 2,
        y2: y3 + size2 / 2,
        stroke: color2,
        lineWidth
      });
      select(this.icon).maybeAppend(".left-arrow", "line").styles({
        x1: x3,
        y1: y3,
        x2: x3 - size2 / 2 + gap * 2,
        y2: y3,
        stroke: color2,
        lineWidth,
        markerEnd: arrow(lineWidth * 2, color2)
      });
      select(this.icon).maybeAppend(".right-arrow", "line").styles({
        x1: x3,
        y1: y3,
        x2: x3 + size2 / 2 - gap * 2,
        y2: y3,
        stroke: color2,
        lineWidth,
        markerEnd: arrow(lineWidth * 2, color2)
      });
    };
    return Range2;
  }(IconBase)
);
var Value = (
  /** @class */
  function(_super) {
    __extends(Value2, _super);
    function Value2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Value2.prototype, "label", {
      get: function() {
        return "单一时间";
      },
      enumerable: false,
      configurable: true
    });
    Value2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color2 = _a2.color;
      var _b = this, size2 = _b.iconSize, lineWidth = _b.lineWidth;
      select(this.icon).maybeAppend(".line", "line").styles({
        x1: x3,
        y1: y3 - size2 / 2,
        x2: x3,
        y2: y3 + size2 / 2,
        stroke: color2,
        lineWidth
      });
      var gap = lineWidth;
      select(this.icon).maybeAppend(".left-arrow", "line").styles({
        x1: x3 - size2 / 2 - gap * 2,
        y1: y3,
        x2: x3 - gap * 2,
        y2: y3,
        stroke: color2,
        lineWidth,
        markerEnd: arrow(lineWidth * 2, color2)
      });
      select(this.icon).maybeAppend(".right-arrow", "line").styles({
        x1: x3 + size2 / 2 + gap * 2,
        y1: y3,
        x2: x3 + gap * 2,
        y2: y3,
        stroke: color2,
        lineWidth,
        markerEnd: arrow(lineWidth * 2, color2)
      });
    };
    return Value2;
  }(IconBase)
);
var getCoordinatePoints = function(size2) {
  return [
    [-size2 / 2, -size2 / 2],
    [-size2 / 2, size2 / 2],
    [size2 / 2, size2 / 2]
  ];
};
var LineChart = (
  /** @class */
  function(_super) {
    __extends(LineChart2, _super);
    function LineChart2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(LineChart2.prototype, "label", {
      get: function() {
        return "折线图";
      },
      enumerable: false,
      configurable: true
    });
    LineChart2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color2 = _a2.color;
      var _b = this, size2 = _b.iconSize, lineWidth = _b.lineWidth;
      var gap = lineWidth;
      var deltaX = (size2 - gap * 2 - lineWidth) / 4;
      var deltaY = (size2 - gap * 2 - lineWidth) / 2;
      var _c = __read([x3 - size2 / 2 + gap, y3 + size2 / 2 - gap * 2], 2), ox = _c[0], oy = _c[1];
      select(this.icon).maybeAppend(".coordinate", "polyline").styles({
        points: getCoordinatePoints(size2).map(function(_a3) {
          var _b2 = __read(_a3, 2), px2 = _b2[0], py = _b2[1];
          return [px2 + x3, py + y3];
        }),
        stroke: color2,
        lineWidth
      });
      select(this.icon).maybeAppend(".line", "polyline").styles({
        points: [
          [ox, oy],
          [ox + deltaX, oy - deltaY],
          [ox + deltaX * 2, oy],
          [ox + deltaX * 4, oy - deltaY * 2]
        ],
        stroke: color2,
        lineWidth
      });
    };
    return LineChart2;
  }(IconBase)
);
var BarChart = (
  /** @class */
  function(_super) {
    __extends(BarChart2, _super);
    function BarChart2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(BarChart2.prototype, "label", {
      get: function() {
        return "条形图";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BarChart2.prototype, "data", {
      get: function() {
        return [1, 4, 2, 4, 3];
      },
      enumerable: false,
      configurable: true
    });
    BarChart2.prototype.renderIcon = function() {
      var data2 = this.data;
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color2 = _a2.color;
      var _b = this, size2 = _b.iconSize, lineWidth = _b.lineWidth;
      var gap = lineWidth;
      var deltaX = (size2 - gap) / data2.length;
      var deltaY = (size2 - gap * 2) / 4;
      var _c = __read([x3 - size2 / 2 + gap * 2, y3 + size2 / 2 - gap], 2), ox = _c[0], oy = _c[1];
      select(this.icon).maybeAppend(".coordinate", "polyline").styles({
        points: getCoordinatePoints(size2).map(function(_a3) {
          var _b2 = __read(_a3, 2), px2 = _b2[0], py = _b2[1];
          return [px2 + x3, py + y3];
        }),
        stroke: color2,
        lineWidth
      });
      select(this.icon).maybeAppend(".bars", "g").selectAll(".column").data(this.data.map(function(value, index2) {
        return { value, index: index2 };
      })).join(function(enter) {
        return enter.append("line").attr("className", "column").style("x1", function(_a3) {
          var index2 = _a3.index;
          return ox + deltaX * index2;
        }).style("y1", oy).style("x2", function(_a3) {
          var index2 = _a3.index;
          return ox + deltaX * index2;
        }).style("y2", function(_a3) {
          var value = _a3.value;
          return oy - deltaY * value;
        }).styles({
          y1: oy,
          stroke: color2,
          lineWidth
        });
      });
    };
    return BarChart2;
  }(IconBase)
);
var Split = (
  /** @class */
  function(_super) {
    __extends(Split2, _super);
    function Split2(options) {
      var _this2 = _super.call(this, deepAssign({}, { style: { color: "#d8d9d9" } }, options)) || this;
      _this2.showBackground = false;
      return _this2;
    }
    Split2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color2 = _a2.color;
      var _b = this, size2 = _b.iconSize, lineWidth = _b.lineWidth;
      select(this.icon).maybeAppend(".split", "line").styles({
        x1: x3,
        y1: y3 - size2 / 2,
        x2: x3,
        y2: y3 + size2 / 2,
        stroke: color2,
        lineWidth
      });
    };
    return Split2;
  }(IconBase)
);
var SpeedSelect = (
  /** @class */
  function(_super) {
    __extends(SpeedSelect2, _super);
    function SpeedSelect2() {
      var _this2 = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
      _this2.showBackground = false;
      return _this2;
    }
    Object.defineProperty(SpeedSelect2.prototype, "padding", {
      get: function() {
        return parseSeriesAttr(0);
      },
      enumerable: false,
      configurable: true
    });
    SpeedSelect2.prototype.renderIcon = function() {
      var iconSize = this.iconSize;
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, _b = _a2.speed, speed = _b === void 0 ? 1 : _b;
      var inheritStyle = omit_default(this.attributes, [
        "x",
        "y",
        "transform",
        "transformOrigin",
        "width",
        "height",
        "size",
        "color",
        "speed"
      ]);
      var width = clamp_default(iconSize, 20, Infinity);
      var height = 20;
      var style = __assign(__assign({}, inheritStyle), { x: x3 - width / 2, y: y3 - height / 2, width, height, defaultValue: speed, bordered: false, showDropdownIcon: false, selectRadius: 2, dropdownPadding: this.padding, dropdownRadius: 2, dropdownSpacing: iconSize / 5, placeholderFontSize: iconSize / 2, optionPadding: 0, optionLabelFontSize: iconSize / 2, optionBackgroundRadius: 1, options: [
        { label: "1x", value: 1 },
        { label: "1.5x", value: 1.5 },
        { label: "2x", value: 2 }
      ] });
      select(this.icon).maybeAppend(".speed", function() {
        return new Select({ style });
      }).attr("className", "speed").each(function() {
        this.update(style);
      });
    };
    SpeedSelect2.tag = "SpeedSelect";
    return SpeedSelect2;
  }(IconBase)
);
var ToggleIcon = (
  /** @class */
  function(_super) {
    __extends(ToggleIcon2, _super);
    function ToggleIcon2(options) {
      var _this2 = _super.call(this, options) || this;
      _this2.icon = _this2.appendChild(new Group({}));
      _this2.currentType = _this2.attributes.type;
      return _this2;
    }
    ToggleIcon2.prototype.getType = function() {
      return this.currentType;
    };
    ToggleIcon2.prototype.render = function() {
      var _this2 = this;
      var _a2 = this.attributes, onChange = _a2.onChange, restStyles = __rest(_a2, ["onChange"]);
      select(this.icon).selectAll(".icon").data([this.currentType]).join(function(enter) {
        return enter.append(function(type) {
          var _a3;
          var Ctor = (_a3 = _this2.toggles.find(function(_a4) {
            var _b = __read(_a4, 1), key = _b[0];
            return key === type;
          })) === null || _a3 === void 0 ? void 0 : _a3[1];
          if (!Ctor)
            throw new Error("Invalid type: ".concat(type));
          return new Ctor({});
        }).attr("className", "icon").styles(restStyles, false).update({});
      }, function(update2) {
        return update2.styles({ restStyles }).update({});
      }, function(exit) {
        return exit.remove();
      });
    };
    ToggleIcon2.prototype.bindEvents = function() {
      var _this2 = this;
      var onChange = this.attributes.onChange;
      this.addEventListener("click", function(e) {
        e.preventDefault();
        e.stopPropagation();
        var nextIndex = (_this2.toggles.findIndex(function(_a2) {
          var _b = __read(_a2, 1), key = _b[0];
          return key === _this2.currentType;
        }) + 1) % _this2.toggles.length;
        var nextType = _this2.toggles[nextIndex][0];
        onChange === null || onChange === void 0 ? void 0 : onChange(_this2.currentType);
        _this2.currentType = nextType;
        _this2.render();
      });
    };
    ToggleIcon2.tag = "ToggleIcon";
    return ToggleIcon2;
  }(Component)
);
var PlayPause = (
  /** @class */
  function(_super) {
    __extends(PlayPause2, _super);
    function PlayPause2(options) {
      var _this2 = _super.call(this, deepAssign({}, { style: { type: "play" } }, options)) || this;
      _this2.toggles = [
        ["play", Play],
        ["pause", Pause]
      ];
      return _this2;
    }
    return PlayPause2;
  }(ToggleIcon)
);
var SelectionType = (
  /** @class */
  function(_super) {
    __extends(SelectionType2, _super);
    function SelectionType2(options) {
      var _this2 = _super.call(this, deepAssign({}, { style: { type: "range" } }, options)) || this;
      _this2.toggles = [
        ["range", Range],
        ["value", Value]
      ];
      return _this2;
    }
    return SelectionType2;
  }(ToggleIcon)
);
var ChartType = (
  /** @class */
  function(_super) {
    __extends(ChartType2, _super);
    function ChartType2(options) {
      var _this2 = _super.call(this, deepAssign({}, { style: { type: "column" } }, options)) || this;
      _this2.toggles = [
        ["line", LineChart],
        ["column", BarChart]
      ];
      return _this2;
    }
    return ChartType2;
  }(ToggleIcon)
);

// node_modules/@antv/component/esm/ui/timebar/controller.js
var componentsMap = {
  reset: Reset,
  speed: SpeedSelect,
  backward: Backward,
  playPause: PlayPause,
  forward: Forward,
  selectionType: SelectionType,
  chartType: ChartType,
  split: Split
};
var Controller = (
  /** @class */
  function(_super) {
    __extends(Controller2, _super);
    function Controller2(options) {
      var _this2 = _super.call(this, deepAssign({}, Controller2.defaultOptions, options)) || this;
      _this2.background = _this2.appendChild(new Rect({}));
      _this2.functions = _this2.appendChild(new Group({}));
      return _this2;
    }
    Object.defineProperty(Controller2.prototype, "padding", {
      get: function() {
        return parseSeriesAttr(this.attributes.padding);
      },
      enumerable: false,
      configurable: true
    });
    Controller2.prototype.renderBackground = function() {
      var _a2 = this.style, x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
      var backgroundStyle = subStyleProps(this.attributes, "background");
      this.background.attr(__assign({ x: x3, y: y3, width, height }, backgroundStyle));
    };
    Controller2.prototype.renderFunctions = function() {
      var _this2 = this;
      var _a2;
      var _b = this.attributes, functions = _b.functions, iconSize = _b.iconSize, iconSpacing = _b.iconSpacing, x3 = _b.x, y3 = _b.y, width = _b.width, height = _b.height, align = _b.align;
      var _c = __read(this.padding, 4), right = _c[1], left = _c[3];
      var components = functions.reduce(function(prev, curr) {
        if (prev.length && curr.length) {
          return prev.concat.apply(prev, __spreadArray(["split"], __read(curr), false));
        }
        return prev.concat.apply(prev, __spreadArray([], __read(curr), false));
      }, []);
      var componentsWidth = components.length * (iconSize + iconSpacing) - iconSpacing;
      var xOffset = {
        left: left + iconSize / 2,
        center: (width - componentsWidth) / 2 + iconSize / 2,
        right: width - componentsWidth - left - right + iconSize / 2
      }[align] || 0;
      (_a2 = this.speedSelect) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      this.functions.removeChildren();
      components.forEach(function(name, index2) {
        var _a3;
        var Ctor = componentsMap[name];
        var style = {
          x: x3 + index2 * (iconSize + iconSpacing) + xOffset,
          y: y3 + height / 2,
          size: iconSize
        };
        if (Ctor === SpeedSelect) {
          style.speed = _this2.attributes.speed;
          style.onSelect = function(value) {
            return _this2.handleFunctionChange(name, { value });
          };
        } else if ([PlayPause, SelectionType, ChartType].includes(Ctor)) {
          style.onChange = function(value) {
            return _this2.handleFunctionChange(name, { value });
          };
          if (Ctor === PlayPause)
            style.type = _this2.attributes.state === "play" ? "pause" : "play";
          if (Ctor === SelectionType)
            style.type = _this2.attributes.selectionType === "range" ? "value" : "range";
          if (Ctor === ChartType)
            style.type = _this2.attributes.chartType === "line" ? "column" : "line";
        } else {
          style.onClick = function() {
            return _this2.handleFunctionChange(name, { value: name });
          };
        }
        if (Ctor === SpeedSelect) {
          var canvas = (_a3 = _this2.ownerDocument) === null || _a3 === void 0 ? void 0 : _a3.defaultView;
          if (canvas) {
            _this2.speedSelect = new Ctor({ style: __assign(__assign({}, style), { zIndex: 100 }) });
            canvas.appendChild(_this2.speedSelect);
          }
        } else {
          _this2.functions.appendChild(new Ctor({ style }));
        }
      });
    };
    Controller2.prototype.disconnectedCallback = function() {
      var _a2;
      _super.prototype.disconnectedCallback.call(this);
      (_a2 = this.speedSelect) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    };
    Controller2.prototype.render = function() {
      this.renderBackground();
      this.renderFunctions();
    };
    Controller2.prototype.handleFunctionChange = function(name, value) {
      var onChange = this.attributes.onChange;
      onChange === null || onChange === void 0 ? void 0 : onChange(name, value);
    };
    Controller2.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        width: 300,
        height: 40,
        padding: 0,
        align: "center",
        iconSize: 25,
        iconSpacing: 0,
        speed: 1,
        state: "pause",
        chartType: "line",
        selectionType: "range",
        backgroundFill: "#fbfdff",
        backgroundStroke: "#ebedf0",
        functions: [
          ["reset", "speed"],
          ["backward", "playPause", "forward"],
          ["selectionType", "chartType"]
        ]
      }
    };
    return Controller2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/timebar/handle.js
var TimeModeHandle = (
  /** @class */
  function(_super) {
    __extends(TimeModeHandle2, _super);
    function TimeModeHandle2(options) {
      var _this2 = _super.call(this, deepAssign({}, TimeModeHandle2.defaultOptions, options)) || this;
      _this2.bindEvents();
      return _this2;
    }
    TimeModeHandle2.prototype.bindEvents = function() {
      var _this2 = this;
      this.addEventListener("mouseenter", function() {
        _this2.attr("lineWidth", Math.ceil(+(_this2.style.r || 0) / 2));
      });
      this.addEventListener("mouseleave", function() {
        _this2.attr("lineWidth", 0);
      });
    };
    TimeModeHandle2.defaultOptions = {
      style: {
        r: 5,
        fill: "#3f7cf7",
        lineWidth: 0,
        stroke: "#3f7cf7",
        strokeOpacity: 0.5,
        cursor: "pointer"
      }
    };
    return TimeModeHandle2;
  }(Circle)
);
var ChartModeHandle = (
  /** @class */
  function(_super) {
    __extends(ChartModeHandle2, _super);
    function ChartModeHandle2(options) {
      return _super.call(this, deepAssign({}, ChartModeHandle2.defaultOptions, options)) || this;
    }
    ChartModeHandle2.prototype.renderBackground = function() {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height;
      var style = subStyleProps(this.attributes, "background");
      select(this).maybeAppend("background", "rect").attr("className", "background").styles(__assign({ x: x3 - width / 2, y: y3 - height / 2, width, height }, style));
    };
    ChartModeHandle2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, iconSize = _a2.iconSize;
      var style = subStyleProps(this.attributes, "icon");
      var diffX = 1;
      var diffY = iconSize / 2;
      select(this).maybeAppend("icon-left-line", "line").attr("className", "icon-left-line").styles(__assign({ x1: x3 - diffX, y1: y3 - diffY, x2: x3 - diffX, y2: y3 + diffY }, style));
      select(this).maybeAppend("icon-right-line", "line").attr("className", "icon-right-line").styles(__assign({ x1: x3 + diffX, y1: y3 - diffY, x2: x3 + diffX, y2: y3 + diffY }, style));
    };
    ChartModeHandle2.prototype.renderBorder = function() {
      var _a2 = this.attributes, xx = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height, type = _a2.type;
      var style = subStyleProps(this.attributes, "border");
      var x3 = type === "start" ? +width / 2 : -width / 2;
      select(this).maybeAppend("border", "line").attr("className", "border").styles(__assign({ x1: x3 + xx, y1: y3 - height / 2, x2: x3 + xx, y2: y3 + height / 2 }, style));
    };
    ChartModeHandle2.prototype.render = function() {
      this.renderBackground();
      this.renderIcon();
      this.renderBorder();
    };
    ChartModeHandle2.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        width: 10,
        height: 50,
        iconSize: 10,
        type: "start",
        backgroundFill: "#fff",
        backgroundFillOpacity: 0.5,
        iconStroke: "#9a9a9a",
        iconLineWidth: 1,
        borderStroke: "#e8e8e8",
        borderLineWidth: 1
      }
    };
    return ChartModeHandle2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/timebar/utils.js
function labelFormatter(time, interval) {
  if (typeof time === "number") {
    return parseBySeries(time);
  }
  return parseByTime(time, interval);
}
function parseByTime(time, interval) {
  var date = new Date(time);
  switch (interval) {
    case "half-hour":
    case "hour":
    case "four-hour":
      if ([0, 6, 12, 18].includes(date.getHours()) && date.getMinutes() === 0) {
        return formatTime(date, "HH:mm\nYYYY-MM-DD");
      }
      return formatTime(date, "HH:mm");
    case "half-day":
      if (date.getHours() < 12) {
        return "AM\n".concat(formatTime(date, "YYYY-MM-DD"));
      }
      return "PM";
    case "day":
      if ([1, 10, 20].includes(date.getDate())) {
        return formatTime(date, "DD\nYYYY-MM");
      }
      return formatTime(date, "DD");
    case "week":
      if (date.getDate() <= 7) {
        return formatTime(date, "DD\nYYYY-MM");
      }
      return formatTime(date, "DD");
    case "month":
      if ([0, 6].includes(date.getMonth())) {
        return formatTime(date, "MM月\nYYYY");
      }
      return formatTime(date, "MM月");
    case "season":
      if ([0].includes(date.getMonth())) {
        return formatTime(date, "MM月\nYYYY");
      }
      return formatTime(date, "MM月");
    case "year":
      return formatTime(date, "YYYY");
    default:
      return formatTime(date, "YYYY-MM-DD HH:mm");
  }
}
function parseBySeries(time) {
  var hours = String(Math.floor(time / 3600)).padStart(2, "0");
  var minutes = String(Math.floor(time % 3600 / 60)).padStart(2, "0");
  var seconds = String(Math.floor(time % 60)).padStart(2, "0");
  if (time < 3600) {
    return "".concat(minutes, ":").concat(seconds);
  }
  return "".concat(hours, ":").concat(minutes, ":").concat(seconds);
}

// node_modules/@antv/component/esm/ui/timebar/timebar.js
var Timebar = (
  /** @class */
  function(_super) {
    __extends(Timebar2, _super);
    function Timebar2(options) {
      var _this2 = _super.call(this, deepAssign({}, Timebar2.defaultOptions, options)) || this;
      _this2.axis = _this2.appendChild(new Axis({
        style: { type: "linear", startPos: [0, 0], endPos: [0, 0], data: [], showArrow: false, animate: false }
      }));
      _this2.timeline = _this2.appendChild(new Slider({
        style: {
          onChange: function(values2) {
            _this2.handleSliderChange(values2);
          }
        }
      }));
      _this2.controller = _this2.appendChild(new Controller({}));
      _this2.states = {};
      _this2.handleSliderChange = function(values2) {
        var prevValues = function() {
          var val = _this2.states.values;
          if (Array.isArray(val))
            return __spreadArray([], __read(val), false);
          return val;
        }();
        _this2.setBySliderValues(values2);
        _this2.dispatchOnChange(prevValues);
      };
      var _a2 = _this2.attributes, selectionType = _a2.selectionType, chartType = _a2.chartType, speed = _a2.speed, state = _a2.state, playMode = _a2.playMode, values = _a2.values;
      _this2.states = { chartType, playMode, selectionType, speed, state };
      _this2.setByTimebarValues(values);
      return _this2;
    }
    Object.defineProperty(Timebar2.prototype, "data", {
      get: function() {
        var data2 = this.attributes.data;
        var compareFn = function(a2, b) {
          if (a2.time < b.time)
            return -1;
          if (a2.time > b.time)
            return 1;
          return 0;
        };
        return data2.sort(compareFn);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Timebar2.prototype, "space", {
      /** 计算空间分配 */
      get: function() {
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, width = _a2.width, height = _a2.height, type = _a2.type, controllerHeight = _a2.controllerHeight;
        var availableTimelineHeight = clamp_default(+height - controllerHeight, 0, +height);
        var controllerBBox = new BBox(x3, y3 + +height - controllerHeight, +width, controllerHeight);
        var axisBBox;
        var axisHeight = 0;
        if (type === "chart") {
          axisHeight = 35;
          axisBBox = new BBox(x3, y3 + availableTimelineHeight - axisHeight, +width, axisHeight);
        } else
          axisBBox = new BBox();
        var timelineHeight = type === "time" ? 10 : availableTimelineHeight;
        var timelineBBox = new BBox(x3, y3 + (type === "time" ? availableTimelineHeight : availableTimelineHeight - timelineHeight), +width, timelineHeight - axisHeight);
        return { axisBBox, controllerBBox, timelineBBox };
      },
      enumerable: false,
      configurable: true
    });
    Timebar2.prototype.setBySliderValues = function(val) {
      var _a2, _b;
      var data2 = this.data;
      var _c = __read(Array.isArray(val) ? val : [0, val], 2), startRatio = _c[0], endRatio = _c[1];
      var length5 = data2.length;
      var startDatum = data2[Math.floor(startRatio * length5)];
      var endDatum = data2[Math.ceil(endRatio * length5) - (Array.isArray(val) ? 0 : 1)];
      this.states.values = [(_a2 = startDatum === null || startDatum === void 0 ? void 0 : startDatum.time) !== null && _a2 !== void 0 ? _a2 : data2[0].time, (_b = endDatum === null || endDatum === void 0 ? void 0 : endDatum.time) !== null && _b !== void 0 ? _b : Infinity];
    };
    Timebar2.prototype.setByTimebarValues = function(val) {
      var _a2, _b, _c;
      var data2 = this.data;
      var _d = __read(Array.isArray(val) ? val : [void 0, val], 2), start = _d[0], end = _d[1];
      var startDatum = data2.find(function(_a3) {
        var time = _a3.time;
        return time === start;
      });
      var endDatum = data2.find(function(_a3) {
        var time = _a3.time;
        return time === end;
      });
      this.states.values = [(_a2 = startDatum === null || startDatum === void 0 ? void 0 : startDatum.time) !== null && _a2 !== void 0 ? _a2 : (_b = data2[0]) === null || _b === void 0 ? void 0 : _b.time, (_c = endDatum === null || endDatum === void 0 ? void 0 : endDatum.time) !== null && _c !== void 0 ? _c : Infinity];
    };
    Timebar2.prototype.setByIndex = function(index2) {
      var _a2, _b, _c, _d;
      var data2 = this.data;
      var _e = __read(index2, 2), startIndex = _e[0], endIndex = _e[1];
      this.states.values = [(_b = (_a2 = data2[startIndex]) === null || _a2 === void 0 ? void 0 : _a2.time) !== null && _b !== void 0 ? _b : data2[0].time, (_d = (_c = this.data[endIndex]) === null || _c === void 0 ? void 0 : _c.time) !== null && _d !== void 0 ? _d : Infinity];
    };
    Object.defineProperty(Timebar2.prototype, "sliderValues", {
      /**
       * 获取 timebar 的 values
       */
      get: function() {
        var _a2 = this.states, values = _a2.values, selectionType = _a2.selectionType;
        var _b = __read(Array.isArray(values) ? values : [void 0, values], 2), start = _b[0], end = _b[1];
        var data2 = this.data;
        var length5 = data2.length;
        var isValue = selectionType === "value";
        var getStartValue = function() {
          var startDatumIndex = data2.findIndex(function(_a3) {
            var time = _a3.time;
            return time === start;
          });
          if (isValue)
            return 0;
          if (startDatumIndex > -1)
            return startDatumIndex / length5;
          return 0;
        };
        var getEndValue = function() {
          if (end === Infinity)
            return 1;
          var endDatumIndex = data2.findIndex(function(_a3) {
            var time = _a3.time;
            return time === end;
          });
          if (endDatumIndex > -1)
            return endDatumIndex / length5;
          if (isValue)
            return 0.5;
          return 1;
        };
        return [getStartValue(), getEndValue()];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Timebar2.prototype, "values", {
      get: function() {
        var _a2 = this.states, values = _a2.values, selectionType = _a2.selectionType;
        var _b = __read(Array.isArray(values) ? values : [this.data[0].time, values], 2), start = _b[0], end = _b[1];
        if (selectionType === "value")
          return end;
        return [start, end];
      },
      enumerable: false,
      configurable: true
    });
    Timebar2.prototype.getDatumByRatio = function(ratio) {
      var data2 = this.data;
      var length5 = data2.length;
      var index2 = Math.floor(ratio * (length5 - 1));
      return data2[index2];
    };
    Object.defineProperty(Timebar2.prototype, "chartHandleIconShape", {
      get: function() {
        var selectionType = this.states.selectionType;
        var height = this.space.timelineBBox.height;
        if (selectionType === "range")
          return function(type) {
            return new ChartModeHandle({ style: { type, height, iconSize: height / 6 } });
          };
        return function() {
          return new Line({ style: { x1: 0, y1: -height / 2, x2: 0, y2: height / 2, lineWidth: 2, stroke: "#c8c8c8" } });
        };
      },
      enumerable: false,
      configurable: true
    });
    Timebar2.prototype.getChartStyle = function(bbox) {
      var _this2 = this;
      var x3 = bbox.x, y3 = bbox.y, width = bbox.width, height = bbox.height;
      var _a2 = this.states, selectionType = _a2.selectionType, chartType = _a2.chartType;
      var data2 = this.data;
      var _b = this.attributes, type = _b.type, userDefinedLabelFormatter = _b.labelFormatter;
      var _c = subStyleProps(this.attributes, "chart"), ignoreType = _c.type, userDefinedChartStyle = __rest(_c, ["type"]);
      var isRange = selectionType === "range";
      if (type === "time") {
        return __assign({
          handleIconShape: function() {
            return new TimeModeHandle({});
          },
          selectionFill: "#2e7ff8",
          selectionFillOpacity: 1,
          showLabelOnInteraction: true,
          handleLabelDy: isRange ? -15 : 0,
          autoFitLabel: isRange,
          handleSpacing: isRange ? -15 : 0,
          trackFill: "#edeeef",
          trackLength: width,
          trackOpacity: 0.5,
          trackRadius: height / 2,
          trackSize: height / 2,
          type: selectionType,
          values: this.sliderValues,
          formatter: function(value) {
            if (userDefinedLabelFormatter)
              return userDefinedLabelFormatter(value);
            var time = _this2.getDatumByRatio(value).time;
            if (typeof time === "number")
              return parseBySeries(time);
            return formatTime(time, "YYYY-MM-DD HH:mm:ss");
          },
          transform: "translate(".concat(x3, ", ").concat(y3, ")"),
          // x,
          // y,
          zIndex: 1
        }, userDefinedChartStyle);
      }
      var handleIconOffset = selectionType === "range" ? 5 : 0;
      var sparklineData = data2.map(function(_a3) {
        var value = _a3.value;
        return value;
      });
      return __assign({
        handleIconOffset,
        handleIconShape: this.chartHandleIconShape,
        selectionFill: "#fff",
        selectionFillOpacity: 0.5,
        selectionType: "invert",
        sparklineSpacing: 0.1,
        sparklineColumnLineWidth: 0,
        sparklineColor: "#d4e5fd",
        sparklineAreaOpacity: 1,
        sparklineAreaLineWidth: 0,
        sparklineData,
        sparklineType: chartType,
        sparklineScale: 0.8,
        trackLength: width,
        trackSize: height,
        type: selectionType,
        values: this.sliderValues,
        // x,
        // y,
        transform: "translate(".concat(x3, ", ").concat(y3, ")"),
        zIndex: 1
      }, userDefinedChartStyle);
    };
    Timebar2.prototype.renderChart = function(bbox) {
      if (bbox === void 0) {
        bbox = this.space.timelineBBox;
      }
      this.timeline.update(this.getChartStyle(bbox));
    };
    Timebar2.prototype.updateSelection = function() {
      this.timeline.setValues(this.sliderValues, true);
      this.handleSliderChange(this.sliderValues);
    };
    Timebar2.prototype.getAxisStyle = function(bbox) {
      var data2 = this.data;
      var _a2 = this.attributes, interval = _a2.interval, userDefinedLabelFormatter = _a2.labelFormatter;
      var userDefinedAxisStyle = subStyleProps(this.attributes, "axis");
      var x3 = bbox.x, y3 = bbox.y, width = bbox.width;
      var axisData = __spreadArray(__spreadArray([], __read(data2), false), [{ time: 0 }], false).map(function(_a3, index2, arr) {
        var time = _a3.time;
        return {
          label: "".concat(time),
          value: index2 / (arr.length - 1),
          time
        };
      });
      var style = __assign({
        startPos: [x3, y3],
        endPos: [x3 + width, y3],
        data: axisData,
        // hide last label
        labelFilter: function(_datum, index2) {
          return index2 < axisData.length - 1;
        },
        labelFormatter: function(_a3) {
          var time = _a3.time;
          return userDefinedLabelFormatter ? userDefinedLabelFormatter(time) : labelFormatter(time, interval);
        }
      }, userDefinedAxisStyle);
      return style;
    };
    Timebar2.prototype.renderAxis = function(bbox) {
      if (bbox === void 0) {
        bbox = this.space.axisBBox;
      }
      var type = this.attributes.type;
      if (type !== "chart")
        return;
      this.axis.update(this.getAxisStyle(bbox));
    };
    Timebar2.prototype.renderController = function(bbox) {
      if (bbox === void 0) {
        bbox = this.space.controllerBBox;
      }
      var type = this.attributes.type;
      var _a2 = this.states, state = _a2.state, speed = _a2.speed, selectionType = _a2.selectionType, chartType = _a2.chartType;
      var userDefinedControllerStyle = subStyleProps(this.attributes, "controller");
      var that = this;
      var style = __assign(__assign(__assign({}, bbox), { iconSize: 20, speed, state, selectionType, chartType, onChange: function(type2, _a3) {
        var value = _a3.value;
        switch (type2) {
          case "reset":
            that.internalReset();
            break;
          case "speed":
            that.handleSpeedChange(value);
            break;
          case "backward":
            that.internalBackward();
            break;
          case "playPause":
            if (value === "play")
              that.internalPlay();
            else
              that.internalPause();
            break;
          case "forward":
            that.internalForward();
            break;
          case "selectionType":
            that.handleSelectionTypeChange(value);
            break;
          case "chartType":
            that.handleChartTypeChange(value);
            break;
          default:
            break;
        }
      } }), userDefinedControllerStyle);
      if (type === "time") {
        style.functions = [["reset", "speed"], ["backward", "playPause", "forward"], ["selectionType"]];
      }
      this.controller.update(style);
    };
    Timebar2.prototype.dispatchOnChange = function(prevValues) {
      var data2 = this.data;
      var onChange = this.attributes.onChange;
      var _a2 = this.states, values = _a2.values, selectionType = _a2.selectionType;
      var _b = __read(values, 2), start = _b[0], end = _b[1];
      var endTime = end === Infinity ? data2.at(-1).time : end;
      var newValues = selectionType === "range" ? [start, endTime] : endTime;
      var isEqual2 = function(val1, val2) {
        if (Array.isArray(val1)) {
          if (!Array.isArray(val2))
            return false;
          if (val1[0] === val2[0]) {
            if (val1[1] === val2[1])
              return true;
            if (val1[1] === Infinity || val2[1] === Infinity)
              return true;
          }
          return false;
        }
        if (Array.isArray(val2))
          return false;
        return val1 === val2;
      };
      if (!prevValues || !isEqual2(prevValues, newValues)) {
        onChange === null || onChange === void 0 ? void 0 : onChange(selectionType === "range" ? [start, endTime] : endTime);
      }
    };
    Timebar2.prototype.internalReset = function(preventEvent) {
      var _a2, _b;
      var selectionType = this.states.selectionType;
      this.internalPause();
      this.setBySliderValues(selectionType === "range" ? [0, 1] : [0, 0]);
      this.renderController();
      this.updateSelection();
      if (!preventEvent) {
        (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onReset) === null || _b === void 0 ? void 0 : _b.call(_a2);
        this.dispatchOnChange();
      }
    };
    Timebar2.prototype.reset = function() {
      this.internalReset();
    };
    Timebar2.prototype.moveSelection = function(direction3, preventEvent) {
      var data2 = this.data;
      var length5 = data2.length;
      var _a2 = this.states, values = _a2.values, selectionType = _a2.selectionType, playMode = _a2.playMode;
      var _b = __read(values, 2), startTime = _b[0], endTime = _b[1];
      var startIndex = data2.findIndex(function(_a3) {
        var time = _a3.time;
        return time === startTime;
      });
      var endIndex = data2.findIndex(function(_a3) {
        var time = _a3.time;
        return time === endTime;
      });
      if (endIndex === -1)
        endIndex = length5;
      var diff = direction3 === "backward" ? -1 : 1;
      var currentIndexes;
      if (selectionType === "range") {
        if (playMode === "acc") {
          currentIndexes = [startIndex, endIndex + diff];
          if (diff === -1 && startIndex === endIndex) {
            currentIndexes = [startIndex, length5];
          }
        } else
          currentIndexes = [startIndex + diff, endIndex + diff];
      } else
        currentIndexes = [startIndex, endIndex + diff];
      var normalizeIndexes = function(indexes) {
        var _a3 = __read(indexes.sort(function(a2, b) {
          return a2 - b;
        }), 2), start = _a3[0], end = _a3[1];
        var clampIndex = function(index2) {
          return clamp_default(index2, 0, length5);
        };
        if (end > length5) {
          if (selectionType === "value")
            return [0, 0];
          if (playMode === "acc")
            return [clampIndex(start), clampIndex(start)];
          return [0, clampIndex(end - start)];
        }
        if (start < 0) {
          if (playMode === "acc")
            return [0, clampIndex(end)];
          return [clampIndex(start + length5 - end), length5];
        }
        return [clampIndex(start), clampIndex(end)];
      };
      var normalizedIndexes = normalizeIndexes(currentIndexes);
      this.setByIndex(normalizedIndexes);
      this.updateSelection();
      return normalizedIndexes;
    };
    Timebar2.prototype.internalBackward = function(preventEvent) {
      var _a2, _b;
      var indexes = this.moveSelection("backward", preventEvent);
      if (!preventEvent) {
        (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onBackward) === null || _b === void 0 ? void 0 : _b.call(_a2);
        this.dispatchOnChange();
      }
      return indexes;
    };
    Timebar2.prototype.backward = function() {
      this.internalBackward();
    };
    Timebar2.prototype.internalPlay = function(preventEvent) {
      var _this2 = this;
      var _a2, _b;
      var data2 = this.data;
      var loop = this.attributes.loop;
      var _c = this.states.speed, speed = _c === void 0 ? 1 : _c;
      this.playInterval = window.setInterval(function() {
        var indexes = _this2.internalForward();
        if (indexes[1] === data2.length && !loop) {
          _this2.internalPause();
          _this2.renderController();
        }
      }, 1e3 / speed);
      this.states.state = "play";
      !preventEvent && ((_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onPlay) === null || _b === void 0 ? void 0 : _b.call(_a2));
    };
    Timebar2.prototype.play = function() {
      this.internalPlay();
    };
    Timebar2.prototype.internalPause = function(preventEvent) {
      var _a2, _b;
      clearInterval(this.playInterval);
      this.states.state = "pause";
      !preventEvent && ((_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onPause) === null || _b === void 0 ? void 0 : _b.call(_a2));
    };
    Timebar2.prototype.pause = function() {
      this.internalPause();
    };
    Timebar2.prototype.internalForward = function(preventEvent) {
      var _a2, _b;
      var indexes = this.moveSelection("forward", preventEvent);
      if (!preventEvent) {
        (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onForward) === null || _b === void 0 ? void 0 : _b.call(_a2);
        this.dispatchOnChange();
      }
      return indexes;
    };
    Timebar2.prototype.forward = function() {
      this.internalForward();
    };
    Timebar2.prototype.handleSpeedChange = function(value) {
      var _a2, _b;
      this.states.speed = value;
      var state = this.states.state;
      if (state === "play") {
        this.internalPause(true);
        this.internalPlay(true);
      }
      (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onSpeedChange) === null || _b === void 0 ? void 0 : _b.call(_a2, value);
    };
    Timebar2.prototype.handleSelectionTypeChange = function(type) {
      var _a2, _b;
      this.states.selectionType = type;
      this.renderChart();
      (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onSelectionTypeChange) === null || _b === void 0 ? void 0 : _b.call(_a2, type);
    };
    Timebar2.prototype.handleChartTypeChange = function(type) {
      var _a2, _b;
      this.states.chartType = type;
      this.renderChart();
      (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onChartTypeChange) === null || _b === void 0 ? void 0 : _b.call(_a2, type);
    };
    Timebar2.prototype.render = function() {
      var _a2 = this.space, axisBBox = _a2.axisBBox, controllerBBox = _a2.controllerBBox, timelineBBox = _a2.timelineBBox;
      this.renderController(controllerBBox);
      this.renderAxis(axisBBox);
      this.renderChart(timelineBBox);
      if (this.states.state === "play")
        this.internalPlay();
    };
    Timebar2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.internalPause(true);
    };
    Timebar2.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        axisLabelFill: "#6e6e6e",
        axisLabelTextAlign: "left",
        axisLabelTextBaseline: "top",
        axisLabelTransform: "translate(5, -12)",
        axisLineLineWidth: 1,
        axisLineStroke: "#cacdd1",
        axisTickLength: 15,
        axisTickLineWidth: 1,
        axisTickStroke: "#cacdd1",
        chartShowLabel: false,
        chartType: "line",
        controllerAlign: "center",
        controllerHeight: 40,
        data: [],
        interval: "day",
        loop: false,
        playMode: "acc",
        selectionType: "range",
        type: "time"
      }
    };
    return Timebar2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/tag/index.js
function adjust(container, paddingLeft, paddingTop, align, baseline) {
  var bounds = container.getLocalBounds();
  var x3 = 0;
  var y3 = 0;
  if (align === "start")
    x3 = paddingLeft;
  if (align === "center")
    x3 = -bounds.halfExtents[0];
  if (align === "end")
    x3 = -paddingLeft - bounds.halfExtents[0] * 2;
  if (baseline === "top")
    y3 = paddingTop + bounds.halfExtents[1];
  if (baseline === "middle")
    y3 = 0;
  if (baseline === "bottom")
    y3 = paddingTop - bounds.halfExtents[1] * 2;
  container.setLocalPosition([x3, y3]);
}
function getTextPosition(markerShape, spacing) {
  var bounds = markerShape.getLocalBounds();
  return {
    x: bounds.halfExtents[0] ? bounds.max[0] + (spacing || 0) : markerShape.style.x,
    y: bounds.halfExtents[1] ? (bounds.min[1] + bounds.max[1]) / 2 : markerShape.style.y
  };
}
var Tag = (
  /** @class */
  function(_super) {
    __extends(Tag2, _super);
    function Tag2(options) {
      return _super.call(this, options, {
        padding: 4,
        spacing: 4
      }) || this;
    }
    Tag2.prototype.render = function(attributes, container) {
      var _a2 = attributes.padding, padding = _a2 === void 0 ? 0 : _a2, marker = attributes.marker, text = attributes.text, radius = attributes.radius, spacing = attributes.spacing, align = attributes.align, verticalAlign = attributes.verticalAlign;
      var labelStyle = subStyleProps(attributes, "label");
      var backgroundStyle = subStyleProps(attributes, "background");
      var _b = __read(parseSeriesAttr(padding), 4), pt = _b[0], pr = _b[1], pb = _b[2], pl = _b[3];
      var group2 = maybeAppend(container, ".tag-content", "g").attr("className", "tag-content").style("zIndex", 0).node();
      var markerStyle = marker || { symbol: "triangle", size: 0 };
      var markerShape = maybeAppend(group2, ".tag-marker", function() {
        return new Marker({ style: markerStyle });
      }).attr("className", "tag-marker").update(markerStyle).node();
      var _c = getTextPosition(markerShape, spacing), x3 = _c.x, y3 = _c.y;
      select(group2).maybeAppendByClassName("tag-text", function() {
        return new Text2();
      }).styles(__assign(__assign({ fontSize: 12, text: isNil(text) ? "" : "".concat(text), x: x3, y: y3 }, labelStyle), { textBaseline: "middle" })).call(function(selection) {
        if (!text)
          selection.remove();
      });
      adjust(group2, pl, pt, align || "start", verticalAlign || "top");
      var bounds = group2.getLocalBounds();
      select(container).maybeAppendByClassName("tag-background", "rect").styles(__assign({ zIndex: -1, y: bounds.min[1] - pt, x: bounds.min[0] - pl, width: backgroundStyle !== null ? pl + pr + bounds.halfExtents[0] * 2 : 0, height: backgroundStyle !== null ? pt + pb + bounds.halfExtents[1] * 2 : 0, radius: radius !== null && radius !== void 0 ? radius : 2, fill: "#fafafa", stroke: "#d9d9d9", lineWidth: 1 }, backgroundStyle));
    };
    Tag2.tag = "tag";
    return Tag2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/button/constant.js
var SIZE_STYLE = {
  small: {
    textFontSize: 10,
    buttonWidth: 40,
    buttonHeight: 20,
    markerSize: 8
  },
  middle: {
    textFontSize: 12,
    buttonWidth: 60,
    buttonHeight: 30,
    markerSize: 12
  },
  large: {
    textFontSize: 16,
    buttonWidth: 80,
    buttonHeight: 40,
    markerSize: 16
  }
};
var TYPE_STYLE = {
  primary: {
    default: { textFill: "#fff", buttonFill: "#1890ff", buttonLineWidth: 0, markerFill: "#1890ff" },
    active: {
      buttonFill: "#40a9ff",
      markerFill: "#40a9ff"
    },
    disabled: {}
  },
  dashed: {
    default: {
      buttonFill: "transparent",
      buttonStroke: "#bbb",
      buttonLineDash: [5, 5]
    },
    active: {},
    disabled: {}
  },
  link: {
    default: { textFill: "#1890ff", buttonFill: "transparent", buttonLineWidth: 0, markerFill: "#1890ff" },
    active: {},
    disabled: {}
  },
  text: {
    default: { textFill: "#000", buttonFill: "transparent", buttonLineWidth: 0, markerFill: "#000" },
    active: {},
    disabled: {}
  },
  default: {
    default: { textFill: "#000", buttonFill: "transparent", buttonStroke: "#bbb", markerFill: "#bbb" },
    active: { textFill: "#1890ff", buttonStroke: "#1890ff", markerStroke: "#1890ff" },
    disabled: {}
  }
};
var DISABLED_STYLE = {
  // 严格需要替换的样式
  strict: {
    textFill: "#b8b8b8"
  },
  buttonStroke: "#d9d9d9",
  buttonFill: "#f5f5f5",
  markerStroke: "#d9d9d9"
};

// node_modules/@antv/component/esm/ui/button/index.js
var Button = (
  /** @class */
  function(_super) {
    __extends(Button2, _super);
    function Button2(options) {
      var _this2 = _super.call(this, options, {
        cursor: "pointer",
        padding: 10,
        size: "middle",
        type: "default",
        text: "",
        state: "default",
        markerAlign: "left",
        markerSpacing: 5,
        default: {
          buttonLineWidth: 1,
          buttonRadius: 5
        },
        active: {}
      }) || this;
      _this2.state = "default";
      _this2.clickEvents = function() {
        var _a2 = _this2.attributes, onClick = _a2.onClick, state = _a2.state;
        if (state !== "disabled")
          onClick === null || onClick === void 0 ? void 0 : onClick.call(_this2, _this2);
      };
      _this2.mouseenterEvent = function() {
        var state = _this2.attributes.state;
        if (state !== "disabled") {
          _this2.state = "active";
          _this2.render(_this2.attributes, _this2);
        }
      };
      _this2.mouseleaveEvent = function() {
        var state = _this2.attributes.state;
        _this2.state = state;
        _this2.render(_this2.attributes, _this2);
      };
      return _this2;
    }
    Object.defineProperty(Button2.prototype, "markerSize", {
      get: function() {
        var markerSymbol = this.attributes.markerSymbol;
        var markerStyle = this.getStyle("marker");
        var markerSize = !markerSymbol ? 0 : (markerStyle === null || markerStyle === void 0 ? void 0 : markerStyle.size) || 2;
        return markerSize;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Button2.prototype, "textAvailableWidth", {
      /* 获得文本可用宽度 */
      get: function() {
        var _a2 = this.attributes, markerSymbol = _a2.markerSymbol, padding = _a2.padding, ellipsis = _a2.ellipsis, bWidth = _a2.width, spacing = _a2.markerSpacing;
        if (!ellipsis)
          return Infinity;
        var width = is_undefined_default(bWidth) ? this.getStyle("button").width : bWidth;
        if (markerSymbol)
          return width - padding * 2 - spacing - this.markerSize;
        return width - padding * 2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Button2.prototype, "buttonHeight", {
      get: function() {
        var height = this.attributes.height;
        if (height)
          return +height;
        return +this.getStyle("button").height;
      },
      enumerable: false,
      configurable: true
    });
    Button2.prototype.getStyle = function(name) {
      var _a2 = this.attributes, size2 = _a2.size, type = _a2.type;
      var state = this.state;
      var mixedStyle = deep_mix_default({}, SIZE_STYLE[size2], TYPE_STYLE[type][state], this.attributes.default, this.attributes[state]);
      if (state === "disabled") {
        Object.keys(mixedStyle).forEach(function(key) {
          if (key in DISABLED_STYLE) {
            mixedStyle[key] = DISABLED_STYLE[key];
          }
        });
        Object.keys(DISABLED_STYLE.strict).forEach(function(key) {
          mixedStyle[key] = DISABLED_STYLE.strict[key];
        });
        deep_mix_default(mixedStyle, this.attributes.disabled || {});
      }
      return subStyleProps(mixedStyle, name);
    };
    Button2.prototype.render = function(attributes, container) {
      var _a2 = attributes.text, text = _a2 === void 0 ? "" : _a2, _b = attributes.padding, padding = _b === void 0 ? 0 : _b, markerSymbol = attributes.markerSymbol, _c = attributes.markerSpacing, markerSpacing = _c === void 0 ? 0 : _c, _d = attributes.x, x3 = _d === void 0 ? 0 : _d, _e = attributes.y, y3 = _e === void 0 ? 0 : _e;
      container.attr({
        cursor: this.state === "disabled" ? "not-allowed" : "pointer"
      });
      var _f = __read(parseSeriesAttr(padding), 4), pt = _f[0], pr = _f[1], pb = _f[2], pl = _f[3];
      var height = this.buttonHeight;
      var markerStyle = this.getStyle("marker");
      var markerSize = this.markerSize;
      var style = __assign(__assign({}, markerStyle), { symbol: markerSymbol, x: x3 + pl + markerSize / 2, y: y3 + height / 2, size: markerSize });
      var markerShape = maybeAppend(container, ".marker", function() {
        return new Marker({ className: "marker", style });
      }).update({ style }).node();
      var bounds = markerShape.getLocalBounds();
      var textStyle = this.getStyle("text");
      this.textShape = maybeAppend(container, ".text", "text").attr("className", "text").styles(__assign(__assign({ x: x3 + (markerSize ? bounds.max[0] + markerSpacing : pl), y: y3 + height / 2 }, textStyle), { text, textAlign: "left", textBaseline: "middle", wordWrap: true, wordWrapWidth: this.textAvailableWidth, maxLines: 1, textOverflow: "..." })).node();
      var textBounds = this.textShape.getLocalBounds();
      var buttonStyle = this.getStyle("button");
      select(container).maybeAppendByClassName(".background", "rect").styles(__assign(__assign({ zIndex: -1 }, buttonStyle), { x: x3, y: y3, height, width: pl + (markerSize ? markerSize + markerSpacing : 0) + textBounds.halfExtents[0] * 2 + pr }));
    };
    Button2.prototype.update = function(attr2) {
      if (attr2 === void 0) {
        attr2 = {};
      }
      this.attr(deep_mix_default({}, this.attributes, attr2));
      var state = this.attributes.state;
      this.state = state;
      this.render(this.attributes, this);
    };
    Button2.prototype.setState = function(state) {
      this.update({ state });
    };
    Button2.prototype.hide = function() {
      this.style.visibility = "hidden";
    };
    Button2.prototype.show = function() {
      this.style.visibility = "visible";
    };
    Button2.prototype.bindEvents = function() {
      this.addEventListener("click", this.clickEvents);
      this.addEventListener("mouseenter", this.mouseenterEvent);
      this.addEventListener("mouseleave", this.mouseleaveEvent);
    };
    Button2.tag = "button";
    return Button2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/breadcrumb/index.js
var Breadcrumb = (
  /** @class */
  function(_super) {
    __extends(Breadcrumb2, _super);
    function Breadcrumb2(options) {
      return _super.call(this, deep_mix_default({}, Breadcrumb2.defaultOptions, options)) || this;
    }
    Breadcrumb2.prototype.render = function(attributes, container) {
      var x3 = attributes.x, y3 = attributes.y, items = attributes.items, textStyle = attributes.textStyle, _a2 = attributes.padding, padding = _a2 === void 0 ? 0 : _a2, width = attributes.width, separator = attributes.separator;
      var _b = __read(parseSeriesAttr(padding), 3), top = _b[0], right = _b[1], left = _b[2];
      var tagStyle = subStyleProps(attributes, "tag");
      var selection = maybeAppend(container, ".container", "g").styles({
        className: "container",
        x: x3 + left,
        y: y3 + top
      });
      var cursorX = 0;
      var cursorY = 0;
      selection.node().removeChildren();
      var _loop_1 = function(i2) {
        var datum = items[i2];
        var shape = new Tag({
          className: "breadcrumb-item",
          style: __assign(__assign(__assign(__assign({ transform: "translate(".concat(cursorX, ", ").concat(cursorY, ")") }, tagStyle), { text: isNil(datum.text) ? datum.id : datum.text }), pick_default(datum, ["marker"])), {
            // 强制不需要背景
            padding: 0
          })
        });
        selection.append(function() {
          return shape;
        });
        var bounds = shape.getLocalBounds();
        var shapeW = bounds.halfExtents[0] * 2;
        var shapeH = bounds.halfExtents[1] * 2;
        cursorX += shapeW;
        if (!isNil(width)) {
          var avaliableWidth = width - right;
          if (cursorX > avaliableWidth) {
            shape.attr({ transform: "translateY(".concat(cursorY + shapeH, ")") });
            cursorX = shapeW;
            cursorY += shapeH;
          }
        }
        this_1.bindInnerEvents(shape, datum);
        var _c = separator || {}, _d = _c.spacing, spacing = _d === void 0 ? 0 : _d, _e = _c.text, text = _e === void 0 ? "/" : _e, style = _c.style;
        if (i2 !== items.length - 1) {
          var shape_1 = new Text2({
            className: "".concat(Breadcrumb2.tag, "-separator"),
            id: "".concat(Breadcrumb2.tag, "-separator-").concat(i2),
            style: __assign(__assign({ x: cursorX + spacing, y: cursorY + shapeH / 2 }, style), { text, textAlign: "end", textBaseline: "middle" })
          });
          selection.append(function() {
            return shape_1;
          });
          var bounds_1 = shape_1.getLocalBounds();
          cursorX += bounds_1.halfExtents[0] * 2 + spacing;
        }
      };
      var this_1 = this;
      for (var i = 0; i < items.length; i++) {
        _loop_1(i);
      }
    };
    Breadcrumb2.prototype.update = function(cfg) {
      this.attr(deep_mix_default({}, this.attributes, cfg));
      this.render(this.attributes, this);
    };
    Breadcrumb2.prototype.bindInnerEvents = function(shape, item) {
      var _a2 = this.attributes, items = _a2.items, onClick = _a2.onClick;
      if (onClick) {
        shape.addEventListener("click", function() {
          onClick.call(shape, item.id, item, items);
        });
      }
    };
    Breadcrumb2.tag = "breadcrumb";
    Breadcrumb2.defaultOptions = {
      style: {
        separator: {
          text: "/",
          style: {
            fontSize: 14,
            fill: "rgba(0, 0, 0, 0.45)"
          },
          spacing: 8
        },
        textStyle: {
          default: {
            fontSize: 14,
            fill: "rgba(0, 0, 0, 0.45)"
          },
          active: {
            fill: "#5468ff",
            cursor: "pointer"
          }
        },
        padding: [8, 8, 8, 8]
      }
    };
    return Breadcrumb2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/scrollbar/index.js
var Scrollbar = (
  /** @class */
  function(_super) {
    __extends(Scrollbar2, _super);
    function Scrollbar2(options) {
      var _this2 = _super.call(this, options, {
        x: 0,
        y: 0,
        isRound: true,
        orientation: "vertical",
        padding: [2, 2, 2, 2],
        scrollable: true,
        slidable: true,
        thumbCursor: "default",
        trackSize: 10,
        value: 0
      }) || this;
      _this2.range = [0, 1];
      _this2.onValueChange = function(oldValue) {
        var newValue = _this2.attributes.value;
        if (oldValue === newValue)
          return;
        var evtVal = {
          detail: {
            oldValue,
            value: newValue
          }
        };
        _this2.dispatchEvent(new CustomEvent("scroll", evtVal));
        _this2.dispatchEvent(new CustomEvent("valuechange", evtVal));
      };
      _this2.onTrackClick = function(e) {
        var slidable = _this2.attributes.slidable;
        if (!slidable)
          return;
        var _a2 = __read(_this2.getLocalPosition(), 2), x3 = _a2[0], y3 = _a2[1];
        var _b = __read(_this2.padding, 4), top = _b[0], left = _b[3];
        var basePos = _this2.getOrientVal([x3 + left, y3 + top]);
        var clickPos = _this2.getOrientVal(getEventPos(e));
        var value = (clickPos - basePos) / _this2.trackLength;
        _this2.setValue(value, true);
      };
      _this2.onThumbMouseenter = function(e) {
        _this2.dispatchEvent(new CustomEvent("thumbMouseenter", { detail: e.detail }));
      };
      _this2.onTrackMouseenter = function(e) {
        _this2.dispatchEvent(new CustomEvent("trackMouseenter", { detail: e.detail }));
      };
      _this2.onThumbMouseleave = function(e) {
        _this2.dispatchEvent(new CustomEvent("thumbMouseleave", { detail: e.detail }));
      };
      _this2.onTrackMouseleave = function(e) {
        _this2.dispatchEvent(new CustomEvent("trackMouseleave", { detail: e.detail }));
      };
      return _this2;
    }
    Object.defineProperty(Scrollbar2.prototype, "padding", {
      get: function() {
        var padding = this.attributes.padding;
        return parseSeriesAttr(padding);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar2.prototype, "value", {
      get: function() {
        var value = this.attributes.value;
        var _a2 = __read(this.range, 2), min5 = _a2[0], max6 = _a2[1];
        return clamp_default(value, min5, max6);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar2.prototype, "trackLength", {
      get: function() {
        var _a2 = this.attributes, viewportLength = _a2.viewportLength, _b = _a2.trackLength, trackLength = _b === void 0 ? viewportLength : _b;
        return trackLength;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar2.prototype, "availableSpace", {
      get: function() {
        var trackSize = this.attributes.trackSize;
        var trackLength = this.trackLength;
        var _a2 = __read(this.padding, 4), top = _a2[0], right = _a2[1], bottom = _a2[2], left = _a2[3];
        var _b = __read(this.getOrientVal([
          [trackLength, trackSize],
          [trackSize, trackLength]
        ]), 2), width = _b[0], height = _b[1];
        return {
          x: left,
          y: top,
          width: +width - (left + right),
          height: +height - (top + bottom)
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar2.prototype, "trackRadius", {
      get: function() {
        var _a2 = this.attributes, isRound = _a2.isRound, trackSize = _a2.trackSize;
        if (!isRound)
          return 0;
        return trackSize / 2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar2.prototype, "thumbRadius", {
      get: function() {
        var _a2 = this.attributes, isRound = _a2.isRound, thumbRadius = _a2.thumbRadius;
        if (!isRound)
          return 0;
        var _b = this.availableSpace, width = _b.width, height = _b.height;
        return thumbRadius || this.getOrientVal([height, width]) / 2;
      },
      enumerable: false,
      configurable: true
    });
    Scrollbar2.prototype.getValues = function(value) {
      if (value === void 0) {
        value = this.value;
      }
      var _a2 = this.attributes, viewportLength = _a2.viewportLength, contentLength = _a2.contentLength;
      var unit = viewportLength / contentLength;
      var _b = __read(this.range, 2), min5 = _b[0], max6 = _b[1];
      var start = value * (max6 - min5 - unit);
      return [start, start + unit];
    };
    Scrollbar2.prototype.getValue = function() {
      return this.value;
    };
    Scrollbar2.prototype.renderSlider = function(container) {
      var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, orientation = _a2.orientation, trackSize = _a2.trackSize, padding = _a2.padding, slidable = _a2.slidable;
      var trackStyle = subStyleProps(this.attributes, "track");
      var selectionStyle = subStyleProps(this.attributes, "thumb");
      var style = __assign(__assign({ x: x3, y: y3, brushable: false, orientation, padding, selectionRadius: this.thumbRadius, showHandle: false, slidable, trackLength: this.trackLength, trackRadius: this.trackRadius, trackSize, values: this.getValues() }, superStyleProps(trackStyle, "track")), superStyleProps(selectionStyle, "selection"));
      this.slider = select(container).maybeAppendByClassName("scrollbar", function() {
        return new Slider({ style });
      }).update(style).node();
    };
    Scrollbar2.prototype.render = function(attributes, container) {
      this.renderSlider(container);
    };
    Scrollbar2.prototype.setValue = function(value, animate2) {
      if (animate2 === void 0) {
        animate2 = false;
      }
      var oldValue = this.attributes.value;
      var _a2 = __read(this.range, 2), min5 = _a2[0], max6 = _a2[1];
      this.slider.setValues(this.getValues(clamp_default(value, min5, max6)), animate2);
      this.onValueChange(oldValue);
    };
    Scrollbar2.prototype.bindEvents = function() {
      var _this2 = this;
      this.slider.addEventListener("trackClick", function(e) {
        e.stopPropagation();
        _this2.onTrackClick(e.detail);
      });
      this.onHover();
    };
    Scrollbar2.prototype.getOrientVal = function(values) {
      var orientation = this.attributes.orientation;
      return orientation === "horizontal" ? values[0] : values[1];
    };
    Scrollbar2.prototype.onHover = function() {
      this.slider.addEventListener("selectionMouseenter", this.onThumbMouseenter);
      this.slider.addEventListener("trackMouseenter", this.onTrackMouseenter);
      this.slider.addEventListener("selectionMouseleave", this.onThumbMouseleave);
      this.slider.addEventListener("trackMouseleave", this.onTrackMouseleave);
    };
    Scrollbar2.tag = "scrollbar";
    return Scrollbar2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/switch/constant.js
var SIZE_STYLE2 = {
  default: {
    sizeStyle: {
      width: 44,
      height: 22,
      radius: 11
    },
    tagStyle: {
      textStyle: {
        fontSize: 12,
        lineHeight: 16,
        fill: "#fff"
      },
      padding: 0
    },
    markerStyle: {
      size: 11
    }
  },
  small: {
    sizeStyle: {
      width: 28,
      height: 16,
      radius: 8
    },
    tagStyle: {
      textStyle: {
        fontSize: 10,
        lineHeight: 14,
        fill: "#fff"
      },
      padding: 0
    },
    markerStyle: {
      size: 8
    }
  },
  mini: {
    sizeStyle: {
      width: 20,
      height: 14,
      radius: 7
    },
    tagStyle: {
      textStyle: {
        fontSize: 7,
        lineHeight: 10,
        fill: "#fff"
      },
      padding: 0
    },
    markerStyle: {
      size: 7
    }
  }
};

// node_modules/@antv/component/esm/ui/switch/index.js
var OPTION_COLOR = "#1890FF";
var CLOSE_COLOR = "#00000040";
function getHandleShapeStyle(shape, spacing, checked) {
  if (spacing === void 0) {
    spacing = 0;
  }
  if (checked === void 0) {
    checked = true;
  }
  var size2 = Number(shape.style.height) - spacing * 2;
  return {
    x: checked ? Number(shape.style.width) + Number(shape.style.x) - spacing - size2 : Number(shape.style.x) + spacing,
    y: Number(shape.style.y) + spacing,
    width: size2,
    height: size2,
    radius: size2 / 2
  };
}
function getTagShapeStyle(backgroundStyle, _a2, spacing, checked) {
  var width = _a2.width, height = _a2.height;
  if (spacing === void 0) {
    spacing = 0;
  }
  if (checked === void 0) {
    checked = true;
  }
  return {
    x: checked ? Number(backgroundStyle.x) + spacing : Number(backgroundStyle.width) + Number(backgroundStyle.x) - width,
    y: Number(backgroundStyle.y) + (Number(backgroundStyle.height) - height) / 2
  };
}
var Switch = (
  /** @class */
  function(_super) {
    __extends(Switch2, _super);
    function Switch2(options) {
      return _super.call(this, options, {
        x: 0,
        y: 0,
        size: "default",
        spacing: 2,
        checked: true,
        disabled: false
      }) || this;
    }
    Switch2.prototype.render = function(attributes, container) {
      var _this2 = this;
      var size2 = attributes.size, spacing = attributes.spacing, disabled = attributes.disabled, checked = attributes.checked, unCheckedChildren = attributes.unCheckedChildren, checkedChildren = attributes.checkedChildren;
      var group2 = select(container).maybeAppendByClassName("switch-content", "g").node();
      var bounds = group2.getLocalBounds();
      var _a2 = get_default(SIZE_STYLE2, size2, SIZE_STYLE2.default), sizeStyle = _a2.sizeStyle, tagStyle = _a2.tagStyle;
      var cursor = disabled ? "no-drop" : "pointer";
      var color2 = checked ? OPTION_COLOR : CLOSE_COLOR;
      var backgroundStyle = sizeStyle;
      var tagCfg = checked ? checkedChildren : unCheckedChildren;
      if (checkedChildren || unCheckedChildren) {
        select(group2).maybeAppendByClassName("switch-tag", function() {
          return new Tag({});
        }).call(function(selection) {
          var tagShape = selection.node();
          tagShape.update(__assign(__assign({ cursor, backgroundStyle: null, text: false, marker: false }, tagStyle), tagCfg));
          var _a3 = (tagShape === null || tagShape === void 0 ? void 0 : tagShape.getLocalBounds()) || {}, max6 = _a3.max, min5 = _a3.min;
          var width = max6[0] - min5[0] + sizeStyle.radius;
          var height = max6[1] - min5[1];
          var backgroundWidth = Math.max(width + sizeStyle.height + 2, sizeStyle.width);
          backgroundStyle = __assign(__assign({}, sizeStyle), { width: backgroundWidth });
          tagShape.update(getTagShapeStyle({
            x: bounds.min[0],
            y: bounds.min[1],
            width: backgroundWidth,
            height: backgroundStyle.height
          }, { width, height }, backgroundStyle.radius, checked));
        });
      }
      var backgroundShape = select(group2).maybeAppendByClassName("switch-background", "rect").styles(__assign({ zIndex: (group2.style.zIndex || 0) - 1, x: bounds.min[0], y: bounds.min[1], fill: color2, cursor, fillOpacity: disabled ? 0.4 : 1 }, backgroundStyle)).node();
      var backgroundStrokeShape = select(group2).maybeAppendByClassName("switch-background-stroke", "rect").styles(__assign({ zIndex: (group2.style.zIndex || 0) - 2, x: bounds.min[0], y: bounds.min[1], stroke: color2, lineWidth: 0 }, backgroundStyle)).node();
      select(group2).maybeAppendByClassName("switch-handle", "rect").styles({
        fill: "#fff",
        cursor
      }).call(function(selection) {
        var _a3, _b;
        var handleShape = selection.node();
        var newHandleShapeStyle = getHandleShapeStyle(backgroundShape, spacing, checked);
        var oldHandleShapeStyle = getHandleShapeStyle(backgroundShape, spacing, !checked);
        if (handleShape.attr("x") && !is_equal_default(newHandleShapeStyle, oldHandleShapeStyle) && _this2.checked !== checked) {
          handleShape.attr(oldHandleShapeStyle);
          (_a3 = handleShape.getAnimations()[0]) === null || _a3 === void 0 ? void 0 : _a3.cancel();
          (_b = backgroundStrokeShape.getAnimations()[0]) === null || _b === void 0 ? void 0 : _b.cancel();
          handleShape.animate([{ x: oldHandleShapeStyle.x }, { x: newHandleShapeStyle.x }], {
            duration: 120,
            fill: "both"
          });
          backgroundStrokeShape.animate([
            { lineWidth: 0, strokeOpacity: 0.5 },
            { lineWidth: 14, strokeOpacity: 0 }
          ], {
            duration: 400,
            easing: "ease-on"
          });
        } else {
          handleShape.attr(newHandleShapeStyle);
        }
      });
      this.checked = !!checked;
    };
    Switch2.tag = "switch";
    return Switch2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/crosshair/constant.js
var CROSSHAIR_BASE_DEFAULT_STYLE = {
  tagText: "",
  lineStroke: "#416180",
  lineStrokeOpacity: 0.45,
  lineLineWidth: 1,
  lineLineDash: [5, 5]
};
var LINE_CROSSHAIR_DEFAULT_STYLE = deepAssign({}, CROSSHAIR_BASE_DEFAULT_STYLE, {
  type: "line",
  tagPosition: "start",
  tagAlign: "center",
  tagVerticalAlign: "bottom"
});
var CIRCLE_CROSSHAIR_DEFAULT_STYLE = deepAssign({}, CROSSHAIR_BASE_DEFAULT_STYLE, {
  type: "circle",
  defaultRadius: 0
});
var POLYGON_CROSSHAIR_DEFAULT_STYLE = deepAssign({}, CROSSHAIR_BASE_DEFAULT_STYLE, {
  type: "polygon",
  defaultRadius: 0,
  startAngle: 0
});

// node_modules/@antv/component/esm/ui/crosshair/base.js
var CrosshairBase = (
  /** @class */
  function(_super) {
    __extends(CrosshairBase2, _super);
    function CrosshairBase2(options) {
      return _super.call(this, options, CROSSHAIR_BASE_DEFAULT_STYLE) || this;
    }
    Object.defineProperty(CrosshairBase2.prototype, "localPointer", {
      /**
       * 获得 pointer 的相对坐标
       */
      get: function() {
        var _a2 = __read(this.getPosition(), 2), bx = _a2[0], by = _a2[1];
        var _b = __read(this.pointer, 2), x3 = _b[0], y3 = _b[1];
        return [x3 - bx, y3 - by];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CrosshairBase2.prototype, "tagStyle", {
      get: function() {
        var style = subStyleProps(this.attributes, "tag");
        return style;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CrosshairBase2.prototype, "crosshairStyle", {
      get: function() {
        var style = subStyleProps(this.attributes, "line");
        return __assign(__assign({}, style), { d: this.crosshairPath });
      },
      enumerable: false,
      configurable: true
    });
    CrosshairBase2.prototype.render = function(attributes, container) {
      var group2 = select(container).maybeAppendByClassName(".crosshair-group", "g").node();
      this.shapesGroup = group2;
      var tagStyle = this.tagStyle;
      var crosshairStyle = this.crosshairStyle;
      this.tagShape = select(group2).maybeAppendByClassName("crosshair-tag", function() {
        return new Tag({ style: tagStyle });
      }).styles(tagStyle).node();
      this.crosshairShape = select(group2).maybeAppendByClassName(".crosshair-path", "path").styles(crosshairStyle).node();
      this.adjustLayout();
    };
    CrosshairBase2.prototype.setPointer = function(pointer) {
      this.pointer = pointer;
    };
    CrosshairBase2.tag = "crosshair-base";
    return CrosshairBase2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/crosshair/line.js
var LineCrosshair = (
  /** @class */
  function(_super) {
    __extends(LineCrosshair2, _super);
    function LineCrosshair2(options) {
      return _super.call(this, deepAssign({}, LineCrosshair2.defaultOptions, options)) || this;
    }
    Object.defineProperty(LineCrosshair2.prototype, "crosshairPath", {
      get: function() {
        var _a2 = this.attributes, _b = __read(_a2.startPos, 2), sx = _b[0], sy = _b[1], _c = __read(_a2.endPos, 2), ex = _c[0], ey = _c[1];
        var path = [["M", 0, 0], ["L", ex - sx, ey - sy], ["Z"]];
        return path;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(LineCrosshair2.prototype, "localPointer", {
      /**
       * 获得 pointer 的相对坐标
       */
      get: function() {
        if (!this.pointer)
          return this.attributes.startPos;
        var _a2 = __read(this.getPosition(), 2), bx = _a2[0], by = _a2[1];
        var _b = __read(this.pointer, 2), x3 = _b[0], y3 = _b[1];
        return [x3 - bx, y3 - by];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(LineCrosshair2.prototype, "isVertical", {
      get: function() {
        var _a2 = this.attributes, _b = __read(_a2.startPos, 2), x1 = _b[0], y1 = _b[1], _c = __read(_a2.endPos, 2), x22 = _c[0], y22 = _c[1];
        return x1 === x22 && y1 !== y22;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(LineCrosshair2.prototype, "tagShapeSpace", {
      get: function() {
        var _a2 = getShapeSpace(this.tagShape), width = _a2.width, height = _a2.height;
        return { width, height };
      },
      enumerable: false,
      configurable: true
    });
    LineCrosshair2.prototype.update = function(cfg) {
      _super.prototype.update.call(this, cfg);
    };
    LineCrosshair2.prototype.setPointer = function(pointer) {
      _super.prototype.setPointer.call(this, pointer);
      this.adjustPosition();
    };
    LineCrosshair2.prototype.setText = function(text) {
      this.tagShape.update({ text });
      this.adjustTag();
    };
    LineCrosshair2.prototype.adjustLayout = function() {
      this.adjustPosition();
      this.adjustTag();
    };
    LineCrosshair2.prototype.adjustPosition = function() {
      var _a2 = __read(this.localPointer, 2), lx = _a2[0], ly = _a2[1];
      var _b = __read(this.attributes.startPos, 2), sx = _b[0], sy = _b[1];
      var targetPos = this.getOrientVal([sx, ly], [lx, sy]);
      this.shapesGroup.setLocalPosition(targetPos);
    };
    LineCrosshair2.prototype.adjustTag = function() {
      var _a2 = this.attributes, tagText = _a2.tagText, tagPosition = _a2.tagPosition, _b = __read(_a2.startPos, 2), x1 = _b[0], y1 = _b[1], _c = __read(_a2.endPos, 2), x22 = _c[0], y22 = _c[1];
      if (!tagText || tagText === "") {
        hide(this.tagShape);
        return;
      }
      show(this.tagShape);
      var _d = this.tagShapeSpace, width = _d.width, height = _d.height;
      var _e = __read(this.getOrientVal({
        start: [-width / 2, height / 2],
        end: [x22 - x1 + width / 2, height / 2]
      }, {
        start: [0, 0],
        end: [0, y22 - y1 + height]
      })[tagPosition], 2), xOffset = _e[0], yOffset = _e[1];
      this.tagShape.setLocalPosition(xOffset, yOffset);
    };
    LineCrosshair2.prototype.getOrientVal = function(v1, v2) {
      return this.isVertical ? v2 : v1;
    };
    LineCrosshair2.tag = "line-crosshair";
    LineCrosshair2.defaultOptions = {
      style: LINE_CROSSHAIR_DEFAULT_STYLE
    };
    return LineCrosshair2;
  }(CrosshairBase)
);

// node_modules/@antv/component/esm/ui/crosshair/circle.js
var CircleCrosshair = (
  /** @class */
  function(_super) {
    __extends(CircleCrosshair2, _super);
    function CircleCrosshair2(options) {
      return _super.call(this, deepAssign({}, CircleCrosshair2.defaultOptions, options)) || this;
    }
    Object.defineProperty(CircleCrosshair2.prototype, "crosshairPath", {
      get: function() {
        return this.createCirclePath();
      },
      enumerable: false,
      configurable: true
    });
    CircleCrosshair2.prototype.update = function(cfg) {
      _super.prototype.update.call(this, cfg);
    };
    CircleCrosshair2.prototype.setPointer = function(_a2) {
      var _b = __read(_a2, 2), x3 = _b[0], y3 = _b[1];
      _super.prototype.setPointer.call(this, [x3, y3]);
      var _c = __read(this.localPointer, 2), lx = _c[0], ly = _c[1];
      var _d = __read(this.attributes.center, 2), cx = _d[0], cy = _d[1];
      var path = this.createCirclePath(Math.pow(Math.pow(lx - cx, 2) + Math.pow(ly - cy, 2), 0.5));
      this.crosshairShape.attr({ d: path });
    };
    CircleCrosshair2.prototype.adjustLayout = function() {
      hide(this.tagShape);
    };
    CircleCrosshair2.prototype.createCirclePath = function(radius) {
      var _a2 = this.attributes, _b = __read(_a2.center, 2), x3 = _b[0], y3 = _b[1], defaultRadius = _a2.defaultRadius;
      return circle(x3, y3, radius || defaultRadius);
    };
    CircleCrosshair2.tag = "circle-crosshair";
    CircleCrosshair2.defaultOptions = {
      style: CIRCLE_CROSSHAIR_DEFAULT_STYLE
    };
    return CircleCrosshair2;
  }(CrosshairBase)
);

// node_modules/@antv/component/esm/ui/crosshair/polygon.js
var PolygonCrosshair = (
  /** @class */
  function(_super) {
    __extends(PolygonCrosshair2, _super);
    function PolygonCrosshair2(options) {
      return _super.call(this, deepAssign({}, PolygonCrosshair2.defaultOptions, options)) || this;
    }
    Object.defineProperty(PolygonCrosshair2.prototype, "crosshairPath", {
      get: function() {
        return this.createPolygonPath();
      },
      enumerable: false,
      configurable: true
    });
    PolygonCrosshair2.prototype.update = function(cfg) {
      _super.prototype.update.call(this, cfg);
    };
    Object.defineProperty(PolygonCrosshair2.prototype, "points", {
      /**
       * 得到从中心出发，各个点方向的单位向量
       */
      get: function() {
        var _a2 = this.attributes, startAngle = _a2.startAngle, sides = _a2.sides;
        var a2 = Math.PI * 2 / sides;
        var unit = [1, 0];
        var points = [];
        for (var i = 0; i < sides; i += 1) {
          points.push(rotate5(unit, [0, 0], startAngle / 180 * Math.PI + a2 * i));
        }
        return points;
      },
      enumerable: false,
      configurable: true
    });
    PolygonCrosshair2.prototype.setPointer = function(_a2) {
      var _b = __read(_a2, 2), x3 = _b[0], y3 = _b[1];
      _super.prototype.setPointer.call(this, [x3, y3]);
      var _c = __read(this.localPointer, 2), lx = _c[0], ly = _c[1];
      var center = this.attributes.center;
      var _d = __read(this.intersection([lx, ly]), 2), ix = _d[0], iy = _d[1];
      if (!ix || !iy)
        return;
      var equivalentRadius = lineLen(center, [lx, ly]) / lineLen(center, [ix, iy]);
      var path = this.createPolygonPath(equivalentRadius);
      this.crosshairShape.attr({ d: path });
    };
    PolygonCrosshair2.prototype.adjustLayout = function() {
      hide(this.tagShape);
    };
    PolygonCrosshair2.prototype.createPolygonPath = function(radius) {
      var _a2 = this.attributes, defaultRadius = _a2.defaultRadius, _b = __read(_a2.center, 2), cx = _b[0], cy = _b[1];
      var path = this.points.map(function(_a3, index2) {
        var _b2 = __read(_a3, 2), x3 = _b2[0], y3 = _b2[1];
        var _c = __read(scale8([x3, y3], radius || defaultRadius), 2), tx = _c[0], ty = _c[1];
        return [index2 === 0 ? "M" : "L", cx + tx, cy + ty];
      });
      path.push(["Z"]);
      return path;
    };
    PolygonCrosshair2.prototype.intersection = function(_a2) {
      var _b;
      var _c = __read(_a2, 2), x3 = _c[0], y3 = _c[1];
      var points = this.points;
      var _d = __read(this.attributes.center, 2), cx = _d[0], cy = _d[1];
      var ix;
      var iy;
      for (var i = 1; i <= points.length; i += 1) {
        var _e = __read(points[i - 1], 2), sx = _e[0], sy = _e[1];
        var _f = __read(points[i % points.length], 2), ex = _f[0], ey = _f[1];
        var inter = intersection([x3, y3], [cx, cy], [sx + cx, sy + cy], [ex + cx, ey + cy]);
        if (inter.length !== 0) {
          _b = __read(inter, 2), ix = _b[0], iy = _b[1];
        }
      }
      return [ix, iy];
    };
    PolygonCrosshair2.tag = "polygon-crosshair";
    PolygonCrosshair2.defaultOptions = {
      style: POLYGON_CROSSHAIR_DEFAULT_STYLE
    };
    return PolygonCrosshair2;
  }(CrosshairBase)
);

// node_modules/@antv/component/esm/ui/checkbox/constant.js
var LABEL_TEXT_STYLE = superStyleProps({
  fill: "rgba(0,0,0,0.45)",
  fontSize: 10,
  textAlign: "start",
  textBaseline: "middle",
  overflow: "clip"
}, "label");
var CHECKBOX_RECT_STYLE = {
  default: {
    width: 12,
    height: 12,
    radius: 2,
    stroke: "#dadada",
    lineWidth: 1,
    fill: "#ffffff",
    cursor: "pointer"
  },
  selected: {
    width: 12,
    height: 12,
    radius: 2,
    stroke: "#3471F9",
    lineWidth: 1,
    fill: "#3471F9",
    cursor: "pointer"
  }
};
var CHECKED_SHAPE_PATH = [
  ["M", 3, 6],
  ["L", "5", "8.5"],
  ["L", "8.5", "4"]
];
var CHECKED_SHAPE_STYLE = {
  d: CHECKED_SHAPE_PATH,
  lineWidth: 1,
  cursor: "pointer"
};

// node_modules/@antv/component/esm/ui/checkbox/index.js
function getLablePosition(shape, spacing) {
  var bounds = shape.getLocalBounds();
  return {
    x: bounds.halfExtents[0] ? bounds.max[0] + (spacing || 0) : shape.style.x,
    y: bounds.halfExtents[1] ? (bounds.min[1] + bounds.max[1]) / 2 : shape.style.y
  };
}
var Checkbox = (
  /** @class */
  function(_super) {
    __extends(Checkbox2, _super);
    function Checkbox2(options) {
      return _super.call(this, options, __assign({ labelText: "", spacing: 4, checked: false }, LABEL_TEXT_STYLE)) || this;
    }
    Checkbox2.prototype.render = function(attributes, container) {
      var checked = attributes.checked, spacing = attributes.spacing;
      this.checked = !!checked;
      var group2 = maybeAppend(container, ".checkbox-content", "g").attr("className", "checkbox-content").node();
      var boxStyle = subStyleProps(attributes, "box");
      var checkedStyle = subStyleProps(attributes, "checked");
      var labelStyle = subStyleProps(attributes, "label");
      var checkboxStyle = __assign(__assign({}, this.checked ? CHECKBOX_RECT_STYLE.selected : CHECKBOX_RECT_STYLE.default), boxStyle);
      var checkboxBoxCheckedStyle = __assign(__assign({}, CHECKED_SHAPE_STYLE), checkedStyle);
      this.checkboxBoxShape = maybeAppend(group2, ".checkbox-box", "rect").styles(__assign({ className: "checkbox-box", zIndex: (group2.style.zIndex || 0) - 1 }, checkboxStyle)).node();
      maybeAppend(this.checkboxBoxShape, ".checkbox-checked", "path").styles(__assign({ className: "checkbox-box-checked", stroke: "#fff" }, checkboxBoxCheckedStyle));
      var _a2 = getLablePosition(this.checkboxBoxShape, Number(spacing)), x3 = _a2.x, y3 = _a2.y;
      maybeAppend(group2, ".checkbox-label", "text").styles(__assign({ className: "checkbox-label", x: x3, y: y3 }, labelStyle));
    };
    Checkbox2.tag = "checkbox";
    return Checkbox2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/layout/layout.js
var Layout = (
  /** @class */
  function(_super) {
    __extends(Layout2, _super);
    function Layout2(options) {
      var _this2 = _super.call(this, options) || this;
      _this2.layoutEvents = [ElementEvent.BOUNDS_CHANGED, ElementEvent.INSERTED, ElementEvent.REMOVED];
      _this2.$margin = parseSeriesAttr(0);
      _this2.$padding = parseSeriesAttr(0);
      var _a2 = options.style || {}, _b = _a2.margin, margin = _b === void 0 ? 0 : _b, _c = _a2.padding, padding = _c === void 0 ? 0 : _c;
      _this2.margin = margin;
      _this2.padding = padding;
      _this2.isMutationObserved = true;
      _this2.bindEvents();
      return _this2;
    }
    Object.defineProperty(Layout2.prototype, "margin", {
      get: function() {
        return this.$margin;
      },
      set: function(value) {
        this.$margin = parseSeriesAttr(value);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Layout2.prototype, "padding", {
      get: function() {
        return this.$padding;
      },
      set: function(value) {
        this.$padding = parseSeriesAttr(value);
      },
      enumerable: false,
      configurable: true
    });
    Layout2.prototype.getBBox = function() {
      var _a2 = this.attributes, _b = _a2.x, x3 = _b === void 0 ? 0 : _b, _c = _a2.y, y3 = _c === void 0 ? 0 : _c, width = _a2.width, height = _a2.height;
      var _d = __read(this.$margin, 4), marginTop = _d[0], marginRight = _d[1], marginBottom = _d[2], marginLeft = _d[3];
      return new BBox(x3 - marginLeft, y3 - marginTop, width + marginLeft + marginRight, height + marginTop + marginBottom);
    };
    Layout2.prototype.appendChild = function(child, index2) {
      child.isMutationObserved = true;
      _super.prototype.appendChild.call(this, child, index2);
      return child;
    };
    Layout2.prototype.getAvailableSpace = function() {
      var _a2 = this.attributes, width = _a2.width, height = _a2.height;
      var _b = __read(this.$padding, 4), paddingTop = _b[0], paddingRight = _b[1], paddingBottom = _b[2], paddingLeft = _b[3];
      var _c = __read(this.$margin, 4), marginTop = _c[0], marginLeft = _c[3];
      return new BBox(paddingLeft + marginLeft, paddingTop + marginTop, width - paddingLeft - paddingRight, height - paddingTop - paddingBottom);
    };
    Layout2.prototype.layout = function() {
      if (!this.attributes.display || !this.isConnected)
        return;
      if (this.children.some(function(child) {
        return !child.isConnected;
      }))
        return;
      try {
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y;
        this.style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
        var bboxes_1 = executer_default(this.getAvailableSpace(), this.children.map(function(child) {
          return child.getBBox();
        }), this.attributes);
        this.children.forEach(function(child, index2) {
          var _a3 = bboxes_1[index2], x4 = _a3.x, y4 = _a3.y;
          child.style.transform = "translate(".concat(x4, ", ").concat(y4, ")");
        });
      } catch (e) {
      }
    };
    Layout2.prototype.bindEvents = function() {
      var _this2 = this;
      this.layoutEvents.forEach(function(event) {
        _this2.addEventListener(event, function(e) {
          if (!e.target)
            return;
          e.target.isMutationObserved = true;
          _this2.layout();
        });
      });
    };
    Layout2.prototype.attributeChangedCallback = function(name, oldValue, newValue) {
      if (name === "margin")
        this.margin = newValue;
      else if (name === "padding")
        this.padding = newValue;
      this.layout();
    };
    return Layout2;
  }(Group)
);

// node_modules/@antv/g-plugin-dragndrop/dist/index.esm.js
var DragndropPlugin = function() {
  function DragndropPlugin2(dragndropPluginOptions) {
    _classCallCheck(this, DragndropPlugin2);
    this.dragndropPluginOptions = dragndropPluginOptions;
  }
  return _createClass(DragndropPlugin2, [{
    key: "apply",
    value: function apply(context) {
      var _this2 = this;
      var renderingService = context.renderingService, renderingContext = context.renderingContext;
      var document2 = renderingContext.root.ownerDocument;
      var canvas = document2.defaultView;
      var handlePointerdown = function handlePointerdown2(event) {
        var target = event.target;
        var isDocument = target === document2;
        var draggableEventTarget = isDocument && _this2.dragndropPluginOptions.isDocumentDraggable ? document2 : target.closest && target.closest("[draggable=true]");
        if (draggableEventTarget) {
          var dragstartTriggered = false;
          var dragstartTimeStamp = event.timeStamp;
          var dragstartClientCoordinates = [event.clientX, event.clientY];
          var currentDroppable = null;
          var lastDragClientCoordinates = [event.clientX, event.clientY];
          var handlePointermove = function() {
            var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(event2) {
              var timeElapsed, distanceMoved, point2, elementsBelow, elementBelow, droppableBelow;
              return _regeneratorRuntime().wrap(function(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    if (dragstartTriggered) {
                      _context.next = 2;
                      break;
                    }
                    timeElapsed = event2.timeStamp - dragstartTimeStamp;
                    distanceMoved = distanceSquareRoot([event2.clientX, event2.clientY], dragstartClientCoordinates);
                    if (!(timeElapsed <= _this2.dragndropPluginOptions.dragstartTimeThreshold || distanceMoved <= _this2.dragndropPluginOptions.dragstartDistanceThreshold)) {
                      _context.next = 1;
                      break;
                    }
                    return _context.abrupt("return");
                  case 1:
                    event2.type = "dragstart";
                    draggableEventTarget.dispatchEvent(event2);
                    dragstartTriggered = true;
                  case 2:
                    event2.type = "drag";
                    event2.dx = event2.clientX - lastDragClientCoordinates[0];
                    event2.dy = event2.clientY - lastDragClientCoordinates[1];
                    draggableEventTarget.dispatchEvent(event2);
                    lastDragClientCoordinates = [event2.clientX, event2.clientY];
                    if (isDocument) {
                      _context.next = 4;
                      break;
                    }
                    point2 = _this2.dragndropPluginOptions.overlap === "pointer" ? [event2.canvasX, event2.canvasY] : target.getBounds().center;
                    _context.next = 3;
                    return document2.elementsFromPoint(point2[0], point2[1]);
                  case 3:
                    elementsBelow = _context.sent;
                    elementBelow = elementsBelow[elementsBelow.indexOf(target) + 1];
                    droppableBelow = (elementBelow === null || elementBelow === void 0 ? void 0 : elementBelow.closest("[droppable=true]")) || (_this2.dragndropPluginOptions.isDocumentDroppable ? document2 : null);
                    if (currentDroppable !== droppableBelow) {
                      if (currentDroppable) {
                        event2.type = "dragleave";
                        event2.target = currentDroppable;
                        currentDroppable.dispatchEvent(event2);
                      }
                      if (droppableBelow) {
                        event2.type = "dragenter";
                        event2.target = droppableBelow;
                        droppableBelow.dispatchEvent(event2);
                      }
                      currentDroppable = droppableBelow;
                      if (currentDroppable) {
                        event2.type = "dragover";
                        event2.target = currentDroppable;
                        currentDroppable.dispatchEvent(event2);
                      }
                    }
                  case 4:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            return function handlePointermove2(_x) {
              return _ref.apply(this, arguments);
            };
          }();
          canvas.addEventListener("pointermove", handlePointermove);
          var stopDragging = function stopDragging2(originalPointerUpEvent) {
            if (dragstartTriggered) {
              originalPointerUpEvent.detail = {
                preventClick: true
              };
              var _event = originalPointerUpEvent.clone();
              if (currentDroppable) {
                _event.type = "drop";
                _event.target = currentDroppable;
                currentDroppable.dispatchEvent(_event);
              }
              _event.type = "dragend";
              draggableEventTarget.dispatchEvent(_event);
              dragstartTriggered = false;
            }
            canvas.removeEventListener("pointermove", handlePointermove);
          };
          target.addEventListener("pointerup", stopDragging, {
            once: true
          });
          target.addEventListener("pointerupoutside", stopDragging, {
            once: true
          });
        }
      };
      renderingService.hooks.init.tap(DragndropPlugin2.tag, function() {
        canvas.addEventListener("pointerdown", handlePointerdown);
      });
      renderingService.hooks.destroy.tap(DragndropPlugin2.tag, function() {
        canvas.removeEventListener("pointerdown", handlePointerdown);
      });
    }
  }]);
}();
DragndropPlugin.tag = "Dragndrop";
var Plugin7 = function(_AbstractRendererPlug) {
  function Plugin8() {
    var _this2;
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Plugin8);
    _this2 = _callSuper(this, Plugin8);
    _this2.name = "dragndrop";
    _this2.options = options;
    return _this2;
  }
  _inherits(Plugin8, _AbstractRendererPlug);
  return _createClass(Plugin8, [{
    key: "init",
    value: function init() {
      this.addRenderingPlugin(new DragndropPlugin(_objectSpread2({
        overlap: "pointer",
        isDocumentDraggable: false,
        isDocumentDroppable: false,
        dragstartDistanceThreshold: 0,
        dragstartTimeThreshold: 0
      }, this.options)));
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.removeAllRenderingPlugins();
    }
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      Object.assign(this.plugins[0].dragndropPluginOptions, options);
    }
  }]);
}(AbstractRendererPlugin);

export {
  mat3_exports,
  mat4_exports,
  vec3_exports,
  vec4_exports,
  filter_default,
  difference_default,
  isFunction,
  isNil,
  isArray,
  is_object_default,
  keys_default,
  is_plain_object_default,
  find_default,
  reduce_default,
  isString,
  uniq,
  head,
  last,
  group_by_default,
  clamp_default,
  isNumber,
  lower_first_default,
  upper_first_default,
  is_boolean_default,
  isDate,
  isNull,
  is_undefined_default,
  mix,
  clone_default,
  debounce_default,
  memoize,
  deep_mix_default,
  index_of_default,
  is_empty_default,
  is_equal_default,
  map_values_default,
  get_default,
  set_default,
  pick_default,
  omit_default,
  throttle_default,
  unique_id_default,
  identity_default,
  size,
  createDOM,
  Shape,
  AABB,
  rad2deg,
  PropertySyntax,
  parseColor,
  convertToPath,
  FederatedPointerEvent,
  CustomEvent,
  ElementEvent,
  DisplayObject,
  Circle,
  CustomElement,
  Ellipse,
  Group,
  HTML,
  Image2 as Image,
  Line,
  Path,
  Polygon,
  Polyline,
  Rect,
  Text,
  CSS,
  Document2 as Document,
  CanvasEvent,
  Canvas,
  Renderer,
  esm_default,
  quadtree,
  center_default,
  collide_default,
  link_default,
  simulation_default,
  manyBody_default,
  radial_default,
  x_default2 as x_default,
  y_default2 as y_default,
  measureTextWidth,
  Marker,
  format,
  Slider,
  Scrollbar,
  Axis,
  Category,
  Continuous2 as Continuous,
  Tooltip,
  Layout,
  Timebar,
  Plugin7 as Plugin,
  require_lodash
};
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

@antv/g-math/dist/index.esm.js:
  (*!
   * @antv/g-math
   * @description Geometry util
   * @version 3.0.1
   * @date 5/9/2025, 8:18:51 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-lite/dist/index.esm.js:
  (*!
   * @antv/g-lite
   * @description A core module for rendering engine implements DOM API.
   * @version 2.3.2
   * @date 7/30/2025, 1:34:19 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-camera-api/dist/index.esm.js:
  (*!
   * @antv/g-camera-api
   * @description A simple implementation of Camera API.
   * @version 2.0.41
   * @date 7/30/2025, 1:34:37 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-dom-mutation-observer-api/dist/index.esm.js:
  (*!
   * @antv/g-dom-mutation-observer-api
   * @description A simple implementation of DOM MutationObserver API.
   * @version 2.0.38
   * @date 7/30/2025, 1:34:51 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-web-animations-api/dist/index.esm.js:
  (*!
   * @antv/g-web-animations-api
   * @description A simple implementation of Web Animations API.
   * @version 2.1.28
   * @date 7/30/2025, 1:36:24 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g/dist/index.esm.js:
  (*!
   * @antv/g
   * @description A core module for rendering engine implements DOM API.
   * @version 6.1.28
   * @date 7/30/2025, 1:36:29 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-canvas-path-generator/dist/index.esm.js:
  (*!
   * @antv/g-plugin-canvas-path-generator
   * @description A G plugin of path generator with Canvas2D API
   * @version 2.1.22
   * @date 7/30/2025, 1:35:25 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-canvas-picker/dist/index.esm.js:
  (*!
   * @antv/g-plugin-canvas-picker
   * @description A G plugin for picking in canvas
   * @version 2.1.27
   * @date 7/30/2025, 1:37:32 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-image-loader/dist/index.esm.js:
  (*!
   * @antv/g-plugin-image-loader
   * @description A G plugin for loading image
   * @version 2.1.26
   * @date 7/30/2025, 1:35:52 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-canvas-renderer/dist/index.esm.js:
  (*!
   * @antv/g-plugin-canvas-renderer
   * @description A G plugin of renderer implementation with Canvas2D API
   * @version 2.3.3
   * @date 7/30/2025, 1:36:40 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-dom-interaction/dist/index.esm.js:
  (*!
   * @antv/g-plugin-dom-interaction
   * @description A G plugin
   * @version 2.1.27
   * @date 7/30/2025, 1:35:38 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-html-renderer/dist/index.esm.js:
  (*!
   * @antv/g-plugin-html-renderer
   * @description A G plugin for rendering HTML
   * @version 2.1.27
   * @date 7/30/2025, 1:35:48 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-canvas/dist/index.esm.js:
  (*!
   * @antv/g-canvas
   * @description A renderer implemented by Canvas 2D API
   * @version 2.0.48
   * @date 7/30/2025, 1:38:18 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-dragndrop/dist/index.esm.js:
  (*!
   * @antv/g-plugin-dragndrop
   * @description A G plugin for Drag n Drop implemented with PointerEvents
   * @version 2.0.38
   * @date 7/30/2025, 1:35:41 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)
*/
//# sourceMappingURL=chunk-2C3BOJAR.js.map
