import {
  $B,
  JE,
  e3,
  v3
} from "./chunk-42GB3BEU.js";
import {
  Be,
  Ds,
  ER,
  Fl,
  Gc,
  Hl,
  Hn,
  Inject,
  Injector,
  Ls,
  Ve,
  Ze,
  br,
  co,
  en,
  ho,
  qc,
  rR,
  vs,
  we,
  xs,
  yl
} from "./chunk-Y4UF2FTU.js";
import {
  BehaviorSubject,
  Subject,
  takeUntil
} from "./chunk-AR6LG6UR.js";
import {
  __objRest,
  __spreadProps,
  __spreadValues
} from "./chunk-JMNN7AZU.js";

// node_modules/@univerjs/docs/lib/es/index.js
var ie = Object.defineProperty;
var re = (i, e, t) => e in i ? ie(i, e, { enumerable: true, configurable: true, writable: true, value: t }) : i[e] = t;
var u = (i, e, t) => re(i, typeof e != "symbol" ? e + "" : e, t);
var k = {
  id: "doc.operation.set-selections",
  type: Ls.OPERATION,
  handler: () => true
};
var xe = Object.getOwnPropertyDescriptor;
var Oe = (i, e, t, n) => {
  for (var s = n > 1 ? void 0 : n ? xe(e, t) : e, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (s = o(s) || s);
  return s;
};
var F = (i, e) => (t, n) => e(t, n, i);
var m = class extends ER {
  constructor(e, t) {
    super();
    u(this, "_currentSelection", null);
    u(this, "_textSelectionInfo", /* @__PURE__ */ new Map());
    u(this, "_textSelection$", new Subject());
    u(this, "textSelection$", this._textSelection$.asObservable());
    u(this, "_refreshSelection$", new BehaviorSubject(null));
    u(this, "refreshSelection$", this._refreshSelection$.asObservable());
    this._commandService = e, this._univerInstanceService = t, this._listenCurrentUnit();
  }
  _listenCurrentUnit() {
    this._univerInstanceService.getCurrentTypeOfUnit$(we.UNIVER_DOC).pipe(takeUntil(this.dispose$)).subscribe((e) => {
      if (e == null)
        return;
      const t = e.getUnitId();
      this._setCurrentSelectionNotRefresh({
        unitId: t,
        subUnitId: t
      });
    });
  }
  __getCurrentSelection() {
    return this._currentSelection;
  }
  getSelectionInfo(e = this._currentSelection) {
    return this._getTextRanges(e);
  }
  refreshSelection(e = this._currentSelection) {
    e != null && this._refresh(e);
  }
  // **Only used in test case** because this does not go through the render layer.
  __TEST_ONLY_setCurrentSelection(e) {
    this._currentSelection = e, this._refresh(e);
  }
  getTextRanges(e = this._currentSelection) {
    var t;
    return (t = this._getTextRanges(e)) == null ? void 0 : t.textRanges;
  }
  getRectRanges(e = this._currentSelection) {
    var t;
    return (t = this._getTextRanges(e)) == null ? void 0 : t.rectRanges;
  }
  getDocRanges(e = this._currentSelection) {
    var r, o;
    const t = (r = this.getTextRanges(e)) != null ? r : [], n = (o = this.getRectRanges(e)) != null ? o : [];
    return [...t, ...n].filter((c) => c.startOffset != null && c.endOffset != null).sort((c, a) => c.startOffset > a.startOffset ? 1 : c.startOffset < a.startOffset ? -1 : 0);
  }
  getActiveTextRange() {
    const e = this._getTextRanges(this._currentSelection);
    if (e == null)
      return;
    const { textRanges: t } = e;
    return t.find((n) => n.isActive);
  }
  /**
   *
   * @deprecated
   */
  getActiveRectRange() {
    const e = this._getTextRanges(this._currentSelection);
    if (e == null)
      return;
    const { rectRanges: t } = e;
    return t.find((n) => n.isActive);
  }
  // **Only used in test case** because this does not go through the render layer.
  __TEST_ONLY_add(e, t = true) {
    this._currentSelection != null && this._addByParam(__spreadProps(__spreadValues({}, this._currentSelection), {
      textRanges: e,
      rectRanges: [],
      segmentId: "",
      segmentPage: -1,
      isEditing: t,
      style: $B
      // mock style.
    }));
  }
  // Use to replace the current editor selection.
  /**
   * @deprecated pls use replaceDocRanges.
   */
  replaceTextRanges(e, t = true, n) {
    return this.replaceDocRanges(
      e,
      this._currentSelection,
      t,
      n
    );
  }
  replaceDocRanges(e, t = this._currentSelection, n = true, s) {
    if (t == null)
      return;
    const { unitId: r, subUnitId: o } = t;
    this._refreshSelection$.next({
      unitId: r,
      subUnitId: o,
      docRanges: e,
      isEditing: n,
      options: s
    });
  }
  // Only use in doc-selection-render.controller.ts
  __replaceTextRangesWithNoRefresh(e, t) {
    if (this._currentSelection == null)
      return;
    const n = __spreadValues(__spreadValues({}, e), t);
    this._replaceByParam(n), this._textSelection$.next(n);
    const { unitId: s, subUnitId: r, segmentId: o, style: c, textRanges: a, rectRanges: l, isEditing: d } = n, h = [...a, ...l].filter((g) => g.startOffset != null && g.endOffset != null).sort((g, _) => g.startOffset > _.startOffset ? 1 : g.startOffset < _.startOffset ? -1 : 0);
    this._commandService.executeCommand(k.id, {
      unitId: s,
      subUnitId: r,
      segmentId: o,
      style: c,
      isEditing: d,
      ranges: h
    });
  }
  dispose() {
    this._textSelection$.complete(), this._refreshSelection$.complete();
  }
  _setCurrentSelectionNotRefresh(e) {
    this._currentSelection = e;
  }
  _getTextRanges(e) {
    var s;
    if (e == null)
      return;
    const { unitId: t, subUnitId: n = "" } = e;
    return (s = this._textSelectionInfo.get(t)) == null ? void 0 : s.get(n);
  }
  _refresh(e) {
    const t = this._getTextRanges(e);
    if (t == null)
      return;
    const { textRanges: n, rectRanges: s } = t, r = [...n, ...s], { unitId: o, subUnitId: c } = e;
    this._refreshSelection$.next({
      unitId: o,
      subUnitId: c,
      docRanges: r,
      isEditing: false
    });
  }
  _replaceByParam(e) {
    const _a = e, { unitId: t, subUnitId: n } = _a, s = __objRest(_a, ["unitId", "subUnitId"]);
    this._textSelectionInfo.has(t) || this._textSelectionInfo.set(t, /* @__PURE__ */ new Map()), this._textSelectionInfo.get(t).set(n, __spreadValues({}, s));
  }
  _addByParam(e) {
    const _a = e, { unitId: t, subUnitId: n } = _a, s = __objRest(_a, ["unitId", "subUnitId"]);
    this._textSelectionInfo.has(t) || this._textSelectionInfo.set(t, /* @__PURE__ */ new Map());
    const r = this._textSelectionInfo.get(t);
    r.has(n) ? r.get(n).textRanges.push(...e.textRanges) : r.set(n, __spreadValues({}, s));
  }
};
m = Oe([
  F(0, Ds),
  F(1, br)
], m);
var Ce = Object.getOwnPropertyDescriptor;
var Me = (i, e, t, n) => {
  for (var s = n > 1 ? void 0 : n ? Ce(e, t) : e, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (s = o(s) || s);
  return s;
};
var W = (i, e) => (t, n) => e(t, n, i);
var D = class extends ER {
  constructor(e, t, n) {
    super();
    u(this, "_skeleton");
    u(this, "_docViewModel");
    u(this, "_currentSkeleton$", new BehaviorSubject(null));
    u(this, "currentSkeleton$", this._currentSkeleton$.asObservable());
    u(this, "_currentSkeletonBefore$", new BehaviorSubject(null));
    u(this, "currentSkeletonBefore$", this._currentSkeletonBefore$.asObservable());
    u(this, "_currentViewModel$", new BehaviorSubject(null));
    u(this, "currentViewModel$", this._currentViewModel$.asObservable());
    this._context = e, this._localeService = t, this._univerInstanceService = n, this._init(), this._univerInstanceService.getCurrentTypeOfUnit$(we.UNIVER_DOC).pipe(takeUntil(this.dispose$)).subscribe((s) => {
      s && s.getUnitId() === this._context.unitId && this._update(s);
    });
  }
  dispose() {
    super.dispose(), this._currentSkeletonBefore$.complete(), this._currentSkeleton$.complete();
  }
  getSkeleton() {
    return this._skeleton;
  }
  getViewModel() {
    return this._docViewModel;
  }
  _init() {
    const e = this._context.unit;
    this._update(e);
  }
  _update(e) {
    const t = this._context.unitId;
    if (e.getBody() == null)
      return;
    this._docViewModel && Gc(t) ? (this._docViewModel.reset(e), this._context.unit = e) : this._docViewModel || (this._docViewModel = this._buildDocViewModel(e)), this._skeleton || (this._skeleton = this._buildSkeleton(this._docViewModel));
    const n = this._skeleton;
    n.calculate(), this._currentSkeletonBefore$.next(n), this._currentSkeleton$.next(n), this._currentViewModel$.next(this._docViewModel);
  }
  _buildSkeleton(e) {
    return v3.create(e, this._localeService);
  }
  _buildDocViewModel(e) {
    return new e3(e);
  }
};
D = Me([
  W(1, Inject(Hn)),
  W(2, br)
], D);
var te = class extends ER {
  constructor() {
    super();
    u(this, "_docStateChangeParams$", new BehaviorSubject(null));
    u(this, "docStateChangeParams$", this._docStateChangeParams$.asObservable());
  }
  emitStateChangeInfo(t) {
    this._docStateChangeParams$.next(t);
  }
  dispose() {
    super.dispose(), this._docStateChangeParams$.complete();
  }
};
var Y = "doc.mutation.rich-text-editing";
var M = {
  id: Y,
  type: Ls.MUTATION,
  // eslint-disable-next-line max-lines-per-function
  handler: (i, e) => {
    var G, z;
    const {
      unitId: t,
      segmentId: n = "",
      actions: s,
      textRanges: r,
      prevTextRanges: o,
      trigger: c,
      noHistory: a,
      isCompositionEnd: l,
      noNeedSetTextRange: d,
      debounce: h,
      isEditing: g = true,
      isSync: _,
      syncer: f
    } = e, R = i.get(br), p = i.get(JE), v = i.get(te), S = R.getUniverDocInstance(t), j = (G = p.getRenderById(t)) == null ? void 0 : G.with(D).getViewModel();
    if (S == null || j == null)
      throw new Error(`DocumentDataModel or documentViewModel not found for unitId: ${t}`);
    const L = i.get(m), b = (z = L.getDocRanges()) != null ? z : [], ne = !!S.getSnapshot().disabled;
    if (en.isNoop(s) || s && s.length === 0 || ne)
      return {
        unitId: t,
        actions: [],
        textRanges: b
      };
    const X = en.invertWithDoc(s, S.getSnapshot());
    S.apply(s), j.reset(S), !d && r && c != null && !_ && queueMicrotask(() => {
      L.replaceDocRanges(r, { unitId: t, subUnitId: t }, g, e.options);
    });
    const se = {
      commandId: Y,
      unitId: t,
      segmentId: n,
      trigger: c,
      noHistory: a,
      debounce: h,
      redoState: {
        actions: s,
        textRanges: r
      },
      undoState: {
        actions: X,
        textRanges: o != null ? o : b
      },
      isCompositionEnd: l,
      isSync: _,
      syncer: f
    };
    return v.emitStateChangeInfo(se), {
      unitId: t,
      actions: X,
      textRanges: b
    };
  }
};
var De = {
  id: "doc.mutation.rename-doc",
  type: Ls.MUTATION,
  handler: (i, e) => {
    const n = i.get(br).getUnit(e.unitId, we.UNIVER_DOC);
    return n ? (n.setName(e.name), true) : false;
  }
};
var Te = "docs.config";
var K = {};
var ye = Object.getOwnPropertyDescriptor;
var we2 = (i, e, t, n) => {
  for (var s = n > 1 ? void 0 : n ? ye(e, t) : e, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (s = o(s) || s);
  return s;
};
var $ = (i, e) => (t, n) => e(t, n, i);
var T = class extends Ve {
  constructor(i, e, t) {
    super(), this._commandService = i, this._textSelectionManagerService = e, this._univerInstanceService = t, this._initSelectionChange();
  }
  _transformCustomRange(i, e) {
    var o;
    const { startOffset: t, endOffset: n, collapsed: s } = e, r = (o = i.getCustomRanges()) == null ? void 0 : o.filter((c) => !c.wholeEntity || t <= c.startIndex && n > c.endIndex ? false : s ? c.startIndex < t && c.endIndex >= n : Ze.range.isIntersects(t, n - 1, c.startIndex, c.endIndex));
    if (r != null && r.length) {
      let c = t, a = n;
      return r.forEach((l) => {
        c = Math.min(l.startIndex, c), a = Math.max(l.endIndex + 1, a);
      }), __spreadProps(__spreadValues({}, e), {
        startOffset: c,
        endOffset: a,
        collapsed: c === a
      });
    }
    return e;
  }
  _initSelectionChange() {
    this.disposeWithMe(this._commandService.onCommandExecuted((i) => {
      if (i.id === k.id) {
        const e = i.params, { unitId: t, ranges: n, isEditing: s } = e, r = this._univerInstanceService.getUnit(t);
        if (!r)
          return;
        const o = n.map((c) => this._transformCustomRange(r, c));
        o.some((c, a) => n[a] !== c) && this._textSelectionManagerService.replaceTextRanges(o, s);
      }
    }));
  }
};
T = we2([
  $(0, Ds),
  $(1, Inject(m)),
  $(2, br)
], T);
var be = Object.getOwnPropertyDescriptor;
var Ue = (i, e, t, n) => {
  for (var s = n > 1 ? void 0 : n ? be(e, t) : e, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (s = o(s) || s);
  return s;
};
var H = (i, e) => (t, n) => e(t, n, i);
var $e = "DOCS_PLUGIN";
var N;
var q = (N = class extends yl {
  // static override type = UniverInstanceType.UNIVER_DOC;
  constructor(i = K, e, t) {
    super(), this._config = i, this._injector = e, this._configService = t;
    const n = __objRest(co(
      {},
      K,
      this._config
    ), []);
    this._configService.setConfig(Te, n);
  }
  onStarting() {
    this._initializeDependencies(), this._initializeCommands();
  }
  _initializeCommands() {
    [
      M,
      De,
      k
    ].forEach((i) => {
      this._injector.get(Ds).registerCommand(i);
    });
  }
  _initializeDependencies() {
    [
      [m],
      [te],
      [T]
    ].forEach((i) => this._injector.add(i));
  }
  onReady() {
    this._injector.get(T);
  }
}, u(N, "pluginName", $e), N);
q = Ue([
  H(1, Inject(Injector)),
  H(2, xs)
], q);
var Ee = rR("CUSTOM_RANGE");
var Ne = rR("CUSTOM_DECORATION");
var E = {
  CUSTOM_RANGE: Ee,
  CUSTOM_DECORATION: Ne
};
var Pe = Object.getOwnPropertyDescriptor;
var Ve2 = (i, e, t, n) => {
  for (var s = n > 1 ? void 0 : n ? Pe(e, t) : e, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (s = o(s) || s);
  return s;
};
var Be2 = (i, e) => (t, n) => e(t, n, i);
var J = class extends Ve {
  constructor(e, t) {
    super();
    u(this, "_interceptorsByName", /* @__PURE__ */ new Map());
    this._context = e, this._docSkeletonManagerService = t;
    const n = this._docSkeletonManagerService.getViewModel(), s = n.getDataModel().getUnitId();
    if (s === Fl || s === Hl)
      return;
    this.disposeWithMe(this.interceptDocumentViewModel(n)), this.disposeWithMe(this.intercept(E.CUSTOM_RANGE, {
      priority: -1,
      handler: (o, c, a) => a(o)
    }));
    let r = new ho();
    n.segmentViewModels$.subscribe((o) => {
      r.dispose(), r = new ho(), o.forEach((c) => {
        r.add(this.interceptDocumentViewModel(c));
      });
    }), this.disposeWithMe(r);
  }
  intercept(e, t) {
    const n = e;
    this._interceptorsByName.has(n) || this._interceptorsByName.set(n, []);
    const s = this._interceptorsByName.get(n);
    return s.push(t), this._interceptorsByName.set(
      n,
      s.sort((r, o) => {
        var c, a;
        return ((c = o.priority) != null ? c : 0) - ((a = r.priority) != null ? a : 0);
      })
    ), this.disposeWithMe(Be(() => vs(this._interceptorsByName.get(n), t)));
  }
  fetchThroughInterceptors(e) {
    const t = e, n = this._interceptorsByName.get(t);
    return qc(n || []);
  }
  interceptDocumentViewModel(e) {
    const t = new ho();
    return t.add(e.registerCustomRangeInterceptor({
      getCustomRange: (n) => {
        var s;
        return this.fetchThroughInterceptors(E.CUSTOM_RANGE)(
          e.getCustomRangeRaw(n),
          {
            index: n,
            unitId: e.getDataModel().getUnitId(),
            customRanges: (s = e.getDataModel().getCustomRanges()) != null ? s : []
          }
        );
      },
      getCustomDecoration: (n) => {
        var s;
        return this.fetchThroughInterceptors(E.CUSTOM_DECORATION)(
          e.getCustomDecorationRaw(n),
          {
            index: n,
            unitId: e.getDataModel().getUnitId(),
            customDecorations: (s = e.getDataModel().getCustomDecorations()) != null ? s : []
          }
        );
      }
    })), t;
  }
};
J = Ve2([
  Be2(1, Inject(D))
], J);
function A(i, e = "") {
  if (!e)
    return ["body"];
  const { headers: t, footers: n } = i.getSnapshot();
  if (t == null && n == null)
    throw new Error("Document data model must have headers or footers when update by segment id");
  if ((t == null ? void 0 : t[e]) != null)
    return ["headers", e, "body"];
  if ((n == null ? void 0 : n[e]) != null)
    return ["footers", e, "body"];
  throw new Error("Segment id not found in headers or footers");
}
function Xe(i, e, t) {
  const { unitId: n, segmentId: s } = e, o = i.get(br).getUnit(n);
  if (!o)
    return false;
  const c = {
    id: M.id,
    params: {
      unitId: e.unitId,
      actions: [],
      textRanges: void 0
    }
  }, a = en.getInstance(), l = Ze.customRange.add(__spreadProps(__spreadValues({}, e), { body: t }));
  if (!l)
    return false;
  const d = A(o, s);
  return c.params.actions = a.editOp(l.serialize(), d), c;
}
function Ge(i, e) {
  var S;
  const { rangeId: t, rangeType: n, wholeEntity: s, properties: r, unitId: o, selections: c } = e, a = i.get(m), l = i.get(br), d = c != null ? c : a.getTextRanges({ unitId: o, subUnitId: o }), h = (S = d == null ? void 0 : d[0]) == null ? void 0 : S.segmentId;
  if (!(d != null && d.length))
    return false;
  const g = l.getUnit(o, we.UNIVER_DOC);
  if (!g)
    return false;
  const _ = g.getSelfOrHeaderFooterModel(h).getBody();
  if (!_)
    return false;
  const f = Ze.customRange.add({
    ranges: d,
    rangeId: t,
    rangeType: n,
    segmentId: h,
    wholeEntity: s,
    properties: r,
    body: _
  });
  if (!f)
    return false;
  const R = en.getInstance(), p = {
    id: M.id,
    params: {
      unitId: o,
      actions: [],
      textRanges: f.selections,
      segmentId: h
    },
    textX: f
  }, v = A(g, h);
  return p.params.actions = R.editOp(f.serialize(), v), p;
}
function ze(i, e) {
  const { unitId: t, segmentId: n, insert: s } = e, o = i.get(br).getUnit(t);
  if (!o)
    return false;
  const c = {
    id: M.id,
    params: {
      unitId: e.unitId,
      actions: [],
      textRanges: void 0,
      segmentId: n
    }
  }, a = en.getInstance(), l = Ze.customRange.delete({
    documentDataModel: o,
    rangeId: e.rangeId,
    insert: s,
    segmentId: n
  });
  if (!l)
    return false;
  const d = A(o, n);
  return c.params.actions = a.editOp(l.serialize(), d), c.params.textRanges = l.selections, c;
}
function Fe(i, e) {
  var f, R, p, v;
  const { unitId: t, body: n, doc: s } = e;
  let r = s;
  if (r || (r = i.get(br).getUnit(t)), !r)
    return false;
  const o = (f = e.selection) == null ? void 0 : f.segmentId, c = (R = r.getSelfOrHeaderFooterModel(o)) == null ? void 0 : R.getBody();
  if (!c) return false;
  const a = i.get(m), l = (p = e.selection) != null ? p : a.getActiveTextRange();
  if (!l || !c)
    return false;
  const d = (v = e.textRanges) != null ? v : [{
    startOffset: l.startOffset + n.dataStream.length,
    endOffset: l.startOffset + n.dataStream.length,
    collapsed: true,
    segmentId: o
  }], h = Ze.selection.replace({
    selection: l,
    body: n,
    doc: r
  });
  if (!h)
    return false;
  const g = {
    id: M.id,
    params: {
      unitId: t,
      actions: [],
      textRanges: d,
      debounce: true,
      segmentId: o
    },
    textX: h
  }, _ = en.getInstance();
  return g.params.actions = _.editOp(h.serialize()), g;
}

export {
  k,
  m,
  D,
  te,
  M,
  q,
  E,
  J,
  Xe,
  Ge,
  ze,
  Fe
};
//# sourceMappingURL=chunk-GRZDFSJT.js.map
