{
  "version": 3,
  "sources": ["../../clsx/dist/clsx.js", "../../react-draggable/build/cjs/utils/shims.js", "../../react-draggable/build/cjs/utils/getPrefix.js", "../../react-draggable/build/cjs/utils/domFns.js", "../../react-draggable/build/cjs/utils/positionFns.js", "../../react-draggable/build/cjs/utils/log.js", "../../react-draggable/build/cjs/DraggableCore.js", "../../react-draggable/build/cjs/Draggable.js", "../../react-draggable/build/cjs/cjs.js", "../../react-resizable/build/utils.js", "../../react-resizable/build/propTypes.js", "../../react-resizable/build/Resizable.js", "../../react-resizable/build/ResizableBox.js", "../../react-resizable/index.js", "../../react-grid-layout/src/core/calculate.ts", "../../react-grid-layout/src/core/collision.ts", "../../react-grid-layout/src/core/sort.ts", "../../react-grid-layout/src/core/layout.ts", "../../react-grid-layout/src/core/constraints.ts", "../../react-grid-layout/src/core/position.ts", "../../react-grid-layout/src/core/types.ts", "../../react-grid-layout/src/core/compactors.ts", "../../react-grid-layout/src/core/responsive.ts", "../../fast-equals/src/utils.ts", "../../fast-equals/src/comparator.ts", "../../fast-equals/src/arrays.ts", "../../fast-equals/src/dates.ts", "../../fast-equals/src/maps.ts", "../../fast-equals/src/objects.ts", "../../fast-equals/src/regexps.ts", "../../fast-equals/src/sets.ts", "../../fast-equals/src/index.ts", "../../react-grid-layout/src/react/hooks/useContainerWidth.ts", "../../react-grid-layout/src/react/hooks/useGridLayout.ts", "../../react-grid-layout/src/react/hooks/useResponsiveLayout.ts", "../../react-grid-layout/src/react/components/GridItem.tsx", "../../react-grid-layout/src/react/components/GridLayout.tsx", "../../react-grid-layout/src/react/components/ResponsiveGridLayout.tsx"],
  "sourcesContent": ["function r(e){var o,t,f=\"\";if(\"string\"==typeof e||\"number\"==typeof e)f+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var n=e.length;for(o=0;o<n;o++)e[o]&&(t=r(e[o]))&&(f&&(f+=\" \"),f+=t)}else for(t in e)e[t]&&(f&&(f+=\" \"),f+=t);return f}function e(){for(var e,o,t=0,f=\"\",n=arguments.length;t<n;t++)(e=arguments[t])&&(o=r(e))&&(f&&(f+=\" \"),f+=o);return f}module.exports=e,module.exports.clsx=e;", "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.dontSetMe = dontSetMe;\nexports.findInArray = findInArray;\nexports.int = int;\nexports.isFunction = isFunction;\nexports.isNum = isNum;\n// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc\nfunction findInArray(array /*: Array<any> | TouchList*/, callback /*: Function*/) /*: any*/{\n  for (let i = 0, length = array.length; i < length; i++) {\n    if (callback.apply(callback, [array[i], i, array])) return array[i];\n  }\n}\nfunction isFunction(func /*: any*/) /*: boolean %checks*/{\n  // $FlowIgnore[method-unbinding]\n  return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';\n}\nfunction isNum(num /*: any*/) /*: boolean %checks*/{\n  return typeof num === 'number' && !isNaN(num);\n}\nfunction int(a /*: string*/) /*: number*/{\n  return parseInt(a, 10);\n}\nfunction dontSetMe(props /*: Object*/, propName /*: string*/, componentName /*: string*/) /*: ?Error*/{\n  if (props[propName]) {\n    return new Error(`Invalid prop ${propName} passed to ${componentName} - do not set this, set it on the child.`);\n  }\n}", "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.browserPrefixToKey = browserPrefixToKey;\nexports.browserPrefixToStyle = browserPrefixToStyle;\nexports.default = void 0;\nexports.getPrefix = getPrefix;\nconst prefixes = ['Moz', 'Webkit', 'O', 'ms'];\nfunction getPrefix() /*: string*/{\n  let prop /*: string*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transform';\n  // Ensure we're running in an environment where there is actually a global\n  // `window` obj\n  if (typeof window === 'undefined') return '';\n\n  // If we're in a pseudo-browser server-side environment, this access\n  // path may not exist, so bail out if it doesn't.\n  const style = window.document?.documentElement?.style;\n  if (!style) return '';\n  if (prop in style) return '';\n  for (let i = 0; i < prefixes.length; i++) {\n    if (browserPrefixToKey(prop, prefixes[i]) in style) return prefixes[i];\n  }\n  return '';\n}\nfunction browserPrefixToKey(prop /*: string*/, prefix /*: string*/) /*: string*/{\n  return prefix ? `${prefix}${kebabToTitleCase(prop)}` : prop;\n}\nfunction browserPrefixToStyle(prop /*: string*/, prefix /*: string*/) /*: string*/{\n  return prefix ? `-${prefix.toLowerCase()}-${prop}` : prop;\n}\nfunction kebabToTitleCase(str /*: string*/) /*: string*/{\n  let out = '';\n  let shouldCapitalize = true;\n  for (let i = 0; i < str.length; i++) {\n    if (shouldCapitalize) {\n      out += str[i].toUpperCase();\n      shouldCapitalize = false;\n    } else if (str[i] === '-') {\n      shouldCapitalize = true;\n    } else {\n      out += str[i];\n    }\n  }\n  return out;\n}\n\n// Default export is the prefix itself, like 'Moz', 'Webkit', etc\n// Note that you may have to re-test for certain things; for instance, Chrome 50\n// can handle unprefixed `transform`, but not unprefixed `user-select`\nvar _default = exports.default = (getPrefix() /*: string*/);", "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addClassName = addClassName;\nexports.addEvent = addEvent;\nexports.addUserSelectStyles = addUserSelectStyles;\nexports.createCSSTransform = createCSSTransform;\nexports.createSVGTransform = createSVGTransform;\nexports.getTouch = getTouch;\nexports.getTouchIdentifier = getTouchIdentifier;\nexports.getTranslation = getTranslation;\nexports.innerHeight = innerHeight;\nexports.innerWidth = innerWidth;\nexports.matchesSelector = matchesSelector;\nexports.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;\nexports.offsetXYFromParent = offsetXYFromParent;\nexports.outerHeight = outerHeight;\nexports.outerWidth = outerWidth;\nexports.removeClassName = removeClassName;\nexports.removeEvent = removeEvent;\nexports.scheduleRemoveUserSelectStyles = scheduleRemoveUserSelectStyles;\nvar _shims = require(\"./shims\");\nvar _getPrefix = _interopRequireWildcard(require(\"./getPrefix\"));\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) \"default\" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }\n/*:: import type {ControlPosition, PositionOffsetControlPosition, MouseTouchEvent} from './types';*/\nlet matchesSelectorFunc = '';\nfunction matchesSelector(el /*: Node*/, selector /*: string*/) /*: boolean*/{\n  if (!matchesSelectorFunc) {\n    matchesSelectorFunc = (0, _shims.findInArray)(['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'], function (method) {\n      // $FlowIgnore: Doesn't think elements are indexable\n      return (0, _shims.isFunction)(el[method]);\n    });\n  }\n\n  // Might not be found entirely (not an Element?) - in that case, bail\n  // $FlowIgnore: Doesn't think elements are indexable\n  if (!(0, _shims.isFunction)(el[matchesSelectorFunc])) return false;\n\n  // $FlowIgnore: Doesn't think elements are indexable\n  return el[matchesSelectorFunc](selector);\n}\n\n// Works up the tree to the draggable itself attempting to match selector.\nfunction matchesSelectorAndParentsTo(el /*: Node*/, selector /*: string*/, baseNode /*: Node*/) /*: boolean*/{\n  let node = el;\n  do {\n    if (matchesSelector(node, selector)) return true;\n    if (node === baseNode) return false;\n    // $FlowIgnore[incompatible-type]\n    node = node.parentNode;\n  } while (node);\n  return false;\n}\nfunction addEvent(el /*: ?Node*/, event /*: string*/, handler /*: Function*/, inputOptions /*: Object*/) /*: void*/{\n  if (!el) return;\n  const options = {\n    capture: true,\n    ...inputOptions\n  };\n  // $FlowIgnore[method-unbinding]\n  if (el.addEventListener) {\n    el.addEventListener(event, handler, options);\n  } else if (el.attachEvent) {\n    el.attachEvent('on' + event, handler);\n  } else {\n    // $FlowIgnore: Doesn't think elements are indexable\n    el['on' + event] = handler;\n  }\n}\nfunction removeEvent(el /*: ?Node*/, event /*: string*/, handler /*: Function*/, inputOptions /*: Object*/) /*: void*/{\n  if (!el) return;\n  const options = {\n    capture: true,\n    ...inputOptions\n  };\n  // $FlowIgnore[method-unbinding]\n  if (el.removeEventListener) {\n    el.removeEventListener(event, handler, options);\n  } else if (el.detachEvent) {\n    el.detachEvent('on' + event, handler);\n  } else {\n    // $FlowIgnore: Doesn't think elements are indexable\n    el['on' + event] = null;\n  }\n}\nfunction outerHeight(node /*: HTMLElement*/) /*: number*/{\n  // This is deliberately excluding margin for our calculations, since we are using\n  // offsetTop which is including margin. See getBoundPosition\n  let height = node.clientHeight;\n  const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n  height += (0, _shims.int)(computedStyle.borderTopWidth);\n  height += (0, _shims.int)(computedStyle.borderBottomWidth);\n  return height;\n}\nfunction outerWidth(node /*: HTMLElement*/) /*: number*/{\n  // This is deliberately excluding margin for our calculations, since we are using\n  // offsetLeft which is including margin. See getBoundPosition\n  let width = node.clientWidth;\n  const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n  width += (0, _shims.int)(computedStyle.borderLeftWidth);\n  width += (0, _shims.int)(computedStyle.borderRightWidth);\n  return width;\n}\nfunction innerHeight(node /*: HTMLElement*/) /*: number*/{\n  let height = node.clientHeight;\n  const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n  height -= (0, _shims.int)(computedStyle.paddingTop);\n  height -= (0, _shims.int)(computedStyle.paddingBottom);\n  return height;\n}\nfunction innerWidth(node /*: HTMLElement*/) /*: number*/{\n  let width = node.clientWidth;\n  const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n  width -= (0, _shims.int)(computedStyle.paddingLeft);\n  width -= (0, _shims.int)(computedStyle.paddingRight);\n  return width;\n}\n/*:: interface EventWithOffset {\n  clientX: number, clientY: number\n}*/\n// Get from offsetParent\nfunction offsetXYFromParent(evt /*: EventWithOffset*/, offsetParent /*: HTMLElement*/, scale /*: number*/) /*: ControlPosition*/{\n  const isBody = offsetParent === offsetParent.ownerDocument.body;\n  const offsetParentRect = isBody ? {\n    left: 0,\n    top: 0\n  } : offsetParent.getBoundingClientRect();\n  const x = (evt.clientX + offsetParent.scrollLeft - offsetParentRect.left) / scale;\n  const y = (evt.clientY + offsetParent.scrollTop - offsetParentRect.top) / scale;\n  return {\n    x,\n    y\n  };\n}\nfunction createCSSTransform(controlPos /*: ControlPosition*/, positionOffset /*: PositionOffsetControlPosition*/) /*: Object*/{\n  const translation = getTranslation(controlPos, positionOffset, 'px');\n  return {\n    [(0, _getPrefix.browserPrefixToKey)('transform', _getPrefix.default)]: translation\n  };\n}\nfunction createSVGTransform(controlPos /*: ControlPosition*/, positionOffset /*: PositionOffsetControlPosition*/) /*: string*/{\n  const translation = getTranslation(controlPos, positionOffset, '');\n  return translation;\n}\nfunction getTranslation(_ref /*:: */, positionOffset /*: PositionOffsetControlPosition*/, unitSuffix /*: string*/) /*: string*/{\n  let {\n    x,\n    y\n  } /*: ControlPosition*/ = _ref /*: ControlPosition*/;\n  let translation = `translate(${x}${unitSuffix},${y}${unitSuffix})`;\n  if (positionOffset) {\n    const defaultX = `${typeof positionOffset.x === 'string' ? positionOffset.x : positionOffset.x + unitSuffix}`;\n    const defaultY = `${typeof positionOffset.y === 'string' ? positionOffset.y : positionOffset.y + unitSuffix}`;\n    translation = `translate(${defaultX}, ${defaultY})` + translation;\n  }\n  return translation;\n}\nfunction getTouch(e /*: MouseTouchEvent*/, identifier /*: number*/) /*: ?{clientX: number, clientY: number}*/{\n  return e.targetTouches && (0, _shims.findInArray)(e.targetTouches, t => identifier === t.identifier) || e.changedTouches && (0, _shims.findInArray)(e.changedTouches, t => identifier === t.identifier);\n}\nfunction getTouchIdentifier(e /*: MouseTouchEvent*/) /*: ?number*/{\n  if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;\n  if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;\n}\n\n// User-select Hacks:\n//\n// Useful for preventing blue highlights all over everything when dragging.\n\n// Note we're passing `document` b/c we could be iframed\nfunction addUserSelectStyles(doc /*: ?Document*/) {\n  if (!doc) return;\n  let styleEl = doc.getElementById('react-draggable-style-el');\n  if (!styleEl) {\n    styleEl = doc.createElement('style');\n    styleEl.type = 'text/css';\n    styleEl.id = 'react-draggable-style-el';\n    styleEl.innerHTML = '.react-draggable-transparent-selection *::-moz-selection {all: inherit;}\\n';\n    styleEl.innerHTML += '.react-draggable-transparent-selection *::selection {all: inherit;}\\n';\n    doc.getElementsByTagName('head')[0].appendChild(styleEl);\n  }\n  if (doc.body) addClassName(doc.body, 'react-draggable-transparent-selection');\n}\nfunction scheduleRemoveUserSelectStyles(doc /*: ?Document*/) {\n  // Prevent a possible \"forced reflow\"\n  if (window.requestAnimationFrame) {\n    window.requestAnimationFrame(() => {\n      removeUserSelectStyles(doc);\n    });\n  } else {\n    removeUserSelectStyles(doc);\n  }\n}\nfunction removeUserSelectStyles(doc /*: ?Document*/) {\n  if (!doc) return;\n  try {\n    if (doc.body) removeClassName(doc.body, 'react-draggable-transparent-selection');\n    // $FlowIgnore: IE\n    if (doc.selection) {\n      // $FlowIgnore: IE\n      doc.selection.empty();\n    } else {\n      // Remove selection caused by scroll, unless it's a focused input\n      // (we use doc.defaultView in case we're in an iframe)\n      const selection = (doc.defaultView || window).getSelection();\n      if (selection && selection.type !== 'Caret') {\n        selection.removeAllRanges();\n      }\n    }\n  } catch (e) {\n    // probably IE\n  }\n}\nfunction addClassName(el /*: HTMLElement*/, className /*: string*/) {\n  if (el.classList) {\n    el.classList.add(className);\n  } else {\n    if (!el.className.match(new RegExp(`(?:^|\\\\s)${className}(?!\\\\S)`))) {\n      el.className += ` ${className}`;\n    }\n  }\n}\nfunction removeClassName(el /*: HTMLElement*/, className /*: string*/) {\n  if (el.classList) {\n    el.classList.remove(className);\n  } else {\n    el.className = el.className.replace(new RegExp(`(?:^|\\\\s)${className}(?!\\\\S)`, 'g'), '');\n  }\n}", "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.canDragX = canDragX;\nexports.canDragY = canDragY;\nexports.createCoreData = createCoreData;\nexports.createDraggableData = createDraggableData;\nexports.getBoundPosition = getBoundPosition;\nexports.getControlPosition = getControlPosition;\nexports.snapToGrid = snapToGrid;\nvar _shims = require(\"./shims\");\nvar _domFns = require(\"./domFns\");\n/*:: import type Draggable from '../Draggable';*/\n/*:: import type {Bounds, ControlPosition, DraggableData, MouseTouchEvent} from './types';*/\n/*:: import type DraggableCore from '../DraggableCore';*/\nfunction getBoundPosition(draggable /*: Draggable*/, x /*: number*/, y /*: number*/) /*: [number, number]*/{\n  // If no bounds, short-circuit and move on\n  if (!draggable.props.bounds) return [x, y];\n\n  // Clone new bounds\n  let {\n    bounds\n  } = draggable.props;\n  bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);\n  const node = findDOMNode(draggable);\n  if (typeof bounds === 'string') {\n    const {\n      ownerDocument\n    } = node;\n    const ownerWindow = ownerDocument.defaultView;\n    let boundNode;\n    if (bounds === 'parent') {\n      boundNode = node.parentNode;\n    } else {\n      // Flow assigns the wrong return type (Node) for getRootNode(),\n      // so we cast it to one of the correct types (Element).\n      // The others are Document and ShadowRoot.\n      // All three implement querySelector() so it's safe to call.\n      const rootNode = ((node.getRootNode() /*: any*/) /*: Element*/);\n      boundNode = rootNode.querySelector(bounds);\n    }\n    if (!(boundNode instanceof ownerWindow.HTMLElement)) {\n      throw new Error('Bounds selector \"' + bounds + '\" could not find an element.');\n    }\n    const boundNodeEl /*: HTMLElement*/ = boundNode; // for Flow, can't seem to refine correctly\n    const nodeStyle = ownerWindow.getComputedStyle(node);\n    const boundNodeStyle = ownerWindow.getComputedStyle(boundNodeEl);\n    // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.\n    bounds = {\n      left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),\n      top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),\n      right: (0, _domFns.innerWidth)(boundNodeEl) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),\n      bottom: (0, _domFns.innerHeight)(boundNodeEl) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)\n    };\n  }\n\n  // Keep x and y below right and bottom limits...\n  if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);\n  if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom);\n\n  // But above left and top limits.\n  if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);\n  if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);\n  return [x, y];\n}\nfunction snapToGrid(grid /*: [number, number]*/, pendingX /*: number*/, pendingY /*: number*/) /*: [number, number]*/{\n  const x = Math.round(pendingX / grid[0]) * grid[0];\n  const y = Math.round(pendingY / grid[1]) * grid[1];\n  return [x, y];\n}\nfunction canDragX(draggable /*: Draggable*/) /*: boolean*/{\n  return draggable.props.axis === 'both' || draggable.props.axis === 'x';\n}\nfunction canDragY(draggable /*: Draggable*/) /*: boolean*/{\n  return draggable.props.axis === 'both' || draggable.props.axis === 'y';\n}\n\n// Get {x, y} positions from event.\nfunction getControlPosition(e /*: MouseTouchEvent*/, touchIdentifier /*: ?number*/, draggableCore /*: DraggableCore*/) /*: ?ControlPosition*/{\n  const touchObj = typeof touchIdentifier === 'number' ? (0, _domFns.getTouch)(e, touchIdentifier) : null;\n  if (typeof touchIdentifier === 'number' && !touchObj) return null; // not the right touch\n  const node = findDOMNode(draggableCore);\n  // User can provide an offsetParent if desired.\n  const offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;\n  return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent, draggableCore.props.scale);\n}\n\n// Create an data object exposed by <DraggableCore>'s events\nfunction createCoreData(draggable /*: DraggableCore*/, x /*: number*/, y /*: number*/) /*: DraggableData*/{\n  const isStart = !(0, _shims.isNum)(draggable.lastX);\n  const node = findDOMNode(draggable);\n  if (isStart) {\n    // If this is our first move, use the x and y as last coords.\n    return {\n      node,\n      deltaX: 0,\n      deltaY: 0,\n      lastX: x,\n      lastY: y,\n      x,\n      y\n    };\n  } else {\n    // Otherwise calculate proper values.\n    return {\n      node,\n      deltaX: x - draggable.lastX,\n      deltaY: y - draggable.lastY,\n      lastX: draggable.lastX,\n      lastY: draggable.lastY,\n      x,\n      y\n    };\n  }\n}\n\n// Create an data exposed by <Draggable>'s events\nfunction createDraggableData(draggable /*: Draggable*/, coreData /*: DraggableData*/) /*: DraggableData*/{\n  const scale = draggable.props.scale;\n  return {\n    node: coreData.node,\n    x: draggable.state.x + coreData.deltaX / scale,\n    y: draggable.state.y + coreData.deltaY / scale,\n    deltaX: coreData.deltaX / scale,\n    deltaY: coreData.deltaY / scale,\n    lastX: draggable.state.x,\n    lastY: draggable.state.y\n  };\n}\n\n// A lot faster than stringify/parse\nfunction cloneBounds(bounds /*: Bounds*/) /*: Bounds*/{\n  return {\n    left: bounds.left,\n    top: bounds.top,\n    right: bounds.right,\n    bottom: bounds.bottom\n  };\n}\nfunction findDOMNode(draggable /*: Draggable | DraggableCore*/) /*: HTMLElement*/{\n  const node = draggable.findDOMNode();\n  if (!node) {\n    throw new Error('<DraggableCore>: Unmounted during event!');\n  }\n  // $FlowIgnore we can't assert on HTMLElement due to tests... FIXME\n  return node;\n}", "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = log;\n/*eslint no-console:0*/\nfunction log() {\n  if (undefined) console.log(...arguments);\n}", "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\nvar _reactDom = _interopRequireDefault(require(\"react-dom\"));\nvar _domFns = require(\"./utils/domFns\");\nvar _positionFns = require(\"./utils/positionFns\");\nvar _shims = require(\"./utils/shims\");\nvar _log = _interopRequireDefault(require(\"./utils/log\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) \"default\" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/*:: import type {EventHandler, MouseTouchEvent} from './utils/types';*/\n/*:: import type {Element as ReactElement} from 'react';*/\n// Simple abstraction for dragging events names.\nconst eventsFor = {\n  touch: {\n    start: 'touchstart',\n    move: 'touchmove',\n    stop: 'touchend'\n  },\n  mouse: {\n    start: 'mousedown',\n    move: 'mousemove',\n    stop: 'mouseup'\n  }\n};\n\n// Default to mouse events.\nlet dragEventFor = eventsFor.mouse;\n/*:: export type DraggableData = {\n  node: HTMLElement,\n  x: number, y: number,\n  deltaX: number, deltaY: number,\n  lastX: number, lastY: number,\n};*/\n/*:: export type DraggableEventHandler = (e: MouseEvent, data: DraggableData) => void | false;*/\n/*:: export type ControlPosition = {x: number, y: number};*/\n/*:: export type PositionOffsetControlPosition = {x: number|string, y: number|string};*/\n/*:: export type DraggableCoreDefaultProps = {\n  allowAnyClick: boolean,\n  allowMobileScroll: boolean,\n  disabled: boolean,\n  enableUserSelectHack: boolean,\n  onStart: DraggableEventHandler,\n  onDrag: DraggableEventHandler,\n  onStop: DraggableEventHandler,\n  onMouseDown: (e: MouseEvent) => void,\n  scale: number,\n};*/\n/*:: export type DraggableCoreProps = {\n  ...DraggableCoreDefaultProps,\n  cancel: string,\n  children: ReactElement<any>,\n  offsetParent: HTMLElement,\n  grid: [number, number],\n  handle: string,\n  nodeRef?: ?React.ElementRef<any>,\n};*/\n//\n// Define <DraggableCore>.\n//\n// <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can\n// work well with libraries that require more control over the element.\n//\n\nclass DraggableCore extends React.Component /*:: <DraggableCoreProps>*/{\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"dragging\", false);\n    // Used while dragging to determine deltas.\n    _defineProperty(this, \"lastX\", NaN);\n    _defineProperty(this, \"lastY\", NaN);\n    _defineProperty(this, \"touchIdentifier\", null);\n    _defineProperty(this, \"mounted\", false);\n    _defineProperty(this, \"handleDragStart\", e => {\n      // Make it possible to attach event handlers on top of this one.\n      this.props.onMouseDown(e);\n\n      // Only accept left-clicks.\n      if (!this.props.allowAnyClick && typeof e.button === 'number' && e.button !== 0) return false;\n\n      // Get nodes. Be sure to grab relative document (could be iframed)\n      const thisNode = this.findDOMNode();\n      if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {\n        throw new Error('<DraggableCore> not mounted on DragStart!');\n      }\n      const {\n        ownerDocument\n      } = thisNode;\n\n      // Short circuit if handle or cancel prop was provided and selector doesn't match.\n      if (this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.handle, thisNode) || this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.cancel, thisNode)) {\n        return;\n      }\n\n      // Prevent scrolling on mobile devices, like ipad/iphone.\n      // Important that this is after handle/cancel.\n      if (e.type === 'touchstart' && !this.props.allowMobileScroll) e.preventDefault();\n\n      // Set touch identifier in component state if this is a touch event. This allows us to\n      // distinguish between individual touches on multitouch screens by identifying which\n      // touchpoint was set to this element.\n      const touchIdentifier = (0, _domFns.getTouchIdentifier)(e);\n      this.touchIdentifier = touchIdentifier;\n\n      // Get the current drag point from the event. This is used as the offset.\n      const position = (0, _positionFns.getControlPosition)(e, touchIdentifier, this);\n      if (position == null) return; // not possible but satisfies flow\n      const {\n        x,\n        y\n      } = position;\n\n      // Create an event object with all the data parents need to make a decision here.\n      const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n      (0, _log.default)('DraggableCore: handleDragStart: %j', coreEvent);\n\n      // Call event handler. If it returns explicit false, cancel.\n      (0, _log.default)('calling', this.props.onStart);\n      const shouldUpdate = this.props.onStart(e, coreEvent);\n      if (shouldUpdate === false || this.mounted === false) return;\n\n      // Add a style to the body to disable user-select. This prevents text from\n      // being selected all over the page.\n      if (this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument);\n\n      // Initiate dragging. Set the current x and y as offsets\n      // so we know how much we've moved during the drag. This allows us\n      // to drag elements around even if they have been moved, without issue.\n      this.dragging = true;\n      this.lastX = x;\n      this.lastY = y;\n\n      // Add events to the document directly so we catch when the user's mouse/touch moves outside of\n      // this element. We use different events depending on whether or not we have detected that this\n      // is a touch-capable device.\n      (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, this.handleDrag);\n      (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, this.handleDragStop);\n    });\n    _defineProperty(this, \"handleDrag\", e => {\n      // Get the current drag point from the event. This is used as the offset.\n      const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);\n      if (position == null) return;\n      let {\n        x,\n        y\n      } = position;\n\n      // Snap to grid if prop has been provided\n      if (Array.isArray(this.props.grid)) {\n        let deltaX = x - this.lastX,\n          deltaY = y - this.lastY;\n        [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);\n        if (!deltaX && !deltaY) return; // skip useless drag\n        x = this.lastX + deltaX, y = this.lastY + deltaY;\n      }\n      const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n      (0, _log.default)('DraggableCore: handleDrag: %j', coreEvent);\n\n      // Call event handler. If it returns explicit false, trigger end.\n      const shouldUpdate = this.props.onDrag(e, coreEvent);\n      if (shouldUpdate === false || this.mounted === false) {\n        try {\n          // $FlowIgnore\n          this.handleDragStop(new MouseEvent('mouseup'));\n        } catch (err) {\n          // Old browsers\n          const event = ((document.createEvent('MouseEvents') /*: any*/) /*: MouseTouchEvent*/);\n          // I see why this insanity was deprecated\n          // $FlowIgnore\n          event.initMouseEvent('mouseup', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n          this.handleDragStop(event);\n        }\n        return;\n      }\n      this.lastX = x;\n      this.lastY = y;\n    });\n    _defineProperty(this, \"handleDragStop\", e => {\n      if (!this.dragging) return;\n      const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);\n      if (position == null) return;\n      let {\n        x,\n        y\n      } = position;\n\n      // Snap to grid if prop has been provided\n      if (Array.isArray(this.props.grid)) {\n        let deltaX = x - this.lastX || 0;\n        let deltaY = y - this.lastY || 0;\n        [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);\n        x = this.lastX + deltaX, y = this.lastY + deltaY;\n      }\n      const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n\n      // Call event handler\n      const shouldContinue = this.props.onStop(e, coreEvent);\n      if (shouldContinue === false || this.mounted === false) return false;\n      const thisNode = this.findDOMNode();\n      if (thisNode) {\n        // Remove user-select hack\n        if (this.props.enableUserSelectHack) (0, _domFns.scheduleRemoveUserSelectStyles)(thisNode.ownerDocument);\n      }\n      (0, _log.default)('DraggableCore: handleDragStop: %j', coreEvent);\n\n      // Reset the el.\n      this.dragging = false;\n      this.lastX = NaN;\n      this.lastY = NaN;\n      if (thisNode) {\n        // Remove event handlers\n        (0, _log.default)('DraggableCore: Removing handlers');\n        (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, this.handleDrag);\n        (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, this.handleDragStop);\n      }\n    });\n    _defineProperty(this, \"onMouseDown\", e => {\n      dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse\n\n      return this.handleDragStart(e);\n    });\n    _defineProperty(this, \"onMouseUp\", e => {\n      dragEventFor = eventsFor.mouse;\n      return this.handleDragStop(e);\n    });\n    // Same as onMouseDown (start drag), but now consider this a touch device.\n    _defineProperty(this, \"onTouchStart\", e => {\n      // We're on a touch device now, so change the event handlers\n      dragEventFor = eventsFor.touch;\n      return this.handleDragStart(e);\n    });\n    _defineProperty(this, \"onTouchEnd\", e => {\n      // We're on a touch device now, so change the event handlers\n      dragEventFor = eventsFor.touch;\n      return this.handleDragStop(e);\n    });\n  }\n  componentDidMount() {\n    this.mounted = true;\n    // Touch handlers must be added with {passive: false} to be cancelable.\n    // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n    const thisNode = this.findDOMNode();\n    if (thisNode) {\n      (0, _domFns.addEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {\n        passive: false\n      });\n    }\n  }\n  componentWillUnmount() {\n    this.mounted = false;\n    // Remove any leftover event handlers. Remove both touch and mouse handlers in case\n    // some browser quirk caused a touch event to fire during a mouse move, or vice versa.\n    const thisNode = this.findDOMNode();\n    if (thisNode) {\n      const {\n        ownerDocument\n      } = thisNode;\n      (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);\n      (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);\n      (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);\n      (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);\n      (0, _domFns.removeEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {\n        passive: false\n      });\n      if (this.props.enableUserSelectHack) (0, _domFns.scheduleRemoveUserSelectStyles)(ownerDocument);\n    }\n  }\n\n  // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find\n  // the underlying DOM node ourselves. See the README for more information.\n  findDOMNode() /*: ?HTMLElement*/{\n    return this.props?.nodeRef ? this.props?.nodeRef?.current : _reactDom.default.findDOMNode(this);\n  }\n  render() /*: React.Element<any>*/{\n    // Reuse the child provided\n    // This makes it flexible to use whatever element is wanted (div, ul, etc)\n    return /*#__PURE__*/React.cloneElement(React.Children.only(this.props.children), {\n      // Note: mouseMove handler is attached to document so it will still function\n      // when the user drags quickly and leaves the bounds of the element.\n      onMouseDown: this.onMouseDown,\n      onMouseUp: this.onMouseUp,\n      // onTouchStart is added on `componentDidMount` so they can be added with\n      // {passive: false}, which allows it to cancel. See\n      // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n      onTouchEnd: this.onTouchEnd\n    });\n  }\n}\nexports.default = DraggableCore;\n_defineProperty(DraggableCore, \"displayName\", 'DraggableCore');\n_defineProperty(DraggableCore, \"propTypes\", {\n  /**\n   * `allowAnyClick` allows dragging using any mouse button.\n   * By default, we only accept the left button.\n   *\n   * Defaults to `false`.\n   */\n  allowAnyClick: _propTypes.default.bool,\n  /**\n   * `allowMobileScroll` turns off cancellation of the 'touchstart' event\n   * on mobile devices. Only enable this if you are having trouble with click\n   * events. Prefer using 'handle' / 'cancel' instead.\n   *\n   * Defaults to `false`.\n   */\n  allowMobileScroll: _propTypes.default.bool,\n  children: _propTypes.default.node.isRequired,\n  /**\n   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,\n   * with the exception of `onMouseDown`, will not fire.\n   */\n  disabled: _propTypes.default.bool,\n  /**\n   * By default, we add 'user-select:none' attributes to the document body\n   * to prevent ugly text selection during drag. If this is causing problems\n   * for your app, set this to `false`.\n   */\n  enableUserSelectHack: _propTypes.default.bool,\n  /**\n   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets\n   * instead of using the parent node.\n   */\n  offsetParent: function (props /*: DraggableCoreProps*/, propName /*: $Keys<DraggableCoreProps>*/) {\n    if (props[propName] && props[propName].nodeType !== 1) {\n      throw new Error('Draggable\\'s offsetParent must be a DOM Node.');\n    }\n  },\n  /**\n   * `grid` specifies the x and y that dragging should snap to.\n   */\n  grid: _propTypes.default.arrayOf(_propTypes.default.number),\n  /**\n   * `handle` specifies a selector to be used as the handle that initiates drag.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *         return (\n   *            <Draggable handle=\".handle\">\n   *              <div>\n   *                  <div className=\"handle\">Click me to drag</div>\n   *                  <div>This is some other content</div>\n   *              </div>\n   *           </Draggable>\n   *         );\n   *       }\n   *   });\n   * ```\n   */\n  handle: _propTypes.default.string,\n  /**\n   * `cancel` specifies a selector to be used to prevent drag initialization.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *           return(\n   *               <Draggable cancel=\".cancel\">\n   *                   <div>\n   *                     <div className=\"cancel\">You can't drag from here</div>\n   *                     <div>Dragging here works fine</div>\n   *                   </div>\n   *               </Draggable>\n   *           );\n   *       }\n   *   });\n   * ```\n   */\n  cancel: _propTypes.default.string,\n  /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.\n   * Unfortunately, in order for <Draggable> to work properly, we need raw access\n   * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`\n   * as in this example:\n   *\n   * function MyComponent() {\n   *   const nodeRef = React.useRef(null);\n   *   return (\n   *     <Draggable nodeRef={nodeRef}>\n   *       <div ref={nodeRef}>Example Target</div>\n   *     </Draggable>\n   *   );\n   * }\n   *\n   * This can be used for arbitrarily nested components, so long as the ref ends up\n   * pointing to the actual child DOM node and not a custom component.\n   */\n  nodeRef: _propTypes.default.object,\n  /**\n   * Called when dragging starts.\n   * If this function returns the boolean false, dragging will be canceled.\n   */\n  onStart: _propTypes.default.func,\n  /**\n   * Called while dragging.\n   * If this function returns the boolean false, dragging will be canceled.\n   */\n  onDrag: _propTypes.default.func,\n  /**\n   * Called when dragging stops.\n   * If this function returns the boolean false, the drag will remain active.\n   */\n  onStop: _propTypes.default.func,\n  /**\n   * A workaround option which can be passed if onMouseDown needs to be accessed,\n   * since it'll always be blocked (as there is internal use of onMouseDown)\n   */\n  onMouseDown: _propTypes.default.func,\n  /**\n   * `scale`, if set, applies scaling while dragging an element\n   */\n  scale: _propTypes.default.number,\n  /**\n   * These properties should be defined on the child, not here.\n   */\n  className: _shims.dontSetMe,\n  style: _shims.dontSetMe,\n  transform: _shims.dontSetMe\n});\n_defineProperty(DraggableCore, \"defaultProps\", {\n  allowAnyClick: false,\n  // by default only accept left click\n  allowMobileScroll: false,\n  disabled: false,\n  enableUserSelectHack: true,\n  onStart: function () {},\n  onDrag: function () {},\n  onStop: function () {},\n  onMouseDown: function () {},\n  scale: 1\n});", "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"DraggableCore\", {\n  enumerable: true,\n  get: function () {\n    return _DraggableCore.default;\n  }\n});\nexports.default = void 0;\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\nvar _reactDom = _interopRequireDefault(require(\"react-dom\"));\nvar _clsx = require(\"clsx\");\nvar _domFns = require(\"./utils/domFns\");\nvar _positionFns = require(\"./utils/positionFns\");\nvar _shims = require(\"./utils/shims\");\nvar _DraggableCore = _interopRequireDefault(require(\"./DraggableCore\"));\nvar _log = _interopRequireDefault(require(\"./utils/log\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) \"default\" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); } /*:: import type {ControlPosition, PositionOffsetControlPosition, DraggableCoreProps, DraggableCoreDefaultProps} from './DraggableCore';*/\n/*:: import type {Bounds, DraggableEventHandler} from './utils/types';*/\n/*:: import type {Element as ReactElement} from 'react';*/\n/*:: type DraggableState = {\n  dragging: boolean,\n  dragged: boolean,\n  x: number, y: number,\n  slackX: number, slackY: number,\n  isElementSVG: boolean,\n  prevPropsPosition: ?ControlPosition,\n};*/\n/*:: export type DraggableDefaultProps = {\n  ...DraggableCoreDefaultProps,\n  axis: 'both' | 'x' | 'y' | 'none',\n  bounds: Bounds | string | false,\n  defaultClassName: string,\n  defaultClassNameDragging: string,\n  defaultClassNameDragged: string,\n  defaultPosition: ControlPosition,\n  scale: number,\n};*/\n/*:: export type DraggableProps = {\n  ...DraggableCoreProps,\n  ...DraggableDefaultProps,\n  positionOffset: PositionOffsetControlPosition,\n  position: ControlPosition,\n};*/\n//\n// Define <Draggable>\n//\nclass Draggable extends React.Component /*:: <DraggableProps, DraggableState>*/{\n  // React 16.3+\n  // Arity (props, state)\n  static getDerivedStateFromProps(_ref /*:: */, _ref2 /*:: */) /*: ?Partial<DraggableState>*/{\n    let {\n      position\n    } /*: DraggableProps*/ = _ref /*: DraggableProps*/;\n    let {\n      prevPropsPosition\n    } /*: DraggableState*/ = _ref2 /*: DraggableState*/;\n    // Set x/y if a new position is provided in props that is different than the previous.\n    if (position && (!prevPropsPosition || position.x !== prevPropsPosition.x || position.y !== prevPropsPosition.y)) {\n      (0, _log.default)('Draggable: getDerivedStateFromProps %j', {\n        position,\n        prevPropsPosition\n      });\n      return {\n        x: position.x,\n        y: position.y,\n        prevPropsPosition: {\n          ...position\n        }\n      };\n    }\n    return null;\n  }\n  constructor(props /*: DraggableProps*/) {\n    super(props);\n    _defineProperty(this, \"onDragStart\", (e, coreData) => {\n      (0, _log.default)('Draggable: onDragStart: %j', coreData);\n\n      // Short-circuit if user's callback killed it.\n      const shouldStart = this.props.onStart(e, (0, _positionFns.createDraggableData)(this, coreData));\n      // Kills start event on core as well, so move handlers are never bound.\n      if (shouldStart === false) return false;\n      this.setState({\n        dragging: true,\n        dragged: true\n      });\n    });\n    _defineProperty(this, \"onDrag\", (e, coreData) => {\n      if (!this.state.dragging) return false;\n      (0, _log.default)('Draggable: onDrag: %j', coreData);\n      const uiData = (0, _positionFns.createDraggableData)(this, coreData);\n      const newState = {\n        x: uiData.x,\n        y: uiData.y,\n        slackX: 0,\n        slackY: 0\n      };\n\n      // Keep within bounds.\n      if (this.props.bounds) {\n        // Save original x and y.\n        const {\n          x,\n          y\n        } = newState;\n\n        // Add slack to the values used to calculate bound position. This will ensure that if\n        // we start removing slack, the element won't react to it right away until it's been\n        // completely removed.\n        newState.x += this.state.slackX;\n        newState.y += this.state.slackY;\n\n        // Get bound position. This will ceil/floor the x and y within the boundaries.\n        const [newStateX, newStateY] = (0, _positionFns.getBoundPosition)(this, newState.x, newState.y);\n        newState.x = newStateX;\n        newState.y = newStateY;\n\n        // Recalculate slack by noting how much was shaved by the boundPosition handler.\n        newState.slackX = this.state.slackX + (x - newState.x);\n        newState.slackY = this.state.slackY + (y - newState.y);\n\n        // Update the event we fire to reflect what really happened after bounds took effect.\n        uiData.x = newState.x;\n        uiData.y = newState.y;\n        uiData.deltaX = newState.x - this.state.x;\n        uiData.deltaY = newState.y - this.state.y;\n      }\n\n      // Short-circuit if user's callback killed it.\n      const shouldUpdate = this.props.onDrag(e, uiData);\n      if (shouldUpdate === false) return false;\n      this.setState(newState);\n    });\n    _defineProperty(this, \"onDragStop\", (e, coreData) => {\n      if (!this.state.dragging) return false;\n\n      // Short-circuit if user's callback killed it.\n      const shouldContinue = this.props.onStop(e, (0, _positionFns.createDraggableData)(this, coreData));\n      if (shouldContinue === false) return false;\n      (0, _log.default)('Draggable: onDragStop: %j', coreData);\n      const newState /*: Partial<DraggableState>*/ = {\n        dragging: false,\n        slackX: 0,\n        slackY: 0\n      };\n\n      // If this is a controlled component, the result of this operation will be to\n      // revert back to the old position. We expect a handler on `onDragStop`, at the least.\n      const controlled = Boolean(this.props.position);\n      if (controlled) {\n        const {\n          x,\n          y\n        } = this.props.position;\n        newState.x = x;\n        newState.y = y;\n      }\n      this.setState(newState);\n    });\n    this.state = {\n      // Whether or not we are currently dragging.\n      dragging: false,\n      // Whether or not we have been dragged before.\n      dragged: false,\n      // Current transform x and y.\n      x: props.position ? props.position.x : props.defaultPosition.x,\n      y: props.position ? props.position.y : props.defaultPosition.y,\n      prevPropsPosition: {\n        ...props.position\n      },\n      // Used for compensating for out-of-bounds drags\n      slackX: 0,\n      slackY: 0,\n      // Can only determine if SVG after mounting\n      isElementSVG: false\n    };\n    if (props.position && !(props.onDrag || props.onStop)) {\n      // eslint-disable-next-line no-console\n      console.warn('A `position` was applied to this <Draggable>, without drag handlers. This will make this ' + 'component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the ' + '`position` of this element.');\n    }\n  }\n  componentDidMount() {\n    // Check to see if the element passed is an instanceof SVGElement\n    if (typeof window.SVGElement !== 'undefined' && this.findDOMNode() instanceof window.SVGElement) {\n      this.setState({\n        isElementSVG: true\n      });\n    }\n  }\n  componentWillUnmount() {\n    if (this.state.dragging) {\n      this.setState({\n        dragging: false\n      }); // prevents invariant if unmounted while dragging\n    }\n  }\n\n  // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find\n  // the underlying DOM node ourselves. See the README for more information.\n  findDOMNode() /*: ?HTMLElement*/{\n    return this.props?.nodeRef?.current ?? _reactDom.default.findDOMNode(this);\n  }\n  render() /*: ReactElement<any>*/{\n    const {\n      axis,\n      bounds,\n      children,\n      defaultPosition,\n      defaultClassName,\n      defaultClassNameDragging,\n      defaultClassNameDragged,\n      position,\n      positionOffset,\n      scale,\n      ...draggableCoreProps\n    } = this.props;\n    let style = {};\n    let svgTransform = null;\n\n    // If this is controlled, we don't want to move it - unless it's dragging.\n    const controlled = Boolean(position);\n    const draggable = !controlled || this.state.dragging;\n    const validPosition = position || defaultPosition;\n    const transformOpts = {\n      // Set left if horizontal drag is enabled\n      x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : validPosition.x,\n      // Set top if vertical drag is enabled\n      y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : validPosition.y\n    };\n\n    // If this element was SVG, we use the `transform` attribute.\n    if (this.state.isElementSVG) {\n      svgTransform = (0, _domFns.createSVGTransform)(transformOpts, positionOffset);\n    } else {\n      // Add a CSS transform to move the element around. This allows us to move the element around\n      // without worrying about whether or not it is relatively or absolutely positioned.\n      // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>\n      // has a clean slate.\n      style = (0, _domFns.createCSSTransform)(transformOpts, positionOffset);\n    }\n\n    // Mark with class while dragging\n    const className = (0, _clsx.clsx)(children.props.className || '', defaultClassName, {\n      [defaultClassNameDragging]: this.state.dragging,\n      [defaultClassNameDragged]: this.state.dragged\n    });\n\n    // Reuse the child provided\n    // This makes it flexible to use whatever element is wanted (div, ul, etc)\n    return /*#__PURE__*/React.createElement(_DraggableCore.default, _extends({}, draggableCoreProps, {\n      onStart: this.onDragStart,\n      onDrag: this.onDrag,\n      onStop: this.onDragStop\n    }), /*#__PURE__*/React.cloneElement(React.Children.only(children), {\n      className: className,\n      style: {\n        ...children.props.style,\n        ...style\n      },\n      transform: svgTransform\n    }));\n  }\n}\nexports.default = Draggable;\n_defineProperty(Draggable, \"displayName\", 'Draggable');\n_defineProperty(Draggable, \"propTypes\", {\n  // Accepts all props <DraggableCore> accepts.\n  ..._DraggableCore.default.propTypes,\n  /**\n   * `axis` determines which axis the draggable can move.\n   *\n   *  Note that all callbacks will still return data as normal. This only\n   *  controls flushing to the DOM.\n   *\n   * 'both' allows movement horizontally and vertically.\n   * 'x' limits movement to horizontal axis.\n   * 'y' limits movement to vertical axis.\n   * 'none' limits all movement.\n   *\n   * Defaults to 'both'.\n   */\n  axis: _propTypes.default.oneOf(['both', 'x', 'y', 'none']),\n  /**\n   * `bounds` determines the range of movement available to the element.\n   * Available values are:\n   *\n   * 'parent' restricts movement within the Draggable's parent node.\n   *\n   * Alternatively, pass an object with the following properties, all of which are optional:\n   *\n   * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}\n   *\n   * All values are in px.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *         return (\n   *            <Draggable bounds={{right: 300, bottom: 300}}>\n   *              <div>Content</div>\n   *           </Draggable>\n   *         );\n   *       }\n   *   });\n   * ```\n   */\n  bounds: _propTypes.default.oneOfType([_propTypes.default.shape({\n    left: _propTypes.default.number,\n    right: _propTypes.default.number,\n    top: _propTypes.default.number,\n    bottom: _propTypes.default.number\n  }), _propTypes.default.string, _propTypes.default.oneOf([false])]),\n  defaultClassName: _propTypes.default.string,\n  defaultClassNameDragging: _propTypes.default.string,\n  defaultClassNameDragged: _propTypes.default.string,\n  /**\n   * `defaultPosition` specifies the x and y that the dragged item should start at\n   *\n   * Example:\n   *\n   * ```jsx\n   *      let App = React.createClass({\n   *          render: function () {\n   *              return (\n   *                  <Draggable defaultPosition={{x: 25, y: 25}}>\n   *                      <div>I start with transformX: 25px and transformY: 25px;</div>\n   *                  </Draggable>\n   *              );\n   *          }\n   *      });\n   * ```\n   */\n  defaultPosition: _propTypes.default.shape({\n    x: _propTypes.default.number,\n    y: _propTypes.default.number\n  }),\n  positionOffset: _propTypes.default.shape({\n    x: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),\n    y: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])\n  }),\n  /**\n   * `position`, if present, defines the current position of the element.\n   *\n   *  This is similar to how form elements in React work - if no `position` is supplied, the component\n   *  is uncontrolled.\n   *\n   * Example:\n   *\n   * ```jsx\n   *      let App = React.createClass({\n   *          render: function () {\n   *              return (\n   *                  <Draggable position={{x: 25, y: 25}}>\n   *                      <div>I start with transformX: 25px and transformY: 25px;</div>\n   *                  </Draggable>\n   *              );\n   *          }\n   *      });\n   * ```\n   */\n  position: _propTypes.default.shape({\n    x: _propTypes.default.number,\n    y: _propTypes.default.number\n  }),\n  /**\n   * These properties should be defined on the child, not here.\n   */\n  className: _shims.dontSetMe,\n  style: _shims.dontSetMe,\n  transform: _shims.dontSetMe\n});\n_defineProperty(Draggable, \"defaultProps\", {\n  ..._DraggableCore.default.defaultProps,\n  axis: 'both',\n  bounds: false,\n  defaultClassName: 'react-draggable',\n  defaultClassNameDragging: 'react-draggable-dragging',\n  defaultClassNameDragged: 'react-draggable-dragged',\n  defaultPosition: {\n    x: 0,\n    y: 0\n  },\n  scale: 1\n});", "\"use strict\";\n\nconst {\n  default: Draggable,\n  DraggableCore\n} = require('./Draggable');\n\n// Previous versions of this lib exported <Draggable> as the root export. As to no-// them, or TypeScript, we export *both* as the root and as 'default'.\n// See https://github.com/mzabriskie/react-draggable/pull/254\n// and https://github.com/mzabriskie/react-draggable/issues/266\nmodule.exports = Draggable;\nmodule.exports.default = Draggable;\nmodule.exports.DraggableCore = DraggableCore;", "\"use strict\";\n\nexports.__esModule = true;\nexports.cloneElement = cloneElement;\nvar _react = _interopRequireDefault(require(\"react\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n// React.addons.cloneWithProps look-alike that merges style & className.\nfunction cloneElement(element, props) {\n  if (props.style && element.props.style) {\n    props.style = _objectSpread(_objectSpread({}, element.props.style), props.style);\n  }\n  if (props.className && element.props.className) {\n    props.className = element.props.className + \" \" + props.className;\n  }\n  return /*#__PURE__*/_react.default.cloneElement(element, props);\n}", "\"use strict\";\n\nexports.__esModule = true;\nexports.resizableProps = void 0;\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\nvar _reactDraggable = require(\"react-draggable\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar resizableProps = {\n  /*\n  * Restricts resizing to a particular axis (default: 'both')\n  * 'both' - allows resizing by width or height\n  * 'x' - only allows the width to be changed\n  * 'y' - only allows the height to be changed\n  * 'none' - disables resizing altogether\n  * */\n  axis: _propTypes.default.oneOf(['both', 'x', 'y', 'none']),\n  className: _propTypes.default.string,\n  /*\n  * Require that one and only one child be present.\n  * */\n  children: _propTypes.default.element.isRequired,\n  /*\n  * These will be passed wholesale to react-draggable's DraggableCore\n  * */\n  draggableOpts: _propTypes.default.shape({\n    allowAnyClick: _propTypes.default.bool,\n    cancel: _propTypes.default.string,\n    children: _propTypes.default.node,\n    disabled: _propTypes.default.bool,\n    enableUserSelectHack: _propTypes.default.bool,\n    offsetParent: _propTypes.default.node,\n    grid: _propTypes.default.arrayOf(_propTypes.default.number),\n    handle: _propTypes.default.string,\n    nodeRef: _propTypes.default.object,\n    onStart: _propTypes.default.func,\n    onDrag: _propTypes.default.func,\n    onStop: _propTypes.default.func,\n    onMouseDown: _propTypes.default.func,\n    scale: _propTypes.default.number\n  }),\n  /*\n  * Initial height\n  * */\n  height: function height() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    var props = args[0];\n    // Required if resizing height or both\n    if (props.axis === 'both' || props.axis === 'y') {\n      var _PropTypes$number;\n      return (_PropTypes$number = _propTypes.default.number).isRequired.apply(_PropTypes$number, args);\n    }\n    return _propTypes.default.number.apply(_propTypes.default, args);\n  },\n  /*\n  * Customize cursor resize handle\n  * */\n  handle: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),\n  /*\n  * If you change this, be sure to update your css\n  * */\n  handleSize: _propTypes.default.arrayOf(_propTypes.default.number),\n  lockAspectRatio: _propTypes.default.bool,\n  /*\n  * Max X & Y measure\n  * */\n  maxConstraints: _propTypes.default.arrayOf(_propTypes.default.number),\n  /*\n  * Min X & Y measure\n  * */\n  minConstraints: _propTypes.default.arrayOf(_propTypes.default.number),\n  /*\n  * Called on stop resize event\n  * */\n  onResizeStop: _propTypes.default.func,\n  /*\n  * Called on start resize event\n  * */\n  onResizeStart: _propTypes.default.func,\n  /*\n  * Called on resize event\n  * */\n  onResize: _propTypes.default.func,\n  /*\n  * Defines which resize handles should be rendered (default: 'se')\n  * 's' - South handle (bottom-center)\n  * 'w' - West handle (left-center)\n  * 'e' - East handle (right-center)\n  * 'n' - North handle (top-center)\n  * 'sw' - Southwest handle (bottom-left)\n  * 'nw' - Northwest handle (top-left)\n  * 'se' - Southeast handle (bottom-right)\n  * 'ne' - Northeast handle (top-center)\n  * */\n  resizeHandles: _propTypes.default.arrayOf(_propTypes.default.oneOf(['s', 'w', 'e', 'n', 'sw', 'nw', 'se', 'ne'])),\n  /*\n  * If `transform: scale(n)` is set on the parent, this should be set to `n`.\n  * */\n  transformScale: _propTypes.default.number,\n  /*\n   * Initial width\n   */\n  width: function width() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    var props = args[0];\n    // Required if resizing width or both\n    if (props.axis === 'both' || props.axis === 'x') {\n      var _PropTypes$number2;\n      return (_PropTypes$number2 = _propTypes.default.number).isRequired.apply(_PropTypes$number2, args);\n    }\n    return _propTypes.default.number.apply(_propTypes.default, args);\n  }\n};\nexports.resizableProps = resizableProps;", "\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _reactDraggable = require(\"react-draggable\");\nvar _utils = require(\"./utils\");\nvar _propTypes = require(\"./propTypes\");\nvar _excluded = [\"children\", \"className\", \"draggableOpts\", \"width\", \"height\", \"handle\", \"handleSize\", \"lockAspectRatio\", \"axis\", \"minConstraints\", \"maxConstraints\", \"onResize\", \"onResizeStop\", \"onResizeStart\", \"resizeHandles\", \"transformScale\"];\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n// The base <Resizable> component.\n// This component does not have state and relies on the parent to set its props based on callback data.\nvar Resizable = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Resizable, _React$Component);\n  function Resizable() {\n    var _this;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.handleRefs = {};\n    _this.lastHandleRect = null;\n    _this.slack = null;\n    return _this;\n  }\n  var _proto = Resizable.prototype;\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.resetData();\n  };\n  _proto.resetData = function resetData() {\n    this.lastHandleRect = this.slack = null;\n  }\n\n  // Clamp width and height within provided constraints\n  ;\n  _proto.runConstraints = function runConstraints(width, height) {\n    var _this$props = this.props,\n      minConstraints = _this$props.minConstraints,\n      maxConstraints = _this$props.maxConstraints,\n      lockAspectRatio = _this$props.lockAspectRatio;\n    // short circuit\n    if (!minConstraints && !maxConstraints && !lockAspectRatio) return [width, height];\n\n    // If constraining to min and max, we need to also fit width and height to aspect ratio.\n    if (lockAspectRatio) {\n      var ratio = this.props.width / this.props.height;\n      var deltaW = width - this.props.width;\n      var deltaH = height - this.props.height;\n\n      // Find which coordinate was greater and should push the other toward it.\n      // E.g.:\n      // ratio = 1, deltaW = 10, deltaH = 5, deltaH should become 10.\n      // ratio = 2, deltaW = 10, deltaH = 6, deltaW should become 12.\n      if (Math.abs(deltaW) > Math.abs(deltaH * ratio)) {\n        height = width / ratio;\n      } else {\n        width = height * ratio;\n      }\n    }\n    var oldW = width,\n      oldH = height;\n\n    // Add slack to the values used to calculate bound position. This will ensure that if\n    // we start removing slack, the element won't react to it right away until it's been\n    // completely removed.\n    var _ref = this.slack || [0, 0],\n      slackW = _ref[0],\n      slackH = _ref[1];\n    width += slackW;\n    height += slackH;\n    if (minConstraints) {\n      width = Math.max(minConstraints[0], width);\n      height = Math.max(minConstraints[1], height);\n    }\n    if (maxConstraints) {\n      width = Math.min(maxConstraints[0], width);\n      height = Math.min(maxConstraints[1], height);\n    }\n\n    // If the width or height changed, we must have introduced some slack. Record it for the next iteration.\n    this.slack = [slackW + (oldW - width), slackH + (oldH - height)];\n    return [width, height];\n  }\n\n  /**\n   * Wrapper around drag events to provide more useful data.\n   *\n   * @param  {String} handlerName Handler name to wrap.\n   * @return {Function}           Handler function.\n   */;\n  _proto.resizeHandler = function resizeHandler(handlerName, axis) {\n    var _this2 = this;\n    return function (e, _ref2) {\n      var node = _ref2.node,\n        deltaX = _ref2.deltaX,\n        deltaY = _ref2.deltaY;\n      // Reset data in case it was left over somehow (should not be possible)\n      if (handlerName === 'onResizeStart') _this2.resetData();\n\n      // Axis restrictions\n      var canDragX = (_this2.props.axis === 'both' || _this2.props.axis === 'x') && axis !== 'n' && axis !== 's';\n      var canDragY = (_this2.props.axis === 'both' || _this2.props.axis === 'y') && axis !== 'e' && axis !== 'w';\n      // No dragging possible.\n      if (!canDragX && !canDragY) return;\n\n      // Decompose axis for later use\n      var axisV = axis[0];\n      var axisH = axis[axis.length - 1]; // intentionally not axis[1], so that this catches axis === 'w' for example\n\n      // Track the element being dragged to account for changes in position.\n      // If a handle's position is changed between callbacks, we need to factor this in to the next callback.\n      // Failure to do so will cause the element to \"skip\" when resized upwards or leftwards.\n      var handleRect = node.getBoundingClientRect();\n      if (_this2.lastHandleRect != null) {\n        // If the handle has repositioned on either axis since last render,\n        // we need to increase our callback values by this much.\n        // Only checking 'n', 'w' since resizing by 's', 'w' won't affect the overall position on page,\n        if (axisH === 'w') {\n          var deltaLeftSinceLast = handleRect.left - _this2.lastHandleRect.left;\n          deltaX += deltaLeftSinceLast;\n        }\n        if (axisV === 'n') {\n          var deltaTopSinceLast = handleRect.top - _this2.lastHandleRect.top;\n          deltaY += deltaTopSinceLast;\n        }\n      }\n      // Storage of last rect so we know how much it has really moved.\n      _this2.lastHandleRect = handleRect;\n\n      // Reverse delta if using top or left drag handles.\n      if (axisH === 'w') deltaX = -deltaX;\n      if (axisV === 'n') deltaY = -deltaY;\n\n      // Update w/h by the deltas. Also factor in transformScale.\n      var width = _this2.props.width + (canDragX ? deltaX / _this2.props.transformScale : 0);\n      var height = _this2.props.height + (canDragY ? deltaY / _this2.props.transformScale : 0);\n\n      // Run user-provided constraints.\n      var _this2$runConstraints = _this2.runConstraints(width, height);\n      width = _this2$runConstraints[0];\n      height = _this2$runConstraints[1];\n      var dimensionsChanged = width !== _this2.props.width || height !== _this2.props.height;\n\n      // Call user-supplied callback if present.\n      var cb = typeof _this2.props[handlerName] === 'function' ? _this2.props[handlerName] : null;\n      // Don't call 'onResize' if dimensions haven't changed.\n      var shouldSkipCb = handlerName === 'onResize' && !dimensionsChanged;\n      if (cb && !shouldSkipCb) {\n        e.persist == null ? void 0 : e.persist();\n        cb(e, {\n          node: node,\n          size: {\n            width: width,\n            height: height\n          },\n          handle: axis\n        });\n      }\n\n      // Reset internal data\n      if (handlerName === 'onResizeStop') _this2.resetData();\n    };\n  }\n\n  // Render a resize handle given an axis & DOM ref. Ref *must* be attached for\n  // the underlying draggable library to work properly.\n  ;\n  _proto.renderResizeHandle = function renderResizeHandle(handleAxis, ref) {\n    var handle = this.props.handle;\n    // No handle provided, make the default\n    if (!handle) {\n      return /*#__PURE__*/React.createElement(\"span\", {\n        className: \"react-resizable-handle react-resizable-handle-\" + handleAxis,\n        ref: ref\n      });\n    }\n    // Handle is a function, such as:\n    // `handle={(handleAxis) => <span className={...} />}`\n    if (typeof handle === 'function') {\n      return handle(handleAxis, ref);\n    }\n    // Handle is a React component (composite or DOM).\n    var isDOMElement = typeof handle.type === 'string';\n    var props = _objectSpread({\n      ref: ref\n    }, isDOMElement ? {} : {\n      handleAxis: handleAxis\n    });\n    return /*#__PURE__*/React.cloneElement(handle, props);\n  };\n  _proto.render = function render() {\n    var _this3 = this;\n    // Pass along only props not meant for the `<Resizable>`.`\n    // eslint-disable-next-line no-unused-vars\n    var _this$props2 = this.props,\n      children = _this$props2.children,\n      className = _this$props2.className,\n      draggableOpts = _this$props2.draggableOpts,\n      width = _this$props2.width,\n      height = _this$props2.height,\n      handle = _this$props2.handle,\n      handleSize = _this$props2.handleSize,\n      lockAspectRatio = _this$props2.lockAspectRatio,\n      axis = _this$props2.axis,\n      minConstraints = _this$props2.minConstraints,\n      maxConstraints = _this$props2.maxConstraints,\n      onResize = _this$props2.onResize,\n      onResizeStop = _this$props2.onResizeStop,\n      onResizeStart = _this$props2.onResizeStart,\n      resizeHandles = _this$props2.resizeHandles,\n      transformScale = _this$props2.transformScale,\n      p = _objectWithoutPropertiesLoose(_this$props2, _excluded);\n\n    // What we're doing here is getting the child of this element, and cloning it with this element's props.\n    // We are then defining its children as:\n    // 1. Its original children (resizable's child's children), and\n    // 2. One or more draggable handles.\n    return (0, _utils.cloneElement)(children, _objectSpread(_objectSpread({}, p), {}, {\n      className: (className ? className + \" \" : '') + \"react-resizable\",\n      children: [].concat(children.props.children, resizeHandles.map(function (handleAxis) {\n        var _this3$handleRefs$han;\n        // Create a ref to the handle so that `<DraggableCore>` doesn't have to use ReactDOM.findDOMNode().\n        var ref = (_this3$handleRefs$han = _this3.handleRefs[handleAxis]) != null ? _this3$handleRefs$han : _this3.handleRefs[handleAxis] = /*#__PURE__*/React.createRef();\n        return /*#__PURE__*/React.createElement(_reactDraggable.DraggableCore, _extends({}, draggableOpts, {\n          nodeRef: ref,\n          key: \"resizableHandle-\" + handleAxis,\n          onStop: _this3.resizeHandler('onResizeStop', handleAxis),\n          onStart: _this3.resizeHandler('onResizeStart', handleAxis),\n          onDrag: _this3.resizeHandler('onResize', handleAxis)\n        }), _this3.renderResizeHandle(handleAxis, ref));\n      }))\n    }));\n  };\n  return Resizable;\n}(React.Component);\nexports.default = Resizable;\nResizable.propTypes = _propTypes.resizableProps;\nResizable.defaultProps = {\n  axis: 'both',\n  handleSize: [20, 20],\n  lockAspectRatio: false,\n  minConstraints: [20, 20],\n  maxConstraints: [Infinity, Infinity],\n  resizeHandles: ['se'],\n  transformScale: 1\n};", "\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\nvar _Resizable = _interopRequireDefault(require(\"./Resizable\"));\nvar _propTypes2 = require(\"./propTypes\");\nvar _excluded = [\"handle\", \"handleSize\", \"onResize\", \"onResizeStart\", \"onResizeStop\", \"draggableOpts\", \"minConstraints\", \"maxConstraints\", \"lockAspectRatio\", \"axis\", \"width\", \"height\", \"resizeHandles\", \"style\", \"transformScale\"];\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nvar ResizableBox = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(ResizableBox, _React$Component);\n  function ResizableBox() {\n    var _this;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.state = {\n      width: _this.props.width,\n      height: _this.props.height,\n      propsWidth: _this.props.width,\n      propsHeight: _this.props.height\n    };\n    _this.onResize = function (e, data) {\n      var size = data.size;\n      if (_this.props.onResize) {\n        e.persist == null ? void 0 : e.persist();\n        _this.setState(size, function () {\n          return _this.props.onResize && _this.props.onResize(e, data);\n        });\n      } else {\n        _this.setState(size);\n      }\n    };\n    return _this;\n  }\n  ResizableBox.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n    // If parent changes height/width, set that in our state.\n    if (state.propsWidth !== props.width || state.propsHeight !== props.height) {\n      return {\n        width: props.width,\n        height: props.height,\n        propsWidth: props.width,\n        propsHeight: props.height\n      };\n    }\n    return null;\n  };\n  var _proto = ResizableBox.prototype;\n  _proto.render = function render() {\n    // Basic wrapper around a Resizable instance.\n    // If you use Resizable directly, you are responsible for updating the child component\n    // with a new width and height.\n    var _this$props = this.props,\n      handle = _this$props.handle,\n      handleSize = _this$props.handleSize,\n      onResize = _this$props.onResize,\n      onResizeStart = _this$props.onResizeStart,\n      onResizeStop = _this$props.onResizeStop,\n      draggableOpts = _this$props.draggableOpts,\n      minConstraints = _this$props.minConstraints,\n      maxConstraints = _this$props.maxConstraints,\n      lockAspectRatio = _this$props.lockAspectRatio,\n      axis = _this$props.axis,\n      width = _this$props.width,\n      height = _this$props.height,\n      resizeHandles = _this$props.resizeHandles,\n      style = _this$props.style,\n      transformScale = _this$props.transformScale,\n      props = _objectWithoutPropertiesLoose(_this$props, _excluded);\n    return /*#__PURE__*/React.createElement(_Resizable.default, {\n      axis: axis,\n      draggableOpts: draggableOpts,\n      handle: handle,\n      handleSize: handleSize,\n      height: this.state.height,\n      lockAspectRatio: lockAspectRatio,\n      maxConstraints: maxConstraints,\n      minConstraints: minConstraints,\n      onResizeStart: onResizeStart,\n      onResize: this.onResize,\n      onResizeStop: onResizeStop,\n      resizeHandles: resizeHandles,\n      transformScale: transformScale,\n      width: this.state.width\n    }, /*#__PURE__*/React.createElement(\"div\", _extends({}, props, {\n      style: _objectSpread(_objectSpread({}, style), {}, {\n        width: this.state.width + 'px',\n        height: this.state.height + 'px'\n      })\n    })));\n  };\n  return ResizableBox;\n}(React.Component);\nexports.default = ResizableBox;\n// PropTypes are identical to <Resizable>, except that children are not strictly required to be present.\nResizableBox.propTypes = _objectSpread(_objectSpread({}, _propTypes2.resizableProps), {}, {\n  children: _propTypes.default.element\n});", "'use strict';\nmodule.exports = function() {\n  throw new Error(\"Don't instantiate Resizable directly! Use require('react-resizable').Resizable\");\n};\n\nmodule.exports.Resizable = require('./build/Resizable').default;\nmodule.exports.ResizableBox = require('./build/ResizableBox').default;\n", "/**\n * Grid calculation utilities.\n *\n * These functions convert between grid units and pixel positions.\n */\n\nimport type { Position, ResizeHandleAxis } from \"./types.js\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Parameters needed for position calculations.\n */\nexport interface PositionParams {\n  readonly margin: readonly [number, number];\n  readonly containerPadding: readonly [number, number];\n  readonly containerWidth: number;\n  readonly cols: number;\n  readonly rowHeight: number;\n  readonly maxRows: number;\n}\n\n// ============================================================================\n// Grid Column/Row Calculations\n// ============================================================================\n\n/**\n * Calculate the width of a single grid column in pixels.\n *\n * @param positionParams - Grid parameters\n * @returns Column width in pixels\n */\nexport function calcGridColWidth(positionParams: PositionParams): number {\n  const { margin, containerPadding, containerWidth, cols } = positionParams;\n  return (\n    (containerWidth - margin[0] * (cols - 1) - containerPadding[0] * 2) / cols\n  );\n}\n\n/**\n * Calculate the pixel size for a grid unit dimension (width or height).\n *\n * Can be called as:\n * - calcGridItemWHPx(w, colWidth, margin[0]) for width\n * - calcGridItemWHPx(h, rowHeight, margin[1]) for height\n *\n * @param gridUnits - Size in grid units\n * @param colOrRowSize - Column width or row height in pixels\n * @param marginPx - Margin between items in pixels\n * @returns Size in pixels\n */\nexport function calcGridItemWHPx(\n  gridUnits: number,\n  colOrRowSize: number,\n  marginPx: number\n): number {\n  // 0 * Infinity === NaN, which causes problems with resize constraints\n  if (!Number.isFinite(gridUnits)) return gridUnits;\n  return Math.round(\n    colOrRowSize * gridUnits + Math.max(0, gridUnits - 1) * marginPx\n  );\n}\n\n// ============================================================================\n// Position Calculations\n// ============================================================================\n\n/**\n * Calculate pixel position for a grid item.\n *\n * Returns left, top, width, height in pixels.\n *\n * @param positionParams - Grid parameters\n * @param x - X coordinate in grid units\n * @param y - Y coordinate in grid units\n * @param w - Width in grid units\n * @param h - Height in grid units\n * @param dragPosition - If present, use exact left/top from drag callbacks\n * @param resizePosition - If present, use exact dimensions from resize callbacks\n * @returns Position in pixels\n */\nexport function calcGridItemPosition(\n  positionParams: PositionParams,\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  dragPosition?: { top: number; left: number } | null,\n  resizePosition?: {\n    top: number;\n    left: number;\n    height: number;\n    width: number;\n  } | null\n): Position {\n  const { margin, containerPadding, rowHeight } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n\n  let width: number;\n  let height: number;\n  let top: number;\n  let left: number;\n\n  // If resizing, use the exact width and height from resize callbacks\n  if (resizePosition) {\n    width = Math.round(resizePosition.width);\n    height = Math.round(resizePosition.height);\n  } else {\n    // Calculate from grid units\n    width = calcGridItemWHPx(w, colWidth, margin[0]);\n    height = calcGridItemWHPx(h, rowHeight, margin[1]);\n  }\n\n  // If dragging, use the exact left/top from drag callbacks\n  if (dragPosition) {\n    top = Math.round(dragPosition.top);\n    left = Math.round(dragPosition.left);\n  } else if (resizePosition) {\n    // If resizing, use the exact left/top from resize position\n    top = Math.round(resizePosition.top);\n    left = Math.round(resizePosition.left);\n  } else {\n    // Calculate from grid units\n    top = Math.round((rowHeight + margin[1]) * y + containerPadding[1]);\n    left = Math.round((colWidth + margin[0]) * x + containerPadding[0]);\n  }\n\n  // When not dragging or resizing, fix margin inconsistencies caused by rounding.\n  // Due to Math.round(), the gap between adjacent items can differ from the\n  // expected margin (e.g., 0px or 2px instead of 1px). We fix this by comparing\n  // where the next sibling would start vs where this item ends, and adjusting\n  // the width/height to maintain consistent margins.\n  if (!dragPosition && !resizePosition) {\n    if (Number.isFinite(w)) {\n      // Calculate where the next column's item would start\n      const siblingLeft = Math.round(\n        (colWidth + margin[0]) * (x + w) + containerPadding[0]\n      );\n      // Calculate actual margin: sibling start - (our left + our width)\n      const actualMarginRight = siblingLeft - left - width;\n      // Adjust width if margin doesn't match\n      if (actualMarginRight !== margin[0]) {\n        width += actualMarginRight - margin[0];\n      }\n    }\n\n    if (Number.isFinite(h)) {\n      // Calculate where the next row's item would start\n      const siblingTop = Math.round(\n        (rowHeight + margin[1]) * (y + h) + containerPadding[1]\n      );\n      // Calculate actual margin: sibling start - (our top + our height)\n      const actualMarginBottom = siblingTop - top - height;\n      // Adjust height if margin doesn't match\n      if (actualMarginBottom !== margin[1]) {\n        height += actualMarginBottom - margin[1];\n      }\n    }\n  }\n\n  return { top, left, width, height };\n}\n\n/**\n * Translate pixel coordinates to grid units.\n *\n * @param positionParams - Grid parameters\n * @param top - Top position in pixels (relative to parent)\n * @param left - Left position in pixels (relative to parent)\n * @param w - Width in grid units (for clamping)\n * @param h - Height in grid units (for clamping)\n * @returns x and y in grid units\n */\nexport function calcXY(\n  positionParams: PositionParams,\n  top: number,\n  left: number,\n  w: number,\n  h: number\n): { x: number; y: number } {\n  const { margin, containerPadding, cols, rowHeight, maxRows } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n\n  // left = containerPaddingX + x * (colWidth + marginX)\n  // x = (left - containerPaddingX) / (colWidth + marginX)\n  let x = Math.round((left - containerPadding[0]) / (colWidth + margin[0]));\n  let y = Math.round((top - containerPadding[1]) / (rowHeight + margin[1]));\n\n  // Clamp to grid bounds\n  x = clamp(x, 0, cols - w);\n  y = clamp(y, 0, maxRows - h);\n\n  return { x, y };\n}\n\n/**\n * Translate pixel coordinates to grid units without clamping.\n *\n * Use this with the constraint system for custom boundary control.\n *\n * @param positionParams - Grid parameters\n * @param top - Top position in pixels (relative to parent)\n * @param left - Left position in pixels (relative to parent)\n * @returns x and y in grid units (unclamped)\n */\nexport function calcXYRaw(\n  positionParams: PositionParams,\n  top: number,\n  left: number\n): { x: number; y: number } {\n  const { margin, containerPadding, rowHeight } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n\n  const x = Math.round((left - containerPadding[0]) / (colWidth + margin[0]));\n  const y = Math.round((top - containerPadding[1]) / (rowHeight + margin[1]));\n\n  return { x, y };\n}\n\n/**\n * Calculate grid units from pixel dimensions.\n *\n * @param positionParams - Grid parameters\n * @param width - Width in pixels\n * @param height - Height in pixels\n * @param x - X coordinate in grid units (for clamping)\n * @param y - Y coordinate in grid units (for clamping)\n * @param handle - Resize handle being used\n * @returns w, h in grid units\n */\nexport function calcWH(\n  positionParams: PositionParams,\n  width: number,\n  height: number,\n  x: number,\n  y: number,\n  handle: ResizeHandleAxis\n): { w: number; h: number } {\n  const { margin, maxRows, cols, rowHeight } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n\n  // width = colWidth * w - (margin * (w - 1))\n  // w = (width + margin) / (colWidth + margin)\n  const w = Math.round((width + margin[0]) / (colWidth + margin[0]));\n  const h = Math.round((height + margin[1]) / (rowHeight + margin[1]));\n\n  // Clamp based on resize handle direction\n  let _w = clamp(w, 0, cols - x);\n  let _h = clamp(h, 0, maxRows - y);\n\n  // West handles can resize to full width\n  if (handle === \"sw\" || handle === \"w\" || handle === \"nw\") {\n    _w = clamp(w, 0, cols);\n  }\n\n  // North handles can resize to full height\n  if (handle === \"nw\" || handle === \"n\" || handle === \"ne\") {\n    _h = clamp(h, 0, maxRows);\n  }\n\n  return { w: _w, h: _h };\n}\n\n/**\n * Calculate grid units from pixel dimensions without clamping.\n *\n * Use this with the constraint system for custom size control.\n *\n * @param positionParams - Grid parameters\n * @param width - Width in pixels\n * @param height - Height in pixels\n * @returns w, h in grid units (unclamped, minimum 1)\n */\nexport function calcWHRaw(\n  positionParams: PositionParams,\n  width: number,\n  height: number\n): { w: number; h: number } {\n  const { margin, rowHeight } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n\n  // width = colWidth * w - (margin * (w - 1))\n  // w = (width + margin) / (colWidth + margin)\n  const w = Math.max(\n    1,\n    Math.round((width + margin[0]) / (colWidth + margin[0]))\n  );\n  const h = Math.max(\n    1,\n    Math.round((height + margin[1]) / (rowHeight + margin[1]))\n  );\n\n  return { w, h };\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\n/**\n * Clamp a number between bounds.\n *\n * @param num - Number to clamp\n * @param lowerBound - Minimum value\n * @param upperBound - Maximum value\n * @returns Clamped value\n */\nexport function clamp(\n  num: number,\n  lowerBound: number,\n  upperBound: number\n): number {\n  return Math.max(Math.min(num, upperBound), lowerBound);\n}\n\n// ============================================================================\n// Grid Background Calculations\n// ============================================================================\n\n/**\n * Grid cell dimension information for rendering backgrounds or overlays.\n */\nexport interface GridCellDimensions {\n  /** Width of a single cell in pixels */\n  readonly cellWidth: number;\n  /** Height of a single cell in pixels */\n  readonly cellHeight: number;\n  /** Horizontal offset from container edge to first cell */\n  readonly offsetX: number;\n  /** Vertical offset from container edge to first cell */\n  readonly offsetY: number;\n  /** Horizontal gap between cells */\n  readonly gapX: number;\n  /** Vertical gap between cells */\n  readonly gapY: number;\n  /** Number of columns */\n  readonly cols: number;\n  /** Total container width */\n  readonly containerWidth: number;\n}\n\n/**\n * Configuration for grid cell dimension calculation.\n */\nexport interface GridCellConfig {\n  /** Container width in pixels */\n  width: number;\n  /** Number of columns */\n  cols: number;\n  /** Row height in pixels */\n  rowHeight: number;\n  /** Margin between items [x, y] */\n  margin?: readonly [number, number];\n  /** Container padding [x, y], defaults to margin if not specified */\n  containerPadding?: readonly [number, number] | null;\n}\n\n/**\n * Calculate grid cell dimensions for rendering backgrounds or overlays.\n *\n * This function provides all the measurements needed to render a visual\n * grid background that aligns with the actual grid cells.\n *\n * @param config - Grid configuration\n * @returns Cell dimensions and offsets\n *\n * @example\n * ```tsx\n * import { calcGridCellDimensions } from 'react-grid-layout/core';\n *\n * const dims = calcGridCellDimensions({\n *   width: 1200,\n *   cols: 12,\n *   rowHeight: 30,\n *   margin: [10, 10],\n *   containerPadding: [10, 10]\n * });\n *\n * // dims.cellWidth = 88.33...\n * // dims.cellHeight = 30\n * // dims.offsetX = 10 (containerPadding[0])\n * // dims.offsetY = 10 (containerPadding[1])\n * // dims.gapX = 10 (margin[0])\n * // dims.gapY = 10 (margin[1])\n * ```\n */\nexport function calcGridCellDimensions(\n  config: GridCellConfig\n): GridCellDimensions {\n  const {\n    width,\n    cols,\n    rowHeight,\n    margin = [10, 10],\n    containerPadding\n  } = config;\n\n  // Container padding defaults to margin if not specified\n  const padding = containerPadding ?? margin;\n\n  // Calculate cell width: total width minus padding and gaps, divided by columns\n  // Formula: width = 2*padding + cols*cellWidth + (cols-1)*gap\n  // Solving for cellWidth: cellWidth = (width - 2*padding - (cols-1)*gap) / cols\n  const cellWidth = (width - padding[0] * 2 - margin[0] * (cols - 1)) / cols;\n  const cellHeight = rowHeight;\n\n  return {\n    cellWidth,\n    cellHeight,\n    offsetX: padding[0],\n    offsetY: padding[1],\n    gapX: margin[0],\n    gapY: margin[1],\n    cols,\n    containerWidth: width\n  };\n}\n", "/**\n * Collision detection utilities for grid layouts.\n *\n * These functions determine if and where layout items overlap.\n */\n\nimport type { Layout, LayoutItem } from \"./types.js\";\n\n/**\n * Check if two layout items collide (overlap).\n *\n * Two items collide if their bounding boxes overlap and they are\n * not the same item.\n *\n * @param l1 - First layout item\n * @param l2 - Second layout item\n * @returns true if the items collide\n */\nexport function collides(l1: LayoutItem, l2: LayoutItem): boolean {\n  // Same element - can't collide with itself\n  if (l1.i === l2.i) return false;\n\n  // Check if bounding boxes don't overlap (any gap means no collision)\n  if (l1.x + l1.w <= l2.x) return false; // l1 is completely left of l2\n  if (l1.x >= l2.x + l2.w) return false; // l1 is completely right of l2\n  if (l1.y + l1.h <= l2.y) return false; // l1 is completely above l2\n  if (l1.y >= l2.y + l2.h) return false; // l1 is completely below l2\n\n  // Bounding boxes overlap\n  return true;\n}\n\n/**\n * Find the first item in the layout that collides with the given item.\n *\n * @param layout - Layout to search\n * @param layoutItem - Item to check for collisions\n * @returns The first colliding item, or undefined if none\n */\nexport function getFirstCollision(\n  layout: Layout,\n  layoutItem: LayoutItem\n): LayoutItem | undefined {\n  for (let i = 0; i < layout.length; i++) {\n    const item = layout[i];\n    if (item !== undefined && collides(item, layoutItem)) {\n      return item;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Find all items in the layout that collide with the given item.\n *\n * @param layout - Layout to search\n * @param layoutItem - Item to check for collisions\n * @returns Array of all colliding items (may be empty)\n */\nexport function getAllCollisions(\n  layout: Layout,\n  layoutItem: LayoutItem\n): LayoutItem[] {\n  return layout.filter((l): l is LayoutItem => collides(l, layoutItem));\n}\n", "/**\n * Sorting utilities for grid layouts.\n *\n * These functions sort layout items for compaction and iteration.\n */\n\nimport type { CompactType, Layout, LayoutItem } from \"./types.js\";\n\n/**\n * Sort layout items based on the compaction type.\n *\n * - Vertical compaction: sort by row (y) then column (x)\n * - Horizontal compaction: sort by column (x) then row (y)\n * - No compaction (null): return original order\n *\n * Does not modify the original layout.\n *\n * @param layout - Layout to sort\n * @param compactType - Type of compaction\n * @returns Sorted layout\n */\nexport function sortLayoutItems(\n  layout: Layout,\n  compactType: CompactType\n): LayoutItem[] {\n  if (compactType === \"horizontal\") {\n    return sortLayoutItemsByColRow(layout);\n  }\n  if (compactType === \"vertical\") {\n    return sortLayoutItemsByRowCol(layout);\n  }\n  if (compactType === \"wrap\") {\n    // Wrap mode uses row-col order (reading order: left-to-right, top-to-bottom)\n    return sortLayoutItemsByRowCol(layout);\n  }\n  // No compaction - return a copy to maintain immutability\n  return [...layout];\n}\n\n/**\n * Sort layout items by row ascending, then column ascending.\n *\n * Items are ordered from top-left to bottom-right, row by row.\n * This is the natural reading order for vertical compaction.\n *\n * Does not modify the original layout.\n *\n * @param layout - Layout to sort\n * @returns Sorted array of layout items\n */\nexport function sortLayoutItemsByRowCol(layout: Layout): LayoutItem[] {\n  return [...layout].sort((a, b) => {\n    // Primary sort by row (y)\n    if (a.y !== b.y) {\n      return a.y - b.y;\n    }\n    // Secondary sort by column (x)\n    return a.x - b.x;\n  });\n}\n\n/**\n * Sort layout items by column ascending, then row ascending.\n *\n * Items are ordered from top-left to bottom-right, column by column.\n * This is the natural order for horizontal compaction.\n *\n * Does not modify the original layout.\n *\n * @param layout - Layout to sort\n * @returns Sorted array of layout items\n */\nexport function sortLayoutItemsByColRow(layout: Layout): LayoutItem[] {\n  return [...layout].sort((a, b) => {\n    // Primary sort by column (x)\n    if (a.x !== b.x) {\n      return a.x - b.x;\n    }\n    // Secondary sort by row (y)\n    return a.y - b.y;\n  });\n}\n", "/**\n * Core layout manipulation utilities.\n *\n * These functions create, modify, and query grid layouts.\n * All functions treat layouts as immutable - they return new arrays/objects.\n */\n\nimport type { CompactType, Layout, LayoutItem, Mutable } from \"./types.js\";\nimport { getAllCollisions, getFirstCollision } from \"./collision.js\";\nimport { sortLayoutItems } from \"./sort.js\";\n\n// ============================================================================\n// Layout Queries\n// ============================================================================\n\n/**\n * Get the bottom-most Y coordinate of the layout.\n *\n * This is the Y position plus height of the lowest item.\n *\n * @param layout - Layout to measure\n * @returns The bottom Y coordinate (0 if layout is empty)\n */\nexport function bottom(layout: Layout): number {\n  let max = 0;\n  for (let i = 0; i < layout.length; i++) {\n    const item = layout[i];\n    if (item !== undefined) {\n      const bottomY = item.y + item.h;\n      if (bottomY > max) max = bottomY;\n    }\n  }\n  return max;\n}\n\n/**\n * Get a layout item by its ID.\n *\n * @param layout - Layout to search\n * @param id - Item ID to find\n * @returns The layout item, or undefined if not found\n */\nexport function getLayoutItem(\n  layout: Layout,\n  id: string\n): LayoutItem | undefined {\n  for (let i = 0; i < layout.length; i++) {\n    const item = layout[i];\n    if (item !== undefined && item.i === id) {\n      return item;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Get all static items from the layout.\n *\n * Static items cannot be moved or resized by the user.\n *\n * @param layout - Layout to filter\n * @returns Array of static layout items\n */\nexport function getStatics(layout: Layout): LayoutItem[] {\n  return layout.filter((l): l is LayoutItem => l.static === true);\n}\n\n// ============================================================================\n// Layout Cloning\n// ============================================================================\n\n/**\n * Clone a layout item.\n *\n * Creates a shallow copy with all properties preserved.\n * Boolean properties are normalized (undefined becomes false).\n *\n * @param layoutItem - Item to clone\n * @returns A new layout item with the same properties\n */\nexport function cloneLayoutItem(layoutItem: LayoutItem): LayoutItem {\n  return {\n    i: layoutItem.i,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    w: layoutItem.w,\n    h: layoutItem.h,\n    minW: layoutItem.minW,\n    maxW: layoutItem.maxW,\n    minH: layoutItem.minH,\n    maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved),\n    static: Boolean(layoutItem.static),\n    isDraggable: layoutItem.isDraggable,\n    isResizable: layoutItem.isResizable,\n    resizeHandles: layoutItem.resizeHandles,\n    constraints: layoutItem.constraints,\n    isBounded: layoutItem.isBounded\n  };\n}\n\n/**\n * Clone an entire layout.\n *\n * Creates a new array with cloned items.\n *\n * @param layout - Layout to clone\n * @returns A new layout with cloned items\n */\nexport function cloneLayout(layout: Layout): LayoutItem[] {\n  const newLayout: LayoutItem[] = new Array(layout.length);\n  for (let i = 0; i < layout.length; i++) {\n    const item = layout[i];\n    if (item !== undefined) {\n      newLayout[i] = cloneLayoutItem(item);\n    }\n  }\n  return newLayout;\n}\n\n// ============================================================================\n// Layout Modification\n// ============================================================================\n\n/**\n * Replace a layout item in a layout.\n *\n * Returns a new layout with the item replaced. Other items are not cloned.\n *\n * @param layout - Layout to modify\n * @param layoutItem - New item (matched by `i` property)\n * @returns New layout with the item replaced\n */\nexport function modifyLayout(\n  layout: Layout,\n  layoutItem: LayoutItem\n): LayoutItem[] {\n  const newLayout: LayoutItem[] = new Array(layout.length);\n  for (let i = 0; i < layout.length; i++) {\n    const item = layout[i];\n    if (item !== undefined) {\n      if (layoutItem.i === item.i) {\n        newLayout[i] = layoutItem;\n      } else {\n        newLayout[i] = item;\n      }\n    }\n  }\n  return newLayout;\n}\n\n/**\n * Apply a transformation to a layout item.\n *\n * Finds the item by key, clones it, applies the callback, and returns\n * a new layout with the modified item.\n *\n * @param layout - Layout to modify\n * @param itemKey - Key of the item to modify\n * @param cb - Callback that receives the cloned item and returns the modified item\n * @returns Tuple of [new layout, modified item or null if not found]\n */\nexport function withLayoutItem(\n  layout: Layout,\n  itemKey: string,\n  cb: (item: LayoutItem) => LayoutItem\n): [LayoutItem[], LayoutItem | null] {\n  let item = getLayoutItem(layout, itemKey);\n  if (!item) {\n    return [[...layout], null];\n  }\n\n  // Clone, then modify via callback\n  item = cb(cloneLayoutItem(item));\n  const newLayout = modifyLayout(layout, item);\n\n  return [newLayout, item];\n}\n\n// ============================================================================\n// Bounds Correction\n// ============================================================================\n\n/**\n * Ensure all layout items fit within the grid bounds.\n *\n * - Items overflowing right are moved left\n * - Items overflowing left are moved to x=0 and clamped to grid width\n * - Static items that collide with other statics are moved down\n *\n * **IMPORTANT**: This function mutates the layout items in place for performance.\n * The type signature uses `Mutable<LayoutItem>[]` to make this explicit.\n * Clone the layout first (e.g., with `cloneLayout()`) if you need immutability.\n *\n * @param layout - Layout to correct (items WILL be mutated)\n * @param bounds - Grid bounds\n * @returns The same layout array (for chaining)\n */\nexport function correctBounds(\n  layout: Mutable<LayoutItem>[],\n  bounds: { cols: number }\n): LayoutItem[] {\n  const collidesWith = getStatics(layout);\n\n  for (let i = 0; i < layout.length; i++) {\n    const l = layout[i];\n    if (l === undefined) continue;\n\n    // Overflows right\n    if (l.x + l.w > bounds.cols) {\n      l.x = bounds.cols - l.w;\n    }\n\n    // Overflows left\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n\n    if (!l.static) {\n      collidesWith.push(l);\n    } else {\n      // Static items that collide with other statics must be moved down\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n\n  return layout;\n}\n\n// ============================================================================\n// Move Operations\n// ============================================================================\n\n/**\n * Move a layout element to a new position.\n *\n * Handles collision detection and cascading movements.\n * Does not compact the layout - call `compact()` separately.\n *\n * **Note**: This function mutates the `l` parameter directly for performance.\n * The item's x, y, and moved properties will be modified. Callers should\n * ideally pass a cloned item if they need to preserve the original.\n *\n * @param layout - Full layout\n * @param l - Item to move (will be mutated)\n * @param x - New X position (or undefined to keep current)\n * @param y - New Y position (or undefined to keep current)\n * @param isUserAction - True if this is a direct user action (affects collision resolution)\n * @param preventCollision - True to block movement into occupied space (item snaps back). No effect if allowOverlap is true.\n * @param compactType - Compaction type for collision resolution\n * @param cols - Number of columns in the grid\n * @param allowOverlap - True to allow items to stack on top of each other\n * @returns The updated layout\n */\nexport function moveElement(\n  layout: Layout,\n  l: LayoutItem,\n  x: number | undefined,\n  y: number | undefined,\n  isUserAction: boolean | undefined,\n  preventCollision: boolean | undefined,\n  compactType: CompactType,\n  cols: number,\n  allowOverlap?: boolean\n): LayoutItem[] {\n  // Static items can't be moved unless explicitly draggable\n  if (l.static && l.isDraggable !== true) {\n    return [...layout];\n  }\n\n  // Short-circuit if position unchanged\n  if (l.y === y && l.x === x) {\n    return [...layout];\n  }\n\n  const oldX = l.x;\n  const oldY = l.y;\n\n  // Update position (mutates l directly - see JSDoc note)\n  if (typeof x === \"number\") (l as Mutable<LayoutItem>).x = x;\n  if (typeof y === \"number\") (l as Mutable<LayoutItem>).y = y;\n  (l as Mutable<LayoutItem>).moved = true;\n\n  // Sort for proper collision detection order\n  let sorted = sortLayoutItems(layout, compactType);\n  const movingUp =\n    compactType === \"vertical\" && typeof y === \"number\"\n      ? oldY >= y\n      : compactType === \"horizontal\" && typeof x === \"number\"\n        ? oldX >= x\n        : false;\n\n  if (movingUp) {\n    sorted = sorted.reverse();\n  }\n\n  const collisions = getAllCollisions(sorted, l);\n  const hasCollisions = collisions.length > 0;\n\n  // Handle overlap mode - just clone and return\n  if (hasCollisions && allowOverlap) {\n    return cloneLayout(layout);\n  }\n\n  // Handle prevent collision mode - revert position\n  // Return same reference to signal no change occurred\n  if (hasCollisions && preventCollision) {\n    (l as Mutable<LayoutItem>).x = oldX;\n    (l as Mutable<LayoutItem>).y = oldY;\n    (l as Mutable<LayoutItem>).moved = false;\n    return layout as LayoutItem[];\n  }\n\n  // Resolve collisions by moving other items\n  let resultLayout: LayoutItem[] = [...layout];\n  for (let i = 0; i < collisions.length; i++) {\n    const collision = collisions[i];\n    if (collision === undefined) continue;\n\n    // Skip already-moved items to prevent infinite loops\n    if (collision.moved) continue;\n\n    // Static items can't be moved - move the dragged item instead\n    if (collision.static) {\n      resultLayout = moveElementAwayFromCollision(\n        resultLayout,\n        collision,\n        l,\n        isUserAction,\n        compactType,\n        cols\n      );\n    } else {\n      resultLayout = moveElementAwayFromCollision(\n        resultLayout,\n        l,\n        collision,\n        isUserAction,\n        compactType,\n        cols\n      );\n    }\n  }\n\n  return resultLayout;\n}\n\n/**\n * Move an item away from a collision.\n *\n * Attempts to move the item up/left first if there's room,\n * otherwise moves it down/right.\n *\n * @param layout - Full layout\n * @param collidesWith - The item being collided with\n * @param itemToMove - The item to move away\n * @param isUserAction - True if this is a direct user action\n * @param compactType - Compaction type\n * @param cols - Number of columns\n * @returns Updated layout\n */\nexport function moveElementAwayFromCollision(\n  layout: Layout,\n  collidesWith: LayoutItem,\n  itemToMove: LayoutItem,\n  isUserAction: boolean | undefined,\n  compactType: CompactType,\n  cols: number\n): LayoutItem[] {\n  const compactH = compactType === \"horizontal\";\n  const compactV = compactType === \"vertical\";\n  const preventCollision = collidesWith.static;\n\n  // Try to move up/left first (only on primary collision from user action)\n  if (isUserAction) {\n    isUserAction = false; // Only try this once\n\n    // Create a fake item to test if there's room above/left\n    const fakeItem: LayoutItem = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    };\n\n    const firstCollision = getFirstCollision(layout, fakeItem);\n    const collisionNorth =\n      firstCollision !== undefined &&\n      firstCollision.y + firstCollision.h > collidesWith.y;\n    const collisionWest =\n      firstCollision !== undefined &&\n      collidesWith.x + collidesWith.w > firstCollision.x;\n\n    // No collision above/left - we can move there\n    if (!firstCollision) {\n      return moveElement(\n        layout,\n        itemToMove,\n        compactH ? fakeItem.x : undefined,\n        compactV ? fakeItem.y : undefined,\n        isUserAction,\n        preventCollision,\n        compactType,\n        cols\n      );\n    }\n\n    // Handle specific collision cases\n    if (collisionNorth && compactV) {\n      return moveElement(\n        layout,\n        itemToMove,\n        undefined,\n        itemToMove.y + 1,\n        isUserAction,\n        preventCollision,\n        compactType,\n        cols\n      );\n    }\n\n    if (collisionNorth && compactType === null) {\n      // Swap positions in free-form mode\n      (collidesWith as Mutable<LayoutItem>).y = itemToMove.y;\n      (itemToMove as Mutable<LayoutItem>).y = itemToMove.y + itemToMove.h;\n      return [...layout];\n    }\n\n    if (collisionWest && compactH) {\n      return moveElement(\n        layout,\n        collidesWith,\n        itemToMove.x,\n        undefined,\n        isUserAction,\n        preventCollision,\n        compactType,\n        cols\n      );\n    }\n  }\n\n  // Default: move down/right by 1\n  const newX = compactH ? itemToMove.x + 1 : undefined;\n  const newY = compactV ? itemToMove.y + 1 : undefined;\n\n  if (newX === undefined && newY === undefined) {\n    return [...layout];\n  }\n\n  return moveElement(\n    layout,\n    itemToMove,\n    newX,\n    newY,\n    isUserAction,\n    preventCollision,\n    compactType,\n    cols\n  );\n}\n\n// ============================================================================\n// Validation\n// ============================================================================\n\n/**\n * Validate that a layout has the required properties.\n *\n * @param layout - Layout to validate\n * @param contextName - Name for error messages\n * @throws Error if layout is invalid\n */\nexport function validateLayout(\n  layout: Layout,\n  contextName: string = \"Layout\"\n): void {\n  const requiredProps = [\"x\", \"y\", \"w\", \"h\"] as const;\n\n  if (!Array.isArray(layout)) {\n    throw new Error(`${contextName} must be an array!`);\n  }\n\n  for (let i = 0; i < layout.length; i++) {\n    const item = layout[i];\n    if (item === undefined) continue;\n\n    for (const key of requiredProps) {\n      const value = item[key];\n      if (typeof value !== \"number\" || Number.isNaN(value)) {\n        throw new Error(\n          `ReactGridLayout: ${contextName}[${i}].${key} must be a number! ` +\n            `Received: ${String(value)} (${typeof value})`\n        );\n      }\n    }\n\n    if (item.i !== undefined && typeof item.i !== \"string\") {\n      throw new Error(\n        `ReactGridLayout: ${contextName}[${i}].i must be a string! ` +\n          `Received: ${String(item.i)} (${typeof item.i})`\n      );\n    }\n  }\n}\n", "/**\n * Pluggable layout constraints for react-grid-layout v2\n *\n * Constraints control position and size limits during drag/resize operations.\n * They are composable, tree-shakeable, and can be applied at grid or item level.\n */\n\nimport type {\n  LayoutItem,\n  LayoutConstraint,\n  ConstraintContext,\n  ResizeHandleAxis\n} from \"./types.js\";\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\n/**\n * Clamp a value between min and max bounds.\n */\nfunction clamp(value: number, min: number, max: number): number {\n  return Math.max(min, Math.min(max, value));\n}\n\n// ============================================================================\n// Built-in Constraints\n// ============================================================================\n\n/**\n * Grid boundary constraint.\n *\n * Ensures items stay within the grid bounds (0 to cols-w for x, 0 to maxRows-h for y).\n * This is the default position constraint.\n */\nexport const gridBounds: LayoutConstraint = {\n  name: \"gridBounds\",\n\n  constrainPosition(\n    item: LayoutItem,\n    x: number,\n    y: number,\n    { cols, maxRows }: ConstraintContext\n  ): { x: number; y: number } {\n    return {\n      x: clamp(x, 0, Math.max(0, cols - item.w)),\n      y: clamp(y, 0, Math.max(0, maxRows - item.h))\n    };\n  },\n\n  constrainSize(\n    item: LayoutItem,\n    w: number,\n    h: number,\n    handle: ResizeHandleAxis,\n    { cols, maxRows }: ConstraintContext\n  ): { w: number; h: number } {\n    // For west-side resizes (w, nw, sw), max width is limited by the right edge position\n    // because the item expands leftward (x decreases as w increases)\n    const maxW =\n      handle === \"w\" || handle === \"nw\" || handle === \"sw\"\n        ? item.x + item.w // right edge = x + w, can expand left to x=0\n        : cols - item.x; // can expand right to cols\n\n    // For north-side resizes (n, nw, ne), max height is limited by the bottom edge position\n    // because the item expands upward (y decreases as h increases)\n    const maxH =\n      handle === \"n\" || handle === \"nw\" || handle === \"ne\"\n        ? item.y + item.h // bottom edge = y + h, can expand up to y=0\n        : maxRows - item.y; // can expand down to maxRows\n\n    return {\n      w: clamp(w, 1, Math.max(1, maxW)),\n      h: clamp(h, 1, Math.max(1, maxH))\n    };\n  }\n};\n\n/**\n * Min/max size constraint.\n *\n * Enforces per-item minW/maxW/minH/maxH properties.\n * This is applied by default after gridBounds.\n */\nexport const minMaxSize: LayoutConstraint = {\n  name: \"minMaxSize\",\n\n  constrainSize(\n    item: LayoutItem,\n    w: number,\n    h: number\n  ): { w: number; h: number } {\n    return {\n      w: clamp(w, item.minW ?? 1, item.maxW ?? Infinity),\n      h: clamp(h, item.minH ?? 1, item.maxH ?? Infinity)\n    };\n  }\n};\n\n/**\n * Container bounds constraint.\n *\n * Constrains items to stay within the visible container.\n * Use this as a replacement for the legacy `isBounded` prop.\n *\n * Unlike gridBounds which uses maxRows (which may be Infinity),\n * this constraint calculates visible rows from the actual container height.\n * Falls back to maxRows if containerHeight is 0 (auto-height grids).\n */\nexport const containerBounds: LayoutConstraint = {\n  name: \"containerBounds\",\n\n  constrainPosition(\n    item: LayoutItem,\n    x: number,\n    y: number,\n    { cols, maxRows, containerHeight, rowHeight, margin }: ConstraintContext\n  ): { x: number; y: number } {\n    // Calculate visible rows from container height\n    // Formula: containerHeight = rows * rowHeight + (rows - 1) * margin\n    // Solving: rows = (containerHeight + margin) / (rowHeight + margin)\n    const visibleRows =\n      containerHeight > 0\n        ? Math.floor((containerHeight + margin[1]) / (rowHeight + margin[1]))\n        : maxRows;\n\n    return {\n      x: clamp(x, 0, Math.max(0, cols - item.w)),\n      y: clamp(y, 0, Math.max(0, visibleRows - item.h))\n    };\n  }\n};\n\n/**\n * Bounded X constraint.\n *\n * Only constrains horizontal position (x-axis).\n * Items can move freely in the vertical direction.\n */\nexport const boundedX: LayoutConstraint = {\n  name: \"boundedX\",\n\n  constrainPosition(\n    item: LayoutItem,\n    x: number,\n    y: number,\n    { cols }: ConstraintContext\n  ): { x: number; y: number } {\n    return {\n      x: clamp(x, 0, Math.max(0, cols - item.w)),\n      y\n    };\n  }\n};\n\n/**\n * Bounded Y constraint.\n *\n * Only constrains vertical position (y-axis).\n * Items can move freely in the horizontal direction.\n */\nexport const boundedY: LayoutConstraint = {\n  name: \"boundedY\",\n\n  constrainPosition(\n    item: LayoutItem,\n    x: number,\n    y: number,\n    { maxRows }: ConstraintContext\n  ): { x: number; y: number } {\n    return {\n      x,\n      y: clamp(y, 0, Math.max(0, maxRows - item.h))\n    };\n  }\n};\n\n// ============================================================================\n// Constraint Factories\n// ============================================================================\n\n/**\n * Create an aspect ratio constraint.\n *\n * Maintains a fixed width-to-height ratio **in pixels** during resize operations.\n * Accounts for the different pixel sizes of grid columns vs rows.\n *\n * @param ratio - Width-to-height ratio (e.g., 16/9 for widescreen, 1 for square)\n * @returns A constraint that enforces the aspect ratio\n *\n * @example\n * ```typescript\n * // 16:9 aspect ratio (actual pixel proportions)\n * const layout = [\n *   { i: 'video', x: 0, y: 0, w: 4, h: 2, constraints: [aspectRatio(16/9)] }\n * ];\n *\n * // Square items (in pixels, not grid units)\n * <GridLayout constraints={[gridBounds, minMaxSize, aspectRatio(1)]} />\n * ```\n */\nexport function aspectRatio(ratio: number): LayoutConstraint {\n  return {\n    name: `aspectRatio(${ratio})`,\n\n    constrainSize(\n      _item: LayoutItem,\n      w: number,\n      _h: number,\n      _handle: ResizeHandleAxis,\n      context: ConstraintContext\n    ): { w: number; h: number } {\n      const { cols, containerWidth, rowHeight, margin } = context;\n      // Calculate column width in pixels\n      // colWidth = (containerWidth - margin[0] * (cols - 1)) / cols\n      // Note: simplified formula assumes no container padding\n      const colWidth = (containerWidth - margin[0] * (cols - 1)) / cols;\n\n      // Calculate pixel width of the item\n      // pixelWidth = colWidth * w + margin[0] * (w - 1)\n      const pixelWidth = colWidth * w + margin[0] * Math.max(0, w - 1);\n\n      // Calculate required pixel height for aspect ratio\n      const pixelHeight = pixelWidth / ratio;\n\n      // Convert pixel height back to grid units\n      // pixelHeight = rowHeight * h + margin[1] * (h - 1)\n      // Solving for h:\n      // pixelHeight = h * (rowHeight + margin[1]) - margin[1]\n      // h = (pixelHeight + margin[1]) / (rowHeight + margin[1])\n      const h = Math.max(\n        1,\n        Math.round((pixelHeight + margin[1]) / (rowHeight + margin[1]))\n      );\n\n      return { w, h };\n    }\n  };\n}\n\n/**\n * Create a snap-to-grid constraint.\n *\n * Snaps positions to multiples of the specified step values.\n * Useful for aligning items to a coarser grid.\n *\n * @param stepX - Horizontal snap step in grid units\n * @param stepY - Vertical snap step in grid units (defaults to stepX)\n * @returns A constraint that snaps positions to the grid\n *\n * @example\n * ```typescript\n * // Snap to every 2 grid units\n * <GridLayout constraints={[snapToGrid(2), gridBounds]} />\n *\n * // Different horizontal and vertical snap\n * <GridLayout constraints={[snapToGrid(2, 3), gridBounds]} />\n * ```\n */\nexport function snapToGrid(\n  stepX: number,\n  stepY: number = stepX\n): LayoutConstraint {\n  // Validate step values to prevent division by zero or invalid snapping\n  if (stepX <= 0 || stepY <= 0) {\n    throw new Error(\n      `snapToGrid: step values must be positive (got stepX=${stepX}, stepY=${stepY})`\n    );\n  }\n\n  return {\n    name: `snapToGrid(${stepX}, ${stepY})`,\n\n    constrainPosition(\n      _item: LayoutItem,\n      x: number,\n      y: number\n    ): { x: number; y: number } {\n      return {\n        x: Math.round(x / stepX) * stepX,\n        y: Math.round(y / stepY) * stepY\n      };\n    }\n  };\n}\n\n/**\n * Create a minimum size constraint.\n *\n * Sets minimum width and height for all items using this constraint.\n * Useful for grid-wide minimums without setting minW/minH on each item.\n *\n * @param minW - Minimum width in grid units\n * @param minH - Minimum height in grid units\n * @returns A constraint that enforces minimum size\n */\nexport function minSize(minW: number, minH: number): LayoutConstraint {\n  return {\n    name: `minSize(${minW}, ${minH})`,\n\n    constrainSize(\n      _item: LayoutItem,\n      w: number,\n      h: number\n    ): { w: number; h: number } {\n      return {\n        w: Math.max(minW, w),\n        h: Math.max(minH, h)\n      };\n    }\n  };\n}\n\n/**\n * Create a maximum size constraint.\n *\n * Sets maximum width and height for all items using this constraint.\n * Useful for grid-wide maximums without setting maxW/maxH on each item.\n *\n * @param maxW - Maximum width in grid units\n * @param maxH - Maximum height in grid units\n * @returns A constraint that enforces maximum size\n */\nexport function maxSize(maxW: number, maxH: number): LayoutConstraint {\n  return {\n    name: `maxSize(${maxW}, ${maxH})`,\n\n    constrainSize(\n      _item: LayoutItem,\n      w: number,\n      h: number\n    ): { w: number; h: number } {\n      return {\n        w: Math.min(maxW, w),\n        h: Math.min(maxH, h)\n      };\n    }\n  };\n}\n\n// ============================================================================\n// Default Constraints\n// ============================================================================\n\n/**\n * Default constraints applied when none are specified.\n *\n * Includes:\n * - gridBounds: Keep items within the grid\n * - minMaxSize: Respect per-item min/max constraints\n */\nexport const defaultConstraints: LayoutConstraint[] = [gridBounds, minMaxSize];\n\n// ============================================================================\n// Constraint Application Functions\n// ============================================================================\n\n/**\n * Apply position constraints to a proposed position.\n *\n * Constraints are applied in array order, allowing composition.\n * Grid-level constraints are applied first, then per-item constraints.\n *\n * @param constraints - Array of constraints to apply\n * @param item - The layout item being positioned\n * @param x - Proposed x position\n * @param y - Proposed y position\n * @param context - Grid context (cols, maxRows, etc.)\n * @returns Constrained position\n */\nexport function applyPositionConstraints(\n  constraints: LayoutConstraint[],\n  item: LayoutItem,\n  x: number,\n  y: number,\n  context: ConstraintContext\n): { x: number; y: number } {\n  let result = { x, y };\n\n  // Apply grid-level constraints\n  for (const constraint of constraints) {\n    if (constraint.constrainPosition) {\n      result = constraint.constrainPosition(item, result.x, result.y, context);\n    }\n  }\n\n  // Apply per-item constraints\n  if (item.constraints) {\n    for (const constraint of item.constraints) {\n      if (constraint.constrainPosition) {\n        result = constraint.constrainPosition(\n          item,\n          result.x,\n          result.y,\n          context\n        );\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Apply size constraints to a proposed size.\n *\n * Constraints are applied in array order, allowing composition.\n * Grid-level constraints are applied first, then per-item constraints.\n *\n * @param constraints - Array of constraints to apply\n * @param item - The layout item being resized\n * @param w - Proposed width\n * @param h - Proposed height\n * @param handle - Which resize handle is being used\n * @param context - Grid context (cols, maxRows, etc.)\n * @returns Constrained size\n */\nexport function applySizeConstraints(\n  constraints: LayoutConstraint[],\n  item: LayoutItem,\n  w: number,\n  h: number,\n  handle: ResizeHandleAxis,\n  context: ConstraintContext\n): { w: number; h: number } {\n  let result = { w, h };\n\n  // Apply grid-level constraints\n  for (const constraint of constraints) {\n    if (constraint.constrainSize) {\n      result = constraint.constrainSize(\n        item,\n        result.w,\n        result.h,\n        handle,\n        context\n      );\n    }\n  }\n\n  // Apply per-item constraints\n  if (item.constraints) {\n    for (const constraint of item.constraints) {\n      if (constraint.constrainSize) {\n        result = constraint.constrainSize(\n          item,\n          result.w,\n          result.h,\n          handle,\n          context\n        );\n      }\n    }\n  }\n\n  return result;\n}\n", "/**\n * Position calculation utilities.\n *\n * These functions convert between grid units and pixel positions,\n * and generate CSS styles for grid items.\n */\n\nimport type {\n  Position,\n  PartialPosition,\n  ResizeHandleAxis,\n  PositionStrategy\n} from \"./types.js\";\n\n// ============================================================================\n// CSS Style Generation\n// ============================================================================\n\n/**\n * Generate CSS transform-based positioning styles.\n *\n * Using transforms is more performant than top/left positioning\n * because it doesn't trigger layout recalculations.\n *\n * @param position - Position in pixels\n * @returns CSS style object\n */\nexport function setTransform({\n  top,\n  left,\n  width,\n  height\n}: Position): Record<string, string> {\n  const translate = `translate(${left}px,${top}px)`;\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: \"absolute\"\n  };\n}\n\n/**\n * Generate CSS top/left positioning styles.\n *\n * Use this when transforms are not suitable (e.g., for printing\n * or when transform causes issues with child elements).\n *\n * @param position - Position in pixels\n * @returns CSS style object\n */\nexport function setTopLeft({\n  top,\n  left,\n  width,\n  height\n}: Position): Record<string, string> {\n  return {\n    top: `${top}px`,\n    left: `${left}px`,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: \"absolute\"\n  };\n}\n\n/**\n * Convert a number to a percentage string.\n *\n * @param num - Number to convert (0-1 range typically)\n * @returns Percentage string (e.g., \"50%\")\n */\nexport function perc(num: number): string {\n  return num * 100 + \"%\";\n}\n\n// ============================================================================\n// Resize Direction Handling\n// ============================================================================\n\n/**\n * Constrain width to not overflow container.\n */\nfunction constrainWidth(\n  left: number,\n  currentWidth: number,\n  newWidth: number,\n  containerWidth: number\n): number {\n  return left + newWidth > containerWidth ? currentWidth : newWidth;\n}\n\n/**\n * Constrain height to not go above container (negative top).\n */\nfunction constrainHeight(\n  top: number,\n  currentHeight: number,\n  newHeight: number\n): number {\n  return top < 0 ? currentHeight : newHeight;\n}\n\n/**\n * Constrain left to not be negative.\n */\nfunction constrainLeft(left: number): number {\n  return Math.max(0, left);\n}\n\n/**\n * Constrain top to not be negative.\n */\nfunction constrainTop(top: number): number {\n  return Math.max(0, top);\n}\n\n// Direction handlers\ntype ResizeHandler = (\n  currentSize: Position,\n  newSize: Position,\n  containerWidth: number\n) => Position;\n\nconst resizeNorth: ResizeHandler = (currentSize, newSize, _containerWidth) => {\n  const { left, height, width } = newSize;\n  const top = currentSize.top - (height - currentSize.height);\n\n  return {\n    left,\n    width,\n    height: constrainHeight(top, currentSize.height, height),\n    top: constrainTop(top)\n  };\n};\n\nconst resizeEast: ResizeHandler = (currentSize, newSize, containerWidth) => {\n  const { top, left, height, width } = newSize;\n  return {\n    top,\n    height,\n    width: constrainWidth(\n      currentSize.left,\n      currentSize.width,\n      width,\n      containerWidth\n    ),\n    left: constrainLeft(left)\n  };\n};\n\nconst resizeWest: ResizeHandler = (currentSize, newSize, _containerWidth) => {\n  const { top, height, width } = newSize;\n  const left = currentSize.left + currentSize.width - width;\n\n  if (left < 0) {\n    return {\n      height,\n      width: currentSize.left + currentSize.width,\n      top: constrainTop(top),\n      left: 0\n    };\n  }\n\n  return {\n    height,\n    width,\n    top: constrainTop(top),\n    left\n  };\n};\n\nconst resizeSouth: ResizeHandler = (currentSize, newSize, _containerWidth) => {\n  const { top, left, height, width } = newSize;\n  return {\n    width,\n    left,\n    height: constrainHeight(top, currentSize.height, height),\n    top: constrainTop(top)\n  };\n};\n\n// Compound directions (corners)\nconst resizeNorthEast: ResizeHandler = (currentSize, newSize, containerWidth) =>\n  resizeNorth(\n    currentSize,\n    resizeEast(currentSize, newSize, containerWidth),\n    containerWidth\n  );\n\nconst resizeNorthWest: ResizeHandler = (currentSize, newSize, containerWidth) =>\n  resizeNorth(\n    currentSize,\n    resizeWest(currentSize, newSize, containerWidth),\n    containerWidth\n  );\n\nconst resizeSouthEast: ResizeHandler = (currentSize, newSize, containerWidth) =>\n  resizeSouth(\n    currentSize,\n    resizeEast(currentSize, newSize, containerWidth),\n    containerWidth\n  );\n\nconst resizeSouthWest: ResizeHandler = (currentSize, newSize, containerWidth) =>\n  resizeSouth(\n    currentSize,\n    resizeWest(currentSize, newSize, containerWidth),\n    containerWidth\n  );\n\nconst resizeHandlerMap: Record<ResizeHandleAxis, ResizeHandler> = {\n  n: resizeNorth,\n  ne: resizeNorthEast,\n  e: resizeEast,\n  se: resizeSouthEast,\n  s: resizeSouth,\n  sw: resizeSouthWest,\n  w: resizeWest,\n  nw: resizeNorthWest\n};\n\n/**\n * Resize an item in a specific direction, clamping to container bounds.\n *\n * This handles the complex logic of resizing from different edges/corners,\n * ensuring the item doesn't overflow the container.\n *\n * @param direction - Which edge/corner is being dragged\n * @param currentSize - Current position and size\n * @param newSize - Requested new position and size\n * @param containerWidth - Width of the container\n * @returns Constrained position and size\n */\nexport function resizeItemInDirection(\n  direction: ResizeHandleAxis,\n  currentSize: Position,\n  newSize: Position,\n  containerWidth: number\n): Position {\n  const handler = resizeHandlerMap[direction];\n\n  // Fallback if direction not found (shouldn't happen with proper types)\n  if (!handler) {\n    return newSize;\n  }\n\n  return handler(currentSize, { ...currentSize, ...newSize }, containerWidth);\n}\n\n// ============================================================================\n// Position Strategies (v2 Composable Interface)\n// ============================================================================\n\n/**\n * CSS transform-based positioning strategy.\n *\n * Uses CSS transforms for positioning, which is more performant\n * as it doesn't trigger layout recalculations.\n *\n * This is the default strategy.\n */\nexport const transformStrategy: PositionStrategy = {\n  type: \"transform\",\n  scale: 1,\n\n  calcStyle(pos: Position): React.CSSProperties {\n    return setTransform(pos) as React.CSSProperties;\n  }\n};\n\n/**\n * Absolute (top/left) positioning strategy.\n *\n * Uses CSS top/left for positioning. Use this when CSS transforms\n * cause issues (e.g., printing, certain child element positioning).\n */\nexport const absoluteStrategy: PositionStrategy = {\n  type: \"absolute\",\n  scale: 1,\n\n  calcStyle(pos: Position): React.CSSProperties {\n    return setTopLeft(pos) as React.CSSProperties;\n  }\n};\n\n/**\n * Create a scaled transform strategy.\n *\n * Use this when the grid container is inside a scaled element\n * (e.g., `transform: scale(0.5)`). The scale factor adjusts\n * drag/resize calculations to account for the parent transform.\n *\n * @param scale - Scale factor (e.g., 0.5 for half size)\n * @returns Position strategy with scaled calculations\n *\n * @example\n * ```tsx\n * <div style={{ transform: 'scale(0.5)' }}>\n *   <GridLayout positionStrategy={createScaledStrategy(0.5)} />\n * </div>\n * ```\n */\nexport function createScaledStrategy(scale: number): PositionStrategy {\n  return {\n    type: \"transform\",\n    scale,\n\n    calcStyle(pos: Position): React.CSSProperties {\n      return setTransform(pos) as React.CSSProperties;\n    },\n\n    calcDragPosition(\n      clientX: number,\n      clientY: number,\n      offsetX: number,\n      offsetY: number\n    ): PartialPosition {\n      return {\n        left: (clientX - offsetX) / scale,\n        top: (clientY - offsetY) / scale\n      };\n    }\n  };\n}\n\n/** Default position strategy (transform-based) */\nexport const defaultPositionStrategy = transformStrategy;\n", "/**\n * Core types for react-grid-layout v2\n *\n * These types are framework-agnostic and define the data structures\n * used by the layout algorithms.\n */\n\n// ============================================================================\n// Resize Handle Types\n// ============================================================================\n\n/**\n * Axis identifiers for resize handles.\n * - Cardinal: 'n', 's', 'e', 'w' (north, south, east, west)\n * - Diagonal: 'ne', 'nw', 'se', 'sw'\n */\nexport type ResizeHandleAxis =\n  | \"s\"\n  | \"w\"\n  | \"e\"\n  | \"n\"\n  | \"sw\"\n  | \"nw\"\n  | \"se\"\n  | \"ne\";\n\n// ============================================================================\n// Layout Item Types\n// ============================================================================\n\n/**\n * A single item in the grid layout.\n *\n * Position (x, y) is in grid units, not pixels.\n * Size (w, h) is in grid units.\n */\nexport interface LayoutItem {\n  /** Unique identifier for this item */\n  i: string;\n\n  /** X position in grid units (0-indexed from left) */\n  x: number;\n\n  /** Y position in grid units (0-indexed from top) */\n  y: number;\n\n  /** Width in grid units */\n  w: number;\n\n  /** Height in grid units */\n  h: number;\n\n  /** Minimum width in grid units */\n  minW?: number;\n\n  /** Minimum height in grid units */\n  minH?: number;\n\n  /** Maximum width in grid units */\n  maxW?: number;\n\n  /** Maximum height in grid units */\n  maxH?: number;\n\n  /**\n   * If true, item cannot be dragged or resized, and other items\n   * will move around it during compaction.\n   */\n  static?: boolean;\n\n  /**\n   * If false, item cannot be dragged (but may still be resizable).\n   * Overrides grid-level isDraggable for this item.\n   */\n  isDraggable?: boolean;\n\n  /**\n   * If false, item cannot be resized (but may still be draggable).\n   * Overrides grid-level isResizable for this item.\n   */\n  isResizable?: boolean;\n\n  /**\n   * Which resize handles to show for this item.\n   * Overrides grid-level resizeHandles for this item.\n   */\n  resizeHandles?: ResizeHandleAxis[];\n\n  /**\n   * If true, item is constrained to the grid container bounds.\n   * Overrides grid-level isBounded for this item.\n   */\n  isBounded?: boolean;\n\n  /**\n   * Internal flag set during drag/resize operations to indicate\n   * the item has moved from its original position.\n   * @internal\n   */\n  moved?: boolean;\n\n  /**\n   * Per-item layout constraints.\n   * Applied in addition to grid-level constraints.\n   */\n  constraints?: LayoutConstraint[];\n}\n\n/**\n * A layout is a readonly array of layout items.\n * Layouts should be treated as immutable.\n */\nexport type Layout = readonly LayoutItem[];\n\n// ============================================================================\n// Position & Size Types\n// ============================================================================\n\n/**\n * Pixel position and size of an element.\n */\nexport interface Position {\n  left: number;\n  top: number;\n  width: number;\n  height: number;\n}\n\n/**\n * Partial position (just coordinates, no size).\n */\nexport interface PartialPosition {\n  left: number;\n  top: number;\n}\n\n/**\n * Size in pixels.\n */\nexport interface Size {\n  width: number;\n  height: number;\n}\n\n/**\n * Position when dropping an external element onto the grid.\n */\nexport interface DroppingPosition {\n  left: number;\n  top: number;\n  e: Event;\n}\n\n// ============================================================================\n// Event Types\n// ============================================================================\n\n/**\n * Data provided by react-draggable during drag operations.\n */\nexport interface ReactDraggableCallbackData {\n  node: HTMLElement;\n  x?: number;\n  y?: number;\n  deltaX: number;\n  deltaY: number;\n  lastX?: number;\n  lastY?: number;\n}\n\n/**\n * Grid-level drag event data.\n */\nexport interface GridDragEvent {\n  e: Event;\n  node: HTMLElement;\n  newPosition: PartialPosition;\n}\n\n/**\n * Grid-level resize event data.\n */\nexport interface GridResizeEvent {\n  e: Event;\n  node: HTMLElement;\n  size: Size;\n  handle: ResizeHandleAxis;\n}\n\n/**\n * Drag-over event with layer coordinates.\n */\nexport interface DragOverEvent extends MouseEvent {\n  nativeEvent: Event & {\n    layerX: number;\n    layerY: number;\n  };\n}\n\n// ============================================================================\n// Compaction Types\n// ============================================================================\n\n/**\n * Type of compaction to apply to the layout.\n * - 'vertical': Items compact upward (default)\n * - 'horizontal': Items compact leftward\n * - 'wrap': Items arranged in wrapped-paragraph style (like words in text)\n * - null: No compaction (free-form positioning)\n */\nexport type CompactType = \"horizontal\" | \"vertical\" | \"wrap\" | null;\n\n// ============================================================================\n// Callback Types\n// ============================================================================\n\n/**\n * Standard callback signature for layout change events.\n *\n * @param layout - The current layout after the change\n * @param oldItem - The item before the change (null if not applicable)\n * @param newItem - The item after the change (null if not applicable)\n * @param placeholder - The placeholder item during drag/resize (null at start)\n * @param event - The DOM event that triggered the change\n * @param element - The DOM element being manipulated (null if not applicable)\n */\nexport type EventCallback = (\n  layout: Layout,\n  oldItem: LayoutItem | null,\n  newItem: LayoutItem | null,\n  placeholder: LayoutItem | null,\n  event: Event,\n  element: HTMLElement | null\n) => void;\n\n/**\n * Callback when layout changes for any reason.\n */\nexport type OnLayoutChangeCallback = (layout: Layout) => void;\n\n// ============================================================================\n// Composable Interfaces (v2 API)\n// ============================================================================\n\n/**\n * Interface for layout compaction strategies.\n *\n * Implement this interface to create custom compaction algorithms.\n *\n * @example\n * ```typescript\n * const myCompactor: Compactor = {\n *   type: 'vertical',\n *   allowOverlap: false,\n *   compact(layout, cols) {\n *     // Custom compaction logic\n *     return compactedLayout;\n *   }\n * };\n * ```\n */\nexport interface Compactor {\n  /** Compaction type identifier */\n  readonly type: CompactType;\n\n  /**\n   * Whether items can overlap (stack on top of each other).\n   *\n   * When true:\n   * - Items can be placed on top of other items\n   * - Dragging into another item does NOT push it away\n   * - Compaction is skipped after drag/resize\n   */\n  readonly allowOverlap: boolean;\n\n  /**\n   * Whether to block movement that would cause collision.\n   *\n   * When true (and allowOverlap is false):\n   * - Dragging into another item is blocked (item snaps back)\n   * - Other items are NOT pushed away\n   * - Only affects drag/resize, not compaction\n   *\n   * Has no effect when allowOverlap is true.\n   */\n  readonly preventCollision?: boolean;\n\n  /**\n   * Compact the layout.\n   *\n   * @param layout - The layout to compact\n   * @param cols - Number of columns in the grid\n   * @returns The compacted layout\n   */\n  compact(layout: Layout, cols: number): Layout;\n}\n\n/**\n * Interface for CSS positioning strategies.\n *\n * Implement this interface to customize how items are positioned in the DOM.\n * Built-in strategies: transformStrategy, absoluteStrategy.\n *\n * @example\n * ```typescript\n * // Use transform-based positioning (default, better performance)\n * <GridLayout positionStrategy={transformStrategy} />\n *\n * // Use top/left positioning (for environments where transforms cause issues)\n * <GridLayout positionStrategy={absoluteStrategy} />\n *\n * // Use scaled transforms (for scaled containers)\n * <GridLayout positionStrategy={createScaledStrategy(0.5)} />\n * ```\n */\nexport interface PositionStrategy {\n  /** Strategy type identifier */\n  readonly type: \"transform\" | \"absolute\";\n\n  /** Scale factor for drag/resize calculations */\n  readonly scale: number;\n\n  /**\n   * Convert pixel position to CSS style object.\n   *\n   * @param pos - Position in pixels\n   * @returns CSS properties for positioning the element\n   */\n  calcStyle(pos: Position): React.CSSProperties;\n\n  /**\n   * Calculate position during drag operations, accounting for transforms and scale.\n   *\n   * This method is optional. When not provided, react-draggable uses its built-in\n   * parent-relative coordinate calculation. Only override this when you need custom\n   * coordinate handling, such as for scaled containers.\n   *\n   * @param clientX - Mouse client X position\n   * @param clientY - Mouse client Y position\n   * @param offsetX - Offset from element origin X\n   * @param offsetY - Offset from element origin Y\n   * @returns Adjusted left/top position\n   */\n  calcDragPosition?(\n    clientX: number,\n    clientY: number,\n    offsetX: number,\n    offsetY: number\n  ): PartialPosition;\n}\n\n// ============================================================================\n// Layout Constraint Types\n// ============================================================================\n\n/**\n * Context provided to constraint functions during drag/resize operations.\n */\nexport interface ConstraintContext {\n  /** Number of columns in the grid */\n  cols: number;\n\n  /** Maximum number of rows (Infinity if unbounded) */\n  maxRows: number;\n\n  /** Container width in pixels */\n  containerWidth: number;\n\n  /** Container height in pixels (may be 0 if auto-height) */\n  containerHeight: number;\n\n  /** Row height in pixels */\n  rowHeight: number;\n\n  /** Margin between items [x, y] in pixels */\n  margin: readonly [number, number];\n\n  /** Current layout state */\n  layout: Layout;\n}\n\n/**\n * Interface for layout constraints.\n *\n * Implement this interface to create custom position/size constraints.\n * Built-in constraints: gridBounds, minMaxSize, containerBounds, boundedX, boundedY.\n *\n * @example\n * ```typescript\n * // Grid-level constraints\n * <GridLayout constraints={[gridBounds, minMaxSize, aspectRatio(16/9)]} />\n *\n * // Per-item constraints\n * const layout = [\n *   { i: 'video', x: 0, y: 0, w: 4, h: 2, constraints: [aspectRatio(16/9)] }\n * ];\n * ```\n */\nexport interface LayoutConstraint {\n  /** Constraint identifier for debugging */\n  readonly name: string;\n\n  /**\n   * Constrain position during drag operations.\n   * Called after grid unit conversion, before layout update.\n   *\n   * @param item - The item being dragged\n   * @param x - Proposed x position in grid units\n   * @param y - Proposed y position in grid units\n   * @param context - Grid context (cols, maxRows, etc.)\n   * @returns Constrained x, y position\n   */\n  constrainPosition?(\n    item: LayoutItem,\n    x: number,\n    y: number,\n    context: ConstraintContext\n  ): { x: number; y: number };\n\n  /**\n   * Constrain size during resize operations.\n   * Called after grid unit conversion, before layout update.\n   *\n   * @param item - The item being resized\n   * @param w - Proposed width in grid units\n   * @param h - Proposed height in grid units\n   * @param handle - Which resize handle is being used\n   * @param context - Grid context (cols, maxRows, etc.)\n   * @returns Constrained w, h size\n   */\n  constrainSize?(\n    item: LayoutItem,\n    w: number,\n    h: number,\n    handle: ResizeHandleAxis,\n    context: ConstraintContext\n  ): { w: number; h: number };\n}\n\n// ============================================================================\n// Grid Configuration Types (v2 Composable Interfaces)\n// ============================================================================\n\n/**\n * Grid measurement configuration.\n * Groups all grid metrics (columns, row height, margins).\n */\nexport interface GridConfig {\n  /** Number of columns in the grid (default: 12) */\n  cols: number;\n\n  /** Height of a single row in pixels (default: 150) */\n  rowHeight: number;\n\n  /** [horizontal, vertical] margin between items in pixels (default: [10, 10]) */\n  margin: readonly [number, number];\n\n  /** [horizontal, vertical] padding inside the container (default: null, uses margin) */\n  containerPadding: readonly [number, number] | null;\n\n  /** Maximum number of rows (default: Infinity) */\n  maxRows: number;\n}\n\n/** Default grid configuration */\nexport const defaultGridConfig: GridConfig = {\n  cols: 12,\n  rowHeight: 150,\n  margin: [10, 10],\n  containerPadding: null,\n  maxRows: Infinity\n};\n\n/**\n * Drag behavior configuration.\n * Groups all drag-related settings.\n */\nexport interface DragConfig {\n  /** Whether items can be dragged (default: true) */\n  enabled: boolean;\n\n  /** Whether items are bounded to the container (default: false) */\n  bounded: boolean;\n\n  /** CSS selector for drag handle (e.g., '.drag-handle') */\n  handle?: string;\n\n  /** CSS selector for elements that should not trigger drag */\n  cancel?: string;\n\n  /**\n   * Minimum pixels to move before drag starts.\n   * Helps distinguish click from drag (fixes #1341, #1401).\n   * @default 3\n   */\n  threshold: number;\n}\n\n/** Default drag configuration */\nexport const defaultDragConfig: DragConfig = {\n  enabled: true,\n  bounded: false,\n  threshold: 3\n};\n\n/**\n * Resize behavior configuration.\n * Groups all resize-related settings.\n */\nexport interface ResizeConfig {\n  /** Whether items can be resized (default: true) */\n  enabled: boolean;\n\n  /** Which resize handles to show (default: ['se']) */\n  handles: readonly ResizeHandleAxis[];\n\n  /**\n   * Custom resize handle component.\n   * Can be a React node or a function that receives the axis.\n   */\n  handleComponent?:\n    | React.ReactNode\n    | ((\n        axis: ResizeHandleAxis,\n        ref: React.Ref<HTMLElement>\n      ) => React.ReactNode);\n}\n\n/** Default resize configuration */\nexport const defaultResizeConfig: ResizeConfig = {\n  enabled: true,\n  handles: [\"se\"]\n};\n\n/**\n * Drop configuration (for dropping external elements).\n * Groups all drop-related settings.\n */\nexport interface DropConfig {\n  /** Whether external elements can be dropped on the grid (default: false) */\n  enabled: boolean;\n\n  /** Default size for dropped items (default: { w: 1, h: 1 }) */\n  defaultItem: { w: number; h: number };\n\n  /**\n   * Called when dragging over the grid.\n   * Return dimensions to override defaultItem, or false to reject the drop.\n   * Can also return dragOffsetX/dragOffsetY to specify cursor offset for centering.\n   */\n  onDragOver?: (\n    e: DragEvent\n  ) =>\n    | { w?: number; h?: number; dragOffsetX?: number; dragOffsetY?: number }\n    | false\n    | void;\n}\n\n/** Default drop configuration */\nexport const defaultDropConfig: DropConfig = {\n  enabled: false,\n  defaultItem: { w: 1, h: 1 }\n};\n\n// ============================================================================\n// Responsive Types\n// ============================================================================\n\n/**\n * Breakpoint name (e.g., 'lg', 'md', 'sm', 'xs', 'xxs').\n */\nexport type Breakpoint = string;\n\n/**\n * Map of breakpoint name to pixel width.\n * Generic type B allows custom breakpoint strings.\n */\nexport type Breakpoints<B extends Breakpoint = Breakpoint> = Record<B, number>;\n\n/**\n * Map of breakpoint name to number of columns.\n * Generic type B allows custom breakpoint strings.\n */\nexport type BreakpointCols<B extends Breakpoint = Breakpoint> = Record<\n  B,\n  number\n>;\n\n/**\n * Map of breakpoint name to layout.\n * Generic type B allows custom breakpoint strings.\n */\nexport type ResponsiveLayouts<B extends Breakpoint = Breakpoint> = Partial<\n  Record<B, Layout>\n>;\n\n/**\n * Callback when breakpoint changes.\n */\nexport type OnBreakpointChangeCallback<B extends Breakpoint = Breakpoint> = (\n  newBreakpoint: B,\n  cols: number\n) => void;\n\n// ============================================================================\n// Utility Types\n// ============================================================================\n\n/**\n * Makes all properties in T mutable (removes readonly).\n */\nexport type Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * Deep partial - all properties and nested properties are optional.\n */\nexport type DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\n};\n\n/**\n * Extract the element type from an array type.\n */\nexport type ArrayElement<T> = T extends readonly (infer U)[] ? U : never;\n", "/**\n * Compactor implementations.\n *\n * Compactors are pluggable strategies for removing gaps between grid items.\n * Use the Compactor interface to create custom compaction algorithms.\n */\n\nimport type {\n  Compactor,\n  CompactType,\n  Layout,\n  LayoutItem,\n  Mutable\n} from \"./types.js\";\nimport { getFirstCollision } from \"./collision.js\";\nimport { sortLayoutItemsByRowCol, sortLayoutItemsByColRow } from \"./sort.js\";\nimport { bottom, cloneLayoutItem, getStatics, cloneLayout } from \"./layout.js\";\nimport { collides } from \"./collision.js\";\n\n// ============================================================================\n// Helpers for Custom Compactors\n// ============================================================================\n\n/**\n * Resolve a compaction collision by moving items.\n *\n * Before moving an item to a position, checks if that movement would\n * cause collisions and recursively moves those items first.\n *\n * Useful for implementing custom compactors.\n *\n * @param layout - Full layout (must be sorted for optimization)\n * @param item - Item being moved (will be mutated)\n * @param moveToCoord - Target coordinate\n * @param axis - Which axis to move on ('x' or 'y')\n * @param hasStatics - Whether layout contains static items (disables early break optimization)\n */\nexport function resolveCompactionCollision(\n  layout: Layout,\n  item: LayoutItem,\n  moveToCoord: number,\n  axis: \"x\" | \"y\",\n  hasStatics?: boolean\n): void {\n  const sizeProp = axis === \"x\" ? \"w\" : \"h\";\n\n  // Temporarily increment position to check for collisions\n  (item as Mutable<LayoutItem>)[axis] += 1;\n\n  const itemIndex = layout.findIndex(l => l.i === item.i);\n\n  // Calculate hasStatics once if not provided (for backwards compat)\n  const layoutHasStatics = hasStatics ?? getStatics(layout).length > 0;\n\n  for (let i = itemIndex + 1; i < layout.length; i++) {\n    const otherItem = layout[i];\n    if (otherItem === undefined) continue;\n    if (otherItem.static) continue;\n    // Optimization: break early if past this element, but only if no statics\n    // are present. Static items can be scattered throughout the layout,\n    // so we can't assume sort order guarantees no more collisions.\n    if (!layoutHasStatics && otherItem.y > item.y + item.h) break;\n\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(\n        layout,\n        otherItem,\n        moveToCoord + item[sizeProp],\n        axis,\n        layoutHasStatics\n      );\n    }\n  }\n\n  (item as Mutable<LayoutItem>)[axis] = moveToCoord;\n}\n\n/**\n * Compact a single item vertically (move up).\n *\n * Moves the item as far up as possible without colliding.\n * Useful for implementing custom vertical compactors.\n *\n * @param compareWith - Items to check for collisions\n * @param l - Item to compact (will be mutated)\n * @param fullLayout - Full layout for collision resolution\n * @param maxY - Maximum Y to start from\n * @returns The compacted item\n */\nexport function compactItemVertical(\n  compareWith: Layout,\n  l: LayoutItem,\n  fullLayout: Layout,\n  maxY: number\n): LayoutItem {\n  // Correct negative positions first\n  (l as Mutable<LayoutItem>).x = Math.max(l.x, 0);\n  (l as Mutable<LayoutItem>).y = Math.max(l.y, 0);\n\n  // Limit Y to the current bottom\n  (l as Mutable<LayoutItem>).y = Math.min(maxY, l.y);\n\n  // Move up as far as possible\n  while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n    (l as Mutable<LayoutItem>).y--;\n  }\n\n  // Resolve collisions by moving down\n  let collision: LayoutItem | undefined;\n  while ((collision = getFirstCollision(compareWith, l)) !== undefined) {\n    resolveCompactionCollision(fullLayout, l, collision.y + collision.h, \"y\");\n  }\n\n  (l as Mutable<LayoutItem>).y = Math.max(l.y, 0);\n  return l;\n}\n\n/**\n * Compact a single item horizontally (move left).\n *\n * Moves the item as far left as possible without colliding.\n * Wraps to the next row if it overflows.\n * Useful for implementing custom horizontal compactors.\n *\n * @param compareWith - Items to check for collisions\n * @param l - Item to compact (will be mutated)\n * @param cols - Number of columns in the grid\n * @param fullLayout - Full layout for collision resolution\n * @returns The compacted item\n */\nexport function compactItemHorizontal(\n  compareWith: Layout,\n  l: LayoutItem,\n  cols: number,\n  fullLayout: Layout\n): LayoutItem {\n  // Correct negative positions first\n  (l as Mutable<LayoutItem>).x = Math.max(l.x, 0);\n  (l as Mutable<LayoutItem>).y = Math.max(l.y, 0);\n\n  // Move left as far as possible\n  while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n    (l as Mutable<LayoutItem>).x--;\n  }\n\n  // Resolve collisions\n  let collision: LayoutItem | undefined;\n  while ((collision = getFirstCollision(compareWith, l)) !== undefined) {\n    resolveCompactionCollision(fullLayout, l, collision.x + collision.w, \"x\");\n\n    // Horizontal overflow: wrap to next row\n    if (l.x + l.w > cols) {\n      (l as Mutable<LayoutItem>).x = cols - l.w;\n      (l as Mutable<LayoutItem>).y++;\n\n      while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n        (l as Mutable<LayoutItem>).x--;\n      }\n    }\n  }\n\n  (l as Mutable<LayoutItem>).x = Math.max(l.x, 0);\n  return l;\n}\n\n// ============================================================================\n// Vertical Compactor\n// ============================================================================\n\n/**\n * Vertical compactor - moves items up to fill gaps.\n *\n * Items are sorted by row then column, and each item is moved\n * as far up as possible without overlapping other items.\n *\n * This is the default compaction mode for react-grid-layout.\n */\nexport const verticalCompactor: Compactor = {\n  type: \"vertical\",\n  allowOverlap: false,\n\n  compact(layout: Layout, _cols: number): Layout {\n    const compareWith = getStatics(layout);\n    let maxY = bottom(compareWith);\n    const sorted = sortLayoutItemsByRowCol(layout);\n    const out: LayoutItem[] = new Array(layout.length);\n\n    for (let i = 0; i < sorted.length; i++) {\n      const sortedItem = sorted[i];\n      if (sortedItem === undefined) continue;\n\n      let l = cloneLayoutItem(sortedItem);\n\n      if (!l.static) {\n        l = compactItemVertical(compareWith, l, sorted, maxY);\n        maxY = Math.max(maxY, l.y + l.h);\n        compareWith.push(l);\n      }\n\n      const originalIndex = layout.indexOf(sortedItem);\n      out[originalIndex] = l;\n      l.moved = false;\n    }\n\n    return out;\n  }\n};\n\n// ============================================================================\n// Horizontal Compactor\n// ============================================================================\n\n/**\n * Horizontal compactor - moves items left to fill gaps.\n *\n * Items are sorted by column then row, and each item is moved\n * as far left as possible without overlapping other items.\n */\nexport const horizontalCompactor: Compactor = {\n  type: \"horizontal\",\n  allowOverlap: false,\n\n  compact(layout: Layout, cols: number): Layout {\n    const compareWith = getStatics(layout);\n    const sorted = sortLayoutItemsByColRow(layout);\n    const out: LayoutItem[] = new Array(layout.length);\n\n    for (let i = 0; i < sorted.length; i++) {\n      const sortedItem = sorted[i];\n      if (sortedItem === undefined) continue;\n\n      let l = cloneLayoutItem(sortedItem);\n\n      if (!l.static) {\n        l = compactItemHorizontal(compareWith, l, cols, sorted);\n        compareWith.push(l);\n      }\n\n      const originalIndex = layout.indexOf(sortedItem);\n      out[originalIndex] = l;\n      l.moved = false;\n    }\n\n    return out;\n  }\n};\n\n// ============================================================================\n// No Compaction\n// ============================================================================\n\n/**\n * No compaction - items stay where placed.\n *\n * Use this for free-form layouts where items can be placed anywhere.\n * Items will not automatically move to fill gaps.\n */\nexport const noCompactor: Compactor = {\n  type: null,\n  allowOverlap: false,\n\n  compact(layout: Layout, _cols: number): Layout {\n    // No compaction - just clone to maintain immutability\n    return cloneLayout(layout);\n  }\n};\n\n// ============================================================================\n// Overlap-Allowing Variants\n// ============================================================================\n\n/**\n * Vertical compactor that allows overlapping items.\n *\n * Items compact upward but are allowed to overlap each other.\n * Useful for layered layouts or when collision detection is handled externally.\n */\nexport const verticalOverlapCompactor: Compactor = {\n  ...verticalCompactor,\n  allowOverlap: true,\n\n  compact(layout: Layout, _cols: number): Layout {\n    // With overlap allowed, just clone without moving\n    return cloneLayout(layout);\n  }\n};\n\n/**\n * Horizontal compactor that allows overlapping items.\n */\nexport const horizontalOverlapCompactor: Compactor = {\n  ...horizontalCompactor,\n  allowOverlap: true,\n\n  compact(layout: Layout, _cols: number): Layout {\n    return cloneLayout(layout);\n  }\n};\n\n/**\n * No compaction, with overlapping allowed.\n *\n * Items stay where placed and can overlap each other.\n */\nexport const noOverlapCompactor: Compactor = {\n  ...noCompactor,\n  allowOverlap: true\n};\n\n// ============================================================================\n// Factory Function\n// ============================================================================\n\n/**\n * Get a compactor by type.\n *\n * This is a convenience function for backwards compatibility with the\n * string-based compactType API.\n *\n * Note: For 'wrap' mode, import `wrapCompactor` from 'react-grid-layout/extras'\n * and pass it directly to the `compactor` prop. This function returns\n * `noCompactor` for 'wrap' type since the wrap compactor is tree-shakeable.\n *\n * @param compactType - 'vertical', 'horizontal', 'wrap', or null\n * @param allowOverlap - Whether to allow overlapping items\n * @returns The appropriate Compactor\n */\nexport function getCompactor(\n  compactType: CompactType,\n  allowOverlap: boolean = false,\n  preventCollision: boolean = false\n): Compactor {\n  let baseCompactor: Compactor;\n\n  if (allowOverlap) {\n    if (compactType === \"vertical\") baseCompactor = verticalOverlapCompactor;\n    else if (compactType === \"horizontal\")\n      baseCompactor = horizontalOverlapCompactor;\n    else baseCompactor = noOverlapCompactor;\n  } else {\n    if (compactType === \"vertical\") baseCompactor = verticalCompactor;\n    else if (compactType === \"horizontal\") baseCompactor = horizontalCompactor;\n    // For 'wrap' and null, use noCompactor\n    // Users wanting wrap mode should import wrapCompactor from extras\n    else baseCompactor = noCompactor;\n  }\n\n  // Return with preventCollision if specified\n  if (preventCollision) {\n    return { ...baseCompactor, preventCollision };\n  }\n  return baseCompactor;\n}\n", "/**\n * Responsive layout utilities.\n *\n * Functions for handling responsive breakpoints and layout generation.\n */\n\nimport type {\n  Breakpoint,\n  Breakpoints,\n  Compactor,\n  CompactType,\n  Layout,\n  ResponsiveLayouts\n} from \"./types.js\";\nimport { cloneLayout, correctBounds } from \"./layout.js\";\nimport { getCompactor } from \"./compactors.js\";\n\n// ============================================================================\n// Breakpoint Utilities\n// ============================================================================\n\n/**\n * Sort breakpoints by width (ascending).\n *\n * Returns an array of breakpoint names sorted from smallest to largest.\n * E.g., ['xxs', 'xs', 'sm', 'md', 'lg']\n *\n * @param breakpoints - Map of breakpoint names to widths\n * @returns Sorted array of breakpoint names\n */\nexport function sortBreakpoints<B extends Breakpoint>(\n  breakpoints: Breakpoints<B>\n): B[] {\n  const keys = Object.keys(breakpoints) as B[];\n  return keys.sort((a, b) => breakpoints[a] - breakpoints[b]);\n}\n\n/**\n * Get the active breakpoint for a given width.\n *\n * Returns the highest breakpoint that is valid for the width (width > breakpoint).\n *\n * @param breakpoints - Map of breakpoint names to widths\n * @param width - Container width in pixels\n * @returns Active breakpoint name\n */\nexport function getBreakpointFromWidth<B extends Breakpoint>(\n  breakpoints: Breakpoints<B>,\n  width: number\n): B {\n  const sorted = sortBreakpoints(breakpoints);\n  let matching = sorted[0];\n\n  if (matching === undefined) {\n    throw new Error(\"No breakpoints defined\");\n  }\n\n  for (let i = 1; i < sorted.length; i++) {\n    const breakpointName = sorted[i];\n    if (breakpointName === undefined) continue;\n\n    const breakpointWidth = breakpoints[breakpointName];\n    if (width > breakpointWidth) {\n      matching = breakpointName;\n    }\n  }\n\n  return matching;\n}\n\n/**\n * Get the column count for a breakpoint.\n *\n * @param breakpoint - Breakpoint name\n * @param cols - Map of breakpoint names to column counts\n * @returns Number of columns for the breakpoint\n * @throws Error if breakpoint is not defined in cols\n */\nexport function getColsFromBreakpoint<B extends Breakpoint>(\n  breakpoint: B,\n  cols: Breakpoints<B>\n): number {\n  const colCount = cols[breakpoint];\n  if (colCount === undefined) {\n    throw new Error(\n      `ResponsiveReactGridLayout: \\`cols\\` entry for breakpoint ${String(breakpoint)} is missing!`\n    );\n  }\n  return colCount;\n}\n\n// ============================================================================\n// Layout Generation\n// ============================================================================\n\n/**\n * Find or generate a layout for a breakpoint.\n *\n * If a layout exists for the breakpoint, returns a clone.\n * Otherwise, generates a new layout from the nearest larger breakpoint.\n *\n * @param layouts - Existing layouts by breakpoint\n * @param breakpoints - Breakpoint definitions\n * @param breakpoint - Target breakpoint\n * @param lastBreakpoint - Previous breakpoint (for fallback)\n * @param cols - Column count for the target breakpoint\n * @param compactTypeOrCompactor - Compaction type string (legacy) or Compactor object\n * @returns Layout for the breakpoint\n */\nexport function findOrGenerateResponsiveLayout<B extends Breakpoint>(\n  layouts: ResponsiveLayouts<B>,\n  breakpoints: Breakpoints<B>,\n  breakpoint: B,\n  lastBreakpoint: B,\n  cols: number,\n  compactTypeOrCompactor: CompactType | Compactor\n): Layout {\n  // If it already exists, just return it\n  const existingLayout = layouts[breakpoint];\n  if (existingLayout) {\n    return cloneLayout(existingLayout);\n  }\n\n  // Find or generate the next layout\n  let layout = layouts[lastBreakpoint];\n\n  // Look for layouts at larger breakpoints\n  const breakpointsSorted = sortBreakpoints(breakpoints);\n  const breakpointsAbove = breakpointsSorted.slice(\n    breakpointsSorted.indexOf(breakpoint)\n  );\n\n  for (let i = 0; i < breakpointsAbove.length; i++) {\n    const b = breakpointsAbove[i];\n    if (b === undefined) continue;\n\n    const layoutForBreakpoint = layouts[b];\n    if (layoutForBreakpoint) {\n      layout = layoutForBreakpoint;\n      break;\n    }\n  }\n\n  // Clone layout so we don't modify existing items\n  const clonedLayout = cloneLayout(layout || []);\n\n  // Correct bounds and compact - use compactor.compact() (#2213)\n  // Handle both legacy compactType string and new Compactor object\n  const corrected = correctBounds(clonedLayout, { cols });\n  const compactor: Compactor =\n    typeof compactTypeOrCompactor === \"object\" &&\n    compactTypeOrCompactor !== null\n      ? compactTypeOrCompactor\n      : getCompactor(compactTypeOrCompactor);\n  return compactor.compact(corrected, cols);\n}\n\n// ============================================================================\n// Margin/Padding Helpers\n// ============================================================================\n\ntype IndentationValue<B extends Breakpoint> =\n  | readonly [number, number]\n  | Partial<Record<B, readonly [number, number]>>;\n\n/**\n * Get margin or padding value for a breakpoint.\n *\n * Supports both fixed values ([x, y]) and breakpoint-specific values\n * ({ lg: [x, y], md: [x, y], ... }).\n *\n * @param value - Fixed value or breakpoint-specific map\n * @param breakpoint - Current breakpoint\n * @returns Margin/padding tuple [x, y]\n */\nexport function getIndentationValue<B extends Breakpoint>(\n  value: IndentationValue<B>,\n  breakpoint: B\n): readonly [number, number] {\n  // If it's a tuple (array), return it directly\n  if (Array.isArray(value)) {\n    return value as readonly [number, number];\n  }\n\n  // It's a breakpoint map - find the value\n  const breakpointMap = value as Partial<Record<B, readonly [number, number]>>;\n  const breakpointValue = breakpointMap[breakpoint];\n  if (breakpointValue !== undefined) {\n    return breakpointValue;\n  }\n\n  // Fallback to first defined value\n  const keys = Object.keys(breakpointMap) as B[];\n  for (const key of keys) {\n    const v = breakpointMap[key];\n    if (v !== undefined) {\n      return v;\n    }\n  }\n\n  // Default fallback\n  return [10, 10];\n}\n", "import {\n  EqualityComparator,\n  InternalEqualityComparator,\n  TypeEqualityComparator,\n} from '../index.d';\n\n/**\n * Default equality comparator pass-through, used as the standard `isEqual` creator for\n * use inside the built comparator.\n */\nexport function createDefaultIsNestedEqual<Meta>(\n  comparator: EqualityComparator<Meta>,\n): InternalEqualityComparator<Meta> {\n  return function isEqual<A, B>(\n    a: A,\n    b: B,\n    _indexOrKeyA: any,\n    _indexOrKeyB: any,\n    _parentA: any,\n    _parentB: any,\n    meta: Meta,\n  ) {\n    return comparator(a, b, meta);\n  };\n}\n\n/**\n * Wrap the provided `areItemsEqual` method to manage the circular cache, allowing\n * for circular references to be safely included in the comparison without creating\n * stack overflows.\n */\nexport function createIsCircular<\n  AreItemsEqual extends TypeEqualityComparator<any, any>,\n>(areItemsEqual: AreItemsEqual): AreItemsEqual {\n  return function isCircular(\n    a: any,\n    b: any,\n    isEqual: InternalEqualityComparator<WeakMap<any, any>>,\n    cache: WeakMap<any, any>,\n  ) {\n    if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\n      return areItemsEqual(a, b, isEqual, cache);\n    }\n\n    const cachedA = cache.get(a);\n    const cachedB = cache.get(b);\n\n    if (cachedA && cachedB) {\n      return cachedA === b && cachedB === a;\n    }\n\n    cache.set(a, b);\n    cache.set(b, a);\n\n    const result = areItemsEqual(a, b, isEqual, cache);\n\n    cache.delete(a);\n    cache.delete(b);\n\n    return result;\n  } as AreItemsEqual;\n}\n\n/**\n * Targeted shallow merge of two objects.\n *\n * @NOTE\n * This exists as a tinier compiled version of the `__assign` helper that\n * `tsc` injects in case of `Object.assign` not being present.\n */\nexport function merge<A extends object, B extends object>(a: A, b: B): A & B {\n  const merged: Record<string, any> = {};\n\n  for (const key in a) {\n    merged[key] = a[key];\n  }\n\n  for (const key in b) {\n    merged[key] = b[key];\n  }\n\n  return merged as A & B;\n}\n\n/**\n * Whether the value is a plain object.\n *\n * @NOTE\n * This is a same-realm compariosn only.\n */\nexport function isPlainObject(value: any): boolean {\n  return value.constructor === Object || value.constructor == null;\n}\n\n/**\n * When the value is `Promise`-like, aka \"then-able\".\n */\nexport function isPromiseLike(value: any): boolean {\n  return typeof value.then === 'function';\n}\n\n/**\n * Whether the values passed are strictly equal or both NaN.\n */\nexport function sameValueZeroEqual(a: any, b: any): boolean {\n  return a === b || (a !== a && b !== b);\n}\n", "import { isPlainObject, isPromiseLike, sameValueZeroEqual } from './utils';\n\nimport type {\n  CreateComparatorCreatorOptions,\n  EqualityComparator,\n} from '../index.d';\n\nconst ARGUMENTS_TAG = '[object Arguments]';\nconst BOOLEAN_TAG = '[object Boolean]';\nconst DATE_TAG = '[object Date]';\nconst REG_EXP_TAG = '[object RegExp]';\nconst MAP_TAG = '[object Map]';\nconst NUMBER_TAG = '[object Number]';\nconst OBJECT_TAG = '[object Object]';\nconst SET_TAG = '[object Set]';\nconst STRING_TAG = '[object String]';\n\nconst { toString } = Object.prototype;\n\nexport function createComparator<Meta>({\n  areArraysEqual,\n  areDatesEqual,\n  areMapsEqual,\n  areObjectsEqual,\n  areRegExpsEqual,\n  areSetsEqual,\n  createIsNestedEqual,\n}: CreateComparatorCreatorOptions<Meta>): EqualityComparator<Meta> {\n  const isEqual = createIsNestedEqual(comparator as EqualityComparator<Meta>);\n\n  /**\n   * compare the value of the two objects and return true if they are equivalent in values\n   */\n  function comparator(a: any, b: any, meta: Meta): boolean {\n    // If the items are strictly equal, no need to do a value comparison.\n    if (a === b) {\n      return true;\n    }\n\n    // If the items are not non-nullish objects, then the only possibility\n    // of them being equal but not strictly is if they are both `NaN`. Since\n    // `NaN` is uniquely not equal to itself, we can use self-comparison of\n    // both objects, which is faster than `isNaN()`.\n    if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\n      return a !== a && b !== b;\n    }\n\n    // Checks are listed in order of commonality of use-case:\n    //   1. Common complex object types (plain object, array)\n    //   2. Common data values (date, regexp)\n    //   3. Less-common complex object types (map, set)\n    //   4. Less-common data values (promise, primitive wrappers)\n    // Inherently this is both subjective and assumptive, however\n    // when reviewing comparable libraries in the wild this order\n    // appears to be generally consistent.\n\n    // `isPlainObject` only checks against the object's own realm. Cross-realm\n    // comparisons are rare, and will be handled in the ultimate fallback, so\n    // we can avoid the `toString.call()` cost unless necessary.\n    if (isPlainObject(a) && isPlainObject(b)) {\n      return areObjectsEqual(a, b, isEqual, meta);\n    }\n\n    // `isArray()` works on subclasses and is cross-realm, so we can again avoid\n    // the `toString.call()` cost unless necessary by just checking if either\n    // and then both are arrays.\n    const aArray = Array.isArray(a);\n    const bArray = Array.isArray(b);\n\n    if (aArray || bArray) {\n      return aArray === bArray && areArraysEqual(a, b, isEqual, meta);\n    }\n\n    // Since this is a custom object, use the classic `toString.call()` to get its\n    // type. This is reasonably performant in modern environments like v8 and\n    // SpiderMonkey, and allows for cross-realm comparison when other checks like\n    // `instanceof` do not.\n    const aTag = toString.call(a);\n\n    if (aTag !== toString.call(b)) {\n      return false;\n    }\n\n    if (aTag === DATE_TAG) {\n      // `getTime()` showed better results compared to alternatives like `valueOf()`\n      // or the unary `+` operator.\n      return areDatesEqual(a, b, isEqual, meta);\n    }\n\n    if (aTag === REG_EXP_TAG) {\n      return areRegExpsEqual(a, b, isEqual, meta);\n    }\n\n    if (aTag === MAP_TAG) {\n      return areMapsEqual(a, b, isEqual, meta);\n    }\n\n    if (aTag === SET_TAG) {\n      return areSetsEqual(a, b, isEqual, meta);\n    }\n\n    // If a simple object tag, then we can prioritize a simple object comparison because\n    // it is likely a custom class. If an arguments tag, it should be treated as a standard\n    // object.\n    if (aTag === OBJECT_TAG || aTag === ARGUMENTS_TAG) {\n      // The exception for value comparison is `Promise`-like contracts. These should be\n      // treated the same as standard `Promise` objects, which means strict equality.\n      return isPromiseLike(a) || isPromiseLike(b)\n        ? false\n        : areObjectsEqual(a, b, isEqual, meta);\n    }\n\n    // As the penultimate fallback, check if the values passed are primitive wrappers. This\n    // is very rare in modern JS, which is why it is deprioritized compared to all other object\n    // types.\n    if (aTag === BOOLEAN_TAG || aTag === NUMBER_TAG || aTag === STRING_TAG) {\n      return sameValueZeroEqual(a.valueOf(), b.valueOf());\n    }\n\n    // If not matching any tags that require a specific type of comparison, then we hard-code false because\n    // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\n    //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\n    //     comparison that can be made.\n    //   - For types that can be introspected, but rarely have requirements to be compared\n    //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\n    //     use-cases (may be included in a future release, if requested enough).\n    //   - For types that can be introspected but do not have an objective definition of what\n    //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\n    // In all cases, these decisions should be reevaluated based on changes to the language and\n    // common development practices.\n    return false;\n  }\n\n  return comparator as EqualityComparator<Meta>;\n}\n", "import { createIsCircular } from './utils';\n\nimport type { InternalEqualityComparator } from '../index.d';\n\n/**\n * Whether the arrays are equal in value.\n */\nexport function areArraysEqual(\n  a: any[],\n  b: any[],\n  isEqual: InternalEqualityComparator<any>,\n  meta: any,\n): boolean {\n  let index = a.length;\n\n  if (b.length !== index) {\n    return false;\n  }\n\n  // Decrementing `while` showed faster results than either incrementing or\n  // decrementing `for` loop and than an incrementing `while` loop. Declarative\n  // methods like `some` / `every` were not used to avoid incurring the garbage\n  // cost of anonymous callbacks.\n  while (index-- > 0) {\n    if (!isEqual(a[index], b[index], index, index, a, b, meta)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the arrays are equal in value, including circular references.\n */\nexport const areArraysEqualCircular = createIsCircular(areArraysEqual);\n", "import { sameValueZeroEqual } from './utils';\n\n/**\n * Whether the dates passed are equal in value.\n *\n * @NOTE\n * This is a standalone function instead of done inline in the comparator\n * to allow for overrides.\n */\nexport function areDatesEqual(a: Date, b: Date): boolean {\n  return sameValueZeroEqual(a.valueOf(), b.valueOf());\n}\n", "import { createIsCircular } from './utils';\n\nimport type { InternalEqualityComparator } from '../index.d';\n\n/**\n * Whether the `Map`s are equal in value.\n */\nexport function areMapsEqual(\n  a: Map<any, any>,\n  b: Map<any, any>,\n  isEqual: InternalEqualityComparator<any>,\n  meta: any,\n): boolean {\n  let isValueEqual = a.size === b.size;\n\n  if (!isValueEqual) {\n    return false;\n  }\n\n  if (!a.size) {\n    return true;\n  }\n\n  // The use of `forEach()` is to avoid the transpilation cost of `for...of` comparisons, and\n  // the inability to control the performance of the resulting code. It also avoids excessive\n  // iteration compared to doing comparisons of `keys()` and `values()`. As a result, though,\n  // we cannot short-circuit the iterations; bookkeeping must be done to short-circuit the\n  // equality checks themselves.\n\n  const matchedIndices: Record<number, true> = {};\n\n  let indexA = 0;\n\n  a.forEach((aValue, aKey) => {\n    if (!isValueEqual) {\n      return;\n    }\n\n    let hasMatch = false;\n    let matchIndexB = 0;\n\n    b.forEach((bValue, bKey) => {\n      if (\n        !hasMatch &&\n        !matchedIndices[matchIndexB] &&\n        (hasMatch =\n          isEqual(aKey, bKey, indexA, matchIndexB, a, b, meta) &&\n          isEqual(aValue, bValue, aKey, bKey, a, b, meta))\n      ) {\n        matchedIndices[matchIndexB] = true;\n      }\n\n      matchIndexB++;\n    });\n\n    indexA++;\n    isValueEqual = hasMatch;\n  });\n\n  return isValueEqual;\n}\n\n/**\n * Whether the `Map`s are equal in value, including circular references.\n */\nexport const areMapsEqualCircular = createIsCircular(areMapsEqual);\n", "import { createIsCircular } from './utils';\n\nimport type { InternalEqualityComparator } from '../index.d';\n\ninterface Dictionary<Value> {\n  [key: string]: Value;\n  $$typeof?: any;\n}\n\nconst OWNER = '_owner';\nconst { hasOwnProperty } = Object.prototype;\n\n/**\n * Whether the objects are equal in value.\n */\nexport function areObjectsEqual(\n  a: Dictionary<any>,\n  b: Dictionary<any>,\n  isEqual: InternalEqualityComparator<any>,\n  meta: any,\n): boolean {\n  const keysA = Object.keys(a);\n\n  let index = keysA.length;\n\n  if (Object.keys(b).length !== index) {\n    return false;\n  }\n\n  let key: string;\n\n  // Decrementing `while` showed faster results than either incrementing or\n  // decrementing `for` loop and than an incrementing `while` loop. Declarative\n  // methods like `some` / `every` were not used to avoid incurring the garbage\n  // cost of anonymous callbacks.\n  while (index-- > 0) {\n    key = keysA[index];\n\n    if (key === OWNER) {\n      const reactElementA = !!a.$$typeof;\n      const reactElementB = !!b.$$typeof;\n\n      if ((reactElementA || reactElementB) && reactElementA !== reactElementB) {\n        return false;\n      }\n    }\n\n    if (\n      !hasOwnProperty.call(b, key) ||\n      !isEqual(a[key], b[key], key, key, a, b, meta)\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the objects are equal in value, including circular references.\n */\nexport const areObjectsEqualCircular = createIsCircular(areObjectsEqual);\n", "/**\n * Whether the regexps passed are equal in value.\n *\n * @NOTE\n * This is a standalone function instead of done inline in the comparator\n * to allow for overrides. An example of this would be supporting a\n * pre-ES2015 environment where the `flags` property is not available.\n */\nexport function areRegExpsEqual(a: RegExp, b: RegExp): boolean {\n  return a.source === b.source && a.flags === b.flags;\n}\n", "import { createIsCircular } from './utils';\n\nimport type { InternalEqualityComparator } from '../index.d';\n\n/**\n * Whether the `Set`s are equal in value.\n */\nexport function areSetsEqual(\n  a: Set<any>,\n  b: Set<any>,\n  isEqual: InternalEqualityComparator<any>,\n  meta: any,\n): boolean {\n  let isValueEqual = a.size === b.size;\n\n  if (!isValueEqual) {\n    return false;\n  }\n\n  if (!a.size) {\n    return true;\n  }\n\n  // The use of `forEach()` is to avoid the transpilation cost of `for...of` comparisons, and\n  // the inability to control the performance of the resulting code. It also avoids excessive\n  // iteration compared to doing comparisons of `keys()` and `values()`. As a result, though,\n  // we cannot short-circuit the iterations; bookkeeping must be done to short-circuit the\n  // equality checks themselves.\n\n  const matchedIndices: Record<number, true> = {};\n\n  a.forEach((aValue, aKey) => {\n    if (!isValueEqual) {\n      return;\n    }\n\n    let hasMatch = false;\n    let matchIndex = 0;\n\n    b.forEach((bValue, bKey) => {\n      if (\n        !hasMatch &&\n        !matchedIndices[matchIndex] &&\n        (hasMatch = isEqual(aValue, bValue, aKey, bKey, a, b, meta))\n      ) {\n        matchedIndices[matchIndex] = true;\n      }\n\n      matchIndex++;\n    });\n\n    isValueEqual = hasMatch;\n  });\n\n  return isValueEqual;\n}\n\n/**\n * Whether the `Set`s are equal in value, including circular references.\n */\nexport const areSetsEqualCircular = createIsCircular(areSetsEqual);\n", "import { createComparator } from './comparator';\nimport { areArraysEqual, areArraysEqualCircular } from './arrays';\nimport { areDatesEqual } from './dates';\nimport { areMapsEqual, areMapsEqualCircular } from './maps';\nimport { areObjectsEqual, areObjectsEqualCircular } from './objects';\nimport { areRegExpsEqual } from './regexps';\nimport { areSetsEqual, areSetsEqualCircular } from './sets';\nimport { createDefaultIsNestedEqual, merge, sameValueZeroEqual } from './utils';\n\nimport type {\n  BaseCircularMeta,\n  CreateComparatorCreatorOptions,\n  EqualityComparator,\n  GetComparatorOptions,\n} from '../index.d';\n\nexport { sameValueZeroEqual };\n\nconst DEFAULT_CONFIG: CreateComparatorCreatorOptions<undefined> = Object.freeze(\n  {\n    areArraysEqual,\n    areDatesEqual,\n    areMapsEqual,\n    areObjectsEqual,\n    areRegExpsEqual,\n    areSetsEqual,\n    createIsNestedEqual: createDefaultIsNestedEqual,\n  },\n);\nconst DEFAULT_CIRCULAR_CONFIG: CreateComparatorCreatorOptions<BaseCircularMeta> =\n  Object.freeze({\n    areArraysEqual: areArraysEqualCircular,\n    areDatesEqual,\n    areMapsEqual: areMapsEqualCircular,\n    areObjectsEqual: areObjectsEqualCircular,\n    areRegExpsEqual,\n    areSetsEqual: areSetsEqualCircular,\n    createIsNestedEqual: createDefaultIsNestedEqual,\n  });\n\nconst isDeepEqual = createComparator(DEFAULT_CONFIG);\n\n/**\n * Whether the items passed are deeply-equal in value.\n */\nexport function deepEqual<A, B>(a: A, b: B): boolean {\n  return isDeepEqual(a, b, undefined);\n}\n\nconst isShallowEqual = createComparator(\n  merge(DEFAULT_CONFIG, { createIsNestedEqual: () => sameValueZeroEqual }),\n);\n\n/**\n * Whether the items passed are shallowly-equal in value.\n */\nexport function shallowEqual<A, B>(a: A, b: B): boolean {\n  return isShallowEqual(a, b, undefined);\n}\n\nconst isCircularDeepEqual = createComparator(DEFAULT_CIRCULAR_CONFIG);\n\n/**\n * Whether the items passed are deeply-equal in value, including circular references.\n */\nexport function circularDeepEqual<A, B>(a: A, b: B): boolean {\n  return isCircularDeepEqual(a, b, new WeakMap());\n}\n\nconst isCircularShallowEqual = createComparator(\n  merge(DEFAULT_CIRCULAR_CONFIG, {\n    createIsNestedEqual: () => sameValueZeroEqual,\n  }),\n);\n\n/**\n * Whether the items passed are shallowly-equal in value, including circular references.\n */\nexport function circularShallowEqual<A, B>(a: A, b: B): boolean {\n  return isCircularShallowEqual(a, b, new WeakMap());\n}\n\n/**\n * Create a custom equality comparison method.\n *\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\n * where the standard methods are not performant enough, but can also be used to provide\n * support for legacy environments that do not support expected features like\n * `RegExp.prototype.flags` out of the box.\n */\nexport function createCustomEqual<Meta = undefined>(\n  getComparatorOptions: GetComparatorOptions<Meta>,\n): EqualityComparator<Meta> {\n  return createComparator<Meta>(\n    merge(DEFAULT_CONFIG, getComparatorOptions(DEFAULT_CONFIG as any)),\n  );\n}\n\n/**\n * Create a custom equality comparison method that handles circular references. This is very\n * similar to `createCustomEqual`, with the only difference being that `meta` expects to be\n * populated with a `WeakMap`-like contract.\n *\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\n * where the standard methods are not performant enough, but can also be used to provide\n * support for legacy environments that do not support expected features like\n * `WeakMap` out of the box.\n */\nexport function createCustomCircularEqual<\n  Meta extends BaseCircularMeta = WeakMap<any, any>,\n>(getComparatorOptions: GetComparatorOptions<Meta>): EqualityComparator<Meta> {\n  const comparator = createComparator<Meta>(\n    merge(\n      DEFAULT_CIRCULAR_CONFIG,\n      getComparatorOptions(DEFAULT_CIRCULAR_CONFIG as any),\n    ),\n  );\n\n  return ((a: any, b: any, meta: any = new WeakMap()) =>\n    comparator(a, b, meta)) as EqualityComparator<Meta>;\n}\n", "/**\n * useContainerWidth hook\n *\n * Observes container width using ResizeObserver and provides\n * reactive width updates for responsive layouts.\n */\n\nimport {\n  useState,\n  useEffect,\n  useRef,\n  useCallback,\n  type RefObject\n} from \"react\";\n\nexport interface UseContainerWidthOptions {\n  /**\n   * If true, delays initial render until width is measured.\n   * Useful for SSR or when you need accurate initial measurements.\n   */\n  measureBeforeMount?: boolean;\n\n  /**\n   * Initial width to use before measurement.\n   * Defaults to 1280.\n   */\n  initialWidth?: number;\n}\n\nexport interface UseContainerWidthResult {\n  /**\n   * Current container width in pixels.\n   */\n  width: number;\n\n  /**\n   * Whether the container has been measured at least once.\n   */\n  mounted: boolean;\n\n  /**\n   * Ref to attach to the container element.\n   */\n  containerRef: RefObject<HTMLDivElement | null>;\n\n  /**\n   * Manually trigger a width measurement.\n   * Useful when the container size might change without a resize event.\n   */\n  measureWidth: () => void;\n}\n\n/**\n * Hook to observe and track container width.\n *\n * Replaces the WidthProvider HOC with a more composable approach.\n *\n * @example\n * ```tsx\n * function MyGrid() {\n *   const { width, containerRef, mounted } = useContainerWidth();\n *\n *   return (\n *     <div ref={containerRef}>\n *       {mounted && <GridLayout width={width} {...props} />}\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useContainerWidth(\n  options: UseContainerWidthOptions = {}\n): UseContainerWidthResult {\n  const { measureBeforeMount = false, initialWidth = 1280 } = options;\n\n  const [width, setWidth] = useState(initialWidth);\n  const [mounted, setMounted] = useState(!measureBeforeMount);\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const observerRef = useRef<ResizeObserver | null>(null);\n\n  const measureWidth = useCallback(() => {\n    const node = containerRef.current;\n    if (node) {\n      const newWidth = node.offsetWidth;\n      setWidth(newWidth);\n      if (!mounted) {\n        setMounted(true);\n      }\n    }\n  }, [mounted]);\n\n  useEffect(() => {\n    const node = containerRef.current;\n    if (!node) return;\n\n    // Initial measurement\n    measureWidth();\n\n    // Set up ResizeObserver\n    if (typeof ResizeObserver !== \"undefined\") {\n      observerRef.current = new ResizeObserver(entries => {\n        const entry = entries[0];\n        if (entry) {\n          // Use contentRect.width for consistent measurements\n          const newWidth = entry.contentRect.width;\n          setWidth(newWidth);\n        }\n      });\n\n      observerRef.current.observe(node);\n    }\n\n    return () => {\n      if (observerRef.current) {\n        observerRef.current.disconnect();\n        observerRef.current = null;\n      }\n    };\n  }, [measureWidth]);\n\n  return {\n    width,\n    mounted,\n    containerRef,\n    measureWidth\n  };\n}\n\nexport default useContainerWidth;\n", "/**\n * useGridLayout hook\n *\n * Core hook for managing grid layout state, including drag, resize, and drop operations.\n * This extracts the state management logic from ReactGridLayout into a reusable hook.\n */\n\nimport { useState, useCallback, useMemo, useRef, useEffect } from \"react\";\nimport { deepEqual } from \"fast-equals\";\nimport type {\n  Layout,\n  LayoutItem,\n  DroppingPosition,\n  Compactor,\n  Mutable\n} from \"../../core/types.js\";\nimport {\n  cloneLayout,\n  cloneLayoutItem,\n  moveElement,\n  correctBounds,\n  bottom,\n  getLayoutItem\n} from \"../../core/layout.js\";\nimport { verticalCompactor } from \"../../core/compactors.js\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface DragState {\n  /** Currently dragging item placeholder */\n  activeDrag: LayoutItem | null;\n  /** Original item before drag started */\n  oldDragItem: LayoutItem | null;\n  /** Layout before drag started */\n  oldLayout: Layout | null;\n}\n\nexport interface ResizeState {\n  /** Whether a resize is in progress */\n  resizing: boolean;\n  /** Original item before resize started */\n  oldResizeItem: LayoutItem | null;\n  /** Layout before resize started */\n  oldLayout: Layout | null;\n}\n\nexport interface DropState {\n  /** DOM node for the dropping placeholder */\n  droppingDOMNode: React.ReactElement | null;\n  /** Current drop position */\n  droppingPosition: DroppingPosition | null;\n}\n\nexport interface UseGridLayoutOptions {\n  /** Initial layout */\n  layout: Layout;\n  /** Number of columns */\n  cols: number;\n  /** Prevent collisions when moving items */\n  preventCollision?: boolean;\n  /** Called when layout changes */\n  onLayoutChange?: (layout: Layout) => void;\n  /** Compactor for layout compaction (default: verticalCompactor) */\n  compactor?: Compactor;\n}\n\nexport interface UseGridLayoutResult {\n  /** Current layout */\n  layout: Layout;\n  /** Set layout directly */\n  setLayout: (layout: Layout) => void;\n  /** Drag state */\n  dragState: DragState;\n  /** Resize state */\n  resizeState: ResizeState;\n  /** Drop state */\n  dropState: DropState;\n  /** Start dragging an item */\n  onDragStart: (itemId: string, x: number, y: number) => LayoutItem | null;\n  /** Update drag position */\n  onDrag: (itemId: string, x: number, y: number) => void;\n  /** Stop dragging */\n  onDragStop: (itemId: string, x: number, y: number) => void;\n  /** Start resizing an item */\n  onResizeStart: (itemId: string) => LayoutItem | null;\n  /** Update resize dimensions */\n  onResize: (\n    itemId: string,\n    w: number,\n    h: number,\n    x?: number,\n    y?: number\n  ) => void;\n  /** Stop resizing */\n  onResizeStop: (itemId: string, w: number, h: number) => void;\n  /** Start dropping (external drag-in) */\n  onDropDragOver: (\n    droppingItem: LayoutItem,\n    position: DroppingPosition\n  ) => void;\n  /** Update drop position */\n  onDropDragLeave: () => void;\n  /** Complete drop */\n  onDrop: (droppingItem: LayoutItem) => void;\n  /** Container height in rows */\n  containerHeight: number;\n  /** Whether any drag/resize is active */\n  isInteracting: boolean;\n  /** Get the compactor being used */\n  compactor: Compactor;\n}\n\n// ============================================================================\n// Hook Implementation\n// ============================================================================\n\n/**\n * Hook for managing grid layout state.\n *\n * Handles all layout state including drag, resize, and drop operations.\n * Uses immutable updates and provides callbacks for all interactions.\n *\n * @example\n * ```tsx\n * function MyGrid() {\n *   const {\n *     layout,\n *     onDragStart,\n *     onDrag,\n *     onDragStop,\n *     containerHeight\n *   } = useGridLayout({\n *     layout: initialLayout,\n *     cols: 12\n *   });\n *\n *   return (\n *     <div style={{ height: containerHeight }}>\n *       {layout.map(item => (\n *         <GridItem\n *           key={item.i}\n *           {...item}\n *           onDragStart={() => onDragStart(item.i, item.x, item.y)}\n *         />\n *       ))}\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useGridLayout(\n  options: UseGridLayoutOptions\n): UseGridLayoutResult {\n  const {\n    layout: propsLayout,\n    cols,\n    preventCollision = false,\n    onLayoutChange,\n    compactor = verticalCompactor\n  } = options;\n\n  // Track if we're currently dragging to block prop updates\n  const isDraggingRef = useRef(false);\n\n  // Initialize layout with compaction using the compactor\n  const [layout, setLayoutState] = useState<Layout>(() => {\n    const corrected = correctBounds(cloneLayout(propsLayout), { cols });\n    return compactor.compact(corrected, cols);\n  });\n\n  // Drag state\n  const [dragState, setDragState] = useState<DragState>({\n    activeDrag: null,\n    oldDragItem: null,\n    oldLayout: null\n  });\n\n  // Resize state\n  const [resizeState, setResizeState] = useState<ResizeState>({\n    resizing: false,\n    oldResizeItem: null,\n    oldLayout: null\n  });\n\n  // Drop state\n  const [dropState, setDropState] = useState<DropState>({\n    droppingDOMNode: null,\n    droppingPosition: null\n  });\n\n  // Track previous layout for change detection\n  const prevLayoutRef = useRef<Layout>(layout);\n\n  // Set layout with optional compaction - use compactor.compact() (#2213)\n  const setLayout = useCallback(\n    (newLayout: Layout) => {\n      const corrected = correctBounds(cloneLayout(newLayout), { cols });\n      const compacted = compactor.compact(corrected, cols);\n      setLayoutState(compacted);\n    },\n    [cols, compactor]\n  );\n\n  // Sync layout from props when not dragging\n  useEffect(() => {\n    if (isDraggingRef.current) return;\n\n    if (!deepEqual(propsLayout, prevLayoutRef.current)) {\n      setLayout(propsLayout);\n    }\n  }, [propsLayout, setLayout]);\n\n  // Notify layout changes\n  useEffect(() => {\n    if (!deepEqual(layout, prevLayoutRef.current)) {\n      prevLayoutRef.current = layout;\n      onLayoutChange?.(layout);\n    }\n  }, [layout, onLayoutChange]);\n\n  // ============================================================================\n  // Drag Handlers\n  // ============================================================================\n\n  const onDragStart = useCallback(\n    (itemId: string, x: number, y: number): LayoutItem | null => {\n      const item = getLayoutItem(layout, itemId);\n      if (!item) return null;\n\n      isDraggingRef.current = true;\n\n      const placeholder: LayoutItem = {\n        ...cloneLayoutItem(item),\n        x,\n        y,\n        static: false,\n        moved: false\n      };\n\n      setDragState({\n        activeDrag: placeholder,\n        oldDragItem: cloneLayoutItem(item),\n        oldLayout: cloneLayout(layout)\n      });\n\n      return placeholder;\n    },\n    [layout]\n  );\n\n  const onDrag = useCallback(\n    (itemId: string, x: number, y: number) => {\n      const item = getLayoutItem(layout, itemId);\n      if (!item) return;\n\n      // Update placeholder position\n      setDragState(prev => ({\n        ...prev,\n        activeDrag: prev.activeDrag ? { ...prev.activeDrag, x, y } : null\n      }));\n\n      // Move element and update layout\n      const newLayout = moveElement(\n        layout,\n        item,\n        x,\n        y,\n        true, // isUserAction\n        preventCollision,\n        compactor.type,\n        cols,\n        compactor.allowOverlap\n      );\n\n      // Compact layout - use compactor.compact() (#2213)\n      const compacted = compactor.compact(newLayout, cols);\n\n      setLayoutState(compacted);\n    },\n    [layout, cols, compactor, preventCollision]\n  );\n\n  const onDragStop = useCallback(\n    (itemId: string, x: number, y: number) => {\n      const item = getLayoutItem(layout, itemId);\n      if (!item) return;\n\n      // Final move\n      const newLayout = moveElement(\n        layout,\n        item,\n        x,\n        y,\n        true,\n        preventCollision,\n        compactor.type,\n        cols,\n        compactor.allowOverlap\n      );\n\n      // Compact and finalize - use compactor.compact() (#2213)\n      const compacted = compactor.compact(newLayout, cols);\n\n      isDraggingRef.current = false;\n\n      setDragState({\n        activeDrag: null,\n        oldDragItem: null,\n        oldLayout: null\n      });\n\n      setLayoutState(compacted);\n    },\n    [layout, cols, compactor, preventCollision]\n  );\n\n  // ============================================================================\n  // Resize Handlers\n  // ============================================================================\n\n  const onResizeStart = useCallback(\n    (itemId: string): LayoutItem | null => {\n      const item = getLayoutItem(layout, itemId);\n      if (!item) return null;\n\n      setResizeState({\n        resizing: true,\n        oldResizeItem: cloneLayoutItem(item),\n        oldLayout: cloneLayout(layout)\n      });\n\n      return item;\n    },\n    [layout]\n  );\n\n  const onResize = useCallback(\n    (itemId: string, w: number, h: number, x?: number, y?: number) => {\n      const newLayout = layout.map(item => {\n        if (item.i === itemId) {\n          const updated: LayoutItem = {\n            ...item,\n            w,\n            h\n          };\n          if (x !== undefined) (updated as Mutable<LayoutItem>).x = x;\n          if (y !== undefined) (updated as Mutable<LayoutItem>).y = y;\n          return updated;\n        }\n        return item;\n      });\n\n      // Correct bounds and compact - use compactor.compact() (#2213)\n      const corrected = correctBounds(newLayout, { cols });\n      const compacted = compactor.compact(corrected, cols);\n\n      setLayoutState(compacted);\n    },\n    [layout, cols, compactor]\n  );\n\n  const onResizeStop = useCallback(\n    (itemId: string, w: number, h: number) => {\n      // Apply final resize\n      onResize(itemId, w, h);\n\n      setResizeState({\n        resizing: false,\n        oldResizeItem: null,\n        oldLayout: null\n      });\n    },\n    [onResize]\n  );\n\n  // ============================================================================\n  // Drop Handlers\n  // ============================================================================\n\n  const onDropDragOver = useCallback(\n    (droppingItem: LayoutItem, position: DroppingPosition) => {\n      // Check if item already exists in layout\n      const existingItem = getLayoutItem(layout, droppingItem.i);\n\n      if (!existingItem) {\n        // Add dropping item to layout - use compactor.compact() (#2213)\n        const newLayout = [...layout, droppingItem];\n        const corrected = correctBounds(newLayout, { cols });\n        const compacted = compactor.compact(corrected, cols);\n        setLayoutState(compacted);\n      }\n\n      setDropState({\n        droppingDOMNode: null, // Will be set by component\n        droppingPosition: position\n      });\n    },\n    [layout, cols, compactor]\n  );\n\n  const onDropDragLeave = useCallback(() => {\n    // Remove dropping placeholder from layout\n    const newLayout = layout.filter(item => item.i !== \"__dropping-elem__\");\n    setLayoutState(newLayout);\n\n    setDropState({\n      droppingDOMNode: null,\n      droppingPosition: null\n    });\n  }, [layout]);\n\n  const onDrop = useCallback(\n    (droppingItem: LayoutItem) => {\n      // Replace placeholder with actual item\n      const newLayout = layout.map(item => {\n        if (item.i === \"__dropping-elem__\") {\n          return {\n            ...item,\n            i: droppingItem.i,\n            static: false\n          };\n        }\n        return item;\n      });\n\n      // Use compactor.compact() (#2213)\n      const corrected = correctBounds(newLayout, { cols });\n      const compacted = compactor.compact(corrected, cols);\n      setLayoutState(compacted);\n\n      setDropState({\n        droppingDOMNode: null,\n        droppingPosition: null\n      });\n    },\n    [layout, cols, compactor]\n  );\n\n  // ============================================================================\n  // Computed Values\n  // ============================================================================\n\n  const containerHeight = useMemo(() => bottom(layout), [layout]);\n\n  const isInteracting =\n    dragState.activeDrag !== null ||\n    resizeState.resizing ||\n    dropState.droppingPosition !== null;\n\n  return {\n    layout,\n    setLayout,\n    dragState,\n    resizeState,\n    dropState,\n    onDragStart,\n    onDrag,\n    onDragStop,\n    onResizeStart,\n    onResize,\n    onResizeStop,\n    onDropDragOver,\n    onDropDragLeave,\n    onDrop,\n    containerHeight,\n    isInteracting,\n    compactor\n  };\n}\n\nexport default useGridLayout;\n", "/**\n * useResponsiveLayout hook\n *\n * Manages responsive breakpoints and layout generation for different screen sizes.\n * Extracts state management from ResponsiveReactGridLayout into a reusable hook.\n */\n\nimport { useState, useCallback, useEffect, useMemo, useRef } from \"react\";\nimport { deepEqual } from \"fast-equals\";\nimport type {\n  Layout,\n  Breakpoint,\n  Breakpoints,\n  ResponsiveLayouts,\n  Compactor\n} from \"../../core/types.js\";\nimport { cloneLayout } from \"../../core/layout.js\";\nimport {\n  getBreakpointFromWidth,\n  getColsFromBreakpoint,\n  findOrGenerateResponsiveLayout,\n  sortBreakpoints\n} from \"../../core/responsive.js\";\nimport { verticalCompactor } from \"../../core/compactors.js\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/** Default breakpoint names */\nexport type DefaultBreakpoints = \"lg\" | \"md\" | \"sm\" | \"xs\" | \"xxs\";\n\n/** Default breakpoint widths */\nexport const DEFAULT_BREAKPOINTS: Breakpoints<DefaultBreakpoints> = {\n  lg: 1200,\n  md: 996,\n  sm: 768,\n  xs: 480,\n  xxs: 0\n};\n\n/** Default column counts per breakpoint */\nexport const DEFAULT_COLS: Breakpoints<DefaultBreakpoints> = {\n  lg: 12,\n  md: 10,\n  sm: 6,\n  xs: 4,\n  xxs: 2\n};\n\nexport interface UseResponsiveLayoutOptions<\n  B extends Breakpoint = DefaultBreakpoints\n> {\n  /** Current container width */\n  width: number;\n  /** Breakpoint definitions (name  min-width) */\n  breakpoints?: Breakpoints<B>;\n  /** Column counts per breakpoint */\n  cols?: Breakpoints<B>;\n  /** Layouts for each breakpoint */\n  layouts?: ResponsiveLayouts<B>;\n  /** Compactor for layout compaction (default: verticalCompactor) */\n  compactor?: Compactor;\n  /** Called when breakpoint changes */\n  onBreakpointChange?: (newBreakpoint: B, cols: number) => void;\n  /** Called when layout changes */\n  onLayoutChange?: (layout: Layout, layouts: ResponsiveLayouts<B>) => void;\n  /** Called when width changes */\n  onWidthChange?: (\n    width: number,\n    margin: readonly [number, number],\n    cols: number,\n    containerPadding: readonly [number, number] | null\n  ) => void;\n}\n\nexport interface UseResponsiveLayoutResult<\n  B extends Breakpoint = DefaultBreakpoints\n> {\n  /** Current layout for the active breakpoint */\n  layout: Layout;\n  /** All layouts by breakpoint */\n  layouts: ResponsiveLayouts<B>;\n  /** Current active breakpoint */\n  breakpoint: B;\n  /** Column count for the current breakpoint */\n  cols: number;\n  /** Update layouts for a specific breakpoint */\n  setLayoutForBreakpoint: (breakpoint: B, layout: Layout) => void;\n  /** Update all layouts */\n  setLayouts: (layouts: ResponsiveLayouts<B>) => void;\n  /** Sorted array of breakpoint names (smallest to largest) */\n  sortedBreakpoints: B[];\n}\n\n// ============================================================================\n// Hook Implementation\n// ============================================================================\n\n/**\n * Hook for managing responsive grid layouts.\n *\n * Automatically selects the appropriate layout based on container width\n * and generates layouts for new breakpoints from existing ones.\n *\n * @example\n * ```tsx\n * function MyResponsiveGrid() {\n *   const { width, containerRef } = useContainerWidth();\n *   const { layout, breakpoint, cols } = useResponsiveLayout({\n *     width,\n *     layouts: {\n *       lg: [...],\n *       md: [...],\n *       sm: [...]\n *     }\n *   });\n *\n *   return (\n *     <div ref={containerRef}>\n *       <GridLayout\n *         width={width}\n *         cols={cols}\n *         layout={layout}\n *       />\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useResponsiveLayout<B extends Breakpoint = DefaultBreakpoints>(\n  options: UseResponsiveLayoutOptions<B>\n): UseResponsiveLayoutResult<B> {\n  const {\n    width,\n    breakpoints = DEFAULT_BREAKPOINTS as unknown as Breakpoints<B>,\n    cols: colsConfig = DEFAULT_COLS as unknown as Breakpoints<B>,\n    layouts: propsLayouts = {} as ResponsiveLayouts<B>,\n    compactor = verticalCompactor,\n    onBreakpointChange,\n    onLayoutChange,\n    onWidthChange\n  } = options;\n\n  // Sorted breakpoints for consistent ordering\n  const sortedBreakpoints = useMemo(\n    () => sortBreakpoints(breakpoints),\n    [breakpoints]\n  );\n\n  // Calculate initial breakpoint and cols\n  const initialBreakpoint = useMemo(\n    () => getBreakpointFromWidth(breakpoints, width),\n    // Only calculate on mount, not on width changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  const initialCols = useMemo(\n    () => getColsFromBreakpoint(initialBreakpoint, colsConfig),\n    [initialBreakpoint, colsConfig]\n  );\n\n  // State\n  const [breakpoint, setBreakpoint] = useState<B>(initialBreakpoint);\n  const [cols, setCols] = useState<number>(initialCols);\n  const [layouts, setLayoutsState] = useState<ResponsiveLayouts<B>>(() => {\n    // Clone initial layouts\n    const cloned = {} as ResponsiveLayouts<B>;\n    for (const bp of sortedBreakpoints) {\n      const layout = propsLayouts[bp];\n      if (layout) {\n        (cloned as Record<B, Layout>)[bp] = cloneLayout(layout);\n      }\n    }\n    return cloned;\n  });\n\n  // Track previous values for change detection\n  const prevWidthRef = useRef(width);\n  const prevBreakpointRef = useRef(breakpoint);\n  // Separate refs for props vs state to prevent infinite loops (#2202)\n  // When using inline objects for layouts prop, we need to compare props to props\n  // and state to state, not mix them up.\n  const prevPropsLayoutsRef = useRef(propsLayouts);\n  const prevLayoutsRef = useRef(layouts);\n\n  // Current layout for the active breakpoint - use compactor (#2213)\n  const layout = useMemo(() => {\n    return findOrGenerateResponsiveLayout(\n      layouts,\n      breakpoints,\n      breakpoint,\n      prevBreakpointRef.current,\n      cols,\n      compactor\n    );\n  }, [layouts, breakpoints, breakpoint, cols, compactor]);\n\n  // Set layout for a specific breakpoint\n  const setLayoutForBreakpoint = useCallback((bp: B, newLayout: Layout) => {\n    setLayoutsState((prev: ResponsiveLayouts<B>) => ({\n      ...prev,\n      [bp]: cloneLayout(newLayout)\n    }));\n  }, []);\n\n  // Set all layouts\n  const setLayouts = useCallback((newLayouts: ResponsiveLayouts<B>) => {\n    const cloned = {} as ResponsiveLayouts<B>;\n    for (const bp of Object.keys(newLayouts) as B[]) {\n      const layoutForBp = newLayouts[bp];\n      if (layoutForBp) {\n        (cloned as Record<B, Layout>)[bp] = cloneLayout(layoutForBp);\n      }\n    }\n    setLayoutsState(cloned);\n  }, []);\n\n  // Handle width changes\n  useEffect(() => {\n    if (prevWidthRef.current === width) return;\n    prevWidthRef.current = width;\n\n    // Determine new breakpoint\n    const newBreakpoint = getBreakpointFromWidth(breakpoints, width);\n    const newCols = getColsFromBreakpoint(newBreakpoint, colsConfig);\n\n    // Notify width change\n    onWidthChange?.(width, [10, 10], newCols, null);\n\n    // Check if breakpoint changed\n    if (newBreakpoint !== breakpoint) {\n      // Generate layout for new breakpoint\n      // Use compactor (#2213)\n      const newLayout = findOrGenerateResponsiveLayout(\n        layouts,\n        breakpoints,\n        newBreakpoint,\n        breakpoint,\n        newCols,\n        compactor\n      );\n\n      // Update layouts with the new breakpoint layout\n      const updatedLayouts: ResponsiveLayouts<B> = {\n        ...layouts,\n        [newBreakpoint]: newLayout\n      };\n\n      setLayoutsState(updatedLayouts);\n      setBreakpoint(newBreakpoint);\n      setCols(newCols);\n\n      // Notify breakpoint change\n      onBreakpointChange?.(newBreakpoint, newCols);\n\n      prevBreakpointRef.current = newBreakpoint;\n    }\n  }, [\n    width,\n    breakpoints,\n    colsConfig,\n    breakpoint,\n    layouts,\n    compactor,\n    onBreakpointChange,\n    onWidthChange\n  ]);\n\n  // Sync with prop layouts when they change\n  useEffect(() => {\n    if (!deepEqual(propsLayouts, prevPropsLayoutsRef.current)) {\n      setLayouts(propsLayouts);\n      prevPropsLayoutsRef.current = propsLayouts;\n    }\n  }, [propsLayouts, setLayouts]);\n\n  // Notify layout changes\n  useEffect(() => {\n    if (!deepEqual(layouts, prevLayoutsRef.current)) {\n      prevLayoutsRef.current = layouts;\n      onLayoutChange?.(layout, layouts);\n    }\n  }, [layout, layouts, onLayoutChange]);\n\n  return {\n    layout,\n    layouts,\n    breakpoint,\n    cols,\n    setLayoutForBreakpoint,\n    setLayouts,\n    sortedBreakpoints\n  };\n}\n\nexport default useResponsiveLayout;\n", "/**\n * GridItem component\n *\n * An individual item within a grid layout. Handles dragging and resizing.\n */\n\nimport React, {\n  useRef,\n  useState,\n  useCallback,\n  useEffect,\n  useMemo,\n  type ReactElement,\n  type CSSProperties\n} from \"react\";\nimport { DraggableCore, type DraggableEventHandler } from \"react-draggable\";\nimport { Resizable } from \"react-resizable\";\nimport clsx from \"clsx\";\n\nimport type {\n  Position,\n  DroppingPosition,\n  ResizeHandleAxis,\n  GridDragEvent,\n  GridResizeEvent,\n  LayoutConstraint,\n  ConstraintContext,\n  Layout,\n  LayoutItem as LayoutItemType,\n  PositionStrategy\n} from \"../../core/types.js\";\nimport type { PositionParams } from \"../../core/calculate.js\";\nimport {\n  calcGridItemPosition,\n  calcGridItemWHPx,\n  calcGridColWidth,\n  calcXYRaw,\n  calcWHRaw,\n  clamp\n} from \"../../core/calculate.js\";\nimport {\n  applyPositionConstraints,\n  applySizeConstraints,\n  defaultConstraints\n} from \"../../core/constraints.js\";\nimport {\n  setTransform,\n  setTopLeft,\n  perc,\n  resizeItemInDirection\n} from \"../../core/position.js\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\ntype PartialPosition = { top: number; left: number };\n\nexport type GridItemCallback<Data extends GridDragEvent | GridResizeEvent> = (\n  i: string,\n  w: number,\n  h: number,\n  data: Data\n) => void;\n\nexport type ResizeHandle =\n  | ReactElement\n  | ((\n      resizeHandleAxis: ResizeHandleAxis,\n      ref: React.Ref<HTMLElement>\n    ) => ReactElement);\n\n// Internal callback data type with typed handle\ninterface ResizeCallbackData {\n  node: HTMLElement;\n  size: { width: number; height: number };\n  handle: ResizeHandleAxis;\n}\n\n// react-resizable callback type (handle is string)\ntype ReactResizableCallback = (\n  e: React.SyntheticEvent,\n  data: {\n    node: HTMLElement;\n    size: { width: number; height: number };\n    handle: string;\n  }\n) => void;\n\nexport interface GridItemProps {\n  /** Child element to render */\n  children: ReactElement;\n  /** Number of columns in the grid */\n  cols: number;\n  /** Width of the container in pixels */\n  containerWidth: number;\n  /** Margin between items [x, y] */\n  margin: readonly [number, number];\n  /** Padding inside the container [x, y] */\n  containerPadding: readonly [number, number];\n  /** Height of each row in pixels */\n  rowHeight: number;\n  /** Maximum number of rows */\n  maxRows: number;\n  /** Whether the item can be dragged */\n  isDraggable: boolean;\n  /** Whether the item can be resized */\n  isResizable: boolean;\n  /** Whether the item is bounded within the container */\n  isBounded: boolean;\n  /** Whether the item is static (can't be moved/resized) */\n  static?: boolean;\n  /** Use CSS transforms instead of top/left */\n  useCSSTransforms?: boolean;\n  /** Use percentage widths for server rendering */\n  usePercentages?: boolean;\n  /** Scale factor for transforms */\n  transformScale?: number;\n  /** Position strategy for custom positioning (#2217) */\n  positionStrategy?: PositionStrategy;\n  /** Drag threshold in pixels before drag starts (#2217) */\n  dragThreshold?: number;\n  /** Current position of a dropping element */\n  droppingPosition?: DroppingPosition;\n\n  /** Additional class name */\n  className?: string;\n  /** Additional styles */\n  style?: CSSProperties;\n\n  /** CSS selector for draggable handle */\n  handle?: string;\n  /** CSS selector for cancel handle */\n  cancel?: string;\n\n  /** X position in grid units */\n  x: number;\n  /** Y position in grid units */\n  y: number;\n  /** Width in grid units */\n  w: number;\n  /** Height in grid units */\n  h: number;\n\n  /** Minimum width in grid units */\n  minW?: number;\n  /** Maximum width in grid units */\n  maxW?: number;\n  /** Minimum height in grid units */\n  minH?: number;\n  /** Maximum height in grid units */\n  maxH?: number;\n\n  /** Unique identifier */\n  i: string;\n\n  /** Which resize handles to show */\n  resizeHandles?: ResizeHandleAxis[];\n  /** Custom resize handle */\n  resizeHandle?: ResizeHandle;\n\n  /** Layout constraints for position/size limiting */\n  constraints?: LayoutConstraint[];\n\n  /** The layout item data (for per-item constraints) */\n  layoutItem?: LayoutItemType;\n\n  /** Current layout (for constraint context) */\n  layout?: Layout;\n\n  /** Called when drag starts */\n  onDragStart?: GridItemCallback<GridDragEvent>;\n  /** Called during drag */\n  onDrag?: GridItemCallback<GridDragEvent>;\n  /** Called when drag stops */\n  onDragStop?: GridItemCallback<GridDragEvent>;\n  /** Called when resize starts */\n  onResizeStart?: GridItemCallback<GridResizeEvent>;\n  /** Called during resize */\n  onResize?: GridItemCallback<GridResizeEvent>;\n  /** Called when resize stops */\n  onResizeStop?: GridItemCallback<GridResizeEvent>;\n}\n\n// ============================================================================\n// Component\n// ============================================================================\n\n/**\n * GridItem - An individual item within a grid layout.\n *\n * Wraps a child element with drag and resize functionality.\n */\nexport function GridItem(props: GridItemProps): ReactElement {\n  const {\n    children,\n    cols,\n    containerWidth,\n    margin,\n    containerPadding,\n    rowHeight,\n    maxRows,\n    isDraggable,\n    isResizable,\n    isBounded,\n    static: isStatic,\n    useCSSTransforms = true,\n    usePercentages = false,\n    transformScale = 1,\n    positionStrategy,\n    dragThreshold = 0,\n    droppingPosition,\n    className = \"\",\n    style,\n    handle = \"\",\n    cancel = \"\",\n    x,\n    y,\n    w,\n    h,\n    minW = 1,\n    maxW = Infinity,\n    minH = 1,\n    maxH = Infinity,\n    i,\n    resizeHandles,\n    resizeHandle,\n    constraints = defaultConstraints,\n    layoutItem,\n    layout = [],\n    onDragStart: onDragStartProp,\n    onDrag: onDragProp,\n    onDragStop: onDragStopProp,\n    onResizeStart: onResizeStartProp,\n    onResize: onResizeProp,\n    onResizeStop: onResizeStopProp\n  } = props;\n\n  // State\n  const [dragging, setDragging] = useState(false);\n  const [resizing, setResizing] = useState(false);\n\n  // Refs for position tracking (avoid state for React 18 batching)\n  const elementRef = useRef<HTMLDivElement>(null);\n  const dragPositionRef = useRef<PartialPosition>({ left: 0, top: 0 });\n  const resizePositionRef = useRef<Position>({\n    top: 0,\n    left: 0,\n    width: 0,\n    height: 0\n  });\n\n  // Previous dropping position for comparison\n  const prevDroppingPositionRef = useRef<DroppingPosition | undefined>(\n    undefined\n  );\n\n  // Ref to current layout - Critical for preventing infinite update loops (#2210).\n  // The dropping item effect depends on onDrag, which needs layout for constraints.\n  // If we included layout directly, onDrag would be recreated on every layout change,\n  // causing the effect to re-run and update layout again, creating an infinite loop.\n  const layoutRef = useRef<Layout>(layout);\n  layoutRef.current = layout;\n\n  // Refs to callbacks for use in dropping item effect (#2210).\n  // The dropping item effect must NOT depend on onDragStart/onDrag callbacks because:\n  // 1. When dragging state changes, onDrag callback is recreated\n  // 2. When layout changes, effectiveLayoutItem changes, causing callbacks to recreate\n  // Using refs allows us to call the latest callback without the effect re-running.\n  const onDragStartRef = useRef<DraggableEventHandler | null>(null);\n  const onDragRef = useRef<DraggableEventHandler | null>(null);\n\n  // Drag threshold tracking (#2217)\n  // Tracks whether we're waiting to exceed the threshold before starting the drag\n  const dragPendingRef = useRef(false);\n  const initialDragClientRef = useRef<{ x: number; y: number }>({ x: 0, y: 0 });\n  const thresholdExceededRef = useRef(false);\n\n  // Position parameters\n  const positionParams: PositionParams = useMemo(\n    () => ({\n      cols,\n      containerPadding: containerPadding as [number, number],\n      containerWidth,\n      margin: margin as [number, number],\n      maxRows,\n      rowHeight\n    }),\n    [cols, containerPadding, containerWidth, margin, maxRows, rowHeight]\n  );\n\n  // Constraint context for applying constraints\n  // Note: This does NOT include layout in its dependencies to prevent infinite loops (#2210).\n  // The layout is accessed via layoutRef.current inside the callbacks that use this context.\n  const constraintContext: ConstraintContext = useMemo(\n    () => ({\n      cols,\n      maxRows,\n      containerWidth,\n      containerHeight: 0, // Auto-height grids don't have a fixed container height\n      rowHeight,\n      margin,\n      // Use empty layout here - the actual layout will be accessed via layoutRef when needed\n      // This prevents the context from changing when layout changes, avoiding callback recreation\n      layout: []\n    }),\n    [cols, maxRows, containerWidth, rowHeight, margin]\n  );\n\n  // Create a getter for constraint context with current layout\n  // This is called inside callbacks to get fresh layout data without causing re-renders\n  const getConstraintContext = useCallback(\n    (): ConstraintContext => ({\n      ...constraintContext,\n      layout: layoutRef.current\n    }),\n    [constraintContext]\n  );\n\n  // Effective layout item (use provided or create from props)\n  const effectiveLayoutItem: LayoutItemType = useMemo(\n    () =>\n      layoutItem ?? {\n        i,\n        x,\n        y,\n        w,\n        h,\n        minW,\n        maxW,\n        minH,\n        maxH\n      },\n    [layoutItem, i, x, y, w, h, minW, maxW, minH, maxH]\n  );\n\n  // ============================================================================\n  // Style Creation\n  // ============================================================================\n\n  const createStyle = useCallback(\n    (pos: Position): CSSProperties => {\n      // Use custom positionStrategy.calcStyle() if provided (#2217)\n      if (positionStrategy?.calcStyle) {\n        return positionStrategy.calcStyle(pos);\n      }\n\n      // Default positioning based on useCSSTransforms\n      if (useCSSTransforms) {\n        return setTransform(pos) as CSSProperties;\n      }\n\n      const styleObj = setTopLeft(pos) as CSSProperties;\n\n      if (usePercentages) {\n        return {\n          ...styleObj,\n          left: perc(pos.left / containerWidth),\n          width: perc(pos.width / containerWidth)\n        };\n      }\n\n      return styleObj;\n    },\n    [positionStrategy, useCSSTransforms, usePercentages, containerWidth]\n  );\n\n  // ============================================================================\n  // Drag Handlers\n  // ============================================================================\n\n  const onDragStart: DraggableEventHandler = useCallback(\n    (e, { node }) => {\n      if (!onDragStartProp) return;\n\n      const { offsetParent } = node;\n      if (!offsetParent) return;\n\n      const parentRect = offsetParent.getBoundingClientRect();\n      const clientRect = node.getBoundingClientRect();\n\n      const cLeft = clientRect.left / transformScale;\n      const pLeft = parentRect.left / transformScale;\n      const cTop = clientRect.top / transformScale;\n      const pTop = parentRect.top / transformScale;\n\n      // Use custom positionStrategy.calcDragPosition() if provided (#2217)\n      let newPosition: PartialPosition;\n      if (positionStrategy?.calcDragPosition) {\n        const mouseEvent = e as unknown as MouseEvent;\n        newPosition = positionStrategy.calcDragPosition(\n          mouseEvent.clientX,\n          mouseEvent.clientY,\n          mouseEvent.clientX - clientRect.left,\n          mouseEvent.clientY - clientRect.top\n        );\n      } else {\n        newPosition = {\n          left: cLeft - pLeft + offsetParent.scrollLeft,\n          top: cTop - pTop + offsetParent.scrollTop\n        };\n      }\n\n      dragPositionRef.current = newPosition;\n\n      // Threshold support (#2217) - if threshold is set, delay calling onDragStartProp\n      // until the mouse has moved at least `dragThreshold` pixels\n      if (dragThreshold > 0) {\n        const mouseEvent = e as unknown as MouseEvent;\n        initialDragClientRef.current = {\n          x: mouseEvent.clientX,\n          y: mouseEvent.clientY\n        };\n        dragPendingRef.current = true;\n        thresholdExceededRef.current = false;\n        setDragging(true);\n        return; // Don't call onDragStartProp yet\n      }\n\n      setDragging(true);\n\n      // Calculate raw position and apply constraints\n      const rawPos = calcXYRaw(\n        positionParams,\n        newPosition.top,\n        newPosition.left\n      );\n      const { x: newX, y: newY } = applyPositionConstraints(\n        constraints,\n        effectiveLayoutItem,\n        rawPos.x,\n        rawPos.y,\n        getConstraintContext()\n      );\n\n      onDragStartProp(i, newX, newY, {\n        e: e as unknown as Event,\n        node,\n        newPosition\n      });\n    },\n    [\n      onDragStartProp,\n      transformScale,\n      positionParams,\n      positionStrategy,\n      dragThreshold,\n      constraints,\n      effectiveLayoutItem,\n      getConstraintContext,\n      i\n    ]\n  );\n\n  const onDrag: DraggableEventHandler = useCallback(\n    (e, { node, deltaX, deltaY }) => {\n      if (!onDragProp || !dragging) return;\n\n      const mouseEvent = e as unknown as MouseEvent;\n\n      // Threshold support (#2217) - check if we've exceeded the threshold\n      if (dragPendingRef.current && !thresholdExceededRef.current) {\n        const dx = mouseEvent.clientX - initialDragClientRef.current.x;\n        const dy = mouseEvent.clientY - initialDragClientRef.current.y;\n        const distance = Math.hypot(dx, dy);\n\n        if (distance < dragThreshold) {\n          // Haven't exceeded threshold yet, don't trigger drag\n          return;\n        }\n\n        // Threshold exceeded! Call onDragStartProp first, then continue with onDrag\n        thresholdExceededRef.current = true;\n        dragPendingRef.current = false;\n\n        // Call onDragStartProp now that threshold is exceeded\n        if (onDragStartProp) {\n          const rawPos = calcXYRaw(\n            positionParams,\n            dragPositionRef.current.top,\n            dragPositionRef.current.left\n          );\n          const { x: startX, y: startY } = applyPositionConstraints(\n            constraints,\n            effectiveLayoutItem,\n            rawPos.x,\n            rawPos.y,\n            getConstraintContext()\n          );\n          onDragStartProp(i, startX, startY, {\n            e: e as unknown as Event,\n            node,\n            newPosition: dragPositionRef.current\n          });\n        }\n      }\n\n      let top = dragPositionRef.current.top + deltaY;\n      let left = dragPositionRef.current.left + deltaX;\n\n      // Pixel-level boundary calculations (isBounded affects pixel position)\n      if (isBounded) {\n        const { offsetParent } = node;\n        if (offsetParent) {\n          const bottomBoundary =\n            offsetParent.clientHeight -\n            calcGridItemWHPx(h, rowHeight, margin[1]);\n          top = clamp(top, 0, bottomBoundary);\n\n          const colWidth = calcGridColWidth(positionParams);\n          const rightBoundary =\n            containerWidth - calcGridItemWHPx(w, colWidth, margin[0]);\n          left = clamp(left, 0, rightBoundary);\n        }\n      }\n\n      const newPosition: PartialPosition = { top, left };\n      dragPositionRef.current = newPosition;\n\n      // Calculate raw position and apply constraints\n      const rawPos = calcXYRaw(positionParams, top, left);\n      const { x: newX, y: newY } = applyPositionConstraints(\n        constraints,\n        effectiveLayoutItem,\n        rawPos.x,\n        rawPos.y,\n        getConstraintContext()\n      );\n\n      onDragProp(i, newX, newY, {\n        e: e as unknown as Event,\n        node,\n        newPosition\n      });\n    },\n    [\n      onDragProp,\n      onDragStartProp,\n      dragging,\n      dragThreshold,\n      isBounded,\n      h,\n      rowHeight,\n      margin,\n      positionParams,\n      containerWidth,\n      w,\n      i,\n      constraints,\n      effectiveLayoutItem,\n      getConstraintContext\n    ]\n  );\n\n  const onDragStop: DraggableEventHandler = useCallback(\n    (e, { node }) => {\n      if (!onDragStopProp || !dragging) return;\n\n      // Reset threshold tracking (#2217)\n      const wasPending = dragPendingRef.current;\n      dragPendingRef.current = false;\n      thresholdExceededRef.current = false;\n      initialDragClientRef.current = { x: 0, y: 0 };\n\n      // If threshold was never exceeded, don't call onDragStopProp\n      // since onDragStartProp was never called\n      if (wasPending) {\n        setDragging(false);\n        dragPositionRef.current = { left: 0, top: 0 };\n        return;\n      }\n\n      const { left, top } = dragPositionRef.current;\n      const newPosition: PartialPosition = { top, left };\n\n      setDragging(false);\n      dragPositionRef.current = { left: 0, top: 0 };\n\n      // Calculate raw position and apply constraints\n      const rawPos = calcXYRaw(positionParams, top, left);\n      const { x: newX, y: newY } = applyPositionConstraints(\n        constraints,\n        effectiveLayoutItem,\n        rawPos.x,\n        rawPos.y,\n        getConstraintContext()\n      );\n\n      onDragStopProp(i, newX, newY, {\n        e: e as unknown as Event,\n        node,\n        newPosition\n      });\n    },\n    [\n      onDragStopProp,\n      dragging,\n      positionParams,\n      constraints,\n      effectiveLayoutItem,\n      getConstraintContext,\n      i\n    ]\n  );\n\n  // Update callback refs for use in dropping item effect (#2210)\n  onDragStartRef.current = onDragStart;\n  onDragRef.current = onDrag;\n\n  // ============================================================================\n  // Resize Handlers\n  // ============================================================================\n\n  const onResizeHandler = useCallback(\n    (\n      e: React.SyntheticEvent,\n      { node, size, handle: resizeHandle }: ResizeCallbackData,\n      position: Position,\n      handlerName: \"onResizeStart\" | \"onResize\" | \"onResizeStop\"\n    ) => {\n      const handler =\n        handlerName === \"onResizeStart\"\n          ? onResizeStartProp\n          : handlerName === \"onResize\"\n            ? onResizeProp\n            : onResizeStopProp;\n\n      if (!handler) return;\n\n      // Sizing based on resize direction\n      let updatedSize: Position;\n      if (node) {\n        updatedSize = resizeItemInDirection(\n          resizeHandle,\n          position,\n          size as Position,\n          containerWidth\n        );\n      } else {\n        updatedSize = {\n          ...size,\n          top: position.top,\n          left: position.left\n        } as Position;\n      }\n\n      resizePositionRef.current = updatedSize;\n\n      // Calculate raw grid dimensions and apply constraints\n      const rawSize = calcWHRaw(\n        positionParams,\n        updatedSize.width,\n        updatedSize.height\n      );\n      const { w: newW, h: newH } = applySizeConstraints(\n        constraints,\n        effectiveLayoutItem,\n        rawSize.w,\n        rawSize.h,\n        resizeHandle,\n        getConstraintContext()\n      );\n\n      handler(i, newW, newH, {\n        e: e.nativeEvent,\n        node,\n        size: updatedSize,\n        handle: resizeHandle\n      });\n    },\n    [\n      onResizeStartProp,\n      onResizeProp,\n      onResizeStopProp,\n      containerWidth,\n      positionParams,\n      i,\n      constraints,\n      effectiveLayoutItem,\n      getConstraintContext\n    ]\n  );\n\n  const handleResizeStart: ReactResizableCallback = useCallback(\n    (e, data) => {\n      setResizing(true);\n      const pos = calcGridItemPosition(positionParams, x, y, w, h);\n      const typedData: ResizeCallbackData = {\n        ...data,\n        handle: data.handle as ResizeHandleAxis\n      };\n      onResizeHandler(e, typedData, pos, \"onResizeStart\");\n    },\n    [onResizeHandler, positionParams, x, y, w, h]\n  );\n\n  const handleResize: ReactResizableCallback = useCallback(\n    (e, data) => {\n      const pos = calcGridItemPosition(positionParams, x, y, w, h);\n      const typedData: ResizeCallbackData = {\n        ...data,\n        handle: data.handle as ResizeHandleAxis\n      };\n      onResizeHandler(e, typedData, pos, \"onResize\");\n    },\n    [onResizeHandler, positionParams, x, y, w, h]\n  );\n\n  const handleResizeStop: ReactResizableCallback = useCallback(\n    (e, data) => {\n      setResizing(false);\n      resizePositionRef.current = { top: 0, left: 0, width: 0, height: 0 };\n      const pos = calcGridItemPosition(positionParams, x, y, w, h);\n      const typedData: ResizeCallbackData = {\n        ...data,\n        handle: data.handle as ResizeHandleAxis\n      };\n      onResizeHandler(e, typedData, pos, \"onResizeStop\");\n    },\n    [onResizeHandler, positionParams, x, y, w, h]\n  );\n\n  // ============================================================================\n  // Dropping Item Support\n  // ============================================================================\n\n  // Dropping Item Support - uses refs to avoid callback dependency changes (#2210)\n  // The effect only depends on droppingPosition and dragging state.\n  // Callbacks are accessed via refs to get the latest version without triggering re-runs.\n  useEffect(() => {\n    if (!droppingPosition) return;\n\n    const node = elementRef.current;\n    if (!node) return;\n\n    const prevDroppingPosition = prevDroppingPositionRef.current || {\n      left: 0,\n      top: 0\n    };\n\n    const shouldDrag =\n      dragging &&\n      (droppingPosition.left !== prevDroppingPosition.left ||\n        droppingPosition.top !== prevDroppingPosition.top);\n\n    if (!dragging) {\n      // Start drag - simulate the draggable callback data\n      const fakeData = {\n        node,\n        deltaX: droppingPosition.left,\n        deltaY: droppingPosition.top,\n        lastX: 0,\n        lastY: 0,\n        x: droppingPosition.left,\n        y: droppingPosition.top\n      };\n      // Use ref to get latest callback without dependency\n      onDragStartRef.current?.(\n        droppingPosition.e as unknown as MouseEvent,\n        fakeData\n      );\n    } else if (shouldDrag) {\n      // Continue drag\n      const deltaX = droppingPosition.left - dragPositionRef.current.left;\n      const deltaY = droppingPosition.top - dragPositionRef.current.top;\n\n      const fakeData = {\n        node,\n        deltaX,\n        deltaY,\n        lastX: dragPositionRef.current.left,\n        lastY: dragPositionRef.current.top,\n        x: droppingPosition.left,\n        y: droppingPosition.top\n      };\n      // Use ref to get latest callback without dependency\n      onDragRef.current?.(\n        droppingPosition.e as unknown as MouseEvent,\n        fakeData\n      );\n    }\n\n    prevDroppingPositionRef.current = droppingPosition;\n  }, [droppingPosition, dragging, i]);\n\n  // ============================================================================\n  // Render\n  // ============================================================================\n\n  const pos = calcGridItemPosition(\n    positionParams,\n    x,\n    y,\n    w,\n    h,\n    dragging ? dragPositionRef.current : null,\n    resizing ? resizePositionRef.current : null\n  );\n\n  const child = React.Children.only(children);\n\n  // Calculate constraints for resizing\n  // Note: We use wide-open constraints for react-resizable and let our pluggable\n  // constraint system handle the actual limits. This allows constraints to be\n  // fully controllable via the constraints prop.\n  const minGridUnit = calcGridItemPosition(positionParams, 0, 0, 1, 1);\n  const minConstraints: [number, number] = [\n    minGridUnit.width,\n    minGridUnit.height\n  ];\n  const maxConstraints: [number, number] = [Infinity, Infinity];\n\n  // Get child props safely\n  const childProps = (child as ReactElement<Record<string, unknown>>).props;\n  const childClassName = childProps[\"className\"] as string | undefined;\n  const childStyle = childProps[\"style\"] as CSSProperties | undefined;\n\n  // Create the child element with updated props\n  let newChild: ReactElement = React.cloneElement(child, {\n    ref: elementRef,\n    className: clsx(\"react-grid-item\", childClassName, className, {\n      static: isStatic,\n      resizing,\n      \"react-draggable\": isDraggable,\n      \"react-draggable-dragging\": dragging,\n      dropping: Boolean(droppingPosition),\n      cssTransforms: useCSSTransforms\n    }),\n    style: {\n      ...style,\n      ...childStyle,\n      ...createStyle(pos)\n    }\n  } as Record<string, unknown>);\n\n  // Wrap with Resizable\n  // Cast resizeHandle to match react-resizable's expected type (string instead of ResizeHandleAxis)\n  const resizableHandle = resizeHandle as\n    | ReactElement\n    | ((axis: string, ref: React.Ref<HTMLElement>) => ReactElement)\n    | undefined;\n\n  newChild = (\n    <Resizable\n      draggableOpts={{ disabled: !isResizable }}\n      className={isResizable ? undefined : \"react-resizable-hide\"}\n      width={pos.width}\n      height={pos.height}\n      minConstraints={minConstraints}\n      maxConstraints={maxConstraints}\n      onResizeStart={handleResizeStart}\n      onResize={handleResize}\n      onResizeStop={handleResizeStop}\n      transformScale={transformScale}\n      resizeHandles={resizeHandles}\n      handle={resizableHandle}\n    >\n      {newChild}\n    </Resizable>\n  );\n\n  // Wrap with DraggableCore\n  newChild = (\n    <DraggableCore\n      disabled={!isDraggable}\n      onStart={onDragStart}\n      onDrag={onDrag}\n      onStop={onDragStop}\n      handle={handle}\n      cancel={\".react-resizable-handle\" + (cancel ? \",\" + cancel : \"\")}\n      scale={transformScale}\n      nodeRef={elementRef}\n    >\n      {newChild}\n    </DraggableCore>\n  );\n\n  return newChild;\n}\n\nexport default GridItem;\n", "/**\n * GridLayout component\n *\n * A reactive, fluid grid layout with draggable, resizable components.\n */\n\nimport React, {\n  useState,\n  useCallback,\n  useEffect,\n  useRef,\n  useMemo,\n  type ReactElement,\n  type CSSProperties,\n  type DragEvent as ReactDragEvent\n} from \"react\";\nimport { deepEqual } from \"fast-equals\";\nimport clsx from \"clsx\";\n\nimport type {\n  Layout,\n  LayoutItem,\n  CompactType,\n  DroppingPosition,\n  GridDragEvent,\n  GridResizeEvent,\n  Mutable,\n  GridConfig,\n  DragConfig,\n  ResizeConfig,\n  DropConfig,\n  PositionStrategy,\n  Compactor,\n  LayoutConstraint\n} from \"../../core/types.js\";\nimport {\n  defaultGridConfig,\n  defaultDragConfig,\n  defaultResizeConfig,\n  defaultDropConfig\n} from \"../../core/types.js\";\nimport type { PositionParams } from \"../../core/calculate.js\";\nimport {\n  bottom,\n  cloneLayoutItem,\n  getLayoutItem,\n  moveElement,\n  withLayoutItem,\n  correctBounds\n} from \"../../core/layout.js\";\nimport { getAllCollisions } from \"../../core/collision.js\";\n// Note: compact from compact-compat.js is NOT used - we use compactor.compact() instead (#2213)\nimport { getCompactor } from \"../../core/compactors.js\";\nimport {\n  calcXY,\n  calcGridColWidth,\n  calcGridItemWHPx\n} from \"../../core/calculate.js\";\nimport { defaultPositionStrategy } from \"../../core/position.js\";\nimport { defaultConstraints } from \"../../core/constraints.js\";\n\nimport { GridItem, type ResizeHandle } from \"./GridItem.js\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport type EventCallback = (\n  layout: Layout,\n  oldItem: LayoutItem | null,\n  newItem: LayoutItem | null,\n  placeholder: LayoutItem | null,\n  event: Event,\n  element?: HTMLElement\n) => void;\n\nexport interface GridLayoutProps {\n  // ===========================================================================\n  // Required Props\n  // ===========================================================================\n\n  /** Child elements to render in the grid */\n  children: React.ReactNode;\n\n  /** Width of the container in pixels */\n  width: number;\n\n  // ===========================================================================\n  // Composable Configuration Interfaces (v2 API)\n  // ===========================================================================\n\n  /**\n   * Grid measurement configuration.\n   * @see GridConfig\n   */\n  gridConfig?: Partial<GridConfig>;\n\n  /**\n   * Drag behavior configuration.\n   * @see DragConfig\n   */\n  dragConfig?: Partial<DragConfig>;\n\n  /**\n   * Resize behavior configuration.\n   * @see ResizeConfig\n   */\n  resizeConfig?: Partial<ResizeConfig>;\n\n  /**\n   * External drop configuration.\n   * @see DropConfig\n   */\n  dropConfig?: Partial<DropConfig>;\n\n  /**\n   * CSS positioning strategy.\n   * Use transformStrategy (default), absoluteStrategy, or createScaledStrategy(scale).\n   * @see PositionStrategy\n   */\n  positionStrategy?: PositionStrategy;\n\n  /**\n   * Layout compaction strategy.\n   * Use verticalCompactor (default), horizontalCompactor, or noCompactor.\n   * @see Compactor\n   */\n  compactor?: Compactor;\n\n  /**\n   * Layout constraints for position and size limiting.\n   * Applied during drag/resize operations.\n   * Default: [gridBounds, minMaxSize]\n   * @see LayoutConstraint\n   */\n  constraints?: LayoutConstraint[];\n\n  // ===========================================================================\n  // Layout Data\n  // ===========================================================================\n\n  /** Layout definition */\n  layout?: Layout;\n\n  /** Item to use when dropping from outside */\n  droppingItem?: LayoutItem;\n\n  // ===========================================================================\n  // Container Props\n  // ===========================================================================\n\n  /** Whether to auto-size the container height */\n  autoSize?: boolean;\n\n  /** Additional class name */\n  className?: string;\n\n  /** Additional styles */\n  style?: CSSProperties;\n\n  /** Ref to the container element */\n  innerRef?: React.Ref<HTMLDivElement>;\n\n  // ===========================================================================\n  // Callbacks\n  // ===========================================================================\n\n  /** Called when layout changes */\n  onLayoutChange?: (layout: Layout) => void;\n\n  /** Called when drag starts */\n  onDragStart?: EventCallback;\n\n  /** Called during drag */\n  onDrag?: EventCallback;\n\n  /** Called when drag stops */\n  onDragStop?: EventCallback;\n\n  /** Called when resize starts */\n  onResizeStart?: EventCallback;\n\n  /** Called during resize */\n  onResize?: EventCallback;\n\n  /** Called when resize stops */\n  onResizeStop?: EventCallback;\n\n  /** Called when an item is dropped from outside */\n  onDrop?: (layout: Layout, item: LayoutItem | undefined, e: Event) => void;\n\n  /** Called when dragging over the grid */\n  onDropDragOver?: (\n    e: ReactDragEvent\n  ) =>\n    | { w?: number; h?: number; dragOffsetX?: number; dragOffsetY?: number }\n    | false\n    | void;\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\nconst noop = () => {};\n\nconst layoutClassName = \"react-grid-layout\";\n\n// Check for Firefox\nlet isFirefox = false;\ntry {\n  isFirefox = /firefox/i.test(navigator.userAgent);\n} catch {\n  /* Ignore */\n}\n\n/**\n * Compare children arrays for equality\n */\nfunction childrenEqual(a: React.ReactNode, b: React.ReactNode): boolean {\n  const aArr = React.Children.toArray(a);\n  const bArr = React.Children.toArray(b);\n\n  if (aArr.length !== bArr.length) return false;\n\n  for (let i = 0; i < aArr.length; i++) {\n    const aChild = aArr[i] as ReactElement;\n    const bChild = bArr[i] as ReactElement;\n    if (aChild?.key !== bChild?.key) return false;\n  }\n\n  return true;\n}\n\n/**\n * Synchronize layout with children\n */\nfunction synchronizeLayoutWithChildren(\n  initialLayout: Layout,\n  children: React.ReactNode,\n  cols: number,\n  compactor: Compactor\n): Layout {\n  const layout: LayoutItem[] = [];\n  const childKeys = new Set<string>();\n\n  React.Children.forEach(children, child => {\n    if (!React.isValidElement(child) || child.key === null) return;\n    const key = String(child.key);\n    childKeys.add(key);\n\n    // Find existing layout item\n    const existingItem = initialLayout.find(l => l.i === key);\n\n    if (existingItem) {\n      layout.push(cloneLayoutItem(existingItem));\n    } else {\n      // Create new layout item from child data-grid prop\n      const childProps = child.props as { \"data-grid\"?: Partial<LayoutItem> };\n      const dataGrid = childProps[\"data-grid\"];\n\n      if (dataGrid) {\n        layout.push({\n          i: key,\n          x: dataGrid.x ?? 0,\n          y: dataGrid.y ?? 0,\n          w: dataGrid.w ?? 1,\n          h: dataGrid.h ?? 1,\n          minW: dataGrid.minW,\n          maxW: dataGrid.maxW,\n          minH: dataGrid.minH,\n          maxH: dataGrid.maxH,\n          static: dataGrid.static,\n          isDraggable: dataGrid.isDraggable,\n          isResizable: dataGrid.isResizable,\n          resizeHandles: dataGrid.resizeHandles,\n          isBounded: dataGrid.isBounded\n        });\n      } else {\n        // Create default layout item\n        layout.push({\n          i: key,\n          x: 0,\n          y: bottom(layout),\n          w: 1,\n          h: 1\n        });\n      }\n    }\n  });\n\n  // Correct bounds and compact using the compactor's compact method (#2213)\n  const corrected = correctBounds(layout, { cols });\n  return compactor.compact(corrected, cols);\n}\n\n// ============================================================================\n// Component\n// ============================================================================\n\n/**\n * GridLayout - A reactive, fluid grid layout with draggable, resizable components.\n */\nexport function GridLayout(props: GridLayoutProps): ReactElement {\n  const {\n    // Required\n    children,\n    width,\n\n    // Composable config interfaces\n    gridConfig: gridConfigProp,\n    dragConfig: dragConfigProp,\n    resizeConfig: resizeConfigProp,\n    dropConfig: dropConfigProp,\n    positionStrategy = defaultPositionStrategy,\n    compactor: compactorProp,\n    constraints = defaultConstraints,\n\n    // Layout data\n    layout: propsLayout = [],\n    droppingItem: droppingItemProp,\n\n    // Container props\n    autoSize = true,\n    className = \"\",\n    style = {},\n    innerRef,\n\n    // Callbacks\n    onLayoutChange = noop,\n    onDragStart: onDragStartProp = noop,\n    onDrag: onDragProp = noop,\n    onDragStop: onDragStopProp = noop,\n    onResizeStart: onResizeStartProp = noop,\n    onResize: onResizeProp = noop,\n    onResizeStop: onResizeStopProp = noop,\n    onDrop: onDropProp = noop,\n    onDropDragOver: onDropDragOverProp = noop\n  } = props;\n\n  // Resolve config interfaces with defaults\n  const gridConfig: GridConfig = useMemo(\n    () => ({ ...defaultGridConfig, ...gridConfigProp }),\n    [gridConfigProp]\n  );\n  const dragConfig: DragConfig = useMemo(\n    () => ({ ...defaultDragConfig, ...dragConfigProp }),\n    [dragConfigProp]\n  );\n  const resizeConfig: ResizeConfig = useMemo(\n    () => ({ ...defaultResizeConfig, ...resizeConfigProp }),\n    [resizeConfigProp]\n  );\n  const dropConfig: DropConfig = useMemo(\n    () => ({ ...defaultDropConfig, ...dropConfigProp }),\n    [dropConfigProp]\n  );\n\n  // Destructure resolved configs for convenience\n  const { cols, rowHeight, maxRows, margin, containerPadding } = gridConfig;\n  const {\n    enabled: isDraggable,\n    bounded: isBounded,\n    handle: draggableHandle,\n    cancel: draggableCancel,\n    threshold: dragThreshold\n  } = dragConfig;\n  const {\n    enabled: isResizable,\n    handles: resizeHandles,\n    handleComponent: resizeHandle\n  } = resizeConfig;\n  const {\n    enabled: isDroppable,\n    defaultItem: defaultDropItem,\n    onDragOver: dropConfigOnDragOver\n  } = dropConfig;\n\n  // Get compactor (use provided or get from type)\n  const compactor = compactorProp ?? getCompactor(\"vertical\");\n  const compactType = compactor.type;\n  const allowOverlap = compactor.allowOverlap;\n  const preventCollision = compactor.preventCollision ?? false;\n\n  // Resolve dropping item - memoized to avoid unstable reference in useCallback dependencies\n  const droppingItem = useMemo(\n    () =>\n      droppingItemProp ?? {\n        i: \"__dropping-elem__\",\n        ...defaultDropItem\n      },\n    [droppingItemProp, defaultDropItem]\n  );\n\n  // Position strategy values\n  const useCSSTransforms = positionStrategy.type === \"transform\";\n  const transformScale = positionStrategy.scale;\n\n  const effectiveContainerPadding = containerPadding ?? margin;\n\n  // State\n  const [mounted, setMounted] = useState(false);\n  const [layout, setLayout] = useState<Layout>(() =>\n    synchronizeLayoutWithChildren(propsLayout, children, cols, compactor)\n  );\n  const [activeDrag, setActiveDrag] = useState<LayoutItem | null>(null);\n  const [resizing, setResizing] = useState(false);\n  const [droppingDOMNode, setDroppingDOMNode] = useState<ReactElement | null>(\n    null\n  );\n  const [droppingPosition, setDroppingPosition] = useState<\n    DroppingPosition | undefined\n  >();\n\n  // Refs for tracking previous state\n  const oldDragItemRef = useRef<LayoutItem | null>(null);\n  const oldResizeItemRef = useRef<LayoutItem | null>(null);\n  const oldLayoutRef = useRef<Layout | null>(null);\n  const dragEnterCounterRef = useRef(0);\n  const prevLayoutRef = useRef<Layout>(layout);\n  const prevPropsLayoutRef = useRef<Layout>(propsLayout);\n  const prevChildrenRef = useRef<React.ReactNode>(children);\n  const prevCompactTypeRef = useRef<CompactType>(compactType);\n\n  // Ref to current layout - Critical for preventing infinite update loops (#2204).\n  // This allows callbacks to access the latest layout without including `layout`\n  // in dependency arrays, which would cause callbacks to be recreated on every\n  // layout change and trigger infinite re-renders via GridItem's useEffect.\n  const layoutRef = useRef<Layout>(layout);\n  layoutRef.current = layout;\n\n  // Mount effect - call onLayoutChange with initial layout if it differs from props\n  useEffect(() => {\n    setMounted(true);\n    // Possibly call back with layout on mount. This should be done after correcting the layout width\n    // to ensure we don't rerender with the wrong width.\n    if (!deepEqual(layout, propsLayout)) {\n      onLayoutChange(layout);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []); // Only run on mount\n\n  // Sync layout from props\n  useEffect(() => {\n    if (activeDrag) return; // Don't update during drag\n    if (droppingDOMNode) return; // Don't update during drop from outside\n\n    const layoutChanged = !deepEqual(propsLayout, prevPropsLayoutRef.current);\n    const childrenChanged = !childrenEqual(children, prevChildrenRef.current);\n    const compactTypeChanged = compactType !== prevCompactTypeRef.current;\n\n    if (layoutChanged || childrenChanged || compactTypeChanged) {\n      const baseLayout = layoutChanged ? propsLayout : layout;\n      const newLayout = synchronizeLayoutWithChildren(\n        baseLayout,\n        children,\n        cols,\n        compactor\n      );\n      // Only update if the layout actually changed (#2210)\n      // This prevents infinite loops when controlled state updates trigger\n      // sync effects that produce the same layout\n      if (!deepEqual(newLayout, layout)) {\n        setLayout(newLayout);\n      }\n    }\n\n    prevPropsLayoutRef.current = propsLayout;\n    prevChildrenRef.current = children;\n    prevCompactTypeRef.current = compactType;\n  }, [\n    propsLayout,\n    children,\n    cols,\n    compactType,\n    compactor,\n    activeDrag,\n    droppingDOMNode,\n    layout\n  ]);\n\n  // Layout change callback\n  useEffect(() => {\n    if (!activeDrag && !deepEqual(layout, prevLayoutRef.current)) {\n      prevLayoutRef.current = layout;\n      // Filter out dropping placeholder - it's transient internal state only (#2210)\n      // The dropping item should not be exposed to users until the actual drop happens.\n      // This prevents infinite loops in controlled state patterns where children derive\n      // from layout (e.g., children = layouts.map(...) with onLayoutChange={setLayouts}).\n      const publicLayout = layout.filter(l => l.i !== droppingItem.i);\n      onLayoutChange(publicLayout);\n    }\n  }, [layout, activeDrag, onLayoutChange, droppingItem.i]);\n\n  // ============================================================================\n  // Container Height\n  // ============================================================================\n\n  const containerHeight = useMemo((): string | undefined => {\n    if (!autoSize) return undefined;\n    const nbRow = bottom(layout);\n    const containerPaddingY = effectiveContainerPadding[1];\n    return (\n      nbRow * rowHeight + (nbRow - 1) * margin[1] + containerPaddingY * 2 + \"px\"\n    );\n  }, [autoSize, layout, rowHeight, margin, effectiveContainerPadding]);\n\n  // ============================================================================\n  // Drag Handlers\n  // ============================================================================\n\n  const onDragStart = useCallback(\n    (i: string, _x: number, _y: number, data: GridDragEvent) => {\n      const currentLayout = layoutRef.current;\n      const l = getLayoutItem(currentLayout, i);\n      if (!l) return;\n\n      const placeholder: LayoutItem = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        i\n      };\n\n      oldDragItemRef.current = cloneLayoutItem(l);\n      oldLayoutRef.current = currentLayout;\n      setActiveDrag(placeholder);\n\n      onDragStartProp(currentLayout, l, l, null, data.e, data.node);\n    },\n    [onDragStartProp]\n  );\n\n  const onDrag = useCallback(\n    (i: string, x: number, y: number, data: GridDragEvent) => {\n      const currentLayout = layoutRef.current;\n      const oldDragItem = oldDragItemRef.current;\n      const l = getLayoutItem(currentLayout, i);\n      if (!l) return;\n\n      const placeholder: LayoutItem = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        i\n      };\n\n      // Move the element\n      const newLayout = moveElement(\n        currentLayout,\n        l,\n        x,\n        y,\n        true,\n        preventCollision,\n        compactType,\n        cols,\n        allowOverlap\n      );\n\n      onDragProp(newLayout, oldDragItem, l, placeholder, data.e, data.node);\n\n      // Use compactor.compact() - it handles allowOverlap internally (#2213)\n      setLayout(compactor.compact(newLayout, cols));\n      setActiveDrag(placeholder);\n    },\n    [preventCollision, compactType, cols, allowOverlap, compactor, onDragProp]\n  );\n\n  const onDragStop = useCallback(\n    (i: string, x: number, y: number, data: GridDragEvent) => {\n      if (!activeDrag) return;\n\n      const currentLayout = layoutRef.current;\n      const oldDragItem = oldDragItemRef.current;\n      const l = getLayoutItem(currentLayout, i);\n      if (!l) return;\n\n      const newLayout = moveElement(\n        currentLayout,\n        l,\n        x,\n        y,\n        true,\n        preventCollision,\n        compactType,\n        cols,\n        allowOverlap\n      );\n\n      // Use compactor.compact() - it handles allowOverlap internally (#2213)\n      const finalLayout = compactor.compact(newLayout, cols);\n\n      onDragStopProp(finalLayout, oldDragItem, l, null, data.e, data.node);\n\n      const oldLayout = oldLayoutRef.current;\n      oldDragItemRef.current = null;\n      oldLayoutRef.current = null;\n      setActiveDrag(null);\n      setLayout(finalLayout);\n\n      if (oldLayout && !deepEqual(oldLayout, finalLayout)) {\n        onLayoutChange(finalLayout);\n      }\n    },\n    [\n      activeDrag,\n      preventCollision,\n      compactType,\n      cols,\n      allowOverlap,\n      compactor,\n      onDragStopProp,\n      onLayoutChange\n    ]\n  );\n\n  // ============================================================================\n  // Resize Handlers\n  // ============================================================================\n\n  const onResizeStart = useCallback(\n    (i: string, _w: number, _h: number, data: GridResizeEvent) => {\n      const currentLayout = layoutRef.current;\n      const l = getLayoutItem(currentLayout, i);\n      if (!l) return;\n\n      oldResizeItemRef.current = cloneLayoutItem(l);\n      oldLayoutRef.current = currentLayout;\n      setResizing(true);\n\n      onResizeStartProp(currentLayout, l, l, null, data.e, data.node);\n    },\n    [onResizeStartProp]\n  );\n\n  const onResize = useCallback(\n    (i: string, w: number, h: number, data: GridResizeEvent) => {\n      const currentLayout = layoutRef.current;\n      const oldResizeItem = oldResizeItemRef.current;\n      const { handle } = data;\n\n      let shouldMoveItem = false;\n      let newX: number | undefined;\n      let newY: number | undefined;\n\n      const [newLayout, l] = withLayoutItem(currentLayout, i, item => {\n        newX = item.x;\n        newY = item.y;\n\n        // Handle corner/edge resizing that affects position\n        if ([\"sw\", \"w\", \"nw\", \"n\", \"ne\"].includes(handle)) {\n          if ([\"sw\", \"nw\", \"w\"].includes(handle)) {\n            newX = item.x + (item.w - w);\n            w = item.x !== newX && newX < 0 ? item.w : w;\n            newX = newX < 0 ? 0 : newX;\n          }\n\n          if ([\"ne\", \"n\", \"nw\"].includes(handle)) {\n            newY = item.y + (item.h - h);\n            h = item.y !== newY && newY < 0 ? item.h : h;\n            newY = newY < 0 ? 0 : newY;\n          }\n\n          shouldMoveItem = true;\n        }\n\n        // Check for collisions if preventCollision is enabled\n        if (preventCollision && !allowOverlap) {\n          const collisions = getAllCollisions(currentLayout, {\n            ...item,\n            w,\n            h,\n            x: newX ?? item.x,\n            y: newY ?? item.y\n          }).filter(layoutItem => layoutItem.i !== item.i);\n\n          if (collisions.length > 0) {\n            newY = item.y;\n            h = item.h;\n            newX = item.x;\n            w = item.w;\n            shouldMoveItem = false;\n          }\n        }\n\n        (item as Mutable<LayoutItem>).w = w;\n        (item as Mutable<LayoutItem>).h = h;\n\n        return item;\n      });\n\n      if (!l) return;\n\n      let finalLayout = newLayout;\n      if (shouldMoveItem && newX !== undefined && newY !== undefined) {\n        finalLayout = moveElement(\n          newLayout,\n          l,\n          newX,\n          newY,\n          true,\n          preventCollision,\n          compactType,\n          cols,\n          allowOverlap\n        );\n      }\n\n      const placeholder: LayoutItem = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        i,\n        static: true\n      };\n\n      onResizeProp(\n        finalLayout,\n        oldResizeItem,\n        l,\n        placeholder,\n        data.e,\n        data.node\n      );\n\n      // Use compactor.compact() - it handles allowOverlap internally (#2213)\n      setLayout(compactor.compact(finalLayout, cols));\n      setActiveDrag(placeholder);\n    },\n    [preventCollision, compactType, cols, allowOverlap, compactor, onResizeProp]\n  );\n\n  const onResizeStop = useCallback(\n    (i: string, _w: number, _h: number, data: GridResizeEvent) => {\n      const currentLayout = layoutRef.current;\n      const oldResizeItem = oldResizeItemRef.current;\n      const l = getLayoutItem(currentLayout, i);\n\n      // Use compactor.compact() - it handles allowOverlap internally (#2213)\n      const finalLayout = compactor.compact(currentLayout, cols);\n\n      onResizeStopProp(\n        finalLayout,\n        oldResizeItem,\n        l ?? null,\n        null,\n        data.e,\n        data.node\n      );\n\n      const oldLayout = oldLayoutRef.current;\n      oldResizeItemRef.current = null;\n      oldLayoutRef.current = null;\n      setActiveDrag(null);\n      setResizing(false);\n      setLayout(finalLayout);\n\n      if (oldLayout && !deepEqual(oldLayout, finalLayout)) {\n        onLayoutChange(finalLayout);\n      }\n    },\n    [cols, compactor, onResizeStopProp, onLayoutChange]\n  );\n\n  // ============================================================================\n  // Drop Handlers\n  // ============================================================================\n\n  const removeDroppingPlaceholder = useCallback(() => {\n    // Guard against being called when there's no dropping item (#2210)\n    // This makes the function idempotent and safe to call multiple times\n    const currentLayout = layoutRef.current;\n    const hasDroppingItem = currentLayout.some(l => l.i === droppingItem.i);\n    if (!hasDroppingItem) {\n      // Nothing to remove, just ensure state is clean\n      setDroppingDOMNode(null);\n      setActiveDrag(null);\n      setDroppingPosition(undefined);\n      return;\n    }\n\n    // Use compactor.compact() - it handles allowOverlap internally (#2213)\n    const newLayout = compactor.compact(\n      currentLayout.filter(l => l.i !== droppingItem.i),\n      cols\n    );\n\n    setLayout(newLayout);\n    setDroppingDOMNode(null);\n    setActiveDrag(null);\n    setDroppingPosition(undefined);\n  }, [droppingItem.i, cols, compactor]);\n\n  const handleDragOver = useCallback(\n    (e: ReactDragEvent): void | false => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      // Firefox hack\n      if (\n        isFirefox &&\n        !(e.nativeEvent.target as HTMLElement)?.classList.contains(\n          layoutClassName\n        )\n      ) {\n        return false;\n      }\n\n      // Use dropConfig.onDragOver if provided, otherwise fall back to onDropDragOver prop (#2212)\n      // dropConfig.onDragOver uses native DragEvent, onDropDragOver uses React's DragEvent\n      const rawResult = dropConfigOnDragOver\n        ? dropConfigOnDragOver(e.nativeEvent as DragEvent)\n        : onDropDragOverProp(e);\n      if (rawResult === false) {\n        if (droppingDOMNode) {\n          removeDroppingPlaceholder();\n        }\n        return false;\n      }\n      const {\n        dragOffsetX = 0,\n        dragOffsetY = 0,\n        ...onDragOverResult\n      } = rawResult ?? {};\n\n      const finalDroppingItem = { ...droppingItem, ...onDragOverResult };\n      const gridRect = e.currentTarget.getBoundingClientRect();\n\n      // Calculate position params for proper column width calculation\n      const positionParams: PositionParams = {\n        cols,\n        margin: margin as [number, number],\n        maxRows,\n        rowHeight,\n        containerWidth: width,\n        containerPadding: effectiveContainerPadding as [number, number]\n      };\n\n      // Calculate actual column width accounting for margins and padding\n      const actualColWidth = calcGridColWidth(positionParams);\n\n      // Calculate item dimensions in pixels including margins between cells\n      const itemPixelWidth = calcGridItemWHPx(\n        finalDroppingItem.w,\n        actualColWidth,\n        (margin as [number, number])[0]\n      );\n      const itemPixelHeight = calcGridItemWHPx(\n        finalDroppingItem.h,\n        rowHeight,\n        (margin as [number, number])[1]\n      );\n\n      // Center the dropping item by offsetting by half its size\n      const itemCenterOffsetX = itemPixelWidth / 2;\n      const itemCenterOffsetY = itemPixelHeight / 2;\n\n      // Calculate mouse position relative to grid, accounting for drag offset and item centering\n      const rawGridX =\n        e.clientX - gridRect.left + dragOffsetX - itemCenterOffsetX;\n      const rawGridY =\n        e.clientY - gridRect.top + dragOffsetY - itemCenterOffsetY;\n\n      // Clamp to prevent negative positions (calcXY handles upper bound clamping)\n      const clampedGridX = Math.max(0, rawGridX);\n      const clampedGridY = Math.max(0, rawGridY);\n\n      const newDroppingPosition: DroppingPosition = {\n        left: clampedGridX / transformScale,\n        top: clampedGridY / transformScale,\n        e: e.nativeEvent\n      };\n\n      if (!droppingDOMNode) {\n        const calculatedPosition = calcXY(\n          positionParams,\n          clampedGridY,\n          clampedGridX,\n          finalDroppingItem.w,\n          finalDroppingItem.h\n        );\n\n        setDroppingDOMNode(<div key={finalDroppingItem.i} />);\n        setDroppingPosition(newDroppingPosition);\n        setLayout([\n          ...layoutRef.current,\n          {\n            ...finalDroppingItem,\n            x: calculatedPosition.x,\n            y: calculatedPosition.y,\n            static: false,\n            isDraggable: true\n          }\n        ]);\n      } else if (droppingPosition) {\n        const shouldUpdate =\n          droppingPosition.left !== newDroppingPosition.left ||\n          droppingPosition.top !== newDroppingPosition.top;\n        if (shouldUpdate) {\n          setDroppingPosition(newDroppingPosition);\n        }\n      }\n    },\n    [\n      droppingDOMNode,\n      droppingPosition,\n      droppingItem,\n      dropConfigOnDragOver,\n      onDropDragOverProp,\n      removeDroppingPlaceholder,\n      transformScale,\n      cols,\n      margin,\n      maxRows,\n      rowHeight,\n      width,\n      effectiveContainerPadding\n    ]\n  );\n\n  const handleDragLeave = useCallback(\n    (e: ReactDragEvent) => {\n      e.preventDefault();\n      e.stopPropagation();\n      dragEnterCounterRef.current--;\n\n      // Guard against negative counter (#2210)\n      // This can happen in edge cases with event timing or bubbling\n      if (dragEnterCounterRef.current < 0) {\n        dragEnterCounterRef.current = 0;\n      }\n\n      if (dragEnterCounterRef.current === 0) {\n        removeDroppingPlaceholder();\n      }\n    },\n    [removeDroppingPlaceholder]\n  );\n\n  const handleDragEnter = useCallback((e: ReactDragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n    dragEnterCounterRef.current++;\n  }, []);\n\n  const handleDrop = useCallback(\n    (e: ReactDragEvent) => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      const currentLayout = layoutRef.current;\n      const item = currentLayout.find(l => l.i === droppingItem.i);\n      dragEnterCounterRef.current = 0;\n      removeDroppingPlaceholder();\n      onDropProp(currentLayout, item, e.nativeEvent);\n    },\n    [droppingItem.i, removeDroppingPlaceholder, onDropProp]\n  );\n\n  // ============================================================================\n  // Render Helpers\n  // ============================================================================\n\n  const processGridItem = useCallback(\n    (\n      child: ReactElement,\n      isDroppingItem?: boolean\n    ): ReactElement | null | undefined => {\n      if (!child || !child.key) return null;\n\n      const l = getLayoutItem(layout, String(child.key));\n      if (!l) return null;\n\n      const draggable =\n        typeof l.isDraggable === \"boolean\"\n          ? l.isDraggable\n          : !l.static && isDraggable;\n      const resizable =\n        typeof l.isResizable === \"boolean\"\n          ? l.isResizable\n          : !l.static && isResizable;\n      const resizeHandlesOptions = l.resizeHandles || [...resizeHandles];\n      const bounded = draggable && isBounded && l.isBounded !== false;\n\n      // Cast resize handle to expected type (function signature is compatible)\n      const resizeHandleElement = resizeHandle as ResizeHandle | undefined;\n\n      return (\n        <GridItem\n          key={l.i}\n          containerWidth={width}\n          cols={cols}\n          margin={margin}\n          containerPadding={effectiveContainerPadding}\n          maxRows={maxRows}\n          rowHeight={rowHeight}\n          cancel={draggableCancel}\n          handle={draggableHandle}\n          onDragStart={onDragStart}\n          onDrag={onDrag}\n          onDragStop={onDragStop}\n          onResizeStart={onResizeStart}\n          onResize={onResize}\n          onResizeStop={onResizeStop}\n          isDraggable={draggable}\n          isResizable={resizable}\n          isBounded={bounded}\n          useCSSTransforms={useCSSTransforms && mounted}\n          usePercentages={!mounted}\n          transformScale={transformScale}\n          positionStrategy={positionStrategy}\n          dragThreshold={dragThreshold}\n          w={l.w}\n          h={l.h}\n          x={l.x}\n          y={l.y}\n          i={l.i}\n          minH={l.minH}\n          minW={l.minW}\n          maxH={l.maxH}\n          maxW={l.maxW}\n          static={l.static}\n          droppingPosition={isDroppingItem ? droppingPosition : undefined}\n          resizeHandles={resizeHandlesOptions}\n          resizeHandle={resizeHandleElement}\n          constraints={constraints}\n          layoutItem={l}\n          layout={layout}\n        >\n          {child}\n        </GridItem>\n      );\n    },\n    [\n      layout,\n      width,\n      cols,\n      margin,\n      effectiveContainerPadding,\n      maxRows,\n      rowHeight,\n      draggableCancel,\n      draggableHandle,\n      onDragStart,\n      onDrag,\n      onDragStop,\n      onResizeStart,\n      onResize,\n      onResizeStop,\n      isDraggable,\n      isResizable,\n      isBounded,\n      useCSSTransforms,\n      mounted,\n      transformScale,\n      positionStrategy,\n      dragThreshold,\n      droppingPosition,\n      resizeHandles,\n      resizeHandle,\n      constraints\n    ]\n  );\n\n  const renderPlaceholder = (): ReactElement | null => {\n    if (!activeDrag) return null;\n\n    return (\n      <GridItem\n        w={activeDrag.w}\n        h={activeDrag.h}\n        x={activeDrag.x}\n        y={activeDrag.y}\n        i={activeDrag.i}\n        className={`react-grid-placeholder ${resizing ? \"placeholder-resizing\" : \"\"}`}\n        containerWidth={width}\n        cols={cols}\n        margin={margin}\n        containerPadding={effectiveContainerPadding}\n        maxRows={maxRows}\n        rowHeight={rowHeight}\n        isDraggable={false}\n        isResizable={false}\n        isBounded={false}\n        useCSSTransforms={useCSSTransforms}\n        transformScale={transformScale}\n        constraints={constraints}\n        layout={layout}\n      >\n        <div />\n      </GridItem>\n    );\n  };\n\n  // ============================================================================\n  // Render\n  // ============================================================================\n\n  const mergedClassName = clsx(layoutClassName, className);\n  const mergedStyle: CSSProperties = {\n    height: containerHeight,\n    ...style\n  };\n\n  return (\n    <div\n      ref={innerRef}\n      className={mergedClassName}\n      style={mergedStyle}\n      onDrop={isDroppable ? handleDrop : undefined}\n      onDragLeave={isDroppable ? handleDragLeave : undefined}\n      onDragEnter={isDroppable ? handleDragEnter : undefined}\n      onDragOver={isDroppable ? handleDragOver : undefined}\n    >\n      {React.Children.map(children, child => {\n        if (!React.isValidElement(child)) return null;\n        return processGridItem(child);\n      })}\n      {isDroppable && droppingDOMNode && processGridItem(droppingDOMNode, true)}\n      {renderPlaceholder()}\n    </div>\n  );\n}\n\nexport default GridLayout;\n", "/**\n * ResponsiveGridLayout component\n *\n * A responsive grid layout that automatically adjusts to container width.\n */\n\nimport React, {\n  useState,\n  useEffect,\n  useRef,\n  useMemo,\n  useCallback,\n  type ReactElement\n} from \"react\";\nimport { deepEqual } from \"fast-equals\";\n\nimport type {\n  Layout,\n  LayoutItem,\n  Breakpoint,\n  Breakpoints,\n  ResponsiveLayouts,\n  Compactor\n} from \"../../core/types.js\";\nimport { cloneLayout, correctBounds } from \"../../core/layout.js\";\nimport {\n  getBreakpointFromWidth,\n  getColsFromBreakpoint,\n  findOrGenerateResponsiveLayout,\n  getIndentationValue\n} from \"../../core/responsive.js\";\nimport { getCompactor } from \"../../core/compactors.js\";\nimport { bottom } from \"../../core/layout.js\";\n\nimport { GridLayout, type GridLayoutProps } from \"./GridLayout.js\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface ResponsiveGridLayoutProps<\n  B extends Breakpoint = string\n> extends Omit<GridLayoutProps, \"gridConfig\" | \"layout\" | \"onLayoutChange\"> {\n  /** Current breakpoint (optional, auto-detected from width) */\n  breakpoint?: B;\n  /** Breakpoint definitions (name  min-width) */\n  breakpoints?: Breakpoints<B>;\n  /** Column counts per breakpoint */\n  cols?: Breakpoints<B>;\n  /** Layouts for each breakpoint */\n  layouts?: ResponsiveLayouts<B>;\n  /** Row height (default: 150) */\n  rowHeight?: number;\n  /** Maximum rows (default: Infinity) */\n  maxRows?: number;\n  /** Margin between items - can be fixed or per-breakpoint */\n  margin?:\n    | readonly [number, number]\n    | Partial<Record<B, readonly [number, number]>>;\n  /** Container padding - can be fixed or per-breakpoint */\n  containerPadding?:\n    | readonly [number, number]\n    | Partial<Record<B, readonly [number, number] | null>>\n    | null;\n  /** Compactor for layout compaction */\n  compactor?: Compactor;\n  /** Called when breakpoint changes */\n  onBreakpointChange?: (newBreakpoint: B, cols: number) => void;\n  /** Called when layout changes */\n  onLayoutChange?: (layout: Layout, layouts: ResponsiveLayouts<B>) => void;\n  /** Called when width changes */\n  onWidthChange?: (\n    containerWidth: number,\n    margin: readonly [number, number],\n    cols: number,\n    containerPadding: readonly [number, number] | null\n  ) => void;\n}\n\n// ============================================================================\n// Default Values\n// ============================================================================\n\nconst DEFAULT_BREAKPOINTS: Breakpoints<string> = {\n  lg: 1200,\n  md: 996,\n  sm: 768,\n  xs: 480,\n  xxs: 0\n};\n\nconst DEFAULT_COLS: Breakpoints<string> = {\n  lg: 12,\n  md: 10,\n  sm: 6,\n  xs: 4,\n  xxs: 2\n};\n\nconst noop = () => {};\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\n/**\n * Synchronize layout with children - use compactor.compact() (#2213)\n */\nfunction synchronizeLayoutWithChildren(\n  initialLayout: Layout,\n  children: React.ReactNode,\n  cols: number,\n  compactor: Compactor\n): Layout {\n  const layout: LayoutItem[] = [];\n\n  React.Children.forEach(children, child => {\n    if (!React.isValidElement(child) || child.key === null) return;\n    const key = String(child.key);\n\n    // Find existing layout item\n    const existingItem = initialLayout.find(l => l.i === key);\n\n    if (existingItem) {\n      layout.push({\n        ...existingItem,\n        i: key\n      });\n    } else {\n      // Create new layout item from child data-grid prop\n      const childProps = child.props as { \"data-grid\"?: Partial<LayoutItem> };\n      const dataGrid = childProps[\"data-grid\"];\n\n      if (dataGrid) {\n        layout.push({\n          i: key,\n          x: dataGrid.x ?? 0,\n          y: dataGrid.y ?? 0,\n          w: dataGrid.w ?? 1,\n          h: dataGrid.h ?? 1,\n          minW: dataGrid.minW,\n          maxW: dataGrid.maxW,\n          minH: dataGrid.minH,\n          maxH: dataGrid.maxH,\n          static: dataGrid.static,\n          isDraggable: dataGrid.isDraggable,\n          isResizable: dataGrid.isResizable,\n          resizeHandles: dataGrid.resizeHandles,\n          isBounded: dataGrid.isBounded\n        });\n      } else {\n        // Create default layout item\n        layout.push({\n          i: key,\n          x: 0,\n          y: bottom(layout),\n          w: 1,\n          h: 1\n        });\n      }\n    }\n  });\n\n  // Correct bounds and compact - use compactor.compact() (#2213)\n  const corrected = correctBounds(layout, { cols });\n  return compactor.compact(corrected, cols);\n}\n\n// ============================================================================\n// Component\n// ============================================================================\n\n/**\n * ResponsiveGridLayout - A responsive grid layout that adjusts to container width.\n */\nexport function ResponsiveGridLayout<B extends Breakpoint = string>(\n  props: ResponsiveGridLayoutProps<B>\n): ReactElement {\n  const {\n    children,\n    width,\n    breakpoint: propBreakpoint,\n    breakpoints = DEFAULT_BREAKPOINTS as Breakpoints<B>,\n    cols: colsConfig = DEFAULT_COLS as Breakpoints<B>,\n    layouts: propsLayouts = {} as ResponsiveLayouts<B>,\n    rowHeight = 150,\n    maxRows = Infinity,\n    margin: propMargin = [10, 10] as readonly [number, number],\n    containerPadding: propContainerPadding = null,\n    compactor: compactorProp,\n    onBreakpointChange = noop,\n    onLayoutChange = noop,\n    onWidthChange = noop,\n    ...restProps\n  } = props;\n\n  // Get compactor (use provided or default to vertical)\n  const compactor = compactorProp ?? getCompactor(\"vertical\");\n  const compactType = compactor.type;\n  const allowOverlap = compactor.allowOverlap;\n\n  // Calculate initial state\n  const initialBreakpoint = useMemo(() => {\n    return propBreakpoint ?? getBreakpointFromWidth(breakpoints, width);\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  const initialCols = useMemo(() => {\n    return getColsFromBreakpoint(initialBreakpoint, colsConfig);\n  }, [initialBreakpoint, colsConfig]);\n\n  // Use compactType for initial layout as compactor reference isn't stable here\n  // findOrGenerateResponsiveLayout accepts both CompactType and Compactor (#2213)\n  const initialLayout = useMemo(() => {\n    return findOrGenerateResponsiveLayout(\n      propsLayouts,\n      breakpoints,\n      initialBreakpoint,\n      initialBreakpoint,\n      initialCols,\n      compactType\n    );\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  // State\n  const [breakpoint, setBreakpoint] = useState<B>(initialBreakpoint);\n  const [cols, setCols] = useState<number>(initialCols);\n  const [layout, setLayout] = useState<Layout>(initialLayout);\n  const [layouts, setLayouts] = useState<ResponsiveLayouts<B>>(propsLayouts);\n\n  // Refs for tracking changes\n  const prevWidthRef = useRef(width);\n  const prevBreakpointRef = useRef(propBreakpoint);\n  const prevBreakpointsRef = useRef(breakpoints);\n  const prevColsRef = useRef(colsConfig);\n  const prevLayoutsRef = useRef(propsLayouts);\n  const prevCompactTypeRef = useRef(compactType);\n\n  // Ref to always have current layouts value (avoids stale closure in callbacks)\n  const layoutsRef = useRef(layouts);\n\n  // Keep layoutsRef in sync with layouts state\n  useEffect(() => {\n    layoutsRef.current = layouts;\n  }, [layouts]);\n\n  // Derive layout synchronously from props during render (not in useEffect which runs after render)\n  // This prevents the timing issue where GridLayout sees children before the layout is updated\n  // Use compactor directly (#2213)\n  const derivedLayout: Layout | null = useMemo(() => {\n    if (!deepEqual(propsLayouts, prevLayoutsRef.current)) {\n      // Props changed, derive new layout synchronously\n      return findOrGenerateResponsiveLayout(\n        propsLayouts,\n        breakpoints,\n        breakpoint,\n        breakpoint,\n        cols,\n        compactor\n      );\n    }\n    return null; // No change needed\n  }, [propsLayouts, breakpoints, breakpoint, cols, compactor]);\n\n  // The effective layout to pass to GridLayout - use derived if available, else state\n  const effectiveLayout = derivedLayout ?? layout;\n\n  // Update state and refs in effect (for consistency on future renders)\n  useEffect(() => {\n    if (derivedLayout !== null) {\n      setLayout(derivedLayout);\n      setLayouts(propsLayouts);\n      layoutsRef.current = propsLayouts;\n      prevLayoutsRef.current = propsLayouts;\n    }\n  }, [derivedLayout, propsLayouts]);\n\n  // Handle compactType changes - use compactor.compact() (#2213)\n  useEffect(() => {\n    if (compactType !== prevCompactTypeRef.current) {\n      // Re-compact the current layout with the new compactType\n      // Use effectiveLayout to avoid stale data when layouts are being synced\n      const newLayout = compactor.compact(cloneLayout(effectiveLayout), cols);\n      const newLayouts = {\n        ...layoutsRef.current,\n        [breakpoint]: newLayout\n      } as ResponsiveLayouts<B>;\n\n      setLayout(newLayout);\n      setLayouts(newLayouts);\n      layoutsRef.current = newLayouts;\n      onLayoutChange(newLayout, newLayouts);\n      prevCompactTypeRef.current = compactType;\n    }\n  }, [\n    compactType,\n    compactor,\n    effectiveLayout,\n    cols,\n    allowOverlap,\n    breakpoint,\n    onLayoutChange\n  ]);\n\n  // Handle width changes\n  useEffect(() => {\n    const widthChanged = width !== prevWidthRef.current;\n    const breakpointPropChanged = propBreakpoint !== prevBreakpointRef.current;\n    const breakpointsChanged = !deepEqual(\n      breakpoints,\n      prevBreakpointsRef.current\n    );\n    const colsChanged = !deepEqual(colsConfig, prevColsRef.current);\n\n    if (\n      widthChanged ||\n      breakpointPropChanged ||\n      breakpointsChanged ||\n      colsChanged\n    ) {\n      const newBreakpoint =\n        propBreakpoint ?? getBreakpointFromWidth(breakpoints, width);\n      const newCols = getColsFromBreakpoint(newBreakpoint, colsConfig);\n      const lastBreakpoint = breakpoint;\n\n      // Breakpoint change\n      if (\n        lastBreakpoint !== newBreakpoint ||\n        breakpointsChanged ||\n        colsChanged\n      ) {\n        const newLayouts = { ...layoutsRef.current } as ResponsiveLayouts<B>;\n\n        // Preserve current layout if not in new layouts\n        if (!newLayouts[lastBreakpoint]) {\n          (newLayouts as Record<B, Layout>)[lastBreakpoint] =\n            cloneLayout(layout);\n        }\n\n        // Find or generate new layout - use compactor (#2213)\n        let newLayout = findOrGenerateResponsiveLayout(\n          newLayouts,\n          breakpoints,\n          newBreakpoint,\n          lastBreakpoint,\n          newCols,\n          compactor\n        );\n\n        // Sync with children - use compactor (#2213)\n        newLayout = synchronizeLayoutWithChildren(\n          newLayout,\n          children,\n          newCols,\n          compactor\n        );\n\n        // Store new layout\n        (newLayouts as Record<B, Layout>)[newBreakpoint] = newLayout;\n\n        // Update state\n        setBreakpoint(newBreakpoint);\n        setCols(newCols);\n        setLayout(newLayout);\n        setLayouts(newLayouts);\n        layoutsRef.current = newLayouts;\n\n        // Callbacks\n        onBreakpointChange(newBreakpoint, newCols);\n        onLayoutChange(newLayout, newLayouts);\n      }\n\n      // Get margin and padding for callback\n      const currentMargin = getIndentationValue(\n        propMargin as Parameters<typeof getIndentationValue>[0],\n        newBreakpoint\n      );\n      const currentPadding = propContainerPadding\n        ? getIndentationValue(\n            propContainerPadding as Parameters<typeof getIndentationValue>[0],\n            newBreakpoint\n          )\n        : null;\n\n      // Width change callback\n      onWidthChange(width, currentMargin, newCols, currentPadding);\n\n      // Update refs\n      prevWidthRef.current = width;\n      prevBreakpointRef.current = propBreakpoint;\n      prevBreakpointsRef.current = breakpoints;\n      prevColsRef.current = colsConfig;\n    }\n  }, [\n    width,\n    propBreakpoint,\n    breakpoints,\n    colsConfig,\n    breakpoint,\n    cols,\n    layout,\n    children,\n    compactor,\n    compactType,\n    allowOverlap,\n    propMargin,\n    propContainerPadding,\n    onBreakpointChange,\n    onLayoutChange,\n    onWidthChange\n  ]);\n\n  // Handle layout change from GridLayout\n  const handleLayoutChange = useCallback(\n    (newLayout: Layout) => {\n      // Use layoutsRef.current to avoid stale closure issues\n      const currentLayouts = layoutsRef.current;\n      const newLayouts = {\n        ...currentLayouts,\n        [breakpoint]: newLayout\n      } as ResponsiveLayouts<B>;\n\n      setLayout(newLayout);\n      setLayouts(newLayouts);\n      layoutsRef.current = newLayouts;\n      onLayoutChange(newLayout, newLayouts);\n    },\n    [breakpoint, onLayoutChange]\n  );\n\n  // Get margin and padding for current breakpoint\n  const currentMargin = useMemo(() => {\n    return getIndentationValue(\n      propMargin as Parameters<typeof getIndentationValue>[0],\n      breakpoint\n    );\n  }, [propMargin, breakpoint]);\n\n  const currentContainerPadding = useMemo(() => {\n    if (propContainerPadding === null) return null;\n    return getIndentationValue(\n      propContainerPadding as Parameters<typeof getIndentationValue>[0],\n      breakpoint\n    );\n  }, [propContainerPadding, breakpoint]);\n\n  // Build grid config for current breakpoint\n  const gridConfig = useMemo(\n    () => ({\n      cols,\n      rowHeight,\n      maxRows,\n      margin: currentMargin,\n      containerPadding: currentContainerPadding\n    }),\n    [cols, rowHeight, maxRows, currentMargin, currentContainerPadding]\n  );\n\n  return (\n    <GridLayout\n      {...restProps}\n      width={width}\n      gridConfig={gridConfig}\n      compactor={compactor}\n      onLayoutChange={handleLayoutChange}\n      layout={effectiveLayout}\n    >\n      {children}\n    </GridLayout>\n  );\n}\n\nexport default ResponsiveGridLayout;\n"],
  "mappings": "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",
  "names": ["e", "e", "t", "e", "t", "DraggableCore", "e", "t", "DraggableCore", "_getRequireWildcardCache", "nodeInterop", "_setPrototypeOf", "o", "p", "Resizable", "_getRequireWildcardCache", "nodeInterop", "_setPrototypeOf", "o", "p", "ResizableBox", "clamp", "areArraysEqual", "areDatesEqual", "areMapsEqual", "areObjectsEqual", "areRegExpsEqual", "areSetsEqual", "useRef", "useState", "useCallback", "useEffect", "useMemo", "layout", "deepEqual", "pos", "rawPos", "resizeHandle", "React", "useMemo", "useState", "useRef", "useEffect", "useCallback", "_a", "jsx", "clsx", "DEFAULT_BREAKPOINTS", "DEFAULT_COLS", "noop", "synchronizeLayoutWithChildren", "deepEqual", "currentMargin"]
}
