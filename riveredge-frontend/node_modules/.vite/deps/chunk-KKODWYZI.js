import {
  Be,
  Cn,
  Ds,
  ER,
  Fn,
  Hn,
  Inject,
  Injector,
  JC,
  Jg,
  KR,
  Kc,
  Ls,
  Nt,
  Optional,
  QR,
  Ts,
  Ve,
  Z,
  ZR,
  Ze,
  _s,
  a1,
  aI,
  br,
  co,
  createIdentifier,
  ct,
  et,
  gR,
  ge,
  h1,
  ho,
  ht,
  i1,
  ie,
  l1,
  mn,
  s1,
  w1,
  we,
  xs,
  y1,
  ye,
  yl
} from "./chunk-Y4UF2FTU.js";
import {
  BehaviorSubject,
  Observable,
  Subject,
  combineLatest,
  distinctUntilChanged,
  filter,
  firstValueFrom,
  isObservable,
  map,
  of,
  shareReplay,
  take,
  takeUntil
} from "./chunk-AR6LG6UR.js";
import {
  __async,
  __objRest,
  __pow,
  __spreadProps,
  __spreadValues
} from "./chunk-JMNN7AZU.js";

// node_modules/@univerjs/rpc/lib/es/index.js
var X = Object.defineProperty;
var Z2 = (s, t, e) => t in s ? X(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var a = (s, t, e) => Z2(s, typeof t != "symbol" ? t + "" : t, e);
var he = Object.getOwnPropertyDescriptor;
var G = (s, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? he(t, e) : t, i = s.length - 1, c; i >= 0; i--)
    (c = s[i]) && (r = c(r) || r);
  return r;
};
var p = (s, t) => (e, n) => t(e, n, s);
var W = "rpc.remote-sync.service";
var m = createIdentifier(W);
var M = class {
  constructor(s) {
    this._commandService = s;
  }
  syncMutation(s) {
    return __async(this, null, function* () {
      return this._commandService.syncExecuteCommand(s.mutationInfo.id, s.mutationInfo.params, {
        onlyLocal: true,
        fromSync: true
      });
    });
  }
};
M = G([
  p(0, Ds)
], M);
var $ = "univer.remote-instance-service";
var g = createIdentifier($);
var q = class {
  constructor(s, t, e) {
    this._univerInstanceService = s, this._commandService = t, this._logService = e;
  }
  whenReady() {
    return Promise.resolve(true);
  }
  syncMutation(s) {
    return __async(this, null, function* () {
      return this._applyMutation(s.mutationInfo);
    });
  }
  createInstance(s) {
    return __async(this, null, function* () {
      const { type: t, snapshot: e } = s;
      try {
        switch (t) {
          case we.UNIVER_SHEET:
            return this._univerInstanceService.createUnit(we.UNIVER_SHEET, e), true;
          default:
            throw new Error(
              `[WebWorkerRemoteInstanceService]: cannot create replica for document type: ${t}.`
            );
        }
      } catch (n) {
        throw n instanceof Error ? n : new TypeError(`${n}`);
      }
    });
  }
  disposeInstance(s) {
    return __async(this, null, function* () {
      return this._univerInstanceService.disposeUnit(s.unitID);
    });
  }
  _applyMutation(s) {
    const { id: t, params: e } = s;
    return this._commandService.syncExecuteCommand(t, e, {
      onlyLocal: true,
      fromSync: true
    });
  }
};
q = G([
  p(0, br),
  p(1, Ds),
  p(2, Nt)
], q);
function Y(s) {
  const t = s;
  return new class {
    call(e, n) {
      const r = t[e];
      if (typeof r == "function") {
        let i = n ? r.apply(t, n) : r.call(t);
        return i instanceof Promise || (i = Promise.resolve(i)), i;
      }
      throw new Error(`[RPC]: method not found for ${e}!`);
    }
    subscribe(e, n) {
      const r = t[e];
      if (typeof r == "function") {
        const i = n ? r.apply(t, n) : r.call(t);
        return isObservable(i) ? i : of(i);
      }
      throw new Error(`[RPC]: observable method not found for ${e}!`);
    }
  }();
}
function B(s) {
  return new Proxy({}, {
    get(t, e) {
      if (e !== "dispose")
        return function(...n) {
          return le(e) ? s.subscribe(e, n) : s.call(e, n);
        };
    }
  });
}
function le(s) {
  return s.endsWith("$");
}
var _e = class extends ER {
  constructor(e) {
    super();
    a(this, "_initialized", new BehaviorSubject(false));
    a(this, "_lastRequestCounter", 0);
    a(this, "_pendingRequests", /* @__PURE__ */ new Map());
    this._protocol = e, this._protocol.send({
      type: 50
      /* REQUEST_INITIALIZATION */
    }), this._protocol.onMessage.pipe(takeUntil(this.dispose$)).subscribe((n) => this._onMessage(n));
  }
  dispose() {
    this._pendingRequests.clear();
  }
  getChannel(e) {
    const n = this;
    return {
      call(r, i) {
        return n._disposed ? Promise.reject() : n._remoteCall(e, r, i);
      },
      subscribe(r, i) {
        if (n._disposed)
          throw new Error("[ChannelClient]: client is disposed!");
        return n._remoteSubscribe(e, r, i);
      }
    };
  }
  _whenReady() {
    return firstValueFrom(
      this._initialized.pipe(
        filter((e) => e),
        take(1)
      )
    );
  }
  _remoteCall(e, n, r) {
    return __async(this, null, function* () {
      yield this._whenReady();
      const i = ++this._lastRequestCounter, h2 = { seq: i, type: 100, channelName: e, method: n, args: r }, o = this;
      return new Promise((w, l) => {
        const Q2 = {
          handle(E) {
            switch (E.type) {
              case 201:
                o._pendingRequests.delete(i), w(E.data);
                break;
              case 202:
                o._pendingRequests.delete(i), l(E.data);
                break;
              default:
                throw new Error("[ChannelClient]: unknown response type!");
            }
          }
        };
        this._pendingRequests.set(i, Q2), this._sendRequest(h2);
      });
    });
  }
  _remoteSubscribe(e, n, r) {
    return new Observable((i) => {
      let c = -1;
      return this._whenReady().then(() => {
        c = ++this._lastRequestCounter;
        const o = { seq: c, type: 101, channelName: e, method: n, args: r }, w = {
          handle(l) {
            switch (l.type) {
              case 300:
                i.next(l.data);
                break;
              case 301:
                i.error(l.data);
                break;
              case 302:
                i.complete();
                break;
              default:
                throw new Error("[ChannelClient]: unknown response type!");
            }
          }
        };
        this._pendingRequests.set(c, w), this._sendRequest(o);
      }), () => {
        if (c === -1)
          return;
        const h2 = {
          type: 102,
          seq: c,
          channelName: e,
          method: n
        };
        this._sendRequest(h2);
      };
    });
  }
  _sendRequest(e) {
    this._protocol.send(e);
  }
  _onMessage(e) {
    var n;
    switch (e.type) {
      case 0:
        this._initialized.next(true);
        break;
      case 201:
      case 202:
      case 300:
      case 302:
      case 301:
        (n = this._pendingRequests.get(e.seq)) == null || n.handle(e);
        break;
    }
  }
};
var ue = class extends ER {
  constructor(e) {
    super();
    a(this, "_channels", /* @__PURE__ */ new Map());
    a(this, "_subscriptions", /* @__PURE__ */ new Map());
    this._protocol = e, this._protocol.onMessage.pipe(takeUntil(this.dispose$)).subscribe((n) => this._onRequest(n)), this._sendInitialize();
  }
  dispose() {
    super.dispose(), this._subscriptions.clear(), this._channels.clear();
  }
  registerChannel(e, n) {
    this._channels.set(e, n);
  }
  _onRequest(e) {
    switch (e.type) {
      case 50:
        this._sendInitialize();
        break;
      case 100:
        this._onMethodCall(e);
        break;
      case 101:
        this._onSubscribe(e);
        break;
      case 102:
        this._onUnsubscribe(e);
        break;
    }
  }
  _sendInitialize() {
    this._sendResponse({
      seq: -1,
      type: 0
      /* INITIALIZE */
    });
  }
  _onMethodCall(e) {
    const { channelName: n, method: r, args: i } = e, c = this._channels.get(n);
    let h2;
    try {
      if (!c)
        throw new Error(`[ChannelServer]: Channel ${n} not found!`);
      h2 = i ? c.call(r, i) : c.call(r);
    } catch (o) {
      h2 = Promise.reject(o);
    }
    h2.then((o) => {
      this._sendResponse({ seq: e.seq, type: 201, data: o });
    }).catch((o) => {
      o instanceof Error ? this._sendResponse({ seq: e.seq, type: 202, data: o.message }) : this._sendResponse({ seq: e.seq, type: 202, data: String(o) });
    });
  }
  _onSubscribe(e) {
    const { channelName: n, seq: r } = e, i = this._channels.get(n);
    try {
      if (!i)
        throw new Error(`[ChannelServer]: Channel ${n} not found!`);
      const h2 = i.subscribe(e.method, e.args).subscribe({
        next: (o) => {
          this._sendResponse({ seq: r, type: 300, data: o });
        },
        error: (o) => {
          this._sendResponse({ seq: r, type: 301, data: o.message }), this._sendResponse({
            seq: r,
            type: 302
            /* SUBSCRIBE_COMPLETE */
          });
        },
        complete: () => {
          this._sendResponse({
            seq: r,
            type: 302
            /* SUBSCRIBE_COMPLETE */
          });
        }
      });
      this._subscriptions.set(e.seq, h2);
    } catch (c) {
      c instanceof Error ? this._sendResponse({ seq: e.seq, type: 301, data: c.message }) : this._sendResponse({ seq: e.seq, type: 301, data: String(c) });
    }
  }
  _onUnsubscribe(e) {
    const n = this._subscriptions.get(e.seq);
    n && (n.unsubscribe(), this._subscriptions.delete(e.seq));
  }
  _sendResponse(e) {
    this._protocol.send(e);
  }
};
var I = createIdentifier("IRPCChannelService");
var K = class {
  constructor(t) {
    a(this, "_client");
    a(this, "_server");
    this._client = new _e(t), this._server = new ue(t);
  }
  dispose() {
    this._client.dispose(), this._server.dispose();
  }
  requestChannel(t) {
    return this._client.getChannel(t);
  }
  registerChannel(t, e) {
    this._server.registerChannel(t, e);
  }
};
var de = Object.getOwnPropertyDescriptor;
var pe = (s, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? de(t, e) : t, i = s.length - 1, c; i >= 0; i--)
    (c = s[i]) && (r = c(r) || r);
  return r;
};
var _ = (s, t) => (e, n) => t(e, n, s);
var y = class extends ER {
  constructor(t, e, n, r, i) {
    super();
    a(this, "_remoteInstanceService");
    a(this, "_syncingUnits", /* @__PURE__ */ new Set());
    a(this, "_syncingMutations", /* @__PURE__ */ new Set());
    this._injector = t, this._commandService = e, this._univerInstanceService = n, this._rpcChannelService = r, this._remoteSyncService = i, this._initRPCChannels(), this._init();
  }
  registerSyncingMutations(t) {
    this._syncingMutations.add(t.id);
  }
  /**
   * Only spreadsheets would be synced to the web worker in normal situations. If you would like to
   * sync other types of documents, you should manually call this method with that document's id.
   */
  syncUnit(t) {
    return this._syncingUnits.add(t), Be(() => this._syncingUnits.delete(t));
  }
  _initRPCChannels() {
    this._rpcChannelService.registerChannel(W, Y(this._remoteSyncService)), this._injector.add([
      g,
      { useFactory: () => B(this._rpcChannelService.requestChannel($)) }
    ]), this._remoteInstanceService = this._injector.get(g);
  }
  _init() {
    this._univerInstanceService.getTypeOfUnitAdded$(we.UNIVER_SHEET).pipe(takeUntil(this.dispose$)).subscribe((t) => {
      this._syncingUnits.add(t.getUnitId()), this._remoteInstanceService.createInstance({
        unitID: t.getUnitId(),
        type: we.UNIVER_SHEET,
        snapshot: t.getSnapshot()
      });
    }), this._univerInstanceService.getTypeOfUnitDisposed$(we.UNIVER_SHEET).pipe(takeUntil(this.dispose$)).subscribe((t) => {
      this._syncingUnits.delete(t.getUnitId()), this._remoteInstanceService.disposeInstance({
        unitID: t.getUnitId()
      });
    }), this.disposeWithMe(this._commandService.onCommandExecuted((t, e) => {
      const { type: n, params: r, id: i } = t, c = (r == null ? void 0 : r.unitId) || "";
      n === Ls.MUTATION && // only sync mutations to the worker thread
      (!c || this._syncingUnits.has(c)) && // do not sync mutations from the web worker back to the web worker
      !(e != null && e.fromSync) && // do not sync mutations those are not meant to be synced
      this._syncingMutations.has(i) && this._remoteInstanceService.syncMutation({ mutationInfo: t });
    }));
  }
};
y = pe([
  _(0, Inject(Injector)),
  _(1, Ds),
  _(2, br),
  _(3, I),
  _(4, m)
], y);
var ve = Object.getOwnPropertyDescriptor;
var me = (s, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? ve(t, e) : t, i = s.length - 1, c; i >= 0; i--)
    (c = s[i]) && (r = c(r) || r);
  return r;
};
var d = (s, t) => (e, n) => t(e, n, s);
var f = class extends Ve {
  constructor(t, e, n, r) {
    super();
    a(this, "_remoteSyncService");
    this._injector = t, this._remoteInstanceService = e, this._commandService = n, this._rpcChannelService = r, this._initRPCChannels(), this._init();
  }
  _initRPCChannels() {
    this._rpcChannelService.registerChannel($, Y(this._remoteInstanceService)), this._injector.add([
      m,
      { useFactory: () => B(this._rpcChannelService.requestChannel(W)) }
    ]), this._remoteSyncService = this._injector.get(m);
  }
  _init() {
    this.disposeWithMe(
      // Mutations executed on the main thread should be synced to the worker thread.
      this._commandService.onCommandExecuted((t, e) => {
        t.type === Ls.MUTATION && !(e != null && e.fromSync) && this._remoteSyncService.syncMutation({
          mutationInfo: t
        });
      })
    );
  }
};
f = me([
  d(0, Inject(Injector)),
  d(1, g),
  d(2, Ds),
  d(3, I)
], f);
var ge2 = "rpc.main-thread.config";
var j = {};
var ye2 = "rpc.worker-thread.config";
var D = {};
function fe() {
  return {
    send(s) {
      postMessage(s);
    },
    onMessage: new Observable((s) => {
      const t = (e) => {
        s.next(e.data);
      };
      return addEventListener("message", t), () => removeEventListener("message", t);
    }).pipe(shareReplay(1))
  };
}
function Se(s) {
  return {
    send(t) {
      s.postMessage(t);
    },
    onMessage: new Observable((t) => {
      const e = (n) => {
        t.next(n.data);
      };
      return s.addEventListener("message", e), () => s.removeEventListener("message", e);
    }).pipe(shareReplay(1))
  };
}
var Ce = Object.getOwnPropertyDescriptor;
var J = (s, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? Ce(t, e) : t, i = s.length - 1, c; i >= 0; i--)
    (c = s[i]) && (r = c(r) || r);
  return r;
};
var S = (s, t) => (e, n) => t(e, n, s);
var P;
var N = (P = class extends yl {
  constructor(t = j, e, n) {
    super();
    a(this, "_internalWorker", null);
    this._config = t, this._injector = e, this._configService = n;
    const r = __objRest(co(
      {},
      j,
      this._config
    ), []);
    this._configService.setConfig(ge2, r);
  }
  dispose() {
    super.dispose(), this._internalWorker && (this._internalWorker.terminate(), this._internalWorker = null);
  }
  onStarting() {
    const { workerURL: t } = this._config;
    if (!t)
      throw new Error("[UniverRPCMainThreadPlugin]: The workerURL is required for the RPC main thread plugin.");
    const e = t instanceof Worker ? t : new Worker(t);
    this._internalWorker = t instanceof Worker ? null : e;
    const n = Se(e);
    [
      [
        I,
        {
          useFactory: () => new K(n)
        }
      ],
      [y],
      [m, { useClass: M }]
    ].forEach((i) => this._injector.add(i)), this._injector.get(y);
  }
}, a(P, "pluginName", "UNIVER_RPC_MAIN_THREAD_PLUGIN"), P);
N = J([
  S(1, Inject(Injector)),
  S(2, xs)
], N);
var U;
var x = (U = class extends yl {
  constructor(s = D, t, e) {
    super(), this._config = s, this._injector = t, this._configService = e;
    const n = __objRest(co(
      {},
      D,
      this._config
    ), []);
    this._configService.setConfig(ye2, n);
  }
  onStarting() {
    [
      [f],
      [
        I,
        {
          useFactory: () => new K(fe())
        }
      ],
      [g, { useClass: q }]
    ].forEach((s) => this._injector.add(s)), this._injector.get(f);
  }
}, a(U, "pluginName", "UNIVER_RPC_WORKER_THREAD_PLUGIN"), U);
x = J([
  S(1, Inject(Injector)),
  S(2, xs)
], x);

// node_modules/@univerjs/engine-formula/lib/es/index.js
var Vc = Object.defineProperty;
var Oc = (a2, i, e) => i in a2 ? Vc(a2, i, { enumerable: true, configurable: true, writable: true, value: e }) : a2[i] = e;
var A = (a2, i, e) => Oc(a2, typeof i != "symbol" ? i + "" : i, e);
var ir = ((a2) => (a2.FALSE = "FALSE", a2.TRUE = "TRUE", a2))(ir || {});
var It = ((a2) => (a2[a2.SUCCESS = 0] = "SUCCESS", a2[a2.ERROR = 1] = "ERROR", a2))(It || {});
var De = ((a2) => (a2.ALL = "#All", a2.DATA = "#Data", a2.HEADERS = "#Headers", a2.TOTALS = "#Totals", a2.THIS_ROW = "#This Row", a2))(De || {});
var ft = ((a2) => (a2[a2.FRONT = 0] = "FRONT", a2[a2.BACK = 1] = "BACK", a2))(ft || {});
function Xc(a2, i, e, t, r) {
  for (let n = 0, s = a2.length; n < s; n++) {
    const o = a2[n];
    if (i !== o.unitId || e !== o.sheetId)
      continue;
    const { startRow: u, startColumn: c, endRow: l, endColumn: f2 } = o.range;
    if (t >= u && t <= l && r >= c && r <= f2)
      return true;
  }
  return false;
}
var h = ((a2) => (a2.DIV_BY_ZERO = "#DIV/0!", a2.NAME = "#NAME?", a2.VALUE = "#VALUE!", a2.NUM = "#NUM!", a2.NA = "#N/A", a2.CYCLE = "#CYCLE!", a2.REF = "#REF!", a2.SPILL = "#SPILL!", a2.CALC = "#CALC!", a2.ERROR = "#ERROR!", a2.CONNECT = "#GETTING_DATA", a2.NULL = "#NULL!", a2))(h || {});
var fr = new Set(Object.values(h));
var ii = [...new Set(Object.values(h).map((a2) => a2.length))];
var Kc2 = ((a2) => (a2[a2.Financial = 0] = "Financial", a2[a2.Date = 1] = "Date", a2[a2.Math = 2] = "Math", a2[a2.Statistical = 3] = "Statistical", a2[a2.Lookup = 4] = "Lookup", a2[a2.Database = 5] = "Database", a2[a2.Text = 6] = "Text", a2[a2.Logical = 7] = "Logical", a2[a2.Information = 8] = "Information", a2[a2.Engineering = 9] = "Engineering", a2[a2.Cube = 10] = "Cube", a2[a2.Compatibility = 11] = "Compatibility", a2[a2.Web = 12] = "Web", a2[a2.Array = 13] = "Array", a2[a2.Univer = 14] = "Univer", a2[a2.User = 15] = "User", a2[a2.DefinedName = 16] = "DefinedName", a2[a2.Table = 17] = "Table", a2))(Kc2 || {});
var Z3 = ((a2) => (a2.PLUS = "+", a2.MINUS = "-", a2.MULTIPLY = "*", a2.DIVIDED = "/", a2.CONCATENATE = "&", a2.POWER = "^", a2.EQUALS = "=", a2.NOT_EQUAL = "<>", a2.GREATER_THAN = ">", a2.GREATER_THAN_OR_EQUAL = ">=", a2.LESS_THAN = "<", a2.LESS_THAN_OR_EQUAL = "<=", a2))(Z3 || {});
var Y2 = ((a2) => (a2.EQUALS = "=", a2.NOT_EQUAL = "<>", a2.GREATER_THAN = ">", a2.GREATER_THAN_OR_EQUAL = ">=", a2.LESS_THAN = "<", a2.LESS_THAN_OR_EQUAL = "<=", a2))(Y2 || {});
var dn = /* @__PURE__ */ new Map([
  ["<>", 4],
  ["<", 4],
  [">=", 4],
  ["=", 4],
  [">", 4],
  ["<=", 4],
  ["&", 3],
  ["+", 2],
  ["-", 2],
  ["/", 1],
  ["*", 1],
  ["^", 0]
  // ^
]);
var Mt = new Set(dn.keys());
var Zc = /* @__PURE__ */ new Set([
  "=",
  "<>",
  ">",
  ">=",
  "<",
  "<="
  /* LESS_THAN_OR_EQUAL */
]);
var X2 = ((a2) => (a2.OPEN_BRACKET = "(", a2.CLOSE_BRACKET = ")", a2.COMMA = ",", a2.SINGLE_QUOTATION = "'", a2.DOUBLE_QUOTATION = '"', a2.OPEN_BRACES = "{", a2.CLOSE_BRACES = "}", a2.COLON = ":", a2.OPEN_SQUARE_BRACKET = "[", a2.CLOSE_SQUARE_BRACKET = "]", a2))(X2 || {});
var nt = ((a2) => (a2.PERCENTAGE = "%", a2.POUND = "#", a2))(nt || {});
var Rs = /* @__PURE__ */ new Set([
  "%",
  "#"
  /* POUND */
]);
var we2 = ((a2) => (a2.AT = "@", a2.MINUS = "-", a2.PLUS = "+", a2))(we2 || {});
var zc = " ";
var go = [
  ...Object.values(Y2),
  ...Object.values(Z3),
  ...Object.values(X2),
  ...Object.values(nt),
  ...Object.values(we2)
];
function Cn2(a2) {
  return go.includes(a2);
}
function Jc(a2) {
  for (const i of go)
    if (a2.indexOf(i) > -1)
      return true;
  return false;
}
function vb(a2) {
  return a2[0] === "'" && a2[a2.length - 1] === "'" ? a2.substring(1, a2.length - 1) : a2;
}
function Tb(a2) {
  return Cn2(a2) && a2 !== X2.CLOSE_BRACES && a2 !== X2.CLOSE_BRACKET && a2 !== X2.SINGLE_QUOTATION && a2 !== X2.DOUBLE_QUOTATION || a2 === " ";
}
var el = /* @__PURE__ */ new Set([
  Z3.PLUS,
  Z3.MINUS,
  Z3.MULTIPLY,
  Z3.DIVIDED,
  Z3.CONCATENATE,
  Z3.POWER,
  Z3.EQUALS,
  Z3.NOT_EQUAL,
  Z3.GREATER_THAN,
  Z3.GREATER_THAN_OR_EQUAL,
  Z3.LESS_THAN,
  Z3.LESS_THAN_OR_EQUAL,
  X2.OPEN_BRACKET,
  X2.COMMA,
  X2.COLON,
  X2.OPEN_BRACES,
  X2.OPEN_SQUARE_BRACKET
]);
function tl(a2) {
  return el.has(a2);
}
var rl = /* @__PURE__ */ new Set([
  Z3.PLUS,
  Z3.MINUS,
  Z3.MULTIPLY,
  Z3.DIVIDED,
  Z3.CONCATENATE,
  Z3.POWER,
  Z3.EQUALS,
  Z3.NOT_EQUAL,
  Z3.GREATER_THAN,
  Z3.GREATER_THAN_OR_EQUAL,
  Z3.LESS_THAN,
  Z3.LESS_THAN_OR_EQUAL,
  X2.OPEN_BRACKET,
  X2.COMMA,
  X2.COLON,
  X2.OPEN_BRACES,
  X2.OPEN_SQUARE_BRACKET,
  nt.PERCENTAGE,
  nt.POUND
]);
function nl(a2) {
  return rl.has(a2);
}
var Dr = '\\[([^\\[\\]\\/?:"<>|*\\\\]+)\\]';
var oi = new RegExp(Dr);
var sl = "((?![\\[\\]\\/?*\\\\]).)*!";
var $t = "$";
var es = "\\s*?:\\s*?";
var Nn = "[A-Za-z]+";
var Vn = "[1-9][0-9]*";
var wr = `'?(${Dr})?(${sl})?'?`;
var Us = `\\${$t}?${Nn}\\${$t}?${Vn}`;
var al = `^(${we2.AT})?${wr}${Us}${es}${Us}$`;
var ui = new RegExp(al);
var il = `^${wr}\\s*?${Us}(${nt.POUND})?$`;
var ci = new RegExp(il);
var ol = `^${wr}\\${$t}?${Vn}${es}\\${$t}?${Vn}$`;
var li = new RegExp(ol);
var ul = `^${wr}\\${$t}?${Nn}${es}\\${$t}?${Nn}$`;
var fi = new RegExp(ul);
var cl = `^${wr}\\s*?\\${$t}?${Vn}$`;
var mi = new RegExp(cl);
var ll = `^${wr}\\s*?\\${$t}?${Nn}$`;
var hi = new RegExp(ll);
var Br = "((?![~!@#$%^&*()_+<>?:,./;’，。、‘：“《》？~！@#￥%……（）【】\\[\\]\\/\\\\]).)+";
var Co = "\\[#.+\\]\\s*?,\\s*?";
var On = "\\[((?<!#).)*\\]";
var gi = `${On}${es}${On}`;
var fl = `^(${Dr})?${Br}$`;
var ml = `^(${Dr})?${Br}(${On}|\\[${Co}${On}\\])+$`;
var hl = `^(${Dr})?${Br}(\\[${gi}\\])?$|^${Br}(\\[${Co}${gi}\\])?$`;
var gl = `^(${Dr})?${Br}\\[\\s*#([^\\]]+)\\s*\\]$`;
var di = new RegExp(fl);
var Ci = new RegExp(ml);
var _i = new RegExp(hl);
var Ai = new RegExp(gl);
var dl = "{.*?}";
var Ei = new RegExp(dl, "g");
function qr(a2) {
  return ci.lastIndex = 0, ci.test(a2);
}
function Cl(a2) {
  return ui.lastIndex = 0, ui.test(a2);
}
function _o(a2) {
  return li.lastIndex = 0, li.test(a2);
}
function Ao(a2) {
  return fi.lastIndex = 0, fi.test(a2);
}
function Eo(a2) {
  return mi.lastIndex = 0, mi.test(a2);
}
function Ro(a2) {
  return hi.lastIndex = 0, hi.test(a2);
}
function _l(a2) {
  return di.lastIndex = 0, di.test(a2);
}
function Al(a2) {
  return Ci.lastIndex = 0, Ci.test(a2);
}
function El(a2) {
  return _i.lastIndex = 0, _i.test(a2);
}
function Rl(a2) {
  return Ai.lastIndex = 0, Ai.test(a2);
}
function bl(a2) {
  return Ei.lastIndex = 0, Ei.test(a2);
}
function bo(a2) {
  return qr(a2) || Cl(a2) || _o(a2) || Ao(a2);
}
function yl2(a2) {
  const i = {};
  return Object.keys(a2).forEach((e) => {
    const t = a2[e];
    if (t == null)
      return true;
    i[e] == null && (i[e] = {}), Object.keys(t).forEach((r) => {
      const n = t[r];
      i[e][r] = new ht(n);
    });
  }), i;
}
function pl(a2) {
  const i = {};
  for (const e in a2) {
    const t = a2[e];
    if (t != null) {
      i[e] == null && (i[e] = {});
      for (const r in t) {
        const n = t[r], s = {};
        n.forValue((o, u, c) => {
          s[o] === void 0 && (s[o] = {}), s[o][u] = c;
        }), i[e][r] = s;
      }
    }
  }
  return i;
}
var At = "P_1";
var Ft = "R_1";
var Rr = "L_1";
var Xr = "LR_1";
var yo = "LO_1";
var Nl = "LET";
var Fr = "LAMBDA";
var Vl = "CUBE";
var Ol = /* @__PURE__ */ new Set(["RAND", "RANDBETWEEN", "NOW", "TODAY"]);
var Sl = {
  id: "formula.mutation.register-function",
  type: Ls.MUTATION,
  handler: () => true
};
var vs = {
  id: "formula.mutation.set-array-formula-data",
  type: Ls.MUTATION,
  handler: (a2, i) => true
};
var Ml = /[^0-9]/g;
var Dl = /[^A-Za-z]/g;
function _n(a2) {
  let i = a2[0] === "$";
  const e = a2.substring(1);
  let t = e.indexOf("$") > -1;
  return Z.isStringNumber(e) && i && !t && (i = false, t = true), i && t ? ye.ALL : i ? ye.COLUMN : t ? ye.ROW : ye.NONE;
}
function Ib(a2) {
  const i = a2.split("!");
  i.length > 1 && (a2 = i[i.length - 1]);
  const e = a2.split(":");
  return e.length > 1 ? {
    startAbsoluteRefType: _n(e[0]),
    endAbsoluteRefType: _n(e[1])
  } : { startAbsoluteRefType: _n(e[0]) };
}
function Ri(a2 = ye.NONE) {
  let i = "", e = "";
  return a2 === ye.ROW ? i = "$" : a2 === ye.COLUMN ? e = "$" : a2 === ye.ALL && (i = "$", e = "$"), {
    rowAbsoluteString: i,
    columnAbsoluteString: e
  };
}
function Yt(a2) {
  const {
    startColumn: i,
    startRow: e,
    endColumn: t,
    endRow: r,
    startAbsoluteRefType: n,
    endAbsoluteRefType: s,
    rangeType: o = ge.NORMAL
  } = a2, u = Ri(n), c = Ri(s);
  if (o === ge.ROW || o === ge.ALL) {
    const m2 = `${u.rowAbsoluteString}${e + 1}`, d2 = `${c.rowAbsoluteString}${r + 1}`;
    return `${m2}:${d2}`;
  }
  if (o === ge.COLUMN) {
    const m2 = `${u.columnAbsoluteString}${Z.chatAtABC(i)}`, d2 = `${c.columnAbsoluteString}${Z.chatAtABC(t)}`;
    return `${m2}:${d2}`;
  }
  const l = `${u.columnAbsoluteString}${Z.chatAtABC(i)}${u.rowAbsoluteString}${e + 1}`, f2 = `${c.columnAbsoluteString}${Z.chatAtABC(t)}${c.rowAbsoluteString}${r + 1}`;
  return l === f2 ? l : `${l}:${f2}`;
}
function wl(a2, i) {
  return `${No(a2)}!${Yt(i)}`;
}
function Ll(a2, i, e) {
  return Is(a2) || Is(i) ? `'[${Bs(a2)}]${Bs(i)}'!${Yt(e)}` : `[${a2}]${i}!${Yt(e)}`;
}
function Ts2(a2) {
  const { unitId: i, sheetName: e, range: t } = a2;
  return i != null && i.length > 0 && e != null && e.length > 0 ? Ll(i, e, t) : e != null && e.length > 0 ? wl(e, t) : Yt(t);
}
function bs(a2) {
  const i = Number.parseInt(a2.replace(Ml, "")) - 1, e = Z.ABCatNum(a2.replace(Dl, "")), t = _n(a2);
  return {
    row: i,
    column: e,
    absoluteRefType: t
  };
}
function Ca(a2) {
  const i = oi.exec(a2);
  let e = "";
  i != null && (e = i[0].trim(), e = bi(e.slice(1, e.length - 1)), a2 = a2.replace(oi, ""));
  const t = a2.indexOf("!");
  let r = "", n = "";
  return t > -1 ? (r = a2.substring(0, t), r[0] === "'" && r[r.length - 1] === "'" && (r = r.substring(1, r.length - 1)), r = bi(r), n = a2.substring(t + 1)) : n = a2, {
    refBody: n,
    sheetName: r,
    unitId: e
  };
}
function kr(a2) {
  const { refBody: i, sheetName: e, unitId: t } = Ca(a2), r = i.indexOf(":");
  if (r === -1) {
    const _2 = bs(i), C = _2.row, E = _2.column, R = _2.absoluteRefType;
    return {
      unitId: t,
      sheetName: e,
      range: {
        startRow: C,
        startColumn: E,
        endRow: C,
        endColumn: E,
        startAbsoluteRefType: R,
        endAbsoluteRefType: R
      }
    };
  }
  const n = i.substring(0, r), s = i.substring(r + 1), o = bs(n), u = bs(s), c = o.row > u.row ? u.row : o.row, l = o.column > u.column ? u.column : o.column, f2 = o.row > u.row ? o.row : u.row, m2 = o.column > u.column ? o.column : u.column;
  let d2 = ge.NORMAL;
  return Number.isNaN(c) && Number.isNaN(f2) ? d2 = ge.COLUMN : Number.isNaN(l) && Number.isNaN(m2) && (d2 = ge.ROW), {
    unitId: t,
    sheetName: e,
    range: {
      startRow: c,
      startColumn: l,
      endRow: f2,
      endColumn: m2,
      startAbsoluteRefType: o.absoluteRefType,
      endAbsoluteRefType: u.absoluteRefType,
      rangeType: d2
    }
  };
}
var Pl = ["LOG10"];
function An(a2) {
  const i = po(a2);
  if (!bo(i) || Pl.includes(i.toUpperCase().trim()))
    return false;
  const { range: e } = kr(i);
  return !(e.endColumn >= 16384);
}
function po(a2) {
  const i = [];
  let e = false;
  for (let t = 0, r = a2.length; t < r; t++) {
    const n = a2[t];
    if (n === zc && !e)
      i.push(n);
    else {
      if (!e && (n === we2.AT || n === we2.MINUS || n === we2.PLUS))
        continue;
      i.push(n), e = true;
    }
  }
  return i.join("");
}
function Bb(a2, i) {
  const e = (a2 == null ? void 0 : a2.split(",")) || [];
  return a2 === "" || e.length === 0 ? [] : xl(a2) ? e.map((n) => {
    const s = kr(n);
    return {
      unitId: s.unitId,
      sheetId: i(s.sheetName),
      range: s.range,
      sheetName: s.sheetName
    };
  }) : [];
}
function xl(a2) {
  return ((a2 == null ? void 0 : a2.split(",")) || []).every((e) => An(e.trim()));
}
function Is(a2) {
  return a2.length === 0 ? false : !!(Jc(a2) || jl(a2) || Ul(a2) || vl(a2) || /[\s!$%^&*()+\-=\[\]{};':"\\|,.<>\/?（）]/.test(a2));
}
function No(a2) {
  return Is(a2) ? `'${Bs(a2)}'` : a2;
}
function Bs(a2) {
  return a2.replace(/'/g, "''");
}
function bi(a2) {
  return a2.replace(/''/g, "'");
}
function jl(a2) {
  const i = a2.match(/[1-9][0-9]{0,6}/);
  return /^[A-Z]+[1-9][0-9]{0,6}$/.test(a2) && i !== null;
}
function Ul(a2) {
  return /^(R(-?[0-9]+)?C(-?[0-9]+)?|C(-?[0-9]+)?|R(-?[0-9]+)?)$/.test(a2);
}
function vl(a2) {
  return !new RegExp("^\\p{Letter}", "u").test(a2.charAt(0));
}
var Tl = Object.getOwnPropertyDescriptor;
var Il = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Tl(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var Bl = (a2, i) => (e, t) => i(e, t, a2);
var Fs = class extends Ve {
  constructor(i) {
    super();
    A(this, "_definedNameMap", {});
    A(this, "_nameCacheMap", {});
    A(this, "_update$", new Subject());
    A(this, "update$", this._update$.asObservable());
    A(this, "_currentRange", {
      unitId: "",
      sheetId: "",
      range: {
        startRow: 0,
        endRow: 0,
        startColumn: 0,
        endColumn: 0
      }
    });
    A(this, "_currentRange$", new Subject());
    A(this, "currentRange$", this._currentRange$.asObservable());
    A(this, "_focusRange$", new Subject());
    A(this, "focusRange$", this._focusRange$.asObservable());
    this._univerInstanceService = i;
  }
  dispose() {
    super.dispose(), this._definedNameMap = {}, this._nameCacheMap = {}, this._update$.complete(), this._currentRange$.complete(), this._focusRange$.complete();
  }
  getWorksheetByRef(i, e) {
    var r;
    const { sheetName: t } = Ca(e);
    return (r = this._univerInstanceService.getUnit(i)) == null ? void 0 : r.getSheetBySheetName(t);
  }
  focusRange(i, e) {
    const t = this.getValueById(i, e);
    t !== void 0 && this._focusRange$.next(__spreadProps(__spreadValues({}, t), { unitId: i }));
  }
  setCurrentRange(i) {
    this._currentRange = i, this._currentRange$.next(i);
  }
  getCurrentRange() {
    return this._currentRange;
  }
  getCurrentRangeForString() {
    return Yt(this._currentRange.range);
  }
  registerDefinedNames(i, e) {
    this._definedNameMap[i] = e, this._updateCache(i), this._update();
  }
  registerDefinedName(i, e) {
    this._definedNameMap[i] === void 0 && (this._definedNameMap[i] = {}), this._definedNameMap[i][e.id] = e, this._updateCache(i), this._update();
  }
  removeDefinedName(i, e) {
    var t;
    (t = this._definedNameMap[i]) == null || delete t[e], this._updateCache(i), this._update();
  }
  removeUnitDefinedName(i) {
    delete this._definedNameMap[i], this._updateCache(i), this._update();
  }
  getDefinedNameMap(i) {
    return this._definedNameMap[i];
  }
  getValueByName(i, e) {
    const t = this._nameCacheMap[i];
    if (t)
      return t[e] || null;
    const r = this._definedNameMap[i];
    if (r === void 0)
      return null;
    let n = null;
    for (const s of Object.values(r))
      if (s.name === e) {
        n = s;
        break;
      }
    return n && (this._nameCacheMap[i] = this._nameCacheMap[i] || {}, this._nameCacheMap[i][e] = n), n;
  }
  getValueById(i, e) {
    var t;
    return (t = this._definedNameMap[i]) == null ? void 0 : t[e];
  }
  hasDefinedName(i) {
    return this._definedNameMap[i] === void 0 ? false : (Array.from(Object.values(this._definedNameMap[i])).length || 0) !== 0;
  }
  getAllDefinedNames() {
    return this._definedNameMap;
  }
  _update() {
    this._update$.next(null);
  }
  _updateCache(i) {
    const e = this._definedNameMap[i];
    if (e === void 0) {
      delete this._nameCacheMap[i];
      return;
    }
    this._nameCacheMap[i] = {};
    for (const t of Object.values(e))
      this._nameCacheMap[i][t.name] = t;
  }
};
Fs = Il([
  Bl(0, br)
], Fs);
var Lr = createIdentifier("univer.formula.defined-names.service");
var Fb = (a2, i) => {
  const { unitId: e, id: t } = i;
  return __spreadProps(__spreadValues({}, a2.get(Lr).getValueById(e, t)), {
    unitId: e
  });
};
var _a = {
  id: "formula.mutation.set-defined-name",
  type: Ls.MUTATION,
  handler: (a2, i) => {
    if (i == null)
      return false;
    const e = a2.get(Lr), { id: t, unitId: r, name: n, formulaOrRefString: s, comment: o, hidden: u, localSheetId: c, formulaOrRefStringWithPrefix: l } = i;
    return e.registerDefinedName(r, {
      id: t,
      name: n.trim(),
      formulaOrRefString: s.trim(),
      comment: o == null ? void 0 : o.trim(),
      hidden: u,
      localSheetId: c,
      formulaOrRefStringWithPrefix: l
    }), true;
  }
};
var Vo = {
  id: "formula.mutation.remove-defined-name",
  type: Ls.MUTATION,
  handler: (a2, i) => {
    if (i == null)
      return false;
    const e = a2.get(Lr), { unitId: t, id: r } = i;
    return e.removeDefinedName(t, r), true;
  }
};
var Aa = {
  id: "formula.mutation.set-feature-calculation",
  type: Ls.MUTATION,
  handler: () => true
};
var Ea = {
  id: "formula.mutation.remove-feature-calculation",
  type: Ls.MUTATION,
  handler: () => true
};
var Oo = {
  id: "formula.mutation.set-formula-calculation-start",
  type: Ls.MUTATION,
  handler: () => true
};
var So = {
  id: "formula.mutation.set-formula-calculation-stop",
  type: Ls.MUTATION,
  handler: () => true
};
var Sn = {
  id: "formula.mutation.set-formula-calculation-notification",
  type: Ls.MUTATION,
  handler: () => true
};
var Mo = {
  id: "formula.mutation.set-formula-calculation-result",
  type: Ls.MUTATION,
  handler: () => true
};
var Do = {
  id: "formula.mutation.set-formula-data",
  type: Ls.MUTATION,
  handler: (a2, i) => true
};
var wo = {
  id: "formula.mutation.set-image-formula-data",
  type: Ls.MUTATION,
  handler: (a2, i) => true
};
var Ra = {
  id: "formula.mutation.set-other-formula",
  type: Ls.MUTATION,
  handler: () => true
};
var ba = {
  id: "formula.mutation.remove-other-formula",
  type: Ls.MUTATION,
  handler: () => true
};
var Fl = class extends Ve {
  constructor() {
    super();
    A(this, "_tableMap", /* @__PURE__ */ new Map());
    A(this, "_tableOptionMap", /* @__PURE__ */ new Map());
    A(this, "_update$", new Subject());
    A(this, "update$", this._update$.asObservable());
    this.registerTableOptionMap(De.ALL, De.ALL), this.registerTableOptionMap(De.DATA, De.DATA), this.registerTableOptionMap(De.HEADERS, De.HEADERS), this.registerTableOptionMap(De.TOTALS, De.TOTALS), this.registerTableOptionMap(De.THIS_ROW, De.THIS_ROW);
  }
  dispose() {
    super.dispose(), this._update$.complete(), this._tableMap.clear(), this._tableOptionMap.clear();
  }
  remove(e, t) {
    var r;
    (r = this._tableMap.get(e)) == null || r.delete(t), this._update();
  }
  getTableMap(e) {
    return this._tableMap.get(e);
  }
  getTableOptionMap() {
    return this._tableOptionMap;
  }
  registerTable(e, t, r) {
    var n;
    this._tableMap.get(e) == null && this._tableMap.set(e, /* @__PURE__ */ new Map()), (n = this._tableMap.get(e)) == null || n.set(t, r), this._update();
  }
  registerTableOptionMap(e, t) {
    this._tableOptionMap.set(e, t);
  }
  _update() {
    this._update$.next(null);
  }
};
var Pr = createIdentifier("univer.formula.super-table.service");
var kl = {
  id: "formula.mutation.set-super-table",
  type: Ls.MUTATION,
  handler: (a2, i) => {
    const { unitId: e, tableName: t, reference: r } = i;
    return a2.get(Pr).registerTable(e, t, r), true;
  }
};
var $l = {
  id: "formula.mutation.remove-super-table",
  type: Ls.MUTATION,
  handler: (a2, i) => {
    const { unitId: e, tableName: t } = i;
    return a2.get(Pr).remove(e, t), true;
  }
};
var Lo = {
  id: "formula.mutation.set-super-table-option",
  type: Ls.MUTATION,
  handler: (a2, i) => {
    const { tableOption: e, tableOptionType: t } = i;
    return a2.get(Pr).registerTableOptionMap(e, t), true;
  }
};
var xt = class {
  constructor(i) {
    A(this, "_cache");
    this._cache = new _s(i);
  }
  set(i, e) {
    const t = this._hash(i);
    this._cache.set(t, e);
  }
  get(i) {
    const e = this._hash(i);
    return this._cache.get(e);
  }
  clear() {
    this._cache.clear();
  }
  delete(i) {
    this._cache.delete(this._hash(i));
  }
  forEach(i, e) {
    this._cache.forEach(i, e);
  }
  _hash(i) {
    return i.length <= 64 ? i : i1(i).toString();
  }
};
var ks = new xt(1e5);
function br2(a2) {
  const i = ks.get(a2);
  if (i)
    return i;
  const e = kr(a2);
  return ks.set(a2, e), kr(a2);
}
function Yl() {
  ks.clear();
}
var He = ((a2) => (a2[a2.NORMAL = 0] = "NORMAL", a2[a2.NUMBER = 1] = "NUMBER", a2[a2.STRING = 2] = "STRING", a2[a2.FUNCTION = 3] = "FUNCTION", a2[a2.REFERENCE = 4] = "REFERENCE", a2[a2.ARRAY = 5] = "ARRAY", a2[a2.DEFINED_NAME = 6] = "DEFINED_NAME", a2))(He || {});
function yi(a2) {
  let i = "";
  for (const e of a2)
    typeof e == "string" ? i += e : i += e.token;
  return i;
}
var ie2 = class _ie {
  constructor() {
    A(this, "_parent");
    A(this, "_token", Ft);
    A(this, "_children", []);
    A(this, "_lambdaId");
    A(this, "_functionDefinitionPrivacyVar");
    A(this, "_lambdaParameter", "");
    A(this, "_startIndex", -1);
    A(this, "_endIndex", -1);
    A(this, "_definedNames", []);
  }
  dispose() {
    var i;
    this._children.forEach((e) => {
      typeof e != "string" && e.dispose();
    }), (i = this._functionDefinitionPrivacyVar) == null || i.clear(), this._functionDefinitionPrivacyVar = null, this._children = [], this._parent = null, this._definedNames = [];
  }
  getDefinedNames() {
    return this._definedNames;
  }
  getStartIndex() {
    return this._startIndex;
  }
  getLambdaId() {
    return this._lambdaId;
  }
  setLambdaId(i) {
    this._lambdaId = i;
  }
  getFunctionDefinitionPrivacyVar() {
    return this._functionDefinitionPrivacyVar;
  }
  setLambdaPrivacyVar(i) {
    this._functionDefinitionPrivacyVar = i;
  }
  getLambdaParameter() {
    return this._lambdaParameter;
  }
  setLambdaParameter(i) {
    this._lambdaParameter = i;
  }
  getParent() {
    return this._parent;
  }
  setParent(i) {
    this._parent = i;
  }
  getChildren() {
    return this._children;
  }
  setChildren(i) {
    this._children = i;
  }
  addChildren(i) {
    this._children.push(i);
  }
  addChildrenFirst(i) {
    this._children.unshift(i);
  }
  getToken() {
    return this._token;
  }
  setToken(i) {
    this._token = i;
  }
  setIndex(i, e) {
    this._startIndex = i, this._endIndex = e;
  }
  setDefinedNames(i) {
    this._definedNames = i;
  }
  hasDefinedNames() {
    return this._definedNames.length > 0;
  }
  replaceChild(i, e) {
    const t = this._getIndexInParent(i);
    t != null && (this.getChildren().splice(t, 1, e), e.setParent(this));
  }
  changeToParent(i) {
    const e = this.getParent();
    e && e.removeChild(this), this.setParent(i), i.getChildren().push(this);
  }
  removeChild(i) {
    const e = this._getIndexInParent(i);
    e != null && this.getChildren().splice(e, 1);
  }
  serialize() {
    const i = this.getToken(), e = this.getChildren(), t = [], r = e.length;
    for (let n = 0; n < r; n++) {
      const s = e[n];
      s instanceof _ie ? t.push(s.serialize()) : t.push(s);
    }
    return {
      token: i,
      st: this._startIndex,
      ed: this._endIndex,
      children: t
    };
  }
  _getIndexInParent(i) {
    const e = this.getChildren(), t = e.length;
    for (let r = 0; r < t; r++)
      if (e[r] === i)
        return r;
  }
};
var Po = 2e3;
var ys = new xt(Po);
var ps = new xt(Po);
var Mn = class extends Ve {
  constructor() {
    super(...arguments);
    A(this, "_currentLexerNode", new ie2());
    A(this, "_upLevel", 0);
    A(this, "_segment", "");
    A(this, "_bracketState", []);
    A(this, "_squareBracketState", 0);
    A(this, "_bracesState", 0);
    A(this, "_singleQuotationState", 0);
    A(this, "_doubleQuotationState", 0);
    A(this, "_lambdaState", false);
    A(this, "_colonState", false);
    A(this, "_formulaErrorCount", 0);
    A(this, "_tableBracketState", false);
  }
  // Table3[[#All],[Column1]:[Column2]]
  dispose() {
    this._resetTemp(), this._currentLexerNode.dispose(), ys.clear(), ps.clear();
  }
  getUpLevel() {
    return this._upLevel;
  }
  isColonClose() {
    return this._colonState === false;
  }
  isColonOpen() {
    return this._colonState === true;
  }
  isDoubleQuotationClose() {
    return this._doubleQuotationState === 0;
  }
  isLambdaOpen() {
    return this._lambdaState === true;
  }
  isLambdaClose() {
    return this._lambdaState === false;
  }
  isSingleQuotationClose() {
    return this._singleQuotationState === 0;
  }
  isBracesClose() {
    return this._bracesState === 0;
  }
  isBracketClose() {
    return this._bracketState.length === 0;
  }
  isSquareBracketClose() {
    return this._squareBracketState === 0;
  }
  getCurrentLexerNode() {
    return this._currentLexerNode;
  }
  getFunctionAndParameter(e, t) {
    const r = this._getCurrentParamIndex(e, t);
    if (r == null || r === h.VALUE)
      return;
    const n = r[0];
    if (typeof n == "string")
      return;
    let s = n.getParent(), o = n;
    for (; s; ) {
      const u = s.getToken();
      if (u !== At && !Cn2(u) && s.getStartIndex() !== -1) {
        const c = s.getChildren().indexOf(o);
        return {
          functionName: u,
          paramIndex: c
        };
      }
      o = s, s = s.getParent();
    }
  }
  /**
   * Estimate the number of right brackets that need to be automatically added to the end of the formula.
   * @param formulaString
   */
  checkIfAddBracket(e) {
    let t = 0, r = e.length - 1, n = e[r];
    for (; (n === X2.CLOSE_BRACKET || n === " ") && r >= 0; )
      n === X2.CLOSE_BRACKET && t++, n = e[--r];
    const s = this._getCurrentParamIndex(e, e.length - 2);
    if (s == null || s === h.VALUE)
      return 0;
    const o = s[0];
    if (typeof o == "string")
      return 0;
    let u = o.getParent(), c = 0;
    for (s[1] === X2.OPEN_BRACKET && c++; u; ) {
      const l = u.getToken();
      l !== At && l !== X2.COLON && u.getStartIndex() !== -1 && l.toUpperCase() !== Fr && (t === 0 ? c += 1 : t--), u = u.getParent();
    }
    return c;
  }
  sequenceNodesBuilder(e) {
    const t = ps.get(e);
    if (t)
      return [...t];
    const r = this._getSequenceArray(e);
    if (r.length === 0)
      return;
    const n = this.getSequenceNode(r);
    return ps.set(e, [...n]), n;
  }
  convertRefersToAbsolute(e, t, r, n = "") {
    const s = this.sequenceNodesBuilder(e);
    if (s == null)
      return e;
    let o = "";
    e.substring(0, 1) === Z3.EQUALS && (o = Z3.EQUALS);
    for (let u = 0, c = s.length; u < c; u++) {
      const l = s[u];
      if (typeof l != "string" && l.nodeType === He.REFERENCE) {
        const { token: f2, endIndex: m2 } = l, d2 = br2(f2);
        if (d2 == null)
          continue;
        const { range: _2, sheetName: C, unitId: E } = d2, R = __spreadProps(__spreadValues({}, _2), {
          startAbsoluteRefType: t,
          endAbsoluteRefType: r
        }), b = Ts2({
          range: R,
          unitId: E,
          sheetName: C || n
        }), p2 = b.length - f2.length;
        s[u] = __spreadProps(__spreadValues({}, l), {
          token: b,
          endIndex: m2 + p2
        });
        for (let V = u + 1; V < c; V++) {
          const S2 = s[V];
          typeof S2 != "string" && (S2.startIndex += p2, S2.endIndex += p2);
        }
      }
    }
    return `${o}${yi(s)}`;
  }
  moveFormulaRefOffset(e, t, r, n = false) {
    const s = this.sequenceNodesBuilder(e);
    if (s == null)
      return e;
    const o = [];
    for (let u = 0, c = s.length; u < c; u++) {
      const l = s[u];
      if (typeof l == "string" || l.nodeType !== He.REFERENCE) {
        o.push(l);
        continue;
      }
      const { token: f2 } = l, m2 = br2(f2), { sheetName: d2, unitId: _2 } = m2;
      let C = m2.range;
      if (!n && C.startAbsoluteRefType === ye.ALL && C.endAbsoluteRefType === ye.ALL) {
        o.push(l);
        continue;
      } else
        C = w1(C, t, r, n);
      let E = "";
      ZR(C) ? E = Ts2({
        range: C,
        unitId: _2,
        sheetName: d2
      }) : E = h.REF, o.push(__spreadProps(__spreadValues({}, l), {
        token: E
      }));
    }
    return `=${yi(o)}`;
  }
  /**
   * univer-pro/issues/1684
   * =sum({}{})
   */
  _formulaSpellCheck() {
    if (this._currentLexerNode.getChildren().length === 0)
      return true;
    const e = this._currentLexerNode.getChildren()[0];
    return e instanceof ie2 ? true : !!(this._passArrayOperator(e) || Mt.has(e) || Rs.has(e) || e === we2.AT || e === X2.COMMA || e === X2.COLON || e === X2.OPEN_BRACKET);
  }
  /**
   * ={0,1,2,3,4,5,6} + {0;1;2;3;4;5;6}*7
   */
  _passArrayOperator(e) {
    if (e.length === 0 || !(e[0] === "{" && e[e.length - 1] === "}"))
      return false;
    const t = this._currentLexerNode.getChildren(), r = t[t.length - 1];
    return r instanceof ie2 ? false : !!Mt.has(r);
  }
  // eslint-disable-next-line complexity
  getSequenceNode(e) {
    const t = [];
    let r = false;
    for (let n = 0, s = e.length; n < s; n++) {
      const o = e[n], u = e[n - 1], { segment: c, currentString: l } = o;
      if (l === X2.DOUBLE_QUOTATION && (r = true), (c !== "" || n === 0) && n !== s - 1) {
        t.push(l);
        continue;
      }
      let f2 = (u == null ? void 0 : u.segment) || "";
      const m2 = n - f2.length;
      let d2 = n - 1;
      const _2 = n - 1;
      if (n === s - 1 && this._isLastMergeString(l) && (f2 += l, d2 += 1), f2 === "" || dn.has(f2)) {
        t.push(l);
        continue;
      }
      const C = f2.trim(), E = po(C);
      r === true && C[C.length - 1] === X2.DOUBLE_QUOTATION && C[0] !== X2.OPEN_BRACES ? (r = false, this._processPushSequenceNode(t, He.STRING, f2, m2, d2, _2)) : qr(E) && An(E) ? this._processPushSequenceNode(t, He.REFERENCE, f2, m2, d2, _2) : Z.isStringNumber(C) ? this._processPushSequenceNode(t, He.NUMBER, f2, m2, d2, _2) : C.length > 0 && this._processPushSequenceNode(t, He.FUNCTION, f2, m2, d2, _2), (n !== s - 1 || !this._isLastMergeString(l)) && t.push(l);
    }
    return this._mergeSequenceNodeReference(t);
  }
  _processPushSequenceNode(e, t, r, n, s, o) {
    this._pushSequenceNode(
      e,
      {
        nodeType: t,
        token: r,
        startIndex: n,
        endIndex: s
      },
      o
    );
  }
  _getCurrentParamIndex(e, t) {
    return this._nodeMaker(e, void 0, t);
  }
  _isLastMergeString(e) {
    return e === X2.DOUBLE_QUOTATION || Z.isStringNumber(e) || !Cn2(e);
  }
  /**
   * Merge array and handle ref operations
   *
   */
  _mergeSequenceNodeReference(e) {
    const t = [], r = e.length;
    let n = 0;
    for (; n < r; ) {
      const s = e[n];
      if (typeof s == "string") {
        const o = e[n - 1];
        if (s.trim() === X2.CLOSE_BRACES && o != null && typeof o != "string" && o.nodeType === He.FUNCTION && o.token.trim().substring(0, 1) === X2.OPEN_BRACES) {
          o.nodeType = He.ARRAY, o.token += s, o.endIndex += s.length, n++;
          continue;
        }
        t.push(s);
      } else {
        const o = e[n + 1], u = e[n + 2];
        o === X2.COLON && typeof s != "string" && u != null && typeof u != "string" && An((s.token + o + u.token).trim()) && (s.nodeType = He.REFERENCE, s.token += o + u.token, s.endIndex = u.endIndex, n += 2), t.push(s);
      }
      n++;
    }
    return this._minusSplitSequenceNode(t);
  }
  /**
   * =-A1  Separate the negative sign from the ref string.
   */
  _minusSplitSequenceNode(e) {
    const t = [];
    for (const r of e) {
      if (typeof r != "string") {
        const s = r.token.match(/^(\s*([-@+]\s*)+)(.*)$/);
        if (s) {
          const o = s[1], u = s[3];
          if (An(u.trim())) {
            const c = o.length, l = r.startIndex, f2 = r.startIndex + c - 1, m2 = {
              nodeType: He.NORMAL,
              // Use appropriate nodeType for operators
              token: o,
              startIndex: l,
              endIndex: f2
            }, d2 = {
              nodeType: He.REFERENCE,
              token: u,
              startIndex: f2 + 1,
              endIndex: r.endIndex
            };
            t.push(m2), t.push(d2);
            continue;
          }
        }
      }
      t.push(r);
    }
    return t;
  }
  _pushSequenceNode(e, t, r) {
    const n = r - t.startIndex + 1;
    e.splice(e.length - n, n, t);
  }
  nodeMakerTest(e) {
    return this._nodeMaker(e);
  }
  treeBuilder(e, t = true, r) {
    var f2;
    if (t === true) {
      const m2 = ys.get(e), d2 = r && ((f2 = this._simpleCheckDefinedName) == null ? void 0 : f2.call(this, e, r));
      if (m2 && !d2)
        return m2;
    }
    this._resetCurrentLexerNode(), this._currentLexerNode.setToken(Ft);
    const n = [];
    let s = this._nodeMaker(e, n);
    if (s === h.VALUE || n.length === 0)
      return s;
    let o = false, u = "", c = [];
    if (r) {
      const { hasDefinedName: m2, sequenceString: d2, definedNames: _2 } = this._handleDefinedName(n, r);
      o = m2, u = d2, c = _2;
    }
    if (o && (this._resetCurrentLexerNode(), this._currentLexerNode.setToken(Ft), s = this._nodeMaker(`=${u}`), s === h.VALUE))
      return s;
    const l = this._getTopNode(this._currentLexerNode);
    if (l && (this._currentLexerNode = l), t) {
      if (!this._suffixExpressionHandler(this._currentLexerNode))
        return h.VALUE;
      ys.set(e, this._currentLexerNode);
    }
    return o && this._currentLexerNode.setDefinedNames(c), this._currentLexerNode;
  }
  _handleDefinedName(e, t) {
    const { unitId: r, getValueByName: n, getSheetName: s } = t;
    if (r == null)
      return {
        sequenceString: "",
        hasDefinedName: false,
        definedNames: []
      };
    const o = this.getSequenceNode(e);
    let u = "", c = false;
    const l = [];
    for (let f2 = 0, m2 = o.length; f2 < m2; f2++) {
      const d2 = o[f2];
      if (typeof d2 == "string") {
        u += d2;
        continue;
      }
      const { nodeType: _2, token: C } = d2;
      let E = C;
      if (_2 === He.REFERENCE || _2 === He.FUNCTION) {
        _2 === He.FUNCTION && (E = this._getHasSheetNameDefinedName(C, r, t));
        const R = n(r, E);
        if (R) {
          const b = R.formulaOrRefString, p2 = this._handleNestedDefinedName(b, t);
          if (p2 == null || typeof p2 != "object")
            u += p2 || h.NAME, c = true, l.push(E);
          else if (typeof p2 == "object") {
            const { sequenceString: V, definedNames: S2 } = p2;
            u += V, S2.forEach((M2) => {
              l.push(M2);
            }), c = true;
          }
        } else this._checkDefinedNameDirty(E, t) ? (u += h.NAME, c = true, l.push(E)) : u += E;
      } else
        u += E;
    }
    return {
      sequenceString: u,
      hasDefinedName: c,
      definedNames: l
    };
  }
  _getHasSheetNameDefinedName(e, t, r) {
    if (!e.includes("!"))
      return e;
    const n = e.split("!");
    if (n.length !== 2)
      return e;
    const s = n[0], o = n[1].trim(), u = r.getValueByName(t, o);
    if (!u)
      return e;
    const c = u.localSheetId;
    if (c !== void 0) {
      if (c === "AllDefaultWorkbook")
        return o;
      const l = r.getSheetName(t, c);
      if (s === l)
        return o;
    } else
      return o;
    return e;
  }
  _handleNestedDefinedName(e, t) {
    const r = [], n = this._nodeMaker(e, r);
    return n === h.VALUE || r.length === 0 ? n : this._handleDefinedName(r, t);
  }
  _simpleCheckDefinedName(e, t) {
    const { getDirtyDefinedNameMap: r, unitId: n } = t, s = r(), o = n;
    if (o != null && s[o] != null) {
      const u = Object.keys(s[o]);
      for (let c = 0, l = u.length; c < l; c++) {
        const f2 = u[c];
        if (e.indexOf(f2) > -1)
          return true;
      }
    }
    return false;
  }
  _checkDefinedNameDirty(e, t) {
    const { getDirtyDefinedNameMap: r, unitId: n } = t, s = r(), o = n;
    if (o != null && s[o] != null) {
      const u = Object.keys(s[o]);
      for (let c = 0, l = u.length; c < l; c++)
        if (u[c] === e)
          return true;
    }
    return false;
  }
  // eslint-disable-next-line complexity
  _suffixExpressionHandler(e) {
    var u;
    const t = e.getChildren();
    if (!t)
      return false;
    const r = t.length, n = [], s = [];
    let o = true;
    for (let c = 0; c < r; c++) {
      const l = t[c];
      if (l instanceof ie2)
        o = this._suffixExpressionHandler(l), n.push(l);
      else {
        const f2 = l.trim();
        if (f2 === "")
          continue;
        if (Mt.has(f2)) {
          if (f2 === Z3.PLUS && this._deletePlusForPreNode(t[c - 1]))
            continue;
          if (f2 !== Z3.PLUS && f2 !== Z3.MINUS && this._deletePlusForPreNode(t[c - 1]))
            return false;
          for (; s.length > 0; ) {
            const m2 = (u = s[s.length - 1]) == null ? void 0 : u.trim();
            if (!m2 || m2 === X2.OPEN_BRACKET)
              break;
            const d2 = dn.get(m2), _2 = dn.get(f2);
            if (d2 === void 0 || _2 === void 0)
              break;
            if (_2 >= d2)
              n.push(s.pop());
            else
              break;
          }
          s.push(l);
        } else if (f2 === X2.OPEN_BRACKET)
          s.push(l);
        else if (f2 === X2.CLOSE_BRACKET)
          this._processSuffixExpressionCloseBracket(n, s, t, c);
        else {
          if (this._checkCloseBracket(t[c - 1]))
            return false;
          n.push(l);
        }
      }
    }
    return o ? this._processSuffixExpressionRemain(n, s, e) : false;
  }
  _processSuffixExpressionRemain(e, t, r) {
    const n = e.length, s = e[n - 1];
    for (; t.length > 0; ) {
      const o = t.pop();
      if (!(s instanceof ie2) && (o === X2.OPEN_BRACKET || o === X2.CLOSE_BRACKET))
        return false;
      e.push(o);
    }
    return r.setChildren(e), true;
  }
  _processSuffixExpressionCloseBracket(e, t, r, n) {
    var s;
    if (this._checkOpenBracket(r[n - 1]) || this._checkOperator(r[n - 1]))
      return false;
    for (; t.length > 0; ) {
      const o = (s = t[t.length - 1]) == null ? void 0 : s.trim();
      if (!o)
        break;
      if (o === X2.OPEN_BRACKET) {
        t.pop();
        break;
      }
      e.push(t.pop());
    }
  }
  _checkCloseBracket(e) {
    return e === X2.CLOSE_BRACKET || e instanceof ie2;
  }
  _checkOpenBracket(e) {
    return e === X2.OPEN_BRACKET;
  }
  _checkOperator(e) {
    return e == null || e instanceof ie2 ? false : Mt.has(e);
  }
  _deletePlusForPreNode(e) {
    if (e == null)
      return true;
    if (!(e instanceof ie2)) {
      const t = e.trim();
      if (Mt.has(t) || t === X2.OPEN_BRACKET)
        return true;
    }
    return false;
  }
  _resetCurrentLexerNode() {
    this._currentLexerNode = new ie2();
  }
  _resetSegment() {
    this._segment = "";
  }
  _openBracket(e = 0) {
    this._bracketState.push(e);
  }
  _closeBracket() {
    this._bracketState.pop();
  }
  _openSquareBracket() {
    this._squareBracketState += 1;
  }
  _closeSquareBracket() {
    this._squareBracketState -= 1;
  }
  _getCurrentBracket() {
    const e = this._bracketState;
    return e[e.length - 1];
  }
  _changeCurrentBracket(e) {
    const t = this._bracketState;
    t[t.length - 1] = e;
  }
  _openBraces() {
    this._bracesState += 1;
  }
  _closeBraces() {
    this._bracesState -= 1;
  }
  _openSingleQuotation() {
    this._singleQuotationState += 1;
  }
  _closeSingleQuotation() {
    this._singleQuotationState -= 1;
  }
  _openDoubleQuotation() {
    this._doubleQuotationState += 1;
  }
  _closeDoubleQuotation() {
    this._doubleQuotationState -= 1;
  }
  _openLambda() {
    this._lambdaState = true;
  }
  _closeLambda() {
    this._lambdaState = false;
  }
  _openColon(e) {
    this._upLevel = e, this._colonState = true;
  }
  _closeColon() {
    this._upLevel = 0, this._colonState = false;
  }
  _isTableBracket() {
    return this._tableBracketState;
  }
  _openTableBracket() {
    this._tableBracketState = true;
  }
  _closeTableBracket() {
    this._tableBracketState = false;
  }
  _formalErrorOccurred() {
    this._formulaErrorCount += 1;
  }
  _hasFormalError() {
    return this._formulaErrorCount > 0;
  }
  _getLastChildCurrentLexerNode() {
    const e = this._currentLexerNode.getChildren();
    if (e && e.length > 0) {
      const t = e[e.length - 1];
      if (t instanceof ie2)
        return t;
    }
    return false;
  }
  _getLastChildCurrent() {
    const e = this._currentLexerNode.getChildren();
    return e && e.length > 0 ? e[e.length - 1] : false;
  }
  _setParentCurrentLexerNode() {
    const e = this._currentLexerNode.getParent();
    return e ? (this._currentLexerNode = e, true) : false;
  }
  _setAncestorCurrentLexerNode() {
    var r, n, s, o, u, c;
    const e = (r = this._currentLexerNode) == null ? void 0 : r.getParent();
    let t = false;
    if (e && e.getToken() === Rr) {
      if ((n = e == null ? void 0 : e.getParent()) != null && n.getParent()) {
        const l = (o = (s = this._currentLexerNode.getParent()) == null ? void 0 : s.getParent()) == null ? void 0 : o.getParent();
        l && (this._currentLexerNode = l), t = true;
      }
    } else if (e != null && e.getParent()) {
      const l = (u = this._currentLexerNode.getParent()) == null ? void 0 : u.getParent();
      l && (this._currentLexerNode = l), t = true;
    }
    for (let l = 0; l < this._upLevel; l++) {
      const f2 = (c = this._currentLexerNode) == null ? void 0 : c.getParent();
      f2 && (this._currentLexerNode = f2), this._currentLexerNode ? t = true : t = false;
    }
    return t;
  }
  _segmentCount() {
    return this._segment.trim().length;
  }
  _pushSegment(e) {
    this._segment += e;
  }
  _pushNodeToChildren(e, t = false) {
    let r = e;
    if (r !== "") {
      const n = this._currentLexerNode.getChildren();
      if (!(r instanceof ie2) && this.isColonOpen()) {
        const s = new ie2();
        s.setToken(r), s.setParent(this._currentLexerNode), r = s;
      }
      t ? n.unshift(r) : n.push(r);
    }
    this.isColonOpen() && (this._setAncestorCurrentLexerNode(), this._closeColon());
  }
  _setCurrentLexerNode(e, t = false) {
    this._pushNodeToChildren(e, t), e.setParent(this._currentLexerNode), this._currentLexerNode = e;
  }
  _newAndPushCurrentLexerNode(e, t, r = false) {
    const n = new ie2();
    n.setToken(e), n.setIndex(t - e.length, t - 1), this._setCurrentLexerNode(n, r);
  }
  _getTopNode(e) {
    let t = e;
    for (; t != null && t.getParent(); )
      t = t.getParent();
    return t;
  }
  _removeLastChild() {
    this._currentLexerNode.getChildren().splice(-1);
  }
  /**
   * fix univer-pro/issues/2447
   * =1/3+
   * =+
   * =sum(A1+)
   */
  _formulaErrorLastTokenCheck(e, t) {
    const r = this._findPreviousToken(e, t) || "", n = e.length - 1 === t;
    if (!n && this._isOperatorToken(r) || n && tl(r))
      return true;
    if (Rs.has(r)) {
      const s = this._findSecondLastNonSpaceToken(e, t);
      if (s == null || nl(s))
        return true;
    }
    return false;
  }
  _findPreviousToken(e, t) {
    let r = t;
    for (; r >= 0; ) {
      const n = e[r];
      if (n !== " ")
        return n;
      r--;
    }
  }
  _findSecondLastNonSpaceToken(e, t) {
    let r = t, n = 0;
    for (; r >= 0; ) {
      const s = e[r];
      if (s !== " " && (n++, n === 2))
        return s;
      r--;
    }
    return null;
  }
  _findNextToken(e, t) {
    let r = t;
    for (; r >= 0; ) {
      const n = e[r];
      if (n !== " ")
        return n;
      r++;
    }
  }
  _unexpectedEndingTokenExcludeOperator(e) {
    return (
      // OPERATOR_TOKEN_SET.has(prevString) ||
      e === X2.OPEN_BRACKET || e === X2.COMMA || e === Z3.EQUALS || e === ""
    );
  }
  _unexpectedEndingToken(e) {
    return !!(this._isOperatorToken(e) || this._unexpectedEndingTokenExcludeOperator(e));
  }
  _isOperatorToken(e) {
    return !!Mt.has(e);
  }
  _getSequenceArray(e) {
    const t = [];
    return this._nodeMaker(e, t), t;
  }
  _resetTemp() {
    this._currentLexerNode = new ie2(), this._upLevel = 0, this._segment = "", this._bracketState = [], this._bracesState = 0, this._singleQuotationState = 0, this._doubleQuotationState = 0, this._lambdaState = false, this._colonState = false, this._formulaErrorCount = 0;
  }
  _checkErrorState() {
    return !!(this._bracketState.length > 0 || this._bracesState > 0 || this._singleQuotationState > 0 || this._doubleQuotationState > 0 || this._hasFormalError());
  }
  _checkSimilarErrorToken(e, t, r) {
    let n = t;
    if (e !== nt.POUND)
      return true;
    let s = r[++n];
    for (; s === " "; )
      s = r[++n];
    return !!Cn2(s);
  }
  _checkIfErrorObject(e, t) {
    return !!this._findErrorObject(e, t);
  }
  _findErrorObject(e, t) {
    for (let r = 0; r < ii.length; r++) {
      const n = ii[r], s = t.slice(e, e + n).join("").toUpperCase();
      if (fr.has(s))
        return s;
    }
  }
  // NOTE@wzhudev: this method is over complex, need to refactor. Using recursive descend to parse the formula string
  // without a standalone lexer phase
  // eslint-disable-next-line max-lines-per-function, complexity
  _nodeMaker(e, t, r) {
    let n = e.replace(/\r\n$|\r|\n/g, " ");
    n.substring(0, 1) === Z3.EQUALS && (n = n.substring(1));
    const s = n.split(""), o = s.length;
    this._resetTemp(), this._formulaErrorLastTokenCheck(s, o - 1) && this._formalErrorOccurred();
    let u = 0;
    for (; u < o; ) {
      const c = s[u];
      if (r === u)
        return [this._currentLexerNode, c];
      if (c === nt.POUND && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isBracesClose() && this.isSquareBracketClose() && this._checkIfErrorObject(u, s)) {
        const l = this._findErrorObject(u, s);
        if (l == null)
          return h.VALUE;
        this._pushNodeToChildren(l);
        for (let f2 = 0; f2 < l.length; f2++) {
          const m2 = s[u];
          this._pushSegment(m2), this._addSequenceArray(t, m2, u), u++;
        }
        this._resetSegment();
        continue;
      } else if (c === X2.OPEN_BRACKET && this.isSingleQuotationClose() && this.isDoubleQuotationClose())
        if (this._segmentCount() > 0 || this.isLambdaOpen()) {
          this.isLambdaClose() && (this._newAndPushCurrentLexerNode(this._segment, u), this._resetSegment()), this._openBracket(
            1
            /* FUNCTION */
          ), this._closeLambda();
          const l = s[u + 1];
          if (l && l === X2.CLOSE_BRACKET) {
            if (!this._setParentCurrentLexerNode() && u !== o - 1)
              return h.VALUE;
            this._addSequenceArray(t, c, u), u++, this._addSequenceArray(t, l, u), u++, this._closeBracket();
            continue;
          } else l && this._newAndPushCurrentLexerNode(At, u);
        } else
          this._pushNodeToChildren(c), this._openBracket(
            0
            /* NORMAL */
          ), this._resetSegment();
      else if (c === X2.CLOSE_BRACKET && this.isSingleQuotationClose() && this.isDoubleQuotationClose()) {
        this._formulaErrorLastTokenCheck(s, u - 1) && this._formalErrorOccurred(), this._pushNodeToChildren(this._segment), this._resetSegment();
        const l = this._getCurrentBracket();
        if (l === 0)
          this._pushNodeToChildren(c);
        else if (l === 1) {
          const f2 = s[u + 1];
          if (f2 && f2 === X2.OPEN_BRACKET) {
            if (!this._setParentCurrentLexerNode() && u !== o - 1)
              return h.VALUE;
            this._newAndPushCurrentLexerNode(Rr, u, true), this._openLambda();
          } else if (!this._setAncestorCurrentLexerNode() && u !== o - 1)
            return h.VALUE;
        } else
          return h.VALUE;
        this._closeBracket();
      } else if (c === X2.OPEN_BRACES && this.isSingleQuotationClose() && this.isDoubleQuotationClose()) {
        if (this._pushSegment(c), this._openBraces(), !this._formulaSpellCheck())
          return h.VALUE;
      } else if (c === X2.CLOSE_BRACES && this.isSingleQuotationClose() && this.isDoubleQuotationClose())
        this._pushSegment(c), this._pushNodeToChildren(this._segment), this._resetSegment(), this._closeBraces();
      else if (c === X2.OPEN_SQUARE_BRACKET && this.isSingleQuotationClose() && this.isDoubleQuotationClose())
        this._segment.length > 0 && this._openTableBracket(), this._pushSegment(c), this._openSquareBracket();
      else if (c === X2.CLOSE_SQUARE_BRACKET && this.isSingleQuotationClose() && this.isDoubleQuotationClose())
        this._closeSquareBracket(), this.isSquareBracketClose() ? (this._pushSegment(c), this._isTableBracket() && (this._pushNodeToChildren(this._segment), this._resetSegment()), this._closeTableBracket()) : this._pushSegment(c);
      else if (c === X2.DOUBLE_QUOTATION && this.isSingleQuotationClose() && this.isSquareBracketClose()) {
        if (this.isDoubleQuotationClose())
          this._openDoubleQuotation();
        else {
          const l = s[u + 1];
          l && l === X2.DOUBLE_QUOTATION ? u++ : this._closeDoubleQuotation();
        }
        this._pushSegment(c);
      } else if (c === X2.SINGLE_QUOTATION && this.isDoubleQuotationClose()) {
        if (this.isSingleQuotationClose())
          this._openSingleQuotation(), this._segmentCount() === 0 && this._resetSegment();
        else {
          const l = s[u + 1];
          if (l && l === X2.SINGLE_QUOTATION) {
            this._pushSegment(c), this._addSequenceArray(t, c, u), u++, this._pushSegment(l), this._addSequenceArray(t, l, u), u++;
            continue;
          } else
            this._closeSingleQuotation();
        }
        this._pushSegment(c);
      } else if (c === X2.COMMA && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isBracesClose() && this.isSquareBracketClose()) {
        this._formulaErrorLastTokenCheck(s, u - 1) && this._formalErrorOccurred();
        const l = this._getCurrentBracket();
        if (l === 1 || l == null) {
          if (this._pushNodeToChildren(this._segment), this._resetSegment(), !this._setParentCurrentLexerNode() && u !== o - 1 && l != null)
            return h.VALUE;
          this._newAndPushCurrentLexerNode(At, u);
        } else {
          const f2 = new ie2();
          f2.setToken(Vl);
          const m2 = new ie2();
          m2.setToken(At), m2.changeToParent(f2);
          const d2 = this._currentLexerNode.getParent();
          if (d2 && d2.getToken() === X2.COLON) {
            const _2 = d2.getParent();
            if (!_2)
              return h.VALUE;
            d2.changeToParent(m2), _2.setChildren([]), f2.changeToParent(_2);
          } else
            return h.VALUE;
          this._changeCurrentBracket(
            1
            /* FUNCTION */
          ), this._pushNodeToChildren(this._segment), this._resetSegment(), this._currentLexerNode = f2, this._newAndPushCurrentLexerNode(At, u);
        }
      } else if (c === X2.COLON && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isBracesClose() && this.isSquareBracketClose()) {
        const l = new ie2();
        l.setToken(c);
        const f2 = new ie2();
        f2.setToken(At), f2.setParent(l);
        const m2 = new ie2();
        m2.setToken(At), m2.setParent(l), l.getChildren().push(f2, m2);
        let d2 = l, _2 = 0;
        if (this._segmentCount() > 0) {
          let C, E, R = 0;
          const b = this._segment.trim(), p2 = b[0], V = b[1];
          if (p2 === we2.MINUS && (C = new ie2(), C.setToken(we2.MINUS), R++), (p2 === we2.AT || V === we2.AT) && (E = new ie2(), E.setToken(we2.AT), C && (C.addChildren(E), E.setParent(C)), R++), R > 0 && (this._segment = b.slice(R)), _2 = R, E)
            if (E.addChildren(l), l.setParent(E), E.getParent()) {
              const M2 = E.getParent();
              M2 && (d2 = M2);
            } else
              d2 = E;
          else C && (d2 = C, C.addChildren(l), l.setParent(C));
          const S2 = new ie2();
          S2.setToken(this._segment), S2.setParent(f2), f2.getChildren().push(S2), this._resetSegment();
        } else {
          const C = this._getLastChildCurrentLexerNode();
          C && C.changeToParent(f2);
        }
        this._setCurrentLexerNode(d2), this._currentLexerNode = m2, this._openColon(_2);
      } else if (Rs.has(c) && this._checkSimilarErrorToken(c, u, s) && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isSquareBracketClose() && this.isBracesClose()) {
        this._pushNodeToChildren(this._segment);
        const l = new ie2();
        l.setToken(c);
        const f2 = this._getLastChildCurrent();
        f2 instanceof ie2 ? f2.changeToParent(l) : f2 !== false && (l.getChildren().push(f2), this._removeLastChild()), this._pushNodeToChildren(l), l.setParent(this._currentLexerNode), this._resetSegment();
      } else if (Mt.has(c) && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isSquareBracketClose() && this.isBracesClose()) {
        let l = this._segment.trim();
        if (c === Z3.MINUS && l === "") {
          const f2 = this._findPreviousToken(s, u - 1) || "", m2 = this._findNextToken(s, u + 1) || "";
          if (this._unexpectedEndingTokenExcludeOperator(f2) && this._isOperatorToken(m2)) {
            this._pushNodeToChildren("0"), this._pushNodeToChildren(Z3.MINUS), this._addSequenceArray(t, c, u), this._resetSegment(), u++;
            continue;
          } else if (this._unexpectedEndingToken(f2))
            if (m2 === Z3.PLUS) {
              this._pushSegment(Z3.MINUS), this._addSequenceArray(t, c, u), this._addSequenceArray(t, Z3.PLUS, u + 1), u += 2;
              continue;
            } else {
              this._pushSegment(Z3.MINUS), this._addSequenceArray(t, c, u), u++;
              continue;
            }
        } else if (this._segment.length > 0 && this._isScientificNotation(s, u, c)) {
          this._pushSegment(c), this._addSequenceArray(t, c, u), u++;
          continue;
        } else this._segment.length > 0 && l === "" ? l = this._segment : (this._pushNodeToChildren(this._segment), l = "");
        if (c === Z3.LESS_THAN || c === Z3.GREATER_THAN) {
          const f2 = s[u + 1];
          if (f2 && Mt.has(c + f2)) {
            this._pushNodeToChildren(l + c + f2), this._resetSegment(), this._addSequenceArray(t, c, u), u++, this._addSequenceArray(t, f2, u), u++;
            continue;
          } else
            this._pushNodeToChildren(l + c);
        } else
          this._pushNodeToChildren(l + c);
        this._resetSegment();
      } else
        (this._segment !== "" || c !== " ") && this._pushSegment(c);
      this._addSequenceArray(t, c, u), u++;
    }
    if (this._pushNodeToChildren(this._segment), this._checkErrorState())
      return h.VALUE;
  }
  _isScientificNotation(e, t, r) {
    const n = e[t - 2];
    if (n && Number.isNaN(Number(n)) || !(r === Z3.MINUS || r === Z3.PLUS))
      return false;
    const s = e[t + 1];
    if (s && Number.isNaN(Number(s)))
      return false;
    const o = e[t - 1];
    return o && o.toUpperCase() === "E";
  }
  _addSequenceArray(e, t, r) {
    e == null || e.push({
      segment: this._segment,
      currentString: t,
      cur: r,
      currentLexerNode: this._currentLexerNode
    });
  }
  getNewFormulaWithPrefix(e, t) {
    return null;
  }
};
function Hl(a2, i, e, t, r, n, s) {
  const o = (s == null ? void 0 : s.f) || "", u = (s == null ? void 0 : s.si) || "", c = Jg(o), l = KR(u), f2 = a2.getValue(r, n), m2 = (f2 == null ? void 0 : f2.f) || "", d2 = (f2 == null ? void 0 : f2.si) || "";
  function _2() {
    var C;
    if (Jg(m2) && KR(d2)) {
      const E = (C = e == null ? void 0 : e[d2]) == null ? void 0 : C.f;
      E ? t.set(d2, E) : t.set(d2, m2);
    }
  }
  c && l ? (d2 !== u && _2(), a2.setValue(r, n, {
    f: o,
    si: u
  }), e[u] = { f: o, r, c: n }, i.setValue(r, n, {
    f: o,
    si: u
  })) : c && !l ? (m2 !== o && _2(), a2.setValue(r, n, {
    f: o
  }), i.setValue(r, n, {
    f: o
  })) : !c && l ? (d2 !== u && _2(), a2.setValue(r, n, {
    f: "",
    si: u
  })) : !c && !l && a2.getValue(r, n) && (_2(), a2.realDeleteValue(r, n), i.setValue(r, n, null));
}
function Gl(a2, i, e, t) {
  const r = a2 == null ? void 0 : a2.getValue(e, t);
  if (r == null)
    return true;
  const n = [];
  a2.forValue((l, f2, m2) => {
    l === e && f2 === t || Cn.intersects(m2, r) && n.push(m2);
  });
  const { startRow: s, startColumn: o, endRow: u, endColumn: c } = r;
  for (let l = s; l <= u; l++)
    for (let f2 = o; f2 <= c; f2++) {
      let m2 = false;
      const d2 = QR(l, f2);
      n.some((_2) => Cn.contains(_2, d2) ? (m2 = true, true) : false), m2 || i.realDeleteValue(l, f2);
    }
}
var Wl = Object.getOwnPropertyDescriptor;
var Ql = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Wl(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var pi = (a2, i) => (e, t) => i(e, t, a2);
var yr = class extends Ve {
  constructor(i, e) {
    super();
    A(this, "_arrayFormulaRange", {});
    A(this, "_arrayFormulaCellData", {});
    A(this, "_unitImageFormulaData", {});
    this._univerInstanceService = i, this._lexerTreeBuilder = e;
  }
  dispose() {
    super.dispose(), this._arrayFormulaRange = {}, this._arrayFormulaCellData = {}, this._unitImageFormulaData = {};
  }
  clearPreviousArrayFormulaCellData(i) {
    Object.keys(i).forEach((e) => {
      const t = i[e];
      if (t == null)
        return true;
      Object.keys(t).forEach((r) => {
        var c, l, f2, m2;
        const n = t[r], s = (l = (c = this._arrayFormulaRange) == null ? void 0 : c[e]) == null ? void 0 : l[r];
        if (s == null)
          return true;
        const o = new ht(s);
        let u = new ht();
        ((f2 = this._arrayFormulaCellData[e]) == null ? void 0 : f2[r]) != null && (u = new ht(
          (m2 = this._arrayFormulaCellData[e]) == null ? void 0 : m2[r]
        )), n.forValue((d2, _2) => {
          const C = o.getValue(d2, _2);
          if (C == null)
            return true;
          const { startRow: E, startColumn: R, endRow: b, endColumn: p2 } = C;
          for (let V = E; V <= b; V++)
            for (let S2 = R; S2 <= p2; S2++)
              u.setValue(V, S2, null);
          o.realDeleteValue(d2, _2);
        }), this._arrayFormulaCellData[e] && (this._arrayFormulaCellData[e][r] = u.getData());
      });
    });
  }
  mergeArrayFormulaCellData(i) {
    Object.keys(i).forEach((e) => {
      const t = i[e];
      if (t == null)
        return true;
      this._arrayFormulaRange[e] == null && (this._arrayFormulaRange[e] = {}), this._arrayFormulaCellData[e] == null && (this._arrayFormulaCellData[e] = {}), Object.keys(t).forEach((r) => {
        var u, c;
        const n = t[r], s = new ht((u = this._arrayFormulaRange[e]) == null ? void 0 : u[r]), o = new ht((c = this._arrayFormulaCellData[e]) == null ? void 0 : c[r]);
        n.forValue((l, f2) => {
          const m2 = s == null ? void 0 : s.getValue(l, f2);
          if (m2 == null)
            return true;
          const { startRow: d2, startColumn: _2, endRow: C, endColumn: E } = m2;
          for (let R = d2; R <= C; R++)
            for (let b = _2; b <= E; b++)
              o.setValue(R, b, null);
        }), n.forValue((l, f2, m2) => {
          o.setValue(l, f2, m2);
        }), this._arrayFormulaCellData[e] && (this._arrayFormulaCellData[e][r] = o.getData());
      });
    });
  }
  getFormulaData() {
    const i = {}, e = this._univerInstanceService.getAllUnitsForType(we.UNIVER_SHEET);
    return e.length === 0 || e.forEach((t) => {
      const r = t.getUnitId();
      i[r] = {}, t.getSheets().forEach((s) => {
        const o = s.getCellMatrix(), u = s.getSheetId();
        Ni(i, r, u, o);
      });
    }), i;
  }
  getSheetFormulaData(i, e) {
    const t = {}, r = this._univerInstanceService.getUnit(i);
    if (r == null)
      return {};
    t[i] = {};
    const n = r.getSheetBySheetId(e);
    if (n == null)
      return {};
    const s = n.getCellMatrix();
    return Ni(t, i, e, s), t[i][e];
  }
  getArrayFormulaRange() {
    return this._arrayFormulaRange;
  }
  setArrayFormulaRange(i) {
    this._arrayFormulaRange = i;
  }
  getArrayFormulaCellData() {
    return this._arrayFormulaCellData;
  }
  setArrayFormulaCellData(i) {
    this._arrayFormulaCellData = i;
  }
  getUnitImageFormulaData() {
    return this._unitImageFormulaData;
  }
  setUnitImageFormulaData(i) {
    this._unitImageFormulaData = i;
  }
  mergeArrayFormulaRange(i) {
    Object.keys(i).forEach((e) => {
      const t = i[e];
      if (t == null)
        return true;
      this._arrayFormulaRange[e] || (this._arrayFormulaRange[e] = {}), Object.keys(t).forEach((r) => {
        var o;
        const n = new ht(t[r]), s = new ht((o = this._arrayFormulaRange[e]) == null ? void 0 : o[r]);
        n.forValue((u, c, l) => {
          s.setValue(u, c, l);
        }), this._arrayFormulaRange[e] && (this._arrayFormulaRange[e][r] = s.getData());
      });
    });
  }
  mergeUnitImageFormulaData(i) {
    const e = Object.keys(i);
    for (let t = 0; t < e.length; t++) {
      const r = e[t], n = i[r];
      if (!n) continue;
      this._unitImageFormulaData[r] || (this._unitImageFormulaData[r] = {});
      const s = Object.keys(n);
      for (let o = 0; o < s.length; o++) {
        const u = s[o], c = n[u];
        c && (this._unitImageFormulaData[r][u] || (this._unitImageFormulaData[r][u] = new ht()), c.forValue((l, f2, m2) => {
          this._unitImageFormulaData[r][u].setValue(l, f2, m2);
        }));
      }
    }
  }
  deleteArrayFormulaRange(i, e, t, r) {
    var o;
    const n = (o = this._arrayFormulaRange[i]) == null ? void 0 : o[e];
    if (n == null)
      return;
    const s = new ht(n);
    s.getValue(t, r) && (s.realDeleteValue(t, r), this._arrayFormulaRange[i] && (this._arrayFormulaRange[i][e] = s.getData()));
  }
  getCalculateData() {
    const i = this._univerInstanceService.getAllUnitsForType(we.UNIVER_SHEET), e = {}, t = {}, r = {};
    for (const n of i) {
      const s = n.getUnitId(), o = n.getSheets(), u = {}, c = {};
      for (const l of o) {
        const f2 = l.getSheetId(), m2 = l.getConfig();
        u[f2] = {
          cellData: new ht(m2.cellData),
          rowCount: m2.rowCount,
          columnCount: m2.columnCount,
          rowData: m2.rowData,
          columnData: m2.columnData,
          defaultRowHeight: m2.defaultRowHeight,
          defaultColumnWidth: m2.defaultColumnWidth
        }, c[l.getName()] = l.getSheetId();
      }
      e[s] = u, t[s] = n.getStyles(), r[s] = c;
    }
    return {
      allUnitData: e,
      unitStylesData: t,
      unitSheetNameMap: r
    };
  }
  /**
   * Get the hidden rows that are filtered or manually hidden.
   *
   * For formulas that are sensitive to hidden rows.
   */
  getHiddenRowsFiltered() {
    const i = this._univerInstanceService.getAllUnitsForType(we.UNIVER_SHEET), e = {};
    for (const t of i) {
      const r = t.getUnitId(), n = t.getSheets();
      e[r] = {};
      for (const s of n) {
        const o = s.getSheetId();
        e[r][o] = {};
        const u = 0, c = s.getRowCount() - 1, l = {};
        for (let f2 = u; f2 <= c; f2++)
          s.getRowVisible(f2) || (l[f2] = {
            hd: ie.TRUE
          });
        e[r][o] = l;
      }
    }
    return e;
  }
  updateFormulaData(i, e, t) {
    const r = new ht(t), n = this._getSheetFormulaIdMap(i, e), s = /* @__PURE__ */ new Map(), o = this.getFormulaData();
    o[i] == null && (o[i] = {});
    const u = o[i];
    u[e] == null && (u[e] = {});
    const c = new ht(u[e] || {}), l = new ht();
    return r.forValue((f2, m2, d2) => {
      Hl(c, l, n, s, f2, m2, d2);
    }), c.forValue((f2, m2, d2) => {
      const _2 = (d2 == null ? void 0 : d2.f) || "", C = (d2 == null ? void 0 : d2.si) || "";
      if (KR(C)) {
        const E = n == null ? void 0 : n[C], R = s.get(C);
        if (E && !Jg(_2)) {
          const b = E.f, p2 = m2 - E.c, V = f2 - E.r;
          c.setValue(f2, m2, { f: b, si: C, x: p2, y: V }), l.setValue(f2, m2, { f: b, si: C, x: p2, y: V });
        } else if (typeof R == "string") {
          const b = (d2 == null ? void 0 : d2.x) || 0, p2 = (d2 == null ? void 0 : d2.y) || 0, V = this._lexerTreeBuilder.moveFormulaRefOffset(R, b, p2);
          s.set(C, { r: f2, c: m2, f: V }), c.setValue(f2, m2, { f: V, si: C }), l.setValue(f2, m2, { f: V, si: C });
        } else if (typeof R == "object") {
          const b = m2 - R.c, p2 = f2 - R.r;
          c.setValue(f2, m2, { f: R.f, si: C, x: b, y: p2 }), l.setValue(f2, m2, { f: R.f, si: C, x: b, y: p2 });
        }
      }
    }), l.getMatrix();
  }
  updateArrayFormulaRange(i, e, t) {
    var o;
    const r = (o = this._arrayFormulaRange[i]) == null ? void 0 : o[e];
    if (!r) return;
    const n = new ht(r);
    new ht(t).forValue((u, c, l) => {
      n.realDeleteValue(u, c);
    });
  }
  updateArrayFormulaCellData(i, e, t) {
    var c, l;
    const r = (c = this._arrayFormulaRange[i]) == null ? void 0 : c[e];
    if (!r) return;
    const n = new ht(r), s = (l = this._arrayFormulaCellData[i]) == null ? void 0 : l[e];
    if (!s) return;
    const o = new ht(s);
    new ht(t).forValue((f2, m2, d2) => {
      Gl(n, o, f2, m2);
    });
  }
  updateImageFormulaData(i, e, t) {
    var s;
    const r = (s = this._unitImageFormulaData[i]) == null ? void 0 : s[e];
    if (!r)
      return;
    new ht(t).forValue((o, u) => {
      r.realDeleteValue(o, u);
    });
  }
  getFormulaStringByCell(i, e, t, r) {
    const n = this._univerInstanceService.getUnit(r);
    if (n == null)
      return null;
    const s = n.getSheetBySheetId(t);
    if (s == null)
      return null;
    const o = s.getCellMatrix(), u = o.getValue(i, e);
    if (u == null)
      return null;
    const { f: c, si: l } = u;
    if (Jg(c))
      return c;
    if (KR(l)) {
      let f2 = null;
      return o.forValue((m2, d2, _2) => {
        if (_2 == null)
          return true;
        const { f: C, si: E } = _2;
        if (Jg(C) && l === E)
          return f2 = this._lexerTreeBuilder.moveFormulaRefOffset(
            C,
            e - d2,
            i - m2
          ), false;
      }), f2;
    }
    return null;
  }
  /**
   * Function to get all formula ranges
   * @returns
   */
  getFormulaDirtyRanges() {
    const i = this.getFormulaData(), e = [];
    for (const t in i) {
      const r = i[t];
      if (!r) continue;
      const n = this._univerInstanceService.getUnit(t);
      if (n)
        for (const s in r) {
          const o = r[s];
          if (!o) continue;
          const u = n.getSheetBySheetId(s);
          if (!u) continue;
          const c = {};
          for (const l of Object.keys(o)) {
            const f2 = Number(l);
            for (const m2 in o[f2]) {
              const d2 = Number(m2), _2 = u.getCellRaw(f2, d2), C = Jg(_2 == null ? void 0 : _2.f) || KR(_2 == null ? void 0 : _2.si), E = (_2 == null ? void 0 : _2.v) === void 0;
              if (!(C && E)) continue;
              c[d2] || (c[d2] = []);
              const R = c[d2].slice(-1)[0];
              R && R.endRow === f2 - 1 ? R.endRow = f2 : c[d2].push({ startRow: f2, endRow: f2 });
            }
          }
          for (const l in c) {
            const f2 = c[l];
            for (let m2 = 0; m2 < f2.length; m2++) {
              const d2 = f2[m2];
              e.push({
                unitId: t,
                sheetId: s,
                range: {
                  rangeType: ge.NORMAL,
                  startRow: d2.startRow,
                  endRow: d2.endRow,
                  // Use endRow as the inclusive end row
                  startColumn: Number(l),
                  endColumn: Number(l)
                }
              });
            }
          }
        }
    }
    return e;
  }
  _getSheetFormulaIdMap(i, e) {
    const t = {}, r = this._univerInstanceService.getUnit(i);
    if (r == null)
      return t;
    const n = r.getSheetBySheetId(e);
    return n == null || n.getCellMatrix().forValue((o, u, c) => {
      if (c == null)
        return true;
      const { f: l, si: f2 } = c;
      Jg(l) && KR(f2) && (t[f2] = { f: l, r: o, c: u });
    }), t;
  }
};
yr = Ql([
  pi(0, br),
  pi(1, Inject(Mn))
], yr);
function Ni(a2, i, e, t) {
  a2[i] || (a2[i] = {}), a2[i][e] || (a2[i][e] = {});
  const r = /* @__PURE__ */ new Map(), n = new ht(a2[i][e]);
  t.forValue((o, u, c) => {
    const l = (c == null ? void 0 : c.f) || "", f2 = (c == null ? void 0 : c.si) || "", m2 = Jg(l), d2 = KR(f2);
    m2 && d2 ? (n.setValue(o, u, {
      f: l,
      si: f2
    }), r.set(f2, { f: l, r: o, c: u })) : m2 && !d2 ? n.setValue(o, u, {
      f: l
    }) : !m2 && d2 && n.setValue(o, u, {
      f: "",
      si: f2
    });
  }), n.forValue((o, u, c) => {
    const l = (c == null ? void 0 : c.f) || "", f2 = (c == null ? void 0 : c.si) || "";
    if (KR(f2) && !Jg(l)) {
      const m2 = r.get(f2);
      if (m2) {
        const d2 = m2.f, _2 = u - m2.c, C = o - m2.r;
        n.setValue(o, u, { f: d2, si: f2, x: _2, y: C });
      } else
        n.realDeleteValue(o, u);
    }
  });
  const s = n.getMatrix();
  return {
    [i]: {
      [e]: s
    }
  };
}
var ql = class $s {
  /**
   * Accept two comparable values and creates new instance of interval
   * Predicate Interval.comparable_less(low, high) supposed to return true on these values
   * @param low
   * @param high
   */
  constructor(i, e) {
    this.low = i, this.high = e;
  }
  /**
   * Clone interval
   * @returns {Interval}
   */
  clone() {
    return new $s(this.low, this.high);
  }
  /**
   * Propery max returns clone of this interval
   * @returns {Interval}
   */
  get max() {
    return this.clone();
  }
  /**
   * Predicate returns true is this interval less than other interval
   * @param other_interval
   * @returns {boolean}
   */
  less_than(i) {
    return this.low < i.low || this.low === i.low && this.high < i.high;
  }
  /**
   * Predicate returns true is this interval equals to other interval
   * @param other_interval
   * @returns {boolean}
   */
  equal_to(i) {
    return this.low === i.low && this.high === i.high;
  }
  /**
   * Predicate returns true if this interval intersects other interval
   * @param other_interval
   * @returns {boolean}
   */
  intersect(i) {
    return !this.not_intersect(i);
  }
  /**
   * Predicate returns true if this interval does not intersect other interval
   * @param other_interval
   * @returns {boolean}
   */
  not_intersect(i) {
    return this.high < i.low || i.high < this.low;
  }
  /**
   * Returns new interval merged with other interval
   * @param {Interval} other_interval - Other interval to merge with
   * @returns {Interval}
   */
  merge(i) {
    return new $s(
      this.low === void 0 ? i.low : this.low < i.low ? this.low : i.low,
      this.high === void 0 ? i.high : this.high > i.high ? this.high : i.high
    );
  }
  /**
   * Returns how key should return
   */
  output() {
    return [this.low, this.high];
  }
  /**
   * Function returns maximum between two comparable values
   * @param interval1
   * @param interval2
   * @returns {Interval}
   */
  static comparable_max(i, e) {
    return i.merge(e);
  }
  /**
   * Predicate returns true if first value less than second value
   * @param val1
   * @param val2
   * @returns {boolean}
   */
  static comparable_less_than(i, e) {
    return i < e;
  }
};
var ve2 = 0;
var Re = 1;
var Kt = class {
  constructor(i = void 0, e = void 0, t = null, r = null, n = null, s = Re) {
    if (this.left = t, this.right = r, this.parent = n, this.color = s, this.item = { key: i, value: e }, i && i instanceof Array && i.length === 2 && !Number.isNaN(i[0]) && !Number.isNaN(i[1])) {
      let [o, u] = i;
      o > u && ([o, u] = [u, o]), this.item.key = new ql(o, u);
    }
    this.max = this.item.key ? this.item.key.max : void 0;
  }
  isNil() {
    return this.item.key === void 0 && this.item.value === void 0 && this.left === null && this.right === null && this.color === Re;
  }
  _value_less_than(i) {
    return this.item.value && i.item.value && this.item.value.less_than ? this.item.value.less_than(i.item.value) : this.item.value < i.item.value;
  }
  less_than(i) {
    return this.item.value === this.item.key && i.item.value === i.item.key ? this.item.key.less_than(i.item.key) : this.item.key.less_than(i.item.key) || this.item.key.equal_to(i.item.key) && this._value_less_than(i);
  }
  _value_equal(i) {
    return this.item.value && i.item.value && this.item.value.equal_to ? this.item.value.equal_to(i.item.value) : this.item.value === i.item.value;
  }
  equal_to(i) {
    return this.item.value === this.item.key && i.item.value === i.item.key ? this.item.key.equal_to(i.item.key) : this.item.key.equal_to(i.item.key) && this._value_equal(i);
  }
  intersect(i) {
    return this.item.key.intersect(i.item.key);
  }
  copy_data(i) {
    this.item.key = i.item.key, this.item.value = i.item.value;
  }
  update_max() {
    if (this.max = this.item.key ? this.item.key.max : void 0, this.right && this.right.max) {
      const i = this.item.key.constructor.comparable_max;
      this.max = i(this.max, this.right.max);
    }
    if (this.left && this.left.max) {
      const i = this.item.key.constructor.comparable_max;
      this.max = i(this.max, this.left.max);
    }
  }
  // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low
  not_intersect_left_subtree(i) {
    const e = this.item.key.constructor.comparable_less_than;
    let t = this.left.max.high !== void 0 ? this.left.max.high : this.left.max;
    return e(t, i.item.key.low);
  }
  // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low
  not_intersect_right_subtree(i) {
    const e = this.item.key.constructor.comparable_less_than;
    let t = this.right.max.low !== void 0 ? this.right.max.low : this.right.item.key.low;
    return e(i.item.key.high, t);
  }
};
var ya = class _ya {
  /**
   * Construct new empty instance of IntervalTree
   */
  constructor() {
    this.root = null, this.nil_node = new Kt();
  }
  /**
   * Returns number of items stored in the interval tree
   * @returns {number}
   */
  get size() {
    let i = 0;
    return this.tree_walk(this.root, () => i++), i;
  }
  /**
   * Returns array of sorted keys in the ascending order
   * @returns {Array}
   */
  get keys() {
    let i = [];
    return this.tree_walk(this.root, (e) => i.push(
      e.item.key.output ? e.item.key.output() : e.item.key
    )), i;
  }
  /**
   * Return array of values in the ascending keys order
   * @returns {Array}
   */
  get values() {
    let i = [];
    return this.tree_walk(this.root, (e) => i.push(e.item.value)), i;
  }
  /**
   * Returns array of items (<key,value> pairs) in the ascended keys order
   * @returns {Array}
   */
  get items() {
    let i = [];
    return this.tree_walk(this.root, (e) => i.push({
      key: e.item.key.output ? e.item.key.output() : e.item.key,
      value: e.item.value
    })), i;
  }
  /**
   * Returns true if tree is empty
   * @returns {boolean}
   */
  isEmpty() {
    return this.root == null || this.root === this.nil_node;
  }
  /**
   * Clear tree
   */
  clear() {
    this.root = null;
  }
  /**
   * Insert new item into interval tree
   * @param {Interval} key - interval object or array of two numbers [low, high]
   * @param {any} value - value representing any object (optional)
   * @returns {Node} returns reference to inserted node as an object {key:interval, value: value}
   */
  insert(i, e = i) {
    if (i === void 0) return;
    let t = new Kt(i, e, this.nil_node, this.nil_node, null, ve2);
    return this.tree_insert(t), this.recalc_max(t), t;
  }
  /**
   * Returns true if item {key,value} exist in the tree
   * @param {Interval} key - interval correspondent to keys stored in the tree
   * @param {any} value - value object to be checked
   * @returns {boolean} true if item {key, value} exist in the tree, false otherwise
   */
  exist(i, e = i) {
    let t = new Kt(i, e);
    return !!this.tree_search(this.root, t);
  }
  /**
   * Remove entry {key, value} from the tree
   * @param {Interval} key - interval correspondent to keys stored in the tree
   * @param {any} value - value object
   * @returns {boolean} true if item {key, value} deleted, false if not found
   */
  remove(i, e = i) {
    let t = new Kt(i, e), r = this.tree_search(this.root, t);
    return r && this.tree_delete(r), r;
  }
  /**
   * Returns array of entry values which keys intersect with given interval <br/>
   * If no values stored in the tree, returns array of keys which intersect given interval
   * @param {Interval} interval - search interval, or tuple [low, high]
   * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output
   * @returns {Array}
   */
  search(i, e = (t, r) => t === r ? r.output() : t) {
    let t = new Kt(i), r = [];
    return this.tree_search_interval(this.root, t, r), r.map((n) => e(n.item.value, n.item.key));
  }
  /**
   * Returns true if intersection between given and any interval stored in the tree found
   * @param {Interval} interval - search interval or tuple [low, high]
   * @returns {boolean}
   */
  intersect_any(i) {
    let e = new Kt(i);
    return this.tree_find_any_interval(this.root, e);
  }
  /**
   * Tree visitor. For each node implement a callback function. <br/>
   * Method calls a callback function with two parameters (key, value)
   * @param visitor(key,value) - function to be called for each tree item
   */
  forEach(i) {
    this.tree_walk(this.root, (e) => i(e.item.key, e.item.value));
  }
  /**
   * Value Mapper. Walk through every node and map node value to another value
   * @param callback(value,key) - function to be called for each tree item
   */
  map(i) {
    const e = new _ya();
    return this.tree_walk(this.root, (t) => e.insert(t.item.key, i(t.item.value, t.item.key))), e;
  }
  /**
   * @param {Interval} interval - optional if the iterator is intended to start from the beginning
   * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output
   * @returns {Iterator}
   */
  *iterate(i, e = (t, r) => t === r ? r.output() : t) {
    let t;
    for (i ? t = this.tree_search_nearest_forward(this.root, new Kt(i)) : this.root && (t = this.local_minimum(this.root)); t; )
      yield e(t.item.value, t.item.key), t = this.tree_successor(t);
  }
  recalc_max(i) {
    let e = i;
    for (; e.parent != null; )
      e.parent.update_max(), e = e.parent;
  }
  tree_insert(i) {
    let e = this.root, t = null;
    if (this.root == null || this.root === this.nil_node)
      this.root = i;
    else {
      for (; e !== this.nil_node; )
        t = e, i.less_than(e) ? e = e.left : e = e.right;
      i.parent = t, i.less_than(t) ? t.left = i : t.right = i;
    }
    this.insert_fixup(i);
  }
  // After insertion insert_node may have red-colored parent, and this is a single possible violation
  // Go upwords to the root and re-color until violation will be resolved
  insert_fixup(i) {
    let e, t;
    for (e = i; e !== this.root && e.parent.color === ve2; )
      e.parent === e.parent.parent.left ? (t = e.parent.parent.right, t.color === ve2 ? (e.parent.color = Re, t.color = Re, e.parent.parent.color = ve2, e = e.parent.parent) : (e === e.parent.right && (e = e.parent, this.rotate_left(e)), e.parent.color = Re, e.parent.parent.color = ve2, this.rotate_right(e.parent.parent))) : (t = e.parent.parent.left, t.color === ve2 ? (e.parent.color = Re, t.color = Re, e.parent.parent.color = ve2, e = e.parent.parent) : (e === e.parent.left && (e = e.parent, this.rotate_right(e)), e.parent.color = Re, e.parent.parent.color = ve2, this.rotate_left(e.parent.parent)));
    this.root.color = Re;
  }
  tree_delete(i) {
    let e, t;
    i.left === this.nil_node || i.right === this.nil_node ? e = i : e = this.tree_successor(i), e.left !== this.nil_node ? t = e.left : t = e.right, t.parent = e.parent, e === this.root ? this.root = t : (e === e.parent.left ? e.parent.left = t : e.parent.right = t, e.parent.update_max()), this.recalc_max(t), e !== i && (i.copy_data(e), i.update_max(), this.recalc_max(i)), /*fix_node != this.nil_node && */
    e.color === Re && this.delete_fixup(t);
  }
  delete_fixup(i) {
    let e = i, t;
    for (; e !== this.root && e.parent != null && e.color === Re; )
      e === e.parent.left ? (t = e.parent.right, t.color === ve2 && (t.color = Re, e.parent.color = ve2, this.rotate_left(e.parent), t = e.parent.right), t.left.color === Re && t.right.color === Re ? (t.color = ve2, e = e.parent) : (t.right.color === Re && (t.color = ve2, t.left.color = Re, this.rotate_right(t), t = e.parent.right), t.color = e.parent.color, e.parent.color = Re, t.right.color = Re, this.rotate_left(e.parent), e = this.root)) : (t = e.parent.left, t.color === ve2 && (t.color = Re, e.parent.color = ve2, this.rotate_right(e.parent), t = e.parent.left), t.left.color === Re && t.right.color === Re ? (t.color = ve2, e = e.parent) : (t.left.color === Re && (t.color = ve2, t.right.color = Re, this.rotate_left(t), t = e.parent.left), t.color = e.parent.color, e.parent.color = Re, t.left.color = Re, this.rotate_right(e.parent), e = this.root));
    e.color = Re;
  }
  tree_search(i, e) {
    if (!(i == null || i === this.nil_node))
      return e.equal_to(i) ? i : e.less_than(i) ? this.tree_search(i.left, e) : this.tree_search(i.right, e);
  }
  tree_search_nearest_forward(i, e) {
    let t, r = i;
    for (; r && r !== this.nil_node; )
      r.less_than(e) ? r.intersect(e) ? (t = r, r = r.left) : r = r.right : ((!t || r.less_than(t)) && (t = r), r = r.left);
    return t || null;
  }
  // Original search_interval method; container res support push() insertion
  // Search all intervals intersecting given one
  tree_search_interval(i, e, t) {
    i != null && i !== this.nil_node && (i.left !== this.nil_node && !i.not_intersect_left_subtree(e) && this.tree_search_interval(i.left, e, t), i.intersect(e) && t.push(i), i.right !== this.nil_node && !i.not_intersect_right_subtree(e) && this.tree_search_interval(i.right, e, t));
  }
  tree_find_any_interval(i, e) {
    let t = false;
    return i != null && i !== this.nil_node && (i.left !== this.nil_node && !i.not_intersect_left_subtree(e) && (t = this.tree_find_any_interval(i.left, e)), t || (t = i.intersect(e)), !t && i.right !== this.nil_node && !i.not_intersect_right_subtree(e) && (t = this.tree_find_any_interval(i.right, e))), t;
  }
  local_minimum(i) {
    let e = i;
    for (; e.left != null && e.left !== this.nil_node; )
      e = e.left;
    return e;
  }
  // not in use
  local_maximum(i) {
    let e = i;
    for (; e.right != null && e.right !== this.nil_node; )
      e = e.right;
    return e;
  }
  tree_successor(i) {
    let e, t, r;
    if (i.right !== this.nil_node)
      e = this.local_minimum(i.right);
    else {
      for (t = i, r = i.parent; r != null && r.right === t; )
        t = r, r = r.parent;
      e = r;
    }
    return e;
  }
  //           |            right-rotate(T,y)       |
  //           y            ---------------.       x
  //          / \                                  / \
  //         x   c          left-rotate(T,x)      a   y
  //        / \             <---------------         / \
  //       a   b                                    b   c
  rotate_left(i) {
    let e = i.right;
    i.right = e.left, e.left !== this.nil_node && (e.left.parent = i), e.parent = i.parent, i === this.root ? this.root = e : i === i.parent.left ? i.parent.left = e : i.parent.right = e, e.left = i, i.parent = e, i != null && i !== this.nil_node && i.update_max(), e = i.parent, e != null && e !== this.nil_node && e.update_max();
  }
  rotate_right(i) {
    let e = i.left;
    i.left = e.right, e.right !== this.nil_node && (e.right.parent = i), e.parent = i.parent, i === this.root ? this.root = e : i === i.parent.left ? i.parent.left = e : i.parent.right = e, e.right = i, i.parent = e, i !== null && i !== this.nil_node && i.update_max(), e = i.parent, e != null && e !== this.nil_node && e.update_max();
  }
  tree_walk(i, e) {
    i != null && i !== this.nil_node && (this.tree_walk(i.left, e), e(i), this.tree_walk(i.right, e));
  }
  /* Return true if all red nodes have exactly two black child nodes */
  testRedBlackProperty() {
    let i = true;
    return this.tree_walk(this.root, function(e) {
      e.color === ve2 && (e.left.color === Re && e.right.color === Re || (i = false));
    }), i;
  }
  /* Throw error if not every path from root to bottom has same black height */
  testBlackHeightProperty(i) {
    let e = 0, t = 0, r = 0;
    if (i.color === Re && e++, i.left !== this.nil_node ? t = this.testBlackHeightProperty(i.left) : t = 1, i.right !== this.nil_node ? r = this.testBlackHeightProperty(i.right) : r = 1, t !== r)
      throw new Error("Red-black height property violated");
    return e += t, e;
  }
};
var Ys = Symbol("EMPTY_CELL");
var Xl = class {
  constructor() {
    A(this, "_cache", /* @__PURE__ */ new Map());
    A(this, "_continueBuildingCache", /* @__PURE__ */ new Map());
  }
  set(i, e, t, r, n, s = false) {
    if (!this.shouldContinueBuildingCache(i, e, t, n) && !s)
      return;
    let o = this._cache.get(i);
    o == null && (o = /* @__PURE__ */ new Map(), this._cache.set(i, o));
    let u = o.get(e);
    u == null && (u = /* @__PURE__ */ new Map(), o.set(e, u));
    let c = u.get(t);
    if (c == null && (c = /* @__PURE__ */ new Map(), u.set(t, c)), s) {
      for (const [m2, d2] of c)
        if (d2.has(n)) {
          d2.delete(n);
          break;
        }
    }
    let l = typeof r == "string" ? r.toLowerCase() : r;
    (l === "" || l === null) && (l = Ys);
    let f2 = c.get(l);
    f2 == null && (f2 = /* @__PURE__ */ new Set(), c.set(l, f2)), f2.add(n);
  }
  getCellValuePositions(i, e, t) {
    var r, n;
    return (n = (r = this._cache.get(i)) == null ? void 0 : r.get(e)) == null ? void 0 : n.get(t);
  }
  getCellPositions(i, e, t, r, n) {
    var u, c, l;
    let s = typeof r == "string" ? r.toLowerCase() : r;
    (s === "" || s === null) && (s = Ys);
    const o = (l = (c = (u = this._cache.get(i)) == null ? void 0 : u.get(e)) == null ? void 0 : c.get(t)) == null ? void 0 : l.get(s);
    return o && [...o].filter((f2) => n.some(([m2, d2]) => f2 >= m2 && f2 <= d2));
  }
  setContinueBuildingCache(i, e, t, r, n) {
    if (t === -1 || r === -1 || n === -1)
      return;
    let s = this._continueBuildingCache.get(i);
    s == null && (s = /* @__PURE__ */ new Map(), this._continueBuildingCache.set(i, s));
    let o = s.get(e);
    o == null && (o = /* @__PURE__ */ new Map(), s.set(e, o));
    let u = o.get(t);
    if (u == null) {
      u = new ya(), u.insert([r, n]), o.set(t, u);
      return;
    }
    this._handleNewInterval(u, r, n);
  }
  shouldContinueBuildingCache(i, e, t, r) {
    var o, u;
    if (t === -1 || r === -1)
      return false;
    const n = (u = (o = this._continueBuildingCache.get(i)) == null ? void 0 : o.get(e)) == null ? void 0 : u.get(t);
    return n ? n.search([r, r]).length === 0 : true;
  }
  canUseCache(i, e, t, r, n) {
    var f2, m2;
    const s = (m2 = (f2 = this._continueBuildingCache.get(i)) == null ? void 0 : f2.get(e)) == null ? void 0 : m2.get(t);
    if (t === -1 || r === -1 || n === -1 || !s)
      return {
        rowsInCache: [],
        rowsNotInCache: []
      };
    const o = s.search([r, n]);
    if (o.length === 0)
      return {
        rowsInCache: [],
        rowsNotInCache: []
      };
    o.sort((d2, _2) => d2[0] - _2[0]);
    const u = [], c = [];
    let l = r;
    for (let d2 = 0; d2 < o.length; d2++) {
      const [_2, C] = o[d2];
      if (l >= _2) {
        if (n <= C) {
          u.push([l, n]);
          break;
        }
        u.push([l, C]), l = C + 1, d2 === o.length - 1 && l <= n && c.push([l, n]);
      } else {
        if (n > C) {
          u.push([_2, C]), c.push([l, _2 - 1]), l = C + 1, d2 === o.length - 1 && l <= n && c.push([l, n]);
          continue;
        }
        u.push([_2, n]), c.push([l, _2 - 1]);
      }
    }
    return {
      rowsInCache: u,
      rowsNotInCache: c
    };
  }
  clear() {
    this._cache.clear(), this._continueBuildingCache.clear();
  }
  _handleNewInterval(i, e, t) {
    let r = i.search([e, t]);
    if (r.length === 0) {
      const o = [e - 1 < 0 ? 0 : e - 1, t + 1];
      if (r = i.search(o), r.length === 0) {
        i.insert([e, t]);
        return;
      }
    }
    let n = e, s = t;
    for (const o of r)
      n = Math.min(n, o[0]), s = Math.max(s, o[1]), i.remove(o);
    i.insert([n, s]);
  }
};
var Ke = new Xl();
var pa = "engine-formula.config";
var xo = 1;
var kb = "CYCLE_REFERENCE_COUNT";
var Vi = {};
var Kl = class extends Ve {
  constructor() {
    super(...arguments);
    A(this, "_getRowFilteredCallback");
  }
  register(e) {
    this._getRowFilteredCallback = e;
  }
  getRowFiltered(e, t, r) {
    var n;
    return this._getRowFilteredCallback && (n = this._getRowFilteredCallback(e, t, r)) != null ? n : false;
  }
};
var jo = createIdentifier(
  "univer.formula.sheet-row-filtered.service"
);
var Zl = Object.getOwnPropertyDescriptor;
var zl = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Zl(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var an = (a2, i) => (e, t) => i(e, t, a2);
var Hs = class extends Ve {
  constructor(i, e, t, r) {
    super();
    A(this, "_unitData", {});
    A(this, "_unitStylesData", {});
    A(this, "_arrayFormulaCellData", {});
    A(this, "_arrayFormulaRange", {});
    A(this, "_formulaData", {});
    A(this, "_sheetNameMap", {});
    A(this, "_forceCalculate", false);
    A(this, "_clearDependencyTreeCache", {});
    A(this, "_dirtyRanges", []);
    A(this, "_dirtyNameMap", {});
    A(this, "_dirtyDefinedNameMap", {});
    A(this, "_dirtyUnitFeatureMap", {});
    A(this, "_dirtyUnitOtherFormulaMap", {});
    A(this, "_excludedCell");
    A(this, "_sheetIdToNameMap", {});
    A(this, "_executeUnitId", "");
    A(this, "_executeSubUnitId", "");
    this._univerInstanceService = i, this._localeService = e, this._formulaDataModel = t, this._sheetRowFilteredService = r;
  }
  dispose() {
    super.dispose(), this._unitData = {}, this._unitStylesData = {}, this._arrayFormulaCellData = {}, this._arrayFormulaRange = {}, this._formulaData = {}, this._sheetNameMap = {}, this._clearDependencyTreeCache = {}, this._dirtyRanges = [], this._dirtyNameMap = {}, this._dirtyDefinedNameMap = {}, this._dirtyUnitFeatureMap = {}, this._dirtyUnitOtherFormulaMap = {}, this._excludedCell = {}, this._sheetIdToNameMap = {};
  }
  getExecuteUnitId() {
    return this._executeUnitId;
  }
  getExecuteSubUnitId() {
    return this._executeSubUnitId;
  }
  setExecuteUnitId(i) {
    this._executeUnitId = i;
  }
  setExecuteSubUnitId(i) {
    this._executeSubUnitId = i;
  }
  getExcludedRange() {
    return this._excludedCell;
  }
  getUnitData() {
    return this._unitData;
  }
  getUnitStylesData() {
    return this._unitStylesData;
  }
  getFormulaData() {
    return this._formulaData;
  }
  getArrayFormulaCellData() {
    return this._arrayFormulaCellData;
  }
  getArrayFormulaRange() {
    return this._arrayFormulaRange;
  }
  getSheetNameMap() {
    return this._sheetNameMap;
  }
  isForceCalculate() {
    return this._forceCalculate;
  }
  getDirtyRanges() {
    return this._dirtyRanges;
  }
  getDirtyNameMap() {
    return this._dirtyNameMap;
  }
  getDirtyDefinedNameMap() {
    return this._dirtyDefinedNameMap;
  }
  getDirtyUnitFeatureMap() {
    return this._dirtyUnitFeatureMap;
  }
  getDirtyUnitOtherFormulaMap() {
    return this._dirtyUnitOtherFormulaMap;
  }
  getSheetName(i, e) {
    return this._sheetIdToNameMap[i] == null ? "" : this._sheetIdToNameMap[i][e] || "";
  }
  setSheetNameMap(i) {
    this._sheetIdToNameMap = i;
  }
  getClearDependencyTreeCache() {
    return this._clearDependencyTreeCache;
  }
  getLocale() {
    return this._localeService.getCurrentLocale();
  }
  getSheetsInfo() {
    const i = this._univerInstanceService.getCurrentUnitForType(we.UNIVER_SHEET), { id: e, sheetOrder: t } = i.getSnapshot();
    return {
      sheetOrder: t,
      sheetNameMap: this._sheetIdToNameMap[e]
    };
  }
  getSheetRowColumnCount(i, e) {
    const t = this._univerInstanceService.getUnit(i), r = t == null ? void 0 : t.getSheetBySheetId(e), n = r == null ? void 0 : r.getSnapshot();
    if (!n)
      return { rowCount: 0, columnCount: 0 };
    const { rowCount: s, columnCount: o } = n;
    return { rowCount: s, columnCount: o };
  }
  getFilteredOutRows(i, e, t, r) {
    const n = [];
    for (let s = t; s <= r; s++)
      this._sheetRowFilteredService.getRowFiltered(i, e, s) && n.push(s);
    return n;
  }
  load(i) {
    if (i.allUnitData && i.unitSheetNameMap && i.unitStylesData)
      this._unitData = i.allUnitData, this._unitStylesData = i.unitStylesData, this._sheetNameMap = i.unitSheetNameMap;
    else {
      const { allUnitData: e, unitSheetNameMap: t, unitStylesData: r } = this._loadSheetData();
      this._unitData = e, this._unitStylesData = r, this._sheetNameMap = t;
    }
    i.rowData && this._applyUnitRowData(i.rowData), this._formulaData = i.formulaData, this._arrayFormulaCellData = yl2(i.arrayFormulaCellData), this._arrayFormulaRange = i.arrayFormulaRange, this._forceCalculate = i.forceCalculate, this._clearDependencyTreeCache = i.clearDependencyTreeCache || {}, this._dirtyRanges = i.dirtyRanges, this._dirtyNameMap = i.dirtyNameMap, this._dirtyDefinedNameMap = i.dirtyDefinedNameMap, this._dirtyUnitFeatureMap = i.dirtyUnitFeatureMap, this._dirtyUnitOtherFormulaMap = i.dirtyUnitOtherFormulaMap, this._excludedCell = i.excludedCell, this._mergeNameMap(this._sheetNameMap, this._dirtyNameMap);
  }
  getDirtyData() {
    return {
      forceCalculation: this._forceCalculate,
      dirtyRanges: this._dirtyRanges,
      dirtyNameMap: this._dirtyNameMap,
      dirtyDefinedNameMap: this._dirtyDefinedNameMap,
      dirtyUnitFeatureMap: this._dirtyUnitFeatureMap,
      dirtyUnitOtherFormulaMap: this._dirtyUnitOtherFormulaMap,
      clearDependencyTreeCache: this._clearDependencyTreeCache
    };
  }
  loadDirtyRangesAndExcludedCell(i, e) {
    this._dirtyRanges = i, this._excludedCell = e, this._dirtyNameMap = {};
  }
  registerUnitData(i) {
    this._unitData = i;
  }
  registerFormulaData(i) {
    this._formulaData = i;
  }
  registerSheetNameMap(i) {
    this._sheetNameMap = i;
  }
  // private _loadOtherFormulaData() {
  //     const unitAllDoc = this._univerInstanceService.getAllUniverDocsInstance();
  //     const unitAllSlide = this._univerInstanceService.getAllUniverSlidesInstance();
  //     const otherFormulaData: IOtherFormulaData = {};
  //     for (const documentDataModel of unitAllDoc) {
  //         const unitId = documentDataModel.getUnitId();
  //         if (otherFormulaData[unitId] == null) {
  //             otherFormulaData[unitId] = {};
  //         }
  //         if (otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID] == null) {
  //             otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID] = {};
  //         }
  //         const subComponent = otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID];
  //         const customRanges = documentDataModel.getBody()?.customRanges;
  //         if (customRanges == null) {
  //             continue;
  //         }
  //         for (const customRange of customRanges) {
  //             subComponent[customRange.rangeId] = {
  //                 f: customRange.endIndex.toString(),
  //             };
  //         }
  //     }
  //     for (const slide of unitAllSlide) {
  //         const unitId = slide.getUnitId();
  //         if (otherFormulaData[unitId] == null) {
  //             otherFormulaData[unitId] = {};
  //         }
  //         if (otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID] == null) {
  //             otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID] = {};
  //         }
  //         const pages = slide.getPages();
  //         if (pages == null) {
  //             continue;
  //         }
  //         const pageIds = Object.keys(pages);
  //         for (const pageId of pageIds) {
  //             const page = pages[pageId];
  //             const subComponent = otherFormulaData[unitId][pageId];
  //             const pageElements = page.pageElements;
  //             if (pageElements == null) {
  //                 continue;
  //             }
  //             const pageElementIds = Object.keys(pageElements);
  //             for (const pageElementId of pageElementIds) {
  //                 const pageElement = pageElements[pageElementId];
  //                 subComponent[pageElementId] = {
  //                     f: pageElement.title,
  //                 };
  //             }
  //         }
  //     }
  //     return otherFormulaData;
  // }
  _mergeNameMap(i, e) {
    Object.keys(e).forEach((t) => {
      e[t] && Object.keys(e[t]).forEach((r) => {
        i[t] == null && (i[t] = {}), i[t][e[t][r]] = r;
      });
    }), this._sheetIdToNameMap = {}, Object.keys(i).forEach((t) => {
      Object.keys(i[t]).forEach((r) => {
        this._sheetIdToNameMap[t] == null && (this._sheetIdToNameMap[t] = {}), this._sheetIdToNameMap[t][i[t][r]] = r;
      });
    });
  }
  _loadSheetData() {
    const i = this._univerInstanceService.getCurrentUnitForType(we.UNIVER_SHEET), e = i == null ? void 0 : i.getActiveSheet();
    return this._executeUnitId = i == null ? void 0 : i.getUnitId(), this._executeSubUnitId = e == null ? void 0 : e.getSheetId(), this._formulaDataModel.getCalculateData();
  }
  /**
   * There is no filter information in the worker, it must be passed in from the main thread after it is ready
   * @param rowData
   */
  _applyUnitRowData(i) {
    for (const e in i)
      if (i[e] != null)
        for (const t in i[e])
          i[e][t] != null && (this._unitData[e] == null && (this._unitData[e] = {}), this._unitData[e][t] == null && (this._unitData[e][t] = {
            cellData: new ht({}),
            rowCount: 0,
            columnCount: 0,
            rowData: {},
            columnData: {}
          }), this._unitData[e][t].rowData = i[e][t]);
  }
};
Hs = zl([
  an(0, br),
  an(1, Inject(Hn)),
  an(2, Inject(yr)),
  an(3, Inject(jo))
], Hs);
var Wt = createIdentifier(
  "univer.formula.current-data.service"
);
var Jl = Object.getOwnPropertyDescriptor;
var ef = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Jl(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var Ns = (a2, i) => (e, t) => i(e, t, a2);
var pr = class extends Ve {
  constructor(a2, i, e) {
    super(), this._definedNamesService = a2, this._lexerTreeBuilder = i, this._formulaCurrentConfigService = e;
  }
  treeBuilder(a2, i = true) {
    const e = this._definedNamesService.getAllDefinedNames();
    return this._isDeepDefinedNameMapEmpty(e) ? this._lexerTreeBuilder.treeBuilder(a2, i) : this._lexerTreeBuilder.treeBuilder(a2, i, {
      unitId: this._formulaCurrentConfigService.getExecuteUnitId(),
      getValueByName: this._definedNamesService.getValueByName.bind(this._definedNamesService),
      getDirtyDefinedNameMap: this._formulaCurrentConfigService.getDirtyDefinedNameMap.bind(this._formulaCurrentConfigService),
      getSheetName: this._formulaCurrentConfigService.getSheetName.bind(this._formulaCurrentConfigService)
    });
  }
  _isDeepDefinedNameMapEmpty(a2) {
    for (const i in a2)
      if (Object.keys(a2[i]).length > 0)
        return false;
    return true;
  }
};
pr = ef([
  Ns(0, Lr),
  Ns(1, Inject(Mn)),
  Ns(2, Wt)
], pr);
function En(a2) {
  if (a2 == null)
    return true;
  const { v: i, f: e, si: t, p: r } = a2;
  return !(!(i == null || typeof i == "string" && i.length === 0) || e != null && e.length > 0 || t != null && t.length > 0 || r != null);
}
var ts = class {
  constructor() {
    A(this, "pattern", "");
  }
  dispose() {
  }
  getPattern() {
    return this.pattern;
  }
  /**
   * Only used in NumberValueObject
   * @param pattern
   */
  setPattern(i) {
    this.pattern = i;
  }
  isError() {
    return false;
  }
  isAsyncObject() {
    return false;
  }
  isAsyncArrayObject() {
    return false;
  }
  isReferenceObject() {
    return false;
  }
  isArray() {
    return false;
  }
  isValueObject() {
    return false;
  }
  isEqualType(i) {
    return false;
  }
};
function tf(a2) {
  var i;
  if (a2 === null)
    return 0;
  if (a2 != null && a2.p) {
    const e = a2 == null ? void 0 : a2.p.body;
    if (e == null)
      return 0;
    const t = e.dataStream;
    return Ze.transform.getPlainText(t);
  }
  return (i = a2 == null ? void 0 : a2.v) != null ? i : 0;
}
function $b(a2, i = false) {
  return !i && !(Jg(a2 == null ? void 0 : a2.f) || KR(a2 == null ? void 0 : a2.si)) ? null : typeof (a2 == null ? void 0 : a2.v) == "string" && fr.has(a2.v) ? a2.v : null;
}
function Uo(a2, i, e, t, r) {
  var s;
  const n = Object.keys(r);
  for (const o of n) {
    const u = r[o], c = (s = u == null ? void 0 : u[t]) == null ? void 0 : s[e];
    if (c == null)
      continue;
    const l = c.getValue(a2, i);
    if (l != null)
      return l;
  }
}
var zt = ((a2) => (a2[a2.MIN = 0] = "MIN", a2[a2.MAX = 1] = "MAX", a2))(zt || {});
var xe = ((a2) => (a2[a2.NORMAL = 0] = "NORMAL", a2[a2.MIN = 1] = "MIN", a2[a2.MAX = 2] = "MAX", a2))(xe || {});
function Dn() {
  return Intl && Intl.Collator ? new Intl.Collator(void 0, { numeric: false }).compare : (a2, i) => a2.localeCompare(i);
}
function vo(a2) {
  return a2.indexOf("*") > -1 || a2.indexOf("?") > -1;
}
function Vs(a2, i) {
  const e = nf(i).replace(/~?[*?]/g, (r) => r.startsWith("~") ? `\\${r.substring(1)}` : r === "*" ? ".*" : r === "?" ? "." : r);
  return new RegExp(`^${e}$`).test(a2);
}
function Oi(a2) {
  return a2.replace(/~?[*?]/g, (i) => i.startsWith("~") ? i.substring(1) : " ");
}
function rf(a2, i, e) {
  let t = false;
  switch (e) {
    case Y2.EQUALS:
      t = Vs(a2, i);
      break;
    case Y2.NOT_EQUAL:
      t = !Vs(a2, i);
      break;
    case Y2.GREATER_THAN:
    case Y2.GREATER_THAN_OR_EQUAL:
      t = Vs(a2, i) || a2 > Oi(i);
      break;
    case Y2.LESS_THAN:
    case Y2.LESS_THAN_OR_EQUAL:
      t = a2 < Oi(i);
      break;
  }
  return t;
}
function nf(a2) {
  return a2.replace(/[.+^${}()|[\]\\]/g, "\\$&");
}
function Gs(a2) {
  switch (a2) {
    case 1:
      return 2;
    case 0:
      return 0;
    case -1:
      return 1;
    default:
      return 0;
  }
}
function Ws(a2) {
  return a2 === -2 ? 1 : 0;
}
var sf = [
  "$",
  "£",
  "¥",
  "¤",
  "֏",
  "؋",
  "৳",
  "฿",
  "៛",
  "₡",
  "₦",
  "₩",
  "₪",
  "₫",
  "€",
  "₭",
  "₮",
  "₱",
  "₲",
  "₴",
  "₸",
  "₹",
  "₺",
  "₼",
  "₽",
  "₾",
  "₿"
];
var af = {
  currency: 2,
  date: 4,
  datetime: 5,
  error: 11,
  fraction: 7,
  general: 0,
  grouped: 11,
  number: 1,
  percent: 6,
  scientific: 8,
  text: 9,
  time: 5,
  unknown: 11
  /* Custom */
};
function Yb(a2, i, e) {
  var u, c;
  if (a2 == null || i == null)
    return i;
  const t = (e == null ? void 0 : e.getStyleByCell(a2)) || a2.s, r = (e == null ? void 0 : e.getStyleByCell(i)) || i.s;
  if (t == null || r == null || typeof t != "object" || typeof r != "object")
    return i;
  const n = (u = t == null ? void 0 : t.n) == null ? void 0 : u.pattern, s = (c = r == null ? void 0 : r.n) == null ? void 0 : c.pattern;
  if (n == null || s == null)
    return i;
  const o = n || s;
  return r.n.pattern = o, i;
}
var Qs = new xt(1e5);
function Si(a2) {
  const i = Qs.get(a2);
  if (i !== void 0)
    return i;
  const e = uf(a2);
  return Qs.set(a2, e), e;
}
function of2() {
  Qs.clear();
}
function uf(a2) {
  if (cf(a2))
    return 3;
  const i = a1.getFormatInfo(a2).type || "unknown";
  return af[i];
}
function cf(a2) {
  return !!sf.find((i) => a2.includes(i)) && a2.startsWith("_(");
}
function on(a2, i, e) {
  if (a2 === "")
    return i;
  if (i === "")
    return a2;
  const t = Si(a2), r = Si(i);
  return e === Z3.PLUS || e === Z3.MINUS ? t === 4 && r === 4 || t === 11 && r === 11 ? "" : i : e === Z3.MULTIPLY || e === Z3.DIVIDED ? t === 6 && r === 6 || t === 7 && r === 7 || t === 8 && r === 8 || t === 9 && r === 9 ? i : "" : a2 || i;
}
var lf = /* @__PURE__ */ new Map([
  [Ts.EN_US, "$"],
  [Ts.RU_RU, "₽"],
  [Ts.VI_VN, "₫"],
  [Ts.ZH_CN, "¥"],
  [Ts.ZH_TW, "NT$"],
  [Ts.FR_FR, "€"],
  [Ts.FA_IR, "﷼"],
  [Ts.KO_KR, "₩"],
  [Ts.ES_ES, "€"],
  [Ts.CA_ES, "€"]
]);
function Mi(a2) {
  return lf.get(a2) || "$";
}
function et2(a2, i = 2) {
  let e = i;
  i > 127 && (e = 127);
  let t = "";
  return e > 0 && (t = `.${"0".repeat(e)}`), `"${Mi(a2)}"#,##0${t}_);[Red]("${Mi(a2)}"#,##0${t})`;
}
function ff(a2, i, e = 2) {
  return a1.format(et2(a2, e), i);
}
var Na = new xt(1e5);
function mf(a2) {
  let i = a2;
  i.startsWith('"') && i.endsWith('"') && (i = i.slice(1, -1));
  const e = Na.get(i);
  if (e)
    return {
      isNumberPattern: true,
      value: e.value,
      pattern: e.pattern
    };
  const t = a1.parseNumber(i);
  if (t && t.z)
    return Os(i, t.v, t.z);
  const r = a1.parseDate(i);
  if (r && r.z)
    return Os(i, r.v, r.z);
  const n = a1.parseTime(i);
  return n && n.z ? Os(i, n.v, n.z) : {
    isNumberPattern: false
  };
}
function Os(a2, i, e) {
  return Na.set(a2, {
    value: i,
    pattern: e
  }), {
    isNumberPattern: true,
    value: i,
    pattern: e
  };
}
function hf() {
  Na.clear();
}
var Qt = class extends ts {
  constructor(e) {
    super();
    A(this, "_customData");
    this._rawValue = e;
  }
  isValueObject() {
    return true;
  }
  toUnitRange() {
    return {
      range: {
        startColumn: -1,
        startRow: -1,
        endRow: -1,
        endColumn: -1
      },
      sheetId: "",
      unitId: ""
    };
  }
  getValue() {
    return 0;
  }
  getArrayValue() {
    return [];
  }
  setValue(e) {
  }
  setArrayValue(e) {
  }
  withCustomData(e) {
    return this._customData = e, this;
  }
  getCustomData() {
    return this._customData;
  }
  isCube() {
    return false;
  }
  isString() {
    return false;
  }
  isNumber() {
    return false;
  }
  isBoolean() {
    return false;
  }
  isLambda() {
    return false;
  }
  isDateFormat() {
    return false;
  }
  isError() {
    return false;
  }
  isNull() {
    return false;
  }
  isHyperlink() {
    return false;
  }
  isImage() {
    return false;
  }
  sum() {
    return g2.create(h.VALUE);
  }
  max() {
    return g2.create(h.VALUE);
  }
  min() {
    return g2.create(h.VALUE);
  }
  count() {
    return g2.create(h.VALUE);
  }
  countA() {
    return g2.create(h.VALUE);
  }
  countBlank() {
    return g2.create(h.VALUE);
  }
  getNegative() {
    return g2.create(h.VALUE);
  }
  getReciprocal() {
    return g2.create(h.VALUE);
  }
  plus(e) {
    return g2.create(h.VALUE);
  }
  minus(e) {
    return g2.create(h.VALUE);
  }
  multiply(e) {
    return g2.create(h.VALUE);
  }
  divided(e) {
    return g2.create(h.VALUE);
  }
  mod(e) {
    return g2.create(h.VALUE);
  }
  /**
   * return every value in the array after the callback function, excluding the error value
   * @param callbackFn
   * @returns
   */
  map(e) {
    return g2.create(h.NAME);
  }
  /**
   * return every value in the array after the callback function
   * @param callbackFn
   * @returns
   */
  mapValue(e) {
    return g2.create(h.NAME);
  }
  compare(e, t, r = false) {
    return g2.create(h.NAME);
  }
  isEqual(e) {
    return this.compare(e, Y2.EQUALS);
  }
  isNotEqual(e) {
    return this.compare(e, Y2.NOT_EQUAL);
  }
  isGreaterThanOrEqual(e) {
    return this.compare(e, Y2.GREATER_THAN_OR_EQUAL);
  }
  isLessThanOrEqual(e) {
    return this.compare(e, Y2.LESS_THAN_OR_EQUAL);
  }
  isLessThan(e) {
    return this.compare(e, Y2.LESS_THAN);
  }
  isGreaterThan(e) {
    return this.compare(e, Y2.GREATER_THAN);
  }
  concatenateFront(e) {
    return g2.create(h.NAME);
  }
  concatenateBack(e) {
    return g2.create(h.NAME);
  }
  plusBy(e) {
    return g2.create(h.VALUE);
  }
  minusBy(e) {
    return g2.create(h.VALUE);
  }
  multiplyBy(e) {
    return g2.create(h.VALUE);
  }
  dividedBy(e) {
    return g2.create(h.VALUE);
  }
  modInverse(e) {
    return g2.create(h.VALUE);
  }
  compareBy(e, t, r = false) {
    return g2.create(h.NAME);
  }
  concatenate(e, t = ft.FRONT) {
    let r = this.getValue().toString();
    if (typeof e == "string")
      t === ft.FRONT ? r = e + r : r += e;
    else if (typeof e == "number")
      t === ft.FRONT ? r = e.toString() + r : r += e.toString();
    else if (typeof e == "boolean") {
      const n = e ? "TRUE" : "FALSE";
      t === ft.FRONT ? r = n + r : r += n;
    }
    return r;
  }
  pow(e) {
    return g2.create(h.VALUE);
  }
  powInverse(e) {
    return g2.create(h.VALUE);
  }
  sqrt() {
    return g2.create(h.VALUE);
  }
  cbrt() {
    return g2.create(h.VALUE);
  }
  cos() {
    return g2.create(h.VALUE);
  }
  cosh() {
    return g2.create(h.VALUE);
  }
  acos() {
    return g2.create(h.VALUE);
  }
  acosh() {
    return g2.create(h.VALUE);
  }
  sin() {
    return g2.create(h.VALUE);
  }
  sinh() {
    return g2.create(h.VALUE);
  }
  asin() {
    return g2.create(h.VALUE);
  }
  asinh() {
    return g2.create(h.VALUE);
  }
  tan() {
    return g2.create(h.VALUE);
  }
  tanh() {
    return g2.create(h.VALUE);
  }
  atan() {
    return g2.create(h.VALUE);
  }
  atan2(e) {
    return g2.create(h.VALUE);
  }
  atan2Inverse(e) {
    return g2.create(h.VALUE);
  }
  atanh() {
    return g2.create(h.VALUE);
  }
  /**
   * Calculate the mean of the entire array.
   *
   * reference https://numpy.org/doc/stable/reference/generated/numpy.mean.html#numpy.mean
   *
   */
  mean() {
    return this;
  }
  /**
   * Calculate the median of the entire array.
   *
   * reference https://numpy.org/doc/stable/reference/generated/numpy.median.html
   *
   */
  median() {
    return this;
  }
  /**
   * Calculate the variance of the entire array.
   *
   * reference https://numpy.org/doc/stable/reference/generated/numpy.var.html
   */
  var() {
    return this;
  }
  /**
   * Calculate the standard deviation of the entire array.
   *
   * reference https://numpy.org/doc/stable/reference/generated/numpy.std.html
   */
  std() {
    return this;
  }
  log() {
    return g2.create(h.VALUE);
  }
  log10() {
    return g2.create(h.VALUE);
  }
  exp() {
    return g2.create(h.VALUE);
  }
  abs() {
    return g2.create(h.VALUE);
  }
  round(e) {
    return g2.create(h.VALUE);
  }
  roundInverse(e) {
    return g2.create(h.VALUE);
  }
  floor(e) {
    return g2.create(h.VALUE);
  }
  floorInverse(e) {
    return g2.create(h.VALUE);
  }
  ceil(e) {
    return g2.create(h.VALUE);
  }
  ceilInverse(e) {
    return g2.create(h.VALUE);
  }
  convertToNumberObjectValue() {
    return g2.create(h.VALUE);
  }
  convertToBooleanObjectValue() {
    return g2.create(h.VALUE);
  }
};
var gf = 1e3;
var qs = new xt(gf);
var g2 = class _g2 extends Qt {
  constructor(i, e = "") {
    super(i), this._errorType = i, this._errorContent = e;
  }
  static create(i, e = "") {
    const t = `${i}-${e}`, r = qs.get(t);
    if (r)
      return r;
    const n = new _g2(i, e);
    return qs.set(t, n), n;
  }
  getValue() {
    return this._errorType;
  }
  getErrorType() {
    return this._errorType;
  }
  getErrorContent() {
    return this._errorContent;
  }
  isEqualType(i) {
    return i.getErrorType() === this.getErrorType();
  }
  isError() {
    return true;
  }
};
function Va(a2) {
  let i;
  switch (a2) {
    case Y2.EQUALS:
      i = Y2.EQUALS;
      break;
    case Y2.GREATER_THAN:
      i = Y2.LESS_THAN;
      break;
    case Y2.GREATER_THAN_OR_EQUAL:
      i = Y2.LESS_THAN_OR_EQUAL;
      break;
    case Y2.LESS_THAN:
      i = Y2.GREATER_THAN;
      break;
    case Y2.LESS_THAN_OR_EQUAL:
      i = Y2.GREATER_THAN_OR_EQUAL;
      break;
    case Y2.NOT_EQUAL:
      i = Y2.NOT_EQUAL;
      break;
  }
  return i;
}
var dr = 9e15;
var qt = 1e9;
var Xs = "0123456789abcdef";
var wn = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
var Ln = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
var Ks = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -dr,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: dr,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: false
  // true/false
};
var To;
var Lt;
var ue2 = true;
var rs = "[DecimalError] ";
var Ht = rs + "Invalid argument: ";
var Io = rs + "Precision limit exceeded";
var Bo = rs + "crypto unavailable";
var Fo = "[object Decimal]";
var $e = Math.floor;
var je = Math.pow;
var df = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
var Cf = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
var _f = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
var ko = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var gt = 1e7;
var se = 7;
var Af = 9007199254740991;
var Ef = wn.length - 1;
var Zs = Ln.length - 1;
var B2 = { toStringTag: Fo };
B2.absoluteValue = B2.abs = function() {
  var a2 = new this.constructor(this);
  return a2.s < 0 && (a2.s = 1), te(a2);
};
B2.ceil = function() {
  return te(new this.constructor(this), this.e + 1, 2);
};
B2.clampedTo = B2.clamp = function(a2, i) {
  var e, t = this, r = t.constructor;
  if (a2 = new r(a2), i = new r(i), !a2.s || !i.s) return new r(NaN);
  if (a2.gt(i)) throw Error(Ht + i);
  return e = t.cmp(a2), e < 0 ? a2 : t.cmp(i) > 0 ? i : new r(t);
};
B2.comparedTo = B2.cmp = function(a2) {
  var i, e, t, r, n = this, s = n.d, o = (a2 = new n.constructor(a2)).d, u = n.s, c = a2.s;
  if (!s || !o)
    return !u || !c ? NaN : u !== c ? u : s === o ? 0 : !s ^ u < 0 ? 1 : -1;
  if (!s[0] || !o[0]) return s[0] ? u : o[0] ? -c : 0;
  if (u !== c) return u;
  if (n.e !== a2.e) return n.e > a2.e ^ u < 0 ? 1 : -1;
  for (t = s.length, r = o.length, i = 0, e = t < r ? t : r; i < e; ++i)
    if (s[i] !== o[i]) return s[i] > o[i] ^ u < 0 ? 1 : -1;
  return t === r ? 0 : t > r ^ u < 0 ? 1 : -1;
};
B2.cosine = B2.cos = function() {
  var a2, i, e = this, t = e.constructor;
  return e.d ? e.d[0] ? (a2 = t.precision, i = t.rounding, t.precision = a2 + Math.max(e.e, e.sd()) + se, t.rounding = 1, e = Rf(t, Wo(t, e)), t.precision = a2, t.rounding = i, te(Lt == 2 || Lt == 3 ? e.neg() : e, a2, i, true)) : new t(1) : new t(NaN);
};
B2.cubeRoot = B2.cbrt = function() {
  var a2, i, e, t, r, n, s, o, u, c, l = this, f2 = l.constructor;
  if (!l.isFinite() || l.isZero()) return new f2(l);
  for (ue2 = false, n = l.s * je(l.s * l, 1 / 3), !n || Math.abs(n) == 1 / 0 ? (e = Te(l.d), a2 = l.e, (n = (a2 - e.length + 1) % 3) && (e += n == 1 || n == -2 ? "0" : "00"), n = je(e, 1 / 3), a2 = $e((a2 + 1) / 3) - (a2 % 3 == (a2 < 0 ? -1 : 2)), n == 1 / 0 ? e = "5e" + a2 : (e = n.toExponential(), e = e.slice(0, e.indexOf("e") + 1) + a2), t = new f2(e), t.s = l.s) : t = new f2(n.toString()), s = (a2 = f2.precision) + 3; ; )
    if (o = t, u = o.times(o).times(o), c = u.plus(l), t = Oe(c.plus(l).times(o), c.plus(u), s + 2, 1), Te(o.d).slice(0, s) === (e = Te(t.d)).slice(0, s))
      if (e = e.slice(s - 3, s + 1), e == "9999" || !r && e == "4999") {
        if (!r && (te(o, a2 + 1, 0), o.times(o).times(o).eq(l))) {
          t = o;
          break;
        }
        s += 4, r = 1;
      } else {
        (!+e || !+e.slice(1) && e.charAt(0) == "5") && (te(t, a2 + 1, 1), i = !t.times(t).times(t).eq(l));
        break;
      }
  return ue2 = true, te(t, a2, f2.rounding, i);
};
B2.decimalPlaces = B2.dp = function() {
  var a2, i = this.d, e = NaN;
  if (i) {
    if (a2 = i.length - 1, e = (a2 - $e(this.e / se)) * se, a2 = i[a2], a2) for (; a2 % 10 == 0; a2 /= 10) e--;
    e < 0 && (e = 0);
  }
  return e;
};
B2.dividedBy = B2.div = function(a2) {
  return Oe(this, new this.constructor(a2));
};
B2.dividedToIntegerBy = B2.divToInt = function(a2) {
  var i = this, e = i.constructor;
  return te(Oe(i, new e(a2), 0, 1, 1), e.precision, e.rounding);
};
B2.equals = B2.eq = function(a2) {
  return this.cmp(a2) === 0;
};
B2.floor = function() {
  return te(new this.constructor(this), this.e + 1, 3);
};
B2.greaterThan = B2.gt = function(a2) {
  return this.cmp(a2) > 0;
};
B2.greaterThanOrEqualTo = B2.gte = function(a2) {
  var i = this.cmp(a2);
  return i == 1 || i === 0;
};
B2.hyperbolicCosine = B2.cosh = function() {
  var a2, i, e, t, r, n = this, s = n.constructor, o = new s(1);
  if (!n.isFinite()) return new s(n.s ? 1 / 0 : NaN);
  if (n.isZero()) return o;
  e = s.precision, t = s.rounding, s.precision = e + Math.max(n.e, n.sd()) + 4, s.rounding = 1, r = n.d.length, r < 32 ? (a2 = Math.ceil(r / 3), i = (1 / ss(4, a2)).toString()) : (a2 = 16, i = "2.3283064365386962890625e-10"), n = Nr(s, 1, n.times(i), new s(1), true);
  for (var u, c = a2, l = new s(8); c--; )
    u = n.times(n), n = o.minus(u.times(l.minus(u.times(l))));
  return te(n, s.precision = e, s.rounding = t, true);
};
B2.hyperbolicSine = B2.sinh = function() {
  var a2, i, e, t, r = this, n = r.constructor;
  if (!r.isFinite() || r.isZero()) return new n(r);
  if (i = n.precision, e = n.rounding, n.precision = i + Math.max(r.e, r.sd()) + 4, n.rounding = 1, t = r.d.length, t < 3)
    r = Nr(n, 2, r, r, true);
  else {
    a2 = 1.4 * Math.sqrt(t), a2 = a2 > 16 ? 16 : a2 | 0, r = r.times(1 / ss(5, a2)), r = Nr(n, 2, r, r, true);
    for (var s, o = new n(5), u = new n(16), c = new n(20); a2--; )
      s = r.times(r), r = r.times(o.plus(s.times(u.times(s).plus(c))));
  }
  return n.precision = i, n.rounding = e, te(r, i, e, true);
};
B2.hyperbolicTangent = B2.tanh = function() {
  var a2, i, e = this, t = e.constructor;
  return e.isFinite() ? e.isZero() ? new t(e) : (a2 = t.precision, i = t.rounding, t.precision = a2 + 7, t.rounding = 1, Oe(e.sinh(), e.cosh(), t.precision = a2, t.rounding = i)) : new t(e.s);
};
B2.inverseCosine = B2.acos = function() {
  var a2 = this, i = a2.constructor, e = a2.abs().cmp(1), t = i.precision, r = i.rounding;
  return e !== -1 ? e === 0 ? a2.isNeg() ? bt(i, t, r) : new i(0) : new i(NaN) : a2.isZero() ? bt(i, t + 4, r).times(0.5) : (i.precision = t + 6, i.rounding = 1, a2 = new i(1).minus(a2).div(a2.plus(1)).sqrt().atan(), i.precision = t, i.rounding = r, a2.times(2));
};
B2.inverseHyperbolicCosine = B2.acosh = function() {
  var a2, i, e = this, t = e.constructor;
  return e.lte(1) ? new t(e.eq(1) ? 0 : NaN) : e.isFinite() ? (a2 = t.precision, i = t.rounding, t.precision = a2 + Math.max(Math.abs(e.e), e.sd()) + 4, t.rounding = 1, ue2 = false, e = e.times(e).minus(1).sqrt().plus(e), ue2 = true, t.precision = a2, t.rounding = i, e.ln()) : new t(e);
};
B2.inverseHyperbolicSine = B2.asinh = function() {
  var a2, i, e = this, t = e.constructor;
  return !e.isFinite() || e.isZero() ? new t(e) : (a2 = t.precision, i = t.rounding, t.precision = a2 + 2 * Math.max(Math.abs(e.e), e.sd()) + 6, t.rounding = 1, ue2 = false, e = e.times(e).plus(1).sqrt().plus(e), ue2 = true, t.precision = a2, t.rounding = i, e.ln());
};
B2.inverseHyperbolicTangent = B2.atanh = function() {
  var a2, i, e, t, r = this, n = r.constructor;
  return r.isFinite() ? r.e >= 0 ? new n(r.abs().eq(1) ? r.s / 0 : r.isZero() ? r : NaN) : (a2 = n.precision, i = n.rounding, t = r.sd(), Math.max(t, a2) < 2 * -r.e - 1 ? te(new n(r), a2, i, true) : (n.precision = e = t - r.e, r = Oe(r.plus(1), new n(1).minus(r), e + a2, 1), n.precision = a2 + 4, n.rounding = 1, r = r.ln(), n.precision = a2, n.rounding = i, r.times(0.5))) : new n(NaN);
};
B2.inverseSine = B2.asin = function() {
  var a2, i, e, t, r = this, n = r.constructor;
  return r.isZero() ? new n(r) : (i = r.abs().cmp(1), e = n.precision, t = n.rounding, i !== -1 ? i === 0 ? (a2 = bt(n, e + 4, t).times(0.5), a2.s = r.s, a2) : new n(NaN) : (n.precision = e + 6, n.rounding = 1, r = r.div(new n(1).minus(r.times(r)).sqrt().plus(1)).atan(), n.precision = e, n.rounding = t, r.times(2)));
};
B2.inverseTangent = B2.atan = function() {
  var a2, i, e, t, r, n, s, o, u, c = this, l = c.constructor, f2 = l.precision, m2 = l.rounding;
  if (c.isFinite()) {
    if (c.isZero())
      return new l(c);
    if (c.abs().eq(1) && f2 + 4 <= Zs)
      return s = bt(l, f2 + 4, m2).times(0.25), s.s = c.s, s;
  } else {
    if (!c.s) return new l(NaN);
    if (f2 + 4 <= Zs)
      return s = bt(l, f2 + 4, m2).times(0.5), s.s = c.s, s;
  }
  for (l.precision = o = f2 + 10, l.rounding = 1, e = Math.min(28, o / se + 2 | 0), a2 = e; a2; --a2) c = c.div(c.times(c).plus(1).sqrt().plus(1));
  for (ue2 = false, i = Math.ceil(o / se), t = 1, u = c.times(c), s = new l(c), r = c; a2 !== -1; )
    if (r = r.times(u), n = s.minus(r.div(t += 2)), r = r.times(u), s = n.plus(r.div(t += 2)), s.d[i] !== void 0) for (a2 = i; s.d[a2] === n.d[a2] && a2--; ) ;
  return e && (s = s.times(2 << e - 1)), ue2 = true, te(s, l.precision = f2, l.rounding = m2, true);
};
B2.isFinite = function() {
  return !!this.d;
};
B2.isInteger = B2.isInt = function() {
  return !!this.d && $e(this.e / se) > this.d.length - 2;
};
B2.isNaN = function() {
  return !this.s;
};
B2.isNegative = B2.isNeg = function() {
  return this.s < 0;
};
B2.isPositive = B2.isPos = function() {
  return this.s > 0;
};
B2.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
B2.lessThan = B2.lt = function(a2) {
  return this.cmp(a2) < 0;
};
B2.lessThanOrEqualTo = B2.lte = function(a2) {
  return this.cmp(a2) < 1;
};
B2.logarithm = B2.log = function(a2) {
  var i, e, t, r, n, s, o, u, c = this, l = c.constructor, f2 = l.precision, m2 = l.rounding, d2 = 5;
  if (a2 == null)
    a2 = new l(10), i = true;
  else {
    if (a2 = new l(a2), e = a2.d, a2.s < 0 || !e || !e[0] || a2.eq(1)) return new l(NaN);
    i = a2.eq(10);
  }
  if (e = c.d, c.s < 0 || !e || !e[0] || c.eq(1))
    return new l(e && !e[0] ? -1 / 0 : c.s != 1 ? NaN : e ? 0 : 1 / 0);
  if (i)
    if (e.length > 1)
      n = true;
    else {
      for (r = e[0]; r % 10 === 0; ) r /= 10;
      n = r !== 1;
    }
  if (ue2 = false, o = f2 + d2, s = Bt(c, o), t = i ? Pn(l, o + 10) : Bt(a2, o), u = Oe(s, t, o, 1), $r(u.d, r = f2, m2))
    do
      if (o += 10, s = Bt(c, o), t = i ? Pn(l, o + 10) : Bt(a2, o), u = Oe(s, t, o, 1), !n) {
        +Te(u.d).slice(r + 1, r + 15) + 1 == 1e14 && (u = te(u, f2 + 1, 0));
        break;
      }
    while ($r(u.d, r += 10, m2));
  return ue2 = true, te(u, f2, m2);
};
B2.minus = B2.sub = function(a2) {
  var i, e, t, r, n, s, o, u, c, l, f2, m2, d2 = this, _2 = d2.constructor;
  if (a2 = new _2(a2), !d2.d || !a2.d)
    return !d2.s || !a2.s ? a2 = new _2(NaN) : d2.d ? a2.s = -a2.s : a2 = new _2(a2.d || d2.s !== a2.s ? d2 : NaN), a2;
  if (d2.s != a2.s)
    return a2.s = -a2.s, d2.plus(a2);
  if (c = d2.d, m2 = a2.d, o = _2.precision, u = _2.rounding, !c[0] || !m2[0]) {
    if (m2[0]) a2.s = -a2.s;
    else if (c[0]) a2 = new _2(d2);
    else return new _2(u === 3 ? -0 : 0);
    return ue2 ? te(a2, o, u) : a2;
  }
  if (e = $e(a2.e / se), l = $e(d2.e / se), c = c.slice(), n = l - e, n) {
    for (f2 = n < 0, f2 ? (i = c, n = -n, s = m2.length) : (i = m2, e = l, s = c.length), t = Math.max(Math.ceil(o / se), s) + 2, n > t && (n = t, i.length = 1), i.reverse(), t = n; t--; ) i.push(0);
    i.reverse();
  } else {
    for (t = c.length, s = m2.length, f2 = t < s, f2 && (s = t), t = 0; t < s; t++)
      if (c[t] != m2[t]) {
        f2 = c[t] < m2[t];
        break;
      }
    n = 0;
  }
  for (f2 && (i = c, c = m2, m2 = i, a2.s = -a2.s), s = c.length, t = m2.length - s; t > 0; --t) c[s++] = 0;
  for (t = m2.length; t > n; ) {
    if (c[--t] < m2[t]) {
      for (r = t; r && c[--r] === 0; ) c[r] = gt - 1;
      --c[r], c[t] += gt;
    }
    c[t] -= m2[t];
  }
  for (; c[--s] === 0; ) c.pop();
  for (; c[0] === 0; c.shift()) --e;
  return c[0] ? (a2.d = c, a2.e = ns(c, e), ue2 ? te(a2, o, u) : a2) : new _2(u === 3 ? -0 : 0);
};
B2.modulo = B2.mod = function(a2) {
  var i, e = this, t = e.constructor;
  return a2 = new t(a2), !e.d || !a2.s || a2.d && !a2.d[0] ? new t(NaN) : !a2.d || e.d && !e.d[0] ? te(new t(e), t.precision, t.rounding) : (ue2 = false, t.modulo == 9 ? (i = Oe(e, a2.abs(), 0, 3, 1), i.s *= a2.s) : i = Oe(e, a2, 0, t.modulo, 1), i = i.times(a2), ue2 = true, e.minus(i));
};
B2.naturalExponential = B2.exp = function() {
  return zs(this);
};
B2.naturalLogarithm = B2.ln = function() {
  return Bt(this);
};
B2.negated = B2.neg = function() {
  var a2 = new this.constructor(this);
  return a2.s = -a2.s, te(a2);
};
B2.plus = B2.add = function(a2) {
  var i, e, t, r, n, s, o, u, c, l, f2 = this, m2 = f2.constructor;
  if (a2 = new m2(a2), !f2.d || !a2.d)
    return !f2.s || !a2.s ? a2 = new m2(NaN) : f2.d || (a2 = new m2(a2.d || f2.s === a2.s ? f2 : NaN)), a2;
  if (f2.s != a2.s)
    return a2.s = -a2.s, f2.minus(a2);
  if (c = f2.d, l = a2.d, o = m2.precision, u = m2.rounding, !c[0] || !l[0])
    return l[0] || (a2 = new m2(f2)), ue2 ? te(a2, o, u) : a2;
  if (n = $e(f2.e / se), t = $e(a2.e / se), c = c.slice(), r = n - t, r) {
    for (r < 0 ? (e = c, r = -r, s = l.length) : (e = l, t = n, s = c.length), n = Math.ceil(o / se), s = n > s ? n + 1 : s + 1, r > s && (r = s, e.length = 1), e.reverse(); r--; ) e.push(0);
    e.reverse();
  }
  for (s = c.length, r = l.length, s - r < 0 && (r = s, e = l, l = c, c = e), i = 0; r; )
    i = (c[--r] = c[r] + l[r] + i) / gt | 0, c[r] %= gt;
  for (i && (c.unshift(i), ++t), s = c.length; c[--s] == 0; ) c.pop();
  return a2.d = c, a2.e = ns(c, t), ue2 ? te(a2, o, u) : a2;
};
B2.precision = B2.sd = function(a2) {
  var i, e = this;
  if (a2 !== void 0 && a2 !== !!a2 && a2 !== 1 && a2 !== 0) throw Error(Ht + a2);
  return e.d ? (i = $o(e.d), a2 && e.e + 1 > i && (i = e.e + 1)) : i = NaN, i;
};
B2.round = function() {
  var a2 = this, i = a2.constructor;
  return te(new i(a2), a2.e + 1, i.rounding);
};
B2.sine = B2.sin = function() {
  var a2, i, e = this, t = e.constructor;
  return e.isFinite() ? e.isZero() ? new t(e) : (a2 = t.precision, i = t.rounding, t.precision = a2 + Math.max(e.e, e.sd()) + se, t.rounding = 1, e = yf(t, Wo(t, e)), t.precision = a2, t.rounding = i, te(Lt > 2 ? e.neg() : e, a2, i, true)) : new t(NaN);
};
B2.squareRoot = B2.sqrt = function() {
  var a2, i, e, t, r, n, s = this, o = s.d, u = s.e, c = s.s, l = s.constructor;
  if (c !== 1 || !o || !o[0])
    return new l(!c || c < 0 && (!o || o[0]) ? NaN : o ? s : 1 / 0);
  for (ue2 = false, c = Math.sqrt(+s), c == 0 || c == 1 / 0 ? (i = Te(o), (i.length + u) % 2 == 0 && (i += "0"), c = Math.sqrt(i), u = $e((u + 1) / 2) - (u < 0 || u % 2), c == 1 / 0 ? i = "5e" + u : (i = c.toExponential(), i = i.slice(0, i.indexOf("e") + 1) + u), t = new l(i)) : t = new l(c.toString()), e = (u = l.precision) + 3; ; )
    if (n = t, t = n.plus(Oe(s, n, e + 2, 1)).times(0.5), Te(n.d).slice(0, e) === (i = Te(t.d)).slice(0, e))
      if (i = i.slice(e - 3, e + 1), i == "9999" || !r && i == "4999") {
        if (!r && (te(n, u + 1, 0), n.times(n).eq(s))) {
          t = n;
          break;
        }
        e += 4, r = 1;
      } else {
        (!+i || !+i.slice(1) && i.charAt(0) == "5") && (te(t, u + 1, 1), a2 = !t.times(t).eq(s));
        break;
      }
  return ue2 = true, te(t, u, l.rounding, a2);
};
B2.tangent = B2.tan = function() {
  var a2, i, e = this, t = e.constructor;
  return e.isFinite() ? e.isZero() ? new t(e) : (a2 = t.precision, i = t.rounding, t.precision = a2 + 10, t.rounding = 1, e = e.sin(), e.s = 1, e = Oe(e, new t(1).minus(e.times(e)).sqrt(), a2 + 10, 0), t.precision = a2, t.rounding = i, te(Lt == 2 || Lt == 4 ? e.neg() : e, a2, i, true)) : new t(NaN);
};
B2.times = B2.mul = function(a2) {
  var i, e, t, r, n, s, o, u, c, l = this, f2 = l.constructor, m2 = l.d, d2 = (a2 = new f2(a2)).d;
  if (a2.s *= l.s, !m2 || !m2[0] || !d2 || !d2[0])
    return new f2(!a2.s || m2 && !m2[0] && !d2 || d2 && !d2[0] && !m2 ? NaN : !m2 || !d2 ? a2.s / 0 : a2.s * 0);
  for (e = $e(l.e / se) + $e(a2.e / se), u = m2.length, c = d2.length, u < c && (n = m2, m2 = d2, d2 = n, s = u, u = c, c = s), n = [], s = u + c, t = s; t--; ) n.push(0);
  for (t = c; --t >= 0; ) {
    for (i = 0, r = u + t; r > t; )
      o = n[r] + d2[t] * m2[r - t - 1] + i, n[r--] = o % gt | 0, i = o / gt | 0;
    n[r] = (n[r] + i) % gt | 0;
  }
  for (; !n[--s]; ) n.pop();
  return i ? ++e : n.shift(), a2.d = n, a2.e = ns(n, e), ue2 ? te(a2, f2.precision, f2.rounding) : a2;
};
B2.toBinary = function(a2, i) {
  return Oa(this, 2, a2, i);
};
B2.toDecimalPlaces = B2.toDP = function(a2, i) {
  var e = this, t = e.constructor;
  return e = new t(e), a2 === void 0 ? e : (Qe(a2, 0, qt), i === void 0 ? i = t.rounding : Qe(i, 0, 8), te(e, a2 + e.e + 1, i));
};
B2.toExponential = function(a2, i) {
  var e, t = this, r = t.constructor;
  return a2 === void 0 ? e = pt(t, true) : (Qe(a2, 0, qt), i === void 0 ? i = r.rounding : Qe(i, 0, 8), t = te(new r(t), a2 + 1, i), e = pt(t, true, a2 + 1)), t.isNeg() && !t.isZero() ? "-" + e : e;
};
B2.toFixed = function(a2, i) {
  var e, t, r = this, n = r.constructor;
  return a2 === void 0 ? e = pt(r) : (Qe(a2, 0, qt), i === void 0 ? i = n.rounding : Qe(i, 0, 8), t = te(new n(r), a2 + r.e + 1, i), e = pt(t, false, a2 + t.e + 1)), r.isNeg() && !r.isZero() ? "-" + e : e;
};
B2.toFraction = function(a2) {
  var i, e, t, r, n, s, o, u, c, l, f2, m2, d2 = this, _2 = d2.d, C = d2.constructor;
  if (!_2) return new C(d2);
  if (c = e = new C(1), t = u = new C(0), i = new C(t), n = i.e = $o(_2) - d2.e - 1, s = n % se, i.d[0] = je(10, s < 0 ? se + s : s), a2 == null)
    a2 = n > 0 ? i : c;
  else {
    if (o = new C(a2), !o.isInt() || o.lt(c)) throw Error(Ht + o);
    a2 = o.gt(i) ? n > 0 ? i : c : o;
  }
  for (ue2 = false, o = new C(Te(_2)), l = C.precision, C.precision = n = _2.length * se * 2; f2 = Oe(o, i, 0, 1, 1), r = e.plus(f2.times(t)), r.cmp(a2) != 1; )
    e = t, t = r, r = c, c = u.plus(f2.times(r)), u = r, r = i, i = o.minus(f2.times(r)), o = r;
  return r = Oe(a2.minus(e), t, 0, 1, 1), u = u.plus(r.times(c)), e = e.plus(r.times(t)), u.s = c.s = d2.s, m2 = Oe(c, t, n, 1).minus(d2).abs().cmp(Oe(u, e, n, 1).minus(d2).abs()) < 1 ? [c, t] : [u, e], C.precision = l, ue2 = true, m2;
};
B2.toHexadecimal = B2.toHex = function(a2, i) {
  return Oa(this, 16, a2, i);
};
B2.toNearest = function(a2, i) {
  var e = this, t = e.constructor;
  if (e = new t(e), a2 == null) {
    if (!e.d) return e;
    a2 = new t(1), i = t.rounding;
  } else {
    if (a2 = new t(a2), i === void 0 ? i = t.rounding : Qe(i, 0, 8), !e.d) return a2.s ? e : a2;
    if (!a2.d)
      return a2.s && (a2.s = e.s), a2;
  }
  return a2.d[0] ? (ue2 = false, e = Oe(e, a2, 0, i, 1).times(a2), ue2 = true, te(e)) : (a2.s = e.s, e = a2), e;
};
B2.toNumber = function() {
  return +this;
};
B2.toOctal = function(a2, i) {
  return Oa(this, 8, a2, i);
};
B2.toPower = B2.pow = function(a2) {
  var i, e, t, r, n, s, o = this, u = o.constructor, c = +(a2 = new u(a2));
  if (!o.d || !a2.d || !o.d[0] || !a2.d[0]) return new u(je(+o, c));
  if (o = new u(o), o.eq(1)) return o;
  if (t = u.precision, n = u.rounding, a2.eq(1)) return te(o, t, n);
  if (i = $e(a2.e / se), i >= a2.d.length - 1 && (e = c < 0 ? -c : c) <= Af)
    return r = Yo(u, o, e, t), a2.s < 0 ? new u(1).div(r) : te(r, t, n);
  if (s = o.s, s < 0) {
    if (i < a2.d.length - 1) return new u(NaN);
    if ((a2.d[i] & 1) == 0 && (s = 1), o.e == 0 && o.d[0] == 1 && o.d.length == 1)
      return o.s = s, o;
  }
  return e = je(+o, c), i = e == 0 || !isFinite(e) ? $e(c * (Math.log("0." + Te(o.d)) / Math.LN10 + o.e + 1)) : new u(e + "").e, i > u.maxE + 1 || i < u.minE - 1 ? new u(i > 0 ? s / 0 : 0) : (ue2 = false, u.rounding = o.s = 1, e = Math.min(12, (i + "").length), r = zs(a2.times(Bt(o, t + e)), t), r.d && (r = te(r, t + 5, 1), $r(r.d, t, n) && (i = t + 10, r = te(zs(a2.times(Bt(o, i + e)), i), i + 5, 1), +Te(r.d).slice(t + 1, t + 15) + 1 == 1e14 && (r = te(r, t + 1, 0)))), r.s = s, ue2 = true, u.rounding = n, te(r, t, n));
};
B2.toPrecision = function(a2, i) {
  var e, t = this, r = t.constructor;
  return a2 === void 0 ? e = pt(t, t.e <= r.toExpNeg || t.e >= r.toExpPos) : (Qe(a2, 1, qt), i === void 0 ? i = r.rounding : Qe(i, 0, 8), t = te(new r(t), a2, i), e = pt(t, a2 <= t.e || t.e <= r.toExpNeg, a2)), t.isNeg() && !t.isZero() ? "-" + e : e;
};
B2.toSignificantDigits = B2.toSD = function(a2, i) {
  var e = this, t = e.constructor;
  return a2 === void 0 ? (a2 = t.precision, i = t.rounding) : (Qe(a2, 1, qt), i === void 0 ? i = t.rounding : Qe(i, 0, 8)), te(new t(e), a2, i);
};
B2.toString = function() {
  var a2 = this, i = a2.constructor, e = pt(a2, a2.e <= i.toExpNeg || a2.e >= i.toExpPos);
  return a2.isNeg() && !a2.isZero() ? "-" + e : e;
};
B2.truncated = B2.trunc = function() {
  return te(new this.constructor(this), this.e + 1, 1);
};
B2.valueOf = B2.toJSON = function() {
  var a2 = this, i = a2.constructor, e = pt(a2, a2.e <= i.toExpNeg || a2.e >= i.toExpPos);
  return a2.isNeg() ? "-" + e : e;
};
function Te(a2) {
  var i, e, t, r = a2.length - 1, n = "", s = a2[0];
  if (r > 0) {
    for (n += s, i = 1; i < r; i++)
      t = a2[i] + "", e = se - t.length, e && (n += Tt(e)), n += t;
    s = a2[i], t = s + "", e = se - t.length, e && (n += Tt(e));
  } else if (s === 0)
    return "0";
  for (; s % 10 === 0; ) s /= 10;
  return n + s;
}
function Qe(a2, i, e) {
  if (a2 !== ~~a2 || a2 < i || a2 > e)
    throw Error(Ht + a2);
}
function $r(a2, i, e, t) {
  var r, n, s, o;
  for (n = a2[0]; n >= 10; n /= 10) --i;
  return --i < 0 ? (i += se, r = 0) : (r = Math.ceil((i + 1) / se), i %= se), n = je(10, se - i), o = a2[r] % n | 0, t == null ? i < 3 ? (i == 0 ? o = o / 100 | 0 : i == 1 && (o = o / 10 | 0), s = e < 4 && o == 99999 || e > 3 && o == 49999 || o == 5e4 || o == 0) : s = (e < 4 && o + 1 == n || e > 3 && o + 1 == n / 2) && (a2[r + 1] / n / 100 | 0) == je(10, i - 2) - 1 || (o == n / 2 || o == 0) && (a2[r + 1] / n / 100 | 0) == 0 : i < 4 ? (i == 0 ? o = o / 1e3 | 0 : i == 1 ? o = o / 100 | 0 : i == 2 && (o = o / 10 | 0), s = (t || e < 4) && o == 9999 || !t && e > 3 && o == 4999) : s = ((t || e < 4) && o + 1 == n || !t && e > 3 && o + 1 == n / 2) && (a2[r + 1] / n / 1e3 | 0) == je(10, i - 3) - 1, s;
}
function Rn(a2, i, e) {
  for (var t, r = [0], n, s = 0, o = a2.length; s < o; ) {
    for (n = r.length; n--; ) r[n] *= i;
    for (r[0] += Xs.indexOf(a2.charAt(s++)), t = 0; t < r.length; t++)
      r[t] > e - 1 && (r[t + 1] === void 0 && (r[t + 1] = 0), r[t + 1] += r[t] / e | 0, r[t] %= e);
  }
  return r.reverse();
}
function Rf(a2, i) {
  var e, t, r;
  if (i.isZero()) return i;
  t = i.d.length, t < 32 ? (e = Math.ceil(t / 3), r = (1 / ss(4, e)).toString()) : (e = 16, r = "2.3283064365386962890625e-10"), a2.precision += e, i = Nr(a2, 1, i.times(r), new a2(1));
  for (var n = e; n--; ) {
    var s = i.times(i);
    i = s.times(s).minus(s).times(8).plus(1);
  }
  return a2.precision -= e, i;
}
var Oe = /* @__PURE__ */ function() {
  function a2(t, r, n) {
    var s, o = 0, u = t.length;
    for (t = t.slice(); u--; )
      s = t[u] * r + o, t[u] = s % n | 0, o = s / n | 0;
    return o && t.unshift(o), t;
  }
  function i(t, r, n, s) {
    var o, u;
    if (n != s)
      u = n > s ? 1 : -1;
    else
      for (o = u = 0; o < n; o++)
        if (t[o] != r[o]) {
          u = t[o] > r[o] ? 1 : -1;
          break;
        }
    return u;
  }
  function e(t, r, n, s) {
    for (var o = 0; n--; )
      t[n] -= o, o = t[n] < r[n] ? 1 : 0, t[n] = o * s + t[n] - r[n];
    for (; !t[0] && t.length > 1; ) t.shift();
  }
  return function(t, r, n, s, o, u) {
    var c, l, f2, m2, d2, _2, C, E, R, b, p2, V, S2, M2, D2, w, L, v, j2, k, G2 = t.constructor, ne = t.s == r.s ? 1 : -1, z = t.d, $2 = r.d;
    if (!z || !z[0] || !$2 || !$2[0])
      return new G2(
        // Return NaN if either NaN, or both Infinity or 0.
        !t.s || !r.s || (z ? $2 && z[0] == $2[0] : !$2) ? NaN : (
          // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.
          z && z[0] == 0 || !$2 ? ne * 0 : ne / 0
        )
      );
    for (u ? (d2 = 1, l = t.e - r.e) : (u = gt, d2 = se, l = $e(t.e / d2) - $e(r.e / d2)), j2 = $2.length, L = z.length, R = new G2(ne), b = R.d = [], f2 = 0; $2[f2] == (z[f2] || 0); f2++) ;
    if ($2[f2] > (z[f2] || 0) && l--, n == null ? (M2 = n = G2.precision, s = G2.rounding) : o ? M2 = n + (t.e - r.e) + 1 : M2 = n, M2 < 0)
      b.push(1), _2 = true;
    else {
      if (M2 = M2 / d2 + 2 | 0, f2 = 0, j2 == 1) {
        for (m2 = 0, $2 = $2[0], M2++; (f2 < L || m2) && M2--; f2++)
          D2 = m2 * u + (z[f2] || 0), b[f2] = D2 / $2 | 0, m2 = D2 % $2 | 0;
        _2 = m2 || f2 < L;
      } else {
        for (m2 = u / ($2[0] + 1) | 0, m2 > 1 && ($2 = a2($2, m2, u), z = a2(z, m2, u), j2 = $2.length, L = z.length), w = j2, p2 = z.slice(0, j2), V = p2.length; V < j2; ) p2[V++] = 0;
        k = $2.slice(), k.unshift(0), v = $2[0], $2[1] >= u / 2 && ++v;
        do
          m2 = 0, c = i($2, p2, j2, V), c < 0 ? (S2 = p2[0], j2 != V && (S2 = S2 * u + (p2[1] || 0)), m2 = S2 / v | 0, m2 > 1 ? (m2 >= u && (m2 = u - 1), C = a2($2, m2, u), E = C.length, V = p2.length, c = i(C, p2, E, V), c == 1 && (m2--, e(C, j2 < E ? k : $2, E, u))) : (m2 == 0 && (c = m2 = 1), C = $2.slice()), E = C.length, E < V && C.unshift(0), e(p2, C, V, u), c == -1 && (V = p2.length, c = i($2, p2, j2, V), c < 1 && (m2++, e(p2, j2 < V ? k : $2, V, u))), V = p2.length) : c === 0 && (m2++, p2 = [0]), b[f2++] = m2, c && p2[0] ? p2[V++] = z[w] || 0 : (p2 = [z[w]], V = 1);
        while ((w++ < L || p2[0] !== void 0) && M2--);
        _2 = p2[0] !== void 0;
      }
      b[0] || b.shift();
    }
    if (d2 == 1)
      R.e = l, To = _2;
    else {
      for (f2 = 1, m2 = b[0]; m2 >= 10; m2 /= 10) f2++;
      R.e = f2 + l * d2 - 1, te(R, o ? n + R.e + 1 : n, s, _2);
    }
    return R;
  };
}();
function te(a2, i, e, t) {
  var r, n, s, o, u, c, l, f2, m2, d2 = a2.constructor;
  e: if (i != null) {
    if (f2 = a2.d, !f2) return a2;
    for (r = 1, o = f2[0]; o >= 10; o /= 10) r++;
    if (n = i - r, n < 0)
      n += se, s = i, l = f2[m2 = 0], u = l / je(10, r - s - 1) % 10 | 0;
    else if (m2 = Math.ceil((n + 1) / se), o = f2.length, m2 >= o)
      if (t) {
        for (; o++ <= m2; ) f2.push(0);
        l = u = 0, r = 1, n %= se, s = n - se + 1;
      } else
        break e;
    else {
      for (l = o = f2[m2], r = 1; o >= 10; o /= 10) r++;
      n %= se, s = n - se + r, u = s < 0 ? 0 : l / je(10, r - s - 1) % 10 | 0;
    }
    if (t = t || i < 0 || f2[m2 + 1] !== void 0 || (s < 0 ? l : l % je(10, r - s - 1)), c = e < 4 ? (u || t) && (e == 0 || e == (a2.s < 0 ? 3 : 2)) : u > 5 || u == 5 && (e == 4 || t || e == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (n > 0 ? s > 0 ? l / je(10, r - s) : 0 : f2[m2 - 1]) % 10 & 1 || e == (a2.s < 0 ? 8 : 7)), i < 1 || !f2[0])
      return f2.length = 0, c ? (i -= a2.e + 1, f2[0] = je(10, (se - i % se) % se), a2.e = -i || 0) : f2[0] = a2.e = 0, a2;
    if (n == 0 ? (f2.length = m2, o = 1, m2--) : (f2.length = m2 + 1, o = je(10, se - n), f2[m2] = s > 0 ? (l / je(10, r - s) % je(10, s) | 0) * o : 0), c)
      for (; ; )
        if (m2 == 0) {
          for (n = 1, s = f2[0]; s >= 10; s /= 10) n++;
          for (s = f2[0] += o, o = 1; s >= 10; s /= 10) o++;
          n != o && (a2.e++, f2[0] == gt && (f2[0] = 1));
          break;
        } else {
          if (f2[m2] += o, f2[m2] != gt) break;
          f2[m2--] = 0, o = 1;
        }
    for (n = f2.length; f2[--n] === 0; ) f2.pop();
  }
  return ue2 && (a2.e > d2.maxE ? (a2.d = null, a2.e = NaN) : a2.e < d2.minE && (a2.e = 0, a2.d = [0])), a2;
}
function pt(a2, i, e) {
  if (!a2.isFinite()) return Go(a2);
  var t, r = a2.e, n = Te(a2.d), s = n.length;
  return i ? (e && (t = e - s) > 0 ? n = n.charAt(0) + "." + n.slice(1) + Tt(t) : s > 1 && (n = n.charAt(0) + "." + n.slice(1)), n = n + (a2.e < 0 ? "e" : "e+") + a2.e) : r < 0 ? (n = "0." + Tt(-r - 1) + n, e && (t = e - s) > 0 && (n += Tt(t))) : r >= s ? (n += Tt(r + 1 - s), e && (t = e - r - 1) > 0 && (n = n + "." + Tt(t))) : ((t = r + 1) < s && (n = n.slice(0, t) + "." + n.slice(t)), e && (t = e - s) > 0 && (r + 1 === s && (n += "."), n += Tt(t))), n;
}
function ns(a2, i) {
  var e = a2[0];
  for (i *= se; e >= 10; e /= 10) i++;
  return i;
}
function Pn(a2, i, e) {
  if (i > Ef)
    throw ue2 = true, e && (a2.precision = e), Error(Io);
  return te(new a2(wn), i, 1, true);
}
function bt(a2, i, e) {
  if (i > Zs) throw Error(Io);
  return te(new a2(Ln), i, e, true);
}
function $o(a2) {
  var i = a2.length - 1, e = i * se + 1;
  if (i = a2[i], i) {
    for (; i % 10 == 0; i /= 10) e--;
    for (i = a2[0]; i >= 10; i /= 10) e++;
  }
  return e;
}
function Tt(a2) {
  for (var i = ""; a2--; ) i += "0";
  return i;
}
function Yo(a2, i, e, t) {
  var r, n = new a2(1), s = Math.ceil(t / se + 4);
  for (ue2 = false; ; ) {
    if (e % 2 && (n = n.times(i), wi(n.d, s) && (r = true)), e = $e(e / 2), e === 0) {
      e = n.d.length - 1, r && n.d[e] === 0 && ++n.d[e];
      break;
    }
    i = i.times(i), wi(i.d, s);
  }
  return ue2 = true, n;
}
function Di(a2) {
  return a2.d[a2.d.length - 1] & 1;
}
function Ho(a2, i, e) {
  for (var t, r, n = new a2(i[0]), s = 0; ++s < i.length; ) {
    if (r = new a2(i[s]), !r.s) {
      n = r;
      break;
    }
    t = n.cmp(r), (t === e || t === 0 && n.s === e) && (n = r);
  }
  return n;
}
function zs(a2, i) {
  var e, t, r, n, s, o, u, c = 0, l = 0, f2 = 0, m2 = a2.constructor, d2 = m2.rounding, _2 = m2.precision;
  if (!a2.d || !a2.d[0] || a2.e > 17)
    return new m2(a2.d ? a2.d[0] ? a2.s < 0 ? 0 : 1 / 0 : 1 : a2.s ? a2.s < 0 ? 0 : a2 : NaN);
  for (i == null ? (ue2 = false, u = _2) : u = i, o = new m2(0.03125); a2.e > -2; )
    a2 = a2.times(o), f2 += 5;
  for (t = Math.log(je(2, f2)) / Math.LN10 * 2 + 5 | 0, u += t, e = n = s = new m2(1), m2.precision = u; ; ) {
    if (n = te(n.times(a2), u, 1), e = e.times(++l), o = s.plus(Oe(n, e, u, 1)), Te(o.d).slice(0, u) === Te(s.d).slice(0, u)) {
      for (r = f2; r--; ) s = te(s.times(s), u, 1);
      if (i == null)
        if (c < 3 && $r(s.d, u - t, d2, c))
          m2.precision = u += 10, e = n = o = new m2(1), l = 0, c++;
        else
          return te(s, m2.precision = _2, d2, ue2 = true);
      else
        return m2.precision = _2, s;
    }
    s = o;
  }
}
function Bt(a2, i) {
  var e, t, r, n, s, o, u, c, l, f2, m2, d2 = 1, _2 = 10, C = a2, E = C.d, R = C.constructor, b = R.rounding, p2 = R.precision;
  if (C.s < 0 || !E || !E[0] || !C.e && E[0] == 1 && E.length == 1)
    return new R(E && !E[0] ? -1 / 0 : C.s != 1 ? NaN : E ? 0 : C);
  if (i == null ? (ue2 = false, l = p2) : l = i, R.precision = l += _2, e = Te(E), t = e.charAt(0), Math.abs(n = C.e) < 15e14) {
    for (; t < 7 && t != 1 || t == 1 && e.charAt(1) > 3; )
      C = C.times(a2), e = Te(C.d), t = e.charAt(0), d2++;
    n = C.e, t > 1 ? (C = new R("0." + e), n++) : C = new R(t + "." + e.slice(1));
  } else
    return c = Pn(R, l + 2, p2).times(n + ""), C = Bt(new R(t + "." + e.slice(1)), l - _2).plus(c), R.precision = p2, i == null ? te(C, p2, b, ue2 = true) : C;
  for (f2 = C, u = s = C = Oe(C.minus(1), C.plus(1), l, 1), m2 = te(C.times(C), l, 1), r = 3; ; ) {
    if (s = te(s.times(m2), l, 1), c = u.plus(Oe(s, new R(r), l, 1)), Te(c.d).slice(0, l) === Te(u.d).slice(0, l))
      if (u = u.times(2), n !== 0 && (u = u.plus(Pn(R, l + 2, p2).times(n + ""))), u = Oe(u, new R(d2), l, 1), i == null)
        if ($r(u.d, l - _2, b, o))
          R.precision = l += _2, c = s = C = Oe(f2.minus(1), f2.plus(1), l, 1), m2 = te(C.times(C), l, 1), r = o = 1;
        else
          return te(u, R.precision = p2, b, ue2 = true);
      else
        return R.precision = p2, u;
    u = c, r += 2;
  }
}
function Go(a2) {
  return String(a2.s * a2.s / 0);
}
function bn(a2, i) {
  var e, t, r;
  for ((e = i.indexOf(".")) > -1 && (i = i.replace(".", "")), (t = i.search(/e/i)) > 0 ? (e < 0 && (e = t), e += +i.slice(t + 1), i = i.substring(0, t)) : e < 0 && (e = i.length), t = 0; i.charCodeAt(t) === 48; t++) ;
  for (r = i.length; i.charCodeAt(r - 1) === 48; --r) ;
  if (i = i.slice(t, r), i) {
    if (r -= t, a2.e = e = e - t - 1, a2.d = [], t = (e + 1) % se, e < 0 && (t += se), t < r) {
      for (t && a2.d.push(+i.slice(0, t)), r -= se; t < r; ) a2.d.push(+i.slice(t, t += se));
      i = i.slice(t), t = se - i.length;
    } else
      t -= r;
    for (; t--; ) i += "0";
    a2.d.push(+i), ue2 && (a2.e > a2.constructor.maxE ? (a2.d = null, a2.e = NaN) : a2.e < a2.constructor.minE && (a2.e = 0, a2.d = [0]));
  } else
    a2.e = 0, a2.d = [0];
  return a2;
}
function bf(a2, i) {
  var e, t, r, n, s, o, u, c, l;
  if (i.indexOf("_") > -1) {
    if (i = i.replace(/(\d)_(?=\d)/g, "$1"), ko.test(i)) return bn(a2, i);
  } else if (i === "Infinity" || i === "NaN")
    return +i || (a2.s = NaN), a2.e = NaN, a2.d = null, a2;
  if (Cf.test(i))
    e = 16, i = i.toLowerCase();
  else if (df.test(i))
    e = 2;
  else if (_f.test(i))
    e = 8;
  else
    throw Error(Ht + i);
  for (n = i.search(/p/i), n > 0 ? (u = +i.slice(n + 1), i = i.substring(2, n)) : i = i.slice(2), n = i.indexOf("."), s = n >= 0, t = a2.constructor, s && (i = i.replace(".", ""), o = i.length, n = o - n, r = Yo(t, new t(e), n, n * 2)), c = Rn(i, e, gt), l = c.length - 1, n = l; c[n] === 0; --n) c.pop();
  return n < 0 ? new t(a2.s * 0) : (a2.e = ns(c, l), a2.d = c, ue2 = false, s && (a2 = Oe(a2, r, o * 4)), u && (a2 = a2.times(Math.abs(u) < 54 ? je(2, u) : x2.pow(2, u))), ue2 = true, a2);
}
function yf(a2, i) {
  var e, t = i.d.length;
  if (t < 3)
    return i.isZero() ? i : Nr(a2, 2, i, i);
  e = 1.4 * Math.sqrt(t), e = e > 16 ? 16 : e | 0, i = i.times(1 / ss(5, e)), i = Nr(a2, 2, i, i);
  for (var r, n = new a2(5), s = new a2(16), o = new a2(20); e--; )
    r = i.times(i), i = i.times(n.plus(r.times(s.times(r).minus(o))));
  return i;
}
function Nr(a2, i, e, t, r) {
  var n, s, o, u, c = a2.precision, l = Math.ceil(c / se);
  for (ue2 = false, u = e.times(e), o = new a2(t); ; ) {
    if (s = Oe(o.times(u), new a2(i++ * i++), c, 1), o = r ? t.plus(s) : t.minus(s), t = Oe(s.times(u), new a2(i++ * i++), c, 1), s = o.plus(t), s.d[l] !== void 0) {
      for (n = l; s.d[n] === o.d[n] && n--; ) ;
      if (n == -1) break;
    }
    n = o, o = t, t = s, s = n;
  }
  return ue2 = true, s.d.length = l + 1, s;
}
function ss(a2, i) {
  for (var e = a2; --i; ) e *= a2;
  return e;
}
function Wo(a2, i) {
  var e, t = i.s < 0, r = bt(a2, a2.precision, 1), n = r.times(0.5);
  if (i = i.abs(), i.lte(n))
    return Lt = t ? 4 : 1, i;
  if (e = i.divToInt(r), e.isZero())
    Lt = t ? 3 : 2;
  else {
    if (i = i.minus(e.times(r)), i.lte(n))
      return Lt = Di(e) ? t ? 2 : 3 : t ? 4 : 1, i;
    Lt = Di(e) ? t ? 1 : 4 : t ? 3 : 2;
  }
  return i.minus(r).abs();
}
function Oa(a2, i, e, t) {
  var r, n, s, o, u, c, l, f2, m2, d2 = a2.constructor, _2 = e !== void 0;
  if (_2 ? (Qe(e, 1, qt), t === void 0 ? t = d2.rounding : Qe(t, 0, 8)) : (e = d2.precision, t = d2.rounding), !a2.isFinite())
    l = Go(a2);
  else {
    for (l = pt(a2), s = l.indexOf("."), _2 ? (r = 2, i == 16 ? e = e * 4 - 3 : i == 8 && (e = e * 3 - 2)) : r = i, s >= 0 && (l = l.replace(".", ""), m2 = new d2(1), m2.e = l.length - s, m2.d = Rn(pt(m2), 10, r), m2.e = m2.d.length), f2 = Rn(l, 10, r), n = u = f2.length; f2[--u] == 0; ) f2.pop();
    if (!f2[0])
      l = _2 ? "0p+0" : "0";
    else {
      if (s < 0 ? n-- : (a2 = new d2(a2), a2.d = f2, a2.e = n, a2 = Oe(a2, m2, e, t, 0, r), f2 = a2.d, n = a2.e, c = To), s = f2[e], o = r / 2, c = c || f2[e + 1] !== void 0, c = t < 4 ? (s !== void 0 || c) && (t === 0 || t === (a2.s < 0 ? 3 : 2)) : s > o || s === o && (t === 4 || c || t === 6 && f2[e - 1] & 1 || t === (a2.s < 0 ? 8 : 7)), f2.length = e, c)
        for (; ++f2[--e] > r - 1; )
          f2[e] = 0, e || (++n, f2.unshift(1));
      for (u = f2.length; !f2[u - 1]; --u) ;
      for (s = 0, l = ""; s < u; s++) l += Xs.charAt(f2[s]);
      if (_2) {
        if (u > 1)
          if (i == 16 || i == 8) {
            for (s = i == 16 ? 4 : 3, --u; u % s; u++) l += "0";
            for (f2 = Rn(l, r, i), u = f2.length; !f2[u - 1]; --u) ;
            for (s = 1, l = "1."; s < u; s++) l += Xs.charAt(f2[s]);
          } else
            l = l.charAt(0) + "." + l.slice(1);
        l = l + (n < 0 ? "p" : "p+") + n;
      } else if (n < 0) {
        for (; ++n; ) l = "0" + l;
        l = "0." + l;
      } else if (++n > u) for (n -= u; n--; ) l += "0";
      else n < u && (l = l.slice(0, n) + "." + l.slice(n));
    }
    l = (i == 16 ? "0x" : i == 2 ? "0b" : i == 8 ? "0o" : "") + l;
  }
  return a2.s < 0 ? "-" + l : l;
}
function wi(a2, i) {
  if (a2.length > i)
    return a2.length = i, true;
}
function pf(a2) {
  return new this(a2).abs();
}
function Nf(a2) {
  return new this(a2).acos();
}
function Vf(a2) {
  return new this(a2).acosh();
}
function Of(a2, i) {
  return new this(a2).plus(i);
}
function Sf(a2) {
  return new this(a2).asin();
}
function Mf(a2) {
  return new this(a2).asinh();
}
function Df(a2) {
  return new this(a2).atan();
}
function wf(a2) {
  return new this(a2).atanh();
}
function Lf(a2, i) {
  a2 = new this(a2), i = new this(i);
  var e, t = this.precision, r = this.rounding, n = t + 4;
  return !a2.s || !i.s ? e = new this(NaN) : !a2.d && !i.d ? (e = bt(this, n, 1).times(i.s > 0 ? 0.25 : 0.75), e.s = a2.s) : !i.d || a2.isZero() ? (e = i.s < 0 ? bt(this, t, r) : new this(0), e.s = a2.s) : !a2.d || i.isZero() ? (e = bt(this, n, 1).times(0.5), e.s = a2.s) : i.s < 0 ? (this.precision = n, this.rounding = 1, e = this.atan(Oe(a2, i, n, 1)), i = bt(this, n, 1), this.precision = t, this.rounding = r, e = a2.s < 0 ? e.minus(i) : e.plus(i)) : e = this.atan(Oe(a2, i, n, 1)), e;
}
function Pf(a2) {
  return new this(a2).cbrt();
}
function xf(a2) {
  return te(a2 = new this(a2), a2.e + 1, 2);
}
function jf(a2, i, e) {
  return new this(a2).clamp(i, e);
}
function Uf(a2) {
  if (!a2 || typeof a2 != "object") throw Error(rs + "Object expected");
  var i, e, t, r = a2.defaults === true, n = [
    "precision",
    1,
    qt,
    "rounding",
    0,
    8,
    "toExpNeg",
    -dr,
    0,
    "toExpPos",
    0,
    dr,
    "maxE",
    0,
    dr,
    "minE",
    -dr,
    0,
    "modulo",
    0,
    9
  ];
  for (i = 0; i < n.length; i += 3)
    if (e = n[i], r && (this[e] = Ks[e]), (t = a2[e]) !== void 0)
      if ($e(t) === t && t >= n[i + 1] && t <= n[i + 2]) this[e] = t;
      else throw Error(Ht + e + ": " + t);
  if (e = "crypto", r && (this[e] = Ks[e]), (t = a2[e]) !== void 0)
    if (t === true || t === false || t === 0 || t === 1)
      if (t)
        if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
          this[e] = true;
        else
          throw Error(Bo);
      else
        this[e] = false;
    else
      throw Error(Ht + e + ": " + t);
  return this;
}
function vf(a2) {
  return new this(a2).cos();
}
function Tf(a2) {
  return new this(a2).cosh();
}
function Qo(a2) {
  var i, e, t;
  function r(n) {
    var s, o, u, c = this;
    if (!(c instanceof r)) return new r(n);
    if (c.constructor = r, Li(n)) {
      c.s = n.s, ue2 ? !n.d || n.e > r.maxE ? (c.e = NaN, c.d = null) : n.e < r.minE ? (c.e = 0, c.d = [0]) : (c.e = n.e, c.d = n.d.slice()) : (c.e = n.e, c.d = n.d ? n.d.slice() : n.d);
      return;
    }
    if (u = typeof n, u === "number") {
      if (n === 0) {
        c.s = 1 / n < 0 ? -1 : 1, c.e = 0, c.d = [0];
        return;
      }
      if (n < 0 ? (n = -n, c.s = -1) : c.s = 1, n === ~~n && n < 1e7) {
        for (s = 0, o = n; o >= 10; o /= 10) s++;
        ue2 ? s > r.maxE ? (c.e = NaN, c.d = null) : s < r.minE ? (c.e = 0, c.d = [0]) : (c.e = s, c.d = [n]) : (c.e = s, c.d = [n]);
        return;
      }
      if (n * 0 !== 0) {
        n || (c.s = NaN), c.e = NaN, c.d = null;
        return;
      }
      return bn(c, n.toString());
    }
    if (u === "string")
      return (o = n.charCodeAt(0)) === 45 ? (n = n.slice(1), c.s = -1) : (o === 43 && (n = n.slice(1)), c.s = 1), ko.test(n) ? bn(c, n) : bf(c, n);
    if (u === "bigint")
      return n < 0 ? (n = -n, c.s = -1) : c.s = 1, bn(c, n.toString());
    throw Error(Ht + n);
  }
  if (r.prototype = B2, r.ROUND_UP = 0, r.ROUND_DOWN = 1, r.ROUND_CEIL = 2, r.ROUND_FLOOR = 3, r.ROUND_HALF_UP = 4, r.ROUND_HALF_DOWN = 5, r.ROUND_HALF_EVEN = 6, r.ROUND_HALF_CEIL = 7, r.ROUND_HALF_FLOOR = 8, r.EUCLID = 9, r.config = r.set = Uf, r.clone = Qo, r.isDecimal = Li, r.abs = pf, r.acos = Nf, r.acosh = Vf, r.add = Of, r.asin = Sf, r.asinh = Mf, r.atan = Df, r.atanh = wf, r.atan2 = Lf, r.cbrt = Pf, r.ceil = xf, r.clamp = jf, r.cos = vf, r.cosh = Tf, r.div = If, r.exp = Bf, r.floor = Ff, r.hypot = kf, r.ln = $f, r.log = Yf, r.log10 = Gf, r.log2 = Hf, r.max = Wf, r.min = Qf, r.mod = qf, r.mul = Xf, r.pow = Kf, r.random = Zf, r.round = zf, r.sign = Jf, r.sin = em, r.sinh = tm, r.sqrt = rm, r.sub = nm, r.sum = sm, r.tan = am, r.tanh = im, r.trunc = om, a2 === void 0 && (a2 = {}), a2 && a2.defaults !== true)
    for (t = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], i = 0; i < t.length; ) a2.hasOwnProperty(e = t[i++]) || (a2[e] = this[e]);
  return r.config(a2), r;
}
function If(a2, i) {
  return new this(a2).div(i);
}
function Bf(a2) {
  return new this(a2).exp();
}
function Ff(a2) {
  return te(a2 = new this(a2), a2.e + 1, 3);
}
function kf() {
  var a2, i, e = new this(0);
  for (ue2 = false, a2 = 0; a2 < arguments.length; )
    if (i = new this(arguments[a2++]), i.d)
      e.d && (e = e.plus(i.times(i)));
    else {
      if (i.s)
        return ue2 = true, new this(1 / 0);
      e = i;
    }
  return ue2 = true, e.sqrt();
}
function Li(a2) {
  return a2 instanceof x2 || a2 && a2.toStringTag === Fo || false;
}
function $f(a2) {
  return new this(a2).ln();
}
function Yf(a2, i) {
  return new this(a2).log(i);
}
function Hf(a2) {
  return new this(a2).log(2);
}
function Gf(a2) {
  return new this(a2).log(10);
}
function Wf() {
  return Ho(this, arguments, -1);
}
function Qf() {
  return Ho(this, arguments, 1);
}
function qf(a2, i) {
  return new this(a2).mod(i);
}
function Xf(a2, i) {
  return new this(a2).mul(i);
}
function Kf(a2, i) {
  return new this(a2).pow(i);
}
function Zf(a2) {
  var i, e, t, r, n = 0, s = new this(1), o = [];
  if (a2 === void 0 ? a2 = this.precision : Qe(a2, 1, qt), t = Math.ceil(a2 / se), this.crypto)
    if (crypto.getRandomValues)
      for (i = crypto.getRandomValues(new Uint32Array(t)); n < t; )
        r = i[n], r >= 429e7 ? i[n] = crypto.getRandomValues(new Uint32Array(1))[0] : o[n++] = r % 1e7;
    else if (crypto.randomBytes) {
      for (i = crypto.randomBytes(t *= 4); n < t; )
        r = i[n] + (i[n + 1] << 8) + (i[n + 2] << 16) + ((i[n + 3] & 127) << 24), r >= 214e7 ? crypto.randomBytes(4).copy(i, n) : (o.push(r % 1e7), n += 4);
      n = t / 4;
    } else
      throw Error(Bo);
  else for (; n < t; ) o[n++] = Math.random() * 1e7 | 0;
  for (t = o[--n], a2 %= se, t && a2 && (r = je(10, se - a2), o[n] = (t / r | 0) * r); o[n] === 0; n--) o.pop();
  if (n < 0)
    e = 0, o = [0];
  else {
    for (e = -1; o[0] === 0; e -= se) o.shift();
    for (t = 1, r = o[0]; r >= 10; r /= 10) t++;
    t < se && (e -= se - t);
  }
  return s.e = e, s.d = o, s;
}
function zf(a2) {
  return te(a2 = new this(a2), a2.e + 1, this.rounding);
}
function Jf(a2) {
  return a2 = new this(a2), a2.d ? a2.d[0] ? a2.s : 0 * a2.s : a2.s || NaN;
}
function em(a2) {
  return new this(a2).sin();
}
function tm(a2) {
  return new this(a2).sinh();
}
function rm(a2) {
  return new this(a2).sqrt();
}
function nm(a2, i) {
  return new this(a2).sub(i);
}
function sm() {
  var a2 = 0, i = arguments, e = new this(i[a2]);
  for (ue2 = false; e.s && ++a2 < i.length; ) e = e.plus(i[a2]);
  return ue2 = true, te(e, this.precision, this.rounding);
}
function am(a2) {
  return new this(a2).tan();
}
function im(a2) {
  return new this(a2).tanh();
}
function om(a2) {
  return te(a2 = new this(a2), a2.e + 1, 1);
}
B2[Symbol.for("nodejs.util.inspect.custom")] = B2.toString;
B2[Symbol.toStringTag] = "Decimal";
var x2 = B2.constructor = Qo(Ks);
wn = new x2(wn);
Ln = new x2(Ln);
function um(a2, i) {
  const e = a2 + i;
  return Number.isSafeInteger(e) ? e : new x2(a2).add(i).toNumber();
}
function cm(a2, i) {
  const e = a2 - i;
  return Number.isSafeInteger(e) ? e : new x2(a2).sub(i).toNumber();
}
function xr(a2, i) {
  const e = a2 * i;
  return Number.isSafeInteger(e) ? e : new x2(a2).mul(i).toNumber();
}
function lm(a2, i) {
  const e = a2 / i;
  return Number.isSafeInteger(e) ? e : new x2(a2).div(i).toNumber();
}
function kt(a2, i) {
  const e = __pow(10, Math.trunc(i)), t = as(a2, e);
  return Math.round(xr(a2, e) + t) / e;
}
function Ze2(a2, i) {
  const e = __pow(10, Math.trunc(i)), t = as(a2, e);
  return Math.floor(xr(a2, e) + t) / e;
}
function We(a2, i) {
  const e = __pow(10, Math.trunc(i)), t = as(a2, e);
  return Math.ceil(xr(a2, e) - t) / e;
}
function as(a2, i) {
  return Number.EPSILON * Math.max(1, Math.abs(xr(a2, i)));
}
function Pi(a2, i) {
  return a2 - i * Math.floor(a2 / i);
}
function fm(a2, i) {
  return __pow(a2, i);
}
function mm(a2) {
  return Math.sqrt(a2);
}
function xi(a2, i) {
  return a2 === i;
}
function hm(a2, i) {
  return a2 > i;
}
function gm(a2, i) {
  return a2 >= i;
}
function dm(a2, i) {
  return a2 < i;
}
function Cm(a2, i) {
  return a2 <= i;
}
function ji(a2, i = 15) {
  return Math.floor(Math.abs(a2)).toString().length >= i ? a2 : Number.parseFloat(a2.toPrecision(i));
}
function _m(a2, i, e = Number.EPSILON) {
  return Math.abs(a2 - i) < e;
}
function Sa(a2, i = 12, e = 1e-10) {
  const t = ji(a2, i);
  return _m(a2, t, e) ? t : ji(a2);
}
function Am(a2) {
  return a2 - Math.trunc(a2);
}
var zn = class zn2 extends Qt {
  static create() {
    return this._instance = this._instance || new zn2(0), this._instance;
  }
  isNull() {
    return true;
  }
  plus(i) {
    return y2.create(0).plus(i);
  }
  minus(i) {
    return y2.create(0).minus(i);
  }
  multiply(i) {
    return y2.create(0).multiply(i);
  }
  divided(i) {
    return y2.create(0).divided(i);
  }
  mod(i) {
    return y2.create(0).mod(i);
  }
  compare(i, e) {
    return i.isString() ? U2.create("").compare(i, e) : i.isBoolean() ? T.create(false).compare(i, e) : y2.create(0).compare(i, e);
  }
  concatenateFront(i) {
    return i.isArray() ? i.concatenateBack(U2.create("")) : U2.create(this.concatenate(i.getValue(), ft.FRONT));
  }
  concatenateBack(i) {
    return i.isArray() ? i.concatenateFront(U2.create("")) : U2.create(this.concatenate(i.getValue(), ft.BACK));
  }
  plusBy(i) {
    return y2.create(0).plusBy(i);
  }
  minusBy(i) {
    return y2.create(0).minusBy(i);
  }
  multiplyBy(i) {
    return y2.create(0).multiplyBy(i);
  }
  dividedBy(i) {
    return y2.create(0).dividedBy(i);
  }
  compareBy(i, e) {
    return typeof i == "string" ? U2.create("").compareBy(i, e) : typeof i == "boolean" ? T.create(false).compareBy(i, e) : y2.create(0).compareBy(i, e);
  }
  pow(i) {
    return y2.create(0).pow(i);
  }
  sqrt() {
    return y2.create(0).sqrt();
  }
  cbrt() {
    return y2.create(0).cbrt();
  }
  cos() {
    return y2.create(0).cos();
  }
  cosh() {
    return y2.create(0).cosh();
  }
  acos() {
    return y2.create(0).acos();
  }
  acosh() {
    return y2.create(0).acosh();
  }
  sin() {
    return y2.create(0).sin();
  }
  sinh() {
    return y2.create(0).sinh();
  }
  asin() {
    return y2.create(0).asin();
  }
  asinh() {
    return y2.create(0).asinh();
  }
  tan() {
    return y2.create(0).tan();
  }
  tanh() {
    return y2.create(0).tanh();
  }
  atan() {
    return y2.create(0).atan();
  }
  atan2(i) {
    return y2.create(0).atan2(i);
  }
  atanh() {
    return y2.create(0).atanh();
  }
  log() {
    return g2.create(h.NUM);
  }
  log10() {
    return g2.create(h.NUM);
  }
  exp() {
    return y2.create(0).exp();
  }
  abs() {
    return y2.create(0).abs();
  }
  round(i) {
    return y2.create(0).round(i);
  }
  floor(i) {
    return y2.create(0).floor(i);
  }
  ceil(i) {
    return y2.create(0).ceil(i);
  }
  convertToNumberObjectValue() {
    return y2.create(0);
  }
  convertToBooleanObjectValue() {
    return T.create(false);
  }
};
A(zn, "_instance");
var ce = zn;
var Jt = class Jt2 extends Qt {
  constructor(e) {
    super(e);
    A(this, "_value", false);
    this._value = e;
  }
  static create(e) {
    return e ? (this._instanceTrue = this._instanceTrue || new Jt2(true), this._instanceTrue) : (this._instanceFalse = this._instanceFalse || new Jt2(false), this._instanceFalse);
  }
  getValue() {
    return this._value;
  }
  isBoolean() {
    return true;
  }
  getNegative() {
    const e = this.getValue();
    let t = 0;
    return e && (t = 1), y2.create(-t);
  }
  getReciprocal() {
    return this.getValue() ? y2.create(1) : g2.create(h.DIV_BY_ZERO);
  }
  plus(e) {
    return this._convertToNumber().plus(e);
  }
  minus(e) {
    return this._convertToNumber().minus(e);
  }
  multiply(e) {
    return this._convertToNumber().multiply(e);
  }
  divided(e) {
    return this._convertToNumber().divided(e);
  }
  mod(e) {
    return this._convertToNumber().mod(e);
  }
  compare(e, t) {
    return e.isArray() ? e.compare(this, Va(t)) : e.isNull() ? this._convertToNumber().compare(e, t) : this.compareBy(e.getValue(), t);
  }
  compareBy(e, t) {
    let r = false;
    if (typeof e == "string" || typeof e == "number")
      r = this._compareString(t);
    else if (typeof e == "boolean") {
      const n = y2.create(e ? 1 : 0);
      return this._convertToNumber().compare(n, t);
    }
    return Jt2.create(r);
  }
  _compareString(e) {
    switch (e) {
      case Y2.GREATER_THAN:
      case Y2.GREATER_THAN_OR_EQUAL:
        return true;
      case Y2.EQUALS:
      case Y2.LESS_THAN:
      case Y2.LESS_THAN_OR_EQUAL:
      case Y2.NOT_EQUAL:
        return false;
    }
  }
  concatenateFront(e) {
    return this._convertToNumber().concatenateFront(e);
  }
  concatenateBack(e) {
    return this._convertToNumber().concatenateBack(e);
  }
  _convertToNumber() {
    const e = this.getValue();
    let t = 0;
    return e && (t = 1), y2.create(t);
  }
  pow(e) {
    return this._convertToNumber().pow(e);
  }
  sqrt() {
    return this._convertToNumber().sqrt();
  }
  cbrt() {
    return this._convertToNumber().cbrt();
  }
  cos() {
    return this._convertToNumber().cos();
  }
  cosh() {
    return this._convertToNumber().cosh();
  }
  acos() {
    return this._convertToNumber().acos();
  }
  acosh() {
    return this._convertToNumber().acosh();
  }
  sin() {
    return this._convertToNumber().sin();
  }
  sinh() {
    return this._convertToNumber().sinh();
  }
  asin() {
    return this._convertToNumber().asin();
  }
  asinh() {
    return this._convertToNumber().asinh();
  }
  tan() {
    return this._convertToNumber().tan();
  }
  tanh() {
    return this._convertToNumber().tanh();
  }
  atan() {
    return this._convertToNumber().atan();
  }
  atan2(e) {
    return this._convertToNumber().atan2(e);
  }
  atanh() {
    return this._convertToNumber().atanh();
  }
  log() {
    return this._convertToNumber().log();
  }
  log10() {
    return this._convertToNumber().log10();
  }
  exp() {
    return this._convertToNumber().exp();
  }
  abs() {
    return this._convertToNumber().abs();
  }
  round(e) {
    return this._convertToNumber().round(e);
  }
  floor(e) {
    return this._convertToNumber().floor(e);
  }
  ceil(e) {
    return this._convertToNumber().ceil(e);
  }
  convertToNumberObjectValue() {
    return Yr(this.getValue());
  }
  convertToBooleanObjectValue() {
    return this;
  }
};
A(Jt, "_instanceTrue"), A(Jt, "_instanceFalse");
var T = Jt;
var y2 = class _y extends Qt {
  constructor(e) {
    super(e);
    A(this, "_value", 0);
    this._value = Number(e);
  }
  static create(e, t = "") {
    const r = new _y(e);
    return t && r.setPattern(t), r;
  }
  getValue() {
    return this._value;
  }
  setValue(e) {
    this._value = e;
  }
  isNumber() {
    return true;
  }
  getNegative() {
    return _y.create(0).minus(this);
  }
  getReciprocal() {
    return _y.create(1).divided(this);
  }
  plus(e) {
    if (e.isArray())
      return e.plus(this);
    let t = e;
    e.isNumber() || (t = e.convertToNumberObjectValue());
    let r = this.plusBy(t.getValue());
    if (r.isError())
      return r;
    const n = on(this.getPattern(), t.getPattern(), Z3.PLUS);
    return r = _y.create(Number(r.getValue()), n), r;
  }
  equalZero() {
    return this._value === 0;
  }
  minus(e) {
    if (e.isArray()) {
      const s = e.getNegative();
      return s.isError() ? s : s.plus(this);
    }
    let t = e;
    e.isNumber() || (t = e.convertToNumberObjectValue());
    let r = this.minusBy(t.getValue());
    if (r.isError())
      return r;
    const n = on(this.getPattern(), t.getPattern(), Z3.MINUS);
    return r = _y.create(Number(r.getValue()), n), r;
  }
  multiply(e) {
    if (e.isArray())
      return e.multiply(this);
    let t = e;
    e.isNumber() || (t = e.convertToNumberObjectValue());
    let r = this.multiplyBy(t.getValue());
    if (r.isError())
      return r;
    const n = on(this.getPattern(), t.getPattern(), Z3.MULTIPLY);
    return r = _y.create(Number(r.getValue()), n), r;
  }
  divided(e) {
    if (e.isArray()) {
      const s = e.getReciprocal();
      return s.isError() ? s : s.multiply(this);
    }
    let t = e;
    e.isNumber() || (t = e.convertToNumberObjectValue());
    let r = this.dividedBy(t.getValue());
    if (r.isError())
      return r;
    const n = on(this.getPattern(), t.getPattern(), Z3.DIVIDED);
    return r = _y.create(Number(r.getValue()), n), r;
  }
  mod(e) {
    if (e.isArray())
      return e.modInverse(this);
    const t = this.getValue(), r = e.getValue();
    if (e.isNull())
      return g2.create(h.DIV_BY_ZERO);
    if (typeof r == "string")
      return g2.create(h.VALUE);
    if (typeof r == "number") {
      if (r === 0)
        return g2.create(h.DIV_BY_ZERO);
      if (!Number.isFinite(t) || !Number.isFinite(r) || Math.abs(r) * 11259e8 <= Math.abs(t))
        return g2.create(h.NUM);
      const n = Pi(t, r);
      return Number.isFinite(n) ? _y.create(n) : g2.create(h.NUM);
    }
    if (typeof r == "boolean") {
      const n = r ? 1 : 0;
      return n === 0 ? g2.create(h.DIV_BY_ZERO) : _y.create(Pi(t, n));
    }
    return this;
  }
  concatenateFront(e) {
    return e.isArray() ? e.concatenateBack(this) : U2.create(this.concatenate(e.getValue(), ft.FRONT));
  }
  concatenateBack(e) {
    return e.isArray() ? e.concatenateFront(this) : U2.create(this.concatenate(e.getValue(), ft.BACK));
  }
  isDateFormat() {
    const e = this.getPattern();
    return a1.isDateFormat(e);
  }
  compare(e, t) {
    if (e.isArray())
      return e.compare(this, Va(t));
    let r = false;
    return e.isDateFormat() && this.isDateFormat() && (r = true), this.compareBy(e.getValue(), t, r);
  }
  plusBy(e) {
    if (typeof e == "string" && e.trim() === "")
      return g2.create(h.VALUE);
    const t = +this.getValue(), r = +e;
    if (Number.isNaN(t) || Number.isNaN(r))
      return g2.create(h.VALUE);
    if (!Number.isFinite(t) || !Number.isFinite(r))
      return g2.create(h.NUM);
    const n = um(t, r);
    return Number.isFinite(n) ? _y.create(n) : g2.create(h.NUM);
  }
  minusBy(e) {
    if (typeof e == "string" && e.trim() === "")
      return g2.create(h.VALUE);
    const t = +this.getValue(), r = +e;
    if (Number.isNaN(t) || Number.isNaN(r))
      return g2.create(h.VALUE);
    if (!Number.isFinite(t) || !Number.isFinite(r))
      return g2.create(h.NUM);
    const n = cm(t, r);
    return Number.isFinite(n) ? _y.create(n) : g2.create(h.NUM);
  }
  multiplyBy(e) {
    if (typeof e == "string" && e.trim() === "")
      return g2.create(h.VALUE);
    const t = +this.getValue(), r = +e;
    if (Number.isNaN(t) || Number.isNaN(r))
      return g2.create(h.VALUE);
    if (!Number.isFinite(t) || !Number.isFinite(r))
      return g2.create(h.NUM);
    const n = xr(t, r);
    return Number.isFinite(n) ? _y.create(n) : g2.create(h.NUM);
  }
  dividedBy(e) {
    if (typeof e == "string" && e.trim() === "")
      return g2.create(h.VALUE);
    const t = +this.getValue(), r = +e;
    if (Number.isNaN(t) || Number.isNaN(r))
      return g2.create(h.VALUE);
    if (!Number.isFinite(t) || !Number.isFinite(r))
      return g2.create(h.NUM);
    if (r === 0)
      return g2.create(h.DIV_BY_ZERO);
    const n = lm(t, r);
    return Number.isFinite(n) ? _y.create(n) : g2.create(h.NUM);
  }
  compareBy(e, t, r = false) {
    const n = this.getValue();
    let s = false, o = n, u = e;
    return r && (o = Math.round(n * 1e8) / 1e8, u = Math.round(e * 1e8) / 1e8), typeof u == "string" ? s = this._compareString(t) : typeof u == "number" ? s = this._compareNumber(o, u, t) : typeof u == "boolean" && (s = this._compareBoolean(t)), T.create(s);
  }
  _compareString(e) {
    switch (e) {
      case Y2.EQUALS:
      case Y2.GREATER_THAN:
      case Y2.GREATER_THAN_OR_EQUAL:
        return false;
      case Y2.LESS_THAN:
      case Y2.LESS_THAN_OR_EQUAL:
      case Y2.NOT_EQUAL:
        return true;
    }
  }
  _compareNumber(e, t, r) {
    return !Number.isFinite(e) || !Number.isFinite(t) ? this._compareInfinity(e, t, r) : this._compareFiniteNumber(e, t, r);
  }
  _compareFiniteNumber(e, t, r) {
    switch (r) {
      case Y2.EQUALS:
        return xi(e, t);
      case Y2.GREATER_THAN:
        return hm(e, t);
      case Y2.GREATER_THAN_OR_EQUAL:
        return gm(e, t);
      case Y2.LESS_THAN:
        return dm(e, t);
      case Y2.LESS_THAN_OR_EQUAL:
        return Cm(e, t);
      case Y2.NOT_EQUAL:
        return !xi(e, t);
    }
  }
  _compareBoolean(e) {
    switch (e) {
      case Y2.EQUALS:
      case Y2.GREATER_THAN:
      case Y2.GREATER_THAN_OR_EQUAL:
        return false;
      case Y2.LESS_THAN:
      case Y2.LESS_THAN_OR_EQUAL:
      case Y2.NOT_EQUAL:
        return true;
    }
  }
  pow(e) {
    if (e.isArray())
      return e.powInverse(this);
    if (this.isError())
      return this;
    const t = this.getValue();
    let r = e;
    if (e.isString() && (r = e.convertToNumberObjectValue()), r.isError())
      return r;
    const n = +r.getValue();
    if (Number.isNaN(n))
      return g2.create(h.VALUE);
    if (!Number.isFinite(t) || !Number.isFinite(n))
      return g2.create(h.NUM);
    if (t === 0)
      return n < 0 ? g2.create(h.DIV_BY_ZERO) : n === 0 ? g2.create(h.NUM) : _y.create(0);
    const s = fm(t, n);
    return Number.isFinite(s) ? _y.create(s) : g2.create(h.NUM);
  }
  sqrt() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g2.create(h.NUM);
    const t = mm(e);
    return Number.isFinite(t) ? _y.create(t) : g2.create(h.NUM);
  }
  cbrt() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g2.create(h.NUM);
    const t = Math.cbrt(e);
    return Number.isFinite(t) ? _y.create(t) : g2.create(h.NUM);
  }
  cos() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g2.create(h.NUM);
    const t = Math.cos(e);
    return Number.isFinite(t) ? _y.create(t) : g2.create(h.NUM);
  }
  cosh() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g2.create(h.NUM);
    const t = Math.cosh(e);
    return Number.isFinite(t) ? _y.create(t) : g2.create(h.NUM);
  }
  acos() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g2.create(h.NUM);
    const t = Math.acos(e);
    return Number.isNaN(t) ? g2.create(h.NUM) : _y.create(t);
  }
  acosh() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g2.create(h.NUM);
    const t = Math.acosh(e);
    return Number.isNaN(t) ? g2.create(h.NUM) : _y.create(t);
  }
  sin() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g2.create(h.NUM);
    const t = Math.sin(e);
    return Number.isFinite(t) ? _y.create(t) : g2.create(h.NUM);
  }
  sinh() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g2.create(h.NUM);
    const t = Math.sinh(e);
    return Number.isFinite(t) ? _y.create(t) : g2.create(h.NUM);
  }
  asin() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g2.create(h.NUM);
    const t = Math.asin(e);
    return Number.isNaN(t) ? g2.create(h.NUM) : _y.create(t);
  }
  asinh() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g2.create(h.NUM);
    const t = Math.asinh(e);
    return Number.isNaN(t) ? g2.create(h.NUM) : _y.create(t);
  }
  tan() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g2.create(h.NUM);
    const t = Math.tan(e);
    return Number.isFinite(t) ? _y.create(t) : g2.create(h.NUM);
  }
  tanh() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g2.create(h.NUM);
    const t = Math.tanh(e);
    return Number.isFinite(t) ? _y.create(t) : g2.create(h.NUM);
  }
  atan() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g2.create(h.NUM);
    const t = Math.atan(e);
    return Number.isFinite(t) ? _y.create(t) : g2.create(h.NUM);
  }
  atan2(e) {
    if (e.isArray())
      return e.atan2Inverse(this);
    const t = this.getValue(), r = e.getValue();
    if (typeof r == "string")
      return g2.create(h.VALUE);
    if (typeof r == "number") {
      if (!Number.isFinite(t) || !Number.isFinite(r))
        return g2.create(h.NUM);
      if (t === 0 && r === 0)
        return g2.create(h.DIV_BY_ZERO);
      const n = Math.atan2(t, r);
      return Number.isFinite(n) ? _y.create(n) : g2.create(h.NUM);
    }
    return typeof r == "boolean" ? _y.create(Math.atan2(t, r ? 1 : 0)) : this;
  }
  atanh() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g2.create(h.NUM);
    const t = Math.atanh(e);
    return Number.isFinite(t) ? _y.create(t) : g2.create(h.NUM);
  }
  log() {
    const e = this.getValue();
    if (typeof e == "number" && e <= 0 || !Number.isFinite(e))
      return g2.create(h.NUM);
    const t = Math.log(e);
    return Number.isFinite(t) ? _y.create(t) : g2.create(h.NUM);
  }
  log10() {
    const e = this.getValue();
    if (typeof e == "number" && e <= 0 || !Number.isFinite(e))
      return g2.create(h.NUM);
    const t = Math.log10(e);
    return Number.isFinite(t) ? _y.create(t) : g2.create(h.NUM);
  }
  exp() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g2.create(h.NUM);
    const t = Math.exp(e);
    return Number.isFinite(t) ? _y.create(t) : g2.create(h.NUM);
  }
  abs() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g2.create(h.NUM);
    const t = Math.abs(e);
    return Number.isFinite(t) ? _y.create(t) : g2.create(h.NUM);
  }
  round(e) {
    if (e.isArray())
      return e.roundInverse(this);
    const t = this.getValue(), r = e.getValue();
    if (typeof r == "string")
      return g2.create(h.VALUE);
    if (typeof r == "number") {
      if (!Number.isFinite(t) || !Number.isFinite(r))
        return g2.create(h.NUM);
      const n = t < 0 ? -kt(Math.abs(t), r) : kt(t, r);
      return Number.isFinite(n) ? _y.create(n) : g2.create(h.NUM);
    }
    return typeof r == "boolean" ? _y.create(kt(t, r ? 1 : 0)) : this;
  }
  floor(e) {
    if (e.isArray())
      return e.floorInverse(this);
    const t = this.getValue(), r = e.getValue();
    if (typeof r == "string")
      return g2.create(h.VALUE);
    if (typeof r == "number") {
      if (!Number.isFinite(t) || !Number.isFinite(r))
        return g2.create(h.NUM);
      const n = t < 0 ? -Ze2(Math.abs(t), r) : Ze2(t, r);
      return Number.isFinite(n) ? _y.create(n) : g2.create(h.NUM);
    }
    return typeof r == "boolean" ? _y.create(Ze2(t, r ? 1 : 0)) : this;
  }
  ceil(e) {
    if (e.isArray())
      return e.ceilInverse(this);
    const t = this.getValue(), r = e.getValue();
    if (typeof r == "string")
      return g2.create(h.VALUE);
    if (typeof r == "number") {
      if (!Number.isFinite(t) || !Number.isFinite(r))
        return g2.create(h.NUM);
      const n = t < 0 ? -We(Math.abs(t), r) : We(t, r);
      return Number.isFinite(n) ? _y.create(n) : g2.create(h.NUM);
    }
    return typeof r == "boolean" ? _y.create(We(t, r ? 1 : 0)) : this;
  }
  convertToNumberObjectValue() {
    return this;
  }
  convertToBooleanObjectValue() {
    return is(true);
  }
  _compareInfinity(e, t, r) {
    let n = false;
    switch (r) {
      case Y2.EQUALS:
        n = e === t;
        break;
      case Y2.GREATER_THAN:
        n = e > t;
        break;
      case Y2.GREATER_THAN_OR_EQUAL:
        n = e >= t;
        break;
      case Y2.LESS_THAN:
        n = e < t;
        break;
      case Y2.LESS_THAN_OR_EQUAL:
        n = e <= t;
        break;
      case Y2.NOT_EQUAL:
        n = e !== t;
        break;
    }
    return n;
  }
};
var Em = 1e5;
var Js = new xt(Em);
var U2 = class _U extends Qt {
  constructor(e) {
    super(e);
    A(this, "_value");
    A(this, "_isHyperlink", false);
    A(this, "_hyperlinkUrl", "");
    A(this, "_isImage", false);
    A(this, "_imageInfo");
    this._value = e;
  }
  static create(e, t) {
    var s;
    const r = Js.get(e);
    if (r && t && this.checkCacheByOptions(r, t))
      return r;
    const n = new _U(e);
    return t != null && t.isHyperlink && (n._isHyperlink = t.isHyperlink, n._hyperlinkUrl = (s = t.hyperlinkUrl) != null ? s : ""), t != null && t.isImage && (n._isImage = t.isImage, n._imageInfo = t.imageInfo), Js.set(e, n), n;
  }
  static checkCacheByOptions(e, t) {
    return !(e.isHyperlink() !== t.isHyperlink || e.getHyperlinkUrl() !== t.hyperlinkUrl || e.isImage() !== t.isImage || !Z.diffValue(e.getImageInfo(), t.imageInfo));
  }
  getValue() {
    return this._value;
  }
  isString() {
    return true;
  }
  isHyperlink() {
    return this._isHyperlink;
  }
  getHyperlinkUrl() {
    return this._hyperlinkUrl;
  }
  isImage() {
    return this._isImage;
  }
  getImageInfo() {
    return this._imageInfo;
  }
  concatenateFront(e) {
    return e.isArray() ? e.concatenateBack(this) : _U.create(this.concatenate(e.getValue(), ft.FRONT));
  }
  concatenateBack(e) {
    return e.isArray() ? e.concatenateFront(this) : _U.create(this.concatenate(e.getValue(), ft.BACK));
  }
  plus(e) {
    return this.convertToNumberObjectValue().plus(e);
  }
  minus(e) {
    return this.convertToNumberObjectValue().minus(e);
  }
  multiply(e) {
    return this.convertToNumberObjectValue().multiply(e);
  }
  divided(e) {
    return this.convertToNumberObjectValue().divided(e);
  }
  compare(e, t, r) {
    return e.isArray() ? e.compare(this, Va(t), r) : this.compareBy(e.getValue(), t, r);
  }
  compareBy(e, t, r = false) {
    let n = this.getValue(), s = false;
    if (typeof e == "string") {
      let o = e;
      if (r || (n = n.toLocaleLowerCase(), o = o.toLocaleLowerCase()), vo(o))
        return this._checkWildcard(o, t);
      s = this._compareString(n, o, t);
    } else typeof e == "number" ? s = this._compareNumber(t) : typeof e == "boolean" && (s = this._compareBoolean(t));
    return T.create(s);
  }
  _compareString(e, t, r) {
    switch (r) {
      case Y2.EQUALS:
        return e === t;
      case Y2.GREATER_THAN:
        return e > t;
      case Y2.GREATER_THAN_OR_EQUAL:
        return e >= t;
      case Y2.LESS_THAN:
        return e < t;
      case Y2.LESS_THAN_OR_EQUAL:
        return e <= t;
      case Y2.NOT_EQUAL:
        return e !== t;
    }
  }
  _compareNumber(e) {
    switch (e) {
      case Y2.NOT_EQUAL:
      case Y2.GREATER_THAN:
      case Y2.GREATER_THAN_OR_EQUAL:
        return true;
      case Y2.EQUALS:
      case Y2.LESS_THAN:
      case Y2.LESS_THAN_OR_EQUAL:
        return false;
    }
  }
  _compareBoolean(e) {
    switch (e) {
      case Y2.EQUALS:
      case Y2.GREATER_THAN:
      case Y2.GREATER_THAN_OR_EQUAL:
        return false;
      case Y2.LESS_THAN:
      case Y2.LESS_THAN_OR_EQUAL:
      case Y2.NOT_EQUAL:
        return true;
    }
  }
  convertToNumberObjectValue() {
    const e = this.getValue(), t = h1(e);
    return t && t.z ? Yr(t.v, t.z) : Yr(e);
  }
  convertToBooleanObjectValue() {
    return T.create(true);
  }
  _checkWildcard(e, t) {
    const r = this.getValue().toLocaleLowerCase(), n = rf(r, e, t);
    return T.create(n);
  }
};
function is(a2) {
  if (typeof a2 == "boolean")
    return T.create(a2);
  let i = false;
  if (typeof a2 == "string") {
    const e = a2.toLocaleUpperCase();
    e === ir.TRUE ? i = true : e === ir.FALSE && (i = false);
  } else
    a2 === 1 ? i = true : i = false;
  return T.create(i);
}
function Rm(a2) {
  let i = a2.toString();
  return i.charAt(0) === '"' && i.charAt(i.length - 1) === '"' && (i = i.slice(1, -1), i = i.replace(/""/g, '"')), U2.create(i);
}
function Yr(a2, i = "") {
  if (typeof a2 == "boolean") {
    let e = 0;
    return a2 && (e = 1), y2.create(e, i);
  } else {
    if (typeof a2 == "number")
      return Number.isFinite(a2) ? y2.create(a2, i) : g2.create(h.NUM);
    if (s1(a2))
      return y2.create(Number(a2), i);
  }
  return g2.create(h.VALUE);
}
function bm(a2) {
  return "";
}
function qo(a2 = [], i = false) {
  const e = [];
  for (let t = 0; t < a2.length; t++) {
    const r = a2[t];
    e[t] == null && (e[t] = []);
    for (let n = 0; n < r.length; n++) {
      const s = r[n];
      e[t][n] = Pt.create(s, i);
    }
  }
  return e;
}
function ym(a2 = []) {
  const i = [];
  for (let e = 0; e < a2.length; e++) {
    const t = a2[e];
    i[e] == null && (i[e] = []);
    for (let r = 0; r < t.length; r++) {
      const n = t[r];
      n == null ? i[e][r] = null : n.isError() ? i[e][r] = n.getErrorType() : i[e][r] = n.getValue();
    }
  }
  return i;
}
var K2 = class _K extends Qt {
  constructor(e) {
    super(typeof e == "string" ? e : bm());
    A(this, "_values", []);
    A(this, "_rowCount", -1);
    A(this, "_columnCount", -1);
    A(this, "_unitId", "");
    A(this, "_sheetId", "");
    A(this, "_currentRow", -1);
    A(this, "_currentColumn", -1);
    A(this, "_sliceCache", /* @__PURE__ */ new Map());
    A(this, "_flattenCache");
    A(this, "_defaultValue", null);
    A(this, "_flattenPosition");
    this._values = this._formatValue(e);
  }
  /**
   * Create an array value object based on the string or IArrayValueObject data.
   * @param rawValue
   * @returns
   */
  static create(e) {
    return new _K(e);
  }
  /**
   * Create an array value object based on the array data.
   * @param array
   * @returns
   */
  static createByArray(e) {
    const r = {
      calculateValueList: qo(e),
      rowCount: e.length,
      columnCount: e[0].length || 0,
      unitId: "",
      sheetId: "",
      row: -1,
      column: -1
    };
    return new _K(r);
  }
  dispose() {
    this._values = [], this._defaultValue = null, this._flattenPosition = null, this._clearCache();
  }
  clone() {
    return this.map((e) => e);
  }
  getRowCount() {
    return this._rowCount;
  }
  setRowCount(e) {
    this._rowCount = e;
  }
  getColumnCount() {
    return this._columnCount;
  }
  setColumnCount(e) {
    this._columnCount = e;
  }
  setCurrent(e, t) {
    this._currentRow = e, this._currentColumn = t;
  }
  setUnitId(e) {
    this._unitId = e;
  }
  getUnitId() {
    return this._unitId;
  }
  setSheetId(e) {
    this._sheetId = e;
  }
  getSheetId() {
    return this._sheetId;
  }
  getCurrentRow() {
    return this._currentRow;
  }
  getCurrentColumn() {
    return this._currentColumn;
  }
  getArrayValue() {
    return this._values;
  }
  setArrayValue(e) {
    this._clearCache(), this._values = e;
  }
  isArray() {
    return true;
  }
  setDefaultValue(e) {
    this._defaultValue = e;
  }
  get(e, t) {
    var r;
    return ((r = this._values[e]) == null ? void 0 : r[t]) || this._defaultValue;
  }
  getRealValue(e, t) {
    const r = this._values[e];
    if (r == null)
      return null;
    const n = r[t];
    return n == null ? null : n;
  }
  getValueOrDefault(e, t) {
    return this.get(e, t) || this._defaultValue;
  }
  set(e, t, r) {
    if (e >= this._rowCount || t >= this._columnCount)
      throw new Error("Exceeding array bounds.");
    this._clearCache(), this._values[e][t] = r;
  }
  getRangePosition() {
    const t = this.getRowCount(), r = 0, n = this.getColumnCount();
    return {
      startRow: 0,
      endRow: t - 1,
      startColumn: r,
      endColumn: n - 1
    };
  }
  iterator(e) {
    var u;
    const { startRow: t, endRow: r, startColumn: n, endColumn: s } = this.getRangePosition(), o = this.getArrayValue();
    for (let c = t; c <= r; c++)
      for (let l = n; l <= s; l++)
        if (e(((u = o[c]) == null ? void 0 : u[l]) || this._defaultValue, c, l) === false)
          return;
  }
  iteratorReverse(e) {
    var u;
    const { startRow: t, endRow: r, startColumn: n, endColumn: s } = this.getRangePosition(), o = this.getArrayValue();
    for (let c = r; c >= t; c--)
      for (let l = s; l >= n; l--)
        if (e(((u = o[c]) == null ? void 0 : u[l]) || this._defaultValue, c, l) === false)
          return;
  }
  getLastTruePosition() {
    let e;
    return this.iteratorReverse((t, r, n) => {
      if (t != null && t.isBoolean() && t.getValue() === true)
        return e = {
          row: r,
          column: n
        }, false;
    }), e;
  }
  getFirstTruePosition() {
    let e;
    return this.iterator((t, r, n) => {
      if (t != null && t.isBoolean() && t.getValue() === true)
        return e = {
          row: r,
          column: n
        }, false;
    }), e;
  }
  getFirstCell() {
    const { startRow: e, startColumn: t } = this.getRangePosition();
    return this.get(e, t) || this._defaultValue || ce.create();
  }
  getLastCell() {
    const { endRow: e, endColumn: t } = this.getRangePosition();
    return this.get(e, t) || this._defaultValue || ce.create();
  }
  /**
   * Referring to matrix calculations,
   * extract the matching values from a true/false matrix based on parameters and store them in a two-dimensional array.
   * implement x[x<10]
   * https://numpy.org/doc/stable/user/basics.indexing.html
   * @param takeArray
   */
  pick(e) {
    const t = this.pickRaw(e);
    return this._createNewArray(t, 1, t[0].length);
  }
  pickRaw(e) {
    const t = e.getRowCount(), r = e.getColumnCount();
    if (t !== this._rowCount || r !== this._columnCount)
      return [[ce.create()]];
    const n = [];
    n[0] = [];
    for (let s = 0; s < t; s++)
      for (let o = 0; o < r; o++) {
        const u = e.get(s, o);
        if (!(u == null || u.isError()) && u.getValue() === true) {
          const c = this.get(s, o);
          n[0].push(c);
        }
      }
    return n;
  }
  /**
   * Flatten a 2D array.
   * https://numpy.org/doc/stable/reference/generated/numpy.chararray.flatten.html#numpy.chararray.flatten
   */
  flatten() {
    if (this._flattenCache != null)
      return this._flattenCache;
    const e = [];
    e[0] = [];
    for (let r = 0; r < this._rowCount; r++)
      for (let n = 0; n < this._columnCount; n++) {
        const s = this.get(r, n);
        e[0].push(s);
      }
    const t = this._createNewArray(e, 1, e[0].length);
    return t.setDefaultValue(this._defaultValue), this._flattenCache = t, t;
  }
  /**
   * Flatten a 2D array.
   * In Excel, errors and blank cells are ignored, which results in a binary search that cannot strictly adhere to the number of cells.
   */
  flattenPosition() {
    if (this._flattenPosition != null)
      return this._flattenPosition;
    const e = [], t = [], r = [], n = [];
    let s = 0;
    for (let u = 0; u < this._rowCount; u++)
      for (let c = 0; c < this._columnCount; c++) {
        const l = this.get(u, c);
        if (l == null || l.isError() || l.isNull()) {
          s++;
          continue;
        }
        l.isString() ? (e.push(l), r.push(s++)) : (t.push(l), n.push(s++));
      }
    const o = {
      stringArray: e,
      numberArray: t,
      stringPosition: r,
      numberPosition: n
    };
    return this._flattenPosition = o, o;
  }
  /**
   * I'm looking to perform slicing operations on 2D arrays, similar to the functionality provided by NumPy.
   * https://numpy.org/doc/stable/user/basics.indexing.html
   * @rowParam start:stop:step
   * @columnParam start:stop:step
   * @param takeArray
   */
  slice(e, t) {
    let r = 0, n = this._rowCount, s = 1, o = 0, u = this._columnCount, c = 1;
    if (e != null && (r = e[0] || 0, n = e[1] || this._rowCount, s = e[2] || 1), t != null && (o = t[0] || 0, u = t[1] || this._columnCount, c = t[2] || 1), r >= this._rowCount || o >= this._columnCount)
      return;
    const l = `${r}_${n}_${s}_${o}_${u}_${c}`, f2 = this._sliceCache.get(l);
    if (f2 != null)
      return f2;
    const m2 = [], d2 = this._values;
    let _2 = 0, C = 0;
    for (let p2 = r; p2 < n; p2 += s) {
      C = 0, m2[_2] == null && (m2[_2] = []);
      for (let V = o; V < u; V += c) {
        if (!d2[p2])
          return;
        let S2 = d2[p2][V] || this._defaultValue;
        S2 == null && (S2 = ce.create()), m2[_2][C] = S2, C++;
      }
      _2++;
    }
    if (m2.length === 0 || m2[0].length === 0)
      return;
    const E = s > 1 ? -1 : r + this._currentRow, R = c > 1 ? -1 : o + this._currentColumn, b = this._createNewArray(m2, m2.length, m2[0].length, E, R);
    return b.setDefaultValue(this._defaultValue), this._sliceCache.set(l, b), b;
  }
  sortByRow(e) {
    const t = this._transposeArray(this._values);
    t.sort(this._sort(e)), this._clearCache(), this._values = this._transposeArray(t);
  }
  sortByColumn(e) {
    this._clearCache(), this._values.sort(this._sort(e));
  }
  transpose() {
    const e = this._transposeArray(this._values), t = this._rowCount, r = this._columnCount, n = this._createNewArray(e, r, t);
    return n.setDefaultValue(this._defaultValue), n;
  }
  /**
   * Due to the inability to effectively utilize the cache,
   * the sequential matching approach is only used for special matches in XLOOKUP and XMATCH.
   * For example, when match_mode is set to 1 and -1 for an exact match. If not found, it returns the next smaller item.
   */
  orderSearch(e, t = xe.MIN, r = false, n = false) {
    let s, o, u, c;
    const l = (f2, m2, d2) => {
      if (f2 == null || f2.isNull())
        return true;
      let _2;
      if (n === true ? _2 = f2.compare(e, Y2.EQUALS) : _2 = f2.isEqual(e), (_2 == null ? void 0 : _2.getValue()) === true)
        return s = f2, u = { row: m2, column: d2 }, false;
      t === xe.MAX ? f2.isGreaterThan(e).getValue() === true && (o == null || f2.minus(e).abs().isLessThanOrEqual(o.minus(e).abs()).getValue() === true) && (o = f2, c = { row: m2, column: d2 }) : t === xe.MIN && f2.isLessThan(e).getValue() === true && (o == null || f2.minus(e).abs().isLessThanOrEqual(o.minus(e).abs()).getValue() === true) && (o = f2, c = { row: m2, column: d2 });
    };
    if (r ? this.iteratorReverse((f2, m2, d2) => l(f2, m2, d2)) : this.iterator((f2, m2, d2) => l(f2, m2, d2)), s != null)
      return u;
    if (o != null)
      return c;
  }
  binarySearch(e, t = zt.MIN, r = xe.MIN) {
    if (e.isError())
      return;
    const { stringArray: n, stringPosition: s, numberArray: o, numberPosition: u } = this.flattenPosition();
    return e.isString() ? this._binarySearch(e, n, s, t, r) : this._binarySearch(e, o, u, t, r);
  }
  /**
   * searchType defaults to ascending order
   *
   * matchType defaults to the maximum value less than the search value, which is used for the default matching mode of VLOOKUP/LOOKUP/HLOOKUP.
   * @param valueObject
   * @param searchArray
   * @param positionArray
   * @param searchType
   * @param matchType
   * @returns
   */
  _binarySearch(e, t, r, n = zt.MIN, s = xe.MIN) {
    const o = Dn(), u = Number(e.getValue()), c = !Number.isNaN(u);
    let l = 0, f2 = t.length - 1, m2 = -1, d2 = -1, _2 = -1;
    for (; l <= f2; ) {
      const C = Math.floor((l + f2) / 2), E = t[C];
      let R;
      if (E.isNull())
        R = n === zt.MIN ? 1 : -1;
      else {
        const b = E.getValue();
        if (c) {
          const p2 = Number(b);
          R = Number.isNaN(p2) ? 1 : Math.sign(p2 - u);
        } else
          R = o(b.toString().toLocaleLowerCase(), e.getValue().toString().toLocaleLowerCase());
      }
      if (n === zt.MAX && (R = -R), R === 0) {
        m2 = C;
        break;
      }
      R < 0 ? (d2 = C, l = C + 1) : (_2 = C, f2 = C - 1);
    }
    if (s === xe.NORMAL)
      return m2 !== -1 ? r[m2] : void 0;
    if (s === xe.MIN)
      return m2 !== -1 ? r[m2] : n === zt.MIN ? r[d2] : r[_2];
    if (s === xe.MAX)
      return m2 !== -1 ? r[m2] : n === zt.MIN ? r[_2] : r[d2];
  }
  sum() {
    let e = y2.create(0);
    return this.iterator((t) => {
      if (t == null || t.isString() || t.isBoolean() || t.isNull())
        return true;
      if (t.isError())
        return e = t, false;
      e = e.plus(
        t
      );
    }), e;
  }
  max() {
    let e = y2.create(Number.NEGATIVE_INFINITY);
    return this.iterator((t) => {
      if (t == null)
        return true;
      if (t.isError())
        return e = t, false;
      if (t.isString() || t.isNull() || t.isBoolean())
        return true;
      e.isLessThan(t).getValue() && (e = t);
    }), e;
  }
  min() {
    let e = y2.create(Number.POSITIVE_INFINITY);
    return this.iterator((t) => {
      if (t == null)
        return true;
      if (t.isError())
        return e = t, false;
      if (t.isString() || t.isNull() || t.isBoolean())
        return true;
      e.isGreaterThan(t).getValue() && (e = t);
    }), e;
  }
  count() {
    let e = y2.create(0);
    return this.iterator((t) => {
      if (t == null || t.isError() || t.isString() || t.isNull() || t.isBoolean())
        return true;
      e = e.plusBy(1);
    }), e;
  }
  countA() {
    let e = y2.create(0);
    return this.iterator((t) => {
      if (t == null || t.isNull())
        return true;
      e = e.plusBy(1);
    }), e;
  }
  countBlank() {
    let e = y2.create(0);
    return this.iterator((t) => {
      (t == null || t.isNull() || t.getValue() === "") && (e = e.plusBy(1));
    }), e;
  }
  getNegative() {
    return _K.create("{0}").minus(this);
  }
  getReciprocal() {
    return _K.create("{1}").divided(this);
  }
  plus(e) {
    return this._batchOperator(
      e,
      1
      /* PLUS */
    );
  }
  minus(e) {
    return this._batchOperator(
      e,
      0
      /* MINUS */
    );
  }
  multiply(e) {
    return this._batchOperator(
      e,
      2
      /* MULTIPLY */
    );
  }
  divided(e) {
    return this._batchOperator(
      e,
      3
      /* DIVIDED */
    );
  }
  mod(e) {
    return this._batchOperator(
      e,
      4
      /* MOD */
    );
  }
  modInverse(e) {
    return this.map((t) => t.isError() ? t : e.mod(t));
  }
  compare(e, t, r) {
    return this._batchOperator(e, 5, t, r);
  }
  concatenateFront(e) {
    return this._batchOperator(
      e,
      6
      /* CONCATENATE_FRONT */
    );
  }
  concatenateBack(e) {
    return this._batchOperator(
      e,
      7
      /* CONCATENATE_BACK */
    );
  }
  map(e) {
    const t = (r, n, s) => r == null ? ce.create() : r.isError() ? r : e(r, n, s);
    return this.mapValue(t);
  }
  mapValue(e) {
    var s;
    const t = this._rowCount, r = this._columnCount, n = [];
    for (let o = 0; o < t; o++) {
      const u = [];
      for (let c = 0; c < r; c++) {
        const l = (s = this._values) == null ? void 0 : s[o];
        if (l == null)
          u[c] = g2.create(h.VALUE);
        else {
          const f2 = l[c] || this._defaultValue;
          f2 ? u[c] = e(f2, o, c) : u[c] = ce.create();
        }
      }
      n.push(u);
    }
    return this._createNewArray(n, t, r);
  }
  pow(e) {
    return this._batchOperator(
      e,
      8
      /* POW */
    );
  }
  /**
   *
   * @param valueObject In the case of an inverse, it is certainly not an array.
   * @returns
   */
  powInverse(e) {
    return this.map((t) => t.isError() ? t : e.pow(t));
  }
  sqrt() {
    return this.map((e) => e.isError() ? e : e.sqrt());
  }
  cbrt() {
    return this.map((e) => e.isError() ? e : e.cbrt());
  }
  cos() {
    return this.map((e) => e.isError() ? e : e.cos());
  }
  cosh() {
    return this.map((e) => e.isError() ? e : e.cosh());
  }
  acos() {
    return this.map((e) => e.isError() ? e : e.acos());
  }
  acosh() {
    return this.map((e) => e.isError() ? e : e.acosh());
  }
  sin() {
    return this.map((e) => e.isError() ? e : e.sin());
  }
  sinh() {
    return this.map((e) => e.isError() ? e : e.sinh());
  }
  asin() {
    return this.map((e) => e.isError() ? e : e.asin());
  }
  asinh() {
    return this.map((e) => e.isError() ? e : e.asinh());
  }
  tan() {
    return this.map((e) => e.isError() ? e : e.tan());
  }
  tanh() {
    return this.map((e) => e.isError() ? e : e.tanh());
  }
  atan() {
    return this.map((e) => e.isError() ? e : e.atan());
  }
  atanh() {
    return this.map((e) => e.isError() ? e : e.atanh());
  }
  atan2(e) {
    return this._batchOperator(
      e,
      12
      /* ATAN2 */
    );
  }
  atan2Inverse(e) {
    return this.map((t) => t.isError() ? t : e.atan2(t));
  }
  mean(e = 0) {
    const t = this.sum(), r = this.count();
    return t.divided(e === 0 ? r : r.minusBy(1));
  }
  /**
   * TODO: @DR-Univer
   * This calculation method contains an error, please note.
   * Please refer `getMedianResult` function in /engine-formula/src/basics/statistical.ts
   */
  median() {
    const e = this.flattenPosition().numberArray, t = this._createNewArray([e], 1, e.length), r = t.getColumnCount();
    if (r <= 1)
      return t.get(0, 0) || ce.create();
    if (t.sortByRow(0), r % 2 === 0) {
      const n = t.get(0, r / 2) || ce.create(), s = t.get(0, r / 2 - 1) || ce.create();
      return n.plus(s).divided(y2.create(2));
    }
    return t.get(0, (r - 1) / 2) || ce.create();
  }
  /**
   * ┌──────────────┬────────────────────────────────┬───────────────────┐
   * │ Function     │ Ignore logical values and text │ Type              │
   * ├──────────────┼────────────────────────────────┼───────────────────┤
   * │ VAR.S (VAR)  │ TRUE                           │ sample            │
   * │ VAR.P (VARP) │ TRUE                           │ entire population │
   * │ VARA         │ FALSE                          │ sample            │
   * │ VARPA        │ FALSE                          │ entire population │
   * └──────────────┴────────────────────────────────┴───────────────────┘
   *
   * for VARPA and VARA, strings and FALSE are counted as 0, TRUE is counted as 1
   * for VAR.S/VAR, or VAR.P/VARP, strings,TRUE and FALSE are ignored
   * Since sum ignores strings and booleans, they are ignored here too, and VAR.S and VAR.P are used more
   *
   * VAR.S assumes that its arguments are a sample of the population, like numpy.var(data, ddof=1)
   * VAR.P assumes that its arguments are the entire population, like numpy.var(data, ddof=0)
   * numpy.var uses ddof=0 (Delta Degrees of Freedom) by default, so we use ddof=0 here
   *
   */
  var(e = 0) {
    const t = this.mean(), r = [[]];
    this.iterator((l) => {
      if (l == null || l.isError() || l.isString() || l.isBoolean() || l.isNull())
        return;
      const f2 = l.minus(t).pow(y2.create(2));
      f2.isError() || r[0].push(f2);
    });
    const { _unitId: n, _sheetId: s, _currentRow: o, _currentColumn: u } = this;
    return _K.create({
      calculateValueList: r,
      rowCount: 1,
      columnCount: r[0].length,
      unitId: n,
      sheetId: s,
      row: o,
      column: u
    }).mean(e);
  }
  /**
   * STDEV.P (STDEVP): ddof=0, ignore strings and booleans
   * STDEV.S (STDEV): ddof=1, ignore strings and booleans
   *
   * STDEVPA: ddof=0,
   * STDEVA: ddof=1,
   * @returns
   */
  std(e = 0) {
    const t = this.var(e);
    return t.isError() ? t : t.sqrt();
  }
  log() {
    return this.map((e) => e.isError() ? e : e.log());
  }
  log10() {
    return this.map((e) => e.isError() ? e : e.log10());
  }
  exp() {
    return this.map((e) => e.isError() ? e : e.exp());
  }
  abs() {
    return this.map((e) => e.isError() ? e : e.abs());
  }
  round(e) {
    return this._batchOperator(
      e,
      9
      /* ROUND */
    );
  }
  roundInverse(e) {
    return this.map((t) => t.isError() ? t : e.round(t));
  }
  floor(e) {
    return this._batchOperator(
      e,
      10
      /* FLOOR */
    );
  }
  floorInverse(e) {
    return this.map((t) => t.isError() ? t : e.floor(t));
  }
  ceil(e) {
    return this._batchOperator(
      e,
      11
      /* CEIL */
    );
  }
  ceilInverse(e) {
    return this.map((t) => t.isError() ? t : e.ceil(t));
  }
  toValue() {
    return ym(this._values);
  }
  _clearCache() {
    this._flattenCache = null, this._sliceCache.clear();
  }
  _sort(e) {
    const t = Dn();
    return (r, n) => {
      const s = r[e], o = n[e];
      return s == null ? 1 : o == null ? -1 : s.isError() && s.isError() ? 0 : s.isError() ? 1 : o.isError() ? -1 : t(
        s.getValue(),
        o.getValue()
      );
    };
  }
  _transposeArray(e) {
    const t = e.length, r = e[0].length, n = [];
    for (let s = 0; s < r; s++) {
      n[s] = [];
      for (let o = 0; o < t; o++)
        n[s][o] = e[o][s];
    }
    return n;
  }
  _batchOperator(e, t, r, n) {
    const s = [];
    let o = this._rowCount, u = this._columnCount;
    if (e.isArray()) {
      const f2 = e.getRowCount(), m2 = e.getColumnCount();
      if (o = Math.max(f2, o), u = Math.max(m2, u), f2 === 1 && m2 === 1) {
        const d2 = e.getFirstCell();
        for (let _2 = 0; _2 < u; _2++)
          s.push(d2);
      } else if (f2 === 1 && this._columnCount > 1) {
        const d2 = e.getArrayValue();
        for (let _2 = 0; _2 < u; _2++)
          d2[0] && d2[0][_2] ? s.push(d2[0][_2]) : s.push(ce.create());
      } else
        return this._batchOperatorArray(e, t, r, n);
    } else
      for (let f2 = 0; f2 < u; f2++)
        s.push(e);
    const c = [];
    for (let f2 = 0; f2 < u; f2++) {
      const m2 = s[f2];
      this._batchOperatorValue(
        m2,
        f2,
        c,
        t,
        r,
        n
      );
    }
    const l = this._createNewArray(c, o, u);
    return l.setDefaultValue(T.create(false)), l;
  }
  // eslint-disable-next-line max-lines-per-function
  _batchOperatorValue(e, t, r, n, s, o) {
    const u = this._rowCount, c = this.getUnitId(), l = this.getSheetId(), f2 = this.getCurrentRow(), m2 = this.getCurrentColumn();
    if (n === 5) {
      const { rowsInCache: d2, rowsNotInCache: _2 } = Ke.canUseCache(
        c,
        l,
        t + m2,
        f2,
        f2 + u - 1
      );
      if (d2.length > 0) {
        if (s === Y2.EQUALS && !(e.isString() && vo(e.getValue()))) {
          const C = Ke.getCellPositions(
            c,
            l,
            t + m2,
            e.isNull() ? null : e.getValue(),
            d2
          );
          C != null && C.forEach((E) => {
            if (E < f2 || E > f2 + u - 1)
              return;
            const R = E - f2;
            r[R] == null && (r[R] = []), r[R][t] = T.create(true);
          });
        } else {
          const C = Ke.getCellValuePositions(
            c,
            l,
            t + m2
          );
          C != null && C.forEach((E, R) => {
            let b = ce.create();
            fr.has(R) ? b = g2.create(R) : typeof R == "string" ? b = U2.create(R) : typeof R == "number" ? b = y2.create(R) : typeof R == "boolean" && (b = T.create(R));
            let p2;
            b.isError() ? p2 = b : e.isError() ? p2 = e : p2 = b.compare(e, s, o), E.forEach((V) => {
              V >= f2 && V <= f2 + u - 1 && (r[V - f2] == null && (r[V - f2] = []), r[V - f2][t] = p2);
            });
          });
        }
        if (_2.length > 0)
          for (const C of _2) {
            const [E, R] = C;
            for (let b = E; b <= R; b++)
              this.__batchOperatorRowValue(
                e,
                t,
                r,
                n,
                b - f2,
                c,
                l,
                f2,
                m2,
                s,
                o
              );
            Ke.setContinueBuildingCache(
              c,
              l,
              t + m2,
              E,
              R
            );
          }
        return;
      }
    }
    for (let d2 = 0; d2 < u; d2++)
      this.__batchOperatorRowValue(
        e,
        t,
        r,
        n,
        d2,
        c,
        l,
        f2,
        m2,
        s,
        o
      );
    Ke.setContinueBuildingCache(
      c,
      l,
      t + m2,
      f2,
      f2 + u - 1
    );
  }
  // eslint-disable-next-line
  __batchOperatorRowValue(e, t, r, n, s, o, u, c, l, f2, m2) {
    const d2 = this.getValueOrDefault(s, t);
    if (r[s] == null && (r[s] = []), d2 && e)
      if (d2.isError())
        r[s][t] = d2;
      else if (e.isError())
        r[s][t] = e;
      else
        switch (n) {
          case 1:
            r[s][t] = d2.plus(e);
            break;
          case 0:
            r[s][t] = d2.minus(e);
            break;
          case 2:
            r[s][t] = d2.multiply(e);
            break;
          case 3:
            r[s][t] = d2.divided(e);
            break;
          case 4:
            r[s][t] = d2.mod(e);
            break;
          case 5:
            f2 ? r[s][t] = d2.compare(e, f2, m2) : r[s][t] = g2.create(h.VALUE);
            break;
          case 6:
            r[s][t] = d2.concatenateFront(e);
            break;
          case 7:
            r[s][t] = d2.concatenateBack(e);
            break;
          case 8:
            r[s][t] = d2.pow(e);
            break;
          case 9:
            r[s][t] = d2.round(e);
            break;
          case 10:
            r[s][t] = d2.floor(e);
            break;
          case 12:
            r[s][t] = d2.atan2(e);
            break;
          case 11:
            r[s][t] = d2.ceil(e);
            break;
        }
    else
      r[s][t] = g2.create(h.NA);
    !d2 || d2 != null && d2.isNull() ? Ke.set(
      o,
      u,
      t + l,
      Ys,
      s + c
    ) : Ke.set(
      o,
      u,
      t + l,
      d2.getValue(),
      s + c
    );
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _batchOperatorArray(e, t, r, n) {
    let s = e.getRowCount(), o = e.getColumnCount();
    s < this._rowCount && (s = this._rowCount), o < this._columnCount && (o = this._columnCount);
    const u = [], c = this._checkArrayCalculateType(this), l = this._checkArrayCalculateType(e);
    for (let f2 = 0; f2 < s; f2++) {
      const m2 = [];
      for (let d2 = 0; d2 < o; d2++) {
        let _2;
        c === 3 ? _2 = this.getValueOrDefault(0, 0) : c === 1 ? _2 = this.getValueOrDefault(0, d2) : c === 2 ? _2 = this.getValueOrDefault(f2, 0) : _2 = this.getValueOrDefault(f2, d2);
        let C;
        if (l === 3 ? C = e.getValueOrDefault(0, 0) : l === 1 ? C = e.getValueOrDefault(0, d2) : l === 2 ? C = e.getValueOrDefault(f2, 0) : C = e.getValueOrDefault(f2, d2), _2 && C)
          if (_2.isError())
            m2[d2] = _2;
          else if (C.isError())
            m2[d2] = C;
          else
            switch (t) {
              case 1:
                m2[d2] = _2.plus(C);
                break;
              case 0:
                m2[d2] = _2.minus(C);
                break;
              case 2:
                m2[d2] = _2.multiply(C);
                break;
              case 3:
                m2[d2] = _2.divided(C);
                break;
              case 4:
                m2[d2] = _2.mod(C);
                break;
              case 5:
                r ? m2[d2] = _2.compare(C, r, n) : m2[d2] = g2.create(h.VALUE);
                break;
              case 6:
                m2[d2] = _2.concatenateFront(C);
                break;
              case 7:
                m2[d2] = _2.concatenateBack(C);
                break;
              case 8:
                m2[d2] = _2.pow(C);
                break;
              case 9:
                m2[d2] = _2.round(C);
                break;
              case 12:
                m2[d2] = _2.atan2(C);
                break;
              case 10:
                m2[d2] = _2.floor(C);
                break;
              case 11:
                m2[d2] = _2.ceil(C);
                break;
            }
        else
          m2[d2] = g2.create(h.NA);
      }
      u.push(m2);
    }
    return this._createNewArray(u, s, o);
  }
  _checkArrayCalculateType(e) {
    return e.getRowCount() === 1 && e.getColumnCount() === 1 ? 3 : e.getRowCount() === 1 ? 1 : e.getColumnCount() === 1 ? 2 : 0;
  }
  _formatValue(e) {
    if (typeof e != "string")
      return e = e, this._rowCount = e.rowCount, this._columnCount = e.columnCount, this._unitId = e.unitId, this._sheetId = e.sheetId, this._currentRow = e.row, this._currentColumn = e.column, e.calculateValueList;
    e = e.slice(1, -1);
    const t = e.split(";"), r = t.length, n = [];
    let s = 0;
    for (let o = 0; o < r; o++) {
      const c = t[o].split(","), l = c.length;
      s < l && (s = l);
      const f2 = [];
      for (let m2 = 0; m2 < l; m2++) {
        const d2 = c[m2].trim();
        f2.push(Pt.create(d2));
      }
      n.push(f2);
    }
    return this._rowCount = r, this._columnCount = s, n;
  }
  _createNewArray(e, t, r, n = -1, s = -1) {
    (this._currentColumn === -1 || this._currentRow === -1) && (n = -1, s = -1);
    const o = {
      calculateValueList: e,
      rowCount: t,
      columnCount: r,
      unitId: this.getUnitId(),
      sheetId: this.getSheetId(),
      row: n,
      column: s
    };
    return _K.create(o);
  }
};
var Pt = class {
  static create(i, e = false) {
    if (i == null)
      return ce.create();
    if (typeof i == "boolean")
      return T.create(i);
    if (typeof i == "string") {
      const t = i.toLocaleUpperCase().trim();
      if (fr.has(t))
        return g2.create(t);
      if (t === ir.TRUE || t === ir.FALSE)
        return is(i);
      if (s1(i))
        return y2.create(Number(i));
      if (!e) {
        const { isNumberPattern: n, value: s, pattern: o } = mf(i);
        if (n)
          return y2.create(s, o);
      }
      const r = i.replace(/\n/g, "").replace(/\r/g, "");
      return !pm(r) && bl(r) ? K2.create(r) : Rm(i);
    }
    return typeof i == "number" ? Yr(i) : g2.create(h.VALUE);
  }
};
function pm(a2) {
  const i = a2.trim();
  return i.startsWith('"') && i.endsWith('"');
}
var Nm = 1e4;
var _r = new xt(Nm);
var jr = class extends ts {
  constructor(e) {
    super();
    A(this, "_forcedSheetId", "");
    A(this, "_forcedSheetName", "");
    A(this, "_defaultSheetId", "");
    A(this, "_rangeData", {
      startColumn: -1,
      startRow: -1,
      endRow: -1,
      endColumn: -1
    });
    A(this, "_unitData", {});
    A(this, "_unitStylesData", {});
    A(this, "_filteredOutRows", []);
    A(this, "_defaultUnitId", "");
    A(this, "_forcedUnitId", "");
    A(this, "_runtimeData", {});
    A(this, "_arrayFormulaCellData", {});
    A(this, "_runtimeArrayFormulaCellData", {});
    A(this, "_runtimeFeatureCellData", {});
    A(this, "_refOffsetX", 0);
    A(this, "_refOffsetY", 0);
    A(this, "_currentRow");
    A(this, "_currentColumn");
    this._token = e;
  }
  dispose() {
    this._unitData = {}, this._unitStylesData = {}, this._runtimeData = {};
  }
  getToken() {
    return this._token;
  }
  setToken(e) {
    this._token = e;
  }
  isExceedRange() {
    const { startRow: e, endRow: t, startColumn: r, endColumn: n } = this.getRangePosition();
    return e < 0 || r < 0 || t >= this.getActiveSheetRowCount() || n >= this.getActiveSheetColumnCount();
  }
  setRefOffset(e = 0, t = 0) {
    this._refOffsetX = e, this._refOffsetY = t;
  }
  getRefOffset() {
    return {
      x: this._refOffsetX,
      y: this._refOffsetY
    };
  }
  getRangePosition() {
    const { x: e, y: t } = this.getRefOffset(), r = this.getRangeData();
    let { startRow: n, startColumn: s, endRow: o, endColumn: u } = w1(r, e, t);
    return Number.isNaN(n) && (n = 0), Number.isNaN(s) && (s = 0), Number.isNaN(o) && (o = this.getActiveSheetRowCount() - 1), Number.isNaN(u) && (u = this.getActiveSheetColumnCount() - 1), {
      startRow: n,
      endRow: o,
      startColumn: s,
      endColumn: u
    };
  }
  isReferenceObject() {
    return true;
  }
  iterator(e) {
    const { startRow: t, endRow: r, startColumn: n, endColumn: s } = this.getRangePosition();
    if (this._checkIfWorksheetMiss())
      return e(g2.create(h.VALUE), t, n);
    const o = this._forcedUnitId || this._defaultUnitId, u = this._forcedSheetId || this._defaultSheetId;
    for (let c = t; c <= r; c++)
      for (let l = n; l <= s; l++) {
        if (c < 0 || l < 0)
          return e(g2.create(h.REF), c, l);
        const f2 = this.getCellData(c, l);
        let m2 = false;
        if (En(f2)) {
          m2 = e(null, c, l);
          continue;
        }
        let d2 = this.getCellValueObject(f2);
        if (c === t && l === n) {
          const _2 = this.getCellPattern(o, u, c, l);
          if (_2 && d2.isNumber()) {
            const C = Number(d2.getValue());
            d2 = y2.create(C, _2);
          }
        }
        if (m2 = e(d2, c, l), m2 === false)
          return;
      }
  }
  getFirstCell() {
    if (this._checkIfWorksheetMiss())
      return g2.create(h.VALUE);
    const { startRow: e, startColumn: t } = this.getRangePosition(), r = this.getCellData(e, t);
    if (!r)
      return y2.create(0);
    let n = this.getCellValueObject(r);
    const s = this._forcedUnitId || this._defaultUnitId, o = this._forcedSheetId || this._defaultSheetId, u = this.getCellPattern(s, o, e, t);
    if (u && n.isNumber()) {
      const c = Number(n.getValue());
      n = y2.create(c, u);
    }
    return n;
  }
  getRangeData() {
    return this._rangeData;
  }
  setRangeData(e) {
    this._rangeData = e;
  }
  getUnitId() {
    return this._forcedUnitId && this._forcedUnitId.length > 0 ? this._forcedUnitId : this._defaultUnitId;
  }
  getSheetId() {
    return this._forcedSheetId && this._forcedSheetId.length > 0 ? this._forcedSheetId : this._defaultSheetId;
  }
  setForcedUnitIdDirect(e) {
    e.length > 0 && (this._forcedUnitId = e);
  }
  getForcedUnitId() {
    return this._forcedUnitId;
  }
  setForcedSheetId(e) {
    var t;
    this._forcedSheetId = (t = e[this.getUnitId()]) == null ? void 0 : t[this._forcedSheetName];
  }
  setForcedSheetIdDirect(e) {
    this._forcedSheetId = e;
  }
  getForcedSheetId() {
    return this._forcedSheetId;
  }
  setForcedSheetName(e) {
    e.length > 0 && (this._forcedSheetName = e);
  }
  getForcedSheetName() {
    return this._forcedSheetName;
  }
  setDefaultSheetId(e) {
    this._defaultSheetId = e;
  }
  getDefaultSheetId() {
    return this._defaultSheetId;
  }
  setDefaultUnitId(e) {
    this._defaultUnitId = e;
  }
  getDefaultUnitId() {
    return this._defaultUnitId;
  }
  getUnitData() {
    return this._unitData;
  }
  setUnitData(e) {
    this._unitData = e;
  }
  getUnitStylesData() {
    return this._unitStylesData;
  }
  setUnitStylesData(e) {
    this._unitStylesData = e;
  }
  getFilteredOutRows() {
    return this._filteredOutRows;
  }
  setFilteredOutRows(e) {
    this._filteredOutRows = e;
  }
  getRuntimeData() {
    return this._runtimeData;
  }
  setRuntimeData(e) {
    this._runtimeData = e;
  }
  getArrayFormulaCellData() {
    return this._arrayFormulaCellData;
  }
  setArrayFormulaCellData(e) {
    this._arrayFormulaCellData = e;
  }
  getRuntimeArrayFormulaCellData() {
    return this._runtimeArrayFormulaCellData;
  }
  setRuntimeArrayFormulaCellData(e) {
    this._runtimeArrayFormulaCellData = e;
  }
  getRuntimeFeatureCellData() {
    return this._runtimeFeatureCellData;
  }
  setRuntimeFeatureCellData(e) {
    this._runtimeFeatureCellData = e;
  }
  getActiveSheetRowCount() {
    var e;
    return ((e = this.getCurrentActiveSheetData()) == null ? void 0 : e.rowCount) || 0;
  }
  getActiveSheetColumnCount() {
    var e;
    return ((e = this.getCurrentActiveSheetData()) == null ? void 0 : e.columnCount) || 0;
  }
  getRowCount() {
    const e = this.getRangeData();
    return e.endRow - e.startRow + 1;
  }
  getColumnCount() {
    const e = this.getRangeData();
    return e.endColumn - e.startColumn + 1;
  }
  getRowData() {
    var e;
    return ((e = this.getCurrentActiveSheetData()) == null ? void 0 : e.rowData) || {};
  }
  getColumnData() {
    var e;
    return ((e = this.getCurrentActiveSheetData()) == null ? void 0 : e.columnData) || {};
  }
  isCell() {
    return false;
  }
  isColumn() {
    return false;
  }
  isRow() {
    return false;
  }
  isRange() {
    return false;
  }
  isTable() {
    return false;
  }
  isCurrentRowForRange() {
    return false;
  }
  isCurrentColumnForRange() {
    return false;
  }
  isMultiArea() {
    return false;
  }
  unionBy(e) {
    return g2.create(h.REF);
  }
  unionRange(e, t) {
    return {
      startRow: -1,
      startColumn: -1,
      endRow: -1,
      endColumn: -1
    };
  }
  getCellValueObject(e) {
    const t = tf(e);
    if (fr.has(t))
      return g2.create(t);
    if (e.t === mn.NUMBER) {
      const r = this._getPatternByCell(e);
      return l1(r) ? U2.create(t.toString()) : Yr(t, r);
    }
    return e.t === mn.STRING || e.t === mn.FORCE_STRING ? U2.create(t.toString()) : e.t === mn.BOOLEAN ? is(t) : Pt.create(t);
  }
  _getPatternByCell(e) {
    var n;
    const t = this._unitStylesData[this.getUnitId()];
    if (!t) return "";
    const r = t.getStyleByCell(e);
    return ((n = r == null ? void 0 : r.n) == null ? void 0 : n.pattern) || "";
  }
  getCellByRow(e) {
    return this.getCellByPosition(e);
  }
  getCellByColumn(e) {
    return this.getCellByPosition(void 0, e);
  }
  getCurrentActiveSheetData() {
    var e;
    return (e = this._unitData[this.getUnitId()]) == null ? void 0 : e[this.getSheetId()];
  }
  getCurrentStylesData() {
    return this._unitStylesData[this.getUnitId()];
  }
  getCurrentRuntimeSheetData() {
    var e, t;
    return (t = (e = this._runtimeData) == null ? void 0 : e[this.getUnitId()]) == null ? void 0 : t[this.getSheetId()];
  }
  getCurrentActiveArrayFormulaCellData() {
    var e, t;
    return (t = (e = this._arrayFormulaCellData) == null ? void 0 : e[this.getUnitId()]) == null ? void 0 : t[this.getSheetId()];
  }
  getCurrentRuntimeActiveArrayFormulaCellData() {
    var e, t;
    return (t = (e = this._runtimeArrayFormulaCellData) == null ? void 0 : e[this.getUnitId()]) == null ? void 0 : t[this.getSheetId()];
  }
  getCellData(e, t) {
    const r = this.getCurrentActiveSheetData(), n = this.getCurrentRuntimeSheetData(), s = this.getCurrentActiveArrayFormulaCellData(), o = this.getCurrentRuntimeActiveArrayFormulaCellData();
    return (n == null ? void 0 : n.getValue(e, t)) || (o == null ? void 0 : o.getValue(e, t)) || this.getRuntimeFeatureCellValue(e, t) || (s == null ? void 0 : s.getValue(e, t)) || (r == null ? void 0 : r.cellData.getValue(e, t));
  }
  getRuntimeFeatureCellValue(e, t) {
    return Uo(e, t, this.getSheetId(), this.getUnitId(), this._runtimeFeatureCellData);
  }
  getCellByPosition(e, t) {
    let r = e, n = t;
    const s = this.getRangeData();
    r || (r = s.startRow), n || (n = s.startColumn);
    const o = this.getCellData(r, n);
    return o ? this.getCellValueObject(o) : g2.create(h.VALUE);
  }
  setCurrentRowAndColumn(e, t) {
    this._currentRow = e, this._currentColumn = t;
  }
  getCurrentRow() {
    return this._currentRow;
  }
  getCurrentColumn() {
    return this._currentColumn;
  }
  /**
   * Get the pattern of the cell
   * @param unitId
   * @param sheetId
   * @param row
   * @param column
   * @returns
   */
  getCellPattern(e, t, r, n) {
    var c, l, f2, m2;
    const s = this._unitStylesData[e];
    if (!s)
      return "";
    const o = (f2 = (l = (c = this._unitData[e]) == null ? void 0 : c[t]) == null ? void 0 : l.cellData) == null ? void 0 : f2.getValue(r, n);
    if (!o)
      return "";
    const u = s.getStyleByCell(o);
    return ((m2 = u == null ? void 0 : u.n) == null ? void 0 : m2.pattern) || "";
  }
  toArrayValueObject(e = true) {
    var _2;
    const { startRow: t, endRow: r, startColumn: n, endColumn: s } = this.getRangePosition(), o = `${this.getUnitId()}_${this.getSheetId()}_${t}_${r}_${n}_${s}`, u = _r.get(o);
    if (u && e)
      return u;
    const c = r - t + 1, l = s - n + 1;
    if (c < 0 || l < 0)
      return this._getBlankArrayValueObject();
    const f2 = new Array(c);
    this.iterator((C, E, R) => {
      const b = E - t, p2 = R - n;
      f2[b] || (f2[b] = new Array(l)), C == null && (C = ce.create()), f2[b][p2] = C;
    });
    const m2 = {
      calculateValueList: f2,
      rowCount: f2.length,
      columnCount: ((_2 = f2[0]) == null ? void 0 : _2.length) || 0,
      unitId: this.getUnitId(),
      sheetId: this.getSheetId(),
      row: t,
      column: n
    }, d2 = K2.create(m2);
    return e && _r.set(o, d2), d2;
  }
  toUnitRange() {
    return {
      range: this.getRangePosition(),
      sheetId: this.getSheetId(),
      unitId: this.getUnitId()
    };
  }
  _checkIfWorksheetMiss() {
    return (this._forcedSheetId == null || this._forcedSheetId.length === 0) && this._forcedSheetName.length > 0;
  }
  _getBlankArrayValueObject() {
    const e = {
      calculateValueList: [],
      rowCount: 0,
      columnCount: 0,
      unitId: this.getUnitId(),
      sheetId: this.getSheetId(),
      row: 0,
      column: 0
    };
    return K2.create(e);
  }
};
var Vm = class extends ts {
  constructor(i) {
    super(), this._promise = i;
  }
  isAsyncObject() {
    return true;
  }
  getValue() {
    return __async(this, null, function* () {
      return this._promise;
    });
  }
};
var Om = class extends ts {
  constructor(i) {
    super(), this._promiseList = i;
  }
  isAsyncArrayObject() {
    return true;
  }
  getValue() {
    return __async(this, null, function* () {
      var t;
      const i = [];
      for (let r = 0; r < this._promiseList.length; r++) {
        const n = this._promiseList[r];
        i[r] == null && (i[r] = []);
        for (let s = 0; s < n.length; s++) {
          const o = n[s];
          o.isAsyncObject() ? i[r][s] = yield o.getValue() : i[r][s] = o;
        }
      }
      const e = {
        calculateValueList: i,
        rowCount: i.length,
        columnCount: ((t = i[0]) == null ? void 0 : t.length) || 0,
        unitId: "",
        sheetId: "",
        row: 0,
        column: 0
      };
      return K2.create(e);
    });
  }
};
var xn = class extends jr {
  constructor(i, e, t) {
    super(""), this.setRangeData(i), e && this.setForcedSheetIdDirect(e), t && this.setForcedUnitIdDirect(t);
  }
  isRange() {
    return true;
  }
};
var Ma = class extends jr {
  constructor(i) {
    super(i);
    const e = br2(i);
    this.setForcedUnitIdDirect(e.unitId), this.setForcedSheetName(e.sheetName), this.setRangeData(e.range);
  }
  isCell() {
    return true;
  }
  unionBy(i) {
    if (!i.isCell())
      return g2.create(h.REF);
    const e = i, t = this.unionRange(this.getRangeData(), e.getRangeData());
    return this._createRange(t);
  }
  unionRange(i, e) {
    const t = i.startRow, r = i.startColumn, n = e.startRow, s = e.startColumn, o = {
      startRow: -1,
      startColumn: -1,
      endRow: -1,
      endColumn: -1
    };
    return t > n ? (o.startRow = n, o.endRow = t) : (o.startRow = t, o.endRow = n), r > s ? (o.startColumn = s, o.endColumn = r) : (o.startColumn = r, o.endColumn = s), i.startAbsoluteRefType && (o.startAbsoluteRefType = i.startAbsoluteRefType), e.startAbsoluteRefType && (o.endAbsoluteRefType = e.startAbsoluteRefType), o;
  }
  _createRange(i) {
    const e = new xn(
      i,
      this.getForcedSheetId(),
      this.getForcedUnitId()
    );
    e.setUnitData(this.getUnitData()), e.setDefaultSheetId(this.getDefaultSheetId()), e.setDefaultUnitId(this.getDefaultUnitId()), e.setRuntimeData(this.getRuntimeData()), e.setUnitStylesData(this.getUnitStylesData()), e.setArrayFormulaCellData(this.getArrayFormulaCellData()), e.setRuntimeArrayFormulaCellData(this.getRuntimeArrayFormulaCellData()), e.setRuntimeFeatureCellData(this.getRuntimeFeatureCellData());
    const { x: t, y: r } = this.getRefOffset();
    e.setRefOffset(t, r);
    const n = this.getForcedSheetId();
    e.setForcedSheetName(this.getForcedSheetName()), n != null && e.setForcedSheetIdDirect(n);
    const s = this.getForcedUnitId();
    return s && e.setForcedUnitIdDirect(s), e;
  }
};
var Da = class extends jr {
  constructor(i) {
    super(i);
    const e = br2(i);
    this.setForcedUnitIdDirect(e.unitId), this.setForcedSheetName(e.sheetName);
    const t = __spreadProps(__spreadValues({}, e.range), {
      startColumn: e.range.startColumn,
      startRow: Number.NaN,
      endColumn: e.range.endColumn,
      endRow: Number.NaN,
      rangeType: ge.COLUMN
    });
    this.setRangeData(t);
  }
  isColumn() {
    return true;
  }
  unionBy(i) {
    if (!i.isColumn())
      return g2.create(h.REF);
    const e = i;
    if (e.getForcedSheetName() !== void 0 && e.getForcedSheetName() !== "")
      return g2.create(h.REF);
    const t = this.getRangeData(), r = e.getRangeData(), n = r.startColumn;
    if (n >= t.startColumn && n <= t.endColumn)
      return this;
    const s = t.startColumn;
    return n > s ? t.endColumn = n : (t.startColumn = n, t.endColumn = s), r.startAbsoluteRefType && (t.endAbsoluteRefType = r.startAbsoluteRefType), t.rangeType = ge.COLUMN, this.setToken(`${this.getToken()}${X2.COLON}${e.getToken()}`), this;
  }
};
var wa = class extends jr {
  constructor(i) {
    super(i);
    const e = br2(i);
    this.setForcedUnitIdDirect(e.unitId), this.setForcedSheetName(e.sheetName);
    const t = __spreadProps(__spreadValues({}, e.range), {
      startColumn: Number.NaN,
      startRow: e.range.startRow,
      endColumn: Number.NaN,
      endRow: e.range.endRow,
      rangeType: ge.ROW
    });
    this.setRangeData(t);
  }
  isRow() {
    return true;
  }
  unionBy(i) {
    if (!i.isRow())
      return g2.create(h.REF);
    const e = i;
    if (e.getForcedSheetName() !== void 0 && e.getForcedSheetName() !== "")
      return g2.create(h.REF);
    const t = this.getRangeData(), r = e.getRangeData(), n = r.startRow;
    if (n >= t.startRow && n <= t.endRow)
      return this;
    const s = t.startRow;
    return n > s ? t.endRow = n : (t.startRow = n, t.endRow = s), r.startAbsoluteRefType && (t.endAbsoluteRefType = r.startAbsoluteRefType), t.rangeType = ge.ROW, this.setToken(`${this.getToken()}${X2.COLON}${e.getToken()}`), this;
  }
};
function O(a2, i, e, t) {
  const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = [];
  for (let o = 0; o < a2; o++) {
    const u = [];
    for (let c = 0; c < i; c++) {
      if (r === 1 && n === 1) {
        const f2 = e.isArray() ? e.get(0, 0) : e;
        u.push(f2);
        continue;
      }
      if (r === 1 && c < n) {
        const f2 = e.get(0, c);
        u.push(f2);
        continue;
      }
      if (n === 1 && o < r) {
        const f2 = e.get(o, 0);
        u.push(f2);
        continue;
      }
      if (o >= r || c >= n) {
        u.push(t != null ? t : ce.create());
        continue;
      }
      const l = e.get(o, c);
      u.push(l);
    }
    s.push(u);
  }
  return mt(s, a2, i);
}
function mt(a2, i, e, t = "", r = "") {
  const n = {
    calculateValueList: a2,
    rowCount: i,
    columnCount: e,
    unitId: t,
    sheetId: r,
    row: -1,
    column: -1
  };
  return K2.create(n);
}
function La(a2) {
  const i = [
    Y2.EQUALS,
    Y2.NOT_EQUAL,
    Y2.GREATER_THAN_OR_EQUAL,
    Y2.GREATER_THAN,
    Y2.LESS_THAN_OR_EQUAL,
    Y2.LESS_THAN
  ];
  for (const e of i)
    if (a2.startsWith(e)) {
      const t = a2.substring(e.length);
      return [e, Pt.create(t)];
    }
  return [Y2.EQUALS, Pt.create(a2)];
}
function os(a2, i, e, t) {
  if (!e)
    if (i.isString()) {
      const r = `${i.getValue()}`, [n, s] = La(r);
      e = n, i = s;
    } else
      e = Y2.EQUALS;
  return a2.compare(i, e, t);
}
function Sm(a2, i) {
  const e = Math.max(a2.isArray() ? a2.getRowCount() : 1, i.isArray() ? i.getRowCount() : 1), t = Math.max(a2.isArray() ? a2.getColumnCount() : 1, i.isArray() ? i.getColumnCount() : 1), r = O(e, t, a2), n = O(e, t, i);
  return r.mapValue((s, o, u) => {
    const c = n.get(o, u);
    return s != null && s.isError() ? s : c != null && c.isError() ? c : s != null && s.isBoolean() && (c != null && c.isBoolean()) ? is(s.getValue() && c.getValue()) : T.create(false);
  });
}
function Mm(a2) {
  const i = a2.getValue();
  let e = 0;
  return i && (e = 1), y2.create(e);
}
function Ui(a2) {
  return a2.isArray() && a2.getRowCount() === 1 && a2.getColumnCount() === 1 ? true : a2.isReferenceObject() ? !!(a2.isCell() || a2.getRowCount() === 1 && a2.getColumnCount() === 1) : (a2 = a2, !!(a2.isString() || a2.isNumber() || a2.isBoolean() || a2.isError() || a2.isNull()));
}
function Dm(a2) {
  const i = a2 == null ? void 0 : a2.getPattern();
  let e = {}, t = {};
  if (i && (e = {
    s: {
      n: {
        pattern: i
      }
    }
  }), a2 != null && a2.getCustomData() && (t = {
    custom: a2.getCustomData()
  }), a2 == null)
    return __spreadValues({
      v: null
    }, e);
  if (a2.isError())
    return __spreadValues(__spreadValues({
      v: a2.getErrorType(),
      t: mn.STRING
    }, e), t);
  if (a2.isValueObject()) {
    const r = a2, n = r.getValue();
    return r.isNumber() ? __spreadValues(__spreadValues({
      v: n,
      t: mn.NUMBER
    }, e), t) : r.isBoolean() ? __spreadValues(__spreadValues({
      v: n ? 1 : 0,
      t: mn.BOOLEAN
    }, e), t) : r.isString() ? __spreadValues(__spreadValues({
      v: n,
      t: mn.STRING
    }, e), t) : r.isNull() ? __spreadValues(__spreadValues({
      v: null
    }, e), t) : __spreadValues(__spreadValues({
      v: n,
      t: mn.STRING
    }, e), t);
  }
}
function wm(a2) {
  let i = 0, e = 0;
  return a2.forEach((t, r) => {
    if (r % 2 === 1)
      if (t.isArray()) {
        const n = t;
        i = Math.max(i, n.getRowCount()), e = Math.max(e, n.getColumnCount());
      } else
        i = Math.max(i, 1), e = Math.max(e, 1);
  }), { maxRowLength: i, maxColumnLength: e };
}
function Kr(a2, i) {
  if (a2.length === 0 || a2.length % 2 !== 0)
    return {
      isError: true,
      errorObject: g2.create(h.VALUE),
      rangeIsDifferentSize: false,
      criteriaMaxRowLength: 0,
      criteriaMaxColumnLength: 0,
      targetRange: null,
      variants: []
    };
  let e = null, t = -1, r = -1;
  if (i) {
    if (!i.isReferenceObject())
      return {
        isError: true,
        errorObject: g2.create(h.VALUE),
        rangeIsDifferentSize: false,
        criteriaMaxRowLength: 0,
        criteriaMaxColumnLength: 0,
        targetRange: null,
        variants: []
      };
    e = i.toArrayValueObject(), t = e.getRowCount(), r = e.getColumnCount();
  }
  let n = 0, s = 0, o = false;
  const u = [];
  for (let c = 0; c < a2.length; c++)
    if (c % 2 === 1) {
      const l = a2[c - 1], f2 = a2[c];
      if (!l.isReferenceObject())
        return {
          isError: true,
          errorObject: g2.create(h.VALUE),
          rangeIsDifferentSize: false,
          criteriaMaxRowLength: 0,
          criteriaMaxColumnLength: 0,
          targetRange: null,
          variants: []
        };
      const m2 = l.toArrayValueObject(), d2 = m2.getRowCount(), _2 = m2.getColumnCount();
      c === 1 && t === -1 && r === -1 ? (t = d2, r = _2) : !o && (t !== d2 || r !== _2) && (o = true);
      let C = f2;
      f2.isReferenceObject() && (C = f2.toArrayValueObject()), n = Math.max(n, C.isArray() ? C.getRowCount() : 1), s = Math.max(s, C.isArray() ? C.getColumnCount() : 1), u.push(m2), u.push(C);
    }
  return {
    isError: false,
    errorObject: null,
    rangeIsDifferentSize: o,
    criteriaMaxRowLength: n,
    criteriaMaxColumnLength: s,
    targetRange: e,
    variants: u
  };
}
function ea(a2) {
  return a2.isArray() ? a2 : K2.createByArray([[a2.getValue()]]);
}
function Zr(a2, i, e, t = false) {
  const r = [];
  for (let n = 0; n < a2.length; n++) {
    if (n % 2 === 1) continue;
    const s = a2[n], o = a2[n + 1];
    O(i, e, o, g2.create(h.NA)).iterator((c, l, f2) => {
      if (!c)
        return;
      let m2 = os(s, c);
      if (t && (m2 = us(m2, s, c)), r[l] === void 0 && (r[l] = []), r[l][f2] === void 0) {
        r[l][f2] = m2;
        return;
      }
      r[l][f2] = Sm(r[l][f2], m2);
    });
  }
  return r;
}
function us(a2, i, e) {
  const [t, r] = La(`${e.getValue()}`);
  return a2.mapValue((n, s, o) => {
    const u = i.get(s, o);
    if (u && Lm(u, r))
      return n;
    if (u != null && u.isError() && r.isError() && u.getValue() === r.getValue())
      return T.create(true);
    if (t === Y2.EQUALS || t === Y2.NOT_EQUAL) {
      if (u != null && u.isNumber() && r.isString()) {
        const c = r.convertToNumberObjectValue();
        if (c.isNumber())
          return u.compare(c, t);
      }
      if (r.isNumber() && (u != null && u.isString())) {
        const c = u.convertToNumberObjectValue();
        if (c.isNumber())
          return c.compare(r, t);
      }
      if (t === Y2.EQUALS)
        return T.create(false);
      if (t === Y2.NOT_EQUAL)
        return T.create(true);
    }
    return T.create(false);
  });
}
function Lm(a2, i) {
  if (a2.isNumber() && i.isNumber() || a2.isBoolean() && i.isBoolean())
    return true;
  const e = a2.isString() && a2.getValue() === "", t = i.isString() && i.getValue() === "";
  return !!((e || a2.isNull()) && (t || i.isNull()) || a2.isString() && !e && i.isString() && !t);
}
var Tr = ((a2) => (a2[a2.CELL = 0] = "CELL", a2[a2.COLUMN = 1] = "COLUMN", a2[a2.ROW = 2] = "ROW", a2))(Tr || {});
function Pm(a2, i) {
  let e;
  switch (i) {
    case 0:
      e = new Ma(a2);
      break;
    case 1:
      e = new Da(a2);
      break;
    case 2:
      e = new wa(a2);
      break;
    default:
      throw new Error("Unknown reference object type");
  }
  return e;
}
function xm(a2, i) {
  let e;
  return a2.isCell() && i.isCell() || a2.isRow() && i.isRow() || a2.isColumn() && i.isColumn() ? e = a2.unionBy(i) : e = g2.create(h.NAME), e;
}
var jm = Object.getOwnPropertyDescriptor;
var Um = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? jm(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var vm = (a2, i) => (e, t) => i(e, t, a2);
var ta = class extends Ve {
  constructor(a2) {
    super(), this._univerInstanceService = a2;
  }
  generateCellValue(a2, i) {
    if (i.trim() === "")
      return {
        v: ""
      };
    let e = a2;
    if (a2.startsWith("#") && bo(a2.slice(1))) {
      const { unitId: t, sheetName: r, range: n } = kr(a2.slice(1)), s = this._univerInstanceService.getCurrentUnitOfType(we.UNIVER_SHEET);
      if (t === "" || t === s.getUnitId())
        if (r === "")
          e = `#gid=${s.getActiveSheet().getSheetId()}&range=${Yt(n)}`;
        else {
          const o = s.getSheetBySheetName(r);
          o && (e = `#gid=${o.getSheetId()}&range=${Yt(n)}`);
        }
    } else Z.isLegalUrl(a2) && (e = Z.normalizeUrl(a2));
    return {
      p: Fn.create().insertLink(i, e).getData()
    };
  }
};
ta = Um([
  vm(0, br)
], ta);
var Xo = createIdentifier(
  "univer.formula.hyperlink-engine-formula.service"
);
var Tm = Object.getOwnPropertyDescriptor;
var Im = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Tm(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var vi = (a2, i) => (e, t) => i(e, t, a2);
var tt = ((a2) => (a2[a2.IDLE = 0] = "IDLE", a2[a2.START = 1] = "START", a2[a2.START_DEPENDENCY = 2] = "START_DEPENDENCY", a2[a2.START_CALCULATION = 3] = "START_CALCULATION", a2[a2.CURRENTLY_CALCULATING = 4] = "CURRENTLY_CALCULATING", a2[a2.START_DEPENDENCY_ARRAY_FORMULA = 5] = "START_DEPENDENCY_ARRAY_FORMULA", a2[a2.START_CALCULATION_ARRAY_FORMULA = 6] = "START_CALCULATION_ARRAY_FORMULA", a2[a2.CURRENTLY_CALCULATING_ARRAY_FORMULA = 7] = "CURRENTLY_CALCULATING_ARRAY_FORMULA", a2[a2.CALCULATION_COMPLETED = 8] = "CALCULATION_COMPLETED", a2))(tt || {});
var Ir = ((a2) => (a2[a2.INITIAL = 0] = "INITIAL", a2[a2.STOP_EXECUTION = 1] = "STOP_EXECUTION", a2[a2.NOT_EXECUTED = 2] = "NOT_EXECUTED", a2[a2.SUCCESS = 3] = "SUCCESS", a2))(Ir || {});
var ra = class extends Ve {
  constructor(i, e) {
    super();
    A(this, "_formulaExecuteStage", 0);
    A(this, "_stopState", false);
    A(this, "_currentRow", -1);
    A(this, "_currentColumn", -1);
    A(this, "_currentRowCount", Number.NEGATIVE_INFINITY);
    A(this, "_currentColumnCount", Number.NEGATIVE_INFINITY);
    A(this, "_currentSubUnitId", "");
    A(this, "_currentUnitId", "");
    A(this, "_runtimeData", {});
    A(this, "_runtimeOtherData", {});
    A(this, "_unitArrayFormulaRange", {});
    A(this, "_unitArrayFormulaEmbeddedMap", {});
    A(this, "_runtimeArrayFormulaCellData", {});
    A(this, "_runtimeClearArrayFormulaCellData", {});
    A(this, "_runtimeFeatureRange", {});
    A(this, "_runtimeFeatureCellData", {});
    A(this, "_runtimeImageFormulaData", []);
    A(this, "_functionsExecutedState", 0);
    A(this, "_functionDefinitionPrivacyVar", /* @__PURE__ */ new Map());
    A(this, "_totalFormulasToCalculate", 0);
    A(this, "_completedFormulasCount", 0);
    A(this, "_totalArrayFormulasToCalculate", 0);
    A(this, "_completedArrayFormulasCount", 0);
    A(this, "_formulaCycleIndex", 0);
    A(this, "_isCycleDependency", false);
    this._currentConfigService = i, this._hyperlinkEngineFormulaService = e;
  }
  get currentRow() {
    return this._currentRow;
  }
  get currentColumn() {
    return this._currentColumn;
  }
  get currentRowCount() {
    return this._currentRowCount;
  }
  get currentColumnCount() {
    return this._currentColumnCount;
  }
  get currentSubUnitId() {
    return this._currentSubUnitId;
  }
  get currentUnitId() {
    return this._currentUnitId;
  }
  dispose() {
    super.dispose(), this.reset(), this._runtimeFeatureCellData = {}, this._runtimeFeatureRange = {}, this.clearReferenceAndNumberformatCache();
  }
  enableCycleDependency() {
    this._isCycleDependency = true;
  }
  disableCycleDependency() {
    this._isCycleDependency = false;
  }
  isCycleDependency() {
    return this._isCycleDependency;
  }
  setFormulaCycleIndex(i) {
    this._formulaCycleIndex = i;
  }
  getFormulaCycleIndex() {
    return this._formulaCycleIndex;
  }
  setTotalArrayFormulasToCalculate(i) {
    this._totalArrayFormulasToCalculate = i;
  }
  getTotalArrayFormulasToCalculate() {
    return this._totalArrayFormulasToCalculate;
  }
  setCompletedArrayFormulasCount(i) {
    this._completedArrayFormulasCount = i;
  }
  getCompletedArrayFormulasCount() {
    return this._completedArrayFormulasCount;
  }
  setTotalFormulasToCalculate(i) {
    this._totalFormulasToCalculate = i;
  }
  getTotalFormulasToCalculate() {
    return this._totalFormulasToCalculate;
  }
  setCompletedFormulasCount(i) {
    this._completedFormulasCount = i;
  }
  getCompletedFormulasCount() {
    return this._completedFormulasCount;
  }
  markedAsSuccessfullyExecuted() {
    this._functionsExecutedState = 3;
  }
  markedAsNoFunctionsExecuted() {
    this._functionsExecutedState = 2;
  }
  markedAsStopFunctionsExecuted() {
    this._functionsExecutedState = 1;
  }
  markedAsInitialFunctionsExecuted() {
    this._functionsExecutedState = 0;
  }
  stopExecution() {
    this._stopState = true, this.setFormulaExecuteStage(
      0
      /* IDLE */
    );
  }
  isStopExecution() {
    return this._stopState;
  }
  setFormulaExecuteStage(i) {
    this._formulaExecuteStage = i;
  }
  getFormulaExecuteStage() {
    return this._formulaExecuteStage;
  }
  reset() {
    this._formulaExecuteStage = 0, this._runtimeData = {}, this._runtimeOtherData = {}, this._unitArrayFormulaRange = {}, this._unitArrayFormulaEmbeddedMap = {}, this._runtimeArrayFormulaCellData = {}, this._runtimeClearArrayFormulaCellData = {}, this._runtimeImageFormulaData = [], this._functionDefinitionPrivacyVar.clear(), this.markedAsInitialFunctionsExecuted(), this._stopState = false, this._isCycleDependency = false, this._totalFormulasToCalculate = 0, this._completedFormulasCount = 0, this.clearReferenceAndNumberformatCache();
  }
  clearReferenceAndNumberformatCache() {
    of2(), hf(), Yl();
  }
  setCurrent(i, e, t, r, n, s) {
    this._currentRow = i, this._currentColumn = e, this._currentRowCount = t, this._currentColumnCount = r, this._currentSubUnitId = n, this._currentUnitId = s;
  }
  clearFunctionDefinitionPrivacyVar() {
    this._functionDefinitionPrivacyVar.clear();
  }
  registerFunctionDefinitionPrivacyVar(i, e) {
    this._functionDefinitionPrivacyVar.set(i, e);
  }
  getFunctionDefinitionPrivacyVar(i) {
    return this._functionDefinitionPrivacyVar.get(i);
  }
  setRuntimeOtherData(i, e, t, r) {
    const n = this._currentSubUnitId, s = this._currentUnitId;
    this._runtimeOtherData[s] === void 0 && (this._runtimeOtherData[s] = {});
    const o = this._runtimeOtherData[s];
    (o[n] === void 0 || o[n] === null) && (o[n] = {});
    const u = o[n];
    let c = [];
    if (r.isReferenceObject() || r.isValueObject() && r.isArray()) {
      const l = r, { startRow: f2, startColumn: m2 } = l.getRangePosition();
      l.iterator((d2, _2, C) => {
        const E = this._getValueObjectOfRuntimeData(d2), R = _2 - f2, b = C - m2;
        c[R] == null && (c[R] = []), c[R][b] = E;
      });
    } else
      c = [[this._getValueObjectOfRuntimeData(r)]];
    (u[i] === void 0 || u[i] === null) && (u[i] = {}), (u[i][t] === void 0 || u[i][t] === null) && (u[i][t] = {}), u[i][t][e] = c;
  }
  // eslint-disable-next-line max-lines-per-function
  setRuntimeData(i) {
    const e = this._currentRow, t = this._currentColumn, r = this._currentRowCount, n = this.currentColumnCount, s = this._currentSubUnitId, o = this._currentUnitId;
    this._runtimeData[o] == null && (this._runtimeData[o] = {});
    const u = this._runtimeData[o];
    u[s] == null && (u[s] = new ht());
    const c = u[s];
    this._unitArrayFormulaRange[o] == null && (this._unitArrayFormulaRange[o] = {});
    const l = this._unitArrayFormulaRange[o];
    (l[s] === null || l[s] === void 0) && (l[s] = {});
    const f2 = new ht(l[s]);
    this._runtimeArrayFormulaCellData[o] === void 0 && (this._runtimeArrayFormulaCellData[o] = {});
    const m2 = this._runtimeArrayFormulaCellData[o];
    m2[s] == null && (m2[s] = new ht());
    const d2 = m2[s];
    this._runtimeClearArrayFormulaCellData[o] === void 0 && (this._runtimeClearArrayFormulaCellData[o] = {});
    const _2 = this._runtimeClearArrayFormulaCellData[o];
    _2[s] == null && (_2[s] = new ht());
    const C = _2[s];
    if (i.isReferenceObject() || i.isValueObject() && i.isArray()) {
      const E = i, { startRow: R, startColumn: b, endRow: p2, endColumn: V } = E.getRangePosition();
      if (R === p2 && b === V) {
        const M2 = E.getFirstCell(), D2 = this._getValueObjectOfRuntimeData(M2);
        c.setValue(e, t, D2), C.setValue(e, t, D2), Ke.set(
          o,
          s,
          t,
          M2.getValue(),
          e,
          true
        );
        return;
      }
      const S2 = {
        startRow: e,
        startColumn: t,
        endRow: p2 - R + e,
        endColumn: V - b + t
      };
      if (f2.setValue(e, t, S2), this._checkIfArrayFormulaRangeHasData(o, s, e, t, S2) || this._checkIfArrayFormulaExceeded(r, n, S2)) {
        const M2 = this._getValueObjectOfRuntimeData(g2.create(h.SPILL));
        c.setValue(e, t, M2), C.setValue(e, t, M2), Ke.set(
          o,
          s,
          t,
          h.SPILL,
          e,
          true
        );
        const D2 = this._currentConfigService.getUnitData();
        E.iterator((w, L, v) => {
          var ne, z;
          const j2 = L - R + e, k = v - b + t, G2 = (z = (ne = D2[o]) == null ? void 0 : ne[s]) == null ? void 0 : z.cellData.getValue(j2, k);
          if (L === R && v === b)
            d2.setValue(e, t, M2);
          else if (G2 != null)
            G2.v == null && (G2.v = ""), d2.setValue(j2, k, G2);
          else {
            if (this._isInOtherArrayFormulaRange(o, s, e, t, j2, k))
              return true;
            d2.setValue(j2, k, { v: "" });
          }
        });
      } else {
        const M2 = g2.create(h.SPILL);
        E.iterator((D2, w, L) => {
          Ke.set(
            o,
            s,
            t - b + L,
            D2 ? D2.getValue() : 0,
            e - R + w,
            true
          );
          const v = this._getValueObjectOfRuntimeData(D2);
          if (w === R && L === b) {
            if (D2 != null && D2.isError() && D2.isEqualType(M2))
              return C.setValue(e, t, {}), c.setValue(e, t, __spreadValues({}, this._getValueObjectOfRuntimeData(M2))), false;
            c.setValue(e, t, __spreadValues({}, v));
          }
          const j2 = w - R + e, k = L - b + t;
          d2.setValue(j2, k, v);
        });
      }
    } else {
      const E = this._getValueObjectOfRuntimeData(i);
      if (c.setValue(e, t, E), i.isString() && i.isImage()) {
        const R = i.getImageInfo();
        R && this._runtimeImageFormulaData.push(__spreadProps(__spreadValues({}, R), {
          unitId: o,
          sheetId: s,
          row: e,
          column: t
        }));
      }
      Ke.set(
        o,
        s,
        t,
        i.getValue(),
        e,
        true
      ), C.setValue(e, t, E);
    }
  }
  _getValueObjectOfRuntimeData(i) {
    return i != null && i.isString() && i.isHyperlink() ? this._hyperlinkEngineFormulaService.generateCellValue(
      i.getHyperlinkUrl(),
      i.getValue()
    ) : Dm(i);
  }
  getUnitData() {
    return this._runtimeData;
  }
  getUnitArrayFormula() {
    return this._unitArrayFormulaRange;
  }
  getUnitArrayFormulaEmbeddedMap() {
    return this._unitArrayFormulaEmbeddedMap;
  }
  setUnitArrayFormulaEmbeddedMap() {
    const i = this._currentUnitId, e = this._currentSubUnitId, t = this._currentRow, r = this._currentColumn, n = this._unitArrayFormulaEmbeddedMap;
    n[i] == null && (n[i] = {}), n[i][e] == null && (n[i][e] = {}), n[i][e][t] == null && (n[i][e][t] = {}), n[i][e][t][r] = true;
  }
  getRuntimeOtherData() {
    return this._runtimeOtherData;
  }
  getRuntimeArrayFormulaCellData() {
    return this._runtimeArrayFormulaCellData;
  }
  getRuntimeClearArrayFormulaCellData() {
    return this._runtimeClearArrayFormulaCellData;
  }
  getRuntimeFeatureRange() {
    return this._runtimeFeatureRange;
  }
  setRuntimeFeatureRange(i, e) {
    this._runtimeFeatureRange[i] = e;
  }
  getRuntimeFeatureCellData() {
    return this._runtimeFeatureCellData;
  }
  setRuntimeFeatureCellData(i, e) {
    this._runtimeFeatureCellData[i] = e;
  }
  getRuntimeImageFormulaData() {
    return this._runtimeImageFormulaData;
  }
  getAllRuntimeData() {
    return {
      unitData: this.getUnitData(),
      arrayFormulaRange: this.getUnitArrayFormula(),
      arrayFormulaEmbedded: this.getUnitArrayFormulaEmbeddedMap(),
      unitOtherData: this.getRuntimeOtherData(),
      functionsExecutedState: this._functionsExecutedState,
      arrayFormulaCellData: this.getRuntimeArrayFormulaCellData(),
      clearArrayFormulaCellData: this.getRuntimeClearArrayFormulaCellData(),
      imageFormulaData: this.getRuntimeImageFormulaData(),
      runtimeFeatureRange: this.getRuntimeFeatureRange(),
      runtimeFeatureCellData: this.getRuntimeFeatureCellData()
    };
  }
  getRuntimeState() {
    return {
      totalFormulasToCalculate: this.getTotalFormulasToCalculate(),
      completedFormulasCount: this.getCompletedFormulasCount(),
      totalArrayFormulasToCalculate: this.getTotalArrayFormulasToCalculate(),
      completedArrayFormulasCount: this.getCompletedArrayFormulasCount(),
      stage: this.getFormulaExecuteStage(),
      formulaCycleIndex: this.getFormulaCycleIndex()
    };
  }
  clearArrayObjectCache() {
    _r.clear();
  }
  // eslint-disable-next-line complexity
  _checkIfArrayFormulaRangeHasData(i, e, t, r, n) {
    var m2, d2, _2, C, E, R, b, p2, V, S2, M2;
    const { startRow: s, startColumn: o, endRow: u, endColumn: c } = n, l = this._currentConfigService.getUnitData(), f2 = this._currentConfigService.getArrayFormulaCellData();
    (_2 = (d2 = (m2 = this._unitArrayFormulaRange[i]) == null ? void 0 : m2[e]) == null ? void 0 : d2[t]) == null || _2[r];
    for (let D2 = s; D2 <= u; D2++)
      for (let w = o; w <= c; w++) {
        if (D2 === t && r === w)
          continue;
        const L = (R = (E = (C = this._runtimeData) == null ? void 0 : C[i]) == null ? void 0 : E[e]) == null ? void 0 : R.getValue(D2, w);
        (p2 = (b = f2 == null ? void 0 : f2[i]) == null ? void 0 : b[e]) == null || p2.getValue(
          D2,
          w
        );
        const v = (M2 = (S2 = (V = l == null ? void 0 : l[i]) == null ? void 0 : V[e]) == null ? void 0 : S2.cellData) == null ? void 0 : M2.getValue(D2, w), j2 = this._getRuntimeFeatureCellValue(D2, w, e, i);
        if (!En(L) || this._isInOtherArrayFormulaRange(i, e, t, r, D2, w) || !En(v) || !En(j2))
          return true;
      }
    return false;
  }
  _getRuntimeFeatureCellValue(i, e, t, r) {
    return Uo(i, e, t, r, this._runtimeFeatureCellData);
  }
  _arrayCellHasData(i) {
    return i == null ? false : i.v !== void 0;
  }
  /**
   * If the current array formula in the extended area intersects with the existing array formula, a #SPILL! error will be reported. Note that if other array formulas are already #SPILL!, they will not conflict with the current array formula
   * @param formulaUnitId
   * @param formulaSheetId
   * @param formulaRow
   * @param formulaColumn
   * @param r
   * @param c
   * @returns
   */
  _isInOtherArrayFormulaRange(i, e, t, r, n, s) {
    var l;
    const o = (l = this._currentConfigService.getArrayFormulaRange()[i]) == null ? void 0 : l[e];
    if (o == null)
      return false;
    let u = false;
    return new ht(o).forValue((f2, m2, d2) => {
      var E, R;
      if (f2 === t && m2 === r)
        return;
      const _2 = this._isInArrayFormulaRange(d2, n, s), C = (R = (E = this._runtimeData[i]) == null ? void 0 : E[e]) == null ? void 0 : R.getValue(f2, m2);
      _2 && (C == null ? void 0 : C.v) !== h.SPILL && (u = true);
    }), u;
  }
  _isInArrayFormulaRange(i, e, t) {
    if (i == null)
      return false;
    const { startRow: r, startColumn: n, endRow: s, endColumn: o } = i;
    return e >= r && e <= s && t >= n && t <= o;
  }
  _checkIfArrayFormulaExceeded(i, e, t) {
    return t.endRow >= i || t.endColumn >= e;
  }
  _isInDirtyRange(i, e, t, r) {
    const n = this._currentConfigService.getDirtyRanges();
    return n.length === 0 ? true : Xc(n, i, e, t, r);
  }
};
ra = Im([
  vi(0, Wt),
  vi(1, Xo)
], ra);
var Nt2 = createIdentifier("univer.formula.runtime.service");
var oe = ((a2) => (a2[a2.REFERENCE = 1] = "REFERENCE", a2[a2.VALUE = 2] = "VALUE", a2[a2.OPERATOR = 3] = "OPERATOR", a2[a2.FUNCTION = 4] = "FUNCTION", a2[a2.LAMBDA = 5] = "LAMBDA", a2[a2.LAMBDA_PARAMETER = 6] = "LAMBDA_PARAMETER", a2[a2.ERROR = 7] = "ERROR", a2[a2.BASE = 8] = "BASE", a2[a2.ROOT = 9] = "ROOT", a2[a2.UNION = 10] = "UNION", a2[a2.PREFIX = 11] = "PREFIX", a2[a2.SUFFIX = 12] = "SUFFIX", a2[a2.NULL = 13] = "NULL", a2))(oe || {});
var Vt = /* @__PURE__ */ new Map([
  [1, 7],
  [2, 9],
  [3, 8],
  [4, 6],
  [5, 1],
  [6, 2],
  [9, 10],
  [10, 3],
  [11, 4],
  [12, 5]
]);
var qe = class {
  constructor(i) {
    A(this, "_children", []);
    A(this, "_definedNames");
    A(this, "_parent");
    A(this, "_valueObject");
    A(this, "_calculateState", false);
    A(this, "_async", false);
    A(this, "_address", false);
    A(this, "_isForcedCalculateFunction", false);
    this._token = i;
  }
  dispose() {
    var i;
    this._children.forEach((e) => {
      e.dispose();
    }), (i = this._valueObject) == null || i.dispose(), this._valueObject = null, this._children = [], this._definedNames = null, this._parent = null;
  }
  get nodeType() {
    return oe.BASE;
  }
  resetCalculationState() {
    this._children.forEach((i) => {
      i.resetCalculationState();
    }), this._valueObject = null, this._calculateState = false;
  }
  isAsync() {
    return this._async;
  }
  isAddress() {
    return this._address;
  }
  isForcedCalculateFunction() {
    return this._isForcedCalculateFunction;
  }
  setAsync() {
    this._async = true;
  }
  setAddress() {
    this._address = true;
  }
  getParent() {
    return this._parent;
  }
  setParent(i) {
    this._parent = i, i.addChildren(this);
  }
  setForcedCalculateFunction() {
    this._isForcedCalculateFunction = true;
  }
  getChildren() {
    return this._children;
  }
  addChildren(...i) {
    this._children.push(...i);
  }
  getToken() {
    return this._token;
  }
  setValue(i) {
    this._valueObject = i;
  }
  getValue() {
    return this._valueObject;
  }
  isCalculated() {
    return this._calculateState;
  }
  setCalculated() {
    this._calculateState = true;
  }
  execute() {
  }
  setNotEmpty(i = true) {
  }
  executeAsync() {
    return __async(this, null, function* () {
      return Promise.resolve(It.SUCCESS);
    });
  }
  serialize() {
    const i = this.getToken(), e = this.getChildren(), t = [], r = e.length;
    for (let s = 0; s < r; s++) {
      const o = e[s];
      t.push(o.serialize());
    }
    const n = {
      token: i,
      nodeType: this.nodeType
    };
    return r > 0 && (n.children = t), n;
  }
  hasDefinedName(i) {
    var e;
    return ((e = this._definedNames) == null ? void 0 : e.includes(i)) || false;
  }
  setDefinedNames(i) {
    this._definedNames = i;
  }
  getDefinedNames() {
    return this._definedNames;
  }
};
var Ue = class _Ue extends qe {
  constructor(e) {
    super(e);
    A(this, "_errorValueObject");
    this._errorValueObject = g2.create(e);
  }
  get nodeType() {
    return oe.ERROR;
  }
  static create(e) {
    return new _Ue(e);
  }
  getValue() {
    return this._errorValueObject;
  }
};
var Ot = 100;
var St = class {
  get zIndex() {
    return 0;
  }
  dispose() {
  }
  create(i, e, t) {
    let r;
    return i instanceof ie2 ? r = i.getToken() : r = i, new qe(r);
  }
};
var na = class extends qe {
  get nodeType() {
    return oe.ROOT;
  }
  execute() {
    const i = this.getChildren();
    if (i.length > 1) {
      this.setValue(g2.create(h.VALUE));
      return;
    }
    const e = i[0];
    e == null ? this.setValue(g2.create(h.VALUE)) : this.setValue(e.getValue());
  }
};
var Ko = class extends St {
  get zIndex() {
    return Vt.get(oe.ROOT) || Ot;
  }
  checkAndCreateNodeType(i) {
    if (!(i instanceof ie2))
      return;
    if (i.getToken() === Ft)
      return new na(Ft);
  }
};
var Bm = 5e3;
var Hr = new xt(Bm);
function Ti(a2, i, e, t, r) {
  let n = Hr.get(`${a2}${i}`);
  if (n && !Zo(n, r))
    return n;
  const s = e.treeBuilder(i);
  if (fr.has(s))
    return Ue.create(s);
  if (n = t.parse(s), n == null)
    throw new Error("astNode is null");
  return Hr.set(`${a2}${i}`, n), n;
}
function Zo(a2, i) {
  const e = i.getDirtyDefinedNameMap(), t = i.getExecuteUnitId();
  if (t != null && e[t] != null) {
    const r = Object.keys(e[t]);
    for (let n = 0, s = r.length; n < s; n++) {
      const o = r[n];
      if (a2.hasDefinedName(o))
        return true;
    }
  }
  return false;
}
function Fm(a2, i, e) {
  return !!(i != null && Zo(i, e));
}
var Xt = createIdentifier("univer.formula-function.service");
var km = class extends Ve {
  constructor() {
    super(...arguments);
    A(this, "_functionExecutors", /* @__PURE__ */ new Map());
    A(this, "_functionDescriptions", /* @__PURE__ */ new Map());
  }
  dispose() {
    super.dispose(), this._functionExecutors.clear(), this._functionDescriptions.clear();
  }
  registerExecutors(...e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      this._functionExecutors.set(r.name, r);
    }
  }
  getExecutors() {
    return this._functionExecutors;
  }
  getExecutor(e) {
    return this._functionExecutors.get(e);
  }
  hasExecutor(e) {
    return this._functionExecutors.has(e);
  }
  unregisterExecutors(...e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      this._functionExecutors.delete(r);
    }
  }
  registerDescriptions(...e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      this._functionDescriptions.set(r.functionName, r);
    }
    return Be(() => {
      for (let t = 0; t < e.length; t++) {
        const r = e[t];
        this._functionDescriptions.delete(r.functionName);
      }
    });
  }
  getDescriptions() {
    return this._functionDescriptions;
  }
  getDescription(e) {
    return this._functionDescriptions.get(e);
  }
  hasDescription(e) {
    return this._functionDescriptions.has(e);
  }
  unregisterDescriptions(...e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      this._functionDescriptions.delete(r);
    }
  }
  deleteFormulaAstCacheKey(...e) {
    Hr.forEach((t, r) => {
      e.forEach((n) => {
        r.includes(n) && Hr.delete(r);
      });
    });
  }
};
var ke = ((a2) => (a2.COMPARE = "COMPARE", a2.DIVIDED = "DIVIDED", a2.MINUS = "MINUS", a2.MULTIPLY = "MULTIPLY", a2.PLUS = "PLUS", a2.UNION = "UNION", a2.CUBE = "CUBE", a2))(ke || {});
var $m = Object.getOwnPropertyDescriptor;
var Ym = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? $m(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var Ii = (a2, i) => (e, t) => i(e, t, a2);
var jn = class extends qe {
  constructor(i, e, t) {
    super(e), this._runtimeService = i, this._operatorString = e, this._functionExecutor = t;
  }
  get nodeType() {
    return oe.PREFIX;
  }
  execute() {
    let e = this.getChildren()[0].getValue(), t;
    if (e == null)
      throw new Error("object is null");
    this._operatorString === we2.MINUS ? (e.isReferenceObject() && (e = e.toArrayValueObject()), t = this._functionExecutor.calculate(
      y2.create(0),
      e
    )) : this._operatorString === we2.AT ? t = this._handlerAT(e) : t = g2.create(h.VALUE), this.setValue(t);
  }
  _handlerAT(i) {
    if (!i.isReferenceObject())
      return g2.create(h.VALUE);
    const e = i;
    if (e.isCell())
      return g2.create(h.VALUE);
    const t = this._runtimeService, r = t.currentRow || 0, n = t.currentColumn || 0, s = e.getRangePosition(), { startRow: o, startColumn: u, endRow: c, endColumn: l } = s;
    return l !== u && c !== o || o === c && u === l ? g2.create(h.VALUE) : c === o && n >= u && n <= l ? e.getCellByColumn(n) : u === l && r >= o && r <= c ? e.getCellByRow(r) : e.isTable() ? e.getCellByPosition(r) : g2.create(h.VALUE);
  }
};
var Un = class extends St {
  constructor(a2, i) {
    super(), this._functionService = a2, this._runtimeService = i;
  }
  get zIndex() {
    return Vt.get(oe.PREFIX) || Ot;
  }
  checkAndCreateNodeType(a2) {
    if (!(a2 instanceof ie2))
      return;
    const i = a2.getToken(), e = i.trim();
    if (e.charAt(0) === '"' && e.charAt(e.length - 1) === '"')
      return;
    let t = "";
    if (e === we2.MINUS)
      t = ke.MINUS;
    else return e === we2.AT ? new jn(this._runtimeService, e) : void 0;
    const r = this._functionService.getExecutor(t);
    return r ? new jn(this._runtimeService, e, r) : (console.error(`No function ${i}`), Ue.create(h.NAME));
  }
};
Un = Ym([
  Ii(0, Xt),
  Ii(1, Nt2)
], Un);
function zo(a2, i, e) {
  let t, r, n = a2;
  const s = n[0];
  let o = 0;
  if (s === we2.MINUS) {
    const u = i.getExecutor(ke.MINUS);
    t = new jn(e, we2.MINUS, u), o++;
  } else s === we2.AT && (r = new jn(e, we2.AT), t && r.setParent(t), o++);
  return o > 0 && (n = n.slice(o)), { tokenTrim: n, minusPrefixNode: t, atPrefixNode: r };
}
var Hm = Object.getOwnPropertyDescriptor;
var Gm = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Hm(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var hr = (a2, i) => (e, t) => i(e, t, a2);
var Wm = class extends qe {
  constructor(i, e, t, r, n, s) {
    super(i), this._functionExecutor = e, this._currentConfigService = t, this._runtimeService = r, this._definedNamesService = n, this._formulaDataModel = s, this._functionExecutor.isAsync() && this.setAsync(), this._functionExecutor.isAddress() && this.setAddress(), this._functionExecutor.needsLocale && this._setLocale(), this._functionExecutor.needsSheetsInfo && this._setSheetsInfo(), this._functionExecutor.needsFormulaDataModel && this._functionExecutor.setFormulaDataModel(this._formulaDataModel);
  }
  get nodeType() {
    return oe.FUNCTION;
  }
  executeAsync() {
    return __async(this, null, function* () {
      const i = [], e = this.getChildren(), t = e.length;
      this._compatibility();
      for (let s = 0; s < t; s++) {
        const u = e[s].getValue();
        u != null && (u.isReferenceObject() && !this._functionExecutor.needsReferenceObject ? i.push(u.toArrayValueObject()) : i.push(u));
      }
      const r = yield this._calculateAsync(i);
      let n;
      return r.isAsyncObject() || r.isAsyncArrayObject() ? n = yield r.getValue() : n = r, this._setEmbeddedArrayFormulaToResult(n), this._setRefData(n), this.setValue(n), Promise.resolve(It.SUCCESS);
    });
  }
  execute() {
    const i = [], e = this.getChildren(), t = e.length;
    this._compatibility();
    for (let n = 0; n < t; n++) {
      const o = e[n].getValue();
      o != null && (o.isReferenceObject() && this._functionExecutor.needsFilteredOutRows && this._setFilteredOutRows(o), o.isReferenceObject() && !this._functionExecutor.needsReferenceObject ? i.push(o.toArrayValueObject()) : i.push(o));
    }
    const r = this._calculate(i);
    this._setEmbeddedArrayFormulaToResult(r), this._setRefData(r), this.setValue(r);
  }
  isFunctionExecutorArgumentsIgnoreNumberPattern() {
    return this._functionExecutor.isArgumentsIgnoreNumberPattern();
  }
  /**
   * If it contains an array formula, set the current cell to the cache and send itself as a ref outward
   */
  _setEmbeddedArrayFormulaToResult(i) {
    if (!i.isArray())
      return;
    const e = i.getRowCount(), t = i.getColumnCount();
    e <= 1 && t <= 1 || this._runtimeService.setUnitArrayFormulaEmbeddedMap();
  }
  /**
   * Compatibility handling for special functions.
   */
  _compatibility() {
    this._lookupCompatibility();
  }
  /**
   * The LOOKUP function follows the following rules when dealing with vectors of different sizes:
   *    If the lookup_vector is larger than the result_vector,
   *    the LOOKUP function will ignore the extra portion of the lookup_vector and only use the portion of the result_vector that is the same size as the lookup_vector for lookup and returning results.
   *    If the lookup_vector is smaller than the result_vector,
   *    the LOOKUP function will continue using the last value of the result_vector for lookup and returning results after the last value of the lookup_vector.
   */
  _lookupCompatibility() {
    const i = this.getChildren(), e = i.length;
    if (!this._functionExecutor.needsExpandParams || e !== 3)
      return;
    const t = i[1].getValue(), r = i[2].getValue();
    if (!(t != null && t.isReferenceObject()) && !(r != null && r.isReferenceObject()))
      return;
    let n, s;
    if (t != null && t.isReferenceObject()) {
      const _2 = t.getRangeData(), { startRow: C, startColumn: E, endRow: R, endColumn: b } = _2;
      n = R - C + 1, s = b - E + 1;
    } else
      n = t != null && t.isArray() ? t.getRowCount() : 1, s = t != null && t.isArray() ? t.getColumnCount() : 1;
    const o = r.getRangeData(), { startRow: u, startColumn: c, endRow: l, endColumn: f2 } = o, m2 = l - u + 1, d2 = f2 - c + 1;
    n !== m2 && (o.endRow += n - m2), s !== d2 && (o.endColumn += s - d2);
  }
  /**
   * Transform the result of a custom function to a NodeValueType.
   */
  _handleCustomResult(i) {
    var t;
    if (typeof i != "object" || i == null)
      return Pt.create(i);
    const e = qo(i);
    return K2.create({
      calculateValueList: e,
      rowCount: e.length,
      columnCount: ((t = e[0]) == null ? void 0 : t.length) || 0,
      unitId: "",
      sheetId: "",
      row: -1,
      column: -1
    });
  }
  _handleAddressFunction() {
    this._functionExecutor.isAddress() && this._setDefinedNamesForFunction();
  }
  _mapVariantsToValues(i) {
    return i.map((e) => e.isArray() ? e.toValue() : e.isLambda() ? e : e.getValue());
  }
  _calculate(i) {
    const { minParams: e, maxParams: t } = this._functionExecutor;
    if (e !== -1 && t !== -1 && (i.length < e || i.length > t))
      return g2.create(h.NA);
    let r;
    if (this._setRefInfo(), this._functionExecutor.isCustom()) {
      const n = this._functionExecutor.calculateCustom(
        ...this._mapVariantsToValues(i)
      );
      r = this._handleCustomResult(n);
    } else
      this._handleAddressFunction(), r = this._functionExecutor.calculate(...i);
    return r;
  }
  _calculateAsync(i) {
    return __async(this, null, function* () {
      const { minParams: e, maxParams: t } = this._functionExecutor;
      if (e !== -1 && t !== -1 && (i.length < e || i.length > t))
        return g2.create(h.NA);
      let r;
      if (this._setRefInfo(), this._functionExecutor.isCustom()) {
        const n = yield this._functionExecutor.calculateCustom(
          ...this._mapVariantsToValues(i)
        );
        r = this._handleCustomResult(n);
      } else
        this._handleAddressFunction(), r = this._functionExecutor.calculate(...i);
      return r;
    });
  }
  _setDefinedNamesForFunction() {
    const i = this._currentConfigService.getExecuteUnitId();
    if (i == null)
      return;
    const e = this._definedNamesService.getDefinedNameMap(i);
    e != null && this._functionExecutor.setDefinedNames(e);
  }
  _setRefInfo() {
    const { currentUnitId: i, currentSubUnitId: e, currentRow: t, currentColumn: r } = this._runtimeService;
    if (this._functionExecutor.setRefInfo(i, e, t, r), this._functionExecutor.needsSheetRowColumnCount) {
      const { rowCount: n, columnCount: s } = this._currentConfigService.getSheetRowColumnCount(i, e);
      this._functionExecutor.setSheetRowColumnCount(n, s);
    }
  }
  _setRefData(i) {
    if (!i.isReferenceObject())
      return;
    const e = i;
    e.setForcedSheetId(this._currentConfigService.getSheetNameMap()), e.setUnitData(this._currentConfigService.getUnitData()), e.setArrayFormulaCellData(this._currentConfigService.getArrayFormulaCellData()), e.setRuntimeData(this._runtimeService.getUnitData()), e.setRuntimeArrayFormulaCellData(this._runtimeService.getRuntimeArrayFormulaCellData()), e.setRuntimeFeatureCellData(this._runtimeService.getRuntimeFeatureCellData());
  }
  _setLocale() {
    this._functionExecutor.setLocale(this._currentConfigService.getLocale());
  }
  _setSheetsInfo() {
    this._functionExecutor.setSheetsInfo(this._currentConfigService.getSheetsInfo());
  }
  _setFilteredOutRows(i) {
    const { startRow: e, endRow: t } = i.getRangePosition(), r = this._currentConfigService.getFilteredOutRows(
      i.getUnitId(),
      i.getSheetId(),
      e,
      t
    );
    i.setFilteredOutRows(r);
  }
};
var Qm = class extends qe {
  constructor(i = "Error") {
    super(i);
  }
  get nodeType() {
    return oe.FUNCTION;
  }
  executeAsync() {
    return __async(this, null, function* () {
      return this.setValue(g2.create(h.NAME)), Promise.resolve(It.SUCCESS);
    });
  }
  execute() {
    this.setValue(g2.create(h.NAME));
  }
};
var vn = class extends St {
  constructor(a2, i, e, t, r, n) {
    super(), this._functionService = a2, this._currentConfigService = i, this._runtimeService = e, this._definedNamesService = t, this._injector = r, this._formulaDataModel = n;
  }
  get zIndex() {
    return Vt.get(oe.FUNCTION) || Ot;
  }
  create(a2) {
    const i = this._functionService.getExecutor(a2);
    return i ? new Wm(
      a2,
      i,
      this._currentConfigService,
      this._runtimeService,
      this._definedNamesService,
      this._formulaDataModel
    ) : (console.error(`No function ${a2}`), Ue.create(h.NAME));
  }
  checkAndCreateNodeType(a2) {
    if (typeof a2 == "string")
      return;
    const i = a2.getToken(), { tokenTrim: e, minusPrefixNode: t, atPrefixNode: r } = zo(i.trim(), this._functionService, this._runtimeService);
    if (!Number.isNaN(Number(e)) && !this._isParentUnionNode(a2))
      return Ue.create(h.VALUE);
    const n = e.toUpperCase();
    if (this._functionService.hasExecutor(n)) {
      const s = this.create(n);
      return r ? s.setParent(r) : t && s.setParent(t), s;
    }
  }
  _isParentUnionNode(a2) {
    var i, e;
    return ((e = (i = a2.getParent()) == null ? void 0 : i.getParent()) == null ? void 0 : e.getToken()) === X2.COLON;
  }
};
vn = Gm([
  hr(0, Xt),
  hr(1, Wt),
  hr(2, Nt2),
  hr(3, Lr),
  hr(4, Inject(Injector)),
  hr(5, Inject(yr))
], vn);
var qm = Object.getOwnPropertyDescriptor;
var Xm = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? qm(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var Km = (a2, i) => (e, t) => i(e, t, a2);
var Vr = class extends Ve {
  constructor(a2) {
    super(), this._runtimeService = a2;
  }
  executeAsync(a2) {
    return __async(this, null, function* () {
      if (!a2 || !a2.node)
        return Promise.resolve(g2.create(h.VALUE));
      const i = a2.node, e = a2.refOffsetX, t = a2.refOffsetY;
      yield this._executeAsync(i, e, t);
      const r = i.getValue();
      return r == null ? Promise.resolve(g2.create(h.VALUE)) : Promise.resolve(r);
    });
  }
  execute(a2) {
    if (!a2 || !a2.node)
      return g2.create(h.VALUE);
    const i = a2.node, e = a2.refOffsetX, t = a2.refOffsetY;
    this._execute(i, e, t);
    const r = i.getValue();
    return r == null ? g2.create(h.VALUE) : r;
  }
  executePreCalculateNode(a2) {
    return a2.execute(), a2.getValue();
  }
  checkAsyncNode(a2) {
    if (a2 == null)
      return false;
    const i = [];
    this._checkAsyncNode(a2, i);
    for (let e = 0, t = i.length; e < t; e++)
      if (i[e] === true)
        return true;
    return false;
  }
  _checkAsyncNode(a2, i) {
    const e = a2.getChildren(), t = e.length;
    for (let r = 0; r < t; r++) {
      const n = e[r];
      i.push(n.isAsync()), this._checkAsyncNode(n, i);
    }
  }
  _executeAsync(a2, i = 0, e = 0) {
    return __async(this, null, function* () {
      if (this._runtimeService.isStopExecution())
        return Promise.resolve(It.ERROR);
      const t = a2.getChildren(), r = t.length;
      for (let n = 0; n < r; n++) {
        const s = t[n];
        if (s.getToken().toUpperCase() === Fr && s.isEmptyParamFunction()) {
          s.execute();
          continue;
        }
        yield this._executeAsync(s, i, e);
      }
      return a2.nodeType === oe.REFERENCE && a2.setRefOffset(i, e), a2.nodeType === oe.FUNCTION && a2.isAsync() ? yield a2.executeAsync() : a2.execute(), Promise.resolve(It.SUCCESS);
    });
  }
  _execute(a2, i = 0, e = 0) {
    if (this._runtimeService.isStopExecution())
      return It.ERROR;
    const t = a2.getChildren(), r = t.length;
    for (let n = 0; n < r; n++) {
      const s = t[n];
      if (s.getToken().toUpperCase() === Fr && s.isEmptyParamFunction()) {
        s.execute();
        continue;
      }
      this._execute(s, i, e);
    }
    return a2.nodeType === oe.REFERENCE && a2.setRefOffset(i, e), a2.execute(), It.SUCCESS;
  }
};
Vr = Xm([
  Km(0, Nt2)
], Vr);
function Jo(a2) {
  return a2 instanceof ie2 ? a2.getToken() === Rr : false;
}
function Zm(a2) {
  return a2 instanceof ie2 ? a2.getToken() === yo : false;
}
function Pa(a2, i, e) {
  const t = a2.getChildren(), r = t.length, n = t[0];
  for (let s = 0; s < r; s++) {
    const o = t[s];
    if (!(Jo(n) && s !== 0))
      if (o instanceof ie2)
        Pa(o, i, e);
      else {
        const u = o.trim();
        if (e.has(u)) {
          const c = new ie2();
          c.setToken(Xr), c.setLambdaId(i), c.setLambdaPrivacyVar(e), c.setLambdaParameter(u), t[s] = c;
        }
      }
  }
}
function zm(a2) {
  let i = a2;
  for (; i != null && i.getParent(); )
    i = i.getParent();
  return i;
}
function Bi(a2, i = 0, e = 0) {
  return {
    node: a2,
    refOffsetX: i,
    refOffsetY: e
  };
}
function eu(a2) {
  if (!a2)
    return;
  if (a2.getToken() !== Xr)
    return a2;
  const i = a2, e = i.getCurrentLambdaPrivacyVar(), t = i.getLambdaParameter();
  if (!e)
    return;
  const r = e.get(t);
  return r == null && a2.getValue() ? a2 : eu(r);
}
var xa = class _xa extends Qt {
  constructor(e, t, r) {
    super(0);
    A(this, "_lambdaPrivacyValueMap", /* @__PURE__ */ new Map());
    this._lambdaNode = e, this._interpreter = t, this._lambdaPrivacyVarKeys = r, this._lambdaPrivacyValueMap.clear();
  }
  static create(e, t, r) {
    return new _xa(e, t, r);
  }
  dispose() {
    this._lambdaPrivacyValueMap.clear(), this._lambdaPrivacyValueMap = /* @__PURE__ */ new Map(), this._lambdaNode = null, this._interpreter = null, this._lambdaPrivacyVarKeys = [];
  }
  isLambda() {
    return true;
  }
  execute(...e) {
    const t = this._lambdaPrivacyVarKeys.length;
    if (e.length !== t || !this._interpreter || !this._lambdaNode)
      return g2.create(h.VALUE);
    this._setLambdaPrivacyValueMap(e), this._setLambdaNodeValue(this._lambdaNode), this._lambdaNode.setNotEmpty(false);
    let r;
    if (this._interpreter.checkAsyncNode(this._lambdaNode))
      r = new Vm(this._interpreter.executeAsync(Bi(this._lambdaNode)));
    else {
      const n = this._interpreter.execute(Bi(this._lambdaNode));
      n.isReferenceObject() ? r = n.toArrayValueObject() : r = n;
    }
    return this._lambdaNode.setNotEmpty(true), r;
  }
  /**
   * Execute custom lambda function, handle basic types
   * @param variants
   */
  executeCustom(...e) {
    const t = e.map((r) => Pt.create(r));
    return this.execute(...t);
  }
  _setLambdaNodeValue(e) {
    if (!e)
      return;
    const t = e.getChildren(), r = t.length;
    for (let n = 0; n < r; n++) {
      const s = t[n];
      if (s.getToken() === Xr) {
        const u = s.getLambdaParameter(), c = this._lambdaPrivacyValueMap.get(u);
        if (c)
          s.setValue(c);
        else {
          const l = s.getCurrentLambdaPrivacyVar(), f2 = eu(l.get(u));
          f2 != null && s.setValue(f2.getValue());
        }
        continue;
      }
      this._setLambdaNodeValue(s);
    }
  }
  _setLambdaPrivacyValueMap(e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t], n = this._lambdaPrivacyVarKeys[t];
      this._lambdaPrivacyValueMap.set(n, r);
    }
  }
  getLambdaPrivacyVarKeys() {
    return this._lambdaPrivacyVarKeys;
  }
};
var Jm = Object.getOwnPropertyDescriptor;
var eh = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Jm(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var Fi = (a2, i) => (e, t) => i(e, t, a2);
var th = class extends qe {
  constructor(e, t, r, n, s) {
    super(e);
    A(this, "_isNotEmpty", true);
    this._lambdaId = t, this._interpreter = r, this._lambdaPrivacyVarKeys = n, this._runtimeService = s;
  }
  get nodeType() {
    return oe.LAMBDA;
  }
  setNotEmpty(e = false) {
    this._isNotEmpty = e;
  }
  isEmptyParamFunction() {
    return this.getChildren().length < 2 && this._isNotEmpty;
  }
  isFunctionParameter() {
    return this._lambdaId === null;
  }
  getLambdaId() {
    return this._lambdaId;
  }
  execute() {
    if (this.isEmptyParamFunction())
      this.setValue(xa.create(this, this._interpreter, this._lambdaPrivacyVarKeys));
    else {
      const e = this.getChildren(), t = e.length;
      this.setValue(e[t - 1].getValue());
    }
    this._runtimeService.setUnitArrayFormulaEmbeddedMap();
  }
  // override async executeAsync() {
  //     if (this.isEmptyParamFunction()) {
  //         await this.setValue(LambdaValueObjectObject.create(this, this._interpreter, this._lambdaPrivacyVarKeys));
  //     } else {
  //         const children = this.getChildren();
  //         const childrenCount = children.length;
  //         await this.setValue(children[childrenCount - 1].getValue());
  //     }
  //     return Promise.resolve(AstNodePromiseType.SUCCESS);
  // }
};
var Tn = class extends St {
  constructor(a2, i) {
    super(), this._runtimeService = a2, this._interpreter = i;
  }
  get zIndex() {
    return Vt.get(oe.LAMBDA) || Ot;
  }
  create(a2) {
    const i = a2.getChildren(), e = i[0];
    let t = i.slice(1, -1);
    const r = i[i.length - 1];
    if (!(e instanceof ie2 && r instanceof ie2))
      return Ue.create(h.NAME);
    if (e.getToken() === Rr) {
      const o = e.getChildren();
      if (t.length !== o.length)
        return Ue.create(h.VALUE);
    } else
      t = i.slice(0, -1);
    const n = et(8), s = /* @__PURE__ */ new Map();
    for (let o = 0; o < t.length; o++) {
      const u = t[o];
      if (u instanceof ie2) {
        const c = u.getChildren()[0];
        u.setToken(yo), s.set(c.trim(), void 0);
      } else
        return Ue.create(h.VALUE);
    }
    return this._runtimeService.registerFunctionDefinitionPrivacyVar(n, s), this._updateLambdaStatement(r, n, s), new th(a2.getToken(), n, this._interpreter, [...s.keys()], this._runtimeService);
  }
  checkAndCreateNodeType(a2) {
    if (!(!(a2 instanceof ie2) || a2.getToken().trim().toUpperCase() !== Fr))
      return this.create(a2);
  }
  _updateLambdaStatement(a2, i, e) {
    Pa(a2, i, e);
  }
};
Tn = eh([
  Fi(0, Nt2),
  Fi(1, Inject(Vr))
], Tn);
function tu(a2) {
  if (!a2)
    return;
  if (a2.getToken() !== Xr)
    return a2;
  const i = a2, e = i.getCurrentLambdaPrivacyVar(), t = i.getLambdaParameter();
  if (e)
    return tu(e.get(t));
}
var rh = class extends qe {
  constructor(i, e, t) {
    super(i), this._lambdaParameter = e, this._currentLambdaPrivacyVar = t;
  }
  getLambdaParameter() {
    return this._lambdaParameter;
  }
  getCurrentLambdaPrivacyVar() {
    return this._currentLambdaPrivacyVar;
  }
  get nodeType() {
    return oe.LAMBDA_PARAMETER;
  }
  execute() {
    const i = tu(this._currentLambdaPrivacyVar.get(this._lambdaParameter));
    if (i)
      this.setValue(i.getValue());
    else {
      const e = this.getValue();
      (e == null || e.isError()) && this.setValue(g2.create(h.NAME));
    }
  }
};
var ru = class extends St {
  get zIndex() {
    return Vt.get(oe.LAMBDA_PARAMETER) || Ot;
  }
  create(i) {
    const e = i.getFunctionDefinitionPrivacyVar(), t = i.getLambdaParameter();
    return e ? new rh(i.getToken(), t, e) : new Ue(h.NAME);
  }
  checkAndCreateNodeType(i) {
    if (!(!(i instanceof ie2) || i.getToken().trim() !== Xr))
      return this.create(i);
  }
};
var nh = class extends qe {
  constructor(i) {
    super(i), this._operatorString = i;
  }
  get nodeType() {
    return oe.NULL;
  }
  execute() {
    this.setValue(ce.create());
  }
};
var F = ((a2) => (a2.ABS = "ABS", a2.ACOS = "ACOS", a2.ACOSH = "ACOSH", a2.ACOT = "ACOT", a2.ACOTH = "ACOTH", a2.AGGREGATE = "AGGREGATE", a2.ARABIC = "ARABIC", a2.ASIN = "ASIN", a2.ASINH = "ASINH", a2.ATAN = "ATAN", a2.ATAN2 = "ATAN2", a2.ATANH = "ATANH", a2.BASE = "BASE", a2.CEILING = "CEILING", a2.CEILING_MATH = "CEILING.MATH", a2.CEILING_PRECISE = "CEILING.PRECISE", a2.COMBIN = "COMBIN", a2.COMBINA = "COMBINA", a2.COS = "COS", a2.COSH = "COSH", a2.COT = "COT", a2.COTH = "COTH", a2.CSC = "CSC", a2.CSCH = "CSCH", a2.DECIMAL = "DECIMAL", a2.DEGREES = "DEGREES", a2.EVEN = "EVEN", a2.EXP = "EXP", a2.FACT = "FACT", a2.FACTDOUBLE = "FACTDOUBLE", a2.FLOOR = "FLOOR", a2.FLOOR_MATH = "FLOOR.MATH", a2.FLOOR_PRECISE = "FLOOR.PRECISE", a2.GCD = "GCD", a2.INT = "INT", a2.ISO_CEILING = "ISO.CEILING", a2.LCM = "LCM", a2.LET = "LET", a2.LN = "LN", a2.LOG = "LOG", a2.LOG10 = "LOG10", a2.MDETERM = "MDETERM", a2.MINVERSE = "MINVERSE", a2.MMULT = "MMULT", a2.MOD = "MOD", a2.MROUND = "MROUND", a2.MULTINOMIAL = "MULTINOMIAL", a2.MUNIT = "MUNIT", a2.ODD = "ODD", a2.PI = "PI", a2.POWER = "POWER", a2.PRODUCT = "PRODUCT", a2.QUOTIENT = "QUOTIENT", a2.RADIANS = "RADIANS", a2.RAND = "RAND", a2.RANDARRAY = "RANDARRAY", a2.RANDBETWEEN = "RANDBETWEEN", a2.ROMAN = "ROMAN", a2.ROUND = "ROUND", a2.ROUNDBANK = "ROUNDBANK", a2.ROUNDDOWN = "ROUNDDOWN", a2.ROUNDUP = "ROUNDUP", a2.SEC = "SEC", a2.SECH = "SECH", a2.SERIESSUM = "SERIESSUM", a2.SEQUENCE = "SEQUENCE", a2.SIGN = "SIGN", a2.SIN = "SIN", a2.SINH = "SINH", a2.SQRT = "SQRT", a2.SQRTPI = "SQRTPI", a2.SUBTOTAL = "SUBTOTAL", a2.SUM = "SUM", a2.SUMIF = "SUMIF", a2.SUMIFS = "SUMIFS", a2.SUMPRODUCT = "SUMPRODUCT", a2.SUMSQ = "SUMSQ", a2.SUMX2MY2 = "SUMX2MY2", a2.SUMX2PY2 = "SUMX2PY2", a2.SUMXMY2 = "SUMXMY2", a2.TAN = "TAN", a2.TANH = "TANH", a2.TRUNC = "TRUNC", a2))(F || {});
var J2 = ((a2) => (a2.ASC = "ASC", a2.ARRAYTOTEXT = "ARRAYTOTEXT", a2.BAHTTEXT = "BAHTTEXT", a2.CHAR = "CHAR", a2.CLEAN = "CLEAN", a2.CODE = "CODE", a2.CONCAT = "CONCAT", a2.CONCATENATE = "CONCATENATE", a2.DBCS = "DBCS", a2.DOLLAR = "DOLLAR", a2.EXACT = "EXACT", a2.FIND = "FIND", a2.FINDB = "FINDB", a2.FIXED = "FIXED", a2.LEFT = "LEFT", a2.LEFTB = "LEFTB", a2.LEN = "LEN", a2.LENB = "LENB", a2.LOWER = "LOWER", a2.MID = "MID", a2.MIDB = "MIDB", a2.NUMBERSTRING = "NUMBERSTRING", a2.NUMBERVALUE = "NUMBERVALUE", a2.PHONETIC = "PHONETIC", a2.PROPER = "PROPER", a2.REGEXEXTRACT = "REGEXEXTRACT", a2.REGEXMATCH = "REGEXMATCH", a2.REGEXREPLACE = "REGEXREPLACE", a2.REPLACE = "REPLACE", a2.REPLACEB = "REPLACEB", a2.REPT = "REPT", a2.RIGHT = "RIGHT", a2.RIGHTB = "RIGHTB", a2.SEARCH = "SEARCH", a2.SEARCHB = "SEARCHB", a2.SUBSTITUTE = "SUBSTITUTE", a2.T = "T", a2.TEXT = "TEXT", a2.TEXTAFTER = "TEXTAFTER", a2.TEXTBEFORE = "TEXTBEFORE", a2.TEXTJOIN = "TEXTJOIN", a2.TEXTSPLIT = "TEXTSPLIT", a2.TRIM = "TRIM", a2.UNICHAR = "UNICHAR", a2.UNICODE = "UNICODE", a2.UPPER = "UPPER", a2.VALUE = "VALUE", a2.VALUETOTEXT = "VALUETOTEXT", a2.CALL = "CALL", a2.EUROCONVERT = "EUROCONVERT", a2.REGISTER_ID = "REGISTER.ID", a2))(J2 || {});
var sh = Object.getOwnPropertyDescriptor;
var ah = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? sh(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var ki = (a2, i) => (e, t) => i(e, t, a2);
var ih = class extends qe {
  constructor(i, e, t) {
    super(i), this._functionExecutor = e, this._runtimeService = t;
  }
  get nodeType() {
    return oe.OPERATOR;
  }
  execute() {
    const i = this.getChildren();
    this._functionExecutor.name === ke.COMPARE && this._functionExecutor.setCompareType(this.getToken());
    const e = i[0], t = i[1];
    let r = e == null ? void 0 : e.getValue(), n = t == null ? void 0 : t.getValue();
    const s = this.getToken();
    if ((r == null || n == null) && s !== Z3.MINUS && s !== Z3.PLUS) {
      this.setValue(g2.create(h.VALUE));
      return;
    }
    r == null && (r = ce.create()), n == null && (n = ce.create()), r.isReferenceObject() && (r = r.toArrayValueObject()), n.isReferenceObject() && (n = n.toArrayValueObject());
    const o = this._functionExecutor.calculate(
      r,
      n
    );
    this._setEmbeddedArrayFormulaToResult(o), this.setValue(o);
  }
  /**
   * If it contains an array formula, set the current cell to the cache and send itself as a ref outward
   */
  _setEmbeddedArrayFormulaToResult(i) {
    if (!i.isArray())
      return;
    const e = i.getRowCount(), t = i.getColumnCount();
    e <= 1 && t <= 1 || this._runtimeService.setUnitArrayFormulaEmbeddedMap();
  }
};
var In = class extends St {
  constructor(a2, i) {
    super(), this._functionService = a2, this._runtimeService = i;
  }
  get zIndex() {
    return Vt.get(oe.OPERATOR) || Ot;
  }
  create(a2) {
    let i = "";
    const e = a2;
    e === Z3.PLUS ? i = ke.PLUS : e === Z3.MINUS ? i = ke.MINUS : e === Z3.MULTIPLY ? i = ke.MULTIPLY : e === Z3.DIVIDED ? i = ke.DIVIDED : e === Z3.CONCATENATE ? i = J2.CONCATENATE : e === Z3.POWER ? i = F.POWER : Zc.has(e) && (i = ke.COMPARE);
    const t = this._functionService.getExecutor(i);
    return t ? new ih(e, t, this._runtimeService) : (console.error(`No function ${a2}`), Ue.create(h.NAME));
  }
  checkAndCreateNodeType(a2) {
    if (a2 instanceof ie2)
      return;
    const i = a2.trim();
    if (!(i.charAt(0) === '"' && i.charAt(i.length - 1) === '"') && Mt.has(i))
      return this.create(i);
  }
};
In = ah([
  ki(0, Xt),
  ki(1, Nt2)
], In);
var oh = class extends jr {
  constructor(e, t, r, n) {
    super(e);
    A(this, "_isCurrentRowForRange", false);
    this._tableData = t, this._columnDataString = r, this._tableOptionMap = n;
    const { sheetId: s, range: o, titleMap: u } = this._tableData;
    this.setForcedSheetIdDirect(s);
    const { startColumn: c, endColumn: l, type: f2 } = this._parseStructuredRef(this._columnDataString, u), m2 = o.startRow, d2 = o.endRow;
    let _2 = -1, C = -1;
    switch (f2) {
      case De.ALL:
        _2 = m2, C = d2;
        break;
      case De.DATA:
        _2 = m2 + 1, C = d2;
        break;
      case De.HEADERS:
        _2 = m2, C = m2;
        break;
      case De.TOTALS:
        _2 = d2, C = d2;
        break;
      case De.THIS_ROW: {
        const E = this._resolveThisRow(m2, d2);
        _2 = E, C = E;
        break;
      }
      default:
        _2 = m2 + 1, C = d2;
        break;
    }
    this.setRangeData({
      startColumn: c,
      endColumn: l,
      startRow: _2,
      endRow: C
    });
  }
  getRangeData() {
    const e = super.getRangeData();
    if (this._isCurrentRowForRange) {
      const { startRow: t, startColumn: r, endRow: n, endColumn: s } = e, o = this.getCurrentRow();
      return {
        startRow: o == null ? t : o,
        endRow: o == null ? n : o,
        startColumn: r,
        endColumn: s
      };
    }
    return e;
  }
  getRefOffset() {
    return {
      x: 0,
      y: 0
    };
  }
  isTable() {
    return true;
  }
  isCurrentRowForRange() {
    return this._isCurrentRowForRange;
  }
  setForcedSheetId(e) {
  }
  /**
   * Parse structured reference body, returning column range and Section type.
   * Determination rules:
   *  - Whether it's a Section depends on "whether it starts with # after stripping", not whether it still has brackets.
   *  - No comma: Either Section, or column/column range
   *  - Has comma: Left is Section, right is column/column range
   */
  _parseStructuredRef(e, t) {
    var C, E;
    const { range: r } = this._tableData, n = (C = r.startColumn) != null ? C : 0, s = (E = r.endColumn) != null ? E : 0;
    if (!e || e.trim().length === 0)
      return { startColumn: n, endColumn: s, type: De.DATA };
    const o = e.trim();
    if (o[0] !== "[") {
      const R = this._mapSection(o);
      if (R !== void 0)
        return { startColumn: n, endColumn: s, type: R };
      const { startColumn: b, endColumn: p2 } = this._parseColumnOrRange(o, t, n);
      return { startColumn: b, endColumn: p2, type: De.DATA };
    }
    const u = this._stripOuterBracketOnce(o), c = this._findCommaAtTopLevel(u);
    if (u.length === 0)
      return { startColumn: n, endColumn: s, type: De.DATA };
    if (c === -1) {
      if (u.startsWith("#")) {
        const p2 = this._mapSection(u);
        return p2 !== void 0 ? { startColumn: n, endColumn: s, type: p2 } : { startColumn: n, endColumn: s, type: De.DATA };
      }
      const { startColumn: R, endColumn: b } = this._parseColumnOrRange(u, t, n);
      return { startColumn: R, endColumn: b, type: De.DATA };
    }
    const l = u.slice(0, c).trim(), f2 = u.slice(c + 1).trim(), m2 = this._parseSectionMaybeBracketed(l), { startColumn: d2, endColumn: _2 } = this._parseColumnOrRange(f2, t, n);
    return { startColumn: d2, endColumn: _2, type: m2 };
  }
  /** Strip one layer of outer brackets from "[...]" (return as-is if none) */
  _stripOuterBracketOnce(e) {
    return e.length >= 2 && e[0] === "[" && e[e.length - 1] === "]" ? e.slice(1, -1) : e;
  }
  /**
   * Find first comma at depth=0 (used to split Section and column parts)
   * Compatible with nesting like "[[#Data],[ColA]:[ColB]]".
   */
  _findCommaAtTopLevel(e) {
    let t = 0;
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      if (n === "[") t++;
      else if (n === "]") t = Math.max(0, t - 1);
      else if (n === X2.COMMA && t === 0) return r;
    }
    return -1;
  }
  /**
   * Parse Section, compatible with both "[#Data]" and "#Data" inputs
   * Returns TableOptionType if matched; returns DATA if not (could throw error instead)
   */
  _parseSectionMaybeBracketed(e) {
    const t = e.trim(), r = t.startsWith("[") && t.endsWith("]") ? this._stripOuterBracketOnce(t) : t, n = this._mapSection(r);
    return n != null ? n : De.DATA;
  }
  /**
   * Section mapping: Only accepts keywords starting with #.
   * Returns undefined if not a valid Section (caller treats as column or fallback).
   */
  _mapSection(e) {
    const t = e.trim();
    if (!t.startsWith("#")) return;
    const r = this._tableOptionMap.get(t);
    if (r !== void 0) return r;
    const n = t.replace(/\s+/g, " ").toLowerCase();
    for (const [s, o] of this._tableOptionMap.entries())
      if (s.replace(/\s+/g, " ").toLowerCase() === n) return o;
  }
  /**
   * Parse column selection:
   * - "[Col]" / "Col"               => Single column
   * - "[[ColA]:[ColB]]" / "[ColA]:[ColB]" / "ColA:ColB"  => Column range
   *
   * Rules:
   * - First find colon at top level, strip one layer of brackets from left and right sides (if present)
   * - Returns -1 if column name not found (caller should handle as parse error)
   */
  _parseColumnOrRange(e, t, r) {
    const n = e.trim(), s = this._findColonAtTopLevel(n);
    if (s === -1) {
      const d2 = this._stripOuterBracketIfAny(n), _2 = this._titleToIndex(d2, t);
      return { startColumn: r + _2, endColumn: +r + _2 };
    }
    const o = n.slice(0, s).trim(), u = n.slice(s + 1).trim(), c = this._stripOuterBracketIfAny(o), l = this._stripOuterBracketIfAny(u), f2 = this._titleToIndex(c, t), m2 = this._titleToIndex(l, t);
    return f2 !== -1 && m2 !== -1 && f2 > m2 ? { startColumn: r + m2, endColumn: r + f2 } : { startColumn: r + f2, endColumn: r + m2 };
  }
  /** Strip one layer of outer brackets; return as-is if none (compatible with "[Col]" and "Col") */
  _stripOuterBracketIfAny(e) {
    return e.length >= 2 && e[0] === "[" && e[e.length - 1] === "]" ? e.slice(1, -1) : e;
  }
  /** Find range colon at depth=0 */
  _findColonAtTopLevel(e) {
    let t = 0;
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      if (n === "[") t++;
      else if (n === "]") t = Math.max(0, t - 1);
      else if (n === X2.COLON && t === 0) return r;
    }
    return -1;
  }
  /** Column title → column index; returns -1 if not found (caller should handle as parse error) */
  _titleToIndex(e, t) {
    var o;
    const r = e.trim(), n = t.get(r);
    if (n !== void 0) return n;
    const s = r.replace(/\u3000/g, " ").trim();
    return (o = t.get(s)) != null ? o : -1;
  }
  /** Resolve #This Row's row number; takes first data row (tableStartRow+1) when no context available */
  _resolveThisRow(e, t) {
    return this._isCurrentRowForRange = true, Math.min(e + 1, t);
  }
};
var uh = Object.getOwnPropertyDescriptor;
var ch = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? uh(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var un = (a2, i) => (e, t) => i(e, t, a2);
var $i = class extends qe {
  constructor(e, t, r, n, s = false, o) {
    super(r);
    A(this, "_refOffsetX", 0);
    A(this, "_refOffsetY", 0);
    this._currentConfigService = e, this._runtimeService = t, this._referenceObjectType = n, this._isPrepareMerge = s, this._tableReferenceObject = o;
  }
  get nodeType() {
    return oe.REFERENCE;
  }
  execute() {
    const e = this._currentConfigService, t = this._runtimeService, r = this._tableReferenceObject || Pm(this.getToken(), this._referenceObjectType);
    r.setDefaultUnitId(t.currentUnitId), r.setDefaultSheetId(t.currentSubUnitId), r.setForcedSheetId(e.getSheetNameMap()), r.setUnitData(e.getUnitData()), r.setArrayFormulaCellData(e.getArrayFormulaCellData()), r.setRuntimeData(t.getUnitData()), r.setUnitStylesData(e.getUnitStylesData()), r.setRuntimeArrayFormulaCellData(t.getRuntimeArrayFormulaCellData()), r.setRuntimeFeatureCellData(t.getRuntimeFeatureCellData());
    const n = t.currentRow, s = t.currentColumn;
    r.setCurrentRowAndColumn(n, s);
    const { x: o, y: u } = this.getRefOffset();
    r.setRefOffset(o, u), !this._isPrepareMerge && r.isExceedRange() ? this.setValue(g2.create(h.NAME)) : this.setValue(r);
  }
  setRefOffset(e = 0, t = 0) {
    this._refOffsetX = e, this._refOffsetY = t;
  }
  getRefOffset() {
    return {
      x: this._refOffsetX,
      y: this._refOffsetY
    };
  }
};
var Bn = class extends St {
  constructor(a2, i, e, t) {
    super(), this._currentConfigService = a2, this._formulaRuntimeService = i, this._functionService = e, this._superTableService = t;
  }
  get zIndex() {
    return Vt.get(oe.REFERENCE) || Ot;
  }
  checkAndCreateNodeType(a2) {
    var u, c;
    let i = false, e, t = false;
    a2 instanceof ie2 ? (i = true, e = a2.getToken().trim(), ((c = (u = a2.getParent()) == null ? void 0 : u.getParent()) == null ? void 0 : c.getToken().trim()) === X2.COLON && (t = true)) : e = a2.trim();
    const { tokenTrim: r, minusPrefixNode: n, atPrefixNode: s } = zo(e, this._functionService, this._formulaRuntimeService);
    if (!i && r.charAt(0) === '"' && r.charAt(r.length - 1) === '"')
      return;
    const o = this._getNode(r, i, t, a2);
    if (o)
      return s ? o.setParent(s) : n && o.setParent(n), o;
  }
  _getTableMap() {
    const a2 = this._currentConfigService.getExecuteUnitId();
    if (a2)
      return this._superTableService.getTableMap(a2);
  }
  _getNode(a2, i, e, t) {
    var d2;
    const r = this._currentConfigService, n = this._formulaRuntimeService, s = (_2) => new $i(r, n, a2, _2, e);
    if (qr(a2))
      return s(Tr.CELL);
    const u = i && this._checkParentIsUnionOperator(t);
    if (u && Eo(a2))
      return s(Tr.ROW);
    if (u && Ro(a2))
      return s(Tr.COLUMN);
    const f2 = this._getTableMap();
    return ((d2 = f2 == null ? void 0 : f2.has(a2)) != null ? d2 : false) ? this._getTableReferenceNode(a2, i, e, true) : this._getTableReferenceNode(a2, i, e, false);
  }
  _getTableReferenceNode(a2, i, e, t = false) {
    if (!this._checkTokenIsTableReference(a2) && !t)
      return;
    const { tableName: r, columnStruct: n } = this._splitTableStructuredRef(a2), s = this._getTableMap();
    if (!i && (s != null && s.has(r))) {
      const o = n, u = s.get(r), c = this._superTableService.getTableOptionMap();
      return new $i(
        this._currentConfigService,
        this._formulaRuntimeService,
        a2,
        Tr.COLUMN,
        e,
        new oh(a2, u, o, c)
      );
    }
  }
  _splitTableStructuredRef(a2) {
    const i = a2.indexOf("[");
    return i === -1 ? { tableName: a2, struct: "" } : {
      tableName: a2.slice(0, i),
      columnStruct: a2.slice(i)
      // 包含外层 [[...]]
    };
  }
  _checkTokenIsTableReference(a2) {
    return _l(a2) || Al(a2) || El(a2) || Rl(a2);
  }
  _checkParentIsUnionOperator(a2) {
    var i, e;
    return ((e = (i = a2.getParent()) == null ? void 0 : i.getParent()) == null ? void 0 : e.getToken().trim()) === X2.COLON;
  }
};
Bn = ch([
  un(0, Wt),
  un(1, Nt2),
  un(2, Xt),
  un(3, Pr)
], Bn);
var lh = Object.getOwnPropertyDescriptor;
var fh = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? lh(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var Ss = (a2, i) => (e, t) => i(e, t, a2);
var Yi = class extends qe {
  constructor(i, e, t, r) {
    super(t), this._currentConfigService = i, this._lexer = e, this._operatorString = t, this._functionExecutor = r;
  }
  get nodeType() {
    return oe.SUFFIX;
  }
  execute() {
    var r;
    let e = (r = this.getChildren()[0]) == null ? void 0 : r.getValue(), t;
    if (e == null) {
      this.setValue(g2.create(h.ERROR));
      return;
    }
    if (this._operatorString === nt.PERCENTAGE) {
      if (e.isReferenceObject() && (e = e.toArrayValueObject()), t = this._functionExecutor.calculate(
        e,
        y2.create(100)
      ), t.isNumber()) {
        const n = Number(t.getValue());
        t = y2.create(n, "0.00%");
      }
    } else this._operatorString === nt.POUND ? t = this._handlerPound(e) : t = g2.create(h.VALUE);
    this.setValue(t);
  }
  _handlerPound(i) {
    var u, c, l, f2;
    if (!i.isReferenceObject() || !i.isCell())
      return g2.create(h.VALUE);
    const e = i, t = e.getRangePosition(), r = e.getUnitId(), n = e.getSheetId(), s = this._currentConfigService.getFormulaData(), o = (f2 = (l = (c = (u = s == null ? void 0 : s[r]) == null ? void 0 : u[n]) == null ? void 0 : c[t.startRow]) == null ? void 0 : l[t.startColumn]) == null ? void 0 : f2.f;
    return o && this._lexer.treeBuilder(o), g2.create(h.VALUE);
  }
};
var Fn2 = class extends St {
  constructor(a2, i, e) {
    super(), this._functionService = a2, this._lexer = i, this._currentConfigService = e;
  }
  get zIndex() {
    return Vt.get(oe.SUFFIX) || Ot;
  }
  checkAndCreateNodeType(a2) {
    if (!(a2 instanceof ie2))
      return;
    const i = a2.getToken().trim();
    if (i.charAt(0) === '"' && i.charAt(i.length - 1) === '"')
      return;
    let e = "";
    if (i === nt.PERCENTAGE)
      e = ke.DIVIDED;
    else return i === nt.POUND ? new Yi(this._currentConfigService, this._lexer, i) : void 0;
    const t = this._functionService.getExecutor(e);
    return t ? new Yi(this._currentConfigService, this._lexer, i, t) : (console.error(`No function ${a2}`), Ue.create(h.NAME));
  }
};
Fn2 = fh([
  Ss(0, Xt),
  Ss(1, Inject(pr)),
  Ss(2, Wt)
], Fn2);
var mh = Object.getOwnPropertyDescriptor;
var hh = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? mh(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var gh = (a2, i) => (e, t) => i(e, t, a2);
var dh = class extends qe {
  constructor(i) {
    super(i);
  }
  get nodeType() {
    return oe.UNION;
  }
  execute() {
    const i = this.getChildren(), e = i[0], t = i[1], r = e.getValue(), n = t.getValue();
    if (r == null || n == null)
      throw new Error("leftNode and rightNode");
    let s;
    this.getToken() === X2.COLON ? s = this._unionFunction(r, n) : s = g2.create(h.NAME), this.setValue(s);
  }
  _unionFunction(i, e) {
    return i.isError() || e.isError() || !i.isReferenceObject() || !e.isReferenceObject() ? g2.create(h.REF) : (i = i, e = e, xm(i, e));
  }
};
var kn = class extends St {
  constructor(a2) {
    super(), this._functionService = a2;
  }
  get zIndex() {
    return Vt.get(oe.UNION) || Ot;
  }
  create(a2) {
    return new dh(a2);
  }
  checkAndCreateNodeType(a2) {
    if (!(a2 instanceof ie2))
      return;
    const e = a2.getToken().trim();
    if (!(e.charAt(0) === '"' && e.charAt(e.length - 1) === '"') && e === X2.COLON)
      return this.create(e);
  }
};
kn = hh([
  gh(0, Xt)
], kn);
var Ch = class extends qe {
  constructor(i) {
    super(i);
  }
  get nodeType() {
    return oe.VALUE;
  }
  execute() {
    var e, t, r;
    const i = ((e = this.getParent()) == null ? void 0 : e.nodeType) === oe.FUNCTION && ((r = (t = this.getParent()) == null ? void 0 : t.isFunctionExecutorArgumentsIgnoreNumberPattern) == null ? void 0 : r.call(t));
    this.setValue(Pt.create(this.getToken(), i));
  }
};
var nu = class extends St {
  get zIndex() {
    return Vt.get(oe.VALUE) || Ot;
  }
  _checkValueNode(i) {
    if (Number.isNaN(Number(i))) {
      const e = i.trim(), t = e.charAt(0), r = e.charAt(e.length - 1);
      if (fr.has(e))
        return this.create(e);
      if (t === '"' && r === '"')
        return this.create(e);
      if (t === "{" && r === "}")
        return this.create(e);
      const n = e.toUpperCase();
      if (n === ir.TRUE || n === ir.FALSE)
        return this.create(n);
    } else
      return this.create(i);
  }
  create(i) {
    return new Ch(i);
  }
  checkAndCreateNodeType(i) {
    if (!(i instanceof ie2))
      return this._checkValueNode(i);
  }
};
var _h = Object.getOwnPropertyDescriptor;
var Ah = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? _h(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var lt = (a2, i) => (e, t) => i(e, t, a2);
var Gr = class extends Ve {
  constructor(i, e, t, r, n, s, o, u, c, l, f2) {
    super();
    A(this, "_astNodeFactoryList", []);
    this._runtimeService = i, this._astRootNodeFactory = e, this._functionNodeFactory = t, this._lambdaNodeFactory = r, this._lambdaParameterNodeFactory = n, this._operatorNodeFactory = s, this._prefixNodeFactory = o, this._referenceNodeFactory = u, this._suffixNodeFactory = c, this._unionNodeFactory = l, this._valueNodeFactory = f2, this._initializeAstNode();
  }
  dispose() {
    this._astNodeFactoryList.forEach((i) => {
      i.dispose();
    }), this._astNodeFactoryList = [];
  }
  parse(i) {
    const e = new na(Ft), t = this._parse(i, e);
    return i.hasDefinedNames() && (t == null || t.setDefinedNames(i.getDefinedNames())), t;
  }
  _lambdaParameterHandler(i, e) {
    if (e.getLambdaId == null)
      return Ue.create(h.VALUE);
    const t = e.getLambdaId(), r = new na(Ft), n = this._runtimeService.getFunctionDefinitionPrivacyVar(t);
    if (!n)
      return false;
    const s = [...n.keys()], o = i.getChildren(), u = o.length;
    for (let c = 0; c < u; c++) {
      const l = o[c];
      if (l instanceof ie2) {
        Pa(l, t, n), this._parse(l, r);
        const m2 = r.getChildren()[c];
        m2 != null && n.set(s[c], m2);
      } else
        return false;
    }
    return r.setParent(e), e;
  }
  _changeLetToLambda(i) {
    const e = i.getChildren(), t = e.length;
    if (t % 2 !== 1 || t === 0)
      return;
    const r = new ie2();
    r.setToken(Fr);
    const n = new ie2();
    n.setToken(Rr);
    const s = [...e];
    for (let u = 0; u < t; u++) {
      const c = s[u];
      if (!(c instanceof ie2))
        return;
      u % 2 === 0 ? c.changeToParent(r) : c.changeToParent(n);
    }
    r.addChildrenFirst(n), n.setParent(r);
    const o = i.getParent();
    return o == null || o.replaceChild(i, r), r;
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _parse(i, e) {
    var l;
    const t = i.getChildren(), r = t.length, n = [];
    let s = null;
    const o = i.getToken().trim().toUpperCase();
    if (o === Nl) {
      const f2 = this._changeLetToLambda(i);
      return f2 != null ? this._parse(f2, e) : Ue.create(h.ERROR);
    }
    if (o === At) {
      if (s = e, r === 0)
        return new nh(Ft).setParent(e), s;
    } else {
      if (o === Rr) {
        let f2 = this._lambdaParameterHandler(i, e);
        return f2 === false && (f2 = Ue.create(h.ERROR)), f2;
      }
      if (s = this._checkAstNode(i), s == null)
        return Ue.create(h.NAME);
    }
    const u = t[0];
    for (let f2 = 0; f2 < r; f2++) {
      const m2 = t[f2];
      if (Jo(u)) {
        if (f2 !== 0 && f2 !== r - 1)
          continue;
      } else if (Zm(m2) && f2 !== r - 1)
        continue;
      let d2 = null;
      if (m2 instanceof ie2) {
        if (m2.getToken() === At && m2.getChildren().length === 0) {
          const _2 = (l = m2.getParent()) == null ? void 0 : l.getChildren();
          if (_2 && _2.length === 1)
            return Ue.create(h.NAME);
        }
        if (d2 = this._parse(m2, s), d2 === s)
          continue;
      } else
        d2 = this._checkAstNode(m2);
      if (d2 == null)
        return Ue.create(h.NAME);
      if (d2 = zm(d2), d2 == null || (d2 == null ? void 0 : d2.nodeType) === oe.ERROR)
        return d2;
      switch (d2.nodeType) {
        case oe.FUNCTION: {
          const _2 = d2.getToken().trim().toUpperCase();
          Ol.has(_2) && d2.setForcedCalculateFunction(), n.push(d2);
          break;
        }
        case oe.LAMBDA:
          n.push(d2);
          break;
        case oe.LAMBDA_PARAMETER:
          n.push(d2);
          break;
        case oe.OPERATOR: {
          const _2 = n.pop(), C = n.pop();
          C && C.setParent(d2), _2 && _2.setParent(d2), n.push(d2);
          break;
        }
        case oe.REFERENCE:
          n.push(d2);
          break;
        case oe.ROOT:
          n.push(d2);
          break;
        case oe.UNION:
          n.push(d2);
          break;
        case oe.VALUE:
          n.push(d2);
          break;
        case oe.PREFIX:
          n.push(d2);
          break;
        case oe.SUFFIX:
          n.push(d2);
          break;
      }
    }
    const c = n.length;
    for (let f2 = 0; f2 < c; f2++)
      n[f2].setParent(s);
    return s;
  }
  // private _setPrefixRefOffset(astNode: BaseAstNode) {
  //     const children = astNode.getChildren();
  //     const childrenCount = children.length;
  //     for (let i = 0; i < childrenCount; i++) {
  //         const item = children[i];
  //         if (item.nodeType === NodeType.REFERENCE) {
  //             item.setRefOffset(this._refOffsetX, this._refOffsetY);
  //         }
  //     }
  // }
  _checkAstNode(i) {
    let e = null;
    const t = this._astNodeFactoryList.length;
    for (let r = 0; r < t && (e = this._astNodeFactoryList[r].checkAndCreateNodeType(i), e == null); r++)
      ;
    return e == null ? new Qm() : e;
  }
  _initializeAstNode() {
    this._astNodeFactoryList = [
      this._astRootNodeFactory,
      this._functionNodeFactory,
      this._lambdaNodeFactory,
      this._lambdaParameterNodeFactory,
      this._operatorNodeFactory,
      this._prefixNodeFactory,
      this._referenceNodeFactory,
      this._suffixNodeFactory,
      this._unionNodeFactory,
      this._valueNodeFactory
    ].sort(y1);
  }
};
Gr = Ah([
  lt(0, Nt2),
  lt(1, Inject(Ko)),
  lt(2, Inject(vn)),
  lt(3, Inject(Tn)),
  lt(4, Inject(ru)),
  lt(5, Inject(In)),
  lt(6, Inject(Un)),
  lt(7, Inject(Bn)),
  lt(8, Inject(Fn2)),
  lt(9, Inject(kn)),
  lt(10, Inject(nu))
], Gr);
var Eh = class extends Ve {
  constructor() {
    super(...arguments);
    A(this, "_otherFormulaData", /* @__PURE__ */ new Map());
    A(this, "_featureFormulaData", /* @__PURE__ */ new Map());
    A(this, "_formulaData", /* @__PURE__ */ new Map());
    A(this, "_definedNameMap", /* @__PURE__ */ new Map());
    A(this, "_otherFormulaDataMainData", /* @__PURE__ */ new Set());
    A(this, "_dependencyRTreeCache", new aI());
    A(this, "_dependencyTreeIdLast", 0);
  }
  buildDependencyTree(e, t) {
    throw new Error("Method not implemented.");
  }
  getTreeById(e) {
    throw new Error("Method not implemented.");
  }
  getAllTree() {
    throw new Error("Method not implemented.");
  }
  reset() {
    throw new Error("Method not implemented.");
  }
  addOtherFormulaDependency(e, t, r, n) {
    throw new Error("Method not implemented.");
  }
  removeOtherFormulaDependency(e, t, r) {
    throw new Error("Method not implemented.");
  }
  clearOtherFormulaDependency(e, t) {
    throw new Error("Method not implemented.");
  }
  addFeatureFormulaDependency(e, t, r, n) {
    throw new Error("Method not implemented.");
  }
  removeFeatureFormulaDependency(e, t, r) {
    throw new Error("Method not implemented.");
  }
  clearFeatureFormulaDependency(e, t) {
    throw new Error("Method not implemented.");
  }
  addFormulaDependency(e, t, r, n, s) {
    throw new Error("Method not implemented.");
  }
  removeFormulaDependency(e, t, r, n) {
    throw new Error("Method not implemented.");
  }
  clearFormulaDependency(e, t) {
    throw new Error("Method not implemented.");
  }
  removeFormulaDependencyByDefinedName(e, t) {
    throw new Error("Method not implemented.");
  }
  searchDependency(e, t) {
    return this._dependencyRTreeCache.bulkSearch(e, t);
  }
  _restDependencyTreeId() {
    this._dependencyTreeIdLast = 0;
  }
  getOtherFormulaDependency(e, t, r) {
    var n, s;
    return (s = (n = this._otherFormulaData.get(e)) == null ? void 0 : n.get(t)) == null ? void 0 : s.get(r);
  }
  addOtherFormulaDependencyMainData(e) {
    this._otherFormulaDataMainData.add(e);
  }
  hasOtherFormulaDataMainData(e) {
    return this._otherFormulaDataMainData.has(e);
  }
  _removeDependencyRTreeCacheById(e, t) {
    this._dependencyRTreeCache.removeById(e, t);
  }
  getFeatureFormulaDependency(e, t, r) {
    var n, s;
    return (s = (n = this._featureFormulaData.get(e)) == null ? void 0 : n.get(t)) == null ? void 0 : s.get(r);
  }
  getFormulaDependency(e, t, r, n) {
    var s, o;
    return (o = (s = this._formulaData.get(e)) == null ? void 0 : s.get(t)) == null ? void 0 : o.getValue(r, n);
  }
  addDependencyRTreeCache(e) {
    const t = [];
    for (let r = 0; r < e.rangeList.length; r++) {
      const n = e.rangeList[r], { unitId: s, sheetId: o, range: u } = n;
      t.push({
        unitId: s,
        sheetId: o,
        range: u,
        id: e.treeId
      });
    }
    this._dependencyRTreeCache.bulkInsert(t), this._addAllTreeMap(e);
  }
  getLastTreeId() {
    const e = this._dependencyTreeIdLast;
    return this._dependencyTreeIdLast++, e;
  }
  _addAllTreeMap(e) {
    throw new Error("Method not implemented.");
  }
  _addDefinedName(e, t, r) {
    this._definedNameMap.has(e) || this._definedNameMap.set(e, /* @__PURE__ */ new Map());
    const n = this._definedNameMap.get(e);
    n.has(t) || n.set(t, /* @__PURE__ */ new Set()), n.get(t).add(r);
  }
  addFormulaDependencyByDefinedName(e, t) {
    const r = e.treeId, n = (t == null ? void 0 : t.getDefinedNames()) || [];
    for (const s of n)
      this._addDefinedName(e.unitId, s, r);
  }
};
var Rh = class extends Eh {
  constructor() {
    super(...arguments);
    A(this, "_allTreeMap", /* @__PURE__ */ new Map());
  }
  dispose() {
    super.dispose(), this.reset();
  }
  buildDependencyTree(e, t = []) {
    const r = this.getAllTree();
    return e.length === 0 ? (this._buildReverseDependency(r, t), r) : (this._buildDependencyTree(r, e), this._buildReverseDependency(r, e), r);
  }
  /**
   * Build the dependency relationship between the trees.
   * @param allTrees  all FormulaDependencyTree
   * @param shouldBeBuildTrees  FormulaDependencyTree[] | FormulaDependencyTreeCache
   */
  _buildDependencyTree(e, t) {
    const r = /* @__PURE__ */ new Map();
    for (let n = 0; n < t.length; n++) {
      const s = t[n];
      r.set(s.treeId, s);
    }
    for (let n = 0; n < e.length; n++) {
      const s = e[n], o = s.toRTreeItem(), u = this._dependencyRTreeCache.bulkSearch(o);
      for (const c of u) {
        const l = r.get(c);
        l && s !== l && !l.hasChildren(s.treeId) && l.pushChildren(s);
      }
    }
    r.clear();
  }
  /**
   * Build the reverse dependency relationship between the trees.
   * @param allTrees
   * @param dependencyTrees
   */
  _buildReverseDependency(e, t) {
    const r = /* @__PURE__ */ new Map();
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      r.set(s.treeId, s);
    }
    for (let n = 0; n < t.length; n++) {
      const s = t[n], o = s.toRTreeItem(), u = this._dependencyRTreeCache.bulkSearch(o);
      for (const c of u) {
        const l = r.get(c);
        l && s !== l && !l.hasChildren(s.treeId) && l.pushChildren(s);
      }
    }
    r.clear();
  }
  /**
   * Get all FormulaDependencyTree from _otherFormulaData, _featureFormulaData, _formulaData
   * return FormulaDependencyTree[]
   */
  getAllTree() {
    const e = [];
    return this._allTreeMap.forEach((t) => {
      t.resetState(), e.push(t);
    }), e;
  }
  getTreeById(e) {
    return this._allTreeMap.get(e);
  }
  reset() {
    this._otherFormulaData.clear(), this._featureFormulaData.clear(), this._formulaData.clear(), this._definedNameMap.clear(), this._otherFormulaDataMainData.clear(), this._dependencyRTreeCache.clear(), this._allTreeMap.clear(), this._restDependencyTreeId();
  }
  addOtherFormulaDependency(e, t, r, n) {
    this._otherFormulaData.has(e) || this._otherFormulaData.set(e, /* @__PURE__ */ new Map());
    const s = this._otherFormulaData.get(e);
    s.has(t) || s.set(t, /* @__PURE__ */ new Map());
    const o = s.get(t);
    o.has(r) || o.set(r, new ht()), o.get(r).setValue(n.refOffsetX, n.refOffsetY, n.treeId), this._addAllTreeMap(n);
  }
  removeOtherFormulaDependency(e, t, r) {
    const n = this._otherFormulaData.get(e);
    if (n && n.has(t)) {
      const s = n.get(t);
      r.forEach((o) => {
        const u = s.get(o);
        u != null && (u.forValue((c, l, f2) => {
          this._removeDependencyRTreeCache(f2), this.clearDependencyForTree(this._allTreeMap.get(f2)), this._removeAllTreeMap(f2);
        }), s.delete(o), this._otherFormulaDataMainData.delete(o));
      }), s.size === 0 && n.delete(t), n.size === 0 && this._otherFormulaData.delete(e);
    }
  }
  clearOtherFormulaDependency(e, t) {
    const r = this._otherFormulaData.get(e);
    if (t && r && r.has(t)) {
      const n = r.get(t);
      this._removeDependencyRTreeCacheById(e, t);
      for (const s of n.keys()) {
        const o = n.get(s);
        o != null && (o.forValue((u, c, l) => {
          const f2 = this._allTreeMap.get(l);
          f2 && (this.clearDependencyForTree(f2), this._removeAllTreeMap(l));
        }), this._otherFormulaDataMainData.delete(s));
      }
      n.clear();
    } else if (r) {
      for (const n of r.keys()) {
        const s = r.get(n);
        this._removeDependencyRTreeCacheById(e, n);
        for (const o of s.keys()) {
          const u = s.get(o);
          u != null && (u.forValue((c, l, f2) => {
            const m2 = this._allTreeMap.get(f2);
            m2 && (this.clearDependencyForTree(m2), this._removeAllTreeMap(f2));
          }), this._otherFormulaDataMainData.delete(o));
        }
      }
      this._otherFormulaData.delete(e);
    }
  }
  addFeatureFormulaDependency(e, t, r, n) {
    this._featureFormulaData.has(e) || this._featureFormulaData.set(e, /* @__PURE__ */ new Map());
    const s = this._featureFormulaData.get(e);
    s.has(t) || s.set(t, /* @__PURE__ */ new Map()), s.get(t).set(r, n.treeId), this._addAllTreeMap(n);
  }
  removeFeatureFormulaDependency(e, t, r) {
    const n = this._featureFormulaData.get(e);
    if (n && n.has(t)) {
      const s = n.get(t);
      r.forEach((o) => {
        const u = s.get(o);
        u != null && (this._removeDependencyRTreeCache(u), s.delete(o), this.clearDependencyForTree(this._allTreeMap.get(u)), this._removeAllTreeMap(u));
      });
    }
  }
  clearFeatureFormulaDependency(e, t) {
    const r = this._featureFormulaData.get(e);
    if (t && r && r.has(t)) {
      const n = r.get(t);
      this._removeDependencyRTreeCacheById(e, t), n.forEach((s) => {
        s != null && (this.clearDependencyForTree(this._allTreeMap.get(s)), this._removeAllTreeMap(s));
      }), n.clear();
    } else r && (r.forEach((n, s) => {
      this._removeDependencyRTreeCacheById(e, s), n.forEach((o) => {
        o != null && (this.clearDependencyForTree(this._allTreeMap.get(o)), this._removeAllTreeMap(o));
      });
    }), this._featureFormulaData.delete(e));
  }
  addFormulaDependency(e, t, r, n, s) {
    this._formulaData.has(e) || this._formulaData.set(e, /* @__PURE__ */ new Map());
    const o = this._formulaData.get(e);
    o.has(t) || o.set(t, new ht()), o.get(t).setValue(r, n, s.treeId), this._addAllTreeMap(s);
  }
  removeFormulaDependency(e, t, r, n) {
    const s = this._formulaData.get(e);
    if (s && s.has(t)) {
      const o = s.get(t), u = o.getValue(r, n);
      if (u == null)
        return;
      this._removeDependencyRTreeCache(u), o.realDeleteValue(r, n), this.clearDependencyForTree(this._allTreeMap.get(u)), this._removeAllTreeMap(u);
    }
  }
  clearFormulaDependency(e, t) {
    const r = this._formulaData.get(e);
    if (t && r && r.has(t)) {
      const n = r.get(t);
      this._removeDependencyRTreeCacheById(e, t), n.forValue((s, o, u) => {
        if (u == null)
          return true;
        this.clearDependencyForTree(this._allTreeMap.get(u)), this._removeAllTreeMap(u);
      }), n.reset();
    } else r && (r.forEach((n, s) => {
      this._removeDependencyRTreeCacheById(e, s), n.forValue((o, u, c) => {
        if (c == null)
          return true;
        this.clearDependencyForTree(this._allTreeMap.get(c)), this._removeAllTreeMap(c);
      });
    }), this._formulaData.delete(e));
  }
  /**
   * Clear the dependency relationship of the tree.
   * establish the relationship between the parent and the child.
   * @param shouldBeClearTree
   */
  clearDependencyForTree(e) {
    if (e == null)
      return;
    const t = e.parents, r = e.children, n = this._allTreeMap;
    for (const s of t) {
      const o = n.get(s);
      o == null || o.children.delete(e.treeId);
    }
    for (const s of r) {
      const o = n.get(s);
      o == null || o.parents.delete(e.treeId);
    }
    e.dispose();
  }
  _removeDependencyRTreeCache(e) {
    if (e == null)
      return;
    const t = this._allTreeMap.get(e);
    if (t) {
      const r = [];
      for (let n = 0; n < t.rangeList.length; n++) {
        const s = t.rangeList[n], { unitId: o, sheetId: u, range: c } = s;
        r.push({
          unitId: o,
          sheetId: u,
          range: c,
          id: e
        });
      }
      this._dependencyRTreeCache.bulkRemove(r);
    }
  }
  removeFormulaDependencyByDefinedName(e, t) {
    const r = this._definedNameMap.get(e);
    if (r) {
      const n = r.get(t);
      if (n) {
        for (const s of n)
          this._removeDependencyRTreeCache(s), this.clearDependencyForTree(this._allTreeMap.get(s)), this._removeAllTreeMap(s);
        n.clear();
      }
    }
  }
  _removeAllTreeMap(e) {
    e != null && this._allTreeMap.delete(e);
  }
  _addAllTreeMap(e) {
    this._allTreeMap.set(e.treeId, e);
  }
};
var cs = createIdentifier(
  "univer.formula.dependency-manager.service"
);
var bh = class extends Ve {
  constructor() {
    super(...arguments);
    A(this, "_referenceExecutorMap", /* @__PURE__ */ new Map());
    A(this, "_onChanged$", new Subject());
    A(this, "onChanged$", this._onChanged$.asObservable());
  }
  dispose() {
    super.dispose(), this._referenceExecutorMap.clear(), this._onChanged$.complete();
  }
  remove(e, t, r) {
    r.forEach((n) => {
      var s, o;
      (o = (s = this._referenceExecutorMap.get(e)) == null ? void 0 : s.get(t)) == null || o.delete(n);
    }), this._onChanged$.next({
      unitId: e,
      subUnitId: t,
      featureIds: r
    });
  }
  get(e, t, r) {
    var n, s;
    return (s = (n = this._referenceExecutorMap.get(e)) == null ? void 0 : n.get(t)) == null ? void 0 : s.get(r);
  }
  has(e, t, r) {
    var n, s;
    return !!((s = (n = this._referenceExecutorMap.get(e)) == null ? void 0 : n.get(t)) != null && s.has(r));
  }
  register(e, t, r, n) {
    let s = this._referenceExecutorMap.get(e);
    s || (s = /* @__PURE__ */ new Map(), this._referenceExecutorMap.set(e, s));
    let o = s.get(t);
    o || (o = /* @__PURE__ */ new Map(), s.set(t, o)), this._onChanged$.next({
      unitId: e,
      subUnitId: t,
      featureIds: [r]
    }), o.set(r, n);
  }
  getReferenceExecutorMap() {
    return this._referenceExecutorMap;
  }
};
var Wr = createIdentifier(
  "univer.formula.feature-calculation-manager.service"
);
var yh = class extends Ve {
  constructor() {
    super(...arguments);
    A(this, "_otherFormulaData", {});
  }
  dispose() {
    super.dispose(), this._otherFormulaData = {};
  }
  remove(e) {
    var s, o, u;
    const { unitId: t, subUnitId: r, formulaId: n } = e;
    (u = (o = (s = this._otherFormulaData) == null ? void 0 : s[t]) == null ? void 0 : o[r]) == null || delete u[n];
  }
  get(e) {
    var s, o;
    const { unitId: t, subUnitId: r, formulaId: n } = e;
    return (o = (s = this._otherFormulaData[t]) == null ? void 0 : s[r]) == null ? void 0 : o[n];
  }
  has(e) {
    var s, o;
    const { unitId: t, subUnitId: r, formulaId: n } = e;
    return ((o = (s = this._otherFormulaData[t]) == null ? void 0 : s[r]) == null ? void 0 : o[n]) != null;
  }
  register(e) {
    const { unitId: t, subUnitId: r, formulaId: n, item: s } = e;
    this._otherFormulaData[t] || (this._otherFormulaData[t] = {}), this._otherFormulaData[t][r] || (this._otherFormulaData[t][r] = {}), this._otherFormulaData[t][r][n] = s;
  }
  batchRegister(e) {
    Object.keys(e).forEach((t) => {
      const r = e[t];
      if (r == null)
        return true;
      Object.keys(r).forEach((n) => {
        const s = r[n];
        if (s == null)
          return true;
        Object.keys(s).forEach((o) => {
          const u = s[o];
          if (u == null)
            return true;
          this.register({
            unitId: t,
            subUnitId: n,
            formulaId: o,
            item: u
          });
        });
      });
    });
  }
  batchRemove(e) {
    Object.keys(e).forEach((t) => {
      const r = e[t];
      if (r == null)
        return true;
      Object.keys(r).forEach((n) => {
        const s = r[n];
        if (s == null)
          return true;
        Object.keys(s).forEach((o) => {
          this.remove({
            unitId: t,
            subUnitId: n,
            formulaId: o
          });
        });
      });
    });
  }
  getOtherFormulaData() {
    return this._otherFormulaData;
  }
};
var ja = createIdentifier(
  "univer.formula.other-formula-manager.service"
);
var sa = ((a2) => (a2[a2.NORMAL_FORMULA = 0] = "NORMAL_FORMULA", a2[a2.OTHER_FORMULA = 1] = "OTHER_FORMULA", a2[a2.FEATURE_FORMULA = 2] = "FEATURE_FORMULA", a2))(sa || {});
var su = class {
  constructor() {
    A(this, "_state", 0);
    A(this, "treeId");
    A(this, "children", /* @__PURE__ */ new Set());
    A(this, "parents", /* @__PURE__ */ new Set());
  }
  resetState() {
    this._state = 0;
  }
  setAdded() {
    this._state = 1;
  }
  isAdded() {
    return this._state === 1;
  }
  setSkip() {
    this._state = 2;
  }
  isSkip() {
    return this._state === 2;
  }
  pushChildren(i) {
    this.children.add(i.treeId), i._pushParent(this);
  }
  hasChildren(i) {
    return this.children.has(i);
  }
  _pushParent(i) {
    this.parents.add(i.treeId);
  }
};
var Hi = class extends su {
  constructor() {
    super(...arguments);
    A(this, "refTree");
    A(this, "refOffsetX", -1);
    A(this, "refOffsetY", -1);
    A(this, "isCache", false);
    A(this, "isDirty", false);
    A(this, "addressFunctionNodes", []);
    A(this, "getDirtyData");
    A(this, "featureId");
  }
  get isVirtual() {
    return true;
  }
  get row() {
    return this.refTree == null ? -1 : this.refTree.row + this.refOffsetY;
  }
  get column() {
    return this.refTree == null ? -1 : this.refTree.column + this.refOffsetX;
  }
  get rowCount() {
    return this.refTree == null ? 0 : this.refTree.rowCount;
  }
  get columnCount() {
    return this.refTree == null ? 0 : this.refTree.columnCount;
  }
  get unitId() {
    return this.refTree == null ? "" : this.refTree.unitId;
  }
  get subUnitId() {
    return this.refTree == null ? "" : this.refTree.subUnitId;
  }
  get formula() {
    var e, t;
    return (t = (e = this.refTree) == null ? void 0 : e.formula) != null ? t : "";
  }
  get nodeData() {
    return {
      node: this.node,
      refOffsetX: this.refOffsetX,
      refOffsetY: this.refOffsetY
    };
  }
  get node() {
    var e;
    return (e = this.refTree) == null ? void 0 : e.node;
  }
  dispose() {
    this.refTree = null;
  }
  get rangeList() {
    const e = [];
    if (this.refTree == null)
      return [];
    for (let t = 0; t < this.refTree.rangeList.length; t++) {
      const r = this.refTree.rangeList[t];
      e.push({
        unitId: r.unitId,
        sheetId: r.sheetId,
        range: w1(r.range, this.refOffsetX, this.refOffsetY)
      });
    }
    return e;
  }
  toRTreeItem() {
    const e = this.row, t = this.column;
    return [{
      unitId: this.unitId,
      sheetId: this.subUnitId,
      range: {
        startRow: e,
        startColumn: t,
        endRow: e,
        endColumn: t
      }
    }];
  }
  inRangeData(e) {
    const t = e.startRow, r = e.startColumn, n = e.endRow, s = e.endColumn, o = this.row, u = this.column;
    return !(o < t || o > n || u < r || u > s);
  }
  dependencySheetName(e) {
    return this.refTree == null ? false : this.refTree.dependencySheetName(e);
  }
  isExcludeRange(e) {
    var r;
    const t = this.rangeList;
    if (t.length === 0)
      return false;
    for (let n = 0, s = t.length; n < s; n++) {
      const o = t[n], { unitId: u, sheetId: c, range: l } = o, f2 = (r = e == null ? void 0 : e[u]) == null ? void 0 : r[c];
      let { startRow: m2, endRow: d2, startColumn: _2, endColumn: C } = l;
      Number.isNaN(m2) && (m2 = 0), Number.isNaN(_2) && (_2 = 0), Number.isNaN(d2) && (d2 = Number.POSITIVE_INFINITY), Number.isNaN(C) && (C = Number.POSITIVE_INFINITY);
      let E = false;
      if (f2 == null || f2.forValue((R, b) => {
        if (R >= m2 && R <= d2 && b >= _2 && b <= C)
          return E = true, false;
      }), E)
        return true;
    }
    return false;
  }
  get formulaId() {
    return this.refTree == null ? "" : this.refTree.formulaId;
  }
};
var Ms = class extends su {
  constructor(e) {
    super();
    A(this, "isCache", false);
    A(this, "featureId");
    A(this, "featureDirtyRanges", []);
    A(this, "refOffsetX", 0);
    A(this, "refOffsetY", 0);
    A(this, "type", 0);
    A(this, "formulaId");
    A(this, "subUnitId", "");
    A(this, "unitId", "");
    A(this, "rangeList", []);
    A(this, "formula", "");
    A(this, "row", -1);
    A(this, "column", -1);
    A(this, "rowCount", Number.NEGATIVE_INFINITY);
    A(this, "columnCount", Number.NEGATIVE_INFINITY);
    A(this, "isDirty", false);
    A(this, "node");
    A(this, "addressFunctionNodes", []);
    A(this, "getDirtyData");
    this.treeId = e;
  }
  get isVirtual() {
    return false;
  }
  get nodeData() {
    return {
      node: this.node,
      refOffsetX: 0,
      refOffsetY: 0
    };
  }
  toJson() {
    return {
      formula: this.formula,
      refOffsetX: this.refOffsetX,
      refOffsetY: this.refOffsetY
    };
  }
  dispose() {
    this.featureDirtyRanges = [], this.rangeList = [], this.addressFunctionNodes = [], this.getDirtyData = null;
  }
  inRangeData(e) {
    const t = e.startRow, r = e.startColumn, n = e.endRow, s = e.endColumn, o = this.row, u = this.column;
    return !(o < t || o > n || u < r || u > s);
  }
  dependencySheetName(e) {
    var r;
    const t = this.rangeList;
    if (t.length === 0 || e == null)
      return false;
    for (let n = 0, s = t.length; n < s; n++) {
      const o = t[n], { unitId: u, sheetId: c } = o;
      if (((r = e[u]) == null ? void 0 : r[c]) != null)
        return true;
    }
    return false;
  }
  isExcludeRange(e) {
    var r;
    const t = this.rangeList;
    if (t.length === 0)
      return false;
    for (let n = 0, s = t.length; n < s; n++) {
      const o = t[n], { unitId: u, sheetId: c, range: l } = o, f2 = (r = e == null ? void 0 : e[u]) == null ? void 0 : r[c];
      let { startRow: m2, endRow: d2, startColumn: _2, endColumn: C } = l;
      Number.isNaN(m2) && (m2 = 0), Number.isNaN(_2) && (_2 = 0), Number.isNaN(d2) && (d2 = Number.POSITIVE_INFINITY), Number.isNaN(C) && (C = Number.POSITIVE_INFINITY);
      let E = false;
      if (f2 == null || f2.forValue((R, b) => {
        if (R >= m2 && R <= d2 && b >= _2 && b <= C)
          return E = true, false;
      }), E)
        return true;
    }
    return false;
  }
  // pushChildren(tree: FormulaDependencyTree) {
  //     this.children.add(tree.treeId);
  //     tree._pushParent(this);
  // }
  /**
   * Add the range corresponding to the current ast node.
   * @param range
   */
  pushRangeList(e) {
    this.rangeList.push(...e);
  }
  shouldBePushRangeList() {
    return this.rangeList.length === 0 && this.type !== 2;
  }
  // hasChildren(treeId: number) {
  //     return this.children.has(treeId);
  // }
  toRTreeItem() {
    if (this.featureId != null)
      return this.featureDirtyRanges;
    const e = this.row, t = this.column;
    return [{
      unitId: this.unitId,
      sheetId: this.subUnitId,
      range: {
        startRow: e,
        startColumn: t,
        endRow: e,
        endColumn: t
      }
    }];
  }
  /**
   * Determine whether it is dependent on other trees.
   * @param dependenceTree
   */
  // dependency(dependenceTree: FormulaDependencyTree) {
  //     if (this.rangeList.length === 0) {
  //         return false;
  //     }
  //     for (let r = 0, len = this.rangeList.length; r < len; r++) {
  //         const unitRange = this.rangeList[r];
  //         const unitId = unitRange.unitId;
  //         const sheetId = unitRange.sheetId;
  //         const range = unitRange.range;
  //         if (
  //             dependenceTree.unitId === unitId &&
  //             dependenceTree.subUnitId === sheetId &&
  //             dependenceTree.inRangeData(range)
  //         ) {
  //             return true;
  //         }
  //     }
  //     return false;
  // }
  // private _pushParent(tree: FormulaDependencyTree) {
  //     this.parents.add(tree.treeId);
  // }
};
var ph = Object.getOwnPropertyDescriptor;
var Nh = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? ph(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var vt = (a2, i) => (e, t) => i(e, t, a2);
function gr(a2) {
  return a2.getLastTreeId() || 0;
}
var aa = createIdentifier("engine-formula.dependency-generator");
var ia = class extends Ve {
  constructor(i, e, t, r, n, s, o, u) {
    super();
    A(this, "_updateRangeFlattenCache", /* @__PURE__ */ new Map());
    A(this, "_dependencyRTreeCacheForAddressFunction", new aI());
    A(this, "_executedAddressFunctionNodeIds", /* @__PURE__ */ new Set());
    this._currentConfigService = i, this._runtimeService = e, this._otherFormulaManagerService = t, this._featureCalculationManagerService = r, this._interpreter = n, this._astTreeBuilder = s, this._lexer = o, this._dependencyManagerService = u;
  }
  dispose() {
    this._updateRangeFlattenCache.clear(), this._dependencyRTreeCacheForAddressFunction.clear(), Hr.clear();
  }
  generate() {
    return __async(this, null, function* () {
      this._updateRangeFlatten();
      const i = this._currentConfigService.getFormulaData(), e = this._otherFormulaManagerService.getOtherFormulaData(), t = this._currentConfigService.getClearDependencyTreeCache();
      t != null && Object.keys(t).forEach((l) => {
        l != null && Object.keys(t[l]).forEach((f2) => {
          f2 != null && (this._dependencyManagerService.clearOtherFormulaDependency(l, f2), this._dependencyManagerService.clearFeatureFormulaDependency(l, f2), this._dependencyManagerService.clearFormulaDependency(l, f2));
        });
      });
      const r = this._currentConfigService.getUnitData(), n = yield this._generateTreeList(i, e, r), s = this._getUpdateTreeListAndMakeDependency(n);
      let o = this._calculateRunList(s);
      return this._dependencyFeatureCalculation(o) && (o.forEach((l) => {
        l.resetState();
      }), o = this._calculateRunList(o)), this._checkIsCycleDependency(o) && this._runtimeService.enableCycleDependency(), this._dependencyRTreeCacheForAddressFunction.clear(), this._runtimeService.clearArrayObjectCache(), Promise.resolve(o);
    });
  }
  _dependencyFeatureCalculation(i) {
    const e = this._featureCalculationManagerService.getReferenceExecutorMap();
    if (e.size === 0)
      return;
    this._clearFeatureCalculationNode(i);
    let t = false;
    return e.forEach((r, n) => {
      r.forEach((s, o) => {
        s.forEach((u, c) => {
          const { unitId: l, subUnitId: f2, getDirtyData: m2 } = u, d2 = m2(this._currentConfigService.getDirtyData(), this._runtimeService.getAllRuntimeData()), _2 = this._convertDirtyRangesToUnitRange(d2.dirtyRanges), C = this._intersectFeatureCalculation(_2, i, { unitId: l, subUnitId: f2, featureId: c });
          if (C.length > 0) {
            let E = this._getExistTreeList({ unitId: l, subUnitId: f2, featureId: c }, i);
            E == null && (E = this._getFeatureFormulaTree(c, gr(this._dependencyManagerService), u), i.push(E)), E.parents = /* @__PURE__ */ new Set(), C.forEach((R) => {
              R.hasChildren(E.treeId) || R.pushChildren(E);
            }), t = true;
          }
        });
      });
    }), t;
  }
  _clearFeatureCalculationNode(i) {
    const e = this._featureCalculationManagerService.getReferenceExecutorMap();
    i.forEach((t) => {
      var s, o, u, c;
      const r = /* @__PURE__ */ new Set();
      for (const l of t.children) {
        const f2 = this._dependencyManagerService.getTreeById(l);
        f2 && (f2.featureId && (o = (s = e.get(t.unitId)) == null ? void 0 : s.get(t.subUnitId)) != null && o.has(f2.featureId) || r.add(l));
      }
      t.children = r;
      const n = /* @__PURE__ */ new Set();
      for (const l of t.parents) {
        const f2 = this._dependencyManagerService.getTreeById(l);
        f2 && (f2.featureId && (c = (u = e.get(t.unitId)) == null ? void 0 : u.get(t.subUnitId)) != null && c.has(f2.featureId) || n.add(l));
      }
      t.parents = n;
    });
  }
  /**
   * TODO @DR-Univer: The next step will be to try changing the incoming dirtyRanges to an array, thus avoiding conversion.
   * @param dirtyRanges
   * @returns
   */
  _convertDirtyRangesToUnitRange(i) {
    const e = [];
    for (const t in i) {
      const r = i[t];
      for (const n in r) {
        const s = r[n];
        for (const o of s)
          e.push({
            unitId: t,
            sheetId: n,
            range: o
          });
      }
    }
    return e;
  }
  _intersectFeatureCalculation(i, e, t) {
    const r = [], n = this._dependencyManagerService.searchDependency(i);
    for (let s = 0, o = e.length; s < o; s++) {
      const u = e[s];
      if (u.unitId === t.unitId && u.subUnitId === t.subUnitId && u.featureId === t.featureId)
        continue;
      n.has(u.treeId) && r.push(u);
    }
    return r;
  }
  _getExistTreeList(i, e) {
    const { unitId: t, subUnitId: r, featureId: n } = i;
    for (let s = 0, o = e.length; s < o; s++) {
      const u = e[s];
      if (u.unitId === t && u.subUnitId === r && u.featureId === n)
        return u;
    }
  }
  _isCyclicUtil(i, e, t) {
    const r = this._dependencyManagerService.getTreeById(i);
    if (r == null)
      return false;
    if (!e.has(r.treeId)) {
      e.add(r.treeId), t.add(r.treeId);
      for (const n of r.children)
        if (!e.has(n) && this._isCyclicUtil(n, e, t) || t.has(n))
          return true;
    }
    return t.delete(r.treeId), false;
  }
  _checkIsCycleDependency(i) {
    const e = /* @__PURE__ */ new Set(), t = /* @__PURE__ */ new Set();
    for (let r = 0, n = i.length; r < n; r++) {
      const s = i[r];
      if (this._isCyclicUtil(s.treeId, e, t) === true)
        return true;
    }
    return false;
  }
  /**
   * Generate nodes for the dependency tree, where each node contains all the reference data ranges included in each formula.
   * @param formulaData
   */
  _generateTreeList(i, e, t) {
    return __async(this, null, function* () {
      const r = Object.keys(i), n = Object.keys(e), s = [];
      this._currentConfigService.isForceCalculate() && this._dependencyManagerService.reset(), this._registerFormulas(r, i, t, s), this._registerOtherFormulas(e, n, s), this._registerFeatureFormulas(s);
      for (let u = 0, c = s.length; u < c; u++) {
        const l = s[u];
        if (!l.formula)
          continue;
        const f2 = this._getTreeNode(l);
        l.isDirty = this._includeTree(l, f2);
        const m2 = this._getAddressFunctionNodeList(f2);
        if (m2.length > 0 && (l.addressFunctionNodes = m2), l.isVirtual)
          continue;
        this._runtimeService.setCurrent(
          l.row,
          l.column,
          l.rowCount,
          l.columnCount,
          l.subUnitId,
          l.unitId
        );
        const d2 = yield this._getRangeListByNode({
          node: f2,
          refOffsetX: l.refOffsetX,
          refOffsetY: l.refOffsetY
        });
        l.pushRangeList(d2);
      }
      for (let u = 0, c = s.length; u < c; u++) {
        const l = s[u];
        l.isCache || this._dependencyManagerService.addDependencyRTreeCache(l);
      }
      return yield this._calculateListByFunctionRefNode(s), s;
    });
  }
  // private _moveRangeList(tree: FormulaDependencyTree, refOffsetX: number, refOffsetY: number) {
  //     const rangeList = tree.rangeList;
  //     const newRangeList = [];
  //     for (let i = 0, len = rangeList.length; i < len; i++) {
  //         const unitRange = rangeList[i];
  //         const newRange = {
  //             unitId: tree.unitId,
  //             sheetId: tree.subUnitId,
  //             range: moveRangeByOffset(unitRange.range, refOffsetX, refOffsetY),
  //         };
  //         newRangeList.push(newRange);
  //     }
  //     return newRangeList;
  // }
  _registerFeatureFormulas(i) {
    this._featureCalculationManagerService.getReferenceExecutorMap().forEach((t, r) => {
      t.forEach((n, s) => {
        n.forEach((o, u) => {
          const c = this._dependencyManagerService.getFeatureFormulaDependency(o.unitId, o.subUnitId, u);
          i.push(this._getFeatureFormulaTree(u, c, o));
        });
      });
    });
  }
  _getFeatureFormulaTree(i, e, t) {
    const { unitId: r, subUnitId: n, dependencyRanges: s, getDirtyData: o } = t, u = e || gr(this._dependencyManagerService), c = new Ms(u);
    c.unitId = r, c.subUnitId = n, c.rangeList = s, c.getDirtyData = o;
    const l = o(this._currentConfigService.getDirtyData(), this._runtimeService.getAllRuntimeData()), f2 = this._convertDirtyRangesToUnitRange(l.dirtyRanges);
    return c.featureDirtyRanges = f2, c.featureId = i, c.type = sa.FEATURE_FORMULA, this._dependencyManagerService.addFeatureFormulaDependency(r, n, i, c), this._dependencyManagerService.getFeatureFormulaDependency(t.unitId, t.subUnitId, i) && (c.isCache = true), c;
  }
  _registerOtherFormulas(i, e, t) {
    for (const r of e) {
      const n = i[r];
      if (n == null)
        continue;
      const s = Object.keys(n);
      for (const o of s) {
        const u = n[o];
        if (u == null)
          continue;
        const c = Object.keys(u);
        for (const l of c) {
          const f2 = this._dependencyManagerService.hasOtherFormulaDataMainData(l), m2 = u[l], { f: d2, ranges: _2 } = m2;
          let C = false;
          f2 && (C = true);
          const E = Ti(r, d2, this._lexer, this._astTreeBuilder, this._currentConfigService), { firstRow: R, firstColumn: b } = this._getFirstCellOfRange(_2), p2 = this._dependencyManagerService.getOtherFormulaDependency(r, o, l), V = (p2 == null ? void 0 : p2.getValue(0, 0)) || gr(this._dependencyManagerService), S2 = new Ms(V);
          for (let M2 = 0; M2 < _2.length; M2++) {
            const D2 = _2[M2], { startRow: w, startColumn: L, endRow: v, endColumn: j2 } = D2;
            for (let k = w; k <= v; k++)
              for (let G2 = L; G2 <= j2; G2++) {
                const ne = G2 - b, z = k - R;
                if (ne === 0 && z === 0) {
                  S2.node = E, S2.formula = d2, S2.unitId = r, S2.subUnitId = o, S2.formulaId = l, S2.type = sa.OTHER_FORMULA, S2.isCache = C, t.push(S2), this._dependencyManagerService.addOtherFormulaDependency(r, o, l, S2), this._dependencyManagerService.addFormulaDependencyByDefinedName(S2);
                  continue;
                }
                const $2 = new Hi();
                $2.treeId = (p2 == null ? void 0 : p2.getValue(ne, z)) || gr(this._dependencyManagerService), $2.refTree = S2, $2.refOffsetX = ne, $2.refOffsetY = z, $2.isCache = C, this._dependencyManagerService.addOtherFormulaDependency(r, o, l, $2), this._dependencyManagerService.addFormulaDependencyByDefinedName($2), t.push($2);
              }
          }
          this._dependencyManagerService.addOtherFormulaDependencyMainData(l);
        }
      }
    }
  }
  _getFirstCellOfRange(i) {
    const e = i[0];
    return {
      firstRow: e.startRow,
      firstColumn: e.startColumn
    };
  }
  _registerFormulas(i, e, t, r) {
    for (const n of i) {
      const s = e[n];
      if (s == null)
        continue;
      const o = Object.keys(s);
      for (const u of o) {
        const c = new ht(s[u] || {}), l = /* @__PURE__ */ new Map();
        c.forValue((f2, m2, d2) => {
          if (d2 == null)
            return true;
          const { x: _2 = 0, y: C = 0, si: E } = d2;
          if (!(_2 === 0 && C === 0 && E != null))
            return true;
          const R = this._createFDtree(n, u, f2, m2, t, d2), b = this._dependencyManagerService.getFormulaDependency(n, u, f2, m2);
          b != null ? (R.treeId = b, R.isCache = true) : (this._dependencyManagerService.addFormulaDependency(n, u, f2, m2, R), this._dependencyManagerService.addFormulaDependencyByDefinedName(R)), l.set(E, R), r.push(R);
        }), c.forValue((f2, m2, d2) => {
          if (d2 == null)
            return true;
          const { x: _2 = 0, y: C = 0, si: E } = d2;
          if (_2 === 0 && C === 0 && E != null)
            return true;
          let R;
          if (E && l.has(E)) {
            const p2 = l.get(E);
            R = this._createVirtualFDtree(p2, d2);
          } else
            R = this._createFDtree(n, u, f2, m2, t, d2);
          const b = this._dependencyManagerService.getFormulaDependency(n, u, f2, m2);
          b != null ? (R.treeId = b, R.isCache = true) : (this._dependencyManagerService.addFormulaDependency(n, u, f2, m2, R), this._dependencyManagerService.addFormulaDependencyByDefinedName(R)), r.push(R);
        }), l.clear();
      }
    }
  }
  _createFDtree(i, e, t, r, n, s) {
    const { f: o, x: u = 0, y: c = 0 } = s, l = new Ms(gr(this._dependencyManagerService)), f2 = n[i][e], m2 = Ti(i, o, this._lexer, this._astTreeBuilder, this._currentConfigService);
    return l.node = m2, l.formula = o, l.unitId = i, l.subUnitId = e, l.row = t, l.column = r, l.rowCount = f2.rowCount, l.columnCount = f2.columnCount, l;
  }
  _createVirtualFDtree(i, e) {
    const { x: t = 0, y: r = 0 } = e, n = new Hi();
    return n.treeId = gr(this._dependencyManagerService), n.refTree = i, n.refOffsetX = t, n.refOffsetY = r, n;
  }
  /**
   * Break down the dirty areas into ranges for subsequent matching.
   */
  _updateRangeFlatten() {
    const i = this._currentConfigService.isForceCalculate(), e = this._currentConfigService.getDirtyRanges();
    if (!i) {
      this._updateRangeFlattenCache.clear();
      for (let t = 0; t < e.length; t++) {
        const r = e[t], n = r.range, s = r.sheetId, o = r.unitId;
        this._addFlattenCache(o, s, n);
      }
    }
  }
  _addFlattenCache(i, e, t) {
    let r = this._updateRangeFlattenCache.get(i);
    r == null && (r = /* @__PURE__ */ new Map(), this._updateRangeFlattenCache.set(i, r));
    let n = r.get(e);
    n == null && (n = [], r.set(e, n)), n.push(t);
  }
  _isPreCalculateNode(i) {
    return i.nodeType === oe.UNION || i.nodeType === oe.PREFIX && i.getToken() === we2.AT || i.nodeType === oe.SUFFIX && i.getToken() === nt.POUND;
  }
  _nodeTraversalRef(i, e) {
    const t = i.getChildren(), r = t.length;
    for (let n = 0; n < r; n++) {
      const s = t[n];
      if (this._isPreCalculateNode(s)) {
        if (e.push(s), s.nodeType === oe.UNION)
          for (const o of s.getChildren())
            o.nodeType === oe.FUNCTION && o.isAddress() && this._nodeTraversalRef(o, e);
        continue;
      } else s.nodeType === oe.REFERENCE && e.push(s);
      this._nodeTraversalRef(s, e);
    }
  }
  _nodeTraversalReferenceFunction(i, e) {
    const t = i.getChildren(), r = t.length;
    for (let n = 0; n < r; n++) {
      const s = t[n];
      if (s.nodeType === oe.FUNCTION && s.isAddress()) {
        e.push(s);
        continue;
      }
      this._nodeTraversalReferenceFunction(s, e);
    }
  }
  _executeNode(i, e = 0, t = 0) {
    return __async(this, null, function* () {
      let r;
      const n = {
        node: i,
        refOffsetX: e,
        refOffsetY: t
      };
      return this._interpreter.checkAsyncNode(i) ? r = yield this._interpreter.executeAsync(n) : r = this._interpreter.execute(n), r;
    });
  }
  /**
   * Calculate the range required for collection in advance,
   * including references and location functions (such as OFFSET, INDIRECT, INDEX, etc.).
   * @param node
   */
  _getRangeListByNode(i) {
    return __async(this, null, function* () {
      const e = [], t = i.refOffsetX, r = i.refOffsetY, n = i.node;
      if (n == null)
        return [];
      this._nodeTraversalRef(n, e);
      const s = [];
      for (let o = 0, u = e.length; o < u; o++) {
        const c = e[o], f2 = (yield this._executeNode(c, t, r)).toUnitRange();
        s.push(f2), c.setValue(null);
      }
      return s;
    });
  }
  _getAddressFunctionNodeList(i) {
    const e = [];
    return i == null ? [] : (this._nodeTraversalReferenceFunction(i, e), e);
  }
  _getTreeNode(i) {
    return i.node;
  }
  _buildDirtyRangesByAddressFunction(i, e) {
    return __async(this, null, function* () {
      const t = e.addressFunctionNodes;
      if (t.length === 0)
        return;
      const r = e.refOffsetX, n = e.refOffsetY, s = yield this._getRangeListByFunctionRefNode(t, r, n);
      e.addressFunctionNodes = [], this._addDependencyTreeByAddressFunction(e, s);
      const o = i.bulkSearch(s), u = this._buildTreeNodeById(o);
      u.length !== 0 && (yield this._calculateAddressFunctionRuntimeData(i, u));
    });
  }
  _calculateListByFunctionRefNode(i) {
    return __async(this, null, function* () {
      const e = new aI();
      for (let t = 0, r = i.length; t < r; t++) {
        const n = i[t];
        e.insert({
          unitId: n.unitId,
          sheetId: n.subUnitId,
          range: {
            startRow: n.row,
            startColumn: n.column,
            endRow: n.row,
            endColumn: n.column
          },
          id: n.treeId
        });
      }
      this._executedAddressFunctionNodeIds.clear();
      for (let t = 0, r = i.length; t < r; t++) {
        const n = i[t];
        yield this._calculateAddressFunction(e, n);
      }
    });
  }
  _calculateAddressFunction(i, e) {
    return __async(this, null, function* () {
      const t = e.addressFunctionNodes;
      if (t.length === 0)
        return;
      const r = e.refOffsetX, n = e.refOffsetY;
      this._runtimeService.setCurrent(
        e.row,
        e.column,
        e.rowCount,
        e.columnCount,
        e.subUnitId,
        e.unitId
      );
      const s = [];
      for (let c = 0, l = t.length; c < l; c++) {
        const f2 = yield this._getRangeListByNode({
          node: t[c],
          refOffsetX: r,
          refOffsetY: n
        });
        s.push(...f2);
      }
      const o = /* @__PURE__ */ new Set();
      this._searchDependencyByAddressFunction(i, s, o);
      const u = this._buildTreeNodeById(o);
      if (u.length === 0) {
        yield this._buildDirtyRangesByAddressFunction(i, e);
        return;
      }
      yield this._calculateAddressFunctionRuntimeData(i, u), yield this._buildDirtyRangesByAddressFunction(i, e);
    });
  }
  _calculateAddressFunctionRuntimeData(i, e) {
    return __async(this, null, function* () {
      for (; e.length > 0; ) {
        const t = e.pop(), n = {
          node: this._getTreeNode(t),
          refOffsetX: t.refOffsetX,
          refOffsetY: t.refOffsetY
        };
        yield this._calculateAddressFunction(i, t), this._runtimeService.setCurrent(
          t.row,
          t.column,
          t.rowCount,
          t.columnCount,
          t.subUnitId,
          t.unitId
        );
        let s;
        this._interpreter.checkAsyncNode(n.node) ? s = yield this._interpreter.executeAsync(n) : s = this._interpreter.execute(n), t.formulaId != null ? this._runtimeService.setRuntimeOtherData(t.formulaId, t.refOffsetX, t.refOffsetY, s) : this._runtimeService.setRuntimeData(s);
      }
    });
  }
  _buildTreeNodeById(i) {
    const e = [];
    for (const t of i) {
      const r = this._getTreeById(t);
      !r || this._executedAddressFunctionNodeIds.has(t) || (this._executedAddressFunctionNodeIds.add(t), e.push(r));
    }
    return e;
  }
  _searchDependencyByAddressFunction(i, e, t) {
    const r = i.bulkSearch(e), n = this._dependencyRTreeCacheForAddressFunction.bulkSearch(e);
    for (const o of n)
      t.has(o) || t.add(o);
    const s = [];
    for (const o of r) {
      const u = this._getTreeById(o);
      u && !t.has(o) && (s.push(...u.rangeList), t.add(o));
    }
    return s.length > 0 && this._searchDependencyByAddressFunction(i, s, t), t;
  }
  _getTreeById(i) {
    return this._dependencyManagerService.getTreeById(i);
  }
  _addDependencyTreeByAddressFunction(i, e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const n = e[r], { unitId: s, sheetId: o, range: u } = n;
      t.push({
        unitId: s,
        sheetId: o,
        range: u,
        id: i.treeId
      });
    }
    this._dependencyRTreeCacheForAddressFunction.bulkInsert(t);
  }
  /**
   * Calculate the range required for collection in advance,
   * including references and location functions (such as OFFSET, INDIRECT, INDEX, etc.).
   * @param node
   */
  _getRangeListByFunctionRefNode(i, e, t) {
    return __async(this, null, function* () {
      const r = [];
      for (let n = 0, s = i.length; n < s; n++) {
        const o = i[n], c = (yield this._executeNode(o, e, t)).toUnitRange();
        r.push(c), o.setValue(null);
      }
      return r;
    });
  }
  /**
   * Build a formula dependency tree based on the dependency relationships.
   * @param treeList
   */
  _getUpdateTreeListAndMakeDependency(i) {
    const e = [], t = /* @__PURE__ */ new Set(), r = this._currentConfigService.isForceCalculate(), n = this._currentConfigService.getDirtyRanges(), s = this._dependencyManagerService.searchDependency(n), o = this._dependencyRTreeCacheForAddressFunction.bulkSearch(n);
    for (const c of o)
      s.add(c);
    const u = this._dependencyManagerService.buildDependencyTree(i);
    for (const c of u) {
      const l = c.treeId;
      (r || c.isDirty || c.dependencySheetName(this._currentConfigService.getDirtyNameMap()) || //O(n) n=tree.rangeList.length
      s.has(l) && !c.isExcludeRange(this._currentConfigService.getExcludedRange())) && !t.has(l) && (e.push(c), t.add(l));
    }
    return e;
  }
  _includeTreeFeature(i) {
    var n, s;
    const e = i.unitId, t = i.subUnitId, r = i.featureId;
    if (r != null) {
      const o = this._currentConfigService.getDirtyUnitFeatureMap();
      if (((s = (n = o == null ? void 0 : o[e]) == null ? void 0 : n[t]) == null ? void 0 : s[r]) != null)
        return true;
    }
    return false;
  }
  _includeOtherFormula(i) {
    var n, s;
    const e = i.unitId, t = i.subUnitId, r = i.formulaId;
    if (r != null) {
      const o = this._currentConfigService.getDirtyUnitOtherFormulaMap();
      if (((s = (n = o == null ? void 0 : o[e]) == null ? void 0 : n[t]) == null ? void 0 : s[r]) != null)
        return true;
    }
    return false;
  }
  _detectForcedRecalculationNode(i, e) {
    return e == null ? false : this._detectForcedRecalculationNodeRecursion(e);
  }
  _detectForcedRecalculationNodeRecursion(i) {
    if (i.isForcedCalculateFunction())
      return true;
    const e = i.getChildren();
    for (let t = 0, r = e.length; t < r; t++) {
      const n = e[t];
      if (this._detectForcedRecalculationNodeRecursion(n))
        return true;
    }
    return false;
  }
  /**
   * Determine whether all ranges of the current node exist within the dirty area.
   * If they are within the dirty area, return true, indicating that this node needs to be calculated.
   * @param tree
   */
  _includeTree(i, e) {
    var c, l, f2;
    const t = i.unitId, r = i.subUnitId;
    if (this._detectForcedRecalculationNode(i, e) === true || this._includeTreeFeature(i) === true || this._includeOtherFormula(i) === true || Fm(i, e, this._currentConfigService) === true)
      return true;
    const n = (l = (c = this._currentConfigService.getExcludedRange()) == null ? void 0 : c[t]) == null ? void 0 : l[r];
    if ((n == null ? void 0 : n.getValue(i.row, i.column)) != null)
      return false;
    if (((f2 = this._currentConfigService.getDirtyNameMap()[t]) == null ? void 0 : f2[r]) != null)
      return true;
    if (!this._updateRangeFlattenCache.has(t))
      return false;
    const o = this._updateRangeFlattenCache.get(t);
    if (!o.has(r))
      return false;
    const u = o.get(r);
    for (const m2 of u)
      if (i.inRangeData(m2))
        return true;
    return false;
  }
  /**
   * Generate the final formula calculation order array by traversing the dependency tree established via depth-first search.
   * @param treeList
   */
  _calculateRunList(i) {
    i.length;
    const e = i, t = [], r = [];
    for (; e.length > 0; ) {
      const n = e.pop();
      if (n === void 0 || n.isSkip())
        continue;
      if (n.isAdded()) {
        t.push(n), n.setSkip();
        continue;
      }
      r.length = 0;
      for (const o of n.parents) {
        const u = this._dependencyManagerService.getTreeById(o);
        if (!u)
          throw new Error("ParentDependencyTree object is null");
        u.isAdded() || n.isSkip() || r.push(u);
      }
      const s = this._dependencyRTreeCacheForAddressFunction.bulkSearch(n.toRTreeItem());
      for (const o of s) {
        const u = this._dependencyManagerService.getTreeById(o);
        if (!u)
          throw new Error("ParentDependencyTree object is null");
        u.isAdded() || n.isSkip() || r.push(u);
      }
      r.length === 0 ? (t.push(n), n.setSkip()) : (n.setAdded(), e.push(n, ...r));
    }
    return t;
  }
};
ia = Nh([
  vt(0, Wt),
  vt(1, Nt2),
  vt(2, ja),
  vt(3, Wr),
  vt(4, Inject(Vr)),
  vt(5, Inject(Gr)),
  vt(6, Inject(pr)),
  vt(7, cs)
], ia);
var Vh = Object.getOwnPropertyDescriptor;
var Oh = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Vh(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var Zt = (a2, i) => (e, t) => i(e, t, a2);
var Sh = 500;
var oa = createIdentifier("engine-formula.calculate-formula.service");
var ua = class extends Ve {
  constructor(i, e, t, r, n, s, o) {
    super();
    A(this, "_executionInProgressListener$", new Subject());
    A(this, "executionInProgressListener$", this._executionInProgressListener$.asObservable());
    A(this, "_executionCompleteListener$", new Subject());
    A(this, "executionCompleteListener$", this._executionCompleteListener$.asObservable());
    A(this, "_executeLock", new JC());
    this._configService = i, this._lexer = e, this._currentConfigService = t, this._runtimeService = r, this._formulaDependencyGenerator = n, this._interpreter = s, this._astTreeBuilder = o;
  }
  dispose() {
    super.dispose(), this._executionInProgressListener$.complete(), this._executionCompleteListener$.complete(), _r.clear(), Ke.clear(), qs.clear(), Js.clear();
  }
  /**
   * Stop the execution of the formula.
   */
  stopFormulaExecution() {
    this._runtimeService.stopExecution();
  }
  /**
   * When the feature is loading,
   * the pre-calculated content needs to be input to the formula engine in advance,
   * so that the formula can read the correct values.
   * @param featureId
   * @param featureData
   */
  setRuntimeFeatureCellData(i, e) {
    this._runtimeService.setRuntimeFeatureCellData(i, e);
  }
  setRuntimeFeatureRange(i, e) {
    this._runtimeService.setRuntimeFeatureRange(i, e);
  }
  execute(i) {
    return __async(this, null, function* () {
      this._runtimeService.setFormulaExecuteStage(tt.START), this._executionInProgressListener$.next(this._runtimeService.getRuntimeState()), this._currentConfigService.load(i), this._runtimeService.reset();
      const e = i.maxIteration || xo;
      this._executeLock.acquire("FORMULA_EXECUTION_LOCK", () => __async(this, null, function* () {
        for (let t = 0; t < e && (this._runtimeService.setFormulaCycleIndex(t), yield this._executeStep(), _r.clear(), !!this._runtimeService.isCycleDependency()); t++)
          ;
        this._runtimeService.setFormulaExecuteStage(tt.CALCULATION_COMPLETED), this._executionInProgressListener$.next(this._runtimeService.getRuntimeState()), this._executionCompleteListener$.next(this._runtimeService.getAllRuntimeData()), Ke.clear(), this._runtimeService.reset();
      }));
    });
  }
  _executeStep() {
    return __async(this, null, function* () {
      const i = yield this._apply();
      if (i == null)
        return;
      const { arrayFormulaRange: e, runtimeFeatureRange: t } = i, { dirtyRanges: r, excludedCell: n } = this._getArrayFormulaDirtyRangeAndExcludedRange(
        e,
        t
      );
      return r == null || r.length === 0 || (_r.clear(), this._currentConfigService.loadDirtyRangesAndExcludedCell(r, n), yield this._apply(true)), true;
    });
  }
  _getArrayFormulaDirtyRangeAndExcludedRange(i, e) {
    const t = [], r = {};
    return Object.keys(i).forEach((n) => {
      const s = i[n];
      if (s == null)
        return true;
      Object.keys(s).forEach((o) => {
        const u = new ht(s[o]);
        if (u == null)
          return true;
        const c = new ht();
        u.forValue((l, f2, m2) => {
          c.setValue(l, f2, true), t.push({ unitId: n, sheetId: o, range: m2 });
        }), r[n] == null && (r[n] = {}), r[n][o] = c;
      });
    }), Object.keys(e).forEach((n) => {
      const s = e[n];
      Object.keys(s).forEach((o) => {
        const u = s[o];
        if (u == null)
          return true;
        Object.keys(u).forEach((c) => {
          const l = u[c];
          if (l == null)
            return true;
          for (const f2 of l)
            t.push({ unitId: o, sheetId: c, range: f2 });
        });
      });
    }), { dirtyRanges: t, excludedCell: r };
  }
  // eslint-disable-next-line max-lines-per-function
  _apply(i = false) {
    return __async(this, null, function* () {
      var u;
      i ? this._runtimeService.setFormulaExecuteStage(tt.START_DEPENDENCY_ARRAY_FORMULA) : this._runtimeService.setFormulaExecuteStage(tt.START_DEPENDENCY), this._executionInProgressListener$.next(this._runtimeService.getRuntimeState());
      const e = (yield this._formulaDependencyGenerator.generate()).reverse(), t = this._interpreter;
      i ? (this._runtimeService.setFormulaExecuteStage(tt.START_CALCULATION_ARRAY_FORMULA), this._runtimeService.setTotalArrayFormulasToCalculate(e.length)) : (this._runtimeService.setFormulaExecuteStage(tt.START_CALCULATION), this._runtimeService.setTotalFormulasToCalculate(e.length)), this._executionInProgressListener$.next(this._runtimeService.getRuntimeState());
      let r = [];
      const n = this._configService.getConfig(pa), s = (n == null ? void 0 : n.intervalCount) || Sh, o = e.length;
      for (let c = 0; c < o; c++) {
        const l = e[c], f2 = l.nodeData, m2 = l.getDirtyData;
        if (c % s === 0 && (yield new Promise((_2) => {
          const C = gR(_2);
          r.push(C);
        }), i ? (this._runtimeService.setFormulaExecuteStage(
          tt.CURRENTLY_CALCULATING_ARRAY_FORMULA
        ), this._runtimeService.setCompletedArrayFormulasCount(c + 1)) : (this._runtimeService.setFormulaExecuteStage(tt.CURRENTLY_CALCULATING), this._runtimeService.setCompletedFormulasCount(c + 1)), this._executionInProgressListener$.next(this._runtimeService.getRuntimeState()), this._runtimeService.isStopExecution() || f2 == null && m2 == null)) {
          this._runtimeService.setFormulaExecuteStage(tt.IDLE), this._runtimeService.markedAsStopFunctionsExecuted(), this._executionCompleteListener$.next(this._runtimeService.getAllRuntimeData());
          return;
        }
        this._runtimeService.setCurrent(
          l.row,
          l.column,
          l.rowCount,
          l.columnCount,
          l.subUnitId,
          l.unitId
        );
        let d2;
        if (m2 != null && l.featureId != null) {
          const { runtimeCellData: _2, dirtyRanges: C } = m2(this._currentConfigService.getDirtyData(), this._runtimeService.getAllRuntimeData());
          this._runtimeService.setRuntimeFeatureCellData(l.featureId, _2), this._runtimeService.setRuntimeFeatureRange(l.featureId, C);
        } else f2 != null && (t.checkAsyncNode(f2.node) ? d2 = yield t.executeAsync(f2) : d2 = t.execute(f2), l.formulaId != null ? this._runtimeService.setRuntimeOtherData(l.formulaId, l.refOffsetX, l.refOffsetY, d2) : this._runtimeService.setRuntimeData(d2));
        (u = f2.node) == null || u.resetCalculationState();
      }
      return r.forEach((c) => c()), r = [], o > 0 ? this._runtimeService.markedAsSuccessfullyExecuted() : i || this._runtimeService.markedAsNoFunctionsExecuted(), this._runtimeService.getAllRuntimeData();
    });
  }
  calculate(i, e = true) {
    const t = this._lexer.treeBuilder(i, e);
    if (Object.values(h).includes(t))
      return Ue.create(t);
    const r = this._astTreeBuilder.parse(t);
    r == null || r.serialize();
  }
};
ua = Oh([
  Zt(0, xs),
  Zt(1, Inject(pr)),
  Zt(2, Wt),
  Zt(3, Nt2),
  Zt(4, aa),
  Zt(5, Inject(Vr)),
  Zt(6, Inject(Gr))
], ua);
var Mh = Object.getOwnPropertyDescriptor;
var Dh = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Mh(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var Ds2 = (a2, i) => (e, t) => i(e, t, a2);
var $n = class extends Ve {
  constructor(a2, i, e) {
    super(), this._commandService = a2, this._calculateFormulaService = i, this._formulaDataModel = e, this._initialize();
  }
  _initialize() {
    this._commandExecutedListener(), this._initialExecuteFormulaListener();
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((a2) => {
        if (a2.id === So.id)
          this._calculateFormulaService.stopFormulaExecution();
        else if (a2.id === Oo.id)
          this._calculate(a2.params);
        else if (a2.id === vs.id) {
          const i = a2.params;
          if (i == null)
            return;
          const { arrayFormulaRange: e, arrayFormulaCellData: t } = i;
          this._formulaDataModel.setArrayFormulaRange(e), this._formulaDataModel.setArrayFormulaCellData(t);
        }
      })
    );
  }
  _calculate(a2) {
    return __async(this, null, function* () {
      const { forceCalculation: i = false, dirtyRanges: e = [], dirtyNameMap: t = {}, dirtyDefinedNameMap: r = {}, dirtyUnitFeatureMap: n = {}, dirtyUnitOtherFormulaMap: s = {}, clearDependencyTreeCache: o = {}, maxIteration: u = xo, rowData: c } = a2, l = this._formulaDataModel.getFormulaData(), f2 = this._formulaDataModel.getArrayFormulaCellData(), m2 = this._formulaDataModel.getArrayFormulaRange();
      this._calculateFormulaService.execute({
        formulaData: l,
        arrayFormulaCellData: f2,
        arrayFormulaRange: m2,
        forceCalculate: i,
        dirtyRanges: e,
        dirtyNameMap: t,
        dirtyDefinedNameMap: r,
        dirtyUnitFeatureMap: n,
        dirtyUnitOtherFormulaMap: s,
        clearDependencyTreeCache: o,
        maxIteration: u,
        rowData: c
      });
    });
  }
  // Notification
  _initialExecuteFormulaListener() {
    this._calculateFormulaService.executionCompleteListener$.subscribe((a2) => {
      const i = a2.functionsExecutedState;
      switch (i) {
        case Ir.NOT_EXECUTED:
          break;
        case Ir.STOP_EXECUTION:
          break;
        case Ir.SUCCESS:
          this._applyResult(a2);
          break;
        case Ir.INITIAL:
          break;
      }
      this._commandService.executeCommand(
        Sn.id,
        {
          functionsExecutedState: i
        },
        {
          onlyLocal: true
        }
      );
    }), this._calculateFormulaService.executionInProgressListener$.subscribe((a2) => {
      this._commandService.executeCommand(
        Sn.id,
        {
          stageInfo: a2
        },
        {
          onlyLocal: true
        }
      );
    });
  }
  _applyResult(a2) {
    return __async(this, null, function* () {
      const { unitData: i, unitOtherData: e, arrayFormulaRange: t, arrayFormulaCellData: r, clearArrayFormulaCellData: n, arrayFormulaEmbedded: s, imageFormulaData: o } = a2;
      if (!i) {
        console.error("No sheetData from Formula Engine!");
        return;
      }
      (t || s) && (this._formulaDataModel.clearPreviousArrayFormulaCellData(n), this._formulaDataModel.mergeArrayFormulaCellData(r), this._formulaDataModel.mergeArrayFormulaRange(t), this._commandService.executeCommand(
        vs.id,
        {
          arrayFormulaRange: this._formulaDataModel.getArrayFormulaRange(),
          arrayFormulaCellData: this._formulaDataModel.getArrayFormulaCellData(),
          arrayFormulaEmbedded: s
        },
        {
          onlyLocal: true
        }
      )), o && o.length > 0 && this._commandService.executeCommand(
        wo.id,
        {
          imageFormulaData: o
        },
        {
          onlyLocal: true
        }
      ), this._commandService.executeCommand(
        Mo.id,
        {
          unitData: pl(i),
          unitOtherData: e
        },
        {
          onlyLocal: true
        }
      );
    });
  }
};
$n = Dh([
  Ds2(0, Ds),
  Ds2(1, oa),
  Ds2(2, Inject(yr))
], $n);
var Gi = /[\[\]]/g;
function Wi(a2, i) {
  if (Gi.test(a2)) {
    const e = Number(a2.replace(Gi, ""));
    return i + e;
  }
  return Number(a2) - 1;
}
function ws(a2, i = 0, e = 0) {
  a2 = a2.toLocaleUpperCase();
  const t = a2.split(/[RC]/), r = t[1], n = t[2], s = Wi(r, i), o = Wi(n, e);
  return {
    row: s,
    column: o,
    absoluteRefType: ye.NONE
  };
}
function wh(a2, i = 0, e = 0) {
  const { refBody: t, sheetName: r, unitId: n } = Ca(a2), s = t.indexOf(":");
  if (s === -1) {
    const C = ws(t, i, e), E = C.row, R = C.column, b = C.absoluteRefType;
    return {
      unitId: n,
      sheetName: r,
      range: {
        startRow: E,
        startColumn: R,
        endRow: E,
        endColumn: R,
        startAbsoluteRefType: b,
        endAbsoluteRefType: b
      }
    };
  }
  const o = t.substring(0, s), u = t.substring(s + 1), c = ws(o, i, e), l = ws(u, i, e), f2 = c.row, m2 = c.column, d2 = l.row, _2 = l.column;
  return {
    unitId: n,
    sheetName: r,
    range: {
      startRow: f2,
      startColumn: m2,
      endRow: d2,
      endColumn: _2,
      startAbsoluteRefType: c.absoluteRefType,
      endAbsoluteRefType: l.absoluteRefType
    }
  };
}
function Lh(a2) {
  const i = cn(a2.startRow, a2.startAbsoluteRefType, true), e = cn(a2.startColumn, a2.startAbsoluteRefType, false), t = cn(a2.endRow, a2.endAbsoluteRefType, true), r = cn(a2.endColumn, a2.endAbsoluteRefType, false);
  return i === t && e === r ? `R${i}C${e}` : `R${i}C${e}:R${t}C${r}`;
}
function cn(a2, i = ye.ALL, e) {
  switch (a2 += 1, i) {
    case ye.ALL:
      return `${a2}`;
    case ye.ROW:
      return e ? `${a2}` : `[${a2}]`;
    case ye.COLUMN:
      return e ? `[${a2}]` : `${a2}`;
    case ye.NONE:
      return `[${a2}]`;
  }
}
function rr(a2) {
  let i = a2;
  if (a2.isArray()) {
    const e = a2.getRowCount(), t = a2.getColumnCount();
    if (e > 1 || t > 1)
      return g2.create(h.VALUE);
    i = a2.get(0, 0);
  }
  return i.isError(), i;
}
function zr(...a2) {
  for (let i = 0; i < a2.length; i++) {
    const e = rr(a2[i]);
    if (e.isError())
      return {
        isError: true,
        errorObject: e
      };
    a2[i] = e;
  }
  return {
    isError: false,
    variants: a2
  };
}
function W2(...a2) {
  for (let i = 0; i < a2.length; i++) {
    const e = rr(a2[i]);
    if (e.isError())
      return {
        isError: true,
        errorObject: e
      };
    if (e.isBoolean())
      return {
        isError: true,
        errorObject: g2.create(h.VALUE)
      };
    a2[i] = e;
  }
  return {
    isError: false,
    variants: a2
  };
}
function Ye(...a2) {
  for (let i = 0; i < a2.length; i++) {
    let e = a2[i];
    if (e.isError())
      return {
        isError: true,
        errorObject: e
      };
    if (e.isNull())
      return {
        isError: true,
        errorObject: g2.create(h.NA)
      };
    if (e = rr(a2[i]), e.isError())
      return {
        isError: true,
        errorObject: e
      };
    if (e.isBoolean())
      return {
        isError: true,
        errorObject: g2.create(h.VALUE)
      };
    a2[i] = e;
  }
  return {
    isError: false,
    variants: a2
  };
}
function I2(...a2) {
  for (let i = 0; i < a2.length; i++) {
    let e = a2[i];
    if (e.isString() && (e = e.convertToNumberObjectValue()), e.isError())
      return {
        isError: true,
        errorObject: e
      };
    a2[i] = e;
  }
  return {
    isError: false,
    variants: a2
  };
}
var N2 = class {
  constructor(i) {
    A(this, "_unitId");
    A(this, "_subUnitId");
    A(this, "_row", -1);
    A(this, "_column", -1);
    A(this, "_definedNames");
    A(this, "_locale");
    A(this, "_sheetOrder");
    A(this, "_sheetNameMap");
    A(this, "_formulaDataModel");
    A(this, "_rowCount", -1);
    A(this, "_columnCount", -1);
    A(this, "needsExpandParams", false);
    A(this, "needsReferenceObject", false);
    A(this, "needsLocale", false);
    A(this, "needsSheetsInfo", false);
    A(this, "needsFormulaDataModel", false);
    A(this, "needsSheetRowColumnCount", false);
    A(this, "needsFilteredOutRows", false);
    A(this, "minParams", -1);
    A(this, "maxParams", -1);
    this._name = i;
  }
  get name() {
    return this._name;
  }
  get unitId() {
    return this._unitId;
  }
  get subUnitId() {
    return this._subUnitId;
  }
  get row() {
    return this._row;
  }
  get column() {
    return this._column;
  }
  dispose() {
  }
  /**
   * In Excel, to inject a defined name into a function that has positioning capabilities,
   * such as using the INDIRECT function to reference a named range,
   * you can write it as follows:
   * =INDIRECT("DefinedName1")
   */
  getDefinedName(i) {
    var t;
    const e = this._definedNames;
    return e == null ? null : (t = Array.from(Object.values(e)).filter((r) => r.name === i)) == null ? void 0 : t[0];
  }
  setDefinedNames(i) {
    this._definedNames = i;
  }
  getLocale() {
    return this._locale;
  }
  setLocale(i) {
    this._locale = i;
  }
  getSheetsInfo() {
    return {
      sheetOrder: this._sheetOrder,
      sheetNameMap: this._sheetNameMap
    };
  }
  setSheetsInfo({
    sheetOrder: i,
    sheetNameMap: e
  }) {
    this._sheetOrder = i, this._sheetNameMap = e;
  }
  setFormulaDataModel(i) {
    this._formulaDataModel = i;
  }
  setSheetRowColumnCount(i, e) {
    this._rowCount = i, this._columnCount = e;
  }
  isAsync() {
    return false;
  }
  isAddress() {
    return false;
  }
  isCustom() {
    return false;
  }
  isArgumentsIgnoreNumberPattern() {
    return false;
  }
  setRefInfo(i, e, t, r) {
    this._unitId = i, this._subUnitId = e, this._row = t, this._column = r;
  }
  calculateCustom(...i) {
    return null;
  }
  calculate(...i) {
    return g2.create(h.VALUE);
  }
  checkArrayType(i) {
    return i.isReferenceObject() || i.isValueObject() && i.isArray();
  }
  /**
   * Starting with 1
   * For instance, The column number (starting with 1 for the left-most column of table_array) that contains the return value.
   * https://support.microsoft.com/en-us/office/vlookup-function-0bbc8083-26fe-4963-8ab8-93a18ad188a1
   * @param indexNum
   */
  getIndexNumValue(i, e = 1) {
    let t = i;
    if (t.isArray() && (t = t.getFirstCell()), t.isBoolean())
      return t.getValue() === false ? g2.create(h.VALUE) : e;
    if (t.isString()) {
      const r = Number(t.getValue());
      return Number.isNaN(r) ? g2.create(h.REF) : r;
    } else if (t.isNumber())
      return t.getValue();
    return g2.create(h.VALUE);
  }
  /**
   * A logical value that specifies 1/TRUE , 0/FALSE, default 1
   * For instance range_lookup, A logical value that specifies whether you want VLOOKUP to find an approximate or an exact match
   * Approximate match - 1/TRUE
   * Exact match - 0/FALSE
   * https://support.microsoft.com/en-us/office/vlookup-function-0bbc8083-26fe-4963-8ab8-93a18ad188a1
   * For instance A1, A logical value that specifies what type of reference is contained in the cell ref_text.
   * If a1 is TRUE or omitted, ref_text is interpreted as an A1-style reference.
   * If a1 is FALSE, ref_text is interpreted as an R1C1-style reference.
   * https://support.microsoft.com/zh-cn/office/indirect-%E5%87%BD%E6%95%B0-474b3a3a-8a26-4f44-b491-92b6306fa261
   * @param logicValueObject
   */
  getZeroOrOneByOneDefault(i) {
    if (i == null)
      return 1;
    let e = 1;
    if (i.isArray() && (i = i.getFirstCell()), i.isBoolean())
      i.getValue() === false && (e = 0);
    else {
      if (i.isString())
        return;
      i.isNumber() && i.getValue() === 0 && (e = 0);
    }
    return e;
  }
  /**
   * A logical value that specifies 1/TRUE , 0/FALSE, -1, default 1.
   * The difference from getZeroOrOneByOneDefault is that we need to get -1
   * @param logicValueObject
   */
  getMatchTypeValue(i) {
    if (i == null)
      return 1;
    let e = 1;
    if (i.isArray() && (i = i.getFirstCell()), i.isBoolean())
      i.getValue() === false && (e = 0);
    else {
      if (i.isString())
        return;
      if (i.isNumber()) {
        const t = i.getValue();
        t <= 0 && (e = t);
      }
    }
    return e;
  }
  binarySearch(i, e, t, r, n) {
    const s = e.binarySearch(i, r, n);
    if (s == null)
      return g2.create(h.NA);
    let o;
    return t.getRowCount() === 1 ? o = t.get(0, s) || ce.create() : o = t.get(s, 0) || ce.create(), o.isNull() ? y2.create(0) : o;
  }
  _getOneFirstByRaw(i) {
    return i.length === 0 ? g2.create(h.NA) : i[0][0] || g2.create(h.NA);
  }
  _getOneLastByRaw(i) {
    return i.length === 0 ? g2.create(h.NA) : i[i.length - 1][i[0].length - 1] || g2.create(h.NA);
  }
  equalSearch(i, e, t, r = true) {
    const n = t.pickRaw(e.isEqual(i));
    return r ? this._getOneFirstByRaw(n) : this._getOneLastByRaw(n);
  }
  fuzzySearch(i, e, t, r = true) {
    const n = t.pickRaw(e.compare(i, Y2.EQUALS));
    return r ? this._getOneFirstByRaw(n) : this._getOneLastByRaw(n);
  }
  orderSearch(i, e, t, r = xe.MIN, n = false) {
    const s = e.orderSearch(i, r, n);
    if (s == null)
      return g2.create(h.NA);
    const o = t.get(s.row, s.column) || ce.create();
    return o.isNull() ? g2.create(h.NA) : o;
  }
  binarySearchExpand(i, e, t, r = 0, n, s) {
    const o = e.binarySearch(i, n, s);
    return o == null ? g2.create(h.NA) : r === 0 ? t.slice([o, o + 1]) : t.slice(void 0, [o, o + 1]);
  }
  equalSearchExpand(i, e, t, r = true, n = 0) {
    const s = e.isEqual(i);
    let o;
    return r ? o = s.getFirstTruePosition() : o = s.getLastTruePosition(), o == null ? g2.create(h.NA) : n === 0 ? t.slice([o.row, o.row + 1]) : t.slice(void 0, [o.column, o.column + 1]);
  }
  fuzzySearchExpand(i, e, t, r = true, n = 0) {
    const s = e.compare(i, Y2.EQUALS);
    let o;
    return r ? o = s.getFirstTruePosition() : o = s.getLastTruePosition(), o == null ? g2.create(h.NA) : n === 0 ? t.slice([o.row, o.row + 1]) : t.slice(void 0, [o.column, o.column + 1]);
  }
  orderSearchExpand(i, e, t, r = xe.MIN, n = false, s = 0) {
    const o = e.orderSearch(i, r, n);
    return o == null ? g2.create(h.NA) : s === 0 ? t.slice([o.row, o.row + 1]) : t.slice(void 0, [o.column, o.column + 1]);
  }
  flattenArray(i, e = true) {
    const t = [];
    t[0] = [];
    for (let r = 0; r < i.length; r++) {
      let n = i[r];
      if ((n.isString() || n.isBoolean() || n.isNull()) && (n = n.convertToNumberObjectValue()), n.isError())
        return n;
      if (n.isArray()) {
        let s;
        if (n.iterator((o) => {
          if (o == null || o.isNull() || e && (o.isString() || o.isBoolean()))
            return true;
          if (o = this._includingLogicalValuesAndText(o), o.isError())
            return s = o, false;
          t[0].push(o);
        }), s != null && s.isError())
          return s;
      } else
        t[0].push(n);
    }
    return mt(t, 1, t[0].length);
  }
  _includingLogicalValuesAndText(i) {
    if (i.isBoolean() && (i = Mm(i)), i.isString()) {
      const e = Number(i.getValue());
      i = y2.create(Number.isNaN(e) ? 0 : e);
    }
    return i;
  }
  createReferenceObject(i, e) {
    const t = i.getForcedUnitId() || i.getDefaultUnitId() || "", r = i.getForcedSheetId() || i.getDefaultUnitId() || "", n = i.getForcedSheetName(), o = Ts2({
      unitId: t,
      sheetName: n,
      range: e
    });
    let u;
    return qr(o) ? u = new Ma(o) : Eo(o) ? u = new wa(o) : Ro(o) ? u = new Da(o) : u = new xn(e, r, t), this._setReferenceDefault(i, u);
  }
  _setReferenceDefault(i, e) {
    if (this.unitId == null || this.subUnitId == null)
      return g2.create(h.REF);
    e.setDefaultUnitId(this.unitId), e.setDefaultSheetId(this.subUnitId);
    const t = i.getUnitId();
    t != null && e.setForcedUnitIdDirect(t);
    const r = i.getForcedSheetId();
    return r != null && e.setForcedSheetIdDirect(r), e.setForcedSheetName(i.getForcedSheetName()), e.setUnitData(i.getUnitData()), e.setRuntimeData(i.getRuntimeData()), e.setArrayFormulaCellData(i.getArrayFormulaCellData()), e.setUnitStylesData(i.getUnitStylesData()), e;
  }
};
var Ph = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    if (e.isError())
      return e;
    const { isError: n, errorObject: s, variants: o } = zr(t, r);
    if (n)
      return s;
    const { isError: u, errorObject: c, variants: l } = I2(...o);
    if (u)
      return c;
    const [f2, m2] = l, d2 = Math.floor(+f2.getValue()), _2 = Math.floor(+m2.getValue());
    if (d2 < 0 || _2 < 0)
      return g2.create(h.NUM);
    if (d2 === 0 || _2 === 0)
      return g2.create(h.REF);
    const C = e.isArray() ? e.getRowCount() : 1, E = e.isArray() ? e.getColumnCount() : 1;
    if (C === 1 && E === 1)
      return e.isArray() ? e.get(0, 0) : e;
    const R = d2 > C ? C : d2, b = _2 > E ? E : _2;
    return e.slice([0, R], [0, b]);
  }
};
var xh = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const n = e[r], s = n.isArray() ? n.getRowCount() : 1, o = n.isArray() ? n.getColumnCount() : 1;
      for (let u = 0; u < s; u++)
        for (let c = 0; c < o; c++) {
          const l = n.isArray() ? n.get(u, c) : n;
          t.push([l]);
        }
    }
    return K2.create({
      calculateValueList: t,
      rowCount: t.length,
      columnCount: 1,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
};
var ca = ((a2) => (a2.ARRAY_CONSTRAIN = "ARRAY_CONSTRAIN", a2.FLATTEN = "FLATTEN", a2))(ca || {});
var jh = [
  [Ph, ca.ARRAY_CONSTRAIN],
  [xh, ca.FLATTEN]
];
var Or;
((a2) => {
  const i = 0.636619772;
  function e(n, s) {
    let o = 0;
    for (let u = 0; u < n.length; ++u)
      o = s * o + n[u];
    return o;
  }
  function t(n, s, o, u, c) {
    if (s === 0)
      return o;
    if (s === 1)
      return u;
    const l = 2 / n;
    let f2 = o, m2 = u, d2 = u;
    for (let _2 = 1; _2 < s; ++_2)
      d2 = m2 * _2 * l + c * f2, f2 = m2, m2 = d2;
    return d2;
  }
  function r(n, s, o, u) {
    return function(l, f2) {
      if (o) {
        if (l === 0)
          return o === 1 ? -1 / 0 : 1 / 0;
        if (l < 0)
          return Number.NaN;
      }
      if (f2 === 0)
        return n(l);
      if (f2 === 1)
        return s(l);
      if (f2 < 0)
        return Number.NaN;
      const m2 = f2 | 0, d2 = n(l), _2 = s(l);
      return t(l, m2, d2, _2, u);
    };
  }
  a2.besselj = /* @__PURE__ */ (() => {
    const n = [-184.9052456, 77392.33017, -1121442418e-2, 6516196407e-1, -13362590354, 57568490574], s = [1, 267.8532712, 59272.64853, 9494680718e-3, 1029532985, 57568490411], o = [2093887211e-16, -2073370639e-15, 2734510407e-14, -0.001098628627, 1], u = [-934935152e-16, 7621095161e-16, -6911147651e-15, 1430488765e-13, -0.01562499995];
    function c(C) {
      let E = 0, R = 0, b = 0, p2 = C * C;
      if (C < 8)
        R = e(n, p2), b = e(s, p2), E = R / b;
      else {
        const V = C - 0.785398164;
        p2 = 64 / p2, R = e(o, p2), b = e(u, p2), E = Math.sqrt(i / C) * (Math.cos(V) * R - Math.sin(V) * b * 8 / C);
      }
      return E;
    }
    const l = [-30.16036606, 15704.4826, -2972611439e-3, 2423968531e-1, -7895059235, 72362614232], f2 = [1, 376.9991397, 99447.43394, 1858330474e-2, 2300535178, 144725228442], m2 = [-240337019e-15, 2457520174e-15, -3516396496e-14, 183105e-8, 1], d2 = [105787412e-15, -88228987e-14, 8449199096e-15, -2002690873e-13, 0.04687499995];
    function _2(C) {
      let E = 0, R = 0, b = 0, p2 = C * C;
      const V = Math.abs(C) - 2.356194491;
      return Math.abs(C) < 8 ? (R = C * e(l, p2), b = e(f2, p2), E = R / b) : (p2 = 64 / p2, R = e(m2, p2), b = e(d2, p2), E = Math.sqrt(i / Math.abs(C)) * (Math.cos(V) * R - Math.sin(V) * b * 8 / Math.abs(C)), C < 0 && (E = -E)), E;
    }
    return function C(E, R) {
      const b = Math.round(R);
      if (!Number.isFinite(E))
        return Number.isNaN(E) ? E : 0;
      if (b < 0)
        return (b % 2 ? -1 : 1) * C(E, -b);
      if (E < 0)
        return (b % 2 ? -1 : 1) * C(-E, b);
      if (b === 0)
        return c(E);
      if (b === 1)
        return _2(E);
      if (E === 0)
        return 0;
      let p2 = 0;
      if (E > b)
        p2 = t(E, b, c(E), _2(E), -1);
      else {
        const V = 2 * Math.floor((b + Math.floor(Math.sqrt(40 * b))) / 2);
        let S2 = false, M2 = 0, D2 = 0, w = 1, L = 0;
        const v = 2 / E;
        for (let j2 = V; j2 > 0; j2--)
          if (L = j2 * v * w - M2, M2 = w, w = L, Math.abs(w) > 1e10 && (w *= 1e-10, M2 *= 1e-10, p2 *= 1e-10, D2 *= 1e-10), S2 && (D2 += w), S2 = !S2, j2 === b && (p2 = M2), V - j2 > 100 && p2 === 0)
            return Number.NaN;
        D2 = 2 * D2 - w, p2 /= D2;
      }
      return p2;
    };
  })(), a2.bessely = (() => {
    const n = [228.4622733, -86327.92757, 1087988129e-2, -5123598036e-1, 7062834065, -2957821389], s = [1, 226.1030244, 47447.2647, 7189466438e-3, 7452499648e-1, 40076544269], o = [2093887211e-16, -2073370639e-15, 2734510407e-14, -0.001098628627, 1], u = [-934945152e-16, 7621095161e-16, -6911147651e-15, 1430488765e-13, -0.01562499995];
    function c(C) {
      let E = 0, R = 0, b = 0, p2 = C * C;
      const V = C - 0.785398164;
      return C < 8 ? (R = e(n, p2), b = e(s, p2), E = R / b + i * (0, a2.besselj)(C, 0) * Math.log(C)) : (p2 = 64 / p2, R = e(o, p2), b = e(u, p2), E = Math.sqrt(i / C) * (Math.sin(V) * R + Math.cos(V) * b * 8 / C)), E;
    }
    const l = [8511.937935, -4237922726e-3, 7349264551e-1, -51534381390, 127527439e4, -4900604943e3], f2 = [1, 354.9632885, 102042.605, 2245904002e-2, 3733650367, 424441966400, 249958057e5], m2 = [-240337019e-15, 2457520174e-15, -3516396496e-14, 183105e-8, 1], d2 = [105787412e-15, -88228987e-14, 8449199096e-15, -2002690873e-13, 0.04687499995];
    function _2(C) {
      let E = 0, R = 0, b = 0, p2 = C * C;
      const V = C - 2.356194491;
      return C < 8 ? (R = C * e(l, p2), b = e(f2, p2), E = R / b + i * ((0, a2.besselj)(C, 1) * Math.log(C) - 1 / C)) : (p2 = 64 / p2, R = e(m2, p2), b = e(d2, p2), E = Math.sqrt(i / C) * (Math.sin(V) * R + Math.cos(V) * b * 8 / C)), E;
    }
    return r(c, _2, 1, -1);
  })(), a2.besseli = /* @__PURE__ */ (() => {
    const n = [45813e-7, 0.0360768, 0.2659732, 1.2067492, 3.0899424, 3.5156229, 1], s = [392377e-8, -0.01647633, 0.02635537, -0.02057706, 916281e-8, -157565e-8, 225319e-8, 0.01328592, 0.39894228];
    function o(f2) {
      return f2 <= 3.75 ? e(n, f2 * f2 / (3.75 * 3.75)) : Math.exp(Math.abs(f2)) / Math.sqrt(Math.abs(f2)) * e(s, 3.75 / Math.abs(f2));
    }
    const u = [32411e-8, 301532e-8, 0.02658733, 0.15084934, 0.51498869, 0.87890594, 0.5], c = [-420059e-8, 0.01787654, -0.02895312, 0.02282967, -0.01031555, 163801e-8, -362018e-8, -0.03988024, 0.39894228];
    function l(f2) {
      return f2 < 3.75 ? f2 * e(u, f2 * f2 / (3.75 * 3.75)) : (f2 < 0 ? -1 : 1) * Math.exp(Math.abs(f2)) / Math.sqrt(Math.abs(f2)) * e(c, 3.75 / Math.abs(f2));
    }
    return function f2(m2, d2) {
      const _2 = Math.round(d2);
      if (_2 === 0)
        return o(m2);
      if (_2 === 1)
        return l(m2);
      if (_2 < 0)
        return Number.NaN;
      if (Math.abs(m2) === 0)
        return 0;
      if (m2 === 1 / 0)
        return 1 / 0;
      let C = 0, E;
      const R = 2 / Math.abs(m2);
      let b = 0, p2 = 1, V = 0;
      const S2 = 2 * Math.round((_2 + Math.round(Math.sqrt(40 * _2))) / 2);
      for (E = S2; E > 0; E--)
        if (V = E * R * p2 + b, b = p2, p2 = V, Math.abs(p2) > 1e10 && (p2 *= 1e-10, b *= 1e-10, C *= 1e-10), E === _2 && (C = b), S2 - E > 100 && C === 0)
          return Number.NaN;
      return C *= f2(m2, 0) / p2, m2 < 0 && _2 % 2 ? -C : C;
    };
  })(), a2.besselk = (() => {
    const n = [74e-7, 1075e-7, 262698e-8, 0.0348859, 0.23069756, 0.4227842, -0.57721566], s = [53208e-8, -25154e-7, 587872e-8, -0.01062446, 0.02189568, -0.07832358, 1.25331414];
    function o(f2) {
      return f2 <= 2 ? -Math.log(f2 / 2) * (0, a2.besseli)(f2, 0) + e(n, f2 * f2 / 4) : Math.exp(-f2) / Math.sqrt(f2) * e(s, 2 / f2);
    }
    const u = [-4686e-8, -110404e-8, -0.01919402, -0.18156897, -0.67278579, 0.15443144, 1], c = [-68245e-8, 325614e-8, -780353e-8, 0.01504268, -0.0365562, 0.23498619, 1.25331414];
    function l(f2) {
      return f2 <= 2 ? Math.log(f2 / 2) * (0, a2.besseli)(f2, 1) + 1 / f2 * e(u, f2 * f2 / 4) : Math.exp(-f2) / Math.sqrt(f2) * e(c, 2 / f2);
    }
    return r(o, l, 2, 1);
  })();
})(Or || (Or = {}));
function Ua(a2) {
  return /^[01]{1,10}$/.test(a2);
}
function va(a2) {
  return /^[0-7]{1,10}$/.test(a2);
}
function Ta(a2) {
  return /^[0-9A-Fa-f]{1,10}$/.test(a2);
}
function nr(a2) {
  if (a2 === 0)
    return 0;
  const i = [
    -1.3026537197817094,
    // eslint-disable-next-line no-loss-of-precision
    0.6419697923564902,
    0.019476473204185836,
    -0.00956151478680863,
    -946595344482036e-18,
    366839497852761e-18,
    42523324806907e-18,
    -20278578112534e-18,
    -1624290004647e-18,
    130365583558e-17,
    15626441722e-18,
    -85238095915e-18,
    6529054439e-18,
    5059343495e-18,
    -991364156e-18,
    -227365122e-18,
    96467911e-18,
    2394038e-18,
    -6886027e-18,
    894487e-18,
    313092e-18,
    -112708e-18,
    381e-18,
    7106e-18,
    -1523e-18,
    -94e-18,
    121e-18,
    -28e-18
  ];
  let e = a2, t = false;
  e < 0 && (e = -e, t = true);
  const r = 2 / (2 + e), n = 4 * r - 2;
  let s = 0, o = 0, u;
  for (let l = i.length - 1; l > 0; l--)
    u = s, s = n * s - o + i[l], o = u;
  const c = r * Math.exp(-e * e + 0.5 * (i[0] + n * s) - o);
  return t ? c - 1 : 1 - c;
}
function Ia(a2) {
  return 1 - nr(a2);
}
function Uh(a2) {
  if (a2 >= 2)
    return -100;
  if (a2 <= 0)
    return 100;
  const i = a2 < 1 ? a2 : 2 - a2, e = Math.sqrt(-2 * Math.log(i / 2));
  let t = -0.70711 * ((2.30753 + e * 0.27061) / (1 + e * (0.99229 + e * 0.04481)) - e);
  for (let r = 0; r < 2; r++) {
    const n = Ia(t) - i;
    t += n / (1.1283791670955126 * Math.exp(-t * t) - t * n);
  }
  return a2 < 1 ? t : -t;
}
function Ar(a2, i = 1) {
  let e = Math.floor(a2);
  if (a2 < 0)
    return Number.NaN;
  let t = 1;
  for (; e > 1 && Number.isFinite(t); )
    t *= e, e -= i;
  return t;
}
function sr(a2, i) {
  const e = Math.min(a2 - i, i);
  let t = 1;
  for (let r = 1; r <= e && Number.isFinite(t); r++)
    t *= a2 - r + 1, t /= r;
  return t;
}
function la(a2, i) {
  let e = Math.floor(a2), t = Math.floor(i);
  for (; t !== 0; ) {
    const r = t;
    t = e % t, e = r;
  }
  return e;
}
function Qi(a2, i) {
  const e = la(a2, i);
  return e === 0 ? 0 : Math.abs(a2 * i) / e;
}
function Ba(a2) {
  const i = a2.length;
  if (i === 1)
    return a2[0][0];
  if (i === 2)
    return a2[0][0] * a2[1][1] - a2[0][1] * a2[1][0];
  const { rowSwap: e, smallPivotDetected: t, luMatrix: r, permutation: n } = au(a2);
  if (t)
    return 0;
  let s = e ? 1 : -1;
  for (let o = 0; o < n.length; o++)
    s *= r[o][o];
  return s === 0 ? 0 : s;
}
function vh(a2) {
  const i = Ba(a2);
  return i === 0 ? null : a2.length === 1 ? [[1 / i]] : Ih(a2).map((r) => r.map((n) => n / i));
}
function Th(a2, i, e) {
  return a2.filter((t, r) => r !== i).map((t) => t.filter((r, n) => n !== e));
}
function Ih(a2) {
  const i = a2.length, e = Array.from({ length: i }, () => new Array(i).fill(0));
  for (let t = 0; t < i; t++)
    for (let r = 0; r < i; r++) {
      const s = ((t + r) % 2 === 0 ? 1 : -1) * Ba(Th(a2, t, r));
      e[r][t] = s === 0 ? 0 : s;
    }
  return e;
}
function Er(a2, i) {
  return a2.map((e) => i[0].map(
    (t, r) => e.reduce((n, s, o) => n + s * i[o][r], 0)
  ));
}
function Rt(a2) {
  return a2[0].map((i, e) => a2.map((t) => t[e]));
}
function Bh(a2) {
  const { smallPivotDetected: i, luMatrix: e, permutation: t } = au(a2);
  return i ? null : Fh(e, t);
}
function au(a2) {
  const i = Rt(a2), e = i.length, t = i[0].length;
  let r = true, n = false;
  const s = fa(e, t, 0), o = new Array(t).fill(0).map((u, c) => c);
  for (let u = 0; u < t; u++) {
    for (let m2 = 0; m2 < u; m2++) {
      let d2 = i[m2][u];
      for (let _2 = 0; _2 < m2; _2++)
        d2 -= s[m2][_2] * s[_2][u];
      s[m2][u] = d2;
    }
    let c = -1 / 0, l = u;
    for (let m2 = u; m2 < e; m2++) {
      let d2 = i[m2][u];
      for (let C = 0; C < u; C++)
        d2 -= s[m2][C] * s[C][u];
      s[m2][u] = d2;
      const _2 = Math.abs(d2);
      _2 > c && (c = _2, l = m2);
    }
    if (Math.abs(s[l][u]) < 1e-11) {
      n = true;
      break;
    }
    l !== u && ([s[u], s[l]] = [s[l], s[u]], [i[u], i[l]] = [i[l], i[u]], [o[u], o[l]] = [o[l], o[u]], r = !r);
    const f2 = s[u][u];
    for (let m2 = u + 1; m2 < e; m2++)
      s[m2][u] /= f2;
  }
  return {
    rowSwap: r,
    smallPivotDetected: n,
    luMatrix: s,
    permutation: o
  };
}
function Fh(a2, i) {
  const e = i.length, t = fa(e, e, 0);
  for (let n = 0; n < e; n++)
    t[n][n] = 1;
  const r = fa(e, e, 0);
  for (let n = 0; n < e; n++) {
    const s = i[n];
    for (let o = 0; o < e; o++)
      r[n][o] = t[s][o];
  }
  for (let n = 0; n < e; n++) {
    const s = r[n];
    for (let o = n + 1; o < e; o++) {
      const u = a2[o][n];
      for (let c = 0; c < e; c++)
        r[o][c] -= s[c] * u;
    }
  }
  for (let n = e - 1; n >= 0; n--) {
    const s = r[n], o = a2[n][n];
    for (let u = 0; u < e; u++)
      s[u] /= o;
    for (let u = 0; u < n; u++) {
      const c = a2[u][n];
      for (let l = 0; l < e; l++)
        r[u][l] -= s[l] * c;
    }
  }
  return r;
}
function fa(a2, i, e) {
  const t = [];
  for (let r = 0; r < a2; r++) {
    t[r] = [];
    for (let n = 0; n < i; n++)
      t[r].push(e);
  }
  return t;
}
function kh(a2) {
  const i = $h(a2);
  if (!i)
    return null;
  const { matrixU: e, matrixS: t, matrixV: r } = i, n = Rt(e), s = Array.from({ length: t.length }, () => new Array(a2[0].length).fill(0)), o = Math.max(a2.length, a2[0].length) * Number.EPSILON * t[0];
  for (let u = 0; u < t.length; u++)
    Math.abs(t[u]) > o && (s[u][u] = 1 / t[u]);
  return Er(r, Er(s, n));
}
function $h(a2) {
  const i = Rt(a2), e = i.length, t = i[0].length;
  if (e < t)
    return null;
  const r = new Array(t).fill(0), n = new Array(t).fill(0), s = Array.from({ length: t }, () => new Array(t).fill(0));
  let o = Number.EPSILON, u = 0, c = 0, l = 0;
  for (let C = 0; C < t; C++) {
    if (r[C] = u, c = Ls2(i, C, e, C, C), c <= 1e-64 / o)
      u = 0;
    else {
      u = Math.sqrt(c), i[C][C] >= 0 && (u = -u);
      const R = i[C][C] * u - c;
      i[C][C] -= u;
      for (let b = C + 1; b < t; b++) {
        c = Ls2(i, C, e, C, b);
        for (let p2 = C; p2 < e; p2++)
          i[p2][b] += c / R * i[p2][C];
      }
    }
    if (n[C] = u, c = qi(i, C + 1, t, C, C), c <= 1e-64 / o)
      u = 0;
    else {
      u = Math.sqrt(c), i[C][C + 1] >= 0 && (u = -u);
      const R = i[C][C + 1] * u - c;
      i[C][C + 1] -= u;
      for (let b = C + 1; b < t; b++)
        r[b] = i[C][b] / R;
      for (let b = C + 1; b < e; b++) {
        c = qi(i, C + 1, t, b, C);
        for (let p2 = C + 1; p2 < t; p2++)
          i[b][p2] += c * r[p2];
      }
    }
    const E = Math.abs(n[C]) + Math.abs(r[C]);
    E > l && (l = E);
  }
  let f2 = 0;
  for (let C = t - 1; C >= 0; C--) {
    if (u !== 0) {
      for (let E = f2; E < t; E++)
        s[E][C] = i[C][E] / (u * i[C][C + 1]);
      for (let E = f2; E < t; E++) {
        c = 0;
        for (let R = f2; R < t; R++)
          c += i[C][R] * s[R][E];
        for (let R = f2; R < t; R++)
          s[R][E] += c * s[R][C];
      }
    }
    for (let E = f2; E < t; E++)
      s[C][E] = 0, s[E][C] = 0;
    s[C][C] = 1, u = r[C], f2 = C;
  }
  for (let C = t - 1; C >= 0; C--) {
    u = n[C];
    for (let E = C + 1; E < t; E++)
      i[C][E] = 0;
    if (u !== 0) {
      for (let E = C + 1; E < t; E++) {
        c = Ls2(i, C + 1, e, C, E);
        for (let R = C; R < e; R++)
          i[R][E] += c / (i[C][C] * u) * i[R][C];
      }
      for (let E = C; E < e; E++)
        i[E][C] /= u;
    } else
      for (let E = C; E < e; E++)
        i[E][C] = 0;
    i[C][C] += 1;
  }
  o *= l;
  let m2 = 0, d2 = 0, _2 = 0;
  for (let C = t - 1; C >= 0; C--)
    for (let E = 0; E < 50; E++) {
      let R = false, b = C;
      for (; b >= 0; b--) {
        if (Math.abs(r[b]) <= o) {
          R = true;
          break;
        }
        if (Math.abs(n[b - 1]) <= o)
          break;
      }
      if (!R) {
        let M2 = 0, D2 = 1;
        for (let w = b; w < C + 1 && (m2 = D2 * r[w], d2 = n[w], r[w] *= M2, !(Math.abs(m2) <= o)); w++) {
          _2 = ln(m2, d2), n[w] = _2, M2 = d2 / _2, D2 = -m2 / _2;
          for (let L = 0; L < e; L++) {
            const v = i[L][b - 1], j2 = i[L][w];
            i[L][b - 1] = v * M2 + j2 * D2, i[L][w] = -v * D2 + j2 * M2;
          }
        }
      }
      if (b === C) {
        if (n[C] < 0) {
          n[C] = -n[C];
          for (let M2 = 0; M2 < t; M2++)
            s[M2][C] = -s[M2][C];
        }
        break;
      }
      if (E >= 49)
        return null;
      let p2 = n[b];
      m2 = ((n[C - 1] - n[C]) * (n[C - 1] + n[C]) + (r[C - 1] - r[C]) * (r[C - 1] + r[C])) / (2 * r[C] * n[C - 1]), _2 = ln(m2, 1), m2 < 0 ? m2 = ((p2 - n[C]) * (p2 + n[C]) + r[C] * (n[C - 1] / (m2 - _2) - r[C])) / p2 : m2 = ((p2 - n[C]) * (p2 + n[C]) + r[C] * (n[C - 1] / (m2 + _2) - r[C])) / p2;
      let V = 1, S2 = 1;
      for (let M2 = b + 1; M2 < C + 1; M2++) {
        let D2 = r[M2], w = n[M2];
        d2 = S2 * D2, D2 *= V, _2 = ln(m2, d2), r[M2 - 1] = _2, V = m2 / _2, S2 = d2 / _2, m2 = p2 * V + D2 * S2, d2 = w * S2, D2 = -p2 * S2 + D2 * V, w *= V;
        for (let L = 0; L < t; L++) {
          const v = s[L][M2 - 1], j2 = s[L][M2];
          s[L][M2 - 1] = v * V + j2 * S2, s[L][M2] = -v * S2 + j2 * V;
        }
        _2 = ln(m2, d2), n[M2 - 1] = _2, V = m2 / _2, S2 = d2 / _2, m2 = V * D2 + S2 * w, p2 = -S2 * D2 + V * w;
        for (let L = 0; L < e; L++) {
          const v = i[L][M2 - 1], j2 = i[L][M2];
          i[L][M2 - 1] = v * V + j2 * S2, i[L][M2] = -v * S2 + j2 * V;
        }
      }
      r[b] = 0, r[C] = m2, n[C] = p2;
    }
  for (let C = 0; C < n.length; C++)
    n[C] < o && (n[C] = 0);
  for (let C = 0; C < t; C++)
    for (let E = C - 1; E >= 0; E--)
      if (n[E] < n[C]) {
        const R = n[E];
        n[E] = n[C], n[C] = R;
        for (let b = 0; b < i.length; b++) {
          const p2 = i[b][C];
          i[b][C] = i[b][E], i[b][E] = p2;
        }
        for (let b = 0; b < s.length; b++) {
          const p2 = s[b][C];
          s[b][C] = s[b][E], s[b][E] = p2;
        }
        C = E;
      }
  return {
    matrixU: i,
    matrixS: n,
    matrixV: s
  };
}
function ln(a2, i) {
  let e = 0;
  return Math.abs(a2) > Math.abs(i) ? (e = i / a2, Math.abs(a2) * Math.sqrt(1 + e * e)) : i !== 0 ? (e = a2 / i, Math.abs(i) * Math.sqrt(1 + e * e)) : 0;
}
function Ls2(a2, i, e, t, r) {
  let n = 0;
  for (let s = i; s < e; s++)
    n += a2[s][t] * a2[s][r];
  return n;
}
function qi(a2, i, e, t, r) {
  let n = 0;
  for (let s = i; s < e; s++)
    n += a2[t][s] * a2[r][s];
  return n;
}
var fn = /* @__PURE__ */ new Map([
  ["I", 1],
  ["V", 5],
  ["X", 10],
  ["L", 50],
  ["C", 100],
  ["D", 500],
  ["M", 1e3]
]);
var Yh = /* @__PURE__ */ new Map([
  [1, "I"],
  [4, "IV"],
  [5, "V"],
  [9, "IX"],
  [10, "X"],
  [40, "XL"],
  [45, "VL"],
  [49, "IL"],
  [50, "L"],
  [90, "XC"],
  [95, "VC"],
  [99, "IC"],
  [100, "C"],
  [400, "CD"],
  [450, "LD"],
  [490, "XD"],
  [495, "VD"],
  [499, "ID"],
  [500, "D"],
  [900, "CM"],
  [950, "LM"],
  [990, "XM"],
  [995, "VM"],
  [999, "IM"],
  [1e3, "M"]
]);
var Hh = [
  [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1e3, 4e3],
  [1, 4, 5, 9, 10, 40, 45, 50, 90, 95, 100, 400, 450, 500, 900, 950, 1e3, 4e3],
  [1, 4, 5, 9, 10, 40, 45, 49, 50, 90, 95, 99, 100, 400, 450, 490, 500, 900, 950, 990, 1e3, 4e3],
  [1, 4, 5, 9, 10, 40, 45, 49, 50, 90, 95, 99, 100, 400, 450, 490, 495, 500, 900, 950, 990, 995, 1e3, 4e3],
  [1, 4, 5, 9, 10, 40, 45, 49, 50, 90, 95, 99, 100, 400, 450, 490, 495, 499, 500, 900, 950, 990, 995, 999, 1e3, 4e3]
];
function iu(a2, i, e) {
  return a2 <= 0 ? 0 : a2 >= 1 ? 1 : ls(a2, i, e);
}
function Gh(a2, i, e) {
  return a2 <= 0 || a2 >= 1 ? 0 : i === 1 && e === 1 ? 1 : i < 512 && e < 512 ? __pow(a2, i - 1) * __pow(1 - a2, e - 1) / ka(i, e) : Math.exp((i - 1) * Math.log(a2) + (e - 1) * Math.log(1 - a2) - $a(i, e));
}
function Fa(a2, i, e) {
  if (a2 <= 0)
    return 0;
  if (a2 >= 1)
    return 1;
  const t = 1e-8;
  let r;
  if (i >= 1 && e >= 1) {
    const c = a2 < 0.5 ? a2 : 1 - a2, l = Math.sqrt(-2 * Math.log(c));
    r = (2.30753 + l * 0.27061) / (1 + l * (0.99229 + l * 0.04481)) - l, a2 < 0.5 && (r = -r);
    const f2 = (r * r - 3) / 6, m2 = 2 / (1 / (2 * i - 1) + 1 / (2 * e - 1)), d2 = r * Math.sqrt(f2 + m2) / m2 - (1 / (2 * e - 1) - 1 / (2 * i - 1)) * (f2 + 5 / 6 - 2 / (3 * m2));
    r = i / (i + e * Math.exp(2 * d2));
  } else {
    const c = Math.exp(i * Math.log(i / (i + e))) / i, l = Math.exp(e * Math.log(e / (i + e))) / e, f2 = c + l;
    a2 < c / f2 ? r = __pow(i * f2 * a2, 1 / i) : r = 1 - __pow(e * f2 * (1 - a2), 1 / e);
  }
  const n = -$a(i, e);
  let s, o, u;
  for (let c = 0; c < 10; c++) {
    if (r === 0 || r === 1)
      return r;
    if (s = ls(r, i, e) - a2, o = Math.exp((i - 1) * Math.log(r) + (e - 1) * Math.log(1 - r) + n), u = s / o, r -= o = u / (1 - 0.5 * Math.min(1, u * ((i - 1) / r - (e - 1) / (1 - r)))), r <= 0 && (r = 0.5 * (r + o)), r >= 1 && (r = 0.5 * (r + o + 1)), Math.abs(o) < t * r && c > 0)
      break;
  }
  return r;
}
function ls(a2, i, e) {
  const t = a2 === 0 || a2 === 1 ? 0 : Math.exp(dt(i + e) - dt(i) - dt(e) + i * Math.log(a2) + e * Math.log(1 - a2));
  return a2 < (i + 1) / (i + e + 2) ? t * Xi(a2, i, e) / i : 1 - t * Xi(1 - a2, e, i) / e;
}
function Xi(a2, i, e) {
  let n = 1 - (i + e) * a2 / (i + 1);
  Math.abs(n) < 1e-8 && (n = 1e-8), n = 1 / n;
  let s = 1, o = n;
  for (let u = 1; u <= 100; u++) {
    let c = u * (e - u) * a2 / ((i - 1 + u * 2) * (i + u * 2));
    if (n = 1 + c * n, Math.abs(n) < 1e-8 && (n = 1e-8), s = 1 + c / s, Math.abs(s) < 1e-8 && (s = 1e-8), n = 1 / n, o *= n * s, c = -(i + u) * (i + e + u) * a2 / ((i + u * 2) * (i + 1 + u * 2)), n = 1 + c * n, Math.abs(n) < 1e-8 && (n = 1e-8), s = 1 + c / s, Math.abs(s) < 1e-8 && (s = 1e-8), n = 1 / n, o *= n * s, Math.abs(n * s - 1) < 1e-8)
      break;
  }
  return o;
}
function ka(a2, i) {
  return a2 + i > 170 ? Math.exp($a(a2, i)) : yn(a2) * yn(i) / yn(a2 + i);
}
function $a(a2, i) {
  return dt(a2) + dt(i) - dt(a2 + i);
}
function ou(a2, i, e) {
  if (a2 < 0)
    return 0;
  if (a2 >= i)
    return 1;
  if (e < 0 || e > 1 || i <= 0)
    return Number.NaN;
  let t = 0;
  for (let r = 0; r <= a2; r++)
    t += Ya(r, i, e);
  return t;
}
function Ya(a2, i, e) {
  return e === 0 || e === 1 ? i * e === a2 ? 1 : 0 : sr(i, a2) * __pow(e, a2) * __pow(1 - e, i - a2);
}
function Ha(a2, i) {
  return a2 <= 0 ? 0 : Wa(i / 2, a2 / 2);
}
function Wh(a2, i) {
  return a2 < 0 ? 0 : a2 === 0 && i === 2 ? 0.5 : Math.exp((i / 2 - 1) * Math.log(a2) - a2 / 2 - i / 2 * Math.log(2) - dt(i / 2));
}
function uu(a2, i) {
  return a2 <= 0 ? 0 : a2 >= 1 ? 1 / 0 : 2 * fu(a2, i / 2);
}
function Ga(a2, i, e) {
  return a2 < 0 ? 0 : ls(i * a2 / (i * a2 + e), i / 2, e / 2);
}
function Qh(a2, i, e) {
  if (a2 < 0)
    return 0;
  if (a2 === 0 && i < 2)
    return 1 / 0;
  if (a2 === 0 && i === 2)
    return 1;
  let t = 1 / ka(i / 2, e / 2);
  return t *= __pow(i / e, i / 2), t *= __pow(a2, i / 2 - 1), t *= __pow(1 + i / e * a2, -(i + e) / 2), t;
}
function cu(a2, i, e) {
  return a2 <= 0 ? 0 : a2 >= 1 ? 1 / 0 : e / (i * (1 / Fa(a2, i / 2, e / 2) - 1));
}
function qh(a2, i) {
  return a2 < 0 ? 0 : 1 - Math.exp(-i * a2);
}
function Xh(a2, i) {
  return a2 < 0 ? 0 : i * Math.exp(-i * a2);
}
function lu(a2, i, e) {
  const t = i.length;
  let r = 0, n = 0;
  for (let m2 = 0; m2 < t; m2++)
    r += i[m2], n += e[m2];
  const s = r / t, o = n / t;
  let u = 0, c = 0;
  for (let m2 = 0; m2 < t; m2++)
    u += (i[m2] - s) * (e[m2] - o), c += __pow(e[m2] - o, 2);
  if (c === 0)
    return 1 / 0;
  const l = u / c;
  return s - l * o + l * a2;
}
function yn(a2) {
  const i = [
    -1.716185138865495,
    24.76565080557592,
    -379.80425647094563,
    629.3311553128184,
    866.9662027904133,
    -31451.272968848367,
    -36144.413418691176,
    66456.14382024054
  ], e = [
    -30.8402300119739,
    315.35062697960416,
    -1015.1563674902192,
    -3107.771671572311,
    // eslint-disable-next-line no-loss-of-precision
    22538.11842098015,
    // eslint-disable-next-line no-loss-of-precision
    4755.846277527881,
    -134659.9598649693,
    -115132.2596755535
  ];
  let t = 0, r = a2;
  if (a2 > 171.6243769536076)
    return 1 / 0;
  if (r <= 0) {
    const f2 = r % 1 + 36e-17;
    if (f2)
      t = (r & 1 ? -1 : 1) * Math.PI / Math.sin(Math.PI * f2), r = 1 - r;
    else
      return 1 / 0;
  }
  const n = r;
  let s = 0, o;
  r < 1 ? o = r++ : o = (r -= s = (r | 0) - 1) - 1;
  let u = 0, c = 0;
  for (let f2 = 0; f2 < 8; ++f2)
    u = (u + i[f2]) * o, c = c * o + e[f2];
  let l = u / c + 1;
  if (n < r)
    l /= n;
  else if (n > r)
    for (let f2 = 0; f2 < s; ++f2)
      l *= r, r++;
  return t && (l = t / l), l;
}
function Kh(a2, i, e) {
  return a2 <= 0 ? 0 : Wa(i, a2 / e);
}
function Zh(a2, i, e) {
  return a2 < 0 ? 0 : a2 === 0 && i === 1 ? 1 / e : Math.exp((i - 1) * Math.log(a2) - a2 / e - dt(i) - i * Math.log(e));
}
function zh(a2, i, e) {
  return a2 <= 0 ? 0 : a2 >= 1 ? 1 / 0 : e * fu(a2, i);
}
function dt(a2) {
  const i = [
    76.18009172947146,
    -86.50532032941678,
    24.01409824083091,
    // eslint-disable-line
    -1.231739572450155,
    0.001208650973866179,
    -5395239384953e-18
  ];
  let e = a2, t = a2 + 5.5;
  t -= (a2 + 0.5) * Math.log(t);
  let r = 1.000000000190015;
  for (let n = 0; n < 6; n++)
    r += i[n] / ++e;
  return -t + Math.log(2.5066282746310007 * r / a2);
}
function Wa(a2, i) {
  if (i < 0 || a2 <= 0)
    return Number.NaN;
  const e = 1e-30, t = -~(Math.log(a2 >= 1 ? a2 : 1 / a2) * 8.5 + a2 * 0.4 + 17), r = dt(a2), n = Math.exp(-i + a2 * Math.log(i) - r);
  let s = a2, o = 1 / a2, u = o;
  if (i < a2 + 1) {
    if (n === 0)
      return 0;
    for (let d2 = 1; d2 <= t && (o += u *= i / ++s, !(Math.abs(u) < Math.abs(o) * e)); d2++)
      ;
    return o * n;
  }
  if (n === 0)
    return 1;
  let c = i + 1 - a2, l = 1 / e, f2 = 1 / c, m2 = f2;
  for (let d2 = 1; d2 <= t; d2++) {
    const _2 = -d2 * (d2 - a2);
    if (c += 2, f2 = _2 * f2 + c, Math.abs(f2) < e && (f2 = e), l = c + _2 / l, Math.abs(l) < e && (l = e), f2 = 1 / f2, m2 *= f2 * l, Math.abs(f2 * l - 1) < e)
      break;
  }
  return 1 - m2 * n;
}
function fu(a2, i) {
  if (a2 <= 0)
    return 0;
  if (a2 >= 1)
    return Math.max(100, i + 100 * Math.sqrt(i));
  let e;
  if (i > 1) {
    const o = a2 < 0.5 ? a2 : 1 - a2, u = Math.sqrt(-2 * Math.log(o));
    e = (2.30753 + u * 0.27061) / (1 + u * (0.99229 + u * 0.04481)) - u, a2 < 0.5 && (e = -e), e = Math.max(1e-3, i * __pow(1 - 1 / (9 * i) - e / (3 * Math.sqrt(i)), 3));
  } else {
    const o = 1 - i * (0.253 + i * 0.12);
    a2 < o ? e = __pow(a2 / o, 1 / i) : e = 1 - Math.log(1 - (a2 - o) / (1 - o));
  }
  const t = 1e-8, r = dt(i);
  let n, s;
  for (let o = 0; o < 12; o++) {
    if (e <= 0)
      return 0;
    if (n = Wa(i, e) - a2, i > 1 ? s = Math.exp((i - 1) * (Math.log(i - 1) - 1) - r) * Math.exp(-(e - (i - 1)) + (i - 1) * (Math.log(e) - Math.log(i - 1))) : s = Math.exp(-e + (i - 1) * Math.log(e) - r), s !== 0 && (s = n / s / (1 - 0.5 * Math.min(1, n / s * ((i - 1) / e - 1)))), e -= s, e <= 0 && (e = 0.5 * (e + s)), Math.abs(s) < t * e)
      break;
  }
  return e;
}
function Jh(a2, i, e, t) {
  let r = 0;
  for (let n = 0; n <= a2; n++)
    r += Qa(n, i, e, t);
  return r;
}
function Qa(a2, i, e, t) {
  return i - a2 > t - e ? 0 : sr(e, a2) * sr(t - e, i - a2) / sr(t, i);
}
function mu(a2, i, e) {
  return a2 < 0 ? 0 : 0.5 + 0.5 * nr((Math.log(a2) - i) / Math.sqrt(2 * e * e));
}
function eg(a2, i, e) {
  return a2 <= 0 ? 0 : Math.exp(-Math.log(a2) - 0.5 * Math.log(2 * Math.PI) - Math.log(e) - __pow(Math.log(a2) - i, 2) / (2 * e * e));
}
function tg(a2, i, e) {
  return Math.exp(fs(a2, i, e));
}
function rg(a2, i, e) {
  if (a2 < 0)
    return 0;
  let t = 0;
  for (let r = 0; r <= a2; r++)
    t += qa(r, i, e);
  return t;
}
function qa(a2, i, e) {
  return a2 < 0 ? 0 : sr(a2 + i - 1, i - 1) * __pow(e, i) * __pow(1 - e, a2);
}
function Jr(a2, i, e) {
  return 0.5 * (1 + nr((a2 - i) / Math.sqrt(2 * e * e)));
}
function hu(a2, i, e) {
  return Math.exp(-0.5 * Math.log(2 * Math.PI) - Math.log(e) - __pow(a2 - i, 2) / (2 * e * e));
}
function fs(a2, i, e) {
  return -1.4142135623730951 * e * Uh(2 * a2) + i;
}
function ng(a2, i) {
  let e = 0;
  for (let t = 0; t <= a2; t++)
    e += gu(t, i);
  return e;
}
function gu(a2, i) {
  return Math.exp(-i) * __pow(i, a2) / Ar(a2);
}
function en(a2, i) {
  const e = 0.5 * ls(i / (__pow(a2, 2) + i), i / 2, 0.5);
  return a2 < 0 ? e : 1 - e;
}
function sg(a2, i) {
  const e = __pow(1 + __pow(a2, 2) / i, -(i + 1) / 2);
  return 1 / (Math.sqrt(i) * ka(0.5, i / 2)) * e;
}
function ms(a2, i) {
  let e = Fa(2 * Math.min(a2, 1 - a2), 0.5 * i, 0.5);
  return e = Math.sqrt(i * (1 - e) / e), a2 > 0.5 ? e : -e;
}
function st(a2, i, e, t, r) {
  const n = [], s = [];
  let o = true;
  for (let u = 0; u < e; u++) {
    const c = Math.floor(u / t), l = u % t, f2 = Math.floor(u / r), m2 = u % r, d2 = a2.isArray() ? a2.get(c, l) : a2, _2 = i.isArray() ? i.get(f2, m2) : i;
    if (d2.isError())
      return {
        isError: true,
        errorObject: d2,
        array1Values: n,
        array2Values: s,
        noCalculate: o
      };
    if (_2.isError())
      return {
        isError: true,
        errorObject: _2,
        array1Values: n,
        array2Values: s,
        noCalculate: o
      };
    if (d2.isNull() || _2.isNull() || d2.isBoolean() || _2.isBoolean())
      continue;
    const C = d2.getValue(), E = _2.getValue();
    !s1(C) || !s1(E) || (n.push(+C), s.push(+E), o = false);
  }
  return {
    isError: false,
    errorObject: null,
    array1Values: n,
    array2Values: s,
    noCalculate: o
  };
}
function hs(a2, i, e) {
  const t = a2.isArray() ? a2.getRowCount() : 1, r = a2.isArray() ? a2.getColumnCount() : 1;
  let n = t, s = r;
  if (i && !i.isNull() && (n = i.isArray() ? i.getRowCount() : 1, s = i.isArray() ? i.getColumnCount() : 1, t === 1 && s !== r || r === 1 && n !== t || t !== 1 && r !== 1 && (n !== t || s !== r)))
    return {
      isError: true,
      errorObject: g2.create(h.REF)
    };
  if (e && !e.isNull()) {
    const o = e.isArray() ? e.getRowCount() : 1, u = e.isArray() ? e.getColumnCount() : 1;
    if (t === 1 && n > 1 && o !== n || r === 1 && s > 1 && u !== s)
      return {
        isError: true,
        errorObject: g2.create(h.REF)
      };
  }
  return {
    isError: false,
    errorObject: null
  };
}
function yt(a2) {
  const i = a2.isArray() ? a2.getRowCount() : 1, e = a2.isArray() ? a2.getColumnCount() : 1, t = [];
  for (let r = 0; r < i; r++) {
    t[r] = [];
    for (let n = 0; n < e; n++) {
      const s = a2.isArray() ? a2.get(r, n) : a2;
      if (s.isError() || s.isNull() || s.isBoolean() || s.isString())
        return g2.create(h.VALUE);
      t[r].push(+s.getValue());
    }
  }
  return t;
}
function gs(a2, i) {
  const e = [];
  let t = 1;
  for (let r = 0; r < a2; r++) {
    e[r] = [];
    for (let n = 0; n < i; n++)
      e[r].push(t++);
  }
  return e;
}
function ds(a2, i, e, t) {
  let r = i;
  t && (r = i.map((o) => Math.log(o)));
  let n, s;
  return e ? { slope: n, intercept: s } = ag(a2, r) : { slope: n, intercept: s } = ig(a2, r), t && (n = Math.exp(n), s = Math.exp(s)), Number.isNaN(n) && !e && (n = 0), { slope: n, intercept: s, Y: r };
}
function ag(a2, i) {
  const e = i.length;
  let t = 0, r = 0, n = 0, s = 0;
  for (let l = 0; l < e; l++)
    t += a2[l], r += i[l], n += a2[l] * a2[l], s += a2[l] * i[l];
  const u = (e * s - t * r) / (e * n - t * t), c = 1 / e * r - u * (1 / e) * t;
  return {
    slope: u,
    intercept: c
  };
}
function ig(a2, i) {
  const e = [[...a2]], t = [...i];
  let r = e.length, n = e[0].length, s = Math.min(r, n);
  const o = new Array(s).fill(0);
  for (let c = 0; c < s; c++) {
    const l = e[c];
    let f2 = 0;
    for (let d2 = 0; d2 < n; d2++)
      f2 += __pow(l[d2], 2);
    const m2 = l[c] < 0 ? Math.sqrt(f2) : -Math.sqrt(f2);
    if (o[c] = m2, m2 !== 0) {
      l[c] -= m2;
      for (let d2 = c + 1; d2 < r; d2++) {
        let _2 = 0;
        for (let C = c; C < n; C++)
          _2 -= e[d2][C] * l[C];
        _2 /= m2 * l[c];
        for (let C = c; C < n; C++)
          e[d2][C] -= _2 * l[C];
      }
    }
  }
  r = e.length, n = e[0].length, s = Math.min(r, n);
  const u = new Array(r).fill(0);
  for (let c = 0; c < s; c++) {
    const l = e[c];
    let f2 = 0;
    for (let m2 = 0; m2 < n; m2++)
      f2 += t[m2] * l[m2];
    f2 /= o[c] * l[c];
    for (let m2 = 0; m2 < n; m2++)
      t[m2] += f2 * l[m2];
  }
  for (let c = o.length - 1; c >= 0; c--) {
    t[c] /= o[c];
    const l = t[c], f2 = e[c];
    u[c] = l;
    for (let m2 = 0; m2 < c; m2++)
      t[m2] -= l * f2[m2];
  }
  return {
    slope: u[0],
    intercept: 0
  };
}
function Cs(a2, i, e, t, r) {
  const n = a2.length === 1 && a2[0].length > 1;
  let s = a2;
  r && (s = a2.map((C) => C.map((E) => Math.log(E))));
  let o = i, u = e;
  n && (s = Rt(s), o = Rt(o), u = Rt(u)), t && (o = o.map((C) => [...C, 1]));
  const c = Rt(o), l = Er(c, o), f2 = Er(c, s);
  let m2 = Bh(l);
  if (!m2 && (m2 = kh(l), !m2))
    return g2.create(h.NA);
  let d2 = Er(m2, f2);
  t || d2.push([0]), d2 = Rt(d2);
  const _2 = d2[0].pop();
  if (d2[0].reverse(), d2[0].push(_2), r)
    for (let C = 0; C < d2[0].length; C++)
      d2[0][C] = Math.exp(d2[0][C]);
  return {
    coefficients: d2,
    Y: s,
    X: o,
    newX: u,
    XTXInverse: m2
  };
}
function du(a2) {
  const i = [], e = [];
  let t = false;
  for (let r = 0; r < a2.length; r++) {
    const n = a2[r];
    if (n.isReferenceObject())
      n.isMultiArea() ? i.push(n) : e.push(n);
    else {
      t = true;
      break;
    }
  }
  return {
    isError: t,
    multiAreaRefs: i,
    normalRefs: e
  };
}
var Me = ((a2) => (a2.AVERAGE = "AVERAGE", a2.COUNT = "COUNT", a2.COUNTA = "COUNTA", a2.MAX = "MAX", a2.MIN = "MIN", a2.PRODUCT = "PRODUCT", a2.STDEV = "STDEV", a2.STDEV_S = "STDEV.S", a2.STDEVP = "STDEVP", a2.STDEV_P = "STDEV.P", a2.SUM = "SUM", a2.VAR = "VAR", a2.VAR_S = "VAR.S", a2.VARP = "VARP", a2.VAR_P = "VAR.P", a2.MEDIAN = "MEDIAN", a2.MODE_SNGL = "MODE.SNGL", a2))(Me || {});
function Cu(a2, i) {
  const e = a2[i];
  return e ? e.hd === ie.TRUE : false;
}
function _u(a2, i, e, t, r, n) {
  const s = a2.getValue(i, e);
  if (s != null && s.f || s != null && s.si) {
    const o = n.getFormulaStringByCell(i, e, t, r);
    if (o && (o.indexOf(`${F.SUBTOTAL}(`) > -1 || o.indexOf(`${F.AGGREGATE}(`) > -1))
      return true;
  }
  return false;
}
function Au(a2, i) {
  const e = Object.entries(a2).filter(([t, { count: r }]) => r === i).sort((t, r) => t[1].order - r[1].order).map(([t]) => +t);
  return y2.create(e[0]);
}
function Eu(a2, i) {
  var b, p2;
  const { type: e, ignoreRowHidden: t, ignoreErrorValues: r, ignoreNested: n, formulaDataModel: s } = a2, o = [];
  let u = 0, c = 0, l = 0, f2 = 0, m2 = 0, d2 = 0, _2 = 1;
  const C = {};
  let E = 1, R = 0;
  for (let V = 0; V < i.length; V++) {
    const S2 = i[V], M2 = S2.getFilteredOutRows(), D2 = S2.getRowData(), w = S2.getUnitId(), L = S2.getSheetId(), j2 = (p2 = (b = S2.getUnitData()[w]) == null ? void 0 : b[L]) == null ? void 0 : p2.cellData;
    let k;
    if (S2.iterator((G2, ne, z) => {
      if (M2.includes(ne) || t && Cu(D2, ne) || n && _u(j2, ne, z, L, w, s))
        return true;
      if (e === "COUNT")
        return G2 != null && G2.isNumber() && u++, true;
      if (e === "COUNTA")
        return G2 != null && !G2.isNull() && c++, true;
      if (G2 != null && G2.isError())
        return r ? true : (k = G2, false);
      if (!G2 || G2.isNull() || G2.isBoolean() || G2.isString())
        return true;
      let $2 = G2.getValue();
      if (!s1($2))
        return true;
      if ($2 = +$2, f2++, e === "MAX")
        return m2 = f2 === 1 ? $2 : Math.max(m2, $2), true;
      if (e === "MIN")
        return d2 = f2 === 1 ? $2 : Math.min(d2, $2), true;
      if (e === "MODE.SNGL")
        return C[$2] ? (C[$2].count++, C[$2].count > E && (E = C[$2].count)) : C[$2] = { count: 1, order: R++ }, true;
      l += $2, _2 *= $2, o.push(G2);
    }), k != null && k.isError())
      return k;
  }
  switch (e) {
    case "AVERAGE":
      return f2 === 0 ? g2.create(h.DIV_BY_ZERO) : y2.create(l / f2);
    case "COUNT":
      return y2.create(u);
    case "COUNTA":
      return y2.create(c);
    case "MAX":
      return y2.create(m2);
    case "MIN":
      return y2.create(d2);
    case "PRODUCT":
      return y2.create(f2 === 0 ? 0 : _2);
    case "STDEV":
    case "STDEV.S":
      return f2 < 2 ? g2.create(h.DIV_BY_ZERO) : mt([o], 1, f2).std(1);
    case "STDEVP":
    case "STDEV.P":
      return f2 === 0 ? g2.create(h.DIV_BY_ZERO) : mt([o], 1, f2).std();
    case "SUM":
      return y2.create(l);
    case "VAR":
    case "VAR.S":
      return f2 < 2 ? g2.create(h.DIV_BY_ZERO) : mt([o], 1, f2).var(1);
    case "VARP":
    case "VAR.P":
      return f2 === 0 ? g2.create(h.DIV_BY_ZERO) : mt([o], 1, f2).var();
    case "MEDIAN":
      return f2 === 0 ? g2.create(h.NUM) : Ru(o.map((V) => +V.getValue()));
    case "MODE.SNGL":
      return R === 0 || E === 1 ? g2.create(h.NA) : Au(C, E);
    default:
      return g2.create(h.VALUE);
  }
}
function mr(a2, i, e) {
  var o, u;
  const { ignoreRowHidden: t = false, ignoreErrorValues: r = false, ignoreNested: n = false } = i != null ? i : {}, s = [];
  if (a2.isReferenceObject()) {
    const c = a2.getFilteredOutRows(), l = a2.getRowData(), f2 = a2.getUnitId(), m2 = a2.getSheetId(), _2 = (u = (o = a2.getUnitData()[f2]) == null ? void 0 : o[m2]) == null ? void 0 : u.cellData;
    let C;
    if (a2.iterator((E, R, b) => {
      if (c.includes(R) || t && Cu(l, R))
        return true;
      if (E != null && E.isError())
        return r ? true : (C = E, false);
      if (n && e && _u(_2, R, b, m2, f2, e) || !E || E.isNull() || E.isBoolean() || E.isString())
        return true;
      const p2 = E.getValue();
      if (!s1(p2))
        return true;
      s.push(+p2);
    }), C)
      return C;
  } else {
    const c = a2.isArray() ? a2.getRowCount() : 1, l = a2.isArray() ? a2.getColumnCount() : 1;
    for (let f2 = 0; f2 < c; f2++)
      for (let m2 = 0; m2 < l; m2++) {
        const d2 = a2.isArray() ? a2.get(f2, m2) : a2;
        if (d2.isError()) {
          if (r) continue;
          return d2;
        }
        if (!d2 || d2.isNull() || d2.isBoolean() || d2.isString())
          continue;
        const _2 = d2.getValue();
        s1(_2) && s.push(+_2);
      }
  }
  return s.length === 0 ? g2.create(h.NUM) : s;
}
function Ru(a2) {
  const i = a2.length;
  a2.sort((t, r) => t - r);
  let e;
  if (i % 2 === 0) {
    const t = i / 2;
    e = (a2[t - 1] + a2[t]) / 2;
  } else
    e = a2[Math.floor(i / 2)];
  return y2.create(e);
}
function bu(a2, i) {
  if (i < 1 || i > a2.length)
    return g2.create(h.NUM);
  a2.sort((t, r) => r - t);
  const e = Math.ceil(i);
  return y2.create(a2[e - 1]);
}
function yu(a2, i) {
  if (i < 1 || i > a2.length)
    return g2.create(h.NUM);
  a2.sort((t, r) => t - r);
  const e = Math.floor(i);
  return y2.create(a2[e - 1]);
}
function pu(a2, i) {
  const e = a2.length;
  if (i < 0 || i > 1)
    return g2.create(h.NUM);
  a2.sort((o, u) => o - u);
  const t = i * (e - 1), r = Math.floor(t), n = t - r;
  if (n === 0)
    return y2.create(a2[r]);
  const s = a2[r] + n * (a2[r + 1] - a2[r]);
  return y2.create(s);
}
function Nu(a2, i) {
  const e = a2.length;
  if (i < 1 / (e + 1) || i > 1 - 1 / (e + 1))
    return g2.create(h.NUM);
  a2.sort((o, u) => o - u);
  const t = i * (e + 1) - 1, r = Math.floor(t), n = t - r;
  if (n === 0)
    return y2.create(a2[r]);
  const s = a2[r] + n * (a2[r + 1] - a2[r]);
  return y2.create(s);
}
function Vu(a2, i) {
  const e = a2.length;
  if (i < 0 || i > 4)
    return g2.create(h.NUM);
  a2.sort((u, c) => u - c);
  const r = i / 4 * (e - 1), n = Math.floor(r), s = r - n;
  if (s === 0)
    return y2.create(a2[n]);
  const o = a2[n] + s * (a2[n + 1] - a2[n]);
  return y2.create(o);
}
function Ou(a2, i) {
  const e = a2.length;
  if (i <= 0 || i >= 4)
    return g2.create(h.NUM);
  a2.sort((u, c) => u - c);
  const t = i / 4;
  if (t < 1 / (e + 1) || t > 1 - 1 / (e + 1))
    return g2.create(h.NUM);
  const r = t * (e + 1) - 1, n = Math.floor(r), s = r - n;
  if (s === 0)
    return y2.create(a2[n]);
  const o = a2[n] + s * (a2[n + 1] - a2[n]);
  return y2.create(o);
}
var Su = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    let o = n != null ? n : y2.create(0), u = s != null ? s : y2.create(1);
    o.isNull() && (o = y2.create(0)), u.isNull() && (u = y2.create(1));
    const c = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1
    ), l = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1
    ), f2 = O(c, l, e, g2.create(h.NA)), m2 = O(c, l, t, g2.create(h.NA)), d2 = O(c, l, r, g2.create(h.NA)), _2 = O(c, l, o, g2.create(h.NA)), C = O(c, l, u, g2.create(h.NA)), E = f2.mapValue((R, b, p2) => {
      const V = m2.get(b, p2), S2 = d2.get(b, p2), M2 = _2.get(b, p2), D2 = C.get(b, p2);
      return this._handleSingleObject(R, V, S2, M2, D2);
    });
    return c === 1 && l === 1 ? E.get(0, 0) : E;
  }
  _handleSingleObject(e, t, r, n, s) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (r.isError())
      return r;
    if (n.isError())
      return n;
    if (s.isError())
      return s;
    const { isError: o, errorObject: u, variants: c } = I2(e, t, r, n, s);
    if (o)
      return u;
    const [l, f2, m2, d2, _2] = c, C = +l.getValue(), E = +f2.getValue(), R = +m2.getValue(), b = +d2.getValue(), p2 = +_2.getValue();
    if (E <= 0 || R <= 0 || C <= 0 || C >= 1 || b >= p2)
      return g2.create(h.NUM);
    const V = Fa(C, E, R) * (p2 - b) + b;
    return y2.create(V);
  }
};
var Mu = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g2.create(h.NA)), c = O(s, o, t, g2.create(h.NA)), l = O(s, o, r, g2.create(h.NA)), f2 = O(s, o, n, g2.create(h.NA)), m2 = u.mapValue((d2, _2, C) => {
      const E = c.get(_2, C), R = l.get(_2, C), b = f2.get(_2, C);
      return d2.isError() ? d2 : E.isError() ? E : R.isError() ? R : b.isError() ? b : this._handleSingleObject(d2, E, R, b);
    });
    return s === 1 && o === 1 ? m2.get(0, 0) : m2;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = I2(e, t, r, n);
    if (s)
      return o;
    const [c, l, f2, m2] = u, d2 = Math.floor(+c.getValue()), _2 = Math.floor(+l.getValue()), C = +f2.getValue(), E = +m2.getValue();
    if (d2 < 0 || d2 > _2 || C < 0 || C > 1)
      return g2.create(h.NUM);
    let R;
    return E ? R = ou(d2, _2, C) : R = Ya(d2, _2, C), y2.create(R);
  }
};
var Du = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, t, g2.create(h.NA)), c = O(n, s, r, g2.create(h.NA)), l = o.mapValue((f2, m2, d2) => {
      const _2 = u.get(m2, d2), C = c.get(m2, d2);
      return f2.isError() ? f2 : _2.isError() ? _2 : C.isError() ? C : this._handleSingleObject(f2, _2, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I2(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f2 = Math.floor(+u.getValue()), m2 = +c.getValue(), d2 = +l.getValue();
    if (f2 < 0 || m2 <= 0 || m2 >= 1 || d2 <= 0 || d2 >= 1)
      return g2.create(h.NUM);
    let _2 = 0;
    for (; _2 <= f2 && !(ou(_2, f2, m2) >= d2); )
      _2++;
    return y2.create(_2);
  }
};
var wu = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g2.create(h.NA)), o = O(r, n, t, g2.create(h.NA)), u = s.mapValue((c, l, f2) => {
      const m2 = o.get(l, f2);
      return c.isError() ? c : m2.isError() ? m2 : this._handleSingleObject(c, m2);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = I2(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (c < 0 || l < 1 || l > __pow(10, 10))
      return g2.create(h.NUM);
    const f2 = 1 - Ha(c, l);
    return y2.create(f2);
  }
};
var Lu = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g2.create(h.NA)), o = O(r, n, t, g2.create(h.NA)), u = s.mapValue((c, l, f2) => {
      const m2 = o.get(l, f2);
      return c.isError() ? c : m2.isError() ? m2 : this._handleSingleObject(c, m2);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = I2(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (c < 0 || c > 1 || l < 1 || l > __pow(10, 10))
      return g2.create(h.NUM);
    const f2 = uu(1 - c, l);
    return Number.isNaN(f2) || !Number.isFinite(f2) ? g2.create(h.NUM) : y2.create(f2);
  }
};
var Pu = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if (r * n === 1 || s * o === 1)
      return u.isNull() || c.isNull() ? g2.create(h.VALUE) : g2.create(h.NA);
    if (r * n !== s * o)
      return g2.create(h.NA);
    const {
      isError: l,
      errorObject: f2,
      array1Values: m2,
      array2Values: d2,
      noCalculate: _2
    } = st(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f2 : _2 ? g2.create(h.DIV_BY_ZERO) : this._getResult(m2, d2, r, n);
  }
  _getResult(e, t, r, n) {
    let s = 0;
    for (let c = 0; c < e.length; c++) {
      if (t[c] === 0)
        return g2.create(h.DIV_BY_ZERO);
      s += __pow(e[c] - t[c], 2) / t[c];
    }
    let o = (r - 1) * (n - 1);
    r === 1 ? o = n - 1 : n === 1 && (o = r - 1);
    const u = 1 - Ha(s, o);
    return y2.create(u);
  }
};
var xu = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, t, g2.create(h.NA)), c = O(n, s, r, g2.create(h.NA)), l = o.mapValue((f2, m2, d2) => {
      const _2 = u.get(m2, d2), C = c.get(m2, d2);
      if (f2.isError())
        return f2;
      if (_2.isError())
        return _2;
      if (C.isError())
        return C;
      const { isError: E, errorObject: R, variants: b } = I2(f2, _2, C);
      if (E)
        return R;
      const [p2, V, S2] = b, M2 = +p2.getValue(), D2 = +V.getValue(), w = Math.floor(+S2.getValue());
      if (M2 <= 0 || M2 >= 1 || D2 <= 0 || w < 1)
        return g2.create(h.NUM);
      const L = Math.abs(fs(M2 / 2, 0, 1) * D2 / Math.sqrt(w));
      return y2.create(L);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
};
var ju = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if ((r * n === 1 || s * o === 1) && (u.isNull() || c.isNull()))
      return g2.create(h.VALUE);
    if (r * n !== s * o)
      return g2.create(h.NA);
    const {
      isError: l,
      errorObject: f2,
      array1Values: m2,
      array2Values: d2,
      noCalculate: _2
    } = st(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f2 : _2 ? g2.create(h.DIV_BY_ZERO) : this._getResult(m2, d2);
  }
  _getResult(e, t) {
    if (e.length === 0)
      return g2.create(h.DIV_BY_ZERO);
    const r = e.length;
    let n = 0, s = 0;
    for (let l = 0; l < r; l++)
      n += e[l], s += t[l];
    const o = n / r, u = s / r;
    let c = 0;
    for (let l = 0; l < r; l++) {
      const f2 = e[l] - o, m2 = t[l] - u;
      c += f2 * m2;
    }
    return y2.create(c / r);
  }
};
var Uu = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, t, g2.create(h.NA)), c = O(n, s, r, g2.create(h.NA)), l = o.mapValue((f2, m2, d2) => {
      const _2 = u.get(m2, d2), C = c.get(m2, d2);
      return f2.isError() ? f2 : _2.isError() ? _2 : C.isError() ? C : this._handleSingleObject(f2, _2, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I2(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f2 = +u.getValue(), m2 = +c.getValue(), d2 = +l.getValue();
    if (f2 < 0 || m2 <= 0)
      return g2.create(h.NUM);
    let _2;
    return d2 ? _2 = qh(f2, m2) : _2 = Xh(f2, m2), y2.create(_2);
  }
};
var vu = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, t, g2.create(h.NA)), c = O(n, s, r, g2.create(h.NA)), l = o.mapValue((f2, m2, d2) => {
      const _2 = u.get(m2, d2), C = c.get(m2, d2);
      return f2.isError() ? f2 : _2.isError() ? _2 : C.isError() ? C : this._handleSingleObject(f2, _2, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I2(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f2 = +u.getValue(), m2 = Math.floor(+c.getValue()), d2 = Math.floor(+l.getValue());
    if (f2 < 0 || m2 < 1 || m2 > __pow(10, 10) || d2 < 1 || d2 > __pow(10, 10))
      return g2.create(h.NUM);
    const _2 = 1 - Ga(f2, m2, d2);
    return y2.create(_2);
  }
};
var Tu = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, t, g2.create(h.NA)), c = O(n, s, r, g2.create(h.NA)), l = o.mapValue((f2, m2, d2) => {
      const _2 = u.get(m2, d2), C = c.get(m2, d2);
      return f2.isError() ? f2 : _2.isError() ? _2 : C.isError() ? C : this._handleSingleObject(f2, _2, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I2(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f2 = +u.getValue(), m2 = Math.floor(+c.getValue()), d2 = Math.floor(+l.getValue());
    if (f2 < 0 || f2 > 1 || m2 < 1 || m2 > __pow(10, 10) || d2 < 1 || d2 > __pow(10, 10))
      return g2.create(h.NUM);
    const _2 = cu(1 - f2, m2, d2);
    return Number.isNaN(_2) || !Number.isFinite(_2) ? g2.create(h.NUM) : y2.create(_2);
  }
};
var Iu = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const {
      isError: r,
      errorObject: n,
      variance: s,
      ns1: o
    } = this._getValues(e);
    if (r)
      return n;
    const {
      isError: u,
      errorObject: c,
      variance: l,
      ns1: f2
    } = this._getValues(t);
    if (u)
      return c;
    let m2 = 2 * (1 - Ga(s / l, o, f2));
    return m2 > 1 && (m2 = 2 - m2), y2.create(m2);
  }
  // eslint-disable-next-line
  _getValues(e) {
    let t = 0, r = 0;
    const n = e.isArray() ? e.getRowCount() : 1, s = e.isArray() ? e.getColumnCount() : 1;
    if (n === 1 && s === 1) {
      const f2 = e.isArray() ? e.get(0, 0) : e;
      return f2.isError() ? {
        isError: true,
        errorObject: f2,
        variance: t,
        ns1: r
      } : f2.isNull() ? {
        isError: true,
        errorObject: g2.create(h.VALUE),
        variance: t,
        ns1: r
      } : {
        isError: true,
        errorObject: g2.create(h.DIV_BY_ZERO),
        variance: t,
        ns1: r
      };
    }
    const o = [];
    let u = 0;
    for (let f2 = 0; f2 < n; f2++)
      for (let m2 = 0; m2 < s; m2++) {
        const d2 = e.isArray() ? e.get(f2, m2) : e;
        if (d2.isError())
          return {
            isError: true,
            errorObject: d2,
            variance: t,
            ns1: r
          };
        if (d2.isNull() || d2.isBoolean())
          continue;
        const _2 = d2.getValue();
        s1(_2) && (o.push(+_2), u += +_2);
      }
    if (o.length <= 1)
      return {
        isError: true,
        errorObject: g2.create(h.DIV_BY_ZERO),
        variance: t,
        ns1: r
      };
    const c = u / o.length;
    let l = 0;
    for (let f2 = 0; f2 < o.length; f2++)
      l += __pow(o[f2] - c, 2);
    return r = o.length - 1, t = l / r, t === 0 ? {
      isError: true,
      errorObject: g2.create(h.DIV_BY_ZERO),
      variance: t,
      ns1: r
    } : {
      isError: false,
      errorObject: null,
      variance: t,
      ns1: r
    };
  }
};
var Bu = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g2.create(h.NA)), c = O(s, o, t, g2.create(h.NA)), l = O(s, o, r, g2.create(h.NA)), f2 = O(s, o, n, g2.create(h.NA)), m2 = u.mapValue((d2, _2, C) => {
      const E = c.get(_2, C), R = l.get(_2, C), b = f2.get(_2, C);
      return d2.isError() ? d2 : E.isError() ? E : R.isError() ? R : b.isError() ? b : this._handleSingleObject(d2, E, R, b);
    });
    return s === 1 && o === 1 ? m2.get(0, 0) : m2;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = I2(e, t, r, n);
    if (s)
      return o;
    const [c, l, f2, m2] = u, d2 = +c.getValue(), _2 = +l.getValue(), C = +f2.getValue(), E = +m2.getValue();
    if (d2 < 0 || _2 <= 0 || C <= 0)
      return g2.create(h.NUM);
    let R;
    return E ? R = Kh(d2, _2, C) : R = Zh(d2, _2, C), y2.create(R);
  }
};
var Fu = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, t, g2.create(h.NA)), c = O(n, s, r, g2.create(h.NA)), l = o.mapValue((f2, m2, d2) => {
      const _2 = u.get(m2, d2), C = c.get(m2, d2);
      return f2.isError() ? f2 : _2.isError() ? _2 : C.isError() ? C : this._handleSingleObject(f2, _2, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I2(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f2 = +u.getValue(), m2 = +c.getValue(), d2 = +l.getValue();
    if (f2 < 0 || f2 > 1 || m2 <= 0 || d2 <= 0)
      return g2.create(h.NUM);
    const _2 = zh(f2, m2, d2);
    return Number.isNaN(_2) || !Number.isFinite(_2) ? g2.create(h.NUM) : y2.create(_2);
  }
};
var ku = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, t, g2.create(h.NA)), c = O(n, s, r, g2.create(h.NA)), l = o.mapValue((f2, m2, d2) => {
      const _2 = u.get(m2, d2), C = c.get(m2, d2);
      return f2.isError() ? f2 : _2.isError() ? _2 : C.isError() ? C : this._handleSingleObject(f2, _2, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I2(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f2 = +u.getValue(), m2 = +c.getValue(), d2 = +l.getValue();
    if (f2 <= 0 || f2 >= 1 || d2 <= 0)
      return g2.create(h.NUM);
    const _2 = tg(f2, m2, d2);
    return Number.isNaN(_2) || !Number.isFinite(_2) ? g2.create(h.NUM) : y2.create(_2);
  }
};
var $u = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = {};
    let r = 0, n = 1;
    for (let s = 0; s < e.length; s++) {
      const o = e[s];
      if (o.isError())
        return o;
      if (o.isString()) {
        const l = o.convertToNumberObjectValue();
        if (l.isError())
          return l;
      }
      const u = o.isArray() ? o.getRowCount() : 1, c = o.isArray() ? o.getColumnCount() : 1;
      for (let l = 0; l < u; l++)
        for (let f2 = 0; f2 < c; f2++) {
          const m2 = o.isArray() ? o.get(l, f2) : o;
          if (m2.isError())
            return m2;
          if (m2.isNull() || m2.isBoolean() || m2.isString())
            continue;
          const d2 = m2.getValue();
          s1(d2) && (t[+d2] ? (t[+d2].count++, t[+d2].count > n && (n = t[+d2].count)) : t[+d2] = { count: 1, order: r++ });
        }
    }
    return r === 0 || n === 1 ? new g2(h.NA) : Au(t, n);
  }
};
var Yu = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g2.create(h.NA)), c = O(s, o, t, g2.create(h.NA)), l = O(s, o, r, g2.create(h.NA)), f2 = O(s, o, n, g2.create(h.NA)), m2 = u.mapValue((d2, _2, C) => {
      const E = c.get(_2, C), R = l.get(_2, C), b = f2.get(_2, C);
      return d2.isError() ? d2 : E.isError() ? E : R.isError() ? R : b.isError() ? b : this._handleSingleObject(d2, E, R, b);
    });
    return s === 1 && o === 1 ? m2.get(0, 0) : m2;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = I2(e, t, r, n);
    if (s)
      return o;
    const [c, l, f2, m2] = u, d2 = +c.getValue(), _2 = +l.getValue(), C = +f2.getValue(), E = +m2.getValue();
    if (C <= 0)
      return g2.create(h.NUM);
    let R;
    return E ? R = Jr(d2, _2, C) : R = hu(d2, _2, C), y2.create(R);
  }
};
var Hu = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, t, g2.create(h.NA)), c = O(n, s, r, g2.create(h.NA)), l = o.mapValue((f2, m2, d2) => {
      const _2 = u.get(m2, d2), C = c.get(m2, d2);
      return f2.isError() ? f2 : _2.isError() ? _2 : C.isError() ? C : this._handleSingleObject(f2, _2, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I2(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f2 = +u.getValue(), m2 = +c.getValue(), d2 = +l.getValue();
    if (f2 <= 0 || f2 >= 1 || d2 <= 0)
      return g2.create(h.NUM);
    const _2 = fs(f2, m2, d2);
    return y2.create(_2);
  }
};
var Gu = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return e.getRowCount() === 1 && e.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = I2(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue();
    if (o <= 0 || o >= 1)
      return g2.create(h.NUM);
    const u = fs(o, 0, 1);
    return y2.create(u);
  }
};
var Wu = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = mr(e);
    if (t.isArray()) {
      const n = t.mapValue((s) => this._handleSingleObject(r, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(r, t);
  }
  _handleSingleObject(e, t) {
    if (!Array.isArray(e))
      return e;
    const { isError: r, errorObject: n, variants: s } = I2(t);
    if (r)
      return n;
    const [o] = s, u = +o.getValue();
    return pu(e, u);
  }
};
var Qu = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = this._getValues(e);
    let s = r != null ? r : y2.create(3);
    s.isNull() && (s = y2.create(3));
    const o = Math.max(
      t.isArray() ? t.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      t.isArray() ? t.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, t, g2.create(h.NA)), l = O(o, u, s, g2.create(h.NA)), f2 = c.mapValue((m2, d2, _2) => {
      const C = l.get(d2, _2);
      return m2.isError() ? m2 : C.isError() ? C : this._handleSingleObject(n, m2, C);
    });
    return o === 1 && u === 1 ? f2.get(0, 0) : f2;
  }
  _handleSingleObject(e, t, r) {
    if (e instanceof g2)
      return e;
    const { isError: n, errorObject: s, variants: o } = I2(t, r);
    if (n)
      return s;
    const [u, c] = o, l = +u.getValue(), f2 = Math.floor(+c.getValue()), m2 = e.length;
    if (m2 === 0 || l < e[0] || l > e[m2 - 1])
      return g2.create(h.NA);
    if (m2 === 1)
      return l === e[0] ? y2.create(1) : g2.create(h.NA);
    let d2 = 0, _2 = false, C = 0;
    for (; !_2 && C < m2; )
      l === e[C] ? (d2 = C / (m2 - 1), _2 = true) : l > e[C] && C + 1 < m2 && l < e[C + 1] && (d2 = (C + (l - e[C]) / (e[C + 1] - e[C])) / (m2 - 1), _2 = true), C++;
    return _2 ? f2 < 1 ? g2.create(h.NUM) : (d2 = Ze2(d2, f2), y2.create(d2)) : g2.create(h.NA);
  }
  _getValues(e) {
    const t = e.isArray() ? e.getRowCount() : 1, r = e.isArray() ? e.getColumnCount() : 1, n = [];
    for (let s = 0; s < t; s++)
      for (let o = 0; o < r; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        if (u.isNull() || u.isBoolean())
          continue;
        const c = u.getValue();
        s1(c) && n.push(+c);
      }
    return n.sort((s, o) => s - o);
  }
};
var qu = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, t, g2.create(h.NA)), c = O(n, s, r, g2.create(h.NA)), l = o.mapValue((f2, m2, d2) => {
      const _2 = u.get(m2, d2), C = c.get(m2, d2);
      return f2.isError() ? f2 : _2.isError() ? _2 : C.isError() ? C : this._handleSingleObject(f2, _2, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I2(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f2 = Math.floor(+u.getValue()), m2 = +c.getValue(), d2 = +l.getValue();
    if (f2 < 0 || m2 < 0)
      return g2.create(h.NUM);
    let _2;
    return d2 ? _2 = ng(f2, m2) : _2 = gu(f2, m2), y2.create(_2);
  }
};
var Xu = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = mr(e);
    if (t.isArray()) {
      const n = t.mapValue((s) => this._handleSingleObject(r, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(r, t);
  }
  _handleSingleObject(e, t) {
    if (!Array.isArray(e))
      return e;
    const { isError: r, errorObject: n, variants: s } = I2(t);
    if (r)
      return n;
    const [o] = s, u = Math.floor(+o.getValue());
    return Vu(e, u);
  }
};
var Ku = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = this.flattenArray(e);
    return t.isError() ? t : t.std();
  }
};
var Zu = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = this.flattenArray(e);
    return t.isError() ? t : t.std(1);
  }
};
var zu = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g2.create(h.NA)), o = O(r, n, t, g2.create(h.NA)), u = s.mapValue((c, l, f2) => {
      const m2 = o.get(l, f2);
      return c.isError() ? c : m2.isError() ? m2 : this._handleSingleObject(c, m2);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = I2(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (c <= 0 || c > 1 || l < 1 || l > __pow(10, 10))
      return g2.create(h.NUM);
    const f2 = Math.abs(ms(c / 2, l));
    return Number.isNaN(f2) || !Number.isFinite(f2) ? g2.create(h.NUM) : y2.create(f2);
  }
};
var Ju = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  // eslint-disable-next-line
  calculate(e, t, r, n) {
    const { isError: s, errorObject: o, array1Values: u, array2Values: c } = this._handleArray1AndArray2(e, t), l = this._getArrayValues(e), f2 = this._getArrayValues(t), m2 = Math.max(
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), d2 = Math.max(
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), _2 = O(m2, d2, r, g2.create(h.NA)), C = O(m2, d2, n, g2.create(h.NA)), E = _2.mapValue((R, b, p2) => {
      const V = C.get(b, p2);
      if (e.isError())
        return e;
      if (t.isError())
        return t;
      if (R.isError())
        return R;
      if (V.isError())
        return V;
      const { isError: S2, errorObject: M2, variants: D2 } = I2(R, V);
      if (S2)
        return M2;
      const [w, L] = D2, v = Math.floor(+w.getValue()), j2 = Math.floor(+L.getValue());
      return ![1, 2].includes(v) || ![1, 2, 3].includes(j2) ? g2.create(h.NUM) : j2 === 1 && s ? o : j2 !== 1 && l instanceof g2 ? l : j2 !== 1 && f2 instanceof g2 ? f2 : this._handleSingleObject(
        j2 === 1 ? u : l,
        j2 === 1 ? c : f2,
        v,
        j2
      );
    });
    return m2 === 1 && d2 === 1 ? E.get(0, 0) : E;
  }
  _handleSingleObject(e, t, r, n) {
    if (e.length < 2 || t.length < 2)
      return g2.create(h.DIV_BY_ZERO);
    const { isError: s, errorObject: o, x: u, degFreedom: c } = this._getTDistParamByArrayValues(e, t, n);
    if (s)
      return o;
    let l = en(-u, c);
    return r === 2 && (l *= 2), Number.isNaN(l) || !Number.isFinite(l) ? g2.create(h.NUM) : y2.create(l);
  }
  _getArrayValues(e) {
    const t = e.isArray() ? e.getRowCount() : 1, r = e.isArray() ? e.getColumnCount() : 1, n = [];
    for (let s = 0; s < t; s++)
      for (let o = 0; o < r; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        if (u.isNull()) {
          if (t * r === 1)
            return g2.create(h.VALUE);
          continue;
        }
        u.isBoolean() || u.isString() || n.push(+u.getValue());
      }
    return n;
  }
  // eslint-disable-next-line
  _handleArray1AndArray2(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return {
        isError: true,
        errorObject: u,
        array1Values: [],
        array2Values: []
      };
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return {
        isError: true,
        errorObject: c,
        array1Values: [],
        array2Values: []
      };
    if ((r * n === 1 || s * o === 1) && (u.isNull() || c.isNull()))
      return {
        isError: true,
        errorObject: g2.create(h.VALUE),
        array1Values: [],
        array2Values: []
      };
    if (r * n !== s * o)
      return {
        isError: true,
        errorObject: g2.create(h.NA),
        array1Values: [],
        array2Values: []
      };
    const {
      isError: l,
      errorObject: f2,
      array1Values: m2,
      array2Values: d2,
      noCalculate: _2
    } = st(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? {
      isError: true,
      errorObject: f2,
      array1Values: [],
      array2Values: []
    } : _2 || m2.length < 2 ? {
      isError: true,
      errorObject: g2.create(h.DIV_BY_ZERO),
      array1Values: [],
      array2Values: []
    } : {
      isError: false,
      errorObject: null,
      array1Values: m2,
      array2Values: d2
    };
  }
  _getTDistParamByArrayValues(e, t, r) {
    return r === 1 ? this._getTDistParamByType1(e, t) : r === 2 ? this._getTDistParamByType2(e, t) : this._getTDistParamByType3(e, t);
  }
  _getTDistParamByType1(e, t) {
    const r = e.length;
    let n = 0, s = 0, o = 0;
    for (let m2 = 0; m2 < r; m2++)
      n += e[m2], s += t[m2], o += __pow(e[m2] - t[m2], 2);
    const u = n - s, c = r * o - __pow(u, 2), l = r - 1;
    return c === 0 ? {
      isError: true,
      errorObject: g2.create(h.DIV_BY_ZERO),
      x: 0,
      degFreedom: l
    } : {
      isError: false,
      errorObject: null,
      x: Math.abs(u) * Math.sqrt(l / c),
      degFreedom: l
    };
  }
  _getTDistParamByType2(e, t) {
    const r = e.length, n = t.length;
    let s = 0, o = 0;
    for (let E = 0; E < r; E++)
      s += e[E], o += __pow(e[E], 2);
    let u = 0, c = 0;
    for (let E = 0; E < n; E++)
      u += t[E], c += __pow(t[E], 2);
    const l = o - __pow(s, 2) / r, f2 = c - __pow(u, 2) / n, m2 = Math.sqrt(l + f2);
    if (m2 === 0)
      return {
        isError: true,
        errorObject: g2.create(h.DIV_BY_ZERO),
        x: 0,
        degFreedom: 0
      };
    const d2 = r - 1 + n - 1, _2 = Math.sqrt(r * n * d2 / (r + n));
    return {
      isError: false,
      errorObject: null,
      x: Math.abs(s / r - u / n) / m2 * _2,
      degFreedom: d2
    };
  }
  _getTDistParamByType3(e, t) {
    const r = e.length, n = t.length;
    let s = 0, o = 0;
    for (let C = 0; C < r; C++)
      s += e[C], o += __pow(e[C], 2);
    let u = 0, c = 0;
    for (let C = 0; C < n; C++)
      u += t[C], c += __pow(t[C], 2);
    const l = (o - __pow(s, 2) / r) / (r * (r - 1)), f2 = (c - __pow(u, 2) / n) / (n * (n - 1));
    if (l + f2 === 0)
      return {
        isError: true,
        errorObject: g2.create(h.DIV_BY_ZERO),
        x: 0,
        degFreedom: 0
      };
    const m2 = l / (l + f2), d2 = Math.abs(s / r - u / n) / Math.sqrt(l + f2), _2 = 1 / (__pow(m2, 2) / (r - 1) + __pow(1 - m2, 2) / (n - 1));
    return {
      isError: false,
      errorObject: null,
      x: d2,
      degFreedom: _2
    };
  }
};
var ec = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = this.flattenArray(e);
    return t.isError() ? t : t.var();
  }
};
var tc = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = this.flattenArray(e);
    return t.isError() ? t : t.var(1);
  }
};
var rc = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g2.create(h.NA)), c = O(s, o, t, g2.create(h.NA)), l = O(s, o, r, g2.create(h.NA)), f2 = O(s, o, n, g2.create(h.NA)), m2 = u.mapValue((d2, _2, C) => {
      const E = c.get(_2, C), R = l.get(_2, C), b = f2.get(_2, C);
      return d2.isError() ? d2 : E.isError() ? E : R.isError() ? R : b.isError() ? b : this._handleSingleObject(d2, E, R, b);
    });
    return s === 1 && o === 1 ? m2.get(0, 0) : m2;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = I2(e, t, r, n);
    if (s)
      return o;
    const [c, l, f2, m2] = u, d2 = +c.getValue(), _2 = +l.getValue(), C = +f2.getValue(), E = +m2.getValue();
    if (d2 < 0 || _2 <= 0 || C <= 0)
      return g2.create(h.NUM);
    const R = Math.exp(-__pow(d2 / C, _2));
    let b;
    return E ? b = 1 - R : b = _2 / __pow(C, _2) * __pow(d2, _2 - 1) * R, Number.isNaN(b) || !Number.isFinite(b) ? g2.create(h.NUM) : y2.create(b);
  }
};
var nc = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = this._getArrayValues(e), s = Math.max(
      t.isArray() ? t.getRowCount() : 1,
      r != null && r.isArray() ? r.getRowCount() : 1
    ), o = Math.max(
      t.isArray() ? t.getColumnCount() : 1,
      r != null && r.isArray() ? r.getColumnCount() : 1
    ), u = O(s, o, t, g2.create(h.NA)), c = r ? O(s, o, r, g2.create(h.NA)) : void 0, l = u.mapValue((f2, m2, d2) => {
      if (n instanceof g2)
        return n;
      if (f2.isError())
        return f2;
      const _2 = r ? c.get(m2, d2) : void 0;
      return _2 != null && _2.isError() ? _2 : n.length === 0 ? g2.create(h.NA) : n.length === 1 ? g2.create(h.DIV_BY_ZERO) : this._handleSingleObject(n, f2, _2);
    });
    return s === 1 && o === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I2(t);
    if (n)
      return s;
    const [u] = o, c = +u.getValue(), l = e.length;
    let f2 = 0, m2 = 0;
    for (let E = 0; E < l; E++)
      f2 += e[E], m2 += __pow(e[E], 2);
    let d2 = 0;
    if (r !== void 0) {
      const { isError: E, errorObject: R, variants: b } = I2(r);
      if (E)
        return R;
      const [p2] = b;
      d2 = +p2.getValue();
    } else {
      const E = f2 / l;
      d2 = Math.sqrt((m2 - 2 * E * f2 + l * __pow(E, 2)) / (l - 1));
    }
    if (d2 <= 0)
      return g2.create(h.NUM);
    const _2 = (f2 / l - c) / (d2 / Math.sqrt(l)), C = 1 - Jr(_2, 0, 1);
    return Number.isNaN(C) || !Number.isFinite(C) ? g2.create(h.NUM) : y2.create(C);
  }
  _getArrayValues(e) {
    const t = [], r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1;
    for (let s = 0; s < r; s++)
      for (let o = 0; o < n; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        if (u.isNull() || u.isBoolean() || u.isString())
          continue;
        const c = u.getValue();
        s1(c) && t.push(+c);
      }
    return t;
  }
};
var og = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    let o = n != null ? n : y2.create(0), u = s != null ? s : y2.create(1);
    o.isNull() && (o = y2.create(0)), u.isNull() && (u = y2.create(1));
    const c = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1
    ), l = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1
    ), f2 = O(c, l, e, g2.create(h.NA)), m2 = O(c, l, t, g2.create(h.NA)), d2 = O(c, l, r, g2.create(h.NA)), _2 = O(c, l, o, g2.create(h.NA)), C = O(c, l, u, g2.create(h.NA)), E = f2.mapValue((R, b, p2) => {
      const V = m2.get(b, p2), S2 = d2.get(b, p2), M2 = _2.get(b, p2), D2 = C.get(b, p2);
      return this._handleSingleObject(R, V, S2, M2, D2);
    });
    return c === 1 && l === 1 ? E.get(0, 0) : E;
  }
  _handleSingleObject(e, t, r, n, s) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (r.isError())
      return r;
    if (n.isError())
      return n;
    if (s.isError())
      return s;
    const { isError: o, errorObject: u, variants: c } = I2(e, t, r, n, s);
    if (o)
      return u;
    const [l, f2, m2, d2, _2] = c, C = +l.getValue(), E = +f2.getValue(), R = +m2.getValue(), b = +d2.getValue(), p2 = +_2.getValue();
    if (E <= 0 || R <= 0 || C < b || C > p2 || b === p2)
      return g2.create(h.NUM);
    const V = iu((C - b) / (p2 - b), E, R);
    return y2.create(V);
  }
};
var fe2 = ((a2) => (a2.BETADIST = "BETADIST", a2.BETAINV = "BETAINV", a2.BINOMDIST = "BINOMDIST", a2.CHIDIST = "CHIDIST", a2.CHIINV = "CHIINV", a2.CHITEST = "CHITEST", a2.CONFIDENCE = "CONFIDENCE", a2.COVAR = "COVAR", a2.CRITBINOM = "CRITBINOM", a2.EXPONDIST = "EXPONDIST", a2.FDIST = "FDIST", a2.FINV = "FINV", a2.FTEST = "FTEST", a2.GAMMADIST = "GAMMADIST", a2.GAMMAINV = "GAMMAINV", a2.HYPGEOMDIST = "HYPGEOMDIST", a2.LOGINV = "LOGINV", a2.LOGNORMDIST = "LOGNORMDIST", a2.MODE = "MODE", a2.NEGBINOMDIST = "NEGBINOMDIST", a2.NORMDIST = "NORMDIST", a2.NORMINV = "NORMINV", a2.NORMSDIST = "NORMSDIST", a2.NORMSINV = "NORMSINV", a2.PERCENTILE = "PERCENTILE", a2.PERCENTRANK = "PERCENTRANK", a2.POISSON = "POISSON", a2.QUARTILE = "QUARTILE", a2.RANK = "RANK", a2.STDEV = "STDEV", a2.STDEVP = "STDEVP", a2.TDIST = "TDIST", a2.TINV = "TINV", a2.TTEST = "TTEST", a2.VAR = "VAR", a2.VARP = "VARP", a2.WEIBULL = "WEIBULL", a2.ZTEST = "ZTEST", a2))(fe2 || {});
var ug = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g2.create(h.NA)), c = O(s, o, t, g2.create(h.NA)), l = O(s, o, r, g2.create(h.NA)), f2 = O(s, o, n, g2.create(h.NA)), m2 = u.mapValue((d2, _2, C) => {
      const E = c.get(_2, C), R = l.get(_2, C), b = f2.get(_2, C);
      return d2.isError() ? d2 : E.isError() ? E : R.isError() ? R : b.isError() ? b : this._handleSingleObject(d2, E, R, b);
    });
    return s === 1 && o === 1 ? m2.get(0, 0) : m2;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = I2(e, t, r, n);
    if (s)
      return o;
    const [c, l, f2, m2] = u, d2 = Math.floor(+c.getValue()), _2 = Math.floor(+l.getValue()), C = Math.floor(+f2.getValue()), E = Math.floor(+m2.getValue());
    if (d2 < 0 || d2 > _2 || d2 > C || d2 < _2 - E + C || _2 <= 0 || _2 > E || C <= 0 || C > E || E <= 0)
      return g2.create(h.NUM);
    let R = Qa(d2, _2, C, E);
    return Number.isNaN(R) && (R = 0), y2.create(R);
  }
};
var cg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, t, g2.create(h.NA)), c = O(n, s, r, g2.create(h.NA)), l = o.mapValue((f2, m2, d2) => {
      const _2 = u.get(m2, d2), C = c.get(m2, d2);
      return f2.isError() ? f2 : _2.isError() ? _2 : C.isError() ? C : this._handleSingleObject(f2, _2, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I2(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f2 = +u.getValue(), m2 = +c.getValue(), d2 = +l.getValue();
    if (f2 <= 0 || d2 <= 0)
      return g2.create(h.NUM);
    const _2 = mu(f2, m2, d2);
    return y2.create(_2);
  }
};
var lg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, t, g2.create(h.NA)), c = O(n, s, r, g2.create(h.NA)), l = o.mapValue((f2, m2, d2) => {
      const _2 = u.get(m2, d2), C = c.get(m2, d2);
      return f2.isError() ? f2 : _2.isError() ? _2 : C.isError() ? C : this._handleSingleObject(f2, _2, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I2(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f2 = Math.floor(+u.getValue()), m2 = Math.floor(+c.getValue()), d2 = +l.getValue();
    if (f2 < 0 || m2 < 1 || d2 <= 0 || d2 >= 1)
      return g2.create(h.NUM);
    const _2 = qa(f2, m2, d2);
    return y2.create(_2);
  }
};
var fg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return e.getRowCount() === 1 && e.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = I2(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue(), u = Jr(o, 0, 1);
    return y2.create(u);
  }
};
var mg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
    A(this, "needsReferenceObject", true);
  }
  calculate(e, t, r) {
    let n = e;
    n.isReferenceObject() && (n = n.toArrayValueObject());
    const { refHasError: s, refErrorObject: o, refNumbers: u } = this._checkRefReferenceObject(t);
    let c = r != null ? r : y2.create(0);
    c.isReferenceObject() && (c = c.toArrayValueObject());
    const l = Math.max(
      n.isArray() ? n.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f2 = Math.max(
      n.isArray() ? n.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), m2 = O(l, f2, n, g2.create(h.NA)), d2 = O(l, f2, c, g2.create(h.NA)), _2 = m2.map((C, E, R) => {
      const b = d2.get(E, R);
      if (!e.isReferenceObject() && e.isNull())
        return g2.create(h.NA);
      if (s)
        return o;
      if (b.isError())
        return b;
      const p2 = +C.getValue(), V = +b.getValue();
      if (Number.isNaN(p2) || Number.isNaN(V))
        return g2.create(h.VALUE);
      const M2 = u.sort((D2, w) => V ? D2 - w : w - D2).indexOf(p2);
      return M2 === -1 ? g2.create(h.NA) : y2.create(M2 + 1);
    });
    return l === 1 && f2 === 1 ? _2.get(0, 0) : _2;
  }
  _checkRefReferenceObject(e) {
    let t = false, r = g2.create(h.NA);
    const n = [];
    return e.isReferenceObject() ? (e.toArrayValueObject().iterator((o) => {
      const u = o;
      if (u.isError())
        return t = true, r = u, false;
      if (u.isNull() || u.isBoolean())
        return true;
      const c = +u.getValue();
      if (Number.isNaN(c))
        return true;
      n.push(c);
    }), {
      refHasError: t,
      refErrorObject: r,
      refNumbers: n
    }) : {
      refHasError: true,
      refErrorObject: r,
      refNumbers: n
    };
  }
};
var hg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, t, g2.create(h.NA)), c = O(n, s, r, g2.create(h.NA)), l = o.mapValue((f2, m2, d2) => {
      const _2 = u.get(m2, d2), C = c.get(m2, d2);
      return f2.isError() ? f2 : _2.isError() ? _2 : C.isError() ? C : this._handleSingleObject(f2, _2, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I2(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f2 = +u.getValue(), m2 = Math.floor(+c.getValue()), d2 = Math.floor(+l.getValue());
    if (f2 < 0 || m2 < 1 || m2 > __pow(10, 10) || d2 < 1 || d2 > 2)
      return g2.create(h.NUM);
    let _2 = en(-f2, m2);
    return d2 === 2 && (_2 *= 2), Number.isNaN(_2) || !Number.isFinite(_2) ? g2.create(h.NUM) : y2.create(_2);
  }
};
var gg = [
  [og, fe2.BETADIST],
  [Su, fe2.BETAINV],
  [Mu, fe2.BINOMDIST],
  [wu, fe2.CHIDIST],
  [Lu, fe2.CHIINV],
  [Pu, fe2.CHITEST],
  [xu, fe2.CONFIDENCE],
  [ju, fe2.COVAR],
  [Du, fe2.CRITBINOM],
  [Uu, fe2.EXPONDIST],
  [vu, fe2.FDIST],
  [Tu, fe2.FINV],
  [Iu, fe2.FTEST],
  [Bu, fe2.GAMMADIST],
  [Fu, fe2.GAMMAINV],
  [ug, fe2.HYPGEOMDIST],
  [cg, fe2.LOGNORMDIST],
  [ku, fe2.LOGINV],
  [$u, fe2.MODE],
  [lg, fe2.NEGBINOMDIST],
  [Yu, fe2.NORMDIST],
  [Hu, fe2.NORMINV],
  [fg, fe2.NORMSDIST],
  [Gu, fe2.NORMSINV],
  [Wu, fe2.PERCENTILE],
  [Qu, fe2.PERCENTRANK],
  [qu, fe2.POISSON],
  [Xu, fe2.QUARTILE],
  [mg, fe2.RANK],
  [Zu, fe2.STDEV],
  [Ku, fe2.STDEVP],
  [hg, fe2.TDIST],
  [zu, fe2.TINV],
  [Ju, fe2.TTEST],
  [tc, fe2.VAR],
  [ec, fe2.VARP],
  [rc, fe2.WEIBULL],
  [nc, fe2.ZTEST]
];
var dg = [];
var Cg = ((a2) => (a2.CUBEKPIMEMBER = "CUBEKPIMEMBER", a2.CUBEMEMBER = "CUBEMEMBER", a2.CUBEMEMBERPROPERTY = "CUBEMEMBERPROPERTY", a2.CUBERANKEDMEMBER = "CUBERANKEDMEMBER", a2.CUBESET = "CUBESET", a2.CUBESETCOUNT = "CUBESETCOUNT", a2.CUBEVALUE = "CUBEVALUE", a2))(Cg || {});
var _g = class extends N2 {
  isCustom() {
    return true;
  }
};
var Hb = class extends _g {
  isAsync() {
    return true;
  }
};
function at(a2) {
  const i = [];
  if (a2.isError())
    return {
      isError: true,
      errorObject: a2,
      databaseValues: i
    };
  const e = a2.isArray() ? a2.getRowCount() : 1, t = a2.isArray() ? a2.getColumnCount() : 1;
  if (e < 2)
    return {
      isError: true,
      errorObject: g2.create(h.VALUE),
      databaseValues: i
    };
  for (let r = 0; r < e; r++) {
    const n = [];
    for (let s = 0; s < t; s++) {
      const o = a2.get(r, s);
      if (o.isNull()) {
        n.push(null);
        continue;
      }
      let u = `${o.getValue()}`;
      if (o.isBoolean() && (u = u.toLocaleUpperCase()), o.isNumber() || s1(u)) {
        n.push(+u);
        continue;
      }
      n.push(u);
    }
    i.push(n);
  }
  return {
    isError: false,
    errorObject: null,
    databaseValues: i
  };
}
function it(a2, i) {
  let e = -1;
  if (a2.isError())
    return {
      isError: true,
      errorObject: a2,
      fieldIndex: e
    };
  const t = a2.isArray() ? a2.getRowCount() : 1, r = a2.isArray() ? a2.getColumnCount() : 1;
  if (t > 1 || r > 1)
    return {
      isError: true,
      errorObject: g2.create(h.VALUE),
      fieldIndex: e
    };
  const n = a2.isArray() ? a2.get(0, 0) : a2;
  let s = `${n.getValue()}`;
  if (n.isNull() ? s = 0 : n.isBoolean() ? s = n.getValue() ? 1 : 0 : (n.isNumber() || s1(s)) && (s = Math.floor(+s)), typeof s == "number") {
    if (s < 1 || s > i[0].length)
      return {
        isError: true,
        errorObject: g2.create(h.VALUE),
        fieldIndex: e
      };
    e = s - 1;
  } else if (e = i[0].findIndex((o) => o === null ? false : `${o}`.toLocaleLowerCase() === s.toLocaleLowerCase()), e === -1)
    return {
      isError: true,
      errorObject: g2.create(h.VALUE),
      fieldIndex: e
    };
  return {
    isError: false,
    errorObject: null,
    fieldIndex: e
  };
}
function ot(a2) {
  const i = [];
  if (a2.isError())
    return {
      isError: true,
      errorObject: a2,
      criteriaValues: i
    };
  const e = a2.isArray() ? a2.getRowCount() : 1, t = a2.isArray() ? a2.getColumnCount() : 1;
  if (e < 2)
    return {
      isError: true,
      errorObject: g2.create(h.VALUE),
      criteriaValues: i
    };
  for (let r = 0; r < e; r++) {
    const n = [];
    for (let s = 0; s < t; s++) {
      const o = a2.get(r, s);
      if (o.isNull()) {
        n.push(null);
        continue;
      }
      const u = `${o.getValue()}`;
      if (o.isBoolean()) {
        n.push(o.getValue() ? 1 : 0);
        continue;
      }
      if (o.isNumber() || s1(u)) {
        n.push(+u);
        continue;
      }
      n.push(u);
    }
    i.push(n);
  }
  return {
    isError: false,
    errorObject: null,
    criteriaValues: i
  };
}
function ut(a2, i, e) {
  const t = a2.length, r = a2[0].length, n = {};
  let s = false;
  for (let o = 1; o < t; o++) {
    let u = true;
    for (let c = 0; c < r; c++) {
      const l = a2[o][c];
      if (l === null)
        continue;
      let f2 = n[c];
      if (f2 === void 0) {
        const m2 = a2[0][c];
        f2 = i[0].findIndex((d2) => d2 === null || m2 === null ? false : `${d2}`.toLocaleLowerCase() === `${m2}`.toLocaleLowerCase()), n[c] = f2;
      }
      if (f2 === -1 && (typeof l == "string" || l === 0)) {
        u = false;
        break;
      } else if (f2 > -1) {
        const m2 = i[e][f2];
        if (m2 === null) {
          u = false;
          break;
        }
        const [d2, _2] = La(`${l}`);
        if (!Pt.create(`${m2}`).compare(_2, d2).getValue()) {
          u = false;
          break;
        }
      }
    }
    if (u) {
      s = true;
      break;
    }
  }
  return s;
}
var Ag = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = at(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = it(t, o);
    if (u)
      return c;
    const { isError: f2, errorObject: m2, criteriaValues: d2 } = ot(r);
    if (f2)
      return m2;
    let _2 = 0, C = 0;
    for (let E = 1; E < o.length; E++) {
      const R = o[E][l];
      typeof R == "number" && ut(d2, o, E) && (_2 += R, C++);
    }
    return C === 0 ? g2.create(h.DIV_BY_ZERO) : y2.create(_2 / C);
  }
};
var Eg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = at(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = it(t, o);
    if (u)
      return c;
    const { isError: f2, errorObject: m2, criteriaValues: d2 } = ot(r);
    if (f2)
      return m2;
    let _2 = 0;
    for (let C = 1; C < o.length; C++)
      typeof o[C][l] == "number" && ut(d2, o, C) && _2++;
    return y2.create(_2);
  }
};
var Rg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = at(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = it(t, o);
    if (u)
      return c;
    const { isError: f2, errorObject: m2, criteriaValues: d2 } = ot(r);
    if (f2)
      return m2;
    let _2 = 0;
    for (let C = 1; C < o.length; C++) {
      const E = o[C][l];
      E != null && ut(d2, o, C) && _2++;
    }
    return y2.create(_2);
  }
};
var bg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = at(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = it(t, o);
    if (u)
      return c;
    const { isError: f2, errorObject: m2, criteriaValues: d2 } = ot(r);
    if (f2)
      return m2;
    let _2 = 0, C = 0;
    for (let E = 1; E < o.length; E++) {
      const R = o[E][l];
      R != null && ut(d2, o, E) && (_2++, C = E);
    }
    return _2 === 0 ? g2.create(h.VALUE) : _2 > 1 ? g2.create(h.NUM) : e.get(C, l);
  }
};
var yg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = at(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = it(t, o);
    if (u)
      return c;
    const { isError: f2, errorObject: m2, criteriaValues: d2 } = ot(r);
    if (f2)
      return m2;
    let _2 = -1 / 0, C = 0;
    for (let E = 1; E < o.length; E++) {
      const R = o[E][l];
      typeof R == "number" && ut(d2, o, E) && (_2 = Math.max(_2, R), C++);
    }
    return C === 0 ? y2.create(0) : y2.create(_2);
  }
};
var pg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = at(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = it(t, o);
    if (u)
      return c;
    const { isError: f2, errorObject: m2, criteriaValues: d2 } = ot(r);
    if (f2)
      return m2;
    let _2 = 1 / 0, C = 0;
    for (let E = 1; E < o.length; E++) {
      const R = o[E][l];
      typeof R == "number" && ut(d2, o, E) && (_2 = Math.min(_2, R), C++);
    }
    return C === 0 ? y2.create(0) : y2.create(_2);
  }
};
var Ng = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = at(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = it(t, o);
    if (u)
      return c;
    const { isError: f2, errorObject: m2, criteriaValues: d2 } = ot(r);
    if (f2)
      return m2;
    let _2 = 1, C = 0;
    for (let E = 1; E < o.length; E++) {
      const R = o[E][l];
      typeof R == "number" && ut(d2, o, E) && (_2 *= R, C++);
    }
    return C === 0 ? y2.create(0) : y2.create(_2);
  }
};
var Vg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = at(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = it(t, o);
    if (u)
      return c;
    const { isError: f2, errorObject: m2, criteriaValues: d2 } = ot(r);
    if (f2)
      return m2;
    const _2 = [];
    let C = 0, E = 0;
    for (let V = 1; V < o.length; V++) {
      const S2 = o[V][l];
      typeof S2 == "number" && ut(d2, o, V) && (_2.push(S2), C += S2, E++);
    }
    if (E <= 1)
      return g2.create(h.DIV_BY_ZERO);
    const R = C / E;
    let b = 0;
    for (let V = 0; V < E; V++)
      b += __pow(_2[V] - R, 2);
    const p2 = Math.sqrt(b / (E - 1));
    return y2.create(p2);
  }
};
var Og = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = at(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = it(t, o);
    if (u)
      return c;
    const { isError: f2, errorObject: m2, criteriaValues: d2 } = ot(r);
    if (f2)
      return m2;
    const _2 = [];
    let C = 0, E = 0;
    for (let V = 1; V < o.length; V++) {
      const S2 = o[V][l];
      typeof S2 == "number" && ut(d2, o, V) && (_2.push(S2), C += S2, E++);
    }
    if (E === 0)
      return g2.create(h.DIV_BY_ZERO);
    const R = C / E;
    let b = 0;
    for (let V = 0; V < E; V++)
      b += __pow(_2[V] - R, 2);
    const p2 = Math.sqrt(b / E);
    return y2.create(p2);
  }
};
var Sg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = at(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = it(t, o);
    if (u)
      return c;
    const { isError: f2, errorObject: m2, criteriaValues: d2 } = ot(r);
    if (f2)
      return m2;
    let _2 = 0;
    for (let C = 1; C < o.length; C++) {
      const E = o[C][l];
      typeof E == "number" && ut(d2, o, C) && (_2 += E);
    }
    return y2.create(_2);
  }
};
var Mg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = at(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = it(t, o);
    if (u)
      return c;
    const { isError: f2, errorObject: m2, criteriaValues: d2 } = ot(r);
    if (f2)
      return m2;
    const _2 = [];
    let C = 0, E = 0;
    for (let V = 1; V < o.length; V++) {
      const S2 = o[V][l];
      typeof S2 == "number" && ut(d2, o, V) && (_2.push(S2), C += S2, E++);
    }
    if (E <= 1)
      return g2.create(h.DIV_BY_ZERO);
    const R = C / E;
    let b = 0;
    for (let V = 0; V < E; V++)
      b += __pow(_2[V] - R, 2);
    const p2 = b / (E - 1);
    return y2.create(p2);
  }
};
var Dg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = at(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = it(t, o);
    if (u)
      return c;
    const { isError: f2, errorObject: m2, criteriaValues: d2 } = ot(r);
    if (f2)
      return m2;
    const _2 = [];
    let C = 0, E = 0;
    for (let V = 1; V < o.length; V++) {
      const S2 = o[V][l];
      typeof S2 == "number" && ut(d2, o, V) && (_2.push(S2), C += S2, E++);
    }
    if (E === 0)
      return g2.create(h.DIV_BY_ZERO);
    const R = C / E;
    let b = 0;
    for (let V = 0; V < E; V++)
      b += __pow(_2[V] - R, 2);
    const p2 = b / E;
    return y2.create(p2);
  }
};
var Xe = ((a2) => (a2.DAVERAGE = "DAVERAGE", a2.DCOUNT = "DCOUNT", a2.DCOUNTA = "DCOUNTA", a2.DGET = "DGET", a2.DMAX = "DMAX", a2.DMIN = "DMIN", a2.DPRODUCT = "DPRODUCT", a2.DSTDEV = "DSTDEV", a2.DSTDEVP = "DSTDEVP", a2.DSUM = "DSUM", a2.DVAR = "DVAR", a2.DVARP = "DVARP", a2))(Xe || {});
var wg = [
  [Ag, Xe.DAVERAGE],
  [Eg, Xe.DCOUNT],
  [Rg, Xe.DCOUNTA],
  [bg, Xe.DGET],
  [yg, Xe.DMAX],
  [pg, Xe.DMIN],
  [Ng, Xe.DPRODUCT],
  [Vg, Xe.DSTDEV],
  [Og, Xe.DSTDEVP],
  [Sg, Xe.DSUM],
  [Mg, Xe.DVAR],
  [Dg, Xe.DVARP]
];
var Xa = "yyyy/mm/dd;@";
var Lg = "yyyy/mm/dd hh:mm";
var Pg = "h:mm A/P";
function pe2(a2) {
  const i = new Date(Date.UTC(1900, 0, 1)), e = new Date(Date.UTC(1900, 1, 28)), t = Date.UTC(a2.getFullYear(), a2.getMonth(), a2.getDate());
  let r = (t - i.getTime()) / (1e3 * 3600 * 24);
  return t > e.getTime() && (r += 1), Math.floor(r) + 1;
}
function tn(a2) {
  const i = new Date(Date.UTC(1900, 0, 1, 0, 0, 0)), e = new Date(Date.UTC(1900, 1, 28, 0, 0, 0));
  let r = (a2.getTime() - i.getTime()) / (1e3 * 3600 * 24);
  return a2 > e && (r += 1), r + 1;
}
function ae(a2) {
  const i = new Date(Date.UTC(1900, 0, 1)), e = new Date(Date.UTC(1900, 1, 28));
  let t = Math.floor(a2) - 1;
  return t > (e.getTime() - i.getTime()) / (1e3 * 3600 * 24) && (t -= 1), new Date(i.getTime() + t * (1e3 * 3600 * 24));
}
function Ka(a2) {
  const i = new Date(Date.UTC(1900, 0, 1, 0, 0, 0)), e = new Date(Date.UTC(1900, 1, 28, 0, 0, 0));
  let t = a2 - 1;
  return t > (e.getTime() - i.getTime()) / (1e3 * 3600 * 24) && (t -= 1), t < 0 && (t = a2), new Date(i.getTime() + t * (1e3 * 3600 * 24));
}
function Za(a2) {
  if (!/^\d{4}[-/](0?[1-9]|1[012])[-/](0?[1-9]|[12][0-9]|3[01])$/.test(a2))
    return false;
  const e = a2.replace(/-/g, "/").replace(/T.+/, ""), t = /* @__PURE__ */ new Date(`${e}`);
  if (Number.isNaN(t.getTime()))
    return false;
  const r = t.getFullYear(), n = (t.getMonth() + 1).toString().padStart(2, "0"), s = t.getDate().toString().padStart(2, "0"), o = `${r}-${n}-${s}`;
  return a2.replace(/\//g, "-").split("-").map((c) => c.padStart(2, "0")).join("-") === o;
}
function Yn(a2) {
  return a1.parseDate(a2);
}
function xg(a2) {
  return a1.parseValue(a2);
}
function Hn2(a2) {
  return a1.parseTime(a2);
}
function za(a2) {
  return a1.getFormatInfo(a2).isDate;
}
var sc = {
  1: [6, 0],
  // Saturday, Sunday
  2: [0, 1],
  // Sunday, Monday
  3: [1, 2],
  // Monday, Tuesday
  4: [2, 3],
  // Tuesday, Wednesday
  5: [3, 4],
  // Wednesday, Thursday
  6: [4, 5],
  // Thursday, Friday
  7: [5, 6],
  // Friday, Saturday
  11: [0],
  // Sunday only
  12: [1],
  // Monday only
  13: [2],
  // Tuesday only
  14: [3],
  // Wednesday only
  15: [4],
  // Thursday only
  16: [5],
  // Friday only
  17: [6]
  // Saturday only
};
function Qr(a2) {
  return !!(typeof a2 == "string" && /^[0|1]{7}/.test(a2) || sc[Number(a2)]);
}
function ac(a2) {
  if (!Qr(a2))
    return [];
  if (typeof a2 == "string" && /^[0|1]{7}/.test(a2)) {
    const i = [];
    for (let e = 1; e <= a2.length; e++)
      `${a2[e - 1]}` == "1" && (e === a2.length ? i.push(0) : i.push(e));
    return i;
  }
  return sc[Number(a2)] || [];
}
function Gn(a2, i, e = 1, t) {
  const r = ac(e), n = Math.floor(a2), s = Math.floor(i), o = s > n ? n : s;
  let u = 0;
  const c = Math.abs(Math.floor(i) - Math.floor(a2)) + 1;
  for (let l = 0; l < c; l++) {
    const f2 = o + l;
    if (t && t.length > 0 && t.some((d2) => Math.floor(d2) === f2))
      continue;
    const m2 = or(f2);
    r.includes(m2) || u++;
  }
  return s >= n ? u : -u;
}
function Wn(a2, i, e = 1, t) {
  const r = ac(e), n = Math.floor(a2);
  let s = n, o = Math.abs(i);
  for (let u = 1; u <= o; u++) {
    const c = i < 0 ? n - u : n + u;
    if (c < 0)
      return g2.create(h.NUM);
    if (t && t.length > 0 && t.some((f2) => Math.floor(f2) === c)) {
      o++;
      continue;
    }
    const l = or(c);
    if (r.includes(l)) {
      o++;
      continue;
    }
    s = c;
  }
  return s;
}
function H(a2) {
  if (a2.isError())
    return a2;
  const i = a2.getValue();
  if (a2.isString()) {
    let e;
    if (Yn(`${i}`))
      e = Yn(`${i}`).v;
    else if (Hn2(`${i}`))
      e = Hn2(`${i}`).v;
    else if (s1(i))
      e = +i;
    else
      return g2.create(h.VALUE);
    return e instanceof Date && (e = tn(e)), +e < 0 || +e > 2958465 ? g2.create(h.NUM) : +e;
  } else {
    const e = +a2.getValue();
    return e < 0 || e > 2958465 ? g2.create(h.NUM) : e;
  }
}
function or(a2) {
  const i = Math.floor(a2) === 60;
  let e = ae(a2);
  const t = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate())).getTime(), r = new Date(Date.UTC(1900, 1, 28)).getTime();
  return !i && t <= r && (e = new Date(t - 24 * 3600 * 1e3)), new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate())).getUTCDay();
}
function _e2(a2, i, e) {
  switch (e) {
    case 0:
      return jg(a2, i);
    case 1:
      return Ug(a2, i);
    case 2:
      return {
        days: Math.abs(i - a2),
        yearDays: 360
      };
    case 3:
      return {
        days: Math.abs(i - a2),
        yearDays: 365
      };
    case 4:
      return vg(a2, i);
    default:
      return {
        days: Math.abs(i - a2),
        yearDays: 365
      };
  }
}
function jg(a2, i) {
  const e = ae(a2), t = a2 > 0 ? e.getUTCFullYear() : 1900, r = a2 > 0 ? e.getUTCMonth() + 1 : 1;
  let n = a2 > 0 ? e.getUTCDate() : 0, s = ae(i), o = i > 0 ? s.getUTCFullYear() : 1900, u = i > 0 ? s.getUTCMonth() + 1 : 1, c = i > 0 ? s.getUTCDate() : 0;
  r === 2 ? ae(a2 + 1).getUTCMonth() + 1 === 3 && (n = 30) : n === 31 && (n = 30), c === 31 && (n < 30 ? (s = ae(i + 1), o = s.getUTCFullYear(), u = s.getUTCMonth() + 1, c = s.getUTCDate()) : c = 30);
  const l = (o - t) * 360, f2 = i >= a2 ? 30 - n : -n, m2 = i >= a2 ? c : c - 30, d2 = (i >= a2 ? u - r - 1 : u - r + 1) * 30;
  return {
    days: Math.abs(l + f2 + m2 + d2),
    yearDays: 360
  };
}
function Ug(a2, i) {
  const e = ae(a2), t = a2 > 0 ? e.getUTCFullYear() : 1900, r = ae(i), n = i > 0 ? r.getUTCFullYear() : 1900, s = Math.abs(i - a2), o = Math.abs(n - t) + 1;
  let u, c;
  if (n < t) {
    const l = new Date(Date.UTC(n, 0, 1)), f2 = new Date(Date.UTC(t, 11, 31));
    u = pe2(l), c = pe2(f2), n === 1900 && (u += 1);
  } else {
    const l = new Date(Date.UTC(t, 0, 1)), f2 = new Date(Date.UTC(n, 11, 31));
    u = pe2(l), c = pe2(f2), t === 1900 && (u += 1);
  }
  return {
    days: s,
    yearDays: (c - u + 1) / o
  };
}
function vg(a2, i) {
  const e = ae(a2), t = a2 > 0 ? e.getUTCFullYear() : 1900, r = a2 > 0 ? e.getUTCMonth() + 1 : 1;
  let n = a2 > 0 ? e.getUTCDate() : 0;
  const s = ae(i), o = i > 0 ? s.getUTCFullYear() : 1900, u = i > 0 ? s.getUTCMonth() + 1 : 1;
  let c = i > 0 ? s.getUTCDate() : 0;
  n === 31 && (n = 30), c === 31 && (c = 30);
  const l = (o - t) * 360, f2 = i >= a2 ? 30 - n : -n, m2 = i >= a2 ? c : c - 30, d2 = (i >= a2 ? u - r - 1 : u - r + 1) * 30;
  return {
    days: Math.abs(l + f2 + m2 + d2),
    yearDays: 360
  };
}
function Tg(a2) {
  return a2 % 4 === 0 && a2 % 100 !== 0 || a2 % 400 === 0;
}
function Ig(a2) {
  return a2 % 4 === 0 && a2 % 100 !== 0 || a2 % 400 === 0 || a2 === 1900;
}
var Bg = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var Fg = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function rn(a2, i) {
  return Tg(a2) ? Bg[i] : Fg[i];
}
function _s2(a2) {
  return Ig(a2) ? 366 : 365;
}
function ic(a2, i) {
  switch (i) {
    case 0:
    case 2:
    case 4:
      return 360;
    case 1:
      return _s2(ae(a2).getUTCFullYear());
    case 3:
      return 365;
    default:
      return -1;
  }
}
function Sr(a2, i, e) {
  return rn(a2, i) === e;
}
function Mr(a2, i) {
  let e = a2.getUTCFullYear(), t = a2.getUTCMonth();
  const r = a2.getUTCDate();
  return Sr(e, t, r) ? (a2.setUTCDate(1), a2.setUTCMonth(a2.getUTCMonth() + i), e = a2.getUTCFullYear(), t = a2.getUTCMonth(), a2.setUTCDate(rn(e, t))) : a2.setUTCMonth(a2.getUTCMonth() + i), a2;
}
var kg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, t, g2.create(h.NA)), c = O(n, s, r, g2.create(h.NA)), l = o.map((f2, m2, d2) => {
      const _2 = u.get(m2, d2), C = c.get(m2, d2);
      if (f2.isError())
        return f2;
      if (_2.isError())
        return _2;
      if (C.isError())
        return C;
      const { isError: E, errorObject: R, variants: b } = I2(f2, _2, C);
      if (E)
        return R;
      const [p2, V, S2] = b;
      let M2 = Math.floor(+p2.getValue());
      const D2 = Math.floor(+V.getValue()), w = Math.floor(+S2.getValue());
      if (M2 < 0 || M2 > 9999)
        return g2.create(h.NUM);
      M2 >= 0 && M2 < 1899 && (M2 += 1900);
      const L = new Date(M2, D2 - 1, w), v = pe2(L);
      return v < 0 ? g2.create(h.NUM) : y2.create(v, Xa);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
};
var $g = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    let n = e, s = t, o = r;
    if (n.isArray() && (n = n.get(0, 0)), s.isArray() && (s = s.get(0, 0)), o.isArray() && (o = o.get(0, 0)), n.isError())
      return n;
    if (s.isError())
      return s;
    if (o.isError())
      return o;
    const u = H(n);
    if (typeof u != "number")
      return u;
    const c = H(s);
    return typeof c != "number" ? c : c < u || !o.isString() ? g2.create(h.NUM) : this._getResultByUnit(u, c, o);
  }
  _getResultByUnit(e, t, r) {
    const n = ae(e), s = n.getUTCFullYear(), o = n.getUTCMonth() + 1, u = n.getUTCDate(), c = ae(t), l = c.getUTCFullYear(), f2 = c.getUTCMonth() + 1, m2 = c.getUTCDate(), d2 = `${r.getValue()}`.toLocaleUpperCase();
    let _2 = 0, C;
    switch (d2) {
      case "Y":
        _2 = l - s, (f2 < o || f2 === o && m2 < u) && (_2 -= 1);
        break;
      case "M":
        _2 = (l - s) * 12 + f2 - o, m2 < u && (_2 -= 1);
        break;
      case "D":
        _2 = Math.floor(t) - Math.floor(e);
        break;
      case "MD":
        _2 = m2 - u, m2 < u && (C = new Date(Date.UTC(l, f2 - 1, 0)), _2 += rn(C.getUTCFullYear(), C.getUTCMonth()));
        break;
      case "YM":
        _2 = f2 - o, (f2 < o || f2 === o && m2 < u) && (_2 += 12), m2 < u && (_2 -= 1);
        break;
      case "YD":
        C = new Date(Date.UTC(s, f2 - 1, m2)), (f2 < o || f2 === o && m2 < u) && (C = new Date(Date.UTC(s + 1, f2 - 1, m2))), _2 = Math.floor(pe2(C)) - Math.floor(e);
        break;
      default:
        return g2.create(h.NUM);
    }
    return y2.create(_2);
  }
};
var Yg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  isArgumentsIgnoreNumberPattern() {
    return true;
  }
  calculate(e) {
    return e.isArray() ? e.mapValue((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isString()) {
      const t = `${e.getValue()}`;
      let r = Yn(t);
      if (r === null && (r = Hn2(t)), r) {
        let { v: n, z: s } = r;
        if (s && za(s))
          return n instanceof Date && (n = tn(n)), y2.create(Math.trunc(+n));
      }
    }
    return g2.create(h.VALUE);
  }
};
var Hg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isError() ? e : e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t;
    const r = e.getValue();
    if (e.isString()) {
      if (!Za(`${r}`))
        return g2.create(h.VALUE);
      t = /* @__PURE__ */ new Date(`${r}`);
    } else {
      const o = +e.getValue();
      if (o < 0)
        return g2.create(h.NUM);
      if (o === 0)
        return y2.create(0);
      t = ae(o);
    }
    const n = t.getDate();
    return y2.create(n);
  }
};
var Gg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e), o = O(r, n, t), u = s.map((c, l, f2) => {
      const m2 = o.get(l, f2);
      if (c.isError())
        return c;
      if (m2.isError())
        return m2;
      const d2 = H(c);
      if (typeof d2 != "number")
        return d2;
      const _2 = H(m2);
      if (typeof _2 != "number")
        return _2;
      const C = Math.floor(d2) - Math.floor(_2);
      return y2.create(C);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
};
var Wg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : T.create(false);
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (n.isError())
      return n;
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g2.create(h.NA)), c = O(s, o, t, g2.create(h.NA)), l = O(s, o, n, g2.create(h.NA)), f2 = u.map((m2, d2, _2) => {
      const C = c.get(d2, _2);
      let E = l.get(d2, _2);
      if (m2.isError())
        return m2;
      const R = H(m2);
      if (typeof R != "number")
        return R;
      if (C.isError())
        return C;
      const b = H(C);
      if (typeof b != "number")
        return b;
      if (E.isString() && (E = E.convertToNumberObjectValue()), E.isError())
        return E;
      const p2 = +E.getValue(), { days: V } = _e2(R, b, p2 ? 4 : 0), S2 = b >= R ? V : -V;
      return y2.create(S2);
    });
    return s === 1 && o === 1 ? f2.get(0, 0) : f2;
  }
};
var Qg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e), o = O(r, n, t);
    return s.map((u, c, l) => {
      const f2 = o.get(c, l) || ce.create();
      if (u.isError())
        return u;
      if (f2.isError())
        return f2;
      if (u.isString() || u.isBoolean() || f2.isString() || f2.isBoolean())
        return g2.create(h.VALUE);
      const m2 = +u.getValue();
      if (m2 < 0)
        return g2.create(h.NUM);
      const d2 = Math.floor(+f2.getValue()), _2 = ae(m2), C = _2.getUTCFullYear(), E = _2.getUTCMonth() + d2, R = _2.getUTCDate(), b = new Date(Date.UTC(C, E, R)), p2 = pe2(b);
      return y2.create(p2, Xa);
    });
  }
};
var qg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e, n = t;
    if (r.isArray()) {
      const d2 = r.getRowCount(), _2 = r.getColumnCount();
      if (d2 > 1 || _2 > 1)
        return g2.create(h.VALUE);
      r = r.get(0, 0);
    }
    if (n.isArray()) {
      const d2 = n.getRowCount(), _2 = n.getColumnCount();
      if (d2 > 1 || _2 > 1)
        return g2.create(h.VALUE);
      n = n.get(0, 0);
    }
    if (r.isError())
      return r;
    if (n.isError())
      return n;
    const s = H(r);
    if (typeof s != "number")
      return s;
    if (n.isBoolean())
      return g2.create(h.VALUE);
    const o = ae(s), u = s > 0 ? o.getUTCFullYear() : 1900, c = s > 0 ? o.getUTCMonth() : 0, l = Math.floor(+n.getValue());
    if (Number.isNaN(l))
      return g2.create(h.VALUE);
    const f2 = new Date(Date.UTC(u, c + l + 1, 0)), m2 = pe2(f2);
    return y2.create(m2);
  }
};
var Xg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
    A(this, "needsReferenceObject", true);
  }
  calculate(e, t) {
    const r = t != null ? t : y2.create(1), { isError: n, errorObject: s, timestampIsReferenceObject: o, timestampObject: u, unitObject: c } = this._checkVariants(e, r);
    if (n)
      return s;
    if (u.isNull() || u.isBoolean() || u.isString() || !o && u.isNumber() && u.getPattern() !== "")
      return g2.create(h.VALUE);
    let l = +u.getValue();
    const { isError: f2, errorObject: m2, variants: d2 } = I2(c);
    if (f2)
      return m2;
    const [_2] = d2, C = Math.floor(+_2.getValue());
    if (l < 0 || C < 1 || C > 3)
      return g2.create(h.NUM);
    C === 1 && (l = l * 1e3), C === 3 && (l = l / 1e3);
    const E = new Date(Date.UTC(1970, 0, 1, 0, 0, 0, 0) + l);
    if (Number.isNaN(E.getTime())) {
      const R = 25569 + l / 864e5;
      return y2.create(R);
    } else {
      const R = tn(E);
      return y2.create(R, "yyyy-MM-dd AM/PM hh:mm:ss");
    }
  }
  _checkVariants(e, t) {
    const r = e.isReferenceObject(), n = t.isReferenceObject();
    let s = e;
    if (r && (s = e.toArrayValueObject()), s.isArray()) {
      const u = s.getRowCount(), c = s.getColumnCount();
      if (u > 1 || c > 1)
        return {
          isError: true,
          errorObject: g2.create(h.VALUE)
        };
      s = s.get(0, 0);
    }
    if (s.isError())
      return {
        isError: true,
        errorObject: s
      };
    let o = t;
    if (n && (o = t.toArrayValueObject()), o.isArray()) {
      const u = o.getRowCount(), c = o.getColumnCount();
      if (u > 1 || c > 1)
        return {
          isError: true,
          errorObject: g2.create(h.VALUE)
        };
      o = o.get(0, 0);
    }
    return o.isError() ? {
      isError: true,
      errorObject: o
    } : {
      isError: false,
      errorObject: null,
      timestampIsReferenceObject: r,
      timestampObject: s,
      unitIsReferenceObject: n,
      unitObject: o
    };
  }
};
var Ae = ((a2) => (a2.DATE = "DATE", a2.DATEDIF = "DATEDIF", a2.DATEVALUE = "DATEVALUE", a2.DAY = "DAY", a2.DAYS = "DAYS", a2.DAYS360 = "DAYS360", a2.EDATE = "EDATE", a2.EOMONTH = "EOMONTH", a2.EPOCHTODATE = "EPOCHTODATE", a2.HOUR = "HOUR", a2.ISOWEEKNUM = "ISOWEEKNUM", a2.MINUTE = "MINUTE", a2.MONTH = "MONTH", a2.NETWORKDAYS = "NETWORKDAYS", a2.NETWORKDAYS_INTL = "NETWORKDAYS.INTL", a2.NOW = "NOW", a2.SECOND = "SECOND", a2.TIME = "TIME", a2.TIMEVALUE = "TIMEVALUE", a2.TO_DATE = "TO_DATE", a2.TODAY = "TODAY", a2.WEEKDAY = "WEEKDAY", a2.WEEKNUM = "WEEKNUM", a2.WORKDAY = "WORKDAY", a2.WORKDAY_INTL = "WORKDAY.INTL", a2.YEAR = "YEAR", a2.YEARFRAC = "YEARFRAC", a2))(Ae || {});
var Kg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isError() ? e : e.isArray() ? e.map((t) => t.isError() ? t : this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const t = H(e);
    if (typeof t != "number")
      return t;
    if (t === 0)
      return y2.create(0);
    const n = Ka(t).getUTCHours();
    return y2.create(n);
  }
};
var Zg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isError() ? e : e.isArray() ? e.map((t) => t.isError() ? t : this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const t = H(e);
    if (typeof t != "number")
      return t;
    const r = ae(t), n = t > 0 ? r.getUTCFullYear() : 1900;
    let s = new Date(Date.UTC(n, 0, 1)), o = pe2(s), u = or(o), c;
    u < 1 ? c = o + 1 : u <= 4 ? c = o - (u - 1) : c = o + (11 - u), t < c && (s = new Date(Date.UTC(n - 1, 0, 1)), o = pe2(s), u = or(o), u < 1 ? c = o + 1 : u <= 4 ? c = o - (u - 1) : c = o + (11 - u));
    const l = Math.ceil((t - c + 1) / 7);
    return y2.create(l);
  }
};
var zg = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isError() ? e : e.isArray() ? e.map((t) => t.isError() ? t : this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const t = H(e);
    if (typeof t != "number")
      return t;
    if (t === 0)
      return y2.create(0);
    const n = Ka(t).getUTCMinutes();
    return y2.create(n);
  }
};
var Jg2 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    let t;
    const r = e.getValue();
    if (e.isString()) {
      if (!Za(`${r}`))
        return g2.create(h.VALUE);
      t = /* @__PURE__ */ new Date(`${r}`);
    } else {
      const o = +e.getValue();
      if (o < 0)
        return g2.create(h.NUM);
      if (o === 0)
        return y2.create(1);
      t = ae(o);
    }
    const n = t.getUTCMonth() + 1;
    return y2.create(n);
  }
};
var e1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    let n = e, s = t;
    if (n.isArray()) {
      const l = n.getRowCount(), f2 = n.getColumnCount();
      if (l > 1 || f2 > 1)
        return g2.create(h.VALUE);
      n = n.get(0, 0);
    }
    if (n.isError())
      return n;
    if (s.isArray()) {
      const l = s.getRowCount(), f2 = s.getColumnCount();
      if (l > 1 || f2 > 1)
        return g2.create(h.VALUE);
      s = s.get(0, 0);
    }
    if (s.isError())
      return s;
    if (r != null && r.isError())
      return r;
    if (n.isBoolean() || s.isBoolean())
      return g2.create(h.VALUE);
    const o = H(n);
    if (typeof o != "number")
      return o;
    const u = H(s);
    if (typeof u != "number")
      return u;
    if (r)
      return this._getResultByHolidays(o, u, r);
    const c = Gn(o, u);
    return y2.create(c);
  }
  _getResultByHolidays(e, t, r) {
    const n = [];
    if (r != null && r.isArray()) {
      const o = r.getRowCount(), u = r.getColumnCount();
      for (let c = 0; c < o; c++)
        for (let l = 0; l < u; l++) {
          const f2 = r.get(c, l);
          if (f2.isBoolean())
            return g2.create(h.VALUE);
          const m2 = H(f2);
          if (typeof m2 != "number")
            return m2;
          n.push(m2);
        }
    } else {
      if (r.isBoolean())
        return g2.create(h.VALUE);
      const o = H(r);
      if (typeof o != "number")
        return o;
      n.push(o);
    }
    const s = Gn(e, t, 1, n);
    return y2.create(s);
  }
};
var t1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    return e.isError() ? e : t.isError() ? t : r != null && r.isError() ? r : n != null && n.isError() ? n : r != null && r.isArray() ? r.map((s) => this._handleSingleObject(e, t, s, n)) : this._handleSingleObject(e, t, r, n);
  }
  _handleSingleObject(e, t, r, n) {
    let s = e, o = t;
    if (s.isArray()) {
      const m2 = s.getRowCount(), d2 = s.getColumnCount();
      if (m2 > 1 || d2 > 1)
        return g2.create(h.VALUE);
      s = s.get(0, 0);
    }
    if (s.isError())
      return s;
    if (o.isArray()) {
      const m2 = o.getRowCount(), d2 = o.getColumnCount();
      if (m2 > 1 || d2 > 1)
        return g2.create(h.VALUE);
      o = o.get(0, 0);
    }
    if (o.isError())
      return o;
    let u = 1;
    if (r) {
      if (u = r.getValue(), r.isBoolean() && (u = +u), r.isString() && !Qr(u))
        return g2.create(h.VALUE);
      if (!Qr(u))
        return g2.create(h.NUM);
    }
    if (s.isBoolean() || o.isBoolean())
      return g2.create(h.VALUE);
    const c = H(s);
    if (typeof c != "number")
      return c;
    const l = H(o);
    if (typeof l != "number")
      return l;
    if (n)
      return this._getResultByHolidays(c, l, u, n);
    const f2 = Gn(c, l, u);
    return y2.create(f2);
  }
  _getResultByHolidays(e, t, r, n) {
    const s = [];
    if (n != null && n.isArray()) {
      const u = n.getRowCount(), c = n.getColumnCount();
      for (let l = 0; l < u; l++)
        for (let f2 = 0; f2 < c; f2++) {
          const m2 = n.get(l, f2);
          if (m2.isBoolean())
            return g2.create(h.VALUE);
          const d2 = H(m2);
          if (typeof d2 != "number")
            return d2;
          s.push(d2);
        }
    } else {
      if (n.isBoolean())
        return g2.create(h.VALUE);
      const u = H(n);
      if (typeof u != "number")
        return u;
      s.push(u);
    }
    const o = Gn(e, t, r, s);
    return y2.create(o);
  }
};
var r1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 0);
  }
  calculate() {
    const e = /* @__PURE__ */ new Date(), t = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds())), r = tn(t);
    return y2.create(r, Lg);
  }
};
var n1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isError() ? e : e.isArray() ? e.map((t) => t.isError() ? t : this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const t = H(e);
    if (typeof t != "number")
      return t;
    if (t === 0)
      return y2.create(0);
    const n = Ka(t).getUTCSeconds();
    return y2.create(n);
  }
};
var s12 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (r.isError())
      return r;
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e), u = O(n, s, t), c = O(n, s, r);
    return o.map((l, f2, m2) => this._calculateTime(l, u, c, f2, m2));
  }
  _calculateTime(e, t, r, n, s) {
    let o = e, u = t.get(n, s) || ce.create(), c = r.get(n, s) || ce.create();
    if ((o.isString() || o.isBoolean()) && (o = o.convertToNumberObjectValue()), (u.isString() || u.isBoolean()) && (u = u.convertToNumberObjectValue()), (c.isString() || c.isBoolean()) && (c = c.convertToNumberObjectValue()), o.isError())
      return o;
    if (u.isError())
      return u;
    if (c.isError())
      return c;
    let l = Math.floor(+o.getValue()), f2 = Math.floor(+u.getValue()), m2 = Math.floor(+c.getValue());
    if (l < 0 || f2 < 0 || m2 < 0 || l > 32767 || f2 > 32767 || m2 > 32767)
      return g2.create(h.NUM);
    f2 += Math.floor(m2 / 60), m2 %= 60, l += Math.floor(f2 / 60), f2 %= 60, l %= 24;
    const _2 = (l * 3600 + f2 * 60 + m2) / 86400;
    return y2.create(_2, Pg);
  }
};
var a12 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  isArgumentsIgnoreNumberPattern() {
    return true;
  }
  calculate(e) {
    return e.isArray() ? e.mapValue((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isString()) {
      const t = `${e.getValue()}`, r = xg(t);
      if (r) {
        let { v: n, z: s } = r;
        if (s && za(s))
          return n instanceof Date && (n = tn(n)), y2.create(Am(+n));
      }
    }
    return g2.create(h.VALUE);
  }
};
var i12 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
    A(this, "needsReferenceObject", true);
  }
  calculate(e) {
    const t = e.isReferenceObject();
    let r = e;
    if (t && (r = e.toArrayValueObject()), r.isArray()) {
      const s = r.getRowCount(), o = r.getColumnCount();
      if (s > 1 || o > 1)
        return g2.create(h.VALUE);
      r = r.get(0, 0);
    }
    if (r.isError() || r.isNull() || r.isBoolean() || r.isString() || !t && r.isNumber() && r.getPattern() !== "")
      return r;
    const n = +r.getValue();
    return y2.create(n, "yyyy-MM-dd hh:mm:ss AM/PM");
  }
};
var o1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 0);
  }
  calculate() {
    const e = pe2(/* @__PURE__ */ new Date());
    return y2.create(e, Xa);
  }
};
var u1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
    A(this, "_returnTypeMap", {
      1: [1, 2, 3, 4, 5, 6, 7],
      // Sunday = 1 ~ Saturday = 7
      2: [7, 1, 2, 3, 4, 5, 6],
      // Monday = 1 ~ Sunday = 7
      3: [6, 0, 1, 2, 3, 4, 5],
      // Monday = 0 ~ Sunday = 6
      11: [7, 1, 2, 3, 4, 5, 6],
      // Monday = 1 ~ Sunday = 7
      12: [6, 7, 1, 2, 3, 4, 5],
      // Tuesday = 1 ~ Monday = 7
      13: [5, 6, 7, 1, 2, 3, 4],
      // Wednesday = 1 ~ Tuesday = 7
      14: [4, 5, 6, 7, 1, 2, 3],
      // Thursday = 1 ~ Wednesday = 7
      15: [3, 4, 5, 6, 7, 1, 2],
      // Friday = 1 ~ Thursday = 7
      16: [2, 3, 4, 5, 6, 7, 1],
      // Saturday = 1 ~ Friday = 7
      17: [1, 2, 3, 4, 5, 6, 7]
      // Sunday = 1 ~ Saturday = 7
    });
  }
  calculate(e, t) {
    const r = t != null ? t : y2.create(1);
    if (e.isError())
      return e;
    if (r.isError())
      return r;
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, r, g2.create(h.NA)), c = o.map((l, f2, m2) => {
      const d2 = u.get(f2, m2);
      return this._handleSingleObject(l, d2);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
  _handleSingleObject(e, t) {
    let r = t;
    if (e.isError())
      return e;
    if (r.isError())
      return r;
    const n = H(e);
    if (typeof n != "number")
      return n;
    if (r.isString() && (r = r.convertToNumberObjectValue(), r.isError()))
      return r;
    const s = Math.floor(+r.getValue());
    if (!this._returnTypeMap[s])
      return g2.create(h.NUM);
    const o = or(n), u = this._returnTypeMap[s][o];
    return y2.create(u);
  }
};
var c1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
    A(this, "_returnTypeMap", {
      1: 0,
      2: 1,
      11: 1,
      12: 2,
      13: 3,
      14: 4,
      15: 5,
      16: 6,
      17: 0,
      21: 4
    });
  }
  calculate(e, t) {
    let r = e, n = t != null ? t : y2.create(1);
    if (r.isArray()) {
      const u = r.getRowCount(), c = r.getColumnCount();
      if (u > 1 || c > 1)
        return g2.create(h.VALUE);
      r = r.get(0, 0);
    }
    if (r.isError())
      return r;
    if (n.isArray()) {
      const u = n.getRowCount(), c = n.getColumnCount();
      if (u > 1 || c > 1)
        return g2.create(h.VALUE);
      n = n.get(0, 0);
    }
    if (n.isError())
      return n;
    if (r.isBoolean())
      return g2.create(h.VALUE);
    const s = H(r);
    if (typeof s != "number")
      return s;
    if (n.isBoolean())
      return g2.create(h.VALUE);
    const o = Math.floor(+n.getValue());
    return Number.isNaN(o) ? g2.create(h.VALUE) : o in this._returnTypeMap ? this._getResult(s, o) : g2.create(h.NUM);
  }
  _getResult(e, t) {
    const r = ae(e), n = e > 0 ? r.getUTCFullYear() : 1900;
    let s = new Date(Date.UTC(n, 0, 1)), o = pe2(s), u = or(o), c;
    if (t === 21)
      u < 1 ? c = o + 1 : u <= 4 ? c = o - (u - 1) : c = o + (11 - u), e < c && (s = new Date(Date.UTC(n - 1, 0, 1)), o = pe2(s), u = or(o), u < 1 ? c = o + 1 : u <= 4 ? c = o - (u - 1) : c = o + (11 - u));
    else {
      const f2 = this._returnTypeMap[t];
      u < f2 ? c = o - (u + 7 - f2) : c = o - (u - f2);
    }
    const l = Math.ceil((e - c + 1) / 7);
    return y2.create(l);
  }
};
var l12 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    let n = e, s = t;
    if (n.isArray()) {
      const l = n.getRowCount(), f2 = n.getColumnCount();
      if (l > 1 || f2 > 1)
        return g2.create(h.VALUE);
      n = n.get(0, 0);
    }
    if (n.isError())
      return n;
    if (s.isArray()) {
      const l = s.getRowCount(), f2 = s.getColumnCount();
      if (l > 1 || f2 > 1)
        return g2.create(h.VALUE);
      s = s.get(0, 0);
    }
    if (s.isError())
      return s;
    if (r != null && r.isError())
      return r;
    if (n.isBoolean() || s.isBoolean())
      return g2.create(h.VALUE);
    const o = H(n);
    if (typeof o != "number")
      return o;
    const u = +s.getValue();
    if (Number.isNaN(u))
      return g2.create(h.VALUE);
    if (r)
      return this._getResultByHolidays(o, u, r);
    const c = Wn(o, u);
    return typeof c != "number" ? c : y2.create(c);
  }
  _getResultByHolidays(e, t, r) {
    const n = [];
    if (r != null && r.isArray()) {
      const o = r.getRowCount(), u = r.getColumnCount();
      for (let c = 0; c < o; c++)
        for (let l = 0; l < u; l++) {
          const f2 = r.get(c, l);
          if (f2.isBoolean())
            return g2.create(h.VALUE);
          const m2 = H(f2);
          if (typeof m2 != "number")
            return m2;
          n.push(m2);
        }
    } else {
      if (r.isBoolean())
        return g2.create(h.VALUE);
      const o = H(r);
      if (typeof o != "number")
        return o;
      n.push(o);
    }
    const s = Wn(e, t, 1, n);
    return typeof s != "number" ? s : y2.create(s);
  }
};
var f1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    return e.isError() ? e : t.isError() ? t : r != null && r.isError() ? r : n != null && n.isError() ? n : r != null && r.isArray() ? r.map((s) => this._handleSingleObject(e, t, s, n)) : this._handleSingleObject(e, t, r, n);
  }
  _handleSingleObject(e, t, r, n) {
    const s = r != null ? r : y2.create(1), o = this._checkArrayError(e);
    if (o.isError())
      return o;
    const u = this._checkArrayError(t);
    if (u.isError())
      return u;
    if (o.isBoolean() || u.isBoolean())
      return g2.create(h.VALUE);
    const c = H(e);
    if (typeof c != "number")
      return c;
    const l = +t.getValue();
    if (Number.isNaN(l))
      return g2.create(h.VALUE);
    let f2 = s.getValue();
    if (s.isBoolean() && (f2 = +f2), s.isString() && (!Qr(f2) || f2 === "1111111"))
      return g2.create(h.VALUE);
    if (!Qr(f2))
      return g2.create(h.NUM);
    if (n)
      return this._getResultByHolidays(c, l, f2, n);
    const m2 = Wn(c, l, f2);
    return typeof m2 != "number" ? m2 : y2.create(m2);
  }
  _checkArrayError(e) {
    let t = e;
    if (t.isArray()) {
      const r = t.getRowCount(), n = t.getColumnCount();
      if (r > 1 || n > 1)
        return g2.create(h.VALUE);
      t = t.get(0, 0);
    }
    return t.isError(), t;
  }
  _getResultByHolidays(e, t, r, n) {
    const s = [];
    if (n != null && n.isArray()) {
      const u = n.getRowCount(), c = n.getColumnCount();
      for (let l = 0; l < u; l++)
        for (let f2 = 0; f2 < c; f2++) {
          const m2 = n.get(l, f2);
          if (m2.isBoolean())
            return g2.create(h.VALUE);
          const d2 = H(m2);
          if (typeof d2 != "number")
            return d2;
          s.push(d2);
        }
    } else {
      if (n.isBoolean())
        return g2.create(h.VALUE);
      const u = H(n);
      if (typeof u != "number")
        return u;
      s.push(u);
    }
    const o = Wn(e, t, r, s);
    return typeof o != "number" ? o : y2.create(o);
  }
};
var m1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    let t;
    const r = e.getValue();
    if (e.isString()) {
      if (!Za(`${r}`))
        return g2.create(h.VALUE);
      t = /* @__PURE__ */ new Date(`${r}`);
    } else {
      const o = +r;
      if (o < 0)
        return g2.create(h.NUM);
      if (o === 0)
        return y2.create(1900);
      t = ae(o);
    }
    const n = t.getUTCFullYear();
    return y2.create(n);
  }
};
var h12 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    let n = r != null ? r : y2.create(0);
    const s = rr(e);
    if (s.isError())
      return s;
    const o = rr(t);
    if (o.isError())
      return o;
    if (n = rr(n), n.isError())
      return n;
    if (s.isBoolean() || o.isBoolean() || n.isBoolean())
      return g2.create(h.VALUE);
    const u = H(s);
    if (typeof u != "number")
      return u;
    const c = H(o);
    if (typeof c != "number")
      return c;
    const l = Math.floor(+n.getValue());
    if (Number.isNaN(l))
      return g2.create(h.VALUE);
    if (l < 0 || l > 4)
      return g2.create(h.NUM);
    const { days: f2, yearDays: m2 } = _e2(u, c, l), d2 = f2 / m2;
    return y2.create(d2);
  }
};
var g1 = [
  [kg, Ae.DATE],
  [$g, Ae.DATEDIF],
  [Yg, Ae.DATEVALUE],
  [Hg, Ae.DAY],
  [Gg, Ae.DAYS],
  [Wg, Ae.DAYS360],
  [Qg, Ae.EDATE],
  [qg, Ae.EOMONTH],
  [Xg, Ae.EPOCHTODATE],
  [Kg, Ae.HOUR],
  [Zg, Ae.ISOWEEKNUM],
  [zg, Ae.MINUTE],
  [Jg2, Ae.MONTH],
  [e1, Ae.NETWORKDAYS],
  [t1, Ae.NETWORKDAYS_INTL],
  [r1, Ae.NOW],
  [n1, Ae.SECOND],
  [s12, Ae.TIME],
  [a12, Ae.TIMEVALUE],
  [i12, Ae.TO_DATE],
  [o1, Ae.TODAY],
  [u1, Ae.WEEKDAY],
  [c1, Ae.WEEKNUM],
  [l12, Ae.WORKDAY],
  [f1, Ae.WORKDAY_INTL],
  [m1, Ae.YEAR],
  [h12, Ae.YEARFRAC]
];
var d1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull() || t.isNull())
      return g2.create(h.NA);
    const { isError: r, errorObject: n, variants: s } = W2(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (Number.isNaN(c) || Number.isNaN(l))
      return g2.create(h.VALUE);
    if (l < 0)
      return g2.create(h.NUM);
    const f2 = Or.besseli(c, l);
    return Number.isNaN(f2) || !Number.isFinite(f2) ? g2.create(h.NUM) : y2.create(f2);
  }
};
var C1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull() || t.isNull())
      return g2.create(h.NA);
    const { isError: r, errorObject: n, variants: s } = W2(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (Number.isNaN(c) || Number.isNaN(l))
      return g2.create(h.VALUE);
    if (l < 0)
      return g2.create(h.NUM);
    const f2 = Or.besselj(c, l);
    return Number.isNaN(f2) || !Number.isFinite(f2) ? g2.create(h.NUM) : y2.create(f2);
  }
};
var _1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull() || t.isNull())
      return g2.create(h.NA);
    const { isError: r, errorObject: n, variants: s } = W2(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (Number.isNaN(c) || Number.isNaN(l))
      return g2.create(h.VALUE);
    if (l < 0)
      return g2.create(h.NUM);
    const f2 = Or.besselk(c, l);
    return Number.isNaN(f2) || !Number.isFinite(f2) ? g2.create(h.NUM) : y2.create(f2);
  }
};
var A1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull() || t.isNull())
      return g2.create(h.NA);
    const { isError: r, errorObject: n, variants: s } = W2(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (Number.isNaN(c) || Number.isNaN(l))
      return g2.create(h.VALUE);
    if (l < 0)
      return g2.create(h.NUM);
    const f2 = Or.bessely(c, l);
    return Number.isNaN(f2) || !Number.isFinite(f2) ? g2.create(h.NUM) : y2.create(f2);
  }
};
var E1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`;
    if (!Ua(o))
      return g2.create(h.NUM);
    let u;
    return o.length === 10 && o.substring(0, 1) === "1" ? u = Number.parseInt(o.substring(1), 2) - 512 : u = Number.parseInt(o, 2), y2.create(u);
  }
};
var R1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g2.create(h.NA);
    let r = 0;
    if (t) {
      const { isError: f2, errorObject: m2, variants: d2 } = W2(t);
      if (f2)
        return m2;
      const [_2] = d2;
      if (r = Math.floor(+_2.getValue()), Number.isNaN(r))
        return g2.create(h.VALUE);
      if (r < 0 || r > 10)
        return g2.create(h.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = W2(e);
    if (n)
      return s;
    const [u] = o, c = `${u.getValue()}`;
    if (!Ua(c))
      return g2.create(h.NUM);
    let l;
    if (c.length === 10 && c.substring(0, 1) === "1")
      l = (1099511627264 + Number.parseInt(c.substring(1), 2)).toString(16);
    else if (l = Number.parseInt(c, 2).toString(16), t) {
      if (r < l.length)
        return g2.create(h.NUM);
      l = "0".repeat(r - l.length) + l;
    }
    return U2.create(l.toLocaleUpperCase());
  }
};
var b1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g2.create(h.NA);
    let r = 0;
    if (t) {
      const { isError: f2, errorObject: m2, variants: d2 } = W2(t);
      if (f2)
        return m2;
      const [_2] = d2;
      if (r = Math.floor(+_2.getValue()), Number.isNaN(r))
        return g2.create(h.VALUE);
      if (r < 0 || r > 10)
        return g2.create(h.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = W2(e);
    if (n)
      return s;
    const [u] = o, c = `${u.getValue()}`;
    if (!Ua(c))
      return g2.create(h.NUM);
    let l;
    if (c.length === 10 && c.substring(0, 1) === "1")
      l = (1073741312 + Number.parseInt(c.substring(1), 2)).toString(8);
    else if (l = Number.parseInt(c, 2).toString(8), t) {
      if (r < l.length)
        return g2.create(h.NUM);
      l = "0".repeat(r - l.length) + l;
    }
    return U2.create(l);
  }
};
var y12 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g2.create(h.NA)), o = O(r, n, t, g2.create(h.NA)), u = s.map((c, l, f2) => {
      let m2 = c;
      if (m2.isString() && (m2 = m2.convertToNumberObjectValue()), m2.isError())
        return m2;
      let d2 = o.get(l, f2);
      if (d2.isString() && (d2 = d2.convertToNumberObjectValue()), d2.isError())
        return d2;
      const _2 = +m2.getValue(), C = +d2.getValue();
      if (_2 < 0 || C < 0 || Math.floor(_2) !== _2 || Math.floor(C) !== C || _2 > 281474976710655 || C > 281474976710655)
        return g2.create(h.NUM);
      const E = _2 & C;
      return y2.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
};
var p1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g2.create(h.NA)), o = O(r, n, t, g2.create(h.NA)), u = s.map((c, l, f2) => {
      let m2 = c;
      if (m2.isString() && (m2 = m2.convertToNumberObjectValue()), m2.isError())
        return m2;
      let d2 = o.get(l, f2);
      if (d2.isString() && (d2 = d2.convertToNumberObjectValue()), d2.isError())
        return d2;
      const _2 = +m2.getValue();
      let C = +d2.getValue();
      if (_2 < 0 || Math.floor(_2) !== _2 || _2 > 281474976710655 || Math.abs(C) > 53)
        return g2.create(h.NUM);
      C = Math.trunc(C);
      const E = Number(C >= 0 ? BigInt(_2) << BigInt(C) : BigInt(_2) >> BigInt(-C));
      return E > 281474976710655 ? g2.create(h.NUM) : y2.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
};
var N1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g2.create(h.NA)), o = O(r, n, t, g2.create(h.NA)), u = s.map((c, l, f2) => {
      let m2 = c;
      if (m2.isString() && (m2 = m2.convertToNumberObjectValue()), m2.isError())
        return m2;
      let d2 = o.get(l, f2);
      if (d2.isString() && (d2 = d2.convertToNumberObjectValue()), d2.isError())
        return d2;
      const _2 = +m2.getValue(), C = +d2.getValue();
      if (_2 < 0 || C < 0 || Math.floor(_2) !== _2 || Math.floor(C) !== C || _2 > 281474976710655 || C > 281474976710655)
        return g2.create(h.NUM);
      const E = Number(BigInt(_2) | BigInt(C));
      return y2.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
};
var V1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g2.create(h.NA)), o = O(r, n, t, g2.create(h.NA)), u = s.map((c, l, f2) => {
      let m2 = c;
      if (m2.isString() && (m2 = m2.convertToNumberObjectValue()), m2.isError())
        return m2;
      let d2 = o.get(l, f2);
      if (d2.isString() && (d2 = d2.convertToNumberObjectValue()), d2.isError())
        return d2;
      const _2 = +m2.getValue();
      let C = +d2.getValue();
      if (_2 < 0 || Math.floor(_2) !== _2 || _2 > 281474976710655 || Math.abs(C) > 53)
        return g2.create(h.NUM);
      C = Math.trunc(C);
      const E = Number(C >= 0 ? BigInt(_2) >> BigInt(C) : BigInt(_2) << BigInt(-C));
      return E > 281474976710655 ? g2.create(h.NUM) : y2.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
};
var O1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g2.create(h.NA)), o = O(r, n, t, g2.create(h.NA)), u = s.map((c, l, f2) => {
      let m2 = c;
      if (m2.isString() && (m2 = m2.convertToNumberObjectValue()), m2.isError())
        return m2;
      let d2 = o.get(l, f2);
      if (d2.isString() && (d2 = d2.convertToNumberObjectValue()), d2.isError())
        return d2;
      const _2 = +m2.getValue(), C = +d2.getValue();
      if (_2 < 0 || C < 0 || Math.floor(_2) !== _2 || Math.floor(C) !== C || _2 > 281474976710655 || C > 281474976710655)
        return g2.create(h.NUM);
      const E = _2 ^ C;
      return y2.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
};
x2.prototype.cos = function() {
  const a2 = this.toNumber();
  return new x2(Math.cos(a2));
};
var me2 = class le2 {
  constructor(i) {
    A(this, "_inumber", "");
    A(this, "_realNum", 0);
    A(this, "_iNum", 0);
    A(this, "_suffix", "");
    A(this, "_isError", false);
    if (`${i}`.trim() === "") {
      this._isError = true;
      return;
    }
    this._inumber = i, this._getImReal(), this._getImAginary(), this._getImSuffix();
  }
  static getComplex(i, e, t) {
    const r = new x2(i).toSignificantDigits(15).toNumber(), n = new x2(e).toSignificantDigits(15).toNumber(), s = t === "" ? "i" : t;
    let o;
    if (r === 0 && n === 0)
      o = 0;
    else if (r === 0)
      o = n === 1 ? s : `${n}${s}`;
    else if (n === 0)
      o = r;
    else {
      const u = n > 0 ? "+" : "", c = n === 1 ? s : `${n}${s}`;
      o = `${r}${u}${c}`;
    }
    return o;
  }
  static createByComplexStr(i, e, t) {
    const r = le2.getComplex(i, e, t);
    return new le2(r);
  }
  _getImReal() {
    if (this._inumber === 0 || this._inumber === "0") {
      this._realNum = 0;
      return;
    }
    const i = `${this._inumber}`;
    if (["i", "+i", "1i", "+1i", "-i", "-1i", "j", "+j", "1j", "+1j", "-j", "-1j"].indexOf(i) >= 0) {
      this._realNum = 0;
      return;
    }
    let e = i.indexOf("+"), t = i.indexOf("-");
    e === 0 && (e = i.indexOf("+", 1)), t === 0 && (t = i.indexOf("-", 1));
    const r = i.substring(i.length - 1, i.length), n = r === "i" || r === "j";
    if (e >= 0 || t >= 0) {
      if (!n) {
        this._isError = true;
        return;
      }
      e >= 0 ? Number.isNaN(+i.substring(0, e)) || Number.isNaN(+i.substring(e + 1, i.length - 1)) ? this._isError = true : this._realNum = +i.substring(0, e) : Number.isNaN(+i.substring(0, t)) || Number.isNaN(+i.substring(t + 1, i.length - 1)) ? this._isError = true : this._realNum = +i.substring(0, t);
    } else
      n ? Number.isNaN(+i.substring(0, i.length - 1)) ? this._isError = true : this._realNum = 0 : Number.isNaN(+i) ? this._isError = true : this._realNum = +i;
  }
  _getImAginary() {
    if (this._isError)
      return;
    if (this._inumber === 0 || this._inumber === "0") {
      this._iNum = 0;
      return;
    }
    let i = `${this._inumber}`;
    if (["i", "j"].indexOf(i) >= 0) {
      this._iNum = 1;
      return;
    }
    i = i.replace("+i", "+1i").replace("-i", "-1i").replace("+j", "+1j").replace("-j", "-1j");
    let e = i.indexOf("+"), t = i.indexOf("-");
    e === 0 && (e = i.indexOf("+", 1)), t === 0 && (t = i.indexOf("-", 1));
    const r = i.substring(i.length - 1, i.length), n = r === "i" || r === "j";
    if (e >= 0 || t >= 0) {
      if (!n) {
        this._isError = true;
        return;
      }
      e >= 0 ? Number.isNaN(+i.substring(0, e)) || Number.isNaN(+i.substring(e + 1, i.length - 1)) ? this._isError = true : this._iNum = +i.substring(e + 1, i.length - 1) : Number.isNaN(+i.substring(0, t)) || Number.isNaN(+i.substring(t + 1, i.length - 1)) ? this._isError = true : this._iNum = -+i.substring(t + 1, i.length - 1);
    } else
      n ? Number.isNaN(+i.substring(0, i.length - 1)) ? this._isError = true : this._iNum = +i.substring(0, i.length - 1) : Number.isNaN(+i) ? this._isError = true : this._iNum = 0;
  }
  _getImSuffix() {
    const i = `${this._inumber}`, e = i.substring(i.length - 1);
    this._suffix = e === "i" || e === "j" ? e : "";
  }
  getRealNum() {
    return this._realNum;
  }
  getINum() {
    return this._iNum;
  }
  getSuffix() {
    return this._suffix;
  }
  isError() {
    return this._isError;
  }
  toString() {
    return le2.getComplex(this._realNum, this._iNum, this._suffix);
  }
  isDifferentSuffixes(i) {
    const e = i.getSuffix();
    return this._suffix === "" || e === "" ? false : this._suffix !== e;
  }
  Abs() {
    return x2.sqrt(x2.pow(this._realNum, 2).add(x2.pow(this._iNum, 2))).toSignificantDigits(16).toNumber();
  }
  Argument() {
    const i = x2.sqrt(x2.pow(this._realNum, 2).add(x2.pow(this._iNum, 2)));
    let e = x2.acos(new x2(this._realNum).div(i)).toSignificantDigits(16).toNumber();
    return this._iNum < 0 && (e = -e), e;
  }
  Conjugate() {
    return le2.getComplex(this._realNum, -this._iNum, this._suffix);
  }
  Cos() {
    if (this._iNum) {
      const i = x2.cos(this._realNum).mul(x2.cosh(this._iNum)).toNumber(), e = x2.sin(this._realNum).mul(x2.sinh(this._iNum)).negated().toNumber();
      return le2.getComplex(i, e, this._suffix);
    } else {
      const i = x2.cos(this._realNum).toNumber();
      return le2.getComplex(i, this._iNum, this._suffix);
    }
  }
  Cosh() {
    if (!Number.isFinite(Math.sinh(this._realNum)) || !Number.isFinite(Math.cosh(this._realNum)))
      return this._isError = true, "";
    if (this._iNum) {
      const i = x2.cosh(this._realNum).mul(x2.cos(this._iNum)).toNumber(), e = x2.sinh(this._realNum).mul(x2.sin(this._iNum)).toNumber();
      return le2.getComplex(i, e, this._suffix);
    } else {
      const i = x2.cosh(this._realNum).toNumber();
      return le2.getComplex(i, this._iNum, this._suffix);
    }
  }
  Cot() {
    if (this._iNum) {
      const i = x2.cosh(this._iNum * 2).sub(x2.cos(this._realNum * 2)), e = x2.sin(this._realNum * 2).div(i).toNumber(), t = x2.sinh(this._iNum * 2).div(i).negated().toNumber();
      return le2.getComplex(e, t, this._suffix);
    } else {
      const i = new x2(1).div(x2.tan(this._realNum)).toNumber();
      return le2.getComplex(i, this._iNum, this._suffix);
    }
  }
  Coth() {
    if (!Number.isFinite(Math.sinh(this._realNum)) || !Number.isFinite(Math.cosh(this._realNum)))
      return this._isError = true, "";
    if (this._iNum) {
      const i = x2.cosh(this._realNum * 2).sub(x2.cos(this._iNum * 2)), e = x2.sinh(this._realNum * 2).div(i).toNumber(), t = x2.sin(this._iNum * 2).div(i).negated().toNumber();
      return le2.getComplex(e, t, this._suffix);
    } else {
      const i = new x2(1).div(x2.tanh(this._realNum)).toNumber();
      return le2.getComplex(i, this._iNum, this._suffix);
    }
  }
  Csc() {
    if (this._iNum) {
      const i = x2.cosh(this._iNum * 2).sub(x2.cos(this._realNum * 2)), e = x2.sin(this._realNum).mul(x2.cosh(this._iNum)).mul(2).div(i).toNumber(), t = x2.cos(this._realNum).mul(x2.sinh(this._iNum)).mul(-2).div(i).toNumber();
      return le2.getComplex(e, t, this._suffix);
    } else {
      const i = new x2(1).div(x2.sin(this._realNum)).toNumber();
      return le2.getComplex(i, this._iNum, this._suffix);
    }
  }
  Csch() {
    if (!Number.isFinite(Math.sinh(this._realNum)) || !Number.isFinite(Math.cosh(this._realNum)))
      return le2.getComplex(0, 0, this._suffix);
    if (this._iNum) {
      const i = x2.cosh(this._realNum * 2).sub(x2.cos(this._iNum * 2)), e = x2.sinh(this._realNum).mul(x2.cos(this._iNum)).mul(2).div(i).toNumber(), t = x2.cosh(this._realNum).mul(x2.sin(this._iNum)).mul(-2).div(i).toNumber();
      return le2.getComplex(e, t, this._suffix);
    } else {
      const i = new x2(1).div(x2.sinh(this._realNum)).toNumber();
      return le2.getComplex(i, this._iNum, this._suffix);
    }
  }
  Div(i) {
    const e = new x2(this._realNum), t = new x2(this._iNum), r = new x2(i.getRealNum()), n = new x2(i.getINum()), s = r.mul(r).add(n.mul(n)), o = e.mul(r).add(t.mul(n)).div(s).toNumber(), u = t.mul(r).sub(e.mul(n)).div(s).toNumber(), c = this._suffix === "" ? i.getSuffix() : this._suffix;
    return le2.getComplex(o, u, c);
  }
  Exp() {
    if (!Number.isFinite(Math.exp(this._realNum)))
      return this._isError = true, "";
    const i = x2.exp(this._realNum).mul(x2.cos(this._iNum)).toNumber(), e = x2.exp(this._realNum).mul(x2.sin(this._iNum)).toNumber();
    return le2.getComplex(i, e, this._suffix);
  }
  Ln() {
    const i = x2.sqrt(x2.pow(this._realNum, 2).add(x2.pow(this._iNum, 2))), e = x2.ln(i).toNumber(), t = x2.acos(new x2(this._realNum).div(i)).toNumber();
    return le2.getComplex(e, t, this._suffix);
  }
  Log(i) {
    const e = x2.sqrt(x2.pow(this._realNum, 2).add(x2.pow(this._iNum, 2))), t = x2.ln(e);
    let r = x2.acos(new x2(this._realNum).div(e));
    this._iNum < 0 && (r = r.negated());
    const n = x2.ln(i), s = new x2(0), o = n.mul(n).add(s.mul(s));
    if (o.eq(0))
      return this._isError = true, "";
    const u = t.mul(n).add(r.mul(s)).div(o).toNumber(), c = r.mul(n).sub(t.mul(s)).div(o).toNumber();
    return le2.getComplex(u, c, this._suffix);
  }
  Power(i) {
    if (this._realNum === 0 && this._iNum === 0)
      return i > 0 ? le2.getComplex(this._realNum, this._iNum, this._suffix) : (this._isError = true, "");
    let e = x2.sqrt(x2.pow(this._realNum, 2).add(x2.pow(this._iNum, 2))), t = x2.acos(new x2(this._realNum).div(e));
    this._iNum < 0 && (t = t.negated()), e = x2.pow(e, i), t = t.mul(i);
    const r = x2.cos(t).mul(e).toNumber(), n = x2.sin(t).mul(e).toNumber();
    return !Number.isFinite(r) || !Number.isFinite(n) ? (this._isError = true, "") : le2.getComplex(r, n, this._suffix);
  }
  Product(i) {
    const e = new x2(this._realNum), t = new x2(this._iNum), r = new x2(i.getRealNum()), n = new x2(i.getINum()), s = e.mul(r).sub(t.mul(n)).toNumber(), o = e.mul(n).add(t.mul(r)).toNumber(), u = this._suffix === "" ? i.getSuffix() : this._suffix;
    return le2.getComplex(s, o, u);
  }
  Sec() {
    if (this._iNum) {
      const i = x2.cosh(this._iNum * 2).add(x2.cos(this._realNum * 2)), e = x2.cos(this._realNum).mul(x2.cosh(this._iNum)).mul(2).div(i).toNumber(), t = x2.sin(this._realNum).mul(x2.sinh(this._iNum)).mul(2).div(i).toNumber();
      return le2.getComplex(e, t, this._suffix);
    } else {
      const i = new x2(1).div(x2.cos(this._realNum)).toNumber();
      return le2.getComplex(i, this._iNum, this._suffix);
    }
  }
  Sech() {
    if (!Number.isFinite(Math.sinh(this._realNum * 2)) || !Number.isFinite(Math.cosh(this._realNum * 2)))
      return le2.getComplex(0, 0, this._suffix);
    if (this._iNum) {
      const i = x2.cosh(this._realNum * 2).add(x2.cos(this._iNum * 2)), e = x2.cosh(this._realNum).mul(x2.cos(this._iNum)).mul(2).div(i).toNumber(), t = x2.sinh(this._realNum).mul(x2.sin(this._iNum)).mul(-2).div(i).toNumber();
      return le2.getComplex(e, t, this._suffix);
    } else {
      const i = new x2(1).div(x2.cosh(this._realNum)).toNumber();
      return le2.getComplex(i, this._iNum, this._suffix);
    }
  }
  Sin() {
    if (this._iNum) {
      const i = x2.sin(this._realNum).mul(x2.cosh(this._iNum)).toNumber(), e = x2.cos(this._realNum).mul(x2.sinh(this._iNum)).toNumber();
      return le2.getComplex(i, e, this._suffix);
    } else {
      const i = x2.sin(this._realNum).toNumber();
      return le2.getComplex(i, this._iNum, this._suffix);
    }
  }
  Sinh() {
    if (!Number.isFinite(Math.sinh(this._realNum)) || !Number.isFinite(Math.cosh(this._realNum)))
      return this._isError = true, "";
    if (this._iNum) {
      const i = x2.sinh(this._realNum).mul(x2.cos(this._iNum)).toNumber(), e = x2.cosh(this._realNum).mul(x2.sin(this._iNum)).toNumber();
      return le2.getComplex(i, e, this._suffix);
    } else {
      const i = x2.sinh(this._realNum).toNumber();
      return le2.getComplex(i, this._iNum, this._suffix);
    }
  }
  Sqrt() {
    const i = x2.sqrt(x2.pow(this._realNum, 2).add(x2.pow(this._iNum, 2))), e = x2.sqrt(i);
    let t = x2.acos(new x2(this._realNum).div(i));
    this._iNum < 0 && (t = t.negated());
    const r = e.mul(x2.cos(t.div(2).toNumber())).toNumber(), n = e.mul(x2.sin(t.div(2))).toNumber();
    return le2.getComplex(r, n, this._suffix);
  }
  Sub(i) {
    const e = new x2(this._realNum), t = new x2(this._iNum), r = new x2(i.getRealNum()), n = new x2(i.getINum()), s = e.sub(r).toNumber(), o = t.sub(n).toNumber(), u = this._suffix === "" ? i.getSuffix() : this._suffix;
    return le2.getComplex(s, o, u);
  }
  Sum(i) {
    const e = new x2(this._realNum), t = new x2(this._iNum), r = new x2(i.getRealNum()), n = new x2(i.getINum()), s = e.add(r).toNumber(), o = t.add(n).toNumber(), u = this._suffix === "" ? i.getSuffix() : this._suffix;
    return le2.getComplex(s, o, u);
  }
  Tan() {
    if (this._iNum) {
      const i = x2.cos(this._realNum * 2).add(x2.cosh(this._iNum * 2)), e = x2.sin(this._realNum * 2).div(i).toNumber(), t = x2.sinh(this._iNum * 2).div(i).toNumber();
      return le2.getComplex(e, t, this._suffix);
    } else {
      const i = x2.tan(this._realNum).toNumber();
      return le2.getComplex(i, this._iNum, this._suffix);
    }
  }
  Tanh() {
    if (!Number.isFinite(Math.sinh(this._realNum)) || !Number.isFinite(Math.cosh(this._realNum)))
      return this._isError = true, "";
    if (this._iNum) {
      const i = x2.cosh(this._realNum * 2).add(x2.cos(this._iNum * 2)), e = x2.sinh(this._realNum * 2).div(i).toNumber(), t = x2.sin(this._iNum * 2).div(i).toNumber();
      return le2.getComplex(e, t, this._suffix);
    } else {
      const i = x2.tanh(this._realNum).toNumber();
      return le2.getComplex(i, this._iNum, this._suffix);
    }
  }
};
var S1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : U2.create("i"), { isError: s, errorObject: o, variants: u } = W2(e, t, n);
    if (s)
      return o;
    const [c, l, f2] = u, m2 = +c.getValue(), d2 = +l.getValue(), _2 = `${f2.getValue()}`;
    if (Number.isNaN(m2) || Number.isNaN(d2) || _2 !== "i" && _2 !== "j")
      return g2.create(h.VALUE);
    const C = me2.getComplex(m2, d2, _2);
    return typeof C == "number" ? y2.create(C) : U2.create(C);
  }
};
var M1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
    A(this, "_units", [
      ["a.u. of action", "?", null, "action", false, false, 105457168181818e-48],
      ["a.u. of charge", "e", null, "electric_charge", false, false, 160217653141414e-33],
      ["a.u. of energy", "Eh", null, "energy", false, false, 435974417757576e-32],
      ["a.u. of length", "a?", null, "length", false, false, 529177210818182e-25],
      ["a.u. of mass", "m?", null, "mass", false, false, 910938261616162e-45],
      ["a.u. of time", "?/Eh", null, "time", false, false, 241888432650516e-31],
      ["admiralty knot", "admkn", null, "speed", false, true, 0.514773333],
      ["ampere", "A", null, "electric_current", true, false, 1],
      ["ampere per meter", "A/m", null, "magnetic_field_intensity", true, false, 1],
      ["ångström", "Å", ["ang"], "length", false, true, 1e-10],
      ["are", "ar", null, "area", false, true, 100],
      ["astronomical unit", "ua", null, "length", false, false, 149597870691667e-25],
      ["bar", "bar", null, "pressure", false, false, 1e5],
      ["barn", "b", null, "area", false, false, 1e-28],
      ["becquerel", "Bq", null, "radioactivity", true, false, 1],
      ["bit", "bit", ["b"], "information", false, true, 1],
      ["btu", "BTU", ["btu"], "energy", false, true, 1055.05585262],
      ["byte", "byte", null, "information", false, true, 8],
      ["candela", "cd", null, "luminous_intensity", true, false, 1],
      ["candela per square metre", "cd/m?", null, "luminance", true, false, 1],
      ["centigrade", "C", ["cel"], "temperature", true, false, 1],
      ["cubic ångström", "ang3", ["ang^3"], "volume", false, true, 1e-30],
      ["cubic foot", "ft3", ["ft^3"], "volume", false, true, 0.028316846592],
      ["cubic inch", "in3", ["in^3"], "volume", false, true, 16387064e-12],
      ["cubic light-year", "ly3", ["ly^3"], "volume", false, true, 846786664623715e-61],
      ["cubic metre", "m3", ["m^3"], "volume", true, true, 1],
      ["cubic mile", "mi3", ["mi^3"], "volume", false, true, 416818182544058e-5],
      ["cubic nautical mile", "Nmi3", ["Nmi^3"], "volume", false, true, 6352182208],
      ["cubic Pica", "Pica3", ["Picapt3", "Pica^3", "Picapt^3"], "volume", false, true, 758660370370369e-22],
      ["cubic yard", "yd3", ["yd^3"], "volume", false, true, 0.764554857984],
      ["cup", "cup", null, "volume", false, true, 2365882365e-13],
      ["dalton", "Da", ["u"], "mass", false, false, 166053886282828e-41],
      ["day", "d", ["day"], "time", false, true, 86400],
      ["degree", "°", null, "angle", false, false, 0.0174532925199433],
      ["dyne", "dyn", ["dy"], "force", false, true, 1e-5],
      ["electronvolt", "eV", ["ev"], "energy", false, true, 1.60217656514141],
      ["ell", "ell", null, "length", false, true, 1.143],
      ["erg", "erg", ["e"], "energy", false, true, 1e-7],
      ["fahrenheit", "F", ["fah"], "temperature", true, false, 1],
      ["fluid ounce", "oz", null, "volume", false, true, 295735295625e-16],
      ["foot", "ft", null, "length", false, true, 0.3048],
      ["foot-pound", "flb", null, "energy", false, true, 1.3558179483314],
      ["gal", "Gal", null, "acceleration", false, false, 0.01],
      ["gallon", "gal", null, "volume", false, true, 0.003785411784],
      ["gauss", "G", ["ga"], "magnetic_flux_density", false, true, 1],
      ["grain", "grain", null, "mass", false, true, 647989e-10],
      ["gram", "g", null, "mass", false, true, 1e-3],
      ["gray", "Gy", null, "absorbed_dose", true, false, 1],
      ["gross registered ton", "GRT", ["regton"], "volume", false, true, 2.8316846592],
      ["hectare", "ha", null, "area", false, true, 1e4],
      ["henry", "H", null, "inductance", true, false, 1],
      ["hertz", "Hz", null, "frequency", true, false, 1],
      ["horsepower", "HP", ["h"], "power", false, true, 745.69987158227],
      ["horsepower-hour", "HPh", ["hh", "hph"], "energy", false, true, 2684519538e-3],
      ["hour", "h", ["hr"], "time", false, true, 3600],
      ["imperial gallon (U.K.)", "uk_gal", null, "volume", false, true, 454609e-8],
      ["imperial hundredweight", "lcwt", ["uk_cwt", "hweight"], "mass", false, true, 50.802345],
      ["imperial quart (U.K)", "uk_qt", null, "volume", false, true, 0.0011365225],
      ["imperial ton", "brton", ["uk_ton", "LTON"], "mass", false, true, 1016.046909],
      ["inch", "in", null, "length", false, true, 0.0254],
      ["international acre", "uk_acre", null, "area", false, true, 4046.8564224],
      ["IT calorie", "cal", null, "energy", false, true, 4.1868],
      ["joule", "J", null, "energy", true, true, 1],
      ["katal", "kat", null, "catalytic_activity", true, false, 1],
      ["kelvin", "K", ["kel"], "temperature", true, true, 1],
      ["kilogram", "kg", null, "mass", true, true, 1],
      ["knot", "kn", null, "speed", false, true, 0.514444444444444],
      ["light-year", "ly", null, "length", false, true, 9460730472580800],
      ["litre", "L", ["l", "lt"], "volume", false, true, 1e-3],
      ["lumen", "lm", null, "luminous_flux", true, false, 1],
      ["lux", "lx", null, "illuminance", true, false, 1],
      ["maxwell", "Mx", null, "magnetic_flux", false, false, 1e-18],
      ["measurement ton", "MTON", null, "volume", false, true, 1.13267386368],
      ["meter per hour", "m/h", ["m/hr"], "speed", false, true, 27777777777778e-17],
      ["meter per second", "m/s", ["m/sec"], "speed", true, true, 1],
      ["meter per second squared", "m?s??", null, "acceleration", true, false, 1],
      ["parsec", "pc", ["parsec"], "length", false, true, 30856775814671900],
      ["meter squared per second", "m?/s", null, "kinematic_viscosity", true, false, 1],
      ["metre", "m", null, "length", true, true, 1],
      ["miles per hour", "mph", null, "speed", false, true, 0.44704],
      ["millimetre of mercury", "mmHg", null, "pressure", false, false, 133.322],
      ["minute", "?", null, "angle", false, false, 290888208665722e-18],
      ["minute", "min", ["mn"], "time", false, true, 60],
      ["modern teaspoon", "tspm", null, "volume", false, true, 5e-6],
      ["mole", "mol", null, "amount_of_substance", true, false, 1],
      ["morgen", "Morgen", null, "area", false, true, 2500],
      ["n.u. of action", "?", null, "action", false, false, 105457168181818e-48],
      ["n.u. of mass", "m?", null, "mass", false, false, 910938261616162e-45],
      ["n.u. of speed", "c?", null, "speed", false, false, 299792458],
      ["n.u. of time", "?/(me?c??)", null, "time", false, false, 128808866778687e-35],
      ["nautical mile", "M", ["Nmi"], "length", false, true, 1852],
      ["newton", "N", null, "force", true, true, 1],
      ["œrsted", "Oe ", null, "magnetic_field_intensity", false, false, 79.5774715459477],
      ["ohm", "Ω", null, "electric_resistance", true, false, 1],
      ["ounce mass", "ozm", null, "mass", false, true, 0.028349523125],
      ["pascal", "Pa", null, "pressure", true, false, 1],
      ["pascal second", "Pa?s", null, "dynamic_viscosity", true, false, 1],
      ["pferdestärke", "PS", null, "power", false, true, 735.49875],
      ["phot", "ph", null, "illuminance", false, false, 1e-4],
      ["pica (1/6 inch)", "pica", null, "length", false, true, 35277777777778e-17],
      ["pica (1/72 inch)", "Pica", ["Picapt"], "length", false, true, 0.00423333333333333],
      ["poise", "P", null, "dynamic_viscosity", false, false, 0.1],
      ["pond", "pond", null, "force", false, true, 980665e-8],
      ["pound force", "lbf", null, "force", false, true, 4.4482216152605],
      ["pound mass", "lbm", null, "mass", false, true, 0.45359237],
      ["quart", "qt", null, "volume", false, true, 946352946e-12],
      ["radian", "rad", null, "angle", true, false, 1],
      ["rankine", "Rank", null, "temperature", false, true, 1],
      ["reaumur", "Reau", null, "temperature", false, true, 1],
      ["second", "?", null, "angle", false, false, 484813681109536e-20],
      ["second", "s", ["sec"], "time", true, true, 1],
      ["short hundredweight", "cwt", ["shweight"], "mass", false, true, 45.359237],
      ["siemens", "S", null, "electrical_conductance", true, false, 1],
      ["sievert", "Sv", null, "equivalent_dose", true, false, 1],
      ["slug", "sg", null, "mass", false, true, 14.59390294],
      ["square ångström", "ang2", ["ang^2"], "area", false, true, 1e-20],
      ["square foot", "ft2", ["ft^2"], "area", false, true, 0.09290304],
      ["square inch", "in2", ["in^2"], "area", false, true, 64516e-8],
      ["square light-year", "ly2", ["ly^2"], "area", false, true, 895054210748189e17],
      ["square meter", "m?", null, "area", true, true, 1],
      ["square mile", "mi2", ["mi^2"], "area", false, true, 2589988110336e-6],
      ["square nautical mile", "Nmi2", ["Nmi^2"], "area", false, true, 3429904],
      ["square Pica", "Pica2", ["Picapt2", "Pica^2", "Picapt^2"], "area", false, true, 1792111111111e-17],
      ["square yard", "yd2", ["yd^2"], "area", false, true, 0.83612736],
      ["statute mile", "mi", null, "length", false, true, 1609.344],
      ["steradian", "sr", null, "solid_angle", true, false, 1],
      ["stilb", "sb", null, "luminance", false, false, 1e-4],
      ["stokes", "St", null, "kinematic_viscosity", false, false, 1e-4],
      ["stone", "stone", null, "mass", false, true, 6.35029318],
      ["tablespoon", "tbs", null, "volume", false, true, 147868e-10],
      ["teaspoon", "tsp", null, "volume", false, true, 492892e-11],
      ["tesla", "T", null, "magnetic_flux_density", true, true, 1],
      ["thermodynamic calorie", "c", null, "energy", false, true, 4.184],
      ["ton", "ton", null, "mass", false, true, 907.18474],
      ["tonne", "t", null, "mass", false, false, 1e3],
      ["U.K. pint", "uk_pt", null, "volume", false, true, 56826125e-11],
      ["U.S. bushel", "bushel", null, "volume", false, true, 0.03523907],
      ["U.S. oil barrel", "barrel", null, "volume", false, true, 0.158987295],
      ["U.S. pint", "pt", ["us_pt"], "volume", false, true, 473176473e-12],
      ["U.S. survey mile", "survey_mi", null, "length", false, true, 1609.347219],
      ["U.S. survey/statute acre", "us_acre", null, "area", false, true, 4046.87261],
      ["volt", "V", null, "voltage", true, false, 1],
      ["watt", "W", null, "power", true, true, 1],
      ["watt-hour", "Wh", ["wh"], "energy", false, true, 3600],
      ["weber", "Wb", null, "magnetic_flux", true, false, 1],
      ["yard", "yd", null, "length", false, true, 0.9144],
      ["year", "yr", null, "time", false, true, 31557600]
    ]);
    A(this, "_binaryPrefixes", {
      Yi: ["yobi", 80, 12089258196146292e8, "Yi", "yotta"],
      Zi: ["zebi", 70, 11805916207174113e5, "Zi", "zetta"],
      Ei: ["exbi", 60, 1152921504606847e3, "Ei", "exa"],
      Pi: ["pebi", 50, 1125899906842624, "Pi", "peta"],
      Ti: ["tebi", 40, 1099511627776, "Ti", "tera"],
      Gi: ["gibi", 30, 1073741824, "Gi", "giga"],
      Mi: ["mebi", 20, 1048576, "Mi", "mega"],
      ki: ["kibi", 10, 1024, "ki", "kilo"]
    });
    A(this, "_unitPrefixes", {
      Y: ["yotta", 1e24, "Y"],
      Z: ["zetta", 1e21, "Z"],
      E: ["exa", 1e18, "E"],
      P: ["peta", 1e15, "P"],
      T: ["tera", 1e12, "T"],
      G: ["giga", 1e9, "G"],
      M: ["mega", 1e6, "M"],
      k: ["kilo", 1e3, "k"],
      h: ["hecto", 100, "h"],
      e: ["dekao", 10, "e"],
      d: ["deci", 0.1, "d"],
      c: ["centi", 0.01, "c"],
      m: ["milli", 1e-3, "m"],
      u: ["micro", 1e-6, "u"],
      n: ["nano", 1e-9, "n"],
      p: ["pico", 1e-12, "p"],
      f: ["femto", 1e-15, "f"],
      a: ["atto", 1e-18, "a"],
      z: ["zepto", 1e-21, "z"],
      y: ["yocto", 1e-24, "y"]
    });
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = W2(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f2 = +u.getValue(), m2 = `${c.getValue()}`, d2 = `${l.getValue()}`;
    if (Number.isNaN(f2))
      return g2.create(h.VALUE);
    let _2, C = 1, E, R = 1;
    const { _from: b, _to: p2 } = this._lookupFromAndToUnits(m2, d2);
    if (_2 = b, E = p2, _2 === null) {
      const { _from: S2, _fromMultiplier: M2 } = this._lookupFromPrefix(m2);
      _2 = S2, C = M2;
    }
    if (E === null) {
      const { _to: S2, _toMultiplier: M2 } = this._lookupToPrefix(d2);
      E = S2, R = M2;
    }
    if (_2 === null || E === null || _2[3] !== E[3])
      return g2.create(h.NA);
    let V;
    return _2[3] === "temperature" ? (V = this._getTemperatureConversion(f2, _2[1], E[1]), V = +V.toFixed(2)) : V = f2 * _2[6] * C / (E[6] * R), y2.create(V);
  }
  _lookupFromAndToUnits(e, t) {
    let r = null, n = null, s;
    for (let o = 0; o < this._units.length; o++)
      s = this._units[o][2] === null ? [] : this._units[o][2], (this._units[o][1] === e || s.indexOf(e) >= 0) && (r = this._units[o]), (this._units[o][1] === t || s.indexOf(t) >= 0) && (n = this._units[o]);
    return {
      _from: r,
      _to: n
    };
  }
  _lookupFromPrefix(e) {
    let t = null, r = 1, n = e, s;
    const o = this._binaryPrefixes[e.substring(0, 2)];
    let u = this._unitPrefixes[e.substring(0, 1)];
    e.substring(0, 2) === "da" && (u = ["dekao", 10, "da"]), o ? (r = o[2], n = e.substring(2)) : u && (r = u[1], n = e.substring(u[2].length));
    for (let c = 0; c < this._units.length; c++)
      s = this._units[c][2] === null ? [] : this._units[c][2], (this._units[c][1] === n || s.indexOf(n) >= 0) && (t = this._units[c]);
    return {
      _from: t,
      _fromMultiplier: r
    };
  }
  _lookupToPrefix(e) {
    let t = null, r = 1, n = e, s;
    const o = this._binaryPrefixes[e.substring(0, 2)];
    let u = this._unitPrefixes[e.substring(0, 1)];
    e.substring(0, 2) === "da" && (u = ["dekao", 10, "da"]), o ? (r = o[2], n = e.substring(2)) : u && (r = u[1], n = e.substring(u[2].length));
    for (let c = 0; c < this._units.length; c++)
      s = this._units[c][2] === null ? [] : this._units[c][2], (this._units[c][1] === n || s.indexOf(n) >= 0) && (t = this._units[c]);
    return {
      _to: t,
      _toMultiplier: r
    };
  }
  _getTemperatureConversion(e, t, r) {
    switch (t) {
      case "C":
        return this._centigradeConversion(e, r);
      case "F":
        return this._fahrenheitConversion(e, r);
      case "K":
        return this._kelvinConversion(e, r);
      case "Rank":
        return this._rankineConversion(e, r);
      case "Reau":
        return this._reaumurConversion(e, r);
      default:
        return e;
    }
  }
  _centigradeConversion(e, t) {
    switch (t) {
      case "F":
        return e * 9 / 5 + 32;
      case "K":
        return e + 273.15;
      case "Rank":
        return (e + 273.15) * 9 / 5;
      case "Reau":
        return e * 4 / 5;
      default:
        return e;
    }
  }
  _fahrenheitConversion(e, t) {
    switch (t) {
      case "C":
        return (e - 32) * 5 / 9;
      case "K":
        return (e - 32) * 5 / 9 + 273.15;
      case "Rank":
        return e + 459.67;
      case "Reau":
        return (e - 32) * 4 / 9;
      default:
        return e;
    }
  }
  _kelvinConversion(e, t) {
    switch (t) {
      case "C":
        return e - 273.15;
      case "F":
        return (e - 273.15) * 9 / 5 + 32;
      case "Rank":
        return e * 9 / 5;
      case "Reau":
        return (e - 273.15) * 4 / 5;
      default:
        return e;
    }
  }
  _rankineConversion(e, t) {
    switch (t) {
      case "C":
        return (e - 491.67) * 5 / 9;
      case "F":
        return e - 459.67;
      case "K":
        return e * 5 / 9;
      case "Reau":
        return (e - 491.67) * 4 / 9;
      default:
        return e;
    }
  }
  _reaumurConversion(e, t) {
    switch (t) {
      case "C":
        return e * 5 / 4;
      case "F":
        return e * 9 / 4 + 32;
      case "K":
        return e * 5 / 4 + 273.15;
      case "Rank":
        return e * 9 / 4 + 491.67;
      default:
        return e;
    }
  }
};
var D1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g2.create(h.NA);
    let r = 0;
    if (t) {
      const { isError: f2, errorObject: m2, variants: d2 } = W2(t);
      if (f2)
        return m2;
      const [_2] = d2;
      if (r = Math.floor(+_2.getValue()), Number.isNaN(r))
        return g2.create(h.VALUE);
      if (r < 0 || r > 10)
        return g2.create(h.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = W2(e);
    if (n)
      return s;
    const [u] = o, c = Math.trunc(+u.getValue());
    if (Number.isNaN(c))
      return g2.create(h.VALUE);
    if (!/^-?[0-9]{1,3}$/.test(`${c}`) || c < -512 || c > 511)
      return g2.create(h.NUM);
    let l;
    if (c < 0) {
      const f2 = (512 + c).toString(2);
      l = `1${"0".repeat(9 - f2.length)}${f2}`;
    } else if (l = Number.parseInt(`${c}`, 10).toString(2), t) {
      if (r < l.length)
        return g2.create(h.NUM);
      l = "0".repeat(r - l.length) + l;
    }
    return U2.create(l);
  }
};
var w12 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g2.create(h.NA);
    let r = 0;
    if (t) {
      const { isError: f2, errorObject: m2, variants: d2 } = W2(t);
      if (f2)
        return m2;
      const [_2] = d2;
      if (r = Math.floor(+_2.getValue()), Number.isNaN(r))
        return g2.create(h.VALUE);
      if (r < 0 || r > 10)
        return g2.create(h.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = W2(e);
    if (n)
      return s;
    const [u] = o, c = Math.trunc(+u.getValue());
    if (Number.isNaN(c))
      return g2.create(h.VALUE);
    if (!/^-?[0-9]{1,12}$/.test(`${c}`) || c < -549755813888 || c > 549755813887)
      return g2.create(h.NUM);
    let l;
    if (c < 0)
      l = (1099511627776 + c).toString(16);
    else if (l = Number.parseInt(`${c}`, 10).toString(16), t) {
      if (r < l.length)
        return g2.create(h.NUM);
      l = "0".repeat(r - l.length) + l;
    }
    return U2.create(l.toLocaleUpperCase());
  }
};
var L1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g2.create(h.NA);
    let r = 0;
    if (t) {
      const { isError: f2, errorObject: m2, variants: d2 } = W2(t);
      if (f2)
        return m2;
      const [_2] = d2;
      if (r = Math.floor(+_2.getValue()), Number.isNaN(r))
        return g2.create(h.VALUE);
      if (r < 0 || r > 10)
        return g2.create(h.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = W2(e);
    if (n)
      return s;
    const [u] = o, c = Math.trunc(+u.getValue());
    if (Number.isNaN(c))
      return g2.create(h.VALUE);
    if (!/^-?[0-9]{1,9}$/.test(`${c}`) || c < -536870912 || c > 536870911)
      return g2.create(h.NUM);
    let l;
    if (c < 0)
      l = (1073741824 + c).toString(8);
    else if (l = Number.parseInt(`${c}`, 10).toString(8), t) {
      if (r < l.length)
        return g2.create(h.NUM);
      l = "0".repeat(r - l.length) + l;
    }
    return U2.create(l);
  }
};
var P1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y2.create(0), { isError: n, errorObject: s, variants: o } = W2(e, r);
    if (n)
      return s;
    const [u, c] = o, l = +u.getValue(), f2 = +c.getValue();
    if (Number.isNaN(l) || Number.isNaN(f2))
      return g2.create(h.VALUE);
    const m2 = l === f2 ? 1 : 0;
    return y2.create(m2);
  }
};
var x1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r;
    if (t) {
      const { isError: n, errorObject: s, variants: o } = W2(e, t);
      if (n)
        return s;
      const [u, c] = o, l = +u.getValue(), f2 = +c.getValue();
      if (Number.isNaN(l) || Number.isNaN(f2))
        return g2.create(h.VALUE);
      r = nr(f2) - nr(l);
    } else {
      const { isError: n, errorObject: s, variants: o } = W2(e);
      if (n)
        return s;
      const [u] = o, c = +u.getValue();
      if (Number.isNaN(c))
        return g2.create(h.VALUE);
      r = nr(c);
    }
    return y2.create(r);
  }
};
var j1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue();
    if (Number.isNaN(o))
      return g2.create(h.VALUE);
    const u = nr(o);
    return y2.create(u);
  }
};
var U1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue();
    if (Number.isNaN(o))
      return g2.create(h.VALUE);
    const u = Ia(o);
    return y2.create(u);
  }
};
var v1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue();
    if (Number.isNaN(o))
      return g2.create(h.VALUE);
    const u = Ia(o);
    return y2.create(u);
  }
};
var Q = ((a2) => (a2.BESSELI = "BESSELI", a2.BESSELJ = "BESSELJ", a2.BESSELK = "BESSELK", a2.BESSELY = "BESSELY", a2.BIN2DEC = "BIN2DEC", a2.BIN2HEX = "BIN2HEX", a2.BIN2OCT = "BIN2OCT", a2.BITAND = "BITAND", a2.BITLSHIFT = "BITLSHIFT", a2.BITOR = "BITOR", a2.BITRSHIFT = "BITRSHIFT", a2.BITXOR = "BITXOR", a2.COMPLEX = "COMPLEX", a2.CONVERT = "CONVERT", a2.DEC2BIN = "DEC2BIN", a2.DEC2HEX = "DEC2HEX", a2.DEC2OCT = "DEC2OCT", a2.DELTA = "DELTA", a2.ERF = "ERF", a2.ERF_PRECISE = "ERF.PRECISE", a2.ERFC = "ERFC", a2.ERFC_PRECISE = "ERFC.PRECISE", a2.GESTEP = "GESTEP", a2.HEX2BIN = "HEX2BIN", a2.HEX2DEC = "HEX2DEC", a2.HEX2OCT = "HEX2OCT", a2.IMABS = "IMABS", a2.IMAGINARY = "IMAGINARY", a2.IMARGUMENT = "IMARGUMENT", a2.IMCONJUGATE = "IMCONJUGATE", a2.IMCOS = "IMCOS", a2.IMCOSH = "IMCOSH", a2.IMCOT = "IMCOT", a2.IMCOTH = "IMCOTH", a2.IMCSC = "IMCSC", a2.IMCSCH = "IMCSCH", a2.IMDIV = "IMDIV", a2.IMEXP = "IMEXP", a2.IMLN = "IMLN", a2.IMLOG = "IMLOG", a2.IMLOG10 = "IMLOG10", a2.IMLOG2 = "IMLOG2", a2.IMPOWER = "IMPOWER", a2.IMPRODUCT = "IMPRODUCT", a2.IMREAL = "IMREAL", a2.IMSEC = "IMSEC", a2.IMSECH = "IMSECH", a2.IMSIN = "IMSIN", a2.IMSINH = "IMSINH", a2.IMSQRT = "IMSQRT", a2.IMSUB = "IMSUB", a2.IMSUM = "IMSUM", a2.IMTAN = "IMTAN", a2.IMTANH = "IMTANH", a2.OCT2BIN = "OCT2BIN", a2.OCT2DEC = "OCT2DEC", a2.OCT2HEX = "OCT2HEX", a2))(Q || {});
var T1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g2.create(h.NA);
    const r = t != null ? t : y2.create(0), { isError: n, errorObject: s, variants: o } = W2(e, r);
    if (n)
      return s;
    const [u, c] = o, l = +u.getValue(), f2 = +c.getValue();
    if (Number.isNaN(l) || Number.isNaN(f2))
      return g2.create(h.VALUE);
    const m2 = l >= f2 ? 1 : 0;
    return y2.create(m2);
  }
};
var I1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g2.create(h.NA);
    let r = 0;
    if (t) {
      const { isError: d2, errorObject: _2, variants: C } = W2(t);
      if (d2)
        return _2;
      const [E] = C;
      if (r = Math.floor(+E.getValue()), Number.isNaN(r))
        return g2.create(h.VALUE);
      if (r < 0 || r > 10)
        return g2.create(h.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = W2(e);
    if (n)
      return s;
    const [u] = o, c = `${u.getValue()}`;
    if (!Ta(c))
      return g2.create(h.NUM);
    const l = c.length === 10 && c.substring(0, 1).toLocaleUpperCase() === "F", f2 = l ? Number.parseInt(c, 16) - 1099511627776 : Number.parseInt(c, 16);
    if (f2 < -512 || f2 > 511)
      return g2.create(h.NUM);
    let m2;
    if (l) {
      const d2 = (512 + f2).toString(2);
      m2 = `1${"0".repeat(9 - d2.length)}${d2}`;
    } else if (m2 = f2.toString(2), t) {
      if (r < m2.length)
        return g2.create(h.NUM);
      m2 = "0".repeat(r - m2.length) + m2;
    }
    return U2.create(m2);
  }
};
var B1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`;
    if (!Ta(o))
      return g2.create(h.NUM);
    let u = Number.parseInt(o, 16);
    return u >= 549755813888 && (u -= 1099511627776), y2.create(u);
  }
};
var F1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g2.create(h.NA);
    let r = 0;
    if (t) {
      const { isError: m2, errorObject: d2, variants: _2 } = W2(t);
      if (m2)
        return d2;
      const [C] = _2;
      if (r = Math.floor(+C.getValue()), Number.isNaN(r))
        return g2.create(h.VALUE);
      if (r < 0 || r > 10)
        return g2.create(h.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = W2(e);
    if (n)
      return s;
    const [u] = o, c = `${u.getValue()}`;
    if (!Ta(c))
      return g2.create(h.NUM);
    const l = Number.parseInt(c, 16);
    if (l > 536870911 && l < 1098974756864)
      return g2.create(h.NUM);
    let f2;
    if (l >= 1098974756864)
      f2 = (l - 1098437885952).toString(8);
    else if (f2 = l.toString(8), t) {
      if (r < f2.length)
        return g2.create(h.NUM);
      f2 = "0".repeat(r - f2.length) + f2;
    }
    return U2.create(f2);
  }
};
var k1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me2(o);
    if (u.isError())
      return g2.create(h.NUM);
    const c = u.Abs();
    return y2.create(c);
  }
};
var $1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me2(o);
    if (u.isError())
      return g2.create(h.NUM);
    const c = u.getINum();
    return y2.create(c);
  }
};
var Y1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me2(o);
    if (u.isError())
      return g2.create(h.NUM);
    if (u.getRealNum() === 0 && u.getINum() === 0)
      return g2.create(h.DIV_BY_ZERO);
    const c = u.Argument();
    return y2.create(c);
  }
};
var H1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me2(o);
    if (u.isError())
      return g2.create(h.NUM);
    const c = u.Conjugate();
    return typeof c == "number" || s1(c) ? y2.create(+c) : U2.create(c);
  }
};
var G1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me2(o);
    if (u.isError())
      return g2.create(h.NUM);
    const c = u.Cos();
    return typeof c == "number" || s1(c) ? y2.create(+c) : U2.create(c);
  }
};
var W1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me2(o);
    if (u.isError())
      return g2.create(h.NUM);
    const c = u.Cosh();
    return u.isError() ? g2.create(h.NUM) : typeof c == "number" || s1(c) ? y2.create(+c) : U2.create(c);
  }
};
var Q1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me2(o);
    if (u.isError() || u.getRealNum() === 0 && u.getINum() === 0)
      return g2.create(h.NUM);
    const c = u.Cot();
    return typeof c == "number" || s1(c) ? y2.create(+c) : U2.create(c);
  }
};
var q1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me2(o);
    if (u.isError() || u.getRealNum() === 0 && u.getINum() === 0)
      return g2.create(h.NUM);
    const c = u.Coth();
    return u.isError() ? g2.create(h.NUM) : typeof c == "number" || s1(c) ? y2.create(+c) : U2.create(c);
  }
};
var X1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me2(o);
    if (u.isError() || u.getRealNum() === 0 && u.getINum() === 0)
      return g2.create(h.NUM);
    const c = u.Csc();
    return typeof c == "number" || s1(c) ? y2.create(+c) : U2.create(c);
  }
};
var K1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me2(o);
    if (u.isError() || u.getRealNum() === 0 && u.getINum() === 0)
      return g2.create(h.NUM);
    const c = u.Csch();
    return typeof c == "number" || s1(c) ? y2.create(+c) : U2.create(c);
  }
};
var Z1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull() || t.isNull())
      return g2.create(h.NA);
    const { isError: r, errorObject: n, variants: s } = W2(e, t);
    if (r)
      return n;
    const [o, u] = s, c = `${o.getValue()}`, l = `${u.getValue()}`, f2 = new me2(c), m2 = new me2(l);
    if (f2.isError() || m2.isError() || f2.isDifferentSuffixes(m2) || m2.getRealNum() === 0 && m2.getINum() === 0)
      return g2.create(h.NUM);
    const d2 = f2.Div(m2);
    return typeof d2 == "number" || s1(d2) ? y2.create(+d2) : U2.create(d2);
  }
};
var z1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me2(o);
    if (u.isError())
      return g2.create(h.NUM);
    const c = u.Exp();
    return u.isError() ? g2.create(h.NUM) : typeof c == "number" || s1(c) ? y2.create(+c) : U2.create(c);
  }
};
var J1 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me2(o);
    if (u.isError() || u.getRealNum() === 0 && u.getINum() === 0)
      return g2.create(h.NUM);
    const c = u.Ln();
    return typeof c == "number" || s1(c) ? y2.create(+c) : U2.create(c);
  }
};
var ed = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = W2(e);
    if (r)
      return n;
    const [o] = s;
    let u = t != null ? t : y2.create(10);
    if (u.isArray()) {
      const R = u.getRowCount(), b = u.getColumnCount();
      if (R > 1 || b > 1)
        return g2.create(h.VALUE);
      u = u.get(0, 0);
    }
    const { isError: c, errorObject: l, variants: f2 } = I2(u);
    if (c)
      return l;
    const [m2] = f2, d2 = `${o.getValue()}`, _2 = +m2.getValue(), C = new me2(d2);
    if (C.isError() || C.getRealNum() === 0 && C.getINum() === 0 || _2 <= 0)
      return g2.create(h.NUM);
    const E = C.Log(_2);
    return C.isError() ? g2.create(h.NUM) : typeof E == "number" || s1(E) ? y2.create(+E) : U2.create(E);
  }
};
var td = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me2(o);
    if (u.isError() || u.getRealNum() === 0 && u.getINum() === 0)
      return g2.create(h.NUM);
    const c = u.Log(2);
    return typeof c == "number" || s1(c) ? y2.create(+c) : U2.create(c);
  }
};
var rd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me2(o);
    if (u.isError() || u.getRealNum() === 0 && u.getINum() === 0)
      return g2.create(h.NUM);
    const c = u.Log(10);
    return typeof c == "number" || s1(c) ? y2.create(+c) : U2.create(c);
  }
};
var nd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull() || t.isNull())
      return g2.create(h.NA);
    const { isError: r, errorObject: n, variants: s } = W2(e, t);
    if (r)
      return n;
    const [o, u] = s, c = `${o.getValue()}`, l = new me2(c);
    if (l.isError())
      return g2.create(h.NUM);
    const f2 = +u.getValue();
    if (Number.isNaN(f2))
      return g2.create(h.VALUE);
    const m2 = l.Power(f2);
    return l.isError() ? g2.create(h.NUM) : typeof m2 == "number" || s1(m2) ? y2.create(+m2) : U2.create(m2);
  }
};
var sd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = "";
    for (let r = 0; r < e.length; r++) {
      if (t instanceof g2)
        return t;
      const n = e[r];
      if (n.isArray()) {
        let s = false, o;
        if (n.iterator((u) => {
          if (t = this._handleSingleObject(u, t), t instanceof g2)
            return s = true, o = t, false;
        }), s)
          return o;
      } else
        t = this._handleSingleObject(n, t);
    }
    return t instanceof g2 ? t : typeof t == "number" || s1(t) ? y2.create(+t) : U2.create(t);
  }
  _handleSingleObject(e, t) {
    let r = t;
    if (e.isError())
      return e;
    if (e.isBoolean())
      return g2.create(h.VALUE);
    const n = `${e.getValue()}`;
    if (typeof t != "number" && !t) {
      const s = new me2(n);
      if (s.isError())
        return g2.create(h.NUM);
      r = s.toString();
    } else {
      const s = new me2(t), o = new me2(n);
      if (s.isError() || o.isError())
        return g2.create(h.NUM);
      if (s.isDifferentSuffixes(o))
        return g2.create(h.VALUE);
      r = s.Product(o);
    }
    return r;
  }
};
var ad = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me2(o);
    if (u.isError())
      return g2.create(h.NUM);
    const c = u.getRealNum();
    return y2.create(c);
  }
};
var id = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me2(o);
    if (u.isError())
      return g2.create(h.NUM);
    const c = u.Sec();
    return typeof c == "number" || s1(c) ? y2.create(+c) : U2.create(c);
  }
};
var od = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me2(o);
    if (u.isError())
      return g2.create(h.NUM);
    const c = u.Sech();
    return typeof c == "number" || s1(c) ? y2.create(+c) : U2.create(c);
  }
};
var ud = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me2(o);
    if (u.isError())
      return g2.create(h.NUM);
    const c = u.Sin();
    return typeof c == "number" || s1(c) ? y2.create(+c) : U2.create(c);
  }
};
var cd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me2(o);
    if (u.isError())
      return g2.create(h.NUM);
    const c = u.Sinh();
    return u.isError() ? g2.create(h.NUM) : typeof c == "number" || s1(c) ? y2.create(+c) : U2.create(c);
  }
};
var ld = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me2(o);
    if (u.isError())
      return g2.create(h.NUM);
    if (u.getRealNum() === 0 && u.getINum() === 0)
      return y2.create(0);
    const c = u.Sqrt();
    return typeof c == "number" || s1(c) ? y2.create(+c) : U2.create(c);
  }
};
var fd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull() || t.isNull())
      return g2.create(h.NA);
    const { isError: r, errorObject: n, variants: s } = W2(e, t);
    if (r)
      return n;
    const [o, u] = s, c = `${o.getValue()}`, l = `${u.getValue()}`, f2 = new me2(c), m2 = new me2(l);
    if (f2.isError() || m2.isError() || f2.isDifferentSuffixes(m2))
      return g2.create(h.NUM);
    const d2 = f2.Sub(m2);
    return typeof d2 == "number" || s1(d2) ? y2.create(+d2) : U2.create(d2);
  }
};
var md = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = "";
    for (let r = 0; r < e.length; r++) {
      if (t instanceof g2)
        return t;
      const n = e[r];
      if (n.isArray()) {
        let s = false, o;
        if (n.iterator((u) => {
          if (t = this._handleSingleObject(u, t), t instanceof g2)
            return s = true, o = t, false;
        }), s)
          return o;
      } else
        t = this._handleSingleObject(n, t);
    }
    return t instanceof g2 ? t : typeof t == "number" || s1(t) ? y2.create(+t) : U2.create(t);
  }
  _handleSingleObject(e, t) {
    let r = t;
    if (e.isError())
      return e;
    if (e.isBoolean())
      return g2.create(h.VALUE);
    const n = `${e.getValue()}`;
    if (typeof t != "number" && !t) {
      const s = new me2(n);
      if (s.isError())
        return g2.create(h.NUM);
      r = s.toString();
    } else {
      const s = new me2(t), o = new me2(n);
      if (s.isError() || o.isError())
        return g2.create(h.NUM);
      if (s.isDifferentSuffixes(o))
        return g2.create(h.VALUE);
      r = s.Sum(o);
    }
    return r;
  }
};
var hd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me2(o);
    if (u.isError())
      return g2.create(h.NUM);
    const c = u.Tan();
    return typeof c == "number" || s1(c) ? y2.create(+c) : U2.create(c);
  }
};
var gd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me2(o);
    if (u.isError())
      return g2.create(h.NUM);
    const c = u.Tanh();
    return u.isError() ? g2.create(h.NUM) : typeof c == "number" || s1(c) ? y2.create(+c) : U2.create(c);
  }
};
var dd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g2.create(h.NA);
    let r = 0;
    if (t) {
      const { isError: d2, errorObject: _2, variants: C } = W2(t);
      if (d2)
        return _2;
      const [E] = C;
      if (r = Math.floor(+E.getValue()), Number.isNaN(r))
        return g2.create(h.VALUE);
      if (r < 0 || r > 10)
        return g2.create(h.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = W2(e);
    if (n)
      return s;
    const [u] = o, c = `${u.getValue()}`;
    if (!va(c))
      return g2.create(h.NUM);
    const l = c.length === 10 && c.substring(0, 1) === "7", f2 = l ? Number.parseInt(c, 8) - 1073741824 : Number.parseInt(c, 8);
    if (f2 < -512 || f2 > 511)
      return g2.create(h.NUM);
    let m2;
    if (l) {
      const d2 = (512 + f2).toString(2);
      m2 = `1${"0".repeat(9 - d2.length)}${d2}`;
    } else if (m2 = f2.toString(2), t) {
      if (r < m2.length)
        return g2.create(h.NUM);
      m2 = "0".repeat(r - m2.length) + m2;
    }
    return U2.create(m2);
  }
};
var Cd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W2(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`;
    if (!va(o))
      return g2.create(h.NUM);
    let u = Number.parseInt(o, 8);
    return u >= 536870912 && (u -= 1073741824), y2.create(u);
  }
};
var _d = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g2.create(h.NA);
    let r = 0;
    if (t) {
      const { isError: m2, errorObject: d2, variants: _2 } = W2(t);
      if (m2)
        return d2;
      const [C] = _2;
      if (r = Math.floor(+C.getValue()), Number.isNaN(r))
        return g2.create(h.VALUE);
      if (r < 0 || r > 10)
        return g2.create(h.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = W2(e);
    if (n)
      return s;
    const [u] = o, c = `${u.getValue()}`;
    if (!va(c))
      return g2.create(h.NUM);
    const l = Number.parseInt(c, 8);
    let f2;
    if (l >= 536870912)
      f2 = `ff${(l + 3221225472).toString(16)}`;
    else if (f2 = l.toString(16), t) {
      if (r < f2.length)
        return g2.create(h.NUM);
      f2 = "0".repeat(r - f2.length) + f2;
    }
    return U2.create(f2.toLocaleUpperCase());
  }
};
var Ad = [
  [d1, Q.BESSELI],
  [C1, Q.BESSELJ],
  [_1, Q.BESSELK],
  [A1, Q.BESSELY],
  [E1, Q.BIN2DEC],
  [R1, Q.BIN2HEX],
  [b1, Q.BIN2OCT],
  [y12, Q.BITAND],
  [p1, Q.BITLSHIFT],
  [N1, Q.BITOR],
  [V1, Q.BITRSHIFT],
  [O1, Q.BITXOR],
  [S1, Q.COMPLEX],
  [M1, Q.CONVERT],
  [D1, Q.DEC2BIN],
  [w12, Q.DEC2HEX],
  [L1, Q.DEC2OCT],
  [P1, Q.DELTA],
  [x1, Q.ERF],
  [j1, Q.ERF_PRECISE],
  [U1, Q.ERFC],
  [v1, Q.ERFC_PRECISE],
  [T1, Q.GESTEP],
  [I1, Q.HEX2BIN],
  [B1, Q.HEX2DEC],
  [F1, Q.HEX2OCT],
  [k1, Q.IMABS],
  [$1, Q.IMAGINARY],
  [Y1, Q.IMARGUMENT],
  [H1, Q.IMCONJUGATE],
  [G1, Q.IMCOS],
  [W1, Q.IMCOSH],
  [Q1, Q.IMCOT],
  [q1, Q.IMCOTH],
  [X1, Q.IMCSC],
  [K1, Q.IMCSCH],
  [Z1, Q.IMDIV],
  [z1, Q.IMEXP],
  [J1, Q.IMLN],
  [ed, Q.IMLOG],
  [rd, Q.IMLOG10],
  [td, Q.IMLOG2],
  [nd, Q.IMPOWER],
  [sd, Q.IMPRODUCT],
  [ad, Q.IMREAL],
  [id, Q.IMSEC],
  [od, Q.IMSECH],
  [ud, Q.IMSIN],
  [cd, Q.IMSINH],
  [ld, Q.IMSQRT],
  [fd, Q.IMSUB],
  [md, Q.IMSUM],
  [hd, Q.IMTAN],
  [gd, Q.IMTANH],
  [dd, Q.OCT2BIN],
  [Cd, Q.OCT2DEC],
  [_d, Q.OCT2HEX]
];
var ee = ((a2) => (a2.ACCRINT = "ACCRINT", a2.ACCRINTM = "ACCRINTM", a2.AMORDEGRC = "AMORDEGRC", a2.AMORLINC = "AMORLINC", a2.COUPDAYBS = "COUPDAYBS", a2.COUPDAYS = "COUPDAYS", a2.COUPDAYSNC = "COUPDAYSNC", a2.COUPNCD = "COUPNCD", a2.COUPNUM = "COUPNUM", a2.COUPPCD = "COUPPCD", a2.CUMIPMT = "CUMIPMT", a2.CUMPRINC = "CUMPRINC", a2.DB = "DB", a2.DDB = "DDB", a2.DISC = "DISC", a2.DOLLARDE = "DOLLARDE", a2.DOLLARFR = "DOLLARFR", a2.DURATION = "DURATION", a2.EFFECT = "EFFECT", a2.FV = "FV", a2.FVSCHEDULE = "FVSCHEDULE", a2.INTRATE = "INTRATE", a2.IPMT = "IPMT", a2.IRR = "IRR", a2.ISPMT = "ISPMT", a2.MDURATION = "MDURATION", a2.MIRR = "MIRR", a2.NOMINAL = "NOMINAL", a2.NPER = "NPER", a2.NPV = "NPV", a2.ODDFPRICE = "ODDFPRICE", a2.ODDFYIELD = "ODDFYIELD", a2.ODDLPRICE = "ODDLPRICE", a2.ODDLYIELD = "ODDLYIELD", a2.PDURATION = "PDURATION", a2.PMT = "PMT", a2.PPMT = "PPMT", a2.PRICE = "PRICE", a2.PRICEDISC = "PRICEDISC", a2.PRICEMAT = "PRICEMAT", a2.PV = "PV", a2.RATE = "RATE", a2.RECEIVED = "RECEIVED", a2.RRI = "RRI", a2.SLN = "SLN", a2.SYD = "SYD", a2.TBILLEQ = "TBILLEQ", a2.TBILLPRICE = "TBILLPRICE", a2.TBILLYIELD = "TBILLYIELD", a2.VDB = "VDB", a2.XIRR = "XIRR", a2.XNPV = "XNPV", a2.YIELD = "YIELD", a2.YIELDDISC = "YIELDDISC", a2.YIELDMAT = "YIELDMAT", a2))(ee || {});
function As(a2, i, e, t) {
  const r = Gt(a2, i, e), { days: n } = _e2(r, a2, t);
  return n;
}
function ze(a2, i, e, t) {
  let r;
  if (t === 1) {
    const n = Gt(a2, i, e);
    let s = ae(n);
    s = Mr(s, 12 / e);
    const o = pe2(s);
    n < 0 && e === 1 ? r = 365 : r = o - n;
  } else t === 3 ? r = 365 / e : r = 360 / e;
  return r;
}
function oc(a2, i, e) {
  const t = ae(a2);
  let r = ae(i);
  for (r.setUTCFullYear(t.getUTCFullYear()), r < t && r.setUTCFullYear(r.getUTCFullYear() + 1); r > t; )
    r = Mr(r, -12 / e);
  return r = Mr(r, 12 / e), pe2(r);
}
function ur(a2, i, e) {
  let t = 0;
  const r = ae(a2);
  let n = ae(i);
  for (; n > r; )
    n = Mr(n, -12 / e), t++;
  return t;
}
function Gt(a2, i, e) {
  const t = ae(a2);
  let r = ae(i);
  for (r.setUTCFullYear(t.getUTCFullYear()), r < t && r.setUTCFullYear(r.getUTCFullYear() + 1); r > t; )
    r = Mr(r, -12 / e);
  return pe2(r);
}
function uc(a2, i, e, t, r, n) {
  const s = As(a2, i, r, n), o = ze(a2, i, r, n), u = ur(a2, i, r), c = (o - s) / o - 1, l = t / r + 1, f2 = e * 100 / r;
  let m2 = 0, d2 = 0;
  for (let E = 1; E <= u; E++) {
    const R = E + c, b = f2 / __pow(l, R);
    m2 += R * b, d2 += b;
  }
  const _2 = u + c, C = 100 / __pow(l, _2);
  return m2 += _2 * C, d2 += C, m2 / d2 / r;
}
function nn(a2, i, e, t, r) {
  let n;
  if (a2 === 0)
    n = (e + t) / i;
  else {
    const s = __pow(1 + a2, i);
    n = r === 1 ? (t * a2 / (s - 1) + e * a2 / (1 - 1 / s)) / (1 + a2) : t * a2 / (s - 1) + e * a2 / (1 - 1 / s);
  }
  return -n;
}
function cr(a2, i, e, t, r) {
  let n;
  if (a2 === 0)
    n = t + e * i;
  else {
    if (a2 === -1 && i === 0)
      return Number.NaN;
    const s = __pow(1 + a2, i);
    n = r === 1 ? t * s + e * (1 + a2) * (s - 1) / a2 : t * s + e * (s - 1) / a2;
  }
  return -n;
}
function cc(a2, i, e, t, r, n) {
  const s = nn(a2, e, t, r, n);
  return (i === 1 ? n === 1 ? 0 : -t : n === 1 ? cr(a2, i - 2, s, t, 1) - s : cr(a2, i - 1, s, t, 0)) * a2;
}
function lc(a2, i) {
  let e = 0;
  for (let t = 1; t <= i.length; t++)
    e += i[t - 1] / __pow(1 + a2, t);
  return e;
}
function fc(a2, i, e, t, r, n, s, o, u) {
  const c = er(e, t, u), l = ze(a2, t, o, u);
  return c < l ? Ed(
    a2,
    i,
    e,
    t,
    r,
    n,
    s,
    o,
    u,
    c,
    l
  ) : Rd(
    a2,
    i,
    e,
    t,
    r,
    n,
    s,
    o,
    u,
    l
  );
}
function Ed(a2, i, e, t, r, n, s, o, u, c, l) {
  let f2 = 0;
  const m2 = ur(a2, i, o), d2 = er(a2, t, u);
  f2 += s / __pow(1 + n / o, m2 - 1 + d2 / l), f2 += 100 * r / o * c / l / __pow(1 + n / o, d2 / l);
  for (let C = 2; C <= m2; C++)
    f2 += 100 * r / o / __pow(1 + n / o, C - 1 + d2 / l);
  const _2 = er(e, a2, u);
  return f2 -= 100 * r / o * _2 / l, f2;
}
function Rd(a2, i, e, t, r, n, s, o, u, c) {
  let l = 0;
  const f2 = ur(t, i, o), m2 = bd(t, a2, 12 / o);
  let d2;
  if (u === 2 || u === 3) {
    const b = oc(a2, t, o);
    d2 = er(a2, b, u);
  } else {
    const b = Gt(a2, t, o), { days: p2 } = _e2(b, a2, u);
    d2 = c - p2;
  }
  l += s / __pow(1 + n / o, f2 + m2 + d2 / c);
  const _2 = ur(e, t, o);
  let C = t, E = 0, R = 0;
  for (let b = _2; b >= 1; b--) {
    const p2 = ar(C, -12 / o, false), V = u === 1 ? er(p2, C, u) : c, S2 = b > 1 ? V : er(e, C, u);
    E += S2 / V;
    const M2 = e > p2 ? e : p2, D2 = a2 < C ? a2 : C, w = er(M2, D2, u);
    R += w / V, C = p2;
  }
  l += 100 * r / o * E / __pow(1 + n / o, m2 + d2 / c);
  for (let b = 1; b <= f2; b++)
    l += 100 * r / o / __pow(1 + n / o, b + m2 + d2 / c);
  return l -= 100 * r / o * R, l;
}
function er(a2, i, e) {
  const { days: t } = _e2(a2, i, e);
  return a2 < i ? t : 0;
}
function mc(a2, i, e) {
  const t = ae(a2), r = t.getUTCFullYear(), n = t.getUTCMonth(), s = t.getUTCDate(), o = Sr(r, n, s), u = ae(i), c = u.getUTCFullYear(), l = u.getUTCMonth(), f2 = u.getUTCDate(), m2 = Sr(c, l, f2);
  return !(s !== f2 && !(o && m2) || Math.abs((c - r) * 12 + (l - n)) % (12 / e) !== 0);
}
function Ur(a2, i, e) {
  return Gt(a2, i, e) >= 0;
}
function ar(a2, i, e) {
  let t = ae(a2);
  if (t = Mr(t, i), e) {
    const r = t.getUTCFullYear(), n = t.getUTCMonth(), s = rn(r, n);
    t.setUTCDate(s);
  }
  return pe2(t);
}
function bd(a2, i, e, t) {
  const r = ae(a2), n = ae(i), s = r.getUTCFullYear(), o = r.getUTCMonth(), u = r.getUTCDate(), c = n.getUTCFullYear(), l = n.getUTCMonth(), f2 = n.getUTCDate(), m2 = Sr(s, o, u), d2 = !m2 && o !== 1 && u > 28 && u < rn(s, o) ? Sr(c, l, f2) : m2, _2 = ar(i, 0, d2);
  let C = 1 + +(i < _2), E = ar(_2, e, d2);
  for (; !(e > 0 ? E >= i : E <= i); )
    E = ar(E, e, d2), C++;
  return C;
}
function Ja(a2, i) {
  let n = 1, s = 0, o = a2, u;
  for (; n > 1e-7 && s < 500; ) {
    const c = (i(o + 1e-7) - i(o - 1e-7)) / 2e-7;
    u = o - i(o) / c, s++, n = Math.abs(u - o), o = u;
  }
  return Number.isNaN(o) || Math.abs(o) === 1 / 0 || s === 500 ? yd(a2, i) : o;
}
function yd(a2, i) {
  const r = Number.MAX_VALUE, n = -1, s = 1.6;
  let o = a2 - 0.01 <= n ? n + 1e-7 : a2 - 0.01, u = a2 + 0.01 >= r ? r - 1e-7 : a2 + 0.01, c, l, f2 = 0;
  if (a2 <= n || a2 >= r)
    return g2.create(h.NUM);
  for (let E = 0; E < 60; E++) {
    c = o <= n ? n + 1e-7 : o, l = u >= r ? r - 1e-7 : u;
    const R = i(c), b = i(l);
    if (R * b <= 0)
      break;
    if (R * b > 0)
      o = c + s * (c - l), u = l + s * (l - c);
    else
      return g2.create(h.NUM);
    if (E === 59)
      return g2.create(h.NUM);
  }
  c = c, l = l;
  let m2 = i(c);
  const d2 = i(l);
  let _2, C;
  if (Math.abs(m2) < 1e-7 || Math.abs(d2) < 1e-7)
    return g2.create(h.NUM);
  do
    C = c + (l - c) / 2, _2 = i(C), m2 * _2 < 0 ? l = C : c = C, m2 = i(c), f2++;
  while (Math.abs(_2) > 1e-7 && f2 < 60);
  return C;
}
function pn(a2, i, e, t, r, n, s) {
  const o = ur(a2, i, n), u = ze(a2, i, n, s), c = As(a2, i, n, s);
  if (o === 1) {
    const m2 = u - c, d2 = 100 * e / n + r, _2 = t / n * m2 / u + 1, C = 100 * e / n * c / u;
    return d2 / _2 - C;
  }
  const l = u - c;
  let f2 = r / __pow(1 + t / n, o - 1 + l / u);
  for (let m2 = 1; m2 <= o; m2++)
    f2 += 100 * e / n / __pow(1 + t / n, m2 - 1 + l / u);
  return f2 -= 100 * e / n * c / u, f2;
}
function ma(a2, i, e, t, r) {
  let n = 0, s = r / e;
  s >= 1 ? (s = 1, n = t === 1 ? a2 : 0) : n = a2 * __pow(1 - s, t - 1);
  const o = a2 * __pow(1 - s, t);
  let u = 0;
  return o < i ? u = n - i : u = n - o, u < 0 && (u = 0), u;
}
var pd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 6);
    A(this, "maxParams", 8);
  }
  calculate(e, t, r, n, s, o, u, c) {
    const l = u != null ? u : y2.create(0), f2 = c != null ? c : T.create(true), { isError: m2, errorObject: d2, variants: _2 } = W2(e, t, r, n, s, o, l);
    if (m2)
      return d2;
    const [C, E, R, b, p2, V, S2] = _2, M2 = H(C);
    if (typeof M2 != "number")
      return M2;
    const D2 = H(E);
    if (typeof D2 != "number")
      return D2;
    const w = H(R);
    if (typeof w != "number")
      return w;
    const L = +b.getValue(), v = +p2.getValue(), j2 = Math.floor(+V.getValue()), k = Math.floor(+S2.getValue()), G2 = +f2.getValue();
    return Number.isNaN(L) || Number.isNaN(v) || Number.isNaN(j2) || Number.isNaN(k) || Number.isNaN(G2) ? g2.create(h.VALUE) : L <= 0 || v <= 0 || ![1, 2, 4].includes(j2) || k < 0 || k > 4 || Math.floor(M2) >= Math.floor(w) ? g2.create(h.NUM) : this._getResult(M2, D2, w, L, v, j2, k, G2);
  }
  _getResult(e, t, r, n, s, o, u, c) {
    let l = Gt(e, t, o);
    if (l <= 0)
      return y2.create(0);
    l = Gt(r, t, o);
    const f2 = 12 / o, m2 = ae(t), d2 = m2.getUTCFullYear(), _2 = m2.getUTCMonth(), C = m2.getUTCDate(), E = Sr(d2, _2, C);
    let R = ar(t, -f2, E);
    if (r > t && c)
      for (R = t; R < r; )
        R = ar(R, f2, E);
    let b = e > R ? e : R, { days: p2 } = _e2(b, r, u);
    if (l >= e) {
      const { days: L } = _e2(b, r, u ? 4 : 0);
      p2 = L;
    }
    r < b && (p2 = -p2);
    let V = ze(R, t, o, u), S2 = p2 / V, M2 = R, D2 = e;
    for (; M2 > e; ) {
      D2 = M2, M2 = ar(M2, -f2, E), b = e > M2 ? e : M2;
      const { days: L } = _e2(b, D2, u);
      if (u === 0)
        D2 >= b || e <= M2 ? p2 = L : p2 = -L, V = ze(M2, D2, o, u);
      else if (p2 = D2 < b ? -L : L, u === 3)
        V = 365 / o;
      else {
        const { days: v } = _e2(M2, D2, u);
        V = D2 < M2 ? -v : v;
      }
      S2 += e <= M2 ? c ? 1 : 0 : p2 / V;
    }
    const w = s * n / o * S2;
    return y2.create(w);
  }
};
var Nd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    const o = s != null ? s : y2.create(0), { isError: u, errorObject: c, variants: l } = W2(e, t, r, n, o);
    if (u)
      return c;
    const [f2, m2, d2, _2, C] = l, E = H(f2);
    if (typeof E != "number")
      return E;
    const R = H(m2);
    if (typeof R != "number")
      return R;
    const b = +d2.getValue(), p2 = +_2.getValue(), V = Math.floor(+C.getValue());
    if (Number.isNaN(b) || Number.isNaN(p2) || Number.isNaN(V))
      return g2.create(h.VALUE);
    if (b <= 0 || p2 <= 0 || V < 0 || V > 4 || Math.floor(E) > Math.floor(R))
      return g2.create(h.NUM);
    if (Math.floor(E) === Math.floor(R))
      return y2.create(0);
    const { days: S2, yearDays: M2 } = _e2(E, R, V), D2 = p2 * b * S2 / M2;
    return y2.create(D2);
  }
};
var Vd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 6);
    A(this, "maxParams", 7);
  }
  calculate(e, t, r, n, s, o, u) {
    const c = u != null ? u : y2.create(0), { isError: l, errorObject: f2, variants: m2 } = W2(e, t, r, n, s, o, c);
    if (l)
      return f2;
    const [d2, _2, C, E, R, b, p2] = m2, V = H(_2);
    if (typeof V != "number")
      return V;
    const S2 = H(C);
    if (typeof S2 != "number")
      return S2;
    const M2 = +d2.getValue(), D2 = +E.getValue();
    let w = +R.getValue();
    const L = +b.getValue(), v = Math.floor(+p2.getValue());
    return Number.isNaN(M2) || Number.isNaN(D2) || Number.isNaN(w) || Number.isNaN(L) || Number.isNaN(v) ? g2.create(h.VALUE) : M2 <= 0 || D2 < 0 || M2 < D2 || Math.floor(V) > Math.floor(S2) || w < 0 || L <= 0 || ![0, 1, 3, 4].includes(v) ? g2.create(h.NUM) : (w > 1 ? w = Math.floor(w) : w = Math.ceil(w), this._getResult(M2, V, S2, D2, w, L, v));
  }
  _getResult(e, t, r, n, s, o, u) {
    const c = e - n, l = e * o, { days: f2, yearDays: m2 } = _e2(t, r, u), d2 = f2 / m2, _2 = Math.ceil(c / l - d2);
    if (_2 < 0)
      return y2.create(0);
    let C = l;
    return s === 0 ? C = l * d2 : s === _2 ? C = c - l * (d2 + s - 1) : s > _2 && (C = 0), y2.create(C);
  }
};
var Od = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = n != null ? n : y2.create(0), { isError: o, errorObject: u, variants: c } = W2(e, t, r, s);
    if (o)
      return u;
    const [l, f2, m2, d2] = c, _2 = H(l);
    if (typeof _2 != "number")
      return _2;
    const C = H(f2);
    if (typeof C != "number")
      return C;
    const E = Math.floor(+m2.getValue()), R = Math.floor(+d2.getValue());
    if (Number.isNaN(E) || Number.isNaN(R))
      return g2.create(h.VALUE);
    if (![1, 2, 4].includes(E) || R < 0 || R > 4 || Math.floor(_2) >= Math.floor(C))
      return g2.create(h.NUM);
    const b = As(_2, C, E, R);
    return y2.create(b);
  }
};
var Sd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = n != null ? n : y2.create(0), { isError: o, errorObject: u, variants: c } = W2(e, t, r, s);
    if (o)
      return u;
    const [l, f2, m2, d2] = c, _2 = H(l);
    if (typeof _2 != "number")
      return _2;
    const C = H(f2);
    if (typeof C != "number")
      return C;
    const E = Math.floor(+m2.getValue()), R = Math.floor(+d2.getValue());
    if (Number.isNaN(E) || Number.isNaN(R))
      return g2.create(h.VALUE);
    if (![1, 2, 4].includes(E) || R < 0 || R > 4 || Math.floor(_2) >= Math.floor(C))
      return g2.create(h.NUM);
    const b = ze(_2, C, E, R);
    return y2.create(b);
  }
};
var Md = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = n != null ? n : y2.create(0), { isError: o, errorObject: u, variants: c } = W2(e, t, r, s);
    if (o)
      return u;
    const [l, f2, m2, d2] = c, _2 = H(l);
    if (typeof _2 != "number")
      return _2;
    const C = H(f2);
    if (typeof C != "number")
      return C;
    const E = Math.floor(+m2.getValue()), R = Math.floor(+d2.getValue());
    if (Number.isNaN(E) || Number.isNaN(R))
      return g2.create(h.VALUE);
    if (![1, 2, 4].includes(E) || R < 0 || R > 4 || Math.floor(_2) >= Math.floor(C))
      return g2.create(h.NUM);
    const b = ae(_2), p2 = ae(C);
    for (p2.setUTCFullYear(b.getUTCFullYear()), p2 < b && p2.setUTCFullYear(p2.getUTCFullYear() + 1); p2 > b; )
      p2.setUTCMonth(p2.getUTCMonth() - 12 / E);
    p2.setUTCMonth(p2.getUTCMonth() + 12 / E);
    const V = pe2(p2), { days: S2 } = _e2(_2, V, R);
    return y2.create(S2);
  }
};
var Dd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = n != null ? n : y2.create(0), { isError: o, errorObject: u, variants: c } = W2(e, t, r, s);
    if (o)
      return u;
    const [l, f2, m2, d2] = c, _2 = H(l);
    if (typeof _2 != "number")
      return _2;
    const C = H(f2);
    if (typeof C != "number")
      return C;
    const E = Math.floor(+m2.getValue()), R = Math.floor(+d2.getValue());
    if (Number.isNaN(E) || Number.isNaN(R))
      return g2.create(h.VALUE);
    if (![1, 2, 4].includes(E) || R < 0 || R > 4 || Math.floor(_2) >= Math.floor(C))
      return g2.create(h.NUM);
    const b = oc(_2, C, E);
    return y2.create(b);
  }
};
var wd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = n != null ? n : y2.create(0), { isError: o, errorObject: u, variants: c } = W2(e, t, r, s);
    if (o)
      return u;
    const [l, f2, m2, d2] = c, _2 = H(l);
    if (typeof _2 != "number")
      return _2;
    const C = H(f2);
    if (typeof C != "number")
      return C;
    const E = Math.floor(+m2.getValue()), R = Math.floor(+d2.getValue());
    if (Number.isNaN(E) || Number.isNaN(R))
      return g2.create(h.VALUE);
    if (![1, 2, 4].includes(E) || R < 0 || R > 4 || Math.floor(_2) >= Math.floor(C) || Gt(_2, C, E) < 0)
      return g2.create(h.NUM);
    const p2 = ur(_2, C, E);
    return y2.create(p2);
  }
};
var Ld = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = n != null ? n : y2.create(0), { isError: o, errorObject: u, variants: c } = W2(e, t, r, s);
    if (o)
      return u;
    const [l, f2, m2, d2] = c, _2 = H(l);
    if (typeof _2 != "number")
      return _2;
    const C = H(f2);
    if (typeof C != "number")
      return C;
    const E = Math.floor(+m2.getValue()), R = Math.floor(+d2.getValue());
    if (Number.isNaN(E) || Number.isNaN(R))
      return g2.create(h.VALUE);
    if (![1, 2, 4].includes(E) || R < 0 || R > 4 || Math.floor(_2) >= Math.floor(C))
      return g2.create(h.NUM);
    let b = Gt(_2, C, E);
    return b < 0 && (b = 0), y2.create(b);
  }
};
var Pd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 6);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    const { isError: u, errorObject: c, variants: l } = W2(e, t, r, n, s, o);
    if (u)
      return c;
    const [f2, m2, d2, _2, C, E] = l, R = +f2.getValue(), b = +m2.getValue(), p2 = +d2.getValue(), V = +_2.getValue(), S2 = +C.getValue(), M2 = +E.getValue();
    return Number.isNaN(R) || Number.isNaN(b) || Number.isNaN(p2) || Number.isNaN(V) || Number.isNaN(S2) || Number.isNaN(M2) ? g2.create(h.VALUE) : R <= 0 || b <= 0 || p2 <= 0 || V < 1 || S2 < 1 || V > S2 || V > b || S2 > b || ![0, 1].includes(M2) ? g2.create(h.NUM) : Math.trunc(V) !== V && Math.trunc(S2) !== S2 && Math.trunc(V) === Math.trunc(S2) ? y2.create(0) : this._getResult(R, b, p2, V, S2, M2);
  }
  _getResult(e, t, r, n, s, o) {
    const u = nn(e, t, r, 0, o);
    let c = 0, l = Math.ceil(n);
    l === 1 && (o === 0 && (c = -r), l++);
    let f2 = false;
    for (let m2 = l; m2 <= s; m2++) {
      const d2 = o === 1 ? cr(e, m2 - 2, u, r, 1) : cr(e, m2 - 1, u, r, 0);
      if (d2 === 0) {
        f2 = true;
        break;
      }
      c += o === 1 ? d2 - u : d2;
    }
    return c *= e, (c < u * (s - n + 1) || f2) && (c = u * (s - n + 1)), y2.create(c);
  }
};
var xd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 6);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    const { isError: u, errorObject: c, variants: l } = W2(e, t, r, n, s, o);
    if (u)
      return c;
    const [f2, m2, d2, _2, C, E] = l, R = +f2.getValue(), b = +m2.getValue(), p2 = +d2.getValue(), V = +_2.getValue(), S2 = +C.getValue(), M2 = +E.getValue();
    return Number.isNaN(R) || Number.isNaN(b) || Number.isNaN(p2) || Number.isNaN(V) || Number.isNaN(S2) || Number.isNaN(M2) ? g2.create(h.VALUE) : R <= 0 || b <= 0 || p2 <= 0 || V < 1 || S2 < 1 || V > S2 || ![0, 1].includes(M2) ? g2.create(h.NUM) : Math.trunc(V) !== V && Math.trunc(S2) !== S2 && Math.trunc(V) === Math.trunc(S2) ? y2.create(0) : this._getResult(R, b, p2, V, S2, M2);
  }
  _getResult(e, t, r, n, s, o) {
    const u = nn(e, t, r, 0, o);
    let c = 0, l = Math.ceil(n);
    l === 1 && (c = o === 0 ? u + r * e : u, l++);
    for (let f2 = l; f2 <= s; f2++)
      c += o === 1 ? u - (cr(e, f2 - 2, u, r, 1) - u) * e : u - cr(e, f2 - 1, u, r, 0) * e;
    return y2.create(c);
  }
};
var jd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 5);
    A(this, "needsLocale", true);
  }
  calculate(e, t, r, n, s) {
    let o = s != null ? s : y2.create(12);
    o.isNull() && (o = y2.create(12));
    const u = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1
    ), c = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1
    ), l = O(u, c, e, g2.create(h.NA)), f2 = O(u, c, t, g2.create(h.NA)), m2 = O(u, c, r, g2.create(h.NA)), d2 = O(u, c, n, g2.create(h.NA)), _2 = O(u, c, o, g2.create(h.NA)), C = l.map((E, R, b) => {
      const p2 = f2.get(R, b), V = m2.get(R, b), S2 = d2.get(R, b), M2 = _2.get(R, b), { isError: D2, errorObject: w, variants: L } = I2(E, p2, V, S2, M2);
      if (D2)
        return w;
      const [v, j2, k, G2, ne] = L, z = +v.getValue(), $2 = +j2.getValue(), ge3 = +k.getValue();
      let Ce2 = +G2.getValue();
      const be = Math.floor(+ne.getValue());
      return z < 0 || $2 < 0 || ge3 <= 0 || Ce2 <= 0 || Math.floor(Ce2) > Math.floor(ge3) || be < 1 || be > 12 ? g2.create(h.NUM) : (Ce2 < 1 && (Ce2 = 1), Ce2 = Math.floor(Ce2), this._getResult(z, $2, ge3, Ce2, be, R, b));
    });
    return u === 1 && c === 1 ? C.get(0, 0) : C;
  }
  _getResult(e, t, r, n, s, o, u) {
    const c = +(1 - __pow(t / e, 1 / r)).toFixed(3), l = e * c * s / 12;
    let f2 = l, m2 = 0;
    const d2 = n === r ? r - 1 : n;
    for (let C = 2; C <= d2; C++)
      m2 = (e - f2) * c, f2 += m2;
    let _2;
    return n === 1 ? _2 = l : n === r ? _2 = (e - f2) * c : _2 = m2, Number.isNaN(_2) || !Number.isFinite(_2) ? g2.create(h.NUM) : o === 0 && u === 0 ? y2.create(_2, et2(this.getLocale())) : y2.create(_2);
  }
};
var Ud = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 5);
    A(this, "needsLocale", true);
  }
  calculate(e, t, r, n, s) {
    let o = s != null ? s : y2.create(2);
    o.isNull() && (o = y2.create(2));
    const u = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1
    ), c = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1
    ), l = O(u, c, e, g2.create(h.NA)), f2 = O(u, c, t, g2.create(h.NA)), m2 = O(u, c, r, g2.create(h.NA)), d2 = O(u, c, n, g2.create(h.NA)), _2 = O(u, c, o, g2.create(h.NA)), C = l.map((E, R, b) => {
      const p2 = f2.get(R, b), V = m2.get(R, b), S2 = d2.get(R, b), M2 = _2.get(R, b), { isError: D2, errorObject: w, variants: L } = I2(E, p2, V, S2, M2);
      if (D2)
        return w;
      const [v, j2, k, G2, ne] = L, z = +v.getValue(), $2 = +j2.getValue(), ge3 = +k.getValue(), Ce2 = +G2.getValue(), be = +ne.getValue();
      if (z < 0 || $2 < 0 || ge3 <= 0 || Ce2 <= 0 || Ce2 > ge3 || be <= 0)
        return g2.create(h.NUM);
      const Ne = ma(z, $2, ge3, Ce2, be);
      return Number.isNaN(Ne) || !Number.isFinite(Ne) ? g2.create(h.NUM) : R === 0 && b === 0 ? y2.create(Ne, et2(this.getLocale())) : y2.create(Ne);
    });
    return u === 1 && c === 1 ? C.get(0, 0) : C;
  }
};
var vd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    const o = s != null ? s : y2.create(0), { isError: u, errorObject: c, variants: l } = W2(e, t, r, n, o);
    if (u)
      return c;
    const [f2, m2, d2, _2, C] = l, E = H(f2);
    if (typeof E != "number")
      return E;
    const R = H(m2);
    if (typeof R != "number")
      return R;
    const b = +d2.getValue(), p2 = +_2.getValue(), V = Math.floor(+C.getValue());
    if (Number.isNaN(b) || Number.isNaN(p2) || Number.isNaN(V))
      return g2.create(h.VALUE);
    if (b <= 0 || p2 <= 0 || V < 0 || V > 4 || Math.floor(E) >= Math.floor(R))
      return g2.create(h.NUM);
    const { days: S2, yearDays: M2 } = _e2(E, R, V), D2 = (p2 - b) / p2 * (M2 / S2);
    return y2.create(D2);
  }
};
var Td = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = W2(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue();
    let l = Math.floor(+u.getValue());
    if (Number.isNaN(c) || Number.isNaN(l))
      return g2.create(h.VALUE);
    if (l < 0)
      return g2.create(h.NUM);
    if (l >= 0 && l < 1)
      return g2.create(h.DIV_BY_ZERO);
    l = Number.parseInt(`${l}`, 10);
    let f2 = Number.parseInt(`${c}`, 10);
    f2 += c % 1 * __pow(10, Math.ceil(Math.log(l) / Math.LN10)) / l;
    const m2 = __pow(10, Math.ceil(Math.log(l) / Math.LN2) + 1);
    return f2 = Math.round(f2 * m2) / m2, y2.create(f2);
  }
};
var Id = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = W2(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue();
    let l = Math.floor(+u.getValue());
    if (Number.isNaN(c) || Number.isNaN(l))
      return g2.create(h.VALUE);
    if (l < 0)
      return g2.create(h.NUM);
    if (l >= 0 && l < 1)
      return g2.create(h.DIV_BY_ZERO);
    l = Number.parseInt(`${l}`, 10);
    let f2 = Number.parseInt(`${c}`, 10);
    return f2 += c % 1 * __pow(10, -Math.ceil(Math.log(l) / Math.LN10)) * l, y2.create(f2);
  }
};
var Bd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 5);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    let u = o != null ? o : y2.create(0);
    u.isNull() && (u = y2.create(0));
    const { isError: c, errorObject: l, variants: f2 } = Ye(e, t, r, n, s, u);
    if (c)
      return l;
    const [m2, d2, _2, C, E, R] = f2, b = H(m2);
    if (typeof b != "number")
      return b;
    const p2 = H(d2);
    if (typeof p2 != "number")
      return p2;
    const V = +_2.getValue(), S2 = +C.getValue(), M2 = Math.floor(+E.getValue()), D2 = Math.floor(+R.getValue());
    if (Number.isNaN(V) || Number.isNaN(S2) || Number.isNaN(M2) || Number.isNaN(D2))
      return g2.create(h.VALUE);
    if (V < 0 || S2 < 0 || ![1, 2, 4].includes(M2) || D2 < 0 || D2 > 4 || Math.floor(b) >= Math.floor(p2) || b <= 0 || p2 <= 366)
      return g2.create(h.NUM);
    const w = uc(b, p2, V, S2, M2, D2);
    return y2.create(w);
  }
};
var Fd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = W2(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue();
    let l = Math.floor(+u.getValue());
    if (Number.isNaN(c) || Number.isNaN(l))
      return g2.create(h.VALUE);
    if (c <= 0 || l < 1)
      return g2.create(h.NUM);
    l = Number.parseInt(`${l}`, 10);
    const f2 = __pow(1 + c / l, l) - 1;
    return y2.create(f2);
  }
};
var kd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 5);
    A(this, "needsLocale", true);
  }
  calculate(e, t, r, n, s) {
    const o = n != null ? n : y2.create(0), u = s != null ? s : y2.create(0), c = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1
    ), l = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1
    ), f2 = O(c, l, e, g2.create(h.NA)), m2 = O(c, l, t, g2.create(h.NA)), d2 = O(c, l, r, g2.create(h.NA)), _2 = O(c, l, o, g2.create(h.NA)), C = O(c, l, u, g2.create(h.NA)), E = f2.map((R, b, p2) => {
      const V = m2.get(b, p2), S2 = d2.get(b, p2), M2 = _2.get(b, p2), D2 = C.get(b, p2), { isError: w, errorObject: L, variants: v } = I2(R, V, S2, M2, D2);
      if (w)
        return L;
      const [j2, k, G2, ne, z] = v, $2 = +j2.getValue(), ge3 = +k.getValue(), Ce2 = +G2.getValue(), be = +ne.getValue(), Ne = +z.getValue(), he2 = cr($2, ge3, Ce2, be, Ne ? 1 : 0);
      return Number.isNaN(he2) || !Number.isFinite(he2) ? g2.create(h.NUM) : b === 0 && p2 === 0 ? y2.create(he2, et2(this.getLocale())) : y2.create(he2);
    });
    return c === 1 && l === 1 ? E.get(0, 0) : E;
  }
};
var $d = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = W2(e);
    if (r)
      return n;
    const [o] = s, u = +o.getValue();
    if (Number.isNaN(u))
      return g2.create(h.VALUE);
    let c = u;
    if (t.isArray()) {
      const l = t.getArrayValue().flat();
      for (let f2 = 0; f2 < l.length; f2++) {
        const m2 = l[f2];
        if (m2.isBoolean())
          return g2.create(h.VALUE);
        const d2 = +m2.getValue();
        if (Number.isNaN(d2))
          return g2.create(h.VALUE);
        c *= 1 + d2;
      }
    } else {
      if (t.isBoolean())
        return g2.create(h.VALUE);
      const l = +t.getValue();
      if (Number.isNaN(l))
        return g2.create(h.VALUE);
      c *= 1 + l;
    }
    return y2.create(c);
  }
};
var Yd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    const o = s != null ? s : y2.create(0), { isError: u, errorObject: c, variants: l } = W2(e, t, r, n, o);
    if (u)
      return c;
    const [f2, m2, d2, _2, C] = l, E = H(f2);
    if (typeof E != "number")
      return E;
    const R = H(m2);
    if (typeof R != "number")
      return R;
    const b = +d2.getValue(), p2 = +_2.getValue(), V = Math.floor(+C.getValue());
    if (Number.isNaN(b) || Number.isNaN(p2) || Number.isNaN(V))
      return g2.create(h.VALUE);
    if (b <= 0 || p2 <= 0 || V < 0 || V > 4 || Math.floor(E) >= Math.floor(R))
      return g2.create(h.NUM);
    const { days: S2, yearDays: M2 } = _e2(E, R, V), D2 = (p2 - b) / b * (M2 / S2);
    return y2.create(D2);
  }
};
var Hd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 6);
    A(this, "needsLocale", true);
  }
  calculate(e, t, r, n, s, o) {
    const u = s != null ? s : y2.create(0), c = o != null ? o : y2.create(0), l = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f2 = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), m2 = O(l, f2, e, g2.create(h.NA)), d2 = O(l, f2, t, g2.create(h.NA)), _2 = O(l, f2, r, g2.create(h.NA)), C = O(l, f2, n, g2.create(h.NA)), E = O(l, f2, u, g2.create(h.NA)), R = O(l, f2, c, g2.create(h.NA)), b = m2.map((p2, V, S2) => {
      const M2 = d2.get(V, S2), D2 = _2.get(V, S2), w = C.get(V, S2), L = E.get(V, S2), v = R.get(V, S2), { isError: j2, errorObject: k, variants: G2 } = I2(p2, M2, D2, w, L, v);
      if (j2)
        return k;
      const [ne, z, $2, ge3, Ce2, be] = G2, Ne = +ne.getValue(), he2 = +z.getValue(), Be2 = +$2.getValue(), Ct = +ge3.getValue(), jt = +Ce2.getValue(), Ut = +be.getValue();
      if (he2 < 1 || Math.floor(he2) > Math.ceil(Be2))
        return g2.create(h.NUM);
      const ct2 = cc(Ne, he2, Be2, Ct, jt, Ut ? 1 : 0);
      return Number.isNaN(ct2) || !Number.isFinite(ct2) ? g2.create(h.NUM) : V === 0 && S2 === 0 ? y2.create(ct2, et2(this.getLocale())) : y2.create(ct2);
    });
    return l === 1 && f2 === 1 ? b.get(0, 0) : b;
  }
};
var Gd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = t != null ? t : y2.create(0.1);
    return r.isNull() && (r = y2.create(0.1)), r.isArray() ? r.map((n, s, o) => this._handleSingleObject(e, n, s, o)) : this._handleSingleObject(e, r);
  }
  _handleSingleObject(e, t, r = 0, n = 0) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (e.isNull())
      return g2.create(h.VALUE);
    if (!e.isArray())
      return g2.create(h.NUM);
    const { _values: s, valuesHasError: o } = this._getValues(e);
    if (o)
      return g2.create(h.VALUE);
    let u = t;
    if (u.isString() && (u = u.convertToNumberObjectValue(), u.isError()))
      return u;
    const c = +u.getValue(), { positive: l, negative: f2 } = this._checkValues(s);
    if (!l || !f2)
      return g2.create(h.NUM);
    const m2 = Ja(c, (d2) => lc(d2, s));
    return typeof m2 != "number" ? m2 : r === 0 && n === 0 ? y2.create(m2, "0%") : y2.create(m2);
  }
  _getValues(e) {
    const t = [];
    let r = false;
    return e.iterator((n) => {
      const s = n;
      if (s.isError())
        return r = true, false;
      if (s.isNull() || s.isBoolean() || s.isString() && s.getValue() === "")
        return true;
      const o = +s.getValue();
      if (Number.isNaN(o))
        return true;
      t.push(o);
    }), {
      _values: t,
      valuesHasError: r
    };
  }
  _checkValues(e) {
    let t = false, r = false;
    for (let n = 0; n < e.length; n++)
      e[n] > 0 && (t = true), e[n] < 0 && (r = true);
    return {
      positive: t,
      negative: r
    };
  }
};
var Wd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g2.create(h.NA)), c = O(s, o, t, g2.create(h.NA)), l = O(s, o, r, g2.create(h.NA)), f2 = O(s, o, n, g2.create(h.NA)), m2 = u.map((d2, _2, C) => {
      const E = c.get(_2, C), R = l.get(_2, C), b = f2.get(_2, C), { isError: p2, errorObject: V, variants: S2 } = I2(d2, E, R, b);
      if (p2)
        return V;
      const [M2, D2, w, L] = S2, v = +M2.getValue(), j2 = +D2.getValue(), k = +w.getValue(), G2 = +L.getValue();
      if (k === 0)
        return g2.create(h.DIV_BY_ZERO);
      const ne = G2 * v * (j2 / k - 1);
      return y2.create(ne);
    });
    return s === 1 && o === 1 ? m2.get(0, 0) : m2;
  }
};
var Qd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 5);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    let u = o != null ? o : y2.create(0);
    u.isNull() && (u = y2.create(0));
    const { isError: c, errorObject: l, variants: f2 } = Ye(e, t, r, n, s, u);
    if (c)
      return l;
    const [m2, d2, _2, C, E, R] = f2, b = H(m2);
    if (typeof b != "number")
      return b;
    const p2 = H(d2);
    if (typeof p2 != "number")
      return p2;
    const V = +_2.getValue(), S2 = +C.getValue(), M2 = Math.floor(+E.getValue()), D2 = Math.floor(+R.getValue());
    if (Number.isNaN(V) || Number.isNaN(S2) || Number.isNaN(M2) || Number.isNaN(D2))
      return g2.create(h.VALUE);
    if (V < 0 || S2 < 0 || ![1, 2, 4].includes(M2) || D2 < 0 || D2 > 4 || Math.floor(b) >= Math.floor(p2))
      return g2.create(h.NUM);
    let w = uc(b, p2, V, S2, M2, D2);
    return w /= 1 + S2 / M2, y2.create(w);
  }
};
var qd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { _values: n, numberValues: s, positive: o, negative: u } = this._getValues(e), c = Math.max(
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), l = Math.max(
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), f2 = O(c, l, t, g2.create(h.NA)), m2 = O(c, l, r, g2.create(h.NA)), d2 = f2.map((_2, C, E) => {
      const R = m2.get(C, E);
      if (e.isError())
        return e;
      if (R.isError())
        return R;
      if (n.isError())
        return n;
      if (!o || !u)
        return g2.create(h.DIV_BY_ZERO);
      const b = +_2.getValue(), p2 = +R.getValue();
      if (Number.isNaN(b) || Number.isNaN(p2))
        return g2.create(h.VALUE);
      if (p2 === -1)
        return g2.create(h.DIV_BY_ZERO);
      const V = this._getResult(s, b, p2);
      return C === 0 && E === 0 ? y2.create(V, "0%") : y2.create(V);
    });
    return c === 1 && l === 1 ? d2.get(0, 0) : d2;
  }
  _getValues(e) {
    let t = e, r = [], n = false, s = false;
    if (!e.isError())
      if (e.isNull())
        t = g2.create(h.VALUE);
      else if (!e.isArray())
        t = g2.create(h.DIV_BY_ZERO);
      else {
        const { numberValues: o, valuesHasError: u, errorObject: c, positive: l, negative: f2 } = this._checkValues(e);
        u && (t = c), r = o, n = l, s = f2;
      }
    return {
      _values: t,
      numberValues: r,
      positive: n,
      negative: s
    };
  }
  _checkValues(e) {
    const t = [];
    let r = false, n = g2.create(h.VALUE), s = false, o = false;
    return e.iterator((u) => {
      const c = u;
      if (c.isError())
        return r = true, n = c, false;
      if (c.isNull() || c.isBoolean() || c.isString() && c.getValue() === "")
        return true;
      const l = +c.getValue();
      if (Number.isNaN(l))
        return true;
      l > 0 && (s = true), l < 0 && (o = true), t.push(l);
    }), {
      numberValues: t,
      valuesHasError: r,
      errorObject: n,
      positive: s,
      negative: o
    };
  }
  _getResult(e, t, r) {
    const n = e.length, s = [], o = [];
    for (let d2 = 0; d2 < n; d2++)
      e[d2] > 0 ? o.push(e[d2]) : e[d2] < 0 && s.push(e[d2]);
    const u = this._npv(r, e, "positive"), c = this._npv(t, e, "negative"), l = -u * __pow(1 + r, n), f2 = c * (1 + t);
    return __pow(l / f2, 1 / (n - 1)) - 1;
  }
  _npv(e, t, r) {
    let n = 0;
    for (let s = 1; s <= t.length; s++) {
      const o = t[s - 1];
      (r === "positive" && o > 0 || r === "negative" && o < 0) && (n += o / __pow(1 + e, s));
    }
    return n;
  }
};
var Xd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = W2(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue();
    let l = Math.floor(+u.getValue());
    if (Number.isNaN(c) || Number.isNaN(l))
      return g2.create(h.VALUE);
    if (c <= 0 || l < 1)
      return g2.create(h.NUM);
    l = Number.parseInt(`${l}`, 10);
    const f2 = (__pow(c + 1, 1 / l) - 1) * l;
    return y2.create(f2);
  }
};
var Kd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    const o = n != null ? n : y2.create(0), u = s != null ? s : y2.create(0), c = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1
    ), l = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1
    ), f2 = O(c, l, e, g2.create(h.NA)), m2 = O(c, l, t, g2.create(h.NA)), d2 = O(c, l, r, g2.create(h.NA)), _2 = O(c, l, o, g2.create(h.NA)), C = O(c, l, u, g2.create(h.NA)), E = f2.map((R, b, p2) => {
      const V = m2.get(b, p2), S2 = d2.get(b, p2), M2 = _2.get(b, p2), D2 = C.get(b, p2), { isError: w, errorObject: L, variants: v } = I2(R, V, S2, M2, D2);
      if (w)
        return L;
      const [j2, k, G2, ne, z] = v, $2 = +j2.getValue(), ge3 = +k.getValue(), Ce2 = +G2.getValue(), be = +ne.getValue();
      let Ne = +z.getValue();
      if (Ne = Ne ? 1 : 0, $2 === 0 && ge3 === 0)
        return g2.create(h.DIV_BY_ZERO);
      let he2;
      if ($2 === 0)
        he2 = -(Ce2 + be) / ge3;
      else {
        const Be2 = ge3 * (1 + $2 * Ne) - be * $2, Ct = Ce2 * $2 + ge3 * (1 + $2 * Ne);
        he2 = Math.log(Be2 / Ct) / Math.log(1 + $2);
      }
      return Number.isNaN(he2) || !Number.isFinite(he2) ? g2.create(h.NUM) : y2.create(he2);
    });
    return c === 1 && l === 1 ? E.get(0, 0) : E;
  }
};
var Zd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
    A(this, "needsLocale", true);
  }
  calculate(e, ...t) {
    if (e.isError())
      return e;
    const { isError: r, errorObject: n, values: s } = this._getValues(t);
    return e.isArray() ? e.map((o, u, c) => this._handleSingleObject(o, r, n, s, u, c)) : this._handleSingleObject(e, r, n, s);
  }
  _handleSingleObject(e, t, r, n, s = 0, o = 0) {
    let u = e;
    if (u.isString() && (u = u.convertToNumberObjectValue()), u.isError())
      return u;
    if (t)
      return r;
    const c = +e.getValue(), l = lc(c, n);
    return Number.isNaN(l) || Math.abs(l) === 1 / 0 ? g2.create(h.DIV_BY_ZERO) : s === 0 && o === 0 ? y2.create(l, et2(this.getLocale())) : y2.create(l);
  }
  _getValues(e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      if (n.isError())
        return {
          isError: true,
          errorObject: n
        };
      if (n.isArray()) {
        let s = false, o = g2.create(h.VALUE);
        if (n.iterator((u) => {
          const c = u;
          if (c.isError())
            return s = true, o = c, false;
          if (c.isNull() || c.isBoolean() || c.isString() && c.getValue() === "")
            return true;
          const l = +c.getValue();
          if (Number.isNaN(l))
            return true;
          t.push(l);
        }), s)
          return {
            isError: s,
            errorObject: o
          };
      } else {
        const s = +n.getValue();
        if (Number.isNaN(s))
          return {
            isError: true,
            errorObject: g2.create(h.VALUE)
          };
        t.push(s);
      }
    }
    return {
      isError: false,
      values: t
    };
  }
};
var zd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 8);
    A(this, "maxParams", 9);
  }
  calculate(e, t, r, n, s, o, u, c, l) {
    let f2 = l != null ? l : y2.create(0);
    f2.isNull() && (f2 = y2.create(0));
    const { isError: m2, errorObject: d2, variants: _2 } = Ye(e, t, r, n, s, o, u, c, f2);
    if (m2)
      return d2;
    const [C, E, R, b, p2, V, S2, M2, D2] = _2, w = H(C);
    if (typeof w != "number")
      return w;
    const L = H(E);
    if (typeof L != "number")
      return L;
    const v = H(R);
    if (typeof v != "number")
      return v;
    const j2 = H(b);
    if (typeof j2 != "number")
      return j2;
    const k = +p2.getValue(), G2 = +V.getValue(), ne = +S2.getValue(), z = Math.floor(+M2.getValue()), $2 = Math.floor(+D2.getValue());
    if (Number.isNaN(k) || Number.isNaN(G2) || Number.isNaN(ne) || Number.isNaN(z) || Number.isNaN($2))
      return g2.create(h.VALUE);
    if (k < 0 || G2 < 0 || ne <= 0 || ![1, 2, 4].includes(z) || $2 < 0 || $2 > 4 || !this._validDate(L, j2, w, v, z))
      return g2.create(h.NUM);
    const ge3 = fc(w, L, v, j2, k, G2, ne, z, $2);
    return y2.create(ge3);
  }
  _validDate(e, t, r, n, s) {
    return this._getDateCorrectOrder(e, t, r, n) && mc(e, t, s) && Ur(n, e, s);
  }
  _getDateCorrectOrder(e, t, r, n) {
    return Math.floor(e) > Math.floor(t) && Math.floor(t) > Math.floor(r) && Math.floor(r) > Math.floor(n);
  }
};
var Jd = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 8);
    A(this, "maxParams", 9);
  }
  calculate(e, t, r, n, s, o, u, c, l) {
    let f2 = l != null ? l : y2.create(0);
    f2.isNull() && (f2 = y2.create(0));
    const { isError: m2, errorObject: d2, variants: _2 } = Ye(e, t, r, n, s, o, u, c, f2);
    if (m2)
      return d2;
    const [C, E, R, b, p2, V, S2, M2, D2] = _2, w = H(C);
    if (typeof w != "number")
      return w;
    const L = H(E);
    if (typeof L != "number")
      return L;
    const v = H(R);
    if (typeof v != "number")
      return v;
    const j2 = H(b);
    if (typeof j2 != "number")
      return j2;
    const k = +p2.getValue(), G2 = +V.getValue(), ne = +S2.getValue(), z = Math.floor(+M2.getValue()), $2 = Math.floor(+D2.getValue());
    return Number.isNaN(k) || Number.isNaN(G2) || Number.isNaN(ne) || Number.isNaN(z) || Number.isNaN($2) ? g2.create(h.VALUE) : k < 0 || G2 <= 0 || ne <= 0 || ![1, 2, 4].includes(z) || $2 < 0 || $2 > 4 || !this._validDate(L, j2, w, v, z) ? g2.create(h.NUM) : this._getResult(w, L, v, j2, k, G2, ne, z, $2);
  }
  _validDate(e, t, r, n, s) {
    return this._getDateCorrectOrder(e, t, r, n) && mc(e, t, s) && Ur(n, e, s);
  }
  _getDateCorrectOrder(e, t, r, n) {
    return Math.floor(e) > Math.floor(t) && Math.floor(t) > Math.floor(r) && Math.floor(r) > Math.floor(n);
  }
  _getResult(e, t, r, n, s, o, u, c, l) {
    const { days: f2 } = _e2(e, t, l), m2 = (s * f2 * 100 - (o - 100)) / ((o - 100) * 0.25 * (1 + 2 * f2) + f2 * 100);
    function d2(C) {
      return o - fc(e, t, r, n, s, C, u, c, l);
    }
    const _2 = Ja(m2, (C) => d2(C));
    return typeof _2 != "number" ? _2 : y2.create(_2);
  }
};
var e0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 7);
    A(this, "maxParams", 8);
  }
  calculate(e, t, r, n, s, o, u, c) {
    let l = c != null ? c : y2.create(0);
    l.isNull() && (l = y2.create(0));
    const { isError: f2, errorObject: m2, variants: d2 } = Ye(e, t, r, n, s, o, u, l);
    if (f2)
      return m2;
    const [_2, C, E, R, b, p2, V, S2] = d2, M2 = H(_2);
    if (typeof M2 != "number")
      return M2;
    const D2 = H(C);
    if (typeof D2 != "number")
      return D2;
    const w = H(E);
    if (typeof w != "number")
      return w;
    const L = +R.getValue(), v = +b.getValue(), j2 = +p2.getValue(), k = Math.floor(+V.getValue()), G2 = Math.floor(+S2.getValue());
    if (Number.isNaN(L) || Number.isNaN(v) || Number.isNaN(j2) || Number.isNaN(k) || Number.isNaN(G2))
      return g2.create(h.VALUE);
    if (L < 0 || v < 0 || j2 <= 0 || ![1, 2, 4].includes(k) || G2 < 0 || G2 > 4 || !this._validDate(D2, M2, w, k))
      return g2.create(h.NUM);
    const ne = this._getResult(M2, D2, w, L, v, j2, k, G2);
    return y2.create(ne);
  }
  _validDate(e, t, r, n) {
    return Math.floor(e) > Math.floor(t) && Math.floor(t) > Math.floor(r) && Ur(r, e, n);
  }
  _getResult(e, t, r, n, s, o, u, c) {
    const l = this._getCoupDate(t, r, u), f2 = this._getFrac(r, e, l, u, c), m2 = this._getFrac(r, t, l, u, c), d2 = this._getFrac(e, t, l, u, c);
    return (o * u + 100 * n * (m2 - f2 * (1 + s * d2 / u))) / (s * d2 + u);
  }
  _getCoupDate(e, t, r) {
    const n = ae(e), s = ae(t);
    for (s.setUTCFullYear(n.getUTCFullYear()), s > n && s.setUTCFullYear(s.getUTCFullYear() - 1); s < n; )
      s.setUTCMonth(s.getUTCMonth() + 12 / r);
    return pe2(s);
  }
  _getFrac(e, t, r, n, s) {
    const o = ae(e), u = ae(t), c = ae(r);
    for (c.setUTCFullYear(o.getUTCFullYear()), c < o && c.setUTCFullYear(c.getUTCFullYear() + 1); c > o; )
      c.setUTCMonth(c.getUTCMonth() - 12 / n);
    let l = pe2(c);
    c.setUTCMonth(c.getUTCMonth() + 12 / n);
    let f2 = pe2(c);
    if (f2 >= t) {
      const { days: p2 } = _e2(e, t, s), V = ze(l, f2, n, s);
      return p2 / V;
    }
    const { days: m2 } = _e2(e, f2, s), d2 = ze(l, f2, n, s);
    let _2 = m2 / d2;
    const C = ae(f2), E = ae(f2);
    for (E.setUTCMonth(E.getUTCMonth() + 12 / n); E < u; )
      C.setUTCMonth(C.getUTCMonth() + 12 / n), E.setUTCMonth(E.getUTCMonth() + 12 / n), _2 += 1;
    l = pe2(C), f2 = pe2(E);
    const { days: R } = _e2(l, t, s), b = ze(l, f2, n, s);
    return _2 += R / b, _2;
  }
};
var t0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 8);
    A(this, "maxParams", 9);
  }
  calculate(e, t, r, n, s, o, u, c) {
    let l = c != null ? c : y2.create(0);
    l.isNull() && (l = y2.create(0));
    const { isError: f2, errorObject: m2, variants: d2 } = Ye(e, t, r, n, s, o, u, l);
    if (f2)
      return m2;
    const [_2, C, E, R, b, p2, V, S2] = d2, M2 = H(_2);
    if (typeof M2 != "number")
      return M2;
    const D2 = H(C);
    if (typeof D2 != "number")
      return D2;
    const w = H(E);
    if (typeof w != "number")
      return w;
    const L = +R.getValue(), v = +b.getValue(), j2 = +p2.getValue(), k = Math.floor(+V.getValue()), G2 = Math.floor(+S2.getValue());
    if (Number.isNaN(L) || Number.isNaN(v) || Number.isNaN(j2) || Number.isNaN(k) || Number.isNaN(G2))
      return g2.create(h.VALUE);
    if (L < 0 || v <= 0 || j2 <= 0 || ![1, 2, 4].includes(k) || G2 < 0 || G2 > 4 || !this._validDate(D2, M2, w, k))
      return g2.create(h.NUM);
    const ne = this._getResult(M2, D2, w, L, v, j2, k, G2);
    return y2.create(ne);
  }
  _validDate(e, t, r, n) {
    return Math.floor(e) > Math.floor(t) && Math.floor(t) > Math.floor(r) && Ur(r, e, n);
  }
  _getResult(e, t, r, n, s, o, u, c) {
    const l = this._getCoupDate(t, r, u), f2 = this._getFrac(r, e, l, u, c), m2 = this._getFrac(r, t, l, u, c), d2 = this._getFrac(e, t, l, u, c);
    return (u * (o - s) + 100 * n * (m2 - f2)) / (d2 * s + 100 * n * f2 * d2 / u);
  }
  _getCoupDate(e, t, r) {
    const n = ae(e), s = ae(t);
    for (s.setUTCFullYear(n.getUTCFullYear()), s > n && s.setUTCFullYear(s.getUTCFullYear() - 1); s < n; )
      s.setUTCMonth(s.getUTCMonth() + 12 / r);
    return pe2(s);
  }
  _getFrac(e, t, r, n, s) {
    const o = ae(e), u = ae(t), c = ae(r);
    for (c.setUTCFullYear(o.getUTCFullYear()), c < o && c.setUTCFullYear(c.getUTCFullYear() + 1); c > o; )
      c.setUTCMonth(c.getUTCMonth() - 12 / n);
    let l = pe2(c);
    c.setUTCMonth(c.getUTCMonth() + 12 / n);
    let f2 = pe2(c);
    if (f2 >= t) {
      const { days: p2 } = _e2(e, t, s), V = ze(l, f2, n, s);
      return p2 / V;
    }
    const { days: m2 } = _e2(e, f2, s), d2 = ze(l, f2, n, s);
    let _2 = m2 / d2;
    const C = ae(f2), E = ae(f2);
    for (E.setUTCMonth(E.getUTCMonth() + 12 / n); E < u; )
      C.setUTCMonth(C.getUTCMonth() + 12 / n), E.setUTCMonth(E.getUTCMonth() + 12 / n), _2 += 1;
    l = pe2(C), f2 = pe2(E);
    const { days: R } = _e2(l, t, s), b = ze(l, f2, n, s);
    return _2 += R / b, _2;
  }
};
var r0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, t, g2.create(h.NA)), c = O(n, s, r, g2.create(h.NA)), l = o.map((f2, m2, d2) => {
      const _2 = u.get(m2, d2), C = c.get(m2, d2), { isError: E, errorObject: R, variants: b } = I2(f2, _2, C);
      if (E)
        return R;
      const [p2, V, S2] = b, M2 = +p2.getValue(), D2 = +V.getValue(), w = +S2.getValue();
      if (M2 <= -1)
        return g2.create(h.NUM);
      const L = (Math.log(w) - Math.log(D2)) / Math.log(1 + M2);
      return Number.isNaN(L) || !Number.isFinite(L) ? g2.create(h.NUM) : y2.create(L);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
};
var n0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 5);
    A(this, "needsLocale", true);
  }
  calculate(e, t, r, n, s) {
    const o = n != null ? n : y2.create(0), u = s != null ? s : y2.create(0), c = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1
    ), l = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1
    ), f2 = O(c, l, e, g2.create(h.NA)), m2 = O(c, l, t, g2.create(h.NA)), d2 = O(c, l, r, g2.create(h.NA)), _2 = O(c, l, o, g2.create(h.NA)), C = O(c, l, u, g2.create(h.NA)), E = f2.map((R, b, p2) => {
      const V = m2.get(b, p2), S2 = d2.get(b, p2), M2 = _2.get(b, p2), D2 = C.get(b, p2), { isError: w, errorObject: L, variants: v } = I2(R, V, S2, M2, D2);
      if (w)
        return L;
      const [j2, k, G2, ne, z] = v, $2 = +j2.getValue(), ge3 = +k.getValue(), Ce2 = +G2.getValue(), be = +ne.getValue(), Ne = +z.getValue();
      if ($2 <= -1)
        return g2.create(h.NUM);
      const he2 = nn($2, ge3, Ce2, be, Ne ? 1 : 0);
      return Number.isNaN(he2) || !Number.isFinite(he2) ? g2.create(h.NUM) : b === 0 && p2 === 0 ? y2.create(he2, et2(this.getLocale())) : y2.create(he2);
    });
    return c === 1 && l === 1 ? E.get(0, 0) : E;
  }
};
var s0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 6);
    A(this, "needsLocale", true);
  }
  calculate(e, t, r, n, s, o) {
    const u = s != null ? s : y2.create(0), c = o != null ? o : y2.create(0), l = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f2 = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), m2 = O(l, f2, e, g2.create(h.NA)), d2 = O(l, f2, t, g2.create(h.NA)), _2 = O(l, f2, r, g2.create(h.NA)), C = O(l, f2, n, g2.create(h.NA)), E = O(l, f2, u, g2.create(h.NA)), R = O(l, f2, c, g2.create(h.NA)), b = m2.map((p2, V, S2) => {
      const M2 = d2.get(V, S2), D2 = _2.get(V, S2), w = C.get(V, S2), L = E.get(V, S2), v = R.get(V, S2), { isError: j2, errorObject: k, variants: G2 } = I2(p2, M2, D2, w, L, v);
      if (j2)
        return k;
      const [ne, z, $2, ge3, Ce2, be] = G2, Ne = +ne.getValue(), he2 = +z.getValue(), Be2 = +$2.getValue(), Ct = +ge3.getValue(), jt = +Ce2.getValue(), Ut = +be.getValue();
      if (he2 < 1 || Math.floor(he2) > Math.ceil(Be2) || he2 - Be2 >= 1)
        return g2.create(h.NUM);
      const ct2 = nn(Ne, Be2, Ct, jt, Ut ? 1 : 0) - cc(Ne, he2, Be2, Ct, jt, Ut ? 1 : 0);
      return Number.isNaN(ct2) || !Number.isFinite(ct2) ? g2.create(h.NUM) : V === 0 && S2 === 0 ? y2.create(ct2, et2(this.getLocale())) : y2.create(ct2);
    });
    return l === 1 && f2 === 1 ? b.get(0, 0) : b;
  }
};
var a0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 6);
    A(this, "maxParams", 7);
  }
  calculate(e, t, r, n, s, o, u) {
    let c = u != null ? u : y2.create(0);
    c.isNull() && (c = y2.create(0));
    const { isError: l, errorObject: f2, variants: m2 } = Ye(e, t, r, n, s, o, c);
    if (l)
      return f2;
    const [d2, _2, C, E, R, b, p2] = m2, V = H(d2);
    if (typeof V != "number")
      return V;
    const S2 = H(_2);
    if (typeof S2 != "number")
      return S2;
    const M2 = +C.getValue(), D2 = +E.getValue(), w = +R.getValue(), L = Math.floor(+b.getValue()), v = Math.floor(+p2.getValue());
    if (Number.isNaN(M2) || Number.isNaN(D2) || Number.isNaN(w) || Number.isNaN(L) || Number.isNaN(v))
      return g2.create(h.VALUE);
    if (M2 < 0 || D2 < 0 || w <= 0 || ![1, 2, 4].includes(L) || v < 0 || v > 4 || V >= S2 || !Ur(V, S2, L))
      return g2.create(h.NUM);
    const j2 = pn(V, S2, M2, D2, w, L, v);
    return y2.create(j2);
  }
};
var i0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    let o = s != null ? s : y2.create(0);
    o.isNull() && (o = y2.create(0));
    const { isError: u, errorObject: c, variants: l } = Ye(e, t, r, n, o);
    if (u)
      return c;
    const [f2, m2, d2, _2, C] = l, E = H(f2);
    if (typeof E != "number")
      return E;
    const R = H(m2);
    if (typeof R != "number")
      return R;
    const b = +d2.getValue(), p2 = +_2.getValue(), V = Math.floor(+C.getValue());
    if (Number.isNaN(b) || Number.isNaN(p2) || Number.isNaN(V))
      return g2.create(h.VALUE);
    if (b <= 0 || p2 <= 0 || V < 0 || V > 4 || E >= R)
      return g2.create(h.NUM);
    const { days: S2, yearDays: M2 } = _e2(E, R, V), D2 = p2 - b * p2 * S2 / M2;
    return y2.create(D2);
  }
};
var o0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 5);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    let u = o != null ? o : y2.create(0);
    u.isNull() && (u = y2.create(0));
    const { isError: c, errorObject: l, variants: f2 } = Ye(e, t, r, n, s, u);
    if (c)
      return l;
    const [m2, d2, _2, C, E, R] = f2, b = H(m2);
    if (typeof b != "number")
      return b;
    const p2 = H(d2);
    if (typeof p2 != "number")
      return p2;
    const V = H(_2);
    if (typeof V != "number")
      return V;
    const S2 = +C.getValue(), M2 = +E.getValue(), D2 = Math.floor(+R.getValue());
    if (Number.isNaN(S2) || Number.isNaN(M2) || Number.isNaN(D2))
      return g2.create(h.VALUE);
    const w = this._getDateCorrectOrder(p2, b, V);
    if (S2 < 0 || M2 < 0 || D2 < 0 || D2 > 4 || !w)
      return g2.create(h.NUM);
    const L = ic(b, D2), { days: v } = _e2(b, p2, D2), { days: j2 } = _e2(V, p2, D2), { days: k } = _e2(V, b, D2), G2 = (100 + j2 / L * S2 * 100) / (1 + v / L * M2) - k / L * S2 * 100;
    return y2.create(G2);
  }
  _getDateCorrectOrder(e, t, r) {
    return Math.floor(e) > Math.floor(t) && Math.floor(t) > Math.floor(r);
  }
};
var u0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 5);
    A(this, "needsLocale", true);
  }
  calculate(e, t, r, n, s) {
    const o = n != null ? n : y2.create(0), u = s != null ? s : y2.create(0), c = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1
    ), l = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1
    ), f2 = O(c, l, e, g2.create(h.NA)), m2 = O(c, l, t, g2.create(h.NA)), d2 = O(c, l, r, g2.create(h.NA)), _2 = O(c, l, o, g2.create(h.NA)), C = O(c, l, u, g2.create(h.NA)), E = f2.map((R, b, p2) => {
      const V = m2.get(b, p2), S2 = d2.get(b, p2), M2 = _2.get(b, p2), D2 = C.get(b, p2), { isError: w, errorObject: L, variants: v } = I2(R, V, S2, M2, D2);
      if (w)
        return L;
      const [j2, k, G2, ne, z] = v, $2 = +j2.getValue(), ge3 = +k.getValue(), Ce2 = +G2.getValue(), be = +ne.getValue();
      let Ne = +z.getValue();
      Ne = Ne ? 1 : 0;
      const he2 = $2 === 0 ? -Ce2 * ge3 - be : ((1 - __pow(1 + $2, ge3)) / $2 * Ce2 * (1 + $2 * Ne) - be) / __pow(1 + $2, ge3);
      return Number.isNaN(he2) || !Number.isFinite(he2) ? g2.create(h.NUM) : b === 0 && p2 === 0 ? y2.create(he2, et2(this.getLocale())) : y2.create(he2);
    });
    return c === 1 && l === 1 ? E.get(0, 0) : E;
  }
};
var c0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    const u = n != null ? n : y2.create(0), c = s != null ? s : y2.create(0), l = o != null ? o : y2.create(0.1), f2 = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1,
      l.isArray() ? l.getRowCount() : 1
    ), m2 = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1,
      l.isArray() ? l.getColumnCount() : 1
    ), d2 = O(f2, m2, e, g2.create(h.NA)), _2 = O(f2, m2, t, g2.create(h.NA)), C = O(f2, m2, r, g2.create(h.NA)), E = O(f2, m2, u, g2.create(h.NA)), R = O(f2, m2, c, g2.create(h.NA)), b = O(f2, m2, l, g2.create(h.NA)), p2 = d2.map((V, S2, M2) => {
      const D2 = _2.get(S2, M2), w = C.get(S2, M2), L = E.get(S2, M2), v = R.get(S2, M2), j2 = b.get(S2, M2), { isError: k, errorObject: G2, variants: ne } = I2(V, D2, w, L, v, j2);
      if (k)
        return G2;
      const [z, $2, ge3, Ce2, be, Ne] = ne, he2 = +z.getValue(), Be2 = +$2.getValue(), Ct = +ge3.getValue(), jt = +Ce2.getValue();
      let Ut = +be.getValue();
      const ct2 = +Ne.getValue();
      if (Ut = Ut ? 1 : 0, he2 <= 0)
        return g2.create(h.NUM);
      const pc = Be2 >= 0 && Ct >= 0 && jt >= 0, Nc = Be2 <= 0 && Ct <= 0 && jt <= 0;
      return pc || Nc ? g2.create(h.NUM) : this._getResult(he2, Be2, Ct, jt, Ut, ct2, S2, M2);
    });
    return f2 === 1 && m2 === 1 ? p2.get(0, 0) : p2;
  }
  _getResult(e, t, r, n, s, o, u, c) {
    if (Math.abs(t) < 1e-14)
      return this._computeSimpleGrowthRate(e, r, n, u, c);
    let m2 = o, d2 = Number.POSITIVE_INFINITY;
    for (let _2 = 0; _2 < 100; _2++) {
      if (m2 <= -1)
        return g2.create(h.NUM);
      const { value: C, derivative: E } = this._evaluateRateFunction(
        m2,
        e,
        t,
        r,
        n,
        s,
        1e-10
      ), R = Math.abs(C);
      if (R < 1e-10 || Math.abs(E) < 1e-14)
        break;
      const b = this._getAdaptiveDampedStep(C, E, R, d2);
      m2 -= b, d2 = R;
    }
    return !Number.isFinite(m2) || m2 <= -1 ? g2.create(h.NUM) : y2.create(m2, u === 0 && c === 0 ? "0%" : void 0);
  }
  _computeSimpleGrowthRate(e, t, r, n, s) {
    if (Math.sign(t) === Math.sign(r))
      return g2.create(h.NUM);
    const o = __pow(r / -t, 1 / e) - 1;
    return y2.create(o, n === 0 && s === 0 ? "0%" : void 0);
  }
  _evaluateRateFunction(e, t, r, n, s, o, u) {
    let c, l, f2;
    if (Math.abs(e) < u)
      c = n * (1 + t * e) + r * (1 + e * o) * t + s, l = n * t + r * o * t;
    else {
      f2 = __pow(1 + e, t), c = n * f2 + r * (1 / e + o) * (f2 - 1) + s;
      const m2 = t * __pow(1 + e, t - 1);
      l = n * m2 + r * (1 / e + o) * m2 + r * (-1 / (e * e)) * (f2 - 1);
    }
    return { value: c, derivative: l };
  }
  _getAdaptiveDampedStep(e, t, r, n) {
    const s = e / t;
    return r > 1e-3 || r >= n * 0.9 ? Math.max(Math.min(s, 5), -5) : Math.max(Math.min(s, 0.5), -0.5);
  }
};
var l0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    let o = s != null ? s : y2.create(0);
    o.isNull() && (o = y2.create(0));
    const { isError: u, errorObject: c, variants: l } = Ye(e, t, r, n, o);
    if (u)
      return c;
    const [f2, m2, d2, _2, C] = l, E = H(f2);
    if (typeof E != "number")
      return E;
    const R = H(m2);
    if (typeof R != "number")
      return R;
    const b = +d2.getValue(), p2 = +_2.getValue(), V = Math.floor(+C.getValue());
    if (Number.isNaN(b) || Number.isNaN(p2) || Number.isNaN(V))
      return g2.create(h.VALUE);
    if (b <= 0 || p2 <= 0 || V < 0 || V > 4 || E >= R)
      return g2.create(h.NUM);
    const { days: S2, yearDays: M2 } = _e2(E, R, V), D2 = b / (1 - p2 * S2 / M2);
    return D2 < 0 ? g2.create(h.NUM) : y2.create(D2);
  }
};
var f0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, t, g2.create(h.NA)), c = O(n, s, r, g2.create(h.NA)), l = o.map((f2, m2, d2) => {
      const _2 = u.get(m2, d2), C = c.get(m2, d2), { isError: E, errorObject: R, variants: b } = I2(f2, _2, C);
      if (E)
        return R;
      const [p2, V, S2] = b, M2 = +p2.getValue(), D2 = +V.getValue(), w = +S2.getValue();
      if (M2 <= 0)
        return g2.create(h.NUM);
      if (D2 === 0 && w === 0)
        return y2.create(0);
      const L = __pow(w / D2, 1 / M2) - 1;
      return Number.isNaN(L) || !Number.isFinite(L) || w / D2 < 0 ? g2.create(h.NUM) : y2.create(L);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
};
var m0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
    A(this, "needsLocale", true);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, t, g2.create(h.NA)), c = O(n, s, r, g2.create(h.NA)), l = o.map((f2, m2, d2) => {
      const _2 = u.get(m2, d2), C = c.get(m2, d2);
      if (_2.isError())
        return _2;
      if (C.isError())
        return C;
      const E = +f2.getValue(), R = +_2.getValue(), b = +C.getValue();
      if (Number.isNaN(E) || Number.isNaN(R) || Number.isNaN(b))
        return g2.create(h.VALUE);
      if (b === 0)
        return g2.create(h.DIV_BY_ZERO);
      const p2 = (E - R) / b;
      return m2 === 0 && d2 === 0 ? y2.create(p2, et2(this.getLocale())) : y2.create(p2);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
};
var h0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
    A(this, "needsLocale", true);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g2.create(h.NA)), c = O(s, o, t, g2.create(h.NA)), l = O(s, o, r, g2.create(h.NA)), f2 = O(s, o, n, g2.create(h.NA)), m2 = u.map((d2, _2, C) => {
      const E = c.get(_2, C), R = l.get(_2, C), b = f2.get(_2, C);
      if (E.isError())
        return E;
      if (R.isError())
        return R;
      if (b.isError())
        return b;
      const p2 = +d2.getValue(), V = +E.getValue(), S2 = +R.getValue(), M2 = +b.getValue();
      if (Number.isNaN(p2) || Number.isNaN(V) || Number.isNaN(S2) || Number.isNaN(M2))
        return g2.create(h.VALUE);
      if (V < 0 || S2 <= 0 || M2 > S2)
        return g2.create(h.NUM);
      const D2 = (p2 - V) * (S2 - M2 + 1) * 2 / (S2 * (S2 + 1));
      return _2 === 0 && C === 0 ? y2.create(D2, et2(this.getLocale())) : y2.create(D2);
    });
    return s === 1 && o === 1 ? m2.get(0, 0) : m2;
  }
};
var g0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = Ye(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f2 = H(u);
    if (typeof f2 != "number")
      return f2;
    const m2 = H(c);
    if (typeof m2 != "number")
      return m2;
    const d2 = +l.getValue();
    if (Number.isNaN(d2))
      return g2.create(h.VALUE);
    if (d2 <= 0 || f2 >= m2)
      return g2.create(h.NUM);
    const _2 = Math.floor(m2) - Math.floor(f2), E = ae(f2).getUTCFullYear(), R = _s2(E);
    if (_2 > R)
      return g2.create(h.NUM);
    let b = 365 * d2 / (360 - d2 * _2);
    if (_2 > 182) {
      const p2 = 100 * (1 - d2 * _2 / 360), V = _2 / 365;
      if (b = (-V + Math.sqrt(V * V - (V * 2 - 1) * (1 - 100 / p2))) / (V - 0.5), Number.isNaN(b))
        return g2.create(h.NUM);
    }
    return b < 0 ? g2.create(h.NUM) : y2.create(b);
  }
};
var d0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
    A(this, "needsLocale", true);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = Ye(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f2 = H(u);
    if (typeof f2 != "number")
      return f2;
    const m2 = H(c);
    if (typeof m2 != "number")
      return m2;
    const d2 = +l.getValue();
    if (Number.isNaN(d2))
      return g2.create(h.VALUE);
    if (d2 <= 0 || f2 >= m2)
      return g2.create(h.NUM);
    const _2 = Math.floor(m2) - Math.floor(f2), E = ae(f2).getUTCFullYear(), R = _s2(E);
    if (_2 > R)
      return g2.create(h.NUM);
    const b = 100 * (1 - d2 * _2 / 360);
    return b < 0 ? g2.create(h.NUM) : y2.create(b, et2(this.getLocale()));
  }
};
var C0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = Ye(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f2 = H(u);
    if (typeof f2 != "number")
      return f2;
    const m2 = H(c);
    if (typeof m2 != "number")
      return m2;
    const d2 = +l.getValue();
    if (Number.isNaN(d2))
      return g2.create(h.VALUE);
    if (d2 <= 0 || f2 >= m2)
      return g2.create(h.NUM);
    const _2 = Math.floor(m2) - Math.floor(f2), E = ae(f2).getUTCFullYear(), R = _s2(E);
    if (_2 > R)
      return g2.create(h.NUM);
    const b = (100 - d2) / d2 * 360 / _2;
    return y2.create(b);
  }
};
var _0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 5);
    A(this, "maxParams", 7);
    A(this, "needsLocale", true);
  }
  calculate(e, t, r, n, s, o, u) {
    let c = o != null ? o : y2.create(2);
    c.isNull() && (c = y2.create(2));
    let l = u != null ? u : T.create(false);
    l.isNull() && (l = T.create(false));
    const f2 = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1,
      l.isArray() ? l.getRowCount() : 1
    ), m2 = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1,
      l.isArray() ? l.getColumnCount() : 1
    ), d2 = O(f2, m2, e, g2.create(h.NA)), _2 = O(f2, m2, t, g2.create(h.NA)), C = O(f2, m2, r, g2.create(h.NA)), E = O(f2, m2, n, g2.create(h.NA)), R = O(f2, m2, s, g2.create(h.NA)), b = O(f2, m2, c, g2.create(h.NA)), p2 = O(f2, m2, l, g2.create(h.NA));
    return this._getResultArray(
      d2,
      _2,
      C,
      E,
      R,
      b,
      p2,
      f2,
      m2
    );
  }
  _getResultArray(e, t, r, n, s, o, u, c, l) {
    const f2 = e.map((m2, d2, _2) => {
      const C = t.get(d2, _2), E = r.get(d2, _2), R = n.get(d2, _2), b = s.get(d2, _2), p2 = o.get(d2, _2), V = u.get(d2, _2), { isError: S2, errorObject: M2, variants: D2 } = I2(m2, C, E, R, b, p2, V);
      if (S2)
        return M2;
      const [w, L, v, j2, k, G2, ne] = D2, z = +w.getValue(), $2 = +L.getValue(), ge3 = +v.getValue(), Ce2 = +j2.getValue(), be = +k.getValue(), Ne = +G2.getValue(), he2 = +ne.getValue();
      if (z < 0 || $2 < 0 || ge3 < 0 || Ce2 < 0 || be < 0 || be > ge3 || Ce2 > be || Ne < 0)
        return g2.create(h.NUM);
      if (ge3 === 0 && Ce2 === 0 && be === 0)
        return g2.create(h.DIV_BY_ZERO);
      const Be2 = this._getResult(z, $2, ge3, Ce2, be, Ne, he2);
      return d2 === 0 && _2 === 0 ? y2.create(Be2, et2(this.getLocale())) : y2.create(Be2);
    });
    return c === 1 && l === 1 ? f2.get(0, 0) : f2;
  }
  _getResult(e, t, r, n, s, o, u) {
    const c = Math.floor(n), l = Math.ceil(s);
    let f2 = 0;
    if (e < t) {
      if (n >= 1 || u)
        return f2;
      const m2 = Math.abs(e - t);
      return f2 = m2 * (s - n) > m2 ? m2 : m2 * (s - n), -f2;
    }
    if (u)
      for (let m2 = c + 1; m2 <= l; m2++) {
        let d2 = ma(e, t, r, m2, o);
        m2 === c + 1 ? d2 *= Math.min(s, c + 1) - n : m2 === l && (d2 *= s + 1 - l), f2 += d2;
      }
    else {
      const m2 = e - this._getVdb(e, t, r, r, n, o);
      f2 = this._getVdb(m2, t, r, r - n, s - n, o);
    }
    return f2;
  }
  _getVdb(e, t, r, n, s, o) {
    const u = Math.ceil(s);
    let c = 0, l = e - t, f2 = 0, m2 = 0, d2 = false;
    for (let _2 = 1; _2 <= u; _2++) {
      if (d2)
        m2 = f2;
      else {
        const C = ma(e, t, r, _2, o);
        f2 = l / (n - (_2 - 1)), f2 > C ? (m2 = f2, d2 = true) : (m2 = C, l -= C);
      }
      _2 === u && (m2 *= s + 1 - u), c += m2;
    }
    return c;
  }
};
var A0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    if (e.isNull() || t.isNull())
      return g2.create(h.NA);
    const { isError: n, errorObejct: s, _values: o, _dates: u } = this._checkErrors(e, t);
    if (n)
      return s;
    let c = r != null ? r : y2.create(0.1);
    c.isNull() && (c = y2.create(0.1));
    const { isError: l, errorObject: f2, variants: m2 } = W2(c);
    if (l)
      return f2;
    const [d2] = m2, _2 = +d2.getValue();
    if (Number.isNaN(_2))
      return g2.create(h.VALUE);
    const { positive: C, negative: E } = this._checkValues(o);
    if (!C || !E || (o == null ? void 0 : o.length) !== (u == null ? void 0 : u.length) || _2 < 0)
      return g2.create(h.NUM);
    const R = Ja(_2, (b) => this._iterF(o, u, b));
    return typeof R != "number" ? R : y2.create(R);
  }
  _checkErrors(e, t) {
    if (e.isError())
      return {
        isError: true,
        errorObejct: e
      };
    if (t.isError())
      return {
        isError: true,
        errorObejct: t
      };
    const { isError: r, errorObejct: n, _values: s } = this._checkErrorValues(e);
    if (r)
      return {
        isError: r,
        errorObejct: n
      };
    const { isError: o, errorObejct: u, _dates: c } = this._checkErrorDates(t);
    return o ? {
      isError: o,
      errorObejct: u
    } : {
      isError: false,
      _values: s,
      _dates: c
    };
  }
  _checkErrorValues(e) {
    const t = [];
    if (e.isArray()) {
      let r = false, n = g2.create(h.VALUE);
      return e.iterator((s) => {
        const o = s;
        if (o.isError())
          return r = true, n = o, false;
        if (o.isBoolean())
          return r = true, n = g2.create(h.VALUE), false;
        const u = +o.getValue();
        if (Number.isNaN(u))
          return r = true, n = g2.create(h.VALUE), false;
        t.push(u);
      }), r ? {
        isError: r,
        errorObejct: n
      } : t.length <= 1 ? {
        isError: true,
        errorObejct: g2.create(h.NA)
      } : {
        isError: r,
        _values: t
      };
    } else {
      const r = e.getValue();
      return e.isBoolean() || e.isString() && !s1(r) ? {
        isError: true,
        errorObejct: g2.create(h.VALUE)
      } : {
        isError: true,
        errorObejct: g2.create(h.NA)
      };
    }
  }
  _checkErrorDates(e) {
    const t = [];
    if (e.isArray()) {
      let r = false, n = g2.create(h.VALUE);
      return e.iterator((s) => {
        if (s != null && s.isError())
          return r = true, n = s, false;
        if (s != null && s.isBoolean())
          return r = true, n = g2.create(h.VALUE), false;
        const o = +s.getValue();
        if (Number.isNaN(o))
          return r = true, n = g2.create(h.VALUE), false;
        if (o < 0)
          return r = true, n = g2.create(h.NUM), false;
        t.push(Math.floor(o));
      }), r ? {
        isError: r,
        errorObejct: n
      } : t.length <= 1 ? {
        isError: true,
        errorObejct: g2.create(h.NA)
      } : {
        isError: r,
        _dates: t
      };
    } else {
      const r = e.getValue();
      return e.isBoolean() || e.isString() && !s1(r) ? {
        isError: true,
        errorObejct: g2.create(h.VALUE)
      } : +r < 0 ? {
        isError: true,
        errorObejct: g2.create(h.NUM)
      } : {
        isError: true,
        errorObejct: g2.create(h.NA)
      };
    }
  }
  _checkValues(e) {
    let t = false, r = false;
    for (let n = 0; n < e.length; n++)
      e[n] > 0 && (t = true), e[n] < 0 && (r = true);
    return {
      positive: t,
      negative: r
    };
  }
  _iterF(e, t, r) {
    return e.reduce((n, s, o) => n + s / __pow(1 + r, (t[o] - t[0]) / 365), 0);
  }
};
var E0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    if (e.isNull() || t.isNull() || r.isNull())
      return g2.create(h.NA);
    const { isError: n, errorObject: s, variants: o } = W2(e);
    if (n)
      return s;
    const [u] = o, c = +u.getValue();
    if (Number.isNaN(c))
      return g2.create(h.VALUE);
    let { isError: l, errorObejct: f2, _values: m2, _dates: d2 } = this._checkErrors(t, r);
    if (l)
      return f2;
    if (m2 = m2, d2 = d2, c < 0 || m2.length !== d2.length)
      return g2.create(h.NUM);
    let _2 = 0;
    const C = d2[0];
    for (let E = 0; E < d2.length; E++) {
      const R = d2[E], b = m2[E];
      _2 += b / __pow(1 + c, (R - C) / 365);
    }
    return y2.create(_2);
  }
  _checkErrors(e, t) {
    if (e.isError())
      return {
        isError: true,
        errorObejct: e
      };
    if (t.isError())
      return {
        isError: true,
        errorObejct: t
      };
    const { isError: r, errorObejct: n, _values: s } = this._checkErrorValues(e);
    if (r)
      return {
        isError: r,
        errorObejct: n
      };
    const { isError: o, errorObejct: u, _dates: c } = this._checkErrorDates(t);
    return o ? {
      isError: o,
      errorObejct: u
    } : {
      isError: false,
      _values: s,
      _dates: c
    };
  }
  _checkErrorValues(e) {
    const t = [];
    if (e.isArray()) {
      let r = false, n = g2.create(h.VALUE);
      return e.iterator((s) => {
        const o = s;
        if (o.isError())
          return r = true, n = o, false;
        if (o.isNull() || o.isBoolean() || o.isString() && o.getValue() === "")
          return r = true, n = g2.create(h.VALUE), false;
        const u = +o.getValue();
        if (Number.isNaN(u))
          return r = true, n = g2.create(h.VALUE), false;
        t.push(u);
      }), r ? {
        isError: r,
        errorObejct: n
      } : {
        isError: r,
        _values: t
      };
    } else {
      if (e.isError())
        return {
          isError: true,
          errorObejct: e
        };
      if (e.isNull() || e.isBoolean())
        return {
          isError: true,
          errorObejct: g2.create(h.VALUE)
        };
      const r = +e.getValue();
      return Number.isNaN(r) ? {
        isError: true,
        errorObejct: g2.create(h.VALUE)
      } : {
        isError: false,
        _values: [r]
      };
    }
  }
  _checkErrorDates(e) {
    const t = [];
    if (e.isArray()) {
      let r = false, n = g2.create(h.VALUE);
      return e.iterator((s) => {
        const o = s;
        if (o.isError())
          return r = true, n = o, false;
        if (o.isNull() || o.isBoolean())
          return r = true, n = g2.create(h.VALUE), false;
        const u = +o.getValue();
        if (Number.isNaN(u))
          return r = true, n = g2.create(h.VALUE), false;
        if (u < 0)
          return r = true, n = g2.create(h.NUM), false;
        t.push(Math.floor(u));
      }), r ? {
        isError: r,
        errorObejct: n
      } : {
        isError: r,
        _dates: t
      };
    } else {
      if (e.isError())
        return {
          isError: true,
          errorObejct: e
        };
      if (e.isNull() || e.isBoolean())
        return {
          isError: true,
          errorObejct: g2.create(h.VALUE)
        };
      const r = +e.getValue();
      return Number.isNaN(r) ? {
        isError: true,
        errorObejct: g2.create(h.VALUE)
      } : +r < 0 ? {
        isError: true,
        errorObejct: g2.create(h.NUM)
      } : {
        isError: false,
        _dates: [Math.floor(r)]
      };
    }
  }
};
var R0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 6);
    A(this, "maxParams", 7);
  }
  calculate(e, t, r, n, s, o, u) {
    let c = u != null ? u : y2.create(0);
    c.isNull() && (c = y2.create(0));
    const { isError: l, errorObject: f2, variants: m2 } = Ye(e, t, r, n, s, o, c);
    if (l)
      return f2;
    const [d2, _2, C, E, R, b, p2] = m2, V = H(d2);
    if (typeof V != "number")
      return V;
    const S2 = H(_2);
    if (typeof S2 != "number")
      return S2;
    const M2 = +C.getValue(), D2 = +E.getValue(), w = +R.getValue(), L = Math.floor(+b.getValue()), v = Math.floor(+p2.getValue());
    if (Number.isNaN(M2) || Number.isNaN(D2) || Number.isNaN(w) || Number.isNaN(L) || Number.isNaN(v))
      return g2.create(h.VALUE);
    if (M2 < 0 || D2 <= 0 || w <= 0 || ![1, 2, 4].includes(L) || v < 0 || v > 4 || V >= S2 || !Ur(V, S2, L))
      return g2.create(h.NUM);
    const j2 = this._getResult(V, S2, M2, D2, w, L, v);
    return y2.create(j2);
  }
  _getResult(e, t, r, n, s, o, u) {
    if (ur(e, t, o) > 1) {
      let E = r || 0.01, R = pn(e, t, r, E, s, o, u), b = R - n;
      for (let p2 = 0; p2 < 100 && Math.abs(b) > 1e-7; p2++)
        R = pn(e, t, r, 1.01 * E, s, o, u), E += -b / (R - n - b) * E * 0.01, b = pn(e, t, r, E, s, o, u) - n;
      return E;
    }
    const l = As(e, t, o, u), f2 = ze(e, t, o, u), { days: m2 } = _e2(e, t, u), d2 = n / 100 + l / f2 * r / o;
    return (s / 100 + r / o - d2) / d2 * o * f2 / m2;
  }
};
var b0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    let o = s != null ? s : y2.create(0);
    o.isNull() && (o = y2.create(0));
    const { isError: u, errorObject: c, variants: l } = Ye(e, t, r, n, o);
    if (u)
      return c;
    const [f2, m2, d2, _2, C] = l, E = H(f2);
    if (typeof E != "number")
      return E;
    const R = H(m2);
    if (typeof R != "number")
      return R;
    const b = +d2.getValue(), p2 = +_2.getValue(), V = Math.floor(+C.getValue());
    if (Number.isNaN(b) || Number.isNaN(p2) || Number.isNaN(V))
      return g2.create(h.VALUE);
    if (b <= 0 || p2 <= 0 || V < 0 || V > 4 || E >= R)
      return g2.create(h.NUM);
    const { days: S2, yearDays: M2 } = _e2(E, R, V), D2 = (p2 / b - 1) / (S2 / M2);
    return y2.create(D2);
  }
};
var y0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 5);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    let u = o != null ? o : y2.create(0);
    u.isNull() && (u = y2.create(0));
    const { isError: c, errorObject: l, variants: f2 } = Ye(e, t, r, n, s, u);
    if (c)
      return l;
    const [m2, d2, _2, C, E, R] = f2, b = H(m2);
    if (typeof b != "number")
      return b;
    const p2 = H(d2);
    if (typeof p2 != "number")
      return p2;
    const V = H(_2);
    if (typeof V != "number")
      return V;
    const S2 = +C.getValue(), M2 = +E.getValue(), D2 = Math.floor(+R.getValue());
    if (Number.isNaN(S2) || Number.isNaN(M2) || Number.isNaN(D2))
      return g2.create(h.VALUE);
    const w = this._getDateCorrectOrder(p2, b, V);
    if (S2 < 0 || M2 <= 0 || D2 < 0 || D2 > 4 || !w)
      return g2.create(h.NUM);
    const L = ic(b, D2), { days: v } = _e2(b, p2, D2), { days: j2 } = _e2(V, p2, D2), { days: k } = _e2(V, b, D2), G2 = ((1 + j2 / L * S2) / (M2 / 100 + k / L * S2) - 1) / (v / L);
    return y2.create(G2);
  }
  _getDateCorrectOrder(e, t, r) {
    return Math.floor(e) > Math.floor(t) && Math.floor(t) > Math.floor(r);
  }
};
var p0 = [
  [pd, ee.ACCRINT],
  [Nd, ee.ACCRINTM],
  [Vd, ee.AMORLINC],
  [Od, ee.COUPDAYBS],
  [Sd, ee.COUPDAYS],
  [Md, ee.COUPDAYSNC],
  [Dd, ee.COUPNCD],
  [wd, ee.COUPNUM],
  [Ld, ee.COUPPCD],
  [Pd, ee.CUMIPMT],
  [xd, ee.CUMPRINC],
  [jd, ee.DB],
  [Ud, ee.DDB],
  [vd, ee.DISC],
  [Td, ee.DOLLARDE],
  [Id, ee.DOLLARFR],
  [Bd, ee.DURATION],
  [Fd, ee.EFFECT],
  [kd, ee.FV],
  [$d, ee.FVSCHEDULE],
  [Yd, ee.INTRATE],
  [Hd, ee.IPMT],
  [Gd, ee.IRR],
  [Wd, ee.ISPMT],
  [Qd, ee.MDURATION],
  [qd, ee.MIRR],
  [Xd, ee.NOMINAL],
  [Kd, ee.NPER],
  [Zd, ee.NPV],
  [zd, ee.ODDFPRICE],
  [Jd, ee.ODDFYIELD],
  [e0, ee.ODDLPRICE],
  [t0, ee.ODDLYIELD],
  [r0, ee.PDURATION],
  [n0, ee.PMT],
  [s0, ee.PPMT],
  [a0, ee.PRICE],
  [i0, ee.PRICEDISC],
  [o0, ee.PRICEMAT],
  [u0, ee.PV],
  [c0, ee.RATE],
  [l0, ee.RECEIVED],
  [f0, ee.RRI],
  [m0, ee.SLN],
  [h0, ee.SYD],
  [g0, ee.TBILLEQ],
  [d0, ee.TBILLPRICE],
  [C0, ee.TBILLYIELD],
  [_0, ee.VDB],
  [A0, ee.XIRR],
  [E0, ee.XNPV],
  [R0, ee.YIELD],
  [b0, ee.YIELDDISC],
  [y0, ee.YIELDMAT]
];
var N0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "needsReferenceObject", true);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (r.isError())
      return r;
    if (r.isReferenceObject() && (r = r.toArrayValueObject()), r.isArray()) {
      const n = r.getRowCount(), s = r.getColumnCount();
      if (n === 1 && s === 1) {
        const o = r.get(0, 0);
        return this._handleSingleObject(o, t);
      }
      return r.map((o) => o.isError() ? o : this._handleSingleObject(o, t, true));
    }
    return this._handleSingleObject(r, t);
  }
  _handleSingleObject(e, t, r = false) {
    let n = t;
    if (n.isError())
      return n;
    if (!n.isReferenceObject())
      return g2.create(h.NA);
    const s = n.getCurrentActiveSheetData(), { columnData: o, defaultColumnWidth: u } = s;
    n = n.toArrayValueObject();
    const c = n.getCurrentRow(), l = n.getCurrentColumn();
    n = n.getFirstCell();
    const f2 = `${e.getValue()}`;
    let m2;
    switch (f2.toLocaleLowerCase()) {
      case "address":
        return U2.create(`$${Z.chatAtABC(l)}$${c + 1}`);
      case "col":
        return y2.create(l + 1);
      case "color":
        return y2.create(0);
      case "contents":
        return n;
      case "filename":
        return g2.create(h.VALUE);
      case "format":
        return U2.create("G");
      case "parentheses":
        return y2.create(0);
      case "prefix":
        return U2.create("");
      case "protect":
        return y2.create(1);
      case "row":
        return y2.create(c + 1);
      case "type":
        return m2 = "v", n.isNull() && (m2 = "b"), n.isString() && (m2 = "l"), U2.create(m2);
      case "width":
        return this._getWidthResult(o, u, l, r);
      default:
        return g2.create(h.VALUE);
    }
  }
  _getWidthResult(e, t, r, n) {
    var u;
    let s = (u = e[r]) == null ? void 0 : u.w;
    if (!s && s !== 0 && (s = t), n)
      return y2.create(s);
    const o = [[s, s === t]];
    return K2.createByArray(o);
  }
};
var V0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
    A(this, "_errorTypeValueMap", /* @__PURE__ */ new Map([
      [h.NULL, 1],
      [h.DIV_BY_ZERO, 2],
      [h.VALUE, 3],
      [h.REF, 4],
      [h.NAME, 5],
      [h.NUM, 6],
      [h.NA, 7],
      [h.CONNECT, 8],
      [h.CALC, 14]
    ]));
  }
  calculate(e) {
    return e.isArray() ? e.mapValue((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const t = e.getValue(), r = this._errorTypeValueMap.get(t);
    return r ? y2.create(r) : g2.create(h.NA);
  }
};
var Ve2 = ((a2) => (a2.CELL = "CELL", a2.ERROR_TYPE = "ERROR.TYPE", a2.INFO = "INFO", a2.ISBETWEEN = "ISBETWEEN", a2.ISBLANK = "ISBLANK", a2.ISDATE = "ISDATE", a2.ISEMAIL = "ISEMAIL", a2.ISERR = "ISERR", a2.ISERROR = "ISERROR", a2.ISEVEN = "ISEVEN", a2.ISFORMULA = "ISFORMULA", a2.ISLOGICAL = "ISLOGICAL", a2.ISNA = "ISNA", a2.ISNONTEXT = "ISNONTEXT", a2.ISNUMBER = "ISNUMBER", a2.ISODD = "ISODD", a2.ISOMITTED = "ISOMITTED", a2.ISREF = "ISREF", a2.ISTEXT = "ISTEXT", a2.ISURL = "ISURL", a2.N = "N", a2.NA = "NA", a2.SHEET = "SHEET", a2.SHEETS = "SHEETS", a2.TYPE = "TYPE", a2))(Ve2 || {});
var O0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    const o = n != null ? n : T.create(true), u = s != null ? s : T.create(true), { isError: c, errorObject: l, variants: f2 } = zr(e, t, r, o, u);
    if (c)
      return l;
    const [m2, d2, _2, C, E] = f2;
    if (C.isString() || E.isString())
      return g2.create(h.VALUE);
    if (d2.compare(_2, ">").getValue() === true)
      return g2.create(h.NUM);
    const b = +C.getValue(), p2 = +E.getValue(), V = b ? ">=" : ">", S2 = p2 ? "<=" : "<";
    return m2.compare(d2, V).getValue() === false || m2.compare(_2, S2).getValue() === false ? T.create(false) : T.create(true);
  }
};
var S0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isNull() ? T.create(true) : e.isArray() ? e.mapValue((t) => t.isNull() ? T.create(true) : T.create(false)) : T.create(false);
  }
};
var M0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    if (t.isArray()) {
      const r = t.getRowCount(), n = t.getColumnCount();
      if (r > 1 || n > 1)
        return g2.create(h.VALUE);
      t = t.get(0, 0);
    }
    return t.isError() ? t : t.isNumber() && t.getPattern() !== "" ? T.create(za(t.getPattern())) : t.isString() && (Yn(`${t.getValue()}`) || Hn2(`${t.getValue()}`)) ? T.create(true) : T.create(false);
  }
};
var D0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    if (t.isArray()) {
      const o = t.getRowCount(), u = t.getColumnCount();
      if (o > 1 || u > 1)
        return g2.create(h.VALUE);
      t = t.get(0, 0);
    }
    if (t.isError())
      return t;
    if (t.isNull() || t.isBoolean() || t.isNumber())
      return T.create(false);
    const r = `${t.getValue()}`;
    if (r.length > 254)
      return T.create(false);
    const n = Z.topLevelDomainCombiningString(), s = new RegExp(
      `^(?:[\\w+-]+\\.)*[\\w+-]+@[a-z0-9_-]+(?:\\.[a-z0-9_-]+)*\\.(?:${n})$`,
      "i"
    );
    return T.create(s.test(r));
  }
};
var w0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.getValue() === h.NA ? T.create(false) : e.isError() ? T.create(true) : e.isArray() ? e.mapValue((t) => t.getValue() === h.NA ? T.create(false) : t.isError() ? T.create(true) : T.create(false)) : T.create(false);
  }
};
var L0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isError() ? T.create(true) : e.isArray() ? e.mapValue((t) => t.isError() ? T.create(true) : T.create(false)) : T.create(false);
  }
};
var P0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    if (t.isArray()) {
      const s = t.getRowCount(), o = t.getColumnCount();
      if (s > 1 || o > 1)
        return g2.create(h.VALUE);
      t = t.get(0, 0);
    }
    if (t.isError())
      return t;
    if (t.isBoolean())
      return g2.create(h.VALUE);
    const r = Math.trunc(+t.getValue());
    if (Number.isNaN(r))
      return g2.create(h.VALUE);
    const n = r % 2 === 0;
    return T.create(n);
  }
};
var x0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
    A(this, "needsReferenceObject", true);
  }
  calculate(e) {
    var u;
    if (e.isError())
      return e;
    if (!e.isReferenceObject())
      return g2.create(h.NA);
    const t = (u = e.getCurrentActiveSheetData()) == null ? void 0 : u.cellData.getMatrix(), { startRow: r, startColumn: n } = e.getRangePosition(), s = e.toArrayValueObject(), o = s.mapValue((c, l, f2) => {
      var d2;
      const m2 = (d2 = t == null ? void 0 : t[r + l]) == null ? void 0 : d2[n + f2];
      return m2 != null && m2.f || m2 != null && m2.si ? T.create(true) : T.create(false);
    });
    return s.getRowCount() === 1 && s.getColumnCount() === 1 ? o.get(0, 0) : o;
  }
};
var j0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isBoolean() ? T.create(true) : e.isArray() ? e.mapValue((t) => t.isBoolean() ? T.create(true) : T.create(false)) : T.create(false);
  }
};
var U0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.getValue() === h.NA ? T.create(true) : e.isArray() ? e.mapValue((t) => t.getValue() === h.NA ? T.create(true) : T.create(false)) : T.create(false);
  }
};
var v0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return !e.isArray() && !e.isString() ? T.create(true) : e.isArray() ? e.mapValue((t) => t.isString() ? T.create(false) : T.create(true)) : T.create(false);
  }
};
var T0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isNumber() ? T.create(true) : e.isArray() ? e.mapValue((t) => t.isNumber() ? T.create(true) : T.create(false)) : T.create(false);
  }
};
var I0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    if (t.isArray()) {
      const s = t.getRowCount(), o = t.getColumnCount();
      if (s > 1 || o > 1)
        return g2.create(h.VALUE);
      t = t.get(0, 0);
    }
    if (t.isError())
      return t;
    if (t.isBoolean())
      return g2.create(h.VALUE);
    const r = Math.trunc(+t.getValue());
    if (Number.isNaN(r))
      return g2.create(h.VALUE);
    const n = r % 2 !== 0;
    return T.create(n);
  }
};
var B0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
    A(this, "needsReferenceObject", true);
  }
  calculate(e) {
    return e.isReferenceObject() ? T.create(true) : T.create(false);
  }
};
var F0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isString() ? T.create(true) : e.isArray() ? e.mapValue((t) => t.isString() ? T.create(true) : T.create(false)) : T.create(false);
  }
};
var k0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    if (t.isArray()) {
      const o = t.getRowCount(), u = t.getColumnCount();
      if (o > 1 || u > 1)
        return g2.create(h.VALUE);
      t = t.get(0, 0);
    }
    if (t.isError())
      return t;
    if (t.isNull() || t.isBoolean() || t.isNumber())
      return T.create(false);
    const r = `${t.getValue()}`.replace(/^\s+|\s+$/g, "");
    if (r.length > 1e3)
      return T.create(false);
    const n = Z.topLevelDomainCombiningString(), s = new RegExp(
      `^(?:(?:https?|s?ftp|ftps|nfs|ssh)://+[a-z0-9_-]+(?:\\.[a-z0-9_-]+)*(?::[0-9]+)?(?:/(?:[A-Za-z0-9\\-._~!$&'()*+,;=:@]|%[A-Fa-f0-9]{2})*)*/?(?:[?#]\\S*)?|[a-z0-9_-]+(?:\\.[a-z0-9_-]+)*\\.(?:${n})(?::[0-9]+)?(?:/(?:[A-Za-z0-9\\-._~!$&'()*+,;=:@]|%[A-Fa-f0-9]{2})*)*/?(?:[?#]\\S*)?|mailto:(?:[\\w+-]+\\.)*[\\w+-]+@[a-z0-9_-]+(?:\\.[a-z0-9_-]+)*\\.(?:${n})|(?:news|aim):[%a-z0-9$_\\.+!*(),;/?#:@&~=-]+)$`,
      "i"
    );
    return T.create(s.test(r));
  }
};
var $0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    if (e.isArray() && (t = e.get(0, 0)), t.isError())
      return t;
    if (t.isString())
      return y2.create(0);
    const r = +t.getValue();
    return y2.create(r);
  }
};
var Y0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 0);
  }
  calculate() {
    return g2.create(h.NA);
  }
};
var H0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 1);
    A(this, "needsReferenceObject", true);
    A(this, "needsSheetsInfo", true);
  }
  calculate(e) {
    var u;
    if (e != null && e.isError())
      return e;
    const { sheetOrder: t, sheetNameMap: r } = this.getSheetsInfo();
    if (!e) {
      const c = t.findIndex((l) => l === this.subUnitId);
      return y2.create(c + 1);
    }
    if (e.isReferenceObject()) {
      const c = e.getForcedSheetId(), l = e.getDefaultSheetId(), f2 = t.findIndex((m2) => c ? m2 === c : m2 === l);
      return y2.create(f2 + 1);
    }
    if (e.isArray())
      return g2.create(h.NA);
    const n = `${e.getValue()}`.toLocaleLowerCase(), s = (u = Object.entries(r).find(([c, l]) => l.toLocaleLowerCase() === n)) == null ? void 0 : u[0];
    if (!s)
      return g2.create(h.NA);
    const o = t.findIndex((c) => c === s);
    return y2.create(o + 1);
  }
};
var G0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 0);
    A(this, "needsSheetsInfo", true);
  }
  calculate() {
    const { sheetOrder: e } = this.getSheetsInfo();
    return y2.create(e.length);
  }
};
var W0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "needsReferenceObject", true);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isReferenceObject()) {
      const t = e.getRowCount(), r = e.getColumnCount();
      if (t === 1 && r === 1) {
        const n = e.getFirstCell();
        if (n.isError())
          return y2.create(16);
        if (n.isBoolean())
          return y2.create(4);
        if (n.isString())
          return y2.create(2);
        if (n.isNumber() || n.isNull())
          return y2.create(1);
      } else
        return y2.create(64);
    } else {
      if (e.isArray())
        return y2.create(64);
      if (e.isError())
        return y2.create(16);
      if (e.isBoolean())
        return y2.create(4);
      if (e.isString())
        return y2.create(2);
      if (e.isNumber() || e.isNull())
        return y2.create(1);
    }
    return y2.create(128);
  }
};
var Q0 = [
  [N0, Ve2.CELL],
  [V0, Ve2.ERROR_TYPE],
  [O0, Ve2.ISBETWEEN],
  [S0, Ve2.ISBLANK],
  [M0, Ve2.ISDATE],
  [D0, Ve2.ISEMAIL],
  [w0, Ve2.ISERR],
  [L0, Ve2.ISERROR],
  [P0, Ve2.ISEVEN],
  [x0, Ve2.ISFORMULA],
  [j0, Ve2.ISLOGICAL],
  [U0, Ve2.ISNA],
  [v0, Ve2.ISNONTEXT],
  [T0, Ve2.ISNUMBER],
  [I0, Ve2.ISODD],
  [B0, Ve2.ISREF],
  [F0, Ve2.ISTEXT],
  [k0, Ve2.ISURL],
  [$0, Ve2.N],
  [Y0, Ve2.NA],
  [H0, Ve2.SHEET],
  [G0, Ve2.SHEETS],
  [W0, Ve2.TYPE]
];
var q0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = true, r = true, n = null;
    for (const s of e) {
      if (s.isError())
        return s;
      if (s.isArray()) {
        if (s.iterator((o) => {
          if (o != null && o.isError())
            return n = o, false;
          (o != null && o.isBoolean() || o != null && o.isNumber()) && (t = t && !!o.getValue(), r = false);
        }), n)
          return n;
      } else (s.isBoolean() || s.isNumber()) && (t = t && !!s.getValue(), r = false);
    }
    return r ? g2.create(h.VALUE) : T.create(t);
  }
};
var X0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
    A(this, "needsReferenceObject", true);
  }
  // eslint-disable-next-line
  calculate(e, t) {
    let r = e, n = null;
    if (e.isReferenceObject() && (r = e.toArrayValueObject(), n = e), r.isError())
      return r;
    if (t.isError())
      return t;
    if (!(t.isValueObject() && t.isLambda() && t.getLambdaPrivacyVarKeys().length === 1))
      return g2.create(h.VALUE);
    const s = t, o = r.isArray() ? r.getRowCount() : 1, u = r.isArray() ? r.getColumnCount() : 1;
    r = O(o, u, r);
    const c = [[]];
    for (let l = 0; l < u; l++) {
      const f2 = [];
      for (let _2 = 0; _2 < o; _2++) {
        const C = r.get(_2, l);
        f2.push([C]);
      }
      let m2 = K2.create({
        calculateValueList: f2,
        rowCount: o,
        columnCount: 1,
        unitId: "",
        sheetId: "",
        row: 0,
        column: 0
      });
      if (n) {
        const { startRow: _2, startColumn: C } = n.getRangePosition(), E = {
          startRow: _2,
          startColumn: C + l,
          endRow: _2 + o - 1,
          endColumn: C + l
        };
        m2 = this.createReferenceObject(n, E);
      }
      let d2 = s.execute(m2);
      if (d2.isArray()) {
        const _2 = d2.getRowCount(), C = d2.getColumnCount();
        if (_2 > 1 || C > 1)
          return g2.create(h.CALC);
        d2 = d2.get(0, 0);
      }
      d2.isNull() && (d2 = y2.create(0)), c[0].push(d2);
    }
    return u === 1 ? c[0][0] : K2.create({
      calculateValueList: c,
      rowCount: 1,
      columnCount: u,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
};
var K0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
    A(this, "needsReferenceObject", true);
  }
  // eslint-disable-next-line
  calculate(e, t) {
    let r = e, n = null;
    if (e.isReferenceObject() && (r = e.toArrayValueObject(), n = e), r.isError())
      return r;
    if (t.isError())
      return t;
    if (!(t.isValueObject() && t.isLambda() && t.getLambdaPrivacyVarKeys().length === 1))
      return g2.create(h.VALUE);
    const s = t, o = r.isArray() ? r.getRowCount() : 1, u = r.isArray() ? r.getColumnCount() : 1;
    r = O(o, u, r);
    const c = [];
    for (let l = 0; l < o; l++) {
      const f2 = [[]];
      for (let _2 = 0; _2 < u; _2++) {
        const C = r.get(l, _2);
        f2[0].push(C);
      }
      let m2 = K2.create({
        calculateValueList: f2,
        rowCount: 1,
        columnCount: u,
        unitId: "",
        sheetId: "",
        row: 0,
        column: 0
      });
      if (n) {
        const { startRow: _2, startColumn: C } = n.getRangePosition(), E = {
          startRow: _2 + l,
          startColumn: C,
          endRow: _2 + l,
          endColumn: C + u - 1
        };
        m2 = this.createReferenceObject(n, E);
      }
      let d2 = s.execute(m2);
      if (d2.isArray()) {
        const _2 = d2.getRowCount(), C = d2.getColumnCount();
        if (_2 > 1 || C > 1)
          return g2.create(h.CALC);
        d2 = d2.get(0, 0);
      }
      d2.isNull() && (d2 = y2.create(0)), c.push([d2]);
    }
    return o === 1 ? c[0][0] : K2.create({
      calculateValueList: c,
      rowCount: o,
      columnCount: 1,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
};
var Z0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 0);
  }
  calculate() {
    return T.create(false);
  }
};
var Ee = ((a2) => (a2.AND = "AND", a2.BYCOL = "BYCOL", a2.BYROW = "BYROW", a2.FALSE = "FALSE", a2.IF = "IF", a2.IFERROR = "IFERROR", a2.IFNA = "IFNA", a2.IFS = "IFS", a2.LAMBDA = "LAMBDA", a2.LET = "LET", a2.MAKEARRAY = "MAKEARRAY", a2.MAP = "MAP", a2.NOT = "NOT", a2.OR = "OR", a2.REDUCE = "REDUCE", a2.SCAN = "SCAN", a2.SWITCH = "SWITCH", a2.TRUE = "TRUE", a2.XOR = "XOR", a2))(Ee || {});
var z0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r = T.create(false)) {
    let n = e;
    if (e.isArray()) {
      const f2 = e.getRowCount(), m2 = e.getColumnCount();
      f2 === 1 && m2 === 1 && (n = e.get(0, 0));
    }
    if (!n.isArray())
      return this._handleSingleObject(n, t, r);
    const s = Math.max(
      n.isArray() ? n.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), o = Math.max(
      n.isArray() ? n.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), u = O(s, o, n, g2.create(h.NA)), c = O(s, o, t, g2.create(h.NA)), l = O(s, o, r, g2.create(h.NA));
    return u.mapValue((f2, m2, d2) => {
      const _2 = c.get(m2, d2), C = l.get(m2, d2);
      return this._handleSingleObject(f2, _2, C);
    });
  }
  _handleSingleObject(e, t, r) {
    return e.isError() ? e : e.getValue() ? t : r;
  }
};
var J0 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (!e.isArray())
      return e.isError() ? t : e;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e), o = O(r, n, t);
    return s.iterator((u, c, l) => {
      u != null && u.isError() && s.set(c, l, o.get(c, l));
    }), s;
  }
};
var eC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError() && e.getErrorType() !== h.NA)
      return e;
    if (t.isError())
      return t;
    if (!e.isArray())
      return e.isError() && e.getErrorType() === h.NA ? t : e;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e), o = O(r, n, t);
    return s.iterator((u, c, l) => {
      u != null && u.isError() && u.getErrorType() === h.NA && s.set(c, l, o.get(c, l));
    }), s;
  }
};
var tC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    if (e.length % 2 !== 0)
      return g2.create(h.NA);
    for (let o = 0; o < e.length; o++)
      if (e[o].isError())
        return e[o];
    const t = Math.max(
      ...e.map((o) => o.isArray() ? o.getRowCount() : 1)
    ), r = Math.max(
      ...e.map((o) => o.isArray() ? o.getColumnCount() : 1)
    ), n = e.map(
      (o) => O(t, r, o, g2.create(h.NA))
    ), s = n[0].map((o, u, c) => {
      for (let l = 0; l < n.length; l += 2) {
        const f2 = n[l].get(u, c) || ce.create(), m2 = n[l + 1].get(u, c) || ce.create();
        if (f2.isNull())
          continue;
        if (f2.isError())
          return f2;
        const d2 = f2.getValue();
        if (f2.isString()) {
          if (`${d2}`.toLocaleUpperCase() === "TRUE")
            return m2;
          if (`${d2}`.toLocaleUpperCase() === "FALSE")
            continue;
          return g2.create(h.VALUE);
        }
        if (+d2)
          return m2.isNull() ? g2.create(h.NA) : m2;
      }
      return g2.create(h.NA);
    });
    return t === 1 && r === 1 ? s.get(0, 0) : s;
  }
};
var rC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    return g2.create(h.VALUE);
  }
};
var nC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    return g2.create(h.VALUE);
  }
};
var sC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(...e) {
    const t = this.getIndexNumValue(e[0]);
    if (typeof t != "number")
      return t;
    const r = this.getIndexNumValue(e[1]);
    if (typeof r != "number")
      return r;
    if (!(e[2].isValueObject() && e[2].isLambda()))
      return g2.create(h.VALUE);
    const n = e[2], s = [];
    for (let o = 0; o < t; o++) {
      s[o] == null && (s[o] = []);
      for (let u = 0; u < r; u++) {
        let c = n.execute(y2.create(o + 1), y2.create(u + 1));
        c.isArray() && (c = c.get(0, 0)), s[o][u] = c;
      }
    }
    return new Om(s);
  }
  isAsync() {
    return true;
  }
};
var aC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", true);
  }
  calculate(...e) {
    const t = [];
    let r = null, n = 0, s = 0;
    for (let u = 0; u < e.length; u++) {
      const c = e[u];
      let l = c;
      if (l.isReferenceObject() && (l = c.toArrayValueObject()), l.isError())
        return l;
      if (u === e.length - 1) {
        if (!(c.isValueObject() && c.isLambda()))
          return g2.create(h.VALUE);
        r = c;
      } else
        t.push(c), n = Math.max(n, l.isArray() ? l.getRowCount() : 1), s = Math.max(s, l.isArray() ? l.getColumnCount() : 1);
    }
    const o = this._getResultArray(t, r, n, s);
    return o instanceof g2 ? o : n === 1 && s === 1 ? o[0][0] : K2.create({
      calculateValueList: o,
      rowCount: n,
      columnCount: s,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
  // eslint-disable-next-line
  _getResultArray(e, t, r, n) {
    const s = [];
    for (let o = 0; o < r; o++) {
      const u = [];
      for (let c = 0; c < n; c++) {
        const l = [];
        let f2 = false;
        for (let d2 = 0; d2 < e.length; d2++) {
          let _2 = e[d2], C = null;
          if (_2.isReferenceObject() && (C = _2, _2 = _2.toArrayValueObject()), !_2.isArray())
            if (o === 0 && c === 0) {
              l.push(C || _2);
              continue;
            } else {
              u.push(g2.create(h.NA)), f2 = true;
              break;
            }
          let E = _2.get(o, c);
          if (!E) {
            u.push(g2.create(h.NA)), f2 = true;
            break;
          }
          if (C) {
            const { startRow: R, startColumn: b } = C.getRangePosition(), p2 = {
              startRow: R + o,
              startColumn: b + c,
              endRow: R + o,
              endColumn: b + c
            };
            E = this.createReferenceObject(C, p2);
          }
          l.push(E);
        }
        if (f2 || l.length === 0)
          continue;
        let m2 = t.execute(...l);
        if (m2.isArray()) {
          const d2 = m2.getRowCount(), _2 = m2.getColumnCount();
          if (d2 > 1 || _2 > 1)
            return g2.create(h.CALC);
          m2 = m2.get(0, 0);
        }
        m2.isNull() && (m2 = y2.create(0)), u.push(m2);
      }
      s.push(u);
    }
    return s;
  }
};
var iC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    const t = +e.getValue();
    return Number.isNaN(t) ? g2.create(h.VALUE) : T.create(!t);
  }
};
var oC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = false, r = true, n = null;
    for (const s of e) {
      if (s.isError())
        return s;
      if (s.isArray()) {
        if (s.iterator((o) => {
          if (o != null && o.isError())
            return n = o, false;
          (o != null && o.isBoolean() || o != null && o.isNumber()) && (t = t || !!o.getValue(), r = false);
        }), n)
          return n;
      } else (s.isBoolean() || s.isNumber()) && (t = t || !!s.getValue(), r = false);
    }
    return r ? new g2(h.VALUE) : new T(t);
  }
};
var uC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
    A(this, "needsReferenceObject", true);
  }
  calculate(e, t, r) {
    let n, s;
    e.isReferenceObject() ? (n = e.toArrayValueObject(), s = e) : (n = e, s = null);
    let o, u;
    return t.isReferenceObject() ? (o = t.toArrayValueObject(), u = t) : (o = t, u = null), n.isArray() ? n.mapValue((c) => this._handleSingleValueObject(c, o, r, s, u)) : this._handleSingleValueObject(n, o, r, s, u);
  }
  _handleSingleValueObject(e, t, r, n, s) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (r.isError())
      return r;
    if (!(r.isValueObject() && r.isLambda() && r.getLambdaPrivacyVarKeys().length === 2))
      return g2.create(h.VALUE);
    const o = r, u = t.isArray() ? t.getRowCount() : 1, c = t.isArray() ? t.getColumnCount() : 1;
    let l = e;
    n && (l = n);
    for (let f2 = 0; f2 < u; f2++)
      for (let m2 = 0; m2 < c; m2++) {
        let d2 = t.isArray() ? t.get(f2, m2) : t;
        if (d2.isError())
          return d2;
        if (s) {
          const { startRow: C, startColumn: E } = s.getRangePosition(), R = {
            startRow: C + f2,
            startColumn: E + m2,
            endRow: C + f2,
            endColumn: E + m2
          };
          d2 = this.createReferenceObject(s, R);
        }
        let _2 = o.execute(l, d2);
        if (_2.isError())
          return _2;
        _2.isNull() && (_2 = y2.create(0)), l = _2;
      }
    return l.isReferenceObject() ? l.toArrayValueObject() : l;
  }
};
var cC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
    A(this, "needsReferenceObject", true);
  }
  calculate(e, t, r) {
    let n = e, s = null;
    e.isReferenceObject() && (n = e.toArrayValueObject(), s = e), n = n;
    let o = t, u = null;
    if (t.isReferenceObject() && (o = t.toArrayValueObject(), u = t), o = o, n.isError())
      return n;
    if (o.isError())
      return o;
    if (r.isError())
      return r;
    if (!(r.isValueObject() && r.isLambda() && r.getLambdaPrivacyVarKeys().length === 2))
      return g2.create(h.VALUE);
    if (n.isArray()) {
      const c = n.getRowCount(), l = n.getColumnCount();
      if (c > 1 || l > 1)
        return g2.create(h.CALC);
      n = n.get(0, 0);
    }
    return this._getResult(n, o, r, s, u);
  }
  // eslint-disable-next-line
  _getResult(e, t, r, n, s) {
    const o = [], u = t.isArray() ? t.getRowCount() : 1, c = t.isArray() ? t.getColumnCount() : 1;
    let l = e;
    n && (l = n);
    for (let f2 = 0; f2 < u; f2++) {
      const m2 = [];
      for (let d2 = 0; d2 < c; d2++) {
        if (l.isError()) {
          m2.push(l);
          continue;
        }
        let _2 = t.isArray() ? t.get(f2, d2) : t;
        if (_2.isError()) {
          l = _2, m2.push(_2);
          continue;
        }
        if (s) {
          const { startRow: E, startColumn: R } = s.getRangePosition(), b = {
            startRow: E + f2,
            startColumn: R + d2,
            endRow: E + f2,
            endColumn: R + d2
          };
          _2 = this.createReferenceObject(s, b);
        }
        let C = r.execute(l, _2);
        if (C.isArray()) {
          const E = C.getRowCount(), R = C.getColumnCount();
          if (E > 1 || R > 1)
            return g2.create(h.CALC);
          C = C.get(0, 0);
        }
        C.isNull() && (C = y2.create(0)), l = C, m2.push(C);
      }
      o.push(m2);
    }
    return u === 1 && c === 1 ? o[0][0] : K2.create({
      calculateValueList: o,
      rowCount: u,
      columnCount: c,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
};
var lC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
  }
  calculate(e, ...t) {
    if (e.isError())
      return e;
    const r = t.length % 2 !== 0, n = r ? t[t.length - 1] : ce.create();
    return !e.isArray() && !t.some((s) => s.isArray()) ? this._handleNonArrayInputs(e, t, n, r) : this._handleArrayInputs(e, t, n, r);
  }
  _handleNonArrayInputs(e, t, r, n) {
    for (let s = 0; s < t.length - (n ? 1 : 0); s += 2) {
      const o = t[s], u = t[s + 1];
      if (!o.isNull()) {
        if (o.isError())
          return o;
        if (`${e.getValue()}`.toLocaleLowerCase() === `${o.getValue()}`.toLocaleLowerCase())
          return u.isNull() ? g2.create(h.NA) : u;
      }
    }
    return r.isNull() ? g2.create(h.NA) : r;
  }
  _handleArrayInputs(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      ...t.map((f2) => f2.isArray() ? f2.getRowCount() : 1),
      r.isArray() ? r.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      ...t.map((f2) => f2.isArray() ? f2.getColumnCount() : 1),
      r.isArray() ? r.getColumnCount() : 1
    ), u = O(s, o, e), c = t.map(
      (f2) => O(s, o, f2, g2.create(h.NA))
    ), l = O(s, o, r, g2.create(h.NA));
    return u.map((f2, m2, d2) => {
      for (let C = 0; C < c.length - (n ? 1 : 0); C += 2) {
        const E = c[C].get(m2, d2) || ce.create(), R = c[C + 1].get(m2, d2) || ce.create();
        if (!E.isNull()) {
          if (E.isError() || f2.isError())
            return E.isError() ? E : f2;
          if (`${f2.getValue()}`.toLocaleLowerCase() === `${E.getValue()}`.toLocaleLowerCase())
            return R.isNull() ? g2.create(h.NA) : R;
        }
      }
      const _2 = l.get(m2, d2) || ce.create();
      return _2.isNull() ? g2.create(h.NA) : _2;
    });
  }
};
var fC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 0);
  }
  calculate() {
    return T.create(true);
  }
};
var mC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = 0, r = true, n = null;
    for (const s of e) {
      if (s.isError())
        return s;
      if (s.isArray()) {
        if (s.iterator((o) => {
          if (o != null && o.isError())
            return n = o, false;
          (o != null && o.isBoolean() || o != null && o.isNumber()) && (o.getValue() && t++, r = false);
        }), n)
          return n;
      } else (s.isBoolean() || s.isNumber()) && (s.getValue() && t++, r = false);
    }
    return r ? g2.create(h.VALUE) : T.create(t % 2 === 1);
  }
};
var hC = [
  [q0, Ee.AND],
  [X0, Ee.BYCOL],
  [K0, Ee.BYROW],
  [Z0, Ee.FALSE],
  [z0, Ee.IF],
  [J0, Ee.IFERROR],
  [eC, Ee.IFNA],
  [tC, Ee.IFS],
  [rC, Ee.LAMBDA],
  [nC, Ee.LET],
  [sC, Ee.MAKEARRAY],
  [aC, Ee.MAP],
  [iC, Ee.NOT],
  [oC, Ee.OR],
  [uC, Ee.REDUCE],
  [cC, Ee.SCAN],
  [lC, Ee.SWITCH],
  [fC, Ee.TRUE],
  [mC, Ee.XOR]
];
var gC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 5);
  }
  // eslint-disable-next-line max-lines-per-function
  calculate(e, t, r, n, s) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (r != null && r.isError())
      return r;
    if (n != null && n.isError())
      return n;
    if (s != null && s.isError())
      return s;
    const o = r != null ? r : y2.create(1), u = n != null ? n : T.create(true), c = s != null ? s : U2.create(""), l = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f2 = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), m2 = O(l, f2, e, g2.create(h.NA)), d2 = O(l, f2, t, g2.create(h.NA)), _2 = O(l, f2, o, g2.create(h.NA)), C = O(l, f2, u, g2.create(h.NA)), E = O(l, f2, c, g2.create(h.NA));
    return m2.map((R, b, p2) => {
      const V = d2.get(b, p2) || g2.create(h.NA), S2 = _2.get(b, p2) || g2.create(h.NA), M2 = C.get(b, p2) || g2.create(h.NA), D2 = E.get(b, p2) || g2.create(h.NA);
      return R.isError() ? R : V.isError() ? V : S2.isError() ? S2 : M2.isError() ? M2 : D2.isError() ? D2 : this._calculateSingleCell(R, V, S2, M2, D2);
    });
  }
  _calculateSingleCell(e, t, r, n, s) {
    const o = Number.parseInt(`${Number(e.getValue()) - 1}`), u = Number.parseInt(`${Number(t.getValue()) - 1}`), c = Number.parseInt(`${Number(r.getValue())}`);
    if (Number.isNaN(o) || Number.isNaN(u) || Number.isNaN(c) || c < 1 || c > 4)
      return g2.create(h.VALUE);
    const l = dC(c), f2 = this.getZeroOrOneByOneDefault(n), m2 = `${s.getValue()}`, d2 = No(m2), _2 = {
      startRow: o,
      startColumn: u,
      endRow: o,
      endColumn: u,
      startAbsoluteRefType: l,
      endAbsoluteRefType: l
    }, C = n && !f2 ? Lh(_2) : Yt(_2);
    return U2.create(d2 !== "" ? `${d2}!${C}` : C);
  }
};
function dC(a2) {
  switch (a2) {
    case 1:
      return ye.ALL;
    case 2:
      return ye.ROW;
    case 3:
      return ye.COLUMN;
    case 4:
      return ye.NONE;
    default:
      return ye.ALL;
  }
}
var CC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
    A(this, "needsReferenceObject", true);
  }
  calculate(e) {
    return e.isReferenceObject() ? y2.create(1) : g2.create(h.VALUE);
  }
};
var _C = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", true);
  }
  calculate(e, ...t) {
    let r = e;
    if (r.isError())
      return r;
    if (r.isReferenceObject() && (r = r.toArrayValueObject()), !r.isArray()) {
      const c = r.convertToNumberObjectValue();
      return c.isError() ? c : t[Math.trunc(+c.getValue()) - 1] || g2.create(h.VALUE);
    }
    let n = r.isArray() ? r.getRowCount() : 1, s = r.isArray() ? r.getColumnCount() : 1;
    t.forEach((c, l) => {
      if (c.isArray()) {
        const f2 = c;
        n = Math.max(n, f2.getRowCount()), s = Math.max(s, f2.getColumnCount());
      } else
        n = Math.max(n, 1), s = Math.max(s, 1);
    });
    const o = O(n, s, r, g2.create(h.NA)), u = t.map((c) => {
      let l = c;
      return l.isReferenceObject() && (l = l.toArrayValueObject()), O(n, s, l, g2.create(h.NA));
    });
    return o.map((c, l, f2) => {
      if (c.isError())
        return c;
      const m2 = c.convertToNumberObjectValue();
      if (m2.isError())
        return m2;
      const d2 = u[Math.trunc(+m2.getValue()) - 1];
      let _2 = (d2 == null ? void 0 : d2.get(l, f2)) || g2.create(h.VALUE);
      return _2 != null && _2.isNull() && (_2 = y2.create(0)), _2;
    });
  }
};
var AC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
  }
  calculate(e, ...t) {
    if (e.isError())
      return e;
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = [];
    for (let o = 0; o < t.length; o++) {
      let u = t[o];
      if (u.isArray()) {
        const f2 = u.getRowCount(), m2 = u.getColumnCount();
        if (f2 > 1 || m2 > 1)
          return g2.create(h.VALUE);
        u = u.get(0, 0);
      }
      if (u.isString() && (u = u.convertToNumberObjectValue()), u.isError())
        return u;
      const c = Math.trunc(+u.getValue());
      if (c === 0 || Math.abs(c) > n)
        return g2.create(h.VALUE);
      let l = e;
      n > 1 && (c < 0 ? l = e.slice(void 0, [c + n, c + 1 + n]) : l = e.slice(void 0, [c - 1, c]));
      for (let f2 = 0; f2 < r; f2++)
        s[f2] || (s[f2] = []), e.isArray() ? s[f2].push(l.get(f2, 0)) : s[f2].push(e);
    }
    return K2.create({
      calculateValueList: s,
      rowCount: s.length,
      columnCount: s[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
};
var EC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
  }
  calculate(e, ...t) {
    if (e.isError())
      return e;
    const r = e.isArray() ? e.getRowCount() : 1, n = [];
    for (let s = 0; s < t.length; s++) {
      let o = t[s];
      if (o.isArray()) {
        const l = o.getRowCount(), f2 = o.getColumnCount();
        if (l > 1 || f2 > 1)
          return g2.create(h.VALUE);
        o = o.get(0, 0);
      }
      if (o.isString() && (o = o.convertToNumberObjectValue()), o.isError())
        return o;
      const u = Math.trunc(+o.getValue());
      if (u === 0 || Math.abs(u) > r)
        return g2.create(h.VALUE);
      let c = e;
      r > 1 && (u < 0 ? c = e.slice([u + r, u + 1 + r]) : c = e.slice([u - 1, u])), e.isArray() ? n.push(c.getArrayValue()[0]) : n.push([e]);
    }
    return K2.create({
      calculateValueList: n,
      rowCount: n.length,
      columnCount: n[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
};
var RC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e == null)
      return y2.create(this.column + 1);
    if (e.isError())
      return e;
    if (!e.isArray())
      return g2.create(h.NA);
    const t = e.getCurrentColumn(), r = e.getColumnCount(), n = [];
    for (let o = 0; o < r; o++)
      n.push(y2.create(t + o + 1));
    const s = {
      calculateValueList: [n],
      rowCount: 1,
      columnCount: r,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    };
    return K2.create(s);
  }
};
var bC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isError())
      return e;
    if (e.isString() || e.isNumber() || e.isBoolean())
      return y2.create(1);
    if (!e.isArray())
      return g2.create(h.NA);
    const t = e.getColumnCount();
    return y2.create(t);
  }
};
var yC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : y2.create(0), s = e.isArray() ? e.getRowCount() : 1, o = e.isArray() ? e.getColumnCount() : 1, u = Math.max(
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), c = Math.max(
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), l = O(u, c, t, g2.create(h.NA)), f2 = O(u, c, n, g2.create(h.NA));
    if (u > 1 || c > 1)
      return l.mapValue((b, p2, V) => {
        const S2 = f2.get(p2, V);
        if (e.isError())
          return e;
        if (e.isNull())
          return g2.create(h.VALUE);
        const { isError: M2, errorObject: D2 } = this._checkRowsColumns(b, S2, s, o);
        return M2 ? D2 : e.isArray() ? g2.create(h.VALUE) : e;
      });
    if (e.isError())
      return e;
    if (e.isNull())
      return g2.create(h.VALUE);
    const m2 = t.isArray() ? t.get(0, 0) : t, d2 = n.isArray() ? n.get(0, 0) : n, { isError: _2, errorObject: C, rowsValue: E, columnsValue: R } = this._checkRowsColumns(m2, d2, s, o);
    return _2 ? C : this._getResultArray(e, E, R, s, o);
  }
  _checkRowsColumns(e, t, r, n) {
    if (e.isError())
      return {
        isError: true,
        errorObject: e
      };
    if (t.isError())
      return {
        isError: true,
        errorObject: t
      };
    const s = Math.trunc(+e.getValue()), o = Math.trunc(+t.getValue());
    return Number.isNaN(s) || Number.isNaN(o) ? {
      isError: true,
      errorObject: g2.create(h.VALUE)
    } : Math.abs(s) >= r || Math.abs(o) >= n ? {
      isError: true,
      errorObject: g2.create(h.CALC)
    } : {
      isError: false,
      rowsValue: s,
      columnsValue: o
    };
  }
  _getResultArray(e, t, r, n, s) {
    const o = t >= 0 ? [t, n] : [0, n + t], u = r >= 0 ? [r, s] : [0, s + r];
    let c;
    return t === 0 && r === 0 ? c = e : t === 0 ? c = e.slice(void 0, u) : r === 0 ? c = e.slice(o, void 0) : c = e.slice(o, u), c = c.map((l) => l.isNull() ? y2.create(0) : l), n - t === 1 && s - r === 1 ? c.get(0, 0) : c;
  }
};
var pC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = e.isArray() ? e.getRowCount() : 1, o = e.isArray() ? e.getColumnCount() : 1;
    let u = t, c = r != null ? r : y2.create(o);
    const l = n != null ? n : g2.create(h.NA);
    t.isNull() && (u = y2.create(s)), c.isNull() && (c = y2.create(o));
    const f2 = Math.max(
      u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), m2 = Math.max(
      u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), d2 = O(f2, m2, u, g2.create(h.NA)), _2 = O(f2, m2, c, g2.create(h.NA));
    if (f2 > 1 || m2 > 1)
      return d2.mapValue((M2, D2, w) => {
        const L = _2.get(D2, w);
        if (e.isError())
          return e;
        if (e.isNull())
          return g2.create(h.VALUE);
        const { isError: v, errorObject: j2 } = this._checkRowsColumnsPadWith(M2, L, l, s, o);
        return v ? j2 : e.isArray() ? e.get(0, 0) : e;
      });
    if (e.isError())
      return e;
    if (e.isNull())
      return g2.create(h.VALUE);
    const C = u.isArray() ? u.get(0, 0) : u, E = c.isArray() ? c.get(0, 0) : c, { isError: R, errorObject: b, rowsValue: p2, columnsValue: V, padWithObject: S2 } = this._checkRowsColumnsPadWith(C, E, l, s, o);
    return R ? b : this._getResultArray(e, p2, V, S2, s, o);
  }
  _checkRowsColumnsPadWith(e, t, r, n, s) {
    if (e.isError())
      return {
        isError: true,
        errorObject: e
      };
    if (t.isError())
      return {
        isError: true,
        errorObject: t
      };
    const o = Math.trunc(+e.getValue()), u = Math.trunc(+t.getValue());
    if (Number.isNaN(o) || Number.isNaN(u))
      return {
        isError: true,
        errorObject: g2.create(h.VALUE)
      };
    if (Math.abs(o) < n || Math.abs(u) < s)
      return {
        isError: true,
        errorObject: g2.create(h.VALUE)
      };
    let c = r;
    if (r.isArray()) {
      const l = r.getRowCount(), f2 = r.getColumnCount();
      if (l > 1 || f2 > 1)
        return {
          isError: true,
          errorObject: g2.create(h.VALUE)
        };
      c = r.get(0, 0);
    }
    return {
      isError: false,
      rowsValue: o,
      columnsValue: u,
      padWithObject: c
    };
  }
  _getResultArray(e, t, r, n, s, o) {
    let u = [];
    e.isArray() ? u = e.map((f2) => f2.isNull() ? y2.create(0) : f2).getArrayValue() : u = [[e]];
    const c = Math.max(0, t - s), l = Math.max(0, r - o);
    for (let f2 = 0; f2 < c; f2++)
      u.push(new Array(o).fill(n));
    for (let f2 = 0; f2 < l; f2++)
      u.forEach((m2) => {
        m2.push(n);
      });
    return t === 1 && r === 1 ? u[0][0] : K2.create({
      calculateValueList: u,
      rowCount: u.length,
      columnCount: u[0].length,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
};
var NC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : g2.create(h.CALC);
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const s = e.isArray() ? e.getRowCount() : 1, o = e.isArray() ? e.getColumnCount() : 1, u = t.isArray() ? t.getRowCount() : 1, c = t.isArray() ? t.getColumnCount() : 1;
    return u > 1 && c > 1 || u === 1 && c !== o || c === 1 && u !== s ? g2.create(h.VALUE) : s === 1 && o === 1 ? this._getResultArrayByR1C1(e, t, n) : u === 1 ? c !== o ? g2.create(h.VALUE) : this._getResultArrayByR1(s, o, e, t, n) : c === 1 ? u !== s ? g2.create(h.VALUE) : this._getResultArrayByC1(s, o, e, t, n) : n;
  }
  _getResultArrayByR1C1(e, t, r) {
    let n = e, s = t;
    return n.isArray() && (n = n.get(0, 0)), s.isArray() && (s = s.get(0, 0)), s.isString() && (s = s.convertToNumberObjectValue()), s.isError() ? s : +s.getValue() ? n : r;
  }
  _getResultArrayByR1(e, t, r, n, s) {
    const o = [];
    for (let u = 0; u < t; u++) {
      let c = n.get(0, u);
      if (c.isString() && (c = c.convertToNumberObjectValue()), c.isError())
        return c;
      if (+c.getValue())
        for (let f2 = 0; f2 < e; f2++) {
          o[f2] || (o[f2] = []);
          const m2 = r.get(f2, u);
          o[f2].push(m2);
        }
    }
    return o.length === 0 ? s : K2.create({
      calculateValueList: o,
      rowCount: o.length,
      columnCount: o[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
  _getResultArrayByC1(e, t, r, n, s) {
    const o = [];
    for (let u = 0; u < e; u++) {
      let c = n.get(u, 0);
      if (c.isString() && (c = c.convertToNumberObjectValue()), c.isError())
        return c;
      if (!+c.getValue())
        continue;
      const f2 = [];
      for (let m2 = 0; m2 < t; m2++) {
        const d2 = r.get(u, m2);
        f2.push(d2);
      }
      o.push(f2);
    }
    return o.length === 0 ? s : K2.create({
      calculateValueList: o,
      rowCount: o.length,
      columnCount: o[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
};
var VC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
    A(this, "needsReferenceObject", true);
    A(this, "needsFormulaDataModel", true);
  }
  calculate(e) {
    var f2, m2;
    if (!e.isReferenceObject())
      return g2.create(h.NA);
    const t = e.getUnitId(), r = e.getSheetId(), s = (m2 = (f2 = e.getUnitData()[t]) == null ? void 0 : f2[r]) == null ? void 0 : m2.cellData, { startRow: o, startColumn: u } = e.getRangePosition(), l = e.toArrayValueObject().mapValue((d2, _2, C) => {
      const E = s.getValue(o + _2, u + C);
      if (E != null && E.f || E != null && E.si) {
        const R = this._formulaDataModel.getFormulaStringByCell(o + _2, u + C, r, t);
        return U2.create(R);
      }
      return g2.create(h.NA);
    });
    return l.getRowCount() === 1 && l.getColumnCount() === 1 ? l.get(0, 0) : l;
  }
};
var re = ((a2) => (a2.ADDRESS = "ADDRESS", a2.AREAS = "AREAS", a2.CHOOSE = "CHOOSE", a2.CHOOSECOLS = "CHOOSECOLS", a2.CHOOSEROWS = "CHOOSEROWS", a2.COLUMN = "COLUMN", a2.COLUMNS = "COLUMNS", a2.DROP = "DROP", a2.EXPAND = "EXPAND", a2.FILTER = "FILTER", a2.FORMULATEXT = "FORMULATEXT", a2.GETPIVOTDATA = "GETPIVOTDATA", a2.HLOOKUP = "HLOOKUP", a2.HSTACK = "HSTACK", a2.HYPERLINK = "HYPERLINK", a2.IMAGE = "IMAGE", a2.INDEX = "INDEX", a2.INDIRECT = "INDIRECT", a2.LOOKUP = "LOOKUP", a2.MATCH = "MATCH", a2.OFFSET = "OFFSET", a2.ROW = "ROW", a2.ROWS = "ROWS", a2.RTD = "RTD", a2.SORT = "SORT", a2.SORTBY = "SORTBY", a2.TAKE = "TAKE", a2.TOCOL = "TOCOL", a2.TOROW = "TOROW", a2.TRANSPOSE = "TRANSPOSE", a2.UNIQUE = "UNIQUE", a2.VLOOKUP = "VLOOKUP", a2.VSTACK = "VSTACK", a2.WRAPCOLS = "WRAPCOLS", a2.WRAPROWS = "WRAPROWS", a2.XLOOKUP = "XLOOKUP", a2.XMATCH = "XMATCH", a2))(re || {});
var OC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    if (e.isError())
      return e;
    if (t.isError())
      return g2.create(h.REF);
    if (!t.isArray() || r.isError() || n != null && n.isError())
      return g2.create(h.NA);
    const s = this.getZeroOrOneByOneDefault(n);
    if (s == null)
      return g2.create(h.VALUE);
    const o = this.getIndexNumValue(r);
    if (o instanceof g2)
      return o;
    const u = t.slice([0, 1]), c = t.slice([o - 1, o]);
    return u == null || c == null ? g2.create(h.REF) : e.isArray() ? e.map((l) => this._handleSingleObject(l, u, c, s)) : this._handleSingleObject(e, u, c, s);
  }
  _handleSingleObject(e, t, r, n) {
    return n === 0 ? this.equalSearch(e, t, r) : this.binarySearch(e, t, r);
  }
};
var SC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = Math.max(
      ...e.map((n) => n.isArray() ? n.getRowCount() : 1)
    ), r = [];
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      if (s.isError())
        return s;
      const o = s.isArray() ? s.getRowCount() : 1, u = s.isArray() ? s.getColumnCount() : 1;
      for (let c = 0; c < t; c++) {
        r[c] || (r[c] = []);
        for (let l = 0; l < u; l++) {
          let f2 = s;
          s.isArray() && (f2 = s.get(c, l)), c > o - 1 || !f2 ? r[c].push(g2.create(h.NA)) : r[c].push(f2);
        }
      }
    }
    return K2.create({
      calculateValueList: r,
      rowCount: r.length,
      columnCount: r[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
};
var MC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (e.isArray() && (r = e.get(0, 0)), r.isError())
      return r;
    let n = t;
    if (t != null && t.isArray() && (n = t.get(0, 0)), n != null && n.isError())
      return n;
    let s = `${r.getValue()}`;
    r.isNull() && (s = "");
    let o = s;
    return n && (o = `${n.getValue()}`, n.isNull() ? o = "0" : n.isBoolean() && (o = o.toLocaleUpperCase())), U2.create(o, {
      isHyperlink: true,
      hyperlinkUrl: s
    });
  }
};
var DC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 5);
  }
  // eslint-disable-next-line complexity
  calculate(e, t, r, n, s) {
    const o = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t != null && t.isArray() ? t.getRowCount() : 1,
      r != null && r.isArray() ? r.getRowCount() : 1,
      n != null && n.isArray() ? n.getRowCount() : 1,
      s != null && s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t != null && t.isArray() ? t.getColumnCount() : 1,
      r != null && r.isArray() ? r.getColumnCount() : 1,
      n != null && n.isArray() ? n.getColumnCount() : 1,
      s != null && s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, e, g2.create(h.NA)), l = t ? O(o, u, t, g2.create(h.NA)) : void 0, f2 = r ? O(o, u, r, g2.create(h.NA)) : void 0, m2 = n ? O(o, u, n, g2.create(h.NA)) : void 0, d2 = s ? O(o, u, s, g2.create(h.NA)) : void 0, _2 = c.mapValue((C, E, R) => {
      if (C.isError())
        return C;
      const b = l ? l.get(E, R) : void 0;
      if (b != null && b.isError())
        return b;
      const p2 = f2 ? f2.get(E, R) : void 0;
      if (p2 != null && p2.isError())
        return p2;
      const V = m2 ? m2.get(E, R) : void 0;
      if (V != null && V.isError())
        return V;
      const S2 = d2 ? d2.get(E, R) : void 0;
      return S2 != null && S2.isError() ? S2 : this._handleSingleObject(C, b, p2, V, S2);
    });
    return o === 1 && u === 1 ? _2.get(0, 0) : _2;
  }
  // eslint-disable-next-line complexity
  _handleSingleObject(e, t, r, n, s) {
    if (!e.isString())
      return g2.create(h.VALUE);
    const o = e.getValue();
    let u = "";
    t && (t.isBoolean() ? u = t.getValue() ? "TRUE" : "FALSE" : t.isNull() || (u = `${t.getValue()}`));
    let c = r != null ? r : y2.create(0);
    if (c.isString() && (c = c.convertToNumberObjectValue()), c.isError())
      return c;
    const l = Math.abs(Math.trunc(+c.getValue()));
    if (l < 0 || l > 3 || [0, 1, 2].includes(l) && (n || s))
      return g2.create(h.VALUE);
    let f2 = n != null ? n : y2.create(0);
    if (f2.isString() && (f2 = f2.convertToNumberObjectValue()), f2.isError())
      return f2;
    const m2 = Math.ceil(+f2.getValue());
    let d2 = s != null ? s : y2.create(0);
    if (d2.isString() && (d2 = d2.convertToNumberObjectValue()), d2.isError())
      return d2;
    const _2 = Math.ceil(+d2.getValue());
    return l === 3 && m2 < 1 && _2 < 1 ? g2.create(h.VALUE) : U2.create("", {
      isImage: true,
      imageInfo: {
        source: o,
        altText: u,
        sizing: l,
        height: m2,
        width: _2
      }
    });
  }
};
var wC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 4);
    A(this, "needsReferenceObject", true);
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  calculate(e, t, r, n) {
    if (e.isError())
      return e;
    const s = this._getReferenceCounts(e);
    let o = t;
    t.isReferenceObject() && (o = t.toArrayValueObject());
    let u = r;
    u != null && u.isReferenceObject() && (u = r.toArrayValueObject());
    let c = n != null ? n : y2.create(1);
    c.isReferenceObject() && (c = n.toArrayValueObject());
    const l = Math.max(
      o.isArray() ? o.getRowCount() : 1,
      u != null && u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f2 = Math.max(
      o.isArray() ? o.getColumnCount() : 1,
      u != null && u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    );
    if (l === 1 && f2 === 1)
      return this._handleSingleObject(
        e,
        o.isArray() ? o.get(0, 0) : o,
        u ? u.isArray() ? u.get(0, 0) : u : void 0,
        c.isArray() ? c.get(0, 0) : c,
        s
      );
    {
      const m2 = O(l, f2, o, g2.create(h.NA)), d2 = u ? O(l, f2, u, g2.create(h.NA)) : [], _2 = O(l, f2, c, g2.create(h.NA));
      return m2.mapValue((C, E, R) => {
        const b = u ? d2.get(E, R) : void 0, p2 = _2.get(E, R), V = this._handleSingleObject(e, C, b, p2, s);
        return V.isReferenceObject() ? V.getCellByPosition() : V;
      });
    }
  }
  _handleSingleObject(e, t, r, n, s) {
    let o, u, c;
    if (r) {
      const { isError: C, errorObject: E, variants: R } = I2(t, r, n);
      if (C)
        return E;
      o = R[0], u = R[1], c = R[2];
    } else {
      const { isError: C, errorObject: E, variants: R } = I2(t, n);
      if (C)
        return E;
      o = R[0], c = R[1];
    }
    const l = Math.floor(+c.getValue());
    if (l < 0)
      return g2.create(h.VALUE);
    if (l > s.length)
      return g2.create(h.REF);
    const f2 = s[l - 1];
    let m2 = 0, d2 = 0;
    if (f2.rowCount === 1 && !r ? d2 = Math.floor(+o.getValue()) : (m2 = Math.floor(+o.getValue()), r && (d2 = Math.floor(+u.getValue()))), m2 < 0 || d2 < 0)
      return g2.create(h.VALUE);
    if (m2 > f2.rowCount || d2 > f2.columnCount)
      return g2.create(h.REF);
    let _2 = e;
    return l > 1 && (_2 = e.getCubeValues()[l - 1]), _2.isReferenceObject() ? this._calculateReferenceObject(_2, m2, d2) : this._calculateArrayObject(_2, m2, d2);
  }
  _getReferenceCounts(e) {
    let t = [
      {
        rowCount: 1,
        columnCount: 1
      }
    ];
    return e.isReferenceObject() ? t = [
      {
        rowCount: e.getRowCount(),
        columnCount: e.getColumnCount()
      }
    ] : e.isCube() ? t = e.getCubeValues().map((r) => ({
      rowCount: r.getRowCount(),
      columnCount: r.getColumnCount()
    })) : e.isArray() && (t = [
      {
        rowCount: e.getRowCount(),
        columnCount: e.getColumnCount()
      }
    ]), t;
  }
  _calculateReferenceObject(e, t, r) {
    const { startRow: n, endRow: s, startColumn: o, endColumn: u } = e.getRangePosition();
    let c = 0, l = 0, f2 = 0, m2 = 0;
    if (t === 0 ? (c = n, l = s) : c = l = n + t - 1, r === 0 ? (f2 = o, m2 = u) : f2 = m2 = o + r - 1, c > s || f2 > u)
      return g2.create(h.REF);
    const d2 = {
      startRow: c,
      startColumn: f2,
      endRow: l,
      endColumn: m2
    };
    return this.createReferenceObject(e, d2);
  }
  _calculateArrayObject(e, t, r) {
    return !e.isArray() || t === 0 && r === 0 ? e : t === 0 ? e.slice(void 0, [r - 1, r]) : r === 0 ? e.slice([t - 1, t], void 0) : e.get(t - 1, r - 1);
  }
};
var LC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  isAddress() {
    return true;
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t != null && t.isError())
      return t;
    let r = this.getZeroOrOneByOneDefault(t);
    r == null && (r = 1);
    let n = e;
    if (e.isArray()) {
      const s = e.getRowCount(), o = e.getColumnCount();
      if (s > 1 || o > 1)
        return e.map(() => g2.create(h.VALUE));
      n = e.getFirstCell();
    }
    return this._handleSingleObject(n, r);
  }
  _handleSingleObject(e, t) {
    const r = `${e.getValue()}`;
    if (r.trim() === "")
      return g2.create(h.REF);
    const n = this._convertToDefinedName(r);
    if (t === 0) {
      const f2 = wh(n), { range: m2, sheetName: d2, unitId: _2 } = f2, C = new xn(m2);
      return C.setForcedUnitIdDirect(_2), C.setForcedSheetName(d2), this._setDefault(C);
    }
    if (qr(n))
      return this._setDefault(new Ma(n));
    if (_o(n))
      return this._setDefault(new wa(n));
    if (Ao(n))
      return this._setDefault(new Da(n));
    const s = br2(n), { range: o, sheetName: u, unitId: c } = s;
    if (Number.isNaN(o.startRow) || o.endRow + 1 > 1048576 || Number.isNaN(o.startColumn) || o.endColumn + 1 > 16384)
      return g2.create(h.REF);
    const l = new xn(o);
    return l.setForcedUnitIdDirect(c), l.setForcedSheetName(u), this._setDefault(l);
  }
  _setDefault(e) {
    return this.unitId == null || this.subUnitId == null ? g2.create(h.REF) : (e.setDefaultUnitId(this.unitId), e.setDefaultSheetId(this.subUnitId), e);
  }
  /**
   * In Excel, to inject a defined name into a function that has positioning capabilities,
   * such as using the INDIRECT function to reference a named range,
   * you can write it as follows:
   * =INDIRECT("DefinedName1")
   */
  _convertToDefinedName(e) {
    const t = this.getDefinedName(e);
    if (t == null)
      return e;
    const r = t.formulaOrRefString;
    return r == null ? e : r.startsWith(Z3.EQUALS) ? r.slice(1) : r;
  }
};
var PC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
    A(this, "needsExpandParams", true);
  }
  calculate(e, t, r) {
    return e.isError() ? e : t.isError() ? g2.create(h.REF) : t.isArray() ? r != null && r.isError() ? r : t.getColumnCount() === 1 || t.getRowCount() === 1 ? r != null && !r.isArray() ? g2.create(h.REF) : this._handleVector(e, t, r) : this._handleArray(e, t) : g2.create(h.VALUE);
  }
  _handleVector(e, t, r) {
    let n = r;
    if (n == null)
      n = t;
    else if (n.getRowCount() !== t.getRowCount() || n.getColumnCount() !== t.getColumnCount())
      return g2.create(h.REF);
    return e.isArray() ? e.map((s) => this.binarySearch(s, t, n)) : this.binarySearch(e, t, n);
  }
  _handleArray(e, t) {
    const r = t.getRowCount(), n = t.getColumnCount();
    let s, o;
    return n > r ? (s = t.slice([0, 1]), o = t.slice([r - 1, r])) : (s = t.slice(void 0, [0, 1]), o = t.slice(void 0, [n - 1, n])), s == null || o == null ? g2.create(h.VALUE) : e.isArray() ? e.map((u) => this.binarySearch(u, s, o)) : this.binarySearch(e, s, o);
  }
};
var xC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    if (e.isError())
      return e;
    if (t.isError())
      return g2.create(h.REF);
    if (!t.isArray())
      return g2.create(h.VALUE);
    const n = t.getRowCount(), s = t.getColumnCount();
    if (n !== 1 && s !== 1 || r != null && r.isError())
      return g2.create(h.NA);
    const o = this.getMatchTypeValue(r);
    return o == null ? g2.create(h.VALUE) : e.isArray() ? e.map((u) => this._handleSingleObject(
      u,
      t,
      o
    )) : this._handleSingleObject(
      e,
      t,
      o
    );
  }
  _handleSingleObject(e, t, r) {
    const n = e.isNull() ? y2.create(0) : e, s = this._getSearchModeValue(r), o = t.orderSearch(n, s);
    if (o == null)
      return g2.create(h.NA);
    if (o instanceof g2)
      return o;
    const u = t.getRowCount() === 1 ? o.column + 1 : o.row + 1;
    return y2.create(u);
  }
  _getSearchModeValue(e) {
    switch (e) {
      case 1:
        return xe.MIN;
      case 0:
        return xe.NORMAL;
      case -1:
        return xe.MAX;
    }
  }
};
var jC = class extends jr {
  constructor(e, t = []) {
    super(e);
    A(this, "_areas", []);
    this._areas = t;
  }
  dispose() {
    this._areas.forEach((e) => {
      e.forEach((t) => t.dispose());
    }), this._areas = [], super.dispose();
  }
  // ------------------------------------------------------------
  // Area Management
  // ------------------------------------------------------------
  getAreas() {
    return this._areas;
  }
  setAreas(e) {
    this._areas = e;
  }
  /**
   * Append an area:
   * - If a single AreaValue is passed, it will be wrapped as one row.
   * - If an AreaValue[] is passed, it will be inserted as an entire row.
   */
  addArea(e) {
    Array.isArray(e) ? this._areas.push(e) : this._areas.push([e]);
  }
  /** Flatten the 2D areas to reuse 1D logic */
  _flatAreas() {
    return this._areas.flat();
  }
  // ------------------------------------------------------------
  // Multi-area identification
  // ------------------------------------------------------------
  isMultiArea() {
    return true;
  }
  isRange() {
    return false;
  }
  isCell() {
    return false;
  }
  isRow() {
    return false;
  }
  isColumn() {
    return false;
  }
  // ------------------------------------------------------------
  // Range-related queries
  // ------------------------------------------------------------
  getRowCount() {
    let e = 0;
    for (const t of this._flatAreas())
      t.isError() || (e += t.getRowCount());
    return e;
  }
  getColumnCount() {
    let e = 0;
    for (const t of this._flatAreas())
      t.isError() || (e += t.getColumnCount());
    return e;
  }
  isExceedRange() {
    return this._flatAreas().some((e) => e.isError() ? false : e.isExceedRange());
  }
  setRefOffset(e = 0, t = 0) {
    super.setRefOffset(e, t), this._flatAreas().forEach((r) => {
      r.isError() || r.setRefOffset(e, t);
    });
  }
  _getReferenceArea() {
    return this._flatAreas().find((r) => !r.isError());
  }
  // ------------------------------------------------------------
  // Unit/Sheet resolution
  // ------------------------------------------------------------
  /**
   * Multi-area reference may span multiple sheets, but Excel requires
   * them to be in the same sheet for most functions. We follow Excel semantics
   * by returning the first area’s identifiers.
   */
  getUnitId() {
    var e, t;
    return (t = (e = this._getReferenceArea()) == null ? void 0 : e.getUnitId()) != null ? t : super.getUnitId();
  }
  getSheetId() {
    var e, t;
    return (t = (e = this._getReferenceArea()) == null ? void 0 : e.getSheetId()) != null ? t : super.getSheetId();
  }
  getActiveSheetRowCount() {
    var e, t;
    return (t = (e = this._getReferenceArea()) == null ? void 0 : e.getActiveSheetRowCount()) != null ? t : 0;
  }
  getActiveSheetColumnCount() {
    var e, t;
    return (t = (e = this._getReferenceArea()) == null ? void 0 : e.getActiveSheetColumnCount()) != null ? t : 0;
  }
  // ------------------------------------------------------------
  // Cell traversal
  // ------------------------------------------------------------
  /**
   * Iterate through all areas in order, flattening the multi-area into
   * a sequence of cells.
   *
   * Note: The order here is "row-major":
   *   iterate by the row order of _areas, then within each row by the area order.
   */
  iterator(e) {
    for (const t of this._areas) {
      let r = false;
      for (const n of t) {
        if (n.isError())
          continue;
        let s = false;
        if (n.iterator((o, u, c) => {
          const l = e(o, u, c);
          return l === false ? (s = true, r = true, false) : l;
        }), s)
          break;
      }
      if (r)
        return;
    }
  }
  /**
   * Excel defines the "first cell" of a multi-area reference
   * as the first cell of the first area.
   */
  getFirstCell() {
    const e = this._getReferenceArea();
    return e ? e.getFirstCell() : super.getFirstCell();
  }
  // ------------------------------------------------------------
  // Conversion to Array or Cube
  // ------------------------------------------------------------
  /**
   * For multi-area, we only take the *first cell* of each area and
   * arrange them into a 2D ArrayValueObject:
   *
   * - outer `_areas` dimension => rows
   * - inner `_areas[row]` dimension => columns
   */
  toArrayValueObject() {
    var n, s;
    const e = this._areas.length;
    if (e === 0)
      return mt([], 0, 0);
    const t = (s = (n = this._areas[0]) == null ? void 0 : n.length) != null ? s : 0, r = [];
    for (let o = 0; o < e; o++) {
      const u = this._areas[o];
      if (u) {
        r[o] = r[o] || [];
        for (let c = 0; c < t; c++) {
          const l = u[c];
          if (!l)
            continue;
          if (l.isError()) {
            r[o][c] = l;
            continue;
          }
          let f2 = null;
          l.iterator((m2) => (f2 = m2 != null ? m2 : null, false)), f2 != null && (r[o][c] = f2), r[o][c] = ce.create();
        }
      }
    }
    return mt(r, e, t);
  }
  getRangePosition() {
    const e = this._flatAreas();
    if (!e.length)
      return super.getRangePosition();
    let t = Number.POSITIVE_INFINITY, r = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY, s = Number.NEGATIVE_INFINITY;
    for (const o of e) {
      if (o.isError())
        continue;
      const { startRow: u, startColumn: c, endRow: l, endColumn: f2 } = o.getRangePosition();
      !Number.isFinite(u) || !Number.isFinite(c) || !Number.isFinite(l) || !Number.isFinite(f2) || (u < t && (t = u), c < r && (r = c), l > n && (n = l), f2 > s && (s = s < f2 ? f2 : s));
    }
    return !Number.isFinite(t) || !Number.isFinite(r) || !Number.isFinite(n) || !Number.isFinite(s) ? super.getRangePosition() : {
      startRow: t,
      startColumn: r,
      endRow: n,
      endColumn: s
    };
  }
  toUnitRange() {
    return {
      range: this.getRangePosition(),
      sheetId: this.getSheetId(),
      unitId: this.getUnitId()
    };
  }
  getRangeData() {
    const e = this._flatAreas();
    if (!e.length)
      return super.getRangeData();
    let t = Number.POSITIVE_INFINITY, r = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY, s = Number.NEGATIVE_INFINITY;
    for (const o of e) {
      if (o.isError())
        continue;
      const { startRow: u, startColumn: c, endRow: l, endColumn: f2 } = o.getRangeData();
      !Number.isFinite(u) || !Number.isFinite(c) || !Number.isFinite(l) || !Number.isFinite(f2) || (u < t && (t = u), c < r && (r = c), l > n && (n = l), f2 > s && (s = f2));
    }
    return !Number.isFinite(t) || !Number.isFinite(r) || !Number.isFinite(n) || !Number.isFinite(s) ? super.getRangeData() : {
      startRow: t,
      startColumn: r,
      endRow: n,
      endColumn: s
    };
  }
};
var UC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 5);
    A(this, "needsReferenceObject", true);
  }
  isAddress() {
    return true;
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  calculate(e, t, r, n, s) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (r.isError())
      return r;
    if (n != null && n.isError())
      return n;
    if (s != null && s.isError())
      return s;
    if (!e.isReferenceObject())
      return g2.create(h.VALUE);
    const o = e.getRowCount(), u = e.getColumnCount();
    let c = t;
    c.isReferenceObject() && (c = c.toArrayValueObject());
    let l = r;
    l.isReferenceObject() && (l = l.toArrayValueObject());
    let f2 = n != null ? n : y2.create(o);
    f2.isReferenceObject() && (f2 = f2.toArrayValueObject()), f2.isNull() && (f2 = y2.create(o));
    let m2 = s != null ? s : y2.create(u);
    m2.isReferenceObject() && (m2 = m2.toArrayValueObject()), m2.isNull() && (m2 = y2.create(u));
    const d2 = Math.max(
      c.isArray() ? c.getRowCount() : 1,
      l.isArray() ? l.getRowCount() : 1,
      f2.isArray() ? f2.getRowCount() : 1,
      m2.isArray() ? m2.getRowCount() : 1
    ), _2 = Math.max(
      c.isArray() ? c.getColumnCount() : 1,
      l.isArray() ? l.getColumnCount() : 1,
      f2.isArray() ? f2.getColumnCount() : 1,
      m2.isArray() ? m2.getColumnCount() : 1
    );
    if (c = c, l = l, f2 = f2, m2 = m2, d2 === 1 && _2 === 1)
      return c = c.isArray() ? c.get(0, 0) : c, l = l.isArray() ? l.get(0, 0) : l, f2 = f2.isArray() ? f2.get(0, 0) : f2, m2 = m2.isArray() ? m2.get(0, 0) : m2, this._handleSingleObject(e, c, l, f2, m2);
    const C = O(d2, _2, c, g2.create(h.NA)), E = O(d2, _2, l, g2.create(h.NA)), R = O(d2, _2, f2, g2.create(h.NA)), b = O(d2, _2, m2, g2.create(h.NA)), p2 = [];
    return C.iterator((V, S2, M2) => {
      const D2 = E.get(S2, M2), w = R.get(S2, M2), L = b.get(S2, M2);
      if (p2[S2] = p2[S2] || [], V == null) {
        p2[S2][M2] = g2.create(h.NA);
        return;
      }
      if (V.isError()) {
        p2[S2][M2] = V;
        return;
      }
      if (D2.isError()) {
        p2[S2][M2] = D2;
        return;
      }
      if (w.isError()) {
        p2[S2][M2] = w;
        return;
      }
      if (L.isError()) {
        p2[S2][M2] = L;
        return;
      }
      const v = this._handleSingleObject(e, V, D2, w, L);
      p2[S2][M2] = v;
    }), new jC("", p2);
  }
  // eslint-disable-next-line
  _handleSingleObject(e, t, r, n, s) {
    const { startRow: o, startColumn: u } = e.getRangePosition();
    let c = t;
    if (c.isString() && (c = c.convertToNumberObjectValue()), c.isError())
      return c;
    let l = r;
    if (l.isString() && (l = l.convertToNumberObjectValue()), l.isError())
      return l;
    const f2 = +c.getValue(), m2 = +l.getValue();
    if (typeof f2 != "number" || typeof m2 != "number")
      return g2.create(h.VALUE);
    const d2 = o + f2, _2 = u + m2;
    if (d2 < 0 || _2 < 0)
      return g2.create(h.REF);
    const C = this.getIndexNumValue(n), E = this.getIndexNumValue(s);
    if (typeof C != "number" || typeof E != "number")
      return g2.create(h.VALUE);
    if (C === 0 || E === 0)
      return g2.create(h.REF);
    const R = C > 0 ? d2 + C - 1 : d2 + C + 1, b = E > 0 ? _2 + E - 1 : _2 + E + 1;
    if (R < 0 || b < 0)
      return g2.create(h.REF);
    const p2 = d2 < R ? d2 : R, V = _2 < b ? _2 : b, S2 = d2 > R ? d2 : R, M2 = _2 > b ? _2 : b, D2 = {
      startRow: p2,
      startColumn: V,
      endRow: S2,
      endColumn: M2
    };
    return this.createReferenceObject(e, D2);
  }
};
var vC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e == null)
      return y2.create(this.row + 1);
    if (e.isError())
      return e;
    if (!e.isArray())
      return g2.create(h.NA);
    const t = e.getCurrentRow(), r = e.getRowCount(), n = [];
    for (let o = 0; o < r; o++)
      n.push([y2.create(t + o + 1)]);
    const s = {
      calculateValueList: n,
      rowCount: r,
      columnCount: 1,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    };
    return K2.create(s);
  }
};
var TC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isError())
      return e;
    if (e.isString() || e.isNumber() || e.isBoolean())
      return y2.create(1);
    if (!e.isArray())
      return g2.create(h.NA);
    const t = e.getRowCount();
    return y2.create(t);
  }
};
var IC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    let s = t != null ? t : y2.create(1);
    const o = r != null ? r : y2.create(1), u = n != null ? n : T.create(false);
    if (s.isNull() && (s = y2.create(1)), u.isArray()) {
      const c = u.getRowCount(), l = u.getColumnCount();
      if (c === 1 && l === 1) {
        const f2 = u.get(0, 0);
        return this._handleSingleObject(e, s, o, f2);
      }
      return u.map((f2) => {
        const m2 = this._handleSingleObject(e, s, o, f2);
        return m2.isArray() ? m2.get(0, 0) : m2;
      });
    }
    return this._handleSingleObject(e, s, o, u);
  }
  _handleSingleObject(e, t, r, n) {
    if (e.isError())
      return e;
    const s = e.isArray() ? e.getRowCount() : 1, o = e.isArray() ? e.getColumnCount() : 1, u = this._checkArrayError(t);
    if (u.isError())
      return u;
    const c = Math.floor(+u.getValue());
    if (c < 1)
      return g2.create(h.VALUE);
    const l = this._checkArrayError(r);
    if (l.isError())
      return l;
    const f2 = Math.floor(+l.getValue());
    if (f2 !== -1 && f2 !== 1)
      return g2.create(h.VALUE);
    let m2 = n;
    if (m2.isString() && (m2 = m2.convertToNumberObjectValue()), m2.isError())
      return m2;
    if (!e.isArray() || s === 1 && o === 1)
      return e;
    const d2 = +m2.getValue();
    return this._getResult(e, c, f2, d2, s, o);
  }
  _checkArrayError(e) {
    let t = e;
    if (t.isArray()) {
      const r = t.getRowCount(), n = t.getColumnCount();
      if (r > 1 || n > 1)
        return g2.create(h.VALUE);
      t = t.get(0, 0);
    }
    return t.isString() && (t = t.convertToNumberObjectValue()), t;
  }
  _getResult(e, t, r, n, s, o) {
    if (n) {
      if (t > s)
        return g2.create(h.VALUE);
      const u = e.transpose().getArrayValue();
      return u.sort(this._sort(t - 1, r)), K2.create({
        calculateValueList: u,
        rowCount: u.length,
        columnCount: u[0].length || 0,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      }).transpose();
    } else {
      if (t > o)
        return g2.create(h.VALUE);
      const u = e.getArrayValue();
      return u.sort(this._sort(t - 1, r)), K2.create({
        calculateValueList: u,
        rowCount: u.length,
        columnCount: u[0].length || 0,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      });
    }
  }
  _sort(e, t = 1) {
    const r = Dn();
    return t === 1 ? this._sortAsc(e, r) : this._sortDesc(e, r);
  }
  _sortAsc(e, t) {
    return (r, n) => {
      const s = r[e], o = n[e];
      if (s == null || s.isNull())
        return 1;
      if (o == null || o.isNull())
        return -1;
      if (s.isError() && o.isError())
        return 0;
      if (s.isError())
        return 1;
      if (o.isError())
        return -1;
      const u = s.getValue(), c = o.getValue();
      return s.isBoolean() && u === true ? 1 : o.isBoolean() && c === true ? -1 : s.isBoolean() && u === false ? 1 : o.isBoolean() && c === false ? -1 : s.isNumber() && o.isNumber() ? +u - +c : t(
        u,
        c
      );
    };
  }
  _sortDesc(e, t) {
    return (r, n) => {
      const s = r[e], o = n[e];
      if (s == null || s.isNull())
        return 1;
      if (o == null || o.isNull())
        return -1;
      if (s.isError() && o.isError())
        return 0;
      if (s.isError())
        return -1;
      if (o.isError())
        return 1;
      const u = s.getValue(), c = o.getValue();
      return s.isBoolean() && u === true ? -1 : o.isBoolean() && c === true ? 1 : s.isBoolean() && u === false ? -1 : o.isBoolean() && c === false ? 1 : s.isNumber() && o.isNumber() ? +c - +u : t(
        c,
        u
      );
    };
  }
};
var BC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
  }
  calculate(e, ...t) {
    t.length === 1 && t.push(y2.create(1));
    const r = this._getVariantsError(e, ...t), { maxRowLength: n, maxColumnLength: s } = wm(t);
    if (r.isError()) {
      const c = O(n, s, r);
      return n === 1 && s === 1 ? c.get(0, 0) : c;
    }
    const o = t.map((c, l) => l % 2 === 0 ? c : O(n, s, c, g2.create(h.NA))), u = this._getResultArray(e, o, n, s);
    return n === 1 && s === 1 ? u[0][0] : K2.create({
      calculateValueList: u,
      rowCount: u.length,
      columnCount: u[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
  // eslint-disable-next-line complexity
  _getVariantsError(e, ...t) {
    if (e.isError())
      return e;
    for (let u = 0; u < t.length; u++) {
      const c = t[u];
      if (c.isError())
        return c;
    }
    if (t.length < 2 || t.length % 2 !== 0)
      return g2.create(h.VALUE);
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t[0].isArray() ? t[0].getRowCount() : 1, o = t[0].isArray() ? t[0].getColumnCount() : 1;
    if ((s > 1 || o > 1) && (s > 1 && o > 1 || s === 1 && o !== n || o === 1 && s !== r))
      return g2.create(h.VALUE);
    for (let u = 2; u < t.length; u++) {
      if (u % 2 === 1)
        continue;
      const c = t[u].isArray() ? t[u].getRowCount() : 1, l = t[u].isArray() ? t[u].getColumnCount() : 1;
      if (c !== s || l !== o)
        return g2.create(h.VALUE);
    }
    return T.create(true);
  }
  _getResultArray(e, t, r, n) {
    const s = e.isArray() ? e.getRowCount() : 1, o = e.isArray() ? e.getColumnCount() : 1, u = t[0].isArray() ? t[0].getRowCount() : 1, c = t[0].isArray() ? t[0].getColumnCount() : 1, l = [];
    for (let f2 = 0; f2 < r; f2++) {
      l[f2] = [];
      for (let m2 = 0; m2 < n; m2++) {
        const { isError: d2, errorObject: _2, byArrays: C, sortOrders: E } = this._getByArraysAndSortOrders(t, f2, m2, c);
        if (d2) {
          l[f2].push(_2);
          continue;
        }
        if (!e.isArray() || s === 1 && o === 1) {
          l[f2].push(e);
          continue;
        }
        let R = e.getArrayValue();
        u === 1 && c === 1 || (u === 1 ? (R = R.concat(C), R = this._transposeArray(R), R.sort(this._sort(s, E)), R = this._transposeArray(R).slice(0, s)) : c === 1 && (R = this._transposeArray(R), R = R.concat(C), R = this._transposeArray(R), R.sort(this._sort(o, E)), R = R.map((p2) => p2.slice(0, o))));
        const b = K2.create({
          calculateValueList: R,
          rowCount: R.length,
          columnCount: R[0].length || 0,
          unitId: this.unitId,
          sheetId: this.subUnitId,
          row: this.row,
          column: this.column
        });
        if (r > 1 || n > 1) {
          l[f2].push(b.get(0, 0));
          continue;
        }
        l[f2].push(b);
      }
    }
    return l;
  }
  _getByArraysAndSortOrders(e, t, r, n) {
    const s = [], o = [];
    let u = false, c = null;
    for (let l = 0; l < e.length; l++) {
      if (l % 2 === 1)
        continue;
      const f2 = e[l];
      let m2 = e[l + 1].get(t, r);
      if (m2.isString() && (m2 = m2.convertToNumberObjectValue()), m2.isError()) {
        u = true, c = m2;
        break;
      }
      const d2 = Math.floor(+m2.getValue());
      if (d2 !== -1 && d2 !== 1) {
        u = true, c = g2.create(h.VALUE);
        break;
      }
      if (o.push(d2), f2.isArray()) {
        let _2 = f2.getArrayValue();
        n === 1 && (_2 = this._transposeArray(_2)), s.push(_2[0]);
      } else
        s.push([f2]);
    }
    return {
      isError: u,
      errorObject: c,
      byArrays: s,
      sortOrders: o
    };
  }
  _transposeArray(e) {
    const t = e.length, r = e[0].length, n = [];
    for (let s = 0; s < r; s++) {
      n[s] = [];
      for (let o = 0; o < t; o++)
        n[s][o] = e[o][s];
    }
    return n;
  }
  _sort(e, t) {
    const r = Dn();
    return (n, s) => {
      let o = n[e], u = s[e], c = this._compare(o, u, t[0], r);
      if (c === 0 && t.length > 1) {
        for (let l = 1; l < t.length; l++)
          if (o = n[e + l], u = s[e + l], c = this._compare(o, u, t[l], r), c !== 0)
            return c;
      }
      return c;
    };
  }
  _compare(e, t, r, n) {
    return r === 1 ? this._asc(e, t, n) : this._desc(e, t, n);
  }
  _asc(e, t, r) {
    if (e == null || e.isNull())
      return 1;
    if (t == null || t.isNull())
      return -1;
    if (e.isError() && t.isError())
      return 0;
    if (e.isError())
      return 1;
    if (t.isError())
      return -1;
    const n = e.getValue(), s = t.getValue();
    return e.isBoolean() && n === true ? 1 : t.isBoolean() && s === true ? -1 : e.isBoolean() && n === false ? 1 : t.isBoolean() && s === false ? -1 : e.isNumber() && t.isNumber() ? +n - +s : r(
      n,
      s
    );
  }
  _desc(e, t, r) {
    if (e == null || e.isNull())
      return 1;
    if (t == null || t.isNull())
      return -1;
    if (e.isError() && t.isError())
      return 0;
    if (e.isError())
      return -1;
    if (t.isError())
      return 1;
    const n = e.getValue(), s = t.getValue();
    return e.isBoolean() && n === true ? -1 : t.isBoolean() && s === true ? 1 : e.isBoolean() && n === false ? -1 : t.isBoolean() && s === false ? 1 : e.isNumber() && t.isNumber() ? +s - +n : r(
      s,
      n
    );
  }
};
var FC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = e.isArray() ? e.getRowCount() : 1, s = e.isArray() ? e.getColumnCount() : 1;
    let o = t, u = r != null ? r : y2.create(s);
    t.isNull() && (o = y2.create(n)), u.isNull() && (u = y2.create(s));
    const c = Math.max(
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1
    ), l = Math.max(
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1
    ), f2 = O(c, l, o, g2.create(h.NA)), m2 = O(c, l, u, g2.create(h.NA));
    if (c > 1 || l > 1)
      return f2.mapValue((p2, V, S2) => {
        const M2 = m2.get(V, S2);
        if (e.isError())
          return e;
        if (e.isNull())
          return g2.create(h.VALUE);
        const { isError: D2, errorObject: w } = this._checkRowsColumns(p2, M2, n, s);
        return D2 ? w : e.isArray() ? g2.create(h.VALUE) : e;
      });
    if (e.isError())
      return e;
    if (e.isNull())
      return g2.create(h.VALUE);
    const d2 = o.isArray() ? o.get(0, 0) : o, _2 = u.isArray() ? u.get(0, 0) : u, { isError: C, errorObject: E, rowsValue: R, columnsValue: b } = this._checkRowsColumns(d2, _2, n, s);
    return C ? E : this._getResultArray(e, R, b, n, s);
  }
  _checkRowsColumns(e, t, r, n) {
    if (e.isError())
      return {
        isError: true,
        errorObject: e
      };
    if (t.isError())
      return {
        isError: true,
        errorObject: t
      };
    let s = Math.trunc(+e.getValue()), o = Math.trunc(+t.getValue());
    return Number.isNaN(s) || Number.isNaN(o) ? {
      isError: true,
      errorObject: g2.create(h.VALUE)
    } : Math.abs(s) === 0 || Math.abs(o) === 0 ? {
      isError: true,
      errorObject: g2.create(h.CALC)
    } : (s > r && (s = r), o > n && (o = n), {
      isError: false,
      rowsValue: s,
      columnsValue: o
    });
  }
  _getResultArray(e, t, r, n, s) {
    if (!e.isArray())
      return e;
    const o = t >= 0 ? [0, t] : [n + t, n], u = r >= 0 ? [0, r] : [s + r, s];
    let c;
    return t === n && r === s ? c = e : t === n ? c = e.slice(void 0, u) : r === s ? c = e.slice(o, void 0) : c = e.slice(o, u), c = c.map((l) => l.isNull() ? y2.create(0) : l), t === 1 && r === 1 ? c.get(0, 0) : c;
  }
};
var kC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = t != null ? t : y2.create(0), s = r != null ? r : T.create(false), o = Math.max(
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, n, g2.create(h.NA)), l = O(o, u, s, g2.create(h.NA)), f2 = c.mapValue((m2, d2, _2) => {
      const C = l.get(d2, _2);
      if (e.isError())
        return e;
      if (e.isNull())
        return g2.create(h.VALUE);
      if (m2.isError())
        return m2;
      if (C.isError())
        return C;
      const E = Math.trunc(+m2.getValue()), R = +C.getValue();
      if (Number.isNaN(E) || E < 0 || E > 3 || Number.isNaN(R))
        return g2.create(h.VALUE);
      if (!e.isArray())
        return e;
      let b = [];
      return R ? b = this._getArrayValueByColumn(e, E) : b = this._getArrayValueByRow(e, E), b.length === 0 ? g2.create(h.CALC) : o > 1 || u > 1 || b.length === 1 ? b[0] : K2.create({
        calculateValueList: b.map((p2) => [p2]),
        rowCount: b.length,
        columnCount: 1,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      });
    });
    return o === 1 && u === 1 ? f2.get(0, 0) : f2;
  }
  _getArrayValueByColumn(e, t) {
    const r = e, n = r.getRowCount(), s = r.getColumnCount(), o = [];
    for (let u = 0; u < s; u++)
      for (let c = 0; c < n; c++) {
        const l = r.get(c, u);
        this._isIgnore(l, t) || o.push(l.isNull() ? y2.create(0) : l);
      }
    return o;
  }
  _getArrayValueByRow(e, t) {
    const r = e, n = r.getRowCount(), s = r.getColumnCount(), o = [];
    for (let u = 0; u < n; u++)
      for (let c = 0; c < s; c++) {
        const l = r.get(u, c);
        this._isIgnore(l, t) || o.push(l.isNull() ? y2.create(0) : l);
      }
    return o;
  }
  _isIgnore(e, t) {
    switch (t) {
      case 0:
        return false;
      case 1:
        return e.isNull();
      case 2:
        return e.isError();
      case 3:
        return e.isNull() || e.isError();
      default:
        return false;
    }
  }
};
var $C = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = t != null ? t : y2.create(0), s = r != null ? r : T.create(false), o = Math.max(
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, n, g2.create(h.NA)), l = O(o, u, s, g2.create(h.NA)), f2 = c.mapValue((m2, d2, _2) => {
      const C = l.get(d2, _2);
      if (e.isError())
        return e;
      if (m2.isError())
        return m2;
      if (C.isError())
        return C;
      const E = Math.trunc(+m2.getValue()), R = +C.getValue();
      if (Number.isNaN(E) || E < 0 || E > 3 || Number.isNaN(R) || e.isNull())
        return g2.create(h.VALUE);
      if (!e.isArray())
        return e;
      let b = [];
      return R ? b = this._getArrayValueByColumn(e, E) : b = this._getArrayValueByRow(e, E), b.length === 0 ? g2.create(h.CALC) : o > 1 || u > 1 || b.length === 1 ? b[0] : K2.create({
        calculateValueList: [b],
        rowCount: 1,
        columnCount: b.length,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      });
    });
    return o === 1 && u === 1 ? f2.get(0, 0) : f2;
  }
  _getArrayValueByColumn(e, t) {
    const r = e, n = r.getRowCount(), s = r.getColumnCount(), o = [];
    for (let u = 0; u < s; u++)
      for (let c = 0; c < n; c++) {
        const l = r.get(c, u);
        this._isIgnore(l, t) || o.push(l.isNull() ? y2.create(0) : l);
      }
    return o;
  }
  _getArrayValueByRow(e, t) {
    const r = e, n = r.getRowCount(), s = r.getColumnCount(), o = [];
    for (let u = 0; u < n; u++)
      for (let c = 0; c < s; c++) {
        const l = r.get(u, c);
        this._isIgnore(l, t) || o.push(l.isNull() ? y2.create(0) : l);
      }
    return o;
  }
  _isIgnore(e, t) {
    switch (t) {
      case 0:
        return false;
      case 1:
        return e.isNull();
      case 2:
        return e.isError();
      case 3:
        return e.isNull() || e.isError();
      default:
        return false;
    }
  }
};
var YC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isError())
      return e;
    if (e.isArray()) {
      const t = e.getRowCount(), r = e.getColumnCount();
      return t === 1 && r === 1 ? e.get(0, 0) : e.transpose();
    }
    return e;
  }
};
var HC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = t != null ? t : T.create(false), s = r != null ? r : T.create(false), o = e.isArray() ? e.getRowCount() : 1, u = e.isArray() ? e.getColumnCount() : 1, c = Math.max(
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), l = Math.max(
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), f2 = O(c, l, n, g2.create(h.NA)), m2 = O(c, l, s, g2.create(h.NA)), d2 = f2.map((_2, C, E) => {
      let R = _2, b = m2.get(C, E);
      if (e.isError())
        return e;
      if (R.isString() && (R = R.convertToNumberObjectValue()), R.isError())
        return R;
      if (b.isString() && (b = b.convertToNumberObjectValue()), b.isError())
        return b;
      const p2 = +R.getValue(), V = +b.getValue();
      let S2;
      return !p2 && o === 1 || p2 && u === 1 ? S2 = e : S2 = this._getResult(e, p2, V), (c > 1 || l > 1) && (S2 != null && S2.isArray()) ? S2.get(0, 0) : S2;
    });
    return c === 1 && l === 1 ? d2.get(0, 0) : d2;
  }
  _getResult(e, t, r) {
    const n = e.isArray() ? e.getRowCount() : 1, s = e.isArray() ? e.getColumnCount() : 1;
    let o = e.getArrayValue(), u = n, c = s;
    t && (o = this._transposeArray(o), u = s, c = n);
    const l = this._getRepeatRows(o, u, c);
    if (l.length > 0) {
      const f2 = [];
      l.forEach((m2) => {
        m2.forEach((d2, _2) => {
          (_2 !== 0 || r) && f2.push(d2);
        });
      }), o = o.filter((m2, d2) => !f2.includes(d2));
    }
    return o.length === 0 ? g2.create(h.CALC) : (t && (o = this._transposeArray(o)), K2.create({
      calculateValueList: o,
      rowCount: o.length,
      columnCount: o[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    }));
  }
  _getRepeatRows(e, t, r) {
    let n = [];
    for (let s = 0; s < r; s++)
      if (s === 0) {
        const o = new Array(t).fill(null).map((u, c) => ({
          r: c,
          valueObject: e[c][s]
        }));
        n = this._getRepeatRowsByObjects(o);
      } else {
        if (n.length === 0)
          break;
        let o = [];
        n.forEach((u) => {
          const c = u.map((f2) => ({
            r: f2,
            valueObject: e[f2][s]
          })), l = this._getRepeatRowsByObjects(c);
          o = o.concat(l);
        }), n = o;
      }
    return n;
  }
  _getRepeatRowsByObjects(e) {
    const t = /* @__PURE__ */ new Map();
    return e.forEach((r) => {
      const n = r.r, s = r.valueObject;
      let o = s.getValue();
      if (s.isNull() ? o = null : s.isString() && s1(o) && (o = +o), !t.has(o))
        t.set(o, [n]);
      else {
        const u = t.get(o);
        u.push(n), t.set(o, u);
      }
    }), Array.from(t.values()).filter((r) => r.length > 1);
  }
  _transposeArray(e) {
    const t = e.length, r = e[0].length, n = [];
    for (let s = 0; s < r; s++) {
      n[s] = [];
      for (let o = 0; o < t; o++)
        n[s][o] = e[o][s];
    }
    return n;
  }
};
var GC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (!t.isArray())
      return g2.create(h.VALUE);
    if (r.isError())
      return r;
    if (n != null && n.isError())
      return n;
    const s = n != null ? n : T.create(true);
    return Ui(e) && Ui(s) && r.isArray() ? this._handleArrayColIndexNum(e, t, r, s) : this._handleNonArrayColIndexNum(e, t, r, s);
  }
  _handleArrayColIndexNum(e, t, r, n) {
    const s = e.isArray() ? e.getFirstCell() : e, o = this.getZeroOrOneByOneDefault(n);
    if (o == null)
      return g2.create(h.VALUE);
    let u;
    const c = [];
    return r.iterator((l, f2, m2) => {
      if (l == null)
        return u = g2.create(h.VALUE), false;
      const d2 = this._handleTableArray(s, t, l, o);
      if (d2.isError())
        return u = d2, false;
      c[f2] === void 0 && (c[f2] = []), c[f2][m2] = d2;
    }), u || mt(c, c.length, c[0].length, this.unitId || "", this.subUnitId || "");
  }
  _handleNonArrayColIndexNum(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e), c = O(s, o, n);
    return u.map((l, f2, m2) => {
      if (l.isError())
        return l;
      const d2 = c.get(f2, m2);
      if (d2 == null)
        return g2.create(h.VALUE);
      if (d2.isError())
        return d2;
      const _2 = this.getZeroOrOneByOneDefault(d2);
      return _2 == null ? g2.create(h.VALUE) : this._handleTableArray(l, t, r, _2);
    });
  }
  _handleTableArray(e, t, r, n) {
    let s = this.getIndexNumValue(r);
    if (s instanceof g2)
      return s;
    if (s = Math.floor(s), s < 1)
      return g2.create(h.VALUE);
    const o = t.slice(void 0, [0, 1]);
    if (o == null)
      return g2.create(h.VALUE);
    const u = t.slice(void 0, [s - 1, s]);
    return u == null ? g2.create(h.REF) : this._handleSingleObject(e, o, u, n);
  }
  _handleSingleObject(e, t, r, n) {
    return n === 0 ? this.equalSearch(e, t, r) : this.binarySearch(e, t, r);
  }
};
var WC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = Math.max(
      ...e.map((n) => n.isArray() ? n.getColumnCount() : 1)
    ), r = [];
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      if (s.isError())
        return s;
      const o = s.isArray() ? s.getRowCount() : 1, u = s.isArray() ? s.getColumnCount() : 1;
      for (let c = 0; c < o; c++) {
        const l = [];
        for (let f2 = 0; f2 < t; f2++) {
          let m2 = s;
          s.isArray() && (m2 = s.get(c, f2)), f2 > u - 1 || !m2 ? l.push(g2.create(h.NA)) : l.push(m2);
        }
        r.push(l);
      }
    }
    return K2.create({
      calculateValueList: r,
      rowCount: r.length,
      columnCount: r[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
};
var QC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    let n = r != null ? r : g2.create(h.NA);
    n.isNull() && (n = g2.create(h.NA));
    const s = e.isArray() ? e.getRowCount() : 1, o = e.isArray() ? e.getColumnCount() : 1, u = Math.max(
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), c = Math.max(
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), l = O(u, c, t, g2.create(h.NA)), f2 = O(u, c, n, g2.create(h.NA)), m2 = l.mapValue((d2, _2, C) => {
      const E = f2.get(_2, C);
      if (e.isError())
        return e;
      if (e.isNull())
        return g2.create(h.VALUE);
      if (d2.isError())
        return d2;
      const R = Math.trunc(+d2.getValue());
      if (s > 1 && o > 1 || Number.isNaN(R))
        return g2.create(h.VALUE);
      if (R < 1)
        return g2.create(h.NUM);
      const b = e.isArray() ? e.getArrayValue().flat() : [e], p2 = this._getWrapArray(b, R, E);
      return u > 1 || c > 1 || p2.length === 1 && p2[0].length === 1 ? p2[0][0] : K2.create({
        calculateValueList: p2,
        rowCount: p2.length,
        columnCount: p2[0].length,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      });
    });
    return u === 1 && c === 1 ? m2.get(0, 0) : m2;
  }
  _getWrapArray(e, t, r) {
    const n = Math.ceil(e.length / t), s = n > 1 ? t : e.length, o = [];
    for (let u = 0; u < n; u++)
      for (let c = 0; c < s; c++) {
        o[c] || (o[c] = []);
        const l = u * s + c;
        l < e.length ? o[c].push(e[l].isNull() ? y2.create(0) : e[l]) : o[c].push(r);
      }
    return o;
  }
};
var qC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    let n = r != null ? r : g2.create(h.NA);
    n.isNull() && (n = g2.create(h.NA));
    const s = e.isArray() ? e.getRowCount() : 1, o = e.isArray() ? e.getColumnCount() : 1, u = Math.max(
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), c = Math.max(
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), l = O(u, c, t, g2.create(h.NA)), f2 = O(u, c, n, g2.create(h.NA)), m2 = l.mapValue((d2, _2, C) => {
      const E = f2.get(_2, C);
      if (e.isError())
        return e;
      if (e.isNull())
        return g2.create(h.VALUE);
      if (d2.isError())
        return d2;
      const R = Math.trunc(+d2.getValue());
      if (s > 1 && o > 1 || Number.isNaN(R))
        return g2.create(h.VALUE);
      if (R < 1)
        return g2.create(h.NUM);
      const b = e.isArray() ? e.getArrayValue().flat() : [e], p2 = this._getWrapArray(b, R, E);
      return u > 1 || c > 1 || p2.length === 1 && p2[0].length === 1 ? p2[0][0] : K2.create({
        calculateValueList: p2,
        rowCount: p2.length,
        columnCount: p2[0].length,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      });
    });
    return u === 1 && c === 1 ? m2.get(0, 0) : m2;
  }
  _getWrapArray(e, t, r) {
    const n = Math.ceil(e.length / t), s = n > 1 ? t : e.length, o = [];
    for (let u = 0; u < n; u++) {
      const c = [];
      for (let l = 0; l < s; l++) {
        const f2 = u * s + l;
        f2 < e.length ? c.push(e[f2].isNull() ? y2.create(0) : e[f2]) : c.push(r);
      }
      o.push(c);
    }
    return o;
  }
};
var XC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 6);
  }
  // eslint-disable-next-line
  calculate(e, t, r, n, s, o) {
    let u = n != null ? n : g2.create(h.NA);
    n != null && n.isNull() && (u = g2.create(h.NA));
    let c = s != null ? s : y2.create(0);
    s != null && s.isNull() && (c = y2.create(0));
    let l = o != null ? o : y2.create(1);
    if (o != null && o.isNull() && (l = y2.create(1)), e.isError())
      return e;
    const f2 = t.isArray() ? t.getRowCount() : 1, m2 = t.isArray() ? t.getColumnCount() : 1, d2 = r.isArray() ? r.getRowCount() : 1, _2 = r.isArray() ? r.getColumnCount() : 1;
    if (f2 !== 1 && m2 !== 1 || f2 === 1 && m2 > 1 && m2 !== _2 || m2 === 1 && f2 > 1 && f2 !== d2)
      return g2.create(h.VALUE);
    if (c.isError())
      return c;
    if (l.isError())
      return l;
    const C = this.getIndexNumValue(c);
    if (C instanceof g2)
      return C;
    const E = this.getIndexNumValue(l);
    return E instanceof g2 ? E : this._getResult(
      e,
      ea(t),
      ea(r),
      u,
      C,
      E,
      f2,
      m2,
      d2,
      _2
    );
  }
  _getResult(e, t, r, n, s, o, u, c, l, f2) {
    const m2 = e.isArray() ? e.getRowCount() : 1, d2 = e.isArray() ? e.getColumnCount() : 1;
    if (m2 > 1 || d2 > 1) {
      let R;
      return u === 1 ? R = r.slice([0, 1]) : R = r.slice(void 0, [0, 1]), R == null ? g2.create(h.NA) : e.map((b) => {
        const p2 = this._checkErrorCombination(s, o);
        if (p2)
          return p2;
        const V = this._handleSingleObject(b, t, R, s, o);
        return V.isError() ? n : V;
      });
    }
    const _2 = e.isArray() ? e.get(0, 0) : e;
    if (c === f2 && u === l) {
      const R = this._checkErrorCombination(s, o);
      if (R)
        return R;
      const b = this._handleSingleObject(_2, t, r, s, o);
      return b.isError() ? n : b;
    }
    let C = 0;
    c === f2 && (C = 1);
    const E = this._handleExpandObject(_2, t, r, s, o, C);
    return E == null ? g2.create(h.NA) : E;
  }
  _handleExpandObject(e, t, r, n, s, o = 0) {
    if ((s === 2 || s === -2) && n !== 2) {
      const u = Ws(s), c = Gs(n);
      return this.binarySearchExpand(
        e,
        t,
        r,
        o,
        u,
        c
      );
    }
    return n === 2 ? this.fuzzySearchExpand(e, t, r, s !== -1, o) : n === -1 || n === 1 ? this.orderSearchExpand(
      e,
      t,
      r,
      n === 1 ? xe.MAX : xe.MIN,
      s === -1,
      o
    ) : this.equalSearchExpand(e, t, r, s !== -1, o);
  }
  _handleSingleObject(e, t, r, n, s) {
    if ((s === 2 || s === -2) && n !== 2) {
      const o = Ws(s), u = Gs(n);
      return this.binarySearch(e, t, r, o, u);
    }
    return n === 2 ? this.fuzzySearch(e, t, r, s !== -1) : n === -1 || n === 1 ? this.orderSearch(
      e,
      t,
      r,
      n === 1 ? xe.MAX : xe.MIN,
      s === -1
    ) : this.equalSearch(e, t, r, s !== -1);
  }
  /**
   * Wildcard matching and binary search cannot appear at the same time
   * @param matchModeValue
   * @param searchModeValue
   * @returns
   */
  _checkErrorCombination(e, t) {
    return e === 2 && (t === -2 || t === 2) ? g2.create(h.VALUE) : null;
  }
};
var KC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    let s = y2.create(0);
    r && !r.isNull() && (s = r);
    let o = y2.create(1);
    n && !n.isNull() && (o = n);
    const u = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1
    ), c = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1
    ), l = O(u, c, e, g2.create(h.NA)), f2 = O(u, c, s, g2.create(h.NA)), m2 = O(u, c, o, g2.create(h.NA)), d2 = l.mapValue((_2, C, E) => {
      if (_2.isError())
        return _2;
      const R = f2.get(C, E), b = m2.get(C, E);
      return R.isError() ? R : b.isError() ? b : this._handleSingleObject(_2, t, R, b);
    });
    return u === 1 && c === 1 ? d2.get(0, 0) : d2;
  }
  _handleSingleObject(e, t, r, n) {
    const s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    if (s !== 1 && o !== 1)
      return g2.create(h.VALUE);
    let u = r;
    if ((r.isString() || r.isBoolean() || r.isNull()) && (u = r.convertToNumberObjectValue()), u.isError())
      return u;
    let c = n;
    if ((n.isString() || n.isBoolean() || n.isNull()) && (c = n.convertToNumberObjectValue()), c.isError())
      return c;
    const l = u.getValue(), f2 = c.getValue();
    return ![-1, 0, 1, 2].includes(l) || ![-1, 1, 2].includes(f2) ? g2.create(h.VALUE) : this._getResult(e, t, l, f2);
  }
  _getResult(e, t, r, n) {
    const s = ea(t);
    let o;
    if ((n === 2 || n === -2) && r !== 2) {
      const u = Ws(n), c = Gs(r);
      o = s.binarySearch(e, u, c);
    } else if (r === 2) {
      const u = s.compare(e, Y2.EQUALS);
      let c;
      if (n !== -1 ? c = u.getFirstTruePosition() : c = u.getLastTruePosition(), c == null)
        return g2.create(h.NA);
      o = s.getRowCount() === 1 ? c.column : c.row;
    } else if (r === -1 || r === 1) {
      const u = s.orderSearch(e, r === 1 ? xe.MAX : xe.MIN, n === -1);
      if (u == null)
        return g2.create(h.NA);
      if (u instanceof g2)
        return u;
      o = s.getRowCount() === 1 ? u.column : u.row;
    } else {
      const u = s.isEqual(e);
      let c;
      if (n !== -1 ? c = u.getFirstTruePosition() : c = u.getLastTruePosition(), c == null)
        return g2.create(h.NA);
      o = s.getRowCount() === 1 ? c.column : c.row;
    }
    return o == null ? g2.create(h.NA) : y2.create(o + 1);
  }
};
var ZC = [
  [gC, re.ADDRESS],
  [CC, re.AREAS],
  [_C, re.CHOOSE],
  [AC, re.CHOOSECOLS],
  [EC, re.CHOOSEROWS],
  [RC, re.COLUMN],
  [bC, re.COLUMNS],
  [yC, re.DROP],
  [pC, re.EXPAND],
  [NC, re.FILTER],
  [VC, re.FORMULATEXT],
  [OC, re.HLOOKUP],
  [SC, re.HSTACK],
  [MC, re.HYPERLINK],
  [DC, re.IMAGE],
  [wC, re.INDEX],
  [LC, re.INDIRECT],
  [PC, re.LOOKUP],
  [xC, re.MATCH],
  [UC, re.OFFSET],
  [vC, re.ROW],
  [TC, re.ROWS],
  [IC, re.SORT],
  [BC, re.SORTBY],
  [FC, re.TAKE],
  [kC, re.TOCOL],
  [$C, re.TOROW],
  [YC, re.TRANSPOSE],
  [HC, re.UNIQUE],
  [GC, re.VLOOKUP],
  [WC, re.VSTACK],
  [QC, re.WRAPCOLS],
  [qC, re.WRAPROWS],
  [XC, re.XLOOKUP],
  [KC, re.XMATCH]
];
var zC = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.abs();
  }
};
var JC2 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.acos();
  }
};
var e_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.acosh();
  }
};
var t_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.isArray() ? t.map((r) => r.isError() ? r : Ki(r)) : Ki(t);
  }
};
function Ki(a2) {
  let i = a2.getValue();
  if (a2.isBoolean() && (i = i ? 1 : 0), !Number.isFinite(i))
    return g2.create(h.VALUE);
  i = Number(i);
  let e = Math.atan(1 / i);
  return i < 0 && (e += Math.PI), Number.isNaN(e) ? g2.create(h.VALUE) : y2.create(e);
}
var r_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.isArray() ? t.map((r) => r.isError() ? r : Zi(r)) : Zi(t);
  }
};
function Zi(a2) {
  let i = a2.getValue();
  if (a2.isBoolean() && (i = i ? 1 : 0), !Number.isFinite(i))
    return g2.create(h.VALUE);
  if (i = Number(i), Math.abs(i) <= 1)
    return g2.create(h.NUM);
  const e = 1 / 2 * Math.log((i + 1) / (i - 1));
  return Number.isNaN(e) ? g2.create(h.VALUE) : y2.create(e);
}
var n_ = {
  1: Me.AVERAGE,
  2: Me.COUNT,
  3: Me.COUNTA,
  4: Me.MAX,
  5: Me.MIN,
  6: Me.PRODUCT,
  7: Me.STDEV_S,
  8: Me.STDEV_P,
  9: Me.SUM,
  10: Me.VAR_S,
  11: Me.VAR_P,
  12: Me.MEDIAN,
  13: Me.MODE_SNGL
};
var s_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", true);
    A(this, "needsFilteredOutRows", true);
    A(this, "needsFormulaDataModel", true);
  }
  calculate(e, t, ...r) {
    const { isError: n, multiAreaRefs: s, normalRefs: o } = du(r);
    let u;
    e.isReferenceObject() ? u = e.toArrayValueObject() : u = e;
    let c;
    t.isReferenceObject() ? c = t.toArrayValueObject() : c = t;
    const l = Math.max(
      u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f2 = Math.max(
      u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), m2 = O(l, f2, u, g2.create(h.NA)), d2 = O(l, f2, c, g2.create(h.NA)), _2 = m2.mapValue((C, E, R) => {
      if (C.isError())
        return C;
      const b = d2.get(E, R);
      return b.isError() ? b : s.length > 0 ? g2.create(h.VALUE) : this._handleSingleObject(C, b, r, n, o);
    });
    return _2.getRowCount() === 1 && _2.getColumnCount() === 1 ? _2.get(0, 0) : _2;
  }
  _handleSingleObject(e, t, r, n, s) {
    let o = e;
    if (e.isString() && (o = e.convertToNumberObjectValue()), o.isError())
      return o;
    const u = Math.floor(+o.getValue());
    if (u < 1 || u > 19 || u >= 1 && u <= 13 && n || u >= 14 && u <= 19 && r.length !== 2)
      return g2.create(h.VALUE);
    let c = t;
    if (t.isString() && (c = t.convertToNumberObjectValue()), c.isError())
      return c;
    const l = Math.floor(+c.getValue());
    if (l < 0 || l > 7)
      return g2.create(h.VALUE);
    const f2 = this._getAggregateOptions(l);
    return u >= 14 && u <= 19 ? this._handleLargeSmallPercentileQuartile(
      u,
      f2,
      r[0],
      r[1]
    ) : Eu(__spreadProps(__spreadValues({
      type: n_[u]
    }, f2), {
      formulaDataModel: this._formulaDataModel
    }), s);
  }
  _getAggregateOptions(e) {
    switch (e) {
      case 1:
        return {
          ignoreRowHidden: true,
          ignoreErrorValues: false,
          ignoreNested: true
        };
      case 2:
        return {
          ignoreRowHidden: false,
          ignoreErrorValues: true,
          ignoreNested: true
        };
      case 3:
        return {
          ignoreRowHidden: true,
          ignoreErrorValues: true,
          ignoreNested: true
        };
      case 4:
        return {
          ignoreRowHidden: false,
          ignoreErrorValues: false,
          ignoreNested: false
        };
      case 5:
        return {
          ignoreRowHidden: true,
          ignoreErrorValues: false,
          ignoreNested: false
        };
      case 6:
        return {
          ignoreRowHidden: false,
          ignoreErrorValues: true,
          ignoreNested: false
        };
      case 7:
        return {
          ignoreRowHidden: true,
          ignoreErrorValues: true,
          ignoreNested: false
        };
      case 0:
      default:
        return {
          ignoreRowHidden: false,
          ignoreErrorValues: false,
          ignoreNested: true
        };
    }
  }
  _handleLargeSmallPercentileQuartile(e, t, r, n) {
    let s;
    if (n.isReferenceObject() ? s = n.toArrayValueObject() : s = n, s.isError())
      return s;
    if (s.isArray()) {
      const c = s.getRowCount(), l = s.getColumnCount();
      if (c > 1 || l > 1)
        return g2.create(h.VALUE);
      s = s.get(0, 0);
    }
    const o = mr(r, t, this._formulaDataModel);
    if (!Array.isArray(o))
      return o;
    const u = +s.getValue();
    switch (e) {
      case 14:
        return bu(o, u);
      case 15:
        return yu(o, u);
      case 16:
        return pu(o, u);
      case 17:
        return Vu(o, u);
      case 18:
        return Nu(o, u);
      case 19:
        return Ou(o, u);
      default:
        return g2.create(h.VALUE);
    }
  }
};
var a_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  // eslint-disable-next-line
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isNull())
      return y2.create(0);
    if (e.isBoolean() || e.isNumber())
      return g2.create(h.VALUE);
    let t = e.getValue().toLocaleString().toLocaleUpperCase();
    if (t.length > 255)
      return g2.create(h.VALUE);
    const r = t.startsWith("-");
    r && (t = t.slice(1));
    let n = 0;
    for (let s = 0; s < t.length; s++) {
      const o = fn.get(t[s]) || 0, u = fn.get(t[s + 1]) || 0, c = fn.get(t[s + 2]) || 0, l = fn.get(t[s + 3]) || 0;
      if (!o || c >= u && c > o || o === u && o === c && o === l || o === u / 2)
        return g2.create(h.VALUE);
      o < u ? n -= o : n += o;
    }
    return y2.create(r ? -n : n);
  }
};
var i_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.asin();
  }
};
var o_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.asinh();
  }
};
var u_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.atan();
  }
};
var c_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e, n = t;
    return r.isString() && (r = r.convertToNumberObjectValue()), r.isError() ? r : (n.isString() && (n = n.convertToNumberObjectValue()), n.isError() ? n : n.atan2(r));
  }
};
var l_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.atanh();
  }
};
var f_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : y2.create(0);
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (n.isError())
      return n;
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g2.create(h.NA)), c = O(s, o, t, g2.create(h.NA)), l = O(s, o, n, g2.create(h.NA)), f2 = u.map((m2, d2, _2) => {
      const C = c.get(d2, _2), E = l.get(d2, _2);
      return this._handleSingleObject(m2, C, E);
    });
    return f2.getRowCount() === 1 && f2.getColumnCount() === 1 ? f2.getArrayValue()[0][0] : f2;
  }
  _handleSingleObject(e, t, r) {
    let n = e;
    if (n.isString() && (n = n.convertToNumberObjectValue()), n.isError())
      return n;
    let s = t;
    if (s.isString() && (s = s.convertToNumberObjectValue()), s.isError())
      return s;
    let o = r;
    if (o.isString() && (o = o.convertToNumberObjectValue()), o.isError())
      return o;
    const u = Math.floor(+n.getValue()), c = Math.floor(+s.getValue()), l = Math.floor(+o.getValue());
    if (u < 0 || u >= __pow(2, 53) || c < 2 || c > 36 || l < 0)
      return g2.create(h.NUM);
    let f2 = u.toString(c);
    return f2.length < l && (f2 = new Array(l - f2.length + 1).join("0") + f2), U2.create(f2.toLocaleUpperCase());
  }
};
var m_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g2.create(h.NA)), o = O(r, n, t, g2.create(h.NA)), u = s.map((c, l, f2) => {
      let m2 = c, d2 = o.get(l, f2);
      if (m2.isString() && (m2 = m2.convertToNumberObjectValue()), m2.isError())
        return m2;
      if (d2.isString() && (d2 = d2.convertToNumberObjectValue()), d2.isError())
        return d2;
      const _2 = +m2.getValue(), C = +d2.getValue();
      if (_2 > 0 && C < 0)
        return g2.create(h.NUM);
      if (_2 === 0 || C === 0)
        return y2.create(0);
      const E = We(_2 / C, 0) * C;
      return y2.create(E);
    });
    return u.getRowCount() === 1 && u.getColumnCount() === 1 ? u.getArrayValue()[0][0] : u;
  }
};
var h_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = t != null ? t : y2.create(1), s = r != null ? r : y2.create(0);
    if (e.isError())
      return e;
    if (n.isError())
      return n;
    if (s.isError())
      return s;
    const o = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, e, g2.create(h.NA)), l = O(o, u, n, g2.create(h.NA)), f2 = O(o, u, s, g2.create(h.NA)), m2 = c.map((d2, _2, C) => {
      let E = d2, R = l.get(_2, C), b = f2.get(_2, C);
      if (E.isString() && (E = E.convertToNumberObjectValue()), E.isError())
        return E;
      if (R.isString() && (R = R.convertToNumberObjectValue()), R.isError())
        return R;
      if (b.isString() && (b = b.convertToNumberObjectValue()), b.isError())
        return b;
      const p2 = +E.getValue(), V = +R.getValue(), S2 = +b.getValue();
      return p2 === 0 || V === 0 ? y2.create(0) : this._getResult(p2, V, S2);
    });
    return o === 1 && u === 1 ? m2.get(0, 0) : m2;
  }
  _getResult(e, t, r) {
    let n;
    return e < 0 && r !== 0 ? n = (t < 0 ? We(Math.abs(e) / Math.abs(t), 0) : -We(Math.abs(e) / t, 0)) * t : n = (t < 0 ? -We(e / Math.abs(t), 0) : We(e / t, 0)) * t, y2.create(n);
  }
};
var g_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y2.create(1);
    if (e.isError())
      return e;
    if (r.isError())
      return r;
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, r, g2.create(h.NA)), c = o.map((l, f2, m2) => {
      let d2 = u.get(f2, m2), _2 = l;
      if (_2.isString() && (_2 = _2.convertToNumberObjectValue()), _2.isError())
        return _2;
      if (d2.isString() && (d2 = d2.convertToNumberObjectValue()), d2.isError())
        return d2;
      const C = +_2.getValue(), E = +d2.getValue();
      if (C === 0 || E === 0)
        return y2.create(0);
      const R = (E < 0 ? -We(C / Math.abs(E), 0) : We(C / E, 0)) * E;
      return y2.create(R);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
};
var d_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g2.create(h.NA)), o = O(r, n, t, g2.create(h.NA)), u = s.mapValue((c, l, f2) => {
      let m2 = c, d2 = o.get(l, f2);
      if (m2.isString() && (m2 = m2.convertToNumberObjectValue()), d2.isString() && (d2 = d2.convertToNumberObjectValue()), m2.isError())
        return m2;
      if (d2.isError())
        return d2;
      const _2 = Math.floor(+m2.getValue()), C = Math.floor(+d2.getValue());
      if (_2 < 0 || C < 0 || _2 < C)
        return g2.create(h.NUM);
      const E = sr(_2, C);
      return Number.isNaN(E) || !Number.isFinite(E) ? g2.create(h.NUM) : y2.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
};
var C_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g2.create(h.NA)), o = O(r, n, t, g2.create(h.NA)), u = s.mapValue((c, l, f2) => {
      let m2 = c, d2 = o.get(l, f2);
      if (m2.isString() && (m2 = m2.convertToNumberObjectValue()), d2.isString() && (d2 = d2.convertToNumberObjectValue()), m2.isError())
        return m2;
      if (d2.isError())
        return d2;
      const _2 = Math.floor(+m2.getValue()), C = Math.floor(+d2.getValue());
      if (_2 < 0 || C < 0 || _2 === 0 && _2 < C)
        return g2.create(h.NUM);
      const E = sr(_2 + C - 1, _2 - 1);
      return Number.isNaN(E) || !Number.isFinite(E) ? g2.create(h.NUM) : y2.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
};
var __ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.cos();
  }
};
var A_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.cosh();
  }
};
var E_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    return Math.abs(r) >= __pow(2, 27) ? g2.create(h.NUM) : r === 0 ? g2.create(h.DIV_BY_ZERO) : t.tan().getReciprocal();
  }
};
var R_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : +t.getValue() === 0 ? g2.create(h.DIV_BY_ZERO) : t.tanh().getReciprocal();
  }
};
var b_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    return Math.abs(r) >= __pow(2, 27) ? g2.create(h.NUM) : r === 0 ? g2.create(h.DIV_BY_ZERO) : t.sin().getReciprocal();
  }
};
var y_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    return r === 0 ? g2.create(h.DIV_BY_ZERO) : !Number.isNaN(r) && !Number.isFinite(Math.sinh(r)) ? y2.create(0) : t.sinh().getReciprocal();
  }
};
var p_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g2.create(h.NA)), o = O(r, n, t, g2.create(h.NA)), u = s.map((c, l, f2) => {
      if (c.isError())
        return c;
      let m2 = o.get(l, f2);
      if (m2.isString() && (m2 = m2.convertToNumberObjectValue()), m2.isError())
        return m2;
      const d2 = `${c.getValue()}`, _2 = Math.floor(+m2.getValue());
      if (s1(d2) && (+d2 < 0 || +d2 >= __pow(2, 53) || !Number.isInteger(+d2)) || d2.toLocaleLowerCase() === "true" || d2.toLocaleLowerCase() === "false" || _2 < 2 || _2 > 36)
        return g2.create(h.NUM);
      if (d2.replace(/\s/g, "") === "")
        return y2.create(0);
      if (!this._isValidCharForRadix(d2, _2))
        return g2.create(h.NUM);
      const C = Number.parseInt(d2, _2);
      return Number.isNaN(C) ? g2.create(h.NUM) : y2.create(C);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _isValidCharForRadix(e, t) {
    for (const r of e) {
      const n = r.toUpperCase().charCodeAt(0);
      if (t <= 10 && !(n >= 48 && n < 48 + t) || t > 10 && !(n >= 48 && n < 58 || n >= 65 && n < 65 + t - 10))
        return false;
    }
    return true;
  }
};
var N_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    if (!Number.isFinite(r))
      return g2.create(h.VALUE);
    const n = r * (180 / Math.PI);
    return Number.isNaN(n) ? g2.create(h.VALUE) : y2.create(n);
  }
};
var V_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    if (!Number.isFinite(r))
      return g2.create(h.VALUE);
    const n = (r < 0 ? -We(Math.abs(r) / 2, 0) : We(r / 2, 0)) * 2;
    return Number.isNaN(n) ? g2.create(h.VALUE) : n === 0 ? y2.create(0) : y2.create(n);
  }
};
var O_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.exp();
  }
};
var S_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.mapValue((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = Math.floor(+t.getValue()), n = Ar(r);
    return Number.isNaN(n) || !Number.isFinite(n) ? g2.create(h.NUM) : y2.create(n);
  }
};
var M_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    if (e.isArray()) {
      const r = e.getRowCount(), n = e.getColumnCount();
      if (r > 1 || n > 1)
        return g2.create(h.VALUE);
      t = e.get(0, 0);
    }
    return this._handleSingleObject(t);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = Math.floor(+t.getValue()), n = Ar(r, 2);
    return Number.isNaN(n) || !Number.isFinite(n) ? g2.create(h.NUM) : y2.create(n);
  }
};
var D_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g2.create(h.NA)), o = O(r, n, t, g2.create(h.NA)), u = s.map((c, l, f2) => {
      let m2 = o.get(l, f2), d2 = c;
      if (d2.isString() && (d2 = d2.convertToNumberObjectValue()), d2.isError())
        return d2;
      if (m2.isString() && (m2 = m2.convertToNumberObjectValue()), m2.isError())
        return m2;
      const _2 = +d2.getValue(), C = +m2.getValue();
      if (_2 > 0 && C < 0)
        return g2.create(h.NUM);
      if (_2 === 0)
        return y2.create(0);
      if (C === 0)
        return g2.create(h.DIV_BY_ZERO);
      const E = Ze2(_2 / C, 0) * C;
      return y2.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
};
var w_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = t != null ? t : y2.create(1), s = r != null ? r : y2.create(0), o = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, e, g2.create(h.NA)), l = O(o, u, n, g2.create(h.NA)), f2 = O(o, u, s, g2.create(h.NA)), m2 = c.map((d2, _2, C) => {
      let E = d2, R = l.get(_2, C), b = f2.get(_2, C);
      if (E.isString() && (E = E.convertToNumberObjectValue()), E.isError())
        return E;
      if (R.isString() && (R = R.convertToNumberObjectValue()), R.isError())
        return R;
      if (b.isString() && (b = b.convertToNumberObjectValue()), b.isError())
        return b;
      const p2 = +E.getValue(), V = +R.getValue(), S2 = +b.getValue();
      if (p2 === 0 || V === 0)
        return y2.create(0);
      let M2;
      return p2 < 0 && S2 !== 0 ? M2 = (V < 0 ? Ze2(Math.abs(p2) / Math.abs(V), 0) : -Ze2(Math.abs(p2) / V, 0)) * V : M2 = (V < 0 ? -Ze2(p2 / Math.abs(V), 0) : Ze2(p2 / V, 0)) * V, y2.create(M2);
    });
    return o === 1 && u === 1 ? m2.get(0, 0) : m2;
  }
};
var L_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y2.create(1);
    if (e.isError())
      return e;
    if (r.isError())
      return r;
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, r, g2.create(h.NA)), c = o.map((l, f2, m2) => {
      let d2 = u.get(f2, m2), _2 = l;
      if (_2.isString() && (_2 = _2.convertToNumberObjectValue()), _2.isError())
        return _2;
      if (d2.isString() && (d2 = d2.convertToNumberObjectValue()), d2.isError())
        return d2;
      const C = +_2.getValue(), E = +d2.getValue();
      if (C === 0 || E === 0)
        return y2.create(0);
      const R = (E < 0 ? -Ze2(C / Math.abs(E), 0) : Ze2(C / E, 0)) * E;
      return y2.create(R);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
};
var P_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = 0;
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      if (!n.isNull())
        if (n.isArray()) {
          let s = false, o = g2.create(h.VALUE);
          if (n.iterator((u) => {
            if (u != null && u.isNull())
              return true;
            const { isError: c, errorObject: l, number: f2 } = this._handleSingleObject(u);
            if (c)
              return s = true, o = l, false;
            t = la(t, f2);
          }), s)
            return o;
        } else {
          const { isError: s, errorObject: o, number: u } = this._handleSingleObject(n);
          if (s)
            return o;
          t = la(t, u);
        }
    }
    return y2.create(t);
  }
  _handleSingleObject(e) {
    if (e.isBoolean())
      return {
        isError: true,
        errorObject: g2.create(h.VALUE),
        number: null
      };
    let t = e;
    if (e.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return {
        isError: true,
        errorObject: t,
        number: null
      };
    const r = Math.floor(+t.getValue());
    return r < 0 || r >= __pow(2, 53) ? {
      isError: true,
      errorObject: g2.create(h.NUM),
      number: null
    } : {
      isError: false,
      errorObject: null,
      number: r
    };
  }
};
var x_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.mapValue((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = Math.floor(+t.getValue());
    return y2.create(r);
  }
};
var j_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = 1, r = true;
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      if (!s.isNull())
        if (s.isArray()) {
          let o = false, u = g2.create(h.VALUE);
          if (s.iterator((c) => {
            if (c != null && c.isNull())
              return true;
            const { isError: l, errorObject: f2, number: m2 } = this._handleSingleObject(c);
            if (l)
              return o = true, u = f2, false;
            t = Qi(t, m2), r = false;
          }), o)
            return u;
        } else {
          const { isError: o, errorObject: u, number: c } = this._handleSingleObject(s);
          if (o)
            return u;
          t = Qi(t, c), r = false;
        }
    }
    return r ? y2.create(0) : Number.isNaN(t) || !Number.isFinite(t) || t >= __pow(2, 53) ? g2.create(h.VALUE) : y2.create(t);
  }
  _handleSingleObject(e) {
    if (e.isBoolean())
      return {
        isError: true,
        errorObject: g2.create(h.VALUE),
        number: null
      };
    let t = e;
    if (e.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return {
        isError: true,
        errorObject: t,
        number: null
      };
    const r = Math.floor(+t.getValue());
    return r < 0 ? {
      isError: true,
      errorObject: g2.create(h.NUM),
      number: null
    } : {
      isError: false,
      errorObject: null,
      number: r
    };
  }
};
var U_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.log();
  }
};
var v_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y2.create(10);
    if (e.isError())
      return e;
    if (r.isError())
      return r;
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, r, g2.create(h.NA)), c = o.map((l, f2, m2) => {
      let d2 = u.get(f2, m2), _2 = l;
      if (_2.isString() && (_2 = _2.convertToNumberObjectValue()), _2.isError())
        return _2;
      if (d2.isString() && (d2 = d2.convertToNumberObjectValue()), d2.isError())
        return d2;
      const C = +_2.getValue(), E = +d2.getValue();
      if (C <= 0 || E <= 0)
        return g2.create(h.NUM);
      const R = Math.log(E);
      if (R === 0)
        return g2.create(h.DIV_BY_ZERO);
      const b = Math.log(C) / R;
      return y2.create(b);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
};
var T_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.log10();
  }
};
var I_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const t = e.isArray() ? e.getRowCount() : 1, r = e.isArray() ? e.getColumnCount() : 1, n = [];
    for (let o = 0; o < t; o++) {
      const u = [];
      for (let c = 0; c < r; c++) {
        let l = e.isArray() ? e.get(o, c) : e;
        if (l.isError())
          return l;
        if (l.isNull() || l.isBoolean())
          return g2.create(h.VALUE);
        if (l.isString() && (l = l.convertToNumberObjectValue()), l.isError())
          return l;
        const f2 = +l.getValue();
        u.push(f2);
      }
      n.push(u);
    }
    if (t !== r)
      return g2.create(h.VALUE);
    const s = Ba(n);
    return y2.create(s);
  }
};
var B_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const t = e.isArray() ? e.getRowCount() : 1, r = e.isArray() ? e.getColumnCount() : 1, n = [];
    for (let o = 0; o < t; o++) {
      const u = [];
      for (let c = 0; c < r; c++) {
        let l = e.isArray() ? e.get(o, c) : e;
        if (l.isError())
          return l;
        if (l.isNull() || l.isBoolean())
          return g2.create(h.VALUE);
        if (l.isString() && (l = l.convertToNumberObjectValue()), l.isError())
          return l;
        const f2 = +l.getValue();
        u.push(f2);
      }
      n.push(u);
    }
    if (t !== r)
      return g2.create(h.VALUE);
    const s = vh(n);
    return s === null ? g2.create(h.NUM) : K2.createByArray(s);
  }
};
var F_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    if (n !== s)
      return g2.create(h.VALUE);
    const u = this._getMatrix(e, r, n), c = this._getMatrix(t, s, o);
    if (u instanceof g2)
      return u;
    if (c instanceof g2)
      return c;
    const l = Er(u, c);
    return K2.createByArray(l);
  }
  _getMatrix(e, t, r) {
    const n = [];
    for (let s = 0; s < t; s++) {
      const o = [];
      for (let u = 0; u < r; u++) {
        let c = e.isArray() ? e.get(s, u) : e;
        if (c.isError())
          return c;
        if (c.isNull() || c.isBoolean())
          return g2.create(h.VALUE);
        if (c.isString() && (c = c.convertToNumberObjectValue()), c.isError())
          return c;
        const l = +c.getValue();
        o.push(l);
      }
      n.push(o);
    }
    return n;
  }
};
var k_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (r.isString() && (r = r.convertToNumberObjectValue()), r.isError())
      return r;
    let n = t;
    return n.isString() && (n = n.convertToNumberObjectValue()), n.isError() ? n : r.mod(n);
  }
};
var $_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (r.isArray()) {
      const c = r.getRowCount(), l = r.getColumnCount();
      if (c > 1 || l > 1)
        return g2.create(h.VALUE);
      r = r.get(0, 0);
    }
    if (r.isError())
      return r;
    let n = t;
    if (n.isArray()) {
      const c = n.getRowCount(), l = n.getColumnCount();
      if (c > 1 || l > 1)
        return g2.create(h.VALUE);
      n = n.get(0, 0);
    }
    if (n.isError())
      return n;
    if (r.isBoolean() || n.isBoolean())
      return g2.create(h.VALUE);
    const s = +r.getValue(), o = +n.getValue();
    if (Number.isNaN(s) || Number.isNaN(o))
      return g2.create(h.VALUE);
    if (o === 0)
      return y2.create(0);
    if (s > 0 && o < 0 || s < 0 && o > 0)
      return g2.create(h.NUM);
    const u = kt(s / o, 0) * o;
    return y2.create(u);
  }
};
var Y_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = 0, r = 1;
    for (let s = 0; s < e.length; s++) {
      const o = e[s];
      if (!o.isNull())
        if (o.isArray()) {
          let u = false, c = g2.create(h.VALUE);
          if (o.iterator((l) => {
            if (l != null && l.isNull())
              return true;
            const { isError: f2, errorObject: m2, number: d2 } = this._handleSingleObject(l);
            if (f2)
              return u = true, c = m2, false;
            if (t += d2, t > 170)
              return u = true, c = g2.create(h.NUM), false;
            r *= Ar(d2);
          }), u)
            return c;
        } else {
          const { isError: u, errorObject: c, number: l } = this._handleSingleObject(o);
          if (u)
            return c;
          if (t += l, t > 170)
            return g2.create(h.NUM);
          r *= Ar(l);
        }
    }
    const n = Ar(t) / r;
    return y2.create(n);
  }
  _handleSingleObject(e) {
    if (e.isBoolean())
      return {
        isError: true,
        errorObject: g2.create(h.VALUE),
        number: null
      };
    let t = e;
    if (e.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return {
        isError: true,
        errorObject: t,
        number: null
      };
    const r = Math.floor(+t.getValue());
    return r < 0 ? {
      isError: true,
      errorObject: g2.create(h.NUM),
      number: null
    } : {
      isError: false,
      errorObject: null,
      number: r
    };
  }
};
var H_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.getRowCount(), r = e.getColumnCount(), n = e.mapValue((s) => {
        const o = this._handleSingleObject(s);
        return o.isError() ? o : t > 1 || r > 1 ? o.get(0, 0) : o;
      });
      return t === 1 && r === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = Math.floor(+t.getValue());
    if (r <= 0)
      return g2.create(h.VALUE);
    const n = [];
    for (let s = 0; s < r; s++) {
      n[s] = [];
      for (let o = 0; o < r; o++)
        n[s][o] = s === o ? 1 : 0;
    }
    return K2.createByArray(n);
  }
};
var G_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    if (!Number.isFinite(r))
      return g2.create(h.VALUE);
    let n = r < 0 ? -We(Math.abs(r), 0) : We(r, 0);
    return Number.isNaN(n) ? g2.create(h.VALUE) : (Math.abs(n) % 2 === 0 && (r < 0 ? n-- : n++), y2.create(n));
  }
};
var W_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 0);
  }
  calculate() {
    return y2.create(Math.PI);
  }
};
var Q_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (r.isString() && (r = r.convertToNumberObjectValue()), r.isError())
      return r;
    let n = t;
    return n.isString() && (n = n.convertToNumberObjectValue()), n.isError() ? n : r.pow(n);
  }
};
var q_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y2.create(1), r = true;
    for (let n = 0; n < e.length; n++) {
      let s = e[n];
      if (s.isError())
        return s;
      if (s.isArray()) {
        let o = false, u = null;
        if (s.iterator((c) => {
          if (c != null && c.isError())
            return o = true, u = c, false;
          if (!c || c.isNull() || c.isString() || c.isBoolean())
            return true;
          t = t.multiply(c), r = false;
        }), o)
          return u;
      } else {
        if (s.isNull())
          continue;
        if (s.isString() && (s = s.convertToNumberObjectValue()), s.isError())
          return s;
        t = t.multiply(s), r = false;
      }
      if (t.isError())
        return t;
    }
    return r ? y2.create(0) : t;
  }
};
var X_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = W2(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = +u.getValue();
    if (Number.isNaN(c) || Number.isNaN(l))
      return g2.create(h.VALUE);
    if (l === 0)
      return g2.create(h.DIV_BY_ZERO);
    const f2 = Math.trunc(c / l);
    return y2.create(f2);
  }
};
var K_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    if (!Number.isFinite(r))
      return g2.create(h.VALUE);
    const n = r * (Math.PI / 180);
    return Number.isNaN(n) ? g2.create(h.VALUE) : y2.create(n);
  }
};
var Z_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 0);
  }
  calculate() {
    return y2.create(Math.random());
  }
};
var z_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 5);
    A(this, "needsSheetRowColumnCount", true);
  }
  calculate(e, t, r, n, s) {
    if (e != null && e.isError())
      return e;
    if (t != null && t.isError())
      return t;
    if (r != null && r.isError())
      return r;
    if (n != null && n.isError())
      return n;
    if (s != null && s.isError())
      return s;
    const o = e != null ? e : y2.create(1), u = t != null ? t : y2.create(1), c = r != null ? r : y2.create(0), l = n != null ? n : y2.create(1), f2 = s != null ? s : y2.create(0);
    return this._calculateResult(o, u, c, l, f2);
  }
  _calculateResult(e, t, r, n, s) {
    const o = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    );
    if (o === 1 && u === 1)
      return this._calculateSingleCell(e, t, r, n, s);
    const c = O(o, u, e, g2.create(h.NA)), l = O(o, u, t, g2.create(h.NA)), f2 = O(o, u, r, g2.create(h.NA)), m2 = O(o, u, n, g2.create(h.NA)), d2 = O(o, u, s, g2.create(h.NA));
    return c.map((_2, C, E) => {
      const R = l.get(C, E), b = f2.get(C, E), p2 = m2.get(C, E), V = d2.get(C, E), S2 = this._handleError(_2, R, b, p2, V);
      if (S2.errorObject)
        return S2.errorObject;
      let { minValue: M2, maxValue: D2, wholeNumberValue: w } = S2, L;
      return w ? (M2 = Math.ceil(M2), D2 = Math.floor(D2), L = Math.floor(Math.random() * (D2 - M2 + 1)) + M2) : L = Math.random() * (D2 - M2) + M2, L < M2 || L > D2 ? g2.create(h.VALUE) : y2.create(L);
    });
  }
  _calculateSingleCell(e, t, r, n, s) {
    let o = e;
    o.isArray() && (o = o.get(0, 0));
    let u = t;
    u.isArray() && (u = u.get(0, 0));
    let c = r;
    c.isArray() && (c = c.get(0, 0));
    let l = n;
    l.isArray() && (l = l.get(0, 0));
    let f2 = s;
    f2.isArray() && (f2 = f2.get(0, 0));
    const m2 = this._handleError(o, u, c, l, f2);
    if (m2.errorObject)
      return m2.errorObject;
    let { rowsValue: d2, columnsValue: _2, minValue: C, maxValue: E, wholeNumberValue: R } = m2;
    if (R && (C = Math.ceil(C), E = Math.floor(E), C > E))
      return g2.create(h.VALUE);
    const b = [];
    for (let p2 = 0; p2 < d2; p2++) {
      const V = [];
      for (let S2 = 0; S2 < _2; S2++)
        R ? V.push(Math.floor(Math.random() * (E - C + 1)) + C) : V.push(Math.random() * (E - C) + C);
      b.push(V);
    }
    return d2 === 1 && _2 === 1 ? y2.create(b[0][0]) : K2.createByArray(b);
  }
  _handleError(e, t, r, n, s) {
    let o = e;
    if (o.isString() && (o = o.convertToNumberObjectValue()), o.isError())
      return {
        errorObject: o
      };
    let u = t;
    if (u.isString() && (u = u.convertToNumberObjectValue()), u.isError())
      return {
        errorObject: u
      };
    let c = r;
    if (c.isString() && (c = c.convertToNumberObjectValue()), c.isError())
      return {
        errorObject: c
      };
    let l = n;
    if (l.isString() && (l = l.convertToNumberObjectValue()), l.isError())
      return {
        errorObject: l
      };
    let f2 = s;
    return f2.isString() && (f2 = f2.convertToNumberObjectValue()), f2.isError() ? {
      errorObject: f2
    } : this._getValue(o, u, c, l, f2);
  }
  _getValue(e, t, r, n, s) {
    const o = Math.floor(+e.getValue()), u = Math.floor(+t.getValue());
    if (o === 0 || u === 0)
      return {
        errorObject: g2.create(h.CALC)
      };
    const c = this._rowCount - this.row, l = this._columnCount - this.column;
    if (o < 0 || u < 0 || o * u > __pow(10, 7))
      return {
        errorObject: g2.create(h.VALUE)
      };
    if (o > c || u > l)
      return {
        errorObject: g2.create(h.REF)
      };
    const f2 = +r.getValue(), m2 = +n.getValue(), d2 = +s.getValue();
    return f2 > m2 ? {
      errorObject: g2.create(h.VALUE)
    } : d2 && (!Number.isInteger(f2) || !Number.isInteger(m2)) ? {
      errorObject: g2.create(h.VALUE)
    } : {
      rowsValue: o,
      columnsValue: u,
      minValue: f2,
      maxValue: m2,
      wholeNumberValue: d2
    };
  }
};
var J_ = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (r.isArray()) {
      const c = r.getRowCount(), l = r.getColumnCount();
      if (c > 1 || l > 1)
        return g2.create(h.VALUE);
      r = r.get(0, 0);
    }
    if (r.isError())
      return r;
    let n = t;
    if (n.isArray()) {
      const c = n.getRowCount(), l = n.getColumnCount();
      if (c > 1 || l > 1)
        return g2.create(h.VALUE);
      n = n.get(0, 0);
    }
    if (n.isError())
      return n;
    if (r.isBoolean() || n.isBoolean())
      return g2.create(h.VALUE);
    let s = +r.getValue(), o = +n.getValue();
    if (Number.isNaN(s) || Number.isNaN(o))
      return g2.create(h.VALUE);
    if (s > o)
      return g2.create(h.NUM);
    s = Math.ceil(s), o = Math.floor(o);
    const u = Math.floor(Math.random() * (o - s + 1)) + s;
    return y2.create(u);
  }
};
var eA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y2.create(0), n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, r, g2.create(h.NA)), c = o.mapValue((l, f2, m2) => {
      const d2 = u.get(f2, m2);
      return l.isError() ? l : d2.isError() ? d2 : this._handleSingleObject(l, d2);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = I2(e);
    if (r)
      return n;
    const [o] = s;
    let u = Math.floor(+o.getValue()), c = t;
    if (c.isString() && (c = c.convertToNumberObjectValue(), c.isError()))
      return c;
    let l = Math.floor(+c.getValue());
    if (c.isBoolean() && (l = c.getValue() ? 0 : 4), u < 0 || u > 3999 || l < 0 || l > 4)
      return g2.create(h.VALUE);
    const f2 = Hh[l];
    let m2 = f2.length - 1, d2 = "";
    for (; u > 0; ) {
      m2 = this._binarySearch(u, 0, m2, f2);
      const _2 = f2[m2];
      u -= _2, d2 += Yh.get(_2);
    }
    return U2.create(d2);
  }
  _binarySearch(e, t, r, n) {
    let s = t, o = r;
    for (; o - s > 1; ) {
      const u = Math.floor((s + o) / 2), c = n[u];
      if (c === e)
        return u;
      c > e ? o = u : s = u;
    }
    return s !== o && n[o] <= e ? o : s;
  }
};
var tA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (r.isString() && (r = r.convertToNumberObjectValue()), r.isError())
      return r;
    let n = t;
    return n.isString() && (n = n.convertToNumberObjectValue()), n.isError() ? n : r.round(n);
  }
};
var rA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g2.create(h.NA)), o = O(r, n, t, g2.create(h.NA)), u = s.mapValue((c, l, f2) => {
      const m2 = o.get(l, f2);
      if (c.isError())
        return c;
      if (m2.isError())
        return m2;
      const { isError: d2, errorObject: _2, variants: C } = I2(c, m2);
      if (d2)
        return _2;
      const [E, R] = C, b = +E.getValue(), p2 = Math.trunc(+R.getValue()), V = this._roundBank(b, p2);
      return y2.create(V);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _roundBank(e, t) {
    if (t > 16)
      return e;
    if (t < -16)
      return 0;
    const r = 1e-8, n = __pow(10, t), s = +(e * n).toFixed(8), o = Math.floor(s), u = s - o;
    let c = Math.round(s);
    return u > 0.5 - r && u < 0.5 + r && (c = o % 2 === 0 ? o : o + 1), t ? c / n : c;
  }
};
var nA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (r.isString() && (r = r.convertToNumberObjectValue()), r.isError())
      return r;
    let n = t;
    return n.isString() && (n = n.convertToNumberObjectValue()), n.isError() ? n : r.floor(n);
  }
};
var sA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (r.isString() && (r = r.convertToNumberObjectValue()), r.isError())
      return r;
    let n = t;
    return n.isString() && (n = n.convertToNumberObjectValue()), n.isError() ? n : r.ceil(n);
  }
};
var aA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    return Math.abs(r) >= __pow(2, 27) ? g2.create(h.NUM) : t.cos().getReciprocal();
  }
};
var iA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    return Number.isFinite(Math.cosh(r)) ? Math.abs(r) >= __pow(2, 27) ? g2.create(h.NUM) : t.cosh().getReciprocal() : y2.create(0);
  }
};
var oA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 4);
    A(this, "needsSheetRowColumnCount", true);
  }
  calculate(e, t, r, n) {
    let s = e, o = t != null ? t : y2.create(1), u = r != null ? r : y2.create(1), c = n != null ? n : y2.create(1);
    s.isNull() && (s = y2.create(1)), o.isNull() && (o = y2.create(1)), u.isNull() && (u = y2.create(1)), c.isNull() && (c = y2.create(1));
    const l = Math.max(
      s.isArray() ? s.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f2 = Math.max(
      s.isArray() ? s.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), m2 = O(l, f2, s, g2.create(h.NA)), d2 = O(l, f2, o, g2.create(h.NA)), _2 = O(l, f2, u, g2.create(h.NA)), C = O(l, f2, c, g2.create(h.NA)), E = m2.mapValue((R, b, p2) => {
      const V = d2.get(b, p2), S2 = _2.get(b, p2), M2 = C.get(b, p2);
      return R.isError() ? R : V.isError() ? V : S2.isError() ? S2 : M2.isError() ? M2 : this._getResult(R, V, S2, M2, l, f2);
    });
    return l === 1 && f2 === 1 ? E.get(0, 0) : E;
  }
  _getResult(e, t, r, n, s, o) {
    const { isError: u, errorObject: c, variants: l } = I2(e, t, r, n);
    if (u)
      return c;
    const [f2, m2, d2, _2] = l, C = Math.floor(+f2.getValue()), E = Math.floor(+m2.getValue()), R = +d2.getValue(), b = +_2.getValue();
    if (C < 0 || E < 0 || C * E > __pow(10, 7))
      return g2.create(h.VALUE);
    if (C === 0 || E === 0)
      return g2.create(h.CALC);
    const p2 = this._rowCount - this.row, V = this._columnCount - this.column;
    if (C > p2 || E > V)
      return g2.create(h.REF);
    const S2 = [];
    for (let M2 = 0; M2 < C; M2++) {
      S2[M2] = [];
      for (let D2 = 0; D2 < E; D2++)
        S2[M2][D2] = R + (M2 * E + D2) * b;
    }
    return s > 1 || o > 1 ? y2.create(S2[0][0]) : K2.createByArray(S2);
  }
};
var uA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    if (e.isNull() || t.isNull() || r.isNull() || n.isNull())
      return g2.create(h.NA);
    const { isError: s, errorObject: o, variants: u } = W2(e, t, r);
    if (s)
      return o;
    const { isError: c, errorObject: l, variants: f2 } = I2(...u);
    if (c)
      return l;
    const [m2, d2, _2] = f2, C = +m2.getValue(), E = +d2.getValue(), R = +_2.getValue(), b = [];
    if (n.isArray()) {
      let V = false, S2 = g2.create(h.VALUE);
      if (n.iterator((M2) => {
        const { isError: D2, errorObject: w, coefficientsObject: L } = this._handleSingleObject(M2);
        if (D2)
          return V = true, S2 = w, false;
        const v = +L.getValue();
        b.push(v);
      }), V)
        return S2;
    } else {
      const { isError: V, errorObject: S2, coefficientsObject: M2 } = this._handleSingleObject(n);
      if (V)
        return S2;
      const D2 = +M2.getValue();
      b.push(D2);
    }
    let p2 = 0;
    for (let V = 0; V < b.length; V++)
      p2 += b[V] * __pow(C, E + V * R);
    return Number.isNaN(p2) || !Number.isFinite(p2) ? g2.create(h.NUM) : y2.create(p2);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return {
        isError: true,
        errorObject: e,
        coefficientsObject: null
      };
    if (e != null && e.isBoolean())
      return {
        isError: true,
        errorObject: g2.create(h.VALUE),
        coefficientsObject: null
      };
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? {
      isError: true,
      errorObject: t,
      coefficientsObject: null
    } : {
      isError: false,
      errorObject: null,
      coefficientsObject: t
    };
  }
};
var cA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    const { isError: t, errorObject: r, variants: n } = I2(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue();
    return o > 0 ? y2.create(1) : o < 0 ? y2.create(-1) : y2.create(0);
  }
};
var lA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.sin();
  }
};
var fA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.sinh();
  }
};
var mA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.sqrt();
  }
};
var hA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    if (t.isArray()) {
      const s = t.getRowCount(), o = t.getColumnCount();
      if (s > 1 || o > 1)
        return g2.create(h.VALUE);
      t = t.get(0, 0);
    }
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    if (r < 0)
      return g2.create(h.NUM);
    const n = Math.sqrt(r * Math.PI);
    return y2.create(n);
  }
};
var gA = {
  1: Me.AVERAGE,
  2: Me.COUNT,
  3: Me.COUNTA,
  4: Me.MAX,
  5: Me.MIN,
  6: Me.PRODUCT,
  7: Me.STDEV,
  8: Me.STDEVP,
  9: Me.SUM,
  10: Me.VAR,
  11: Me.VARP
};
var dA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", true);
    A(this, "needsFilteredOutRows", true);
    A(this, "needsFormulaDataModel", true);
  }
  calculate(e, ...t) {
    let r;
    e.isReferenceObject() ? r = e.toArrayValueObject() : r = e;
    const { isError: n, multiAreaRefs: s, normalRefs: o } = du(t);
    if (!n && s.length > 0)
      return this._handleMultiAreaRefs(r, s, t);
    if (r.isArray()) {
      const u = r.mapValue((c) => this._handleSingleObject(c, {
        isError: n,
        refs: o
      }));
      return u.getRowCount() === 1 && u.getColumnCount() === 1 ? u.get(0, 0) : u;
    }
    return this._handleSingleObject(r, {
      isError: n,
      refs: o
    });
  }
  _handleSingleObject(e, t) {
    const { isError: r = false, refs: n } = t;
    let s = e;
    if (e.isString() && (s = e.convertToNumberObjectValue()), s.isError())
      return s;
    if (r)
      return g2.create(h.VALUE);
    let o = Math.floor(+s.getValue());
    if (o < 1 || o > 11 && o < 101 || o > 111)
      return g2.create(h.VALUE);
    let u = false;
    return o >= 101 && (o -= 100, u = true), Eu({
      type: gA[o],
      ignoreRowHidden: u,
      ignoreErrorValues: false,
      ignoreNested: true,
      formulaDataModel: this._formulaDataModel
    }, n);
  }
  _handleMultiAreaRefs(e, t, r) {
    const n = e.isArray() ? e.getRowCount() : 1, s = e.isArray() ? e.getColumnCount() : 1, { multiAreaInfoMap: o, maxAreasLen: u } = this._getMultiAreaInfo(t), c = Math.max(n, u), l = [];
    for (let f2 = 0; f2 < c; f2++) {
      const m2 = f2 < n ? f2 : n - 1, d2 = [];
      for (let _2 = 0; _2 < s; _2++) {
        if (n > 1 && f2 >= n) {
          d2.push(g2.create(h.NA));
          continue;
        }
        const C = e.isArray() ? e.get(m2, _2) : e, E = [];
        for (let b = 0; b < r.length; b++) {
          const p2 = r[b], V = o.get(p2);
          if (V) {
            const S2 = f2 < V.rowAreas.length ? f2 : V.rowAreas.length - 1, M2 = V.rowAreas[S2];
            if (M2.isError()) {
              d2.push(M2);
              break;
            }
            E.push(M2);
            continue;
          }
          E.push(p2);
        }
        const R = this._handleSingleObject(C, {
          isError: false,
          refs: E
        });
        d2.push(R);
      }
      l.push(d2);
    }
    return l.length === 1 ? l[0][0] : mt(l, l.length, s);
  }
  _getMultiAreaInfo(e) {
    const t = /* @__PURE__ */ new Map();
    let r = 1;
    return e.forEach((n) => {
      const s = n.getAreas().map((o) => {
        if (!o || o.length === 0)
          return n;
        const u = o.find((c) => !c.isError());
        return u != null ? u : o[0];
      });
      t.set(n, {
        ref: n,
        rowAreas: s
      }), r = Math.max(r, s.length || 1);
    }), {
      multiAreaInfoMap: t,
      maxAreasLen: r
    };
  }
};
var CA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y2.create(0);
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (n.isString() && (n = n.convertToNumberObjectValue()), n.isError() || (n.isArray() && (n = n.sum()), n.isError()))
        return n;
      if (t = t.plus(n), t.isError())
        return t;
    }
    return t;
  }
};
var _A = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
    A(this, "needsReferenceObject", true);
  }
  calculate(e, t, r) {
    if (!e.isReferenceObject() || r && !r.isReferenceObject())
      return g2.create(h.VALUE);
    let n = t;
    if (t.isReferenceObject() && (n = t.toArrayValueObject()), n.isArray()) {
      const s = n.mapValue((o) => this._handleSingleObject(e, o, r));
      return s.getRowCount() === 1 && s.getColumnCount() === 1 ? s.get(0, 0) : s;
    }
    return this._handleSingleObject(e, n, r);
  }
  _handleSingleObject(e, t, r) {
    const n = e.toArrayValueObject();
    let s = os(n, t);
    s = us(s, n, t);
    const o = n.getRowCount(), u = n.getColumnCount();
    let c = n;
    if (r) {
      c = r.toArrayValueObject();
      const l = c.getRowCount(), f2 = c.getColumnCount();
      if (o !== l || u !== f2) {
        const m2 = r.getRangeData();
        m2.endRow = m2.startRow + o - 1, m2.endColumn = m2.startColumn + u - 1, r.setRangeData(m2), c = r.toArrayValueObject();
      }
    }
    return c.pick(s).sum();
  }
};
var AA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", true);
  }
  calculate(e, ...t) {
    const {
      isError: r,
      errorObject: n,
      rangeIsDifferentSize: s,
      criteriaMaxRowLength: o,
      criteriaMaxColumnLength: u,
      targetRange: c,
      variants: l
    } = Kr(t, e);
    if (r)
      return n;
    if (s)
      return o === 1 && u === 1 ? g2.create(h.VALUE) : O(o, u, g2.create(h.VALUE));
    const f2 = Zr(l, o, u, true);
    return this._aggregateResults(c, f2);
  }
  _aggregateResults(e, t) {
    const r = t.map((n) => n.map((s) => e.pick(s).sum()));
    return r.length === 1 && r[0].length === 1 ? r[0][0] : K2.create({
      calculateValueList: r,
      rowCount: r.length,
      columnCount: r[0].length,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    });
  }
};
var EA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(e, ...t) {
    if (e.isError())
      return e;
    const r = this._initArray1(e);
    if (t.length === 0)
      return r.sum();
    const n = r.getRowCount(), s = r.getColumnCount(), o = this._getResultArrayByArray1(n, s, r);
    if (o instanceof g2)
      return o;
    const u = o, c = this._validateVariants(t, n, s);
    return c || this._sumProduct(u, t, n, s);
  }
  /**
   * Validate all variants:
   * - propagate first error BaseValueObject
   * - ensure array dimensions are compatible with base (rowCount/columnCount)
   * Returns an ErrorValueObject / BaseValueObject on failure, or null when OK.
   */
  _validateVariants(e, t, r) {
    for (const n of e) {
      if (n.isError())
        return n;
      if (n.isArray()) {
        const s = n, o = s.getRowCount(), u = s.getColumnCount();
        if (o !== t && u !== r)
          return g2.create(h.VALUE);
      }
    }
    return null;
  }
  /**
   * Core SUMPRODUCT loop.
   * - baseArray already contains numeric values from array1
   * - variants may be scalar or array; non-number cells are treated as 0
   * - any error cell short-circuits with that error
   */
  _sumProduct(e, t, r, n) {
    let s = 0;
    for (let o = 0; o < r; o++)
      for (let u = 0; u < n; u++) {
        let c = e[o][u];
        for (let l = 0; l < t.length; l++) {
          const f2 = t[l], m2 = this._getVariantCell(f2, o, u);
          if (!m2)
            return g2.create(h.VALUE);
          if (m2.isError())
            return m2;
          m2.isNumber() ? c *= m2.getValue() : c = 0;
        }
        s += c;
      }
    return y2.create(s);
  }
  /**
   * Get the value object of a variant at (r, c).
   * - For scalar variants, returns the variant itself.
   * - For array variants, returns the cell at (r, c).
   *   If cell does not exist, returns null and let caller convert to #VALUE!.
   */
  _getVariantCell(e, t, r) {
    if (!e.isArray())
      return e;
    const s = e.get(t, r);
    return s != null ? s : null;
  }
  _initArray1(e) {
    let t = e;
    return t.isArray() || (t = K2.create({
      calculateValueList: [[t]],
      rowCount: 1,
      columnCount: 1,
      unitId: "",
      sheetId: "",
      row: 0,
      column: 0
    })), t;
  }
  _getResultArrayByArray1(e, t, r) {
    const n = [];
    for (let s = 0; s < e; s++) {
      const o = [];
      for (let u = 0; u < t; u++) {
        const c = r.get(s, u);
        if (c.isError())
          return c;
        c.isNumber() ? o.push(c.getValue()) : o.push(0);
      }
      n.push(o);
    }
    return n;
  }
};
var RA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y2.create(0);
    const r = y2.create(2);
    for (let n = 0; n < e.length; n++) {
      let s = e[n];
      if (s.isString() && (s = s.convertToNumberObjectValue()), s.isError())
        return s;
      if (s.isArray() ? s.iterator((o) => {
        if (o == null || o.isString() || o.isBoolean() || o.isNull())
          return true;
        if (o.isError())
          return t = o, false;
        t = t.plus(
          o.pow(r)
        );
      }) : t = t.plus(s.pow(r)), t.isError())
        return t;
    }
    return t;
  }
};
var bA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = r * n, o = t.isArray() ? t.getRowCount() : 1, u = t.isArray() ? t.getColumnCount() : 1, c = o * u;
    if (s !== c)
      return g2.create(h.NA);
    if (s === 1)
      return this._calculateSingleCell(e, t);
    {
      const l = e.flatten(), f2 = t.flatten();
      let m2 = ce.create();
      const d2 = [], _2 = [];
      let C = 0;
      return l.iterator((E, R, b) => {
        const p2 = f2.get(R, b);
        if (E == null || E.isString() || E.isBoolean() || E.isNull())
          return true;
        if (E != null && E.isError())
          return m2 = E, false;
        if (p2 == null || p2.isString() || p2.isBoolean() || p2.isNull())
          return true;
        if (p2 != null && p2.isError())
          return m2 = p2, false;
        const V = +E.getValue(), S2 = +p2.getValue();
        d2.push(V), _2.push(S2), C += __pow(V, 2) - __pow(S2, 2);
      }), m2.isError() ? m2 : d2.length === 0 || _2.length === 0 ? g2.create(h.DIV_BY_ZERO) : y2.create(C);
    }
  }
  _calculateSingleCell(e, t) {
    let r = e;
    if (r.isArray() && (r = r.get(0, 0)), r.isError())
      return r;
    let n = t;
    if (n.isArray() && (n = n.get(0, 0)), n.isError())
      return n;
    if (r.isNull() || n.isNull())
      return g2.create(h.VALUE);
    const s = +r.getValue(), o = +n.getValue();
    if (r.isString() && !s1(s) || r.isBoolean() || n.isString() && !s1(o) || n.isBoolean())
      return g2.create(h.DIV_BY_ZERO);
    const u = __pow(s, 2) - __pow(o, 2);
    return y2.create(u);
  }
};
var yA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = r * n, o = t.isArray() ? t.getRowCount() : 1, u = t.isArray() ? t.getColumnCount() : 1, c = o * u;
    if (s !== c)
      return g2.create(h.NA);
    if (s === 1)
      return this._calculateSingleCell(e, t);
    {
      const l = e.flatten(), f2 = t.flatten();
      let m2 = ce.create();
      const d2 = [], _2 = [];
      let C = 0;
      return l.iterator((E, R, b) => {
        const p2 = f2.get(R, b);
        if (E == null || E.isString() || E.isBoolean() || E.isNull())
          return true;
        if (E != null && E.isError())
          return m2 = E, false;
        if (p2 == null || p2.isString() || p2.isBoolean() || p2.isNull())
          return true;
        if (p2 != null && p2.isError())
          return m2 = p2, false;
        const V = +E.getValue(), S2 = +p2.getValue();
        d2.push(V), _2.push(S2), C += __pow(V, 2) + __pow(S2, 2);
      }), m2.isError() ? m2 : d2.length === 0 || _2.length === 0 ? g2.create(h.DIV_BY_ZERO) : y2.create(C);
    }
  }
  _calculateSingleCell(e, t) {
    let r = e;
    if (r.isArray() && (r = r.get(0, 0)), r.isError())
      return r;
    let n = t;
    if (n.isArray() && (n = n.get(0, 0)), n.isError())
      return n;
    if (r.isNull() || n.isNull())
      return g2.create(h.VALUE);
    const s = +r.getValue(), o = +n.getValue();
    if (r.isString() && !s1(s) || r.isBoolean() || n.isString() && !s1(o) || n.isBoolean())
      return g2.create(h.DIV_BY_ZERO);
    const u = __pow(s, 2) + __pow(o, 2);
    return y2.create(u);
  }
};
var pA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = r * n, o = t.isArray() ? t.getRowCount() : 1, u = t.isArray() ? t.getColumnCount() : 1, c = o * u;
    if (s !== c)
      return g2.create(h.NA);
    if (s === 1)
      return this._calculateSingleCell(e, t);
    {
      const l = e.flatten(), f2 = t.flatten();
      let m2 = ce.create();
      const d2 = [], _2 = [];
      let C = 0;
      return l.iterator((E, R, b) => {
        const p2 = f2.get(R, b);
        if (E == null || E.isString() || E.isBoolean() || E.isNull())
          return true;
        if (E != null && E.isError())
          return m2 = E, false;
        if (p2 == null || p2.isString() || p2.isBoolean() || p2.isNull())
          return true;
        if (p2 != null && p2.isError())
          return m2 = p2, false;
        const V = +E.getValue(), S2 = +p2.getValue();
        d2.push(V), _2.push(S2), C += __pow(V - S2, 2);
      }), m2.isError() ? m2 : d2.length === 0 || _2.length === 0 ? g2.create(h.DIV_BY_ZERO) : y2.create(C);
    }
  }
  _calculateSingleCell(e, t) {
    let r = e;
    if (r.isArray() && (r = r.get(0, 0)), r.isError())
      return r;
    let n = t;
    if (n.isArray() && (n = n.get(0, 0)), n.isError())
      return n;
    if (r.isNull() || n.isNull())
      return g2.create(h.VALUE);
    const s = +r.getValue(), o = +n.getValue();
    if (r.isString() && !s1(s) || r.isBoolean() || n.isString() && !s1(o) || n.isBoolean())
      return g2.create(h.DIV_BY_ZERO);
    const u = __pow(s - o, 2);
    return y2.create(u);
  }
};
var NA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.tan();
  }
};
var VA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.tanh();
  }
};
var OA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y2.create(0), n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, r, g2.create(h.NA)), c = o.map((l, f2, m2) => {
      let d2 = u.get(f2, m2), _2 = l;
      if (_2.isString() && (_2 = _2.convertToNumberObjectValue()), _2.isError())
        return _2;
      if (d2.isString() && (d2 = d2.convertToNumberObjectValue()), d2.isError())
        return d2;
      const C = +_2.getValue(), E = +d2.getValue(), R = __pow(10, Math.trunc(E)), b = as(C, R), p2 = Math.trunc(xr(C, R) + b) / R;
      return y2.create(p2);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
};
var SA = [
  [zC, F.ABS],
  [JC2, F.ACOS],
  [e_, F.ACOSH],
  [t_, F.ACOT],
  [r_, F.ACOTH],
  [s_, F.AGGREGATE],
  [a_, F.ARABIC],
  [i_, F.ASIN],
  [o_, F.ASINH],
  [u_, F.ATAN],
  [c_, F.ATAN2],
  [l_, F.ATANH],
  [f_, F.BASE],
  [m_, F.CEILING],
  [h_, F.CEILING_MATH],
  [g_, F.CEILING_PRECISE],
  [d_, F.COMBIN],
  [C_, F.COMBINA],
  [__, F.COS],
  [A_, F.COSH],
  [E_, F.COT],
  [R_, F.COTH],
  [b_, F.CSC],
  [y_, F.CSCH],
  [p_, F.DECIMAL],
  [N_, F.DEGREES],
  [V_, F.EVEN],
  [O_, F.EXP],
  [S_, F.FACT],
  [M_, F.FACTDOUBLE],
  [D_, F.FLOOR],
  [w_, F.FLOOR_MATH],
  [L_, F.FLOOR_PRECISE],
  [P_, F.GCD],
  [x_, F.INT],
  [j_, F.LCM],
  [U_, F.LN],
  [v_, F.LOG],
  [T_, F.LOG10],
  [I_, F.MDETERM],
  [B_, F.MINVERSE],
  [F_, F.MMULT],
  [k_, F.MOD],
  [$_, F.MROUND],
  [Y_, F.MULTINOMIAL],
  [H_, F.MUNIT],
  [G_, F.ODD],
  [W_, F.PI],
  [Q_, F.POWER],
  [q_, F.PRODUCT],
  [X_, F.QUOTIENT],
  [K_, F.RADIANS],
  [Z_, F.RAND],
  [z_, F.RANDARRAY],
  [J_, F.RANDBETWEEN],
  [eA, F.ROMAN],
  [tA, F.ROUND],
  [rA, F.ROUNDBANK],
  [nA, F.ROUNDDOWN],
  [sA, F.ROUNDUP],
  [aA, F.SEC],
  [iA, F.SECH],
  [uA, F.SERIESSUM],
  [oA, F.SEQUENCE],
  [cA, F.SIGN],
  [lA, F.SIN],
  [fA, F.SINH],
  [mA, F.SQRT],
  [hA, F.SQRTPI],
  [dA, F.SUBTOTAL],
  [CA, F.SUM],
  [_A, F.SUMIF],
  [AA, F.SUMIFS],
  [EA, F.SUMPRODUCT],
  [RA, F.SUMSQ],
  [bA, F.SUMX2MY2],
  [yA, F.SUMX2PY2],
  [pA, F.SUMXMY2],
  [NA, F.TAN],
  [VA, F.TANH],
  [OA, F.TRUNC]
];
var MA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
    A(this, "_compareType", Y2.EQUALS);
  }
  setCompareType(e) {
    this._compareType = e;
  }
  calculate(e, t) {
    return e.isError() ? e : t.isError() ? t : e.compare(t, this._compareType);
  }
};
var ei = class _ei extends Qt {
  constructor(e) {
    super("");
    A(this, "_values", []);
    this._values = e;
  }
  static create(e) {
    return new _ei(e);
  }
  isCube() {
    return true;
  }
  dispose() {
    this._values.forEach((e) => {
      e.dispose();
    }), this._values = [];
  }
  getCubeValues() {
    return this._values;
  }
  getCubeCount() {
    return this._values.length;
  }
  sum() {
    const e = y2.create(0);
    return this._values.forEach((t) => {
      e.plus(t.sum());
    }), e;
  }
  max() {
    let e = y2.create(Number.NEGATIVE_INFINITY);
    return this._values.forEach((t) => {
      const r = t.max();
      e.isLessThan(r) && (e = r);
    }), e;
  }
  min() {
    let e = y2.create(Number.POSITIVE_INFINITY);
    return this._values.forEach((t) => {
      const r = t.max();
      e.isGreaterThan(r) && (e = r);
    }), e;
  }
  count() {
    const e = y2.create(0);
    return this._values.forEach((t) => {
      e.plus(t.count());
    }), e;
  }
  countA() {
    const e = y2.create(0);
    return this._values.forEach((t) => {
      e.plus(t.countA());
    }), e;
  }
  countBlank() {
    const e = y2.create(0);
    return this._values.forEach((t) => {
      e.plus(t.countBlank());
    }), e;
  }
};
var DA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      if (n.isError())
        return n;
      if (!n.isArray())
        return g2.create(h.VALUE);
      t.push(n);
    }
    return ei.create(t);
  }
};
var wA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    return e.isError() ? e : t.isError() ? t : !t.isArray() && t.getValue() === 0 ? g2.create(h.DIV_BY_ZERO) : e.divided(t);
  }
};
var LA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    return e.isError() ? e : t.isError() ? t : e.minus(t);
  }
};
var PA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    return e.isError() ? e : t.isError() ? t : e.multiply(t);
  }
};
var xA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    return e.isError() ? e : t.isError() ? t : e.plus(t);
  }
};
var jA = [
  [MA, ke.COMPARE],
  [wA, ke.DIVIDED],
  [LA, ke.MINUS],
  [PA, ke.MULTIPLY],
  [xA, ke.PLUS],
  [DA, ke.CUBE]
];
var P2 = ((a2) => (a2.AVEDEV = "AVEDEV", a2.AVERAGE = "AVERAGE", a2.AVERAGE_WEIGHTED = "AVERAGE.WEIGHTED", a2.AVERAGEA = "AVERAGEA", a2.AVERAGEIF = "AVERAGEIF", a2.AVERAGEIFS = "AVERAGEIFS", a2.BETA_DIST = "BETA.DIST", a2.BETA_INV = "BETA.INV", a2.BINOM_DIST = "BINOM.DIST", a2.BINOM_DIST_RANGE = "BINOM.DIST.RANGE", a2.BINOM_INV = "BINOM.INV", a2.CHISQ_DIST = "CHISQ.DIST", a2.CHISQ_DIST_RT = "CHISQ.DIST.RT", a2.CHISQ_INV = "CHISQ.INV", a2.CHISQ_INV_RT = "CHISQ.INV.RT", a2.CHISQ_TEST = "CHISQ.TEST", a2.CONFIDENCE_NORM = "CONFIDENCE.NORM", a2.CONFIDENCE_T = "CONFIDENCE.T", a2.CORREL = "CORREL", a2.COUNT = "COUNT", a2.COUNTA = "COUNTA", a2.COUNTBLANK = "COUNTBLANK", a2.COUNTIF = "COUNTIF", a2.COUNTIFS = "COUNTIFS", a2.COVARIANCE_P = "COVARIANCE.P", a2.COVARIANCE_S = "COVARIANCE.S", a2.DEVSQ = "DEVSQ", a2.EXPON_DIST = "EXPON.DIST", a2.F_DIST = "F.DIST", a2.F_DIST_RT = "F.DIST.RT", a2.F_INV = "F.INV", a2.F_INV_RT = "F.INV.RT", a2.F_TEST = "F.TEST", a2.FISHER = "FISHER", a2.FISHERINV = "FISHERINV", a2.FORECAST = "FORECAST", a2.FORECAST_ETS = "FORECAST.ETS", a2.FORECAST_ETS_CONFINT = "FORECAST.ETS.CONFINT", a2.FORECAST_ETS_SEASONALITY = "FORECAST.ETS.SEASONALITY", a2.FORECAST_ETS_STAT = "FORECAST.ETS.STAT", a2.FORECAST_LINEAR = "FORECAST.LINEAR", a2.FREQUENCY = "FREQUENCY", a2.GAMMA = "GAMMA", a2.GAMMA_DIST = "GAMMA.DIST", a2.GAMMA_INV = "GAMMA.INV", a2.GAMMALN = "GAMMALN", a2.GAMMALN_PRECISE = "GAMMALN.PRECISE", a2.GAUSS = "GAUSS", a2.GEOMEAN = "GEOMEAN", a2.GROWTH = "GROWTH", a2.HARMEAN = "HARMEAN", a2.HYPGEOM_DIST = "HYPGEOM.DIST", a2.INTERCEPT = "INTERCEPT", a2.KURT = "KURT", a2.LARGE = "LARGE", a2.LINEST = "LINEST", a2.LOGEST = "LOGEST", a2.LOGNORM_DIST = "LOGNORM.DIST", a2.LOGNORM_INV = "LOGNORM.INV", a2.MARGINOFERROR = "MARGINOFERROR", a2.MAX = "MAX", a2.MAXA = "MAXA", a2.MAXIFS = "MAXIFS", a2.MEDIAN = "MEDIAN", a2.MIN = "MIN", a2.MINA = "MINA", a2.MINIFS = "MINIFS", a2.MODE_MULT = "MODE.MULT", a2.MODE_SNGL = "MODE.SNGL", a2.NEGBINOM_DIST = "NEGBINOM.DIST", a2.NORM_DIST = "NORM.DIST", a2.NORM_INV = "NORM.INV", a2.NORM_S_DIST = "NORM.S.DIST", a2.NORM_S_INV = "NORM.S.INV", a2.PEARSON = "PEARSON", a2.PERCENTILE_EXC = "PERCENTILE.EXC", a2.PERCENTILE_INC = "PERCENTILE.INC", a2.PERCENTRANK_EXC = "PERCENTRANK.EXC", a2.PERCENTRANK_INC = "PERCENTRANK.INC", a2.PERMUT = "PERMUT", a2.PERMUTATIONA = "PERMUTATIONA", a2.PHI = "PHI", a2.POISSON_DIST = "POISSON.DIST", a2.PROB = "PROB", a2.QUARTILE_EXC = "QUARTILE.EXC", a2.QUARTILE_INC = "QUARTILE.INC", a2.RANK_AVG = "RANK.AVG", a2.RANK_EQ = "RANK.EQ", a2.RSQ = "RSQ", a2.SKEW = "SKEW", a2.SKEW_P = "SKEW.P", a2.SLOPE = "SLOPE", a2.SMALL = "SMALL", a2.STANDARDIZE = "STANDARDIZE", a2.STDEV_P = "STDEV.P", a2.STDEV_S = "STDEV.S", a2.STDEVA = "STDEVA", a2.STDEVPA = "STDEVPA", a2.STEYX = "STEYX", a2.T_DIST = "T.DIST", a2.T_DIST_2T = "T.DIST.2T", a2.T_DIST_RT = "T.DIST.RT", a2.T_INV = "T.INV", a2.T_INV_2T = "T.INV.2T", a2.T_TEST = "T.TEST", a2.TREND = "TREND", a2.TRIMMEAN = "TRIMMEAN", a2.VAR_P = "VAR.P", a2.VAR_S = "VAR.S", a2.VARA = "VARA", a2.VARPA = "VARPA", a2.WEIBULL_DIST = "WEIBULL.DIST", a2.Z_TEST = "Z.TEST", a2))(P2 || {});
var ti = ((a2) => (a2.ENCODEURL = "ENCODEURL", a2.FILTERXML = "FILTERXML", a2.WEBSERVICE = "WEBSERVICE", a2))(ti || {});
var Wb = /* @__PURE__ */ new Set([
  // Trigonometric & Math extensions
  F.ACOT,
  F.ACOTH,
  F.ARABIC,
  F.BASE,
  F.CEILING_MATH,
  F.CEILING_PRECISE,
  F.COMBINA,
  F.COT,
  F.COTH,
  F.CSC,
  F.CSCH,
  F.DECIMAL,
  F.FLOOR_MATH,
  F.FLOOR_PRECISE,
  F.MUNIT,
  F.RANDARRAY,
  F.SEC,
  F.SECH,
  F.SEQUENCE,
  // Dynamic array functions
  re.CHOOSECOLS,
  re.CHOOSEROWS,
  re.DROP,
  re.EXPAND,
  re.FILTER,
  re.FORMULATEXT,
  re.HSTACK,
  re.SORT,
  re.SORTBY,
  re.TAKE,
  re.TOCOL,
  re.TOROW,
  re.UNIQUE,
  re.VSTACK,
  re.WRAPCOLS,
  re.WRAPROWS,
  re.XLOOKUP,
  re.XMATCH,
  // Bitwise and complex math
  Q.BITAND,
  Q.BITLSHIFT,
  Q.BITOR,
  Q.BITRSHIFT,
  Q.BITXOR,
  Q.ERF_PRECISE,
  Q.ERFC_PRECISE,
  Q.IMCOSH,
  Q.IMCOT,
  Q.IMCSC,
  Q.IMCSCH,
  Q.IMSEC,
  Q.IMSECH,
  Q.IMSINH,
  Q.IMTAN,
  // Information functions
  Ve2.ISFORMULA,
  Ve2.SHEET,
  Ve2.SHEETS,
  // Logical extensions
  Ee.IFNA,
  Ee.IFS,
  Ee.SWITCH,
  Ee.XOR,
  // Statistical and text extensions
  P2.BETA_DIST,
  P2.BETA_INV,
  P2.BINOM_DIST,
  P2.BINOM_DIST_RANGE,
  P2.BINOM_INV,
  P2.CHISQ_DIST,
  P2.CHISQ_DIST_RT,
  P2.CHISQ_INV,
  P2.CHISQ_INV_RT,
  P2.CHISQ_TEST,
  P2.CONFIDENCE_NORM,
  P2.CONFIDENCE_T,
  P2.COVARIANCE_P,
  P2.COVARIANCE_S,
  P2.EXPON_DIST,
  P2.F_DIST,
  P2.F_DIST_RT,
  P2.F_INV,
  P2.F_INV_RT,
  P2.F_TEST,
  P2.FORECAST_LINEAR,
  P2.GAMMA,
  P2.GAMMA_DIST,
  P2.GAMMA_INV,
  P2.GAMMALN_PRECISE,
  P2.GAUSS,
  P2.HYPGEOM_DIST,
  P2.LOGNORM_DIST,
  P2.LOGNORM_INV,
  P2.MAXIFS,
  P2.MINIFS,
  P2.MODE_MULT,
  P2.MODE_SNGL,
  P2.NEGBINOM_DIST,
  P2.NORM_DIST,
  P2.NORM_INV,
  P2.NORM_S_DIST,
  P2.NORM_S_INV,
  P2.PERCENTILE_EXC,
  P2.PERCENTILE_INC,
  P2.PERCENTRANK_EXC,
  P2.PERCENTRANK_INC,
  P2.PERMUTATIONA,
  P2.PHI,
  P2.POISSON_DIST,
  P2.QUARTILE_EXC,
  P2.QUARTILE_INC,
  P2.RANK_AVG,
  P2.RANK_EQ,
  P2.SKEW_P,
  P2.STDEV_P,
  P2.STDEV_S,
  P2.T_DIST,
  P2.T_DIST_2T,
  P2.T_DIST_RT,
  P2.T_INV,
  P2.T_INV_2T,
  P2.T_TEST,
  P2.VAR_P,
  P2.VAR_S,
  P2.WEIBULL_DIST,
  P2.Z_TEST,
  // Text and encoding
  J2.ARRAYTOTEXT,
  ti.ENCODEURL,
  J2.NUMBERVALUE,
  J2.TEXTAFTER,
  J2.TEXTBEFORE,
  J2.TEXTJOIN,
  J2.TEXTSPLIT,
  J2.UNICHAR,
  J2.UNICODE,
  J2.VALUETOTEXT,
  // Date & time
  Ae.DAYS,
  Ae.ISOWEEKNUM,
  ee.PDURATION,
  ee.RRI,
  Ee.BYCOL,
  Ee.BYROW,
  Ee.MAKEARRAY,
  Ee.MAP,
  Ee.REDUCE,
  Ee.SCAN
]);
var UA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y2.create(0), r = y2.create(0);
    for (let o = 0; o < e.length; o++) {
      let u = e[o];
      if (u.isString() && (u = u.convertToNumberObjectValue()), u.isError())
        return u;
      if (u.isArray()) {
        if (u = vA(u), u.isError())
          return u;
        if (e[o] = u, t = t.plus(u.sum()), t.isError())
          return t;
        r = r.plus(u.count());
      } else u.isNull() || (t = t.plus(u), r = r.plus(y2.create(1)));
    }
    if (r.getValue() === 0)
      return g2.create(h.NUM);
    const n = t.divided(r);
    if (n.isError())
      return n;
    let s = y2.create(0);
    for (let o = 0; o < e.length; o++) {
      let u = e[o];
      if (u.isString() && (u = u.convertToNumberObjectValue()), u.isError())
        return u;
      if (u.isArray()) {
        if (s = s.plus(u.minus(n).abs().sum()), s.isError())
          return s;
      } else u.isNull() || (s = s.plus(u.minus(n).abs()));
    }
    return s.divided(r);
  }
};
function vA(a2) {
  const i = [];
  i[0] = [];
  let e = null;
  return a2.iterator((t, r, n) => {
    if (t != null && t.isError())
      return e = t, false;
    t != null && t.isNumber() && i[0].push(t);
  }), e || mt(i, 1, i[0].length);
}
var TA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y2.create(0), r = y2.create(0);
    for (let n = 0; n < e.length; n++) {
      let s = e[n];
      if ((s.isString() || s.isBoolean()) && (s = s.convertToNumberObjectValue()), s.isError())
        return s;
      if (s.isArray()) {
        if (t = t.plus(s.sum()), t.isError())
          return t;
        r = r.plus(s.count());
      } else s.isNull() || (t = t.plus(s), r = r.plus(y2.create(1)));
    }
    return t.divided(r);
  }
};
var IA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 254);
  }
  // eslint-disable-next-line
  calculate(...e) {
    let t = false, r;
    e.length % 2 !== 0 && (t = true, r = g2.create(h.NA));
    const n = [], s = [];
    for (let o = 0; o < e.length; o += 2) {
      const u = e[o], c = u.isArray() ? u.getRowCount() : 1, l = u.isArray() ? u.getColumnCount() : 1;
      for (let _2 = 0; _2 < c; _2++)
        for (let C = 0; C < l; C++) {
          const E = u.isArray() ? u.get(_2, C) : u;
          if (E.isError())
            return E;
          if (t)
            continue;
          const R = E.isNull() ? "" : E.getValue();
          n.push(R);
        }
      if (o + 1 >= e.length)
        continue;
      const f2 = e[o + 1], m2 = f2.isArray() ? f2.getRowCount() : 1, d2 = f2.isArray() ? f2.getColumnCount() : 1;
      (m2 !== c || d2 !== l) && (t = true, r = g2.create(h.VALUE));
      for (let _2 = 0; _2 < m2; _2++)
        for (let C = 0; C < d2; C++) {
          const E = f2.isArray() ? f2.get(_2, C) : f2;
          if (E.isError())
            return E;
          if (t)
            continue;
          const R = E.isNull() ? "" : E.getValue();
          s.push(R);
        }
    }
    return t ? r : this._getResult(n, s);
  }
  _getResult(e, t) {
    const r = e.length;
    let n = 0, s = 0;
    for (let u = 0; u < r; u++) {
      const c = e[u], l = t[u];
      if (!(typeof c != "number" && typeof l != "number")) {
        if (typeof c != "number" || typeof l != "number" || l < 0)
          return g2.create(h.VALUE);
        n += c * l, s += l;
      }
    }
    if (s === 0)
      return g2.create(h.DIV_BY_ZERO);
    const o = n / s;
    return y2.create(o);
  }
};
var BA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y2.create(0), r = y2.create(0);
    for (let n = 0; n < e.length; n++) {
      let s = e[n];
      if ((s.isString() || s.isBoolean()) && (s = s.convertToNumberObjectValue()), s.isError())
        return s;
      if (s.isArray()) {
        if (s.iterator((o) => {
          if (o == null || o.isNull())
            return true;
          let u = o;
          if (u.isString() && (u = u.convertToNumberObjectValue(), u.isError() && (u = y2.create(0))), u.isBoolean() && (u = u.convertToNumberObjectValue()), u.isError())
            return t = u, false;
          t = t.plus(u), r = r.plus(y2.create(1));
        }), t.isError())
          return t;
      } else s.isNull() || (t = t.plus(s), r = r.plus(y2.create(1)));
    }
    return t.divided(r);
  }
};
var FA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
    A(this, "needsReferenceObject", true);
  }
  calculate(e, t, r) {
    if (!e.isReferenceObject() || r && !r.isReferenceObject())
      return g2.create(h.VALUE);
    let n = t;
    if (t.isReferenceObject() && (n = t.toArrayValueObject()), n.isArray()) {
      const s = n.mapValue((o) => this._handleSingleObject(e, o, r));
      return s.getRowCount() === 1 && s.getColumnCount() === 1 ? s.get(0, 0) : s;
    }
    return this._handleSingleObject(e, n, r);
  }
  _handleSingleObject(e, t, r) {
    const n = e.toArrayValueObject();
    let s = os(n, t);
    s = us(s, n, t);
    const o = n.getRowCount(), u = n.getColumnCount();
    let c = n;
    if (r) {
      c = r.toArrayValueObject();
      const d2 = c.getRowCount(), _2 = c.getColumnCount();
      if (o !== d2 || u !== _2) {
        const C = r.getRangeData();
        C.endRow = C.startRow + o - 1, C.endColumn = C.startColumn + u - 1, r.setRangeData(C), c = r.toArrayValueObject();
      }
    }
    const l = c.pick(s), f2 = l.sum(), m2 = l.count();
    return f2.divided(m2);
  }
};
var kA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", true);
  }
  calculate(e, ...t) {
    const {
      isError: r,
      errorObject: n,
      rangeIsDifferentSize: s,
      criteriaMaxRowLength: o,
      criteriaMaxColumnLength: u,
      targetRange: c,
      variants: l
    } = Kr(t, e);
    if (r)
      return n;
    if (s)
      return o === 1 && u === 1 ? g2.create(h.VALUE) : O(o, u, g2.create(h.VALUE));
    const f2 = Zr(l, o, u, true);
    return this._aggregateResults(c, f2);
  }
  _aggregateResults(e, t) {
    const r = t.map((n) => n.map((s) => {
      const o = e.pick(s), u = o.sum(), c = o.count();
      return u.divided(c);
    }));
    return r.length === 1 && r[0].length === 1 ? r[0][0] : K2.create({
      calculateValueList: r,
      rowCount: r.length,
      columnCount: r[0].length,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    });
  }
};
var $A = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    let u = s != null ? s : y2.create(0), c = o != null ? o : y2.create(1);
    u.isNull() && (u = y2.create(0)), c.isNull() && (c = y2.create(1));
    const l = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f2 = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), m2 = O(l, f2, e, g2.create(h.NA)), d2 = O(l, f2, t, g2.create(h.NA)), _2 = O(l, f2, r, g2.create(h.NA)), C = O(l, f2, n, g2.create(h.NA)), E = O(l, f2, u, g2.create(h.NA)), R = O(l, f2, c, g2.create(h.NA)), b = m2.mapValue((p2, V, S2) => {
      const M2 = d2.get(V, S2), D2 = _2.get(V, S2), w = C.get(V, S2), L = E.get(V, S2), v = R.get(V, S2);
      return this._handleSingleObject(p2, M2, D2, w, L, v);
    });
    return l === 1 && f2 === 1 ? b.get(0, 0) : b;
  }
  _handleSingleObject(e, t, r, n, s, o) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (r.isError())
      return r;
    if (n.isError())
      return n;
    if (s.isError())
      return s;
    if (o.isError())
      return o;
    const { isError: u, errorObject: c, variants: l } = I2(e, t, r, n, s, o);
    if (u)
      return c;
    const [f2, m2, d2, _2, C, E] = l, R = +f2.getValue(), b = +m2.getValue(), p2 = +d2.getValue(), V = +_2.getValue(), S2 = +C.getValue(), M2 = +E.getValue();
    if (b <= 0 || p2 <= 0 || R < S2 || R > M2 || S2 === M2)
      return g2.create(h.NUM);
    let D2;
    return V ? D2 = iu((R - S2) / (M2 - S2), b, p2) : D2 = Gh((R - S2) / (M2 - S2), b, p2) / (M2 - S2), y2.create(D2);
  }
};
var YA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    let s = n != null ? n : r;
    s.isNull() && (s = r);
    const o = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, e, g2.create(h.NA)), l = O(o, u, t, g2.create(h.NA)), f2 = O(o, u, r, g2.create(h.NA)), m2 = O(o, u, s, g2.create(h.NA)), d2 = c.mapValue((_2, C, E) => {
      const R = l.get(C, E), b = f2.get(C, E), p2 = m2.get(C, E);
      return _2.isError() ? _2 : R.isError() ? R : b.isError() ? b : p2.isError() ? p2 : this._handleSingleObject(_2, R, b, p2);
    });
    return o === 1 && u === 1 ? d2.get(0, 0) : d2;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = I2(e, t, r, n);
    if (s)
      return o;
    const [c, l, f2, m2] = u, d2 = Math.floor(+c.getValue()), _2 = +l.getValue(), C = Math.floor(+f2.getValue()), E = Math.floor(+m2.getValue());
    if (d2 < 0 || _2 < 0 || _2 > 1 || C < 0 || C > d2 || E < 0 || E < C || E > d2)
      return g2.create(h.NUM);
    let R = 0;
    for (let b = C; b <= E; b++)
      R += Ya(b, d2, _2);
    return y2.create(R);
  }
};
var HA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, t, g2.create(h.NA)), c = O(n, s, r, g2.create(h.NA)), l = o.mapValue((f2, m2, d2) => {
      const _2 = u.get(m2, d2), C = c.get(m2, d2);
      return f2.isError() ? f2 : _2.isError() ? _2 : C.isError() ? C : this._handleSingleObject(f2, _2, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I2(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f2 = +u.getValue(), m2 = Math.floor(+c.getValue()), d2 = +l.getValue();
    if (f2 < 0 || m2 < 1 || m2 > __pow(10, 10))
      return g2.create(h.NUM);
    let _2;
    return d2 ? _2 = Ha(f2, m2) : _2 = Wh(f2, m2), y2.create(_2);
  }
};
var GA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g2.create(h.NA)), o = O(r, n, t, g2.create(h.NA)), u = s.mapValue((c, l, f2) => {
      const m2 = o.get(l, f2);
      return c.isError() ? c : m2.isError() ? m2 : this._handleSingleObject(c, m2);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = I2(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (c < 0 || c > 1 || l < 1 || l > __pow(10, 10))
      return g2.create(h.NUM);
    const f2 = uu(c, l);
    return Number.isNaN(f2) || !Number.isFinite(f2) ? g2.create(h.NUM) : y2.create(f2);
  }
};
var WA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, t, g2.create(h.NA)), c = O(n, s, r, g2.create(h.NA)), l = o.mapValue((f2, m2, d2) => {
      const _2 = u.get(m2, d2), C = c.get(m2, d2);
      if (f2.isError())
        return f2;
      if (_2.isError())
        return _2;
      if (C.isError())
        return C;
      const { isError: E, errorObject: R, variants: b } = I2(f2, _2, C);
      if (E)
        return R;
      const [p2, V, S2] = b, M2 = +p2.getValue(), D2 = +V.getValue(), w = Math.floor(+S2.getValue());
      if (M2 <= 0 || M2 >= 1 || D2 <= 0 || w < 1)
        return g2.create(h.NUM);
      if (w === 1)
        return g2.create(h.DIV_BY_ZERO);
      const L = Math.abs(ms(M2 / 2, w - 1) * D2 / Math.sqrt(w));
      return y2.create(L);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
};
var QA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if (r * n === 1 || s * o === 1)
      return u.isNull() || c.isNull() ? g2.create(h.VALUE) : g2.create(h.DIV_BY_ZERO);
    if (r * n !== s * o)
      return g2.create(h.NA);
    const {
      isError: l,
      errorObject: f2,
      array1Values: m2,
      array2Values: d2,
      noCalculate: _2
    } = st(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f2 : _2 ? g2.create(h.DIV_BY_ZERO) : this._getResult(m2, d2);
  }
  _getResult(e, t) {
    const r = e.length;
    let n = 0, s = 0;
    for (let d2 = 0; d2 < r; d2++)
      n += e[d2], s += t[d2];
    const o = n / r, u = s / r;
    let c = 0, l = 0, f2 = 0;
    for (let d2 = 0; d2 < r; d2++) {
      const _2 = e[d2] - o, C = t[d2] - u;
      c += _2 * C, l += __pow(_2, 2), f2 += __pow(C, 2);
    }
    const m2 = Math.sqrt(l * f2);
    return m2 === 0 ? g2.create(h.DIV_BY_ZERO) : y2.create(c / m2);
  }
};
var qA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y2.create(0);
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      n.isError() || (n.isArray() ? t = t.plus(n.count()) : n.isString() ? n.convertToNumberObjectValue().isError() || (t = t.plus(y2.create(1))) : n.isNull() || (t = t.plus(y2.create(1))));
    }
    return t;
  }
};
var XA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y2.create(0);
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (n.isError()) {
        t = t.plus(y2.create(1));
        continue;
      }
      n.isArray() ? (n = n.countA(), t = t.plus(n)) : n.isNull() || (t = t.plus(y2.create(1)));
    }
    return t;
  }
};
var KA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isError() ? e : e.getValue() === "" || e.isNull() ? y2.create(1) : e.isArray() ? e.countBlank() : y2.create(0);
  }
};
var ZA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
    A(this, "needsReferenceObject", true);
  }
  calculate(e, t) {
    if (!e.isReferenceObject())
      return g2.create(h.VALUE);
    let r = t;
    if (t.isReferenceObject() && (r = t.toArrayValueObject()), r.isArray()) {
      const n = r.mapValue((s) => this._handleSingleObject(e, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(e, r);
  }
  _handleSingleObject(e, t) {
    const r = e.toArrayValueObject();
    let n = os(r, t);
    n = us(n, r, t);
    const s = r.pick(n);
    return this._countA(s);
  }
  _countA(e) {
    let t = y2.create(0);
    return e.iterator((r) => {
      if (r == null)
        return true;
      t = t.plusBy(1);
    }), t;
  }
};
var zA = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", true);
  }
  calculate(...e) {
    const {
      isError: t,
      errorObject: r,
      rangeIsDifferentSize: n,
      criteriaMaxRowLength: s,
      criteriaMaxColumnLength: o,
      variants: u
    } = Kr(e);
    if (t)
      return r;
    if (n)
      return s === 1 && o === 1 ? g2.create(h.VALUE) : O(s, o, g2.create(h.VALUE));
    const c = Zr(u, s, o, true);
    return this._aggregateResults(c);
  }
  _aggregateResults(e) {
    const t = e.map((r) => r.map((n) => JA(n)));
    return t.length === 1 && t[0].length === 1 ? t[0][0] : K2.create({
      calculateValueList: t,
      rowCount: t.length,
      columnCount: t[0].length,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    });
  }
};
function JA(a2) {
  let i = 0;
  return a2.iterator((e) => {
    e != null && e.isBoolean() && e.getValue() === true && i++;
  }), y2.create(i);
}
var eE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if ((r * n === 1 || s * o === 1) && (u.isNull() || c.isNull()))
      return g2.create(h.VALUE);
    if (r * n !== s * o)
      return g2.create(h.NA);
    const {
      isError: l,
      errorObject: f2,
      array1Values: m2,
      array2Values: d2,
      noCalculate: _2
    } = st(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f2 : _2 ? g2.create(h.DIV_BY_ZERO) : this._getResult(m2, d2);
  }
  _getResult(e, t) {
    if (e.length <= 1)
      return g2.create(h.DIV_BY_ZERO);
    const r = e.length;
    let n = 0, s = 0;
    for (let l = 0; l < r; l++)
      n += e[l], s += t[l];
    const o = n / r, u = s / r;
    let c = 0;
    for (let l = 0; l < r; l++) {
      const f2 = e[l] - o, m2 = t[l] - u;
      c += f2 * m2;
    }
    return y2.create(c / (r - 1));
  }
};
var tE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = [];
    let r = 0, n = true;
    for (let u = 0; u < e.length; u++) {
      const c = e[u];
      if (c.isArray()) {
        let l = false, f2 = g2.create(h.VALUE);
        if (c.iterator((m2) => {
          const d2 = this._handleSingleObject(m2);
          if (d2.isError())
            return l = true, f2 = d2, false;
          if (d2.isNull())
            return true;
          const _2 = d2.getValue();
          t.push(_2), r += _2, n = false;
        }), l)
          return f2;
      } else {
        const l = this._handleSingleObject(c);
        if (l.isError())
          return l;
        if (l.isNull())
          continue;
        const f2 = l.getValue();
        t.push(f2), r += f2, n = false;
      }
    }
    if (n)
      return g2.create(h.NUM);
    const s = r / t.length;
    let o = 0;
    for (let u = 0; u < t.length; u++)
      o += __pow(t[u] - s, 2);
    return y2.create(o);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isNull() || e.isBoolean())
      return ce.create();
    const t = e.getValue();
    return s1(t) ? y2.create(+t) : ce.create();
  }
};
var rE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g2.create(h.NA)), c = O(s, o, t, g2.create(h.NA)), l = O(s, o, r, g2.create(h.NA)), f2 = O(s, o, n, g2.create(h.NA)), m2 = u.mapValue((d2, _2, C) => {
      const E = c.get(_2, C), R = l.get(_2, C), b = f2.get(_2, C);
      return d2.isError() ? d2 : E.isError() ? E : R.isError() ? R : b.isError() ? b : this._handleSingleObject(d2, E, R, b);
    });
    return s === 1 && o === 1 ? m2.get(0, 0) : m2;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = I2(e, t, r, n);
    if (s)
      return o;
    const [c, l, f2, m2] = u, d2 = +c.getValue(), _2 = Math.floor(+l.getValue()), C = Math.floor(+f2.getValue()), E = +m2.getValue();
    if (d2 < 0 || _2 < 1 || _2 > __pow(10, 10) || C < 1 || C > __pow(10, 10))
      return g2.create(h.NUM);
    let R;
    return E ? R = Ga(d2, _2, C) : R = Qh(d2, _2, C), Number.isNaN(R) || !Number.isFinite(R) ? g2.create(h.NUM) : y2.create(R);
  }
};
var nE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, t, g2.create(h.NA)), c = O(n, s, r, g2.create(h.NA)), l = o.mapValue((f2, m2, d2) => {
      const _2 = u.get(m2, d2), C = c.get(m2, d2);
      return f2.isError() ? f2 : _2.isError() ? _2 : C.isError() ? C : this._handleSingleObject(f2, _2, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I2(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f2 = +u.getValue(), m2 = Math.floor(+c.getValue()), d2 = Math.floor(+l.getValue());
    if (f2 < 0 || f2 > 1 || m2 < 1 || m2 > __pow(10, 10) || d2 < 1 || d2 > __pow(10, 10))
      return g2.create(h.NUM);
    const _2 = cu(f2, m2, d2);
    return Number.isNaN(_2) || !Number.isFinite(_2) ? g2.create(h.NUM) : y2.create(_2);
  }
};
var sE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.mapValue((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = I2(e);
    if (t)
      return r;
    const [s] = n, o = s.getValue();
    if (o <= -1 || o >= 1)
      return g2.create(h.NUM);
    const u = Math.log((1 + o) / (1 - o)) / 2;
    return y2.create(u);
  }
};
var aE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.mapValue((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = I2(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue(), u = Math.exp(2 * o) - 1, c = Math.exp(2 * o) + 1;
    return !Number.isFinite(u) && u > 0 && !Number.isFinite(c) && c > 0 ? y2.create(1) : y2.create(u / c);
  }
};
var zi = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = t.isArray() ? t.getRowCount() : 1, s = t.isArray() ? t.getColumnCount() : 1, o = r.isArray() ? r.getRowCount() : 1, u = r.isArray() ? r.getColumnCount() : 1;
    let c = t;
    t.isArray() && n === 1 && s === 1 && (c = t.get(0, 0));
    let l = r;
    return r.isArray() && o === 1 && u === 1 && (l = r.get(0, 0)), e.isArray() ? e.mapValue(
      (f2) => this._handleSingleObject(f2, c, l, n, s, o, u)
    ) : this._handleSingleObject(e, c, l, n, s, o, u);
  }
  _handleSingleObject(e, t, r, n, s, o, u) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (r.isError())
      return r;
    let c = e;
    if (e.isString() && (c = e.convertToNumberObjectValue()), c.isError())
      return c;
    const l = +c.getValue();
    if ((n * s === 1 || o * u === 1) && (t.isNull() || r.isNull()))
      return g2.create(h.VALUE);
    if (n * s !== o * u)
      return g2.create(h.NA);
    const {
      isError: f2,
      errorObject: m2,
      array1Values: d2,
      array2Values: _2,
      noCalculate: C
    } = st(
      t,
      r,
      n * s,
      s,
      u
    );
    if (f2)
      return m2;
    if (C)
      return g2.create(h.DIV_BY_ZERO);
    const E = lu(l, d2, _2);
    return Number.isFinite(E) ? y2.create(E) : g2.create(h.DIV_BY_ZERO);
  }
};
var iE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, values: s } = this._getValues(e);
    if (r)
      return n;
    if (e.isNull() || t.isNull())
      return g2.create(h.VALUE);
    let { values: o } = this._getValues(t, true);
    o.length === 0 && (o = [0]);
    const u = this._getNewBinsArrayValues(o), c = new Array(u.length).fill(0);
    for (let l = 0; l < s.length; l++) {
      const f2 = s[l], m2 = u.findIndex((d2) => f2 > d2.start && f2 <= d2.end);
      c[m2]++;
    }
    return K2.createByArray(c.map((l) => [l]));
  }
  _getValues(e, t = false) {
    const r = [], n = e.isArray() ? e.getRowCount() : 1, s = e.isArray() ? e.getColumnCount() : 1;
    for (let o = 0; o < n; o++)
      for (let u = 0; u < s; u++) {
        const c = e.isArray() ? e.get(o, u) : e;
        if (c.isError()) {
          if (!t)
            return {
              isError: true,
              errorObject: c,
              values: r
            };
          continue;
        }
        if (c.isNull() || c.isBoolean())
          continue;
        const l = c.getValue();
        s1(l) && r.push(+l);
      }
    return {
      isError: false,
      errorObject: null,
      values: r
    };
  }
  _getNewBinsArrayValues(e) {
    const t = e.map((n, s) => ({
      value: n,
      index: s
    })).sort((n, s) => n.value - s.value), r = [];
    for (let n = 0; n < t.length; n++) {
      const s = t[n].index;
      if (n === 0) {
        r[s] = {
          start: -1 / 0,
          end: t[n].value
        };
        continue;
      }
      r[s] = {
        start: t[n - 1].value,
        end: t[n].value
      };
    }
    return r.push({
      start: t[t.length - 1].value,
      end: 1 / 0
    }), r;
  }
};
var oE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = I2(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue();
    if (o === 0 || o < 0 && o % 1 === 0)
      return g2.create(h.NUM);
    const u = yn(o);
    return Number.isNaN(u) || !Number.isFinite(u) ? g2.create(h.NUM) : y2.create(u);
  }
};
var Ji = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = I2(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue();
    if (o <= 0)
      return g2.create(h.NUM);
    const u = dt(o);
    return Math.abs(u) < 1e-15 ? y2.create(0) : y2.create(u);
  }
};
var uE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = I2(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue(), u = Jr(o, 0, 1) - 0.5;
    return y2.create(u);
  }
};
var cE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = 1, r = 0, n = false;
    for (let o = 0; o < e.length; o++) {
      const u = e[o];
      if (u.isArray()) {
        let c = false, l = g2.create(h.VALUE);
        if (u.iterator((f2) => {
          if (f2 != null && f2.isError())
            return c = true, l = f2, false;
          if (f2 != null && f2.isNull() || f2 != null && f2.isBoolean())
            return true;
          const m2 = f2.getValue();
          if (!s1(m2))
            return true;
          +m2 <= 0 && (n = true), t *= +m2, r++;
        }), c)
          return l;
      } else {
        if (u.isError())
          return u;
        if (u.isString()) {
          const l = u.convertToNumberObjectValue();
          if (l.isError())
            return l;
        }
        if (u.isNull() || u.isBoolean())
          continue;
        const c = u.getValue();
        if (!s1(c))
          continue;
        +c <= 0 && (n = true), t *= +c, r++;
      }
    }
    if (r === 0 || n)
      return g2.create(h.NUM);
    const s = __pow(t, 1 / r);
    return y2.create(s);
  }
};
var lE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const { isError: s, errorObject: o } = hs(e, t, r);
    if (s)
      return o;
    const u = yt(e);
    if (u instanceof g2)
      return u;
    const c = this._getKnownXsValues(u, t);
    if (c instanceof g2)
      return c;
    const l = this._getNewXsValues(c, r);
    if (l instanceof g2)
      return l;
    let f2 = n != null ? n : T.create(true);
    if (f2.isArray() && (f2 = f2.get(0, 0)), f2.isString() && (f2 = f2.convertToNumberObjectValue()), f2.isError())
      return f2;
    const m2 = +f2.getValue();
    return this._getResult(u, c, l, m2);
  }
  _getResult(e, t, r, n) {
    return e.length === 1 && t.length > 1 || e[0].length === 1 && t[0].length > 1 ? e.length === 1 && t.length > 1 && (n ? t.length + 1 : t.length) > e[0].length || e[0].length === 1 && t[0].length > 1 && (n ? t[0].length + 1 : t[0].length) > e.length ? g2.create(h.NA) : this._getResultByMultipleVariables(e, t, r, n) : this._getResultBySimpleVariables(e, t, r, n);
  }
  _getResultByMultipleVariables(e, t, r, n) {
    const s = e.length === 1 && e[0].length > 1, o = Cs(e, t, r, n, true);
    if (o instanceof g2)
      return o;
    const { coefficients: u, newX: c } = o, l = u[0].length, f2 = u[0][l - 1];
    let m2 = [];
    for (let d2 = 0; d2 < c.length; d2++) {
      m2[d2] = [];
      let _2 = f2;
      for (let C = l - 2; C >= 0; C--)
        _2 *= __pow(u[0][l - 2 - C], c[d2][C]);
      m2[d2].push(_2);
    }
    return s && (m2 = Rt(m2)), K2.createByArray(m2);
  }
  _getResultBySimpleVariables(e, t, r, n) {
    const s = e.flat(), o = t.flat(), { slope: u, intercept: c } = ds(o, s, n, true), l = r.map((f2) => f2.map((m2) => c * __pow(u, m2)));
    return K2.createByArray(l);
  }
  _getKnownXsValues(e, t) {
    return !t || t.isNull() ? gs(e.length, e[0].length) : yt(t);
  }
  _getNewXsValues(e, t) {
    return !t || t.isNull() ? e : yt(t);
  }
};
var fE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = 0, r = 0, n = false;
    for (let o = 0; o < e.length; o++) {
      const u = e[o];
      if (u.isArray()) {
        let c = false, l = g2.create(h.VALUE);
        if (u.iterator((f2) => {
          if (f2 != null && f2.isError())
            return c = true, l = f2, false;
          if (f2 != null && f2.isNull() || f2 != null && f2.isBoolean())
            return true;
          const m2 = f2.getValue();
          if (!s1(m2))
            return true;
          +m2 <= 0 && (n = true), t += 1 / +m2, r++;
        }), c)
          return l;
      } else {
        if (u.isError())
          return u;
        if (u.isString()) {
          const l = u.convertToNumberObjectValue();
          if (l.isError())
            return l;
        }
        if (u.isNull() || u.isBoolean())
          continue;
        const c = u.getValue();
        if (!s1(c))
          continue;
        +c <= 0 && (n = true), t += 1 / +c, r++;
      }
    }
    if (r === 0)
      return g2.create(h.NA);
    if (n)
      return g2.create(h.NUM);
    const s = r / t;
    return y2.create(s);
  }
};
var mE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 5);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    const o = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, e, g2.create(h.NA)), l = O(o, u, t, g2.create(h.NA)), f2 = O(o, u, r, g2.create(h.NA)), m2 = O(o, u, n, g2.create(h.NA)), d2 = O(o, u, s, g2.create(h.NA)), _2 = c.mapValue((C, E, R) => {
      const b = l.get(E, R), p2 = f2.get(E, R), V = m2.get(E, R), S2 = d2.get(E, R);
      return C.isError() ? C : b.isError() ? b : p2.isError() ? p2 : V.isError() ? V : S2.isError() ? S2 : this._handleSingleObject(C, b, p2, V, S2);
    });
    return o === 1 && u === 1 ? _2.get(0, 0) : _2;
  }
  _handleSingleObject(e, t, r, n, s) {
    const { isError: o, errorObject: u, variants: c } = I2(e, t, r, n, s);
    if (o)
      return u;
    const [l, f2, m2, d2, _2] = c, C = Math.floor(+l.getValue()), E = Math.floor(+f2.getValue()), R = Math.floor(+m2.getValue()), b = Math.floor(+d2.getValue()), p2 = +_2.getValue();
    if (C < 0 || C > E || C > R || C < E - b + R || E <= 0 || E > b || R <= 0 || R > b || b <= 0)
      return g2.create(h.NUM);
    let V;
    return p2 ? V = Jh(C, E, R, b) : V = Qa(C, E, R, b), Number.isNaN(V) && (V = 0), y2.create(V);
  }
};
var hE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if (r * n === 1 || s * o === 1)
      return u.isNull() || c.isNull() ? g2.create(h.VALUE) : g2.create(h.DIV_BY_ZERO);
    if (r * n !== s * o)
      return g2.create(h.NA);
    const {
      isError: l,
      errorObject: f2,
      array1Values: m2,
      array2Values: d2,
      noCalculate: _2
    } = st(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f2 : _2 ? g2.create(h.DIV_BY_ZERO) : this._getResult(m2, d2);
  }
  _getResult(e, t) {
    const r = lu(0, e, t);
    return Number.isFinite(r) ? y2.create(r) : g2.create(h.DIV_BY_ZERO);
  }
};
var gE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = [];
    let r = 0;
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      if (s.isError())
        return s;
      if (s.isString()) {
        const c = s.convertToNumberObjectValue();
        if (c.isError())
          return c;
      }
      const o = s.isArray() ? s.getRowCount() : 1, u = s.isArray() ? s.getColumnCount() : 1;
      for (let c = 0; c < o; c++)
        for (let l = 0; l < u; l++) {
          const f2 = s.isArray() ? s.get(c, l) : s;
          if (f2.isError())
            return f2;
          if (f2.isNull() || f2.isBoolean())
            continue;
          const m2 = f2.getValue();
          s1(m2) && (t.push(+m2), r += +m2);
        }
    }
    return t.length <= 3 ? g2.create(h.DIV_BY_ZERO) : this._getResult(t, r);
  }
  _getResult(e, t) {
    const r = e.length, n = t / r;
    let s = 0;
    for (let l = 0; l < r; l++)
      s += __pow(e[l] - n, 2);
    const o = Math.sqrt(s / (r - 1));
    if (o === 0)
      return g2.create(h.DIV_BY_ZERO);
    let u = 0;
    for (let l = 0; l < r; l++)
      u += __pow((e[l] - n) / o, 4);
    const c = r * (r + 1) / ((r - 1) * (r - 2) * (r - 3)) * u - 3 * __pow(r - 1, 2) / ((r - 2) * (r - 3));
    return y2.create(c);
  }
};
var dE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = mr(e);
    if (t.isArray()) {
      const n = t.mapValue((s) => this._handleSingleObject(r, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(r, t);
  }
  _handleSingleObject(e, t) {
    if (!Array.isArray(e))
      return e;
    const { isError: r, errorObject: n, variants: s } = I2(t);
    if (r)
      return n;
    const [o] = s, u = +o.getValue();
    return bu(e, u);
  }
};
var CE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const { isError: s, errorObject: o } = hs(e, t);
    if (s)
      return o;
    const u = yt(e);
    if (u instanceof g2)
      return u;
    const c = this._getKnownXsValues(u, t);
    if (c instanceof g2)
      return c;
    let l = r != null ? r : T.create(true);
    l.isArray() && (l = l.get(0, 0));
    let f2 = n != null ? n : T.create(false);
    f2.isArray() && (f2 = f2.get(0, 0));
    const { isError: m2, errorObject: d2, variants: _2 } = I2(l, f2);
    if (m2)
      return d2;
    const [C, E] = _2;
    return this._getResult(u, c, +C.getValue(), +E.getValue());
  }
  _getResult(e, t, r, n) {
    return e.length === 1 && t.length > 1 || e[0].length === 1 && t[0].length > 1 ? e.length === 1 && t.length > 1 && (r ? t.length + 1 : t.length) > e[0].length || e[0].length === 1 && t[0].length > 1 && (r ? t[0].length + 1 : t[0].length) > e.length ? g2.create(h.NA) : this._getResultByMultipleVariables(e, t, r, n) : this._getResultBySimpleVariables(e, t, r, n);
  }
  _getResultByMultipleVariables(e, t, r, n) {
    const s = Cs(e, t, t, r, false);
    if (s instanceof g2)
      return s;
    const { coefficients: o, X: u, XTXInverse: c } = s;
    let l = [];
    if (n) {
      const f2 = e.flat(), m2 = f2.length, d2 = r ? f2.reduce((j2, k) => j2 + k, 0) / m2 : 0, _2 = c.length, C = m2 - _2, E = o[0].length, R = new Array(E - 2).fill(h.NA), b = o[0][E - 1], p2 = [];
      for (let j2 = 0; j2 < u.length; j2++) {
        let k = b;
        for (let G2 = E - 2; G2 >= 0; G2--)
          k += o[0][E - 2 - G2] * u[j2][G2];
        p2.push(k);
      }
      let V = 0, S2 = 0;
      for (let j2 = 0; j2 < m2; j2++)
        V += __pow(f2[j2] - d2, 2), S2 += __pow(f2[j2] - p2[j2], 2);
      const M2 = V - S2, D2 = V === 0 ? 0 : M2 / V, w = [];
      for (let j2 = _2 - 1; j2 >= 0; j2--) {
        const k = C > 0 ? Math.sqrt(S2 / C * c[j2][j2]) : 0;
        w.push(k);
      }
      if (r) {
        const j2 = w.shift();
        w.push(j2);
      } else
        w.push(h.NA);
      const L = C > 0 ? Math.sqrt(S2 / C) : 0, v = C > 0 ? M2 / (E - 1) / (S2 / C) : h.NUM;
      l = [
        o[0],
        // [mn, mn-1, ..., m1, b]
        [...w],
        // [sen, sen-1, ..., se1, seb]
        [D2, L, ...R],
        // [r2, sey]
        [v, C, ...R],
        // [F, df]
        [M2, S2, ...R]
        // [ssreg, ssresid]
      ];
    } else
      l = [
        o[0]
        // [mn, mn-1, ..., m1, b]
      ];
    return K2.createByArray(l);
  }
  _getResultBySimpleVariables(e, t, r, n) {
    const s = e.flat(), o = t.flat(), { slope: u, intercept: c } = ds(o, s, r, false);
    if (Number.isNaN(u))
      return g2.create(h.NA);
    let l = [];
    if (n) {
      const f2 = s.length;
      let m2 = 0, d2 = 0, _2 = f2 - 1;
      if (r) {
        let w = 0, L = 0;
        for (let v = 0; v < f2; v++)
          w += s[v], L += o[v];
        m2 = w / f2, d2 = L / f2, _2 = f2 - 2;
      }
      let C = 0, E = 0, R = 0;
      for (let w = 0; w < f2; w++)
        C += __pow(s[w] - m2, 2), E += __pow(s[w] - (u * o[w] + c), 2), R += __pow(o[w] - d2, 2);
      const b = C - E, p2 = b === C ? 1 : b / C;
      let V = 0, S2 = 0, M2 = 0;
      _2 > 0 && (R > 0 && (V = Math.sqrt(E / _2 / R), S2 = Math.sqrt(E / _2 * (1 / f2 + __pow(d2, 2) / R))), M2 = Math.sqrt(E / _2));
      const D2 = _2 > 0 ? b / 1 / (E / _2) : h.NUM;
      r || (S2 = h.NA), l = [
        [u, c],
        // [m, b]
        [V, S2],
        // [se, seb]
        [p2, M2],
        // [r2, sey]
        [D2, _2],
        // [F, df]
        [b, E]
        // [ssreg, ssresid]
      ];
    } else
      l = [
        [u, c]
        // [m, b]
      ];
    return K2.createByArray(l);
  }
  _getKnownXsValues(e, t) {
    return !t || t.isNull() ? gs(e.length, e[0].length) : yt(t);
  }
};
var _E = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const { isError: s, errorObject: o } = hs(e, t);
    if (s)
      return o;
    const u = yt(e);
    if (u instanceof g2)
      return u;
    const c = this._getKnownXsValues(u, t);
    if (c instanceof g2)
      return c;
    let l = r != null ? r : T.create(true);
    l.isArray() && (l = l.get(0, 0));
    let f2 = n != null ? n : T.create(false);
    f2.isArray() && (f2 = f2.get(0, 0));
    const { isError: m2, errorObject: d2, variants: _2 } = I2(l, f2);
    if (m2)
      return d2;
    const [C, E] = _2;
    return this._getResult(u, c, +C.getValue(), +E.getValue());
  }
  _getResult(e, t, r, n) {
    return e.length === 1 && t.length > 1 || e[0].length === 1 && t[0].length > 1 ? e.length === 1 && t.length > 1 && (r ? t.length + 1 : t.length) > e[0].length || e[0].length === 1 && t[0].length > 1 && (r ? t[0].length + 1 : t[0].length) > e.length ? g2.create(h.NA) : this._getResultByMultipleVariables(e, t, r, n) : this._getResultBySimpleVariables(e, t, r, n);
  }
  // eslint-disable-next-line max-lines-per-function
  _getResultByMultipleVariables(e, t, r, n) {
    const s = Cs(e, t, t, r, true);
    if (s instanceof g2)
      return s;
    const { coefficients: o, Y: u, X: c, XTXInverse: l } = s;
    let f2 = [];
    if (n) {
      const m2 = u.flat(), d2 = m2.length, _2 = r ? m2.reduce((k, G2) => k + G2, 0) / d2 : 0, C = l.length, E = d2 - C, R = o[0].length, b = new Array(R - 2).fill(h.NA), p2 = o[0][R - 1], V = [];
      for (let k = 0; k < c.length; k++) {
        let G2 = p2;
        for (let ne = R - 2; ne >= 0; ne--)
          G2 *= __pow(o[0][R - 2 - ne], c[k][ne]);
        V.push(Math.log(G2));
      }
      let S2 = 0, M2 = 0;
      for (let k = 0; k < d2; k++)
        S2 += __pow(m2[k] - _2, 2), !(!r && !Number.isFinite(V[k])) && (M2 += __pow(m2[k] - V[k], 2));
      Number.isFinite(M2) || (M2 = 0);
      const D2 = S2 - M2, w = S2 === 0 ? 0 : D2 / S2, L = [];
      for (let k = C - 1; k >= 0; k--) {
        const G2 = E > 0 ? Math.sqrt(M2 / E * l[k][k]) : 0;
        L.push(G2);
      }
      if (r) {
        const k = L.shift();
        L.push(k);
      } else
        L.push(h.NA);
      const v = E > 0 ? Math.sqrt(M2 / E) : 0, j2 = E > 0 ? D2 / (R - 1) / (M2 / E) : h.NUM;
      f2 = [
        o[0],
        // [mn, mn-1, ..., m1, b]
        [...L],
        // [sen, sen-1, ..., se1, seb]
        [w, v, ...b],
        // [r2, sey]
        [j2, E, ...b],
        // [F, df]
        [D2, M2, ...b]
        // [ssreg, ssresid]
      ];
    } else
      f2 = [
        o[0]
        // [mn, mn-1, ..., m1, b]
      ];
    return K2.createByArray(f2);
  }
  _getResultBySimpleVariables(e, t, r, n) {
    const s = e.flat(), o = t.flat(), { slope: u, intercept: c, Y: l } = ds(o, s, r, true);
    if (Number.isNaN(u))
      return g2.create(h.NA);
    let f2 = [];
    if (n) {
      const m2 = l.length;
      let d2 = 0, _2 = 0, C = m2 - 1;
      if (r) {
        let L = 0, v = 0;
        for (let j2 = 0; j2 < m2; j2++)
          L += l[j2], v += o[j2];
        d2 = L / m2, _2 = v / m2, C = m2 - 2;
      }
      let E = 0, R = 0, b = 0;
      for (let L = 0; L < m2; L++)
        E += __pow(l[L] - d2, 2), R += __pow(l[L] - Math.log(c * __pow(u, o[L])), 2), b += __pow(o[L] - _2, 2);
      const p2 = E - R, V = E === 0 ? 0 : p2 / E;
      let S2 = 0, M2 = 0, D2 = 0, w = 0;
      C > 0 && (b > 0 && (S2 = Math.sqrt(R / C / b), M2 = Math.sqrt(R / C * (1 / m2 + __pow(_2, 2) / b))), D2 = Math.sqrt(R / C), w = p2 / 1 / (R / C)), r || (M2 = h.NA), f2 = [
        [u, c],
        // [m, b]
        [S2, M2],
        // [se, seb]
        [V, D2],
        // [r2, sey]
        [w, C],
        // [F, df]
        [p2, R]
        // [ssreg, ssresid]
      ];
    } else
      f2 = [
        [u, c]
        // [m, b]
      ];
    return K2.createByArray(f2);
  }
  _getKnownXsValues(e, t) {
    return !t || t.isNull() ? gs(e.length, e[0].length) : yt(t);
  }
};
var AE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g2.create(h.NA)), c = O(s, o, t, g2.create(h.NA)), l = O(s, o, r, g2.create(h.NA)), f2 = O(s, o, n, g2.create(h.NA)), m2 = u.mapValue((d2, _2, C) => {
      const E = c.get(_2, C), R = l.get(_2, C), b = f2.get(_2, C);
      return d2.isError() ? d2 : E.isError() ? E : R.isError() ? R : b.isError() ? b : this._handleSingleObject(d2, E, R, b);
    });
    return s === 1 && o === 1 ? m2.get(0, 0) : m2;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = I2(e, t, r, n);
    if (s)
      return o;
    const [c, l, f2, m2] = u, d2 = +c.getValue(), _2 = +l.getValue(), C = +f2.getValue(), E = +m2.getValue();
    if (d2 <= 0 || C <= 0)
      return g2.create(h.NUM);
    let R;
    return E ? R = mu(d2, _2, C) : R = eg(d2, _2, C), y2.create(R);
  }
};
var EE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = this._getRangeValues(e);
    if (r instanceof g2)
      return r;
    const n = rr(t);
    if (n.isError())
      return n;
    const { isError: s, errorObject: o, variants: u } = I2(n);
    if (s)
      return o;
    const [c] = u, l = +c.getValue();
    if (l <= 0 || l >= 1)
      return g2.create(h.NUM);
    if (r.length < 2)
      return g2.create(h.DIV_BY_ZERO);
    const f2 = 1 - l, m2 = r.length, d2 = r.reduce((R, b) => R + b, 0) / m2, _2 = r.reduce((R, b) => R + __pow(b - d2, 2), 0) / (m2 - 1), C = Math.sqrt(_2);
    if (C <= 0)
      return g2.create(h.NUM);
    const E = Math.abs(ms(f2 / 2, m2 - 1) * C / Math.sqrt(m2));
    return y2.create(E);
  }
  _getRangeValues(e) {
    const t = [], r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1;
    for (let s = 0; s < r; s++)
      for (let o = 0; o < n; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        u.isNull() || u.isBoolean() || u.isString() || t.push(+u.getValue());
      }
    return t;
  }
};
var RE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y2.create(Number.NEGATIVE_INFINITY);
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (!n.isNull()) {
        if ((n.isString() || n.isBoolean()) && (n = n.convertToNumberObjectValue()), n.isArray() && (n = n.max()), n.isError())
          return n;
        t = this._validator(t, n);
      }
    }
    return t.getValue() === Number.NEGATIVE_INFINITY ? y2.create(0) : t;
  }
  _validator(e, t) {
    const r = e.isLessThan(t);
    let n = e;
    return r.getValue() && (n = t), n;
  }
};
var bE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y2.create(Number.NEGATIVE_INFINITY);
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (!n.isNull()) {
        if ((n.isString() || n.isBoolean()) && (n = n.convertToNumberObjectValue()), n.isError())
          return n;
        if (n.isArray() && n.iterator((s) => {
          let o = s;
          if ((o == null || o.isNull() || o.isString()) && (o = y2.create(0)), o.isBoolean() && (o = o.convertToNumberObjectValue()), o.isError())
            return t = o, false;
          t = this._validator(t, o);
        }), t.isError())
          return t;
        t = this._validator(t, n);
      }
    }
    return t.getValue() === Number.NEGATIVE_INFINITY ? y2.create(0) : t;
  }
  _validator(e, t) {
    const r = e.isLessThan(t);
    let n = e;
    return r.getValue() && (n = t), n;
  }
};
var yE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", true);
  }
  calculate(e, ...t) {
    const {
      isError: r,
      errorObject: n,
      rangeIsDifferentSize: s,
      criteriaMaxRowLength: o,
      criteriaMaxColumnLength: u,
      targetRange: c,
      variants: l
    } = Kr(t, e);
    if (r)
      return n;
    if (s)
      return o === 1 && u === 1 ? g2.create(h.VALUE) : O(o, u, g2.create(h.VALUE));
    const f2 = Zr(l, o, u, true);
    return this._aggregateResults(c, f2);
  }
  _aggregateResults(e, t) {
    const r = t.map((n) => n.map((s) => {
      const o = e.pick(s);
      return o.getColumnCount() === 0 ? K2.create("0") : o.max();
    }));
    return r.length === 1 && r[0].length === 1 ? r[0][0] : K2.create({
      calculateValueList: r,
      rowCount: r.length,
      columnCount: r[0].length,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    });
  }
};
var pE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      if (n.isArray()) {
        let s = false, o = g2.create(h.VALUE);
        if (n.iterator((u) => {
          if (u != null && u.isError())
            return s = true, o = u, false;
          if (u != null && u.isNull() || u != null && u.isBoolean())
            return true;
          const c = u.getValue();
          if (!s1(c))
            return true;
          t.push(+c);
        }), s)
          return o;
      } else {
        if (n.isError())
          return n;
        if (n.isNull() || n.isBoolean())
          continue;
        if (n.isString()) {
          const o = n.convertToNumberObjectValue();
          if (o.isError())
            return o;
        }
        const s = n.getValue();
        if (!s1(s))
          continue;
        t.push(+s);
      }
    }
    return t.length === 0 ? g2.create(h.NUM) : Ru(t);
  }
};
var NE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y2.create(Number.POSITIVE_INFINITY);
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (!n.isNull()) {
        if ((n.isString() || n.isBoolean()) && (n = n.convertToNumberObjectValue()), n.isArray() && (n = n.min()), n.isError())
          return n;
        t = this._validator(t, n);
      }
    }
    return t.getValue() === Number.POSITIVE_INFINITY ? y2.create(0) : t;
  }
  _validator(e, t) {
    const r = e.isGreaterThan(t);
    let n = e;
    return r.getValue() && (n = t), n;
  }
};
var VE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y2.create(Number.POSITIVE_INFINITY);
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (!n.isNull()) {
        if ((n.isString() || n.isBoolean()) && (n = n.convertToNumberObjectValue()), n.isError())
          return n;
        if (n.isArray() && n.iterator((s) => {
          let o = s;
          if ((o == null || o.isNull() || o.isString()) && (o = y2.create(0)), o.isBoolean() && (o = o.convertToNumberObjectValue()), o.isError())
            return t = o, false;
          t = this._validator(t, o);
        }), t.isError())
          return t;
        t = this._validator(t, n);
      }
    }
    return t.getValue() === Number.POSITIVE_INFINITY ? y2.create(0) : t;
  }
  _validator(e, t) {
    const r = e.isGreaterThan(t);
    let n = e;
    return r.getValue() && (n = t), n;
  }
};
var OE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", true);
  }
  calculate(e, ...t) {
    const {
      isError: r,
      errorObject: n,
      rangeIsDifferentSize: s,
      criteriaMaxRowLength: o,
      criteriaMaxColumnLength: u,
      targetRange: c,
      variants: l
    } = Kr(t, e);
    if (r)
      return n;
    if (s)
      return o === 1 && u === 1 ? g2.create(h.VALUE) : O(o, u, g2.create(h.VALUE));
    const f2 = Zr(l, o, u, true);
    return this._aggregateResults(c, f2);
  }
  _aggregateResults(e, t) {
    const r = t.map((n) => n.map((s) => {
      const o = e.pick(s);
      return o.getColumnCount() === 0 ? K2.create("0") : o.min();
    }));
    return r.length === 1 && r[0].length === 1 ? r[0][0] : K2.create({
      calculateValueList: r,
      rowCount: r.length,
      columnCount: r[0].length,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    });
  }
};
var SE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = {};
    let r = 0, n = 1;
    for (let s = 0; s < e.length; s++) {
      const o = e[s];
      if (o.isError())
        return o;
      if (o.isString()) {
        const l = o.convertToNumberObjectValue();
        if (l.isError())
          return l;
      }
      const u = o.isArray() ? o.getRowCount() : 1, c = o.isArray() ? o.getColumnCount() : 1;
      for (let l = 0; l < u; l++)
        for (let f2 = 0; f2 < c; f2++) {
          const m2 = o.isArray() ? o.get(l, f2) : o;
          if (m2.isError())
            return m2;
          if (m2.isNull() || m2.isBoolean() || m2.isString())
            continue;
          const d2 = m2.getValue();
          s1(d2) && (t[+d2] ? (t[+d2].count++, t[+d2].count > n && (n = t[+d2].count)) : t[+d2] = { count: 1, order: r++ });
        }
    }
    return r === 0 || n === 1 ? new g2(h.NA) : this._getResult(t, n);
  }
  _getResult(e, t) {
    const r = Object.entries(e).filter(([n, { count: s }]) => s === t).sort((n, s) => n[1].order - s[1].order).map(([n]) => +n);
    return r.length === 1 ? y2.create(r[0]) : K2.createByArray(r.map((n) => [n]));
  }
};
var ME = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g2.create(h.NA)), c = O(s, o, t, g2.create(h.NA)), l = O(s, o, r, g2.create(h.NA)), f2 = O(s, o, n, g2.create(h.NA)), m2 = u.mapValue((d2, _2, C) => {
      const E = c.get(_2, C), R = l.get(_2, C), b = f2.get(_2, C);
      return d2.isError() ? d2 : E.isError() ? E : R.isError() ? R : b.isError() ? b : this._handleSingleObject(d2, E, R, b);
    });
    return s === 1 && o === 1 ? m2.get(0, 0) : m2;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = I2(e, t, r, n);
    if (s)
      return o;
    const [c, l, f2, m2] = u, d2 = Math.floor(+c.getValue()), _2 = Math.floor(+l.getValue()), C = +f2.getValue(), E = +m2.getValue();
    if (d2 < 0 || _2 < 1 || C <= 0 || C >= 1)
      return g2.create(h.NUM);
    let R;
    return E ? R = rg(d2, _2, C) : R = qa(d2, _2, C), y2.create(R);
  }
};
var DE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g2.create(h.NA)), o = O(r, n, t, g2.create(h.NA)), u = s.mapValue((c, l, f2) => {
      const m2 = o.get(l, f2);
      return c.isError() ? c : m2.isError() ? m2 : this._handleSingleObject(c, m2);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = I2(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = +u.getValue();
    let f2;
    return l ? f2 = Jr(c, 0, 1) : f2 = hu(c, 0, 1), y2.create(f2);
  }
};
var wE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if (r * n === 1 || s * o === 1)
      return u.isNull() || c.isNull() ? g2.create(h.VALUE) : g2.create(h.DIV_BY_ZERO);
    if (r * n !== s * o)
      return g2.create(h.NA);
    const {
      isError: l,
      errorObject: f2,
      array1Values: m2,
      array2Values: d2,
      noCalculate: _2
    } = st(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f2 : _2 ? g2.create(h.DIV_BY_ZERO) : this._getResult(m2, d2);
  }
  _getResult(e, t) {
    const r = e.length;
    let n = 0, s = 0;
    for (let d2 = 0; d2 < r; d2++)
      n += e[d2], s += t[d2];
    const o = n / r, u = s / r;
    let c = 0, l = 0, f2 = 0;
    for (let d2 = 0; d2 < r; d2++)
      c += (e[d2] - o) * (t[d2] - u), l += __pow(e[d2] - o, 2), f2 += __pow(t[d2] - u, 2);
    if (l === 0 || f2 === 0)
      return g2.create(h.DIV_BY_ZERO);
    const m2 = c / Math.sqrt(l * f2);
    return y2.create(m2);
  }
};
var LE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = mr(e);
    if (t.isArray()) {
      const n = t.mapValue((s) => this._handleSingleObject(r, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(r, t);
  }
  _handleSingleObject(e, t) {
    if (!Array.isArray(e))
      return e;
    const { isError: r, errorObject: n, variants: s } = I2(t);
    if (r)
      return n;
    const [o] = s, u = +o.getValue();
    return Nu(e, u);
  }
};
var PE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = this._getValues(e);
    let s = r != null ? r : y2.create(3);
    s.isNull() && (s = y2.create(3));
    const o = Math.max(
      t.isArray() ? t.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      t.isArray() ? t.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, t, g2.create(h.NA)), l = O(o, u, s, g2.create(h.NA)), f2 = c.mapValue((m2, d2, _2) => {
      const C = l.get(d2, _2);
      return m2.isError() ? m2 : C.isError() ? C : this._handleSingleObject(n, m2, C);
    });
    return o === 1 && u === 1 ? f2.get(0, 0) : f2;
  }
  _handleSingleObject(e, t, r) {
    if (e instanceof g2)
      return e;
    const { isError: n, errorObject: s, variants: o } = I2(t, r);
    if (n)
      return s;
    const [u, c] = o, l = +u.getValue(), f2 = Math.floor(+c.getValue()), m2 = e.length;
    if (m2 === 0 || l < e[0] || l > e[m2 - 1])
      return g2.create(h.NA);
    if (m2 === 1)
      return l === e[0] ? y2.create(1) : g2.create(h.NA);
    let d2 = 0, _2 = false, C = 0;
    for (; !_2 && C < m2; )
      l === e[C] ? (d2 = (C + 1) / (m2 + 1), _2 = true) : l > e[C] && C + 1 < m2 && l < e[C + 1] && (d2 = (C + 1 + (l - e[C]) / (e[C + 1] - e[C])) / (m2 + 1), _2 = true), C++;
    return _2 ? f2 < 1 ? g2.create(h.NUM) : (d2 = Ze2(d2, f2), y2.create(d2)) : g2.create(h.NA);
  }
  _getValues(e) {
    const t = e.isArray() ? e.getRowCount() : 1, r = e.isArray() ? e.getColumnCount() : 1, n = [];
    for (let s = 0; s < t; s++)
      for (let o = 0; o < r; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        if (u.isNull() || u.isBoolean())
          continue;
        const c = u.getValue();
        s1(c) && n.push(+c);
      }
    return n.sort((s, o) => s - o);
  }
};
var xE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g2.create(h.NA)), o = O(r, n, t, g2.create(h.NA)), u = s.mapValue((c, l, f2) => {
      const m2 = o.get(l, f2);
      if (c.isError())
        return c;
      if (m2.isError())
        return m2;
      const { isError: d2, errorObject: _2, variants: C } = I2(c, m2);
      if (d2)
        return _2;
      const [E, R] = C, b = Math.floor(+E.getValue()), p2 = Math.floor(+R.getValue());
      if (b < 0 || b >= 2147483647 || p2 < 0 || b < p2)
        return g2.create(h.NUM);
      let V = 1;
      for (let S2 = b - p2 + 1; S2 <= b; S2++)
        V *= S2;
      return Number.isFinite(V) ? y2.create(V) : g2.create(h.NUM);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
};
var jE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g2.create(h.NA)), o = O(r, n, t, g2.create(h.NA)), u = s.mapValue((c, l, f2) => {
      const m2 = o.get(l, f2);
      if (c.isError())
        return c;
      if (m2.isError())
        return m2;
      const { isError: d2, errorObject: _2, variants: C } = I2(c, m2);
      if (d2)
        return _2;
      const [E, R] = C, b = Math.floor(+E.getValue()), p2 = Math.floor(+R.getValue());
      if (b < 0 || b >= 2147483647 || p2 < 0)
        return g2.create(h.NUM);
      if (b === 0)
        return p2 === 0 ? y2.create(1) : y2.create(0);
      const V = __pow(b, p2);
      return Number.isFinite(V) ? y2.create(V) : g2.create(h.NUM);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
};
var UE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = I2(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue(), u = Math.exp(-0.5 * o * o) / Math.sqrt(2 * Math.PI);
    return y2.create(u);
  }
};
var vE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const { isError: s, errorObject: o, xRangeValues: u, probRangeValues: c } = this._handleXRangeAndProbRange(e, t);
    let l = n != null ? n : r;
    n != null && n.isNull() && (l = r);
    const f2 = Math.max(
      r.isArray() ? r.getRowCount() : 1,
      l.isArray() ? l.getRowCount() : 1
    ), m2 = Math.max(
      r.isArray() ? r.getColumnCount() : 1,
      l.isArray() ? l.getColumnCount() : 1
    ), d2 = O(f2, m2, r, g2.create(h.NA)), _2 = O(f2, m2, l, g2.create(h.NA)), C = d2.mapValue((E, R, b) => {
      const p2 = _2.get(R, b);
      return e.isError() ? e : t.isError() ? t : E.isError() ? E : p2.isError() ? p2 : s ? o : this._handleSingleObject(u, c, E, p2);
    });
    return f2 === 1 && m2 === 1 ? C.get(0, 0) : C;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = I2(r, n);
    if (s)
      return o;
    const [c, l] = u, f2 = +c.getValue(), m2 = +l.getValue();
    if (t.reduce((_2, C) => _2 + C, 0) !== 1)
      return g2.create(h.NUM);
    let d2 = 0;
    for (let _2 = 0; _2 < e.length; _2++)
      e[_2] >= f2 && e[_2] <= m2 && (d2 += t[_2]);
    return y2.create(d2);
  }
  // eslint-disable-next-line
  _handleXRangeAndProbRange(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return {
        isError: true,
        errorObject: u,
        xRangeValues: [],
        probRangeValues: []
      };
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return {
        isError: true,
        errorObject: c,
        xRangeValues: [],
        probRangeValues: []
      };
    if ((r * n === 1 || s * o === 1) && (u.isNull() || c.isNull()))
      return {
        isError: true,
        errorObject: g2.create(h.VALUE),
        xRangeValues: [],
        probRangeValues: []
      };
    if (r * n !== s * o)
      return {
        isError: true,
        errorObject: g2.create(h.NA),
        xRangeValues: [],
        probRangeValues: []
      };
    const {
      isError: l,
      errorObject: f2,
      array1Values: m2,
      array2Values: d2,
      noCalculate: _2
    } = st(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? {
      isError: true,
      errorObject: f2,
      xRangeValues: [],
      probRangeValues: []
    } : _2 ? {
      isError: true,
      errorObject: g2.create(h.DIV_BY_ZERO),
      xRangeValues: [],
      probRangeValues: []
    } : {
      isError: false,
      errorObject: null,
      xRangeValues: m2,
      probRangeValues: d2
    };
  }
};
var TE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = mr(e);
    if (t.isArray()) {
      const n = t.mapValue((s) => this._handleSingleObject(r, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(r, t);
  }
  _handleSingleObject(e, t) {
    if (!Array.isArray(e))
      return e;
    const { isError: r, errorObject: n, variants: s } = I2(t);
    if (r)
      return n;
    const [o] = s, u = Math.floor(+o.getValue());
    return Ou(e, u);
  }
};
var IE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
    A(this, "needsReferenceObject", true);
  }
  calculate(e, t, r) {
    let n = e;
    n.isReferenceObject() && (n = n.toArrayValueObject());
    const { refHasError: s, refErrorObject: o, refNumbers: u } = this._checkRefReferenceObject(t);
    let c = r != null ? r : y2.create(0);
    c.isReferenceObject() && (c = c.toArrayValueObject());
    const l = Math.max(
      n.isArray() ? n.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f2 = Math.max(
      n.isArray() ? n.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), m2 = O(l, f2, n, g2.create(h.NA)), d2 = O(l, f2, c, g2.create(h.NA)), _2 = m2.map((C, E, R) => {
      const b = d2.get(E, R);
      if (!e.isReferenceObject() && e.isNull())
        return g2.create(h.NA);
      if (s)
        return o;
      if (b.isError())
        return b;
      const p2 = +C.getValue(), V = +b.getValue();
      return Number.isNaN(p2) || Number.isNaN(V) ? g2.create(h.VALUE) : this._getResult(p2, V, u);
    });
    return l === 1 && f2 === 1 ? _2.get(0, 0) : _2;
  }
  _getResult(e, t, r) {
    const n = r.sort((c, l) => t ? c - l : l - c);
    let s = n.indexOf(e);
    const o = [];
    for (; s >= 0; ) {
      const c = s + 1;
      o.push(c), s = n.indexOf(e, c);
    }
    if (o.length === 0)
      return g2.create(h.NA);
    const u = o.reduce((c, l) => c + l, 0) / o.length;
    return y2.create(u);
  }
  _checkRefReferenceObject(e) {
    let t = false, r = g2.create(h.NA);
    const n = [];
    return e.isReferenceObject() ? (e.toArrayValueObject().iterator((o) => {
      const u = o;
      if (u.isError())
        return t = true, r = u, false;
      if (u.isNull() || u.isBoolean())
        return true;
      const c = +u.getValue();
      if (Number.isNaN(c))
        return true;
      n.push(c);
    }), {
      refHasError: t,
      refErrorObject: r,
      refNumbers: n
    }) : {
      refHasError: true,
      refErrorObject: r,
      refNumbers: n
    };
  }
};
var BE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
    A(this, "needsReferenceObject", true);
  }
  calculate(e, t, r) {
    let n = e;
    n.isReferenceObject() && (n = n.toArrayValueObject());
    const { refHasError: s, refErrorObject: o, refNumbers: u } = this._checkRefReferenceObject(t);
    let c = r != null ? r : y2.create(0);
    c.isReferenceObject() && (c = c.toArrayValueObject());
    const l = Math.max(
      n.isArray() ? n.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f2 = Math.max(
      n.isArray() ? n.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), m2 = O(l, f2, n, g2.create(h.NA)), d2 = O(l, f2, c, g2.create(h.NA)), _2 = m2.map((C, E, R) => {
      const b = d2.get(E, R);
      if (!e.isReferenceObject() && e.isNull())
        return g2.create(h.NA);
      if (s)
        return o;
      if (b.isError())
        return b;
      const p2 = +C.getValue(), V = +b.getValue();
      if (Number.isNaN(p2) || Number.isNaN(V))
        return g2.create(h.VALUE);
      const M2 = u.sort((D2, w) => V ? D2 - w : w - D2).indexOf(p2);
      return M2 === -1 ? g2.create(h.NA) : y2.create(M2 + 1);
    });
    return l === 1 && f2 === 1 ? _2.get(0, 0) : _2;
  }
  _checkRefReferenceObject(e) {
    let t = false, r = g2.create(h.NA);
    const n = [];
    return e.isReferenceObject() ? (e.toArrayValueObject().iterator((o) => {
      const u = o;
      if (u.isError())
        return t = true, r = u, false;
      if (u.isNull() || u.isBoolean())
        return true;
      const c = +u.getValue();
      if (Number.isNaN(c))
        return true;
      n.push(c);
    }), {
      refHasError: t,
      refErrorObject: r,
      refNumbers: n
    }) : {
      refHasError: true,
      refErrorObject: r,
      refNumbers: n
    };
  }
};
var FE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if ((r * n === 1 || s * o === 1) && (u.isNull() || c.isNull()))
      return g2.create(h.VALUE);
    if (r * n !== s * o)
      return g2.create(h.NA);
    const {
      isError: l,
      errorObject: f2,
      array1Values: m2,
      array2Values: d2,
      noCalculate: _2
    } = st(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f2 : _2 ? g2.create(h.DIV_BY_ZERO) : this._getResult(m2, d2);
  }
  _getResult(e, t) {
    if (e.length === 0)
      return g2.create(h.DIV_BY_ZERO);
    const r = e.length;
    let n = 0, s = 0;
    for (let d2 = 0; d2 < r; d2++)
      n += e[d2], s += t[d2];
    const o = n / r, u = s / r;
    let c = 0, l = 0, f2 = 0;
    for (let d2 = 0; d2 < r; d2++)
      c += (e[d2] - o) * (t[d2] - u), l += __pow(e[d2] - o, 2), f2 += __pow(t[d2] - u, 2);
    if (l === 0 || f2 === 0)
      return g2.create(h.DIV_BY_ZERO);
    const m2 = __pow(c / Math.sqrt(l * f2), 2);
    return y2.create(m2);
  }
};
var kE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = [];
    let r = 0;
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      if (s.isError())
        return s;
      if (s.isString()) {
        const c = s.convertToNumberObjectValue();
        if (c.isError())
          return c;
      }
      const o = s.isArray() ? s.getRowCount() : 1, u = s.isArray() ? s.getColumnCount() : 1;
      for (let c = 0; c < o; c++)
        for (let l = 0; l < u; l++) {
          const f2 = s.isArray() ? s.get(c, l) : s;
          if (f2.isError())
            return f2;
          if (f2.isNull() || f2.isBoolean())
            continue;
          const m2 = f2.getValue();
          s1(m2) && (t.push(+m2), r += +m2);
        }
    }
    return t.length <= 2 ? g2.create(h.DIV_BY_ZERO) : this._getResult(t, r);
  }
  _getResult(e, t) {
    const r = e.length, n = t / r;
    let s = 0;
    for (let l = 0; l < r; l++)
      s += __pow(e[l] - n, 2);
    const o = Math.sqrt(s / (r - 1));
    if (o === 0)
      return g2.create(h.DIV_BY_ZERO);
    let u = 0;
    for (let l = 0; l < r; l++)
      u += __pow((e[l] - n) / o, 3);
    const c = r / ((r - 1) * (r - 2)) * u;
    return y2.create(c);
  }
};
var $E = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = [];
    let r = 0;
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      if (s.isError())
        return s;
      if (s.isString()) {
        const c = s.convertToNumberObjectValue();
        if (c.isError())
          return c;
      }
      const o = s.isArray() ? s.getRowCount() : 1, u = s.isArray() ? s.getColumnCount() : 1;
      for (let c = 0; c < o; c++)
        for (let l = 0; l < u; l++) {
          const f2 = s.isArray() ? s.get(c, l) : s;
          if (f2.isError())
            return f2;
          if (f2.isNull() || f2.isBoolean())
            continue;
          const m2 = f2.getValue();
          s1(m2) && (t.push(+m2), r += +m2);
        }
    }
    return t.length <= 2 ? g2.create(h.DIV_BY_ZERO) : this._getResult(t, r);
  }
  _getResult(e, t) {
    const r = e.length, n = t / r;
    let s = 0;
    for (let l = 0; l < r; l++)
      s += __pow(e[l] - n, 2);
    const o = Math.sqrt(s / r);
    if (o === 0)
      return g2.create(h.DIV_BY_ZERO);
    let u = 0;
    for (let l = 0; l < r; l++)
      u += __pow((e[l] - n) / o, 3);
    const c = u / r;
    return y2.create(c);
  }
};
var YE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if (r * n === 1 || s * o === 1)
      return u.isNull() || c.isNull() ? g2.create(h.VALUE) : g2.create(h.DIV_BY_ZERO);
    if (r * n !== s * o)
      return g2.create(h.NA);
    const {
      isError: l,
      errorObject: f2,
      array1Values: m2,
      array2Values: d2,
      noCalculate: _2
    } = st(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f2 : _2 ? g2.create(h.DIV_BY_ZERO) : this._getResult(m2, d2);
  }
  _getResult(e, t) {
    const r = e.length;
    let n = 0, s = 0;
    for (let m2 = 0; m2 < r; m2++)
      n += e[m2], s += t[m2];
    const o = n / r, u = s / r;
    let c = 0, l = 0;
    for (let m2 = 0; m2 < r; m2++)
      c += (e[m2] - o) * (t[m2] - u), l += __pow(t[m2] - u, 2);
    if (l === 0)
      return g2.create(h.DIV_BY_ZERO);
    const f2 = c / l;
    return y2.create(f2);
  }
};
var HE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = mr(e);
    if (t.isArray()) {
      const n = t.mapValue((s) => this._handleSingleObject(r, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(r, t);
  }
  _handleSingleObject(e, t) {
    if (!Array.isArray(e))
      return e;
    const { isError: r, errorObject: n, variants: s } = I2(t);
    if (r)
      return n;
    const [o] = s, u = +o.getValue();
    return yu(e, u);
  }
};
var GE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, t, g2.create(h.NA)), c = O(n, s, r, g2.create(h.NA)), l = o.mapValue((f2, m2, d2) => {
      const _2 = u.get(m2, d2), C = c.get(m2, d2);
      return f2.isError() ? f2 : _2.isError() ? _2 : C.isError() ? C : this._handleSingleObject(f2, _2, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I2(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f2 = +u.getValue(), m2 = +c.getValue(), d2 = +l.getValue();
    if (d2 <= 0)
      return g2.create(h.NUM);
    const _2 = (f2 - m2) / d2;
    return y2.create(_2);
  }
};
var WE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = this.flattenArray(e, false);
    return t.isError() ? t : t.std(1);
  }
};
var QE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = this.flattenArray(e, false);
    return t.isError() ? t : t.std();
  }
};
var qE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if ((r * n === 1 || s * o === 1) && (u.isNull() || c.isNull()))
      return g2.create(h.VALUE);
    if (r * n !== s * o)
      return g2.create(h.NA);
    const {
      isError: l,
      errorObject: f2,
      array1Values: m2,
      array2Values: d2,
      noCalculate: _2
    } = st(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f2 : _2 ? g2.create(h.DIV_BY_ZERO) : this._getResult(m2, d2);
  }
  _getResult(e, t) {
    const r = e.length;
    if (r <= 2)
      return g2.create(h.DIV_BY_ZERO);
    let n = 0, s = 0;
    for (let d2 = 0; d2 < r; d2++)
      n += e[d2], s += t[d2];
    const o = n / r, u = s / r;
    let c = 0, l = 0, f2 = 0;
    for (let d2 = 0; d2 < r; d2++)
      c += (e[d2] - o) * (t[d2] - u), l += __pow(e[d2] - o, 2), f2 += __pow(t[d2] - u, 2);
    if (f2 === 0)
      return g2.create(h.DIV_BY_ZERO);
    const m2 = Math.sqrt((l - __pow(c, 2) / f2) / (r - 2));
    return Number.isNaN(m2) || !Number.isFinite(m2) ? g2.create(h.NUM) : y2.create(m2);
  }
};
var XE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, t, g2.create(h.NA)), c = O(n, s, r, g2.create(h.NA)), l = o.mapValue((f2, m2, d2) => {
      const _2 = u.get(m2, d2), C = c.get(m2, d2);
      return f2.isError() ? f2 : _2.isError() ? _2 : C.isError() ? C : this._handleSingleObject(f2, _2, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I2(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f2 = +u.getValue(), m2 = Math.floor(+c.getValue()), d2 = +l.getValue();
    if (m2 < 1)
      return g2.create(h.NUM);
    let _2;
    return d2 ? _2 = en(f2, m2) : _2 = sg(f2, m2), Number.isNaN(_2) || !Number.isFinite(_2) ? g2.create(h.NUM) : y2.create(_2);
  }
};
var KE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g2.create(h.NA)), o = O(r, n, t, g2.create(h.NA)), u = s.mapValue((c, l, f2) => {
      const m2 = o.get(l, f2);
      return c.isError() ? c : m2.isError() ? m2 : this._handleSingleObject(c, m2);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = I2(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (c < 0 || l < 1 || l > __pow(10, 10))
      return g2.create(h.NUM);
    const f2 = en(-c, l) * 2;
    return Number.isNaN(f2) || !Number.isFinite(f2) ? g2.create(h.NUM) : y2.create(f2);
  }
};
var ZE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g2.create(h.NA)), o = O(r, n, t, g2.create(h.NA)), u = s.mapValue((c, l, f2) => {
      const m2 = o.get(l, f2);
      return c.isError() ? c : m2.isError() ? m2 : this._handleSingleObject(c, m2);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = I2(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (l < 1 || l > __pow(10, 10))
      return g2.create(h.NUM);
    const f2 = en(-c, l);
    return Number.isNaN(f2) || !Number.isFinite(f2) ? g2.create(h.NUM) : y2.create(f2);
  }
};
var zE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g2.create(h.NA)), o = O(r, n, t, g2.create(h.NA)), u = s.mapValue((c, l, f2) => {
      const m2 = o.get(l, f2);
      return c.isError() ? c : m2.isError() ? m2 : this._handleSingleObject(c, m2);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = I2(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (c <= 0 || c > 1 || l < 1 || l > __pow(10, 10))
      return g2.create(h.NUM);
    const f2 = ms(c, l);
    return Number.isNaN(f2) || !Number.isFinite(f2) ? g2.create(h.NUM) : y2.create(f2);
  }
};
var JE = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const { isError: s, errorObject: o } = hs(e, t, r);
    if (s)
      return o;
    const u = yt(e);
    if (u instanceof g2)
      return u;
    const c = this._getKnownXsValues(u, t);
    if (c instanceof g2)
      return c;
    const l = this._getNewXsValues(c, r);
    if (l instanceof g2)
      return l;
    let f2 = n != null ? n : T.create(true);
    if (f2.isArray() && (f2 = f2.get(0, 0)), f2.isString() && (f2 = f2.convertToNumberObjectValue()), f2.isError())
      return f2;
    const m2 = +f2.getValue();
    return this._getResult(u, c, l, m2);
  }
  _getResult(e, t, r, n) {
    return e.length === 1 && t.length > 1 || e[0].length === 1 && t[0].length > 1 ? e.length === 1 && t.length > 1 && (n ? t.length + 1 : t.length) > e[0].length || e[0].length === 1 && t[0].length > 1 && (n ? t[0].length + 1 : t[0].length) > e.length ? g2.create(h.NA) : this._getResultByMultipleVariables(e, t, r, n) : this._getResultBySimpleVariables(e, t, r, n);
  }
  _getResultByMultipleVariables(e, t, r, n) {
    const s = e.length === 1 && e[0].length > 1, o = Cs(e, t, r, n, false);
    if (o instanceof g2)
      return o;
    const { coefficients: u, newX: c } = o, l = u[0].length, f2 = u[0][l - 1];
    let m2 = [];
    for (let d2 = 0; d2 < c.length; d2++) {
      m2[d2] = [];
      let _2 = f2;
      for (let C = l - 2; C >= 0; C--)
        _2 += u[0][l - 2 - C] * c[d2][C];
      m2[d2].push(_2);
    }
    return s && (m2 = Rt(m2)), K2.createByArray(m2);
  }
  _getResultBySimpleVariables(e, t, r, n) {
    const s = e.flat(), o = t.flat(), { slope: u, intercept: c } = ds(o, s, n, false);
    if (Number.isNaN(u))
      return g2.create(h.NA);
    const l = r.map((f2) => f2.map((m2) => u * m2 + c));
    return K2.createByArray(l);
  }
  _getKnownXsValues(e, t) {
    return !t || t.isNull() ? gs(e.length, e[0].length) : yt(t);
  }
  _getNewXsValues(e, t) {
    return !t || t.isNull() ? e : yt(t);
  }
};
var eR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = this._getValues(e);
    if (t.isArray()) {
      const n = t.mapValue((s) => this._handleSingleObject(r, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(r, t);
  }
  _handleSingleObject(e, t) {
    if (e instanceof g2)
      return e;
    const { isError: r, errorObject: n, variants: s } = I2(t);
    if (r)
      return n;
    const [o] = s, u = +o.getValue();
    if (u < 0 || u >= 1)
      return g2.create(h.NUM);
    const c = Ze2(e.length * u / 2, 0) * 2, l = e.slice(c / 2, e.length - c / 2), f2 = l.reduce((m2, d2) => m2 + d2, 0) / l.length;
    return y2.create(f2);
  }
  _getValues(e) {
    const t = e.isArray() ? e.getRowCount() : 1, r = e.isArray() ? e.getColumnCount() : 1, n = [];
    for (let s = 0; s < t; s++)
      for (let o = 0; o < r; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        if (u.isNull() || u.isBoolean())
          continue;
        const c = u.getValue();
        s1(c) && n.push(+c);
      }
    return n.length === 0 ? g2.create(h.NUM) : n.sort((s, o) => s - o);
  }
};
var tR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = this.flattenArray(e, false);
    return t.isError() ? t : t.var(1);
  }
};
var rR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = this.flattenArray(e, false);
    return t.isError() ? t : t.var();
  }
};
var nR = [
  [UA, P2.AVEDEV],
  [TA, P2.AVERAGE],
  [IA, P2.AVERAGE_WEIGHTED],
  [BA, P2.AVERAGEA],
  [FA, P2.AVERAGEIF],
  [kA, P2.AVERAGEIFS],
  [$A, P2.BETA_DIST],
  [Su, P2.BETA_INV],
  [Mu, P2.BINOM_DIST],
  [YA, P2.BINOM_DIST_RANGE],
  [Du, P2.BINOM_INV],
  [HA, P2.CHISQ_DIST],
  [wu, P2.CHISQ_DIST_RT],
  [GA, P2.CHISQ_INV],
  [Lu, P2.CHISQ_INV_RT],
  [Pu, P2.CHISQ_TEST],
  [xu, P2.CONFIDENCE_NORM],
  [WA, P2.CONFIDENCE_T],
  [QA, P2.CORREL],
  [qA, P2.COUNT],
  [XA, P2.COUNTA],
  [KA, P2.COUNTBLANK],
  [ZA, P2.COUNTIF],
  [zA, P2.COUNTIFS],
  [ju, P2.COVARIANCE_P],
  [eE, P2.COVARIANCE_S],
  [tE, P2.DEVSQ],
  [Uu, P2.EXPON_DIST],
  [rE, P2.F_DIST],
  [vu, P2.F_DIST_RT],
  [nE, P2.F_INV],
  [Tu, P2.F_INV_RT],
  [Iu, P2.F_TEST],
  [sE, P2.FISHER],
  [aE, P2.FISHERINV],
  [zi, P2.FORECAST],
  [zi, P2.FORECAST_LINEAR],
  [iE, P2.FREQUENCY],
  [oE, P2.GAMMA],
  [Bu, P2.GAMMA_DIST],
  [Fu, P2.GAMMA_INV],
  [Ji, P2.GAMMALN],
  [Ji, P2.GAMMALN_PRECISE],
  [uE, P2.GAUSS],
  [cE, P2.GEOMEAN],
  [lE, P2.GROWTH],
  [fE, P2.HARMEAN],
  [mE, P2.HYPGEOM_DIST],
  [hE, P2.INTERCEPT],
  [gE, P2.KURT],
  [dE, P2.LARGE],
  [CE, P2.LINEST],
  [_E, P2.LOGEST],
  [AE, P2.LOGNORM_DIST],
  [ku, P2.LOGNORM_INV],
  [EE, P2.MARGINOFERROR],
  [RE, P2.MAX],
  [bE, P2.MAXA],
  [yE, P2.MAXIFS],
  [pE, P2.MEDIAN],
  [NE, P2.MIN],
  [VE, P2.MINA],
  [OE, P2.MINIFS],
  [SE, P2.MODE_MULT],
  [$u, P2.MODE_SNGL],
  [ME, P2.NEGBINOM_DIST],
  [Yu, P2.NORM_DIST],
  [Hu, P2.NORM_INV],
  [DE, P2.NORM_S_DIST],
  [Gu, P2.NORM_S_INV],
  [wE, P2.PEARSON],
  [LE, P2.PERCENTILE_EXC],
  [Wu, P2.PERCENTILE_INC],
  [PE, P2.PERCENTRANK_EXC],
  [Qu, P2.PERCENTRANK_INC],
  [xE, P2.PERMUT],
  [jE, P2.PERMUTATIONA],
  [UE, P2.PHI],
  [qu, P2.POISSON_DIST],
  [vE, P2.PROB],
  [TE, P2.QUARTILE_EXC],
  [Xu, P2.QUARTILE_INC],
  [IE, P2.RANK_AVG],
  [BE, P2.RANK_EQ],
  [FE, P2.RSQ],
  [kE, P2.SKEW],
  [$E, P2.SKEW_P],
  [YE, P2.SLOPE],
  [HE, P2.SMALL],
  [GE, P2.STANDARDIZE],
  [Ku, P2.STDEV_P],
  [Zu, P2.STDEV_S],
  [WE, P2.STDEVA],
  [QE, P2.STDEVPA],
  [qE, P2.STEYX],
  [XE, P2.T_DIST],
  [KE, P2.T_DIST_2T],
  [ZE, P2.T_DIST_RT],
  [zE, P2.T_INV],
  [zu, P2.T_INV_2T],
  [Ju, P2.T_TEST],
  [JE, P2.TREND],
  [eR, P2.TRIMMEAN],
  [ec, P2.VAR_P],
  [tc, P2.VAR_S],
  [tR, P2.VARA],
  [rR, P2.VARPA],
  [rc, P2.WEIBULL_DIST],
  [nc, P2.Z_TEST]
];
var sR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = t != null ? t : y2.create(0);
    if (t != null && t.isNull() && (r = y2.create(0)), r.isArray()) {
      const n = r.mapValue((s) => this._handleSingleObject(e, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(e, r);
  }
  _handleSingleObject(e, t) {
    const r = this._checkArray(e);
    if (r.isError())
      return r;
    const { isError: n, errorObject: s, variants: o } = I2(t);
    if (n)
      return s;
    const [u] = o, c = +u.getValue(), l = e.isArray() ? e.getRowCount() : 1, f2 = e.isArray() ? e.getColumnCount() : 1;
    let m2 = "";
    for (let d2 = 0; d2 < l; d2++)
      for (let _2 = 0; _2 < f2; _2++) {
        const C = e.isArray() ? e.get(d2, _2) : e;
        let E = `${C.getValue()}`;
        C.isNull() && (E = ""), C.isBoolean() && (E = E.toLocaleUpperCase()), C.isString() && c ? m2 += `"${E}"` : m2 += E, d2 === l - 1 && _2 === f2 - 1 || (c ? _2 === f2 - 1 ? m2 += ";" : m2 += "," : m2 += ", ");
      }
    return c && (m2 = `{${m2}}`), m2.length > 32767 ? g2.create(h.CALC) : U2.create(m2);
  }
  _checkArray(e) {
    if (e.isArray()) {
      const t = e.getRowCount(), r = e.getColumnCount();
      return t > 1 || r > 1 ? e : e.get(0, 0);
    }
    return e;
  }
};
var aR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError() || e.isNull() || e.isBoolean() || e.isNumber())
      return e;
    const t = e.getValue().toLocaleString();
    let r = "";
    for (let n = 0; n < t.length; n++) {
      let s = t.charCodeAt(n);
      s === 12288 ? s = 32 : s >= 65281 && s <= 65374 && (s -= 65248), r += String.fromCharCode(s);
    }
    return U2.create(r);
  }
};
var iR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = I2(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue(), u = Math.abs(Number.parseInt(o.toString(), 10)), c = Number.parseFloat((Math.abs(o) - u).toFixed(2));
    let l = "";
    return u === 0 ? c !== 0 ? l = `${o < 0 ? "ลบ" : ""}${this._convertNumberToThaiText(c * 100)}สตางค์` : l = "ศูนย์บาทถ้วน" : c === 0 ? l = `${o < 0 ? "ลบ" : ""}${this._convertNumberToThaiText(u)}บาทถ้วน` : l = `${o < 0 ? "ลบ" : ""}${this._convertNumberToThaiText(u)}บาท${this._convertNumberToThaiText(c * 100)}สตางค์`, U2.create(l);
  }
  _convertNumberToThaiText(e) {
    const t = ["ล้าน", "สิบ", "ร้อย", "พัน", "หมื่น", "แสน", ""], r = ["ศูนย์", "หนึ่ง", "สอง", "สาม", "สี่", "ห้า", "หก", "เจ็ด", "แปด", "เก้า"], n = ["ลบ", "บาท", "ถ้วน", "สตางค์", "ยี่", "เอ็ด", ",", " ", "฿"], s = e.toString(), o = s.length;
    let u = "";
    for (let c = o; c > 0; c--) {
      const l = Number.parseInt(s.charAt(o - c), 10);
      let f2 = r[l];
      const m2 = c > 1 ? (c - 1) % 6 : 6;
      if (m2 === 1 && l === 2 && (f2 = n[4]), l === 1)
        switch (m2) {
          case 0:
          case 6:
            u += c < o ? n[5] : f2;
            break;
          case 1:
            break;
          default:
            u += f2;
            break;
        }
      else if (l === 0) {
        m2 === 0 && (u += t[m2]);
        continue;
      } else
        u += f2;
      u += t[m2];
    }
    return u;
  }
};
var oR = Object.values(ct).filter((a2) => [
  ct.TABLE_START,
  ct.TABLE_ROW_START,
  ct.TABLE_CELL_START,
  ct.TABLE_CELL_END,
  ct.TABLE_ROW_END,
  ct.TABLE_END,
  ct.CUSTOM_BLOCK
].includes(a2));
var uR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = I2(e);
    if (t)
      return r;
    const [s] = n, o = Math.floor(+s.getValue());
    if (o <= 0)
      return g2.create(h.VALUE);
    let u = String.fromCharCode(o);
    return oR.some((c) => c === u) && (u = ""), U2.create(u);
  }
};
var cR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError() || e.isBoolean() || e.isNumber())
      return e;
    if (e.isNull())
      return U2.create("");
    const r = `${e.getValue()}`.replace(/[\0-\x1F]/g, "");
    return U2.create(r);
  }
};
var lR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isNull())
      return g2.create(h.VALUE);
    let t = e.getValue().toLocaleString();
    if (e.isBoolean() && (t = t.toLocaleUpperCase()), t === "")
      return g2.create(h.VALUE);
    const r = t.charCodeAt(0);
    return y2.create(r);
  }
};
var fR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = "", r = null;
    for (const n of e)
      if (n.isArray()) {
        if (n.iterator((s) => {
          if (s == null || s.isNull())
            return true;
          if (s.isError())
            return r = s, false;
          s.isBoolean() ? t += `${s.getValue()}`.toLocaleUpperCase() : (s.isString() || s.isNumber()) && (t += s.getValue());
        }), r)
          return r;
      } else !n.isError() && !n.isNull() && (t += n.getValue());
    return U2.create(t);
  }
};
var mR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = 0, r = 0;
    e.forEach((s) => {
      if (s.isArray()) {
        const o = s;
        t = Math.max(t, o.getRowCount()), r = Math.max(r, o.getColumnCount());
      } else
        t = Math.max(t, 1), r = Math.max(r, 1);
    });
    let n = null;
    for (const s of e)
      n = O(t, r, s, g2.create(h.NA)).mapValue((u, c, l) => {
        const f2 = n && n.get(c, l);
        if (f2 != null && f2.isError())
          return f2;
        if (u.isError())
          return u;
        let m2 = f2 == null ? void 0 : f2.getValue(), d2 = u == null ? void 0 : u.getValue();
        f2 != null && f2.isBoolean() && (m2 = `${m2}`.toLocaleUpperCase()), u != null && u.isBoolean() && (d2 = `${d2}`.toLocaleUpperCase());
        const _2 = f2 != null && f2.isNull() ? "" : m2 != null ? m2 : "", C = u != null && u.isNull() ? "" : d2 != null ? d2 : "";
        return U2.create(`${_2}${C}`);
      });
    return n || g2.create(h.VALUE);
  }
};
var hR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isNull())
      return U2.create("");
    let t = `${e.getValue()}`;
    e.isBoolean() && (t = t.toLocaleUpperCase());
    let r = "";
    for (let n = 0; n < t.length; n++) {
      const s = t.charCodeAt(n);
      s >= 33 && s <= 126 ? r += String.fromCharCode(s + 65248) : s === 32 ? r += "　" : r += t.charAt(n);
    }
    return U2.create(r);
  }
};
var gR2 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
    A(this, "needsLocale", true);
  }
  calculate(e, t) {
    let r = t != null ? t : y2.create(2);
    r.isNull() && (r = y2.create(2));
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, r, g2.create(h.NA)), c = o.mapValue((l, f2, m2) => {
      const d2 = u.get(f2, m2);
      return l.isError() ? l : d2.isError() ? d2 : this._handleSingleObject(l, d2);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = I2(e, t);
    if (r)
      return n;
    const [o, u] = s;
    let c = +o.getValue(), l = Math.trunc(+u.getValue());
    if (l > 127)
      return g2.create(h.VALUE);
    l < 0 && (`${c}`.length < Math.abs(l) ? c = 0 : c = c < 0 ? -kt(Math.abs(c), l) : kt(c, l), l = 0);
    const f2 = ff(this.getLocale(), c, l);
    return U2.create(f2);
  }
};
var dR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, ce.create()), o = O(r, n, t, ce.create()), u = s.mapValue((c, l, f2) => {
      const m2 = o.get(l, f2);
      return c.isError() ? c : m2.isError() ? m2 : this._handleSingleObject(c, m2);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    if (e.isNull() || t.isNull()) {
      const o = e.isNull() && t.isNull();
      return T.create(o);
    }
    let r = `${e.getValue()}`;
    e.isBoolean() && (r = r.toLocaleUpperCase());
    let n = `${t.getValue()}`;
    t.isBoolean() && (n = n.toLocaleUpperCase());
    const s = r === n;
    return T.create(s);
  }
};
var ri = (a2, i) => a1.format(a2, i, { throws: false });
var Pe = (a2) => {
  let i = `${a2.getValue()}`;
  return a2.isNull() && (i = ""), a2.isBoolean() && (i = i.toLocaleUpperCase()), a2.isNumber() && (a2.getPattern() !== "" ? i = ri(a2.getPattern(), +a2.getValue()) : i = `${Sa(+a2.getValue())}`), i;
};
var CR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : y2.create(1), s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g2.create(h.NA)), c = O(s, o, t, g2.create(h.NA)), l = O(s, o, n, g2.create(h.NA)), f2 = u.mapValue((m2, d2, _2) => {
      const C = c.get(d2, _2), E = l.get(d2, _2);
      return m2.isError() ? m2 : C.isError() ? C : E.isError() ? E : this._handleSingleObject(m2, C, E);
    });
    return s === 1 && o === 1 ? f2.get(0, 0) : f2;
  }
  _handleSingleObject(e, t, r) {
    const n = Pe(e), s = Pe(t), { isError: o, errorObject: u, variants: c } = I2(r);
    if (o)
      return u;
    const [l] = c, f2 = Math.floor(+l.getValue());
    if (t.isNull() || f2 <= 0 || f2 > s.length)
      return g2.create(h.VALUE);
    if (e.isNull() || n.length === 0)
      return y2.create(f2);
    const m2 = s.indexOf(n, f2 - 1);
    return m2 === -1 ? g2.create(h.VALUE) : y2.create(m2 + 1);
  }
};
function ni(a2) {
  let i = 0;
  for (let e = 0; e < a2.length; e++)
    i += sn(a2, e);
  return i;
}
function sn(a2, i, e = "ltr") {
  return _R(a2, i, e) > 255 ? 2 : 1;
}
function eo(a2) {
  return a2 >= 55296 && a2 <= 56319;
}
function to(a2) {
  return a2 >= 56320 && a2 <= 57343;
}
function ro(a2, i) {
  const e = (a2 & 1023) << 10, t = i & 1023;
  return e + t + 65536;
}
function _R(a2, i, e = "ltr") {
  const t = a2.charCodeAt(i);
  if (e === "ltr" && eo(t) && i + 1 < a2.length) {
    const r = a2.charCodeAt(i + 1);
    if (to(r))
      return ro(t, r);
  }
  if (e === "rtl" && to(t) && i - 1 >= 0) {
    const r = a2.charCodeAt(i - 1);
    if (eo(r))
      return ro(r, t);
  }
  return t;
}
var AR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : y2.create(1), s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g2.create(h.NA)), c = O(s, o, t, g2.create(h.NA)), l = O(s, o, n, g2.create(h.NA)), f2 = u.mapValue((m2, d2, _2) => {
      const C = c.get(d2, _2), E = l.get(d2, _2);
      return m2.isError() ? m2 : C.isError() ? C : E.isError() ? E : this._handleSingleObject(m2, C, E);
    });
    return s === 1 && o === 1 ? f2.get(0, 0) : f2;
  }
  _handleSingleObject(e, t, r) {
    const n = Pe(e), s = Pe(t), { isError: o, errorObject: u, variants: c } = I2(r);
    if (o)
      return u;
    const [l] = c, f2 = Math.floor(+l.getValue());
    if (t.isNull() || f2 <= 0 || f2 > s.length)
      return g2.create(h.VALUE);
    if (e.isNull() || n.length === 0)
      return y2.create(f2);
    const m2 = s.indexOf(n, f2 - 1);
    if (m2 === -1)
      return g2.create(h.VALUE);
    const d2 = ni(s.substring(0, m2)) + 1;
    return y2.create(d2);
  }
};
var ER2 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    let n = t != null ? t : y2.create(2);
    n.isNull() && (n = y2.create(2));
    let s = r != null ? r : T.create(false);
    s.isNull() && (s = T.create(false));
    const o = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, e, g2.create(h.NA)), l = O(o, u, n, g2.create(h.NA)), f2 = O(o, u, s, g2.create(h.NA)), m2 = c.mapValue((d2, _2, C) => {
      const E = l.get(_2, C), R = f2.get(_2, C);
      return d2.isError() ? d2 : E.isError() ? E : R.isError() ? R : this._handleSingleObject(d2, E, R);
    });
    return o === 1 && u === 1 ? m2.get(0, 0) : m2;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I2(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o;
    let f2 = +u.getValue(), m2 = Math.trunc(+c.getValue());
    const d2 = +l.getValue();
    if (m2 > 127)
      return g2.create(h.VALUE);
    m2 < 0 && (`${f2}`.length < Math.abs(m2) ? f2 = 0 : f2 = f2 < 0 ? -kt(Math.abs(f2), m2) : kt(f2, m2), m2 = 0);
    let _2 = d2 ? "###0" : "#,##0";
    m2 > 0 && (_2 += `.${"0".repeat(m2)}`);
    const C = ri(_2, f2);
    return U2.create(C);
  }
};
var RR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y2.create(1), n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, r, g2.create(h.NA)), c = o.mapValue((l, f2, m2) => {
      const d2 = u.get(f2, m2);
      return l.isError() ? l : d2.isError() ? d2 : this._handleSingleObject(l, d2);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
  _handleSingleObject(e, t) {
    const r = Pe(e), { isError: n, errorObject: s, variants: o } = I2(t);
    if (n)
      return s;
    const [u] = o, c = Math.floor(+u.getValue());
    if (c < 0)
      return g2.create(h.VALUE);
    if (e.isNull() || c === 0)
      return U2.create("");
    if (c >= r.length)
      return U2.create(r);
    const l = r.substring(0, c);
    return U2.create(l);
  }
};
var bR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y2.create(1), n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, ce.create()), u = O(n, s, r, ce.create()), c = o.mapValue((l, f2, m2) => {
      const d2 = u.get(f2, m2);
      return l.isError() ? l : d2.isError() ? d2 : this._handleSingleObject(l, d2);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
  _handleSingleObject(e, t) {
    const r = Pe(e), { isError: n, errorObject: s, variants: o } = I2(t);
    if (n)
      return s;
    const [u] = o, c = Math.floor(+u.getValue());
    if (c < 0)
      return g2.create(h.VALUE);
    if (e.isNull() || c === 0)
      return U2.create("");
    let l = 0, f2 = 0, m2 = "";
    for (; f2 < c && l < r.length; )
      f2 += sn(r, l), m2 += r.charAt(l), l++;
    return U2.create(m2);
  }
};
var yR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleText(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleText(e);
  }
  _handleSingleText(e) {
    if (e.isError())
      return e;
    const t = Pe(e);
    return y2.create(t.length);
  }
};
var pR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleText(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleText(e);
  }
  _handleSingleText(e) {
    if (e.isError())
      return e;
    const t = Pe(e), r = ni(t);
    return y2.create(r);
  }
};
var NR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isNull())
      return U2.create("");
    const t = `${e.getValue()}`.toLocaleLowerCase();
    return U2.create(t);
  }
};
var VR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, t, g2.create(h.NA)), c = O(n, s, r, g2.create(h.NA)), l = o.mapValue((f2, m2, d2) => {
      const _2 = u.get(m2, d2), C = c.get(m2, d2);
      return f2.isError() ? f2 : _2.isError() ? _2 : C.isError() ? C : this._handleSingleObject(f2, _2, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const n = Pe(e), { isError: s, errorObject: o, variants: u } = I2(t, r);
    if (s)
      return o;
    const [c, l] = u, f2 = Math.floor(+c.getValue()), m2 = Math.floor(+l.getValue());
    if (f2 <= 0 || m2 < 0)
      return g2.create(h.VALUE);
    if (e.isNull() || f2 > n.length || m2 === 0)
      return U2.create("");
    const d2 = n.substring(f2 - 1, f2 - 1 + m2);
    return U2.create(d2);
  }
};
var OR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, t, g2.create(h.NA)), c = O(n, s, r, g2.create(h.NA)), l = o.mapValue((f2, m2, d2) => {
      const _2 = u.get(m2, d2), C = c.get(m2, d2);
      return f2.isError() ? f2 : _2.isError() ? _2 : C.isError() ? C : this._handleSingleObject(f2, _2, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    let n = Pe(e);
    const { isError: s, errorObject: o, variants: u } = I2(t, r);
    if (s)
      return o;
    const [c, l] = u, f2 = Math.floor(+c.getValue()), m2 = Math.floor(+l.getValue());
    if (f2 <= 0 || m2 < 0)
      return g2.create(h.VALUE);
    if (e.isNull() || f2 > n.length || m2 === 0)
      return U2.create("");
    n = n.substring(f2 - 1);
    let d2 = 0, _2 = 0, C = "";
    for (; _2 < m2 && d2 < n.length; )
      _2 += sn(n, d2), C += n.charAt(d2), d2++;
    return U2.create(C);
  }
};
var vr = ["〇", "一", "二", "三", "四", "五", "六", "七", "八", "九"];
var mn2 = ["零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"];
var SR = ["", "十", "百", "千"];
var MR = ["", "拾", "佰", "仟"];
var DR = ["", "万", "亿", "兆"];
var wR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g2.create(h.NA)), o = O(r, n, t, g2.create(h.NA)), u = s.mapValue((c, l, f2) => {
      const m2 = o.get(l, f2);
      return c.isError() ? c : m2.isError() ? m2 : this._handleSingleObject(c, m2);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  // eslint-disable-next-line
  _handleSingleObject(e, t) {
    const r = e.convertToNumberObjectValue();
    if (r.isError())
      return r;
    const n = t.convertToNumberObjectValue();
    if (n.isError())
      return n;
    let s = r.getValue();
    const o = Math.trunc(n.getValue());
    if (s < 0 || ![1, 2, 3].includes(o))
      return g2.create(h.NUM);
    s = Math.round(s);
    const u = s.toString(), c = u.length;
    let l = "", f2 = false;
    for (let m2 = 0; m2 < c; m2++) {
      const d2 = Number(u[m2]);
      if (c === 1 && d2 === 0) {
        l += o === 2 ? mn2[0] : vr[0];
        break;
      }
      if (o === 3) {
        l += vr[d2];
        continue;
      }
      const _2 = c - m2 - 1, C = _2 % 4, E = Math.trunc(_2 / 4);
      if (c >= 17 && E > 2) {
        if (l += o === 1 ? vr[d2] : mn2[d2], E > 3)
          continue;
      } else
        d2 === 0 ? f2 = C !== 0 : (f2 && (l += o === 1 ? vr[0] : mn2[0], f2 = false), l += o === 1 ? vr[d2] + SR[C] : mn2[d2] + MR[C]);
      C === 0 && E > 0 && u.slice(Math.max(0, m2 - 3), m2 + 1) !== "0000" && (l += DR[E]);
    }
    return U2.create(l);
  }
};
var LR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 3);
  }
  isArgumentsIgnoreNumberPattern() {
    return true;
  }
  calculate(e, t, r) {
    const n = t != null ? t : U2.create("."), s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      r != null && r.isArray() ? r.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      r != null && r.isArray() ? r.getColumnCount() : 1
    ), u = O(s, o, e, g2.create(h.NA)), c = O(s, o, n, g2.create(h.NA)), l = r ? O(s, o, r, g2.create(h.NA)) : void 0, f2 = u.mapValue((m2, d2, _2) => {
      const C = c.get(d2, _2), E = r ? l.get(d2, _2) : void 0;
      return m2.isError() ? m2 : C.isError() ? C : E != null && E.isError() ? E : C.isNull() || E != null && E.isNull() ? g2.create(h.VALUE) : m2.isNull() ? y2.create(0) : this._handleSingleObject(m2, C, E);
    });
    return s === 1 && o === 1 ? f2.get(0, 0) : f2;
  }
  // eslint-disable-next-line
  _handleSingleObject(e, t, r) {
    let n = `${e.getValue()}`;
    n = n.replace(/\s+/g, "");
    let s = `${t.getValue()}`;
    t.isBoolean() && (s = s.toLocaleUpperCase()), s = s.charAt(0);
    let o;
    if (r && (o = `${r.getValue()}`, r.isBoolean() && (o = o.toLocaleUpperCase()), o = o.charAt(0), s === o))
      return g2.create(h.VALUE);
    if (n.trim() === "")
      return y2.create(0);
    if (!n.match(/^\s*[+-]?\s*(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:[eE][+-]?\d+)?[ \t]*/))
      return g2.create(h.VALUE);
    const u = n.split(s);
    if (u.length > 2)
      return g2.create(h.VALUE);
    let c = u[0].replace(/,/g, "");
    r && (c = c.split(o).join(""));
    let l = 0;
    if (u.length === 1) {
      s === "," && (c = c.replace(/\./g, ""));
      let f2 = 0;
      for (; c.endsWith("%"); )
        c = c.slice(0, -1), f2++;
      f2 > 0 ? l = +c / __pow(100, f2) : l = +c;
    } else {
      if (!s1(c))
        return g2.create(h.VALUE);
      let f2 = u[1], m2 = 0;
      for (; f2.endsWith("%"); )
        f2 = f2.slice(0, -1), m2++;
      const d2 = `${c}.${f2}`;
      if (!s1(d2))
        return g2.create(h.VALUE);
      m2 > 0 ? l = +d2 / __pow(100, m2) : l = +d2;
    }
    return Number.isNaN(l) ? g2.create(h.VALUE) : y2.create(l);
  }
};
var PR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError() || e.isNull() || e.isBoolean() || e.isNumber())
      return e;
    const r = e.getValue().toLocaleString().toLocaleLowerCase().replace(/(^|\b|\W|\d|_)[a-z]/g, (n) => n.toLocaleUpperCase());
    return U2.create(r);
  }
};
var hc = () => [
  {
    type: 4,
    from: 48,
    to: 57
  }
];
var gc = () => [
  {
    type: 7,
    value: 95
  },
  {
    type: 4,
    from: 97,
    to: 122
  },
  {
    type: 4,
    from: 65,
    to: 90
  },
  {
    type: 4,
    from: 48,
    to: 57
  }
];
var dc = () => [
  {
    type: 7,
    value: 9
  },
  {
    type: 7,
    value: 10
  },
  {
    type: 7,
    value: 11
  },
  {
    type: 7,
    value: 12
  },
  {
    type: 7,
    value: 13
  },
  {
    type: 7,
    value: 32
  },
  {
    type: 7,
    value: 160
  },
  {
    type: 7,
    value: 5760
  },
  {
    type: 4,
    from: 8192,
    to: 8202
  },
  {
    type: 7,
    value: 8232
  },
  {
    type: 7,
    value: 8233
  },
  {
    type: 7,
    value: 8239
  },
  {
    type: 7,
    value: 8287
  },
  {
    type: 7,
    value: 12288
  },
  {
    type: 7,
    value: 65279
  }
];
var Cc = () => ({
  type: 3,
  set: gc(),
  not: false
});
var _c = () => ({
  type: 3,
  set: gc(),
  not: true
});
var Ac = () => ({
  type: 3,
  set: hc(),
  not: false
});
var Ec = () => ({
  type: 3,
  set: hc(),
  not: true
});
var Rc = () => ({
  type: 3,
  set: dc(),
  not: false
});
var bc = () => ({
  type: 3,
  set: dc(),
  not: true
});
var xR = () => ({
  type: 3,
  set: [
    {
      type: 7,
      value: 10
    },
    {
      type: 7,
      value: 13
    },
    {
      type: 7,
      value: 8232
    },
    {
      type: 7,
      value: 8233
    }
  ],
  not: true
});
function jR(a2) {
  const i = {
    type: 0,
    stack: []
  };
  let e = i, t = i.stack;
  const r = [], n = [];
  let s = 0;
  const o = (f2) => {
    throw new SyntaxError(`Invalid regular expression: /${a2}/: Nothing to repeat at column ${f2 - 1}`);
  }, u = vR(a2);
  let c = 0, l;
  for (; c < u.length; )
    switch (l = u[c++], l) {
      case "\\":
        if (c === u.length)
          throw new SyntaxError(`Invalid regular expression: /${a2}/: \\ at end of pattern`);
        switch (l = u[c++], l) {
          case "b":
            t.push({
              type: 2,
              value: "b"
            });
            break;
          case "B":
            t.push({
              type: 2,
              value: "B"
            });
            break;
          case "w":
            t.push(Cc());
            break;
          case "W":
            t.push(_c());
            break;
          case "d":
            t.push(Ac());
            break;
          case "D":
            t.push(Ec());
            break;
          case "s":
            t.push(Rc());
            break;
          case "S":
            t.push(bc());
            break;
          default:
            if (/\d/.test(l)) {
              for (; /\d/.test(u[c]) && c < u.length; )
                l += u[c++];
              const f2 = Number.parseInt(l, 10);
              t.push({
                type: 6,
                value: f2
              }), n.push({
                reference: {
                  type: 6,
                  value: f2
                },
                stack: t,
                index: t.length - 1
              });
            } else
              t.push({
                type: 7,
                value: l.charCodeAt(0)
              });
        }
        break;
      case "^":
        t.push({
          type: 2,
          value: "^"
        });
        break;
      case "$":
        t.push({
          type: 2,
          value: "$"
        });
        break;
      case "[": {
        const f2 = u[c] === "^";
        f2 && c++;
        const m2 = UR(u.slice(c), a2);
        c += m2[1], t.push({
          type: 3,
          set: m2[0],
          not: f2
        });
        break;
      }
      case ".":
        t.push(xR());
        break;
      case "(": {
        const f2 = {
          type: 1,
          stack: [],
          remember: true
          // 默认情况下，捕获组是需要记住（捕获）的
        };
        if (u[c] === "?") {
          const m2 = u[c + 1];
          if (c += 2, m2 === "=")
            f2.followedBy = true;
          else if (m2 === "!")
            f2.notFollowedBy = true;
          else if (m2 !== ":")
            throw new SyntaxError(`Invalid regular expression: /${a2}/: Invalid group, character '${m2}' after '?' at column ${c - 1}`);
          f2.remember = false;
        } else
          s += 1;
        t.push(f2), r.push(e), e = f2, t = f2.stack;
        break;
      }
      case ")":
        if (r.length === 0)
          throw new SyntaxError(`Invalid regular expression: /${a2}/: Unmatched ) at column ${c - 1}`);
        e = r.pop(), t = e.options ? e.options[e.options.length - 1] : e.stack;
        break;
      case "|": {
        e.options || (e.options = [e.stack], delete e.stack);
        const f2 = [];
        e.options.push(f2), t = f2;
        break;
      }
      case "{": {
        const f2 = /^(\d+)(,(\d+)?)?\}/.exec(u.slice(c));
        if (f2) {
          t.length === 0 && o(c);
          const m2 = Number.parseInt(f2[1], 10), d2 = f2[2] ? f2[3] ? Number.parseInt(f2[3], 10) : 1 / 0 : m2;
          c += f2[0].length, t.push({
            type: 5,
            min: m2,
            max: d2,
            value: t.pop()
          });
        } else
          t.push({
            // Assuming 123 is the character code for '{'
            type: 7,
            value: 123
          });
        break;
      }
      case "?":
        t.length === 0 && o(c), t.push({
          type: 5,
          min: 0,
          max: 1,
          value: t.pop()
        });
        break;
      case "+":
        t.length === 0 && o(c), t.push({
          type: 5,
          min: 1,
          max: 1 / 0,
          value: t.pop()
        });
        break;
      case "*":
        t.length === 0 && o(c), t.push({
          type: 5,
          min: 0,
          max: 1 / 0,
          value: t.pop()
        });
        break;
      default:
        t.push({
          type: 7,
          value: l.charCodeAt(0)
        });
    }
  if (r.length > 0)
    throw new SyntaxError(`Invalid regular expression: /${a2}/: Unterminated group`);
  return TR(n, s), i;
}
function UR(a2, i) {
  let e;
  const t = [], r = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(((?:\\)])|(((?:\\)?([^\]])))))|(\])|(?:\\)?([^])/g;
  for (; (e = r.exec(a2)) !== null; ) {
    let n = null;
    const [, s, o, u, c, l, f2, m2, d2, _2, C] = e;
    if (s || o || u || c || l || f2 ? n = (() => {
      let E = {
        type: 3,
        set: [],
        not: false
      };
      return s ? E = Cc() : o ? E = Ac() : u ? E = Rc() : c ? E = _c() : l ? E = Ec() : f2 && (E = bc()), E;
    })() : m2 && C ? n = {
      type: 4,
      from: (d2 || _2).charCodeAt(0),
      to: C.charCodeAt(C.length - 1)
    } : e[16] && (n = {
      type: 7,
      value: e[16].charCodeAt(0)
    }), !n)
      return [t, r.lastIndex];
    t.push(n);
  }
  throw new SyntaxError(`Invalid regular expression: /${i}/: Unterminated character class`);
}
function vR(a2) {
  return a2.replace(
    /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g,
    (i, e, t, r, n, s, o) => {
      if (t)
        return i;
      let u;
      e ? u = 8 : r ? u = Number.parseInt(r, 16) : n ? u = Number.parseInt(n, 16) : s ? u = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?".indexOf(s) : u = {
        0: 0,
        t: 9,
        n: 10,
        v: 11,
        f: 12,
        r: 13
      }[o];
      const c = String.fromCharCode(u);
      return /[[\]{}^$.|?*+()]/.test(c) ? `\\${c}` : c;
    }
  );
}
function TR(a2, i) {
  for (const e of a2.reverse()) {
    const t = e.reference.value;
    if (i < t) {
      e.reference.type = 7;
      const r = t.toString();
      if (e.reference.value = Number.parseInt(r, 8), !/^[0-7]+$/.test(r)) {
        let n = 0;
        for (; r[n] !== "8" && r[n] !== "9" && n < r.length; )
          n += 1;
        if (n === 0 ? (e.reference.value = r.charCodeAt(0), n += 1) : e.reference.value = Number.parseInt(r.slice(0, n), 8), r.length > n) {
          const s = e.stack.splice(e.index + 1);
          for (const o of r.slice(n))
            e.stack.push({
              type: 7,
              value: o.charCodeAt(0)
            });
          e.stack.push(...s);
        }
      }
    }
  }
}
function si(a2, i) {
  if (!IR(a2))
    return {
      isError: true,
      regExp: null
    };
  try {
    const e = new RegExp(a2, i ? "ug" : "u");
    return BR(e) ? {
      isError: false,
      regExp: e
    } : {
      isError: true,
      regExp: null
    };
  } catch (e) {
    return {
      isError: true,
      regExp: null
    };
  }
}
function IR(a2) {
  return !(/\(\?<=.*?\)/g.test(a2) && !/\[.*?(\?<=.*?)\]/g.test(a2) || /\(\?<!.*?\)/g.test(a2) && !/\[.*?(\?<!.*?)\]/g.test(a2));
}
function BR(a2, i) {
  let t;
  Object.prototype.toString.call(a2) === "[object RegExp]" ? t = a2.source : a2 && typeof a2 != "string" && (t = `${a2}`);
  let r;
  try {
    r = jR(t);
  } catch (e) {
    return false;
  }
  let n = 0;
  const s = (o, u) => {
    let c = u;
    if (o.type === 5 && (c++, n++, c > 1 || n > 25))
      return false;
    if (o.options) {
      for (const f2 of o.options)
        if (!s({ stack: f2 }, c))
          return false;
    }
    const l = o.stack || o.value && o.value.stack;
    if (!l)
      return true;
    for (const f2 of l)
      if (!s(f2, c))
        return false;
    return true;
  };
  return s(r, 0);
}
var FR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = zr(e, t);
    if (r)
      return n;
    const [o, u] = s;
    let c = o.getValue();
    o.isNull() && (c = ""), o.isBoolean() && (c = c ? "TRUE" : "FALSE"), c = `${c}`;
    let l = u.getValue();
    u.isNull() && (l = ""), u.isBoolean() && (l = l ? "TRUE" : "FALSE"), l = `${l}`;
    const { isError: f2, regExp: m2 } = si(l, false);
    if (f2)
      return g2.create(h.REF);
    const d2 = c.match(m2);
    if (d2 === null)
      return g2.create(h.NA);
    if (d2.length > 1) {
      const _2 = d2.slice(1).map((C) => U2.create(C));
      return _2.length > 1 ? K2.create({
        calculateValueList: [_2],
        rowCount: 1,
        columnCount: _2.length,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      }) : _2[0];
    }
    return U2.create(d2[0]);
  }
};
var kR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = zr(e, t);
    if (r)
      return n;
    const [o, u] = s;
    let c = o.getValue();
    o.isNull() && (c = ""), o.isBoolean() && (c = c ? "TRUE" : "FALSE"), c = `${c}`;
    let l = u.getValue();
    u.isNull() && (l = ""), u.isBoolean() && (l = l ? "TRUE" : "FALSE"), l = `${l}`;
    const { isError: f2, regExp: m2 } = si(l, false);
    return f2 ? g2.create(h.REF) : c.match(m2) === null ? T.create(false) : T.create(true);
  }
};
var $R = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = zr(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o;
    let f2 = u.getValue();
    u.isNull() && (f2 = ""), u.isBoolean() && (f2 = f2 ? "TRUE" : "FALSE"), f2 = `${f2}`;
    let m2 = c.getValue();
    c.isNull() && (m2 = ""), c.isBoolean() && (m2 = m2 ? "TRUE" : "FALSE"), m2 = `${m2}`;
    let d2 = l.getValue();
    l.isNull() && (d2 = ""), l.isBoolean() && (d2 = d2 ? "TRUE" : "FALSE"), d2 = `${d2}`;
    const { isError: _2, regExp: C } = si(m2, true);
    if (_2)
      return g2.create(h.REF);
    const E = f2.replace(C, d2);
    return U2.create(E);
  }
};
var YR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g2.create(h.NA)), c = O(s, o, t, g2.create(h.NA)), l = O(s, o, r, g2.create(h.NA)), f2 = O(s, o, n, g2.create(h.NA)), m2 = u.mapValue((d2, _2, C) => {
      const E = c.get(_2, C), R = l.get(_2, C), b = f2.get(_2, C);
      return d2.isError() ? d2 : E.isError() ? E : R.isError() ? R : b.isError() ? b : this._handleSingleObject(d2, E, R, b);
    });
    return s === 1 && o === 1 ? m2.get(0, 0) : m2;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = I2(t, r);
    if (s)
      return o;
    const [c, l] = u, f2 = Math.floor(+c.getValue()), m2 = Math.floor(+l.getValue());
    if (f2 <= 0 || m2 < 0)
      return g2.create(h.VALUE);
    const d2 = Pe(e), _2 = Pe(n), C = d2.substring(0, f2 - 1) + _2 + d2.substring(f2 - 1 + m2);
    return U2.create(C);
  }
};
var HR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g2.create(h.NA)), c = O(s, o, t, g2.create(h.NA)), l = O(s, o, r, g2.create(h.NA)), f2 = O(s, o, n, g2.create(h.NA)), m2 = u.mapValue((d2, _2, C) => {
      const E = c.get(_2, C), R = l.get(_2, C), b = f2.get(_2, C);
      return d2.isError() ? d2 : E.isError() ? E : R.isError() ? R : b.isError() ? b : this._handleSingleObject(d2, E, R, b);
    });
    return s === 1 && o === 1 ? m2.get(0, 0) : m2;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = I2(t, r);
    if (s)
      return o;
    const [c, l] = u, f2 = Math.floor(+c.getValue()), m2 = Math.floor(+l.getValue());
    if (f2 <= 0 || m2 < 0)
      return g2.create(h.VALUE);
    let d2 = Pe(e);
    const _2 = Pe(n);
    let C = d2.substring(0, f2 - 1);
    d2 = d2.substring(f2 - 1);
    let E = 0, R = 0;
    for (; R < m2 && E < d2.length; )
      R += sn(d2, E), E++;
    return C += _2 + d2.substring(E), U2.create(C);
  }
};
var GR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g2.create(h.NA)), o = O(r, n, t, g2.create(h.NA)), u = s.map((c, l, f2) => {
      let m2 = o.get(l, f2);
      if (c.isError())
        return c;
      let d2 = c.getValue();
      if (c.isNull() && (d2 = ""), c.isBoolean() && (d2 = d2 ? "TRUE" : "FALSE"), d2 += "", m2.isString() && (m2 = m2.convertToNumberObjectValue()), m2.isError())
        return m2;
      const _2 = 32767, C = Math.floor(+m2.getValue());
      if (C < 0 || C > _2 / d2.length)
        return g2.create(h.VALUE);
      const E = d2.repeat(C);
      return U2.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
};
var WR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y2.create(1), n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, r, g2.create(h.NA)), c = o.mapValue((l, f2, m2) => {
      const d2 = u.get(f2, m2);
      return l.isError() ? l : d2.isError() ? d2 : this._handleSingleObject(l, d2);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
  _handleSingleObject(e, t) {
    const r = Pe(e), { isError: n, errorObject: s, variants: o } = I2(t);
    if (n)
      return s;
    const [u] = o, c = Math.floor(+u.getValue());
    if (c < 0)
      return g2.create(h.VALUE);
    if (e.isNull() || c === 0)
      return U2.create("");
    if (c >= r.length)
      return U2.create(r);
    const l = r.substring(r.length - c);
    return U2.create(l);
  }
};
var QR2 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y2.create(1), n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, r, g2.create(h.NA)), c = o.mapValue((l, f2, m2) => {
      const d2 = u.get(f2, m2);
      return l.isError() ? l : d2.isError() ? d2 : this._handleSingleObject(l, d2);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
  _handleSingleObject(e, t) {
    const r = Pe(e), { isError: n, errorObject: s, variants: o } = I2(t);
    if (n)
      return s;
    const [u] = o, c = Math.floor(+u.getValue());
    if (c < 0)
      return g2.create(h.VALUE);
    if (e.isNull() || c === 0)
      return U2.create("");
    let l = r.length - 1, f2 = 0, m2 = "";
    for (; f2 < c && l >= 0; )
      f2 += sn(r, l, "rtl"), m2 = r.charAt(l) + m2, l--;
    return U2.create(m2);
  }
};
var qR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : y2.create(1), s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g2.create(h.NA)), c = O(s, o, t, g2.create(h.NA)), l = O(s, o, n, g2.create(h.NA)), f2 = u.mapValue((m2, d2, _2) => {
      const C = c.get(d2, _2), E = l.get(d2, _2);
      return m2.isError() ? m2 : C.isError() ? C : E.isError() ? E : this._handleSingleObject(m2, C, E);
    });
    return s === 1 && o === 1 ? f2.get(0, 0) : f2;
  }
  _handleSingleObject(e, t, r) {
    const n = Pe(e).toLocaleUpperCase(), s = Pe(t).toLocaleUpperCase(), { isError: o, errorObject: u, variants: c } = I2(r);
    if (o)
      return u;
    const [l] = c, f2 = Math.floor(+l.getValue());
    if (t.isNull() || f2 <= 0 || f2 > s.length)
      return g2.create(h.VALUE);
    if (e.isNull() || n.length === 0)
      return y2.create(f2);
    const m2 = s.indexOf(n, f2 - 1);
    return m2 === -1 ? g2.create(h.VALUE) : y2.create(m2 + 1);
  }
};
var XR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : y2.create(1), s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g2.create(h.NA)), c = O(s, o, t, g2.create(h.NA)), l = O(s, o, n, g2.create(h.NA)), f2 = u.mapValue((m2, d2, _2) => {
      const C = c.get(d2, _2), E = l.get(d2, _2);
      return m2.isError() ? m2 : C.isError() ? C : E.isError() ? E : this._handleSingleObject(m2, C, E);
    });
    return s === 1 && o === 1 ? f2.get(0, 0) : f2;
  }
  _handleSingleObject(e, t, r) {
    const n = Pe(e).toLocaleUpperCase(), s = Pe(t).toLocaleUpperCase(), { isError: o, errorObject: u, variants: c } = I2(r);
    if (o)
      return u;
    const [l] = c, f2 = Math.floor(+l.getValue());
    if (t.isNull() || f2 <= 0 || f2 > s.length)
      return g2.create(h.VALUE);
    if (e.isNull() || n.length === 0)
      return y2.create(f2);
    const m2 = s.indexOf(n, f2 - 1);
    if (m2 === -1)
      return g2.create(h.VALUE);
    const d2 = ni(s.substring(0, m2)) + 1;
    return y2.create(d2);
  }
};
var KR2 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n != null && n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n != null && n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g2.create(h.NA)), c = O(s, o, t, g2.create(h.NA)), l = O(s, o, r, g2.create(h.NA)), f2 = n ? O(s, o, n, g2.create(h.NA)) : void 0, m2 = u.mapValue((d2, _2, C) => {
      const E = c.get(_2, C), R = l.get(_2, C);
      let b = n ? f2.get(_2, C) : void 0;
      return d2.isError() ? d2 : E.isError() ? E : R.isError() ? R : b != null && b.isError() ? b : b != null && b.isNull() || b != null && b.isBoolean() ? g2.create(h.VALUE) : (b != null && b.isString() && (b = b.convertToNumberObjectValue()), b != null && b.isError() ? b : this._handleSingleObject(d2, E, R, b));
    });
    return s === 1 && o === 1 ? m2.get(0, 0) : m2;
  }
  _handleSingleObject(e, t, r, n) {
    const s = this._getObjectString(e), o = this._getObjectString(t), u = this._getObjectString(r), c = n ? Math.floor(+n.getValue()) : void 0;
    if (n && c <= 0)
      return g2.create(h.VALUE);
    if (o === "")
      return U2.create(s);
    let l = "", f2 = 0;
    for (let m2 = 0; m2 < s.length; m2++) {
      const d2 = s.substr(m2, o.length);
      if (d2 === o || d2.length === o.length && d2.trim() === o.trim()) {
        if (f2++, f2 === c) {
          l = s.substr(0, m2) + u + s.substr(m2 + o.length);
          break;
        }
        c === void 0 && (l += u), m2 += o.length - 1;
      } else
        c === void 0 && (l += s[m2]);
    }
    return c && f2 < c && (l = s), U2.create(l);
  }
  _getObjectString(e) {
    let t = `${e.getValue()}`;
    return e.isNull() && (t = ""), e.isBoolean() && (t = t.toLocaleUpperCase()), t;
  }
};
var ZR2 = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
    A(this, "needsReferenceObject", true);
  }
  calculate(e) {
    let t = e;
    return e.isReferenceObject() && (t = e.toArrayValueObject().get(0, 0)), t.isArray() ? t.mapValue((r) => this._handleSingleObject(r)) : this._handleSingleObject(t);
  }
  _handleSingleObject(e) {
    return e.isError() ? e : e.isNull() || e.isBoolean() || e.isNumber() ? U2.create("") : e;
  }
};
var zR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  isArgumentsIgnoreNumberPattern() {
    return true;
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e), o = O(r, n, t), u = s.map((c, l, f2) => {
      if (c.isError())
        return c;
      let m2 = o.get(l, f2) || U2.create(" ");
      if (m2.isError())
        return m2;
      if (m2.isBoolean())
        return g2.create(h.VALUE);
      if (c.isBoolean())
        return c;
      let d2 = c.getValue();
      if (c.isNull() && (d2 = 0), c.isString())
        if (s1(d2))
          d2 = Number(d2);
        else {
          const E = h1(`${d2}`);
          E && E.v != null && typeof E.v == "number" && (d2 = E.v);
        }
      m2.isNull() && (m2 = U2.create(" "));
      const _2 = `${m2.getValue()}`, C = ri(_2, d2);
      return U2.create(_2 === " " ? C.trimEnd() : C);
    });
    return u.getRowCount() === 1 && u.getColumnCount() === 1 ? u.get(0, 0) : u;
  }
};
var JR = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    let u = false, c = r != null ? r : y2.create(1);
    c.isNull() && (u = true, c = y2.create(1));
    const l = !n, f2 = n != null ? n : y2.create(0), m2 = s != null ? s : y2.create(0), d2 = o != null ? o : g2.create(h.NA), _2 = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1,
      f2.isArray() ? f2.getRowCount() : 1,
      m2.isArray() ? m2.getRowCount() : 1,
      d2.isArray() ? d2.getRowCount() : 1
    ), C = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1,
      f2.isArray() ? f2.getColumnCount() : 1,
      m2.isArray() ? m2.getColumnCount() : 1,
      d2.isArray() ? d2.getColumnCount() : 1
    ), E = O(_2, C, e, g2.create(h.NA)), R = O(_2, C, c, g2.create(h.NA)), b = O(_2, C, f2, g2.create(h.NA)), p2 = O(_2, C, m2, g2.create(h.NA)), V = O(_2, C, d2, g2.create(h.NA)), S2 = this._getResultArray(E, t, R, b, p2, V, u, l);
    return _2 === 1 && C === 1 ? S2.get(0, 0) : S2;
  }
  _getResultArray(e, t, r, n, s, o, u, c) {
    return e.map((f2, m2, d2) => {
      const _2 = r.get(m2, d2), C = n.get(m2, d2), E = s.get(m2, d2), R = o.get(m2, d2), b = this._checkVariantsError(f2, _2, C, E);
      if (b.isError())
        return b;
      const p2 = this._getStringValue(f2), V = this._getDelimiterValue(t);
      if (V instanceof g2)
        return V;
      const S2 = this._getVariantsNumberFloorValue(_2, C, E);
      if (S2 instanceof g2)
        return S2;
      const [M2, D2, w] = S2;
      return M2 === 0 || D2 < 0 || D2 > 1 || w < 0 || w > 1 ? g2.create(h.VALUE) : V.includes("") ? M2 > 0 ? U2.create(p2) : U2.create("") : !u && Math.abs(M2) > p2.length ? g2.create(h.VALUE) : V.every((L) => L.length > p2.length) ? g2.create(h.NA) : this._getResult(p2, V, M2, D2, w, R, c);
    });
  }
  _checkVariantsError(...e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      if (r.isError())
        return r;
    }
    return T.create(true);
  }
  _getStringValue(e) {
    let t = `${e.getValue()}`;
    return e.isNull() && (t = ""), e.isBoolean() && (t = t.toLocaleUpperCase()), t;
  }
  _getDelimiterValue(e) {
    const t = [];
    if (e.isArray()) {
      let r = false, n = g2.create(h.VALUE);
      if (e.iterator((s) => {
        const o = s;
        if (o.isError())
          return r = true, n = o, false;
        t.push(this._getStringValue(o));
      }), r)
        return n;
    } else {
      if (e.isError())
        return e;
      t.push(this._getStringValue(e));
    }
    return t;
  }
  _getVariantsNumberFloorValue(...e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (n.isString() && (n = n.convertToNumberObjectValue()), n.isError())
        return n;
      const s = Math.floor(+n.getValue());
      t.push(s);
    }
    return t;
  }
  _getResult(e, t, r, n, s, o, u) {
    let c = n ? e.toLocaleLowerCase() : e;
    const l = n ? t.map((C) => C.toLocaleLowerCase()) : t;
    let f2 = 0, m2 = 0, d2 = 0;
    for (let C = 0; C < Math.abs(r); C++)
      if (r < 0) {
        const E = l.map((R) => ({
          index: c.lastIndexOf(R),
          length: R.length
        })).filter((R) => R.index !== -1).sort((R, b) => b.index - R.index)[0];
        if (!E)
          break;
        f2 = E.index, c = c.substr(0, E.index), d2 = E.length, m2++;
      } else {
        const E = l.map((R) => ({
          index: c.indexOf(R),
          length: R.length
        })).filter((R) => R.index !== -1).sort((R, b) => R.index - b.index)[0];
        if (!E)
          break;
        f2 += E.index + d2, c = c.substr(E.index + E.length), d2 = E.length, m2++;
      }
    if (m2 && m2 < Math.abs(r) && u)
      return g2.create(h.NA);
    if (!m2 || m2 < Math.abs(r))
      return s ? r > 0 ? U2.create("") : U2.create(e) : o;
    const _2 = e.substr(f2 + d2);
    return U2.create(_2);
  }
};
var eb = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    let u = false, c = r != null ? r : y2.create(1);
    c.isNull() && (u = true, c = y2.create(1));
    const l = !n, f2 = n != null ? n : y2.create(0), m2 = s != null ? s : y2.create(0), d2 = o != null ? o : g2.create(h.NA), _2 = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1,
      f2.isArray() ? f2.getRowCount() : 1,
      m2.isArray() ? m2.getRowCount() : 1,
      d2.isArray() ? d2.getRowCount() : 1
    ), C = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1,
      f2.isArray() ? f2.getColumnCount() : 1,
      m2.isArray() ? m2.getColumnCount() : 1,
      d2.isArray() ? d2.getColumnCount() : 1
    ), E = O(_2, C, e, g2.create(h.NA)), R = O(_2, C, c, g2.create(h.NA)), b = O(_2, C, f2, g2.create(h.NA)), p2 = O(_2, C, m2, g2.create(h.NA)), V = O(_2, C, d2, g2.create(h.NA)), S2 = this._getResultArray(E, t, R, b, p2, V, u, l);
    return _2 === 1 && C === 1 ? S2.get(0, 0) : S2;
  }
  _getResultArray(e, t, r, n, s, o, u, c) {
    return e.map((f2, m2, d2) => {
      const _2 = r.get(m2, d2), C = n.get(m2, d2), E = s.get(m2, d2), R = o.get(m2, d2), b = this._checkVariantsError(f2, _2, C, E);
      if (b.isError())
        return b;
      const p2 = this._getStringValue(f2), V = this._getDelimiterValue(t);
      if (V instanceof g2)
        return V;
      const S2 = this._getVariantsNumberFloorValue(_2, C, E);
      if (S2 instanceof g2)
        return S2;
      const [M2, D2, w] = S2;
      return M2 === 0 || D2 < 0 || D2 > 1 || w < 0 || w > 1 ? g2.create(h.VALUE) : V.includes("") ? M2 > 0 ? U2.create("") : U2.create(p2) : !u && Math.abs(M2) > p2.length ? g2.create(h.VALUE) : V.every((L) => L.length > p2.length) ? g2.create(h.NA) : this._getResult(p2, V, M2, D2, w, R, c);
    });
  }
  _checkVariantsError(...e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      if (r.isError())
        return r;
    }
    return T.create(true);
  }
  _getStringValue(e) {
    let t = `${e.getValue()}`;
    return e.isNull() && (t = ""), e.isBoolean() && (t = t.toLocaleUpperCase()), t;
  }
  _getDelimiterValue(e) {
    const t = [];
    if (e.isArray()) {
      let r = false, n = g2.create(h.VALUE);
      if (e.iterator((s) => {
        const o = s;
        if (o.isError())
          return r = true, n = o, false;
        t.push(this._getStringValue(o));
      }), r)
        return n;
    } else {
      if (e.isError())
        return e;
      t.push(this._getStringValue(e));
    }
    return t;
  }
  _getVariantsNumberFloorValue(...e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (n.isString() && (n = n.convertToNumberObjectValue()), n.isError())
        return n;
      const s = Math.floor(+n.getValue());
      t.push(s);
    }
    return t;
  }
  _getResult(e, t, r, n, s, o, u) {
    let c = n ? e.toLocaleLowerCase() : e;
    const l = n ? t.map((C) => C.toLocaleLowerCase()) : t;
    let f2 = 0, m2 = 0, d2 = 0;
    for (let C = 0; C < Math.abs(r); C++)
      if (r < 0) {
        const E = l.map((R) => ({
          index: c.lastIndexOf(R),
          length: R.length
        })).filter((R) => R.index !== -1).sort((R, b) => b.index - R.index)[0];
        if (!E)
          break;
        f2 = E.index, c = c.substr(0, E.index), m2++;
      } else {
        const E = l.map((R) => ({
          index: c.indexOf(R),
          length: R.length
        })).filter((R) => R.index !== -1).sort((R, b) => R.index - b.index)[0];
        if (!E)
          break;
        f2 += E.index + d2, c = c.substr(E.index + E.length), d2 = E.length, m2++;
      }
    if (m2 && m2 < Math.abs(r) && u)
      return g2.create(h.NA);
    if (!m2 || m2 < Math.abs(r))
      return s ? r > 0 ? U2.create(e) : U2.create("") : o;
    const _2 = e.substr(0, f2);
    return U2.create(_2);
  }
};
var tb = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 255);
  }
  calculate(e, t, ...r) {
    const n = this._getDelimiterValues(e), s = this._getTextValues(r);
    if (t.isArray()) {
      const u = t.mapValue((c) => this._handleSingleObject(n, c, s));
      return u.getRowCount() === 1 && u.getColumnCount() === 1 ? u.get(0, 0) : u;
    }
    const o = t;
    if (o.isString()) {
      const u = `${o.getValue()}`.toLocaleUpperCase();
      if (u === "TRUE")
        return this._handleSingleObject(n, T.create(true), s);
      if (u === "FALSE")
        return this._handleSingleObject(n, T.create(false), s);
    }
    return this._handleSingleObject(n, t, s);
  }
  _handleSingleObject(e, t, r) {
    if (e instanceof g2)
      return e;
    const { isError: n, errorObject: s, variants: o } = I2(t);
    if (n)
      return s;
    if (r instanceof g2)
      return r;
    const [u] = o, c = +u.getValue();
    let l = r;
    c && (l = r.filter((m2) => m2 !== null && m2 !== ""));
    let f2 = "";
    for (let m2 = 0; m2 < l.length; m2++)
      l[m2] !== null && (f2 += l[m2]), m2 < l.length - 1 && (f2 += e[m2 % e.length]);
    return U2.create(f2);
  }
  _getDelimiterValues(e) {
    const t = [], r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1;
    for (let s = 0; s < r; s++)
      for (let o = 0; o < n; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        let c = `${u.getValue()}`;
        u.isNull() && (c = ""), u.isBoolean() && (c = c.toLocaleUpperCase()), t.push(c);
      }
    return t;
  }
  _getTextValues(e) {
    const t = [];
    for (const r of e) {
      const n = r.isArray() ? r.getRowCount() : 1, s = r.isArray() ? r.getColumnCount() : 1;
      for (let o = 0; o < n; o++)
        for (let u = 0; u < s; u++) {
          const c = r.isArray() ? r.get(o, u) : r;
          if (c.isError())
            return c;
          if (c.isNull()) {
            t.push(null);
            continue;
          }
          let l = `${c.getValue()}`;
          c.isBoolean() && (l = l.toLocaleUpperCase()), t.push(l);
        }
    }
    return t;
  }
};
var rb = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    let u = r != null ? r : U2.create("\\s");
    const c = n != null ? n : y2.create(0), l = s != null ? s : y2.create(0), f2 = o != null ? o : U2.create(h.NA), { _variant: m2, values: d2 } = this._getStringValues(t), { _variant: _2, values: C } = this._getStringValues(u, false);
    u = _2;
    const E = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1,
      l.isArray() ? l.getRowCount() : 1
    ), R = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1,
      l.isArray() ? l.getColumnCount() : 1
    ), b = O(E, R, e, g2.create(h.NA)), p2 = O(E, R, c, g2.create(h.NA)), V = O(E, R, l, g2.create(h.NA)), S2 = this._getResultArray(
      b,
      m2,
      u,
      p2,
      V,
      f2,
      d2,
      C
    );
    return E === 1 && R === 1 ? S2.get(0, 0) : S2.map((M2) => M2.get(0, 0));
  }
  _getStringValues(e, t = true) {
    let r = e;
    const n = [];
    if (r.isArray())
      r.iterator((s) => {
        if (s != null && s.isError())
          return r = s, false;
        if (s != null && s.isNull() && t)
          return r = g2.create(h.VALUE), false;
        const o = this._getRegExpStringValue(s);
        if (o === "")
          return r = g2.create(h.VALUE), false;
        n.push(o);
      });
    else {
      r.isNull() && t && (r = g2.create(h.VALUE));
      const s = this._getRegExpStringValue(r);
      s === "" && (r = g2.create(h.VALUE)), n.push(s);
    }
    return {
      _variant: r,
      values: n
    };
  }
  _getResultArray(e, t, r, n, s, o, u, c) {
    return e.map((f2, m2, d2) => {
      let _2 = n.get(m2, d2), C = s.get(m2, d2);
      const E = this._checkVariantsError(f2, t, r, _2, C);
      if (E.isError())
        return E;
      if (f2.isNull())
        return g2.create(h.VALUE);
      let R = o;
      if (R.isArray()) {
        const M2 = R.getRowCount(), D2 = R.getColumnCount();
        if (M2 > 1 || D2 > 1)
          return g2.create(h.VALUE);
        R = R.get(0, 0);
      }
      let b = `${f2.getValue()}`;
      if (f2.isBoolean() && (b = b.toLocaleUpperCase()), _2.isString() && (_2 = _2.convertToNumberObjectValue(), _2.isError()))
        return _2;
      const p2 = Math.floor(+_2.getValue());
      if (C.isString() && (C = C.convertToNumberObjectValue(), C.isError()))
        return C;
      const V = Math.floor(+C.getValue());
      if (V < 0 || V > 1)
        return g2.create(h.VALUE);
      let S2 = `${R.getValue()}`;
      return R.isBoolean() && (S2 = S2.toLocaleUpperCase()), this._getResult(b, u, c, p2, V, S2);
    });
  }
  _getResult(e, t, r, n, s, o) {
    const u = new RegExp(r.join("|"), `g${s ? "i" : ""}`), c = new RegExp(t.join("|"), `g${s ? "i" : ""}`), l = e.split(u);
    let f2 = 1, m2 = l.map((d2) => {
      let _2 = d2.split(c);
      return n && (_2 = _2.filter((C) => C !== "")), f2 = Math.max(f2, _2.length), _2;
    });
    return m2 = m2.map((d2) => {
      let _2 = d2;
      return _2.length < f2 && (_2 = _2.concat(new Array(f2 - _2.length).fill(o))), _2;
    }), K2.createByArray(m2);
  }
  _checkVariantsError(...e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      if (r.isError())
        return r;
    }
    return T.create(true);
  }
  _getRegExpStringValue(e) {
    let t = e.getValue();
    return e.isNull() && (t = "\\s"), e.isBoolean() && (t = t ? "TRUE" : "FALSE"), t += "", this._escapeRegExp(t);
  }
  _escapeRegExp(e) {
    return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
};
var nb = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isNull())
      return U2.create("");
    let t = `${e.getValue()}`;
    return e.isBoolean() && (t = t.toLocaleUpperCase()), t = t.trim().replace(/\s+/g, " "), U2.create(t);
  }
};
var sb = Object.values(ct).filter((a2) => [
  ct.TABLE_START,
  ct.TABLE_ROW_START,
  ct.TABLE_CELL_START,
  ct.TABLE_CELL_END,
  ct.TABLE_ROW_END,
  ct.TABLE_END,
  ct.CUSTOM_BLOCK
].includes(a2));
var ab = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = I2(e);
    if (t)
      return r;
    const [s] = n, o = Math.floor(+s.getValue());
    if (o < 1 || o > 1114111)
      return g2.create(h.VALUE);
    if (o === 1114111 || o === 1114110)
      return g2.create(h.NA);
    let u = String.fromCharCode(o);
    return sb.some((c) => c === u) && (u = ""), U2.create(u);
  }
};
var ib = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isNull())
      return g2.create(h.VALUE);
    let t = e.getValue().toLocaleString();
    e.isBoolean() && (t = t.toLocaleUpperCase());
    const r = t.charCodeAt(0);
    return y2.create(r);
  }
};
var ob = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isNull())
      return U2.create("");
    const t = `${e.getValue()}`.toLocaleUpperCase();
    return U2.create(t);
  }
};
var ub = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isBoolean())
      return g2.create(h.VALUE);
    let t = e;
    if (e.isString() && (t = t.convertToNumberObjectValue(), t.isError()))
      return t;
    const r = +t.getValue();
    return y2.create(r);
  }
};
var cb = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y2.create(0), n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g2.create(h.NA)), u = O(n, s, r, g2.create(h.NA)), c = o.mapValue((l, f2, m2) => {
      const d2 = u.get(f2, m2);
      return l.isError() ? l : d2.isError() ? d2 : this._handleSingleObject(l, d2);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = I2(t);
    if (r)
      return n;
    const [o] = s, u = Math.floor(+o.getValue());
    if (u < 0 || u > 1)
      return g2.create(h.VALUE);
    if (e.isNull())
      return U2.create("");
    if (e.isBoolean())
      return e;
    if (e.isNumber())
      return y2.create(e.getValue());
    const c = u ? `"${e.getValue()}"` : `${e.getValue()}`;
    return U2.create(c);
  }
};
var lb = [
  [aR, J2.ASC],
  [sR, J2.ARRAYTOTEXT],
  [iR, J2.BAHTTEXT],
  [uR, J2.CHAR],
  [cR, J2.CLEAN],
  [lR, J2.CODE],
  [fR, J2.CONCAT],
  [mR, J2.CONCATENATE],
  [hR, J2.DBCS],
  [gR2, J2.DOLLAR],
  [dR, J2.EXACT],
  [CR, J2.FIND],
  [AR, J2.FINDB],
  [ER2, J2.FIXED],
  [RR, J2.LEFT],
  [bR, J2.LEFTB],
  [yR, J2.LEN],
  [pR, J2.LENB],
  [NR, J2.LOWER],
  [VR, J2.MID],
  [OR, J2.MIDB],
  [wR, J2.NUMBERSTRING],
  [LR, J2.NUMBERVALUE],
  [FR, J2.REGEXEXTRACT],
  [kR, J2.REGEXMATCH],
  [$R, J2.REGEXREPLACE],
  [PR, J2.PROPER],
  [YR, J2.REPLACE],
  [HR, J2.REPLACEB],
  [GR, J2.REPT],
  [WR, J2.RIGHT],
  [QR2, J2.RIGHTB],
  [qR, J2.SEARCH],
  [XR, J2.SEARCHB],
  [KR2, J2.SUBSTITUTE],
  [ZR2, J2.T],
  [zR, J2.TEXT],
  [JR, J2.TEXTAFTER],
  [eb, J2.TEXTBEFORE],
  [tb, J2.TEXTJOIN],
  [rb, J2.TEXTSPLIT],
  [nb, J2.TRIM],
  [ab, J2.UNICHAR],
  [ib, J2.UNICODE],
  [ob, J2.UPPER],
  [ub, J2.VALUE],
  [cb, J2.VALUETOTEXT]
];
var fb = [];
var mb = /* @__PURE__ */ ((a2) => a2)(mb || {});
function no(a2) {
  return a2.map((i) => i.map((e) => typeof e == "number" ? Sa(e) : e));
}
function Qb(a2, i = false) {
  if (a2.isReferenceObject()) {
    const e = a2.toArrayValueObject().toValue();
    return i ? no(e) : e;
  } else if (a2.isArray()) {
    const e = a2.toValue();
    return i ? no(e) : e;
  } else if (a2.isNumber()) {
    const e = a2.getValue();
    return i ? Sa(e) : e;
  }
  return a2.getValue();
}
var hb = class extends N2 {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    const t = Pe(e), r = encodeURIComponent(t).replace(/[!~'()*]/g, (n) => `%${n.charCodeAt(0).toString(16).toLocaleUpperCase()}`);
    return U2.create(r);
  }
};
var gb = [
  [hb, ti.ENCODEURL]
];
var yc = class extends Ve {
  constructor() {
    super(...arguments);
    A(this, "_allSubjects", []);
    A(this, "_computingStatus$", new BehaviorSubject(true));
    A(this, "computingStatus$", this._computingStatus$.pipe(distinctUntilChanged()));
    A(this, "_computingSubscription");
  }
  get computingStatus() {
    return this._computingStatus$.getValue();
  }
  dispose() {
    var e;
    super.dispose(), (e = this._computingSubscription) == null || e.unsubscribe(), this._computingStatus$.next(true), this._computingStatus$.complete(), this._allSubjects.forEach((t) => {
      t.complete();
    });
  }
  pushComputingStatusSubject(e) {
    return this._allSubjects.push(e), this._updateComputingObservable(), {
      dispose: () => {
        const t = this._allSubjects.indexOf(e);
        t !== -1 && this._allSubjects.splice(t, 1), this._updateComputingObservable();
      }
    };
  }
  _updateComputingObservable() {
    var e;
    if ((e = this._computingSubscription) == null || e.unsubscribe(), this._allSubjects.length === 0) {
      this._computingStatus$.next(true);
      return;
    }
    this._computingSubscription = combineLatest(this._allSubjects).pipe(map((t) => t.every((r) => r))).subscribe((t) => this._computingStatus$.next(t));
  }
};
var db = Object.getOwnPropertyDescriptor;
var Cb = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? db(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var so = (a2, i) => (e, t) => i(e, t, a2);
var ha = class extends Ve {
  constructor(i, e) {
    super();
    A(this, "_computingCompleted$", new Observable((i2) => {
      this._commandService.onCommandExecuted((e2) => {
        if (e2.id !== Sn.id) return;
        const t2 = e2.params;
        if (t2.stageInfo)
          return i2.next(
            t2.stageInfo.stage === tt.IDLE || t2.stageInfo.stage === tt.CALCULATION_COMPLETED
          );
      });
    }).pipe(
      distinctUntilChanged(),
      shareReplay()
    ));
    this._commandService = i, this._globalComputingSrv = e;
    const t = new ho(), r = new BehaviorSubject(true);
    t.add(this._globalComputingSrv.pushComputingStatusSubject(r)), t.add(this._computingCompleted$.subscribe((n) => r.next(n))), t.add(() => r.complete()), this.disposeWithMe(t);
  }
};
ha = Cb([
  so(0, Ds),
  so(1, Inject(yc))
], ha);
var _b = Object.getOwnPropertyDescriptor;
var Ab = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? _b(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var hn = (a2, i) => (e, t) => i(e, t, a2);
var Qn = class extends Ve {
  constructor(a2, i, e, t) {
    super(), this._commandService = a2, this._functionService = i, this._configService = e, this._dataSyncPrimaryController = t, this._initialize();
  }
  _initialize() {
    this._registerCommands(), this._registerFunctions();
  }
  _registerCommands() {
    [
      Do,
      vs,
      wo,
      Oo,
      So,
      Sn,
      Mo,
      _a,
      Vo,
      Aa,
      Ea,
      Ra,
      ba,
      kl,
      $l,
      Lo,
      Sl
    ].forEach((a2) => {
      var i;
      this._commandService.registerCommand(a2), (i = this._dataSyncPrimaryController) == null || i.registerSyncingMutations(a2);
    });
  }
  _registerFunctions() {
    var e;
    const a2 = this._configService.getConfig(pa), i = [
      ...jh,
      ...gg,
      ...dg,
      ...wg,
      ...g1,
      ...Ad,
      ...p0,
      ...Q0,
      ...hC,
      ...ZC,
      ...SA,
      ...jA,
      ...nR,
      ...lb,
      ...fb,
      ...gb
    ].concat((e = a2 == null ? void 0 : a2.function) != null ? e : []).map((t) => {
      const r = t[0], n = t[1];
      return new r(n);
    });
    this._functionService.registerExecutors(...i);
  }
};
Qn = Ab([
  hn(0, Ds),
  hn(1, Xt),
  hn(2, xs),
  hn(3, Optional(y))
], Qn);
var Eb = Object.getOwnPropertyDescriptor;
var Rb = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Eb(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var gn = (a2, i) => (e, t) => i(e, t, a2);
var qn = class extends Ve {
  constructor(a2, i, e) {
    super(), this._commandService = a2, this._dependencyManagerService = i, this._featureCalculationManagerService = e, this._initialize();
  }
  _initialize() {
    this._commandExecutedListener(), this._featureCalculationManagerServiceListener();
  }
  _featureCalculationManagerServiceListener() {
    this.disposeWithMe(
      this._featureCalculationManagerService.onChanged$.subscribe((a2) => {
        const { unitId: i, subUnitId: e, featureIds: t } = a2;
        this._dependencyManagerService.removeFeatureFormulaDependency(i, e, t);
      })
    );
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((a2) => {
        if (a2.id === Ea.id) {
          const i = a2.params;
          if (i == null)
            return;
          const { featureIds: e, unitId: t, subUnitId: r } = i;
          this._dependencyManagerService.removeFeatureFormulaDependency(t, r, e);
        } else if (a2.id === Aa.id) {
          const i = a2.params;
          if (i == null)
            return;
          const { featureId: e, calculationParam: t } = i, { unitId: r, subUnitId: n } = t;
          this._dependencyManagerService.removeFeatureFormulaDependency(r, n, [e]);
        } else if (a2.id === ba.id) {
          const i = a2.params;
          if (i == null)
            return;
          this._dependencyManagerService.removeOtherFormulaDependency(i.unitId, i.subUnitId, i.formulaIdList);
        } else if (a2.id === Ra.id) {
          const i = a2.params;
          if (i == null)
            return;
          const e = i.formulaMap, t = [];
          Object.keys(e).forEach((r) => {
            t.push(r);
          }), this._dependencyManagerService.removeOtherFormulaDependency(i.unitId, i.subUnitId, t);
        } else if (a2.id === Do.id) {
          const i = a2.params.formulaData;
          Object.keys(i).forEach((e) => {
            const t = i[e];
            if (t !== void 0) {
              if (t === null) {
                this._dependencyManagerService.clearFormulaDependency(e);
                return;
              }
              Object.keys(t).forEach((r) => {
                const n = t[r];
                if (n !== void 0) {
                  if (n === null)
                    return this._dependencyManagerService.clearFormulaDependency(e, r), true;
                  new ht(n).forValue((s, o) => {
                    this._dependencyManagerService.removeFormulaDependency(e, r, s, o);
                  });
                }
              });
            }
          });
        } else a2.id === _a.id && this._handleSetDefinedName(a2);
      })
    );
  }
  _handleSetDefinedName(a2) {
    const i = a2.params;
    if (i == null)
      return;
    const { unitId: e, name: t } = i;
    this._dependencyManagerService.removeFormulaDependencyByDefinedName(e, t);
  }
};
qn = Rb([
  gn(0, Ds),
  gn(1, Wr),
  gn(1, cs),
  gn(2, Wr)
], qn);
var bb = Object.getOwnPropertyDescriptor;
var yb = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? bb(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var ao = (a2, i) => (e, t) => i(e, t, a2);
var Xn = class extends Ve {
  constructor(a2, i) {
    super(), this._commandService = a2, this._featureCalculationManagerService = i, this._initialize();
  }
  _initialize() {
    this._commandExecutedListener();
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((a2) => {
        if (a2.id === Aa.id) {
          const i = a2.params;
          if (i == null)
            return;
          const { featureId: e, calculationParam: t } = i, { unitId: r, subUnitId: n } = t;
          this._featureCalculationManagerService.register(r, n, e, t);
        } else if (a2.id === Ea.id) {
          const i = a2.params;
          if (i == null)
            return;
          const { featureIds: e, unitId: t, subUnitId: r } = i;
          this._featureCalculationManagerService.remove(t, r, e);
        }
      })
    );
  }
};
Xn = yb([
  ao(0, Ds),
  ao(1, Wr)
], Xn);
var pb = Object.getOwnPropertyDescriptor;
var Nb = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? pb(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var Ps = (a2, i) => (e, t) => i(e, t, a2);
var Kn = class extends Ve {
  constructor(a2, i, e) {
    super(), this._commandService = a2, this._otherFormulaManagerService = i, this._dependencyManagerService = e, this._initialize();
  }
  _initialize() {
    this._commandExecutedListener();
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((a2) => {
        if (a2.id === Ra.id) {
          const i = a2.params;
          if (i == null)
            return;
          const e = { [i.unitId]: { [i.subUnitId]: i.formulaMap } };
          this._otherFormulaManagerService.batchRegister(e);
        } else if (a2.id === ba.id) {
          const i = a2.params;
          if (i == null)
            return;
          const e = {};
          i.formulaIdList.forEach((r) => e[r] = true);
          const t = { [i.unitId]: { [i.subUnitId]: e } };
          this._otherFormulaManagerService.batchRemove(t);
        }
      })
    );
  }
};
Kn = Nb([
  Ps(0, Ds),
  Ps(1, ja),
  Ps(2, cs)
], Kn);
var Vb = Object.getOwnPropertyDescriptor;
var Ob = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Vb(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var io = (a2, i) => (e, t) => i(e, t, a2);
var Zn = class extends Ve {
  constructor(a2, i) {
    super(), this._commandService = a2, this._superTableService = i, this._initialize();
  }
  _initialize() {
    this._commandExecutedListener();
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((a2) => {
        if (a2.id === _a.id) {
          const i = a2.params;
          if (i == null)
            return;
          const { unitId: e, tableName: t, reference: r } = i;
          this._superTableService.registerTable(e, t, r);
        } else if (a2.id === Vo.id) {
          const i = a2.params;
          if (i == null)
            return;
          const { unitId: e, tableName: t } = i;
          this._superTableService.remove(e, t);
        } else if (a2.id === Lo.id) {
          const i = a2.params;
          if (i == null)
            return;
          const { tableOption: e, tableOptionType: t } = i;
          this._superTableService.registerTableOptionMap(e, t);
        }
      })
    );
  }
};
Zn = Ob([
  io(0, Ds),
  io(1, Pr)
], Zn);
var Sb = class extends Ve {
  constructor() {
    super(...arguments);
    A(this, "_dirtyConversionMap", /* @__PURE__ */ new Map());
  }
  dispose() {
    this._dirtyConversionMap.clear();
  }
  remove(e) {
    this._dirtyConversionMap.delete(e);
  }
  get(e) {
    return this._dirtyConversionMap.get(e);
  }
  has(e) {
    return this._dirtyConversionMap.has(e);
  }
  register(e, t) {
    this._dirtyConversionMap.set(e, t);
  }
  getDirtyConversionMap() {
    return this._dirtyConversionMap;
  }
};
var Mb = createIdentifier(
  "univer.formula.active-dirty-manager.service"
);
var Db = Object.getOwnPropertyDescriptor;
var wb = (a2, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Db(i, e) : i, n = a2.length - 1, s; n >= 0; n--)
    (s = a2[n]) && (r = s(r) || r);
  return r;
};
var oo = (a2, i) => (e, t) => i(e, t, a2);
var Lb = "UNIVER_ENGINE_FORMULA_PLUGIN";
var xs2;
var uo = (xs2 = class extends yl {
  constructor(a2 = Vi, i, e) {
    super(), this._config = a2, this._injector = i, this._configService = e;
    const t = __objRest(co(
      {},
      Vi,
      this._config
    ), []);
    this._configService.setConfig(pa, t);
  }
  onStarting() {
    this._initialize(), this._initializeWithOverride();
  }
  onReady() {
    var a2;
    Kc(this._injector, [
      [Qn],
      [Zn]
    ]), (a2 = this._config) != null && a2.notExecuteFormula || Kc(this._injector, [
      [Kn],
      [Xn],
      [qn],
      [$n]
    ]);
  }
  onRendered() {
    var a2;
    (a2 = this._config) != null && a2.notExecuteFormula || Kc(this._injector, [
      [oa],
      [aa]
    ]);
  }
  _initialize() {
    const a2 = !this._config.notExecuteFormula, i = [
      // Services
      [Xt, { useClass: km }],
      [Lr, { useClass: Fs }],
      [Mb, { useClass: Sb }],
      [Xo, { useClass: ta }],
      [jo, { useClass: Kl }],
      [Pr, { useClass: Fl }],
      [yc],
      // Models
      [yr],
      //Controllers
      [Qn],
      [Zn],
      [ha]
    ];
    a2 && i.push(
      // Services
      [ja, { useClass: yh }],
      [Nt2, { useClass: ra }],
      [Wt, { useClass: Hs }],
      [Wr, { useClass: bh }],
      //Controller
      [$n],
      [Kn],
      [qn],
      [Xn],
      // Calculation engine
      [Vr],
      [Gr],
      [pr],
      // AstNode factory
      [Ko],
      [vn],
      [Tn],
      [ru],
      [In],
      [Un],
      [Bn],
      [Fn2],
      [kn],
      [nu]
    ), i.forEach((e) => this._injector.add(e));
  }
  _initializeWithOverride() {
    var a2;
    this._injector.add([Mn, { useClass: Mn }]), (a2 = this._config) != null && a2.notExecuteFormula || [
      [oa, { useClass: ua }],
      [cs, { useClass: Rh }],
      [aa, { useClass: ia }]
    ].forEach((e) => this._injector.add(e));
  }
}, A(xs2, "pluginName", Lb), xs2);
uo = wb([
  oo(1, Inject(Injector)),
  oo(2, xs)
], uo);

export {
  W,
  m,
  M,
  $,
  g,
  q,
  Y,
  B,
  _e,
  ue,
  I,
  K,
  y,
  f,
  N,
  x,
  ir,
  Xc,
  h,
  fr,
  Kc2 as Kc,
  Z3 as Z,
  Y2,
  Mt,
  X2 as X,
  Rs,
  we2 as we,
  Cn2 as Cn,
  Jc,
  vb,
  Tb,
  bo,
  yl2 as yl,
  At,
  Ft,
  Rr,
  Nl,
  Fr,
  Sl,
  vs,
  _n,
  Ib,
  Yt,
  wl,
  Ll,
  Ts2 as Ts,
  bs,
  Ca,
  kr,
  An,
  Bb,
  xl,
  Is,
  Bs,
  bi,
  Fs,
  Lr,
  Fb,
  _a,
  Vo,
  Aa,
  Ea,
  Oo,
  So,
  Sn,
  Mo,
  Do,
  wo,
  Ra,
  ba,
  Fl,
  Pr,
  kl,
  $l,
  Lo,
  br2 as br,
  He,
  yi,
  ie2 as ie,
  Mn,
  yr,
  Ni,
  pa,
  kb,
  Kl,
  jo,
  Hs,
  Wt,
  pr,
  $b,
  Yb,
  Qt,
  g2,
  ji,
  Sa,
  ce,
  T,
  y2,
  U2 as U,
  K2,
  Pt,
  jr,
  Vm,
  Om,
  xn,
  ta,
  Xo,
  tt,
  Ir,
  ra,
  Nt2 as Nt,
  Ko,
  Ti,
  Xt,
  km,
  Un,
  vn,
  Vr,
  Bi,
  xa,
  Tn,
  ru,
  F,
  J2 as J,
  In,
  Bn,
  Fn2 as Fn,
  kn,
  nu,
  Gr,
  Eh,
  Rh,
  cs,
  bh,
  Wr,
  yh,
  ja,
  sa,
  Hi,
  Ms,
  gr,
  aa,
  ia,
  Sh,
  oa,
  ua,
  $n,
  wh,
  N2,
  ca,
  jh,
  fe2 as fe,
  gg,
  dg,
  Cg,
  _g,
  Hb,
  Xe,
  wg,
  Ae,
  g1,
  Q,
  Ad,
  ee,
  p0,
  Ve2 as Ve,
  Q0,
  Ee,
  hC,
  re,
  ZC,
  SA,
  jA,
  P2 as P,
  ti,
  Wb,
  nR,
  lb,
  fb,
  mb,
  Qb,
  gb,
  yc,
  Sb,
  Mb,
  uo
};
//# sourceMappingURL=chunk-KKODWYZI.js.map
