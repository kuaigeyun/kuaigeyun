import {
  BehaviorSubject,
  Observable,
  ReplaySubject,
  Subject,
  Subscription,
  combineLatest,
  debounceTime,
  distinctUntilChanged,
  filter,
  first,
  firstValueFrom,
  map,
  merge,
  of,
  skip,
  take,
  tap,
  timer
} from "./chunk-AR6LG6UR.js";
import {
  F
} from "./chunk-WJ7JTOYX.js";
import {
  __async,
  __objRest,
  __pow,
  __publicField,
  __spreadProps,
  __spreadValues
} from "./chunk-JMNN7AZU.js";

// node_modules/@wendellhu/redi/dist/esm/index.js
var IdentifierDecoratorSymbol = Symbol("$$IDENTIFIER_DECORATOR");
function isIdentifierDecorator(thing) {
  return thing && thing[IdentifierDecoratorSymbol] === true;
}
function isCtor(thing) {
  return typeof thing === "function";
}
function isClassDependencyItem(thing) {
  if (thing && typeof thing.useClass !== "undefined") return true;
  return false;
}
function isFactoryDependencyItem(thing) {
  if (thing && typeof thing.useFactory !== "undefined") return true;
  return false;
}
function isValueDependencyItem(thing) {
  if (thing && typeof thing.useValue !== "undefined") return true;
  return false;
}
function isExistingDependencyItem(thing) {
  if (thing && typeof thing.useExisting !== "undefined") return true;
  return false;
}
function isAsyncDependencyItem(thing) {
  if (thing && typeof thing.useAsync !== "undefined") return true;
  return false;
}
var AsyncHookSymbol = Symbol("AsyncHook");
function isAsyncHook(thing) {
  if (thing && thing.__symbol === AsyncHookSymbol) return true;
  return false;
}
function prettyPrintIdentifier(id2) {
  return isCtor(id2) && !id2[IdentifierDecoratorSymbol] ? id2.name : id2.toString();
}
var RediError = class extends Error {
  constructor(message) {
    super(`[redi]: ${message}`);
  }
};
var Quantity = function(Quantity$1) {
  Quantity$1["MANY"] = "many";
  Quantity$1["OPTIONAL"] = "optional";
  Quantity$1["REQUIRED"] = "required";
  return Quantity$1;
}({});
var LookUp = function(LookUp$1) {
  LookUp$1["SELF"] = "self";
  LookUp$1["SKIP_SELF"] = "skipSelf";
  return LookUp$1;
}({});
var TARGET = Symbol("$$TARGET");
var DEPENDENCIES = Symbol("$$DEPENDENCIES");
var DependencyDescriptorNotFoundError = class extends RediError {
  constructor(index, target) {
    const msg = `Could not find dependency registered on the ${index} (indexed) parameter of the constructor of "${prettyPrintIdentifier(target)}".`;
    super(msg);
  }
};
var RequiredDecoratorMissusedError = class extends RediError {
  constructor(target, index) {
    const msg = `It seems that you forgot to provide a parameter to @Required() on the ${index}th parameter of "${prettyPrintIdentifier(target)}"`;
    super(msg);
  }
};
var IdentifierUndefinedError = class extends RediError {
  constructor(target, index) {
    const msg = `It seems that you register "undefined" as dependency on the ${index}th parameter of "${prettyPrintIdentifier(target)}". Please make sure that there is not cyclic dependency among your TypeScript files, or consider using "forwardRef". For more info please visit our website https://redi.wendell.fun/docs/faq#could-not-find-dependency-registered-on`;
    super(msg);
  }
};
function getDependencies(registerTarget) {
  const target = registerTarget;
  return target[DEPENDENCIES] || [];
}
function getDependencyByIndex(registerTarget, index) {
  const allDependencies = getDependencies(registerTarget);
  const dep = allDependencies.find((descriptor) => descriptor.paramIndex === index);
  if (!dep) throw new DependencyDescriptorNotFoundError(index, registerTarget);
  return dep;
}
function setDependency(registerTarget, identifier, paramIndex, quantity = Quantity.REQUIRED, lookUp) {
  const descriptor = {
    paramIndex,
    identifier,
    quantity,
    lookUp,
    withNew: false
  };
  if (typeof identifier === "undefined") throw new IdentifierUndefinedError(registerTarget, paramIndex);
  const target = registerTarget;
  if (target[TARGET] === target) target[DEPENDENCIES].push(descriptor);
  else {
    target[DEPENDENCIES] = [descriptor];
    target[TARGET] = target;
  }
}
var knownIdentifiers = /* @__PURE__ */ new Set();
var cachedIdentifiers = /* @__PURE__ */ new Map();
function createIdentifier(id2) {
  if (knownIdentifiers.has(id2)) {
    console.error(`Identifier "${id2}" already exists. Returning the cached identifier decorator.`);
    return cachedIdentifiers.get(id2);
  }
  const decorator = function(registerTarget, _key, index) {
    setDependency(registerTarget, decorator, index);
  };
  decorator.decoratorName = id2;
  decorator.toString = () => decorator.decoratorName;
  decorator[IdentifierDecoratorSymbol] = true;
  knownIdentifiers.add(id2);
  cachedIdentifiers.set(id2, decorator);
  return decorator;
}
function changeLookup(target, index, lookUp) {
  const descriptor = getDependencyByIndex(target, index);
  descriptor.lookUp = lookUp;
}
function lookupDecoratorFactoryProducer(lookUp) {
  return function DecoratorFactory() {
    if (this instanceof DecoratorFactory) return this;
    return function(target, _key, index) {
      changeLookup(target, index, lookUp);
    };
  };
}
var SkipSelf = lookupDecoratorFactoryProducer(LookUp.SKIP_SELF);
var Self = lookupDecoratorFactoryProducer(LookUp.SELF);
function mapQuantityToNumber(quantity) {
  if (quantity === Quantity.OPTIONAL) return "0 or 1";
  else return "1";
}
var QuantityCheckError = class extends RediError {
  constructor(id2, quantity, actual) {
    let msg = `Expect ${mapQuantityToNumber(quantity)} dependency item(s) for id "${prettyPrintIdentifier(id2)}" but get ${actual}.`;
    if (actual === 0) msg += " Did you forget to register it?";
    if (actual > 1) msg += " You register it more than once.";
    super(msg);
    this.quantity = quantity;
    this.actual = actual;
  }
};
function checkQuantity(id2, quantity, length) {
  if (quantity === Quantity.OPTIONAL && length > 1 || quantity === Quantity.REQUIRED && length !== 1) throw new QuantityCheckError(id2, quantity, length);
}
function retrieveQuantity(quantity, arr) {
  if (quantity === Quantity.MANY) return arr;
  else return arr[0];
}
function changeQuantity(target, index, quantity) {
  const descriptor = getDependencyByIndex(target, index);
  descriptor.quantity = quantity;
}
function quantifyDecoratorFactoryProducer(quantity) {
  return function decoratorFactory(id2) {
    if (this instanceof decoratorFactory) return this;
    return function(registerTarget, _key, index) {
      if (id2) setDependency(registerTarget, id2, index, quantity);
      else {
        if (quantity === Quantity.REQUIRED) throw new RequiredDecoratorMissusedError(registerTarget, index);
        changeQuantity(registerTarget, index, quantity);
      }
    };
  };
}
var Many = quantifyDecoratorFactoryProducer(Quantity.MANY);
var Optional = quantifyDecoratorFactoryProducer(Quantity.OPTIONAL);
var Inject = quantifyDecoratorFactoryProducer(Quantity.REQUIRED);
function normalizeFactoryDeps(deps, startIndex = 0) {
  if (!deps) return [];
  return deps.map((dep, index) => {
    index += startIndex;
    if (!Array.isArray(dep)) return {
      paramIndex: index,
      identifier: dep,
      quantity: Quantity.REQUIRED,
      withNew: false
    };
    const modifiers = dep.slice(0, dep.length - 1);
    const identifier = dep[dep.length - 1];
    let lookUp;
    let quantity = Quantity.REQUIRED;
    let withNew = false;
    modifiers.forEach((modifier) => {
      if (modifier instanceof Self) lookUp = LookUp.SELF;
      else if (modifier instanceof SkipSelf) lookUp = LookUp.SKIP_SELF;
      else if (modifier instanceof Optional) quantity = Quantity.OPTIONAL;
      else if (modifier instanceof Many) quantity = Quantity.MANY;
      else withNew = true;
    });
    return {
      paramIndex: index,
      identifier,
      quantity,
      lookUp,
      withNew
    };
  });
}
function setDependencies(registerTarget, deps, startIndex = 0) {
  const normalizedDescriptors = normalizeFactoryDeps(deps, startIndex);
  normalizedDescriptors.forEach((descriptor) => {
    setDependency(registerTarget, descriptor.identifier, descriptor.paramIndex, descriptor.quantity, descriptor.lookUp);
  });
}
function forwardRef(wrapper) {
  return { unwrap: wrapper };
}
function isForwardRef(thing) {
  return !!thing && typeof thing.unwrap === "function";
}
function normalizeForwardRef(id2) {
  if (isForwardRef(id2)) return id2.unwrap();
  return id2;
}
function changeToSelf(target, index, withNew) {
  const descriptor = getDependencyByIndex(target, index);
  descriptor.withNew = withNew;
}
function withNewDecoratorFactoryProducer(withNew) {
  return function DecoratorFactory() {
    if (this instanceof DecoratorFactory) return this;
    return function(target, _key, index) {
      changeToSelf(target, index, withNew);
    };
  };
}
var WithNew = withNewDecoratorFactoryProducer(true);
function isDisposable(thing) {
  return !!thing && typeof thing.dispose === "function";
}
function isBareClassDependency(thing) {
  return thing.length === 1;
}
var ResolvingStack = [];
function pushResolvingStack(id2) {
  ResolvingStack.push(id2);
}
function popupResolvingStack() {
  ResolvingStack.pop();
}
function clearResolvingStack() {
  ResolvingStack.length = 0;
}
var DependencyNotFoundForModuleError = class extends RediError {
  constructor(toInstantiate, id2, index) {
    const msg = `Cannot find "${prettyPrintIdentifier(id2)}" registered by any injector. It is the ${index}th param of "${isIdentifierDecorator(toInstantiate) ? prettyPrintIdentifier(toInstantiate) : toInstantiate.name}".`;
    super(msg);
  }
};
var DependencyNotFoundError = class extends RediError {
  constructor(id2) {
    const msg = `Cannot find "${prettyPrintIdentifier(id2)}" registered by any injector. The stack of dependencies is: "${ResolvingStack.map((id$1) => prettyPrintIdentifier(id$1)).join(" -> ")}".`;
    super(msg);
    clearResolvingStack();
  }
};
var DependencyCollection = class {
  constructor(dependencies) {
    __publicField(this, "dependencyMap", /* @__PURE__ */ new Map());
    this.normalizeDependencies(dependencies).map((pair) => this.add(pair[0], pair[1]));
  }
  add(ctorOrId, val) {
    if (typeof val === "undefined") val = {
      useClass: ctorOrId,
      lazy: false
    };
    let arr = this.dependencyMap.get(ctorOrId);
    if (typeof arr === "undefined") {
      arr = [];
      this.dependencyMap.set(ctorOrId, arr);
    }
    arr.push(val);
  }
  delete(id2) {
    this.dependencyMap.delete(id2);
  }
  get(id2, quantity) {
    const ret = this.dependencyMap.get(id2);
    checkQuantity(id2, quantity, ret.length);
    return retrieveQuantity(quantity, ret);
  }
  has(id2) {
    return this.dependencyMap.has(id2);
  }
  dispose() {
    this.dependencyMap.clear();
  }
  /**
  * normalize dependencies to `DependencyItem`
  */
  normalizeDependencies(dependencies) {
    return dependencies.map((dependency) => {
      const id2 = dependency[0];
      let val;
      if (isBareClassDependency(dependency)) val = {
        useClass: dependency[0],
        lazy: false
      };
      else val = dependency[1];
      return [id2, val];
    });
  }
};
var ResolvedDependencyCollection = class {
  constructor() {
    __publicField(this, "resolvedDependencies", /* @__PURE__ */ new Map());
  }
  add(id2, val) {
    let arr = this.resolvedDependencies.get(id2);
    if (typeof arr === "undefined") {
      arr = [];
      this.resolvedDependencies.set(id2, arr);
    }
    arr.push(val);
  }
  has(id2) {
    return this.resolvedDependencies.has(id2);
  }
  get(id2, quantity) {
    const ret = this.resolvedDependencies.get(id2);
    if (!ret) throw new DependencyNotFoundError(id2);
    checkQuantity(id2, quantity, ret.length);
    if (quantity === Quantity.MANY) return ret;
    else return ret[0];
  }
  dispose() {
    Array.from(this.resolvedDependencies.values()).forEach((items) => {
      items.forEach((item) => isDisposable(item) ? item.dispose() : void 0);
    });
    this.resolvedDependencies.clear();
  }
};
var runWhenIdle;
(function() {
  if (typeof requestIdleCallback !== "undefined" && typeof cancelIdleCallback !== "undefined") runWhenIdle = (runner, timeout) => {
    const handle = requestIdleCallback(runner, typeof timeout === "number" ? { timeout } : void 0);
    let disposed = false;
    return () => {
      if (disposed) return;
      disposed = true;
      cancelIdleCallback(handle);
    };
  };
  else {
    const dummyIdle = Object.freeze({
      didTimeout: true,
      timeRemaining() {
        return 15;
      }
    });
    runWhenIdle = (runner) => {
      const handle = setTimeout(() => runner(dummyIdle));
      let disposed = false;
      return () => {
        if (disposed) return;
        disposed = true;
        clearTimeout(handle);
      };
    };
  }
})();
var IdleValue = class {
  constructor(executor) {
    __publicField(this, "executor");
    __publicField(this, "disposeIdleCallback");
    __publicField(this, "didRun", false);
    __publicField(this, "value");
    __publicField(this, "error");
    this.executor = () => {
      try {
        this.value = executor();
      } catch (err) {
        this.error = err;
      } finally {
        this.didRun = true;
      }
    };
    this.disposeIdleCallback = runWhenIdle(() => this.executor());
  }
  hasRun() {
    return this.didRun;
  }
  dispose() {
    this.disposeIdleCallback();
  }
  getValue() {
    if (!this.didRun) {
      this.disposeIdleCallback();
      this.executor();
    }
    if (this.error) throw this.error;
    return this.value;
  }
};
var MAX_RESOLUTIONS_QUEUED = 300;
var NotInstantiatedSymbol = Symbol("$$NOT_INSTANTIATED_SYMBOL");
var CircularDependencyError = class extends RediError {
  constructor(id2) {
    super(`Detecting cyclic dependency. The last identifier is "${prettyPrintIdentifier(id2)}".`);
  }
};
var InjectorAlreadyDisposedError = class extends RediError {
  constructor() {
    super("Injector cannot be accessed after it was disposed.");
  }
};
var AsyncItemReturnAsyncItemError = class extends RediError {
  constructor(id2) {
    super(`Async item "${prettyPrintIdentifier(id2)}" returns another async item.`);
  }
};
var GetAsyncItemFromSyncApiError = class extends RediError {
  constructor(id2) {
    super(`Cannot get async item "${prettyPrintIdentifier(id2)}" from sync api.`);
  }
};
var AddDependencyAfterResolutionError = class extends RediError {
  constructor(id2) {
    super(`Cannot add dependency "${prettyPrintIdentifier(id2)}" after it is already resolved.`);
  }
};
var DeleteDependencyAfterResolutionError = class extends RediError {
  constructor(id2) {
    super(`Cannot delete dependency "${prettyPrintIdentifier(id2)}" when it is already resolved.`);
  }
};
var Injector = class Injector2 {
  /**
  * Create a new `Injector` instance
  * @param dependencies Dependencies that should be resolved by this injector instance.
  * @param parent Optional parent injector.
  */
  constructor(dependencies, parent = null) {
    __publicField(this, "dependencyCollection");
    __publicField(this, "resolvedDependencyCollection");
    __publicField(this, "children", []);
    __publicField(this, "resolutionOngoing", 0);
    __publicField(this, "disposingCallbacks", /* @__PURE__ */ new Set());
    __publicField(this, "disposed", false);
    this.parent = parent;
    this.dependencyCollection = new DependencyCollection(dependencies || []);
    this.resolvedDependencyCollection = new ResolvedDependencyCollection();
    if (parent) parent.children.push(this);
  }
  /**
  * Add a callback function that will be triggered when the Injector is disposed.
  * Please note that when you callback is invoked, the injector is already disposed and
  * you will not be able to interact with this Injector any more.
  *
  * @param {() => void} callback The callback function that will be invoked when
  * the Injector is disposed.
  * @returns A disposable that will remove the callback.
  */
  onDispose(callback) {
    this.disposingCallbacks.add(callback);
    return { dispose: () => this.disposingCallbacks.delete(callback) };
  }
  /**
  * Create a child inject with a set of dependencies.
  * @param dependencies Dependencies that should be resolved by the newly created child injector.
  * @returns The child injector.
  */
  createChild(dependencies) {
    this._ensureInjectorNotDisposed();
    return new Injector2(dependencies, this);
  }
  /**
  * Dispose the injector and all dependencies held by this injector. Note that its child injectors will dispose first.
  */
  dispose() {
    this.children.forEach((c) => c.dispose());
    this.children.length = 0;
    this.dependencyCollection.dispose();
    this.resolvedDependencyCollection.dispose();
    this.deleteSelfFromParent();
    this.disposed = true;
    this.disposingCallbacks.forEach((callback) => callback());
    this.disposingCallbacks.clear();
  }
  deleteSelfFromParent() {
    if (this.parent) {
      const index = this.parent.children.indexOf(this);
      this.parent.children.splice(index, 1);
    }
  }
  /**
  * Add a dependency or its instance into injector. It would throw an error if the dependency
  * has already been instantiated.
  *
  * @param dependency The dependency or an instance that would be add in the injector.
  */
  add(dependency) {
    this._ensureInjectorNotDisposed();
    const identifierOrCtor = dependency[0];
    const item = dependency[1];
    if (this.resolvedDependencyCollection.has(identifierOrCtor)) throw new AddDependencyAfterResolutionError(identifierOrCtor);
    if (typeof item === "undefined") this.dependencyCollection.add(identifierOrCtor);
    else if (isAsyncDependencyItem(item) || isClassDependencyItem(item) || isValueDependencyItem(item) || isFactoryDependencyItem(item)) this.dependencyCollection.add(identifierOrCtor, item);
    else this.resolvedDependencyCollection.add(identifierOrCtor, item);
  }
  /**
  * Replace an injection mapping for interface-based injection. It would throw an error if the dependency
  * has already been instantiated.
  *
  * @param dependency The dependency that will replace the already existed dependency.
  */
  replace(dependency) {
    this._ensureInjectorNotDisposed();
    const identifier = dependency[0];
    if (this.resolvedDependencyCollection.has(identifier)) throw new AddDependencyAfterResolutionError(identifier);
    this.dependencyCollection.delete(identifier);
    this.dependencyCollection.add(identifier, dependency[1]);
  }
  /**
  * Delete a dependency from an injector. It would throw an error when the deleted dependency
  * has already been instantiated.
  *
  * @param identifier The identifier of the dependency that is supposed to be deleted.
  */
  delete(identifier) {
    this._ensureInjectorNotDisposed();
    if (this.resolvedDependencyCollection.has(identifier)) throw new DeleteDependencyAfterResolutionError(identifier);
    this.dependencyCollection.delete(identifier);
  }
  /**
  * Invoke a function with dependencies injected. The function could only get dependency from the injector
  * and other methods are not accessible for the function.
  *
  * @param cb the function to be executed
  * @param args arguments to be passed into the function
  * @returns the return value of the function
  */
  invoke(cb, ...args) {
    this._ensureInjectorNotDisposed();
    const accessor = {
      get: (id2, quantityOrLookup, lookUp) => {
        return this._get(id2, quantityOrLookup, lookUp);
      },
      has: (id2) => {
        return this.has(id2);
      }
    };
    return cb(accessor, ...args);
  }
  /**
  * Check if the injector could initialize a dependency.
  *
  * @param id Identifier of the dependency
  */
  has(id2) {
    var _a2;
    return this.dependencyCollection.has(id2) || ((_a2 = this.parent) == null ? void 0 : _a2.has(id2)) || false;
  }
  /**
  * Get dependency instance(s).
  *
  * @param id Identifier of the dependency
  * @param quantityOrLookup @link{Quantity} or @link{LookUp}
  * @param lookUp @link{LookUp}
  */
  get(id2, quantityOrLookup, lookUp) {
    this._ensureInjectorNotDisposed();
    const newResult = this._get(id2, quantityOrLookup, lookUp);
    if (Array.isArray(newResult) && newResult.some((r) => isAsyncHook(r)) || isAsyncHook(newResult)) throw new GetAsyncItemFromSyncApiError(id2);
    return newResult;
  }
  _get(id2, quantityOrLookup, lookUp, withNew) {
    let quantity = Quantity.REQUIRED;
    if (quantityOrLookup === Quantity.REQUIRED || quantityOrLookup === Quantity.OPTIONAL || quantityOrLookup === Quantity.MANY) quantity = quantityOrLookup;
    else lookUp = quantityOrLookup;
    if (!withNew) {
      const cachedResult = this.getValue(id2, quantity, lookUp);
      if (cachedResult !== NotInstantiatedSymbol) return cachedResult;
    }
    const shouldCache = !withNew;
    return this.createDependency(id2, quantity, lookUp, shouldCache);
  }
  /**
  * Get a dependency in the async way.
  */
  getAsync(id2) {
    this._ensureInjectorNotDisposed();
    const cachedResult = this.getValue(id2, Quantity.REQUIRED);
    if (cachedResult !== NotInstantiatedSymbol) return Promise.resolve(cachedResult);
    const newResult = this.createDependency(id2, Quantity.REQUIRED);
    if (!isAsyncHook(newResult)) return Promise.resolve(newResult);
    return newResult.whenReady();
  }
  /**
  * Instantiate a class. The created instance would not be held by the injector.
  */
  createInstance(ctor, ...customArgs) {
    this._ensureInjectorNotDisposed();
    return this._resolveClassImpl({ useClass: ctor }, ...customArgs);
  }
  _resolveDependency(id2, item, shouldCache = true) {
    let result;
    pushResolvingStack(id2);
    try {
      if (isValueDependencyItem(item)) result = this._resolveValueDependency(id2, item);
      else if (isFactoryDependencyItem(item)) result = this._resolveFactory(id2, item, shouldCache);
      else if (isClassDependencyItem(item)) result = this._resolveClass(id2, item, shouldCache);
      else if (isExistingDependencyItem(item)) result = this._resolveExisting(id2, item);
      else result = this._resolveAsync(id2, item);
      popupResolvingStack();
    } catch (e) {
      popupResolvingStack();
      throw e;
    }
    return result;
  }
  _resolveExisting(id2, item) {
    const thing = this.get(item.useExisting);
    this.resolvedDependencyCollection.add(id2, thing);
    return thing;
  }
  _resolveValueDependency(id2, item) {
    const thing = item.useValue;
    this.resolvedDependencyCollection.add(id2, thing);
    return thing;
  }
  _resolveClass(id2, item, shouldCache) {
    let thing;
    if (item.lazy) {
      const idle = new IdleValue(() => {
        this._ensureInjectorNotDisposed();
        return this._resolveClassImpl(item);
      });
      thing = new Proxy(/* @__PURE__ */ Object.create(null), {
        get(target, key) {
          if (key in target) return target[key];
          const thing$1 = idle.getValue();
          let property = thing$1[key];
          if (typeof property !== "function") return property;
          property = property.bind(thing$1);
          target[key] = property;
          return property;
        },
        set(_target, key, value) {
          idle.getValue()[key] = value;
          return true;
        }
      });
    } else thing = this._resolveClassImpl(item);
    if (id2 && shouldCache) this.resolvedDependencyCollection.add(id2, thing);
    return thing;
  }
  _resolveClassImpl(item, ...extraParams) {
    var _a2;
    const Ctor = item.useClass;
    this.markNewResolution(Ctor);
    const declaredDependencies = getDependencies(Ctor).sort((a, b) => a.paramIndex - b.paramIndex).map((descriptor) => __spreadProps(__spreadValues({}, descriptor), {
      identifier: normalizeForwardRef(descriptor.identifier)
    }));
    const resolvedArgs = [];
    for (const dep of declaredDependencies) try {
      const thing$1 = this._get(dep.identifier, dep.quantity, dep.lookUp, dep.withNew);
      resolvedArgs.push(thing$1);
    } catch (error) {
      if (error instanceof DependencyNotFoundError || error instanceof QuantityCheckError && error.actual === 0) throw new DependencyNotFoundForModuleError(Ctor, dep.identifier, dep.paramIndex);
      throw error;
    }
    let args = [...extraParams];
    const firstDependencyArgIndex = declaredDependencies.length > 0 ? declaredDependencies[0].paramIndex : args.length;
    if (args.length !== firstDependencyArgIndex) {
      console.warn(`[redi]: Expect ${firstDependencyArgIndex} custom parameter(s) of ${prettyPrintIdentifier(Ctor)} but get ${args.length}.`);
      const delta = firstDependencyArgIndex - args.length;
      if (delta > 0) args = [...args, ...Array.from({ length: delta }).fill(void 0)];
      else args = args.slice(0, firstDependencyArgIndex);
    }
    const thing = new Ctor(...args, ...resolvedArgs);
    (_a2 = item == null ? void 0 : item.onInstantiation) == null ? void 0 : _a2.call(item, thing);
    this.markResolutionCompleted();
    return thing;
  }
  _resolveFactory(id2, item, shouldCache) {
    var _a2;
    this.markNewResolution(id2);
    const declaredDependencies = normalizeFactoryDeps(item.deps);
    const resolvedArgs = [];
    for (const dep of declaredDependencies) try {
      const thing$1 = this._get(dep.identifier, dep.quantity, dep.lookUp, dep.withNew);
      resolvedArgs.push(thing$1);
    } catch (error) {
      if (error instanceof DependencyNotFoundError || error instanceof QuantityCheckError && error.actual === 0) throw new DependencyNotFoundForModuleError(id2, dep.identifier, dep.paramIndex);
      throw error;
    }
    const thing = item.useFactory.apply(null, resolvedArgs);
    if (shouldCache) this.resolvedDependencyCollection.add(id2, thing);
    this.markResolutionCompleted();
    (_a2 = item == null ? void 0 : item.onInstantiation) == null ? void 0 : _a2.call(item, thing);
    return thing;
  }
  _resolveAsync(id2, item) {
    const asyncLoader = {
      __symbol: AsyncHookSymbol,
      whenReady: () => this._resolveAsyncImpl(id2, item)
    };
    return asyncLoader;
  }
  _resolveAsyncImpl(id2, item) {
    return item.useAsync().then((thing) => {
      const resolvedCheck = this.getValue(id2);
      if (resolvedCheck !== NotInstantiatedSymbol) return resolvedCheck;
      let ret;
      if (Array.isArray(thing)) {
        const item$1 = thing[1];
        if (isAsyncDependencyItem(item$1)) throw new AsyncItemReturnAsyncItemError(id2);
        else ret = this._resolveDependency(id2, item$1);
      } else if (isCtor(thing)) ret = this._resolveClassImpl({
        useClass: thing,
        onInstantiation: item.onInstantiation
      });
      else ret = thing;
      this.resolvedDependencyCollection.add(id2, ret);
      return ret;
    });
  }
  getValue(id2, quantity = Quantity.REQUIRED, lookUp) {
    const onSelf = () => {
      if (this.dependencyCollection.has(id2) && !this.resolvedDependencyCollection.has(id2)) return NotInstantiatedSymbol;
      return this.resolvedDependencyCollection.get(id2, quantity);
    };
    const onParent = () => {
      if (this.parent) return this.parent.getValue(id2, quantity);
      else {
        if (quantity === Quantity.OPTIONAL) return null;
        else if (quantity === Quantity.MANY) return [];
        throw new QuantityCheckError(id2, Quantity.REQUIRED, 0);
      }
    };
    if (lookUp === LookUp.SKIP_SELF) return onParent();
    if (id2 === Injector2) return this;
    if (lookUp === LookUp.SELF) return onSelf();
    if (this.resolvedDependencyCollection.has(id2) || this.dependencyCollection.has(id2)) return onSelf();
    return onParent();
  }
  createDependency(id2, quantity, lookUp, shouldCache = true) {
    const onSelf = () => {
      const registrations = this.dependencyCollection.get(id2, quantity);
      let ret = null;
      if (Array.isArray(registrations)) ret = registrations.map((dependencyItem) => this._resolveDependency(id2, dependencyItem, shouldCache));
      else ret = this._resolveDependency(id2, registrations, shouldCache);
      return ret;
    };
    const onParent = () => {
      if (this.parent) return this.parent.createDependency(id2, quantity, void 0, shouldCache);
      else {
        if (quantity === Quantity.OPTIONAL) return null;
        else if (quantity === Quantity.MANY) return [];
        pushResolvingStack(id2);
        throw new DependencyNotFoundError(id2);
      }
    };
    if (lookUp === LookUp.SKIP_SELF) return onParent();
    if (this.dependencyCollection.has(id2)) return onSelf();
    return onParent();
  }
  markNewResolution(id2) {
    this.resolutionOngoing += 1;
    if (this.resolutionOngoing >= MAX_RESOLUTIONS_QUEUED) throw new CircularDependencyError(id2);
  }
  markResolutionCompleted() {
    this.resolutionOngoing -= 1;
  }
  _ensureInjectorNotDisposed() {
    if (this.disposed) throw new InjectorAlreadyDisposedError();
  }
};
var globalObject = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global !== "undefined" && global;
var __REDI_GLOBAL_LOCK__ = "REDI_GLOBAL_LOCK";
var isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
if (globalObject[__REDI_GLOBAL_LOCK__]) {
  if (!isNode) console.error(`[redi]: You are loading scripts of redi more than once! This may cause undesired behavior in your application.
Maybe your dependencies added redi as its dependency and bundled redi to its dist files. Or you import different versions of redi.
For more info please visit our website: https://redi.wendell.fun/en-US/docs/faq#import-scripts-of-redi-more-than-once`);
} else globalObject[__REDI_GLOBAL_LOCK__] = true;

// node_modules/@univerjs/core/lib/es/index.js
var Cc = Object.defineProperty;
var Rc = (e, t, n) => t in e ? Cc(e, t, { enumerable: true, configurable: true, writable: true, value: n }) : e[t] = n;
var p = (e, t, n) => Rc(e, typeof t != "symbol" ? t + "" : t, n);
function Lc(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const s in r)
        if (s !== "default" && !(s in e)) {
          const i = Object.getOwnPropertyDescriptor(r, s);
          i && Object.defineProperty(e, s, i.get ? i : {
            enumerable: true,
            get: () => r[s]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var Ut = typeof global < "u" ? global : typeof self < "u" ? self : window;
function Dc() {
  const t = /* @__PURE__ */ new Map();
  let n = 0;
  typeof Ut.requestIdleCallback != "function" && (Ut.requestIdleCallback = function(s) {
    const i = Date.now(), o = ++n, a = setTimeout(function() {
      t.delete(o);
      const u = Math.max(0, 50 - (Date.now() - i));
      s({
        didTimeout: u === 0,
        timeRemaining() {
          return u;
        }
      });
    }, 1);
    return t.set(o, a), o;
  }), typeof Ut.cancelIdleCallback != "function" && (Ut.cancelIdleCallback = function(s) {
    const i = t.get(s);
    i !== void 0 && (clearTimeout(i), t.delete(s));
  });
}
function Uc() {
  typeof Ut.Array.prototype.findLastIndex != "function" && (Ut.Array.prototype.findLastIndex = function(t, n) {
    if (this == null)
      throw new TypeError("Array.prototype.findLastIndex called on null or undefined");
    if (typeof t != "function")
      throw new TypeError("callback must be a function");
    const r = this.length >>> 0;
    for (let s = r - 1; s >= 0; s--)
      if (s in this && t.call(n, this[s], s, this))
        return s;
    return -1;
  }), typeof Ut.Array.prototype.findLast != "function" && (Ut.Array.prototype.findLast = function(t, n) {
    const r = this.findLastIndex(t, n);
    return r !== -1 ? this[r] : void 0;
  });
}
function Pc() {
  typeof Ut.String.prototype.at != "function" && (Ut.String.prototype.at = function(t) {
    if (this == null)
      throw new TypeError("String.prototype.at called on null or undefined");
    const n = this.length;
    if (t < 0 && (t = n + t), !(t < 0 || t >= n))
      return this.charAt(t);
  });
}
function kc() {
  Dc(), Uc(), Pc();
}
function vs(e, t) {
  const n = e.indexOf(t);
  return n > -1 ? (e.splice(n, 1), true) : false;
}
function VC(e) {
  const t = /* @__PURE__ */ new Set(), n = [];
  for (const r of e)
    t.has(r) || (t.add(r), n.push(r));
  return n;
}
function GC(e, t) {
  const n = /* @__PURE__ */ new Set(), r = [];
  for (const s of e) {
    const i = t(s);
    n.has(i) || (n.add(i), r.push(s));
  }
  return r;
}
function Fc(e, t) {
  for (let n = e.length - 1; n > -1; n--) {
    const r = e[n];
    if (t(r, n))
      return r;
  }
  return null;
}
function KC(e, t) {
  if (e.length === 0)
    return e;
  const n = t % e.length;
  return e.slice(n).concat(e.slice(0, n));
}
function XC(e, t) {
  const n = /* @__PURE__ */ new Map();
  return e.forEach((r) => {
    const s = t(r);
    let i = n.get(s);
    n.has(s) || (i = [], n.set(s, i)), i.push(r);
  }), n;
}
function qC(e) {
  return Array.isArray(e) ? e : [e];
}
function It(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var zs;
var aa;
function Hc() {
  if (aa) return zs;
  aa = 1;
  var e = function(t) {
    if (t = t || {}, this.Promise = t.Promise || Promise, this.queues = /* @__PURE__ */ Object.create(null), this.domainReentrant = t.domainReentrant || false, this.domainReentrant) {
      if (typeof process > "u" || typeof process.domain > "u")
        throw new Error(
          "Domain-reentrant locks require `process.domain` to exist. Please flip `opts.domainReentrant = false`, use a NodeJS version that still implements Domain, or install a browser polyfill."
        );
      this.domains = /* @__PURE__ */ Object.create(null);
    }
    this.timeout = t.timeout || e.DEFAULT_TIMEOUT, this.maxOccupationTime = t.maxOccupationTime || e.DEFAULT_MAX_OCCUPATION_TIME, this.maxExecutionTime = t.maxExecutionTime || e.DEFAULT_MAX_EXECUTION_TIME, t.maxPending === 1 / 0 || Number.isInteger(t.maxPending) && t.maxPending >= 0 ? this.maxPending = t.maxPending : this.maxPending = e.DEFAULT_MAX_PENDING;
  };
  return e.DEFAULT_TIMEOUT = 0, e.DEFAULT_MAX_OCCUPATION_TIME = 0, e.DEFAULT_MAX_EXECUTION_TIME = 0, e.DEFAULT_MAX_PENDING = 1e3, e.prototype.acquire = function(t, n, r, s) {
    if (Array.isArray(t))
      return this._acquireBatch(t, n, r, s);
    if (typeof n != "function")
      throw new Error("You must pass a function to execute");
    var i = null, o = null, a = null;
    typeof r != "function" && (s = r, r = null, a = new this.Promise(function(k, W) {
      i = k, o = W;
    })), s = s || {};
    var l = false, u = null, c = null, h = null, d = this, f = function(k, W, w) {
      c && (clearTimeout(c), c = null), h && (clearTimeout(h), h = null), k && (d.queues[t] && d.queues[t].length === 0 && delete d.queues[t], d.domainReentrant && delete d.domains[t]), l || (a ? W ? o(W) : i(w) : typeof r == "function" && r(W, w), l = true), k && d.queues[t] && d.queues[t].length > 0 && d.queues[t].shift()();
    }, g = function(k) {
      if (l)
        return f(k);
      u && (clearTimeout(u), u = null), d.domainReentrant && k && (d.domains[t] = process.domain);
      var W = s.maxExecutionTime || d.maxExecutionTime;
      if (W && (h = setTimeout(function() {
        d.queues[t] && f(k, new Error("Maximum execution time is exceeded " + t));
      }, W)), n.length === 1) {
        var w = false;
        try {
          n(function(C, v) {
            w || (w = true, f(k, C, v));
          });
        } catch (C) {
          w || (w = true, f(k, C));
        }
      } else
        d._promiseTry(function() {
          return n();
        }).then(function(C) {
          f(k, void 0, C);
        }, function(C) {
          f(k, C);
        });
    };
    d.domainReentrant && process.domain && (g = process.domain.bind(g));
    var _ = s.maxPending || d.maxPending;
    if (!d.queues[t])
      d.queues[t] = [], g(true);
    else if (d.domainReentrant && process.domain && process.domain === d.domains[t])
      g(false);
    else if (d.queues[t].length >= _)
      f(false, new Error("Too many pending tasks in queue " + t));
    else {
      var R = function() {
        g(true);
      };
      s.skipQueue ? d.queues[t].unshift(R) : d.queues[t].push(R);
      var b = s.timeout || d.timeout;
      b && (u = setTimeout(function() {
        u = null, f(false, new Error("async-lock timed out in queue " + t));
      }, b));
    }
    var $ = s.maxOccupationTime || d.maxOccupationTime;
    if ($ && (c = setTimeout(function() {
      d.queues[t] && f(false, new Error("Maximum occupation time is exceeded in queue " + t));
    }, $)), a)
      return a;
  }, e.prototype._acquireBatch = function(t, n, r, s) {
    typeof r != "function" && (s = r, r = null);
    var i = this, o = function(l, u) {
      return function(c) {
        i.acquire(l, u, c, s);
      };
    }, a = t.reduceRight(function(l, u) {
      return o(u, l);
    }, n);
    if (typeof r == "function")
      a(r);
    else
      return new this.Promise(function(l, u) {
        a.length === 1 ? a(function(c, h) {
          c ? u(c) : l(h);
        }) : l(a());
      });
  }, e.prototype.isBusy = function(t) {
    return t ? !!this.queues[t] : Object.keys(this.queues).length > 0;
  }, e.prototype._promiseTry = function(t) {
    try {
      return this.Promise.resolve(t());
    } catch (n) {
      return this.Promise.reject(n);
    }
  }, zs = e, zs;
}
var Vs;
var la;
function $c() {
  return la || (la = 1, Vs = Hc()), Vs;
}
var Bc = $c();
var JC = It(Bc);
var jc = /* @__PURE__ */ new Set(["true", "false"]);
function ZC(e) {
  return jc.has(e.toLowerCase());
}
var yr = "__INTERNAL_EDITOR__";
var Fl = `${yr}DOCS_NORMAL`;
var Hl = `${yr}DOCS_FORMULA_BAR`;
var Wc = `${yr}ZEN_EDITOR`;
var Yc = `\r
`;
var zc = "isRowStylePrecedeColumnStyle";
var Vc = Symbol("AUTO_HEIGHT_FOR_MERGED_CELLS");
function QC(e) {
  return `${yr}${e}`;
}
function Gc(e) {
  return e.startsWith(yr);
}
function eR(e, t) {
  t.forEach((n) => e.add(n));
}
function Kc(e, t) {
  t.forEach(([n]) => {
    e.has(n) && e.get(n);
  });
}
function Xc(e, t) {
  if (Object.is(e, t))
    return true;
  if (typeof e != "object" || !e || typeof t != "object" || !t)
    return false;
  const n = Object.keys(e), r = Object.keys(t);
  if (n.length !== r.length)
    return false;
  const s = Object.prototype.hasOwnProperty.bind(t);
  for (let i = 0; i < n.length; i++) {
    const o = n[i];
    if (!s(o))
      return false;
    const a = e[o], l = t[o];
    if (a !== l)
      return false;
  }
  return true;
}
var Ci = class extends Error {
  constructor(t) {
    super(t), this.name = "CustomCommandExecutionError";
  }
};
var tR = class extends Ci {
  constructor() {
    super("Canceled by facade"), this.name = "CanceledError";
  }
};
function nR(e, t = 16) {
  let n = 0, r = null;
  return function(...i) {
    const o = Date.now();
    o - n < t ? (r && clearTimeout(r), r = setTimeout(() => {
      n = o, e.apply(this, i);
    }, t)) : (n = o, e.apply(this, i));
  };
}
var ir = ((e) => (e[e.Style = 1] = "Style", e[e.Value = 2] = "Value", e))(ir || {});
function rR(e) {
  return `sheet_interceptor_${e}`;
}
var qc = (e) => function(t, n) {
  let r = -1, s = t;
  for (let i = 0; i <= e.length; i++) {
    if (i <= r)
      throw new Error("[SheetInterceptorService]: next() called multiple times!");
    if (r = i, i === e.length)
      return s;
    const o = e[i];
    let a = false;
    if (s = o.handler(s, n, (l) => (a = true, l)), !a)
      break;
  }
  return s;
};
var sR = class {
  constructor(t) {
    p(this, "_interceptorsByName", /* @__PURE__ */ new Map());
    p(this, "_interceptorPoints");
    this._interceptorPoints = t;
  }
  /**
   * Get the interceptors.
   * @param name Name of the intercepted point.
   * @param filter A callback function to filter the interceptors.
   * @returns It will return a composed interceptor function. If you will perform the interceptor repeatedly,
   * you should cache the result instead of calling this function multiple times.
   */
  fetchThroughInterceptors(t, n) {
    const r = t;
    let s = this._interceptorsByName.get(r);
    return n && (s = s.filter(n)), qc(s || []);
  }
  intercept(t, n) {
    const r = t;
    this._interceptorsByName.has(r) || this._interceptorsByName.set(r, []);
    const s = this._interceptorsByName.get(r);
    return s.push(n), this._interceptorsByName.set(
      r,
      s.sort((i, o) => {
        var a, l;
        return ((a = o.priority) != null ? a : 0) - ((l = i.priority) != null ? l : 0);
      })
      // from large to small
    ), () => vs(this._interceptorsByName.get(r), n);
  }
  getInterceptPoints() {
    return this._interceptorPoints;
  }
  dispose() {
    this._interceptorsByName.clear();
  }
};
function iR(e) {
  return `sheet_async_interceptor_${e}`;
}
var Jc = (e) => function(t, n) {
  return __async(this, null, function* () {
    let r = -1, s = t;
    for (let i = 0; i <= e.length; i++) {
      if (i <= r)
        throw new Error("[SheetInterceptorService]: next() called multiple times!");
      if (r = i, i === e.length)
        return s;
      const o = e[i];
      let a = false;
      if (s = yield o.handler(s, n, (l) => __async(this, null, function* () {
        return a = true, l;
      })), !a)
        break;
    }
    return s;
  });
};
var oR = class {
  constructor(t) {
    p(this, "_asyncInterceptorsByName", /* @__PURE__ */ new Map());
    p(this, "_asyncInterceptorPoints");
    this._asyncInterceptorPoints = t;
  }
  /**
   * Get the interceptors.
   * @param name Name of the intercepted point.
   * @param filter A callback function to filter the interceptors.
   * @returns It will return a composed interceptor function. If you will perform the interceptor repeatedly,
   * you should cache the result instead of calling this function multiple times.
   */
  fetchThroughAsyncInterceptors(t, n) {
    const r = t;
    let s = this._asyncInterceptorsByName.get(r);
    return n && (s = s.filter(n)), Jc(s || []);
  }
  interceptAsync(t, n) {
    return __async(this, null, function* () {
      const r = t;
      this._asyncInterceptorsByName.has(r) || this._asyncInterceptorsByName.set(r, []);
      const s = this._asyncInterceptorsByName.get(r);
      return s.push(n), this._asyncInterceptorsByName.set(
        r,
        s.sort((i, o) => {
          var a, l;
          return ((a = o.priority) != null ? a : 0) - ((l = i.priority) != null ? l : 0);
        })
        // from large to small
      ), () => vs(this._asyncInterceptorsByName.get(r), n);
    });
  }
  getInterceptPoints() {
    return this._asyncInterceptorPoints;
  }
  dispose() {
    this._asyncInterceptorsByName.clear();
  }
};
function $l(e) {
  return e.map((t) => t / 255);
}
function Bl(e) {
  return e.map((t) => Math.round(t * 255));
}
function Zc([e, t, n]) {
  const r = Math.max(e, t, n), s = Math.min(e, t, n), i = (r + s) / 2;
  let o = 0, a = 0;
  if (r !== s) {
    const l = r - s;
    switch (a = i > 0.5 ? l / (2 - r - s) : l / (r + s), r) {
      case e:
        o = (t - n) / l + (t < n ? 6 : 0);
        break;
      case t:
        o = (n - e) / l + 2;
        break;
      case n:
        o = (e - t) / l + 4;
        break;
    }
    o /= 6;
  }
  return [o, a, i];
}
function fs(e, t, n) {
  const r = [e, t, n].map((s) => s <= 0.03928 ? s / 12.92 : __pow((s + 0.055) / 1.055, 2.4));
  return 0.2126 * r[0] + 0.7152 * r[1] + 0.0722 * r[2];
}
function ua(e, t) {
  return (Math.max(e, t) + 0.05) / (Math.min(e, t) + 0.05);
}
function Qc(e, t, n) {
  let r, s, i;
  if (t === 0)
    r = s = i = n;
  else {
    const o = (u, c, h) => {
      let d = h;
      return d < 0 && (d += 1), d > 1 && (d -= 1), d < 0.16666666666666666 ? u + (c - u) * 6 * d : d < 0.5 ? c : d < 0.6666666666666666 ? u + (c - u) * (0.6666666666666666 - d) * 6 : u;
    }, a = n < 0.5 ? n * (1 + t) : n + t - n * t, l = 2 * n - a;
    r = o(l, a, e + 1 / 3), s = o(l, a, e), i = o(l, a, e - 1 / 3);
  }
  return [r, s, i];
}
var Gs = { r: 1, g: 1, b: 1 };
var Ks = { r: 0, g: 0, b: 0 };
var eh = fs(Gs.r, Gs.g, Gs.b);
var th = fs(Ks.r, Ks.g, Ks.b);
function nh(e) {
  const t = fs(e[0], e[1], e[2]), n = ua(
    eh,
    t
  ), r = Zc(e);
  let s = 1 - r[2], i, o, a;
  do
    i = Qc(r[0], r[1], s), o = fs(i[0], i[1], i[2]), a = ua(o, th), s += 0.01;
  while (s <= 1 && s >= 0 && Math.abs(a - n) < 0.01);
  return i;
}
function aR(e) {
  return Bl(nh($l(e)));
}
var gt = [
  [0.333, -0.667, -0.667, 0, 1],
  [-0.667, 0.333, -0.667, 0, 1],
  [-0.667, -0.667, 0.333, 0, 1],
  [0, 0, 0, 1, 0]
];
function rh(e) {
  const t = e[0], n = e[1], r = e[2];
  let s = [
    gt[0][0] * t + gt[0][1] * n + gt[0][2] * r + gt[0][4],
    gt[1][0] * t + gt[1][1] * n + gt[1][2] * r + gt[1][4],
    gt[2][0] * t + gt[2][1] * n + gt[2][2] * r + gt[2][4]
  ];
  return s = s.map((i) => i > 1 ? 1 : i < 0 ? 0 : i), s;
}
function lR(e) {
  return Bl(rh($l(e)));
}
var jl = typeof global == "object" && global && global.Object === Object && global;
var sh = typeof self == "object" && self && self.Object === Object && self;
var Rn = jl || sh || Function("return this")();
var $n = Rn.Symbol;
var Wl = Object.prototype;
var ih = Wl.hasOwnProperty;
var oh = Wl.toString;
var Jn = $n ? $n.toStringTag : void 0;
function ah(e) {
  var t = ih.call(e, Jn), n = e[Jn];
  try {
    e[Jn] = void 0;
    var r = true;
  } catch (e2) {
  }
  var s = oh.call(e);
  return r && (t ? e[Jn] = n : delete e[Jn]), s;
}
var lh = Object.prototype;
var uh = lh.toString;
function ch(e) {
  return uh.call(e);
}
var hh = "[object Null]";
var dh = "[object Undefined]";
var ca = $n ? $n.toStringTag : void 0;
function Nr(e) {
  return e == null ? e === void 0 ? dh : hh : ca && ca in Object(e) ? ah(e) : ch(e);
}
function Vn(e) {
  return e != null && typeof e == "object";
}
var fh = "[object Symbol]";
function bs(e) {
  return typeof e == "symbol" || Vn(e) && Nr(e) == fh;
}
function mh(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, s = Array(r); ++n < r; )
    s[n] = t(e[n], n, e);
  return s;
}
var Bn = Array.isArray;
var ha = $n ? $n.prototype : void 0;
var da = ha ? ha.toString : void 0;
function Yl(e) {
  if (typeof e == "string")
    return e;
  if (Bn(e))
    return mh(e, Yl) + "";
  if (bs(e))
    return da ? da.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
var gh = /\s/;
function _h(e) {
  for (var t = e.length; t-- && gh.test(e.charAt(t)); )
    ;
  return t;
}
var ph = /^\s+/;
function Eh(e) {
  return e && e.slice(0, _h(e) + 1).replace(ph, "");
}
function Rt(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var fa = NaN;
var Ch = /^[-+]0x[0-9a-f]+$/i;
var Rh = /^0b[01]+$/i;
var Ih = /^0o[0-7]+$/i;
var wh = parseInt;
function ma(e) {
  if (typeof e == "number")
    return e;
  if (bs(e))
    return fa;
  if (Rt(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Rt(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = Eh(e);
  var n = Rh.test(e);
  return n || Ih.test(e) ? wh(e.slice(2), n ? 2 : 8) : Ch.test(e) ? fa : +e;
}
function zl(e) {
  return e;
}
var Sh = "[object AsyncFunction]";
var Oh = "[object Function]";
var vh = "[object GeneratorFunction]";
var bh = "[object Proxy]";
function ro(e) {
  if (!Rt(e))
    return false;
  var t = Nr(e);
  return t == Oh || t == vh || t == Sh || t == bh;
}
var Xs = Rn["__core-js_shared__"];
var ga = function() {
  var e = /[^.]+$/.exec(Xs && Xs.keys && Xs.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function Ah(e) {
  return !!ga && ga in e;
}
var yh = Function.prototype;
var Nh = yh.toString;
function Th(e) {
  if (e != null) {
    try {
      return Nh.call(e);
    } catch (e2) {
    }
    try {
      return e + "";
    } catch (e2) {
    }
  }
  return "";
}
var Mh = /[\\^$.*+?()[\]{}|]/g;
var xh = /^\[object .+?Constructor\]$/;
var Lh = Function.prototype;
var Dh = Object.prototype;
var Uh = Lh.toString;
var Ph = Dh.hasOwnProperty;
var kh = RegExp(
  "^" + Uh.call(Ph).replace(Mh, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Fh(e) {
  if (!Rt(e) || Ah(e))
    return false;
  var t = ro(e) ? kh : xh;
  return t.test(Th(e));
}
function Hh(e, t) {
  return e == null ? void 0 : e[t];
}
function so(e, t) {
  var n = Hh(e, t);
  return Fh(n) ? n : void 0;
}
var _a = Object.create;
var $h = /* @__PURE__ */ function() {
  function e() {
  }
  return function(t) {
    if (!Rt(t))
      return {};
    if (_a)
      return _a(t);
    e.prototype = t;
    var n = new e();
    return e.prototype = void 0, n;
  };
}();
function Bh(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
function jh(e, t) {
  var n = -1, r = e.length;
  for (t || (t = Array(r)); ++n < r; )
    t[n] = e[n];
  return t;
}
var Wh = 800;
var Yh = 16;
var zh = Date.now;
function Vh(e) {
  var t = 0, n = 0;
  return function() {
    var r = zh(), s = Yh - (r - n);
    if (n = r, s > 0) {
      if (++t >= Wh)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
function Gh(e) {
  return function() {
    return e;
  };
}
var ms = function() {
  try {
    var e = so(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch (e2) {
  }
}();
var Kh = ms ? function(e, t) {
  return ms(e, "toString", {
    configurable: true,
    enumerable: false,
    value: Gh(t),
    writable: true
  });
} : zl;
var Xh = Vh(Kh);
var qh = 9007199254740991;
var Jh = /^(?:0|[1-9]\d*)$/;
function io(e, t) {
  var n = typeof e;
  return t = t == null ? qh : t, !!t && (n == "number" || n != "symbol" && Jh.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
function oo(e, t, n) {
  t == "__proto__" && ms ? ms(e, t, {
    configurable: true,
    enumerable: true,
    value: n,
    writable: true
  }) : e[t] = n;
}
function As(e, t) {
  return e === t || e !== e && t !== t;
}
var Zh = Object.prototype;
var Qh = Zh.hasOwnProperty;
function Vl(e, t, n) {
  var r = e[t];
  (!(Qh.call(e, t) && As(r, n)) || n === void 0 && !(t in e)) && oo(e, t, n);
}
function ed(e, t, n, r) {
  var s = !n;
  n || (n = {});
  for (var i = -1, o = t.length; ++i < o; ) {
    var a = t[i], l = void 0;
    l === void 0 && (l = e[a]), s ? oo(n, a, l) : Vl(n, a, l);
  }
  return n;
}
var pa = Math.max;
function td(e, t, n) {
  return t = pa(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var r = arguments, s = -1, i = pa(r.length - t, 0), o = Array(i); ++s < i; )
      o[s] = r[t + s];
    s = -1;
    for (var a = Array(t + 1); ++s < t; )
      a[s] = r[s];
    return a[t] = n(o), Bh(e, this, a);
  };
}
function nd(e, t) {
  return Xh(td(e, t, zl), e + "");
}
var rd = 9007199254740991;
function Gl(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= rd;
}
function ao(e) {
  return e != null && Gl(e.length) && !ro(e);
}
function sd(e, t, n) {
  if (!Rt(n))
    return false;
  var r = typeof t;
  return (r == "number" ? ao(n) && io(t, n.length) : r == "string" && t in n) ? As(n[t], e) : false;
}
function Kl(e) {
  return nd(function(t, n) {
    var r = -1, s = n.length, i = s > 1 ? n[s - 1] : void 0, o = s > 2 ? n[2] : void 0;
    for (i = e.length > 3 && typeof i == "function" ? (s--, i) : void 0, o && sd(n[0], n[1], o) && (i = s < 3 ? void 0 : i, s = 1), t = Object(t); ++r < s; ) {
      var a = n[r];
      a && e(t, a, r, i);
    }
    return t;
  });
}
var id = Object.prototype;
function Xl(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || id;
  return e === n;
}
function od(e, t) {
  for (var n = -1, r = Array(e); ++n < e; )
    r[n] = t(n);
  return r;
}
var ad = "[object Arguments]";
function Ea(e) {
  return Vn(e) && Nr(e) == ad;
}
var ql = Object.prototype;
var ld = ql.hasOwnProperty;
var ud = ql.propertyIsEnumerable;
var Ri = Ea(/* @__PURE__ */ function() {
  return arguments;
}()) ? Ea : function(e) {
  return Vn(e) && ld.call(e, "callee") && !ud.call(e, "callee");
};
function cd() {
  return false;
}
var Jl = typeof exports == "object" && exports && !exports.nodeType && exports;
var Ca = Jl && typeof module == "object" && module && !module.nodeType && module;
var hd = Ca && Ca.exports === Jl;
var Ra = hd ? Rn.Buffer : void 0;
var dd = Ra ? Ra.isBuffer : void 0;
var Zl = dd || cd;
var fd = "[object Arguments]";
var md = "[object Array]";
var gd = "[object Boolean]";
var _d = "[object Date]";
var pd = "[object Error]";
var Ed = "[object Function]";
var Cd = "[object Map]";
var Rd = "[object Number]";
var Id = "[object Object]";
var wd = "[object RegExp]";
var Sd = "[object Set]";
var Od = "[object String]";
var vd = "[object WeakMap]";
var bd = "[object ArrayBuffer]";
var Ad = "[object DataView]";
var yd = "[object Float32Array]";
var Nd = "[object Float64Array]";
var Td = "[object Int8Array]";
var Md = "[object Int16Array]";
var xd = "[object Int32Array]";
var Ld = "[object Uint8Array]";
var Dd = "[object Uint8ClampedArray]";
var Ud = "[object Uint16Array]";
var Pd = "[object Uint32Array]";
var Ue = {};
Ue[yd] = Ue[Nd] = Ue[Td] = Ue[Md] = Ue[xd] = Ue[Ld] = Ue[Dd] = Ue[Ud] = Ue[Pd] = true;
Ue[fd] = Ue[md] = Ue[bd] = Ue[gd] = Ue[Ad] = Ue[_d] = Ue[pd] = Ue[Ed] = Ue[Cd] = Ue[Rd] = Ue[Id] = Ue[wd] = Ue[Sd] = Ue[Od] = Ue[vd] = false;
function kd(e) {
  return Vn(e) && Gl(e.length) && !!Ue[Nr(e)];
}
function Fd(e) {
  return function(t) {
    return e(t);
  };
}
var Ql = typeof exports == "object" && exports && !exports.nodeType && exports;
var pr = Ql && typeof module == "object" && module && !module.nodeType && module;
var Hd = pr && pr.exports === Ql;
var qs = Hd && jl.process;
var Ia = function() {
  try {
    var e = pr && pr.require && pr.require("util").types;
    return e || qs && qs.binding && qs.binding("util");
  } catch (e2) {
  }
}();
var wa = Ia && Ia.isTypedArray;
var eu = wa ? Fd(wa) : kd;
function $d(e, t) {
  var n = Bn(e), r = !n && Ri(e), s = !n && !r && Zl(e), i = !n && !r && !s && eu(e), o = n || r || s || i, a = o ? od(e.length, String) : [], l = a.length;
  for (var u in e)
    o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    s && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    i && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
    io(u, l)) || a.push(u);
  return a;
}
function Bd(e, t) {
  return function(n) {
    return e(t(n));
  };
}
function jd(e) {
  var t = [];
  if (e != null)
    for (var n in Object(e))
      t.push(n);
  return t;
}
var Wd = Object.prototype;
var Yd = Wd.hasOwnProperty;
function zd(e) {
  if (!Rt(e))
    return jd(e);
  var t = Xl(e), n = [];
  for (var r in e)
    r == "constructor" && (t || !Yd.call(e, r)) || n.push(r);
  return n;
}
function tu(e) {
  return ao(e) ? $d(e) : zd(e);
}
var Vd = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var Gd = /^\w*$/;
function Kd(e, t) {
  if (Bn(e))
    return false;
  var n = typeof e;
  return n == "number" || n == "symbol" || n == "boolean" || e == null || bs(e) ? true : Gd.test(e) || !Vd.test(e) || t != null && e in Object(t);
}
var wr = so(Object, "create");
function Xd() {
  this.__data__ = wr ? wr(null) : {}, this.size = 0;
}
function qd(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var Jd = "__lodash_hash_undefined__";
var Zd = Object.prototype;
var Qd = Zd.hasOwnProperty;
function ef(e) {
  var t = this.__data__;
  if (wr) {
    var n = t[e];
    return n === Jd ? void 0 : n;
  }
  return Qd.call(t, e) ? t[e] : void 0;
}
var tf = Object.prototype;
var nf = tf.hasOwnProperty;
function rf(e) {
  var t = this.__data__;
  return wr ? t[e] !== void 0 : nf.call(t, e);
}
var sf = "__lodash_hash_undefined__";
function of2(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = wr && t === void 0 ? sf : t, this;
}
function pn(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
pn.prototype.clear = Xd;
pn.prototype.delete = qd;
pn.prototype.get = ef;
pn.prototype.has = rf;
pn.prototype.set = of2;
function af() {
  this.__data__ = [], this.size = 0;
}
function ys(e, t) {
  for (var n = e.length; n--; )
    if (As(e[n][0], t))
      return n;
  return -1;
}
var lf = Array.prototype;
var uf = lf.splice;
function cf(e) {
  var t = this.__data__, n = ys(t, e);
  if (n < 0)
    return false;
  var r = t.length - 1;
  return n == r ? t.pop() : uf.call(t, n, 1), --this.size, true;
}
function hf(e) {
  var t = this.__data__, n = ys(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function df(e) {
  return ys(this.__data__, e) > -1;
}
function ff(e, t) {
  var n = this.__data__, r = ys(n, e);
  return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this;
}
function Gt(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Gt.prototype.clear = af;
Gt.prototype.delete = cf;
Gt.prototype.get = hf;
Gt.prototype.has = df;
Gt.prototype.set = ff;
var nu = so(Rn, "Map");
function mf() {
  this.size = 0, this.__data__ = {
    hash: new pn(),
    map: new (nu || Gt)(),
    string: new pn()
  };
}
function gf(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function Ns(e, t) {
  var n = e.__data__;
  return gf(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function _f(e) {
  var t = Ns(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function pf(e) {
  return Ns(this, e).get(e);
}
function Ef(e) {
  return Ns(this, e).has(e);
}
function Cf(e, t) {
  var n = Ns(this, e), r = n.size;
  return n.set(e, t), this.size += n.size == r ? 0 : 1, this;
}
function tn(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
tn.prototype.clear = mf;
tn.prototype.delete = _f;
tn.prototype.get = pf;
tn.prototype.has = Ef;
tn.prototype.set = Cf;
var Rf = "Expected a function";
function lo(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(Rf);
  var n = function() {
    var r = arguments, s = t ? t.apply(this, r) : r[0], i = n.cache;
    if (i.has(s))
      return i.get(s);
    var o = e.apply(this, r);
    return n.cache = i.set(s, o) || i, o;
  };
  return n.cache = new (lo.Cache || tn)(), n;
}
lo.Cache = tn;
var If = 500;
function wf(e) {
  var t = lo(e, function(r) {
    return n.size === If && n.clear(), r;
  }), n = t.cache;
  return t;
}
var Sf = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var Of = /\\(\\)?/g;
var vf = wf(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(Sf, function(n, r, s, i) {
    t.push(s ? i.replace(Of, "$1") : r || n);
  }), t;
});
function bf(e) {
  return e == null ? "" : Yl(e);
}
function ru(e, t) {
  return Bn(e) ? e : Kd(e, t) ? [e] : vf(bf(e));
}
function su(e) {
  if (typeof e == "string" || bs(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
function Af(e, t) {
  t = ru(t, e);
  for (var n = 0, r = t.length; e != null && n < r; )
    e = e[su(t[n++])];
  return n && n == r ? e : void 0;
}
function yf(e, t, n) {
  var r = e == null ? void 0 : Af(e, t);
  return r === void 0 ? n : r;
}
var iu = Bd(Object.getPrototypeOf, Object);
var Nf = "[object Object]";
var Tf = Function.prototype;
var Mf = Object.prototype;
var ou = Tf.toString;
var xf = Mf.hasOwnProperty;
var Lf = ou.call(Object);
function Df(e) {
  if (!Vn(e) || Nr(e) != Nf)
    return false;
  var t = iu(e);
  if (t === null)
    return true;
  var n = xf.call(t, "constructor") && t.constructor;
  return typeof n == "function" && n instanceof n && ou.call(n) == Lf;
}
function Uf() {
  this.__data__ = new Gt(), this.size = 0;
}
function Pf(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
function kf(e) {
  return this.__data__.get(e);
}
function Ff(e) {
  return this.__data__.has(e);
}
var Hf = 200;
function $f(e, t) {
  var n = this.__data__;
  if (n instanceof Gt) {
    var r = n.__data__;
    if (!nu || r.length < Hf - 1)
      return r.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new tn(r);
  }
  return n.set(e, t), this.size = n.size, this;
}
function Gn(e) {
  var t = this.__data__ = new Gt(e);
  this.size = t.size;
}
Gn.prototype.clear = Uf;
Gn.prototype.delete = Pf;
Gn.prototype.get = kf;
Gn.prototype.has = Ff;
Gn.prototype.set = $f;
var au = typeof exports == "object" && exports && !exports.nodeType && exports;
var Sa = au && typeof module == "object" && module && !module.nodeType && module;
var Bf = Sa && Sa.exports === au;
var Oa = Bf ? Rn.Buffer : void 0;
Oa && Oa.allocUnsafe;
function jf(e, t) {
  return e.slice();
}
var va = Rn.Uint8Array;
function Wf(e) {
  var t = new e.constructor(e.byteLength);
  return new va(t).set(new va(e)), t;
}
function Yf(e, t) {
  var n = Wf(e.buffer);
  return new e.constructor(n, e.byteOffset, e.length);
}
function zf(e) {
  return typeof e.constructor == "function" && !Xl(e) ? $h(iu(e)) : {};
}
function Vf(e) {
  return function(t, n, r) {
    for (var s = -1, i = Object(t), o = r(t), a = o.length; a--; ) {
      var l = o[++s];
      if (n(i[l], l, i) === false)
        break;
    }
    return t;
  };
}
var Gf = Vf();
var Js = function() {
  return Rn.Date.now();
};
var Kf = "Expected a function";
var Xf = Math.max;
var qf = Math.min;
function uR(e, t, n) {
  var r, s, i, o, a, l, u = 0, c = false, h = false, d = true;
  if (typeof e != "function")
    throw new TypeError(Kf);
  t = ma(t) || 0, Rt(n) && (c = !!n.leading, h = "maxWait" in n, i = h ? Xf(ma(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function f(C) {
    var v = r, y = s;
    return r = s = void 0, u = C, o = e.apply(y, v), o;
  }
  function g(C) {
    return u = C, a = setTimeout(b, t), c ? f(C) : o;
  }
  function _(C) {
    var v = C - l, y = C - u, F2 = t - v;
    return h ? qf(F2, i - y) : F2;
  }
  function R(C) {
    var v = C - l, y = C - u;
    return l === void 0 || v >= t || v < 0 || h && y >= i;
  }
  function b() {
    var C = Js();
    if (R(C))
      return $(C);
    a = setTimeout(b, _(C));
  }
  function $(C) {
    return a = void 0, d && r ? f(C) : (r = s = void 0, o);
  }
  function k() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = s = a = void 0;
  }
  function W() {
    return a === void 0 ? o : $(Js());
  }
  function w() {
    var C = Js(), v = R(C);
    if (r = arguments, s = this, l = C, v) {
      if (a === void 0)
        return g(l);
      if (h)
        return clearTimeout(a), a = setTimeout(b, t), f(l);
    }
    return a === void 0 && (a = setTimeout(b, t)), o;
  }
  return w.cancel = k, w.flush = W, w;
}
function Ii(e, t, n) {
  (n !== void 0 && !As(e[t], n) || n === void 0 && !(t in e)) && oo(e, t, n);
}
function Jf(e) {
  return Vn(e) && ao(e);
}
function wi(e, t) {
  if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
    return e[t];
}
function Zf(e) {
  return ed(e, tu(e));
}
function Qf(e, t, n, r, s, i, o) {
  var a = wi(e, n), l = wi(t, n), u = o.get(l);
  if (u) {
    Ii(e, n, u);
    return;
  }
  var c = i ? i(a, l, n + "", e, t, o) : void 0, h = c === void 0;
  if (h) {
    var d = Bn(l), f = !d && Zl(l), g = !d && !f && eu(l);
    c = l, d || f || g ? Bn(a) ? c = a : Jf(a) ? c = jh(a) : f ? (h = false, c = jf(l)) : g ? (h = false, c = Yf(l)) : c = [] : Df(l) || Ri(l) ? (c = a, Ri(a) ? c = Zf(a) : (!Rt(a) || ro(a)) && (c = zf(l))) : h = false;
  }
  h && (o.set(l, c), s(c, l, r, i, o), o.delete(l)), Ii(e, n, c);
}
function uo(e, t, n, r, s) {
  e !== t && Gf(t, function(i, o) {
    if (s || (s = new Gn()), Rt(i))
      Qf(e, t, o, n, uo, r, s);
    else {
      var a = r ? r(wi(e, o), i, o + "", e, t, s) : void 0;
      a === void 0 && (a = i), Ii(e, o, a);
    }
  }, tu);
}
var cR = Kl(function(e, t, n, r) {
  uo(e, t, n, r);
});
var co = Kl(function(e, t, n) {
  uo(e, t, n);
});
function em(e, t, n, r) {
  if (!Rt(e))
    return e;
  t = ru(t, e);
  for (var s = -1, i = t.length, o = i - 1, a = e; a != null && ++s < i; ) {
    var l = su(t[s]), u = n;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return e;
    if (s != o) {
      var c = a[l];
      u = void 0, u === void 0 && (u = Rt(c) ? c : io(t[s + 1]) ? [] : {});
    }
    Vl(a, l, u), a = a[l];
  }
  return e;
}
function hR(e, t, n) {
  return e == null ? e : em(e, t, n);
}
var Kn = class {
  constructor() {
    p(this, "cursor", 0);
  }
  reset() {
    return this.cursor = 0, this;
  }
  moveCursor(t) {
    this.cursor += t;
  }
  moveCursorTo(t) {
    this.cursor = t;
  }
};
function dR(e, t) {
  for (const n in t)
    t.hasOwnProperty(n) && (e[n] = t[n]);
}
function tm(e) {
  return /^-?\d+(\.\d+)?$/.test(e);
}
function fR(e) {
  return tm(e) ? Number(e) <= Number.MAX_SAFE_INTEGER : false;
}
function mR(e) {
  return Number(e) > Number.MAX_SAFE_INTEGER || e.length >= 18;
}
var lu = class _lu {
  constructor() {
    p(this, "_data", []);
  }
  static create() {
    return new _lu();
  }
  add(t) {
    this._data.indexOf(t) > -1 || this._data.push(t);
  }
  delete(t) {
    const n = this._data.indexOf(t);
    this._data.splice(n, 1);
  }
  getData() {
    return this._data;
  }
};
var uu = class _uu {
  constructor() {
    p(this, "_data", /* @__PURE__ */ new Map());
  }
  static create() {
    return new _uu();
  }
  add(t, n) {
    this._data.has(t) || this._data.set(t, n);
  }
  delete(t) {
    this._data.delete(t);
  }
  getData() {
    return this._data;
  }
};
function gR(e) {
  const t = new MessageChannel();
  let n = false;
  const r = () => {
    n || e();
  };
  return t.port1.onmessage = r, t.port2.postMessage(null), () => {
    n = true, t.port1.onmessage = null, t.port1.close(), t.port2.close();
  };
}
function nm(e) {
  return __async(this, null, function* () {
    for (const [t, n] of e.entries())
      try {
        if (!(yield n()))
          return {
            index: t,
            result: false
          };
      } catch (r) {
        return {
          index: t,
          result: false,
          error: r
        };
      }
    return {
      result: true,
      index: -1
    };
  });
}
function rm(e) {
  for (const [t, n] of e.entries())
    try {
      if (!n())
        return {
          index: t,
          result: false
        };
    } catch (r) {
      return {
        index: t,
        result: false,
        error: r
      };
    }
  return {
    result: true,
    index: -1
  };
}
function _R(e, t) {
  return t.forEach((n) => e.add(n)), e;
}
function sm(e) {
  return e instanceof Subscription || e instanceof Subject || e && "closed" in e && typeof e.unsubscribe < "u";
}
function Be(e) {
  let t = false;
  return e ? sm(e) ? {
    dispose: () => e.unsubscribe()
  } : typeof e == "function" ? {
    dispose: () => {
      t || (t = true, e());
    }
  } : e : Be(() => {
  });
}
function pR(e) {
  return Be(() => {
    e.unsubscribe();
  });
}
var ho = class {
  constructor() {
    p(this, "_disposables", /* @__PURE__ */ new Set());
  }
  add(t) {
    const n = Be(t);
    return this._disposables.add(n), {
      dispose: (r = false) => {
        r || n.dispose(), this._disposables.delete(n);
      }
    };
  }
  dispose() {
    this._disposables.forEach((t) => {
      t.dispose();
    }), this._disposables.clear();
  }
};
var Ve = class {
  constructor() {
    p(this, "_disposed", false);
    p(this, "_collection", new ho());
  }
  disposeWithMe(t) {
    return this._collection.add(t);
  }
  ensureNotDisposed() {
    if (this._disposed)
      throw new Error("[Disposable]: object is disposed!");
  }
  dispose() {
    this._disposed || (this._disposed = true, this._collection.dispose());
  }
};
var ER = class extends Ve {
  constructor() {
    super(...arguments);
    p(this, "dispose$", new Subject());
  }
  dispose() {
    super.dispose(), this.dispose$.next(), this.dispose$.complete();
  }
};
var CR = class extends Ve {
  constructor(n) {
    super();
    p(this, "_ref", 0);
    this._rootDisposable = n;
  }
  inc() {
    if (this._disposed)
      throw new Error("[RCDisposable]: should not ref to a disposed.");
    this._ref += 1;
  }
  dec() {
    this._ref -= 1, this._ref === 0 && (this._rootDisposable.dispose(), this.dispose());
  }
};
var we = ((e) => (e[e.UNIVER_UNKNOWN = 0] = "UNIVER_UNKNOWN", e[e.UNIVER_DOC = 1] = "UNIVER_DOC", e[e.UNIVER_SHEET = 2] = "UNIVER_SHEET", e[e.UNIVER_SLIDE = 3] = "UNIVER_SLIDE", e[e.UNIVER_PROJECT = 4] = "UNIVER_PROJECT", e[e.UNRECOGNIZED = -1] = "UNRECOGNIZED", e))(we || {});
var Dt = ((e) => (e[e.Reader = 0] = "Reader", e[e.Editor = 1] = "Editor", e[e.Owner = 2] = "Owner", e[e.UNRECOGNIZED = -1] = "UNRECOGNIZED", e))(Dt || {});
var Si = ((e) => (e[e.SomeCollaborator = 0] = "SomeCollaborator", e[e.AllCollaborator = 1] = "AllCollaborator", e[e.OneSelf = 2] = "OneSelf", e[e.UNRECOGNIZED = -1] = "UNRECOGNIZED", e))(Si || {});
var fo = class extends Ve {
};
var im = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
var om = (e) => crypto.getRandomValues(new Uint8Array(e));
var am = (e, t, n) => {
  let r = (2 << Math.log2(e.length - 1)) - 1, s = -~(1.6 * r * t / e.length);
  return (i = t) => {
    let o = "";
    for (; ; ) {
      let a = n(s), l = s | 0;
      for (; l--; )
        if (o += e[a[l] & r] || "", o.length >= i) return o;
    }
  };
};
var lm = (e, t = 21) => am(e, t | 0, om);
var um = (e = 21) => {
  let t = "", n = crypto.getRandomValues(new Uint8Array(e |= 0));
  for (; e--; )
    t += im[n[e] & 63];
  return t;
};
var cu = /* @__PURE__ */ new Set([
  "ac",
  "ad",
  "ae",
  "aero",
  "af",
  "ag",
  "ai",
  "al",
  "am",
  "ao",
  "aq",
  "ar",
  "arpa",
  "as",
  "asia",
  "at",
  "au",
  "aw",
  "ax",
  "az",
  "ba",
  "bb",
  "bd",
  "be",
  "bf",
  "bg",
  "bh",
  "bi",
  "biz",
  "bj",
  "bm",
  "bn",
  "bo",
  "br",
  "bs",
  "bt",
  "bv",
  "bw",
  "by",
  "bz",
  "ca",
  "cat",
  "cc",
  "cd",
  "cf",
  "cg",
  "ch",
  "ci",
  "ck",
  "cl",
  "cm",
  "cn",
  "co",
  "com",
  "coop",
  "cr",
  "cu",
  "cv",
  "cw",
  "cx",
  "cy",
  "cz",
  "de",
  "dj",
  "dk",
  "dm",
  "do",
  "dz",
  "ec",
  "edu",
  "ee",
  "eg",
  "er",
  "es",
  "et",
  "eu",
  "fi",
  "fj",
  "fk",
  "fm",
  "fo",
  "fr",
  "ga",
  "gb",
  "gd",
  "ge",
  "gf",
  "gg",
  "gh",
  "gi",
  "gl",
  "gm",
  "gn",
  "gov",
  "gp",
  "gq",
  "gr",
  "gs",
  "gt",
  "gu",
  "gw",
  "gy",
  "hk",
  "hm",
  "hn",
  "hr",
  "ht",
  "hu",
  "id",
  "ie",
  "il",
  "im",
  "in",
  "info",
  "int",
  "io",
  "iq",
  "ir",
  "is",
  "it",
  "je",
  "jm",
  "jo",
  "jobs",
  "jp",
  "ke",
  "kg",
  "kh",
  "ki",
  "km",
  "kn",
  "kp",
  "kr",
  "kw",
  "ky",
  "kz",
  "la",
  "lb",
  "lc",
  "li",
  "lk",
  "lr",
  "ls",
  "lt",
  "lu",
  "lv",
  "ly",
  "ma",
  "mc",
  "md",
  "me",
  "mg",
  "mh",
  "mil",
  "mk",
  "ml",
  "mm",
  "mn",
  "mo",
  "mobi",
  "mp",
  "mq",
  "mr",
  "ms",
  "mt",
  "mu",
  "museum",
  "mv",
  "mw",
  "mx",
  "my",
  "mz",
  "na",
  "name",
  "nc",
  "ne",
  "net",
  "nf",
  "ng",
  "ni",
  "nl",
  "no",
  "np",
  "nr",
  "nu",
  "nz",
  "om",
  "onion",
  "org",
  "pa",
  "pe",
  "pf",
  "pg",
  "ph",
  "pk",
  "pl",
  "pm",
  "pn",
  "post",
  "pr",
  "pro",
  "ps",
  "pt",
  "pw",
  "py",
  "qa",
  "re",
  "ro",
  "rs",
  "ru",
  "rw",
  "sa",
  "sb",
  "sc",
  "sd",
  "se",
  "sg",
  "sh",
  "si",
  "sj",
  "sk",
  "sl",
  "sm",
  "sn",
  "so",
  "sr",
  "ss",
  "st",
  "su",
  "sv",
  "sx",
  "sy",
  "sz",
  "tc",
  "td",
  "tel",
  "tf",
  "tg",
  "th",
  "tj",
  "tk",
  "tl",
  "tm",
  "tn",
  "to",
  "tr",
  "tt",
  "tv",
  "tw",
  "tz",
  "ua",
  "ug",
  "uk",
  "us",
  "uy",
  "uz",
  "va",
  "vc",
  "ve",
  "vg",
  "vi",
  "vn",
  "vu",
  "wf",
  "ws",
  "yt",
  "za",
  "zm",
  "zw"
]);
var cm = new RegExp(
  "^(?:(?:(?:https?|ftp):)?\\/\\/)?(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff]\\.)+(?:[a-z\\u00a1-\\uffff]{2,}\\.?))(?::\\d{2,5})?(?:[/?#]\\S*)?$",
  "i"
);
function hm(e) {
  if (!Number.isNaN(+e))
    return false;
  if (e.startsWith("http://localhost:3002") || e.startsWith("localhost:3002"))
    return true;
  if (cm.test(e)) {
    if (hu(e))
      return true;
    try {
      const r = new URL(du(e)).hostname.split(".").pop();
      if (r && cu.has(r))
        return true;
    } catch (e2) {
      return false;
    }
  }
  return false;
}
function hu(e) {
  return /^[a-zA-Z]+:\/\//.test(e);
}
function dm(e) {
  return /^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/.test(e);
}
function du(e) {
  return hu(e) ? e : dm(e) ? `mailto://${e}` : `https://${e}`;
}
var qt = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z"
];
function mo(e, t) {
  const n = Z.getValueType(e), r = Z.getValueType(t);
  return n !== r ? false : Z.isArray(e) ? fm(e, t) : Z.isObject(e) ? mm(e, t) : Z.isDate(e) ? e.getTime() === t.getTime() : Z.isRegExp(e) ? e.toString() === t.toString() : e === t;
}
function fm(e, t) {
  if (e.length !== t.length)
    return false;
  for (let n = 0, r = e.length; n < r; n++) {
    const s = e[n], i = t[n];
    if (!mo(s, i))
      return false;
  }
  return true;
}
function mm(e, t) {
  const n = Object.keys(e), r = Object.keys(t);
  if (n.length !== r.length)
    return false;
  for (const s of n) {
    if (!r.includes(s))
      return false;
    const i = e[s], o = t[s];
    if (!mo(i, o))
      return false;
  }
  return true;
}
var Z = class _Z {
  static deleteNull(t) {
    for (const n in t)
      (t[n] === null || t[n] === void 0) && delete t[n];
    return t;
  }
  static stringAt(t) {
    let n = "", r = t;
    for (; r >= qt.length; )
      r /= qt.length, r -= 1, n += qt[r % qt.length];
    const s = t % qt.length;
    return n += qt[s], n;
  }
  static indexAt(t) {
    let n = 0;
    for (let r = 0; r < t.length - 1; r += 1) {
      const s = t.charCodeAt(r) - 65, i = t.length - 1 - r;
      n += __pow(qt.length, i) + qt.length * s;
    }
    return n += t.charCodeAt(t.length - 1) - 65, n;
  }
  static deleteBlank(t) {
    return _Z.isString(t) ? t.replace(/\s/g, "") : t;
  }
  // eslint-disable-next-line complexity
  static getSystemType() {
    const t = navigator.userAgent, n = navigator.platform === "Win32" || navigator.platform === "Windows", r = navigator.platform === "Mac68K" || navigator.platform === "MacPPC" || navigator.platform === "Macintosh" || navigator.platform === "MacIntel";
    if (r) return "Mac";
    if (navigator.platform === "X11" && !n && !r) return "Unix";
    if (String(navigator.platform).indexOf("Linux") > -1) return "Linux";
    if (n) {
      if (t.indexOf("Windows NT 5.0") > -1 || t.indexOf("Windows 2000") > -1) return "Windows 2000";
      if (t.indexOf("Windows NT 5.1") > -1 || t.indexOf("Windows XP") > -1) return "Windows XP";
      if (t.indexOf("Windows NT 5.2") > -1 || t.indexOf("Windows 2003") > -1) return "Windows 2003";
      if (t.indexOf("Windows NT 6.0") > -1 || t.indexOf("Windows Vista") > -1) return "Windows Vista";
      if (t.indexOf("Windows NT 6.1") > -1 || t.indexOf("Windows 7") > -1) return "Windows 7";
      if (t.indexOf("Windows NT 10") > -1 || t.indexOf("Windows 10") > -1) return "Windows 10";
      if (t.indexOf("Windows NT 11") > -1 || t.indexOf("Windows 11") > -1) return "Windows 11";
    }
    return "Unknown system";
  }
  static getBrowserType() {
    const t = navigator.userAgent, n = t.indexOf("Opera") > -1, r = t.indexOf("compatible") > -1 && t.indexOf("MSIE") > -1 && !n, s = t.indexOf("Trident") > -1 && t.indexOf("rv:11.0") > -1, i = t.indexOf("Edge") > -1, o = t.indexOf("Firefox") > -1, a = t.indexOf("Safari") > -1 && t.indexOf("Chrome") === -1, l = t.indexOf("Chrome") > -1 && t.indexOf("Safari") > -1;
    if (r) {
      new RegExp("MSIE (\\d+\\.\\d+);").test(t);
      const c = Number.parseFloat(RegExp.$1);
      return c === 7 ? "IE7" : c === 8 ? "IE8" : c === 9 ? "IE9" : c === 10 ? "IE10" : "0";
    }
    return o ? "FF" : n ? "Opera" : a ? "Safari" : l ? "Chrome" : i ? "Edge" : s ? "IE11" : "Unknown browser";
  }
  static getClassName(t) {
    return t.constructor.name;
  }
  /** @deprecated This method is deprecated, please use `import { merge } from '@univerjs/core` instead */
  static deepMerge(t, ...n) {
    n.forEach((o) => o && i(o));
    function r(o, a) {
      o.forEach((l, u) => {
        var c, h;
        if (_Z.isArray(l)) {
          const d = (c = a[u]) != null ? c : [];
          a[u] = d, r(l, d);
          return;
        }
        if (_Z.isObject(l)) {
          const d = (h = a[u]) != null ? h : {};
          a[u] = d, s(l, d);
          return;
        }
        a[u] = l;
      });
    }
    function s(o, a) {
      Object.keys(o).forEach((l) => {
        var c, h;
        const u = o[l];
        if (_Z.isObject(u)) {
          const d = (c = a[l]) != null ? c : {};
          a[l] = d, s(u, d);
          return;
        }
        if (_Z.isArray(u)) {
          const d = (h = a[l]) != null ? h : [];
          a[l] = d, r(u, d);
          return;
        }
        a[l] = u;
      });
    }
    function i(o) {
      Object.keys(o).forEach((a) => {
        var u, c;
        const l = o[a];
        if (_Z.isArray(l)) {
          const h = (u = t[a]) != null ? u : [];
          t[a] = h, r(l, h);
          return;
        }
        if (_Z.isObject(l)) {
          const h = (c = t[a]) != null ? c : {};
          t[a] = h, s(l, h);
          return;
        }
        t[a] = l;
      });
    }
    return t;
  }
  static numberFixed(t, n) {
    return Number(Number(t).toFixed(n));
  }
  static diffValue(t, n) {
    return mo(t, n);
  }
  static deepClone(t) {
    if (!this.isDefine(t))
      return t;
    if (this.isRegExp(t))
      return new RegExp(t);
    if (this.isDate(t))
      return new Date(t);
    if (this.isArray(t)) {
      const n = [];
      return t.forEach((r, s) => {
        n[s] = _Z.deepClone(r);
      }), n;
    }
    if (this.isObject(t)) {
      const n = {};
      return Object.keys(t).forEach((r) => {
        const s = t[r];
        n[r] = _Z.deepClone(s);
      }), Object.setPrototypeOf(n, Object.getPrototypeOf(t)), n;
    }
    return t;
  }
  static getLanguage() {
    const t = "en-US";
    return globalThis.navigator && (navigator.languages && navigator.languages[0] || navigator.language) || t;
  }
  static getValueType(t) {
    return Object.prototype.toString.apply(t);
  }
  static isDefine(t) {
    return t != null;
  }
  static isBlank(t) {
    return this.isDefine(t) ? this.isString(t) ? t.trim() === "" : false : true;
  }
  static isPlainObject(t) {
    return this.isDefine(t) ? Object.getPrototypeOf(t) === Object.getPrototypeOf({}) : false;
  }
  static isDate(t) {
    return this.getValueType(t) === "[object Date]";
  }
  static isRegExp(t) {
    return this.getValueType(t) === "[object RegExp]";
  }
  static isArray(t) {
    return this.getValueType(t) === "[object Array]";
  }
  static isString(t) {
    return this.getValueType(t) === "[object String]";
  }
  static isNumber(t) {
    return this.getValueType(t) === "[object Number]";
  }
  static isStringNumber(t) {
    return !isNaN(Number.parseFloat(t)) && isFinite(t);
  }
  static isObject(t) {
    return this.getValueType(t) === "[object Object]";
  }
  static isEmptyObject(t) {
    for (const n in t)
      return false;
    return true;
  }
  static isTablet() {
    return /ipad|android|android 3.0|xoom|sch-i800|playbook|tablet|kindle/i.test(navigator.userAgent.toLowerCase());
  }
  static isIPhone() {
    return /iPhone/i.test(navigator.userAgent);
  }
  static isLegalUrl(t) {
    return hm(t);
  }
  static normalizeUrl(t) {
    return du(t);
  }
  static topLevelDomainCombiningString() {
    return [...cu].join("|");
  }
  /**
   * remove all null from object
   * @param obj
   * @returns
   */
  static removeNull(t) {
    return this.isObject(t) && Object.keys(t).forEach((n) => {
      const r = t[n];
      r == null ? delete t[n] : _Z.removeNull(r);
    }), t;
  }
  /**
   * Generate a two-dimensional array with the specified number of rows and columns, and fill in the values
   * @param rows row length
   * @param columns column length
   * @param value value to be set
   * @returns
   */
  static fillTwoDimensionalArray(t, n, r) {
    return new Array(t).fill(r).map((s) => new Array(n).fill(r));
  }
  /**
   * Generate a two-dimensional array with the specified number of rows and columns, and fill in the values
   * @param rows row length
   * @param columns column length
   * @param value value to be set
   * @returns
   */
  // static fillObjectMatrix<T>(rows: number, columns: number, value: T): IObjectMatrixPrimitiveType<T> {
  //     const matrix = new ObjectMatrix<T>();
  //     for (let r = 0; r < rows; r++) {
  //         for (let c = 0; c < columns; c++) {
  //             matrix.setValue(r, c, value);
  //         }
  //     }
  //     return matrix.getData();
  // }
  static numToWord(t) {
    let n = "";
    for (; t > 0; ) {
      let r = t % 26;
      r = r === 0 ? r = 26 : r, n = String.fromCharCode(96 + r) + n, t = (t - r) / 26;
    }
    return n.toLocaleUpperCase();
  }
  /**
   * Column subscript letter to number
   *
   * @param a - Column subscript letter,e.g.,"A1"
   * @returns Column subscript number,e.g.,0
   *
   */
  static ABCatNum(t) {
    if (t == null || t.length === 0)
      return Number.NaN;
    const n = t.toLowerCase().split(""), r = n.length;
    let s = 0, i = 0;
    for (let o = 0; o < r; o++)
      i = n[o].charCodeAt(0) - 96, s += i * __pow(26, r - o - 1);
    return s === 0 ? Number.NaN : s - 1;
  }
  /**
   * Column subscript number to letter
   *
   * @param n Column subscript number,e.g.,0
   * @returns Column subscript letter,e.g.,"A1"
   */
  static chatAtABC(t) {
    let i = "";
    for (; t >= 0; )
      i = String.fromCharCode(t % 26 + 97) + i, t = Math.floor(t / 26) - 1;
    return i.toUpperCase();
  }
  /**
   * extend two objects
   * @param originJson
   * @param extendJson
   * @returns
   */
  static commonExtend(t, n) {
    const r = {};
    for (const s in t)
      r[s] = t[s];
    for (const s in n)
      n[s] != null && (r[s] = n[s]);
    return r;
  }
  static hasIntersectionBetweenTwoRanges(t, n, r, s) {
    return n >= r && s >= t;
  }
  static isStartValidPosition(t) {
    return /^[A-Za-z--_]/.test(t);
  }
  static isValidParameter(t) {
    const n = /[~!@#$%^&*()+=\-{}\[\]\|:;"'<>,?\/ ]+/.test(t), r = t.length <= 255;
    return !n && r;
  }
  static clamp(t, n, r) {
    return Math.max(n, Math.min(r, t));
  }
  static now() {
    return performance && performance.now ? performance.now() : Date.now();
  }
};
function et(e = 21, t) {
  return t ? lm(t, e)() : um(e);
}
function Dr(...e) {
  const t = {}, n = e.length;
  for (let r = n - 1; r >= 0; r--) {
    const s = e[r];
    if (s) {
      const i = Object.keys(s);
      for (const o of i)
        t[o] === void 0 && (t[o] = s[o]);
    }
  }
  return t;
}
var RR = () => typeof process < "u" && process.versions != null && process.versions.node != null;
function IR(e) {
  const n = e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/\\\*/g, ".*").replace(/\\\?/g, ".");
  return new RegExp(`^${n}$`, "i");
}
var gm = ((e) => (e[e.DEFAULT_SERIES = 0] = "DEFAULT_SERIES", e[e.ALTERNATE_SERIES = 1] = "ALTERNATE_SERIES", e))(gm || {});
var xe = ((e) => (e[e.NONE = 0] = "NONE", e[e.THIN = 1] = "THIN", e[e.HAIR = 2] = "HAIR", e[e.DOTTED = 3] = "DOTTED", e[e.DASHED = 4] = "DASHED", e[e.DASH_DOT = 5] = "DASH_DOT", e[e.DASH_DOT_DOT = 6] = "DASH_DOT_DOT", e[e.DOUBLE = 7] = "DOUBLE", e[e.MEDIUM = 8] = "MEDIUM", e[e.MEDIUM_DASHED = 9] = "MEDIUM_DASHED", e[e.MEDIUM_DASH_DOT = 10] = "MEDIUM_DASH_DOT", e[e.MEDIUM_DASH_DOT_DOT = 11] = "MEDIUM_DASH_DOT_DOT", e[e.SLANT_DASH_DOT = 12] = "SLANT_DASH_DOT", e[e.THICK = 13] = "THICK", e))(xe || {});
var _m = ((e) => (e.TOP = "top", e.BOTTOM = "bottom", e.LEFT = "left", e.RIGHT = "right", e.NONE = "none", e.ALL = "all", e.OUTSIDE = "outside", e.INSIDE = "inside", e.HORIZONTAL = "horizontal", e.VERTICAL = "vertical", e.TLBR = "tlbr", e.TLBC_TLMR = "tlbc_tlmr", e.TLBR_TLBC_TLMR = "tlbr_tlbc_tlmr", e.BLTR = "bl_tr", e.MLTR_BCTR = "mltr_bctr", e))(_m || {});
var yt = ((e) => (e[e.UNSUPPORTED = 0] = "UNSUPPORTED", e[e.RGB = 1] = "RGB", e[e.HEX = 2] = "HEX", e[e.THEME = 3] = "THEME", e))(yt || {});
var pm = ((e) => (e[e.ON = 0] = "ON", e[e.OFF = 1] = "OFF", e))(pm || {});
var Em = ((e) => (e[e.PASTE_NORMAL = 0] = "PASTE_NORMAL", e[e.PASTE_NO_BORDERS = 1] = "PASTE_NO_BORDERS", e[e.PASTE_FORMAT = 2] = "PASTE_FORMAT", e[e.PASTE_FORMULA = 3] = "PASTE_FORMULA", e[e.PASTE_DATA_VALIDATION = 4] = "PASTE_DATA_VALIDATION", e[e.PASTE_VALUES = 5] = "PASTE_VALUES", e[e.PASTE_CONDITIONAL_FORMATTING = 6] = "PASTE_CONDITIONAL_FORMATTING", e[e.PASTE_COLUMN_WIDTHS = 7] = "PASTE_COLUMN_WIDTHS", e))(Em || {});
var Cm = ((e) => (e[e.LEFT = 0] = "LEFT", e[e.RIGHT = 1] = "RIGHT", e))(Cm || {});
var Rm = ((e) => (e[e.DOCUMENT = 0] = "DOCUMENT", e[e.PROJECT = 1] = "PROJECT", e))(Rm || {});
var Im = ((e) => (e[e.COLUMNS = 0] = "COLUMNS", e[e.ROWS = 1] = "ROWS", e))(Im || {});
var wm = ((e) => (e[e.UP = 0] = "UP", e[e.RIGHT = 1] = "RIGHT", e[e.DOWN = 2] = "DOWN", e[e.LEFT = 3] = "LEFT", e))(wm || {});
function wR(e) {
  switch (e) {
    case 3:
      return 1;
    case 1:
      return 3;
    case 0:
      return 2;
    case 2:
      return 0;
  }
}
var Sm = ((e) => (e[e.INTERPOLATION_POINT_TYPE_UNSPECIFIED = 0] = "INTERPOLATION_POINT_TYPE_UNSPECIFIED", e[e.MIN = 1] = "MIN", e[e.MAX = 2] = "MAX", e[e.NUMBER = 3] = "NUMBER", e[e.PERCENT = 4] = "PERCENT", e[e.PERCENTILE = 5] = "PERCENTILE", e))(Sm || {});
var Ts = ((e) => (e.EN_US = "enUS", e.FR_FR = "frFR", e.ZH_CN = "zhCN", e.RU_RU = "ruRU", e.ZH_TW = "zhTW", e.VI_VN = "viVN", e.FA_IR = "faIR", e.JA_JP = "jaJP", e.KO_KR = "koKR", e.ES_ES = "esES", e.CA_ES = "caES", e))(Ts || {});
var Oi = ((e) => (e[e.PERSON = 0] = "PERSON", e[e.FILE = 1] = "FILE", e[e.DATE = 2] = "DATE", e[e.LOCATION = 3] = "LOCATION", e[e.EVENT = 4] = "EVENT", e))(Oi || {});
var Om = ((e) => (e[e.RANGE = 0] = "RANGE", e[e.SHEET = 1] = "SHEET", e))(Om || {});
var vm = ((e) => (e.Line = "line", e.LineInv = "lineInv", e.Triangle = "triangle", e.RtTriangle = "rtTriangle", e.Rect = "rect", e.Diamond = "diamond", e.Parallelogram = "parallelogram", e.Trapezoid = "trapezoid", e.NonIsocelesTrapezoid = "nonIsocelesTrapezoid", e.Pentagon = "pentagon", e.Hexagon = "hexagon", e.Heptagon = "heptagon", e.Octagon = "octagon", e.Decagon = "decagon", e.Dodecagon = "dodecagon", e.Star4 = "star4", e.Star5 = "star5", e.Star6 = "star6", e.Star7 = "star7", e.Star8 = "star8", e.Star10 = "star10", e.Star12 = "star12", e.Star16 = "star16", e.Star24 = "star24", e.Star32 = "star32", e.RoundRect = "roundRect", e.Round1Rect = "round1Rect", e.Round2SameRect = "round2SameRect", e.Round2DiagRect = "round2DiagRect", e.Ellipse = "ellipse", e))(vm || {});
var bm = ((e) => (e.RightArrow = "rightArrow", e.LeftArrow = "leftArrow", e.UpArrow = "upArrow", e.DownArrow = "downArrow", e.LeftRightArrow = "leftRightArrow", e.UpDownArrow = "upDownArrow", e.QuadArrow = "quadArrow", e.LeftRightUpArrow = "leftRightUpArrow", e.BentArrow = "bentArrow", e.UturnArrow = "uturnArrow", e.CircularArrow = "circularArrow", e.NotchedRightArrow = "notchedRightArrow", e.HomePlate = "homePlate", e.Chevron = "chevron", e.LeftCircularArrow = "leftCircularArrow", e.LeftRightCircularArrow = "leftRightCircularArrow", e))(bm || {});
var Am = ((e) => (e.Plaque = "plaque", e.Can = "can", e.Cube = "cube", e.Bevel = "bevel", e.Donut = "donut", e.NoSmoking = "noSmoking", e.BlockArc = "blockArc", e.FoldedCorner = "foldedCorner", e))(Am || {});
var ym = ((e) => (e.SmileyFace = "smileyFace", e.Heart = "heart", e.LightningBolt = "lightningBolt", e.Sun = "sun", e.Moon = "moon", e.Cloud = "cloud", e.Arc = "arc", e.Backpack = "backpack", e.Frame = "frame", e.HalfFrame = "halfFrame", e.Corner = "corner", e.Chord = "chord", e.Pie = "pie", e.Teardrop = "teardrop", e.WedgeRectCallout = "wedgeRectCallout", e.WedgeRRectCallout = "wedgeRRectCallout", e.WedgeEllipseCallout = "wedgeEllipseCallout", e.CloudCallout = "cloudCallout", e.BorderCallout1 = "borderCallout1", e.BorderCallout2 = "borderCallout2", e.BorderCallout3 = "borderCallout3", e.AccentCallout1 = "accentCallout1", e.AccentCallout2 = "accentCallout2", e.AccentCallout3 = "accentCallout3", e.Callout1 = "callout1", e.Callout2 = "callout2", e.Callout3 = "callout3", e.ActionButtonBackPrevious = "actionButtonBackPrevious", e.ActionButtonEnd = "actionButtonEnd", e.ActionButtonForwardNext = "actionButtonForwardNext", e.ActionButtonHelp = "actionButtonHelp", e.ActionButtonHome = "actionButtonHome", e.ActionButtonInformation = "actionButtonInformation", e.ActionButtonMovie = "actionButtonMovie", e.ActionButtonReturn = "actionButtonReturn", e.ActionButtonSound = "actionButtonSound", e))(ym || {});
var Nm = ((e) => (e[e.RELATIVE_DATE_UNSPECIFIED = 0] = "RELATIVE_DATE_UNSPECIFIED", e[e.PAST_YEAR = 1] = "PAST_YEAR", e[e.PAST_MONTH = 2] = "PAST_MONTH", e[e.PAST_WEEK = 3] = "PAST_WEEK", e[e.YESTERDAY = 4] = "YESTERDAY", e[e.TODAY = 5] = "TODAY", e[e.TOMORROW = 6] = "TOMORROW", e))(Nm || {});
var Tm = ((e) => (e[e.GRID = 0] = "GRID", e[e.KANBAN = 1] = "KANBAN", e[e.GANTT = 2] = "GANTT", e))(Tm || {});
var gs = ((e) => (e[e.UNSPECIFIED = 0] = "UNSPECIFIED", e[e.LEFT_TO_RIGHT = 1] = "LEFT_TO_RIGHT", e[e.RIGHT_TO_LEFT = 2] = "RIGHT_TO_LEFT", e))(gs || {});
var Mm = ((e) => (e[e.DASH = 0] = "DASH", e[e.DASH_DOT_DOT_HEAVY = 1] = "DASH_DOT_DOT_HEAVY", e[e.DASH_DOT_HEAVY = 2] = "DASH_DOT_HEAVY", e[e.DASHED_HEAVY = 3] = "DASHED_HEAVY", e[e.DASH_LONG = 4] = "DASH_LONG", e[e.DASH_LONG_HEAVY = 5] = "DASH_LONG_HEAVY", e[e.DOT_DASH = 6] = "DOT_DASH", e[e.DOT_DOT_DASH = 7] = "DOT_DOT_DASH", e[e.DOTTED = 8] = "DOTTED", e[e.DOTTED_HEAVY = 9] = "DOTTED_HEAVY", e[e.DOUBLE = 10] = "DOUBLE", e[e.NONE = 11] = "NONE", e[e.SINGLE = 12] = "SINGLE", e[e.THICK = 13] = "THICK", e[e.WAVE = 14] = "WAVE", e[e.WAVY_DOUBLE = 15] = "WAVY_DOUBLE", e[e.WAVY_HEAVY = 16] = "WAVY_HEAVY", e[e.WORDS = 17] = "WORDS", e))(Mm || {});
var Pt = ((e) => (e[e.UNSPECIFIED = 0] = "UNSPECIFIED", e[e.LEFT = 1] = "LEFT", e[e.CENTER = 2] = "CENTER", e[e.RIGHT = 3] = "RIGHT", e[e.JUSTIFIED = 4] = "JUSTIFIED", e[e.BOTH = 5] = "BOTH", e[e.DISTRIBUTED = 6] = "DISTRIBUTED", e))(Pt || {});
var Dn = ((e) => (e[e.UNSPECIFIED = 0] = "UNSPECIFIED", e[e.TOP = 1] = "TOP", e[e.MIDDLE = 2] = "MIDDLE", e[e.BOTTOM = 3] = "BOTTOM", e))(Dn || {});
var jn = ((e) => (e[e.UNSPECIFIED = 0] = "UNSPECIFIED", e[e.OVERFLOW = 1] = "OVERFLOW", e[e.CLIP = 2] = "CLIP", e[e.WRAP = 3] = "WRAP", e))(jn || {});
var vi = ((e) => (e[e.NORMAL = 0] = "NORMAL", e[e.ITALIC = 1] = "ITALIC", e))(vi || {});
var bi = ((e) => (e[e.NORMAL = 0] = "NORMAL", e[e.BOLD = 1] = "BOLD", e))(bi || {});
var Zt = ((e) => (e[e.NORMAL = 1] = "NORMAL", e[e.SUBSCRIPT = 2] = "SUBSCRIPT", e[e.SUPERSCRIPT = 3] = "SUPERSCRIPT", e))(Zt || {});
var ie = ((e) => (e[e.FALSE = 0] = "FALSE", e[e.TRUE = 1] = "TRUE", e))(ie || {});
var mn = ((e) => (e[e.STRING = 1] = "STRING", e[e.NUMBER = 2] = "NUMBER", e[e.BOOLEAN = 3] = "BOOLEAN", e[e.FORCE_STRING = 4] = "FORCE_STRING", e))(mn || {});
var st = ((e) => (e[e.DARK1 = 0] = "DARK1", e[e.LIGHT1 = 1] = "LIGHT1", e[e.DARK2 = 2] = "DARK2", e[e.LIGHT2 = 3] = "LIGHT2", e[e.ACCENT1 = 4] = "ACCENT1", e[e.ACCENT2 = 5] = "ACCENT2", e[e.ACCENT3 = 6] = "ACCENT3", e[e.ACCENT4 = 7] = "ACCENT4", e[e.ACCENT5 = 8] = "ACCENT5", e[e.ACCENT6 = 9] = "ACCENT6", e[e.HYPERLINK = 10] = "HYPERLINK", e[e.FOLLOWED_HYPERLINK = 11] = "FOLLOWED_HYPERLINK", e))(st || {});
var go = ((e) => (e.OFFICE = "Office", e.OFFICE_2007_2010 = "Office 2007-2010", e.GRAYSCALE = "Grayscale", e.BLUE_WARM = "Blue Warm", e.BLUE = "Blue", e.BLUE_II = "Blue II", e.BLUE_GREEN = "Blue Green", e.GREEN = "Green", e.GREEN_YELLOW = "Green Yellow", e.YELLOW = "Yellow", e.YELLOW_ORANGE = "Yellow Orange", e.ORANGE = "Orange", e.ORANGE_RED = "Orange Red", e.RED_ORANGE = "Red Orange", e.RED = "Red", e.RED_VIOLET = "Red Violet", e.VIOLET = "Violet", e.VIOLET_II = "Violet II", e.MEDIAN = "Median", e.PAPER = "Paper", e.MARQUEE = "Marquee", e.SLIPSTREAM = "Slipstream", e.Aspect = "Aspect", e))(go || {});
var xm = ((e) => (e[e.character = 0] = "character", e[e.paragraph = 1] = "paragraph", e[e.table = 2] = "table", e[e.numbering = 3] = "numbering", e))(xm || {});
var Lm = ((e) => (e[e.TAB = 0] = "TAB", e[e.SPACE = 1] = "SPACE", e[e.NOTHING = 2] = "NOTHING", e))(Lm || {});
var me = ((e) => (e[e.BULLET = 0] = "BULLET", e[e.NONE = 1] = "NONE", e[e.DECIMAL = 2] = "DECIMAL", e[e.DECIMAL_ZERO = 3] = "DECIMAL_ZERO", e[e.UPPER_LETTER = 4] = "UPPER_LETTER", e[e.LOWER_LETTER = 5] = "LOWER_LETTER", e[e.UPPER_ROMAN = 6] = "UPPER_ROMAN", e[e.LOWER_ROMAN = 7] = "LOWER_ROMAN", e[e.ORDINAL = 8] = "ORDINAL", e[e.CARDINAL_TEXT = 9] = "CARDINAL_TEXT", e[e.ORDINAL_TEXT = 10] = "ORDINAL_TEXT", e[e.HEX = 11] = "HEX", e[e.CHICAGO = 12] = "CHICAGO", e[e.IDEOGRAPH_DIGITAL = 13] = "IDEOGRAPH_DIGITAL", e[e.JAPANESE_COUNTING = 14] = "JAPANESE_COUNTING", e[e.AIUEO = 15] = "AIUEO", e[e.IROHA = 16] = "IROHA", e[e.DECIMAL_FULL_WIDTH = 17] = "DECIMAL_FULL_WIDTH", e[e.DECIMAL_HALF_WIDTH = 18] = "DECIMAL_HALF_WIDTH", e[e.JAPANESE_LEGAL = 19] = "JAPANESE_LEGAL", e[e.JAPANESE_DIGITAL_TEN_THOUSAND = 20] = "JAPANESE_DIGITAL_TEN_THOUSAND", e[e.DECIMAL_ENCLOSED_CIRCLE = 21] = "DECIMAL_ENCLOSED_CIRCLE", e[e.DECIMAL_FULL_WIDTH2 = 22] = "DECIMAL_FULL_WIDTH2", e[e.AIUEO_FULL_WIDTH = 23] = "AIUEO_FULL_WIDTH", e[e.IROHA_FULL_WIDTH = 24] = "IROHA_FULL_WIDTH", e[e.GANADA = 25] = "GANADA", e[e.CHOSUNG = 26] = "CHOSUNG", e[e.DECIMAL_ENCLOSED_FULLSTOP = 27] = "DECIMAL_ENCLOSED_FULLSTOP", e[e.DECIMAL_ENCLOSED_PAREN = 28] = "DECIMAL_ENCLOSED_PAREN", e[e.DECIMAL_ENCLOSED_CIRCLE_CHINESE = 29] = "DECIMAL_ENCLOSED_CIRCLE_CHINESE", e[e.IDEOGRAPH_ENCLOSED_CIRCLE = 30] = "IDEOGRAPH_ENCLOSED_CIRCLE", e[e.IDEOGRAPH_TRADITIONAL = 31] = "IDEOGRAPH_TRADITIONAL", e[e.IDEOGRAPH_ZODIAC = 32] = "IDEOGRAPH_ZODIAC", e[e.IDEOGRAPH_ZODIAC_TRADITIONAL = 33] = "IDEOGRAPH_ZODIAC_TRADITIONAL", e[e.TAIWANESE_COUNTING = 34] = "TAIWANESE_COUNTING", e[e.IDEOGRAPH_LEGAL_TRADITIONAL = 35] = "IDEOGRAPH_LEGAL_TRADITIONAL", e[e.TAIWANESE_COUNTING_THOUSAND = 36] = "TAIWANESE_COUNTING_THOUSAND", e[e.TAIWANESE_DIGITAL = 37] = "TAIWANESE_DIGITAL", e[e.CHINESE_COUNTING = 38] = "CHINESE_COUNTING", e[e.CHINESE_LEGAL_SIMPLIFIED = 39] = "CHINESE_LEGAL_SIMPLIFIED", e[e.CHINESE_COUNTING_THOUSAND = 40] = "CHINESE_COUNTING_THOUSAND", e[e.KOREAN_DIGITAL = 41] = "KOREAN_DIGITAL", e[e.KOREAN_COUNTING = 42] = "KOREAN_COUNTING", e[e.KOREAN_LEGAL = 43] = "KOREAN_LEGAL", e[e.KOREAN_DIGITAL2 = 44] = "KOREAN_DIGITAL2", e[e.VIETNAMESE_COUNTING = 45] = "VIETNAMESE_COUNTING", e[e.RUSSIAN_LOWER = 46] = "RUSSIAN_LOWER", e[e.RUSSIAN_UPPER = 47] = "RUSSIAN_UPPER", e[e.NUMBER_IN_DASH = 48] = "NUMBER_IN_DASH", e[e.HEBREW1 = 49] = "HEBREW1", e[e.HEBREW2 = 50] = "HEBREW2", e[e.ARABIC_ALPHA = 51] = "ARABIC_ALPHA", e[e.ARABIC_ABJAD = 52] = "ARABIC_ABJAD", e[e.HINDI_VOWELS = 53] = "HINDI_VOWELS", e[e.HINDI_CONSONANTS = 54] = "HINDI_CONSONANTS", e[e.HINDI_NUMBERS = 55] = "HINDI_NUMBERS", e[e.HINDI_COUNTING = 56] = "HINDI_COUNTING", e[e.THAI_LETTERS = 57] = "THAI_LETTERS", e[e.THAI_NUMBERS = 58] = "THAI_NUMBERS", e[e.THAI_COUNTING = 59] = "THAI_COUNTING", e[e.CUSTOM = 60] = "CUSTOM", e))(me || {});
var Ms = ((e) => (e[e.BULLET_ALIGNMENT_UNSPECIFIED = 0] = "BULLET_ALIGNMENT_UNSPECIFIED", e[e.START = 1] = "START", e[e.CENTER = 2] = "CENTER", e[e.END = 3] = "END", e[e.BOTH = 4] = "BOTH", e))(Ms || {});
var En = ((e) => (e[e.HYPERLINK = 0] = "HYPERLINK", e[e.FIELD = 1] = "FIELD", e[e.SDT = 2] = "SDT", e[e.BOOKMARK = 3] = "BOOKMARK", e[e.COMMENT = 4] = "COMMENT", e[e.CUSTOM = 5] = "CUSTOM", e[e.MENTION = 6] = "MENTION", e[e.UNI_FORMULA = 7] = "UNI_FORMULA", e[e.DELTED = 9999] = "DELTED", e))(En || {});
var Un = ((e) => (e[e.COMMENT = 0] = "COMMENT", e[e.DELETED = 9999] = "DELETED", e))(Un || {});
var Dm = ((e) => (e[e.DRAWING = 0] = "DRAWING", e[e.CUSTOM = 1] = "CUSTOM", e))(Dm || {});
var fu = ((e) => (e[e.UNSPECIFIED = 0] = "UNSPECIFIED", e[e.TRADITIONAL = 1] = "TRADITIONAL", e[e.MODERN = 2] = "MODERN", e))(fu || {});
var Um = ((e) => (e[e.DEFAULT = 0] = "DEFAULT", e[e.LINES = 1] = "LINES", e[e.LINES_AND_CHARS = 2] = "LINES_AND_CHARS", e[e.SNAP_TO_CHARS = 3] = "SNAP_TO_CHARS", e))(Um || {});
var Pm = ((e) => (e[e.SECTION_TYPE_UNSPECIFIED = 0] = "SECTION_TYPE_UNSPECIFIED", e[e.CONTINUOUS = 1] = "CONTINUOUS", e[e.NEXT_PAGE = 2] = "NEXT_PAGE", e[e.EVEN_PAGE = 3] = "EVEN_PAGE", e[e.ODD_PAGE = 4] = "ODD_PAGE", e))(Pm || {});
var km = ((e) => (e[e.COLUMN_SEPARATOR_STYLE_UNSPECIFIED = 0] = "COLUMN_SEPARATOR_STYLE_UNSPECIFIED", e[e.NONE = 1] = "NONE", e[e.BETWEEN_EACH_COLUMN = 2] = "BETWEEN_EACH_COLUMN", e))(km || {});
var Fm = ((e) => (e[e.NORMAL = 0] = "NORMAL", e[e.TBRL = 1] = "TBRL", e[e.LRTBV = 2] = "LRTBV", e))(Fm || {});
var Hm = ((e) => (e[e.TEXT_RUN = 0] = "TEXT_RUN", e[e.AUTO_TEXT = 1] = "AUTO_TEXT", e[e.PAGE_BREAK = 2] = "PAGE_BREAK", e[e.COLUMN_BREAK = 3] = "COLUMN_BREAK", e[e.FOOT_NOTE_REFERENCE = 4] = "FOOT_NOTE_REFERENCE", e[e.HORIZONTAL_RULE = 5] = "HORIZONTAL_RULE", e[e.EQUATION = 6] = "EQUATION", e[e.DRAWING = 7] = "DRAWING", e[e.PERSON = 8] = "PERSON", e[e.RICH_LINK = 9] = "RICH_LINK", e))(Hm || {});
var $m = ((e) => (e[e.BOTH_SIDES = 0] = "BOTH_SIDES", e[e.LEFT = 1] = "LEFT", e[e.RIGHT = 2] = "RIGHT", e[e.LARGEST = 3] = "LARGEST", e))($m || {});
var Bm = ((e) => (e[e.INLINE = 0] = "INLINE", e[e.WRAP_NONE = 1] = "WRAP_NONE", e[e.WRAP_POLYGON = 2] = "WRAP_POLYGON", e[e.WRAP_SQUARE = 3] = "WRAP_SQUARE", e[e.WRAP_THROUGH = 4] = "WRAP_THROUGH", e[e.WRAP_TIGHT = 5] = "WRAP_TIGHT", e[e.WRAP_TOP_AND_BOTTOM = 6] = "WRAP_TOP_AND_BOTTOM", e))(Bm || {});
var qe = ((e) => (e[e.NAMED_STYLE_TYPE_UNSPECIFIED = 0] = "NAMED_STYLE_TYPE_UNSPECIFIED", e[e.NORMAL_TEXT = 1] = "NORMAL_TEXT", e[e.TITLE = 2] = "TITLE", e[e.SUBTITLE = 3] = "SUBTITLE", e[e.HEADING_1 = 4] = "HEADING_1", e[e.HEADING_2 = 5] = "HEADING_2", e[e.HEADING_3 = 6] = "HEADING_3", e[e.HEADING_4 = 7] = "HEADING_4", e[e.HEADING_5 = 8] = "HEADING_5", e))(qe || {});
var jm = ((e) => (e[e.AUTO = 0] = "AUTO", e[e.AT_LEAST = 1] = "AT_LEAST", e[e.EXACT = 2] = "EXACT", e))(jm || {});
var Wm = ((e) => (e[e.DASH_STYLE_UNSPECIFIED = 0] = "DASH_STYLE_UNSPECIFIED", e[e.SOLID = 1] = "SOLID", e[e.DOT = 2] = "DOT", e[e.DASH = 3] = "DASH", e))(Wm || {});
var Ym = ((e) => (e[e.TAB_STOP_ALIGNMENT_UNSPECIFIED = 0] = "TAB_STOP_ALIGNMENT_UNSPECIFIED", e[e.START = 1] = "START", e[e.CENTER = 2] = "CENTER", e[e.END = 3] = "END", e))(Ym || {});
var zm = ((e) => (e[e.UNSPECIFIED = 0] = "UNSPECIFIED", e[e.SPECIFIED = 1] = "SPECIFIED", e))(zm || {});
var Vm = ((e) => (e[e.START = 0] = "START", e[e.CENTER = 1] = "CENTER", e[e.END = 2] = "END", e))(Vm || {});
var Gm = ((e) => (e[e.AUTO_FIT = 0] = "AUTO_FIT", e[e.FIXED = 1] = "FIXED", e))(Gm || {});
var Km = ((e) => (e[e.NONE = 0] = "NONE", e[e.WRAP = 1] = "WRAP", e))(Km || {});
var Xm = ((e) => (e[e.AUTO = 0] = "AUTO", e[e.AT_LEAST = 1] = "AT_LEAST", e[e.EXACT = 2] = "EXACT", e))(Xm || {});
var qm = ((e) => (e[e.CONTENT_ALIGNMENT_UNSPECIFIED = 0] = "CONTENT_ALIGNMENT_UNSPECIFIED", e[e.BOTH = 1] = "BOTH", e[e.TOP = 2] = "TOP", e[e.CENTER = 3] = "CENTER", e[e.BOTTOM = 4] = "BOTTOM", e))(qm || {});
var or = ((e) => (e.NORMAL = "normal", e.BOLD = "bold", e.ITALIC = "italic", e))(or || {});
var Jm = ((e) => (e[e.PAGE = 0] = "PAGE", e[e.COLUMN = 1] = "COLUMN", e[e.CHARACTER = 2] = "CHARACTER", e[e.MARGIN = 3] = "MARGIN", e[e.INSIDE_MARGIN = 4] = "INSIDE_MARGIN", e[e.OUTSIDE_MARGIN = 5] = "OUTSIDE_MARGIN", e[e.LEFT_MARGIN = 6] = "LEFT_MARGIN", e[e.RIGHT_MARGIN = 7] = "RIGHT_MARGIN", e))(Jm || {});
var Zm = ((e) => (e[e.PAGE = 0] = "PAGE", e[e.PARAGRAPH = 1] = "PARAGRAPH", e[e.LINE = 2] = "LINE", e[e.MARGIN = 3] = "MARGIN", e[e.TOP_MARGIN = 4] = "TOP_MARGIN", e[e.BOTTOM_MARGIN = 5] = "BOTTOM_MARGIN", e[e.INSIDE_MARGIN = 6] = "INSIDE_MARGIN", e[e.OUTSIDE_MARGIN = 7] = "OUTSIDE_MARGIN", e))(Zm || {});
var Qm = ((e) => (e[e.POINT = 0] = "POINT", e[e.LINE = 1] = "LINE", e[e.CHARACTER = 2] = "CHARACTER", e[e.PIXEL = 3] = "PIXEL", e[e.PERCENT = 4] = "PERCENT", e))(Qm || {});
var eg = ((e) => (e[e.CENTER = 0] = "CENTER", e[e.INSIDE = 1] = "INSIDE", e[e.LEFT = 2] = "LEFT", e[e.OUTSIDE = 3] = "OUTSIDE", e[e.RIGHT = 4] = "RIGHT", e[e.BOTH = 5] = "BOTH", e[e.DISTRIBUTE = 6] = "DISTRIBUTE", e))(eg || {});
var tg = ((e) => (e[e.BOTTOM = 0] = "BOTTOM", e[e.CENTER = 1] = "CENTER", e[e.INSIDE = 2] = "INSIDE", e[e.OUTSIDE = 3] = "OUTSIDE", e[e.TOP = 4] = "TOP", e))(tg || {});
var ng = ((e) => (e[e.compressPunctuation = 0] = "compressPunctuation", e[e.compressPunctuationAndJapaneseKana = 1] = "compressPunctuationAndJapaneseKana", e[e.doNotCompress = 2] = "doNotCompress", e))(ng || {});
var rg = ((e) => (e[e.PORTRAIT = 0] = "PORTRAIT", e[e.LANDSCAPE = 1] = "LANDSCAPE", e))(rg || {});
var _t = ((e) => (e.Letter = "Letter", e.Tabloid = "Tabloid", e.Legal = "Legal", e.Statement = "Statement", e.Executive = "Executive", e.Folio = "Folio", e.A3 = "A3", e.A4 = "A4", e.A5 = "A5", e.B4 = "B4", e.B5 = "B5", e))(_t || {});
var SR = [
  "A3",
  "A4",
  "A5",
  "B4",
  "B5",
  "Letter",
  "Tabloid",
  "Legal",
  "Statement",
  "Executive",
  "Folio"
  /* Folio */
];
var sg = ((e) => (e[e.forward = 0] = "forward", e[e.backward = 1] = "backward", e[e.front = 2] = "front", e[e.back = 3] = "back", e))(sg || {});
var ig = ((e) => (e[e.UNRECOGNIZED = -1] = "UNRECOGNIZED", e[e.DRAWING_IMAGE = 0] = "DRAWING_IMAGE", e[e.DRAWING_SHAPE = 1] = "DRAWING_SHAPE", e[e.DRAWING_CHART = 2] = "DRAWING_CHART", e[e.DRAWING_TABLE = 3] = "DRAWING_TABLE", e[e.DRAWING_SMART_ART = 4] = "DRAWING_SMART_ART", e[e.DRAWING_VIDEO = 5] = "DRAWING_VIDEO", e[e.DRAWING_GROUP = 6] = "DRAWING_GROUP", e[e.DRAWING_UNIT = 7] = "DRAWING_UNIT", e[e.DRAWING_DOM = 8] = "DRAWING_DOM", e))(ig || {});
var mu = ((e) => (e[e.SLIDE = 0] = "SLIDE", e[e.MASTER = 1] = "MASTER", e[e.LAYOUT = 2] = "LAYOUT", e[e.HANDOUT_MASTER = 3] = "HANDOUT_MASTER", e[e.NOTES_MASTER = 4] = "NOTES_MASTER", e))(mu || {});
var og = ((e) => (e[e.SHAPE = 0] = "SHAPE", e[e.IMAGE = 1] = "IMAGE", e[e.TEXT = 2] = "TEXT", e[e.SPREADSHEET = 3] = "SPREADSHEET", e[e.DOCUMENT = 4] = "DOCUMENT", e[e.SLIDE = 5] = "SLIDE", e))(og || {});
var ag = ((e) => (e[e.RELATIVE_SLIDE_LINK_UNSPECIFIED = 0] = "RELATIVE_SLIDE_LINK_UNSPECIFIED", e[e.NEXT_SLIDE = 1] = "NEXT_SLIDE", e[e.PREVIOUS_SLIDE = 2] = "PREVIOUS_SLIDE", e[e.FIRST_SLIDE = 3] = "FIRST_SLIDE", e[e.LAST_SLIDE = 4] = "LAST_SLIDE", e))(ag || {});
function lg(e = et(6), t = Ts.EN_US, n = "") {
  return {
    id: e,
    locale: t,
    title: n,
    // title should get from request.
    tableSource: {},
    drawings: {},
    drawingsOrder: [],
    headers: {},
    footers: {},
    body: {
      dataStream: `\r
`,
      textRuns: [],
      customBlocks: [],
      tables: [],
      paragraphs: [
        {
          startIndex: 0,
          paragraphStyle: {
            spaceAbove: { v: 5 },
            lineSpacing: 1,
            spaceBelow: { v: 0 }
          }
        }
      ],
      sectionBreaks: [
        {
          startIndex: 1
        }
      ]
    },
    documentStyle: {
      pageSize: {
        width: 793.3333333333334,
        height: 1122.6666666666667
      },
      documentFlavor: fu.TRADITIONAL,
      marginTop: 50,
      marginBottom: 50,
      marginRight: 50,
      marginLeft: 50,
      renderConfig: {
        zeroWidthParagraphBreak: ie.FALSE,
        vertexAngle: 0,
        centerAngle: 0,
        background: {
          rgb: "#ccc"
        }
      },
      autoHyphenation: ie.TRUE,
      doNotHyphenateCaps: ie.FALSE,
      consecutiveHyphenLimit: 2,
      defaultHeaderId: "",
      defaultFooterId: "",
      evenPageHeaderId: "",
      evenPageFooterId: "",
      firstPageHeaderId: "",
      firstPageFooterId: "",
      evenAndOddHeaders: ie.FALSE,
      useFirstPageHeaderFooter: ie.FALSE,
      marginHeader: 30,
      marginFooter: 30
    },
    settings: {}
  };
}
var ln = {};
var Zn = {};
var Ur = {};
var ba;
function ug() {
  if (ba) return Ur;
  ba = 1, Object.defineProperty(Ur, "__esModule", { value: true });
  function e(r, s) {
    if (Array.isArray(s))
      return false;
    for (let i in r)
      if (!n(r[i], s[i]))
        return false;
    for (let i in s)
      if (r[i] === void 0)
        return false;
    return true;
  }
  function t(r, s) {
    if (!Array.isArray(s) || r.length !== s.length)
      return false;
    for (let i = 0; i < r.length; i++)
      if (!n(r[i], s[i]))
        return false;
    return true;
  }
  function n(r, s) {
    return r === s ? true : r === null || s === null || typeof r != "object" || typeof s != "object" ? false : Array.isArray(r) ? t(r, s) : e(r, s);
  }
  return Ur.default = n, Ur;
}
var Pr = {};
var Aa;
function cg() {
  if (Aa) return Pr;
  Aa = 1, Object.defineProperty(Pr, "__esModule", { value: true });
  function e(t) {
    if (t === null)
      return null;
    if (Array.isArray(t))
      return t.map(e);
    if (typeof t == "object") {
      const n = {};
      for (let r in t)
        n[r] = e(t[r]);
      return n;
    } else
      return t;
  }
  return Pr.default = e, Pr;
}
var Zs = {};
var ya;
function gu() {
  return ya || (ya = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: true }), e.eachChildOf = e.advancer = e.readCursor = e.writeCursor = e.WriteCursor = e.ReadCursor = e.isValidPathItem = void 0;
    function t(c, h) {
      if (!c)
        throw new Error(h);
    }
    const n = (c) => c != null && typeof c == "object" && !Array.isArray(c), r = (c, h) => (
      // All the numbers, then all the letters. Just as the gods of ascii intended.
      typeof c == typeof h ? c > h : typeof c == "string" && typeof h == "number"
    );
    function s(c, h) {
      for (let d in c) {
        const f = d;
        h.write(f, c[f]);
      }
    }
    e.isValidPathItem = (c) => typeof c == "number" || typeof c == "string" && c !== "__proto__";
    class i {
      constructor(h = null) {
        this.parents = [], this.indexes = [], this.lcIdx = -1, this.idx = -1, this.container = h;
      }
      ascend() {
        t(this.parents.length === this.indexes.length / 2), this.idx === 0 ? this.parents.length ? (this.lcIdx = this.indexes.pop(), this.container = this.parents.pop(), this.idx = this.indexes.pop()) : (this.lcIdx = 0, this.idx = -1) : (t(this.idx > 0), this.idx--, n(this.container[this.idx]) && this.idx--);
      }
      getPath() {
        const h = [];
        let d = this.container, f = this.parents.length - 1, g = this.idx;
        for (; g >= 0; )
          h.unshift(d[g]), g === 0 ? (g = this.indexes[f * 2], d = this.parents[f--]) : g -= n(d[g - 1]) ? 2 : 1;
        return h;
      }
    }
    class o extends i {
      get() {
        return this.container ? this.container.slice(this.idx + 1) : null;
      }
      // Its only valid to call this after descending into a child.
      getKey() {
        return t(this.container != null, "Invalid call to getKey before cursor descended"), this.container[this.idx];
      }
      getComponent() {
        let h;
        return this.container && this.container.length > this.idx + 1 && n(h = this.container[this.idx + 1]) ? h : null;
      }
      descendFirst() {
        let h = this.idx + 1;
        if (!this.container || h >= this.container.length || n(this.container[h]) && h + 1 >= this.container.length)
          return false;
        n(this.container[h]) && h++;
        const d = this.container[h];
        return Array.isArray(d) ? (this.indexes.push(this.idx), this.parents.push(this.container), this.indexes.push(h), this.idx = 0, this.container = d) : this.idx = h, true;
      }
      nextSibling() {
        if (t(this.parents.length === this.indexes.length / 2), this.idx > 0 || this.parents.length === 0)
          return false;
        const h = this.indexes[this.indexes.length - 1] + 1, d = this.parents[this.parents.length - 1];
        return h >= d.length ? false : (t(!isNaN(h)), this.indexes[this.indexes.length - 1] = h, this.container = d[h], true);
      }
      _init(h, d, f, g) {
        this.container = h, this.idx = d, this.parents = f.slice(), this.indexes = g.slice();
      }
      clone() {
        const h = new o();
        return h._init(this.container, this.idx, this.parents, this.indexes), h;
      }
      *[Symbol.iterator]() {
        if (this.descendFirst()) {
          do
            yield this.getKey();
          while (this.nextSibling());
          this.ascend();
        }
      }
      // TODO(cleanup): Consider moving these functions out of cursor, since
      // they're really just helper methods.
      // It'd be really nice to do this using generators.
      traverse(h, d) {
        const f = this.getComponent();
        f && d(f, h);
        for (const g of this)
          h && h.descend(g), this.traverse(h, d), h && h.ascend();
      }
      eachPick(h, d) {
        this.traverse(h, (f, g) => {
          f.p != null && d(f.p, g);
        });
      }
      eachDrop(h, d) {
        this.traverse(h, (f, g) => {
          f.d != null && d(f.d, g);
        });
      }
    }
    e.ReadCursor = o;
    class a extends i {
      constructor(h = null) {
        super(h), this.pendingDescent = [], this._op = h;
      }
      flushDescent() {
        t(this.parents.length === this.indexes.length / 2), this.container === null && (this._op = this.container = []);
        for (let h = 0; h < this.pendingDescent.length; h++) {
          const d = this.pendingDescent[h];
          let f = this.idx + 1;
          if (f < this.container.length && n(this.container[f]) && f++, t(f === this.container.length || !n(this.container[f])), f === this.container.length)
            this.container.push(d), this.idx = f;
          else if (this.container[f] === d)
            this.idx = f;
          else {
            if (!Array.isArray(this.container[f])) {
              const g = this.container.splice(f, this.container.length - f);
              this.container.push(g), this.lcIdx > -1 && (this.lcIdx = f);
            }
            for (this.indexes.push(this.idx), this.parents.push(this.container), this.lcIdx !== -1 && (t(r(d, this.container[this.lcIdx][0])), f = this.lcIdx + 1, this.lcIdx = -1); f < this.container.length && r(d, this.container[f][0]); )
              f++;
            if (this.indexes.push(f), this.idx = 0, f < this.container.length && this.container[f][0] === d)
              this.container = this.container[f];
            else {
              const g = [d];
              this.container.splice(f, 0, g), this.container = g;
            }
          }
        }
        this.pendingDescent.length = 0;
      }
      reset() {
        this.lcIdx = -1;
      }
      // Creates and returns a component, creating one if need be. You should
      // probably write to it immediately - ops are not valid with empty
      // components.
      getComponent() {
        this.flushDescent();
        const h = this.idx + 1;
        if (h < this.container.length && n(this.container[h]))
          return this.container[h];
        {
          const d = {};
          return this.container.splice(h, 0, d), d;
        }
      }
      write(h, d) {
        const f = this.getComponent();
        t(f[h] == null || f[h] === d, "Internal consistency error: Overwritten component. File a bug"), f[h] = d;
      }
      get() {
        return this._op;
      }
      descend(h) {
        if (!e.isValidPathItem(h))
          throw Error("Invalid JSON key");
        this.pendingDescent.push(h);
      }
      descendPath(h) {
        return this.pendingDescent.push(...h), this;
      }
      ascend() {
        this.pendingDescent.length ? this.pendingDescent.pop() : super.ascend();
      }
      mergeTree(h, d = s) {
        if (h === null)
          return;
        if (t(Array.isArray(h)), h === this._op)
          throw Error("Cannot merge into my own tree");
        const f = this.lcIdx, g = this.parents.length;
        let _ = 0;
        for (let R = 0; R < h.length; R++) {
          const b = h[R];
          typeof b == "string" || typeof b == "number" ? (_++, this.descend(b)) : Array.isArray(b) ? this.mergeTree(b, d) : typeof b == "object" && d(b, this);
        }
        for (; _--; )
          this.ascend();
        this.lcIdx = this.parents.length === g ? f : -1;
      }
      at(h, d) {
        this.descendPath(h), d(this);
        for (let f = 0; f < h.length; f++)
          this.ascend();
        return this;
      }
      // This is used by helpers, so the strict ordering guarantees are
      // relaxed.
      writeAtPath(h, d, f) {
        return this.at(h, () => this.write(d, f)), this.reset(), this;
      }
      writeMove(h, d, f = 0) {
        return this.writeAtPath(h, "p", f).writeAtPath(d, "d", f);
      }
      getPath() {
        const h = super.getPath();
        return h.push(...this.pendingDescent), h;
      }
    }
    e.WriteCursor = a, e.writeCursor = () => new a(), e.readCursor = (c) => new o(c);
    function l(c, h, d) {
      let f, g;
      g = f = c ? c.descendFirst() : false;
      function _(R) {
        let b;
        for (; g; ) {
          const $ = b = c.getKey();
          if (R != null) {
            let k = false;
            if (h && typeof $ == "number" && (b = h($, c.getComponent()), b < 0 && (b = ~b, k = true)), r(b, R))
              return null;
            if (b === R && !k)
              return c;
          }
          d && typeof b == "number" && d(b, c.getComponent()), g = c.nextSibling();
        }
        return null;
      }
      return _.end = () => {
        f && c.ascend();
      }, _;
    }
    e.advancer = l;
    function u(c, h, d) {
      let f, g, _, R;
      for (f = g = c && c.descendFirst(), _ = R = h && h.descendFirst(); f || _; ) {
        let b = f ? c.getKey() : null, $ = _ ? h.getKey() : null;
        b !== null && $ !== null && (r($, b) ? $ = null : b !== $ && (b = null)), d(b == null ? $ : b, b != null ? c : null, $ != null ? h : null), b != null && f && (f = c.nextSibling()), $ != null && _ && (_ = h.nextSibling());
      }
      g && c.ascend(), R && h.ascend();
    }
    e.eachChildOf = u;
  }(Zs)), Zs;
}
var Qs = {};
var Na;
function _u() {
  return Na || (Na = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: true }), e.ConflictType = void 0, function(t) {
      t[t.RM_UNEXPECTED_CONTENT = 1] = "RM_UNEXPECTED_CONTENT", t[t.DROP_COLLISION = 2] = "DROP_COLLISION", t[t.BLACKHOLE = 3] = "BLACKHOLE";
    }(e.ConflictType || (e.ConflictType = {}));
  }(Qs)), Qs;
}
var bt = {};
var un = {};
var Ta;
function _o() {
  return Ta || (Ta = 1, Object.defineProperty(un, "__esModule", { value: true }), un.uniToStrPos = un.strPosToUni = void 0, un.strPosToUni = (e, t = e.length) => {
    let n = 0, r = 0;
    for (; r < t; r++) {
      const s = e.charCodeAt(r);
      s >= 55296 && s <= 57343 && (n++, r++);
    }
    if (r !== t)
      throw Error("Invalid offset - splits unicode bytes");
    return r - n;
  }, un.uniToStrPos = (e, t) => {
    let n = 0;
    for (; t > 0; t--) {
      const r = e.charCodeAt(n);
      n += r >= 55296 && r <= 57343 ? 2 : 1;
    }
    return n;
  }), un;
}
var ei = {};
var Ma;
function Ai() {
  return Ma || (Ma = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: true }), e.uniSlice = e.dlen = e.eachOp = void 0;
    const t = _o(), n = (w) => {
      if (!Array.isArray(w))
        throw Error("Op must be an array of components");
      let C = null;
      for (let v = 0; v < w.length; v++) {
        const y = w[v];
        switch (typeof y) {
          case "object":
            if (typeof y.d != "number" && typeof y.d != "string")
              throw Error("Delete must be number or string");
            if (e.dlen(y.d) <= 0)
              throw Error("Deletes must not be empty");
            break;
          case "string":
            if (!(y.length > 0))
              throw Error("Inserts cannot be empty");
            break;
          case "number":
            if (!(y > 0))
              throw Error("Skip components must be >0");
            if (typeof C == "number")
              throw Error("Adjacent skip components should be combined");
            break;
        }
        C = y;
      }
      if (typeof C == "number")
        throw Error("Op has a trailing skip");
    };
    function r(w, C) {
      let v = 0, y = 0;
      for (let F2 = 0; F2 < w.length; F2++) {
        const H = w[F2];
        switch (C(H, v, y), typeof H) {
          case "object":
            v += e.dlen(H.d);
            break;
          case "string":
            y += t.strPosToUni(H);
            break;
          case "number":
            v += H, y += H;
            break;
        }
      }
    }
    e.eachOp = r;
    function s(w, C) {
      const v = [], y = a(v);
      return r(w, (F2, H, m) => {
        y(C(F2, H, m));
      }), h(v);
    }
    const i = (w) => w, o = (w) => s(w, i);
    e.dlen = (w) => typeof w == "number" ? w : t.strPosToUni(w);
    const a = (w) => (C) => {
      if (!(!C || C.d === 0 || C.d === "")) if (w.length === 0)
        w.push(C);
      else if (typeof C == typeof w[w.length - 1])
        if (typeof C == "object") {
          const v = w[w.length - 1];
          v.d = typeof v.d == "string" && typeof C.d == "string" ? v.d + C.d : e.dlen(v.d) + e.dlen(C.d);
        } else
          w[w.length - 1] += C;
      else
        w.push(C);
    }, l = (w) => typeof w == "number" ? w : typeof w == "string" ? t.strPosToUni(w) : typeof w.d == "number" ? w.d : t.strPosToUni(w.d);
    e.uniSlice = (w, C, v) => {
      const y = t.uniToStrPos(w, C), F2 = v == null ? 1 / 0 : t.uniToStrPos(w, v);
      return w.slice(y, F2);
    };
    const u = (w, C, v) => typeof w == "number" ? v == null ? w - C : Math.min(w, v) - C : e.uniSlice(w, C, v), c = (w) => {
      let C = 0, v = 0;
      return { take: (H, m) => {
        if (C === w.length)
          return H === -1 ? null : H;
        const D = w[C];
        let S;
        if (typeof D == "number")
          return H === -1 || D - v <= H ? (S = D - v, ++C, v = 0, S) : (v += H, H);
        if (typeof D == "string") {
          if (H === -1 || m === "i" || t.strPosToUni(D.slice(v)) <= H)
            return S = D.slice(v), ++C, v = 0, S;
          {
            const T = v + t.uniToStrPos(D.slice(v), H);
            return S = D.slice(v, T), v = T, S;
          }
        } else {
          if (H === -1 || m === "d" || e.dlen(D.d) - v <= H)
            return S = { d: u(D.d, v) }, ++C, v = 0, S;
          {
            let T = u(D.d, v, v + H);
            return v += H, { d: T };
          }
        }
      }, peek: () => w[C] };
    }, h = (w) => (w.length > 0 && typeof w[w.length - 1] == "number" && w.pop(), w);
    function d(w, C, v) {
      if (v !== "left" && v !== "right")
        throw Error("side (" + v + ") must be 'left' or 'right'");
      n(w), n(C);
      const y = [], F2 = a(y), { take: H, peek: m } = c(w);
      for (let S = 0; S < C.length; S++) {
        const T = C[S];
        let A, O;
        switch (typeof T) {
          case "number":
            for (A = T; A > 0; )
              O = H(A, "i"), F2(O), typeof O != "string" && (A -= l(O));
            break;
          case "string":
            v === "left" && typeof m() == "string" && F2(H(-1)), F2(t.strPosToUni(T));
            break;
          case "object":
            for (A = e.dlen(T.d); A > 0; )
              switch (O = H(A, "i"), typeof O) {
                case "number":
                  A -= O;
                  break;
                case "string":
                  F2(O);
                  break;
                case "object":
                  A -= e.dlen(O.d);
              }
            break;
        }
      }
      let D;
      for (; D = H(-1); )
        F2(D);
      return h(y);
    }
    function f(w, C) {
      n(w), n(C);
      const v = [], y = a(v), { take: F2 } = c(w);
      for (let m = 0; m < C.length; m++) {
        const D = C[m];
        let S, T;
        switch (typeof D) {
          case "number":
            for (S = D; S > 0; )
              T = F2(S, "d"), y(T), typeof T != "object" && (S -= l(T));
            break;
          case "string":
            y(D);
            break;
          case "object":
            S = e.dlen(D.d);
            let A = 0;
            for (; A < S; )
              switch (T = F2(S - A, "d"), typeof T) {
                case "number":
                  y({ d: u(D.d, A, A + T) }), A += T;
                  break;
                case "string":
                  A += t.strPosToUni(T);
                  break;
                case "object":
                  y(T);
              }
            break;
        }
      }
      let H;
      for (; H = F2(-1); )
        y(H);
      return h(v);
    }
    const g = (w, C) => {
      let v = 0;
      for (let y = 0; y < C.length && w > v; y++) {
        const F2 = C[y];
        switch (typeof F2) {
          case "number": {
            v += F2;
            break;
          }
          case "string":
            const H = t.strPosToUni(F2);
            v += H, w += H;
            break;
          case "object":
            w -= Math.min(e.dlen(F2.d), w - v);
            break;
        }
      }
      return w;
    }, _ = (w, C) => typeof w == "number" ? g(w, C) : w.map((v) => g(v, C));
    function R(w, C, v) {
      return s(w, (y, F2) => typeof y == "object" && typeof y.d == "number" ? { d: v.slice(C, F2, F2 + y.d) } : y);
    }
    function b(w) {
      return s(w, (C) => {
        switch (typeof C) {
          case "object":
            if (typeof C.d == "number")
              throw Error("Cannot invert text op: Deleted characters missing from operation. makeInvertible must be called first.");
            return C.d;
          case "string":
            return { d: C };
          case "number":
            return C;
        }
      });
    }
    function $(w) {
      return s(w, (C) => typeof C == "object" && typeof C.d == "string" ? { d: t.strPosToUni(C.d) } : C);
    }
    function k(w) {
      let C = true;
      return r(w, (v) => {
        typeof v == "object" && typeof v.d == "number" && (C = false);
      }), C;
    }
    function W(w) {
      return {
        name: "text-unicode",
        uri: "http://sharejs.org/types/text-unicode",
        trim: h,
        normalize: o,
        checkOp: n,
        /** Create a new text snapshot.
         *
         * @param {string} initial - initial snapshot data. Optional. Defaults to ''.
         * @returns {Snap} Initial document snapshot object
         */
        create(C = "") {
          if (typeof C != "string")
            throw Error("Initial data must be a string");
          return w.create(C);
        },
        /** Apply an operation to a document snapshot
         */
        apply(C, v) {
          n(v);
          const y = w.builder(C);
          for (let F2 = 0; F2 < v.length; F2++) {
            const H = v[F2];
            switch (typeof H) {
              case "number":
                y.skip(H);
                break;
              case "string":
                y.append(H);
                break;
              case "object":
                y.del(e.dlen(H.d));
                break;
            }
          }
          return y.build();
        },
        transform: d,
        compose: f,
        transformPosition: g,
        transformSelection: _,
        isInvertible: k,
        makeInvertible(C, v) {
          return R(C, v, w);
        },
        stripInvertible: $,
        invert: b,
        invertWithDoc(C, v) {
          return b(R(C, v, w));
        },
        isNoop: (C) => C.length === 0
      };
    }
    e.default = W;
  }(ei)), ei;
}
var kr = {};
var xa;
function hg() {
  if (xa) return kr;
  xa = 1, Object.defineProperty(kr, "__esModule", { value: true });
  const e = Ai(), t = _o();
  function n(r, s) {
    return {
      // Returns the text content of the document
      get: r,
      // Returns the number of characters in the string
      getLength() {
        return r().length;
      },
      // Insert the specified text at the given position in the document
      insert(i, o, a) {
        const l = t.strPosToUni(r(), i);
        return s([l, o], a);
      },
      remove(i, o, a) {
        const l = t.strPosToUni(r(), i);
        return s([l, { d: o }], a);
      },
      // When you use this API, you should implement these two methods
      // in your editing context.
      //onInsert: function(pos, text) {},
      //onRemove: function(pos, removedLength) {},
      _onOp(i) {
        e.eachOp(i, (o, a, l) => {
          switch (typeof o) {
            case "string":
              this.onInsert && this.onInsert(l, o);
              break;
            case "object":
              const u = e.dlen(o.d);
              this.onRemove && this.onRemove(l, u);
          }
        });
      },
      onInsert: null,
      onRemove: null
    };
  }
  return kr.default = n, n.provides = { text: true }, kr;
}
var La;
function dg() {
  return La || (La = 1, function(e) {
    var t = bt && bt.__createBinding || (Object.create ? function(d, f, g, _) {
      _ === void 0 && (_ = g), Object.defineProperty(d, _, { enumerable: true, get: function() {
        return f[g];
      } });
    } : function(d, f, g, _) {
      _ === void 0 && (_ = g), d[_] = f[g];
    }), n = bt && bt.__setModuleDefault || (Object.create ? function(d, f) {
      Object.defineProperty(d, "default", { enumerable: true, value: f });
    } : function(d, f) {
      d.default = f;
    }), r = bt && bt.__importStar || function(d) {
      if (d && d.__esModule) return d;
      var f = {};
      if (d != null) for (var g in d) Object.hasOwnProperty.call(d, g) && t(f, d, g);
      return n(f, d), f;
    }, s = bt && bt.__importDefault || function(d) {
      return d && d.__esModule ? d : { default: d };
    };
    Object.defineProperty(e, "__esModule", { value: true }), e.type = e.remove = e.insert = void 0;
    const i = _o(), o = r(Ai()), a = s(hg()), l = {
      create(d) {
        return d;
      },
      toString(d) {
        return d;
      },
      builder(d) {
        if (typeof d != "string")
          throw Error("Invalid document snapshot: " + d);
        const f = [];
        return {
          skip(g) {
            let _ = i.uniToStrPos(d, g);
            if (_ > d.length)
              throw Error("The op is too long for this document");
            f.push(d.slice(0, _)), d = d.slice(_);
          },
          append(g) {
            f.push(g);
          },
          del(g) {
            d = d.slice(i.uniToStrPos(d, g));
          },
          build() {
            return f.join("") + d;
          }
        };
      },
      slice: o.uniSlice
    }, u = o.default(l), c = Object.assign(Object.assign({}, u), { api: a.default });
    e.type = c, e.insert = (d, f) => f.length === 0 ? [] : d === 0 ? [f] : [d, f], e.remove = (d, f) => o.dlen(f) === 0 ? [] : d === 0 ? [{ d: f }] : [d, { d: f }];
    var h = Ai();
    Object.defineProperty(e, "makeType", { enumerable: true, get: function() {
      return h.default;
    } });
  }(bt)), bt;
}
var Da;
function fg() {
  return Da || (Da = 1, function(e) {
    var t = Zn && Zn.__importDefault || function(I) {
      return I && I.__esModule ? I : {
        default: I
      };
    };
    Object.defineProperty(e, "__esModule", {
      value: true
    }), e.editOp = e.replaceOp = e.insertOp = e.moveOp = e.removeOp = e.type = void 0;
    const n = t(ug()), r = t(cg()), s = gu(), i = _u();
    function o(I, L) {
      if (!I) throw new Error(L);
    }
    e.type = {
      name: "json1",
      uri: "http://sharejs.org/types/JSONv1",
      readCursor: s.readCursor,
      writeCursor: s.writeCursor,
      create: (I) => I,
      isNoop: (I) => I == null,
      setDebug(I) {
      },
      registerSubtype: b,
      checkValidOp: F2,
      normalize: H,
      apply: m,
      transformPosition: D,
      compose: S,
      tryTransform: x,
      transform: q,
      makeInvertible: O,
      invert: T,
      invertWithDoc: N,
      RM_UNEXPECTED_CONTENT: i.ConflictType.RM_UNEXPECTED_CONTENT,
      DROP_COLLISION: i.ConflictType.DROP_COLLISION,
      BLACKHOLE: i.ConflictType.BLACKHOLE,
      transformNoConflict: (I, L, Y) => le(() => true, I, L, Y),
      typeAllowingConflictsPred: (I) => Object.assign(Object.assign({}, e.type), {
        transform: (L, Y, z) => le(I, L, Y, z)
      })
    };
    const a = (I) => I ? I.getComponent() : null;
    function l(I) {
      return I && typeof I == "object" && !Array.isArray(I);
    }
    const u = (I) => Array.isArray(I) ? I.slice() : I !== null && typeof I == "object" ? Object.assign({}, I) : I, c = (I) => I && (I.p != null || I.r !== void 0), h = (I) => I && (I.d != null || I.i !== void 0);
    function d(I, L) {
      return o(I != null), typeof L == "number" ? (o(Array.isArray(I), "Invalid key - child is not an array"), (I = I.slice()).splice(L, 1)) : (o(l(I), "Invalid key - child is not an object"), delete (I = Object.assign({}, I))[L]), I;
    }
    function f(I, L, Y) {
      return typeof L == "number" ? (o(I != null, "Container is missing for key"), o(Array.isArray(I), "Cannot use numerical key for object container"), o(I.length >= L, "Cannot insert into out of bounds index"), I.splice(L, 0, Y)) : (o(l(I), "Cannot insert into missing item"), o(I[L] === void 0, "Trying to overwrite value at key. Your op needs to remove it first"), I[L] = Y), Y;
    }
    e.removeOp = (I, L = true) => s.writeCursor().writeAtPath(I, "r", L).get(), e.moveOp = (I, L) => s.writeCursor().writeMove(I, L).get(), e.insertOp = (I, L) => s.writeCursor().writeAtPath(I, "i", L).get(), e.replaceOp = (I, L, Y) => s.writeCursor().at(I, (z) => {
      z.write("r", L), z.write("i", Y);
    }).get(), e.editOp = (I, L, Y, z = false) => s.writeCursor().at(I, (B) => C(B, L, Y, z)).get();
    const g = (I, L) => I != null && (typeof L == "number" ? Array.isArray(I) : typeof I == "object"), _ = (I, L) => g(I, L) ? I[L] : void 0, R = {};
    function b(I) {
      let L = I.type ? I.type : I;
      L.name && (R[L.name] = L), L.uri && (R[L.uri] = L);
    }
    const $ = (I) => {
      const L = R[I];
      if (L) return L;
      throw Error("Missing type: " + I);
    };
    b(dg());
    const k = (I, L) => I + L;
    b({
      name: "number",
      apply: k,
      compose: k,
      invert: (I) => -I,
      transform: (I) => I
    });
    const W = (I) => I == null ? null : I.et ? $(I.et) : I.es ? R["text-unicode"] : I.ena != null ? R.number : null, w = (I) => I.es ? I.es : I.ena != null ? I.ena : I.e, C = (I, L, Y, z = false) => {
      const [B, j] = typeof L == "string" ? [$(L), L] : [L, L.name];
      !z && B.isNoop && B.isNoop(Y) || (j === "number" ? I.write("ena", Y) : j === "text-unicode" ? I.write("es", Y) : (I.write("et", j), I.write("e", Y)));
    };
    function v(I) {
      o(typeof I == "number"), o(I >= 0), o(I === (0 | I));
    }
    function y(I) {
      typeof I == "number" ? v(I) : o(typeof I == "string");
    }
    function F2(I) {
      if (I === null) return;
      const L = /* @__PURE__ */ new Set(), Y = /* @__PURE__ */ new Set(), z = (j) => {
        let Q = true, ee = false;
        for (let U in j) {
          const G = j[U];
          if (Q = false, o(U === "p" || U === "r" || U === "d" || U === "i" || U === "e" || U === "es" || U === "ena" || U === "et", "Invalid component item '" + U + "'"), U === "p") v(G), o(!L.has(G)), L.add(G), o(j.r === void 0);
          else if (U === "d") v(G), o(!Y.has(G)), Y.add(G), o(j.i === void 0);
          else if (U === "e" || U === "es" || U === "ena") {
            o(!ee), ee = true;
            const X = W(j);
            o(X, "Missing type in edit"), X.checkValidOp && X.checkValidOp(w(j));
          }
        }
        o(!Q);
      }, B = (j, Q, ee) => {
        if (!Array.isArray(j)) throw Error("Op must be null or a list");
        if (j.length === 0) throw Error("Empty descent");
        Q || y(j[0]);
        let U = 1, G = 0, X = 0;
        for (let ne = 0; ne < j.length; ne++) {
          const de = j[ne];
          if (o(de != null), Array.isArray(de)) {
            const _e = B(de, false);
            if (G) {
              const K = typeof X, ce = typeof _e;
              K === ce ? o(X < _e, "descent keys are not in order") : o(K === "number" && ce === "string");
            }
            X = _e, G++, U = 3;
          } else typeof de == "object" ? (o(U === 1, `Prev not scalar - instead ${U}`), z(de), U = 2) : (o(U !== 3), y(de), o(s.isValidPathItem(de), "Invalid path key"), U = 1);
        }
        return o(G !== 1, "Operation makes multiple descents. Remove some []"), o(U === 2 || U === 3), j[0];
      };
      B(I, true), o(L.size === Y.size, "Mismatched picks and drops in op");
      for (let j = 0; j < L.size; j++) o(L.has(j)), o(Y.has(j));
    }
    function H(I) {
      let L = 0, Y = [];
      const z = s.writeCursor();
      return z.mergeTree(I, (B, j) => {
        const Q = W(B);
        if (Q) {
          const U = w(B);
          C(j, Q, Q.normalize ? Q.normalize(U) : U);
        }
        for (const U of ["r", "p", "i", "d"]) if (B[U] !== void 0) {
          const G = U === "p" || U === "d" ? (ee = B[U], Y[ee] == null && (Y[ee] = L++), Y[ee]) : B[U];
          j.write(U, G);
        }
        var ee;
      }), z.get();
    }
    function m(I, L) {
      if (F2(L), L === null) return I;
      const Y = [];
      return function z(B, j) {
        let Q = B, ee = 0, U = {
          root: B
        }, G = 0, X = U, ne = "root";
        function de() {
          for (; G < ee; G++) {
            let _e = j[G];
            typeof _e != "object" && (o(g(X, ne)), X = X[ne] = u(X[ne]), ne = _e);
          }
        }
        for (; ee < j.length; ee++) {
          const _e = j[ee];
          if (Array.isArray(_e)) {
            const K = z(Q, _e);
            K !== Q && K !== void 0 && (de(), Q = X[ne] = K);
          } else if (typeof _e == "object") {
            _e.d != null ? (de(), Q = f(X, ne, Y[_e.d])) : _e.i !== void 0 && (de(), Q = f(X, ne, _e.i));
            const K = W(_e);
            if (K) de(), Q = X[ne] = K.apply(Q, w(_e));
            else if (_e.e !== void 0) throw Error("Subtype " + _e.et + " undefined");
          } else Q = _(Q, _e);
        }
        return U.root;
      }(I = function z(B, j) {
        const Q = [];
        let ee = 0;
        for (; ee < j.length; ee++) {
          const ne = j[ee];
          if (Array.isArray(ne)) break;
          typeof ne != "object" && (Q.push(B), B = _(B, ne));
        }
        for (let ne = j.length - 1; ne >= ee; ne--) B = z(B, j[ne]);
        for (--ee; ee >= 0; ee--) {
          const ne = j[ee];
          if (typeof ne != "object") {
            const de = Q.pop();
            B = B === _(de, ne) ? de : B === void 0 ? d(de, ne) : (G = ne, X = B, (U = u(U = de))[G] = X, U);
          } else c(ne) && (o(B !== void 0, "Cannot pick up or remove undefined"), ne.p != null && (Y[ne.p] = B), B = void 0);
        }
        var U, G, X;
        return B;
      }(I, L), L);
    }
    function D(I, L) {
      I = I.slice(), F2(L);
      const Y = s.readCursor(L);
      let z, B, j = false;
      const Q = [];
      for (let U = 0; ; U++) {
        const G = I[U], X = Y.getComponent();
        if (X && (X.r !== void 0 ? j = true : X.p != null && (j = false, z = X.p, B = U)), U >= I.length) break;
        let ne = 0;
        const de = s.advancer(Y, void 0, (K, ce) => {
          c(ce) && ne++;
        });
        Q.unshift(de);
        const _e = de(G);
        if (typeof G == "number" && (I[U] -= ne), !_e) break;
      }
      if (Q.forEach((U) => U.end()), j) return null;
      const ee = () => {
        let U = 0;
        if (z != null) {
          const G = Y.getPath();
          U = G.length, I = G.concat(I.slice(B));
        }
        for (; U < I.length; U++) {
          const G = I[U], X = a(Y), ne = W(X);
          if (ne) {
            const K = w(X);
            ne.transformPosition && (I[U] = ne.transformPosition(I[U], K));
            break;
          }
          let de = 0;
          const _e = s.advancer(Y, (K, ce) => h(ce) ? ~(K - de) : K - de, (K, ce) => {
            h(ce) && de++;
          })(G);
          if (typeof G == "number" && (I[U] += de), !_e) break;
        }
      };
      return z != null ? Y.eachDrop(null, (U) => {
        U === z && ee();
      }) : ee(), I;
    }
    function S(I, L) {
      if (F2(I), F2(L), I == null) return L;
      if (L == null) return I;
      let Y = 0;
      const z = s.readCursor(I), B = s.readCursor(L), j = s.writeCursor(), Q = [], ee = [], U = [], G = [], X = [], ne = [], de = /* @__PURE__ */ new Set();
      z.traverse(null, (K) => {
        K.p != null && (U[K.p] = z.clone());
      }), B.traverse(null, (K) => {
        K.d != null && (G[K.d] = B.clone());
      });
      const _e = s.writeCursor();
      return function K(ce, Me, Ae, Re, ke, $t, Qe, Ge) {
        o(Me || Ae);
        const Fe = a(Me), ft = a(Ae), wt = !!ft && ft.r !== void 0, sn = !!Fe && Fe.i !== void 0, mt = Fe ? Fe.d : null, at = ft ? ft.p : null, Bt = ($t || wt) && at == null;
        if (at != null) Re = G[at], Qe = ee[at] = new s.WriteCursor();
        else if (ft && ft.r !== void 0) Re = null;
        else {
          const se = a(Re);
          se && se.d != null && (Re = null);
        }
        const ve = a(Re);
        if (mt != null) if (ce = U[mt], Ge = Q[mt] = new s.WriteCursor(), Bt) $t && !wt && Ge.write("r", true);
        else {
          const se = X[mt] = Y++;
          Qe.write("d", se);
        }
        else if (Fe && Fe.i !== void 0) ce = null;
        else {
          const se = a(ce);
          se && se.p != null && (ce = null);
        }
        let ae;
        sn ? (o(ke === void 0), ae = Fe.i) : ae = ke;
        const Ee = (at == null ? !sn || $t || wt : ae === void 0) ? null : Qe.getComponent();
        if (at != null) {
          if (!(ke !== void 0 || sn)) {
            const se = mt != null ? X[mt] : Y++;
            ne[at] = se, Ge.write("p", se);
          }
        } else wt && (sn || ke !== void 0 || (ft.r, Ge.write("r", ft.r)));
        const ue = Bt ? null : W(Fe), re = W(ve);
        if ((ue || re) && (ue && ue.name, re && re.name), ue && re) {
          o(ue === re);
          const se = w(Fe), Ce = w(ve), ze = ue.compose(se, Ce);
          C(Qe, ue, ze), de.add(ve);
        } else ue ? C(Qe, ue, w(Fe)) : re && (C(Qe, re, w(ve)), de.add(ve));
        const he = typeof ae == "object" && ae != null;
        let Oe = false, Se = 0, be = 0, Ye = 0, je = 0, He = 0;
        const Je = s.advancer(Re, (se, Ce) => h(Ce) ? je - se - 1 : se - je, (se, Ce) => {
          h(Ce) && je++;
        }), Ie = s.advancer(ce, (se, Ce) => c(Ce) ? Se - se - 1 : se - Se, (se, Ce) => {
          c(Ce) && Se++;
        });
        if (s.eachChildOf(Me, Ae, (se, Ce, ze) => {
          let nt, jt, on = se, St = se, qn = se;
          if (typeof se == "number") {
            let Ke = se + Ye;
            jt = Je(Ke), St = Ke + je;
            let $e = se + be;
            nt = Ie($e), h(a(jt)) && (nt = null), on = $e + Se, qn = se + He, o(on >= 0, "p1PickKey is negative"), o(St >= 0, "p2DropKey is negative");
            const Ot = h(a(Ce)), Wt = c(a(ze));
            (Ot || Wt && !Bt) && He--, Ot && be--, Wt && Ye--;
          } else nt = Ie(se), jt = Je(se);
          Ge.descend(on), Qe.descend(St);
          const In = he && !h(a(Ce)) ? ae[qn] : void 0, Mt = K(nt, Ce, ze, jt, In, Bt, Qe, Ge);
          var xt, fe, De;
          he && !Bt ? In !== Mt && (Oe || (ae = Array.isArray(ae) ? ae.slice() : Object.assign({}, ae), Oe = true), xt = ae, De = Mt, typeof (fe = qn) == "number" ? (o(Array.isArray(xt)), o(fe < xt.length)) : (o(!Array.isArray(xt)), o(xt[fe] !== void 0)), De === void 0 ? typeof fe == "number" ? xt.splice(fe, 1) : delete xt[fe] : xt[fe] = De) : o(Mt === void 0), Qe.ascend(), Ge.ascend();
        }), Ie.end(), Je.end(), Ee != null) Ee.i = ae;
        else if (!$t && !wt && at == null) return ae;
      }(z, z.clone(), B, B.clone(), void 0, false, j, _e), j.reset(), j.mergeTree(_e.get()), j.reset(), j.get(), Q.map((K) => K.get()), ee.map((K) => K.get()), z.traverse(j, (K, ce) => {
        const Me = K.p;
        if (Me != null) {
          const Ae = X[Me];
          Ae != null && ce.write("p", Ae);
          const Re = Q[Me];
          Re && Re.get(), Re && ce.mergeTree(Re.get());
        } else K.r !== void 0 && ce.write("r", K.r);
      }), j.reset(), j.get(), B.traverse(j, (K, ce) => {
        const Me = K.d;
        if (Me != null) {
          const Re = ne[Me];
          Re != null && ce.write("d", Re);
          const ke = ee[Me];
          ke && ce.mergeTree(ke.get());
        } else K.i !== void 0 && ce.write("i", K.i);
        const Ae = W(K);
        Ae && !de.has(K) && C(ce, Ae, w(K));
      }), j.get();
    }
    function T(I) {
      if (I == null) return null;
      const L = new s.ReadCursor(I), Y = new s.WriteCursor();
      let z;
      const B = [], j = [];
      return function Q(ee, U, G) {
        const X = ee.getComponent();
        let ne, de = false;
        if (X) {
          X.p != null && (U.write("d", X.p), B[X.p] = ee.clone()), X.r !== void 0 && U.write("i", X.r), X.d != null && (U.write("p", X.d), G = void 0), X.i !== void 0 && (G = ne = X.i);
          const K = W(X);
          K && (G === void 0 ? (z || (z = /* @__PURE__ */ new Set()), z.add(X)) : (w(X), G = K.apply(G, w(X)), de = true));
        }
        let _e = 0;
        for (const K of ee) {
          U.descend(K);
          const ce = typeof K == "number" ? K - _e : K, Me = _(G, ce);
          h(ee.getComponent()) && _e++;
          const Ae = Q(ee, U, Me);
          if (G !== void 0 && Ae !== void 0) {
            if (de || (de = true, G = u(G)), !g(G, ce)) throw Error("Cannot modify child - invalid operation");
            G[ce] = Ae;
          }
          U.ascend();
        }
        if (ne === void 0) return de ? G : void 0;
        U.write("r", G);
      }(L, Y, void 0), z && (Y.reset(), function Q(ee, U, G) {
        const X = U.getComponent();
        if (X) {
          const K = X.d;
          if (K != null && (ee = B[K], G = j[K] = s.writeCursor()), z.has(X)) {
            const ce = W(X);
            if (!ce.invert) throw Error(`Cannot invert subtype ${ce.name}`);
            C(G, ce, ce.invert(w(X)));
          }
        }
        let ne = 0, de = 0;
        const _e = s.advancer(ee, (K, ce) => c(ce) ? ne - K - 1 : K - ne, (K, ce) => {
          c(ce) && ne++;
        });
        for (const K of U) if (typeof K == "number") {
          const ce = K - de, Me = _e(ce), Ae = ce + ne;
          G.descend(Ae), Q(Me, U, G), h(U.getComponent()) && de++, G.ascend();
        } else G.descend(K), Q(_e(K), U, G), G.ascend();
        _e.end();
      }(L.clone(), L, Y), j.length && (Y.reset(), L.traverse(Y, (Q, ee) => {
        const U = Q.p;
        if (U != null) {
          const G = j[U];
          G && G.get(), G && ee.mergeTree(G.get());
        }
      }))), Y.get();
    }
    const A = (I, L) => I.some((Y) => typeof Y == "object" && (Array.isArray(Y) ? A(Y, L) : L(Y)));
    function O(I, L) {
      if (I == null || !A(I, (U) => {
        var G;
        return U.r !== void 0 || ((G = W(U)) === null || G === void 0 ? void 0 : G.makeInvertible) != null;
      })) return I;
      const Y = new s.ReadCursor(I), z = new s.WriteCursor();
      let B = false;
      const j = [], Q = [], ee = (U, G, X) => {
        const ne = U.getComponent();
        let de = false;
        if (ne) {
          ne.d != null && G.write("d", ne.d), ne.i !== void 0 && G.write("i", ne.i);
          const K = ne.p;
          if (K != null && (j[K] = U.clone(), o(X !== void 0, "Operation picks up at an invalid key"), Q[K] = X, G.write("p", ne.p)), ne.r !== void 0 && X === void 0) throw Error("Invalid doc / op in makeInvertible: removed item missing from doc");
          const ce = W(ne);
          ce && (ce.makeInvertible ? B = true : C(G, ce, w(ne), true));
        }
        let _e = 0;
        for (const K of U) {
          G.descend(K);
          const ce = typeof K == "number" ? K - _e : K, Me = _(X, ce), Ae = ee(U, G, Me);
          Me !== Ae && (de || (de = true, X = u(X)), Ae === void 0 ? (X = d(X, ce), typeof K == "number" && _e++) : X[ce] = Ae), G.ascend();
        }
        return ne && (ne.r !== void 0 ? (G.write("r", r.default(X)), X = void 0) : ne.p != null && (X = void 0)), X;
      };
      return ee(Y, z, L), z.get(), B && (z.reset(), function U(G, X, ne, de, _e) {
        const K = X.getComponent();
        if (K) {
          K.i !== void 0 ? (de = K.i, _e = true) : K.d != null && (de = Q[K.d], G = j[K.d], _e = false, K.d);
          let Re = W(K);
          if (Re && Re.makeInvertible) {
            const ke = w(K);
            C(ne, Re, Re.makeInvertible(ke, de), true);
          }
        }
        let ce = 0, Me = 0;
        const Ae = s.advancer(G, (Re, ke) => c(ke) ? ce - Re - 1 : Re - ce, (Re, ke) => {
          c(ke) && ce++;
        });
        for (const Re of X) if (typeof Re == "number") {
          const ke = Re - Me, $t = Ae(ke), Qe = ke + ce, Ge = _(de, _e ? ke : Qe);
          ne.descend(Re), U($t, X, ne, Ge, _e), h(X.getComponent()) && Me++, ne.ascend();
        } else {
          const ke = _(de, Re);
          ne.descend(Re), U(Ae(Re), X, ne, ke, _e), ne.ascend();
        }
        Ae.end();
      }(Y.clone(), Y, z, L, false)), z.get();
    }
    function N(I, L) {
      return T(O(I, L));
    }
    const M = (I) => {
      if (I == null) return null;
      const L = I.slice();
      for (let Y = 0; Y < I.length; Y++) {
        const z = L[Y];
        Array.isArray(z) && (L[Y] = M(z));
      }
      return L;
    };
    function x(I, L, Y) {
      o(Y === "left" || Y === "right", "Direction must be left or right");
      const z = Y === "left" ? 0 : 1;
      if (L == null) return {
        ok: true,
        result: I
      };
      F2(I), F2(L);
      let B = null;
      const j = [], Q = [], ee = [], U = [], G = [], X = [], ne = [], de = [], _e = [], K = [], ce = [], Me = [], Ae = [], Re = [], ke = [];
      let $t = 0;
      const Qe = s.readCursor(I), Ge = s.readCursor(L), Fe = s.writeCursor();
      if (function ve(ae, Ee = null, ue) {
        const re = a(Ee);
        re && (re.r !== void 0 ? ue = Ee.clone() : re.p != null && (ue = null, X[re.p] = ae.clone()));
        const he = ae.getComponent();
        let Oe;
        he && (Oe = he.p) != null && (G[Oe] = Ee ? Ee.clone() : null, ee[Oe] = ae.clone(), ue && (K[Oe] = true, _e[Oe] = ue), re && re.p != null && (Re[Oe] = re.p));
        const Se = s.advancer(Ee);
        for (const be of ae) ve(ae, Se(be), ue);
        Se.end();
      }(Ge, Qe, null), function ve(ae, Ee, ue, re, he) {
        const Oe = ue.getComponent();
        let Se, be = false;
        Oe && ((Se = Oe.d) != null ? (U[Se] = ue.clone(), re != null && (ke[re] == null && (ke[re] = []), ke[re].push(Se)), K[Se], ae = G[Se] || null, Ee = ee[Se] || null, K[Se] ? (he && (ce[Se] = true), he = _e[Se] || null) : !he || z !== 1 && Re[Se] != null || B == null && (B = {
          type: i.ConflictType.RM_UNEXPECTED_CONTENT,
          op1: e.removeOp(he.getPath()),
          op2: e.moveOp(Ee.getPath(), ue.getPath())
        }), be = true) : Oe.i !== void 0 && (ae = Ee = null, be = true, he && B == null && (B = {
          type: i.ConflictType.RM_UNEXPECTED_CONTENT,
          op1: e.removeOp(he.getPath()),
          op2: e.insertOp(ue.getPath(), Oe.i)
        })));
        const Ye = a(ae);
        Ye && (Ye.r !== void 0 ? he = ae.clone() : Ye.p != null && (Ye.p, re = Ye.p, he = null));
        const je = W(Oe);
        je && he && B == null && (B = {
          type: i.ConflictType.RM_UNEXPECTED_CONTENT,
          op1: e.removeOp(he.getPath()),
          op2: e.editOp(ue.getPath(), je, w(Oe), true)
        });
        let He = 0, Je = 0;
        const Ie = s.advancer(Ee, (Ce, ze) => c(ze) ? He - Ce - 1 : Ce - He, (Ce, ze) => {
          c(ze) && He++;
        }), se = s.advancer(ae);
        for (const Ce of ue) if (typeof Ce == "number") {
          const ze = Ce - Je, nt = Ie(ze);
          Je += +ve(se(ze + He), nt, ue, re, he);
        } else {
          const ze = Ie(Ce);
          ve(se(Ce), ze, ue, re, he);
        }
        return Ie.end(), se.end(), be;
      }(Qe, Ge, Ge.clone(), null, null), U.map((ve) => ve && ve.get()), B) return {
        ok: false,
        conflict: B
      };
      ce.map((ve) => !!ve);
      const ft = [];
      let wt = null;
      (function ve(ae, Ee, ue, re, he) {
        let Oe = false;
        const Se = a(Ee);
        if (c(Se)) {
          const Ie = Se.p;
          Ie != null ? (ue = U[Ie], re = Me[Ie] = s.writeCursor(), Oe = true, he = null) : (ue = null, he = Ee.clone());
        } else h(a(ue)) && (ue = null);
        const be = ae.getComponent();
        if (be) {
          const Ie = be.p;
          Ie != null ? (he && (de[Ie] = he), ft[Ie] = he || z === 1 && Oe ? null : re.getComponent(), j[Ie] = ae.clone(), ue && (ne[Ie] = ue.clone())) : be.r !== void 0 && (he || re.write("r", true), (he || Oe) && (wt == null && (wt = /* @__PURE__ */ new Set()), wt.add(be)));
        }
        let Ye = 0, je = 0;
        const He = s.advancer(Ee, void 0, (Ie, se) => {
          c(se) && Ye++;
        }), Je = s.advancer(ue, (Ie, se) => h(se) ? ~(Ie - je) : Ie - je, (Ie, se) => {
          h(se) && je++;
        });
        if (ae) for (const Ie of ae) if (typeof Ie == "string") {
          const se = He(Ie), Ce = Je(Ie);
          re.descend(Ie), ve(ae, se, Ce, re, he), re.ascend();
        } else {
          const se = He(Ie), Ce = Ie - Ye, ze = c(a(se)) ? null : Je(Ce), nt = Ce + je;
          o(nt >= 0), re.descend(nt), ve(ae, se, ze, re, he), re.ascend();
        }
        He.end(), Je.end();
      })(Qe, Ge, Ge.clone(), Fe, null), Fe.reset();
      let sn = [];
      if (function ve(ae, Ee, ue, re, he, Oe) {
        o(Ee);
        const Se = Ee.getComponent();
        let be = a(re), Ye = false;
        const je = (fe, De, Ke) => fe ? e.moveOp(fe.getPath(), De.getPath()) : e.insertOp(De.getPath(), Ke.i);
        if (h(Se)) {
          const fe = Se.d;
          fe != null && (Q[fe] = Ee.clone());
          const De = fe != null ? ft[fe] : null;
          let Ke = false;
          if (Se.i !== void 0 || fe != null && De) {
            let $e;
            be && (be.i !== void 0 || ($e = be.d) != null && !K[$e]) && (Ke = $e != null ? fe != null && fe === Re[$e] : n.default(be.i, Se.i), Ke || $e != null && z !== 1 && Re[$e] != null || B == null && (B = {
              type: i.ConflictType.DROP_COLLISION,
              op1: je(fe != null ? j[fe] : null, Ee, Se),
              op2: je($e != null ? ee[$e] : null, re, be)
            })), Ke || (Oe ? B == null && (B = {
              type: i.ConflictType.RM_UNEXPECTED_CONTENT,
              op1: je(fe != null ? j[fe] : null, Ee, Se),
              op2: e.removeOp(Oe.getPath())
            }) : (fe != null ? (sn[$t] = fe, he.write("d", De.p = $t++)) : he.write("i", r.default(Se.i)), Ye = true));
          } else if (fe != null && !De) {
            const $e = de[fe];
            $e && (Oe = $e.clone());
          }
          fe != null ? (ae = j[fe], ue = X[fe], re = ne[fe]) : Se.i !== void 0 && (ae = ue = null, Ke || (re = null));
        } else c(a(ae)) && (ae = ue = re = null);
        const He = a(ae), Je = a(ue);
        if (c(Je)) {
          const fe = Je.p;
          Je.r !== void 0 && (!He || He.r === void 0) || K[fe] ? (re = null, Oe = ue.clone()) : fe != null && (re = U[fe], z !== 1 && Re[fe] != null || ((he = Ae[fe]) || (he = Ae[fe] = s.writeCursor()), he.reset(), Oe = null));
        } else !h(Se) && h(be) && (re = null);
        be = re != null ? re.getComponent() : null;
        const Ie = W(Se);
        if (Ie) {
          const fe = w(Se);
          if (Oe) B == null && (B = {
            type: i.ConflictType.RM_UNEXPECTED_CONTENT,
            op1: e.editOp(Ee.getPath(), Ie, fe, true),
            op2: e.removeOp(Oe.getPath())
          });
          else {
            const De = W(be);
            let Ke;
            if (De) {
              if (Ie !== De) throw Error("Transforming incompatible types");
              const $e = w(be);
              Ke = Ie.transform(fe, $e, Y);
            } else Ke = r.default(fe);
            C(he, Ie, Ke);
          }
        }
        let se = 0, Ce = 0, ze = 0, nt = 0, jt = 0, on = 0, St = ae != null && ae.descendFirst(), qn = St;
        const In = s.advancer(ue, void 0, (fe, De) => {
          c(De) && ze++;
        });
        let Mt = re != null && re.descendFirst(), xt = Mt;
        for (const fe of Ee) if (typeof fe == "number") {
          let De;
          const Ke = h(Ee.getComponent()), $e = fe - Ce;
          {
            let Kt;
            for (; St && typeof (Kt = ae.getKey()) == "number"; ) {
              Kt += se;
              const vt = ae.getComponent(), wn = c(vt);
              if (Kt > $e || Kt === $e && (!wn || z === 0 && Ke)) break;
              if (wn) {
                se--;
                const an = vt.p;
                Re.includes(an), vt.d, a(Ae[vt.d]), c(a(Ae[vt.d])), (vt.r === void 0 || wt && wt.has(vt)) && (an == null || !ft[an] || z !== 1 && Re.includes(an)) || jt--;
              }
              St = ae.nextSibling();
            }
            De = St && Kt === $e ? ae : null;
          }
          const Ot = $e - se;
          let Wt = In(Ot);
          const Ys = Ot - ze;
          let Mr = null;
          {
            let Kt, vt;
            for (; Mt && typeof (Kt = re.getKey()) == "number"; ) {
              vt = Kt - nt;
              const wn = re.getComponent(), an = h(wn);
              if (vt > Ys) break;
              if (vt === Ys) {
                if (!an) {
                  Mr = re;
                  break;
                }
                {
                  if (z === 0 && Ke) {
                    Mr = re;
                    break;
                  }
                  const Xt = Wt && c(Wt.getComponent());
                  if (z === 0 && Xt) break;
                }
              }
              if (an) {
                const Xt = wn.d;
                K[Xt], Re[Xt], wn.i === void 0 && (K[Xt] || Re[Xt] != null && z !== 1) ? (K[Xt] || Re[Xt] != null && z === 0) && (nt++, on--) : nt++;
              }
              Mt = re.nextSibling();
            }
          }
          const ia = Ys + nt + jt + on;
          o(ia >= 0, "trying to descend to a negative index"), he.descend(ia), Ke && (De = Wt = Mr = null, Ce++), ve(De, Ee, Wt, Mr, he, Oe) && on++, he.ascend();
        } else {
          let De;
          for (; St && (De = ae.getKey(), typeof De != "string" || !(De > fe || De === fe)); ) St = ae.nextSibling();
          const Ke = St && De === fe ? ae : null, $e = In(fe);
          let Ot;
          for (; Mt && (Ot = re.getKey(), typeof Ot != "string" || !(Ot > fe || Ot === fe)); ) Mt = re.nextSibling();
          const Wt = Mt && Ot === fe ? re : null;
          he.descend(fe), ve(Ke, Ee, $e, Wt, he, Oe), he.ascend();
        }
        return In.end(), qn && ae.ascend(), xt && re.ascend(), Ye;
      }(Qe, Qe.clone(), Ge, Ge.clone(), Fe, null), B) return {
        ok: false,
        conflict: B
      };
      Fe.reset();
      const mt = (ve, ae, Ee) => ve.traverse(ae, (ue, re) => {
        ue.d != null && Ee(ue.d, ve, re);
      });
      (K.length || Me.length) && (mt(Ge, Fe, (ve, ae, Ee) => {
        K[ve] && !ce[ve] && Ee.write("r", true), Me[ve] && Ee.mergeTree(Me[ve].get());
      }), Fe.reset());
      const at = [], Bt = [];
      if ((Ae.length || K.length) && !B) {
        const ve = s.readCursor(M(Fe.get()));
        if (mt(ve, null, (ae, Ee) => {
          at[ae] = Ee.clone();
        }), Ae.forEach((ae) => {
          ae && mt(s.readCursor(ae.get()), null, (Ee, ue) => {
            at[Ee] = ue.clone();
          });
        }), function ae(Ee, ue, re, he, Oe, Se) {
          const be = a(ue);
          if (be && c(be)) if (be.p != null) {
            const se = be.p;
            at[se].getPath(), re = at[se], he = Bt[se] = s.writeCursor();
          } else be.r !== void 0 && (re = null);
          else h(a(re)) && (re = null);
          const Ye = Ee.getComponent();
          if (Ye) {
            let se;
            if ((se = Ye.d) != null) {
              const Ce = Ae[se];
              Ce && (Ce.get(), he.mergeTree(Ce.get()), re = s.readCursor(Ce.get()));
            }
          }
          let je = 0, He = 0;
          const Je = s.advancer(ue, void 0, (se, Ce) => {
            c(Ce) && je--;
          }), Ie = s.advancer(re, (se, Ce) => h(Ce) ? -(se - He) - 1 : se - He, (se, Ce) => {
            h(Ce) && He++;
          });
          for (const se of Ee) if (typeof se == "number") {
            const Ce = Je(se), ze = se + je, nt = Ie(ze), jt = ze + He;
            he.descend(jt), ae(Ee, Ce, nt, he), he.ascend();
          } else he.descend(se), ae(Ee, Je(se), Ie(se), he), he.ascend();
          Je.end(), Ie.end();
        }(Ge, ve, ve.clone(), Fe), Fe.reset(), B) return {
          ok: false,
          conflict: B
        };
        if (Fe.get(), Bt.length) {
          const ae = Bt.map((ue) => ue ? ue.get() : null), Ee = s.readCursor(M(Fe.get()));
          if (mt(Ee, Fe, (ue, re, he) => {
            const Oe = ae[ue];
            Oe && (he.mergeTree(Oe), ae[ue] = null);
          }), ae.find((ue) => ue)) {
            const ue = s.writeCursor(), re = s.writeCursor();
            let he = 0, Oe = 0;
            ae.forEach((Se) => {
              Se != null && mt(s.readCursor(Se), null, (be) => {
                const Ye = sn[be];
                ue.writeMove(j[Ye].getPath(), Q[Ye].getPath(), he++);
                const je = ke[Ye];
                je && je.forEach((He) => {
                  K[He] || z !== 1 && Re[He] != null || re.writeMove(ee[He].getPath(), U[He].getPath(), Oe++);
                });
              });
            }), B = {
              type: i.ConflictType.BLACKHOLE,
              op1: ue.get(),
              op2: re.get()
            };
          }
        }
      }
      return B ? {
        ok: false,
        conflict: B
      } : {
        ok: true,
        result: Fe.get()
      };
    }
    const P = (I) => {
      const L = new Error("Transform detected write conflict");
      throw L.conflict = I, L.type = L.name = "writeConflict", L;
    };
    function q(I, L, Y) {
      const z = x(I, L, Y);
      if (z.ok) return z.result;
      P(z.conflict);
    }
    const V = (I) => {
      const L = s.writeCursor();
      return s.readCursor(I).traverse(L, (Y, z) => {
        (h(Y) || W(Y)) && z.write("r", true);
      }), L.get();
    }, oe = (I, L) => {
      const { type: Y, op1: z, op2: B } = I;
      switch (Y) {
        case i.ConflictType.DROP_COLLISION:
          return L === "left" ? [null, V(B)] : [V(z), null];
        case i.ConflictType.RM_UNEXPECTED_CONTENT:
          let j = false;
          return s.readCursor(z).traverse(null, (Q) => {
            Q.r !== void 0 && (j = true);
          }), j ? [null, V(B)] : [V(z), null];
        case i.ConflictType.BLACKHOLE:
          return [V(z), V(B)];
        default:
          throw Error("Unrecognised conflict: " + Y);
      }
    };
    function le(I, L, Y, z) {
      let B = null;
      for (; ; ) {
        const j = x(L, Y, z);
        if (j.ok) return S(B, j.result);
        {
          const { conflict: Q } = j;
          I(Q) || P(Q);
          const [ee, U] = oe(Q, z);
          L = S(H(L), ee), Y = S(H(Y), U), B = S(B, U);
        }
      }
    }
  }(Zn)), Zn;
}
var Ua;
function mg() {
  return Ua || (Ua = 1, function(e) {
    var t = ln && ln.__createBinding || (Object.create ? function(i, o, a, l) {
      l === void 0 && (l = a), Object.defineProperty(i, l, { enumerable: true, get: function() {
        return o[a];
      } });
    } : function(i, o, a, l) {
      l === void 0 && (l = a), i[l] = o[a];
    }), n = ln && ln.__exportStar || function(i, o) {
      for (var a in i) a !== "default" && !o.hasOwnProperty(a) && t(o, i, a);
    };
    Object.defineProperty(e, "__esModule", { value: true }), n(fg(), e);
    var r = gu();
    Object.defineProperty(e, "ReadCursor", { enumerable: true, get: function() {
      return r.ReadCursor;
    } }), Object.defineProperty(e, "WriteCursor", { enumerable: true, get: function() {
      return r.WriteCursor;
    } });
    var s = _u();
    Object.defineProperty(e, "ConflictType", { enumerable: true, get: function() {
      return s.ConflictType;
    } });
  }(ln)), ln;
}
var it = mg();
var gg = It(it);
var OR = Lc({
  __proto__: null,
  default: gg
}, [it]);
var pe = ((e) => (e[e.COVER = 0] = "COVER", e[e.REPLACE = 1] = "REPLACE", e))(pe || {});
var J = ((e) => (e.RETAIN = "r", e.INSERT = "i", e.DELETE = "d", e))(J || {});
var xs = createIdentifier("univer.config-service");
var _g = class {
  constructor() {
    p(this, "_configChanged$", new Subject());
    p(this, "configChanged$", this._configChanged$.asObservable());
    p(this, "_config", /* @__PURE__ */ new Map());
  }
  dispose() {
    this._config.clear(), this._configChanged$.complete();
  }
  getConfig(t) {
    return this._config.get(t);
  }
  setConfig(t, n, r) {
    var o;
    const { merge: s = false } = r || {};
    let i = (o = this._config.get(t)) != null ? o : {};
    s ? i = co(i, n) : i = n, this._config.set(t, i), this._configChanged$.next({ [t]: i });
  }
  deleteConfig(t) {
    return this._config.delete(t);
  }
  subscribeConfigValue$(t) {
    return new Observable((n) => {
      Object.prototype.hasOwnProperty.call(this._config, t) && n.next(this._config.get(t));
      const r = this.configChanged$.pipe(filter((s) => Object.prototype.hasOwnProperty.call(s, t))).subscribe((s) => n.next(s[t]));
      return () => r.unsubscribe();
    });
  }
};
var Tr = createIdentifier("univer.context-service");
var pg = class extends Ve {
  constructor() {
    super(...arguments);
    p(this, "_contextChanged$", new Subject());
    p(this, "contextChanged$", this._contextChanged$.asObservable());
    p(this, "_contextMap", /* @__PURE__ */ new Map());
  }
  dispose() {
    super.dispose(), this._contextChanged$.complete(), this._contextMap.clear();
  }
  getContextValue(n) {
    var r;
    return (r = this._contextMap.get(n)) != null ? r : false;
  }
  setContextValue(n, r) {
    this._contextMap.set(n, r), this._contextChanged$.next({ [n]: r });
  }
  subscribeContextValue$(n) {
    return new Observable((r) => {
      const s = this._contextChanged$.pipe(filter((i) => typeof i[n] < "u")).subscribe((i) => r.next(i[n]));
      return this._contextMap.has(n) && r.next(this._contextMap.get(n)), () => s.unsubscribe();
    });
  }
};
var Eg = ((e) => (e[e.SILENT = 0] = "SILENT", e[e.ERROR = 1] = "ERROR", e[e.WARN = 2] = "WARN", e[e.INFO = 3] = "INFO", e[e.VERBOSE = 4] = "VERBOSE", e))(Eg || {});
var Nt = createIdentifier("univer.log");
var Cg = class extends Ve {
  constructor() {
    super(...arguments);
    p(this, "_logLevel", 3);
    p(this, "_deduction", /* @__PURE__ */ new Set());
  }
  dispose() {
    super.dispose(), this._logLevel = 3, this._deduction.clear();
  }
  debug(...n) {
    this._logLevel >= 4 && this._log(console.debug, ...n);
  }
  log(...n) {
    this._logLevel >= 3 && this._log(console.log, ...n);
  }
  warn(...n) {
    this._logLevel >= 2 && this._log(console.warn, ...n);
  }
  error(...n) {
    this._logLevel >= 1 && this._log(console.error, ...n);
  }
  deprecate(...n) {
    this._logLevel >= 2 && this._logWithDeduplication(console.error, ...n);
  }
  setLogLevel(n) {
    this._logLevel = n;
  }
  _log(n, ...r) {
    const s = r[0];
    /^\[(.*?)\]/g.test(s) ? n(`\x1B[97;104m${s}\x1B[0m`, ...r.slice(1)) : n(...r);
  }
  _logWithDeduplication(n, ...r) {
    const s = Rg(...r);
    this._deduction.has(s) || (this._deduction.add(s), this._log(n, ...r));
  }
};
function Rg(...e) {
  return e.map((t) => JSON.stringify(t)).join("");
}
var Ig = Object.getOwnPropertyDescriptor;
var wg = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? Ig(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
};
var ti = (e, t) => (n, r) => t(n, r, e);
var yi = "command.logExecution";
var Ls = ((e) => (e[e.COMMAND = 0] = "COMMAND", e[e.OPERATION = 1] = "OPERATION", e[e.MUTATION = 2] = "MUTATION", e))(Ls || {});
var Ds = createIdentifier("univer.core.command-service");
var Sg = class {
  constructor() {
    p(this, "_commands", /* @__PURE__ */ new Map());
    p(this, "_commandTypes", /* @__PURE__ */ new Map());
  }
  registerCommand(t) {
    if (this._commands.has(t.id))
      throw new Error(`[CommandRegistry]: command "${t.id}" has been registered before.`);
    return this._commands.set(t.id, t), this._commandTypes.set(t.id, t.type), Be(() => {
      this.unregisterCommand(t.id);
    });
  }
  unregisterCommand(t) {
    this._commands.delete(t), this._commandTypes.delete(t);
  }
  hasCommand(t) {
    return this._commands.has(t);
  }
  getCommand(t) {
    return this._commands.has(t) ? [this._commands.get(t)] : null;
  }
  getCommandType(t) {
    return this._commandTypes.get(t);
  }
};
var Og = {
  id: "nil",
  type: 0,
  handler: () => true
};
var Ni = class extends Ve {
  constructor(t, n, r) {
    super();
    p(this, "_commandRegistry");
    p(this, "_beforeCommandExecutionListeners", []);
    p(this, "_commandExecutedListeners", []);
    p(this, "_collabMutationListeners", []);
    p(this, "_multiCommandDisposables", /* @__PURE__ */ new Map());
    p(this, "_commandExecutingLevel", 0);
    p(this, "_commandExecutionStack", []);
    this._injector = t, this._logService = n, this._configService = r, this._commandRegistry = new Sg(), this.registerCommand(Og);
  }
  dispose() {
    super.dispose(), this._commandExecutedListeners.length = 0, this._beforeCommandExecutionListeners.length = 0, this._collabMutationListeners.length = 0;
  }
  hasCommand(t) {
    return this._commandRegistry.hasCommand(t);
  }
  registerCommand(t) {
    return this._commandRegistry.registerCommand(t);
  }
  unregisterCommand(t) {
    var n;
    this._commandRegistry.unregisterCommand(t), (n = this._multiCommandDisposables.get(t)) == null || n.dispose();
  }
  registerMultipleCommand(t) {
    return this._registerMultiCommand(t);
  }
  beforeCommandExecuted(t) {
    if (this._beforeCommandExecutionListeners.indexOf(t) === -1)
      return this._beforeCommandExecutionListeners.push(t), Be(() => {
        const n = this._beforeCommandExecutionListeners.indexOf(t);
        this._beforeCommandExecutionListeners.splice(n, 1);
      });
    throw new Error("[CommandService]: could not add a listener twice.");
  }
  onCommandExecuted(t) {
    if (this._commandExecutedListeners.indexOf(t) === -1)
      return this._commandExecutedListeners.push(t), Be(() => {
        const n = this._commandExecutedListeners.indexOf(t);
        this._commandExecutedListeners.splice(n, 1);
      });
    throw new Error("[CommandService]: could not add a listener twice.");
  }
  onMutationExecutedForCollab(t) {
    if (this._collabMutationListeners.indexOf(t) === -1)
      return this._collabMutationListeners.push(t), Be(() => {
        const n = this._collabMutationListeners.indexOf(t);
        this._collabMutationListeners.splice(n, 1);
      });
    throw new Error("[CommandService]: could not add a collab mutation listener twice.");
  }
  executeCommand(t, n, r) {
    return __async(this, null, function* () {
      try {
        const s = this._commandRegistry.getCommand(t);
        if (s) {
          const [i] = s, o = {
            id: i.id,
            type: i.type,
            params: n
          }, a = this._pushCommandExecutionStack(o), l = r != null ? r : {};
          this._beforeCommandExecutionListeners.forEach((c) => c(o, l));
          const u = yield this._execute(i, n, l);
          return l.syncOnly ? i.type === 2 && this._collabMutationListeners.forEach((c) => c(o, l)) : (this._commandExecutedListeners.forEach((c) => c(o, l)), i.type === 2 && this._collabMutationListeners.forEach((c) => c(o, l))), a.dispose(), u;
        }
        throw new Error(`[CommandService]: command "${t}" is not registered.`);
      } catch (s) {
        if (s instanceof Ci)
          return false;
        throw s;
      }
    });
  }
  syncExecuteCommand(t, n, r) {
    var s;
    try {
      const i = this._commandRegistry.getCommand(t);
      if (i) {
        const [o] = i, a = {
          id: o.id,
          type: o.type,
          params: n
        };
        if (o.type === 2) {
          const h = Fc(
            this._commandExecutionStack,
            (d) => d.type === 0
            /* COMMAND */
          );
          h && (a.params = (s = a.params) != null ? s : {}, a.params.trigger = h.id);
        }
        const l = this._pushCommandExecutionStack(a), u = r != null ? r : {};
        this._beforeCommandExecutionListeners.forEach((h) => h(a, u));
        const c = this._syncExecute(o, n, u);
        return u.syncOnly ? o.type === 2 && this._collabMutationListeners.forEach((h) => h(a, u)) : (this._commandExecutedListeners.forEach((h) => h(a, u)), o.type === 2 && this._collabMutationListeners.forEach((h) => h(a, u))), l.dispose(), c;
      }
      throw new Error(`[CommandService]: command "${t}" is not registered.`);
    } catch (i) {
      if (i instanceof Ci)
        return false;
      throw i;
    }
  }
  _pushCommandExecutionStack(t) {
    return this._commandExecutionStack.push(t), Be(() => vs(this._commandExecutionStack, t));
  }
  _registerMultiCommand(t) {
    const n = this._commandRegistry.getCommand(t.id);
    let r;
    if (n) {
      if (n[0].multi !== true)
        throw new Error("Command has registered as a single command.");
      r = n[0];
    } else {
      r = new vg(t.id);
      const i = new ho();
      i.add(this._commandRegistry.registerCommand(r)), i.add(
        Be(() => {
          this._multiCommandDisposables.delete(t.id);
        })
      ), this._multiCommandDisposables.set(t.id, i);
    }
    const s = r.registerImplementation(t);
    return Be(() => {
      var i;
      s.dispose(), r.hasImplementations() || (i = this._multiCommandDisposables.get(t.id)) == null || i.dispose();
    });
  }
  _execute(t, n, r) {
    return __async(this, null, function* () {
      if (r != null && r.syncOnly)
        return true;
      this._configService.getConfig(yi) !== false && this._logService.debug(
        "[CommandService]",
        `${"|-".repeat(Math.max(this._commandExecutingLevel, 0))}executing command "${t.id}"`
      ), this._commandExecutingLevel++;
      let s;
      try {
        s = yield this._injector.invoke(t.handler, n, r), this._commandExecutingLevel--;
      } catch (i) {
        throw s = false, this._commandExecutingLevel = 0, i;
      }
      return s;
    });
  }
  _syncExecute(t, n, r) {
    if (r != null && r.syncOnly)
      return true;
    this._configService.getConfig(yi) !== false && this._logService.debug(
      "[CommandService]",
      `${"|-".repeat(Math.max(0, this._commandExecutingLevel))}executing command "${t.id}".`
    ), this._commandExecutingLevel++;
    let s;
    try {
      if (s = this._injector.invoke(t.handler, n, r), s instanceof Promise)
        throw new TypeError("[CommandService]: Command handler should not return a promise.");
      this._commandExecutingLevel--;
    } catch (i) {
      throw s = false, this._commandExecutingLevel = 0, i;
    }
    return s;
  }
};
Ni = wg([
  ti(0, Inject(Injector)),
  ti(1, Nt),
  ti(2, xs)
], Ni);
var vg = class {
  constructor(t) {
    p(this, "name");
    p(this, "multi", true);
    p(this, "type", 0);
    p(this, "priority", 0);
    p(this, "_implementations", []);
    p(this, "handler", (t2, n) => __async(this, null, function* () {
      if (!this._implementations.length)
        return false;
      const r = t2.get(Nt), s = t2.get(Tr), i = t2.get(Injector);
      for (const o of this._implementations) {
        const a = o.command.preconditions;
        if ((!a || a && a(s)) && (r.debug("[MultiCommand]", `executing implementation "${o.command.name}".`), yield i.invoke(o.command.handler, n)))
          return true;
      }
      return false;
    }));
    this.id = t, this.name = t;
  }
  registerImplementation(t) {
    const n = { command: t };
    return this._implementations.push(n), this._implementations.sort((r, s) => s.command.priority - r.command.priority), Be(() => {
      const r = this._implementations.indexOf(n);
      this._implementations.splice(r, 1);
    });
  }
  hasImplementations() {
    return this._implementations.length > 0;
  }
};
function po(e, t, n) {
  const r = e.map((s) => () => t.syncExecuteCommand(s.id, s.params, n));
  return rm(r);
}
function vR(e, t, n) {
  const r = e.map((s) => () => t.executeCommand(s.id, s.params, n));
  return nm(r);
}
function bg(e) {
  return new Observable((t) => {
    const n = e((...r) => t.next(r));
    return () => n == null ? void 0 : n.dispose();
  });
}
function Pa(e) {
  return function(n) {
    return new Observable((r) => (n.subscribe({
      next: (s) => {
        r.next(s), e(s) && r.complete();
      },
      complete: () => r.complete(),
      error: (s) => r.error(s)
    }), () => r.unsubscribe()));
  };
}
function bR(e = 0) {
  return (t) => {
    let n = [];
    return t.pipe(
      tap((r) => n.push(r)),
      debounceTime(e),
      map(() => n),
      tap(() => n = [])
    );
  };
}
function AR(e) {
  const t = new ReplaySubject(1);
  return setTimeout(() => t.next(), e), t.pipe(take(1));
}
function yR(e, t) {
  const n = new BehaviorSubject(t);
  return e.subscribe(n), n;
}
var NR = (e) => new Promise((t) => {
  merge(
    bg(e.onCommandExecuted.bind(e)).pipe(filter(([n]) => n.type === Ls.MUTATION)),
    timer(300)
  ).pipe(debounceTime(16), first()).subscribe(() => {
    t();
  });
});
function Ag(e, t) {
  let n = 0, r = e.length - 1;
  if (t < e[0]) return 0;
  if (t >= e[e.length - 1]) return e.length - 1;
  for (; n <= r; ) {
    if (e[n] === t) {
      for (; n < e.length && e[n] === t; )
        n++;
      return n;
    }
    if (t > e[n] && t < e[n + 1])
      return n + 1;
    if (e[r] === t) {
      for (; r < e.length && e[r] === t; )
        r++;
      return r;
    }
    if (t > e[r - 1] && t < e[r])
      return r;
    n++, r--;
  }
  return -1;
}
function TR(e, t) {
  let n = 0, r = e.length - 1;
  for (; n <= r; ) {
    const s = Math.floor((r + n) / 2);
    if (t < e[s] && (s === 0 || t >= e[s - 1]))
      return s;
    if (t >= e[s])
      n = s + 1;
    else if (t < e[s])
      r = s - 1;
    else
      return -1;
  }
  return -1;
}
function yg(e, t) {
  let n = 0, r = e.length;
  for (; n < r; ) {
    const s = Math.floor((n + r) / 2);
    e[s] <= t ? n = s + 1 : r = s;
  }
  return n < e.length ? n : e.length - 1;
}
function Fr(e, t, n = false) {
  let r = e.length - 1;
  if (t < 0 || t < e[0])
    return 0;
  if (e.length < 40 || t <= e[20] || t >= e[r - 20] ? r = Ag(e, t) : r = yg(e, t), n) {
    const s = e[r];
    return e.indexOf(s);
  }
  return r;
}
function MR(e) {
  const t = new Blob([e], { type: "text/javascript" });
  return window.URL.createObjectURL(t);
}
var Hr = 2;
var Ng = 1;
function xR(e, t) {
  if (t == null || e == null)
    return true;
  const { left: n = 0, top: r = 0, height: s = 0, width: i = 0, angle: o = 0 } = t, { left: a = 0, top: l = 0, height: u = 0, width: c = 0, angle: h = 0 } = e, d = c, f = u, g = i, _ = s;
  return Math.abs(a - n) > Hr || Math.abs(l - r) > Hr || Math.abs(d - g) > Hr || Math.abs(f - _) > Hr || Math.abs(h - o) > Ng;
}
function ni(e, t, n) {
  const { dataStream: r, textRuns: s = [] } = e;
  let i = t;
  const o = [];
  for (const a of s) {
    const { st: l, ed: u } = a;
    Z.hasIntersectionBetweenTwoRanges(t, n, l, u) && (l > i ? (o.push(r.slice(i, l)), o.push(ka(r, __spreadProps(__spreadValues({}, a), {
      ed: Math.min(u, n)
    })))) : o.push(ka(r, __spreadProps(__spreadValues({}, a), {
      st: i,
      ed: Math.min(u, n)
    })))), i = Math.max(t, Math.min(u, n));
  }
  return i !== n && o.push(r.slice(i, n)), o.join("");
}
function LR(e, t = true) {
  var n;
  if (t && ((n = e.paragraphs) != null && n.length)) {
    const { dataStream: r, paragraphs: s = [] } = e;
    let i = "", o = -1;
    for (const a of s) {
      const { startIndex: l, paragraphStyle: u = {} } = a, { spaceAbove: c, spaceBelow: h, lineSpacing: d } = u, f = [];
      c != null && (typeof c == "number" ? f.push(`margin-top: ${c}px`) : f.push(`margin-top: ${c.v}px`)), h != null && (typeof h == "number" ? f.push(`margin-bottom: ${h}px`) : f.push(`margin-bottom: ${h.v}px`)), d != null && f.push(`line-height: ${d}`), l > o + 1 ? i += `<p class="UniverNormal" ${f.length ? `style="${f.join("; ")};"` : ""}>${ni(e, o + 1, l)}</p>` : i += `<p class="UniverNormal" ${f.length ? `style="${f.join("; ")};"` : ""}></p>`, o = l;
    }
    return o !== r.length && (i += ni(e, o, r.length)), i;
  } else
    return ni(e, 0, e.dataStream.length);
}
function ka(e, t) {
  const { st: n, ed: r, ts: s = {} } = t, { ff: i, fs: o, it: a, bl: l, ul: u, st: c, ol: h, bg: d, cl: f, va: g } = s;
  let _ = e.slice(n, r);
  const R = [];
  return a === ie.TRUE && (_ = `<i>${_}</i>`), g === Zt.SUPERSCRIPT ? _ = `<sup>${_}</sup>` : g === Zt.SUBSCRIPT && (_ = `<sub>${_}</sub>`), (u == null ? void 0 : u.s) === ie.TRUE && (_ = `<u>${_}</u>`), (c == null ? void 0 : c.s) === ie.TRUE && (_ = `<s>${_}</s>`), l === ie.TRUE && (_ = `<strong>${_}</strong>`), i && R.push(`font-family: ${i}`), f && R.push(`color: ${f.rgb}`), o && R.push(`font-size: ${o}pt`), h && R.push("text-decoration: overline"), d && R.push(`background: ${d.rgb}`), R.length ? `<span style="${R.join("; ")};">${_}</span>` : _;
}
var Tg = {
  [go.OFFICE]: {
    [st.ACCENT1]: "#4472C4",
    [st.ACCENT2]: "#ED7D31",
    [st.ACCENT3]: "#A5A5A5",
    [st.ACCENT4]: "#70AD47",
    [st.ACCENT5]: "#5B9BD5",
    [st.ACCENT6]: "#70AD47",
    [st.DARK1]: "#000000",
    [st.DARK2]: "#44546A",
    [st.LIGHT1]: "#FFFFFF",
    [st.LIGHT2]: "#E7E6E6",
    [st.HYPERLINK]: "#0563C1",
    [st.FOLLOWED_HYPERLINK]: "#954F72"
  }
};
var Eo = class {
  constructor() {
    p(this, "_themeValue", st.LIGHT1);
    p(this, "_themeColors");
    p(this, "_themeTint");
    p(this, "_rgbValue", "");
    p(this, "_colorType");
    this._colorType = yt.UNSUPPORTED, this._themeColors = go.OFFICE, this._themeTint = 0;
  }
  asRgbColor() {
    return new Ti(this._rgbValue, this);
  }
  asThemeColor() {
    return new Mi(this._themeValue, this._themeTint, this._themeColors, this);
  }
  build() {
    switch (this._colorType) {
      case yt.THEME:
        return this.asThemeColor();
      case yt.RGB:
        return this.asRgbColor();
      case yt.UNSUPPORTED:
        throw new Error("unsupported color type");
    }
  }
  setRgbColor(t) {
    return this._colorType = yt.RGB, this._rgbValue = t, this;
  }
  setThemeColors(t) {
    this._colorType = yt.THEME, this._themeColors = t;
  }
  setThemeTint(t) {
    this._colorType = yt.THEME, this._themeTint = t;
  }
  setThemeColor(t) {
    return this._colorType = yt.THEME, this._themeValue = t, this;
  }
  getColorType() {
    return this._colorType;
  }
};
var Wn = class _Wn {
  constructor(t) {
    p(this, "_builder");
    this._builder = t;
  }
  static rgbColorToHexValue(t) {
    return `#${((1 << 24) + (t.getRed() << 16) + (t.getGreen() << 8) + t.getBlue()).toString(16).slice(1)}`;
  }
  static hexValueToRgbColor(t) {
    t ? t.indexOf("#") > -1 && (t = t.substring(1)) : t = "#000000";
    const n = +`0x${t[0]}${t[1]}`, r = +`0x${t[2]}${t[3]}`, s = +`0x${t[4]}${t[5]}`;
    return new Eo().setRgbColor(`rgb(${n},${r},${s})`).asRgbColor();
  }
  static hexToRgbString(t) {
    const n = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    t = t.replace(n, (i, o, a, l) => o + o + a + a + l + l);
    const r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
    let s = null;
    if (r) {
      const i = Number.parseInt(r[1], 16), o = Number.parseInt(r[2], 16), a = Number.parseInt(r[3], 16);
      s = `rgba(${i},${o},${a})`;
    }
    return s;
  }
  asRgbColor() {
    return this._builder.asRgbColor();
  }
  asThemeColor() {
    return this._builder.asThemeColor();
  }
  getColorType() {
    return this._builder.getColorType();
  }
  clone() {
    return new _Wn(this._builder);
  }
  equals(t) {
    return false;
  }
};
var Mg = class {
  constructor(t) {
    p(this, "_saturation", 0);
    p(this, "_hue", 0);
    p(this, "_lightness", 0);
    p(this, "_alpha", 0);
    const n = t.getRed() / 255, r = t.getGreen() / 255, s = t.getBlue() / 255, i = t.getAlpha() / 255, o = Math.min(n, Math.min(r, s)), a = Math.max(n, Math.max(r, s)), l = a - o;
    if (a === o) {
      this._hue = 0, this._saturation = 0, this._lightness = a;
      return;
    }
    this._lightness = (o + a) / 2, this._lightness < 0.5 ? this._saturation = l / (a + o) : this._saturation = l / (2 - a - o), n === a && (this._hue = (r - s) / l), r === a && (this._hue = 2 + (s - n) / l), s === a && (this._hue = 4 + (n - r) / l), this._hue *= 60, this._hue < 0 && (this._hue += 360), this._alpha = i;
  }
  asRgbColor() {
    const t = new Eo();
    if (this._saturation === 0)
      return t.setRgbColor(
        `rgba(${this._lightness * 255},${this._lightness * 255},${this._lightness * 255},${this._alpha * 255})`
      ), t.asRgbColor();
    let n;
    this._lightness < 0.5 ? n = this._lightness * (1 + this._saturation) : n = this._lightness + this._saturation - this._lightness * this._saturation;
    const r = 2 * this._lightness - n, s = this._hue / 360, i = s + 1 / 3, o = this.setColor(n, r, i), a = this.setColor(n, r, s), l = s - 1 / 3, u = this.setColor(n, r, l);
    return t.setRgbColor(
      `rgba(${Math.round(o * 255)},${Math.round(a * 255)},${Math.round(u * 255)},${this._alpha * 255})`
    ), t.asRgbColor();
  }
  getLightness() {
    return this._lightness;
  }
  getHue() {
    return this._hue;
  }
  getSaturation() {
    return this._saturation;
  }
  getAlpha() {
    return this._alpha;
  }
  setColor(t, n, r) {
    r < 0 && (r += 1), r > 1 && (r -= 1);
    let s;
    return 6 * r < 1 ? s = n + (t - n) * 6 * r : 2 * r < 1 ? s = t : 3 * r < 2 ? s = n + (t - n) * (2 / 3 - r) * 6 : s = n, s;
  }
  setLightness(t) {
    this._lightness = t;
  }
};
var pt = class pt2 extends Wn {
  constructor(n, r) {
    super(r);
    p(this, "_cssString");
    p(this, "_red");
    p(this, "_green");
    p(this, "_blue");
    p(this, "_alpha");
    let s = n.match(pt2.RGBA_EXTRACT);
    if (s) {
      const i = +s[1], o = +s[2], a = +s[3], l = +s[4];
      this._cssString = n, this._red = i, this._green = o, this._blue = a, this._alpha = l;
      return;
    }
    if (s = n.match(pt2.RGB_EXTRACT), s) {
      const i = +s[1], o = +s[2], a = +s[3];
      this._cssString = n, this._red = i, this._green = o, this._blue = a, this._alpha = 1;
      return;
    }
    throw new Error("Invalid rgba or rgb color");
  }
  asHexString() {
    return Wn.rgbColorToHexValue(this);
  }
  getRed() {
    let n = this._red + pt2.RGB_COLOR_AMT;
    return n > 255 ? n = 255 : n < 0 && (n = 0), n;
  }
  getGreen() {
    let n = this._green + pt2.RGB_COLOR_AMT;
    return n > 255 ? n = 255 : n < 0 && (n = 0), n;
  }
  getBlue() {
    let n = this._blue + pt2.RGB_COLOR_AMT;
    return n > 255 ? n = 255 : n < 0 && (n = 0), n;
  }
  getAlpha() {
    return this._alpha;
  }
  getColorType() {
    return yt.RGB;
  }
  clone() {
    return new pt2(this._cssString, this._builder);
  }
  asThemeColor() {
    throw new Error("rgb color not support to themeColor");
  }
  equals(n) {
    return n instanceof pt2 ? n._red === this._red && n._blue === this._blue && n._green === this._green && n._alpha === this._alpha : false;
  }
  getCssString() {
    return this._cssString;
  }
};
p(pt, "RGB_COLOR_AMT", 0), p(pt, "RGBA_EXTRACT", new RegExp(
  "\\s*rgba\\s*\\((\\s*\\d+\\s*),(\\s*\\d+\\s*),(\\s*\\d+\\s*),(\\s*\\d.\\d|\\d\\s*)\\)\\s*"
)), p(pt, "RGB_EXTRACT", new RegExp("\\s*rgb\\s*\\((\\s*\\d+\\s*),(\\s*\\d+\\s*),(\\s*\\d+\\s*)\\)\\s*"));
var Ti = pt;
var Jt = class Jt2 extends Wn {
  constructor(n, r, s, i) {
    super(i);
    p(this, "_themeColorType");
    p(this, "_themeTint");
    p(this, "_themeColors");
    this._themeColorType = n, this._themeTint = r, this._themeColors = s;
  }
  lumValue(n, r) {
    if (n == null)
      return r;
    let s;
    return n < 0 ? s = r * (1 + n) : s = r * (1 - n) + (255 - 255 * (1 - n)), s;
  }
  asRgbColor() {
    const n = Tg[this._themeColors];
    if (n == null)
      throw new Error("not find themeColors type");
    const r = n[this._themeColorType];
    if (r == null)
      throw new Error("not find themeColors value");
    let s;
    if (Jt2._cacheThemeColor.has(this._themeColors)) {
      if (s = Jt2._cacheThemeColor.get(this._themeColors), s.has(this._themeColorType))
        return s.get(this._themeColorType);
    } else
      s = /* @__PURE__ */ new Map(), Jt2._cacheThemeColor.set(this._themeColors, s);
    const i = new Mg(Wn.hexValueToRgbColor(r));
    i.setLightness(this.lumValue(this._themeTint, i.getLightness() * 255) / 255);
    const o = i.asRgbColor();
    return s.set(this._themeColorType, o), o;
  }
  clone() {
    return new Jt2(this._themeColorType, this._themeTint, this._themeColors, this._builder);
  }
  equals(n) {
    return n instanceof Jt2 ? n._themeColorType === this._themeColorType : false;
  }
  getColorType() {
    return yt.THEME;
  }
  getThemeColorType() {
    return this._themeColorType;
  }
};
p(Jt, "_cacheThemeColor", /* @__PURE__ */ new Map());
var Mi = Jt;
var DR = "rgb(";
var UR = "rgba(";
var Fa = {
  aliceBlue: [240, 248, 255],
  antiqueWhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blancheAlmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueViolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlyWood: [222, 184, 135],
  cadetBlue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornFlowerBlue: [100, 149, 237],
  cornSilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkBlue: [0, 0, 139],
  darkCyan: [0, 139, 139],
  darkGoldenrod: [184, 132, 11],
  darkGray: [169, 169, 169],
  darkGreen: [0, 100, 0],
  darkGrey: [169, 169, 169],
  darkKhaki: [189, 183, 107],
  darkMagenta: [139, 0, 139],
  darkOliveGreen: [85, 107, 47],
  darkOrange: [255, 140, 0],
  darkOrchid: [153, 50, 204],
  darkRed: [139, 0, 0],
  darkSalmon: [233, 150, 122],
  darkSeaGreen: [143, 188, 143],
  darkSlateBlue: [72, 61, 139],
  darkSlateGray: [47, 79, 79],
  darkSlateGrey: [47, 79, 79],
  darkTurquoise: [0, 206, 209],
  darkViolet: [148, 0, 211],
  darkYellow: [139, 128, 0],
  deepPink: [255, 20, 147],
  deepSkyBlue: [0, 191, 255],
  dimGray: [105, 105, 105],
  dimGrey: [105, 105, 105],
  dodgerBlue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralWhite: [255, 255, 240],
  forestGreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostWhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenYellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotPink: [255, 105, 180],
  indianRed: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderBlush: [255, 240, 245],
  lawnGreen: [124, 252, 0],
  lemonChiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightCoral: [240, 128, 128],
  lightCyan: [224, 255, 255],
  lightGoldenrodYellow: [250, 250, 210],
  lightGray: [211, 211, 211],
  lightGreen: [144, 238, 144],
  lightGrey: [211, 211, 211],
  lightPink: [255, 182, 193],
  lightSalmon: [255, 160, 122],
  lightSeaGreen: [32, 178, 170],
  lightSkyBlue: [135, 206, 250],
  lightSlateGray: [119, 136, 153],
  lightSlateGrey: [119, 136, 153],
  lightSteelBlue: [176, 196, 222],
  lightYellow: [255, 255, 224],
  lime: [0, 255, 0],
  limeGreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumAquamarine: [102, 205, 170],
  mediumBlue: [0, 0, 205],
  mediumOrchid: [186, 85, 211],
  mediumPurple: [147, 112, 219],
  mediumSeaGreen: [60, 179, 113],
  mediumSlateBlue: [123, 104, 238],
  mediumSpringGreen: [0, 250, 154],
  mediumTurquoise: [72, 209, 204],
  mediumVioletRed: [199, 21, 133],
  midBightBlue: [25, 25, 112],
  mintCream: [245, 255, 250],
  mistyRose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajoWhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldLace: [253, 245, 230],
  olive: [128, 128, 0],
  oliveDrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangeRed: [255, 69, 0],
  orchid: [218, 112, 214],
  paleGoldenrod: [238, 232, 170],
  paleGreen: [152, 251, 152],
  paleTurquoise: [175, 238, 238],
  paleVioletRed: [219, 112, 147],
  papayaWhip: [255, 239, 213],
  peachPuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 203],
  powderBlue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccaPurple: [102, 51, 153],
  red: [255, 0, 0],
  rosyBrown: [188, 143, 143],
  royalBlue: [65, 105, 225],
  saddleBrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandyBrown: [244, 164, 96],
  seaGreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyBlue: [135, 206, 235],
  slateBlue: [106, 90, 205],
  slateGray: [119, 128, 144],
  slateGrey: [119, 128, 144],
  snow: [255, 255, 250],
  springGreen: [0, 255, 127],
  steelBlue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  transparent: [255, 255, 255, 0],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whiteSmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowGreen: [154, 205, 5]
};
var At = class _At {
  constructor(t) {
    p(this, "_color");
    p(this, "_rgbColor");
    p(this, "_isValid", false);
    if (t == null) {
      this._setNullColor();
      return;
    }
    if (t instanceof _At) {
      this._color = __spreadValues({}, t._color), this._rgbColor = __spreadValues({}, t._rgbColor);
      return;
    }
    const n = pu(t);
    if (n == null) {
      this._setNullColor();
      return;
    }
    this._color = n;
    const r = Pg(this._color);
    if (r == null) {
      this._setNullColor();
      return;
    }
    this._rgbColor = r, this._isValid = true;
  }
  static mix(t, n, r) {
    var u, c;
    r = Math.min(1, Math.max(0, r));
    const s = new _At(t).toRgb(), i = new _At(n).toRgb(), o = (u = s.a) != null ? u : 1, a = (c = i.a) != null ? c : 1, l = {
      r: (i.r - s.r) * r + s.r,
      g: (i.g - s.g) * r + s.g,
      b: (i.b - s.b) * r + s.b,
      a: (a - o) * r + o
    };
    return new _At(l);
  }
  static getContrastRatio(t, n) {
    const r = new _At(t).getLuminance(), s = new _At(n).getLuminance();
    return (Math.max(r, s) + 0.05) / (Math.min(r, s) + 0.05);
  }
  get isValid() {
    return this._isValid;
  }
  toRgb() {
    return this._rgbColor;
  }
  toRgbString() {
    const { r: t, g: n, b: r, a: s = 1 } = this.toRgb(), i = s < 1;
    return `rgb${i ? "a" : ""}(${t},${n},${r}${i ? `,${s}` : ""})`;
  }
  toString() {
    return this.toRgbString();
  }
  toHexString(t) {
    const { r: n, g: r, b: s, a: i = 1 } = this.toRgb(), o = i < 1, a = [
      $r(Math.round(n).toString(16)),
      $r(Math.round(r).toString(16)),
      $r(Math.round(s).toString(16)),
      $r(Math.round(i * 255).toString(16))
    ];
    return t && a[0][0] === a[0][1] && a[1][0] === a[1][1] && a[2][0] === a[2][1] && a[3][0] === a[3][1] ? o ? `#${a[0][0]}${a[1][0]}${a[2][0]}${a[3][0]}` : `#${a[0][0]}${a[1][0]}${a[2][0]}` : o ? `#${a[0]}${a[1]}${a[2]}${a[3]}` : `#${a[0]}${a[1]}${a[2]}`;
  }
  toHsv() {
    return $g(this.toRgb());
  }
  toHsl() {
    return Hg(this.toRgb());
  }
  lighten(t = 10) {
    const n = this.toHsl();
    return n.l += t, n.l = Math.min(Math.max(n.l, 0), 100), new _At(n);
  }
  darken(t = 10) {
    const n = this.toHsl();
    return n.l -= t, n.l = Math.min(Math.max(n.l, 0), 100), new _At(n);
  }
  setAlpha(t) {
    return new _At(__spreadProps(__spreadValues({}, this._rgbColor), { a: t }));
  }
  getLuminance() {
    let { r: t, g: n, b: r } = this.toRgb();
    return t = ri(t), n = ri(n), r = ri(r), Number((0.2126 * t + 0.7152 * n + 0.0722 * r).toFixed(3));
  }
  getBrightness() {
    const { r: t, g: n, b: r } = this.toRgb();
    return (t * 299 + n * 587 + r * 114) / 1e3;
  }
  getAlpha() {
    var t;
    return (t = this._color.a) != null ? t : 1;
  }
  isDark() {
    return this.getBrightness() < 128;
  }
  isLight() {
    return !this.isDark();
  }
  _setNullColor() {
    this._isValid = false, this._color = {
      r: 0,
      g: 0,
      b: 0,
      a: 0
    }, this._rgbColor = {
      r: 0,
      g: 0,
      b: 0,
      a: 0
    };
  }
};
var $r = (e) => e.length === 1 ? `0${e}` : e;
var ri = (e) => (e /= 255, e <= 0.03928 ? e / 12.92 : __pow((e + 0.055) / 1.055, 2.4));
var pu = (e) => {
  if (jg(e)) {
    if ("r" in e) {
      const r = {
        r: Math.round(e.r),
        g: Math.round(e.g),
        b: Math.round(e.b)
      };
      return e.a !== void 0 && (r.a = e.a), r;
    }
    if ("l" in e) {
      const r = {
        h: Math.round(e.h),
        s: e.s,
        l: e.l
      };
      return e.a !== void 0 && (r.a = e.a), r;
    }
    const n = {
      h: Math.round(e.h),
      s: e.s,
      v: e.v
    };
    return e.a !== void 0 && (n.a = e.a), n;
  }
  const t = e.trim();
  if (Fa[t]) {
    const n = Fa[t], r = {
      r: Math.round(n[0]),
      g: Math.round(n[1]),
      b: Math.round(n[2])
    };
    return r.a = n[3] || 1, r;
  }
  if (t.startsWith("#"))
    return xg(t);
  if (t.startsWith("rgb"))
    return Lg(t);
  if (t.startsWith("hsl"))
    return Dg(t);
  if (t.startsWith("hsv"))
    return Ug(t);
};
var xg = (e) => {
  const t = e.substring(1), n = new RegExp(`.{1,${t.length >= 6 ? 2 : 1}}`, "g");
  let r = t.match(n);
  if (!r || r.length < 3)
    throw new Error(`The color '${e}' is illegal hex color`);
  r[0].length === 1 && (r = r.map((i) => i + i));
  const s = {
    r: Number.parseInt(r[0], 16),
    g: Number.parseInt(r[1], 16),
    b: Number.parseInt(r[2], 16)
  };
  return r.length > 3 && (s.a = Number.parseInt(r[3], 16) / 255), s;
};
var Lg = (e) => {
  const t = e.indexOf("(");
  if (t === -1)
    throw new Error(`The color '${e}' is illegal rgb color`);
  const n = e.substring(t + 1, e.length - 1).split(",");
  if (n.length < 3)
    throw new Error(`The color '${e}' is illegal rgb color`);
  const r = {
    r: Number.parseInt(n[0], 10),
    g: Number.parseInt(n[1], 10),
    b: Number.parseInt(n[2], 10)
  };
  return n.length > 3 && (r.a = Number.parseFloat(n[3])), r;
};
var Dg = (e) => {
  const t = e.indexOf("(");
  if (t === -1)
    throw new Error(`The color '${e}' is illegal hsl color`);
  const n = e.substring(t + 1, e.length - 1).split(",");
  if (n.length < 3)
    throw new Error(`The color '${e}' is illegal hsl color`);
  const r = {
    h: Number.parseInt(n[0], 10),
    s: Number.parseFloat(n[1]),
    l: Number.parseFloat(n[2])
  };
  return n.length > 3 && (r.a = Number.parseFloat(n[3])), r;
};
var Ug = (e) => {
  const t = e.indexOf("(");
  if (t === -1)
    throw new Error(`The color '${e}' is illegal hsv color`);
  const n = e.substring(t + 1, e.length - 1).split(",");
  if (n.length < 3)
    throw new Error(`The color '${e}' is illegal hsv color`);
  const r = {
    h: Number.parseInt(n[0], 10),
    s: Number.parseFloat(n[1]),
    v: Number.parseFloat(n[2])
  };
  return n.length > 3 && (r.a = Number.parseFloat(n[3])), r;
};
var Pg = (e) => {
  const t = pu(e);
  if (t != null)
    return "r" in t ? t : "l" in t ? kg(t) : Fg(t);
};
var si = (e, t, n) => (n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e);
var kg = (e) => {
  let { h: t, s: n, l: r } = e;
  t /= 360, n /= 100, r /= 100;
  let s = 0, i = 0, o = 0;
  if (n === 0)
    s = i = o = r;
  else {
    const l = r < 0.5 ? r * (1 + n) : r + n - r * n, u = 2 * r - l;
    s = si(u, l, t + 1 / 3), i = si(u, l, t), o = si(u, l, t - 1 / 3);
  }
  const a = {
    r: Math.round(s * 255),
    g: Math.round(i * 255),
    b: Math.round(o * 255)
  };
  return e.a !== void 0 && (a.a = e.a), a;
};
var Fg = (e) => {
  let { h: t, s: n, v: r } = e;
  t = t / 360 * 6, n /= 100, r /= 100;
  const s = Math.floor(t), i = t - s, o = r * (1 - n), a = r * (1 - i * n), l = r * (1 - (1 - i) * n), u = s % 6, c = [r, a, o, o, l, r][u], h = [l, r, r, a, o, o][u], d = [o, o, l, r, r, a][u], f = {
    r: c * 255,
    g: h * 255,
    b: d * 255
  };
  return e.a !== void 0 && (f.a = e.a), f;
};
var Hg = (e) => {
  let { r: t, g: n, b: r } = e;
  t /= 255, n /= 255, r /= 255;
  const s = Math.max(t, n, r), i = Math.min(t, n, r), o = (s + i) / 2;
  let a, l;
  if (s === i)
    a = l = 0;
  else {
    const c = s - i;
    switch (l = o > 0.5 ? c / (2 - s - i) : c / (s + i), s) {
      case t:
        a = (n - r) / c + (n < r ? 6 : 0);
        break;
      case n:
        a = (r - t) / c + 2;
        break;
      default:
        a = (t - n) / c + 4;
        break;
    }
    a /= 6;
  }
  const u = {
    h: Math.round(a * 360),
    s: Math.round(l * 100),
    l: Math.round(o * 100)
  };
  return e.a !== void 0 && (u.a = e.a), u;
};
var $g = (e) => {
  let { r: t, g: n, b: r } = e;
  t /= 255, n /= 255, r /= 255;
  const s = Math.max(t, n, r), i = Math.min(t, n, r);
  let o;
  const a = s, l = s - i, u = s === 0 ? 0 : l / s;
  if (s === i)
    o = 0;
  else {
    switch (s) {
      case t:
        o = (n - r) / l + (n < r ? 6 : 0);
        break;
      case n:
        o = (r - t) / l + 2;
        break;
      default:
        o = (t - n) / l + 4;
        break;
    }
    o /= 6;
  }
  const c = {
    h: Math.round(o * 360),
    s: Math.round(u * 100),
    v: Math.round(a * 100)
  };
  return e.a !== void 0 && (c.a = e.a), c;
};
var Bg = (e) => e == null;
var jg = (e) => !Bg(e) && typeof e == "object";
function PR(e) {
  const t = /^#(?:[0]{3}|[0]{6})\b/, n = /^rgb\s*\(\s*0+\s*,\s*0+\s*,\s*0+\s*\)$/, r = /^rgba\s*\(\s*0+\s*,\s*0+\s*,\s*0+\s*,\s*(1|1\.0*|0?\.\d+)\)$/, s = /^hsl\s*\(\s*0*\s*,\s*0%*\s*,\s*0%*\s*\)$/, i = /^hsla\s*\(\s*0*\s*,\s*0%*\s*,\s*0%*\s*,\s*(1|1\.0*|0?\.\d+)\)$/;
  return !!(t.test(e) || n.test(e) || r.test(e) || s.test(e) || i.test(e));
}
function kR(e) {
  const t = /^#(?:[Ff]{3}|[Ff]{6})\b/, n = /^rgb\s*\(\s*255\s*,\s*255\s*,\s*255\s*\)$/, r = /^rgba\s*\(\s*255\s*,\s*255\s*,\s*255\s*,\s*(1|1\.0*|0?\.\d+)\)$/, s = /^hsl\s*\(\s*0*\s*,\s*0%*\s*,\s*100%*\s*\)$/, i = /^hsla\s*\(\s*0*\s*,\s*0%*\s*,\s*100%*\s*,\s*(1|1\.0*|0?\.\d+)\)$/;
  return !!(t.test(e) || n.test(e) || r.test(e) || s.test(e) || i.test(e));
}
function Wg(e) {
  return e && (e.s !== void 0 || e.p !== void 0 || e.v !== void 0 || e.t !== void 0 || e.f !== void 0 || e.si !== void 0 || e.custom !== void 0);
}
function FR(e) {
  if (e.t !== void 0)
    return e.t;
  if (typeof e.v == "string")
    return mn.STRING;
  if (typeof e.v == "number")
    return mn.NUMBER;
  if (typeof e.v == "boolean")
    return mn.BOOLEAN;
}
function HR(e) {
  if (e == null)
    return true;
  const { v: t, f: n, si: r, p: s, custom: i } = e;
  return !(!(t == null || typeof t == "string" && t.length === 0) || n != null && n.length > 0 || r != null && r.length > 0 || s != null || i != null);
}
function Yg(e) {
  return e != null && (typeof e == "string" || typeof e == "number" || typeof e == "boolean");
}
var ge = ((e) => (e[e.NORMAL = 0] = "NORMAL", e[e.ROW = 1] = "ROW", e[e.COLUMN = 2] = "COLUMN", e[e.ALL = 3] = "ALL", e))(ge || {});
var ye = ((e) => (e[e.NONE = 0] = "NONE", e[e.ROW = 1] = "ROW", e[e.COLUMN = 2] = "COLUMN", e[e.ALL = 3] = "ALL", e))(ye || {});
function $R(e) {
  return [e.startRow, e.startColumn, e.endRow, e.endColumn];
}
var zg = ((e) => (e.NONE = "none", e.BACKWARD = "backward", e.FORWARD = "forward", e))(zg || {});
var Vg = ((e) => (e.RECT = "RECT", e.TEXT = "TEXT", e))(Vg || {});
function BR(e, t, n) {
  let r = false, s = false, i = e, o = t, a = e, l = t;
  if (n == null)
    return {
      actualRow: e,
      actualColumn: t,
      isMergedMainCell: s,
      isMerged: r,
      endRow: i,
      endColumn: o,
      startRow: a,
      startColumn: l
    };
  for (let u = 0; u < n.length; u++) {
    const {
      startRow: c,
      endRow: h,
      startColumn: d,
      endColumn: f
    } = n[u];
    if (e === c && t === d) {
      i = h, o = f, a = c, l = d, s = true;
      break;
    }
    if (e >= c && e <= h && t >= d && t <= f) {
      i = h, o = f, a = c, l = d, r = true;
      break;
    }
  }
  return {
    actualRow: e,
    actualColumn: t,
    isMergedMainCell: s,
    isMerged: r,
    endRow: i,
    endColumn: o,
    startRow: a,
    startColumn: l
  };
}
var ar = ((e) => (e.Raw = "raw", e.Intercepted = "intercepted", e.Both = "both", e))(ar || {});
function jR(e, t) {
  const n = {};
  for (const r in e) {
    const s = Number(r), i = e[s];
    for (const o in i) {
      const a = Number(o), l = i[a], u = t(s, a, l);
      u !== void 0 && (n[s] ? n[s][a] = u : n[s] = {
        [a]: u
      });
    }
  }
  return n;
}
function gn(e) {
  let t = 0;
  const n = Object.keys(e);
  for (const r of n) {
    const s = Number(r);
    t = Math.max(t, s);
  }
  return t + 1;
}
function WR(e, t, n) {
  const r = gn(n), s = n;
  for (let i = r - 1; i >= e; i--)
    s[i + 1] = s[i];
  s[e] = t;
}
function Ha(e, t, n) {
  const r = Object.keys(n).reduce((s, i) => Math.max(s, Number.parseInt(i)), 0) + 1;
  for (let s = e; s < r; s++)
    s < e + t ? delete n[s] : n[s] !== void 0 && (n[s - t] = n[s], delete n[s]);
}
function YR(e, t) {
  const n = e, r = Object.keys(n), s = r.length, i = t, o = Object.keys(i), a = o.length, l = {};
  let u = 0;
  for (let c = 0; c < s; c++, u++) {
    const h = r[c];
    l[u] = n[h];
  }
  for (let c = 0; c < a; c++, u++) {
    const h = o[c];
    l[u] = i[h];
  }
  return l;
}
function zR(e, t, n) {
  const r = n;
  if (gn(n) > 0) {
    const i = {};
    let o = 0;
    for (let a = e; a <= t; a++)
      r[a] && (i[o] = r[a], o++);
    return i;
  }
  return {};
}
function $a(e, t, n, r) {
  const s = e > n;
  if (!s && e + t > n)
    throw new Error("Invalid move operation");
  s ? Gg(e, t, n, r) : Kg(e, t, n, r);
}
function Gg(e, t, n, r) {
  const s = r, i = [];
  for (let o = e; o < e + t; o++)
    i.push(s[o]);
  for (let o = e - 1; o >= n; o--) {
    const a = s[o];
    s[o + t] = a, a === void 0 && delete s[o + t];
  }
  i.forEach((o, a) => {
    s[n + a] = o, o === void 0 && delete s[n + a];
  });
}
function Kg(e, t, n, r) {
  const s = r, i = [];
  for (let o = e; o < e + t; o++)
    i.push(s[o]);
  for (let o = e + t; o < n; o++) {
    const a = s[o];
    s[o - t] = a, a === void 0 && delete s[o - t];
  }
  i.forEach((o, a) => {
    s[n + a - t] = o, o === void 0 && delete s[n + a - t];
  });
}
var ht = class _ht {
  constructor(t = {}) {
    p(this, "_matrix");
    this._setOriginValue(t);
  }
  static MakeObjectMatrixSize(t) {
    return new _ht({
      [t - 1]: {}
    });
  }
  getMatrix() {
    return this._matrix;
  }
  forEach(t) {
    const n = this._matrix, r = Object.keys(n);
    for (const s of r) {
      const i = Number(s), o = n[i];
      if (t(i, o) === false)
        return this;
    }
    return this;
  }
  forRow(t) {
    const n = this._matrix, r = Object.keys(n);
    for (const s of r) {
      const i = Number(s), o = n[i];
      if (t(
        i,
        Object.keys(o).map((l) => Number(l))
      ) === false)
        return this;
    }
    return this;
  }
  /**
   * Iterate the object matrix with row priority, which means it scan the whole range row by row.
   */
  forValue(t) {
    const n = this._matrix;
    for (const r in n) {
      const s = Number(r), i = n[s];
      if (i)
        for (const o in i) {
          const a = Number(o), l = i[a];
          if (t(s, a, l) === false)
            return this;
        }
    }
    return this;
  }
  swapRow(t, n) {
    const r = this._matrix[t], s = this._matrix[n];
    this._matrix[t] = s, this._matrix[n] = r;
  }
  getRow(t) {
    return this._matrix[t];
  }
  getRowOrCreate(t) {
    let n = this.getRow(t);
    return n == null && (n = {}, this._matrix[t] = n), n;
  }
  reset() {
    this._setOriginValue({});
  }
  hasValue() {
    const t = this._matrix, n = Object.keys(t);
    if (n.length === 0)
      return false;
    for (const r of n) {
      const s = Number(r), i = t[s];
      if (Object.keys(i).length > 0)
        return true;
    }
    return false;
  }
  getValue(t, n) {
    var r, s;
    return (s = (r = this._matrix) == null ? void 0 : r[t]) == null ? void 0 : s[n];
  }
  setValue(t, n, r) {
    const s = this.getRowOrCreate(t);
    s[n] = r;
  }
  /**
   * 
   * Please +1 , who fell into this pit.
   * @deprecated use `realDelete` or `splice`
   */
  deleteValue(t, n) {
    var r, s;
    (s = (r = this._matrix) == null ? void 0 : r[t]) == null || delete s[n];
  }
  realDeleteValue(t, n) {
    var r, s, i;
    if ((s = (r = this._matrix) == null ? void 0 : r[t]) == null || delete s[n], this.getRow(t)) {
      const o = this.getRow(t);
      if (o == null)
        return;
      Object.keys(o).length === 0 && ((i = this._matrix) == null || delete i[t]);
    }
  }
  setRow(t, n) {
    this._matrix[t] = n;
  }
  moveRows(t, n, r) {
    $a(t, n, r, this._matrix);
  }
  moveColumns(t, n, r) {
    this.forEach((s, i) => {
      $a(t, n, r, i);
    });
  }
  insertRows(t, n) {
    const r = Object.keys(this._matrix);
    for (let s = r.length - 1; s >= 0; s--) {
      const i = Number(r[s]);
      if (i >= t) {
        const o = this._matrix[i];
        delete this._matrix[i], this._matrix[i + n] = o;
      }
    }
  }
  insertColumns(t, n) {
    const r = Object.keys(this._matrix);
    for (let s = 0; s < r.length; s++) {
      const i = Number(r[s]), o = this._matrix[i], a = Object.keys(o);
      for (let l = a.length - 1; l >= 0; l--) {
        const u = Number(a[l]);
        if (u >= t) {
          const c = o[u];
          delete o[u], o[u + n] = c;
        }
      }
    }
  }
  removeRows(t, n) {
    Ha(t, n, this._matrix);
  }
  removeColumns(t, n) {
    this.forEach((r, s) => {
      s && Ha(t, n, s);
    });
  }
  /**
   * Return a fragment of the original data matrix. Note that the returned matrix's row matrix would start from
   * 0 not `startRow`. Neither does its column matrix. If you want to get the original matrix, use `getSlice`.
   *
   * @param startRow
   * @param endRow
   * @param startColumn
   * @param endColumn
   * @returns
   */
  getFragment(t, n, r, s) {
    const i = new _ht();
    let o = 0;
    for (let a = t; a <= n; a++) {
      const l = {};
      let u = 0;
      for (let c = r; c <= s; c++) {
        const h = this.getValue(a, c);
        l[u] = h, u++;
      }
      i.setRow(o, l), o++;
    }
    return i;
  }
  /**
   * Return a slice of the original data matrix. Note that the returned matrix's row matrix would start from
   * `startRow` not 0, and the same does its column index. You may be looking for `getFragment` if you want
   * both of the indexes start from 0.
   *
   * @param startRow
   * @param endRow
   * @param startColumn
   * @param endColumn
   * @returns
   */
  getSlice(t, n, r, s) {
    const i = new _ht();
    for (let o = t; o <= n; o++)
      for (let a = r; a <= s; a++) {
        const l = this.getValue(o, a);
        l && i.setValue(o, a, Z.deepClone(l));
      }
    return i;
  }
  getSliceDataAndCellCountByRows(t, n) {
    const r = new _ht();
    let s = 0;
    for (let i = t; i <= n; i++) {
      const o = this.getRow(i);
      o && (r.setRow(i, o), s += Object.keys(o).length);
    }
    return {
      sliceData: r,
      cellCount: s
    };
  }
  getSizeOf() {
    return Object.keys(this._matrix).length;
  }
  getLength() {
    return gn(this._matrix);
  }
  getRange() {
    const r = this.getLength() - 1;
    let s = 0;
    const i = this.getLength();
    for (let o = 0; o < i; o++) {
      const a = this.getRow(o);
      if (a) {
        const l = gn(a) - 1;
        s = l > s ? l : s;
      }
    }
    return {
      startRow: 0,
      startColumn: 0,
      endRow: r,
      endColumn: s
    };
  }
  getRealRange() {
    const t = Object.keys(this._matrix), n = t.length, r = n > 0 ? Number(t[0]) : 0, s = n > 0 ? Number(t[n - 1]) : 0;
    let i = -1 / 0, o = 0;
    for (const a of t) {
      const l = this.getRow(Number(a));
      if (l) {
        const u = Object.keys(l);
        if (u.length > 0) {
          const c = Number(u[0]), h = Number(u[u.length - 1]);
          (i === -1 / 0 || c < i) && (i = c), h > o && (o = h);
        }
      }
    }
    return i === -1 / 0 && (i = 0), {
      startRow: r,
      endRow: s,
      startColumn: i,
      endColumn: o
    };
  }
  getRealRowRange() {
    const t = Object.keys(this._matrix), n = t.length, r = n > 0 ? Number(t[0]) : 0, s = n > 0 ? Number(t[n - 1]) : 0;
    return {
      startRow: r,
      endRow: s
    };
  }
  toNativeArray() {
    const t = new Array();
    return this.forValue((n, r, s) => {
      t.push(s);
    }), t;
  }
  toArray() {
    const t = [];
    return this.forRow((n, r) => {
      t[n] == null && (t[n] = []), r.forEach((s) => {
        t[n][s] = this.getValue(n, s);
      });
    }), t;
  }
  toFullArray() {
    const t = this.getRange(), { endColumn: n, endRow: r } = t, s = [];
    for (let i = 0; i <= r; i++) {
      const o = new Array(n + 1).fill(void 0);
      s.push(o);
    }
    return this.forValue((i, o, a) => {
      s[i][o] = a;
    }), s;
  }
  /**
   * @deprecated Use getMatrix as a substitute.
   */
  toJSON() {
    return this._matrix;
  }
  clone() {
    const t = JSON.stringify(this._matrix);
    return JSON.parse(t);
  }
  /**
   * @deprecated Use clone as a substitute.
   */
  getData() {
    const t = JSON.stringify(this._matrix);
    return JSON.parse(t);
  }
  getArrayData() {
    let t = 0, n = 0, r = false, s = false;
    const i = new _ht();
    return this.forEach((o, a) => {
      r || (r = true, t = o), Object.keys(a).forEach((l) => {
        const u = Number(l);
        s ? u < n && (n = u) : (s = true, n = u);
        const c = this.getValue(o, u);
        i.setValue(o - t, u - n, c);
      });
    }), i.getData();
  }
  /**
   * the function can only be used in all the row and column are positive integer
   * @description the positive integer in V8 Object is stored in a fast memory space and it is sorted  when we get the keys
   * @returns {IRange} the start and end scope of the matrix
   */
  getStartEndScope() {
    let t = 1 / 0, n = -1 / 0, r = 1 / 0, s = -1 / 0;
    const i = Object.keys(this._matrix);
    i.length > 0 && (t = +i[0], n = +i[i.length - 1]);
    for (const o of i) {
      const a = Object.keys(this._matrix[o]);
      a.length > 0 && (r = Math.min(r, +a[0]), s = Math.max(s, +a[a.length - 1]));
    }
    return { startRow: t, endRow: n, startColumn: r, endColumn: s };
  }
  getDataRange() {
    let t = 0, n = 0, r = 0, s = -1, i = false, o = false;
    return this.forEach((a, l) => {
      if (i || (i = true, t = a), l == null)
        return;
      const u = gn(l) - 1;
      u > r && (r = u), Object.keys(l).forEach((c) => {
        const h = Number(c);
        o ? h < n && (n = h) : (o = true, n = h);
      }), a > s && (s = a);
    }), {
      startRow: t,
      startColumn: n,
      endRow: s,
      endColumn: r
    };
  }
  getDiscreteRanges() {
    const t = [];
    return this.forEach((n, r) => {
      Object.keys(r).forEach((s) => {
        const i = Number(s);
        let o = false;
        for (const a of t)
          if (n >= a.startRow && n <= a.endRow + 1 && i >= a.startColumn && i <= a.endColumn + 1) {
            a.endRow = Math.max(n, a.endRow), a.endColumn = Math.max(i, a.endColumn), o = true;
            break;
          }
        o || t.push({
          startRow: n,
          endRow: n,
          startColumn: i,
          endColumn: i
        });
      });
    }), t;
  }
  merge(t) {
    this.forValue((n, r) => {
      const s = t.getValue(n, r);
      s != null && this.setValue(n, r, s);
    });
  }
  concatRows(t) {
    const n = t.getMatrix();
    for (const r in n) {
      const s = Number(r);
      this.setRow(s, n[s]);
    }
  }
  _setOriginValue(t = {}) {
    this._matrix = t;
  }
};
function Xg(e) {
  const { actualRow: t, actualColumn: n, isMerged: r, isMergedMainCell: s, mergeInfo: i } = e;
  let { startY: o, endY: a, startX: l, endX: u } = e, c = t, h = n, d = t, f = n;
  if (r && i) {
    const {
      startRow: g,
      startColumn: _,
      endRow: R,
      endColumn: b,
      startY: $,
      endY: k,
      startX: W,
      endX: w
    } = i;
    c = g, h = _, d = R, f = b, o = $, a = k, l = W, u = w;
  }
  return s && (o = i.startY, a = i.endY, l = i.startX, u = i.endX, d = i.endRow, f = i.endColumn), {
    startRow: c,
    startColumn: h,
    endRow: d,
    endColumn: f,
    startY: o,
    endY: a,
    startX: l,
    endX: u
  };
}
var VR = Xg;
function GR(e) {
  if (!e)
    return;
  const {
    actualRow: t,
    actualColumn: n,
    isMerged: r,
    isMergedMainCell: s,
    startRow: i,
    startColumn: o,
    endRow: a,
    endColumn: l
  } = e;
  let u = t, c = n, h = t, d = n;
  return (r || s) && (u = i, c = o, h = a, d = l), {
    startRow: u,
    startColumn: c,
    endRow: h,
    endColumn: d
  };
}
function qg(e) {
  var n;
  return !e || (((n = e == null ? void 0 : e.v) == null ? void 0 : n.toString()) || "").length === 0 && !e.p;
}
function Ba(e) {
  return qg(e) && (e == null ? void 0 : e.coverable) !== false;
}
function Yt(e) {
  if (e) {
    if (e.rgb)
      return new At(e.rgb).toHexString();
    if (e.th)
      return new Eo().setThemeColor(e.th).asThemeColor().asRgbColor().getCssString();
  }
  return null;
}
function Jg(e) {
  return Z.isString(e) && e.substring(0, 1) === "=" && e.length > 1;
}
function KR(e) {
  return Z.isString(e) && e.length > 0;
}
function XR(e, t = false) {
  var i;
  let n = "";
  const r = /* @__PURE__ */ new Map([
    [
      "ff",
      () => {
        e.ff && (n += `font-family: ${e.ff}; `);
      }
    ],
    [
      "fs",
      () => {
        if (e.fs) {
          let o = e.fs;
          e.va && (o /= 2), n += `font-size: ${o}pt; `;
        }
      }
    ],
    [
      "it",
      () => {
        e.it && (n += "font-style: italic; ");
      }
    ],
    [
      "bl",
      () => {
        e.bl && (n += "font-weight: bold; ");
      }
    ],
    [
      "ul",
      () => {
        var o;
        (o = e.ul) != null && o.s && (n.indexOf("text-decoration-line") > -1 ? n = n.replace(/(text-decoration-line:\s*[^;]+)(?=;)/g, (a, l) => `${l} underline`) : n += "text-decoration: underline; ", e.ul.cl && n.indexOf("text-decoration-color") === -1 && (n += `text-decoration-color: ${Yt(e.ul.cl)}; `), e.ul.t && n.indexOf("text-decoration-style") === -1 && (n += `text-decoration-style: ${e.ul.t} `));
      }
    ],
    [
      "st",
      () => {
        var o;
        (o = e.st) != null && o.s && (n.indexOf("text-decoration-line") > -1 ? n = n.replace(/(text-decoration-line:\s*[^;]+)(?=;)/g, (a, l) => `${l} line-through`) : n += "text-decoration-line: line-through; ", e.st.cl && n.indexOf("text-decoration-color") === -1 && (n += `text-decoration-color: ${Yt(e.st.cl)}; `), e.st.t && n.indexOf("text-decoration-style") === -1 && (n += `text-decoration-style: ${e.st.t} `));
      }
    ],
    [
      "ol",
      () => {
        var o;
        (o = e.ol) != null && o.s && (n.indexOf("text-decoration-line") > -1 ? n = n.replace(/(text-decoration-line:\s*[^;]+)(?=;)/g, (a, l) => `${l} overline`) : n += "text-decoration-line: overline; ", e.ol.cl && n.indexOf("text-decoration-color") === -1 && (n += `text-decoration-color: ${Yt(e.ol.cl)}; `), e.ol.t && n.indexOf("text-decoration-style") === -1 && (n += `text-decoration-style: ${e.ol.t} `));
      }
    ],
    [
      "bg",
      () => {
        e.bg && (n += `background: ${Yt(e.bg)}; `);
      }
    ],
    [
      "bd",
      () => {
        var o, a, l, u, c, h, d, f, g, _, R, b;
        (o = e.bd) != null && o.b && (n += `border-bottom: ${Br((a = e.bd) == null ? void 0 : a.b.s)} ${(l = Yt(e.bd.b.cl)) != null ? l : ""}; `), (u = e.bd) != null && u.t && (n += `border-top: ${Br((c = e.bd) == null ? void 0 : c.t.s)} ${(h = Yt(e.bd.t.cl)) != null ? h : ""}; `), (d = e.bd) != null && d.r && (n += `border-right: ${Br((f = e.bd) == null ? void 0 : f.r.s)} ${(g = Yt(e.bd.r.cl)) != null ? g : ""}; `), (_ = e.bd) != null && _.l && (n += `border-left: ${Br((R = e.bd) == null ? void 0 : R.l.s)} ${(b = Yt(e.bd.l.cl)) != null ? b : ""}; `);
      }
    ],
    [
      "cl",
      () => {
        e.cl && (n += `color: ${Yt(e.cl)}; `);
      }
    ],
    [
      "va",
      () => {
        e.va === Zt.SUBSCRIPT ? n += "vertical-align: sub; " : e.va === Zt.SUPERSCRIPT && (n += "vertical-align: super; ");
      }
    ],
    [
      "td",
      () => {
        e.td === gs.LEFT_TO_RIGHT ? n += "direction: ltr; " : e.td === gs.RIGHT_TO_LEFT && (n += "direction: rtl; ");
      }
    ],
    [
      "tr",
      () => {
        var o, a, l;
        e.tr && (n += `--data-rotate: (${(o = e.tr) == null ? void 0 : o.a}deg${(a = e.tr) != null && a.v ? ` ,${(l = e.tr) == null ? void 0 : l.v}` : ""});`);
      }
    ],
    [
      "ht",
      () => {
        e.ht === Pt.LEFT ? n += "text-align: left; " : e.ht === Pt.RIGHT ? n += "text-align: right; " : e.ht === Pt.CENTER ? n += "text-align: center; " : e.ht === Pt.JUSTIFIED && (n += "text-align: justify; ");
      }
    ],
    [
      "vt",
      () => {
        e.vt === Dn.BOTTOM ? n += "vertical-align: bottom; " : e.vt === Dn.TOP ? n += "vertical-align: top; " : e.vt === Dn.MIDDLE && (n += "vertical-align: middle; ");
      }
    ],
    [
      "tb",
      () => {
        e.tb === jn.CLIP ? n += "white-space: nowrap; overflow-x: hidden; " : e.tb === jn.WRAP && (n += "white-space: normal;");
      }
    ],
    [
      "pd",
      () => {
        var c, h, d, f, g, _, R, b;
        const o = `${(c = e.pd) == null ? void 0 : c.b}pt`, a = `${(h = e.pd) == null ? void 0 : h.t}pt`, l = `${(d = e.pd) == null ? void 0 : d.l}pt`, u = `${(f = e.pd) == null ? void 0 : f.r}pt`;
        (g = e.pd) != null && g.b && (n += `padding-bottom: ${o}; `), (_ = e.pd) != null && _.t && (n += `padding-top: ${a}; `), (R = e.pd) != null && R.l && (n += `padding-left: ${l}; `), (b = e.pd) != null && b.r && (n += `padding-right: ${u}; `);
      }
    ]
  ]), s = ["bd", "tr", "tb"];
  for (const o in e)
    t && s.includes(o) || (i = r.get(o)) == null || i();
  return n;
}
function Br(e) {
  let t = "";
  return e === xe.NONE ? t = "none" : e === xe.THIN ? t = "0.5pt solid" : e === xe.HAIR ? t = "0.5pt double" : e === xe.DOTTED ? t = "0.5pt dotted" : e === xe.DASHED || e === xe.DASH_DOT ? t = "0.5pt dashed" : e === xe.DASH_DOT_DOT ? t = "0.5pt dotted" : e === xe.DOUBLE ? t = "0.5pt double" : e === xe.MEDIUM ? t = "1pt solid" : e === xe.MEDIUM_DASHED || e === xe.MEDIUM_DASH_DOT ? t = "1pt dashed" : e === xe.MEDIUM_DASH_DOT_DOT ? t = "1pt dotted" : e === xe.SLANT_DASH_DOT ? t = "0.5pt dashed" : e === xe.THICK && (t = "1.5pt solid"), t;
}
function qR(e) {
  let t = 0;
  if (e = e.trim(), e === "none")
    t = xe.NONE;
  else if (e === "0.5pt solid")
    t = xe.THIN;
  else if (e === "0.5pt double")
    t = xe.HAIR;
  else if (e === "0.5pt dotted")
    t = xe.DOTTED;
  else if (e === "0.5pt dashed")
    t = xe.DASHED;
  else if (e === "1pt solid")
    t = xe.MEDIUM;
  else if (e === "1pt dashed")
    t = xe.MEDIUM_DASHED;
  else if (e === "1pt dotted")
    t = xe.MEDIUM_DASH_DOT_DOT;
  else if (e === "1.5pt solid")
    t = xe.THICK;
  else if (!e.includes("none"))
    t = xe.THIN;
  else
    return xe.NONE;
  return t;
}
function JR(e, t) {
  let n = e.body;
  if (t) {
    const { headers: r, footers: s } = e;
    r != null && r[t] ? n = r[t].body : s != null && s[t] && (n = s[t].body);
  }
  return n;
}
function ZR(e, t) {
  const { startRow: n, endRow: r, startColumn: s, endColumn: i, rangeType: o } = e;
  if (n < 0 || s < 0 || r < 0 || i < 0 || !(Number.isNaN(n) && Number.isNaN(r)) && o === ge.COLUMN || !(Number.isNaN(s) && Number.isNaN(i)) && o === ge.ROW || o !== ge.ROW && o !== ge.COLUMN && (Number.isNaN(s) || Number.isNaN(n) || Number.isNaN(i) || Number.isNaN(r)))
    return false;
  if (t) {
    const a = t.getRowCount(), l = t.getColumnCount();
    if (r >= a || i >= l)
      return false;
  }
  return true;
}
function QR(e, t) {
  return { startRow: e, endRow: e, startColumn: t, endColumn: t };
}
function ja(e) {
  return Jg(e) ? {
    f: e,
    v: null,
    p: null
  } : Yg(e) ? {
    v: e,
    p: null,
    f: null
  } : (Wg(e), e);
}
function e1(e, t) {
  const n = new ht(), { startRow: r, startColumn: s, endRow: i, endColumn: o } = t;
  if (Z.isArray(e))
    for (let a = 0; a <= i - r; a++)
      for (let l = 0; l <= o - s; l++)
        n.setValue(a + r, l + s, ja(e[a][l]));
  else
    new ht(e).forValue((l, u, c) => {
      n.setValue(l, u, ja(c));
    });
  return n.getMatrix();
}
function Eu(e, t) {
  return Object.prototype.toString.call(e) === Object.prototype.toString.call(t) ? Object.prototype.toString.call(e) === "[object Object]" || Object.prototype.toString.call(e) === "[object Array]" ? Object.keys(e).length !== Object.keys(t).length ? false : Object.keys(e).every((n) => Eu(e[n], t[n])) : e === t : false;
}
function Zg(e, t) {
  const n = e.ts || {}, r = t.ts || {};
  return e.sId !== t.sId ? false : Eu(n, r);
}
function t1(e, t) {
  return t.some((n) => e.indexOf(n) > -1);
}
var ts = { exports: {} };
var Qg = ts.exports;
var Wa;
function e_() {
  return Wa || (Wa = 1, function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(Qg, function() {
      var n = 1e3, r = 6e4, s = 36e5, i = "millisecond", o = "second", a = "minute", l = "hour", u = "day", c = "week", h = "month", d = "quarter", f = "year", g = "date", _ = "Invalid Date", R = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, b = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, $ = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(T) {
        var A = ["th", "st", "nd", "rd"], O = T % 100;
        return "[" + T + (A[(O - 20) % 10] || A[O] || A[0]) + "]";
      } }, k = function(T, A, O) {
        var N = String(T);
        return !N || N.length >= A ? T : "" + Array(A + 1 - N.length).join(O) + T;
      }, W = { s: k, z: function(T) {
        var A = -T.utcOffset(), O = Math.abs(A), N = Math.floor(O / 60), M = O % 60;
        return (A <= 0 ? "+" : "-") + k(N, 2, "0") + ":" + k(M, 2, "0");
      }, m: function T(A, O) {
        if (A.date() < O.date()) return -T(O, A);
        var N = 12 * (O.year() - A.year()) + (O.month() - A.month()), M = A.clone().add(N, h), x = O - M < 0, P = A.clone().add(N + (x ? -1 : 1), h);
        return +(-(N + (O - M) / (x ? M - P : P - M)) || 0);
      }, a: function(T) {
        return T < 0 ? Math.ceil(T) || 0 : Math.floor(T);
      }, p: function(T) {
        return { M: h, y: f, w: c, d: u, D: g, h: l, m: a, s: o, ms: i, Q: d }[T] || String(T || "").toLowerCase().replace(/s$/, "");
      }, u: function(T) {
        return T === void 0;
      } }, w = "en", C = {};
      C[w] = $;
      var v = "$isDayjsObject", y = function(T) {
        return T instanceof D || !(!T || !T[v]);
      }, F2 = function T(A, O, N) {
        var M;
        if (!A) return w;
        if (typeof A == "string") {
          var x = A.toLowerCase();
          C[x] && (M = x), O && (C[x] = O, M = x);
          var P = A.split("-");
          if (!M && P.length > 1) return T(P[0]);
        } else {
          var q = A.name;
          C[q] = A, M = q;
        }
        return !N && M && (w = M), M || !N && w;
      }, H = function(T, A) {
        if (y(T)) return T.clone();
        var O = typeof A == "object" ? A : {};
        return O.date = T, O.args = arguments, new D(O);
      }, m = W;
      m.l = F2, m.i = y, m.w = function(T, A) {
        return H(T, { locale: A.$L, utc: A.$u, x: A.$x, $offset: A.$offset });
      };
      var D = function() {
        function T(O) {
          this.$L = F2(O.locale, null, true), this.parse(O), this.$x = this.$x || O.x || {}, this[v] = true;
        }
        var A = T.prototype;
        return A.parse = function(O) {
          this.$d = function(N) {
            var M = N.date, x = N.utc;
            if (M === null) return /* @__PURE__ */ new Date(NaN);
            if (m.u(M)) return /* @__PURE__ */ new Date();
            if (M instanceof Date) return new Date(M);
            if (typeof M == "string" && !/Z$/i.test(M)) {
              var P = M.match(R);
              if (P) {
                var q = P[2] - 1 || 0, V = (P[7] || "0").substring(0, 3);
                return x ? new Date(Date.UTC(P[1], q, P[3] || 1, P[4] || 0, P[5] || 0, P[6] || 0, V)) : new Date(P[1], q, P[3] || 1, P[4] || 0, P[5] || 0, P[6] || 0, V);
              }
            }
            return new Date(M);
          }(O), this.init();
        }, A.init = function() {
          var O = this.$d;
          this.$y = O.getFullYear(), this.$M = O.getMonth(), this.$D = O.getDate(), this.$W = O.getDay(), this.$H = O.getHours(), this.$m = O.getMinutes(), this.$s = O.getSeconds(), this.$ms = O.getMilliseconds();
        }, A.$utils = function() {
          return m;
        }, A.isValid = function() {
          return this.$d.toString() !== _;
        }, A.isSame = function(O, N) {
          var M = H(O);
          return this.startOf(N) <= M && M <= this.endOf(N);
        }, A.isAfter = function(O, N) {
          return H(O) < this.startOf(N);
        }, A.isBefore = function(O, N) {
          return this.endOf(N) < H(O);
        }, A.$g = function(O, N, M) {
          return m.u(O) ? this[N] : this.set(M, O);
        }, A.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, A.valueOf = function() {
          return this.$d.getTime();
        }, A.startOf = function(O, N) {
          var M = this, x = !!m.u(N) || N, P = m.p(O), q = function(B, j) {
            var Q = m.w(M.$u ? Date.UTC(M.$y, j, B) : new Date(M.$y, j, B), M);
            return x ? Q : Q.endOf(u);
          }, V = function(B, j) {
            return m.w(M.toDate()[B].apply(M.toDate("s"), (x ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(j)), M);
          }, oe = this.$W, le = this.$M, I = this.$D, L = "set" + (this.$u ? "UTC" : "");
          switch (P) {
            case f:
              return x ? q(1, 0) : q(31, 11);
            case h:
              return x ? q(1, le) : q(0, le + 1);
            case c:
              var Y = this.$locale().weekStart || 0, z = (oe < Y ? oe + 7 : oe) - Y;
              return q(x ? I - z : I + (6 - z), le);
            case u:
            case g:
              return V(L + "Hours", 0);
            case l:
              return V(L + "Minutes", 1);
            case a:
              return V(L + "Seconds", 2);
            case o:
              return V(L + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, A.endOf = function(O) {
          return this.startOf(O, false);
        }, A.$set = function(O, N) {
          var M, x = m.p(O), P = "set" + (this.$u ? "UTC" : ""), q = (M = {}, M[u] = P + "Date", M[g] = P + "Date", M[h] = P + "Month", M[f] = P + "FullYear", M[l] = P + "Hours", M[a] = P + "Minutes", M[o] = P + "Seconds", M[i] = P + "Milliseconds", M)[x], V = x === u ? this.$D + (N - this.$W) : N;
          if (x === h || x === f) {
            var oe = this.clone().set(g, 1);
            oe.$d[q](V), oe.init(), this.$d = oe.set(g, Math.min(this.$D, oe.daysInMonth())).$d;
          } else q && this.$d[q](V);
          return this.init(), this;
        }, A.set = function(O, N) {
          return this.clone().$set(O, N);
        }, A.get = function(O) {
          return this[m.p(O)]();
        }, A.add = function(O, N) {
          var M, x = this;
          O = Number(O);
          var P = m.p(N), q = function(le) {
            var I = H(x);
            return m.w(I.date(I.date() + Math.round(le * O)), x);
          };
          if (P === h) return this.set(h, this.$M + O);
          if (P === f) return this.set(f, this.$y + O);
          if (P === u) return q(1);
          if (P === c) return q(7);
          var V = (M = {}, M[a] = r, M[l] = s, M[o] = n, M)[P] || 1, oe = this.$d.getTime() + O * V;
          return m.w(oe, this);
        }, A.subtract = function(O, N) {
          return this.add(-1 * O, N);
        }, A.format = function(O) {
          var N = this, M = this.$locale();
          if (!this.isValid()) return M.invalidDate || _;
          var x = O || "YYYY-MM-DDTHH:mm:ssZ", P = m.z(this), q = this.$H, V = this.$m, oe = this.$M, le = M.weekdays, I = M.months, L = M.meridiem, Y = function(j, Q, ee, U) {
            return j && (j[Q] || j(N, x)) || ee[Q].slice(0, U);
          }, z = function(j) {
            return m.s(q % 12 || 12, j, "0");
          }, B = L || function(j, Q, ee) {
            var U = j < 12 ? "AM" : "PM";
            return ee ? U.toLowerCase() : U;
          };
          return x.replace(b, function(j, Q) {
            return Q || function(ee) {
              switch (ee) {
                case "YY":
                  return String(N.$y).slice(-2);
                case "YYYY":
                  return m.s(N.$y, 4, "0");
                case "M":
                  return oe + 1;
                case "MM":
                  return m.s(oe + 1, 2, "0");
                case "MMM":
                  return Y(M.monthsShort, oe, I, 3);
                case "MMMM":
                  return Y(I, oe);
                case "D":
                  return N.$D;
                case "DD":
                  return m.s(N.$D, 2, "0");
                case "d":
                  return String(N.$W);
                case "dd":
                  return Y(M.weekdaysMin, N.$W, le, 2);
                case "ddd":
                  return Y(M.weekdaysShort, N.$W, le, 3);
                case "dddd":
                  return le[N.$W];
                case "H":
                  return String(q);
                case "HH":
                  return m.s(q, 2, "0");
                case "h":
                  return z(1);
                case "hh":
                  return z(2);
                case "a":
                  return B(q, V, true);
                case "A":
                  return B(q, V, false);
                case "m":
                  return String(V);
                case "mm":
                  return m.s(V, 2, "0");
                case "s":
                  return String(N.$s);
                case "ss":
                  return m.s(N.$s, 2, "0");
                case "SSS":
                  return m.s(N.$ms, 3, "0");
                case "Z":
                  return P;
              }
              return null;
            }(j) || P.replace(":", "");
          });
        }, A.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, A.diff = function(O, N, M) {
          var x, P = this, q = m.p(N), V = H(O), oe = (V.utcOffset() - this.utcOffset()) * r, le = this - V, I = function() {
            return m.m(P, V);
          };
          switch (q) {
            case f:
              x = I() / 12;
              break;
            case h:
              x = I();
              break;
            case d:
              x = I() / 3;
              break;
            case c:
              x = (le - oe) / 6048e5;
              break;
            case u:
              x = (le - oe) / 864e5;
              break;
            case l:
              x = le / s;
              break;
            case a:
              x = le / r;
              break;
            case o:
              x = le / n;
              break;
            default:
              x = le;
          }
          return M ? x : m.a(x);
        }, A.daysInMonth = function() {
          return this.endOf(h).$D;
        }, A.$locale = function() {
          return C[this.$L];
        }, A.locale = function(O, N) {
          if (!O) return this.$L;
          var M = this.clone(), x = F2(O, N, true);
          return x && (M.$L = x), M;
        }, A.clone = function() {
          return m.w(this.$d, this);
        }, A.toDate = function() {
          return new Date(this.valueOf());
        }, A.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, A.toISOString = function() {
          return this.$d.toISOString();
        }, A.toString = function() {
          return this.$d.toUTCString();
        }, T;
      }(), S = D.prototype;
      return H.prototype = S, [["$ms", i], ["$s", o], ["$m", a], ["$H", l], ["$W", u], ["$M", h], ["$y", f], ["$D", g]].forEach(function(T) {
        S[T[1]] = function(A) {
          return this.$g(A, T[0], T[1]);
        };
      }), H.extend = function(T, A) {
        return T.$i || (T(A, D, H), T.$i = true), H;
      }, H.locale = F2, H.isDayjs = y, H.unix = function(T) {
        return H(1e3 * T);
      }, H.en = C[w], H.Ls = C, H.p = {}, H;
    });
  }(ts)), ts.exports;
}
var t_ = e_();
var nn = It(t_);
var ns = { exports: {} };
var n_ = ns.exports;
var Ya;
function r_() {
  return Ya || (Ya = 1, function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(n_, function() {
      return function(n, r) {
        var s = r.prototype, i = s.format;
        s.format = function(o) {
          var a = this, l = this.$locale();
          if (!this.isValid()) return i.bind(this)(o);
          var u = this.$utils(), c = (o || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(h) {
            switch (h) {
              case "Q":
                return Math.ceil((a.$M + 1) / 3);
              case "Do":
                return l.ordinal(a.$D);
              case "gggg":
                return a.weekYear();
              case "GGGG":
                return a.isoWeekYear();
              case "wo":
                return l.ordinal(a.week(), "W");
              case "w":
              case "ww":
                return u.s(a.week(), h === "w" ? 1 : 2, "0");
              case "W":
              case "WW":
                return u.s(a.isoWeek(), h === "W" ? 1 : 2, "0");
              case "k":
              case "kk":
                return u.s(String(a.$H === 0 ? 24 : a.$H), h === "k" ? 1 : 2, "0");
              case "X":
                return Math.floor(a.$d.getTime() / 1e3);
              case "x":
                return a.$d.getTime();
              case "z":
                return "[" + a.offsetName() + "]";
              case "zzz":
                return "[" + a.offsetName("long") + "]";
              default:
                return h;
            }
          });
          return i.bind(this)(c);
        };
      };
    });
  }(ns)), ns.exports;
}
var s_ = r_();
var i_ = It(s_);
var rs = { exports: {} };
var o_ = rs.exports;
var za;
function a_() {
  return za || (za = 1, function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(o_, function() {
      var n = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, r = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, s = /\d/, i = /\d\d/, o = /\d\d?/, a = /\d*[^-_:/,()\s\d]+/, l = {}, u = function(R) {
        return (R = +R) + (R > 68 ? 1900 : 2e3);
      }, c = function(R) {
        return function(b) {
          this[R] = +b;
        };
      }, h = [/[+-]\d\d:?(\d\d)?|Z/, function(R) {
        (this.zone || (this.zone = {})).offset = function(b) {
          if (!b || b === "Z") return 0;
          var $ = b.match(/([+-]|\d\d)/g), k = 60 * $[1] + (+$[2] || 0);
          return k === 0 ? 0 : $[0] === "+" ? -k : k;
        }(R);
      }], d = function(R) {
        var b = l[R];
        return b && (b.indexOf ? b : b.s.concat(b.f));
      }, f = function(R, b) {
        var $, k = l.meridiem;
        if (k) {
          for (var W = 1; W <= 24; W += 1) if (R.indexOf(k(W, 0, b)) > -1) {
            $ = W > 12;
            break;
          }
        } else $ = R === (b ? "pm" : "PM");
        return $;
      }, g = { A: [a, function(R) {
        this.afternoon = f(R, false);
      }], a: [a, function(R) {
        this.afternoon = f(R, true);
      }], Q: [s, function(R) {
        this.month = 3 * (R - 1) + 1;
      }], S: [s, function(R) {
        this.milliseconds = 100 * +R;
      }], SS: [i, function(R) {
        this.milliseconds = 10 * +R;
      }], SSS: [/\d{3}/, function(R) {
        this.milliseconds = +R;
      }], s: [o, c("seconds")], ss: [o, c("seconds")], m: [o, c("minutes")], mm: [o, c("minutes")], H: [o, c("hours")], h: [o, c("hours")], HH: [o, c("hours")], hh: [o, c("hours")], D: [o, c("day")], DD: [i, c("day")], Do: [a, function(R) {
        var b = l.ordinal, $ = R.match(/\d+/);
        if (this.day = $[0], b) for (var k = 1; k <= 31; k += 1) b(k).replace(/\[|\]/g, "") === R && (this.day = k);
      }], w: [o, c("week")], ww: [i, c("week")], M: [o, c("month")], MM: [i, c("month")], MMM: [a, function(R) {
        var b = d("months"), $ = (d("monthsShort") || b.map(function(k) {
          return k.slice(0, 3);
        })).indexOf(R) + 1;
        if ($ < 1) throw new Error();
        this.month = $ % 12 || $;
      }], MMMM: [a, function(R) {
        var b = d("months").indexOf(R) + 1;
        if (b < 1) throw new Error();
        this.month = b % 12 || b;
      }], Y: [/[+-]?\d+/, c("year")], YY: [i, function(R) {
        this.year = u(R);
      }], YYYY: [/\d{4}/, c("year")], Z: h, ZZ: h };
      function _(R) {
        var b, $;
        b = R, $ = l && l.formats;
        for (var k = (R = b.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(H, m, D) {
          var S = D && D.toUpperCase();
          return m || $[D] || n[D] || $[S].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(T, A, O) {
            return A || O.slice(1);
          });
        })).match(r), W = k.length, w = 0; w < W; w += 1) {
          var C = k[w], v = g[C], y = v && v[0], F2 = v && v[1];
          k[w] = F2 ? { regex: y, parser: F2 } : C.replace(/^\[|\]$/g, "");
        }
        return function(H) {
          for (var m = {}, D = 0, S = 0; D < W; D += 1) {
            var T = k[D];
            if (typeof T == "string") S += T.length;
            else {
              var A = T.regex, O = T.parser, N = H.slice(S), M = A.exec(N)[0];
              O.call(m, M), H = H.replace(M, "");
            }
          }
          return function(x) {
            var P = x.afternoon;
            if (P !== void 0) {
              var q = x.hours;
              P ? q < 12 && (x.hours += 12) : q === 12 && (x.hours = 0), delete x.afternoon;
            }
          }(m), m;
        };
      }
      return function(R, b, $) {
        $.p.customParseFormat = true, R && R.parseTwoDigitYear && (u = R.parseTwoDigitYear);
        var k = b.prototype, W = k.parse;
        k.parse = function(w) {
          var C = w.date, v = w.utc, y = w.args;
          this.$u = v;
          var F2 = y[1];
          if (typeof F2 == "string") {
            var H = y[2] === true, m = y[3] === true, D = H || m, S = y[2];
            m && (S = y[2]), l = this.$locale(), !H && S && (l = $.Ls[S]), this.$d = function(N, M, x, P) {
              try {
                if (["x", "X"].indexOf(M) > -1) return new Date((M === "X" ? 1e3 : 1) * N);
                var q = _(M)(N), V = q.year, oe = q.month, le = q.day, I = q.hours, L = q.minutes, Y = q.seconds, z = q.milliseconds, B = q.zone, j = q.week, Q = /* @__PURE__ */ new Date(), ee = le || (V || oe ? 1 : Q.getDate()), U = V || Q.getFullYear(), G = 0;
                V && !oe || (G = oe > 0 ? oe - 1 : Q.getMonth());
                var X, ne = I || 0, de = L || 0, _e = Y || 0, K = z || 0;
                return B ? new Date(Date.UTC(U, G, ee, ne, de, _e, K + 60 * B.offset * 1e3)) : x ? new Date(Date.UTC(U, G, ee, ne, de, _e, K)) : (X = new Date(U, G, ee, ne, de, _e, K), j && (X = P(X).week(j).toDate()), X);
              } catch (e2) {
                return /* @__PURE__ */ new Date("");
              }
            }(C, F2, v, $), this.init(), S && S !== true && (this.$L = this.locale(S).$L), D && C != this.format(F2) && (this.$d = /* @__PURE__ */ new Date("")), l = {};
          } else if (F2 instanceof Array) for (var T = F2.length, A = 1; A <= T; A += 1) {
            y[1] = F2[A - 1];
            var O = $.apply(this, y);
            if (O.isValid()) {
              this.$d = O.$d, this.$L = O.$L, this.init();
              break;
            }
            A === T && (this.$d = /* @__PURE__ */ new Date(""));
          }
          else W.call(this, w);
        };
      };
    });
  }(rs)), rs.exports;
}
var l_ = a_();
var u_ = It(l_);
var ss = { exports: {} };
var c_ = ss.exports;
var Va;
function h_() {
  return Va || (Va = 1, function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(c_, function() {
      return function(n, r, s) {
        var i = r.prototype, o = function(h) {
          return h && (h.indexOf ? h : h.s);
        }, a = function(h, d, f, g, _) {
          var R = h.name ? h : h.$locale(), b = o(R[d]), $ = o(R[f]), k = b || $.map(function(w) {
            return w.slice(0, g);
          });
          if (!_) return k;
          var W = R.weekStart;
          return k.map(function(w, C) {
            return k[(C + (W || 0)) % 7];
          });
        }, l = function() {
          return s.Ls[s.locale()];
        }, u = function(h, d) {
          return h.formats[d] || function(f) {
            return f.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(g, _, R) {
              return _ || R.slice(1);
            });
          }(h.formats[d.toUpperCase()]);
        }, c = function() {
          var h = this;
          return { months: function(d) {
            return d ? d.format("MMMM") : a(h, "months");
          }, monthsShort: function(d) {
            return d ? d.format("MMM") : a(h, "monthsShort", "months", 3);
          }, firstDayOfWeek: function() {
            return h.$locale().weekStart || 0;
          }, weekdays: function(d) {
            return d ? d.format("dddd") : a(h, "weekdays");
          }, weekdaysMin: function(d) {
            return d ? d.format("dd") : a(h, "weekdaysMin", "weekdays", 2);
          }, weekdaysShort: function(d) {
            return d ? d.format("ddd") : a(h, "weekdaysShort", "weekdays", 3);
          }, longDateFormat: function(d) {
            return u(h.$locale(), d);
          }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
        };
        i.localeData = function() {
          return c.bind(this)();
        }, s.localeData = function() {
          var h = l();
          return { firstDayOfWeek: function() {
            return h.weekStart || 0;
          }, weekdays: function() {
            return s.weekdays();
          }, weekdaysShort: function() {
            return s.weekdaysShort();
          }, weekdaysMin: function() {
            return s.weekdaysMin();
          }, months: function() {
            return s.months();
          }, monthsShort: function() {
            return s.monthsShort();
          }, longDateFormat: function(d) {
            return u(h, d);
          }, meridiem: h.meridiem, ordinal: h.ordinal };
        }, s.months = function() {
          return a(l(), "months");
        }, s.monthsShort = function() {
          return a(l(), "monthsShort", "months", 3);
        }, s.weekdays = function(h) {
          return a(l(), "weekdays", null, null, h);
        }, s.weekdaysShort = function(h) {
          return a(l(), "weekdaysShort", "weekdays", 3, h);
        }, s.weekdaysMin = function(h) {
          return a(l(), "weekdaysMin", "weekdays", 2, h);
        };
      };
    });
  }(ss)), ss.exports;
}
var d_ = h_();
var f_ = It(d_);
var is = { exports: {} };
var m_ = is.exports;
var Ga;
function g_() {
  return Ga || (Ga = 1, function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(m_, function() {
      var n = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
      return function(r, s, i) {
        var o = s.prototype, a = o.format;
        i.en.formats = n, o.format = function(l) {
          l === void 0 && (l = "YYYY-MM-DDTHH:mm:ssZ");
          var u = this.$locale().formats, c = function(h, d) {
            return h.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(f, g, _) {
              var R = _ && _.toUpperCase();
              return g || d[_] || n[_] || d[R].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(b, $, k) {
                return $ || k.slice(1);
              });
            });
          }(l, u === void 0 ? {} : u);
          return a.call(this, c);
        };
      };
    });
  }(is)), is.exports;
}
var __ = g_();
var p_ = It(__);
var os = { exports: {} };
var E_ = os.exports;
var Ka;
function C_() {
  return Ka || (Ka = 1, function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(E_, function() {
      var n = "minute", r = /[+-]\d\d(?::?\d\d)?/g, s = /([+-]|\d\d)/g;
      return function(i, o, a) {
        var l = o.prototype;
        a.utc = function(_) {
          var R = { date: _, utc: true, args: arguments };
          return new o(R);
        }, l.utc = function(_) {
          var R = a(this.toDate(), { locale: this.$L, utc: true });
          return _ ? R.add(this.utcOffset(), n) : R;
        }, l.local = function() {
          return a(this.toDate(), { locale: this.$L, utc: false });
        };
        var u = l.parse;
        l.parse = function(_) {
          _.utc && (this.$u = true), this.$utils().u(_.$offset) || (this.$offset = _.$offset), u.call(this, _);
        };
        var c = l.init;
        l.init = function() {
          if (this.$u) {
            var _ = this.$d;
            this.$y = _.getUTCFullYear(), this.$M = _.getUTCMonth(), this.$D = _.getUTCDate(), this.$W = _.getUTCDay(), this.$H = _.getUTCHours(), this.$m = _.getUTCMinutes(), this.$s = _.getUTCSeconds(), this.$ms = _.getUTCMilliseconds();
          } else c.call(this);
        };
        var h = l.utcOffset;
        l.utcOffset = function(_, R) {
          var b = this.$utils().u;
          if (b(_)) return this.$u ? 0 : b(this.$offset) ? h.call(this) : this.$offset;
          if (typeof _ == "string" && (_ = function(w) {
            w === void 0 && (w = "");
            var C = w.match(r);
            if (!C) return null;
            var v = ("" + C[0]).match(s) || ["-", 0, 0], y = v[0], F2 = 60 * +v[1] + +v[2];
            return F2 === 0 ? 0 : y === "+" ? F2 : -F2;
          }(_), _ === null)) return this;
          var $ = Math.abs(_) <= 16 ? 60 * _ : _;
          if ($ === 0) return this.utc(R);
          var k = this.clone();
          if (R) return k.$offset = $, k.$u = false, k;
          var W = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
          return (k = this.local().add($ + W, n)).$offset = $, k.$x.$localOffset = W, k;
        };
        var d = l.format;
        l.format = function(_) {
          var R = _ || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
          return d.call(this, R);
        }, l.valueOf = function() {
          var _ = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
          return this.$d.valueOf() - 6e4 * _;
        }, l.isUTC = function() {
          return !!this.$u;
        }, l.toISOString = function() {
          return this.toDate().toISOString();
        }, l.toString = function() {
          return this.toDate().toUTCString();
        };
        var f = l.toDate;
        l.toDate = function(_) {
          return _ === "s" && this.$offset ? a(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : f.call(this);
        };
        var g = l.diff;
        l.diff = function(_, R, b) {
          if (_ && this.$u === _.$u) return g.call(this, _, R, b);
          var $ = this.local(), k = a(_).local();
          return g.call($, k, R, b);
        };
      };
    });
  }(os)), os.exports;
}
var R_ = C_();
var I_ = It(R_);
var as = { exports: {} };
var w_ = as.exports;
var Xa;
function S_() {
  return Xa || (Xa = 1, function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(w_, function() {
      return function(n, r) {
        r.prototype.weekday = function(s) {
          var i = this.$locale().weekStart || 0, o = this.$W, a = (o < i ? o + 7 : o) - i;
          return this.$utils().u(s) ? a : this.subtract(a, "day").add(s, "day");
        };
      };
    });
  }(as)), as.exports;
}
var O_ = S_();
var v_ = It(O_);
var ls = { exports: {} };
var b_ = ls.exports;
var qa;
function A_() {
  return qa || (qa = 1, function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(b_, function() {
      var n = "week", r = "year";
      return function(s, i, o) {
        var a = i.prototype;
        a.week = function(l) {
          if (l === void 0 && (l = null), l !== null) return this.add(7 * (l - this.week()), "day");
          var u = this.$locale().yearStart || 1;
          if (this.month() === 11 && this.date() > 25) {
            var c = o(this).startOf(r).add(1, r).date(u), h = o(this).endOf(n);
            if (c.isBefore(h)) return 1;
          }
          var d = o(this).startOf(r).date(u).startOf(n).subtract(1, "millisecond"), f = this.diff(d, n, true);
          return f < 0 ? o(this).startOf("week").week() : Math.ceil(f);
        }, a.weeks = function(l) {
          return l === void 0 && (l = null), this.week(l);
        };
      };
    });
  }(ls)), ls.exports;
}
var y_ = A_();
var N_ = It(y_);
var us = { exports: {} };
var T_ = us.exports;
var Ja;
function M_() {
  return Ja || (Ja = 1, function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(T_, function() {
      return function(n, r) {
        r.prototype.weekYear = function() {
          var s = this.month(), i = this.week(), o = this.year();
          return i === 1 && s === 11 ? o + 1 : s === 0 && i >= 52 ? o - 1 : o;
        };
      };
    });
  }(us)), us.exports;
}
var x_ = M_();
var L_ = It(x_);
nn.extend(u_);
nn.extend(i_);
nn.extend(v_);
nn.extend(f_);
nn.extend(N_);
nn.extend(L_);
nn.extend(I_);
nn.extend(p_);
function Co(e, t, n, r) {
  if (e > t)
    throw new Error("a1 should be less than a2");
  if (n > r)
    throw new Error("b1 should be less than b2");
  if (t < n || r < e)
    return [e, t];
  if (n <= e && r >= t)
    return [];
  const s = r - n + 1;
  return e < n && t > r ? [e, t - s] : n <= e && r < t ? [r + 1 - s, t - s] : n > e && r >= t ? [e, n - 1] : [e, t];
}
function n1(e) {
  if (e == null)
    return false;
  const t = e.bullet;
  return (t == null ? void 0 : t.listId) != null;
}
function r1(e) {
  if (e == null)
    return false;
  const t = e.paragraphStyle;
  return D_(t);
}
function D_(e) {
  var t;
  return !(e == null || (e.indentStart == null || e.indentStart.v === 0) && e.hanging == null || ((t = e.hanging) == null ? void 0 : t.v) === 0);
}
function U_(e, t, n) {
  return e.slice(0, t) + n + e.slice(t);
}
function P_(e, t, n) {
  return t > n ? e : e.slice(0, t) + e.slice(n);
}
function s1(e) {
  if (e == null || typeof e == "boolean")
    return false;
  if (typeof e == "number")
    return !isNaN(e);
  if (typeof e == "string") {
    const t = e.trim();
    return t === "" ? false : !isNaN(Number(t));
  }
  return false;
}
function i1(e) {
  let t = 0;
  for (let n = 0; n < e.length; n++)
    t = e.charCodeAt(n) + (t << 6) + (t << 16) - t;
  return t >>> 0;
}
function o1(...e) {
  let t;
  return e.length === 1 && Array.isArray(e[0]) ? t = e[0] : t = e, co({}, ...t);
}
var Te = Symbol("newer");
var Xe = Symbol("older");
var k_ = class {
  constructor(t) {
    p(this, "entry");
    this.entry = t;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const t = this.entry;
    return t ? (this.entry = t[Te], { done: false, value: t.key }) : { done: true, value: void 0 };
  }
};
var F_ = class {
  constructor(t) {
    p(this, "entry");
    this.entry = t;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const t = this.entry;
    return t ? (this.entry = t[Te], { done: false, value: t.value }) : { done: true, value: void 0 };
  }
};
var H_ = class {
  constructor(t) {
    p(this, "entry");
    this.entry = t;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const t = this.entry;
    return t ? (this.entry = t[Te], { done: false, value: [t.key, t.value] }) : { done: true, value: void 0 };
  }
};
var Dl;
var Ul;
Ul = Te, Dl = Xe;
var Za = class {
  constructor(t, n) {
    p(this, "key");
    p(this, "value");
    p(this, Ul);
    p(this, Dl);
    this.key = t, this.value = n, this[Te] = void 0, this[Xe] = void 0;
  }
  toJSON() {
    return {
      key: this.key,
      value: this.value
    };
  }
};
var _s = class {
  constructor(...t) {
    p(this, "_keymap");
    p(this, "size", 0);
    p(this, "limit");
    p(this, "oldest");
    p(this, "newest");
    p(this, "_onShiftListeners", []);
    if (jr.hasLength(t, 1)) {
      if (jr.isNumber(t[0])) {
        const n = t[0];
        this._initialize(n, void 0);
        return;
      }
      if (jr.isIterable(t[0])) {
        const n = t[0];
        this._initialize(0, n);
        return;
      }
      return;
    }
    if (jr.hasLength(t, 2)) {
      const n = t[0], r = t[1];
      this._initialize(n, r);
    }
  }
  onShift(t) {
    if (this._onShiftListeners.indexOf(t) === -1)
      return this._onShiftListeners.push(t), Be(() => vs(this._onShiftListeners, t));
    throw new Error("[LRUMap]: the listener has been registered!");
  }
  _initialize(t, n) {
    this.oldest = void 0, this.newest = void 0, this.size = 0, this.limit = t, this._keymap = /* @__PURE__ */ new Map(), n && (this.assign(n), t < 1 && (this.limit = this.size));
  }
  _markEntryAsUsed(t) {
    t !== this.newest && (t[Te] && (t === this.oldest && (this.oldest = t[Te]), t[Te][Xe] = t[Xe]), t[Xe] && (t[Xe][Te] = t[Te]), t[Te] = void 0, t[Xe] = this.newest, this.newest && (this.newest[Te] = t), this.newest = t);
  }
  assign(t) {
    let n, r = this.limit || Number.MAX_VALUE;
    this._keymap.clear();
    const s = t[Symbol.iterator]();
    for (let i = s.next(); !i.done; i = s.next()) {
      const o = new Za(i.value[0], i.value[1]);
      if (this._keymap.set(o.key, o), n ? (n[Te] = o, o[Xe] = n) : this.oldest = o, n = o, r-- === 0)
        throw new Error("overflow");
    }
    this.newest = n, this.size = this._keymap.size;
  }
  set(t, n) {
    let r = this._keymap.get(t);
    return r ? (r.value = n, this._markEntryAsUsed(r), this) : (this._keymap.set(t, r = new Za(t, n)), this.newest ? (this.newest[Te] = r, r[Xe] = this.newest) : this.oldest = r, this.newest = r, ++this.size, this.size > this.limit && this.shift(), this);
  }
  shift() {
    const t = this.oldest;
    if (t)
      return this.oldest && this.oldest[Te] ? (this.oldest = this.oldest[Te], this.oldest[Xe] = void 0) : (this.oldest = void 0, this.newest = void 0), t[Te] = t[Xe] = void 0, this._keymap.delete(t.key), --this.size, this._onShiftListeners.forEach((n) => n(t)), [t.key, t.value];
  }
  get(t) {
    const n = this._keymap.get(t);
    if (n)
      return this._markEntryAsUsed(n), n.value;
  }
  has(t) {
    return this._keymap.has(t);
  }
  find(t) {
    const n = this._keymap.get(t);
    return n ? n.value : void 0;
  }
  delete(t) {
    const n = this._keymap.get(t);
    if (n)
      return this._keymap.delete(n.key), n[Te] && n[Xe] ? (n[Xe][Te] = n[Te], n[Te][Xe] = n[Xe]) : n[Te] ? (n[Te][Xe] = void 0, this.oldest = n[Te]) : n[Xe] ? (n[Xe][Te] = void 0, this.newest = n[Xe]) : this.oldest = this.newest = void 0, this.size--, n.value;
  }
  clear() {
    this.oldest = void 0, this.newest = void 0, this.size = 0, this._keymap.clear();
  }
  keys() {
    return new k_(this.oldest);
  }
  values() {
    return new F_(this.oldest);
  }
  entries() {
    return this[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return new H_(this.oldest);
  }
  forEach(t, n) {
    typeof n != "object" && (n = this);
    let r = this.oldest;
    for (; r; )
      t.call(n, r.value, r.key, this), r = r[Te];
  }
  toJSON() {
    const t = new Array(this.size);
    let n = 0, r = this.oldest;
    for (; r; )
      t[n++] = { key: r.key, value: r.value }, r = r[Te];
    return t;
  }
  toString() {
    let t = "", n = this.oldest;
    for (; n; )
      t += `${String(n.key)}:${n.value}`, n = n[Te], n && (t += " < ");
    return t;
  }
};
var jr = class {
  static hasLength(t, n) {
    return t.length === n;
  }
  static getValueType(t) {
    return Object.prototype.toString.apply(t);
  }
  static isObject(t) {
    return this.getValueType(t) === "[object Object]";
  }
  static isIterable(t) {
    return t[Symbol.iterator] != null;
  }
  static isNumber(t) {
    return this.getValueType(t) === "[object Number]";
  }
};
var lr = 2;
var ur = __pow(2, 2);
var cs = __pow(2, 3);
var cr = __pow(2, 4);
var hr = __pow(2, 5);
var dr = __pow(2, 6);
var xi = __pow(2, 7);
var Li = __pow(2, 8);
var Di = __pow(2, 9);
var $_ = 0;
var B_ = 2958466;
var j_ = -694324;
var W_ = 35830291;
var Y_ = -1;
var Qa = 1;
var Pn = 6;
var Ro = "general";
var Io = "hash";
var kn = "zero";
var wo = "qmark";
var So = "slash";
var Sr = "group";
var ps = "scale";
var Oo = "comma";
var vo = "break";
var Us = "text";
var bo = "plus";
var Ao = "minus";
var Es = "point";
var yo = "space";
var No = "percent";
var Ps = "digit";
var To = "calendar";
var Or = "error";
var Mo = "datetime";
var xo = "duration";
var Lo = "condition";
var Do = "dbnum";
var Uo = "natnum";
var Po = "locale";
var ko = "color";
var Cu = "modifier";
var Fo = "ampm";
var Ho = "escaped";
var $o = "string";
var Bo = "skip";
var jo = "exp";
var Wo = "fill";
var Yo = "paren";
var ks = "char";
var z_ = [
  "#000",
  "#FFF",
  "#F00",
  "#0F0",
  "#00F",
  "#FF0",
  "#F0F",
  "#0FF",
  "#000",
  "#FFF",
  "#F00",
  "#0F0",
  "#00F",
  "#FF0",
  "#F0F",
  "#0FF",
  "#800",
  "#080",
  "#008",
  "#880",
  "#808",
  "#088",
  "#CCC",
  "#888",
  "#99F",
  "#936",
  "#FFC",
  "#CFF",
  "#606",
  "#F88",
  "#06C",
  "#CCF",
  "#008",
  "#F0F",
  "#FF0",
  "#0FF",
  "#808",
  "#800",
  "#088",
  "#00F",
  "#0CF",
  "#CFF",
  "#CFC",
  "#FF9",
  "#9CF",
  "#F9C",
  "#C9F",
  "#FC9",
  "#36F",
  "#3CC",
  "#9C0",
  "#FC0"
];
var Ui = [
  "",
  "$",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];
var Pi = new RegExp("[" + Ui.join("") + "]");
var ii = Object.freeze({
  1078: "af",
  // Afrikaans
  1052: "sq",
  // Albanian
  1118: "am",
  // Amharic
  5121: "ar_DZ",
  // Arabic - Algeria
  15361: "ar_BH",
  // Arabic - Bahrain
  3073: "ar_EG",
  // Arabic - Egypt
  2049: "ar_IQ",
  // Arabic - Iraq
  11265: "ar_JO",
  // Arabic - Jordan
  13313: "ar_KW",
  // Arabic - Kuwait
  12289: "ar_LB",
  // Arabic - Lebanon
  4097: "ar_LY",
  // Arabic - Libya
  6145: "ar_MA",
  // Arabic - Morocco
  8193: "ar_OM",
  // Arabic - Oman
  16385: "ar_QA",
  // Arabic - Qatar
  1025: "ar_SA",
  // Arabic - Saudi Arabia
  10241: "ar_SY",
  // Arabic - Syria
  7169: "ar_TN",
  // Arabic - Tunisia
  14337: "ar_AE",
  // Arabic - United Arab Emirates
  9217: "ar_YE",
  // Arabic - Yemen
  1067: "hy",
  // Armenian
  1101: "as",
  // Assamese
  2092: "az_AZ",
  // Azeri - Cyrillic
  1068: "az_AZ",
  // Azeri - Latin
  1069: "eu",
  // Basque
  1059: "be",
  // Belarusian
  2117: "bn",
  // Bengali - Bangladesh
  1093: "bn_IN",
  // Bengali - India
  5146: "bs",
  // Bosnian
  1026: "bg",
  // Bulgarian
  1109: "my",
  // Burmese
  1027: "ca",
  // Catalan
  2052: "zh_CN",
  // Chinese - China
  3076: "zh_HK",
  // Chinese - Hong Kong SAR
  5124: "zh_MO",
  // Chinese - Macau SAR
  4100: "zh_SG",
  // Chinese - Singapore
  1028: "zh_TW",
  // Chinese - Taiwan
  1050: "hr",
  // Croatian
  1029: "cs",
  // Czech
  1030: "da",
  // Danish
  1125: "dv",
  // Divehi; Dhivehi; Maldivian
  2067: "nl_BE",
  // Dutch - Belgium
  1043: "nl_NL",
  // Dutch - Netherlands
  1126: "bin",
  // Edo
  3081: "en_AU",
  // English - Australia
  10249: "en_BZ",
  // English - Belize
  4105: "en_CA",
  // English - Canada
  9225: "en_CB",
  // English - Caribbean
  2057: "en_GB",
  // English - Great Britain
  16393: "en_IN",
  // English - India
  6153: "en_IE",
  // English - Ireland
  8201: "en_JM",
  // English - Jamaica
  5129: "en_NZ",
  // English - New Zealand
  13321: "en_PH",
  // English - Phillippines
  7177: "en_ZA",
  // English - Southern Africa
  11273: "en_TT",
  // English - Trinidad
  1033: "en_US",
  // English - United States
  12297: "en_ZW",
  // English - Zimbabwe
  1061: "et",
  // Estonian
  1071: "mk",
  // FYRO Macedonia
  1080: "fo",
  // Faroese
  1065: "fa",
  // Farsi - Persian
  1124: "fil",
  // Filipino
  1035: "fi",
  // Finnish
  2060: "fr_BE",
  // French - Belgium
  11276: "fr_CM",
  // French - Cameroon
  3084: "fr_CA",
  // French - Canada
  9228: "fr_CG",
  // French - Congo
  12300: "fr_CI",
  // French - Cote d'Ivoire
  1036: "fr_FR",
  // French - France
  5132: "fr_LU",
  // French - Luxembourg
  13324: "fr_ML",
  // French - Mali
  6156: "fr_MC",
  // French - Monaco
  14348: "fr_MA",
  // French - Morocco
  10252: "fr_SN",
  // French - Senegal
  4108: "fr_CH",
  // French - Switzerland
  7180: "fr",
  // French - West Indies
  1122: "fy_NL",
  // Frisian - Netherlands
  2108: "gd_IE",
  // Gaelic - Ireland
  1084: "gd",
  // Gaelic - Scotland
  1110: "gl",
  // Galician
  1079: "ka",
  // Georgian
  3079: "de_AT",
  // German - Austria
  1031: "de_DE",
  // German - Germany
  5127: "de_LI",
  // German - Liechtenstein
  4103: "de_LU",
  // German - Luxembourg
  2055: "de_CH",
  // German - Switzerland
  1032: "el",
  // Greek
  1140: "gn",
  // Guarani - Paraguay
  1095: "gu",
  // Gujarati
  1279: "en",
  // HID (Human Interface Device)
  1037: "he",
  // Hebrew
  1081: "hi",
  // Hindi
  1038: "hu",
  // Hungarian
  1039: "is",
  // Icelandic
  1136: "ig_NG",
  // Igbo - Nigeria
  1057: "id",
  // Indonesian
  1040: "it_IT",
  // Italian - Italy
  2064: "it_CH",
  // Italian - Switzerland
  1041: "ja",
  // Japanese
  1099: "kn",
  // Kannada
  1120: "ks",
  // Kashmiri
  1087: "kk",
  // Kazakh
  1107: "km",
  // Khmer
  1111: "kok",
  // Konkani
  1042: "ko",
  // Korean
  1088: "ky",
  // Kyrgyz - Cyrillic
  1108: "lo",
  // Lao
  1142: "la",
  // Latin
  1062: "lv",
  // Latvian
  1063: "lt",
  // Lithuanian
  2110: "ms_BN",
  // Malay - Brunei
  1086: "ms_MY",
  // Malay - Malaysia
  1100: "ml",
  // Malayalam
  1082: "mt",
  // Maltese
  1112: "mni",
  // Manipuri
  1153: "mi",
  // Maori
  1102: "mr",
  // Marathi
  1104: "mn",
  // Mongolian
  2128: "mn",
  // Mongolian
  1121: "ne",
  // Nepali
  1044: "no_NO",
  // Norwegian - Bokml
  2068: "no_NO",
  // Norwegian - Nynorsk
  1096: "or",
  // Oriya
  1045: "pl",
  // Polish
  1046: "pt_BR",
  // Portuguese - Brazil
  2070: "pt_PT",
  // Portuguese - Portugal
  1094: "pa",
  // Punjabi
  1047: "rm",
  // Raeto-Romance
  2072: "ro_MO",
  // Romanian - Moldova
  1048: "ro_RO",
  // Romanian - Romania
  1049: "ru",
  // Russian
  2073: "ru_MO",
  // Russian - Moldova
  1083: "se",
  // Sami Lappish
  1103: "sa",
  // Sanskrit
  3098: "sr_SP",
  // Serbian - Cyrillic
  2074: "sr_SP",
  // Serbian - Latin
  1072: "st",
  // Sesotho (Sutu)
  1074: "tn",
  // Setsuana
  1113: "sd",
  // Sindhi
  1115: "si",
  // Sinhala; Sinhalese
  1051: "sk",
  // Slovak
  1060: "sl",
  // Slovenian
  1143: "so",
  // Somali
  1070: "sb",
  // Sorbian
  11274: "es_AR",
  // Spanish - Argentina
  16394: "es_BO",
  // Spanish - Bolivia
  13322: "es_CL",
  // Spanish - Chile
  9226: "es_CO",
  // Spanish - Colombia
  5130: "es_CR",
  // Spanish - Costa Rica
  7178: "es_DO",
  // Spanish - Dominican Republic
  12298: "es_EC",
  // Spanish - Ecuador
  17418: "es_SV",
  // Spanish - El Salvador
  4106: "es_GT",
  // Spanish - Guatemala
  18442: "es_HN",
  // Spanish - Honduras
  2058: "es_MX",
  // Spanish - Mexico
  19466: "es_NI",
  // Spanish - Nicaragua
  6154: "es_PA",
  // Spanish - Panama
  15370: "es_PY",
  // Spanish - Paraguay
  10250: "es_PE",
  // Spanish - Peru
  20490: "es_PR",
  // Spanish - Puerto Rico
  1034: "es_ES",
  // Spanish - Spain (Traditional)
  14346: "es_UY",
  // Spanish - Uruguay
  8202: "es_VE",
  // Spanish - Venezuela
  1089: "sw",
  // Swahili
  2077: "sv_FI",
  // Swedish - Finland
  1053: "sv_SE",
  // Swedish - Sweden
  1114: "syc",
  // Syriac
  1064: "tg",
  // Tajik
  1097: "ta",
  // Tamil
  1092: "tt",
  // Tatar
  1098: "te",
  // Telugu
  1054: "th",
  // Thai
  1105: "bo",
  // Tibetan
  1073: "ts",
  // Tsonga
  1055: "tr",
  // Turkish
  1090: "tk",
  // Turkmen
  1058: "uk",
  // Ukrainian
  1056: "ur",
  // Urdu
  2115: "uz_UZ",
  // Uzbek - Cyrillic
  1091: "uz_UZ",
  // Uzbek - Latin
  1075: "ve",
  // Venda
  1066: "vi",
  // Vietnamese
  1106: "cy",
  // Welsh
  1076: "xh",
  // Xhosa
  1085: "yi",
  // Yiddish
  1077: "zu"
  // Zulu
});
var Ru = /^([a-z\d]+)(?:[_-]([a-z\d]+))?(?:\.([a-z\d]+))?(?:@([a-z\d]+))?$/i;
var Tn = {};
var E = (e, t = "") => e.replace(/~/g, t).split(";");
var Le = (e, t = 0, n = 0) => (e.mmm || (e.mmm = t < 1 ? e.mmmm.concat() : e.mmmm.map((r) => {
  const s = r.slice(0, t % 10);
  return s + (t < 10 || r === s ? "" : ".");
})), e.ddd || (e.ddd = n < 1 ? e.dddd.concat() : e.dddd.map((r) => {
  const s = r.slice(0, n % 10);
  return s + (n < 10 || r === s ? "" : ".");
})), !e.mmm6 && e.mmmm6 && (e.mmm6 = e.mmmm6), e);
var V_ = {
  group: "",
  decimal: ".",
  positive: "+",
  negative: "-",
  percent: "%",
  exponent: "E",
  nan: "NaN",
  infinity: "",
  ampm: E("AM;PM"),
  mmmm6: E("Muharram;Safar;Rabi I;Rabi II;Jumada I;Jumada II;Rajab;Shaban;Ramadan;Shawwal;Dhul-Qidah;Dhul-Hijjah"),
  mmm6: E("Muh.;Saf.;Rab. I;Rab. II;Jum. I;Jum. II;Raj.;Sha.;Ram.;Shaw.;Dhul-Q.;Dhul-H."),
  mmmm: E("January;February;March;April;May;June;July;August;September;October;November;December"),
  mmm: E("Jan;Feb;Mar;Apr;May;Jun;Jul;Aug;Sep;Oct;Nov;Dec"),
  dddd: E("Sunday;Monday;Tuesday;Wednesday;Thursday;Friday;Saturday"),
  ddd: E("Sun;Mon;Tue;Wed;Thu;Fri;Sat"),
  bool: E("TRUE;FALSE"),
  preferMDY: false
};
function zo(e) {
  const t = Ru.exec(e);
  if (!t)
    throw new SyntaxError(`Malformed locale: ${e}`);
  return {
    lang: t[1] + (t[2] ? "_" + t[2] : ""),
    language: t[1],
    territory: t[2] || ""
  };
}
function Vo(e) {
  if (typeof e == "number")
    return ii[e & 65535] || null;
  const t = parseInt(e, 16);
  return isFinite(t) && ii[t & 65535] ? ii[t & 65535] || null : Ru.test(e) ? e : null;
}
function Xn(e) {
  const t = Vo(e);
  let n = null;
  if (t) {
    const r = zo(t);
    n = Tn[r.lang] || Tn[r.language] || null;
  }
  return n;
}
function ki(e) {
  return Object.assign({}, V_, e);
}
function te(e, t) {
  const n = typeof t == "object" ? t : zo(t);
  return Tn[n.lang] = ki(e), n.language !== n.lang && !Tn[n.language] && (Tn[n.language] = ki(e)), Tn[n.lang];
}
var Qt = ki({ group: ",", preferMDY: true });
Qt.isDefault = true;
te({
  group: ",",
  ampm: E(";"),
  mmmm: E(";;;;;;;;;;;"),
  mmm: E("1;2;3;4;5;6;7;8;9;10;11;12"),
  dddd: E("~;~;~;~;~;~;~", ""),
  ddd: E(";;;;;;")
}, "zh_CN");
var Go = {
  group: ",",
  ampm: E(";"),
  mmmm: E("1;2;3;4;5;6;7;8;9;10;11;12"),
  mmm: E("1;2;3;4;5;6;7;8;9;10;11;12"),
  dddd: E("~;~;~;~;~;~;~", ""),
  ddd: E(";;;;;;")
};
te(__spreadProps(__spreadValues({}, Go), {
  nan: "",
  dddd: E("~;~;~;~;~;~;~", "")
}), "zh_TW");
te(__spreadProps(__spreadValues({}, Go), {
  dddd: E("~;~;~;~;~;~;~", "")
}), "zh_HK");
te(__spreadProps(__spreadValues({}, Go), {
  ampm: E(";"),
  dddd: E("~;~;~;~;~;~;~", ""),
  ddd: E(";;;;;;")
}), "ja");
te({
  group: ",",
  ampm: E(";"),
  mmmm: E("1;2;3;4;5;6;7;8;9;10;11;12"),
  mmm: E("1;2;3;4;5;6;7;8;9;10;11;12"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;")
}, "ko");
te({
  group: ",",
  ampm: E(";"),
  mmmm: E("~;;~;;~;;~;~;;~;;~", ""),
  mmm: E("..;..;..;..;..;..;..;..;..;..;..;.."),
  dddd: E(";;;;;;"),
  ddd: E(".;.;.;.;.;.;.")
}, "th");
te(Le({
  decimal: ",",
  ampm: E("dop.;odp."),
  mmmm: E("ledna;nora;bezna;dubna;kvtna;ervna;ervence;srpna;z;jna;listopadu;prosince"),
  mmm: E("I;II;III;IV;V;VI;VII;VIII;IX;X;XI;XII"),
  dddd: E("nedle;pondl;ter;steda;tvrtek;ptek;sobota"),
  bool: E("PRAVDA;NEPRAVDA")
}, -1, 2), "cs");
te(Le({
  group: ".",
  decimal: ",",
  mmmm: E("januar;februar;marts;april;maj;juni;juli;august;september;oktober;november;december"),
  dddd: E("sn~;man~;tirs~;ons~;tors~;fre~;lr~", "dag"),
  bool: E("SAND;FALSK")
}, 13, 13), "da");
te(Le({
  group: ".",
  decimal: ",",
  ampm: E("a.m.;p.m."),
  mmmm: E("januari;februari;maart;april;mei;juni;juli;augustus;september;oktober;november;december"),
  mmm: E("jan.;feb.;mrt.;apr.;mei;jun.;jul.;aug.;sep.;okt.;nov.;dec."),
  dddd: E("zondag;maandag;dinsdag;woensdag;donderdag;vrijdag;zaterdag"),
  bool: E("WAAR;ONWAAR")
}, -1, 2), "nl");
te({ group: ",", preferMDY: true }, "en");
te({ group: ",", preferMDY: true }, "en_US");
te({ group: "," }, "en_AU");
te({ group: "," }, "en_CA");
te({ group: "," }, "en_GB");
te({ group: ",", mmm: E("Jan;Feb;Mar;Apr;May;Jun;Jul;Aug;Sept;Oct;Nov;Dec") }, "en_IE");
te(Le({
  decimal: ",",
  nan: "epluku",
  ampm: E("ap.;ip."),
  mmmm: E("tammi~;helmi~;maalis~;huhti~;touko~;kes~;hein~;elo~;syys~;loka~;marras~;joulu~", "kuuta"),
  mmm: E("tammik.;helmik.;maalisk.;huhtik.;toukok.;kesk.;heink.;elok.;syysk.;lokak.;marrask.;jouluk."),
  dddd: E("sunnun~;maanan~;tiis~;keskiviikkona;tors~;perjan~;lauan~", "taina"),
  bool: E("TOSI;EPTOSI")
}, -1, 2), "fi");
var Ko = Le({
  group: "",
  decimal: ",",
  mmmm: E("janvier;fvrier;mars;avril;mai;juin;juillet;aot;septembre;octobre;novembre;dcembre"),
  mmm: E("janv.;fvr.;mars;avr.;mai;juin;juil.;aot;sept.;oct.;nov.;dc."),
  dddd: E("~manche;lun~;mar~;mercre~;jeu~;vendre~;same~", "di"),
  bool: E("VRAI;FAUX")
}, -1, 13);
te(__spreadValues({}, Ko), "fr");
te(__spreadProps(__spreadValues({}, Ko), { mmm: E("janv.;fvr.;mars;avr.;mai;juin;juill.;aot;sept.;oct.;nov.;dc.") }), "fr_CA");
te(__spreadValues({ group: "'", decimal: "." }, Ko), "fr_CH");
var Iu = Le({
  mmmm: E("Januar;Februar;Mrz;April;Mai;Juni;Juli;August;September;Oktober;November;Dezember"),
  mmm: E("Jan.;Feb.;Mrz;Apr.;Mai;Juni;Juli;Aug.;Sept.;Okt.;Nov.;Dez."),
  dddd: E("Sonn~;Mon~;Diens~;Mittwoch;Donners~;Frei~;Sams~", "tag"),
  bool: E("WAHR;FALSCH")
}, -1, 12);
te(__spreadValues({ group: ".", decimal: "," }, Iu), "de");
te(__spreadValues({ group: "'", decimal: "." }, Iu), "de_CH");
te(Le({
  group: ".",
  decimal: ",",
  ampm: E("..;.."),
  mmmm: E("~;~;~;~;;~;~;;~;~;~;~", ""),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;")
}, -1, 3), "el");
te({
  decimal: ",",
  ampm: E("de.;du."),
  mmmm: E("janur;februr;mrcius;prilis;mjus;jnius;jlius;augusztus;szeptember;oktber;november;december"),
  mmm: E("jan.;febr.;mrc.;pr.;mj.;jn.;jl.;aug.;szept.;okt.;nov.;dec."),
  dddd: E("vasrnap;htf;kedd;szerda;cstrtk;pntek;szombat"),
  ddd: E("V;H;K;Sze;Cs;P;Szo"),
  bool: E("IGAZ;HAMIS")
}, "hu");
te(Le({
  group: ".",
  decimal: ",",
  ampm: E("f.h.;e.h."),
  mmmm: E("janar;febrar;mars;aprl;ma;jn;jl;gst;september;oktber;nvember;desember"),
  dddd: E("sunnu~;mnu~;riju~;miviku~;fimmtu~;fstu~;laugar~", "dagur")
}, 13, 13), "is");
te(Le({
  group: ".",
  decimal: ",",
  mmmm: E("Januari;Februari;Maret;April;Mei;Juni;Juli;Agustus;September;Oktober;November;Desember"),
  dddd: E("Minggu;Senin;Selasa;Rabu;Kamis;Jumat;Sabtu")
}, 3, 3), "id");
var wu = Le({
  mmmm: E("gennaio;febbraio;marzo;aprile;maggio;giugno;luglio;agosto;settembre;ottobre;novembre;dicembre"),
  dddd: E("domenica;luned;marted;mercoled;gioved;venerd;sabato"),
  bool: E("VERO;FALSO")
}, 3, 3);
te(__spreadValues({ group: ".", decimal: "," }, wu), "it");
te(__spreadValues({ group: "'", decimal: "." }, wu), "it_CH");
var Su = {
  decimal: ",",
  ampm: E("a.m.;p.m."),
  mmmm: E("januar;februar;mars;april;mai;juni;juli;august;september;oktober;november;desember"),
  mmm: E("jan.;feb.;mar.;apr.;mai;jun.;jul.;aug.;sep.;okt.;nov.;des."),
  dddd: E("sn~;man~;tirs~;ons~;tors~;fre~;lr~", "dag"),
  bool: E("SANN;USANN")
};
te(Le(__spreadValues({}, Su), -1, 13), "nb");
te(Le(__spreadValues({}, Su), -1, 13), "no");
te(Le({
  decimal: ",",
  mmmm: E("stycznia;lutego;marca;kwietnia;maja;czerwca;lipca;sierpnia;wrzenia;padziernika;listopada;grudnia"),
  dddd: E("niedziela;poniedziaek;wtorek;roda;czwartek;pitek;sobota"),
  ddd: E("niedz.;pon.;wt.;r.;czw.;pt.;sob."),
  bool: E("PRAWDA;FASZ")
}, 3, -1), "pl");
var Ou = {
  group: ".",
  decimal: ",",
  mmmm: E("janeiro;fevereiro;maro;abril;maio;junho;julho;agosto;setembro;outubro;novembro;dezembro"),
  dddd: E("domingo;segunda-feira;tera-feira;quarta-feira;quinta-feira;sexta-feira;sbado"),
  bool: E("VERDADEIRO;FALSO")
};
te(Le(Ou, 13, 13), "pt");
te(Le(Ou, 13, 13), "pt_BR");
te({
  decimal: ",",
  nan: "",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(".;.;.;.;;.;.;.;.;.;.;."),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;"),
  mmmm6: E(";;-;-;;--;--;--;--;;;"),
  mmm6: E(".;.;-.;-.;.;. I;. II;. I;. II;.;.;."),
  bool: E(";")
}, "ru");
te(Le({
  decimal: ",",
  mmmm: E("janura;februra;marca;aprla;mja;jna;jla;augusta;septembra;oktbra;novembra;decembra"),
  dddd: E("nedea;pondelok;utorok;streda;tvrtok;piatok;sobota")
}, 3, 2), "sk");
var Ht = {
  group: ".",
  decimal: ",",
  ampm: E("a.m.;p.m."),
  mmmm: E("enero;febrero;marzo;abril;mayo;junio;julio;agosto;septiem~;octu~;noviem~;diciem~", "bre"),
  mmm: E("ene;feb;mar;abr;may;jun;jul;ago;sept;oct;nov;dic"),
  dddd: E("domingo;lunes;martes;mircoles;jueves;viernes;sbado"),
  ddd: E("dom;lun;mar;mi;jue;vie;sb"),
  bool: E("VERDADERO;FALSO")
};
var G_ = E("ene;feb;mar;abr;may;jun;jul;ago;sep;oct;nov;dic");
var Xo = E("ene.;feb.;mar.;abr.;may.;jun.;jul.;ago.;sept.;oct.;nov.;dic.");
te(__spreadValues({}, Ht), "es");
te(__spreadValues({}, Ht), "es_AR");
te(__spreadValues({}, Ht), "es_BO");
te(__spreadValues({}, Ht), "es_CL");
te(__spreadValues({}, Ht), "es_CO");
te(__spreadValues({}, Ht), "es_EC");
te(__spreadProps(__spreadValues({}, Ht), { mmm: G_, ampm: E("a.m.;p.m.") }), "es_MX");
te(__spreadProps(__spreadValues({}, Ht), { mmm: Xo }), "es_PY");
te(__spreadProps(__spreadValues({}, Ht), { mmm: Xo }), "es_UY");
te(__spreadProps(__spreadValues({}, Ht), { mmm: Xo, mmmm: E("enero;febrero;marzo;abril;mayo;junio;julio;agosto;setiembre;octubre;noviembre;diciembre") }), "es_VE");
te({
  decimal: ",",
  ampm: E("fm;em"),
  mmmm: E("januari;februari;mars;april;maj;juni;juli;augusti;september;oktober;november;december"),
  mmm: E("jan.;feb.;mars;apr.;maj;juni;juli;aug.;sep.;okt.;nov.;dec."),
  dddd: E("sn~;mn~;tis~;ons~;tors~;fre~;lr~", "dag"),
  ddd: E("sn;mn;tis;ons;tors;fre;lr")
}, "sv");
te(Le({
  group: ".",
  decimal: ",",
  ampm: E(";S"),
  mmmm: E("Ocak;ubat;Mart;Nisan;Mays;Haziran;Temmuz;Austos;Eyll;Ekim;Kasm;Aralk"),
  mmm: E("Oca;ub;Mar;Nis;May;Haz;Tem;Au;Eyl;Eki;Kas;Ara"),
  dddd: E("Pazar;Pazartesi;Sal;aramba;Perembe;Cuma;Cumartesi"),
  ddd: E("Paz;Pzt;Sal;ar;Per;Cum;Cmt"),
  bool: E("DORU;YANLI")
}, 3, -1), "tr");
te({
  group: ",",
  ampm: E("yb;yh"),
  mmmm: E("Ionawr;Chwefror;Mawrth;Ebrill;Mai;Mehefin;Gorffennaf;Awst;Medi;Hydref;Tachwedd;Rhagfyr"),
  mmm: E("Ion;Chwef;Maw;Ebr;Mai;Meh;Gorff;Awst;Medi;Hyd;Tach;Rhag"),
  dddd: E("Dydd Sul;Dydd Llun;Dydd Mawrth;Dydd Mercher;Dydd Iau;Dydd Gwener;Dydd Sadwrn"),
  ddd: E("Sul;Llun;Maw;Mer;Iau;Gwen;Sad")
}, "cy");
te({
  group: ".",
  decimal: ",",
  mmmm: E("yanvar;fevral;mart;aprel;may;iyun;iyul;avqust;sentyabr;oktyabr;noyabr;dekabr"),
  mmm: E("yan;fev;mar;apr;may;iyn;iyl;avq;sen;okt;noy;dek"),
  dddd: E("bazar;bazar ertsi;rnb axam;rnb;cm axam;cm;nb"),
  ddd: E("B.;B.e.;.a.;.;C.a.;C.;.")
}, "az");
te(Le({
  decimal: ",",
  mmmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;")
}, 3, -1), "be");
te({
  decimal: ",",
  ampm: E("..;.."),
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;"),
  bool: E(";")
}, "bg");
te({
  group: ".",
  decimal: ",",
  mmmm: E("de gener;de febrer;de mar;dabril;de maig;de juny;de juliol;dagost;de setembre;doctubre;de novembre;de desembre"),
  mmm: E("de gen.;de febr.;de mar;dabr.;de maig;de juny;de jul.;dag.;de set.;doct.;de nov.;de des."),
  dddd: E("diumenge;dilluns;dimarts;dimecres;dijous;divendres;dissabte"),
  ddd: E("dg.;dl.;dt.;dc.;dj.;dv.;ds."),
  ampm: E("a.m.;p.m.")
}, "ca");
te(Le({
  group: ",",
  decimal: ".",
  mmmm: E("Enero;Pebrero;Marso;Abril;Mayo;Hunyo;Hulyo;Agosto;Setyembre;Oktubre;Nobyembre;Disyembre"),
  dddd: E("Linggo;Lunes;Martes;Miyerkules;Huwebes;Biyernes;Sabado")
}, 3, 3), "fil");
te({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E("~;~;~;~;~;~;~", ""),
  ddd: E(";;;;;;")
}, "gu");
te({
  group: ",",
  decimal: ".",
  ampm: E(";"),
  dddd: E("~;~;~;~;~;~;~", " "),
  ddd: E("~;~;~;~;~;~;", " "),
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  mmmm6: E(";; ; ;; ; ; ; ;;;"),
  mmm6: E(";; ; ;; ; ; ; ;;;")
}, "he");
te(Le({
  group: ".",
  decimal: ",",
  mmmm: E("sijenja;veljae;oujka;travnja;svibnja;lipnja;srpnja;kolovoza;rujna;listopada;studenoga;prosinca"),
  mmm: E("sij;velj;ou;tra;svi;lip;srp;kol;ruj;lis;stu;pro"),
  dddd: E("nedjelja;ponedjeljak;utorak;srijeda;etvrtak;petak;subota")
}, -1, 3), "hr");
te({
  decimal: ",",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;")
}, "hy");
te(Le({
  decimal: ",",
  mmmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;")
}, 3, 3), "ka");
te(Le({
  decimal: ",",
  mmmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;")
}, 13, -1), "kk");
te({
  group: ",",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E("~;~;~;~;~;~;~", ""),
  ddd: E(";;;;;;"),
  ampm: E(";")
}, "kn");
te({
  decimal: ",",
  mmmm: E("sausio;vasario;kovo;balandio;gegus;birelio;liepos;rugpjio;rugsjo;spalio;lapkriio;gruodio"),
  mmm: E("saus.;vas.;kov.;bal.;geg.;bir.;liep.;rugp.;rugs.;spal.;lapkr.;gruod."),
  dddd: E("sekmadienis;pirmadienis;antradienis;treiadienis;ketvirtadienis;penktadienis;etadienis"),
  ddd: E("sk;pr;an;tr;kt;pn;t"),
  ampm: E("priepiet;popiet")
}, "lt");
te({
  decimal: ",",
  mmmm: E("janvris;februris;marts;aprlis;maijs;jnijs;jlijs;augusts;septembris;oktobris;novembris;decembris"),
  mmm: E("janv.;febr.;marts;apr.;maijs;jn.;jl.;aug.;sept.;okt.;nov.;dec."),
  dddd: E("svtdiena;pirmdiena;otrdiena;trediena;ceturtdiena;piektdiena;sestdiena"),
  ddd: E("svtd.;pirmd.;otrd.;tred.;ceturtd.;piektd.;sestd."),
  ampm: E("priekpusdien;pcpusdien")
}, "lv");
te({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;")
}, "ml");
te({
  group: ",",
  decimal: ".",
  mmmm: E("~;~;~;~;~;~;~;~;~;~; ~; ~", " "),
  mmm: E("1~;2~;3~;4~;5~;6~;7~;8~;9~;10~;11~;12~", "- "),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;"),
  ampm: E("..;..")
}, "mn");
te({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;")
}, "mr");
te(Le({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ampm: E(";")
}, -1, 0), "my");
te({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;"),
  ampm: E("..;..")
}, "pa");
te({
  group: ".",
  decimal: ",",
  mmmm: E("ianuarie;februarie;martie;aprilie;mai;iunie;iulie;august;septem~;octom~;noiem~;decem~", "brie"),
  mmm: E("ian.;feb.;mar.;apr.;mai;iun.;iul.;aug.;sept.;oct.;nov.;dec."),
  dddd: E("duminic;luni;mari;miercuri;joi;vineri;smbt"),
  ddd: E("dum.;lun.;mar.;mie.;joi;vin.;sm."),
  ampm: E("a.m.;p.m.")
}, "ro");
te(Le({
  group: ".",
  decimal: ",",
  mmmm: E("januar;februar;marec;april;maj;junij;julij;avgust;september;oktober;november;december"),
  mmm: E("jan.;feb.;mar.;apr.;maj;jun.;jul.;avg.;sep.;okt.;nov.;dec."),
  dddd: E("nedelja;ponedeljek;torek;sreda;etrtek;petek;sobota"),
  ampm: E("dop.;pop.")
}, -1, 13), "sl");
te(Le({
  group: ".",
  decimal: ",",
  mmmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;")
}, 3, 3), "sr");
te({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(".;.;.;.;;;;.;.;.;.;."),
  dddd: E(";;;;;;"),
  ddd: E(".;.;.;.;.;.;")
}, "ta");
te({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;")
}, "te");
te({
  decimal: ",",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(".;.;.;.;.;.;.;.;.;.;.;."),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;"),
  ampm: E(";")
}, "uk");
te({
  group: ".",
  decimal: ",",
  mmmm: E("~1;~2;~3;~4;~5;~6;~7;~8;~9;~10;~11;~12", "thng "),
  mmm: E("~1;~2;~3;~4;~5;~6;~7;~8;~9;~10;~11;~12", "thg "),
  dddd: E("Ch Nht;Th Hai;Th Ba;Th T;Th Nm;Th Su;Th By"),
  ddd: E("CN;Th 2;Th 3;Th 4;Th 5;Th 6;Th 7"),
  ampm: E("SA;CH")
}, "vi");
te(Le({
  group: "",
  decimal: "",
  ampm: E(";"),
  mmmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  mmmm6: E(";; ; ;; ; ; ; ;;;")
}, 0, 0), "ar");
te({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;")
}, "bn");
te({
  group: ",",
  decimal: ".",
  mmmm: E(";;;;;;;;;;;"),
  mmm: E(";;;;;;;;;;;"),
  dddd: E(";;;;;;"),
  ddd: E(";;;;;;"),
  ampm: E("am;pm")
}, "hi");
var vu = {
  // Overflow error string
  overflow: "######",
  // dateErrorThrow needs to be off! [prev in locale]
  // Should it throw when there is an overflow error?
  dateErrorThrows: false,
  // Should it emit a number when date has an overflow error? (Sheets does this)
  dateErrorNumber: true,
  // dateErrorThrow needs to be off!
  // Should it emit a number when bigint has an is an overflow error?
  bigintErrorNumber: false,
  // Sheets mode (see #3)
  dateSpanLarge: true,
  // Simulate the Lotus 1-2-3 leap year bug
  leap1900: true,
  // Emit regular vs. non-breaking spaces
  nbsp: false,
  // Robust/throw mode
  throws: true,
  // What is emitted when robust mode fails to parse (###### currently)
  invalid: "######",
  // Locale
  locale: "",
  // Don't adjust dates to UTC when converting them to serial time
  ignoreTimezone: false,
  // Integer digit grouping
  grouping: [3, 3],
  // resolve indexed colors to hex
  indexColors: true,
  // Skip-next signifier character
  skipChar: "",
  // Repear-next signifier character
  repeatChar: ""
};
function Et(e, t = 0) {
  if (typeof e != "number")
    return e;
  if (e < 0)
    return -Et(-e, t);
  if (t) {
    const n = __pow(10, t) || 1;
    return Et(e * n, 0) / n;
  }
  return Math.round(e);
}
var K_ = 1e-13;
function bu(e, t = 2, n = 2) {
  const r = e < 0 ? -1 : 1, s = __pow(10, t || 2), i = __pow(10, n || 2);
  let o = Math.abs(e), a = 0, l = 0, u = 0, c = 1, h, d;
  if (e = o, e % 1 === 0)
    d = [e * r, 1];
  else if (e < 1e-19)
    d = [r, 1e19];
  else if (e > 1e19)
    d = [1e19 * r, 1];
  else {
    do
      if (o = 1 / (o - Math.floor(o)), h = c, c = c * Math.floor(o) + a, a = h, l = u, u = Math.floor(e * c + 0.5), u >= s || c >= i)
        return [r * l, a];
    while (Math.abs(e - u / c) >= K_ && o !== Math.floor(o));
    d = [r * u, c];
  }
  return d;
}
var ut = Math.floor;
function Au(e, t = true) {
  if (t && e >= 0) {
    if (e === 0)
      return [1900, 1, 0];
    if (e === 60)
      return [1900, 2, 29];
    if (e < 60)
      return [1900, e < 32 ? 1 : 2, (e - 1) % 31 + 1];
  }
  let n = e + 68569 + 2415019;
  const r = ut(4 * n / 146097);
  n = n - ut((146097 * r + 3) / 4);
  const s = ut(4e3 * (n + 1) / 1461001);
  n = n - ut(1461 * s / 4) + 31;
  const i = ut(80 * n / 2447), o = n - ut(2447 * i / 80);
  n = ut(i / 11);
  const a = i + 2 - 12 * n;
  return [100 * (r - 49) + s + n | 0, a | 0, o | 0];
}
function X_(e) {
  return Au(e + 1462);
}
function q_(e) {
  if (e === 60)
    throw new Error("#VALUE!");
  if (e <= 1)
    return [1317, 8, 29];
  if (e < 60)
    return [1317, e < 32 ? 9 : 10, 1 + (e - 2) % 30];
  const t = 10631 / 30, n = 8.01 / 60;
  let r = e + 466935;
  const s = ut(r / 10631);
  r = r - 10631 * s;
  const i = ut((r - n) / t);
  r = r - ut(i * t + n);
  const o = ut((r + 28.5001) / 29.5);
  return o === 13 ? [30 * s + i, 12, 30] : [30 * s + i, o, r - ut(29.5001 * o - 29)];
}
function yu(e, t = 0, n = true) {
  const r = ut(e);
  return t === Pn ? q_(r) : t === Y_ ? X_(r) : Au(r, n);
}
var Wr = Math.floor;
var oi = 86400;
function qo(e, t) {
  let n = null;
  if (Array.isArray(e)) {
    const [r, s, i, o, a, l] = e;
    n = Date.UTC(r, s == null ? 0 : s - 1, i != null ? i : 1, o || 0, a || 0, l || 0);
  } else if (e instanceof Date && (n = e * 1, !t || !t.ignoreTimezone)) {
    const r = /* @__PURE__ */ new Date();
    r.setUTCFullYear(
      e.getFullYear(),
      e.getMonth(),
      e.getDate()
    ), r.setUTCHours(
      e.getHours(),
      e.getMinutes(),
      e.getSeconds(),
      e.getMilliseconds()
    ), n = r * 1;
  }
  if (n != null && isFinite(n)) {
    const r = n / 864e5;
    return r - (r <= -25509 ? -25568 : -25569);
  }
  return null;
}
function J_(e, t) {
  let n = e | 0;
  const r = oi * (e - n);
  let s = Wr(r);
  r - s > 0.9999 && (s += 1, s === oi && (s = 0, n += 1));
  const i = s < 0 ? oi + s : s, [o, a, l] = yu(e, 0, t && t.leap1900), u = Wr(i / 60 / 60) % 60, c = Wr(i / 60) % 60, h = Wr(i) % 60;
  return [o, a, l, u, c, h];
}
var Z_ = [
  // day-month-year
  "!d-m-y",
  "!d-m-Y",
  "!j-m-y",
  "!j-m-Y",
  "!d-n-y",
  "!d-n-Y",
  "!j-n-y",
  "!j-n-Y",
  // month-day-year
  "?m-d-y",
  "?m-d-Y",
  "?m-j-y",
  "?m-j-Y",
  "?n-d-y",
  "?n-d-Y",
  "?n-j-y",
  "?n-j-Y",
  // unab
  "d-M-y",
  "d-M-Y",
  "j-M-y",
  "j-M-Y",
  "M-d-y",
  "M-d-Y",
  "M-j-y",
  "M-j-Y",
  "d-F-y",
  "d-F-Y",
  "F-d-y",
  "F-d-Y",
  "F-j-y",
  "F-j-Y",
  "j-F-y",
  "j-F-Y",
  "y-F-d",
  "y-F-j",
  "y-M-d",
  "y-M-j",
  "Y-F-d",
  "Y-F-j",
  "Y-M-d",
  "Y-m-d",
  "Y-M-j",
  "Y-m-j",
  "Y-n-d",
  "Y-n-j",
  "j-F",
  // 2-April
  "j-M",
  // 2-Apr
  "d-F",
  // 02-April
  "d-M",
  // 02-Apr
  "n-d",
  // 4-02
  "n-j",
  // 4-2
  "n-Y",
  // 4-1908
  "m-d",
  // 04-02
  "m-j",
  // 04-2
  "m-Y",
  // 04-1908
  "M-Y",
  // Apr-1908
  "M-y",
  // Apr-08
  "F-y",
  // April-08
  "F-Y",
  // April-1908
  "Y-M",
  // 1908-Apr
  "Y-n",
  // 1908-4
  "Y-m",
  // 1908-04
  "Y-F",
  // 1908-April
  "Y-M"
  // 1908-Apr
];
var Q_ = { j: "d", d: "d", D: "ddd", l: "dddd", n: "m", m: "m", M: "mmm", F: "mmmm", y: "yy", Y: "yyyy" };
var ep = { j: "dd", d: "dd", D: "ddd", l: "dddd", n: "mm", m: "mm", M: "mmm", F: "mmmm", y: "yy", Y: "yyyy" };
var Nu = {};
var Tu = {};
function lt(e, t, n = 1) {
  if (e) {
    const r = e[0], s = e.slice(1);
    r === "!" ? lt(s, t, 4) : r === "?" ? lt(s, t, 2) : (t[r] = t[r] || {}, lt(s, t[r], n));
  } else
    t.$ = n;
}
function el(e, t) {
  lt(e, t), lt(e + " x", t), lt(e + " l", t), lt(e + " l x", t), lt("l " + e, t), lt("l " + e + " x", t), lt(e + " D", t), lt(e + " D x", t), lt("D " + e, t), lt("D " + e + " x", t);
}
Z_.forEach((e) => {
  e[0] !== "?" && el(e, Nu), e[0] !== "!" && el(e, Tu);
});
var tp = (/* @__PURE__ */ new Date()).getUTCFullYear();
var tl = ".";
var np = ",";
var ai = " ";
var Er = "";
var Cr = "";
var hs = "'";
var ds = "";
var rp = {
  ".": [np, Er, Cr, hs, ds],
  ",": [tl, Er, Cr, hs, ds],
  "": [tl, Er, Cr, hs, ds]
};
var li = (e) => e && e.length === 1 && e >= "0" && e <= "9";
function Jo(e, t = {}) {
  const n = Xn(t.locale || "") || Qt, r = n.decimal, s = [...rp[r] || [hs, ds]];
  !s.includes(n.group) && n.group !== ai && n.group !== r && s.push(n.group);
  let i = "", o = "", a = 1, l = "", u = false, c = false, h = false, d = false, f = false, g = null, _ = false, R = 0;
  const b = [ai, Er, Cr, "+", "%", "(", "-"].concat(Ui);
  for (; b.includes(e[R]); ) {
    const v = e[R];
    if (v === "-") {
      if (u || c)
        return null;
      u = true, a = -1;
    } else if (Pi.test(v)) {
      if (f)
        return null;
      f = true, g = v;
    } else if (v === "(") {
      if (c || u)
        return null;
      c = true, a = -1;
    } else if (v === "%") {
      if (d)
        return null;
      d = true;
    }
    R++;
  }
  let $ = false, k;
  if (e[R] === r || li(e[R]))
    for (; R < e.length; ) {
      const v = e[R];
      if (!k && s.includes(v))
        k = v;
      else if (!(k && k === v)) if (v === r) {
        if ($)
          break;
        i += ".", $ = true;
      } else if (li(v))
        i += v;
      else
        break;
      R++;
    }
  if (e[R] === "e" || e[R] === "E") {
    o += e[R], R++, (e[R] === "+" || e[R] === "-") && (o += e[R], R++);
    const v = R;
    for (; li(e[R]); )
      o += e[R], R++;
    if (v === R)
      return null;
  }
  const W = [ai, Er, Cr, "%", "$", ")"].concat(Ui);
  for (; W.includes(e[R]); ) {
    const v = e[R];
    if (Pi.test(v)) {
      if (f)
        return null;
      f = true, g = v, _ = true;
    } else if (v === ")") {
      if (h || !c)
        return null;
      h = true;
    } else if (v === "%") {
      if (d)
        return null;
      d = true;
    }
    R++;
  }
  if (R !== e.length)
    return null;
  let w = parseFloat(i + o);
  if (!isFinite(w))
    return null;
  if (o) {
    if (d || f)
      return null;
    l = "0.00E+00";
  } else if (d) {
    if (f)
      return null;
    l = i.includes(".") ? "0.00%" : "0%", w *= 0.01;
  } else if (f) {
    const v = i.includes(".") ? "#,##0.00" : "#,##0";
    _ ? l = v + g : l = g + v;
  } else k && (l = i.includes(".") ? "#,##0.00" : "#,##0");
  const C = { v: w * a };
  return l && (C.z = l), C;
}
function sp(e, t, n) {
  if (n < 1 || t < 1 || t > 12)
    return false;
  if (t === 2) {
    const s = e % 4 === 0 && e % 100 !== 0 || e % 400 === 0 || e === 1900 ? 29 : 28;
    if (n > s)
      return false;
  } else if ((t === 4 || t === 6 || t === 9 || t === 11) && n > 30 || (t === 1 || t === 3 || t === 5 || t === 7 || t === 8 || t === 10 || t === 12) && n > 31)
    return false;
  return true;
}
var nl = (e, t, n = false) => {
  for (const r of t)
    if (e.startsWith(r[0])) {
      let s = r[0].length;
      return n && (r[2] === "D" || r[2] === "M") && e[s] === "." && s++, [e.slice(0, s), r];
    }
  return ["", null];
};
var Lt = (e, t, n, r) => {
  const s = n.path || "", i = Object.keys(t);
  for (let o = 0; o < i.length; o++) {
    let a;
    const l = i[o];
    if (t[l]) {
      if (l === "$" || l === "")
        e || (a = n);
      else if (l === "-") {
        const u = /^(\s*([./-]|,\s)\s*|\s+)/.exec(e);
        if (u) {
          const c = u[1] === "-" || u[1] === "/" || u[1] === "." ? u[1] : " ";
          if (!n.sep || n.sep === c) {
            const h = u[0].replace(/\s+/g, " ");
            a = Lt(e.slice(u[0].length), t[l], __spreadProps(__spreadValues({}, n), { sep: c, path: s + h }), r);
          }
        }
      } else if (l === " ") {
        const u = /^[,.]?\s+/.exec(e);
        if (u) {
          const c = u[0].replace(/\s+/g, " ");
          a = Lt(e.slice(u[0].length), t[l], __spreadProps(__spreadValues({}, n), { path: s + c }), r);
        }
      } else if (l === "j" || l === "d") {
        const u = /^(0?[1-9]|1\d|2\d|3[01])\b/.exec(e);
        u && (a = Lt(e.slice(u[0].length), t[l], __spreadProps(__spreadValues({}, n), { day: u[0], path: s + l }), r));
      } else if (l === "n" || l === "m") {
        const u = /^(0?[1-9]|1[012])\b/.exec(e);
        u && (a = Lt(e.slice(u[0].length), t[l], __spreadProps(__spreadValues({}, n), { month: +u[0], _mon: u[0], path: s + l }), r));
      } else if (l === "F" || l === "M") {
        const [u, c] = nl(e, r.mon, r.mp);
        c && c[2] === l && (a = Lt(
          e.slice(u.length),
          t[l],
          __spreadProps(__spreadValues({}, n), { month: c[1], _mon: u, path: s + l }),
          r
        ));
      } else if (l === "l" || l === "D") {
        const [u, c] = nl(e, r.day, r.dp);
        c && c[2] === l && (a = Lt(e.slice(u.length), t[l], __spreadProps(__spreadValues({}, n), { path: s + l }), r));
      } else if (l === "y") {
        const u = /^\d\d\b/.exec(e);
        if (u) {
          const c = +u[0] >= 30 ? +u[0] + 1900 : +u[0] + 2e3;
          a = Lt(e.slice(u[0].length), t[l], __spreadProps(__spreadValues({}, n), { year: c, path: s + l }), r);
        }
      } else if (l === "Y") {
        const u = /^\d\d\d\d\b/.exec(e);
        u && (a = Lt(e.slice(u[0].length), t[l], __spreadProps(__spreadValues({}, n), { year: +u[0], path: s + l }), r));
      } else if (l === "x") {
        const u = Fs(e, { locale: r.locale });
        u && (a = Lt("", t[l], __spreadProps(__spreadValues({}, n), { time: u.v, tf: u.z, path: s + l }), r));
      } else
        throw new Error(`Unknown date token "${l}"`);
      if (a && sp(n.year || 1916, n.month || 1, n.day ? +n.day : 1))
        return a;
    }
  }
};
var Mu = (e) => e.replace(/\s+/g, " ").trim().replace(//, "'").replace(/\.$/, "").toLowerCase();
var Yr = (e, t) => {
  const n = e.map((r, s) => [Mu(r), s + 1, t]);
  return n.sort((r, s) => s[0].length - r[0].length), n;
};
function Zo(e, t = {}) {
  var i;
  const n = Xn(t.locale || "") || Qt, r = {
    mon: Yr(n.mmmm, "F").concat(Yr(n.mmm, "M")),
    mp: n.mmm[0].at(-1) === ".",
    day: Yr(n.dddd, "l").concat(Yr(n.ddd, "D")),
    dp: n.ddd[0].at(-1) === ".",
    locale: t.locale
  }, s = Lt(
    Mu(e),
    n.preferMDY ? Tu : Nu,
    { path: "" },
    r
  );
  if (s) {
    if (s.sep === "." && s.path.length === 3)
      return null;
    const o = +((i = s.year) != null ? i : tp);
    s.day || (s.day = 1);
    let a = -1 / 0;
    if (o < 1900)
      return null;
    o <= 1900 && s.month <= 2 ? a = 25568 : o < 1e4 && (a = 25569);
    const l = Date.UTC(o, s.month - 1, s.day) / 864e5 + a + (s.time || 0);
    if (l >= 0 && l <= 2958465) {
      const u = (
        // either has a leading zero
        s._mon[0] === "0" || s.day[0] === "0" || // both are 2-digits long
        s._mon.length === 2 && s.day.length === 2
      ), c = s.path.replace(/[jdlDnmMFyYx]/g, (h) => h === "x" ? s.tf || "" : (u ? ep[h] : Q_[h]) || h);
      return { v: l, z: c };
    }
  }
  return null;
}
var ui = (e) => e.replace(/\s+/g, "").trim().replace(/\./g, "").toLowerCase();
function Fs(e, t = {}) {
  const n = Xn(t.locale || "") || Qt, r = /^\s*([10]?\d|2[0-4])(?::([0-5]\d|\d))?(?::([0-5]\d|\d))?(\.\d{1,10})?(?=\s*[^\s\d]|$)/.exec(e);
  let s = "";
  if (r) {
    const i = ui(e.slice(r[0].length));
    if (i === ui(n.ampm[0]) || i === "a" || i === "am")
      s = "a";
    else if (i === ui(n.ampm[1]) || i === "p" || i === "pm")
      s = "p";
    else if (i)
      return null;
  }
  if (r) {
    const [, i, o, a, l] = r;
    if (l && !a || !s && !o && !a)
      return null;
    let u = +(i || 0) * 1;
    if (s) {
      if (u >= 13)
        return null;
      s === "p" && (u += 12);
    }
    const c = +(o || 0) * 1, h = +(a || 0) * 1, d = +(l || 0) * 1;
    return {
      v: (u * 60 * 60 + c * 60 + h + d) / (3600 * 24),
      z: (i.length === 2 ? "hh" : "h") + ":mm" + (a ? ":ss" : "") + (s ? " AM/PM" : "")
    };
  }
  return null;
}
function xu(e, t = {}) {
  const n = Xn(t.locale || "") || Qt, r = e.trim().toLowerCase(), s = n.bool[0].toLowerCase();
  if (r === "true" || r === s)
    return { v: true };
  const i = n.bool[1].toLowerCase();
  return r === "false" || r === i ? { v: false } : null;
}
function ip(e, t) {
  var n, r, s;
  return (s = (r = (n = Jo(e, t)) != null ? n : Zo(e, t)) != null ? r : Fs(e, t)) != null ? s : xu(e, t);
}
function cn(e, t, n) {
  return t[n + "_max"] = e.length, t[n + "_min"] = e.replace(/#/g, "").length, t;
}
function We(e, t) {
  typeof e == "string" ? t.push({ type: "string", value: e }) : t.push(e);
}
function rl(e, t) {
  const n = e && e.type;
  return n === Io || n === kn || n === wo || n === Ps && t === "den";
}
function fr(e) {
  var k, W, w;
  const t = [], n = {
    scale: 1,
    percent: false,
    text: false,
    date: 0,
    date_eval: false,
    date_system: Qa,
    sec_decimals: 0,
    general: false,
    clock: 24,
    int_pattern: [],
    frac_pattern: [],
    man_pattern: [],
    den_pattern: [],
    num_pattern: [],
    tokens: t
  };
  let r = "int", s = null;
  const i = [];
  let o, a = false, l = -1, u = false, c = "", h = false;
  for (; ++l < e.length && !u; ) {
    const C = e[l], v = C.type || Or;
    if (c += C.raw, v === Ro)
      n.general = true, We(C, t);
    else if (rl(C, r)) {
      const y = n[r + "_pattern"];
      rl(o, r) || (o == null ? void 0 : o.type) === Sr ? (y.push((y.pop() || "") + C.value), s.num += C.value) : (y.push(C.value), s = { type: r, num: C.value }, We(s, t));
    } else if (v === Yo)
      C.value === "(" && (n.parens = true), We(C.value, t);
    else if (v === Ps)
      We(C.value, t);
    else if (v === So)
      if (h = true, n[r + "_pattern"].length) {
        if (!s)
          throw new SyntaxError("Format pattern is missing a numerator");
        n.fractions = true, n.num_pattern.push(n[r + "_pattern"].pop()), s.type = "num", r = "den", We({ type: "div" }, t);
      } else
        We(C.value, t);
    else if (v === Oo)
      We(",", t);
    else if (v === ps)
      n.scale = __pow(1e-3, C.raw.length);
    else if (v === Sr) {
      if (r === "int" && (n.grouping = true), r === "den")
        throw new SyntaxError("Cannot group denominator digits");
    } else if (v === yo)
      We(C, t);
    else if (v === vo) {
      u = true;
      break;
    } else if (v === Us)
      n.text = true, We(C, t);
    else if (v === bo || v === Ao)
      We(C, t);
    else if (v === xo) {
      const y = C.value.toLowerCase(), F2 = y[0], H = { type: "", size: 0, date: 1, pad: y.length };
      F2 === "h" ? (H.size = cr, H.type = "hour-elap") : F2 === "m" ? (H.size = hr, H.type = "min-elap") : (H.size = dr, H.type = "sec-elap"), n.date = n.date | H.size, i.push(H), We(H, t);
    } else if (n.date && v === Es && ((k = e[l + 1]) == null ? void 0 : k.type) === kn) {
      let y = 1;
      l++;
      let F2 = "0";
      ((W = e[l + 1]) == null ? void 0 : W.type) === kn && (F2 += "0", y = 2, l++), ((w = e[l + 1]) == null ? void 0 : w.type) === kn && (F2 += "0", y = 3, l++), c += F2;
      const H = [dr, xi, Li, Di][y];
      n.date = n.date | H, n.date_eval = true, n.sec_decimals = Math.max(n.sec_decimals, y), We({
        type: "subsec",
        size: H,
        decimals: y,
        date: 1
      }, t);
    } else if (v === To)
      a || (C.value === "B2" || C.value === "b2" ? n.date_system = Pn : n.date_system = Qa);
    else if (v === Mo) {
      const y = { type: "", size: 0, date: 1 }, F2 = C.value.toLowerCase(), H = F2[0];
      if (F2 === "y" || F2 === "yy")
        y.size = lr, y.type = "year-short";
      else if (H === "y" || H === "e")
        y.size = lr, y.type = "year";
      else if (F2 === "b" || F2 === "bb")
        y.size = lr, y.type = "b-year-short";
      else if (H === "b")
        y.size = lr, y.type = "b-year";
      else if (F2 === "d" || F2 === "dd")
        y.size = cs, y.type = "day", y.pad = /dd/.test(F2);
      else if (F2 === "ddd" || F2 === "aaa")
        y.size = cs, y.type = "weekday-short";
      else if (H === "d" || H === "a")
        y.size = cs, y.type = "weekday";
      else if (H === "h")
        y.size = cr, y.type = "hour", y.pad = /hh/i.test(F2);
      else if (H === "m") {
        F2.length === 3 ? (y.size = ur, y.type = "monthname-short") : F2.length === 5 ? (y.size = ur, y.type = "monthname-single") : F2.length >= 4 && (y.size = ur, y.type = "monthname");
        const m = i[i.length - 1];
        !y.type && m && !m.used && m.size & (cr | dr) && (m.used = true, y.size = hr, y.type = "min", y.pad = /mm/.test(F2)), y.type || (y.size = ur, y.type = "month", y.pad = /mm/.test(F2), y.indeterminate = true);
      } else if (H === "s") {
        y.size = dr, y.type = "sec", y.pad = /ss/.test(F2);
        const m = i[i.length - 1];
        m && m.size & hr ? y.used = true : m && m.indeterminate && (delete m.indeterminate, m.size = hr, m.type = "min", y.used = true);
      }
      n.date = n.date | y.size, n.date_eval = true, i.push(y), We(y, t);
    } else if (v === Fo)
      n.clock = 12, n.date = n.date | cr, n.date_eval = true, C.short = C.value === "A/P", We(C, t);
    else if (v === $o || v === Ho || v === ks)
      We(C.value, t);
    else if (v === Lo)
      n.condition = [
        C.value[0],
        // operator
        parseFloat(C.value[1])
        // operand
      ];
    else if (v === Po) {
      const y = C.value.split("-"), F2 = y.length < 2 ? "" : y.slice(1).join("-"), H = y[0];
      H && We(H, t);
      const m = Vo(F2);
      m && (n.locale = m);
      const D = parseInt(F2, 16);
      isFinite(D) && D & 16711680 && (D >> 16 & 255) === 6 && (n.date_system = Pn), a = true;
    } else if (v === ko) {
      let y, F2 = C.value.toLowerCase();
      (y = /^color\s*(\d+)$/i.exec(F2)) && (F2 = parseInt(y[1], 10)), n.color = F2;
    } else if (v === No)
      n.scale = 100, n.percent = true, We("%", t);
    else if (v === Es)
      We(C, t), n.date || (n.dec_fractions = true, r = "frac");
    else if (v === jo)
      n.exponential = true, n.exp_plus = C.value.includes("+"), r = "man", We({ type: "exp", plus: n.exp_plus }, t);
    else if (v === Bo)
      We(C, t);
    else if (v === Wo)
      We(C, t);
    else if (!(v === Do || v === Uo)) throw v === Or ? new SyntaxError(`Illegal character: ${c}`) : new SyntaxError(`Unknown token ${v} in ${c}`);
    o = C;
  }
  if (n.tokensUsed = l, n.pattern = c, /^((?:\[[^\]]+\])+)(;|$)/.test(n.pattern) && !/^\[(?:h+|m+|s+)\]/.test(n.pattern) && We({ type: "text" }, t), n.fractions && n.dec_fractions || n.grouping && !n.int_pattern.length || n.fractions && n.exponential || n.fractions && n.den_pattern.length * n.num_pattern.length === 0 || h && !n.fractions && !n.date || n.exponential && (n.int_pattern.length || n.frac_pattern.length) * n.man_pattern.length === 0)
    throw new SyntaxError(`Invalid pattern: ${c}`);
  const d = n.int_pattern.join(""), f = n.man_pattern.join(""), g = n.frac_pattern.join("");
  cn(d, n, "int");
  let _ = 0;
  for (let C = 0; C < d.length; C++) {
    const v = d[d.length - 1 - C];
    /^[0-9?]/.test(v) && (_ = C + 1);
  }
  n.int_min = _, cn(g, n, "frac"), cn(f, n, "man");
  let R = n.num_pattern.join(""), b = n.den_pattern[0] || "";
  if (b.includes("?") || R.includes("?") ? (b = b.replace(/\d/g, "?"), b = b.replace(/#$/g, "?"), cn(R, n, "num"), cn(b, n, "den"), R = R.replace(/#$/g, "?")) : (cn(R, n, "num"), cn(b, n, "den")), n.int_p = d, n.man_p = f, n.num_p = R, n.den_p = b, n.den_pattern.length && (n.denominator = parseInt(n.den_pattern.join("").replace(/\D/g, ""), 10)), n.integer = !!d.length, !n.integer && !n.exponential && g.length) {
    const C = n.tokens.findIndex((v) => v.type === "point");
    n.tokens.splice(C, 0, { type: "int", value: "#" }), n.integer = true, n.int_pattern = ["#"], n.int_p = "#";
  }
  if (n.fractions)
    for (let C = 0; C < t.length - 1; C++) {
      const v = t[C];
      if (v.type !== "string" && v.type !== "space")
        continue;
      const y = t[C + 1].type;
      y === "num" ? v.rule = "num+int" : y === "div" ? v.rule = "num" : y === "den" && (v.rule = "den");
    }
  return n.grouping && n.int_pattern.length > 1 && (n.grouping = false), n;
}
function op(e) {
  if (e === 0)
    return e;
  const t = Math.ceil(Math.log10(e < 0 ? -e : e)), n = __pow(10, 16 - Math.floor(t));
  return isFinite(n) ? Math.round(e * n) / n : 0;
}
function Lu(e, t = 0) {
  const n = Math.floor(Math.log10(e));
  return t > 1 ? Math.floor(n / t) * t : n;
}
function Du(e, t = 1) {
  return t < -300 ? parseFloat(e.toExponential().split("e")[0]) : e * __pow(10, -t);
}
var ap = {
  total: 1,
  sign: 0,
  period: 0,
  int: 1,
  frac: 0
};
function lp(e, t = true) {
  const n = Math.abs(e);
  if (!n)
    return ap;
  const r = t && e < 0 ? 1 : 0, s = Math.floor(n), i = Math.floor(Math.log10(n) + 1);
  let o = 0, a = 0;
  if (s !== n) {
    o = 1;
    const l = String(
      Et(n * __pow(10, -i), 15)
    );
    let u = l.length, c = true, h = 0;
    for (; h <= l.length; ) {
      if (l[h] === ".") {
        u--;
        break;
      } else l[h] === "0" && c ? u-- : c = false;
      h++;
    }
    a = u - i, a < 0 && (a = 0, o = 0);
  }
  return {
    total: r + Math.max(i, 1) + o + a,
    digits: Math.max(i, 0) + a,
    sign: r,
    period: o,
    int: Math.max(i, 1),
    frac: a
  };
}
var An = (e, t) => e.replace(/\./, t.decimal);
var sl = (e, t, n) => {
  const r = Math.abs(t);
  let s;
  return e === 1 ? s = e : s = Et(e, 5), [
    An(s + "", n),
    n.exponent,
    t < 0 ? n.negative : n.positive,
    r < 10 ? "0" : "",
    r
  ];
};
function il(e, t, n, r) {
  const s = n | 0;
  if (typeof n == "string")
    e.push(n);
  else if (n === s)
    e.push(Math.abs(s));
  else {
    const i = Math.abs(n);
    let o = Lu(i), a = Du(i, o);
    a === 10 && (a = 1, o++);
    const l = lp(i);
    if (o >= -4 && o <= -1) {
      const u = i.toPrecision(10 + o).replace(/\.?0+$/, "");
      e.push(An(u, r));
    } else if (o === 10) {
      const u = i.toFixed(10).slice(0, 12).replace(/\.$/, "");
      e.push(An(u, r));
    } else if (Math.abs(o) <= 9)
      if (l.total <= 11) {
        const u = Et(i, 9).toFixed(l.frac);
        e.push(An(u, r));
      } else o === 9 ? e.push(Math.floor(i)) : o >= 0 && o < 9 ? e.push(An(String(Et(i, 9 - o)), r)) : e.push(...sl(a, o, r));
    else l.total >= 12 ? e.push(...sl(a, o, r)) : e.push(An(Et(i, 9).toFixed(l.frac), r));
  }
  return e;
}
function hn(e, t = false) {
  return e === "0" ? "0" : e === "?" ? t ? "" : " " : "";
}
var Qn = 86400;
var up = (e, t, n) => n ? e < j_ || t >= W_ : e < $_ || t >= B_;
function ol(e, t, n, r) {
  var A, O;
  let s = "", i = "", o = "", a = "", l = "", u = "", c = 0, h = 0;
  if (typeof e == "bigint") {
    if (e <= Number.MAX_SAFE_INTEGER && e >= Number.MIN_SAFE_INTEGER)
      e = Number(e);
    else
      return n.bigintErrorNumber ? String(e) : n.overflow;
    h = e;
  } else
    h = Math.trunc(e);
  let d = 0, f = 0, g = 1, _ = 0, R = 0, b = 0, $ = 0, k = 0, W = 0;
  const w = r || Qt;
  if (!t.text && isFinite(t.scale) && t.scale !== 1 && (e = op(e * t.scale)), t.exponential) {
    let N = Math.abs(e);
    N && (c = Lu(N, t.int_max)), e && !t.integer && c++, N = Du(N, c), t.int_max === 1 && Et(N, t.frac_max) === 10 && (N = 1, c++), e = e < 0 ? -N : N, s += Math.abs(c);
  }
  if (t.integer) {
    const N = Math.abs(Et(e, t.fractions ? 1 : t.frac_max));
    u += N < 1 ? "" : Math.floor(N);
  }
  const C = (A = n.grouping[0]) != null ? A : 3, v = (O = n.grouping[1]) != null ? O : C;
  t.dec_fractions && (l = String(Et(e, t.frac_max)).split(".")[1] || "");
  const y = !t.error && (t.num_p.includes("0") || t.den_p.includes("0"));
  let F2 = y;
  if (t.fractions) {
    F2 = y || !!(e % 1);
    const N = Math.abs(t.integer ? e % 1 : e);
    if (N)
      if (F2 = true, t.denominator && isFinite(t.denominator))
        a += t.denominator, o += Et(N * t.denominator), o === "0" && (o = "", a = "", F2 = y);
      else {
        const M = bu(N, 1 / 0, t.den_max);
        o += M[0], a += M[1], t.integer && o === "0" && (o = "", a = "", F2 = y);
      }
    else !e && !t.integer && (F2 = true, o = "0", a = "1");
    t.integer && !F2 && !Math.trunc(e) && (u = "0");
  }
  if (t.date) {
    h = Math.trunc(e);
    const N = Qn * (e - h);
    if (d = Math.floor(N), W = N - d, Math.abs(W) < 1e-6 ? W = 0 : W > 0.9999 && (W = 0, d += 1, d === Qn && (d = 0, h += 1)), W) {
      const M = t.date & Di || t.date & Li || t.date & xi;
      (M === Di && W > 0.9995 || M === Li && W > 0.995 || M === xi && W > 0.95 || !M && W >= 0.5) && (d++, W = 0);
    }
    if (h || t.date_system) {
      const M = yu(e, t.date_system, n.leap1900);
      f = M[0], g = M[1], _ = M[2];
    }
    if (d) {
      const M = d < 0 ? Qn + d : d;
      k = Math.floor(M) % 60, $ = Math.floor(M / 60) % 60, b = Math.floor(M / 60 / 60) % 60;
    }
    if (R = (6 + h) % 7, t.date_eval && up(e, h + d / Qn, n.dateSpanLarge)) {
      if (n.dateErrorThrows)
        throw new Error("Date out of bounds");
      if (n.dateErrorNumber) {
        const M = e < 0 ? [w.negative] : [];
        return il(M, {}, e, w).join("");
      }
      return n.overflow;
    }
  }
  const H = hn("?", n.nbsp);
  c < 0 ? i = "-" : t.exp_plus && (i = "+");
  const m = [], D = (N, M, x, P) => {
    const q = !P && N.length > M.length ? x.length + N.length - M.length : x.length;
    N.length < M.length && (P += N.length - M.length);
    for (let V = 0; V < q; V++)
      m.push(N[V + P] || hn(x[V], n.nbsp));
    return q;
  };
  let S = false;
  const T = { int: 0, frac: 0, man: 0, num: 0, den: 0 };
  for (let N = 0, M = t.tokens.length; N < M; N++) {
    const x = t.tokens[N], P = x.type, q = x.num ? x.num.length : 0;
    if (P === "string")
      x.rule ? x.rule === "num" ? F2 ? m.push(x.value.replace(/ /g, H)) : (t.num_min > 0 || t.den_min > 0) && m.push(x.value.replace(/./g, H)) : x.rule === "num+int" ? F2 && u ? m.push(x.value.replace(/ /g, H)) : t.den_min > 0 && (u || t.num_min) && m.push(x.value.replace(/./g, H)) : x.rule === "den" && (F2 ? m.push(x.value.replace(/ /g, H)) : (t.den_min > 0 || t.den_min > 0) && m.push(x.value.replace(/./g, H))) : m.push(x.value.replace(/ /g, H));
    else if (P === "space")
      x.rule === "num+int" ? (F2 || t.num_min || t.den_min) && (u || t.num_min) && m.push(H) : m.push(H);
    else if (P === "error")
      m.push(n.invalid);
    else if (P === "point")
      m.push(t.date ? x.value : w.decimal);
    else if (P === "general")
      il(m, t, e, w);
    else if (P === "exp")
      m.push(w.exponent);
    else if (P === "minus")
      x.volatile && t.date || x.volatile && (e >= 0 || typeof e != "number") || (x.volatile && !t.fractions && (t.integer || t.dec_fractions) ? (e < 0 && u && u !== "0" || l) && m.push(w.negative) : m.push(w.negative));
    else if (P === "plus")
      m.push(w.positive);
    else if (P === "text")
      m.push(e);
    else if (P === "fill")
      n.fillChar && m.push(n.fillChar, x.value);
    else if (P === "skip")
      n.skipChar ? m.push(n.skipChar, x.value) : m.push(n.nbsp ? "" : " ");
    else if (P === "div")
      F2 ? m.push("/") : t.num_min > 0 || t.den_min > 0 ? m.push(H) : m.push(hn("#", n.nbsp));
    else if (P === "int")
      if (t.int_pattern.length === 1) {
        const V = t.int_p, oe = Math.max(t.int_min, u.length);
        let le = "";
        for (let I = oe; I > 0; I--) {
          const L = u.charAt(u.length - I), Y = L ? "" : V.charAt(V.length - I) || V[0];
          let z = "";
          if (t.grouping) {
            const B = I - 1 - C;
            B >= 0 && !(B % v) && (z = L || Y === "0" ? w.group : hn("?", n.nbsp));
          }
          le += (L || hn(Y, n.nbsp)) + z;
        }
        m.push(le);
      } else
        T.int += D(u, t.int_p, x.num, T.int);
    else if (P === "frac") {
      const V = T.frac;
      for (let oe = 0; oe < q; oe++)
        m.push(l[oe + V] || hn(x.num[oe], n.nbsp));
      T.frac += q;
    } else if (P === "man")
      !T[P] && !T.man && m.push(i), T.man += D(s, t.man_p, x.num, T.man);
    else if (P === "num")
      T.num += D(o, t.num_p, x.num, T.num);
    else if (P === "den") {
      const V = T.den;
      for (let oe = 0; oe < q; oe++) {
        let le = a[oe + V];
        if (!le) {
          const I = x.num[oe];
          "123456789".includes(I) || S && I === "0" ? (S = true, le = n.nbsp ? "" : " ") : !S && oe === q - 1 && I === "0" && !a ? le = "1" : le = hn(I, n.nbsp);
        }
        m.push(le);
      }
      T.den += q;
    } else if (P === "year")
      f < 0 && m.push(w.negative), m.push(String(Math.abs(f)).padStart(4, "0"));
    else if (P === "year-short") {
      const V = f % 100;
      m.push(V < 10 ? "0" : "", V);
    } else if (P === "month")
      m.push(x.pad && g < 10 ? "0" : "", g);
    else if (P === "monthname-single")
      t.date_system === Pn ? m.push(w.mmmm6[g - 1].charAt(0)) : m.push(w.mmmm[g - 1].charAt(0));
    else if (P === "monthname-short")
      t.date_system === Pn ? m.push(w.mmm6[g - 1]) : m.push(w.mmm[g - 1]);
    else if (P === "monthname")
      t.date_system === Pn ? m.push(w.mmmm6[g - 1]) : m.push(w.mmmm[g - 1]);
    else if (x.type === "weekday-short")
      m.push(w.ddd[R]);
    else if (P === "weekday")
      m.push(w.dddd[R]);
    else if (P === "day")
      m.push(x.pad && _ < 10 ? "0" : "", _);
    else if (P === "hour") {
      const V = b % t.clock || (t.clock < 24 ? t.clock : 0);
      m.push(x.pad && V < 10 ? "0" : "", V);
    } else if (P === "min")
      m.push(x.pad && $ < 10 ? "0" : "", $);
    else if (P === "sec")
      m.push(x.pad && k < 10 ? "0" : "", k);
    else if (P === "subsec") {
      m.push(w.decimal);
      const V = W.toFixed(t.sec_decimals);
      m.push(V.slice(2, 2 + x.decimals));
    } else if (P === "ampm") {
      const V = b < 12 ? 0 : 1;
      x.short && !r ? m.push("AP"[V]) : m.push(w.ampm[V]);
    } else if (P === "hour-elap") {
      e < 0 && m.push(w.negative);
      const V = h * 24 + Math.floor(Math.abs(d) / 3600);
      m.push(String(Math.abs(V)).padStart(x.pad, "0"));
    } else if (P === "min-elap") {
      e < 0 && m.push(w.negative);
      const V = h * 1440 + Math.floor(Math.abs(d) / 60);
      m.push(String(Math.abs(V)).padStart(x.pad, "0"));
    } else if (P === "sec-elap") {
      e < 0 && m.push(w.negative);
      const V = h * Qn + Math.abs(d);
      m.push(String(Math.abs(V)).padStart(x.pad, "0"));
    } else if (P === "b-year")
      m.push(f + 543);
    else if (P === "b-year-short") {
      const V = (f + 543) % 100;
      m.push(V < 10 ? "0" : "", V);
    }
  }
  return m.join("");
}
var cp = fr([
  { type: Us, value: "@", raw: "@" }
]);
function Uu(e, t) {
  for (let n = 0; n < 3; n++) {
    const r = t[n];
    if (r) {
      let s;
      if (r.condition) {
        const i = r.condition[0], o = r.condition[1];
        i === "=" ? s = e === o : i === ">" ? s = e > o : i === "<" ? s = e < o : i === ">=" ? s = e >= o : i === "<=" ? s = e <= o : i === "<>" && (s = e !== o);
      } else
        s = true;
      if (s)
        return r;
    }
  }
}
function hp(e, t, n) {
  const r = t.partitions;
  let s = r[3], i = null;
  return (typeof e == "number" || typeof e == "bigint") && isFinite(e) && (s = Uu(e, r)), s && s.color && (i = s.color), i && typeof i == "number" && n.indexColors && (i = z_[i - 1] || "#000"), i;
}
function dp(e, t, n) {
  const r = t.partitions, s = Xn(t.locale || n.locale), i = r[3] ? r[3] : cp;
  if (typeof e == "boolean" && (e = (s || Qt).bool[e ? 0 : 1]), e == null)
    return "";
  const o = typeof e == "bigint";
  if (typeof e != "number" && !o)
    return ol(e, i, n, s);
  if (!o && !isFinite(e)) {
    const l = s || Qt;
    return isNaN(e) ? l.nan : (e < 0 ? l.negative : "") + l.infinity;
  }
  const a = Uu(e, r);
  return a ? ol(e, a, n, s) : n.overflow;
}
function Pu(e) {
  return !!(e[0] && e[0].percent || e[1] && e[1].percent || e[2] && e[2].percent || e[3] && e[3].percent);
}
function ku(e) {
  return !!(e[0] && e[0].date || e[1] && e[1].date || e[2] && e[2].date || e[3] && e[3].date);
}
function Fu(e) {
  const [t, n, r, s] = e;
  return !!((!t || t.generated) && (!n || n.generated) && (!r || r.generated) && s && s.text && !s.generated);
}
var fp = {
  text: 15,
  datetime: 10.8,
  date: 10.8,
  time: 10.8,
  percent: 10.6,
  currency: 10.4,
  grouped: 10.2,
  scientific: 6,
  number: 4,
  fraction: 2,
  general: 0,
  error: 0
};
var mp = [
  ["DMY", 1],
  ["DM", 2],
  ["MY", 3],
  ["MDY", 4],
  ["MD", 5],
  ["hmsa", 6],
  ["hma", 7],
  ["hms", 8],
  ["hm", 9]
];
function gp(e, t = null) {
  var h;
  const [n, r] = e, s = n.frac_max, i = {
    type: "general",
    isDate: ku(e),
    isText: Fu(e),
    isPercent: Pu(e),
    maxDecimals: n.general ? 9 : s,
    scale: (h = n.scale) != null ? h : 1,
    color: 0,
    parentheses: 0,
    grouped: n.grouping ? 1 : 0
  }, o = !i.isDate && !i.isText && !n.error && n.tokens.some((d) => d.type === "string" && (t ? d.value === t : Pi.test(d.value)));
  let a = "G", l = s >= 0 ? Math.min(15, s) : "", u = "", c = "";
  if (r && r.color && (c = "-", i.color = 1), n.parens && (u = "()", i.parentheses = 1), o)
    a = "C", i.type = "currency";
  else if (n.error)
    i.type = "error", i.maxDecimals = 0;
  else if (i.isDate) {
    let d = 0, f = 0, g = "";
    n.tokens.forEach((R) => {
      const b = R.type;
      /^(b-)?year/.test(b) ? (g += "Y", f++) : b.startsWith("month") ? (g += "M", f++) : /^(week)?day/.test(b) ? (g += "D", f++) : (b === "hour" || b === "min" || b === "sec" || b === "ampm") && (g += b[0], d++);
    }), i.type = "date", f && d ? i.type = "datetime" : !f && d && (i.type = "time");
    const _ = mp.find((R) => g.startsWith(R[0]));
    a = _ ? "D" : "G", l = _ ? _[1] : "";
  } else i.isText ? (a = "G", i.type = "text", l = "", i.maxDecimals = 0) : n.general ? (a = "G", i.type = "general", l = "") : n.fractions ? (a = "G", i.type = "fraction", l = "") : n.exponential ? (a = "S", i.type = "scientific") : i.isPercent ? (a = "P", i.type = "percent") : n.grouping ? (a = ",", i.type = "grouped") : (n.int_max || s) && (a = "F", i.type = "number");
  return i.code = a + l + c + u, i.level = fp[i.type], Object.freeze(i);
}
function _p(e) {
  const [t] = e;
  return {
    year: !!(t.date & lr),
    month: !!(t.date & ur),
    day: !!(t.date & cs),
    hours: !!(t.date & cr),
    minutes: !!(t.date & hr),
    seconds: !!(t.date & dr),
    clockType: t.clock === 12 ? 12 : 24
  };
}
var pp = [
  [Ro, /^General/i, 0],
  [Io, /^#/, 0],
  [kn, /^0/, 0],
  [wo, /^\?/, 0],
  [So, /^\//, 0],
  // Commas are dealt with as a special case in the tokenizer but will end up
  // as one of these:
  // [ TOKEN_GROUP, /^(,),*/, 1 ],
  // [ TOKEN_SCALE, /^(,),*/, 1 ],
  // [ TOKEN_COMMA, /^(,),*/, 1 ],
  [vo, /^;/, 0],
  [Us, /^@/, 0],
  [bo, /^\+/, 0],
  [Ao, /^-/, 0],
  [Es, /^\./, 0],
  [yo, /^ /, 0],
  [No, /^%/, 0],
  [Ps, /^[1-9]/, 0],
  [To, /^(?:B[12])/i, 0],
  [Or, /^B$/, 0],
  // pattern must not end in a "B"
  [Mo, /^(?:[hH]+|[mM]+|[sS]+|[yY]+|[bB]+|[dD]+|[gG]+|[aA]{3,}|e+)/, 0],
  [xo, /^(?:\[(h+|m+|s+)\])/i, 1],
  [Lo, /^\[(<[=>]?|>=?|=)\s*(-?[.\d]+)\]/, [1, 2]],
  [Do, /^\[(DBNum[0-4]?\d)\]/i, 1],
  [Uo, /^\[(NatNum[0-4]?\d)\]/i, 1],
  [Po, /^\[\$([^\]]+)\]/, 1],
  [ko, /^\[(black|blue|cyan|green|magenta|red|white|yellow|color\s*\d+)\]/i, 1],
  // conditionally allow these open ended directions?
  [Cu, /^\[([^\]]+)\]/, 1],
  [Fo, /^(?:AM\/PM|am\/pm|A\/P)/, 0],
  [Ho, /^\\(.)/, 1],
  [$o, /^"([^"]*?)"/, 1],
  [Bo, /^_(\\.|.)/, 1],
  // Google Sheets and Excel diverge on "e": Excel only accepts E.
  [jo, /^[Ee]([+-])/, 1],
  [Wo, /^\*(\\.|.)/, 1],
  [Yo, /^[()]/, 0],
  [Or, /^[ENn["*/\\_]/, 0],
  [ks, /^./, 0]
];
var Ep = 63;
var Cp = 35;
var Rp = 48;
var Ip = 57;
var ci = (e) => {
  const t = (e || "\0").charCodeAt(0);
  return t === Ep || t === Cp || t >= Rp && t <= Ip;
};
function Mn(e) {
  let t = 0;
  const n = [], r = [];
  for (; t < e.length; ) {
    const s = e.slice(t);
    let i = 0;
    const o = /^(,+)(.)?/.exec(s);
    if (o) {
      const a = o[1];
      i = a.length;
      const l = e[t - 1] || "";
      let u = false, c = false;
      ci(l) ? (u = true, c = true) : l === "." && (c = true);
      const h = o[2] || "";
      if (u && (!h || h === ";") && (u = false), c && ci(h) && (c = false), u && !c)
        n.push({ type: Sr, value: ",", raw: a });
      else if (!u && c)
        n.push({ type: ps, value: ",", raw: a });
      else if (u && c) {
        const d = { type: ps, value: ",", raw: a };
        n.push(d), r.push(d);
      } else
        n.push({ type: Oo, value: ",", raw: a });
    } else {
      let a;
      for (const [l, u, c] of pp) {
        const h = u.exec(s);
        if (h) {
          const d = Array.isArray(c) ? c.map((f) => h[f]) : h[c || 0];
          a = { type: l, value: d, raw: h[0] }, n.push(a), i = h[0].length;
          break;
        }
      }
      r.length && a.raw === ";" && (r.length = 0), r.length && ci(a.raw) && (r.forEach((l) => l.type = Sr), r.length = 0);
    }
    if (!i) {
      const a = s[0];
      i = 1, n.push({ type: ks, value: a, raw: a });
    }
    t += i;
  }
  return n;
}
var hi = (e) => {
  const t = e.condition;
  t && t[1] < 0 && (t[0] === "<" || t[0] === "<=" || t[0] === "=") || e.tokens.unshift({
    type: "minus",
    volatile: true
  });
};
var al = (e, t = null) => {
  const n = {};
  for (const r in e)
    Array.isArray(e[r]) ? n[r] = [...e[r]] : n[r] = e[r];
  return t && n.tokens.unshift(t), n.generated = true, n;
};
function wp(e) {
  var h;
  const t = [];
  let n = false, r, s = null, i = 0, o = false, a = 0, l = 0, u = Mn(e);
  do {
    if (o = fr(u), (o.date || o.general) && (o.int_pattern.length || o.frac_pattern.length || o.scale !== 1 || o.text))
      throw new Error("Illegal format");
    if (o.condition && (l++, n = true), o.text) {
      if (s)
        throw new Error("Unexpected partition");
      s = o;
    }
    o.locale && (r = Vo(o.locale)), t.push(o), i = ((h = u[o.tokensUsed]) == null ? void 0 : h.type) === "break" ? 1 : 0, u = u.slice(o.tokensUsed + i), a++;
  } while (i && a < 4 && l < 3);
  if (i)
    throw new Error("Unexpected partition");
  if (l > 2)
    throw new Error("Unexpected condition");
  const c = t[3];
  if (c && (c.int_pattern.length || c.frac_pattern.length || c.date))
    throw new Error("Unexpected partition");
  if (n) {
    const d = t.length;
    if (d === 1 && (t[1] = fr(Mn("General")), t[1].generated = true), d < 3) {
      const f = t[0], g = t[1];
      if (hi(f), g.condition)
        hi(g);
      else {
        const _ = f.condition;
        (_[0] === "=" || _[1] >= 0 && (_[0] === ">" || _[0] === ">=")) && g.tokens.unshift({
          type: "minus",
          volatile: true
        });
      }
    } else
      t.forEach(hi);
  } else {
    if (t.length < 4 && s)
      for (let d = 0, f = t.length; d < f; d++)
        t[d] === s && t.splice(d, 1);
    if (t.length < 1 && s && (t[0] = fr(Mn("General")), t[0].generated = true), t.length < 2) {
      const d = { type: "minus", volatile: true };
      t.push(al(t[0], d));
    }
    if (t.length < 3 && t.push(al(t[0])), t.length < 4)
      if (s)
        t.push(s);
      else {
        const d = fr(Mn("@"));
        d.generated = true, t.push(d);
      }
    t[0].condition = [">", 0], t[1].condition = ["<", 0], t[2].condition = null;
  }
  return {
    pattern: e,
    partitions: t,
    locale: r
  };
}
var ll = /* @__PURE__ */ Object.create({});
function rn(e, t = false) {
  e || (e = "General");
  let n = ll[e];
  if (!n)
    try {
      n = wp(e), ll[e] = n;
    } catch (r) {
      if (t)
        throw r;
      const s = {
        tokens: [{ type: "error" }],
        error: r.message
      };
      n = {
        pattern: e,
        partitions: [s, s, s, s],
        error: r.message,
        locale: null
      };
    }
  return n;
}
function Hu(e, t, n = {}) {
  var o;
  const r = Object.assign({}, vu, n), s = rn(e, r.throws), i = (o = qo(t, r)) != null ? o : t;
  return dp(i, s, r);
}
function Sp(e, t, n) {
  var o;
  const r = Object.assign({}, vu, n), s = rn(e, r.throws), i = (o = qo(t, r)) != null ? o : t;
  return hp(i, s, r);
}
function Op(e) {
  const t = rn(e, false);
  return ku(t.partitions);
}
function vp(e) {
  const t = rn(e, false);
  return Pu(t.partitions);
}
function bp(e) {
  const t = rn(e, false);
  return Fu(t.partitions);
}
function Ap(e) {
  try {
    return rn(e, true), true;
  } catch (e2) {
    return false;
  }
}
function yp(e, t = {}) {
  const n = rn(e, false);
  return n.info || (n.info = gp(n.partitions, t == null ? void 0 : t.currency)), n.info;
}
function Np(e) {
  const t = rn(e, false);
  return t.dateInfo || (t.dateInfo = _p(t.partitions)), t.dateInfo;
}
var yn = Object.freeze({
  AMPM: Fo,
  BREAK: vo,
  CALENDAR: To,
  CHAR: ks,
  COLOR: ko,
  COMMA: Oo,
  CONDITION: Lo,
  DATETIME: Mo,
  DBNUM: Do,
  DIGIT: Ps,
  DURATION: xo,
  ERROR: Or,
  ESCAPED: Ho,
  EXP: jo,
  FILL: Wo,
  GENERAL: Ro,
  GROUP: Sr,
  HASH: Io,
  LOCALE: Po,
  MINUS: Ao,
  MODIFIER: Cu,
  NATNUM: Uo,
  PAREN: Yo,
  PERCENT: No,
  PLUS: bo,
  POINT: Es,
  QMARK: wo,
  SCALE: ps,
  SKIP: Bo,
  SLASH: So,
  SPACE: yo,
  STRING: $o,
  TEXT: Us,
  ZERO: kn
});
var a1 = Object.freeze(Object.defineProperty({
  __proto__: null,
  addLocale: te,
  dateFromSerial: J_,
  dateToSerial: qo,
  dec2frac: bu,
  format: Hu,
  formatColor: Sp,
  getFormatDateInfo: Np,
  getFormatInfo: yp,
  getLocale: Xn,
  isDateFormat: Op,
  isPercentFormat: vp,
  isTextFormat: bp,
  isValidFormat: Ap,
  parseBool: xu,
  parseDate: Zo,
  parseLocale: zo,
  parseNumber: Jo,
  parseTime: Fs,
  parseValue: ip,
  round: Et,
  tokenTypes: yn,
  tokenize: Mn
}, Symbol.toStringTag, { value: "Module" }));
var Tp = "@@@";
var Mp = "@";
var xp = "General";
function l1(e) {
  return e === Tp || e === Mp;
}
function u1(e) {
  return e == null || e === xp;
}
var c1 = (e, t) => {
  if (e && !t || !e && t)
    return false;
  const n = (i) => {
    const o = Mn(i);
    let a = "", l = false, u = false;
    for (const c of o) {
      if (c.type === yn.POINT) {
        l = true;
        continue;
      }
      if (!(u && c.type === yn.MINUS) && c.type !== yn.SKIP) {
        if (c.type === yn.COLOR) {
          u = true;
          continue;
        } else
          u = false;
        l && c.type === yn.ZERO || (l = false, l || (a += c.value || ""));
      }
    }
    return a;
  }, r = n(e), s = n(t);
  return r === s;
};
var Lp = /* @__PURE__ */ new Set(["m d"]);
var Dp = /* @__PURE__ */ new Set(["h:mm AM/PM", "hh:mm AM/PM"]);
var h1 = (e) => {
  var s, i;
  const t = (i = (s = Zo(e)) != null ? s : Fs(e)) != null ? i : Jo(e);
  if (!t) return null;
  const { v: n, z: r } = t;
  return r && (Lp.has(r) || Dp.has(r) && !/\s(A|AM|P|PM)$/i.test(e) || r.includes("#,##0") && Hu(r, n) !== e) ? null : t;
};
var d1 = {
  sheetId: "",
  range: {
    startRow: -1,
    endRow: -1,
    startColumn: -1,
    endColumn: -1
  }
};
var f1 = {
  startRow: -1,
  startColumn: -1,
  endRow: -1,
  endColumn: -1
};
var m1 = {
  startRow: 0,
  startColumn: 0,
  endRow: 0,
  endColumn: 0
};
var g1 = {
  row: 0,
  column: 0
};
var rt = {
  /**
   * fontFamily
   */
  ff: "Arial",
  /**
   * fontSize
   */
  fs: 11,
  /**
   * italic
   * 0: false
   * 1: true
   */
  it: ie.FALSE,
  /**
   * bold
   * 0: false
   * 1: true
   */
  bl: ie.FALSE,
  /**
   * underline
   */
  ul: {
    s: ie.FALSE
  },
  /**
   * strikethrough
   */
  st: {
    s: ie.FALSE
  },
  /**
   * overline
   */
  ol: {
    s: ie.FALSE
  },
  /**
   * textRotation
   */
  tr: {
    a: 0,
    /**
     * true : 1
     * false : 0
     */
    v: ie.FALSE
  },
  /**
   * textDirection
   */
  td: gs.UNSPECIFIED,
  /**
   * color
   */
  cl: {
    rgb: "#000000"
  },
  /**
   * background
   */
  bg: {
    rgb: "#fff"
  },
  /**
   * horizontalAlignment
   */
  ht: Pt.UNSPECIFIED,
  /**
   * verticalAlignment
   */
  vt: Dn.UNSPECIFIED,
  /**
   * wrapStrategy
   */
  tb: jn.UNSPECIFIED,
  /**
   * padding
   */
  pd: {
    t: 0,
    r: 0,
    b: 0,
    l: 0
  },
  n: null,
  /**
   * border
   */
  bd: {
    b: null,
    l: null,
    r: null,
    t: null
  }
};
var Up = {
  id: "default_slide",
  title: "defaultSlide",
  pageSize: {
    width: 300,
    height: 300
  }
};
var _1 = [Fl, Wc, Hl];
var p1 = {
  [qe.HEADING_1]: { fs: 20, bl: 1 },
  // Heading 1: 20pt, bold
  [qe.HEADING_2]: { fs: 18, bl: 1 },
  // Heading 2: 18pt, bold
  [qe.HEADING_3]: { fs: 16, bl: 1 },
  // Heading 3: 16pt, bold
  [qe.HEADING_4]: { fs: 14, bl: 1 },
  // Heading 4: 14pt, bold
  [qe.HEADING_5]: { fs: 12, bl: 1 },
  // Heading 5: 12pt, bold
  [qe.NORMAL_TEXT]: null,
  // Normal text: using global font size
  [qe.TITLE]: { fs: 26, bl: 1 },
  // Title: 26pt, bold
  [qe.SUBTITLE]: { fs: 15, cl: { rgb: "#999999" } },
  // Subtitle: 15pt
  [qe.NAMED_STYLE_TYPE_UNSPECIFIED]: null
};
var Sn = 4;
var E1 = {
  [qe.HEADING_1]: {
    spaceAbove: {
      v: 20
    },
    spaceBelow: {
      v: 6 + Sn
    }
  },
  [qe.HEADING_2]: {
    spaceAbove: {
      v: 18
    },
    spaceBelow: {
      v: 6 + Sn
    }
  },
  [qe.HEADING_3]: {
    spaceAbove: {
      v: 16
    },
    spaceBelow: {
      v: 6 + Sn
    }
  },
  [qe.HEADING_4]: {
    spaceAbove: {
      v: 14
    },
    spaceBelow: {
      v: 4 + Sn
    }
  },
  [qe.HEADING_5]: {
    spaceAbove: {
      v: 12
    },
    spaceBelow: {
      v: 4 + Sn
    }
  },
  [qe.NORMAL_TEXT]: {
    spaceAbove: {
      v: 0
    },
    spaceBelow: {
      v: 0
    }
  },
  [qe.TITLE]: {
    spaceAbove: {
      v: 0
    },
    spaceBelow: {
      v: 3 + Sn
    }
  },
  [qe.SUBTITLE]: {
    spaceAbove: {
      v: 0
    },
    spaceBelow: {
      v: 16
    }
  },
  [qe.NAMED_STYLE_TYPE_UNSPECIFIED]: null
};
var C1 = "univer-sheets-chart-print-chart";
var R1 = "univer-docs-drawing-printing";
var Pp = ((e) => (e.ARRAY_CONVERTOR = "ARRAY_CONVERTOR", e.MATRIX_CONVERTOR = "MATRIX_CONVERTOR", e))(Pp || {});
var I1 = {
  [_t.A3]: {
    width: 1123,
    height: 1587
  },
  [_t.A4]: {
    width: 794,
    height: 1124
  },
  [_t.A5]: {
    width: 559,
    height: 794
  },
  [_t.B4]: {
    width: 944,
    height: 1344
  },
  [_t.B5]: {
    width: 665,
    height: 944
  },
  [_t.Executive]: {
    width: 696,
    height: 1008
  },
  [_t.Folio]: {
    width: 816,
    height: 1248
  },
  [_t.Legal]: {
    width: 816,
    height: 1344
  },
  [_t.Letter]: {
    width: 816,
    height: 1056
  },
  [_t.Statement]: {
    width: 528,
    height: 816
  },
  [_t.Tabloid]: {
    width: 1056,
    height: 1632
  }
};
function zr(e, t) {
  const { textRuns: n = [] } = t;
  let r = 0;
  for (const i of n) {
    const { ts: o = {}, st: a, ed: l } = i;
    if (o[e] == null)
      return ie.FALSE;
    switch (e) {
      case "bl":
      case "it": {
        if (o[e] === ie.FALSE)
          return ie.FALSE;
        break;
      }
      case "ul":
      case "st": {
        if (o[e].s === ie.FALSE)
          return ie.FALSE;
        break;
      }
      default:
        throw new Error(`unknown style key: ${e} in IStyleBase`);
    }
    r += l - a;
  }
  return t.dataStream.indexOf(`\r
`) === r ? ie.TRUE : ie.FALSE;
}
var Rr = class Rr2 {
  constructor(t, n, r) {
    p(this, "_range");
    p(this, "_worksheet");
    this._deps = r, this._range = n, this._worksheet = t;
  }
  static foreach(t, n) {
    const { startRow: r, startColumn: s, endRow: i, endColumn: o } = t;
    for (let a = r; a <= i; a++)
      for (let l = s; l <= o; l++)
        n(a, l);
  }
  /**
   * get current range data
   *
   * @returns current range
   */
  getRangeData() {
    return this._range;
  }
  /**
   * Returns the value of the top-left cell in the range. The value may be of type Number, Boolean, Date, or String
   * depending on the value of the cell. Empty cells return an empty string.
   * @returns  The value in this cell
   */
  getValue() {
    return this.getValues()[0][0];
  }
  /**
   * Returns the rectangular grid of values for this range.
   *
   * Returns a two-dimensional array of values, indexed by row, then by column. The values may be of type Number,
   * Boolean, Date, or String, depending on the value of the cell. Empty cells are represented by an empty string
   * in the array. Remember that while a range index starts at 0, 0, same as the JavaScript array is indexed from [0][0].
   *
   * In web apps, a Date value isn't a legal parameter. getValues() fails to return data to a web app if the range
   * contains a cell with a Date value. Instead, transform all the values retrieved from the sheet to a supported
   * JavaScript primitive like a Number, Boolean, or String.
   *
   * @returns  A two-dimensional array of values.
   */
  getValues() {
    const { startRow: t, endRow: n, startColumn: r, endColumn: s } = this._range, i = [];
    for (let o = t; o <= n; o++) {
      const a = [];
      for (let l = r; l <= s; l++)
        a.push(this.getMatrix().getValue(o, l) || null);
      i.push(a);
    }
    return i;
  }
  /**
   * get range matrix
   *
   * @returns range matrix
   */
  getMatrix() {
    const { startRow: t, endRow: n, startColumn: r, endColumn: s } = this._range, i = this._worksheet.getCellMatrix(), o = new ht();
    for (let a = t; a <= n; a++)
      for (let l = r; l <= s; l++)
        o.setValue(a, l, i.getValue(a, l) || null);
    return o;
  }
  /**
   * get range matrix object
   *
   * @returns range matrix object
   */
  getMatrixObject() {
    const { startRow: t, endRow: n, startColumn: r, endColumn: s } = this._range, i = this._worksheet.getCellMatrix(), o = new ht();
    for (let a = t; a <= n; a++)
      for (let l = r; l <= s; l++)
        o.setValue(a - t, l - r, i.getValue(a, l) || {});
    return o;
  }
  /**
   * Returns a string description of the range, in A1 notation.
   *
   * @returns The string description of the range in A1 notation.
   */
  getA1Notation() {
    const { startRow: t, endRow: n, startColumn: r, endColumn: s } = this._range;
    let i, o;
    return r < s ? (i = Z.numToWord(r + 1) + (t + 1), o = Z.numToWord(s + 1) + (n + 1)) : (i = Z.numToWord(s + 1) + (n + 1), o = Z.numToWord(r + 1) + (t + 1)), i === o ? `${i}` : `${i}:${o}`;
  }
  /**
   * Returns the background color of the top-left cell in the range (for example, '#ffffff').
   *
   * @returns  The color code of the background.
   */
  getBackground() {
    return this.getBackgrounds()[0][0];
  }
  /**
   * Returns the background colors of the cells in the range (for example, '#ffffff').
   *
   * @returns   A two-dimensional array of color codes of the backgrounds.
   */
  getBackgrounds() {
    const t = this._deps.getStyles();
    return this.getValues().map(
      (n) => n.map((r) => {
        var i;
        const s = t.getStyleByCell(r);
        return ((i = s == null ? void 0 : s.bg) == null ? void 0 : i.rgb) || rt.bg.rgb;
      })
    );
  }
  /**
   * Returns a given cell within a range.
   *
   * The row and column here are relative to the range
   * e.g. "B2:D4", getCell(0,0) in this code returns the cell at B2
   * @returns   A range containing a single cell at the specified coordinates.
   */
  getCell(t, n) {
    const { startRow: r, startColumn: s } = this._range, i = {
      startRow: r + t,
      endRow: r + t,
      startColumn: s + n,
      endColumn: s + n
    };
    return new Rr2(this._worksheet, i, this._deps);
  }
  /**
   * Returns the starting column position for this range
   *
   * @returns   The range's starting column position in the spreadsheet.
   */
  getColumn() {
    return this._range.startColumn;
  }
  /**
   * Returns the data of the object structure, and can set whether to bring styles
   */
  getObjectValue(t = {}) {
    return this.getObjectValues(t)[0][0];
  }
  /**
   * Returns the data of the object structure, and can set whether to bring styles
   *
   * @param options set whether to include style
   * @returns Returns a value in object format
   */
  getObjectValues(t = {}) {
    var a;
    const { startRow: n, endRow: r, startColumn: s, endColumn: i } = this._range, o = this._worksheet.getCellMatrix().getFragment(n, r, s, i).getData();
    if (t.isIncludeStyle) {
      const l = this._deps.getStyles();
      for (let u = 0; u <= r - n; u++)
        for (let c = 0; c <= i - s; c++) {
          if (o == null || ((a = o == null ? void 0 : o[u]) == null ? void 0 : a[c]) == null)
            continue;
          const h = o[u][c].s;
          h && (o[u][c].s = l.get(h));
        }
    }
    return o;
  }
  /**
   * Returns the font color of the cell in the top-left corner of the range, in CSS notation
   */
  getFontColor() {
    return this.getFontColors()[0][0];
  }
  /**
   * Returns the font colors of the cells in the range in CSS notation (such as '#ffffff' or 'white').
   */
  getFontColors() {
    const t = this._deps.getStyles();
    return this.getValues().map(
      (n) => n.map((r) => {
        var i;
        const s = t.getStyleByCell(r);
        return ((i = s == null ? void 0 : s.cl) == null ? void 0 : i.rgb) || rt.cl.rgb;
      })
    );
  }
  /**
   * Returns the font families of the cells in the range.
   */
  getFontFamilies() {
    return this._getStyles("ff");
  }
  /**
   * Returns the font family of the cell in the top-left corner of the range.
   */
  getFontFamily() {
    return this.getFontFamilies()[0][0];
  }
  /**
   * Returns the underlines of the cells in the range.
   */
  getUnderlines() {
    return this._getStyles("ul");
  }
  /**
   * Returns the underline of the cells in the range.
   */
  getUnderline() {
    var n, r;
    const { p: t } = (n = this.getValue()) != null ? n : {};
    return t && Array.isArray((r = t.body) == null ? void 0 : r.textRuns) && t.body.textRuns.length > 0 ? zr("ul", t.body) === ie.TRUE ? {
      s: ie.TRUE
    } : {
      s: ie.FALSE
    } : this.getUnderlines()[0][0];
  }
  /**
   * Returns the overlines of the cells in the range.
   */
  getOverlines() {
    return this._getStyles("ol");
  }
  /**
   * Returns the overline of the cells in the range.
   */
  getOverline() {
    return this.getOverlines()[0][0];
  }
  /**
   * Returns the strikeThrough of the cells in the range.
   */
  getStrikeThrough() {
    var n, r;
    const { p: t } = (n = this.getValue()) != null ? n : {};
    return t && Array.isArray((r = t.body) == null ? void 0 : r.textRuns) && t.body.textRuns.length > 0 ? zr("st", t.body) === ie.TRUE ? {
      s: ie.TRUE
    } : {
      s: ie.FALSE
    } : this.getStrikeThroughs()[0][0];
  }
  /**
   * Returns the strikeThroughs of the cells in the range.
   */
  getStrikeThroughs() {
    return this._getStyles("st");
  }
  /**
   * Returns the font size in point size of the cell in the top-left corner of the range.
   */
  getFontSize() {
    var n, r;
    const t = ((n = this.getValue()) == null ? void 0 : n.p) || {};
    return t && Array.isArray((r = t.body) == null ? void 0 : r.textRuns) && t.body.textRuns.length > 0 ? t.body.textRuns.some((s) => {
      var i;
      return ((i = s == null ? void 0 : s.ts) == null ? void 0 : i.fs) != null;
    }) ? Math.max(...t.body.textRuns.map((s) => {
      var i;
      return ((i = s == null ? void 0 : s.ts) == null ? void 0 : i.fs) || 0;
    })) : this.getFontSizes()[0][0] : this.getFontSizes()[0][0];
  }
  /**
   * Returns the font sizes of the cells in the range.
   */
  getFontSizes() {
    return this._getStyles("fs");
  }
  /**
   * Returns the border info of the cells in the range.
   */
  getBorder() {
    return this.getBorders()[0][0];
  }
  getBorders() {
    return this._getStyles("bd");
  }
  /**
   * Returns the font style ('italic' or 'normal') of the cell in the top-left corner of the range.
   */
  getFontStyle() {
    var n, r;
    const { p: t } = (n = this.getValue()) != null ? n : {};
    return t && Array.isArray((r = t.body) == null ? void 0 : r.textRuns) && t.body.textRuns.length > 0 ? zr("it", t.body) === ie.TRUE ? vi.ITALIC : vi.NORMAL : this._getFontStyles()[0][0];
  }
  /**
   * Returns the font styles of the cells in the range.
   */
  _getFontStyles() {
    return this._getStyles("it");
  }
  /**
   * Returns the font weight (normal/bold) of the cell in the top-left corner of the range.
   * If the cell has rich text, the return value according to the textRuns of the rich text,
   * when all styles of textRuns are bold, it will return FontWeight.BOLD,
   * otherwise return FontWeight.NORMAL.
   */
  getFontWeight() {
    var n, r;
    const { p: t } = (n = this.getValue()) != null ? n : {};
    return t && Array.isArray((r = t.body) == null ? void 0 : r.textRuns) && t.body.textRuns.length > 0 ? zr("bl", t.body) === ie.TRUE ? bi.BOLD : bi.NORMAL : this._getFontWeights()[0][0];
  }
  /**
   * Returns the font weights of the cells in the range.
   */
  _getFontWeights() {
    return this._getStyles("bl");
  }
  /**
   * Returns the grid ID of the range's parent sheet.
   */
  getGridId() {
    return this._worksheet.getSheetId();
  }
  /**
   * Returns the height of the range.
   */
  getHeight() {
    const { _range: t, _worksheet: n } = this, { startRow: r, endRow: s } = t;
    let i = 0;
    for (let o = 0; o <= s - r; o++) {
      const a = n.getRowHeight(o);
      i += a;
    }
    return i;
  }
  /**
   *     Returns the horizontal alignment of the text (left/center/right) of the cell in the top-left corner of the range.
   */
  getHorizontalAlignment() {
    return this.getHorizontalAlignments()[0][0];
  }
  /**
   *Returns the horizontal alignments of the cells in the range.
   */
  getHorizontalAlignments() {
    return this._getStyles("ht");
  }
  /**
   * Returns the end column position.
   */
  getLastColumn() {
    return this._range.endColumn;
  }
  /**
   *     Returns the end row position.
   */
  getLastRow() {
    return this._range.endRow;
  }
  /**
   * Returns the number of columns in this range.
   */
  getNumColumns() {
    const { startColumn: t, endColumn: n } = this._range;
    return n - t + 1;
  }
  /**
   * Returns the number of rows in this range.
   */
  getNumRows() {
    const { startRow: t, endRow: n } = this._range;
    return n - t + 1;
  }
  /**
   * Returns the Rich Text value for the top left cell of the range, or null if the cell value is not text.
   */
  getRichTextValue() {
    return this.getRichTextValues()[0][0];
  }
  /**
   * Returns the Rich Text values for the cells in the range.
   */
  getRichTextValues() {
    return this.getValues().map((t) => t.map((n) => (n == null ? void 0 : n.p) || ""));
  }
  /**
   * Returns the row position for this range.
   */
  getRowIndex() {
    return this._range.startRow;
  }
  /**
   * Returns the sheet this range belongs to.
   */
  getSheet() {
    return this._worksheet;
  }
  /**
   * Returns the text direction for the top left cell of the range.
   */
  getTextDirection() {
    return this.getTextDirections()[0][0];
  }
  /**
   * Returns the text directions for the cells in the range.
   */
  getTextDirections() {
    return this._getStyles("td");
  }
  /**
   * Returns the text rotation settings for the top left cell of the range.
   */
  // getTextRotation(): number {
  getTextRotation() {
    return this.getTextRotations()[0][0];
  }
  /**
   * Returns the text rotation settings for the cells in the range.
   */
  // getTextRotations(): number[][] {
  getTextRotations() {
    return this._getStyles("tr");
  }
  /**
   *     Returns the text style for the top left cell of the range.
   */
  getTextStyle() {
    return this.getTextStyles()[0][0];
  }
  /**
   * Returns the text styles for the cells in the range.
   */
  getTextStyles() {
    const t = this._deps.getStyles();
    return this.getValues().map((n) => n.map((r) => t.getStyleByCell(r)));
  }
  /**
   * Returns the vertical alignment (top/middle/bottom) of the cell in the top-left corner of the range.
   */
  getVerticalAlignment() {
    return this.getVerticalAlignments()[0][0];
  }
  /**
   * Returns the vertical alignments of the cells in the range.
   */
  getVerticalAlignments() {
    return this._getStyles("vt");
  }
  /**
   * Returns the width of the range in columns.
   */
  getWidth() {
    const { _range: t, _worksheet: n } = this, { startColumn: r, endColumn: s } = t;
    let i = 0;
    for (let o = 0; o <= s - r; o++)
      i += n.getColumnWidth(o);
    return i;
  }
  /**
   * Returns whether the text in the cell wraps.
   */
  getWrap() {
    return this.getWrapStrategy() === jn.WRAP ? ie.TRUE : ie.FALSE;
  }
  /**
   * Returns the text wrapping strategies for the cells in the range.
   */
  getWrapStrategies() {
    return this._getStyles("tb");
  }
  /**
   * Returns the text wrapping strategy for the top left cell of the range.
   */
  getWrapStrategy() {
    return this.getWrapStrategies()[0][0];
  }
  forEach(t) {
    Rr2.foreach(this._range, t);
  }
  /**
   *
   * @param arg Shorthand for the style that gets
   * @returns style value
   */
  _getStyles(t) {
    const n = this._deps.getStyles();
    return this.getValues().map(
      (r) => r.map((s) => {
        const i = n && n.getStyleByCell(s);
        return i && i[t] || rt[t];
      })
    );
  }
};
p(Rr, "transformRange", (t, n) => {
  const r = n.getMaxColumns() - 1, s = n.getMaxRows() - 1;
  return t.rangeType === ge.ALL ? {
    startColumn: 0,
    startRow: 0,
    endColumn: r,
    endRow: s
  } : t.rangeType === ge.COLUMN ? {
    startRow: 0,
    endRow: s,
    startColumn: t.startColumn,
    endColumn: t.endColumn
  } : t.rangeType === ge.ROW ? {
    startColumn: 0,
    endColumn: r,
    startRow: t.startRow,
    endRow: t.endRow
  } : {
    startColumn: t.startColumn,
    endColumn: Math.min(t.endColumn, r),
    startRow: t.startRow,
    endRow: Math.min(t.endRow, s)
  };
});
var vr = Rr;
function $u(e, t, n = 0, r = e.length - 1, s = kp) {
  for (; r > n; ) {
    if (r - n > 600) {
      const l = r - n + 1, u = t - n + 1, c = Math.log(l), h = 0.5 * Math.exp(2 * c / 3), d = 0.5 * Math.sqrt(c * h * (l - h) / l) * (u - l / 2 < 0 ? -1 : 1), f = Math.max(n, Math.floor(t - u * h / l + d)), g = Math.min(r, Math.floor(t + (l - u) * h / l + d));
      $u(e, t, f, g, s);
    }
    const i = e[t];
    let o = n, a = r;
    for (er(e, n, t), s(e[r], i) > 0 && er(e, n, r); o < a; ) {
      for (er(e, o, a), o++, a--; s(e[o], i) < 0; ) o++;
      for (; s(e[a], i) > 0; ) a--;
    }
    s(e[n], i) === 0 ? er(e, n, a) : (a++, er(e, a, r)), a <= t && (n = a + 1), t <= a && (r = a - 1);
  }
}
function er(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function kp(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
var Fi = class {
  constructor(t = 9) {
    this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(t) {
    let n = this.data;
    const r = [];
    if (!Gr(t, n)) return r;
    const s = this.toBBox, i = [];
    for (; n; ) {
      for (let o = 0; o < n.children.length; o++) {
        const a = n.children[o], l = n.leaf ? s(a) : a;
        Gr(t, l) && (n.leaf ? r.push(a) : fi(t, l) ? this._all(a, r) : i.push(a));
      }
      n = i.pop();
    }
    return r;
  }
  collides(t) {
    let n = this.data;
    if (!Gr(t, n)) return false;
    const r = [];
    for (; n; ) {
      for (let s = 0; s < n.children.length; s++) {
        const i = n.children[s], o = n.leaf ? this.toBBox(i) : i;
        if (Gr(t, o)) {
          if (n.leaf || fi(t, o)) return true;
          r.push(i);
        }
      }
      n = r.pop();
    }
    return false;
  }
  load(t) {
    if (!(t && t.length)) return this;
    if (t.length < this._minEntries) {
      for (let r = 0; r < t.length; r++)
        this.insert(t[r]);
      return this;
    }
    let n = this._build(t.slice(), 0, t.length - 1, 0);
    if (!this.data.children.length)
      this.data = n;
    else if (this.data.height === n.height)
      this._splitRoot(this.data, n);
    else {
      if (this.data.height < n.height) {
        const r = this.data;
        this.data = n, n = r;
      }
      this._insert(n, this.data.height - n.height - 1, true);
    }
    return this;
  }
  insert(t) {
    return t && this._insert(t, this.data.height - 1), this;
  }
  clear() {
    return this.data = Nn([]), this;
  }
  remove(t, n) {
    if (!t) return this;
    let r = this.data;
    const s = this.toBBox(t), i = [], o = [];
    let a, l, u;
    for (; r || i.length; ) {
      if (r || (r = i.pop(), l = i[i.length - 1], a = o.pop(), u = true), r.leaf) {
        const c = Fp(t, r.children, n);
        if (c !== -1)
          return r.children.splice(c, 1), i.push(r), this._condense(i), this;
      }
      !u && !r.leaf && fi(r, s) ? (i.push(r), o.push(a), a = 0, l = r, r = r.children[0]) : l ? (a++, r = l.children[a], u = false) : r = null;
    }
    return this;
  }
  toBBox(t) {
    return t;
  }
  compareMinX(t, n) {
    return t.minX - n.minX;
  }
  compareMinY(t, n) {
    return t.minY - n.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(t) {
    return this.data = t, this;
  }
  _all(t, n) {
    const r = [];
    for (; t; )
      t.leaf ? n.push(...t.children) : r.push(...t.children), t = r.pop();
    return n;
  }
  _build(t, n, r, s) {
    const i = r - n + 1;
    let o = this._maxEntries, a;
    if (i <= o)
      return a = Nn(t.slice(n, r + 1)), On(a, this.toBBox), a;
    s || (s = Math.ceil(Math.log(i) / Math.log(o)), o = Math.ceil(i / Math.pow(o, s - 1))), a = Nn([]), a.leaf = false, a.height = s;
    const l = Math.ceil(i / o), u = l * Math.ceil(Math.sqrt(o));
    ul(t, n, r, u, this.compareMinX);
    for (let c = n; c <= r; c += u) {
      const h = Math.min(c + u - 1, r);
      ul(t, c, h, l, this.compareMinY);
      for (let d = c; d <= h; d += l) {
        const f = Math.min(d + l - 1, h);
        a.children.push(this._build(t, d, f, s - 1));
      }
    }
    return On(a, this.toBBox), a;
  }
  _chooseSubtree(t, n, r, s) {
    for (; s.push(n), !(n.leaf || s.length - 1 === r); ) {
      let i = 1 / 0, o = 1 / 0, a;
      for (let l = 0; l < n.children.length; l++) {
        const u = n.children[l], c = di(u), h = Bp(t, u) - c;
        h < o ? (o = h, i = c < i ? c : i, a = u) : h === o && c < i && (i = c, a = u);
      }
      n = a || n.children[0];
    }
    return n;
  }
  _insert(t, n, r) {
    const s = r ? t : this.toBBox(t), i = [], o = this._chooseSubtree(s, this.data, n, i);
    for (o.children.push(t), gr(o, s); n >= 0 && i[n].children.length > this._maxEntries; )
      this._split(i, n), n--;
    this._adjustParentBBoxes(s, i, n);
  }
  // split overflowed node into two
  _split(t, n) {
    const r = t[n], s = r.children.length, i = this._minEntries;
    this._chooseSplitAxis(r, i, s);
    const o = this._chooseSplitIndex(r, i, s), a = Nn(r.children.splice(o, r.children.length - o));
    a.height = r.height, a.leaf = r.leaf, On(r, this.toBBox), On(a, this.toBBox), n ? t[n - 1].children.push(a) : this._splitRoot(r, a);
  }
  _splitRoot(t, n) {
    this.data = Nn([t, n]), this.data.height = t.height + 1, this.data.leaf = false, On(this.data, this.toBBox);
  }
  _chooseSplitIndex(t, n, r) {
    let s, i = 1 / 0, o = 1 / 0;
    for (let a = n; a <= r - n; a++) {
      const l = mr(t, 0, a, this.toBBox), u = mr(t, a, r, this.toBBox), c = jp(l, u), h = di(l) + di(u);
      c < i ? (i = c, s = a, o = h < o ? h : o) : c === i && h < o && (o = h, s = a);
    }
    return s || r - n;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(t, n, r) {
    const s = t.leaf ? this.compareMinX : Hp, i = t.leaf ? this.compareMinY : $p, o = this._allDistMargin(t, n, r, s), a = this._allDistMargin(t, n, r, i);
    o < a && t.children.sort(s);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(t, n, r, s) {
    t.children.sort(s);
    const i = this.toBBox, o = mr(t, 0, n, i), a = mr(t, r - n, r, i);
    let l = Vr(o) + Vr(a);
    for (let u = n; u < r - n; u++) {
      const c = t.children[u];
      gr(o, t.leaf ? i(c) : c), l += Vr(o);
    }
    for (let u = r - n - 1; u >= n; u--) {
      const c = t.children[u];
      gr(a, t.leaf ? i(c) : c), l += Vr(a);
    }
    return l;
  }
  _adjustParentBBoxes(t, n, r) {
    for (let s = r; s >= 0; s--)
      gr(n[s], t);
  }
  _condense(t) {
    for (let n = t.length - 1, r; n >= 0; n--)
      t[n].children.length === 0 ? n > 0 ? (r = t[n - 1].children, r.splice(r.indexOf(t[n]), 1)) : this.clear() : On(t[n], this.toBBox);
  }
};
function Fp(e, t, n) {
  if (!n) return t.indexOf(e);
  for (let r = 0; r < t.length; r++)
    if (n(e, t[r])) return r;
  return -1;
}
function On(e, t) {
  mr(e, 0, e.children.length, t, e);
}
function mr(e, t, n, r, s) {
  s || (s = Nn(null)), s.minX = 1 / 0, s.minY = 1 / 0, s.maxX = -1 / 0, s.maxY = -1 / 0;
  for (let i = t; i < n; i++) {
    const o = e.children[i];
    gr(s, e.leaf ? r(o) : o);
  }
  return s;
}
function gr(e, t) {
  return e.minX = Math.min(e.minX, t.minX), e.minY = Math.min(e.minY, t.minY), e.maxX = Math.max(e.maxX, t.maxX), e.maxY = Math.max(e.maxY, t.maxY), e;
}
function Hp(e, t) {
  return e.minX - t.minX;
}
function $p(e, t) {
  return e.minY - t.minY;
}
function di(e) {
  return (e.maxX - e.minX) * (e.maxY - e.minY);
}
function Vr(e) {
  return e.maxX - e.minX + (e.maxY - e.minY);
}
function Bp(e, t) {
  return (Math.max(t.maxX, e.maxX) - Math.min(t.minX, e.minX)) * (Math.max(t.maxY, e.maxY) - Math.min(t.minY, e.minY));
}
function jp(e, t) {
  const n = Math.max(e.minX, t.minX), r = Math.max(e.minY, t.minY), s = Math.min(e.maxX, t.maxX), i = Math.min(e.maxY, t.maxY);
  return Math.max(0, s - n) * Math.max(0, i - r);
}
function fi(e, t) {
  return e.minX <= t.minX && e.minY <= t.minY && t.maxX <= e.maxX && t.maxY <= e.maxY;
}
function Gr(e, t) {
  return t.minX <= e.maxX && t.minY <= e.maxY && t.maxX >= e.minX && t.maxY >= e.minY;
}
function Nn(e) {
  return {
    children: e,
    height: 1,
    leaf: true,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function ul(e, t, n, r, s) {
  const i = [t, n];
  for (; i.length; ) {
    if (n = i.pop(), t = i.pop(), n - t <= r) continue;
    const o = t + Math.ceil((n - t) / r / 2) * r;
    $u(e, o, t, n, s), i.push(t, o, o, n);
  }
}
function w1(e, t, n, r = false) {
  if (t === 0 && n === 0)
    return e;
  let s = __spreadValues({}, e);
  const i = s.startAbsoluteRefType || ye.NONE, o = s.endAbsoluteRefType || ye.NONE, a = s.rangeType || ge.NORMAL;
  if (!r && i === ye.ALL && o === ye.ALL)
    return s;
  const l = cl(s.startRow, n, s.startColumn, t, a), u = cl(s.endRow, n, s.endColumn, t, a);
  return r || i === ye.NONE && o === ye.NONE ? s = __spreadProps(__spreadValues({}, s), {
    startRow: l.row,
    startColumn: l.column,
    endRow: u.row,
    endColumn: u.column
  }) : (i === ye.NONE ? s = __spreadProps(__spreadValues({}, s), { startRow: l.row, startColumn: l.column }) : i === ye.COLUMN ? s = __spreadProps(__spreadValues({}, s), { startRow: l.row }) : i === ye.ROW && (s = __spreadProps(__spreadValues({}, s), { startColumn: l.column })), o === ye.NONE ? s = __spreadProps(__spreadValues({}, s), { endRow: u.row, endColumn: u.column }) : o === ye.COLUMN ? s = __spreadProps(__spreadValues({}, s), { endRow: u.row }) : o === ye.ROW && (s = __spreadProps(__spreadValues({}, s), { endColumn: u.column })), s);
}
function cl(e, t, n, r, s) {
  return s === ge.NORMAL ? { row: e + t, column: n + r } : s === ge.ROW ? { row: e + t, column: n } : s === ge.COLUMN ? { row: e, column: n + r } : { row: e, column: n };
}
function Bu(e) {
  const t = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set();
  for (const o of e)
    t.add(o.startColumn), t.add(o.endColumn + 1), n.add(o.startRow), n.add(o.endRow + 1);
  const r = Array.from(t).sort((o, a) => o - a), s = Array.from(n).sort((o, a) => o - a);
  e.sort((o, a) => o.startRow - a.startRow || o.startColumn - a.startColumn);
  const i = [];
  for (let o = 0; o < s.length - 1; o++)
    for (let a = 0; a < r.length - 1; a++) {
      const l = r[a], u = r[a + 1] - 1, c = s[o], h = s[o + 1] - 1;
      for (const d of e) {
        if (d.startRow > h)
          break;
        if (d.startRow <= c && d.endRow >= h && d.startColumn <= l && d.endColumn >= u) {
          i.push({
            startColumn: l,
            endColumn: u,
            startRow: c,
            endRow: h
          });
          break;
        }
      }
    }
  return i;
}
function Wp(e) {
  e.sort((r, s) => r.startRow - s.startRow || r.startColumn - s.startColumn);
  const t = {};
  for (const r of e)
    t[r.startRow] || (t[r.startRow] = []), t[r.startRow].push(r);
  const n = [];
  for (const r in t) {
    const s = t[+r];
    s.sort((o, a) => o.startColumn - a.startColumn);
    let i = s[0];
    for (let o = 1; o < s.length; o++) {
      const a = s[o];
      a.startColumn <= i.endColumn + 1 && a.startRow === i.startRow && a.endRow === i.endRow ? i.endColumn = Math.max(i.endColumn, a.endColumn) : (n.push(i), i = a);
    }
    n.push(i);
  }
  return n;
}
function Yp(e) {
  e.sort((r, s) => r.startColumn - s.startColumn || r.startRow - s.startRow);
  const t = {};
  for (const r of e)
    t[r.startColumn] || (t[r.startColumn] = []), t[r.startColumn].push(r);
  const n = [];
  for (const r in t) {
    const s = t[+r];
    s.sort((o, a) => o.startRow - a.startRow);
    let i = s[0];
    for (let o = 1; o < s.length; o++) {
      const a = s[o];
      a.startRow <= i.endRow + 1 && a.startColumn === i.startColumn && a.endColumn === i.endColumn ? i.endRow = Math.max(i.endRow, a.endRow) : (n.push(i), i = a);
    }
    n.push(i);
  }
  return n;
}
function zp(e) {
  const t = Bu(e), n = Wp(t);
  return Yp(n);
}
function Vp(e, t) {
  const n = [];
  return e.forEach((r) => {
    n.push(...Cn.subtract(r, t));
  }), Cn.mergeRanges(n);
}
function Gp(e, t) {
  const n = hl(
    e.startRow,
    e.endRow,
    t.startRow,
    t.endRow
  ), r = hl(
    e.startColumn,
    e.endColumn,
    t.startColumn,
    t.endColumn
  );
  if (!n || !r)
    return null;
  const [s, i] = n, [o, a] = r, l = Kp(
    e.rangeType,
    t.rangeType,
    s,
    i,
    o,
    a
  );
  return {
    startRow: s,
    endRow: i,
    startColumn: o,
    endColumn: a,
    rangeType: l
  };
}
function hl(e, t, n, r) {
  const s = isNaN(e) ? -1 / 0 : e, i = isNaN(t) ? 1 / 0 : t, o = isNaN(n) ? -1 / 0 : n, a = isNaN(r) ? 1 / 0 : r, l = Math.max(s, o), u = Math.min(i, a);
  if (l <= u) {
    const c = l === -1 / 0 ? Number.NaN : l, h = u === 1 / 0 ? Number.NaN : u;
    return [c, h];
  } else
    return null;
}
function Kp(e, t, n, r, s, i) {
  const o = e !== void 0 ? e : dl(n, r, s, i), a = t !== void 0 ? t : dl(n, r, s, i);
  return o === ge.ALL || a === ge.ALL ? o === a ? o : o === ge.ALL ? a : o : o === a ? o : (o === ge.NORMAL || a === ge.NORMAL, ge.NORMAL);
}
function dl(e, t, n, r) {
  const s = !isNaN(e) && !isNaN(t), i = !isNaN(n) && !isNaN(r);
  return s && i ? ge.NORMAL : s ? ge.ROW : i ? ge.COLUMN : ge.ALL;
}
var zt = class zt2 {
  /**
   * Creates a deep copy of an IRange object
   * @param src
   * @example
   * ```typescript
   * const original = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
   * const copy = Rectangle.clone(original);
   * // copy = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 }
   * ```
   */
  static clone(t) {
    return t.rangeType !== void 0 ? {
      startRow: t.startRow,
      startColumn: t.startColumn,
      endRow: t.endRow,
      endColumn: t.endColumn,
      rangeType: t.rangeType
    } : {
      startRow: t.startRow,
      startColumn: t.startColumn,
      endRow: t.endRow,
      endColumn: t.endColumn
    };
  }
  /**
   * Checks if two ranges are equal by comparing their properties
   * @param src
   * @param target
   * @example
   * ```typescript
   * const range1 = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
   * const range2 = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
   * const areEqual = Rectangle.equals(range1, range2); // true
   * ```
   */
  static equals(t, n) {
    return t == null || n == null ? false : t.endRow === n.endRow && t.endColumn === n.endColumn && t.startRow === n.startRow && t.startColumn === n.startColumn && (t.rangeType === n.rangeType || t.rangeType === void 0 && n.rangeType === ge.NORMAL || n.rangeType === void 0 && t.rangeType === ge.NORMAL);
  }
  /**
   * Quickly checks if two normal ranges intersect. For specialized range types,
   * use the intersects() method instead.
   * @param rangeA
   * @param rangeB
   * @example
   * ```typescript
   * const range1 = { startRow: 0, startColumn: 0, endRow: 2, endColumn: 2 };
   * const range2 = { startRow: 1, startColumn: 1, endRow: 3, endColumn: 3 };
   * const doIntersect = Rectangle.simpleRangesIntersect(range1, range2); // true
   * ```
   */
  static simpleRangesIntersect(t, n) {
    const { startRow: r, endRow: s, startColumn: i, endColumn: o } = t, { startRow: a, endRow: l, startColumn: u, endColumn: c } = n, h = r <= l && s >= a, d = i <= c && o >= u;
    return h && d;
  }
  /**
   * Checks if two ranges intersect, handling special range types (ROW, COLUMN)
   * @param src
   * @param target
   * @example
   * ```typescript
   * const rowRange = {
   *   startRow: 0, endRow: 2,
   *   startColumn: NaN, endColumn: NaN,
   *   rangeType: RANGE_TYPE.ROW
   * };
   * const colRange = {
   *   startRow: NaN, endRow: NaN,
   *   startColumn: 0, endColumn: 2,
   *   rangeType: RANGE_TYPE.COLUMN
   * };
   * const doIntersect = Rectangle.intersects(rowRange, colRange); // true
   * ```
   */
  static intersects(t, n) {
    if (t.rangeType === ge.ROW && n.rangeType === ge.COLUMN || t.rangeType === ge.COLUMN && n.rangeType === ge.ROW)
      return true;
    if (t.rangeType === ge.ROW && n.rangeType === ge.ROW)
      return t.startRow <= n.endRow && t.endRow >= n.startRow;
    if (t.rangeType === ge.COLUMN && n.rangeType === ge.COLUMN)
      return t.startColumn <= n.endColumn && t.endColumn >= n.startColumn;
    const r = Math.floor(Number.MAX_SAFE_INTEGER / 10), s = Number.isNaN(t.startRow) ? 0 : t.startRow, i = Number.isNaN(t.endRow) ? r : t.endRow, o = Number.isNaN(t.startColumn) ? 0 : t.startColumn, a = Number.isNaN(t.endColumn) ? r : t.endColumn, l = Number.isNaN(n.startRow) ? 0 : n.startRow, u = Number.isNaN(n.endRow) ? r : n.endRow, c = Number.isNaN(n.startColumn) ? 0 : n.startColumn, h = Number.isNaN(n.endColumn) ? r : n.endColumn, d = Math.abs(o + a - c - h), f = Math.abs(o - a) + Math.abs(c - h), g = Math.abs(s + i - l - u), _ = Math.abs(s - i) + Math.abs(l - u);
    return d <= f && g <= _;
  }
  /**
   * Checks if any of the ranges in the target array intersect with any of the ranges in the source array.
   * Attention! Please make sure there is no NaN in the ranges.
   * @param src
   * @param target
   * @example
   * ```typescript
   * const ranges1 = [
   *   { startRow: 0, startColumn: 0, endRow: 2, endColumn: 2 },
   *   { startRow: 3, startColumn: 3, endRow: 5, endColumn: 5 }
   * ];
   * const ranges2 = [
   *   { startRow: 1, startColumn: 1, endRow: 4, endColumn: 4 },
   *   { startRow: 6, startColumn: 6, endRow: 8, endColumn: 8 }
   * ];
   * const doIntersect = Rectangle.doAnyRangesIntersect(ranges1, ranges2); // true
   * ```
   */
  static doAnyRangesIntersect(t, n) {
    const r = new Fi();
    return r.load(t.map((s) => ({ minX: s.startColumn, minY: s.startRow, maxX: s.endColumn, maxY: s.endRow }))), n.some((s) => r.search({ minX: s.startColumn, minY: s.startRow, maxX: s.endColumn, maxY: s.endRow }).length > 0);
  }
  /**
   * Gets the intersection range between two ranges
   * @param src
   * @param target
   * @deprecated use `getIntersectRange` instead
   * @example
   * ```typescript
   * const range1 = { startRow: 0, startColumn: 0, endRow: 2, endColumn: 2 };
   * const range2 = { startRow: 1, startColumn: 1, endRow: 3, endColumn: 3 };
   * const intersection = Rectangle.getIntersects(range1, range2);
   * // intersection = { startRow: 1, startColumn: 1, endRow: 2, endColumn: 2 }
   * ```
   */
  static getIntersects(t, n) {
    const r = t.startRow, s = t.endRow, i = t.startColumn, o = t.endColumn, a = n.startRow, l = n.endRow, u = n.startColumn, c = n.endColumn;
    let h, d, f, g;
    if (a <= s)
      a >= r ? d = a : d = r;
    else
      return null;
    if (l >= r)
      l >= s ? g = s : g = l;
    else
      return null;
    if (u <= o)
      u > i ? h = u : h = i;
    else
      return null;
    if (c >= i)
      c >= o ? f = o : f = c;
    else
      return null;
    return {
      startRow: d,
      endRow: g,
      startColumn: h,
      endColumn: f,
      rangeType: ge.NORMAL
      // TODO: this may not be accurate
    };
  }
  /**
   * Checks if one range completely contains another range
   * @param src
   * @param target
   * @example
   * ```typescript
   * const outer = { startRow: 0, startColumn: 0, endRow: 3, endColumn: 3 };
   * const inner = { startRow: 1, startColumn: 1, endRow: 2, endColumn: 2 };
   * const contains = Rectangle.contains(outer, inner); // true
   * ```
   */
  static contains(t, n) {
    return t.startRow <= n.startRow && t.endRow >= n.endRow && t.startColumn <= n.startColumn && t.endColumn >= n.endColumn;
  }
  /**
   * Checks if one range strictly contains another range (not equal)
   * @param src
   * @param target
   * @example
   * ```typescript
   * const outer = { startRow: 0, startColumn: 0, endRow: 3, endColumn: 3 };
   * const same = { startRow: 0, startColumn: 0, endRow: 3, endColumn: 3 };
   * const realContains = Rectangle.realContain(outer, same); // false
   * ```
   */
  static realContain(t, n) {
    return zt2.contains(t, n) && (t.startRow < n.startRow || t.endRow > n.endRow || t.startColumn < n.startColumn || t.endColumn > n.endColumn);
  }
  /**
   * Creates a union range that encompasses all input ranges
   * @param {...any} ranges
   * @example
   * ```typescript
   * const range1 = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
   * const range2 = { startRow: 2, startColumn: 2, endRow: 3, endColumn: 3 };
   * const union = Rectangle.union(range1, range2);
   * // union = { startRow: 0, startColumn: 0, endRow: 3, endColumn: 3 }
   * ```
   */
  static union(...t) {
    return t.reduce(
      (n, r) => ({
        startRow: Math.min(n.startRow, r.startRow),
        startColumn: Math.min(n.startColumn, r.startColumn),
        endRow: Math.max(n.endRow, r.endRow),
        endColumn: Math.max(n.endColumn, r.endColumn),
        rangeType: ge.NORMAL
      }),
      t[0]
    );
  }
  /**
   * Creates a union range considering special range types (ROW, COLUMN)
   * @param {...any} ranges
   * @example
   * ```typescript
   * const rowRange = {
   *   startRow: 0, endRow: 2,
   *   rangeType: RANGE_TYPE.ROW
   * };
   * const normalRange = {
   *   startRow: 1, startColumn: 1,
   *   endRow: 3, endColumn: 3
   * };
   * const union = Rectangle.realUnion(rowRange, normalRange);
   * // Result will have NaN for columns due to ROW type
   * ```
   */
  static realUnion(...t) {
    const n = t.some((i) => i.rangeType === ge.COLUMN), r = t.some((i) => i.rangeType === ge.ROW), s = zt2.union(...t);
    return {
      startColumn: r ? Number.NaN : s.startColumn,
      endColumn: r ? Number.NaN : s.endColumn,
      startRow: n ? Number.NaN : s.startRow,
      endRow: n ? Number.NaN : s.endRow,
      rangeType: r ? ge.ROW : n ? ge.COLUMN : ge.NORMAL
    };
  }
  /**
   * Subtracts one range from another, returning the remaining areas as separate ranges
   * @param range1
   * @param range2
   * @example
   * ```typescript
   * const range1 = { startRow: 0, startColumn: 0, endRow: 3, endColumn: 3 };
   * const range2 = { startRow: 1, startColumn: 1, endRow: 2, endColumn: 2 };
   * const result = Rectangle.subtract(range1, range2);
   * // Results in up to 4 ranges representing the non-overlapping areas
   * ```
   */
  static subtract(t, n) {
    if (n.startRow > t.endRow || n.endRow < t.startRow || n.startColumn > t.endColumn || n.endColumn < t.startColumn)
      return [t];
    const r = [];
    n.startRow >= t.startRow && r.push({
      startRow: t.startRow,
      startColumn: t.startColumn,
      endRow: n.startRow - 1,
      endColumn: t.endColumn
    }), n.endRow <= t.endRow && r.push({
      startRow: n.endRow + 1,
      startColumn: t.startColumn,
      endRow: t.endRow,
      endColumn: t.endColumn
    });
    const s = Math.max(t.startRow, n.startRow), i = Math.min(t.endRow, n.endRow);
    return n.startColumn >= t.startColumn && r.push({
      startRow: s,
      startColumn: t.startColumn,
      endRow: i,
      endColumn: n.startColumn - 1
    }), n.endColumn <= t.endColumn && r.push({
      startRow: s,
      startColumn: n.endColumn + 1,
      endRow: i,
      endColumn: t.endColumn
    }), r.filter((a) => a.startRow <= a.endRow && a.startColumn <= a.endColumn);
  }
  /**
   * Merges overlapping or adjacent ranges into larger ranges
   * @param ranges
   * @example
   * ```typescript
   * const ranges = [
   *   { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 },
   *   { startRow: 1, startColumn: 1, endRow: 2, endColumn: 2 }
   * ];
   * const merged = Rectangle.mergeRanges(ranges);
   * // Combines overlapping ranges into larger ones
   * ```
   */
  static mergeRanges(t) {
    return zp(t);
  }
  /**
   * Splits overlapping ranges into a grid of non-overlapping ranges
   * @param ranges
   * @example
   * ```typescript
   * const ranges = [
   *   { startRow: 0, startColumn: 0, endRow: 2, endColumn: 2 },
   *   { startRow: 1, startColumn: 1, endRow: 3, endColumn: 3 }
   * ];
   * const grid = Rectangle.splitIntoGrid(ranges);
   * // Splits into non-overlapping grid sections
   * ```
   */
  static splitIntoGrid(t) {
    return Bu(t);
  }
  /**
   * Subtracts multiple ranges from multiple ranges
   * @param ranges1
   * @param ranges2
   * @example
   * ```typescript
   * const ranges1 = [{ startRow: 0, startColumn: 0, endRow: 3, endColumn: 3 }];
   * const ranges2 = [
   *   { startRow: 1, startColumn: 1, endRow: 2, endColumn: 2 },
   *   { startRow: 2, startColumn: 2, endRow: 3, endColumn: 3 }
   * ];
   * const result = Rectangle.subtractMulti(ranges1, ranges2);
   * // Returns remaining non-overlapping areas
   * ```
   */
  static subtractMulti(t, n) {
    if (!n.length)
      return t;
    let r = t;
    return n.forEach((s) => {
      r = Vp(r, s);
    }), r;
  }
  /**
   * Checks if two rectangles defined by left, top, right, bottom coordinates intersect
   * @param rect1
   * @param rect2
   * @example
   * ```typescript
   * const rect1 = { left: 0, top: 0, right: 10, bottom: 10 };
   * const rect2 = { left: 5, top: 5, right: 15, bottom: 15 };
   * const intersects = Rectangle.hasIntersectionBetweenTwoRect(rect1, rect2); // true
   * ```
   */
  static hasIntersectionBetweenTwoRect(t, n) {
    return !(t.left > n.right || // rect1  rect2 
    t.right < n.left || // rect1  rect2 
    t.top > n.bottom || // rect1  rect2 
    t.bottom < n.top);
  }
  /**
   * Gets the intersection area between two rectangles defined by LTRB coordinates
   * @param rect1
   * @param rect2
   * @example
   * ```typescript
   * const rect1 = { left: 0, top: 0, right: 10, bottom: 10 };
   * const rect2 = { left: 5, top: 5, right: 15, bottom: 15 };
   * const intersection = Rectangle.getIntersectionBetweenTwoRect(rect1, rect2);
   * // Returns { left: 5, top: 5, right: 10, bottom: 10, width: 5, height: 5 }
   * ```
   */
  static getIntersectionBetweenTwoRect(t, n) {
    const r = Math.max(t.left, n.left), s = Math.min(t.right, n.right), i = Math.max(t.top, n.top), o = Math.min(t.bottom, n.bottom);
    return s <= r || o <= i ? null : {
      left: r,
      right: s,
      top: i,
      bottom: o,
      width: s - r,
      height: o - i
    };
  }
  /**
   * Sorts an array of ranges by startRow, then by startColumn
   * @param ranges
   * @example
   * ```typescript
   * const ranges = [
   *   { startRow: 1, startColumn: 0, endRow: 2, endColumn: 1 },
   *   { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 }
   * ];
   * const sorted = Rectangle.sort(ranges);
   * // Ranges will be sorted by startRow first, then startColumn
   * ```
   */
  static sort(t) {
    return t.sort((n, r) => n.startRow - r.startRow || n.startColumn - r.startColumn);
  }
};
p(zt, "getRelativeRange", (t, n) => ({
  startRow: t.startRow - n.startRow,
  endRow: t.endRow - t.startRow,
  startColumn: t.startColumn - n.startColumn,
  endColumn: t.endColumn - t.startColumn
})), /**
* Converts a relative range back to an absolute range based on origin
* @param relativeRange
* @param originRange
* @param absoluteRange
* @example
* ```typescript
* const relative = { startRow: 2, startColumn: 2, endRow: 2, endColumn: 2 };
* const origin = { startRow: 3, startColumn: 3, endRow: 8, endColumn: 8 };
* const absolute = Rectangle.getPositionRange(relative, origin);
* // absolute = { startRow: 5, startColumn: 5, endRow: 7, endColumn: 7 }
* ```
*/
p(zt, "getPositionRange", (t, n, r) => __spreadProps(__spreadValues({}, r || {}), {
  startRow: r && [ye.ROW, ye.ALL].includes(r.startAbsoluteRefType || 0) ? r.startRow : t.startRow + n.startRow,
  endRow: r && [ye.ROW, ye.ALL].includes(r.endAbsoluteRefType || 0) ? r.endRow : t.endRow + t.startRow + n.startRow,
  startColumn: r && [ye.COLUMN, ye.ALL].includes(r.startAbsoluteRefType || 0) ? r.startColumn : t.startColumn + n.startColumn,
  endColumn: r && [ye.COLUMN, ye.ALL].includes(r.endAbsoluteRefType || 0) ? r.endColumn : t.endColumn + t.startColumn + n.startColumn
})), /**
* Moves a range horizontally by a specified step and optionally extends it
* @param range
* @param step
* @param length
* @example
* ```typescript
* const range = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
* const moved = Rectangle.moveHorizontal(range, 2, 1);
* // moved = { startRow: 0, startColumn: 2, endRow: 1, endColumn: 4 }
* ```
*/
p(zt, "moveHorizontal", (t, n = 0, r = 0) => __spreadProps(__spreadValues({}, t), {
  startColumn: t.startColumn + n,
  endColumn: t.endColumn + n + r
})), /**
* Moves a range vertically by a specified step and optionally extends it
* @param range
* @param step
* @param length
* @example
* ```typescript
* const range = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
* const moved = Rectangle.moveVertical(range, 2, 1);
* // moved = { startRow: 2, startColumn: 0, endRow: 4, endColumn: 1 }
* ```
*/
p(zt, "moveVertical", (t, n = 0, r = 0) => __spreadProps(__spreadValues({}, t), {
  startRow: t.startRow + n,
  endRow: t.endRow + n + r
})), /**
* Moves a range by specified offsets in both directions
* @param range
* @param offsetX
* @param offsetY
* @example
* ```typescript
* const range = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
* const moved = Rectangle.moveOffset(range, 2, 3);
* // moved = { startRow: 3, startColumn: 2, endRow: 4, endColumn: 3 }
* ```
*/
p(zt, "moveOffset", (t, n, r) => {
  const s = __spreadValues({}, t);
  switch (t.startAbsoluteRefType) {
    case ye.ROW:
      s.startColumn += n;
      break;
    case ye.COLUMN:
      s.startRow += r;
      break;
    case ye.ALL:
      break;
    case ye.NONE:
    default:
      s.startRow += r, s.startColumn += n;
      break;
  }
  switch (t.endAbsoluteRefType) {
    case ye.ROW:
      s.endColumn += n;
      break;
    case ye.COLUMN:
      s.endRow += r;
      break;
    case ye.ALL:
      break;
    case ye.NONE:
    default:
      s.endRow += r, s.endColumn += n;
      break;
  }
  return s;
});
var Cn = zt;
function Xp(e, t) {
  if (e.length === 0 || e[0].length === 0) return null;
  const n = new Array(e[0].length).fill(0);
  let r = 0, s = null;
  for (let i = 0; i < e.length; i++) {
    for (let a = 0; a < e[0].length; a++)
      n[a] = t(e[i][a]) ? n[a] + 1 : 0;
    const o = qp(n);
    o.area > r && (r = o.area, s = {
      startColumn: o.start,
      startRow: i - o.height + 1,
      endColumn: o.end,
      endRow: i
    });
  }
  return s;
}
function qp(e) {
  const t = [];
  let n = 0, r = { area: 0, height: 0, start: 0, end: 0 }, s = 0;
  for (; s < e.length; )
    if (t.length === 0 || e[s] >= e[t[t.length - 1]])
      t.push(s++);
    else {
      const i = e[t.pop()], o = t.length === 0 ? s : s - t[t.length - 1] - 1;
      i * o > n && (n = i * o, r = { area: n, height: i, start: t.length === 0 ? 0 : t[t.length - 1] + 1, end: s - 1 });
    }
  for (; t.length > 0; ) {
    const i = e[t.pop()], o = t.length === 0 ? s : s - t[t.length - 1] - 1;
    i * o > n && (n = i * o, r = { area: n, height: i, start: t.length === 0 ? 0 : t[t.length - 1] + 1, end: s - 1 });
  }
  return r;
}
function Jp(e, t) {
  vr.foreach(t, (n, r) => {
    e[n][r] = void 0;
  });
}
function S1(e, t) {
  const n = e.toFullArray(), r = [];
  for (; ; ) {
    const s = Xp(n, t);
    if (!s)
      break;
    r.push(s), Jp(n, s);
  }
  return r;
}
var O1 = class {
  constructor(t, n) {
    p(this, "_values", []);
    p(this, "_keys", []);
    p(this, "_keyMaps", /* @__PURE__ */ new Map());
    this._values = t, this._keys = n, t.forEach((r) => {
      this._initKeyMap(r);
    });
  }
  _initKeyMap(t) {
    this._keys.forEach((n) => {
      const r = t[n], s = this._keyMaps.get(n) || /* @__PURE__ */ new Map();
      s.set(r, t), this._keyMaps.set(n, s);
    });
  }
  /**
   * If a key group is specified, the order of values is determined by the key group, otherwise it depends on the keys at initialization
   * @param {string} key
   * @param {K[]} [keyGroup]
   * @return {*}
   * @memberof RefAlias
   */
  getValue(t, n) {
    const r = n || this._keys;
    for (let s = 0; s < r.length; s++) {
      const i = this._keyMaps.get(r[s]);
      if (i != null && i.has(t))
        return i.get(t);
    }
    return null;
  }
  hasValue(t) {
    for (let n = 0; n < this._keys.length; n++) {
      const r = this._keyMaps.get(this._keys[n]);
      if (r != null && r.has(t))
        return true;
    }
    return false;
  }
  addValue(t) {
    this._values.push(t), this._initKeyMap(t);
  }
  setValue(t, n, r) {
    const s = this.getValue(t);
    s && Object.keys(s).includes(n) && (s[n] = r);
  }
  deleteValue(t, n) {
    const r = this.getValue(t, n);
    if (r) {
      this._keys.forEach((i) => {
        const o = this._keyMaps.get(i), a = r[i];
        o == null || o.delete(a);
      });
      const s = this._values.findIndex((i) => i === r);
      this._values.splice(s, 1);
    }
  }
  getValues() {
    return this._values;
  }
  getKeyMap(t) {
    var n;
    return [...((n = this._keyMaps.get(t)) == null ? void 0 : n.keys()) || []];
  }
  clear() {
    this._values = [], this._keys = [], this._keyMaps.clear();
  }
};
function fl(e, t, n, r) {
  return {
    forEach(s) {
      for (let i = e; i <= t; i++)
        for (let o = n; o <= r; o++)
          s(i, o);
    }
  };
}
function v1(e) {
  if (e == null || e.length === 0)
    return Number.NaN;
  const t = e.toLowerCase().split(""), n = t.length, r = (o) => o.charCodeAt(0) - 96;
  let s = 0, i = 0;
  for (let o = 0; o < n; o++)
    i = r(t[o]), s += i * __pow(26, n - o - 1);
  return s === 0 ? Number.NaN : s - 1;
}
var Cs = 65;
var ju = 90;
var Zp = 97;
function b1(e) {
  const t = ju - Cs + 1;
  let n = "";
  for (; e >= 0; )
    n = String.fromCharCode(e % t + Cs) + n, e = Math.floor(e / t) - 1;
  return n;
}
function Qp(e, t) {
  let n = "";
  for (; t > 0; )
    n += e, t--;
  return n;
}
function A1(e, t = false) {
  const n = ju - Cs + 1;
  let r = Zp;
  t && (r = Cs);
  const s = String.fromCharCode(e % n + r), i = Math.floor(e / n) + 1;
  return Qp(s, i);
}
function y1(e, t) {
  return e.zIndex > t.zIndex ? 1 : e.zIndex === t.zIndex ? 0 : -1;
}
function N1(e, t) {
  return e.zIndex > t.zIndex ? -1 : e.zIndex === t.zIndex ? 0 : 1;
}
function Hs(e = "index", t = 1) {
  return (n, r) => n[e] > r[e] ? t : n[e] === r[e] ? 0 : -t;
}
function $s(e, t = false) {
  const n = [];
  for (const r of e) {
    const { st: s, ed: i, ts: o } = r;
    if (r.sId === void 0 && delete r.sId, s === i || !t && Z.isEmptyObject(o) && r.sId == null)
      continue;
    if (n.length === 0) {
      n.push(r);
      continue;
    }
    const a = n.pop();
    Zg(r, a) && Z.hasIntersectionBetweenTwoRanges(a.st, a.ed, r.st, r.ed) ? n.push(__spreadProps(__spreadValues({}, r), {
      st: a.st,
      ed: i
    })) : n.push(a, r);
  }
  return n;
}
function Wu(e, t, n, r) {
  var u;
  const { textRuns: s } = e;
  if (s == null)
    return;
  const i = [], o = s.length;
  let a = false;
  const l = (u = t.textRuns) != null ? u : [];
  if (l.length)
    for (const c of l)
      c.st += r, c.ed += r;
  for (let c = 0; c < o; c++) {
    const h = s[c], { st: d, ed: f } = h;
    if (f <= r)
      i.push(h);
    else if (r > d && r < f) {
      a = true;
      const g = __spreadProps(__spreadValues({}, h), {
        ed: r
      });
      i.push(g), l.length && i.push(...l);
      const _ = __spreadProps(__spreadValues({}, h), {
        st: r + n,
        ed: f + n
      });
      i.push(_);
    } else
      h.st += n, h.ed += n, a || (a = true, i.push(...l)), i.push(h);
  }
  a || (a = true, i.push(...l)), e.textRuns = $s(i);
}
function Yu(e, t, n, r) {
  const { paragraphs: s } = e;
  if (s == null)
    return;
  const { paragraphs: i } = t, o = [];
  for (let l = 0, u = s.length; l < u; l++) {
    const c = s[l], { startIndex: h } = c;
    h >= r && (c.startIndex += n), o.push(c.startIndex);
  }
  let a = -1;
  if (i) {
    for (let l = 0, u = i.length; l < u; l++) {
      const c = i[l];
      c.startIndex += r;
      const h = c.startIndex;
      a = o.indexOf(h);
    }
    a !== -1 && s.splice(a, 1), s.push(...i), s.sort(Hs("startIndex"));
  }
}
function zu(e, t, n, r) {
  const { sectionBreaks: s } = e;
  if (s == null)
    return;
  for (let o = 0, a = s.length; o < a; o++) {
    const l = s[o], { startIndex: u } = l;
    u >= r && (l.startIndex += n);
  }
  const i = t.sectionBreaks;
  if (i) {
    for (let o = 0, a = i.length; o < a; o++) {
      const l = i[o];
      l.startIndex += r;
    }
    s.push(...i), s.sort(Hs("startIndex"));
  }
}
function Vu(e, t, n, r) {
  const { customBlocks: s = [] } = e;
  for (let o = 0, a = s.length; o < a; o++) {
    const l = s[o], { startIndex: u } = l;
    u >= r && (l.startIndex += n);
  }
  const i = t.customBlocks;
  if (i) {
    for (let o = 0, a = i.length; o < a; o++) {
      const l = i[o];
      l.startIndex += r;
    }
    s.push(...i), s.sort(Hs("startIndex"));
  }
  s.length && !e.customBlocks && (e.customBlocks = s);
}
function Gu(e, t, n, r) {
  const { tables: s } = e;
  if (s == null)
    return;
  for (let o = 0, a = s.length; o < a; o++) {
    const l = s[o], { startIndex: u, endIndex: c } = l;
    u > r ? (l.startIndex += n, l.endIndex += n) : c > r && (l.endIndex += n);
  }
  const i = t.tables;
  if (i) {
    for (let o = 0, a = i.length; o < a; o++) {
      const l = i[o];
      l.startIndex += r, l.endIndex += r;
    }
    s.push(...i), s.sort(Hs("startIndex"));
  }
}
var Ku = "$";
var ml = (e) => e.split(Ku)[0];
function Qo(e) {
  if (e.length <= 1) return e;
  e.sort((s, i) => s.startIndex - i.startIndex);
  const t = [];
  let n = __spreadValues({}, e[0]);
  n.rangeId = ml(n.rangeId);
  for (let s = 1; s < e.length; s++) {
    const i = e[s];
    i.rangeId = ml(i.rangeId), i.rangeId === n.rangeId && Xc(n.properties, i.properties) && n.endIndex + 1 >= i.startIndex ? n.endIndex = i.endIndex : (t.push(n), n = __spreadValues({}, i));
  }
  t.push(n);
  const r = /* @__PURE__ */ Object.create(null);
  for (let s = 0, i = t.length; s < i; s++) {
    const o = t[s], a = o.rangeId;
    r[a] ? (o.rangeId = `${a}${Ku}${r[a]}`, r[a] = r[a] + 1) : r[a] = 1;
  }
  return t;
}
function Hi(e, t) {
  const n = e.findIndex((s) => s.startIndex < t && s.endIndex >= t), r = e[n];
  r && e.splice(n, 1, {
    rangeId: r.rangeId,
    rangeType: r.rangeType,
    startIndex: r.startIndex,
    endIndex: t - 1,
    properties: __spreadValues({}, r.properties)
  }, {
    rangeId: r.rangeId,
    rangeType: r.rangeType,
    startIndex: t,
    endIndex: r.endIndex,
    properties: __spreadValues({}, r.properties)
  });
}
function Xu(e) {
  if (e.length <= 1) return e;
  e.sort((r, s) => r.startIndex - s.startIndex);
  const t = [];
  let n = __spreadValues({}, e[0]);
  for (let r = 1; r < e.length; r++) {
    const s = e[r];
    s.id === n.id && n.endIndex + 1 >= s.startIndex ? n.endIndex = s.endIndex : (t.push(n), n = __spreadValues({}, s));
  }
  return t.push(n), t;
}
function $i(e, t) {
  e.filter((r) => r.startIndex < t && r.endIndex >= t).forEach((r) => {
    const s = e.indexOf(r);
    e.splice(s, 1, {
      id: r.id,
      type: r.type,
      startIndex: r.startIndex,
      endIndex: t - 1
    }, {
      id: r.id,
      type: r.type,
      startIndex: t,
      endIndex: r.endIndex
    });
  });
}
function e0(e, t, n, r) {
  e.customRanges || (e.customRanges = []);
  const { customRanges: s } = e;
  Hi(s, r);
  for (let o = 0, a = s.length; o < a; o++) {
    const l = s[o], { startIndex: u } = l;
    u >= r && (l.startIndex += n, l.endIndex += n);
  }
  const i = [];
  if (t.customRanges) {
    for (let o = 0, a = t.customRanges.length; o < a; o++) {
      const l = t.customRanges[o];
      l.startIndex += r, l.endIndex += r, i.push(l);
    }
    s.push(...i);
  }
  e.customRanges = Qo(s);
}
function t0(e, t, n, r) {
  e.customDecorations || (e.customDecorations = []);
  const { customDecorations: s } = e;
  $i(s, r);
  for (let o = 0, a = s.length; o < a; o++) {
    const l = s[o], { startIndex: u } = l;
    u >= r && (l.startIndex += n, l.endIndex += n);
  }
  const i = [];
  if (t.customDecorations) {
    for (let o = 0, a = t.customDecorations.length; o < a; o++) {
      const l = t.customDecorations[o];
      l.startIndex += r, l.endIndex += r, i.push(l);
    }
    s.push(...i);
  }
  e.customDecorations = Xu(s);
}
function qu(e, t, n) {
  const { textRuns: r } = e, s = n, i = n + t, o = [];
  if (r) {
    const a = [];
    for (let l = 0, u = r.length; l < u; l++) {
      const c = r[l], { st: h, ed: d } = c;
      if (s <= h && i >= d) {
        o.push(__spreadProps(__spreadValues({}, c), {
          st: h - s,
          ed: d - s
        }));
        continue;
      } else h <= s && d >= i ? (o.push(__spreadProps(__spreadValues({}, c), {
        st: s - s,
        ed: i - s
      })), c.ed -= t) : s >= h && s < d ? (o.push(__spreadProps(__spreadValues({}, c), {
        st: s - s,
        ed: d - s
      })), c.ed = s) : i > h && i <= d ? (o.push(__spreadProps(__spreadValues({}, c), {
        st: h - s,
        ed: i - s
      })), c.st = i - t, c.ed -= t) : h >= i && (c.st -= t, c.ed -= t);
      a.push(c);
    }
    e.textRuns = a;
  }
  return o.length === 0 && o.push({
    st: 0,
    ed: t,
    ts: {}
  }), o;
}
function Ju(e, t, n) {
  const { paragraphs: r } = e, s = n, i = n + t, o = [];
  if (r) {
    const a = [];
    for (let l = 0, u = r.length; l < u; l++) {
      const c = r[l], { startIndex: h } = c;
      if (h >= s && h < i) {
        o.push(__spreadProps(__spreadValues({}, c), {
          startIndex: h - n
        }));
        continue;
      } else h >= i && (c.startIndex -= t);
      a.push(c);
    }
    e.paragraphs = a;
  }
  return o;
}
function Zu(e, t, n) {
  const { sectionBreaks: r } = e, s = n, i = n + t - 1, o = [];
  if (r) {
    const a = [];
    for (let l = 0, u = r.length; l < u; l++) {
      const c = r[l], { startIndex: h } = c;
      if (h >= s && h <= i) {
        o.push(__spreadProps(__spreadValues({}, c), {
          startIndex: h - n
        }));
        continue;
      } else h > i && (c.startIndex -= t);
      a.push(c);
    }
    e.sectionBreaks = a;
  }
  return o;
}
function Qu(e, t, n) {
  const { customBlocks: r = [] } = e, s = n, i = n + t - 1, o = [];
  if (r) {
    const a = [];
    for (let l = 0, u = r.length; l < u; l++) {
      const c = r[l], { startIndex: h } = c;
      if (h >= s && h <= i) {
        o.push(__spreadProps(__spreadValues({}, c), {
          startIndex: h - n
        }));
        continue;
      } else h > i && (c.startIndex -= t);
      a.push(c);
    }
    e.customBlocks = a;
  }
  return r.length && !e.customBlocks && (e.customBlocks = r), o;
}
function ec(e, t, n) {
  const { tables: r } = e, s = n, i = n + t - 1, o = [];
  if (r) {
    const a = [];
    for (let l = 0, u = r.length; l < u; l++) {
      const c = r[l], { startIndex: h, endIndex: d } = c;
      if (s <= h && i >= d) {
        o.push(__spreadProps(__spreadValues({}, c), {
          startIndex: h - n,
          endIndex: d - n
        }));
        continue;
      } else if (h <= s && d >= i) {
        const f = Co(h, d, s, i);
        if (f.length === 0 || (c.startIndex = f[0], c.endIndex = f[1], c.startIndex === c.endIndex))
          continue;
      } else i < h && (c.startIndex -= t, c.endIndex -= t);
      a.push(c);
    }
    e.tables = a;
  }
  return o;
}
function n0(e, t, n) {
  const { customRanges: r } = e, s = n, i = n + t - 1, o = [];
  if (r) {
    const a = [];
    for (let l = 0, u = r.length; l < u; l++) {
      const c = r[l], { startIndex: h, endIndex: d } = c;
      if (h >= s && d <= i) {
        o.push(c);
        continue;
      } else if (Math.max(s, h) <= Math.min(i, d)) {
        const f = Co(h, d, s, i);
        if (f.length === 0)
          continue;
        c.startIndex = f[0], c.endIndex = f[1];
      } else i < h && (c.startIndex -= t, c.endIndex -= t);
      a.push(c);
    }
    e.customRanges = Qo(a);
  }
  return o;
}
function r0(e, t, n, r = true) {
  const { customDecorations: s } = e, i = n, o = n + t - 1, a = [];
  if (s) {
    const l = [];
    for (let u = 0, c = s.length; u < c; u++) {
      const h = s[u], { startIndex: d, endIndex: f } = h;
      if (d >= i && f <= o) {
        a.push(h);
        continue;
      } else if (Math.max(i, d) <= Math.min(o, f)) {
        const g = Co(d, f, i, o);
        if (g.length === 0)
          continue;
        h.startIndex = g[0], h.endIndex = g[1];
      } else o < d && r && (h.startIndex -= t, h.endIndex -= t);
      l.push(h);
    }
    e.customDecorations = l;
  }
  return a;
}
var s0 = ((e) => (e.ORDER_LIST_QUICK_1 = "1.", e.ORDER_LIST_QUICK_2 = "a)", e.ORDER_LIST_QUICK_3 = "a.", e.ORDER_LIST_QUICK_4 = "i.", e.ORDER_LIST_QUICK_5 = "A.", e.ORDER_LIST_QUICK_6 = "I.", e.ORDER_LIST_QUICK_7 = "01.", e.BULLET_LIST = "*", e))(s0 || {});
var Vt = ((e) => (e.BULLET_LIST = "BULLET_LIST", e.BULLET_LIST_1 = "BULLET_LIST_1", e.BULLET_LIST_2 = "BULLET_LIST_2", e.BULLET_LIST_3 = "BULLET_LIST_3", e.BULLET_LIST_4 = "BULLET_LIST_4", e.BULLET_LIST_5 = "BULLET_LIST_5", e.ORDER_LIST = "ORDER_LIST", e.ORDER_LIST_1 = "ORDER_LIST_1", e.ORDER_LIST_2 = "ORDER_LIST_2", e.ORDER_LIST_3 = "ORDER_LIST_3", e.ORDER_LIST_4 = "ORDER_LIST_4", e.ORDER_LIST_5 = "ORDER_LIST_5", e.ORDER_LIST_QUICK_2 = "ORDER_LIST_QUICK_2", e.ORDER_LIST_QUICK_3 = "ORDER_LIST_QUICK_3", e.ORDER_LIST_QUICK_4 = "ORDER_LIST_QUICK_4", e.ORDER_LIST_QUICK_5 = "ORDER_LIST_QUICK_5", e.ORDER_LIST_QUICK_6 = "ORDER_LIST_QUICK_6", e.CHECK_LIST = "CHECK_LIST", e.CHECK_LIST_CHECKED = "CHECK_LIST_CHECKED", e))(Vt || {});
var Kr = {
  "a)": { glyphFormat: "%1)", glyphType: me.DECIMAL },
  "1.": { glyphType: me.DECIMAL },
  "a.": { glyphFormat: "%1.", glyphType: me.LOWER_LETTER },
  "A.": { glyphType: me.UPPER_LETTER },
  "i.": { glyphFormat: "%1.", glyphType: me.LOWER_ROMAN },
  "I.": { glyphFormat: "%1.", glyphType: me.UPPER_LETTER }
};
var vn = (e) => [
  ...e,
  ...e,
  ...e
].map((t, n) => ({
  glyphFormat: ` %${n + 1}`,
  glyphSymbol: t,
  bulletAlignment: Ms.START,
  textStyle: {
    fs: 12
  },
  startNumber: 0,
  paragraphProperties: {
    hanging: { v: 21 },
    indentStart: { v: 21 * n }
  }
}));
var bn = (e) => e.map((t, n) => __spreadProps(__spreadValues({}, t), {
  bulletAlignment: Ms.START,
  textStyle: {
    fs: 12
  },
  startNumber: 0,
  paragraphProperties: {
    hanging: { v: 21 },
    indentStart: { v: 21 * n }
  }
}));
var gl = (e, t) => new Array(9).fill(0).map((n, r) => ({
  glyphFormat: ` %${r + 1}`,
  glyphSymbol: e,
  bulletAlignment: Ms.START,
  textStyle: {
    fs: 16
  },
  startNumber: 0,
  paragraphProperties: {
    hanging: { v: 21 },
    indentStart: { v: 21 * r },
    textStyle: t
  }
}));
var Bs = {
  BULLET_LIST: {
    listType: "BULLET_LIST",
    nestingLevel: vn(["", "", ""])
  },
  BULLET_LIST_1: {
    listType: "BULLET_LIST",
    nestingLevel: vn(["", "", ""])
  },
  BULLET_LIST_2: {
    listType: "BULLET_LIST",
    nestingLevel: vn(["", "", ""])
  },
  BULLET_LIST_3: {
    listType: "BULLET_LIST",
    nestingLevel: vn(["", "", ""])
  },
  BULLET_LIST_4: {
    listType: "BULLET_LIST",
    nestingLevel: vn(["", "", ""])
  },
  BULLET_LIST_5: {
    listType: "BULLET_LIST",
    nestingLevel: vn(["", "", ""])
  },
  ORDER_LIST: {
    listType: "ORDER_LIST",
    nestingLevel: bn([
      { glyphFormat: "%1.", glyphType: me.DECIMAL },
      { glyphFormat: "%2.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%3.", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%4.", glyphType: me.DECIMAL },
      { glyphFormat: "%5.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%6.", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%7.", glyphType: me.DECIMAL },
      { glyphFormat: "%8.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%9.", glyphType: me.LOWER_ROMAN }
    ])
  },
  ORDER_LIST_1: {
    listType: "ORDER_LIST",
    nestingLevel: bn([
      { glyphFormat: "%1)", glyphType: me.DECIMAL },
      { glyphFormat: "%2)", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%3)", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%4)", glyphType: me.DECIMAL },
      { glyphFormat: "%5)", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%6)", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%7)", glyphType: me.DECIMAL },
      { glyphFormat: "%8)", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%9)", glyphType: me.LOWER_ROMAN }
    ])
  },
  ORDER_LIST_2: {
    listType: "ORDER_LIST",
    nestingLevel: bn([
      "%1.",
      "%1.%2.",
      "%1.%2.%3.",
      "%1.%2.%3.%4.",
      "%1.%2.%3.%4.%5.",
      "%1.%2.%3.%4.%5.%6.",
      "%1.%2.%3.%4.%5.%6.%7."
    ].map((e) => ({ glyphFormat: e, glyphType: me.DECIMAL })))
  },
  ORDER_LIST_3: {
    listType: "ORDER_LIST",
    nestingLevel: bn([
      { glyphFormat: "%1.", glyphType: me.UPPER_LETTER },
      { glyphFormat: "%2.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%3.", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%4.", glyphType: me.UPPER_LETTER },
      { glyphFormat: "%5.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%6.", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%7.", glyphType: me.UPPER_LETTER },
      { glyphFormat: "%8.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%9.", glyphType: me.LOWER_ROMAN }
    ])
  },
  ORDER_LIST_4: {
    listType: "ORDER_LIST",
    nestingLevel: bn([
      { glyphFormat: "%1.", glyphType: me.UPPER_LETTER },
      { glyphFormat: "%2.", glyphType: me.DECIMAL },
      { glyphFormat: "%3.", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%4.", glyphType: me.UPPER_LETTER },
      { glyphFormat: "%5.", glyphType: me.DECIMAL },
      { glyphFormat: "%6.", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%7.", glyphType: me.UPPER_LETTER },
      { glyphFormat: "%8.", glyphType: me.DECIMAL },
      { glyphFormat: "%9.", glyphType: me.LOWER_ROMAN }
    ])
  },
  ORDER_LIST_5: {
    listType: "ORDER_LIST",
    nestingLevel: bn([
      { glyphFormat: "%1.", glyphType: me.DECIMAL_ZERO },
      { glyphFormat: "%2.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%3.", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%4.", glyphType: me.DECIMAL_ZERO },
      { glyphFormat: "%5.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%6.", glyphType: me.LOWER_ROMAN },
      { glyphFormat: "%7.", glyphType: me.DECIMAL_ZERO },
      { glyphFormat: "%8.", glyphType: me.LOWER_LETTER },
      { glyphFormat: "%9.", glyphType: me.LOWER_ROMAN }
    ])
  },
  CHECK_LIST: {
    listType: "CHECK_LIST",
    nestingLevel: gl("")
  },
  CHECK_LIST_CHECKED: {
    listType: "CHECK_LIST_CHECKED",
    nestingLevel: gl(
      "",
      {
        st: {
          s: ie.TRUE
        }
      }
    )
  }
};
var Xr = (e) => {
  const { glyphFormat: t, glyphType: n } = e, r = Z.deepClone(Bs.ORDER_LIST);
  return r.nestingLevel[0].glyphFormat = t, r.nestingLevel[0].glyphType = n, r;
};
var i0 = {
  ORDER_LIST_QUICK_2: Xr(Kr[
    "a)"
    /* ORDER_LIST_QUICK_2 */
  ]),
  ORDER_LIST_QUICK_3: Xr(Kr[
    "a."
    /* ORDER_LIST_QUICK_3 */
  ]),
  ORDER_LIST_QUICK_4: Xr(Kr[
    "i."
    /* ORDER_LIST_QUICK_4 */
  ]),
  ORDER_LIST_QUICK_6: Xr(Kr[
    "I."
    /* ORDER_LIST_QUICK_6 */
  ])
};
Object.assign(Bs, i0);
var T1 = {
  "1.": "ORDER_LIST",
  "a)": "ORDER_LIST_QUICK_2",
  "a.": "ORDER_LIST_QUICK_3",
  "i.": "ORDER_LIST_QUICK_4",
  "A.": "ORDER_LIST_3",
  "I.": "ORDER_LIST_QUICK_6",
  "01.": "ORDER_LIST_5",
  "*": "BULLET_LIST"
  /* BULLET_LIST */
};
function o0(e, t, n, r, s) {
  const i = a0(e, t, n, r, s), o = l0(e, t, n, r, s), a = u0(e, t, n, r, s), l = c0(e, t, n, r, s), u = h0(e, t, n, r, s), c = d0(e, t, n, r), h = f0(e, t, n, r, s);
  return {
    dataStream: "",
    textRuns: i,
    paragraphs: o,
    sectionBreaks: a,
    customBlocks: l,
    tables: u,
    customRanges: c,
    customDecorations: h
  };
}
function a0(e, t, n, r, s) {
  const { textRuns: i } = e, { textRuns: o } = t;
  if (i == null || o == null)
    return;
  const a = qu(e, n, r);
  if (s !== pe.REPLACE) {
    const l = tc(o, a, s);
    t.textRuns = l;
  }
  return Wu(e, t, n, r), a;
}
function tc(e, t, n) {
  if (t.length === 0)
    return e;
  e = Z.deepClone(e), t = Z.deepClone(t);
  const r = [], s = e.length, i = t.length;
  let o = 0, a = 0, l = null;
  function u() {
    return l ? (r.push(l), l = null, true) : false;
  }
  for (; o < s && a < i; ) {
    const { st: f, ed: g, ts: _ } = e[o], { st: R, ed: b, ts: $, sId: k } = t[a];
    let W;
    if (n === pe.COVER ? W = __spreadValues(__spreadValues({}, $), _) : W = __spreadValues({}, _), g < R)
      u() || r.push(e[o]), o++;
    else if (b < f)
      u() || r.push(t[a]), a++;
    else {
      const w = {
        st: Math.min(f, R),
        ed: Math.max(f, R),
        ts: f < R ? __spreadValues({}, _) : __spreadValues({}, $),
        sId: f < R ? void 0 : k
      };
      w.ed > w.st && r.push(w), r.push({
        st: Math.max(f, R),
        ed: Math.min(g, b),
        ts: W,
        sId: k
      }), g < b ? (o++, t[a].st = g, t[a].st === t[a].ed && a++) : (a++, e[o].st = b, e[o].st === e[o].ed && o++);
      const C = {
        st: Math.min(g, b),
        ed: Math.max(g, b),
        ts: g < b ? __spreadValues({}, $) : __spreadValues({}, _),
        sId: g < b ? k : void 0
      };
      l = C.ed > C.st ? C : null;
    }
  }
  u();
  const c = r[r.length - 1], h = e[s - 1], d = t[i - 1];
  return c && c.ed !== Math.max(h.ed, d.ed) && (h.ed > d.ed ? r.push(h) : r.push(d)), $s(r);
}
function l0(e, t, n, r, s) {
  const { paragraphs: i } = e, { paragraphs: o } = t;
  if (i == null || o == null)
    return;
  const a = Ju(e, n, r);
  if (s !== pe.REPLACE) {
    const l = [];
    for (const u of o) {
      const {
        startIndex: c,
        paragraphStyle: h,
        bullet: d
      } = u;
      let f = [];
      for (const g of a) {
        const {
          startIndex: _,
          paragraphStyle: R,
          bullet: b
        } = g;
        let $, k;
        if (s === pe.COVER ? ($ = __spreadValues(__spreadValues({}, R), h), k = __spreadValues(__spreadValues({
          listId: "",
          listType: Vt.BULLET_LIST,
          nestingLevel: 0,
          textStyle: {}
        }, b), d)) : ($ = __spreadValues(__spreadValues({}, h), R), k = __spreadValues(__spreadValues({
          listId: "",
          listType: Vt.BULLET_LIST,
          nestingLevel: 0,
          textStyle: {}
        }, d), b)), c === _) {
          f.push({
            startIndex: c,
            paragraphStyle: $,
            bullet: k
          });
          break;
        }
      }
      l.push(...f), f = [];
    }
    t.paragraphs = l;
  }
  return Yu(e, t, n, r), a;
}
function u0(e, t, n, r, s) {
  const { sectionBreaks: i } = e, { sectionBreaks: o } = t;
  if (i == null || o == null)
    return;
  const a = Zu(e, n, r);
  if (s !== pe.REPLACE) {
    const l = [];
    for (const u of o) {
      const { startIndex: c } = u;
      let h = [];
      for (const d of a) {
        const { startIndex: f } = d;
        if (c === f) {
          s === pe.COVER ? h.push(__spreadValues(__spreadValues({}, d), u)) : h.push(__spreadValues(__spreadValues({}, u), d));
          break;
        }
      }
      l.push(...h), h = [];
    }
    t.sectionBreaks = l;
  }
  return zu(e, t, n, r), a;
}
function c0(e, t, n, r, s) {
  const { customBlocks: i = [] } = e, { customBlocks: o } = t;
  if (i == null || o == null)
    return;
  const a = Qu(e, n, r);
  if (s !== pe.REPLACE) {
    const l = [];
    for (const u of o) {
      const { startIndex: c } = u;
      let h = [];
      for (const d of a) {
        const { startIndex: f } = d;
        if (c === f) {
          s === pe.COVER ? h.push(__spreadValues(__spreadValues({}, d), u)) : h.push(__spreadValues(__spreadValues({}, u), d));
          break;
        }
      }
      l.push(...h), h = [];
    }
    t.customBlocks = l;
  }
  return Vu(e, t, n, r), i.length && !e.customBlocks && (e.customBlocks = i), a;
}
function h0(e, t, n, r, s) {
  const { tables: i } = e, { tables: o } = t;
  if (i == null || o == null)
    return;
  const a = ec(e, n, r);
  if (s !== pe.REPLACE) {
    const l = [];
    for (const u of o) {
      const { startIndex: c, endIndex: h } = u;
      let d = [];
      for (const f of a) {
        const { startIndex: g, endIndex: _ } = f;
        if (g >= c && _ <= h) {
          s === pe.COVER ? d.push(__spreadValues(__spreadValues({}, f), u)) : d.push(__spreadValues(__spreadValues({}, u), f));
          break;
        }
      }
      l.push(...d), d = [];
    }
    t.tables = l;
  }
  return Gu(e, t, n, r), a;
}
function d0(e, t, n, r, s) {
  e.customRanges || (e.customRanges = []), Hi(e.customRanges, r), Hi(e.customRanges, r + n);
  const i = r, o = r + n - 1, { customRanges: a } = t, l = [], u = /* @__PURE__ */ new Map();
  e.customRanges.forEach((h) => {
    const { startIndex: d, endIndex: f } = h;
    d >= i && f <= o ? u.set(h.rangeId, h) : l.push(h);
  });
  const c = [];
  return a ? (a.forEach((h) => {
    const { startIndex: d, endIndex: f } = h;
    l.push(__spreadProps(__spreadValues({}, h), {
      startIndex: d + r,
      endIndex: f + r
    }));
  }), e.customRanges = Qo(l), c) : [];
}
function f0(e, t, n, r, s) {
  e.customDecorations || (e.customDecorations = []), $i(e.customDecorations, r), $i(e.customDecorations, r + n);
  const i = [], { customDecorations: o } = e, { customDecorations: a = [] } = t;
  if (s === pe.REPLACE) {
    for (let l = 0; l < o.length; l++) {
      const u = o[l], { startIndex: c, endIndex: h } = u;
      c >= r && h <= r + n - 1 && i.push(u);
    }
    a.forEach((l) => {
      const { startIndex: u, endIndex: c } = l;
      o.push(__spreadProps(__spreadValues({}, l), {
        startIndex: u + r,
        endIndex: c + r
      }));
    });
  } else
    for (const l of a) {
      const { id: u } = l;
      if (l.type === Un.DELETED) {
        const c = o.filter((h) => h.id === u);
        c.length && i.push(...c);
      } else
        o.push(__spreadProps(__spreadValues({}, l), {
          startIndex: l.startIndex + r,
          endIndex: l.endIndex + r
        }));
    }
  for (const l of i) {
    const { id: u } = l, c = o.findIndex((h) => h.id === u);
    c !== -1 && o.splice(c, 1);
  }
  return e.customDecorations = Xu(o), i;
}
var nc = ((e) => (e[e.copy = 0] = "copy", e[e.cut = 1] = "cut", e))(nc || {});
function Bi(e, t, n, r = true) {
  const { textRuns: s } = e;
  if (s) {
    const i = [];
    for (const o of s) {
      const a = Z.deepClone(o), { st: l, ed: u } = a;
      Z.hasIntersectionBetweenTwoRanges(l, u, t, n) && (t >= l && t <= u ? i.push(__spreadProps(__spreadValues({}, a), {
        st: t,
        ed: Math.min(n, u)
      })) : n >= l && n <= u ? i.push(__spreadProps(__spreadValues({}, a), {
        st: Math.max(t, l),
        ed: n
      })) : i.push(a));
    }
    return $s(
      i.map((o) => {
        const { st: a, ed: l } = o;
        return __spreadProps(__spreadValues({}, o), {
          st: a - t,
          ed: l - t
        });
      })
    );
  } else if (r)
    return [{
      st: 0,
      ed: n - t,
      ts: {}
    }];
}
function m0(e, t, n) {
  const { tables: r = [] } = e, s = [];
  for (const i of r) {
    const o = Z.deepClone(i), { startIndex: a, endIndex: l } = o;
    a >= t && l <= n && s.push(__spreadProps(__spreadValues({}, o), {
      startIndex: a - t,
      endIndex: l - t
    }));
  }
  return s;
}
function g0(e, t, n) {
  const { paragraphs: r = [] } = e, s = [];
  for (const i of r) {
    const { startIndex: o } = i;
    if (o >= t && o < n) {
      const a = Z.deepClone(i);
      s.push(a);
    }
  }
  if (s.length)
    return s.map((i) => __spreadProps(__spreadValues({}, i), {
      startIndex: i.startIndex - t
    }));
}
function M1(e, t, n) {
  const { sectionBreaks: r = [] } = e, s = [];
  for (const i of r) {
    const { startIndex: o } = i;
    o >= t && o <= n && s.push(Z.deepClone(i));
  }
  if (s.length)
    return s.map((i) => __spreadProps(__spreadValues({}, i), {
      startIndex: i.startIndex - t
    }));
}
function _0(e, t, n) {
  const { customBlocks: r = [] } = e, s = [];
  for (const i of r) {
    const { startIndex: o } = i;
    o >= t && o < n && s.push(Z.deepClone(i));
  }
  if (s.length)
    return s.map((i) => __spreadProps(__spreadValues({}, i), {
      startIndex: i.startIndex - t
    }));
}
function kt(e, t, n, r = true, s = 1) {
  const { dataStream: i } = e, o = {
    dataStream: i.slice(t, n)
  };
  o.textRuns = Bi(e, t, n, r);
  const a = m0(e, t, n);
  if (a.length && (o.tables = a), o.paragraphs = g0(e, t, n), s === 1) {
    const u = E0(e, t, n);
    u ? o.customDecorations = u : r && (o.customDecorations = []);
  }
  const { customRanges: l } = p0(e, t, n);
  return l ? o.customRanges = l : r && (o.customRanges = []), o.customBlocks = _0(e, t, n), o;
}
function x1(e) {
  const { dataStream: t, textRuns: n, paragraphs: r, customRanges: s, customDecorations: i, tables: o } = e;
  let a = 0, l = 0;
  s == null || s.forEach((c) => {
    c.startIndex < 0 && (a = Math.max(a, -c.startIndex)), c.endIndex > t.length - 1 && (l = Math.max(l, c.endIndex - t.length + 1));
  });
  const u = `${t}`;
  return n && (n[0] && (n[0].st = n[0].st - a), n[n.length - 1] && (n[n.length - 1].ed = n[n.length - 1].ed + l)), n == null || n.forEach((c) => {
    c.st += a, c.ed += a;
  }), r == null || r.forEach((c) => {
    c.startIndex += a;
  }), s == null || s.forEach((c) => {
    c.startIndex += a, c.endIndex += a;
  }), i == null || i.forEach((c) => {
    c.startIndex += a, c.endIndex += l;
  }), o == null || o.forEach((c) => {
    c.startIndex += a, c.endIndex += l;
  }), __spreadProps(__spreadValues({}, e), {
    dataStream: u,
    textRuns: n,
    paragraphs: r,
    customRanges: s,
    customDecorations: i,
    tables: o
  });
}
function p0(e, t, n) {
  if (e.customRanges == null)
    return {};
  const { customRanges: r } = e;
  return {
    customRanges: r.filter((a) => Math.max(a.startIndex, t) <= Math.min(a.endIndex, n - 1)).map((a) => __spreadProps(__spreadValues({}, a), {
      startIndex: Math.max(a.startIndex, t),
      endIndex: Math.min(a.endIndex, n - 1)
    })).map((a) => __spreadProps(__spreadValues({}, a), {
      startIndex: a.startIndex - t,
      endIndex: a.endIndex - t
    })),
    leftOffset: 0,
    rightOffset: 0
  };
}
function E0(e, t, n) {
  if (e.customDecorations == null)
    return;
  const { customDecorations: r = [] } = e, s = [];
  return r.forEach((i) => {
    if (Math.max(i.startIndex, t) <= Math.min(i.endIndex, n - 1)) {
      const o = Z.deepClone(i);
      s.push(__spreadProps(__spreadValues({}, o), {
        startIndex: Math.max(o.startIndex - t, 0),
        endIndex: Math.min(o.endIndex, n - 1) - t
      }));
    }
  }), s;
}
function C0(e, t, n) {
  return e == null || t == null ? e != null ? e : t : tc(e, t, n);
}
function R0(e, t, n) {
  if (e == null || t == null)
    return e != null ? e : t;
  if (t.length === 0 || e.length === 0)
    return e;
  if (t.length > 1 || e.length > 1)
    throw new Error("Cannot cover multiple customRanges");
  return n === pe.REPLACE ? [__spreadValues({}, e[0])] : [__spreadValues(__spreadValues({}, t[0]), e[0])];
}
function I0(e, t, n) {
  return t.length === 0 || e.length === 0 || n === pe.REPLACE ? e : [
    ...e,
    ...t.filter((r) => !e.some((s) => r.id === s.id))
  ];
}
function _l(e, t, n = pe.COVER) {
  if (t.dataStream !== "")
    throw new Error("Cannot compose other body with non-empty dataStream");
  const r = {
    dataStream: e.dataStream
  }, {
    textRuns: s,
    paragraphs: i = [],
    customRanges: o,
    customDecorations: a = []
  } = e, {
    textRuns: l,
    paragraphs: u = [],
    customRanges: c,
    customDecorations: h = []
  } = t;
  r.textRuns = C0(l, s, n), r.customRanges = R0(c, o, n);
  const d = I0(h, a, n);
  d.length && (r.customDecorations = d);
  const f = [];
  let g = 0, _ = 0;
  for (; g < i.length && _ < u.length; ) {
    const R = i[g], b = u[_], { startIndex: $ } = R, { startIndex: k } = b;
    $ === k ? (f.push(Z.deepMerge(R, b)), g++, _++) : $ < k ? (f.push(Z.deepClone(R)), g++) : (f.push(Z.deepClone(b)), _++);
  }
  return g < i.length && f.push(...i.slice(g)), _ < u.length && f.push(...u.slice(_)), f.length && (r.paragraphs = f), r;
}
function w0(e) {
  const { body: t } = e;
  if (t == null)
    return true;
  const { textRuns: n, paragraphs: r, customRanges: s, customBlocks: i, customDecorations: o, tables: a } = t;
  return n == null && r == null && s == null && i == null && o == null && a == null;
}
var tr = class {
  constructor(t) {
    p(this, "_index", 0);
    p(this, "_offset", 0);
    this._actions = t;
  }
  hasNext() {
    return this.peekLength() < Number.POSITIVE_INFINITY;
  }
  next(t) {
    t || (t = Number.POSITIVE_INFINITY);
    const n = this._actions[this._index];
    if (n) {
      const r = this._offset, s = n.len;
      return t >= s - r ? (t = s - r, this._index += 1, this._offset = 0) : this._offset += t, n.t === J.DELETE || n.t === J.RETAIN && n.body == null ? Z.deepClone(__spreadProps(__spreadValues({}, n), {
        len: t
      })) : Z.deepClone(__spreadProps(__spreadValues({}, n), {
        len: t,
        body: kt(n.body, r, r + t, false)
      }));
    } else
      return {
        t: J.RETAIN,
        len: Number.POSITIVE_INFINITY
      };
  }
  peek() {
    return this._actions[this._index];
  }
  peekLength() {
    return this._actions[this._index] ? this._actions[this._index].len - this._offset : Number.POSITIVE_INFINITY;
  }
  peekType() {
    const t = this._actions[this._index];
    return t ? t.t : J.RETAIN;
  }
  rest() {
    if (this.hasNext()) {
      if (this._offset === 0)
        return this._actions.slice(this._index);
      {
        const t = this._offset, n = this._index, r = this.next(), s = this._actions.slice(this._index);
        return this._offset = t, this._index = n, [r].concat(s);
      }
    } else return [];
  }
};
function S0(e, t, n) {
  const { dataStream: r } = e, s = n, i = n + t, o = qu(e, t, n), a = Ju(e, t, n), l = Zu(e, t, n), u = Qu(e, t, n), c = ec(e, t, n), h = n0(e, t, n), d = r0(e, t, n);
  let f = "";
  return r && (e.dataStream = P_(r, s, i), f = r.slice(s, i)), {
    dataStream: f,
    textRuns: o,
    paragraphs: a,
    sectionBreaks: l,
    customBlocks: u,
    tables: c,
    customRanges: h,
    customDecorations: d
  };
}
function O0(e, t, n, r) {
  e.dataStream = U_(e.dataStream, r, t.dataStream), Wu(e, t, n, r), Yu(e, t, n, r), zu(e, t, n, r), Vu(e, t, n, r), Gu(e, t, n, r), e0(e, t, n, r), t0(e, t, n, r);
}
function v0(e, t, n, r, s = pe.COVER) {
  return o0(e, t, n, r, s);
}
function b0(e, t, n) {
  return t <= 0 ? { dataStream: "" } : S0(e, t, n);
}
function A0(e, t, n, r) {
  n !== 0 && O0(e, t, n, r);
}
function y0(e, t) {
  const n = new Kn();
  return n.reset(), t.forEach((r) => {
    const s = Z.deepClone(r);
    switch (s.t) {
      case J.RETAIN: {
        const { coverType: i, body: o, len: a } = s;
        o != null && v0(e, o, a, n.cursor, i), n.moveCursor(a);
        break;
      }
      case J.INSERT: {
        const { body: i, len: o } = s;
        A0(e, i, o, n.cursor), n.moveCursor(o);
        break;
      }
      case J.DELETE: {
        const { len: i } = s;
        b0(e, i, n.cursor);
        break;
      }
      default:
        throw new Error(`Unknown action type for action: ${s}.`);
    }
  }), e;
}
function N0(e, t, n, r, s) {
  if (e == null || t == null)
    return t;
  if (e.length === 0 || t.length === 0)
    return [];
  t = Z.deepClone(t), e = Z.deepClone(e);
  const i = [], o = t.length, a = e.length;
  let l = 0, u = 0, c = null;
  function h() {
    return c ? (i.push(c), c = null, true) : false;
  }
  for (; l < o && u < a; ) {
    const { st: _, ed: R, ts: b } = t[l], { st: $, ed: k, ts: W, sId: w } = e[u];
    let C = {};
    if (s === 0)
      C = __spreadValues({}, b), n === pe.COVER && r === pe.REPLACE && W && (C = Object.assign({}, W, C));
    else if (C = __spreadValues({}, b), n === pe.REPLACE) {
      if (r === pe.REPLACE)
        C = __spreadValues({}, W);
      else if (b && W) {
        const v = Object.keys(b);
        for (const y of v)
          W[y] && delete C[y];
      }
    } else if (r === pe.REPLACE) {
      if (W) {
        const v = Object.keys(W);
        for (const y of v)
          W[y] !== void 0 && (C[y] = W[y]);
      }
    } else if (W) {
      const v = Object.keys(W);
      for (const y of v)
        C[y] !== void 0 && delete C[y];
    }
    if (R < $)
      h() || i.push(t[l]), l++;
    else if (k < _)
      h() || i.push(e[u]), u++;
    else {
      const v = {
        st: Math.min(_, $),
        ed: Math.max(_, $),
        ts: _ < $ ? __spreadValues({}, b) : __spreadValues({}, W)
      };
      v.ed > v.st && i.push(), i.push({
        st: Math.max(_, $),
        ed: Math.min(R, k),
        ts: C,
        sId: w
      }), R < k ? (l++, e[u].st = R, e[u].st === e[u].ed && u++) : (u++, t[l].st = k, t[l].st === t[l].ed && l++);
      const y = {
        st: Math.min(R, k),
        ed: Math.max(R, k),
        ts: R < k ? __spreadValues({}, W) : __spreadValues({}, b),
        sId: R < k ? w : void 0
      };
      c = y.ed > y.st ? y : null;
    }
  }
  h();
  const d = i[i.length - 1], f = t[o - 1], g = e[a - 1];
  return d.ed !== Math.max(f.ed, g.ed) && (f.ed > g.ed ? i.push(f) : i.push(g)), $s(i, true);
}
function T0(e, t, n, r, s) {
  if (e == null || t == null)
    return t;
  if (e.length === 0 || t.length === 0)
    return [];
  if (e.length > 1 || t.length > 1)
    throw new Error("CustomRanges is only supported transform for length one now.");
  const i = e[0], o = t[0];
  if (n === pe.REPLACE)
    return s === 1 ? [Z.deepClone(i)] : [Z.deepClone(o)];
  if (r === pe.REPLACE) {
    const a = Z.deepClone(o);
    return s === 1 && Object.assign(a, Z.deepClone(i)), [a];
  } else {
    const a = Z.deepClone(o);
    return s === 1 && Object.assign(a, Z.deepClone(i)), [a];
  }
}
function pl(e, t, n, r, s) {
  const i = {
    startIndex: t.startIndex
  };
  if (t.paragraphStyle && (i.paragraphStyle = Z.deepClone(t.paragraphStyle), e.paragraphStyle)) {
    if (n === pe.REPLACE)
      if (r === pe.REPLACE)
        s === 1 && (i.paragraphStyle = __spreadValues({}, e.paragraphStyle));
      else if (s === 1) {
        const o = Object.keys(e.paragraphStyle);
        for (const a of o)
          e.paragraphStyle[a] !== void 0 && (i.paragraphStyle[a] = e.paragraphStyle[a]);
      } else {
        const o = Object.keys(e.paragraphStyle);
        for (const a of o)
          i.paragraphStyle[a] === void 0 && (i.paragraphStyle[a] = e.paragraphStyle[a]);
      }
    else if (r === pe.REPLACE)
      if (s === 1) {
        const o = Object.keys(e.paragraphStyle);
        for (const a of o)
          e.paragraphStyle[a] !== void 0 && (i.paragraphStyle[a] = e.paragraphStyle[a]);
      } else {
        const o = Object.keys(e.paragraphStyle);
        for (const a of o)
          i.paragraphStyle[a] === void 0 && (i.paragraphStyle[a] = e.paragraphStyle[a]);
      }
    else if (s === 1) {
      const o = Object.keys(e.paragraphStyle);
      for (const a of o)
        i.paragraphStyle[a] && delete i.paragraphStyle[a];
    }
  }
  return n === pe.REPLACE && r === pe.REPLACE ? i.bullet = s === 1 ? Z.deepClone(e.bullet) : Z.deepClone(t.bullet) : e.bullet === void 0 ? i.bullet = Z.deepClone(t.bullet) : n === pe.REPLACE || r === pe.REPLACE ? i.bullet = s === 0 && t.bullet ? Z.deepClone(t.bullet) : Z.deepClone(e.bullet) : s === 0 && t.bullet !== void 0 && (i.bullet = Z.deepClone(t.bullet)), i;
}
function M0(e, t) {
  if (e == null || t == null)
    return t;
  if (e.length === 0 || t.length === 0)
    return Z.deepClone(t);
  const n = [];
  for (const r of t) {
    const { id: s, type: i } = r;
    let o = false;
    for (const a of e)
      if (a.id === s) {
        (a.type === Un.DELETED || i === Un.DELETED) && (o = true, n.push(__spreadProps(__spreadValues({}, r), {
          type: Un.DELETED
        })));
        break;
      }
    o || n.push(r);
  }
  return n;
}
function x0(e, t, n = false) {
  const { body: r, coverType: s = pe.COVER } = e, { body: i, coverType: o = pe.COVER } = t;
  if (r == null || r.dataStream !== "" || i == null || i.dataStream !== "")
    throw new Error("Data stream is not supported in retain transform.");
  const a = {
    dataStream: ""
  }, l = o, {
    textRuns: u,
    paragraphs: c = [],
    customRanges: h,
    customDecorations: d
  } = r, {
    textRuns: f,
    paragraphs: g = [],
    customRanges: _,
    customDecorations: R
  } = i, b = N0(
    u,
    f,
    s,
    o,
    n ? 1 : 0
    /* COVER */
  );
  b && (a.textRuns = b);
  const $ = T0(
    h,
    _,
    s,
    o,
    n ? 1 : 0
    /* COVER */
  );
  $ && (a.customRanges = $);
  const k = M0(
    d,
    R
  );
  k && (a.customDecorations = k);
  const W = [];
  let w = 0, C = 0;
  for (; w < c.length && C < g.length; ) {
    const v = c[w], y = g[C], { startIndex: F2 } = v, { startIndex: H } = y;
    if (F2 === H) {
      let m = {
        startIndex: F2
      };
      n ? m = pl(
        v,
        y,
        s,
        o,
        1
        /* COVER_ONLY_NOT_EXISTED */
      ) : m = pl(
        v,
        y,
        s,
        o,
        0
        /* COVER */
      ), W.push(m), w++, C++;
    } else F2 < H ? w++ : (W.push(Z.deepClone(y)), C++);
  }
  return C < g.length && W.push(...g.slice(C)), W.length && (a.paragraphs = W), {
    coverType: l,
    body: a
  };
}
function El(e) {
  return Object.keys(e).length === 1;
}
var xn = class xn2 {
  constructor() {
    p(this, "_actions", []);
  }
  static apply(t, n) {
    return y0(t, n);
  }
  // eslint-disable-next-line complexity
  static compose(t, n) {
    const r = new tr(t), s = new tr(n), i = new xn2();
    for (; r.hasNext() || s.hasNext(); )
      if (s.peekType() === J.INSERT)
        i.push(s.next());
      else if (r.peekType() === J.DELETE)
        i.push(r.next());
      else {
        const o = Math.min(r.peekLength(), s.peekLength()), a = r.next(o), l = s.next(o);
        if (a.t === J.INSERT && l.t === J.RETAIN)
          l.body == null ? i.push(a) : i.push(__spreadProps(__spreadValues({}, a), {
            body: _l(a.body, l.body, l.coverType)
          }));
        else if (a.t === J.RETAIN && l.t === J.RETAIN)
          if (a.body == null && l.body == null)
            i.push(a.len !== Number.POSITIVE_INFINITY ? a : l);
          else if (a.body && l.body) {
            const u = a.coverType === pe.REPLACE || l.coverType === pe.REPLACE ? pe.REPLACE : pe.COVER;
            i.push(__spreadProps(__spreadValues({}, a), {
              t: J.RETAIN,
              coverType: u,
              body: _l(a.body, l.body, l.coverType)
            }));
          } else
            i.push(a.body ? a : l);
        else a.t === J.RETAIN && l.t === J.DELETE ? i.push(l) : a.t === J.INSERT && (l.t, J.DELETE);
      }
    return i.trimEndUselessRetainAction(), i.serialize();
  }
  /**
   * |(this \| other) | **insert** | **retain** | **delete** |
   * | ---------------- | ---------- | ---------- | ---------- |
   * |    **insert**    |   Case 1   |   Case 2   |   Case 2   |
   * |    **retain**    |   Case 1   |   Case 5   |   Case 4   |
   * |    **delete**    |   Case 1   |   Case 3   |   Case 3   |
   *
   * Case 1: When the other action type is an insert operation,
   *         the insert operation is retained regardless of the type of action this action
   * Case 2: When this action type is an insert operation and the other action type is a
   *         non-insert operation, you need to retain the length of this action insert
   * Case 3: When this action is a delete operation, there are two scenarios:
   *      1) When other is a delete operation, since it is a delete operation, this has
   *         already been deleted, so the target does not need to be in delete, and it can
   *         be continued directly
   *      2) When other is the retain operation, although this action delete occurs first,
   *         the delete priority is higher, so the delete operation is retained, and the origin
   *         delete has been applied, so it is directly continued
   * Case 4: other is the delete operation, this is the retain operation, and the target delete operation
   *         is kept
   * Case 5: When both other and this are retain operations
   *      1) If the other body attribute does not exist, directly retain length
   *      2) If the other body property exists, then execute the TransformBody logic to override it
   */
  // priority - if true, this actions takes priority over other, that is, this actions are considered to happen "first".
  // thisActions is the target action.
  static transform(t, n, r = "right") {
    return this._transform(n, t, r === "left" ? "right" : "left");
  }
  // otherActions is the actions to be transformed.
  static _transform(t, n, r = "right") {
    const s = new tr(t), i = new tr(n), o = new xn2();
    for (; s.hasNext() || i.hasNext(); )
      if (s.peekType() === J.INSERT && (r === "left" || i.peekType() !== J.INSERT)) {
        const a = s.next();
        o.retain(a.len);
      } else if (i.peekType() === J.INSERT)
        o.push(i.next());
      else {
        const a = Math.min(s.peekLength(), i.peekLength()), l = s.next(a), u = i.next(a);
        if (l.t === J.DELETE)
          continue;
        if (u.t === J.DELETE) {
          o.push(u);
          continue;
        }
        if (l.body == null || u.body == null)
          o.push(u);
        else {
          const { coverType: c, body: h } = x0(l, u, r === "left");
          o.push(__spreadProps(__spreadValues({}, u), {
            t: J.RETAIN,
            coverType: c,
            body: h
          }));
        }
      }
    return o.trimEndUselessRetainAction(), o.serialize();
  }
  /**
   * Used to transform selection. Why not named transformSelection?
   * Because Univer Doc supports multiple Selections in one document, user need to encapsulate transformSelections at the application layer.
   */
  static transformPosition(t, n, r = false) {
    const s = new tr(t);
    let i = 0;
    for (; s.hasNext() && i <= n; ) {
      const o = s.peekLength(), a = s.peekType();
      if (s.next(), a === J.DELETE) {
        n -= Math.min(o, n - i);
        continue;
      } else a === J.INSERT && (i < n || !r) && (n += o);
      i += o;
    }
    return n;
  }
  static isNoop(t) {
    return t.length === 0;
  }
  static invert(t) {
    const n = [];
    for (const r of t)
      if (r.t === J.INSERT)
        n.push({
          t: J.DELETE,
          len: r.len,
          body: r.body
        });
      else if (r.t === J.DELETE) {
        if (r.body == null)
          throw new Error("Can not invert DELETE action without body property, makeInvertible must be called first.");
        n.push({
          t: J.INSERT,
          body: r.body,
          len: r.len
        });
      } else if (r.body != null) {
        if (r.oldBody == null)
          throw new Error("Can not invert RETAIN action without oldBody property, makeInvertible must be called first.");
        n.push({
          t: J.RETAIN,
          body: r.oldBody,
          oldBody: r.body,
          len: r.len,
          coverType: pe.REPLACE
        });
      } else
        n.push(r);
    return n;
  }
  static makeInvertible(t, n) {
    const r = [];
    let s = 0;
    for (const i of t) {
      if (i.t === J.DELETE && (i.body == null || i.body && i.body.dataStream.length !== i.len)) {
        const o = kt(n, s, s + i.len, false);
        i.len = o.dataStream.length, i.body = o;
      }
      if (i.t === J.RETAIN && i.body != null) {
        const o = kt(n, s, s + i.len, true);
        i.oldBody = __spreadProps(__spreadValues({}, o), {
          dataStream: ""
        }), i.len = o.dataStream.length;
      }
      r.push(i), i.t !== J.INSERT && (s += i.len);
    }
    return r;
  }
  insert(t, n) {
    const r = {
      t: J.INSERT,
      body: n,
      len: t
    };
    return this.push(r), this;
  }
  retain(t, n, r) {
    const s = {
      t: J.RETAIN,
      len: t
    };
    return n != null && (s.body = n), r != null && (s.coverType = r), this.push(s), this;
  }
  delete(t) {
    const n = {
      t: J.DELETE,
      len: t
    };
    return this.push(n), this;
  }
  empty() {
    return this._actions = [], this;
  }
  serialize() {
    return this._actions;
  }
  // eslint-disable-next-line complexity
  push(...t) {
    if (t.length > 1) {
      for (const i of t)
        this.push(i);
      return this;
    }
    let n = this._actions.length, r = this._actions[n - 1];
    const s = Z.deepClone(t[0]);
    if (s.t === J.RETAIN && s.len === 0 && s.body == null)
      return this;
    if (typeof r == "object") {
      if (r.t === J.DELETE && s.t === J.DELETE)
        return r.len += s.len, this;
      if (r.t === J.DELETE && s.t === J.INSERT && (n -= 1, r = this._actions[n - 1], r == null))
        return this._actions.unshift(s), this;
      if (r.t === J.RETAIN && s.t === J.RETAIN && r.body == null && s.body == null)
        return r.len += s.len, this;
      if (r.t === J.INSERT && El(r.body) && s.t === J.INSERT && El(s.body))
        return r.len += s.len, r.body.dataStream += s.body.dataStream, this;
    }
    return n === this._actions.length ? this._actions.push(s) : this._actions.splice(n, 0, s), this;
  }
  trimEndUselessRetainAction() {
    let t = this._actions[this._actions.length - 1];
    for (; t && t.t === J.RETAIN && w0(t); )
      this._actions.pop(), t = this._actions[this._actions.length - 1];
    return this;
  }
};
p(xn, "id", "text-x"), p(xn, "uri", "https://github.com/dream-num/univer#text-x");
var Ne = xn;
Object.defineProperty(Ne, "name", {
  value: "text-x"
});
var Ln = class Ln2 {
  static registerSubtype(t) {
    var n;
    t == null || this._subTypes.has(t.name) && ((n = this._subTypes.get(t.name)) == null ? void 0 : n.id) !== Ne.id || (this._subTypes.set(t.name, t), it.type.registerSubtype(t));
  }
  static apply(t, n) {
    if (!it.type.isNoop(n))
      return it.type.apply(t, n);
  }
  static compose(t, n) {
    return it.type.compose(t, n);
  }
  static transform(t, n, r) {
    return it.type.transform(t, n, r);
  }
  // Use to transform cursor position, just call TextXPro.transformPosition.
  static transformPosition(t, n, r = "right") {
    return t && t.length === 2 && t[0] === "body" && t[1].et === Ne.name ? Ne.transformPosition(t[1].e, n, r === "left") : n;
  }
  static invertWithDoc(t, n) {
    return it.type.invertWithDoc(t, n);
  }
  static isNoop(t) {
    return it.type.isNoop(t);
  }
  static getInstance() {
    return this._instance == null && (this._instance = new Ln2()), this._instance;
  }
  // eslint-disable-next-line ts/no-explicit-any
  removeOp(t, n) {
    return it.removeOp(t, n);
  }
  moveOp(t, n) {
    return it.moveOp(t, n);
  }
  // eslint-disable-next-line ts/no-explicit-any
  insertOp(t, n) {
    return it.insertOp(t, n);
  }
  // eslint-disable-next-line ts/no-explicit-any
  replaceOp(t, n, r) {
    return it.replaceOp(t, n, r);
  }
  editOp(t, n = ["body"]) {
    return it.editOp(n, Ne.name, t);
  }
};
p(Ln, "uri", "https://github.com/dream-num/univer#json-x"), p(Ln, "_subTypes", /* @__PURE__ */ new Map()), p(Ln, "_instance", null);
var en = Ln;
en.registerSubtype(Ne);
var L0 = ((e) => (e.PARAGRAPH = "PARAGRAPH", e.SECTION_BREAK = "SECTION_BREAK", e.TABLE = "TABLE", e.TABLE_ROW = "TABLE_ROW", e.TABLE_CELL = "TABLE_CELL", e.CUSTOM_BLOCK = "CUSTOM_BLOCK", e))(L0 || {});
var ct = ((e) => (e.PARAGRAPH = "\r", e.SECTION_BREAK = `
`, e.TABLE_START = "", e.TABLE_ROW_START = "\x1B", e.TABLE_CELL_START = "", e.TABLE_CELL_END = "", e.TABLE_ROW_END = "", e.TABLE_END = "", e.CUSTOM_RANGE_START = "", e.CUSTOM_RANGE_END = "", e.COLUMN_BREAK = "\v", e.PAGE_BREAK = "\f", e.DOCS_END = "\0", e.TAB = "	", e.CUSTOM_BLOCK = "\b", e.LETTER = "", e.SPACE = " ", e))(ct || {});
function L1(e) {
  return `${e}`;
}
var D0 = [
  // DataStreamTreeTokenType.PARAGRAPH, // 
  // DataStreamTreeTokenType.SECTION_BREAK, // 
  ct.TABLE_START,
  // 
  ct.TABLE_ROW_START,
  // 
  ct.TABLE_CELL_START,
  // 
  ct.TABLE_CELL_END,
  // 
  ct.TABLE_ROW_END,
  // 
  ct.TABLE_END
  // 
  // DataStreamTreeTokenType.COLUMN_BREAK, // 
  // DataStreamTreeTokenType.PAGE_BREAK, // 
  // DataStreamTreeTokenType.DOCS_END, // 
  // DataStreamTreeTokenType.TAB, // 
  // DataStreamTreeTokenType.CUSTOM_BLOCK, //  mention 
];
var ea = (e) => {
  const t = e.endsWith(`\r
`) ? e.slice(0, -2) : e;
  return D0.reduce((n, r) => n.replaceAll(r, ""), t);
};
var U0 = (e) => e ? ea(e).replaceAll("\r", "") === "" : true;
var P0 = (e) => {
  const t = e.replace(/\n/g, "\r"), n = [], r = [];
  let s = 0, i = "";
  const o = (l, u = true) => {
    const c = t.slice(s, l);
    if (Z.isLegalUrl(c)) {
      const h = et(), d = `${c}`, f = {
        startIndex: s,
        endIndex: s + d.length - 1,
        rangeId: h,
        rangeType: En.HYPERLINK,
        properties: {
          url: e
        }
      };
      r.push(f), i += d, s = l + 1, u && (i += "\r", n.push({ startIndex: l }));
    } else
      i += t.slice(s, l + 1), s = l + 1, u && n.push({ startIndex: l });
  };
  let a = 0;
  for (let l = 0; l < t.length; l++)
    t[l] === "\r" && (o(l), a = l);
  return (a !== t.length - 1 || t.length === 1) && o(t.length, false), {
    dataStream: i,
    paragraphs: n,
    customRanges: r
  };
};
var rc = {
  id: "default_doc",
  documentStyle: {}
};
var k0 = class extends fo {
  constructor(n) {
    var r;
    super();
    p(this, "type", we.UNIVER_DOC);
    p(this, "_name$", new BehaviorSubject(""));
    p(this, "name$", this._name$.asObservable());
    p(this, "snapshot");
    this.snapshot = __spreadValues(__spreadValues({}, rc), n), this._name$.next((r = this.snapshot.title) != null ? r : "No Title");
  }
  getUnitId() {
    throw new Error("Method not implemented.");
  }
  getRev() {
    var n;
    return (n = this.snapshot.rev) != null ? n : 1;
  }
  incrementRev() {
    this.snapshot.rev = this.getRev() + 1;
  }
  setRev(n) {
    this.snapshot.rev = n;
  }
  setName(n) {
    this.snapshot.title = n, this._name$.next(n);
  }
  get drawings() {
    return this.snapshot.drawings;
  }
  get documentStyle() {
    return this.snapshot.documentStyle;
  }
  get lists() {
    return this.snapshot.lists;
  }
  get zoomRatio() {
    var n;
    return ((n = this.snapshot.settings) == null ? void 0 : n.zoomRatio) || 1;
  }
  resetDrawing(n, r) {
    this.snapshot.drawings = n, this.snapshot.drawingsOrder = r;
  }
  getBody() {
    return this.snapshot.body;
  }
  getSnapshot() {
    return this.snapshot;
  }
  getBulletPresetList() {
    var s;
    const n = (s = this.snapshot.lists) != null ? s : {};
    return __spreadValues(__spreadValues({}, Bs), n);
  }
  updateDocumentId(n) {
    this.snapshot.id = n;
  }
  updateDocumentRenderConfig(n) {
    const { documentStyle: r } = this.snapshot;
    r.renderConfig == null ? r.renderConfig = n : r.renderConfig = __spreadValues(__spreadValues({}, r.renderConfig), n);
  }
  getDocumentStyle() {
    return this.snapshot.documentStyle;
  }
  updateDocumentStyle(n) {
    this.snapshot.documentStyle == null ? this.snapshot.documentStyle = n : this.snapshot.documentStyle = __spreadValues(__spreadValues({}, this.snapshot.documentStyle), n);
  }
  updateDocumentDataMargin(n) {
    const { t: r, l: s, b: i, r: o } = n, { documentStyle: a } = this.snapshot;
    r != null && (a.marginTop = r), s != null && (a.marginLeft = s), i != null && (a.marginBottom = i), o != null && (a.marginRight = o);
  }
  updateDocumentDataPageSize(n, r) {
    const { documentStyle: s } = this.snapshot;
    if (!s.pageSize) {
      s.pageSize = {
        width: n != null ? n : Number.POSITIVE_INFINITY,
        height: r != null ? r : Number.POSITIVE_INFINITY
      };
      return;
    }
    n !== void 0 && (s.pageSize.width = n), r !== void 0 && (s.pageSize.height = r);
  }
  updateDrawing(n, r) {
    const { drawings: s } = this, { width: i, height: o, left: a, top: l } = r, u = s == null ? void 0 : s[n];
    if (!u)
      return;
    const c = u.docTransform;
    c.size.width = i, c.size.height = o, c.positionH.posOffset = a, c.positionV.posOffset = l;
  }
  setZoomRatio(n = 1) {
    this.snapshot.settings ? this.snapshot.settings.zoomRatio = n : this.snapshot.settings = {
      zoomRatio: n
    };
  }
  setDisabled(n) {
    this.snapshot.disabled = n;
  }
  getDisabled() {
    return this.snapshot.disabled;
  }
  getTitle() {
    return this.snapshot.title;
  }
};
var Ft = class _Ft extends k0 {
  constructor(n) {
    var s, i;
    super(Z.isEmptyObject(n) ? lg() : n);
    p(this, "_unitId");
    p(this, "headerModelMap", /* @__PURE__ */ new Map());
    p(this, "footerModelMap", /* @__PURE__ */ new Map());
    p(this, "change$", new BehaviorSubject(0));
    const r = 6;
    this._unitId = (s = this.snapshot.id) != null ? s : et(r), this._initializeHeaderFooterModel(), this._name$.next((i = this.snapshot.title) != null ? i : "");
  }
  dispose() {
    super.dispose(), this.headerModelMap.forEach((n) => {
      n.dispose();
    }), this.footerModelMap.forEach((n) => {
      n.dispose();
    }), this._name$.complete();
  }
  getDrawings() {
    return this.snapshot.drawings;
  }
  getDrawingsOrder() {
    return this.snapshot.drawingsOrder;
  }
  getCustomRanges() {
    var n;
    return (n = this.snapshot.body) == null ? void 0 : n.customRanges;
  }
  getCustomDecorations() {
    var n;
    return (n = this.snapshot.body) == null ? void 0 : n.customDecorations;
  }
  getSettings() {
    return this.snapshot.settings;
  }
  // TODO: @JOCS do not use reset, please use apply to modify the snapshot.
  reset(n) {
    if (n.id && n.id !== this._unitId)
      throw new Error("Cannot reset a document model with a different unit id!");
    this.snapshot = __spreadValues(__spreadValues({}, rc), n), this._initializeHeaderFooterModel(), this.change$.next(this.change$.value + 1);
  }
  getSelfOrHeaderFooterModel(n) {
    if (n != null) {
      if (this.headerModelMap.has(n))
        return this.headerModelMap.get(n);
      if (this.footerModelMap.has(n))
        return this.footerModelMap.get(n);
    }
    return this;
  }
  getUnitId() {
    return this._unitId;
  }
  apply(n) {
    if (!en.isNoop(n))
      return this.snapshot = en.apply(this.snapshot, n), n != null && n.some((r) => Array.isArray(r) && ((r == null ? void 0 : r[0]) === "headers" || (r == null ? void 0 : r[0]) === "footers")) && (this.headerModelMap.clear(), this.footerModelMap.clear(), this._initializeHeaderFooterModel()), this.change$.next(this.change$.value + 1), this.snapshot;
  }
  sliceBody(n, r, s = nc.copy) {
    const i = this.getBody();
    if (i != null)
      return kt(i, n, r, false, s);
  }
  _initializeHeaderFooterModel() {
    const { headers: n, footers: r } = this.getSnapshot();
    if (n)
      for (const s in n) {
        const i = n[s];
        this.headerModelMap.set(s, new _Ft(i)), this.headerModelMap.get(s).updateDocumentId(this.getUnitId());
      }
    if (r)
      for (const s in r) {
        const i = r[s];
        this.footerModelMap.set(s, new _Ft(i)), this.footerModelMap.get(s).updateDocumentId(this.getUnitId());
      }
  }
  updateDocumentId(n) {
    super.updateDocumentId(n), this._unitId = n;
  }
  getPlainText() {
    var n, r;
    return ea((r = (n = this.getBody()) == null ? void 0 : n.dataStream) != null ? r : "");
  }
};
function F0(e) {
  const { ranges: t, id: n, type: r } = e, s = new Ne();
  let i = 0;
  for (let o = 0; o < t.length; o++) {
    const a = t[o], { startOffset: l, endOffset: u } = a;
    l > 0 && s.push({
      t: J.RETAIN,
      len: l - i
    }), s.push({
      t: J.RETAIN,
      body: {
        dataStream: "",
        customDecorations: [{
          id: n,
          type: r,
          startIndex: 0,
          endIndex: u - l - 1
        }]
      },
      len: u - l
    }), i = u;
  }
  return s;
}
function H0(e) {
  var c, h, d;
  const { id: t, segmentId: n, documentDataModel: r } = e, s = r == null ? void 0 : r.getBody();
  if (!r || !s)
    return false;
  const i = (d = (h = (c = r.getSelfOrHeaderFooterModel(n)) == null ? void 0 : c.getBody()) == null ? void 0 : h.customDecorations) == null ? void 0 : d.find((f) => f.id === t);
  if (!i)
    return false;
  const o = new Ne(), { startIndex: a, endIndex: l } = i, u = l - a + 1;
  return o.push({
    t: J.RETAIN,
    len: a
  }), o.push({
    t: J.RETAIN,
    len: u,
    body: {
      dataStream: "",
      customDecorations: [
        {
          startIndex: 0,
          endIndex: u - 1,
          id: t,
          type: Un.DELETED
        }
      ]
    }
  }), o;
}
function sc(e, t, n, r) {
  return e <= n && t >= n || e >= n && e <= r;
}
function $0(e, t) {
  const n = [];
  for (let r = 0, s = t.length; r < s; r++) {
    const i = t[r];
    e.collapsed ? i.startIndex < e.startOffset && e.startOffset <= i.endIndex && n.push(i) : sc(e.startOffset, e.endOffset - 1, i.startIndex, i.endIndex) && n.push(i);
  }
  return n;
}
function B0(e) {
  return __spreadProps(__spreadValues({}, Z.deepClone(e)), {
    rangeId: et()
  });
}
function j0(e, t) {
  const n = [];
  let r = e[0];
  for (const s of t)
    s < e[0] || s > e[1] || (r < s && n.push([r, s - 1]), r = s + 1);
  return r <= e[1] && n.push([r, e[1]]), n;
}
function ic(e, t, n, r) {
  const s = [];
  for (let i = 0, o = n.length; i < o; i++) {
    const a = n[i];
    if ((r === void 0 || a.rangeType === r) && Math.max(a.startIndex, e) <= Math.min(a.endIndex, t) && s.push(__spreadValues({}, a)), a.startIndex > t)
      break;
  }
  return s;
}
function W0(e, t) {
  var i, o, a, l, u;
  const n = ic(e.startOffset, e.collapsed ? e.startOffset : e.endOffset - 1, (i = t.customRanges) != null ? i : []), r = Math.min(e.startOffset, (a = (o = n[0]) == null ? void 0 : o.startIndex) != null ? a : 1 / 0), s = Math.max(e.endOffset, ((u = (l = n[n.length - 1]) == null ? void 0 : l.endIndex) != null ? u : -1 / 0) + 1);
  return {
    startOffset: r,
    endOffset: s,
    collapsed: r === s
  };
}
var mi;
var Cl;
function Y0() {
  if (Cl) return mi;
  Cl = 1;
  var e = -1, t = 1, n = 0;
  function r(m, D, S, T, A) {
    if (m === D)
      return m ? [[n, m]] : [];
    if (S != null) {
      var O = F2(m, D, S);
      if (O)
        return O;
    }
    var N = a(m, D), M = m.substring(0, N);
    m = m.substring(N), D = D.substring(N), N = u(m, D);
    var x = m.substring(m.length - N);
    m = m.substring(0, m.length - N), D = D.substring(0, D.length - N);
    var P = s(m, D);
    return M && P.unshift([n, M]), x && P.push([n, x]), $(P, A), T && h(P), P;
  }
  function s(m, D) {
    var S;
    if (!m)
      return [[t, D]];
    if (!D)
      return [[e, m]];
    var T = m.length > D.length ? m : D, A = m.length > D.length ? D : m, O = T.indexOf(A);
    if (O !== -1)
      return S = [
        [t, T.substring(0, O)],
        [n, A],
        [t, T.substring(O + A.length)]
      ], m.length > D.length && (S[0][0] = S[2][0] = e), S;
    if (A.length === 1)
      return [
        [e, m],
        [t, D]
      ];
    var N = c(m, D);
    if (N) {
      var M = N[0], x = N[1], P = N[2], q = N[3], V = N[4], oe = r(M, P), le = r(x, q);
      return oe.concat([[n, V]], le);
    }
    return i(m, D);
  }
  function i(m, D) {
    for (var S = m.length, T = D.length, A = Math.ceil((S + T) / 2), O = A, N = 2 * A, M = new Array(N), x = new Array(N), P = 0; P < N; P++)
      M[P] = -1, x[P] = -1;
    M[O + 1] = 0, x[O + 1] = 0;
    for (var q = S - T, V = q % 2 !== 0, oe = 0, le = 0, I = 0, L = 0, Y = 0; Y < A; Y++) {
      for (var z = -Y + oe; z <= Y - le; z += 2) {
        var B = O + z, j;
        z === -Y || z !== Y && M[B - 1] < M[B + 1] ? j = M[B + 1] : j = M[B - 1] + 1;
        for (var Q = j - z; j < S && Q < T && m.charAt(j) === D.charAt(Q); )
          j++, Q++;
        if (M[B] = j, j > S)
          le += 2;
        else if (Q > T)
          oe += 2;
        else if (V) {
          var ee = O + q - z;
          if (ee >= 0 && ee < N && x[ee] !== -1) {
            var U = S - x[ee];
            if (j >= U)
              return o(m, D, j, Q);
          }
        }
      }
      for (var G = -Y + I; G <= Y - L; G += 2) {
        var ee = O + G, U;
        G === -Y || G !== Y && x[ee - 1] < x[ee + 1] ? U = x[ee + 1] : U = x[ee - 1] + 1;
        for (var X = U - G; U < S && X < T && m.charAt(S - U - 1) === D.charAt(T - X - 1); )
          U++, X++;
        if (x[ee] = U, U > S)
          L += 2;
        else if (X > T)
          I += 2;
        else if (!V) {
          var B = O + q - G;
          if (B >= 0 && B < N && M[B] !== -1) {
            var j = M[B], Q = O + j - B;
            if (U = S - U, j >= U)
              return o(m, D, j, Q);
          }
        }
      }
    }
    return [
      [e, m],
      [t, D]
    ];
  }
  function o(m, D, S, T) {
    var A = m.substring(0, S), O = D.substring(0, T), N = m.substring(S), M = D.substring(T), x = r(A, O), P = r(N, M);
    return x.concat(P);
  }
  function a(m, D) {
    if (!m || !D || m.charAt(0) !== D.charAt(0))
      return 0;
    for (var S = 0, T = Math.min(m.length, D.length), A = T, O = 0; S < A; )
      m.substring(O, A) == D.substring(O, A) ? (S = A, O = S) : T = A, A = Math.floor((T - S) / 2 + S);
    return k(m.charCodeAt(A - 1)) && A--, A;
  }
  function l(m, D) {
    var S = m.length, T = D.length;
    if (S == 0 || T == 0)
      return 0;
    S > T ? m = m.substring(S - T) : S < T && (D = D.substring(0, S));
    var A = Math.min(S, T);
    if (m == D)
      return A;
    for (var O = 0, N = 1; ; ) {
      var M = m.substring(A - N), x = D.indexOf(M);
      if (x == -1)
        return O;
      N += x, (x == 0 || m.substring(A - N) == D.substring(0, N)) && (O = N, N++);
    }
  }
  function u(m, D) {
    if (!m || !D || m.slice(-1) !== D.slice(-1))
      return 0;
    for (var S = 0, T = Math.min(m.length, D.length), A = T, O = 0; S < A; )
      m.substring(m.length - A, m.length - O) == D.substring(D.length - A, D.length - O) ? (S = A, O = S) : T = A, A = Math.floor((T - S) / 2 + S);
    return W(m.charCodeAt(m.length - A)) && A--, A;
  }
  function c(m, D) {
    var S = m.length > D.length ? m : D, T = m.length > D.length ? D : m;
    if (S.length < 4 || T.length * 2 < S.length)
      return null;
    function A(le, I, L) {
      for (var Y = le.substring(L, L + Math.floor(le.length / 4)), z = -1, B = "", j, Q, ee, U; (z = I.indexOf(Y, z + 1)) !== -1; ) {
        var G = a(
          le.substring(L),
          I.substring(z)
        ), X = u(
          le.substring(0, L),
          I.substring(0, z)
        );
        B.length < X + G && (B = I.substring(z - X, z) + I.substring(z, z + G), j = le.substring(0, L - X), Q = le.substring(L + G), ee = I.substring(0, z - X), U = I.substring(z + G));
      }
      return B.length * 2 >= le.length ? [
        j,
        Q,
        ee,
        U,
        B
      ] : null;
    }
    var O = A(
      S,
      T,
      Math.ceil(S.length / 4)
    ), N = A(
      S,
      T,
      Math.ceil(S.length / 2)
    ), M;
    if (!O && !N)
      return null;
    N ? O ? M = O[4].length > N[4].length ? O : N : M = N : M = O;
    var x, P, q, V;
    m.length > D.length ? (x = M[0], P = M[1], q = M[2], V = M[3]) : (q = M[0], V = M[1], x = M[2], P = M[3]);
    var oe = M[4];
    return [x, P, q, V, oe];
  }
  function h(m) {
    for (var D = false, S = [], T = 0, A = null, O = 0, N = 0, M = 0, x = 0, P = 0; O < m.length; )
      m[O][0] == n ? (S[T++] = O, N = x, M = P, x = 0, P = 0, A = m[O][1]) : (m[O][0] == t ? x += m[O][1].length : P += m[O][1].length, A && A.length <= Math.max(N, M) && A.length <= Math.max(x, P) && (m.splice(S[T - 1], 0, [
        e,
        A
      ]), m[S[T - 1] + 1][0] = t, T--, T--, O = T > 0 ? S[T - 1] : -1, N = 0, M = 0, x = 0, P = 0, A = null, D = true)), O++;
    for (D && $(m), b(m), O = 1; O < m.length; ) {
      if (m[O - 1][0] == e && m[O][0] == t) {
        var q = m[O - 1][1], V = m[O][1], oe = l(q, V), le = l(V, q);
        oe >= le ? (oe >= q.length / 2 || oe >= V.length / 2) && (m.splice(O, 0, [
          n,
          V.substring(0, oe)
        ]), m[O - 1][1] = q.substring(
          0,
          q.length - oe
        ), m[O + 1][1] = V.substring(oe), O++) : (le >= q.length / 2 || le >= V.length / 2) && (m.splice(O, 0, [
          n,
          q.substring(0, le)
        ]), m[O - 1][0] = t, m[O - 1][1] = V.substring(
          0,
          V.length - le
        ), m[O + 1][0] = e, m[O + 1][1] = q.substring(le), O++), O++;
      }
      O++;
    }
  }
  var d = /[^a-zA-Z0-9]/, f = /\s/, g = /[\r\n]/, _ = /\n\r?\n$/, R = /^\r?\n\r?\n/;
  function b(m) {
    function D(le, I) {
      if (!le || !I)
        return 6;
      var L = le.charAt(le.length - 1), Y = I.charAt(0), z = L.match(d), B = Y.match(d), j = z && L.match(f), Q = B && Y.match(f), ee = j && L.match(g), U = Q && Y.match(g), G = ee && le.match(_), X = U && I.match(R);
      return G || X ? 5 : ee || U ? 4 : z && !j && Q ? 3 : j || Q ? 2 : z || B ? 1 : 0;
    }
    for (var S = 1; S < m.length - 1; ) {
      if (m[S - 1][0] == n && m[S + 1][0] == n) {
        var T = m[S - 1][1], A = m[S][1], O = m[S + 1][1], N = u(T, A);
        if (N) {
          var M = A.substring(A.length - N);
          T = T.substring(0, T.length - N), A = M + A.substring(0, A.length - N), O = M + O;
        }
        for (var x = T, P = A, q = O, V = D(T, A) + D(A, O); A.charAt(0) === O.charAt(0); ) {
          T += A.charAt(0), A = A.substring(1) + O.charAt(0), O = O.substring(1);
          var oe = D(T, A) + D(A, O);
          oe >= V && (V = oe, x = T, P = A, q = O);
        }
        m[S - 1][1] != x && (x ? m[S - 1][1] = x : (m.splice(S - 1, 1), S--), m[S][1] = P, q ? m[S + 1][1] = q : (m.splice(S + 1, 1), S--));
      }
      S++;
    }
  }
  function $(m, D) {
    m.push([n, ""]);
    for (var S = 0, T = 0, A = 0, O = "", N = "", M; S < m.length; ) {
      if (S < m.length - 1 && !m[S][1]) {
        m.splice(S, 1);
        continue;
      }
      switch (m[S][0]) {
        case t:
          A++, N += m[S][1], S++;
          break;
        case e:
          T++, O += m[S][1], S++;
          break;
        case n:
          var x = S - A - T - 1;
          if (D) {
            if (x >= 0 && C(m[x][1])) {
              var P = m[x][1].slice(-1);
              if (m[x][1] = m[x][1].slice(
                0,
                -1
              ), O = P + O, N = P + N, !m[x][1]) {
                m.splice(x, 1), S--;
                var q = x - 1;
                m[q] && m[q][0] === t && (A++, N = m[q][1] + N, q--), m[q] && m[q][0] === e && (T++, O = m[q][1] + O, q--), x = q;
              }
            }
            if (w(m[S][1])) {
              var P = m[S][1].charAt(0);
              m[S][1] = m[S][1].slice(1), O += P, N += P;
            }
          }
          if (S < m.length - 1 && !m[S][1]) {
            m.splice(S, 1);
            break;
          }
          if (O.length > 0 || N.length > 0) {
            O.length > 0 && N.length > 0 && (M = a(N, O), M !== 0 && (x >= 0 ? m[x][1] += N.substring(
              0,
              M
            ) : (m.splice(0, 0, [
              n,
              N.substring(0, M)
            ]), S++), N = N.substring(M), O = O.substring(M)), M = u(N, O), M !== 0 && (m[S][1] = N.substring(N.length - M) + m[S][1], N = N.substring(
              0,
              N.length - M
            ), O = O.substring(
              0,
              O.length - M
            )));
            var V = A + T;
            O.length === 0 && N.length === 0 ? (m.splice(S - V, V), S = S - V) : O.length === 0 ? (m.splice(S - V, V, [t, N]), S = S - V + 1) : N.length === 0 ? (m.splice(S - V, V, [e, O]), S = S - V + 1) : (m.splice(
              S - V,
              V,
              [e, O],
              [t, N]
            ), S = S - V + 2);
          }
          S !== 0 && m[S - 1][0] === n ? (m[S - 1][1] += m[S][1], m.splice(S, 1)) : S++, A = 0, T = 0, O = "", N = "";
          break;
      }
    }
    m[m.length - 1][1] === "" && m.pop();
    var oe = false;
    for (S = 1; S < m.length - 1; )
      m[S - 1][0] === n && m[S + 1][0] === n && (m[S][1].substring(
        m[S][1].length - m[S - 1][1].length
      ) === m[S - 1][1] ? (m[S][1] = m[S - 1][1] + m[S][1].substring(
        0,
        m[S][1].length - m[S - 1][1].length
      ), m[S + 1][1] = m[S - 1][1] + m[S + 1][1], m.splice(S - 1, 1), oe = true) : m[S][1].substring(0, m[S + 1][1].length) == m[S + 1][1] && (m[S - 1][1] += m[S + 1][1], m[S][1] = m[S][1].substring(m[S + 1][1].length) + m[S + 1][1], m.splice(S + 1, 1), oe = true)), S++;
    oe && $(m, D);
  }
  function k(m) {
    return m >= 55296 && m <= 56319;
  }
  function W(m) {
    return m >= 56320 && m <= 57343;
  }
  function w(m) {
    return W(m.charCodeAt(0));
  }
  function C(m) {
    return k(m.charCodeAt(m.length - 1));
  }
  function v(m) {
    for (var D = [], S = 0; S < m.length; S++)
      m[S][1].length > 0 && D.push(m[S]);
    return D;
  }
  function y(m, D, S, T) {
    return C(m) || w(T) ? null : v([
      [n, m],
      [e, D],
      [t, S],
      [n, T]
    ]);
  }
  function F2(m, D, S) {
    var T = typeof S == "number" ? { index: S, length: 0 } : S.oldRange, A = typeof S == "number" ? null : S.newRange, O = m.length, N = D.length;
    if (T.length === 0 && (A === null || A.length === 0)) {
      var M = T.index, x = m.slice(0, M), P = m.slice(M), q = A ? A.index : null;
      e: {
        var V = M + N - O;
        if (q !== null && q !== V || V < 0 || V > N)
          break e;
        var oe = D.slice(0, V), le = D.slice(V);
        if (le !== P)
          break e;
        var I = Math.min(M, V), L = x.slice(0, I), Y = oe.slice(0, I);
        if (L !== Y)
          break e;
        var z = x.slice(I), B = oe.slice(I);
        return y(L, z, B, P);
      }
      e: {
        if (q !== null && q !== M)
          break e;
        var j = M, oe = D.slice(0, j), le = D.slice(j);
        if (oe !== x)
          break e;
        var Q = Math.min(O - j, N - j), ee = P.slice(P.length - Q), U = le.slice(le.length - Q);
        if (ee !== U)
          break e;
        var z = P.slice(0, P.length - Q), B = le.slice(0, le.length - Q);
        return y(x, z, B, ee);
      }
    }
    if (T.length > 0 && A && A.length === 0)
      e: {
        var L = m.slice(0, T.index), ee = m.slice(T.index + T.length), I = L.length, Q = ee.length;
        if (N < I + Q)
          break e;
        var Y = D.slice(0, I), U = D.slice(N - Q);
        if (L !== Y || ee !== U)
          break e;
        var z = m.slice(I, O - Q), B = D.slice(I, N - Q);
        return y(L, z, B, ee);
      }
    return null;
  }
  function H(m, D, S, T) {
    return r(m, D, S, T, true);
  }
  return H.INSERT = t, H.DELETE = e, H.EQUAL = n, mi = H, mi;
}
var z0 = Y0();
var oc = It(z0);
function V0(e) {
  var h, d, f;
  const { rangeId: t, segmentId: n, documentDataModel: r, insert: s } = e, i = (d = (h = r.getSelfOrHeaderFooterModel(n).getBody()) == null ? void 0 : h.customRanges) == null ? void 0 : d.find((g) => g.rangeId === t);
  if (!i)
    return false;
  const { startIndex: o, endIndex: a } = i, l = new Ne(), u = a - o + 1;
  l.push({
    t: J.RETAIN,
    len: o
  }), l.push({
    t: J.RETAIN,
    len: u,
    body: {
      dataStream: "",
      customRanges: []
    }
  }), s && l.push({
    t: J.INSERT,
    body: s,
    len: s.dataStream.length
  });
  const c = a + 1 + ((f = s == null ? void 0 : s.dataStream.length) != null ? f : 0);
  return l.selections = [{
    startOffset: c,
    endOffset: c,
    collapsed: true
  }], l;
}
function G0(e) {
  const { ranges: t, rangeId: n, rangeType: r, wholeEntity: s, properties: i, body: o } = e;
  let a = 0;
  const l = new Ne();
  let u = false;
  return t.forEach((c) => {
    var k, W, w;
    const h = W0(c, o);
    if (!h || !o)
      return false;
    const { startOffset: d, endOffset: f } = h, g = (k = o.customRanges) != null ? k : [], _ = (C, v, y) => {
      var S, T, A, O;
      const F2 = ic(C, v, g, r), H = Math.min((T = (S = F2[0]) == null ? void 0 : S.startIndex) != null ? T : 1 / 0, C), m = Math.max((O = (A = F2[F2.length - 1]) == null ? void 0 : A.endIndex) != null ? O : -1 / 0, v), D = {
        rangeId: y ? `${n}$${y}` : n,
        rangeType: r,
        startIndex: 0,
        endIndex: m - H,
        wholeEntity: s,
        properties: __spreadValues({}, i)
      };
      l.push({
        t: J.RETAIN,
        len: H - a
      }), l.push({
        t: J.RETAIN,
        len: m - H + 1,
        body: {
          dataStream: "",
          customRanges: [D]
        },
        coverType: pe.COVER
      }), a = m + 1;
    }, R = ((W = o.paragraphs) != null ? W : []).filter((C) => C.startIndex < f && C.startIndex > d), b = ((w = o.customBlocks) != null ? w : []).filter((C) => C.startIndex < f && C.startIndex > d);
    j0([d, f - 1], [...R.map((C) => C.startIndex), ...b.map((C) => C.startIndex)]).forEach(([C, v], y) => _(C, v, y)), u = true, l.selections = [{
      startOffset: h.endOffset,
      endOffset: h.endOffset,
      collapsed: true
    }];
  }), u ? l : false;
}
function ac(e, t, n = 0, r = null, s = true) {
  e.sort((u, c) => u.startOffset - c.startOffset);
  const i = [], { paragraphs: o = [] } = t, a = o == null ? void 0 : o.find(
    (u) => u.startIndex >= e[0].startOffset && u.startIndex < e[0].endOffset
  );
  let l = n;
  if (e.forEach((u) => {
    const { startOffset: c, endOffset: h } = u;
    c > l && (i.push({
      t: J.RETAIN,
      len: c - l
    }), l = c), l < h && (i.push({
      t: J.DELETE,
      len: h - l
    }), l = h);
  }), r && i.push({
    t: J.INSERT,
    body: r,
    len: r.dataStream.length
  }), a && s) {
    const u = o.find((c) => c.startIndex - n >= e[e.length - 1].endOffset - 1);
    u && (u.startIndex > l && (i.push({
      t: J.RETAIN,
      len: u.startIndex - l
    }), l = u.startIndex), i.push({
      t: J.RETAIN,
      len: 1,
      body: {
        dataStream: "",
        paragraphs: [
          __spreadProps(__spreadValues({}, u), {
            startIndex: 0,
            bullet: a == null ? void 0 : a.bullet
          })
        ]
      },
      coverType: pe.REPLACE
    }));
  }
  return i;
}
function K0(e, t, n = 0) {
  const r = [];
  let s = n;
  return e.forEach((i) => {
    const { startOffset: o, endOffset: a } = i;
    o > s && (r.push({
      t: J.RETAIN,
      len: o - s
    }), s = o), a > s && (r.push({
      t: J.RETAIN,
      len: a - s,
      body: __spreadProps(__spreadValues({}, Z.deepClone(t)), {
        dataStream: ""
      })
    }), s = a);
  }), r;
}
var X0 = (e) => {
  var h;
  const { selection: t, body: n, doc: r } = e, s = t.segmentId, i = (h = r.getSelfOrHeaderFooterModel(s)) == null ? void 0 : h.getBody();
  if (!i) return false;
  const o = t.collapsed ? null : kt(i, t.startOffset, t.endOffset), a = oc(o ? o.dataStream : "", n.dataStream);
  let l = 0;
  const u = a.map(([d, f]) => {
    switch (d) {
      case 0: {
        const g = {
          t: J.RETAIN,
          body: __spreadProps(__spreadValues({}, kt(n, l, l + f.length, false)), {
            dataStream: ""
          }),
          len: f.length
        };
        return l += f.length, g;
      }
      case 1: {
        const g = {
          t: J.INSERT,
          body: kt(n, l, l + f.length),
          len: f.length
        };
        return l += f.length, g;
      }
      default:
        return {
          t: J.DELETE,
          len: f.length
        };
    }
  }), c = new Ne();
  return c.push({
    t: J.RETAIN,
    len: t.startOffset
  }), c.push(...u), c;
};
function q0(e, t) {
  return !!((e == null ? void 0 : e.length) === (t == null ? void 0 : t.length) && (e != null && e.every((n, r) => JSON.stringify(n) === JSON.stringify(t == null ? void 0 : t[r]))));
}
var J0 = (e) => {
  var d;
  const { selection: t, body: n, doc: r, themeService: s } = e, i = t.segmentId, o = (d = r.getSelfOrHeaderFooterModel(i)) == null ? void 0 : d.getBody();
  if (!o) return false;
  const a = t.collapsed ? null : kt(o, t.startOffset, t.endOffset), l = oc(a ? a.dataStream : "", n.dataStream);
  let u = 0;
  const c = l.map(([f, g]) => {
    switch (f) {
      case 0: {
        const _ = Bi(n, u, u + g.length, false), R = Bi(a, u, u + g.length, false), b = {
          t: J.RETAIN,
          body: q0(_, R) ? void 0 : {
            textRuns: _ == null ? void 0 : _.map(($) => {
              var k, W, w, C, v, y, F2;
              return __spreadProps(__spreadValues({}, $), {
                ts: __spreadProps(__spreadValues({}, $.ts), {
                  cl: (w = (W = (k = $.ts) == null ? void 0 : k.cl) == null ? void 0 : W.rgb) != null && w.includes(".") ? { rgb: s.getColorFromTheme((y = (v = (C = $.ts) == null ? void 0 : C.cl) == null ? void 0 : v.rgb) != null ? y : "") } : (F2 = $.ts) == null ? void 0 : F2.cl
                })
              });
            }),
            dataStream: ""
          },
          len: g.length
        };
        return u += g.length, b;
      }
      case 1: {
        const _ = {
          t: J.INSERT,
          body: kt(n, u, u + g.length),
          len: g.length
        };
        return u += g.length, _;
      }
      default:
        return {
          t: J.DELETE,
          len: g.length
        };
    }
  });
  if (c.every((f) => f.t === J.RETAIN && !f.body))
    return false;
  const h = new Ne();
  return h.push({
    t: J.RETAIN,
    len: t.startOffset
  }), h.push(...c), h;
};
function Z0(e, t) {
  const n = [], { customBlocks: r = [] } = e;
  for (const s of t) {
    const { startOffset: i, endOffset: o } = s;
    if (!(i == null || o == null))
      for (const a of r) {
        const { startIndex: l } = a;
        l >= i && l < o && n.push(a.blockId);
      }
  }
  return n;
}
function Q0(e, t = "") {
  if (!t)
    return ["body"];
  const { headers: n, footers: r } = e.getSnapshot();
  if (n == null && r == null)
    throw new Error("Document data model must have headers or footers when update by segment id");
  if ((n == null ? void 0 : n[t]) != null)
    return ["headers", t, "body"];
  if ((r == null ? void 0 : r[t]) != null)
    return ["footers", t, "body"];
  throw new Error("Segment id not found in headers or footers");
}
var eE = (e) => {
  var _, R, b, $;
  const { selection: t, documentDataModel: n, drawings: r } = e, { collapsed: s, startOffset: i, segmentId: o } = t, a = new Ne(), l = en.getInstance(), u = [], c = n.getSelfOrHeaderFooterModel(o).getBody();
  if (!c)
    return false;
  const h = (R = (_ = n.getSnapshot().drawingsOrder) == null ? void 0 : _.length) != null ? R : 0;
  let d = 0;
  if (s)
    i > 0 && a.push({
      t: J.RETAIN,
      len: i
    });
  else {
    const k = ac([t], c, 0, null, false);
    a.push(...k);
    const W = Z0(c, [t]), w = (b = n.getDrawings()) != null ? b : {}, C = ($ = n.getDrawingsOrder()) != null ? $ : [], v = W.sort((y, F2) => C.indexOf(y) > C.indexOf(F2) ? -1 : C.indexOf(y) < C.indexOf(F2) ? 1 : 0);
    if (v.length > 0)
      for (const y of v) {
        const F2 = w[y], H = C.indexOf(y);
        if (F2 == null || H < 0)
          continue;
        const m = l.removeOp(["drawings", y], F2), D = l.removeOp(["drawingsOrder", H], y);
        u.push(m), u.push(D), d++;
      }
  }
  a.push({
    t: J.INSERT,
    body: {
      dataStream: "\b".repeat(r.length),
      customBlocks: r.map((k, W) => ({
        startIndex: W,
        blockId: k.drawingId
      }))
    },
    len: r.length
  });
  const f = Q0(n, o), g = l.editOp(a.serialize(), f);
  u.push(g);
  for (const k of r) {
    const { drawingId: W } = k, w = l.insertOp(["drawings", W], k), C = l.insertOp(["drawingsOrder", h - d], W);
    u.push(w), u.push(C);
  }
  return u.reduce((k, W) => en.compose(k, W), null);
};
function tE(e, t) {
  if (typeof t > "u")
    return { startOffset: e, endOffset: e, collapsed: true };
  if (t < e)
    throw new Error(`Cannot make a doc selection when endOffset ${t} is less than startOffset ${e}.`);
  return { startOffset: e, endOffset: t, collapsed: e === t };
}
function nE(e) {
  const { startOffset: t, endOffset: n, collapsed: r } = e, s = Math.min(t, n), i = Math.max(t, n);
  return {
    startOffset: s,
    endOffset: i,
    collapsed: r
  };
}
function rE(e, t, n, r) {
  return Math.max(e, n) <= Math.min(t, r);
}
function ji(e, t, n, r) {
  const { startOffset: s, endOffset: i } = e, o = r != null ? r : ta(t, n), a = [];
  let l = -1;
  for (let u = 0; u < o.length; u++) {
    const c = o[u], { startIndex: h } = c;
    (s > l && s <= h || i > l && i <= h || h >= s && h <= i) && a.push(c), l = h;
  }
  return a;
}
function Wi(e, t, n) {
  const r = [], s = ta(t, n);
  for (const i of e) {
    const o = ji(i, t, n, s);
    r.push(...o);
  }
  return r;
}
var sE = [
  ct.PARAGRAPH,
  ct.TABLE_START,
  ct.TABLE_END,
  ct.TABLE_ROW_START,
  ct.TABLE_CELL_START,
  ct.TABLE_CELL_END
];
function ta(e, t) {
  const n = [];
  for (let r = 0; r < e.length; r++) {
    const s = e[r], { startIndex: i } = s;
    let o = i - 1;
    for (; !sE.includes(t[o]) && o >= 0; )
      o--;
    n.push(__spreadProps(__spreadValues({}, s), {
      paragraphStart: o + 1,
      paragraphEnd: s.startIndex
    }));
  }
  return n;
}
var iE = (e) => {
  var h, d, f;
  const { paragraphs: t, segmentId: n, document: r } = e;
  let s = e.listType;
  const i = (d = (h = r.getSelfOrHeaderFooterModel(n).getBody()) == null ? void 0 : h.paragraphs) != null ? d : [], o = t.every((g) => {
    var _;
    return ((_ = g.bullet) == null ? void 0 : _.listType.indexOf(s)) === 0;
  });
  let l = et(6);
  if (t.length === 1) {
    const g = i.indexOf(t[0]), _ = i[g - 1], R = i[g + 1];
    _ && _.bullet && _.bullet.listType.indexOf(s) === 0 ? (l = _.bullet.listId, s !== Vt.CHECK_LIST && (s = _.bullet.listType)) : R && R.bullet && R.bullet.listType.indexOf(s) === 0 && (l = R.bullet.listId, s !== Vt.CHECK_LIST && (s = R.bullet.listType));
  }
  const u = new Kn();
  u.reset();
  const c = new Ne();
  for (const g of t) {
    const { startIndex: _, paragraphStyle: R = {}, bullet: b } = g;
    c.push({
      t: J.RETAIN,
      len: _ - u.cursor
    }), c.push({
      t: J.RETAIN,
      len: 1,
      body: {
        dataStream: "",
        paragraphs: [
          o ? {
            paragraphStyle: R,
            startIndex: 0
          } : {
            startIndex: 0,
            paragraphStyle: __spreadValues({}, R),
            bullet: {
              nestingLevel: (f = b == null ? void 0 : b.nestingLevel) != null ? f : 0,
              textStyle: {
                fs: 20
              },
              listType: s,
              listId: l
            }
          }
        ]
      },
      coverType: pe.REPLACE
    }), u.moveCursorTo(_ + 1);
  }
  return c;
};
var oE = (e) => {
  var h;
  const { paragraphIndex: t, segmentId: n, document: r } = e, s = (h = r.getSelfOrHeaderFooterModel(n).getBody()) == null ? void 0 : h.paragraphs;
  if (s == null)
    return false;
  const i = s.find((d) => d.startIndex === t);
  if (!(i != null && i.bullet) || i.bullet.listType.indexOf(Vt.CHECK_LIST) === -1)
    return false;
  const o = new Kn();
  o.reset();
  const a = new Ne(), { startIndex: l, paragraphStyle: u = {} } = i, c = i.bullet.listType === Vt.CHECK_LIST ? Vt.CHECK_LIST_CHECKED : Vt.CHECK_LIST;
  return a.push({
    t: J.RETAIN,
    len: l - o.cursor
  }), a.push({
    t: J.RETAIN,
    len: 1,
    body: {
      dataStream: "",
      paragraphs: [
        __spreadProps(__spreadValues({}, i), {
          paragraphStyle: u,
          startIndex: 0,
          bullet: __spreadProps(__spreadValues({}, i.bullet), {
            listType: c
          })
        })
      ]
    },
    coverType: pe.REPLACE
  }), o.moveCursorTo(l + 1), a;
};
var aE = (e) => {
  var c, h;
  const { paragraphs: t, listType: n, segmentId: r, document: s } = e;
  if (((c = s.getSelfOrHeaderFooterModel(r).getBody()) == null ? void 0 : c.paragraphs) == null)
    return false;
  const a = et(6), l = new Kn();
  l.reset();
  const u = new Ne();
  for (const d of t) {
    const { startIndex: f, paragraphStyle: g = {}, bullet: _ } = d;
    u.push({
      t: J.RETAIN,
      len: f - l.cursor
    }), u.push({
      t: J.RETAIN,
      len: 1,
      body: {
        dataStream: "",
        paragraphs: [
          {
            startIndex: 0,
            paragraphStyle: g,
            bullet: {
              nestingLevel: (h = _ == null ? void 0 : _.nestingLevel) != null ? h : 0,
              textStyle: (_ == null ? void 0 : _.listType) === n ? _.textStyle : {
                fs: 20
              },
              listType: n,
              listId: a
            }
          }
        ]
      },
      coverType: pe.REPLACE
    }), l.moveCursorTo(f + 1);
  }
  return u;
};
function lE(e, t) {
  return t.some((n) => e.startIndex > n.startIndex && e.startIndex < n.endIndex);
}
var uE = (e) => {
  var u, c, h;
  const { paragraphs: t, document: n, type: r } = e, s = new Kn();
  s.reset();
  const i = new Ne(), o = (u = n.getSnapshot().lists) != null ? u : {}, a = (h = (c = n.getBody()) == null ? void 0 : c.tables) != null ? h : [], l = __spreadValues(__spreadValues({}, Bs), o);
  for (const d of t) {
    const { startIndex: f, paragraphStyle: g = {}, bullet: _ } = d, R = lE(d, a);
    if (i.push({
      t: J.RETAIN,
      len: f - s.cursor
    }), _) {
      const b = _.listType;
      let $ = l[b].nestingLevel.length - 1;
      R && ($ = Math.min($, 2)), i.push({
        t: J.RETAIN,
        len: 1,
        body: {
          dataStream: "",
          paragraphs: [
            {
              startIndex: 0,
              paragraphStyle: __spreadValues({}, g),
              bullet: __spreadProps(__spreadValues({}, _), {
                nestingLevel: Math.max(Math.min(_.nestingLevel + r, $), 0)
              })
            }
          ]
        },
        coverType: pe.REPLACE
      });
    } else
      i.push({
        t: J.RETAIN,
        len: 1
      });
    s.moveCursorTo(f + 1);
  }
  return i;
};
var cE = (e) => {
  var R, b, $, k;
  const {
    textRanges: t,
    segmentId: n,
    document: r,
    style: s,
    paragraphTextRun: i,
    cursor: o,
    deleteLen: a,
    textX: l
  } = e, u = r.getSelfOrHeaderFooterModel(n), c = (b = (R = u.getBody()) == null ? void 0 : R.paragraphs) != null ? b : [], h = (k = ($ = u.getBody()) == null ? void 0 : $.dataStream) != null ? k : "", d = Wi(t, c, h), f = new Kn();
  o && f.moveCursorTo(o);
  const g = l != null ? l : new Ne();
  d.sort((W, w) => W.startIndex - w.startIndex);
  const _ = Math.max(0, d[0].paragraphStart - 1);
  _ > f.cursor && (g.push({
    t: J.RETAIN,
    len: _ - f.cursor
  }), f.moveCursorTo(_)), a && g.push({
    t: J.DELETE,
    len: a
  });
  for (const W of d) {
    const { startIndex: w, paragraphStyle: C = {} } = W, v = w - f.cursor;
    g.push(__spreadValues({
      t: J.RETAIN,
      len: v
    }, i ? {
      body: {
        dataStream: "",
        textRuns: [{
          ts: i,
          st: 0,
          ed: v
        }]
      },
      coverType: pe.REPLACE
    } : null)), g.push({
      t: J.RETAIN,
      len: 1,
      body: {
        dataStream: "",
        paragraphs: [
          {
            startIndex: 0,
            paragraphStyle: __spreadValues(__spreadValues({}, C), s)
          }
        ]
      },
      coverType: pe.REPLACE
    }), f.moveCursorTo(w + 1);
  }
  return g;
};
var Ze = class {
};
p(Ze, "customRange", {
  add: G0,
  delete: V0,
  copyCustomRange: B0,
  getCustomRangesInterestsWithSelection: $0,
  isIntersecting: sc
}), p(Ze, "customDecoration", {
  add: F0,
  delete: H0
}), p(Ze, "selection", {
  replace: X0,
  makeSelection: tE,
  normalizeSelection: nE,
  delete: ac,
  replaceTextRuns: J0,
  retain: K0
}), p(Ze, "range", {
  isIntersects: rE,
  getParagraphsInRange: ji,
  getParagraphsInRanges: Wi
}), p(Ze, "transform", {
  getPlainText: ea,
  fromPlainText: P0,
  isEmptyDocument: U0
}), p(Ze, "paragraph", {
  bullet: {
    set: aE,
    switch: iE,
    toggleChecklist: oE,
    changeNestLevel: uE
  },
  style: {
    set: cE
  },
  util: {
    transform: ta,
    getParagraphsInRange: ji,
    getParagraphsInRanges: Wi
  }
}), p(Ze, "drawing", {
  add: eE
});
function D1(e, t, n, r) {
  var u;
  if (t === "")
    return e;
  const s = {
    id: "mock-id",
    body: e,
    documentStyle: {}
  }, i = new Ft(s), o = t.length;
  let a;
  for (; (a = (r ? i.getBody().dataStream : i.getBody().dataStream.toLowerCase()).indexOf(t)) >= 0; ) {
    const c = new Ne(), h = en.getInstance();
    if (a > 0 && c.retain(a), n.length > 0) {
      const d = i.sliceBody(a, a + o), f = {
        dataStream: n
      };
      if (Array.isArray(d == null ? void 0 : d.textRuns) && d.textRuns.length && (f.textRuns = [__spreadProps(__spreadValues({}, d.textRuns[0]), {
        st: 0,
        ed: n.length
      })]), (u = d == null ? void 0 : d.customRanges) != null && u.length) {
        const g = d.customRanges[0];
        f.customRanges = [__spreadProps(__spreadValues({}, g), {
          startIndex: 0,
          endIndex: n.length - 1
        })];
      }
      c.insert(n.length, f);
    }
    c.delete(o), i.apply(h.editOp(c.serialize()));
  }
  const l = i.getBody();
  return i.dispose(), l;
}
function hE(e) {
  if (e.customRanges || (e.customRanges = []), !e.paragraphs) {
    e.paragraphs = [];
    for (let t = 0; t < e.dataStream.length; t++)
      e.dataStream[t] === "\r" && e.paragraphs.push({ startIndex: t });
  }
  return e.customBlocks || (e.customBlocks = []), e.textRuns || (e.textRuns = []), e.customDecorations || (e.customDecorations = []), e.sectionBreaks || (e.sectionBreaks = []), e.tables || (e.tables = []), e;
}
function lc(e) {
  var t;
  return e.body = hE((t = e.body) != null ? t : { dataStream: "" }), e.drawingsOrder || (e.drawingsOrder = []), e.drawings || (e.drawings = {}), e.documentStyle || (e.documentStyle = {}), e;
}
var js = class _js {
  /**
   * Creates a new TextStyleValue instance
   * @param {ITextStyle} style The initial style object
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style);
   * ```
   */
  constructor(t = {}) {
    p(this, "_style");
    this._style = t;
  }
  /**
   * Creates an instance of TextStyleValue.
   * @param {ITextStyle} style style object
   * @returns {TextStyleValue} font style instance
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style);
   * ```
   */
  static create(t = {}) {
    return new _js(t);
  }
  /**
   * Gets the font family
   * @returns {Nullable<string>} The font family name or undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.fontFamily);
   * ```
   */
  get fontFamily() {
    return this._style.ff;
  }
  /**
   * Gets the font size in points
   * @returns {number | undefined} The font size or undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.fontSize);
   * ```
   */
  get fontSize() {
    return this._style.fs;
  }
  /**
   * Gets whether the text is italic
   * @returns {boolean} True if italic, false otherwise
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.italic);
   * ```
   */
  get italic() {
    return this._style.it === ie.TRUE;
  }
  /**
   * Gets whether the text is bold
   * @returns {boolean} True if bold, false otherwise
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.bold);
   * ```
   */
  get bold() {
    return this._style.bl === ie.TRUE;
  }
  /**
   * Gets the underline decoration
   * @returns {TextDecorationBuilder | undefined} The underline decoration or undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.underline);
   * ```
   */
  get underline() {
    return this._style.ul && dn.create(this._style.ul);
  }
  /**
   * Gets the bottom border line decoration
   * @returns {TextDecorationBuilder | undefined} The bottom border line decoration or undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.bottomBorderLine);
   * ```
   */
  get bottomBorderLine() {
    return this._style.bbl && dn.create(this._style.bbl);
  }
  /**
   * Gets the strikethrough decoration
   * @returns {TextDecorationBuilder | undefined} The strikethrough decoration or undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.strikethrough);
   * ```
   */
  get strikethrough() {
    return this._style.st && dn.create(this._style.st);
  }
  /**
   * Gets the overline decoration
   * @returns {TextDecorationBuilder | undefined} The overline decoration or undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.overline);
   * ```
   */
  get overline() {
    return this._style.ol && dn.create(this._style.ol);
  }
  /**
   * Gets the background color
   * @returns {Nullable<IColorStyle>} The background color or null/undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.background);
   * ```
   */
  get background() {
    return this._style.bg;
  }
  /**
   * Gets the border settings
   * @returns {Nullable<IBorderData>} The border settings or null/undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.border);
   * ```
   */
  get border() {
    return this._style.bd;
  }
  /**
   * Gets the text color
   * @returns {Nullable<IColorStyle>} The text color or null/undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.color);
   * ```
   */
  get color() {
    return this._style.cl;
  }
  /**
   * Gets the vertical alignment (subscript/superscript)
   * @returns {Nullable<BaselineOffset>} The vertical alignment or null/undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.verticalAlign);
   * ```
   */
  get verticalAlign() {
    return this._style.va;
  }
  /**
   * Gets the number format pattern
   * @returns {Nullable<{ pattern: string }>} The number format pattern or null/undefined
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.numberFormat);
   * ```
   */
  get numberFormat() {
    return this._style.n;
  }
  /**
   * Creates a copy of this font style as a builder
   * @returns {TextStyleBuilder} A new TextStyleBuilder instance with the same style
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * const copy = style.copy();
   * console.log(copy);
   * ```
   */
  copy() {
    return _n.create(Z.deepClone(this._style));
  }
  /**
   * Gets the raw style object
   * @returns {ITextStyle} The underlying style object
   * @example
   * ```ts
   * const style = TextStyleValue.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style.getValue());
   * ```
   */
  getValue() {
    return __spreadValues({}, this._style);
  }
};
var _n = class __n extends js {
  /**
   * Creates a new TextStyleBuilder instance
   * @param {ITextStyle} style Initial style object
   * @returns {TextStyleBuilder} A new TextStyleBuilder instance
   * @example
   * ```ts
   * const style = TextStyleBuilder.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style);
   * ```
   */
  static create(t = {}) {
    return new __n(t);
  }
  /**
   * Creates a new TextStyleBuilder instance
   * @param {ITextStyle} style The initial style object
   * @example
   * ```ts
   * const style = new TextStyleBuilder({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * console.log(style);
   * ```
   */
  constructor(t = {}) {
    super(t);
  }
  /**
   * Sets the font family
   * @param {string} family The font family name
   * @returns {TextStyleBuilder} The builder instance for chaining
   * @example
   * ```ts
   * const style = TextStyleBuilder.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * style.setFontFamily('Times New Roman');
   * console.log(style.fontFamily);
   * ```
   */
  setFontFamily(t) {
    return this._style.ff = t, this;
  }
  /**
   * Sets the font size in points
   * @param {number} size The font size
   * @returns {TextStyleBuilder} The builder instance for chaining
   * @example
   * ```ts
   * const style = TextStyleBuilder.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * style.setFontSize(14);
   * console.log(style.fontSize);
   * ```
   */
  setFontSize(t) {
    return this._style.fs = t, this;
  }
  /**
   * Sets the italic style
   * @param {boolean} value True to make italic, false otherwise
   * @returns {TextStyleBuilder} The builder instance for chaining
   * @example
   * ```ts
   * const style = TextStyleBuilder.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * style.setItalic(true);
   * console.log(style.italic);
   * ```
   */
  setItalic(t) {
    return this._style.it = t ? 1 : 0, this;
  }
  /**
   * Sets the bold style
   * @param {boolean} value True to make bold, false otherwise
   * @returns {TextStyleBuilder} The builder instance for chaining
   * @example
   * ```ts
   * const style = TextStyleBuilder.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * style.setBold(true);
   * console.log(style.bold);
   * ```
   */
  setBold(t) {
    return this._style.bl = t ? 1 : 0, this;
  }
  /**
   * Sets the underline decoration
   * @param {TextDecorationBuilder} decoration The underline decoration settings
   * @returns {TextStyleBuilder} The builder instance for chaining
   * @example
   * ```ts
   * const style = TextStyleBuilder.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * style.setUnderline({ type: 'single', color: '#FF0000' });
   * console.log(style.underline);
   * ```
   */
  setUnderline(t) {
    return this._style.ul = t.build(), this;
  }
  /**
   * Sets the bottom border line decoration
   * @param {TextDecorationBuilder} decoration The bottom border line decoration settings
   * @returns {TextStyleBuilder} The builder instance for chaining
   * @example
   * ```ts
   * const style = TextStyleBuilder.create({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * style.setBottomBorderLine({ type: 'single', color: '#FF0000' });
   * console.log(style.bottomBorderLine);
   * ```
   */
  setBottomBorderLine(t) {
    return this._style.bbl = t.build(), this;
  }
  /**
   * Sets the strikethrough decoration
   * @param {TextDecorationBuilder} decoration The strikethrough decoration settings
   * @returns {TextStyleBuilder} The builder instance for chaining
   */
  setStrikethrough(t) {
    return this._style.st = t.build(), this;
  }
  /**
   * Sets the overline decoration
   * @param {TextDecorationBuilder} decoration The overline decoration settings
   * @returns {TextStyleBuilder} The builder instance for chaining
   */
  setOverline(t) {
    return this._style.ol = t.build(), this;
  }
  /**
   * Sets the background color
   * @param {IColorStyle | null} color The background color or null to remove
   * @returns {TextStyleBuilder} The builder instance for chaining
   */
  setBackground(t) {
    return this._style.bg = t, this;
  }
  /**
   * Sets the border settings
   * @param {IBorderData | null} border The border settings or null to remove
   * @returns {TextStyleBuilder} The builder instance for chaining
   */
  setBorder(t) {
    return this._style.bd = t, this;
  }
  /**
   * Sets the text color
   * @param {IColorStyle | null} color The text color or null to remove
   * @returns {TextStyleBuilder} The builder instance for chaining
   */
  setColor(t) {
    return this._style.cl = t, this;
  }
  /**
   * Sets the vertical alignment (subscript/superscript)
   * @param {BaselineOffset | null} offset The vertical alignment or null to remove
   * @returns {TextStyleBuilder} The builder instance for chaining
   */
  setVerticalAlign(t) {
    return this._style.va = t, this;
  }
  /**
   * Creates a copy of this font style builder
   * @returns {TextStyleBuilder} A new TextStyleBuilder instance with the same style
   */
  copy() {
    return __n.create(Z.deepClone(this._style));
  }
  /**
   * Builds and returns the final style object
   * @returns {ITextStyle} The complete style object
   */
  build() {
    return this.getValue();
  }
};
var dn = class _dn {
  /**
   * Creates a new TextDecorationBuilder instance
   * @param {ITextDecoration} decoration The initial decoration object
   * @example
   * ```ts
   * const decoration = new TextDecorationBuilder({ s: 1, t: TextDecoration.SINGLE });
   * ```
   */
  constructor(t = { s: 1 }) {
    p(this, "_decoration");
    this._decoration = t;
  }
  /**
   * Creates an instance of TextDecorationBuilder.
   * @param {ITextDecoration} decoration Initial decoration object
   * @returns {TextDecorationBuilder} text decoration builder instance
   * @example
   * ```ts
   * const decoration = TextDecorationBuilder.create({ s: 1, t: TextDecoration.SINGLE });
   * console.log(decoration);
   * ```
   */
  static create(t = { s: 1 }) {
    return new _dn(t);
  }
  /**
   * Gets whether the decoration is shown
   * @returns {boolean} True if the decoration is shown
   */
  get show() {
    return this._decoration.s === ie.TRUE;
  }
  /**
   * Gets whether the decoration color follows the font color
   * @returns {boolean} True if the decoration color follows the font color
   */
  get followFontColor() {
    return this._decoration.c === ie.TRUE;
  }
  /**
   * Gets the decoration color
   * @returns {Nullable<IColorStyle>} The decoration color
   */
  get color() {
    return this._decoration.cl;
  }
  /**
   * Gets the decoration line type
   * @returns {Nullable<TextDecoration>} The decoration line type
   */
  get type() {
    return this._decoration.t;
  }
  /**
   * Sets whether the decoration is shown
   * @param {boolean} value True to show the decoration
   * @returns {TextDecorationBuilder} The builder instance for chaining
   * @example
   * ```ts
   * decoration.setShow(true);
   * ```
   */
  setShow(t) {
    return this._decoration.s = t ? 1 : 0, this;
  }
  /**
   * Sets whether the decoration color follows the font color
   * @param {boolean} value True to follow font color
   * @returns {TextDecorationBuilder} The builder instance for chaining
   * @example
   * ```ts
   * decoration.setFollowFontColor(false);
   * ```
   */
  setFollowFontColor(t) {
    return this._decoration.c = t ? 1 : 0, this;
  }
  /**
   * Sets the decoration color
   * @param {IColorStyle} color The color style
   * @returns {TextDecorationBuilder} The builder instance for chaining
   * @example
   * ```ts
   * decoration.setColor({ rgb: '#FF0000' });
   * ```
   */
  setColor(t) {
    return this._decoration.cl = t, this;
  }
  /**
   * Sets the decoration line type
   * @param {TextDecoration} type The line type
   * @returns {TextDecorationBuilder} The builder instance for chaining
   * @example
   * ```ts
   * decoration.setLineType(TextDecoration.SINGLE);
   * ```
   */
  setLineType(t) {
    return this._decoration.t = t, this;
  }
  /**
   * Creates a copy of this text decoration builder
   * @returns {TextDecorationBuilder} A new TextDecorationBuilder instance with the same decoration
   * @example
   * ```ts
   * const copy = decoration.copy();
   * ```
   */
  copy() {
    return _dn.create(Z.deepClone(this._decoration));
  }
  /**
   * Builds and returns the final decoration object
   * @returns {ITextDecoration} The complete text decoration object
   * @example
   * ```ts
   * const style = decoration.build();
   * ```
   */
  build() {
    return __spreadValues({}, this._decoration);
  }
};
var Ws = class _Ws {
  constructor(t = {}) {
    p(this, "_style");
    this._style = t;
  }
  /**
   * Creates a new ParagraphStyleValue instance
   * @param {IParagraphStyle} style The initial style object
   * @returns A new ParagraphStyleValue instance
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * ```
   */
  static create(t = {}) {
    return new _Ws(t);
  }
  /**
   * Gets the first line indent
   * @returns {Nullable<INumberUnit>} The first line indent
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.indentFirstLine);
   * ```
   */
  get indentFirstLine() {
    return this._style.indentFirstLine;
  }
  /**
   * Gets the hanging indent
   * @returns {Nullable<INumberUnit>} The hanging indent
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.hanging);
   * ```
   */
  get hanging() {
    return this._style.hanging;
  }
  /**
   * Gets the indent start
   * @returns {Nullable<INumberUnit>} The indent start
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.indentStart);
   * ```
   */
  get indentStart() {
    return this._style.indentStart;
  }
  /**
   * Gets the indent end
   * @returns {Nullable<INumberUnit>} The indent end
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.indentEnd);
   * ```
   */
  get tabStops() {
    return this._style.tabStops;
  }
  /**
   * Gets the indent end
   * @returns {Nullable<INumberUnit>} The indent end
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.indentEnd);
   * ```
   */
  get indentEnd() {
    return this._style.indentEnd;
  }
  /**
   * Gets the text style
   * @returns {Nullable<ITextStyle>} The text style
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.textStyle);
   * ```
   */
  get textStyle() {
    return this._style.textStyle;
  }
  /**
   * Gets the heading id
   * @returns {Nullable<string>} The heading id
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.headingId);
   * ```
   */
  get headingId() {
    return this._style.headingId;
  }
  /**
   * Gets the named style type
   * @returns {Nullable<NamedStyleType>} The named style type
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.namedStyleType);
   * ```
   */
  get namedStyleType() {
    return this._style.namedStyleType;
  }
  /**
   * Gets the horizontal align
   * @returns {Nullable<HorizontalAlign>} The horizontal align
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.horizontalAlign);
   * ```
   */
  get horizontalAlign() {
    return this._style.horizontalAlign;
  }
  /**
   * Gets the line spacing
   * @returns {Nullable<number>} The line spacing
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.lineSpacing);
   * ```
   */
  get lineSpacing() {
    return this._style.lineSpacing;
  }
  /**
   * Gets the text direction
   * @returns {Nullable<TextDirection>} The text direction
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.direction);
   * ```
   */
  get direction() {
    return this._style.direction;
  }
  /**
   * Gets the spacing rule
   * @returns {Nullable<SpacingRule>} The spacing rule
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.spacingRule);
   * ```
   */
  get spacingRule() {
    return this._style.spacingRule;
  }
  /**
   * Gets the snap to grid
   * @returns {Nullable<BooleanNumber>} The snap to grid
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.snapToGrid);
   * ```
   */
  get snapToGrid() {
    return this._style.snapToGrid;
  }
  /**
   * Gets the space above
   * @returns {Nullable<INumberUnit>} The space above
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.spaceAbove);
   * ```
   */
  get spaceAbove() {
    return this._style.spaceAbove;
  }
  /**
   * Gets the space below
   * @returns {Nullable<INumberUnit>} The space below
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.spaceBelow);
   * ```
   */
  get spaceBelow() {
    return this._style.spaceBelow;
  }
  /**
   * Gets the border between
   * @returns {Nullable<IParagraphBorder>} The border between
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.borderBetween);
   * ```
   */
  get borderBetween() {
    return this._style.borderBetween;
  }
  /**
   * Gets the border top
   * @returns {Nullable<IParagraphBorder>} The border top
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.borderTop);
   * ```
   */
  get borderTop() {
    return this._style.borderTop;
  }
  /**
   * Gets the border bottom
   * @returns {Nullable<IParagraphBorder>} The border bottom
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.borderBottom);
   * ```
   */
  get borderBottom() {
    return this._style.borderBottom;
  }
  /**
   * Gets the border left
   * @returns {Nullable<IParagraphBorder>} The border left
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.borderLeft);
   * ```
   */
  get borderLeft() {
    return this._style.borderLeft;
  }
  /**
   * Gets the border right
   * @returns {Nullable<IParagraphBorder>} The border right
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.borderRight);
   * ```
   */
  get borderRight() {
    return this._style.borderRight;
  }
  /**
   * Gets the keep lines
   * @returns {boolean} The keep lines
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.keepLines);
   * ```
   */
  get keepLines() {
    return this._style.keepLines === ie.TRUE;
  }
  /**
   * Gets the keep next
   * @returns {boolean} The keep next
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.keepNext);
   * ```
   */
  get keepNext() {
    return this._style.keepNext === ie.TRUE;
  }
  /**
   * Gets the word wrap
   * @returns {boolean} The word wrap
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.wordWrap);
   * ```
   */
  get wordWrap() {
    return this._style.wordWrap === ie.TRUE;
  }
  /**
   * Gets the widow control
   * @returns {boolean} The widow control
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.widowControl);
   * ```
   */
  get widowControl() {
    return this._style.widowControl === ie.TRUE;
  }
  /**
   * Gets the shading
   * @returns {Nullable<IShading>} The shading
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.shading);
   * ```
   */
  get shading() {
    return this._style.shading;
  }
  /**
   * Gets the suppress hyphenation
   * @returns {boolean} The suppress hyphenation
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.suppressHyphenation);
   * ```
   */
  get suppressHyphenation() {
    return this._style.suppressHyphenation === ie.TRUE;
  }
  /**
   * Creates a copy of the paragraph style
   * @returns {ParagraphStyleBuilder} The copy
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * ```
   */
  copy() {
    return Rs.create(Z.deepClone(this._style));
  }
  /**
   * Gets the value
   * @returns {IParagraphStyle} The value
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * console.log(style.getValue());
   * ```
   */
  getValue() {
    return this._style;
  }
};
var Rs = class _Rs extends Ws {
  /**
   * Creates a new paragraph style builder
   * @param style The paragraph style
   * @returns A new paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * ```
   */
  static create(t = {}) {
    return new _Rs(t);
  }
  constructor(t = {}) {
    super(t);
  }
  /**
   * Sets the indent first line
   * @param value The indent first line
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setIndentFirstLine(10);
   * ```
   */
  setIndentFirstLine(t) {
    return this._style.indentFirstLine = t, this;
  }
  /**
   * Sets the hanging
   * @param value The hanging
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setHanging(10);
   * ```
   */
  setHanging(t) {
    return this._style.hanging = t, this;
  }
  /**
   * Sets the indent start
   * @param value The indent start
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setIndentStart(10);
   * ```
   */
  setIndentStart(t) {
    return this._style.indentStart = t, this;
  }
  /**
   * Sets the tab stops
   * @param value The tab stops
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setTabStops([{ value: 10 }]);
   * ```
   */
  setTabStops(t) {
    return this._style.tabStops = t, this;
  }
  /**
   * Sets the indent end
   * @param value The indent end
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setIndentEnd(10);
   * ```
   */
  setIndentEnd(t) {
    return this._style.indentEnd = t, this;
  }
  /**
   * Sets the text style
   * @param value The text style
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setTextStyle({ ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE });
   * ```
   */
  setTextStyle(t) {
    return this._style.textStyle = t, this;
  }
  /**
   * Sets the heading id
   * @param value The heading id
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setHeadingId('test');
   * ```
   */
  setHeadingId(t) {
    return this._style.headingId = t, this;
  }
  /**
   * Sets the named style type
   * @param value The named style type
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setNamedStyleType(NamedStyleType.CHAPTER);
   * ```
   */
  setNamedStyleType(t) {
    return this._style.namedStyleType = t, this;
  }
  /**
   * Sets the vertical align
   * @param value The vertical align
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setVerticalAlign(VerticalAlign.CENTER);
   * ```
   */
  setHorizontalAlign(t) {
    return this._style.horizontalAlign = t, this;
  }
  /**
   * Sets the line spacing
   * @param value The line spacing
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setLineSpacing(10);
   * ```
   */
  setLineSpacing(t) {
    return this._style.lineSpacing = t, this;
  }
  /**
   * Sets the text direction
   * @param value The text direction
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setTextDirection(TextDirection.RIGHT_TO_LEFT);
   * ```
   */
  setDirection(t) {
    return this._style.direction = t, this;
  }
  /**
   * Sets the spacing rule
   * @param value The spacing rule
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setSpacingRule(SpacingRule.AUTO);
   * ```
   */
  setSpacingRule(t) {
    return this._style.spacingRule = t, this;
  }
  /**
   * Sets the snap to grid
   * @param value The snap to grid
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setSnapToGrid(true);
   * ```
   */
  setSnapToGrid(t) {
    return this._style.snapToGrid = t ? 1 : 0, this;
  }
  /**
   * Sets the space above
   * @param value The space above
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setSpaceAbove(10);
   * ```
   */
  setSpaceAbove(t) {
    return this._style.spaceAbove = t, this;
  }
  /**
   * Sets the space below
   * @param value The space below
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setSpaceBelow(10);
   * ```
   */
  setSpaceBelow(t) {
    return this._style.spaceBelow = t, this;
  }
  /**
   * Sets the border between
   * @param {IParagraphBorder} value The border between
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setBorderBetween({ color: 'red', width: 1 });
   * ```
   */
  setBorderBetween(t) {
    return this._style.borderBetween = t, this;
  }
  /**
   * Sets the border top
   * @param {IParagraphBorder} value The border top
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setBorderTop({ color: 'red', width: 1 });
   * ```
   */
  setBorderTop(t) {
    return this._style.borderTop = t, this;
  }
  /**
   * Sets the border bottom
   * @param {IParagraphBorder} value The border bottom
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setBorderBottom({ color: 'red', width: 1 });
   * ```
   */
  setBorderBottom(t) {
    return this._style.borderBottom = t, this;
  }
  /**
   * Sets the border left
   * @param {IParagraphBorder} value The border left
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setBorderLeft({ color: 'red', width: 1 });
   * ```
   */
  setBorderLeft(t) {
    return this._style.borderLeft = t, this;
  }
  /**
   * Sets the border right
   * @param {IParagraphBorder} value The border right
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setBorderRight({ color: 'red', width: 1 });
   * ```
   */
  setBorderRight(t) {
    return this._style.borderRight = t, this;
  }
  /**
   * Sets the keep lines
   * @param value The keep lines
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setKeepLines(true);
   * ```
   */
  setKeepLines(t) {
    return this._style.keepLines = t ? 1 : 0, this;
  }
  /**
   * Sets the keep next
   * @param value The keep next
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setKeepNext(true);
   * ```
   */
  setKeepNext(t) {
    return this._style.keepNext = t ? 1 : 0, this;
  }
  /**
   * Sets the word wrap
   * @param value The word wrap
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setWordWrap(true);
   * ```
   */
  setWordWrap(t) {
    return this._style.wordWrap = t ? 1 : 0, this;
  }
  /**
   * Sets the widow control
   * @param {boolean} value The widow control value
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setWidowControl(true);
   * ```
   */
  setWidowControl(t) {
    return this._style.widowControl = t ? 1 : 0, this;
  }
  /**
   * Sets the shading style
   * @param {IShading} value The shading configuration
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setShading({ backgroundColor: '#f0f0f0' });
   * ```
   */
  setShading(t) {
    return this._style.shading = t, this;
  }
  /**
   * Sets whether to suppress hyphenation
   * @param {boolean} value The suppress hyphenation value
   * @returns {ParagraphStyleBuilder} The paragraph style builder
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * copy.setSuppressHyphenation(true);
   * ```
   */
  setSuppressHyphenation(t) {
    return this._style.suppressHyphenation = t ? 1 : 0, this;
  }
  /**
   * Creates a copy of the current paragraph style builder
   * @returns {ParagraphStyleBuilder} A new instance of ParagraphStyleBuilder with the same settings
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const copy = style.copy();
   * ```
   */
  copy() {
    return _Rs.create(Z.deepClone(this._style));
  }
  /**
   * Builds and returns the final paragraph style configuration
   * @returns {IParagraphStyle} The constructed paragraph style object
   * @example
   * ```ts
   * const style = ParagraphStyleValue.create({ textStyle: { ff: 'Arial', fs: 12, it: univerAPI.Enum.BooleanNumber.TRUE, bl: univerAPI.Enum.BooleanNumber.TRUE } });
   * const finalStyle = style.build();
   * ```
   */
  build() {
    return this.getValue();
  }
};
var fn = class _fn {
  constructor(t) {
    p(this, "_data");
    if (!t.body)
      throw new Error("Invalid document data, body is required");
    this._data = lc(t);
  }
  /**
   * Creates a new RichTextValue instance
   * @param {IDocumentData} data The initial data for the rich text value
   * @returns {RichTextValue} A new RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * ```
   */
  static create(t) {
    return new _fn(t);
  }
  /**
   * Creates a new RichTextValue instance
   * @param {IDocumentBody} data The initial data for the rich text value
   * @returns {RichTextValue} A new RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.createByBody({ dataStream: 'Hello World\r\n' });
   * ```
   */
  static createByBody(t) {
    return new _fn({ body: t, id: "d", documentStyle: {} });
  }
  /**
   * Creates a copy of the current RichTextValue instance
   * @returns {RichTextValue} A new instance of RichTextValue with the same data
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const copy = richText.copy();
   * ```
   */
  copy() {
    return Fn.create(Z.deepClone(this._data));
  }
  /**
   * Slices the current RichTextValue instance
   * @param {number} start The start index
   * @param {number} end The end index
   * @returns {RichTextBuilder} A new instance of RichTextBuilder with the sliced data
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const sliced = richText.slice(0, 5);
   * ```
   */
  slice(t, n) {
    const _a2 = this._data, { body: r } = _a2, s = __objRest(_a2, ["body"]);
    return Fn.create(__spreadProps(__spreadValues({}, Z.deepClone(s)), {
      body: kt(r, t, n)
    }));
  }
  /**
   * Converts the current RichTextValue instance to plain text
   * @returns {string} The plain text representation of the current RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const plainText = richText.toPlainText();
   * ```
   */
  toPlainText() {
    var t, n;
    return Ze.transform.getPlainText((n = (t = this._data.body) == null ? void 0 : t.dataStream) != null ? n : "").replaceAll("\r", `
`);
  }
  /**
   * Gets the paragraph style of the current RichTextValue instance
   * @returns {ParagraphStyleValue} The paragraph style of the current RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const style = richText.getParagraphStyle();
   * ```
   */
  getParagraphStyle() {
    var t, n;
    return Ws.create((n = (t = this._data.body) == null ? void 0 : t.paragraphs) == null ? void 0 : n[0].paragraphStyle);
  }
  /**
   * Gets the paragraph bullet of the current RichTextValue instance
   * @returns {ParagraphBulletValue} The paragraph bullet of the current RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const bullet = richText.getParagraphBullet();
   * ```
   */
  getParagraphBullet() {
    var t, n;
    return (n = (t = this._data.body) == null ? void 0 : t.paragraphs) == null ? void 0 : n[0].bullet;
  }
  /**
   * Gets the paragraphs of the current RichTextValue instance
   * @returns {RichTextValue[]} The paragraphs of the current RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const paragraphs = richText.getParagraphs();
   * ```
   */
  getParagraphs() {
    var r, s;
    const t = (s = (r = this._data.body) == null ? void 0 : r.paragraphs) != null ? s : [];
    let n = 0;
    return t.map((i) => {
      const o = this.slice(n, i.startIndex);
      return n = i.startIndex, o;
    });
  }
  /**
   * Gets the text runs of the current RichTextValue instance
   * @returns {TextRunValue[]} The text runs of the current RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const textRuns = richText.getTextRuns();
   * ```
   */
  getTextRuns() {
    var t, n;
    return ((n = (t = this._data.body) == null ? void 0 : t.textRuns) != null ? n : []).map((r) => __spreadProps(__spreadValues({}, r), {
      ts: r.ts ? js.create(r.ts) : null
    }));
  }
  /**
   * Gets the links of the current RichTextValue instance
   * @returns {ICustomRange[]} The links of the current RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const links = richText.getLinks();
   * ```
   */
  getLinks() {
    var t, n, r;
    return (r = (n = (t = this._data.body) == null ? void 0 : t.customRanges) == null ? void 0 : n.filter((s) => s.rangeType === En.HYPERLINK)) != null ? r : [];
  }
  /**
   * Gets the data of the current RichTextValue instance
   * @returns {IDocumentData} The data of the current RichTextValue instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const data = richText.getData();
   * ```
   */
  getData() {
    return this._data;
  }
};
var Fn = class _Fn extends fn {
  constructor(n) {
    super(n);
    p(this, "_doc");
    this._doc = new Ft(n);
  }
  static newEmptyData() {
    return lc({
      id: "d",
      documentStyle: {},
      drawings: {},
      drawingsOrder: [],
      body: {
        dataStream: `\r
`,
        customBlocks: [],
        customRanges: [],
        paragraphs: [{ startIndex: 0 }],
        textRuns: [],
        tables: [],
        sectionBreaks: []
      }
    });
  }
  /**
   * Creates a new RichTextBuilder instance
   * @param {IDocumentData} data The initial data for the rich text builder
   * @returns {RichTextBuilder} A new RichTextBuilder instance
   */
  static create(n) {
    return new _Fn(n != null ? n : _Fn.newEmptyData());
  }
  insertText(n, r, s) {
    var c, h;
    let i = ((h = (c = this._data.body) == null ? void 0 : c.dataStream.length) != null ? h : 2) - 2, o, a;
    if (typeof n == "string" ? o = n : (i = Math.min(n, i), o = r), typeof r == "object" ? a = r instanceof _n ? r.build() : r : a = s instanceof _n ? s.build() : s, !o) return this;
    const l = {
      dataStream: o,
      textRuns: a ? [
        {
          ts: a,
          st: i,
          ed: i + o.length
        }
      ] : []
    }, u = Ze.selection.replace({
      doc: this._doc,
      selection: { startOffset: i, endOffset: i, collapsed: true },
      body: l
    });
    if (!u)
      throw new Error("Insert text failed, please check.");
    return Ne.apply(this._doc.getBody(), u.serialize()), this;
  }
  insertRichText(n, r) {
    var a, l;
    let s = ((l = (a = this._data.body) == null ? void 0 : a.dataStream.length) != null ? l : 2) - 2, i;
    typeof n == "object" ? i = n instanceof fn ? n.getData() : n : (s = Math.min(n, s), i = r instanceof fn ? r.getData() : r);
    const o = Ze.selection.replace({
      doc: this._doc,
      selection: { startOffset: s, endOffset: s, collapsed: true },
      body: i.body
    });
    if (!o)
      throw new Error("Insert text failed, please check.");
    return Ne.apply(this._doc.getBody(), o.serialize()), this;
  }
  delete(n, r) {
    if (r !== void 0) {
      if (!r) return this;
      const s = Ze.selection.delete([{ startOffset: n, endOffset: n + r, collapsed: true }], this._data.body);
      Ne.apply(this._doc.getBody(), s);
    }
    return this;
  }
  /**
   * Sets the style of the text at the specified start and end positions
   * @param {number} start The start position of the text to set the style
   * @param {number} end The end position of the text to set the style
   * @param {TextStyleBuilder | ITextStyle} style The style to set
   * @returns {RichTextBuilder} The current RichTextBuilder instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const newRichText = richText.setStyle(5, 10, { ff: 'Arial', fs: 12 });
   * ```
   */
  setStyle(n, r, s) {
    const i = {
      dataStream: "",
      textRuns: [{
        ts: s instanceof _n ? s.build() : s,
        st: 0,
        ed: r - n
      }]
    }, o = Ze.selection.retain([{ startOffset: n, endOffset: r, collapsed: true }], i);
    return Ne.apply(this._doc.getBody(), o), this;
  }
  /**
   * Sets the link of the text at the specified start and end positions
   * @param {number} start The start position of the text to set the link
   * @param {number} end The end position of the text to set the link
   * @param {string} link The link to set
   * @returns {RichTextBuilder} The current RichTextBuilder instance
   * @example
   * ```ts
   * const richText = RichTextValue.create({ body: { dataStream: 'Hello World\r\n' } });
   * const newRichText = richText.setLink(5, 10, 'https://www.example.com');
   * ```
   */
  setLink(n, r, s) {
    const i = Ze.customRange.add({
      rangeType: En.HYPERLINK,
      rangeId: et(),
      properties: {
        url: s
      },
      ranges: [{ startOffset: n, endOffset: r, collapsed: false }],
      body: this._data.body
    });
    if (!i)
      throw new Error("Insert text failed, please check.");
    return Ne.apply(this._doc.getBody(), i.serialize()), this;
  }
  cancelLink(n, r) {
    if (typeof n == "string") {
      const s = Ze.customRange.delete({
        rangeId: n,
        documentDataModel: this._doc
      });
      if (!s)
        throw new Error("Insert text failed, please check.");
      Ne.apply(this._doc.getBody(), s.serialize());
    } else
      this.slice(n, r).getLinks().forEach((i) => {
        const o = Ze.customRange.delete({
          rangeId: i.rangeId,
          documentDataModel: this._doc
        });
        if (!o)
          throw new Error("Insert text failed, please check.");
        Ne.apply(this._doc.getBody(), o.serialize());
      });
    return this;
  }
  updateLink(n, r) {
    var i, o;
    const s = (o = (i = this._data.body) == null ? void 0 : i.customRanges) == null ? void 0 : o.find((a) => a.rangeId === n);
    if (!s)
      throw new Error("Link not found");
    return s.properties.url = r, this;
  }
  insertParagraph(n, r) {
    var o, a;
    let s, i;
    return typeof n == "object" ? (s = {
      dataStream: "\r",
      paragraphs: [{
        startIndex: 0,
        paragraphStyle: n.build()
      }]
    }, i = ((a = (o = this._data.body) == null ? void 0 : o.dataStream.length) != null ? a : 2) - 2) : (i = n, s = {
      dataStream: "\r",
      paragraphs: [{
        startIndex: 0,
        paragraphStyle: r == null ? void 0 : r.build()
      }]
    }), this.insertRichText(i, fn.create({ body: s, id: "d", documentStyle: {} })), this;
  }
  insertLink(n, r, s) {
    let i = "", o = "";
    typeof n == "string" ? (i = n, o = r) : (i = r, o = s);
    const a = _Fn.createByBody({
      dataStream: i,
      customRanges: [{
        rangeType: En.HYPERLINK,
        rangeId: et(),
        properties: {
          url: o
        },
        startIndex: 0,
        endIndex: i.length - 1
      }]
    });
    return typeof n == "number" ? this.insertRichText(n, a) : this.insertRichText(a);
  }
};
var U1 = "__default_document_sub_component_id20231101__";
var dE = class {
  constructor() {
    p(this, "skipNextObservers", false);
    p(this, "lastReturnValue");
    p(this, "isStopPropagation", false);
  }
  stopPropagation() {
    this.isStopPropagation = true;
  }
};
var P1 = class extends Subject {
  constructor() {
    super(...arguments);
    p(this, "_sortedObservers", []);
  }
  /** @deprecated Use `subscribeEvent` instead. */
  subscribe() {
    throw new Error("[EventSubject]: please use `subscribeEvent` instead of `subscribe` method for `EventSubject`.");
  }
  /** @deprecated Use `emitEvent` instead. */
  next() {
    throw new Error("[EventSubject]: please use `emitEvent` instead of `next` method for `EventSubject`.");
  }
  unsubscribe() {
    super.unsubscribe(), this._sortedObservers.length = 0;
  }
  complete() {
    super.complete(), this._sortedObservers.length = 0;
  }
  subscribeEvent(n) {
    let r;
    typeof n == "function" ? r = { next: ([i, o]) => n(i, o) } : r = n;
    const s = super.subscribe(r);
    return this._sortedObservers.push(r), this._sortedObservers.sort((i, o) => {
      var a, l;
      return ((a = i.priority) != null ? a : 0) - ((l = o.priority) != null ? l : 0);
    }), s.add(() => this._sortedObservers = this._sortedObservers.filter((i) => i !== r)), s;
  }
  clearObservers() {
    this._sortedObservers.forEach((n) => {
      var r;
      return (r = n.complete) == null ? void 0 : r.call(n);
    }), this._sortedObservers.length = 0;
  }
  emitEvent(n) {
    var r;
    if (!this.closed) {
      const s = new dE();
      s.lastReturnValue = n;
      for (const i of this._sortedObservers) {
        const o = (r = i.next) == null ? void 0 : r.call(i, [n, s]);
        if (s.lastReturnValue = o, s.skipNextObservers)
          return {
            handled: true,
            lastReturnValue: s.lastReturnValue,
            stopPropagation: s.isStopPropagation
          };
      }
      return {
        handled: this._sortedObservers.length > 0,
        lastReturnValue: s.lastReturnValue,
        stopPropagation: s.isStopPropagation
      };
    }
    throw new Error("[EventSubject]: cannot emit event on a closed subject.");
  }
};
function k1(e) {
  return new Observable((t) => {
    const n = e.subscribeEvent((r) => {
      t.next(r);
    });
    return () => n.unsubscribe();
  });
}
var na = createIdentifier("core.resource-manager.service");
var Yi = {
  [Dt.Editor]: "Editor",
  [Dt.Owner]: "Owner",
  [Dt.Reader]: "Reader",
  [Dt.UNRECOGNIZED]: "UNRECOGNIZED"
};
var zi = (e) => e ? {
  userID: `${Yi[e]}_${et(8)}`,
  name: Yi[e],
  avatar: ""
} : {
  userID: "",
  name: "",
  avatar: "",
  anonymous: true,
  canBindAnonymous: false
};
var fE = (e, t) => e.startsWith(Yi[t]);
var Is = class extends Ve {
  constructor() {
    super(...arguments);
    p(this, "_model", /* @__PURE__ */ new Map());
    p(this, "_userChange$", new Subject());
    p(this, "userChange$", this._userChange$.asObservable());
    p(this, "_currentUser$", new BehaviorSubject(zi()));
    p(this, "currentUser$", this._currentUser$.asObservable());
  }
  dispose() {
    super.dispose(), this._model.clear(), this._userChange$.complete(), this._currentUser$.complete();
  }
  getCurrentUser() {
    return this._currentUser$.getValue();
  }
  setCurrentUser(n) {
    this.addUser(n), this._currentUser$.next(n);
  }
  addUser(n) {
    this._model.set(n.userID, n), this._userChange$.next({ type: "add", user: n });
  }
  getUser(n, r) {
    const s = this._model.get(n);
    if (s)
      return s;
    r && r();
  }
  delete(n) {
    const r = this.getUser(n);
    this._model.delete(n), r && this._userChange$.next({ type: "delete", user: r });
  }
  clear() {
    this._model.clear(), this._userChange$.next({ type: "clear" });
  }
  list() {
    return Array.from(this._model.values());
  }
};
var mE = Object.getOwnPropertyDescriptor;
var gE = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? mE(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
};
var Rl = (e, t) => (n, r) => t(n, r, e);
var Vi = class {
  // private _sheetPermissionPointMap: Map<string, { action: UnitAction; allowed: boolean }[]> = new Map();
  constructor(e, t) {
    p(this, "_permissionMap", /* @__PURE__ */ new Map([]));
    this._resourceManagerService = e, this._userManagerService = t, this._initSnapshot(), this._initDefaultUser();
  }
  _initDefaultUser() {
    const e = this._userManagerService.getCurrentUser();
    e && e.userID || this._userManagerService.setCurrentUser(zi(Dt.Owner));
  }
  _getRole(e) {
    const t = this._userManagerService.getCurrentUser();
    return t ? fE(t.userID, e) : false;
  }
  _initSnapshot() {
    this._resourceManagerService.registerPluginResource({
      toJson: (e) => {
        const t = [...this._permissionMap.keys()].reduce((n, r) => {
          const s = this._permissionMap.get(r);
          return n[r] = s, n;
        }, {});
        return JSON.stringify(t);
      },
      parseJson: (e) => JSON.parse(e),
      pluginName: "SHEET_AuthzIoMockService_PLUGIN",
      businesses: [we.UNIVER_SHEET, we.UNIVER_DOC, we.UNIVER_SLIDE],
      onLoad: (e, t) => {
        for (const n in t)
          this._permissionMap.set(n, t[n]);
      },
      onUnLoad: () => {
        this._permissionMap.clear();
      }
    });
  }
  create(e) {
    return __async(this, null, function* () {
      return et(8);
    });
  }
  allowed(e) {
    return __async(this, null, function* () {
      return Promise.resolve([]);
    });
  }
  batchAllowed(e) {
    return __async(this, null, function* () {
      return Promise.resolve([]);
    });
  }
  // eslint-disable-next-line max-lines-per-function
  list(e) {
    return __async(this, null, function* () {
      const t = [];
      return e.objectIDs.forEach((n) => {
        const r = this._permissionMap.get(n);
        if (r) {
          const s = {
            objectID: n,
            unitID: e.unitID,
            objectType: r.objectType,
            name: r.name,
            shareOn: false,
            shareRole: Dt.Owner,
            shareScope: -1,
            scope: {
              read: Si.AllCollaborator,
              edit: Si.AllCollaborator
            },
            creator: zi(Dt.Owner),
            strategies: [
              {
                action: 6,
                role: 1
              },
              {
                action: 16,
                role: 1
              },
              {
                action: 17,
                role: 1
              },
              {
                action: 18,
                role: 1
              },
              {
                action: 19,
                role: 1
              },
              {
                action: 33,
                role: 1
              },
              {
                action: 34,
                role: 1
              },
              {
                action: 35,
                role: 1
              },
              {
                action: 36,
                role: 1
              },
              {
                action: 37,
                role: 1
              },
              {
                action: 38,
                role: 1
              },
              {
                action: 39,
                role: 1
              },
              {
                action: 40,
                role: 1
              }
            ],
            actions: e.actions.map((i) => ({ action: i, allowed: this._getRole(Dt.Owner) || this._getRole(Dt.Editor) }))
          };
          t.push(s);
        }
      }), t;
    });
  }
  listCollaborators() {
    return __async(this, null, function* () {
      return [];
    });
  }
  listRoles() {
    return __async(this, null, function* () {
      return {
        roles: [],
        actions: []
      };
    });
  }
  deleteCollaborator() {
    return __async(this, null, function* () {
    });
  }
  update(e) {
    return __async(this, null, function* () {
    });
  }
  updateCollaborator() {
    return __async(this, null, function* () {
    });
  }
  createCollaborator() {
    return __async(this, null, function* () {
    });
  }
  putCollaborators(e) {
    return __async(this, null, function* () {
    });
  }
};
Vi = gE([
  Rl(0, na),
  Rl(1, Inject(Is))
], Vi);
var _E = createIdentifier("IAuthzIoIoService");
var qr = "FOCUSING_UNIT";
var _r = "FOCUSING_SHEET";
var Jr = "FOCUSING_DOC";
var Zr = "FOCUSING_SLIDE";
var F1 = "FOCUSING_EDITOR_BUT_HIDDEN";
var pE = "EDITOR_ACTIVATED";
var H1 = "FOCUSING_EDITOR_INPUT_FORMULA";
var EE = "FOCUSING_FX_BAR_EDITOR";
var $1 = "FOCUSING_UNIVER_EDITOR";
var B1 = "FOCUSING_EDITOR_INPUT_FORMULA";
var j1 = "FOCUSING_PANEL_EDITOR";
var W1 = "FOCUSING_UNIVER_EDITOR_STANDALONE_SINGLE_MODE";
var Y1 = "FOCUSING_COMMON_DRAWINGS";
var z1 = "FORMULA_EDITOR_ACTIVATED";
var CE = class extends Ve {
  constructor() {
    super(...arguments);
    p(this, "_error$", new Subject());
    p(this, "error$", this._error$.asObservable());
  }
  dispose() {
    this._error$.complete();
  }
  emit(n) {
    this._error$.next({ errorKey: n });
  }
};
var uc = ((e) => (e.URL = "URL", e.UUID = "UUID", e.BASE64 = "BASE64", e))(uc || {});
var RE = ((e) => (e.SUCCUSS = "0", e.ERROR_EXCEED_SIZE = "1", e.ERROR_IMAGE_TYPE = "2", e.ERROR_UPLOAD_COUNT_LIMIT = "3", e.ERROR_IMAGE = "4", e))(RE || {});
var Il = createIdentifier("core.image-io.service");
var IE = "0.12.4";
var wE = {
  version: IE
};
function SE(e = "", t = Ts.ZH_CN, n = "") {
  return {
    id: e,
    sheetOrder: [],
    name: n,
    appVersion: wE.version,
    locale: t,
    styles: {},
    sheets: {},
    resources: []
  };
}
var OE = class {
  constructor(t = {}) {
    p(this, "_styles");
    p(this, "_cacheMap", new _s(1e5));
    this._styles = t, this._generateCacheMap();
  }
  each(t) {
    return Object.entries(this._styles).forEach(t), this;
  }
  search(t, n) {
    if (this._cacheMap.has(n))
      return this._cacheMap.get(n);
    const r = this._getExistingStyleId(t);
    return r || "-1";
  }
  get(t) {
    return typeof t != "string" ? t : (t = String(t), this._styles[t]);
  }
  add(t, n) {
    const r = et(6);
    return this._styles[r] = t, this._cacheMap.set(n, r), r;
  }
  setValue(t) {
    if (t == null) return;
    const n = JSON.stringify(t), r = this.search(t, n);
    return r !== "-1" ? r : this.add(t, n);
  }
  addCustomStyle(t, n) {
    n != null && (this._styles[t] = n, this._cacheMap.set(JSON.stringify(n), t));
  }
  remove(t) {
    this._styles[t] && (delete this._styles[t], this._cacheMap.delete(JSON.stringify(this._styles[t])));
  }
  toJSON() {
    return this._styles;
  }
  // TODO: this should be `deReuseStyle` to be more accurate.
  getStyleByCell(t) {
    let n;
    t && Z.isObject(t.s) ? n = t.s : n = (t == null ? void 0 : t.s) && this.get(t.s);
    const r = t == null ? void 0 : t.interceptorStyle;
    return r ? __spreadValues(__spreadValues({}, n), r) : n;
  }
  _generateCacheMap() {
    const { _styles: t, _cacheMap: n } = this;
    for (const r in t) {
      const s = JSON.stringify(t[r]);
      n.set(s, r);
    }
  }
  _getExistingStyleId(t) {
    const { _styles: n } = this;
    for (const r in n)
      if (Z.diffValue(n[r], t))
        return r;
    return null;
  }
};
var V1 = (e, t) => t.length === e.length && !e.some((n) => t.some((r) => !Cn.equals(r, n)));
var G1 = (e, t) => t.length === e.length && e.every((n, r) => {
  const s = t[r];
  return s.unitId === n.unitId && s.sheetId === n.sheetId && Cn.equals(n.range, s.range);
});
var Gi = {
  t: 0,
  b: 2,
  // must over 1, see https://github.com/dream-num/univer/issues/2727
  l: 2,
  r: 2
};
var vE = (e) => ({
  sbr: 0.6,
  sbo: e,
  spr: 0.6,
  spo: e
});
var wl = 90;
function Qr(e, t, n = {}) {
  const r = e.length, {
    textRotation: s,
    paddingData: i,
    horizontalAlign: o = Pt.UNSPECIFIED,
    verticalAlign: a = Dn.UNSPECIFIED,
    wrapStrategy: l = jn.UNSPECIFIED,
    cellValueType: u
  } = n, { t: c, r: h, b: d, l: f } = i || Gi, { vertexAngle: g, centerAngle: _ } = cc(s), R = {
    id: "d",
    body: {
      dataStream: `${e}${Yc}`,
      textRuns: [
        {
          ts: t,
          st: 0,
          ed: r
        }
      ],
      paragraphs: [
        {
          startIndex: r,
          paragraphStyle: {
            horizontalAlign: o
          }
        }
      ],
      sectionBreaks: [{
        startIndex: r + 1
      }]
    },
    documentStyle: {
      pageSize: {
        width: Number.POSITIVE_INFINITY,
        height: Number.POSITIVE_INFINITY
      },
      marginTop: c,
      marginBottom: d,
      marginRight: h,
      marginLeft: f,
      renderConfig: {
        horizontalAlign: o,
        verticalAlign: a,
        centerAngle: _,
        vertexAngle: g,
        wrapStrategy: l,
        cellValueType: u
        /**
         * TODO@weird94
         * This config was previously used to fix the issue of cell image editing, now remove it first.
         * If you need to use it, please note the following issues:
         * 1. After delete cell content using backspace, the cell does not enter edit mode.
         * because the code `if (!info || info.actualWidth <= 0) return;`, code in `packages/sheets-ui/src/services/editor/cell-editor-resize.service.ts`
         * 2. copy empty cell content from excel and paste it to univer, the empty cell does not enter edit mode. The reason is the same as above.
         */
        // zeroWidthParagraphBreak: 1,
      }
    },
    drawings: {},
    drawingsOrder: []
  };
  return new Ft(R);
}
function bE(e) {
  if (!e) return {};
  const {
    tr: t,
    td: n,
    ht: r,
    vt: s,
    tb: i,
    pd: o
  } = e;
  return {
    textRotation: t,
    textDirection: n,
    horizontalAlign: r,
    verticalAlign: s,
    wrapStrategy: i,
    paddingData: o
  };
}
function Sl(e) {
  if (!e)
    return {};
  const { ff: t, fs: n, it: r, bl: s, ul: i, st: o, ol: a, cl: l, bg: u } = e, c = {};
  return t && (c.ff = t), n && (c.fs = n), r && (c.it = r), s && (c.bl = s), i && (c.ul = i), o && (c.st = o), a && (c.ol = a), l && (c.cl = l), u && (c.bg = u), c;
}
function AE(e, t, n) {
  var i;
  const r = e.getBody();
  if ((i = r.customRanges) != null && i.some((o) => o.rangeType === En.HYPERLINK))
    return;
  const s = Ze.customRange.add({
    ranges: [
      {
        startOffset: 0,
        endOffset: r.dataStream.length - 1,
        collapsed: false
      }
    ],
    rangeId: n,
    rangeType: En.HYPERLINK,
    body: r,
    properties: {
      url: t,
      refId: n
    }
  });
  s && Ne.apply(r, s.serialize());
}
function yE(e) {
  return e != null;
}
var NE = '"Helvetica Neue", Helvetica, Arial, "PingFang SC", "Hiragino Sans GB", "Heiti SC", "Microsoft YaHei", "WenQuanYi Micro Hei", sans-serif';
function Ol(e) {
  const t = rt.ff, n = rt.fs;
  if (!e) {
    const h = `${n}pt  ${t}`;
    return {
      fontCache: h,
      fontString: h,
      fontSize: n,
      originFontSize: n,
      fontFamily: t
    };
  }
  let r = or.ITALIC;
  (e.it === 0 || e.it === void 0) && (r = or.NORMAL);
  let s = or.BOLD;
  (e.bl === 0 || e.bl === void 0) && (s = or.NORMAL);
  let i = n;
  e.fs && (i = Math.ceil(e.fs));
  let o = t;
  if (e.ff) {
    let h = e.ff;
    h = h.replace(/"/g, "").replace(/'/g, ""), h.indexOf(" ") > -1 && (h = `"${h}"`), h == null && (h = t), o = h;
  }
  const { va: a } = e;
  let l = i;
  if (a === Zt.SUBSCRIPT || a === Zt.SUPERSCRIPT) {
    const h = TE(o, l), { sbr: d, spr: f } = h;
    l *= a === Zt.SUBSCRIPT ? d : f;
  }
  const u = `${r} ${s} ${l}pt ${o}`, c = `${u}, ${NE} `;
  return {
    fontCache: u,
    fontString: c,
    fontSize: l,
    originFontSize: i,
    fontFamily: o
  };
}
function TE(e, t) {
  return vE(t);
}
function cc(e) {
  const { a: t = 0, v: n = ie.FALSE } = e || { a: 0, v: ie.FALSE };
  let r = 0, s = t;
  return n === ie.TRUE && (r = wl, s = wl), { centerAngle: r, vertexAngle: s };
}
var ME = class {
  constructor(t, n) {
    p(this, "_columnData", {});
    this._config = t, this._columnData = n;
  }
  /**
   * Get width and hidden status of columns in the sheet
   * @returns {IObjectArrayPrimitiveType<Partial<IColumnData>>} Column data, including width, hidden status, etc.
   */
  getColumnData() {
    return this._columnData;
  }
  getColVisible(t) {
    const { _columnData: n } = this, r = n[t];
    return r ? r.hd !== ie.TRUE : true;
  }
  /**
   * Get the column style
   * @param {number} col Column index
   * @returns {string | Nullable<IStyleData>} Style data, may be undefined
   */
  getColumnStyle(t) {
    var n;
    return (n = this._columnData[t]) == null ? void 0 : n.s;
  }
  /**
   * Set the set column  default style
   * @param {number} col Column index
   * @param {string | Nullable<IStyleData>} style Style data
   */
  setColumnStyle(t, n) {
    const r = this.getColumnOrCreate(t);
    r.s = n;
  }
  /**
   * Get all hidden columns
   * @param start Start index
   * @param end End index
   * @returns Hidden columns range list
   */
  getHiddenCols(t = 0, n = this.getSize() - 1) {
    const r = [];
    let s = false, i = -1;
    for (let o = t; o <= n; o++) {
      const a = this.getColVisible(o);
      s && a ? (s = false, r.push({
        rangeType: ge.COLUMN,
        startColumn: i,
        endColumn: o - 1,
        startRow: 0,
        endRow: 0
      })) : !s && !a && (s = true, i = o);
    }
    return s && r.push({
      startRow: 0,
      endRow: 0,
      startColumn: i,
      endColumn: n,
      rangeType: ge.COLUMN
    }), r;
  }
  /**
   * Get all visible columns
   * @param start Start index
   * @param end End index
   * @returns Visible columns range list
   */
  getVisibleCols(t = 0, n = this.getSize() - 1) {
    const r = [];
    let s = false, i = -1;
    for (let o = t; o <= n; o++) {
      const a = this.getColVisible(o);
      s && !a ? (s = false, r.push({
        rangeType: ge.COLUMN,
        startColumn: i,
        endColumn: o - 1,
        startRow: 0,
        endRow: 0
      })) : !s && a && (s = true, i = o);
    }
    return s && r.push({
      startRow: 0,
      endRow: 0,
      startColumn: i,
      endColumn: n,
      rangeType: ge.COLUMN
    }), r;
  }
  getColumnDatas(t, n) {
    const r = {};
    let s = 0;
    for (let i = t; i < t + n; i++) {
      const o = this.getColumn(i);
      r[s] = o != null ? o : {
        w: this._config.defaultColumnWidth,
        hd: ie.FALSE
      }, s++;
    }
    return r;
  }
  /**
   * Get count of column in the sheet
   * @returns {number} count of column
   */
  getSize() {
    return gn(this._columnData);
  }
  /**
   * Get the width of column
   * @param columnPos column index
   * @returns {number} width of column
   */
  getColumnWidth(t) {
    var n, r;
    return (r = (n = this._columnData[t]) == null ? void 0 : n.w) != null ? r : this._config.defaultColumnWidth;
  }
  /**
   * Set the width of column
   * @param columnPos column index
   * @param width width of column
   */
  setColumnWidth(t, n) {
    const r = this._columnData[t];
    n === this._config.defaultColumnWidth ? r && (delete r.w, Object.keys(r).length === 0 && delete this._columnData[t]) : this._columnData[t] = r ? __spreadProps(__spreadValues({}, r), { w: n }) : { w: n };
  }
  /**
   * Get given column data
   * @param columnPos column index
   */
  getColumn(t) {
    return this._columnData[t];
  }
  /**
   * Remove column data of given column
   * @param columnPos
   */
  removeColumn(t) {
    delete this._columnData[t];
  }
  /**
   * Get given column data or create a column data when it's null
   * This method is used to ensure that the column data should not be null when setting column properties.
   * To prevent data redundancy, if is not setting column properties, you can use `getColumn` method to get column data. don't use this method.
   * @param columnPos column index
   * @returns {Partial<IColumnData>} columnData
   */
  getColumnOrCreate(t) {
    const { _columnData: n } = this, r = n[t];
    if (r)
      return r;
    const s = {};
    return this._columnData[t] = s, s;
  }
  setCustomMetadata(t, n) {
    const r = this.getColumn(t);
    r && (r.custom = n);
  }
  getCustomMetadata(t) {
    var n;
    return (n = this.getColumn(t)) == null ? void 0 : n.custom;
  }
};
var xE = 2e3;
var LE = class {
  constructor(t, n, r) {
    p(this, "_rowData");
    this._config = t, this._viewModel = n, this._rowData = r;
  }
  /**
   * Get height and hidden status of columns in the sheet
   * @returns {IObjectArrayPrimitiveType<Partial<IRowData>>} Row data, including height, hidden status, etc.
   */
  getRowData() {
    return this._rowData;
  }
  /**
   * Get the row style
   * @param {number} row Row index
   * @returns {string | Nullable<IStyleData>} Style data, may be undefined
   */
  getRowStyle(t) {
    var n;
    return (n = this._rowData[t]) == null ? void 0 : n.s;
  }
  /**
   * Set row default style
   * @param {number} row The row index
   * @param {string | Nullable<IStyleData>} style The style data
   */
  setRowStyle(t, n) {
    const r = this.getRowOrCreate(t);
    r.s = n;
  }
  getRowDatas(t, n) {
    const r = {};
    let s = 0;
    for (let i = t; i < t + n; i++) {
      const o = this.getRow(i);
      r[s] = o != null ? o : {
        h: this._config.defaultRowHeight,
        hd: ie.FALSE
      }, s++;
    }
    return r;
  }
  getRowHeight(t, n = 1) {
    const { _rowData: r } = this, s = this._config;
    let i = 0;
    for (let o = 0; o < n; o++) {
      const a = r[o + t] || {
        hd: ie.FALSE,
        h: s.defaultRowHeight
      }, { ia: l, ah: u, h: c = s.defaultRowHeight } = a;
      i += (l == null || l === ie.TRUE) && typeof u == "number" ? u : c;
    }
    return i;
  }
  /**
   * Set row height of given row
   * @param rowPos row index
   * @param height row height
   */
  setRowHeight(t, n) {
    const r = this._rowData[t];
    if (n === this._config.defaultRowHeight)
      r && (delete r.h, Object.keys(r).length === 0 && delete this._rowData[t]);
    else {
      const s = Math.min(n, xE);
      this._rowData[t] = r ? __spreadProps(__spreadValues({}, r), { h: s }) : { h: s };
    }
  }
  /**
   * Get row data of given row
   * @param rowPos row index
   * @returns {Nullable<Partial<IRowData>>} rowData
   */
  getRow(t) {
    return this._rowData[t];
  }
  /**
   * Remove row data of given row
   * @param rowPos
   */
  removeRow(t) {
    delete this._rowData[t];
  }
  /**
   * Get given row data or create a row data when it's null
   * This method is used to ensure that the row data should not be null when setting row properties.
   * To prevent data redundancy, if is not setting row properties, you can use `getRow` method to get row data. don't use this method.
   * @param rowPos row index
   * @returns {Partial<IRowData>} rowData
   */
  getRowOrCreate(t) {
    const { _rowData: n } = this, r = n[t];
    if (r)
      return r;
    const s = {};
    return n[t] = s, s;
  }
  /**
   * Get all hidden rows
   * @param start Start index
   * @param end End index
   * @returns Hidden rows range list
   */
  getHiddenRows(t = 0, n = this.getSize() - 1) {
    const r = [];
    let s = false, i = -1;
    for (let o = t; o <= n; o++) {
      const a = this.getRowRawVisible(o);
      s && a ? (s = false, r.push({
        startRow: i,
        endRow: o - 1,
        startColumn: 0,
        endColumn: 0,
        rangeType: ge.ROW
      })) : !s && !a && (s = true, i = o);
    }
    return s && r.push({ startRow: i, endRow: n, startColumn: 0, endColumn: 0, rangeType: ge.ROW }), r;
  }
  /**
   * Get all visible rows
   * @param start Start index
   * @param end End index
   * @returns Visible rows range list
   */
  getVisibleRows(t = 0, n = this.getSize() - 1) {
    const r = [];
    let s = false, i = -1;
    for (let o = t; o <= n; o++) {
      const a = this.getRowRawVisible(o);
      s && !a ? (s = false, r.push({
        startRow: i,
        endRow: o - 1,
        startColumn: 0,
        endColumn: 0,
        rangeType: ge.ROW
      })) : !s && a && (s = true, i = o);
    }
    return s && r.push({ startRow: i, endRow: n, startColumn: 0, endColumn: 0, rangeType: ge.ROW }), r;
  }
  getRowRawVisible(t) {
    const n = this.getRow(t);
    return n ? n.hd !== ie.TRUE : true;
  }
  /**
   * Get count of row in the sheet
   * @returns {number} row count
   */
  getSize() {
    return gn(this._rowData);
  }
  setCustomMetadata(t, n) {
    const r = this.getRow(t);
    r && (r.custom = n);
  }
  getCustomMetadata(t) {
    var n;
    return (n = this.getRow(t)) == null ? void 0 : n.custom;
  }
};
var K1 = "DEFAULT_WORKSHEET_ROW_COUNT";
var DE = 1e3;
var X1 = "DEFAULT_WORKSHEET_COLUMN_COUNT";
var UE = 20;
var q1 = "DEFAULT_WORKSHEET_ROW_HEIGHT";
var PE = 24;
var J1 = "DEFAULT_WORKSHEET_COLUMN_WIDTH";
var kE = 88;
var Z1 = "DEFAULT_WORKSHEET_ROW_TITLE_WIDTH";
var FE = 46;
var Q1 = "DEFAULT_WORKSHEET_COLUMN_TITLE_HEIGHT";
var HE = 20;
function $E(e) {
  const t = {
    name: "Sheet1",
    // TODO: name should have i18n
    id: "sheet-01",
    tabColor: "",
    hidden: ie.FALSE,
    rowCount: DE,
    columnCount: UE,
    zoomRatio: 1,
    freeze: {
      xSplit: 0,
      ySplit: 0,
      startRow: -1,
      startColumn: -1
    },
    scrollTop: 0,
    scrollLeft: 0,
    defaultColumnWidth: kE,
    defaultRowHeight: PE,
    mergeData: [],
    cellData: {},
    rowData: {},
    columnData: {},
    showGridlines: ie.TRUE,
    rowHeader: {
      width: FE,
      hidden: ie.FALSE
    },
    columnHeader: {
      height: HE,
      hidden: ie.FALSE
    },
    rightToLeft: ie.FALSE
  };
  return Object.keys(t).forEach((n) => {
    const r = n;
    typeof e[r] > "u" && (e[r] = t[r]);
  }), e;
}
var BE = class extends Ve {
  constructor(n) {
    super();
    p(this, "_cellCache", /* @__PURE__ */ new Map());
    p(this, "_rowCache", /* @__PURE__ */ new Map());
    p(this, "_columnCache", /* @__PURE__ */ new Map());
    p(this, "_hasRow", false);
    p(this, "_hasColumn", false);
    p(this, "_hasAll", false);
    p(this, "_allIndex", -1);
    p(this, "_mergeData");
    p(this, "_rangeMap", new _s(5e4));
    p(this, "_skeletonCache", new _s(5e4));
    this._init(n.concat());
  }
  _init(n) {
    this._mergeData = n, this._createCache(n);
  }
  _clearCache() {
    this._cellCache.clear(), this._rowCache.clear(), this._columnCache.clear(), this._hasAll = false, this._allIndex = -1, this._rangeMap.clear(), this._skeletonCache.clear(), this._hasColumn = false, this._hasRow = false;
  }
  _createCache(n) {
    let r = 0;
    for (const s of n) {
      const { rangeType: i } = s;
      i === ge.ROW ? this._createRowCache(s, r) : i === ge.COLUMN ? this._createColumnCache(s, r) : i === ge.ALL ? this._createCellAllCache(r) : this._createCellCache(s, r), r++;
    }
  }
  /**
   * Rebuild the merge data cache when the merge data is changed.
   * @param {IRange[]} mergeData
   */
  rebuild(n) {
    this._clearCache(), this._init(n.concat());
  }
  _createRowCache(n, r) {
    const { startRow: s, endRow: i } = n;
    for (let o = s; o <= i; o++)
      this._rowCache.set(o, r), this._hasRow = true;
  }
  _createColumnCache(n, r) {
    const { startColumn: s, endColumn: i } = n;
    for (let o = s; o <= i; o++)
      this._columnCache.set(o, r), this._hasColumn = true;
  }
  _createCellAllCache(n) {
    this._hasAll = true, this._allIndex = n;
  }
  _createCellCache(n, r) {
    for (let s = n.startRow; s <= n.endRow; s++) {
      let i = this._cellCache.get(s);
      i == null && (i = /* @__PURE__ */ new Map(), this._cellCache.set(s, i));
      for (let o = n.startColumn; o <= n.endColumn; o++)
        i.set(o, r);
    }
  }
  add(n) {
    this._mergeData.push(n), this._clearCache(), this._createCache(this._mergeData);
  }
  remove(n, r) {
    const s = this._getMergeDataIndex(n, r);
    s !== -1 && (this._mergeData.splice(s, 1), this._clearCache(), this._createCache(this._mergeData));
  }
  getMergedCell(n, r) {
    const s = this._getMergeDataIndex(n, r);
    return s !== -1 ? this._mergeData[s] : null;
  }
  /**
   * Return index of merge data if (row,col) is in merge range. -1 means not in merge range.
   * @param row
   * @param column
   * @returns {number} index of merge range.
   */
  getMergeDataIndex(n, r) {
    return this._getMergeDataIndex(n, r);
  }
  isRowContainsMergedCell(n) {
    return this._hasAll || !Z.isEmptyObject(this._columnCache) ? true : this._mergeData.some((r) => r.startRow <= n && n <= r.endRow);
  }
  isColumnContainsMergedCell(n) {
    return this._hasAll || !Z.isEmptyObject(this._rowCache) ? true : this._mergeData.some((r) => r.startColumn <= n && n <= r.endColumn);
  }
  getMergedCellRange(n, r, s, i) {
    const o = [], a = `${n}-${r}-${s}-${i}`;
    if (this._rangeMap.has(a))
      return this._getRangeFromCache(a);
    let l = 0;
    const u = [];
    for (const c of this._mergeData || [])
      Cn.intersects(c, {
        startRow: n,
        endRow: s,
        startColumn: r,
        endColumn: i
      }) && (o.push(__spreadValues({}, c)), u.push(l)), l++;
    return this._rangeMap.set(a, u), o;
  }
  /**
   * @deprecated sigificant performance impact, use _getCellMergeInfo instead.
   * @param startRow
   * @param startColumn
   * @param endRow
   * @param endColumn
   */
  getMergedCellRangeForSkeleton(n, r, s, i) {
    const o = [], a = this._mergeData, l = `${n}-${r}-${s}-${i}`;
    if (this._skeletonCache.has(l))
      return this._getSkeletonRangeFromCache(l);
    const u = [];
    for (let c = 0; c < a.length; c++) {
      const {
        startRow: h,
        endRow: d,
        startColumn: f,
        endColumn: g
      } = a[c];
      for (let _ = n; _ <= s; _++) {
        let R = false;
        for (let b = r; b <= i; b++)
          if (_ >= h && _ <= d && b >= f && b <= g) {
            o.push({
              startRow: h,
              endRow: d,
              startColumn: f,
              endColumn: g
            }), u.push(c), R = true;
            break;
          }
        if (R)
          break;
      }
    }
    return this._skeletonCache.set(l, u), o;
  }
  _getRangeFromCache(n) {
    const r = this._rangeMap.get(n) || [], s = [];
    for (const i of r)
      s.push(__spreadValues({}, this._mergeData[i]));
    return s;
  }
  _getSkeletonRangeFromCache(n) {
    const r = this._skeletonCache.get(n) || [], s = [];
    for (const i of r)
      s.push(__spreadValues({}, this._mergeData[i]));
    return s;
  }
  _getMergeDataIndex(n, r) {
    var i;
    if (this._hasAll)
      return this._allIndex;
    if (this._hasRow) {
      const o = this._rowCache.get(n);
      if (o !== void 0)
        return o;
    }
    if (this._hasColumn) {
      const o = this._columnCache.get(r);
      if (o !== void 0)
        return o;
    }
    const s = (i = this._cellCache.get(n)) == null ? void 0 : i.get(r);
    return s !== void 0 ? s : -1;
  }
  getMergeDataSnapshot() {
    return this._mergeData;
  }
  dispose() {
    this._clearCache(), this._mergeData = [];
  }
};
var jE = class extends Ve {
  constructor(n) {
    super();
    p(this, "_cellContentInterceptor", null);
    p(this, "_rowFilteredInterceptor", null);
    this.getRawCell = n;
  }
  dispose() {
    super.dispose(), this._cellContentInterceptor = null, this._rowFilteredInterceptor = null;
  }
  getCell(n, r, s, i) {
    return this._cellContentInterceptor ? this._cellContentInterceptor.getCell(n, r, ir.Value | ir.Style, s, i) : this.getRawCell(n, r);
  }
  getCellValueOnly(n, r) {
    return this._cellContentInterceptor ? this._cellContentInterceptor.getCell(n, r, ir.Value) : this.getRawCell(n, r);
  }
  getCellStyleOnly(n, r) {
    return this._cellContentInterceptor ? this._cellContentInterceptor.getCell(n, r, ir.Style) : this.getRawCell(n, r);
  }
  getRowFiltered(n) {
    var r, s;
    return (s = (r = this._rowFilteredInterceptor) == null ? void 0 : r.getRowFiltered(n)) != null ? s : false;
  }
  registerCellContentInterceptor(n) {
    if (this._cellContentInterceptor)
      throw new Error("[SheetViewModel]: Interceptor already registered.");
    return this._cellContentInterceptor = n, Be(() => this._cellContentInterceptor = null);
  }
  registerRowFilteredInterceptor(n) {
    if (this._rowFilteredInterceptor)
      throw new Error("[SheetViewModel]: Interceptor already registered.");
    return this._rowFilteredInterceptor = n, Be(() => this._rowFilteredInterceptor = null);
  }
};
function Ct(e) {
  if (e == null || typeof e !== "object")
    return e;
  if (Array.isArray(e)) {
    const s = e.length, i = new Array(s);
    for (let o = 0; o < s; o++)
      i[o] = Ct(e[o]);
    return i;
  }
  const n = {}, r = Object.keys(e);
  for (let s = 0, i = r.length; s < i; s++) {
    const o = r[s];
    n[o] = Ct(e[o]);
  }
  return n;
}
function WE(e) {
  if (e == null)
    return e;
  const t = {};
  return e.p !== void 0 && (t.p = e.p === null ? null : Ct(e.p)), e.s !== void 0 && (e.s === null || typeof e.s == "string" ? t.s = e.s : t.s = Ct(e.s)), e.v !== void 0 && (t.v = e.v), e.t !== void 0 && (t.t = e.t), e.f !== void 0 && (t.f = e.f), e.ref !== void 0 && (t.ref = e.ref), e.xf !== void 0 && (t.xf = e.xf), e.si !== void 0 && (t.si = e.si), e.custom !== void 0 && (t.custom = e.custom === null ? null : Ct(e.custom)), t;
}
function eI(e) {
  if (e == null)
    return e;
  const t = {};
  return e.p !== void 0 && (t.p = e.p === null ? null : Ct(e.p)), e.s !== void 0 && (e.s === null || typeof e.s == "string" ? t.s = e.s : t.s = Ct(e.s)), e.v !== void 0 && (t.v = e.v), e.t !== void 0 && (t.t = e.t), e.f !== void 0 && (t.f = e.f), e.ref !== void 0 && (t.ref = e.ref), e.xf !== void 0 && (t.xf = e.xf), e.si !== void 0 && (t.si = e.si), e.custom !== void 0 && (t.custom = e.custom === null ? null : Ct(e.custom)), e.rowSpan !== void 0 && (t.rowSpan = e.rowSpan), e.colSpan !== void 0 && (t.colSpan = e.colSpan), e.displayV !== void 0 && (t.displayV = e.displayV), t;
}
function YE(e) {
  const t = {}, n = Object.keys(e);
  for (let r = 0, s = n.length; r < s; r++) {
    const i = n[r], o = Number(i), a = e[o];
    if (a === void 0) continue;
    const l = {}, u = Object.keys(a);
    for (let c = 0, h = u.length; c < h; c++) {
      const d = u[c], f = Number(d), g = a[f];
      g != null && (l[f] = WE(g));
    }
    t[o] = l;
  }
  return t;
}
function vl(e) {
  const t = {}, n = Object.keys(e);
  for (let r = 0, s = n.length; r < s; r++) {
    const i = n[r], o = Number(i), a = e[o];
    if (a === void 0) continue;
    const l = {};
    "h" in a && a.h !== void 0 && (l.h = a.h), "ia" in a && a.ia !== void 0 && (l.ia = a.ia), "ah" in a && a.ah !== void 0 && (l.ah = a.ah), "hd" in a && a.hd !== void 0 && (l.hd = a.hd), "w" in a && a.w !== void 0 && (l.w = a.w), "s" in a && a.s !== void 0 && (a.s === null || typeof a.s == "string" ? l.s = a.s : l.s = Ct(a.s)), "custom" in a && a.custom !== void 0 && (l.custom = a.custom === null ? null : Ct(a.custom)), t[o] = l;
  }
  return t;
}
function zE(e) {
  const t = e.length, n = new Array(t);
  for (let r = 0; r < t; r++) {
    const s = e[r];
    n[r] = {
      startRow: s.startRow,
      startColumn: s.startColumn,
      endRow: s.endRow,
      endColumn: s.endColumn,
      rangeType: s.rangeType,
      startAbsoluteRefType: s.startAbsoluteRefType,
      endAbsoluteRefType: s.endAbsoluteRefType
    };
  }
  return n;
}
function VE(e) {
  const t = {
    // Primitive values - direct copy
    id: e.id,
    name: e.name,
    tabColor: e.tabColor,
    hidden: e.hidden,
    rowCount: e.rowCount,
    columnCount: e.columnCount,
    zoomRatio: e.zoomRatio,
    scrollTop: e.scrollTop,
    scrollLeft: e.scrollLeft,
    defaultColumnWidth: e.defaultColumnWidth,
    defaultRowHeight: e.defaultRowHeight,
    showGridlines: e.showGridlines,
    rightToLeft: e.rightToLeft,
    // Freeze - simple object with primitive values
    freeze: {
      xSplit: e.freeze.xSplit,
      ySplit: e.freeze.ySplit,
      startRow: e.freeze.startRow,
      startColumn: e.freeze.startColumn
    },
    // Row/column headers - simple objects
    rowHeader: {
      width: e.rowHeader.width,
      hidden: e.rowHeader.hidden
    },
    columnHeader: {
      height: e.columnHeader.height,
      hidden: e.columnHeader.hidden
    },
    // Merge data - array of IRange (primitives only)
    mergeData: zE(e.mergeData),
    // Cell data matrix - the largest data, use optimized clone
    cellData: YE(e.cellData),
    // Row/column data - sparse arrays
    rowData: vl(e.rowData),
    columnData: vl(e.columnData)
  };
  return e.gridlinesColor !== void 0 && (t.gridlinesColor = e.gridlinesColor), e.defaultStyle !== void 0 && (e.defaultStyle === null || typeof e.defaultStyle == "string" ? t.defaultStyle = e.defaultStyle : t.defaultStyle = Ct(e.defaultStyle)), e.custom !== void 0 && (t.custom = e.custom === null ? null : Ct(e.custom)), t;
}
var bl = {
  isDeepClone: false,
  displayRawFormula: false,
  ignoreTextRotation: false
};
var ws = class _ws {
  constructor(t, n, r) {
    p(this, "_sheetId");
    p(this, "_snapshot");
    p(this, "_cellData");
    p(this, "_rowManager");
    p(this, "_columnManager");
    p(this, "_viewModel");
    p(this, "_spanModel");
    p(this, "_isRowStylePrecedeColumnStyle", true);
    p(this, "_getCellHeight");
    var a;
    this.unitId = t, this._styles = r, this._snapshot = $E(n);
    const { columnData: s, rowData: i, cellData: o } = this._snapshot;
    this._sheetId = (a = this._snapshot.id) != null ? a : et(6), this._cellData = new ht(o), this._viewModel = new jE((l, u) => this.getCellRaw(l, u)), this._rowManager = new LE(this._snapshot, this._viewModel, i), this._columnManager = new ME(this._snapshot, s), this._spanModel = new BE(this._snapshot.mergeData);
  }
  /**
   * @internal
   * @param callback
   */
  __interceptViewModel(t) {
    t(this._viewModel);
  }
  /**
   * @internal
   * this is an internal method, please do not use it
   */
  __registerGetCellHeight(t) {
    return this._getCellHeight = t, Be(() => {
      this._getCellHeight = null;
    });
  }
  getSnapshot() {
    return this._snapshot;
  }
  getCellHeight(t, n) {
    return this._getCellHeight ? this._getCellHeight(t, n) : this._snapshot.defaultRowHeight;
  }
  /**
   * Set the merge data of the sheet, all the merged cells will be rebuilt.
   * @param mergeData
   */
  setMergeData(t) {
    this._snapshot.mergeData = t, this.getSpanModel().rebuild(t);
  }
  getSpanModel() {
    return this._spanModel;
  }
  setIsRowStylePrecedeColumnStyle(t) {
    this._isRowStylePrecedeColumnStyle = t;
  }
  getStyleDataByHash(t) {
    return __spreadValues({}, this._styles.get(t));
  }
  setStyleData(t) {
    return this._styles.setValue(t);
  }
  getColumnStyle(t, n = false) {
    return n ? this._columnManager.getColumnStyle(t) : this._styles.get(this._columnManager.getColumnStyle(t));
  }
  /**
   * Set the style of the column.
   * @param {number} column The column index
   * @param {string|Nullable<IStyleData>} style The style to be set
   */
  setColumnStyle(t, n) {
    this._columnManager.setColumnStyle(t, n);
  }
  getRowStyle(t, n = false) {
    return n ? this._rowManager.getRowStyle(t) : this._styles.get(this._rowManager.getRowStyle(t));
  }
  /**
   * Set the style of the row.
   * @param {number} row
   * @param {string|Nullable<IStyleData>} style The style to be set
   */
  setRowStyle(t, n) {
    this._rowManager.setRowStyle(t, n);
  }
  /**
   * Get the default style of the worksheet.
   * @returns {Nullable<IStyleData>} Default Style
   */
  getDefaultCellStyle() {
    return this._snapshot.defaultStyle;
  }
  getDefaultCellStyleInternal() {
    const t = this._snapshot.defaultStyle;
    return this._styles.get(t);
  }
  /**
   * Set Default Style, if the style has been set, all cells style will be base on this style.
   * @param {Nullable<IStyleData>} style The style to be set as default style
   */
  setDefaultCellStyle(t) {
    this._snapshot.defaultStyle = t;
  }
  getCellStyle(t, n) {
    const r = this.getCell(t, n);
    if (r) {
      const s = r.s;
      return typeof s == "string" ? this._styles.get(s) : s;
    }
    return null;
  }
  /**
   * Get the composed style of the cell. If you want to get the style of the cell without merging row style,
   * col style and default style, please use {@link getCellStyle} instead.
   *
   * @param {number} row The row index of the cell
   * @param {number} col The column index of the cell
   * @param {boolean} [rowPriority] If true, row style will precede column style, otherwise use this._isRowStylePrecedeColumnStyle
   * @returns {IStyleData} The composed style of the cell
   */
  getComposedCellStyle(t, n, r) {
    const s = this.getDefaultCellStyleInternal(), i = this.getRowStyle(t), o = this.getColumnStyle(n), a = this.getCell(t, n), l = this._styles.getStyleByCell(a);
    return (r != null ? r : this._isRowStylePrecedeColumnStyle) ? Dr(s, o, i, a == null ? void 0 : a.themeStyle, l) : Dr(s, i, o, a == null ? void 0 : a.themeStyle, l);
  }
  /**
   * Get the composed style of the cell. If you want to get the style of the cell without merging row style,
   * col style and default style, please use {@link getCellStyle} instead.
   * For performance reason, if you already have the cell data, you can use this method to avoid getting the cell data again.
   *
   * @param {number} row The row index of the cell
   * @param {number} col The column index of the cell
   * @param {Nullable<ICellDataForSheetInterceptor>} cellData The cell data of the cell.
   * @param {boolean} [rowPriority] If true, row style will precede column style, otherwise use this._isRowStylePrecedeColumnStyle
   * @returns {IStyleData} The composed style of the cell
   */
  getComposedCellStyleByCellData(t, n, r, s) {
    const i = this.getDefaultCellStyleInternal(), o = this.getRowStyle(t), a = this.getColumnStyle(n), l = this._styles.getStyleByCell(r);
    return (s != null ? s : this._isRowStylePrecedeColumnStyle) ? Dr(i, a, o, r == null ? void 0 : r.themeStyle, l) : Dr(i, o, a, r == null ? void 0 : r.themeStyle, l);
  }
  /**
   * Returns WorkSheet Cell Data Matrix
   * @returns WorkSheet Cell Data Matrix
   */
  getCellMatrix() {
    return this._cellData;
  }
  /**
   * Get worksheet printable cell range.
   * @returns
   */
  // eslint-disable-next-line max-lines-per-function
  getCellMatrixPrintRange() {
    const t = this.getCellMatrix(), n = this.getMergeData();
    let r = -1, s = -1, i = -1, o = -1, a = false, l = false;
    return t.forEach((u, c) => {
      Object.keys(c).forEach((h) => {
        const d = +h, f = t.getValue(u, d), g = f != null && f.s ? this._styles.get(f.s) : null, _ = (g == null ? void 0 : g.bd) && (g.bd.b || g.bd.l || g.bd.r || g.bd.t || g.bd.bc_tr || g.bd.bl_tr || g.bd.ml_tr || g.bd.tl_bc || g.bd.tl_br || g.bd.tl_mr);
        (f && (f.v !== null && f.v !== void 0 && f.v !== "" || f.p) || g != null && g.bg || _) && (a ? r = Math.min(r, u) : (r = u, a = true), s = Math.max(s, u), l ? i = Math.min(i, d) : (l = true, i = d), o = Math.max(o, d));
      });
    }), n.forEach((u) => {
      a ? r = Math.min(r, u.startRow) : (r = u.startRow, a = true), s = Math.max(s, u.endRow), l ? i = Math.min(i, u.startColumn) : (i = u.startColumn, a = true), o = Math.max(o, u.endColumn);
    }), !a || !l ? null : {
      startColumn: i,
      startRow: r,
      endColumn: o,
      endRow: s
    };
  }
  /**
   * Returns Row Manager
   * @returns Row Manager
   */
  getRowManager() {
    return this._rowManager;
  }
  /**
   * Returns the ID of its parent unit.
   */
  getUnitId() {
    return this.unitId;
  }
  /**
   * Returns the ID of the sheet represented by this object.
   * @returns ID of the sheet
   */
  getSheetId() {
    return this._sheetId;
  }
  /**
   * Returns Column Manager
   * @returns Column Manager
   */
  getColumnManager() {
    return this._columnManager;
  }
  /**
   * Returns the name of the sheet.
   * @returns name of the sheet
   */
  getName() {
    return this._snapshot.name;
  }
  /**
   * Returns WorkSheet Clone Object
   * @returns WorkSheet Clone Object
   * @deprecated
   */
  clone() {
    const { _snapshot: t } = this, n = VE(t);
    return new _ws(this.unitId, n, this._styles);
  }
  /**
   * Get the merged cell list of the sheet.
   * @returns {IRange[]} merged cell list
   */
  getMergeData() {
    return this._spanModel.getMergeDataSnapshot();
  }
  /**
   * Get the merged cell Range of the sheet cell.
   * If (row, col) is not in a merged cell, return null
   *
   * @param {number} row The row index of test cell
   * @param {number} col The column index of test cell
   * @returns {Nullable<IRange>} The merged cell range of the cell, if the cell is not in a merged cell, return null
   */
  getMergedCell(t, n) {
    return this._spanModel.getMergedCell(t, n);
  }
  /**
   * Get the merged cell info list which has intersection with the given range.
   * @param {number} startRow The start row index of the range
   * @param {number} startColumn The start column index of the range
   * @param {number} endRow The end row index of the range
   * @param {number} endColumn The end column index of the range
   * @returns {IRange} The merged cell info list which has intersection with the given range or empty array if no merged cell in the range
   */
  getMergedCellRange(t, n, r, s) {
    return this._spanModel.getMergedCellRange(t, n, r, s);
  }
  /**
   * Get if the row contains merged cell
   * @param {number} row The row index
   * @returns {boolean} Is merge cell across row
   */
  isRowContainsMergedCell(t) {
    return this._spanModel.isRowContainsMergedCell(t);
  }
  /**
   * Get if the column contains merged cell
   * @param {number} column The column index
   * @returns {boolean} Is merge cell across column
   */
  isColumnContainsMergedCell(t) {
    return this._spanModel.isColumnContainsMergedCell(t);
  }
  /**
   * Get cell info with merge data
   * @param {number} row - The row index of the cell.
   * @param {number} column - The column index of the cell.
   * @type {selectionCell}
   * @property {number} actualRow - The actual row index of the cell
   * @property {number} actualColumn - The actual column index of the cell
   * @property {boolean} isMergedMainCell - Whether the cell is the main cell of the merged cell, only the upper left cell in the merged cell returns true here
   * @property {boolean} isMerged - Whether the cell is in a merged cell, the upper left cell in the merged cell returns false here
   * @property {number} endRow - The end row index of the merged cell
   * @property {number} endColumn - The end column index of the merged cell
   * @property {number} startRow - The start row index of the merged cell
   * @property {number} startColumn - The start column index of the merged cell
   * @returns  {selectionCell} - The cell info with merge data
   */
  getCellInfoInMergeData(t, n) {
    const r = this.getMergedCell(t, n);
    let s = false, i = false, o = t, a = n, l = t, u = n;
    if (r) {
      const {
        startRow: c,
        endRow: h,
        startColumn: d,
        endColumn: f
      } = r;
      t === c && n === d ? (o = h, a = f, l = c, u = d, i = true) : t >= c && t <= h && n >= d && n <= f && (o = h, a = f, l = c, u = d, s = true);
    }
    return {
      actualRow: t,
      actualColumn: n,
      isMergedMainCell: i,
      isMerged: s,
      endRow: o,
      endColumn: a,
      startRow: l,
      startColumn: u
    };
  }
  /**
   * Get cellData, includes cellData, customRender, markers, dataValidate, etc.
   *
   * WARNING: All sheet CELL_CONTENT interceptors will be called in this method, cause performance issue.
   * example: this._sheetInterceptorService.intercept(INTERCEPTOR_POINT.CELL_CONTENT);
   *
   * @param row
   * @param col
   * @returns ICellDataForSheetInterceptor
   */
  getCell(t, n) {
    return t < 0 || n < 0 ? null : this._viewModel.getCell(t, n);
  }
  /**
   * Get cellData only use effect on value interceptor
   * @param {number} number row The row index of the cell.
   * @param {number} number col The column index of the cell.
   * @returns {Nullable<ICellDataForSheetInterceptor>} The cell data only use effect on value interceptor
   */
  getCellValueOnly(t, n) {
    return t < 0 || n < 0 ? null : this._viewModel.getCellValueOnly(t, n);
  }
  /**
   * Get cellData only use effect on style interceptor
   * @param {number} row The row index of the cell.
   * @param {number} col The column index of the cell.
   * @returns {Nullable<ICellDataForSheetInterceptor>} The cell data only use effect on style interceptor
   */
  getCellStyleOnly(t, n) {
    return t < 0 || n < 0 ? null : this._viewModel.getCellStyleOnly(t, n);
  }
  getCellRaw(t, n) {
    return this.getCellMatrix().getValue(t, n);
  }
  // eslint-disable-next-line ts/no-explicit-any
  getCellWithFilteredInterceptors(t, n, r, s) {
    return this._viewModel.getCell(t, n, r, s);
  }
  getRowFiltered(t) {
    return this._viewModel.getRowFiltered(t);
  }
  /**
   * Get the filtered out rows in a given range. used for remove rows operation, etc.
   * @param range - The range to get filtered rows from.
   * @returns {number[]} An array of row indices that are filtered out within the specified range.
   */
  getRangeFilterRows(t) {
    const n = [];
    for (let r = t.startRow; r <= t.endRow; r++)
      this.getRowFiltered(r) && n.push(r);
    return n;
  }
  getMatrixWithMergedCells(t, n, r, s, i = ar.Raw) {
    const o = this.getCellMatrix(), a = this._spanModel.getMergedCellRange(t, n, r, s), l = new ht();
    return fl(t, r, n, s).forEach((u, c) => {
      var d;
      let h;
      if (i === ar.Raw)
        h = this.getCellRaw(u, c);
      else if (i === ar.Intercepted)
        h = this.getCell(u, c);
      else if (i === ar.Both) {
        const f = this.getCellRaw(u, c);
        if (f) {
          h = __spreadValues({}, f);
          const g = (d = this.getCell(u, c)) == null ? void 0 : d.v;
          yE(g) && h && (h.displayV = String(g));
        }
      }
      h && l.setValue(u, c, h);
    }), a.forEach((u) => {
      const { startColumn: c, startRow: h, endColumn: d, endRow: f } = u;
      fl(h, f, c, d).forEach((g, _) => {
        g === h && _ === c && l.setValue(g, _, __spreadProps(__spreadValues({}, o.getValue(g, _)), {
          rowSpan: f - h + 1,
          colSpan: d - c + 1
        })), (g !== h || _ !== c) && l.realDeleteValue(g, _);
      });
    }), l;
  }
  getRange(t, n, r, s) {
    return typeof t == "object" ? new vr(this, t, {
      getStyles: () => this._styles
    }) : new vr(
      this,
      {
        startRow: t,
        startColumn: n,
        endColumn: s || n,
        endRow: r || t
      },
      {
        getStyles: () => this._styles
      }
    );
  }
  getScrollLeftTopFromSnapshot() {
    return {
      scrollLeft: this._snapshot.scrollLeft,
      scrollTop: this._snapshot.scrollTop
    };
  }
  /**
   * Return WorkSheetZoomRatio
   * @return zoomRatio
   */
  getZoomRatio() {
    return this._snapshot.zoomRatio || 1;
  }
  /**
   * Returns WorkSheet Configures
   * @returns WorkSheet Configures
   */
  getConfig() {
    return this._snapshot;
  }
  /**
   * Returns  frozen.
   * @returns  frozen
   */
  getFreeze() {
    return this._snapshot.freeze;
  }
  /**
   * Returns the current number of columns in the sheet, regardless of content.
   * @returns the current number of columns in the sheet, regardless of content
   */
  getMaxColumns() {
    const { _snapshot: t } = this, { columnCount: n } = t;
    return n;
  }
  /**
   * Returns the current number of rows in the sheet, regardless of content.
   * @returns the current number of rows in the sheet, regardless of content
   */
  getMaxRows() {
    const { _snapshot: t } = this, { rowCount: n } = t;
    return n;
  }
  getRowCount() {
    return this._snapshot.rowCount;
  }
  setRowCount(t) {
    this._snapshot.rowCount = t;
  }
  getColumnCount() {
    return this._snapshot.columnCount;
  }
  setColumnCount(t) {
    this._snapshot.columnCount = t;
  }
  /**
   * isSheetHidden
   * @returns hidden status of sheet
   */
  isSheetHidden() {
    return this._snapshot.hidden;
  }
  /**
   * Returns true if the sheet's gridlines are hidden; otherwise returns false. Gridlines are visible by default.
   * @returns {boolean} Gridlines Hidden Status.
   */
  hasHiddenGridlines() {
    const { _snapshot: t } = this, { showGridlines: n } = t;
    return n === 0;
  }
  /**
   * Returns the color of the gridlines, or undefined if the gridlines are not colored.
   * @returns {string | undefined} returns the color of the gridlines, or undefined if the gridlines are default.
   */
  getGridlinesColor() {
    return this.getConfig().gridlinesColor;
  }
  /**
   * Gets the sheet tab color, or null if the sheet tab has no color.
   * @returns the sheet tab color or null
   */
  getTabColor() {
    const { _snapshot: t } = this, { tabColor: n } = t;
    return n;
  }
  /**
   * Gets the width in pixels of the given column.
   * @param columnPosition column index
   * @returns Gets the width in pixels of the given column.
   */
  getColumnWidth(t) {
    return this.getColumnManager().getColumnWidth(t);
  }
  /**
   * Gets the height in pixels of the given row.
   * @param row row index
   * @returns Gets the height in pixels of the given row.
   */
  getRowHeight(t) {
    return this._viewModel.getRowFiltered(t) ? 0 : this.getRowManager().getRowHeight(t);
  }
  /**
   * Row is filtered out, that means this row is invisible.
   * @param row
   * @returns {boolean} is row hidden by filter
   */
  isRowFiltered(t) {
    return this._viewModel.getRowFiltered(t);
  }
  /**
   * Get if the row is visible. It may be affected by features like filter and view.
   * @param row the row index
   * @returns {boolean} if the row in visible to the user
   */
  getRowVisible(t) {
    return !this.isRowFiltered(t) && this.getRowRawVisible(t);
  }
  /**
   * Get if the row does not have `hidden` property. This value won't affected by features like filter and view.
   * @param row the row index
   * @returns if the row does not have `hidden` property
   */
  getRowRawVisible(t) {
    return this.getRowManager().getRowRawVisible(t);
  }
  getHiddenRows(t, n) {
    const r = this.getMaxColumns() - 1, s = this._rowManager.getHiddenRows(t, n);
    return s.forEach((i) => i.endColumn = r), s;
  }
  getColVisible(t) {
    return this._columnManager.getColVisible(t);
  }
  getHiddenCols(t, n) {
    const r = this.getMaxRows() - 1, s = this._columnManager.getHiddenCols(t, n);
    return s.forEach((i) => i.endRow = r), s;
  }
  /**
   * Get all visible rows in the sheet.(not include filter & view, like getRawVisibleRows)
   * @returns Visible rows range list
   */
  getVisibleRows() {
    const t = this.getRowCount();
    return this._rowManager.getVisibleRows(0, t - 1);
  }
  /**
   * Get all visible columns in the sheet.(not include filter & view)
   * @returns Visible columns range list
   */
  getVisibleCols() {
    const t = this.getColumnCount();
    return this._columnManager.getVisibleCols(0, t - 1);
  }
  /**
   * Returns true if this sheet layout is right-to-left. Returns false if the sheet uses the default left-to-right layout.
   * @returns true if this sheet layout is right-to-left. Returns false if the sheet uses the default left-to-right layout.
   */
  isRightToLeft() {
    const { _snapshot: t } = this, { rightToLeft: n } = t;
    return n;
  }
  /**
   * Returns the position of the last row that has content.
   * @returns the position of the last row that has content.
   */
  getLastRowWithContent() {
    return this._cellData.getRealRowRange().endRow;
  }
  /**
   * Returns the position of the last column that has content.
   * @returns the position of the last column that has content.
   */
  getLastColumnWithContent() {
    return this.getDataRealRange().endColumn;
  }
  getDataRealRange() {
    return this._cellData.getRealRange();
  }
  getDataRangeScope() {
    return this._cellData.getStartEndScope();
  }
  cellHasValue(t) {
    return t && (t.v !== void 0 || t.f !== void 0 || t.p !== void 0);
  }
  // #region iterators
  // NOTE: performance intensive. Should keep an eye on methods in this region.
  /**
   * Iterate a range row by row.
   *
   * Performance intensive.
   *
   * @param range the iterate range
   * @param skipEmpty whether to skip empty cells, default to be `true`
   */
  iterateByRow(t, n = true) {
    const { startRow: r, startColumn: s, endRow: i, endColumn: o } = t, a = this;
    return {
      [Symbol.iterator]: () => {
        let l = r, u = s;
        return {
          next() {
            for (; ; ) {
              if (u > o && (l += 1, u = s), l > i)
                return { done: true, value: void 0 };
              const c = a.getCell(l, u), h = !c, d = a.getMergedCell(l, u);
              if (d) {
                if (l !== d.startRow || u !== d.startColumn) {
                  u = d.endColumn + 1;
                  continue;
                }
                if (h && n) {
                  u = d.endColumn + 1;
                  continue;
                }
                const g = { row: l, col: u, value: c };
                return g.colSpan = d.endColumn - d.startColumn + 1, g.rowSpan = d.endRow - d.startRow + 1, u = d.endColumn + 1, { done: false, value: g };
              }
              if (h && n)
                u += 1;
              else {
                const f = { row: l, col: u, value: c };
                return u += 1, { done: false, value: f };
              }
            }
          }
        };
      }
    };
  }
  /**
   * Iterate a range column by column. This is pretty similar to `iterateByRow` but with different order.
   *
   * Performance intensive.
   *
   * @param range The iterate range.
   * @param skipEmpty Whether to skip empty cells, default to be `true`.
   * @param skipNonTopLeft Whether to skip non-top-left cells of merged cells, default to be `true`. If the
   * parameter is set to `false`, the iterator will return cells in the top row.
   */
  iterateByColumn(t, n = true, r = true) {
    const { startRow: s, startColumn: i, endRow: o, endColumn: a } = t, l = this;
    return {
      [Symbol.iterator]: () => {
        let u = s, c = i;
        return {
          next() {
            for (; ; ) {
              if (u > o && (c += 1, u = s), c > a)
                return { done: true, value: void 0 };
              const h = l.getMergedCell(u, c);
              if (h) {
                const g = u !== h.startRow, _ = g || c !== h.startColumn;
                if (r && _ || !r && g) {
                  u = h.endRow + 1;
                  continue;
                }
                const R = l.getCell(h.startRow, h.startColumn);
                if (!R && n) {
                  u = h.endRow + 1;
                  continue;
                }
                const $ = { row: u, col: h.startColumn, value: R };
                return $.colSpan = h.endColumn - h.startColumn + 1, $.rowSpan = h.endRow - h.startRow + 1, u = h.endRow + 1, { done: false, value: $ };
              }
              const d = l.getCell(u, c);
              if (!d && n)
                u += 1;
              else {
                const g = { row: u, col: c, value: d };
                return u += 1, { done: false, value: g };
              }
            }
          }
        };
      }
    };
  }
  /**
   * This method generates a document model based on the cell's properties and handles the associated styles and configurations.
   * If the cell does not exist, it will return null.
   * PS: This method has significant impact on performance.
   * @param cell
   * @param options
   */
  // eslint-disable-next-line complexity, max-lines-per-function
  getCellDocumentModel(t, n, r = bl) {
    var _;
    if (!t)
      return;
    const { isDeepClone: s, displayRawFormula: i, ignoreTextRotation: o } = __spreadValues(__spreadValues({}, bl), r);
    let a, l = "document";
    const u = bE(n), c = o ? rt.tr : u.textRotation || rt.tr;
    let h = u.horizontalAlign || rt.ht;
    const d = u.verticalAlign || rt.vt, f = u.wrapStrategy || rt.tb, g = u.paddingData || Gi;
    if (t.f && i)
      a = Qr(t.f.toString(), {}, { verticalAlign: d }), h = rt.ht;
    else if (t.p) {
      const { centerAngle: R, vertexAngle: b } = cc(c);
      a = this._updateConfigAndGetDocumentModel(
        s ? Z.deepClone(t.p) : t.p,
        h,
        g,
        {
          horizontalAlign: h,
          verticalAlign: d,
          centerAngle: R,
          vertexAngle: b,
          wrapStrategy: f,
          zeroWidthParagraphBreak: 1
        }
      );
    } else if (t.v != null) {
      const R = Sl(n);
      l = Ol(R).fontCache;
      let b = GE(t);
      t.t === mn.FORCE_STRING && i && (b = `'${b}`), a = Qr(b, R, __spreadProps(__spreadValues({}, u), {
        textRotation: c,
        cellValueType: t.t
      }));
    }
    return a && t.linkUrl && t.linkId && AE(a, t.linkUrl, t.linkId), {
      documentModel: a,
      fontString: l,
      textRotation: c,
      wrapStrategy: f,
      verticalAlign: d,
      horizontalAlign: h,
      paddingData: g,
      fill: (_ = n == null ? void 0 : n.bg) == null ? void 0 : _.rgb
    };
  }
  _updateConfigAndGetDocumentModel(t, n, r, s) {
    var o, a, l, u, c;
    if (!s || !((o = t.body) != null && o.dataStream))
      return;
    t.documentStyle || (t.documentStyle = {}), t.documentStyle.marginTop = (a = r.t) != null ? a : 0, t.documentStyle.marginBottom = (l = r.b) != null ? l : 2, t.documentStyle.marginLeft = (u = r.l) != null ? u : 2, t.documentStyle.marginRight = (c = r.r) != null ? c : 2, t.documentStyle.pageSize = {
      width: Number.POSITIVE_INFINITY,
      height: Number.POSITIVE_INFINITY
    }, t.documentStyle.renderConfig = __spreadValues(__spreadValues({}, t.documentStyle.renderConfig), s);
    const i = t.body.paragraphs || [];
    for (const h of i)
      h.paragraphStyle || (h.paragraphStyle = {}), h.paragraphStyle.horizontalAlign = n;
    return new Ft(t);
  }
  /**
   * Only used for cell edit, and no need to rotate text when edit cell content!
   */
  getBlankCellDocumentModel(t, n, r) {
    const s = this.getComposedCellStyleByCellData(n, r, t), i = Sl(s), o = this.getCellDocumentModel(t, s, { ignoreTextRotation: true });
    if (o != null)
      return o.documentModel == null && (o.documentModel = Qr("", i)), o;
    const a = "";
    let l = "document";
    const u = rt.tr, c = rt.ht, h = rt.vt, d = rt.tb, f = Gi;
    return l = Ol({}).fontCache, {
      documentModel: Qr(a, i),
      fontString: l,
      textRotation: u,
      wrapStrategy: d,
      verticalAlign: h,
      horizontalAlign: c,
      paddingData: f
    };
  }
  // Only used for cell edit, and no need to rotate text when edit cell content!
  getCellDocumentModelWithFormula(t, n, r) {
    const s = this.getComposedCellStyleByCellData(n, r, t);
    return this.getCellDocumentModel(t, s, {
      isDeepClone: true,
      displayRawFormula: true,
      ignoreTextRotation: true
    });
  }
  /**
   * Get custom metadata of worksheet
   * @returns {CustomData | undefined} custom metadata
   */
  getCustomMetadata() {
    return this._snapshot.custom;
  }
  /**
   * Set custom metadata of workbook
   * @param {CustomData | undefined} custom custom metadata
   */
  setCustomMetadata(t) {
    this._snapshot.custom = t;
  }
};
function GE(e) {
  var r, s;
  if (!e)
    return "";
  const t = (s = (r = e.p) == null ? void 0 : r.body) == null ? void 0 : s.dataStream;
  if (t)
    return Ze.transform.getPlainText(t);
  const n = e.v;
  return typeof n == "string" ? e.t === mn.BOOLEAN ? n.toUpperCase() : n.replace(/[\r\n]/g, "") : typeof n == "number" ? e.t === mn.BOOLEAN ? n ? "TRUE" : "FALSE" : n.toString() : typeof n == "boolean" ? n ? "TRUE" : "FALSE" : "";
}
function tI(e) {
  if (e === null)
    return "";
  if (e != null && e.p) {
    const t = e == null ? void 0 : e.p.body;
    if (t == null)
      return "";
    const n = t.dataStream;
    return Ze.transform.getPlainText(n);
  }
  return e == null ? void 0 : e.v;
}
var KE = Object.getOwnPropertyDescriptor;
var XE = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? KE(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
};
var qE = (e, t) => (n, r) => t(n, r, e);
function nI(e, t) {
  return `${e.getUnitId()}|${t.getSheetId()}`;
}
var Ss = class extends fo {
  constructor(t = {}, n) {
    super();
    p(this, "type", we.UNIVER_SHEET);
    p(this, "_sheetCreated$", new Subject());
    p(this, "sheetCreated$", this._sheetCreated$.asObservable());
    p(this, "_sheetDisposed$", new Subject());
    p(this, "sheetDisposed$", this._sheetDisposed$.asObservable());
    p(this, "_activeSheet$", new BehaviorSubject(null));
    p(this, "activeSheet$", this._activeSheet$.asObservable());
    p(this, "_worksheets");
    p(this, "_styles");
    p(this, "_snapshot");
    p(this, "_unitId");
    p(this, "_count");
    p(this, "_name$");
    p(this, "name$");
    this._logService = n;
    const r = SE();
    Z.isEmptyObject(t) ? this._snapshot = r : this._snapshot = Z.commonExtend(r, t);
    const { styles: s } = this._snapshot;
    (this._snapshot.id == null || this._snapshot.id.length === 0) && (this._snapshot.id = et(6)), this._unitId = this._snapshot.id, this._styles = new OE(s), this._count = 1, this._worksheets = /* @__PURE__ */ new Map(), this._name$ = new BehaviorSubject(t.name || ""), this.name$ = this._name$.asObservable(), this._parseWorksheetSnapshots();
  }
  get _activeSheet() {
    return this._activeSheet$.getValue();
  }
  get name() {
    return this._name$.getValue();
  }
  static isIRangeType(t) {
    return typeof t == "string" || "startRow" in t || "row" in t;
  }
  dispose() {
    super.dispose(), this._sheetCreated$.complete(), this._sheetDisposed$.complete(), this._activeSheet$.complete(), this._name$.complete();
  }
  /**
   * Create a clone of the current snapshot.
   * Call resourceLoaderService.saveWorkbook to save the data associated with the current plugin if needed.
   * @memberof Workbook
   */
  save() {
    return Z.deepClone(this._snapshot);
  }
  /**
   * Get current snapshot reference.
   * Call resourceLoaderService.saveWorkbook to save the data associated with the current plugin if needed.
   * @return {*}  {IWorkbookData}
   * @memberof Workbook
   */
  getSnapshot() {
    return this._snapshot;
  }
  /** @deprecated use use name property instead */
  getName() {
    return this._snapshot.name;
  }
  setName(t) {
    this._name$.next(t), this._snapshot.name = t;
  }
  getUnitId() {
    return this._unitId;
  }
  getRev() {
    var t;
    return (t = this._snapshot.rev) != null ? t : 1;
  }
  incrementRev() {
    this._snapshot.rev = this.getRev() + 1;
  }
  setRev(t) {
    this._snapshot.rev = t;
  }
  /**
   * Add a Worksheet into Workbook.
   */
  addWorksheet(t, n, r) {
    const { sheets: s, sheetOrder: i } = this._snapshot;
    if (s[t])
      return false;
    s[t] = r, i.splice(n, 0, t);
    const o = new ws(this._unitId, r, this._styles);
    return this._worksheets.set(t, o), this._sheetCreated$.next(o), true;
  }
  getSheetOrders() {
    return this._snapshot.sheetOrder;
  }
  getWorksheets() {
    return this._worksheets;
  }
  getActiveSpreadsheet() {
    return this;
  }
  getStyles() {
    return this._styles;
  }
  addStyles(t) {
    Object.entries(t).forEach(([n, r]) => {
      this._styles.addCustomStyle(n, r);
    });
  }
  removeStyles(t) {
    t.forEach((n) => {
      this._styles.remove(n);
    });
  }
  getConfig() {
    return this._snapshot;
  }
  getIndexBySheetId(t) {
    const { sheetOrder: n } = this._snapshot;
    return n.findIndex((r) => r === t);
  }
  getActiveSheet(t) {
    if (!this._activeSheet && typeof t > "u")
      throw new Error(`[Workbook]: no active Worksheet on Workbook ${this._unitId}!`);
    return this._activeSheet;
  }
  /**
   * If there is no active sheet, the first sheet would
   * be set active.
   * @returns
   */
  ensureActiveSheet() {
    const t = this._activeSheet;
    if (t)
      return t;
    const n = this._snapshot.sheetOrder;
    for (let s = 0, i = n.length; s < i; s++) {
      const o = this._worksheets.get(n[s]);
      if (o && o.isSheetHidden() !== ie.TRUE)
        return this.setActiveSheet(o), o;
    }
    const r = this._worksheets.get(n[0]);
    return this.setActiveSheet(r), r;
  }
  /**
   * ActiveSheet should not be null!
   * There is at least one sheet in a workbook. You can not delete all sheets in a workbook.
   * @param worksheet
   */
  setActiveSheet(t) {
    this._activeSheet$.next(t);
  }
  removeSheet(t) {
    const n = this._worksheets.get(t);
    return n ? (this._worksheets.delete(t), this._snapshot.sheetOrder.splice(this._snapshot.sheetOrder.indexOf(t), 1), delete this._snapshot.sheets[t], this._sheetDisposed$.next(n), true) : false;
  }
  getActiveSheetIndex() {
    const { sheetOrder: t } = this._snapshot;
    return t.findIndex((n) => this._worksheets.get(n) === this._activeSheet);
  }
  getSheetSize() {
    return this._snapshot.sheetOrder.length;
  }
  getSheets() {
    const { sheetOrder: t } = this._snapshot;
    return t.map((n) => this._worksheets.get(n));
  }
  getSheetsName() {
    const { sheetOrder: t } = this._snapshot, n = [];
    return t.forEach((r) => {
      const s = this._worksheets.get(r);
      s && n.push(s.getName());
    }), n;
  }
  getSheetIndex(t) {
    const { sheetOrder: n } = this._snapshot;
    return n.findIndex((r) => t.getSheetId() === r);
  }
  getSheetBySheetName(t) {
    const { sheetOrder: n } = this._snapshot, r = n.find((s) => this._worksheets.get(s).getName() === t);
    return this._worksheets.get(r);
  }
  getSheetBySheetId(t) {
    return this._worksheets.get(t);
  }
  getSheetByIndex(t) {
    const { sheetOrder: n } = this._snapshot;
    return this._worksheets.get(n[t]);
  }
  getHiddenWorksheets() {
    return this.getSheets().filter((t) => t.getConfig().hidden === ie.TRUE).map((t) => t.getConfig().id);
  }
  getUnhiddenWorksheets() {
    return this.getSheets().filter((t) => t.getConfig().hidden !== ie.TRUE).map((t) => t.getConfig().id);
  }
  load(t) {
    this._snapshot = t;
  }
  /**
   * Check if sheet name is unique
   * @param name sheet name
   * @returns True if sheet name is unique
   */
  checkSheetName(t) {
    return this.getSheetsName().includes(t);
  }
  /**
   *  Check whether the sheet name is unique and generate a new unique sheet name
   * @param name sheet name
   * @returns Unique sheet name
   */
  uniqueSheetName(t = "Sheet1") {
    let n = t;
    for (; this.checkSheetName(n); )
      n = t + this._count, this._count++;
    return n;
  }
  /**
   * Automatically generate new sheet name
   * @param name sheet name
   * @returns New sheet name
   */
  generateNewSheetName(t) {
    let n = t + this._count;
    for (; this.checkSheetName(n); )
      n = t + this._count, this._count++;
    return n;
  }
  // FIXME: now we always create worksheet from DEFAULT_WORKSHEET?
  /**
   * Get Default Sheet
   */
  _parseWorksheetSnapshots() {
    const { _snapshot: t, _worksheets: n } = this, { sheets: r, sheetOrder: s } = t;
    if (Z.isEmptyObject(r)) {
      const i = et();
      r[i] = { id: i };
    }
    for (const i in r) {
      const o = r[i], { name: a } = o;
      o.name = this.uniqueSheetName(a), o.name !== a && this._logService.debug("[Workbook]", `The worksheet name ${a} is duplicated, we changed it to ${o.name}. Please fix the problem in your snapshot.`);
      const l = new ws(this._unitId, o, this._styles);
      n.set(i, l), s.includes(i) || s.push(i);
    }
    this.ensureActiveSheet();
  }
  /**
   * Get custom metadata of workbook
   * @returns {CustomData | undefined} custom metadata
   */
  getCustomMetadata() {
    return this._snapshot.custom;
  }
  /**
   * Set custom metadata of workbook
   * @param {CustomData | undefined} custom custom metadata
   */
  setCustomMetadata(t) {
    this._snapshot.custom = t;
  }
};
Ss = XE([
  qE(1, Nt)
], Ss);
var hc = class extends fo {
  constructor(n) {
    var r;
    super();
    p(this, "type", we.UNIVER_SLIDE);
    p(this, "_activePage$", new BehaviorSubject(null));
    p(this, "activePage$", this._activePage$.asObservable());
    p(this, "_name$");
    p(this, "name$");
    p(this, "_snapshot");
    p(this, "_unitId");
    this._snapshot = __spreadValues(__spreadValues({}, Up), n), this._unitId = (r = this._snapshot.id) != null ? r : et(6), this._name$ = new BehaviorSubject(this._snapshot.title), this.name$ = this._name$.asObservable();
  }
  get _activePage() {
    var r, s;
    const n = this._activePage$.getValue();
    if (!n) {
      const i = (r = this.getPageOrder()) == null ? void 0 : r[0];
      return i ? (s = this.getPages()) == null ? void 0 : s[i] : null;
    }
    return n;
  }
  setName(n) {
    var r;
    this._snapshot.title = n, this._name$.next(n), this._unitId = (r = this._snapshot.id) != null ? r : et(6);
  }
  getRev() {
    return 0;
  }
  incrementRev() {
  }
  setRev(n) {
  }
  getSnapshot() {
    return this._snapshot;
  }
  getUnitId() {
    return this._unitId;
  }
  getPages() {
    var n;
    return (n = this._snapshot.body) == null ? void 0 : n.pages;
  }
  getPageOrder() {
    var n;
    return (n = this._snapshot.body) == null ? void 0 : n.pageOrder;
  }
  getPage(n) {
    const r = this.getPages();
    return r == null ? void 0 : r[n];
  }
  getElementsByPage(n) {
    var r;
    return (r = this.getPage(n)) == null ? void 0 : r.pageElements;
  }
  getElement(n, r) {
    var s;
    return (s = this.getElementsByPage(n)) == null ? void 0 : s[r];
  }
  getPageSize() {
    return this._snapshot.pageSize;
  }
  getBlankPage() {
    const n = et(6);
    return {
      id: n,
      pageType: mu.SLIDE,
      zIndex: 10,
      title: n,
      description: "",
      pageBackgroundFill: {
        rgb: "rgb(255,255,255)"
      },
      pageElements: {}
    };
  }
  setActivePage(n) {
    this._activePage$.next(n);
  }
  getActivePage() {
    return this._activePage;
  }
  updatePage(n, r) {
    this._snapshot.body && (this._snapshot.body.pages[n] = r);
  }
  appendPage(n) {
    var i;
    if (!this._snapshot.body) return;
    this._snapshot.body.pages[n.id] = n;
    const r = this._activePage, s = this._snapshot.body.pageOrder.indexOf((i = r == null ? void 0 : r.id) != null ? i : "");
    this._snapshot.body.pageOrder.splice(s + 1, 0, n.id);
  }
};
var JE = Object.getOwnPropertyDescriptor;
var ZE = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? JE(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
};
var Al = (e, t) => (n, r) => t(n, r, e);
var br = createIdentifier("univer.current");
var Ki = class extends Ve {
  constructor(t, n) {
    super();
    p(this, "_unitsByType", /* @__PURE__ */ new Map());
    p(this, "_createHandler");
    p(this, "_ctorByType", /* @__PURE__ */ new Map());
    p(this, "_currentUnits", /* @__PURE__ */ new Map());
    p(this, "_currentUnits$", new BehaviorSubject(this._currentUnits));
    p(this, "currentUnits$", this._currentUnits$.asObservable());
    p(this, "_unitAdded$", new Subject());
    p(this, "unitAdded$", this._unitAdded$.asObservable());
    p(this, "_unitDisposed$", new Subject());
    p(this, "unitDisposed$", this._unitDisposed$.asObservable());
    p(this, "_focused$", new BehaviorSubject(null));
    p(this, "focused$", this._focused$.asObservable());
    this._injector = t, this._contextService = n;
  }
  dispose() {
    super.dispose(), this._focused$.complete(), this._currentUnits$.complete(), this._unitAdded$.complete(), this._currentUnits.clear(), this._unitsByType.clear();
  }
  __setCreateHandler(t) {
    this._createHandler = t;
  }
  createUnit(t, n, r) {
    return this._createHandler(t, n, this._ctorByType.get(t), r);
  }
  registerCtorForType(t, n) {
    return this._ctorByType.set(t, n), {
      dispose: () => {
        this._ctorByType.delete(t);
      }
    };
  }
  getCurrentTypeOfUnit$(t) {
    return this.currentUnits$.pipe(map((n) => {
      var r;
      return (r = n.get(t)) != null ? r : null;
    }), distinctUntilChanged());
  }
  getCurrentUnitForType(t) {
    return this._currentUnits.get(t);
  }
  getCurrentUnitOfType(t) {
    return this.getCurrentUnitForType(t);
  }
  setCurrentUnitForType(t) {
    const n = this._getUnitById(t);
    if (!n) throw new Error(`[UniverInstanceService]: no document with unitId ${t}!`);
    this._currentUnits.set(n[1], n[0]), this._currentUnits$.next(this._currentUnits);
  }
  getTypeOfUnitAdded$(t) {
    return this._unitAdded$.pipe(filter((n) => n.type === t));
  }
  /**
   * Add a unit into Univer.
   *
   * @ignore
   *
   * @param unit The unit to be added.
   */
  __addUnit(t, n) {
    var o;
    const r = t.type;
    this._unitsByType.has(r) || this._unitsByType.set(r, []);
    const s = this._unitsByType.get(r), i = t.getUnitId();
    if (s.findIndex((a) => a.getUnitId() === i) !== -1)
      throw new Error(`[UniverInstanceService]: cannot create a unit with the same unit id: ${i}.`);
    s.push(t), this._unitAdded$.next(t), ((o = n == null ? void 0 : n.makeCurrent) == null || o) && this.setCurrentUnitForType(t.getUnitId());
  }
  getTypeOfUnitDisposed$(t) {
    return this.unitDisposed$.pipe(filter((n) => n.type === t));
  }
  getUnit(t, n) {
    var s;
    const r = (s = this._getUnitById(t)) == null ? void 0 : s[0];
    return n && (r == null ? void 0 : r.type) !== n ? null : r;
  }
  getCurrentUniverDocInstance() {
    return this.getCurrentUnitForType(we.UNIVER_DOC);
  }
  getUniverDocInstance(t) {
    return this.getUnit(t, we.UNIVER_DOC);
  }
  getUniverSheetInstance(t) {
    return this.getUnit(t, we.UNIVER_SHEET);
  }
  getAllUnitsForType(t) {
    var n;
    return (n = this._unitsByType.get(t)) != null ? n : [];
  }
  changeDoc(t, n) {
    const r = this.getAllUnitsForType(we.UNIVER_DOC), s = r.find((i) => i.getUnitId() === t);
    if (s != null) {
      const i = r.indexOf(s);
      r.splice(i, 1);
    }
    this.__addUnit(n);
  }
  get focused() {
    var n;
    const t = this._focused$.getValue();
    return t ? (n = this._getUnitById(t)) == null ? void 0 : n[0] : null;
  }
  focusUnit(t) {
    this._focused$.next(t), this.focused instanceof Ss ? (this._contextService.setContextValue(qr, true), this._contextService.setContextValue(Jr, false), this._contextService.setContextValue(_r, true), this._contextService.setContextValue(Zr, false), this.setCurrentUnitForType(t)) : this.focused instanceof Ft ? (this._contextService.setContextValue(qr, true), this._contextService.setContextValue(Jr, true), this._contextService.setContextValue(_r, false), this._contextService.setContextValue(Zr, false), this.setCurrentUnitForType(t)) : this.focused instanceof hc ? (this._contextService.setContextValue(qr, true), this._contextService.setContextValue(Jr, false), this._contextService.setContextValue(_r, false), this._contextService.setContextValue(Zr, true), this.setCurrentUnitForType(t)) : (this._contextService.setContextValue(qr, false), this._contextService.setContextValue(Jr, false), this._contextService.setContextValue(_r, false), this._contextService.setContextValue(Zr, false));
  }
  getFocusedUnit() {
    return this.focused;
  }
  getUnitType(t) {
    const n = this._getUnitById(t);
    return n ? n[1] : we.UNRECOGNIZED;
  }
  disposeUnit(t) {
    const n = this._getUnitById(t);
    if (!n) return false;
    const [r, s] = n, i = this._unitsByType.get(s), o = i.indexOf(r);
    return i.splice(o, 1), this._tryResetCurrentOnRemoval(t, s), this._tryResetFocusOnRemoval(t), this._unitDisposed$.next(r), true;
  }
  _tryResetCurrentOnRemoval(t, n) {
    const r = this.getCurrentUnitForType(n);
    (r == null ? void 0 : r.getUnitId()) === t && (this._currentUnits.set(n, null), this._currentUnits$.next(this._currentUnits));
  }
  _tryResetFocusOnRemoval(t) {
    var n;
    ((n = this.focused) == null ? void 0 : n.getUnitId()) === t && this._focused$.next(null);
  }
  _getUnitById(t) {
    for (const [n, r] of this._unitsByType) {
      const s = r.find((i) => i.getUnitId() === t);
      if (s)
        return [s, n];
    }
  }
};
Ki = ZE([
  Al(0, Inject(Injector)),
  Al(1, Tr)
], Ki);
var Pe = ((e) => (e[e.Starting = 0] = "Starting", e[e.Ready = 1] = "Ready", e[e.Rendered = 2] = "Rendered", e[e.Steady = 3] = "Steady", e))(Pe || {});
var dc = {
  0: "Starting",
  1: "Ready",
  2: "Rendered",
  3: "Steady"
};
var QE = Object.getOwnPropertyDescriptor;
var eC = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? QE(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
};
var tC = (e, t) => (n, r) => t(n, r, e);
var nC = class extends Error {
  constructor(t) {
    super(`[LifecycleService]: lifecycle stage "${dc[t]}" will never be reached!`), this.name = "LifecycleUnreachableError";
  }
};
var Yn = class extends Ve {
  constructor(t) {
    super();
    p(this, "_lifecycle$", new BehaviorSubject(Pe.Starting));
    p(this, "lifecycle$", this._lifecycle$.asObservable());
    p(this, "_lock", false);
    this._logService = t, this._reportProgress(Pe.Starting);
  }
  get stage() {
    return this._lifecycle$.getValue();
  }
  set stage(t) {
    if (this._lock) throw new Error("[LifecycleService]: cannot set new stage when related logic is all handled!");
    if (t < this.stage) throw new Error("[LifecycleService]: lifecycle stage cannot go backward!");
    t !== this.stage && (this._lock = true, this._reportProgress(t), this._lifecycle$.next(t), this._lock = false);
  }
  dispose() {
    this._lifecycle$.complete(), super.dispose();
  }
  /**
   * Wait for a specific lifecycle stage to be reached.
   * @param stage The lifecycle stage to wait for.
   * If the current stage is already at or beyond the specified stage, it will
   * resolve immediately.
   * If the specified stage is unreachable, it will reject with a
   * `LifecycleUnreachableError`.
   * @returns A promise that resolves when the specified stage is reached.
   */
  onStage(t) {
    return firstValueFrom(this.lifecycle$.pipe(
      filter((n) => n >= t),
      Pa((n) => n === t),
      map(() => {
      })
    )).catch((n) => n.name === "EmptyError" ? Promise.reject(new nC(t)) : Promise.reject(n));
  }
  /**
   * Subscribe to lifecycle changes and all previous stages and the current
   * stage will be emitted immediately.
   * @returns An observable that emits the lifecycle stages, including the current
   */
  subscribeWithPrevious() {
    return merge(fc(this.stage), this._lifecycle$.pipe(skip(1))).pipe(Pa((t) => t === Pe.Steady));
  }
  _reportProgress(t) {
    this._logService.debug("[LifecycleService]", `lifecycle progressed to "${dc[t]}".`);
  }
};
Yn = eC([
  tC(0, Nt)
], Yn);
function fc(e) {
  switch (e) {
    case Pe.Starting:
      return of(Pe.Starting);
    case Pe.Ready:
      return of(Pe.Starting, Pe.Ready);
    case Pe.Rendered:
      return of(Pe.Starting, Pe.Ready, Pe.Rendered);
    default:
      return of(
        Pe.Starting,
        Pe.Ready,
        Pe.Rendered,
        Pe.Steady
      );
  }
}
var rI = createIdentifier("ILocalStorageService");
var Hn = class extends Ve {
  constructor() {
    super();
    p(this, "_currentLocale$", new BehaviorSubject(Ts.ZH_CN));
    p(this, "currentLocale$", this._currentLocale$.asObservable());
    p(this, "_locales", null);
    p(this, "localeChanged$", new Subject());
    p(this, "t", (n, ...r) => {
      if (!this._locales) throw new Error("[LocaleService]: Locale not initialized");
      const s = n.split("."), i = this.resolveKeyPath(this._locales[this._currentLocale], s);
      if (typeof i == "string") {
        let o = i;
        return r.forEach((a, l) => {
          o = o.replace(`{${l}}`, a);
        }), o;
      } else
        return n;
    });
    this.disposeWithMe(Be(() => {
      this._locales = null, this._currentLocale$.complete(), this.localeChanged$.complete();
    }));
  }
  get _currentLocale() {
    return this._currentLocale$.value;
  }
  /**
   * Load more locales after init.
   *
   * @param locales - Locale object
   */
  load(n) {
    var r;
    this._locales = co((r = this._locales) != null ? r : {}, n);
  }
  setLocale(n) {
    this._currentLocale$.next(n), this.localeChanged$.next();
  }
  getLocales() {
    var n;
    return (n = this._locales) == null ? void 0 : n[this._currentLocale];
  }
  getCurrentLocale() {
    return this._currentLocale;
  }
  resolveKeyPath(n, r) {
    const s = r.shift();
    if (s && n && s in n) {
      const i = n[s];
      return r.length > 0 && (typeof i == "object" || Array.isArray(i)) ? this.resolveKeyPath(i, r) : i;
    }
    return null;
  }
};
var rC = Object.getOwnPropertyDescriptor;
var sC = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? rC(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
};
var iC = (e, t) => (n, r) => t(n, r, e);
var Xi = class {
  constructor(e) {
    this._userManagerService = e;
  }
  list(e) {
    return __async(this, null, function* () {
      return {
        list: [{
          type: Oi.PERSON,
          mentions: [
            {
              objectType: Oi.PERSON,
              objectId: this._userManagerService.getCurrentUser().userID,
              label: this._userManagerService.getCurrentUser().name,
              metadata: {
                icon: this._userManagerService.getCurrentUser().avatar
              }
            }
          ],
          metadata: {},
          title: "PEOPLE"
        }],
        page: e.page,
        size: e.size,
        total: 1
      };
    });
  }
};
Xi = sC([
  iC(0, Inject(Is))
], Xi);
var oC = createIdentifier("univer.service.mention-io");
var mc = ((e) => (e.INIT = "init", e.FETCHING = "fetching", e.DONE = "done", e))(mc || {});
var aC = createIdentifier("univer.permission-service");
var lC = class extends Ve {
  constructor() {
    super(...arguments);
    p(this, "_permissionPointMap", /* @__PURE__ */ new Map());
    p(this, "_permissionPointUpdate$", new Subject());
    p(this, "permissionPointUpdate$", this._permissionPointUpdate$.asObservable());
    p(this, "_showComponents", true);
  }
  setShowComponents(n) {
    this._showComponents = n;
  }
  getShowComponents() {
    return this._showComponents;
  }
  deletePermissionPoint(n) {
    const r = this._permissionPointMap.get(n);
    r && (r.complete(), this._permissionPointMap.delete(n));
  }
  addPermissionPoint(n) {
    const r = n instanceof BehaviorSubject, s = r ? n.getValue() : n;
    return s.id ? this._permissionPointMap.get(s.id) ? (console.warn(`${s.id} PermissionPoint already exists`), false) : (this._permissionPointMap.set(s.id, r ? n : new BehaviorSubject(s)), this._permissionPointUpdate$.next(s), true) : false;
  }
  updatePermissionPoint(n, r) {
    const s = this._permissionPointMap.get(n);
    if (!s)
      return;
    const i = s.getValue();
    i.value = r, i.status = mc.DONE, s.next(i), this._permissionPointUpdate$.next(i);
  }
  clearPermissionMap() {
    this._permissionPointMap.clear();
  }
  getPermissionPoint(n) {
    const r = this._permissionPointMap.get(n);
    if (r)
      return r.getValue();
  }
  getPermissionPoint$(n) {
    const r = this._permissionPointMap.get(n);
    if (r)
      return r;
  }
  composePermission$(n) {
    const r = n.map((s) => {
      var o;
      const i = (o = this._permissionPointMap) == null ? void 0 : o.get(s);
      if (!i)
        throw new Error(`[PermissionService]: ${s} permissionPoint does not exist!`);
      return i.asObservable();
    });
    return combineLatest(r).pipe(
      // Check that all permissions exist
      map((s) => s)
    );
  }
  composePermission(n) {
    return n.map((s) => {
      var o;
      const i = (o = this._permissionPointMap) == null ? void 0 : o.get(s);
      if (!i)
        throw new Error(`[PermissionService]: ${s} permissionPoint does not exist!`);
      return i.getValue();
    });
  }
  getAllPermissionPoint() {
    const n = /* @__PURE__ */ new Map();
    return this._permissionPointMap.forEach((r, s) => {
      n.set(s, r);
    }), n;
  }
};
function uC(e, t) {
  if (!t) return e;
  const n = [];
  for (const r of e) {
    const s = t.find(([i]) => i === r[0]);
    if (s) {
      if (s[1] === null) continue;
      n.push([r[0], s[1]]);
    } else
      n.push(r);
  }
  return n;
}
var cC = Object.getOwnPropertyDescriptor;
var hC = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? cC(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
};
var gi = (e, t) => (n, r) => t(n, r, e);
var dC = 4;
var gc = Symbol("DependentOn");
var yl = class extends Ve {
  onStarting() {
  }
  onReady() {
  }
  onRendered() {
  }
  onSteady() {
  }
  getUnitType() {
    return this.constructor.type;
  }
  getPluginName() {
    return this.constructor.pluginName;
  }
};
p(yl, "pluginName"), p(yl, "type", we.UNIVER_UNKNOWN);
var fC = class {
  constructor() {
    p(this, "_plugins", []);
  }
  addPlugin(t) {
    this._plugins.push(t);
  }
  removePlugins() {
    const t = this._plugins.slice();
    return this._plugins.length = 0, t;
  }
  forEachPlugin(t) {
    this._plugins.forEach(t);
  }
};
function sI(...e) {
  return function(t) {
    t[gc] = e;
  };
}
var Os = class {
  constructor(e, t, n) {
    p(this, "_pluginRegistry", /* @__PURE__ */ new Map());
    p(this, "_pluginStore", new fC());
    p(this, "_seenPlugins", /* @__PURE__ */ new Set());
    p(this, "_loadedPlugins", /* @__PURE__ */ new Set());
    p(this, "_loadedPluginTypes", /* @__PURE__ */ new Set([we.UNIVER_UNKNOWN]));
    p(this, "_flushTimerByType", /* @__PURE__ */ new Map());
    this._injector = e, this._lifecycleService = t, this._logService = n;
  }
  dispose() {
    this._pluginStore.removePlugins().forEach((e) => e.dispose()), this._flushTimerByType.forEach((e) => clearTimeout(e));
  }
  /**
   * Register a plugin into univer.
   * @param {PluginCtor} ctor The plugin's constructor.
   * @param {ConstructorParameters} [config] The configuration for the plugin.
   */
  registerPlugin(e, t) {
    this._assertPluginValid(e);
    const n = { plugin: e, options: t };
    this._pluginRegistry.set(e.pluginName, n), this._logService.debug("[PluginService]", `Plugin "${e.pluginName}" registered.`);
    const { type: r } = e;
    this._loadedPluginTypes.has(r) && (r === we.UNIVER_UNKNOWN ? this._loadFromPlugins([n]) : this._flushType(r));
  }
  startPluginsForType(e) {
    this._loadedPluginTypes.has(e) || this._loadPluginsForType(e);
  }
  _loadPluginsForType(e) {
    const t = Array.from(this._pluginRegistry.keys()), n = [];
    t.forEach((r) => {
      const s = this._pluginRegistry.get(r);
      s.plugin.type === e && n.push(s);
    }), this._loadFromPlugins(n), this._loadedPluginTypes.add(e);
  }
  _assertPluginValid(e) {
    const { type: t, pluginName: n } = e;
    if (t === we.UNRECOGNIZED)
      throw new Error(`[PluginService]: invalid plugin type for ${e.name}. Please assign a "type" to your plugin.`);
    if (!n)
      throw new Error(`[PluginService]: no plugin name for ${e.name}. Please assign a "pluginName" to your plugin.`);
    if (this._seenPlugins.has(n))
      throw new Error(`[PluginService]: duplicated plugin name for "${n}". Maybe a plugin that dependents on "${n} has already registered it. In that case please register "${n}" before the that plugin.`);
    this._seenPlugins.add(e.pluginName);
  }
  _flushType(e) {
    this._flushTimerByType.get(e) === void 0 && this._flushTimerByType.set(e, setTimeout(() => {
      this._loadPluginsForType(e), this._flushTimerByType.delete(e);
    }, dC));
  }
  _loadFromPlugins(e) {
    const t = [], n = /* @__PURE__ */ new Set(), r = (i) => {
      const { plugin: o } = i, { pluginName: a } = o;
      if (this._loadedPlugins.has(a) || n.has(a))
        return;
      n.add(a), this._pluginRegistry.delete(a);
      const l = o[gc];
      l && l.forEach((u) => {
        const c = this._pluginRegistry.get(u.pluginName);
        if (c)
          r(c);
        else if (!this._seenPlugins.has(u.pluginName) && !n.has(u.pluginName)) {
          if (o.type === we.UNIVER_UNKNOWN && u.type !== we.UNIVER_UNKNOWN)
            throw new Error(
              `[PluginService]: cannot register a plugin with Univer type that depends on a plugin with other type. The dependent is ${o.pluginName} and the dependency is ${u.pluginName}.`
            );
          o.type !== u.type && u.type !== we.UNIVER_UNKNOWN && this._logService.debug(
            "[PluginService]",
            `Plugin "${a}" depends on "${u.pluginName}" which has different type.`
          ), this._logService.debug(
            "[PluginService]",
            `Plugin "${a}" depends on "${u.pluginName}" which is not registered. Univer will automatically register it with default configuration.`
          ), this._assertPluginValid(u), r({ plugin: u, options: void 0 });
        }
      }), t.push(i);
    };
    e.forEach((i) => r(i));
    const s = t.map((i) => this._initPlugin(i.plugin, i.options));
    this._pluginsRunLifecycle(s);
  }
  _pluginsRunLifecycle(e) {
    const t = this._lifecycleService.stage;
    if (fc(t).subscribe((n) => this._runStage(e, n)), t !== Pe.Steady) {
      const n = this._lifecycleService.lifecycle$.pipe(
        skip(1)
      ).subscribe((r) => {
        this._runStage(e, r), r === Pe.Steady && n.unsubscribe();
      });
    }
  }
  _runStage(e, t) {
    e.forEach((n) => {
      switch (t) {
        case Pe.Starting:
          n.onStarting();
          break;
        case Pe.Ready:
          n.onReady();
          break;
        case Pe.Rendered:
          n.onRendered();
          break;
        case Pe.Steady:
          n.onSteady();
          break;
      }
    });
  }
  _initPlugin(e, t) {
    const n = this._injector.createInstance(e, t);
    return this._pluginStore.addPlugin(n), this._loadedPlugins.add(e.pluginName), this._logService.debug("[PluginService]", `Plugin "${n.getPluginName()}" loaded.`), n;
  }
};
Os = hC([
  gi(0, Inject(Injector)),
  gi(1, Inject(Yn)),
  gi(2, Nt)
], Os);
var Nl = createIdentifier("resource-loader-service");
var mC = Object.getOwnPropertyDescriptor;
var gC = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? mC(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
};
var _C = (e, t) => (n, r) => t(n, r, e);
var qi = class extends Ve {
  constructor(t) {
    super();
    p(this, "_resourceMap", /* @__PURE__ */ new Map());
    p(this, "_register$", new Subject());
    p(this, "register$", this._register$.asObservable());
    this._logService = t;
  }
  getAllResourceHooks() {
    return [...this._resourceMap.values()];
  }
  getResources(t, n) {
    return n ? this.getResourcesByType(t, n) : this.getAllResourceHooks().map((i) => {
      const o = i.toJson(t);
      return {
        name: i.pluginName,
        data: o
      };
    });
  }
  getResourcesByType(t, n) {
    return this.getAllResourceHooks().filter((i) => i.businesses.includes(n)).map((i) => {
      const o = i.toJson(t);
      return {
        name: i.pluginName,
        data: o
      };
    });
  }
  registerPluginResource(t) {
    const n = t.pluginName;
    if (this._resourceMap.has(n))
      throw new Error(`the pluginName is registered {${n}}`);
    return this._resourceMap.set(n, t), this._register$.next(t), Be(() => this._resourceMap.delete(n));
  }
  disposePluginResource(t) {
    this._resourceMap.delete(t);
  }
  loadResources(t, n) {
    this.getAllResourceHooks().forEach((r) => {
      var i;
      const s = (i = n == null ? void 0 : n.find((o) => o.name === r.pluginName)) == null ? void 0 : i.data;
      if (s)
        try {
          const o = r.parseJson(s);
          r.onLoad(t, o);
        } catch (o) {
          this._logService.error("[ResourceManagerService]", "loadResources error", o);
        }
    });
  }
  unloadResources(t, n) {
    this.getAllResourceHooks().filter((r) => r.businesses.includes(n)).forEach((r) => {
      r.onUnLoad(t);
    });
  }
  dispose() {
    this._register$.complete(), this._resourceMap.clear();
  }
};
qi = gC([
  _C(0, Nt)
], qi);
var Ji = class extends Ve {
  constructor() {
    super();
    p(this, "_darkMode$", new BehaviorSubject(false));
    p(this, "darkMode$", this._darkMode$.asObservable());
    p(this, "_validColorCache", /* @__PURE__ */ new Map());
    p(this, "_currentTheme", F);
    p(this, "_currentTheme$", new BehaviorSubject(this._currentTheme));
    p(this, "currentTheme$", this._currentTheme$.asObservable());
    this.disposeWithMe(Be(() => {
      this._currentTheme = F, this._currentTheme$.complete(), this._darkMode$.complete();
    }));
  }
  get darkMode() {
    return this._darkMode$.getValue();
  }
  /**
   * Whether the given color is a valid theme color.
   * A valid theme color can be a direct key in the theme object or a nested key with a dot notation.
   * For example:
   * @param {string} color - The color string to validate.
   * @returns {boolean} True if the color is valid, false otherwise.
   * @example
   * isValidThemeColor('primary.600'); // true
   * isValidThemeColor('blue'); // false
   */
  isValidThemeColor(n) {
    if (this._validColorCache.has(n))
      return this._validColorCache.get(n);
    let r = false;
    const s = n.split(".");
    if (s.length === 1)
      r = n in F;
    else if (s.length === 2) {
      const [i, o] = s;
      r = i in F && o in this._currentTheme[i];
    }
    return this._validColorCache.set(n, r), r;
  }
  /**
   * Get the current theme.
   * @returns The current theme.
   */
  getCurrentTheme() {
    return this._currentTheme;
  }
  /**
   * Set the current theme.
   * @param theme - The new theme to set.
   */
  setTheme(n) {
    this._currentTheme = n, this._currentTheme$.next(n);
  }
  /**
   * Get the current theme as an observable.
   * @param {boolean} darkMode - Whether to set the theme in dark mode.
   */
  setDarkMode(n) {
    this._darkMode$.next(n);
  }
  /**
   * Get a color from the current theme.
   * @param {string} color - The color key to retrieve.
   * @returns {string} The color value from the current theme.
   */
  getColorFromTheme(n) {
    return yf(this._currentTheme, n);
  }
};
var pC = Object.getOwnPropertyDescriptor;
var EC = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? pC(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
};
var _i = (e, t) => (n, r) => t(n, r, e);
var ra = createIdentifier("univer.undo-redo.service");
var CC = 20;
var _c = class {
  dispose() {
  }
  dispatchToHandlers() {
    return __async(this, null, function* () {
      return false;
    });
  }
};
var RC = "univer.command.redo";
var IC = "univer.command.undo";
var wC = new class extends _c {
  constructor() {
    super(...arguments);
    p(this, "type", Ls.COMMAND);
    p(this, "id", IC);
  }
  handler(t) {
    const n = t.get(ra), r = n.pitchTopUndoElement();
    if (!r)
      return false;
    const s = t.get(Ds);
    return po(r.undoMutations, s) ? (n.popUndoToRedo(), true) : false;
  }
}();
var SC = new class extends _c {
  constructor() {
    super(...arguments);
    p(this, "type", Ls.COMMAND);
    p(this, "id", RC);
  }
  handler(t) {
    const n = t.get(ra), r = n.pitchTopRedoElement();
    if (!r)
      return false;
    const s = t.get(Ds);
    return po(r.redoMutations, s) ? (n.popRedoToUndo(), true) : false;
  }
}();
var Zi = class extends Ve {
  constructor(t, n, r) {
    super();
    p(this, "undoRedoStatus$");
    p(this, "_undoRedoStatus$", new BehaviorSubject({ undos: 0, redos: 0 }));
    p(this, "_undoStacks", /* @__PURE__ */ new Map());
    p(this, "_redoStacks", /* @__PURE__ */ new Map());
    p(this, "_batchingStatus", /* @__PURE__ */ new Map());
    this._univerInstanceService = t, this._commandService = n, this._contextService = r, this.undoRedoStatus$ = this._undoRedoStatus$.asObservable(), this.disposeWithMe(this._commandService.registerCommand(wC)), this.disposeWithMe(this._commandService.registerCommand(SC)), this.disposeWithMe(Be(() => this._undoRedoStatus$.complete())), this.disposeWithMe(Be(this._univerInstanceService.focused$.subscribe(() => this._updateStatus())));
  }
  pushUndoRedo(t) {
    const { unitID: n } = t, r = this._getRedoStack(n, true), s = this._getUndoStack(n, true);
    if (r.length = 0, this._batchingStatus.has(t.unitID)) {
      const o = this._batchingStatus.get(t.unitID), a = this._pitchUndoElement(t.unitID);
      o === 0 || !a ? (i(t), this._batchingStatus.set(
        t.unitID,
        1
        /* CREATED */
      )) : this._tryBatchingElements(a, t);
    } else
      i(t);
    function i(o) {
      s.push(o), s.length > CC && s.splice(0, 1);
    }
    this._updateStatus();
  }
  clearUndoRedo(t) {
    const n = this._getRedoStack(t);
    n && (n.length = 0);
    const r = this._getUndoStack(t);
    r && (r.length = 0), this._updateStatus();
  }
  pitchTopUndoElement() {
    const t = this._getFocusedUnitId();
    return this._pitchUndoElement(t);
  }
  pitchTopRedoElement() {
    const t = this._getFocusedUnitId();
    return this._pitchRedoElement(t);
  }
  _pitchUndoElement(t) {
    const n = this._getUndoStack(t);
    return n != null && n.length ? n[n.length - 1] : null;
  }
  _pitchRedoElement(t) {
    const n = this._getRedoStack(t);
    return n != null && n.length ? n[n.length - 1] : null;
  }
  popUndoToRedo() {
    const n = this._getUndoStackForFocused().pop();
    n && (n.redoMutations.length > 0 && this._getRedoStackForFocused().push(n), this._updateStatus());
  }
  popRedoToUndo() {
    const n = this._getRedoStackForFocused().pop();
    n && (this._getUndoStackForFocused().push(n), this._updateStatus());
  }
  rollback(t, n) {
    const r = n || this._getFocusedUnitId(), s = this._getUndoStack(r), i = s == null ? void 0 : s[(s == null ? void 0 : s.length) - 1];
    i && i.id === t && (s.pop(), po(i.undoMutations, this._commandService));
  }
  __tempBatchingUndoRedo(t) {
    if (this._batchingStatus.has(t))
      throw new Error("[LocalUndoRedoService]: cannot batching undo redo twice at the same time!");
    return this._batchingStatus.set(
      t,
      0
      /* WAITING */
    ), Be(() => this._batchingStatus.delete(t));
  }
  _updateStatus() {
    var s, i;
    const t = this._getFocusedUnitId(), n = t && ((s = this._undoStacks.get(t)) == null ? void 0 : s.length) || 0, r = t && ((i = this._redoStacks.get(t)) == null ? void 0 : i.length) || 0;
    this._undoRedoStatus$.next({
      undos: n,
      redos: r
    });
  }
  _getUndoStack(t, n = false) {
    let r = this._undoStacks.get(t);
    return !r && n && (r = [], this._undoStacks.set(t, r)), r || null;
  }
  _getRedoStack(t, n = false) {
    let r = this._redoStacks.get(t);
    return !r && n && (r = [], this._redoStacks.set(t, r)), r || null;
  }
  _getUndoStackForFocused() {
    const t = this._getFocusedUnitId();
    if (!t)
      throw new Error("No focused univer instance!");
    return this._getUndoStack(t, true);
  }
  _getRedoStackForFocused() {
    const t = this._getFocusedUnitId();
    if (!t)
      throw new Error("No focused univer instance!");
    return this._getRedoStack(t, true);
  }
  _tryBatchingElements(t, n) {
    t.redoMutations.push(...n.redoMutations), t.undoMutations.push(...n.undoMutations);
  }
  _getFocusedUnitId() {
    var i, o, a, l;
    let t = "";
    const n = this._contextService.getContextValue(_r), r = this._contextService.getContextValue(EE), s = this._contextService.getContextValue(pE);
    return n ? r ? t = Hl : s ? t = Fl : t = (o = (i = this._univerInstanceService.getFocusedUnit()) == null ? void 0 : i.getUnitId()) != null ? o : "" : t = (l = (a = this._univerInstanceService.getFocusedUnit()) == null ? void 0 : a.getUnitId()) != null ? l : "", t;
  }
};
Zi = EC([
  _i(0, br),
  _i(1, Ds),
  _i(2, Tr)
], Zi);
var OC = class {
  constructor(t, n = 100) {
    p(this, "_imageCacheMap");
    this._injector = t, this._imageCacheMap = new _s(n);
  }
  _getImageCacheKey(t, n) {
    return `${t}-${n}`;
  }
  getImage(t, n, r, s) {
    const i = this._getImageCacheKey(t, n), o = this._imageCacheMap.get(i);
    return o || ((() => __async(this, null, function* () {
      const a = new Image(), l = this._injector.has(Il) ? this._injector.get(Il) : null;
      if (t === uc.UUID)
        try {
          a.src = (yield l == null ? void 0 : l.getImage(n)) || "";
        } catch (u) {
          console.error(u);
        }
      else
        a.src = n;
      a.onload = () => {
        a.removeAttribute("data-error"), r == null || r();
      }, a.onerror = () => {
        a.setAttribute("data-error", "true"), s == null || s();
      }, this._imageCacheMap.set(i, a);
    }))(), null);
  }
};
function iI(e) {
  return !(e.length === 0 || e.length > 31 || e.startsWith("'") || e.endsWith("'") || /[:\\\/\?\*\[\]]/.test(e));
}
function oI(e, t) {
  return !(!e || e.length === 0 || e.length > 255 || t.has(e) || /[ :\\\/\?\*\[\]]/.test(e) || !/^[\p{L}_]/u.test(e) || /^\$?[A-Za-z]{1,3}\$?[0-9]+$/.test(e) || /^[rR]\d+[cC]\d+$/.test(e) || /^\d+$/.test(e));
}
var Tl = [
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
];
var pi = 1;
var nr = 8;
var sa = class _sa {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    const [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    const s = r >> 4;
    if (s !== pi)
      throw new Error(`Got v${s} data when expected v${pi}.`);
    const i = Tl[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    const [o] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new _sa(a, o, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t, n = 64, r = Float64Array, s) {
    if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    const i = Tl.indexOf(this.ArrayType), o = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error(`Unexpected typed array class: ${r}.`);
    s && s instanceof ArrayBuffer ? (this.data = s, this.ids = new this.IndexArrayType(this.data, nr, t), this.coords = new this.ArrayType(this.data, nr + a + l, t * 2), this._pos = t * 2, this._finished = true) : (this.data = new ArrayBuffer(nr + o + a + l), this.ids = new this.IndexArrayType(this.data, nr, t), this.coords = new this.ArrayType(this.data, nr + a + l, t * 2), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, (pi << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    const r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    const t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error(`Added ${t} items when expected ${this.numItems}.`);
    return Qi(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, s) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: i, coords: o, nodeSize: a } = this, l = [0, i.length - 1, 0], u = [];
    for (; l.length; ) {
      const c = l.pop() || 0, h = l.pop() || 0, d = l.pop() || 0;
      if (h - d <= a) {
        for (let R = d; R <= h; R++) {
          const b = o[2 * R], $ = o[2 * R + 1];
          b >= t && b <= r && $ >= n && $ <= s && u.push(i[R]);
        }
        continue;
      }
      const f = d + h >> 1, g = o[2 * f], _ = o[2 * f + 1];
      g >= t && g <= r && _ >= n && _ <= s && u.push(i[f]), (c === 0 ? t <= g : n <= _) && (l.push(d), l.push(f - 1), l.push(1 - c)), (c === 0 ? r >= g : s >= _) && (l.push(f + 1), l.push(h), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: s, coords: i, nodeSize: o } = this, a = [0, s.length - 1, 0], l = [], u = r * r;
    for (; a.length; ) {
      const c = a.pop() || 0, h = a.pop() || 0, d = a.pop() || 0;
      if (h - d <= o) {
        for (let R = d; R <= h; R++)
          Ml(i[2 * R], i[2 * R + 1], t, n) <= u && l.push(s[R]);
        continue;
      }
      const f = d + h >> 1, g = i[2 * f], _ = i[2 * f + 1];
      Ml(g, _, t, n) <= u && l.push(s[f]), (c === 0 ? t - r <= g : n - r <= _) && (a.push(d), a.push(f - 1), a.push(1 - c)), (c === 0 ? t + r >= g : n + r >= _) && (a.push(f + 1), a.push(h), a.push(1 - c));
    }
    return l;
  }
};
function Qi(e, t, n, r, s, i) {
  if (s - r <= n) return;
  const o = r + s >> 1;
  pc(e, t, o, r, s, i), Qi(e, t, n, r, o - 1, 1 - i), Qi(e, t, n, o + 1, s, 1 - i);
}
function pc(e, t, n, r, s, i) {
  for (; s > r; ) {
    if (s - r > 600) {
      const u = s - r + 1, c = n - r + 1, h = Math.log(u), d = 0.5 * Math.exp(2 * h / 3), f = 0.5 * Math.sqrt(h * d * (u - d) / u) * (c - u / 2 < 0 ? -1 : 1), g = Math.max(r, Math.floor(n - c * d / u + f)), _ = Math.min(s, Math.floor(n + (u - c) * d / u + f));
      pc(e, t, n, g, _, i);
    }
    const o = t[2 * n + i];
    let a = r, l = s;
    for (rr(e, t, r, n), t[2 * s + i] > o && rr(e, t, r, s); a < l; ) {
      for (rr(e, t, a, l), a++, l--; t[2 * a + i] < o; ) a++;
      for (; t[2 * l + i] > o; ) l--;
    }
    t[2 * r + i] === o ? rr(e, t, r, l) : (l++, rr(e, t, l, s)), l <= n && (r = l + 1), n <= l && (s = l - 1);
  }
}
function rr(e, t, n, r) {
  Ei(e, n, r), Ei(t, 2 * n, 2 * r), Ei(t, 2 * n + 1, 2 * r + 1);
}
function Ei(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function Ml(e, t, n, r) {
  const s = e - n, i = t - r;
  return s * s + i * i;
}
var aI = class {
  constructor(t = false) {
    p(this, "_tree", /* @__PURE__ */ new Map());
    p(this, "_oneCellCache", /* @__PURE__ */ new Map());
    p(this, "_kdTree", /* @__PURE__ */ new Map());
    this._enableOneCellCache = t;
  }
  dispose() {
    this.clear();
  }
  getTree(t, n) {
    return this._tree.has(t) || this._tree.set(t, /* @__PURE__ */ new Map()), this._tree.get(t).has(n) || this._tree.get(t).set(n, new Fi()), this._tree.get(t).get(n);
  }
  _getOneCellCache(t, n, r, s) {
    return this._oneCellCache.has(t) || this._oneCellCache.set(t, /* @__PURE__ */ new Map()), this._oneCellCache.get(t).has(n) || this._oneCellCache.get(t).set(n, /* @__PURE__ */ new Map()), this._oneCellCache.get(t).get(n).has(r) || this._oneCellCache.get(t).get(n).set(r, /* @__PURE__ */ new Map()), this._oneCellCache.get(t).get(n).get(r).has(s) || this._oneCellCache.get(t).get(n).get(r).set(s, /* @__PURE__ */ new Set()), this._oneCellCache.get(t).get(n).get(r).get(s);
  }
  _removeOneCellCache(t, n, r, s, i) {
    const o = this._oneCellCache.get(t);
    if (!o) return;
    const a = o.get(n);
    if (!a) return;
    const l = a.get(r);
    if (!l) return;
    const u = l.get(s);
    u && u.delete(i);
  }
  _removeCellCacheByRange(t) {
    const { unitId: n, sheetId: r, range: s, id: i } = t, o = this._oneCellCache.get(n);
    if (!o) return;
    const a = o.get(r);
    if (!a) return;
    const { startRow: l, startColumn: u, endRow: c, endColumn: h } = s;
    for (let d = l; d <= c; d++) {
      const f = a.get(d);
      if (f)
        for (let g = u; g <= h; g++) {
          const _ = f.get(g);
          _ && _.delete(i);
        }
    }
  }
  _insertOneCellCache(t, n, r, s, i) {
    this._getOneCellCache(t, n, r, s).add(i);
  }
  _getRdTreeItems(t) {
    const n = [];
    for (const [r, s] of t)
      for (const [i, o] of s)
        n.push({
          x: i,
          y: r,
          ids: o
        });
    return n;
  }
  _searchByOneCellCache(t) {
    var g;
    const { unitId: n, sheetId: r, range: s } = t, { startRow: i, startColumn: o, endRow: a, endColumn: l } = s, u = (g = this._kdTree.get(n)) == null ? void 0 : g.get(r);
    if (!u)
      return [];
    const { tree: c, items: h } = u, d = c.range(o, i, l, a), f = [];
    for (const _ of d) {
      const R = h[_];
      f.push(...Array.from(R.ids));
    }
    return f;
  }
  /**
   * Open the kd-tree search state.
   * The kd-tree is used to search for data in a single cell.
   */
  openKdTree() {
    var t;
    for (const [n, r] of this._oneCellCache) {
      this._kdTree.has(n) || this._kdTree.set(n, /* @__PURE__ */ new Map());
      for (const [s, i] of r) {
        const o = this._getRdTreeItems(i), a = new sa(o.length);
        (t = this._kdTree.get(n)) == null || t.set(s, {
          tree: a,
          items: o
        });
        for (const l of o)
          a.add(l.x, l.y);
        a.finish();
      }
    }
  }
  closeKdTree() {
    var t;
    for (const [n, r] of this._oneCellCache)
      for (const [s, i] of r)
        (t = this._kdTree.get(n)) == null || t.set(s, void 0);
  }
  insert(t) {
    const { unitId: n, sheetId: r, range: s, id: i } = t;
    if (!n || n.length === 0)
      return;
    let { startRow: o, endRow: a, startColumn: l, endColumn: u } = s;
    if (this._enableOneCellCache && o === a && l === u) {
      this._insertOneCellCache(n, r, o, l, i);
      return;
    }
    const c = this.getTree(n, r);
    Number.isNaN(o) && (o = 0), Number.isNaN(l) && (l = 0), Number.isNaN(a) && (a = Number.POSITIVE_INFINITY), Number.isNaN(u) && (u = Number.POSITIVE_INFINITY), c.insert({
      minX: l,
      minY: o,
      maxX: u,
      maxY: a,
      id: i
    });
  }
  bulkInsert(t) {
    for (const n of t)
      this.insert(n);
  }
  *searchGenerator(t) {
    var a;
    const { unitId: n, sheetId: r, range: s } = t;
    if (this._enableOneCellCache) {
      const l = this._searchByOneCellCache(t);
      for (const u of l)
        yield u;
    }
    const i = (a = this._tree.get(n)) == null ? void 0 : a.get(r);
    if (!i)
      return;
    const o = i.search({
      minX: s.startColumn,
      minY: s.startRow,
      maxX: s.endColumn,
      maxY: s.endRow
    });
    for (const l of o)
      yield l.id;
  }
  bulkSearch(t, n) {
    const r = /* @__PURE__ */ new Set();
    for (const s of t)
      for (const i of this.searchGenerator(s))
        (n == null ? void 0 : n.has(i)) !== true && r.add(i);
    return r;
  }
  removeById(t, n) {
    var r, s;
    n ? ((r = this._tree.get(t)) == null || r.delete(n), (s = this._oneCellCache.get(t)) == null || s.delete(n)) : (this._tree.delete(t), this._oneCellCache.delete(t));
  }
  _removeRTreeItem(t) {
    const { unitId: n, sheetId: r, range: s, id: i } = t, o = this.getTree(n, r), a = o.search({
      minX: s.startColumn,
      minY: s.startRow,
      maxX: s.endColumn,
      maxY: s.endRow
    });
    for (let l = 0; l < a.length; l++)
      a[l].id === i && o.remove(a[l]);
  }
  remove(t) {
    const { unitId: n, sheetId: r, range: s, id: i } = t, { startRow: o, startColumn: a, endRow: l, endColumn: u } = s;
    this._enableOneCellCache ? o === l && a === u ? this._removeOneCellCache(n, r, s.startRow, s.startColumn, i) : (this._removeCellCacheByRange(t), this._removeRTreeItem(t)) : this._removeRTreeItem(t);
  }
  bulkRemove(t) {
    for (const n of t)
      this.remove(n);
  }
  clear() {
    this._tree.clear(), this._oneCellCache.clear();
  }
  toJSON() {
    const t = {};
    return this._tree.forEach((n, r) => {
      t[r] = {}, n.forEach((s, i) => {
        t[r][i] = s.toJSON();
      });
    }), t;
  }
  fromJSON(t) {
    this._tree.clear();
    for (const n in t) {
      this._tree.set(n, /* @__PURE__ */ new Map());
      for (const r in t[n]) {
        const s = new Fi();
        s.fromJSON(t[n][r]), this._tree.get(n).set(r, s);
      }
    }
  }
};
function lI(e) {
  return new Promise((t) => setTimeout(t, e));
}
function uI(e = 1) {
  return new Promise((t) => {
    let n = 0;
    const r = () => {
      n++, n >= e ? t() : requestAnimationFrame(r);
    };
    requestAnimationFrame(r);
  });
}
var vC = Object.getOwnPropertyDescriptor;
var bC = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? vC(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
};
var AC = (e, t) => (n, r) => t(n, r, e);
var eo = class extends Ve {
  constructor(t) {
    super();
    p(this, "_fontLocale");
    p(this, "_dirty", true);
    this._localeService = t, this._localeInitial();
  }
  get dirty() {
    return this._dirty;
  }
  getFontLocale() {
    return this._fontLocale;
  }
  makeDirty(t) {
    this._dirty = t;
  }
  dispose() {
    super.dispose(), this._fontLocale = null;
  }
  _localeInitial() {
  }
};
eo = bC([
  AC(0, Inject(Hn))
], eo);
var yC = Object.getOwnPropertyDescriptor;
var NC = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? yC(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
};
var es = (e, t) => (n, r) => t(n, r, e);
var xl = class extends eo {
  constructor(t, n, r, s, i, o) {
    super(r);
    p(this, "_worksheetData");
    p(this, "_renderRawFormula", false);
    p(this, "_cellData");
    p(this, "_imageCacheMap");
    p(this, "_skipAutoHeightForMergedCells", true);
    p(this, "_rowTotalHeight", 0);
    p(this, "_columnTotalWidth", 0);
    p(this, "_rowHeaderWidth", 0);
    p(this, "_columnHeaderHeight", 0);
    p(this, "_rowHeightAccumulation", []);
    p(this, "_columnWidthAccumulation", []);
    p(this, "_marginTop", 0);
    p(this, "_marginLeft", 0);
    p(this, "_scaleX");
    p(this, "_scaleY");
    p(this, "_scrollX");
    p(this, "_scrollY");
    this.worksheet = t, this._styles = n, this._contextService = s, this._configService = i, this._injector = o, this._worksheetData = this.worksheet.getConfig(), this._cellData = this.worksheet.getCellMatrix(), this._imageCacheMap = new OC(this._injector), this.initConfig();
  }
  initConfig() {
    var t, n;
    this._skipAutoHeightForMergedCells = !((t = this._configService.getConfig(Vc)) != null && t), this.worksheet.setIsRowStylePrecedeColumnStyle((n = this._configService.getConfig(zc)) != null ? n : false);
  }
  resetCache() {
  }
  /**
   * @deprecated should never expose a property that is provided by another module!
   */
  getWorksheetConfig() {
    return this._worksheetData;
  }
  /**
   * Get which Workbook and Worksheet this skeleton is attached to.
   * @returns [unitId, sheetId]
   */
  getLocation() {
    return [this.worksheet.getUnitId(), this.worksheet.getSheetId()];
  }
  set columnHeaderHeight(t) {
    this._columnHeaderHeight = t, this._worksheetData.columnHeader.height = t;
  }
  set rowHeaderWidth(t) {
    this._rowHeaderWidth = t, this._worksheetData.rowHeader.width = t;
  }
  get rowHeightAccumulation() {
    return this._rowHeightAccumulation;
  }
  get rowTotalHeight() {
    return this._rowTotalHeight;
  }
  get columnWidthAccumulation() {
    return this._columnWidthAccumulation;
  }
  get columnTotalWidth() {
    return this._columnTotalWidth;
  }
  get rowHeaderWidth() {
    return this._rowHeaderWidth;
  }
  get columnHeaderHeight() {
    return this._columnHeaderHeight;
  }
  setMarginLeft(t) {
    this._marginLeft = t;
  }
  setMarginTop(t) {
    this._marginTop = t;
  }
  setScale(t, n) {
    this._updateLayout(), this._scaleX = t, this._scaleY = n || t, this._updateLayout();
  }
  setScroll(t, n) {
    Z.isDefine(t) && (this._scrollX = t), Z.isDefine(n) && (this._scrollY = n);
  }
  get scrollX() {
    return this._scrollX;
  }
  get scrollY() {
    return this._scrollY;
  }
  get scaleX() {
    return this._scaleX;
  }
  get scaleY() {
    return this._scaleY;
  }
  get rowHeaderWidthAndMarginLeft() {
    return this.rowHeaderWidth + this._marginLeft;
  }
  get columnHeaderHeightAndMarginTop() {
    return this.columnHeaderHeight + this._marginTop;
  }
  get imageCacheMap() {
    return this._imageCacheMap;
  }
  _generateRowMatrixCache(t, n, r) {
    let s = 0;
    const i = [], o = n;
    for (let a = 0; a < t; a++) {
      let l = r;
      if (this.worksheet.getRowFiltered(a))
        l = 0;
      else if (o[a] != null) {
        const u = o[a];
        if (!u)
          continue;
        const { h: c = r, ah: h, ia: d } = u;
        (d == null || d === ie.TRUE) && typeof h == "number" ? l = h : l = c, u.hd === ie.TRUE && (l = 0);
      }
      s += l, i.push(s);
    }
    return {
      rowTotalHeight: s,
      rowHeightAccumulation: i
    };
  }
  /**
   * Calc columnWidthAccumulation by columnData
   * @param colCount
   * @param columnData
   * @param defaultColumnWidth
   */
  _generateColumnMatrixCache(t, n, r) {
    let s = 0;
    const i = [], o = n;
    for (let a = 0; a < t; a++) {
      let l = r;
      if (o[a] != null) {
        const u = o[a];
        if (!u)
          continue;
        u.w != null && (l = u.w), u.hd === ie.TRUE && (l = 0);
      }
      s += l, i.push(s);
    }
    return {
      columnTotalWidth: s,
      columnWidthAccumulation: i
    };
  }
  intersectMergeRange(t, n) {
    return !!this.worksheet.getMergedCell(t, n);
  }
  //eslint-disable-next-line complexity
  _getOverflowBound(t, n, r, s, i = Pt.LEFT) {
    let o = 0;
    if (n > r) {
      const a = this._columnWidthAccumulation.length - 1;
      for (let l = n; l >= r; l--) {
        const u = l, c = this.worksheet.getCell(t, u);
        if (!Ba(c) && u !== n || this.intersectMergeRange(t, u))
          return u === n ? u : u + 1 > a ? a : u + 1;
        const { startX: h, endX: d } = sr(
          t,
          u,
          this.rowHeightAccumulation,
          this.columnWidthAccumulation
        );
        if (i === Pt.CENTER && u === n ? o += (d - h) / 2 : o += d - h, s < o)
          return u;
      }
      return n;
    }
    for (let a = n; a <= r; a++) {
      const l = a, u = this.worksheet.getCell(t, l);
      if (!Ba(u) && l !== n || this.intersectMergeRange(t, l))
        return l === n ? l : l - 1 < 0 ? 0 : l - 1;
      const { startX: c, endX: h } = sr(
        t,
        l,
        this.rowHeightAccumulation,
        this.columnWidthAccumulation
      );
      if (i === Pt.CENTER && l === n ? o += (h - c) / 2 : o += h - c, s < o)
        return l;
    }
    return r;
  }
  /**
   * Calculate data for row col & cell position.
   * This method should be called whenever a sheet is dirty.
   * Update position value to this._rowHeaderWidth & this._rowHeightAccumulation & this._columnHeaderHeight & this._columnWidthAccumulation.
   */
  _updateLayout() {
    if (!this.dirty)
      return;
    const {
      rowData: t,
      columnData: n,
      defaultRowHeight: r,
      defaultColumnWidth: s,
      rowCount: i,
      columnCount: o,
      rowHeader: a,
      columnHeader: l
    } = this._worksheetData, { rowTotalHeight: u, rowHeightAccumulation: c } = this._generateRowMatrixCache(i, t, r), { columnTotalWidth: h, columnWidthAccumulation: d } = this._generateColumnMatrixCache(
      o,
      n,
      s
    );
    this._rowHeaderWidth = a.hidden !== ie.TRUE ? this._dynamicallyUpdateRowHeaderWidth(a) : 0, this._columnHeaderHeight = l.hidden !== ie.TRUE ? l.height : 0, this._rowTotalHeight = u, this._rowHeightAccumulation = c, this._columnTotalWidth = h, this._columnWidthAccumulation = d, this.makeDirty(false);
  }
  /**
   * Refresh cache after markDirty by SheetSkeletonManagerService.reCalculate()
   * @param bounds
   */
  calculate() {
    return this.resetCache(), this._updateLayout(), this;
  }
  resetRangeCache(t) {
  }
  _dynamicallyUpdateRowHeaderWidth(t) {
    const r = `${this.worksheet.getRowCount()}`.length * 8;
    return Math.max(t.width, r);
  }
  _hasUnMergedCellInRow(t, n, r) {
    if (!this.worksheet.getMergeData())
      return false;
    for (let i = n; i <= r; i++) {
      const { isMerged: o, isMergedMainCell: a } = this.worksheet.getCellInfoInMergeData(t, i);
      if (!o && !a)
        return true;
    }
    return false;
  }
  /**
   * expand curr range if it's intersect with merge range.
   * @param range
   * @returns {IRange} expanded range because merge info.
   */
  expandRangeByMerge(t) {
    let { startRow: n, startColumn: r, endRow: s, endColumn: i } = t;
    const o = this._worksheetData.mergeData;
    if (!o)
      return {
        startRow: n,
        startColumn: r,
        endRow: s,
        endColumn: i
      };
    let a = true;
    const l = new ht();
    for (; a; ) {
      a = false;
      for (let u = 0; u < o.length; u++) {
        const {
          startRow: c,
          startColumn: h,
          endRow: d,
          endColumn: f
        } = o[u];
        if (l.getValue(c, h))
          continue;
        Gp({
          startColumn: r,
          startRow: n,
          endColumn: i,
          endRow: s
        }, {
          startColumn: h,
          startRow: c,
          endColumn: f,
          endRow: d
        }) && (n = Math.min(n, c), r = Math.min(r, h), s = Math.max(s, d), i = Math.max(i, f), l.setValue(c, h, true), a = true);
      }
    }
    return {
      startRow: n,
      startColumn: r,
      endRow: s,
      endColumn: i
    };
  }
  getColumnCount() {
    return this._columnWidthAccumulation.length;
  }
  getRowCount() {
    return this._rowHeightAccumulation.length;
  }
  /**
   * New version to get merge data.
   * @param row
   * @param column
   * @returns {ISelectionCell} The cell info with merge data
   */
  _getCellMergeInfo(t, n) {
    return this.worksheet.getCellInfoInMergeData(t, n);
  }
  /**
   * @deprecated use getNoMergeCellWithCoordByIndex instead.
   * @param rowIndex
   * @param columnIndex
   * @param header
   * @returns
   */
  getNoMergeCellPositionByIndex(t, n, r = true) {
    return this.getNoMergeCellWithCoordByIndex(t, n, r);
  }
  /**
   * Original name: getNoMergeCellPositionByIndex
   * @param rowIndex
   * @param columnIndex
   */
  getNoMergeCellWithCoordByIndex(t, n, r = true) {
    const {
      rowHeightAccumulation: s,
      columnWidthAccumulation: i,
      rowHeaderWidthAndMarginLeft: o,
      columnHeaderHeightAndMarginTop: a
    } = this;
    let { startY: l, endY: u, startX: c, endX: h } = sr(
      t,
      n,
      s,
      i
    );
    return r && (l += a, u += a, c += o, h += o), {
      startY: l,
      endY: u,
      startX: c,
      endX: h
    };
  }
  /**
   * @deprecated use getNoMergeCellWithCoordByIndex(row, col, false)
   * @param rowIndex
   * @param columnIndex
   */
  getNoMergeCellPositionByIndexWithNoHeader(t, n) {
    const { rowHeightAccumulation: r, columnWidthAccumulation: s } = this, { startY: i, endY: o, startX: a, endX: l } = sr(
      t,
      n,
      r,
      s
    );
    return {
      startY: i,
      endY: o,
      startX: a,
      endX: l
    };
  }
  /**
   *
   * @param offsetY scaled offset y
   * @param scaleY scale y
   * @param scrollXY
   * @param scrollXY.x
   * @param scrollXY.y
   */
  getRowIndexByOffsetY(t, n, r, s) {
    var a;
    const { rowHeightAccumulation: i } = this;
    t = MC(
      t,
      n,
      r,
      this.columnHeaderHeightAndMarginTop
    );
    let o = Fr(
      i,
      t,
      s == null ? void 0 : s.firstMatch
    );
    return s != null && s.closeFirst && Math.abs(i[o] - t) < Math.abs(t - ((a = i[o - 1]) != null ? a : 0)) && (o = o + 1), o;
  }
  /**
   * Get column index by offset x.
   * @param offsetX scaled offset x
   * @param scaleX scale x
   * @param scrollXY scrollXY
   * @returns column index
   */
  getColumnIndexByOffsetX(t, n, r, s) {
    var l;
    const i = TC(
      t,
      n,
      r,
      this.rowHeaderWidthAndMarginLeft
    ), { columnWidthAccumulation: o } = this;
    let a = Fr(
      o,
      i,
      s == null ? void 0 : s.firstMatch
    );
    return s != null && s.closeFirst && Math.abs(o[a] - i) < Math.abs(i - ((l = o[a - 1]) != null ? l : 0)) && (a = a + 1), a;
  }
  /**
   * Get cell index by offset(o)
   * @param offsetX position X in viewport.
   * @param offsetY position Y in viewport.
   * @param scaleX render scene scale x-axis, scene.getAncestorScale
   * @param scaleY render scene scale y-axis, scene.getAncestorScale
   * @param scrollXY  render viewport scroll {x, y}, scene.getScrollXYByRelativeCoords, scene.getScrollXY
   * @param scrollXY.x
   * @param scrollXY.y
   * @returns {row, col}
   */
  getCellIndexByOffset(t, n, r, s, i, o) {
    const a = this.getRowIndexByOffsetY(
      n,
      s,
      i,
      o
    ), l = this.getColumnIndexByOffsetX(
      t,
      r,
      i,
      o
    );
    return {
      row: a,
      column: l
    };
  }
  /**
   * Unlike getCellWithCoordByOffset, returning data doesn't include coord.
   * @param offsetX
   * @param offsetY
   * @param scaleX
   * @param scaleY
   * @param scrollXY
   */
  getCellByOffset(t, n, r, s, i) {
    const o = this == null ? void 0 : this.getCellIndexByOffset(
      t,
      n,
      r,
      s,
      i,
      { firstMatch: true }
    );
    return o ? this.worksheet.getCellInfoInMergeData(
      o.row,
      o.column
    ) : null;
  }
  /**
   * Return cell information corresponding to the current coordinates, including the merged cell object.
   *
   * @param row Specified Row Coordinate
   * @param column Specified Column Coordinate
   */
  getCellWithCoordByIndex(t, n, r = true) {
    const {
      rowHeightAccumulation: s,
      columnWidthAccumulation: i,
      rowHeaderWidthAndMarginLeft: o,
      columnHeaderHeightAndMarginTop: a
    } = this, l = sr(
      t,
      n,
      s,
      i,
      this.worksheet.getCellInfoInMergeData(t, n)
    ), { isMerged: u, isMergedMainCell: c } = l;
    let { startY: h, endY: d, startX: f, endX: g, mergeInfo: _ } = l, R = o, b = a;
    return r === false && (R = 0, b = 0), h += b, d += b, f += R, g += R, _.startY += b, _.endY += b, _.startX += R, _.endX += R, {
      actualRow: t,
      actualColumn: n,
      startX: f,
      startY: h,
      endX: g,
      endY: d,
      isMerged: u,
      isMergedMainCell: c,
      mergeInfo: _
    };
  }
  /**
   * Get cell by pos(offsetX, offsetY). Combine getCellIndexByOffset and then getCellWithCoordByIndex.
   *
   * options.matchFirst true means get cell would skip all invisible cells.
   * @param offsetX position X in viewport.
   * @param offsetY position Y in viewport.
   * @param scaleX render scene scale x-axis, scene.getAncestorScale
   * @param scaleY render scene scale y-axis, scene.getAncestorScale
   * @param scrollXY render viewportScroll {x, y}
   * @param options {IGetRowColByPosOptions}
   * @returns {ICellWithCoord} Selection data with coordinates
   */
  getCellWithCoordByOffset(t, n, r, s, i, o) {
    const { row: a, column: l } = this.getCellIndexByOffset(
      t,
      n,
      r,
      s,
      i,
      o
    );
    return this.getCellWithCoordByIndex(a, l);
  }
  /**
   * Original name: getOffsetByPositionX
   * @param column
   * @returns
   */
  getOffsetByColumn(t) {
    const { columnWidthAccumulation: n, rowHeaderWidthAndMarginLeft: r } = this, s = n.length - 1, i = n[t];
    return i != null ? i + r : t < 0 ? r : n[s] + r;
  }
  /**
   * Original name: getOffsetByPositionY
   * @param row
   */
  getOffsetByRow(t) {
    const { rowHeightAccumulation: n, columnHeaderHeightAndMarginTop: r } = this, s = n.length - 1, i = n[t];
    return i != null ? i + r : t < 0 ? r : n[s] + r;
  }
  /**
   * Original name: getDecomposedOffset
   * @param offsetX
   * @param offsetY
   */
  getOffsetRelativeToRowCol(t, n) {
    const r = Fr(this.columnWidthAccumulation, t);
    let s = 0;
    r === 0 ? s = t : s = t - this._columnWidthAccumulation[r - 1];
    const i = Fr(this.rowHeightAccumulation, n);
    let o = 0;
    return i === 0 ? o = n : o = n - this._rowHeightAccumulation[i - 1], {
      row: i,
      column: r,
      columnOffset: s,
      rowOffset: o
    };
  }
  _updateConfigAndGetDocumentModel(t, n, r, s) {
    var o, a, l, u, c;
    if (!s || !((o = t.body) != null && o.dataStream))
      return;
    t.documentStyle || (t.documentStyle = {}), t.documentStyle.marginTop = (a = r.t) != null ? a : 0, t.documentStyle.marginBottom = (l = r.b) != null ? l : 2, t.documentStyle.marginLeft = (u = r.l) != null ? u : 2, t.documentStyle.marginRight = (c = r.r) != null ? c : 2, t.documentStyle.pageSize = {
      width: Number.POSITIVE_INFINITY,
      height: Number.POSITIVE_INFINITY
    }, t.documentStyle.renderConfig = __spreadValues(__spreadValues({}, t.documentStyle.renderConfig), s);
    const i = t.body.paragraphs || [];
    for (const h of i)
      h.paragraphStyle || (h.paragraphStyle = {}), h.paragraphStyle.horizontalAlign = n;
    return new Ft(t);
  }
  dispose() {
    super.dispose(), this._rowHeightAccumulation = [], this._columnWidthAccumulation = [], this._rowTotalHeight = 0, this._columnTotalWidth = 0, this._rowHeaderWidth = 0, this._columnHeaderHeight = 0, this._worksheetData = null, this._cellData = null, this._styles = null, this.worksheet = null;
  }
};
xl = NC([
  es(2, Inject(Hn)),
  es(3, Tr),
  es(4, xs),
  es(5, Inject(Injector))
], xl);
function Ec(e, t, n, r) {
  const s = e - 1, i = t - 1, o = n[s] || 0;
  let a = n[e];
  a == null && (a = n[n.length - 1]);
  const l = r[i] || 0;
  let u = r[t];
  return u == null && (u = r[r.length - 1]), {
    startY: o,
    endY: a,
    startX: l,
    endX: u
  };
}
function cI(e, t, n, r) {
  return Ec(e, t, n, r);
}
function sr(e, t, n, r, s) {
  e = Z.clamp(e, 0, n.length - 1), t = Z.clamp(t, 0, r.length - 1);
  let { startY: i, endY: o, startX: a, endX: l } = Ec(
    e,
    t,
    n,
    r
  );
  if (!s)
    return {
      startY: i,
      endY: o,
      startX: a,
      endX: l,
      isMerged: false,
      isMergedMainCell: false,
      actualRow: e,
      actualColumn: t,
      mergeInfo: {
        startY: i,
        endY: o,
        startX: a,
        endX: l,
        startRow: e,
        startColumn: t,
        endRow: e,
        endColumn: t
      }
    };
  const {
    isMerged: u,
    isMergedMainCell: c,
    startRow: h,
    startColumn: d,
    endRow: f,
    endColumn: g
  } = s;
  let _ = {
    startRow: h,
    startColumn: d,
    endRow: f,
    endColumn: g,
    startY: i,
    endY: o,
    startX: a,
    endX: l
  };
  const R = n.length - 1, b = r.length - 1;
  if (u && h !== -1 && d !== -1) {
    const $ = n[h - 1] || 0, k = n[f] || n[R], W = r[d - 1] || 0, w = r[g] || r[b];
    _ = __spreadProps(__spreadValues({}, _), {
      startY: $,
      endY: k,
      startX: W,
      endX: w
    });
  } else if (!u && f !== -1 && g !== -1) {
    const $ = n[f] || n[R], k = r[g] || r[b];
    _ = __spreadProps(__spreadValues({}, _), {
      startY: i,
      endY: $,
      startX: a,
      endX: k
    });
  }
  return {
    isMerged: u,
    isMergedMainCell: c,
    actualRow: e,
    actualColumn: t,
    startY: i,
    endY: o,
    startX: a,
    endX: l,
    mergeInfo: _
  };
}
function TC(e, t, n, r) {
  const { x: s } = n;
  return e / t + s - r;
}
function MC(e, t, n, r) {
  const { y: s } = n;
  return e = e / t + s - r, e;
}
var hI = ["script", "style", "meta", "comment", "link"];
var xC = ((e) => (e[e.INFO = 0] = "INFO", e[e.STOP = 1] = "STOP", e[e.WARNING = 2] = "WARNING", e))(xC || {});
var LC = ((e) => (e[e.DISABLED = 0] = "DISABLED", e[e.FULL_ALPHA = 1] = "FULL_ALPHA", e[e.FULL_HANGUL = 2] = "FULL_HANGUL", e[e.FULL_KATAKANA = 3] = "FULL_KATAKANA", e[e.HALF_ALPHA = 4] = "HALF_ALPHA", e[e.HALF_HANGUL = 5] = "HALF_HANGUL", e[e.HALF_KATAKANA = 6] = "HALF_KATAKANA", e[e.HIRAGANA = 7] = "HIRAGANA", e[e.NO_CONTROL = 8] = "NO_CONTROL", e[e.OFF = 9] = "OFF", e[e.ON = 10] = "ON", e))(LC || {});
var DC = ((e) => (e.BETWEEN = "between", e.EQUAL = "equal", e.GREATER_THAN = "greaterThan", e.GREATER_THAN_OR_EQUAL = "greaterThanOrEqual", e.LESS_THAN = "lessThan", e.LESS_THAN_OR_EQUAL = "lessThanOrEqual", e.NOT_BETWEEN = "notBetween", e.NOT_EQUAL = "notEqual", e))(DC || {});
var UC = ((e) => (e[e.TEXT = 0] = "TEXT", e[e.ARROW = 1] = "ARROW", e[e.CUSTOM = 2] = "CUSTOM", e))(UC || {});
var PC = ((e) => (e.VALID = "valid", e.INVALID = "invalid", e.VALIDATING = "validating", e))(PC || {});
var kC = ((e) => (e.CUSTOM = "custom", e.LIST = "list", e.LIST_MULTIPLE = "listMultiple", e.NONE = "none", e.TEXT_LENGTH = "textLength", e.DATE = "date", e.TIME = "time", e.WHOLE = "whole", e.DECIMAL = "decimal", e.CHECKBOX = "checkbox", e.ANY = "any", e))(kC || {});
var FC = Object.getOwnPropertyDescriptor;
var HC = (e, t, n, r) => {
  for (var s = r > 1 ? void 0 : r ? FC(t, n) : t, i = e.length - 1, o; i >= 0; i--)
    (o = e[i]) && (s = o(s) || s);
  return s;
};
var Ll = (e, t) => (n, r) => t(n, r, e);
var to = class extends Ve {
  constructor(e, t) {
    super(), this._resourceManagerService = e, this._univerInstanceService = t, this._init();
  }
  _init() {
    const e = (n) => {
      n.businesses.forEach((r) => {
        switch (r) {
          case we.UNRECOGNIZED:
          case we.UNIVER_UNKNOWN:
          case we.UNIVER_SLIDE:
          case we.UNIVER_DOC: {
            this._univerInstanceService.getAllUnitsForType(we.UNIVER_DOC).forEach((s) => {
              const o = (s.getSnapshot().resources || []).find((a) => a.name === n.pluginName);
              if (o)
                try {
                  const a = n.parseJson(o.data);
                  n.onLoad(s.getUnitId(), a);
                } catch (e2) {
                  console.error(`Load Document{${s.getUnitId()}} Resources{${n.pluginName}} Data Error.`);
                }
            });
            break;
          }
          case we.UNIVER_SHEET:
            this._univerInstanceService.getAllUnitsForType(we.UNIVER_SHEET).forEach((s) => {
              const o = (s.getSnapshot().resources || []).find((a) => a.name === n.pluginName);
              if (o)
                try {
                  const a = n.parseJson(o.data);
                  n.onLoad(s.getUnitId(), a);
                } catch (e2) {
                  console.error(`Load Workbook{${s.getUnitId()}} Resources{${n.pluginName}} Data Error.`);
                }
            });
        }
      });
    };
    this._resourceManagerService.getAllResourceHooks().forEach((n) => e(n)), this.disposeWithMe(this._resourceManagerService.register$.subscribe((n) => e(n))), this.disposeWithMe(
      this._univerInstanceService.getTypeOfUnitAdded$(we.UNIVER_SHEET).subscribe((n) => {
        this._resourceManagerService.loadResources(n.getUnitId(), n.getSnapshot().resources);
      })
    ), this.disposeWithMe(
      this._univerInstanceService.getTypeOfUnitAdded$(we.UNIVER_DOC).subscribe((n) => {
        const r = n.getUnitId();
        Gc(r) || this._resourceManagerService.loadResources(n.getUnitId(), n.getSnapshot().resources);
      })
    ), this.disposeWithMe(
      this._univerInstanceService.getTypeOfUnitDisposed$(we.UNIVER_SHEET).subscribe((n) => {
        this._resourceManagerService.unloadResources(n.getUnitId(), we.UNIVER_SHEET);
      })
    ), this.disposeWithMe(
      this._univerInstanceService.getTypeOfUnitDisposed$(we.UNIVER_DOC).subscribe((n) => {
        this._resourceManagerService.unloadResources(n.getUnitId(), we.UNIVER_DOC);
      })
    );
  }
  saveUnit(e) {
    const t = this._univerInstanceService.getUnit(e);
    if (!t)
      return null;
    const n = this._resourceManagerService.getResources(e, t.type), r = Z.deepClone(t.getSnapshot());
    return r.resources = n, r;
  }
};
to = HC([
  Ll(0, Inject(na)),
  Ll(1, Inject(br))
], to);
var dI = class {
  /**
   * Create a Univer instance.
   * @param config Configuration data for Univer
   * @param parentInjector An optional parent injector of the Univer injector. For more information, see https://redi.wendell.fun/docs/hierarchy.
   */
  constructor(t = {}, n) {
    p(this, "_startedTypes", /* @__PURE__ */ new Set());
    p(this, "_injector");
    p(this, "_disposingCallbacks", new ho());
    const r = this._injector = $C(n, t == null ? void 0 : t.override), { theme: s, darkMode: i, locale: o, locales: a, logLevel: l, logCommandExecution: u } = t;
    s && this._injector.get(Ji).setTheme(s), i && this._injector.get(Ji).setDarkMode(i), a && this._injector.get(Hn).load(a), o && this._injector.get(Hn).setLocale(o), l && this._injector.get(Nt).setLogLevel(l), u !== void 0 && this._injector.get(xs).setConfig(yi, u), this._init(r);
  }
  get _univerInstanceService() {
    return this._injector.get(br);
  }
  get _pluginService() {
    return this._injector.get(Os);
  }
  /**
   * @ignore
   */
  __getInjector() {
    return this._injector;
  }
  /**
   * Register a callback function which will be called when this Univer instance is disposing.
   *
   * @ignore
   *
   * @param callback The callback function.
   * @returns To remove this callback function from this Univer instance's on disposing list.
   */
  onDispose(t) {
    const n = this._disposingCallbacks.add(Be(t));
    return Be(() => n.dispose(true));
  }
  dispose() {
    this._disposingCallbacks.dispose(), this._injector.dispose();
  }
  setLocale(t) {
    this._injector.get(Hn).setLocale(t);
  }
  createUnit(t, n) {
    return this._univerInstanceService.createUnit(t, n);
  }
  /**
   * Create a univer sheet instance with internal dependency injection.
   *
   * @deprecated use `createUnit` instead
   */
  createUniverSheet(t) {
    return this._injector.get(Nt).warn("[Univer]", "Univer.createUniverSheet is deprecated, use createUnit instead"), this._univerInstanceService.createUnit(we.UNIVER_SHEET, t);
  }
  /**
   * @deprecated use `createUnit` instead
   */
  createUniverDoc(t) {
    return this._injector.get(Nt).warn("[Univer]", "Univer.createUniverDoc is deprecated, use createUnit instead"), this._univerInstanceService.createUnit(we.UNIVER_DOC, t);
  }
  /**
   * @deprecated use `createUnit` instead
   */
  createUniverSlide(t) {
    return this._injector.get(Nt).warn("[Univer]", "Univer.createUniverSlide is deprecated, use createUnit instead"), this._univerInstanceService.createUnit(we.UNIVER_SLIDE, t);
  }
  _init(t) {
    this._univerInstanceService.registerCtorForType(we.UNIVER_SHEET, Ss), this._univerInstanceService.registerCtorForType(we.UNIVER_DOC, Ft), this._univerInstanceService.registerCtorForType(we.UNIVER_SLIDE, hc);
    const n = t.get(br);
    n.__setCreateHandler(
      (r, s, i, o) => {
        if (!this._startedTypes.has(r)) {
          this._pluginService.startPluginsForType(r), this._startedTypes.add(r);
          const l = t.createInstance(i, s);
          return n.__addUnit(l, o), this._tryProgressToReady(), l;
        }
        const a = t.createInstance(i, s);
        return n.__addUnit(a, o), a;
      }
    );
  }
  _tryProgressToReady() {
    this._injector.get(Yn).stage < Pe.Ready && (this._injector.get(Yn).stage = Pe.Ready);
  }
  /** Register a plugin into univer. */
  registerPlugin(t, n) {
    this._pluginService.registerPlugin(t, n);
  }
  /**
   * Register multiple plugins into univer.
   * @param plugins An array of tuples, where each tuple contains a plugin constructor and its optional configuration.
   */
  registerPlugins(t) {
    t.forEach((n) => {
      const [r, s] = n;
      this._pluginService.registerPlugin(r, s);
    });
  }
};
function $C(e, t) {
  const n = uC([
    [CE],
    [Hn],
    [Ji],
    [Yn],
    [Os],
    [Is],
    // abstract services
    [br, { useClass: Ki }],
    [aC, { useClass: lC }],
    [Nt, { useClass: Cg, lazy: true }],
    [Ds, { useClass: Ni }],
    [ra, { useClass: Zi, lazy: true }],
    [xs, { useClass: _g }],
    [Tr, { useClass: pg }],
    [na, { useClass: qi, lazy: true }],
    [Nl, { useClass: to, lazy: true }],
    [_E, { useClass: Vi }],
    [oC, { useClass: Xi, lazy: true }]
  ], t), r = e ? e.createChild(n) : new Injector(n);
  return Kc(r, [
    [Is],
    [Nl]
  ]), r;
}
kc();

export {
  isCtor,
  isClassDependencyItem,
  isFactoryDependencyItem,
  isValueDependencyItem,
  isAsyncDependencyItem,
  isAsyncHook,
  RediError,
  Quantity,
  LookUp,
  createIdentifier,
  SkipSelf,
  Self,
  Many,
  Optional,
  Inject,
  setDependencies,
  forwardRef,
  WithNew,
  isDisposable,
  Injector,
  vs,
  VC,
  GC,
  KC,
  XC,
  qC,
  JC,
  ZC,
  Fl,
  Hl,
  Wc,
  Yc,
  zc,
  Vc,
  QC,
  Gc,
  eR,
  Kc,
  Xc,
  Ci,
  tR,
  nR,
  ir,
  rR,
  qc,
  sR,
  iR,
  oR,
  aR,
  lR,
  yf,
  uR,
  cR,
  co,
  hR,
  Kn,
  dR,
  tm,
  fR,
  mR,
  lu,
  uu,
  gR,
  nm,
  rm,
  _R,
  Be,
  pR,
  ho,
  Ve,
  ER,
  CR,
  we,
  fo,
  Z,
  et,
  Dr,
  RR,
  IR,
  gm,
  xe,
  _m,
  yt,
  pm,
  Em,
  Cm,
  Rm,
  Im,
  wm,
  wR,
  Sm,
  Ts,
  Oi,
  Om,
  vm,
  bm,
  Am,
  ym,
  Nm,
  Tm,
  gs,
  Mm,
  Pt,
  Dn,
  jn,
  vi,
  bi,
  Zt,
  ie,
  mn,
  st,
  go,
  xm,
  Lm,
  me,
  Ms,
  En,
  Un,
  Dm,
  fu,
  Um,
  Pm,
  km,
  Fm,
  Hm,
  $m,
  Bm,
  qe,
  jm,
  Wm,
  Ym,
  zm,
  Vm,
  Gm,
  Km,
  Xm,
  qm,
  or,
  Jm,
  Zm,
  Qm,
  eg,
  tg,
  ng,
  rg,
  _t,
  SR,
  sg,
  ig,
  mu,
  og,
  ag,
  OR,
  pe,
  J,
  xs,
  _g,
  Tr,
  pg,
  Eg,
  Nt,
  Cg,
  yi,
  Ls,
  Ds,
  Og,
  Ni,
  po,
  vR,
  bg,
  Pa,
  bR,
  AR,
  yR,
  NR,
  Ag,
  TR,
  yg,
  Fr,
  MR,
  Hr,
  Ng,
  xR,
  ni,
  LR,
  ka,
  Tg,
  Eo,
  Wn,
  Mg,
  Ti,
  Mi,
  DR,
  UR,
  Fa,
  At,
  PR,
  kR,
  Wg,
  FR,
  HR,
  Yg,
  ge,
  ye,
  $R,
  zg,
  Vg,
  BR,
  ar,
  jR,
  gn,
  WR,
  Ha,
  YR,
  zR,
  $a,
  ht,
  Xg,
  VR,
  GR,
  qg,
  Ba,
  Yt,
  Jg,
  KR,
  XR,
  qR,
  JR,
  ZR,
  QR,
  ja,
  e1,
  Eu,
  Zg,
  t1,
  nn,
  Co,
  n1,
  r1,
  D_,
  U_,
  P_,
  s1,
  i1,
  o1,
  _s,
  jr,
  a1,
  Tp,
  Mp,
  xp,
  l1,
  u1,
  c1,
  h1,
  d1,
  f1,
  m1,
  g1,
  rt,
  Up,
  _1,
  p1,
  E1,
  C1,
  R1,
  Pp,
  I1,
  vr,
  Fi,
  w1,
  Bu,
  Gp,
  Cn,
  S1,
  O1,
  fl,
  v1,
  b1,
  Qp,
  A1,
  y1,
  N1,
  Hs,
  $s,
  s0,
  Vt,
  Bs,
  T1,
  nc,
  Bi,
  m0,
  g0,
  M1,
  _0,
  kt,
  x1,
  p0,
  E0,
  _l,
  tr,
  S0,
  O0,
  Ne,
  en,
  L0,
  ct,
  L1,
  ea,
  rc,
  Ft,
  oc,
  Ze,
  D1,
  js,
  _n,
  dn,
  Ws,
  Rs,
  fn,
  Fn,
  U1,
  dE,
  P1,
  k1,
  na,
  zi,
  Is,
  Vi,
  _E,
  qr,
  _r,
  Jr,
  Zr,
  F1,
  pE,
  H1,
  EE,
  $1,
  B1,
  j1,
  W1,
  Y1,
  z1,
  CE,
  uc,
  RE,
  Il,
  OE,
  V1,
  G1,
  Qr,
  AE,
  yE,
  K1,
  DE,
  X1,
  UE,
  q1,
  PE,
  J1,
  kE,
  Z1,
  FE,
  Q1,
  HE,
  $E,
  jE,
  Ct,
  WE,
  eI,
  YE,
  VE,
  ws,
  GE,
  tI,
  nI,
  Ss,
  hc,
  br,
  Ki,
  Pe,
  nC,
  Yn,
  rI,
  Hn,
  Xi,
  oC,
  mc,
  aC,
  lC,
  uC,
  yl,
  sI,
  Os,
  Nl,
  qi,
  Ji,
  ra,
  RC,
  IC,
  wC,
  SC,
  Zi,
  OC,
  iI,
  oI,
  aI,
  lI,
  uI,
  eo,
  xl,
  Ec,
  cI,
  sr,
  TC,
  MC,
  hI,
  xC,
  LC,
  DC,
  UC,
  PC,
  kC,
  dI
};
/*! Bundled license information:

@wendellhu/redi/dist/esm/index.js:
  (* istanbul ignore next -- @preserve *)
*/
//# sourceMappingURL=chunk-Y4UF2FTU.js.map
