import {
  cubehelix,
  cubehelixLong,
  rgb,
  rgbBasis
} from "./chunk-E6NMYCS2.js";
import {
  AABB,
  Axis,
  CSS,
  Canvas,
  Category,
  Circle,
  Continuous,
  CustomElement,
  CustomEvent,
  DisplayObject,
  Ellipse,
  Group,
  HTML,
  Image as Image2,
  Layout,
  Line,
  Marker,
  Path,
  Plugin,
  Polygon,
  Polyline,
  PropertySyntax,
  Rect,
  Renderer,
  Scrollbar,
  Shape,
  Slider,
  Text,
  Tooltip,
  center_default,
  collide_default,
  convertToPath,
  debounce_default,
  deep_mix_default,
  esm_default,
  filter_default,
  find_default,
  format,
  get_default,
  head,
  identity_default,
  index_of_default,
  isArray,
  isFunction,
  isNull,
  isNumber,
  isString,
  is_equal_default,
  is_plain_object_default,
  is_undefined_default,
  keys_default,
  last,
  link_default,
  lower_first_default,
  manyBody_default,
  map_values_default,
  mat3_exports,
  mat4_exports,
  measureTextWidth,
  mix,
  omit_default,
  parseColor,
  pick_default,
  reduce_default,
  require_lodash,
  set_default,
  simulation_default,
  size,
  throttle_default,
  upper_first_default,
  vec3_exports,
  vec4_exports,
  x_default,
  y_default
} from "./chunk-2C3BOJAR.js";
import "./chunk-A3W4J62T.js";
import {
  require_color_string
} from "./chunk-OERZF2CA.js";
import "./chunk-ARQYEDIX.js";
import {
  __spreadArrays
} from "./chunk-WJK6EJH2.js";
import {
  require_client
} from "./chunk-EEAVZVMR.js";
import "./chunk-ZY7H3YXG.js";
import {
  require_react_dom
} from "./chunk-4DDZX4I5.js";
import {
  require_react
} from "./chunk-KTKTKB6L.js";
import {
  __commonJS,
  __export,
  __pow,
  __spreadProps,
  __spreadValues,
  __toESM,
  __yieldStar
} from "./chunk-JMNN7AZU.js";

// node_modules/pdfast/src/helper.js
var require_helper = __commonJS({
  "node_modules/pdfast/src/helper.js"(exports, module) {
    "use strict";
    var self = module.exports;
    module.exports.isNumber = function(x2) {
      return typeof x2 === "number";
    };
    module.exports.findMin = function(arr) {
      if (arr.length === 0) {
        return Infinity;
      }
      var curr = arr[0];
      for (var i2 = 1; i2 < arr.length; i2++) {
        curr = Math.min(curr, arr[i2]);
      }
      return curr;
    };
    module.exports.findMax = function(arr) {
      if (arr.length === 0) {
        return -Infinity;
      }
      var curr = arr[0];
      for (var i2 = 1; i2 < arr.length; i2++) {
        curr = Math.max(curr, arr[i2]);
      }
      return curr;
    };
    module.exports.findMinMulti = function(arr) {
      var curr = self.findMin(arr[0]);
      for (var i2 = 1; i2 < arr.length; i2++) {
        curr = Math.min(curr, self.findMin(arr[i2]));
      }
      return curr;
    };
    module.exports.findMaxMulti = function(arr) {
      var curr = self.findMax(arr[0]);
      for (var i2 = 1; i2 < arr.length; i2++) {
        curr = Math.max(curr, self.findMax(arr[i2]));
      }
      return curr;
    };
    module.exports.inside = function(min6, max7, x2) {
      return min6 <= x2 && x2 <= max7;
    };
  }
});

// node_modules/pdfast/src/index.js
var require_src = __commonJS({
  "node_modules/pdfast/src/index.js"(exports, module) {
    "use strict";
    var DEFAULT_SIZE = 50;
    var DEFAULT_WIDTH = 2;
    var LN_2 = Math.log(2);
    var self = module.exports;
    var helper = require_helper();
    function kernel(x2) {
      return 1 - Math.abs(x2);
    }
    module.exports.getUnifiedMinMax = function(arr, options) {
      return self.getUnifiedMinMaxMulti([arr], options);
    };
    module.exports.getUnifiedMinMaxMulti = function(arrMulti, options) {
      options = options || {};
      var relaxMin = false;
      var relaxMax = false;
      var width = helper.isNumber(options.width) ? options.width : DEFAULT_WIDTH;
      var size4 = helper.isNumber(options.size) ? options.size : DEFAULT_SIZE;
      var min6 = helper.isNumber(options.min) ? options.min : (relaxMin = true, helper.findMinMulti(arrMulti));
      var max7 = helper.isNumber(options.max) ? options.max : (relaxMax = true, helper.findMaxMulti(arrMulti));
      var range3 = max7 - min6;
      var step = range3 / (size4 - 1);
      if (relaxMin) {
        min6 = min6 - 2 * width * step;
      }
      if (relaxMax) {
        max7 = max7 + 2 * width * step;
      }
      return {
        min: min6,
        max: max7
      };
    };
    module.exports.create = function(arr, options) {
      options = options || {};
      if (!arr || arr.length === 0) {
        return [];
      }
      var size4 = helper.isNumber(options.size) ? options.size : DEFAULT_SIZE;
      var width = helper.isNumber(options.width) ? options.width : DEFAULT_WIDTH;
      var normalizedMinMax = self.getUnifiedMinMax(arr, {
        size: size4,
        width,
        min: options.min,
        max: options.max
      });
      var min6 = normalizedMinMax.min;
      var max7 = normalizedMinMax.max;
      var range3 = max7 - min6;
      var step = range3 / (size4 - 1);
      if (range3 === 0) {
        return [{ x: min6, y: 1 }];
      }
      var buckets = [];
      for (var i2 = 0; i2 < size4; i2++) {
        buckets.push({
          x: min6 + i2 * step,
          y: 0
        });
      }
      var xToBucket = function(x2) {
        return Math.floor((x2 - min6) / step);
      };
      var partialArea = generatePartialAreas(kernel, width);
      var fullArea = partialArea[width];
      var c5 = partialArea[width - 1] - partialArea[width - 2];
      var initalValue = 0;
      arr.forEach(function(x2) {
        var bucket = xToBucket(x2);
        if (bucket + width < 0 || bucket - width >= buckets.length) {
          return;
        }
        var start = Math.max(bucket - width, 0);
        var mid2 = bucket;
        var end = Math.min(bucket + width, buckets.length - 1);
        var leftBlockCount = start - (bucket - width);
        var rightBlockCount = bucket + width - end;
        var spilledAreaLeft = partialArea[-width - 1 + leftBlockCount] || 0;
        var spilledAreaRight = partialArea[-width - 1 + rightBlockCount] || 0;
        var weight2 = fullArea / (fullArea - spilledAreaLeft - spilledAreaRight);
        if (leftBlockCount > 0) {
          initalValue += weight2 * (leftBlockCount - 1) * c5;
        }
        var startGradPos = Math.max(0, bucket - width + 1);
        if (helper.inside(0, buckets.length - 1, startGradPos)) {
          buckets[startGradPos].y += weight2 * 1 * c5;
        }
        if (helper.inside(0, buckets.length - 1, mid2 + 1)) {
          buckets[mid2 + 1].y -= weight2 * 2 * c5;
        }
        if (helper.inside(0, buckets.length - 1, end + 1)) {
          buckets[end + 1].y += weight2 * 1 * c5;
        }
      });
      var accumulator = initalValue;
      var gradAccumulator = 0;
      var area2 = 0;
      buckets.forEach(function(bucket) {
        gradAccumulator += bucket.y;
        accumulator += gradAccumulator;
        bucket.y = accumulator;
        area2 += accumulator;
      });
      if (area2 > 0) {
        buckets.forEach(function(bucket) {
          bucket.y /= area2;
        });
      }
      return buckets;
    };
    function generatePartialAreas(kernel2, width) {
      var partialAreas = {};
      var accumulator = 0;
      for (var i2 = -width; i2 <= width; i2++) {
        accumulator += kernel2(i2 / width);
        partialAreas[i2] = accumulator;
      }
      return partialAreas;
    }
    module.exports.getExpectedValueFromPdf = function(pdf2) {
      if (!pdf2 || pdf2.length === 0) {
        return void 0;
      }
      var expected = 0;
      pdf2.forEach(function(obj) {
        expected += obj.x * obj.y;
      });
      return expected;
    };
    module.exports.getXWithLeftTailArea = function(pdf2, area2) {
      if (!pdf2 || pdf2.length === 0) {
        return void 0;
      }
      var accumulator = 0;
      var last6 = 0;
      for (var i2 = 0; i2 < pdf2.length; i2++) {
        last6 = i2;
        accumulator += pdf2[i2].y;
        if (accumulator >= area2) {
          break;
        }
      }
      return pdf2[last6].x;
    };
    module.exports.getPerplexity = function(pdf2) {
      if (!pdf2 || pdf2.length === 0) {
        return void 0;
      }
      var entropy = 0;
      pdf2.forEach(function(obj) {
        var ln = Math.log(obj.y);
        if (isFinite(ln)) {
          entropy += obj.y * ln;
        }
      });
      entropy = -entropy / LN_2;
      return Math.pow(2, entropy);
    };
  }
});

// node_modules/@antv/g2/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  AREA_CLASS_NAME: () => AREA_CLASS_NAME,
  Academy: () => Academy,
  Bin: () => Bin,
  BinX: () => BinX,
  COMPONENT_CLASS_NAME: () => COMPONENT_CLASS_NAME,
  Chart: () => Chart2,
  ChartEvent: () => ChartEvent,
  Classic: () => Classic,
  ClassicDark: () => ClassicDark,
  Dark: () => Dark,
  DiffY: () => DiffY,
  DodgeX: () => DodgeX,
  ELEMENT_CLASS_NAME: () => ELEMENT_CLASS_NAME,
  Filter: () => Filter,
  FlexX: () => FlexX,
  Group: () => Group2,
  GroupColor: () => GroupColor,
  GroupX: () => GroupX,
  GroupY: () => GroupY,
  Jitter: () => Jitter,
  JitterX: () => JitterX,
  JitterY: () => JitterY,
  LABEL_CLASS_NAME: () => LABEL_CLASS_NAME,
  LABEL_LAYER_CLASS_NAME: () => LABEL_LAYER_CLASS_NAME,
  Light: () => Light,
  LinearAxis: () => LinearAxis,
  MAIN_LAYER_CLASS_NAME: () => MAIN_LAYER_CLASS_NAME,
  MASK_CLASS_NAME: () => MASK_CLASS_NAME,
  MaybeDefaultX: () => MaybeDefaultX,
  MaybeDefaultY: () => MaybeDefaultY,
  MaybeFunctionAttribute: () => MaybeFunctionAttribute,
  MaybeGradient: () => MaybeGradient,
  MaybeIdentityX: () => MaybeIdentityX,
  MaybeIdentityY: () => MaybeIdentityY,
  MaybeKey: () => MaybeKey,
  MaybeSeries: () => MaybeSeries,
  MaybeSize: () => MaybeSize,
  MaybeStackY: () => MaybeStackY,
  MaybeTitle: () => MaybeTitle,
  MaybeTooltip: () => MaybeTooltip,
  MaybeTuple: () => MaybeTuple,
  MaybeTupleX: () => MaybeTupleX,
  MaybeTupleY: () => MaybeTupleY,
  MaybeVisualPosition: () => MaybeVisualPosition,
  MaybeZeroPadding: () => MaybeZeroPadding,
  MaybeZeroX: () => MaybeZeroX,
  MaybeZeroY: () => MaybeZeroY,
  MaybeZeroY1: () => MaybeZeroY1,
  MaybeZeroZ: () => MaybeZeroZ,
  NormalizeY: () => NormalizeY,
  PLOT_CLASS_NAME: () => PLOT_CLASS_NAME,
  Pack: () => Pack,
  Runtime: () => Runtime,
  Sample: () => Sample,
  Select: () => Select,
  SelectX: () => SelectX,
  SelectY: () => SelectY,
  Selection: () => Selection,
  SortColor: () => SortColor,
  SortX: () => SortX,
  SortY: () => SortY,
  StackEnter: () => StackEnter,
  StackY: () => StackY,
  SymmetryY: () => SymmetryY,
  VIEW_CLASS_NAME: () => VIEW_CLASS_NAME,
  corelib: () => corelib,
  dataOf: () => dataOf,
  extend: () => extend3,
  geolib: () => geolib,
  graphlib: () => graphlib,
  litelib: () => litelib,
  plotlib: () => plotlib,
  register: () => register,
  render: () => render,
  renderToMountedElement: () => renderToMountedElement,
  select: () => select,
  selectG2Elements: () => selectG2Elements,
  selectPlotArea: () => selectPlotArea,
  seriesOf: () => seriesOf,
  stdlib: () => stdlib
});

// node_modules/@antv/g2/esm/coordinate/cartesian.js
var Cartesian = () => [["cartesian"]];
Cartesian.props = {};

// node_modules/@antv/g2/esm/utils/angle.js
function convertAngles(startAngle, endAngle) {
  startAngle = startAngle % (2 * Math.PI);
  endAngle = endAngle % (2 * Math.PI);
  if (startAngle < 0) {
    startAngle = 2 * Math.PI + startAngle;
  }
  if (endAngle < 0) {
    endAngle = 2 * Math.PI + endAngle;
  }
  if (startAngle >= endAngle) {
    endAngle = endAngle + 2 * Math.PI;
  }
  return {
    startAngle,
    endAngle
  };
}

// node_modules/@antv/g2/esm/coordinate/polar.js
var getPolarOptions = (options = {}) => {
  const defaultOptions = {
    startAngle: -Math.PI / 2,
    endAngle: Math.PI * 3 / 2,
    innerRadius: 0,
    outerRadius: 1
  };
  const polarOption = Object.assign(Object.assign({}, defaultOptions), options);
  return Object.assign(Object.assign({}, polarOption), convertAngles(polarOption.startAngle, polarOption.endAngle));
};
var Polar = (options) => {
  const { startAngle, endAngle, innerRadius, outerRadius } = getPolarOptions(options);
  return [
    ["translate", 0, 0.5],
    ["reflect.y"],
    ["translate", 0, -0.5],
    ["polar", startAngle, endAngle, innerRadius, outerRadius]
  ];
};
Polar.props = {};

// node_modules/@antv/g2/esm/coordinate/helix.js
var Helix = ({ startAngle = 0, endAngle = Math.PI * 6, innerRadius = 0, outerRadius = 1 }) => [
  ["translate", 0.5, 0.5],
  ["reflect.y"],
  ["translate", -0.5, -0.5],
  ["helix", startAngle, endAngle, innerRadius, outerRadius]
];
Helix.props = {};

// node_modules/@antv/g2/esm/coordinate/transpose.js
var Transpose = () => [
  ["transpose"],
  ["translate", 0.5, 0.5],
  ["reflect.x"],
  ["translate", -0.5, -0.5]
];
Transpose.props = { transform: true };

// node_modules/@antv/g2/esm/coordinate/theta.js
var getThetaOptions = (options = {}) => {
  const defaultOptions = {
    startAngle: -Math.PI / 2,
    endAngle: Math.PI * 3 / 2,
    innerRadius: 0,
    outerRadius: 1
  };
  return Object.assign(Object.assign({}, defaultOptions), options);
};
var Theta = (options) => {
  const { startAngle, endAngle, innerRadius, outerRadius } = getThetaOptions(options);
  return [
    ...Transpose(),
    ...Polar({ startAngle, endAngle, innerRadius, outerRadius })
  ];
};
Theta.props = {};

// node_modules/@antv/g2/esm/coordinate/radial.js
var getRadialOptions = (options = {}) => {
  const defaultOptions = {
    startAngle: -Math.PI / 2,
    endAngle: Math.PI * 3 / 2,
    innerRadius: 0,
    outerRadius: 1
  };
  return Object.assign(Object.assign({}, defaultOptions), options);
};
var Radial = (options) => {
  const { startAngle, endAngle, innerRadius, outerRadius } = getRadialOptions(options);
  return [
    ["transpose"],
    ["translate", 0.5, 0.5],
    ["reflect"],
    ["translate", -0.5, -0.5],
    ...Polar({ startAngle, endAngle, innerRadius, outerRadius })
  ];
};
Radial.props = {};

// node_modules/@antv/g2/esm/coordinate/parallel.js
var Parallel = () => [["parallel", 0, 1, 0, 1]];
Parallel.props = {};

// node_modules/@antv/g2/esm/coordinate/fisheye.js
var Fisheye = ({ focusX = 0, focusY = 0, distortionX = 2, distortionY = 2, visual = false }) => [["fisheye", focusX, focusY, distortionX, distortionY, visual]];
Fisheye.props = { transform: true };

// node_modules/@antv/g2/esm/coordinate/radar.js
var Radar = (options) => {
  const { startAngle = -Math.PI / 2, endAngle = Math.PI * 3 / 2, innerRadius = 0, outerRadius = 1 } = options;
  return [
    ...Parallel(),
    ...Polar({ startAngle, endAngle, innerRadius, outerRadius })
  ];
};
Radar.props = {};

// node_modules/@antv/g2/esm/encode/constant.js
var Constant = ({ value: value2 }) => {
  return (data) => data.map(() => value2);
};
Constant.props = {};

// node_modules/@antv/g2/esm/encode/transform.js
var Transform = ({ value: value2 }) => {
  return (data) => data.map(value2);
};
Transform.props = {};

// node_modules/@antv/g2/esm/encode/field.js
var Field = ({ value: value2 }) => {
  return (data) => data.map((d3) => d3[value2]);
};
Field.props = {};

// node_modules/@antv/g2/esm/encode/column.js
var Column = ({ value: value2 }) => {
  return () => value2;
};
Column.props = {};

// node_modules/@antv/g2/esm/transform/utils/helper.js
function column(value2, field3) {
  if (value2 === null)
    return void 0;
  return { type: "column", value: value2, field: field3 };
}
function inferredColumn(value2, field3) {
  const c5 = column(value2, field3);
  return Object.assign(Object.assign({}, c5), { inferred: true });
}
function visualColumn(value2, field3) {
  if (value2 === null)
    return void 0;
  return { type: "column", value: value2, field: field3, visual: true };
}
function nonConstantColumn(value2, field3) {
  const c5 = column(value2, field3);
  return Object.assign(Object.assign({}, c5), { constant: false });
}
function constant(I, value2) {
  const array2 = [];
  for (const i2 of I)
    array2[i2] = value2;
  return array2;
}
function columnOf(encode, key) {
  const channel = encode[key];
  if (!channel)
    return [null, null];
  const { value: value2, field: field3 = null } = channel;
  return [value2, field3];
}
function maybeColumnOf(encode, ...K) {
  for (const key of K) {
    if (typeof key === "string") {
      const [KV, fv] = columnOf(encode, key);
      if (KV !== null)
        return [KV, fv];
    } else {
      return [key, null];
    }
  }
  return [null, null];
}
function isObject(d3) {
  if (d3 instanceof Date)
    return false;
  return typeof d3 === "object";
}

// node_modules/@antv/g2/esm/transform/maybeZeroY1.js
var MaybeZeroY1 = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { y1: y12 } = encode;
    if (y12 !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: { y1: inferredColumn(constant(I, 0)) }
      })
    ];
  };
};
MaybeZeroY1.props = {};

// node_modules/d3-array/src/ascending.js
function ascending(a4, b) {
  return a4 == null || b == null ? NaN : a4 < b ? -1 : a4 > b ? 1 : a4 >= b ? 0 : NaN;
}

// node_modules/d3-array/src/descending.js
function descending(a4, b) {
  return a4 == null || b == null ? NaN : b < a4 ? -1 : b > a4 ? 1 : b >= a4 ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector(f2) {
  let compare1, compare2, delta;
  if (f2.length !== 2) {
    compare1 = ascending;
    compare2 = (d3, x2) => ascending(f2(d3), x2);
    delta = (d3, x2) => f2(d3) - x2;
  } else {
    compare1 = f2 === ascending || f2 === descending ? f2 : zero;
    compare2 = f2;
    delta = f2;
  }
  function left2(a4, x2, lo = 0, hi = a4.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0) return hi;
      do {
        const mid2 = lo + hi >>> 1;
        if (compare2(a4[mid2], x2) < 0) lo = mid2 + 1;
        else hi = mid2;
      } while (lo < hi);
    }
    return lo;
  }
  function right2(a4, x2, lo = 0, hi = a4.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0) return hi;
      do {
        const mid2 = lo + hi >>> 1;
        if (compare2(a4[mid2], x2) <= 0) lo = mid2 + 1;
        else hi = mid2;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a4, x2, lo = 0, hi = a4.length) {
    const i2 = left2(a4, x2, lo, hi - 1);
    return i2 > lo && delta(a4[i2 - 1], x2) > -delta(a4[i2], x2) ? i2 - 1 : i2;
  }
  return { left: left2, center: center2, right: right2 };
}
function zero() {
  return 0;
}

// node_modules/d3-array/src/number.js
function number(x2) {
  return x2 === null ? NaN : +x2;
}
function* numbers(values4, valueof2) {
  if (valueof2 === void 0) {
    for (let value2 of values4) {
      if (value2 != null && (value2 = +value2) >= value2) {
        yield value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index2, values4)) != null && (value2 = +value2) >= value2) {
        yield value2;
      }
    }
  }
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default = bisectRight;

// node_modules/d3-array/src/blur.js
var blur2 = Blur2(blurf);
var blurImage = Blur2(blurfImage);
function Blur2(blur3) {
  return function(data, rx, ry = rx) {
    if (!((rx = +rx) >= 0)) throw new RangeError("invalid rx");
    if (!((ry = +ry) >= 0)) throw new RangeError("invalid ry");
    let { data: values4, width, height } = data;
    if (!((width = Math.floor(width)) >= 0)) throw new RangeError("invalid width");
    if (!((height = Math.floor(height !== void 0 ? height : values4.length / width)) >= 0)) throw new RangeError("invalid height");
    if (!width || !height || !rx && !ry) return data;
    const blurx = rx && blur3(rx);
    const blury = ry && blur3(ry);
    const temp = values4.slice();
    if (blurx && blury) {
      blurh(blurx, temp, values4, width, height);
      blurh(blurx, values4, temp, width, height);
      blurh(blurx, temp, values4, width, height);
      blurv(blury, values4, temp, width, height);
      blurv(blury, temp, values4, width, height);
      blurv(blury, values4, temp, width, height);
    } else if (blurx) {
      blurh(blurx, values4, temp, width, height);
      blurh(blurx, temp, values4, width, height);
      blurh(blurx, values4, temp, width, height);
    } else if (blury) {
      blurv(blury, values4, temp, width, height);
      blurv(blury, temp, values4, width, height);
      blurv(blury, values4, temp, width, height);
    }
    return data;
  };
}
function blurh(blur3, T2, S, w2, h2) {
  for (let y3 = 0, n2 = w2 * h2; y3 < n2; ) {
    blur3(T2, S, y3, y3 += w2, 1);
  }
}
function blurv(blur3, T2, S, w2, h2) {
  for (let x2 = 0, n2 = w2 * h2; x2 < w2; ++x2) {
    blur3(T2, S, x2, x2 + n2, w2);
  }
}
function blurfImage(radius) {
  const blur3 = blurf(radius);
  return (T2, S, start, stop, step) => {
    start <<= 2, stop <<= 2, step <<= 2;
    blur3(T2, S, start + 0, stop + 0, step);
    blur3(T2, S, start + 1, stop + 1, step);
    blur3(T2, S, start + 2, stop + 2, step);
    blur3(T2, S, start + 3, stop + 3, step);
  };
}
function blurf(radius) {
  const radius0 = Math.floor(radius);
  if (radius0 === radius) return bluri(radius);
  const t = radius - radius0;
  const w2 = 2 * radius + 1;
  return (T2, S, start, stop, step) => {
    if (!((stop -= step) >= start)) return;
    let sum4 = radius0 * S[start];
    const s0 = step * radius0;
    const s1 = s0 + step;
    for (let i2 = start, j = start + s0; i2 < j; i2 += step) {
      sum4 += S[Math.min(stop, i2)];
    }
    for (let i2 = start, j = stop; i2 <= j; i2 += step) {
      sum4 += S[Math.min(stop, i2 + s0)];
      T2[i2] = (sum4 + t * (S[Math.max(start, i2 - s1)] + S[Math.min(stop, i2 + s1)])) / w2;
      sum4 -= S[Math.max(start, i2 - s0)];
    }
  };
}
function bluri(radius) {
  const w2 = 2 * radius + 1;
  return (T2, S, start, stop, step) => {
    if (!((stop -= step) >= start)) return;
    let sum4 = radius * S[start];
    const s3 = step * radius;
    for (let i2 = start, j = start + s3; i2 < j; i2 += step) {
      sum4 += S[Math.min(stop, i2)];
    }
    for (let i2 = start, j = stop; i2 <= j; i2 += step) {
      sum4 += S[Math.min(stop, i2 + s3)];
      T2[i2] = sum4 / w2;
      sum4 -= S[Math.max(start, i2 - s3)];
    }
  };
}

// node_modules/d3-array/src/count.js
function count(values4, valueof2) {
  let count4 = 0;
  if (valueof2 === void 0) {
    for (let value2 of values4) {
      if (value2 != null && (value2 = +value2) >= value2) {
        ++count4;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index2, values4)) != null && (value2 = +value2) >= value2) {
        ++count4;
      }
    }
  }
  return count4;
}

// node_modules/d3-array/src/variance.js
function variance(values4, valueof2) {
  let count4 = 0;
  let delta;
  let mean3 = 0;
  let sum4 = 0;
  if (valueof2 === void 0) {
    for (let value2 of values4) {
      if (value2 != null && (value2 = +value2) >= value2) {
        delta = value2 - mean3;
        mean3 += delta / ++count4;
        sum4 += delta * (value2 - mean3);
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index2, values4)) != null && (value2 = +value2) >= value2) {
        delta = value2 - mean3;
        mean3 += delta / ++count4;
        sum4 += delta * (value2 - mean3);
      }
    }
  }
  if (count4 > 1) return sum4 / (count4 - 1);
}

// node_modules/d3-array/src/deviation.js
function deviation(values4, valueof2) {
  const v = variance(values4, valueof2);
  return v ? Math.sqrt(v) : v;
}

// node_modules/d3-array/src/extent.js
function extent(values4, valueof2) {
  let min6;
  let max7;
  if (valueof2 === void 0) {
    for (const value2 of values4) {
      if (value2 != null) {
        if (min6 === void 0) {
          if (value2 >= value2) min6 = max7 = value2;
        } else {
          if (min6 > value2) min6 = value2;
          if (max7 < value2) max7 = value2;
        }
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index2, values4)) != null) {
        if (min6 === void 0) {
          if (value2 >= value2) min6 = max7 = value2;
        } else {
          if (min6 > value2) min6 = value2;
          if (max7 < value2) max7 = value2;
        }
      }
    }
  }
  return [min6, max7];
}

// node_modules/d3-array/src/fsum.js
var Adder = class {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x2) {
    const p3 = this._partials;
    let i2 = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y3 = p3[j], hi = x2 + y3, lo = Math.abs(x2) < Math.abs(y3) ? x2 - (hi - y3) : y3 - (hi - x2);
      if (lo) p3[i2++] = lo;
      x2 = hi;
    }
    p3[i2] = x2;
    this._n = i2 + 1;
    return this;
  }
  valueOf() {
    const p3 = this._partials;
    let n2 = this._n, x2, y3, lo, hi = 0;
    if (n2 > 0) {
      hi = p3[--n2];
      while (n2 > 0) {
        x2 = hi;
        y3 = p3[--n2];
        hi = x2 + y3;
        lo = y3 - (hi - x2);
        if (lo) break;
      }
      if (n2 > 0 && (lo < 0 && p3[n2 - 1] < 0 || lo > 0 && p3[n2 - 1] > 0)) {
        y3 = lo * 2;
        x2 = hi + y3;
        if (y3 == x2 - hi) hi = x2;
      }
    }
    return hi;
  }
};

// node_modules/internmap/src/index.js
var InternMap = class extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null) for (const [key2, value2] of entries) this.set(key2, value2);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value2) {
    return super.set(intern_set(this, key), value2);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
};
function intern_get({ _intern, _key }, value2) {
  const key = _key(value2);
  return _intern.has(key) ? _intern.get(key) : value2;
}
function intern_set({ _intern, _key }, value2) {
  const key = _key(value2);
  if (_intern.has(key)) return _intern.get(key);
  _intern.set(key, value2);
  return value2;
}
function intern_delete({ _intern, _key }, value2) {
  const key = _key(value2);
  if (_intern.has(key)) {
    value2 = _intern.get(key);
    _intern.delete(key);
  }
  return value2;
}
function keyof(value2) {
  return value2 !== null && typeof value2 === "object" ? value2.valueOf() : value2;
}

// node_modules/d3-array/src/identity.js
function identity(x2) {
  return x2;
}

// node_modules/d3-array/src/group.js
function group(values4, ...keys) {
  return nest(values4, identity, identity, keys);
}
function groups(values4, ...keys) {
  return nest(values4, Array.from, identity, keys);
}
function rollup(values4, reduce3, ...keys) {
  return nest(values4, identity, reduce3, keys);
}
function rollups(values4, reduce3, ...keys) {
  return nest(values4, Array.from, reduce3, keys);
}
function nest(values4, map5, reduce3, keys) {
  return function regroup(values5, i2) {
    if (i2 >= keys.length) return reduce3(values5);
    const groups2 = new InternMap();
    const keyof4 = keys[i2++];
    let index2 = -1;
    for (const value2 of values5) {
      const key = keyof4(value2, ++index2, values5);
      const group2 = groups2.get(key);
      if (group2) group2.push(value2);
      else groups2.set(key, [value2]);
    }
    for (const [key, values6] of groups2) {
      groups2.set(key, regroup(values6, i2));
    }
    return map5(groups2);
  }(values4, 0);
}

// node_modules/d3-array/src/permute.js
function permute(source, keys) {
  return Array.from(keys, (key) => source[key]);
}

// node_modules/d3-array/src/sort.js
function sort(values4, ...F) {
  if (typeof values4[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  values4 = Array.from(values4);
  let [f2] = F;
  if (f2 && f2.length !== 2 || F.length > 1) {
    const index2 = Uint32Array.from(values4, (d3, i2) => i2);
    if (F.length > 1) {
      F = F.map((f3) => values4.map(f3));
      index2.sort((i2, j) => {
        for (const f3 of F) {
          const c5 = ascendingDefined(f3[i2], f3[j]);
          if (c5) return c5;
        }
      });
    } else {
      f2 = values4.map(f2);
      index2.sort((i2, j) => ascendingDefined(f2[i2], f2[j]));
    }
    return permute(values4, index2);
  }
  return values4.sort(compareDefined(f2));
}
function compareDefined(compare = ascending) {
  if (compare === ascending) return ascendingDefined;
  if (typeof compare !== "function") throw new TypeError("compare is not a function");
  return (a4, b) => {
    const x2 = compare(a4, b);
    if (x2 || x2 === 0) return x2;
    return (compare(b, b) === 0) - (compare(a4, a4) === 0);
  };
}
function ascendingDefined(a4, b) {
  return (a4 == null || !(a4 >= a4)) - (b == null || !(b >= b)) || (a4 < b ? -1 : a4 > b ? 1 : 0);
}

// node_modules/d3-array/src/groupSort.js
function groupSort(values4, reduce3, key) {
  return (reduce3.length !== 2 ? sort(rollup(values4, reduce3, key), ([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)) : sort(group(values4, key), ([ak, av], [bk, bv]) => reduce3(av, bv) || ascending(ak, bk))).map(([key2]) => key2);
}

// node_modules/d3-array/src/array.js
var array = Array.prototype;
var slice = array.slice;
var map = array.map;

// node_modules/d3-array/src/constant.js
function constant2(x2) {
  return () => x2;
}

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickSpec(start, stop, count4) {
  const step = (stop - start) / Math.max(0, count4), power = Math.floor(Math.log10(step)), error2 = step / Math.pow(10, power), factor = error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start) ++i1;
    if (i2 / inc > stop) --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start) ++i1;
    if (i2 * inc > stop) --i2;
  }
  if (i2 < i1 && 0.5 <= count4 && count4 < 2) return tickSpec(start, stop, count4 * 2);
  return [i1, i2, inc];
}
function ticks(start, stop, count4) {
  stop = +stop, start = +start, count4 = +count4;
  if (!(count4 > 0)) return [];
  if (start === stop) return [start];
  const reverse2 = stop < start, [i1, i2, inc] = reverse2 ? tickSpec(stop, start, count4) : tickSpec(start, stop, count4);
  if (!(i2 >= i1)) return [];
  const n2 = i2 - i1 + 1, ticks2 = new Array(n2);
  if (reverse2) {
    if (inc < 0) for (let i3 = 0; i3 < n2; ++i3) ticks2[i3] = (i2 - i3) / -inc;
    else for (let i3 = 0; i3 < n2; ++i3) ticks2[i3] = (i2 - i3) * inc;
  } else {
    if (inc < 0) for (let i3 = 0; i3 < n2; ++i3) ticks2[i3] = (i1 + i3) / -inc;
    else for (let i3 = 0; i3 < n2; ++i3) ticks2[i3] = (i1 + i3) * inc;
  }
  return ticks2;
}
function tickIncrement(start, stop, count4) {
  stop = +stop, start = +start, count4 = +count4;
  return tickSpec(start, stop, count4)[2];
}

// node_modules/d3-array/src/nice.js
function nice(start, stop, count4) {
  let prestep;
  while (true) {
    const step = tickIncrement(start, stop, count4);
    if (step === prestep || step === 0 || !isFinite(step)) {
      return [start, stop];
    } else if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
    }
    prestep = step;
  }
}

// node_modules/d3-array/src/threshold/sturges.js
function thresholdSturges(values4) {
  return Math.max(1, Math.ceil(Math.log(count(values4)) / Math.LN2) + 1);
}

// node_modules/d3-array/src/bin.js
function bin() {
  var value2 = identity, domain = extent, threshold = thresholdSturges;
  function histogram(data) {
    if (!Array.isArray(data)) data = Array.from(data);
    var i2, n2 = data.length, x2, step, values4 = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) {
      values4[i2] = value2(data[i2], i2, data);
    }
    var xz = domain(values4), x05 = xz[0], x12 = xz[1], tz = threshold(values4, x05, x12);
    if (!Array.isArray(tz)) {
      const max7 = x12, tn = +tz;
      if (domain === extent) [x05, x12] = nice(x05, x12, tn);
      tz = ticks(x05, x12, tn);
      if (tz[0] <= x05) step = tickIncrement(x05, x12, tn);
      if (tz[tz.length - 1] >= x12) {
        if (max7 >= x12 && domain === extent) {
          const step2 = tickIncrement(x05, x12, tn);
          if (isFinite(step2)) {
            if (step2 > 0) {
              x12 = (Math.floor(x12 / step2) + 1) * step2;
            } else if (step2 < 0) {
              x12 = (Math.ceil(x12 * -step2) + 1) / -step2;
            }
          }
        } else {
          tz.pop();
        }
      }
    }
    var m2 = tz.length, a4 = 0, b = m2;
    while (tz[a4] <= x05) ++a4;
    while (tz[b - 1] > x12) --b;
    if (a4 || b < m2) tz = tz.slice(a4, b), m2 = b - a4;
    var bins = new Array(m2 + 1), bin2;
    for (i2 = 0; i2 <= m2; ++i2) {
      bin2 = bins[i2] = [];
      bin2.x0 = i2 > 0 ? tz[i2 - 1] : x05;
      bin2.x1 = i2 < m2 ? tz[i2] : x12;
    }
    if (isFinite(step)) {
      if (step > 0) {
        for (i2 = 0; i2 < n2; ++i2) {
          if ((x2 = values4[i2]) != null && x05 <= x2 && x2 <= x12) {
            bins[Math.min(m2, Math.floor((x2 - x05) / step))].push(data[i2]);
          }
        }
      } else if (step < 0) {
        for (i2 = 0; i2 < n2; ++i2) {
          if ((x2 = values4[i2]) != null && x05 <= x2 && x2 <= x12) {
            const j = Math.floor((x05 - x2) * step);
            bins[Math.min(m2, j + (tz[j] <= x2))].push(data[i2]);
          }
        }
      }
    } else {
      for (i2 = 0; i2 < n2; ++i2) {
        if ((x2 = values4[i2]) != null && x05 <= x2 && x2 <= x12) {
          bins[bisect_default(tz, x2, 0, m2)].push(data[i2]);
        }
      }
    }
    return bins;
  }
  histogram.value = function(_) {
    return arguments.length ? (value2 = typeof _ === "function" ? _ : constant2(_), histogram) : value2;
  };
  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant2([_[0], _[1]]), histogram) : domain;
  };
  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : constant2(Array.isArray(_) ? slice.call(_) : _), histogram) : threshold;
  };
  return histogram;
}

// node_modules/d3-array/src/max.js
function max(values4, valueof2) {
  let max7;
  if (valueof2 === void 0) {
    for (const value2 of values4) {
      if (value2 != null && (max7 < value2 || max7 === void 0 && value2 >= value2)) {
        max7 = value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index2, values4)) != null && (max7 < value2 || max7 === void 0 && value2 >= value2)) {
        max7 = value2;
      }
    }
  }
  return max7;
}

// node_modules/d3-array/src/maxIndex.js
function maxIndex(values4, valueof2) {
  let max7;
  let maxIndex2 = -1;
  let index2 = -1;
  if (valueof2 === void 0) {
    for (const value2 of values4) {
      ++index2;
      if (value2 != null && (max7 < value2 || max7 === void 0 && value2 >= value2)) {
        max7 = value2, maxIndex2 = index2;
      }
    }
  } else {
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index2, values4)) != null && (max7 < value2 || max7 === void 0 && value2 >= value2)) {
        max7 = value2, maxIndex2 = index2;
      }
    }
  }
  return maxIndex2;
}

// node_modules/d3-array/src/min.js
function min(values4, valueof2) {
  let min6;
  if (valueof2 === void 0) {
    for (const value2 of values4) {
      if (value2 != null && (min6 > value2 || min6 === void 0 && value2 >= value2)) {
        min6 = value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index2, values4)) != null && (min6 > value2 || min6 === void 0 && value2 >= value2)) {
        min6 = value2;
      }
    }
  }
  return min6;
}

// node_modules/d3-array/src/minIndex.js
function minIndex(values4, valueof2) {
  let min6;
  let minIndex2 = -1;
  let index2 = -1;
  if (valueof2 === void 0) {
    for (const value2 of values4) {
      ++index2;
      if (value2 != null && (min6 > value2 || min6 === void 0 && value2 >= value2)) {
        min6 = value2, minIndex2 = index2;
      }
    }
  } else {
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index2, values4)) != null && (min6 > value2 || min6 === void 0 && value2 >= value2)) {
        min6 = value2, minIndex2 = index2;
      }
    }
  }
  return minIndex2;
}

// node_modules/d3-array/src/quickselect.js
function quickselect(array2, k2, left2 = 0, right2 = Infinity, compare) {
  k2 = Math.floor(k2);
  left2 = Math.floor(Math.max(0, left2));
  right2 = Math.floor(Math.min(array2.length - 1, right2));
  if (!(left2 <= k2 && k2 <= right2)) return array2;
  compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
  while (right2 > left2) {
    if (right2 - left2 > 600) {
      const n2 = right2 - left2 + 1;
      const m2 = k2 - left2 + 1;
      const z = Math.log(n2);
      const s3 = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s3 * (n2 - s3) / n2) * (m2 - n2 / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left2, Math.floor(k2 - m2 * s3 / n2 + sd));
      const newRight = Math.min(right2, Math.floor(k2 + (n2 - m2) * s3 / n2 + sd));
      quickselect(array2, k2, newLeft, newRight, compare);
    }
    const t = array2[k2];
    let i2 = left2;
    let j = right2;
    swap(array2, left2, k2);
    if (compare(array2[right2], t) > 0) swap(array2, left2, right2);
    while (i2 < j) {
      swap(array2, i2, j), ++i2, --j;
      while (compare(array2[i2], t) < 0) ++i2;
      while (compare(array2[j], t) > 0) --j;
    }
    if (compare(array2[left2], t) === 0) swap(array2, left2, j);
    else ++j, swap(array2, j, right2);
    if (j <= k2) left2 = j + 1;
    if (k2 <= j) right2 = j - 1;
  }
  return array2;
}
function swap(array2, i2, j) {
  const t = array2[i2];
  array2[i2] = array2[j];
  array2[j] = t;
}

// node_modules/d3-array/src/greatest.js
function greatest(values4, compare = ascending) {
  let max7;
  let defined3 = false;
  if (compare.length === 1) {
    let maxValue;
    for (const element of values4) {
      const value2 = compare(element);
      if (defined3 ? ascending(value2, maxValue) > 0 : ascending(value2, value2) === 0) {
        max7 = element;
        maxValue = value2;
        defined3 = true;
      }
    }
  } else {
    for (const value2 of values4) {
      if (defined3 ? compare(value2, max7) > 0 : compare(value2, value2) === 0) {
        max7 = value2;
        defined3 = true;
      }
    }
  }
  return max7;
}

// node_modules/d3-array/src/quantile.js
function quantile(values4, p3, valueof2) {
  values4 = Float64Array.from(numbers(values4, valueof2));
  if (!(n2 = values4.length) || isNaN(p3 = +p3)) return;
  if (p3 <= 0 || n2 < 2) return min(values4);
  if (p3 >= 1) return max(values4);
  var n2, i2 = (n2 - 1) * p3, i0 = Math.floor(i2), value0 = max(quickselect(values4, i0).subarray(0, i0 + 1)), value1 = min(values4.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i2 - i0);
}
function quantileIndex(values4, p3, valueof2 = number) {
  if (isNaN(p3 = +p3)) return;
  numbers2 = Float64Array.from(values4, (_, i3) => number(valueof2(values4[i3], i3, values4)));
  if (p3 <= 0) return minIndex(numbers2);
  if (p3 >= 1) return maxIndex(numbers2);
  var numbers2, index2 = Uint32Array.from(values4, (_, i3) => i3), j = numbers2.length - 1, i2 = Math.floor(j * p3);
  quickselect(index2, i2, 0, j, (i3, j2) => ascendingDefined(numbers2[i3], numbers2[j2]));
  i2 = greatest(index2.subarray(0, i2 + 1), (i3) => numbers2[i3]);
  return i2 >= 0 ? i2 : -1;
}

// node_modules/d3-array/src/threshold/scott.js
function thresholdScott(values4, min6, max7) {
  const c5 = count(values4), d3 = deviation(values4);
  return c5 && d3 ? Math.ceil((max7 - min6) * Math.cbrt(c5) / (3.49 * d3)) : 1;
}

// node_modules/d3-array/src/mean.js
function mean(values4, valueof2) {
  let count4 = 0;
  let sum4 = 0;
  if (valueof2 === void 0) {
    for (let value2 of values4) {
      if (value2 != null && (value2 = +value2) >= value2) {
        ++count4, sum4 += value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index2, values4)) != null && (value2 = +value2) >= value2) {
        ++count4, sum4 += value2;
      }
    }
  }
  if (count4) return sum4 / count4;
}

// node_modules/d3-array/src/median.js
function median(values4, valueof2) {
  return quantile(values4, 0.5, valueof2);
}
function medianIndex(values4, valueof2) {
  return quantileIndex(values4, 0.5, valueof2);
}

// node_modules/d3-array/src/merge.js
function* flatten(arrays) {
  for (const array2 of arrays) {
    yield* __yieldStar(array2);
  }
}
function merge(arrays) {
  return Array.from(flatten(arrays));
}

// node_modules/d3-array/src/range.js
function range(start, stop, step) {
  start = +start, stop = +stop, step = (n2 = arguments.length) < 2 ? (stop = start, start = 0, 1) : n2 < 3 ? 1 : +step;
  var i2 = -1, n2 = Math.max(0, Math.ceil((stop - start) / step)) | 0, range3 = new Array(n2);
  while (++i2 < n2) {
    range3[i2] = start + i2 * step;
  }
  return range3;
}

// node_modules/d3-array/src/shuffle.js
var shuffle_default = shuffler(Math.random);
function shuffler(random) {
  return function shuffle2(array2, i0 = 0, i1 = array2.length) {
    let m2 = i1 - (i0 = +i0);
    while (m2) {
      const i2 = random() * m2-- | 0, t = array2[m2 + i0];
      array2[m2 + i0] = array2[i2 + i0];
      array2[i2 + i0] = t;
    }
    return array2;
  };
}

// node_modules/d3-array/src/sum.js
function sum(values4, valueof2) {
  let sum4 = 0;
  if (valueof2 === void 0) {
    for (let value2 of values4) {
      if (value2 = +value2) {
        sum4 += value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values4) {
      if (value2 = +valueof2(value2, ++index2, values4)) {
        sum4 += value2;
      }
    }
  }
  return sum4;
}

// node_modules/@antv/scale/esm/utils/compose.js
function compose(fn, ...rest) {
  return rest.reduce((pre, cur) => (x2) => pre(cur(x2)), fn);
}

// node_modules/@antv/scale/esm/utils/normalize.js
function createNormalize(a4, b) {
  return b - a4 ? (t) => (t - a4) / (b - a4) : (_) => 0.5;
}

// node_modules/@antv/scale/esm/utils/clamp.js
function createClamp(a4, b) {
  const lo = b < a4 ? b : a4;
  const hi = a4 > b ? a4 : b;
  return (x2) => Math.min(Math.max(lo, x2), hi);
}

// node_modules/@antv/scale/esm/utils/bisect.js
function bisect(array2, x2, lo, hi, getter) {
  let i2 = lo || 0;
  let j = hi || array2.length;
  const get3 = getter || ((x3) => x3);
  while (i2 < j) {
    const mid2 = Math.floor((i2 + j) / 2);
    if (get3(array2[mid2]) > x2) {
      j = mid2;
    } else {
      i2 = mid2 + 1;
    }
  }
  return i2;
}

// node_modules/@antv/scale/esm/utils/ticks.js
var e102 = Math.sqrt(50);
var e52 = Math.sqrt(10);
var e22 = Math.sqrt(2);
function tickIncrement2(start, stop, count4) {
  const step = (stop - start) / Math.max(0, count4);
  const power = Math.floor(Math.log(step) / Math.LN10);
  const error2 = step / __pow(10, power);
  if (power >= 0) {
    return (error2 >= e102 ? 10 : error2 >= e52 ? 5 : error2 >= e22 ? 2 : 1) * __pow(10, power);
  }
  return -__pow(10, -power) / (error2 >= e102 ? 10 : error2 >= e52 ? 5 : error2 >= e22 ? 2 : 1);
}
function tickStep2(start, stop, count4) {
  const step0 = Math.abs(stop - start) / Math.max(0, count4);
  let step1 = __pow(10, Math.floor(Math.log(step0) / Math.LN10));
  const error2 = step0 / step1;
  if (error2 >= e102)
    step1 *= 10;
  else if (error2 >= e52)
    step1 *= 5;
  else if (error2 >= e22)
    step1 *= 2;
  return stop < start ? -step1 : step1;
}

// node_modules/@antv/scale/esm/utils/d3-linear-nice.js
var d3LinearNice = (min6, max7, count4 = 5) => {
  const d3 = [min6, max7];
  let i0 = 0;
  let i1 = d3.length - 1;
  let start = d3[i0];
  let stop = d3[i1];
  let step;
  if (stop < start) {
    [start, stop] = [stop, start];
    [i0, i1] = [i1, i0];
  }
  step = tickIncrement2(start, stop, count4);
  if (step > 0) {
    start = Math.floor(start / step) * step;
    stop = Math.ceil(stop / step) * step;
    step = tickIncrement2(start, stop, count4);
  } else if (step < 0) {
    start = Math.ceil(start * step) / step;
    stop = Math.floor(stop * step) / step;
    step = tickIncrement2(start, stop, count4);
  }
  if (step > 0) {
    d3[i0] = Math.floor(start / step) * step;
    d3[i1] = Math.ceil(stop / step) * step;
  } else if (step < 0) {
    d3[i0] = Math.ceil(start * step) / step;
    d3[i1] = Math.floor(stop * step) / step;
  }
  return d3;
};

// node_modules/@antv/scale/esm/utils/time-interval.js
var DURATION_SECOND = 1e3;
var DURATION_MINUTE = DURATION_SECOND * 60;
var DURATION_HOUR = DURATION_MINUTE * 60;
var DURATION_DAY = DURATION_HOUR * 24;
var DURATION_WEEK = DURATION_DAY * 7;
var DURATION_MONTH = DURATION_DAY * 30;
var DURATION_YEAR = DURATION_DAY * 365;
function createInterval(duration, floorish, offseti, field3) {
  const adjust = (date, step) => {
    const test = (date2) => field3(date2) % step === 0;
    let i2 = step;
    while (i2 && !test(date)) {
      offseti(date, -1);
      i2 -= 1;
    }
    return date;
  };
  const floori = (date, step) => {
    if (step)
      adjust(date, step);
    floorish(date);
  };
  const floor = (date, step) => {
    const d3 = /* @__PURE__ */ new Date(+date);
    floori(d3, step);
    return d3;
  };
  const ceil3 = (date, step) => {
    const d3 = new Date(+date - 1);
    floori(d3, step);
    offseti(d3, step);
    floori(d3);
    return d3;
  };
  const range3 = (start, stop, step, shouldAdjust) => {
    const ticks2 = [];
    const roundStep = Math.floor(step);
    const t = shouldAdjust ? ceil3(start, step) : ceil3(start);
    for (let i2 = t; i2 < stop; offseti(i2, roundStep), floori(i2)) {
      ticks2.push(/* @__PURE__ */ new Date(+i2));
    }
    return ticks2;
  };
  return {
    ceil: ceil3,
    floor,
    range: range3,
    duration
  };
}
var millisecond = createInterval(1, (date) => date, (date, step = 1) => {
  date.setTime(+date + step);
}, (date) => date.getTime());
var second = createInterval(DURATION_SECOND, (date) => {
  date.setMilliseconds(0);
}, (date, step = 1) => {
  date.setTime(+date + DURATION_SECOND * step);
}, (date) => date.getSeconds());
var minute = createInterval(DURATION_MINUTE, (date) => {
  date.setSeconds(0, 0);
}, (date, step = 1) => {
  date.setTime(+date + DURATION_MINUTE * step);
}, (date) => date.getMinutes());
var hour = createInterval(DURATION_HOUR, (date) => {
  date.setMinutes(0, 0, 0);
}, (date, step = 1) => {
  date.setTime(+date + DURATION_HOUR * step);
}, (date) => date.getHours());
var day = createInterval(DURATION_DAY, (date) => {
  date.setHours(0, 0, 0, 0);
}, (date, step = 1) => {
  date.setTime(+date + DURATION_DAY * step);
}, (date) => date.getDate() - 1);
var month = createInterval(DURATION_MONTH, (date) => {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, (date, step = 1) => {
  const month3 = date.getMonth();
  date.setMonth(month3 + step);
}, (date) => date.getMonth());
var week = createInterval(DURATION_WEEK, (date) => {
  date.setDate(date.getDate() - date.getDay() % 7);
  date.setHours(0, 0, 0, 0);
}, (date, step = 1) => {
  date.setDate(date.getDate() + 7 * step);
}, (date) => {
  const start = month.floor(date);
  const end = /* @__PURE__ */ new Date(+date);
  return Math.floor((+end - +start) / DURATION_WEEK);
});
var year = createInterval(DURATION_YEAR, (date) => {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, (date, step = 1) => {
  const year3 = date.getFullYear();
  date.setFullYear(year3 + step);
}, (date) => date.getFullYear());
var localIntervalMap = {
  millisecond,
  second,
  minute,
  hour,
  day,
  week,
  month,
  year
};

// node_modules/@antv/scale/esm/utils/utc-interval.js
var utcMillisecond = createInterval(1, (date) => date, (date, step = 1) => {
  date.setTime(+date + step);
}, (date) => date.getTime());
var utcSecond = createInterval(DURATION_SECOND, (date) => {
  date.setUTCMilliseconds(0);
}, (date, step = 1) => {
  date.setTime(+date + DURATION_SECOND * step);
}, (date) => date.getUTCSeconds());
var utcMinute = createInterval(DURATION_MINUTE, (date) => {
  date.setUTCSeconds(0, 0);
}, (date, step = 1) => {
  date.setTime(+date + DURATION_MINUTE * step);
}, (date) => date.getUTCMinutes());
var utcHour = createInterval(DURATION_HOUR, (date) => {
  date.setUTCMinutes(0, 0, 0);
}, (date, step = 1) => {
  date.setTime(+date + DURATION_HOUR * step);
}, (date) => date.getUTCHours());
var utcDay = createInterval(DURATION_DAY, (date) => {
  date.setUTCHours(0, 0, 0, 0);
}, (date, step = 1) => {
  date.setTime(+date + DURATION_DAY * step);
}, (date) => date.getUTCDate() - 1);
var utcMonth = createInterval(DURATION_MONTH, (date) => {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step = 1) => {
  const month3 = date.getUTCMonth();
  date.setUTCMonth(month3 + step);
}, (date) => date.getUTCMonth());
var utcWeek = createInterval(DURATION_WEEK, (date) => {
  date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7) % 7);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step = 1) => {
  date.setTime(+date + DURATION_WEEK * step);
}, (date) => {
  const start = utcMonth.floor(date);
  const end = /* @__PURE__ */ new Date(+date);
  return Math.floor((+end - +start) / DURATION_WEEK);
});
var utcYear = createInterval(DURATION_YEAR, (date) => {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step = 1) => {
  const year3 = date.getUTCFullYear();
  date.setUTCFullYear(year3 + step);
}, (date) => date.getUTCFullYear());
var utcIntervalMap = {
  millisecond: utcMillisecond,
  second: utcSecond,
  minute: utcMinute,
  hour: utcHour,
  day: utcDay,
  week: utcWeek,
  month: utcMonth,
  year: utcYear
};

// node_modules/@antv/scale/esm/utils/find-tick-interval.js
function chooseTickIntervals(utc) {
  const intervalMap = utc ? utcIntervalMap : localIntervalMap;
  const { year: year3, month: month3, week: week3, day: day3, hour: hour3, minute: minute3, second: second3, millisecond: millisecond3 } = intervalMap;
  const tickIntervals = [
    [second3, 1],
    [second3, 5],
    [second3, 15],
    [second3, 30],
    [minute3, 1],
    [minute3, 5],
    [minute3, 15],
    [minute3, 30],
    [hour3, 1],
    [hour3, 3],
    [hour3, 6],
    [hour3, 12],
    [day3, 1],
    [day3, 2],
    [week3, 1],
    [month3, 1],
    [month3, 3],
    [year3, 1]
  ];
  return {
    tickIntervals,
    year: year3,
    millisecond: millisecond3
  };
}
function findTickInterval(start, stop, count4, interval, utc) {
  const lo = +start;
  const hi = +stop;
  const { tickIntervals, year: year3, millisecond: millisecond3 } = chooseTickIntervals(utc);
  const getter = ([interval2, count5]) => interval2.duration * count5;
  const targetCount = interval ? (hi - lo) / interval : count4 || 5;
  const targetInterval = interval || (hi - lo) / targetCount;
  const len = tickIntervals.length;
  const i2 = bisect(tickIntervals, targetInterval, 0, len, getter);
  let matchInterval;
  if (i2 === len) {
    const step = tickStep2(lo / year3.duration, hi / year3.duration, targetCount);
    matchInterval = [year3, step];
  } else if (i2) {
    const closeToLow = targetInterval / getter(tickIntervals[i2 - 1]) < getter(tickIntervals[i2]) / targetInterval;
    const [timeInterval, targetStep] = closeToLow ? tickIntervals[i2 - 1] : tickIntervals[i2];
    const step = interval ? Math.ceil(interval / timeInterval.duration) : targetStep;
    matchInterval = [timeInterval, step];
  } else {
    const step = Math.max(tickStep2(lo, hi, targetCount), 1);
    matchInterval = [millisecond3, step];
  }
  return matchInterval;
}

// node_modules/@antv/scale/esm/utils/d3-time-nice.js
var d3TimeNice = (min6, max7, count4, interval, utc) => {
  const r2 = min6 > max7;
  const lo = r2 ? max7 : min6;
  const hi = r2 ? min6 : max7;
  const [tickInterval, step] = findTickInterval(lo, hi, count4, interval, utc);
  const domain = [tickInterval.floor(lo, step), tickInterval.ceil(hi, step)];
  return r2 ? domain.reverse() : domain;
};

// node_modules/@antv/scale/esm/utils/is-valid.js
function isValid(x2) {
  return !is_undefined_default(x2) && !isNull(x2) && !Number.isNaN(x2);
}

// node_modules/@antv/scale/esm/utils/log.js
var reflect = (f2) => {
  return (x2) => -f2(-x2);
};
var logs = (base, shouldReflect) => {
  const baseCache = Math.log(base);
  const log2 = base === Math.E ? Math.log : base === 10 ? Math.log10 : base === 2 ? Math.log2 : (x2) => Math.log(x2) / baseCache;
  return shouldReflect ? reflect(log2) : log2;
};
var pows = (base, shouldReflect) => {
  const pow2 = base === Math.E ? Math.exp : (x2) => __pow(base, x2);
  return shouldReflect ? reflect(pow2) : pow2;
};

// node_modules/@antv/scale/esm/utils/d3-log-nice.js
var d3LogNice = (a4, b, _, base) => {
  const shouldReflect = a4 < 0;
  const log2 = logs(base, shouldReflect);
  const pow2 = pows(base, shouldReflect);
  const r2 = a4 > b;
  const min6 = r2 ? b : a4;
  const max7 = r2 ? a4 : b;
  const niceDomain = [pow2(Math.floor(log2(min6))), pow2(Math.ceil(log2(max7)))];
  return r2 ? niceDomain.reverse() : niceDomain;
};

// node_modules/@antv/scale/esm/utils/interpolatize.js
var createInterpolatorRound = (interpolator) => {
  return (t) => {
    const res = interpolator(t);
    return isNumber(res) ? Math.round(res) : res;
  };
};
function interpolatize(rangeOf7, normalizeDomain5) {
  return (Scale) => {
    Scale.prototype.rescale = function() {
      this.initRange();
      this.nice();
      const [transform2] = this.chooseTransforms();
      this.composeOutput(transform2, this.chooseClamp(transform2));
    };
    Scale.prototype.initRange = function() {
      const { interpolator } = this.options;
      this.options.range = rangeOf7(interpolator);
    };
    Scale.prototype.composeOutput = function(transform2, clamp2) {
      const { domain, interpolator, round: round2 } = this.getOptions();
      const normalize5 = normalizeDomain5(domain.map(transform2));
      const interpolate2 = round2 ? createInterpolatorRound(interpolator) : interpolator;
      this.output = compose(interpolate2, normalize5, clamp2, transform2);
    };
    Scale.prototype.invert = void 0;
  };
}

// node_modules/@antv/scale/esm/utils/color.js
var import_color_string = __toESM(require_color_string());
function hue2rgb(p3, q, m2) {
  let t = m2;
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p3 + (q - p3) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p3 + (q - p3) * (2 / 3 - t) * 6;
  return p3;
}
function hsl2rbg(hsl) {
  const h2 = hsl[0] / 360;
  const s3 = hsl[1] / 100;
  const l2 = hsl[2] / 100;
  const a4 = hsl[3];
  if (s3 === 0)
    return [l2 * 255, l2 * 255, l2 * 255, a4];
  const q = l2 < 0.5 ? l2 * (1 + s3) : l2 + s3 - l2 * s3;
  const p3 = 2 * l2 - q;
  const r2 = hue2rgb(p3, q, h2 + 1 / 3);
  const g = hue2rgb(p3, q, h2);
  const b = hue2rgb(p3, q, h2 - 1 / 3);
  return [r2 * 255, g * 255, b * 255, a4];
}
function string2rbg(s3) {
  const color = import_color_string.default.get(s3);
  if (!color)
    return null;
  const { model, value: value2 } = color;
  if (model === "rgb")
    return value2;
  if (model === "hsl")
    return hsl2rbg(value2);
  return null;
}

// node_modules/@antv/scale/esm/utils/interpolate.js
var createInterpolateNumber = (a4, b) => {
  return (t) => a4 * (1 - t) + b * t;
};
var createInterpolateColor = (a4, b) => {
  const c1 = string2rbg(a4);
  const c22 = string2rbg(b);
  if (c1 === null || c22 === null)
    return c1 ? () => a4 : () => b;
  return (t) => {
    const values4 = new Array(4);
    for (let i2 = 0; i2 < 4; i2 += 1) {
      const from = c1[i2];
      const to = c22[i2];
      values4[i2] = from * (1 - t) + to * t;
    }
    const [r2, g, b2, a5] = values4;
    return `rgba(${Math.round(r2)}, ${Math.round(g)}, ${Math.round(b2)}, ${a5})`;
  };
};
var createInterpolateValue = (a4, b) => {
  if (typeof a4 === "number" && typeof b === "number")
    return createInterpolateNumber(a4, b);
  if (typeof a4 === "string" && typeof b === "string")
    return createInterpolateColor(a4, b);
  return () => a4;
};
var createInterpolateRound = (a4, b) => {
  const interpolateNumber = createInterpolateNumber(a4, b);
  return (t) => Math.round(interpolateNumber(t));
};

// node_modules/@antv/scale/esm/utils/choose-mask.js
function chooseNiceTimeMask(date, intervalMap) {
  const { second: second3, minute: minute3, hour: hour3, day: day3, week: week3, month: month3, year: year3 } = intervalMap;
  if (second3.floor(date) < date)
    return ".SSS";
  if (minute3.floor(date) < date)
    return ":ss";
  if (hour3.floor(date) < date)
    return "hh:mm";
  if (day3.floor(date) < date)
    return "hh A";
  if (month3.floor(date) < date) {
    if (week3.floor(date) < date)
      return "MMM DD";
    return "ddd DD";
  }
  if (year3.floor(date) < date)
    return "MMMM";
  return "YYYY";
}

// node_modules/@antv/scale/esm/utils/internMap.js
function internGet({ map: map5, initKey }, value2) {
  const key = initKey(value2);
  return map5.has(key) ? map5.get(key) : value2;
}
function internSet({ map: map5, initKey }, value2) {
  const key = initKey(value2);
  if (map5.has(key))
    return map5.get(key);
  map5.set(key, value2);
  return value2;
}
function internDelete({ map: map5, initKey }, value2) {
  const key = initKey(value2);
  if (map5.has(key)) {
    value2 = map5.get(key);
    map5.delete(key);
  }
  return value2;
}
function keyof2(value2) {
  return typeof value2 === "object" ? value2.valueOf() : value2;
}
var InternMap2 = class extends Map {
  constructor(entries) {
    super();
    this.map = /* @__PURE__ */ new Map();
    this.initKey = keyof2;
    if (entries !== null) {
      for (const [key, value2] of entries) {
        this.set(key, value2);
      }
    }
  }
  get(key) {
    return super.get(internGet({ map: this.map, initKey: this.initKey }, key));
  }
  has(key) {
    return super.has(internGet({ map: this.map, initKey: this.initKey }, key));
  }
  set(key, value2) {
    return super.set(internSet({ map: this.map, initKey: this.initKey }, key), value2);
  }
  delete(key) {
    return super.delete(internDelete({ map: this.map, initKey: this.initKey }, key));
  }
};

// node_modules/@antv/scale/esm/scales/base.js
var Base = class {
  /**
   * 
   */
  transformBreaks(options) {
    return options;
  }
  /**
   * 
   * @param options 
   */
  constructor(options) {
    var _a;
    this.options = deep_mix_default({}, this.getDefaultOptions());
    this.update(((_a = options === null || options === void 0 ? void 0 : options.breaks) === null || _a === void 0 ? void 0 : _a.length) ? this.transformBreaks(options) : options);
  }
  /**
   * 
   * @returns 
   */
  getOptions() {
    return this.options;
  }
  /**
   * 
   * @param updateOptions 
   */
  update(updateOptions = {}) {
    const options = updateOptions.breaks ? this.transformBreaks(updateOptions) : updateOptions;
    this.options = deep_mix_default({}, this.options, options);
    this.rescale(options);
  }
  /**
   *  options  options  scale 
   *  this.options  options
   * @param options  options
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  rescale(options) {
  }
};

// node_modules/@antv/scale/esm/scales/ordinal.js
var defaultUnknown = Symbol("defaultUnknown");
function updateIndexMap(target, arr, key) {
  for (let i2 = 0; i2 < arr.length; i2 += 1) {
    if (!target.has(arr[i2])) {
      target.set(key(arr[i2]), i2);
    }
  }
}
function mapBetweenArrByMapIndex(options) {
  const { value: value2, from, to, mapper, notFoundReturn } = options;
  let mappedIndex = mapper.get(value2);
  if (mappedIndex === void 0) {
    if (notFoundReturn !== defaultUnknown) {
      return notFoundReturn;
    }
    mappedIndex = from.push(value2) - 1;
    mapper.set(value2, mappedIndex);
  }
  return to[mappedIndex % to.length];
}
function createKey(d3) {
  if (d3 instanceof Date)
    return (d4) => `${d4}`;
  if (typeof d3 === "object")
    return (d4) => JSON.stringify(d4);
  return (d4) => d4;
}
var Ordinal = class _Ordinal extends Base {
  // 
  getDefaultOptions() {
    return {
      domain: [],
      range: [],
      unknown: defaultUnknown
    };
  }
  //  options  OrdinalOptions O 
  constructor(options) {
    super(options);
  }
  map(x2) {
    if (this.domainIndexMap.size === 0) {
      updateIndexMap(this.domainIndexMap, this.getDomain(), this.domainKey);
    }
    return mapBetweenArrByMapIndex({
      value: this.domainKey(x2),
      mapper: this.domainIndexMap,
      from: this.getDomain(),
      to: this.getRange(),
      notFoundReturn: this.options.unknown
    });
  }
  invert(y3) {
    if (this.rangeIndexMap.size === 0) {
      updateIndexMap(this.rangeIndexMap, this.getRange(), this.rangeKey);
    }
    return mapBetweenArrByMapIndex({
      value: this.rangeKey(y3),
      mapper: this.rangeIndexMap,
      from: this.getRange(),
      to: this.getDomain(),
      notFoundReturn: this.options.unknown
    });
  }
  //  ordinal 
  rescale(options) {
    const [d3] = this.options.domain;
    const [r2] = this.options.range;
    this.domainKey = createKey(d3);
    this.rangeKey = createKey(r2);
    if (!this.rangeIndexMap) {
      this.rangeIndexMap = /* @__PURE__ */ new Map();
      this.domainIndexMap = /* @__PURE__ */ new Map();
      return;
    }
    if (!options || options.range) {
      this.rangeIndexMap.clear();
    }
    if (!options || options.domain || options.compare) {
      this.domainIndexMap.clear();
      this.sortedDomain = void 0;
    }
  }
  clone() {
    return new _Ordinal(this.options);
  }
  getRange() {
    return this.options.range;
  }
  getDomain() {
    if (this.sortedDomain)
      return this.sortedDomain;
    const { domain, compare } = this.options;
    this.sortedDomain = compare ? [...domain].sort(compare) : domain;
    return this.sortedDomain;
  }
};

// node_modules/@antv/scale/esm/scales/band.js
function normalize(array2) {
  const min6 = array2.reduce((a4, b) => Math.min(a4, b), Infinity);
  return min6 === Infinity ? [] : array2.map((d3) => d3 / min6);
}
function splice(array2, n2) {
  const sn = array2.length;
  const diff = n2 - sn;
  return diff > 0 ? [...array2, ...new Array(diff).fill(1)] : diff < 0 ? array2.slice(0, n2) : array2;
}
function pretty(n2) {
  return Math.round(n2 * 1e12) / 1e12;
}
function computeFlexBandState(options) {
  const { domain, range: range3, paddingOuter, paddingInner, flex: F, round: round2, align } = options;
  const n2 = domain.length;
  const flex = splice(F, n2);
  const [start, end] = range3;
  const width = end - start;
  const ratio = 2 / n2 * paddingOuter + 1 - 1 / n2 * paddingInner;
  const stepSum = width / ratio;
  const PI = stepSum * paddingInner / n2;
  const bandWidthSum = stepSum - n2 * PI;
  const normalizedFlex = normalize(flex);
  const flexSum = normalizedFlex.reduce((sum4, value2) => sum4 + value2);
  const minBandWidth = bandWidthSum / flexSum;
  const valueBandWidth = new InternMap2(domain.map((d3, i2) => {
    const bandWidth3 = normalizedFlex[i2] * minBandWidth;
    return [d3, round2 ? Math.floor(bandWidth3) : bandWidth3];
  }));
  const valueStep = new InternMap2(domain.map((d3, i2) => {
    const bandWidth3 = normalizedFlex[i2] * minBandWidth;
    const step = bandWidth3 + PI;
    return [d3, round2 ? Math.floor(step) : step];
  }));
  const finalStepSum = Array.from(valueStep.values()).reduce((sum4, value2) => sum4 + value2);
  const outerPaddingSum = width - (finalStepSum - finalStepSum / n2 * paddingInner);
  const offset2 = outerPaddingSum * align;
  const bandStart = start + offset2;
  let prev = round2 ? Math.round(bandStart) : bandStart;
  const adjustedRange = new Array(n2);
  for (let i2 = 0; i2 < n2; i2 += 1) {
    adjustedRange[i2] = pretty(prev);
    const value2 = domain[i2];
    prev += valueStep.get(value2);
  }
  return {
    valueBandWidth,
    valueStep,
    adjustedRange
  };
}
function computeBandState(options) {
  var _a;
  const { domain } = options;
  const n2 = domain.length;
  if (n2 === 0) {
    return {
      valueBandWidth: void 0,
      valueStep: void 0,
      adjustedRange: []
    };
  }
  const hasFlex = !!((_a = options.flex) === null || _a === void 0 ? void 0 : _a.length);
  if (hasFlex) {
    return computeFlexBandState(options);
  }
  const { range: range3, paddingOuter, paddingInner, round: round2, align } = options;
  let step;
  let bandWidth3;
  let rangeStart = range3[0];
  const rangeEnd = range3[1];
  const deltaRange = rangeEnd - rangeStart;
  const outerTotal = paddingOuter * 2;
  const innerTotal = n2 - paddingInner;
  step = deltaRange / Math.max(1, outerTotal + innerTotal);
  if (round2) {
    step = Math.floor(step);
  }
  rangeStart += (deltaRange - step * (n2 - paddingInner)) * align;
  bandWidth3 = step * (1 - paddingInner);
  if (round2) {
    rangeStart = Math.round(rangeStart);
    bandWidth3 = Math.round(bandWidth3);
  }
  const adjustedRange = new Array(n2).fill(0).map((_, i2) => rangeStart + i2 * step);
  return {
    valueStep: step,
    valueBandWidth: bandWidth3,
    adjustedRange
  };
}
var Band = class _Band extends Ordinal {
  // 
  getDefaultOptions() {
    return {
      domain: [],
      range: [0, 1],
      align: 0.5,
      round: false,
      paddingInner: 0,
      paddingOuter: 0,
      padding: 0,
      unknown: defaultUnknown,
      flex: []
    };
  }
  //  options  OrdinalOptions O 
  constructor(options) {
    super(options);
  }
  clone() {
    return new _Band(this.options);
  }
  getStep(x2) {
    if (this.valueStep === void 0)
      return 1;
    if (typeof this.valueStep === "number") {
      return this.valueStep;
    }
    if (x2 === void 0)
      return Array.from(this.valueStep.values())[0];
    return this.valueStep.get(x2);
  }
  getBandWidth(x2) {
    if (this.valueBandWidth === void 0)
      return 1;
    if (typeof this.valueBandWidth === "number") {
      return this.valueBandWidth;
    }
    if (x2 === void 0)
      return Array.from(this.valueBandWidth.values())[0];
    return this.valueBandWidth.get(x2);
  }
  getRange() {
    return this.adjustedRange;
  }
  getPaddingInner() {
    const { padding, paddingInner } = this.options;
    return padding > 0 ? padding : paddingInner;
  }
  getPaddingOuter() {
    const { padding, paddingOuter } = this.options;
    return padding > 0 ? padding : paddingOuter;
  }
  rescale() {
    super.rescale();
    const { align, domain, range: range3, round: round2, flex } = this.options;
    const { adjustedRange, valueBandWidth, valueStep } = computeBandState({
      align,
      range: range3,
      round: round2,
      flex,
      paddingInner: this.getPaddingInner(),
      paddingOuter: this.getPaddingOuter(),
      domain
    });
    this.valueStep = valueStep;
    this.valueBandWidth = valueBandWidth;
    this.adjustedRange = adjustedRange;
  }
};

// node_modules/@antv/scale/esm/tick-methods/d3-ticks.js
var insertBreaksToTicks = (ticks2, breaks) => {
  if (!(breaks === null || breaks === void 0 ? void 0 : breaks.length))
    return ticks2;
  const edgePoints = [...ticks2, ...breaks.flatMap((b) => [b.start, b.end])];
  const uniqueSortedTicks = Array.from(new Set(edgePoints)).sort((a4, b) => a4 - b);
  const filteredTicks = uniqueSortedTicks.filter((tick2) => !breaks.some(({ start, end }) => tick2 > start && tick2 < end));
  return filteredTicks.length ? filteredTicks : ticks2;
};
var d3Ticks = (begin, end, count4, breaks) => {
  let n2;
  let ticks2;
  let start = begin;
  let stop = end;
  if (start === stop && count4 > 0) {
    return [start];
  }
  let step = tickIncrement2(start, stop, count4);
  if (step === 0 || !Number.isFinite(step)) {
    return [];
  }
  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks2 = new Array(n2 = Math.ceil(stop - start + 1));
    for (let i2 = 0; i2 < n2; i2 += 1) {
      ticks2[i2] = (start + i2) * step;
    }
  } else {
    step = -step;
    start = Math.ceil(start * step);
    stop = Math.floor(stop * step);
    ticks2 = new Array(n2 = Math.ceil(stop - start + 1));
    for (let i2 = 0; i2 < n2; i2 += 1) {
      ticks2[i2] = (start + i2) / step;
    }
  }
  return insertBreaksToTicks(ticks2, breaks);
};

// node_modules/@antv/scale/esm/scales/constant.js
var Constant2 = class _Constant extends Base {
  /**
   * 
   * @returns 
   */
  getDefaultOptions() {
    return {
      range: [0],
      domain: [0, 1],
      unknown: void 0,
      tickCount: 5,
      tickMethod: d3Ticks
    };
  }
  /**
   * y = b b  options.range 
   * @param _ 
   * @returns 
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  map(_) {
    const [v] = this.options.range;
    return v !== void 0 ? v : this.options.unknown;
  }
  /**
   *  x x === b []
   * @param x  (
   * @returns 
   */
  invert(x2) {
    const [v] = this.options.range;
    return x2 === v && v !== void 0 ? this.options.domain : [];
  }
  getTicks() {
    const { tickMethod, domain, tickCount } = this.options;
    const [a4, b] = domain;
    if (!isNumber(a4) || !isNumber(b))
      return [];
    return tickMethod(a4, b, tickCount);
  }
  /**
   *  Constant Scale
   * @returns  Constant Scale
   */
  clone() {
    return new _Constant(this.options);
  }
};

// node_modules/@antv/scale/esm/utils/pretty-number.js
function prettyNumber(n2) {
  return Math.abs(n2) < 1e-14 ? n2 : parseFloat(n2.toFixed(14));
}

// node_modules/@antv/scale/esm/tick-methods/wilkinson-extended.js
var DEFAULT_Q = [1, 5, 2, 2.5, 4, 3];
var eps = Number.EPSILON * 100;
function mod(n2, m2) {
  return (n2 % m2 + m2) % m2;
}
function round(n2) {
  return Math.round(n2 * 1e12) / 1e12;
}
function simplicity(q, Q, j, lmin, lmax, lstep) {
  const n2 = size(Q);
  const i2 = index_of_default(Q, q);
  let v = 0;
  const m2 = mod(lmin, lstep);
  if ((m2 < eps || lstep - m2 < eps) && lmin <= 0 && lmax >= 0) {
    v = 1;
  }
  return 1 - i2 / (n2 - 1) - j + v;
}
function simplicityMax(q, Q, j) {
  const n2 = size(Q);
  const i2 = index_of_default(Q, q);
  const v = 1;
  return 1 - i2 / (n2 - 1) - j + v;
}
function density(k2, m2, dMin, dMax, lMin, lMax) {
  const r2 = (k2 - 1) / (lMax - lMin);
  const rt = (m2 - 1) / (Math.max(lMax, dMax) - Math.min(dMin, lMin));
  return 2 - Math.max(r2 / rt, rt / r2);
}
function densityMax(k2, m2) {
  if (k2 >= m2) {
    return 2 - (k2 - 1) / (m2 - 1);
  }
  return 1;
}
function coverage(dMin, dMax, lMin, lMax) {
  const range3 = dMax - dMin;
  return 1 - 0.5 * (__pow(dMax - lMax, 2) + __pow(dMin - lMin, 2)) / __pow(0.1 * range3, 2);
}
function coverageMax(dMin, dMax, span) {
  const range3 = dMax - dMin;
  if (span > range3) {
    const half = (span - range3) / 2;
    return 1 - __pow(half, 2) / __pow(0.1 * range3, 2);
  }
  return 1;
}
function legibility() {
  return 1;
}
var wilkinsonExtended = (dMin, dMax, n2 = 5, onlyLoose = true, Q = DEFAULT_Q, w2 = [0.25, 0.2, 0.5, 0.05]) => {
  const m2 = n2 < 0 ? 0 : Math.round(n2);
  if (Number.isNaN(dMin) || Number.isNaN(dMax) || typeof dMin !== "number" || typeof dMax !== "number" || !m2) {
    return [];
  }
  if (dMax - dMin < 1e-15 || m2 === 1) {
    return [dMin];
  }
  const best = {
    score: -2,
    lmin: 0,
    lmax: 0,
    lstep: 0
  };
  let j = 1;
  while (j < Infinity) {
    for (let i2 = 0; i2 < Q.length; i2 += 1) {
      const q = Q[i2];
      const sm = simplicityMax(q, Q, j);
      if (w2[0] * sm + w2[1] + w2[2] + w2[3] < best.score) {
        j = Infinity;
        break;
      }
      let k2 = 2;
      while (k2 < Infinity) {
        const dm = densityMax(k2, m2);
        if (w2[0] * sm + w2[1] + w2[2] * dm + w2[3] < best.score) {
          break;
        }
        const delta = (dMax - dMin) / (k2 + 1) / j / q;
        let z = Math.ceil(Math.log10(delta));
        while (z < Infinity) {
          const step = j * q * __pow(10, z);
          const cm = coverageMax(dMin, dMax, step * (k2 - 1));
          if (w2[0] * sm + w2[1] * cm + w2[2] * dm + w2[3] < best.score) {
            break;
          }
          const minStart = Math.floor(dMax / step) * j - (k2 - 1) * j;
          const maxStart = Math.ceil(dMin / step) * j;
          if (minStart <= maxStart) {
            const count4 = maxStart - minStart;
            for (let i3 = 0; i3 <= count4; i3 += 1) {
              const start = minStart + i3;
              const lMin = start * (step / j);
              const lMax = lMin + step * (k2 - 1);
              const lStep = step;
              const s3 = simplicity(q, Q, j, lMin, lMax, lStep);
              const c5 = coverage(dMin, dMax, lMin, lMax);
              const g = density(k2, m2, dMin, dMax, lMin, lMax);
              const l2 = legibility();
              const score2 = w2[0] * s3 + w2[1] * c5 + w2[2] * g + w2[3] * l2;
              if (score2 > best.score && (!onlyLoose || lMin <= dMin && lMax >= dMax)) {
                best.lmin = lMin;
                best.lmax = lMax;
                best.lstep = lStep;
                best.score = score2;
              }
            }
          }
          z += 1;
        }
        k2 += 1;
      }
    }
    j += 1;
  }
  const lmax = prettyNumber(best.lmax);
  const lmin = prettyNumber(best.lmin);
  const lstep = prettyNumber(best.lstep);
  const tickCount = Math.floor(round((lmax - lmin) / lstep)) + 1;
  const ticks2 = new Array(tickCount);
  ticks2[0] = prettyNumber(lmin);
  for (let i2 = 1; i2 < tickCount; i2 += 1) {
    ticks2[i2] = prettyNumber(ticks2[i2 - 1] + lstep);
  }
  return ticks2;
};

// node_modules/@antv/scale/esm/scales/identity.js
var Identity = class _Identity extends Base {
  /**
   * 
   * @returns 
   */
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      tickCount: 5,
      unknown: void 0,
      tickMethod: wilkinsonExtended
    };
  }
  /**
   * y = x
   * @param x 
   * @returns 
   */
  map(x2) {
    return isValid(x2) ? x2 : this.options.unknown;
  }
  /**
   * map x = y map 
   * @param x 
   * @returns 
   */
  invert(x2) {
    return this.map(x2);
  }
  /**
   *  Identity Scale
   * @returns  Identity Scale
   */
  clone() {
    return new _Identity(this.options);
  }
  /**
   *  ticks ticks 
   * @returns  ticks 
   */
  getTicks() {
    const { domain, tickCount, tickMethod } = this.options;
    const [min6, max7] = domain;
    if (!isNumber(min6) || !isNumber(max7))
      return [];
    return tickMethod(min6, max7, tickCount);
  }
};

// node_modules/@antv/scale/esm/scales/continuous.js
var createBiMap = (domain, range3, createInterpolate) => {
  const [d0, d1] = domain;
  const [r0, r1] = range3;
  let normalize5;
  let interpolate2;
  if (d0 < d1) {
    normalize5 = createNormalize(d0, d1);
    interpolate2 = createInterpolate(r0, r1);
  } else {
    normalize5 = createNormalize(d1, d0);
    interpolate2 = createInterpolate(r1, r0);
  }
  return compose(interpolate2, normalize5);
};
var createPolyMap = (domain, range3, createInterpolate) => {
  const len = Math.min(domain.length, range3.length) - 1;
  const normalizeList = new Array(len);
  const interpolateList = new Array(len);
  const reverse2 = domain[0] > domain[len];
  const ascendingDomain = reverse2 ? [...domain].reverse() : domain;
  const ascendingRange = reverse2 ? [...range3].reverse() : range3;
  for (let i2 = 0; i2 < len; i2 += 1) {
    normalizeList[i2] = createNormalize(ascendingDomain[i2], ascendingDomain[i2 + 1]);
    interpolateList[i2] = createInterpolate(ascendingRange[i2], ascendingRange[i2 + 1]);
  }
  return (x2) => {
    const i2 = bisect(domain, x2, 1, len) - 1;
    const normalize5 = normalizeList[i2];
    const interpolate2 = interpolateList[i2];
    return compose(interpolate2, normalize5)(x2);
  };
};
var choosePiecewise = (domain, range3, interpolate2, shouldRound) => {
  const n2 = Math.min(domain.length, range3.length);
  const createPiecewise = n2 > 2 ? createPolyMap : createBiMap;
  const createInterpolate = shouldRound ? createInterpolateRound : interpolate2;
  return createPiecewise(domain, range3, createInterpolate);
};
var Continuous2 = class extends Base {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      nice: false,
      clamp: false,
      round: false,
      interpolate: createInterpolateNumber,
      tickCount: 5
    };
  }
  /**
   * y = interpolate(normalize(clamp(transform(x))))
   */
  map(x2) {
    if (!isValid(x2))
      return this.options.unknown;
    return this.output(x2);
  }
  /**
   * x = transform(clamp(interpolate(normalize(y))))
   */
  invert(x2) {
    if (!isValid(x2))
      return this.options.unknown;
    return this.input(x2);
  }
  nice() {
    if (!this.options.nice || isArray(this.options.breaks))
      return;
    const [min6, max7, tickCount, ...rest] = this.getTickMethodOptions();
    this.options.domain = this.chooseNice()(min6, max7, tickCount, ...rest);
  }
  getTicks() {
    const { tickMethod } = this.options;
    const [min6, max7, tickCount, ...rest] = this.getTickMethodOptions();
    return tickMethod(min6, max7, tickCount, ...rest);
  }
  getTickMethodOptions() {
    const { domain, tickCount } = this.options;
    const min6 = domain[0];
    const max7 = domain[domain.length - 1];
    return [min6, max7, tickCount];
  }
  chooseNice() {
    return d3LinearNice;
  }
  rescale() {
    this.nice();
    const [transform2, untransform] = this.chooseTransforms();
    this.composeOutput(transform2, this.chooseClamp(transform2));
    this.composeInput(transform2, untransform, this.chooseClamp(untransform));
  }
  chooseClamp(transform2) {
    const { clamp: shouldClamp, range: range3 } = this.options;
    const domain = this.options.domain.map(transform2);
    const n2 = Math.min(domain.length, range3.length);
    return shouldClamp ? createClamp(domain[0], domain[n2 - 1]) : identity_default;
  }
  composeOutput(transform2, clamp2) {
    const { domain, range: range3, round: round2, interpolate: interpolate2 } = this.options;
    const piecewise = choosePiecewise(domain.map(transform2), range3, interpolate2, round2);
    this.output = compose(piecewise, clamp2, transform2);
  }
  composeInput(transform2, untransform, clamp2) {
    const { domain, range: range3 } = this.options;
    const piecewise = choosePiecewise(range3, domain.map(transform2), createInterpolateNumber);
    this.input = compose(untransform, clamp2, piecewise);
  }
};

// node_modules/@antv/scale/esm/scales/linear.js
var Linear = class _Linear extends Continuous2 {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      unknown: void 0,
      nice: false,
      clamp: false,
      round: false,
      interpolate: createInterpolateValue,
      tickMethod: d3Ticks,
      tickCount: 5
    };
  }
  removeUnsortedValues(breaksDomain, breaksRange, reverse2) {
    let pre = -Infinity;
    const deleteIndices = breaksRange.reduce((acc, current, i2) => {
      if (i2 === 0)
        return acc;
      const value2 = pre > 0 ? pre : current;
      if (pre > 0 && (reverse2 ? current > pre : current < pre)) {
        acc.push(i2);
      } else {
        const diff = (value2 - breaksRange[i2 - 1]) * (reverse2 ? -1 : 1);
        if (diff < 0) {
          if (pre < 0)
            pre = breaksRange[i2 - 1];
          acc.push(i2);
        } else {
          pre = -Infinity;
        }
      }
      return acc;
    }, []);
    deleteIndices.slice().reverse().forEach((index2) => {
      breaksDomain.splice(index2, 1);
      breaksRange.splice(index2, 1);
    });
    return { breaksDomain, breaksRange };
  }
  transformDomain(options) {
    const RANGE_LIMIT = [0.2, 0.8];
    const DEFAULT_GAP = 0.03;
    const { domain = [], range: range3 = [1, 0], breaks = [], tickCount = 5, nice: nice2 } = options;
    const [min6, max7] = [Math.min(...domain), Math.max(...domain)];
    let niceDomainMin = min6;
    let niceDomainMax = max7;
    if (nice2 && breaks.length < 2) {
      const niceDomain = this.chooseNice()(min6, max7, tickCount);
      niceDomainMin = niceDomain[0];
      niceDomainMax = niceDomain[niceDomain.length - 1];
    }
    const domainMin = Math.min(niceDomainMin, min6);
    let domainMax = Math.max(niceDomainMax, max7);
    const sortedBreaks = breaks.filter(({ end }) => end < domainMax).sort((a4, b) => a4.start - b.start);
    const breaksDomain = d3Ticks(domainMin, domainMax, tickCount, sortedBreaks);
    if (last(breaksDomain) < domainMax) {
      const nicest = d3LinearNice(0, domainMax - last(breaksDomain), 3);
      breaksDomain.push(last(breaksDomain) + last(nicest));
      domainMax = last(breaksDomain);
    }
    const [r0, r1] = [range3[0], last(range3)];
    const diffDomain = domainMax - domainMin;
    const diffRange = Math.abs(r1 - r0);
    const reverse2 = r0 > r1;
    const breaksRange = breaksDomain.map((d3) => {
      const ratio = (d3 - domainMin) / diffDomain;
      return reverse2 ? r0 - ratio * diffRange : r0 + ratio * diffRange;
    });
    const [MIN, MAX] = RANGE_LIMIT;
    sortedBreaks.forEach(({ start, end, gap = DEFAULT_GAP, compress = "middle" }) => {
      const startIndex = breaksDomain.indexOf(start);
      const endIndex = breaksDomain.indexOf(end);
      let value2 = (breaksRange[startIndex] + breaksRange[endIndex]) / 2;
      if (compress === "start")
        value2 = breaksRange[startIndex];
      if (compress === "end")
        value2 = breaksRange[endIndex];
      const halfSpan = gap * diffRange / 2;
      let startValue = reverse2 ? value2 + halfSpan : value2 - halfSpan;
      let endValue = reverse2 ? value2 - halfSpan : value2 + halfSpan;
      if (startValue < MIN) {
        endValue += MIN - startValue;
        startValue = MIN;
      }
      if (endValue > MAX) {
        startValue -= endValue - MAX;
        endValue = MAX;
      }
      if (startValue > MAX) {
        endValue -= startValue - MAX;
        startValue = MAX;
      }
      if (endValue < MIN) {
        startValue += MIN - endValue;
        endValue = MIN;
      }
      breaksRange[startIndex] = startValue;
      breaksRange[endIndex] = endValue;
    });
    return this.removeUnsortedValues(breaksDomain, breaksRange, reverse2);
  }
  transformBreaks(options) {
    const { domain, breaks = [] } = options;
    if (!isArray(options.breaks))
      return options;
    const domainMax = Math.max(...domain);
    const filteredBreaks = breaks.filter(({ end }) => end < domainMax);
    const optWithFilteredBreaks = __spreadProps(__spreadValues({}, options), { breaks: filteredBreaks });
    const { breaksDomain, breaksRange } = this.transformDomain(optWithFilteredBreaks);
    return __spreadProps(__spreadValues({}, options), {
      domain: breaksDomain,
      range: breaksRange,
      breaks: filteredBreaks,
      tickMethod: () => [...breaksDomain]
    });
  }
  chooseTransforms() {
    return [identity_default, identity_default];
  }
  clone() {
    return new _Linear(this.options);
  }
};

// node_modules/@antv/scale/esm/scales/point.js
var Point = class _Point extends Band {
  // 
  getDefaultOptions() {
    return {
      domain: [],
      range: [0, 1],
      align: 0.5,
      round: false,
      padding: 0,
      unknown: defaultUnknown,
      paddingInner: 1,
      paddingOuter: 0
    };
  }
  //  PointOptions paddingInner 
  constructor(options) {
    super(options);
  }
  // Point  paddingInner 1
  getPaddingInner() {
    return 1;
  }
  clone() {
    return new _Point(this.options);
  }
  update(options) {
    super.update(options);
  }
  getPaddingOuter() {
    return this.options.padding;
  }
};

// node_modules/@antv/scale/esm/scales/pow.js
var transformPow = (exponent) => {
  return (x2) => {
    return x2 < 0 ? -__pow(-x2, exponent) : __pow(x2, exponent);
  };
};
var transformPowInvert = (exponent) => {
  return (x2) => {
    return x2 < 0 ? -__pow(-x2, 1 / exponent) : __pow(x2, 1 / exponent);
  };
};
var transformSqrt = (x2) => {
  return x2 < 0 ? -Math.sqrt(-x2) : Math.sqrt(x2);
};
var Pow = class _Pow extends Continuous2 {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      nice: false,
      clamp: false,
      round: false,
      exponent: 2,
      interpolate: createInterpolateValue,
      tickMethod: d3Ticks,
      tickCount: 5
    };
  }
  //  options  PowOptions O 
  constructor(options) {
    super(options);
  }
  chooseTransforms() {
    const { exponent } = this.options;
    if (exponent === 1)
      return [identity_default, identity_default];
    const transform2 = exponent === 0.5 ? transformSqrt : transformPow(exponent);
    const untransform = transformPowInvert(exponent);
    return [transform2, untransform];
  }
  clone() {
    return new _Pow(this.options);
  }
};

// node_modules/@antv/scale/esm/scales/sqrt.js
var Sqrt = class _Sqrt extends Pow {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      nice: false,
      clamp: false,
      round: false,
      interpolate: createInterpolateValue,
      tickMethod: d3Ticks,
      tickCount: 5,
      exponent: 0.5
    };
  }
  constructor(options) {
    super(options);
  }
  update(options) {
    super.update(options);
  }
  clone() {
    return new _Sqrt(this.options);
  }
};

// node_modules/@antv/scale/esm/scales/threshold.js
var Threshold = class _Threshold extends Base {
  getDefaultOptions() {
    return {
      domain: [0.5],
      range: [0, 1]
    };
  }
  constructor(options) {
    super(options);
  }
  /**
   * 
   */
  map(x2) {
    if (!isValid(x2))
      return this.options.unknown;
    const index2 = bisect(this.thresholds, x2, 0, this.n);
    return this.options.range[index2];
  }
  /**
   * 
   */
  invert(y3) {
    const { range: range3 } = this.options;
    const index2 = range3.indexOf(y3);
    const domain = this.thresholds;
    return [domain[index2 - 1], domain[index2]];
  }
  clone() {
    return new _Threshold(this.options);
  }
  rescale() {
    const { domain, range: range3 } = this.options;
    this.n = Math.min(domain.length, range3.length - 1);
    this.thresholds = domain;
  }
};

// node_modules/@antv/scale/esm/tick-methods/d3-log.js
var d3Log = (a4, b, n2, base = 10) => {
  const shouldReflect = a4 < 0;
  const pow2 = pows(base, shouldReflect);
  const log2 = logs(base, shouldReflect);
  const r2 = b < a4;
  const min6 = r2 ? b : a4;
  const max7 = r2 ? a4 : b;
  let i2 = log2(min6);
  let j = log2(max7);
  let ticks2 = [];
  if (!(base % 1) && j - i2 < n2) {
    i2 = Math.floor(i2);
    j = Math.ceil(j);
    if (shouldReflect) {
      for (; i2 <= j; i2 += 1) {
        const p3 = pow2(i2);
        for (let k2 = base - 1; k2 >= 1; k2 -= 1) {
          const t = p3 * k2;
          if (t > max7)
            break;
          if (t >= min6)
            ticks2.push(t);
        }
      }
    } else {
      for (; i2 <= j; i2 += 1) {
        const p3 = pow2(i2);
        for (let k2 = 1; k2 < base; k2 += 1) {
          const t = p3 * k2;
          if (t > max7)
            break;
          if (t >= min6)
            ticks2.push(t);
        }
      }
    }
    if (ticks2.length * 2 < n2)
      ticks2 = d3Ticks(min6, max7, n2);
  } else {
    const count4 = n2 === -1 ? j - i2 : Math.min(j - i2, n2);
    ticks2 = d3Ticks(i2, j, count4).map(pow2);
  }
  return r2 ? ticks2.reverse() : ticks2;
};

// node_modules/@antv/scale/esm/scales/log.js
var Log = class _Log extends Continuous2 {
  getDefaultOptions() {
    return {
      domain: [1, 10],
      range: [0, 1],
      base: 10,
      interpolate: createInterpolateValue,
      tickMethod: d3Log,
      tickCount: 5
    };
  }
  chooseNice() {
    return d3LogNice;
  }
  getTickMethodOptions() {
    const { domain, tickCount, base } = this.options;
    const min6 = domain[0];
    const max7 = domain[domain.length - 1];
    return [min6, max7, tickCount, base];
  }
  chooseTransforms() {
    const { base, domain } = this.options;
    const shouldReflect = domain[0] < 0;
    return [logs(base, shouldReflect), pows(base, shouldReflect)];
  }
  clone() {
    return new _Log(this.options);
  }
};

// node_modules/@antv/scale/esm/scales/quantize.js
var Quantize = class _Quantize extends Threshold {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0.5],
      nice: false,
      tickCount: 5,
      tickMethod: wilkinsonExtended
    };
  }
  constructor(options) {
    super(options);
  }
  nice() {
    const { nice: nice2 } = this.options;
    if (nice2) {
      const [min6, max7, tickCount] = this.getTickMethodOptions();
      this.options.domain = d3LinearNice(min6, max7, tickCount);
    }
  }
  getTicks() {
    const { tickMethod } = this.options;
    const [min6, max7, tickCount] = this.getTickMethodOptions();
    return tickMethod(min6, max7, tickCount);
  }
  getTickMethodOptions() {
    const { domain, tickCount } = this.options;
    const min6 = domain[0];
    const max7 = domain[domain.length - 1];
    return [min6, max7, tickCount];
  }
  rescale() {
    this.nice();
    const { range: range3, domain } = this.options;
    const [x05, x12] = domain;
    this.n = range3.length - 1;
    this.thresholds = new Array(this.n);
    for (let i2 = 0; i2 < this.n; i2 += 1) {
      this.thresholds[i2] = ((i2 + 1) * x12 - (i2 - this.n) * x05) / (this.n + 1);
    }
  }
  /**
   * 
   */
  invert(y3) {
    const [a4, b] = super.invert(y3);
    const [x05, x12] = this.options.domain;
    return a4 === void 0 && b === void 0 ? [a4, b] : [a4 || x05, b || x12];
  }
  getThresholds() {
    return this.thresholds;
  }
  clone() {
    return new _Quantize(this.options);
  }
};

// node_modules/@antv/scale/esm/utils/create-quartile.js
function quantileSorted2(arr, percentage) {
  const len = arr.length;
  if (!len) {
    return void 0;
  }
  if (len < 2) {
    return arr[len - 1];
  }
  const i2 = (len - 1) * percentage;
  const i0 = Math.floor(i2);
  const v0 = arr[i0];
  const v1 = arr[i0 + 1];
  return v0 + (v1 - v0) * (i2 - i0);
}
function createQuartile(arr, n2, isSorted = false) {
  const numberArr = arr;
  if (!isSorted) {
    numberArr.sort((a4, b) => a4 - b);
  }
  const tmp = [];
  for (let i2 = 1; i2 < n2; i2 += 1) {
    tmp.push(quantileSorted2(numberArr, i2 / n2));
  }
  return tmp;
}

// node_modules/@antv/scale/esm/scales/quantile.js
var Quantile = class _Quantile extends Threshold {
  getDefaultOptions() {
    return {
      domain: [],
      range: [],
      tickCount: 5,
      unknown: void 0,
      tickMethod: wilkinsonExtended
    };
  }
  constructor(options) {
    super(options);
  }
  rescale() {
    const { domain, range: range3 } = this.options;
    this.n = range3.length - 1;
    this.thresholds = createQuartile(domain, this.n + 1, false);
  }
  /**
   * 
   */
  invert(y3) {
    const [a4, b] = super.invert(y3);
    const { domain } = this.options;
    const dMin = domain[0];
    const dMax = domain[domain.length - 1];
    return a4 === void 0 && b === void 0 ? [a4, b] : [a4 || dMin, b || dMax];
  }
  getThresholds() {
    return this.thresholds;
  }
  clone() {
    return new _Quantile(this.options);
  }
  getTicks() {
    const { tickCount, domain, tickMethod } = this.options;
    const lastIndex = domain.length - 1;
    const min6 = domain[0];
    const max7 = domain[lastIndex];
    return tickMethod(min6, max7, tickCount);
  }
};

// node_modules/@antv/scale/esm/tick-methods/d3-time.js
var d3Time = (min6, max7, count4, interval, utc) => {
  const r2 = min6 > max7;
  const lo = r2 ? max7 : min6;
  const hi = r2 ? min6 : max7;
  const [tickInterval, step] = findTickInterval(lo, hi, count4, interval, utc);
  const ticks2 = tickInterval.range(lo, /* @__PURE__ */ new Date(+hi + 1), step, true);
  return r2 ? ticks2.reverse() : ticks2;
};

// node_modules/@antv/scale/esm/scales/time.js
function offset(date) {
  const minuteOffset = date.getTimezoneOffset();
  const d3 = new Date(date);
  d3.setMinutes(d3.getMinutes() + minuteOffset, d3.getSeconds(), d3.getMilliseconds());
  return d3;
}
var Time = class _Time extends Continuous2 {
  getDefaultOptions() {
    return {
      domain: [new Date(2e3, 0, 1), new Date(2e3, 0, 2)],
      range: [0, 1],
      nice: false,
      tickCount: 5,
      tickInterval: void 0,
      unknown: void 0,
      clamp: false,
      tickMethod: d3Time,
      interpolate: createInterpolateNumber,
      mask: void 0,
      utc: false
    };
  }
  chooseTransforms() {
    const transform2 = (x2) => +x2;
    const untransform = (x2) => new Date(x2);
    return [transform2, untransform];
  }
  chooseNice() {
    return d3TimeNice;
  }
  getTickMethodOptions() {
    const { domain, tickCount, tickInterval, utc } = this.options;
    const min6 = domain[0];
    const max7 = domain[domain.length - 1];
    return [min6, max7, tickCount, tickInterval, utc];
  }
  getFormatter() {
    const { mask, utc } = this.options;
    const maskMap = utc ? utcIntervalMap : localIntervalMap;
    const time = utc ? offset : identity_default;
    return (d3) => format(time(d3), mask || chooseNiceTimeMask(d3, maskMap));
  }
  clone() {
    return new _Time(this.options);
  }
};

// node_modules/@antv/scale/esm/scales/sequential.js
var __decorate = function(decorators, target, key, desc) {
  var c5 = arguments.length, r2 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r2 = (c5 < 3 ? d3(r2) : c5 > 3 ? d3(target, key, r2) : d3(target, key)) || r2;
  return c5 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var Sequential_1;
function rangeOf(interpolator) {
  return [interpolator(0), interpolator(1)];
}
var normalizeDomain = (domain) => {
  const [d0, d1] = domain;
  const normalize5 = compose(createInterpolateNumber(0, 1), createNormalize(d0, d1));
  return normalize5;
};
var Sequential = Sequential_1 = class Sequential2 extends Linear {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      unknown: void 0,
      nice: false,
      clamp: false,
      round: false,
      interpolator: identity_default,
      tickMethod: d3Ticks,
      tickCount: 5
    };
  }
  constructor(options) {
    super(options);
  }
  clone() {
    return new Sequential_1(this.options);
  }
};
Sequential = Sequential_1 = __decorate([
  interpolatize(rangeOf, normalizeDomain)
], Sequential);

// node_modules/@antv/scale/esm/scales/diverging.js
var __decorate2 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r2 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r2 = (c5 < 3 ? d3(r2) : c5 > 3 ? d3(target, key, r2) : d3(target, key)) || r2;
  return c5 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var Diverging_1;
function rangeOf2(interpolator) {
  return [interpolator(0), interpolator(0.5), interpolator(1)];
}
var normalizeDomain2 = (domain) => {
  const [d0, d1, d22] = domain;
  const normalizeLeft = compose(createInterpolateNumber(0, 0.5), createNormalize(d0, d1));
  const normalizeRight = compose(createInterpolateNumber(0.5, 1), createNormalize(d1, d22));
  return (x2) => {
    if (d0 > d22) {
      return x2 < d1 ? normalizeRight(x2) : normalizeLeft(x2);
    } else {
      return x2 < d1 ? normalizeLeft(x2) : normalizeRight(x2);
    }
  };
};
var Diverging = Diverging_1 = class Diverging2 extends Linear {
  getDefaultOptions() {
    return {
      domain: [0, 0.5, 1],
      unknown: void 0,
      nice: false,
      clamp: false,
      round: false,
      interpolator: identity_default,
      tickMethod: d3Ticks,
      tickCount: 5
    };
  }
  constructor(options) {
    super(options);
  }
  clone() {
    return new Diverging_1(this.options);
  }
};
Diverging = Diverging_1 = __decorate2([
  interpolatize(rangeOf2, normalizeDomain2)
], Diverging);

// node_modules/@antv/g2/esm/utils/helper.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getViewFromElement(element) {
  var _a;
  let current = element;
  while (current) {
    if (((_a = current.attributes) === null || _a === void 0 ? void 0 : _a.class) === "view")
      return current;
    current = current.parentNode;
  }
  return null;
}
function isHeatmap(element) {
  const { markType, nodeName } = element;
  return markType === "heatmap" && nodeName === "image";
}
function dataOf(element, viewData) {
  const view = viewData !== null && viewData !== void 0 ? viewData : getViewFromElement(element).__data__;
  const datum = element.__data__;
  const { markKey, index: index2, seriesIndex, normalized = { x: 0 } } = datum;
  const { markState } = view;
  const selectedMark = Array.from(markState.keys()).find((mark2) => mark2.key === markKey);
  if (!selectedMark)
    return;
  if (seriesIndex) {
    return seriesIndex.map((i2) => selectedMark.data[i2]);
  }
  return isHeatmap(element) ? selectedMark.data[Math.round(selectedMark.data.length * normalized.x)] : selectedMark.data[index2];
}
function seriesOf(elemenet) {
  const viewData = getViewFromElement(elemenet).__data__;
  const { scale: scale4 } = viewData;
  return groupNameOf(scale4, elemenet.__data__);
}
function getSeriesByMarkKey(scale4, datum) {
  var _a, _b, _c, _d;
  const markKey = (_a = datum.markKey) !== null && _a !== void 0 ? _a : (_c = (_b = datum.element) === null || _b === void 0 ? void 0 : _b.__data__) === null || _c === void 0 ? void 0 : _c.markKey;
  const seriesKey = Object.keys(scale4).find((channel) => {
    if (channel.startsWith("series")) {
      const options = scale4[channel].getOptions();
      return options.name === "series" && options.markKey === markKey;
    }
  });
  return (_d = scale4[seriesKey]) !== null && _d !== void 0 ? _d : scale4.series;
}
function groupNameOf(scale4, datum) {
  const { color: scaleColor, facet = false } = scale4;
  const { color, series } = datum;
  const scaleSeries = getSeriesByMarkKey(scale4, datum);
  const invertAble = (scale5) => {
    return scale5 && scale5.invert && !(scale5 instanceof Band) && !(scale5 instanceof Constant2);
  };
  if (invertAble(scaleSeries)) {
    const cloned = scaleSeries.clone();
    return cloned.invert(series);
  }
  if (series && scaleSeries instanceof Band && scaleSeries.invert(series) !== color && !facet) {
    return scaleSeries.invert(series);
  }
  if (invertAble(scaleColor)) {
    const name2 = scaleColor.invert(color);
    if (Array.isArray(name2))
      return null;
    return name2;
  }
  return null;
}
function identity2(x2) {
  return x2;
}
function compose2(fns) {
  return fns.reduce((composed, fn) => (x2, ...args) => fn(composed(x2, ...args), ...args), identity2);
}
function composeAsync(fns) {
  return fns.reduce((composed, fn) => (x2) => __awaiter(this, void 0, void 0, function* () {
    const value2 = yield composed(x2);
    return fn(value2);
  }), identity2);
}
function capitalizeFirst(str) {
  return str.replace(/( |^)[a-z]/g, (L) => L.toUpperCase());
}
function error(message = "") {
  throw new Error(message);
}
function copyAttributes(target, source) {
  const { attributes } = source;
  const exclude2 = /* @__PURE__ */ new Set(["id", "className"]);
  for (const [key, value2] of Object.entries(attributes)) {
    if (!exclude2.has(key)) {
      target.attr(key, value2);
    }
  }
}
function defined(x2) {
  return x2 !== void 0 && x2 !== null && !Number.isNaN(x2);
}
function useMemo(compute2) {
  const map5 = /* @__PURE__ */ new Map();
  return (key) => {
    if (map5.has(key))
      return map5.get(key);
    const value2 = compute2(key);
    map5.set(key, value2);
    return value2;
  };
}
function appendTransform(node, transform2) {
  const { transform: preTransform } = node.style;
  const unset = (d3) => d3 === "none" || d3 === void 0;
  const prefix = unset(preTransform) ? "" : preTransform;
  node.style.transform = `${prefix} ${transform2}`.trimStart();
}
function subObject(obj, prefix) {
  return maybeSubObject(obj, prefix) || {};
}
function maybeSubObject(obj, prefix) {
  const entries = Object.entries(obj || {}).filter(([key]) => key.startsWith(prefix)).map(([key, value2]) => [lower_first_default(key.replace(prefix, "").trim()), value2]).filter(([key]) => !!key);
  return entries.length === 0 ? null : Object.fromEntries(entries);
}
function filterPrefixObject(obj, prefix) {
  return Object.fromEntries(Object.entries(obj).filter(([key]) => prefix.find((p3) => key.startsWith(p3))));
}
function omitPrefixObject(obj, ...prefixes2) {
  return Object.fromEntries(Object.entries(obj).filter(([key]) => prefixes2.every((prefix) => !key.startsWith(prefix))));
}
function maybePercentage(x2, size4) {
  if (x2 === void 0)
    return null;
  if (typeof x2 === "number")
    return x2;
  const px = +x2.replace("%", "");
  return Number.isNaN(px) ? null : px / 100 * size4;
}
function isStrictObject(d3) {
  return typeof d3 === "object" && !(d3 instanceof Date) && d3 !== null && !Array.isArray(d3);
}
function isUnset(value2) {
  return value2 === null || value2 === false;
}
function deepAssign(dist2, src, maxLevel = 5, level = 0) {
  if (level >= maxLevel)
    return;
  for (const key of Object.keys(src)) {
    const value2 = src[key];
    if (!is_plain_object_default(value2) || !is_plain_object_default(dist2[key])) {
      dist2[key] = value2;
    } else {
      deepAssign(dist2[key], value2, maxLevel, level + 1);
    }
  }
  return dist2;
}

// node_modules/@antv/g2/esm/utils/array.js
function mapObject(object, callbackfn) {
  return Object.entries(object).reduce((obj, [key, value2]) => {
    obj[key] = callbackfn(value2, key, object);
    return obj;
  }, {});
}
function indexOf(array2) {
  return array2.map((_, i2) => i2);
}
function firstOf(array2) {
  return array2[0];
}
function lastOf(array2) {
  return array2[array2.length - 1];
}
function unique(array2) {
  return Array.from(new Set(array2));
}
function divide(array2, callbackfn) {
  const result = [[], []];
  array2.forEach((item) => {
    result[callbackfn(item) ? 0 : 1].push(item);
  });
  return result;
}
function comb(array2, len = array2.length) {
  if (len === 1)
    return array2.map((item) => [item]);
  const result = [];
  for (let i2 = 0; i2 < array2.length; i2++) {
    const rest = array2.slice(i2 + 1);
    const restComb = comb(rest, len - 1);
    restComb.forEach((comb2) => {
      result.push([array2[i2], ...comb2]);
    });
  }
  return result;
}
function combine(array2) {
  if (array2.length === 1)
    return [array2];
  const result = [];
  for (let i2 = 1; i2 <= array2.length; i2++) {
    result.push(...comb(array2, i2));
  }
  return result;
}

// node_modules/@antv/g2/esm/transform/utils/order.js
function createGroups(groupBy2, I, mark2) {
  const { encode } = mark2;
  if (groupBy2 === null)
    return [I];
  const G = normalizeGroupBy(groupBy2).map((k2) => {
    var _a;
    return [k2, (_a = columnOf(encode, k2)) === null || _a === void 0 ? void 0 : _a[0]];
  }).filter(([, column2]) => defined(column2));
  const key = (i2) => G.map(([, V]) => V[i2]).join("-");
  return Array.from(group(I, key).values());
}
function normalizeComparator(order) {
  if (Array.isArray(order))
    return createFieldsOrder(order);
  if (typeof order === "function")
    return createFunctionOrder(order);
  if (order === "series")
    return createSeriesOrder;
  if (order === "value")
    return createValueOrder;
  if (order === "sum")
    return createSumOrder;
  if (order === "maxIndex")
    return createMaxIndexOrder;
  return null;
}
function applyOrder(groups2, comparator) {
  for (const group2 of groups2) {
    group2.sort(comparator);
  }
}
function domainOf(value2, scale4) {
  return (scale4 === null || scale4 === void 0 ? void 0 : scale4.domain) || Array.from(new Set(value2));
}
function normalizeGroupBy(groupBy2) {
  if (Array.isArray(groupBy2))
    return groupBy2;
  return [groupBy2];
}
function createSeriesOrder(data, Y, S) {
  return ascendingComparator((i2) => S[i2]);
}
function createFunctionOrder(order) {
  return (data, Y, S) => {
    return ascendingComparator((i2) => order(data[i2]));
  };
}
function createFieldsOrder(order) {
  return (data, Y, S) => {
    return (i2, j) => order.reduce((eq, f2) => eq !== 0 ? eq : ascending(data[i2][f2], data[j][f2]), 0);
  };
}
function createValueOrder(data, Y, S) {
  return ascendingComparator((i2) => Y[i2]);
}
function createSumOrder(data, Y, S) {
  const I = indexOf(data);
  const groups2 = Array.from(group(I, (i2) => S[+i2]).entries());
  const seriesSum = new Map(groups2.map(([k2, GI]) => [k2, GI.reduce((s3, i2) => s3 + +Y[i2])]));
  return ascendingComparator((i2) => seriesSum.get(S[i2]));
}
function createMaxIndexOrder(data, Y, S) {
  const I = indexOf(data);
  const groups2 = Array.from(group(I, (i2) => S[+i2]).entries());
  const seriesMaxIndex = new Map(groups2.map(([k2, GI]) => [k2, maxIndex(GI, (i2) => Y[i2])]));
  return ascendingComparator((i2) => seriesMaxIndex.get(S[i2]));
}
function ascendingComparator(order) {
  return (i2, j) => ascending(order(i2), order(j));
}

// node_modules/@antv/g2/esm/transform/stackY.js
var StackY = (options = {}) => {
  const { groupBy: groupBy2 = "x", orderBy = null, reverse: reverse2 = false, y: fromY = "y", y1: fromY1 = "y1", series = true } = options;
  return (I, mark2) => {
    var _a;
    const { data, encode, style = {} } = mark2;
    const [Y, fy] = columnOf(encode, "y");
    const [Y12, fy1] = columnOf(encode, "y1");
    const [S] = series ? maybeColumnOf(encode, "series", "color") : columnOf(encode, "color");
    const groups2 = createGroups(groupBy2, I, mark2);
    const createComparator = (_a = normalizeComparator(orderBy)) !== null && _a !== void 0 ? _a : () => null;
    const comparator = createComparator(data, Y, S);
    if (comparator)
      applyOrder(groups2, comparator);
    const newY = new Array(I.length);
    const newY1 = new Array(I.length);
    const TY = new Array(I.length);
    const F = [];
    const L = [];
    for (const G of groups2) {
      if (reverse2)
        G.reverse();
      const start = Y12 ? +Y12[G[0]] : 0;
      const PG = [];
      const NG = [];
      for (const i3 of G) {
        const y3 = TY[i3] = +Y[i3] - start;
        if (y3 < 0)
          NG.push(i3);
        else if (y3 >= 0)
          PG.push(i3);
      }
      const FG = PG.length > 0 ? PG : NG;
      const LG = NG.length > 0 ? NG : PG;
      let i2 = PG.length - 1;
      let j = 0;
      while (i2 > 0 && Y[FG[i2]] === 0)
        i2--;
      while (j < LG.length - 1 && Y[LG[j]] === 0)
        j++;
      F.push(FG[i2]);
      L.push(LG[j]);
      let ny = start;
      for (const i3 of NG.reverse()) {
        const y3 = TY[i3];
        ny = newY[i3] = (newY1[i3] = ny) + y3;
      }
      let py = start;
      for (const i3 of PG) {
        const y3 = TY[i3];
        if (y3 > 0)
          py = newY[i3] = (newY1[i3] = py) + y3;
        else
          newY[i3] = newY1[i3] = py;
      }
    }
    const FS = new Set(F);
    const LS = new Set(L);
    const V = fromY === "y" ? newY : newY1;
    const V1 = fromY1 === "y" ? newY : newY1;
    let newEncode;
    if (mark2.type === "point") {
      newEncode = {
        y0: inferredColumn(Y, fy),
        // Store original Y.
        y: column(V, fy)
      };
    } else {
      newEncode = {
        y0: inferredColumn(Y, fy),
        // Store original Y.
        y: column(V, fy),
        y1: column(V1, fy1)
      };
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: Object.assign({}, newEncode),
        style: Object.assign({ first: (_, i2) => FS.has(i2), last: (_, i2) => LS.has(i2) }, style)
      })
    ];
  };
};
StackY.props = {};

// node_modules/@antv/g2/esm/transform/maybeStackY.js
function exclude(transform2) {
  const { type } = transform2;
  const excludes = ["stackY", "dodgeX", "groupX"];
  return typeof type === "string" && excludes.includes(type);
}
var MaybeStackY = (options) => {
  return (I, mark2, context) => {
    const { encode, transform: transform2 = [] } = mark2;
    if (transform2.some(exclude))
      return [I, mark2];
    const { x: x2, y: y3 } = encode;
    if (x2 === void 0 || y3 === void 0)
      return [I, mark2];
    const { series } = options;
    const groupBy2 = series ? ["x", "series"] : "x";
    return StackY({ groupBy: groupBy2 })(I, mark2, context);
  };
};
MaybeStackY.props = {};

// node_modules/@antv/g2/esm/utils/dateFormat.js
function fillZero(digit) {
  if (Math.abs(digit) > 10)
    return String(digit);
  return digit.toString().padStart(2, "0");
}
function dynamicFormatDateTime(date) {
  const year3 = date.getFullYear();
  const month3 = fillZero(date.getMonth() + 1);
  const day3 = fillZero(date.getDate());
  const yyyyMMDD = `${year3}-${month3}-${day3}`;
  const hour3 = date.getHours();
  const minutes = date.getMinutes();
  const seconds = date.getSeconds();
  if (hour3 || minutes || seconds)
    return `${yyyyMMDD} ${fillZero(hour3)}:${fillZero(minutes)}:${fillZero(seconds)}`;
  return yyyyMMDD;
}

// node_modules/@antv/g2/esm/transform/maybeTitle.js
var MaybeTitle = (options = {}) => {
  const { channel = "x" } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const { tooltip: tooltip2 } = mark2;
    if (isUnset(tooltip2))
      return [I, mark2];
    const { title } = tooltip2;
    if (title !== void 0)
      return [I, mark2];
    const titles = Object.keys(encode).filter((key) => key.startsWith(channel)).filter((key) => !encode[key].inferred).map((key) => columnOf(encode, key)).filter(([T3]) => T3).map((d3) => d3[0]);
    if (titles.length === 0)
      return [I, mark2];
    const T2 = [];
    for (const i2 of I) {
      T2[i2] = {
        value: titles.map((t) => t[i2] instanceof Date ? dynamicFormatDateTime(t[i2]) : t[i2]).join(", ")
      };
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        tooltip: {
          title: T2
        }
      })
    ];
  };
};
MaybeTitle.props = {};

// node_modules/@antv/g2/esm/transform/maybeZeroX.js
var MaybeZeroX = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { x: x2 } = encode;
    if (x2 !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: { x: inferredColumn(constant(I, 0)) },
        scale: { x: { guide: null } }
      })
    ];
  };
};
MaybeZeroX.props = {};

// node_modules/@antv/g2/esm/transform/maybeZeroY.js
var MaybeZeroY = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { y: y3 } = encode;
    if (y3 !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: { y: inferredColumn(constant(I, 0)) },
        scale: { y: { guide: null } }
      })
    ];
  };
};
MaybeZeroY.props = {};

// node_modules/@antv/g2/esm/transform/maybeZeroZ.js
var MaybeZeroZ = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { z } = encode;
    if (z !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: { z: inferredColumn(constant(I, 0)) },
        scale: { z: { guide: null } }
      })
    ];
  };
};
MaybeZeroZ.props = {};

// node_modules/@antv/g2/esm/transform/maybeSize.js
var MaybeSize = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { size: size4 } = encode;
    if (size4 !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, { encode: { size: visualColumn(constant(I, 3)) } })
    ];
  };
};
MaybeSize.props = {};

// node_modules/@antv/g2/esm/transform/maybeKey.js
var __rest = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var MaybeKey = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { key } = encode, rest = __rest(encode, ["key"]);
    if (key !== void 0)
      return [I, mark2];
    const values4 = Object.values(rest).map(({ value: value2 }) => value2);
    const K = I.map((i2) => values4.filter(Array.isArray).map((V) => V[i2]).join("-"));
    return [I, deep_mix_default({}, mark2, { encode: { key: column(K) } })];
  };
};
MaybeKey.props = {};

// node_modules/@antv/g2/esm/transform/maybeSeries.js
var MaybeSeries = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { series, color } = encode;
    if (series !== void 0 || color === void 0)
      return [I, mark2];
    const [C, fc] = columnOf(encode, "color");
    return [I, deep_mix_default({}, mark2, { encode: { series: column(C, fc) } })];
  };
};
MaybeSeries.props = {};

// node_modules/@antv/g2/esm/transform/maybeTupleY.js
var MaybeTupleY = () => {
  return (I, mark2) => {
    const { data } = mark2;
    if (!Array.isArray(data) || data.some(isObject))
      return [I, mark2];
    return [I, deep_mix_default({}, mark2, { encode: { y: column(data) } })];
  };
};
MaybeTupleY.props = {};

// node_modules/@antv/g2/esm/transform/maybeTupleX.js
var MaybeTupleX = () => {
  return (I, mark2) => {
    const { data } = mark2;
    if (!Array.isArray(data) || data.some(isObject))
      return [I, mark2];
    return [I, deep_mix_default({}, mark2, { encode: { x: column(data) } })];
  };
};
MaybeTupleX.props = {};

// node_modules/@antv/g2/esm/transform/maybeIdentityY.js
var MaybeIdentityY = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { y1: y12 } = encode;
    if (y12)
      return [I, mark2];
    const [Y] = columnOf(encode, "y");
    return [I, deep_mix_default({}, mark2, { encode: { y1: column([...Y]) } })];
  };
};
MaybeIdentityY.props = {};

// node_modules/@antv/g2/esm/transform/maybeIdentityX.js
var MaybeIdentityX = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { x1: x12 } = encode;
    if (x12)
      return [I, mark2];
    const [X] = columnOf(encode, "x");
    return [I, deep_mix_default({}, mark2, { encode: { x1: column([...X]) } })];
  };
};
MaybeIdentityX.props = {};

// node_modules/@antv/g2/esm/transform/maybeDefaultX.js
var MaybeDefaultX = () => {
  return (I, mark2) => {
    const { data } = mark2;
    if (Array.isArray(data) && (data.every(Array.isArray) || !data.some(isObject))) {
      const extractX = (data2, index2) => Array.isArray(data2[0]) ? data2.map((item) => item[index2]) : [data2[index2]];
      return [
        I,
        deep_mix_default({}, mark2, {
          encode: {
            x: column(extractX(data, 0)),
            x1: column(extractX(data, 1))
          }
        })
      ];
    }
    return [I, mark2];
  };
};
MaybeDefaultX.props = {};

// node_modules/@antv/g2/esm/transform/maybeDefaultY.js
var MaybeDefaultY = () => {
  return (I, mark2) => {
    const { data } = mark2;
    if (Array.isArray(data) && (data.every(Array.isArray) || !data.some(isObject))) {
      const extractY = (data2, index2) => Array.isArray(data2[0]) ? data2.map((item) => item[index2]) : [data2[index2]];
      return [
        I,
        deep_mix_default({}, mark2, {
          encode: {
            y: column(extractY(data, 0)),
            y1: column(extractY(data, 1))
          }
        })
      ];
    }
    return [I, mark2];
  };
};
MaybeDefaultY.props = {};

// node_modules/@antv/g2/esm/transform/maybeTooltip.js
var MaybeTooltip = (options) => {
  const { channel } = options;
  return (I, mark2) => {
    const { encode, tooltip: tooltip2 } = mark2;
    if (isUnset(tooltip2))
      return [I, mark2];
    const { items = [] } = tooltip2;
    if (!items || items.length > 0)
      return [I, mark2];
    const channels = Array.isArray(channel) ? channel : [channel];
    const newItems = channels.flatMap((channel2) => Object.keys(encode).filter((key) => key.startsWith(channel2)).map((key) => {
      const { field: field3, value: value2, inferred = false, aggregate } = encode[key];
      if (inferred)
        return null;
      if (aggregate && value2)
        return { channel: key };
      if (field3)
        return { field: field3 };
      if (value2)
        return { channel: key };
      return null;
    }).filter((d3) => d3 !== null));
    return [I, deep_mix_default({}, mark2, { tooltip: { items: newItems } })];
  };
};
MaybeTooltip.props = {};

// node_modules/@antv/g2/esm/transform/maybeZeroPadding.js
var MaybeZeroPadding = () => {
  return (I, mark2) => {
    return [
      I,
      deep_mix_default({ scale: { x: { padding: 0 }, y: { padding: 0 } } }, mark2)
    ];
  };
};
MaybeZeroPadding.props = {};

// node_modules/@antv/g2/esm/transform/maybeVisualPosition.js
var __rest2 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var MaybeVisualPosition = () => {
  return (I, mark2) => {
    const { data, style = {} } = mark2, restMark = __rest2(mark2, ["data", "style"]);
    const { x: x05, y: y05 } = style, rest = __rest2(style, ["x", "y"]);
    if (x05 == void 0 || y05 == void 0)
      return [I, mark2];
    const x2 = x05 || 0;
    const y3 = y05 || 0;
    return [
      [0],
      deep_mix_default({}, restMark, {
        data: [0],
        cartesian: true,
        encode: {
          x: column([x2]),
          y: column([y3])
        },
        scale: {
          x: { type: "identity", independent: true, guide: null },
          // hide axis
          y: { type: "identity", independent: true, guide: null }
          // hide axis
        },
        style: rest
      })
    ];
  };
};
MaybeVisualPosition.props = {};

// node_modules/@antv/g2/esm/transform/maybeFunctionAttribute.js
var MaybeFunctionAttribute = () => {
  return (I, mark2) => {
    const { style = {} } = mark2;
    return [
      I,
      deep_mix_default({}, mark2, {
        style: Object.assign(Object.assign({}, style), Object.fromEntries(Object.entries(style).filter(([, v]) => typeof v === "function").map(([k2, v]) => [k2, () => v])))
      })
    ];
  };
};
MaybeFunctionAttribute.props = {};

// node_modules/@antv/g2/esm/transform/maybeTuple.js
var MaybeTuple = () => {
  return (I, mark2) => {
    const { data } = mark2;
    if (!Array.isArray(data) || data.some(isObject))
      return [I, mark2];
    const position = Array.isArray(data[0]) ? data : [data];
    const X = position.map((d3) => d3[0]);
    const Y = position.map((d3) => d3[1]);
    return [I, deep_mix_default({}, mark2, { encode: { x: column(X), y: column(Y) } })];
  };
};
MaybeTuple.props = {};

// node_modules/@antv/g2/esm/transform/maybeGradient.js
var MaybeGradient = () => {
  return (I, mark2) => {
    const { style = {}, encode } = mark2;
    const { series } = encode;
    const { gradient: gradient2 } = style;
    if (!gradient2 || series)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: {
          series: visualColumn(constant(I, void 0))
        }
      })
    ];
  };
};
MaybeGradient.props = {};

// node_modules/@antv/g2/esm/transform/dodgeX.js
var __rest3 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var DodgeX = (options = {}) => {
  const { groupBy: groupBy2 = "x", reverse: reverse2 = false, orderBy, padding } = options, rest = __rest3(options, ["groupBy", "reverse", "orderBy", "padding"]);
  return (I, mark2) => {
    const { data, encode, scale: scale4 } = mark2;
    const { series: scaleSeries } = scale4;
    const [Y] = columnOf(encode, "y");
    const [S] = maybeColumnOf(encode, "series", "color");
    const domainSeries = domainOf(S, scaleSeries);
    const newMark = deep_mix_default({}, mark2, {
      scale: {
        series: {
          domain: domainSeries,
          paddingInner: padding
        }
      }
    });
    const groups2 = createGroups(groupBy2, I, mark2);
    const createComparator = normalizeComparator(orderBy);
    if (!createComparator) {
      return [I, deep_mix_default(newMark, { encode: { series: column(S) } })];
    }
    const comparator = createComparator(data, Y, S);
    if (comparator)
      applyOrder(groups2, comparator);
    const newS = new Array(I.length);
    for (const G of groups2) {
      if (reverse2)
        G.reverse();
      for (let i2 = 0; i2 < G.length; i2++) {
        newS[G[i2]] = domainSeries[i2];
      }
    }
    return [
      I,
      deep_mix_default(newMark, {
        encode: {
          series: column(orderBy ? newS : S)
        }
      })
    ];
  };
};
DodgeX.props = {};

// node_modules/@antv/g2/esm/transform/stackEnter.js
var StackEnter = (options) => {
  const { groupBy: groupBy2 = ["x"], reducer = (I, V) => V[I[0]], orderBy = null, reverse: reverse2 = false, duration } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const by = Array.isArray(groupBy2) ? groupBy2 : [groupBy2];
    const groupEntries = by.map((k2) => [k2, columnOf(encode, k2)[0]]);
    if (groupEntries.length === 0)
      return [I, mark2];
    let groups2 = [I];
    for (const [, V] of groupEntries) {
      const newGroups = [];
      for (const I2 of groups2) {
        const G = Array.from(group(I2, (i2) => V[i2]).values());
        newGroups.push(...G);
      }
      groups2 = newGroups;
    }
    if (orderBy) {
      const [V] = columnOf(encode, orderBy);
      if (V)
        groups2.sort((I2, J) => reducer(I2, V) - reducer(J, V));
      if (reverse2)
        groups2.reverse();
    }
    const t = (duration || 3e3) / groups2.length;
    const [ED] = duration ? [constant(I, t)] : maybeColumnOf(encode, "enterDuration", constant(I, t));
    const [EDL] = maybeColumnOf(encode, "enterDelay", constant(I, 0));
    const newEnterDelay = new Array(I.length);
    for (let i2 = 0, pd = 0; i2 < groups2.length; i2++) {
      const I2 = groups2[i2];
      const maxDuration = max(I2, (i3) => +ED[i3]);
      for (const j of I2)
        newEnterDelay[j] = +EDL[j] + pd;
      pd += maxDuration;
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: {
          enterDuration: visualColumn(ED),
          enterDelay: visualColumn(newEnterDelay)
        }
      })
    ];
  };
};
StackEnter.props = {};

// node_modules/@antv/g2/esm/transform/normalizeY.js
var __rest4 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function normalizeBasis(basis) {
  if (typeof basis === "function")
    return basis;
  const registry = {
    min: (I, Y) => min(I, (i2) => Y[+i2]),
    max: (I, Y) => max(I, (i2) => Y[+i2]),
    first: (I, Y) => Y[I[0]],
    last: (I, Y) => Y[I[I.length - 1]],
    mean: (I, Y) => mean(I, (i2) => Y[+i2]),
    median: (I, Y) => median(I, (i2) => Y[+i2]),
    sum: (I, Y) => sum(I, (i2) => Y[+i2]),
    deviation: (I, Y) => deviation(I, (i2) => Y[+i2])
  };
  return registry[basis] || max;
}
var NormalizeY = (options = {}) => {
  const { groupBy: groupBy2 = "x", basis = "max" } = options;
  return (I, mark2) => {
    const { encode, tooltip: tooltip2 } = mark2;
    const { x: x2 } = encode, rest = __rest4(encode, ["x"]);
    const Yn = Object.entries(rest).filter(([k2]) => k2.startsWith("y")).map(([k2]) => [k2, columnOf(encode, k2)[0]]);
    const [, Y] = Yn.find(([k2]) => k2 === "y");
    const newYn = Yn.map(([k2]) => [k2, new Array(I.length)]);
    const groups2 = createGroups(groupBy2, I, mark2);
    const basisFunction = normalizeBasis(basis);
    for (const I2 of groups2) {
      const basisValue = basisFunction(I2, Y);
      for (const i2 of I2) {
        for (let j = 0; j < Yn.length; j++) {
          const [, V] = Yn[j];
          const [, newV] = newYn[j];
          newV[i2] = +V[i2] / basisValue;
        }
      }
    }
    const specifiedTooltip = isUnset(tooltip2) || (tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.items) && (tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.items.length) !== 0;
    return [
      I,
      deep_mix_default({}, mark2, Object.assign({ encode: Object.fromEntries(newYn.map(([k2, v]) => [k2, column(v, columnOf(encode, k2)[1])])) }, !specifiedTooltip && encode.y0 && {
        tooltip: { items: [{ channel: "y0" }] }
      }))
    ];
  };
};
NormalizeY.props = {};

// node_modules/@antv/g2/esm/transform/jitter.js
function rangeOf3(value2, scaleOptions, padding) {
  if (value2 === null)
    return [-0.5, 0.5];
  const domain = domainOf(value2, scaleOptions);
  const scale4 = new Band({ domain, range: [0, 1], padding });
  const step = scale4.getBandWidth();
  return [-step / 2, step / 2];
}
function interpolate(t, a4, b) {
  return a4 * (1 - t) + b * t;
}
var Jitter = (options = {}) => {
  const { padding = 0, paddingX = padding, paddingY = padding, random = Math.random } = options;
  return (I, mark2) => {
    const { encode, scale: scale4 } = mark2;
    const { x: scaleX, y: scaleY } = scale4;
    const [X] = columnOf(encode, "x");
    const [Y] = columnOf(encode, "y");
    const rangeX = rangeOf3(X, scaleX, paddingX);
    const rangeY = rangeOf3(Y, scaleY, paddingY);
    const DY = I.map(() => interpolate(random(), ...rangeY));
    const DX = I.map(() => interpolate(random(), ...rangeX));
    return [
      I,
      deep_mix_default({
        scale: {
          x: { padding: 0.5 },
          y: { padding: 0.5 }
        }
      }, mark2, {
        encode: { dy: column(DY), dx: column(DX) }
      })
    ];
  };
};
Jitter.props = {};

// node_modules/@antv/g2/esm/transform/jitterX.js
var JitterX = (options = {}) => {
  const { padding = 0, random = Math.random } = options;
  return (I, mark2) => {
    const { encode, scale: scale4 } = mark2;
    const { x: scaleX } = scale4;
    const [X] = columnOf(encode, "x");
    const rangeX = rangeOf3(X, scaleX, padding);
    const DX = I.map(() => interpolate(random(), ...rangeX));
    return [
      I,
      deep_mix_default({ scale: { x: { padding: 0.5 } } }, mark2, {
        encode: { dx: column(DX) }
      })
    ];
  };
};
JitterX.props = {};

// node_modules/@antv/g2/esm/transform/jitterY.js
var JitterY = (options = {}) => {
  const { padding = 0, random = Math.random } = options;
  return (I, mark2) => {
    const { encode, scale: scale4 } = mark2;
    const { y: scaleY } = scale4;
    const [Y] = columnOf(encode, "y");
    const rangeY = rangeOf3(Y, scaleY, padding);
    const DY = I.map(() => interpolate(random(), ...rangeY));
    return [
      I,
      deep_mix_default({ scale: { y: { padding: 0.5 } } }, mark2, {
        encode: { dy: column(DY) }
      })
    ];
  };
};
JitterY.props = {};

// node_modules/@antv/g2/esm/transform/symmetryY.js
var __rest5 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var SymmetryY = (options = {}) => {
  const { groupBy: groupBy2 = "x" } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const { x: x2 } = encode, rest = __rest5(encode, ["x"]);
    const Yn = Object.entries(rest).filter(([k2]) => k2.startsWith("y")).map(([k2]) => [k2, columnOf(encode, k2)[0]]);
    const newYn = Yn.map(([k2]) => [k2, new Array(I.length)]);
    const groups2 = createGroups(groupBy2, I, mark2);
    const MY = new Array(groups2.length);
    for (let i2 = 0; i2 < groups2.length; i2++) {
      const I2 = groups2[i2];
      const Y = I2.flatMap((i3) => Yn.map(([, V]) => +V[i3]));
      const [minY, maxY2] = extent(Y);
      MY[i2] = (minY + maxY2) / 2;
    }
    const maxMiddleY = Math.max(...MY);
    for (let m2 = 0; m2 < groups2.length; m2++) {
      const offset2 = maxMiddleY - MY[m2];
      const I2 = groups2[m2];
      for (const i2 of I2) {
        for (let j = 0; j < Yn.length; j++) {
          const [, V] = Yn[j];
          const [, newV] = newYn[j];
          newV[i2] = +V[i2] + offset2;
        }
      }
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: Object.fromEntries(newYn.map(([k2, v]) => [k2, column(v, columnOf(encode, k2)[1])]))
      })
    ];
  };
};
SymmetryY.props = {};

// node_modules/@antv/g2/esm/transform/diffY.js
var DiffY = (options = {}) => {
  const { groupBy: groupBy2 = "x" } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const [Y] = columnOf(encode, "y");
    const [_, fy1] = columnOf(encode, "y1");
    const groups2 = createGroups(groupBy2, I, mark2);
    const newY1 = new Array(I.length);
    for (const G of groups2) {
      const YG = G.map((i2) => +Y[i2]);
      for (let idx = 0; idx < G.length; idx++) {
        const i2 = G[idx];
        const max7 = Math.max(...YG.filter((_2, _i) => _i !== idx));
        newY1[i2] = +Y[i2] > max7 ? max7 : Y[i2];
      }
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: {
          y1: column(newY1, fy1)
        }
      })
    ];
  };
};
DiffY.props = {};

// node_modules/@antv/g2/esm/transform/select.js
function first(I, V) {
  return [I[0]];
}
function last2(I, V) {
  const i2 = I.length - 1;
  return [I[i2]];
}
function max2(I, V) {
  const i2 = maxIndex(I, (i3) => V[i3]);
  return [I[i2]];
}
function min2(I, V) {
  const i2 = minIndex(I, (i3) => V[i3]);
  return [I[i2]];
}
function normalizeSelector(selector) {
  if (typeof selector === "function")
    return selector;
  const registry = { first, last: last2, max: max2, min: min2 };
  return registry[selector] || first;
}
var Select = (options = {}) => {
  const { groupBy: groupBy2 = "series", channel, selector } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const groups2 = createGroups(groupBy2, I, mark2);
    const [V] = columnOf(encode, channel);
    const selectFunction = normalizeSelector(selector);
    return [groups2.flatMap((GI) => selectFunction(GI, V)), mark2];
  };
};
Select.props = {};

// node_modules/@antv/g2/esm/transform/selectX.js
var __rest6 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var SelectX = (options = {}) => {
  const { selector } = options, rest = __rest6(options, ["selector"]);
  return Select(Object.assign({ channel: "x", selector }, rest));
};
SelectX.props = {};

// node_modules/@antv/g2/esm/transform/selectY.js
var __rest7 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var SelectY = (options = {}) => {
  const { selector } = options, rest = __rest7(options, ["selector"]);
  return Select(Object.assign({ channel: "y", selector }, rest));
};
SelectY.props = {};

// node_modules/@antv/g2/esm/transform/groupN.js
var __rest8 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function builtinFormatter(summary) {
  return (d3) => d3 === null ? summary : `${summary} of ${d3}`;
}
function normalizeReducer(reducer) {
  if (typeof reducer === "function")
    return [reducer, null];
  const registry = { mean: mean2, max: max3, count: count2, first: first2, last: last3, sum: sum2, min: min3, median: median2 };
  const reducerFunction = registry[reducer];
  if (!reducerFunction)
    throw new Error(`Unknown reducer: ${reducer}.`);
  return reducerFunction();
}
function mean2() {
  const reducer = (I, V) => mean(I, (i2) => +V[i2]);
  const formatter = builtinFormatter("mean");
  return [reducer, formatter];
}
function median2() {
  const reducer = (I, V) => median(I, (i2) => +V[i2]);
  const formatter = builtinFormatter("median");
  return [reducer, formatter];
}
function max3() {
  const reducer = (I, V) => max(I, (i2) => +V[i2]);
  const formatter = builtinFormatter("max");
  return [reducer, formatter];
}
function min3() {
  const reducer = (I, V) => min(I, (i2) => +V[i2]);
  const formatter = builtinFormatter("min");
  return [reducer, formatter];
}
function count2() {
  const reducer = (I, V) => I.length;
  const formatter = builtinFormatter("count");
  return [reducer, formatter];
}
function sum2() {
  const reducer = (I, V) => sum(I, (i2) => +V[i2]);
  const formatter = builtinFormatter("sum");
  return [reducer, formatter];
}
function first2() {
  const reducer = (I, V) => V[I[0]];
  const formatter = builtinFormatter("first");
  return [reducer, formatter];
}
function last3() {
  const reducer = (I, V) => V[I[I.length - 1]];
  const formatter = builtinFormatter("last");
  return [reducer, formatter];
}
var GroupN = (options = {}) => {
  const { groupBy: groupBy2 } = options, rest = __rest8(options, ["groupBy"]);
  return (I, mark2) => {
    const { data, encode } = mark2;
    const groups2 = groupBy2(I, mark2);
    if (!groups2)
      return [I, mark2];
    const maybeFrom = (field3, reducer) => {
      if (field3)
        return field3;
      const { from } = reducer;
      if (!from)
        return field3;
      const [, field1] = columnOf(encode, from);
      return field1;
    };
    const outputs = Object.entries(rest).map(([channel, reducer]) => {
      const [reducerFunction, formatter] = normalizeReducer(reducer);
      const [V, field3] = columnOf(encode, channel);
      const field1 = maybeFrom(field3, reducer);
      const RV = groups2.map((I2) => reducerFunction(I2, V !== null && V !== void 0 ? V : data));
      return [
        channel,
        Object.assign(Object.assign({}, nonConstantColumn(RV, (formatter === null || formatter === void 0 ? void 0 : formatter(field1)) || field1)), { aggregate: true })
      ];
    });
    const reducedColumns = Object.keys(encode).map((key) => {
      const [V, fv] = columnOf(encode, key);
      const GV = groups2.map((I2) => V[I2[0]]);
      return [key, column(GV, fv)];
    });
    const GD = groups2.map((I2) => data[I2[0]]);
    const GI = indexOf(groups2);
    return [
      GI,
      deep_mix_default({}, mark2, {
        data: GD,
        encode: Object.fromEntries([...reducedColumns, ...outputs])
      })
    ];
  };
};
GroupN.props = {};

// node_modules/@antv/g2/esm/transform/group.js
var __rest9 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var Group2 = (options = {}) => {
  const { channels = ["x", "y"] } = options, rest = __rest9(options, ["channels"]);
  const groupBy2 = (I, mark2) => createGroups(channels, I, mark2);
  return GroupN(Object.assign(Object.assign({}, rest), { groupBy: groupBy2 }));
};
Group2.props = {};

// node_modules/@antv/g2/esm/transform/groupX.js
var GroupX = (options = {}) => {
  return Group2(Object.assign(Object.assign({}, options), { channels: ["x", "color", "series"] }));
};
GroupX.props = {};

// node_modules/@antv/g2/esm/transform/groupY.js
var GroupY = (options = {}) => {
  return Group2(Object.assign(Object.assign({}, options), { channels: ["y", "color", "series"] }));
};
GroupY.props = {};

// node_modules/@antv/g2/esm/transform/groupColor.js
var GroupColor = (options = {}) => {
  return Group2(Object.assign(Object.assign({}, options), { channels: ["color"] }));
};
GroupColor.props = {};

// node_modules/@antv/g2/esm/transform/sort.js
function createReducer(channel, options, encode) {
  const { by = channel, reducer = "max" } = options;
  const [V] = columnOf(encode, by);
  if (typeof reducer === "function")
    return (GI) => reducer(GI, V);
  if (reducer === "max")
    return (GI) => max(GI, (i2) => +V[i2]);
  if (reducer === "min")
    return (GI) => min(GI, (i2) => +V[i2]);
  if (reducer === "sum")
    return (GI) => sum(GI, (i2) => +V[i2]);
  if (reducer === "median")
    return (GI) => median(GI, (i2) => +V[i2]);
  if (reducer === "mean")
    return (GI) => mean(GI, (i2) => +V[i2]);
  if (reducer === "first")
    return (GI) => V[GI[0]];
  if (reducer === "last")
    return (GI) => V[GI[GI.length - 1]];
  throw new Error(`Unknown reducer: ${reducer}`);
}
function filterIndex(I, values4, specifiedDomain) {
  if (!Array.isArray(specifiedDomain))
    return I;
  const domain = new Set(specifiedDomain);
  return I.filter((i2) => domain.has(values4[i2]));
}
var Sort = (options = {}) => {
  return (I, mark2) => {
    const { reverse: reverse2, slice: slice3, channel, by, ordinal = true, reducer } = options;
    const { encode, scale: scale4 = {} } = mark2;
    const domain = scale4[channel].domain;
    const [V] = columnOf(encode, by !== null && by !== void 0 ? by : channel);
    const [T2] = columnOf(encode, channel);
    const normalizeReducer2 = createReducer(channel, { by, reducer }, encode);
    const SI = filterIndex(I, T2, domain);
    const sortedDomain = groupSort(SI, normalizeReducer2, (i2) => T2[i2]);
    const sortedI = !ordinal ? sort(I, (i2) => V[i2]) : I;
    if (reverse2) {
      !ordinal && sortedI.reverse();
      sortedDomain.reverse();
    }
    const s3 = typeof slice3 === "number" ? [0, slice3] : slice3;
    const slicedDomain = slice3 ? sortedDomain.slice(...s3) : sortedDomain;
    return [
      sortedI,
      deep_mix_default(mark2, { scale: { [channel]: { domain: slicedDomain } } })
    ];
  };
};
Sort.props = {};

// node_modules/@antv/g2/esm/transform/sortX.js
var SortX = (options = {}) => {
  return Sort(Object.assign(Object.assign({}, options), { channel: "x" }));
};
SortX.props = {};

// node_modules/@antv/g2/esm/transform/sortColor.js
var SortColor = (options = {}) => {
  return Sort(Object.assign(Object.assign({}, options), { channel: "color" }));
};
SortColor.props = {};

// node_modules/@antv/g2/esm/transform/sortY.js
var SortY = (options = {}) => {
  return Sort(Object.assign(Object.assign({}, options), { channel: "y" }));
};
SortY.props = {};

// node_modules/@antv/g2/esm/transform/flexX.js
function valueOf(data, field3) {
  if (typeof field3 === "string")
    return data.map((d3) => d3[field3]);
  return data.map(field3);
}
function createReducer2(reducer, V) {
  if (typeof reducer === "function")
    return (GI) => reducer(GI, V);
  if (reducer === "sum")
    return (GI) => sum(GI, (i2) => +V[i2]);
  throw new Error(`Unknown reducer: ${reducer}`);
}
var FlexX = (options = {}) => {
  const { field: field3, channel = "y", reducer = "sum" } = options;
  return (I, mark2) => {
    const { data, encode } = mark2;
    const [x2] = columnOf(encode, "x");
    const V = field3 ? valueOf(data, field3) : columnOf(encode, channel)[0];
    const reducerFunction = createReducer2(reducer, V);
    const flex = rollups(I, reducerFunction, (i2) => x2[i2]).map((d3) => d3[1]);
    return [I, deep_mix_default({}, mark2, { scale: { x: { flex } } })];
  };
};
FlexX.props = {};

// node_modules/@antv/g2/esm/utils/vector.js
function sub([x12, y12], [x2, y22]) {
  return [x12 - x2, y12 - y22];
}
function add([x12, y12], [x2, y22]) {
  return [x12 + x2, y12 + y22];
}
function dist([x05, y05], [x12, y12]) {
  return Math.sqrt(Math.pow(x05 - x12, 2) + Math.pow(y05 - y12, 2));
}
function angle([x2, y3]) {
  return Math.atan2(y3, x2);
}
function angleWithQuadrant([x2, y3]) {
  return angle([x2, y3]) + Math.PI / 2;
}
function angleBetween(v0, v1) {
  const a0 = angle(v0);
  const a1 = angle(v1);
  if (a0 < a1)
    return a1 - a0;
  return Math.PI * 2 - (a0 - a1);
}
function calcBBox(points) {
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY2 = -Infinity;
  for (const [x2, y3] of points) {
    minX = Math.min(x2, minX);
    maxX = Math.max(x2, maxX);
    minY = Math.min(y3, minY);
    maxY2 = Math.max(y3, maxY2);
  }
  const width = maxX - minX;
  const height = maxY2 - minY;
  return [minX, minY, width, height];
}
function mid([x12, y12], [x2, y22]) {
  return [(x12 + x2) / 2, (y12 + y22) / 2];
}

// node_modules/@antv/g2/esm/transform/pack.js
function pack(options) {
  const { padding = 0, direction: direction2 = "col" } = options;
  return (P, count4, layout) => {
    const pcount = P.length;
    if (pcount === 0)
      return [];
    const { innerWidth, innerHeight } = layout;
    const aspect = innerHeight / innerWidth;
    let col = Math.ceil(Math.sqrt(count4 / aspect));
    let size4 = innerWidth / col;
    let row = Math.ceil(count4 / col);
    let h0 = row * size4;
    while (h0 > innerHeight) {
      col = col + 1;
      size4 = innerWidth / col;
      row = Math.ceil(count4 / col);
      h0 = row * size4;
    }
    const space = innerHeight - row * size4;
    const intervalY = row <= 1 ? 0 : space / (row - 1);
    const [offsetX, offsetY] = row <= 1 ? [
      (innerWidth - pcount * size4) / (pcount - 1),
      (innerHeight - size4) / 2
    ] : [0, 0];
    return P.map((points, m2) => {
      const [x2, y3, width, height] = calcBBox(points);
      const i2 = direction2 === "col" ? m2 % col : Math.floor(m2 / row);
      const j = direction2 === "col" ? Math.floor(m2 / col) : m2 % row;
      const newX = i2 * size4;
      const newY = (row - j - 1) * size4 + space;
      const sx = (size4 - padding) / width;
      const sy = (size4 - padding) / height;
      const tx = newX - x2 + offsetX * i2 + 1 / 2 * padding;
      const ty = newY - y3 - intervalY * j - offsetY + 1 / 2 * padding;
      return `translate(${tx}, ${ty}) scale(${sx}, ${sy})`;
    });
  };
}
var Pack = (options) => {
  return (I, mark2) => {
    return [I, deep_mix_default({}, mark2, { modifier: pack(options), axis: false })];
  };
};
Pack.props = {};

// node_modules/@antv/g2/esm/transform/bin.js
var __rest10 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var THRESHOLD = "thresholds";
function thresholdAuto(values4) {
  const [min6, max7] = extent(values4);
  return Math.min(200, thresholdScott(values4, min6, max7));
}
var Bin = (options = {}) => {
  const { groupChannels = ["color"], binChannels = ["x", "y"] } = options, rest = __rest10(options, ["groupChannels", "binChannels"]);
  const channelIndexKey = {};
  const groupBy2 = (I, mark2) => {
    const { encode } = mark2;
    const binValues = binChannels.map((channel) => {
      const [V] = columnOf(encode, channel);
      return V;
    });
    const thresholds = subObject(rest, THRESHOLD);
    const DI = I.filter((i2) => binValues.every((V) => defined(V[i2])));
    const groupKeys = [
      // For discrete channels, use value as group key.
      ...groupChannels.map((d3) => {
        const [V] = columnOf(encode, d3);
        return V;
      }).filter(defined).map((V) => (i2) => V[i2]),
      // For quantitative channels, use extent of bin as group key.
      ...binChannels.map((d3, i2) => {
        const V = binValues[i2];
        const t = thresholds[d3] || thresholdAuto(V);
        const bins = bin().thresholds(t).value((i3) => +V[i3])(DI);
        const indexKey = new Map(bins.flatMap((bin2) => {
          const { x0: x05, x1: x12 } = bin2;
          const key2 = `${x05},${x12}`;
          return bin2.map((i3) => [i3, key2]);
        }));
        channelIndexKey[d3] = indexKey;
        return (i3) => indexKey.get(i3);
      })
    ];
    const key = (i2) => groupKeys.map((key2) => key2(i2)).join("-");
    return Array.from(group(DI, key).values());
  };
  return GroupN(Object.assign(Object.assign(Object.assign({}, Object.fromEntries(Object.entries(rest).filter(([k2]) => !k2.startsWith(THRESHOLD)))), Object.fromEntries(binChannels.flatMap((channel) => {
    const start = ([i2]) => +channelIndexKey[channel].get(i2).split(",")[0];
    const end = ([i2]) => +channelIndexKey[channel].get(i2).split(",")[1];
    end.from = channel;
    return [
      [channel, start],
      [`${channel}1`, end]
    ];
  }))), { groupBy: groupBy2 }));
};
Bin.props = {};

// node_modules/@antv/g2/esm/transform/binX.js
var BinX = (options = {}) => {
  const { thresholds } = options;
  return Bin(Object.assign(Object.assign({}, options), { thresholdsX: thresholds, groupChannels: ["color"], binChannels: ["x"] }));
};
BinX.props = {};

// node_modules/@antv/g2/esm/transform/utils/lttb.js
function lttb(I, X, Y, thresholds) {
  const length = I.length;
  if (thresholds >= length || thresholds === 0) {
    return I;
  }
  const x2 = (i2) => X[I[i2]] * 1;
  const y3 = (i2) => Y[I[i2]] * 1;
  const sampled = [];
  const every2 = (length - 2) / (thresholds - 2);
  let a4 = 0;
  let maxArea;
  let area2;
  let nextA;
  sampled.push(a4);
  for (let i2 = 0; i2 < thresholds - 2; i2++) {
    let avgX = 0;
    let avgY = 0;
    let start = Math.floor((i2 + 1) * every2) + 1;
    let end = Math.floor((i2 + 2) * every2) + 1;
    end = Math.min(end, length);
    const size4 = end - start;
    for (; start < end; start++) {
      avgX += x2(start);
      avgY += y3(start);
    }
    avgX /= size4;
    avgY /= size4;
    let frameStart = Math.floor((i2 + 0) * every2) + 1;
    const frameEnd = Math.floor((i2 + 1) * every2) + 1;
    const pointA = [x2(a4), y3(a4)];
    maxArea = area2 = -1;
    for (; frameStart < frameEnd; frameStart++) {
      area2 = Math.abs((pointA[0] - avgX) * (x2(frameStart) - pointA[1]) - (pointA[0] - y3(frameStart)) * (avgY - pointA[0])) * 0.5;
      if (area2 > maxArea) {
        maxArea = area2;
        nextA = frameStart;
      }
    }
    sampled.push(nextA);
    a4 = nextA;
  }
  sampled.push(length - 1);
  return sampled.map((a5) => I[a5]);
}

// node_modules/@antv/g2/esm/transform/sample.js
function normalizeSample(strategy) {
  if (typeof strategy === "function")
    return strategy;
  if (strategy === "lttb")
    return lttb;
  const strategies = {
    first: (f2) => [f2[0]],
    last: (f2) => [f2[f2.length - 1]],
    min: (f2, X, Y) => [
      f2[minIndex(f2, (i2) => Y[i2])]
    ],
    max: (f2, X, Y) => [
      f2[maxIndex(f2, (i2) => Y[i2])]
    ],
    median: (f2, X, Y) => [
      f2[medianIndex(f2, (i2) => Y[i2])]
    ]
  };
  const sampleFunction = strategies[strategy] || strategies.median;
  return (I, X, Y, thresholds) => {
    const frameSize = Math.max(1, Math.floor(I.length / thresholds));
    const frames = getFrames(I, frameSize);
    return frames.flatMap((frame) => sampleFunction(frame, X, Y));
  };
}
function getFrames(I, frameSize) {
  const size4 = I.length;
  const frames = [];
  let i2 = 0;
  while (i2 < size4) {
    frames.push(I.slice(i2, i2 += frameSize));
  }
  return frames;
}
var Sample = (options = {}) => {
  const { strategy = "median", thresholds = 2e3, groupBy: groupBy2 = ["series", "color"] } = options;
  const sampleFunction = normalizeSample(strategy);
  return (I, mark2) => {
    const { encode } = mark2;
    const groups2 = createGroups(groupBy2, I, mark2);
    const [X] = columnOf(encode, "x");
    const [Y] = columnOf(encode, "y");
    return [
      groups2.flatMap((g) => sampleFunction(g, X, Y, thresholds)),
      mark2
    ];
  };
};
Sample.props = {};

// node_modules/@antv/g2/esm/transform/filter.js
function normalizeValue(value2) {
  if (typeof value2 === "object")
    return [value2.value, value2.ordinal];
  else
    return [value2, true];
}
function filterWhenNoElements(mark2) {
  var _a;
  const { encode } = mark2;
  const noElementMark = Object.assign(Object.assign({}, mark2), { encode: Object.assign(Object.assign({}, mark2.encode), { y: Object.assign(Object.assign({}, mark2.encode.y), { value: [] }) }) });
  const targetField = (_a = encode === null || encode === void 0 ? void 0 : encode.color) === null || _a === void 0 ? void 0 : _a.field;
  if (!encode || !targetField) {
    return noElementMark;
  }
  let filterObject;
  for (const [key, v] of Object.entries(encode)) {
    if ((key === "x" || key === "y") && v.field === targetField) {
      filterObject = Object.assign(Object.assign({}, filterObject), { [key]: Object.assign(Object.assign({}, v), { value: [] }) });
    }
  }
  if (!filterObject) {
    return noElementMark;
  }
  return Object.assign(Object.assign({}, mark2), { encode: Object.assign(Object.assign({}, mark2.encode), filterObject) });
}
var Filter = (options = {}) => {
  return (I, mark2) => {
    const { encode, data } = mark2;
    const filters = Object.entries(options).map(([key, v]) => {
      const [V] = columnOf(encode, key);
      if (!V)
        return null;
      const [value2, ordinal = true] = normalizeValue(v);
      if (typeof value2 === "function")
        return (i2) => value2(V[i2]);
      if (ordinal) {
        const expectedValues = Array.isArray(value2) ? value2 : [value2];
        if (expectedValues.length === 0)
          return null;
        return (i2) => expectedValues.includes(V[i2]);
      } else {
        const [start, end] = value2;
        return (i2) => V[i2] >= start && V[i2] <= end;
      }
    }).filter(defined);
    const totalFilter = (i2) => filters.every((f2) => f2(i2));
    const FI = I.filter(totalFilter);
    const newIndex = FI.map((_, i2) => i2);
    if (filters.length === 0) {
      const targetMark = filterWhenNoElements(mark2);
      return [I, targetMark];
    }
    const newEncodes = Object.entries(encode).map(([key, encode2]) => {
      return [
        key,
        Object.assign(Object.assign({}, encode2), { value: newIndex.map((i2) => encode2.value[FI[i2]]).filter((v) => v !== void 0) })
      ];
    });
    return [
      newIndex,
      deep_mix_default({}, mark2, {
        encode: Object.fromEntries(newEncodes),
        // Filter data for tooltip item.
        data: FI.map((i2) => data[i2])
      })
    ];
  };
};
Filter.props = {};

// node_modules/d3-shape/src/constant.js
function constant_default(x2) {
  return function constant4() {
    return x2;
  };
}

// node_modules/d3-shape/src/math.js
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max4 = Math.max;
var min4 = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;
var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;
function acos(x2) {
  return x2 > 1 ? 0 : x2 < -1 ? pi : Math.acos(x2);
}
function asin(x2) {
  return x2 >= 1 ? halfPi : x2 <= -1 ? -halfPi : Math.asin(x2);
}

// node_modules/d3-path/src/path.js
var pi2 = Math.PI;
var tau2 = 2 * pi2;
var epsilon2 = 1e-6;
var tauEpsilon = tau2 - epsilon2;
function append(strings) {
  this._ += strings[0];
  for (let i2 = 1, n2 = strings.length; i2 < n2; ++i2) {
    this._ += arguments[i2] + strings[i2];
  }
}
function appendRound(digits) {
  let d3 = Math.floor(digits);
  if (!(d3 >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d3 > 15) return append;
  const k2 = __pow(10, d3);
  return function(strings) {
    this._ += strings[0];
    for (let i2 = 1, n2 = strings.length; i2 < n2; ++i2) {
      this._ += Math.round(arguments[i2] * k2) / k2 + strings[i2];
    }
  };
}
var Path2 = class {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x2, y3) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y3}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x2, y3) {
    this._append`L${this._x1 = +x2},${this._y1 = +y3}`;
  }
  quadraticCurveTo(x12, y12, x2, y3) {
    this._append`Q${+x12},${+y12},${this._x1 = +x2},${this._y1 = +y3}`;
  }
  bezierCurveTo(x12, y12, x2, y22, x3, y3) {
    this._append`C${+x12},${+y12},${+x2},${+y22},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  arcTo(x12, y12, x2, y22, r2) {
    x12 = +x12, y12 = +y12, x2 = +x2, y22 = +y22, r2 = +r2;
    if (r2 < 0) throw new Error(`negative radius: ${r2}`);
    let x05 = this._x1, y05 = this._y1, x21 = x2 - x12, y21 = y22 - y12, x01 = x05 - x12, y01 = y05 - y12, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x12},${this._y1 = y12}`;
    } else if (!(l01_2 > epsilon2)) ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon2) || !r2) {
      this._append`L${this._x1 = x12},${this._y1 = y12}`;
    } else {
      let x20 = x2 - x05, y20 = y22 - y05, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l2 = r2 * Math.tan((pi2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l2 / l01, t21 = l2 / l21;
      if (Math.abs(t01 - 1) > epsilon2) {
        this._append`L${x12 + t01 * x01},${y12 + t01 * y01}`;
      }
      this._append`A${r2},${r2},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x12 + t21 * x21},${this._y1 = y12 + t21 * y21}`;
    }
  }
  arc(x2, y3, r2, a0, a1, ccw) {
    x2 = +x2, y3 = +y3, r2 = +r2, ccw = !!ccw;
    if (r2 < 0) throw new Error(`negative radius: ${r2}`);
    let dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x05 = x2 + dx, y05 = y3 + dy, cw2 = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x05},${y05}`;
    } else if (Math.abs(this._x1 - x05) > epsilon2 || Math.abs(this._y1 - y05) > epsilon2) {
      this._append`L${x05},${y05}`;
    }
    if (!r2) return;
    if (da < 0) da = da % tau2 + tau2;
    if (da > tauEpsilon) {
      this._append`A${r2},${r2},0,1,${cw2},${x2 - dx},${y3 - dy}A${r2},${r2},0,1,${cw2},${this._x1 = x05},${this._y1 = y05}`;
    } else if (da > epsilon2) {
      this._append`A${r2},${r2},0,${+(da >= pi2)},${cw2},${this._x1 = x2 + r2 * Math.cos(a1)},${this._y1 = y3 + r2 * Math.sin(a1)}`;
    }
  }
  rect(x2, y3, w2, h2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y3}h${w2 = +w2}v${+h2}h${-w2}Z`;
  }
  toString() {
    return this._;
  }
};
function path() {
  return new Path2();
}
path.prototype = Path2.prototype;

// node_modules/d3-shape/src/path.js
function withPath(shape24) {
  let digits = 3;
  shape24.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null) {
      digits = null;
    } else {
      const d3 = Math.floor(_);
      if (!(d3 >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d3;
    }
    return shape24;
  };
  return () => new Path2(digits);
}

// node_modules/d3-shape/src/arc.js
function arcInnerRadius(d3) {
  return d3.innerRadius;
}
function arcOuterRadius(d3) {
  return d3.outerRadius;
}
function arcStartAngle(d3) {
  return d3.startAngle;
}
function arcEndAngle(d3) {
  return d3.endAngle;
}
function arcPadAngle(d3) {
  return d3 && d3.padAngle;
}
function intersect(x05, y05, x12, y12, x2, y22, x3, y3) {
  var x10 = x12 - x05, y10 = y12 - y05, x32 = x3 - x2, y32 = y3 - y22, t = y32 * x10 - x32 * y10;
  if (t * t < epsilon) return;
  t = (x32 * (y05 - y22) - y32 * (x05 - x2)) / t;
  return [x05 + t * x10, y05 + t * y10];
}
function cornerTangents(x05, y05, x12, y12, r1, rc, cw2) {
  var x01 = x05 - x12, y01 = y05 - y12, lo = (cw2 ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x05 + ox, y11 = y05 + oy, x10 = x12 + ox, y10 = y12 + oy, x004 = (x11 + x10) / 2, y004 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d22 = dx * dx + dy * dy, r2 = r1 - rc, D = x11 * y10 - x10 * y11, d3 = (dy < 0 ? -1 : 1) * sqrt(max4(0, r2 * r2 * d22 - D * D)), cx0 = (D * dy - dx * d3) / d22, cy0 = (-D * dx - dy * d3) / d22, cx1 = (D * dy + dx * d3) / d22, cy1 = (-D * dx + dy * d3) / d22, dx0 = cx0 - x004, dy0 = cy0 - y004, dx1 = cx1 - x004, dy1 = cy1 - y004;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r2 - 1),
    y11: cy0 * (r1 / r2 - 1)
  };
}
function arc_default() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path2 = withPath(arc);
  function arc() {
    var buffer, r2, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs(a1 - a0), cw2 = a1 > a0;
    if (!context) context = buffer = path2();
    if (r1 < r0) r2 = r1, r1 = r0, r0 = r2;
    if (!(r1 > epsilon)) context.moveTo(0, 0);
    else if (da > tau - epsilon) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw2);
      if (r0 > epsilon) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw2);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min4(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t0, t1;
      if (rp > epsilon) {
        var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon) p0 *= cw2 ? 1 : -1, a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon) p1 *= cw2 ? 1 : -1, a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
      if (rc > epsilon) {
        var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x004 = r0 * cos(a00), y004 = r0 * sin(a00), oc;
        if (da < pi) {
          if (oc = intersect(x01, y01, x004, y004, x11, y11, x10, y10)) {
            var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min4(rc, (r0 - lc) / (kc - 1));
            rc1 = min4(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }
      if (!(da1 > epsilon)) context.moveTo(x01, y01);
      else if (rc1 > epsilon) {
        t0 = cornerTangents(x004, y004, x01, y01, r1, rc1, cw2);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw2);
        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw2);
        else {
          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw2);
          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw2);
          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw2);
        }
      } else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw2);
      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);
      else if (rc0 > epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw2);
        t1 = cornerTangents(x01, y01, x004, y004, r0, -rc0, cw2);
        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw2);
        else {
          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw2);
          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw2);
          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw2);
        }
      } else context.arc(0, 0, r0, a10, a00, cw2);
    }
    context.closePath();
    if (buffer) return context = null, buffer + "" || null;
  }
  arc.centroid = function() {
    var r2 = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a4 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
    return [cos(a4) * r2, sin(a4) * r2];
  };
  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant_default(+_), arc) : innerRadius;
  };
  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant_default(+_), arc) : outerRadius;
  };
  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant_default(+_), arc) : cornerRadius;
  };
  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), arc) : padRadius;
  };
  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default(+_), arc) : startAngle;
  };
  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default(+_), arc) : endAngle;
  };
  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default(+_), arc) : padAngle;
  };
  arc.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, arc) : context;
  };
  return arc;
}

// node_modules/d3-shape/src/array.js
var slice2 = Array.prototype.slice;
function array_default(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}

// node_modules/d3-shape/src/curve/linear.js
function Linear2(context) {
  this._context = context;
}
Linear2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y3) {
    x2 = +x2, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y3) : this._context.moveTo(x2, y3);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x2, y3);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear2(context);
}

// node_modules/d3-shape/src/point.js
function x(p3) {
  return p3[0];
}
function y(p3) {
  return p3[1];
}

// node_modules/d3-shape/src/line.js
function line_default(x2, y3) {
  var defined3 = constant_default(true), context = null, curve = linear_default, output = null, path2 = withPath(line3);
  x2 = typeof x2 === "function" ? x2 : x2 === void 0 ? x : constant_default(x2);
  y3 = typeof y3 === "function" ? y3 : y3 === void 0 ? y : constant_default(y3);
  function line3(data) {
    var i2, n2 = (data = array_default(data)).length, d3, defined0 = false, buffer;
    if (context == null) output = curve(buffer = path2());
    for (i2 = 0; i2 <= n2; ++i2) {
      if (!(i2 < n2 && defined3(d3 = data[i2], i2, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x2(d3, i2, data), +y3(d3, i2, data));
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  line3.x = function(_) {
    return arguments.length ? (x2 = typeof _ === "function" ? _ : constant_default(+_), line3) : x2;
  };
  line3.y = function(_) {
    return arguments.length ? (y3 = typeof _ === "function" ? _ : constant_default(+_), line3) : y3;
  };
  line3.defined = function(_) {
    return arguments.length ? (defined3 = typeof _ === "function" ? _ : constant_default(!!_), line3) : defined3;
  };
  line3.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line3) : curve;
  };
  line3.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line3) : context;
  };
  return line3;
}

// node_modules/d3-shape/src/area.js
function area_default(x05, y05, y12) {
  var x12 = null, defined3 = constant_default(true), context = null, curve = linear_default, output = null, path2 = withPath(area2);
  x05 = typeof x05 === "function" ? x05 : x05 === void 0 ? x : constant_default(+x05);
  y05 = typeof y05 === "function" ? y05 : y05 === void 0 ? constant_default(0) : constant_default(+y05);
  y12 = typeof y12 === "function" ? y12 : y12 === void 0 ? y : constant_default(+y12);
  function area2(data) {
    var i2, j, k2, n2 = (data = array_default(data)).length, d3, defined0 = false, buffer, x0z = new Array(n2), y0z = new Array(n2);
    if (context == null) output = curve(buffer = path2());
    for (i2 = 0; i2 <= n2; ++i2) {
      if (!(i2 < n2 && defined3(d3 = data[i2], i2, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i2;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k2 = i2 - 1; k2 >= j; --k2) {
            output.point(x0z[k2], y0z[k2]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i2] = +x05(d3, i2, data), y0z[i2] = +y05(d3, i2, data);
        output.point(x12 ? +x12(d3, i2, data) : x0z[i2], y12 ? +y12(d3, i2, data) : y0z[i2]);
      }
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  function arealine() {
    return line_default().defined(defined3).curve(curve).context(context);
  }
  area2.x = function(_) {
    return arguments.length ? (x05 = typeof _ === "function" ? _ : constant_default(+_), x12 = null, area2) : x05;
  };
  area2.x0 = function(_) {
    return arguments.length ? (x05 = typeof _ === "function" ? _ : constant_default(+_), area2) : x05;
  };
  area2.x1 = function(_) {
    return arguments.length ? (x12 = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), area2) : x12;
  };
  area2.y = function(_) {
    return arguments.length ? (y05 = typeof _ === "function" ? _ : constant_default(+_), y12 = null, area2) : y05;
  };
  area2.y0 = function(_) {
    return arguments.length ? (y05 = typeof _ === "function" ? _ : constant_default(+_), area2) : y05;
  };
  area2.y1 = function(_) {
    return arguments.length ? (y12 = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), area2) : y12;
  };
  area2.lineX0 = area2.lineY0 = function() {
    return arealine().x(x05).y(y05);
  };
  area2.lineY1 = function() {
    return arealine().x(x05).y(y12);
  };
  area2.lineX1 = function() {
    return arealine().x(x12).y(y05);
  };
  area2.defined = function(_) {
    return arguments.length ? (defined3 = typeof _ === "function" ? _ : constant_default(!!_), area2) : defined3;
  };
  area2.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area2) : curve;
  };
  area2.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area2) : context;
  };
  return area2;
}

// node_modules/d3-shape/src/curve/radial.js
var curveRadialLinear = curveRadial(linear_default);
function Radial2(curve) {
  this._curve = curve;
}
Radial2.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a4, r2) {
    this._curve.point(r2 * Math.sin(a4), r2 * -Math.cos(a4));
  }
};
function curveRadial(curve) {
  function radial(context) {
    return new Radial2(curve(context));
  }
  radial._curve = curve;
  return radial;
}

// node_modules/d3-shape/src/lineRadial.js
function lineRadial(l2) {
  var c5 = l2.curve;
  l2.angle = l2.x, delete l2.x;
  l2.radius = l2.y, delete l2.y;
  l2.curve = function(_) {
    return arguments.length ? c5(curveRadial(_)) : c5()._curve;
  };
  return l2;
}
function lineRadial_default() {
  return lineRadial(line_default().curve(curveRadialLinear));
}

// node_modules/d3-shape/src/areaRadial.js
function areaRadial_default() {
  var a4 = area_default().curve(curveRadialLinear), c5 = a4.curve, x05 = a4.lineX0, x12 = a4.lineX1, y05 = a4.lineY0, y12 = a4.lineY1;
  a4.angle = a4.x, delete a4.x;
  a4.startAngle = a4.x0, delete a4.x0;
  a4.endAngle = a4.x1, delete a4.x1;
  a4.radius = a4.y, delete a4.y;
  a4.innerRadius = a4.y0, delete a4.y0;
  a4.outerRadius = a4.y1, delete a4.y1;
  a4.lineStartAngle = function() {
    return lineRadial(x05());
  }, delete a4.lineX0;
  a4.lineEndAngle = function() {
    return lineRadial(x12());
  }, delete a4.lineX1;
  a4.lineInnerRadius = function() {
    return lineRadial(y05());
  }, delete a4.lineY0;
  a4.lineOuterRadius = function() {
    return lineRadial(y12());
  }, delete a4.lineY1;
  a4.curve = function(_) {
    return arguments.length ? c5(curveRadial(_)) : c5()._curve;
  };
  return a4;
}

// node_modules/d3-shape/src/symbol/asterisk.js
var sqrt3 = sqrt(3);

// node_modules/d3-shape/src/symbol/diamond.js
var tan30 = sqrt(1 / 3);
var tan30_2 = tan30 * 2;

// node_modules/d3-shape/src/symbol/star.js
var kr = sin(pi / 10) / sin(7 * pi / 10);
var kx = sin(tau / 10) * kr;
var ky = -cos(tau / 10) * kr;

// node_modules/d3-shape/src/symbol/triangle.js
var sqrt32 = sqrt(3);

// node_modules/d3-shape/src/symbol/triangle2.js
var sqrt33 = sqrt(3);

// node_modules/d3-shape/src/symbol/wye.js
var s = sqrt(3) / 2;
var k = 1 / sqrt(12);
var a = (k / 2 + 1) * 3;

// node_modules/d3-shape/src/noop.js
function noop_default() {
}

// node_modules/d3-shape/src/curve/basis.js
function point(that, x2, y3) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x2) / 6,
    (that._y0 + 4 * that._y1 + y3) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y3) {
    x2 = +x2, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y3) : this._context.moveTo(x2, y3);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point(this, x2, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y3;
  }
};

// node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x2, y3) {
    x2 = +x2, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x2, this._y2 = y3;
        break;
      case 1:
        this._point = 2;
        this._x3 = x2, this._y3 = y3;
        break;
      case 2:
        this._point = 3;
        this._x4 = x2, this._y4 = y3;
        this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y3) / 6);
        break;
      default:
        point(this, x2, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y3;
  }
};

// node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y3) {
    x2 = +x2, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x05 = (this._x0 + 4 * this._x1 + x2) / 6, y05 = (this._y0 + 4 * this._y1 + y3) / 6;
        this._line ? this._context.lineTo(x05, y05) : this._context.moveTo(x05, y05);
        break;
      case 3:
        this._point = 4;
      default:
        point(this, x2, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y3;
  }
};

// node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x2 = this._x, y3 = this._y, j = x2.length - 1;
    if (j > 0) {
      var x05 = x2[0], y05 = y3[0], dx = x2[j] - x05, dy = y3[j] - y05, i2 = -1, t;
      while (++i2 <= j) {
        t = i2 / j;
        this._basis.point(
          this._beta * x2[i2] + (1 - this._beta) * (x05 + t * dx),
          this._beta * y3[i2] + (1 - this._beta) * (y05 + t * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x2, y3) {
    this._x.push(+x2);
    this._y.push(+y3);
  }
};
var bundle_default = function custom(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom(+beta2);
  };
  return bundle;
}(0.85);

// node_modules/d3-shape/src/curve/cardinal.js
function point2(that, x2, y3) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x2),
    that._y2 + that._k * (that._y1 - y3),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point2(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y3) {
    x2 = +x2, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y3) : this._context.moveTo(x2, y3);
        break;
      case 1:
        this._point = 2;
        this._x1 = x2, this._y1 = y3;
        break;
      case 2:
        this._point = 3;
      default:
        point2(this, x2, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var cardinal_default = function custom2(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom2(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x2, y3) {
    x2 = +x2, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x2, this._y3 = y3;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x2, this._y4 = y3);
        break;
      case 2:
        this._point = 3;
        this._x5 = x2, this._y5 = y3;
        break;
      default:
        point2(this, x2, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var cardinalClosed_default = function custom3(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom3(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y3) {
    x2 = +x2, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point2(this, x2, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var cardinalOpen_default = function custom4(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom4(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/catmullRom.js
function point3(that, x2, y3) {
  var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon) {
    var a4 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n2 = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x12 = (x12 * a4 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n2;
    y12 = (y12 * a4 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n2;
  }
  if (that._l23_a > epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m2 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b + that._x1 * that._l23_2a - x2 * that._l12_2a) / m2;
    y22 = (y22 * b + that._y1 * that._l23_2a - y3 * that._l12_2a) / m2;
  }
  that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y3) {
    x2 = +x2, y3 = +y3;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y3;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y3) : this._context.moveTo(x2, y3);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point3(this, x2, y3);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var catmullRom_default = function custom5(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom5(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x2, y3) {
    x2 = +x2, y3 = +y3;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y3;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x2, this._y3 = y3;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x2, this._y4 = y3);
        break;
      case 2:
        this._point = 3;
        this._x5 = x2, this._y5 = y3;
        break;
      default:
        point3(this, x2, y3);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var catmullRomClosed_default = function custom6(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom6(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y3) {
    x2 = +x2, y3 = +y3;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y3;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point3(this, x2, y3);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var catmullRomOpen_default = function custom7(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom7(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x2, y3) {
    x2 = +x2, y3 = +y3;
    if (this._point) this._context.lineTo(x2, y3);
    else this._point = 1, this._context.moveTo(x2, y3);
  }
};
function linearClosed_default(context) {
  return new LinearClosed(context);
}

// node_modules/d3-shape/src/curve/monotone.js
function sign(x2) {
  return x2 < 0 ? -1 : 1;
}
function slope3(that, x2, y22) {
  var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p3 = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p3)) || 0;
}
function slope2(that, t) {
  var h2 = that._x1 - that._x0;
  return h2 ? (3 * (that._y1 - that._y0) / h2 - t) / 2 : t;
}
function point4(that, t0, t1) {
  var x05 = that._x0, y05 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x05) / 3;
  that._context.bezierCurveTo(x05 + dx, y05 + dx * t0, x12 - dx, y12 - dx * t1, x12, y12);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point4(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y3) {
    var t1 = NaN;
    x2 = +x2, y3 = +y3;
    if (x2 === this._x1 && y3 === this._y1) return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y3) : this._context.moveTo(x2, y3);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point4(this, slope2(this, t1 = slope3(this, x2, y3)), t1);
        break;
      default:
        point4(this, this._t0, t1 = slope3(this, x2, y3));
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y3;
    this._t0 = t1;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y3) {
  MonotoneX.prototype.point.call(this, y3, x2);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x2, y3) {
    this._context.moveTo(y3, x2);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x2, y3) {
    this._context.lineTo(y3, x2);
  },
  bezierCurveTo: function(x12, y12, x2, y22, x3, y3) {
    this._context.bezierCurveTo(y12, x12, y22, x2, y3, x3);
  }
};
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}

// node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x2 = this._x, y3 = this._y, n2 = x2.length;
    if (n2) {
      this._line ? this._context.lineTo(x2[0], y3[0]) : this._context.moveTo(x2[0], y3[0]);
      if (n2 === 2) {
        this._context.lineTo(x2[1], y3[1]);
      } else {
        var px = controlPoints(x2), py = controlPoints(y3);
        for (var i0 = 0, i1 = 1; i1 < n2; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y3[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n2 === 1) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x2, y3) {
    this._x.push(+x2);
    this._y.push(+y3);
  }
};
function controlPoints(x2) {
  var i2, n2 = x2.length - 1, m2, a4 = new Array(n2), b = new Array(n2), r2 = new Array(n2);
  a4[0] = 0, b[0] = 2, r2[0] = x2[0] + 2 * x2[1];
  for (i2 = 1; i2 < n2 - 1; ++i2) a4[i2] = 1, b[i2] = 4, r2[i2] = 4 * x2[i2] + 2 * x2[i2 + 1];
  a4[n2 - 1] = 2, b[n2 - 1] = 7, r2[n2 - 1] = 8 * x2[n2 - 1] + x2[n2];
  for (i2 = 1; i2 < n2; ++i2) m2 = a4[i2] / b[i2 - 1], b[i2] -= m2, r2[i2] -= m2 * r2[i2 - 1];
  a4[n2 - 1] = r2[n2 - 1] / b[n2 - 1];
  for (i2 = n2 - 2; i2 >= 0; --i2) a4[i2] = (r2[i2] - a4[i2 + 1]) / b[i2];
  b[n2 - 1] = (x2[n2] + a4[n2 - 1]) / 2;
  for (i2 = 0; i2 < n2 - 1; ++i2) b[i2] = 2 * x2[i2 + 1] - a4[i2 + 1];
  return [a4, b];
}

// node_modules/d3-shape/src/curve/step.js
function Step(context, t) {
  this._context = context;
  this._t = t;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x2, y3) {
    x2 = +x2, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y3) : this._context.moveTo(x2, y3);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y3);
          this._context.lineTo(x2, y3);
        } else {
          var x12 = this._x * (1 - this._t) + x2 * this._t;
          this._context.lineTo(x12, this._y);
          this._context.lineTo(x12, y3);
        }
        break;
      }
    }
    this._x = x2, this._y = y3;
  }
};
function step_default(context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}

// node_modules/@antv/g2/esm/utils/coordinate.js
function isTranspose(coordinate) {
  const { transformations } = coordinate.getOptions();
  const transposes = transformations.map(([type]) => type).filter((type) => type === "transpose");
  return transposes.length % 2 !== 0;
}
function isPolar(coordinate) {
  const { transformations } = coordinate.getOptions();
  return transformations.some(([type]) => type === "polar");
}
function isRadial(coordinate) {
  const { transformations } = coordinate.getOptions();
  return (
    // distinguish radial from theta.
    transformations.some(([type]) => type === "reflect") && transformations.some(([type]) => type.startsWith("transpose"))
  );
}
function isHelix(coordinate) {
  const { transformations } = coordinate.getOptions();
  return transformations.some(([type]) => type === "helix");
}
function isParallel(coordinate) {
  const { transformations } = coordinate.getOptions();
  return transformations.some(([type]) => type === "parallel");
}
function isFisheye(coordinate) {
  const { transformations } = coordinate.getOptions();
  return transformations.some(([type]) => type === "fisheye");
}
function isRadar(coordinate) {
  return isParallel(coordinate) && isPolar(coordinate);
}
function isCircular(coordinate) {
  return isHelix(coordinate) || isPolar(coordinate);
}
function isTheta(coordinate) {
  return isPolar(coordinate) && isTranspose(coordinate);
}
function getRadius(coordinate) {
  if (isCircular(coordinate)) {
    const [width, height] = coordinate.getSize();
    const polar2 = coordinate.getOptions().transformations.find((t) => t[0] === "polar");
    if (polar2)
      return Math.max(width, height) / 2 * polar2[4];
  }
  return 0;
}
function radiusOf(coordinate) {
  const { transformations } = coordinate.getOptions();
  const [, , , innerRadius, outerRadius] = transformations.find((d3) => d3[0] === "polar");
  return [+innerRadius, +outerRadius];
}
function angleOf(coordinate, isRadius = true) {
  const { transformations } = coordinate.getOptions();
  const [, startAngle, endAngle] = transformations.find((d3) => d3[0] === "polar");
  return isRadius ? [+startAngle * 180 / Math.PI, +endAngle * 180 / Math.PI] : [startAngle, endAngle];
}
function getTransformOptions(coordinate, type) {
  const { transformations } = coordinate.getOptions();
  const [, ...args] = transformations.find((d3) => d3[0] === type);
  return args;
}

// node_modules/@antv/g2/esm/utils/selection.js
function select(node) {
  return new Selection([node], null, node, node.ownerDocument);
}
var Selection = class _Selection {
  constructor(elements = null, data = null, parent = null, document2 = null, selections = [
    null,
    null,
    null,
    null,
    null
  ], transitions = [], updateElements = []) {
    this._elements = Array.from(elements);
    this._data = data;
    this._parent = parent;
    this._document = document2;
    this._enter = selections[0];
    this._update = selections[1];
    this._exit = selections[2];
    this._merge = selections[3];
    this._split = selections[4];
    this._transitions = transitions;
    this._facetElements = updateElements;
  }
  selectAll(selector) {
    const elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
    return new _Selection(elements, null, this._elements[0], this._document);
  }
  selectFacetAll(selector) {
    const elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
    return new _Selection(this._elements, null, this._parent, this._document, void 0, void 0, elements);
  }
  /**
   * @todo Replace with querySelector which has bug now.
   */
  select(selector) {
    const element = typeof selector === "string" ? this._parent.querySelectorAll(selector)[0] || null : selector;
    return new _Selection([element], null, element, this._document);
  }
  append(node) {
    const callback = typeof node === "function" ? node : () => this.createElement(node);
    const elements = [];
    if (this._data !== null) {
      for (let i2 = 0; i2 < this._data.length; i2++) {
        const d3 = this._data[i2];
        const [datum, from] = Array.isArray(d3) ? d3 : [d3, null];
        const newElement = callback(datum, i2);
        newElement.__data__ = datum;
        if (from !== null)
          newElement.__fromElements__ = from;
        this._parent.appendChild(newElement);
        elements.push(newElement);
      }
      return new _Selection(elements, null, this._parent, this._document);
    } else {
      for (let i2 = 0; i2 < this._elements.length; i2++) {
        const element = this._elements[i2];
        const datum = element.__data__;
        const newElement = callback(datum, i2);
        element.appendChild(newElement);
        elements.push(newElement);
      }
      return new _Selection(elements, null, elements[0], this._document);
    }
  }
  maybeAppend(id2, node, className2) {
    const element = this._elements[0];
    const child = element.getElementById(id2);
    if (child) {
      return new _Selection([child], null, this._parent, this._document);
    }
    const newChild = typeof node === "string" ? this.createElement(node) : node();
    newChild.id = id2;
    if (className2)
      newChild.className = className2;
    element.appendChild(newChild);
    return new _Selection([newChild], null, this._parent, this._document);
  }
  /**
   * Bind data to elements, and produce three selection:
   * Enter: Selection with empty elements and data to be bind to elements.
   * Update: Selection with elements to be updated.
   * Exit: Selection with elements to be removed.
   */
  data(data, id2 = (d3) => d3, groupId = () => null) {
    const enter = [];
    const update = [];
    const exit = new Set(this._elements);
    const merge2 = [];
    const split = /* @__PURE__ */ new Set();
    const keyElement = new Map(this._elements.map((d3, i2) => [id2(d3.__data__, i2), d3]));
    const keyUpdateElement = new Map(this._facetElements.map((d3, i2) => [id2(d3.__data__, i2), d3]));
    const groupKeyElements = group(this._elements, (d3) => groupId(d3.__data__));
    for (let i2 = 0; i2 < data.length; i2++) {
      const datum = data[i2];
      const key = id2(datum, i2);
      const groupKey = groupId(datum, i2);
      if (keyElement.has(key)) {
        const element = keyElement.get(key);
        element.__data__ = datum;
        element.__facet__ = false;
        update.push(element);
        exit.delete(element);
        keyElement.delete(key);
      } else if (keyUpdateElement.has(key)) {
        const element = keyUpdateElement.get(key);
        element.__data__ = datum;
        element.__facet__ = true;
        update.push(element);
        keyUpdateElement.delete(key);
      } else if (groupKeyElements.has(key)) {
        const group2 = groupKeyElements.get(key);
        merge2.push([datum, group2]);
        for (const element of group2)
          exit.delete(element);
        groupKeyElements.delete(key);
      } else if (keyElement.has(groupKey)) {
        const element = keyElement.get(groupKey);
        if (element.__toData__)
          element.__toData__.push(datum);
        else
          element.__toData__ = [datum];
        split.add(element);
        exit.delete(element);
      } else {
        enter.push(datum);
      }
    }
    const S = [
      new _Selection([], enter, this._parent, this._document),
      new _Selection(update, null, this._parent, this._document),
      new _Selection(exit, null, this._parent, this._document),
      new _Selection([], merge2, this._parent, this._document),
      new _Selection(split, null, this._parent, this._document)
    ];
    return new _Selection(this._elements, null, this._parent, this._document, S);
  }
  merge(other) {
    const elements = [...this._elements, ...other._elements];
    const transitions = [...this._transitions, ...other._transitions];
    return new _Selection(elements, null, this._parent, this._document, void 0, transitions);
  }
  createElement(type) {
    if (this._document) {
      return this._document.createElement(type, {});
    }
    const Ctor = _Selection.registry[type];
    if (Ctor)
      return new Ctor();
    return error(`Unknown node type: ${type}`);
  }
  /**
   * Apply callback for each selection(enter, update, exit)
   * and merge them into one selection.
   */
  join(enter = (d3) => d3, update = (d3) => d3, exit = (d3) => d3.remove(), merge2 = (d3) => d3, split = (d3) => d3.remove()) {
    const newEnter = enter(this._enter);
    const newUpdate = update(this._update);
    const newExit = exit(this._exit);
    const newMerge = merge2(this._merge);
    const newSplit = split(this._split);
    return newUpdate.merge(newEnter).merge(newExit).merge(newMerge).merge(newSplit);
  }
  remove() {
    for (let i2 = 0; i2 < this._elements.length; i2++) {
      const transition = this._transitions[i2];
      this._elements[i2].__removed__ = true;
      if (transition) {
        const T2 = Array.isArray(transition) ? transition : [transition];
        Promise.all(T2.map((d3) => d3.finished)).then(() => {
          const element = this._elements[i2];
          if (element.__removed__) {
            element.remove();
          }
        });
      } else {
        const element = this._elements[i2];
        if (element.__removed__) {
          element.remove();
        }
      }
    }
    return new _Selection([], null, this._parent, this._document, void 0, this._transitions);
  }
  each(callback) {
    for (let i2 = 0; i2 < this._elements.length; i2++) {
      const element = this._elements[i2];
      const datum = element.__data__;
      callback(datum, i2, element);
    }
    return this;
  }
  attr(key, value2) {
    const callback = typeof value2 !== "function" ? () => value2 : value2;
    return this.each(function(d3, i2, element) {
      if (value2 !== void 0)
        element[key] = callback(d3, i2, element);
    });
  }
  style(key, value2) {
    const callback = typeof value2 !== "function" ? () => value2 : value2;
    return this.each(function(d3, i2, element) {
      if (value2 !== void 0)
        element.style[key] = callback(d3, i2, element);
    });
  }
  transition(value2) {
    const callback = typeof value2 !== "function" ? () => value2 : value2;
    const { _transitions: T2 } = this;
    return this.each(function(d3, i2, element) {
      T2[i2] = callback(d3, i2, element);
    });
  }
  on(event, handler) {
    this.each(function(d3, i2, element) {
      element.addEventListener(event, handler);
    });
    return this;
  }
  call(callback, ...args) {
    callback(this, ...args);
    return this;
  }
  node() {
    return this._elements[0];
  }
  nodes() {
    return this._elements;
  }
  transitions() {
    return this._transitions;
  }
  parent() {
    return this._parent;
  }
};
Selection.registry = {
  g: Group,
  rect: Rect,
  circle: Circle,
  path: Path,
  text: Text,
  ellipse: Ellipse,
  image: Image2,
  line: Line,
  polygon: Polygon,
  polyline: Polyline,
  html: HTML
};

// node_modules/@antv/g2/esm/utils/number.js
function clamp(v, lower2, upper2) {
  return Math.max(lower2, Math.min(v, upper2));
}
function prettyNumber2(n2, precision = 10) {
  if (typeof n2 !== "number")
    return n2;
  return Math.abs(n2) < 1e-15 ? n2 : parseFloat(n2.toFixed(precision));
}

// node_modules/@antv/g2/esm/shape/utils.js
function applyStyle(selection, style) {
  for (const [key, value2] of Object.entries(style)) {
    selection.style(key, value2);
  }
}
function appendPolygon(path2, points) {
  points.forEach((p3, idx) => idx === 0 ? path2.moveTo(p3[0], p3[1]) : path2.lineTo(p3[0], p3[1]));
  path2.closePath();
  return path2;
}
function arrowPoints(from, to, options) {
  const { arrowSize } = options;
  const size4 = typeof arrowSize === "string" ? +parseFloat(arrowSize) / 100 * dist(from, to) : arrowSize;
  const arrowAngle = Math.PI / 6;
  const angle2 = Math.atan2(to[1] - from[1], to[0] - from[0]);
  const arrowAngle1 = Math.PI / 2 - angle2 - arrowAngle;
  const arrow1 = [
    to[0] - size4 * Math.sin(arrowAngle1),
    to[1] - size4 * Math.cos(arrowAngle1)
  ];
  const arrowAngle2 = angle2 - arrowAngle;
  const arrow2 = [
    to[0] - size4 * Math.cos(arrowAngle2),
    to[1] - size4 * Math.sin(arrowAngle2)
  ];
  return [arrow1, arrow2];
}
function appendArc(path2, from, to, center2, radius) {
  const startAngle = angle(sub(center2, from)) + Math.PI;
  const endAngle = angle(sub(center2, to)) + Math.PI;
  path2.arc(center2[0], center2[1], radius, startAngle, endAngle, endAngle - startAngle < 0);
  return path2;
}
function computeGradient(C, X, Y, from = "y", mode2 = "between", tpShape = false) {
  const getTheta = (from2, tpShape2) => {
    if (from2 === "y" || from2 === true) {
      if (tpShape2) {
        return 180;
      } else {
        return 90;
      }
    } else {
      if (tpShape2) {
        return 90;
      } else {
        return 0;
      }
    }
  };
  const P = from === "y" || from === true ? Y : X;
  const theta = getTheta(from, tpShape);
  const I = indexOf(P);
  const [min6, max7] = extent(I, (i2) => P[i2]);
  const p3 = new Linear({
    domain: [min6, max7],
    range: [0, 100]
  });
  const percentage = (i2) => isNumber(P[i2]) && !Number.isNaN(P[i2]) ? p3.map(P[i2]) : 0;
  const gradientMode = {
    // Interpolate the colors for this segment.
    between: (i2) => `${C[i2]} ${percentage(i2)}%`,
    // Use the color of the start point as the color for this segment.
    start: (i2) => i2 === 0 ? `${C[i2]} ${percentage(i2)}%` : `${C[i2 - 1]} ${percentage(i2)}%, ${C[i2]} ${percentage(i2)}%`,
    // Use the color of the end point as the color for this segment.
    end: (i2) => i2 === C.length - 1 ? `${C[i2]} ${percentage(i2)}%` : `${C[i2]} ${percentage(i2)}%, ${C[i2 + 1]} ${percentage(i2)}%`
  };
  const gradient2 = I.sort((a4, b) => percentage(a4) - percentage(b)).map(gradientMode[mode2] || gradientMode["between"]).join(",");
  return `linear-gradient(${theta}deg, ${gradient2})`;
}
function reorder(points) {
  const [p0, p1, p22, p3] = points;
  return [p3, p0, p1, p22];
}
function getArcObject(coordinate, points, Y) {
  const [p0, p1, , p3] = isTranspose(coordinate) ? reorder(points) : points;
  const [y3, y12] = Y;
  const center2 = coordinate.getCenter();
  const a1 = angleWithQuadrant(sub(p0, center2));
  const a22 = angleWithQuadrant(sub(p1, center2));
  const a32 = a22 === a1 && y3 !== y12 ? a22 + Math.PI * 2 : a22;
  const epsilon4 = 1e-4;
  return {
    startAngle: a1 + epsilon4,
    endAngle: (a32 - a1 >= 0 ? a32 : Math.PI * 2 + a32) - epsilon4,
    innerRadius: dist(p3, center2),
    outerRadius: dist(p0, center2)
  };
}
function toOpacityKey(options) {
  const { colorAttribute, opacityAttribute = colorAttribute } = options;
  return `${opacityAttribute}Opacity`;
}
function getTransform(coordinate, value2) {
  if (!isPolar(coordinate))
    return "";
  const center2 = coordinate.getCenter();
  const { transform: suffix } = value2;
  return `translate(${center2[0]}, ${center2[1]}) ${suffix || ""}`;
}
function getOrigin(points) {
  if (points.length === 1)
    return points[0];
  const [[x05, y05, z0 = 0], [x2, y22, z2 = 0]] = points;
  return [(x05 + x2) / 2, (y05 + y22) / 2, (z0 + z2) / 2];
}

// node_modules/@antv/g2/esm/shape/interval/color.js
var __rest11 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function rect(document2, points, value2, coordinate, style = {}) {
  const { inset = 0, radius = 0, insetLeft = inset, insetTop = inset, insetRight = inset, insetBottom = inset, radiusBottomLeft = radius, radiusBottomRight = radius, radiusTopLeft = radius, radiusTopRight = radius, minWidth = -Infinity, maxWidth = Infinity, minHeight = -Infinity } = style, rest = __rest11(style, ["inset", "radius", "insetLeft", "insetTop", "insetRight", "insetBottom", "radiusBottomLeft", "radiusBottomRight", "radiusTopLeft", "radiusTopRight", "minWidth", "maxWidth", "minHeight"]);
  if (!isPolar(coordinate) && !isHelix(coordinate)) {
    const tpShape = !!isTranspose(coordinate);
    const [p0, , p22] = tpShape ? reorder(points) : points;
    const [x2, y4] = p0;
    const [width, height] = sub(p22, p0);
    const absX = width > 0 ? x2 : x2 + width;
    const absY = height > 0 ? y4 : y4 + height;
    const absWidth = Math.abs(width);
    const absHeight = Math.abs(height);
    const finalX = absX + insetLeft;
    const finalY = absY + insetTop;
    const finalWidth = absWidth - (insetLeft + insetRight);
    const finalHeight = absHeight - (insetTop + insetBottom);
    const clampWidth = tpShape ? clamp(finalWidth, minHeight, Infinity) : clamp(finalWidth, minWidth, maxWidth);
    const clampHeight = tpShape ? clamp(finalHeight, minWidth, maxWidth) : clamp(finalHeight, minHeight, Infinity);
    const clampX = tpShape ? finalX : finalX - (clampWidth - finalWidth) / 2;
    const clampY = tpShape ? finalY - (clampHeight - finalHeight) / 2 : finalY - (clampHeight - finalHeight);
    return select(document2.createElement("rect", {})).style("x", clampX).style("y", clampY).style("width", clampWidth).style("height", clampHeight).style("radius", [
      radiusTopLeft,
      radiusTopRight,
      radiusBottomRight,
      radiusBottomLeft
    ]).call(applyStyle, rest).node();
  }
  const { y: y3, y1: y12 } = value2;
  const center2 = coordinate.getCenter();
  const arcObject = getArcObject(coordinate, points, [y3, y12]);
  const path2 = arc_default().cornerRadius(radius).padAngle(inset * Math.PI / 180);
  return select(document2.createElement("path", {})).style("d", path2(arcObject)).style("transform", `translate(${center2[0]}, ${center2[1]})`).style("radius", radius).style("inset", inset).call(applyStyle, rest).node();
}
var Color = (options, context) => {
  const { colorAttribute, opacityAttribute = "fill", first: first3 = true, last: last6 = true } = options, style = __rest11(options, ["colorAttribute", "opacityAttribute", "first", "last"]);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor, radius: defaultRadius2 = 0 } = defaults4, restDefaults = __rest11(defaults4, ["color", "radius"]);
    const defaultLineWidth = restDefaults.lineWidth || 1;
    const { stroke: stroke2, radius = defaultRadius2, radiusTopLeft = radius, radiusTopRight = radius, radiusBottomRight = radius, radiusBottomLeft = radius, innerRadius = 0, innerRadiusTopLeft = innerRadius, innerRadiusTopRight = innerRadius, innerRadiusBottomRight = innerRadius, innerRadiusBottomLeft = innerRadius, lineWidth = colorAttribute === "stroke" || stroke2 ? defaultLineWidth : 0, inset = 0, insetLeft = inset, insetRight = inset, insetBottom = inset, insetTop = inset, minWidth, maxWidth, minHeight } = style, rest = __rest11(style, ["stroke", "radius", "radiusTopLeft", "radiusTopRight", "radiusBottomRight", "radiusBottomLeft", "innerRadius", "innerRadiusTopLeft", "innerRadiusTopRight", "innerRadiusBottomRight", "innerRadiusBottomLeft", "lineWidth", "inset", "insetLeft", "insetRight", "insetBottom", "insetTop", "minWidth", "maxWidth", "minHeight"]);
    const { color = defaultColor, opacity } = value2;
    const standardDirRadius = [
      first3 ? radiusTopLeft : innerRadiusTopLeft,
      first3 ? radiusTopRight : innerRadiusTopRight,
      last6 ? radiusBottomRight : innerRadiusBottomRight,
      last6 ? radiusBottomLeft : innerRadiusBottomLeft
    ];
    const standardDir = [
      "radiusTopLeft",
      "radiusTopRight",
      "radiusBottomRight",
      "radiusBottomLeft"
    ];
    if (isTranspose(coordinate)) {
      standardDir.push(standardDir.shift());
    }
    const extendedStyle = Object.assign(Object.assign({ radius }, Object.fromEntries(standardDir.map((d3, i2) => [d3, standardDirRadius[i2]]))), {
      inset,
      insetLeft,
      insetRight,
      insetBottom,
      insetTop,
      minWidth,
      maxWidth,
      minHeight
    });
    return select(rect(document2, points, value2, coordinate, extendedStyle)).call(applyStyle, restDefaults).style("fill", "transparent").style(colorAttribute, color).style(toOpacityKey(options), opacity).style("lineWidth", lineWidth).style("stroke", stroke2 === void 0 ? color : stroke2).call(applyStyle, rest).node();
  };
};
Color.props = {
  defaultEnterAnimation: "scaleInY",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/interval/rect.js
var Rect2 = (options, context) => {
  return Color(Object.assign({ colorAttribute: "fill" }, options), context);
};
Rect2.props = Object.assign(Object.assign({}, Color.props), { defaultMarker: "square" });

// node_modules/@antv/g2/esm/shape/interval/hollow.js
var Hollow = (options, context) => {
  return Color(Object.assign({ colorAttribute: "stroke" }, options), context);
};
Hollow.props = Object.assign(Object.assign({}, Color.props), { defaultMarker: "hollowSquare" });

// node_modules/@antv/g2/esm/shape/interval/funnel.js
var __rest12 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function getFunnelPoints(points, nextPoints, coordinate) {
  const [p0, p1, p22, p3] = points;
  if (isTranspose(coordinate)) {
    const newP12 = [nextPoints ? nextPoints[0][0] : p1[0], p1[1]];
    const newP22 = [nextPoints ? nextPoints[3][0] : p22[0], p22[1]];
    return [p0, newP12, newP22, p3];
  }
  const newP1 = [p1[0], nextPoints ? nextPoints[0][1] : p1[1]];
  const newP2 = [p22[0], nextPoints ? nextPoints[3][1] : p22[1]];
  return [p0, newP1, newP2, p3];
}
var Funnel = (options, context) => {
  const { adjustPoints = getFunnelPoints } = options, style = __rest12(options, ["adjustPoints"]);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4, point2d) => {
    const { index: index2 } = value2;
    const { color: defaultColor } = defaults4, rest = __rest12(defaults4, ["color"]);
    const nextPoints = point2d[index2 + 1];
    const funnelPoints = adjustPoints(points, nextPoints, coordinate);
    const tpShape = !!isTranspose(coordinate);
    const [p0, p1, p22, p3] = tpShape ? reorder(funnelPoints) : funnelPoints;
    const { color = defaultColor, opacity } = value2;
    const b = line_default().curve(linearClosed_default)([p0, p1, p22, p3]);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", b).style("fill", color).style("fillOpacity", opacity).call(applyStyle, style).node();
  };
};
Funnel.props = {
  defaultMarker: "square"
};

// node_modules/@antv/g2/esm/shape/interval/pyramid.js
function getPyramidPoints(points, nextPoints, coordinate) {
  const [p0, p1, p22, p3] = points;
  if (isTranspose(coordinate)) {
    const newP12 = [
      nextPoints ? nextPoints[0][0] : (p1[0] + p22[0]) / 2,
      p1[1]
    ];
    const newP22 = [
      nextPoints ? nextPoints[3][0] : (p1[0] + p22[0]) / 2,
      p22[1]
    ];
    return [p0, newP12, newP22, p3];
  }
  const newP1 = [
    p1[0],
    nextPoints ? nextPoints[0][1] : (p1[1] + p22[1]) / 2
  ];
  const newP2 = [
    p22[0],
    nextPoints ? nextPoints[3][1] : (p1[1] + p22[1]) / 2
  ];
  return [p0, newP1, newP2, p3];
}
var Pyramid = (options, context) => {
  return Funnel(Object.assign({ adjustPoints: getPyramidPoints }, options), context);
};
Pyramid.props = {
  defaultMarker: "square"
};

// node_modules/@antv/g2/esm/utils/createElement.js
function createElement(descriptor) {
  const render3 = typeof descriptor === "function" ? descriptor : descriptor.render;
  return class extends CustomElement {
    connectedCallback() {
      this.draw();
    }
    attributeChangedCallback() {
      this.draw();
    }
    draw() {
      render3(this);
    }
  };
}

// node_modules/@antv/g2/esm/shape/line/curve.js
var __rest13 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var DoublePath = createElement((g) => {
  const { d1, d2: d22, style1, style2 } = g.attributes;
  const document2 = g.ownerDocument;
  select(g).maybeAppend("line", () => document2.createElement("path", {})).style("d", d1).call(applyStyle, style1);
  select(g).maybeAppend("line1", () => document2.createElement("path", {})).style("d", d22).call(applyStyle, style2);
});
function segmentation(points, defined3) {
  const definedPoints = [];
  const segments = [];
  let m2 = false;
  let dp = null;
  for (const p3 of points) {
    if (!defined3(p3[0]) || !defined3(p3[1]))
      m2 = true;
    else {
      definedPoints.push(p3);
      if (m2) {
        m2 = false;
        segments.push([dp, p3]);
      }
      dp = p3;
    }
  }
  return [definedPoints, segments];
}
var Curve = (options, context) => {
  const {
    curve,
    gradient: gradient2 = false,
    // The color for each segment.
    gradientColor = "between",
    defined: defined3 = (d3) => !Number.isNaN(d3) && d3 !== void 0 && d3 !== null,
    connect: connectNulls = false
  } = options, style = __rest13(options, ["curve", "gradient", "gradientColor", "defined", "connect"]);
  const { coordinate, document: document2 } = context;
  return (P, value2, defaults4) => {
    const { color: defaultColor, lineWidth: defaultSize } = defaults4, rest = __rest13(defaults4, ["color", "lineWidth"]);
    const { color = defaultColor, size: size4 = defaultSize, seriesColor: sc, seriesX: sx, seriesY: sy } = value2;
    const transform2 = getTransform(coordinate, value2);
    const tpShape = isTranspose(coordinate);
    const stroke2 = gradient2 && sc ? computeGradient(sc, sx, sy, gradient2, gradientColor, tpShape) : color;
    const finalStyle = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, rest), stroke2 && { stroke: stroke2 }), size4 && { lineWidth: size4 }), transform2 && { transform: transform2 }), style);
    let linePath;
    if (isPolar(coordinate)) {
      const center2 = coordinate.getCenter();
      linePath = (points) => lineRadial_default().angle((_, idx) => angleWithQuadrant(sub(points[idx], center2))).radius((_, idx) => dist(points[idx], center2)).defined(([x2, y3]) => defined3(x2) && defined3(y3)).curve(curve)(points);
    } else {
      linePath = line_default().x((d3) => d3[0]).y((d3) => d3[1]).defined(([x2, y3]) => defined3(x2) && defined3(y3)).curve(curve);
    }
    const [DP, MS] = segmentation(P, defined3);
    const connectStyle = subObject(finalStyle, "connect");
    const missing = !!MS.length;
    if (!missing || connectNulls && !Object.keys(connectStyle).length) {
      return select(document2.createElement("path", {})).style("d", linePath(DP) || []).call(applyStyle, finalStyle).node();
    }
    if (missing && !connectNulls) {
      return select(document2.createElement("path", {})).style("d", linePath(P)).call(applyStyle, finalStyle).node();
    }
    const connectPath = (segments) => segments.map(linePath).join(",");
    return select(new DoublePath()).style("style1", Object.assign(Object.assign({}, finalStyle), connectStyle)).style("style2", finalStyle).style("d1", connectPath(MS)).style("d2", linePath(P)).node();
  };
};
Curve.props = {
  defaultMarker: "smooth",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/line/line.js
var Line2 = (options, context) => {
  const { coordinate } = context;
  return (...params) => {
    const curve = isPolar(coordinate) ? linearClosed_default : linear_default;
    return Curve(Object.assign({ curve }, options), context)(...params);
  };
};
Line2.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "line" });

// node_modules/@antv/g2/esm/shape/line/smooth.js
var __rest14 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var Smooth = (options, context) => {
  const rest = __rest14(options, []);
  const { coordinate } = context;
  return (...params) => {
    const curve = isPolar(coordinate) ? catmullRomClosed_default : isTranspose(coordinate) ? monotoneY : monotoneX;
    return Curve(Object.assign({ curve }, rest), context)(...params);
  };
};
Smooth.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "smooth" });

// node_modules/@antv/g2/esm/shape/line/hv.js
var HV = (options, context) => {
  return Curve(Object.assign({ curve: stepAfter }, options), context);
};
HV.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "hv" });

// node_modules/@antv/g2/esm/shape/line/vh.js
var VH = (options, context) => {
  return Curve(Object.assign({ curve: stepBefore }, options), context);
};
VH.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "vh" });

// node_modules/@antv/g2/esm/shape/line/hvh.js
var HVH = (options, context) => {
  return Curve(Object.assign({ curve: step_default }, options), context);
};
HVH.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "hvh" });

// node_modules/@antv/g2/esm/shape/line/trail.js
var __rest15 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function stroke(path2, p0, p1, s0, s1) {
  const v = sub(p1, p0);
  const a4 = angle(v);
  const a1 = a4 + Math.PI / 2;
  const r1 = [s0 / 2 * Math.cos(a1), s0 / 2 * Math.sin(a1)];
  const r2 = [s1 / 2 * Math.cos(a1), s1 / 2 * Math.sin(a1)];
  const r3 = [s1 / 2 * Math.cos(a4), s1 / 2 * Math.sin(a4)];
  const r4 = [s0 / 2 * Math.cos(a4), s0 / 2 * Math.sin(a4)];
  const x05 = add(p0, r1);
  const x12 = add(p1, r2);
  const x2 = add(x12, r3);
  const x3 = add(p1, r3);
  const x4 = sub(x3, r2);
  const x5 = sub(p1, r2);
  const x6 = sub(p0, r1);
  const x7 = sub(x6, r4);
  const x8 = sub(p0, r4);
  const x9 = sub(x05, r4);
  path2.moveTo(...x05);
  path2.lineTo(...x12);
  path2.arcTo(...x2, ...x3, s1 / 2);
  path2.arcTo(...x4, ...x5, s1 / 2);
  path2.lineTo(...x6);
  path2.arcTo(...x7, ...x8, s0 / 2);
  path2.arcTo(...x9, ...x05, s0 / 2);
  path2.closePath();
}
var Trail = (options, context) => {
  const { document: document2 } = context;
  return (P, value2, defaults4) => {
    const { seriesSize, color } = value2;
    const { color: defaultColor } = defaults4, rest = __rest15(defaults4, ["color"]);
    const path2 = path();
    for (let i2 = 0; i2 < P.length - 1; i2++) {
      const p0 = P[i2];
      const p1 = P[i2 + 1];
      const s0 = seriesSize[i2];
      const s1 = seriesSize[i2 + 1];
      if ([...p0, ...p1].every(defined))
        stroke(path2, p0, p1, s0, s1);
    }
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("fill", color || defaultColor).style("d", path2.toString()).call(applyStyle, options).node();
  };
};
Trail.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "line" });

// node_modules/@antv/g2/esm/utils/marker.js
var __rest16 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var point5 = (x2, y3, r2) => {
  return [
    ["M", x2 - r2, y3],
    ["A", r2, r2, 0, 1, 0, x2 + r2, y3],
    ["A", r2, r2, 0, 1, 0, x2 - r2, y3],
    ["Z"]
  ];
};
point5.style = ["fill"];
var hollowPoint = point5.bind(void 0);
hollowPoint.style = ["stroke", "lineWidth"];
var square = (x2, y3, r2) => {
  return [
    ["M", x2 - r2, y3 - r2],
    ["L", x2 + r2, y3 - r2],
    ["L", x2 + r2, y3 + r2],
    ["L", x2 - r2, y3 + r2],
    ["Z"]
  ];
};
square.style = ["fill"];
var rect2 = square.bind(void 0);
rect2.style = ["fill"];
var hollowSquare = square.bind(void 0);
hollowSquare.style = ["stroke", "lineWidth"];
var diamond = (x2, y3, r2) => {
  const hr = r2 * 0.618;
  return [
    ["M", x2 - hr, y3],
    ["L", x2, y3 - r2],
    ["L", x2 + hr, y3],
    ["L", x2, y3 + r2],
    ["Z"]
  ];
};
diamond.style = ["fill"];
var hollowDiamond = diamond.bind(void 0);
hollowDiamond.style = ["stroke", "lineWidth"];
var triangle = (x2, y3, r2) => {
  const diffY = r2 * Math.sin(1 / 3 * Math.PI);
  return [
    ["M", x2 - r2, y3 + diffY],
    ["L", x2, y3 - diffY],
    ["L", x2 + r2, y3 + diffY],
    ["Z"]
  ];
};
triangle.style = ["fill"];
var hollowTriangle = triangle.bind(void 0);
hollowTriangle.style = ["stroke", "lineWidth"];
var triangleDown = (x2, y3, r2) => {
  const diffY = r2 * Math.sin(1 / 3 * Math.PI);
  return [
    ["M", x2 - r2, y3 - diffY],
    ["L", x2 + r2, y3 - diffY],
    ["L", x2, y3 + diffY],
    ["Z"]
  ];
};
triangleDown.style = ["fill"];
var hollowTriangleDown = triangleDown.bind(void 0);
hollowTriangleDown.style = ["stroke", "lineWidth"];
var hexagon = (x2, y3, r2) => {
  const diffX = r2 / 2 * Math.sqrt(3);
  return [
    ["M", x2, y3 - r2],
    ["L", x2 + diffX, y3 - r2 / 2],
    ["L", x2 + diffX, y3 + r2 / 2],
    ["L", x2, y3 + r2],
    ["L", x2 - diffX, y3 + r2 / 2],
    ["L", x2 - diffX, y3 - r2 / 2],
    ["Z"]
  ];
};
hexagon.style = ["fill"];
var hollowHexagon = hexagon.bind(void 0);
hollowHexagon.style = ["stroke", "lineWidth"];
var bowtie = (x2, y3, r2) => {
  const diffY = r2 - 1.5;
  return [
    ["M", x2 - r2, y3 - diffY],
    ["L", x2 + r2, y3 + diffY],
    ["L", x2 + r2, y3 - diffY],
    ["L", x2 - r2, y3 + diffY],
    ["Z"]
  ];
};
bowtie.style = ["fill"];
var hollowBowtie = bowtie.bind(void 0);
hollowBowtie.style = ["stroke", "lineWidth"];
var line = (x2, y3, r2) => {
  return [
    ["M", x2, y3 + r2],
    ["L", x2, y3 - r2]
  ];
};
line.style = ["stroke", "lineWidth"];
var cross2 = (x2, y3, r2) => {
  return [
    ["M", x2 - r2, y3 - r2],
    ["L", x2 + r2, y3 + r2],
    ["M", x2 + r2, y3 - r2],
    ["L", x2 - r2, y3 + r2]
  ];
};
cross2.style = ["stroke", "lineWidth"];
var tick = (x2, y3, r2) => {
  return [
    ["M", x2 - r2 / 2, y3 - r2],
    ["L", x2 + r2 / 2, y3 - r2],
    ["M", x2, y3 - r2],
    ["L", x2, y3 + r2],
    ["M", x2 - r2 / 2, y3 + r2],
    ["L", x2 + r2 / 2, y3 + r2]
  ];
};
tick.style = ["stroke", "lineWidth"];
var plus = (x2, y3, r2) => {
  return [
    ["M", x2 - r2, y3],
    ["L", x2 + r2, y3],
    ["M", x2, y3 - r2],
    ["L", x2, y3 + r2]
  ];
};
plus.style = ["stroke", "lineWidth"];
var hyphen = (x2, y3, r2) => {
  return [
    ["M", x2 - r2, y3],
    ["L", x2 + r2, y3]
  ];
};
hyphen.style = ["stroke", "lineWidth"];
var dot = (x2, y3, r2) => {
  return [
    ["M", x2 - r2, y3],
    ["L", x2 + r2, y3]
  ];
};
dot.style = ["stroke", "lineWidth"];
var dash = dot.bind(void 0);
dash.style = ["stroke", "lineWidth"];
var smooth = (x2, y3, r2) => {
  return [
    ["M", x2 - r2, y3],
    ["A", r2 / 2, r2 / 2, 0, 1, 1, x2, y3],
    ["A", r2 / 2, r2 / 2, 0, 1, 0, x2 + r2, y3]
  ];
};
smooth.style = ["stroke", "lineWidth"];
var hv = (x2, y3, r2) => {
  return [
    ["M", x2 - r2 - 1, y3 - 2.5],
    ["L", x2, y3 - 2.5],
    ["L", x2, y3 + 2.5],
    ["L", x2 + r2 + 1, y3 + 2.5]
  ];
};
hv.style = ["stroke", "lineWidth"];
var vh = (x2, y3, r2) => {
  return [
    ["M", x2 - r2 - 1, y3 + 2.5],
    ["L", x2, y3 + 2.5],
    ["L", x2, y3 - 2.5],
    ["L", x2 + r2 + 1, y3 - 2.5]
  ];
};
vh.style = ["stroke", "lineWidth"];
var hvh = (x2, y3, r2) => {
  return [
    ["M", x2 - (r2 + 1), y3 + 2.5],
    ["L", x2 - r2 / 2, y3 + 2.5],
    ["L", x2 - r2 / 2, y3 - 2.5],
    ["L", x2 + r2 / 2, y3 - 2.5],
    ["L", x2 + r2 / 2, y3 + 2.5],
    ["L", x2 + r2 + 1, y3 + 2.5]
  ];
};
hvh.style = ["stroke", "lineWidth"];
var vhv = (x2, y3, r2) => {
  return [
    ["M", x2 - 5, y3 + 2.5],
    ["L", x2 - 5, y3],
    ["L", x2, y3],
    ["L", x2, y3 - 3],
    ["L", x2, y3 + 3],
    ["L", x2 + 6.5, y3 + 3]
  ];
};
vhv.style = ["stroke", "lineWidth"];
var Symbols = /* @__PURE__ */ new Map([
  ["bowtie", bowtie],
  ["cross", cross2],
  ["dash", dash],
  ["diamond", diamond],
  ["dot", dot],
  ["hexagon", hexagon],
  ["hollowBowtie", hollowBowtie],
  ["hollowDiamond", hollowDiamond],
  ["hollowHexagon", hollowHexagon],
  ["hollowPoint", hollowPoint],
  ["hollowSquare", hollowSquare],
  ["hollowTriangle", hollowTriangle],
  ["hollowTriangleDown", hollowTriangleDown],
  ["hv", hv],
  ["hvh", hvh],
  ["hyphen", hyphen],
  ["line", line],
  ["plus", plus],
  ["point", point5],
  ["rect", rect2],
  ["smooth", smooth],
  ["square", square],
  ["tick", tick],
  ["triangleDown", triangleDown],
  ["triangle", triangle],
  ["vh", vh],
  ["vhv", vhv]
]);
function useMarker(type, _a) {
  var { d: d3, fill, lineWidth, path: path2, stroke: stroke2, color } = _a, style = __rest16(_a, ["d", "fill", "lineWidth", "path", "stroke", "color"]);
  const symbol = Symbols.get(type) || Symbols.get("point");
  return (...args) => {
    const path3 = new Path({
      style: Object.assign(Object.assign({}, style), { d: symbol(...args), stroke: symbol.style.includes("stroke") ? color || stroke2 : "", fill: symbol.style.includes("fill") ? color || fill : "", lineWidth: symbol.style.includes("lineWidth") ? lineWidth || lineWidth || 2 : 0 })
    });
    return path3;
  };
}
function registerSymbol(type, marker) {
  Symbols.set(type, marker);
}

// node_modules/@antv/g2/esm/utils/string.js
function camelCase(s3) {
  return s3.replace(/-(\w)/g, function(_, letter) {
    return letter.toUpperCase();
  });
}
function kebabCase(s3) {
  return s3.replace(/([A-Z])/g, "-$1").toLowerCase();
}

// node_modules/@antv/g2/esm/shape/point/color.js
var __rest17 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function getRadius2(mode2, points, value2, coordinate) {
  if (points.length === 1)
    return void 0;
  const { size: size4 } = value2;
  if (mode2 === "fixed")
    return size4;
  if (mode2 === "normal" || isFisheye(coordinate)) {
    const [[x05, y05], [x2, y22]] = points;
    const a4 = Math.abs((x2 - x05) / 2);
    const b = Math.abs((y22 - y05) / 2);
    return Math.max(0, (a4 + b) / 2);
  }
  return size4;
}
var Color2 = (options, context) => {
  const { colorAttribute, symbol, mode: mode2 = "auto" } = options, style = __rest17(options, ["colorAttribute", "symbol", "mode"]);
  const path2 = Symbols.get(camelCase(symbol)) || Symbols.get("point");
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { lineWidth, color: defaultColor } = defaults4;
    const finalLineWidth = style.stroke ? lineWidth || 1 : lineWidth;
    const { color = defaultColor, transform: transform2, opacity } = value2;
    const [cx, cy] = getOrigin(points);
    const r2 = getRadius2(mode2, points, value2, coordinate);
    const finalRadius = r2 || style.r || defaults4.r;
    return select(document2.createElement("path", {})).call(applyStyle, defaults4).style("fill", "transparent").style("d", path2(cx, cy, finalRadius)).style("lineWidth", finalLineWidth).style("transform", transform2).style("transformOrigin", `${cx - finalRadius} ${cy - finalRadius}`).style("stroke", color).style(toOpacityKey(options), opacity).style(colorAttribute, color).call(applyStyle, style).node();
  };
};
Color2.props = {
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/point/hollowBowtie.js
var HollowBowtie = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke", symbol: "bowtie" }, options), context);
};
HollowBowtie.props = Object.assign({ defaultMarker: "hollowBowtie" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/hollowDiamond.js
var HollowDiamond = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke", symbol: "diamond" }, options), context);
};
HollowDiamond.props = Object.assign({ defaultMarker: "hollowDiamond" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/hollowHexagon.js
var HollowHexagon = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke", symbol: "hexagon" }, options), context);
};
HollowHexagon.props = Object.assign({ defaultMarker: "hollowHexagon" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/hollow.js
var HollowPoint = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke", symbol: "point" }, options), context);
};
HollowPoint.props = Object.assign({ defaultMarker: "hollowPoint" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/hollowSquare.js
var HollowSquare = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke", symbol: "square" }, options), context);
};
HollowSquare.props = Object.assign({ defaultMarker: "hollowSquare" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/hollowTriangle.js
var HollowTriangle = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke", symbol: "triangle" }, options), context);
};
HollowTriangle.props = Object.assign({ defaultMarker: "hollowTriangle" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/hollowTriangleDown.js
var HollowTriangleDown = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke", symbol: "triangle-down" }, options), context);
};
HollowTriangleDown.props = Object.assign({ defaultMarker: "hollowTriangleDown" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/circle.js
var __rest18 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var BaseCircle = (options, context) => {
  const { colorAttribute, mode: mode2 = "auto" } = options, style = __rest18(options, ["colorAttribute", "mode"]);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { lineWidth, color: defaultColor } = defaults4;
    const finalLineWidth = style.stroke ? lineWidth || 1 : lineWidth;
    const { color = defaultColor, transform: transform2, opacity } = value2;
    const [cx, cy] = getOrigin(points);
    const r2 = getRadius2(mode2, points, value2, coordinate);
    const finalRadius = r2 || style.r || defaults4.r;
    return select(document2.createElement("circle", {})).call(applyStyle, defaults4).style("fill", "transparent").style("cx", cx).style("cy", cy).style("r", finalRadius).style("lineWidth", finalLineWidth).style("transform", transform2).style("transformOrigin", `${cx} ${cy}`).style("stroke", color).style(toOpacityKey(options), opacity).style(colorAttribute, color).call(applyStyle, style).node();
  };
};
var Circle2 = (options, context) => {
  return BaseCircle(Object.assign({ colorAttribute: "fill" }, options), context);
};
Circle2.props = {
  defaultMarker: "circle",
  defaultEnterAnimation: "fadeIn",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/point/hollowCircle.js
var HollowCircle = (options, context) => {
  return BaseCircle(Object.assign({ colorAttribute: "stroke" }, options), context);
};
HollowCircle.props = Object.assign({ defaultMarker: "hollowPoint" }, Circle2.props);

// node_modules/@antv/g2/esm/shape/point/bowtie.js
var Bowtie = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "fill", symbol: "bowtie" }, options), context);
};
Bowtie.props = Object.assign({ defaultMarker: "bowtie" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/cross.js
var Cross = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke", symbol: "cross" }, options), context);
};
Cross.props = Object.assign({ defaultMarker: "cross" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/diamond.js
var Diamond = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "fill", symbol: "diamond" }, options), context);
};
Diamond.props = Object.assign({ defaultMarker: "diamond" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/hexagon.js
var Hexagon = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "fill", symbol: "hexagon" }, options), context);
};
Hexagon.props = Object.assign({ defaultMarker: "hexagon" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/hyphen.js
var Hyphen = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke", symbol: "hyphen" }, options), context);
};
Hyphen.props = Object.assign({ defaultMarker: "hyphen" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/line.js
var Line3 = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke", symbol: "line" }, options), context);
};
Line3.props = Object.assign({ defaultMarker: "line" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/plus.js
var Plus = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke", symbol: "plus" }, options), context);
};
Plus.props = Object.assign({ defaultMarker: "plus" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/point.js
var Point2 = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "fill", symbol: "point" }, options), context);
};
Point2.props = Object.assign({ defaultMarker: "point" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/square.js
var Square = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "fill", symbol: "square" }, options), context);
};
Square.props = Object.assign({ defaultMarker: "square" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/tick.js
var Tick = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke", symbol: "tick" }, options), context);
};
Tick.props = Object.assign({ defaultMarker: "tick" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/triangle.js
var Triangle = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "fill", symbol: "triangle" }, options), context);
};
Triangle.props = Object.assign({ defaultMarker: "triangle" }, Color2.props);

// node_modules/@antv/g2/esm/shape/point/triangleDown.js
var TriangleDown = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "fill", symbol: "triangle-down" }, options), context);
};
TriangleDown.props = Object.assign({ defaultMarker: "triangleDown" }, Color2.props);

// node_modules/@antv/g2/esm/shape/vector/vector.js
var __rest19 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var Vector = (options, context) => {
  const { arrow = true, arrowSize = "40%" } = options, style = __rest19(options, ["arrow", "arrowSize"]);
  const { document: document2 } = context;
  return (points, value2, defaults4) => {
    const { defaultColor } = defaults4, rest = __rest19(defaults4, ["defaultColor"]);
    const { color = defaultColor, transform: transform2 } = value2;
    const [from, to] = points;
    const path2 = path();
    path2.moveTo(...from);
    path2.lineTo(...to);
    if (arrow) {
      const [arrow1, arrow2] = arrowPoints(from, to, { arrowSize });
      path2.moveTo(...arrow1);
      path2.lineTo(...to);
      path2.lineTo(...arrow2);
    }
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color).style("transform", transform2).call(applyStyle, style).node();
  };
};
Vector.props = {
  defaultMarker: "line",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/text/advance.js
var __rest20 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function getConnectorPoint(shape24) {
  const { min: [x05, y05], max: [x12, y12] } = shape24.getLocalBounds();
  let x2 = 0;
  let y3 = 0;
  if (x05 > 0)
    x2 = x05;
  if (x12 < 0)
    x2 = x12;
  if (y05 > 0)
    y3 = y05;
  if (y12 < 0)
    y3 = y12;
  return [x2, y3];
}
function inferBackgroundBounds(textShape, padding = []) {
  const [top = 0, right2 = 0, bottom = top, left2 = right2] = padding;
  const container = textShape.parentNode;
  const angle2 = container.getEulerAngles();
  container.setEulerAngles(0);
  const { min: min6, halfExtents } = textShape.getLocalBounds();
  const [x2, y3] = min6;
  const [hw, hh] = halfExtents;
  container.setEulerAngles(angle2);
  return {
    x: x2 - left2,
    y: y3 - top,
    width: hw * 2 + left2 + right2,
    height: hh * 2 + top + bottom
  };
}
function inferConnectorPath(shape24, end, control, coordCenter, left2 = true, top = true) {
  const path2 = (points) => line_default()(points);
  if (!end[0] && !end[1])
    return path2([getConnectorPoint(shape24), end]);
  if (!control.length)
    return path2([[0, 0], end]);
  const [inflection, start] = control;
  const p1 = [...start];
  const p22 = [...inflection];
  if (start[0] !== inflection[0]) {
    const offset2 = left2 ? -4 : 4;
    p1[1] = start[1];
    if (top && !left2) {
      p1[0] = Math.max(inflection[0], start[0] - offset2);
      if (start[1] < inflection[1]) {
        p22[1] = p1[1];
      } else {
        p22[1] = inflection[1];
        p22[0] = Math.max(p22[0], p1[0] - offset2);
      }
    }
    if (!top && !left2) {
      p1[0] = Math.max(inflection[0], start[0] - offset2);
      if (start[1] > inflection[1]) {
        p22[1] = p1[1];
      } else {
        p22[1] = inflection[1];
        p22[0] = Math.max(p22[0], p1[0] - offset2);
      }
    }
    if (!top && left2) {
      p1[0] = Math.min(inflection[0], start[0] - offset2);
      if (start[1] > inflection[1]) {
        p22[1] = p1[1];
      } else {
        p22[1] = inflection[1];
        p22[0] = Math.min(p22[0], p1[0] - offset2);
      }
    }
    if (top && left2) {
      p1[0] = Math.min(inflection[0], start[0] - offset2);
      if (start[1] < inflection[1]) {
        p22[1] = p1[1];
      } else {
        p22[1] = inflection[1];
        p22[0] = Math.min(p22[0], p1[0] - offset2);
      }
    }
  }
  return path2([start, p1, p22, inflection, end]);
}
var Advance = createElement((g) => {
  const _a = g.attributes, {
    className: className2,
    // Do not pass className
    class: _c,
    transform: transform2,
    rotate: rotate2,
    labelTransform,
    labelTransformOrigin,
    x: x2,
    y: y3,
    x0: x05 = x2,
    y0: y05 = y3,
    text,
    background,
    connector,
    startMarker,
    endMarker,
    coordCenter,
    innerHTML
  } = _a, rest = __rest20(_a, ["className", "class", "transform", "rotate", "labelTransform", "labelTransformOrigin", "x", "y", "x0", "y0", "text", "background", "connector", "startMarker", "endMarker", "coordCenter", "innerHTML"]);
  g.style.transform = `translate(${x2}, ${y3})`;
  if ([x2, y3, x05, y05].some((v) => !isNumber(v))) {
    g.children.forEach((d3) => d3.remove());
    return;
  }
  const _b = subObject(rest, "background"), { padding } = _b, backgroundStyle = __rest20(_b, ["padding"]);
  const _d = subObject(rest, "connector"), { points: controlPoints2 = [] } = _d, connectorStyle = __rest20(_d, ["points"]);
  let textShape;
  if (innerHTML) {
    textShape = select(g).maybeAppend("html", "html", className2).style("zIndex", 0).style("innerHTML", innerHTML).call(applyStyle, Object.assign({ transform: labelTransform, transformOrigin: labelTransformOrigin }, rest)).node();
  } else {
    textShape = select(g).maybeAppend("text", "text").style("zIndex", 0).style("text", text).call(applyStyle, Object.assign({ textBaseline: "middle", transform: labelTransform, transformOrigin: labelTransformOrigin }, rest)).node();
  }
  const rect4 = select(g).maybeAppend("background", "rect").style("zIndex", -1).call(applyStyle, inferBackgroundBounds(textShape, padding)).call(applyStyle, background ? backgroundStyle : {}).node();
  const left2 = +x05 < coordCenter[0];
  const top = +y05 < coordCenter[1];
  const end = [+x05 - +x2, +y05 - +y3];
  const connectorPath = inferConnectorPath(rect4, end, controlPoints2, coordCenter, left2, top);
  const markerStart = startMarker && new Marker({
    id: "startMarker",
    style: Object.assign({ x: 0, y: 0 }, subObject(rest, "startMarker"))
  });
  const markerEnd = endMarker && new Marker({
    id: "endMarker",
    style: Object.assign({ x: 0, y: 0 }, subObject(rest, "endMarker"))
  });
  select(g).maybeAppend("connector", "path").style("zIndex", 0).style("d", connectorPath).style("markerStart", markerStart).style("markerEnd", markerEnd).call(applyStyle, connector ? connectorStyle : {});
});

// node_modules/@antv/g2/esm/shape/text/text.js
var Text2 = (options, context) => {
  const { coordinate } = context;
  return (points, value2, defaults4) => {
    const { color, text = "", fontSize, rotate: rotate2 = 0, transform: transform2 = "" } = value2;
    const textStyle = {
      text: String(text),
      stroke: color,
      fill: color,
      fontSize
    };
    const [[x05, y05]] = points;
    return select(new Advance()).style("x", x05).style("y", y05).call(applyStyle, defaults4).style("transform", `${transform2}rotate(${+rotate2})`).style("coordCenter", coordinate.getCenter()).call(applyStyle, textStyle).call(applyStyle, options).node();
  };
};
Text2.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/text/badge.js
var __rest21 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function getPath(r2) {
  const offset2 = r2 / Math.sqrt(2);
  const dy = r2 * Math.sqrt(2);
  const [p0x, p0y] = [-offset2, offset2 - dy];
  const [p1x, p1y] = [0, 0];
  const [p2x, p2y] = [offset2, offset2 - dy];
  return [
    ["M", p0x, p0y],
    ["A", r2, r2, 0, 1, 1, p2x, p2y],
    ["L", p1x, p1y],
    ["Z"]
  ];
}
function inferTextPosition(shape24) {
  const { min: min6, max: max7 } = shape24.getLocalBounds();
  return [(min6[0] + max7[0]) * 0.5, (min6[1] + max7[1]) * 0.5];
}
var BadgeShape = createElement((g) => {
  const _a = g.attributes, { class: className2, x: x05, y: y05, transform: transform2 } = _a, rest = __rest21(_a, ["class", "x", "y", "transform"]);
  const markerStyle = subObject(rest, "marker");
  const { size: size4 = 24 } = markerStyle;
  const symbol = () => getPath(size4 / 2);
  const bgShape = select(g).maybeAppend("marker", () => new Marker({})).call((selection) => selection.node().update(Object.assign({ symbol }, markerStyle))).node();
  const [x2, y3] = inferTextPosition(bgShape);
  select(g).maybeAppend("text", "text").style("x", x2).style("y", y3).call(applyStyle, rest);
});
var Badge = (options, context) => {
  const style = __rest21(options, []);
  return (points, value2, defaults4) => {
    const { color: defaultColor } = defaults4, rest = __rest21(defaults4, ["color"]);
    const { color = defaultColor, text = "" } = value2;
    const textStyle = {
      text: String(text),
      stroke: color,
      fill: color
    };
    const [[x05, y05]] = points;
    return select(new BadgeShape()).call(applyStyle, rest).style("transform", `translate(${x05},${y05})`).call(applyStyle, textStyle).call(applyStyle, style).node();
  };
};
Badge.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/text/tag.js
var Tag = (options, context) => {
  const { coordinate } = context;
  return (points, value2, defaults4) => {
    const { color, text = "", fontSize, rotate: rotate2 = 0, transform: transform2 = "" } = value2;
    const textStyle = {
      text: String(text),
      stroke: color,
      fill: color,
      fontSize,
      textAlign: "center",
      textBaseline: "middle"
    };
    const [[x05, y05]] = points;
    const n2 = select(new Text()).style("x", x05).style("y", y05).call(applyStyle, defaults4).style("transformOrigin", "center center").style("transform", `${transform2}rotate(${rotate2}deg)`).style("coordCenter", coordinate.getCenter()).call(applyStyle, textStyle).call(applyStyle, options).node();
    return n2;
  };
};
Tag.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/area/curve.js
var __rest22 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function segmentation2(points, defined3) {
  const definedPointsY1 = [];
  const definedPointsY0 = [];
  const segments = [];
  let m2 = false;
  let dp = null;
  const mid2 = points.length / 2;
  for (let i2 = 0; i2 < mid2; i2++) {
    const y12 = points[i2];
    const y05 = points[i2 + mid2];
    if ([...y12, ...y05].some((v) => !defined3(v)))
      m2 = true;
    else {
      definedPointsY1.push(y12);
      definedPointsY0.push(y05);
      if (m2 && dp) {
        m2 = false;
        const [dpy1, dpy0] = dp;
        segments.push([dpy1, y12, dpy0, y05]);
      }
      dp = [y12, y05];
    }
  }
  return [definedPointsY1.concat(definedPointsY0), segments];
}
var DoubleArea = createElement((g) => {
  const { areaPath, connectPath, areaStyle, connectStyle } = g.attributes;
  const document2 = g.ownerDocument;
  select(g).maybeAppend("connect-path", () => document2.createElement("path", {})).style("d", connectPath).call(applyStyle, connectStyle);
  select(g).maybeAppend("area-path", () => document2.createElement("path", {})).style("d", areaPath).call(applyStyle, areaStyle);
});
var Curve2 = (options, context) => {
  const { curve, gradient: gradient2 = false, defined: defined3 = (d3) => !Number.isNaN(d3) && d3 !== void 0 && d3 !== null, connect: connectNulls = false } = options, style = __rest22(options, ["curve", "gradient", "defined", "connect"]);
  const { coordinate, document: document2 } = context;
  return (P, value2, defaults4) => {
    const { color: defaultColor } = defaults4;
    const { color = defaultColor, seriesColor: sc, seriesX: sx, seriesY: sy } = value2;
    const tpShape = isTranspose(coordinate);
    const transform2 = getTransform(coordinate, value2);
    const fill = gradient2 && sc ? computeGradient(sc, sx, sy, gradient2, void 0, tpShape) : color;
    const finalStyle = Object.assign(Object.assign(Object.assign(Object.assign({}, defaults4), { stroke: fill, fill }), transform2 && { transform: transform2 }), style);
    const [DP, MS] = segmentation2(P, defined3);
    const connectStyle = subObject(finalStyle, "connect");
    const missing = !!MS.length;
    const getPathNode = (path2) => {
      return select(document2.createElement("path", {})).style("d", path2 || "").call(applyStyle, finalStyle).node();
    };
    if (!isPolar(coordinate)) {
      const areaPath = (points) => {
        const Y12 = points.slice(0, points.length / 2);
        const Y02 = points.slice(points.length / 2);
        return tpShape ? area_default().y((_, idx) => Y12[idx][1]).x1((_, idx) => Y12[idx][0]).x0((_, idx) => Y02[idx][0]).defined((_, idx) => [...Y12[idx], ...Y02[idx]].every(defined3)).curve(curve)(Y12) : area_default().x((_, idx) => Y12[idx][0]).y1((_, idx) => Y12[idx][1]).y0((_, idx) => Y02[idx][1]).defined((_, idx) => [...Y12[idx], ...Y02[idx]].every(defined3)).curve(curve)(Y12);
      };
      if (!missing || connectNulls && !Object.keys(connectStyle).length) {
        return getPathNode(areaPath(DP));
      }
      if (missing && !connectNulls) {
        return getPathNode(areaPath(P));
      }
      return select(new DoubleArea()).style("areaStyle", finalStyle).style("connectStyle", Object.assign(Object.assign({}, connectStyle), style)).style("areaPath", areaPath(P)).style("connectPath", MS.map(areaPath).join("")).node();
    } else {
      const areaRadialPath = (points) => {
        const center2 = coordinate.getCenter();
        const Y12 = points.slice(0, points.length / 2);
        const Y02 = points.slice(points.length / 2);
        return areaRadial_default().angle((_, idx) => angleWithQuadrant(sub(Y12[idx], center2))).outerRadius((_, idx) => dist(Y12[idx], center2)).innerRadius((_, idx) => dist(Y02[idx], center2)).defined((_, idx) => [...Y12[idx], ...Y02[idx]].every(defined3)).curve(curve)(Y02);
      };
      if (!missing || connectNulls && !Object.keys(connectStyle).length) {
        return getPathNode(areaRadialPath(DP));
      }
      if (missing && !connectNulls) {
        return getPathNode(areaRadialPath(P));
      }
      return select(new DoubleArea()).style("areaStyle", finalStyle).style("connectStyle", Object.assign(Object.assign({}, connectStyle), style)).style("areaPath", areaRadialPath(P)).style("connectPath", MS.map(areaRadialPath).join("")).node();
    }
  };
};
Curve2.props = {
  defaultMarker: "smooth",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/area/area.js
var Area = (options, context) => {
  const { coordinate } = context;
  return (...params) => {
    const curve = isPolar(coordinate) ? linearClosed_default : linear_default;
    return Curve2(Object.assign({ curve }, options), context)(...params);
  };
};
Area.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "square" });

// node_modules/@antv/g2/esm/shape/area/smooth.js
var __rest23 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var Smooth2 = (options, context) => {
  const rest = __rest23(options, []);
  const { coordinate } = context;
  return (...params) => {
    const curve = isPolar(coordinate) ? catmullRomClosed_default : isTranspose(coordinate) ? monotoneY : monotoneX;
    return Curve2(Object.assign({ curve }, rest), context)(...params);
  };
};
Smooth2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "smooth" });

// node_modules/@antv/g2/esm/shape/area/hvh.js
var HVH2 = (options, context) => {
  return (...params) => {
    return Curve2(Object.assign({ curve: step_default }, options), context)(...params);
  };
};
HVH2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "hvh" });

// node_modules/@antv/g2/esm/shape/area/vh.js
var VH2 = (options, context) => {
  return (...params) => {
    return Curve2(Object.assign({ curve: stepBefore }, options), context)(...params);
  };
};
VH2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "vh" });

// node_modules/@antv/g2/esm/shape/area/hv.js
var HV2 = (options, context) => {
  return (...params) => {
    return Curve2(Object.assign({ curve: stepAfter }, options), context)(...params);
  };
};
HV2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "hv" });

// node_modules/@antv/g2/esm/shape/link/link.js
var Link = (options, context) => {
  const { arrow = false } = options;
  return (...params) => {
    return Vector(Object.assign(Object.assign({}, options), { arrow }), context)(...params);
  };
};
Link.props = {
  defaultMarker: "line",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/link/smooth.js
var __rest24 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var Smooth3 = (options, context) => {
  const style = __rest24(options, []);
  const { document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor } = defaults4, rest = __rest24(defaults4, ["color"]);
    const { color = defaultColor, transform: transform2 } = value2;
    const [from, to] = points;
    const path2 = path();
    path2.moveTo(from[0], from[1]);
    path2.bezierCurveTo(from[0] / 2 + to[0] / 2, from[1], from[0] / 2 + to[0] / 2, to[1], to[0], to[1]);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color).style("transform", transform2).call(applyStyle, style).node();
  };
};
Smooth3.props = {
  defaultMarker: "smooth",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/link/vhv.js
var __rest25 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function getVHVPath(from, to, coordinate, ratio) {
  const path2 = path();
  if (isPolar(coordinate)) {
    const center2 = coordinate.getCenter();
    const a4 = dist(from, center2);
    const b = dist(to, center2);
    const radius = (b - a4) * ratio + a4;
    path2.moveTo(from[0], from[1]);
    appendArc(path2, from, to, center2, radius);
    path2.lineTo(to[0], to[1]);
    return path2;
  }
  if (isTranspose(coordinate)) {
    path2.moveTo(from[0], from[1]);
    path2.lineTo(from[0] + (to[0] - from[0]) * ratio, from[1]);
    path2.lineTo(from[0] + (to[0] - from[0]) * ratio, to[1]);
    path2.lineTo(to[0], to[1]);
    return path2;
  }
  path2.moveTo(from[0], from[1]);
  path2.lineTo(from[0], from[1] + (to[1] - from[1]) * ratio);
  path2.lineTo(to[0], from[1] + (to[1] - from[1]) * ratio);
  path2.lineTo(to[0], to[1]);
  return path2;
}
var VHV = (options, context) => {
  const { cornerRatio = 1 / 3 } = options, style = __rest25(options, ["cornerRatio"]);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { defaultColor } = defaults4, rest = __rest25(defaults4, ["defaultColor"]);
    const { color = defaultColor, transform: transform2 } = value2;
    const [from, to] = points;
    const path2 = getVHVPath(from, to, coordinate, cornerRatio);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color).style("transform", transform2).call(applyStyle, style).node();
  };
};
VHV.props = {
  defaultMarker: "vhv",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/link/arc.js
var __rest26 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var Arc = (options, context) => {
  const style = __rest26(options, []);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor } = defaults4, rest = __rest26(defaults4, ["color"]);
    const { color = defaultColor, transform: transform2 } = value2;
    const [from, to] = points;
    const path2 = path();
    path2.moveTo(from[0], from[1]);
    if (isPolar(coordinate)) {
      const center2 = coordinate.getCenter();
      path2.quadraticCurveTo(center2[0], center2[1], to[0], to[1]);
    } else {
      const center2 = mid(from, to);
      const raduis = dist(from, to) / 2;
      appendArc(path2, from, to, center2, raduis);
    }
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color).style("transform", transform2).call(applyStyle, style).node();
  };
};
Arc.props = {
  defaultMarker: "smooth",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/mark/utils.js
function baseChannels(options = {}) {
  const { shapes } = options;
  return [
    { name: "color" },
    { name: "opacity" },
    { name: "shape", range: shapes },
    { name: "enterType" },
    { name: "enterDelay", scaleKey: "enter" },
    { name: "enterDuration", scaleKey: "enter" },
    { name: "enterEasing" },
    { name: "key", scale: "identity" },
    { name: "groupKey", scale: "identity" },
    { name: "label", scale: "identity" }
  ];
}
function baseGeometryChannels(options = {}) {
  return [...baseChannels(options), { name: "title", scale: "identity" }];
}
function tooltip2d() {
  return [
    { type: MaybeTitle, channel: "color" },
    { type: MaybeTooltip, channel: ["x", "y"] }
  ];
}
function tooltip1d() {
  return [
    { type: MaybeTitle, channel: "x" },
    { type: MaybeTooltip, channel: ["y"] }
  ];
}
function tooltipXd() {
  return [
    { type: MaybeTitle, channel: "color" },
    { type: MaybeTooltip, channel: ["position"] }
  ];
}
function baseAnnotationChannels(options = {}) {
  return baseChannels(options);
}
function basePreInference() {
  return [{ type: MaybeKey }];
}
function basePostInference() {
  return [];
}
function bandWidth(scale4, x2) {
  return scale4.getBandWidth(scale4.invert(x2));
}
function createBandOffset(scale4, value2, options = {}) {
  const { x: X, y: Y, series: S } = value2;
  const { x: x2, y: y3, series } = scale4;
  const { style: { bandOffset = series ? 0 : 0.5, bandOffsetX = bandOffset, bandOffsetY = bandOffset } = {} } = options;
  const isBandX = !!(x2 === null || x2 === void 0 ? void 0 : x2.getBandWidth);
  const isBandY = !!(y3 === null || y3 === void 0 ? void 0 : y3.getBandWidth);
  const isSeries = !!(series === null || series === void 0 ? void 0 : series.getBandWidth);
  if (!isBandX && !isBandY)
    return (d3) => d3;
  return (d3, i2) => {
    const widthX = isBandX ? bandWidth(x2, X[i2]) : 0;
    const widthY = isBandY ? bandWidth(y3, Y[i2]) : 0;
    const f2 = () => (bandWidth(series, S[i2]) / 2 + +S[i2]) * widthX;
    const offset2 = isSeries && S ? f2() : 0;
    const [x05, y05] = d3;
    return [x05 + bandOffsetX * widthX + offset2, y05 + bandOffsetY * widthY];
  };
}
function p(d3) {
  return parseFloat(d3) / 100;
}
function visualMark(index2, scale4, value2, coordinate) {
  const { x: X, y: Y } = value2;
  const { innerWidth, innerHeight } = coordinate.getOptions();
  const P = Array.from(index2, (i2) => {
    const x05 = X[i2];
    const y05 = Y[i2];
    const x2 = typeof x05 === "string" ? p(x05) * innerWidth : +x05;
    const y3 = typeof y05 === "string" ? p(y05) * innerHeight : +y05;
    return [[x2, y3]];
  });
  return [index2, P];
}
function field(encode) {
  return typeof encode === "function" ? encode : (d3) => d3[encode];
}
function valueof(data, encode) {
  return Array.from(data, field(encode));
}
function normalizeGraphData(data) {
  if (Array.isArray(data)) {
    return { links: data };
  }
  if (data && typeof data === "object") {
    return {
      links: data.links || [],
      nodes: data.nodes
    };
  }
  return { links: [] };
}
function initializeData(data, encode) {
  const normalizedData = normalizeGraphData(data);
  const { source = (d3) => d3.source, target = (d3) => d3.target, value: value2 = (d3) => d3.value } = encode;
  const { links, nodes } = normalizedData;
  if (!links.length) {
    return {
      links: [],
      nodes: nodes || []
    };
  }
  const LS = valueof(links, source);
  const LT = valueof(links, target);
  const LV = valueof(links, value2);
  return {
    links: links.map((_, i2) => ({
      target: LT[i2],
      source: LS[i2],
      value: LV[i2]
    })),
    nodes: nodes || Array.from(/* @__PURE__ */ new Set([...LS, ...LT]), (key) => ({ key }))
  };
}

// node_modules/@antv/g2/esm/shape/image/image.js
var __rest27 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var Image3 = (options, context) => {
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor } = defaults4, rest = __rest27(defaults4, ["color"]);
    const { color = defaultColor, src = "", size: size4 = 32, transform: transform2 = "" } = value2;
    let { width = size4, height = size4 } = options;
    const [[x05, y05]] = points;
    const [w2, h2] = coordinate.getSize();
    width = typeof width === "string" ? p(width) * w2 : width;
    height = typeof height === "string" ? p(height) * h2 : height;
    const x2 = x05 - Number(width) / 2;
    const y3 = y05 - Number(height) / 2;
    return select(document2.createElement("image", {})).call(applyStyle, rest).style("x", x2).style("y", y3).style("src", src).style("stroke", color).style("transform", transform2).call(applyStyle, options).style("width", width).style("height", height).node();
  };
};
Image3.props = {
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/polygon/polygon.js
var __rest28 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function getPolygonPath(points, coordinate) {
  const path2 = path();
  if (isPolar(coordinate)) {
    const center2 = coordinate.getCenter();
    const closedPoints = [...points, points[0]];
    const dists = closedPoints.map((p3) => dist(p3, center2));
    closedPoints.forEach((curr, idx) => {
      if (idx === 0) {
        path2.moveTo(curr[0], curr[1]);
        return;
      }
      const currDist = dists[idx];
      const prev = points[idx - 1];
      const prevDist = dists[idx - 1];
      if (prevDist !== void 0 && Math.abs(currDist - prevDist) < 1e-10) {
        appendArc(path2, prev, curr, center2, currDist);
      } else {
        path2.lineTo(curr[0], curr[1]);
      }
    });
    path2.closePath();
    return path2;
  }
  return appendPolygon(path2, points);
}
var Polygon2 = (options, context) => {
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor } = defaults4, rest = __rest28(defaults4, ["color"]);
    const { color = defaultColor, transform: transform2 } = value2;
    const path2 = getPolygonPath(points, coordinate);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color).style("fill", color).style("transform", transform2).call(applyStyle, options).node();
  };
};
Polygon2.props = {
  defaultMarker: "square",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/polygon/ribbon.js
var __rest29 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function getRibbonPath(points, coordinate) {
  const [p0, p1, p22, p3] = points;
  const path2 = path();
  if (isPolar(coordinate)) {
    const center2 = coordinate.getCenter();
    const radius = dist(center2, p0);
    path2.moveTo(p0[0], p0[1]);
    path2.quadraticCurveTo(center2[0], center2[1], p22[0], p22[1]);
    appendArc(path2, p22, p3, center2, radius);
    path2.quadraticCurveTo(center2[0], center2[1], p1[0], p1[1]);
    appendArc(path2, p1, p0, center2, radius);
    path2.closePath();
    return path2;
  }
  path2.moveTo(p0[0], p0[1]);
  path2.bezierCurveTo(p0[0] / 2 + p22[0] / 2, p0[1], p0[0] / 2 + p22[0] / 2, p22[1], p22[0], p22[1]);
  path2.lineTo(p3[0], p3[1]);
  path2.bezierCurveTo(p3[0] / 2 + p1[0] / 2, p3[1], p3[0] / 2 + p1[0] / 2, p1[1], p1[0], p1[1]);
  path2.lineTo(p0[0], p0[1]);
  path2.closePath();
  return path2;
}
var Ribbon = (options, context) => {
  const style = __rest29(options, []);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor } = defaults4, rest = __rest29(defaults4, ["color"]);
    const { color = defaultColor, transform: transform2 } = value2;
    const path2 = getRibbonPath(points, coordinate);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("fill", color || defaultColor).style("stroke", color || defaultColor).style("transform", transform2).call(applyStyle, style).node();
  };
};
Ribbon.props = {
  defaultMarker: "square",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/box/box.js
var __rest30 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function getPath2(points, coordinate) {
  const path2 = path();
  if (!isPolar(coordinate)) {
    path2.moveTo(...points[0]);
    path2.lineTo(...points[1]);
    path2.moveTo(...points[2]);
    path2.lineTo(...points[3]);
    path2.moveTo(...points[4]);
    path2.lineTo(...points[5]);
    path2.lineTo(...points[6]);
    path2.lineTo(...points[7]);
    path2.closePath();
    path2.moveTo(...points[8]);
    path2.lineTo(...points[9]);
    path2.moveTo(...points[10]);
    path2.lineTo(...points[11]);
    path2.moveTo(...points[12]);
    path2.lineTo(...points[13]);
  } else {
    const center2 = coordinate.getCenter();
    const [x2, y3] = center2;
    const startAngle = angle(sub(points[0], center2));
    const endAngle = angle(sub(points[1], center2));
    const radiusHigh = dist(center2, points[2]);
    const radiusQ3 = dist(center2, points[3]);
    const radiusMedian = dist(center2, points[8]);
    const radiusQ1 = dist(center2, points[10]);
    const radiusLow = dist(center2, points[11]);
    path2.moveTo(...points[0]);
    path2.arc(x2, y3, radiusHigh, startAngle, endAngle);
    path2.arc(x2, y3, radiusHigh, endAngle, startAngle, true);
    path2.moveTo(...points[2]);
    path2.lineTo(...points[3]);
    path2.moveTo(...points[4]);
    path2.arc(x2, y3, radiusQ3, startAngle, endAngle);
    path2.lineTo(...points[6]);
    path2.arc(x2, y3, radiusQ1, endAngle, startAngle, true);
    path2.closePath();
    path2.moveTo(...points[8]);
    path2.arc(x2, y3, radiusMedian, startAngle, endAngle);
    path2.arc(x2, y3, radiusMedian, endAngle, startAngle, true);
    path2.moveTo(...points[10]);
    path2.lineTo(...points[11]);
    path2.moveTo(...points[12]);
    path2.arc(x2, y3, radiusLow, startAngle, endAngle);
    path2.arc(x2, y3, radiusLow, endAngle, startAngle, true);
  }
  return path2;
}
var Box = (options, context) => {
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color, transform: transform2 } = value2;
    const { color: defaultColor, fill = defaultColor, stroke: stroke2 = defaultColor } = defaults4, rest = __rest30(defaults4, ["color", "fill", "stroke"]);
    const path2 = getPath2(points, coordinate);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", stroke2).style("fill", color || fill).style("transform", transform2).call(applyStyle, options).node();
  };
};
Box.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/box/violin.js
var __rest31 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function getPath3(p3, coordinate, size4 = 4) {
  const path2 = path();
  if (!isPolar(coordinate)) {
    path2.moveTo(...p3[2]);
    path2.lineTo(...p3[3]);
    path2.lineTo(p3[3][0] - size4, p3[3][1]);
    path2.lineTo(p3[10][0] - size4, p3[10][1]);
    path2.lineTo(p3[10][0] + size4, p3[10][1]);
    path2.lineTo(p3[3][0] + size4, p3[3][1]);
    path2.lineTo(...p3[3]);
    path2.closePath();
    path2.moveTo(...p3[10]);
    path2.lineTo(...p3[11]);
    path2.moveTo(p3[3][0] + size4 / 2, p3[8][1]);
    path2.arc(p3[3][0], p3[8][1], size4 / 2, 0, Math.PI * 2);
    path2.closePath();
    return path2;
  }
  const center2 = coordinate.getCenter();
  const [x2, y3] = center2;
  const radiusQ3 = dist(center2, p3[3]);
  const radiusMedian = dist(center2, p3[8]);
  const radiusQ1 = dist(center2, p3[10]);
  const middleAngle = angle(sub(p3[2], center2));
  const rectAngle = Math.asin(size4 / radiusMedian);
  const startAngle = middleAngle - rectAngle;
  const endAngle = middleAngle + rectAngle;
  path2.moveTo(...p3[2]);
  path2.lineTo(...p3[3]);
  path2.moveTo(Math.cos(startAngle) * radiusQ3 + x2, Math.sin(startAngle) * radiusQ3 + y3);
  path2.arc(x2, y3, radiusQ3, startAngle, endAngle);
  path2.lineTo(Math.cos(endAngle) * radiusQ1 + x2, Math.sin(endAngle) * radiusQ1 + y3);
  path2.arc(x2, y3, radiusQ1, endAngle, startAngle, true);
  path2.lineTo(Math.cos(startAngle) * radiusQ3 + x2, Math.sin(startAngle) * radiusQ3 + y3);
  path2.closePath();
  path2.moveTo(...p3[10]);
  path2.lineTo(...p3[11]);
  const a4 = (startAngle + endAngle) / 2;
  path2.moveTo(Math.cos(a4) * (radiusMedian + size4 / 2) + x2, Math.sin(a4) * (radiusMedian + size4 / 2) + y3);
  path2.arc(Math.cos(a4) * radiusMedian + x2, Math.sin(a4) * radiusMedian + y3, size4 / 2, a4, Math.PI * 2 + a4);
  path2.closePath();
  return path2;
}
var Violin = (options, context) => {
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color, transform: transform2 } = value2;
    const size4 = 4;
    const { color: defaultColor, fill = defaultColor, stroke: stroke2 = defaultColor } = defaults4, rest = __rest31(defaults4, ["color", "fill", "stroke"]);
    const path2 = getPath3(points, coordinate, size4);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", stroke2).style("fill", color || fill).style("transform", transform2).call(applyStyle, options).node();
  };
};
Violin.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/lineXY/line.js
var __rest32 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function getArrowMarker(document2, arrowSize, arrowStyle) {
  const arrowMarker = document2.createElement("path", {
    style: Object.assign({ d: `M ${arrowSize},${arrowSize} L -${arrowSize},0 L ${arrowSize},-${arrowSize} L 0,0 Z`, transformOrigin: "center" }, arrowStyle)
  });
  return arrowMarker;
}
function getPath4(points, coordinate) {
  if (!isPolar(coordinate))
    return line_default().x((d3) => d3[0]).y((d3) => d3[1])(points);
  const center2 = coordinate.getCenter();
  return arc_default()({
    startAngle: 0,
    endAngle: Math.PI * 2,
    outerRadius: dist(points[0], center2),
    innerRadius: dist(points[1], center2)
  });
}
function getTransform2(coordinate, transform2) {
  if (!isPolar(coordinate))
    return transform2;
  const [cx, cy] = coordinate.getCenter();
  return `translate(${cx}, ${cy}) ${transform2 || ""}`;
}
var Line4 = (options, context) => {
  const { arrow, arrowSize = 4 } = options, style = __rest32(options, ["arrow", "arrowSize"]);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor, lineWidth } = defaults4, shapeTheme = __rest32(defaults4, ["color", "lineWidth"]);
    const { color = defaultColor, size: size4 = lineWidth } = value2;
    const arrowMarker = arrow ? getArrowMarker(document2, arrowSize, Object.assign({ fill: style.stroke || color, stroke: style.stroke || color }, subObject(style, "arrow"))) : null;
    const path2 = getPath4(points, coordinate);
    const transform2 = getTransform2(coordinate, value2.transform);
    return select(document2.createElement("path", {})).call(applyStyle, shapeTheme).style("d", path2).style("stroke", color).style("lineWidth", size4).style("transform", transform2).style("markerEnd", arrowMarker).call(applyStyle, style).node();
  };
};
Line4.props = {
  defaultMarker: "line",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/connector/connector.js
var __rest33 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function inferSymbol(x2, y3, r2) {
  return [["M", x2, y3], ["L", x2 + 2 * r2, y3 - r2], ["L", x2 + 2 * r2, y3 + r2], ["Z"]];
}
function inferConnectorPath2(points) {
  return line_default().x((d3) => d3[0]).y((d3) => d3[1])(points);
}
function getPoints(coordinate, points, sourceOffsetY, targetOffsetY, sourceOffsetX, targetOffsetX, length1 = 0) {
  const [[x05, y05], [x12, y12]] = points;
  if (isTranspose(coordinate)) {
    const X03 = x05 + sourceOffsetY;
    const X13 = x12 + targetOffsetY;
    const X = X03 + length1;
    const Y03 = y05 + sourceOffsetX;
    const Y13 = y12 + targetOffsetX;
    return [
      [X03, Y03],
      [X, Y03],
      [X, Y13],
      [X13, Y13]
    ];
  }
  const Y02 = y05 - sourceOffsetY;
  const Y12 = y12 - targetOffsetY;
  const Y = Y02 - length1;
  const X02 = x05 - sourceOffsetX;
  const X12 = x12 - targetOffsetX;
  return [
    [X02, Y02],
    [X02, Y],
    [X12, Y],
    [X12, Y12]
  ];
}
var Connector = (options, context) => {
  const { offsetX = 0, sourceOffsetX = offsetX, targetOffsetX = offsetX, offsetY = 0, sourceOffsetY = offsetY, targetOffsetY = offsetY, connectLength1: length1, endMarker = true } = options, style = __rest33(options, ["offsetX", "sourceOffsetX", "targetOffsetX", "offsetY", "sourceOffsetY", "targetOffsetY", "connectLength1", "endMarker"]);
  const { coordinate } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor, connectLength1 } = defaults4, rest = __rest33(defaults4, ["color", "connectLength1"]);
    const { color, transform: transform2 } = value2;
    const P = getPoints(coordinate, points, sourceOffsetY, targetOffsetY, sourceOffsetX, targetOffsetX, length1 !== null && length1 !== void 0 ? length1 : connectLength1);
    const makerStyle = subObject(Object.assign(Object.assign({}, style), defaults4), "endMarker");
    return select(new Path()).call(applyStyle, rest).style("d", inferConnectorPath2(P)).style("stroke", color || defaultColor).style("transform", transform2).style("markerEnd", endMarker ? new Marker({
      className: "marker",
      style: Object.assign(Object.assign({}, makerStyle), { symbol: inferSymbol })
    }) : null).call(applyStyle, style).node();
  };
};
Connector.props = {
  defaultMarker: "line",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/label/position/index.js
var position_exports = {};
__export(position_exports, {
  area: () => area,
  bottom: () => getDefaultStyle,
  bottomLeft: () => getDefaultStyle,
  bottomRight: () => getDefaultStyle,
  inside: () => getDefaultStyle,
  left: () => getDefaultStyle,
  outside: () => outside,
  right: () => getDefaultStyle,
  spider: () => spider,
  surround: () => surround,
  top: () => getDefaultStyle,
  topLeft: () => getDefaultStyle,
  topRight: () => getDefaultStyle
});

// node_modules/@antv/g2/esm/shape/label/position/area.js
function area(position, points, value2, coordinate) {
  const l2 = points.length / 2;
  const Y12 = points.slice(0, l2);
  const Y02 = points.slice(l2);
  let idx = maxIndex(Y12, (p3, i2) => Math.abs(p3[1] - Y02[i2][1]));
  idx = Math.max(Math.min(idx, l2 - 2), 1);
  const mid2 = (i2) => [Y12[i2][0], (Y12[i2][1] + Y02[i2][1]) / 2];
  const point6 = mid2(idx);
  const prev = mid2(idx - 1);
  const next = mid2(idx + 1);
  const rotate2 = angle(sub(next, prev)) / Math.PI * 180;
  return {
    x: point6[0],
    y: point6[1],
    transform: `rotate(${rotate2})`,
    textAlign: "center",
    textBaseline: "middle"
  };
}

// node_modules/@antv/g2/esm/shape/label/position/default.js
function inferNonCircularStyle(position, points, value2, coordinate) {
  const { bounds } = value2;
  const [[x05, y05], [x12, y12]] = bounds;
  const w2 = x12 - x05;
  const h2 = y12 - y05;
  const xy = (options) => {
    const { x: ox, y: oy } = options;
    const px = maybePercentage(value2.x, w2);
    const py = maybePercentage(value2.y, h2);
    return Object.assign(Object.assign({}, options), { x: (px || ox) + x05, y: (py || oy) + y05 });
  };
  if (position === "left")
    return xy({ x: 0, y: h2 / 2, textAlign: "start", textBaseline: "middle" });
  if (position === "right")
    return xy({ x: w2, y: h2 / 2, textAlign: "end", textBaseline: "middle" });
  if (position === "top")
    return xy({ x: w2 / 2, y: 0, textAlign: "center", textBaseline: "top" });
  if (position === "bottom")
    return xy({ x: w2 / 2, y: h2, textAlign: "center", textBaseline: "bottom" });
  if (position === "top-left")
    return xy({ x: 0, y: 0, textAlign: "start", textBaseline: "top" });
  if (position === "top-right")
    return xy({ x: w2, y: 0, textAlign: "end", textBaseline: "top" });
  if (position === "bottom-left")
    return xy({ x: 0, y: h2, textAlign: "start", textBaseline: "bottom" });
  if (position === "bottom-right")
    return xy({ x: w2, y: h2, textAlign: "end", textBaseline: "bottom" });
  return xy({
    x: w2 / 2,
    y: h2 / 2,
    textAlign: "center",
    textBaseline: "middle"
  });
}
function inferRadialStyle(position, points, value2, coordinate) {
  const { y: y3, y1: y12, autoRotate, rotateToAlignArc } = value2;
  const center2 = coordinate.getCenter();
  const arcObject = getArcObject(coordinate, points, [y3, y12]);
  const { innerRadius, outerRadius, startAngle, endAngle } = arcObject;
  const angle2 = position === "inside" ? (startAngle + endAngle) / 2 : endAngle;
  const rotate2 = inferRotation(angle2, autoRotate, rotateToAlignArc);
  const point6 = (() => {
    const [p0, p1] = points;
    const radius = innerRadius + (outerRadius - innerRadius) * 0.5;
    const [x2, y4] = position === "inside" ? pointOfArc(center2, angle2, radius) : mid(p0, p1);
    return { x: x2, y: y4 };
  })();
  return Object.assign(Object.assign({}, point6), { textAlign: position === "inside" ? "center" : "start", textBaseline: "middle", rotate: rotate2 });
}
function pointOfArc(center2, angle2, radius) {
  return [
    center2[0] + Math.sin(angle2) * radius,
    center2[1] - Math.cos(angle2) * radius
  ];
}
function inferRotation(angle2, autoRotate, rotateToAlignArc) {
  if (!autoRotate)
    return 0;
  const append3 = rotateToAlignArc ? 0 : Math.sin(angle2) < 0 ? 90 : -90;
  return angle2 / Math.PI * 180 + append3;
}
function inferInnerCircularStyle(position, points, value2, coordinate) {
  const { y: y3, y1: y12, autoRotate, rotateToAlignArc, radius: radiusRatio = 0.5, offset: offset2 = 0 } = value2;
  const arcObject = getArcObject(coordinate, points, [y3, y12]);
  const { startAngle, endAngle } = arcObject;
  const center2 = coordinate.getCenter();
  const angle2 = (startAngle + endAngle) / 2;
  const rotate2 = inferRotation(angle2, autoRotate, rotateToAlignArc);
  const textStyle = { textAlign: "center", textBaseline: "middle", rotate: rotate2 };
  const { innerRadius, outerRadius } = arcObject;
  const r0 = innerRadius + (outerRadius - innerRadius) * radiusRatio;
  const r1 = r0 + offset2;
  const [x05, y05] = pointOfArc(center2, angle2, r1);
  return Object.assign({ x: x05, y: y05 }, textStyle);
}
function maybeUndefined(d3) {
  return d3 === void 0 ? null : d3;
}
function inferIdentityStyle(position, points, value2, coordinate) {
  const { bounds } = value2;
  const [p3] = bounds;
  return {
    x: maybeUndefined(p3[0]),
    y: maybeUndefined(p3[1])
  };
}
function getDefaultStyle(position, points, value2, coordinate) {
  const { bounds } = value2;
  if (bounds.length === 1) {
    return inferIdentityStyle(position, points, value2, coordinate);
  }
  const inferDefaultStyle2 = isRadial(coordinate) ? inferRadialStyle : isCircular(coordinate) ? inferInnerCircularStyle : inferNonCircularStyle;
  return inferDefaultStyle2(position, points, value2, coordinate);
}

// node_modules/@antv/g2/esm/shape/label/position/outside.js
function linePoints(center2, angle2, radius, radius1, offsetX) {
  const [x05, y05] = pointOfArc(center2, angle2, radius);
  const [x12, y12] = pointOfArc(center2, angle2, radius1);
  const sign3 = Math.sin(angle2) > 0 ? 1 : -1;
  return [
    [x05, y05],
    [x12, y12],
    [x12 + sign3 * offsetX, y12]
  ];
}
function radiusOf2(points, value2, coordinate) {
  const arcObject = getArcObject(coordinate, points, [value2.y, value2.y1]);
  const { innerRadius, outerRadius } = arcObject;
  return innerRadius + (outerRadius - innerRadius);
}
function angleOf2(points, value2, coordinate) {
  const arcObject = getArcObject(coordinate, points, [value2.y, value2.y1]);
  const { startAngle, endAngle } = arcObject;
  return (startAngle + endAngle) / 2;
}
function inferOutsideCircularStyle(position, points, value2, coordinate) {
  const { autoRotate, rotateToAlignArc, offset: offset2 = 0, connector = true, connectorLength = offset2, connectorLength2 = 0, connectorDistance = 0 } = value2;
  const center2 = coordinate.getCenter();
  const angle2 = angleOf2(points, value2, coordinate);
  const sign3 = Math.sin(angle2) > 0 ? 1 : -1;
  const rotate2 = inferRotation(angle2, autoRotate, rotateToAlignArc);
  const textStyle = {
    textAlign: sign3 > 0 || isRadial(coordinate) ? "start" : "end",
    textBaseline: "middle",
    rotate: rotate2
  };
  const radius = radiusOf2(points, value2, coordinate);
  const radius1 = radius + (connector ? connectorLength : offset2);
  const [[x05, y05], [x12, y12], [x2, y22]] = linePoints(center2, angle2, radius, radius1, connector ? connectorLength2 : 0);
  const dx = connector ? +connectorDistance * sign3 : 0;
  const x3 = x2 + dx;
  const y3 = y22;
  const connectorStyle = {
    connector,
    connectorPoints: [
      [x12 - x3, y12 - y3],
      [x2 - x3, y22 - y3]
    ]
  };
  return Object.assign(Object.assign({
    x0: x05,
    y0: y05,
    x: x2 + dx,
    y: y22
  }, textStyle), connectorStyle);
}
function outside(position, points, value2, coordinate) {
  const { bounds } = value2;
  if (bounds.length === 1) {
    return inferIdentityStyle(position, points, value2, coordinate);
  }
  const inferDefaultStyle2 = isRadial(coordinate) ? inferRadialStyle : isCircular(coordinate) ? inferOutsideCircularStyle : inferNonCircularStyle;
  return inferDefaultStyle2(position, points, value2, coordinate);
}

// node_modules/@antv/g2/esm/shape/label/position/utils.js
function dodgeY(labels, options = {}) {
  const { labelHeight = 14, height } = options;
  const sortedLabels = sort(labels, (d3) => d3.y);
  const n2 = sortedLabels.length;
  const boxes = new Array(n2);
  for (let i3 = 0; i3 < n2; i3++) {
    const label = sortedLabels[i3];
    const { y: y3 } = label;
    boxes[i3] = { y: y3, y1: y3 + labelHeight, labels: [y3] };
  }
  let overlap = true;
  while (overlap) {
    overlap = false;
    for (let i3 = boxes.length - 1; i3 > 0; i3--) {
      const box = boxes[i3];
      const preBox = boxes[i3 - 1];
      if (preBox.y1 > box.y) {
        overlap = true;
        preBox.labels.push(...box.labels);
        boxes.splice(i3, 1);
        preBox.y1 += box.y1 - box.y;
        const newHeight = preBox.y1 - preBox.y;
        preBox.y1 = Math.max(Math.min(preBox.y1, height), newHeight);
        preBox.y = preBox.y1 - newHeight;
      }
    }
  }
  let i2 = 0;
  for (const box of boxes) {
    const { y: y3, labels: labels2 } = box;
    let prevY = y3 - labelHeight;
    for (const curY of labels2) {
      const label = sortedLabels[i2++];
      const expectedY = prevY + labelHeight;
      const dy = expectedY - curY;
      label.connectorPoints[0][1] -= dy;
      label.y = prevY + labelHeight;
      prevY += labelHeight;
    }
  }
}
function hideAndDodgeY(unsorted, options) {
  const labels = sort(unsorted, (d3) => d3.y);
  const { height, labelHeight = 14 } = options;
  const maxCount = Math.ceil(height / labelHeight);
  if (labels.length <= maxCount)
    return dodgeY(labels, options);
  const filtered = [];
  for (let i2 = 0; i2 < labels.length; i2++) {
    if (i2 < labels.length - maxCount) {
      labels[i2].opacity = 0;
      labels[i2].connector = false;
    } else
      filtered.push(labels[i2]);
  }
  dodgeY(filtered, options);
}

// node_modules/@antv/g2/esm/shape/label/position/spider.js
var __rest34 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var styleByPoints = /* @__PURE__ */ new WeakMap();
function compute(points, value2, coordinate) {
  const { connectorLength, connectorLength2, connectorDistance } = value2;
  const style = __rest34(inferOutsideCircularStyle("outside", points, value2, coordinate), []);
  const center2 = coordinate.getCenter();
  const radius = radiusOf2(points, value2, coordinate);
  const angle2 = angleOf2(points, value2, coordinate);
  const radius1 = radius + connectorLength + connectorLength2;
  const sign3 = Math.sin(angle2) > 0 ? 1 : -1;
  const newX = center2[0] + (radius1 + +connectorDistance) * sign3;
  const { x: originX } = style;
  const dx = newX - originX;
  style.x += dx;
  style.connectorPoints[0][0] -= dx;
  return style;
}
function spider(position, points, value2, coordinate, options, labels) {
  if (!isCircular(coordinate))
    return {};
  if (styleByPoints.has(points))
    return styleByPoints.get(points);
  const computed = labels.map((points2) => compute(points2, value2, coordinate));
  const { width, height } = coordinate.getOptions();
  const left2 = computed.filter((d3) => d3.x < width / 2);
  const right2 = computed.filter((d3) => d3.x >= width / 2);
  const extendedOptions = Object.assign(Object.assign({}, options), { height });
  hideAndDodgeY(left2, extendedOptions);
  hideAndDodgeY(right2, extendedOptions);
  computed.forEach((style, i2) => styleByPoints.set(labels[i2], style));
  return styleByPoints.get(points);
}

// node_modules/@antv/g2/esm/shape/label/position/surround.js
var __rest35 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function surround(position, points, value2, coordinate) {
  if (!isCircular(coordinate))
    return {};
  const { connectorLength, connectorLength2, connectorDistance } = value2;
  const style = __rest35(inferOutsideCircularStyle("outside", points, value2, coordinate), []);
  const { x0: x05, y0: y05 } = style;
  const center2 = coordinate.getCenter();
  const radius = getRadius(coordinate);
  const radius1 = radius + connectorLength;
  const angle2 = angleWithQuadrant([x05 - center2[0], y05 - center2[1]]);
  const sign3 = Math.sin(angle2) > 0 ? 1 : -1;
  const [newX, newY] = pointOfArc(center2, angle2, radius1);
  style.x = newX + (connectorLength2 + connectorDistance) * sign3;
  style.y = newY;
  return style;
}

// node_modules/@antv/g2/esm/shape/label/label.js
var __rest36 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function inferPosition(position, coordinate) {
  if (position !== void 0)
    return position;
  if (isCircular(coordinate))
    return "inside";
  if (isTranspose(coordinate))
    return "right";
  return "top";
}
function getDefaultStyle2(points, value2, coordinate, theme, options, labels) {
  const { position } = value2;
  const { render: render3 } = options;
  const p3 = inferPosition(position, coordinate);
  const labelType = render3 ? "htmlLabel" : p3 === "inside" ? "innerLabel" : "label";
  const t = theme[labelType];
  const v = Object.assign({}, t, value2);
  const processor = position_exports[camelCase(p3)];
  if (!processor) {
    throw new Error(`Unknown position: ${p3}`);
  }
  return Object.assign(Object.assign({}, t), processor(p3, points, v, coordinate, options, labels));
}
var Label = (options, context) => {
  const { coordinate, theme } = context;
  const { render: render3 } = options;
  return (points, value2, style, labels) => {
    const { text, x: x2, y: y3, transform: specifiedTS = "", transformOrigin, className: className2 = "" } = value2, overrideStyle = __rest36(value2, ["text", "x", "y", "transform", "transformOrigin", "className"]);
    const _a = getDefaultStyle2(points, value2, coordinate, theme, options, labels), { rotate: rotate2 = 0, transform: transform2 = "" } = _a, defaultStyle2 = __rest36(_a, ["rotate", "transform"]);
    return select(new Advance()).call(applyStyle, defaultStyle2).style("text", `${text}`).style("className", `${className2} g2-label`).style("innerHTML", render3 ? render3(text, value2.datum, value2.index) : void 0).style("labelTransform", `${transform2} rotate(${+rotate2}) ${specifiedTS}`.trim()).style("labelTransformOrigin", transformOrigin).style("coordCenter", coordinate.getCenter()).call(applyStyle, overrideStyle).node();
  };
};
Label.props = {
  defaultMarker: "point"
};

// node_modules/@antv/g2/esm/shape/path/color.js
var __rest37 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var Color3 = (options, context) => {
  const { arrow, colorAttribute } = options, style = __rest37(options, ["arrow", "colorAttribute"]);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor, stroke: stroke2 } = defaults4, rest = __rest37(defaults4, ["color", "stroke"]);
    const { d: d3, color = defaultColor } = value2;
    const [width, height] = coordinate.getSize();
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", typeof d3 === "function" ? d3({ width, height }) : d3).style(colorAttribute, color).call(applyStyle, style).node();
  };
};
Color3.props = {
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/path/path.js
var Path3 = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "fill" }, options), context);
};
Path3.props = {
  defaultMarker: "hvh",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/path/hollow.js
var Hollow2 = (options, context) => {
  return Color3(Object.assign({ fill: "none", colorAttribute: "stroke" }, options), context);
};
Hollow2.props = {
  defaultMarker: "hvh",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/density/density.js
var __rest38 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var Density = (options, context) => {
  const { document: document2 } = context;
  return (points, value2, defaults4) => {
    const { transform: transform2 } = value2;
    const { color: defaultColor } = defaults4, rest = __rest38(defaults4, ["color"]);
    const { color = defaultColor } = value2;
    const [first3, ...p3] = points;
    const path2 = path();
    path2.moveTo(...first3);
    p3.forEach(([x2, y3]) => {
      path2.lineTo(x2, y3);
    });
    path2.closePath();
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color || defaultColor).style("fill", color || defaultColor).style("fillOpacity", 0.4).style("transform", transform2).call(applyStyle, options).node();
  };
};
Density.props = {
  defaultMarker: "square",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/flru/dist/flru.mjs
function flru_default(max7) {
  var num, curr, prev;
  var limit = max7 || 1;
  function keep(key, value2) {
    if (++num > limit) {
      prev = curr;
      reset(1);
      ++num;
    }
    curr[key] = value2;
  }
  function reset(isPartial) {
    num = 0;
    curr = /* @__PURE__ */ Object.create(null);
    isPartial || (prev = /* @__PURE__ */ Object.create(null));
  }
  reset();
  return {
    clear: reset,
    has: function(key) {
      return curr[key] !== void 0 || prev[key] !== void 0;
    },
    get: function(key) {
      var val = curr[key];
      if (val !== void 0) return val;
      if ((val = prev[key]) !== void 0) {
        keep(key, val);
        return val;
      }
    },
    set: function(key, value2) {
      if (curr[key] !== void 0) {
        curr[key] = value2;
      } else {
        keep(key, value2);
      }
    }
  };
}

// node_modules/@antv/g2/esm/utils/lru.js
var cache = flru_default(3);
function lru(fn, keyFn = (...args) => `${args[0]}`, maxSize = 16) {
  const cache2 = flru_default(maxSize);
  return (...args) => {
    const key = keyFn(...args);
    let v = cache2.get(key);
    if (cache2.has(key))
      return cache2.get(key);
    v = fn(...args);
    cache2.set(key, v);
    return v;
  };
}

// node_modules/@antv/g2/esm/shape/heatmap/renderer/gradient.js
function parseGradient(gradient2) {
  if (typeof gradient2 === "string") {
    return gradient2.split(" ").map((stop) => {
      const [r2, c5] = stop.split(":");
      return [+r2, c5];
    });
  }
  return gradient2;
}

// node_modules/@antv/g2/esm/shape/heatmap/renderer/index.js
function newCanvas(createCanvas, width, height) {
  const c5 = createCanvas ? createCanvas() : document.createElement("canvas");
  c5.width = width;
  c5.height = height;
  return c5;
}
var getPointTemplate = lru((radius, blurFactor, createCanvas) => {
  const tplCanvas = newCanvas(createCanvas, radius * 2, radius * 2);
  const tplCtx = tplCanvas.getContext("2d");
  const x2 = radius;
  const y3 = radius;
  if (blurFactor === 1) {
    tplCtx.beginPath();
    tplCtx.arc(x2, y3, radius, 0, 2 * Math.PI, false);
    tplCtx.fillStyle = "rgba(0,0,0,1)";
    tplCtx.fill();
  } else {
    const gradient2 = tplCtx.createRadialGradient(x2, y3, radius * blurFactor, x2, y3, radius);
    gradient2.addColorStop(0, "rgba(0,0,0,1)");
    gradient2.addColorStop(1, "rgba(0,0,0,0)");
    tplCtx.fillStyle = gradient2;
    tplCtx.fillRect(0, 0, 2 * radius, 2 * radius);
  }
  return tplCanvas;
}, (radius) => `${radius}`);
function getColorPalette(gradientConfig, createCanvas) {
  const paletteCanvas = newCanvas(createCanvas, 256, 1);
  const paletteCtx = paletteCanvas.getContext("2d");
  const gradient2 = paletteCtx.createLinearGradient(0, 0, 256, 1);
  parseGradient(gradientConfig).forEach(([r2, c5]) => {
    gradient2.addColorStop(r2, c5);
  });
  paletteCtx.fillStyle = gradient2;
  paletteCtx.fillRect(0, 0, 256, 1);
  return paletteCtx.getImageData(0, 0, 256, 1).data;
}
function drawAlpha(shadowCtx, min6, max7, data, options, createCanvas) {
  const { blur: blur3 } = options;
  let len = data.length;
  while (len--) {
    const { x: x2, y: y3, value: v, radius } = data[len];
    const value2 = Math.min(v, max7);
    const rectX = x2 - radius;
    const rectY = y3 - radius;
    const tpl = getPointTemplate(radius, 1 - blur3, createCanvas);
    const templateAlpha = (value2 - min6) / (max7 - min6);
    shadowCtx.globalAlpha = Math.max(templateAlpha, 1e-3);
    shadowCtx.drawImage(tpl, rectX, rectY);
  }
  return shadowCtx;
}
function colorize(shadowCtx, maxWidth, maxHeight, palette, options) {
  const { minOpacity, opacity, maxOpacity, useGradientOpacity } = options;
  const x2 = 0;
  const y3 = 0;
  const width = maxWidth;
  const height = maxHeight;
  const img = shadowCtx.getImageData(x2, y3, width, height);
  const imgData = img.data;
  const len = imgData.length;
  for (let i2 = 3; i2 < len; i2 += 4) {
    const alpha = imgData[i2];
    const offset2 = alpha * 4;
    if (!offset2) {
      continue;
    }
    const finalAlpha = opacity || Math.max(0, Math.min(maxOpacity, Math.max(minOpacity, alpha)));
    imgData[i2 - 3] = palette[offset2];
    imgData[i2 - 2] = palette[offset2 + 1];
    imgData[i2 - 1] = palette[offset2 + 2];
    imgData[i2] = useGradientOpacity ? palette[offset2 + 3] : finalAlpha;
  }
  return img;
}
function HeatmapRenderer(width, height, min6, max7, data, options, createCanvas) {
  const opts = Object.assign({ blur: 0.85, minOpacity: 0, opacity: 0.6, maxOpacity: 1, gradient: [
    [0.25, "rgb(0,0,255)"],
    [0.55, "rgb(0,255,0)"],
    [0.85, "yellow"],
    [1, "rgb(255,0,0)"]
  ] }, options);
  opts.minOpacity *= 255;
  opts.opacity *= 255;
  opts.maxOpacity *= 255;
  const shadowCanvas = newCanvas(createCanvas, width, height);
  const shadowCtx = shadowCanvas.getContext("2d");
  const palette = getColorPalette(opts.gradient, createCanvas);
  shadowCtx.clearRect(0, 0, width, height);
  drawAlpha(shadowCtx, min6, max7, data, opts, createCanvas);
  const img = colorize(shadowCtx, width, height, palette, opts);
  const canvas = newCanvas(createCanvas, width, height);
  const ctx3 = canvas.getContext("2d");
  ctx3.putImageData(img, 0, 0);
  return ctx3;
}

// node_modules/@antv/g2/esm/shape/heatmap/heatmap.js
var __rest39 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function deleteKey(obj, fn) {
  return Object.keys(obj).reduce((r2, k2) => {
    const v = obj[k2];
    if (!fn(v, k2))
      r2[k2] = v;
    return r2;
  }, {});
}
var Heatmap = (options, context) => {
  const { gradient: gradient2, opacity, maxOpacity, minOpacity, blur: blur3, useGradientOpacity } = options, style = __rest39(options, ["gradient", "opacity", "maxOpacity", "minOpacity", "blur", "useGradientOpacity"]);
  const { coordinate, createCanvas, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { transform: transform2 } = value2;
    const [width, height] = coordinate.getSize();
    const data = points.map((p3) => ({
      x: p3[0],
      y: p3[1],
      value: p3[2],
      radius: p3[3]
    }));
    const min6 = min(points, (p3) => p3[2]);
    const max7 = max(points, (p3) => p3[2]);
    const options2 = {
      gradient: gradient2,
      opacity,
      minOpacity,
      maxOpacity,
      blur: blur3,
      useGradientOpacity
    };
    const ctx3 = width && height ? HeatmapRenderer(width, height, min6, max7, data, deleteKey(options2, (v) => v === void 0), createCanvas) : { canvas: null };
    return select(document2.createElement("image", {})).call(applyStyle, defaults4).style("x", 0).style("y", 0).style("width", width).style("height", height).style("src", ctx3.canvas.toDataURL()).style("transform", transform2).call(applyStyle, style).node();
  };
};
Heatmap.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/shape/shape.js
var __rest40 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var Shape2 = (options, context) => {
  const { render: render3 } = options, rest = __rest40(options, ["render"]);
  return (points) => {
    const [[x05, y05]] = points;
    return render3(Object.assign(Object.assign({}, rest), { x: x05, y: y05 }), context);
  };
};
Shape2.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/liquid/wave.js
var DURATION = 5e3;
function lerp(min6, max7, factor) {
  return min6 + (max7 - min6) * factor;
}
function getWaterWavePositions(x2, stage, waveLength, amplitude) {
  if (stage === 0) {
    return [
      [x2 + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2],
      [x2 + 1 / 2 * waveLength / Math.PI, amplitude],
      [x2 + waveLength / 4, amplitude]
    ];
  }
  if (stage === 1) {
    return [
      [x2 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), amplitude],
      [
        x2 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),
        amplitude / 2
      ],
      [x2 + waveLength / 4, 0]
    ];
  }
  if (stage === 2) {
    return [
      [x2 + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2],
      [x2 + 1 / 2 * waveLength / Math.PI, -amplitude],
      [x2 + waveLength / 4, -amplitude]
    ];
  }
  return [
    [x2 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), -amplitude],
    [
      x2 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),
      -amplitude / 2
    ],
    [x2 + waveLength / 4, 0]
  ];
}
function getWaterWavePath(radius, waterLevel, waveLength, phase, amplitude, cx, cy) {
  const curves = Math.ceil(2 * radius / waveLength * 4) * 4;
  const path2 = [];
  let _phase = phase;
  while (_phase < -Math.PI * 2) {
    _phase += Math.PI * 2;
  }
  while (_phase > 0) {
    _phase -= Math.PI * 2;
  }
  _phase = _phase / Math.PI / 2 * waveLength;
  const left2 = cx - radius + _phase - radius * 2;
  path2.push(["M", left2, waterLevel]);
  let waveRight = 0;
  for (let c5 = 0; c5 < curves; ++c5) {
    const stage = c5 % 4;
    const pos = getWaterWavePositions(c5 * waveLength / 4, stage, waveLength, amplitude);
    path2.push([
      "C",
      pos[0][0] + left2,
      -pos[0][1] + waterLevel,
      pos[1][0] + left2,
      -pos[1][1] + waterLevel,
      pos[2][0] + left2,
      -pos[2][1] + waterLevel
    ]);
    if (c5 === curves - 1) {
      waveRight = pos[2][0];
    }
  }
  path2.push(["L", waveRight + left2, cy + radius]);
  path2.push(["L", left2, cy + radius]);
  path2.push(["Z"]);
  return path2;
}
function addWave(x2, y3, level, waveCount, waveAttrs, group2, minY, radius, waveLength, animation, document2) {
  const { fill, fillOpacity, opacity } = waveAttrs;
  for (let idx = 0; idx < waveCount; idx++) {
    const factor = waveCount <= 1 ? 1 : idx / (waveCount - 1);
    const path2 = getWaterWavePath(
      radius,
      minY + radius * level,
      waveLength,
      0,
      // Amplitude height.
      radius / 40,
      x2,
      y3
    );
    const wave = document2.createElement("path", {
      style: {
        d: path2,
        fill,
        opacity: lerp(0.2, 0.9, factor) * Number(opacity || fillOpacity)
      }
    });
    group2.appendChild(wave);
    try {
      if (animation === false)
        return;
      const keyframes = [
        {
          transform: "translate(0, 0)"
        },
        {
          transform: `translate(${waveLength * 2}, 0)`
        }
      ];
      wave.animate(keyframes, {
        duration: lerp(0.5 * DURATION, DURATION, factor) * 2,
        iterations: Infinity
      });
    } catch (e3) {
      console.warn("off-screen group animate error!");
    }
  }
}

// node_modules/@antv/g2/esm/shape/liquid/shapes.js
function circle(x2, y3, r2) {
  return `
      M ${x2} ${y3 - r2} 
      a ${r2} ${r2} 0 1 0 0 ${r2 * 2}
      a ${r2} ${r2} 0 1 0 0 ${-r2 * 2}
      Z
    `;
}
function rect3(x2, y3, r2) {
  const GOLDEN_SECTION_RATIO = 0.618;
  const w2 = r2 * GOLDEN_SECTION_RATIO;
  return `
      M ${x2 - w2} ${y3 - r2}
      L ${x2 + w2} ${y3 - r2}
      L ${x2 + w2} ${y3 + r2}
      L ${x2 - w2} ${y3 + r2}
      Z
    `;
}
function diamond2(x2, y3, r2) {
  return `
      M ${x2} ${y3 - r2}
      L ${x2 + r2} ${y3}
      L ${x2} ${y3 + r2}
      L ${x2 - r2} ${y3}
      Z
    `;
}
function triangle2(x2, y3, r2) {
  return `
      M ${x2} ${y3 - r2}
      L ${x2 + r2} ${y3 + r2}
      L ${x2 - r2} ${y3 + r2}
      Z
    `;
}
function pin(x2, y3, radius) {
  const w2 = radius * 4 / 3;
  const h2 = Math.max(w2, radius * 2);
  const r2 = w2 / 2;
  const cx = x2;
  const cy = r2 + y3 - h2 / 2;
  const theta = Math.asin(r2 / ((h2 - r2) * 0.85));
  const dy = Math.sin(theta) * r2;
  const dx = Math.cos(theta) * r2;
  const x05 = cx - dx;
  const y05 = cy + dy;
  const cpX = x2;
  const cpY = cy + r2 / Math.sin(theta);
  return `
      M ${x05} ${y05}
      A ${r2} ${r2} 0 1 1 ${x05 + dx * 2} ${y05}
      Q ${cpX} ${cpY} ${x2} ${y3 + h2 / 2}
      Q ${cpX} ${cpY} ${x05} ${y05}
      Z 
    `;
}
var LiquidShapesPath = {
  pin,
  rect: rect3,
  circle,
  diamond: diamond2,
  triangle: triangle2
};

// node_modules/@antv/g2/esm/shape/liquid/liquid.js
var __rest41 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var getLiquidShape = (shape24 = "circle") => LiquidShapesPath[shape24] || LiquidShapesPath.circle;
var Liquid = (options, context) => {
  if (!context)
    return;
  const { coordinate } = context;
  const { liquidOptions, styleOptions } = options;
  const { liquidShape, percent } = liquidOptions;
  const { background: backgroundStyle, outline = {}, wave = {} } = styleOptions, attr = __rest41(styleOptions, ["background", "outline", "wave"]);
  const { border = 2, distance: distance2 = 0 } = outline, outlineStyle = __rest41(outline, ["border", "distance"]);
  const { length = 192, count: count4 = 3 } = wave;
  return (points, cfg, defaultAttr) => {
    const { document: document2 } = context.canvas;
    const { color, fillOpacity } = defaultAttr;
    const attrs = Object.assign(Object.assign({ fill: color }, defaultAttr), attr);
    const g = document2.createElement("g", {});
    const [centerX, centerY] = coordinate.getCenter();
    const size4 = coordinate.getSize();
    const radius = Math.min(...size4) / 2;
    const buildPath = isFunction(liquidShape) ? liquidShape : getLiquidShape(liquidShape);
    const shapePath = buildPath(centerX, centerY, radius, ...size4);
    const shapeClipPath = buildPath(centerX, centerY, radius + border / 2, ...size4);
    if (Object.keys(backgroundStyle).length) {
      const backgroundShape = document2.createElement("path", {
        style: Object.assign({ d: shapePath, fill: "#fff" }, backgroundStyle)
      });
      g.appendChild(backgroundShape);
    }
    if (percent > 0) {
      const clipShape = document2.createElement("path", {
        style: {
          d: shapeClipPath
        }
      });
      g.appendChild(clipShape);
      g.style.clipPath = clipShape;
      addWave(centerX, centerY, 1 - percent, count4, attrs, g, clipShape.getBBox().y, radius * 2, length, true, document2);
    }
    const distanceShape = document2.createElement("path", {
      style: {
        d: shapePath,
        fill: "transparent",
        lineWidth: border + 2 * distance2,
        stroke: "#fff"
      }
    });
    const borderShape = document2.createElement("path", {
      style: Object.assign(Object.assign(Object.assign({ d: shapePath, stroke: color, strokeOpacity: fillOpacity, lineWidth: border }, attrs), outlineStyle), { fill: "transparent" })
    });
    g.appendChild(distanceShape);
    g.appendChild(borderShape);
    return g;
  };
};
Liquid.props = {};

// node_modules/@antv/g2/esm/shape/gauge/round.js
var getR = (point1, point22) => {
  return Math.sqrt(Math.pow(point1[0] - point22[0], 2) + Math.pow(point1[1] - point22[1], 2)) / 2;
};
var getAngle = (start, end, center2) => {
  const startAngle = Math.atan2(start[1] - center2[1], start[0] - center2[0]);
  const endAngle = Math.atan2(end[1] - center2[1], end[0] - center2[0]);
  let angle2 = endAngle - startAngle;
  if (angle2 < 0)
    angle2 += Math.PI * 2;
  return angle2;
};
var Round = (options, context) => {
  if (!context)
    return;
  const { coordinate } = context;
  if (!(coordinate === null || coordinate === void 0 ? void 0 : coordinate.getCenter))
    return;
  const center2 = coordinate.getCenter();
  return (points, cfg, defaultCfg) => {
    const { document: document2 } = context.canvas;
    const { color, index: index2 } = cfg;
    const g = document2.createElement("g", {});
    const minR = getR(points[0], points[1]);
    const maxR = getR(points[0], center2) * 2;
    const isHalf = getAngle(points[3], points[0], center2) > Math.PI;
    const roundPath2 = document2.createElement("path", {
      style: Object.assign(Object.assign(Object.assign({ d: [
        ["M", ...points[0]],
        ["A", minR, minR, 0, 1, 0, ...points[1]],
        [
          "A",
          maxR + minR * 2,
          maxR + minR * 2,
          0,
          isHalf ? 1 : 0,
          0,
          ...points[2]
        ],
        ["A", minR, minR, 0, 1, index2 === 0 ? 0 : 1, ...points[3]],
        ["A", maxR, maxR, 0, isHalf ? 1 : 0, 1, ...points[0]],
        ["Z"]
      ] }, defaultCfg), omit_default(options, ["shape", "last", "first"])), { fill: color || defaultCfg.color })
    });
    g.appendChild(roundPath2);
    return g;
  };
};

// node_modules/@antv/g2/esm/runtime/constant.js
var MAIN_LAYER_CLASS_NAME = "main-layer";
var LABEL_LAYER_CLASS_NAME = "label-layer";
var ELEMENT_CLASS_NAME = "element";
var VIEW_CLASS_NAME = "view";
var PLOT_CLASS_NAME = "plot";
var COMPONENT_CLASS_NAME = "component";
var LABEL_CLASS_NAME = "label";
var AREA_CLASS_NAME = "area";
var MASK_CLASS_NAME = "mask";
var BREAK_CLASS_NAME = "axis-breaks";
var BREAK_GROUP_CLASS_NAME = "axis-breaks-group";

// node_modules/@antv/g2/esm/shape/axis-breaks/axis-breaks.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest42 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var BREAKS_GAP = 0.03;
var DEFAULT_STYLE = {
  fill: "#fff",
  stroke: "#aaa",
  lineDash: "4 3",
  lineWidth: 0.5,
  fillOpacity: 1,
  strokeOpacity: 1
};
var PADDING = 0;
var createPathPoints = (y3, width, offset2, vertices, isLowerBoundary, lineWidth) => {
  const pathPoints = [];
  const clipPoints = [];
  const segments = vertices - 1;
  for (let i2 = 1; i2 < segments; i2++) {
    const x2 = i2 / segments * width;
    const offsetY = y3 + (i2 % 2 === 0 ? offset2 : -offset2);
    pathPoints.push(`${x2},${offsetY}`);
    clipPoints.push(`${x2},${isLowerBoundary ? offsetY - lineWidth : offsetY + lineWidth}`);
  }
  pathPoints.push(`${width},${y3}`);
  clipPoints.push(`${width + lineWidth},${y3}`);
  return [pathPoints, clipPoints];
};
var AxisBreaks = (_, params) => {
  const { context, selection, view } = params;
  const layer = selection.select(`.${PLOT_CLASS_NAME}`).node();
  const { document: document2 } = context.canvas;
  const { scale: scale4 } = view;
  const collapsed = /* @__PURE__ */ new Map();
  const handleCollapseToggle = (key, start, end) => __awaiter2(void 0, void 0, void 0, function* () {
    const { update, setState } = context.externals;
    setState("options", (prev) => {
      const { marks } = prev;
      if (!marks || !marks.length)
        return prev;
      const newMarks = marks.map((mark2) => {
        const breaks = get_default(mark2, "scale.y.breaks", []);
        const newBreaks = breaks.filter((b) => b.start !== start && b.end !== end && !b.collapsed);
        breaks.forEach((b) => {
          if (b.start === start && b.end === end) {
            b.collapsed = true;
          }
        });
        console.log("breaks group:", breaks, newBreaks);
        return deep_mix_default({}, mark2, { scale: { y: { breaks: newBreaks } } });
      });
      collapsed.set(key, { start, end });
      return Object.assign(Object.assign({}, prev), { marks: newMarks });
    });
    yield update();
  });
  const resetCollapsed = () => __awaiter2(void 0, void 0, void 0, function* () {
    if (!collapsed.size)
      return;
    const { update, setState } = context.externals;
    setState("options", (prev) => {
      const { marks } = prev;
      const newMarks = marks.map((mark2) => {
        const breaks = get_default(mark2, "scale.y.breaks", []);
        set_default(mark2, "scale.y.breaks", breaks.map((b) => Object.assign(Object.assign({}, b), { collapsed: false })));
        return mark2;
      });
      collapsed.clear();
      return Object.assign(Object.assign({}, prev), { marks: newMarks });
    });
    yield update();
  });
  return (option) => {
    const { key, start, end, gap = BREAKS_GAP, vertices = 50, lineWidth = 0.5, verticeOffset = 3 } = option, style = __rest42(option, ["key", "start", "end", "gap", "vertices", "lineWidth", "verticeOffset"]);
    const g = document2.createElement("g", {
      id: `break-group-${key}`,
      className: BREAK_GROUP_CLASS_NAME
    });
    const xDomain = get_default(scale4, "x.sortedDomain", []);
    const yScale = scale4["y"].getOptions();
    const { range: range3, domain } = yScale;
    const startIndex = domain.indexOf(start);
    const endIndex = domain.indexOf(end);
    const { width: plotWidth, height: plotHeight } = layer.getBBox();
    if (startIndex === -1 || endIndex === -1 || !xDomain.length)
      return g;
    const reverse2 = range3[0] > range3[1];
    const lowerY = range3[startIndex] * plotHeight;
    const upperY = range3[endIndex] * plotHeight;
    let linePath = "";
    let clipPath = "";
    for (const [boundaryIndex, { y: y3, isLower }] of [
      { y: upperY, isLower: false },
      { y: lowerY, isLower: true }
    ].entries()) {
      const clipOffset = reverse2 ? lineWidth : -lineWidth;
      const [pathPoints, clipPoints] = createPathPoints(y3, plotWidth - PADDING, verticeOffset, vertices, isLower, clipOffset);
      if (boundaryIndex === 0) {
        linePath = `M ${PADDING},${y3} L ${pathPoints.join(" L ")} `;
        clipPath = `M ${PADDING - lineWidth},${y3 + clipOffset} L ${clipPoints.join(" L ")} `;
      } else {
        linePath += `L ${plotWidth - PADDING},${y3} L ${[...pathPoints].reverse().join(" L ")} L ${PADDING},${y3} Z`;
        clipPath += `L ${plotWidth - PADDING + lineWidth + 2},${y3 - clipOffset} L ${[...clipPoints].reverse().join(" L ")} L ${PADDING - lineWidth},${y3 - clipOffset} Z`;
      }
    }
    const pathAttrs = Object.assign(Object.assign({}, DEFAULT_STYLE), style);
    try {
      const path1 = new Path({ style: Object.assign(Object.assign({}, pathAttrs), { d: linePath }) });
      const path2 = new Path({
        style: Object.assign(Object.assign({}, pathAttrs), { d: clipPath, lineWidth: 0, cursor: "pointer" })
      });
      path2.addEventListener("click", (e3) => __awaiter2(void 0, void 0, void 0, function* () {
        e3.stopPropagation();
        if (e3.detail === 2) {
          yield handleCollapseToggle(key, start, end);
        }
      }));
      g.appendChild(path1);
      g.appendChild(path2);
      layer.addEventListener("click", (e3) => __awaiter2(void 0, void 0, void 0, function* () {
        if (e3.detail === 2) {
          yield resetCollapsed();
        }
      }));
      layer.appendChild(g);
    } catch (e3) {
      console.error("Failed to create break path:", e3);
    }
    return g;
  };
};
AxisBreaks.props = {};

// node_modules/@antv/g2/esm/mark/interval.js
function bandWidth2(scale4, x2) {
  return scale4.getBandWidth(scale4.invert(x2));
}
var shape = {
  rect: Rect2,
  hollow: Hollow,
  funnel: Funnel,
  pyramid: Pyramid
};
var Interval = () => {
  return (index2, scale4, value2, coordinate) => {
    const { x: X, y1: Y12, series: S, size: SZ } = value2;
    let { y: Y } = value2;
    Y = Y.map((d3) => d3 !== void 0 ? d3 : 1);
    const x2 = scale4.x;
    const series = scale4.series;
    const [width] = coordinate.getSize();
    const NSZ = SZ ? SZ.map((d3) => +d3 / width) : null;
    const x1x2 = !SZ ? (x3, w2, i2) => [x3, x3 + w2] : (x3, w2, i2) => {
      const mx = x3 + w2 / 2;
      const s3 = NSZ[i2];
      return [mx - s3 / 2, mx + s3 / 2];
    };
    const P = Array.from(index2, (i2) => {
      const groupWidth = bandWidth2(x2, X[i2]);
      const ratio = series ? bandWidth2(series, S === null || S === void 0 ? void 0 : S[i2]) : 1;
      const width2 = groupWidth * ratio;
      const offset2 = (+(S === null || S === void 0 ? void 0 : S[i2]) || 0) * groupWidth;
      const x05 = +X[i2] + offset2;
      const [x12, x22] = x1x2(x05, width2, i2);
      const y12 = +Y[i2];
      const y22 = +Y12[i2];
      const p1 = [x12, y12];
      const p22 = [x22, y12];
      const p3 = [x22, y22];
      const p4 = [x12, y22];
      return [p1, p22, p3, p4].map((d3) => coordinate.map(d3));
    });
    return [index2, P];
  };
};
Interval.props = {
  defaultShape: "rect",
  defaultLabelShape: "label",
  composite: false,
  shape,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape) }),
    { name: "x", scale: "band", required: true },
    { name: "y", required: true },
    { name: "series", scale: "band" },
    { name: "size" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroY1 },
    { type: MaybeZeroX }
  ],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: { shareTooltip: true }
};

// node_modules/@antv/g2/esm/mark/rect.js
var shape2 = {
  rect: Rect2,
  hollow: Hollow
};
var Rect3 = () => {
  return (index2, scale4, value2, coordinate) => {
    const { x: X, x1: X12, y: Y, y1: Y12 } = value2;
    const P = Array.from(index2, (i2) => {
      const p1 = [+X[i2], +Y[i2]];
      const p22 = [+X12[i2], +Y[i2]];
      const p3 = [+X12[i2], +Y12[i2]];
      const p4 = [+X[i2], +Y12[i2]];
      return [p1, p22, p3, p4].map((d3) => coordinate.map(d3));
    });
    return [index2, P];
  };
};
Rect3.props = {
  defaultShape: "rect",
  defaultLabelShape: "label",
  composite: false,
  shape: shape2,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape2) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeZeroY1 }],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: {
    shareTooltip: true
  }
};

// node_modules/@antv/g2/esm/mark/line.js
var shape3 = {
  line: Line2,
  smooth: Smooth,
  hv: HV,
  vh: VH,
  hvh: HVH,
  trail: Trail
};
var line2 = (index2, scale4, value2, coordinate) => {
  var _a, _b;
  const { series: S, x: X, y: Y } = value2;
  const { x: x2, y: y3 } = scale4;
  if (X === void 0 || Y === void 0) {
    throw new Error("Missing encode for x or y channel.");
  }
  const series = S ? Array.from(group(index2, (i2) => S[i2]).values()) : [index2];
  const I = series.map((group2) => group2[0]).filter((i2) => i2 !== void 0);
  const xoffset = (((_a = x2 === null || x2 === void 0 ? void 0 : x2.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(x2)) || 0) / 2;
  const yoffset = (((_b = y3 === null || y3 === void 0 ? void 0 : y3.getBandWidth) === null || _b === void 0 ? void 0 : _b.call(y3)) || 0) / 2;
  const P = Array.from(series, (I2) => {
    return I2.map((i2) => coordinate.map([+X[i2] + xoffset, +Y[i2] + yoffset]));
  });
  return [I, P, series];
};
var parallel = (index2, scale4, value2, coordinate) => {
  const PV = Object.entries(value2).filter(([key]) => key.startsWith("position")).map(([, value3]) => value3);
  if (PV.length === 0) {
    throw new Error("Missing encode for position channel.");
  }
  if (isPolar(coordinate))
    PV.push(PV[0]);
  const P = Array.from(index2, (i2) => {
    const vector = PV.map((pv) => +pv[i2]);
    const vectors = coordinate.map(vector);
    const points = [];
    for (let i3 = 0; i3 < vectors.length; i3 += 2) {
      points.push([vectors[i3], vectors[i3 + 1]]);
    }
    return points;
  });
  return [index2, P];
};
var Line5 = () => {
  return (index2, scale4, value2, coordinate) => {
    const mark2 = isParallel(coordinate) ? parallel : line2;
    return mark2(index2, scale4, value2, coordinate);
  };
};
Line5.props = {
  defaultShape: "line",
  defaultLabelShape: "label",
  composite: false,
  shape: shape3,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape3) }),
    { name: "x" },
    { name: "y" },
    { name: "position", independent: true },
    { name: "size" },
    { name: "series", scale: "band" }
  ],
  preInference: [
    ...basePreInference(),
    // !!!Note This order is very important.
    { type: MaybeGradient },
    { type: MaybeSeries }
  ],
  postInference: [...basePostInference(), ...tooltip1d(), ...tooltipXd()],
  interaction: {
    shareTooltip: true,
    seriesTooltip: true,
    crosshairs: true
  }
};

// node_modules/@antv/g2/esm/mark/point.js
var shape4 = {
  hollow: HollowPoint,
  hollowDiamond: HollowDiamond,
  hollowHexagon: HollowHexagon,
  hollowSquare: HollowSquare,
  hollowTriangleDown: HollowTriangleDown,
  hollowTriangle: HollowTriangle,
  hollowBowtie: HollowBowtie,
  hollowCircle: HollowCircle,
  point: Point2,
  plus: Plus,
  diamond: Diamond,
  square: Square,
  triangle: Triangle,
  hexagon: Hexagon,
  cross: Cross,
  bowtie: Bowtie,
  hyphen: Hyphen,
  line: Line3,
  tick: Tick,
  triangleDown: TriangleDown,
  circle: Circle2
};
var Point3 = (options) => {
  return (index2, scale4, value2, coordinate) => {
    const { x: X, y: Y, x1: X12, y1: Y12, size: S, dx: DX, dy: DY } = value2;
    const [width, height] = coordinate.getSize();
    const offset2 = createBandOffset(scale4, value2, options);
    const xy = (i2) => {
      const dx = +((DX === null || DX === void 0 ? void 0 : DX[i2]) || 0);
      const dy = +((DY === null || DY === void 0 ? void 0 : DY[i2]) || 0);
      const x2 = X12 ? (+X[i2] + +X12[i2]) / 2 : +X[i2];
      const y3 = Y12 ? (+Y[i2] + +Y12[i2]) / 2 : +Y[i2];
      const cx = x2 + dx;
      const cy = y3 + dy;
      return [cx, cy];
    };
    const P = S ? Array.from(index2, (i2) => {
      const [cx, cy] = xy(i2);
      const r2 = +S[i2];
      const a4 = r2 / width;
      const b = r2 / height;
      const p1 = [cx - a4, cy - b];
      const p22 = [cx + a4, cy + b];
      return [
        coordinate.map(offset2(p1, i2)),
        coordinate.map(offset2(p22, i2))
      ];
    }) : Array.from(index2, (i2) => [coordinate.map(offset2(xy(i2), i2))]);
    return [index2, P];
  };
};
Point3.props = {
  defaultShape: "hollow",
  defaultLabelShape: "label",
  composite: false,
  shape: shape4,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape4) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "series", scale: "band" },
    { name: "size", quantitative: "sqrt" },
    { name: "dx", scale: "identity" },
    { name: "dy", scale: "identity" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroX },
    { type: MaybeZeroY }
  ],
  postInference: [...basePostInference(), { type: MaybeSize }, ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/text.js
var shape5 = {
  text: Text2,
  badge: Badge,
  tag: Tag
};
var Text3 = (options) => {
  const { cartesian: cartesian3 = false } = options;
  if (cartesian3)
    return visualMark;
  return (index2, scale4, value2, coordinate) => {
    const { x: X, y: Y } = value2;
    const offset2 = createBandOffset(scale4, value2, options);
    const P = Array.from(index2, (i2) => {
      const p3 = [+X[i2], +Y[i2]];
      return [coordinate.map(offset2(p3, i2))];
    });
    return [index2, P];
  };
};
Text3.props = {
  defaultShape: "text",
  defaultLabelShape: "label",
  composite: false,
  shape: shape5,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape5) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "text", scale: "identity" },
    { name: "fontSize", scale: "identity" },
    { name: "rotate", scale: "identity" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeTuple },
    { type: MaybeVisualPosition }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/cell.js
var shape6 = {
  cell: Rect2,
  hollow: Hollow
};
var Cell = () => {
  return (index2, scale4, value2, coordinate) => {
    const { x: X, y: Y } = value2;
    const x2 = scale4.x;
    const y3 = scale4.y;
    const P = Array.from(index2, (i2) => {
      const width = x2.getBandWidth(x2.invert(+X[i2]));
      const height = y3.getBandWidth(y3.invert(+Y[i2]));
      const x12 = +X[i2];
      const y12 = +Y[i2];
      const p1 = [x12, y12];
      const p22 = [x12 + width, y12];
      const p3 = [x12 + width, y12 + height];
      const p4 = [x12, y12 + height];
      return [p1, p22, p3, p4].map((d3) => coordinate.map(d3));
    });
    return [index2, P];
  };
};
Cell.props = {
  defaultShape: "cell",
  defaultLabelShape: "label",
  shape: shape6,
  composite: false,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape6) }),
    { name: "x", required: true, scale: "band" },
    { name: "y", required: true, scale: "band" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroX },
    { type: MaybeZeroY },
    { type: MaybeZeroPadding }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/area.js
var shape7 = {
  area: Area,
  smooth: Smooth2,
  hvh: HVH2,
  vh: VH2,
  hv: HV2
};
var Area2 = () => {
  return (index2, scale4, value2, coordinate) => {
    var _a, _b;
    const { x: X, y: Y, y1: Y12, series: S } = value2;
    const { x: x2, y: y3 } = scale4;
    const series = S ? Array.from(group(index2, (i2) => S[i2]).values()) : [index2];
    const I = series.map((group2) => group2[0]).filter((i2) => i2 !== void 0);
    const xoffset = (((_a = x2 === null || x2 === void 0 ? void 0 : x2.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(x2)) || 0) / 2;
    const yoffset = (((_b = y3 === null || y3 === void 0 ? void 0 : y3.getBandWidth) === null || _b === void 0 ? void 0 : _b.call(y3)) || 0) / 2;
    const P = Array.from(series, (SI) => {
      const l2 = SI.length;
      const points = new Array(l2 * 2);
      for (let idx = 0; idx < SI.length; idx++) {
        const i2 = SI[idx];
        points[idx] = coordinate.map([+X[i2] + xoffset, +Y[i2] + yoffset]);
        points[l2 + idx] = coordinate.map([+X[i2] + xoffset, +Y12[i2] + yoffset]);
      }
      return points;
    });
    return [I, P, series];
  };
};
Area2.props = {
  defaultShape: "area",
  defaultLabelShape: "label",
  composite: false,
  shape: shape7,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape7) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "size" },
    { name: "series", scale: "band" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeSeries },
    { type: MaybeZeroY1 },
    { type: MaybeZeroPadding }
  ],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: {
    shareTooltip: true,
    seriesTooltip: true,
    crosshairs: true
  }
};

// node_modules/@antv/g2/esm/mark/link.js
var shape8 = {
  link: Link,
  arc: Arc,
  smooth: Smooth3,
  vhv: VHV
};
var Link2 = (options) => {
  return (index2, scale4, value2, coordinate) => {
    const { x: X, y: Y, x1: X12 = X, y1: Y12 = Y } = value2;
    const offset2 = createBandOffset(scale4, value2, options);
    const P = index2.map((i2) => [
      coordinate.map(offset2([+X[i2], +Y[i2]], i2)),
      coordinate.map(offset2([+X12[i2], +Y12[i2]], i2))
    ]);
    return [index2, P];
  };
};
Link2.props = {
  defaultShape: "link",
  defaultLabelShape: "label",
  composite: false,
  shape: shape8,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape8) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeIdentityY },
    { type: MaybeIdentityX }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/image.js
var shape9 = {
  image: Image3
};
var Image4 = (options) => {
  const { cartesian: cartesian3 } = options;
  if (cartesian3)
    return visualMark;
  return (index2, scale4, value2, coordinate) => {
    const { x: X, y: Y } = value2;
    const offset2 = createBandOffset(scale4, value2, options);
    const P = Array.from(index2, (i2) => {
      const p3 = [+X[i2], +Y[i2]];
      return [coordinate.map(offset2(p3, i2))];
    });
    return [index2, P];
  };
};
Image4.props = {
  defaultShape: "image",
  defaultLabelShape: "label",
  composite: false,
  shape: shape9,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape9) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "src", scale: "identity" },
    { name: "size" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeTuple },
    { type: MaybeVisualPosition }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/polygon.js
var shape10 = {
  polygon: Polygon2,
  ribbon: Ribbon
};
var Polygon3 = () => {
  return (index2, scale4, value2, coordinate) => {
    const Xn = Object.entries(value2).filter(([key]) => key.startsWith("x")).map(([, value3]) => value3);
    const Yn = Object.entries(value2).filter(([key]) => key.startsWith("y")).map(([, value3]) => value3);
    const P = index2.map((i2) => {
      const Pn = [];
      for (let j = 0; j < Xn.length; j++) {
        const x2 = Xn[j][i2];
        if (x2 === void 0)
          break;
        const y3 = Yn[j][i2];
        Pn.push(coordinate.map([+x2, +y3]));
      }
      return Pn;
    });
    return [index2, P];
  };
};
Polygon3.props = {
  defaultShape: "polygon",
  defaultLabelShape: "label",
  composite: false,
  shape: shape10,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape10) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/box.js
var shape11 = {
  box: Box,
  violin: Violin
};
var Box2 = () => {
  return (index2, scale4, value2, coordinate) => {
    const { x: X, y: Y, y1: Y12, y2: Y22, y3: Y3, y4: Y4, series: S } = value2;
    const xScale = scale4.x;
    const series = scale4.series;
    const P = Array.from(index2, (i2) => {
      const groupWidth = xScale.getBandWidth(xScale.invert(+X[i2]));
      const ratio = series ? series.getBandWidth(series.invert(+(S === null || S === void 0 ? void 0 : S[i2]))) : 1;
      const width = groupWidth * ratio;
      const offset2 = (+(S === null || S === void 0 ? void 0 : S[i2]) || 0) * groupWidth;
      const x2 = +X[i2] + offset2 + width / 2;
      const [low, q12, median3, q32, high] = [
        +Y[i2],
        +Y12[i2],
        +Y22[i2],
        +Y3[i2],
        +Y4[i2]
      ];
      const P13 = [
        [x2 - width / 2, high],
        [x2 + width / 2, high],
        [x2, high],
        [x2, q32],
        // idx = 3
        [x2 - width / 2, q32],
        [x2 + width / 2, q32],
        [x2 + width / 2, q12],
        [x2 - width / 2, q12],
        [x2 - width / 2, median3],
        // idx = 8
        [x2 + width / 2, median3],
        [x2, q12],
        // idx = 10
        [x2, low],
        [x2 - width / 2, low],
        [x2 + width / 2, low]
      ];
      return P13.map((d3) => coordinate.map(d3));
    });
    return [index2, P];
  };
};
Box2.props = {
  defaultShape: "box",
  defaultLabelShape: "label",
  composite: false,
  shape: shape11,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape11) }),
    { name: "x", scale: "band", required: true },
    { name: "y", required: true },
    { name: "series", scale: "band" }
  ],
  preInference: [...basePreInference(), { type: MaybeZeroX }],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: {
    shareTooltip: true
  }
};

// node_modules/@antv/g2/esm/mark/vector.js
var shape12 = {
  vector: Vector
};
var Vector2 = () => {
  return (index2, scale4, value2, coordinate) => {
    const { x: X, y: Y, size: S, rotate: R2 } = value2;
    const [width, height] = coordinate.getSize();
    const P = index2.map((i2) => {
      const angle2 = +R2[i2] / 180 * Math.PI;
      const s3 = +S[i2];
      const a4 = s3 / width;
      const b = s3 / height;
      const vx = a4 * Math.cos(angle2);
      const vy = -b * Math.sin(angle2);
      return [
        coordinate.map([+X[i2] - vx / 2, +Y[i2] - vy / 2]),
        coordinate.map([+X[i2] + vx / 2, +Y[i2] + vy / 2])
      ];
    });
    return [index2, P];
  };
};
Vector2.props = {
  defaultShape: "vector",
  defaultLabelShape: "label",
  composite: false,
  shape: shape12,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape12) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "rotate", required: true, scale: "identity" },
    { name: "size", required: true }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/lineY.js
var shape13 = {
  line: Line4
};
var LineY = (options) => {
  return (index2, scale4, value2, coordinate) => {
    const { y: Y } = value2;
    const offset2 = createBandOffset(scale4, value2, deep_mix_default({ style: { bandOffset: 0 } }, options));
    const P = Array.from(index2, (i2) => {
      const p1 = [0, Y[i2]];
      const p22 = [1, Y[i2]];
      return [p1, p22].map((d3) => coordinate.map(offset2(d3, i2)));
    });
    return [index2, P];
  };
};
LineY.props = {
  defaultShape: "line",
  defaultLabelShape: "label",
  composite: false,
  shape: shape13,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape13) }),
    { name: "y", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeTupleY }],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/lineX.js
var shape14 = {
  line: Line4
};
var LineX = (options) => {
  return (index2, scale4, value2, coordinate) => {
    const { x: X } = value2;
    const offset2 = createBandOffset(scale4, value2, deep_mix_default({ style: { bandOffset: 0 } }, options));
    const P = Array.from(index2, (i2) => {
      const p1 = [X[i2], 1];
      const p22 = [X[i2], 0];
      return [p1, p22].map((d3) => coordinate.map(offset2(d3, i2)));
    });
    return [index2, P];
  };
};
LineX.props = {
  defaultShape: "line",
  defaultLabelShape: "label",
  composite: false,
  shape: shape14,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape14) }),
    { name: "x", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeTupleX }],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/connector.js
var shape15 = {
  connector: Connector
};
var Connector2 = (...args) => {
  return Link2(...args);
};
Connector2.props = {
  defaultShape: "connector",
  defaultLabelShape: "label",
  composite: false,
  shape: shape15,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape15) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/range.js
function extend(channel, extended, value2, scale4) {
  if (extended)
    return () => [0, 1];
  const { [channel]: C, [`${channel}1`]: C1 } = value2;
  return (i2) => {
    var _a;
    const offset2 = ((_a = scale4.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(scale4, scale4.invert(+C1[i2]))) || 0;
    return [C[i2], C1[i2] + offset2];
  };
}
function AbstractRange(options = {}) {
  const { extendX = false, extendY = false } = options;
  return (index2, scale4, value2, coordinate) => {
    const x2 = extend("x", extendX, value2, scale4.x);
    const y3 = extend("y", extendY, value2, scale4.y);
    const P = Array.from(index2, (i2) => {
      const [x12, x22] = x2(i2);
      const [y12, y22] = y3(i2);
      const p1 = [x12, y12];
      const p22 = [x22, y12];
      const p3 = [x22, y22];
      const p4 = [x12, y22];
      return [p1, p22, p3, p4].map((d3) => coordinate.map(d3));
    });
    return [index2, P];
  };
}
var shape16 = { range: Rect2 };
var Range = () => {
  return AbstractRange();
};
Range.props = {
  defaultShape: "range",
  defaultLabelShape: "label",
  composite: false,
  shape: shape16,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape16) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/rangeX.js
var shape17 = {
  range: Rect2
};
var RangeX = () => {
  return AbstractRange({ extendY: true });
};
RangeX.props = {
  defaultShape: "range",
  defaultLabelShape: "label",
  composite: false,
  shape: shape17,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape17) }),
    { name: "x", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeDefaultX }],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/rangeY.js
var shape18 = {
  range: Rect2
};
var RangeY = () => {
  return AbstractRange({ extendX: true });
};
RangeY.props = {
  defaultShape: "range",
  defaultLabelShape: "label",
  composite: false,
  shape: shape18,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape18) }),
    { name: "y", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeDefaultY }],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/data/utils/d3-sankey/align.js
function targetDepth(d3) {
  return d3.target.depth;
}
function left(node) {
  return node.depth;
}
function right(node, n2) {
  return n2 - 1 - node.height;
}
function justify(node, n2) {
  return node.sourceLinks.length ? node.depth : n2 - 1;
}
function center(node) {
  return node.targetLinks.length ? node.depth : node.sourceLinks.length ? min(node.sourceLinks, targetDepth) - 1 : 0;
}

// node_modules/@antv/g2/esm/data/utils/d3-sankey/constant.js
function constant3(x2) {
  return function() {
    return x2;
  };
}

// node_modules/@antv/g2/esm/data/utils/d3-sankey/sankey.js
function ascendingSourceBreadth(a4, b) {
  return ascendingBreadth(a4.source, b.source) || a4.index - b.index;
}
function ascendingTargetBreadth(a4, b) {
  return ascendingBreadth(a4.target, b.target) || a4.index - b.index;
}
function ascendingBreadth(a4, b) {
  return a4.y0 - b.y0;
}
function value(d3) {
  return d3.value;
}
function defaultId(d3) {
  return d3.index;
}
function defaultNodes(graph) {
  return graph.nodes;
}
function defaultLinks(graph) {
  return graph.links;
}
function find(nodeById, id2) {
  const node = nodeById.get(id2);
  if (!node)
    throw new Error("missing: " + id2);
  return node;
}
function computeLinkBreadths({ nodes }) {
  for (const node of nodes) {
    let y05 = node.y0;
    let y12 = y05;
    for (const link3 of node.sourceLinks) {
      link3.y0 = y05 + link3.width / 2;
      y05 += link3.width;
    }
    for (const link3 of node.targetLinks) {
      link3.y1 = y12 + link3.width / 2;
      y12 += link3.width;
    }
  }
}
function Sankey() {
  let x05 = 0, y05 = 0, x12 = 1, y12 = 1;
  let dx = 24;
  let dy = 8, py;
  let id2 = defaultId;
  let align = justify;
  let depth;
  let sort2;
  let linkSort;
  let nodes = defaultNodes;
  let links = defaultLinks;
  let iterations2 = 6;
  function sankey(arg) {
    const graph = {
      nodes: nodes(arg),
      links: links(arg)
    };
    computeNodeLinks(graph);
    computeNodeValues(graph);
    computeNodeDepths(graph);
    computeNodeHeights(graph);
    computeNodeBreadths(graph);
    computeLinkBreadths(graph);
    return graph;
  }
  sankey.update = function(graph) {
    computeLinkBreadths(graph);
    return graph;
  };
  sankey.nodeId = function(_) {
    return arguments.length ? (id2 = typeof _ === "function" ? _ : constant3(_), sankey) : id2;
  };
  sankey.nodeAlign = function(_) {
    return arguments.length ? (align = typeof _ === "function" ? _ : constant3(_), sankey) : align;
  };
  sankey.nodeDepth = function(_) {
    return arguments.length ? (depth = typeof _ === "function" ? _ : _, sankey) : depth;
  };
  sankey.nodeSort = function(_) {
    return arguments.length ? (sort2 = _, sankey) : sort2;
  };
  sankey.nodeWidth = function(_) {
    return arguments.length ? (dx = +_, sankey) : dx;
  };
  sankey.nodePadding = function(_) {
    return arguments.length ? (dy = py = +_, sankey) : dy;
  };
  sankey.nodes = function(_) {
    return arguments.length ? (nodes = typeof _ === "function" ? _ : constant3(_), sankey) : nodes;
  };
  sankey.links = function(_) {
    return arguments.length ? (links = typeof _ === "function" ? _ : constant3(_), sankey) : links;
  };
  sankey.linkSort = function(_) {
    return arguments.length ? (linkSort = _, sankey) : linkSort;
  };
  sankey.size = function(_) {
    return arguments.length ? (x05 = y05 = 0, x12 = +_[0], y12 = +_[1], sankey) : [x12 - x05, y12 - y05];
  };
  sankey.extent = function(_) {
    return arguments.length ? (x05 = +_[0][0], x12 = +_[1][0], y05 = +_[0][1], y12 = +_[1][1], sankey) : [
      [x05, y05],
      [x12, y12]
    ];
  };
  sankey.iterations = function(_) {
    return arguments.length ? (iterations2 = +_, sankey) : iterations2;
  };
  function computeNodeLinks({ nodes: nodes2, links: links2 }) {
    nodes2.forEach((node, idx) => {
      node.index = idx;
      node.sourceLinks = [];
      node.targetLinks = [];
    });
    const nodeById = new Map(nodes2.map((d3) => [id2(d3), d3]));
    links2.forEach((link3, idx) => {
      link3.index = idx;
      let { source, target } = link3;
      if (typeof source !== "object")
        source = link3.source = find(nodeById, source);
      if (typeof target !== "object")
        target = link3.target = find(nodeById, target);
      source.sourceLinks.push(link3);
      target.targetLinks.push(link3);
    });
    if (linkSort != null) {
      for (const { sourceLinks, targetLinks } of nodes2) {
        sourceLinks.sort(linkSort);
        targetLinks.sort(linkSort);
      }
    }
  }
  function computeNodeValues({ nodes: nodes2 }) {
    for (const node of nodes2) {
      node.value = node.fixedValue === void 0 ? Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value)) : node.fixedValue;
    }
  }
  function computeNodeDepths({ nodes: nodes2 }) {
    const n2 = nodes2.length;
    let current = new Set(nodes2);
    let next = /* @__PURE__ */ new Set();
    let x2 = 0;
    while (current.size) {
      current.forEach((node) => {
        node.depth = x2;
        for (const { target } of node.sourceLinks) {
          next.add(target);
        }
      });
      if (++x2 > n2)
        throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
    if (depth) {
      const maxDepth2 = Math.max(max(nodes2, (d3) => d3.depth) + 1, 0);
      let node;
      for (let i2 = 0; i2 < nodes2.length; i2++) {
        node = nodes2[i2];
        node.depth = depth.call(null, node, maxDepth2);
      }
    }
  }
  function computeNodeHeights({ nodes: nodes2 }) {
    const n2 = nodes2.length;
    let current = new Set(nodes2);
    let next = /* @__PURE__ */ new Set();
    let x2 = 0;
    while (current.size) {
      current.forEach((node) => {
        node.height = x2;
        for (const { source } of node.targetLinks) {
          next.add(source);
        }
      });
      if (++x2 > n2)
        throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
  }
  function computeNodeLayers({ nodes: nodes2 }) {
    const x2 = Math.max(max(nodes2, (d3) => d3.depth) + 1, 0);
    const kx2 = (x12 - x05 - dx) / (x2 - 1);
    const columns = new Array(x2).fill(0).map(() => []);
    for (const node of nodes2) {
      const i2 = Math.max(0, Math.min(x2 - 1, Math.floor(align.call(null, node, x2))));
      node.layer = i2;
      node.x0 = x05 + i2 * kx2;
      node.x1 = node.x0 + dx;
      if (columns[i2])
        columns[i2].push(node);
      else
        columns[i2] = [node];
    }
    if (sort2)
      for (const column2 of columns) {
        column2.sort(sort2);
      }
    return columns;
  }
  function initializeNodeBreadths(columns) {
    const ky2 = min(columns, (c5) => (y12 - y05 - (c5.length - 1) * py) / sum(c5, value));
    for (const nodes2 of columns) {
      let y3 = y05;
      for (const node of nodes2) {
        node.y0 = y3;
        node.y1 = y3 + node.value * ky2;
        y3 = node.y1 + py;
        for (const link3 of node.sourceLinks) {
          link3.width = link3.value * ky2;
        }
      }
      y3 = (y12 - y3 + py) / (nodes2.length + 1);
      for (let i2 = 0; i2 < nodes2.length; ++i2) {
        const node = nodes2[i2];
        node.y0 += y3 * (i2 + 1);
        node.y1 += y3 * (i2 + 1);
      }
      reorderLinks(nodes2);
    }
  }
  function computeNodeBreadths(graph) {
    const columns = computeNodeLayers(graph);
    py = Math.min(dy, (y12 - y05) / (max(columns, (c5) => c5.length) - 1));
    initializeNodeBreadths(columns);
    for (let i2 = 0; i2 < iterations2; ++i2) {
      const alpha = Math.pow(0.99, i2);
      const beta = Math.max(1 - alpha, (i2 + 1) / iterations2);
      relaxRightToLeft(columns, alpha, beta);
      relaxLeftToRight(columns, alpha, beta);
    }
  }
  function relaxLeftToRight(columns, alpha, beta) {
    for (let i2 = 1, n2 = columns.length; i2 < n2; ++i2) {
      const column2 = columns[i2];
      for (const target of column2) {
        let y3 = 0;
        let w2 = 0;
        for (const { source, value: value2 } of target.targetLinks) {
          const v = value2 * (target.layer - source.layer);
          y3 += targetTop(source, target) * v;
          w2 += v;
        }
        if (!(w2 > 0))
          continue;
        const dy2 = (y3 / w2 - target.y0) * alpha;
        target.y0 += dy2;
        target.y1 += dy2;
        reorderNodeLinks(target);
      }
      if (sort2 === void 0)
        column2.sort(ascendingBreadth);
      if (column2.length)
        resolveCollisions(column2, beta);
    }
  }
  function relaxRightToLeft(columns, alpha, beta) {
    for (let n2 = columns.length, i2 = n2 - 2; i2 >= 0; --i2) {
      const column2 = columns[i2];
      for (const source of column2) {
        let y3 = 0;
        let w2 = 0;
        for (const { target, value: value2 } of source.sourceLinks) {
          const v = value2 * (target.layer - source.layer);
          y3 += sourceTop(source, target) * v;
          w2 += v;
        }
        if (!(w2 > 0))
          continue;
        const dy2 = (y3 / w2 - source.y0) * alpha;
        source.y0 += dy2;
        source.y1 += dy2;
        reorderNodeLinks(source);
      }
      if (sort2 === void 0)
        column2.sort(ascendingBreadth);
      if (column2.length)
        resolveCollisions(column2, beta);
    }
  }
  function resolveCollisions(nodes2, alpha) {
    const i2 = nodes2.length >> 1;
    const subject = nodes2[i2];
    resolveCollisionsBottomToTop(nodes2, subject.y0 - py, i2 - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, subject.y1 + py, i2 + 1, alpha);
    resolveCollisionsBottomToTop(nodes2, y12, nodes2.length - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, y05, 0, alpha);
  }
  function resolveCollisionsTopToBottom(nodes2, y3, i2, alpha) {
    for (; i2 < nodes2.length; ++i2) {
      const node = nodes2[i2];
      const dy2 = (y3 - node.y0) * alpha;
      if (dy2 > 1e-6)
        node.y0 += dy2, node.y1 += dy2;
      y3 = node.y1 + py;
    }
  }
  function resolveCollisionsBottomToTop(nodes2, y3, i2, alpha) {
    for (; i2 >= 0; --i2) {
      const node = nodes2[i2];
      const dy2 = (node.y1 - y3) * alpha;
      if (dy2 > 1e-6)
        node.y0 -= dy2, node.y1 -= dy2;
      y3 = node.y0 - py;
    }
  }
  function reorderNodeLinks({ sourceLinks, targetLinks }) {
    if (linkSort === void 0) {
      for (const { source: { sourceLinks: sourceLinks2 } } of targetLinks) {
        sourceLinks2.sort(ascendingTargetBreadth);
      }
      for (const { target: { targetLinks: targetLinks2 } } of sourceLinks) {
        targetLinks2.sort(ascendingSourceBreadth);
      }
    }
  }
  function reorderLinks(nodes2) {
    if (linkSort === void 0) {
      for (const { sourceLinks, targetLinks } of nodes2) {
        sourceLinks.sort(ascendingTargetBreadth);
        targetLinks.sort(ascendingSourceBreadth);
      }
    }
  }
  function targetTop(source, target) {
    let y3 = source.y0 - (source.sourceLinks.length - 1) * py / 2;
    for (const { target: node, width } of source.sourceLinks) {
      if (node === target)
        break;
      y3 += width + py;
    }
    for (const { source: node, width } of target.targetLinks) {
      if (node === source)
        break;
      y3 -= width;
    }
    return y3;
  }
  function sourceTop(source, target) {
    let y3 = target.y0 - (target.targetLinks.length - 1) * py / 2;
    for (const { source: node, width } of target.targetLinks) {
      if (node === source)
        break;
      y3 += width + py;
    }
    for (const { target: node, width } of source.sourceLinks) {
      if (node === target)
        break;
      y3 -= width;
    }
    return y3;
  }
  return sankey;
}

// node_modules/@antv/g2/esm/data/sankey.js
var DEFAULT_OPTIONS = {
  nodeAlign: "justify",
  nodeWidth: 8e-3,
  nodePadding: 0.03,
  nodes: (graph) => graph.nodes,
  links: (graph) => graph.links,
  nodeSort: void 0,
  linkSort: void 0,
  iterations: 6
};
var ALIGN_METHOD = {
  left,
  right,
  center,
  justify
};
function getNodeAlignFunction(nodeAlign) {
  const type = typeof nodeAlign;
  if (type === "string")
    return ALIGN_METHOD[nodeAlign] || justify;
  if (type === "function")
    return nodeAlign;
  return justify;
}
var Sankey2 = (options) => {
  return (data) => {
    const { nodeId, nodeSort, nodeAlign, nodeWidth, nodePadding, nodeDepth, nodes: nodeNodes, links: nodeLinks, linkSort, iterations: iterations2 } = Object.assign({}, DEFAULT_OPTIONS, options);
    const sankeyProcessor = Sankey().nodeSort(nodeSort).linkSort(linkSort).links(nodeLinks).nodes(nodeNodes).nodeWidth(nodeWidth).nodePadding(nodePadding).nodeDepth(nodeDepth).nodeAlign(getNodeAlignFunction(nodeAlign)).iterations(iterations2).extent([
      [0, 0],
      [1, 1]
    ]);
    if (typeof nodeId === "function") {
      sankeyProcessor.nodeId(nodeId);
    }
    const layoutData = sankeyProcessor(data);
    const { nodes: N, links: L } = layoutData;
    const nodes = N.map((node) => {
      const { x0: x05, x1: x12, y0: y05, y1: y12 } = node;
      return Object.assign(Object.assign({}, node), { x: [x05, x12, x12, x05], y: [y05, y05, y12, y12] });
    });
    const links = L.map((edge) => {
      const { source, target } = edge;
      const sx = source.x1;
      const tx = target.x0;
      const offset2 = edge.width / 2;
      return Object.assign(Object.assign({}, edge), { x: [sx, sx, tx, tx], y: [
        edge.y0 + offset2,
        edge.y0 - offset2,
        edge.y1 + offset2,
        edge.y1 - offset2
      ] });
    });
    return { nodes, links };
  };
};
Sankey2.props = {};

// node_modules/@antv/g2/esm/utils/mark.js
function subTooltip(tooltip2, name2, defaults4 = {}, main = false) {
  if (isUnset(tooltip2))
    return tooltip2;
  if (Array.isArray(tooltip2) && main)
    return tooltip2;
  const sub2 = subObject(tooltip2, name2);
  return deep_mix_default(defaults4, sub2);
}
function maybeTooltip(tooltip2, defaults4 = {}) {
  if (isUnset(tooltip2))
    return tooltip2;
  if (Array.isArray(tooltip2))
    return tooltip2;
  if (!isFullTooltip(tooltip2))
    return tooltip2;
  return deep_mix_default(defaults4, tooltip2);
}
function isFullTooltip(tooltip2) {
  if (Object.keys(tooltip2).length === 0)
    return true;
  const { title, items } = tooltip2;
  return title !== void 0 || items !== void 0;
}
function maybeAnimation(animate, sub2) {
  return typeof animate === "object" ? subObject(animate, sub2) : animate;
}

// node_modules/@antv/g2/esm/mark/sankey.js
var __rest43 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var DEFAULT_LAYOUT_OPTIONS = {
  nodeId: (d3) => d3.key,
  nodeWidth: 0.02,
  nodePadding: 0.02
};
var DEFAULT_NODE_OPTIONS = {
  type: "polygon",
  axis: false,
  legend: false,
  encode: {
    shape: "polygon",
    x: "x",
    y: "y"
  },
  scale: {
    x: { type: "identity" },
    y: { type: "identity" }
  },
  style: {
    stroke: "#000"
  }
};
var DEFAULT_LINK_OPTIONS = {
  type: "polygon",
  axis: false,
  legend: false,
  encode: {
    shape: "ribbon",
    x: "x",
    y: "y"
  },
  style: {
    fillOpacity: 0.5,
    stroke: void 0
  }
};
var DEFAULT_LABEL_OPTIONS = {
  textAlign: (d3) => d3.x[0] < 0.5 ? "start" : "end",
  position: (d3) => d3.x[0] < 0.5 ? "right" : "left",
  fontSize: 10
};
var Sankey3 = (options) => {
  const { data, encode = {}, scale: scale4, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate = {}, tooltip: tooltip2 = {}, interaction, state = {}, viewStyle = {} } = options;
  const { links, nodes } = initializeData(data, encode);
  if (!links || links.length === 0) {
    return [
      // Empty node mark
      deep_mix_default({}, DEFAULT_NODE_OPTIONS, {
        data: [],
        encode: {},
        scale: scale4,
        style: subObject(style, "node"),
        viewStyle,
        labels: [],
        tooltip: false,
        animate: false,
        axis: false,
        interaction,
        state: {}
      }),
      // Empty link mark
      deep_mix_default({}, DEFAULT_LINK_OPTIONS, {
        data: [],
        encode: {},
        labels: [],
        style: subObject(style, "link"),
        tooltip: false,
        animate: false,
        interaction,
        state: {}
      })
    ];
  }
  const nodeEncode = subObject(encode, "node");
  const linkEncode = subObject(encode, "link");
  const { key: nodeKey = (d3) => d3.key, color = nodeKey } = nodeEncode;
  const { links: linkData, nodes: nodeData } = Sankey2(Object.assign(Object.assign(Object.assign({}, DEFAULT_LAYOUT_OPTIONS), { nodeId: field(nodeKey) }), layout))({ links, nodes });
  const _a = subObject(style, "label"), { text = nodeKey, spacing = 5 } = _a, labelStyle = __rest43(_a, ["text", "spacing"]);
  const key1 = field(nodeKey);
  const nodeTooltip = subTooltip(tooltip2, "node", {
    title: key1,
    items: [{ field: "value" }]
  }, true);
  const linkTooltip = subTooltip(tooltip2, "link", {
    title: "",
    items: [
      (d3) => ({ name: "source", value: key1(d3.source) }),
      (d3) => ({ name: "target", value: key1(d3.target) })
    ]
  });
  const [nodeState, linkState] = Object.entries(state).reduce((acc, [stateName, styleObj]) => {
    const commonState = omitPrefixObject(styleObj, "node", "link");
    const nodeState2 = subObject(styleObj, "node");
    acc[0][stateName] = Object.assign(Object.assign({}, commonState), nodeState2);
    const linkState2 = subObject(styleObj, "link");
    acc[1][stateName] = Object.assign(Object.assign({}, commonState), linkState2);
    return acc;
  }, [{}, {}]);
  return [
    deep_mix_default({}, DEFAULT_NODE_OPTIONS, {
      data: nodeData,
      encode: Object.assign(Object.assign({}, nodeEncode), { color }),
      scale: scale4,
      style: subObject(style, "node"),
      viewStyle,
      labels: [
        Object.assign(Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS), { text, dx: (d3) => d3.x[0] < 0.5 ? spacing : -spacing }), labelStyle),
        ...nodeLabels
      ],
      tooltip: nodeTooltip,
      animate: maybeAnimation(animate, "node"),
      axis: false,
      interaction,
      state: nodeState
    }),
    deep_mix_default({}, DEFAULT_LINK_OPTIONS, {
      data: linkData,
      encode: linkEncode,
      labels: linkLabels,
      style: Object.assign({ fill: linkEncode.color ? void 0 : "#aaa", lineWidth: 0 }, subObject(style, "link")),
      tooltip: linkTooltip,
      animate: maybeAnimation(animate, "link"),
      interaction,
      state: linkState
    })
  ];
};
Sankey3.props = {};

// node_modules/@antv/g2/esm/data/utils/arc/sort.js
var sort_exports = {};
__export(sort_exports, {
  frequency: () => frequency,
  id: () => id,
  name: () => name,
  weight: () => weight
});
function weight(a4, b) {
  return b.value - a4.value;
}
function frequency(a4, b) {
  return b.frequency - a4.frequency;
}
function id(a4, b) {
  return `${a4.id}`.localeCompare(`${b.id}`);
}
function name(a4, b) {
  return `${a4.name}`.localeCompare(`${b.name}`);
}

// node_modules/@antv/g2/esm/data/utils/arc/arc.js
var DEFAULT_OPTIONS2 = {
  y: 0,
  thickness: 0.05,
  weight: false,
  marginRatio: 0.1,
  id: (node) => node.id,
  source: (edge) => edge.source,
  target: (edge) => edge.target,
  sourceWeight: (edge) => edge.value || 1,
  targetWeight: (edge) => edge.value || 1,
  sortBy: null
};
function Arc2(options) {
  const { y: y3, thickness, weight: weight2, marginRatio, id: id2, source, target, sourceWeight, targetWeight, sortBy: sortBy2 } = Object.assign(Object.assign({}, DEFAULT_OPTIONS2), options);
  function arc(data) {
    const nodes = data.nodes.map((n2) => Object.assign({}, n2));
    const edges = data.edges.map((n2) => Object.assign({}, n2));
    preprocess(nodes, edges);
    sortNodes(nodes, edges);
    layoutNodes(nodes, edges);
    layoutEdges(nodes, edges);
    return { nodes, edges };
  }
  function preprocess(nodes, edges) {
    edges.forEach((edge) => {
      edge.source = source(edge);
      edge.target = target(edge);
      edge.sourceWeight = sourceWeight(edge);
      edge.targetWeight = targetWeight(edge);
    });
    const edgesBySource = group(edges, (e3) => e3.source);
    const edgesByTarget = group(edges, (e3) => e3.target);
    nodes.forEach((node) => {
      node.id = id2(node);
      const sources = edgesBySource.has(node.id) ? edgesBySource.get(node.id) : [];
      const targets = edgesByTarget.has(node.id) ? edgesByTarget.get(node.id) : [];
      node.frequency = sources.length + targets.length;
      node.value = sum(sources, (d3) => d3.sourceWeight) + sum(targets, (d3) => d3.targetWeight);
    });
    return { nodes, edges };
  }
  function sortNodes(nodes, edges) {
    const method = typeof sortBy2 === "function" ? sortBy2 : sort_exports[sortBy2];
    if (method) {
      nodes.sort(method);
    }
  }
  function layoutNodes(nodes, edges) {
    const size4 = nodes.length;
    if (!size4) {
      throw error("Invalid nodes: it's empty!");
    }
    if (!weight2) {
      const deltaX = 1 / size4;
      nodes.forEach((node, i2) => {
        node.x = (i2 + 0.5) * deltaX;
        node.y = y3;
      });
      return { nodes, edges };
    }
    const margin = marginRatio / (2 * size4);
    const total = nodes.reduce((prev, node) => prev += node.value, 0);
    nodes.reduce((deltaX, node) => {
      node.weight = node.value / total;
      node.width = node.weight * (1 - marginRatio);
      node.height = thickness;
      const minX = margin + deltaX;
      const maxX = minX + node.width;
      const minY = y3 - thickness / 2;
      const maxY2 = minY + thickness;
      node.x = [minX, maxX, maxX, minX];
      node.y = [minY, minY, maxY2, maxY2];
      return deltaX + node.width + 2 * margin;
    }, 0);
    return {
      nodes,
      edges
    };
  }
  function layoutEdges(nodes, edges) {
    const nodesMap = new Map(nodes.map((d3) => [d3.id, d3]));
    if (!weight2) {
      edges.forEach((edge) => {
        const sourceId = source(edge);
        const targetId = target(edge);
        const sourceNode = nodesMap.get(sourceId);
        const targetNode = nodesMap.get(targetId);
        if (sourceNode && targetNode) {
          edge.x = [sourceNode.x, targetNode.x];
          edge.y = [sourceNode.y, targetNode.y];
        }
      });
      return { nodes, edges };
    }
    edges.forEach((edge) => {
      edge.x = [0, 0, 0, 0];
      edge.y = [y3, y3, y3, y3];
    });
    const edgesBySource = group(edges, (e3) => e3.source);
    const edgesByTarget = group(edges, (e3) => e3.target);
    nodes.forEach((node) => {
      const { edges: edges2, width, x: x2, y: y4, value: value2, id: id3 } = node;
      const sourceEdges = edgesBySource.get(id3) || [];
      const targetEdges = edgesByTarget.get(id3) || [];
      let offset2 = 0;
      sourceEdges.map((edge) => {
        const w2 = edge.sourceWeight / value2 * width;
        edge.x[0] = x2[0] + offset2;
        edge.x[1] = x2[0] + offset2 + w2;
        offset2 += w2;
      });
      targetEdges.forEach((edge) => {
        const w2 = edge.targetWeight / value2 * width;
        edge.x[3] = x2[0] + offset2;
        edge.x[2] = x2[0] + offset2 + w2;
        offset2 += w2;
      });
    });
  }
  return arc;
}

// node_modules/@antv/g2/esm/data/arc.js
var Arc3 = (options) => {
  return (data) => {
    return Arc2(options)(data);
  };
};
Arc3.props = {};

// node_modules/@antv/g2/esm/mark/chord.js
var __rest44 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var DEFAULT_LAYOUT_OPTIONS2 = {
  y: 0,
  thickness: 0.05,
  // width of the node, (0, 1)
  marginRatio: 0.1,
  // margin ratio, [0, 1)
  id: (node) => node.key,
  source: (edge) => edge.source,
  target: (edge) => edge.target,
  sourceWeight: (edge) => edge.value || 1,
  targetWeight: (edge) => edge.value || 1,
  sortBy: null
  // optional, id | weight | frequency | {function}
};
var DEFAULT_NODE_OPTIONS2 = {
  type: "polygon",
  axis: false,
  legend: false,
  encode: {
    shape: "polygon",
    x: "x",
    y: "y"
  },
  scale: {
    x: { type: "identity" },
    y: { type: "identity" }
  },
  style: {
    opacity: 1,
    fillOpacity: 1,
    lineWidth: 1
  }
};
var DEFAULT_LINK_OPTIONS2 = {
  type: "polygon",
  axis: false,
  legend: false,
  encode: {
    shape: "ribbon",
    x: "x",
    y: "y"
  },
  style: {
    opacity: 0.5,
    lineWidth: 1
  }
};
var DEFAULT_LABEL_OPTIONS2 = {
  position: "outside",
  fontSize: 10
};
var Chord = (options, context) => {
  const { data, encode = {}, scale: scale4, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate = {}, tooltip: tooltip2 = {} } = options;
  const { nodes, links } = initializeData(data, encode);
  const nodeEncode = subObject(encode, "node");
  const linkEncode = subObject(encode, "link");
  const { key: nodeKey = (d3) => d3.key, color = nodeKey } = nodeEncode;
  const { linkEncodeColor = (d3) => d3.source } = linkEncode;
  const { nodeWidthRatio = DEFAULT_LAYOUT_OPTIONS2.thickness, nodePaddingRatio = DEFAULT_LAYOUT_OPTIONS2.marginRatio } = layout, restLayout = __rest44(layout, ["nodeWidthRatio", "nodePaddingRatio"]);
  const { nodes: nodeData, edges: linkData } = Arc3(Object.assign(Object.assign(Object.assign(Object.assign({}, DEFAULT_LAYOUT_OPTIONS2), { id: field(nodeKey), thickness: nodeWidthRatio, marginRatio: nodePaddingRatio }), restLayout), { weight: true }))({ nodes, edges: links });
  const _a = subObject(style, "label"), { text = nodeKey } = _a, labelStyle = __rest44(_a, ["text"]);
  const nodeTooltip = subTooltip(tooltip2, "node", {
    title: "",
    items: [(d3) => ({ name: d3.key, value: d3.value })]
  }, true);
  const linkTooltip = subTooltip(tooltip2, "link", {
    title: "",
    items: [(d3) => ({ name: `${d3.source} -> ${d3.target}`, value: d3.value })]
  });
  const { height, width } = context;
  const minimumLen = Math.min(height, width);
  return [
    deep_mix_default({}, DEFAULT_LINK_OPTIONS2, {
      data: linkData,
      encode: Object.assign(Object.assign({}, linkEncode), { color: linkEncodeColor }),
      labels: linkLabels,
      style: Object.assign({ fill: linkEncodeColor ? void 0 : "#aaa" }, subObject(style, "link")),
      tooltip: linkTooltip,
      animate: maybeAnimation(animate, "link")
    }),
    deep_mix_default({}, DEFAULT_NODE_OPTIONS2, {
      data: nodeData,
      encode: Object.assign(Object.assign({}, nodeEncode), { color }),
      scale: scale4,
      style: subObject(style, "node"),
      coordinate: {
        type: "polar",
        // Leave enough rendering space for the label.
        outerRadius: (minimumLen - 20) / minimumLen,
        startAngle: -Math.PI * 2,
        endAngle: 0
      },
      labels: [
        Object.assign(Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS2), { text }), labelStyle),
        ...nodeLabels
      ],
      tooltip: nodeTooltip,
      animate: maybeAnimation(animate, "node"),
      axis: false
    })
  ];
};
Chord.props = {};

// node_modules/@antv/g2/esm/mark/path.js
var shape19 = {
  path: Path3,
  hollow: Hollow2
};
var Path4 = (options) => {
  return (index2, scale4, value2, coordinate) => {
    return [index2, index2.map(() => [[0, 0]])];
  };
};
Path4.props = {
  defaultShape: "path",
  defaultLabelShape: "label",
  shape: shape19,
  composite: false,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape19) }),
    { name: "d", scale: "identity" }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference()]
};

// node_modules/d3-hierarchy/src/cluster.js
function defaultSeparation(a4, b) {
  return a4.parent === b.parent ? 1 : 2;
}
function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}
function meanXReduce(x2, c5) {
  return x2 + c5.x;
}
function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}
function maxYReduce(y3, c5) {
  return Math.max(y3, c5.y);
}
function leafLeft(node) {
  var children;
  while (children = node.children) node = children[0];
  return node;
}
function leafRight(node) {
  var children;
  while (children = node.children) node = children[children.length - 1];
  return node;
}
function cluster_default() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
  function cluster(root) {
    var previousNode, x2 = 0;
    root.eachAfter(function(node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x2 += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left2 = leafLeft(root), right2 = leafRight(root), x05 = left2.x - separation(left2, right2) / 2, x12 = right2.x + separation(right2, left2) / 2;
    return root.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x05) / (x12 - x05) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }
  cluster.separation = function(x2) {
    return arguments.length ? (separation = x2, cluster) : separation;
  };
  cluster.size = function(x2) {
    return arguments.length ? (nodeSize = false, dx = +x2[0], dy = +x2[1], cluster) : nodeSize ? null : [dx, dy];
  };
  cluster.nodeSize = function(x2) {
    return arguments.length ? (nodeSize = true, dx = +x2[0], dy = +x2[1], cluster) : nodeSize ? [dx, dy] : null;
  };
  return cluster;
}

// node_modules/d3-hierarchy/src/hierarchy/count.js
function count3(node) {
  var sum4 = 0, children = node.children, i2 = children && children.length;
  if (!i2) sum4 = 1;
  else while (--i2 >= 0) sum4 += children[i2].value;
  node.value = sum4;
}
function count_default() {
  return this.eachAfter(count3);
}

// node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default(callback, that) {
  let index2 = -1;
  for (const node of this) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
  var node = this, nodes = [node], children, i2, index2 = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index2, this);
    if (children = node.children) {
      for (i2 = children.length - 1; i2 >= 0; --i2) {
        nodes.push(children[i2]);
      }
    }
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
  var node = this, nodes = [node], next = [], children, i2, n2, index2 = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children = node.children) {
      for (i2 = 0, n2 = children.length; i2 < n2; ++i2) {
        nodes.push(children[i2]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default2(callback, that) {
  let index2 = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index2, this)) {
      return node;
    }
  }
}

// node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default(value2) {
  return this.eachAfter(function(node) {
    var sum4 = +value2(node.data) || 0, children = node.children, i2 = children && children.length;
    while (--i2 >= 0) sum4 += children[i2].value;
    node.value = sum4;
  });
}

// node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

// node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default(end) {
  var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k2 = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k2, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a4, b) {
  if (a4 === b) return a4;
  var aNodes = a4.ancestors(), bNodes = b.ancestors(), c5 = null;
  a4 = aNodes.pop();
  b = bNodes.pop();
  while (a4 === b) {
    c5 = a4;
    a4 = aNodes.pop();
    b = bNodes.pop();
  }
  return c5;
}

// node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

// node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  return Array.from(this);
}

// node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

// node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}

// node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default() {
  var node = this, current, next = [node], children, i2, n2;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children = node.children) {
        for (i2 = 0, n2 = children.length; i2 < n2; ++i2) {
          next.push(children[i2]);
        }
      }
    }
  } while (next.length);
}

// node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data, children) {
  if (data instanceof Map) {
    data = [void 0, data];
    if (children === void 0) children = mapChildren;
  } else if (children === void 0) {
    children = objectChildren;
  }
  var root = new Node(data), node, nodes = [root], child, childs, i2, n2;
  while (node = nodes.pop()) {
    if ((childs = children(node.data)) && (n2 = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i2 = n2 - 1; i2 >= 0; --i2) {
        nodes.push(child = childs[i2] = new Node(childs[i2]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d3) {
  return d3.children;
}
function mapChildren(d3) {
  return Array.isArray(d3) ? d3[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0) node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: count_default,
  each: each_default,
  eachAfter: eachAfter_default,
  eachBefore: eachBefore_default,
  find: find_default2,
  sum: sum_default,
  sort: sort_default,
  path: path_default,
  ancestors: ancestors_default,
  descendants: descendants_default,
  leaves: leaves_default,
  links: links_default,
  copy: node_copy,
  [Symbol.iterator]: iterator_default
};

// node_modules/d3-hierarchy/src/accessors.js
function optional(f2) {
  return f2 == null ? null : required(f2);
}
function required(f2) {
  if (typeof f2 !== "function") throw new Error();
  return f2;
}

// node_modules/d3-hierarchy/src/constant.js
function constantZero() {
  return 0;
}
function constant_default2(x2) {
  return function() {
    return x2;
  };
}

// node_modules/d3-hierarchy/src/lcg.js
var a2 = 1664525;
var c = 1013904223;
var m = 4294967296;
function lcg_default() {
  let s3 = 1;
  return () => (s3 = (a2 * s3 + c) % m) / m;
}

// node_modules/d3-hierarchy/src/array.js
function array_default2(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}
function shuffle(array2, random) {
  let m2 = array2.length, t, i2;
  while (m2) {
    i2 = random() * m2-- | 0;
    t = array2[m2];
    array2[m2] = array2[i2];
    array2[i2] = t;
  }
  return array2;
}

// node_modules/d3-hierarchy/src/pack/enclose.js
function packEncloseRandom(circles, random) {
  var i2 = 0, n2 = (circles = shuffle(Array.from(circles), random)).length, B = [], p3, e3;
  while (i2 < n2) {
    p3 = circles[i2];
    if (e3 && enclosesWeak(e3, p3)) ++i2;
    else e3 = encloseBasis(B = extendBasis(B, p3)), i2 = 0;
  }
  return e3;
}
function extendBasis(B, p3) {
  var i2, j;
  if (enclosesWeakAll(p3, B)) return [p3];
  for (i2 = 0; i2 < B.length; ++i2) {
    if (enclosesNot(p3, B[i2]) && enclosesWeakAll(encloseBasis2(B[i2], p3), B)) {
      return [B[i2], p3];
    }
  }
  for (i2 = 0; i2 < B.length - 1; ++i2) {
    for (j = i2 + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i2], B[j]), p3) && enclosesNot(encloseBasis2(B[i2], p3), B[j]) && enclosesNot(encloseBasis2(B[j], p3), B[i2]) && enclosesWeakAll(encloseBasis3(B[i2], B[j], p3), B)) {
        return [B[i2], B[j], p3];
      }
    }
  }
  throw new Error();
}
function enclosesNot(a4, b) {
  var dr = a4.r - b.r, dx = b.x - a4.x, dy = b.y - a4.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a4, b) {
  var dr = a4.r - b.r + Math.max(a4.r, b.r, 1) * 1e-9, dx = b.x - a4.x, dy = b.y - a4.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a4, B) {
  for (var i2 = 0; i2 < B.length; ++i2) {
    if (!enclosesWeak(a4, B[i2])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B) {
  switch (B.length) {
    case 1:
      return encloseBasis1(B[0]);
    case 2:
      return encloseBasis2(B[0], B[1]);
    case 3:
      return encloseBasis3(B[0], B[1], B[2]);
  }
}
function encloseBasis1(a4) {
  return {
    x: a4.x,
    y: a4.y,
    r: a4.r
  };
}
function encloseBasis2(a4, b) {
  var x12 = a4.x, y12 = a4.y, r1 = a4.r, x2 = b.x, y22 = b.y, r2 = b.r, x21 = x2 - x12, y21 = y22 - y12, r21 = r2 - r1, l2 = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x12 + x2 + x21 / l2 * r21) / 2,
    y: (y12 + y22 + y21 / l2 * r21) / 2,
    r: (l2 + r1 + r2) / 2
  };
}
function encloseBasis3(a4, b, c5) {
  var x12 = a4.x, y12 = a4.y, r1 = a4.r, x2 = b.x, y22 = b.y, r2 = b.r, x3 = c5.x, y3 = c5.y, r3 = c5.r, a22 = x12 - x2, a32 = x12 - x3, b2 = y12 - y22, b3 = y12 - y3, c22 = r2 - r1, c32 = r3 - r1, d1 = x12 * x12 + y12 * y12 - r1 * r1, d22 = d1 - x2 * x2 - y22 * y22 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a32 * b2 - a22 * b3, xa = (b2 * d3 - b3 * d22) / (ab * 2) - x12, xb = (b3 * c22 - b2 * c32) / ab, ya = (a32 * d22 - a22 * d3) / (ab * 2) - y12, yb = (a22 * c32 - a32 * c22) / ab, A5 = xb * xb + yb * yb - 1, B = 2 * (r1 + xa * xb + ya * yb), C = xa * xa + ya * ya - r1 * r1, r4 = -(Math.abs(A5) > 1e-6 ? (B + Math.sqrt(B * B - 4 * A5 * C)) / (2 * A5) : C / B);
  return {
    x: x12 + xa + xb * r4,
    y: y12 + ya + yb * r4,
    r: r4
  };
}

// node_modules/d3-hierarchy/src/pack/siblings.js
function place(b, a4, c5) {
  var dx = b.x - a4.x, x2, a22, dy = b.y - a4.y, y3, b2, d22 = dx * dx + dy * dy;
  if (d22) {
    a22 = a4.r + c5.r, a22 *= a22;
    b2 = b.r + c5.r, b2 *= b2;
    if (a22 > b2) {
      x2 = (d22 + b2 - a22) / (2 * d22);
      y3 = Math.sqrt(Math.max(0, b2 / d22 - x2 * x2));
      c5.x = b.x - x2 * dx - y3 * dy;
      c5.y = b.y - x2 * dy + y3 * dx;
    } else {
      x2 = (d22 + a22 - b2) / (2 * d22);
      y3 = Math.sqrt(Math.max(0, a22 / d22 - x2 * x2));
      c5.x = a4.x + x2 * dx - y3 * dy;
      c5.y = a4.y + x2 * dy + y3 * dx;
    }
  } else {
    c5.x = a4.x + c5.r;
    c5.y = a4.y;
  }
}
function intersects(a4, b) {
  var dr = a4.r + b.r - 1e-6, dx = b.x - a4.x, dy = b.y - a4.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
  var a4 = node._, b = node.next._, ab = a4.r + b.r, dx = (a4.x * b.r + b.x * a4.r) / ab, dy = (a4.y * b.r + b.y * a4.r) / ab;
  return dx * dx + dy * dy;
}
function Node2(circle2) {
  this._ = circle2;
  this.next = null;
  this.previous = null;
}
function packSiblingsRandom(circles, random) {
  if (!(n2 = (circles = array_default2(circles)).length)) return 0;
  var a4, b, c5, n2, aa, ca, i2, j, k2, sj, sk;
  a4 = circles[0], a4.x = 0, a4.y = 0;
  if (!(n2 > 1)) return a4.r;
  b = circles[1], a4.x = -b.r, b.x = a4.r, b.y = 0;
  if (!(n2 > 2)) return a4.r + b.r;
  place(b, a4, c5 = circles[2]);
  a4 = new Node2(a4), b = new Node2(b), c5 = new Node2(c5);
  a4.next = c5.previous = b;
  b.next = a4.previous = c5;
  c5.next = b.previous = a4;
  pack: for (i2 = 3; i2 < n2; ++i2) {
    place(a4._, b._, c5 = circles[i2]), c5 = new Node2(c5);
    j = b.next, k2 = a4.previous, sj = b._.r, sk = a4._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c5._)) {
          b = j, a4.next = b, b.previous = a4, --i2;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k2._, c5._)) {
          a4 = k2, a4.next = b, b.previous = a4, --i2;
          continue pack;
        }
        sk += k2._.r, k2 = k2.previous;
      }
    } while (j !== k2.next);
    c5.previous = a4, c5.next = b, a4.next = b.previous = b = c5;
    aa = score(a4);
    while ((c5 = c5.next) !== b) {
      if ((ca = score(c5)) < aa) {
        a4 = c5, aa = ca;
      }
    }
    b = a4.next;
  }
  a4 = [b._], c5 = b;
  while ((c5 = c5.next) !== b) a4.push(c5._);
  c5 = packEncloseRandom(a4, random);
  for (i2 = 0; i2 < n2; ++i2) a4 = circles[i2], a4.x -= c5.x, a4.y -= c5.y;
  return c5.r;
}

// node_modules/d3-hierarchy/src/pack/index.js
function defaultRadius(d3) {
  return Math.sqrt(d3.value);
}
function pack_default() {
  var radius = null, dx = 1, dy = 1, padding = constantZero;
  function pack3(root) {
    const random = lcg_default();
    root.x = dx / 2, root.y = dy / 2;
    if (radius) {
      root.eachBefore(radiusLeaf(radius)).eachAfter(packChildrenRandom(padding, 0.5, random)).eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildrenRandom(constantZero, 1, random)).eachAfter(packChildrenRandom(padding, root.r / Math.min(dx, dy), random)).eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }
  pack3.radius = function(x2) {
    return arguments.length ? (radius = optional(x2), pack3) : radius;
  };
  pack3.size = function(x2) {
    return arguments.length ? (dx = +x2[0], dy = +x2[1], pack3) : [dx, dy];
  };
  pack3.padding = function(x2) {
    return arguments.length ? (padding = typeof x2 === "function" ? x2 : constant_default2(+x2), pack3) : padding;
  };
  return pack3;
}
function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}
function packChildrenRandom(padding, k2, random) {
  return function(node) {
    if (children = node.children) {
      var children, i2, n2 = children.length, r2 = padding(node) * k2 || 0, e3;
      if (r2) for (i2 = 0; i2 < n2; ++i2) children[i2].r += r2;
      e3 = packSiblingsRandom(children, random);
      if (r2) for (i2 = 0; i2 < n2; ++i2) children[i2].r -= r2;
      node.r = e3 + r2;
    }
  };
}
function translateChild(k2) {
  return function(node) {
    var parent = node.parent;
    node.r *= k2;
    if (parent) {
      node.x = parent.x + k2 * node.x;
      node.y = parent.y + k2 * node.y;
    }
  };
}

// node_modules/d3-hierarchy/src/treemap/round.js
function round_default(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

// node_modules/d3-hierarchy/src/treemap/dice.js
function dice_default(parent, x05, y05, x12, y12) {
  var nodes = parent.children, node, i2 = -1, n2 = nodes.length, k2 = parent.value && (x12 - x05) / parent.value;
  while (++i2 < n2) {
    node = nodes[i2], node.y0 = y05, node.y1 = y12;
    node.x0 = x05, node.x1 = x05 += node.value * k2;
  }
}

// node_modules/d3-hierarchy/src/partition.js
function partition_default() {
  var dx = 1, dy = 1, padding = 0, round2 = false;
  function partition2(root) {
    var n2 = root.height + 1;
    root.x0 = root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n2;
    root.eachBefore(positionNode(dy, n2));
    if (round2) root.eachBefore(round_default);
    return root;
  }
  function positionNode(dy2, n2) {
    return function(node) {
      if (node.children) {
        dice_default(node, node.x0, dy2 * (node.depth + 1) / n2, node.x1, dy2 * (node.depth + 2) / n2);
      }
      var x05 = node.x0, y05 = node.y0, x12 = node.x1 - padding, y12 = node.y1 - padding;
      if (x12 < x05) x05 = x12 = (x05 + x12) / 2;
      if (y12 < y05) y05 = y12 = (y05 + y12) / 2;
      node.x0 = x05;
      node.y0 = y05;
      node.x1 = x12;
      node.y1 = y12;
    };
  }
  partition2.round = function(x2) {
    return arguments.length ? (round2 = !!x2, partition2) : round2;
  };
  partition2.size = function(x2) {
    return arguments.length ? (dx = +x2[0], dy = +x2[1], partition2) : [dx, dy];
  };
  partition2.padding = function(x2) {
    return arguments.length ? (padding = +x2, partition2) : padding;
  };
  return partition2;
}

// node_modules/d3-hierarchy/src/stratify.js
var preroot = { depth: -1 };
var ambiguous = {};
var imputed = {};
function defaultId2(d3) {
  return d3.id;
}
function defaultParentId(d3) {
  return d3.parentId;
}
function stratify_default() {
  var id2 = defaultId2, parentId = defaultParentId, path2;
  function stratify(data) {
    var nodes = Array.from(data), currentId = id2, currentParentId = parentId, n2, d3, i2, root, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
    if (path2 != null) {
      const I = nodes.map((d4, i3) => normalize2(path2(d4, i3, data)));
      const P = I.map(parentof);
      const S = new Set(I).add("");
      for (const i3 of P) {
        if (!S.has(i3)) {
          S.add(i3);
          I.push(i3);
          P.push(parentof(i3));
          nodes.push(imputed);
        }
      }
      currentId = (_, i3) => I[i3];
      currentParentId = (_, i3) => P[i3];
    }
    for (i2 = 0, n2 = nodes.length; i2 < n2; ++i2) {
      d3 = nodes[i2], node = nodes[i2] = new Node(d3);
      if ((nodeId = currentId(d3, i2, data)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = currentParentId(d3, i2, data)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }
    for (i2 = 0; i2 < n2; ++i2) {
      node = nodes[i2];
      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      } else {
        if (root) throw new Error("multiple roots");
        root = node;
      }
    }
    if (!root) throw new Error("no root");
    if (path2 != null) {
      while (root.data === imputed && root.children.length === 1) {
        root = root.children[0], --n2;
      }
      for (let i3 = nodes.length - 1; i3 >= 0; --i3) {
        node = nodes[i3];
        if (node.data !== imputed) break;
        node.data = null;
      }
    }
    root.parent = preroot;
    root.eachBefore(function(node2) {
      node2.depth = node2.parent.depth + 1;
      --n2;
    }).eachBefore(computeHeight);
    root.parent = null;
    if (n2 > 0) throw new Error("cycle");
    return root;
  }
  stratify.id = function(x2) {
    return arguments.length ? (id2 = optional(x2), stratify) : id2;
  };
  stratify.parentId = function(x2) {
    return arguments.length ? (parentId = optional(x2), stratify) : parentId;
  };
  stratify.path = function(x2) {
    return arguments.length ? (path2 = optional(x2), stratify) : path2;
  };
  return stratify;
}
function normalize2(path2) {
  path2 = `${path2}`;
  let i2 = path2.length;
  if (slash(path2, i2 - 1) && !slash(path2, i2 - 2)) path2 = path2.slice(0, -1);
  return path2[0] === "/" ? path2 : `/${path2}`;
}
function parentof(path2) {
  let i2 = path2.length;
  if (i2 < 2) return "";
  while (--i2 > 1) if (slash(path2, i2)) break;
  return path2.slice(0, i2);
}
function slash(path2, i2) {
  if (path2[i2] === "/") {
    let k2 = 0;
    while (i2 > 0 && path2[--i2] === "\\") ++k2;
    if ((k2 & 1) === 0) return true;
  }
  return false;
}

// node_modules/d3-hierarchy/src/tree.js
function defaultSeparation2(a4, b) {
  return a4.parent === b.parent ? 1 : 2;
}
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v) {
  var shift = 0, change = 0, children = v.children, i2 = children.length, w2;
  while (--i2 >= 0) {
    w2 = children[i2];
    w2.z += shift;
    w2.m += shift;
    shift += w2.s + (change += w2.c);
  }
}
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}
function TreeNode(node, i2) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i2;
}
TreeNode.prototype = Object.create(Node.prototype);
function treeRoot(root) {
  var tree = new TreeNode(root, 0), node, nodes = [tree], child, children, i2, n2;
  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n2 = children.length);
      for (i2 = n2 - 1; i2 >= 0; --i2) {
        nodes.push(child = node.children[i2] = new TreeNode(children[i2], i2));
        child.parent = node;
      }
    }
  }
  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}
function tree_default() {
  var separation = defaultSeparation2, dx = 1, dy = 1, nodeSize = null;
  function tree(root) {
    var t = treeRoot(root);
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);
    if (nodeSize) root.eachBefore(sizeNode);
    else {
      var left2 = root, right2 = root, bottom = root;
      root.eachBefore(function(node) {
        if (node.x < left2.x) left2 = node;
        if (node.x > right2.x) right2 = node;
        if (node.depth > bottom.depth) bottom = node;
      });
      var s3 = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s3 - left2.x, kx2 = dx / (right2.x + s3 + tx), ky2 = dy / (bottom.depth || 1);
      root.eachBefore(function(node) {
        node.x = (node.x + tx) * kx2;
        node.y = node.depth * ky2;
      });
    }
    return root;
  }
  function firstWalk(v) {
    var children = v.children, siblings = v.parent.children, w2 = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w2) {
        v.z = w2.z + separation(v._, w2._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w2) {
      v.z = w2.z + separation(v._, w2._);
    }
    v.parent.A = apportion(v, w2, v.parent.A || siblings[0]);
  }
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }
  function apportion(v, w2, ancestor) {
    if (w2) {
      var vip = v, vop = v, vim = w2, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree.separation = function(x2) {
    return arguments.length ? (separation = x2, tree) : separation;
  };
  tree.size = function(x2) {
    return arguments.length ? (nodeSize = false, dx = +x2[0], dy = +x2[1], tree) : nodeSize ? null : [dx, dy];
  };
  tree.nodeSize = function(x2) {
    return arguments.length ? (nodeSize = true, dx = +x2[0], dy = +x2[1], tree) : nodeSize ? [dx, dy] : null;
  };
  return tree;
}

// node_modules/d3-hierarchy/src/treemap/slice.js
function slice_default(parent, x05, y05, x12, y12) {
  var nodes = parent.children, node, i2 = -1, n2 = nodes.length, k2 = parent.value && (y12 - y05) / parent.value;
  while (++i2 < n2) {
    node = nodes[i2], node.x0 = x05, node.x1 = x12;
    node.y0 = y05, node.y1 = y05 += node.value * k2;
  }
}

// node_modules/d3-hierarchy/src/treemap/squarify.js
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x05, y05, x12, y12) {
  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n2 = nodes.length, dx, dy, value2 = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n2) {
    dx = x12 - x05, dy = y12 - y05;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n2);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value2 * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n2; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice) dice_default(row, x05, y05, x12, value2 ? y05 += dy * sumValue / value2 : y12);
    else slice_default(row, x05, y05, value2 ? x05 += dx * sumValue / value2 : x12, y12);
    value2 -= sumValue, i0 = i1;
  }
  return rows;
}
var squarify_default = function custom8(ratio) {
  function squarify(parent, x05, y05, x12, y12) {
    squarifyRatio(ratio, parent, x05, y05, x12, y12);
  }
  squarify.ratio = function(x2) {
    return custom8((x2 = +x2) > 1 ? x2 : 1);
  };
  return squarify;
}(phi);

// node_modules/d3-hierarchy/src/treemap/index.js
function treemap_default() {
  var tile = squarify_default, round2 = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap(root) {
    root.x0 = root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round2) root.eachBefore(round_default);
    return root;
  }
  function positionNode(node) {
    var p3 = paddingStack[node.depth], x05 = node.x0 + p3, y05 = node.y0 + p3, x12 = node.x1 - p3, y12 = node.y1 - p3;
    if (x12 < x05) x05 = x12 = (x05 + x12) / 2;
    if (y12 < y05) y05 = y12 = (y05 + y12) / 2;
    node.x0 = x05;
    node.y0 = y05;
    node.x1 = x12;
    node.y1 = y12;
    if (node.children) {
      p3 = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x05 += paddingLeft(node) - p3;
      y05 += paddingTop(node) - p3;
      x12 -= paddingRight(node) - p3;
      y12 -= paddingBottom(node) - p3;
      if (x12 < x05) x05 = x12 = (x05 + x12) / 2;
      if (y12 < y05) y05 = y12 = (y05 + y12) / 2;
      tile(node, x05, y05, x12, y12);
    }
  }
  treemap.round = function(x2) {
    return arguments.length ? (round2 = !!x2, treemap) : round2;
  };
  treemap.size = function(x2) {
    return arguments.length ? (dx = +x2[0], dy = +x2[1], treemap) : [dx, dy];
  };
  treemap.tile = function(x2) {
    return arguments.length ? (tile = required(x2), treemap) : tile;
  };
  treemap.padding = function(x2) {
    return arguments.length ? treemap.paddingInner(x2).paddingOuter(x2) : treemap.paddingInner();
  };
  treemap.paddingInner = function(x2) {
    return arguments.length ? (paddingInner = typeof x2 === "function" ? x2 : constant_default2(+x2), treemap) : paddingInner;
  };
  treemap.paddingOuter = function(x2) {
    return arguments.length ? treemap.paddingTop(x2).paddingRight(x2).paddingBottom(x2).paddingLeft(x2) : treemap.paddingTop();
  };
  treemap.paddingTop = function(x2) {
    return arguments.length ? (paddingTop = typeof x2 === "function" ? x2 : constant_default2(+x2), treemap) : paddingTop;
  };
  treemap.paddingRight = function(x2) {
    return arguments.length ? (paddingRight = typeof x2 === "function" ? x2 : constant_default2(+x2), treemap) : paddingRight;
  };
  treemap.paddingBottom = function(x2) {
    return arguments.length ? (paddingBottom = typeof x2 === "function" ? x2 : constant_default2(+x2), treemap) : paddingBottom;
  };
  treemap.paddingLeft = function(x2) {
    return arguments.length ? (paddingLeft = typeof x2 === "function" ? x2 : constant_default2(+x2), treemap) : paddingLeft;
  };
  return treemap;
}

// node_modules/d3-hierarchy/src/treemap/binary.js
function binary_default(parent, x05, y05, x12, y12) {
  var nodes = parent.children, i2, n2 = nodes.length, sum4, sums = new Array(n2 + 1);
  for (sums[0] = sum4 = i2 = 0; i2 < n2; ++i2) {
    sums[i2 + 1] = sum4 += nodes[i2].value;
  }
  partition2(0, n2, parent.value, x05, y05, x12, y12);
  function partition2(i3, j, value2, x06, y06, x13, y13) {
    if (i3 >= j - 1) {
      var node = nodes[i3];
      node.x0 = x06, node.y0 = y06;
      node.x1 = x13, node.y1 = y13;
      return;
    }
    var valueOffset = sums[i3], valueTarget = value2 / 2 + valueOffset, k2 = i3 + 1, hi = j - 1;
    while (k2 < hi) {
      var mid2 = k2 + hi >>> 1;
      if (sums[mid2] < valueTarget) k2 = mid2 + 1;
      else hi = mid2;
    }
    if (valueTarget - sums[k2 - 1] < sums[k2] - valueTarget && i3 + 1 < k2) --k2;
    var valueLeft = sums[k2] - valueOffset, valueRight = value2 - valueLeft;
    if (x13 - x06 > y13 - y06) {
      var xk = value2 ? (x06 * valueRight + x13 * valueLeft) / value2 : x13;
      partition2(i3, k2, valueLeft, x06, y06, xk, y13);
      partition2(k2, j, valueRight, xk, y06, x13, y13);
    } else {
      var yk = value2 ? (y06 * valueRight + y13 * valueLeft) / value2 : y13;
      partition2(i3, k2, valueLeft, x06, y06, x13, yk);
      partition2(k2, j, valueRight, x06, yk, x13, y13);
    }
  }
}

// node_modules/d3-hierarchy/src/treemap/sliceDice.js
function sliceDice_default(parent, x05, y05, x12, y12) {
  (parent.depth & 1 ? slice_default : dice_default)(parent, x05, y05, x12, y12);
}

// node_modules/d3-hierarchy/src/treemap/resquarify.js
var resquarify_default = function custom9(ratio) {
  function resquarify(parent, x05, y05, x12, y12) {
    if ((rows = parent._squarify) && rows.ratio === ratio) {
      var rows, row, nodes, i2, j = -1, n2, m2 = rows.length, value2 = parent.value;
      while (++j < m2) {
        row = rows[j], nodes = row.children;
        for (i2 = row.value = 0, n2 = nodes.length; i2 < n2; ++i2) row.value += nodes[i2].value;
        if (row.dice) dice_default(row, x05, y05, x12, value2 ? y05 += (y12 - y05) * row.value / value2 : y12);
        else slice_default(row, x05, y05, value2 ? x05 += (x12 - x05) * row.value / value2 : x12, y12);
        value2 -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x05, y05, x12, y12);
      rows.ratio = ratio;
    }
  }
  resquarify.ratio = function(x2) {
    return custom9((x2 = +x2) > 1 ? x2 : 1);
  };
  return resquarify;
}(phi);

// node_modules/@antv/g2/esm/utils/treeDataTransform.js
function generateHierarchyRoot(data, path2) {
  if (Array.isArray(data)) {
    return typeof path2 === "function" ? stratify_default().path(path2)(data) : stratify_default()(data);
  }
  return hierarchy(data);
}
function addObjectDataPath(root, path2 = [root.data.name]) {
  root.id = root.id || root.data.name;
  root.path = path2;
  if (root.children) {
    root.children.forEach((item) => {
      item.id = `${root.id}/${item.data.name}`;
      item.path = [...path2, item.data.name];
      addObjectDataPath(item, item.path);
    });
  }
}
function addArrayDataPath(root) {
  const name2 = get_default(root, ["data", "name"]);
  if (name2.replaceAll) {
    root.path = name2.replaceAll(".", "/").split("/");
  }
  if (root.children) {
    root.children.forEach((item) => {
      addArrayDataPath(item);
    });
  }
}
function getTileMethod(tile, ratio) {
  const tiles = {
    treemapBinary: binary_default,
    treemapDice: dice_default,
    treemapSlice: slice_default,
    treemapSliceDice: sliceDice_default,
    treemapSquarify: squarify_default,
    treemapResquarify: resquarify_default
  };
  const tileMethod = tile === "treemapSquarify" ? tiles[tile].ratio(ratio) : tiles[tile];
  if (!tileMethod) {
    throw new TypeError("Invalid tile method!");
  }
  return tileMethod;
}
function treeDataTransform(data, layout, encode) {
  const { value: value2 } = encode;
  const tileMethod = getTileMethod(layout.tile, layout.ratio);
  const root = generateHierarchyRoot(data, layout.path);
  if (isArray(data)) {
    addArrayDataPath(root);
  } else {
    addObjectDataPath(root);
  }
  value2 ? root.sum((d3) => layout.ignoreParentValue && d3.children ? 0 : field(value2)(d3)).sort(layout.sort) : root.count();
  treemap_default().tile(tileMethod).size(layout.size).round(layout.round).paddingInner(layout.paddingInner).paddingOuter(layout.paddingOuter).paddingTop(layout.paddingTop).paddingRight(layout.paddingRight).paddingBottom(layout.paddingBottom).paddingLeft(layout.paddingLeft)(root);
  const nodes = root.descendants().map((d3) => Object.assign(d3, {
    id: d3.id.replace(/^\//, ""),
    x: [d3.x0, d3.x1],
    y: [d3.y0, d3.y1]
  }));
  const filterData = nodes.filter(typeof layout.layer === "function" ? layout.layer : (d3) => d3.height === layout.layer);
  return [filterData, nodes];
}

// node_modules/@antv/g2/esm/mark/treemap.js
var __rest45 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var GET_DEFAULT_LAYOUT_OPTIONS = (width, height) => ({
  tile: "treemapSquarify",
  ratio: 0.5 * (1 + Math.sqrt(5)),
  size: [width, height],
  round: false,
  ignoreParentValue: true,
  padding: 0,
  paddingInner: 0,
  paddingOuter: 0,
  paddingTop: 0,
  paddingRight: 0,
  paddingBottom: 0,
  paddingLeft: 0,
  sort: (a4, b) => b.value - a4.value,
  layer: 0
});
var GET_DEFAULT_OPTIONS = (width, height) => ({
  type: "rect",
  axis: false,
  encode: {
    x: "x",
    y: "y",
    key: "id",
    color: (d3) => d3.path[1]
  },
  scale: {
    x: { domain: [0, width], range: [0, 1] },
    y: { domain: [0, height], range: [0, 1] }
  },
  style: {
    stroke: "#fff"
  },
  state: {
    active: { opacity: 0.6 },
    inactive: { opacity: 1 }
  }
});
var DEFAULT_LABEL_OPTIONS3 = {
  fontSize: 10,
  text: (d3) => last(d3.path),
  position: "inside",
  fill: "#000",
  textOverflow: "clip",
  wordWrap: true,
  maxLines: 1,
  wordWrapWidth: (d3) => d3.x1 - d3.x0,
  isTreemapLabel: true
};
var DEFAULT_TOOLTIP_OPTIONS = {
  title: (d3) => {
    var _a, _b;
    return (_b = (_a = d3.path) === null || _a === void 0 ? void 0 : _a.join) === null || _b === void 0 ? void 0 : _b.call(_a, ".");
  },
  items: [{ field: "value" }]
};
var DEFAULT_TOOLTIP_OPTIONS_DRILL = {
  title: (d3) => last(d3.path),
  items: [{ field: "value" }]
};
var Treemap = (options, context) => {
  const { width, height, options: markOptions } = context;
  const { data, encode = {}, scale: scale4, style = {}, layout = {}, labels = [], tooltip: tooltip2 = {} } = options, resOptions = __rest45(options, ["data", "encode", "scale", "style", "layout", "labels", "tooltip"]);
  const treemapDrillDown = get_default(markOptions, ["interaction", "treemapDrillDown"]) || get_default(markOptions, ["marks", 0, "interaction", "treemapDrillDown"]);
  const layoutOptions = deep_mix_default({}, GET_DEFAULT_LAYOUT_OPTIONS(width, height), layout, {
    layer: treemapDrillDown ? (d3) => {
      return d3.depth === 1;
    } : layout.layer
  });
  const [transformedData, transformedDataAll] = treeDataTransform(data, layoutOptions, encode);
  const labelStyle = subObject(style, "label");
  return deep_mix_default({}, GET_DEFAULT_OPTIONS(width, height), Object.assign(Object.assign({
    data: transformedData,
    scale: scale4,
    style,
    labels: [
      Object.assign(Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS3), labelStyle), treemapDrillDown && { cursor: "pointer" }),
      ...labels
    ]
  }, resOptions), { encode, tooltip: maybeTooltip(tooltip2, DEFAULT_TOOLTIP_OPTIONS), axis: false }), treemapDrillDown ? {
    interaction: Object.assign(Object.assign({}, resOptions.interaction), { treemapDrillDown: treemapDrillDown ? Object.assign(Object.assign({}, treemapDrillDown), { originData: transformedDataAll, layout: layoutOptions }) : void 0 }),
    encode: Object.assign({ color: (d3) => last(d3.path) }, encode),
    tooltip: maybeTooltip(tooltip2, DEFAULT_TOOLTIP_OPTIONS_DRILL)
  } : {});
};
Treemap.props = {};

// node_modules/@antv/g2/esm/mark/pack.js
var __rest46 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var GET_DEFAULT_LAYOUT_OPTIONS2 = (width, height) => ({
  size: [width, height],
  padding: 0,
  sort: (a4, b) => b.value - a4.value
});
var GET_DEFAULT_OPTIONS2 = (width, height, encode) => ({
  type: "point",
  axis: false,
  legend: false,
  scale: {
    x: { domain: [0, width] },
    y: { domain: [0, height] },
    size: { type: "identity" }
  },
  encode: {
    x: "x",
    y: "y",
    size: "r",
    shape: "point"
  },
  style: {
    fill: !encode.color ? (d3) => d3.height === 0 ? "#ddd" : "#fff" : void 0,
    stroke: !encode.color ? (d3) => d3.height === 0 ? "" : "#000" : void 0
  }
});
var DEFAULT_LABEL_OPTIONS4 = {
  text: "",
  position: "inside",
  textOverflow: "clip",
  wordWrap: true,
  maxLines: 1,
  wordWrapWidth: (d3) => d3.r * 2
};
var DEFAULT_TOOLTIP_OPTIONS2 = {
  title: (d3) => d3.data.name,
  items: [{ field: "value" }]
};
var dataTransform = (data, layout, encode) => {
  const { value: value2 } = encode;
  const root = isArray(data) ? stratify_default().path(layout.path)(data) : hierarchy(data);
  value2 ? root.sum((d3) => field(value2)(d3)).sort(layout.sort) : root.count();
  pack_default().size(layout.size).padding(layout.padding)(root);
  return root.descendants();
};
var Pack2 = (markOptions, context) => {
  const { width, height } = context;
  const { data, encode = {}, scale: scale4 = {}, style = {}, layout = {}, labels = [], tooltip: tooltip2 = {} } = markOptions, resOptions = __rest46(markOptions, ["data", "encode", "scale", "style", "layout", "labels", "tooltip"]);
  const DEFAULT_OPTIONS9 = GET_DEFAULT_OPTIONS2(width, height, encode);
  const transformedData = dataTransform(data, deep_mix_default({}, GET_DEFAULT_LAYOUT_OPTIONS2(width, height), layout), deep_mix_default({}, DEFAULT_OPTIONS9["encode"], encode));
  const labelStyle = subObject(style, "label");
  return deep_mix_default({}, DEFAULT_OPTIONS9, Object.assign(Object.assign({
    data: transformedData,
    encode,
    scale: scale4,
    style,
    labels: [
      Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS4), labelStyle),
      ...labels
    ]
  }, resOptions), { tooltip: maybeTooltip(tooltip2, DEFAULT_TOOLTIP_OPTIONS2), axis: false }));
};
Pack2.props = {};

// node_modules/@antv/g2/esm/mark/boxplot.js
var __rest47 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function min5(I, V) {
  return min(I, (i2) => V[i2]);
}
function max5(I, V) {
  return max(I, (i2) => V[i2]);
}
function lower(I, V) {
  const lo = q1(I, V) * 2.5 - q3(I, V) * 1.5;
  return min(I, (i2) => V[i2] >= lo ? V[i2] : NaN);
}
function q1(I, V) {
  return quantile(I, 0.25, (i2) => V[i2]);
}
function q2(I, V) {
  return quantile(I, 0.5, (i2) => V[i2]);
}
function q3(I, V) {
  return quantile(I, 0.75, (i2) => V[i2]);
}
function upper(I, V) {
  const hi = q3(I, V) * 2.5 - q1(I, V) * 1.5;
  return max(I, (i2) => V[i2] <= hi ? V[i2] : NaN);
}
function OutlierY() {
  return (I, mark2) => {
    const { encode } = mark2;
    const { y: y3, x: x2 } = encode;
    const { value: V } = y3;
    const { value: X } = x2;
    const GI = Array.from(group(I, (i2) => X[+i2]).values());
    const FI = GI.flatMap((I2) => {
      const lo = lower(I2, V);
      const hi = upper(I2, V);
      return I2.filter((i2) => V[i2] < lo || V[i2] > hi);
    });
    return [FI, mark2];
  };
}
var Boxplot = (options) => {
  const { data, encode, style = {}, tooltip: tooltip2 = {}, transform: transform2, animate } = options, rest = __rest47(options, ["data", "encode", "style", "tooltip", "transform", "animate"]);
  const { point: point6 = true } = style, restStyle = __rest47(style, ["point"]);
  const { y: y3 } = encode;
  const encodeY = { y: y3, y1: y3, y2: y3, y3, y4: y3 };
  const qy = { y1: q1, y2: q2, y3: q3 };
  const boxTooltip = subTooltip(tooltip2, "box", {
    items: [
      { channel: "y", name: "min" },
      { channel: "y1", name: "q1" },
      { channel: "y2", name: "q2" },
      { channel: "y3", name: "q3" },
      { channel: "y4", name: "max" }
    ]
  }, true);
  const pointTooltip = subTooltip(tooltip2, "point", {
    title: { channel: "x" },
    items: [{ name: "outlier", channel: "y" }]
  });
  if (!point6) {
    return Object.assign({ type: "box", data, transform: [
      Object.assign(Object.assign({ type: "groupX", y: min5 }, qy), { y4: max5 })
    ], encode: Object.assign(Object.assign({}, encode), encodeY), style: restStyle, tooltip: boxTooltip }, rest);
  }
  const boxStyle = subObject(restStyle, "box");
  const pointStyle = subObject(restStyle, "point");
  return [
    Object.assign({ type: "box", data, transform: [
      Object.assign(Object.assign({ type: "groupX", y: lower }, qy), { y4: upper })
    ], encode: Object.assign(Object.assign({}, encode), encodeY), style: boxStyle, tooltip: boxTooltip, animate: maybeAnimation(animate, "box") }, rest),
    // Draw outliers.
    {
      type: "point",
      data,
      transform: [{ type: OutlierY }],
      encode,
      style: Object.assign({}, pointStyle),
      tooltip: pointTooltip,
      animate: maybeAnimation(animate, "point")
    }
  ];
};
Boxplot.props = {};

// node_modules/@antv/g2/esm/mark/shape.js
var shape20 = {
  shape: Shape2
};
var Shape3 = (options) => {
  const { cartesian: cartesian3 } = options;
  if (cartesian3)
    return visualMark;
  return (index2, scale4, value2, coordinate) => {
    const { x: X, y: Y } = value2;
    const offset2 = createBandOffset(scale4, value2, options);
    const P = Array.from(index2, (i2) => {
      const p3 = [+X[i2], +Y[i2]];
      return [coordinate.map(offset2(p3, i2))];
    });
    return [index2, P];
  };
};
Shape3.props = {
  defaultShape: "shape",
  defaultLabelShape: "label",
  composite: false,
  shape: shape20,
  channels: [
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeTuple },
    { type: MaybeVisualPosition },
    { type: MaybeFunctionAttribute }
  ]
};

// node_modules/@antv/g2/esm/mark/forceGraph.js
var __rest48 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var DEFAULT_LAYOUT_OPTIONS3 = {
  joint: true
};
var DEFAULT_LINK_OPTIONS3 = {
  type: "link",
  axis: false,
  legend: false,
  encode: {
    x: [(d3) => d3.source.x, (d3) => d3.target.x],
    y: [(d3) => d3.source.y, (d3) => d3.target.y]
  },
  style: {
    stroke: "#999",
    strokeOpacity: 0.6
  }
};
var DEFAULT_NODE_OPTIONS3 = {
  type: "point",
  axis: false,
  legend: false,
  encode: {
    x: "x",
    y: "y",
    size: 5,
    color: "group",
    shape: "point"
  },
  style: {
    stroke: "#fff"
  }
};
var DEFAULT_LABEL_OPTIONS5 = {
  text: ""
};
function dataTransform2(data, layout, encode) {
  const { nodes, links } = data;
  const { joint, nodeStrength, linkStrength } = layout;
  const { nodeKey = (d3) => d3.id, linkKey = (d3) => d3.id } = encode;
  const nodeForce = manyBody_default();
  const linkForce = link_default(links).id(field(linkKey));
  typeof nodeStrength === "function" && nodeForce.strength(nodeStrength);
  typeof linkStrength === "function" && linkForce.strength(linkStrength);
  const simulation = simulation_default(nodes).force("link", linkForce).force("charge", nodeForce);
  joint ? simulation.force("center", center_default()) : simulation.force("x", x_default()).force("y", y_default());
  simulation.stop();
  const n2 = Math.ceil(Math.log(simulation.alphaMin()) / Math.log(1 - simulation.alphaDecay()));
  for (let i2 = 0; i2 < n2; i2++)
    simulation.tick();
  return {
    nodesData: nodes,
    linksData: links
  };
}
var ForceGraph = (options) => {
  const { data, encode: e3 = {}, scale: scale4, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate = {}, tooltip: tooltip2 = {} } = options;
  const { nodeKey = (d3) => d3.id, linkKey = (d3) => d3.id } = e3, restEncode = __rest48(e3, ["nodeKey", "linkKey"]);
  const encode = Object.assign({ nodeKey, linkKey }, restEncode);
  const nodeEncode = subObject(encode, "node");
  const linkEncode = subObject(encode, "link");
  const { links, nodes } = initializeData(data, encode);
  const { nodesData, linksData } = dataTransform2({ links, nodes }, deep_mix_default({}, DEFAULT_LAYOUT_OPTIONS3, layout), encode);
  const linkTooltip = subTooltip(tooltip2, "link", {
    items: [
      (d3) => ({ name: "source", value: field(linkKey)(d3.source) }),
      (d3) => ({ name: "target", value: field(linkKey)(d3.target) })
    ]
  });
  const nodeTooltip = subTooltip(tooltip2, "node", {
    items: [(d3) => ({ name: "key", value: field(nodeKey)(d3) })]
  }, true);
  return [
    deep_mix_default({}, DEFAULT_LINK_OPTIONS3, {
      data: linksData,
      encode: linkEncode,
      labels: linkLabels,
      style: subObject(style, "link"),
      tooltip: linkTooltip,
      animate: maybeAnimation(animate, "link")
    }),
    deep_mix_default({}, DEFAULT_NODE_OPTIONS3, {
      data: nodesData,
      encode: Object.assign({}, nodeEncode),
      scale: scale4,
      style: subObject(style, "node"),
      tooltip: nodeTooltip,
      labels: [
        Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS5), subObject(style, "label")),
        ...nodeLabels
      ],
      animate: maybeAnimation(animate, "link")
    })
  ];
};
ForceGraph.props = {};

// node_modules/@antv/g2/esm/data/cluster.js
var hierarchyFunction = (layoutFunction) => (options) => {
  return (data) => {
    const { field: field3 = "value", nodeSize, separation, sortBy: sortBy2, as = ["x", "y"] } = options;
    const [x2, y3] = as;
    const root = hierarchy(data, (d3) => d3.children).sum((d3) => d3[field3]).sort(sortBy2);
    const c5 = layoutFunction();
    c5.size([1, 1]);
    if (nodeSize)
      c5.nodeSize(nodeSize);
    if (separation)
      c5.separation(separation);
    c5(root);
    const nodes = [];
    root.each((node) => {
      node[x2] = node.x;
      node[y3] = node.y;
      node.name = node.data.name;
      nodes.push(node);
    });
    const edges = root.links();
    edges.forEach((edge) => {
      edge[x2] = [edge.source[x2], edge.target[x2]];
      edge[y3] = [edge.source[y3], edge.target[y3]];
    });
    return { nodes, edges };
  };
};
var Cluster = (options) => {
  return hierarchyFunction(cluster_default)(options);
};
Cluster.props = {};

// node_modules/@antv/g2/esm/data/tree.js
var Tree = (options) => {
  return hierarchyFunction(tree_default)(options);
};
Tree.props = {};

// node_modules/@antv/g2/esm/mark/tree.js
var DEFAULT_LAYOUT_OPTIONS4 = {
  sortBy: (a4, b) => b.value - a4.value
};
var DEFAULT_NODE_OPTIONS4 = {
  axis: false,
  legend: false,
  type: "point",
  encode: {
    x: "x",
    y: "y",
    size: 2,
    shape: "point"
  }
};
var DEFAULT_LINK_OPTIONS4 = {
  type: "link",
  encode: {
    x: "x",
    y: "y",
    shape: "smooth"
  }
};
var DEFAULT_LABEL_OPTIONS6 = {
  text: "",
  fontSize: 10
};
var Tree2 = (options) => {
  const { data, encode = {}, scale: scale4 = {}, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate = {}, tooltip: tooltip2 = {} } = options;
  const valueEncode = encode === null || encode === void 0 ? void 0 : encode.value;
  const { nodes, edges } = Tree(Object.assign(Object.assign(Object.assign({}, DEFAULT_LAYOUT_OPTIONS4), layout), { field: valueEncode }))(data);
  const nodeTooltip = subTooltip(tooltip2, "node", {
    title: "name",
    items: ["value"]
  }, true);
  const linkTooltip = subTooltip(tooltip2, "link", {
    title: "",
    items: [
      (d3) => ({ name: "source", value: d3.source.name }),
      (d3) => ({ name: "target", value: d3.target.name })
    ]
  });
  return [
    deep_mix_default({}, DEFAULT_LINK_OPTIONS4, {
      data: edges,
      encode: subObject(encode, "link"),
      scale: subObject(scale4, "link"),
      labels: linkLabels,
      style: Object.assign({ stroke: "#999" }, subObject(style, "link")),
      tooltip: linkTooltip,
      animate: maybeAnimation(animate, "link")
    }),
    deep_mix_default({}, DEFAULT_NODE_OPTIONS4, {
      data: nodes,
      scale: subObject(scale4, "node"),
      encode: subObject(encode, "node"),
      labels: [
        Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS6), subObject(style, "label")),
        ...nodeLabels
      ],
      style: Object.assign({}, subObject(style, "node")),
      tooltip: nodeTooltip,
      animate: maybeAnimation(animate, "node")
    })
  ];
};
Tree2.props = {};

// node_modules/@antv/g2/esm/mark/wordCloud.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest49 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function initializeData2(data, encode) {
  const { text = "text", value: value2 = "value" } = encode;
  return data.map((d3) => Object.assign(Object.assign({}, d3), { text: d3[text], value: d3[value2] }));
}
var GET_DEFAULT_OPTIONS3 = () => ({
  axis: false,
  type: "text",
  encode: {
    x: "x",
    y: "y",
    text: "text",
    rotate: "rotate",
    fontSize: "size",
    shape: "tag"
  },
  scale: {
    x: { range: [0, 1] },
    y: { range: [0, 1] }
  },
  style: {
    fontFamily: (d3) => d3.fontFamily
  },
  tooltip: {
    items: [
      (datum) => ({
        name: datum.text,
        value: datum.value
      })
    ]
  }
});
var WordCloud = (options, context) => __awaiter3(void 0, void 0, void 0, function* () {
  const { width, height } = context;
  const { data, encode = {}, scale: scale4, style = {}, layout = {} } = options, resOptions = __rest49(options, ["data", "encode", "scale", "style", "layout"]);
  const initializedData = initializeData2(data, encode);
  return deep_mix_default({}, GET_DEFAULT_OPTIONS3(), Object.assign(Object.assign({
    data: {
      value: initializedData,
      transform: [
        Object.assign({ type: "wordCloud", size: [width, height] }, layout)
      ]
    },
    encode,
    scale: scale4,
    style
  }, resOptions), { axis: false }));
});
WordCloud.props = {};

// node_modules/@antv/g2/esm/mark/gauge.js
var __rest50 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var indicatorShape = (options, context) => {
  const { shape: shape24, radius } = options, style = __rest50(options, ["shape", "radius"]);
  const pointerStyle = subObject(style, "pointer");
  const pinStyle = subObject(style, "pin");
  const { shape: pointerShape } = pointerStyle, resPointerStyle = __rest50(pointerStyle, ["shape"]);
  const { shape: pinShape } = pinStyle, resPinStyle = __rest50(pinStyle, ["shape"]);
  const { coordinate, theme } = context;
  return (points, value2) => {
    const invertedPoints = points.map((p3) => coordinate.invert(p3));
    const [startAngle, endAngle, innerRadius] = getTransformOptions(coordinate, "polar");
    const newCoordinate = coordinate.clone();
    const { color: stroke2 } = value2;
    const newTransformations = Radial({
      startAngle,
      endAngle,
      innerRadius,
      outerRadius: radius
    });
    newTransformations.push(["cartesian"]);
    newCoordinate.update({
      transformations: newTransformations
    });
    const newPoints = invertedPoints.map((p3) => newCoordinate.map(p3));
    const [x2, y3] = getOrigin(newPoints);
    const [cx, cy] = coordinate.getCenter();
    const pointerAttrs = Object.assign(Object.assign({ x1: x2, y1: y3, x2: cx, y2: cy, stroke: stroke2 }, resPointerStyle), style);
    const pinAttrs = Object.assign(Object.assign({
      cx,
      cy,
      stroke: stroke2
    }, resPinStyle), style);
    const indicatorGroup = select(new Group());
    if (!isUnset(pointerShape)) {
      typeof pointerShape === "function" ? indicatorGroup.append(() => pointerShape(newPoints, value2, newCoordinate, theme)) : indicatorGroup.append("line").call(applyStyle, pointerAttrs).node();
    }
    if (!isUnset(pinShape)) {
      typeof pinShape === "function" ? indicatorGroup.append(() => pinShape(newPoints, value2, newCoordinate, theme)) : indicatorGroup.append("circle").call(applyStyle, pinAttrs).node();
    }
    return indicatorGroup.node();
  };
};
var DEFAULT_OPTIONS3 = {
  coordinate: {
    type: "radial",
    innerRadius: 0.9,
    outerRadius: 1,
    startAngle: -11 / 10 * Math.PI,
    endAngle: 1 / 10 * Math.PI
  },
  axis: {
    x: false
  },
  legend: false,
  tooltip: false,
  encode: {
    x: "x",
    y: "y",
    color: "color"
  },
  scale: {
    color: {
      range: ["#30BF78", "#D0D0D0"]
    }
  }
};
var DEFAULT_INDICATOR_OPTIONS = {
  style: {
    shape: indicatorShape,
    lineWidth: 4,
    pointerLineCap: "round",
    pinR: 10,
    pinFill: "#fff",
    radius: 0.6
  }
};
var DEFAULT_TEXT_OPTIONS = {
  type: "text",
  style: {
    x: "50%",
    y: "60%",
    textAlign: "center",
    textBaseline: "middle",
    fontSize: 20,
    fontWeight: 800,
    fill: "#888"
  },
  tooltip: false
};
function getGaugeData(data) {
  if (isNumber(data)) {
    const percent = Math.max(0, Math.min(data, 1));
    return {
      percent,
      target: percent,
      total: 1
    };
  }
  return data;
}
function dataTransform3(data, scale4) {
  const { name: name2 = "score", target, total, percent, thresholds = [] } = getGaugeData(data);
  const _target = percent || target;
  const _total = percent ? 1 : total;
  const newScale = Object.assign({ y: {
    domain: [0, _total]
  } }, scale4);
  if (!thresholds.length) {
    return {
      targetData: [{ x: name2, y: _target, color: "target" }],
      totalData: [
        { x: name2, y: _target, color: "target" },
        { x: name2, y: _total - _target, color: "total" }
      ],
      target: _target,
      total: _total,
      scale: newScale
    };
  }
  return {
    targetData: [{ x: name2, y: _target, color: "target" }],
    totalData: thresholds.map((d3, i2) => ({
      x: name2,
      y: i2 >= 1 ? d3 - thresholds[i2 - 1] : d3,
      color: i2
    })),
    target: _target,
    total: _total,
    scale: newScale
  };
}
function getTextContent(textStyle, { target, total }) {
  const { content } = textStyle;
  return content ? content(target, total) : target.toString();
}
var Gauge = (options) => {
  const { data = {}, scale: scale4 = {}, style = {}, animate = {}, transform: transform2 = [] } = options, resOptions = __rest50(options, ["data", "scale", "style", "animate", "transform"]);
  const { targetData, totalData, target, total, scale: newScale } = dataTransform3(data, scale4);
  const _a = subObject(style, "text"), { tooltip: tooltip2 } = _a, textStyle = __rest50(_a, ["tooltip"]);
  const indicatorStyle = filterPrefixObject(style, ["pointer", "pin"]);
  const arcStyle = subObject(style, "arc");
  const shape24 = arcStyle.shape;
  return [
    deep_mix_default({}, DEFAULT_OPTIONS3, Object.assign({ type: "interval", transform: [{ type: "stackY" }], data: totalData, scale: newScale, style: shape24 === "round" ? Object.assign(Object.assign({}, arcStyle), { shape: Round }) : arcStyle, animate: typeof animate === "object" ? subObject(animate, "arc") : animate }, resOptions)),
    deep_mix_default({}, DEFAULT_OPTIONS3, DEFAULT_INDICATOR_OPTIONS, Object.assign({ type: "point", data: targetData, scale: newScale, style: indicatorStyle, animate: typeof animate === "object" ? subObject(animate, "indicator") : animate }, resOptions)),
    deep_mix_default({}, DEFAULT_TEXT_OPTIONS, {
      style: Object.assign({ text: getTextContent(textStyle, { target, total }) }, textStyle),
      tooltip: tooltip2,
      animate: typeof animate === "object" ? subObject(animate, "text") : animate
    })
  ];
};
Gauge.props = {};

// node_modules/@antv/g2/esm/mark/density.js
var shape21 = {
  density: Density
};
var Density2 = () => {
  return (index2, scale4, value2, coordinate) => {
    const { x: X, series: S } = value2;
    const Yn = Object.entries(value2).filter(([key]) => key.startsWith("y")).map(([, value3]) => value3);
    const SZn = Object.entries(value2).filter(([key]) => key.startsWith("size")).map(([, value3]) => value3);
    if (X === void 0 || Yn === void 0 || SZn === void 0) {
      throw new Error("Missing encode for x or y or size channel.");
    }
    const xScale = scale4.x;
    const series = scale4.series;
    const P = Array.from(index2, (i2) => {
      const groupWidth = xScale.getBandWidth(xScale.invert(+X[i2]));
      const ratio = series ? series.getBandWidth(series.invert(+(S === null || S === void 0 ? void 0 : S[i2]))) : 1;
      const width = groupWidth * ratio;
      const offset2 = (+(S === null || S === void 0 ? void 0 : S[i2]) || 0) * groupWidth;
      const x2 = +X[i2] + offset2 + width / 2;
      const PN = [
        ...Yn.map((_, idx) => [x2 + +SZn[idx][i2] / index2.length, +Yn[idx][i2]]),
        // right
        ...Yn.map((_, idx) => [
          x2 - +SZn[idx][i2] / index2.length,
          +Yn[idx][i2]
        ]).reverse()
        // left
      ];
      return PN.map((p3) => coordinate.map(p3));
    });
    return [index2, P];
  };
};
Density2.props = {
  defaultShape: "density",
  defaultLabelShape: "label",
  composite: false,
  shape: shape21,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape21) }),
    { name: "x", scale: "band", required: true },
    { name: "y", required: true },
    { name: "size", required: true },
    { name: "series", scale: "band" },
    { name: "size", required: true, scale: "identity" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroY1 },
    { type: MaybeZeroX }
  ],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: { shareTooltip: true }
};

// node_modules/@antv/g2/esm/mark/heatmap.js
var shape22 = {
  heatmap: Heatmap
};
var Heatmap2 = (options) => {
  return (index2, scale4, value2, coordinate) => {
    const { x: X, y: Y, size: S, color: C } = value2;
    const P = Array.from(index2, (i2) => {
      const r2 = S ? +S[i2] : 40;
      return [...coordinate.map([+X[i2], +Y[i2]]), C[i2], r2];
    });
    return [[0], [P]];
  };
};
Heatmap2.props = {
  defaultShape: "heatmap",
  defaultLabelShape: "label",
  composite: false,
  shape: shape22,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape22) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "color", scale: "identity", required: true },
    { name: "size" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroX },
    { type: MaybeZeroY }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/liquid.js
var __rest51 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var DEFAULT_OPTIONS4 = {
  axis: {
    x: false,
    y: false
  },
  legend: false,
  tooltip: false,
  encode: {
    x: "type",
    y: "percent"
  },
  scale: {
    y: {
      domain: [0, 1]
    }
  },
  style: {
    shape: Liquid
  },
  animate: {
    enter: {
      type: "fadeIn"
    }
  }
};
var DEFAULT_TEXT_OPTIONS2 = {
  type: "text",
  style: {
    x: "50%",
    y: "50%",
    textAlign: "center",
    textBaseline: "middle",
    fontSize: 20,
    fontWeight: 800,
    fill: "#888"
  },
  animate: {
    enter: {
      type: "fadeIn"
    }
  }
};
var Liquid2 = (options) => {
  const { data = {}, style = {}, animate } = options, resOptions = __rest51(options, ["data", "style", "animate"]);
  const percent = Math.max(0, isNumber(data) ? data : data === null || data === void 0 ? void 0 : data.percent);
  const newData = [{ percent, type: "liquid" }];
  const contentStyle = Object.assign(Object.assign({}, subObject(style, "text")), subObject(style, "content"));
  const outline = subObject(style, "outline");
  const wave = subObject(style, "wave");
  const background = subObject(style, "background");
  return [
    deep_mix_default({}, DEFAULT_OPTIONS4, Object.assign({ type: "interval", data: newData, style: {
      liquidOptions: {
        percent,
        liquidShape: style === null || style === void 0 ? void 0 : style.shape
      },
      styleOptions: Object.assign(Object.assign({}, style), {
        outline,
        wave,
        background
      })
    }, animate }, resOptions)),
    deep_mix_default({}, DEFAULT_TEXT_OPTIONS2, {
      style: Object.assign({ text: `${prettyNumber2(percent * 100)} %` }, contentStyle),
      animate
    })
  ];
};
Liquid2.props = {};

// node_modules/@antv/g2/esm/mark/beeswarm.js
var shape23 = {
  hollow: HollowPoint,
  hollowDiamond: HollowDiamond,
  hollowHexagon: HollowHexagon,
  hollowSquare: HollowSquare,
  hollowTriangleDown: HollowTriangleDown,
  hollowTriangle: HollowTriangle,
  hollowBowtie: HollowBowtie,
  hollowCircle: HollowCircle,
  point: Point2,
  plus: Plus,
  diamond: Diamond,
  square: Square,
  triangle: Triangle,
  hexagon: Hexagon,
  cross: Cross,
  bowtie: Bowtie,
  hyphen: Hyphen,
  line: Line3,
  tick: Tick,
  triangleDown: TriangleDown,
  circle: Circle2
};
var DEFAULT_RADIUS = 4;
var ITERATIONS = 200;
var Beeswarm = (options) => {
  return (index2, scale4, value2, coordinate) => {
    const { x: X, y: Y, size: S } = value2;
    if (!X.length || !Y.length)
      return [index2, Y.map(() => [[]])];
    const [width, height] = coordinate.getSize();
    const offset2 = createBandOffset(scale4, value2, options);
    const nodes = Array.from(index2, (i2) => {
      const x05 = +X[i2] * width;
      const y05 = +Y[i2] * height;
      const r2 = +S[i2] || DEFAULT_RADIUS;
      return { i: i2, x: x05, y: y05, r: r2 };
    });
    const sim = simulation_default(nodes).stop().force("collide", collide_default().radius((d3) => d3.r + 1).strength(1));
    sim.force("x", x_default((d3) => d3.x).strength(0.5));
    sim.force("y", y_default((d3) => d3.y).strength(5));
    for (let i2 = 0; i2 < ITERATIONS; i2++)
      sim.tick();
    sim.stop();
    const xy = (i2) => {
      const n2 = nodes.find((d3) => d3.i === i2);
      return [n2.x / width, n2.y / height];
    };
    const P = S ? Array.from(index2, (i2) => {
      const [cx, cy] = xy(i2);
      const r2 = +S[i2];
      const a4 = r2 / width;
      const b = r2 / height;
      const p1 = [cx - a4, cy - b];
      const p22 = [cx + a4, cy + b];
      return [
        coordinate.map(offset2(p1, i2)),
        coordinate.map(offset2(p22, i2))
      ];
    }) : Array.from(index2, (i2) => [coordinate.map(offset2(xy(i2), i2))]);
    return [index2, P];
  };
};
Beeswarm.props = {
  defaultShape: "point",
  defaultLabelShape: "label",
  composite: false,
  shape: shape23,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape23) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "series", scale: "band" },
    { name: "size", quantitative: "sqrt" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroX },
    { type: MaybeZeroY }
  ],
  postInference: [...basePostInference(), { type: MaybeSize }, ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/partition.js
var __rest52 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function partitionLayout(data, options = {}) {
  const { valueField = "value", sort: sort2, fillParent = true, nameField = "name" } = options;
  if (!data || data.length === 0)
    return [];
  const buildPartition = (node, parent = null, depth = 0) => {
    const partitionNode = {
      data: node,
      depth,
      parent,
      children: [],
      x0: 0,
      x1: 0,
      value: node[valueField] || 0
    };
    if (node.children && node.children.length > 0) {
      partitionNode.children = node.children.map((child) => buildPartition(child, partitionNode, depth + 1));
    }
    return partitionNode;
  };
  const result = [];
  let currentRootStartX = 0;
  data.forEach((rootData) => {
    const root = buildPartition(rootData);
    const calculateLayout = (node, parentStartX = 0, isRootNode = false, parentWidth = 0) => {
      if (isRootNode || node.depth === 0) {
        node.x0 = isRootNode ? parentStartX : 0;
        node.x1 = node.x0 + node.value;
      } else {
        node.x0 = parentStartX;
        if (fillParent && parentWidth > 0) {
          const siblingsTotalValue = node.parent ? node.parent.children.reduce((acc, child) => acc + child.value, 0) : node.value;
          const siblingsCount = node.parent ? node.parent.children.length : 1;
          const ratio = siblingsTotalValue > 0 ? node.value / siblingsTotalValue : 1 / siblingsCount;
          node.x1 = parentStartX + parentWidth * ratio;
        } else {
          node.x1 = parentStartX + node.value;
        }
      }
      let childStartX = node.x0;
      const nodeWidth = node.x1 - node.x0;
      const sortedChildren = sort2 ? [...node.children].sort((a4, b) => sort2(a4.data, b.data)) : node.children;
      if (fillParent && sortedChildren.length > 0) {
        const childrenTotalValue = node.children.reduce((sum4, c5) => sum4 + c5.value, 0);
        sortedChildren.forEach((child) => {
          calculateLayout(child, childStartX, false, nodeWidth);
          const ratio = childrenTotalValue > 0 ? child.value / childrenTotalValue : 1 / sortedChildren.length;
          childStartX += nodeWidth * ratio;
        });
      } else {
        sortedChildren.forEach((child) => {
          calculateLayout(child, childStartX, false, 0);
          childStartX += child.x1 - child.x0;
        });
      }
    };
    calculateLayout(root, currentRootStartX, true);
    currentRootStartX += root.value;
    const processNode = (node) => {
      var _a, _b, _c;
      const getName = (d3) => {
        var _a2;
        return (_a2 = d3[nameField]) !== null && _a2 !== void 0 ? _a2 : d3.name;
      };
      const path2 = [getName(node.data)];
      let ancestorNode = node;
      while (ancestorNode.parent) {
        path2.unshift(getName(ancestorNode.parent.data));
        ancestorNode = ancestorNode.parent;
      }
      return Object.assign(Object.assign({}, pick_default(node.data, [valueField])), {
        [PARTITION_PATH_FIELD]: path2,
        [PARTITION_ANCESTOR_FIELD]: (_c = (_b = (_a = ancestorNode.parent) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b[nameField]) !== null && _c !== void 0 ? _c : node.data[nameField],
        name: node.data[nameField],
        depth: node.depth,
        value: node.value,
        x: [node.x0, node.x1],
        y: [node.depth, node.depth + 1],
        // Add child node count attribute for drill-down interaction judgment.
        [CHILD_NODE_COUNT]: node.children.length
      });
    };
    const collectResultNodes = (node) => {
      result.push(processNode(node));
      node.children.forEach(collectResultNodes);
    };
    collectResultNodes(root);
  });
  return result;
}
var PARTITION_TYPE = "partition";
var PARTITION_TYPE_FIELD = "markType";
var PARTITION_PATH_FIELD = "path";
var PARTITION_ANCESTOR_FIELD = "ancestor-node";
var CHILD_NODE_COUNT = "childNodeCount";
function transformData(options) {
  const { data, encode, fillParent, sort: sort2 } = options;
  const { color, value: value2, name: name2 } = encode;
  const nodes = partitionLayout(data, {
    valueField: value2,
    fillParent,
    nameField: name2,
    sort: sort2
  });
  return nodes.map((node) => {
    const nodeInfo = Object.assign({}, node);
    if (color && color !== PARTITION_ANCESTOR_FIELD) {
      nodeInfo[color] = node[color];
    }
    return nodeInfo;
  });
}
var DEFAULT_OPTIONS5 = {
  id: PARTITION_TYPE,
  encode: {
    x: "x",
    y: "y",
    key: PARTITION_PATH_FIELD,
    color: PARTITION_ANCESTOR_FIELD,
    value: "value",
    name: "name"
  },
  labels: [
    {
      style: {
        pointerEvents: "none"
      },
      text: "value",
      position: "inside",
      transform: [
        {
          type: "overflowHide"
        }
      ]
    }
  ],
  axis: {
    x: { title: "Time/Order", label: true },
    y: false
  },
  style: {
    [PARTITION_TYPE_FIELD]: PARTITION_TYPE,
    [CHILD_NODE_COUNT]: "childNodeCount"
    // Add child node count attribute for drill-down interaction.
  },
  state: {
    active: { zIndex: 2 },
    inactive: { zIndex: 1 }
  },
  legend: false,
  coordinate: {
    type: "cartesian",
    grid: false
    // Remove grid lines.
  },
  interaction: {
    drillDown: true
  }
};
var Partition = (options) => {
  const { encode: encodeOption, data = [], layout = {} } = options, resOptions = __rest52(options, ["encode", "data", "layout"]);
  const { fillParent = true, sort: sort2 } = layout;
  const encode = Object.assign(Object.assign({}, DEFAULT_OPTIONS5.encode), encodeOption);
  const { value: value2 } = encode;
  const rectData = transformData({ encode, data, fillParent, sort: sort2 });
  return [
    deep_mix_default({}, DEFAULT_OPTIONS5, Object.assign({
      type: "rect",
      data: rectData,
      encode,
      tooltip: {
        title: "path",
        items: [
          (d3) => {
            return {
              name: value2,
              value: d3[value2]
            };
          }
        ]
      },
      // Add basic interaction.
      interaction: {
        elementHighlight: true
      }
    }, resOptions))
  ];
};
Partition.props = {};

// node_modules/@antv/g2/esm/palette/category10.js
var Category10 = () => {
  return [
    "#5B8FF9",
    "#5AD8A6",
    "#5D7092",
    "#F6BD16",
    "#6F5EF9",
    "#6DC8EC",
    "#945FB9",
    "#FF9845",
    "#1E9493",
    "#FF99C3"
  ];
};
Category10.props = {};

// node_modules/@antv/g2/esm/palette/category20.js
var Category20 = () => {
  return [
    "#5B8FF9",
    "#CDDDFD",
    "#5AD8A6",
    "#CDF3E4",
    "#5D7092",
    "#CED4DE",
    "#F6BD16",
    "#FCEBB9",
    "#6F5EF9",
    "#D3CEFD",
    "#6DC8EC",
    "#D3EEF9",
    "#945FB9",
    "#DECFEA",
    "#FF9845",
    "#FFE0C7",
    "#1E9493",
    "#BBDEDE",
    "#FF99C3",
    "#FFE0ED"
  ];
};
Category20.props = {};

// node_modules/@antv/g2/esm/scale/band.js
var Band2 = (options) => {
  return new Band(options);
};
Band2.props = {};

// node_modules/@antv/g2/esm/scale/linear.js
var Linear3 = (options) => {
  return new Linear(options);
};
Linear3.props = {};

// node_modules/@antv/g2/esm/scale/ordinal.js
var Ordinal2 = (options) => {
  return new Ordinal(options);
};
Ordinal2.props = {};

// node_modules/@antv/g2/esm/scale/identity.js
var Identity2 = (options) => {
  return new Identity(options);
};
Identity2.props = {};

// node_modules/@antv/g2/esm/scale/point.js
var Point4 = (options) => {
  return new Point(options);
};
Point4.props = {};

// node_modules/@antv/g2/esm/scale/time.js
var Time2 = (options) => {
  return new Time(options);
};
Time2.props = {};

// node_modules/@antv/g2/esm/scale/log.js
var Log2 = (options) => {
  return new Log(options);
};
Log2.props = {};

// node_modules/@antv/g2/esm/scale/pow.js
var Pow2 = (options) => {
  return new Pow(options);
};
Pow2.props = {};

// node_modules/@antv/g2/esm/scale/threshold.js
var Threshold2 = (options) => {
  return new Threshold(options);
};
Threshold2.props = {};

// node_modules/@antv/g2/esm/scale/quantile.js
var Quantile2 = (options) => {
  return new Quantile(options);
};
Quantile2.props = {};

// node_modules/@antv/g2/esm/scale/quantize.js
var Quantize2 = (options) => {
  return new Quantize(options);
};
Quantize2.props = {};

// node_modules/@antv/g2/esm/scale/sqrt.js
var Sqrt2 = (options) => {
  return new Sqrt(options);
};
Sqrt2.props = {};

// node_modules/@antv/g2/esm/scale/sequential.js
var Sequential3 = (options) => {
  return new Sequential(options);
};
Sequential3.props = {};

// node_modules/@antv/g2/esm/scale/constant.js
var Constant3 = (options) => {
  return new Constant2(options);
};
Constant3.props = {};

// node_modules/@antv/g2/esm/component/constant.js
var G2_CLASS_PREFIX = "g2-";
function g2Selector(className2) {
  return `.${G2_CLASS_PREFIX}${className2}`;
}
var LEGEND_INFER_STRATEGIES = [
  [
    "legendCategory",
    [
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["shape", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["shape", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "constant"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["shape", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["shape", "discrete"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["shape", "discrete"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["shape", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["shape", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["shape", "constant"]
      ],
      [
        ["color", "constant"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["shape", "discrete"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "constant"],
        ["shape", "discrete"]
      ],
      // [
      //   ['color', 'constant'],
      //   ['opacity', 'constant'],
      //   ['size', 'constant'],
      // ],
      // [
      //   ['color', 'constant'],
      //   ['shape', 'constant'],
      //   ['size', 'constant'],
      // ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["shape", "constant"]
      ],
      [
        ["color", "discrete"],
        ["shape", "discrete"]
      ],
      [
        ["color", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"]
      ],
      [
        ["color", "discrete"],
        ["shape", "constant"]
      ],
      [
        ["color", "constant"],
        ["shape", "discrete"]
      ],
      [
        ["color", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"]
      ],
      // [
      //   ['color', 'constant'],
      //   ['opacity', 'constant'],
      // ],
      // [
      //   ['color', 'constant'],
      //   ['shape', 'constant'],
      // ],
      [["color", "discrete"]]
      // [['color', 'constant']],
    ]
  ],
  [
    "legendContinuousSize",
    [
      [
        ["color", "continuous"],
        ["opacity", "continuous"],
        ["size", "continuous"]
      ],
      [
        ["color", "constant"],
        ["opacity", "continuous"],
        ["size", "continuous"]
      ],
      [
        ["color", "continuous"],
        ["size", "continuous"]
      ],
      [
        ["color", "constant"],
        ["size", "continuous"]
      ],
      [
        ["size", "continuous"],
        ["opacity", "continuous"]
      ],
      [["size", "continuous"]]
    ]
  ],
  [
    "legendContinuousBlockSize",
    [
      [
        ["color", "distribution"],
        ["opacity", "distribution"],
        ["size", "distribution"]
      ],
      [
        ["color", "distribution"],
        ["size", "distribution"]
      ]
    ]
  ],
  [
    "legendContinuousBlock",
    [
      [
        ["color", "distribution"],
        ["opacity", "continuous"]
      ],
      [["color", "distribution"]]
    ]
  ],
  [
    "legendContinuous",
    [
      [
        ["color", "continuous"],
        ["opacity", "continuous"]
      ],
      [["color", "continuous"]],
      [["opacity", "continuous"]]
    ]
  ]
];
var ANNOTATION_MARKS = [
  "lineX",
  "lineY",
  "rangeX",
  "rangeY",
  "range",
  "connector"
];

// node_modules/@antv/g2/esm/theme/create.js
function create({ colorDefault, colorBlack, colorWhite, colorStroke, colorBackground, padding1, padding2, padding3, alpha90, alpha65, alpha45, alpha25, alpha10, category10, category20, sizeDefault = 1, padding = "auto", margin = 16 }) {
  return {
    padding,
    margin,
    size: sizeDefault,
    color: colorDefault,
    category10,
    category20,
    enter: {
      duration: 300,
      fill: "both",
      delay: 0
    },
    update: {
      duration: 300,
      fill: "both",
      delay: 0
    },
    exit: {
      duration: 300,
      fill: "both",
      delay: 0
    },
    view: {
      viewFill: colorBackground,
      plotFill: "transparent",
      mainFill: "transparent",
      contentFill: "transparent"
    },
    line: {
      line: {
        fill: "",
        strokeOpacity: 1,
        lineWidth: 1,
        lineCap: "round"
      }
    },
    point: {
      point: {
        r: 3,
        fillOpacity: 0.95,
        lineWidth: 0
      },
      hollow: {
        r: 3,
        strokeOpacity: 0.95,
        lineWidth: 1
      },
      plus: {
        r: 3,
        strokeOpacity: 0.95,
        lineWidth: 3
      },
      diamond: {
        r: 3,
        strokeOpacity: 0.95,
        lineWidth: 1
      }
    },
    interval: {
      rect: {
        fillOpacity: 0.95
      },
      hollow: {
        fill: "",
        strokeOpacity: 1,
        lineWidth: 2
      }
    },
    area: {
      area: {
        fillOpacity: 0.85,
        lineWidth: 0
      }
    },
    polygon: {
      polygon: {
        fillOpacity: 0.95
      }
    },
    cell: {
      cell: {
        fillOpacity: 0.95
      },
      hollow: {
        fill: "",
        strokeOpacity: 1,
        lineWidth: 2
      }
    },
    rect: {
      rect: {
        fillOpacity: 0.95
      },
      hollow: {
        fill: "",
        strokeOpacity: 1,
        lineWidth: 2
      }
    },
    link: {
      link: {
        fill: "",
        strokeOpacity: 1
      }
    },
    vector: {
      vector: {
        fillOpacity: 1
      }
    },
    box: {
      box: {
        fillOpacity: 0.95,
        stroke: colorBlack,
        lineWidth: 1
      }
    },
    text: {
      text: {
        fill: "#1D2129",
        fontSize: 12,
        lineWidth: 0,
        connectorStroke: colorStroke,
        connectorStrokeOpacity: 0.45,
        connectorLineWidth: 1,
        backgroundFill: colorStroke,
        backgroundFillOpacity: 0.15,
        backgroundPadding: [2, 4],
        startMarkerSymbol: "circle",
        startMarkerSize: 4,
        endMarkerSymbol: "circle",
        endMarkerSize: 4
      },
      badge: {
        fill: "#1D2129",
        fillOpacity: 0.65,
        lineWidth: 0,
        fontSize: 10,
        textAlign: "center",
        textBaseline: "middle",
        markerFill: colorStroke,
        markerFillOpacity: 0.25,
        markerStrokeOpacity: 0
      }
    },
    lineX: {
      line: {
        stroke: colorStroke,
        strokeOpacity: 0.45,
        lineWidth: 1
      }
    },
    lineY: {
      line: {
        stroke: colorStroke,
        strokeOpacity: 0.45,
        lineWidth: 1
      }
    },
    rangeX: {
      range: {
        fill: colorStroke,
        fillOpacity: 0.15,
        lineWidth: 0
      }
    },
    rangeY: {
      range: {
        fill: colorStroke,
        fillOpacity: 0.15,
        lineWidth: 0
      }
    },
    connector: {
      connector: {
        stroke: colorStroke,
        strokeOpacity: 0.45,
        lineWidth: 1,
        connectLength1: 12,
        endMarker: true,
        endMarkerSize: 6,
        endMarkerFill: colorStroke,
        endMarkerFillOpacity: 0.95
      }
    },
    axis: {
      arrow: false,
      gridLineDash: [3, 4],
      gridLineWidth: 0.5,
      gridStroke: colorBlack,
      gridStrokeOpacity: alpha10,
      labelAlign: "horizontal",
      labelFill: colorBlack,
      labelOpacity: alpha45,
      labelFontSize: 12,
      labelFontWeight: "normal",
      labelSpacing: padding1,
      // spacing between label and it's tick
      line: false,
      lineLineWidth: 0.5,
      lineStroke: colorBlack,
      lineStrokeOpacity: alpha45,
      tickLength: 4,
      tickLineWidth: 1,
      tickStroke: colorBlack,
      tickOpacity: alpha45,
      titleFill: colorBlack,
      titleOpacity: alpha90,
      titleFontSize: 12,
      titleFontWeight: "normal",
      titleSpacing: 12,
      titleTransformOrigin: "center",
      lineArrowOffset: 6,
      lineArrowSize: 6
    },
    axisTop: {
      gridDirection: "positive",
      labelDirection: "negative",
      tickDirection: "negative",
      titlePosition: "top",
      titleSpacing: 12,
      labelSpacing: 4,
      titleTextBaseline: "middle"
    },
    axisBottom: {
      gridDirection: "negative",
      labelDirection: "positive",
      tickDirection: "positive",
      titlePosition: "bottom",
      titleSpacing: 12,
      labelSpacing: 4,
      titleTextBaseline: "bottom",
      titleTransform: "translate(0, 8)"
    },
    axisLeft: {
      gridDirection: "positive",
      labelDirection: "negative",
      labelSpacing: 4,
      tickDirection: "negative",
      titlePosition: "left",
      titleSpacing: 12,
      titleTextBaseline: "middle",
      titleDirection: "vertical",
      titleTransform: "rotate(-90) translate(0, -8)",
      titleTransformOrigin: "center"
    },
    axisRight: {
      gridDirection: "negative",
      labelDirection: "positive",
      labelSpacing: 4,
      tickDirection: "positive",
      titlePosition: "right",
      titleSpacing: 12,
      titleTextBaseline: "top",
      titleDirection: "vertical",
      titleTransformOrigin: "center"
    },
    axisLinear: {
      girdClosed: true,
      gridConnect: "arc",
      gridDirection: "negative",
      gridType: "surround",
      titlePosition: "top",
      titleSpacing: 0
    },
    axisArc: {
      title: false,
      titlePosition: "inner",
      line: false,
      tick: true,
      labelSpacing: 4
    },
    axisRadar: {
      girdClosed: true,
      gridStrokeOpacity: 0.3,
      gridType: "surround",
      tick: false,
      titlePosition: "start"
    },
    legendCategory: {
      backgroundFill: "transparent",
      itemBackgroundFill: "transparent",
      itemLabelFill: colorBlack,
      itemLabelFillOpacity: alpha90,
      itemLabelFontSize: 12,
      itemLabelFontWeight: "normal",
      itemMarkerFillOpacity: 1,
      itemMarkerSize: 8,
      focusMarkerSize: 12,
      itemSpacing: [padding1, padding1, padding1 / 2],
      itemValueFill: colorBlack,
      itemValueFillOpacity: 0.65,
      itemValueFontSize: 12,
      itemValueFontWeight: "normal",
      navButtonFill: colorBlack,
      navButtonFillOpacity: 0.65,
      navPageNumFill: colorBlack,
      navPageNumFillOpacity: 0.45,
      navPageNumFontSize: 12,
      padding: 8,
      title: false,
      titleFill: colorBlack,
      titleFillOpacity: 0.65,
      titleFontSize: 12,
      titleFontWeight: "normal",
      titleSpacing: 4,
      tickStroke: colorBlack,
      tickStrokeOpacity: 0.25,
      rowPadding: padding1,
      colPadding: padding2,
      maxRows: 3,
      maxCols: 3
    },
    legendContinuous: {
      handleHeight: 12,
      handleLabelFill: colorBlack,
      handleLabelFillOpacity: alpha45,
      handleLabelFontSize: 12,
      handleLabelFontWeight: "normal",
      handleMarkerFill: colorBlack,
      handleMarkerFillOpacity: 0.6,
      handleMarkerLineWidth: 1,
      handleMarkerStroke: colorBlack,
      handleMarkerStrokeOpacity: 0.25,
      handleWidth: 10,
      labelFill: colorBlack,
      labelFillOpacity: alpha45,
      labelFontSize: 12,
      labelFontWeight: "normal",
      labelSpacing: 3,
      tick: true,
      tickLength: 12,
      ribbonSize: 12,
      ribbonFill: "#aaa",
      handle: true,
      handleLabel: false,
      handleShape: "slider",
      handleIconSize: 12 / 1.8,
      indicator: false,
      titleFontSize: 12,
      titleSpacing: 4,
      titleFontWeight: "normal",
      titleFillOpacity: alpha90,
      tickStroke: colorBlack,
      tickStrokeOpacity: alpha45
    },
    label: {
      fill: colorBlack,
      fillOpacity: 0.65,
      fontSize: 12,
      fontWeight: "normal",
      stroke: void 0,
      offset: 12,
      connectorStroke: colorBlack,
      connectorStrokeOpacity: 0.45,
      connectorLineWidth: 1,
      connectorLength: 12,
      connectorLength2: 8,
      connectorDistance: 4
    },
    innerLabel: {
      fill: colorWhite,
      fontSize: 12,
      fillOpacity: 0.85,
      fontWeight: "normal",
      stroke: void 0,
      offset: 0
    },
    htmlLabel: {
      fontSize: 12,
      opacity: 0.65,
      color: colorBlack,
      fontWeight: "normal"
    },
    slider: {
      trackSize: 16,
      trackFill: colorStroke,
      trackFillOpacity: 1,
      selectionFill: colorDefault,
      selectionFillOpacity: 0.15,
      handleIconSize: 10,
      handleIconFill: "#f7f7f7",
      handleIconFillOpacity: 1,
      handleIconStroke: colorBlack,
      handleIconStrokeOpacity: 0.25,
      handleIconLineWidth: 1,
      handleIconRadius: 2,
      handleLabelFill: colorBlack,
      handleLabelFillOpacity: 0.45,
      handleLabelFontSize: 12,
      handleLabelFontWeight: "normal"
    },
    scrollbar: {
      padding: [0, 0, 0, 0],
      trackSize: 6,
      isRound: true,
      slidable: true,
      scrollable: true,
      trackFill: "#e5e5e5",
      trackFillOpacity: 0,
      thumbFill: "#000",
      thumbFillOpacity: 0.15,
      thumbHighlightedFillOpacity: 0.2
    },
    title: {
      spacing: 8,
      titleFill: colorBlack,
      titleFillOpacity: alpha90,
      titleFontSize: 16,
      titleFontWeight: "bold",
      titleTextBaseline: "top",
      subtitleFill: colorBlack,
      subtitleFillOpacity: alpha65,
      subtitleFontSize: 12,
      subtitleFontWeight: "normal",
      subtitleTextBaseline: "top"
    },
    tooltip: {
      css: {
        [g2Selector("tooltip")]: {
          "font-family": "sans-serif"
        }
      }
    }
  };
}

// node_modules/@antv/g2/esm/theme/light.js
var tokens = {
  colorBlack: "#1D2129",
  colorWhite: "#ffffff",
  colorStroke: "#416180",
  colorDefault: "#1783FF",
  colorBackground: "transparent",
  category10: [
    "#1783FF",
    "#00C9C9",
    "#F0884D",
    "#D580FF",
    "#7863FF",
    "#60C42D",
    "#BD8F24",
    "#FF80CA",
    "#2491B3",
    "#17C76F"
  ],
  category20: [
    "#1783FF",
    "#00C9C9",
    "#F0884D",
    "#D580FF",
    "#7863FF",
    "#60C42D",
    "#BD8F24",
    "#FF80CA",
    "#2491B3",
    "#17C76F",
    "#AABA01",
    "#BC7CFC",
    "#237CBC",
    "#2DE379",
    "#CE8032",
    "#FF7AF4",
    "#545FD3",
    "#AFE410",
    "#D8C608",
    "#FFA1E0"
  ],
  padding1: 8,
  padding2: 12,
  padding3: 20,
  alpha90: 0.9,
  alpha65: 0.65,
  alpha45: 0.45,
  alpha25: 0.25,
  alpha10: 0.1
};
var defaults = create(tokens);
var Light = (options) => {
  return deep_mix_default({}, defaults, options);
};
Light.props = {};

// node_modules/@antv/g2/esm/theme/classic.js
var Classic = (options) => {
  return deep_mix_default({}, Light(), {
    category10: "category10",
    category20: "category20"
  }, options);
};
Classic.props = {};

// node_modules/@antv/g2/esm/theme/dark.js
var tokens2 = {
  colorBlack: "#fff",
  colorWhite: "#000",
  colorStroke: "#416180",
  colorDefault: "#1783FF",
  colorBackground: "transparent",
  category10: [
    "#1783FF",
    "#00C9C9",
    "#F0884D",
    "#D580FF",
    "#7863FF",
    "#60C42D",
    "#BD8F24",
    "#FF80CA",
    "#2491B3",
    "#17C76F"
  ],
  category20: [
    "#1783FF",
    "#00C9C9",
    "#F0884D",
    "#D580FF",
    "#7863FF",
    "#60C42D",
    "#BD8F24",
    "#FF80CA",
    "#2491B3",
    "#17C76F",
    "#AABA01",
    "#BC7CFC",
    "#237CBC",
    "#2DE379",
    "#CE8032",
    "#FF7AF4",
    "#545FD3",
    "#AFE410",
    "#D8C608",
    "#FFA1E0"
  ],
  padding1: 8,
  padding2: 12,
  padding3: 20,
  alpha90: 0.9,
  alpha65: 0.65,
  alpha45: 0.45,
  alpha25: 0.25,
  alpha10: 0.25
};
var defaults2 = create(tokens2);
var Dark = (options) => {
  return deep_mix_default({}, defaults2, {
    tooltip: {
      crosshairsStroke: "#fff",
      crosshairsLineWidth: 1,
      crosshairsStrokeOpacity: 0.25,
      css: {
        [g2Selector("tooltip")]: {
          background: "#1f1f1f",
          opacity: 0.95
        },
        [g2Selector("tooltip-title")]: {
          color: "#A6A6A6"
        },
        [g2Selector("tooltip-list-item-name-label")]: {
          color: "#A6A6A6"
        },
        [g2Selector("tooltip-list-item-value")]: {
          color: "#A6A6A6"
        }
      }
    }
  }, options);
};

// node_modules/@antv/g2/esm/theme/classicDark.js
var ClassicDark = (options) => {
  return Object.assign({}, Dark(), {
    category10: "category10",
    category20: "category20"
  }, options);
};
ClassicDark.props = {};

// node_modules/@antv/g2/esm/theme/academy.js
var tokens3 = {
  colorBlack: "#000",
  colorWhite: "#fff",
  colorStroke: "#888",
  colorDefault: "#4e79a7",
  colorBackground: "transparent",
  category10: [
    "#4e79a7",
    "#f28e2c",
    "#e15759",
    "#76b7b2",
    "#59a14f",
    "#edc949",
    "#af7aa1",
    "#ff9da7",
    "#9c755f",
    "#bab0ab"
  ],
  category20: [
    "#4e79a7",
    "#f28e2c",
    "#e15759",
    "#76b7b2",
    "#59a14f",
    "#edc949",
    "#af7aa1",
    "#ff9da7",
    "#9c755f",
    "#bab0ab"
  ],
  padding1: 8,
  padding2: 12,
  padding3: 20,
  alpha90: 0.9,
  alpha65: 0.65,
  alpha45: 0.45,
  alpha25: 0.25,
  alpha10: 0.1
};
var defaults3 = create(tokens3);
var Academy = (options) => {
  return deep_mix_default({}, defaults3, {
    text: { text: { fontSize: 10 } },
    axis: {
      gridLineDash: [0, 0],
      gridLineWidth: 1,
      gridStroke: "#ddd",
      gridStrokeOpacity: 1,
      labelOpacity: 1,
      labelStrokeOpacity: 1,
      labelFontSize: 10,
      line: true,
      lineLineWidth: 1,
      lineStroke: "#888",
      lineStrokeOpacity: 1,
      tickLength: 5,
      tickStrokeOpacity: 1,
      titleOpacity: 1,
      titleStrokeOpacity: 1,
      titleFillOpacity: 1,
      titleFontSize: 11,
      titleFontWeight: "bold"
    },
    axisLeft: {
      gridFilter: (_, i2) => i2 !== 0
    },
    axisRight: {
      gridFilter: (_, i2) => i2 !== 0
    },
    legendCategory: {
      itemLabelFillOpacity: 1,
      itemLabelFontSize: 10,
      itemValueFillOpacity: 1,
      itemValueFontSize: 10,
      titleFillOpacity: 1,
      titleFontSize: 11,
      titleFontWeight: "bold"
    },
    legendContinuous: {
      handleLabelFontSize: 10,
      labelFillOpacity: 0.45,
      labelFontSize: 10
    },
    label: {
      fontSize: 10
    },
    innerLabel: {
      fontSize: 10
    },
    htmlLabel: {
      fontSize: 10
    },
    slider: {
      handleLabelFontSize: 10,
      trackFillOpacity: 0.05
    }
  }, options);
};
Academy.props = {};

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x2) {
  return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
}
function formatDecimalParts(x2, p3) {
  if ((i2 = (x2 = p3 ? x2.toExponential(p3 - 1) : x2.toExponential()).indexOf("e")) < 0) return null;
  var i2, coefficient = x2.slice(0, i2);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x2.slice(i2 + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x2) {
  return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value2, width) {
    var i2 = value2.length, t = [], j = 0, g = grouping[0], length = 0;
    while (i2 > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value2.substring(i2 -= g, i2 + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value2) {
    return value2.replace(/[0-9]/g, function(i2) {
      return numerals[+i2];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s3) {
  out: for (var n2 = s3.length, i2 = 1, i0 = -1, i1; i2 < n2; ++i2) {
    switch (s3[i2]) {
      case ".":
        i0 = i1 = i2;
        break;
      case "0":
        if (i0 === 0) i0 = i2;
        i1 = i2;
        break;
      default:
        if (!+s3[i2]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }
  return i0 > 0 ? s3.slice(0, i0) + s3.slice(i1 + 1) : s3;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x2, p3) {
  var d3 = formatDecimalParts(x2, p3);
  if (!d3) return x2 + "";
  var coefficient = d3[0], exponent = d3[1], i2 = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n2 = coefficient.length;
  return i2 === n2 ? coefficient : i2 > n2 ? coefficient + new Array(i2 - n2 + 1).join("0") : i2 > 0 ? coefficient.slice(0, i2) + "." + coefficient.slice(i2) : "0." + new Array(1 - i2).join("0") + formatDecimalParts(x2, Math.max(0, p3 + i2 - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x2, p3) {
  var d3 = formatDecimalParts(x2, p3);
  if (!d3) return x2 + "";
  var coefficient = d3[0], exponent = d3[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x2, p3) => (x2 * 100).toFixed(p3),
  "b": (x2) => Math.round(x2).toString(2),
  "c": (x2) => x2 + "",
  "d": formatDecimal_default,
  "e": (x2, p3) => x2.toExponential(p3),
  "f": (x2, p3) => x2.toFixed(p3),
  "g": (x2, p3) => x2.toPrecision(p3),
  "o": (x2) => Math.round(x2).toString(8),
  "p": (x2, p3) => formatRounded_default(x2 * 100, p3),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
  "x": (x2) => Math.round(x2).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default3(x2) {
  return x2;
}

// node_modules/d3-format/src/locale.js
var map3 = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale2) {
  var group2 = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity_default3 : formatGroup_default(map3.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity_default3 : formatNumerals_default(map3.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign3 = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
    if (type === "n") comma = true, type = "g";
    else if (!formatTypes_default[type]) precision === void 0 && (precision = 12), trim = true, type = "g";
    if (zero2 || fill === "0" && align === "=") zero2 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
    var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format3(value2) {
      var valuePrefix = prefix, valueSuffix = suffix, i2, n2, c5;
      if (type === "c") {
        valueSuffix = formatType(value2) + valueSuffix;
        value2 = "";
      } else {
        value2 = +value2;
        var valueNegative = value2 < 0 || 1 / value2 < 0;
        value2 = isNaN(value2) ? nan : formatType(Math.abs(value2), precision);
        if (trim) value2 = formatTrim_default(value2);
        if (valueNegative && +value2 === 0 && sign3 !== "+") valueNegative = false;
        valuePrefix = (valueNegative ? sign3 === "(" ? sign3 : minus : sign3 === "-" || sign3 === "(" ? "" : sign3) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign3 === "(" ? ")" : "");
        if (maybeSuffix) {
          i2 = -1, n2 = value2.length;
          while (++i2 < n2) {
            if (c5 = value2.charCodeAt(i2), 48 > c5 || c5 > 57) {
              valueSuffix = (c5 === 46 ? decimal + value2.slice(i2 + 1) : value2.slice(i2)) + valueSuffix;
              value2 = value2.slice(0, i2);
              break;
            }
          }
        }
      }
      if (comma && !zero2) value2 = group2(value2, Infinity);
      var length = valuePrefix.length + value2.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero2) value2 = group2(padding + value2, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value2 = valuePrefix + value2 + valueSuffix + padding;
          break;
        case "=":
          value2 = valuePrefix + padding + value2 + valueSuffix;
          break;
        case "^":
          value2 = padding.slice(0, length = padding.length >> 1) + valuePrefix + value2 + valueSuffix + padding.slice(length);
          break;
        default:
          value2 = padding + valuePrefix + value2 + valueSuffix;
          break;
      }
      return numerals(value2);
    }
    format3.toString = function() {
      return specifier + "";
    };
    return format3;
  }
  function formatPrefix2(specifier, value2) {
    var f2 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent_default(value2) / 3))) * 3, k2 = Math.pow(10, -e3), prefix = prefixes[8 + e3 / 3];
    return function(value3) {
      return f2(k2 * value3) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format2;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format2 = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/@antv/g2/esm/component/utils.js
var __rest53 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function createComponent(descriptor) {
  return class extends CustomElement {
    constructor(config) {
      super(config);
      this.descriptor = descriptor;
    }
    connectedCallback() {
      var _a, _b;
      (_b = (_a = this.descriptor).render) === null || _b === void 0 ? void 0 : _b.call(_a, this.attributes, this);
    }
    update(cfg = {}) {
      var _a, _b;
      this.attr(deep_mix_default({}, this.attributes, cfg));
      (_b = (_a = this.descriptor).render) === null || _b === void 0 ? void 0 : _b.call(_a, this.attributes, this);
    }
  };
}
function maybeAppend(parent, selector, node) {
  if (!parent.querySelector(selector)) {
    return select(parent).append(node);
  }
  return select(parent).select(selector);
}
function titleContent(field3) {
  return Array.isArray(field3) ? field3.join(", ") : `${field3 || ""}`;
}
function inferComponentLayout(position, userDefinitions) {
  const preset = {
    display: "flex",
    flexDirection: "row",
    justifyContent: "flex-start",
    alignItems: "center"
  };
  let { flexDirection, justifyContent, alignItems } = preset;
  const layout = {
    top: ["row", "flex-start", "center"],
    bottom: ["row", "flex-start", "center"],
    left: ["column", "flex-start", "center"],
    right: ["column", "flex-start", "center"],
    center: ["column", "center", "center"]
  };
  if (position in layout) {
    [flexDirection, justifyContent, alignItems] = layout[position];
  }
  return Object.assign({
    display: "flex",
    flexDirection,
    justifyContent,
    alignItems
  }, userDefinitions);
}
var G2Layout = class extends Layout {
  get child() {
    var _a;
    return (_a = this.children) === null || _a === void 0 ? void 0 : _a[0];
  }
  update(options) {
    var _a;
    this.attr(options);
    const { subOptions } = options;
    (_a = this.child) === null || _a === void 0 ? void 0 : _a.update(subOptions);
  }
};
var LegendCategoryLayout = class extends G2Layout {
  update(options) {
    var _a;
    const { subOptions } = options;
    this.attr(options);
    (_a = this.child) === null || _a === void 0 ? void 0 : _a.update(subOptions);
  }
};
function scaleOf(scales, type) {
  var _a;
  return (_a = scales.filter((s3) => s3.getOptions().name === type)) === null || _a === void 0 ? void 0 : _a[0];
}
function isHorizontal(orientation) {
  return orientation === "horizontal" || orientation === 0;
}
function isVertical(orientation) {
  return orientation === "vertical" || orientation === -Math.PI / 2;
}
function inferComponentShape(value2, options, component) {
  const { bbox } = value2;
  const { position = "top", size: userDefinedSize, length: userDefinedLength } = options;
  const isHorizontal2 = ["top", "bottom", "center"].includes(position);
  const [bboxSize, bboxLength] = isHorizontal2 ? [bbox.height, bbox.width] : [bbox.width, bbox.height];
  const { defaultSize, defaultLength } = component.props;
  const size4 = userDefinedSize || defaultSize || bboxSize;
  const length = userDefinedLength || defaultLength || bboxLength;
  const orientation = isHorizontal2 ? "horizontal" : "vertical";
  const [width, height] = isHorizontal2 ? [length, size4] : [size4, length];
  return {
    orientation,
    width,
    height,
    size: size4,
    length
  };
}
function domainOf2(scales) {
  return scales.find((scale4) => scale4.getOptions().domain.length > 0).getOptions().domain;
}
function adaptor(style) {
  const reservedKeys = [
    "arrow",
    "crosshairs",
    "grid",
    "handle",
    "handleLabel",
    "indicator",
    "label",
    "line",
    "tick",
    "tip",
    "title",
    "trunc"
  ];
  const { style: styles } = style, rest = __rest53(style, ["style"]);
  const finalStyle = {};
  Object.entries(rest).forEach(([key, value2]) => {
    if (reservedKeys.includes(key)) {
      finalStyle[`show${upper_first_default(key)}`] = value2;
    } else
      finalStyle[key] = value2;
  });
  return Object.assign(Object.assign({}, finalStyle), styles);
}

// node_modules/@antv/g2/esm/component/axis.js
var __rest54 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function rotateAxis(axis, options) {
  const { eulerAngles, origin } = options;
  if (origin) {
    axis.setOrigin(origin);
  }
  if (eulerAngles) {
    axis.rotate(eulerAngles[0], eulerAngles[1], eulerAngles[2]);
  }
}
function sizeOf(coordinate) {
  const { innerWidth, innerHeight, depth } = coordinate.getOptions();
  return [innerWidth, innerHeight, depth];
}
function createFisheye(position, coordinate) {
  const { width, height } = coordinate.getOptions();
  return (tick2) => {
    if (!isFisheye(coordinate))
      return tick2;
    const tickPoint = position === "bottom" ? [tick2, 1] : [0, tick2];
    const vector = coordinate.map(tickPoint);
    if (position === "bottom") {
      const v = vector[0];
      const x2 = new Linear({
        domain: [0, width],
        range: [0, 1]
      });
      return x2.map(v);
    } else if (position === "left") {
      const v = vector[1];
      const x2 = new Linear({
        domain: [0, height],
        range: [0, 1]
      });
      return x2.map(v);
    }
    return tick2;
  };
}
function ticksOf(scale4, domain, tickMethod) {
  if (scale4.getTicks)
    return scale4.getTicks();
  if (!tickMethod)
    return domain;
  const [min6, max7] = extent(domain, (d3) => +d3);
  const { tickCount } = scale4.getOptions();
  return tickMethod(min6, max7, tickCount);
}
function createInset(position, coordinate) {
  if (isPolar(coordinate))
    return (d3) => d3;
  const options = coordinate.getOptions();
  const { innerWidth, innerHeight, insetTop, insetBottom, insetLeft, insetRight } = options;
  const [start, end, size4] = position === "left" || position === "right" ? [insetTop, insetBottom, innerHeight] : [insetLeft, insetRight, innerWidth];
  const x2 = new Linear({
    domain: [0, 1],
    range: [start / size4, 1 - end / size4]
  });
  return (i2) => x2.map(i2);
}
function getData(scale4, domain, tickCount, defaultTickFormatter, tickFilter, tickMethod, position, coordinate) {
  var _a;
  if (tickCount !== void 0 || tickMethod !== void 0) {
    scale4.update(Object.assign(Object.assign({}, tickCount && { tickCount }), tickMethod && { tickMethod }));
  }
  const ticks2 = ticksOf(scale4, domain, tickMethod);
  const filteredTicks = tickFilter ? ticks2.filter(tickFilter) : ticks2;
  const toString5 = (d3) => d3 instanceof Date ? String(d3) : typeof d3 === "object" && !!d3 ? d3 : String(d3);
  const labelFormatter = defaultTickFormatter || ((_a = scale4.getFormatter) === null || _a === void 0 ? void 0 : _a.call(scale4)) || toString5;
  const applyInset = createInset(position, coordinate);
  const applyFisheye = createFisheye(position, coordinate);
  const isHorizontal2 = (position2) => ["top", "bottom", "center", "outer"].includes(position2);
  const isVertical2 = (position2) => ["left", "right"].includes(position2);
  if (isPolar(coordinate) || isTranspose(coordinate)) {
    return filteredTicks.map((d3, i2, array2) => {
      var _a2, _b;
      const offset2 = ((_a2 = scale4.getBandWidth) === null || _a2 === void 0 ? void 0 : _a2.call(scale4, d3)) / 2 || 0;
      const tick2 = applyInset(scale4.map(d3) + offset2);
      const shouldReverse = isRadial(coordinate) && position === "center" || isTranspose(coordinate) && ((_b = scale4.getTicks) === null || _b === void 0 ? void 0 : _b.call(scale4)) && isHorizontal2(position) || isTranspose(coordinate) && isVertical2(position);
      return {
        value: shouldReverse ? 1 - tick2 : tick2,
        label: toString5(labelFormatter(prettyNumber2(d3), i2, array2)),
        id: String(i2)
      };
    });
  }
  return filteredTicks.map((d3, i2, array2) => {
    var _a2;
    const offset2 = ((_a2 = scale4.getBandWidth) === null || _a2 === void 0 ? void 0 : _a2.call(scale4, d3)) / 2 || 0;
    const tick2 = applyFisheye(applyInset(scale4.map(d3) + offset2));
    const shouldReverse = isVertical2(position);
    return {
      value: shouldReverse ? 1 - tick2 : tick2,
      label: toString5(labelFormatter(prettyNumber2(d3), i2, array2)),
      id: String(i2)
    };
  });
}
function inferGridLength(position, coordinate, plane = "xy") {
  const [width, height, depth] = sizeOf(coordinate);
  if (plane === "xy") {
    if (position.includes("bottom") || position.includes("top"))
      return height;
    return width;
  } else if (plane === "xz") {
    if (position.includes("bottom") || position.includes("top"))
      return depth;
    return width;
  } else {
    if (position.includes("bottom") || position.includes("top"))
      return height;
    return depth;
  }
}
function inferLabelOverlap(transform2 = [], style) {
  if (transform2.length > 0)
    return transform2;
  const { labelAutoRotate, labelAutoHide, labelAutoEllipsis, labelAutoWrap } = style;
  const finalTransforms = [];
  const addToTransforms = (overlap, state) => {
    if (state) {
      finalTransforms.push(Object.assign(Object.assign({}, overlap), state));
    }
  };
  addToTransforms({
    type: "rotate",
    optionalAngles: [0, 15, 30, 45, 60, 90]
  }, labelAutoRotate);
  addToTransforms({ type: "ellipsis", minLength: 20 }, labelAutoEllipsis);
  addToTransforms({ type: "hide" }, labelAutoHide);
  addToTransforms({ type: "wrap", wordWrapWidth: 100, maxLines: 3, recoveryWhenFail: true }, labelAutoWrap);
  return finalTransforms;
}
function inferArcStyle(position, bbox, innerRadius, outerRadius, coordinate) {
  const { x: x2, y: y3, width, height } = bbox;
  const center2 = [x2 + width / 2, y3 + height / 2];
  const radius = Math.min(width, height) / 2;
  const [startAngle, endAngle] = angleOf(coordinate);
  const [w2, h2] = sizeOf(coordinate);
  const r2 = Math.min(w2, h2) / 2;
  const common = {
    center: center2,
    radius,
    startAngle,
    endAngle,
    gridLength: (outerRadius - innerRadius) * r2
  };
  if (position === "inner") {
    const { insetLeft, insetTop } = coordinate.getOptions();
    return Object.assign(Object.assign({}, common), { center: [center2[0] - insetLeft, center2[1] - insetTop], labelAlign: "perpendicular", labelDirection: "positive", tickDirection: "positive", gridDirection: "negative" });
  }
  return Object.assign(Object.assign({}, common), { labelAlign: "parallel", labelDirection: "negative", tickDirection: "negative", gridDirection: "positive" });
}
function inferGrid(value2, coordinate, scale4) {
  if (isTheta(coordinate) || isParallel(coordinate))
    return false;
  return value2 === void 0 ? !!scale4.getTicks : value2;
}
function infer3DAxisLinearOverrideStyle(coordinate) {
  const { depth } = coordinate.getOptions();
  return depth ? {
    tickIsBillboard: true,
    lineIsBillboard: true,
    labelIsBillboard: true,
    titleIsBillboard: true,
    gridIsBillboard: true
  } : {};
}
function inferAxisLinearOverrideStyle(position, orientation, bbox, coordinate, xScale) {
  const { x: x2, y: y3, width, height } = bbox;
  if (position === "bottom") {
    return { startPos: [x2, y3], endPos: [x2 + width, y3] };
  }
  if (position === "left") {
    return { startPos: [x2 + width, y3 + height], endPos: [x2 + width, y3] };
  }
  if (position === "right") {
    return { startPos: [x2, y3 + height], endPos: [x2, y3] };
  }
  if (position === "top") {
    return { startPos: [x2, y3 + height], endPos: [x2 + width, y3 + height] };
  }
  if (position === "center") {
    if (orientation === "vertical") {
      return {
        startPos: [x2, y3],
        endPos: [x2, y3 + height]
      };
    } else if (orientation === "horizontal") {
      return {
        startPos: [x2, y3],
        endPos: [x2 + width, y3]
      };
    } else if (typeof orientation === "number") {
      const [cx, cy] = coordinate.getCenter();
      const [innerRadius, outerRadius] = radiusOf(coordinate);
      const [startAngle, endAngle] = angleOf(coordinate);
      const r2 = Math.min(width, height) / 2;
      const { insetLeft, insetTop } = coordinate.getOptions();
      const innerR = innerRadius * r2;
      const outerR = outerRadius * r2;
      const [actualCx, actualCy] = [cx + x2 - insetLeft, cy + y3 - insetTop];
      const [cos3, sin3] = [Math.cos(orientation), Math.sin(orientation)];
      const startPos = [
        actualCx + outerR * cos3,
        actualCy + outerR * sin3
      ];
      const endPos = [
        actualCx + innerR * cos3,
        actualCy + innerR * sin3
      ];
      const getAxisXDomainLength = () => {
        const { domain } = xScale.getOptions();
        return domain.length;
      };
      const controllAngleCount = isPolar(coordinate) && xScale ? getAxisXDomainLength() : 3;
      return {
        startPos,
        endPos,
        gridClosed: Math.abs(endAngle - startAngle - 360) < 1e-6,
        gridCenter: [actualCx, actualCy],
        gridControlAngles: new Array(controllAngleCount).fill(0).map((d3, i2, arr) => (endAngle - startAngle) / controllAngleCount * i2)
      };
    }
  }
  return {};
}
var ArcAxisComponent = (options) => {
  const { order, size: size4, position, orientation, labelFormatter, tickFilter, tickCount, tickMethod, tickLength, important = {}, style = {}, indexBBox, title, grid = false } = options, rest = __rest54(options, ["order", "size", "position", "orientation", "labelFormatter", "tickFilter", "tickCount", "tickMethod", "tickLength", "important", "style", "indexBBox", "title", "grid"]);
  return ({ scales: [scale4], value: value2, coordinate, theme }) => {
    const { bbox } = value2;
    const { domain } = scale4.getOptions();
    const data = getData(scale4, domain, tickCount, labelFormatter, tickFilter, tickMethod, position, coordinate);
    const labels = indexBBox ? data.map((d3, i2) => {
      const bbox2 = indexBBox.get(i2);
      if (!bbox2)
        return d3;
      if (bbox2[0] !== d3.label)
        return d3;
      return Object.assign(Object.assign({}, d3), { bbox: bbox2[1] });
    }) : data;
    const [innerRadius, outerRadius] = radiusOf(coordinate);
    const defaultStyle2 = inferArcStyle(position, bbox, innerRadius, outerRadius, coordinate);
    const { axis: axisTheme, axisArc = {} } = theme;
    const finalStyle = adaptor(deep_mix_default({}, axisTheme, axisArc, defaultStyle2, Object.assign(Object.assign(Object.assign({ type: "arc", data: labels, titleText: titleContent(title), grid, classNamePrefix: G2_CLASS_PREFIX }, tickLength !== void 0 ? { tickLength } : null), rest), important)));
    return new Axis({
      // @fixme transform is not valid for arcAxis.
      // @ts-ignore
      style: omit_default(finalStyle, ["transform"])
    });
  };
};
function inferThemeStyle(scale4, coordinate, theme, direction2, position, orientation) {
  const baseStyle = theme.axis;
  const positionStyle = ["top", "right", "bottom", "left"].includes(position) ? theme[`axis${capitalizeFirst(position)}`] : theme.axisLinear;
  const channel = scale4.getOptions().name;
  const channelStyle = theme[`axis${upper_first_default(channel)}`] || {};
  return Object.assign({}, baseStyle, positionStyle, channelStyle);
}
function inferDefaultStyle(scale4, coordinate, theme, direction2, position, orientation) {
  const themeStyle = inferThemeStyle(scale4, coordinate, theme, direction2, position, orientation);
  if (position === "center") {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, themeStyle), { labelDirection: direction2 === "right" ? "negative" : "positive" }), direction2 === "center" ? { labelTransform: "translate(50%,0)" } : null), { tickDirection: direction2 === "right" ? "negative" : "positive", labelSpacing: direction2 === "center" ? 0 : 4, titleSpacing: isVertical(orientation) ? 10 : 0, tick: direction2 === "center" ? false : void 0 });
  }
  return themeStyle;
}
var LinearAxisComponent = (options) => {
  const { direction: direction2 = "left", important = {}, labelFormatter, order, orientation, actualPosition, position, size: size4, style = {}, title, tickCount, tickFilter, tickMethod, tickLength, transform: transform2, indexBBox } = options, userDefinitions = __rest54(options, ["direction", "important", "labelFormatter", "order", "orientation", "actualPosition", "position", "size", "style", "title", "tickCount", "tickFilter", "tickMethod", "tickLength", "transform", "indexBBox"]);
  return ({ scales, value: value2, coordinate, theme }) => {
    const { bbox } = value2;
    const [scale4] = scales;
    const { domain, xScale } = scale4.getOptions();
    const defaultStyle2 = inferDefaultStyle(scale4, coordinate, theme, direction2, position, orientation);
    const internalAxisStyle = Object.assign(Object.assign(Object.assign({}, defaultStyle2), style), userDefinitions);
    const gridLength = inferGridLength(actualPosition || position, coordinate, options.plane);
    const overrideStyle = inferAxisLinearOverrideStyle(position, orientation, bbox, coordinate, xScale);
    const threeDOverrideStyle = infer3DAxisLinearOverrideStyle(coordinate);
    const data = getData(scale4, domain, tickCount, labelFormatter, tickFilter, tickMethod, position, coordinate);
    const labels = indexBBox ? data.map((d3, i2) => {
      const bbox2 = indexBBox.get(i2);
      if (!bbox2)
        return d3;
      if (bbox2[0] !== d3.label)
        return d3;
      return Object.assign(Object.assign({}, d3), { bbox: bbox2[1] });
    }) : data;
    const finalAxisStyle = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, internalAxisStyle), {
      type: "linear",
      data: labels,
      crossSize: size4,
      titleText: titleContent(title),
      labelOverlap: inferLabelOverlap(transform2, internalAxisStyle),
      grid: inferGrid(internalAxisStyle.grid, coordinate, scale4),
      gridLength,
      // Always showLine, make title could align the end of axis.
      line: true,
      indexBBox,
      classNamePrefix: G2_CLASS_PREFIX
    }), tickLength !== void 0 ? { tickLength } : null), !internalAxisStyle.line ? { lineOpacity: 0 } : null), overrideStyle), threeDOverrideStyle), important);
    const hasHide = finalAxisStyle.labelOverlap.find((d3) => d3.type === "hide");
    if (hasHide)
      finalAxisStyle.crossSize = false;
    return new Axis({
      className: "axis",
      style: adaptor(finalAxisStyle)
    });
  };
};
var axisFactor = (axis) => {
  return (options) => {
    const { labelFormatter: useDefinedLabelFormatter, labelFilter: userDefinedLabelFilter = () => true } = options;
    return (context) => {
      var _a;
      const { scales: [scale4] } = context;
      const ticks2 = ((_a = scale4.getTicks) === null || _a === void 0 ? void 0 : _a.call(scale4)) || scale4.getOptions().domain;
      const labelFormatter = typeof useDefinedLabelFormatter === "string" ? format2(useDefinedLabelFormatter) : useDefinedLabelFormatter;
      const labelFilter = (datum, index2, array2) => userDefinedLabelFilter(ticks2[index2], index2, ticks2);
      const normalizedOptions = Object.assign(Object.assign({}, options), {
        labelFormatter,
        labelFilter,
        scale: scale4
      });
      return axis(normalizedOptions)(context);
    };
  };
};
var LinearAxis = axisFactor(LinearAxisComponent);
var ArcAxis = axisFactor(ArcAxisComponent);
LinearAxis.props = {
  defaultPosition: "center",
  defaultSize: 45,
  defaultOrder: 0,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};
ArcAxis.props = {
  defaultPosition: "outer",
  defaultOrientation: "vertical",
  defaultSize: 45,
  defaultOrder: 0,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/component/axisX.js
var AxisX = (options) => {
  return (...args) => {
    const axisX = LinearAxis(Object.assign({}, { crossPadding: 50 }, options))(...args);
    rotateAxis(axisX, options);
    return axisX;
  };
};
AxisX.props = Object.assign(Object.assign({}, LinearAxis.props), { defaultPosition: "bottom" });

// node_modules/@antv/g2/esm/component/axisY.js
var AxisY = (options) => {
  return (...args) => {
    const axisY = LinearAxis(Object.assign({}, { crossPadding: 10 }, options))(...args);
    rotateAxis(axisY, options);
    return axisY;
  };
};
AxisY.props = Object.assign(Object.assign({}, LinearAxis.props), { defaultPosition: "left" });

// node_modules/@antv/g2/esm/component/axisRadar.js
var __rest55 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function inferTitleTransform(orientation) {
  const internalOrientation = orientation % (Math.PI * 2);
  if (internalOrientation === Math.PI / 2) {
    return { titleTransform: "translate(0, 50%)" };
  }
  if (internalOrientation > -Math.PI / 2 && internalOrientation < Math.PI / 2) {
    return { titleTransform: "translate(50%, 0)" };
  }
  if (internalOrientation > Math.PI / 2 && internalOrientation < Math.PI * 3 / 2) {
    return { titleTransform: "translate(-50%, 0)" };
  }
  return {};
}
function inferAxisStyle(options, theme, coordinate, scales) {
  const { radar } = options;
  const [scale4] = scales;
  const name2 = scale4.getOptions().name;
  const [startAngle, endAngle] = angleOf(coordinate);
  const { axisRadar: radarTheme = {} } = theme;
  return Object.assign(Object.assign({}, radarTheme), { grid: name2 === "position", gridConnect: "line", gridControlAngles: new Array(radar.count).fill(0).map((_, i2) => {
    const angle2 = (endAngle - startAngle) / radar.count;
    return angle2 * i2;
  }) });
}
var AxisRadar = (options) => {
  const { important = {} } = options, restOptions = __rest55(options, ["important"]);
  return (context) => {
    const { theme, coordinate, scales } = context;
    return LinearAxis(Object.assign(Object.assign(Object.assign({}, restOptions), inferTitleTransform(options.orientation)), { important: Object.assign(Object.assign({}, inferAxisStyle(options, theme, coordinate, scales)), important) }))(context);
  };
};
AxisRadar.props = Object.assign(Object.assign({}, LinearAxis.props), { defaultPosition: "center" });

// node_modules/@antv/g2/esm/utils/event.js
var ChartEvent = {
  BEFORE_RENDER: "beforerender",
  AFTER_RENDER: "afterrender",
  BEFORE_PAINT: "beforepaint",
  AFTER_PAINT: "afterpaint",
  BEFORE_CHANGE_DATA: "beforechangedata",
  AFTER_CHANGE_DATA: "afterchangedata",
  BEFORE_CLEAR: "beforeclear",
  AFTER_CLEAR: "afterclear",
  BEFORE_DESTROY: "beforedestroy",
  AFTER_DESTROY: "afterdestroy",
  BEFORE_CHANGE_SIZE: "beforechangesize",
  AFTER_CHANGE_SIZE: "afterchangesize",
  POINTER_TAP: "pointertap",
  POINTER_DOWN: "pointerdown",
  POINTER_UP: "pointerup",
  POINTER_OVER: "pointerover",
  POINTER_OUT: "pointerout",
  POINTER_MOVE: "pointermove",
  POINTER_ENTER: "pointerenter",
  POINTER_LEAVE: "pointerleave",
  POINTER_UPOUTSIDE: "pointerupoutside",
  DRAG_START: "dragstart",
  DRAG: "drag",
  DRAG_END: "dragend",
  DRAG_ENTER: "dragenter",
  DRAG_LEAVE: "dragleave",
  DRAG_OVER: "dragover",
  DROP: "DROP",
  CLICK: "click",
  DBLCLICK: "dblclick"
};

// node_modules/@antv/expr/dist/index.esm.js
var e = { abs: Math.abs, ceil: Math.ceil, floor: Math.floor, max: Math.max, min: Math.min, round: Math.round, sqrt: Math.sqrt, pow: Math.pow };
var n = class extends Error {
  constructor(e3, t, n2) {
    super(e3), this.position = t, this.token = n2, this.name = "ExpressionError";
  }
};
var r;
!function(e3) {
  e3[e3.STRING = 0] = "STRING", e3[e3.NUMBER = 1] = "NUMBER", e3[e3.BOOLEAN = 2] = "BOOLEAN", e3[e3.NULL = 3] = "NULL", e3[e3.IDENTIFIER = 4] = "IDENTIFIER", e3[e3.OPERATOR = 5] = "OPERATOR", e3[e3.FUNCTION = 6] = "FUNCTION", e3[e3.DOT = 7] = "DOT", e3[e3.BRACKET_LEFT = 8] = "BRACKET_LEFT", e3[e3.BRACKET_RIGHT = 9] = "BRACKET_RIGHT", e3[e3.PAREN_LEFT = 10] = "PAREN_LEFT", e3[e3.PAREN_RIGHT = 11] = "PAREN_RIGHT", e3[e3.COMMA = 12] = "COMMA", e3[e3.QUESTION = 13] = "QUESTION", e3[e3.COLON = 14] = "COLON", e3[e3.DOLLAR = 15] = "DOLLAR";
}(r || (r = {}));
var o = /* @__PURE__ */ new Set([32, 9, 10, 13]);
var a3 = /* @__PURE__ */ new Set([43, 45, 42, 47, 37, 33, 38, 124, 61, 60, 62]);
var s2 = /* @__PURE__ */ new Map([["true", r.BOOLEAN], ["false", r.BOOLEAN], ["null", r.NULL]]);
var i = /* @__PURE__ */ new Map([["===", true], ["!==", true], ["<=", true], [">=", true], ["&&", true], ["||", true], ["+", true], ["-", true], ["*", true], ["/", true], ["%", true], ["!", true], ["<", true], [">", true]]);
var u = /* @__PURE__ */ new Map([[46, r.DOT], [91, r.BRACKET_LEFT], [93, r.BRACKET_RIGHT], [40, r.PAREN_LEFT], [41, r.PAREN_RIGHT], [44, r.COMMA], [63, r.QUESTION], [58, r.COLON], [36, r.DOLLAR]]);
var c2 = /* @__PURE__ */ new Map();
for (const [e3, t] of u.entries()) c2.set(e3, { type: t, value: String.fromCharCode(e3) });
function p2(e3) {
  return e3 >= 48 && e3 <= 57;
}
function l(e3) {
  return e3 >= 97 && e3 <= 122 || e3 >= 65 && e3 <= 90 || 95 === e3;
}
function f(e3) {
  return l(e3) || p2(e3);
}
function E(e3) {
  return a3.has(e3);
}
var h;
!function(e3) {
  e3[e3.Program = 0] = "Program", e3[e3.Literal = 1] = "Literal", e3[e3.Identifier = 2] = "Identifier", e3[e3.MemberExpression = 3] = "MemberExpression", e3[e3.CallExpression = 4] = "CallExpression", e3[e3.BinaryExpression = 5] = "BinaryExpression", e3[e3.UnaryExpression = 6] = "UnaryExpression", e3[e3.ConditionalExpression = 7] = "ConditionalExpression";
}(h || (h = {}));
var d = /* @__PURE__ */ new Map([["||", 2], ["&&", 3], ["===", 4], ["!==", 4], [">", 5], [">=", 5], ["<", 5], ["<=", 5], ["+", 6], ["-", 6], ["*", 7], ["/", 7], ["%", 7], ["!", 8]]);
var R = { type: h.Literal, value: null };
var T = { type: h.Literal, value: true };
var w = { type: h.Literal, value: false };
var y2 = (e3) => {
  let t = 0;
  const o2 = e3.length, a4 = () => t >= o2 ? null : e3[t], s3 = () => e3[t++], i2 = (e4) => {
    const t2 = a4();
    return null !== t2 && t2.type === e4;
  }, u2 = (e4) => e4.type === r.OPERATOR ? d.get(e4.value) || -1 : e4.type === r.DOT || e4.type === r.BRACKET_LEFT ? 9 : e4.type === r.QUESTION ? 1 : -1, c5 = (e4) => {
    let o3, u3;
    if (s3().type === r.DOT) {
      if (!i2(r.IDENTIFIER)) {
        const e7 = a4();
        throw new n("Expected property name", t, e7 ? e7.value : "<end of input>");
      }
      const e6 = s3();
      o3 = { type: h.Identifier, name: e6.value }, u3 = false;
    } else {
      if (o3 = l2(0), !i2(r.BRACKET_RIGHT)) {
        const e6 = a4();
        throw new n("Expected closing bracket", t, e6 ? e6.value : "<end of input>");
      }
      s3(), u3 = true;
    }
    return { type: h.MemberExpression, object: e4, property: o3, computed: u3 };
  }, p3 = () => {
    const e4 = a4();
    if (!e4) throw new n("Unexpected end of input", t, "<end of input>");
    if (e4.type === r.OPERATOR && ("!" === e4.value || "-" === e4.value)) {
      s3();
      const t2 = p3();
      return { type: h.UnaryExpression, operator: e4.value, argument: t2, prefix: true };
    }
    switch (e4.type) {
      case r.NUMBER:
        return s3(), { type: h.Literal, value: Number(e4.value) };
      case r.STRING:
        return s3(), { type: h.Literal, value: e4.value };
      case r.BOOLEAN:
        return s3(), "true" === e4.value ? T : w;
      case r.NULL:
        return s3(), R;
      case r.IDENTIFIER:
        return s3(), { type: h.Identifier, name: e4.value };
      case r.FUNCTION:
        return (() => {
          const e6 = s3(), o3 = [];
          if (!i2(r.PAREN_LEFT)) {
            const e7 = a4();
            throw new n("Expected opening parenthesis after function name", t, e7 ? e7.value : "<end of input>");
          }
          for (s3(); ; ) {
            if (i2(r.PAREN_RIGHT)) {
              s3();
              break;
            }
            if (!a4()) {
              const e8 = a4();
              throw new n("Expected closing parenthesis", t, e8 ? e8.value : "<end of input>");
            }
            if (o3.length > 0) {
              if (!i2(r.COMMA)) {
                const e8 = a4();
                throw new n("Expected comma between function arguments", t, e8 ? e8.value : "<end of input>");
              }
              s3();
            }
            const e7 = l2(0);
            o3.push(e7);
          }
          return { type: h.CallExpression, callee: { type: h.Identifier, name: e6.value }, arguments: o3 };
        })();
      case r.PAREN_LEFT: {
        s3();
        const e6 = l2(0);
        if (!i2(r.PAREN_RIGHT)) {
          const e7 = a4();
          throw new n("Expected closing parenthesis", t, e7 ? e7.value : "<end of input>");
        }
        return s3(), e6;
      }
      default:
        throw new n(`Unexpected token: ${e4.type}`, t, e4.value);
    }
  }, l2 = (f3 = 0) => {
    let E2 = p3();
    for (; t < o2; ) {
      const o3 = e3[t], p4 = u2(o3);
      if (p4 <= f3) break;
      if (o3.type !== r.QUESTION) if (o3.type !== r.OPERATOR) {
        if (o3.type !== r.DOT && o3.type !== r.BRACKET_LEFT) break;
        E2 = c5(E2);
      } else {
        s3();
        const e4 = l2(p4);
        E2 = { type: h.BinaryExpression, operator: o3.value, left: E2, right: e4 };
      }
      else {
        s3();
        const e4 = l2(0);
        if (!i2(r.COLON)) {
          const e6 = a4();
          throw new n("Expected : in conditional expression", t, e6 ? e6.value : "<end of input>");
        }
        s3();
        const o4 = l2(0);
        E2 = { type: h.ConditionalExpression, test: E2, consequent: e4, alternate: o4 };
      }
    }
    return E2;
  }, f2 = l2();
  return { type: h.Program, body: f2 };
};
var O = (e3, t, r2) => {
  let o2 = t;
  r2 && (o2 = __spreadProps(__spreadValues({}, t), { context: __spreadValues(__spreadValues({}, t.context), r2) }));
  const a4 = (e4) => {
    switch (e4.type) {
      case h.Literal:
        return ((e6) => e6.value)(e4);
      case h.Identifier:
        return ((e6) => {
          if (!(e6.name in o2.context)) throw new n(`Undefined variable: ${e6.name}`);
          return o2.context[e6.name];
        })(e4);
      case h.MemberExpression:
        return ((e6) => {
          const t2 = a4(e6.object);
          if (null == t2) throw new n("Cannot access property of null or undefined");
          return t2[e6.computed ? a4(e6.property) : e6.property.name];
        })(e4);
      case h.CallExpression:
        return ((e6) => {
          const t2 = o2.functions[e6.callee.name];
          if (!t2) throw new n(`Undefined function: ${e6.callee.name}`);
          return t2(...e6.arguments.map((e7) => a4(e7)));
        })(e4);
      case h.BinaryExpression:
        return ((e6) => {
          if ("&&" === e6.operator) {
            const t3 = a4(e6.left);
            return t3 ? a4(e6.right) : t3;
          }
          if ("||" === e6.operator) {
            return a4(e6.left) || a4(e6.right);
          }
          const t2 = a4(e6.left), r3 = a4(e6.right);
          switch (e6.operator) {
            case "+":
              return t2 + r3;
            case "-":
              return t2 - r3;
            case "*":
              return t2 * r3;
            case "/":
              return t2 / r3;
            case "%":
              return t2 % r3;
            case "===":
              return t2 === r3;
            case "!==":
              return t2 !== r3;
            case ">":
              return t2 > r3;
            case ">=":
              return t2 >= r3;
            case "<":
              return t2 < r3;
            case "<=":
              return t2 <= r3;
            default:
              throw new n(`Unknown operator: ${e6.operator}`);
          }
        })(e4);
      case h.UnaryExpression:
        return ((e6) => {
          const t2 = a4(e6.argument);
          if (e6.prefix) switch (e6.operator) {
            case "!":
              return !t2;
            case "-":
              if ("number" != typeof t2) throw new n(`Cannot apply unary - to non-number: ${t2}`);
              return -t2;
            default:
              throw new n(`Unknown operator: ${e6.operator}`);
          }
          throw new n(`Postfix operators are not supported: ${e6.operator}`);
        })(e4);
      case h.ConditionalExpression:
        return ((e6) => {
          const t2 = a4(e6.test);
          return a4(t2 ? e6.consequent : e6.alternate);
        })(e4);
      default:
        throw new n(`Evaluation error: Unsupported node type: ${e4.type}`);
    }
  };
  return a4(e3.body);
};
function A(t) {
  const a4 = ((e3) => {
    const t2 = e3, a5 = t2.length, u3 = new Array(Math.ceil(a5 / 3));
    let h3 = 0, d3 = 0;
    function R2(e4) {
      const o2 = d3 + 1;
      d3++;
      let s3 = "", i2 = false;
      for (; d3 < a5; ) {
        const n2 = t2.charCodeAt(d3);
        if (n2 === e4) return i2 || (s3 = t2.substring(o2, d3)), d3++, { type: r.STRING, value: s3 };
        92 === n2 ? (i2 || (s3 = t2.substring(o2, d3), i2 = true), d3++, s3 += t2[d3]) : i2 && (s3 += t2[d3]), d3++;
      }
      throw new n(`Unterminated string starting with ${String.fromCharCode(e4)}`, d3, t2.substring(Math.max(0, d3 - 10), d3));
    }
    function T2() {
      const e4 = d3;
      for (45 === t2.charCodeAt(d3) && d3++; d3 < a5 && p2(t2.charCodeAt(d3)); ) d3++;
      if (d3 < a5 && 46 === t2.charCodeAt(d3)) for (d3++; d3 < a5 && p2(t2.charCodeAt(d3)); ) d3++;
      const n2 = t2.slice(e4, d3);
      return { type: r.NUMBER, value: n2 };
    }
    function w2() {
      d3++;
      const e4 = d3;
      if (d3 < a5 && l(t2.charCodeAt(d3))) for (d3++; d3 < a5 && f(t2.charCodeAt(d3)); ) d3++;
      const n2 = t2.slice(e4, d3);
      return { type: r.FUNCTION, value: n2 };
    }
    function y3() {
      const e4 = d3++;
      for (; d3 < a5 && f(t2.charCodeAt(d3)); ) d3++;
      const n2 = t2.slice(e4, d3), o2 = s2.get(n2);
      return o2 ? { type: o2, value: n2 } : { type: r.IDENTIFIER, value: n2 };
    }
    function O2() {
      if (d3 + 2 < a5) {
        const e6 = t2.substring(d3, d3 + 3);
        if (i.has(e6)) return d3 += 3, { type: r.OPERATOR, value: e6 };
      }
      if (d3 + 1 < a5) {
        const e6 = t2.substring(d3, d3 + 2);
        if (i.has(e6)) return d3 += 2, { type: r.OPERATOR, value: e6 };
      }
      const e4 = t2[d3];
      if (i.has(e4)) return d3++, { type: r.OPERATOR, value: e4 };
      throw new n(`Unknown operator at position ${d3}: ${t2.substring(d3, d3 + 1)}`, d3, t2.substring(Math.max(0, d3 - 10), d3));
    }
    for (; d3 < a5; ) {
      const e4 = t2.charCodeAt(d3);
      if (A5 = e4, o.has(A5)) {
        d3++;
        continue;
      }
      const r2 = c2.get(e4);
      if (r2) u3[h3++] = r2, d3++;
      else if (34 !== e4 && 39 !== e4) if (p2(e4) || 45 === e4 && d3 + 1 < a5 && p2(t2.charCodeAt(d3 + 1))) u3[h3++] = T2();
      else if (64 !== e4) if (l(e4)) u3[h3++] = y3();
      else {
        if (!E(e4)) throw new n(`Unexpected character: ${t2[d3]}`, d3, t2.substring(Math.max(0, d3 - 10), d3));
        u3[h3++] = O2();
      }
      else u3[h3++] = w2();
      else u3[h3++] = R2(e4);
    }
    var A5;
    return h3 === u3.length ? u3 : u3.slice(0, h3);
  })(t), u2 = y2(a4), h2 = /* @__PURE__ */ ((e3 = {}, t2 = {}) => ({ context: e3, functions: t2 }))({}, e);
  return (e3 = {}) => O(u2, h2, e3);
}

// node_modules/@antv/g2/esm/utils/expr.js
var EXPR_WHITE_LIST = ["style", "encode", "labels", "children"];
var compileExpression = lru((expr) => {
  const evaluator = A(expr);
  return (...args) => {
    const paramNames = Array.from({ length: args.length }, (_, i2) => String.fromCharCode(97 + i2));
    const namedParams = Object.fromEntries(args.map((value2, index2) => [paramNames[index2], value2]));
    return evaluator(Object.assign(Object.assign({}, namedParams), { global: Object.assign({}, namedParams) }));
  };
}, (expr) => expr, 128);
function parseOptionsExpr(options, isSpecRoot = true) {
  if (Array.isArray(options)) {
    return options.map((_, i2) => parseOptionsExpr(options[i2], isSpecRoot));
  }
  if (typeof options === "object" && options) {
    return map_values_default(options, (value2, key) => {
      if (isSpecRoot && EXPR_WHITE_LIST.includes(key)) {
        return parseOptionsExpr(value2, key === "children");
      }
      if (!isSpecRoot) {
        return parseOptionsExpr(value2, false);
      }
      return value2;
    });
  }
  if (typeof options === "string") {
    const trimmed = options.trim();
    if (trimmed.startsWith("{") && trimmed.endsWith("}")) {
      return compileExpression(trimmed.slice(1, -1));
    }
  }
  return options;
}

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-type.js
var toString = {}.toString;
var isType = function(value2, type) {
  return toString.call(value2) === "[object " + type + "]";
};
var is_type_default = isType;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-function.js
var is_function_default = function(value2) {
  return is_type_default(value2, "Function");
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-array.js
var is_array_default = function(value2) {
  return Array.isArray ? Array.isArray(value2) : is_type_default(value2, "Array");
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-object.js
var is_object_default = function(value2) {
  var type = typeof value2;
  return value2 !== null && type === "object" || type === "function";
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/each.js
function each(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (is_array_default(elements)) {
    for (var i2 = 0, len = elements.length; i2 < len; i2++) {
      rst = func(elements[i2], i2);
      if (rst === false) {
        break;
      }
    }
  } else if (is_object_default(elements)) {
    for (var k2 in elements) {
      if (elements.hasOwnProperty(k2)) {
        rst = func(elements[k2], k2);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var each_default2 = each;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-object-like.js
var isObjectLike = function(value2) {
  return typeof value2 === "object" && value2 !== null;
};
var is_object_like_default = isObjectLike;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-plain-object.js
var isPlainObject = function(value2) {
  if (!is_object_like_default(value2) || !is_type_default(value2, "Object")) {
    return false;
  }
  if (Object.getPrototypeOf(value2) === null) {
    return true;
  }
  var proto = value2;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value2) === proto;
};
var is_plain_object_default2 = isPlainObject;

// node_modules/@antv/coord/node_modules/@antv/util/esm/pull.js
var arrPrototype = Array.prototype;
var splice2 = arrPrototype.splice;
var indexOf2 = arrPrototype.indexOf;

// node_modules/@antv/coord/node_modules/@antv/util/esm/pull-at.js
var splice3 = Array.prototype.splice;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-string.js
var is_string_default = function(str) {
  return is_type_default(str, "String");
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-number.js
var isNumber2 = function(value2) {
  return is_type_default(value2, "Number");
};
var is_number_default = isNumber2;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-integer.js
var isInteger = Number.isInteger ? Number.isInteger : function(num) {
  return is_number_default(num) && num % 1 === 0;
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/to-degree.js
var DEGREE = 180 / Math.PI;

// node_modules/@antv/coord/node_modules/@antv/util/esm/to-radian.js
var RADIAN = Math.PI / 180;

// node_modules/@antv/coord/node_modules/@antv/util/esm/values.js
var values = Object.values ? function(obj) {
  return Object.values(obj);
} : function(obj) {
  var result = [];
  each_default2(obj, function(value2, key) {
    if (!(is_function_default(obj) && key === "prototype")) {
      result.push(value2);
    }
  });
  return result;
};
var values_default = values;

// node_modules/@antv/coord/node_modules/@antv/util/esm/get-type.js
var toString2 = {}.toString;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-prototype.js
var objectProto = Object.prototype;

// node_modules/@antv/coord/node_modules/@antv/util/esm/memoize.js
var memoize_default = function(f2, resolver) {
  if (!is_function_default(f2)) {
    throw new TypeError("Expected a function");
  }
  var memoized = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    var cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = f2.apply(this, args);
    cache2.set(key, result);
    return result;
  };
  memoized.cache = /* @__PURE__ */ new Map();
  return memoized;
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/deep-mix.js
var MAX_MIX_LEVEL = 5;
function _deepMix(dist2, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL;
  for (var key in src) {
    if (src.hasOwnProperty(key)) {
      var value2 = src[key];
      if (value2 !== null && is_plain_object_default2(value2)) {
        if (!is_plain_object_default2(dist2[key])) {
          dist2[key] = {};
        }
        if (level < maxLevel) {
          _deepMix(dist2[key], value2, level + 1, maxLevel);
        } else {
          dist2[key] = src[key];
        }
      } else if (is_array_default(value2)) {
        dist2[key] = [];
        dist2[key] = dist2[key].concat(value2);
      } else if (value2 !== void 0) {
        dist2[key] = value2;
      }
    }
  }
}
var deepMix = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i2 = 0; i2 < args.length; i2 += 1) {
    _deepMix(rst, args[i2]);
  }
  return rst;
};
var deep_mix_default2 = deepMix;

// node_modules/@antv/coord/node_modules/@antv/util/esm/identity.js
var identity_default4 = function(v) {
  return v;
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/measure-text-width.js
var ctx;
var measure_text_width_default = memoize_default(function(text, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  if (!ctx) {
    ctx = document.createElement("canvas").getContext("2d");
  }
  ctx.font = [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ");
  return ctx.measureText(is_string_default(text) ? text : "").width;
}, function(text, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArrays([text], values_default(font)).join("");
});

// node_modules/@antv/coord/node_modules/@antv/util/esm/cache.js
var default_1 = (
  /** @class */
  function() {
    function default_13() {
      this.map = {};
    }
    default_13.prototype.has = function(key) {
      return this.map[key] !== void 0;
    };
    default_13.prototype.get = function(key, def) {
      var v = this.map[key];
      return v === void 0 ? def : v;
    };
    default_13.prototype.set = function(key, value2) {
      this.map[key] = value2;
    };
    default_13.prototype.clear = function() {
      this.map = {};
    };
    default_13.prototype.delete = function(key) {
      delete this.map[key];
    };
    default_13.prototype.size = function() {
      return Object.keys(this.map).length;
    };
    return default_13;
  }()
);

// node_modules/@antv/coord/esm/utils/compose.js
function compose3(fn) {
  var rest = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    rest[_i - 1] = arguments[_i];
  }
  return fn ? rest.reduce(function(total, current) {
    return function(x2) {
      return current(total(x2));
    };
  }, fn) : identity_default4;
}

// node_modules/@antv/coord/esm/utils/isMatrix.js
function isMatrix(transformer2) {
  return transformer2 instanceof Float32Array || transformer2 instanceof Array;
}

// node_modules/@antv/coord/esm/utils/extend.js
var __read = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error2) {
    e3 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function extend2(transform2) {
  return function(vector) {
    var v = [];
    for (var i2 = 0; i2 < vector.length - 1; i2 += 2) {
      var from = [vector[i2], vector[i2 + 1]];
      var to = transform2(from);
      v.push.apply(v, __spreadArray([], __read(to), false));
    }
    return v;
  };
}
function extend3D(transform2) {
  return function(vector) {
    var v = [];
    for (var i2 = 0; i2 < vector.length - 1; i2 += 3) {
      var from = [vector[i2], vector[i2 + 1], vector[i2 + 2]];
      var to = transform2(from);
      v.push.apply(v, __spreadArray([], __read(to), false));
    }
    return v;
  };
}

// node_modules/@antv/coord/esm/utils/adjustAngle.js
function adjustAngle(theta, min6, max7) {
  while (theta < min6)
    theta += Math.PI * 2;
  while (theta > max7)
    theta -= Math.PI * 2;
  return theta;
}

// node_modules/@antv/coord/esm/transforms/translate.js
var __read2 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error2) {
    e3 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var translate = function(params, x2, y3, width, height) {
  var _a = __read2(params, 2), tx = _a[0], ty = _a[1];
  var matrix2 = mat3_exports.create();
  return mat3_exports.fromTranslation(matrix2, [tx, ty]);
};

// node_modules/@antv/coord/node_modules/@antv/scale/esm/utils/compose.js
function compose4(fn, ...rest) {
  return rest.reduce((pre, cur) => (x2) => pre(cur(x2)), fn);
}

// node_modules/@antv/coord/node_modules/@antv/scale/esm/utils/normalize.js
function createNormalize2(a4, b) {
  return b - a4 ? (t) => (t - a4) / (b - a4) : (_) => 0.5;
}

// node_modules/@antv/coord/node_modules/@antv/scale/esm/utils/clamp.js
function createClamp2(a4, b) {
  const lo = b < a4 ? b : a4;
  const hi = a4 > b ? a4 : b;
  return (x2) => Math.min(Math.max(lo, x2), hi);
}

// node_modules/@antv/coord/node_modules/@antv/scale/esm/utils/bisect.js
function bisect2(array2, x2, lo, hi, getter) {
  let i2 = lo || 0;
  let j = hi || array2.length;
  const get3 = getter || ((x3) => x3);
  while (i2 < j) {
    const mid2 = Math.floor((i2 + j) / 2);
    if (get3(array2[mid2]) > x2) {
      j = mid2;
    } else {
      i2 = mid2 + 1;
    }
  }
  return i2;
}

// node_modules/@antv/coord/node_modules/@antv/scale/esm/utils/ticks.js
var e103 = Math.sqrt(50);
var e53 = Math.sqrt(10);
var e23 = Math.sqrt(2);
function tickIncrement3(start, stop, count4) {
  const step = (stop - start) / Math.max(0, count4);
  const power = Math.floor(Math.log(step) / Math.LN10);
  const error2 = step / __pow(10, power);
  if (power >= 0) {
    return (error2 >= e103 ? 10 : error2 >= e53 ? 5 : error2 >= e23 ? 2 : 1) * __pow(10, power);
  }
  return -__pow(10, -power) / (error2 >= e103 ? 10 : error2 >= e53 ? 5 : error2 >= e23 ? 2 : 1);
}

// node_modules/@antv/coord/node_modules/@antv/scale/esm/utils/d3-linear-nice.js
var d3LinearNice2 = (min6, max7, count4 = 5) => {
  const d3 = [min6, max7];
  let i0 = 0;
  let i1 = d3.length - 1;
  let start = d3[i0];
  let stop = d3[i1];
  let step;
  if (stop < start) {
    [start, stop] = [stop, start];
    [i0, i1] = [i1, i0];
  }
  step = tickIncrement3(start, stop, count4);
  if (step > 0) {
    start = Math.floor(start / step) * step;
    stop = Math.ceil(stop / step) * step;
    step = tickIncrement3(start, stop, count4);
  } else if (step < 0) {
    start = Math.ceil(start * step) / step;
    stop = Math.floor(stop * step) / step;
    step = tickIncrement3(start, stop, count4);
  }
  if (step > 0) {
    d3[i0] = Math.floor(start / step) * step;
    d3[i1] = Math.ceil(stop / step) * step;
  } else if (step < 0) {
    d3[i0] = Math.ceil(start * step) / step;
    d3[i1] = Math.floor(stop * step) / step;
  }
  return d3;
};

// node_modules/@antv/coord/node_modules/@antv/scale/esm/utils/time-interval.js
var DURATION_SECOND2 = 1e3;
var DURATION_MINUTE2 = DURATION_SECOND2 * 60;
var DURATION_HOUR2 = DURATION_MINUTE2 * 60;
var DURATION_DAY2 = DURATION_HOUR2 * 24;
var DURATION_WEEK2 = DURATION_DAY2 * 7;
var DURATION_MONTH2 = DURATION_DAY2 * 30;
var DURATION_YEAR2 = DURATION_DAY2 * 365;
function createInterval2(duration, floorish, offseti, field3) {
  const adjust = (date, step) => {
    const test = (date2) => field3(date2) % step === 0;
    let i2 = step;
    while (i2 && !test(date)) {
      offseti(date, -1);
      i2 -= 1;
    }
    return date;
  };
  const floori = (date, step) => {
    if (step)
      adjust(date, step);
    floorish(date);
  };
  const floor = (date, step) => {
    const d3 = /* @__PURE__ */ new Date(+date);
    floori(d3, step);
    return d3;
  };
  const ceil3 = (date, step) => {
    const d3 = new Date(+date - 1);
    floori(d3, step);
    offseti(d3, step);
    floori(d3);
    return d3;
  };
  const range3 = (start, stop, step, shouldAdjust) => {
    const ticks2 = [];
    const roundStep = Math.floor(step);
    const t = shouldAdjust ? ceil3(start, step) : ceil3(start);
    for (let i2 = t; i2 < stop; offseti(i2, roundStep), floori(i2)) {
      ticks2.push(/* @__PURE__ */ new Date(+i2));
    }
    return ticks2;
  };
  return {
    ceil: ceil3,
    floor,
    range: range3,
    duration
  };
}
var millisecond2 = createInterval2(1, (date) => date, (date, step = 1) => {
  date.setTime(+date + step);
}, (date) => date.getTime());
var second2 = createInterval2(DURATION_SECOND2, (date) => {
  date.setMilliseconds(0);
}, (date, step = 1) => {
  date.setTime(+date + DURATION_SECOND2 * step);
}, (date) => date.getSeconds());
var minute2 = createInterval2(DURATION_MINUTE2, (date) => {
  date.setSeconds(0, 0);
}, (date, step = 1) => {
  date.setTime(+date + DURATION_MINUTE2 * step);
}, (date) => date.getMinutes());
var hour2 = createInterval2(DURATION_HOUR2, (date) => {
  date.setMinutes(0, 0, 0);
}, (date, step = 1) => {
  date.setTime(+date + DURATION_HOUR2 * step);
}, (date) => date.getHours());
var day2 = createInterval2(DURATION_DAY2, (date) => {
  date.setHours(0, 0, 0, 0);
}, (date, step = 1) => {
  date.setTime(+date + DURATION_DAY2 * step);
}, (date) => date.getDate() - 1);
var month2 = createInterval2(DURATION_MONTH2, (date) => {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, (date, step = 1) => {
  const month3 = date.getMonth();
  date.setMonth(month3 + step);
}, (date) => date.getMonth());
var week2 = createInterval2(DURATION_WEEK2, (date) => {
  date.setDate(date.getDate() - date.getDay() % 7);
  date.setHours(0, 0, 0, 0);
}, (date, step = 1) => {
  date.setDate(date.getDate() + 7 * step);
}, (date) => {
  const start = month2.floor(date);
  const end = /* @__PURE__ */ new Date(+date);
  return Math.floor((+end - +start) / DURATION_WEEK2);
});
var year2 = createInterval2(DURATION_YEAR2, (date) => {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, (date, step = 1) => {
  const year3 = date.getFullYear();
  date.setFullYear(year3 + step);
}, (date) => date.getFullYear());

// node_modules/@antv/coord/node_modules/@antv/scale/esm/utils/utc-interval.js
var utcMillisecond2 = createInterval2(1, (date) => date, (date, step = 1) => {
  date.setTime(+date + step);
}, (date) => date.getTime());
var utcSecond2 = createInterval2(DURATION_SECOND2, (date) => {
  date.setUTCMilliseconds(0);
}, (date, step = 1) => {
  date.setTime(+date + DURATION_SECOND2 * step);
}, (date) => date.getUTCSeconds());
var utcMinute2 = createInterval2(DURATION_MINUTE2, (date) => {
  date.setUTCSeconds(0, 0);
}, (date, step = 1) => {
  date.setTime(+date + DURATION_MINUTE2 * step);
}, (date) => date.getUTCMinutes());
var utcHour2 = createInterval2(DURATION_HOUR2, (date) => {
  date.setUTCMinutes(0, 0, 0);
}, (date, step = 1) => {
  date.setTime(+date + DURATION_HOUR2 * step);
}, (date) => date.getUTCHours());
var utcDay2 = createInterval2(DURATION_DAY2, (date) => {
  date.setUTCHours(0, 0, 0, 0);
}, (date, step = 1) => {
  date.setTime(+date + DURATION_DAY2 * step);
}, (date) => date.getUTCDate() - 1);
var utcMonth2 = createInterval2(DURATION_MONTH2, (date) => {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step = 1) => {
  const month3 = date.getUTCMonth();
  date.setUTCMonth(month3 + step);
}, (date) => date.getUTCMonth());
var utcWeek2 = createInterval2(DURATION_WEEK2, (date) => {
  date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7) % 7);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step = 1) => {
  date.setTime(+date + DURATION_WEEK2 * step);
}, (date) => {
  const start = utcMonth2.floor(date);
  const end = /* @__PURE__ */ new Date(+date);
  return Math.floor((+end - +start) / DURATION_WEEK2);
});
var utcYear2 = createInterval2(DURATION_YEAR2, (date) => {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step = 1) => {
  const year3 = date.getUTCFullYear();
  date.setUTCFullYear(year3 + step);
}, (date) => date.getUTCFullYear());

// node_modules/@antv/coord/node_modules/@antv/scale/node_modules/@antv/util/esm/color/arr2rgb.js
function toHex(value2) {
  var x16Value = Math.round(value2).toString(16);
  return x16Value.length === 1 ? "0".concat(x16Value) : x16Value;
}
function arr2rgb(arr) {
  return "#".concat(toHex(arr[0])).concat(toHex(arr[1])).concat(toHex(arr[2]));
}

// node_modules/@antv/coord/node_modules/@antv/scale/node_modules/@antv/util/esm/lodash/is-array.js
function isArray2(value2) {
  return Array.isArray(value2);
}

// node_modules/@antv/coord/node_modules/@antv/scale/node_modules/@antv/util/esm/lodash/is-object-like.js
var isObjectLike2 = function(value2) {
  return typeof value2 === "object" && value2 !== null;
};
var is_object_like_default2 = isObjectLike2;

// node_modules/@antv/coord/node_modules/@antv/scale/node_modules/@antv/util/esm/lodash/is-type.js
var toString3 = {}.toString;
var isType2 = function(value2, type) {
  return toString3.call(value2) === "[object " + type + "]";
};
var is_type_default2 = isType2;

// node_modules/@antv/coord/node_modules/@antv/scale/node_modules/@antv/util/esm/lodash/is-plain-object.js
var isPlainObject2 = function(value2) {
  if (!is_object_like_default2(value2) || !is_type_default2(value2, "Object")) {
    return false;
  }
  if (Object.getPrototypeOf(value2) === null) {
    return true;
  }
  var proto = value2;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value2) === proto;
};
var is_plain_object_default3 = isPlainObject2;

// node_modules/@antv/coord/node_modules/@antv/scale/node_modules/@antv/util/esm/lodash/pull.js
var arrPrototype2 = Array.prototype;
var splice4 = arrPrototype2.splice;
var indexOf3 = arrPrototype2.indexOf;

// node_modules/@antv/coord/node_modules/@antv/scale/node_modules/@antv/util/esm/lodash/pull-at.js
var splice5 = Array.prototype.splice;

// node_modules/@antv/coord/node_modules/@antv/scale/node_modules/@antv/util/esm/lodash/is-number.js
function isNumber3(value2) {
  return typeof value2 === "number";
}

// node_modules/@antv/coord/node_modules/@antv/scale/node_modules/@antv/util/esm/lodash/to-degree.js
var DEGREE2 = 180 / Math.PI;

// node_modules/@antv/coord/node_modules/@antv/scale/node_modules/@antv/util/esm/lodash/to-radian.js
var RADIAN2 = Math.PI / 180;

// node_modules/@antv/coord/node_modules/@antv/scale/node_modules/@antv/util/esm/lodash/get-type.js
var toString4 = {}.toString;

// node_modules/@antv/coord/node_modules/@antv/scale/node_modules/@antv/util/esm/lodash/is-null.js
function isNull2(value2) {
  return value2 === null;
}

// node_modules/@antv/coord/node_modules/@antv/scale/node_modules/@antv/util/esm/lodash/is-prototype.js
var objectProto2 = Object.prototype;

// node_modules/@antv/coord/node_modules/@antv/scale/node_modules/@antv/util/esm/lodash/is-undefined.js
var isUndefined = function(value2) {
  return value2 === void 0;
};
var is_undefined_default3 = isUndefined;

// node_modules/@antv/coord/node_modules/@antv/scale/node_modules/@antv/util/esm/lodash/memoize.js
function flru(max7) {
  var num, curr, prev;
  var limit = max7 || 1;
  function keep(key, value2) {
    if (++num > limit) {
      prev = curr;
      reset(1);
      ++num;
    }
    curr[key] = value2;
  }
  function reset(isPartial) {
    num = 0;
    curr = /* @__PURE__ */ Object.create(null);
    isPartial || (prev = /* @__PURE__ */ Object.create(null));
  }
  reset();
  return {
    clear: reset,
    has: function(key) {
      return curr[key] !== void 0 || prev[key] !== void 0;
    },
    get: function(key) {
      var val = curr[key];
      if (val !== void 0)
        return val;
      if ((val = prev[key]) !== void 0) {
        keep(key, val);
        return val;
      }
    },
    set: function(key, value2) {
      if (curr[key] !== void 0) {
        curr[key] = value2;
      } else {
        keep(key, value2);
      }
    }
  };
}
var CacheMap = /* @__PURE__ */ new Map();
function memoize(fn, resolver, maxSize) {
  if (maxSize === void 0) {
    maxSize = 128;
  }
  var memoized = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    if (!CacheMap.has(fn))
      CacheMap.set(fn, flru(maxSize));
    var cache2 = CacheMap.get(fn);
    if (cache2.has(key))
      return cache2.get(key);
    var result = fn.apply(this, args);
    cache2.set(key, result);
    return result;
  };
  return memoized;
}

// node_modules/@antv/coord/node_modules/@antv/scale/node_modules/@antv/util/esm/lodash/deep-mix.js
var MAX_MIX_LEVEL2 = 5;
function hasOwn(object, property) {
  if (Object.hasOwn) {
    return Object.hasOwn(object, property);
  }
  if (object == null) {
    throw new TypeError("Cannot convert undefined or null to object");
  }
  return Object.prototype.hasOwnProperty.call(Object(object), property);
}
function _deepMix2(dist2, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL2;
  for (var key in src) {
    if (hasOwn(src, key)) {
      var value2 = src[key];
      if (value2 !== null && is_plain_object_default3(value2)) {
        if (!is_plain_object_default3(dist2[key])) {
          dist2[key] = {};
        }
        if (level < maxLevel) {
          _deepMix2(dist2[key], value2, level + 1, maxLevel);
        } else {
          dist2[key] = src[key];
        }
      } else if (isArray2(value2)) {
        dist2[key] = [];
        dist2[key] = dist2[key].concat(value2);
      } else if (value2 !== void 0) {
        dist2[key] = value2;
      }
    }
  }
}
var deepMix2 = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i2 = 0; i2 < args.length; i2 += 1) {
    _deepMix2(rst, args[i2]);
  }
  return rst;
};
var deep_mix_default3 = deepMix2;

// node_modules/@antv/coord/node_modules/@antv/scale/node_modules/@antv/util/esm/lodash/identity.js
var identity_default5 = function(v) {
  return v;
};

// node_modules/@antv/coord/node_modules/@antv/scale/node_modules/@antv/util/esm/lodash/cache.js
var default_12 = (
  /** @class */
  function() {
    function default_13() {
      this.map = {};
    }
    default_13.prototype.has = function(key) {
      return this.map[key] !== void 0;
    };
    default_13.prototype.get = function(key, def) {
      var v = this.map[key];
      return v === void 0 ? def : v;
    };
    default_13.prototype.set = function(key, value2) {
      this.map[key] = value2;
    };
    default_13.prototype.clear = function() {
      this.map = {};
    };
    default_13.prototype.delete = function(key) {
      delete this.map[key];
    };
    default_13.prototype.size = function() {
      return Object.keys(this.map).length;
    };
    return default_13;
  }()
);

// node_modules/@antv/coord/node_modules/@antv/scale/node_modules/@antv/util/esm/color/torgb.js
var RGB_REG = /rgba?\(([\s.,0-9]+)\)/;
function getTmp() {
  var i2 = document.getElementById("antv-web-colour-picker");
  if (i2) {
    return i2;
  }
  i2 = document.createElement("i");
  i2.id = "antv-web-colour-picker";
  i2.title = "Web Colour Picker";
  i2.style.display = "none";
  document.body.appendChild(i2);
  return i2;
}
function toRGBString(color) {
  if (color[0] === "#" && color.length === 7) {
    return color;
  }
  var iEl = getTmp();
  iEl.style.color = color;
  var rst = document.defaultView.getComputedStyle(iEl, "").getPropertyValue("color");
  var matches = RGB_REG.exec(rst);
  var cArray = matches[1].split(/\s*,\s*/).map(function(s3) {
    return Number(s3);
  });
  rst = arr2rgb(cArray);
  return rst;
}
var toRGB = memoize(toRGBString, function(color) {
  return color;
}, 256);

// node_modules/@antv/coord/node_modules/@antv/scale/esm/utils/is-valid.js
function isValid2(x2) {
  return !is_undefined_default3(x2) && !isNull2(x2) && !Number.isNaN(x2);
}

// node_modules/@antv/coord/node_modules/@antv/scale/esm/utils/interpolatize.js
var createInterpolatorRound2 = (interpolator) => {
  return (t) => {
    const res = interpolator(t);
    return isNumber3(res) ? Math.round(res) : res;
  };
};
function interpolatize2(rangeOf7, normalizeDomain5) {
  return (Scale) => {
    Scale.prototype.rescale = function() {
      this.initRange();
      this.nice();
      const [transform2] = this.chooseTransforms();
      this.composeOutput(transform2, this.chooseClamp(transform2));
    };
    Scale.prototype.initRange = function() {
      const { interpolator } = this.options;
      this.options.range = rangeOf7(interpolator);
    };
    Scale.prototype.composeOutput = function(transform2, clamp2) {
      const { domain, interpolator, round: round2 } = this.getOptions();
      const normalize5 = normalizeDomain5(domain.map(transform2));
      const interpolate2 = round2 ? createInterpolatorRound2(interpolator) : interpolator;
      this.output = compose4(interpolate2, normalize5, clamp2, transform2);
    };
    Scale.prototype.invert = void 0;
  };
}

// node_modules/@antv/coord/node_modules/@antv/scale/esm/utils/color.js
var import_color_string2 = __toESM(require_color_string());
function hue2rgb2(p3, q, m2) {
  let t = m2;
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p3 + (q - p3) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p3 + (q - p3) * (2 / 3 - t) * 6;
  return p3;
}
function hsl2rbg2(hsl) {
  const h2 = hsl[0] / 360;
  const s3 = hsl[1] / 100;
  const l2 = hsl[2] / 100;
  const a4 = hsl[3];
  if (s3 === 0)
    return [l2 * 255, l2 * 255, l2 * 255, a4];
  const q = l2 < 0.5 ? l2 * (1 + s3) : l2 + s3 - l2 * s3;
  const p3 = 2 * l2 - q;
  const r2 = hue2rgb2(p3, q, h2 + 1 / 3);
  const g = hue2rgb2(p3, q, h2);
  const b = hue2rgb2(p3, q, h2 - 1 / 3);
  return [r2 * 255, g * 255, b * 255, a4];
}
function string2rbg2(s3) {
  const color = import_color_string2.default.get(s3);
  if (!color)
    return null;
  const { model, value: value2 } = color;
  if (model === "rgb")
    return value2;
  if (model === "hsl")
    return hsl2rbg2(value2);
  return null;
}

// node_modules/@antv/coord/node_modules/@antv/scale/esm/utils/interpolate.js
var createInterpolateNumber2 = (a4, b) => {
  return (t) => a4 * (1 - t) + b * t;
};
var createInterpolateColor2 = (a4, b) => {
  const c1 = string2rbg2(a4);
  const c22 = string2rbg2(b);
  if (c1 === null || c22 === null)
    return c1 ? () => a4 : () => b;
  return (t) => {
    const values4 = new Array(4);
    for (let i2 = 0; i2 < 4; i2 += 1) {
      const from = c1[i2];
      const to = c22[i2];
      values4[i2] = from * (1 - t) + to * t;
    }
    const [r2, g, b2, a5] = values4;
    return `rgba(${Math.round(r2)}, ${Math.round(g)}, ${Math.round(b2)}, ${a5})`;
  };
};
var createInterpolateValue2 = (a4, b) => {
  if (typeof a4 === "number" && typeof b === "number")
    return createInterpolateNumber2(a4, b);
  if (typeof a4 === "string" && typeof b === "string")
    return createInterpolateColor2(a4, b);
  return () => a4;
};
var createInterpolateRound2 = (a4, b) => {
  const interpolateNumber = createInterpolateNumber2(a4, b);
  return (t) => Math.round(interpolateNumber(t));
};

// node_modules/@antv/coord/node_modules/@antv/scale/esm/utils/internMap.js
function internGet2({ map: map5, initKey }, value2) {
  const key = initKey(value2);
  return map5.has(key) ? map5.get(key) : value2;
}
function internSet2({ map: map5, initKey }, value2) {
  const key = initKey(value2);
  if (map5.has(key))
    return map5.get(key);
  map5.set(key, value2);
  return value2;
}
function internDelete2({ map: map5, initKey }, value2) {
  const key = initKey(value2);
  if (map5.has(key)) {
    value2 = map5.get(key);
    map5.delete(key);
  }
  return value2;
}
function keyof3(value2) {
  return typeof value2 === "object" ? value2.valueOf() : value2;
}
var InternMap3 = class extends Map {
  constructor(entries) {
    super();
    this.map = /* @__PURE__ */ new Map();
    this.initKey = keyof3;
    if (entries !== null) {
      for (const [key, value2] of entries) {
        this.set(key, value2);
      }
    }
  }
  get(key) {
    return super.get(internGet2({ map: this.map, initKey: this.initKey }, key));
  }
  has(key) {
    return super.has(internGet2({ map: this.map, initKey: this.initKey }, key));
  }
  set(key, value2) {
    return super.set(internSet2({ map: this.map, initKey: this.initKey }, key), value2);
  }
  delete(key) {
    return super.delete(internDelete2({ map: this.map, initKey: this.initKey }, key));
  }
};

// node_modules/@antv/coord/node_modules/@antv/scale/esm/scales/base.js
var Base2 = class {
  /**
   * 
   * @param options 
   */
  constructor(options) {
    this.options = deep_mix_default3({}, this.getDefaultOptions());
    this.update(options);
  }
  /**
   * 
   * @returns 
   */
  getOptions() {
    return this.options;
  }
  /**
   * 
   * @param updateOptions 
   */
  update(updateOptions = {}) {
    this.options = deep_mix_default3({}, this.options, updateOptions);
    this.rescale(updateOptions);
  }
  /**
   *  options  options  scale 
   *  this.options  options
   * @param options  options
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  rescale(options) {
  }
};

// node_modules/@antv/coord/node_modules/@antv/scale/esm/scales/ordinal.js
var defaultUnknown2 = Symbol("defaultUnknown");
function updateIndexMap2(target, arr, key) {
  for (let i2 = 0; i2 < arr.length; i2 += 1) {
    if (!target.has(arr[i2])) {
      target.set(key(arr[i2]), i2);
    }
  }
}
function mapBetweenArrByMapIndex2(options) {
  const { value: value2, from, to, mapper, notFoundReturn } = options;
  let mappedIndex = mapper.get(value2);
  if (mappedIndex === void 0) {
    if (notFoundReturn !== defaultUnknown2) {
      return notFoundReturn;
    }
    mappedIndex = from.push(value2) - 1;
    mapper.set(value2, mappedIndex);
  }
  return to[mappedIndex % to.length];
}
function createKey2(d3) {
  if (d3 instanceof Date)
    return (d4) => `${d4}`;
  if (typeof d3 === "object")
    return (d4) => JSON.stringify(d4);
  return (d4) => d4;
}
var Ordinal3 = class _Ordinal extends Base2 {
  // 
  getDefaultOptions() {
    return {
      domain: [],
      range: [],
      unknown: defaultUnknown2
    };
  }
  //  options  OrdinalOptions O 
  constructor(options) {
    super(options);
  }
  map(x2) {
    if (this.domainIndexMap.size === 0) {
      updateIndexMap2(this.domainIndexMap, this.getDomain(), this.domainKey);
    }
    return mapBetweenArrByMapIndex2({
      value: this.domainKey(x2),
      mapper: this.domainIndexMap,
      from: this.getDomain(),
      to: this.getRange(),
      notFoundReturn: this.options.unknown
    });
  }
  invert(y3) {
    if (this.rangeIndexMap.size === 0) {
      updateIndexMap2(this.rangeIndexMap, this.getRange(), this.rangeKey);
    }
    return mapBetweenArrByMapIndex2({
      value: this.rangeKey(y3),
      mapper: this.rangeIndexMap,
      from: this.getRange(),
      to: this.getDomain(),
      notFoundReturn: this.options.unknown
    });
  }
  //  ordinal 
  rescale(options) {
    const [d3] = this.options.domain;
    const [r2] = this.options.range;
    this.domainKey = createKey2(d3);
    this.rangeKey = createKey2(r2);
    if (!this.rangeIndexMap) {
      this.rangeIndexMap = /* @__PURE__ */ new Map();
      this.domainIndexMap = /* @__PURE__ */ new Map();
      return;
    }
    if (!options || options.range) {
      this.rangeIndexMap.clear();
    }
    if (!options || options.domain || options.compare) {
      this.domainIndexMap.clear();
      this.sortedDomain = void 0;
    }
  }
  clone() {
    return new _Ordinal(this.options);
  }
  getRange() {
    return this.options.range;
  }
  getDomain() {
    if (this.sortedDomain)
      return this.sortedDomain;
    const { domain, compare } = this.options;
    this.sortedDomain = compare ? [...domain].sort(compare) : domain;
    return this.sortedDomain;
  }
};

// node_modules/@antv/coord/node_modules/@antv/scale/esm/scales/band.js
function normalize3(array2) {
  const min6 = Math.min(...array2);
  return array2.map((d3) => d3 / min6);
}
function splice6(array2, n2) {
  const sn = array2.length;
  const diff = n2 - sn;
  return diff > 0 ? [...array2, ...new Array(diff).fill(1)] : diff < 0 ? array2.slice(0, n2) : array2;
}
function pretty2(n2) {
  return Math.round(n2 * 1e12) / 1e12;
}
function computeFlexBandState2(options) {
  const { domain, range: range3, paddingOuter, paddingInner, flex: F, round: round2, align } = options;
  const n2 = domain.length;
  const flex = splice6(F, n2);
  const [start, end] = range3;
  const width = end - start;
  const ratio = 2 / n2 * paddingOuter + 1 - 1 / n2 * paddingInner;
  const stepSum = width / ratio;
  const PI = stepSum * paddingInner / n2;
  const bandWidthSum = stepSum - n2 * PI;
  const normalizedFlex = normalize3(flex);
  const flexSum = normalizedFlex.reduce((sum4, value2) => sum4 + value2);
  const minBandWidth = bandWidthSum / flexSum;
  const valueBandWidth = new InternMap3(domain.map((d3, i2) => {
    const bandWidth3 = normalizedFlex[i2] * minBandWidth;
    return [d3, round2 ? Math.floor(bandWidth3) : bandWidth3];
  }));
  const valueStep = new InternMap3(domain.map((d3, i2) => {
    const bandWidth3 = normalizedFlex[i2] * minBandWidth;
    const step = bandWidth3 + PI;
    return [d3, round2 ? Math.floor(step) : step];
  }));
  const finalStepSum = Array.from(valueStep.values()).reduce((sum4, value2) => sum4 + value2);
  const outerPaddingSum = width - (finalStepSum - finalStepSum / n2 * paddingInner);
  const offset2 = outerPaddingSum * align;
  const bandStart = start + offset2;
  let prev = round2 ? Math.round(bandStart) : bandStart;
  const adjustedRange = new Array(n2);
  for (let i2 = 0; i2 < n2; i2 += 1) {
    adjustedRange[i2] = pretty2(prev);
    const value2 = domain[i2];
    prev += valueStep.get(value2);
  }
  return {
    valueBandWidth,
    valueStep,
    adjustedRange
  };
}
function computeBandState2(options) {
  var _a;
  const { domain } = options;
  const n2 = domain.length;
  if (n2 === 0) {
    return {
      valueBandWidth: void 0,
      valueStep: void 0,
      adjustedRange: []
    };
  }
  const hasFlex = !!((_a = options.flex) === null || _a === void 0 ? void 0 : _a.length);
  if (hasFlex) {
    return computeFlexBandState2(options);
  }
  const { range: range3, paddingOuter, paddingInner, round: round2, align } = options;
  let step;
  let bandWidth3;
  let rangeStart = range3[0];
  const rangeEnd = range3[1];
  const deltaRange = rangeEnd - rangeStart;
  const outerTotal = paddingOuter * 2;
  const innerTotal = n2 - paddingInner;
  step = deltaRange / Math.max(1, outerTotal + innerTotal);
  if (round2) {
    step = Math.floor(step);
  }
  rangeStart += (deltaRange - step * (n2 - paddingInner)) * align;
  bandWidth3 = step * (1 - paddingInner);
  if (round2) {
    rangeStart = Math.round(rangeStart);
    bandWidth3 = Math.round(bandWidth3);
  }
  const adjustedRange = new Array(n2).fill(0).map((_, i2) => rangeStart + i2 * step);
  return {
    valueStep: step,
    valueBandWidth: bandWidth3,
    adjustedRange
  };
}
var Band3 = class _Band extends Ordinal3 {
  // 
  getDefaultOptions() {
    return {
      domain: [],
      range: [0, 1],
      align: 0.5,
      round: false,
      paddingInner: 0,
      paddingOuter: 0,
      padding: 0,
      unknown: defaultUnknown2,
      flex: []
    };
  }
  //  options  OrdinalOptions O 
  constructor(options) {
    super(options);
  }
  clone() {
    return new _Band(this.options);
  }
  getStep(x2) {
    if (this.valueStep === void 0)
      return 1;
    if (typeof this.valueStep === "number") {
      return this.valueStep;
    }
    if (x2 === void 0)
      return Array.from(this.valueStep.values())[0];
    return this.valueStep.get(x2);
  }
  getBandWidth(x2) {
    if (this.valueBandWidth === void 0)
      return 1;
    if (typeof this.valueBandWidth === "number") {
      return this.valueBandWidth;
    }
    if (x2 === void 0)
      return Array.from(this.valueBandWidth.values())[0];
    return this.valueBandWidth.get(x2);
  }
  getRange() {
    return this.adjustedRange;
  }
  getPaddingInner() {
    const { padding, paddingInner } = this.options;
    return padding > 0 ? padding : paddingInner;
  }
  getPaddingOuter() {
    const { padding, paddingOuter } = this.options;
    return padding > 0 ? padding : paddingOuter;
  }
  rescale() {
    super.rescale();
    const { align, domain, range: range3, round: round2, flex } = this.options;
    const { adjustedRange, valueBandWidth, valueStep } = computeBandState2({
      align,
      range: range3,
      round: round2,
      flex,
      paddingInner: this.getPaddingInner(),
      paddingOuter: this.getPaddingOuter(),
      domain
    });
    this.valueStep = valueStep;
    this.valueBandWidth = valueBandWidth;
    this.adjustedRange = adjustedRange;
  }
};

// node_modules/@antv/coord/node_modules/@antv/scale/esm/tick-methods/d3-ticks.js
var d3Ticks2 = (begin, end, count4) => {
  let n2;
  let ticks2;
  let start = begin;
  let stop = end;
  if (start === stop && count4 > 0) {
    return [start];
  }
  let step = tickIncrement3(start, stop, count4);
  if (step === 0 || !Number.isFinite(step)) {
    return [];
  }
  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks2 = new Array(n2 = Math.ceil(stop - start + 1));
    for (let i2 = 0; i2 < n2; i2 += 1) {
      ticks2[i2] = (start + i2) * step;
    }
  } else {
    step = -step;
    start = Math.ceil(start * step);
    stop = Math.floor(stop * step);
    ticks2 = new Array(n2 = Math.ceil(stop - start + 1));
    for (let i2 = 0; i2 < n2; i2 += 1) {
      ticks2[i2] = (start + i2) / step;
    }
  }
  return ticks2;
};

// node_modules/@antv/coord/node_modules/@antv/scale/esm/tick-methods/wilkinson-extended.js
var eps2 = Number.EPSILON * 100;

// node_modules/@antv/coord/node_modules/@antv/scale/esm/scales/continuous.js
var createBiMap2 = (domain, range3, createInterpolate) => {
  const [d0, d1] = domain;
  const [r0, r1] = range3;
  let normalize5;
  let interpolate2;
  if (d0 < d1) {
    normalize5 = createNormalize2(d0, d1);
    interpolate2 = createInterpolate(r0, r1);
  } else {
    normalize5 = createNormalize2(d1, d0);
    interpolate2 = createInterpolate(r1, r0);
  }
  return compose4(interpolate2, normalize5);
};
var createPolyMap2 = (domain, range3, createInterpolate) => {
  const len = Math.min(domain.length, range3.length) - 1;
  const normalizeList = new Array(len);
  const interpolateList = new Array(len);
  const reverse2 = domain[0] > domain[len];
  const ascendingDomain = reverse2 ? [...domain].reverse() : domain;
  const ascendingRange = reverse2 ? [...range3].reverse() : range3;
  for (let i2 = 0; i2 < len; i2 += 1) {
    normalizeList[i2] = createNormalize2(ascendingDomain[i2], ascendingDomain[i2 + 1]);
    interpolateList[i2] = createInterpolate(ascendingRange[i2], ascendingRange[i2 + 1]);
  }
  return (x2) => {
    const i2 = bisect2(domain, x2, 1, len) - 1;
    const normalize5 = normalizeList[i2];
    const interpolate2 = interpolateList[i2];
    return compose4(interpolate2, normalize5)(x2);
  };
};
var choosePiecewise2 = (domain, range3, interpolate2, shouldRound) => {
  const n2 = Math.min(domain.length, range3.length);
  const createPiecewise = n2 > 2 ? createPolyMap2 : createBiMap2;
  const createInterpolate = shouldRound ? createInterpolateRound2 : interpolate2;
  return createPiecewise(domain, range3, createInterpolate);
};
var Continuous3 = class extends Base2 {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      nice: false,
      clamp: false,
      round: false,
      interpolate: createInterpolateNumber2,
      tickCount: 5
    };
  }
  /**
   * y = interpolate(normalize(clamp(transform(x))))
   */
  map(x2) {
    if (!isValid2(x2))
      return this.options.unknown;
    return this.output(x2);
  }
  /**
   * x = transform(clamp(interpolate(normalize(y))))
   */
  invert(x2) {
    if (!isValid2(x2))
      return this.options.unknown;
    return this.input(x2);
  }
  nice() {
    if (!this.options.nice)
      return;
    const [min6, max7, tickCount, ...rest] = this.getTickMethodOptions();
    this.options.domain = this.chooseNice()(min6, max7, tickCount, ...rest);
  }
  getTicks() {
    const { tickMethod } = this.options;
    const [min6, max7, tickCount, ...rest] = this.getTickMethodOptions();
    return tickMethod(min6, max7, tickCount, ...rest);
  }
  getTickMethodOptions() {
    const { domain, tickCount } = this.options;
    const min6 = domain[0];
    const max7 = domain[domain.length - 1];
    return [min6, max7, tickCount];
  }
  chooseNice() {
    return d3LinearNice2;
  }
  rescale() {
    this.nice();
    const [transform2, untransform] = this.chooseTransforms();
    this.composeOutput(transform2, this.chooseClamp(transform2));
    this.composeInput(transform2, untransform, this.chooseClamp(untransform));
  }
  chooseClamp(transform2) {
    const { clamp: shouldClamp, range: range3 } = this.options;
    const domain = this.options.domain.map(transform2);
    const n2 = Math.min(domain.length, range3.length);
    return shouldClamp ? createClamp2(domain[0], domain[n2 - 1]) : identity_default5;
  }
  composeOutput(transform2, clamp2) {
    const { domain, range: range3, round: round2, interpolate: interpolate2 } = this.options;
    const piecewise = choosePiecewise2(domain.map(transform2), range3, interpolate2, round2);
    this.output = compose4(piecewise, clamp2, transform2);
  }
  composeInput(transform2, untransform, clamp2) {
    const { domain, range: range3 } = this.options;
    const piecewise = choosePiecewise2(range3, domain.map(transform2), createInterpolateNumber2);
    this.input = compose4(untransform, clamp2, piecewise);
  }
};

// node_modules/@antv/coord/node_modules/@antv/scale/esm/scales/linear.js
var Linear4 = class _Linear extends Continuous3 {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      unknown: void 0,
      nice: false,
      clamp: false,
      round: false,
      interpolate: createInterpolateValue2,
      tickMethod: d3Ticks2,
      tickCount: 5
    };
  }
  chooseTransforms() {
    return [identity_default5, identity_default5];
  }
  clone() {
    return new _Linear(this.options);
  }
};

// node_modules/@antv/coord/node_modules/@antv/scale/esm/scales/point.js
var Point5 = class _Point extends Band3 {
  // 
  getDefaultOptions() {
    return {
      domain: [],
      range: [0, 1],
      align: 0.5,
      round: false,
      padding: 0,
      unknown: defaultUnknown2,
      paddingInner: 1,
      paddingOuter: 0
    };
  }
  //  PointOptions paddingInner 
  constructor(options) {
    super(options);
  }
  // Point  paddingInner 1
  getPaddingInner() {
    return 1;
  }
  clone() {
    return new _Point(this.options);
  }
  update(options) {
    super.update(options);
  }
  getPaddingOuter() {
    return this.options.padding;
  }
};

// node_modules/@antv/coord/node_modules/@antv/scale/esm/scales/sequential.js
var __decorate3 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r2 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r2 = (c5 < 3 ? d3(r2) : c5 > 3 ? d3(target, key, r2) : d3(target, key)) || r2;
  return c5 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var Sequential_12;
function rangeOf4(interpolator) {
  return [interpolator(0), interpolator(1)];
}
var normalizeDomain3 = (domain) => {
  const [d0, d1] = domain;
  const normalize5 = compose4(createInterpolateNumber2(0, 1), createNormalize2(d0, d1));
  return normalize5;
};
var Sequential4 = Sequential_12 = class Sequential5 extends Linear4 {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      unknown: void 0,
      nice: false,
      clamp: false,
      round: false,
      interpolator: identity_default5,
      tickMethod: d3Ticks2,
      tickCount: 5
    };
  }
  constructor(options) {
    super(options);
  }
  clone() {
    return new Sequential_12(this.options);
  }
};
Sequential4 = Sequential_12 = __decorate3([
  interpolatize2(rangeOf4, normalizeDomain3)
], Sequential4);

// node_modules/@antv/coord/node_modules/@antv/scale/esm/scales/diverging.js
var __decorate4 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r2 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r2 = (c5 < 3 ? d3(r2) : c5 > 3 ? d3(target, key, r2) : d3(target, key)) || r2;
  return c5 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var Diverging_12;
function rangeOf5(interpolator) {
  return [interpolator(0), interpolator(0.5), interpolator(1)];
}
var normalizeDomain4 = (domain) => {
  const [d0, d1, d22] = domain;
  const normalizeLeft = compose4(createInterpolateNumber2(0, 0.5), createNormalize2(d0, d1));
  const normalizeRight = compose4(createInterpolateNumber2(0.5, 1), createNormalize2(d1, d22));
  return (x2) => {
    if (d0 > d22) {
      return x2 < d1 ? normalizeRight(x2) : normalizeLeft(x2);
    } else {
      return x2 < d1 ? normalizeLeft(x2) : normalizeRight(x2);
    }
  };
};
var Diverging3 = Diverging_12 = class Diverging4 extends Linear4 {
  getDefaultOptions() {
    return {
      domain: [0, 0.5, 1],
      unknown: void 0,
      nice: false,
      clamp: false,
      round: false,
      interpolator: identity_default5,
      tickMethod: d3Ticks2,
      tickCount: 5
    };
  }
  constructor(options) {
    super(options);
  }
  clone() {
    return new Diverging_12(this.options);
  }
};
Diverging3 = Diverging_12 = __decorate4([
  interpolatize2(rangeOf5, normalizeDomain4)
], Diverging3);

// node_modules/@antv/coord/esm/transforms/cartesian.js
var __read3 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error2) {
    e3 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var cartesian = function(params, x2, y3, width, height) {
  var sx = new Linear4({
    range: [x2, x2 + width]
  });
  var sy = new Linear4({
    range: [y3, y3 + height]
  });
  return {
    transform: function(vector) {
      var _a = __read3(vector, 2), v1 = _a[0], v2 = _a[1];
      return [sx.map(v1), sy.map(v2)];
    },
    untransform: function(vector) {
      var _a = __read3(vector, 2), v1 = _a[0], v2 = _a[1];
      return [sx.invert(v1), sy.invert(v2)];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/custom.js
var __read4 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error2) {
    e3 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var custom10 = function(params, x2, y3, width, height) {
  var _a = __read4(params, 1), callback = _a[0];
  return callback(x2, y3, width, height);
};

// node_modules/@antv/coord/esm/transforms/matrix.js
var __read5 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error2) {
    e3 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var matrix = function(params, x2, y3, width, height) {
  var _a = __read5(params, 1), matrix2 = _a[0];
  return matrix2;
};

// node_modules/@antv/coord/esm/transforms/polar.js
var __read6 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error2) {
    e3 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var polar = function(params, x2, y3, width, height) {
  var _a = __read6(params, 4), startAngle = _a[0], endAngle = _a[1], innerRadius = _a[2], outerRadius = _a[3];
  var radius = new Linear4({
    range: [innerRadius, outerRadius]
  });
  var angle2 = new Linear4({
    range: [startAngle, endAngle]
  });
  var aspect = height / width;
  var sx = aspect > 1 ? 1 : aspect;
  var sy = aspect > 1 ? 1 / aspect : 1;
  return {
    transform: function(vector) {
      var _a2 = __read6(vector, 2), v1 = _a2[0], v2 = _a2[1];
      var theta = angle2.map(v1);
      var r2 = radius.map(v2);
      var x3 = r2 * Math.cos(theta) * sx;
      var y4 = r2 * Math.sin(theta) * sy;
      var dx = x3 * 0.5 + 0.5;
      var dy = y4 * 0.5 + 0.5;
      return [dx, dy];
    },
    untransform: function(vector) {
      var _a2 = __read6(vector, 2), dx = _a2[0], dy = _a2[1];
      var x3 = (dx - 0.5) * 2 / sx;
      var y4 = (dy - 0.5) * 2 / sy;
      var r2 = Math.sqrt(Math.pow(x3, 2) + Math.pow(y4, 2));
      var t = Math.atan2(y4, x3);
      var theta = adjustAngle(t, startAngle, endAngle);
      var v1 = angle2.invert(theta);
      var v2 = radius.invert(r2);
      return [v1, v2];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/transpose.js
var __read7 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error2) {
    e3 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var transpose2 = function(params, x2, y3, width, height) {
  return {
    transform: function(_a) {
      var _b = __read7(_a, 2), x3 = _b[0], y4 = _b[1];
      return [y4, x3];
    },
    untransform: function(_a) {
      var _b = __read7(_a, 2), x3 = _b[0], y4 = _b[1];
      return [y4, x3];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/scale.js
var __read8 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error2) {
    e3 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var scale = function(params, x2, y3, width, height) {
  var _a = __read8(params, 2), sx = _a[0], sy = _a[1];
  var matrix2 = mat3_exports.create();
  return mat3_exports.fromScaling(matrix2, [sx, sy]);
};

// node_modules/@antv/coord/esm/transforms/reflect.js
var __read9 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error2) {
    e3 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var __spreadArray3 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var reflect2 = function(params) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return scale.apply(void 0, __spreadArray3([[-1, -1]], __read9(args), false));
};
var reflectX = function(params) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return scale.apply(void 0, __spreadArray3([[-1, 1]], __read9(args), false));
};
var reflectY = function(params) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return scale.apply(void 0, __spreadArray3([[1, -1]], __read9(args), false));
};

// node_modules/@antv/coord/esm/transforms/rotate.js
var __read10 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error2) {
    e3 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var rotate = function(params, x2, y3, width, height) {
  var _a = __read10(params, 1), theta = _a[0];
  var matrix2 = mat3_exports.create();
  return mat3_exports.fromRotation(matrix2, theta);
};

// node_modules/@antv/coord/esm/transforms/helix.js
var __read11 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error2) {
    e3 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var helix = function(params, x2, y3, width, height) {
  var _a = __read11(params, 4), startAngle = _a[0], endAngle = _a[1], innerRadius = _a[2], outerRadius = _a[3];
  var count4 = (endAngle - 0) / (2 * Math.PI) + 1;
  var d3 = (outerRadius - innerRadius) / count4;
  var b = d3 / (Math.PI * 2);
  var step = new Linear4({
    range: [innerRadius, innerRadius + d3 * 0.99]
    // 
  });
  var angle2 = new Linear4({
    range: [startAngle, endAngle]
  });
  var aspect = height / width;
  var sx = aspect > 1 ? 1 : aspect;
  var sy = aspect > 1 ? 1 / aspect : 1;
  return {
    transform: function(vector) {
      var _a2 = __read11(vector, 2), v1 = _a2[0], v2 = _a2[1];
      var theta = angle2.map(v1);
      var a4 = step.map(v2);
      var x3 = Math.cos(theta) * (b * theta + a4) * sx;
      var y4 = Math.sin(theta) * (b * theta + a4) * sy;
      var dx = x3 * 0.5 + 0.5;
      var dy = y4 * 0.5 + 0.5;
      return [dx, dy];
    },
    untransform: function(vector) {
      var _a2 = __read11(vector, 2), dx = _a2[0], dy = _a2[1];
      var x3 = (dx - 0.5) * 2 / sx;
      var y4 = (dy - 0.5) * 2 / sy;
      var r2 = Math.sqrt(Math.pow(x3, 2) + Math.pow(y4, 2));
      var t = Math.atan2(y4, x3) + Math.floor(r2 / d3) * Math.PI * 2;
      var theta = adjustAngle(t, startAngle, endAngle);
      var a4 = r2 - b * theta;
      var v1 = angle2.invert(theta);
      var v2 = step.invert(a4);
      return [v1, v2];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/parallel.js
var __read12 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error2) {
    e3 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var parallel2 = function(params, x2, y3, width, height) {
  var _a = __read12(params, 4), x05 = _a[0], x12 = _a[1], y05 = _a[2], y12 = _a[3];
  var sy = new Linear4({
    range: [y05, y12]
  });
  return {
    transform: function(vector) {
      var v = [];
      var len = vector.length;
      var sx = new Point5({
        domain: new Array(len).fill(0).map(function(_, i3) {
          return i3;
        }),
        range: [x05, x12]
      });
      for (var i2 = 0; i2 < len; i2++) {
        var e3 = vector[i2];
        var x_1 = sx.map(i2);
        var y_1 = sy.map(e3);
        v.push(x_1, y_1);
      }
      return v;
    },
    untransform: function(vector) {
      var v = [];
      for (var i2 = 0; i2 < vector.length; i2 += 2) {
        var y_2 = vector[i2 + 1];
        v.push(sy.invert(y_2));
      }
      return v;
    }
  };
};

// node_modules/@antv/coord/esm/transforms/shear.js
var __read13 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error2) {
    e3 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
function cot(theta) {
  return 1 / Math.tan(theta);
}
var shearX = function(params, x2, y3, width, height) {
  var _a = __read13(params, 1), theta = _a[0];
  var sx = cot(theta);
  return {
    transform: function(vector) {
      var _a2 = __read13(vector, 2), x3 = _a2[0], y4 = _a2[1];
      var xx = x3 + y4 * sx;
      return [xx, y4];
    },
    untransform: function(vector) {
      var _a2 = __read13(vector, 2), xx = _a2[0], y4 = _a2[1];
      var x3 = xx - y4 * sx;
      return [x3, y4];
    }
  };
};
var shearY = function(params, x2, y3, width, height) {
  var _a = __read13(params, 1), theta = _a[0];
  var sy = cot(theta);
  return {
    transform: function(vector) {
      var _a2 = __read13(vector, 2), x3 = _a2[0], y4 = _a2[1];
      var yy = y4 + x3 * sy;
      return [x3, yy];
    },
    untransform: function(vector) {
      var _a2 = __read13(vector, 2), x3 = _a2[0], yy = _a2[1];
      var y4 = yy - x3 * sy;
      return [x3, y4];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/fisheye.js
var __read14 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error2) {
    e3 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
function fisheyeTransform(x2, focus2, distortion, min6, max7) {
  var left2 = x2 < focus2;
  var m2 = (left2 ? focus2 - min6 : max7 - focus2) || max7 - min6;
  var f2 = left2 ? -1 : 1;
  return f2 * m2 * (distortion + 1) / (distortion + m2 / ((x2 - focus2) * f2)) + focus2;
}
function fisheyeUntransform(tx, focus2, distortion, min6, max7) {
  var left2 = tx < focus2;
  var m2 = (left2 ? focus2 - min6 : max7 - focus2) || max7 - min6;
  var f2 = left2 ? -1 : 1;
  return m2 / (m2 * (distortion + 1) / (tx - focus2) - distortion * f2) + focus2;
}
function normalize4(focus2, length, isVisual) {
  if (!isVisual)
    return focus2;
  var s3 = new Linear4({
    range: [0, 1],
    domain: [0, length]
  });
  return s3.map(focus2);
}
var fisheyeX = function(params, x2, y3, width, height) {
  var _a = __read14(params, 3), focus2 = _a[0], distortion = _a[1], _b = _a[2], isVisual = _b === void 0 ? false : _b;
  var normalizedFocusX = normalize4(focus2, width, isVisual);
  return {
    transform: function(vector) {
      var _a2 = __read14(vector, 2), vx = _a2[0], vy = _a2[1];
      var fx = fisheyeTransform(vx, normalizedFocusX, distortion, 0, 1);
      return [fx, vy];
    },
    untransform: function(vector) {
      var _a2 = __read14(vector, 2), fx = _a2[0], vy = _a2[1];
      var vx = fisheyeUntransform(fx, normalizedFocusX, distortion, 0, 1);
      return [vx, vy];
    }
  };
};
var fisheyeY = function(params, x2, y3, width, height) {
  var _a = __read14(params, 3), focus2 = _a[0], distortion = _a[1], _b = _a[2], isVisual = _b === void 0 ? false : _b;
  var normalizedFocusY = normalize4(focus2, height, isVisual);
  return {
    transform: function(vector) {
      var _a2 = __read14(vector, 2), vx = _a2[0], vy = _a2[1];
      var fy = fisheyeTransform(vy, normalizedFocusY, distortion, 0, 1);
      return [vx, fy];
    },
    untransform: function(vector) {
      var _a2 = __read14(vector, 2), vx = _a2[0], fy = _a2[1];
      var vy = fisheyeUntransform(fy, normalizedFocusY, distortion, 0, 1);
      return [vx, vy];
    }
  };
};
var fisheye = function(params, x2, y3, width, height) {
  var _a = __read14(params, 5), focusX = _a[0], focusY = _a[1], distortionX = _a[2], distortionY = _a[3], _b = _a[4], isVisual = _b === void 0 ? false : _b;
  var normalizedFocusX = normalize4(focusX, width, isVisual);
  var normalizedFocusY = normalize4(focusY, height, isVisual);
  return {
    transform: function(vector) {
      var _a2 = __read14(vector, 2), vx = _a2[0], vy = _a2[1];
      var fx = fisheyeTransform(vx, normalizedFocusX, distortionX, 0, 1);
      var fy = fisheyeTransform(vy, normalizedFocusY, distortionY, 0, 1);
      return [fx, fy];
    },
    untransform: function(vector) {
      var _a2 = __read14(vector, 2), fx = _a2[0], fy = _a2[1];
      var vx = fisheyeUntransform(fx, normalizedFocusX, distortionX, 0, 1);
      var vy = fisheyeUntransform(fy, normalizedFocusY, distortionY, 0, 1);
      return [vx, vy];
    }
  };
};
var fisheyeCircular = function(params, x2, y3, width, height) {
  var _a = __read14(params, 5), focusX = _a[0], focusY = _a[1], radius = _a[2], distortion = _a[3], _b = _a[4], isVisual = _b === void 0 ? false : _b;
  var scaleX = new Linear4({
    range: [0, width]
  });
  var scaleY = new Linear4({
    range: [0, height]
  });
  var nx = isVisual ? focusX : scaleX.map(focusX);
  var ny = isVisual ? focusY : scaleY.map(focusY);
  return {
    transform: function(vector) {
      var _a2 = __read14(vector, 2), x3 = _a2[0], y4 = _a2[1];
      var dx = scaleX.map(x3) - nx;
      var dy = scaleY.map(y4) - ny;
      var dd = Math.sqrt(dx * dx + dy * dy);
      if (dd > radius)
        return [x3, y4];
      var r2 = fisheyeTransform(dd, 0, distortion, 0, radius);
      var theta = Math.atan2(dy, dx);
      var fx = nx + r2 * Math.cos(theta);
      var fy = ny + r2 * Math.sin(theta);
      return [scaleX.invert(fx), scaleY.invert(fy)];
    },
    untransform: function(vector) {
      var _a2 = __read14(vector, 2), tx = _a2[0], ty = _a2[1];
      var dx = scaleX.map(tx) - nx;
      var dy = scaleY.map(ty) - ny;
      var dd = Math.sqrt(dx * dx + dy * dy);
      if (dd > radius)
        return [tx, ty];
      var x3 = fisheyeUntransform(dd, 0, distortion, 0, radius);
      var theta = Math.atan2(dy, dx);
      var fx = nx + x3 * Math.cos(theta);
      var fy = ny + x3 * Math.sin(theta);
      return [scaleX.invert(fx), scaleY.invert(fy)];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/cartesian3D.js
var __read15 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error2) {
    e3 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var cartesian3D = function(params, x2, y3, z, width, height, depth) {
  var sx = new Linear4({
    range: [x2, x2 + width]
  });
  var sy = new Linear4({
    range: [y3, y3 + height]
  });
  var sz = new Linear4({
    range: [z, z + depth]
  });
  return {
    transform: function(vector) {
      var _a = __read15(vector, 3), v1 = _a[0], v2 = _a[1], v3 = _a[2];
      return [sx.map(v1), sy.map(v2), sz.map(v3)];
    },
    untransform: function(vector) {
      var _a = __read15(vector, 3), v1 = _a[0], v2 = _a[1], v3 = _a[2];
      return [sx.invert(v1), sy.invert(v2), sz.invert(v3)];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/translate3D.js
var __read16 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error2) {
    e3 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var translate3D = function(params, x2, y3, z, width, height, depth) {
  var _a = __read16(params, 3), tx = _a[0], ty = _a[1], tz = _a[2];
  return mat4_exports.fromTranslation(mat4_exports.create(), [tx, ty, tz]);
};

// node_modules/@antv/coord/esm/transforms/transpose3D.js
var __read17 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error2) {
    e3 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var transpose3D = function(params, x2, y3, z, width, height, depth) {
  return {
    transform: function(_a) {
      var _b = __read17(_a, 3), x3 = _b[0], y4 = _b[1], z2 = _b[2];
      return [y4, x3, z2];
    },
    untransform: function(_a) {
      var _b = __read17(_a, 3), x3 = _b[0], y4 = _b[1], z2 = _b[2];
      return [y4, x3, z2];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/scale3D.js
var __read18 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error2) {
    e3 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var scale3D = function(params, x2, y3, z, width, height, depth) {
  var _a = __read18(params, 3), sx = _a[0], sy = _a[1], sz = _a[2];
  return mat4_exports.fromScaling(mat4_exports.create(), [sx, sy, sz]);
};

// node_modules/@antv/coord/esm/coordinate.js
var __read19 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error2) {
    e3 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var __spreadArray4 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = function(o2) {
  var s3 = typeof Symbol === "function" && Symbol.iterator, m2 = s3 && o2[s3], i2 = 0;
  if (m2) return m2.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i2 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Coordinate = (
  /** @class */
  function() {
    function Coordinate2(options) {
      this.options = {
        x: 0,
        y: 0,
        width: 300,
        height: 150,
        transformations: []
      };
      this.transformers = {
        cartesian,
        translate,
        custom: custom10,
        matrix,
        polar,
        transpose: transpose2,
        scale,
        "shear.x": shearX,
        "shear.y": shearY,
        reflect: reflect2,
        "reflect.x": reflectX,
        "reflect.y": reflectY,
        rotate,
        helix,
        parallel: parallel2,
        fisheye,
        "fisheye.x": fisheyeX,
        "fisheye.y": fisheyeY,
        "fisheye.circular": fisheyeCircular
      };
      this.update(options);
    }
    Coordinate2.prototype.update = function(options) {
      this.options = deep_mix_default2({}, this.options, options);
      this.recoordinate();
    };
    Coordinate2.prototype.clone = function() {
      return new Coordinate2(this.options);
    };
    Coordinate2.prototype.getOptions = function() {
      return this.options;
    };
    Coordinate2.prototype.clear = function() {
      this.update({
        transformations: []
      });
    };
    Coordinate2.prototype.getSize = function() {
      var _a = this.options, width = _a.width, height = _a.height;
      return [width, height];
    };
    Coordinate2.prototype.getCenter = function() {
      var _a = this.options, x2 = _a.x, y3 = _a.y, width = _a.width, height = _a.height;
      return [(x2 * 2 + width) / 2, (y3 * 2 + height) / 2];
    };
    Coordinate2.prototype.transform = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var transformations = this.options.transformations;
      this.update({
        transformations: __spreadArray4(__spreadArray4([], __read19(transformations), false), [__spreadArray4([], __read19(args), false)], false)
      });
      return this;
    };
    Coordinate2.prototype.map = function(vector) {
      return this.output(vector);
    };
    Coordinate2.prototype.invert = function(vector) {
      return this.input(vector);
    };
    Coordinate2.prototype.recoordinate = function() {
      this.output = this.compose();
      this.input = this.compose(true);
    };
    Coordinate2.prototype.compose = function(invert2) {
      var e_1, _a;
      if (invert2 === void 0) {
        invert2 = false;
      }
      var transformations = invert2 ? __spreadArray4([], __read19(this.options.transformations), false).reverse() : this.options.transformations;
      var getter = invert2 ? function(d3) {
        return d3.untransform;
      } : function(d3) {
        return d3.transform;
      };
      var matrixes = [];
      var transforms = [];
      var add2 = function(transform3, extended) {
        if (extended === void 0) {
          extended = true;
        }
        return transforms.push(extended ? extend2(transform3) : transform3);
      };
      try {
        for (var transformations_1 = __values(transformations), transformations_1_1 = transformations_1.next(); !transformations_1_1.done; transformations_1_1 = transformations_1.next()) {
          var _b = __read19(transformations_1_1.value), name_1 = _b[0], args = _b.slice(1);
          var createTransformer = this.transformers[name_1];
          if (createTransformer) {
            var _c = this.options, x2 = _c.x, y3 = _c.y, width = _c.width, height = _c.height;
            var transformer2 = createTransformer(__spreadArray4([], __read19(args), false), x2, y3, width, height);
            if (isMatrix(transformer2)) {
              matrixes.push(transformer2);
            } else {
              if (matrixes.length) {
                var transform_1 = this.createMatrixTransform(matrixes, invert2);
                add2(transform_1);
                matrixes.splice(0, matrixes.length);
              }
              var transform2 = getter(transformer2) || identity_default4;
              add2(transform2, name_1 !== "parallel");
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (transformations_1_1 && !transformations_1_1.done && (_a = transformations_1.return)) _a.call(transformations_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      if (matrixes.length) {
        var transform2 = this.createMatrixTransform(matrixes, invert2);
        add2(transform2);
      }
      return compose3.apply(void 0, __spreadArray4([], __read19(transforms), false));
    };
    Coordinate2.prototype.createMatrixTransform = function(matrixes, invert2) {
      var matrix2 = mat3_exports.create();
      if (invert2)
        matrixes.reverse();
      matrixes.forEach(function(m2) {
        return mat3_exports.mul(matrix2, matrix2, m2);
      });
      if (invert2) {
        mat3_exports.invert(matrix2, mat3_exports.clone(matrix2));
      }
      return function(vector) {
        var vector3 = [vector[0], vector[1], 1];
        vec3_exports.transformMat3(vector3, vector3, matrix2);
        return [vector3[0], vector3[1]];
      };
    };
    return Coordinate2;
  }()
);

// node_modules/@antv/coord/esm/coordinate3D.js
var __read20 = function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error2) {
    e3 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var __spreadArray5 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var __values2 = function(o2) {
  var s3 = typeof Symbol === "function" && Symbol.iterator, m2 = s3 && o2[s3], i2 = 0;
  if (m2) return m2.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i2 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Coordinate3D = (
  /** @class */
  function() {
    function Coordinate3D2(options) {
      this.options = {
        x: 0,
        y: 0,
        z: 0,
        width: 300,
        height: 150,
        depth: 150,
        transformations: []
      };
      this.transformers = {
        cartesian3D,
        translate3D,
        scale3D,
        transpose3D
      };
      this.update(options);
    }
    Coordinate3D2.prototype.update = function(options) {
      this.options = deep_mix_default2({}, this.options, options);
      this.recoordinate();
    };
    Coordinate3D2.prototype.clone = function() {
      return new Coordinate3D2(this.options);
    };
    Coordinate3D2.prototype.getOptions = function() {
      return this.options;
    };
    Coordinate3D2.prototype.clear = function() {
      this.update({
        transformations: []
      });
    };
    Coordinate3D2.prototype.getSize = function() {
      var _a = this.options, width = _a.width, height = _a.height, depth = _a.depth;
      return [width, height, depth];
    };
    Coordinate3D2.prototype.getCenter = function() {
      var _a = this.options, x2 = _a.x, y3 = _a.y, z = _a.z, width = _a.width, height = _a.height, depth = _a.depth;
      return [(x2 * 2 + width) / 2, (y3 * 2 + height) / 2, (z * 2 + depth) / 2];
    };
    Coordinate3D2.prototype.transform = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var transformations = this.options.transformations;
      this.update({
        transformations: __spreadArray5(__spreadArray5([], __read20(transformations), false), [__spreadArray5([], __read20(args), false)], false)
      });
      return this;
    };
    Coordinate3D2.prototype.map = function(vector) {
      return this.output(vector);
    };
    Coordinate3D2.prototype.invert = function(vector) {
      return this.input(vector);
    };
    Coordinate3D2.prototype.recoordinate = function() {
      this.output = this.compose();
      this.input = this.compose(true);
    };
    Coordinate3D2.prototype.compose = function(invert2) {
      var e_1, _a;
      if (invert2 === void 0) {
        invert2 = false;
      }
      var transformations = invert2 ? __spreadArray5([], __read20(this.options.transformations), false).reverse() : this.options.transformations;
      var getter = invert2 ? function(d3) {
        return d3.untransform;
      } : function(d3) {
        return d3.transform;
      };
      var matrixes = [];
      var transforms = [];
      var add2 = function(transform3, extended) {
        if (extended === void 0) {
          extended = true;
        }
        return transforms.push(extended ? extend3D(transform3) : transform3);
      };
      try {
        for (var transformations_1 = __values2(transformations), transformations_1_1 = transformations_1.next(); !transformations_1_1.done; transformations_1_1 = transformations_1.next()) {
          var _b = __read20(transformations_1_1.value), name_1 = _b[0], args = _b.slice(1);
          var createTransformer = this.transformers[name_1];
          if (createTransformer) {
            var _c = this.options, x2 = _c.x, y3 = _c.y, z = _c.z, width = _c.width, height = _c.height, depth = _c.depth;
            var transformer2 = createTransformer(__spreadArray5([], __read20(args), false), x2, y3, z, width, height, depth);
            if (isMatrix(transformer2)) {
              matrixes.push(transformer2);
            } else {
              if (matrixes.length) {
                var transform_1 = this.createMatrixTransform(matrixes, invert2);
                add2(transform_1);
                matrixes.splice(0, matrixes.length);
              }
              var transform2 = getter(transformer2) || identity_default4;
              add2(transform2, true);
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (transformations_1_1 && !transformations_1_1.done && (_a = transformations_1.return)) _a.call(transformations_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      if (matrixes.length) {
        var transform2 = this.createMatrixTransform(matrixes, invert2);
        add2(transform2);
      }
      return compose3.apply(void 0, __spreadArray5([], __read20(transforms), false));
    };
    Coordinate3D2.prototype.createMatrixTransform = function(matrixes, invert2) {
      var matrix2 = mat4_exports.create();
      if (invert2)
        matrixes.reverse();
      matrixes.forEach(function(m2) {
        return mat4_exports.mul(matrix2, matrix2, m2);
      });
      if (invert2) {
        mat4_exports.invert(matrix2, mat4_exports.clone(matrix2));
      }
      return function(vector) {
        var vector4 = [vector[0], vector[1], vector[2], 1];
        vec4_exports.transformMat4(vector4, vector4, matrix2);
        return [vector4[0], vector4[1], vector4[2]];
      };
    };
    return Coordinate3D2;
  }()
);

// node_modules/@antv/g2/esm/composition/utils.js
var __rest56 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function useDefaultAdaptor(adaptor33) {
  return (options, ...rest) => deep_mix_default({}, adaptor33(options, ...rest), options);
}
function useOverrideAdaptor(adaptor33) {
  return (options, ...rest) => deep_mix_default({}, options, adaptor33(options, ...rest));
}
function isObject2(d3) {
  if (d3 instanceof Date)
    return false;
  return typeof d3 === "object";
}
function mergeData(dataDescriptor, dataValue) {
  if (!dataDescriptor)
    return dataValue;
  if (Array.isArray(dataDescriptor))
    return dataDescriptor;
  if (isObject2(dataDescriptor)) {
    const { value: value2 = dataValue } = dataDescriptor, rest = __rest56(dataDescriptor, ["value"]);
    return Object.assign(Object.assign({}, rest), { value: value2 });
  }
  return dataDescriptor;
}

// node_modules/@antv/g2/esm/composition/spaceLayer.js
var __rest57 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var SpaceLayer = () => {
  return (options) => {
    const { children } = options;
    if (!Array.isArray(children))
      return [];
    const { x: viewX = 0, y: viewY = 0, width: viewWidth, height: viewHeight, data: layerData } = options;
    return children.map((_a) => {
      var { data, x: x2, y: y3, width, height } = _a, rest = __rest57(_a, ["data", "x", "y", "width", "height"]);
      return Object.assign(Object.assign({}, rest), { data: mergeData(data, layerData), x: x2 !== null && x2 !== void 0 ? x2 : viewX, y: y3 !== null && y3 !== void 0 ? y3 : viewY, width: width !== null && width !== void 0 ? width : viewWidth, height: height !== null && height !== void 0 ? height : viewHeight });
    });
  };
};
SpaceLayer.props = {};

// node_modules/@antv/g2/esm/composition/spaceFlex.js
var __rest58 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var SpaceFlex = () => {
  return (options) => {
    const { children } = options;
    if (!Array.isArray(children))
      return [];
    const { direction: direction2 = "row", ratio = children.map(() => 1), padding = 0, data: flexData } = options;
    const [mainStart, mainSize, crossSize, crossStart] = direction2 === "col" ? ["y", "height", "width", "x"] : ["x", "width", "height", "y"];
    const sum4 = ratio.reduce((total, value2) => total + value2);
    const totalSize = options[mainSize] - padding * (children.length - 1);
    const sizes = ratio.map((value2) => totalSize * (value2 / sum4));
    const newChildren = [];
    let next = options[mainStart] || 0;
    for (let i2 = 0; i2 < sizes.length; i2 += 1) {
      const _a = children[i2], { data } = _a, rest = __rest58(_a, ["data"]);
      const newData = mergeData(data, flexData);
      newChildren.push(Object.assign({ [mainStart]: next, [mainSize]: sizes[i2], [crossStart]: options[crossStart] || 0, [crossSize]: options[crossSize], data: newData }, rest));
      next += sizes[i2] + padding;
    }
    return newChildren;
  };
};
SpaceFlex.props = {};

// node_modules/@antv/g2/esm/composition/view.js
var __rest59 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var View = () => {
  return (options) => {
    const { children } = options, restOptions = __rest59(options, ["children"]);
    if (!Array.isArray(children))
      return [];
    const { data: viewData, scale: viewScale = {}, axis: viewAxis = {}, legend: viewLegend = {}, encode: viewEncode = {}, transform: viewTransform = [], slider: viewSlider = {} } = restOptions, rest = __rest59(restOptions, ["data", "scale", "axis", "legend", "encode", "transform", "slider"]);
    const marks = children.map((_a) => {
      var { data, scale: scale4 = {}, axis = {}, legend = {}, encode = {}, transform: transform2 = [], slider = {} } = _a, rest2 = __rest59(_a, ["data", "scale", "axis", "legend", "encode", "transform", "slider"]);
      return Object.assign({ data: mergeData(data, viewData), scale: deep_mix_default({}, viewScale, scale4), encode: deep_mix_default({}, viewEncode, encode), transform: [...viewTransform, ...transform2], axis: axis && viewAxis ? deep_mix_default({}, viewAxis, axis) : false, legend: legend && viewLegend ? deep_mix_default({}, viewLegend, legend) : false, slider: deep_mix_default({}, viewSlider, slider) }, rest2);
    });
    return [Object.assign(Object.assign({}, rest), { marks, type: "standardView", slider: viewSlider })];
  };
};
View.props = {};

// node_modules/@antv/g2/esm/composition/mark.js
var __rest60 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var Mark = ({ static: isStatic = false } = {}) => {
  return (options) => {
    const { width, height, depth, paddingLeft, paddingRight, paddingTop, paddingBottom, padding, inset, insetLeft, insetTop, insetRight, insetBottom, margin, marginLeft, marginBottom, marginTop, marginRight, data, coordinate, theme, component, interaction, x: x2, y: y3, z, key, frame, labelTransform, parentKey, clip, viewStyle, title } = options, mark2 = __rest60(options, ["width", "height", "depth", "paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "padding", "inset", "insetLeft", "insetTop", "insetRight", "insetBottom", "margin", "marginLeft", "marginBottom", "marginTop", "marginRight", "data", "coordinate", "theme", "component", "interaction", "x", "y", "z", "key", "frame", "labelTransform", "parentKey", "clip", "viewStyle", "title"]);
    return [
      Object.assign(Object.assign({
        type: "standardView",
        x: x2,
        y: y3,
        z,
        key,
        width,
        height,
        depth,
        padding,
        paddingLeft,
        paddingRight,
        paddingTop,
        inset,
        insetLeft,
        insetTop,
        insetRight,
        insetBottom,
        paddingBottom,
        theme,
        coordinate,
        component,
        interaction,
        frame,
        labelTransform,
        margin,
        marginLeft,
        marginBottom,
        marginTop,
        marginRight,
        parentKey,
        clip,
        style: viewStyle
      }, !isStatic && { title }), { marks: [Object.assign(Object.assign(Object.assign({}, mark2), { key: `${key}-0`, data }), isStatic && { title })] })
    ];
  };
};
Mark.props = {};

// node_modules/@antv/g2/esm/utils/container.js
var Container = class _Container {
  constructor(x2) {
    this.$value = x2;
  }
  static of(x2) {
    return new _Container(x2);
  }
  call(f2, ...rest) {
    return this.$value = f2(this.$value, ...rest), this;
  }
  value() {
    return this.$value;
  }
};

// node_modules/@antv/g2/esm/composition/facetRect.js
var __rest61 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var setScale = useDefaultAdaptor((options) => {
  const { encode, data, scale: scale4, shareSize = false } = options;
  const { x: x2, y: y3 } = encode;
  const flexDomain = (encode2, channel) => {
    var _a;
    if (encode2 === void 0 || !shareSize)
      return {};
    const groups2 = group(data, (d3) => d3[encode2]);
    const domain = ((_a = scale4 === null || scale4 === void 0 ? void 0 : scale4[channel]) === null || _a === void 0 ? void 0 : _a.domain) || Array.from(groups2.keys());
    const flex = domain.map((key) => {
      if (!groups2.has(key))
        return 1;
      return groups2.get(key).length;
    });
    return { domain, flex };
  };
  return {
    scale: {
      x: Object.assign(Object.assign({ paddingOuter: 0, paddingInner: 0.1, guide: x2 === void 0 ? null : { position: "top" } }, x2 === void 0 && { paddingInner: 0 }), flexDomain(x2, "x")),
      y: Object.assign(Object.assign({ range: [0, 1], paddingOuter: 0, paddingInner: 0.1, guide: y3 === void 0 ? null : { position: "right" } }, y3 === void 0 && { paddingInner: 0 }), flexDomain(y3, "y"))
    }
  };
});
var inferColor = useOverrideAdaptor((options) => {
  const { data, scale: scale4, legend } = options;
  const discovered = [options];
  let encodeColor;
  let scaleColor;
  let legendColor;
  while (discovered.length) {
    const node = discovered.shift();
    const { children, encode = {}, scale: scale5 = {}, legend: legend2 = {} } = node;
    const { color: c5 } = encode;
    const { color: cs } = scale5;
    const { color: cl } = legend2;
    if (c5 !== void 0)
      encodeColor = c5;
    if (cs !== void 0)
      scaleColor = cs;
    if (cl !== void 0)
      legendColor = cl;
    if (Array.isArray(children)) {
      discovered.push(...children);
    }
  }
  const domainColor = () => {
    var _a;
    const domain2 = (_a = scale4 === null || scale4 === void 0 ? void 0 : scale4.color) === null || _a === void 0 ? void 0 : _a.domain;
    if (domain2 !== void 0)
      return [domain2];
    if (encodeColor === void 0)
      return [void 0];
    const color = typeof encodeColor === "function" ? encodeColor : (d3) => d3[encodeColor];
    const values4 = data.map(color);
    if (values4.some((d3) => typeof d3 === "number"))
      return [extent(values4)];
    return [Array.from(new Set(values4)), "ordinal"];
  };
  const title = typeof encodeColor === "string" ? encodeColor : "";
  const [domain, type] = domainColor();
  return Object.assign({ encode: { color: { type: "column", value: domain !== null && domain !== void 0 ? domain : [] } }, scale: { color: deep_mix_default({}, scaleColor, { domain, type }) } }, legend === void 0 && {
    legend: { color: deep_mix_default({ title }, legendColor) }
  });
});
var setAnimation = useDefaultAdaptor(() => ({
  animate: {
    enterType: "fadeIn"
  }
}));
var setStyle = useOverrideAdaptor(() => ({
  frame: false,
  encode: {
    shape: "hollow"
  },
  style: {
    lineWidth: 0
  }
}));
var toCell = useOverrideAdaptor(() => ({
  type: "cell"
}));
var setData = useOverrideAdaptor((options) => {
  const { data } = options;
  const connector = {
    type: "custom",
    callback: () => {
      const { data: data2, encode } = options;
      const { x: x2, y: y3 } = encode;
      const X = x2 ? Array.from(new Set(data2.map((d3) => d3[x2]))) : [];
      const Y = y3 ? Array.from(new Set(data2.map((d3) => d3[y3]))) : [];
      const cellData = () => {
        if (X.length && Y.length) {
          const cellData2 = [];
          for (const vx of X) {
            for (const vy of Y) {
              cellData2.push({ [x2]: vx, [y3]: vy });
            }
          }
          return cellData2;
        }
        if (X.length)
          return X.map((d3) => ({ [x2]: d3 }));
        if (Y.length)
          return Y.map((d3) => ({ [y3]: d3 }));
      };
      return cellData();
    }
  };
  return {
    data: { type: "inline", value: data, transform: [connector] }
  };
});
var setChildren = useOverrideAdaptor((options, subLayout = subLayoutRect, createGuideX2 = createGuideXRect, createGuideY2 = createGuideYRect, childOptions = {}) => {
  const { data: dataValue, encode, children, scale: facetScale, x: originX = 0, y: originY = 0, shareData = false, key: viewKey } = options;
  const { value: data } = dataValue;
  const { x: encodeX, y: encodeY } = encode;
  const { color: facetScaleColor } = facetScale;
  const { domain: facetDomainColor } = facetScaleColor;
  const createChildren = (visualData, scale4, layout) => {
    const { x: scaleX, y: scaleY } = scale4;
    const { paddingLeft, paddingTop, marginLeft, marginTop } = layout;
    const { domain: domainX } = scaleX.getOptions();
    const { domain: domainY } = scaleY.getOptions();
    const index2 = indexOf(visualData);
    const bboxs = visualData.map(subLayout);
    const values4 = visualData.map(({ x: x2, y: y3 }) => [
      scaleX.invert(x2),
      scaleY.invert(y3)
    ]);
    const filters = values4.map(([fx, fy]) => (d3) => {
      const { [encodeX]: x2, [encodeY]: y3 } = d3;
      const inX = encodeX !== void 0 ? x2 === fx : true;
      const inY = encodeY !== void 0 ? y3 === fy : true;
      return inX && inY;
    });
    const facetData2d = filters.map((f2) => data.filter(f2));
    const maxDataDomain = shareData ? max(facetData2d, (data2) => data2.length) : void 0;
    const facets = values4.map(([fx, fy]) => ({
      columnField: encodeX,
      columnIndex: domainX.indexOf(fx),
      columnValue: fx,
      columnValuesLength: domainX.length,
      rowField: encodeY,
      rowIndex: domainY.indexOf(fy),
      rowValue: fy,
      rowValuesLength: domainY.length
    }));
    const normalizedChildren = facets.map((facet) => {
      if (Array.isArray(children))
        return children;
      return [children(facet)].flat(1);
    });
    return index2.flatMap((i2) => {
      const [left2, top, width, height] = bboxs[i2];
      const facet = facets[i2];
      const facetData = facetData2d[i2];
      const children2 = normalizedChildren[i2];
      return children2.map((_a) => {
        var _b, _c;
        var { scale: scale5, key, facet: isFacet = true, axis = {}, legend = {} } = _a, rest = __rest61(_a, ["scale", "key", "facet", "axis", "legend"]);
        const guideY = ((_b = scale5 === null || scale5 === void 0 ? void 0 : scale5.y) === null || _b === void 0 ? void 0 : _b.guide) || axis.y;
        const guideX = ((_c = scale5 === null || scale5 === void 0 ? void 0 : scale5.x) === null || _c === void 0 ? void 0 : _c.guide) || axis.x;
        const defaultScale = {
          x: { tickCount: encodeX ? 5 : void 0 },
          y: { tickCount: encodeY ? 5 : void 0 }
        };
        const newData = isFacet ? facetData : facetData.length === 0 ? [] : data;
        const newScale = {
          color: { domain: facetDomainColor }
        };
        const newAxis = {
          x: createGuide(guideX, createGuideX2)(facet, newData),
          y: createGuide(guideY, createGuideY2)(facet, newData)
        };
        return Object.assign(Object.assign({
          key: `${key}-${i2}`,
          data: newData,
          margin: 0,
          x: left2 + paddingLeft + originX + marginLeft,
          y: top + paddingTop + originY + marginTop,
          parentKey: viewKey,
          width,
          height,
          paddingLeft: 0,
          paddingRight: 0,
          paddingTop: 0,
          paddingBottom: 0,
          frame: newData.length ? true : false,
          dataDomain: maxDataDomain,
          scale: deep_mix_default(defaultScale, scale5, newScale),
          axis: deep_mix_default({}, axis, newAxis),
          // Hide all legends for child mark by default,
          // they are displayed in the top-level.
          legend: false
        }, rest), childOptions);
      });
    });
  };
  return {
    children: createChildren
  };
});
function subLayoutRect(data) {
  const { points } = data;
  return calcBBox(points);
}
function createInnerGuide(guide, data) {
  return data.length ? deep_mix_default({
    title: false,
    tick: null,
    label: null
  }, guide) : deep_mix_default({
    title: false,
    tick: null,
    label: null,
    grid: null
  }, guide);
}
function createGuideXRect(guide) {
  return (facet, data) => {
    const { rowIndex, rowValuesLength, columnIndex, columnValuesLength } = facet;
    if (rowIndex !== rowValuesLength - 1)
      return createInnerGuide(guide, data);
    const title = columnIndex !== columnValuesLength - 1 ? false : void 0;
    const grid = data.length ? void 0 : null;
    return deep_mix_default({ title, grid }, guide);
  };
}
function createGuideYRect(guide) {
  return (facet, data) => {
    const { rowIndex, columnIndex } = facet;
    if (columnIndex !== 0)
      return createInnerGuide(guide, data);
    const title = rowIndex !== 0 ? false : void 0;
    const grid = data.length ? void 0 : null;
    return deep_mix_default({ title, grid }, guide);
  };
}
function createGuide(guide, factory) {
  if (typeof guide === "function")
    return guide;
  if (guide === null || guide === false)
    return () => null;
  return factory(guide);
}
var FacetRect = () => {
  return (options) => {
    const newOptions = Container.of(options).call(toCell).call(inferColor).call(setAnimation).call(setScale).call(setStyle).call(setData).call(setChildren).value();
    return [newOptions];
  };
};
FacetRect.props = {};

// node_modules/@antv/g2/esm/composition/repeatMatrix.js
var __rest62 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var setScale2 = useDefaultAdaptor((options) => {
  return {
    scale: {
      x: { guide: null, paddingOuter: 0, paddingInner: 0.1 },
      y: { guide: null, range: [0, 1], paddingOuter: 0, paddingInner: 0.1 }
    }
  };
});
var setChildren2 = useOverrideAdaptor((options) => {
  const { data, children, x: originX = 0, y: originY = 0, key: viewKey } = options;
  const createChildren = (visualData, scale4, layout) => {
    const { x: scaleX, y: scaleY } = scale4;
    const { paddingLeft, paddingTop, marginLeft, marginTop } = layout;
    const { domain: domainX } = scaleX.getOptions();
    const { domain: domainY } = scaleY.getOptions();
    const index2 = indexOf(visualData);
    const bboxs = visualData.map(({ points }) => calcBBox(points));
    const values4 = visualData.map(({ x: x2, y: y3 }) => [
      scaleX.invert(x2),
      scaleY.invert(y3)
    ]);
    const facets = values4.map(([fx, fy]) => ({
      columnField: fx,
      columnIndex: domainX.indexOf(fx),
      columnValue: fx,
      columnValuesLength: domainX.length,
      rowField: fy,
      rowIndex: domainY.indexOf(fy),
      rowValue: fy,
      rowValuesLength: domainY.length
    }));
    const normalizedChildren = facets.map((facet) => {
      if (Array.isArray(children))
        return children;
      return [children(facet)].flat(1);
    });
    return index2.flatMap((i2) => {
      const [left2, top, width, height] = bboxs[i2];
      const [fx, fy] = values4[i2];
      const facet = facets[i2];
      const children2 = normalizedChildren[i2];
      return children2.map((d3) => {
        var _a, _b;
        const { scale: scale5, key, encode, axis, interaction } = d3, rest = __rest62(d3, ["scale", "key", "encode", "axis", "interaction"]);
        const guideY = (_a = scale5 === null || scale5 === void 0 ? void 0 : scale5.y) === null || _a === void 0 ? void 0 : _a.guide;
        const guideX = (_b = scale5 === null || scale5 === void 0 ? void 0 : scale5.x) === null || _b === void 0 ? void 0 : _b.guide;
        const defaultScale = {
          // Do not sync position scales among facets by default.
          x: { facet: false },
          // Do not sync position scales among facets by default.
          y: { facet: false }
        };
        const newAxis = {
          x: createGuideX(guideX)(facet, data),
          y: createGuideY(guideY)(facet, data)
        };
        const defaultAxis = {
          x: { tickCount: 5 },
          y: { tickCount: 5 }
        };
        return Object.assign({
          data,
          parentKey: viewKey,
          key: `${key}-${i2}`,
          x: left2 + paddingLeft + originX + marginLeft,
          y: top + paddingTop + originY + marginTop,
          width,
          height,
          margin: 0,
          paddingLeft: 0,
          paddingRight: 0,
          paddingTop: 0,
          paddingBottom: 0,
          frame: true,
          scale: deep_mix_default(defaultScale, scale5),
          axis: deep_mix_default(defaultAxis, axis, newAxis),
          // Hide all legends for child mark by default,
          // they are displayed in the top-level.
          legend: false,
          encode: deep_mix_default({}, encode, {
            x: fx,
            y: fy
          }),
          interaction: deep_mix_default({}, interaction, {
            // Register this interaction in parent node.
            legendFilter: false
          })
        }, rest);
      });
    });
  };
  return {
    children: createChildren
  };
});
var setData2 = useOverrideAdaptor((options) => {
  const { encode } = options, rest = __rest62(options, ["encode"]);
  const { position: P = [], x: X = P, y: Y = [...P].reverse() } = encode, restEncode = __rest62(encode, ["position", "x", "y"]);
  const data = [];
  for (const $x of [X].flat(1)) {
    for (const $y of [Y].flat(1)) {
      data.push({ $x, $y });
    }
  }
  return Object.assign(Object.assign({}, rest), { data, encode: Object.assign(Object.assign({}, restEncode), { x: "$x", y: "$y" }), scale: Object.assign(Object.assign({}, [X].flat(1).length === 1 && { x: { paddingInner: 0 } }), [Y].flat(1).length === 1 && { y: { paddingInner: 0 } }) });
});
function createGuideX(guideX) {
  if (typeof guideX === "function")
    return guideX;
  if (guideX === null)
    return () => null;
  return (facet, data) => {
    const { rowIndex, rowValuesLength } = facet;
    if (rowIndex !== rowValuesLength - 1)
      return createInnerGuide(guideX, data);
  };
}
function createGuideY(guideY) {
  if (typeof guideY === "function")
    return guideY;
  if (guideY === null)
    return () => null;
  return (facet, data) => {
    const { columnIndex } = facet;
    if (columnIndex !== 0)
      return createInnerGuide(guideY, data);
  };
}
var RepeatMatrix = () => {
  return (options) => {
    const newOptions = Container.of(options).call(toCell).call(inferColor).call(setChildren2).call(setData2).call(setAnimation).call(setStyle).call(setScale2).value();
    return [newOptions];
  };
};

// node_modules/@antv/g2/esm/composition/facetCircle.js
var __rest63 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var setScale3 = useDefaultAdaptor((options) => {
  return {
    scale: {
      x: { guide: { type: "axisArc" }, paddingOuter: 0, paddingInner: 0.1 },
      y: { guide: null, range: [0, 1], paddingOuter: 0, paddingInner: 0.1 }
    }
  };
});
var setCoordinate = useDefaultAdaptor((options) => {
  return {
    coordinate: { type: "polar" }
  };
});
var setEncode = (options) => {
  const { encode } = options, rest = __rest63(options, ["encode"]);
  const { position } = encode;
  return Object.assign(Object.assign({}, rest), { encode: { x: position } });
};
function createGuideFacetCircle(guide) {
  return (facet) => null;
}
function subLayoutFacetCircle(data) {
  const { points } = data;
  const [p0, p1, p22, p3] = points;
  const sr = dist(p0, p3);
  const v0 = sub(p0, p3);
  const v1 = sub(p1, p22);
  const a01 = angleBetween(v0, v1);
  const t = 1 / Math.sin(a01 / 2);
  const ir = sr / (1 + t);
  const s3 = ir * Math.sqrt(2);
  const [x05, y05] = p22;
  const a0 = angleWithQuadrant(v0);
  const a32 = a0 + a01 / 2;
  const d3 = ir * t;
  const cx = x05 + d3 * Math.sin(a32);
  const cy = y05 - d3 * Math.cos(a32);
  return [cx - s3 / 2, cy - s3 / 2, s3, s3];
}
var FacetCircle = () => {
  return (options) => {
    const newOptions = Container.of(options).call(toCell).call(setEncode).call(inferColor).call(setCoordinate).call(setData).call(setChildren, subLayoutFacetCircle, createGuideFacetCircle, createGuideFacetCircle, { frame: false }).call(setAnimation).call(setStyle).call(setScale3).value();
    return [newOptions];
  };
};

// node_modules/@antv/g2/esm/composition/timingKeyframe.js
function range2(direction2, iterationCount, keyframeCount) {
  const start = 0;
  const end = keyframeCount;
  const normal = [start, end];
  const reverse2 = [-end + 1, -start + 1];
  if (direction2 === "normal")
    return normal;
  if (direction2 === "reverse")
    return reverse2;
  if (direction2 === "alternate") {
    return iterationCount % 2 === 0 ? normal : reverse2;
  }
  if (direction2 === "reverse-alternate") {
    return iterationCount % 2 === 0 ? reverse2 : normal;
  }
}
function setAnimation2(node, duration, easing) {
  const discovered = [node];
  while (discovered.length) {
    const n2 = discovered.pop();
    n2.animate = deep_mix_default({
      enter: {
        duration
      },
      update: {
        duration,
        easing,
        type: "morphing",
        fill: "both"
      },
      exit: {
        type: "fadeOut",
        duration
      }
    }, n2.animate || {});
    const { children } = n2;
    if (Array.isArray(children))
      discovered.push(...children);
  }
  return node;
}
var TimingKeyframe = () => {
  return (options) => {
    const { children = [], duration = 1e3, iterationCount = 1, direction: direction2 = "normal", easing = "ease-in-out-sine" } = options;
    const n2 = children.length;
    if (!Array.isArray(children) || n2 === 0)
      return [];
    const { key } = children[0];
    const newChildren = children.map((d3) => Object.assign(Object.assign({}, d3), { key })).map((d3) => setAnimation2(d3, duration, easing));
    return function* () {
      let count4 = 0;
      let prevIndex;
      while (iterationCount === "infinite" || count4 < iterationCount) {
        const [start, end] = range2(direction2, count4, n2);
        for (let i2 = start; i2 < end; i2 += 1) {
          const index2 = Math.abs(i2);
          if (prevIndex !== index2)
            yield newChildren[index2];
          prevIndex = index2;
        }
        count4++;
      }
    };
  };
};
TimingKeyframe.props = {};

// node_modules/@antv/g2/esm/composition/geoPath.js
var __rest64 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var GeoPath = () => {
  return (options) => {
    const { type, data, scale: scale4, encode, style, animate, key, state, tooltip: tooltip2 } = options, rest = __rest64(options, ["type", "data", "scale", "encode", "style", "animate", "key", "state", "tooltip"]);
    return [
      Object.assign(Object.assign({ type: "geoView" }, rest), { children: [
        {
          type: "geoPath",
          key: `${key}-0`,
          data: {
            value: data
          },
          scale: scale4,
          encode,
          style,
          animate,
          state,
          tooltip: tooltip2
        }
      ] })
    ];
  };
};
GeoPath.props = {};

// node_modules/d3-geo/src/math.js
var epsilon3 = 1e-6;
var epsilon22 = 1e-12;
var pi3 = Math.PI;
var halfPi2 = pi3 / 2;
var quarterPi = pi3 / 4;
var tau3 = pi3 * 2;
var degrees = 180 / pi3;
var radians = pi3 / 180;
var abs2 = Math.abs;
var atan = Math.atan;
var atan22 = Math.atan2;
var cos2 = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var log = Math.log;
var pow = Math.pow;
var sin2 = Math.sin;
var sign2 = Math.sign || function(x2) {
  return x2 > 0 ? 1 : x2 < 0 ? -1 : 0;
};
var sqrt2 = Math.sqrt;
var tan = Math.tan;
function acos2(x2) {
  return x2 > 1 ? 0 : x2 < -1 ? pi3 : Math.acos(x2);
}
function asin2(x2) {
  return x2 > 1 ? halfPi2 : x2 < -1 ? -halfPi2 : Math.asin(x2);
}

// node_modules/d3-geo/src/noop.js
function noop() {
}

// node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}
var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i2 = -1, n2 = features.length;
    while (++i2 < n2) streamGeometry(features[i2].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i2 = -1, n2 = coordinates.length;
    while (++i2 < n2) object = coordinates[i2], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i2 = -1, n2 = coordinates.length;
    while (++i2 < n2) streamLine(coordinates[i2], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i2 = -1, n2 = coordinates.length;
    while (++i2 < n2) streamPolygon(coordinates[i2], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i2 = -1, n2 = geometries.length;
    while (++i2 < n2) streamGeometry(geometries[i2], stream);
  }
};
function streamLine(coordinates, stream, closed) {
  var i2 = -1, n2 = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i2 < n2) coordinate = coordinates[i2], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates, stream) {
  var i2 = -1, n2 = coordinates.length;
  stream.polygonStart();
  while (++i2 < n2) streamLine(coordinates[i2], stream, 1);
  stream.polygonEnd();
}
function stream_default(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}

// node_modules/d3-geo/src/area.js
var areaRingSum = new Adder();
var areaSum = new Adder();

// node_modules/d3-geo/src/cartesian.js
function spherical(cartesian3) {
  return [atan22(cartesian3[1], cartesian3[0]), asin2(cartesian3[2])];
}
function cartesian2(spherical2) {
  var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos2(phi2);
  return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2)];
}
function cartesianDot(a4, b) {
  return a4[0] * b[0] + a4[1] * b[1] + a4[2] * b[2];
}
function cartesianCross(a4, b) {
  return [a4[1] * b[2] - a4[2] * b[1], a4[2] * b[0] - a4[0] * b[2], a4[0] * b[1] - a4[1] * b[0]];
}
function cartesianAddInPlace(a4, b) {
  a4[0] += b[0], a4[1] += b[1], a4[2] += b[2];
}
function cartesianScale(vector, k2) {
  return [vector[0] * k2, vector[1] * k2, vector[2] * k2];
}
function cartesianNormalizeInPlace(d3) {
  var l2 = sqrt2(d3[0] * d3[0] + d3[1] * d3[1] + d3[2] * d3[2]);
  d3[0] /= l2, d3[1] /= l2, d3[2] /= l2;
}

// node_modules/d3-geo/src/compose.js
function compose_default(a4, b) {
  function compose5(x2, y3) {
    return x2 = a4(x2, y3), b(x2[0], x2[1]);
  }
  if (a4.invert && b.invert) compose5.invert = function(x2, y3) {
    return x2 = b.invert(x2, y3), x2 && a4.invert(x2[0], x2[1]);
  };
  return compose5;
}

// node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi2) {
  if (abs2(lambda) > pi3) lambda -= Math.round(lambda / tau3) * tau3;
  return [lambda, phi2];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau3) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi2) {
    lambda += deltaLambda;
    if (abs2(lambda) > pi3) lambda -= Math.round(lambda / tau3) * tau3;
    return [lambda, phi2];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos2(deltaPhi), sinDeltaPhi = sin2(deltaPhi), cosDeltaGamma = cos2(deltaGamma), sinDeltaGamma = sin2(deltaGamma);
  function rotation(lambda, phi2) {
    var cosPhi = cos2(phi2), x2 = cos2(lambda) * cosPhi, y3 = sin2(lambda) * cosPhi, z = sin2(phi2), k2 = z * cosDeltaPhi + x2 * sinDeltaPhi;
    return [
      atan22(y3 * cosDeltaGamma - k2 * sinDeltaGamma, x2 * cosDeltaPhi - z * sinDeltaPhi),
      asin2(k2 * cosDeltaGamma + y3 * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi2) {
    var cosPhi = cos2(phi2), x2 = cos2(lambda) * cosPhi, y3 = sin2(lambda) * cosPhi, z = sin2(phi2), k2 = z * cosDeltaGamma - y3 * sinDeltaGamma;
    return [
      atan22(y3 * cosDeltaGamma + z * sinDeltaGamma, x2 * cosDeltaPhi + k2 * sinDeltaPhi),
      asin2(k2 * cosDeltaPhi - x2 * sinDeltaPhi)
    ];
  };
  return rotation;
}
function rotation_default(rotate2) {
  rotate2 = rotateRadians(rotate2[0] * radians, rotate2[1] * radians, rotate2.length > 2 ? rotate2[2] * radians : 0);
  function forward(coordinates) {
    coordinates = rotate2(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  }
  forward.invert = function(coordinates) {
    coordinates = rotate2.invert(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  };
  return forward;
}

// node_modules/d3-geo/src/circle.js
function circleStream(stream, radius, delta, direction2, t0, t1) {
  if (!delta) return;
  var cosRadius = cos2(radius), sinRadius = sin2(radius), step = direction2 * delta;
  if (t0 == null) {
    t0 = radius + direction2 * tau3;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction2 > 0 ? t0 < t1 : t0 > t1) t0 += direction2 * tau3;
  }
  for (var point6, t = t0; direction2 > 0 ? t > t1 : t < t1; t -= step) {
    point6 = spherical([cosRadius, -sinRadius * cos2(t), -sinRadius * sin2(t)]);
    stream.point(point6[0], point6[1]);
  }
}
function circleRadius(cosRadius, point6) {
  point6 = cartesian2(point6), point6[0] -= cosRadius;
  cartesianNormalizeInPlace(point6);
  var radius = acos2(-point6[1]);
  return ((-point6[2] < 0 ? -radius : radius) + tau3 - epsilon3) % tau3;
}

// node_modules/d3-geo/src/clip/buffer.js
function buffer_default() {
  var lines = [], line3;
  return {
    point: function(x2, y3, m2) {
      line3.push([x2, y3, m2]);
    },
    lineStart: function() {
      lines.push(line3 = []);
    },
    lineEnd: noop,
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line3 = null;
      return result;
    }
  };
}

// node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a4, b) {
  return abs2(a4[0] - b[0]) < epsilon3 && abs2(a4[1] - b[1]) < epsilon3;
}

// node_modules/d3-geo/src/clip/rejoin.js
function Intersection(point6, points, other, entry) {
  this.x = point6;
  this.z = points;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments, compareIntersection2, startInside, interpolate2, stream) {
  var subject = [], clip = [], i2, n2;
  segments.forEach(function(segment) {
    if ((n3 = segment.length - 1) <= 0) return;
    var n3, p0 = segment[0], p1 = segment[n3], x2;
    if (pointEqual_default(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i2 = 0; i2 < n3; ++i2) stream.point((p0 = segment[i2])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon3;
    }
    subject.push(x2 = new Intersection(p0, segment, null, true));
    clip.push(x2.o = new Intersection(p0, null, x2, false));
    subject.push(x2 = new Intersection(p1, segment, null, false));
    clip.push(x2.o = new Intersection(p1, null, x2, true));
  });
  if (!subject.length) return;
  clip.sort(compareIntersection2);
  link2(subject);
  link2(clip);
  for (i2 = 0, n2 = clip.length; i2 < n2; ++i2) {
    clip[i2].e = startInside = !startInside;
  }
  var start = subject[0], points, point6;
  while (1) {
    var current = start, isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i2 = 0, n2 = points.length; i2 < n2; ++i2) stream.point((point6 = points[i2])[0], point6[1]);
        } else {
          interpolate2(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i2 = points.length - 1; i2 >= 0; --i2) stream.point((point6 = points[i2])[0], point6[1]);
        } else {
          interpolate2(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link2(array2) {
  if (!(n2 = array2.length)) return;
  var n2, i2 = 0, a4 = array2[0], b;
  while (++i2 < n2) {
    a4.n = b = array2[i2];
    b.p = a4;
    a4 = b;
  }
  a4.n = b = array2[0];
  b.p = a4;
}

// node_modules/d3-geo/src/polygonContains.js
function longitude(point6) {
  return abs2(point6[0]) <= pi3 ? point6[0] : sign2(point6[0]) * ((abs2(point6[0]) + pi3) % tau3 - pi3);
}
function polygonContains_default(polygon, point6) {
  var lambda = longitude(point6), phi2 = point6[1], sinPhi = sin2(phi2), normal = [sin2(lambda), -cos2(lambda), 0], angle2 = 0, winding = 0;
  var sum4 = new Adder();
  if (sinPhi === 1) phi2 = halfPi2 + epsilon3;
  else if (sinPhi === -1) phi2 = -halfPi2 - epsilon3;
  for (var i2 = 0, n2 = polygon.length; i2 < n2; ++i2) {
    if (!(m2 = (ring = polygon[i2]).length)) continue;
    var ring, m2, point0 = ring[m2 - 1], lambda0 = longitude(point0), phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin2(phi0), cosPhi0 = cos2(phi0);
    for (var j = 0; j < m2; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j], lambda1 = longitude(point1), phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi1), cosPhi1 = cos2(phi1), delta = lambda1 - lambda0, sign3 = delta >= 0 ? 1 : -1, absDelta = sign3 * delta, antimeridian = absDelta > pi3, k2 = sinPhi0 * sinPhi1;
      sum4.add(atan22(k2 * sign3 * sin2(absDelta), cosPhi0 * cosPhi1 + k2 * cos2(absDelta)));
      angle2 += antimeridian ? delta + sign3 * tau3 : delta;
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian2(point0), cartesian2(point1));
        cartesianNormalizeInPlace(arc);
        var intersection2 = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection2);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin2(intersection2[2]);
        if (phi2 > phiArc || phi2 === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle2 < -epsilon3 || angle2 < epsilon3 && sum4 < -epsilon22) ^ winding & 1;
}

// node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate2, start) {
  return function(sink) {
    var line3 = clipLine(sink), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
    var clip = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point6;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge(segments);
        var startInside = polygonContains_default(polygon, start);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments, compareIntersection, startInside, interpolate2, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate2(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate2(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point6(lambda, phi2) {
      if (pointVisible(lambda, phi2)) sink.point(lambda, phi2);
    }
    function pointLine(lambda, phi2) {
      line3.point(lambda, phi2);
    }
    function lineStart() {
      clip.point = pointLine;
      line3.lineStart();
    }
    function lineEnd() {
      clip.point = point6;
      line3.lineEnd();
    }
    function pointRing(lambda, phi2) {
      ring.push([lambda, phi2]);
      ringSink.point(lambda, phi2);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i2, n2 = ringSegments.length, m2, segment, point7;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n2) return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m2 = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i2 = 0; i2 < m2; ++i2) sink.point((point7 = segment[i2])[0], point7[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n2 > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }
    return clip;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a4, b) {
  return ((a4 = a4.x)[0] < 0 ? a4[1] - halfPi2 - epsilon3 : halfPi2 - a4[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi2 - epsilon3 : halfPi2 - b[1]);
}

// node_modules/d3-geo/src/clip/antimeridian.js
var antimeridian_default = clip_default(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi3, -halfPi2]
);
function clipAntimeridianLine(stream) {
  var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi3 : -pi3, delta = abs2(lambda1 - lambda0);
      if (abs2(delta - pi3) < epsilon3) {
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi2 : -halfPi2);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi3) {
        if (abs2(lambda0 - sign0) < epsilon3) lambda0 -= sign0 * epsilon3;
        if (abs2(lambda1 - sign1) < epsilon3) lambda1 -= sign1 * epsilon3;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin2(lambda0 - lambda1);
  return abs2(sinLambda0Lambda1) > epsilon3 ? atan((sin2(phi0) * (cosPhi1 = cos2(phi1)) * sin2(lambda1) - sin2(phi1) * (cosPhi0 = cos2(phi0)) * sin2(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}
function clipAntimeridianInterpolate(from, to, direction2, stream) {
  var phi2;
  if (from == null) {
    phi2 = direction2 * halfPi2;
    stream.point(-pi3, phi2);
    stream.point(0, phi2);
    stream.point(pi3, phi2);
    stream.point(pi3, 0);
    stream.point(pi3, -phi2);
    stream.point(0, -phi2);
    stream.point(-pi3, -phi2);
    stream.point(-pi3, 0);
    stream.point(-pi3, phi2);
  } else if (abs2(from[0] - to[0]) > epsilon3) {
    var lambda = from[0] < to[0] ? pi3 : -pi3;
    phi2 = direction2 * lambda / 2;
    stream.point(-lambda, phi2);
    stream.point(0, phi2);
    stream.point(lambda, phi2);
  } else {
    stream.point(to[0], to[1]);
  }
}

// node_modules/d3-geo/src/clip/circle.js
function circle_default2(radius) {
  var cr = cos2(radius), delta = 2 * radians, smallRadius = cr > 0, notHemisphere = abs2(cr) > epsilon3;
  function interpolate2(from, to, direction2, stream) {
    circleStream(stream, radius, delta, direction2, from, to);
  }
  function visible(lambda, phi2) {
    return cos2(lambda) * cos2(phi2) > cr;
  }
  function clipLine(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi2) {
        var point1 = [lambda, phi2], point22, v = visible(lambda, phi2), c5 = smallRadius ? v ? 0 : code(lambda, phi2) : v ? code(lambda + (lambda < 0 ? pi3 : -pi3), phi2) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart();
        if (v !== v0) {
          point22 = intersect3(point0, point1);
          if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
            point1[2] = 1;
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            stream.lineStart();
            point22 = intersect3(point1, point0);
            stream.point(point22[0], point22[1]);
          } else {
            point22 = intersect3(point0, point1);
            stream.point(point22[0], point22[1], 2);
            stream.lineEnd();
          }
          point0 = point22;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          if (!(c5 & c0) && (t = intersect3(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v && (!point0 || !pointEqual_default(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c5;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect3(a4, b, two) {
    var pa = cartesian2(a4), pb = cartesian2(b);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant) return !two && a4;
    var c1 = cr * n2n2 / determinant, c22 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B = cartesianScale(n2, c22);
    cartesianAddInPlace(A5, B);
    var u2 = n1xn2, w2 = cartesianDot(A5, u2), uu = cartesianDot(u2, u2), t2 = w2 * w2 - uu * (cartesianDot(A5, A5) - 1);
    if (t2 < 0) return;
    var t = sqrt2(t2), q = cartesianScale(u2, (-w2 - t) / uu);
    cartesianAddInPlace(q, A5);
    q = spherical(q);
    if (!two) return q;
    var lambda0 = a4[0], lambda1 = b[0], phi0 = a4[1], phi1 = b[1], z;
    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;
    var delta2 = lambda1 - lambda0, polar2 = abs2(delta2 - pi3) < epsilon3, meridian = polar2 || delta2 < epsilon3;
    if (!polar2 && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;
    if (meridian ? polar2 ? phi0 + phi1 > 0 ^ q[1] < (abs2(q[0] - lambda0) < epsilon3 ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta2 > pi3 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q12 = cartesianScale(u2, (-w2 + t) / uu);
      cartesianAddInPlace(q12, A5);
      return [q, spherical(q12)];
    }
  }
  function code(lambda, phi2) {
    var r2 = smallRadius ? radius : pi3 - radius, code2 = 0;
    if (lambda < -r2) code2 |= 1;
    else if (lambda > r2) code2 |= 2;
    if (phi2 < -r2) code2 |= 4;
    else if (phi2 > r2) code2 |= 8;
    return code2;
  }
  return clip_default(visible, clipLine, interpolate2, smallRadius ? [0, -radius] : [-pi3, radius - pi3]);
}

// node_modules/d3-geo/src/clip/line.js
function line_default2(a4, b, x05, y05, x12, y12) {
  var ax = a4[0], ay = a4[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r2;
  r2 = x05 - ax;
  if (!dx && r2 > 0) return;
  r2 /= dx;
  if (dx < 0) {
    if (r2 < t0) return;
    if (r2 < t1) t1 = r2;
  } else if (dx > 0) {
    if (r2 > t1) return;
    if (r2 > t0) t0 = r2;
  }
  r2 = x12 - ax;
  if (!dx && r2 < 0) return;
  r2 /= dx;
  if (dx < 0) {
    if (r2 > t1) return;
    if (r2 > t0) t0 = r2;
  } else if (dx > 0) {
    if (r2 < t0) return;
    if (r2 < t1) t1 = r2;
  }
  r2 = y05 - ay;
  if (!dy && r2 > 0) return;
  r2 /= dy;
  if (dy < 0) {
    if (r2 < t0) return;
    if (r2 < t1) t1 = r2;
  } else if (dy > 0) {
    if (r2 > t1) return;
    if (r2 > t0) t0 = r2;
  }
  r2 = y12 - ay;
  if (!dy && r2 < 0) return;
  r2 /= dy;
  if (dy < 0) {
    if (r2 > t1) return;
    if (r2 > t0) t0 = r2;
  } else if (dy > 0) {
    if (r2 < t0) return;
    if (r2 < t1) t1 = r2;
  }
  if (t0 > 0) a4[0] = ax + t0 * dx, a4[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}

// node_modules/d3-geo/src/clip/rectangle.js
var clipMax = 1e9;
var clipMin = -clipMax;
function clipRectangle(x05, y05, x12, y12) {
  function visible(x2, y3) {
    return x05 <= x2 && x2 <= x12 && y05 <= y3 && y3 <= y12;
  }
  function interpolate2(from, to, direction2, stream) {
    var a4 = 0, a1 = 0;
    if (from == null || (a4 = corner(from, direction2)) !== (a1 = corner(to, direction2)) || comparePoint(from, to) < 0 ^ direction2 > 0) {
      do
        stream.point(a4 === 0 || a4 === 3 ? x05 : x12, a4 > 1 ? y12 : y05);
      while ((a4 = (a4 + direction2 + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function corner(p3, direction2) {
    return abs2(p3[0] - x05) < epsilon3 ? direction2 > 0 ? 0 : 3 : abs2(p3[0] - x12) < epsilon3 ? direction2 > 0 ? 2 : 1 : abs2(p3[1] - y05) < epsilon3 ? direction2 > 0 ? 1 : 0 : direction2 > 0 ? 3 : 2;
  }
  function compareIntersection2(a4, b) {
    return comparePoint(a4.x, b.x);
  }
  function comparePoint(a4, b) {
    var ca = corner(a4, 1), cb = corner(b, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b[1] - a4[1] : ca === 1 ? a4[0] - b[0] : ca === 2 ? a4[1] - b[1] : b[0] - a4[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = buffer_default(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first3, clean;
    var clipStream = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point6(x2, y3) {
      if (visible(x2, y3)) activeStream.point(x2, y3);
    }
    function polygonInside() {
      var winding = 0;
      for (var i2 = 0, n2 = polygon.length; i2 < n2; ++i2) {
        for (var ring2 = polygon[i2], j = 1, m2 = ring2.length, point7 = ring2[0], a0, a1, b0 = point7[0], b1 = point7[1]; j < m2; ++j) {
          a0 = b0, a1 = b1, point7 = ring2[j], b0 = point7[0], b1 = point7[1];
          if (a1 <= y12) {
            if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x05 - a0)) ++winding;
          } else {
            if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x05 - a0)) --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge(segments)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate2(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          rejoin_default(segments, compareIntersection2, startInside, interpolate2, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first3 = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point6;
      if (v_) activeStream.lineEnd();
    }
    function linePoint(x2, y3) {
      var v = visible(x2, y3);
      if (polygon) ring.push([x2, y3]);
      if (first3) {
        x__ = x2, y__ = y3, v__ = v;
        first3 = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x2, y3);
        }
      } else {
        if (v && v_) activeStream.point(x2, y3);
        else {
          var a4 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x2 = Math.max(clipMin, Math.min(clipMax, x2)), y3 = Math.max(clipMin, Math.min(clipMax, y3))];
          if (line_default2(a4, b, x05, y05, x12, y12)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a4[0], a4[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x2, y3);
            clean = false;
          }
        }
      }
      x_ = x2, y_ = y3, v_ = v;
    }
    return clipStream;
  };
}

// node_modules/d3-geo/src/graticule.js
function graticuleX(y05, y12, dy) {
  var y3 = range(y05, y12 - epsilon3, dy).concat(y12);
  return function(x2) {
    return y3.map(function(y4) {
      return [x2, y4];
    });
  };
}
function graticuleY(x05, x12, dx) {
  var x2 = range(x05, x12 - epsilon3, dx).concat(x12);
  return function(y3) {
    return x2.map(function(x3) {
      return [x3, y3];
    });
  };
}
function graticule() {
  var x12, x05, X12, X02, y12, y05, Y12, Y02, dx = 10, dy = dx, DX = 90, DY = 360, x2, y3, X, Y, precision = 2.5;
  function graticule2() {
    return { type: "MultiLineString", coordinates: lines() };
  }
  function lines() {
    return range(ceil(X02 / DX) * DX, X12, DX).map(X).concat(range(ceil(Y02 / DY) * DY, Y12, DY).map(Y)).concat(range(ceil(x05 / dx) * dx, x12, dx).filter(function(x3) {
      return abs2(x3 % DX) > epsilon3;
    }).map(x2)).concat(range(ceil(y05 / dy) * dy, y12, dy).filter(function(y4) {
      return abs2(y4 % DY) > epsilon3;
    }).map(y3));
  }
  graticule2.lines = function() {
    return lines().map(function(coordinates) {
      return { type: "LineString", coordinates };
    });
  };
  graticule2.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X(X02).concat(
          Y(Y12).slice(1),
          X(X12).reverse().slice(1),
          Y(Y02).reverse().slice(1)
        )
      ]
    };
  };
  graticule2.extent = function(_) {
    if (!arguments.length) return graticule2.extentMinor();
    return graticule2.extentMajor(_).extentMinor(_);
  };
  graticule2.extentMajor = function(_) {
    if (!arguments.length) return [[X02, Y02], [X12, Y12]];
    X02 = +_[0][0], X12 = +_[1][0];
    Y02 = +_[0][1], Y12 = +_[1][1];
    if (X02 > X12) _ = X02, X02 = X12, X12 = _;
    if (Y02 > Y12) _ = Y02, Y02 = Y12, Y12 = _;
    return graticule2.precision(precision);
  };
  graticule2.extentMinor = function(_) {
    if (!arguments.length) return [[x05, y05], [x12, y12]];
    x05 = +_[0][0], x12 = +_[1][0];
    y05 = +_[0][1], y12 = +_[1][1];
    if (x05 > x12) _ = x05, x05 = x12, x12 = _;
    if (y05 > y12) _ = y05, y05 = y12, y12 = _;
    return graticule2.precision(precision);
  };
  graticule2.step = function(_) {
    if (!arguments.length) return graticule2.stepMinor();
    return graticule2.stepMajor(_).stepMinor(_);
  };
  graticule2.stepMajor = function(_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule2;
  };
  graticule2.stepMinor = function(_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule2;
  };
  graticule2.precision = function(_) {
    if (!arguments.length) return precision;
    precision = +_;
    x2 = graticuleX(y05, y12, 90);
    y3 = graticuleY(x05, x12, precision);
    X = graticuleX(Y02, Y12, 90);
    Y = graticuleY(X02, X12, precision);
    return graticule2;
  };
  return graticule2.extentMajor([[-180, -90 + epsilon3], [180, 90 - epsilon3]]).extentMinor([[-180, -80 - epsilon3], [180, 80 + epsilon3]]);
}
function graticule10() {
  return graticule()();
}

// node_modules/d3-geo/src/identity.js
var identity_default6 = (x2) => x2;

// node_modules/d3-geo/src/path/area.js
var areaSum2 = new Adder();
var areaRingSum2 = new Adder();
var x00;
var y00;
var x0;
var y0;
var areaStream2 = {
  point: noop,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: function() {
    areaStream2.lineStart = areaRingStart;
    areaStream2.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream2.lineStart = areaStream2.lineEnd = areaStream2.point = noop;
    areaSum2.add(abs2(areaRingSum2));
    areaRingSum2 = new Adder();
  },
  result: function() {
    var area2 = areaSum2 / 2;
    areaSum2 = new Adder();
    return area2;
  }
};
function areaRingStart() {
  areaStream2.point = areaPointFirst;
}
function areaPointFirst(x2, y3) {
  areaStream2.point = areaPoint;
  x00 = x0 = x2, y00 = y0 = y3;
}
function areaPoint(x2, y3) {
  areaRingSum2.add(y0 * x2 - x0 * y3);
  x0 = x2, y0 = y3;
}
function areaRingEnd() {
  areaPoint(x00, y00);
}
var area_default2 = areaStream2;

// node_modules/d3-geo/src/path/bounds.js
var x02 = Infinity;
var y02 = x02;
var x1 = -x02;
var y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: noop,
  polygonEnd: noop,
  result: function() {
    var bounds = [[x02, y02], [x1, y1]];
    x1 = y1 = -(y02 = x02 = Infinity);
    return bounds;
  }
};
function boundsPoint(x2, y3) {
  if (x2 < x02) x02 = x2;
  if (x2 > x1) x1 = x2;
  if (y3 < y02) y02 = y3;
  if (y3 > y1) y1 = y3;
}
var bounds_default = boundsStream;

// node_modules/d3-geo/src/path/centroid.js
var X0 = 0;
var Y0 = 0;
var Z0 = 0;
var X1 = 0;
var Y1 = 0;
var Z1 = 0;
var X2 = 0;
var Y2 = 0;
var Z2 = 0;
var x002;
var y002;
var x03;
var y03;
var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
    X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
    return centroid;
  }
};
function centroidPoint(x2, y3) {
  X0 += x2;
  Y0 += y3;
  ++Z0;
}
function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x2, y3) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x03 = x2, y03 = y3);
}
function centroidPointLine(x2, y3) {
  var dx = x2 - x03, dy = y3 - y03, z = sqrt2(dx * dx + dy * dy);
  X1 += z * (x03 + x2) / 2;
  Y1 += z * (y03 + y3) / 2;
  Z1 += z;
  centroidPoint(x03 = x2, y03 = y3);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}
function centroidRingEnd() {
  centroidPointRing(x002, y002);
}
function centroidPointFirstRing(x2, y3) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x002 = x03 = x2, y002 = y03 = y3);
}
function centroidPointRing(x2, y3) {
  var dx = x2 - x03, dy = y3 - y03, z = sqrt2(dx * dx + dy * dy);
  X1 += z * (x03 + x2) / 2;
  Y1 += z * (y03 + y3) / 2;
  Z1 += z;
  z = y03 * x2 - x03 * y3;
  X2 += z * (x03 + x2);
  Y2 += z * (y03 + y3);
  Z2 += z * 3;
  centroidPoint(x03 = x2, y03 = y3);
}
var centroid_default = centroidStream;

// node_modules/d3-geo/src/path/context.js
function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x2, y3) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x2, y3);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x2, y3);
        break;
      }
      default: {
        this._context.moveTo(x2 + this._radius, y3);
        this._context.arc(x2, y3, this._radius, 0, tau3);
        break;
      }
    }
  },
  result: noop
};

// node_modules/d3-geo/src/path/measure.js
var lengthSum = new Adder();
var lengthRing;
var x003;
var y003;
var x04;
var y04;
var lengthStream = {
  point: noop,
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint(x003, y003);
    lengthStream.point = noop;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length = +lengthSum;
    lengthSum = new Adder();
    return length;
  }
};
function lengthPointFirst(x2, y3) {
  lengthStream.point = lengthPoint;
  x003 = x04 = x2, y003 = y04 = y3;
}
function lengthPoint(x2, y3) {
  x04 -= x2, y04 -= y3;
  lengthSum.add(sqrt2(x04 * x04 + y04 * y04));
  x04 = x2, y04 = y3;
}
var measure_default = lengthStream;

// node_modules/d3-geo/src/path/string.js
var cacheDigits;
var cacheAppend;
var cacheRadius;
var cacheCircle;
var PathString = class {
  constructor(digits) {
    this._append = digits == null ? append2 : appendRound2(digits);
    this._radius = 4.5;
    this._ = "";
  }
  pointRadius(_) {
    this._radius = +_;
    return this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line === 0) this._ += "Z";
    this._point = NaN;
  }
  point(x2, y3) {
    switch (this._point) {
      case 0: {
        this._append`M${x2},${y3}`;
        this._point = 1;
        break;
      }
      case 1: {
        this._append`L${x2},${y3}`;
        break;
      }
      default: {
        this._append`M${x2},${y3}`;
        if (this._radius !== cacheRadius || this._append !== cacheAppend) {
          const r2 = this._radius;
          const s3 = this._;
          this._ = "";
          this._append`m0,${r2}a${r2},${r2} 0 1,1 0,${-2 * r2}a${r2},${r2} 0 1,1 0,${2 * r2}z`;
          cacheRadius = r2;
          cacheAppend = this._append;
          cacheCircle = this._;
          this._ = s3;
        }
        this._ += cacheCircle;
        break;
      }
    }
  }
  result() {
    const result = this._;
    this._ = "";
    return result.length ? result : null;
  }
};
function append2(strings) {
  let i2 = 1;
  this._ += strings[0];
  for (const j = strings.length; i2 < j; ++i2) {
    this._ += arguments[i2] + strings[i2];
  }
}
function appendRound2(digits) {
  const d3 = Math.floor(digits);
  if (!(d3 >= 0)) throw new RangeError(`invalid digits: ${digits}`);
  if (d3 > 15) return append2;
  if (d3 !== cacheDigits) {
    const k2 = __pow(10, d3);
    cacheDigits = d3;
    cacheAppend = function append3(strings) {
      let i2 = 1;
      this._ += strings[0];
      for (const j = strings.length; i2 < j; ++i2) {
        this._ += Math.round(arguments[i2] * k2) / k2 + strings[i2];
      }
    };
  }
  return cacheAppend;
}

// node_modules/d3-geo/src/path/index.js
function path_default2(projection2, context) {
  let digits = 3, pointRadius = 4.5, projectionStream, contextStream;
  function path2(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      stream_default(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path2.area = function(object) {
    stream_default(object, projectionStream(area_default2));
    return area_default2.result();
  };
  path2.measure = function(object) {
    stream_default(object, projectionStream(measure_default));
    return measure_default.result();
  };
  path2.bounds = function(object) {
    stream_default(object, projectionStream(bounds_default));
    return bounds_default.result();
  };
  path2.centroid = function(object) {
    stream_default(object, projectionStream(centroid_default));
    return centroid_default.result();
  };
  path2.projection = function(_) {
    if (!arguments.length) return projection2;
    projectionStream = _ == null ? (projection2 = null, identity_default6) : (projection2 = _).stream;
    return path2;
  };
  path2.context = function(_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new PathString(digits)) : new PathContext(context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path2;
  };
  path2.pointRadius = function(_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path2;
  };
  path2.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null) digits = null;
    else {
      const d3 = Math.floor(_);
      if (!(d3 >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d3;
    }
    if (context === null) contextStream = new PathString(digits);
    return path2;
  };
  return path2.projection(projection2).digits(digits).context(context);
}

// node_modules/d3-geo/src/transform.js
function transformer(methods) {
  return function(stream) {
    var s3 = new TransformStream();
    for (var key in methods) s3[key] = methods[key];
    s3.stream = stream;
    return s3;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x2, y3) {
    this.stream.point(x2, y3);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};

// node_modules/d3-geo/src/projection/fit.js
function fit(projection2, fitBounds, object) {
  var clip = projection2.clipExtent && projection2.clipExtent();
  projection2.scale(150).translate([0, 0]);
  if (clip != null) projection2.clipExtent(null);
  stream_default(object, projection2.stream(bounds_default));
  fitBounds(bounds_default.result());
  if (clip != null) projection2.clipExtent(clip);
  return projection2;
}
function fitExtent(projection2, extent2, object) {
  return fit(projection2, function(b) {
    var w2 = extent2[1][0] - extent2[0][0], h2 = extent2[1][1] - extent2[0][1], k2 = Math.min(w2 / (b[1][0] - b[0][0]), h2 / (b[1][1] - b[0][1])), x2 = +extent2[0][0] + (w2 - k2 * (b[1][0] + b[0][0])) / 2, y3 = +extent2[0][1] + (h2 - k2 * (b[1][1] + b[0][1])) / 2;
    projection2.scale(150 * k2).translate([x2, y3]);
  }, object);
}
function fitSize(projection2, size4, object) {
  return fitExtent(projection2, [[0, 0], size4], object);
}
function fitWidth(projection2, width, object) {
  return fit(projection2, function(b) {
    var w2 = +width, k2 = w2 / (b[1][0] - b[0][0]), x2 = (w2 - k2 * (b[1][0] + b[0][0])) / 2, y3 = -k2 * b[0][1];
    projection2.scale(150 * k2).translate([x2, y3]);
  }, object);
}
function fitHeight(projection2, height, object) {
  return fit(projection2, function(b) {
    var h2 = +height, k2 = h2 / (b[1][1] - b[0][1]), x2 = -k2 * b[0][0], y3 = (h2 - k2 * (b[1][1] + b[0][1])) / 2;
    projection2.scale(150 * k2).translate([x2, y3]);
  }, object);
}

// node_modules/d3-geo/src/projection/resample.js
var maxDepth = 16;
var cosMinDistance = cos2(30 * radians);
function resample_default(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}
function resampleNone(project) {
  return transformer({
    point: function(x2, y3) {
      x2 = project(x2, y3);
      this.stream.point(x2[0], x2[1]);
    }
  });
}
function resample(project, delta2) {
  function resampleLineTo(x05, y05, lambda0, a0, b0, c0, x12, y12, lambda1, a1, b1, c1, depth, stream) {
    var dx = x12 - x05, dy = y12 - y05, d22 = dx * dx + dy * dy;
    if (d22 > 4 * delta2 && depth--) {
      var a4 = a0 + a1, b = b0 + b1, c5 = c0 + c1, m2 = sqrt2(a4 * a4 + b * b + c5 * c5), phi2 = asin2(c5 /= m2), lambda2 = abs2(abs2(c5) - 1) < epsilon3 || abs2(lambda0 - lambda1) < epsilon3 ? (lambda0 + lambda1) / 2 : atan22(b, a4), p3 = project(lambda2, phi2), x2 = p3[0], y22 = p3[1], dx2 = x2 - x05, dy2 = y22 - y05, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d22 > delta2 || abs2((dx * dx2 + dy * dy2) / d22 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x05, y05, lambda0, a0, b0, c0, x2, y22, lambda2, a4 /= m2, b /= m2, c5, depth, stream);
        stream.point(x2, y22);
        resampleLineTo(x2, y22, lambda2, a4, b, c5, x12, y12, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x004, y004, a00, b00, c00, lambda0, x05, y05, a0, b0, c0;
    var resampleStream = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point6(x2, y3) {
      x2 = project(x2, y3);
      stream.point(x2[0], x2[1]);
    }
    function lineStart() {
      x05 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }
    function linePoint(lambda, phi2) {
      var c5 = cartesian2([lambda, phi2]), p3 = project(lambda, phi2);
      resampleLineTo(x05, y05, lambda0, a0, b0, c0, x05 = p3[0], y05 = p3[1], lambda0 = lambda, a0 = c5[0], b0 = c5[1], c0 = c5[2], maxDepth, stream);
      stream.point(x05, y05);
    }
    function lineEnd() {
      resampleStream.point = point6;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi2) {
      linePoint(lambda00 = lambda, phi2), x004 = x05, y004 = y05, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }
    function ringEnd() {
      resampleLineTo(x05, y05, lambda0, a0, b0, c0, x004, y004, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}

// node_modules/d3-geo/src/projection/index.js
var transformRadians = transformer({
  point: function(x2, y3) {
    this.stream.point(x2 * radians, y3 * radians);
  }
});
function transformRotate(rotate2) {
  return transformer({
    point: function(x2, y3) {
      var r2 = rotate2(x2, y3);
      return this.stream.point(r2[0], r2[1]);
    }
  });
}
function scaleTranslate(k2, dx, dy, sx, sy) {
  function transform2(x2, y3) {
    x2 *= sx;
    y3 *= sy;
    return [dx + k2 * x2, dy - k2 * y3];
  }
  transform2.invert = function(x2, y3) {
    return [(x2 - dx) / k2 * sx, (dy - y3) / k2 * sy];
  };
  return transform2;
}
function scaleTranslateRotate(k2, dx, dy, sx, sy, alpha) {
  if (!alpha) return scaleTranslate(k2, dx, dy, sx, sy);
  var cosAlpha = cos2(alpha), sinAlpha = sin2(alpha), a4 = cosAlpha * k2, b = sinAlpha * k2, ai = cosAlpha / k2, bi = sinAlpha / k2, ci = (sinAlpha * dy - cosAlpha * dx) / k2, fi = (sinAlpha * dx + cosAlpha * dy) / k2;
  function transform2(x2, y3) {
    x2 *= sx;
    y3 *= sy;
    return [a4 * x2 - b * y3 + dx, dy - b * x2 - a4 * y3];
  }
  transform2.invert = function(x2, y3) {
    return [sx * (ai * x2 - bi * y3 + ci), sy * (fi - bi * x2 - ai * y3)];
  };
  return transform2;
}
function projection(project) {
  return projectionMutator(function() {
    return project;
  })();
}
function projectionMutator(projectAt) {
  var project, k2 = 150, x2 = 480, y3 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate2, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x05 = null, y05, x12, y12, postclip = identity_default6, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache2, cacheStream;
  function projection2(point6) {
    return projectRotateTransform(point6[0] * radians, point6[1] * radians);
  }
  function invert2(point6) {
    point6 = projectRotateTransform.invert(point6[0], point6[1]);
    return point6 && [point6[0] * degrees, point6[1] * degrees];
  }
  projection2.stream = function(stream) {
    return cache2 && cacheStream === stream ? cache2 : cache2 = transformRadians(transformRotate(rotate2)(preclip(projectResample(postclip(cacheStream = stream)))));
  };
  projection2.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = void 0, reset()) : preclip;
  };
  projection2.postclip = function(_) {
    return arguments.length ? (postclip = _, x05 = y05 = x12 = y12 = null, reset()) : postclip;
  };
  projection2.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? circle_default2(theta = _ * radians) : (theta = null, antimeridian_default), reset()) : theta * degrees;
  };
  projection2.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x05 = y05 = x12 = y12 = null, identity_default6) : clipRectangle(x05 = +_[0][0], y05 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x05 == null ? null : [[x05, y05], [x12, y12]];
  };
  projection2.scale = function(_) {
    return arguments.length ? (k2 = +_, recenter()) : k2;
  };
  projection2.translate = function(_) {
    return arguments.length ? (x2 = +_[0], y3 = +_[1], recenter()) : [x2, y3];
  };
  projection2.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * radians, phi2 = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi2 * degrees];
  };
  projection2.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
  };
  projection2.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
  };
  projection2.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
  };
  projection2.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
  };
  projection2.precision = function(_) {
    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _ * _), reset()) : sqrt2(delta2);
  };
  projection2.fitExtent = function(extent2, object) {
    return fitExtent(projection2, extent2, object);
  };
  projection2.fitSize = function(size4, object) {
    return fitSize(projection2, size4, object);
  };
  projection2.fitWidth = function(width, object) {
    return fitWidth(projection2, width, object);
  };
  projection2.fitHeight = function(height, object) {
    return fitHeight(projection2, height, object);
  };
  function recenter() {
    var center2 = scaleTranslateRotate(k2, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi2)), transform2 = scaleTranslateRotate(k2, x2 - center2[0], y3 - center2[1], sx, sy, alpha);
    rotate2 = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose_default(project, transform2);
    projectRotateTransform = compose_default(rotate2, projectTransform);
    projectResample = resample_default(projectTransform, delta2);
    return reset();
  }
  function reset() {
    cache2 = cacheStream = null;
    return projection2;
  }
  return function() {
    project = projectAt.apply(this, arguments);
    projection2.invert = project.invert && invert2;
    return recenter();
  };
}

// node_modules/d3-geo/src/projection/conic.js
function conicProjection(projectAt) {
  var phi0 = 0, phi1 = pi3 / 3, m2 = projectionMutator(projectAt), p3 = m2(phi0, phi1);
  p3.parallels = function(_) {
    return arguments.length ? m2(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];
  };
  return p3;
}

// node_modules/d3-geo/src/projection/cylindricalEqualArea.js
function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = cos2(phi0);
  function forward(lambda, phi2) {
    return [lambda * cosPhi0, sin2(phi2) / cosPhi0];
  }
  forward.invert = function(x2, y3) {
    return [x2 / cosPhi0, asin2(y3 * cosPhi0)];
  };
  return forward;
}

// node_modules/d3-geo/src/projection/conicEqualArea.js
function conicEqualAreaRaw(y05, y12) {
  var sy0 = sin2(y05), n2 = (sy0 + sin2(y12)) / 2;
  if (abs2(n2) < epsilon3) return cylindricalEqualAreaRaw(y05);
  var c5 = 1 + sy0 * (2 * n2 - sy0), r0 = sqrt2(c5) / n2;
  function project(x2, y3) {
    var r2 = sqrt2(c5 - 2 * n2 * sin2(y3)) / n2;
    return [r2 * sin2(x2 *= n2), r0 - r2 * cos2(x2)];
  }
  project.invert = function(x2, y3) {
    var r0y = r0 - y3, l2 = atan22(x2, abs2(r0y)) * sign2(r0y);
    if (r0y * n2 < 0)
      l2 -= pi3 * sign2(x2) * sign2(r0y);
    return [l2 / n2, asin2((c5 - (x2 * x2 + r0y * r0y) * n2 * n2) / (2 * n2))];
  };
  return project;
}
function conicEqualArea_default() {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}

// node_modules/d3-geo/src/projection/albers.js
function albers_default() {
  return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}

// node_modules/d3-geo/src/projection/albersUsa.js
function multiplex(streams) {
  var n2 = streams.length;
  return {
    point: function(x2, y3) {
      var i2 = -1;
      while (++i2 < n2) streams[i2].point(x2, y3);
    },
    sphere: function() {
      var i2 = -1;
      while (++i2 < n2) streams[i2].sphere();
    },
    lineStart: function() {
      var i2 = -1;
      while (++i2 < n2) streams[i2].lineStart();
    },
    lineEnd: function() {
      var i2 = -1;
      while (++i2 < n2) streams[i2].lineEnd();
    },
    polygonStart: function() {
      var i2 = -1;
      while (++i2 < n2) streams[i2].polygonStart();
    },
    polygonEnd: function() {
      var i2 = -1;
      while (++i2 < n2) streams[i2].polygonEnd();
    }
  };
}
function albersUsa_default() {
  var cache2, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point6, pointStream = { point: function(x2, y3) {
    point6 = [x2, y3];
  } };
  function albersUsa(coordinates) {
    var x2 = coordinates[0], y3 = coordinates[1];
    return point6 = null, (lower48Point.point(x2, y3), point6) || (alaskaPoint.point(x2, y3), point6) || (hawaiiPoint.point(x2, y3), point6);
  }
  albersUsa.invert = function(coordinates) {
    var k2 = lower48.scale(), t = lower48.translate(), x2 = (coordinates[0] - t[0]) / k2, y3 = (coordinates[1] - t[1]) / k2;
    return (y3 >= 0.12 && y3 < 0.234 && x2 >= -0.425 && x2 < -0.214 ? alaska : y3 >= 0.166 && y3 < 0.234 && x2 >= -0.214 && x2 < -0.115 ? hawaii : lower48).invert(coordinates);
  };
  albersUsa.stream = function(stream) {
    return cache2 && cacheStream === stream ? cache2 : cache2 = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };
  albersUsa.precision = function(_) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset();
  };
  albersUsa.scale = function(_) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };
  albersUsa.translate = function(_) {
    if (!arguments.length) return lower48.translate();
    var k2 = lower48.scale(), x2 = +_[0], y3 = +_[1];
    lower48Point = lower48.translate(_).clipExtent([[x2 - 0.455 * k2, y3 - 0.238 * k2], [x2 + 0.455 * k2, y3 + 0.238 * k2]]).stream(pointStream);
    alaskaPoint = alaska.translate([x2 - 0.307 * k2, y3 + 0.201 * k2]).clipExtent([[x2 - 0.425 * k2 + epsilon3, y3 + 0.12 * k2 + epsilon3], [x2 - 0.214 * k2 - epsilon3, y3 + 0.234 * k2 - epsilon3]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x2 - 0.205 * k2, y3 + 0.212 * k2]).clipExtent([[x2 - 0.214 * k2 + epsilon3, y3 + 0.166 * k2 + epsilon3], [x2 - 0.115 * k2 - epsilon3, y3 + 0.234 * k2 - epsilon3]]).stream(pointStream);
    return reset();
  };
  albersUsa.fitExtent = function(extent2, object) {
    return fitExtent(albersUsa, extent2, object);
  };
  albersUsa.fitSize = function(size4, object) {
    return fitSize(albersUsa, size4, object);
  };
  albersUsa.fitWidth = function(width, object) {
    return fitWidth(albersUsa, width, object);
  };
  albersUsa.fitHeight = function(height, object) {
    return fitHeight(albersUsa, height, object);
  };
  function reset() {
    cache2 = cacheStream = null;
    return albersUsa;
  }
  return albersUsa.scale(1070);
}

// node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale4) {
  return function(x2, y3) {
    var cx = cos2(x2), cy = cos2(y3), k2 = scale4(cx * cy);
    if (k2 === Infinity) return [2, 0];
    return [
      k2 * cy * sin2(x2),
      k2 * sin2(y3)
    ];
  };
}
function azimuthalInvert(angle2) {
  return function(x2, y3) {
    var z = sqrt2(x2 * x2 + y3 * y3), c5 = angle2(z), sc = sin2(c5), cc = cos2(c5);
    return [
      atan22(x2 * sc, z * cc),
      asin2(z && y3 * sc / z)
    ];
  };
}

// node_modules/d3-geo/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt2(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin2(z / 2);
});
function azimuthalEqualArea_default() {
  return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw = azimuthalRaw(function(c5) {
  return (c5 = acos2(c5)) && c5 / sin2(c5);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});
function azimuthalEquidistant_default() {
  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi2) {
  return [lambda, log(tan((halfPi2 + phi2) / 2))];
}
mercatorRaw.invert = function(x2, y3) {
  return [x2, 2 * atan(exp(y3)) - halfPi2];
};
function mercator_default() {
  return mercatorProjection(mercatorRaw).scale(961 / tau3);
}
function mercatorProjection(project) {
  var m2 = projection(project), center2 = m2.center, scale4 = m2.scale, translate2 = m2.translate, clipExtent = m2.clipExtent, x05 = null, y05, x12, y12;
  m2.scale = function(_) {
    return arguments.length ? (scale4(_), reclip()) : scale4();
  };
  m2.translate = function(_) {
    return arguments.length ? (translate2(_), reclip()) : translate2();
  };
  m2.center = function(_) {
    return arguments.length ? (center2(_), reclip()) : center2();
  };
  m2.clipExtent = function(_) {
    return arguments.length ? (_ == null ? x05 = y05 = x12 = y12 = null : (x05 = +_[0][0], y05 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reclip()) : x05 == null ? null : [[x05, y05], [x12, y12]];
  };
  function reclip() {
    var k2 = pi3 * scale4(), t = m2(rotation_default(m2.rotate()).invert([0, 0]));
    return clipExtent(x05 == null ? [[t[0] - k2, t[1] - k2], [t[0] + k2, t[1] + k2]] : project === mercatorRaw ? [[Math.max(t[0] - k2, x05), y05], [Math.min(t[0] + k2, x12), y12]] : [[x05, Math.max(t[1] - k2, y05)], [x12, Math.min(t[1] + k2, y12)]]);
  }
  return reclip();
}

// node_modules/d3-geo/src/projection/conicConformal.js
function tany(y3) {
  return tan((halfPi2 + y3) / 2);
}
function conicConformalRaw(y05, y12) {
  var cy0 = cos2(y05), n2 = y05 === y12 ? sin2(y05) : log(cy0 / cos2(y12)) / log(tany(y12) / tany(y05)), f2 = cy0 * pow(tany(y05), n2) / n2;
  if (!n2) return mercatorRaw;
  function project(x2, y3) {
    if (f2 > 0) {
      if (y3 < -halfPi2 + epsilon3) y3 = -halfPi2 + epsilon3;
    } else {
      if (y3 > halfPi2 - epsilon3) y3 = halfPi2 - epsilon3;
    }
    var r2 = f2 / pow(tany(y3), n2);
    return [r2 * sin2(n2 * x2), f2 - r2 * cos2(n2 * x2)];
  }
  project.invert = function(x2, y3) {
    var fy = f2 - y3, r2 = sign2(n2) * sqrt2(x2 * x2 + fy * fy), l2 = atan22(x2, abs2(fy)) * sign2(fy);
    if (fy * n2 < 0)
      l2 -= pi3 * sign2(x2) * sign2(fy);
    return [l2 / n2, 2 * atan(pow(f2 / r2, 1 / n2)) - halfPi2];
  };
  return project;
}
function conicConformal_default() {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}

// node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi2) {
  return [lambda, phi2];
}
equirectangularRaw.invert = equirectangularRaw;
function equirectangular_default() {
  return projection(equirectangularRaw).scale(152.63);
}

// node_modules/d3-geo/src/projection/conicEquidistant.js
function conicEquidistantRaw(y05, y12) {
  var cy0 = cos2(y05), n2 = y05 === y12 ? sin2(y05) : (cy0 - cos2(y12)) / (y12 - y05), g = cy0 / n2 + y05;
  if (abs2(n2) < epsilon3) return equirectangularRaw;
  function project(x2, y3) {
    var gy = g - y3, nx = n2 * x2;
    return [gy * sin2(nx), g - gy * cos2(nx)];
  }
  project.invert = function(x2, y3) {
    var gy = g - y3, l2 = atan22(x2, abs2(gy)) * sign2(gy);
    if (gy * n2 < 0)
      l2 -= pi3 * sign2(x2) * sign2(gy);
    return [l2 / n2, g - sign2(n2) * sqrt2(x2 * x2 + gy * gy)];
  };
  return project;
}
function conicEquidistant_default() {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}

// node_modules/d3-geo/src/projection/equalEarth.js
var A1 = 1.340264;
var A2 = -0.081106;
var A3 = 893e-6;
var A4 = 3796e-6;
var M = sqrt2(3) / 2;
var iterations = 12;
function equalEarthRaw(lambda, phi2) {
  var l2 = asin2(M * sin2(phi2)), l22 = l2 * l2, l6 = l22 * l22 * l22;
  return [
    lambda * cos2(l2) / (M * (A1 + 3 * A2 * l22 + l6 * (7 * A3 + 9 * A4 * l22))),
    l2 * (A1 + A2 * l22 + l6 * (A3 + A4 * l22))
  ];
}
equalEarthRaw.invert = function(x2, y3) {
  var l2 = y3, l22 = l2 * l2, l6 = l22 * l22 * l22;
  for (var i2 = 0, delta, fy, fpy; i2 < iterations; ++i2) {
    fy = l2 * (A1 + A2 * l22 + l6 * (A3 + A4 * l22)) - y3;
    fpy = A1 + 3 * A2 * l22 + l6 * (7 * A3 + 9 * A4 * l22);
    l2 -= delta = fy / fpy, l22 = l2 * l2, l6 = l22 * l22 * l22;
    if (abs2(delta) < epsilon22) break;
  }
  return [
    M * x2 * (A1 + 3 * A2 * l22 + l6 * (7 * A3 + 9 * A4 * l22)) / cos2(l2),
    asin2(sin2(l2) / M)
  ];
};
function equalEarth_default() {
  return projection(equalEarthRaw).scale(177.158);
}

// node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x2, y3) {
  var cy = cos2(y3), k2 = cos2(x2) * cy;
  return [cy * sin2(x2) / k2, sin2(y3) / k2];
}
gnomonicRaw.invert = azimuthalInvert(atan);
function gnomonic_default() {
  return projection(gnomonicRaw).scale(144.049).clipAngle(60);
}

// node_modules/d3-geo/src/projection/identity.js
function identity_default7() {
  var k2 = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca, sa, x05 = null, y05, x12, y12, kx2 = 1, ky2 = 1, transform2 = transformer({
    point: function(x2, y3) {
      var p3 = projection2([x2, y3]);
      this.stream.point(p3[0], p3[1]);
    }
  }), postclip = identity_default6, cache2, cacheStream;
  function reset() {
    kx2 = k2 * sx;
    ky2 = k2 * sy;
    cache2 = cacheStream = null;
    return projection2;
  }
  function projection2(p3) {
    var x2 = p3[0] * kx2, y3 = p3[1] * ky2;
    if (alpha) {
      var t = y3 * ca - x2 * sa;
      x2 = x2 * ca + y3 * sa;
      y3 = t;
    }
    return [x2 + tx, y3 + ty];
  }
  projection2.invert = function(p3) {
    var x2 = p3[0] - tx, y3 = p3[1] - ty;
    if (alpha) {
      var t = y3 * ca + x2 * sa;
      x2 = x2 * ca - y3 * sa;
      y3 = t;
    }
    return [x2 / kx2, y3 / ky2];
  };
  projection2.stream = function(stream) {
    return cache2 && cacheStream === stream ? cache2 : cache2 = transform2(postclip(cacheStream = stream));
  };
  projection2.postclip = function(_) {
    return arguments.length ? (postclip = _, x05 = y05 = x12 = y12 = null, reset()) : postclip;
  };
  projection2.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x05 = y05 = x12 = y12 = null, identity_default6) : clipRectangle(x05 = +_[0][0], y05 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x05 == null ? null : [[x05, y05], [x12, y12]];
  };
  projection2.scale = function(_) {
    return arguments.length ? (k2 = +_, reset()) : k2;
  };
  projection2.translate = function(_) {
    return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
  };
  projection2.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * radians, sa = sin2(alpha), ca = cos2(alpha), reset()) : alpha * degrees;
  };
  projection2.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
  };
  projection2.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
  };
  projection2.fitExtent = function(extent2, object) {
    return fitExtent(projection2, extent2, object);
  };
  projection2.fitSize = function(size4, object) {
    return fitSize(projection2, size4, object);
  };
  projection2.fitWidth = function(width, object) {
    return fitWidth(projection2, width, object);
  };
  projection2.fitHeight = function(height, object) {
    return fitHeight(projection2, height, object);
  };
  return projection2;
}

// node_modules/d3-geo/src/projection/naturalEarth1.js
function naturalEarth1Raw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
  return [
    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
  ];
}
naturalEarth1Raw.invert = function(x2, y3) {
  var phi2 = y3, i2 = 25, delta;
  do {
    var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
    phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y3) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
  } while (abs2(delta) > epsilon3 && --i2 > 0);
  return [
    x2 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
    phi2
  ];
};
function naturalEarth1_default() {
  return projection(naturalEarth1Raw).scale(175.295);
}

// node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x2, y3) {
  return [cos2(y3) * sin2(x2), sin2(y3)];
}
orthographicRaw.invert = azimuthalInvert(asin2);
function orthographic_default() {
  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon3);
}

// node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x2, y3) {
  var cy = cos2(y3), k2 = 1 + cos2(x2) * cy;
  return [cy * sin2(x2) / k2, sin2(y3) / k2];
}
stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});
function stereographic_default() {
  return projection(stereographicRaw).scale(250).clipAngle(142);
}

// node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi2) {
  return [log(tan((halfPi2 + phi2) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x2, y3) {
  return [-y3, 2 * atan(exp(x2)) - halfPi2];
};
function transverseMercator_default() {
  var m2 = mercatorProjection(transverseMercatorRaw), center2 = m2.center, rotate2 = m2.rotate;
  m2.center = function(_) {
    return arguments.length ? center2([-_[1], _[0]]) : (_ = center2(), [_[1], -_[0]]);
  };
  m2.rotate = function(_) {
    return arguments.length ? rotate2([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate2(), [_[0], _[1], _[2] - 90]);
  };
  return rotate2([0, 0, 90]).scale(159.155);
}

// node_modules/@antv/g2/esm/composition/d3Projection.js
var d3Projection_exports = {};
__export(d3Projection_exports, {
  geoAlbers: () => albers_default,
  geoAlbersUsa: () => albersUsa_default,
  geoAzimuthalEqualArea: () => azimuthalEqualArea_default,
  geoAzimuthalEqualAreaRaw: () => azimuthalEqualAreaRaw,
  geoAzimuthalEquidistant: () => azimuthalEquidistant_default,
  geoAzimuthalEquidistantRaw: () => azimuthalEquidistantRaw,
  geoConicConformal: () => conicConformal_default,
  geoConicConformalRaw: () => conicConformalRaw,
  geoConicEqualArea: () => conicEqualArea_default,
  geoConicEqualAreaRaw: () => conicEqualAreaRaw,
  geoConicEquidistant: () => conicEquidistant_default,
  geoConicEquidistantRaw: () => conicEquidistantRaw,
  geoEqualEarth: () => equalEarth_default,
  geoEqualEarthRaw: () => equalEarthRaw,
  geoEquirectangular: () => equirectangular_default,
  geoEquirectangularRaw: () => equirectangularRaw,
  geoGnomonic: () => gnomonic_default,
  geoGnomonicRaw: () => gnomonicRaw,
  geoIdentity: () => identity_default7,
  geoMercator: () => mercator_default,
  geoMercatorRaw: () => mercatorRaw,
  geoNaturalEarth1: () => naturalEarth1_default,
  geoNaturalEarth1Raw: () => naturalEarth1Raw,
  geoOrthographic: () => orthographic_default,
  geoOrthographicRaw: () => orthographicRaw,
  geoProjection: () => projection,
  geoProjectionMutator: () => projectionMutator,
  geoStereographic: () => stereographic_default,
  geoStereographicRaw: () => stereographicRaw,
  geoTransverseMercator: () => transverseMercator_default,
  geoTransverseMercatorRaw: () => transverseMercatorRaw
});

// node_modules/@antv/g2/esm/composition/geoView.js
var __rest65 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function normalizeProjection(type) {
  if (typeof type === "function")
    return type;
  const name2 = `geo${upper_first_default(type)}`;
  const projection2 = d3Projection_exports[name2];
  if (!projection2)
    throw new Error(`Unknown coordinate: ${type}`);
  return projection2;
}
function mergeGeoJSON(gjs) {
  return {
    type: "FeatureCollection",
    features: gjs.flatMap((gj) => normalizeGeoJSON(gj).features)
  };
}
function normalizeGeoJSON(gj) {
  const types = {
    Point: "geometry",
    MultiPoint: "geometry",
    LineString: "geometry",
    MultiLineString: "geometry",
    Polygon: "geometry",
    MultiPolygon: "geometry",
    GeometryCollection: "geometry",
    Feature: "feature",
    FeatureCollection: "featureCollection"
  };
  if (!gj || !gj.type)
    return null;
  const type = types[gj.type];
  if (!type)
    return null;
  if (type === "geometry") {
    return {
      type: "FeatureCollection",
      features: [
        {
          type: "Feature",
          properties: {},
          geometry: gj
        }
      ]
    };
  } else if (type === "feature") {
    return {
      type: "FeatureCollection",
      features: [gj]
    };
  } else if (type === "featureCollection") {
    return gj;
  }
}
function setProjectionOptions(projection2, options) {
  var _a;
  for (const [key, value2] of Object.entries(options)) {
    (_a = projection2[key]) === null || _a === void 0 ? void 0 : _a.call(projection2, value2);
  }
}
function setProjectionSize(projection2, nodes, layout, options) {
  const defaultOutline = () => {
    const geoNodes = nodes.filter(isGeoPath);
    const sphere = geoNodes.find((d3) => d3.sphere);
    if (sphere)
      return { type: "Sphere" };
    return mergeGeoJSON(geoNodes.filter((d3) => !d3.sphere).flatMap((d3) => d3.data.value));
  };
  const { outline = defaultOutline() } = options;
  const { size: size4 = "fitExtent" } = options;
  if (size4 === "fitExtent") {
    return setFitExtent(projection2, outline, layout);
  } else if (size4 === "fitWidth") {
    return setFitWidth(projection2, outline, layout);
  }
}
function setFitExtent(projection2, object, layout) {
  const { x: x2, y: y3, width, height } = layout;
  projection2.fitExtent([
    [x2, y3],
    [width, height]
  ], object);
}
function setFitWidth(projection2, object, layout) {
  const { width, height } = layout;
  const [[x05, y05], [x12, y12]] = path_default2(projection2.fitWidth(width, object)).bounds(object);
  const dy = Math.ceil(y12 - y05);
  const l2 = Math.min(Math.ceil(x12 - x05), dy);
  const s3 = projection2.scale() * (l2 - 1) / l2;
  const [tx, ty] = projection2.translate();
  const t = ty + (height - dy) / 2;
  projection2.scale(s3).translate([tx, t]).precision(0.2);
}
function normalizeDataSource(node) {
  const { data } = node;
  if (Array.isArray(data))
    return Object.assign(Object.assign({}, node), { data: { value: data } });
  const { type } = data;
  if (type === "graticule10") {
    return Object.assign(Object.assign({}, node), { data: { value: [graticule10()] } });
  } else if (type === "sphere") {
    return Object.assign(Object.assign({}, node), { sphere: true, data: { value: [{ type: "Sphere" }] } });
  }
  return node;
}
function isGeoPath(d3) {
  return d3.type === "geoPath";
}
var GeoView = () => {
  return (options) => {
    const { children, coordinate: projection2 = {} } = options;
    if (!Array.isArray(children))
      return [];
    const { type = "equalEarth" } = projection2, projectionOptions = __rest65(projection2, ["type"]);
    const createProjection = normalizeProjection(type);
    const nodes = children.map((c5) => {
      return Object.assign(Object.assign({}, c5), { data: mergeData(c5.data, options.data) });
    }).map(normalizeDataSource);
    let path2;
    function Geo() {
      return [
        [
          "custom",
          (x2, y3, width, height) => {
            const visual = createProjection();
            const layout = { x: x2, y: y3, width, height };
            setProjectionSize(visual, nodes, layout, projectionOptions);
            setProjectionOptions(visual, projectionOptions);
            path2 = path_default2(visual);
            const scaleX = new Linear({
              domain: [x2, x2 + width]
            });
            const scaleY = new Linear({
              domain: [y3, y3 + height]
            });
            const normalize5 = (point6) => {
              const visualPoint = visual(point6);
              if (!visualPoint)
                return [null, null];
              const [vx, vy] = visualPoint;
              return [scaleX.map(vx), scaleY.map(vy)];
            };
            const normalizeInvert = (point6) => {
              if (!point6)
                return null;
              const [px, py] = point6;
              const visualPoint = [scaleX.invert(px), scaleY.invert(py)];
              return visual.invert(visualPoint);
            };
            return {
              transform: (point6) => normalize5(point6),
              untransform: (point6) => normalizeInvert(point6)
            };
          }
        ]
      ];
    }
    function GeoPath2(options2) {
      const { style, tooltip: tooltip2 = {} } = options2;
      return Object.assign(Object.assign({}, options2), { type: "path", tooltip: maybeTooltip(tooltip2, {
        title: "id",
        items: [{ channel: "color" }]
      }), style: Object.assign(Object.assign({}, style), { d: (d3) => path2(d3) || [] }) });
    }
    const t = (d3) => isGeoPath(d3) ? GeoPath2(d3) : d3;
    return [
      Object.assign(Object.assign({}, options), { type: "view", scale: {
        x: { type: "identity" },
        y: { type: "identity" }
      }, axis: false, coordinate: { type: Geo }, children: nodes.flatMap(t) })
    ];
  };
};
GeoView.props = {};

// node_modules/@antv/g2/esm/interaction/event.js
function maybeComponentRoot(node) {
  return maybeRoot(node, (node2) => node2.className === "component");
}
function maybeElementRoot(node) {
  return maybeRoot(node, (node2) => node2.className === "element");
}
function maybeLabelRoot(node) {
  return maybeRoot(node, (node2) => node2.className === "label");
}
function bubblesEvent(eventType, view, emitter, predicate = (event) => true) {
  return (e3) => {
    if (!predicate(e3))
      return;
    emitter.emit(`plot:${eventType}`, e3);
    const { target } = e3;
    if (!target)
      return;
    const { className: className2 } = target;
    if (className2 === "plot")
      return;
    const elementRoot = maybeElementRoot(target);
    const componentRoot = maybeComponentRoot(target);
    const babelRoot = maybeLabelRoot(target);
    const root = elementRoot || componentRoot || babelRoot;
    if (!root)
      return;
    const { className: elementType, markType } = root;
    const e1 = Object.assign(Object.assign({}, e3), { nativeEvent: true });
    if (elementType === "element") {
      e1["data"] = { data: dataOf(root, view) };
      emitter.emit(`element:${eventType}`, e1);
      emitter.emit(`${markType}:${eventType}`, e1);
    } else if (elementType === "label") {
      e1["data"] = { data: root.attributes.datum };
      emitter.emit(`label:${eventType}`, e1);
      const classNames = className2.split(/\s+/).filter(Boolean);
      classNames.forEach((cls) => {
        emitter.emit(`${cls}:${eventType}`, e1);
      });
    } else {
      emitter.emit(`component:${eventType}`, e1);
      const classNames = className2.split(/\s+/).filter(Boolean);
      classNames.forEach((cls) => {
        emitter.emit(`${cls}:${eventType}`, e1);
      });
    }
  };
}
function Event() {
  return (context, _, emitter) => {
    const { container, view } = context;
    const click = bubblesEvent(ChartEvent.CLICK, view, emitter, (e3) => e3.detail === 1);
    const dblclick2 = bubblesEvent(ChartEvent.DBLCLICK, view, emitter, (e3) => e3.detail === 2);
    const pointertap = bubblesEvent(ChartEvent.POINTER_TAP, view, emitter);
    const pointerdown = bubblesEvent(ChartEvent.POINTER_DOWN, view, emitter);
    const pointerup = bubblesEvent(ChartEvent.POINTER_UP, view, emitter);
    const pointerover = bubblesEvent(ChartEvent.POINTER_OVER, view, emitter);
    const pointerout = bubblesEvent(ChartEvent.POINTER_OUT, view, emitter);
    const pointermove = bubblesEvent(ChartEvent.POINTER_MOVE, view, emitter);
    const pointerenter = bubblesEvent(ChartEvent.POINTER_ENTER, view, emitter);
    const pointerleave = bubblesEvent(ChartEvent.POINTER_LEAVE, view, emitter);
    const pointerupoutside = bubblesEvent(ChartEvent.POINTER_UPOUTSIDE, view, emitter);
    const dragstart = bubblesEvent(ChartEvent.DRAG_START, view, emitter);
    const drag = bubblesEvent(ChartEvent.DRAG, view, emitter);
    const dragend = bubblesEvent(ChartEvent.DRAG_END, view, emitter);
    const dragenter = bubblesEvent(ChartEvent.DRAG_ENTER, view, emitter);
    const dragleave = bubblesEvent(ChartEvent.DRAG_LEAVE, view, emitter);
    const dragover = bubblesEvent(ChartEvent.DRAG_OVER, view, emitter);
    const drop = bubblesEvent(ChartEvent.DROP, view, emitter);
    container.addEventListener("click", click);
    container.addEventListener("click", dblclick2);
    container.addEventListener("pointertap", pointertap);
    container.addEventListener("pointerdown", pointerdown);
    container.addEventListener("pointerup", pointerup);
    container.addEventListener("pointerover", pointerover);
    container.addEventListener("pointerout", pointerout);
    container.addEventListener("pointermove", pointermove);
    container.addEventListener("pointerenter", pointerenter);
    container.addEventListener("pointerleave", pointerleave);
    container.addEventListener("pointerupoutside", pointerupoutside);
    container.addEventListener("dragstart", dragstart);
    container.addEventListener("drag", drag);
    container.addEventListener("dragend", dragend);
    container.addEventListener("dragenter", dragenter);
    container.addEventListener("dragleave", dragleave);
    container.addEventListener("dragover", dragover);
    container.addEventListener("drop", drop);
    return () => {
      container.removeEventListener("click", click);
      container.removeEventListener("click", dblclick2);
      container.removeEventListener("pointertap", pointertap);
      container.removeEventListener("pointerdown", pointerdown);
      container.removeEventListener("pointerup", pointerup);
      container.removeEventListener("pointerover", pointerover);
      container.removeEventListener("pointerout", pointerout);
      container.removeEventListener("pointermove", pointermove);
      container.removeEventListener("pointerenter", pointerenter);
      container.removeEventListener("pointerleave", pointerleave);
      container.removeEventListener("pointerupoutside", pointerupoutside);
      container.removeEventListener("dragstart", dragstart);
      container.removeEventListener("drag", drag);
      container.removeEventListener("dragend", dragend);
      container.removeEventListener("dragenter", dragenter);
      container.removeEventListener("dragleave", dragleave);
      container.removeEventListener("dragover", dragover);
      container.removeEventListener("drop", drop);
    };
  };
}
Event.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/lib/builtinlib.js
function builtinlib() {
  return {
    "component.axisRadar": AxisRadar,
    "component.axisLinear": LinearAxis,
    "component.axisArc": ArcAxis,
    "component.legendContinuousBlock": LegendContinuousBlock,
    "component.legendContinuousBlockSize": LegendContinuousBlockSize,
    "component.legendContinuousSize": LegendContinuousSize,
    "interaction.event": Event,
    "composition.mark": Mark,
    "composition.view": View,
    "shape.label.label": Label,
    "shape.break": AxisBreaks
  };
}

// node_modules/@antv/g2/esm/runtime/library.js
var __rest66 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function useLibrary(namespace, publicLibrary) {
  const library3 = Object.assign(Object.assign({}, builtinlib()), publicLibrary);
  const create2 = (type) => {
    if (typeof type !== "string")
      return type;
    const key = `${namespace}.${type}`;
    return library3[key] || error(`Unknown Component: ${key}`);
  };
  const use = (options, context) => {
    const { type } = options, rest = __rest66(options, ["type"]);
    if (!type)
      error(`Plot type is required!`);
    const currentLibrary = create2(type);
    return currentLibrary === null || currentLibrary === void 0 ? void 0 : currentLibrary(rest, context);
  };
  return [use, create2];
}
function documentOf(library3) {
  const { canvas, group: group2 } = library3;
  return (canvas === null || canvas === void 0 ? void 0 : canvas.document) || (group2 === null || group2 === void 0 ? void 0 : group2.ownerDocument) || error(`Cannot find library document`);
}

// node_modules/@antv/g2/esm/runtime/coordinate.js
var __rest67 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function createCoordinate(layout, partialOptions, library3) {
  const [useCoordinate] = useLibrary("coordinate", library3);
  const { innerHeight, innerWidth, insetLeft, insetTop, insetRight, insetBottom } = layout;
  const { coordinates: partialTransform = [] } = partialOptions;
  const transform2 = inferCoordinate(partialTransform);
  const isCartesian3D = transform2[0].type === "cartesian3D";
  const options = Object.assign(Object.assign({}, layout), { x: insetLeft, y: insetTop, width: innerWidth - insetLeft - insetRight, height: innerHeight - insetBottom - insetTop, transformations: transform2.flatMap(useCoordinate) });
  const coordinate = isCartesian3D ? (
    // @ts-ignore
    new Coordinate3D(options)
  ) : new Coordinate(options);
  return coordinate;
}
function coordinate2Transform(node, library3) {
  const { coordinate = {}, coordinates } = node, rest = __rest67(node, ["coordinate", "coordinates"]);
  if (coordinates)
    return node;
  const { type, transform: transform2 = [] } = coordinate, options = __rest67(coordinate, ["type", "transform"]);
  if (!type)
    return Object.assign(Object.assign({}, rest), { coordinates: transform2 });
  const [, createCoordinate2] = useLibrary("coordinate", library3);
  const { transform: isTransform = false } = createCoordinate2(type).props || {};
  if (isTransform) {
    throw new Error(`Unknown coordinate: ${type}.`);
  }
  return Object.assign(Object.assign({}, rest), { coordinates: [Object.assign({ type }, options), ...transform2] });
}
function coordOf(coordinates, type) {
  return coordinates.filter((d3) => d3.type === type);
}
function isPolar2(coordinates) {
  return coordOf(coordinates, "polar").length > 0;
}
function isHelix2(coordinates) {
  return coordOf(coordinates, "helix").length > 0;
}
function isTranspose2(coordinates) {
  return coordOf(coordinates, "transpose").length % 2 === 1;
}
function isParallel2(coordinates) {
  return coordOf(coordinates, "parallel").length > 0;
}
function isTheta2(coordinates) {
  return coordOf(coordinates, "theta").length > 0;
}
function isReflect(coordinates) {
  return coordOf(coordinates, "reflect").length > 0;
}
function isRadial2(coordinates) {
  return coordOf(coordinates, "radial").length > 0;
}
function isRadar2(coordinates) {
  return coordOf(coordinates, "radar").length > 0;
}
function isReflectY(coordinates) {
  return coordOf(coordinates, "reflectY").length > 0;
}
function inferCoordinate(coordinates) {
  if (coordinates.find((d3) => d3.type === "cartesian" || d3.type === "cartesian3D"))
    return coordinates;
  return [...coordinates, { type: "cartesian" }];
}

// node_modules/@antv/vendor/es/d3-scale-chromatic.mjs
var d3_scale_chromatic_exports = {};
__export(d3_scale_chromatic_exports, {
  interpolateBlues: () => Blues_default,
  interpolateBrBG: () => BrBG_default,
  interpolateBuGn: () => BuGn_default,
  interpolateBuPu: () => BuPu_default,
  interpolateCividis: () => cividis_default,
  interpolateCool: () => cool,
  interpolateCubehelixDefault: () => cubehelix_default,
  interpolateGnBu: () => GnBu_default,
  interpolateGreens: () => Greens_default,
  interpolateGreys: () => Greys_default,
  interpolateInferno: () => inferno,
  interpolateMagma: () => magma,
  interpolateOrRd: () => OrRd_default,
  interpolateOranges: () => Oranges_default,
  interpolatePRGn: () => PRGn_default,
  interpolatePiYG: () => PiYG_default,
  interpolatePlasma: () => plasma,
  interpolatePuBu: () => PuBu_default,
  interpolatePuBuGn: () => PuBuGn_default,
  interpolatePuOr: () => PuOr_default,
  interpolatePuRd: () => PuRd_default,
  interpolatePurples: () => Purples_default,
  interpolateRainbow: () => rainbow_default,
  interpolateRdBu: () => RdBu_default,
  interpolateRdGy: () => RdGy_default,
  interpolateRdPu: () => RdPu_default,
  interpolateRdYlBu: () => RdYlBu_default,
  interpolateRdYlGn: () => RdYlGn_default,
  interpolateReds: () => Reds_default,
  interpolateSinebow: () => sinebow_default,
  interpolateSpectral: () => Spectral_default,
  interpolateTurbo: () => turbo_default,
  interpolateViridis: () => viridis_default,
  interpolateWarm: () => warm,
  interpolateYlGn: () => YlGn_default,
  interpolateYlGnBu: () => YlGnBu_default,
  interpolateYlOrBr: () => YlOrBr_default,
  interpolateYlOrRd: () => YlOrRd_default,
  schemeAccent: () => Accent_default,
  schemeBlues: () => scheme22,
  schemeBrBG: () => scheme,
  schemeBuGn: () => scheme10,
  schemeBuPu: () => scheme11,
  schemeCategory10: () => category10_default,
  schemeDark2: () => Dark2_default,
  schemeGnBu: () => scheme12,
  schemeGreens: () => scheme23,
  schemeGreys: () => scheme24,
  schemeObservable10: () => observable10_default,
  schemeOrRd: () => scheme13,
  schemeOranges: () => scheme27,
  schemePRGn: () => scheme2,
  schemePaired: () => Paired_default,
  schemePastel1: () => Pastel1_default,
  schemePastel2: () => Pastel2_default,
  schemePiYG: () => scheme3,
  schemePuBu: () => scheme15,
  schemePuBuGn: () => scheme14,
  schemePuOr: () => scheme4,
  schemePuRd: () => scheme16,
  schemePurples: () => scheme25,
  schemeRdBu: () => scheme5,
  schemeRdGy: () => scheme6,
  schemeRdPu: () => scheme17,
  schemeRdYlBu: () => scheme7,
  schemeRdYlGn: () => scheme8,
  schemeReds: () => scheme26,
  schemeSet1: () => Set1_default,
  schemeSet2: () => Set2_default,
  schemeSet3: () => Set3_default,
  schemeSpectral: () => scheme9,
  schemeTableau10: () => Tableau10_default,
  schemeYlGn: () => scheme19,
  schemeYlGnBu: () => scheme18,
  schemeYlOrBr: () => scheme20,
  schemeYlOrRd: () => scheme21
});

// node_modules/d3-scale-chromatic/src/colors.js
function colors_default(specifier) {
  var n2 = specifier.length / 6 | 0, colors = new Array(n2), i2 = 0;
  while (i2 < n2) colors[i2] = "#" + specifier.slice(i2 * 6, ++i2 * 6);
  return colors;
}

// node_modules/d3-scale-chromatic/src/categorical/category10.js
var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

// node_modules/d3-scale-chromatic/src/categorical/Accent.js
var Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

// node_modules/d3-scale-chromatic/src/categorical/Dark2.js
var Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

// node_modules/d3-scale-chromatic/src/categorical/observable10.js
var observable10_default = colors_default("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0");

// node_modules/d3-scale-chromatic/src/categorical/Paired.js
var Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

// node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

// node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
var Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

// node_modules/d3-scale-chromatic/src/categorical/Set1.js
var Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

// node_modules/d3-scale-chromatic/src/categorical/Set2.js
var Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

// node_modules/d3-scale-chromatic/src/categorical/Set3.js
var Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

// node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
var Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

// node_modules/d3-scale-chromatic/src/ramp.js
var ramp_default = (scheme28) => rgbBasis(scheme28[scheme28.length - 1]);

// node_modules/d3-scale-chromatic/src/diverging/BrBG.js
var scheme = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors_default);
var BrBG_default = ramp_default(scheme);

// node_modules/d3-scale-chromatic/src/diverging/PRGn.js
var scheme2 = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors_default);
var PRGn_default = ramp_default(scheme2);

// node_modules/d3-scale-chromatic/src/diverging/PiYG.js
var scheme3 = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors_default);
var PiYG_default = ramp_default(scheme3);

// node_modules/d3-scale-chromatic/src/diverging/PuOr.js
var scheme4 = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors_default);
var PuOr_default = ramp_default(scheme4);

// node_modules/d3-scale-chromatic/src/diverging/RdBu.js
var scheme5 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors_default);
var RdBu_default = ramp_default(scheme5);

// node_modules/d3-scale-chromatic/src/diverging/RdGy.js
var scheme6 = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors_default);
var RdGy_default = ramp_default(scheme6);

// node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
var scheme7 = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors_default);
var RdYlBu_default = ramp_default(scheme7);

// node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
var scheme8 = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors_default);
var RdYlGn_default = ramp_default(scheme8);

// node_modules/d3-scale-chromatic/src/diverging/Spectral.js
var scheme9 = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors_default);
var Spectral_default = ramp_default(scheme9);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
var scheme10 = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors_default);
var BuGn_default = ramp_default(scheme10);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
var scheme11 = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors_default);
var BuPu_default = ramp_default(scheme11);

// node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
var scheme12 = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors_default);
var GnBu_default = ramp_default(scheme12);

// node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
var scheme13 = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors_default);
var OrRd_default = ramp_default(scheme13);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
var scheme14 = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors_default);
var PuBuGn_default = ramp_default(scheme14);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
var scheme15 = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors_default);
var PuBu_default = ramp_default(scheme15);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
var scheme16 = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors_default);
var PuRd_default = ramp_default(scheme16);

// node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
var scheme17 = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors_default);
var RdPu_default = ramp_default(scheme17);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
var scheme18 = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors_default);
var YlGnBu_default = ramp_default(scheme18);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
var scheme19 = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors_default);
var YlGn_default = ramp_default(scheme19);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
var scheme20 = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors_default);
var YlOrBr_default = ramp_default(scheme20);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
var scheme21 = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors_default);
var YlOrRd_default = ramp_default(scheme21);

// node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
var scheme22 = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors_default);
var Blues_default = ramp_default(scheme22);

// node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
var scheme23 = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors_default);
var Greens_default = ramp_default(scheme23);

// node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
var scheme24 = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors_default);
var Greys_default = ramp_default(scheme24);

// node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
var scheme25 = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors_default);
var Purples_default = ramp_default(scheme25);

// node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
var scheme26 = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors_default);
var Reds_default = ramp_default(scheme26);

// node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
var scheme27 = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors_default);
var Oranges_default = ramp_default(scheme27);

// node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js
function cividis_default(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))))) + ")";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
var cubehelix_default = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));

// node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var c3 = cubehelix();
function rainbow_default(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  c3.h = 360 * t - 100;
  c3.s = 1.5 - 1.5 * ts;
  c3.l = 0.8 - 0.9 * ts;
  return c3 + "";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
var c4 = rgb();
var pi_1_3 = Math.PI / 3;
var pi_2_3 = Math.PI * 2 / 3;
function sinebow_default(t) {
  var x2;
  t = (0.5 - t) * Math.PI;
  c4.r = 255 * (x2 = Math.sin(t)) * x2;
  c4.g = 255 * (x2 = Math.sin(t + pi_1_3)) * x2;
  c4.b = 255 * (x2 = Math.sin(t + pi_2_3)) * x2;
  return c4 + "";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js
function turbo_default(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
function ramp(range3) {
  var n2 = range3.length;
  return function(t) {
    return range3[Math.max(0, Math.min(n2 - 1, Math.floor(t * n2)))];
  };
}
var viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var plasma = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

// node_modules/@antv/g2/esm/runtime/scale.js
function inferScale(name2, values4, options, coordinates, theme, library3) {
  const { guide = {} } = options;
  const type = inferScaleType(name2, values4, options);
  if (typeof type !== "string")
    return options;
  const expectedDomain = inferScaleDomain(type, name2, values4, options);
  const actualDomain = maybeRatio(type, expectedDomain, options);
  return Object.assign(Object.assign(Object.assign({}, options), inferScaleOptions(type, name2, values4, options, coordinates)), {
    domain: actualDomain,
    range: inferScaleRange(type, name2, values4, options, actualDomain, theme, library3),
    expectedDomain,
    guide,
    name: name2,
    type
  });
}
function applyScale(channels, scale4) {
  const scaledValue = {};
  for (const channel of channels) {
    const { values: values4, name: scaleName } = channel;
    const scaleInstance = scale4[scaleName];
    for (const value2 of values4) {
      const { name: name2, value: V } = value2;
      scaledValue[name2] = V.map((d3) => scaleInstance.map(d3));
    }
  }
  return scaledValue;
}
function groupTransform(markState, uidScale) {
  const channels = Array.from(markState.values()).flatMap((d3) => d3.channels);
  const scaleGroups = rollups(channels, (channels2) => channels2.map((d3) => uidScale.get(d3.scale.uid)), (d3) => d3.name).filter(([, scales]) => scales.some((d3) => typeof d3.getOptions().groupTransform === "function") && // only sync scales with groupTransform options
  scales.every((d3) => d3.getTicks)).map((d3) => d3[1]);
  scaleGroups.forEach((group2) => {
    const groupTransform2 = group2.map((d3) => d3.getOptions().groupTransform)[0];
    groupTransform2(group2);
  });
}
function collectScales(states, options) {
  var _a;
  const { components = [] } = options;
  const NONE_STATIC_KEYS = [
    "scale",
    "encode",
    "axis",
    "legend",
    "data",
    "transform"
  ];
  const scales = Array.from(new Set(states.flatMap((d3) => d3.channels.map((d4) => d4.scale))));
  const nameScale = new Map(scales.map((scale4) => [scale4.name, scale4]));
  for (const component of components) {
    const channels = inferChannelsForComponent(component);
    for (const channel of channels) {
      const scale4 = nameScale.get(channel);
      const staticScale = ((_a = component.scale) === null || _a === void 0 ? void 0 : _a[channel]) || {};
      const { independent = false } = staticScale;
      if (scale4 && !independent) {
        const { guide } = scale4;
        const guide1 = typeof guide === "boolean" ? {} : guide;
        scale4.guide = deep_mix_default({}, guide1, component);
        Object.assign(scale4, staticScale);
      } else {
        const options1 = Object.assign(Object.assign({}, staticScale), { expectedDomain: staticScale.domain, name: channel, guide: omit_default(component, NONE_STATIC_KEYS) });
        scales.push(options1);
      }
    }
  }
  return scales;
}
function useRelation(relations) {
  if (!relations || !Array.isArray(relations))
    return [identity2, identity2];
  let map5;
  let invert2;
  const conditionalize = (scale4) => {
    var _a;
    map5 = scale4.map.bind(scale4);
    invert2 = (_a = scale4.invert) === null || _a === void 0 ? void 0 : _a.bind(scale4);
    const funcRelations = relations.filter(([v]) => typeof v === "function");
    const valueRelations = relations.filter(([v]) => typeof v !== "function");
    const valueOutput = new Map(valueRelations);
    scale4.map = (x2) => {
      for (const [verify, value2] of funcRelations) {
        if (verify(x2))
          return value2;
      }
      if (valueOutput.has(x2))
        return valueOutput.get(x2);
      return map5(x2);
    };
    if (!invert2)
      return scale4;
    const outputValue = new Map(valueRelations.map(([a4, b]) => [b, a4]));
    const outputFunc = new Map(funcRelations.map(([a4, b]) => [b, a4]));
    scale4.invert = (x2) => {
      if (outputFunc.has(x2))
        return x2;
      if (outputValue.has(x2))
        return outputValue.get(x2);
      return invert2(x2);
    };
    return scale4;
  };
  const deconditionalize = (scale4) => {
    if (map5 !== null)
      scale4.map = map5;
    if (invert2 !== null)
      scale4.invert = invert2;
    return scale4;
  };
  return [conditionalize, deconditionalize];
}
function assignScale(target, source) {
  const keys = Object.keys(target);
  for (const scale4 of Object.values(source)) {
    const { name: name2 } = scale4.getOptions();
    if (!(name2 in target))
      target[name2] = scale4;
    else {
      const I = keys.filter((d3) => d3.startsWith(name2)).map((d3) => +(d3.replace(name2, "") || 0));
      const index2 = max(I) + 1;
      const newKey = `${name2}${index2}`;
      target[newKey] = scale4;
      scale4.getOptions().key = newKey;
    }
  }
  return target;
}
function useRelationScale(options, library3) {
  const [useScale] = useLibrary("scale", library3);
  const { relations } = options;
  const [conditionalize] = useRelation(relations);
  const scale4 = useScale(options);
  return conditionalize(scale4);
}
function syncFacetsScales(states) {
  const scales = states.flatMap((d3) => Array.from(d3.values())).flatMap((d3) => d3.channels.map((d4) => d4.scale));
  syncFacetsScaleByChannel(scales, "x");
  syncFacetsScaleByChannel(scales, "y");
}
function inferChannelsForComponent(component) {
  const { channels = [], type, scale: scale4 = {} } = component;
  const L = ["shape", "color", "opacity", "size"];
  if (channels.length !== 0)
    return channels;
  if (type === "axisX")
    return ["x"];
  if (type === "axisY")
    return ["y"];
  if (type === "legends")
    return Object.keys(scale4).filter((d3) => L.includes(d3));
  return [];
}
function syncFacetsScaleByChannel(scales, channel) {
  const S = scales.filter(({ name: name2, facet = true }) => facet && name2 === channel);
  const D = S.flatMap((d3) => d3.domain);
  const syncedD = S.every(isQuantitativeScale) ? extent(D) : S.every(isDiscreteScale) ? Array.from(new Set(D)) : null;
  if (syncedD === null)
    return;
  for (const scale4 of S) {
    scale4.domain = syncedD;
  }
}
function maybeRatio(type, domain, options) {
  const { ratio } = options;
  if (ratio === void 0 || ratio === null)
    return domain;
  if (isQuantitativeScale({ type })) {
    return clampQuantitativeScale(domain, ratio, type);
  }
  if (isDiscreteScale({ type }))
    return clampDiscreteScale(domain, ratio);
  return domain;
}
function clampQuantitativeScale(domain, ratio, type) {
  const D = domain.map(Number);
  const scale4 = new Linear({
    domain: D,
    range: [D[0], D[0] + (D[D.length - 1] - D[0]) * ratio]
  });
  if (type === "time")
    return domain.map((d3) => new Date(scale4.map(d3)));
  return domain.map((d3) => scale4.map(d3));
}
function clampDiscreteScale(domain, ratio) {
  const index2 = Math.round(domain.length * ratio);
  return domain.slice(0, index2);
}
function isQuantitativeScale(scale4) {
  const { type } = scale4;
  if (typeof type !== "string")
    return false;
  const names = ["linear", "log", "pow", "time"];
  return names.includes(type);
}
function isDiscreteScale(scale4) {
  const { type } = scale4;
  if (typeof type !== "string")
    return false;
  const names = ["band", "point", "ordinal"];
  return names.includes(type);
}
function inferScaleType(name2, values4, options) {
  const { type, domain, range: range3, quantitative, ordinal } = options;
  if (type !== void 0)
    return type;
  if (isObject3(values4))
    return "identity";
  if (typeof range3 === "string")
    return "linear";
  if ((domain || range3 || []).length > 2)
    return asOrdinalType(name2, ordinal);
  if (domain !== void 0) {
    if (isOrdinal([domain]))
      return asOrdinalType(name2, ordinal);
    if (isTemporal(values4))
      return "time";
    return asQuantitativeType(name2, range3, quantitative);
  }
  if (isOrdinal(values4))
    return asOrdinalType(name2, ordinal);
  if (isTemporal(values4))
    return "time";
  return asQuantitativeType(name2, range3, quantitative);
}
function inferScaleDomain(type, name2, values4, options) {
  const { domain } = options;
  if (domain !== void 0)
    return domain;
  switch (type) {
    case "linear":
    case "time":
    case "log":
    case "pow":
    case "sqrt":
    case "quantize":
    case "threshold":
      return maybeMinMax(inferDomainQ(values4, options), options);
    case "band":
    case "ordinal":
    case "point":
      return inferDomainC(values4);
    case "quantile":
      return inferDomainO(values4);
    case "sequential":
      return maybeMinMax(inferDomainS(values4), options);
    default:
      return [];
  }
}
function inferScaleRange(type, name2, values4, options, domain, theme, library3) {
  const { range: range3 } = options;
  if (typeof range3 === "string")
    return gradientColors(range3);
  if (range3 !== void 0)
    return range3;
  const { rangeMin, rangeMax } = options;
  switch (type) {
    case "linear":
    case "time":
    case "log":
    case "pow":
    case "sqrt": {
      const colors = categoricalColors(values4, options, domain, theme, library3);
      const [r0, r1] = inferRangeQ(name2, colors);
      return [rangeMin !== null && rangeMin !== void 0 ? rangeMin : r0, rangeMax !== null && rangeMax !== void 0 ? rangeMax : r1];
    }
    case "band":
    case "point": {
      const min6 = name2 === "size" ? 5 : 0;
      const max7 = name2 === "size" ? 10 : 1;
      return [rangeMin !== null && rangeMin !== void 0 ? rangeMin : min6, rangeMax !== null && rangeMax !== void 0 ? rangeMax : max7];
    }
    case "ordinal": {
      return categoricalColors(values4, options, domain, theme, library3);
    }
    case "sequential":
      return void 0;
    case "constant":
      return [values4[0][0]];
    default:
      return [];
  }
}
function inferScaleOptions(type, name2, values4, options, coordinates) {
  switch (type) {
    case "linear":
    case "time":
    case "log":
    case "pow":
    case "sqrt":
      return inferOptionsQ(coordinates, options);
    case "band":
    case "point":
      return inferOptionsC(type, name2, coordinates, options);
    case "sequential":
      return inferOptionsS(options);
    default:
      return options;
  }
}
function categoricalColors(values4, options, domain, theme, library3) {
  const [usePalette] = useLibrary("palette", library3);
  const { category10: c10, category20: c20 } = theme;
  const defaultPalette = unique(domain).length <= c10.length ? c10 : c20;
  const { palette = defaultPalette, offset: offset2 } = options;
  if (Array.isArray(palette))
    return palette;
  try {
    return usePalette({ type: palette });
  } catch (e3) {
    const colors = interpolatedColors(palette, domain, offset2);
    if (colors)
      return colors;
    throw new Error(`Unknown Component: ${palette} `);
  }
}
function gradientColors(range3) {
  return range3.split("-");
}
function interpolatedColors(palette, domain, offset2 = (d3) => d3) {
  if (!palette)
    return null;
  const fullName = upper_first_default(palette);
  const scheme28 = d3_scale_chromatic_exports[`scheme${fullName}`];
  const interpolator = d3_scale_chromatic_exports[`interpolate${fullName}`];
  if (!scheme28 && !interpolator)
    return null;
  if (scheme28) {
    if (!scheme28.some(Array.isArray))
      return scheme28;
    const schemeColors = scheme28[domain.length];
    if (schemeColors)
      return schemeColors;
  }
  return domain.map((_, i2) => interpolator(offset2(i2 / domain.length)));
}
function inferOptionsS(options) {
  const { palette = "ylGnBu", offset: offset2 } = options;
  const name2 = upper_first_default(palette);
  const interpolator = d3_scale_chromatic_exports[`interpolate${name2}`];
  if (!interpolator)
    throw new Error(`Unknown palette: ${name2}`);
  return {
    interpolator: offset2 ? (x2) => interpolator(offset2(x2)) : interpolator
  };
}
function inferOptionsQ(coordinates, options) {
  const { interpolate: interpolate2 = createInterpolateValue, nice: nice2 = false, tickCount = 5 } = options;
  return Object.assign(Object.assign({}, options), { interpolate: interpolate2, nice: nice2, tickCount });
}
function inferOptionsC(type, name2, coordinates, options) {
  if (options.padding !== void 0 || options.paddingInner !== void 0 || options.paddingOuter !== void 0) {
    return Object.assign(Object.assign({}, options), { unknown: NaN });
  }
  const padding = inferPadding(type, name2, coordinates);
  const { paddingInner = padding, paddingOuter = padding } = options;
  return Object.assign(Object.assign({}, options), {
    paddingInner,
    paddingOuter,
    padding,
    unknown: NaN
  });
}
function inferPadding(type, name2, coordinates) {
  if (name2 === "enterDelay" || name2 === "enterDuration")
    return 0;
  if (name2 === "size")
    return 0;
  if (type === "band")
    return isTheta2(coordinates) ? 0 : 0.1;
  if (type === "point")
    return 0.5;
  return 0;
}
function asOrdinalType(name2, defaults4) {
  if (defaults4)
    return defaults4;
  return isQuantitative(name2) ? "point" : "ordinal";
}
function asQuantitativeType(name2, range3, defaults4) {
  if (defaults4)
    return defaults4;
  if (name2 !== "color")
    return "linear";
  return range3 ? "linear" : "sequential";
}
function maybeMinMax(domain, options) {
  if (domain.length === 0)
    return domain;
  const { domainMin, domainMax } = options;
  const [d0, d1] = domain;
  return [domainMin !== null && domainMin !== void 0 ? domainMin : d0, domainMax !== null && domainMax !== void 0 ? domainMax : d1];
}
function inferDomainQ(values4, options) {
  const { zero: zero2 = false } = options;
  let min6 = Infinity;
  let max7 = -Infinity;
  for (const value2 of values4) {
    for (const d3 of value2) {
      if (defined(d3)) {
        min6 = Math.min(min6, +d3);
        max7 = Math.max(max7, +d3);
      }
    }
  }
  if (min6 === Infinity)
    return [];
  return zero2 ? [Math.min(0, min6), max7] : [min6, max7];
}
function inferDomainC(values4) {
  return Array.from(new Set(values4.flat()));
}
function inferDomainO(values4) {
  return values4.flat().sort();
}
function inferDomainS(values4) {
  let min6 = Infinity;
  let max7 = -Infinity;
  for (const value2 of values4) {
    for (const d3 of value2) {
      if (defined(d3)) {
        min6 = Math.min(min6, +d3);
        max7 = Math.max(max7, +d3);
      }
    }
  }
  if (min6 === Infinity)
    return [];
  return [min6 < 0 ? -max7 : min6, max7];
}
function inferRangeQ(name2, palette) {
  if (name2 === "enterDelay")
    return [0, 1e3];
  if (name2 == "enterDuration")
    return [300, 1e3];
  if (name2.startsWith("y") || name2.startsWith("position"))
    return [1, 0];
  if (name2 === "color")
    return [firstOf(palette), lastOf(palette)];
  if (name2 === "opacity")
    return [0, 1];
  if (name2 === "size")
    return [1, 10];
  return [0, 1];
}
function isOrdinal(values4) {
  return some2(values4, (d3) => {
    const type = typeof d3;
    return type === "string" || type === "boolean";
  });
}
function isTemporal(values4) {
  return some2(values4, (d3) => d3 instanceof Date);
}
function isObject3(values4) {
  return some2(values4, isStrictObject);
}
function some2(values4, callback) {
  for (const V of values4) {
    if (V.some(callback))
      return true;
  }
  return false;
}
function isQuantitative(name2) {
  return name2.startsWith("x") || name2.startsWith("y") || name2.startsWith("position") || name2.startsWith("size");
}
function isPosition(name2) {
  return name2.startsWith("x") || name2.startsWith("y") || name2.startsWith("position") || name2 === "enterDelay" || name2 === "enterDuration" || name2 === "updateDelay" || name2 === "updateDuration" || name2 === "exitDelay" || name2 === "exitDuration";
}
function isValidScale(scale4) {
  if (!scale4 || !scale4.type)
    return false;
  if (typeof scale4.type === "function")
    return true;
  const { type, domain, range: range3, interpolator } = scale4;
  const isValidDomain = domain && domain.length > 0;
  const isValidRange = range3 && range3.length > 0;
  if ([
    "linear",
    "sqrt",
    "log",
    "time",
    "pow",
    "threshold",
    "quantize",
    "quantile",
    "ordinal",
    "band",
    "point"
  ].includes(type) && isValidDomain && isValidRange) {
    return true;
  }
  if (["sequential"].includes(type) && isValidDomain && (isValidRange || interpolator)) {
    return true;
  }
  if (["constant", "identity"].includes(type) && isValidRange)
    return true;
  return false;
}

// node_modules/@antv/g2/esm/runtime/types/scale.js
var ContinuousScale = {
  linear: "linear",
  identity: "identity",
  log: "log",
  pow: "pow",
  sqrt: "sqrt",
  sequential: "sequential"
};
var DistributionScale = {
  threshold: "threshold",
  quantize: "quantize",
  quantile: "quantile"
};
var DiscreteScale = {
  ordinal: "ordinal",
  band: "band",
  point: "point"
};
var ConstantScale = {
  constant: "constant"
};

// node_modules/@antv/g2/esm/runtime/component.js
var __rest68 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function inferComponent(scales, partialOptions, library3) {
  const { coordinates = [], title } = partialOptions;
  const [, createGuideComponent] = useLibrary("component", library3);
  const displayedScales = scales.filter(({ guide }) => {
    if (guide === null)
      return false;
    return true;
  });
  const components = [];
  const sliders = inferScrollableComponents(partialOptions, scales, library3);
  components.push(...sliders);
  if (title) {
    const { props } = createGuideComponent("title");
    const { defaultPosition, defaultOrientation, defaultOrder, defaultSize, defaultCrossPadding } = props;
    const titleOptions = typeof title === "string" ? { title } : title;
    components.push(Object.assign({ type: "title", position: defaultPosition, orientation: defaultOrientation, order: defaultOrder, crossPadding: defaultCrossPadding[0], defaultSize }, titleOptions));
  }
  const inferredComponents = inferComponentsType(displayedScales, coordinates);
  inferredComponents.forEach(([type, relativeScales]) => {
    const { props } = createGuideComponent(type);
    const { defaultPosition, defaultPlane = "xy", defaultOrientation, defaultSize, defaultOrder, defaultLength, defaultPadding: DP = [0, 0], defaultCrossPadding: DCP = [0, 0] } = props;
    const scale4 = deep_mix_default({}, ...relativeScales);
    const { guide: guideOptions, field: field3 } = scale4;
    const guides = Array.isArray(guideOptions) ? guideOptions : [guideOptions];
    for (const partialGuide of guides) {
      const [position, orientation] = inferComponentPositionAndOrientation(type, defaultPosition, defaultOrientation, partialGuide, relativeScales, displayedScales, coordinates);
      if (!position && !orientation)
        continue;
      const isVertical2 = position === "left" || position === "right";
      const defaultPadding = isVertical2 ? DP[1] : DP[0];
      const defaultCrossPadding = isVertical2 ? DCP[1] : DCP[0];
      const { size: size4, order = defaultOrder, length = defaultLength, padding = defaultPadding, crossPadding = defaultCrossPadding } = partialGuide;
      components.push(Object.assign(Object.assign({ title: field3 }, partialGuide), {
        defaultSize,
        length,
        position,
        plane: defaultPlane,
        orientation,
        padding,
        order,
        crossPadding,
        size: size4,
        type,
        scales: relativeScales
      }));
    }
  });
  return components;
}
function renderComponent(component, coordinate, theme, library3, markState) {
  const [useGuideComponent] = useLibrary("component", library3);
  const { scaleInstances: scales, scale: scale4, bbox } = component, options = __rest68(component, ["scaleInstances", "scale", "bbox"]);
  const value2 = { bbox, library: library3 };
  const render3 = useGuideComponent(options);
  return render3({
    coordinate,
    library: library3,
    markState,
    scales,
    theme,
    value: value2,
    scale: scale4
  });
}
function normalizeComponents(components) {
  return components.map((d3) => {
    const component = deep_mix_default(d3, d3.style);
    delete component.style;
    return component;
  });
}
function groupComponents(components, crossSize) {
  const P = ["left", "right", "bottom", "top"];
  const key = ({ type, position, group: group2 }) => {
    if (!P.includes(position))
      return Symbol("independent");
    if (group2 === void 0) {
      if (type.startsWith("legend"))
        return `legend-${position}`;
      return Symbol("independent");
    }
    if (group2 === "independent")
      return Symbol("independent");
    return group2;
  };
  const grouped = groups(components, key);
  return grouped.flatMap(([, components2]) => {
    if (components2.length === 1)
      return components2[0];
    if (crossSize !== void 0) {
      const DL = components2.filter((d3) => d3.length !== void 0).map((d3) => d3.length);
      const totalLength = sum(DL);
      if (totalLength > crossSize) {
        components2.forEach((d3) => d3.group = Symbol("independent"));
        return components2;
      }
      const emptyLength = crossSize - totalLength;
      const emptyCount = components2.length - DL.length;
      const length = emptyLength / emptyCount;
      components2.forEach((d3) => {
        if (d3.length !== void 0)
          return;
        d3.length = length;
      });
    }
    const size4 = max(components2, (d3) => d3.size);
    const order = max(components2, (d3) => d3.order);
    const crossPadding = max(components2, (d3) => d3.crossPadding);
    const position = components2[0].position;
    return {
      type: "group",
      size: size4,
      order,
      position,
      children: components2,
      crossPadding
    };
  });
}
function inferLegendComponentType(scales, coordinates) {
  const channels = ["shape", "size", "color", "opacity"];
  const isConstantSize = (type, name2) => type === "constant" && name2 === "size";
  const accepts = scales.filter(({ type, name: name2 }) => typeof type === "string" && channels.includes(name2) && !isConstantSize(type, name2));
  const constants = accepts.filter(({ type }) => type === "constant");
  const nonConstants = accepts.filter(({ type }) => type !== "constant");
  const groupKey = (d3) => d3.field ? d3.field : Symbol("independent");
  const fieldScales = groups(nonConstants, groupKey).map(([key, scales2]) => [key, [...scales2, ...constants]]).filter(([, scales2]) => scales2.some((scale4) => scale4.type !== "constant"));
  const scalesByField = new Map(fieldScales);
  if (scalesByField.size === 0)
    return [];
  const sort2 = (arr) => arr.sort(([a4], [b]) => a4.localeCompare(b));
  const components = Array.from(scalesByField).map(([, scs]) => {
    const combinations = combine(scs).sort((a4, b) => b.length - a4.length);
    const options = combinations.map((combination) => ({
      combination,
      option: combination.map((scale4) => [scale4.name, getScaleType(scale4)])
    }));
    for (const { option, combination } of options) {
      if (option.every((d3) => d3[1] === "constant"))
        continue;
      if (option.every((d3) => d3[1] === "discrete" || d3[1] === "constant")) {
        return ["legendCategory", combination];
      }
    }
    for (const [componentType, accords] of LEGEND_INFER_STRATEGIES) {
      for (const { option, combination } of options) {
        if (accords.some((accord) => is_equal_default(sort2(accord), sort2(option)))) {
          return [componentType, combination];
        }
      }
    }
    return null;
  }).filter(defined);
  return components;
}
function getScaleType(scale4) {
  const { type } = scale4;
  if (typeof type !== "string")
    return null;
  if (type in ContinuousScale)
    return "continuous";
  if (type in DiscreteScale)
    return "discrete";
  if (type in DistributionScale)
    return "distribution";
  if (type in ConstantScale)
    return "constant";
  return null;
}
function inferAxisComponentType(scales, coordinates) {
  return scales.map((scale4) => {
    const { name: name2 } = scale4;
    if (isHelix2(coordinates) || isTheta2(coordinates))
      return null;
    if (isTranspose2(coordinates) && (isPolar2(coordinates) || isRadial2(coordinates)))
      return null;
    if (name2.startsWith("x")) {
      if (isPolar2(coordinates))
        return ["axisArc", [scale4]];
      if (isRadial2(coordinates))
        return ["axisLinear", [scale4]];
      return [isTranspose2(coordinates) ? "axisY" : "axisX", [scale4]];
    }
    if (name2.startsWith("y")) {
      if (isPolar2(coordinates))
        return ["axisLinear", [scale4]];
      if (isRadial2(coordinates))
        return ["axisArc", [scale4]];
      return [isTranspose2(coordinates) ? "axisX" : "axisY", [scale4]];
    }
    if (name2.startsWith("z")) {
      return ["axisZ", [scale4]];
    }
    if (name2.startsWith("position")) {
      if (isRadar2(coordinates))
        return ["axisRadar", [scale4]];
      if (!isPolar2(coordinates))
        return ["axisY", [scale4]];
    }
    return null;
  }).filter(defined);
}
function inferComponentsType(scales, coordinates) {
  const availableScales = scales.filter((scale4) => isValidScale(scale4));
  return [
    ...inferLegendComponentType(availableScales, coordinates),
    ...inferAxisComponentType(availableScales, coordinates)
  ];
}
function angleOf3(coordinates) {
  const polar2 = coordOf(coordinates, "polar");
  if (polar2.length) {
    const lastPolar = polar2[polar2.length - 1];
    const { startAngle, endAngle } = getPolarOptions(lastPolar);
    return [startAngle, endAngle];
  }
  const radial = coordOf(coordinates, "radial");
  if (radial.length) {
    const lastRadial = radial[radial.length - 1];
    const { startAngle, endAngle } = getRadialOptions(lastRadial);
    return [startAngle, endAngle];
  }
  return [-Math.PI / 2, Math.PI / 2 * 3];
}
function matchPosition(name2) {
  const match = /position(\d*)/g.exec(name2);
  if (!match)
    return null;
  return +match[1];
}
function inferAxisPositionAndOrientation(type, ordinalPosition, relativeScales, scales, coordinates) {
  const { name: name2 } = relativeScales[0];
  if (type === "axisRadar") {
    const positions = scales.filter((scale4) => scale4.name.startsWith("position"));
    const index2 = matchPosition(name2);
    if (index2 === null)
      return [null, null];
    const [startAngle, endAngle] = angleOf3(coordinates);
    const positionLength = isRadar2(coordinates) ? positions.length : positions.length - 1;
    const angle2 = (endAngle - startAngle) / positionLength * index2 + startAngle;
    return ["center", angle2];
  }
  if (type === "axisY" && isParallel2(coordinates)) {
    return isTranspose2(coordinates) ? ["center", "horizontal"] : ["center", "vertical"];
  }
  if (type === "axisLinear") {
    const [startAngle] = angleOf3(coordinates);
    return ["center", startAngle];
  }
  if (type === "axisArc") {
    if (ordinalPosition[0] === "inner")
      return ["inner", null];
    return ["outer", null];
  }
  if (isPolar2(coordinates))
    return ["center", null];
  if (isRadial2(coordinates))
    return ["center", null];
  if (type === "axisX" && isReflect(coordinates) || type === "axisX" && isReflectY(coordinates)) {
    return ["top", null];
  }
  return ordinalPosition;
}
function inferComponentPositionAndOrientation(type, defaultPosition, defaultOrientation, guide, relativeScales, scales, coordinates) {
  const [startAngle] = angleOf3(coordinates);
  const ordinalPositionAndOrientation = [
    guide.position || defaultPosition,
    startAngle !== null && startAngle !== void 0 ? startAngle : defaultOrientation
  ];
  if (typeof type === "string" && type.startsWith("axis")) {
    return inferAxisPositionAndOrientation(type, ordinalPositionAndOrientation, relativeScales, scales, coordinates);
  }
  if (typeof type === "string" && type.startsWith("legend") && isPolar2(coordinates)) {
    if (guide.position === "center")
      return ["center", "vertical"];
  }
  return ordinalPositionAndOrientation;
}
function inferScrollableType(name2, type, coordinates = []) {
  if (name2 === "x")
    return isTranspose2(coordinates) ? `${type}Y` : `${type}X`;
  if (name2 === "y")
    return isTranspose2(coordinates) ? `${type}X` : `${type}Y`;
  return null;
}
function inferScrollableComponents(partialOptions, scales, library3) {
  const [, createGuideComponent] = useLibrary("component", library3);
  const { coordinates } = partialOptions;
  function normalized(type, channelName, scale4, options) {
    const componentType = inferScrollableType(channelName, type, coordinates);
    if (!options || !componentType)
      return;
    const { props } = createGuideComponent(componentType);
    const { defaultPosition, defaultSize, defaultOrder, defaultCrossPadding: [crossPadding] } = props;
    return Object.assign(Object.assign({ position: defaultPosition, defaultSize, order: defaultOrder, type: componentType, crossPadding }, options), { scales: [scale4] });
  }
  return scales.filter((d3) => d3.slider || d3.scrollbar).flatMap((scale4) => {
    const { slider, scrollbar, name: channelName } = scale4;
    return [
      normalized("slider", channelName, scale4, slider),
      normalized("scrollbar", channelName, scale4, scrollbar)
    ];
  }).filter((d3) => !!d3);
}
function computeComponentSize(component, crossSize, crossPadding, position, theme, library3) {
  const { type } = component;
  const paddingAreas = ["left", "right", "bottom", "top"];
  if (!paddingAreas.includes(position))
    return;
  if (typeof type !== "string")
    return;
  const t = type;
  const createCompute = () => {
    if (t.startsWith("axis"))
      return computeAxisSize;
    if (t.startsWith("group"))
      return computeGroupSize;
    if (t.startsWith("legendContinuous"))
      return computeContinuousLegendSize;
    if (t === "legendCategory")
      return computeCategoryLegendSize;
    if (t.startsWith("slider"))
      return computeSliderSize;
    if (t === "title")
      return computeTitleSize;
    if (t.startsWith("scrollbar"))
      return computeScrollbarSize;
    return () => {
    };
  };
  return createCompute()(component, crossSize, crossPadding, position, theme, library3);
}
function computeGroupSize(component, crossSize, crossPadding, position, theme, library3) {
  const { children } = component;
  const maxCrossPadding = max(children, (d3) => d3.crossPadding);
  children.forEach((d3) => d3.crossPadding = maxCrossPadding);
  children.forEach((child) => computeComponentSize(child, crossSize, crossPadding, position, theme, library3));
  const maxSize = max(children, (d3) => d3.size);
  component.size = maxSize;
  children.forEach((d3) => d3.size = maxSize);
}
function computeScrollbarSize(component, crossSize, crossPadding, position, theme, library3) {
  const { trackSize = 6 } = deep_mix_default({}, theme.scrollbar, component);
  component.size = trackSize;
}
function computeTitleSize(component, crossSize, crossPadding, position, theme, library3) {
  const _a = deep_mix_default({}, theme.title, component), { title, subtitle, spacing = 0 } = _a, style = __rest68(_a, ["title", "subtitle", "spacing"]);
  if (title) {
    const titleStyle = subObject(style, "title");
    const titleBBox = computeLabelSize(title, titleStyle);
    component.size = titleBBox.height;
  }
  if (subtitle) {
    const subtitleStyle = subObject(style, "subtitle");
    const subtitleBBox = computeLabelSize(subtitle, subtitleStyle);
    component.size += spacing + subtitleBBox.height;
  }
}
function computeSliderSize(component, crossSize, crossPadding, position, theme, library3) {
  const styleOf2 = () => {
    const { slider } = theme;
    return deep_mix_default({}, slider, component);
  };
  const { trackSize, handleIconSize } = styleOf2();
  const size4 = Math.max(trackSize, handleIconSize * 2.4);
  component.size = size4;
}
function computeAxisSize(component, crossSize, crossPadding, position, theme, library3) {
  var _a, _b;
  component.transform = component.transform || [{ type: "hide" }];
  const isVertical2 = position === "left" || position === "right";
  const style = styleOf(component, position, theme);
  const { tickLength = 0, labelSpacing = 0, titleSpacing = 0, labelAutoRotate } = style, rest = __rest68(style, ["tickLength", "labelSpacing", "titleSpacing", "labelAutoRotate"]);
  const scale4 = createScale(component, library3);
  const labelBBoxes = computeLabelsBBox(rest, scale4);
  let maxTickLength = tickLength;
  if (typeof component.tickLength === "function") {
    const ticks2 = ((_a = scale4.getTicks) === null || _a === void 0 ? void 0 : _a.call(scale4)) || scale4.getOptions().domain;
    const tickLengths = ticks2.map((d3, i2, array2) => component.tickLength(d3, i2, array2));
    maxTickLength = Math.max(...tickLengths, 0);
  }
  const paddingTick = maxTickLength + labelSpacing;
  if (labelBBoxes && labelBBoxes.length) {
    const maxLabelWidth = max(labelBBoxes, (d3) => d3.width);
    const maxLabelHeight = max(labelBBoxes, (d3) => d3.height);
    if (isVertical2) {
      component.size = maxLabelWidth + paddingTick;
    } else {
      const { tickFilter, labelTransform } = component;
      if (overflowX(scale4, labelBBoxes, crossSize, crossPadding, tickFilter) && !labelTransform && labelAutoRotate !== false && labelAutoRotate !== null) {
        component.labelTransform = "rotate(90)";
        component.size = maxLabelWidth + paddingTick;
      } else {
        component.labelTransform = (_b = component.labelTransform) !== null && _b !== void 0 ? _b : "rotate(0)";
        component.size = maxLabelHeight + paddingTick;
      }
    }
  } else {
    component.size = maxTickLength;
  }
  const titleBBox = computeTitleBBox(rest);
  if (titleBBox) {
    if (isVertical2) {
      component.size += titleSpacing + titleBBox.width;
    } else {
      component.size += titleSpacing + titleBBox.height;
    }
  }
}
function computeContinuousLegendSize(component, crossSize, crossPadding, position, theme, library3) {
  const styleOf2 = () => {
    const { legendContinuous } = theme;
    return deep_mix_default({}, legendContinuous, component);
  };
  const _a = styleOf2(), { labelSpacing = 0, titleSpacing = 0 } = _a, rest = __rest68(_a, ["labelSpacing", "titleSpacing"]);
  const isVertical2 = position === "left" || position === "right";
  const ribbonStyles = subObject(rest, "ribbon");
  const { size: ribbonSize } = ribbonStyles;
  const handleIconStyles = subObject(rest, "handleIcon");
  const { size: handleIconSize } = handleIconStyles;
  const mainSize = Math.max(ribbonSize, handleIconSize * 2.4);
  component.size = mainSize;
  const scale4 = createScale(component, library3);
  const labelBBoxes = computeLabelsBBox(rest, scale4);
  if (labelBBoxes) {
    const key = isVertical2 ? "width" : "height";
    const size4 = max(labelBBoxes, (d3) => d3[key]);
    component.size += size4 + labelSpacing;
  }
  const titleBBox = computeTitleBBox(rest);
  if (titleBBox) {
    if (isVertical2) {
      component.size = Math.max(component.size, titleBBox.width);
    } else {
      component.size += titleSpacing + titleBBox.height;
    }
  }
}
function computeCategoryLegendSize(component, crossSize0, crossPadding, position, theme, library3) {
  const styleOf2 = () => {
    const { legendCategory } = theme;
    const { title } = component;
    const [defaultTitle, specifiedTitle] = Array.isArray(title) ? [title, void 0] : [void 0, title];
    return deep_mix_default({ title: defaultTitle }, legendCategory, Object.assign(Object.assign({}, component), { title: specifiedTitle }));
  };
  const _a = styleOf2(), { focus: focus2, itemSpacing, focusMarkerSize, itemMarkerSize, titleSpacing, rowPadding, colPadding, maxCols = Infinity, maxRows = Infinity } = _a, rest = __rest68(_a, ["focus", "itemSpacing", "focusMarkerSize", "itemMarkerSize", "titleSpacing", "rowPadding", "colPadding", "maxCols", "maxRows"]);
  const { cols, length } = component;
  const getRows = (rows) => Math.min(rows, maxRows);
  const getCols = (cols2) => Math.min(cols2, maxCols);
  const isVertical2 = position === "left" || position === "right";
  const crossSize = length === void 0 ? crossSize0 + (isVertical2 ? 0 : crossPadding[0] + crossPadding[1]) : length;
  const titleBBox = computeTitleBBox(rest);
  const scale4 = createScale(component, library3);
  const labelBBoxes = computeLabelsBBox(rest, scale4, "itemLabel");
  const height = Math.max(labelBBoxes[0].height, itemMarkerSize) + rowPadding;
  const widthOf = (w2, padding = 0) => itemMarkerSize + w2 + itemSpacing[0] + padding + (focus2 ? focusMarkerSize + itemSpacing[2] : 0);
  const computeVerticalSize = () => {
    let maxSize = -Infinity;
    let pos = 0;
    let cols2 = 1;
    let rows = 0;
    let maxRows2 = -Infinity;
    let maxPos = -Infinity;
    const titleHeight = titleBBox ? titleBBox.height : 0;
    const maxHeight = crossSize - titleHeight;
    for (const { width } of labelBBoxes) {
      const w2 = widthOf(width, colPadding);
      maxSize = Math.max(maxSize, w2);
      if (pos + height > maxHeight) {
        cols2++;
        maxRows2 = Math.max(maxRows2, rows);
        maxPos = Math.max(maxPos, pos);
        rows = 1;
        pos = height;
      } else {
        pos += height;
        rows++;
      }
    }
    if (cols2 <= 1) {
      maxRows2 = rows;
      maxPos = pos;
    }
    component.size = maxSize * getCols(cols2);
    component.length = maxPos + titleHeight;
    deep_mix_default(component, { cols: getCols(cols2), gridRow: maxRows2 });
  };
  const computeHorizontalGrid = () => {
    const rows = Math.ceil(labelBBoxes.length / cols);
    const maxWidth = max(labelBBoxes, (d3) => widthOf(d3.width)) * cols;
    component.size = height * getRows(rows) - rowPadding;
    component.length = Math.min(maxWidth, crossSize);
  };
  const computeHorizontalFlex = () => {
    let rows = 1;
    let pos = 0;
    let maxPos = -Infinity;
    for (const { width } of labelBBoxes) {
      const w2 = widthOf(width, colPadding);
      if (pos + w2 > crossSize) {
        maxPos = Math.max(maxPos, pos);
        pos = w2;
        rows++;
      } else {
        pos += w2;
      }
    }
    if (rows === 1)
      maxPos = pos;
    component.size = height * getRows(rows) - rowPadding;
    component.length = maxPos;
  };
  if (isVertical2)
    computeVerticalSize();
  else if (typeof cols === "number")
    computeHorizontalGrid();
  else
    computeHorizontalFlex();
  if (titleBBox) {
    if (isVertical2) {
      component.size = Math.max(component.size, titleBBox.width);
    } else {
      component.size += titleSpacing + titleBBox.height;
    }
  }
}
function createScale(component, library3) {
  const [useScale] = useLibrary("scale", library3);
  const { scales, tickCount, tickMethod } = component;
  const scaleOptions = scales.find((d3) => d3.type !== "constant" && d3.type !== "identity");
  if (tickCount !== void 0)
    scaleOptions.tickCount = tickCount;
  if (tickMethod !== void 0)
    scaleOptions.tickMethod = tickMethod;
  return useScale(scaleOptions);
}
function computeLabelsBBox(component, scale4, key = "label") {
  const { labelFormatter, tickFilter, label = true } = component, style = __rest68(component, ["labelFormatter", "tickFilter", "label"]);
  if (!label)
    return null;
  const labels = labelsOf(scale4, labelFormatter, tickFilter);
  const labelStyle = subObject(style, key);
  const labelStyles = labels.map((d3, i2) => Object.fromEntries(Object.entries(labelStyle).map(([key2, value2]) => [
    key2,
    typeof value2 === "function" ? value2(d3, i2) : value2
  ])));
  const labelBBoxes = labels.map((d3, i2) => {
    const normalizeStyle = labelStyles[i2];
    return computeLabelSize(d3, normalizeStyle);
  });
  const hasTransform = labelStyles.some((d3) => d3.transform);
  if (!hasTransform) {
    const I = labels.map((_, i2) => i2);
    component.indexBBox = new Map(I.map((i2) => [i2, [labels[i2], labelBBoxes[i2]]]));
  }
  return labelBBoxes;
}
function computeTitleBBox(component) {
  const isFalsy = (x2) => x2 === false || x2 === null;
  const { title } = component, style = __rest68(component, ["title"]);
  if (isFalsy(title) || title === void 0)
    return null;
  const titleStyle = subObject(style, "title");
  const { direction: direction2, transform: transform2 } = titleStyle;
  const titleText = Array.isArray(title) ? title.join(",") : title;
  if (typeof titleText !== "string")
    return null;
  const titleBBox = computeLabelSize(titleText, Object.assign(Object.assign({}, titleStyle), { transform: transform2 || (direction2 === "vertical" ? "rotate(-90)" : "") }));
  return titleBBox;
}
function styleOf(axis, position, theme) {
  const { title } = axis;
  const [defaultTitle, specifiedTitle] = Array.isArray(title) ? [title, void 0] : [void 0, title];
  const {
    axis: baseStyle,
    // @ts-ignore
    [`axis${capitalizeFirst(position)}`]: positionStyle
  } = theme;
  return deep_mix_default({ title: defaultTitle }, baseStyle, positionStyle, Object.assign(Object.assign({}, axis), { title: specifiedTitle }));
}
function ticksOf2(scale4, tickFilter) {
  const ticks2 = scale4.getTicks ? scale4.getTicks() : scale4.getOptions().domain;
  if (!tickFilter)
    return ticks2;
  return ticks2.filter(tickFilter);
}
function labelsOf(scale4, labelFormatter, tickFilter) {
  const T2 = ticksOf2(scale4, tickFilter);
  const ticks2 = T2.map((d3) => typeof d3 === "number" ? prettyNumber2(d3) : d3);
  const formatter = labelFormatter ? typeof labelFormatter === "string" ? format2(labelFormatter) : labelFormatter : scale4.getFormatter ? scale4.getFormatter() : (d3) => `${d3}`;
  return ticks2.map(formatter);
}
function offsetOf(scale4, d3) {
  if (!scale4.getBandWidth)
    return 0;
  const offset2 = scale4.getBandWidth(d3) / 2;
  return offset2;
}
function overflowX(scale4, labelBBoxes, crossSize, crossPadding, tickFilter) {
  const totalSize = sum(labelBBoxes, (d3) => d3.width);
  if (totalSize > crossSize)
    return true;
  const scaleX = scale4.clone();
  scaleX.update({ range: [0, crossSize] });
  const ticks2 = ticksOf2(scale4, tickFilter);
  const X = ticks2.map((d3) => scaleX.map(d3) + offsetOf(scaleX, d3));
  const I = ticks2.map((_, i2) => i2);
  const startX = -crossPadding[0];
  const endX = crossSize + crossPadding[1];
  const extent2 = (x2, bbox) => {
    const { width } = bbox;
    return [x2 - width / 2, x2 + width / 2];
  };
  for (let i2 = 0; i2 < I.length; i2++) {
    const x2 = X[i2];
    const [x05, x12] = extent2(x2, labelBBoxes[i2]);
    if (x05 < startX || x12 > endX)
      return true;
    const y3 = X[i2 + 1];
    if (y3) {
      const [y05] = extent2(y3, labelBBoxes[i2 + 1]);
      if (x12 > y05)
        return true;
    }
  }
  return false;
}
function computeLabelSize(d3, style) {
  const shape24 = normalizeLabel(d3);
  const { filter: filter2 } = style, rest = __rest68(style, ["filter"]);
  shape24.attr(Object.assign(Object.assign({}, rest), { visibility: "none" }));
  const bbox = shape24.getBBox();
  return bbox;
}
function normalizeLabel(d3) {
  if (d3 instanceof DisplayObject)
    return d3;
  return new Text({ style: { text: `${d3}` } });
}

// node_modules/@antv/g2/esm/runtime/layout.js
var DEFAULT_MARGIN = 16;
function processAxisZ(components) {
  const axisX = components.find(({ type }) => type === "axisX");
  const axisY = components.find(({ type }) => type === "axisY");
  const axisZ = components.find(({ type }) => type === "axisZ");
  if (axisX && axisY && axisZ) {
    axisX.plane = "xy";
    axisY.plane = "xy";
    axisZ.plane = "yz";
    axisZ.origin = [axisX.bbox.x, axisX.bbox.y, 0];
    axisZ.eulerAngles = [0, -90, 0];
    axisZ.bbox.x = axisX.bbox.x;
    axisZ.bbox.y = axisX.bbox.y;
    components.push(Object.assign(Object.assign({}, axisX), { plane: "xz", showLabel: false, showTitle: false, origin: [axisX.bbox.x, axisX.bbox.y, 0], eulerAngles: [-90, 0, 0] }));
    components.push(Object.assign(Object.assign({}, axisY), { plane: "yz", showLabel: false, showTitle: false, origin: [axisY.bbox.x + axisY.bbox.width, axisY.bbox.y, 0], eulerAngles: [0, -90, 0] }));
    components.push(Object.assign(Object.assign({}, axisZ), { plane: "xz", actualPosition: "left", showLabel: false, showTitle: false, eulerAngles: [90, -90, 0] }));
  }
}
function computeLayout(components, options, theme, library3) {
  var _a, _b, _c, _d;
  const { width, height, depth, x: x2 = 0, y: y3 = 0, z = 0, inset = (_a = theme.inset) !== null && _a !== void 0 ? _a : 0, insetLeft = inset, insetTop = inset, insetBottom = inset, insetRight = inset, margin = (_b = theme.margin) !== null && _b !== void 0 ? _b : 0, marginLeft = margin, marginBottom = margin, marginTop = margin, marginRight = margin, padding = theme.padding, paddingBottom = padding, paddingLeft = padding, paddingRight = padding, paddingTop = padding } = computeInset(components, options, theme, library3);
  const isDefaultLayoutLeft = marginLeft === DEFAULT_MARGIN && paddingLeft === "auto";
  const isDefaultLayoutRight = marginRight === DEFAULT_MARGIN && paddingRight === "auto";
  const isTranspose3 = get_default(options, "coordinates", []).some((t) => t.type === "transpose");
  const axisX = components.find(({ type }) => type === "axisX");
  const { size: size4, labelTransform } = axisX || {};
  const MIN_CONTENT_RATIO = 1 / 4;
  const maybeClamp = (viewWidth2, paddingLeft2, paddingRight2, pl02, pr02) => {
    const { marks } = options;
    if (marks.length === 0)
      return [pl02, pr02];
    const contentSize = viewWidth2 - pl02 - pr02;
    const diff = contentSize - viewWidth2 * MIN_CONTENT_RATIO;
    if (diff > 0)
      return [pl02, pr02];
    const shrinkSize = viewWidth2 * (1 - MIN_CONTENT_RATIO);
    return [
      paddingLeft2 === "auto" ? shrinkSize * pl02 / (pl02 + pr02) : pl02,
      paddingRight2 === "auto" ? shrinkSize * pr02 / (pl02 + pr02) : pr02
    ];
  };
  const roughPadding = (padding2) => padding2 === "auto" ? 20 : padding2 !== null && padding2 !== void 0 ? padding2 : 20;
  const rpt = roughPadding(paddingTop);
  const rpb = roughPadding(paddingBottom);
  const horizontalPadding = computePadding(components, height - rpt - rpb, [rpt + marginTop, rpb + marginBottom], ["left", "right"], options, theme, library3);
  const { paddingLeft: pl0, paddingRight: pr0 } = horizontalPadding;
  const viewWidth = width - marginLeft - marginRight;
  let [pl, pr] = maybeClamp(viewWidth, paddingLeft, paddingRight, pl0, pr0);
  let iw = viewWidth - pl - pr;
  const verticalPadding = computePadding(components, iw, [pl + marginLeft, pr + marginRight], ["bottom", "top"], options, theme, library3);
  const { paddingTop: pt0, paddingBottom: pb0 } = verticalPadding;
  const viewHeight = height - marginBottom - marginTop;
  const [pb, pt] = maybeClamp(viewHeight, paddingBottom, paddingTop, pb0, pt0);
  const ih = viewHeight - pb - pt;
  if (size4 && !isTranspose3 && !labelTransform) {
    const { fontSize = 12, fontFamily = "sans-serif", scales = [] } = axisX;
    const domain = (_d = (_c = scales === null || scales === void 0 ? void 0 : scales[0]) === null || _c === void 0 ? void 0 : _c.domain) !== null && _d !== void 0 ? _d : [];
    if (!domain.length)
      return;
    const adjustSide = (side, labelText, margin2, padding2) => {
      const labelWidth = measureTextWidth(labelText, { fontSize, fontFamily });
      const diff = labelWidth / 2 - margin2 - padding2;
      if (diff > 0) {
        iw -= diff;
        if (side === "left")
          pl += labelWidth / 2 - margin2;
        else
          pr += labelWidth / 2 - margin2;
      }
    };
    if (isDefaultLayoutLeft) {
      adjustSide("left", head(domain), marginLeft, pl);
    }
    if (isDefaultLayoutRight) {
      adjustSide("right", last(domain), marginRight, pr);
    }
  }
  return {
    width,
    height,
    depth,
    insetLeft,
    insetTop,
    insetBottom,
    insetRight,
    innerWidth: iw,
    innerHeight: ih,
    paddingLeft: pl,
    paddingRight: pr,
    paddingTop: pt,
    paddingBottom: pb,
    marginLeft,
    marginBottom,
    marginTop,
    marginRight,
    x: x2,
    y: y3,
    z
  };
}
function computeRoughPlotSize(options) {
  const { height, width, padding = 0, paddingLeft = padding, paddingRight = padding, paddingTop = padding, paddingBottom = padding, margin = 16, marginLeft = margin, marginRight = margin, marginTop = margin, marginBottom = margin, inset = 0, insetLeft = inset, insetRight = inset, insetTop = inset, insetBottom = inset } = options;
  const maybeAuto = (padding2) => padding2 === "auto" ? 20 : padding2;
  const finalWidth = width - maybeAuto(paddingLeft) - maybeAuto(paddingRight) - marginLeft - marginRight - insetLeft - insetRight;
  const finalHeight = height - maybeAuto(paddingTop) - maybeAuto(paddingBottom) - marginTop - marginBottom - insetTop - insetBottom;
  return { width: finalWidth, height: finalHeight };
}
function computeInset(components, options, theme, library3) {
  const { coordinates } = options;
  if (!isPolar2(coordinates) && !isRadial2(coordinates)) {
    return options;
  }
  const axes = components.filter((d3) => typeof d3.type === "string" && d3.type.startsWith("axis"));
  if (axes.length === 0)
    return options;
  const styles = axes.map((component) => {
    const key = component.type === "axisArc" ? "arc" : "linear";
    return styleOf(component, key, theme);
  });
  const maxLabelSpacing = max(styles, (d3) => {
    var _a;
    return (_a = d3.labelSpacing) !== null && _a !== void 0 ? _a : 0;
  });
  const labelBBoxes = axes.flatMap((component, i2) => {
    const style = styles[i2];
    const scale4 = createScale(component, library3);
    const labels = computeLabelsBBox(style, scale4);
    return labels;
  }).filter(defined);
  const size4 = max(labelBBoxes, (d3) => d3.height) + maxLabelSpacing;
  const titleBBoxes = axes.flatMap((_, i2) => {
    const style = styles[i2];
    return computeTitleBBox(style);
  }).filter((d3) => d3 !== null);
  const titleSize = titleBBoxes.length === 0 ? 0 : max(titleBBoxes, (d3) => d3.height);
  const { inset = size4, insetLeft = inset, insetBottom = inset, insetTop = inset + titleSize, insetRight = inset } = options;
  return Object.assign(Object.assign({}, options), { insetLeft, insetBottom, insetTop, insetRight });
}
function computePadding(components, crossSize, crossPadding, positions, options, theme, library3) {
  const positionComponents = group(components, (d3) => d3.position);
  const { padding = theme.padding, paddingLeft = padding, paddingRight = padding, paddingBottom = padding, paddingTop = padding } = options;
  const layout = {
    paddingBottom,
    paddingLeft,
    paddingTop,
    paddingRight
  };
  for (const position of positions) {
    const key = `padding${capitalizeFirst(camelCase(position))}`;
    const components2 = positionComponents.get(position) || [];
    const value2 = layout[key];
    const defaultSizeOf = (d3) => {
      if (d3.size === void 0)
        d3.size = d3.defaultSize;
    };
    const sizeOf3 = (d3) => {
      if (d3.type === "group") {
        d3.children.forEach(defaultSizeOf);
        d3.size = max(d3.children, (d4) => d4.size);
      } else {
        d3.size = d3.defaultSize;
      }
    };
    const autoSizeOf = (d3) => {
      if (d3.size)
        return;
      if (value2 !== "auto")
        sizeOf3(d3);
      else {
        computeComponentSize(d3, crossSize, crossPadding, position, theme, library3);
        defaultSizeOf(d3);
      }
    };
    const maybeHide = (d3) => {
      if (!d3.type.startsWith("axis"))
        return;
      if (d3.labelAutoHide === void 0)
        d3.labelAutoHide = true;
    };
    const isHorizontal2 = position === "bottom" || position === "top";
    const minOrder = min(components2, (d3) => d3.order);
    const axes = components2.filter((d3) => d3.type.startsWith("axis") && d3.order == minOrder);
    if (axes.length)
      axes[0].crossPadding = 0;
    if (typeof value2 === "number") {
      components2.forEach(defaultSizeOf);
      components2.forEach(maybeHide);
    } else {
      if (components2.length === 0) {
        layout[key] = 0;
      } else {
        const size4 = isHorizontal2 ? crossSize + crossPadding[0] + crossPadding[1] : crossSize;
        const grouped = groupComponents(components2, size4);
        grouped.forEach(autoSizeOf);
        const totalSize = grouped.reduce((sum4, { size: size5, crossPadding: crossPadding2 = 12 }) => sum4 + size5 + crossPadding2, 0);
        layout[key] = totalSize;
      }
    }
  }
  return layout;
}
function placeComponents(components, coordinate, layout) {
  const positionComponents = group(components, (d3) => `${d3.plane || "xy"}-${d3.position}`);
  const { paddingLeft, paddingRight, paddingTop, paddingBottom, marginLeft, marginTop, marginBottom, marginRight, innerHeight, innerWidth, insetBottom, insetLeft, insetRight, insetTop, height, width, depth } = layout;
  const planes = {
    xy: createSection({
      width,
      height,
      paddingLeft,
      paddingRight,
      paddingTop,
      paddingBottom,
      marginLeft,
      marginTop,
      marginBottom,
      marginRight,
      innerHeight,
      innerWidth,
      insetBottom,
      insetLeft,
      insetRight,
      insetTop
    }),
    yz: createSection({
      width: depth,
      height,
      paddingLeft: 0,
      paddingRight: 0,
      paddingTop: 0,
      paddingBottom: 0,
      marginLeft: 0,
      marginTop: 0,
      marginBottom: 0,
      marginRight: 0,
      innerWidth: depth,
      innerHeight: height,
      insetBottom: 0,
      insetLeft: 0,
      insetRight: 0,
      insetTop: 0
    }),
    xz: createSection({
      width,
      height: depth,
      paddingLeft: 0,
      paddingRight: 0,
      paddingTop: 0,
      paddingBottom: 0,
      marginLeft: 0,
      marginTop: 0,
      marginBottom: 0,
      marginRight: 0,
      innerWidth: width,
      innerHeight: depth,
      insetBottom: 0,
      insetLeft: 0,
      insetRight: 0,
      insetTop: 0
    })
  };
  for (const [key, components2] of positionComponents.entries()) {
    const [plane, position] = key.split("-");
    const area2 = planes[plane][position];
    const [nonEntityComponents, entityComponents] = divide(components2, (component) => {
      if (typeof component.type !== "string")
        return false;
      if (position === "center")
        return true;
      if (component.type.startsWith("axis") && ["inner", "outer"].includes(position)) {
        return true;
      }
      return false;
    });
    if (nonEntityComponents.length) {
      placeNonEntityComponents(nonEntityComponents, coordinate, area2, position);
    }
    if (entityComponents.length) {
      placePaddingArea(components2, coordinate, area2);
    }
  }
}
function createSection({ width, height, paddingLeft, paddingRight, paddingTop, paddingBottom, marginLeft, marginTop, marginBottom, marginRight, innerHeight, innerWidth, insetBottom, insetLeft, insetRight, insetTop }) {
  const pl = paddingLeft + marginLeft;
  const pt = paddingTop + marginTop;
  const pr = paddingRight + marginRight;
  const pb = paddingBottom + marginBottom;
  const plotWidth = width - marginLeft - marginRight;
  const centerSection = [
    pl + insetLeft,
    pt + insetTop,
    innerWidth - insetLeft - insetRight,
    innerHeight - insetTop - insetBottom,
    "center",
    null,
    null
  ];
  const xySection = {
    top: [
      pl,
      0,
      innerWidth,
      pt,
      "vertical",
      true,
      ascending,
      marginLeft,
      plotWidth
    ],
    right: [width - pr, pt, pr, innerHeight, "horizontal", false, ascending],
    bottom: [
      pl,
      height - pb,
      innerWidth,
      pb,
      "vertical",
      false,
      ascending,
      marginLeft,
      plotWidth
    ],
    left: [0, pt, pl, innerHeight, "horizontal", true, ascending],
    "top-left": [pl, 0, innerWidth, pt, "vertical", true, ascending],
    "top-right": [pl, 0, innerWidth, pt, "vertical", true, ascending],
    "bottom-left": [
      pl,
      height - pb,
      innerWidth,
      pb,
      "vertical",
      false,
      ascending
    ],
    "bottom-right": [
      pl,
      height - pb,
      innerWidth,
      pb,
      "vertical",
      false,
      ascending
    ],
    center: centerSection,
    inner: centerSection,
    outer: centerSection
  };
  return xySection;
}
function placeNonEntityComponents(components, coordinate, area2, position) {
  const [axisComponents, nonAxisComponents] = divide(components, (component) => {
    if (typeof component.type === "string" && component.type.startsWith("axis")) {
      return true;
    }
    return false;
  });
  placeNonEntityAxis(axisComponents, coordinate, area2, position);
  placeCenter(nonAxisComponents, coordinate, area2);
}
function placeNonEntityAxis(components, coordinate, area2, position) {
  if (position === "center") {
    if (isRadar(coordinate)) {
      placeAxisRadar(components, coordinate, area2, position);
    } else if (isPolar(coordinate)) {
      placeArcLinear(components, coordinate, area2);
    } else if (isParallel(coordinate)) {
      placeAxisParallel(components, coordinate, area2, components[0].orientation);
    }
  } else if (position === "inner") {
    placeAxisArcInner(components, coordinate, area2);
  } else if (position === "outer") {
    placeAxisArcOuter(components, coordinate, area2);
  }
}
function placeAxisArcInner(components, coordinate, area2) {
  const [x2, y3, , height] = area2;
  const [cx, cy] = coordinate.getCenter();
  const [innerRadius] = radiusOf(coordinate);
  const r2 = height / 2;
  const size4 = innerRadius * r2;
  const x05 = cx - size4;
  const y05 = cy - size4;
  for (let i2 = 0; i2 < components.length; i2++) {
    const component = components[i2];
    component.bbox = {
      x: x2 + x05,
      y: y3 + y05,
      width: size4 * 2,
      height: size4 * 2
    };
  }
}
function placeAxisArcOuter(components, coordinate, area2) {
  const [x2, y3, width, height] = area2;
  for (const component of components) {
    component.bbox = { x: x2, y: y3, width, height };
  }
}
function placeArcLinear(components, coordinate, area2) {
  const [x2, y3, width, height] = area2;
  for (const component of components) {
    component.bbox = { x: x2, y: y3, width, height };
  }
}
function placeAxisParallel(components, coordinate, area2, orientation) {
  if (orientation === "horizontal") {
    placeAxisParallelHorizontal(components, coordinate, area2);
  } else if (orientation === "vertical") {
    placeAxisParallelVertical(components, coordinate, area2);
  }
}
function placeAxisParallelVertical(components, coordinate, area2) {
  const [x2, y3, , height] = area2;
  const vector = new Array(components.length).fill(0);
  const points = coordinate.map(vector);
  const X = points.filter((_, i2) => i2 % 2 === 0).map((d3) => d3 + x2);
  for (let i2 = 0; i2 < components.length; i2++) {
    const component = components[i2];
    const x3 = X[i2];
    const width = X[i2 + 1] - x3;
    component.bbox = { x: x3, y: y3, width, height };
  }
}
function placeAxisParallelHorizontal(components, coordinate, area2) {
  const [x2, y3, width] = area2;
  const vector = new Array(components.length).fill(0);
  const points = coordinate.map(vector);
  const Y = points.filter((_, i2) => i2 % 2 === 1).map((d3) => d3 + y3);
  for (let i2 = 0; i2 < components.length; i2++) {
    const component = components[i2];
    const y4 = Y[i2];
    const height = Y[i2 + 1] - y4;
    component.bbox = { x: x2, y: y4, width, height };
  }
}
function placeAxisRadar(components, coordinate, area2, position) {
  const [x2, y3, width, height] = area2;
  for (const component of components) {
    component.bbox = { x: x2, y: y3, width, height };
    component.radar = {
      index: components.indexOf(component),
      count: components.length
    };
  }
}
function placePaddingArea(components, coordinate, area2) {
  const [x2, y3, width, height, direction2, reverse2, comparator, minX, totalSize] = area2;
  const [mainStartKey, mainStartValue, crossStartKey, crossStartValue, mainSizeKey, mainSizeValue, crossSizeKey, crossSizeValue] = direction2 === "vertical" ? ["y", y3, "x", x2, "height", height, "width", width] : ["x", x2, "y", y3, "width", width, "height", height];
  components.sort((a4, b) => comparator === null || comparator === void 0 ? void 0 : comparator(a4.order, b.order));
  const isLarge = (type) => type === "title" || type === "group" || type.startsWith("legend");
  const crossSizeOf = (type, small, bigger) => {
    if (bigger === void 0)
      return small;
    if (isLarge(type))
      return bigger;
    return small;
  };
  const crossStartOf = (type, x3, minX2) => {
    if (minX2 === void 0)
      return x3;
    if (isLarge(type))
      return minX2;
    return x3;
  };
  const startValue = reverse2 ? mainStartValue + mainSizeValue : mainStartValue;
  for (let i2 = 0, start = startValue; i2 < components.length; i2++) {
    const component = components[i2];
    const { crossPadding = 0, type } = component;
    const { size: size4 } = component;
    component.bbox = {
      [mainStartKey]: reverse2 ? start - size4 - crossPadding : start + crossPadding,
      [crossStartKey]: crossStartOf(type, crossStartValue, minX),
      [mainSizeKey]: size4,
      [crossSizeKey]: crossSizeOf(type, crossSizeValue, totalSize)
    };
    start += (size4 + crossPadding) * (reverse2 ? -1 : 1);
  }
  const groupComponents2 = components.filter((d3) => d3.type === "group");
  for (const group2 of groupComponents2) {
    const { bbox, children } = group2;
    const size4 = bbox[crossSizeKey];
    const step = size4 / children.length;
    const justifyContent = children.reduce((j, child) => {
      var _a;
      const j0 = (_a = child.layout) === null || _a === void 0 ? void 0 : _a.justifyContent;
      return j0 ? j0 : j;
    }, "flex-start");
    const L = children.map((d3, i2) => {
      const { length = step, padding = 0 } = d3;
      return length + (i2 === children.length - 1 ? 0 : padding);
    });
    const totalLength = sum(L);
    const diff = size4 - totalLength;
    const offset2 = justifyContent === "flex-start" ? 0 : justifyContent === "center" ? diff / 2 : diff;
    for (let i2 = 0, start = bbox[crossStartKey] + offset2; i2 < children.length; i2++) {
      const component = children[i2];
      const { padding = 0 } = component;
      const interval = i2 === children.length - 1 ? 0 : padding;
      component.bbox = {
        [mainSizeKey]: bbox[mainSizeKey],
        [mainStartKey]: bbox[mainStartKey],
        [crossStartKey]: start,
        [crossSizeKey]: L[i2] - interval
      };
      deep_mix_default(component, { layout: { justifyContent } });
      start += L[i2];
    }
  }
}
function placeCenter(components, coordinate, area2) {
  if (components.length === 0)
    return;
  const [x2, y3, width, height] = area2;
  const [innerRadius] = radiusOf(coordinate);
  const r2 = height / 2 * innerRadius / Math.sqrt(2);
  const cx = x2 + width / 2;
  const cy = y3 + height / 2;
  for (let i2 = 0; i2 < components.length; i2++) {
    const component = components[i2];
    component.bbox = { x: cx - r2, y: cy - r2, width: r2 * 2, height: r2 * 2 };
  }
}

// node_modules/@antv/g2/esm/runtime/transform.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest69 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var CALLBACK_ITEM_SYMBOL = Symbol("CALLBACK_ITEM");
function applyDefaults(I, mark2, context) {
  const { encode = {}, scale: scale4 = {}, transform: transform2 = [] } = mark2, rest = __rest69(mark2, ["encode", "scale", "transform"]);
  return [I, Object.assign(Object.assign({}, rest), { encode, scale: scale4, transform: transform2 })];
}
function applyDataTransform(I, mark2, context) {
  return __awaiter4(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const { data } = mark2;
    const [useData] = useLibrary("data", library3);
    const descriptor = normalizedDataSource(data);
    const { transform: T2 = [] } = descriptor, connector = __rest69(descriptor, ["transform"]);
    const transform2 = [connector, ...T2];
    const transformFunctions = transform2.map((t) => useData(t, context));
    const transformedData = yield composeAsync(transformFunctions)(data);
    const newData = data && !Array.isArray(data) && !Array.isArray(transformedData) ? { value: transformedData } : transformedData;
    return [
      Array.isArray(transformedData) ? indexOf(transformedData) : [],
      Object.assign(Object.assign({}, mark2), { data: newData })
    ];
  });
}
function flatEncode(I, mark2, context) {
  const { encode } = mark2;
  if (!encode)
    return [I, mark2];
  const flattenEncode = {};
  for (const [key, value2] of Object.entries(encode)) {
    if (Array.isArray(value2)) {
      for (let i2 = 0; i2 < value2.length; i2++) {
        const name2 = `${key}${i2 === 0 ? "" : i2}`;
        flattenEncode[name2] = value2[i2];
      }
    } else {
      flattenEncode[key] = value2;
    }
  }
  return [I, Object.assign(Object.assign({}, mark2), { encode: flattenEncode })];
}
function inferChannelsType(I, mark2, context) {
  const { encode, data } = mark2;
  if (!encode)
    return [I, mark2];
  const typedEncode = mapObject(encode, (channel) => {
    if (isTypedChannel(channel))
      return channel;
    const type = inferChannelType(data, channel);
    return { type, value: channel };
  });
  return [I, Object.assign(Object.assign({}, mark2), { encode: typedEncode })];
}
function maybeVisualChannel(I, mark2, context) {
  const { encode } = mark2;
  if (!encode)
    return [I, mark2];
  const newEncode = mapObject(encode, (channel, name2) => {
    const { type } = channel;
    if (type !== "constant" || isPosition(name2))
      return channel;
    return Object.assign(Object.assign({}, channel), { constant: true });
  });
  return [I, Object.assign(Object.assign({}, mark2), { encode: newEncode })];
}
function extractColumns(I, mark2, context) {
  const { encode, data } = mark2;
  if (!encode)
    return [I, mark2];
  const { library: library3 } = context;
  const columnOf2 = createColumnOf(library3);
  const valuedEncode = mapObject(encode, (channel) => columnOf2(data, channel));
  return [I, Object.assign(Object.assign({}, mark2), { encode: valuedEncode })];
}
function normalizeTooltip(I, mark2, context) {
  const { tooltip: tooltip2 = {} } = mark2;
  if (isUnset(tooltip2))
    return [I, mark2];
  if (Array.isArray(tooltip2)) {
    return [I, Object.assign(Object.assign({}, mark2), { tooltip: { items: tooltip2 } })];
  }
  if (isStrictObject(tooltip2) && isFullTooltip(tooltip2)) {
    return [I, Object.assign(Object.assign({}, mark2), { tooltip: tooltip2 })];
  }
  return [I, Object.assign(Object.assign({}, mark2), { tooltip: { items: [tooltip2] } })];
}
function extractTooltip(I, mark2, context) {
  const { data, encode, tooltip: tooltip2 = {} } = mark2;
  if (isUnset(tooltip2))
    return [I, mark2];
  const valueOf4 = (item) => {
    if (!item)
      return item;
    if (typeof item === "string") {
      return I.map((i2) => ({ name: item, value: data[i2][item] }));
    }
    if (isStrictObject(item)) {
      const { field: field3, channel, color, name: name2 = field3, valueFormatter = (d3) => d3 } = item;
      const normalizedValueFormatter = typeof valueFormatter === "string" ? format2(valueFormatter) : valueFormatter;
      const definedChannel = channel && encode[channel];
      const channelField = definedChannel && encode[channel].field;
      const name1 = name2 || channelField || channel;
      const values4 = [];
      for (const i2 of I) {
        const value1 = field3 ? data[i2][field3] : definedChannel ? encode[channel].value[i2] : null;
        values4[i2] = {
          name: name1,
          color,
          value: normalizedValueFormatter(value1)
        };
      }
      return values4;
    }
    if (typeof item === "function") {
      const values4 = [];
      for (const i2 of I) {
        const v = item(data[i2], i2, data, encode);
        if (isStrictObject(v))
          values4[i2] = Object.assign(Object.assign({}, v), { [CALLBACK_ITEM_SYMBOL]: true });
        else
          values4[i2] = { value: v };
      }
      return values4;
    }
    return item;
  };
  const { title, items = [] } = tooltip2, rest = __rest69(tooltip2, ["title", "items"]);
  const newTooltip = Object.assign({ title: valueOf4(title), items: Array.isArray(items) ? items.map(valueOf4) : [] }, rest);
  return [I, Object.assign(Object.assign({}, mark2), { tooltip: newTooltip })];
}
function maybeArrayField(I, mark2, context) {
  const { encode } = mark2, rest = __rest69(mark2, ["encode"]);
  if (!encode)
    return [I, mark2];
  const columns = Object.entries(encode);
  const arrayColumns = columns.filter(([, channel]) => {
    const { value: V } = channel;
    return Array.isArray(V[0]);
  }).flatMap(([key, V]) => {
    const columns2 = [[key, new Array(I.length).fill(void 0)]];
    const { value: rows } = V, rest2 = __rest69(V, ["value"]);
    for (let i2 = 0; i2 < rows.length; i2++) {
      const row = rows[i2];
      if (Array.isArray(row)) {
        for (let j = 0; j < row.length; j++) {
          const column2 = columns2[j] || [
            `${key}${j}`,
            new Array(I).fill(void 0)
          ];
          column2[1][i2] = row[j];
          columns2[j] = column2;
        }
      }
    }
    return columns2.map(([key2, value2]) => [
      key2,
      Object.assign({ type: "column", value: value2 }, rest2)
    ]);
  });
  const newEncode = Object.fromEntries([...columns, ...arrayColumns]);
  return [I, Object.assign(Object.assign({}, rest), { encode: newEncode })];
}
function addGuideToScale(I, mark2, context) {
  const { axis = {}, legend = {}, slider = {}, scrollbar = {} } = mark2;
  const normalize5 = (guide, channel) => {
    if (typeof guide === "boolean")
      return guide ? {} : null;
    const eachGuide = guide[channel];
    return eachGuide === void 0 || eachGuide ? eachGuide : null;
  };
  const axisChannels = typeof axis === "object" ? Array.from(/* @__PURE__ */ new Set(["x", "y", "z", ...Object.keys(axis)])) : ["x", "y", "z"];
  deep_mix_default(mark2, {
    scale: Object.assign(Object.assign({}, Object.fromEntries(axisChannels.map((channel) => {
      const scrollbarOptions = normalize5(scrollbar, channel);
      return [
        channel,
        Object.assign({ guide: normalize5(axis, channel), slider: normalize5(slider, channel), scrollbar: scrollbarOptions }, scrollbarOptions && {
          ratio: scrollbarOptions.ratio === void 0 ? 0.5 : scrollbarOptions.ratio
        })
      ];
    }))), {
      color: { guide: normalize5(legend, "color") },
      size: { guide: normalize5(legend, "size") },
      shape: { guide: normalize5(legend, "shape") },
      // fixme: opacity is conflict with DisplayObject.opacity
      // to be confirm.
      opacity: { guide: normalize5(legend, "opacity") }
    })
  });
  return [I, mark2];
}
function maybeNonAnimate(I, mark2, context) {
  const { animate } = mark2;
  if (animate || animate === void 0)
    return [I, mark2];
  deep_mix_default(mark2, {
    animate: {
      enter: { type: null },
      exit: { type: null },
      update: { type: null }
    }
  });
  return [I, mark2];
}
function appendMarkScaleKey(I, mark2, context) {
  var _a, _b;
  deep_mix_default(mark2, {
    scale: {
      series: Object.assign({ key: `DEFAULT_${mark2.type}_SERIES_KEY` }, (_b = (_a = mark2 === null || mark2 === void 0 ? void 0 : mark2.scale) === null || _a === void 0 ? void 0 : _a.series) !== null && _b !== void 0 ? _b : {})
    }
  });
  return [I, mark2];
}
function isTypedChannel(channel) {
  if (typeof channel !== "object" || channel instanceof Date || channel === null) {
    return false;
  }
  const { type } = channel;
  return defined(type);
}
function inferChannelType(data, channel) {
  if (typeof channel === "function")
    return "transform";
  if (typeof channel === "string" && isField(data, channel))
    return "field";
  return "constant";
}
function isField(data, value2) {
  if (!Array.isArray(data))
    return false;
  return data.some((d3) => d3[value2] !== void 0);
}
function normalizedDataSource(data) {
  if (isNumber(data))
    return { type: "inline", value: data };
  if (!data)
    return { type: "inline", value: null };
  if (Array.isArray(data))
    return { type: "inline", value: data };
  const { type = "inline" } = data, rest = __rest69(data, ["type"]);
  return Object.assign(Object.assign({}, rest), { type });
}

// node_modules/@antv/g2/esm/runtime/mark.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest70 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function initializeMark(partialMark, partialProps, context) {
  return __awaiter5(this, void 0, void 0, function* () {
    const [I, transformedMark] = yield applyMarkTransform(partialMark, partialProps, context);
    const { encode, scale: scale4, data, tooltip: tooltip2, key: markKey } = transformedMark;
    if (Array.isArray(data) === false) {
      return null;
    }
    const { channels: channelDescriptors } = partialProps;
    const nameChannels = rollups(Object.entries(encode).filter(([, value2]) => defined(value2)), (values4) => values4.map(([key, options]) => Object.assign({ name: key }, options)), ([key]) => {
      var _a;
      const prefix = (_a = /([^\d]+)\d*$/.exec(key)) === null || _a === void 0 ? void 0 : _a[1];
      const descriptor = channelDescriptors.find((d3) => d3.name === prefix);
      if (descriptor === null || descriptor === void 0 ? void 0 : descriptor.independent)
        return key;
      return prefix;
    });
    const channels = channelDescriptors.filter((descriptor) => {
      const { name: name2, required: required2 } = descriptor;
      if (nameChannels.find(([d3]) => d3 === name2))
        return true;
      if (required2)
        throw new Error(`Missing encoding for channel: ${name2}.`);
      return false;
    }).flatMap((descriptor) => {
      const { name: name2, scale: scaleType, scaleKey, range: range3, quantitative, ordinal } = descriptor;
      const valuesArray = nameChannels.filter(([channel]) => channel.startsWith(name2));
      return valuesArray.map(([channel, values4], i2) => {
        const visual = values4.some((d3) => d3.visual);
        const constant4 = values4.some((d3) => d3.constant);
        const _a = scale4[channel] || {}, {
          independent = false,
          // Use channel name as default scale key.
          key = scaleKey || channel,
          // Visual channel use identity scale.
          type = constant4 ? "constant" : visual ? "identity" : scaleType
        } = _a, scaleOptions = __rest70(_a, ["independent", "key", "type"]);
        const isConstant = type === "constant";
        const finalRange = isConstant ? void 0 : range3;
        return {
          name: channel,
          values: values4,
          // Generate a unique key for independent channel,
          // which will not group with any other channels.
          scaleKey: independent || isConstant ? Symbol("independent") : key,
          scale: Object.assign(Object.assign({
            type,
            markKey,
            range: finalRange
          }, scaleOptions), {
            quantitative,
            ordinal
          })
        };
      });
    });
    return [transformedMark, Object.assign(Object.assign({}, partialProps), { index: I, channels, tooltip: tooltip2 })];
  });
}
function createColumnOf(library3) {
  const [useEncode] = useLibrary("encode", library3);
  return (data, encode) => {
    if (encode === void 0)
      return null;
    if (data === void 0)
      return null;
    return Object.assign(Object.assign({}, encode), { type: "column", value: useEncode(encode)(data), field: fieldOf(encode) });
  };
}
function applyMarkTransform(mark2, props, context) {
  return __awaiter5(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const [useTransform] = useLibrary("transform", library3);
    const { preInference = [], postInference = [] } = props;
    const { transform: transform2 = [] } = mark2;
    const transforms = [
      applyDefaults,
      applyDataTransform,
      flatEncode,
      inferChannelsType,
      maybeVisualChannel,
      extractColumns,
      maybeArrayField,
      maybeNonAnimate,
      addGuideToScale,
      normalizeTooltip,
      appendMarkScaleKey,
      ...preInference.map(useTransform),
      ...transform2.map(useTransform),
      ...postInference.map(useTransform),
      extractTooltip
    ];
    let index2 = [];
    let transformedMark = mark2;
    for (const t of transforms) {
      [index2, transformedMark] = yield t(index2, transformedMark, context);
    }
    return [index2, transformedMark];
  });
}
function fieldOf(encode) {
  const { type, value: value2 } = encode;
  if (type === "field" && typeof value2 === "string")
    return value2;
  return null;
}

// node_modules/@antv/g2/esm/runtime/plot.js
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest71 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function plot(options, selection, context) {
  return __awaiter6(this, void 0, void 0, function* () {
    var _a;
    const { library: library3 } = context;
    const [useComposition] = useLibrary("composition", library3);
    const [useInteraction] = useLibrary("interaction", library3);
    const marks = new Set(Object.keys(library3).map((d3) => {
      var _a2;
      return (_a2 = /mark\.(.*)/.exec(d3)) === null || _a2 === void 0 ? void 0 : _a2[1];
    }).filter(defined));
    const staticMarks = new Set(Object.keys(library3).map((d3) => {
      var _a2;
      return (_a2 = /component\.(.*)/.exec(d3)) === null || _a2 === void 0 ? void 0 : _a2[1];
    }).filter(defined));
    const typeOf = (node) => {
      const { type } = node;
      if (typeof type === "function") {
        const { props = {} } = type;
        const { composite = true } = props;
        if (composite)
          return "mark";
      }
      if (typeof type !== "string")
        return type;
      if (marks.has(type) || staticMarks.has(type))
        return "mark";
      return type;
    };
    const isMark2 = (node) => typeOf(node) === "mark";
    const isStandardView = (node) => typeOf(node) === "standardView";
    const isStaticMark = (node) => {
      const { type } = node;
      if (typeof type !== "string")
        return false;
      if (staticMarks.has(type))
        return true;
      return false;
    };
    const transform2 = (node) => {
      if (isStandardView(node))
        return [node];
      const type = typeOf(node);
      const composition = useComposition({ type, static: isStaticMark(node) });
      return composition(node);
    };
    const views = [];
    const viewNode = /* @__PURE__ */ new Map();
    const nodeState = /* @__PURE__ */ new Map();
    const discovered = [options];
    const nodeGenerators = [];
    while (discovered.length) {
      const node = discovered.shift();
      if (isStandardView(node)) {
        const state = nodeState.get(node);
        const [view, children] = state ? initializeState(state, node, library3) : yield initializeView(node, context);
        viewNode.set(view, node);
        views.push(view);
        const transformedNodes = children.flatMap(transform2).map((d3) => coordinate2Transform(d3, library3));
        discovered.push(...transformedNodes);
        if (transformedNodes.every(isStandardView)) {
          const states = yield Promise.all(transformedNodes.map((d3) => initializeMarks(d3, context)));
          syncFacetsScales(states);
          for (let i2 = 0; i2 < transformedNodes.length; i2++) {
            const nodeT = transformedNodes[i2];
            const state2 = states[i2];
            nodeState.set(nodeT, state2);
          }
        }
      } else {
        const n2 = isMark2(node) ? node : yield applyTransform(node, context);
        const N = transform2(n2);
        if (Array.isArray(N))
          discovered.push(...N);
        else if (typeof N === "function")
          nodeGenerators.push(N());
      }
    }
    context.emitter.emit(ChartEvent.BEFORE_PAINT);
    const enterContainer = /* @__PURE__ */ new Map();
    const updateContainer = /* @__PURE__ */ new Map();
    const transitions = [];
    selection.selectAll(className(VIEW_CLASS_NAME)).data(views, (d3) => d3.key).join((enter) => enter.append("g").attr("className", VIEW_CLASS_NAME).attr("id", (view) => view.key).call(applyTranslate).each(function(view, i2, element) {
      plotView(view, select(element), transitions, context);
      enterContainer.set(view, element);
    }), (update) => update.call(applyTranslate).each(function(view, i2, element) {
      plotView(view, select(element), transitions, context);
      updateContainer.set(view, element);
    }), (exit) => exit.each(function(d3, i2, element) {
      const interactions = element["nameInteraction"].values();
      for (const interaction of interactions) {
        interaction.destroy();
      }
    }).remove());
    const viewInstanceof = (viewContainer, updateInteractions2, oldStore) => {
      return Array.from(viewContainer.entries()).map(([view, container]) => {
        const store = oldStore || /* @__PURE__ */ new Map();
        const setState = (key, reducer = (x2) => x2) => store.set(key, reducer);
        const options2 = viewNode.get(view);
        const update = createUpdateView(select(container), options2, context);
        const target = {
          view,
          container,
          options: options2,
          setState,
          update: (from, updateTypes) => __awaiter6(this, void 0, void 0, function* () {
            const reducer = compose2(Array.from(store.values()));
            const newOptions = reducer(options2);
            return yield update(newOptions, from, () => {
              if (isArray(updateTypes)) {
                updateInteractions2(viewContainer, updateTypes, store);
              }
            });
          })
        };
        context.externals.update = target.update;
        context.externals.setState = setState;
        return target;
      });
    };
    const updateInteractions = (container = updateContainer, updateType, oldStore) => {
      var _a2;
      const updateViewInstances = viewInstanceof(container, updateInteractions, oldStore);
      for (const target of updateViewInstances) {
        const { options: options2, container: container2 } = target;
        const nameInteraction = container2["nameInteraction"];
        let typeOptions = inferInteraction(options2);
        if (updateType) {
          typeOptions = typeOptions.filter((v) => updateType.includes(v[0]));
        }
        for (const typeOption of typeOptions) {
          const [type, option] = typeOption;
          const prevInteraction = nameInteraction.get(type);
          if (prevInteraction)
            (_a2 = prevInteraction.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(prevInteraction);
          if (option) {
            const interaction = useThemeInteraction(target.view, type, option, useInteraction);
            const destroy2 = interaction(target, updateViewInstances, context.emitter);
            nameInteraction.set(type, { destroy: destroy2 });
          }
        }
      }
    };
    const enterViewInstances = viewInstanceof(enterContainer, updateInteractions);
    for (const target of enterViewInstances) {
      const { options: options2 } = target;
      const nameInteraction = /* @__PURE__ */ new Map();
      target.container["nameInteraction"] = nameInteraction;
      for (const typeOption of inferInteraction(options2)) {
        const [type, option] = typeOption;
        if (option) {
          const interaction = useThemeInteraction(target.view, type, option, useInteraction);
          const destroy2 = interaction(target, enterViewInstances, context.emitter);
          nameInteraction.set(type, { destroy: destroy2 });
        }
      }
    }
    updateInteractions();
    const { width, height } = options;
    const keyframes = [];
    for (const nodeGenerator of nodeGenerators) {
      const keyframe = new Promise((resolve) => __awaiter6(this, void 0, void 0, function* () {
        for (const node of nodeGenerator) {
          const sizedNode = Object.assign({ width, height }, node);
          yield plot(sizedNode, selection, context);
        }
        resolve();
      }));
      keyframes.push(keyframe);
    }
    context.views = views;
    (_a = context.animations) === null || _a === void 0 ? void 0 : _a.forEach((animation) => animation === null || animation === void 0 ? void 0 : animation.cancel());
    context.animations = transitions;
    context.emitter.emit(ChartEvent.AFTER_PAINT);
    const finished = transitions.filter(defined).map(cancel).map((d3) => d3.finished);
    return Promise.all([...finished, ...keyframes]);
  });
}
function applyTranslate(selection) {
  selection.style("transform", (d3) => `translate(${d3.layout.x}, ${d3.layout.y})`);
}
function definedInteraction(library3) {
  const [, createInteraction] = useLibrary("interaction", library3);
  return (d3) => {
    const [name2, options] = d3;
    try {
      return [name2, createInteraction(name2)];
    } catch (_a) {
      return [name2, options.type];
    }
  };
}
function createUpdateView(selection, options, context) {
  const { library: library3 } = context;
  const createDefinedInteraction = definedInteraction(library3);
  const filter2 = (d3) => d3[1] && d3[1].props && d3[1].props.reapplyWhenUpdate;
  const interactions = inferInteraction(options);
  const updates = interactions.map(createDefinedInteraction).filter(filter2).map((d3) => d3[0]);
  return (newOptions, source, callback) => __awaiter6(this, void 0, void 0, function* () {
    const transitions = [];
    const [newView, newChildren] = yield initializeView(newOptions, context);
    plotView(newView, selection, transitions, context);
    for (const name2 of updates.filter((d3) => d3 !== source)) {
      updateInteraction(name2, selection, newOptions, newView, context);
    }
    for (const child of newChildren) {
      plot(child, selection, context);
    }
    callback();
    return { options: newOptions, view: newView };
  });
}
function updateInteraction(name2, selection, options, view, context) {
  var _a;
  const { library: library3 } = context;
  const [useInteraction] = useLibrary("interaction", library3);
  const container = selection.node();
  const nameInteraction = container["nameInteraction"];
  const interactionOptions = inferInteraction(options).find(([d3]) => d3 === name2);
  const interaction = nameInteraction.get(name2);
  if (!interaction)
    return;
  (_a = interaction.destroy) === null || _a === void 0 ? void 0 : _a.call(interaction);
  if (!interactionOptions[1])
    return;
  const applyInteraction = useThemeInteraction(view, name2, interactionOptions[1], useInteraction);
  const target = {
    options,
    view,
    container: selection.node(),
    update: (options2) => Promise.resolve(options2)
  };
  const destroy2 = applyInteraction(target, [], context.emitter);
  nameInteraction.set(name2, { destroy: destroy2 });
}
function initializeView(options, context) {
  return __awaiter6(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const flattenOptions = yield transformMarks(options, context);
    const mergedOptions = bubbleOptions(flattenOptions);
    options.interaction = mergedOptions.interaction;
    options.coordinate = mergedOptions.coordinate;
    options.marks = [...mergedOptions.marks, ...mergedOptions.components];
    const transformedOptions = coordinate2Transform(mergedOptions, library3);
    const state = yield initializeMarks(transformedOptions, context);
    return initializeState(state, transformedOptions, library3);
  });
}
function bubbleOptions(options) {
  const { coordinate: viewCoordinate = {}, interaction: viewInteraction = {}, style: viewStyle = {}, marks } = options, rest = __rest71(options, ["coordinate", "interaction", "style", "marks"]);
  const markCoordinates = marks.map((d3) => d3.coordinate || {});
  const markInteractions = marks.map((d3) => d3.interaction || {});
  const markViewStyles = marks.map((d3) => d3.viewStyle || {});
  const newCoordinate = [...markCoordinates, viewCoordinate].reduceRight((prev, cur) => deep_mix_default(prev, cur), {});
  const newInteraction = [viewInteraction, ...markInteractions].reduce((prev, cur) => deep_mix_default(prev, cur), {});
  const newStyle = [...markViewStyles, viewStyle].reduce((prev, cur) => deep_mix_default(prev, cur), {});
  return Object.assign(Object.assign({}, rest), { marks, coordinate: newCoordinate, interaction: newInteraction, style: newStyle });
}
function transformMarks(options, context) {
  return __awaiter6(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const [useMark, createMark] = useLibrary("mark", library3);
    const staticMarks = new Set(Object.keys(library3).map((d3) => {
      var _a;
      return (_a = /component\.(.*)/.exec(d3)) === null || _a === void 0 ? void 0 : _a[1];
    }).filter(defined));
    const { marks } = options;
    const flattenMarks = [];
    const components = [];
    const discovered = [...marks];
    const { width, height } = computeRoughPlotSize(options);
    const markOptions = { options, width, height };
    while (discovered.length) {
      const [node] = discovered.splice(0, 1);
      const mark2 = yield applyTransform(node, context);
      const { type = error("G2Mark type is required."), key } = mark2;
      if (staticMarks.has(type))
        components.push(mark2);
      else {
        const { props = {} } = createMark(type);
        const { composite = true } = props;
        if (!composite)
          flattenMarks.push(mark2);
        else {
          const { data } = mark2;
          const newMark = Object.assign(Object.assign({}, mark2), { data: data ? Array.isArray(data) ? data : data.value : data });
          const marks2 = yield useMark(newMark, markOptions);
          const M2 = Array.isArray(marks2) ? marks2 : [marks2];
          discovered.unshift(...M2.map((d3, i2) => Object.assign(Object.assign({}, d3), { key: `${key}-${i2}` })));
        }
      }
    }
    return Object.assign(Object.assign({}, options), { marks: flattenMarks, components });
  });
}
function initializeMarks(options, context) {
  return __awaiter6(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const [useTheme] = useLibrary("theme", library3);
    const [, createMark] = useLibrary("mark", library3);
    const { theme: partialTheme, marks: partialMarks, coordinates = [] } = options;
    const theme = useTheme(inferTheme(partialTheme));
    const markState = /* @__PURE__ */ new Map();
    for (const markOptions of partialMarks) {
      const { type } = markOptions;
      const { props = {} } = createMark(type);
      const markAndState = yield initializeMark(markOptions, props, context);
      if (markAndState) {
        const [initializedMark, state] = markAndState;
        markState.set(initializedMark, state);
      }
    }
    const scaleChannels = group(Array.from(markState.values()).flatMap((d3) => d3.channels), ({ scaleKey }) => scaleKey);
    for (const channels of scaleChannels.values()) {
      const scaleOptions = channels.reduce((total, { scale: scale5 }) => deep_mix_default(total, scale5), {});
      const { scaleKey } = channels[0];
      const { values: FV } = channels[0];
      const fields = Array.from(new Set(FV.map((d3) => d3.field).filter(defined)));
      const options2 = deep_mix_default({
        guide: { title: fields.length === 0 ? void 0 : fields },
        field: fields[0]
      }, scaleOptions);
      const { name: name2 } = channels[0];
      const values4 = channels.flatMap(({ values: values5 }) => values5.map((d3) => d3.value));
      const scale4 = Object.assign(Object.assign({}, inferScale(name2, values4, options2, coordinates, theme, library3)), { uid: Symbol("scale"), key: scaleKey });
      channels.forEach((channel) => channel.scale = scale4);
    }
    return markState;
  });
}
function useThemeInteraction(view, type, option, useInteraction) {
  const theme = view.theme;
  const defaults4 = typeof type === "string" ? theme[type] || {} : {};
  const interaction = useInteraction(deep_mix_default(defaults4, Object.assign({ type }, option)));
  return interaction;
}
function initializeState(markState, options, library3) {
  var _a;
  const [useMark] = useLibrary("mark", library3);
  const [useTheme] = useLibrary("theme", library3);
  const [useLabelTransform] = useLibrary("labelTransform", library3);
  const { key, frame = false, theme: partialTheme, clip, style = {}, labelTransform = [] } = options;
  const theme = useTheme(inferTheme(partialTheme));
  const states = Array.from(markState.values());
  const scales = collectScales(states, options);
  const components = normalizeComponents(inferComponent(inferComponentScales(Array.from(scales), states, markState), options, library3));
  const layout = computeLayout(components, options, theme, library3);
  const coordinate = createCoordinate(layout, options, library3);
  const framedStyle = frame ? deep_mix_default({ mainLineWidth: 1, mainStroke: "#000" }, style) : style;
  placeComponents(groupComponents(components), coordinate, layout);
  processAxisZ(components);
  const uidScale = new Map(Array.from(markState.values()).flatMap((state) => {
    const { channels } = state;
    return channels.map(({ scale: scale4 }) => [
      scale4.uid,
      useRelationScale(scale4, library3)
    ]);
  }));
  groupTransform(markState, uidScale);
  const scaleInstance = {};
  for (const component of components) {
    const { scales: scaleDescriptors = [] } = component;
    const scales2 = [];
    for (const descriptor of scaleDescriptors) {
      const { name: name2, uid } = descriptor;
      const scale4 = (_a = uidScale.get(uid)) !== null && _a !== void 0 ? _a : useRelationScale(descriptor, library3);
      scales2.push(scale4);
      if (name2 === "y") {
        scale4.update(Object.assign(Object.assign({}, scale4.getOptions()), { xScale: scaleInstance.x }));
      }
      assignScale(scaleInstance, { [name2]: scale4 });
    }
    component.scaleInstances = scales2;
  }
  const children = [];
  const dataMap = /* @__PURE__ */ new Map();
  for (const [mark2, state] of markState.entries()) {
    const {
      // scale,
      // Callback to create children options based on this mark.
      children: createChildren,
      // The total count of data (both show and hide)for this facet.
      // This is for unit visualization to sync data domain.
      dataDomain,
      modifier,
      key: markKey,
      data
    } = mark2;
    dataMap.set(markKey, data);
    const { index: index2, channels, tooltip: tooltip2 } = state;
    const scale4 = Object.fromEntries(channels.map(({ name: name2, scale: scale5 }) => [name2, scale5]));
    const markScaleInstance = mapObject(scale4, ({ uid }) => uidScale.get(uid));
    assignScale(scaleInstance, markScaleInstance);
    const value2 = applyScale(channels, markScaleInstance);
    const calcPoints = useMark(mark2);
    const [I, P, S] = filterValid(calcPoints(index2, markScaleInstance, value2, coordinate));
    const count4 = dataDomain || I.length;
    const T2 = modifier ? modifier(P, count4, layout) : [];
    const titleOf = (i2) => {
      var _a2, _b;
      return (_b = (_a2 = tooltip2.title) === null || _a2 === void 0 ? void 0 : _a2[i2]) === null || _b === void 0 ? void 0 : _b.value;
    };
    const itemsOf2 = (i2) => tooltip2.items.map((V) => V[i2]);
    const visualData = I.map((d3, i2) => {
      const datum = Object.assign({ points: P[i2], transform: T2[i2], index: d3, markKey, viewKey: key, data: data[d3] }, tooltip2 && {
        title: titleOf(d3),
        items: itemsOf2(d3)
      });
      for (const [k2, V] of Object.entries(value2)) {
        datum[k2] = V[d3];
        if (S)
          datum[`series${upper_first_default(k2)}`] = S[i2].map((i3) => V[i3]);
      }
      if (S)
        datum["seriesIndex"] = S[i2];
      if (S && tooltip2) {
        datum["seriesItems"] = S[i2].map((si) => itemsOf2(si));
        datum["seriesTitle"] = S[i2].map((si) => titleOf(si));
      }
      return datum;
    });
    state.data = visualData;
    state.index = I;
    const markChildren = createChildren === null || createChildren === void 0 ? void 0 : createChildren(visualData, markScaleInstance, layout);
    children.push(...markChildren || []);
  }
  const view = {
    layout,
    theme,
    coordinate,
    markState,
    key,
    clip,
    scale: scaleInstance,
    style: framedStyle,
    components,
    data: dataMap,
    options,
    labelTransform: compose2(labelTransform.map(useLabelTransform))
  };
  return [view, children];
}
function plotView(view, selection, transitions, context) {
  return __awaiter6(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const { components, theme, layout, markState, coordinate, key, style, clip, scale: scale4 } = view;
    const { x: x2, y: y3, width, height } = layout, rest = __rest71(layout, ["x", "y", "width", "height"]);
    const areaKeys = ["view", "plot", "main", "content"];
    const I = areaKeys.map((_, i2) => i2);
    const sizeKeys = ["a", "margin", "padding", "inset"];
    const areaStyles = areaKeys.map((d3) => maybeSubObject(Object.assign({}, theme.view, style), d3));
    const areaSizes = sizeKeys.map((d3) => subObject(rest, d3));
    const styleArea = (selection2) => selection2.style("x", (i2) => areaLayouts[i2].x).style("y", (i2) => areaLayouts[i2].y).style("width", (i2) => areaLayouts[i2].width).style("height", (i2) => areaLayouts[i2].height).each(function(i2, d3, element) {
      applyStyle2(select(element), areaStyles[i2]);
    });
    let px = 0;
    let py = 0;
    let pw = width;
    let ph = height;
    const areaLayouts = I.map((i2) => {
      const size4 = areaSizes[i2];
      const { left: left2 = 0, top = 0, bottom = 0, right: right2 = 0 } = size4;
      px += left2;
      py += top;
      pw -= left2 + right2;
      ph -= top + bottom;
      return {
        x: px,
        y: py,
        width: pw,
        height: ph
      };
    });
    selection.selectAll(className(AREA_CLASS_NAME)).data(
      // Only render area with defined style.
      I.filter((i2) => defined(areaStyles[i2])),
      (i2) => areaKeys[i2]
    ).join((enter) => enter.append("rect").attr("className", AREA_CLASS_NAME).style("zIndex", -2).call(styleArea), (update) => update.call(styleArea), (exit) => exit.remove());
    const animationExtent = computeAnimationExtent(markState);
    const componentAnimateOptions = animationExtent ? { duration: animationExtent[1] } : false;
    for (const [, C] of groups(components, (d3) => `${d3.type}-${d3.position}`)) {
      C.forEach((d3, i2) => d3.index = i2);
    }
    const componentsTransitions = selection.selectAll(className(COMPONENT_CLASS_NAME)).data(components, (d3) => `${d3.type}-${d3.position}-${d3.index}`).join((enter) => enter.append("g").style("zIndex", ({ zIndex }) => zIndex || -1).attr("className", COMPONENT_CLASS_NAME).append((options) => renderComponent(deep_mix_default({ animate: componentAnimateOptions, scale: scale4 }, options), coordinate, theme, library3, markState)), (update) => update.transition(function(options, i2, element) {
      const { preserve = false } = options;
      if (preserve)
        return;
      const newComponent = renderComponent(deep_mix_default({ animate: componentAnimateOptions, scale: scale4 }, options), coordinate, theme, library3, markState);
      const { attributes } = newComponent;
      const [node] = element.childNodes;
      return node.update(attributes, false);
    })).transitions();
    transitions.push(...componentsTransitions.flat().filter(defined));
    const T2 = selection.selectAll(className(PLOT_CLASS_NAME)).data([layout], () => key).join((enter) => enter.append("rect").style("zIndex", 0).style("fill", "transparent").attr("className", PLOT_CLASS_NAME).call(updateBBox).call(updateLayers, Array.from(markState.keys())).call(applyClip, clip), (update) => update.call(updateLayers, Array.from(markState.keys())).call(updateBBox).call(applyClip, clip)).transitions();
    transitions.push(...T2.flat());
    for (const [mark2, state] of markState.entries()) {
      const { data } = state;
      const { key: key2, class: cls, type } = mark2;
      const viewNode = selection.select(`#${key2}`);
      const shapeFunction = createMarkShapeFunction(mark2, state, view, context);
      const enterFunction = createEnterFunction(mark2, state, view, library3);
      const updateFunction = createUpdateFunction(mark2, state, view, library3);
      const exitFunction = createExitFunction(mark2, state, view, library3);
      const facetElements = selectFacetElements(selection, viewNode, cls, "element");
      const T3 = viewNode.selectAll(className(ELEMENT_CLASS_NAME)).selectFacetAll(facetElements).data(data, (d3) => d3.key, (d3) => d3.groupKey).join((enter) => enter.append(shapeFunction).attr("className", ELEMENT_CLASS_NAME).attr("markType", type).transition(function(data2, i2, element) {
        return enterFunction(data2, [element]);
      }), (update) => update.call((selection2) => {
        const parent = selection2.parent();
        const origin = useMemo((node) => {
          const [x3, y4] = node.getBounds().min;
          return [x3, y4];
        });
        selection2.transition(function(data2, index2, element) {
          maybeFacetElement(element, parent, origin);
          const node = shapeFunction(data2, index2);
          const animation = updateFunction(data2, [element], [node]);
          if (animation === null || animation === void 0 ? void 0 : animation.length)
            return animation;
          if (element.nodeName === node.nodeName && node.nodeName !== "g") {
            copyAttributes(element, node);
          } else {
            element.parentNode.replaceChild(node, element);
            node.className = ELEMENT_CLASS_NAME;
            node.markType = type;
            node.__data__ = element.__data__;
          }
          return animation;
        }).each(function(d3, i2, element) {
          if (element.__removed__) {
            element.__removed__ = false;
          }
        }).attr("markType", type).attr("className", ELEMENT_CLASS_NAME);
      }), (exit) => {
        return exit.each(function(d3, i2, element) {
          element.__removed__ = true;
        }).transition(function(data2, i2, element) {
          return exitFunction(data2, [element]);
        }).remove();
      }, (merge2) => merge2.append(shapeFunction).attr("className", ELEMENT_CLASS_NAME).attr("markType", type).transition(function(data2, i2, element) {
        const { __fromElements__: fromElements } = element;
        const transition = updateFunction(data2, fromElements, [element]);
        const exit = new Selection(fromElements, null, element.parentNode);
        exit.transition(transition).remove();
        return transition;
      }), (split) => split.transition(function(data2, i2, element) {
        const enter = new Selection([], element.__toData__, element.parentNode);
        const toElements = enter.append(shapeFunction).attr("className", ELEMENT_CLASS_NAME).attr("markType", type).nodes();
        return updateFunction(data2, [element], toElements);
      }).remove()).transitions();
      transitions.push(...T3.flat());
    }
    plotLabel(view, selection, transitions, library3, context);
    plotBreak(view, selection, library3, context);
  });
}
function plotLabel(view, selection, transitions, library3, context) {
  const [useLabelTransform] = useLibrary("labelTransform", library3);
  const { markState, labelTransform } = view;
  const labelLayer = selection.select(className(LABEL_LAYER_CLASS_NAME)).node();
  const labelShapeFunction = /* @__PURE__ */ new Map();
  const labelDescriptor = /* @__PURE__ */ new Map();
  const labels = Array.from(markState.entries()).flatMap(([mark2, state]) => {
    const { labels: labelOptions = [], key } = mark2;
    const shapeFunction = createLabelShapeFunction(mark2, state, view, library3, context);
    const elements = selection.select(`#${key}`).selectAll(className(ELEMENT_CLASS_NAME)).nodes().filter((n2) => {
      var _a;
      if (n2.__removed__)
        return false;
      const isHidden = ((_a = n2.style) === null || _a === void 0 ? void 0 : _a.visibility) === "hidden" || n2.children && n2.children.some((child) => {
        var _a2;
        return ((_a2 = child.style) === null || _a2 === void 0 ? void 0 : _a2.visibility) === "hidden";
      });
      return !isHidden;
    });
    return labelOptions.flatMap((labelOption, i2) => {
      const { transform: transform2 = [] } = labelOption, options = __rest71(labelOption, ["transform"]);
      return elements.flatMap((e3) => {
        const L = getLabels(options, i2, e3);
        L.forEach((l2) => {
          labelShapeFunction.set(l2, (data) => shapeFunction(Object.assign(Object.assign({}, data), { element: e3 })));
          labelDescriptor.set(l2, labelOption);
        });
        return L;
      });
    });
  });
  const labelShapes = select(labelLayer).selectAll(className(LABEL_CLASS_NAME)).data(labels, (d3) => d3.key).join((enter) => enter.append((d3) => labelShapeFunction.get(d3)(d3)).attr("className", LABEL_CLASS_NAME), (update) => update.each(function(d3, i2, element) {
    const shapeFunction = labelShapeFunction.get(d3);
    const node = shapeFunction(d3);
    copyAttributes(element, node);
  }), (exit) => exit.remove()).nodes();
  const labelGroups = group(labelShapes, (d3) => labelDescriptor.get(d3.__data__));
  const { coordinate, layout } = view;
  const labelTransformContext = {
    canvas: context.canvas,
    coordinate,
    layout
  };
  for (const [label, shapes] of labelGroups) {
    const { transform: transform2 = [] } = label;
    const transformFunction = compose2(transform2.map(useLabelTransform));
    transformFunction(shapes, labelTransformContext);
  }
  if (labelTransform) {
    labelTransform(labelShapes, labelTransformContext);
  }
}
function getLabels(label, labelIndex, element) {
  const { seriesIndex: SI, seriesKey, points, key, index: index2 } = element.__data__;
  const bounds = getLocalBounds(element);
  if (!SI) {
    return [
      Object.assign(Object.assign({}, label), {
        key: `${key}-${labelIndex}`,
        bounds,
        index: index2,
        points,
        dependentElement: element
      })
    ];
  }
  const selector = normalizeLabelSelector(label);
  const F = SI.map((index3, i2) => Object.assign(Object.assign({}, label), {
    key: `${seriesKey[i2]}-${labelIndex}`,
    bounds: [points[i2]],
    index: index3,
    points,
    dependentElement: element
  }));
  return selector ? selector(F) : F;
}
function plotBreak(view, selection, library3, context) {
  const scale4 = view.scale;
  const breaks = get_default(scale4, "y.options.breaks", []);
  const { document: document2 } = context.canvas;
  [BREAK_CLASS_NAME, BREAK_GROUP_CLASS_NAME].forEach((d3) => {
    document2.getElementsByClassName(d3).forEach((e3) => {
      e3.remove();
    });
  });
  if (!breaks.length) {
    return;
  }
  const breakLayer = selection.select(className(PLOT_CLASS_NAME)).node();
  const [useShape] = useLibrary("shape", library3);
  const breaksShapeFunction = /* @__PURE__ */ new Map();
  breaks.forEach((breakConfig, index2) => {
    breaksShapeFunction.set(breakConfig, useShape({
      type: "break"
    }, {
      view,
      selection,
      context
    }));
  });
  select(breakLayer).selectAll(className(BREAK_CLASS_NAME)).data(breaks, (d3) => d3.key).join((enter) => enter.append((d3, index2) => breaksShapeFunction.get(d3)(d3, index2)).attr("className", BREAK_CLASS_NAME), (update) => update.each(function(d3, i2, element) {
    const shapeFunction = breaksShapeFunction.get(d3);
    const node = shapeFunction(d3, i2);
    copyAttributes(element, node);
  }), (exit) => exit.remove()).nodes();
}
function filterValid([I, P, S]) {
  if (S)
    return [I, P, S];
  const definedIndex = [];
  const definedPoints = [];
  for (let i2 = 0; i2 < I.length; i2++) {
    const d3 = I[i2];
    const p3 = P[i2];
    if (p3.every(([x2, y3]) => defined(x2) && defined(y3))) {
      definedIndex.push(d3);
      definedPoints.push(p3);
    }
  }
  return [definedIndex, definedPoints];
}
function normalizeLabelSelector(label) {
  const { selector } = label;
  if (!selector)
    return null;
  if (typeof selector === "function")
    return selector;
  if (selector === "first")
    return (I) => [I[0]];
  if (selector === "last")
    return (I) => [I[I.length - 1]];
  throw new Error(`Unknown selector: ${selector}`);
}
function getLocalBounds(element) {
  const cloneElement = element.cloneNode(true);
  const animations = element.getAnimations();
  cloneElement.style.visibility = "hidden";
  animations.forEach((animation) => {
    const keyframes = animation.effect.getKeyframes();
    cloneElement.attr(keyframes[keyframes.length - 1]);
  });
  element.parentNode.appendChild(cloneElement);
  const bounds = cloneElement.getLocalBounds();
  cloneElement.destroy();
  const { min: min6, max: max7 } = bounds;
  return [min6, max7];
}
function createLabelShapeFunction(mark2, state, view, library3, context) {
  const [useShape] = useLibrary("shape", library3);
  const { data: abstractData, encode } = mark2;
  const { data: visualData, defaultLabelShape } = state;
  const point2d = visualData.map((d3) => d3.points);
  const channel = mapObject(encode, (d3) => d3.value);
  const { theme, coordinate } = view;
  const shapeContext = Object.assign(Object.assign({}, context), {
    document: documentOf(context),
    theme,
    coordinate
  });
  return (options) => {
    const { index: index2, points } = options;
    const datum = abstractData[index2];
    const { formatter = (d3) => `${d3}`, transform: transform2, style: abstractStyle, render: render3, selector, element } = options, abstractOptions = __rest71(options, ["formatter", "transform", "style", "render", "selector", "element"]);
    const visualOptions = mapObject(Object.assign(Object.assign({}, abstractOptions), abstractStyle), (d3) => valueOf2(d3, datum, index2, abstractData, {
      channel,
      element
    }));
    const { shape: shape24 = defaultLabelShape, text } = visualOptions, style = __rest71(visualOptions, ["shape", "text"]);
    const f2 = typeof formatter === "string" ? format2(formatter) : formatter;
    const value2 = Object.assign(Object.assign({}, style), { text: f2(text, datum, index2, abstractData), datum });
    const shapeOptions = Object.assign({ type: `label.${shape24}`, render: render3 }, style);
    const shapeFunction = useShape(shapeOptions, shapeContext);
    const defaults4 = getDefaultsStyle(theme, "label", shape24, "label");
    return shapeFunction(points, value2, defaults4, point2d);
  };
}
function valueOf2(value2, datum, i2, data, options) {
  if (typeof value2 === "function")
    return value2(datum, i2, data, options);
  if (typeof value2 !== "string")
    return value2;
  if (isStrictObject(datum) && datum[value2] !== void 0)
    return datum[value2];
  return value2;
}
function computeAnimationExtent(markState) {
  let maxDuration = -Infinity;
  let minDelay = Infinity;
  for (const [mark2, state] of markState) {
    const { animate = {} } = mark2;
    const { data } = state;
    const { enter = {}, update = {}, exit = {} } = animate;
    const { type: defaultUpdateType, duration: defaultUpdateDuration = 300, delay: defaultUpdateDelay = 0 } = update;
    const { type: defaultEnterType, duration: defaultEnterDuration = 300, delay: defaultEnterDelay = 0 } = enter;
    const { type: defaultExitType, duration: defaultExitDuration = 300, delay: defaultExitDelay = 0 } = exit;
    for (const d3 of data) {
      const { updateType = defaultUpdateType, updateDuration = defaultUpdateDuration, updateDelay = defaultUpdateDelay, enterType = defaultEnterType, enterDuration = defaultEnterDuration, enterDelay = defaultEnterDelay, exitDuration = defaultExitDuration, exitDelay = defaultExitDelay, exitType = defaultExitType } = d3;
      if (updateType === void 0 || updateType) {
        maxDuration = Math.max(maxDuration, updateDuration + updateDelay);
        minDelay = Math.min(minDelay, updateDelay);
      }
      if (exitType === void 0 || exitType) {
        maxDuration = Math.max(maxDuration, exitDuration + exitDelay);
        minDelay = Math.min(minDelay, exitDelay);
      }
      if (enterType === void 0 || enterType) {
        maxDuration = Math.max(maxDuration, enterDuration + enterDelay);
        minDelay = Math.min(minDelay, enterDelay);
      }
    }
  }
  if (maxDuration === -Infinity)
    return null;
  return [minDelay, maxDuration - minDelay];
}
function selectFacetElements(selection, current, facetClassName, elementClassName) {
  const group2 = selection.node().parentElement;
  if (!group2 || typeof group2.findAll !== "function")
    return [];
  return group2.findAll((node) => node.style.facet !== void 0 && node.style.facet === facetClassName && node !== current.node()).flatMap((node) => node.getElementsByClassName(elementClassName));
}
function maybeFacetElement(element, parent, originOf) {
  if (!element.__facet__)
    return;
  const prePlot = element.parentNode.parentNode;
  const newPlot = parent.parentNode;
  const [px, py] = originOf(prePlot);
  const [x2, y3] = originOf(newPlot);
  const translate2 = `translate(${px - x2}, ${py - y3})`;
  appendTransform(element, translate2);
  parent.append(element);
}
function createMarkShapeFunction(mark2, state, view, context) {
  const { library: library3 } = context;
  const [useShape] = useLibrary("shape", library3);
  const { data: abstractData, encode } = mark2;
  const { defaultShape, data, shape: shapeLibrary } = state;
  const channel = mapObject(encode, (d3) => d3.value);
  const point2d = data.map((d3) => d3.points);
  const { theme, coordinate } = view;
  const { type: markType, style = {} } = mark2;
  const shapeContext = Object.assign(Object.assign({}, context), {
    document: documentOf(context),
    coordinate,
    theme
  });
  return (data2) => {
    const { shape: styleShape = defaultShape } = style;
    const { shape: shape24 = styleShape, points, seriesIndex, index: i2 } = data2, v = __rest71(data2, ["shape", "points", "seriesIndex", "index"]);
    const value2 = Object.assign(Object.assign({}, v), { index: i2 });
    const abstractDatum = seriesIndex ? seriesIndex.map((i3) => abstractData[i3]) : abstractData[i2];
    const I = seriesIndex ? seriesIndex : i2;
    const visualStyle = mapObject(style, (d3) => valueOf2(d3, abstractDatum, I, abstractData, { channel }));
    const shapeFunction = shapeLibrary[shape24] ? shapeLibrary[shape24](visualStyle, shapeContext) : useShape(Object.assign(Object.assign({}, visualStyle), { type: shapeName(mark2, shape24) }), shapeContext);
    const defaults4 = getDefaultsStyle(theme, markType, shape24, defaultShape);
    return shapeFunction(points, value2, defaults4, point2d);
  };
}
function getDefaultsStyle(theme, mark2, shape24, defaultShape) {
  if (typeof mark2 !== "string")
    return;
  const { color } = theme;
  const markTheme = theme[mark2] || {};
  const shapeTheme = markTheme[shape24] || markTheme[defaultShape];
  return Object.assign({ color }, shapeTheme);
}
function createAnimationFunction(type, mark2, state, view, library3) {
  var _a, _b;
  const [, createShape] = useLibrary("shape", library3);
  const [useAnimation] = useLibrary("animation", library3);
  const { defaultShape, shape: shapeLibrary } = state;
  const { theme, coordinate } = view;
  const upperType = upper_first_default(type);
  const key = `default${upperType}Animation`;
  const { [key]: defaultAnimation } = ((_a = shapeLibrary[defaultShape]) === null || _a === void 0 ? void 0 : _a.props) || createShape(shapeName(mark2, defaultShape)).props;
  const { [type]: defaultEffectTiming = {} } = theme;
  const animate = ((_b = mark2.animate) === null || _b === void 0 ? void 0 : _b[type]) || {};
  const context = { coordinate };
  return (data, from, to) => {
    const { [`${type}Type`]: animation, [`${type}Delay`]: delay, [`${type}Duration`]: duration, [`${type}Easing`]: easing } = data;
    const options = Object.assign({ type: animation || defaultAnimation }, animate);
    if (!options.type)
      return null;
    const animateFunction = useAnimation(options, context);
    const value2 = { delay, duration, easing };
    const A5 = animateFunction(from, to, deep_mix_default(defaultEffectTiming, value2));
    let an = [];
    if (!Array.isArray(A5)) {
      an = [A5];
    } else {
      an = A5;
    }
    return an.filter(Boolean);
  };
}
function createEnterFunction(mark2, state, view, library3) {
  return createAnimationFunction("enter", mark2, state, view, library3);
}
function cancel(animation) {
  animation.finished.then(() => {
    animation.cancel();
  });
  return animation;
}
function createUpdateFunction(mark2, state, view, library3) {
  return createAnimationFunction("update", mark2, state, view, library3);
}
function createExitFunction(mark2, state, view, library3) {
  return createAnimationFunction("exit", mark2, state, view, library3);
}
function inferTheme(theme = {}) {
  if (typeof theme === "string")
    return { type: theme };
  const { type = "light" } = theme, rest = __rest71(theme, ["type"]);
  return Object.assign(Object.assign({}, rest), { type });
}
function inferInteraction(view) {
  const defaults4 = {
    event: true,
    tooltip: true,
    // @todo Inferred by slider self.
    sliderFilter: true,
    legendFilter: true,
    scrollbarFilter: true
  };
  const { interaction = {} } = view;
  return Object.entries(deep_mix_default(defaults4, interaction)).reverse();
}
function applyTransform(node, context) {
  return __awaiter6(this, void 0, void 0, function* () {
    const { data } = node, rest = __rest71(node, ["data"]);
    if (data == void 0)
      return node;
    const [, { data: newData }] = yield applyDataTransform([], { data }, context);
    return Object.assign({ data: newData }, rest);
  });
}
function updateBBox(selection) {
  selection.style("transform", (d3) => `translate(${d3.paddingLeft + d3.marginLeft}, ${d3.paddingTop + d3.marginTop})`).style("width", (d3) => d3.innerWidth).style("height", (d3) => d3.innerHeight);
}
function shapeName(mark2, name2) {
  const { type } = mark2;
  if (typeof name2 === "string")
    return `${type}.${name2}`;
  return name2;
}
function updateLayers(selection, marks) {
  const facet = (d3) => d3.class !== void 0 ? `${d3.class}` : "";
  const nodes = selection.nodes();
  if (nodes.length === 0)
    return;
  selection.selectAll(className(MAIN_LAYER_CLASS_NAME)).data(marks, (d3) => d3.key).join((enter) => enter.append("g").attr("className", MAIN_LAYER_CLASS_NAME).attr("id", (d3) => d3.key).style("facet", facet).style("fill", "transparent").style("zIndex", (d3) => {
    var _a;
    return (_a = d3.zIndex) !== null && _a !== void 0 ? _a : 0;
  }), (update) => update.style("facet", facet).style("fill", "transparent").style("zIndex", (d3) => {
    var _a;
    return (_a = d3.zIndex) !== null && _a !== void 0 ? _a : 0;
  }), (exit) => exit.remove());
  const labelLayer = selection.select(className(LABEL_LAYER_CLASS_NAME)).node();
  if (labelLayer)
    return;
  selection.append("g").attr("className", LABEL_LAYER_CLASS_NAME).style("zIndex", 0);
}
function className(...names) {
  return names.map((d3) => `.${d3}`).join("");
}
function applyClip(selection, clip) {
  if (!selection.node())
    return;
  selection.style("clipPath", (data) => {
    if (!clip)
      return null;
    const { paddingTop: y3, paddingLeft: x2, marginLeft: x12, marginTop: y12, innerWidth: width, innerHeight: height } = data;
    return new Rect({ style: { x: x2 + x12, y: y3 + y12, width, height } });
  });
}
function inferComponentScales(scales, states, markState) {
  var _a;
  for (const [key] of markState.entries()) {
    if (key.type === "cell") {
      return scales.filter((scale4) => scale4.name !== "shape");
    }
  }
  if (states.length !== 1 || scales.some((scale4) => scale4.name === "shape")) {
    return scales;
  }
  const { defaultShape: shape24 } = states[0];
  const acceptMarkTypes = ["point", "line", "rect", "hollow"];
  if (!acceptMarkTypes.includes(shape24))
    return scales;
  const shapeMap = {
    point: "point",
    line: "hyphen",
    rect: "square",
    hollow: "hollow"
  };
  const field3 = ((_a = scales.find((scale4) => scale4.name === "color")) === null || _a === void 0 ? void 0 : _a.field) || null;
  const shapeScale = {
    field: field3,
    name: "shape",
    type: "constant",
    domain: [],
    range: [shapeMap[shape24]]
  };
  return [...scales, shapeScale];
}
function applyStyle2(selection, style) {
  for (const [key, value2] of Object.entries(style)) {
    selection.style(key, value2);
  }
}

// node_modules/@antv/g2/esm/utils/flow.js
function flow(...flows) {
  return (param) => {
    return flows.reduce((result, f2) => {
      return f2(result);
    }, param);
  };
}

// node_modules/@antv/g2/esm/runtime/option-preprocess/style.js
function columnWidthRatio(options) {
  const { style, scale: scale4, type } = options;
  const scaleOption = {};
  const columnWidthRatio2 = get_default(style, "columnWidthRatio");
  if (columnWidthRatio2 && type === "interval") {
    scaleOption.x = Object.assign(Object.assign({}, scale4 === null || scale4 === void 0 ? void 0 : scale4.x), { padding: 1 - columnWidthRatio2 });
  }
  return Object.assign(Object.assign({}, options), { scale: Object.assign(Object.assign({}, scale4), scaleOption) });
}

// node_modules/@antv/g2/esm/runtime/option-preprocess/axis-breaks.js
var percentToRatio = (gap) => {
  if (!gap || typeof gap !== "string") {
    return gap;
  }
  const value2 = gap.endsWith("%") ? parseFloat(gap.slice(0, -1)) / 100 : parseFloat(gap);
  if (isNaN(value2) || value2 < 0 || value2 > 1) {
    throw new Error(`Invalid gap value: ${gap}. It should be between 0 and 1.`);
  }
  return value2;
};
function axisBreaks(options) {
  const { axis } = options;
  const breaks = get_default(axis, "y.breaks");
  if (breaks) {
    set_default(options, "scale.y.breaks", breaks.map((item) => Object.assign(Object.assign({ key: `break-${item.start}-${item.end}` }, item), { gap: percentToRatio(item.gap) })));
  }
  return options;
}

// node_modules/@antv/g2/esm/runtime/option-preprocess/index.js
function preprocessOption(options) {
  const convertedOptions = adapter(options);
  if (convertedOptions.children && Array.isArray(convertedOptions.children)) {
    convertedOptions.children = convertedOptions.children.map((child) => preprocessOption(child));
  }
  return convertedOptions;
}
function adapter(options) {
  return flow(columnWidthRatio, axisBreaks)(options);
}

// node_modules/@antv/g2/esm/runtime/render.js
function inferKeys(options) {
  const root = deep_mix_default({}, options);
  const nodeParent = /* @__PURE__ */ new Map([[root, null]]);
  const nodeIndex = /* @__PURE__ */ new Map([[null, -1]]);
  const discovered = [root];
  while (discovered.length) {
    const node = discovered.shift();
    if (node.key === void 0) {
      const parent = nodeParent.get(node);
      const index2 = nodeIndex.get(node);
      const key = parent === null ? `${0}` : `${parent.key}-${index2}`;
      node.key = key;
    }
    const { children = [] } = node;
    if (Array.isArray(children)) {
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = deep_mix_default({}, children[i2]);
        children[i2] = child;
        nodeParent.set(child, node);
        nodeIndex.set(child, i2);
        discovered.push(child);
      }
    }
  }
  return root;
}
function Canvas2(width, height) {
  const renderer = new Renderer();
  renderer.registerPlugin(new Plugin());
  return new Canvas({
    width,
    height,
    container: document.createElement("div"),
    renderer
  });
}
function render(options, context = {}, resolve = () => {
}, reject = (e3) => {
  throw e3;
}) {
  const afterParsedOptions = parseOptionsExpr(options);
  const { width = 640, height = 480, depth = 0 } = afterParsedOptions;
  const preprocessedOption = preprocessOption(afterParsedOptions);
  const keyed2 = inferKeys(preprocessedOption);
  const { canvas = Canvas2(width, height), emitter = new esm_default(), library: library3 } = context;
  context.canvas = canvas;
  context.emitter = emitter;
  context.externals = {};
  const { width: prevWidth, height: prevHeight } = canvas.getConfig();
  if (prevWidth !== width || prevHeight !== height) {
    canvas.resize(width, height);
  }
  emitter.emit(ChartEvent.BEFORE_RENDER);
  const selection = select(canvas.document.documentElement);
  canvas.ready.then(() => plot(Object.assign(Object.assign({}, keyed2), { width, height, depth }), selection, context)).then(() => {
    if (depth) {
      const [x2, y3] = canvas.document.documentElement.getPosition();
      canvas.document.documentElement.setPosition(x2, y3, -depth / 2);
    }
    canvas.requestAnimationFrame(() => {
      canvas.requestAnimationFrame(() => {
        emitter.emit(ChartEvent.AFTER_RENDER);
        resolve === null || resolve === void 0 ? void 0 : resolve();
      });
    });
  }).catch((e3) => {
    reject === null || reject === void 0 ? void 0 : reject(e3);
  });
  return normalizeContainer(canvas.getConfig().container);
}
function renderToMountedElement(options, context = {}, resolve = () => {
}, reject = (e3) => {
  throw e3;
}) {
  var _a;
  const { width = 640, height = 480 } = options;
  const keyed2 = inferKeys(options);
  const { group: group2 = new Group(), emitter = new esm_default(), library: library3 } = context;
  if (!(group2 === null || group2 === void 0 ? void 0 : group2.parentElement)) {
    error(`renderToMountedElement can't render chart to unmounted group.`);
  }
  const selection = select(group2);
  context.group = group2;
  context.emitter = emitter;
  context.externals = {};
  context.canvas = context.canvas || ((_a = group2 === null || group2 === void 0 ? void 0 : group2.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView);
  emitter.emit(ChartEvent.BEFORE_RENDER);
  plot(Object.assign(Object.assign({}, keyed2), { width, height }), selection, context).then(() => {
    var _a2;
    (_a2 = context.canvas) === null || _a2 === void 0 ? void 0 : _a2.requestAnimationFrame(() => {
      emitter.emit(ChartEvent.AFTER_RENDER);
      resolve === null || resolve === void 0 ? void 0 : resolve();
    });
  }).catch((e3) => {
    reject === null || reject === void 0 ? void 0 : reject(e3);
  });
  return group2;
}
function destroy(options, context = {}, isDestroyCanvas = false, isClearEvents = true) {
  const { canvas, emitter } = context;
  if (canvas) {
    destroyAllInteractions(canvas);
    isDestroyCanvas ? canvas.destroy() : canvas.destroyChildren();
  }
  if (isClearEvents) {
    emitter.off();
  }
}
function destroyAllInteractions(canvas) {
  const viewGroups = canvas.getRoot().querySelectorAll(`.${VIEW_CLASS_NAME}`);
  viewGroups === null || viewGroups === void 0 ? void 0 : viewGroups.forEach((group2) => {
    const { nameInteraction = /* @__PURE__ */ new Map() } = group2;
    if ((nameInteraction === null || nameInteraction === void 0 ? void 0 : nameInteraction.size) > 0) {
      Array.from(nameInteraction === null || nameInteraction === void 0 ? void 0 : nameInteraction.values()).forEach((value2) => {
        value2 === null || value2 === void 0 ? void 0 : value2.destroy();
      });
    }
  });
}
function normalizeContainer(container) {
  return typeof container === "string" ? document.getElementById(container) : container;
}

// node_modules/@antv/g2/esm/utils/scale.js
function constrain(x2, lo, hi) {
  return Math.min(hi, Math.max(lo, x2));
}
function isOrdinalScale(scale4) {
  return !!scale4.getBandWidth;
}
function invert(scale4, x2, start) {
  if (!isOrdinalScale(scale4))
    return scale4.invert(x2);
  const { adjustedRange } = scale4;
  if (adjustedRange.includes(x2)) {
    return scale4.invert(x2);
  }
  const { domain } = scale4.getOptions();
  const offset2 = start ? -1 : 0;
  const step = scale4.getStep();
  const range3 = start ? adjustedRange : adjustedRange.map((d3) => d3 + step);
  const i0 = bisectLeft(range3, x2);
  const i1 = constrain(i0 + offset2, 0, domain.length - 1);
  return domain[i1];
}
function domainOf3(scale4, values4, ratioX) {
  if (!values4)
    return scale4.getOptions().domain;
  if (!isOrdinalScale(scale4)) {
    const sortedDomain = sort(values4);
    if (!ratioX)
      return sortedDomain;
    const [d3] = sortedDomain;
    const { range: range3 } = scale4.getOptions();
    const [r0, r1] = range3;
    const v = r0 > r1 ? -1 : 1;
    const d1 = scale4.invert(scale4.map(d3) + v * ratioX);
    return [d3, d1];
  }
  const { domain } = scale4.getOptions();
  const v1 = values4[0];
  const start = domain.indexOf(v1);
  if (ratioX) {
    const end2 = start + Math.round(domain.length * ratioX);
    return domain.slice(start, end2);
  }
  const v2 = values4[values4.length - 1];
  const end = domain.indexOf(v2);
  return domain.slice(start, end + 1);
}
function selectionOf(x2, y3, x12, y12, scale4, coordinate) {
  const { x: scaleX, y: scaleY } = scale4;
  const abstractDomain = (point6, start) => {
    const [x3, y4] = coordinate.invert(point6);
    return [invert(scaleX, x3, start), invert(scaleY, y4, start)];
  };
  const p0 = abstractDomain([x2, y3], true);
  const p1 = abstractDomain([x12, y12], false);
  const domainX = domainOf3(scaleX, [p0[0], p1[0]]);
  const domainY = domainOf3(scaleY, [p0[1], p1[1]]);
  return [domainX, domainY];
}
function abstractOf(domain, scale4) {
  const [d0, d1] = domain;
  const maybeStep = (scale5) => scale5.getStep ? scale5.getStep() : 0;
  return [scale4.map(d0), scale4.map(d1) + maybeStep(scale4)];
}
var sliderAbstractOf = (domain, scale4) => {
  var _a, _b;
  const [d0, d1] = domain;
  const scaleDomain = ((_b = (_a = scale4.getOptions) === null || _a === void 0 ? void 0 : _a.call(scale4)) === null || _b === void 0 ? void 0 : _b.domain) || [];
  const index0 = scaleDomain.indexOf(d0);
  const index1 = scaleDomain.indexOf(d1);
  if (index0 === -1 || index1 === -1) {
    return [scale4.map(d0), scale4.map(d1)];
  }
  const count4 = scaleDomain.length;
  if (count4 <= 1) {
    return [0, 1];
  }
  return [index0 / (count4 - 1), index1 / (count4 - 1)];
};
function pixelsOf(selection, scale4, coordinate) {
  const { x: scaleX, y: scaleY } = scale4;
  const [X, Y] = selection;
  const AX = abstractOf(X, scaleX);
  const AY = abstractOf(Y, scaleY);
  const p0 = [AX[0], AY[0]];
  const p1 = [AX[1], AY[1]];
  const [x2, y3] = coordinate.map(p0);
  const [x12, y12] = coordinate.map(p1);
  return [x2, y3, x12, y12];
}

// node_modules/@antv/g2/esm/utils/traverse-elements.js
function traverseElements(element, visitor) {
  if (visitor(element))
    return true;
  if (element.tagName === "g") {
    const { childNodes = [] } = element;
    for (const child of childNodes) {
      if (traverseElements(child, visitor))
        return true;
    }
  }
  return false;
}

// node_modules/@antv/g2/esm/utils/style.js
var defaultStyle = {
  visibility: "visible",
  opacity: 1,
  fillOpacity: 1,
  strokeOpacity: 1
};
function getStyle(element, key) {
  let value2;
  traverseElements(element, (el) => {
    var _a;
    if (el.tagName !== "g" && ((_a = el.style) === null || _a === void 0 ? void 0 : _a[key]) !== void 0) {
      value2 = el.style[key];
      return true;
    }
    return false;
  });
  return value2 !== null && value2 !== void 0 ? value2 : defaultStyle[key];
}
function setStyle2(element, key, value2, recursive) {
  element.style[key] = value2;
  if (recursive) {
    element.children.forEach((child) => setStyle2(child, key, value2, recursive));
  }
}
function hide(element) {
  setStyle2(element, "visibility", "hidden", true);
}
function show(element) {
  setStyle2(element, "visibility", "visible", true);
}

// node_modules/@antv/g2/esm/interaction/utils.js
var __rest72 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function selectG2Elements(root) {
  return select(root).selectAll(`.${ELEMENT_CLASS_NAME}`).nodes().filter((d3) => !d3.__removed__);
}
function selectFacetG2Elements(target, viewInstances) {
  return selectFacetViews(target, viewInstances).flatMap(({ container }) => selectG2Elements(container));
}
function selectFacetViews(target, viewInstances) {
  return viewInstances.filter((d3) => d3 !== target && d3.options.parentKey === target.options.key);
}
function selectPlotArea(root) {
  return select(root).select(`.${PLOT_CLASS_NAME}`).node();
}
function bboxOf(element) {
  if (element.tagName === "g")
    return element.getRenderBounds();
  const bounds = element.getGeometryBounds();
  const aabb = new AABB();
  aabb.setFromTransformedAABB(bounds, element.getWorldTransform());
  return aabb;
}
function mousePosition(target, event) {
  const { offsetX, offsetY } = event;
  const bbox = bboxOf(target);
  const { min: [x2, y3], max: [x12, y12] } = bbox;
  const isOutX = offsetX < x2 || offsetX > x12;
  const isOutY = offsetY < y3 || offsetY > y12;
  if (isOutX || isOutY)
    return null;
  return [offsetX - x2, offsetY - y3];
}
function brushMousePosition(target, event) {
  const { offsetX, offsetY } = event;
  const [x2, y3, x12, y12] = boundsOfBrushArea(target);
  return [
    Math.min(x12, Math.max(x2, offsetX)) - x2,
    Math.min(y12, Math.max(y3, offsetY)) - y3
  ];
}
function boundsOfBrushArea(target) {
  const bbox = target.getRenderBounds();
  const { min: [x05, y05], max: [x12, y12] } = bbox;
  return [x05, y05, x12, y12];
}
function createColorKey(view) {
  return (element) => element.__data__.color;
}
function createXKey(view) {
  return (element) => element.__data__.x;
}
function createDatumof(view) {
  const views = Array.isArray(view) ? view : [view];
  const keyData = new Map(views.flatMap((view2) => {
    const marks = Array.from(view2.markState.keys());
    return marks.map((mark2) => [keyed(view2.key, mark2.key), mark2.data]);
  }));
  return (element) => {
    const { index: index2, markKey, viewKey } = element.__data__;
    const data = keyData.get(keyed(viewKey, markKey));
    return data[index2];
  };
}
var STATE_PRIORITIES = {
  selected: 3,
  unselected: 3,
  active: 2,
  inactive: 2,
  default: 1
};
var STATE_GROUPS = {
  selection: ["selected", "unselected"],
  highlight: ["active", "inactive"]
};
var setElementAttribute = (element, k2, v) => {
  traverseElements(element, (el) => {
    if ("setAttribute" in el && typeof el.setAttribute === "function") {
      el.setAttribute(k2, v);
    }
  });
};
function createUseState(style, elements) {
  elements.forEach((element) => {
    const currentStyle = element.__interactionStyle__;
    if (currentStyle) {
      element.__interactionStyle__ = Object.assign(Object.assign({}, currentStyle), style);
    } else {
      element.__interactionStyle__ = style;
    }
  });
  return (valueof2 = (d3, element) => d3, setAttribute = setElementAttribute) => useState(void 0, valueof2, setAttribute);
}
function useState(style, valueof2 = (d3, element) => d3, setAttribute = setElementAttribute) {
  const STATES = "__states__";
  const ORIGINAL = "__ordinal__";
  const getStatePriority = (stateName) => STATE_PRIORITIES[stateName] || STATE_PRIORITIES.default;
  const getStateGroup = (stateName) => {
    var _a;
    return (_a = Object.entries(STATE_GROUPS).find(([_, states]) => states.includes(stateName))) === null || _a === void 0 ? void 0 : _a[0];
  };
  const applyState = (element) => {
    var _a;
    const { [STATES]: states = [], [ORIGINAL]: original = {} } = element;
    const sortedStates = [...states].sort((a4, b) => getStatePriority(b) - getStatePriority(a4));
    const styleAttributeMap = /* @__PURE__ */ new Map();
    for (const state of sortedStates) {
      const stateStyles = ((_a = style !== null && style !== void 0 ? style : element.__interactionStyle__) === null || _a === void 0 ? void 0 : _a[state]) || {};
      for (const [key, value2] of Object.entries(stateStyles)) {
        if (!styleAttributeMap.has(key)) {
          styleAttributeMap.set(key, value2);
        }
      }
    }
    const finalStyle = Object.assign({}, original);
    for (const [key, value2] of styleAttributeMap.entries()) {
      finalStyle[key] = value2;
    }
    if (Object.keys(finalStyle).length === 0)
      return;
    for (const [key, value2] of Object.entries(finalStyle)) {
      const currentValue = getStyle(element, key);
      const v = valueof2(value2, element);
      setAttribute(element, key, v);
      if (!(key in original))
        original[key] = currentValue;
    }
    element[ORIGINAL] = original;
  };
  const initState = (element) => {
    if (element[STATES])
      return;
    element[STATES] = [];
    return;
  };
  const updateState = (element, ...states) => {
    initState(element);
    const currentStates = element[STATES];
    const newStateGroups = new Set(states.map((state) => getStateGroup(state)).filter((group2) => group2 !== void 0));
    const remainingStates = currentStates.filter((existingState) => !newStateGroups.has(getStateGroup(existingState)));
    element[STATES] = [...remainingStates, ...states];
    applyState(element);
  };
  const setState = (element, ...states) => {
    initState(element);
    element[STATES] = [...states];
    applyState(element);
  };
  const removeState = (element, ...states) => {
    initState(element);
    for (const state of states) {
      const index2 = element[STATES].indexOf(state);
      if (index2 !== -1) {
        element[STATES].splice(index2, 1);
      }
    }
    applyState(element);
  };
  const hasState = (element, state) => {
    initState(element);
    return element[STATES].indexOf(state) !== -1;
  };
  return {
    setState,
    updateState,
    removeState,
    hasState
  };
}
function isEmptyObject(obj) {
  if (obj === void 0)
    return true;
  if (typeof obj !== "object")
    return false;
  return Object.keys(obj).length === 0;
}
function keyed(viewKey, markKey) {
  return `${viewKey},${markKey}`;
}
function mergeState(options, states) {
  const views = Array.isArray(options) ? options : [options];
  const markState = views.flatMap((view) => view.marks.map((mark2) => [keyed(view.key, mark2.key), mark2.state]));
  const state = {};
  for (const descriptor of states) {
    const [key, defaults4] = Array.isArray(descriptor) ? descriptor : [descriptor, {}];
    state[key] = markState.reduce((merged, mark2) => {
      const [markKey, markState2 = {}] = mark2;
      const selectedState = isEmptyObject(markState2[key]) ? defaults4 : markState2[key];
      for (const [attr, value2] of Object.entries(selectedState)) {
        const oldValue = merged[attr];
        const newValue = (data, index2, array2, element) => {
          const k2 = keyed(element.__data__.viewKey, element.__data__.markKey);
          if (markKey !== k2)
            return oldValue === null || oldValue === void 0 ? void 0 : oldValue(data, index2, array2, element);
          if (typeof value2 !== "function")
            return value2;
          return value2(data, index2, array2, element);
        };
        merged[attr] = newValue;
      }
      return merged;
    }, {});
  }
  return state;
}
function createValueof(elements, datum) {
  const elementIndex = new Map(elements.map((d3, i2) => [d3, i2]));
  const fa = datum ? elements.map(datum) : elements;
  return (d3, e3) => {
    if (typeof d3 !== "function")
      return d3;
    const i2 = elementIndex.get(e3);
    const fe = datum ? datum(e3) : e3;
    return d3(fe, i2, fa, e3);
  };
}
function renderLink(_a) {
  var { link: link3 = false, valueof: valueof2 = (d3, element) => d3, coordinate } = _a, style = __rest72(_a, ["link", "valueof", "coordinate"]);
  const LINK_CLASS_NAME = "element-link";
  if (!link3)
    return [() => {
    }, () => {
    }];
  const pointsOf = (element) => element.__data__.points;
  const pathPointsOf = (P0, P1) => {
    const [, p1, p22] = P0;
    const [p0, , , p3] = P1;
    const P = [p1, p0, p3, p22];
    return P;
  };
  const append3 = (elements) => {
    var _a2;
    if (elements.length <= 1)
      return;
    const sortedElements = sort(elements, (e0, e1) => {
      const { x: x05 } = e0.__data__;
      const { x: x12 } = e1.__data__;
      const dx = x05 - x12;
      return dx;
    });
    for (let i2 = 1; i2 < sortedElements.length; i2++) {
      const p3 = path();
      const e0 = sortedElements[i2 - 1];
      const e1 = sortedElements[i2];
      const [p0, p1, p22, p32] = pathPointsOf(pointsOf(e0), pointsOf(e1));
      p3.moveTo(...p0);
      p3.lineTo(...p1);
      p3.lineTo(...p22);
      p3.lineTo(...p32);
      p3.closePath();
      const _b = mapObject(style, (d3) => valueof2(d3, e0)), { fill = e0.getAttribute("fill") } = _b, rest = __rest72(_b, ["fill"]);
      const link4 = new Path({
        className: LINK_CLASS_NAME,
        style: Object.assign({ d: p3.toString(), fill, zIndex: -2 }, rest)
      });
      (_a2 = e0.link) === null || _a2 === void 0 ? void 0 : _a2.remove();
      e0.parentNode.appendChild(link4);
      e0.link = link4;
    }
  };
  const remove2 = (element) => {
    var _a2;
    (_a2 = element.link) === null || _a2 === void 0 ? void 0 : _a2.remove();
    element.link = null;
  };
  return [append3, remove2];
}
function offsetTransform(element, offset2, coordinate) {
  const append3 = (t) => {
    const { transform: transform2 } = element.style;
    return transform2 ? `${transform2} ${t}` : t;
  };
  if (isPolar(coordinate)) {
    const { points } = element.__data__;
    const [p0, p1] = isTranspose(coordinate) ? reorder(points) : points;
    const center2 = coordinate.getCenter();
    const v0 = sub(p0, center2);
    const v1 = sub(p1, center2);
    const a0 = angle(v0);
    const da = angleBetween(v0, v1);
    const amid = a0 + da / 2;
    const dx = offset2 * Math.cos(amid);
    const dy = offset2 * Math.sin(amid);
    return append3(`translate(${dx}, ${dy})`);
  }
  if (isTranspose(coordinate))
    return append3(`translate(${offset2}, 0)`);
  return append3(`translate(0, ${-offset2})`);
}
function renderBackground(_a) {
  var { document: document2, background, scale: scale4, coordinate, valueof: valueof2 } = _a, rest = __rest72(_a, ["document", "background", "scale", "coordinate", "valueof"]);
  const BACKGROUND_CLASS_NAME = "element-background";
  if (!background)
    return [() => {
    }, () => {
    }];
  const extentOf2 = (scale5, x2, padding) => {
    const ax = scale5.invert(x2);
    const mid2 = x2 + scale5.getBandWidth(ax) / 2;
    const half = scale5.getStep(ax) / 2;
    const offset2 = half * padding;
    return [mid2 - half + offset2, mid2 + half - offset2];
  };
  const sizeXOf = (element, padding) => {
    const { x: scaleX } = scale4;
    if (!isOrdinalScale(scaleX))
      return [0, 1];
    const { __data__: data } = element;
    const { x: x2 } = data;
    const [e1, e24] = extentOf2(scaleX, x2, padding);
    return [e1, e24];
  };
  const sizeYOf = (element, padding) => {
    const { y: scaleY } = scale4;
    if (!isOrdinalScale(scaleY))
      return [0, 1];
    const { __data__: data } = element;
    const { y: y3 } = data;
    const [e1, e24] = extentOf2(scaleY, y3, padding);
    return [e1, e24];
  };
  const bandShapeOf = (element, style) => {
    const { padding } = style;
    const [x12, x2] = sizeXOf(element, padding);
    const [y12, y22] = sizeYOf(element, padding);
    const points = [
      [x12, y12],
      [x2, y12],
      [x2, y22],
      [x12, y22]
    ].map((d3) => coordinate.map(d3));
    const { __data__: data } = element;
    const { y: dy, y1: dy1 } = data;
    return rect(document2, points, { y: dy, y1: dy1 }, coordinate, style);
  };
  const cloneShapeOf = (element, style) => {
    const { transform: transform2 = "scale(1.2, 1.2)", transformOrigin = "center center", stroke: stroke2 = "" } = style, rest2 = __rest72(style, ["transform", "transformOrigin", "stroke"]);
    const finalStyle = Object.assign({ transform: transform2, transformOrigin, stroke: stroke2 }, rest2);
    const shape24 = element.cloneNode(true);
    for (const [key, value2] of Object.entries(finalStyle)) {
      shape24.style[key] = value2;
    }
    return shape24;
  };
  const isOrdinalShape = () => {
    const { x: x2, y: y3 } = scale4;
    return [x2, y3].some(isOrdinalScale);
  };
  const append3 = (element) => {
    if (element.background)
      element.background.remove();
    const _a2 = mapObject(rest, (d3) => valueof2(d3, element)), { fill = "#CCD6EC", fillOpacity = 0.3, zIndex = -2, padding = 1e-3, lineWidth = 0 } = _a2, style = __rest72(_a2, ["fill", "fillOpacity", "zIndex", "padding", "lineWidth"]);
    const finalStyle = Object.assign(Object.assign({}, style), {
      fill,
      fillOpacity,
      zIndex,
      padding,
      lineWidth
    });
    const shapeOf = isOrdinalShape() ? bandShapeOf : cloneShapeOf;
    const shape24 = shapeOf(element, finalStyle);
    shape24.className = BACKGROUND_CLASS_NAME;
    element.parentNode.parentNode.appendChild(shape24);
    element.background = shape24;
  };
  const remove2 = (element) => {
    var _a2;
    (_a2 = element.background) === null || _a2 === void 0 ? void 0 : _a2.remove();
    element.background = null;
  };
  const is = (element) => {
    return element.className === BACKGROUND_CLASS_NAME;
  };
  return [append3, remove2, is];
}
function setCursor(root, cursor) {
  const canvas = root.getRootNode().defaultView;
  const dom2 = canvas.getContextService().getDomElement();
  if (dom2 === null || dom2 === void 0 ? void 0 : dom2.style) {
    root.cursor = dom2.style.cursor;
    dom2.style.cursor = cursor;
  }
}
function restoreCursor(root) {
  setCursor(root, root.cursor);
}
function selectElementByData(elements, data, datum) {
  return elements.find((d3) => Object.entries(data).every(([key, value2]) => datum(d3)[key] === value2));
}
function getPointsR(point6, nextPoint) {
  return Math.sqrt(Math.pow(point6[0] - nextPoint[0], 2) + Math.pow(point6[1] - nextPoint[1], 2));
}
function getPointsPath(points, isClose = false) {
  const path2 = filter_default(points, (d3) => !!d3).map((d3, i2) => {
    return [i2 === 0 ? "M" : "L", ...d3];
  });
  if (isClose) {
    path2.push(["Z"]);
  }
  return path2;
}
function getElements(plot2) {
  return plot2.querySelectorAll(".element");
}
function getThetaPath(center2, points, isBig = 0) {
  const path2 = [["M", ...points[1]]];
  const innerRadius = getPointsR(center2, points[1]);
  const outerRadius = getPointsR(center2, points[0]);
  if (innerRadius === 0) {
    path2.push(["L", ...points[3]], ["A", outerRadius, outerRadius, 0, isBig, 1, ...points[0]], ["Z"]);
  } else {
    path2.push(["A", innerRadius, innerRadius, 0, isBig, 0, ...points[2]], ["L", ...points[3]], ["A", outerRadius, outerRadius, 0, isBig, 1, ...points[0]], ["Z"]);
  }
  return path2;
}
function maybeRoot(node, rootOf) {
  if (rootOf(node))
    return node;
  let root = node.parent;
  while (root && !rootOf(root))
    root = root.parent;
  return root;
}
var VALID_FIND_BY_X_MARKS = ["interval", "point", "density"];
function createFindElementByEvent({ elementsof, root, coordinate, scale: scale4, validFindByXMarks = VALID_FIND_BY_X_MARKS }) {
  var _a, _b;
  let elements = elementsof(root);
  const getValidFindByXMarks = (d3) => validFindByXMarks.includes(d3.markType);
  const hasValidFindByXMarks = elements.find(getValidFindByXMarks);
  if (hasValidFindByXMarks) {
    elements = elements.filter(getValidFindByXMarks);
    const scaleX = scale4.x;
    const scaleSeries = scale4.series;
    const bandWidth3 = (_b = (_a = scaleX === null || scaleX === void 0 ? void 0 : scaleX.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(scaleX)) !== null && _b !== void 0 ? _b : 0;
    const xof = scaleSeries ? (d3) => {
      var _a2, _b2;
      const seriesCount = Math.round(1 / ((_a2 = scaleSeries.valueBandWidth) !== null && _a2 !== void 0 ? _a2 : 1));
      return d3.__data__.x + ((_b2 = d3.__data__.series) !== null && _b2 !== void 0 ? _b2 : 0) * bandWidth3 + bandWidth3 / (seriesCount * 2);
    } : (d3) => d3.__data__.x + bandWidth3 / 2;
    elements.sort((a4, b) => xof(a4) - xof(b));
    return (event) => {
      const mouse = mousePosition(root, event);
      if (!mouse)
        return;
      const [abstractX] = coordinate.invert(mouse);
      const search = bisector(xof).center;
      const i2 = search(elements, abstractX);
      const target = elements[i2];
      return target;
    };
  }
  return (event) => {
    const { target } = event;
    return maybeRoot(target, (node) => {
      if (!node.classList)
        return false;
      return node.classList.includes("element");
    });
  };
}
function calculateSensitivityMultiplier(range3) {
  const BASE_FACTOR = 0.01;
  const MIN_RANGE_FOR_SENSITIVITY = 1e-4;
  const MIN_MULTIPLIER = 0.1;
  const MAX_MULTIPLIER = 100;
  const multiplier = BASE_FACTOR / Math.max(range3, MIN_RANGE_FOR_SENSITIVITY);
  return Math.max(MIN_MULTIPLIER, Math.min(MAX_MULTIPLIER, multiplier));
}
function isFalsyValue(value2) {
  return value2 === false || value2 === null || value2 === void 0;
}
function extractChannelValues(view) {
  var _a, _b;
  const allXChannelValues = [];
  const allYChannelValues = [];
  const markDataPairs = [];
  const marks = view.markState;
  if (marks) {
    for (const [mark2, state] of marks.entries()) {
      if (state === null || state === void 0 ? void 0 : state.channels) {
        const channelData = {};
        for (const channel of state.channels) {
          if ((channel === null || channel === void 0 ? void 0 : channel.name) === "x" && ((_a = channel.values) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            let xValues2 = [];
            for (const valueItem of channel.values) {
              if (valueItem === null || valueItem === void 0 ? void 0 : valueItem.value) {
                xValues2 = xValues2.concat(valueItem.value);
                allXChannelValues.push(valueItem.value);
              }
            }
            channelData["x"] = xValues2;
          } else if (channel && (channel.name === "y" || channel.name.startsWith("y")) && // Support y, y1, y2, y3, etc.
          ((_b = channel.values) === null || _b === void 0 ? void 0 : _b.length) > 0) {
            const channelName = channel.name;
            const channelValues = [];
            for (const valueItem of channel.values) {
              if (valueItem === null || valueItem === void 0 ? void 0 : valueItem.value) {
                const values4 = valueItem.value;
                channelValues.push(values4);
                if (channelName === "y" || channelName === "y1") {
                  if (Array.isArray(values4)) {
                    allYChannelValues.push(values4.flat());
                  } else {
                    allYChannelValues.push([values4]);
                  }
                }
              }
            }
            channelData[channelName] = channelValues;
          }
        }
        const xValues = channelData["x"] || [];
        const yValues = channelData["y"] || [];
        if (xValues.length > 0 && yValues.length > 0) {
          markDataPairs.push({
            markKey: mark2.key || `mark_${markDataPairs.length}`,
            channelData
          });
        }
      }
    }
  }
  return {
    xChannelValues: allXChannelValues.flat(),
    yChannelValues: allYChannelValues.flat(),
    markDataPairs
  };
}
function hasIndependentXYScale(channel1, marks) {
  const scaleKeys = /* @__PURE__ */ new Set();
  for (const mark2 of marks) {
    const { scale: markScale } = mark2;
    const channelScale = markScale === null || markScale === void 0 ? void 0 : markScale[channel1];
    if (!channelScale)
      continue;
    if (channelScale.independent) {
      return true;
    }
    const key = channelScale.key || "default";
    scaleKeys.add(key);
    if (scaleKeys.size > 1) {
      return true;
    }
  }
  return false;
}
function calculateMultiAxisChannelDomains(view, initDomain, scaleX, scaleY, independentInfo) {
  var _a, _b, _c, _d;
  const channelDomain = {
    x: initDomain.x || scaleX.getOptions().domain || [],
    y: initDomain.y || scaleY.getOptions().domain || []
  };
  const info = independentInfo || calculateAllIndependentScaleInfo(view);
  const { hasIndependentX, hasIndependentY } = info;
  if (hasIndependentX || hasIndependentY) {
    let xIndex = 1;
    let yIndex = 1;
    for (const [mark2, state] of view.markState.entries()) {
      if (state === null || state === void 0 ? void 0 : state.channels) {
        if (hasIndependentX) {
          const xChannel = state.channels.find((ch2) => ch2.name === "x");
          if ((_b = (_a = mark2 === null || mark2 === void 0 ? void 0 : mark2.scale) === null || _a === void 0 ? void 0 : _a.x) === null || _b === void 0 ? void 0 : _b.independent) {
            const xKey = `x${xIndex}`;
            channelDomain[xKey] = xChannel.scale.domain;
            xIndex++;
          }
        }
        if (hasIndependentY) {
          const yChannel = state.channels.find((ch2) => ch2.name === "y");
          if ((_d = (_c = mark2 === null || mark2 === void 0 ? void 0 : mark2.scale) === null || _c === void 0 ? void 0 : _c.y) === null || _d === void 0 ? void 0 : _d.independent) {
            const yKey = `y${yIndex}`;
            channelDomain[yKey] = yChannel.scale.domain;
            yIndex++;
          }
        }
      }
    }
  }
  return channelDomain;
}
function calculateAllIndependentScaleInfo(view) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const marks = Array.from(view.markState.keys());
  const hasIndependentX = hasIndependentXYScale("x", marks);
  const hasIndependentY = hasIndependentXYScale("y", marks);
  const marksWithSharedX = [];
  const marksWithIndependentX = [];
  const marksWithSharedY = [];
  const marksWithIndependentY = [];
  const markToXScaleMap = /* @__PURE__ */ new Map();
  const markToYScaleMap = /* @__PURE__ */ new Map();
  const xScaleKeyMap = /* @__PURE__ */ new Map();
  const yScaleKeyMap = /* @__PURE__ */ new Map();
  let xIndex = 1;
  let yIndex = 1;
  for (const [mark2] of view.markState.entries()) {
    const markKey = mark2.key;
    const xScaleKey = ((_b = (_a = mark2 === null || mark2 === void 0 ? void 0 : mark2.scale) === null || _a === void 0 ? void 0 : _a.x) === null || _b === void 0 ? void 0 : _b.key) || "x";
    const hasExplicitIndependentX = !!((_d = (_c = mark2 === null || mark2 === void 0 ? void 0 : mark2.scale) === null || _c === void 0 ? void 0 : _c.x) === null || _d === void 0 ? void 0 : _d.independent);
    if (hasExplicitIndependentX || hasIndependentX && xScaleKey !== "x") {
      marksWithIndependentX.push(markKey);
      if (!xScaleKeyMap.has(xScaleKey)) {
        xScaleKeyMap.set(xScaleKey, xIndex++);
      }
      const scaleIndex = xScaleKeyMap.get(xScaleKey);
      markToXScaleMap.set(markKey, `x${scaleIndex}`);
    } else {
      marksWithSharedX.push(markKey);
      markToXScaleMap.set(markKey, "x");
    }
    const yScaleKey = ((_f = (_e = mark2 === null || mark2 === void 0 ? void 0 : mark2.scale) === null || _e === void 0 ? void 0 : _e.y) === null || _f === void 0 ? void 0 : _f.key) || "y";
    const hasExplicitIndependentY = !!((_h = (_g = mark2 === null || mark2 === void 0 ? void 0 : mark2.scale) === null || _g === void 0 ? void 0 : _g.y) === null || _h === void 0 ? void 0 : _h.independent);
    if (hasExplicitIndependentY || hasIndependentY && yScaleKey !== "y") {
      marksWithIndependentY.push(markKey);
      if (!yScaleKeyMap.has(yScaleKey)) {
        yScaleKeyMap.set(yScaleKey, yIndex++);
      }
      const scaleIndex = yScaleKeyMap.get(yScaleKey);
      markToYScaleMap.set(markKey, `y${scaleIndex}`);
    } else {
      marksWithSharedY.push(markKey);
      markToYScaleMap.set(markKey, "y");
    }
  }
  return {
    hasIndependentX,
    hasIndependentY,
    marksWithSharedX,
    marksWithIndependentX,
    marksWithSharedY,
    marksWithIndependentY,
    markToXScaleMap,
    markToYScaleMap
  };
}

// node_modules/@antv/g2/esm/interaction/legendFilter.js
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CATEGORY_LEGEND_CLASS_NAME = "legend-category";
var CATEGORY_LEGEND_HTML_CLASS_NAME = "legend-html-category";
var CONTINUOUS_LEGEND_CLASS_NAME = "legend-continuous";
var LEGEND_ITEMS_CLASS_NAME = "items-item";
var LEGEND_MAKER_CLASS_NAME = "legend-category-item-marker";
var LEGEND_LABEL_CLASS_NAME = "legend-category-item-label";
var LEGEND_FOCUS_ICON_CLASS_NAME = "legend-category-item-focus-group";
function markerOf(item) {
  return item.getElementsByClassName(LEGEND_MAKER_CLASS_NAME)[0];
}
function labelOf(item) {
  return item.getElementsByClassName(LEGEND_LABEL_CLASS_NAME)[0];
}
function focusIconOf(item) {
  return item.getElementsByClassName(LEGEND_FOCUS_ICON_CLASS_NAME)[0];
}
function itemsOf(root) {
  return root.getElementsByClassName(LEGEND_ITEMS_CLASS_NAME);
}
function legendsOf(root) {
  return root.getElementsByClassName(CATEGORY_LEGEND_CLASS_NAME);
}
function legendsHtmlOf(root) {
  return root.getElementsByClassName(CATEGORY_LEGEND_HTML_CLASS_NAME);
}
function legendsContinuousOf(root) {
  return root.getElementsByClassName(CONTINUOUS_LEGEND_CLASS_NAME);
}
function legendClearSetState(root, setState) {
  const legends = [...legendsOf(root), ...legendsContinuousOf(root)];
  legends.forEach((legend) => {
    setState(legend, (v) => v);
  });
}
function dataOf2(root) {
  let parent = root.parentNode;
  while (parent && !parent.__data__) {
    parent = parent.parentNode;
  }
  return parent.__data__;
}
function getScaleByMarkKey(scale4, markKey, channelName) {
  var _a;
  const seriesKey = Object.keys(scale4).find((channel) => {
    if (channel.startsWith(channelName)) {
      const options = scale4[channel].getOptions();
      return options.name === channelName && options.markKey === markKey;
    }
  });
  return (_a = scale4[seriesKey]) !== null && _a !== void 0 ? _a : scale4[channelName];
}
function legendFilterOrdinal(root, {
  legends,
  // given the root of chart returns legends to be manipulated
  marker: markerOf2,
  // given the legend returns the marker
  label: labelOf2,
  // given the legend returns the label
  datum,
  // given the legend returns the value
  filter: filter2,
  // invoke when dispatch filter event,
  defaultSelect,
  emitter,
  channel,
  state = {}
  // state options
}) {
  const itemClick = /* @__PURE__ */ new Map();
  const itemPointerenter = /* @__PURE__ */ new Map();
  const itemPointerout = /* @__PURE__ */ new Map();
  const focusIconClick = /* @__PURE__ */ new Map();
  const { unselected = {
    markerStroke: "#aaa",
    markerFill: "#aaa",
    labelFill: "#aaa"
  } } = state;
  const markerStyle = { unselected: subObject(unselected, "marker") };
  const labelStyle = { unselected: subObject(unselected, "label") };
  const { setState: setM, removeState: removeM } = useState(markerStyle, void 0);
  const { setState: setL, removeState: removeL } = useState(labelStyle, void 0);
  const items = Array.from(legends(root));
  let selectedValues = items.map(datum);
  const updateLegendState = () => {
    for (const item of items) {
      const value2 = datum(item);
      const marker = markerOf2(item);
      const label = labelOf2(item);
      if (!selectedValues.includes(value2)) {
        setM(marker, "unselected");
        setL(label, "unselected");
      } else {
        removeM(marker, "unselected");
        removeL(label, "unselected");
      }
    }
  };
  for (const item of items) {
    const pointerenter = () => {
      setCursor(root, "pointer");
    };
    const pointerout = () => {
      restoreCursor(root);
    };
    const click = (event) => __awaiter7(this, void 0, void 0, function* () {
      const value2 = datum(item);
      const index2 = selectedValues.indexOf(value2);
      if (index2 === -1)
        selectedValues.push(value2);
      else
        selectedValues.splice(index2, 1);
      yield filter2(selectedValues);
      updateLegendState();
      const { nativeEvent = true } = event;
      if (!nativeEvent)
        return;
      if (selectedValues.length === items.length) {
        emitter.emit("legend:reset", { nativeEvent });
      } else {
        emitter.emit("legend:filter", Object.assign(Object.assign({}, event), { nativeEvent, data: {
          channel,
          values: selectedValues
        } }));
      }
    });
    item.addEventListener("click", click);
    item.addEventListener("pointerenter", pointerenter);
    item.addEventListener("pointerout", pointerout);
    itemClick.set(item, click);
    itemPointerenter.set(item, pointerenter);
    itemPointerout.set(item, pointerout);
    const focusIcon = focusIconOf(item);
    if (focusIcon) {
      const focusClick = (event) => __awaiter7(this, void 0, void 0, function* () {
        event.stopPropagation();
        const value2 = datum(item);
        const index2 = selectedValues.indexOf(value2);
        const { nativeEvent = true } = event;
        if (index2 !== -1 && selectedValues.length === 1) {
          if (!nativeEvent)
            return;
          selectedValues = items.map(datum);
          yield filter2(selectedValues);
          updateLegendState();
          emitter.emit("legend:reset", { nativeEvent });
        } else {
          selectedValues = [value2];
          yield filter2(selectedValues);
          updateLegendState();
          if (!nativeEvent)
            return;
          emitter.emit("legend:focus", Object.assign(Object.assign({}, event), { nativeEvent, data: {
            channel,
            value: value2
          } }));
        }
      });
      focusIcon.addEventListener("click", focusClick);
      focusIconClick.set(item, focusClick);
    }
  }
  const onFocus = (event) => __awaiter7(this, void 0, void 0, function* () {
    const { nativeEvent } = event;
    if (nativeEvent)
      return;
    const { data } = event;
    const { channel: specifiedChannel, value: value2 } = data;
    if (specifiedChannel !== channel)
      return;
    selectedValues = [value2];
    yield filter2(selectedValues);
    updateLegendState();
  });
  const onFilter = (event) => __awaiter7(this, void 0, void 0, function* () {
    const { nativeEvent } = event;
    if (nativeEvent)
      return;
    const { data } = event;
    const { channel: specifiedChannel, values: values4 } = data;
    if (specifiedChannel !== channel)
      return;
    selectedValues = values4;
    yield filter2(selectedValues);
    updateLegendState();
  });
  const onEnd = (event) => __awaiter7(this, void 0, void 0, function* () {
    const { nativeEvent } = event;
    if (nativeEvent)
      return;
    selectedValues = items.map(datum);
    yield filter2(selectedValues);
    updateLegendState();
  });
  emitter.on("legend:filter", onFilter);
  emitter.on("legend:focus", onFocus);
  emitter.on("legend:reset", onEnd);
  if (defaultSelect) {
    emitter.emit("legend:filter", {
      data: { channel, values: defaultSelect }
    });
  }
  return () => {
    for (const item of items) {
      item.removeEventListener("click", itemClick.get(item));
      item.removeEventListener("pointerenter", itemPointerenter.get(item));
      item.removeEventListener("pointerout", itemPointerout.get(item));
      const focusIcon = focusIconOf(item);
      if (focusIcon) {
        focusIcon.removeEventListener("click", focusIconClick.get(item));
      }
    }
    emitter.off("legend:focus", onFocus);
    emitter.off("legend:filter", onFilter);
    emitter.off("legend:reset", onEnd);
  };
}
function legendFilterOrdinalHtml(root, { domain, filter: filter2, defaultSelect, emitter, channel }) {
  const htmlItemClick = /* @__PURE__ */ new Map();
  const htmlItemPointerenter = /* @__PURE__ */ new Map();
  const htmlItemPointerout = /* @__PURE__ */ new Map();
  let selectedValues = [...domain];
  const getChartContainer = () => {
    var _a;
    const view = (_a = root.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
    if (!view)
      return document.body;
    const canvas = view.getContextService().getDomElement();
    return canvas.parentElement || document.body;
  };
  const bindHtmlDomEvents = () => {
    const chartContainer = getChartContainer();
    const htmlContainer = chartContainer.querySelector(".legend-html");
    const htmlClick = (event) => __awaiter7(this, void 0, void 0, function* () {
      let targetElement = event.target;
      while (targetElement && !targetElement.hasAttribute("legend-value")) {
        targetElement = targetElement.parentElement;
        if (targetElement === htmlContainer)
          break;
      }
      if (!targetElement || !targetElement.hasAttribute("legend-value"))
        return;
      event.preventDefault();
      event.stopPropagation();
      const value2 = targetElement.getAttribute("legend-value");
      if (!value2)
        return;
      const index2 = selectedValues.indexOf(value2);
      if (index2 === -1)
        selectedValues.push(value2);
      else
        selectedValues.splice(index2, 1);
      yield filter2(selectedValues);
      updateHtmlLegendState();
      if (selectedValues.length === domain.length) {
        emitter.emit("legend:reset", { nativeEvent: true });
      } else {
        emitter.emit("legend:filter", {
          nativeEvent: true,
          data: {
            channel,
            values: selectedValues
          }
        });
      }
    });
    htmlContainer.addEventListener("click", htmlClick);
    htmlItemClick.set(htmlContainer, htmlClick);
  };
  const updateHtmlLegendState = () => {
    const chartContainer = getChartContainer();
    const htmlLegendItems = chartContainer.querySelectorAll("[legend-value]");
    htmlLegendItems.forEach((htmlItem) => {
      const value2 = htmlItem.getAttribute("legend-value");
      if (!value2)
        return;
      if (!domain.includes(value2))
        return;
      const isSelected = selectedValues.includes(value2);
      const htmlElement = htmlItem;
      if (!isSelected) {
        htmlElement.style.opacity = "0.4";
        htmlElement.classList.add("legend-item-inactive");
      } else {
        htmlElement.style.opacity = "1";
        htmlElement.classList.remove("legend-item-inactive");
      }
    });
  };
  bindHtmlDomEvents();
  const onFocus = (event) => __awaiter7(this, void 0, void 0, function* () {
    const { nativeEvent } = event;
    if (nativeEvent)
      return;
    const { data } = event;
    const { channel: specifiedChannel, value: value2 } = data;
    if (specifiedChannel !== channel)
      return;
    selectedValues = [value2];
    yield filter2(selectedValues);
    updateHtmlLegendState();
  });
  const onFilter = (event) => __awaiter7(this, void 0, void 0, function* () {
    const { nativeEvent } = event;
    if (nativeEvent)
      return;
    const { data } = event;
    const { channel: specifiedChannel, values: values4 } = data;
    if (specifiedChannel !== channel)
      return;
    selectedValues = values4;
    yield filter2(selectedValues);
    updateHtmlLegendState();
  });
  const onEnd = (event) => __awaiter7(this, void 0, void 0, function* () {
    const { nativeEvent } = event;
    if (nativeEvent)
      return;
    selectedValues = [...domain];
    yield filter2(selectedValues);
    updateHtmlLegendState();
  });
  emitter.on("legend:filter", onFilter);
  emitter.on("legend:focus", onFocus);
  emitter.on("legend:reset", onEnd);
  if (defaultSelect) {
    emitter.emit("legend:filter", {
      data: { channel, values: defaultSelect }
    });
  }
  return () => {
    const chartContainer = getChartContainer();
    const htmlLegendItems = chartContainer.querySelectorAll("[legend-value]");
    htmlLegendItems.forEach((htmlItem) => {
      const value2 = htmlItem.getAttribute("legend-value");
      if (!value2)
        return;
      if (!domain.includes(value2))
        return;
      const clickHandler = htmlItemClick.get(htmlItem);
      const pointerenterHandler = htmlItemPointerenter.get(htmlItem);
      const pointeroutHandler = htmlItemPointerout.get(htmlItem);
      if (clickHandler) {
        htmlItem.removeEventListener("click", clickHandler);
      }
      if (pointerenterHandler) {
        htmlItem.removeEventListener("pointerenter", pointerenterHandler);
      }
      if (pointeroutHandler) {
        htmlItem.removeEventListener("pointerout", pointeroutHandler);
      }
    });
    htmlItemClick.clear();
    htmlItemPointerenter.clear();
    htmlItemPointerout.clear();
    emitter.off("legend:filter", onFilter);
    emitter.off("legend:focus", onFocus);
    emitter.off("legend:reset", onEnd);
  };
}
function legendFilterContinuous(_, { legend, filter: filter2, emitter, channel }) {
  const { attributes } = legend;
  const onValueChange = (data) => {
    const { value: value2 } = data.detail;
    const domainValue = value2.map((d3) => {
      var _a, _b;
      const matchRealValue = (_a = attributes.data) === null || _a === void 0 ? void 0 : _a.find((item) => item.value === d3);
      if (matchRealValue)
        return (_b = matchRealValue.domainValue) !== null && _b !== void 0 ? _b : d3;
      return d3;
    });
    filter2(domainValue);
    emitter.emit({
      nativeEvent: true,
      data: {
        channel,
        values: domainValue
      }
    });
  };
  legend.addEventListener("valuechange", onValueChange);
  return () => {
    legend.removeEventListener("valuechange", onValueChange);
  };
}
function filterView(context_1, _a) {
  return __awaiter7(this, arguments, void 0, function* (context, {
    legend,
    // Legend instance.
    channel,
    // Filter Channel.
    value: value2,
    // Filtered Values.
    ordinal,
    // Data type of the legend.
    channels,
    // Channels for this legend.
    allChannels,
    // Channels for all legends.
    facet = false
    // For facet.
  }) {
    const { view, update, setState } = context;
    setState(legend, (viewOptions) => {
      var _a2, _b;
      const { marks } = viewOptions;
      const channelScale = (_b = (_a2 = legend.attributes) === null || _a2 === void 0 ? void 0 : _a2.scales) === null || _b === void 0 ? void 0 : _b.find((s3) => s3.name === channel);
      const newMarks = marks.map((mark2) => {
        var _a3, _b2;
        if (
          // if key is not defined, use default channel name.
          ((_a3 = mark2.scale[channel].key) !== null && _a3 !== void 0 ? _a3 : channel) !== ((_b2 = channelScale === null || channelScale === void 0 ? void 0 : channelScale.key) !== null && _b2 !== void 0 ? _b2 : channelScale === null || channelScale === void 0 ? void 0 : channelScale.name)
        )
          return mark2;
        if (mark2.type === "legends")
          return mark2;
        if (ANNOTATION_MARKS.includes(mark2.type))
          return mark2;
        const { transform: transform2 = [], data = [] } = mark2;
        const index2 = transform2.findIndex(({ type }) => type.startsWith("group") || type.startsWith("bin"));
        const newTransform = [...transform2];
        if (data.length) {
          newTransform.splice(index2 + 1, 0, {
            type: "filter",
            [channel]: {
              value: value2,
              ordinal
            }
          });
        }
        const newScale = Object.fromEntries(channels.map((channel2) => {
          const matchScale = getScaleByMarkKey(view.scale, viewOptions.key, channel2);
          return [channel2, { domain: matchScale.getOptions().domain }];
        }));
        return deep_mix_default({}, mark2, Object.assign(Object.assign({ transform: newTransform, scale: newScale }, !ordinal && { animate: false }), { legend: facet ? false : Object.fromEntries(allChannels.map((d3) => [d3, { preserve: true }])) }));
      });
      return Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
    });
    yield update();
  });
}
function filterFacets(facets, options) {
  for (const facet of facets) {
    filterView(facet, Object.assign(Object.assign({}, options), { facet: true }));
  }
}
function LegendFilter() {
  return (context, contexts, emitter) => {
    const { container } = context;
    const facets = contexts.filter((d3) => d3 !== context);
    const isFacet = facets.length > 0;
    const channelsOf = (legend) => {
      return dataOf2(legend).scales.map((d3) => d3.name);
    };
    const legends = [
      ...legendsOf(container),
      ...legendsHtmlOf(container),
      ...legendsContinuousOf(container)
    ];
    const allChannels = legends.flatMap(channelsOf);
    const filter2 = isFacet ? throttle_default(filterFacets, 50, { trailing: true }) : throttle_default(filterView, 50, { trailing: true });
    const removes = legends.map((legend) => {
      const { name: channel, domain } = dataOf2(legend).scales[0];
      const channels = channelsOf(legend);
      const common = {
        legend,
        channel,
        channels,
        allChannels
      };
      if (legend.className === CATEGORY_LEGEND_CLASS_NAME) {
        return legendFilterOrdinal(legend, {
          legends: itemsOf,
          marker: markerOf,
          label: labelOf,
          datum: (d3) => {
            const { __data__: datum } = d3;
            const { index: index2 } = datum;
            return domain[index2];
          },
          filter: (value2) => {
            const options = Object.assign(Object.assign({}, common), { value: value2, ordinal: true });
            if (isFacet)
              filter2(facets, options);
            else
              filter2(context, options);
          },
          state: legend.attributes.state,
          defaultSelect: legend.attributes.defaultSelect,
          channel,
          emitter
        });
      } else if (legend.className === CATEGORY_LEGEND_HTML_CLASS_NAME) {
        return legendFilterOrdinalHtml(container, {
          domain,
          filter: (value2) => {
            const options = Object.assign(Object.assign({}, common), { value: value2, ordinal: true });
            if (isFacet)
              filter2(facets, options);
            else
              filter2(context, options);
          },
          defaultSelect: legend.attributes.defaultSelect,
          channel,
          emitter
        });
      } else {
        return legendFilterContinuous(container, {
          legend,
          filter: (value2) => {
            const options = Object.assign(Object.assign({}, common), { value: value2, ordinal: false });
            if (isFacet)
              filter2(facets, options);
            else
              filter2(context, options);
          },
          emitter,
          channel
        });
      }
    });
    return () => {
      removes.forEach((remove2) => remove2());
    };
  };
}

// node_modules/@antv/g2/esm/component/legendCategory.js
var __rest73 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function inferShape(scales, markState) {
  const shapeScale = scaleOf(scales, "shape");
  const colorScale = scaleOf(scales, "color");
  const shapeScale1 = shapeScale ? shapeScale.clone() : null;
  const shapes = [];
  for (const [mark2, state] of markState) {
    const namespace = mark2.type;
    const domain = (colorScale === null || colorScale === void 0 ? void 0 : colorScale.getOptions().domain.length) > 0 ? colorScale === null || colorScale === void 0 ? void 0 : colorScale.getOptions().domain : state.data;
    const shape24 = domain.map((d3, i2) => {
      var _a;
      if (shapeScale1)
        return shapeScale1.map(d3 || "point");
      return ((_a = mark2 === null || mark2 === void 0 ? void 0 : mark2.style) === null || _a === void 0 ? void 0 : _a.shape) || state.defaultShape || "point";
    });
    if (typeof namespace === "string")
      shapes.push([namespace, shape24]);
  }
  if (shapes.length === 0)
    return ["point", ["point"]];
  if (shapes.length === 1)
    return shapes[0];
  if (!shapeScale)
    return shapes[0];
  const { range: range3 } = shapeScale.getOptions();
  return shapes.map(([namespace, shape24]) => {
    let sum4 = 0;
    for (let i2 = 0; i2 < shapes.length; i2++) {
      const targetShape = range3[i2 % range3.length];
      if (shape24[i2] === targetShape)
        sum4++;
    }
    return [sum4 / shape24.length, [namespace, shape24]];
  }).sort((a4, b) => b[0] - a4[0])[0][1];
}
function inferItemMarker(options, context) {
  const { scales, library: library3, markState } = context;
  const [mark2, shapes] = inferShape(scales, markState);
  const { itemMarker, itemMarkerSize: size4 } = options;
  const create2 = (name2, d3) => {
    var _a, _b, _c;
    const marker = ((_c = (_b = (_a = library3[`mark.${mark2}`]) === null || _a === void 0 ? void 0 : _a.props) === null || _b === void 0 ? void 0 : _b.shape[name2]) === null || _c === void 0 ? void 0 : _c.props.defaultMarker) || last(name2.split("."));
    const radius = typeof size4 === "function" ? size4(d3) : size4;
    return () => useMarker(marker, { color: d3.color })(0, 0, radius);
  };
  const shapeOf = (i2) => `${shapes[i2]}`;
  const shapeScale = scaleOf(scales, "shape");
  if (shapeScale && !itemMarker)
    return (d3, i2) => create2(shapeOf(i2), d3);
  if (typeof itemMarker === "function") {
    return (d3, i2) => {
      const node = itemMarker(d3.id, i2);
      if (typeof node === "string")
        return create2(node, d3);
      return node;
    };
  }
  return (d3, i2) => create2(itemMarker || shapeOf(i2), d3);
}
function inferItemMarkerOpacity(scales) {
  const scale4 = scaleOf(scales, "opacity");
  if (scale4) {
    const { range: range3 } = scale4.getOptions();
    return (d3, i2) => range3[i2];
  }
  return void 0;
}
function inferItemMarkerSize(scales, defaults4) {
  const scale4 = scaleOf(scales, "size");
  if (scale4 instanceof Identity)
    return scale4.map(NaN) * 2;
  return defaults4;
}
function inferItemMarkerLineWidth(options, context) {
  const { scales, markState } = context;
  const [mark2, shapes] = inferShape(scales, markState);
  const { itemMarker, itemMarkerLineWidth } = options;
  if (itemMarkerLineWidth !== void 0) {
    return itemMarkerLineWidth;
  }
  const lineShapes = [
    "line",
    "hyphen",
    "dash",
    "smooth",
    "hv",
    "hvh",
    "vh",
    "vhv"
  ];
  if (typeof itemMarker === "string" && lineShapes.includes(itemMarker)) {
    return 4;
  }
  if (typeof itemMarker === "function") {
    return (d3, i2) => {
      const markerShape = itemMarker(d3.id, i2);
      if (typeof markerShape === "string" && lineShapes.includes(markerShape)) {
        return 4;
      }
      return void 0;
    };
  }
  const shapesArray = Array.isArray(shapes) ? shapes : [shapes];
  const hasLineShape = shapesArray.some((shape24) => lineShapes.includes(shape24));
  if (hasLineShape) {
    return 4;
  }
  return void 0;
}
function inferCategoryStyle(options, context) {
  const { labelFormatter = (d3) => `${d3}` } = options;
  const { scales, theme } = context;
  const defaultSize = theme.legendCategory.itemMarkerSize;
  const itemMarkerSize = inferItemMarkerSize(scales, defaultSize);
  const baseStyle = {
    itemMarker: inferItemMarker(Object.assign(Object.assign({}, options), { itemMarkerSize }), context),
    itemMarkerSize,
    itemMarkerOpacity: inferItemMarkerOpacity(scales),
    itemMarkerLineWidth: inferItemMarkerLineWidth(options, context)
  };
  const finalLabelFormatter = typeof labelFormatter === "string" ? format2(labelFormatter) : labelFormatter;
  const colorScale = scaleOf(scales, "color");
  const domain = domainOf2(scales);
  const colorOf = colorScale ? (d3) => colorScale.map(d3) : () => context.theme.color;
  return Object.assign(Object.assign({}, baseStyle), { data: domain.map((d3) => ({
    id: d3,
    label: finalLabelFormatter(d3),
    color: colorOf(d3)
  })) });
}
function inferLegendShape(value2, options, component) {
  const { position } = options;
  if (position === "center") {
    const { bbox } = value2;
    const { width: width2, height: height2 } = bbox;
    return { width: width2, height: height2 };
  }
  const { width, height } = inferComponentShape(value2, options, component);
  return { width, height };
}
function filterEmptyIds(legendStyle) {
  return Object.assign(Object.assign({}, legendStyle), { data: (legendStyle === null || legendStyle === void 0 ? void 0 : legendStyle.data.filter((item) => item.id !== "")) || [] });
}
var LegendCategory = (options) => {
  const { labelFormatter, layout, order, orientation, position, size: size4, title, cols, itemMarker, render: render3 } = options, style = __rest73(options, ["labelFormatter", "layout", "order", "orientation", "position", "size", "title", "cols", "itemMarker", "render"]);
  const { gridRow } = style;
  return (context) => {
    const { value: value2, theme } = context;
    const { bbox } = value2;
    const { width, height } = inferLegendShape(value2, options, LegendCategory);
    const finalLayout = inferComponentLayout(position, layout);
    const legendStyle = Object.assign(Object.assign(Object.assign(Object.assign({
      orientation: ["right", "left", "center"].includes(position) ? "vertical" : "horizontal",
      width,
      height,
      layout: cols !== void 0 ? "grid" : "flex"
    }, cols !== void 0 && { gridCol: cols }), gridRow !== void 0 && { gridRow }), { titleText: titleContent(title) }), inferCategoryStyle(options, context));
    const { legendCategory: legendTheme = {} } = theme;
    const categoryStyle = adaptor(Object.assign({}, legendTheme, filterEmptyIds(legendStyle), style, {
      classNamePrefix: G2_CLASS_PREFIX
    }));
    if (render3) {
      return new Category({
        className: CATEGORY_LEGEND_HTML_CLASS_NAME,
        style: Object.assign(Object.assign({}, categoryStyle), { x: bbox.x, y: bbox.y, render: render3 })
      });
    }
    const layoutWrapper = new LegendCategoryLayout({
      style: Object.assign(Object.assign({ x: bbox.x, y: bbox.y, width: bbox.width, height: bbox.height }, finalLayout), {
        // @ts-ignore
        subOptions: categoryStyle
      })
    });
    layoutWrapper.appendChild(new Category({
      className: "legend-category",
      style: categoryStyle
    }));
    return layoutWrapper;
  };
};
LegendCategory.props = {
  defaultPosition: "top",
  defaultOrder: 1,
  defaultSize: 40,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/component/legendContinuous.js
var __rest74 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function updateShapeDimensions(shape24, finalSize, orientation) {
  shape24.size = finalSize;
  if (isHorizontal(orientation)) {
    shape24.height = finalSize;
  } else {
    shape24.width = finalSize;
  }
  return shape24;
}
function inferContinuousShape(value2, options, component) {
  const { size: size4 } = options;
  const shape24 = inferComponentShape(value2, options, component);
  return updateShapeDimensions(shape24, size4, shape24.orientation);
}
function getFormatter(max7) {
  return (value2) => ({
    value: value2 / max7,
    label: String(value2),
    // Reference of input original domain value.
    domainValue: value2
  });
}
function getQuantizeOrQuantileConfig(shape24, colorScale, min6, max7, range3) {
  const thresholds = colorScale.thresholds;
  const formatter = getFormatter(max7);
  return Object.assign(Object.assign({}, shape24), { color: range3, data: [min6, ...thresholds, max7].map(formatter) });
}
function getThresholdConfig(shape24, colorScale, range3) {
  const thresholds = colorScale.thresholds;
  const data = [-Infinity, ...thresholds, Infinity].map((value2, index2) => ({
    value: index2,
    // Reference of input original domain value.
    domainValue: value2,
    label: value2
  }));
  return Object.assign(Object.assign({}, shape24), { data, color: range3, labelFilter: (datum, index2) => {
    return index2 > 0 && index2 < data.length - 1;
  } });
}
function rangeOf6(scale4) {
  const { domain } = scale4.getOptions();
  const [min6, max7] = [domain[0], lastOf(domain)];
  return [min6, max7];
}
function createColorScale(scale4, defaultColor) {
  const options = scale4.getOptions();
  const newScale = scale4.clone();
  newScale.update(Object.assign(Object.assign({}, options), { range: [parseColor(defaultColor).toString()] }));
  return newScale;
}
function getLinearConfig(shape24, colorScale, sizeScale, opacityScale, scales, theme) {
  const { length } = shape24;
  const definedScale = sizeScale || opacityScale;
  const defaultColor = scales.color ? theme.legendContinuous.ribbonFill || "black" : theme.color;
  const scale4 = colorScale || createColorScale(definedScale, defaultColor);
  const [min6, max7] = rangeOf6(scale4);
  const [domainMin, domainMax] = rangeOf6([colorScale, sizeScale, opacityScale].filter((d3) => d3 !== void 0).find((d3) => !(d3 instanceof Constant2)));
  return Object.assign(Object.assign({}, shape24), { domain: [domainMin, domainMax], data: scale4.getTicks().map((value2) => ({ value: value2 })), color: new Array(Math.floor(length)).fill(0).map((d3, i2) => {
    const value2 = (max7 - min6) / (length - 1) * i2 + min6;
    const color = scale4.map(value2) || defaultColor;
    const opacity = opacityScale ? opacityScale.map(value2) : 1;
    return color.replace(/rgb[a]*\(([\d]{1,3}) *, *([\d]{1,3}) *, *([\d]{1,3})[\S\s]*\)/, (match, p1, p22, p3) => `rgba(${p1}, ${p22}, ${p3}, ${opacity})`);
  }) });
}
function inferContinuousConfig(scales, scale4, value2, options, component, theme) {
  const colorScale = scaleOf(scales, "color");
  const shape24 = inferContinuousShape(value2, options, component);
  if (colorScale instanceof Threshold) {
    const { range: range3 } = colorScale.getOptions();
    const [min6, max7] = rangeOf6(colorScale);
    if (colorScale instanceof Quantize || colorScale instanceof Quantile) {
      return getQuantizeOrQuantileConfig(shape24, colorScale, min6, max7, range3);
    }
    return getThresholdConfig(shape24, colorScale, range3);
  }
  const sizeScale = scaleOf(scales, "size");
  const opacityScale = scaleOf(scales, "opacity");
  return getLinearConfig(shape24, colorScale, sizeScale, opacityScale, scale4, theme);
}
var LegendContinuous = (options) => {
  const { labelFormatter, layout, order, orientation, position, size: size4, title, style, crossPadding, padding } = options, rest = __rest74(options, ["labelFormatter", "layout", "order", "orientation", "position", "size", "title", "style", "crossPadding", "padding"]);
  return ({ scales, value: value2, theme, scale: scale4 }) => {
    const { bbox } = value2;
    const { x: x2, y: y3, width, height } = bbox;
    const finalLayout = inferComponentLayout(position, layout);
    const { legendContinuous: legendTheme = {} } = theme;
    const finalStyle = adaptor(Object.assign({}, legendTheme, Object.assign(Object.assign(Object.assign({ titleText: titleContent(title), labelAlign: "value", labelFormatter: typeof labelFormatter === "string" ? (d3) => format2(labelFormatter)(d3.label) : labelFormatter }, inferContinuousConfig(scales, scale4, value2, options, LegendContinuous, theme)), style), { classNamePrefix: G2_CLASS_PREFIX }), rest));
    const layoutWrapper = new G2Layout({
      style: Object.assign(Object.assign({
        x: x2,
        y: y3,
        width,
        height
      }, finalLayout), {
        // @ts-ignore
        subOptions: finalStyle
      })
    });
    layoutWrapper.appendChild(new Continuous({
      className: "legend-continuous",
      style: finalStyle
    }));
    return layoutWrapper;
  };
};
LegendContinuous.props = {
  defaultPosition: "top",
  defaultOrientation: "vertical",
  defaultOrder: 1,
  defaultSize: 60,
  defaultLength: 200,
  defaultLegendSize: 60,
  defaultPadding: [20, 10],
  // [horizontal, vertical]
  defaultCrossPadding: [12, 12]
  // [horizontal, vertical]
};

// node_modules/@antv/g2/esm/component/legendContinuousBlock.js
var LegendContinuousBlock = (options) => {
  return (...args) => LegendContinuous(Object.assign({}, { block: true }, options))(...args);
};
LegendContinuousBlock.props = Object.assign(Object.assign({}, LegendContinuous.props), { defaultPosition: "top", defaultOrientation: "horizontal" });

// node_modules/@antv/g2/esm/component/legendContinuousSize.js
var LegendContinuousSize = (options) => {
  return (context) => {
    const { scales } = context;
    const sizeScale = scaleOf(scales, "size");
    return LegendContinuous(Object.assign({}, {
      type: "size",
      data: sizeScale.getTicks().map((value2, index2) => ({
        value: value2,
        label: String(value2)
      }))
    }, options))(context);
  };
};
LegendContinuousSize.props = Object.assign(Object.assign({}, LegendContinuous.props), { defaultPosition: "top", defaultOrientation: "horizontal" });

// node_modules/@antv/g2/esm/component/legendContinuousBlockSize.js
var LegendContinuousBlockSize = (options) => {
  return LegendContinuousSize(Object.assign({}, { block: true }, options));
};
LegendContinuousBlockSize.props = Object.assign(Object.assign({}, LegendContinuous.props), { defaultPosition: "top", defaultOrientation: "horizontal" });

// node_modules/@antv/g2/esm/component/title.js
var __rest75 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function inferStyleByAlign(x2, y3, width, align) {
  switch (align) {
    case "center":
      return {
        x: x2 + width / 2,
        y: y3,
        textAlign: "middle"
      };
    case "right":
      return {
        x: x2 + width,
        y: y3,
        textAlign: "right"
      };
    default:
      return {
        x: x2,
        y: y3,
        textAlign: "left"
      };
  }
}
var Title = createComponent({
  render(attributes, container) {
    const { width, title, subtitle, spacing = 2, align = "left", x: x2, y: y3 } = attributes, style = __rest75(attributes, ["width", "title", "subtitle", "spacing", "align", "x", "y"]);
    container.style.transform = `translate(${x2}, ${y3})`;
    const titleStyle = subObject(style, "title");
    const subtitleStyle = subObject(style, "subtitle");
    const mainTitle = maybeAppend(container, ".title", "text").attr("className", "title").call(applyStyle, Object.assign(Object.assign(Object.assign({}, inferStyleByAlign(0, 0, width, align)), { fontSize: 14, textBaseline: "top", text: title }), titleStyle)).node();
    const bounds = mainTitle.getLocalBounds();
    maybeAppend(container, ".sub-title", "text").attr("className", "sub-title").call((selection) => {
      if (!subtitle)
        return selection.node().remove();
      selection.node().attr(Object.assign(Object.assign(Object.assign({}, inferStyleByAlign(0, bounds.max[1] + spacing, width, align)), { fontSize: 12, textBaseline: "top", text: subtitle }), subtitleStyle));
    });
  }
});
var TitleComponent = (options) => {
  return ({ value: value2, theme }) => {
    const { x: x2, y: y3, width, height } = value2.bbox;
    return new Title({
      style: deep_mix_default({}, theme.title, Object.assign({
        x: x2,
        y: y3,
        width,
        height
      }, options))
    });
  };
};
TitleComponent.props = {
  defaultPosition: "top",
  defaultOrder: 2,
  defaultSize: 36,
  defaultCrossPadding: [20, 20],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/component/slider.js
var __rest76 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function inferPosition2(bbox, position, trackSize) {
  const { x: x2, y: y3, width, height } = bbox;
  if (position === "left")
    return [x2 + width - trackSize, y3];
  if (position === "right")
    return [x2, y3];
  if (position === "bottom")
    return [x2, y3];
  if (position === "top")
    return [x2, y3 + height - trackSize];
}
var Slider2 = (options) => {
  const { orientation, labelFormatter, size: size4, style = {}, position } = options, rest = __rest76(options, ["orientation", "labelFormatter", "size", "style", "position"]);
  return (context) => {
    var _a;
    const { scales: [scale4], value: value2, theme, coordinate } = context;
    const { bbox } = value2;
    const { width, height } = bbox;
    const { slider: sliderTheme = {} } = theme;
    const defaultFormatter = ((_a = scale4.getFormatter) === null || _a === void 0 ? void 0 : _a.call(scale4)) || ((v) => v + "");
    const formatter = typeof labelFormatter === "string" ? format2(labelFormatter) : labelFormatter;
    const isHorizontal2 = orientation === "horizontal";
    const reverse2 = isTranspose(coordinate) && isHorizontal2;
    const { trackSize = sliderTheme.trackSize } = style;
    const [x05, y05] = inferPosition2(bbox, position, trackSize);
    return new Slider({
      className: "slider",
      style: Object.assign({}, sliderTheme, Object.assign(Object.assign({ x: x05, y: y05, trackLength: isHorizontal2 ? width : height, orientation, formatter: (v) => {
        const f2 = formatter || defaultFormatter;
        const v1 = reverse2 ? 1 - v : v;
        const tick2 = invert(scale4, v1, true);
        return f2(tick2);
      }, sparklineData: inferSparklineData(options, context) }, style), rest))
    });
  };
};
function markValue(markState, channels) {
  const [value2] = Array.from(markState.entries()).filter(([mark2]) => mark2.type === "line" || mark2.type === "area" || mark2.type === "interval").filter(([mark2]) => mark2.slider).map(([mark2]) => {
    const { encode, slider } = mark2;
    if (slider === null || slider === void 0 ? void 0 : slider.x) {
      const channel = (name2) => {
        const channel2 = encode[name2];
        return [name2, channel2 ? channel2.value : void 0];
      };
      return Object.fromEntries(channels.map(channel));
    }
  });
  if (!(value2 === null || value2 === void 0 ? void 0 : value2.series))
    return value2 === null || value2 === void 0 ? void 0 : value2.y;
  const result = value2.series.reduce((acc, curr, index2) => {
    acc[curr] = acc[curr] || [];
    acc[curr].push(value2.y[index2]);
    return acc;
  }, {});
  return Object.values(result);
}
function inferSparklineData(options, context) {
  const { markState } = context;
  if (isArray(options.sparklineData))
    return options.sparklineData;
  return markValue(markState, ["y", "series"]);
}
Slider2.props = {
  defaultPosition: "bottom",
  defaultSize: 24,
  defaultOrder: 1,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/component/sliderX.js
var SliderX = (options) => {
  return Slider2(Object.assign(Object.assign({}, options), { orientation: "horizontal" }));
};
SliderX.props = Object.assign(Object.assign({}, Slider2.props), { defaultPosition: "bottom" });

// node_modules/@antv/g2/esm/component/sliderY.js
var SliderY = (options) => {
  return Slider2(Object.assign(Object.assign({}, options), { orientation: "vertical" }));
};
SliderY.props = Object.assign(Object.assign({}, Slider2.props), { defaultPosition: "left" });

// node_modules/@antv/g2/esm/component/scrollbar.js
var __rest77 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var Scrollbar2 = (options) => {
  const { orientation, labelFormatter, style } = options, rest = __rest77(options, ["orientation", "labelFormatter", "style"]);
  return ({ scales: [scale4], value: value2, theme }) => {
    const { bbox } = value2;
    const { x: x2, y: y3, width, height } = bbox;
    const { scrollbar: scrollbarTheme = {} } = theme;
    const { ratio, range: range3 } = scale4.getOptions();
    const mainSize = orientation === "horizontal" ? width : height;
    const actualSize = mainSize / ratio;
    const [r0, r1] = range3;
    const value1 = r1 > r0 ? 0 : 1;
    return new Scrollbar({
      className: `${G2_CLASS_PREFIX}scrollbar`,
      style: Object.assign({}, scrollbarTheme, Object.assign(Object.assign(Object.assign(Object.assign({}, style), {
        x: x2,
        y: y3,
        trackLength: mainSize,
        value: value1
      }), rest), { orientation, contentLength: actualSize, viewportLength: mainSize }))
    });
  };
};
Scrollbar2.props = {
  defaultPosition: "bottom",
  defaultSize: 24,
  defaultOrder: 1,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/component/scrollbarX.js
var ScrollbarX = (options) => {
  return Scrollbar2(Object.assign(Object.assign({}, options), { orientation: "horizontal" }));
};
ScrollbarX.props = Object.assign(Object.assign({}, Scrollbar2.props), { defaultPosition: "bottom" });

// node_modules/@antv/g2/esm/component/scrollbarY.js
var ScrollbarY = (options) => {
  return Scrollbar2(Object.assign(Object.assign({}, options), { orientation: "vertical" }));
};
ScrollbarY.props = Object.assign(Object.assign({}, Scrollbar2.props), { defaultPosition: "left" });

// node_modules/@antv/g2/esm/component/legends.js
var Legends = (options) => {
  return () => {
    return new Group();
  };
};
Legends.props = {};

// node_modules/@antv/g2/esm/animation/scaleInX.js
var ScaleInX = (options, context) => {
  const ZERO = 1e-4;
  const { coordinate } = context;
  return (from, _, defaults4) => {
    const [shape24] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape24.style;
    const [transformOrigin, transform2] = isTranspose(coordinate) ? [`left bottom`, `scale(1, ${ZERO})`] : [`left top`, `scale(${ZERO}, 1)`];
    const keyframes = [
      {
        transform: `${prefix} ${transform2}`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      },
      {
        transform: `${prefix} ${transform2}`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.01
      },
      {
        transform: `${prefix} scale(1, 1)`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity
      }
    ];
    const animation = shape24.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/scaleOutX.js
var ScaleOutX = (options, context) => {
  const ZERO = 1e-4;
  const { coordinate } = context;
  return (from, _, defaults4) => {
    const [shape24] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape24.style;
    const [transformOrigin, transform2] = isTranspose(coordinate) ? [`left bottom`, `scale(1, ${ZERO})`] : [`left top`, `scale(${ZERO}, 1)`];
    const keyframes = [
      {
        transform: `${prefix} scale(1, 1)`.trimStart(),
        transformOrigin
      },
      {
        transform: `${prefix} ${transform2}`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.99
      },
      {
        transform: `${prefix} ${transform2}`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      }
    ];
    const animation = shape24.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/scaleInY.js
var ScaleInY = (options, context) => {
  const ZERO = 1e-4;
  const { coordinate } = context;
  CSS.registerProperty({
    name: "scaleInYRadius",
    inherits: false,
    initialValue: "",
    interpolable: true,
    syntax: PropertySyntax.NUMBER
  });
  return (from, _, defaults4) => {
    const [shape24] = from;
    const PolarScaleInY = (shape25) => {
      const { __data__, style } = shape25;
      const { fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = style;
      const { points, y: y3, y1: y12 } = __data__;
      const arcObject = getArcObject(coordinate, points, [y3, y12]);
      const { innerRadius, outerRadius } = arcObject;
      const keyframes = [
        {
          scaleInYRadius: innerRadius + ZERO,
          fillOpacity: 0,
          strokeOpacity: 0,
          opacity: 0
        },
        {
          scaleInYRadius: innerRadius + ZERO,
          fillOpacity,
          strokeOpacity,
          opacity,
          offset: 0.01
        },
        {
          scaleInYRadius: outerRadius,
          fillOpacity,
          strokeOpacity,
          opacity
        }
      ];
      const animation = shape25.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
      return animation;
    };
    const RectangularScaleInY = (shape25) => {
      const { style } = shape25;
      const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = style;
      const [transformOrigin, transform2] = isTranspose(coordinate) ? [`left top`, `scale(${ZERO}, 1)`] : [`left bottom`, `scale(1, ${ZERO})`];
      const keyframes = [
        {
          transform: `${prefix} ${transform2}`.trimStart(),
          transformOrigin,
          fillOpacity: 0,
          strokeOpacity: 0,
          opacity: 0
        },
        {
          transform: `${prefix} ${transform2}`.trimStart(),
          transformOrigin,
          fillOpacity,
          strokeOpacity,
          opacity,
          offset: 0.01
        },
        {
          transform: `${prefix} scale(1, 1)`.trimStart(),
          transformOrigin,
          fillOpacity,
          strokeOpacity,
          opacity
        }
      ];
      const animation = shape25.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
      return animation;
    };
    if (isPolar(coordinate)) {
      return PolarScaleInY(shape24);
    } else {
      return RectangularScaleInY(shape24);
    }
  };
};

// node_modules/@antv/g2/esm/animation/scaleOutY.js
var ScaleOutY = (options, context) => {
  const ZERO = 1e-4;
  const { coordinate } = context;
  return (from, _, defaults4) => {
    const [shape24] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape24.style;
    const [transformOrigin, transform2] = isTranspose(coordinate) ? [`left top`, `scale(${ZERO}, 1)`] : [`left bottom`, `scale(1, ${ZERO})`];
    const keyframes = [
      {
        transform: `${prefix} scale(1, 1)`.trimStart(),
        transformOrigin
      },
      {
        transform: `${prefix} ${transform2}`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.99
      },
      {
        transform: `${prefix} ${transform2}`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      }
    ];
    const animation = shape24.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/fadeIn.js
var FadeIn = (options) => {
  return (from, _, defaults4) => {
    const [shape24] = from;
    const { fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape24.style;
    const keyframes = [
      { fillOpacity: 0, strokeOpacity: 0, opacity: 0 },
      {
        fillOpacity,
        strokeOpacity,
        opacity
      }
    ];
    return shape24.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
  };
};
FadeIn.props = {};

// node_modules/@antv/g2/esm/animation/fadeOut.js
var FadeOut = (options) => {
  return (from, _, defaults4) => {
    const [shape24] = from;
    const { fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape24.style;
    const keyframes = [
      {
        fillOpacity,
        strokeOpacity,
        opacity
      },
      { fillOpacity: 0, strokeOpacity: 0, opacity: 0 }
    ];
    return shape24.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
  };
};
FadeOut.props = {};

// node_modules/@antv/g2/esm/animation/utils.js
var DEFAULT_ATTRIBUTE_VALUE = {
  opacity: 1,
  strokeOpacity: 1,
  fillOpacity: 1,
  lineWidth: 0,
  x: 0,
  y: 0,
  cx: 0,
  cy: 0,
  r: 0,
  rx: 0,
  ry: 0,
  width: 0,
  height: 0
};
var GEOMETRY_ATTRIBUTES = {
  [Shape.CIRCLE]: ["cx", "cy", "r"],
  [Shape.ELLIPSE]: ["cx", "cy", "rx", "ry"],
  [Shape.RECT]: ["x", "y", "width", "height"],
  [Shape.IMAGE]: ["x", "y", "width", "height"],
  [Shape.LINE]: ["x1", "y1", "x2", "y2"],
  [Shape.POLYLINE]: ["points"],
  [Shape.POLYGON]: ["points"]
};
function attributeOf(shape24, keys, useDefaultValue = false) {
  const attribute = {};
  for (const key of keys) {
    const value2 = shape24.style[key];
    if (value2) {
      attribute[key] = value2;
    } else if (useDefaultValue) {
      attribute[key] = DEFAULT_ATTRIBUTE_VALUE[key];
    }
  }
  return attribute;
}
var attributeKeys = [
  "fill",
  "stroke",
  "fillOpacity",
  "strokeOpacity",
  "opacity",
  "lineWidth"
];

// node_modules/@antv/g2/esm/animation/morphing.js
function localBBoxOf(shape24) {
  const { min: min6, max: max7 } = shape24.getLocalBounds();
  const [x05, y05] = min6;
  const [x12, y12] = max7;
  const height = y12 - y05;
  const width = x12 - x05;
  return [x05, y05, width, height];
}
function d2(bbox) {
  const [x2, y3, width, height] = bbox;
  return `
    M ${x2} ${y3}
    L ${x2 + width} ${y3}
    L ${x2 + width} ${y3 + height}
    L ${x2} ${y3 + height}
    Z
  `;
}
function pack2(shape24, count4) {
  const [x05, y05, width, height] = localBBoxOf(shape24);
  const aspect = height / width;
  const col = Math.ceil(Math.sqrt(count4 / aspect));
  const row = Math.ceil(count4 / col);
  const B = [];
  const h2 = height / row;
  let j = 0;
  let n2 = count4;
  while (n2 > 0) {
    const c5 = Math.min(n2, col);
    const w2 = width / c5;
    for (let i2 = 0; i2 < c5; i2++) {
      const x2 = x05 + i2 * w2;
      const y3 = y05 + j * h2;
      B.push(d2([x2, y3, w2, h2]));
    }
    n2 -= c5;
    j += 1;
  }
  return B;
}
function normalizeSplit(split = "pack") {
  if (typeof split == "function")
    return split;
  return pack2;
}
function shapeToShape(from, to, timeEffect) {
  let { transform: fromTransform } = from.style;
  const { transform: toTransform } = to.style;
  replaceChild(to, from);
  let keys = attributeKeys;
  if (from.nodeName === Shape.GROUP) {
    const [x05, y05, w0, h0] = localBBoxOf(from);
    const [x12, y12, w1, h1] = localBBoxOf(to);
    const dx = x05 - x12;
    const dy = y05 - y12;
    const sx = w0 / w1;
    const sy = h0 / h1;
    fromTransform = `translate(${dx}, ${dy}) scale(${sx}, ${sy})`;
  } else {
    keys = keys.concat(GEOMETRY_ATTRIBUTES[from.nodeName] || []);
  }
  const keyframes = [
    Object.assign({ transform: fromTransform !== null && fromTransform !== void 0 ? fromTransform : "none" }, attributeOf(from, keys, true)),
    Object.assign({ transform: toTransform !== null && toTransform !== void 0 ? toTransform : "none" }, attributeOf(to, keys, true))
  ];
  const animation = to.animate(keyframes, timeEffect);
  return animation;
}
function replaceChild(newChild, oldChild) {
  newChild["__data__"] = oldChild["__data__"];
  newChild.className = oldChild.className;
  newChild.markType = oldChild.markType;
  oldChild.parentNode.replaceChild(newChild, oldChild);
}
function maybePath(node, d3) {
  const { nodeName } = node;
  if (nodeName === "path")
    return node;
  const path2 = new Path({
    style: Object.assign(Object.assign({}, attributeOf(node, attributeKeys)), { d: d3 })
  });
  replaceChild(path2, node);
  return path2;
}
function hasUniqueString(search, pattern) {
  const first3 = search.indexOf(pattern);
  const last6 = search.lastIndexOf(pattern);
  return first3 === last6;
}
function hasSubPath(path2) {
  return !hasUniqueString(path2, "m") || !hasUniqueString(path2, "M");
}
function shape2path(shape24) {
  const path2 = convertToPath(shape24);
  if (!path2)
    return;
  if (hasSubPath(path2))
    return;
  return path2;
}
function hasMarker(shape24) {
  const { nodeName } = shape24;
  if (nodeName === "path") {
    const attributes = get_default(shape24, "attributes");
    return attributes.markerEnd || attributes.markerStart;
  }
  return false;
}
function oneToOne(shape24, from, to, timeEffect) {
  const { nodeName: fromName } = from;
  const { nodeName: toName } = to;
  const fromPath = shape2path(from);
  const toPath = shape2path(to);
  const { opacity: fromOpacity = 1, strokeOpacity: fromStrokeOpacity = 1, fillOpacity: fromFillOpacity = 1 } = from.style;
  const { opacity: toOpacity = 1, strokeOpacity: toStrokeOpacity = 1, fillOpacity: toFillOpacity = 1 } = to.style;
  const isSameNodes = fromName === toName && fromName !== "path";
  const hasNonPathNode = fromPath === void 0 || toPath === void 0;
  const isPathWithMarker = hasMarker(from) || hasMarker(to);
  if (isSameNodes || hasNonPathNode || isPathWithMarker)
    return shapeToShape(from, to, timeEffect);
  const pathShape = maybePath(shape24, fromPath);
  const fromKeyframes = Object.assign(Object.assign({}, attributeOf(from, attributeKeys)), { opacity: fromOpacity, strokeOpacity: fromStrokeOpacity, fillOpacity: fromFillOpacity });
  const toKeyframes = Object.assign(Object.assign({}, attributeOf(to, attributeKeys)), { opacity: toOpacity, strokeOpacity: toStrokeOpacity, fillOpacity: toFillOpacity });
  const keyframes = [fromKeyframes, toKeyframes];
  if (fromPath !== toPath) {
    keyframes[0].d = fromPath;
    keyframes[1].d = toPath;
    const animation = pathShape.animate(keyframes, timeEffect);
    animation.onfinish = () => {
      copyAttributes(pathShape, to);
      pathShape.style.d = toPath;
      pathShape.style.transform = "none";
    };
    pathShape.style.transform = "none";
    return animation;
  }
  if (!is_equal_default(fromKeyframes, toKeyframes)) {
    return pathShape.animate(keyframes, timeEffect);
  }
  return null;
}
function oneToMultiple(from, to, timeEffect, split) {
  from.style.visibility = "hidden";
  const D = split(from, to.length);
  return to.map((shape24, i2) => {
    const path2 = new Path({
      style: Object.assign({ d: D[i2] }, attributeOf(from, attributeKeys))
    });
    return oneToOne(shape24, path2, shape24, timeEffect);
  });
}
function multipleToOne(from, to, timeEffect, split) {
  const D = split(to, from.length);
  const { fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = to.style;
  const keyframes = [
    { fillOpacity: 0, strokeOpacity: 0, opacity: 0 },
    { fillOpacity: 0, strokeOpacity: 0, opacity: 0, offset: 0.99 },
    {
      fillOpacity,
      strokeOpacity,
      opacity
    }
  ];
  const animation = to.animate(keyframes, timeEffect);
  const animations = from.map((shape24, i2) => {
    const path2 = new Path({
      style: {
        d: D[i2],
        fill: to.style.fill
      }
    });
    return oneToOne(shape24, shape24, path2, timeEffect);
  });
  return [...animations, animation];
}
var Morphing = (options) => {
  return (from, to, defaults4) => {
    const split = normalizeSplit(options.split);
    const timeEffect = Object.assign(Object.assign({}, defaults4), options);
    const { length: fl } = from;
    const { length: tl } = to;
    if (fl === 1 && tl === 1 || fl > 1 && tl > 1) {
      const [f2] = from;
      const [t] = to;
      return oneToOne(f2, f2, t, timeEffect);
    }
    if (fl === 1 && tl > 1) {
      const [f2] = from;
      return oneToMultiple(f2, to, timeEffect, split);
    }
    if (fl > 1 && tl === 1) {
      const [t] = to;
      return multipleToOne(from, t, timeEffect, split);
    }
    return null;
  };
};
Morphing.props = {};

// node_modules/@antv/g2/esm/animation/waveIn.js
var WaveIn = (options, context) => {
  const ZERO = 1e-4;
  CSS.registerProperty({
    name: "waveInArcAngle",
    inherits: false,
    initialValue: "",
    interpolable: true,
    syntax: PropertySyntax.NUMBER
  });
  const { coordinate } = context;
  return (from, to, defaults4) => {
    const [shape24] = from;
    if (!isPolar(coordinate)) {
      return ScaleInX(options, context)(from, to, defaults4);
    }
    const { __data__, style } = shape24;
    const { radius = 0, inset = 0, fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = style;
    const { points, y: y3, y1: y12 } = __data__;
    const path2 = arc_default().cornerRadius(radius).padAngle(inset * Math.PI / 180);
    const arcObject = getArcObject(coordinate, points, [y3, y12]);
    const { startAngle, endAngle } = arcObject;
    const keyframes = [
      // Use custom interpolable CSS property.
      {
        waveInArcAngle: startAngle + ZERO,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      },
      {
        waveInArcAngle: startAngle + ZERO,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.01
      },
      {
        waveInArcAngle: endAngle,
        fillOpacity,
        strokeOpacity,
        opacity
      }
    ];
    const animation = shape24.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
    animation.onframe = function() {
      shape24.style.d = path2(Object.assign(Object.assign({}, arcObject), { endAngle: Number(shape24.style.waveInArcAngle) }));
    };
    animation.onfinish = function() {
      shape24.style.d = path2(Object.assign(Object.assign({}, arcObject), { endAngle }));
    };
    return animation;
  };
};
WaveIn.props = {};

// node_modules/@antv/g2/esm/animation/zoomIn.js
var ZoomIn = (options) => {
  const ZERO = 1e-4;
  return (from, _, defaults4) => {
    const [shape24] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape24.style;
    const transformOrigin = "center center";
    const keyframes = [
      {
        transform: `${prefix} scale(${ZERO})`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      },
      {
        transform: `${prefix} scale(${ZERO})`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.01
      },
      {
        transform: `${prefix} scale(1)`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity
      }
    ];
    const animation = shape24.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/zoomOut.js
var ZoomOut = (options) => {
  const ZERO = 1e-4;
  return (from, _, defaults4) => {
    const [shape24] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape24.style;
    const transformOrigin = "center center";
    const keyframes = [
      { transform: `${prefix} scale(1)`.trimStart(), transformOrigin },
      {
        transform: `${prefix} scale(${ZERO})`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.99
      },
      {
        transform: `${prefix} scale(${ZERO})`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      }
    ];
    const animation = shape24.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/pathIn.js
var PathIn = (options) => {
  return (from, _, defaults4) => {
    var _a, _b;
    const [shape24] = from;
    const length = ((_b = (_a = shape24).getTotalLength) === null || _b === void 0 ? void 0 : _b.call(_a)) || 0;
    const keyframes = [
      { lineDash: [0, length] },
      { lineDash: [length, 0] }
    ];
    return shape24.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
  };
};
PathIn.props = {};

// node_modules/@antv/g2/esm/animation/growInX.js
var GrowInX = (options, context) => {
  return (from, to, defaults4) => {
    const [shape24] = from;
    const { min: [x2, y3], halfExtents } = shape24.getLocalBounds();
    const width = halfExtents[0] * 2;
    const height = halfExtents[1] * 2;
    const clipPath = new Path({
      style: {
        d: `M${x2},${y3}L${x2 + width},${y3}L${x2 + width},${y3 + height}L${x2},${y3 + height}Z`
      }
    });
    shape24.appendChild(clipPath);
    shape24.style.clipPath = clipPath;
    const animation = ScaleInX(options, context)([clipPath], to, defaults4);
    return animation;
  };
};
GrowInX.props = {};

// node_modules/@antv/g2/esm/animation/growInY.js
var GrowInY = (options, context) => {
  return (from, to, defaults4) => {
    const [shape24] = from;
    const { min: [x2, y3], halfExtents } = shape24.getLocalBounds();
    const width = halfExtents[0] * 2;
    const height = halfExtents[1] * 2;
    const clipPath = new Path({
      style: {
        d: `M${x2},${y3}L${x2 + width},${y3}L${x2 + width},${y3 + height}L${x2},${y3 + height}Z`
      }
    });
    shape24.appendChild(clipPath);
    shape24.style.clipPath = clipPath;
    const animation = ScaleInY(options, context)([clipPath], to, defaults4);
    return animation;
  };
};
GrowInY.props = {};

// node_modules/@antv/g2/esm/interaction/elementHighlight.js
var __rest78 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function elementHighlight(root, {
  elements: elementsof,
  // given the root of chart returns elements to be manipulated
  datum,
  // given each element returns the datum of it
  groupKey: eleGroupKey = (d3) => d3,
  // group elements by specified key
  regionGroupKey = (d3) => d3,
  // how to group elements when hover region
  link: link3 = false,
  // draw link or not
  background = false,
  // draw background or not
  delay = 60,
  // delay to unhighlighted element
  scale: scale4,
  coordinate,
  emitter,
  state = {},
  region = false,
  regionEleFilter = (el) => VALID_FIND_BY_X_MARKS.includes(el.markType)
  // some elements can not be highlighted by region, like shapes in pie.
}) {
  var _a, _b;
  const allElements = (_a = elementsof(root)) !== null && _a !== void 0 ? _a : [];
  const elements = region ? allElements.filter(regionEleFilter) : allElements;
  const elementSet = new Set(elements);
  const groupKey = region ? regionGroupKey : eleGroupKey;
  const keyGroup = group(elements, groupKey);
  const findElement = createFindElementByEvent({
    elementsof,
    root,
    coordinate,
    scale: scale4
  });
  const valueof2 = createValueof(elements, datum);
  const [appendLink, removeLink] = renderLink(Object.assign({
    elements,
    valueof: valueof2,
    link: link3,
    coordinate
  }, subObject(state.active, "link")));
  const [appendBackground, removeBackground, isBackground] = renderBackground(Object.assign({
    document: root.ownerDocument,
    scale: scale4,
    coordinate,
    background,
    valueof: valueof2
  }, subObject(state.active, "background")));
  const elementStyle = deep_mix_default(state, {
    active: Object.assign({}, ((_b = state.active) === null || _b === void 0 ? void 0 : _b.offset) && {
      //Apply translate to mock slice out.
      transform: (...params) => {
        const value2 = state.active.offset(...params);
        const [, i2] = params;
        return offsetTransform(elements[i2], value2, coordinate);
      }
    })
  });
  const useState2 = createUseState(elementStyle, elements);
  const { updateState, removeState, hasState } = useState2(valueof2);
  let out;
  const pointerover = (event) => {
    const { nativeEvent = true } = event;
    let element = event.target;
    if (region) {
      element = findElement(event);
    }
    if (!elementSet.has(element))
      return;
    if (out)
      clearTimeout(out);
    const k2 = groupKey(element);
    const group2 = keyGroup.get(k2);
    const groupSet = new Set(group2);
    for (const e3 of elements) {
      if (groupSet.has(e3)) {
        if (!hasState(e3, "active"))
          updateState(e3, "active");
      } else {
        updateState(e3, "inactive");
        removeLink(e3);
      }
      if (e3 !== element)
        removeBackground(e3);
    }
    appendBackground(element);
    appendLink(group2);
    if (!nativeEvent)
      return;
    emitter.emit("element:highlight", {
      nativeEvent,
      data: {
        data: datum(element),
        group: group2.map(datum)
      }
    });
  };
  const delayUnhighlighted = () => {
    if (out)
      clearTimeout(out);
    out = setTimeout(() => {
      unhighlighted();
      out = null;
    }, delay);
  };
  const unhighlighted = (nativeEvent = true) => {
    for (const e3 of elements) {
      removeState(e3, "active", "inactive");
      removeBackground(e3);
      removeLink(e3);
    }
    if (nativeEvent) {
      emitter.emit("element:unhighlight", { nativeEvent });
    }
  };
  const pointerout = (event) => {
    let element = event.target;
    if (region) {
      element = findElement(event);
    }
    if (!element) {
      if (delay > 0)
        delayUnhighlighted();
      else
        unhighlighted();
      return;
    }
    if (background && !isBackground(element))
      return;
    if (!background && !elementSet.has(element))
      return;
    if (delay > 0)
      delayUnhighlighted();
    else
      unhighlighted();
  };
  const pointerleave = () => {
    unhighlighted();
  };
  root.addEventListener("pointerover", pointerover);
  root.addEventListener("pointermove", pointerover);
  root.addEventListener("pointerout", pointerout);
  root.addEventListener("pointerleave", pointerleave);
  const onRest = (e3) => {
    const { nativeEvent } = e3;
    if (nativeEvent)
      return;
    unhighlighted(false);
  };
  const onHighlight = (e3) => {
    const { nativeEvent } = e3;
    if (nativeEvent)
      return;
    const { data } = e3.data;
    const element = selectElementByData(elements, data, datum);
    if (!element)
      return;
    pointerover({ target: element, nativeEvent: false });
  };
  emitter.on("element:highlight", onHighlight);
  emitter.on("element:unhighlight", onRest);
  return () => {
    root.removeEventListener("pointerover", pointerover);
    root.removeEventListener("pointermove", pointerover);
    root.removeEventListener("pointerout", pointerout);
    root.removeEventListener("pointerleave", pointerleave);
    emitter.off("element:highlight", onHighlight);
    emitter.off("element:unhighlight", onRest);
    for (const e3 of elements) {
      removeBackground(e3);
      removeLink(e3);
    }
  };
}
function ElementHighlight(_a) {
  var { delay, createGroup, createRegionGroup, background = false, link: link3 = false } = _a, rest = __rest78(_a, ["delay", "createGroup", "createRegionGroup", "background", "link"]);
  return (context, _, emitter) => {
    const { container, view, options } = context;
    const { scale: scale4, coordinate } = view;
    const plotArea = selectPlotArea(container);
    return elementHighlight(plotArea, Object.assign({
      elements: selectG2Elements,
      datum: createDatumof(view),
      groupKey: createGroup ? createGroup(view) : void 0,
      regionGroupKey: createRegionGroup ? createRegionGroup(view) : createXKey(view),
      coordinate,
      scale: scale4,
      state: mergeState(options, [
        ["active", background ? {} : { lineWidth: "1", stroke: "#000" }],
        "inactive"
      ]),
      background,
      link: link3,
      delay,
      emitter
    }, rest));
  };
}
ElementHighlight.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementHighlightByX.js
function ElementHighlightByX(options) {
  return ElementHighlight(Object.assign(Object.assign({}, options), { createGroup: createXKey }));
}
ElementHighlightByX.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementHighlightByColor.js
function ElementHighlightByColor(options) {
  return ElementHighlight(Object.assign(Object.assign({}, options), { createGroup: createColorKey }));
}
ElementHighlightByColor.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementHoverScale.js
var __rest79 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function elementHoverScale(root, { elements: elementsof, datum, groupKey = (element) => element, scaleFactor = 1.04, scaleOrigin = "center center", shadow = true, shadowColor = "rgba(0, 0, 0, 0.4)", shadowBlur = 10, shadowOffsetX = 0, shadowOffsetY = 2, zIndex = 10, delay = 60, emitter, state = {} }) {
  const getCurrentElements = () => {
    var _a;
    return (_a = elementsof(root)) !== null && _a !== void 0 ? _a : [];
  };
  const initialElements = getCurrentElements();
  const valueof2 = createValueof(initialElements, datum);
  const elementStyle = deep_mix_default(state, {
    active: {}
  });
  const useState2 = createUseState(elementStyle, initialElements);
  const { updateState, removeState, hasState } = useState2(valueof2);
  const originalStyles = /* @__PURE__ */ new Map();
  const hoveredElements = /* @__PURE__ */ new Set();
  let out;
  const applyHoverEffect = (element) => {
    if (hoveredElements.has(element))
      return;
    const currentTransform = element.style.transform || "";
    const currentTransformOrigin = element.style.transformOrigin || "";
    originalStyles.set(element, {
      transform: currentTransform,
      transformOrigin: currentTransformOrigin,
      zIndex: element.style.zIndex || 0,
      shadowColor: element.style.shadowColor || "",
      shadowBlur: element.style.shadowBlur || 0,
      shadowOffsetX: element.style.shadowOffsetX || 0,
      shadowOffsetY: element.style.shadowOffsetY || 0
    });
    const prefix = currentTransform && currentTransform !== "none" ? currentTransform : "";
    const scaleTransform = `scale(${scaleFactor})`;
    let newTransform;
    if (prefix && !prefix.includes("scale")) {
      newTransform = `${prefix} ${scaleTransform}`.trimStart();
    } else if (prefix && prefix.includes("scale")) {
      newTransform = prefix.replace(/scale\([^)]+\)/g, scaleTransform).trimStart();
    } else {
      newTransform = scaleTransform;
    }
    element.style.transformOrigin = scaleOrigin;
    element.style.transform = newTransform;
    element.style.zIndex = zIndex;
    if (shadow) {
      element.style.shadowColor = shadowColor;
      element.style.shadowBlur = shadowBlur;
      element.style.shadowOffsetX = shadowOffsetX;
      element.style.shadowOffsetY = shadowOffsetY;
    }
    hoveredElements.add(element);
  };
  const removeHoverEffect = (element) => {
    const original = originalStyles.get(element);
    if (!original)
      return;
    element.style.transform = original.transform;
    element.style.transformOrigin = original.transformOrigin;
    element.style.zIndex = original.zIndex;
    element.style.shadowColor = original.shadowColor;
    element.style.shadowBlur = original.shadowBlur;
    element.style.shadowOffsetX = original.shadowOffsetX;
    element.style.shadowOffsetY = original.shadowOffsetY;
    hoveredElements.delete(element);
    originalStyles.delete(element);
  };
  const pointerover = (event) => {
    const { nativeEvent = true } = event;
    const element = event.target;
    const validElements = getCurrentElements();
    const currentElementSet = new Set(validElements);
    if (!currentElementSet.has(element))
      return;
    if (out)
      clearTimeout(out);
    const currentKeyGroup = group(validElements, groupKey);
    const k2 = groupKey(element);
    const currentGroup = currentKeyGroup.get(k2);
    if (!currentGroup)
      return;
    const groupSet = new Set(currentGroup);
    for (const e3 of validElements) {
      if (!groupSet.has(e3)) {
        removeState(e3, "active");
        removeHoverEffect(e3);
      }
    }
    for (const e3 of currentGroup) {
      if (!hasState(e3, "active"))
        updateState(e3, "active");
      applyHoverEffect(e3);
    }
    if (!nativeEvent)
      return;
    emitter.emit("element:hoverscale", {
      nativeEvent,
      data: {
        data: datum(element),
        group: currentGroup.map(datum)
      }
    });
  };
  const delayReset = () => {
    if (out)
      clearTimeout(out);
    out = setTimeout(() => {
      reset();
      out = null;
    }, delay);
  };
  const reset = (nativeEvent = true) => {
    const validElements = getCurrentElements();
    for (const e3 of validElements) {
      removeState(e3, "active");
      removeHoverEffect(e3);
    }
    hoveredElements.clear();
    if (nativeEvent) {
      emitter.emit("element:unhoverscale", { nativeEvent });
    }
  };
  const pointerout = (event) => {
    if (delay > 0)
      delayReset();
    else
      reset();
  };
  const pointerleave = () => {
    reset();
  };
  root.addEventListener("pointerover", pointerover);
  root.addEventListener("pointermove", pointerover);
  root.addEventListener("pointerout", pointerout);
  root.addEventListener("pointerleave", pointerleave);
  const onReset = (e3) => {
    const { nativeEvent } = e3;
    if (nativeEvent)
      return;
    reset(false);
  };
  const onHoverScale = (e3) => {
    const { nativeEvent } = e3;
    if (nativeEvent)
      return;
    const { data } = e3.data;
    const currentElements = getCurrentElements();
    const element = selectElementByData(currentElements, data, datum);
    if (!element)
      return;
    pointerover({ target: element, nativeEvent: false });
  };
  emitter.on("element:hoverscale", onHoverScale);
  emitter.on("element:unhoverscale", onReset);
  return () => {
    root.removeEventListener("pointerover", pointerover);
    root.removeEventListener("pointermove", pointerover);
    root.removeEventListener("pointerout", pointerout);
    root.removeEventListener("pointerleave", pointerleave);
    emitter.off("element:hoverscale", onHoverScale);
    emitter.off("element:unhoverscale", onReset);
    const validElements = getCurrentElements();
    for (const e3 of validElements) {
      removeHoverEffect(e3);
    }
    originalStyles.clear();
    hoveredElements.clear();
  };
}
function ElementHoverScale(_a) {
  var { delay, createGroup, scale: scaleFactorParam, scaleOrigin, shadow, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY, zIndex } = _a, rest = __rest79(_a, ["delay", "createGroup", "scale", "scaleOrigin", "shadow", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "zIndex"]);
  return (context, _contexts, emitter) => {
    const { container, view, options } = context;
    const plotArea = selectPlotArea(container);
    const datumof = createDatumof(view);
    return elementHoverScale(plotArea, Object.assign({
      elements: selectG2Elements,
      datum: datumof,
      groupKey: createGroup ? (element) => createGroup(view)(datumof(element)) : void 0,
      state: mergeState(options, ["active"]),
      scaleFactor: scaleFactorParam,
      scaleOrigin,
      shadow,
      shadowColor,
      shadowBlur,
      shadowOffsetX,
      shadowOffsetY,
      zIndex,
      delay,
      emitter
    }, rest));
  };
}
ElementHoverScale.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementSelect.js
var __rest80 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function elementSelect(root, {
  elements: elementsof,
  // given the root of chart returns elements to be manipulated
  datum,
  // given each element returns the datum of it
  groupKey = (d3) => d3,
  // group elements by specified key
  regionGroupKey = (d3) => d3,
  // how to group elements when click region
  link: link3 = false,
  // draw link or not
  single = false,
  // single select or not
  multipleSelectHotkey,
  // hotkey for multi-select mode
  coordinate,
  background = false,
  scale: scale4,
  emitter,
  state = {},
  region = false,
  regionEleFilter = (el) => VALID_FIND_BY_X_MARKS.includes(el.markType)
}) {
  var _a;
  const elements = elementsof(root);
  const elementSet = new Set(elements);
  const findElement = createFindElementByEvent({
    elementsof,
    root,
    coordinate,
    scale: scale4
  });
  const keyGroup = group(elements, groupKey);
  const regionGroup = group(elements, regionGroupKey);
  const valueof2 = createValueof(elements, datum);
  const [appendLink, removeLink] = renderLink(Object.assign({
    link: link3,
    elements,
    valueof: valueof2,
    coordinate
  }, subObject(state.selected, "link")));
  const [appendBackground, removeBackground] = renderBackground(Object.assign({
    document: root.ownerDocument,
    background,
    coordinate,
    scale: scale4,
    valueof: valueof2
  }, subObject(state.selected, "background")));
  const elementStyle = deep_mix_default(state, {
    selected: Object.assign({}, ((_a = state.selected) === null || _a === void 0 ? void 0 : _a.offset) && {
      // Apply translate to mock slice out.
      transform: (...params) => {
        const value2 = state.selected.offset(...params);
        const [, i2] = params;
        return offsetTransform(elements[i2], value2, coordinate);
      }
    })
  });
  const useState2 = createUseState(elementStyle, elements);
  const { updateState, removeState, hasState } = useState2(valueof2);
  let isMultiSelectMode = !single;
  let activeHotkey = null;
  const clear = (nativeEvent = true) => {
    for (const e3 of elements) {
      removeState(e3, "selected", "unselected");
      removeLink(e3);
      removeBackground(e3);
    }
    if (nativeEvent)
      emitter.emit("element:unselect", { nativeEvent: true });
    return;
  };
  const singleSelect = ({ event, element, nativeEvent = true, filter: filter2 = (el) => true, groupBy: groupBy2 = groupKey, groupMap = keyGroup }) => {
    const filteredElements = elements.filter(filter2);
    if (hasState(element, "selected"))
      clear();
    else {
      const k2 = groupBy2(element);
      const group2 = groupMap.get(k2);
      const groupSet = new Set(group2);
      for (const e3 of filteredElements) {
        if (groupSet.has(e3))
          updateState(e3, "selected");
        else {
          updateState(e3, "unselected");
          removeLink(e3);
        }
        if (e3 !== element)
          removeBackground(e3);
      }
      appendLink(group2);
      appendBackground(element);
      if (!nativeEvent)
        return;
      emitter.emit("element:select", Object.assign(Object.assign({}, event), { nativeEvent, data: {
        data: [datum(element), ...group2.map(datum)]
      } }));
    }
  };
  const multipleSelect = ({ event, element, nativeEvent = true, filter: filter2 = (el) => true, groupBy: groupBy2 = groupKey, groupMap = keyGroup }) => {
    const k2 = groupBy2(element);
    const group2 = groupMap.get(k2);
    const groupSet = new Set(group2);
    const filteredElements = elements.filter(filter2);
    if (!hasState(element, "selected")) {
      const hasSelectedGroup = group2.some((e3) => hasState(e3, "selected"));
      for (const e3 of filteredElements) {
        if (groupSet.has(e3))
          updateState(e3, "selected");
        else if (!hasState(e3, "selected"))
          updateState(e3, "unselected");
      }
      if (!hasSelectedGroup && link3)
        appendLink(group2);
      appendBackground(element);
    } else {
      const hasSelected = elements.some((e3) => !groupSet.has(e3) && hasState(e3, "selected"));
      if (!hasSelected)
        return clear();
      for (const e3 of group2) {
        updateState(e3, "unselected");
        removeLink(e3);
        removeBackground(e3);
      }
    }
    if (!nativeEvent)
      return;
    emitter.emit("element:select", Object.assign(Object.assign({}, event), { nativeEvent, data: {
      data: elements.filter((e3) => hasState(e3, "selected")).map(datum)
    } }));
  };
  const isClickElementOrGroup = (element) => {
    if (elementSet.has(element))
      return true;
    for (const group2 of elementSet) {
      const found = traverseElements(group2, (el) => el === element);
      if (found)
        return true;
    }
    return false;
  };
  const getRealElement = (element) => {
    if (elementSet.has(element))
      return element;
    for (const group2 of elementSet) {
      let match = null;
      traverseElements(group2, (el) => {
        if (el === element)
          match = group2;
      });
      if (match)
        return match;
    }
    return element;
  };
  const click = (event) => {
    const { target: element, nativeEvent = true } = event;
    const select2 = !isMultiSelectMode ? singleSelect : multipleSelect;
    let el = element;
    const isClickElement = isClickElementOrGroup(element);
    if (!region || isClickElement) {
      if (!isClickElement)
        return clear();
      return select2({
        event,
        element: getRealElement(el),
        nativeEvent,
        groupBy: groupKey
      });
    } else {
      el = findElement(event);
      if (!elementSet.has(el))
        return clear();
      return select2({
        event,
        element: el,
        nativeEvent,
        filter: regionEleFilter,
        groupBy: regionGroupKey,
        groupMap: regionGroup
      });
    }
  };
  const hotkeys = Array.isArray(multipleSelectHotkey) ? multipleSelectHotkey : [multipleSelectHotkey];
  const handleKeyDown = (event) => {
    if (hotkeys.includes(event.code) && !activeHotkey) {
      activeHotkey = event.code;
      isMultiSelectMode = true;
    }
  };
  const handleKeyUp = (event) => {
    if (event.code === activeHotkey) {
      activeHotkey = null;
      isMultiSelectMode = false;
    }
  };
  root.addEventListener("click", click);
  if (multipleSelectHotkey) {
    isMultiSelectMode = false;
    document.addEventListener("keydown", handleKeyDown);
    document.addEventListener("keyup", handleKeyUp);
  }
  const onSelect = (e3) => {
    const { nativeEvent, data } = e3;
    if (nativeEvent)
      return;
    const selectedData = !isMultiSelectMode ? data.data.slice(0, 1) : data.data;
    for (const d3 of selectedData) {
      const element = selectElementByData(elements, d3, datum);
      click({ target: element, nativeEvent: false });
    }
  };
  const onUnSelect = () => {
    clear(false);
  };
  emitter.on("element:select", onSelect);
  emitter.on("element:unselect", onUnSelect);
  return () => {
    for (const e3 of elements)
      removeLink(e3);
    root.removeEventListener("click", click);
    if (multipleSelectHotkey) {
      document.removeEventListener("keydown", handleKeyDown);
      document.removeEventListener("keyup", handleKeyUp);
    }
    emitter.off("element:select", onSelect);
    emitter.off("element:unselect", onUnSelect);
  };
}
function ElementSelect(_a) {
  var { createGroup, createRegionGroup, background = false, link: link3 = false } = _a, rest = __rest80(_a, ["createGroup", "createRegionGroup", "background", "link"]);
  return (context, _, emitter) => {
    const { container, view, options } = context;
    const { coordinate, scale: scale4 } = view;
    const plotArea = selectPlotArea(container);
    return elementSelect(plotArea, Object.assign({
      elements: selectG2Elements,
      datum: createDatumof(view),
      groupKey: createGroup ? createGroup(view) : void 0,
      regionGroupKey: createRegionGroup ? createRegionGroup(view) : createXKey(view),
      coordinate,
      scale: scale4,
      state: mergeState(options, [
        ["selected", background ? {} : { lineWidth: "1", stroke: "#000" }],
        "unselected"
      ]),
      background,
      link: link3,
      emitter
    }, rest));
  };
}
ElementSelect.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementSelectByX.js
function ElementSelectByX(options) {
  return ElementSelect(Object.assign(Object.assign({}, options), { createGroup: createXKey }));
}
ElementSelectByX.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementSelectByColor.js
function ElementSelectByColor(options) {
  return ElementSelect(Object.assign(Object.assign({}, options), { createGroup: createColorKey }));
}
ElementSelectByColor.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/chartIndex.js
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest81 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function maybeTransform(options) {
  const { transform: transform2 = [] } = options;
  const normalizeY = transform2.find((d3) => d3.type === "normalizeY");
  if (normalizeY)
    return normalizeY;
  const newNormalizeY = { type: "normalizeY" };
  transform2.push(newNormalizeY);
  options.transform = transform2;
  return newNormalizeY;
}
function markValue2(markState, markName, channels) {
  const [value2] = Array.from(markState.entries()).filter(([mark2]) => mark2.type === markName).map(([mark2]) => {
    const { encode } = mark2;
    const channel = (name2) => {
      const channel2 = encode[name2];
      return [name2, channel2 ? channel2.value : void 0];
    };
    return Object.fromEntries(channels.map(channel));
  });
  return value2;
}
function ChartIndex(_a) {
  var { wait = 20, leading, trailing = false, labelFormatter = (date) => `${date}` } = _a, style = __rest81(_a, ["wait", "leading", "trailing", "labelFormatter"]);
  return (context) => {
    const { view, container, update, setState } = context;
    const { markState, scale: scale4, coordinate } = view;
    const value2 = markValue2(markState, "line", ["x", "y", "series"]);
    if (!value2)
      return;
    const { y: Y, x: X, series: S = [] } = value2;
    const I = Y.map((_, i2) => i2);
    const sortedX = sort(I.map((i2) => X[i2]));
    const plotArea = selectPlotArea(container);
    const lines = container.getElementsByClassName(ELEMENT_CLASS_NAME);
    const labels = container.getElementsByClassName(LABEL_CLASS_NAME);
    const keyofLabel = (d3) => d3.__data__.key.split("-")[0];
    const keyLabels = group(labels, keyofLabel);
    const rule = new Line({
      style: Object.assign({ x1: 0, y1: 0, x2: 0, y2: plotArea.getAttribute("height"), stroke: "black", lineWidth: 1 }, subObject(style, "rule"))
    });
    const text = new Text({
      style: Object.assign({ x: 0, y: plotArea.getAttribute("height"), text: "", fontSize: 10 }, subObject(style, "label"))
    });
    rule.append(text);
    plotArea.appendChild(rule);
    const dateByFocus = (coordinate2, scaleX, focus2) => {
      const [normalizedX] = coordinate2.invert(focus2);
      const date = scaleX.invert(normalizedX);
      return sortedX[bisectCenter(sortedX, date)];
    };
    const updateRule = (focus2, date) => {
      rule.setAttribute("x1", focus2[0]);
      rule.setAttribute("x2", focus2[0]);
      text.setAttribute("text", labelFormatter(date));
    };
    let newView;
    const updateBasisByRerender = (focus2) => __awaiter8(this, void 0, void 0, function* () {
      const { x: scaleX } = scale4;
      const date = dateByFocus(coordinate, scaleX, focus2);
      updateRule(focus2, date);
      setState("chartIndex", (options) => {
        const clonedOptions = deep_mix_default({}, options);
        const lineMark = clonedOptions.marks.find((d3) => d3.type === "line");
        const r2 = (I2) => max(I2, (i2) => +Y[i2]) / min(I2, (i2) => +Y[i2]);
        const k2 = max(rollup(I, r2, (i2) => S[i2]).values());
        const domainY = [1 / k2, k2];
        deep_mix_default(lineMark, {
          scale: { y: { domain: domainY } }
        });
        const normalizeY = maybeTransform(lineMark);
        normalizeY.groupBy = "color";
        normalizeY.basis = (I2, Y3) => {
          const i2 = I2[bisector((i3) => X[+i3]).center(I2, date)];
          return Y3[i2];
        };
        for (const mark2 of clonedOptions.marks)
          mark2.animate = false;
        return clonedOptions;
      });
      const newState = yield update("chartIndex");
      newView = newState.view;
    });
    const updateBasisByTranslate = (focus2) => {
      const { scale: scale5, coordinate: coordinate2 } = newView;
      const { x: scaleX, y: scaleY } = scale5;
      const date = dateByFocus(coordinate2, scaleX, focus2);
      updateRule(focus2, date);
      for (const line3 of lines) {
        const { seriesIndex: SI, key } = line3.__data__;
        const i2 = SI[bisector((i3) => X[+i3]).center(SI, date)];
        const p0 = [0, scaleY.map(1)];
        const p1 = [0, scaleY.map(Y[i2] / Y[SI[0]])];
        const [, y05] = coordinate2.map(p0);
        const [, y12] = coordinate2.map(p1);
        const dy = y05 - y12;
        line3.setAttribute("transform", `translate(0, ${dy})`);
        const labels2 = keyLabels.get(key) || [];
        for (const label of labels2) {
          label.setAttribute("dy", dy);
        }
      }
    };
    const updateBasis = throttle_default((event) => {
      const focus2 = mousePosition(plotArea, event);
      if (!focus2)
        return;
      updateBasisByTranslate(focus2);
    }, wait, { leading, trailing });
    updateBasisByRerender([0, 0]);
    plotArea.addEventListener("pointerenter", updateBasis);
    plotArea.addEventListener("pointermove", updateBasis);
    plotArea.addEventListener("pointerleave", updateBasis);
    return () => {
      rule.remove();
      plotArea.removeEventListener("pointerenter", updateBasis);
      plotArea.removeEventListener("pointermove", updateBasis);
      plotArea.removeEventListener("pointerleave", updateBasis);
    };
  };
}
ChartIndex.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/fisheye.js
function maybeCoordinate(options) {
  const { coordinate = {} } = options;
  const { transform: transform2 = [] } = coordinate;
  const fisheye2 = transform2.find((d3) => d3.type === "fisheye");
  if (fisheye2)
    return fisheye2;
  const newFisheye = { type: "fisheye" };
  transform2.push(newFisheye);
  coordinate.transform = transform2;
  options.coordinate = coordinate;
  return newFisheye;
}
function Fisheye2({ wait = 30, leading, trailing = false }) {
  return (context) => {
    const { options, update, setState, container } = context;
    const plotArea = selectPlotArea(container);
    const updateFocus = throttle_default((event) => {
      const focus2 = mousePosition(plotArea, event);
      if (!focus2) {
        setState("fisheye");
        update();
        return;
      }
      setState("fisheye", (options2) => {
        const clonedOptions = deep_mix_default({}, options2, {
          interaction: { tooltip: { preserve: true } }
        });
        for (const mark2 of clonedOptions.marks)
          mark2.animate = false;
        const [x2, y3] = focus2;
        const fisheye2 = maybeCoordinate(clonedOptions);
        fisheye2.focusX = x2;
        fisheye2.focusY = y3;
        fisheye2.visual = true;
        return clonedOptions;
      });
      update();
    }, wait, { leading, trailing });
    plotArea.addEventListener("pointerenter", updateFocus);
    plotArea.addEventListener("pointermove", updateFocus);
    plotArea.addEventListener("pointerleave", updateFocus);
    return () => {
      plotArea.removeEventListener("pointerenter", updateFocus);
      plotArea.removeEventListener("pointermove", updateFocus);
      plotArea.removeEventListener("pointerleave", updateFocus);
    };
  };
}

// node_modules/@antv/g2/esm/interaction/tooltip.js
var __rest82 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var LOCKED_SYMBOL = "tooltipLocked";
function getContainer(group2, mount) {
  var _a;
  if (mount) {
    return typeof mount === "string" ? document.querySelector(mount) : mount;
  }
  const view = (_a = group2.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
  if (!view)
    return;
  const canvas = view.getContextService().getDomElement();
  return canvas.parentElement;
}
function getBounding(root) {
  const bbox = root.getRenderBounds();
  const { min: [x12, y12], max: [x2, y22] } = bbox;
  return {
    x: x12,
    y: y12,
    width: x2 - x12,
    height: y22 - y12
  };
}
function getContainerOffset(container1, container2) {
  const r1 = container1.getBoundingClientRect();
  const r2 = container2.getBoundingClientRect();
  return {
    x: r1.x - r2.x,
    y: r1.y - r2.y
  };
}
function createTooltip(container, x05, y05, position, enterable, bounding, containerOffset, css = {}, offset2 = [10, 10]) {
  const defaults4 = {
    [g2Selector("tooltip")]: {},
    [g2Selector("tooltip-title")]: {
      overflow: "hidden",
      "white-space": "nowrap",
      "text-overflow": "ellipsis"
    }
  };
  const tooltipElement = new Tooltip({
    className: "tooltip",
    style: {
      x: x05,
      y: y05,
      container: containerOffset,
      data: [],
      bounding,
      position,
      enterable,
      title: "",
      offset: offset2,
      template: {
        prefixCls: G2_CLASS_PREFIX
      },
      style: deep_mix_default(defaults4, css)
    }
  });
  container.appendChild(tooltipElement.HTMLTooltipElement);
  return tooltipElement;
}
function showTooltip({ root, data, x: x2, y: y3, render: render3, event, single, position = "right-bottom", enterable = false, css, mount, bounding, offset: offset2 }) {
  const container = getContainer(root, mount);
  const canvasContainer = getContainer(root);
  const parent = single ? canvasContainer : root;
  const b = bounding || getBounding(root);
  const containerOffset = getContainerOffset(canvasContainer, container);
  const { tooltipElement = createTooltip(container, x2, y3, position, enterable, b, containerOffset, css, offset2) } = parent;
  const { items, title = "" } = data;
  tooltipElement.update(Object.assign({
    x: x2,
    y: y3,
    data: items.map((item) => Object.assign(Object.assign({}, item), { value: !item.value && item.value !== 0 ? "" : item.value })),
    title,
    position,
    enterable,
    container: containerOffset
  }, render3 !== void 0 && {
    content: render3(event, { items, title })
  }));
  parent.tooltipElement = tooltipElement;
}
function hideTooltip({ root, single, emitter, nativeEvent = true, event = null }) {
  if (nativeEvent) {
    emitter.emit("tooltip:hide", { nativeEvent });
  }
  const container = getContainer(root);
  const parent = single ? container : root;
  const { tooltipElement } = parent;
  if (tooltipElement) {
    tooltipElement.hide(event === null || event === void 0 ? void 0 : event.clientX, event === null || event === void 0 ? void 0 : event.clientY);
  }
  hideRuleY(root);
  hideRuleX(root);
  hideMarker(root);
}
function destroyTooltip({ root, single }) {
  const container = getContainer(root);
  const parent = single ? container : root;
  if (!parent)
    return;
  const { tooltipElement } = parent;
  if (tooltipElement) {
    tooltipElement.destroy();
    parent.tooltipElement = void 0;
  }
  hideRuleY(root);
  hideRuleX(root);
  hideMarker(root);
}
function showUndefined(item) {
  const { value: value2 } = item;
  return Object.assign(Object.assign({}, item), { value: value2 === void 0 ? "undefined" : value2 });
}
function heatmapItem(element) {
  var _a, _b, _c, _d, _e, _f, _g;
  const { __data__: datum } = element;
  const { title, items = [] } = datum;
  const hasCustomItems = items.some((item) => CALLBACK_ITEM_SYMBOL in item);
  if (hasCustomItems) {
    const newItems = items.filter(defined).map((_a2) => {
      var { color: color2 = itemColorOf(element) } = _a2, item = __rest82(_a2, ["color"]);
      return Object.assign(Object.assign({}, item), { color: color2 });
    }).map(showUndefined);
    return Object.assign(Object.assign({}, title && { title }), { items: newItems });
  }
  const normalizedX = (_b = (_a = datum === null || datum === void 0 ? void 0 : datum.normalized) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : 0;
  const originalDatum = (_c = element.parentNode) === null || _c === void 0 ? void 0 : _c.__data__;
  const encode = (_d = originalDatum === null || originalDatum === void 0 ? void 0 : originalDatum.encode) !== null && _d !== void 0 ? _d : {};
  const { x: x2 = {}, y: y3 = {}, color = {} } = encode;
  const { value: vx = [] } = x2;
  const { value: vy = [] } = y3;
  const { value: vc = [] } = color;
  const index2 = Math.min(Math.round(vx.length * normalizedX), vx.length - 1);
  return {
    title: `${vx[index2]}, ${vy[index2]}`,
    items: [
      {
        name: (_e = color.field) !== null && _e !== void 0 ? _e : "value",
        value: vc[index2],
        color: ((_f = element.style) === null || _f === void 0 ? void 0 : _f.fill) || ((_g = element.getAttribute) === null || _g === void 0 ? void 0 : _g.call(element, "color")) || "#000"
      }
    ]
  };
}
function singleItem(element) {
  const { __data__: datum } = element;
  if (isHeatmap(element))
    return heatmapItem(element);
  const { title, items = [] } = datum;
  const newItems = items.filter(defined).map((_a) => {
    var { color = itemColorOf(element) } = _a, item = __rest82(_a, ["color"]);
    return Object.assign(Object.assign({}, item), { color });
  }).map(showUndefined);
  return Object.assign(Object.assign({}, title && { title }), { items: newItems });
}
function itemColorOf(element) {
  const fill = element.getAttribute("fill");
  const stroke2 = element.getAttribute("stroke");
  const { __data__: datum } = element;
  const { color = fill && fill !== "transparent" ? fill : stroke2 } = datum;
  return color;
}
function unique2(items, key = (d3) => d3) {
  const valueName = new Map(items.map((d3) => [key(d3), d3]));
  return Array.from(valueName.values());
}
function groupItems(elements, scale4, groupName, data = elements.map((d3) => d3["__data__"]), theme = {}) {
  const key = (d3) => d3 instanceof Date ? +d3 : d3;
  const T2 = unique2(data.map((d3) => d3.title), key).filter(defined);
  const newItems = data.flatMap((datum, i2) => {
    const element = datum.element || elements[i2];
    const { items = [], title } = datum;
    const definedItems = items.filter(defined);
    const useGroupName = groupName !== void 0 ? groupName : items.length <= 1 ? true : false;
    return definedItems.map((_a) => {
      var { color = itemColorOf(element) || theme.color, name: name2 } = _a, item = __rest82(_a, ["color", "name"]);
      const groupName2 = groupNameOf(scale4, datum);
      const name1 = useGroupName && !(CALLBACK_ITEM_SYMBOL in item) ? groupName2 || name2 : name2 || groupName2;
      return Object.assign(Object.assign({}, item), { color, name: name1 || title });
    });
  }).map(showUndefined);
  return Object.assign(Object.assign({}, T2.length > 0 && { title: T2.join(",") }), { items: unique2(newItems, (d3) => `(${key(d3.name)}, ${key(d3.value)}, ${key(d3.color)})`) });
}
function updateRuleX(root, points, mouse, _a) {
  var { plotWidth, plotHeight, mainWidth, mainHeight, startX, startY, transposed, polar: polar2, insetLeft, insetTop } = _a, rest = __rest82(_a, ["plotWidth", "plotHeight", "mainWidth", "mainHeight", "startX", "startY", "transposed", "polar", "insetLeft", "insetTop"]);
  const defaults4 = Object.assign({ lineWidth: 1, stroke: "#1b1e23", strokeOpacity: 0.5 }, rest);
  const createCircle = (cx, cy, r2) => {
    const circle2 = new Circle({
      style: Object.assign({
        cx,
        cy,
        r: r2
      }, defaults4)
    });
    root.appendChild(circle2);
    return circle2;
  };
  const createLine = (x12, x2, y12, y22) => {
    const line3 = new Line({
      style: Object.assign({
        x1: x12,
        x2,
        y1: y12,
        y2: y22
      }, defaults4)
    });
    root.appendChild(line3);
    return line3;
  };
  const minDistPoint = (mouse2, points2) => {
    if (points2.length === 1) {
      return points2[0];
    }
    const dists = points2.map((p3) => dist(p3, mouse2));
    const minDistIndex = minIndex(dists, (d3) => d3);
    return points2[minDistIndex];
  };
  const target = minDistPoint(mouse, points);
  const pointsOf = () => {
    if (transposed)
      return [
        startX + target[0],
        startX + target[0],
        startY,
        startY + plotHeight
      ];
    return [startX, startX + plotWidth, target[1] + startY, target[1] + startY];
  };
  const pointsOfPolar = () => {
    const cx = startX + insetLeft + mainWidth / 2;
    const cy = startY + insetTop + mainHeight / 2;
    const cdist = dist([cx, cy], target);
    return [cx, cy, cdist];
  };
  if (polar2) {
    const [cx, cy, r2] = pointsOfPolar();
    const ruleX = root.ruleX || createCircle(cx, cy, r2);
    ruleX.style.cx = cx;
    ruleX.style.cy = cy;
    ruleX.style.r = r2;
    root.ruleX = ruleX;
  } else {
    const [x12, x2, y12, y22] = pointsOf();
    const ruleX = root.ruleX || createLine(x12, x2, y12, y22);
    ruleX.style.x1 = x12;
    ruleX.style.x2 = x2;
    ruleX.style.y1 = y12;
    ruleX.style.y2 = y22;
    root.ruleX = ruleX;
  }
}
function updateRuleY(root, points, _a) {
  var { plotWidth, plotHeight, mainWidth, mainHeight, startX, startY, transposed, polar: polar2, insetLeft, insetTop } = _a, rest = __rest82(_a, ["plotWidth", "plotHeight", "mainWidth", "mainHeight", "startX", "startY", "transposed", "polar", "insetLeft", "insetTop"]);
  const defaults4 = Object.assign({ lineWidth: 1, stroke: "#1b1e23", strokeOpacity: 0.5 }, rest);
  const Y = points.map((p3) => p3[1]);
  const X = points.map((p3) => p3[0]);
  const y3 = mean(Y);
  const x2 = mean(X);
  const pointsOf = () => {
    if (polar2) {
      const r2 = Math.min(mainWidth, mainHeight) / 2;
      const cx = startX + insetLeft + mainWidth / 2;
      const cy = startY + insetTop + mainHeight / 2;
      const a4 = angle(sub([x2, y3], [cx, cy]));
      const x05 = cx + r2 * Math.cos(a4);
      const y05 = cy + r2 * Math.sin(a4);
      return [cx, x05, cy, y05];
    }
    if (transposed)
      return [startX, startX + plotWidth, y3 + startY, y3 + startY];
    return [x2 + startX, x2 + startX, startY, startY + plotHeight];
  };
  const [x12, x22, y12, y22] = pointsOf();
  const createLine = () => {
    const line3 = new Line({
      style: Object.assign({
        x1: x12,
        x2: x22,
        y1: y12,
        y2: y22
      }, defaults4)
    });
    root.appendChild(line3);
    return line3;
  };
  if (X.length > 0) {
    const ruleY = root.ruleY || createLine();
    ruleY.style.x1 = x12;
    ruleY.style.x2 = x22;
    ruleY.style.y1 = y12;
    ruleY.style.y2 = y22;
    root.ruleY = ruleY;
  }
}
function hideRuleY(root) {
  if (root.ruleY) {
    root.ruleY.remove();
    root.ruleY = void 0;
  }
}
function hideRuleX(root) {
  if (root.ruleX) {
    root.ruleX.remove();
    root.ruleX = void 0;
  }
}
function updateMarker(root, { data, style, theme }) {
  if (root.markers)
    root.markers.forEach((d3) => d3.remove());
  const { type = "" } = style;
  const markers = data.filter((d3) => {
    const [{ x: x2, y: y3 }] = d3;
    return defined(x2) && defined(y3);
  }).map((d3) => {
    const [{ color, element }, point6] = d3;
    const originColor = color || // encode value
    element.style.fill || element.style.stroke || theme.color;
    const fill = type === "hollow" ? "transparent" : originColor;
    const stroke2 = type === "hollow" ? originColor : "#fff";
    const shape24 = new Circle({
      className: `${G2_CLASS_PREFIX}tooltip-marker`,
      style: Object.assign({
        cx: point6[0],
        cy: point6[1],
        fill,
        r: 4,
        stroke: stroke2,
        lineWidth: 2,
        // Prevents blocking clicks on elements behind.
        pointerEvents: "none"
      }, style)
    });
    return shape24;
  });
  for (const marker of markers)
    root.appendChild(marker);
  root.markers = markers;
}
function hideMarker(root) {
  if (root.markers) {
    root.markers.forEach((d3) => d3.remove());
    root.markers = [];
  }
}
function interactionKeyof(markState, key) {
  return Array.from(markState.values()).some(
    // @ts-ignore
    (d3) => {
      var _a;
      return (_a = d3.interaction) === null || _a === void 0 ? void 0 : _a[key];
    }
  );
}
function maybeValue(specified, defaults4) {
  return specified === void 0 ? defaults4 : specified;
}
function isEmptyTooltipData(data) {
  const { title, items } = data;
  if (items.length === 0 && title === void 0)
    return true;
  return false;
}
function hasSeries(markState) {
  return Array.from(markState.values()).some(
    // @ts-ignore
    (d3) => {
      var _a;
      return ((_a = d3.interaction) === null || _a === void 0 ? void 0 : _a.seriesTooltip) && d3.tooltip;
    }
  );
}
function normalizedPosition(coordinate, position) {
  const { innerWidth, innerHeight, marginLeft, paddingLeft, insetLeft, marginTop, paddingTop, insetTop } = coordinate.getOptions();
  return {
    x: (position.x - marginLeft - paddingLeft - insetLeft) / innerWidth,
    y: (position.y - marginTop - paddingTop - insetTop) / innerHeight
  };
}
function equalBandWidth(scale4) {
  const { x: x2 } = scale4;
  if (!x2 || !x2.valueBandWidth)
    return true;
  const { valueBandWidth } = x2;
  if (isNumber(valueBandWidth))
    return true;
  return new Set(valueBandWidth.values()).size === 1;
}
function findNearestElementIndex(scale4, abstractX) {
  const { adjustedRange, valueBandWidth, valueStep } = scale4;
  const values4 = Array.from(valueBandWidth.values());
  const steps = Array.from(valueStep.values());
  const ranges = adjustedRange.map((v, i2) => {
    const halfStep = (steps[i2] - values4[i2]) / 2;
    return [v - halfStep, v + values4[i2] + halfStep];
  });
  const index2 = ranges.findIndex(([start, end]) => start <= abstractX && abstractX <= end);
  if (index2 !== -1)
    return index2;
  return abstractX > 0.5 ? adjustedRange.length - 1 : 0;
}
function findSingleElement({ root, event, elements = [], coordinate, scale: scale4, shared }) {
  var _a, _b;
  const inInterval = (d3) => d3.markType === "interval";
  const isBar = elements.every(inInterval) && !isPolar(coordinate);
  const scaleX = scale4.x;
  const isEqualWidth = equalBandWidth(scale4);
  const scaleSeries = scale4.series;
  const bandWidth3 = (_b = (_a = scaleX === null || scaleX === void 0 ? void 0 : scaleX.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(scaleX)) !== null && _b !== void 0 ? _b : 0;
  const xof = scaleSeries && scaleSeries.valueBandWidth ? (d3) => {
    const seriesCount = Math.round(1 / scaleSeries.valueBandWidth);
    return d3.__data__.x + d3.__data__.series * bandWidth3 + bandWidth3 / (seriesCount * 2);
  } : (d3) => d3.__data__.x + bandWidth3 / 2;
  if (isBar)
    elements.sort((a4, b) => xof(a4) - xof(b));
  const findElementByTarget = (event2) => {
    const { target = last(elements) } = event2;
    return maybeRoot(target, (node) => {
      if (!node.classList)
        return false;
      if (isHeatmap(node)) {
        set_default(node, "__data__.normalized", normalizedPosition(coordinate, {
          x: event2.offsetX,
          y: event2.offsetY
        }));
      }
      return node.classList.includes("element");
    });
  };
  const element = isBar ? (event2) => {
    const mouse = mousePosition(root, event2);
    if (!mouse)
      return;
    const [abstractX] = coordinate.invert(mouse);
    const search = bisector(xof).center;
    const i2 = isEqualWidth ? search(elements, abstractX) : findNearestElementIndex(scaleX, abstractX);
    const target = elements[i2];
    if (!shared) {
      const isGrouped = elements.find((d3) => d3 !== target && xof(d3) === xof(target));
      if (isGrouped)
        return findElementByTarget(event2) || isGrouped;
    }
    return target;
  } : findElementByTarget;
  return element(event);
}
function findSeriesElement({ root, event, elements, coordinate, scale: scale4, startX, startY }) {
  const transposed = isTranspose(coordinate);
  const seriesElements = [];
  const itemElements = [];
  for (const element of elements) {
    const { __data__: data } = element;
    const { seriesX, title, items } = data;
    if (seriesX)
      seriesElements.push(element);
    else if (title || items)
      itemElements.push(element);
  }
  const inInterval = (d3) => d3.markType === "interval";
  const isBar = itemElements.length && itemElements.every(inInterval) && !isPolar(coordinate);
  const xof = (d3) => d3.__data__.x;
  const isBandScale = !!scale4.x.getBandWidth;
  const closest = isBandScale && itemElements.length > 0;
  seriesElements.sort((a4, b) => {
    const index2 = transposed ? 0 : 1;
    const minY = (d3) => d3.getBounds().min[index2];
    return transposed ? minY(b) - minY(a4) : minY(a4) - minY(b);
  });
  const extent2 = (d3) => {
    const index2 = transposed ? 1 : 0;
    const { min: min6, max: max7 } = d3.getLocalBounds();
    return sort([min6[index2], max7[index2]]);
  };
  if (isBar)
    elements.sort((a4, b) => xof(a4) - xof(b));
  else {
    itemElements.sort((a4, b) => {
      const [minA, maxA] = extent2(a4);
      const [minB, maxB] = extent2(b);
      const midA = (minA + maxA) / 2;
      const midB = (minB + maxB) / 2;
      return transposed ? midB - midA : midA - midB;
    });
  }
  const elementSortedX = new Map(seriesElements.map((element) => {
    const { __data__: data } = element;
    const { seriesX } = data;
    const seriesIndex = seriesX.map((_, i2) => i2);
    const sortedIndex = sort(seriesIndex, (i2) => seriesX[+i2]);
    return [element, [sortedIndex, seriesX]];
  }));
  const { x: scaleX } = scale4;
  const offsetX = (scaleX === null || scaleX === void 0 ? void 0 : scaleX.getBandWidth) ? scaleX.getBandWidth() / 2 : 0;
  const abstractX = (focus3) => {
    const [normalizedX] = coordinate.invert(focus3);
    return normalizedX - offsetX;
  };
  const indexByFocus = (event2, focus3, I, X) => {
    const { _x } = event2;
    const finalX = _x !== void 0 ? scaleX.map(_x) : abstractX(focus3);
    const DX = X.filter(defined);
    const [minX, maxX] = sort([DX[0], DX[DX.length - 1]]);
    const isOnlyOneElement = minX === maxX;
    if (!closest && (finalX < minX || finalX > maxX) && !isOnlyOneElement)
      return null;
    const search = bisector((i3) => X[+i3]).center;
    const i2 = search(I, finalX);
    return I[i2];
  };
  const elementsByFocus = isBar ? (focus3, elements2) => {
    const search = bisector(xof).center;
    const i2 = search(elements2, abstractX(focus3));
    const find2 = elements2[i2];
    const groups2 = group(elements2, xof);
    const selected = groups2.get(xof(find2));
    return selected;
  } : (focus3, elements2) => {
    const index2 = transposed ? 1 : 0;
    const x2 = focus3[index2];
    const filtered = elements2.filter((element) => {
      const [min6, max7] = extent2(element);
      return x2 >= min6 && x2 <= max7;
    });
    if (!closest || filtered.length > 0)
      return filtered;
    const search = bisector((element) => {
      const [min6, max7] = extent2(element);
      return (min6 + max7) / 2;
    }).center;
    const i2 = search(elements2, x2);
    return [elements2[i2]].filter(defined);
  };
  const seriesData = (element, index2) => {
    const { __data__: data } = element;
    return Object.fromEntries(Object.entries(data).filter(([key]) => key.startsWith("series") && key !== "series").map(([key, V]) => {
      const d3 = V[index2];
      return [lower_first_default(key.replace("series", "")), d3];
    }));
  };
  const mouse = mousePosition(root, event);
  if (!mouse)
    return;
  const focus2 = [mouse[0] - startX, mouse[1] - startY];
  if (!focus2)
    return;
  const selectedItems = elementsByFocus(focus2, itemElements);
  const selectedSeriesElements = [];
  const selectedSeriesData = [];
  for (const element of seriesElements) {
    const [sortedIndex, X] = elementSortedX.get(element);
    const index2 = indexByFocus(event, focus2, sortedIndex, X);
    if (index2 !== null) {
      selectedSeriesElements.push(element);
      const d3 = seriesData(element, index2);
      const { x: x2, y: y3 } = d3;
      const p3 = coordinate.map([(x2 || 0) + offsetX, y3 || 0]);
      selectedSeriesData.push([Object.assign(Object.assign({}, d3), { element }), p3]);
    }
  }
  const SX = Array.from(new Set(selectedSeriesData.map((d3) => d3[0].x)));
  const closestX = SX[minIndex(SX, (x2) => Math.abs(x2 - abstractX(focus2)))];
  const filteredSeriesData = selectedSeriesData.filter((d3) => d3[0].x === closestX);
  const selectedData = [
    ...filteredSeriesData.map((d3) => d3[0]),
    ...selectedItems.map((d3) => d3.__data__)
  ];
  const selectedElements = [...selectedSeriesElements, ...selectedItems];
  return { selectedElements, selectedData, filteredSeriesData, abstractX };
}
function seriesTooltip(root, _a) {
  var { elements: elementsof, sort: sortFunction, filter: filterFunction, scale: scale4, coordinate, crosshairs, crosshairsX, crosshairsY, render: render3, groupName, emitter, wait = 50, leading = true, trailing = false, startX = 0, startY = 0, body = true, single = true, position, enterable, mount, bounding, theme, offset: offset2, disableNative = false, marker = true, preserve = false, style: _style = {}, css = {}, clickLock = false, disableAutoHide = false } = _a, rest = __rest82(_a, ["elements", "sort", "filter", "scale", "coordinate", "crosshairs", "crosshairsX", "crosshairsY", "render", "groupName", "emitter", "wait", "leading", "trailing", "startX", "startY", "body", "single", "position", "enterable", "mount", "bounding", "theme", "offset", "disableNative", "marker", "preserve", "style", "css", "clickLock", "disableAutoHide"]);
  const elements = elementsof(root);
  const style = deep_mix_default(_style, rest);
  const polar2 = isPolar(coordinate);
  const transposed = isTranspose(coordinate);
  const { innerWidth: plotWidth, innerHeight: plotHeight, width: mainWidth, height: mainHeight, insetLeft, insetTop } = coordinate.getOptions();
  const update = throttle_default((event) => {
    var _a2;
    if (clickLock && root.getAttribute(LOCKED_SYMBOL))
      return;
    const mouse = mousePosition(root, event);
    if (!mouse)
      return;
    const bbox = bboxOf(root);
    const x2 = bbox.min[0];
    const y3 = bbox.min[1];
    const { selectedElements, selectedData, filteredSeriesData, abstractX } = findSeriesElement({
      root,
      event,
      elements,
      coordinate,
      scale: scale4,
      startX,
      startY
    });
    const tooltipData = groupItems(selectedElements, scale4, groupName, selectedData, theme);
    if (sortFunction) {
      tooltipData.items.sort((a4, b) => sortFunction(a4) - sortFunction(b));
    }
    if (filterFunction) {
      tooltipData.items = tooltipData.items.filter(filterFunction);
    }
    if (selectedElements.length === 0 || isEmptyTooltipData(tooltipData)) {
      hide2(event);
      return;
    }
    if (body) {
      showTooltip({
        root,
        data: tooltipData,
        x: mouse[0] + x2,
        y: mouse[1] + y3,
        render: render3,
        event,
        single,
        position,
        enterable,
        mount,
        bounding,
        css,
        offset: offset2
      });
    }
    if (crosshairs || crosshairsX || crosshairsY) {
      const ruleStyle = subObject(style, "crosshairs");
      const ruleStyleX = Object.assign(Object.assign({}, ruleStyle), subObject(style, "crosshairsX"));
      const ruleStyleY = Object.assign(Object.assign({}, ruleStyle), subObject(style, "crosshairsY"));
      const points = filteredSeriesData.map((d3) => d3[1]);
      if (crosshairsX) {
        updateRuleX(root, points, mouse, Object.assign(Object.assign({}, ruleStyleX), {
          plotWidth,
          plotHeight,
          mainWidth,
          mainHeight,
          insetLeft,
          insetTop,
          startX,
          startY,
          transposed,
          polar: polar2
        }));
      }
      if (crosshairsY) {
        updateRuleY(root, points, Object.assign(Object.assign({}, ruleStyleY), {
          plotWidth,
          plotHeight,
          mainWidth,
          mainHeight,
          insetLeft,
          insetTop,
          startX,
          startY,
          transposed,
          polar: polar2
        }));
      }
    }
    if (marker) {
      const markerStyles = subObject(style, "marker");
      updateMarker(root, {
        data: filteredSeriesData,
        style: markerStyles,
        theme
      });
    }
    const firstX = (_a2 = filteredSeriesData[0]) === null || _a2 === void 0 ? void 0 : _a2[0].x;
    const transformedX = firstX !== null && firstX !== void 0 ? firstX : abstractX(focus);
    emitter.emit("tooltip:show", Object.assign(Object.assign({}, event), { nativeEvent: true, data: Object.assign(Object.assign({}, tooltipData), { data: { x: invert(scale4.x, transformedX, true) } }) }));
  }, wait, { leading, trailing });
  const hide2 = (event) => {
    if (clickLock && root.getAttribute(LOCKED_SYMBOL) || disableAutoHide)
      return;
    hideTooltip({ root, single, emitter, event });
  };
  const destroy2 = () => {
    destroyTooltip({ root, single });
  };
  const onTooltipShow = (_a2) => {
    var _b;
    var { nativeEvent, data, offsetX, offsetY } = _a2, rest2 = __rest82(_a2, ["nativeEvent", "data", "offsetX", "offsetY"]);
    if (nativeEvent)
      return;
    const x2 = (_b = data === null || data === void 0 ? void 0 : data.data) === null || _b === void 0 ? void 0 : _b.x;
    const scaleX = scale4.x;
    const x12 = scaleX.map(x2);
    const [x22, y22] = coordinate.map([x12, 0.5]);
    const rootBounds = bboxOf(root);
    const minX = rootBounds.min[0];
    const minY = rootBounds.min[1];
    update(Object.assign(Object.assign({}, rest2), { offsetX: offsetX !== void 0 ? offsetX : minX + x22, offsetY: offsetY !== void 0 ? offsetY : minY + y22, _x: x2 }));
  };
  const onTooltipHide = () => {
    hideTooltip({ root, single, emitter, nativeEvent: false });
  };
  const onTooltipDisable = () => {
    removeEventListeners();
    destroy2();
  };
  const pointerleave = (e3) => {
    if (mousePosition(root, e3))
      return;
    hide2(e3);
  };
  const onTooltipEnable = () => {
    addEventListeners();
  };
  const pointerdown = (e3) => {
    if (clickLock) {
      root.setAttribute(LOCKED_SYMBOL, !root.getAttribute(LOCKED_SYMBOL));
    }
    update(e3);
  };
  const addEventListeners = () => {
    if (!disableNative) {
      root.addEventListener("pointerdown", pointerdown);
      root.addEventListener("pointerenter", update);
      root.addEventListener("pointermove", update);
      root.addEventListener("pointerleave", pointerleave);
      root.addEventListener("pointerup", hide2);
    }
  };
  const removeEventListeners = () => {
    if (!disableNative) {
      root.removeEventListener("pointerdown", pointerdown);
      root.removeEventListener("pointerenter", update);
      root.removeEventListener("pointermove", update);
      root.removeEventListener("pointerleave", pointerleave);
      root.removeEventListener("pointerup", hide2);
    }
  };
  addEventListeners();
  emitter.on("tooltip:show", onTooltipShow);
  emitter.on("tooltip:hide", onTooltipHide);
  emitter.on("tooltip:disable", onTooltipDisable);
  emitter.on("tooltip:enable", onTooltipEnable);
  return () => {
    removeEventListeners();
    emitter.off("tooltip:show", onTooltipShow);
    emitter.off("tooltip:hide", onTooltipHide);
    emitter.off("tooltip:disable", onTooltipDisable);
    emitter.off("tooltip:enable", onTooltipEnable);
    if (preserve) {
      hideTooltip({ root, single, emitter, nativeEvent: false });
    } else {
      destroy2();
    }
  };
}
function tooltip(root, {
  elements: elementsof,
  coordinate,
  scale: scale4,
  render: render3,
  groupName,
  sort: sortFunction,
  filter: filterFunction,
  emitter,
  wait = 50,
  leading = true,
  trailing = false,
  groupKey = (d3) => d3,
  // group elements by specified key
  single = true,
  position,
  enterable,
  datum,
  view,
  mount,
  bounding,
  theme,
  offset: offset2,
  shared = false,
  body = true,
  disableNative = false,
  preserve = false,
  css = {},
  clickLock = false,
  disableAutoHide = false
}) {
  const elements = elementsof(root);
  const keyGroup = group(elements, groupKey);
  const pointermove = throttle_default((event) => {
    if (clickLock && root.getAttribute(LOCKED_SYMBOL))
      return;
    const element = findSingleElement({
      root,
      event,
      elements,
      coordinate,
      scale: scale4,
      shared
    });
    if (!element) {
      if (!disableAutoHide) {
        hideTooltip({ root, single, emitter, event });
      }
      return;
    }
    const k2 = groupKey(element);
    const group2 = keyGroup.get(k2);
    if (!group2) {
      return;
    }
    const data = group2.length === 1 && !shared ? singleItem(group2[0]) : groupItems(group2, scale4, groupName, void 0, theme);
    if (sortFunction) {
      data.items.sort((a4, b) => sortFunction(a4) - sortFunction(b));
    }
    if (filterFunction) {
      data.items = data.items.filter(filterFunction);
    }
    if (isEmptyTooltipData(data)) {
      if (!disableAutoHide) {
        hideTooltip({ root, single, emitter, event });
      }
      return;
    }
    const { offsetX, offsetY } = event;
    if (body) {
      showTooltip({
        root,
        data,
        x: offsetX,
        y: offsetY,
        render: render3,
        event,
        single,
        position,
        enterable,
        mount,
        bounding,
        css,
        offset: offset2
      });
    }
    emitter.emit("tooltip:show", Object.assign(Object.assign({}, event), { nativeEvent: true, data: Object.assign(Object.assign({}, data), { data: dataOf(element, view) }) }));
  }, wait, { leading, trailing });
  const pointerleave = (event) => {
    if (disableAutoHide)
      return;
    hideTooltip({ root, single, emitter, event });
  };
  const pointerdown = (e3) => {
    if (clickLock) {
      root.setAttribute(LOCKED_SYMBOL, !root.getAttribute(LOCKED_SYMBOL));
    }
    pointermove(e3);
  };
  const addEventListeners = () => {
    if (!disableNative) {
      root.addEventListener("pointerdown", pointerdown);
      root.addEventListener("pointermove", pointermove);
      root.addEventListener("pointerleave", pointerleave);
      root.addEventListener("pointerup", pointerleave);
    }
  };
  const removeEventListeners = () => {
    if (!disableNative) {
      root.removeEventListener("pointerdown", pointerdown);
      root.removeEventListener("pointermove", pointermove);
      root.removeEventListener("pointerleave", pointerleave);
      root.removeEventListener("pointerup", pointerleave);
    }
  };
  const onTooltipShow = ({ nativeEvent, offsetX, offsetY, data: raw }) => {
    if (nativeEvent)
      return;
    const { data } = raw;
    const element = selectElementByData(elements, data, datum);
    if (!element)
      return;
    const bbox = element.getBBox();
    const { x: x2, y: y3, width, height } = bbox;
    const rootBBox = root.getBBox();
    pointermove({
      target: element,
      offsetX: offsetX !== void 0 ? offsetX + rootBBox.x : x2 + width / 2,
      offsetY: offsetY !== void 0 ? offsetY + rootBBox.y : y3 + height / 2
    });
  };
  const onTooltipHide = ({ nativeEvent } = {}) => {
    if (nativeEvent)
      return;
    hideTooltip({ root, single, emitter, nativeEvent: false });
  };
  const onTooltipDisable = () => {
    removeEventListeners();
    destroyTooltip({ root, single });
  };
  const onTooltipEnable = () => {
    addEventListeners();
  };
  emitter.on("tooltip:show", onTooltipShow);
  emitter.on("tooltip:hide", onTooltipHide);
  emitter.on("tooltip:enable", onTooltipEnable);
  emitter.on("tooltip:disable", onTooltipDisable);
  addEventListeners();
  return () => {
    removeEventListeners();
    emitter.off("tooltip:show", onTooltipShow);
    emitter.off("tooltip:hide", onTooltipHide);
    emitter.off("tooltip:enable", onTooltipEnable);
    emitter.off("tooltip:disable", onTooltipDisable);
    if (preserve) {
      hideTooltip({ root, single, emitter, nativeEvent: false });
    } else {
      destroyTooltip({ root, single });
    }
  };
}
function Tooltip2(options) {
  const { shared, crosshairs, crosshairsX, crosshairsY, series, name: name2, item = () => ({}), facet = false } = options, rest = __rest82(options, ["shared", "crosshairs", "crosshairsX", "crosshairsY", "series", "name", "item", "facet"]);
  return (target, viewInstances, emitter) => {
    const { container, view } = target;
    const { scale: scale4, markState, coordinate, theme } = view;
    const defaultSeries = interactionKeyof(markState, "seriesTooltip");
    const defaultShowCrosshairs = interactionKeyof(markState, "crosshairs");
    const plotArea = selectPlotArea(container);
    const isSeries = maybeValue(series, defaultSeries);
    const crosshairsSetting = maybeValue(crosshairs, defaultShowCrosshairs);
    if (rest.clickLock && !facet)
      plotArea.setAttribute(LOCKED_SYMBOL, false);
    if (isSeries && hasSeries(markState) && !facet) {
      return seriesTooltip(plotArea, Object.assign(Object.assign({}, rest), {
        theme,
        elements: selectG2Elements,
        scale: scale4,
        coordinate,
        crosshairs: crosshairsSetting,
        // the crosshairsX settings level: crosshairsX > crosshairs > false
        // it means crosshairsX default is false
        crosshairsX: maybeValue(maybeValue(crosshairsX, crosshairs), false),
        // crosshairsY default depend on the crossharisSettings
        crosshairsY: maybeValue(crosshairsY, crosshairsSetting),
        item,
        emitter
      }));
    }
    if (isSeries && facet) {
      const facetInstances = viewInstances.filter((d3) => d3 !== target && d3.options.parentKey === target.options.key);
      const elements = selectFacetG2Elements(target, viewInstances);
      const scale5 = facetInstances[0].view.scale;
      const bbox = plotArea.getBounds();
      const startX = bbox.min[0];
      const startY = bbox.min[1];
      Object.assign(scale5, { facet: true });
      const root = plotArea.parentNode.parentNode;
      if (rest.clickLock)
        root.setAttribute(LOCKED_SYMBOL, false);
      return seriesTooltip(root, Object.assign(Object.assign({}, rest), {
        theme,
        elements: () => elements,
        scale: scale5,
        coordinate,
        crosshairs: maybeValue(crosshairs, defaultShowCrosshairs),
        // the crosshairsX settings level: crosshairsX > crosshairs > false
        // it means crosshairsX default is false
        crosshairsX: maybeValue(maybeValue(crosshairsX, crosshairs), false),
        crosshairsY: maybeValue(crosshairsY, crosshairsSetting),
        item,
        startX,
        startY,
        emitter
      }));
    }
    return tooltip(plotArea, Object.assign(Object.assign({}, rest), {
      datum: createDatumof(view),
      elements: selectG2Elements,
      scale: scale4,
      coordinate,
      groupKey: shared ? createXKey(view) : void 0,
      item,
      emitter,
      view,
      theme,
      shared
    }));
  };
}
Tooltip2.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/legendHighlight.js
function LegendHighlight() {
  return (context, _, emitter) => {
    const { container, view, options } = context;
    const legends = legendsOf(container);
    const elements = selectG2Elements(container);
    const channelOf = (legend) => {
      return dataOf2(legend).scales[0].name;
    };
    const scaleOf2 = (channel) => {
      const { scale: { [channel]: scale4 } } = view;
      return scale4;
    };
    const markState = mergeState(options, ["active", "inactive"]);
    const valueof2 = createValueof(elements, createDatumof(view));
    const destroys = [];
    for (const legend of legends) {
      const datumOf = (item) => {
        const { data } = legend.attributes;
        const { __data__: datum } = item;
        const { index: index2 } = datum;
        return data[index2].label;
      };
      const channel = channelOf(legend);
      const items = itemsOf(legend);
      const scale4 = scaleOf2(channel);
      const elementGroup = group(elements, (d3) => scale4.invert(d3.__data__[channel]));
      const { state: legendState = {} } = legend.attributes;
      const { inactive = {} } = legendState;
      const { setState, removeState } = useState(markState, valueof2);
      const markerStyle = { inactive: subObject(inactive, "marker") };
      const labelStyle = { inactive: subObject(inactive, "label") };
      const { setState: setM, removeState: removeM } = useState(markerStyle);
      const { setState: setL, removeState: removeL } = useState(labelStyle);
      const updateLegendState = (highlight) => {
        for (const item of items) {
          const marker = markerOf(item);
          const label = labelOf(item);
          if (item === highlight || highlight === null) {
            removeM(marker, "inactive");
            removeL(label, "inactive");
          } else {
            setM(marker, "inactive");
            setL(label, "inactive");
          }
        }
      };
      const highlightItem = (event, item) => {
        const value2 = datumOf(item);
        const elementSet = new Set(elementGroup.get(value2));
        for (const e3 of elements) {
          if (elementSet.has(e3))
            setState(e3, "active");
          else
            setState(e3, "inactive");
        }
        updateLegendState(item);
        const { nativeEvent = true } = event;
        if (!nativeEvent)
          return;
        emitter.emit("legend:highlight", Object.assign(Object.assign({}, event), { nativeEvent, data: { channel, value: value2 } }));
      };
      const itemPointerover = /* @__PURE__ */ new Map();
      for (const item of items) {
        const pointerover = (event) => {
          highlightItem(event, item);
        };
        item.addEventListener("pointerover", pointerover);
        itemPointerover.set(item, pointerover);
      }
      const pointerleave = (event) => {
        for (const e3 of elements)
          removeState(e3, "inactive", "active");
        updateLegendState(null);
        const { nativeEvent = true } = event;
        if (!nativeEvent)
          return;
        emitter.emit("legend:unhighlight", { nativeEvent });
      };
      const onHighlight = (event) => {
        const { nativeEvent, data } = event;
        if (nativeEvent)
          return;
        const { channel: specifiedChannel, value: value2 } = data;
        if (specifiedChannel !== channel)
          return;
        const item = items.find((d3) => datumOf(d3) === value2);
        if (!item)
          return;
        highlightItem({ nativeEvent: false }, item);
      };
      const onUnHighlight = (event) => {
        const { nativeEvent } = event;
        if (nativeEvent)
          return;
        pointerleave({ nativeEvent: false });
      };
      legend.addEventListener("pointerleave", pointerleave);
      emitter.on("legend:highlight", onHighlight);
      emitter.on("legend:unhighlight", onUnHighlight);
      const destroy2 = () => {
        legend.removeEventListener(pointerleave);
        emitter.off("legend:highlight", onHighlight);
        emitter.off("legend:unhighlight", onUnHighlight);
        for (const [item, pointerover] of itemPointerover) {
          item.removeEventListener(pointerover);
        }
      };
      destroys.push(destroy2);
    }
    return () => destroys.forEach((d3) => d3());
  };
}

// node_modules/@antv/g2/esm/interaction/brushHighlight.js
var __rest83 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function intersect2(bbox1, bbox2) {
  const [minX1, minY1, maxX1, maxY1] = bbox1;
  const [minX2, minY2, maxX2, maxY2] = bbox2;
  return !(minX2 > maxX1 || maxX2 < minX1 || minY2 > maxY1 || maxY2 < minY1);
}
function normalizeBounds(x2, y3, x12, y12, extent2) {
  const [minX, minY, maxX, maxY2] = extent2;
  return [
    Math.max(minX, Math.min(x2, x12)),
    Math.max(minY, Math.min(y3, y12)),
    Math.min(maxX, Math.max(x2, x12)),
    Math.min(maxY2, Math.max(y3, y12))
  ];
}
function bboxOf2(root) {
  const { width, height } = root.getBBox();
  return [0, 0, width, height];
}
function applyStyle3(selection, style) {
  for (const [key, value2] of Object.entries(style)) {
    selection.style(key, value2);
  }
}
var ResizableMask = createElement((g) => {
  const _a = g.attributes, { x: x2, y: y3, width, height, class: className2, renders = {}, handleSize: size4 = 10, document: document2 } = _a, style = __rest83(_a, ["x", "y", "width", "height", "class", "renders", "handleSize", "document"]);
  if (!document2 || width === void 0 || height === void 0 || x2 === void 0 || y3 === void 0)
    return;
  const half = size4 / 2;
  const renderRect = (g2, options, document3) => {
    if (!g2.handle) {
      g2.handle = document3.createElement("rect");
      g2.append(g2.handle);
    }
    const { handle } = g2;
    handle.attr(options);
    return handle;
  };
  const _b = subObject(omitPrefixObject(style, "handleNW", "handleNE"), "handleN"), { render: handleNRender = renderRect } = _b, handleNStyle = __rest83(_b, ["render"]);
  const _c = subObject(style, "handleE"), { render: handleERender = renderRect } = _c, handleEStyle = __rest83(_c, ["render"]);
  const _d = subObject(omitPrefixObject(style, "handleSE", "handleSW"), "handleS"), { render: handleSRender = renderRect } = _d, handleSStyle = __rest83(_d, ["render"]);
  const _e = subObject(style, "handleW"), { render: handleWRender = renderRect } = _e, handleWStyle = __rest83(_e, ["render"]);
  const _f = subObject(style, "handleNW"), { render: handleNWRender = renderRect } = _f, handleNWStyle = __rest83(_f, ["render"]);
  const _g = subObject(style, "handleNE"), { render: handleNERender = renderRect } = _g, handleNEStyle = __rest83(_g, ["render"]);
  const _h = subObject(style, "handleSE"), { render: handleSERender = renderRect } = _h, handleSEStyle = __rest83(_h, ["render"]);
  const _j = subObject(style, "handleSW"), { render: handleSWRender = renderRect } = _j, handleSWStyle = __rest83(_j, ["render"]);
  const renderHandle = (g2, renderNode) => {
    const { id: id2 } = g2;
    const handle = renderNode(g2, g2.attributes, document2);
    handle.id = id2;
    handle.style.draggable = true;
  };
  const appendHandle = (handleRender) => {
    return () => {
      const Node4 = createElement((g2) => renderHandle(g2, handleRender));
      return new Node4({});
    };
  };
  const container = select(g).attr("className", className2).style("transform", `translate(${x2}, ${y3})`).style("draggable", true);
  container.maybeAppend("selection", "rect").style("draggable", true).style("fill", "transparent").call(applyStyle3, Object.assign(Object.assign({
    width,
    height
  }, omitPrefixObject(style, "handle")), { transform: void 0 }));
  container.maybeAppend("handle-n", appendHandle(handleNRender)).style("x", half).style("y", -half).style("width", width - size4).style("height", size4).style("fill", "transparent").call(applyStyle3, handleNStyle);
  container.maybeAppend("handle-e", appendHandle(handleERender)).style("x", width - half).style("y", half).style("width", size4).style("height", height - size4).style("fill", "transparent").call(applyStyle3, handleEStyle);
  container.maybeAppend("handle-s", appendHandle(handleSRender)).style("x", half).style("y", height - half).style("width", width - size4).style("height", size4).style("fill", "transparent").call(applyStyle3, handleSStyle);
  container.maybeAppend("handle-w", appendHandle(handleWRender)).style("x", -half).style("y", half).style("width", size4).style("height", height - size4).style("fill", "transparent").call(applyStyle3, handleWStyle);
  container.maybeAppend("handle-nw", appendHandle(handleNWRender)).style("x", -half).style("y", -half).style("width", size4).style("height", size4).style("fill", "transparent").call(applyStyle3, handleNWStyle);
  container.maybeAppend("handle-ne", appendHandle(handleNERender)).style("x", width - half).style("y", -half).style("width", size4).style("height", size4).style("fill", "transparent").call(applyStyle3, handleNEStyle);
  container.maybeAppend("handle-se", appendHandle(handleSERender)).style("x", width - half).style("y", height - half).style("width", size4).style("height", size4).style("fill", "transparent").call(applyStyle3, handleSEStyle);
  container.maybeAppend("handle-sw", appendHandle(handleSWRender)).style("x", -half).style("y", height - half).style("width", size4).style("height", size4).style("fill", "transparent").call(applyStyle3, handleSWStyle);
});
function brush(root, _a) {
  var { brushed = () => {
  }, brushended = () => {
  }, brushcreated = () => {
  }, brushstarted = () => {
  }, brushupdated = () => {
  }, extent: extent2 = bboxOf2(root), brushRegion = (x2, y3, x12, y12, extent3) => [x2, y3, x12, y12], reverse: reverse2 = false, fill = "#777", fillOpacity = "0.3", stroke: stroke2 = "#fff", selectedHandles = [
    "handle-n",
    "handle-e",
    "handle-s",
    "handle-w",
    "handle-nw",
    "handle-ne",
    "handle-se",
    "handle-sw"
  ] } = _a, style = __rest83(_a, ["brushed", "brushended", "brushcreated", "brushstarted", "brushupdated", "extent", "brushRegion", "reverse", "fill", "fillOpacity", "stroke", "selectedHandles"]);
  let start = null;
  let end = null;
  let moveStart = null;
  let mask = null;
  let background = null;
  let creating = false;
  const [originX, originY, width, height] = extent2;
  setCursor(root, "crosshair");
  root.style.draggable = true;
  const initMask = (x2, y3, event) => {
    brushstarted(event);
    if (mask)
      mask.remove();
    if (background)
      background.remove();
    start = [x2, y3];
    if (reverse2)
      return initReverseMask();
    initNormalMask();
  };
  const initReverseMask = () => {
    background = new Path({
      style: Object.assign(Object.assign({}, style), {
        fill,
        fillOpacity,
        stroke: stroke2,
        pointerEvents: "none"
      })
    });
    mask = new ResizableMask({
      // @ts-ignore
      style: {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        draggable: true,
        document: root.ownerDocument
      },
      className: "mask"
    });
    root.appendChild(background);
    root.appendChild(mask);
  };
  const initNormalMask = () => {
    mask = new ResizableMask({
      // @ts-ignore
      style: Object.assign(Object.assign({ document: root.ownerDocument, x: 0, y: 0 }, style), {
        fill,
        fillOpacity,
        stroke: stroke2,
        draggable: true
      }),
      className: "mask"
    });
    root.appendChild(mask);
  };
  const removeMask = (emit = true) => {
    if (mask)
      mask.remove();
    if (background)
      background.remove();
    start = null;
    end = null;
    moveStart = null;
    creating = false;
    mask = null;
    background = null;
    brushended(emit);
  };
  const updateMask = (start2, end2, emit = true) => {
    const [x2, y3, x12, y12] = normalizeBounds(start2[0], start2[1], end2[0], end2[1], extent2);
    const [fx, fy, fx1, fy1] = brushRegion(x2, y3, x12, y12, extent2);
    if (reverse2)
      updateReverseMask(fx, fy, fx1, fy1);
    else
      updateNormalMask(fx, fy, fx1, fy1);
    brushed(fx, fy, fx1, fy1, emit);
    return [fx, fy, fx1, fy1];
  };
  const updateNormalMask = (x2, y3, x12, y12) => {
    mask.style.x = x2;
    mask.style.y = y3;
    mask.style.width = x12 - x2;
    mask.style.height = y12 - y3;
  };
  const updateReverseMask = (x2, y3, x12, y12) => {
    background.style.d = `
      M${originX},${originY}L${width},${originY}L${width},${height}L${originX},${height}Z
      M${x2},${y3}L${x2},${y12}L${x12},${y12}L${x12},${y3}Z
    `;
    mask.style.x = x2;
    mask.style.y = y3;
    mask.style.width = x12 - x2;
    mask.style.height = y12 - y3;
  };
  const moveMask = (current) => {
    const clip = (dt, start2, end2, min6, max7) => {
      if (dt + start2 < min6)
        return min6 - start2;
      if (dt + end2 > max7)
        return max7 - end2;
      return dt;
    };
    const dx = current[0] - moveStart[0];
    const dy = current[1] - moveStart[1];
    const dx1 = clip(dx, start[0], end[0], originX, width);
    const dy1 = clip(dy, start[1], end[1], originY, height);
    const currentStart = [start[0] + dx1, start[1] + dy1];
    const currentEnd = [end[0] + dx1, end[1] + dy1];
    updateMask(currentStart, currentEnd);
  };
  const handles = {
    "handle-n": { vector: [0, 1, 0, 0], cursor: "ns-resize" },
    "handle-e": { vector: [0, 0, 1, 0], cursor: "ew-resize" },
    "handle-s": { vector: [0, 0, 0, 1], cursor: "ns-resize" },
    "handle-w": { vector: [1, 0, 0, 0], cursor: "ew-resize" },
    "handle-nw": { vector: [1, 1, 0, 0], cursor: "nwse-resize" },
    "handle-ne": { vector: [0, 1, 1, 0], cursor: "nesw-resize" },
    "handle-se": { vector: [0, 0, 1, 1], cursor: "nwse-resize" },
    "handle-sw": { vector: [1, 0, 0, 1], cursor: "nesw-resize" }
  };
  const isMask = (target) => {
    return isSelection(target) || isHandle(target);
  };
  const isHandle = (target) => {
    const { id: id2 } = target;
    if (selectedHandles.indexOf(id2) === -1)
      return false;
    return new Set(Object.keys(handles)).has(id2);
  };
  const isSelection = (target) => {
    return target === mask.getElementById("selection");
  };
  const dragstart = (event) => {
    const { target } = event;
    const [offsetX, offsetY] = brushMousePosition(root, event);
    if (!mask || !isMask(target)) {
      initMask(offsetX, offsetY, event);
      creating = true;
      return;
    }
    if (isMask(target)) {
      moveStart = [offsetX, offsetY];
    }
  };
  const drag = (event) => {
    const { target } = event;
    const mouse = brushMousePosition(root, event);
    if (!start)
      return;
    if (!moveStart)
      return updateMask(start, mouse);
    if (isSelection(target))
      return moveMask(mouse);
    const [dx, dy] = [mouse[0] - moveStart[0], mouse[1] - moveStart[1]];
    const { id: id2 } = target;
    if (handles[id2]) {
      const [sx, sy, ex, ey] = handles[id2].vector;
      return updateMask([start[0] + dx * sx, start[1] + dy * sy], [end[0] + dx * ex, end[1] + dy * ey]);
    }
  };
  const dragend = (event) => {
    if (moveStart) {
      moveStart = null;
      const { x: x2, y: y3, width: width2, height: height2 } = mask.style;
      start = [x2, y3];
      end = [x2 + width2, y3 + height2];
      brushupdated(x2, y3, x2 + width2, y3 + height2, event);
      return;
    }
    end = brushMousePosition(root, event);
    const [fx, fy, fx1, fy1] = updateMask(start, end);
    creating = false;
    brushcreated(fx, fy, fx1, fy1, event);
  };
  const click = (event) => {
    const { target } = event;
    if (mask && !isMask(target))
      removeMask();
  };
  const pointermove = (event) => {
    const { target } = event;
    if (!mask || !isMask(target) || creating)
      setCursor(root, "crosshair");
    else if (isSelection(target))
      setCursor(root, "move");
    else if (isHandle(target))
      setCursor(root, handles[target.id].cursor);
  };
  const pointerleave = () => {
    setCursor(root, "default");
  };
  root.addEventListener("dragstart", dragstart);
  root.addEventListener("drag", drag);
  root.addEventListener("dragend", dragend);
  root.addEventListener("click", click);
  root.addEventListener("pointermove", pointermove);
  root.addEventListener("pointerleave", pointerleave);
  return {
    mask,
    move(x2, y3, x12, y12, emit = true) {
      if (!mask)
        initMask(x2, y3, {});
      start = [x2, y3];
      end = [x12, y12];
      updateMask([x2, y3], [x12, y12], emit);
    },
    remove(emit = true) {
      if (mask)
        removeMask(emit);
    },
    destroy() {
      if (mask)
        removeMask(false);
      setCursor(root, "default");
      root.removeEventListener("dragstart", dragstart);
      root.removeEventListener("drag", drag);
      root.removeEventListener("dragend", dragend);
      root.removeEventListener("click", click);
      root.removeEventListener("pointermove", pointermove);
      root.removeEventListener("pointerleave", pointerleave);
    }
  };
}
function selectSiblingViews(target, viewInstances, brushKey) {
  return viewInstances.filter((d3) => {
    if (d3 === target)
      return false;
    const { interaction = {} } = d3.options;
    return Object.values(interaction).find((d4) => d4.brushKey === brushKey);
  });
}
function selectSiblingContainers(target, viewInstances, brushKey) {
  return selectSiblingViews(target, viewInstances, brushKey).map((d3) => selectPlotArea(d3.container));
}
function selectSiblingOptions(target, viewInstances, brushKey) {
  return selectSiblingViews(target, viewInstances, brushKey).map((d3) => d3.options);
}
function brushHighlight(root, _a) {
  var { elements: elementof, selectedHandles, siblings: siblingsof = (root2) => [], datum, brushRegion, extent: optionalExtent, reverse: reverse2, scale: scale4, coordinate, series = false, key = (d3) => d3, bboxOf: bboxOf3 = (root2) => {
    const { x: x2, y: y3, width, height } = root2.style;
    return { x: x2, y: y3, width, height };
  }, state = {}, emitter } = _a, rest = __rest83(_a, ["elements", "selectedHandles", "siblings", "datum", "brushRegion", "extent", "reverse", "scale", "coordinate", "series", "key", "bboxOf", "state", "emitter"]);
  const elements = elementof(root);
  const siblings = siblingsof(root);
  const siblingElements = siblings.flatMap(elementof);
  const valueof2 = createValueof(elements, datum);
  const brushStyle = subObject(rest, "mask");
  const { setState, removeState } = useState(state, valueof2);
  const clonedElement = /* @__PURE__ */ new Map();
  const { width: rootWidth, height: rootHeight, x: ordinalX = 0, y: ordinalY = 0 } = bboxOf3(root);
  const extent2 = optionalExtent ? optionalExtent : [0, 0, rootWidth, rootHeight];
  const brushended = () => {
    for (const element of [...elements, ...siblingElements]) {
      removeState(element, "active", "inactive");
    }
  };
  const brushed = (x2, y3, x12, y12) => {
    var _a2;
    for (const sibling of siblings)
      (_a2 = sibling.brush) === null || _a2 === void 0 ? void 0 : _a2.remove();
    const keys = /* @__PURE__ */ new Set();
    for (const element of elements) {
      const { min: min6, max: max7 } = element.getLocalBounds();
      const [ex, ey] = min6;
      const [ex1, ey1] = max7;
      if (!intersect2([ex, ey, ex1, ey1], [x2, y3, x12, y12])) {
        setState(element, "inactive");
      } else {
        setState(element, "active");
        keys.add(key(element));
      }
    }
    for (const element of siblingElements) {
      if (keys.has(key(element)))
        setState(element, "active");
      else
        setState(element, "inactive");
    }
  };
  const seriesBrushend = () => {
    for (const element of elements)
      removeState(element, "inactive");
    for (const cloned of clonedElement.values())
      cloned.remove();
    clonedElement.clear();
  };
  const seriesBrushed = (x2, y3, x12, y12) => {
    const clone = (element) => {
      const cloned = element.cloneNode();
      cloned.__data__ = element.__data__;
      element.parentNode.appendChild(cloned);
      clonedElement.set(element, cloned);
      return cloned;
    };
    const clipPath = new Rect({
      style: {
        x: x2 + ordinalX,
        y: y3 + ordinalY,
        width: x12 - x2,
        height: y12 - y3
      }
    });
    root.appendChild(clipPath);
    for (const element of elements) {
      const cloned = clonedElement.get(element) || clone(element);
      cloned.style.clipPath = clipPath;
      setState(element, "inactive");
      setState(cloned, "active");
    }
  };
  const brushHandler = brush(root, Object.assign(Object.assign({}, brushStyle), {
    extent: extent2,
    brushRegion,
    reverse: reverse2,
    selectedHandles,
    brushended: (emit) => {
      const handler = series ? seriesBrushend : brushended;
      if (emit) {
        emitter.emit("brush:remove", { nativeEvent: true });
      }
      handler();
    },
    brushed: (x2, y3, x12, y12, emit) => {
      const selection = selectionOf(x2, y3, x12, y12, scale4, coordinate);
      if (emit) {
        emitter.emit("brush:highlight", {
          nativeEvent: true,
          data: { selection }
        });
      }
      const handler = series ? seriesBrushed : brushed;
      handler(x2, y3, x12, y12);
    },
    brushcreated: (x2, y3, x12, y12, event) => {
      const selection = selectionOf(x2, y3, x12, y12, scale4, coordinate);
      emitter.emit("brush:end", Object.assign(Object.assign({}, event), { nativeEvent: true, data: { selection } }));
    },
    brushupdated: (x2, y3, x12, y12, event) => {
      const selection = selectionOf(x2, y3, x12, y12, scale4, coordinate);
      emitter.emit("brush:end", Object.assign(Object.assign({}, event), { nativeEvent: true, data: { selection } }));
    },
    brushstarted: (e3) => {
      emitter.emit("brush:start", e3);
    }
  }));
  const onHighlight = ({ nativeEvent, data }) => {
    if (nativeEvent)
      return;
    const { selection } = data;
    const [x2, y3, x12, y12] = pixelsOf(selection, scale4, coordinate);
    brushHandler.move(x2, y3, x12, y12, false);
  };
  emitter.on("brush:highlight", onHighlight);
  const onRemove = ({ nativeEvent } = {}) => {
    if (nativeEvent)
      return;
    brushHandler.remove(false);
  };
  emitter.on("brush:remove", onRemove);
  const preBrushDestroy = brushHandler.destroy.bind(brushHandler);
  brushHandler.destroy = () => {
    emitter.off("brush:highlight", onHighlight);
    emitter.off("brush:remove", onRemove);
    preBrushDestroy();
  };
  return brushHandler;
}
function BrushHighlight(_a) {
  var { facet, brushKey } = _a, rest = __rest83(_a, ["facet", "brushKey"]);
  return (target, viewInstances, emitter) => {
    const { container, view, options } = target;
    const plotArea = selectPlotArea(container);
    const defaultOptions = {
      maskFill: "#777",
      maskFillOpacity: "0.3",
      maskStroke: "#fff",
      reverse: false
    };
    const defaultStates = ["active", ["inactive", { opacity: 0.5 }]];
    const { scale: scale4, coordinate } = view;
    if (facet) {
      const bbox = plotArea.getBounds();
      const x2 = bbox.min[0];
      const y3 = bbox.min[1];
      const x12 = bbox.max[0];
      const y12 = bbox.max[1];
      return brushHighlight(plotArea.parentNode.parentNode, Object.assign(Object.assign({
        elements: () => selectFacetG2Elements(target, viewInstances),
        datum: createDatumof(selectFacetViews(target, viewInstances).map((d3) => d3.view)),
        brushRegion: (x3, y4, x13, y13) => [x3, y4, x13, y13],
        extent: [x2, y3, x12, y12],
        state: mergeState(selectFacetViews(target, viewInstances).map((d3) => d3.options), defaultStates),
        emitter,
        scale: scale4,
        coordinate,
        selectedHandles: void 0
      }, defaultOptions), rest));
    }
    const brush2 = brushHighlight(plotArea, Object.assign(Object.assign({
      elements: selectG2Elements,
      key: (element) => element.__data__.key,
      siblings: () => selectSiblingContainers(target, viewInstances, brushKey),
      datum: createDatumof([
        view,
        ...selectSiblingViews(target, viewInstances, brushKey).map((d3) => d3.view)
      ]),
      brushRegion: (x2, y3, x12, y12) => [x2, y3, x12, y12],
      extent: void 0,
      state: mergeState([options, ...selectSiblingOptions(target, viewInstances, brushKey)], defaultStates),
      emitter,
      scale: scale4,
      coordinate,
      selectedHandles: void 0
    }, defaultOptions), rest));
    plotArea.brush = brush2;
    return () => brush2.destroy();
  };
}
BrushHighlight.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/brushXHighlight.js
function brushXRegion(x2, y3, x12, y12, extent2) {
  const [, minY, , maxY2] = extent2;
  return [x2, minY, x12, maxY2];
}
function BrushXHighlight(options) {
  return BrushHighlight(Object.assign(Object.assign({}, options), { brushRegion: brushXRegion, selectedHandles: ["handle-e", "handle-w"] }));
}

// node_modules/@antv/g2/esm/interaction/brushYHighlight.js
function brushYRegion(x2, y3, x12, y12, extent2) {
  const [minX, , maxX] = extent2;
  return [minX, y3, maxX, y12];
}
function BrushYHighlight(options) {
  return BrushHighlight(Object.assign(Object.assign({}, options), { brushRegion: brushYRegion, selectedHandles: ["handle-n", "handle-s"] }));
}

// node_modules/@antv/g2/esm/interaction/brushAxisHighlight.js
var __rest84 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var AXIS_CLASS_NAME = "axis";
var AXIS_LINE_CLASS_NAME = "axis-line";
var AXIS_MAIN_CLASS_NAME = "axis-main-group";
var AXIS_HOT_AREA_CLASS_NAME = "axis-hot-area";
function axesOf(container) {
  return container.getElementsByClassName(AXIS_CLASS_NAME);
}
function lineOf(axis) {
  return axis.getElementsByClassName(AXIS_LINE_CLASS_NAME)[0];
}
function mainGroupOf(axis) {
  return axis.getElementsByClassName(AXIS_MAIN_CLASS_NAME)[0];
}
function boundsOfAxis(axis) {
  return mainGroupOf(axis).getLocalBounds();
}
function verticalBrush(axis, _a) {
  var { cross: cross3, offsetX, offsetY } = _a, style = __rest84(_a, ["cross", "offsetX", "offsetY"]);
  const bounds = boundsOfAxis(axis);
  const axisLine = lineOf(axis);
  const [lineX] = axisLine.getLocalBounds().min;
  const [minX, minY] = bounds.min;
  const [maxX, maxY2] = bounds.max;
  const size4 = (maxX - minX) * 2;
  return {
    brushRegion: brushYRegion,
    hotZone: new Rect({
      className: AXIS_HOT_AREA_CLASS_NAME,
      style: Object.assign({
        // If it is not cross, draw brush in both side of axisLine,
        // otherwise the draw brush within bounds area.
        width: cross3 ? size4 / 2 : size4,
        transform: `translate(${(cross3 ? minX : lineX - size4 / 2).toFixed(2)}, ${minY})`,
        height: maxY2 - minY
      }, style)
    }),
    extent: cross3 ? (
      // If it is cross, the x range is ignored.
      (x2, y3, x12, y12) => [-Infinity, y3, Infinity, y12]
    ) : (x2, y3, x12, y12) => [
      Math.floor(minX - offsetX),
      y3,
      Math.ceil(maxX - offsetX),
      y12
    ]
  };
}
function horizontalBrush(axis, _a) {
  var { offsetY, offsetX, cross: cross3 = false } = _a, style = __rest84(_a, ["offsetY", "offsetX", "cross"]);
  const bounds = boundsOfAxis(axis);
  const axisLine = lineOf(axis);
  const [, lineY] = axisLine.getLocalBounds().min;
  const [minX, minY] = bounds.min;
  const [maxX, maxY2] = bounds.max;
  const size4 = maxY2 - minY;
  return {
    brushRegion: brushXRegion,
    hotZone: new Rect({
      className: AXIS_HOT_AREA_CLASS_NAME,
      style: Object.assign({
        width: maxX - minX,
        // If it is not cross, draw brush in both side of axisLine,
        // otherwise the draw brush within bounds area.
        height: cross3 ? size4 : size4 * 2,
        transform: `translate(${minX}, ${cross3 ? minY : lineY - size4})`
      }, style)
    }),
    extent: cross3 ? (
      // If it is cross, the y range is ignored.
      (x2, y3, x12, y12) => [x2, -Infinity, x12, Infinity]
    ) : (x2, y3, x12, y12) => [
      x2,
      Math.floor(minY - offsetY),
      x12,
      Math.ceil(maxY2 - offsetY)
    ]
  };
}
function brushAxisHighlight(root, _a) {
  var {
    axes: axesOf2,
    // given root, return axes
    elements: elementsOf,
    // given root, return elements
    points: pointsOf,
    // given shape, return control points
    horizontal: isHorizontal2,
    // given axis, return direction
    datum,
    // given shape, return datum
    offsetY,
    // offsetY for shape area
    offsetX,
    // offsetX for shape area
    reverse: reverse2 = false,
    state = {},
    emitter,
    coordinate
  } = _a, rest = __rest84(_a, ["axes", "elements", "points", "horizontal", "datum", "offsetY", "offsetX", "reverse", "state", "emitter", "coordinate"]);
  const elements = elementsOf(root);
  const axes = axesOf2(root);
  const valueof2 = createValueof(elements, datum);
  const { setState, removeState } = useState(state, valueof2);
  const axisExtent = /* @__PURE__ */ new Map();
  const brushStyle = subObject(rest, "mask");
  const brushed = (points) => Array.from(axisExtent.values()).every(([x2, y3, x12, y12]) => points.some(([x05, y05]) => {
    return x05 >= x2 && x05 <= x12 && y05 >= y3 && y05 <= y12;
  }));
  const scales = axes.map((d3) => d3.attributes.scale);
  const extentOf2 = (D) => D.length > 2 ? [D[0], D[D.length - 1]] : D;
  const indexDomain = /* @__PURE__ */ new Map();
  const initIndexDomain = () => {
    indexDomain.clear();
    for (let i2 = 0; i2 < axes.length; i2++) {
      const scale4 = scales[i2];
      const { domain } = scale4.getOptions();
      indexDomain.set(i2, extentOf2(domain));
    }
  };
  initIndexDomain();
  const updateElement = (i2, emit) => {
    const selectedElements = [];
    for (const element of elements) {
      const points = pointsOf(element);
      if (brushed(points)) {
        setState(element, "active");
        selectedElements.push(element);
      } else
        setState(element, "inactive");
    }
    indexDomain.set(i2, selectionOf2(selectedElements, i2));
    if (!emit)
      return;
    const selection = () => {
      if (!cross3)
        return Array.from(indexDomain.values());
      const S = [];
      for (const [index2, domain] of indexDomain) {
        const scale4 = scales[index2];
        const { name: name2 } = scale4.getOptions();
        if (name2 === "x")
          S[0] = domain;
        else
          S[1] = domain;
      }
      return S;
    };
    emitter.emit("brushAxis:highlight", {
      nativeEvent: true,
      data: {
        selection: selection()
      }
    });
  };
  const clearElement = (emit) => {
    for (const element of elements)
      removeState(element, "active", "inactive");
    initIndexDomain();
    if (!emit)
      return;
    emitter.emit("brushAxis:remove", { nativeEvent: true });
  };
  const selectionOf2 = (selected, i2) => {
    const scale4 = scales[i2];
    const { name: name2 } = scale4.getOptions();
    const domain = selected.map((d3) => {
      const data = d3.__data__;
      return scale4.invert(data[name2]);
    });
    return extentOf2(domainOf3(scale4, domain));
  };
  const cross3 = axes.some(isHorizontal2) && axes.some((d3) => !isHorizontal2(d3));
  const handlers = [];
  for (let i2 = 0; i2 < axes.length; i2++) {
    const axis = axes[i2];
    const createBrush = isHorizontal2(axis) ? horizontalBrush : verticalBrush;
    const { hotZone, brushRegion, extent: extent2 } = createBrush(axis, {
      offsetY,
      offsetX,
      cross: cross3,
      zIndex: 999,
      // Pin mask to top.
      fill: "transparent"
      // Make it interactive.
    });
    axis.parentNode.appendChild(hotZone);
    const brushHandler = brush(hotZone, Object.assign(Object.assign({}, brushStyle), {
      reverse: reverse2,
      brushRegion,
      brushended(emit) {
        axisExtent.delete(axis);
        if (Array.from(axisExtent.entries()).length === 0)
          clearElement(emit);
        else
          updateElement(i2, emit);
      },
      brushed(x2, y3, x12, y12, emit) {
        axisExtent.set(axis, extent2(x2, y3, x12, y12));
        updateElement(i2, emit);
      }
    }));
    handlers.push(brushHandler);
  }
  const onRemove = (event = {}) => {
    const { nativeEvent } = event;
    if (nativeEvent)
      return;
    handlers.forEach((d3) => d3.remove(false));
  };
  const rangeOf7 = (domain, scale4, axis) => {
    const [d0, d1] = domain;
    const maybeStep = (scale5) => scale5.getStep ? scale5.getStep() : 0;
    const x2 = abstractOf2(d0, scale4, axis);
    const x12 = abstractOf2(d1, scale4, axis) + maybeStep(scale4);
    if (isHorizontal2(axis))
      return [x2, -Infinity, x12, Infinity];
    return [-Infinity, x2, Infinity, x12];
  };
  const abstractOf2 = (x2, scale4, axis) => {
    const { height, width } = coordinate.getOptions();
    const scale1 = scale4.clone();
    if (isHorizontal2(axis))
      scale1.update({ range: [0, width] });
    else
      scale1.update({ range: [height, 0] });
    return scale1.map(x2);
  };
  const onHighlight = (event) => {
    const { nativeEvent } = event;
    if (nativeEvent)
      return;
    const { selection } = event.data;
    for (let i2 = 0; i2 < handlers.length; i2++) {
      const domain = selection[i2];
      const handler = handlers[i2];
      const axis = axes[i2];
      if (domain) {
        const scale4 = scales[i2];
        handler.move(...rangeOf7(domain, scale4, axis), false);
      } else {
        handler.remove(false);
      }
    }
  };
  emitter.on("brushAxis:remove", onRemove);
  emitter.on("brushAxis:highlight", onHighlight);
  return () => {
    handlers.forEach((d3) => d3.destroy());
    emitter.off("brushAxis:remove", onRemove);
    emitter.off("brushAxis:highlight", onHighlight);
  };
}
function BrushAxisHighlight(options) {
  return (target, _, emitter) => {
    const { container, view, options: viewOptions } = target;
    const plotArea = selectPlotArea(container);
    const { x: x05, y: y05 } = plotArea.getBBox();
    const { coordinate } = view;
    return brushAxisHighlight(container, Object.assign({
      elements: selectG2Elements,
      axes: axesOf,
      offsetY: y05,
      offsetX: x05,
      points: (element) => element.__data__.points,
      horizontal: (axis) => {
        const { startPos: [sx, sy], endPos: [ex, ey] } = axis.attributes;
        return sx !== ex && sy === ey;
      },
      datum: createDatumof(view),
      state: mergeState(viewOptions, [
        "active",
        ["inactive", { opacity: 0.5 }]
      ]),
      coordinate,
      emitter
    }, options));
  };
}

// node_modules/@antv/g2/esm/interaction/brushFilter.js
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest85 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function dblclick(interval = 300) {
  let preTimeStamp = null;
  return (e3) => {
    const { timeStamp } = e3;
    if (preTimeStamp !== null && timeStamp - preTimeStamp < interval) {
      preTimeStamp = timeStamp;
      return true;
    }
    preTimeStamp = timeStamp;
    return false;
  };
}
function brushFilter(root, _a) {
  var { filter: filter2, reset, brushRegion, extent: optionalExtent, reverse: reverse2, emitter, scale: scale4, coordinate, selection, series = false } = _a, rest = __rest85(_a, ["filter", "reset", "brushRegion", "extent", "reverse", "emitter", "scale", "coordinate", "selection", "series"]);
  const brushStyle = subObject(rest, "mask");
  const { width: rootWidth, height: rootHeight } = root.getBBox();
  const extent2 = optionalExtent ? optionalExtent : [0, 0, rootWidth, rootHeight];
  const isDblclick = dblclick();
  const brush2 = brush(root, Object.assign(Object.assign({}, brushStyle), {
    extent: extent2,
    brushRegion,
    reverse: reverse2,
    brushcreated
  }));
  root.addEventListener("click", click);
  function brushcreated(x2, y3, x12, y12, event) {
    if (x2 === x12 && y3 === y12)
      return;
    event.nativeEvent = true;
    filter2(selection(x2, y3, x12, y12), event);
    brush2.remove();
  }
  function click(e3) {
    if (isDblclick(e3)) {
      e3.nativeEvent = true;
      reset(e3);
    }
  }
  const onFilter = ({ nativeEvent, data }) => {
    if (nativeEvent)
      return;
    const { selection: selection2 } = data;
    filter2(selection2, { nativeEvent: false });
  };
  emitter.on("brush:filter", onFilter);
  return () => {
    brush2.destroy();
    emitter.off("brush:filter", onFilter);
    root.removeEventListener("click", click);
  };
}
function BrushFilter(_a) {
  var { hideX = true, hideY = true } = _a, rest = __rest85(_a, ["hideX", "hideY"]);
  return (target, viewInstances, emitter) => {
    const { container, view, options: viewOptions, update, setState } = target;
    const plotArea = selectPlotArea(container);
    const defaultOptions = {
      maskFill: "#777",
      maskFillOpacity: "0.3",
      maskStroke: "#fff",
      unhighlightedOpacity: 0.5,
      reverse: false
    };
    let filtered = false;
    let filtering = false;
    let newView = view;
    const { scale: scale4, coordinate } = view;
    return brushFilter(plotArea, Object.assign(Object.assign({
      brushRegion: (x2, y3, x12, y12) => [x2, y3, x12, y12],
      selection: (x2, y3, x12, y12) => {
        const { scale: scale5, coordinate: coordinate2 } = newView;
        return selectionOf(x2, y3, x12, y12, scale5, coordinate2);
      },
      filter: (selection, event) => __awaiter9(this, void 0, void 0, function* () {
        if (filtering)
          return;
        filtering = true;
        const [domainX, domainY] = selection;
        setState("brushFilter", (options) => {
          const { marks } = options;
          const newMarks = marks.map((mark2) => deep_mix_default({
            // Hide label to keep smooth transition.
            axis: Object.assign(Object.assign({}, hideX && { x: { transform: [{ type: "hide" }] } }), hideY && { y: { transform: [{ type: "hide" }] } })
          }, mark2, {
            // Set nice to false to avoid modify domain.
            scale: {
              x: { domain: domainX, nice: false },
              y: { domain: domainY, nice: false }
            }
          }));
          return Object.assign(Object.assign({}, viewOptions), { marks: newMarks, clip: true });
        });
        emitter.emit("brush:filter", Object.assign(Object.assign({}, event), { data: { selection: [domainX, domainY] } }));
        const newState = yield update();
        newView = newState.view;
        filtering = false;
        filtered = true;
      }),
      reset: (event) => {
        if (filtering || !filtered)
          return;
        const { scale: scale5 } = view;
        const { x: scaleX, y: scaleY } = scale5;
        const domainX = scaleX.getOptions().domain;
        const domainY = scaleY.getOptions().domain;
        emitter.emit("brush:filter", Object.assign(Object.assign({}, event), { data: { selection: [domainX, domainY] } }));
        filtered = false;
        newView = view;
        setState("brushFilter");
        update();
      },
      extent: void 0,
      emitter,
      scale: scale4,
      coordinate
    }, defaultOptions), rest));
  };
}

// node_modules/@antv/g2/esm/interaction/brushXFilter.js
function BrushXFilter(options) {
  return BrushFilter(Object.assign(Object.assign({ hideX: true }, options), { brushRegion: brushXRegion }));
}

// node_modules/@antv/g2/esm/interaction/brushYFilter.js
function BrushYFilter(options) {
  return BrushFilter(Object.assign(Object.assign({ hideY: true }, options), { brushRegion: brushYRegion }));
}

// node_modules/@antv/g2/esm/interaction/adaptiveFilter.js
function extractSingleAxisScaleInfo(shouldFilterXAxis, scaleX, scaleY) {
  const currentScale = shouldFilterXAxis ? scaleY : scaleX;
  const targetScale = shouldFilterXAxis ? scaleX : scaleY;
  const isSourceDiscrete = isOrdinalScale(currentScale);
  const isTargetDiscrete = isOrdinalScale(targetScale);
  const targetOriginalDomain = targetScale.getOptions().domain;
  const shouldPreserveZeroBaseline = !isTargetDiscrete && targetOriginalDomain && targetOriginalDomain.length >= 2 && targetOriginalDomain[0] === 0;
  return {
    currentScale,
    targetScale,
    isSourceDiscrete,
    isTargetDiscrete,
    shouldPreserveZeroBaseline
  };
}
function extractMultiAxisScaleInfo(shouldFilterXAxis, scale4, scaleX, scaleY, channelDomain) {
  const currentScale = shouldFilterXAxis ? scaleY : scaleX;
  const getAxisScaleDomains = (axisType) => {
    const axisScales = {};
    Object.keys(channelDomain).forEach((key) => {
      if (key === axisType || key.match(new RegExp(`^${axisType}\\d+$`))) {
        axisScales[key] = channelDomain[key];
      }
    });
    return axisScales;
  };
  const targetScaleDomain = shouldFilterXAxis ? getAxisScaleDomains("x") : getAxisScaleDomains("y");
  const targetScaleKeys = Object.keys(targetScaleDomain);
  const targetScales = targetScaleKeys.map((item) => scale4[item]);
  const isSourceDiscrete = isOrdinalScale(currentScale);
  const isTargetDiscrete = targetScales.map((targetScale) => isOrdinalScale(targetScale));
  const shouldPreserveZeroBaseline = targetScales.map((targetScale, index2) => {
    const targetOriginalDomain = targetScale.getOptions().domain;
    const isDiscrete = isTargetDiscrete[index2];
    return !isDiscrete && targetOriginalDomain && targetOriginalDomain.length >= 2 && targetOriginalDomain[0] === 0;
  });
  return {
    currentScale,
    targetScales,
    isSourceDiscrete,
    isTargetDiscrete,
    shouldPreserveZeroBaseline,
    targetScaleKeys
  };
}
function getUniqueSortedValues(values4) {
  const uniqueValues = Array.from(new Set(values4));
  return uniqueValues.sort((a4, b) => a4 - b);
}
function calculateFilteredDomain({ isTargetDiscrete, filteredValues, shouldPreserveZeroBaseline }) {
  if (isTargetDiscrete) {
    return getUniqueSortedValues(filteredValues);
  } else {
    const min6 = Math.min(...filteredValues);
    const max7 = Math.max(...filteredValues);
    return shouldPreserveZeroBaseline ? [0, max7] : [min6, max7];
  }
}
function convertToNumeric(value2) {
  if (value2 instanceof Date) {
    return value2.getTime();
  }
  if (typeof value2 === "string") {
    return parseFloat(value2);
  }
  return Number(value2);
}
function filterMarkDataByDomain(markDataPairs, domain, isSourceDiscrete, isTargetDiscrete, shouldPreserveZeroBaseline, adaptiveMode = "filter", shouldFilterXAxis = false) {
  if (isFalsyValue(adaptiveMode)) {
    return [];
  }
  const sourceChannel = shouldFilterXAxis ? "y" : "x";
  const targetChannel = shouldFilterXAxis ? "x" : "y";
  const allFilteredTargetValues = [];
  for (const markData of markDataPairs) {
    const { channelData } = markData;
    const sourceValues = channelData[sourceChannel] || [];
    const targetValues = channelData[targetChannel] || [];
    const normalizedSourceValues = Array.isArray(sourceValues[0]) ? sourceValues[0] : sourceValues;
    const isTargetArray2D = Array.isArray(targetValues[0]);
    if (normalizedSourceValues.length === 0)
      continue;
    const dataLength = normalizedSourceValues.length;
    for (let i2 = 0; i2 < dataLength; i2++) {
      const sourceValue = normalizedSourceValues[i2];
      let shouldInclude = false;
      if (isSourceDiscrete) {
        shouldInclude = domain.includes(sourceValue);
      } else {
        if (domain.length >= 2) {
          const sourceTime = convertToNumeric(sourceValue);
          const domainStartTime = convertToNumeric(domain[0]);
          const domainEndTime = convertToNumeric(domain[domain.length - 1]);
          if (!isNaN(sourceTime) && !isNaN(domainStartTime) && !isNaN(domainEndTime)) {
            shouldInclude = sourceTime >= domainStartTime && sourceTime <= domainEndTime;
          }
        }
      }
      if (adaptiveMode === "filter" && shouldInclude) {
        if (isTargetArray2D) {
          const numChannels = targetValues.length;
          for (let channelIdx = 0; channelIdx < numChannels; channelIdx++) {
            const channelData2 = targetValues[channelIdx];
            if (Array.isArray(channelData2) && i2 < channelData2.length) {
              const targetValue = channelData2[i2];
              const numericValue = convertToNumeric(targetValue);
              if (!isNaN(numericValue)) {
                allFilteredTargetValues.push(numericValue);
              }
            }
          }
        } else {
          if (i2 < targetValues.length) {
            const targetValue = targetValues[i2];
            const numericValue = convertToNumeric(targetValue);
            if (!isNaN(numericValue)) {
              allFilteredTargetValues.push(numericValue);
            }
          }
        }
      }
    }
  }
  if (allFilteredTargetValues.length > 0) {
    return calculateFilteredDomain({
      isTargetDiscrete,
      filteredValues: allFilteredTargetValues,
      shouldPreserveZeroBaseline
    });
  }
  return [];
}
function processSingleAxisFiltering({ markDataPairs, domain, scaleInfo, adaptiveMode, shouldFilterXAxis = false }) {
  const { isSourceDiscrete, isTargetDiscrete, shouldPreserveZeroBaseline } = scaleInfo;
  return filterMarkDataByDomain(markDataPairs, domain, isSourceDiscrete, isTargetDiscrete, shouldPreserveZeroBaseline, adaptiveMode, shouldFilterXAxis);
}
function processMultiAxisViewFiltering({ markDataPairs, domain, scaleInfo, markToScaleMap, adaptiveMode, shouldFilterXAxis = false }) {
  const filteredDomain = /* @__PURE__ */ new Map();
  const { isSourceDiscrete, isTargetDiscrete, shouldPreserveZeroBaseline, targetScaleKeys } = scaleInfo;
  markDataPairs.forEach((markData) => {
    const scaleKey = markToScaleMap.get(markData.markKey);
    if (!scaleKey)
      return;
    const scaleIndex = targetScaleKeys.indexOf(scaleKey);
    if (scaleIndex === -1)
      return;
    const currentIsTargetDiscrete = isTargetDiscrete[scaleIndex];
    const currentShouldPreserveZeroBaseline = shouldPreserveZeroBaseline[scaleIndex];
    const markFilteredDomain = filterMarkDataByDomain([markData], domain, isSourceDiscrete, currentIsTargetDiscrete, currentShouldPreserveZeroBaseline, adaptiveMode, shouldFilterXAxis);
    filteredDomain.set(scaleKey, markFilteredDomain);
  });
  return filteredDomain;
}
function processMultiAxisMarkFiltering(markDataPairs, domain, scaleInfo, targetMarkKey, targetScaleKey, adaptiveMode, shouldFilterXAxis = false, markToScaleMap) {
  const filteredDomain = /* @__PURE__ */ new Map();
  if (markDataPairs.length === 0 || domain.length === 0) {
    return filteredDomain;
  }
  const { isSourceDiscrete, isTargetDiscrete, shouldPreserveZeroBaseline } = scaleInfo;
  const relevantMarkData = markToScaleMap ? markDataPairs.filter((markData) => {
    const markScaleKey = markToScaleMap.get(markData.markKey);
    return markScaleKey === targetScaleKey;
  }) : markDataPairs.filter((markData) => markData.markKey === targetMarkKey);
  if (relevantMarkData.length === 0) {
    return filteredDomain;
  }
  const markFilteredDomain = filterMarkDataByDomain(relevantMarkData, domain, isSourceDiscrete, isTargetDiscrete, shouldPreserveZeroBaseline, adaptiveMode, shouldFilterXAxis);
  filteredDomain.set(targetScaleKey, markFilteredDomain);
  return filteredDomain;
}
function updateChannelDomains(channelDomain, filteredDomain, shouldFilterXAxis, isMultiAxis) {
  if (isMultiAxis && filteredDomain instanceof Map) {
    filteredDomain.forEach((domain, scaleKey) => {
      if (domain && Array.isArray(domain) && domain.length > 0) {
        channelDomain[scaleKey] = domain;
      }
    });
  } else if (!isMultiAxis && Array.isArray(filteredDomain)) {
    if (filteredDomain.length > 0) {
      channelDomain[shouldFilterXAxis ? "x" : "y"] = filteredDomain;
    }
  }
}

// node_modules/@antv/g2/esm/interaction/sliderFilter.js
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SLIDER_CLASS_NAME = "slider";
function calculatePointInset(view) {
  var _a, _b, _c, _d;
  if (!(view === null || view === void 0 ? void 0 : view.markState))
    return 0;
  let maxSize = 0;
  for (const [mark2, state] of view.markState.entries()) {
    if (mark2.type !== "point" || !(state === null || state === void 0 ? void 0 : state.channels))
      continue;
    const sizeChannel = (_a = state.channels) === null || _a === void 0 ? void 0 : _a.find((ch2) => ch2.name === "size");
    if (!sizeChannel)
      continue;
    if (((_c = (_b = sizeChannel.scale) === null || _b === void 0 ? void 0 : _b.range) === null || _c === void 0 ? void 0 : _c.length) > 0) {
      const rangeMax = Math.max(...sizeChannel.scale.range.filter((val) => typeof val === "number"));
      maxSize = Math.max(maxSize, rangeMax);
      continue;
    }
    if (((_d = sizeChannel.values) === null || _d === void 0 ? void 0 : _d.length) > 0) {
      const sizes = sizeChannel.values.filter((item) => item.value !== void 0).flatMap((item) => Array.isArray(item.value) ? item.value : [item.value]).filter((value2) => typeof value2 === "number" && !isNaN(value2));
      if (sizes.length > 0) {
        maxSize = Math.max(maxSize, ...sizes);
      }
    }
  }
  return maxSize;
}
function emitFilterEvent(emitter, eventName, event, domain0, channelDomain, isX, nativeEvent) {
  if (nativeEvent) {
    const X = isX ? domain0 : channelDomain.x;
    const Y = isX ? channelDomain.y : domain0;
    emitter.emit(eventName, Object.assign(Object.assign({}, event), { nativeEvent, data: { selection: [extentOf(X), extentOf(Y)] } }));
  }
}
function updateSliderState(setState, slider, view, params) {
  const { domain0, filteredDomain, channel0, channel1, prefix, hasState, isMultiAxis, markToScaleMap, enableAdaptiveFiltering } = params;
  if (isMultiAxis && filteredDomain instanceof Map) {
    setState(slider, (options) => Object.assign({}, filterDataByDomainMultiAxis(options, view, {
      [channel0]: { domain: domain0, nice: false }
    }, prefix, hasState, channel0, channel1, markToScaleMap || /* @__PURE__ */ new Map(), filteredDomain)));
  } else {
    setState(slider, (options) => Object.assign({}, filterDataByDomain(options, view, Object.assign({ [channel0]: { domain: domain0, nice: false } }, enableAdaptiveFiltering && Array.isArray(filteredDomain) ? {
      [channel1]: {
        domain: filteredDomain,
        nice: true
      }
    } : {}), prefix, hasState, channel0, channel1)));
  }
}
function filterDataByDomain(options, view, scaleOptions, prefix, hasState = false, channel0 = "x", channel1 = "y") {
  const { marks } = options;
  const extraInset = calculatePointInset(view);
  const newMarks = marks.map((mark2) => {
    var _a, _b;
    return deep_mix_default({
      // Hide label to keep smooth transition.
      axis: {
        x: { transform: [{ type: "hide" }] },
        y: { transform: [{ type: "hide" }] }
      }
    }, mark2, {
      scale: scaleOptions,
      [prefix]: Object.assign(Object.assign({}, ((_a = mark2[prefix]) === null || _a === void 0 ? void 0 : _a[channel0]) && {
        [channel0]: Object.assign({ preserve: true }, hasState && { ratio: null })
      }), ((_b = mark2[prefix]) === null || _b === void 0 ? void 0 : _b[channel1]) && {
        [channel1]: { preserve: true }
      }),
      animate: false
    });
  });
  return Object.assign(Object.assign({}, options), {
    marks: newMarks,
    // Add adaptive inset based on actual point sizes from markState
    insetLeft: extraInset,
    insetRight: extraInset,
    insetTop: extraInset,
    insetBottom: extraInset,
    clip: true,
    animate: false
  });
}
function filterDataByDomainMultiAxis(options, view, scaleOptions, prefix, hasState = false, channel0 = "x", channel1 = "y", markToScaleMap = /* @__PURE__ */ new Map(), filteredDomainList = /* @__PURE__ */ new Map()) {
  const { marks } = options;
  const extraInset = calculatePointInset(view);
  const newMarks = marks.map((mark2) => {
    var _a, _b;
    const markKey = typeof (mark2 === null || mark2 === void 0 ? void 0 : mark2.key) === "string" ? mark2.key : String((mark2 === null || mark2 === void 0 ? void 0 : mark2.key) || "");
    const markToScale = markToScaleMap.get(markKey);
    const filterDomain = filteredDomainList.get(markToScale);
    const scaleNew = filterDomain && {
      y: Object.assign({ domain: filterDomain, nice: true }, markToScale !== "y" ? {
        independent: true
      } : void 0)
    };
    return deep_mix_default({
      // Hide label to keep smooth transition.
      axis: {
        x: { transform: [{ type: "hide" }] },
        y: { transform: [{ type: "hide" }] }
      }
    }, mark2, {
      scale: Object.assign(Object.assign({}, scaleOptions), scaleNew),
      [prefix]: Object.assign(Object.assign({}, ((_a = mark2[prefix]) === null || _a === void 0 ? void 0 : _a[channel0]) && {
        [channel0]: Object.assign({ preserve: true }, hasState && { ratio: null })
      }), ((_b = mark2[prefix]) === null || _b === void 0 ? void 0 : _b[channel1]) && {
        [channel1]: { preserve: true }
      }),
      animate: false
    });
  });
  return Object.assign(Object.assign({}, options), {
    marks: newMarks,
    // Add adaptive inset based on actual point sizes from markState
    insetLeft: extraInset,
    insetRight: extraInset,
    insetTop: extraInset,
    insetBottom: extraInset,
    clip: true,
    animate: false
  });
}
function abstractValue(values4, scale4, reverse2) {
  const [x2, x12] = values4;
  const v = reverse2 ? (d3) => 1 - d3 : (d3) => d3;
  const d0 = invert(scale4, v(x2), true);
  const d1 = invert(scale4, v(x12), false);
  return domainOf3(scale4, [d0, d1]);
}
function extentOf(domain) {
  return [domain[0], domain[domain.length - 1]];
}
function SliderFilter({ initDomain = {}, className: className2 = SLIDER_CLASS_NAME, prefix = "slider", setValue = (component, values4) => component.setValues(values4), hasState = false, wait = 50, leading = true, trailing = false, adaptiveMode = "filter", getInitValues = (slider) => {
  var _a;
  const values4 = (_a = slider === null || slider === void 0 ? void 0 : slider.attributes) === null || _a === void 0 ? void 0 : _a.values;
  if (values4[0] !== 0 || values4[1] !== 1)
    return values4;
} }) {
  return (context, _, emitter) => {
    const { container, view, update, setState } = context;
    const sliders = container.getElementsByClassName(className2);
    if (!sliders.length)
      return () => {
      };
    let filtering = false;
    const { scale: scale4, coordinate } = view;
    const { x: scaleX, y: scaleY } = scale4;
    const transposed = isTranspose(coordinate);
    const channelOf = (orientation) => {
      const channel0 = orientation === "vertical" ? "y" : "x";
      const channel1 = orientation === "vertical" ? "x" : "y";
      if (transposed)
        return [channel1, channel0];
      return [channel0, channel1];
    };
    const sliderHandler = /* @__PURE__ */ new Map();
    const emitHandlers = /* @__PURE__ */ new Set();
    const independentScaleInfo = calculateAllIndependentScaleInfo(view);
    const channelDomain = calculateMultiAxisChannelDomains(view, initDomain, scaleX, scaleY, independentScaleInfo);
    const sliderArray = Array.from(sliders);
    const hasSliderOfType = (type) => sliderArray.some((slider) => {
      const { orientation } = slider.attributes;
      const [channel0] = channelOf(orientation);
      return channel0 === type;
    });
    const hasOnlyXSlider = hasSliderOfType("x") && !hasSliderOfType("y");
    const hasOnlyYSlider = hasSliderOfType("y") && !hasSliderOfType("x");
    const enableAdaptiveFiltering = !isFalsyValue(adaptiveMode) && (hasOnlyXSlider || hasOnlyYSlider);
    for (const slider of sliders) {
      const { orientation } = slider.attributes;
      const [channel0, channel1] = channelOf(orientation);
      const eventName = `${prefix}${upper_first_default(channel0)}:filter`;
      const isX = channel0 === "x";
      const { ratio: ratioX } = scaleX.getOptions();
      const { ratio: ratioY } = scaleY.getOptions();
      const domainsOf = (event) => {
        if (event.data) {
          const { selection } = event.data;
          const [X = extentOf(channelDomain.x), Y = extentOf(channelDomain.y)] = selection;
          return isX ? [domainOf3(scaleX, X, ratioX), domainOf3(scaleY, Y, ratioY)] : [domainOf3(scaleY, Y, ratioY), domainOf3(scaleX, X, ratioX)];
        }
        const { value: values5 } = event.detail;
        const scale0 = scale4[channel0];
        const domain0 = abstractValue(values5, scale0, transposed && orientation === "horizontal");
        const domain1 = channelDomain[channel1];
        return [domain0, domain1];
      };
      let isFiltering = false;
      const setFiltering = (value2) => {
        isFiltering = value2;
        if (!value2) {
          filtering = false;
        }
      };
      const onValueChange = createValueChangeHandler({
        getFiltering: () => isFiltering,
        setFiltering,
        domainsOf,
        view,
        independentScaleInfo,
        enableAdaptiveFiltering,
        hasOnlyXSlider,
        hasOnlyYSlider,
        adaptiveMode,
        scaleX,
        scaleY,
        scale: scale4,
        channelDomain,
        channel0,
        channel1,
        isX,
        emitter,
        eventName,
        setState,
        slider,
        prefix,
        hasState,
        update,
        wait,
        leading,
        trailing
      });
      const emitHandler = (event) => {
        const { nativeEvent } = event;
        if (nativeEvent)
          return;
        const { data } = event;
        const { selection } = data;
        const [X, Y] = selection;
        slider.dispatchEvent(new CustomEvent("valuechange", {
          data,
          nativeEvent: false
        }));
        const V = isX ? sliderAbstractOf(X, scaleX) : sliderAbstractOf(Y, scaleY);
        setValue(slider, V);
      };
      emitter.on(eventName, emitHandler);
      slider.addEventListener("valuechange", onValueChange);
      sliderHandler.set(slider, onValueChange);
      emitHandlers.add([eventName, emitHandler]);
      const values4 = getInitValues(slider);
      if (values4) {
        slider.dispatchEvent(new CustomEvent("valuechange", {
          detail: {
            value: values4
          },
          nativeEvent: false,
          initValue: true
        }));
      }
    }
    return () => {
      for (const [slider, handler] of sliderHandler) {
        slider.removeEventListener("valuechange", handler);
      }
      for (const [name2, handler] of emitHandlers) {
        emitter.off(name2, handler);
      }
    };
  };
}
function processMultiAxisFiltering({ view, domain0, shouldFilterXAxis, enableAdaptiveFiltering, markDataPairs, adaptiveMode, scaleX, scaleY, scale: scale4, channelDomain, independentScaleInfo, channel0 }) {
  const filteredDomain = /* @__PURE__ */ new Map();
  const markToScaleMap = /* @__PURE__ */ new Map();
  if (!enableAdaptiveFiltering || markDataPairs.length === 0 || !(domain0 === null || domain0 === void 0 ? void 0 : domain0.length)) {
    return { filteredDomain, markToScaleMap };
  }
  const viewSlider = get_default(view, "options.slider");
  const isViewSlider = Object.keys(viewSlider).length > 0 && Object.prototype.hasOwnProperty.call(viewSlider, channel0);
  if (isViewSlider) {
    const multiAxisScaleInfo = extractMultiAxisScaleInfo(shouldFilterXAxis, scale4, scaleX, scaleY, channelDomain);
    const scaleMapToUse = shouldFilterXAxis ? independentScaleInfo.markToXScaleMap : independentScaleInfo.markToYScaleMap;
    scaleMapToUse.forEach((scaleKey, markKey) => {
      markToScaleMap.set(markKey, scaleKey);
    });
    const processedFilteredDomain = processMultiAxisViewFiltering({
      markDataPairs,
      domain: domain0,
      scaleInfo: multiAxisScaleInfo,
      markToScaleMap,
      adaptiveMode,
      isViewSlider: true,
      shouldFilterXAxis
    });
    updateChannelDomains(channelDomain, processedFilteredDomain, shouldFilterXAxis, true);
    return { filteredDomain: processedFilteredDomain, markToScaleMap };
  } else {
    const targetMarkKey = findTargetMarkKey(view, channel0);
    if (targetMarkKey) {
      const singleAxisScaleInfo = extractSingleAxisScaleInfo(shouldFilterXAxis, scaleX, scaleY);
      const scaleMapping = shouldFilterXAxis ? independentScaleInfo.markToXScaleMap : independentScaleInfo.markToYScaleMap;
      const targetScaleKey = scaleMapping.get(targetMarkKey) || "";
      if (targetScaleKey) {
        markToScaleMap.set(targetMarkKey, targetScaleKey);
        const processedFilteredDomain = processMultiAxisMarkFiltering(markDataPairs, domain0, singleAxisScaleInfo, targetMarkKey, targetScaleKey, adaptiveMode, shouldFilterXAxis, scaleMapping);
        return { filteredDomain: processedFilteredDomain, markToScaleMap };
      }
    }
  }
  return { filteredDomain, markToScaleMap };
}
function findTargetMarkKey(view, channel0) {
  for (const [mark2] of view.markState.entries()) {
    const markSlider = get_default(mark2, "slider");
    const hasMarkSlider = Object.keys(markSlider || {}).length > 0 && Object.prototype.hasOwnProperty.call(markSlider, channel0);
    if (hasMarkSlider) {
      return String(mark2.key || "");
    }
  }
  return null;
}
function processSingleAxisFilteringWithDomainUpdate({ domain0, domain1, shouldFilterXAxis, enableAdaptiveFiltering, markDataPairs, adaptiveMode, scaleX, scaleY, channelDomain, hasOnlyXSlider, hasOnlyYSlider, isX }) {
  let filteredDomain = domain1;
  if (enableAdaptiveFiltering && markDataPairs.length > 0 && (hasOnlyXSlider && isX || hasOnlyYSlider && !isX) && (domain0 === null || domain0 === void 0 ? void 0 : domain0.length) > 0) {
    const singleAxisScaleInfo = extractSingleAxisScaleInfo(shouldFilterXAxis, scaleX, scaleY);
    filteredDomain = processSingleAxisFiltering({
      markDataPairs,
      domain: domain0,
      scaleInfo: singleAxisScaleInfo,
      adaptiveMode,
      shouldFilterXAxis
    });
    updateChannelDomains(channelDomain, filteredDomain, shouldFilterXAxis, false);
  }
  return filteredDomain;
}
function createValueChangeHandler({ getFiltering, setFiltering, domainsOf, view, independentScaleInfo, enableAdaptiveFiltering, hasOnlyXSlider, hasOnlyYSlider, adaptiveMode, scaleX, scaleY, scale: scale4, channelDomain, channel0, channel1, isX, emitter, eventName, setState, slider, prefix, hasState, update, wait, leading, trailing }) {
  return throttle_default((event) => __awaiter10(this, void 0, void 0, function* () {
    const { initValue = false } = event;
    if (getFiltering() && !initValue) {
      return;
    }
    setFiltering(true);
    const { nativeEvent = true } = event;
    const { markDataPairs } = extractChannelValues(view);
    const hasIndependentScale = independentScaleInfo[`hasIndependent${channel1.toUpperCase()}`];
    if (hasIndependentScale) {
      const [domain0] = domainsOf(event);
      const shouldFilterXAxis = hasOnlyYSlider && !isX;
      const { filteredDomain, markToScaleMap } = processMultiAxisFiltering({
        view,
        domain0,
        shouldFilterXAxis,
        enableAdaptiveFiltering: enableAdaptiveFiltering && (hasOnlyXSlider && isX || hasOnlyYSlider && !isX),
        markDataPairs,
        adaptiveMode,
        scaleX,
        scaleY,
        scale: scale4,
        channelDomain,
        independentScaleInfo,
        channel0
      });
      channelDomain[channel0] = domain0;
      emitFilterEvent(emitter, eventName, event, domain0, channelDomain, isX, nativeEvent);
      updateSliderState(setState, slider, view, {
        domain0,
        filteredDomain,
        channel0,
        channel1,
        prefix,
        hasState,
        isMultiAxis: true,
        markToScaleMap,
        enableAdaptiveFiltering
      });
    } else {
      const [domain0, domain1] = domainsOf(event);
      const shouldFilterXAxis = hasOnlyYSlider && !isX;
      const filteredDomain = processSingleAxisFilteringWithDomainUpdate({
        domain0,
        domain1,
        shouldFilterXAxis,
        enableAdaptiveFiltering,
        markDataPairs,
        adaptiveMode,
        scaleX,
        scaleY,
        channelDomain,
        hasOnlyXSlider,
        hasOnlyYSlider,
        isX
      });
      channelDomain[channel0] = domain0;
      emitFilterEvent(emitter, eventName, event, domain0, channelDomain, isX, nativeEvent);
      updateSliderState(setState, slider, view, {
        domain0,
        filteredDomain,
        channel0,
        channel1,
        prefix,
        hasState,
        isMultiAxis: false,
        markToScaleMap: void 0,
        enableAdaptiveFiltering
      });
    }
    yield update();
    setFiltering(false);
  }), wait, { leading, trailing });
}

// node_modules/@antv/g2/esm/interaction/sliderWheel.js
function getCanvasDOM(container) {
  var _a;
  try {
    const canvas = (_a = container.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
    if (!canvas || typeof canvas.getContextService !== "function") {
      return null;
    }
    const dom2 = canvas.getContextService().getDomElement();
    return dom2 instanceof HTMLElement ? dom2 : null;
  } catch (_b) {
    return null;
  }
}
function SliderWheel({ className: className2 = SLIDER_CLASS_NAME, setValue = (component, values4) => component.setValues(values4), minRange = 0.01, wheelSensitivity = 0.05, x: x2 = true, y: y3 = true } = {}) {
  return (context) => {
    const { container, view } = context;
    const { coordinate } = view;
    const transposed = isTranspose(coordinate);
    const canvasDOM = getCanvasDOM(container);
    const safeMinRange = Math.max(1e-6, Math.min(1, minRange));
    const sliders = container.getElementsByClassName(className2);
    if (!sliders.length)
      return () => {
      };
    const isModifierKeyActive = (config, event) => {
      if (config === true)
        return true;
      if (config === false)
        return false;
      if (config === "shift")
        return event.shiftKey && !event.ctrlKey && !event.altKey;
      if (config === "ctrl")
        return event.ctrlKey && !event.shiftKey && !event.altKey;
      if (config === "alt")
        return event.altKey && !event.shiftKey && !event.ctrlKey;
      return false;
    };
    const triggerSliderValueChange = (slider, values4) => {
      setValue(slider, values4);
      slider.dispatchEvent(new CustomEvent("valuechange", {
        detail: { value: values4 },
        nativeEvent: true
      }));
    };
    const calculateZoomCenter = (mousePos, sliderPos, trackLength, v0, v1) => {
      const relativePos = mousePos - sliderPos;
      const normalizedPosition2 = relativePos / trackLength;
      const clamped = Math.max(0, Math.min(1, normalizedPosition2));
      return Math.max(v0, Math.min(v1, clamped));
    };
    const handleWheel = (event) => {
      if (!canvasDOM)
        return;
      const target = event.target;
      if (!canvasDOM.contains(target)) {
        return;
      }
      const canvasRect = canvasDOM.getBoundingClientRect();
      const mouseX = event.clientX - canvasRect.left;
      const mouseY = event.clientY - canvasRect.top;
      const activeSliders = [];
      for (const slider of sliders) {
        const { values: values4, orientation } = slider.attributes;
        if (!values4)
          continue;
        const isHorizontal2 = orientation === "horizontal";
        const actualAxis = transposed ? isHorizontal2 ? "y" : "x" : isHorizontal2 ? "x" : "y";
        const axisConfig = actualAxis === "x" ? x2 : y3;
        if (isModifierKeyActive(axisConfig, event)) {
          activeSliders.push(slider);
        }
      }
      if (activeSliders.length === 0) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      for (const slider of activeSliders) {
        const { values: values4, orientation, x: sliderX, y: sliderY, trackLength } = slider.attributes;
        const [v0, v1] = values4;
        const range3 = v1 - v0;
        const isHorizontal2 = orientation === "horizontal";
        const center2 = isHorizontal2 ? calculateZoomCenter(mouseX, sliderX, trackLength, v0, v1) : calculateZoomCenter(mouseY, sliderY, trackLength, v0, v1);
        const adaptiveSensitivity = wheelSensitivity * calculateSensitivityMultiplier(range3);
        const delta = event.deltaY * adaptiveSensitivity;
        const zoomFactor = 1 + delta;
        const newRange = Math.max(safeMinRange, Math.min(1, range3 * zoomFactor));
        const leftRatio = (center2 - v0) / range3;
        const rightRatio = (v1 - center2) / range3;
        let newV0 = center2 - newRange * leftRatio;
        let newV1 = center2 + newRange * rightRatio;
        if (newV0 < 0) {
          newV0 = 0;
          newV1 = Math.min(1, newRange);
        } else if (newV1 > 1) {
          newV1 = 1;
          newV0 = Math.max(0, 1 - newRange);
        }
        triggerSliderValueChange(slider, [newV0, newV1]);
      }
    };
    if (canvasDOM) {
      canvasDOM.addEventListener("wheel", handleWheel, {
        passive: false,
        capture: true
      });
    }
    return () => {
      if (canvasDOM) {
        canvasDOM.removeEventListener("wheel", handleWheel, { capture: true });
      }
    };
  };
}
SliderWheel.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/scrollbarFilter.js
var SCROLLBAR_CLASS_NAME = `${G2_CLASS_PREFIX}scrollbar`;
function ScrollbarFilter(options = {}) {
  return (context, _, emitter) => {
    const { view, container } = context;
    const scrollbars = container.getElementsByClassName(SCROLLBAR_CLASS_NAME);
    if (!scrollbars.length)
      return () => {
      };
    const { scale: scale4 } = view;
    const { x: scaleX, y: scaleY } = scale4;
    const initDomain = {
      x: [...scaleX.getOptions().domain],
      y: [...scaleY.getOptions().domain]
    };
    scaleX.update({ domain: scaleX.getOptions().expectedDomain });
    scaleY.update({ domain: scaleY.getOptions().expectedDomain });
    const interaction = SliderFilter(Object.assign({ initDomain, className: SCROLLBAR_CLASS_NAME, prefix: "scrollbar", hasState: true, setValue: (component, values4) => component.setValue(values4[0]), getInitValues: (scrollbar) => {
      const values4 = scrollbar.slider.attributes.values;
      if (values4[0] !== 0 || values4[1] !== 1)
        return values4;
    } }, options));
    return interaction(context, _, emitter);
  };
}

// node_modules/@antv/g2/esm/interaction/poptip.js
var __rest86 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function dom(tag, children, style) {
  return `<${tag} style="${Object.entries(style).map(([key, value2]) => `${kebabCase(key)}:${value2}`).join(";")}">${children}</${tag}>`;
}
var defaultTipStyle = {
  backgroundColor: "rgba(0,0,0,0.75)",
  color: "#fff",
  width: "max-content",
  padding: "1px 4px",
  fontSize: "12px",
  borderRadius: "2.5px",
  boxShadow: "0 3px 6px -4px rgba(0,0,0,0.12), 0 6px 16px 0 rgba(0,0,0,0.08), 0 9px 28px 8px rgba(0,0,0,0.05)"
};
function isTipText(element) {
  if (element.nodeName !== "text")
    return false;
  if (element.isOverflowing())
    return true;
  return false;
}
function Poptip(_a) {
  var { offsetX = 8, offsetY = 8 } = _a, style = __rest86(_a, ["offsetX", "offsetY"]);
  return (context) => {
    const { container } = context;
    const [x05, y05] = container.getBounds().min;
    const tipStyle = subObject(style, "tip");
    const tips = /* @__PURE__ */ new Set();
    const pointerover = (e3) => {
      const { target } = e3;
      if (!isTipText(target)) {
        e3.stopPropagation();
        return;
      }
      const { offsetX: mouseX, offsetY: mouseY } = e3;
      const x2 = mouseX + offsetX - x05;
      const y3 = mouseY + offsetY - y05;
      if (target.tip) {
        target.tip.style.x = x2;
        target.tip.style.y = y3;
        return;
      }
      const { text } = target.style;
      const tipELement = new HTML({
        className: "poptip",
        style: {
          innerHTML: dom("div", text, Object.assign(Object.assign({}, defaultTipStyle), tipStyle)),
          x: x2,
          y: y3
        }
      });
      container.appendChild(tipELement);
      target.tip = tipELement;
      tips.add(tipELement);
    };
    const pointerout = (e3) => {
      const { target } = e3;
      if (!isTipText(target)) {
        e3.stopPropagation();
        return;
      }
      if (!target.tip)
        return;
      target.tip.remove();
      target.tip = null;
      tips.delete(target.tip);
    };
    container.addEventListener("pointerover", pointerover);
    container.addEventListener("pointerout", pointerout);
    return () => {
      container.removeEventListener("pointerover", pointerover);
      container.removeEventListener("pointerout", pointerout);
      tips.forEach((tip) => tip.remove());
    };
  };
}
Poptip.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/treemapDrillDown.js
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest87 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function selectPlotArea2(root) {
  return select(root).select(`.${PLOT_CLASS_NAME}`).node();
}
var DEFAULT_BREADCRUMB_STYLE = {
  breadCrumbFill: "rgba(0, 0, 0, 0.85)",
  breadCrumbFontSize: 12,
  breadCrumbY: 12,
  activeFill: "rgba(0, 0, 0, 0.5)"
};
function TreemapDrillDown(drillDownOptions = {}) {
  const { originData = [], layout } = drillDownOptions, style = __rest87(drillDownOptions, ["originData", "layout"]);
  const breadCrumb = deep_mix_default({}, DEFAULT_BREADCRUMB_STYLE, style);
  const breadCrumbStyle = subObject(breadCrumb, "breadCrumb");
  const breadCrumbActiveStyle = subObject(breadCrumb, "active");
  return (context) => {
    const { update, setState, container, options } = context;
    const plotArea = selectPlotArea2(container);
    const mark2 = options.marks[0];
    const { state } = mark2;
    const textGroup = new Group();
    plotArea.appendChild(textGroup);
    const drillDownClick = (path2, depth) => __awaiter11(this, void 0, void 0, function* () {
      textGroup.removeChildren();
      if (depth) {
        let name2 = "";
        let y3 = breadCrumbStyle.y;
        let x2 = 0;
        const textPath = [];
        const maxWidth = plotArea.getBBox().width;
        const drillTexts = path2.map((text, index2) => {
          name2 = `${name2}${text}/`;
          textPath.push(text);
          const drillText = new Text({
            name: name2.replace(/\/$/, ""),
            style: Object.assign(Object.assign({
              text,
              x: x2,
              // @ts-ignore
              path: [...textPath],
              depth: index2
            }, breadCrumbStyle), { y: y3 })
          });
          textGroup.appendChild(drillText);
          x2 += drillText.getBBox().width;
          const textSeparator = new Text({
            style: Object.assign(Object.assign({ x: x2, text: " / " }, breadCrumbStyle), { y: y3 })
          });
          textGroup.appendChild(textSeparator);
          x2 += textSeparator.getBBox().width;
          if (x2 > maxWidth) {
            y3 = textGroup.getBBox().height + breadCrumbStyle.y;
            x2 = 0;
            drillText.attr({
              x: x2,
              y: y3
            });
            x2 += drillText.getBBox().width;
            textSeparator.attr({
              x: x2,
              y: y3
            });
            x2 += textSeparator.getBBox().width;
          }
          if (index2 === size(path2) - 1) {
            textSeparator.remove();
          }
          return drillText;
        });
        drillTexts.forEach((item, index2) => {
          if (index2 === size(drillTexts) - 1)
            return;
          const originalAttrs = Object.assign({}, item.attributes);
          item.attr("cursor", "pointer");
          item.addEventListener("mouseenter", () => {
            item.attr(breadCrumbActiveStyle);
          });
          item.addEventListener("mouseleave", () => {
            item.attr(originalAttrs);
          });
          item.addEventListener("click", () => {
            drillDownClick(get_default(item, ["style", "path"]), get_default(item, ["style", "depth"]));
          });
        });
      }
      legendClearSetState(container, setState);
      setState("treemapDrillDown", (viewOptions) => {
        const { marks } = viewOptions;
        const strPath = path2.join("/");
        const newMarks = marks.map((mark3) => {
          if (mark3.type !== "rect")
            return mark3;
          let newData = originData;
          if (depth) {
            const filterData = originData.filter((item) => {
              const id2 = get_default(item, ["id"]);
              return id2 && (id2.match(`${strPath}/`) || strPath.match(id2));
            }).map((item) => ({
              value: item.height === 0 ? get_default(item, ["value"]) : void 0,
              name: get_default(item, ["id"])
            }));
            const { paddingLeft, paddingBottom, paddingRight } = layout;
            const newLayout = Object.assign(Object.assign({}, layout), { paddingTop: (layout.paddingTop || textGroup.getBBox().height + 10) / (depth + 1), paddingLeft: paddingLeft / (depth + 1), paddingBottom: paddingBottom / (depth + 1), paddingRight: paddingRight / (depth + 1), path: (d3) => d3.name, layer: (d3) => d3.depth === depth + 1 });
            newData = treeDataTransform(filterData, newLayout, {
              value: "value"
            })[0];
          } else {
            newData = originData.filter((item) => {
              return item.depth === 1;
            });
          }
          const colorDomain = [];
          newData.forEach(({ path: path3 }) => {
            colorDomain.push(last(path3));
          });
          return deep_mix_default({}, mark3, {
            data: newData,
            scale: {
              color: { domain: colorDomain }
            }
          });
        });
        return Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
      });
      yield update(void 0, ["legendFilter"]);
    });
    const keyofLabel = (d3) => d3.attributes.key.split("-")[0];
    const keyofRect = (d3) => get_default(d3, ["__data__", "key"]);
    const createDrillClick = (e3) => {
      const item = e3.target;
      const { markType, nodeName, attributes } = item || {};
      if (markType !== "rect" && nodeName !== Shape.TEXT)
        return;
      const key = nodeName === Shape.TEXT && get_default(attributes, "isTreemapLabel") === true ? keyofLabel(item) : keyofRect(item);
      const node = find_default(originData, (d3) => d3.id === key);
      if (get_default(node, "height")) {
        drillDownClick(get_default(node, "path"), get_default(node, "depth"));
      }
    };
    plotArea.addEventListener("click", createDrillClick);
    const changeStyleKey = keys_default(Object.assign(Object.assign({}, state.active), state.inactive));
    const createActive = () => {
      const elements = getElements(plotArea);
      elements.forEach((element) => {
        const cursor = get_default(element, ["style", "cursor"]);
        const node = find_default(originData, (d3) => d3.id === get_default(element, ["__data__", "key"]));
        if (cursor !== "pointer" && (node === null || node === void 0 ? void 0 : node.height)) {
          element.style.cursor = "pointer";
          const originalAttrs = pick_default(element.attributes, changeStyleKey);
          element.addEventListener("mouseenter", () => {
            element.attr(state.active);
          });
          element.addEventListener("mouseleave", () => {
            element.attr(deep_mix_default(originalAttrs, state.inactive));
          });
        }
      });
    };
    createActive();
    plotArea.addEventListener("mousemove", createActive);
    return () => {
      textGroup.remove();
      plotArea.removeEventListener("click", createDrillClick);
      plotArea.removeEventListener("mousemove", createActive);
    };
  };
}

// node_modules/@antv/g2/esm/interaction/drillDown.js
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getElementsPartition = (plot2) => {
  return plot2.querySelectorAll(".element").filter((item) => {
    const itemStyle = item.style || {};
    return itemStyle[PARTITION_TYPE_FIELD] === PARTITION_TYPE;
  });
};
function selectPlotArea3(root) {
  return select(root).select(`.${PLOT_CLASS_NAME}`).node();
}
var DEFAULT_BREADCRUMB = {
  rootText: "root",
  style: {
    fill: "rgba(0, 0, 0, 0.6)",
    fontSize: 11
  },
  y: 4,
  active: {
    fill: "rgba(0, 0, 0, 0.4)"
  }
};
function DrillDown(drillDownOptions = {}) {
  const { breadCrumb: textConfig = {} } = drillDownOptions;
  const breadCrumb = deep_mix_default({}, DEFAULT_BREADCRUMB, textConfig);
  return (context) => {
    const { update, setState, container, view, options: viewOptions } = context;
    const document2 = container.ownerDocument;
    const plotArea = selectPlotArea3(container);
    const partitionMark = viewOptions.marks.find(({ id: id2 }) => id2 === PARTITION_TYPE);
    if (!partitionMark)
      return;
    const { state } = partitionMark;
    const textGroup = document2.createElement("g");
    textGroup.style.transform = `translate(${breadCrumb.x || 0}px, ${breadCrumb.y || 0}px)`;
    textGroup.setAttribute("x", "drilldown-breadcrumb");
    plotArea.appendChild(textGroup);
    const drillDownClick = (path2) => __awaiter12(this, void 0, void 0, function* () {
      textGroup.removeChildren();
      if (path2 && path2.length > 0) {
        const rootText = document2.createElement("text", {
          style: Object.assign({ text: breadCrumb.rootText }, breadCrumb.style)
        });
        textGroup.appendChild(rootText);
        let name2 = "";
        const pathArray = path2;
        let y3 = breadCrumb.style.y;
        let x2 = rootText.getBBox().width;
        const maxWidth = plotArea.getBBox().width;
        const drillTexts = pathArray.map((text, index2) => {
          const textSeparator = document2.createElement("text", {
            style: Object.assign(Object.assign({ x: x2, text: " / " }, breadCrumb.style), { y: y3 })
          });
          textGroup.appendChild(textSeparator);
          x2 += textSeparator.getBBox().width;
          name2 = `${name2}${text} / `;
          const drillText = document2.createElement("text", {
            name: name2.replace(/\s\/\s$/, ""),
            style: Object.assign(Object.assign({
              text,
              x: x2
            }, breadCrumb.style), { y: y3 })
          });
          textGroup.appendChild(drillText);
          x2 += drillText.getBBox().width;
          if (x2 > maxWidth) {
            y3 = textGroup.getBBox().height;
            x2 = 0;
            textSeparator.attr({
              x: x2,
              y: y3
            });
            x2 += textSeparator.getBBox().width;
            drillText.attr({
              x: x2,
              y: y3
            });
            x2 += drillText.getBBox().width;
          }
          return drillText;
        });
        const textStack = [rootText, ...drillTexts];
        textStack.forEach((item, index2) => {
          if (index2 === drillTexts.length)
            return;
          const originalAttrs = Object.assign({}, item.attributes);
          item.attr("cursor", "pointer");
          item.addEventListener("mouseenter", () => {
            item.attr(breadCrumb.active);
          });
          item.addEventListener("mouseleave", () => {
            item.attr(originalAttrs);
          });
          item.addEventListener("click", () => {
            drillDownClick(path2.slice(0, index2));
          });
        });
      }
      setState("drillDown", (viewOptions2) => {
        const { marks } = viewOptions2;
        const newMarks = marks.map((mark2) => {
          if (mark2.id !== PARTITION_TYPE && mark2.type !== "rect")
            return mark2;
          const { data } = mark2;
          const newData = data.filter((item) => {
            var _a;
            const itemPath = (_a = item.path) !== null && _a !== void 0 ? _a : [];
            if (path2.length === 0)
              return true;
            if (!Array.isArray(itemPath) || itemPath.length < path2.length)
              return false;
            for (let i2 = 0; i2 < path2.length; i2++) {
              if (itemPath[i2] !== path2[i2])
                return false;
            }
            return true;
          });
          return deep_mix_default({}, mark2, {
            data: newData
          });
        });
        return Object.assign(Object.assign({}, viewOptions2), { marks: newMarks });
      });
      yield update();
    });
    const createDrillClick = (e3) => {
      var _a, _b;
      const item = e3.target;
      const markType = item.markType;
      const itemStyle = item.style || {};
      const partitionType = itemStyle[PARTITION_TYPE_FIELD];
      const childNodeCount = itemStyle[CHILD_NODE_COUNT];
      const itemData = item.__data__;
      if (markType !== "rect" || partitionType !== PARTITION_TYPE || !childNodeCount) {
        return;
      }
      const path2 = (_b = (_a = itemData === null || itemData === void 0 ? void 0 : itemData.data) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : [];
      drillDownClick(path2);
    };
    plotArea.addEventListener("click", createDrillClick);
    const changeStyleKey = keys_default(Object.assign(Object.assign({}, state.active), state.inactive));
    const createActive = () => {
      const elements = getElementsPartition(plotArea);
      elements.forEach((element) => {
        const childNodeCount = get_default(element, ["style", CHILD_NODE_COUNT]);
        const cursor = get_default(element, ["style", "cursor"]);
        if (cursor !== "pointer" && childNodeCount) {
          element.style.cursor = "pointer";
          const originalAttrs = pick_default(element.attributes, changeStyleKey);
          element.addEventListener("mouseenter", () => {
            element.attr(state.active);
          });
          element.addEventListener("mouseleave", () => {
            element.attr(deep_mix_default(originalAttrs, state.inactive));
          });
        }
      });
    };
    plotArea.addEventListener("mousemove", createActive);
    return () => {
      textGroup.remove();
      plotArea.removeEventListener("click", createDrillClick);
      plotArea.removeEventListener("mousemove", createActive);
    };
  };
}

// node_modules/@antv/g2/esm/interaction/elementPointMove.js
var __awaiter13 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest88 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var DEFAULT_STYLE2 = {
  pointR: 6,
  pointStrokeWidth: 1,
  pointStroke: "#888",
  pointActiveStroke: "#f5f5f5",
  pathStroke: "#888",
  pathLineDash: [3, 4],
  labelFontSize: 12,
  labelFill: "#888",
  labelStroke: "#fff",
  labelLineWidth: 1,
  labelY: -6,
  labelX: 2
};
var MOVE_POINT_NAME = "movePoint";
var elementMouseenter = (e3) => {
  const element = e3.target;
  const { markType } = element;
  if (markType === "line") {
    element.attr("_lineWidth", element.attr("lineWidth") || 1);
    element.attr("lineWidth", element.attr("_lineWidth") + 3);
  }
  if (markType === "interval") {
    element.attr("_opacity", element.attr("opacity") || 1);
    element.attr("opacity", 0.7 * element.attr("_opacity"));
  }
};
var elementMouseleave = (e3) => {
  const element = e3.target;
  const { markType } = element;
  if (markType === "line") {
    element.attr("lineWidth", element.attr("_lineWidth"));
  }
  if (markType === "interval") {
    element.attr("opacity", element.attr("_opacity"));
  }
};
var getNewData = (newChangeData, data, encode) => {
  return data.map((d3) => {
    const isUpdate = ["x", "color"].reduce((v, key) => {
      const field3 = encode[key];
      if (!field3)
        return v;
      if (d3[field3] !== newChangeData[field3])
        return false;
      return v;
    }, true);
    return isUpdate ? Object.assign(Object.assign({}, d3), newChangeData) : d3;
  });
};
var getIntervalDataRatioTransformFn = (element) => {
  const y3 = get_default(element, ["__data__", "y"]);
  const y12 = get_default(element, ["__data__", "y1"]);
  const v = y12 - y3;
  const { __data__: { data, encode, transform: transform2 }, childNodes } = element.parentNode;
  const isNormalizeY = find_default(transform2, ({ type }) => type === "normalizeY");
  const yField = get_default(encode, ["y", "field"]);
  const value2 = data[childNodes.indexOf(element)][yField];
  return (newValue, isTheta3 = false) => {
    if (isNormalizeY || isTheta3) {
      return newValue / (1 - newValue) / (v / (1 - v)) * value2;
    }
    return newValue;
  };
};
var getPathDataRatioTransformFn = (element, index2) => {
  const v = get_default(element, ["__data__", "seriesItems", index2, "0", "value"]);
  const i2 = get_default(element, ["__data__", "seriesIndex", index2]);
  const { __data__: { data, encode, transform: transform2 } } = element.parentNode;
  const isNormalizeY = find_default(transform2, ({ type }) => type === "normalizeY");
  const yField = get_default(encode, ["y", "field"]);
  const value2 = data[i2][yField];
  return (newValue) => {
    if (isNormalizeY) {
      if (v === 1) {
        return newValue;
      }
      return newValue / (1 - newValue) / (v / (1 - v)) * value2;
    }
    return newValue;
  };
};
var selectedPointsStyle = (pointsShape, selection, defaultStyle2) => {
  pointsShape.forEach((shape24, index2) => {
    shape24.attr("stroke", selection[1] === index2 ? defaultStyle2["activeStroke"] : defaultStyle2["stroke"]);
  });
};
var createHelpShape = (group2, circle2, pathStyle, labelStyle) => {
  const pathShape = new Path({
    style: pathStyle
  });
  const labelShape = new Text({
    style: labelStyle
  });
  circle2.appendChild(labelShape);
  group2.appendChild(pathShape);
  return [pathShape, labelShape];
};
var getColorType = (scaleColor, color) => {
  const indexOf4 = get_default(scaleColor, ["options", "range", "indexOf"]);
  if (!indexOf4)
    return;
  const i2 = scaleColor.options.range.indexOf(color);
  return scaleColor.sortedDomain[i2];
};
var getSamePointPosition = (center2, point6, target) => {
  const oldR = getPointsR(center2, point6);
  const newR = getPointsR(center2, target);
  const ratio = newR / oldR;
  const newX = center2[0] + (point6[0] - center2[0]) * ratio;
  const newY = center2[1] + (point6[1] - center2[1]) * ratio;
  return [newX, newY];
};
function ElementPointMove(elementPointMoveOptions = {}) {
  const { selection = [], precision = 2 } = elementPointMoveOptions, style = __rest88(elementPointMoveOptions, ["selection", "precision"]);
  const defaultStyle2 = Object.assign(Object.assign({}, DEFAULT_STYLE2), style || {});
  const pathDefaultStyle = subObject(defaultStyle2, "path");
  const labelDefaultStyle = subObject(defaultStyle2, "label");
  const pointDefaultStyle = subObject(defaultStyle2, "point");
  return (context, _, emitter) => {
    const { update, setState, container, view, options: { marks, coordinate: coordinateOptions } } = context;
    const plotArea = selectPlotArea(container);
    let elements = getElements(plotArea);
    let newState;
    let newSelection = selection;
    const { transform: transform2 = [], type: coordinateType } = coordinateOptions;
    const isTranspose3 = !!find_default(transform2, ({ type }) => type === "transpose");
    const isPolar3 = coordinateType === "polar";
    const isTheta3 = coordinateType === "theta";
    const isArea = !!find_default(elements, ({ markType }) => markType === "area");
    if (isArea) {
      elements = elements.filter(({ markType }) => markType === "area");
    }
    const pointsGroup = new Group({
      style: {
        // Tooltip point need down.
        zIndex: 2
      }
    });
    plotArea.appendChild(pointsGroup);
    const selectedChange = () => {
      emitter.emit("element-point:select", {
        nativeEvent: true,
        data: {
          selection: newSelection
        }
      });
    };
    const dataChange = (changeData, data) => {
      emitter.emit("element-point:moved", {
        nativeEvent: true,
        data: {
          changeData,
          data
        }
      });
    };
    const elementClick = (e3) => {
      const element = e3.target;
      newSelection = [element.parentNode.childNodes.indexOf(element)];
      selectedChange();
      createPoints(element);
    };
    const elementSelect2 = (d3) => {
      const { data: { selection: selection2 }, nativeEvent } = d3;
      if (nativeEvent)
        return;
      newSelection = selection2;
      const element = get_default(elements, [newSelection === null || newSelection === void 0 ? void 0 : newSelection[0]]);
      if (element) {
        createPoints(element);
      }
    };
    const createPoints = (element) => {
      const { attributes, markType, __data__: data } = element;
      const { stroke: fill } = attributes;
      const { points, seriesTitle, color, title, seriesX, y1: y12 } = data;
      if (isTranspose3 && markType !== "interval")
        return;
      const { scale: scale4, coordinate } = (newState === null || newState === void 0 ? void 0 : newState.view) || view;
      const { color: scaleColor, y: scaleY, x: scaleX } = scale4;
      const center2 = coordinate.getCenter();
      pointsGroup.removeChildren();
      let downPoint;
      const updateView = (x2, y3, color2, markTypes) => __awaiter13(this, void 0, void 0, function* () {
        setState("elementPointMove", (viewOptions) => {
          var _a;
          const newMarks = (((_a = newState === null || newState === void 0 ? void 0 : newState.options) === null || _a === void 0 ? void 0 : _a.marks) || marks).map((mark2) => {
            if (!markTypes.includes(mark2.type))
              return mark2;
            const { data: data2, encode } = mark2;
            const encodeKeys = Object.keys(encode);
            const newChangeData = encodeKeys.reduce((value2, key) => {
              const dataKey = encode[key];
              if (key === "x") {
                value2[dataKey] = x2;
              }
              if (key === "y") {
                value2[dataKey] = y3;
              }
              if (key === "color") {
                value2[dataKey] = color2;
              }
              return value2;
            }, {});
            const newData = getNewData(newChangeData, data2, encode);
            dataChange(newChangeData, newData);
            return deep_mix_default({}, mark2, {
              data: newData,
              // No need animate
              animate: false
            });
          });
          return Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
        });
        return yield update("elementPointMove");
      });
      if (["line", "area"].includes(markType)) {
        points.forEach((p3, index2) => {
          const title2 = scaleX.invert(seriesX[index2]);
          if (!title2)
            return;
          const circle2 = new Circle({
            name: MOVE_POINT_NAME,
            style: Object.assign({ cx: p3[0], cy: p3[1], fill }, pointDefaultStyle)
          });
          const ratioTransform = getPathDataRatioTransformFn(element, index2);
          circle2.addEventListener("mousedown", (e3) => {
            const oldPoint = coordinate.output([seriesX[index2], 0]);
            const pathLength = seriesTitle === null || seriesTitle === void 0 ? void 0 : seriesTitle.length;
            container.attr("cursor", "move");
            if (newSelection[1] !== index2) {
              newSelection[1] = index2;
              selectedChange();
            }
            selectedPointsStyle(pointsGroup.childNodes, newSelection, pointDefaultStyle);
            const [pathShape, labelShape] = createHelpShape(pointsGroup, circle2, pathDefaultStyle, labelDefaultStyle);
            const pointMousemove = (e4) => {
              const newCy = p3[1] + e4.clientY - downPoint[1];
              if (isArea) {
                if (isPolar3) {
                  const newCx = p3[0] + e4.clientX - downPoint[0];
                  const [newX, newY] = getSamePointPosition(center2, oldPoint, [
                    newCx,
                    newCy
                  ]);
                  const [, initY] = coordinate.output([1, scaleY.output(0)]);
                  const [, y3] = coordinate.invert([
                    newX,
                    initY - (points[index2 + pathLength][1] - newY)
                  ]);
                  const nextIndex = (index2 + 1) % pathLength;
                  const lastIndex = (index2 - 1 + pathLength) % pathLength;
                  const newPath = getPointsPath([
                    points[lastIndex],
                    [newX, newY],
                    seriesTitle[nextIndex] && points[nextIndex]
                  ]);
                  labelShape.attr("text", ratioTransform(scaleY.invert(y3)).toFixed(precision));
                  pathShape.attr("d", newPath);
                  circle2.attr("cx", newX);
                  circle2.attr("cy", newY);
                } else {
                  const [, initY] = coordinate.output([1, scaleY.output(0)]);
                  const [, y3] = coordinate.invert([
                    p3[0],
                    initY - (points[index2 + pathLength][1] - newCy)
                  ]);
                  const newPath = getPointsPath([
                    points[index2 - 1],
                    [p3[0], newCy],
                    seriesTitle[index2 + 1] && points[index2 + 1]
                  ]);
                  labelShape.attr("text", ratioTransform(scaleY.invert(y3)).toFixed(precision));
                  pathShape.attr("d", newPath);
                  circle2.attr("cy", newCy);
                }
              } else {
                const [, y3] = coordinate.invert([p3[0], newCy]);
                const newPath = getPointsPath([
                  points[index2 - 1],
                  [p3[0], newCy],
                  points[index2 + 1]
                ]);
                labelShape.attr("text", scaleY.invert(y3).toFixed(precision));
                pathShape.attr("d", newPath);
                circle2.attr("cy", newCy);
              }
            };
            downPoint = [e3.clientX, e3.clientY];
            window.addEventListener("mousemove", pointMousemove);
            const mouseupFn = () => __awaiter13(this, void 0, void 0, function* () {
              container.attr("cursor", "default");
              window.removeEventListener("mousemove", pointMousemove);
              container.removeEventListener("mouseup", mouseupFn);
              if (is_undefined_default(labelShape.attr("text")))
                return;
              const y3 = Number(labelShape.attr("text"));
              const colorType = getColorType(scaleColor, color);
              newState = yield updateView(title2, y3, colorType, [
                "line",
                "area"
              ]);
              labelShape.remove();
              pathShape.remove();
              createPoints(element);
            });
            container.addEventListener("mouseup", mouseupFn);
          });
          pointsGroup.appendChild(circle2);
        });
        selectedPointsStyle(pointsGroup.childNodes, newSelection, pointDefaultStyle);
      } else if (markType === "interval") {
        let circlePoint = [(points[0][0] + points[1][0]) / 2, points[0][1]];
        if (isTranspose3) {
          circlePoint = [points[0][0], (points[0][1] + points[1][1]) / 2];
        } else if (isTheta3) {
          circlePoint = points[0];
        }
        const ratioTransform = getIntervalDataRatioTransformFn(element);
        const circle2 = new Circle({
          name: MOVE_POINT_NAME,
          style: Object.assign(Object.assign({ cx: circlePoint[0], cy: circlePoint[1], fill }, pointDefaultStyle), { stroke: pointDefaultStyle["activeStroke"] })
        });
        circle2.addEventListener("mousedown", (e3) => {
          container.attr("cursor", "move");
          const colorType = getColorType(scaleColor, color);
          const [pathShape, labelShape] = createHelpShape(pointsGroup, circle2, pathDefaultStyle, labelDefaultStyle);
          const pointMousemove = (e4) => {
            if (isTranspose3) {
              const newCx = circlePoint[0] + e4.clientX - downPoint[0];
              const [initX] = coordinate.output([
                scaleY.output(0),
                scaleY.output(0)
              ]);
              const [, x2] = coordinate.invert([
                initX + (newCx - points[2][0]),
                circlePoint[1]
              ]);
              const newPath = getPointsPath([
                [newCx, points[0][1]],
                [newCx, points[1][1]],
                points[2],
                points[3]
              ], true);
              labelShape.attr("text", ratioTransform(scaleY.invert(x2)).toFixed(precision));
              pathShape.attr("d", newPath);
              circle2.attr("cx", newCx);
            } else if (isTheta3) {
              const newCy = circlePoint[1] + e4.clientY - downPoint[1];
              const newCx = circlePoint[0] + e4.clientX - downPoint[0];
              const [newXOut, newYOut] = getSamePointPosition(center2, [newCx, newCy], circlePoint);
              const [newXIn, newYIn] = getSamePointPosition(center2, [newCx, newCy], points[1]);
              const lastPercent = coordinate.invert([newXOut, newYOut])[1];
              const percent = y12 - lastPercent;
              if (percent < 0)
                return;
              const newPath = getThetaPath(center2, [[newXOut, newYOut], [newXIn, newYIn], points[2], points[3]], percent > 0.5 ? 1 : 0);
              labelShape.attr("text", ratioTransform(percent, true).toFixed(precision));
              pathShape.attr("d", newPath);
              circle2.attr("cx", newXOut);
              circle2.attr("cy", newYOut);
            } else {
              const newCy = circlePoint[1] + e4.clientY - downPoint[1];
              const [, initY] = coordinate.output([1, scaleY.output(0)]);
              const [, y3] = coordinate.invert([
                circlePoint[0],
                initY - (points[2][1] - newCy)
              ]);
              const newPath = getPointsPath([
                [points[0][0], newCy],
                [points[1][0], newCy],
                points[2],
                points[3]
              ], true);
              labelShape.attr("text", ratioTransform(scaleY.invert(y3)).toFixed(precision));
              pathShape.attr("d", newPath);
              circle2.attr("cy", newCy);
            }
          };
          downPoint = [e3.clientX, e3.clientY];
          window.addEventListener("mousemove", pointMousemove);
          const mouseupFn = () => __awaiter13(this, void 0, void 0, function* () {
            container.attr("cursor", "default");
            container.removeEventListener("mouseup", mouseupFn);
            window.removeEventListener("mousemove", pointMousemove);
            if (is_undefined_default(labelShape.attr("text")))
              return;
            const y3 = Number(labelShape.attr("text"));
            newState = yield updateView(title, y3, colorType, [markType]);
            labelShape.remove();
            pathShape.remove();
            createPoints(element);
          });
          container.addEventListener("mouseup", mouseupFn);
        });
        pointsGroup.appendChild(circle2);
      }
    };
    elements.forEach((element, index2) => {
      if (newSelection[0] === index2) {
        createPoints(element);
      }
      element.addEventListener("click", elementClick);
      element.addEventListener("mouseenter", elementMouseenter);
      element.addEventListener("mouseleave", elementMouseleave);
    });
    const rootClick = (e3) => {
      const element = e3 === null || e3 === void 0 ? void 0 : e3.target;
      if (!element || element.name !== MOVE_POINT_NAME && !elements.includes(element)) {
        newSelection = [];
        selectedChange();
        pointsGroup.removeChildren();
      }
    };
    emitter.on("element-point:select", elementSelect2);
    emitter.on("element-point:unselect", rootClick);
    container.addEventListener("mousedown", rootClick);
    return () => {
      pointsGroup.remove();
      emitter.off("element-point:select", elementSelect2);
      emitter.off("element-point:unselect", rootClick);
      container.removeEventListener("mousedown", rootClick);
      elements.forEach((element) => {
        element.removeEventListener("click", elementClick);
        element.removeEventListener("mouseenter", elementMouseenter);
        element.removeEventListener("mouseleave", elementMouseleave);
      });
    };
  };
}

// node_modules/d3-dsv/src/dsv.js
var EOL = {};
var EOF = {};
var QUOTE = 34;
var NEWLINE = 10;
var RETURN = 13;
function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name2, i2) {
    return JSON.stringify(name2) + ": d[" + i2 + '] || ""';
  }).join(",") + "}");
}
function customConverter(columns, f2) {
  var object = objectConverter(columns);
  return function(row, i2) {
    return f2(object(row), i2, columns);
  };
}
function inferColumns(rows) {
  var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
  rows.forEach(function(row) {
    for (var column2 in row) {
      if (!(column2 in columnSet)) {
        columns.push(columnSet[column2] = column2);
      }
    }
  });
  return columns;
}
function pad(value2, width) {
  var s3 = value2 + "", length = s3.length;
  return length < width ? new Array(width - length + 1).join(0) + s3 : s3;
}
function formatYear(year3) {
  return year3 < 0 ? "-" + pad(-year3, 6) : year3 > 9999 ? "+" + pad(year3, 6) : pad(year3, 4);
}
function formatDate(date) {
  var hours = date.getUTCHours(), minutes = date.getUTCMinutes(), seconds = date.getUTCSeconds(), milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date" : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2) + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z" : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z" : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z" : "");
}
function dsv_default(delimiter) {
  var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
  function parse(text, f2) {
    var convert, columns, rows = parseRows(text, function(row, i2) {
      if (convert) return convert(row, i2 - 1);
      columns = row, convert = f2 ? customConverter(row, f2) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }
  function parseRows(text, f2) {
    var rows = [], N = text.length, I = 0, n2 = 0, t, eof = N <= 0, eol = false;
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;
    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;
      var i2, j = I, c5;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE) ;
        if ((i2 = I) >= N) eof = true;
        else if ((c5 = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c5 === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE) ++I;
        }
        return text.slice(j + 1, i2 - 1).replace(/""/g, '"');
      }
      while (I < N) {
        if ((c5 = text.charCodeAt(i2 = I++)) === NEWLINE) eol = true;
        else if (c5 === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE) ++I;
        } else if (c5 !== DELIMITER) continue;
        return text.slice(j, i2);
      }
      return eof = true, text.slice(j, N);
    }
    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f2 && (row = f2(row, n2++)) == null) continue;
      rows.push(row);
    }
    return rows;
  }
  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column2) {
        return formatValue(row[column2]);
      }).join(delimiter);
    });
  }
  function format3(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }
  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }
  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }
  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }
  function formatValue(value2) {
    return value2 == null ? "" : value2 instanceof Date ? formatDate(value2) : reFormat.test(value2 += "") ? '"' + value2.replace(/"/g, '""') + '"' : value2;
  }
  return {
    parse,
    parseRows,
    format: format3,
    formatBody,
    formatRows,
    formatRow,
    formatValue
  };
}

// node_modules/d3-dsv/src/csv.js
var csv = dsv_default(",");
var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;

// node_modules/d3-dsv/src/tsv.js
var tsv = dsv_default("	");
var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;

// node_modules/d3-dsv/src/autoType.js
function autoType(object) {
  for (var key in object) {
    var value2 = object[key].trim(), number2, m2;
    if (!value2) value2 = null;
    else if (value2 === "true") value2 = true;
    else if (value2 === "false") value2 = false;
    else if (value2 === "NaN") value2 = NaN;
    else if (!isNaN(number2 = +value2)) value2 = number2;
    else if (m2 = value2.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
      if (fixtz && !!m2[4] && !m2[7]) value2 = value2.replace(/-/g, "/").replace(/T/, " ");
      value2 = new Date(value2);
    } else continue;
    object[key] = value2;
  }
  return object;
}
var fixtz = (/* @__PURE__ */ new Date("2019-01-01T00:00")).getHours() || (/* @__PURE__ */ new Date("2019-07-01T00:00")).getHours();

// node_modules/@antv/g2/esm/data/fetch.js
var __awaiter14 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Fetch = (options) => {
  const { value: value2, format: format3 = value2.split(".").pop(), delimiter = ",", autoType: autoType2 = true } = options;
  return () => __awaiter14(void 0, void 0, void 0, function* () {
    const response = yield fetch(value2);
    if (format3 === "csv") {
      const str = yield response.text();
      return dsv_default(delimiter).parse(str, autoType2 ? autoType : identity2);
    }
    if (format3 === "json") {
      return yield response.json();
    }
    throw new Error(`Unknown format: ${format3}.`);
  });
};
Fetch.props = {};

// node_modules/@antv/g2/esm/data/fold.js
function isEmpty(obj) {
  return !obj || Object.keys(obj).length === 0;
}
var Fold = (options) => {
  const { fields, key = "key", value: value2 = "value" } = options;
  return (data) => {
    if (isEmpty(fields))
      return data;
    return data.flatMap((d3) => fields.map((f2) => Object.assign(Object.assign({}, d3), { [key]: f2, [value2]: d3[f2] })));
  };
};
Fold.props = {};

// node_modules/@antv/g2/esm/data/filter.js
function defined2(d3) {
  return d3 !== void 0 && d3 !== null && !Number.isNaN(d3);
}
var Filter2 = (options) => {
  const { callback = defined2 } = options;
  return (data) => data.filter(callback);
};
Filter2.props = {};

// node_modules/@antv/g2/esm/data/sort.js
var Sort2 = (options) => {
  const { callback } = options;
  return (data) => Array.isArray(data) ? [...data].sort(callback) : data;
};
Sort2.props = {};

// node_modules/@antv/g2/esm/data/pick.js
function pick(v, fields = []) {
  return fields.reduce((datum, field3) => {
    if (field3 in v) {
      datum[field3] = v[field3];
    }
    return datum;
  }, {});
}
var Pick = (options) => {
  const { fields } = options;
  return (data) => data.map((d3) => pick(d3, fields));
};
Pick.props = {};

// node_modules/@antv/g2/esm/data/rename.js
function isEmpty2(obj) {
  return Object.keys(obj).length === 0;
}
var Rename = (options) => {
  return (data) => {
    if (!options || isEmpty2(options))
      return data;
    const rename = (v) => Object.entries(v).reduce((datum, [key, value2]) => (datum[options[key] || key] = value2, datum), {});
    return data.map(rename);
  };
};
Rename.props = {};

// node_modules/@antv/g2/esm/data/utils/fields.js
function normalizeFields(fields, defaultValue) {
  return fields.map((d3) => {
    if (Array.isArray(d3)) {
      const [field3, value2 = defaultValue] = d3;
      return [field3, value2];
    }
    return [d3, defaultValue];
  });
}

// node_modules/@antv/g2/esm/data/sortBy.js
var SortBy = (options) => {
  const { fields: F = [] } = options;
  const normalizedF = normalizeFields(F, true);
  return (data) => {
    const comparator = (a4, b) => normalizedF.reduce((ret, [field3, order = true]) => {
      if (ret !== 0) {
        return ret;
      }
      if (order) {
        return a4[field3] < b[field3] ? -1 : +(a4[field3] !== b[field3]);
      } else {
        return a4[field3] > b[field3] ? -1 : +(a4[field3] !== b[field3]);
      }
    }, 0);
    return [...data].sort(comparator);
  };
};
SortBy.props = {};

// node_modules/@antv/g2/esm/data/inline.js
var Inline = (options) => {
  const { value: value2 } = options;
  return () => value2;
};
Inline.props = {};

// node_modules/@antv/g2/esm/data/custom.js
var Custom = (options) => {
  const { callback = identity2 } = options;
  return (data) => callback(data);
};
Custom.props = {};

// node_modules/@antv/g2/esm/data/map.js
var Map2 = (options) => {
  const { callback = identity2 } = options;
  return (data) => Array.isArray(data) ? data.map(callback) : data;
};
Map2.props = {};

// node_modules/@antv/g2/esm/data/utils/flow.js
var __awaiter15 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function flow2(target, source) {
  return {
    set(key, normalize5, callback) {
      if (source[key] === void 0)
        return this;
      const value2 = normalize5 ? normalize5.call(null, source[key]) : source[key];
      if (callback)
        callback.call(null, value2);
      else if (typeof target[key] === "function")
        target[key](value2);
      else
        target[key] = value2;
      return this;
    },
    setAsync(key, normalize5, callback) {
      return __awaiter15(this, void 0, void 0, function* () {
        if (source[key] === void 0)
          return this;
        const value2 = normalize5 ? yield normalize5.call(null, source[key]) : source[key];
        if (callback)
          callback.call(null, value2);
        else if (typeof target[key] === "function")
          target[key](value2);
        else
          target[key] = value2;
        return this;
      });
    }
  };
}

// node_modules/@antv/g2/esm/data/utils/d3-cloud/index.js
var cloudRadians = Math.PI / 180;
var cw = 1 << 11 >> 5;
var ch = 1 << 11;
function cloudText(d3) {
  return d3.text;
}
function cloudFont() {
  return "serif";
}
function cloudFontNormal() {
  return "normal";
}
function cloudFontSize(d3) {
  return d3.value;
}
function cloudRotate() {
  return ~~(Math.random() * 2) * 90;
}
function cloudPadding() {
  return 1;
}
function cloudDispatch() {
  return;
}
function cloudSprite(contextAndRatio, d3, data, di) {
  if (d3.sprite)
    return;
  const c5 = contextAndRatio.context, ratio = contextAndRatio.ratio;
  c5.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  let x2 = 0, y3 = 0, maxh = 0;
  const n2 = data.length;
  --di;
  while (++di < n2) {
    d3 = data[di];
    c5.save();
    c5.font = d3.style + " " + d3.weight + " " + ~~((d3.size + 1) / ratio) + "px " + d3.font;
    let w2 = c5.measureText(d3.text + "m").width * ratio, h2 = d3.size << 1;
    if (d3.rotate) {
      const sr = Math.sin(d3.rotate * cloudRadians), cr = Math.cos(d3.rotate * cloudRadians), wcr = w2 * cr, wsr = w2 * sr, hcr = h2 * cr, hsr = h2 * sr;
      w2 = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
      h2 = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w2 = w2 + 31 >> 5 << 5;
    }
    if (h2 > maxh)
      maxh = h2;
    if (x2 + w2 >= cw << 5) {
      x2 = 0;
      y3 += maxh;
      maxh = 0;
    }
    if (y3 + h2 >= ch)
      break;
    c5.translate((x2 + (w2 >> 1)) / ratio, (y3 + (h2 >> 1)) / ratio);
    if (d3.rotate)
      c5.rotate(d3.rotate * cloudRadians);
    c5.fillText(d3.text, 0, 0);
    if (d3.padding) {
      c5.lineWidth = 2 * d3.padding;
      c5.strokeText(d3.text, 0, 0);
    }
    c5.restore();
    d3.width = w2;
    d3.height = h2;
    d3.xoff = x2;
    d3.yoff = y3;
    d3.x1 = w2 >> 1;
    d3.y1 = h2 >> 1;
    d3.x0 = -d3.x1;
    d3.y0 = -d3.y1;
    d3.hasText = true;
    x2 += w2;
  }
  const pixels = c5.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
  while (--di >= 0) {
    d3 = data[di];
    if (!d3.hasText)
      continue;
    const w2 = d3.width, w32 = w2 >> 5;
    let h2 = d3.y1 - d3.y0;
    for (let i2 = 0; i2 < h2 * w32; i2++)
      sprite[i2] = 0;
    x2 = d3.xoff;
    if (x2 == null)
      return;
    y3 = d3.yoff;
    let seen = 0, seenRow = -1;
    for (let j = 0; j < h2; j++) {
      for (let i2 = 0; i2 < w2; i2++) {
        const k2 = w32 * j + (i2 >> 5), m2 = pixels[(y3 + j) * (cw << 5) + (x2 + i2) << 2] ? 1 << 31 - i2 % 32 : 0;
        sprite[k2] |= m2;
        seen |= m2;
      }
      if (seen)
        seenRow = j;
      else {
        d3.y0++;
        h2--;
        j--;
        y3++;
      }
    }
    d3.y1 = d3.y0 + seenRow;
    d3.sprite = sprite.slice(0, (d3.y1 - d3.y0) * w32);
  }
}
function cloudCollide(tag, board, sw) {
  sw >>= 5;
  const sprite = tag.sprite, w2 = tag.width >> 5, lx = tag.x - (w2 << 4), sx = lx & 127, msx = 32 - sx, h2 = tag.y1 - tag.y0;
  let x2 = (tag.y + tag.y0) * sw + (lx >> 5), last6;
  for (let j = 0; j < h2; j++) {
    last6 = 0;
    for (let i2 = 0; i2 <= w2; i2++) {
      if ((last6 << msx | (i2 < w2 ? (last6 = sprite[j * w2 + i2]) >>> sx : 0)) & board[x2 + i2])
        return true;
    }
    x2 += sw;
  }
  return false;
}
function cloudBounds(bounds, d3) {
  const b0 = bounds[0], b1 = bounds[1];
  if (d3.x + d3.x0 < b0.x)
    b0.x = d3.x + d3.x0;
  if (d3.y + d3.y0 < b0.y)
    b0.y = d3.y + d3.y0;
  if (d3.x + d3.x1 > b1.x)
    b1.x = d3.x + d3.x1;
  if (d3.y + d3.y1 > b1.y)
    b1.y = d3.y + d3.y1;
}
function collideRects(a4, b) {
  return a4.x + a4.x1 > b[0].x && a4.x + a4.x0 < b[1].x && a4.y + a4.y1 > b[0].y && a4.y + a4.y0 < b[1].y;
}
function archimedeanSpiral(size4) {
  const e3 = size4[0] / size4[1];
  return function(t) {
    return [e3 * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
  };
}
function rectangularSpiral(size4) {
  const dy = 4, dx = dy * size4[0] / size4[1];
  let x2 = 0, y3 = 0;
  return function(t) {
    const sign3 = t < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * sign3 * t) - sign3 & 3) {
      case 0:
        x2 += dx;
        break;
      case 1:
        y3 += dy;
        break;
      case 2:
        x2 -= dx;
        break;
      default:
        y3 -= dy;
        break;
    }
    return [x2, y3];
  };
}
function zeroArray(n2) {
  const a4 = [];
  let i2 = -1;
  while (++i2 < n2)
    a4[i2] = 0;
  return a4;
}
function cloudCanvas() {
  return document.createElement("canvas");
}
function functor(d3) {
  return typeof d3 === "function" ? d3 : function() {
    return d3;
  };
}
var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};
function tagCloud() {
  let size4 = [256, 256], text = cloudText, font = cloudFont, fontSize = cloudFontSize, fontWeight = cloudFontNormal, rotate2 = cloudRotate, padding = cloudPadding, spiral = archimedeanSpiral, random = Math.random, event = cloudDispatch, words = [], timer = null, timeInterval = Infinity, canvas = cloudCanvas;
  const fontStyle = cloudFontNormal;
  const cloud = {};
  cloud.start = function() {
    const [width, height] = size4;
    const contextAndRatio = getContext(canvas()), board = cloud.board ? cloud.board : zeroArray((size4[0] >> 5) * size4[1]), n2 = words.length, tags = [], data = words.map(function(d3, i3, data2) {
      d3.text = text.call(this, d3, i3, data2);
      d3.font = font.call(this, d3, i3, data2);
      d3.style = fontStyle.call(this, d3, i3, data2);
      d3.weight = fontWeight.call(this, d3, i3, data2);
      d3.rotate = rotate2.call(this, d3, i3, data2);
      d3.size = ~~fontSize.call(this, d3, i3, data2);
      d3.padding = padding.call(this, d3, i3, data2);
      return d3;
    }).sort(function(a4, b) {
      return b.size - a4.size;
    });
    let i2 = -1, bounds = !cloud.board ? void 0 : [
      {
        x: 0,
        y: 0
      },
      {
        x: width,
        y: height
      }
    ];
    if (timer)
      clearInterval(timer);
    timer = setInterval(step, 0);
    step();
    function step() {
      const start = Date.now();
      while (Date.now() - start < timeInterval && ++i2 < n2) {
        const d3 = data[i2];
        d3.x = width * (random() + 0.5) >> 1;
        d3.y = height * (random() + 0.5) >> 1;
        cloudSprite(contextAndRatio, d3, data, i2);
        if (d3.hasText && place2(board, d3, bounds)) {
          event.call(null, "word", { cloud, word: d3 });
          tags.push(d3);
          if (bounds) {
            if (!cloud.hasImage) {
              cloudBounds(bounds, d3);
            }
          } else {
            bounds = [
              { x: d3.x + d3.x0, y: d3.y + d3.y0 },
              { x: d3.x + d3.x1, y: d3.y + d3.y1 }
            ];
          }
          d3.x -= size4[0] >> 1;
          d3.y -= size4[1] >> 1;
        }
      }
      cloud._tags = tags;
      cloud._bounds = bounds;
      if (i2 >= n2) {
        cloud.stop();
        event.call(null, "end", { cloud, words: tags, bounds });
      }
    }
    return cloud;
  };
  cloud.stop = function() {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
    return cloud;
  };
  function getContext(canvas2) {
    canvas2.width = canvas2.height = 1;
    const ratio = Math.sqrt(canvas2.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
    canvas2.width = (cw << 5) / ratio;
    canvas2.height = ch / ratio;
    const context = canvas2.getContext("2d");
    context.fillStyle = context.strokeStyle = "red";
    context.textAlign = "center";
    context.textBaseline = "middle";
    return { context, ratio };
  }
  function place2(board, tag, bounds) {
    const startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size4[0] * size4[0] + size4[1] * size4[1]), s3 = spiral(size4), dt = random() < 0.5 ? 1 : -1;
    let dxdy, t = -dt, dx, dy;
    while (dxdy = s3(t += dt)) {
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta)
        break;
      tag.x = startX + dx;
      tag.y = startY + dy;
      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size4[0] || tag.y + tag.y1 > size4[1])
        continue;
      if (!bounds || !cloudCollide(tag, board, size4[0])) {
        if (!bounds || collideRects(tag, bounds)) {
          const sprite = tag.sprite, w2 = tag.width >> 5, sw = size4[0] >> 5, lx = tag.x - (w2 << 4), sx = lx & 127, msx = 32 - sx, h2 = tag.y1 - tag.y0;
          let last6, x2 = (tag.y + tag.y0) * sw + (lx >> 5);
          for (let j = 0; j < h2; j++) {
            last6 = 0;
            for (let i2 = 0; i2 <= w2; i2++) {
              board[x2 + i2] |= last6 << msx | (i2 < w2 ? (last6 = sprite[j * w2 + i2]) >>> sx : 0);
            }
            x2 += sw;
          }
          delete tag.sprite;
          return true;
        }
      }
    }
    return false;
  }
  cloud.createMask = (img) => {
    const can = document.createElement("canvas");
    const [width, height] = size4;
    if (!width || !height) {
      return;
    }
    const w32 = width >> 5;
    const board = zeroArray((width >> 5) * height);
    can.width = width;
    can.height = height;
    const cxt = can.getContext("2d");
    cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);
    const imageData = cxt.getImageData(0, 0, width, height).data;
    for (let j = 0; j < height; j++) {
      for (let i2 = 0; i2 < width; i2++) {
        const k2 = w32 * j + (i2 >> 5);
        const tmp = j * width + i2 << 2;
        const flag = imageData[tmp] >= 250 && imageData[tmp + 1] >= 250 && imageData[tmp + 2] >= 250;
        const m2 = flag ? 1 << 31 - i2 % 32 : 0;
        board[k2] |= m2;
      }
    }
    cloud.board = board;
    cloud.hasImage = true;
  };
  cloud.timeInterval = function(_) {
    timeInterval = _ == null ? Infinity : _;
  };
  cloud.words = function(_) {
    words = _;
  };
  cloud.size = function(_ = []) {
    size4 = [+_[0], +_[1]];
  };
  cloud.text = function(_) {
    text = functor(_);
  };
  cloud.font = function(_) {
    font = functor(_);
  };
  cloud.fontWeight = function(_) {
    fontWeight = functor(_);
  };
  cloud.rotate = function(_) {
    rotate2 = functor(_);
  };
  cloud.canvas = function(_) {
    canvas = functor(_);
  };
  cloud.spiral = function(_) {
    spiral = spirals[_] || _;
  };
  cloud.fontSize = function(_) {
    fontSize = functor(_);
  };
  cloud.padding = function(_) {
    padding = functor(_);
  };
  cloud.random = function(_) {
    random = functor(_);
  };
  cloud.on = function(_) {
    event = functor(_);
  };
  return cloud;
}

// node_modules/@antv/g2/esm/data/wordCloud.js
var __awaiter16 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest89 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var DEFAULT_OPTIONS6 = {
  fontSize: [20, 60],
  font: "Impact",
  padding: 2,
  rotate: function() {
    return (~~(Math.random() * 6) - 3) * 30;
  }
};
function processImageMask(img) {
  return new Promise((res, rej) => {
    if (img instanceof HTMLImageElement) {
      res(img);
      return;
    }
    if (typeof img === "string") {
      const image = new Image();
      image.crossOrigin = "anonymous";
      image.src = img;
      image.onload = () => res(image);
      image.onerror = () => {
        console.error(`'image ${img} load failed !!!'`);
        rej();
      };
      return;
    }
    rej();
  });
}
function normalizeFontSize(fontSize, range3) {
  if (typeof fontSize === "function")
    return fontSize;
  if (Array.isArray(fontSize)) {
    const [fMin, fMax] = fontSize;
    if (!range3)
      return () => (fMax + fMin) / 2;
    const [min6, max7] = range3;
    if (max7 === min6)
      return () => (fMax + fMin) / 2;
    return ({ value: value2 }) => (fMax - fMin) / (max7 - min6) * (value2 - min6) + fMin;
  }
  return () => fontSize;
}
var WordCloud2 = (options, context) => {
  return (data) => __awaiter16(void 0, void 0, void 0, function* () {
    const cloudOptions = Object.assign({}, DEFAULT_OPTIONS6, options, {
      canvas: context.createCanvas
    });
    const layout = tagCloud();
    yield flow2(layout, cloudOptions).set("fontSize", (v) => {
      const arr = data.map((d3) => d3.value);
      return normalizeFontSize(v, [min(arr), max(arr)]);
    }).set("font").set("fontStyle").set("fontWeight").set("padding").set("rotate").set("size").set("spiral").set("timeInterval").set("random").set("text").set("on").set("canvas").setAsync("imageMask", processImageMask, layout.createMask);
    layout.words([...data]);
    const result = layout.start();
    const [cw2, ch2] = cloudOptions.size;
    const defaultBounds = [
      { x: 0, y: 0 },
      { x: cw2, y: ch2 }
    ];
    const { _bounds: bounds = defaultBounds, _tags, hasImage } = result;
    const tags = _tags.map((_a) => {
      var { x: x2, y: y3, font } = _a, rest = __rest89(_a, ["x", "y", "font"]);
      return Object.assign(Object.assign({}, rest), { x: x2 + cw2 / 2, y: y3 + ch2 / 2, fontFamily: font });
    });
    const [{ x: tlx, y: tly }, { x: brx, y: bry }] = bounds;
    const invisibleText = { text: "", value: 0, opacity: 0, fontSize: 0 };
    tags.push(Object.assign(Object.assign({}, invisibleText), { x: hasImage ? 0 : tlx, y: hasImage ? 0 : tly }), Object.assign(Object.assign({}, invisibleText), { x: hasImage ? cw2 : brx, y: hasImage ? ch2 : bry }));
    return tags;
  });
};
WordCloud2.props = {};

// node_modules/@antv/g2/esm/data/join.js
function field2(key) {
  return typeof key === "string" ? (d3) => d3[key] : key;
}
var Join = (options) => {
  const { join, on, select: select2 = [], as = select2, unknown = NaN } = options;
  const [key, fromKey] = on;
  const fk = field2(fromKey);
  const k2 = field2(key);
  const keyData = rollup(
    join,
    ([d3]) => d3,
    // Get the first matched.
    (d3) => fk(d3)
  );
  return (data) => data.map((d3) => {
    const source = keyData.get(k2(d3));
    return Object.assign(Object.assign({}, d3), select2.reduce((prev, key2, idx) => (prev[as[idx]] = source ? source[key2] : unknown, prev), {}));
  });
};
Join.props = {};

// node_modules/@antv/g2/esm/data/slice.js
var Slice = (options) => {
  const { start, end } = options;
  return (data) => data.slice(start, end);
};
Slice.props = {};

// node_modules/@antv/g2/esm/data/kde.js
var import_pdfast = __toESM(require_src());
var KDE = (options) => {
  const { field: field3, groupBy: groupBy2, as = ["y", "size"], min: min6, max: max7, size: size4 = 10, width } = options;
  const [yField, sizeField] = as;
  return (data) => {
    const gs = Array.from(group(data, (d3) => groupBy2.map((gb) => d3[gb]).join("-")).values());
    return gs.map((g) => {
      const pdfResult = import_pdfast.default.create(g.map((i2) => i2[field3]), {
        min: min6,
        max: max7,
        size: size4,
        width
      });
      const _y = pdfResult.map((result) => result.x);
      const _size = pdfResult.map((result) => result.y);
      return Object.assign(Object.assign({}, g[0]), { [yField]: _y, [sizeField]: _size });
    });
  };
};
KDE.props = {};

// node_modules/@antv/g2/esm/data/utils/venn/fmin/bisect.js
function bisect3(f2, a4, b, parameters) {
  parameters = parameters || {};
  const maxIterations = parameters.maxIterations || 100;
  const tolerance = parameters.tolerance || 1e-10;
  const fA = f2(a4);
  const fB = f2(b);
  let delta = b - a4;
  if (fA * fB > 0) {
    throw "Initial bisect points must have opposite signs";
  }
  if (fA === 0)
    return a4;
  if (fB === 0)
    return b;
  for (let i2 = 0; i2 < maxIterations; ++i2) {
    delta /= 2;
    const mid2 = a4 + delta;
    const fMid = f2(mid2);
    if (fMid * fA >= 0) {
      a4 = mid2;
    }
    if (Math.abs(delta) < tolerance || fMid === 0) {
      return mid2;
    }
  }
  return a4 + delta;
}

// node_modules/@antv/g2/esm/data/utils/venn/fmin/blas1.js
function zeros(x2) {
  const r2 = new Array(x2);
  for (let i2 = 0; i2 < x2; ++i2) {
    r2[i2] = 0;
  }
  return r2;
}
function zerosM(x2, y3) {
  return zeros(x2).map(() => zeros(y3));
}
function dot2(a4, b) {
  let ret = 0;
  for (let i2 = 0; i2 < a4.length; ++i2) {
    ret += a4[i2] * b[i2];
  }
  return ret;
}
function norm2(a4) {
  return Math.sqrt(dot2(a4, a4));
}
function scale2(ret, value2, c5) {
  for (let i2 = 0; i2 < value2.length; ++i2) {
    ret[i2] = value2[i2] * c5;
  }
}
function weightedSum(ret, w1, v1, w2, v2) {
  for (let j = 0; j < ret.length; ++j) {
    ret[j] = w1 * v1[j] + w2 * v2[j];
  }
}

// node_modules/@antv/g2/esm/data/utils/venn/fmin/nelderMead.js
function nelderMead(f2, x05, parameters) {
  parameters = parameters || {};
  const maxIterations = parameters.maxIterations || x05.length * 200;
  const nonZeroDelta = parameters.nonZeroDelta || 1.05;
  const zeroDelta = parameters.zeroDelta || 1e-3;
  const minErrorDelta = parameters.minErrorDelta || 1e-6;
  const minTolerance = parameters.minErrorDelta || 1e-5;
  const rho = parameters.rho !== void 0 ? parameters.rho : 1;
  const chi = parameters.chi !== void 0 ? parameters.chi : 2;
  const psi = parameters.psi !== void 0 ? parameters.psi : -0.5;
  const sigma = parameters.sigma !== void 0 ? parameters.sigma : 0.5;
  let maxDiff;
  const N = x05.length;
  const simplex = new Array(N + 1);
  simplex[0] = x05;
  simplex[0].fx = f2(x05);
  simplex[0].id = 0;
  for (let i2 = 0; i2 < N; ++i2) {
    const point6 = x05.slice();
    point6[i2] = point6[i2] ? point6[i2] * nonZeroDelta : zeroDelta;
    simplex[i2 + 1] = point6;
    simplex[i2 + 1].fx = f2(point6);
    simplex[i2 + 1].id = i2 + 1;
  }
  function updateSimplex(value2) {
    for (let i2 = 0; i2 < value2.length; i2++) {
      simplex[N][i2] = value2[i2];
    }
    simplex[N].fx = value2.fx;
  }
  const sortOrder = (a4, b) => a4.fx - b.fx;
  const centroid = x05.slice();
  const reflected = x05.slice();
  const contracted = x05.slice();
  const expanded = x05.slice();
  for (let iteration = 0; iteration < maxIterations; ++iteration) {
    simplex.sort(sortOrder);
    if (parameters.history) {
      const sortedSimplex = simplex.map((x2) => {
        const state = x2.slice();
        state.fx = x2.fx;
        state.id = x2.id;
        return state;
      });
      sortedSimplex.sort((a4, b) => a4.id - b.id);
      parameters.history.push({
        x: simplex[0].slice(),
        fx: simplex[0].fx,
        simplex: sortedSimplex
      });
    }
    maxDiff = 0;
    for (let i2 = 0; i2 < N; ++i2) {
      maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i2] - simplex[1][i2]));
    }
    if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta && maxDiff < minTolerance) {
      break;
    }
    for (let i2 = 0; i2 < N; ++i2) {
      centroid[i2] = 0;
      for (let j = 0; j < N; ++j) {
        centroid[i2] += simplex[j][i2];
      }
      centroid[i2] /= N;
    }
    const worst = simplex[N];
    weightedSum(reflected, 1 + rho, centroid, -rho, worst);
    reflected.fx = f2(reflected);
    if (reflected.fx < simplex[0].fx) {
      weightedSum(expanded, 1 + chi, centroid, -chi, worst);
      expanded.fx = f2(expanded);
      if (expanded.fx < reflected.fx) {
        updateSimplex(expanded);
      } else {
        updateSimplex(reflected);
      }
    } else if (reflected.fx >= simplex[N - 1].fx) {
      let shouldReduce = false;
      if (reflected.fx > worst.fx) {
        weightedSum(contracted, 1 + psi, centroid, -psi, worst);
        contracted.fx = f2(contracted);
        if (contracted.fx < worst.fx) {
          updateSimplex(contracted);
        } else {
          shouldReduce = true;
        }
      } else {
        weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst);
        contracted.fx = f2(contracted);
        if (contracted.fx < reflected.fx) {
          updateSimplex(contracted);
        } else {
          shouldReduce = true;
        }
      }
      if (shouldReduce) {
        if (sigma >= 1)
          break;
        for (let i2 = 1; i2 < simplex.length; ++i2) {
          weightedSum(simplex[i2], 1 - sigma, simplex[0], sigma, simplex[i2]);
          simplex[i2].fx = f2(simplex[i2]);
        }
      }
    } else {
      updateSimplex(reflected);
    }
  }
  simplex.sort(sortOrder);
  return { fx: simplex[0].fx, x: simplex[0] };
}

// node_modules/@antv/g2/esm/data/utils/venn/fmin/linesearch.js
function wolfeLineSearch(f2, pk, current, next, a4, c1, c22) {
  const phi0 = current.fx;
  const phiPrime0 = dot2(current.fxprime, pk);
  let phi2 = phi0;
  let phi_old = phi0;
  let phiPrime = phiPrime0;
  let a0 = 0;
  a4 = a4 || 1;
  c1 = c1 || 1e-6;
  c22 = c22 || 0.1;
  function zoom(a_lo, a_high, phi_lo) {
    for (let iteration = 0; iteration < 16; ++iteration) {
      a4 = (a_lo + a_high) / 2;
      weightedSum(next.x, 1, current.x, a4, pk);
      phi2 = next.fx = f2(next.x, next.fxprime);
      phiPrime = dot2(next.fxprime, pk);
      if (phi2 > phi0 + c1 * a4 * phiPrime0 || phi2 >= phi_lo) {
        a_high = a4;
      } else {
        if (Math.abs(phiPrime) <= -c22 * phiPrime0) {
          return a4;
        }
        if (phiPrime * (a_high - a_lo) >= 0) {
          a_high = a_lo;
        }
        a_lo = a4;
        phi_lo = phi2;
      }
    }
    return 0;
  }
  for (let iteration = 0; iteration < 10; ++iteration) {
    weightedSum(next.x, 1, current.x, a4, pk);
    phi2 = next.fx = f2(next.x, next.fxprime);
    phiPrime = dot2(next.fxprime, pk);
    if (phi2 > phi0 + c1 * a4 * phiPrime0 || iteration && phi2 >= phi_old) {
      return zoom(a0, a4, phi_old);
    }
    if (Math.abs(phiPrime) <= -c22 * phiPrime0) {
      return a4;
    }
    if (phiPrime >= 0) {
      return zoom(a4, a0, phi2);
    }
    phi_old = phi2;
    a0 = a4;
    a4 *= 2;
  }
  return a4;
}

// node_modules/@antv/g2/esm/data/utils/venn/fmin/conjugateGradient.js
function conjugateGradient(f2, initial, params) {
  let current = { x: initial.slice(), fx: 0, fxprime: initial.slice() };
  let next = { x: initial.slice(), fx: 0, fxprime: initial.slice() };
  const yk = initial.slice();
  let temp;
  let a4 = 1;
  params = params || {};
  const maxIterations = params.maxIterations || initial.length * 20;
  current.fx = f2(current.x, current.fxprime);
  const pk = current.fxprime.slice();
  scale2(pk, current.fxprime, -1);
  for (let i2 = 0; i2 < maxIterations; ++i2) {
    a4 = wolfeLineSearch(f2, pk, current, next, a4);
    if (params.history) {
      params.history.push({
        x: current.x.slice(),
        fx: current.fx,
        fxprime: current.fxprime.slice(),
        alpha: a4
      });
    }
    if (!a4) {
      scale2(pk, current.fxprime, -1);
    } else {
      weightedSum(yk, 1, next.fxprime, -1, current.fxprime);
      const delta_k = dot2(current.fxprime, current.fxprime);
      const beta_k = Math.max(0, dot2(yk, next.fxprime) / delta_k);
      weightedSum(pk, beta_k, pk, -1, next.fxprime);
      temp = current;
      current = next;
      next = temp;
    }
    if (norm2(current.fxprime) <= 1e-5) {
      break;
    }
  }
  if (params.history) {
    params.history.push({
      x: current.x.slice(),
      fx: current.fx,
      fxprime: current.fxprime.slice(),
      alpha: a4
    });
  }
  return current;
}

// node_modules/@antv/g2/esm/data/utils/venn/circleintersection.js
var SMALL = 1e-10;
function intersectionArea(circles, stats) {
  const intersectionPoints = getIntersectionPoints(circles);
  const innerPoints = intersectionPoints.filter(function(p3) {
    return containedInCircles(p3, circles);
  });
  let arcArea = 0, polygonArea = 0, i2;
  const arcs = [];
  if (innerPoints.length > 1) {
    const center2 = getCenter(innerPoints);
    for (i2 = 0; i2 < innerPoints.length; ++i2) {
      const p3 = innerPoints[i2];
      p3.angle = Math.atan2(p3.x - center2.x, p3.y - center2.y);
    }
    innerPoints.sort(function(a4, b) {
      return b.angle - a4.angle;
    });
    let p22 = innerPoints[innerPoints.length - 1];
    for (i2 = 0; i2 < innerPoints.length; ++i2) {
      const p1 = innerPoints[i2];
      polygonArea += (p22.x + p1.x) * (p1.y - p22.y);
      const midPoint2 = { x: (p1.x + p22.x) / 2, y: (p1.y + p22.y) / 2 };
      let arc = null;
      for (let j = 0; j < p1.parentIndex.length; ++j) {
        if (p22.parentIndex.indexOf(p1.parentIndex[j]) > -1) {
          const circle2 = circles[p1.parentIndex[j]], a1 = Math.atan2(p1.x - circle2.x, p1.y - circle2.y), a22 = Math.atan2(p22.x - circle2.x, p22.y - circle2.y);
          let angleDiff = a22 - a1;
          if (angleDiff < 0) {
            angleDiff += 2 * Math.PI;
          }
          const a4 = a22 - angleDiff / 2;
          let width = distance(midPoint2, {
            x: circle2.x + circle2.radius * Math.sin(a4),
            y: circle2.y + circle2.radius * Math.cos(a4)
          });
          if (width > circle2.radius * 2) {
            width = circle2.radius * 2;
          }
          if (arc === null || arc.width > width) {
            arc = { circle: circle2, width, p1, p2: p22 };
          }
        }
      }
      if (arc !== null) {
        arcs.push(arc);
        arcArea += circleArea(arc.circle.radius, arc.width);
        p22 = p1;
      }
    }
  } else {
    let smallest = circles[0];
    for (i2 = 1; i2 < circles.length; ++i2) {
      if (circles[i2].radius < smallest.radius) {
        smallest = circles[i2];
      }
    }
    let disjoint2 = false;
    for (i2 = 0; i2 < circles.length; ++i2) {
      if (distance(circles[i2], smallest) > Math.abs(smallest.radius - circles[i2].radius)) {
        disjoint2 = true;
        break;
      }
    }
    if (disjoint2) {
      arcArea = polygonArea = 0;
    } else {
      arcArea = smallest.radius * smallest.radius * Math.PI;
      arcs.push({
        circle: smallest,
        p1: { x: smallest.x, y: smallest.y + smallest.radius },
        p2: { x: smallest.x - SMALL, y: smallest.y + smallest.radius },
        width: smallest.radius * 2
      });
    }
  }
  polygonArea /= 2;
  if (stats) {
    stats.area = arcArea + polygonArea;
    stats.arcArea = arcArea;
    stats.polygonArea = polygonArea;
    stats.arcs = arcs;
    stats.innerPoints = innerPoints;
    stats.intersectionPoints = intersectionPoints;
  }
  return arcArea + polygonArea;
}
function containedInCircles(point6, circles) {
  for (let i2 = 0; i2 < circles.length; ++i2) {
    if (distance(point6, circles[i2]) > circles[i2].radius + SMALL) {
      return false;
    }
  }
  return true;
}
function getIntersectionPoints(circles) {
  const ret = [];
  for (let i2 = 0; i2 < circles.length; ++i2) {
    for (let j = i2 + 1; j < circles.length; ++j) {
      const intersect3 = circleCircleIntersection(circles[i2], circles[j]);
      for (let k2 = 0; k2 < intersect3.length; ++k2) {
        const p3 = intersect3[k2];
        p3.parentIndex = [i2, j];
        ret.push(p3);
      }
    }
  }
  return ret;
}
function circleArea(r2, width) {
  return r2 * r2 * Math.acos(1 - width / r2) - (r2 - width) * Math.sqrt(width * (2 * r2 - width));
}
function distance(p1, p22) {
  return Math.sqrt((p1.x - p22.x) * (p1.x - p22.x) + (p1.y - p22.y) * (p1.y - p22.y));
}
function circleOverlap(r1, r2, d3) {
  if (d3 >= r1 + r2) {
    return 0;
  }
  if (d3 <= Math.abs(r1 - r2)) {
    return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);
  }
  const w1 = r1 - (d3 * d3 - r2 * r2 + r1 * r1) / (2 * d3), w2 = r2 - (d3 * d3 - r1 * r1 + r2 * r2) / (2 * d3);
  return circleArea(r1, w1) + circleArea(r2, w2);
}
function circleCircleIntersection(p1, p22) {
  const d3 = distance(p1, p22), r1 = p1.radius, r2 = p22.radius;
  if (d3 >= r1 + r2 || d3 <= Math.abs(r1 - r2)) {
    return [];
  }
  const a4 = (r1 * r1 - r2 * r2 + d3 * d3) / (2 * d3), h2 = Math.sqrt(r1 * r1 - a4 * a4), x05 = p1.x + a4 * (p22.x - p1.x) / d3, y05 = p1.y + a4 * (p22.y - p1.y) / d3, rx = -(p22.y - p1.y) * (h2 / d3), ry = -(p22.x - p1.x) * (h2 / d3);
  return [
    { x: x05 + rx, y: y05 - ry },
    { x: x05 - rx, y: y05 + ry }
  ];
}
function getCenter(points) {
  const center2 = { x: 0, y: 0 };
  for (let i2 = 0; i2 < points.length; ++i2) {
    center2.x += points[i2].x;
    center2.y += points[i2].y;
  }
  center2.x /= points.length;
  center2.y /= points.length;
  return center2;
}

// node_modules/@antv/g2/esm/data/utils/venn/layout.js
function venn(areas, parameters) {
  parameters = parameters || {};
  parameters.maxIterations = parameters.maxIterations || 500;
  const initialLayout = parameters.initialLayout || bestInitialLayout;
  const loss = parameters.lossFunction || lossFunction;
  areas = addMissingAreas(areas);
  const circles = initialLayout(areas, parameters);
  const initial = [], setids = [];
  let setid;
  for (setid in circles) {
    if (circles.hasOwnProperty(setid)) {
      initial.push(circles[setid].x);
      initial.push(circles[setid].y);
      setids.push(setid);
    }
  }
  const solution = nelderMead(function(values4) {
    const current = {};
    for (let i2 = 0; i2 < setids.length; ++i2) {
      const setid2 = setids[i2];
      current[setid2] = {
        x: values4[2 * i2],
        y: values4[2 * i2 + 1],
        radius: circles[setid2].radius
      };
    }
    return loss(current, areas);
  }, initial, parameters);
  const positions = solution.x;
  for (let i2 = 0; i2 < setids.length; ++i2) {
    setid = setids[i2];
    circles[setid].x = positions[2 * i2];
    circles[setid].y = positions[2 * i2 + 1];
  }
  return circles;
}
var SMALL2 = 1e-10;
function distanceFromIntersectArea(r1, r2, overlap) {
  if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + SMALL2) {
    return Math.abs(r1 - r2);
  }
  return bisect3(function(distance2) {
    return circleOverlap(r1, r2, distance2) - overlap;
  }, 0, r1 + r2);
}
function addMissingAreas(areas) {
  areas = areas.slice();
  const ids = [], pairs2 = {};
  let i2, j, a4, b;
  for (i2 = 0; i2 < areas.length; ++i2) {
    const area2 = areas[i2];
    if (area2.sets.length == 1) {
      ids.push(area2.sets[0]);
    } else if (area2.sets.length == 2) {
      a4 = area2.sets[0];
      b = area2.sets[1];
      pairs2[[a4, b]] = true;
      pairs2[[b, a4]] = true;
    }
  }
  ids.sort((a5, b2) => {
    return a5 > b2 ? 1 : -1;
  });
  for (i2 = 0; i2 < ids.length; ++i2) {
    a4 = ids[i2];
    for (j = i2 + 1; j < ids.length; ++j) {
      b = ids[j];
      if (!([a4, b] in pairs2)) {
        areas.push({ sets: [a4, b], size: 0 });
      }
    }
  }
  return areas;
}
function getDistanceMatrices(areas, sets, setids) {
  const distances = zerosM(sets.length, sets.length), constraints = zerosM(sets.length, sets.length);
  areas.filter(function(x2) {
    return x2.sets.length == 2;
  }).map(function(current) {
    const left2 = setids[current.sets[0]], right2 = setids[current.sets[1]], r1 = Math.sqrt(sets[left2].size / Math.PI), r2 = Math.sqrt(sets[right2].size / Math.PI), distance2 = distanceFromIntersectArea(r1, r2, current.size);
    distances[left2][right2] = distances[right2][left2] = distance2;
    let c5 = 0;
    if (current.size + 1e-10 >= Math.min(sets[left2].size, sets[right2].size)) {
      c5 = 1;
    } else if (current.size <= 1e-10) {
      c5 = -1;
    }
    constraints[left2][right2] = constraints[right2][left2] = c5;
  });
  return { distances, constraints };
}
function constrainedMDSGradient(x2, fxprime, distances, constraints) {
  let loss = 0, i2;
  for (i2 = 0; i2 < fxprime.length; ++i2) {
    fxprime[i2] = 0;
  }
  for (i2 = 0; i2 < distances.length; ++i2) {
    const xi = x2[2 * i2], yi = x2[2 * i2 + 1];
    for (let j = i2 + 1; j < distances.length; ++j) {
      const xj = x2[2 * j], yj = x2[2 * j + 1], dij = distances[i2][j], constraint = constraints[i2][j];
      const squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi), distance2 = Math.sqrt(squaredDistance), delta = squaredDistance - dij * dij;
      if (constraint > 0 && distance2 <= dij || constraint < 0 && distance2 >= dij) {
        continue;
      }
      loss += 2 * delta * delta;
      fxprime[2 * i2] += 4 * delta * (xi - xj);
      fxprime[2 * i2 + 1] += 4 * delta * (yi - yj);
      fxprime[2 * j] += 4 * delta * (xj - xi);
      fxprime[2 * j + 1] += 4 * delta * (yj - yi);
    }
  }
  return loss;
}
function bestInitialLayout(areas, params) {
  let initial = greedyLayout(areas, params);
  const loss = params.lossFunction || lossFunction;
  if (areas.length >= 8) {
    const constrained = constrainedMDSLayout(areas, params), constrainedLoss = loss(constrained, areas), greedyLoss = loss(initial, areas);
    if (constrainedLoss + 1e-8 < greedyLoss) {
      initial = constrained;
    }
  }
  return initial;
}
function constrainedMDSLayout(areas, params) {
  params = params || {};
  const restarts = params.restarts || 10;
  const sets = [], setids = {};
  let i2;
  for (i2 = 0; i2 < areas.length; ++i2) {
    const area2 = areas[i2];
    if (area2.sets.length == 1) {
      setids[area2.sets[0]] = sets.length;
      sets.push(area2);
    }
  }
  const matrices = getDistanceMatrices(areas, sets, setids);
  let distances = matrices.distances;
  const constraints = matrices.constraints;
  const norm = norm2(distances.map(norm2)) / distances.length;
  distances = distances.map(function(row) {
    return row.map(function(value2) {
      return value2 / norm;
    });
  });
  const obj = function(x2, fxprime) {
    return constrainedMDSGradient(x2, fxprime, distances, constraints);
  };
  let best, current;
  for (i2 = 0; i2 < restarts; ++i2) {
    const initial = zeros(distances.length * 2).map(Math.random);
    current = conjugateGradient(obj, initial, params);
    if (!best || current.fx < best.fx) {
      best = current;
    }
  }
  const positions = best.x;
  const circles = {};
  for (i2 = 0; i2 < sets.length; ++i2) {
    const set3 = sets[i2];
    circles[set3.sets[0]] = {
      x: positions[2 * i2] * norm,
      y: positions[2 * i2 + 1] * norm,
      radius: Math.sqrt(set3.size / Math.PI)
    };
  }
  if (params.history) {
    for (i2 = 0; i2 < params.history.length; ++i2) {
      scale2(params.history[i2].x, norm);
    }
  }
  return circles;
}
function greedyLayout(areas, params) {
  const loss = params && params.lossFunction ? params.lossFunction : lossFunction;
  const circles = {}, setOverlaps = {};
  let set3;
  for (let i2 = 0; i2 < areas.length; ++i2) {
    const area2 = areas[i2];
    if (area2.sets.length == 1) {
      set3 = area2.sets[0];
      circles[set3] = {
        x: 1e10,
        y: 1e10,
        // rowid: circles.length, // fix to ->
        rowid: Object.keys(circles).length,
        size: area2.size,
        radius: Math.sqrt(area2.size / Math.PI)
      };
      setOverlaps[set3] = [];
    }
  }
  areas = areas.filter(function(a4) {
    return a4.sets.length == 2;
  });
  for (let i2 = 0; i2 < areas.length; ++i2) {
    const current = areas[i2];
    let weight2 = current.hasOwnProperty("weight") ? current.weight : 1;
    const left2 = current.sets[0], right2 = current.sets[1];
    if (current.size + SMALL2 >= Math.min(circles[left2].size, circles[right2].size)) {
      weight2 = 0;
    }
    setOverlaps[left2].push({ set: right2, size: current.size, weight: weight2 });
    setOverlaps[right2].push({ set: left2, size: current.size, weight: weight2 });
  }
  const mostOverlapped = [];
  for (set3 in setOverlaps) {
    if (setOverlaps.hasOwnProperty(set3)) {
      let size4 = 0;
      for (let i2 = 0; i2 < setOverlaps[set3].length; ++i2) {
        size4 += setOverlaps[set3][i2].size * setOverlaps[set3][i2].weight;
      }
      mostOverlapped.push({ set: set3, size: size4 });
    }
  }
  function sortOrder(a4, b) {
    return b.size - a4.size;
  }
  mostOverlapped.sort(sortOrder);
  const positioned = {};
  function isPositioned(element) {
    return element.set in positioned;
  }
  function positionSet(point6, index2) {
    circles[index2].x = point6.x;
    circles[index2].y = point6.y;
    positioned[index2] = true;
  }
  positionSet({ x: 0, y: 0 }, mostOverlapped[0].set);
  for (let i2 = 1; i2 < mostOverlapped.length; ++i2) {
    const setIndex = mostOverlapped[i2].set, overlap = setOverlaps[setIndex].filter(isPositioned);
    set3 = circles[setIndex];
    overlap.sort(sortOrder);
    if (overlap.length === 0) {
      throw "ERROR: missing pairwise overlap information";
    }
    const points = [];
    for (let j = 0; j < overlap.length; ++j) {
      const p1 = circles[overlap[j].set], d1 = distanceFromIntersectArea(set3.radius, p1.radius, overlap[j].size);
      points.push({ x: p1.x + d1, y: p1.y });
      points.push({ x: p1.x - d1, y: p1.y });
      points.push({ y: p1.y + d1, x: p1.x });
      points.push({ y: p1.y - d1, x: p1.x });
      for (let k2 = j + 1; k2 < overlap.length; ++k2) {
        const p22 = circles[overlap[k2].set], d22 = distanceFromIntersectArea(set3.radius, p22.radius, overlap[k2].size);
        const extraPoints = circleCircleIntersection({ x: p1.x, y: p1.y, radius: d1 }, { x: p22.x, y: p22.y, radius: d22 });
        for (let l2 = 0; l2 < extraPoints.length; ++l2) {
          points.push(extraPoints[l2]);
        }
      }
    }
    let bestLoss = 1e50, bestPoint = points[0];
    for (let j = 0; j < points.length; ++j) {
      circles[setIndex].x = points[j].x;
      circles[setIndex].y = points[j].y;
      const localLoss = loss(circles, areas);
      if (localLoss < bestLoss) {
        bestLoss = localLoss;
        bestPoint = points[j];
      }
    }
    positionSet(bestPoint, setIndex);
  }
  return circles;
}
function lossFunction(sets, overlaps) {
  let output = 0;
  function getCircles(indices) {
    return indices.map(function(i2) {
      return sets[i2];
    });
  }
  for (let i2 = 0; i2 < overlaps.length; ++i2) {
    const area2 = overlaps[i2];
    let overlap;
    if (area2.sets.length == 1) {
      continue;
    } else if (area2.sets.length == 2) {
      const left2 = sets[area2.sets[0]], right2 = sets[area2.sets[1]];
      overlap = circleOverlap(left2.radius, right2.radius, distance(left2, right2));
    } else {
      overlap = intersectionArea(getCircles(area2.sets));
    }
    const weight2 = area2.hasOwnProperty("weight") ? area2.weight : 1;
    output += weight2 * (overlap - area2.size) * (overlap - area2.size);
  }
  return output;
}
function getBoundingBox(circles) {
  const minMax = function(d3) {
    const hi = Math.max.apply(null, circles.map(function(c5) {
      return c5[d3] + c5.radius;
    })), lo = Math.min.apply(null, circles.map(function(c5) {
      return c5[d3] - c5.radius;
    }));
    return { max: hi, min: lo };
  };
  return { xRange: minMax("x"), yRange: minMax("y") };
}
function scaleSolution(solution, width, height, padding) {
  const circles = [], setids = [];
  for (const setid in solution) {
    if (solution.hasOwnProperty(setid)) {
      setids.push(setid);
      circles.push(solution[setid]);
    }
  }
  width -= 2 * padding;
  height -= 2 * padding;
  const bounds = getBoundingBox(circles), xRange = bounds.xRange, yRange = bounds.yRange;
  if (xRange.max == xRange.min || yRange.max == yRange.min) {
    console.log("not scaling solution: zero size detected");
    return solution;
  }
  const xScaling = width / (xRange.max - xRange.min), yScaling = height / (yRange.max - yRange.min), scaling = Math.min(yScaling, xScaling), xOffset = (width - (xRange.max - xRange.min) * scaling) / 2, yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;
  const scaled = {};
  for (let i2 = 0; i2 < circles.length; ++i2) {
    const circle2 = circles[i2];
    scaled[setids[i2]] = {
      radius: scaling * circle2.radius,
      x: padding + xOffset + (circle2.x - xRange.min) * scaling,
      y: padding + yOffset + (circle2.y - yRange.min) * scaling
    };
  }
  return scaled;
}

// node_modules/@antv/g2/esm/data/utils/venn/diagram.js
function circlePath(x2, y3, r2) {
  const ret = [];
  const x05 = x2 - r2;
  const y05 = y3;
  ret.push("M", x05, y05);
  ret.push("A", r2, r2, 0, 1, 0, x05 + 2 * r2, y05);
  ret.push("A", r2, r2, 0, 1, 0, x05, y05);
  return ret.join(" ");
}
function intersectionAreaPath(circles) {
  const stats = {};
  intersectionArea(circles, stats);
  const arcs = stats.arcs;
  if (arcs.length === 0) {
    return "M 0 0";
  } else if (arcs.length == 1) {
    const circle2 = arcs[0].circle;
    return circlePath(circle2.x, circle2.y, circle2.radius);
  } else {
    const ret = ["\nM", arcs[0].p2.x, arcs[0].p2.y];
    for (let i2 = 0; i2 < arcs.length; ++i2) {
      const arc = arcs[i2], r2 = arc.circle.radius, wide = arc.width > r2;
      ret.push("\nA", r2, r2, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y);
    }
    return ret.join(" ");
  }
}

// node_modules/@antv/g2/esm/data/venn.js
var Venn = (options) => {
  const { sets = "sets", size: size4 = "size", as = ["key", "path"], padding = 0 } = options;
  const [key, path2] = as;
  return (data) => {
    const vennData = data.map((d3) => Object.assign(Object.assign({}, d3), { sets: d3[sets], size: d3[size4], [key]: d3.sets.join("&") }));
    vennData.sort((a4, b) => a4.sets.length - b.sets.length);
    const solution = venn(vennData);
    let circles;
    return vennData.map((datum) => {
      const setsValue = datum[sets];
      const pathFunc = ({ width, height }) => {
        circles = circles ? circles : scaleSolution(solution, width, height, padding);
        const setCircles = setsValue.map((set3) => circles[set3]);
        let p3 = intersectionAreaPath(setCircles);
        if (!/[zZ]$/.test(p3))
          p3 += " Z";
        return p3;
      };
      return Object.assign(Object.assign({}, datum), { [path2]: pathFunc });
    });
  };
};
Venn.props = {};

// node_modules/@antv/g2/esm/data/log.js
var Log4 = () => {
  return (data) => {
    console.log("G2 data section:", data);
    return data;
  };
};
Log4.props = {};

// node_modules/@antv/g2/esm/data/ema.js
function ema(values4, alpha) {
  if (alpha < 0 || alpha > 1) {
    throw new Error("alpha must be between 0 and 1.");
  }
  if (values4.length === 0) {
    return [];
  }
  let last6 = values4[0];
  const smoothed = [];
  for (const point6 of values4) {
    if (point6 === null || point6 === void 0) {
      smoothed.push(point6);
      console.warn("EMAThe value is null or undefined", values4);
      continue;
    }
    if (last6 === null || last6 === void 0) {
      last6 = point6;
    }
    const smoothedVal = last6 * alpha + (1 - alpha) * point6;
    smoothed.push(smoothedVal);
    last6 = smoothedVal;
  }
  return smoothed;
}
var EMA = (options) => {
  const { field: field3 = "y", alpha = 0.6, as = field3 } = options;
  return (data) => {
    const values4 = data.map((d3) => {
      return d3[field3];
    });
    const out = ema(values4, alpha);
    return data.map((d3, i2) => {
      return Object.assign(Object.assign({}, d3), { [as]: out[i2] });
    });
  };
};
EMA.props = {};

// node_modules/@antv/g2/esm/utils/bounds.js
var EPSILON = 0.01;
function parseAABB(min22) {
  const { min: min6, max: max7 } = min22;
  return [
    [min6[0], min6[1]],
    [max7[0], max7[1]]
  ];
}
function isInBounds(point6, bounds, threshold = EPSILON) {
  const [x2, y3] = point6;
  const [min6, max7] = bounds;
  return x2 >= min6[0] - threshold && x2 <= max7[0] + threshold && y3 >= min6[1] - threshold && y3 <= max7[1] + threshold;
}
function isOverflow(b1, b2, threshold = EPSILON) {
  const [min6, max7] = b1;
  return !(isInBounds(min6, b2, threshold) && isInBounds(max7, b2, threshold));
}
function isOverlap(b1, b2) {
  const [min1, max1] = b1;
  const [min22, max22] = b2;
  return min1[0] < max22[0] && max1[0] > min22[0] && min1[1] < max22[1] && max1[1] > min22[1];
}

// node_modules/@antv/g2/esm/label-transform/overlapHide.js
var OverlapHide = (options) => {
  const { priority } = options;
  return (labels) => {
    const displayLabels = [];
    if (priority)
      labels.sort(priority);
    labels.forEach((l2) => {
      show(l2);
      const b1 = l2.getLocalBounds();
      const overlaping = displayLabels.some((dl) => isOverlap(parseAABB(b1), parseAABB(dl.getLocalBounds())));
      if (overlaping)
        hide(l2);
      else
        displayLabels.push(l2);
    });
    return labels;
  };
};

// node_modules/@antv/g2/esm/label-transform/overlapDodgeY.js
function isSegmentIntersect([a4, b], [c5, d3]) {
  return d3 > a4 && b > c5;
}
function useMap() {
  const map5 = /* @__PURE__ */ new Map();
  const get3 = (key) => map5.get(key);
  const set3 = (key, value2) => map5.set(key, value2);
  return [get3, set3];
}
function getBoundsWithoutConnector(shape24) {
  const node = shape24.cloneNode(true);
  const connectorShape = node.getElementById("connector");
  connectorShape && node.removeChild(connectorShape);
  const { min: min6, max: max7 } = node.getRenderBounds();
  node.destroy();
  return { min: min6, max: max7 };
}
var OverlapDodgeY = (options) => {
  const { maxIterations = 10, maxError = 0.1, padding = 1 } = options;
  return (labels) => {
    const n2 = labels.length;
    if (n2 <= 1)
      return labels;
    const [y05, setY0] = useMap();
    const [y3, setY] = useMap();
    const [h2, setH] = useMap();
    const [xx, setXX] = useMap();
    for (const label of labels) {
      const { min: min6, max: max7 } = getBoundsWithoutConnector(label);
      const [x05, y06] = min6;
      const [x12, y12] = max7;
      setY0(label, y06);
      setY(label, y06);
      setH(label, y12 - y06);
      setXX(label, [x05, x12]);
    }
    for (let iter = 0; iter < maxIterations; iter++) {
      labels.sort((a4, b) => ascending(y3(a4), y3(b)));
      let error2 = 0;
      for (let i2 = 0; i2 < n2 - 1; i2++) {
        const l0 = labels[i2];
        let j = i2 + 1;
        let l1;
        while ((l1 = labels[j]) && !isSegmentIntersect(xx(l0), xx(l1)))
          j += 1;
        if (l1) {
          const y06 = y3(l0);
          const h0 = h2(l0);
          const y12 = y3(l1);
          const delta = y12 - (y06 + h0);
          if (delta < padding) {
            const newDelta = (padding - delta) / 2;
            error2 = Math.max(error2, newDelta);
            setY(l0, y06 - newDelta);
            setY(l1, y12 + newDelta);
          }
        }
      }
      if (error2 < maxError)
        break;
    }
    for (const label of labels) {
      label.style.y += y3(label) - y05(label);
    }
    return labels;
  };
};

// node_modules/@antv/g2/esm/utils/color.js
function parseToRGB(c5) {
  if (typeof c5 === "object")
    return c5;
  return parseColor(c5);
}

// node_modules/@antv/g2/esm/label-transform/utils.js
function getsRGB(s3) {
  let c5 = s3 / 255;
  c5 = c5 <= 0.03928 ? c5 / 12.92 : Math.pow((c5 + 0.055) / 1.055, 2.4);
  return c5;
}
function getL(r2, g, b) {
  return 0.2126 * getsRGB(r2) + 0.7152 * getsRGB(g) + 0.0722 * getsRGB(b);
}
function contrast(foreground, background) {
  if (!foreground || !background || foreground === background)
    return 1;
  const { r: r2, g, b } = foreground;
  const { r: rb, g: gb, b: bb } = background;
  const L1 = getL(r2, g, b);
  const L2 = getL(rb, gb, bb);
  return (Math.max(L1, L2) + 0.05) / (Math.min(L1, L2) + 0.05);
}
function mostContrast(color, palette) {
  const i2 = maxIndex(palette, (c5) => contrast(color, parseToRGB(c5)));
  return palette[i2];
}

// node_modules/@antv/g2/esm/label-transform/contrastReverse.js
var ContrastReverse = (options) => {
  const { threshold = 4.5, palette = ["#000", "#fff"] } = options;
  return (labels) => {
    labels.forEach((l2) => {
      const background = l2.attr("dependentElement").parsedStyle.fill;
      const foreground = l2.parsedStyle.fill;
      const c5 = contrast(foreground, background);
      if (c5 < threshold)
        l2.attr("fill", mostContrast(background, palette));
    });
    return labels;
  };
};

// node_modules/@antv/g2/esm/label-transform/overflowHide.js
var OverflowHide = () => {
  return (labels) => {
    labels.forEach((l2) => {
      show(l2);
      const bounds = l2.attr("bounds");
      const b = l2.getLocalBounds();
      const overflow = isOverflow(parseAABB(b), bounds);
      if (overflow)
        hide(l2);
    });
    return labels;
  };
};

// node_modules/@antv/g2/esm/label-transform/exceedAdjust.js
var adjustPosition = (target, edge) => {
  const [[minEdgeX, minEdgeY], [maxEdgeX, maxEdgeY]] = edge;
  const [[minX, minY], [maxX, maxY2]] = target;
  let changeX = 0, changeY = 0;
  if (minX < minEdgeX) {
    changeX = minEdgeX - minX;
  } else if (maxX > maxEdgeX) {
    changeX = maxEdgeX - maxX;
  }
  if (minY < minEdgeY) {
    changeY = minEdgeY - minY;
  } else if (maxY2 > maxEdgeY) {
    changeY = maxEdgeY - maxY2;
  }
  return [changeX, changeY];
};
var union2 = (a4, b) => {
  if (!a4 || !a4.min || !a4.max) {
    if (!b || !b.min || !b.max) {
      return { min: [0, 0], max: [0, 0] };
    }
    return b;
  }
  if (!b || !b.min || !b.max) {
    return a4;
  }
  return {
    min: [Math.min(a4.min[0], b.min[0]), Math.min(a4.min[1], b.min[1])],
    max: [Math.max(a4.max[0], b.max[0]), Math.max(a4.max[1], b.max[1])]
  };
};
var ExceedAdjust = (options = {}) => {
  return (labels, { canvas, layout }) => {
    const { bounds = "view", offsetX = 0, offsetY = 0 } = options;
    const getBoundaryArea = () => {
      if (bounds === "main") {
        const { x: x2 = 0, y: y3 = 0, width = 0, height = 0, marginLeft = 0, marginRight = 0, marginTop = 0, marginBottom = 0, paddingLeft = 0, paddingRight = 0, paddingTop = 0, paddingBottom = 0 } = layout;
        return [
          [
            x2 + marginLeft + paddingLeft + offsetX,
            y3 + marginTop + paddingTop + offsetY
          ],
          [
            x2 + width - marginRight - paddingRight - offsetX,
            y3 + height - marginBottom - paddingBottom - offsetY
          ]
        ];
      } else {
        const { x: x2 = 0, y: y3 = 0, width = 0, height = 0 } = layout;
        return [
          [x2 + offsetX, y3 + offsetY],
          [x2 + width - offsetX, y3 + height - offsetY]
        ];
      }
    };
    const boundaryArea = getBoundaryArea();
    labels.forEach((l2) => {
      show(l2);
      const { max: max7, min: min6 } = union2(l2.getRenderBounds(), l2.getBounds());
      if (!max7 || !min6 || max7[0] === 0 && max7[1] === 0 && min6[0] === 0 && min6[1] === 0) {
        return;
      }
      const [xMax, yMax] = max7, [xMin, yMin] = min6;
      const changeValue = adjustPosition(
        [
          [xMin, yMin],
          [xMax, yMax]
        ],
        // Use the calculated boundary area based on bounds configuration
        boundaryArea
      );
      if (l2.style.connector && l2.style.connectorPoints) {
        l2.style.connectorPoints[0][0] -= changeValue[0];
        l2.style.connectorPoints[0][1] -= changeValue[1];
      }
      l2.style.x += changeValue[0];
      l2.style.y += changeValue[1];
    });
    return labels;
  };
};

// node_modules/@antv/g2/esm/label-transform/overflowStroke.js
function getBoundsWithAnimation(element) {
  var _a;
  const animations = element.getAnimations();
  if (!animations || animations.length === 0) {
    return bboxOf(element);
  }
  const cloneElement = element.cloneNode(true);
  cloneElement.style.visibility = "hidden";
  animations.forEach((animation) => {
    const keyframes = animation.effect.getKeyframes();
    if (keyframes && keyframes.length > 0) {
      cloneElement.attr(keyframes[keyframes.length - 1]);
    }
  });
  (_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.appendChild(cloneElement);
  const bounds = bboxOf(cloneElement);
  cloneElement.destroy();
  return bounds;
}
var OverflowStroke = (options) => {
  const { palette = ["#000", "#fff"], threshold = 2 } = options;
  return (labels) => {
    labels.forEach((l2) => {
      var _a, _b;
      const dependentElement = l2.attr("dependentElement");
      const labelFill = (_b = (_a = l2.attributes.fill) !== null && _a !== void 0 ? _a : l2.parsedStyle.fill) !== null && _b !== void 0 ? _b : "#fff";
      const textBounds = parseAABB(getBoundsWithAnimation(l2));
      const elementBounds = parseAABB(getBoundsWithAnimation(dependentElement));
      if (isOverflow(textBounds, elementBounds, threshold)) {
        const strokeColor = mostContrast(parseToRGB(labelFill), palette);
        l2.attr("stroke", strokeColor);
      } else {
        l2.removeAttribute("stroke");
      }
    });
    return labels;
  };
};

// node_modules/@antv/g2/esm/lib/core.js
function corelib() {
  return {
    "data.fetch": Fetch,
    "data.inline": Inline,
    "data.sortBy": SortBy,
    "data.sort": Sort2,
    "data.filter": Filter2,
    "data.pick": Pick,
    "data.rename": Rename,
    "data.fold": Fold,
    "data.slice": Slice,
    "data.custom": Custom,
    "data.map": Map2,
    "data.join": Join,
    "data.kde": KDE,
    "data.log": Log4,
    "data.wordCloud": WordCloud2,
    "data.ema": EMA,
    "transform.stackY": StackY,
    "transform.binX": BinX,
    "transform.bin": Bin,
    "transform.dodgeX": DodgeX,
    "transform.jitter": Jitter,
    "transform.jitterX": JitterX,
    "transform.jitterY": JitterY,
    "transform.symmetryY": SymmetryY,
    "transform.diffY": DiffY,
    "transform.stackEnter": StackEnter,
    "transform.normalizeY": NormalizeY,
    "transform.select": Select,
    "transform.selectX": SelectX,
    "transform.selectY": SelectY,
    "transform.groupX": GroupX,
    "transform.groupY": GroupY,
    "transform.groupColor": GroupColor,
    "transform.group": Group2,
    "transform.sortX": SortX,
    "transform.sortY": SortY,
    "transform.sortColor": SortColor,
    "transform.flexX": FlexX,
    "transform.pack": Pack,
    "transform.sample": Sample,
    "transform.filter": Filter,
    "coordinate.cartesian": Cartesian,
    "coordinate.polar": Polar,
    "coordinate.transpose": Transpose,
    "coordinate.theta": Theta,
    "coordinate.parallel": Parallel,
    "coordinate.fisheye": Fisheye,
    "coordinate.radial": Radial,
    "coordinate.radar": Radar,
    "coordinate.helix": Helix,
    "encode.constant": Constant,
    "encode.field": Field,
    "encode.transform": Transform,
    "encode.column": Column,
    "mark.interval": Interval,
    "mark.rect": Rect3,
    "mark.line": Line5,
    "mark.point": Point3,
    "mark.text": Text3,
    "mark.cell": Cell,
    "mark.area": Area2,
    "mark.link": Link2,
    "mark.image": Image4,
    "mark.polygon": Polygon3,
    "mark.box": Box2,
    "mark.vector": Vector2,
    "mark.lineX": LineX,
    "mark.lineY": LineY,
    "mark.connector": Connector2,
    "mark.range": Range,
    "mark.rangeX": RangeX,
    "mark.rangeY": RangeY,
    "mark.path": Path4,
    "mark.shape": Shape3,
    "mark.density": Density2,
    "mark.heatmap": Heatmap2,
    "mark.wordCloud": WordCloud,
    "mark.beeswarm": Beeswarm,
    "palette.category10": Category10,
    "palette.category20": Category20,
    "scale.linear": Linear3,
    "scale.ordinal": Ordinal2,
    "scale.band": Band2,
    "scale.identity": Identity2,
    "scale.point": Point4,
    "scale.time": Time2,
    "scale.log": Log2,
    "scale.pow": Pow2,
    "scale.sqrt": Sqrt2,
    "scale.threshold": Threshold2,
    "scale.quantile": Quantile2,
    "scale.quantize": Quantize2,
    "scale.sequential": Sequential3,
    "scale.constant": Constant3,
    "theme.classic": Classic,
    "theme.classicDark": ClassicDark,
    "theme.academy": Academy,
    "theme.light": Light,
    "theme.dark": Dark,
    "component.axisX": AxisX,
    "component.axisY": AxisY,
    "component.legendCategory": LegendCategory,
    "component.legendContinuous": LegendContinuous,
    "component.legends": Legends,
    "component.title": TitleComponent,
    "component.sliderX": SliderX,
    "component.sliderY": SliderY,
    "component.scrollbarX": ScrollbarX,
    "component.scrollbarY": ScrollbarY,
    "animation.scaleInX": ScaleInX,
    "animation.scaleOutX": ScaleOutX,
    "animation.scaleInY": ScaleInY,
    "animation.scaleOutY": ScaleOutY,
    "animation.waveIn": WaveIn,
    "animation.fadeIn": FadeIn,
    "animation.fadeOut": FadeOut,
    "animation.zoomIn": ZoomIn,
    "animation.zoomOut": ZoomOut,
    "animation.pathIn": PathIn,
    "animation.morphing": Morphing,
    "animation.growInX": GrowInX,
    "animation.growInY": GrowInY,
    "interaction.elementHighlight": ElementHighlight,
    "interaction.elementHighlightByX": ElementHighlightByX,
    "interaction.elementHighlightByColor": ElementHighlightByColor,
    "interaction.elementHoverScale": ElementHoverScale,
    "interaction.elementSelect": ElementSelect,
    "interaction.elementSelectByX": ElementSelectByX,
    "interaction.elementSelectByColor": ElementSelectByColor,
    "interaction.fisheye": Fisheye2,
    "interaction.chartIndex": ChartIndex,
    "interaction.tooltip": Tooltip2,
    "interaction.legendFilter": LegendFilter,
    "interaction.legendHighlight": LegendHighlight,
    "interaction.brushHighlight": BrushHighlight,
    "interaction.brushXHighlight": BrushXHighlight,
    "interaction.brushYHighlight": BrushYHighlight,
    "interaction.brushAxisHighlight": BrushAxisHighlight,
    "interaction.brushFilter": BrushFilter,
    "interaction.brushXFilter": BrushXFilter,
    "interaction.brushYFilter": BrushYFilter,
    "interaction.sliderFilter": SliderFilter,
    "interaction.sliderWheel": SliderWheel,
    "interaction.scrollbarFilter": ScrollbarFilter,
    "interaction.poptip": Poptip,
    "interaction.treemapDrillDown": TreemapDrillDown,
    "interaction.drillDown": DrillDown,
    "interaction.elementPointMove": ElementPointMove,
    "composition.spaceLayer": SpaceLayer,
    "composition.spaceFlex": SpaceFlex,
    "composition.facetRect": FacetRect,
    "composition.repeatMatrix": RepeatMatrix,
    "composition.facetCircle": FacetCircle,
    "composition.timingKeyframe": TimingKeyframe,
    "labelTransform.overlapHide": OverlapHide,
    "labelTransform.overlapDodgeY": OverlapDodgeY,
    "labelTransform.overflowHide": OverflowHide,
    "labelTransform.contrastReverse": ContrastReverse,
    "labelTransform.overflowStroke": OverflowStroke,
    "labelTransform.exceedAdjust": ExceedAdjust
  };
}

// node_modules/@antv/g2/esm/lib/geo.js
function geolib() {
  return {
    "composition.geoView": GeoView,
    "composition.geoPath": GeoPath
  };
}

// node_modules/@antv/g2/esm/lib/graph.js
function graphlib() {
  return {
    "data.arc": Arc3,
    "data.cluster": Cluster,
    "mark.forceGraph": ForceGraph,
    "mark.tree": Tree2,
    "mark.pack": Pack2,
    "mark.sankey": Sankey3,
    "mark.chord": Chord,
    "mark.treemap": Treemap,
    "mark.partition": Partition
  };
}

// node_modules/@antv/g2/esm/lib/plot.js
function plotlib() {
  return {
    "data.venn": Venn,
    "mark.boxplot": Boxplot,
    "mark.gauge": Gauge,
    "mark.wordCloud": WordCloud,
    "mark.liquid": Liquid2
  };
}

// node_modules/@antv/g2/esm/lib/std.js
function stdlib() {
  return Object.assign(Object.assign(Object.assign(Object.assign({}, geolib()), graphlib()), plotlib()), corelib());
}

// node_modules/@antv/g2/esm/lib/lite.js
function litelib() {
  return {
    "data.inline": Inline,
    "coordinate.cartesian": Cartesian,
    "encode.constant": Constant,
    "encode.field": Field,
    "encode.transform": Transform,
    "encode.column": Column,
    "mark.interval": Interval,
    "shape.label.label": Label,
    "palette.category10": Category10,
    "palette.category20": Category20,
    "scale.linear": Linear3,
    "scale.ordinal": Ordinal2,
    "scale.band": Band2,
    "scale.identity": Identity2,
    "scale.point": Point4,
    "scale.time": Time2,
    "scale.log": Log2,
    "scale.pow": Pow2,
    "scale.sqrt": Sqrt2,
    "scale.threshold": Threshold2,
    "scale.quantile": Quantile2,
    "scale.quantize": Quantize2,
    "scale.sequential": Sequential3,
    "scale.constant": Constant3,
    "theme.classic": Classic,
    "component.axisX": AxisX,
    "component.axisY": AxisY,
    "component.axisRadar": AxisRadar,
    "component.axisLinear": LinearAxis,
    "component.axisArc": ArcAxis,
    "component.legendCategory": LegendCategory,
    "component.legendContinuous": LegendContinuous,
    "component.legendContinuousBlock": LegendContinuousBlock,
    "component.legendContinuousBlockSize": LegendContinuousBlockSize,
    "component.legendContinuousSize": LegendContinuousSize,
    "component.legends": Legends,
    "component.title": TitleComponent,
    "component.sliderX": SliderX,
    "component.sliderY": SliderY,
    "component.scrollbarX": ScrollbarX,
    "component.scrollbarY": ScrollbarY,
    "animation.scaleInX": ScaleInX,
    "animation.scaleOutX": ScaleOutX,
    "animation.scaleInY": ScaleInY,
    "animation.scaleOutY": ScaleOutY,
    "animation.waveIn": WaveIn,
    "animation.fadeIn": FadeIn,
    "animation.fadeOut": FadeOut,
    "animation.morphing": Morphing,
    "interaction.tooltip": Tooltip2,
    "interaction.legendFilter": LegendFilter,
    "interaction.legendHighlight": LegendHighlight,
    "interaction.sliderFilter": SliderFilter,
    "interaction.scrollbarFilter": ScrollbarFilter,
    "interaction.poptip": Poptip,
    "interaction.event": Event,
    "composition.mark": Mark,
    "composition.view": View
  };
}

// node_modules/@antv/g2/esm/api/extend.js
function extend3(Runtime2, library3) {
  class Chart4 extends Runtime2 {
    constructor(options) {
      super(Object.assign(Object.assign({}, options), { lib: library3 }));
    }
  }
  return Chart4;
}

// node_modules/@antv/g2/esm/api/library.js
var library = {};
function register(key, component) {
  if (key.startsWith("symbol."))
    registerSymbol(key.split(".").pop(), component);
  else
    Object.assign(library, { [key]: component });
}

// node_modules/@antv/g2/esm/utils/size.js
var parseInt10 = (d3) => d3 ? parseInt(d3) : 0;
function getContainerSize(container) {
  const style = getComputedStyle(container);
  const wrapperWidth = container.clientWidth || parseInt10(style.width);
  const wrapperHeight = container.clientHeight || parseInt10(style.height);
  const widthPadding = parseInt10(style.paddingLeft) + parseInt10(style.paddingRight);
  const heightPadding = parseInt10(style.paddingTop) + parseInt10(style.paddingBottom);
  return {
    width: wrapperWidth - widthPadding,
    height: wrapperHeight - heightPadding
  };
}

// node_modules/@antv/g2/esm/api/node.js
function bfs(node, callback) {
  const discovered = [node];
  while (discovered.length) {
    const currentNode = discovered.shift();
    callback && callback(currentNode);
    const children = currentNode.children || [];
    for (const child of children) {
      discovered.push(child);
    }
  }
}
var Node3 = class {
  constructor(value2 = {}, type) {
    this.parentNode = null;
    this.children = [];
    this.index = 0;
    this.type = type;
    this.value = value2;
  }
  /**
   * Apply specified transform to current value. Mount the node
   * to replace the original one in the tree and then return it.
   */
  map(transform2 = (x2) => x2) {
    const newValue = transform2(this.value);
    this.value = newValue;
    return this;
  }
  /**
   * Set or get the specified attribute. It the value is specified, update
   * the attribute of current value and return the node. Otherwise
   * return the the attribute of current value.
   */
  attr(key, value2) {
    if (arguments.length === 1)
      return this.value[key];
    return this.map((v) => (v[key] = value2, v));
  }
  /**
   * Create a new node and append to children nodes.
   */
  append(Ctor) {
    const node = new Ctor({});
    node.children = [];
    this.push(node);
    return node;
  }
  push(node) {
    node.parentNode = this;
    node.index = this.children.length;
    this.children.push(node);
    return this;
  }
  /**
   * Remove current node from parentNode.
   */
  remove() {
    const parent = this.parentNode;
    if (parent) {
      const { children } = parent;
      const index2 = children.findIndex((item) => item === this);
      children.splice(index2, 1);
    }
    return this;
  }
  getNodeByKey(key) {
    let targetNode = null;
    const callback = (node) => {
      if (key === node.attr("key")) {
        targetNode = node;
      }
    };
    bfs(this, callback);
    return targetNode;
  }
  getNodesByType(type) {
    const nodes = [];
    const callback = (node) => {
      if (type === node.type) {
        nodes.push(node);
      }
    };
    bfs(this, callback);
    return nodes;
  }
  getNodeByType(type) {
    let node = null;
    bfs(this, (current) => {
      if (node)
        return;
      if (type === current.type)
        node = current;
    });
    return node;
  }
  /**
   * Apply specified callback to the node value.
   */
  call(callback, ...params) {
    callback(this.map(), ...params);
    return this;
  }
  getRoot() {
    let root = this;
    while (root && root.parentNode) {
      root = root.parentNode;
    }
    return root;
  }
};

// node_modules/@antv/g2/esm/api/utils.js
var __rest90 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var VIEW_KEYS = [
  "width",
  "height",
  "depth",
  "padding",
  "paddingLeft",
  "paddingRight",
  "paddingBottom",
  "paddingTop",
  "inset",
  "insetLeft",
  "insetRight",
  "insetTop",
  "insetBottom",
  "margin",
  "marginLeft",
  "marginRight",
  "marginTop",
  "marginBottom",
  "autoFit",
  "theme",
  "title",
  "interaction"
];
var REMOVE_FLAG = "__remove__";
var CALLBACK_NODE = "__callback__";
var MIN_CHART_WIDTH = 1;
var MIN_CHART_HEIGHT = 1;
function normalizeContainer2(container) {
  if (container === void 0) {
    const container2 = document.createElement("div");
    container2[REMOVE_FLAG] = true;
    return container2;
  }
  if (typeof container === "string") {
    const node = document.getElementById(container);
    return node;
  }
  return container;
}
function removeContainer(container) {
  const parent = container.parentNode;
  if (parent) {
    parent.removeChild(container);
  }
}
function normalizeRoot(node) {
  if (node.type !== null)
    return node;
  const root = node.children[node.children.length - 1];
  for (const key of VIEW_KEYS)
    root.attr(key, node.attr(key));
  return root;
}
function valueOf3(node) {
  return Object.assign(Object.assign({}, node.value), { type: node.type });
}
function sizeOf2(options, container) {
  const { width, height, autoFit, depth = 0 } = options;
  let effectiveWidth = 640;
  let effectiveHeight = 480;
  if (autoFit) {
    const { width: containerWidth, height: containerHeight } = getContainerSize(container);
    effectiveWidth = containerWidth || effectiveWidth;
    effectiveHeight = containerHeight || effectiveHeight;
  }
  effectiveWidth = width || effectiveWidth;
  effectiveHeight = height || effectiveHeight;
  return {
    width: Math.max(isNumber(effectiveWidth) ? effectiveWidth : MIN_CHART_WIDTH, MIN_CHART_WIDTH),
    height: Math.max(isNumber(effectiveHeight) ? effectiveHeight : MIN_CHART_HEIGHT, MIN_CHART_HEIGHT),
    depth
  };
}
function optionsOf(node) {
  const root = normalizeRoot(node);
  const discovered = [root];
  const nodeValue = /* @__PURE__ */ new Map();
  nodeValue.set(root, valueOf3(root));
  while (discovered.length) {
    const node2 = discovered.pop();
    const value2 = nodeValue.get(node2);
    const { children = [] } = node2;
    for (const child of children) {
      if (child.type === CALLBACK_NODE) {
        value2.children = child.value;
      } else {
        const childValue = valueOf3(child);
        const { children: children2 = [] } = value2;
        children2.push(childValue);
        discovered.push(child);
        nodeValue.set(child, childValue);
        value2.children = children2;
      }
    }
  }
  return nodeValue.get(root);
}
function isMark(type, mark2) {
  if (typeof type === "function")
    return true;
  return new Set(Object.keys(mark2)).has(type);
}
function isComposition(type, composition) {
  return typeof type !== "function" && new Set(Object.keys(composition)).has(type);
}
function normalizeRootOptions(node, options, previousType, marks, composition) {
  const { type: oldType } = node;
  const { type = previousType || oldType } = options;
  if (isComposition(type, composition)) {
    for (const key of VIEW_KEYS) {
      if (node.attr(key) !== void 0 && options[key] === void 0) {
        options[key] = node.attr(key);
      }
    }
    return options;
  }
  if (isMark(type, marks)) {
    const view = { type: "view" };
    const mark2 = Object.assign({}, options);
    for (const key of VIEW_KEYS) {
      if (mark2[key] !== void 0) {
        view[key] = mark2[key];
        delete mark2[key];
      }
    }
    return Object.assign(Object.assign({}, view), { children: [mark2] });
  }
  return options;
}
function typeCtor(type, mark2, composition) {
  if (typeof type === "function")
    return mark2.mark;
  const node = Object.assign(Object.assign({}, mark2), composition);
  const ctor = node[type];
  if (!ctor)
    throw new Error(`Unknown mark: ${type}.`);
  return ctor;
}
function createNode(options, mark2, composition) {
  if (typeof options === "function") {
    const node2 = new Node3();
    node2.value = options;
    node2.type = CALLBACK_NODE;
    return node2;
  }
  const { type, children } = options, value2 = __rest90(options, ["type", "children"]);
  const Ctor = typeCtor(type, mark2, composition);
  const node = new Ctor();
  node.value = value2;
  node.type = type;
  return node;
}
function updateNode(node, newOptions) {
  const { type, children } = newOptions, value2 = __rest90(newOptions, ["type", "children"]);
  if (node.type === type || type === void 0) {
    deepAssign(node.value, value2);
  } else if (typeof type === "string") {
    node.type = type;
    node.value = value2;
  }
}
function appendNode(parent, newOptions, mark2, composition) {
  if (!parent)
    return;
  const discovered = [[parent, newOptions]];
  while (discovered.length) {
    const [parent2, nodeOptions] = discovered.shift();
    const node = createNode(nodeOptions, mark2, composition);
    if (Array.isArray(parent2.children))
      parent2.push(node);
    const { children } = nodeOptions;
    if (Array.isArray(children)) {
      for (const child of children) {
        discovered.push([node, child]);
      }
    } else if (typeof children === "function") {
      discovered.push([node, children]);
    }
  }
}
function updateRoot(node, options, definedType, mark2, composition) {
  const rootOptions = normalizeRootOptions(node, options, definedType, mark2, composition);
  const discovered = [[null, node, rootOptions]];
  while (discovered.length) {
    const [parent, oldNode, newNode] = discovered.shift();
    if (!oldNode) {
      appendNode(parent, newNode, mark2, composition);
    } else if (!newNode) {
      oldNode.remove();
    } else {
      updateNode(oldNode, newNode);
      const { children: newChildren } = newNode;
      const { children: oldChildren } = oldNode;
      if (Array.isArray(newChildren) && Array.isArray(oldChildren)) {
        const n2 = Math.max(newChildren.length, oldChildren.length);
        for (let i2 = 0; i2 < n2; i2++) {
          const newChild = newChildren[i2];
          const oldChild = oldChildren[i2];
          discovered.push([oldNode, oldChild, newChild]);
        }
      } else if (typeof newChildren === "function") {
        discovered.push([oldNode, null, newChildren]);
      }
    }
  }
}
function createEmptyPromise() {
  let reject;
  let resolve;
  const cloned = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return [cloned, resolve, reject];
}

// node_modules/@antv/g2/esm/api/define.js
function defineValueProp(Node4, name2, { key = name2 }) {
  Node4.prototype[name2] = function(value2) {
    if (arguments.length === 0)
      return this.attr(key);
    return this.attr(key, value2);
  };
}
function defineArrayProp(Node4, name2, { key = name2 }) {
  Node4.prototype[name2] = function(value2) {
    if (arguments.length === 0)
      return this.attr(key);
    if (Array.isArray(value2))
      return this.attr(key, value2);
    const array2 = [...this.attr(key) || [], value2];
    return this.attr(key, array2);
  };
}
function defineObjectProp(Node4, name2, { key: k2 = name2 }) {
  Node4.prototype[name2] = function(key, value2) {
    if (arguments.length === 0)
      return this.attr(k2);
    if (arguments.length === 1 && typeof key !== "string") {
      return this.attr(k2, key);
    }
    const obj = this.attr(k2) || {};
    obj[key] = arguments.length === 1 ? true : value2;
    return this.attr(k2, obj);
  };
}
function defineMixProp(Node4, name2, descriptor) {
  Node4.prototype[name2] = function(key) {
    if (arguments.length === 0)
      return this.attr(name2);
    if (Array.isArray(key))
      return this.attr(name2, { items: key });
    if (isStrictObject(key) && (key.title !== void 0 || key.items !== void 0)) {
      return this.attr(name2, key);
    }
    if (key === null || key === false)
      return this.attr(name2, key);
    const obj = this.attr(name2) || {};
    const { items = [] } = obj;
    items.push(key);
    obj.items = items;
    return this.attr(name2, obj);
  };
}
function defineNodeProp(Node4, name2, { ctor }) {
  Node4.prototype[name2] = function(hocMark) {
    const node = this.append(ctor);
    if (name2 === "mark") {
      node.type = hocMark;
    }
    return node;
  };
}
function defineContainerProp(Node4, name2, { ctor }) {
  Node4.prototype[name2] = function() {
    this.type = null;
    return this.append(ctor);
  };
}
function defineProps(descriptors) {
  return (Node4) => {
    for (const [name2, descriptor] of Object.entries(descriptors)) {
      const { type } = descriptor;
      if (type === "value")
        defineValueProp(Node4, name2, descriptor);
      else if (type === "array")
        defineArrayProp(Node4, name2, descriptor);
      else if (type === "object")
        defineObjectProp(Node4, name2, descriptor);
      else if (type === "node")
        defineNodeProp(Node4, name2, descriptor);
      else if (type === "container")
        defineContainerProp(Node4, name2, descriptor);
      else if (type === "mix")
        defineMixProp(Node4, name2, descriptor);
    }
    return Node4;
  };
}
function nodeProps(node) {
  return Object.fromEntries(Object.entries(node).map(([name2, ctor]) => [name2, { type: "node", ctor }]));
}

// node_modules/@antv/g2/esm/api/props.js
var commonProps = {
  encode: { type: "object" },
  scale: { type: "object" },
  data: { type: "value" },
  transform: { type: "array" },
  style: { type: "object" },
  animate: { type: "object" },
  coordinate: { type: "object" },
  interaction: { type: "object" },
  label: { type: "array", key: "labels" },
  axis: { type: "object" },
  legend: { type: "object" },
  slider: { type: "object" },
  scrollbar: { type: "object" },
  state: { type: "object" },
  layout: { type: "object" },
  theme: { type: "object" },
  title: { type: "value" }
};
var markProps = Object.assign(Object.assign({}, commonProps), { tooltip: { type: "mix" }, viewStyle: { type: "object" } });
var compositionProps = Object.assign(Object.assign({}, commonProps), { labelTransform: { type: "array" } });

// node_modules/@antv/g2/esm/api/composition.js
var __decorate5 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r2 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r2 = (c5 < 3 ? d3(r2) : c5 > 3 ? d3(target, key, r2) : d3(target, key)) || r2;
  return c5 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var CompositionNode = class CompositionNode2 extends Node3 {
  /**
   * Change current node data and its children data.
   */
  changeData(data) {
    var _a;
    const chart = this.getRoot();
    if (!chart)
      return;
    this.attr("data", data);
    if ((_a = this.children) === null || _a === void 0 ? void 0 : _a.length) {
      this.children.forEach((child) => {
        child.attr("data", data);
      });
    }
    return chart === null || chart === void 0 ? void 0 : chart.render();
  }
  /**
   * Get view instance by key.
   */
  getView() {
    const chart = this.getRoot();
    const { views } = chart.getContext();
    if (!(views === null || views === void 0 ? void 0 : views.length))
      return void 0;
    return views.find((view) => view.key === this._key);
  }
  getScale() {
    var _a;
    return (_a = this.getView()) === null || _a === void 0 ? void 0 : _a.scale;
  }
  getScaleByChannel(channel) {
    const scale4 = this.getScale();
    if (scale4)
      return scale4[channel];
    return;
  }
  getCoordinate() {
    var _a;
    return (_a = this.getView()) === null || _a === void 0 ? void 0 : _a.coordinate;
  }
  getTheme() {
    var _a;
    return (_a = this.getView()) === null || _a === void 0 ? void 0 : _a.theme;
  }
  getGroup() {
    const key = this._key;
    if (!key)
      return void 0;
    const chart = this.getRoot();
    const chartGroup = chart.getContext().canvas.getRoot();
    return chartGroup.getElementById(key);
  }
  /**
   * Show the view.
   */
  show() {
    const group2 = this.getGroup();
    if (!group2)
      return;
    !group2.isVisible() && show(group2);
  }
  /**
   * Hide the view.
   */
  hide() {
    const group2 = this.getGroup();
    if (!group2)
      return;
    group2.isVisible() && hide(group2);
  }
};
CompositionNode = __decorate5([
  defineProps(compositionProps)
], CompositionNode);

// node_modules/@antv/g2/esm/api/mark.js
var __decorate6 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r2 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r2 = (c5 < 3 ? d3(r2) : c5 > 3 ? d3(target, key, r2) : d3(target, key)) || r2;
  return c5 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var MarkNode = class MarkNode2 extends Node3 {
  changeData(data) {
    const chart = this.getRoot();
    if (!chart)
      return;
    this.attr("data", data);
    return chart === null || chart === void 0 ? void 0 : chart.render();
  }
  /**
   * Get mark from chart views.
   */
  getMark() {
    var _a;
    const chartView = (_a = this.getRoot()) === null || _a === void 0 ? void 0 : _a.getView();
    if (!chartView)
      return void 0;
    const { markState } = chartView;
    const markKey = Array.from(markState.keys()).find((item) => item.key === this.attr("key"));
    return markState.get(markKey);
  }
  /**
   * Get all scales instance.
   */
  getScale() {
    var _a;
    const chartView = (_a = this.getRoot()) === null || _a === void 0 ? void 0 : _a.getView();
    if (!chartView)
      return void 0;
    return chartView === null || chartView === void 0 ? void 0 : chartView.scale;
  }
  /**
   * Get the scale instance by channel.
   */
  getScaleByChannel(channel) {
    var _a, _b;
    const chartView = (_a = this.getRoot()) === null || _a === void 0 ? void 0 : _a.getView();
    if (!chartView)
      return void 0;
    return (_b = chartView === null || chartView === void 0 ? void 0 : chartView.scale) === null || _b === void 0 ? void 0 : _b[channel];
  }
  /**
   * Get canvas group.
   */
  getGroup() {
    const key = this.attr("key");
    if (!key)
      return void 0;
    const chart = this.getRoot();
    const chartGroup = chart.getContext().canvas.getRoot();
    return chartGroup.getElementById(key);
  }
};
MarkNode = __decorate6([
  defineProps(markProps)
], MarkNode);

// node_modules/@antv/g2/esm/api/runtime.js
var __decorate7 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r2 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r2 = (c5 < 3 ? d3(r2) : c5 > 3 ? d3(target, key, r2) : d3(target, key)) || r2;
  return c5 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __rest91 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var G2_CHART_KEY = "G2_CHART_KEY";
var Runtime = class extends CompositionNode {
  constructor(options) {
    const { container, canvas, renderer, plugins, lib, createCanvas } = options, rest = __rest91(options, ["container", "canvas", "renderer", "plugins", "lib", "createCanvas"]);
    super(rest, "view");
    this._hasBindAutoFit = false;
    this._rendering = false;
    this._trailingClear = null;
    this._trailing = false;
    this._trailingResolve = null;
    this._trailingReject = null;
    this._previousDefinedType = null;
    this._onResize = debounce_default(() => {
      this.forceFit();
    }, 300);
    this._renderer = renderer || new Renderer();
    this._plugins = plugins || [];
    this._container = normalizeContainer2(container);
    this._emitter = new esm_default();
    this._context = {
      library: Object.assign(Object.assign({}, lib), library),
      emitter: this._emitter,
      canvas,
      createCanvas
    };
    this._create();
  }
  render() {
    if (this._rendering)
      return this._addToTrailing();
    if (!this._context.canvas)
      this._createCanvas();
    this._bindAutoFit();
    this._rendering = true;
    const finished = new Promise((resolve2, reject2) => render(this._computedOptions(), this._context, this._createResolve(resolve2), this._createReject(reject2)));
    const [finished1, resolve, reject] = createEmptyPromise();
    finished.then(resolve).then(() => {
      if (this._trailingClear) {
        const options = this.options();
        this._trailingClear();
        if (this._trailing)
          this.options(options);
      }
    }).catch(reject).then(() => {
      this._trailingClear = null;
      this._renderTrailing();
    });
    return finished1;
  }
  /**
   * @overload
   * @param {G2ViewTree} [options]
   * @returns {Runtime|Spec}
   */
  options(options) {
    if (arguments.length === 0)
      return optionsOf(this);
    const { type } = options;
    if (type)
      this._previousDefinedType = type;
    updateRoot(this, options, this._previousDefinedType, this._marks, this._compositions);
    return this;
  }
  getContainer() {
    return this._container;
  }
  getContext() {
    return this._context;
  }
  on(event, callback, once) {
    this._emitter.on(event, callback, once);
    return this;
  }
  once(event, callback) {
    this._emitter.once(event, callback);
    return this;
  }
  emit(event, ...args) {
    this._emitter.emit(event, ...args);
    return this;
  }
  off(event, callback) {
    this._emitter.off(event, callback);
    return this;
  }
  clear(isClearEvents = true) {
    if (this._rendering) {
      this._trailingClear = () => {
        this.clear(isClearEvents);
      };
      this._reset();
      return;
    }
    const options = this.options();
    this.emit(ChartEvent.BEFORE_CLEAR);
    this._reset();
    destroy(options, this._context, false, isClearEvents);
    this.emit(ChartEvent.AFTER_CLEAR);
  }
  destroy() {
    const options = this.options();
    this.emit(ChartEvent.BEFORE_DESTROY);
    this._unbindAutoFit();
    this._reset();
    destroy(options, this._context, true);
    if (this._container[REMOVE_FLAG])
      removeContainer(this._container);
    this.emit(ChartEvent.AFTER_DESTROY);
  }
  forceFit() {
    this.options["autoFit"] = true;
    const { width, height } = sizeOf2(this.options(), this._container);
    if (width === this._width && height === this._height) {
      return Promise.resolve(this);
    }
    this.emit(ChartEvent.BEFORE_CHANGE_SIZE);
    const finished = this.render();
    finished.then(() => {
      this.emit(ChartEvent.AFTER_CHANGE_SIZE);
    });
    return finished;
  }
  changeSize(width, height) {
    if (width === this._width && height === this._height) {
      return Promise.resolve(this);
    }
    this.emit(ChartEvent.BEFORE_CHANGE_SIZE);
    this.attr("width", width);
    this.attr("height", height);
    const finished = this.render();
    finished.then(() => {
      this.emit(ChartEvent.AFTER_CHANGE_SIZE);
    });
    return finished;
  }
  getDataByXY(point6, options = {}) {
    const { shared = false, series, facet = false, startX = 0, startY = 0 } = options;
    const { canvas, views } = this._context;
    const { document: document2 } = canvas;
    const { x: x2, y: y3 } = point6;
    const { coordinate, scale: scale4, markState, data: dataMap, key } = views[0];
    const elements = document2.getElementsByClassName(ELEMENT_CLASS_NAME);
    const groupKey = shared ? (element) => element.__data__.x : (d3) => d3;
    const keyGroup = group(elements, groupKey);
    const container = document2.getElementsByClassName(VIEW_CLASS_NAME)[0];
    const root = selectPlotArea(container);
    const hasSeriesInteraction = (markState2) => {
      return Array.from(markState2.values()).some((d3) => {
        var _a, _b;
        return ((_a = d3.interaction) === null || _a === void 0 ? void 0 : _a["seriesTooltip"]) || ((_b = d3.channels) === null || _b === void 0 ? void 0 : _b.some((c5) => c5.name === "series" && c5.values !== void 0));
      });
    };
    const isSeries = maybeValue(series, hasSeriesInteraction(markState));
    const getElementData = (el) => get_default(el, "__data__.data", null);
    const getElementsData = (els) => els.map(getElementData);
    try {
      if (isSeries && hasSeriesInteraction(markState) && !facet) {
        const { selectedData } = findSeriesElement({
          root,
          event: { offsetX: x2, offsetY: y3 },
          elements,
          coordinate,
          scale: scale4,
          startX,
          startY
        });
        const viewData = dataMap.get(`${key}-0`);
        return selectedData.map(({ index: index2 }) => viewData[index2]);
      }
      const element = findSingleElement({
        root,
        event: { offsetX: x2, offsetY: y3 },
        elements,
        coordinate,
        scale: scale4,
        shared
      });
      if (isHeatmap(element))
        return dataOf(element, dataMap.get(key));
      const k2 = groupKey(element);
      const groupElements = keyGroup.get(k2);
      return groupElements ? getElementsData(groupElements) : [];
    } catch (e3) {
      const topMostElement = canvas.document.elementFromPointSync(x2, y3);
      return topMostElement ? getElementData(topMostElement) : [];
    }
  }
  _create() {
    const { library: library3 } = this._context;
    const isMark2 = (key) => key.startsWith("mark.") || key === "component.axisX" || key === "component.axisY" || key === "component.legends";
    const marks = [
      "mark.mark",
      // chart.mark(composite)
      ...Object.keys(library3).filter(isMark2)
    ];
    this._marks = {};
    for (const key of marks) {
      const name2 = key.split(".").pop();
      class Mark2 extends MarkNode {
        constructor() {
          super({}, name2);
        }
      }
      this._marks[name2] = Mark2;
      this[name2] = function(composite) {
        const node = this.append(Mark2);
        if (name2 === "mark")
          node.type = composite;
        return node;
      };
    }
    const compositions = [
      "composition.view",
      // chat.view()
      ...Object.keys(library3).filter((key) => key.startsWith("composition.") && key !== "composition.mark")
    ];
    this._compositions = Object.fromEntries(compositions.map((key) => {
      const name2 = key.split(".").pop();
      let Composition = class Composition extends CompositionNode {
        constructor() {
          super({}, name2);
        }
      };
      Composition = __decorate7([
        defineProps(nodeProps(this._marks))
      ], Composition);
      return [name2, Composition];
    }));
    for (const Ctor of Object.values(this._compositions)) {
      defineProps(nodeProps(this._compositions))(Ctor);
    }
    for (const key of compositions) {
      const name2 = key.split(".").pop();
      this[name2] = function() {
        const Composition = this._compositions[name2];
        this.type = null;
        return this.append(Composition);
      };
    }
  }
  _reset() {
    const KEYS = ["theme", "type", "width", "height", "autoFit"];
    this.type = "view";
    this.value = Object.fromEntries(Object.entries(this.value).filter(([key]) => key.startsWith("margin") || key.startsWith("padding") || key.startsWith("inset") || KEYS.includes(key)));
    this.children = [];
  }
  _renderTrailing() {
    if (!this._trailing)
      return;
    this._trailing = false;
    this.render().then(() => {
      const trailingResolve = this._trailingResolve.bind(this);
      this._trailingResolve = null;
      trailingResolve(this);
    }).catch((error2) => {
      const trailingReject = this._trailingReject.bind(this);
      this._trailingReject = null;
      trailingReject(error2);
    });
  }
  _createResolve(resolve) {
    return () => {
      this._rendering = false;
      resolve(this);
    };
  }
  _createReject(reject) {
    return (error2) => {
      this._rendering = false;
      reject(error2);
    };
  }
  // Update actual size and key.
  _computedOptions() {
    const options = this.options();
    const { key = G2_CHART_KEY } = options;
    const { width, height, depth } = sizeOf2(options, this._container);
    this._width = width;
    this._height = height;
    this._key = key;
    return Object.assign(Object.assign({ key: this._key }, options), { width, height, depth });
  }
  // Create canvas if it does not exist.
  // DragAndDropPlugin is for interaction.
  // It is OK to register more than one time, G will handle this.
  _createCanvas() {
    var _a, _b;
    const { width, height } = sizeOf2(this.options(), this._container);
    this._plugins.push(new Plugin());
    this._plugins.forEach((d3) => this._renderer.registerPlugin(d3));
    this._context.canvas = new Canvas({
      container: this._container,
      width,
      height,
      renderer: this._renderer
    });
    const dom2 = (_b = (_a = this._context.canvas) === null || _a === void 0 ? void 0 : _a.getContextService()) === null || _b === void 0 ? void 0 : _b.getDomElement();
    if (dom2)
      dom2.style.display = "block";
  }
  _addToTrailing() {
    var _a;
    (_a = this._trailingResolve) === null || _a === void 0 ? void 0 : _a.call(this, this);
    this._trailing = true;
    const promise = new Promise((resolve, reject) => {
      this._trailingResolve = resolve;
      this._trailingReject = reject;
    });
    return promise;
  }
  _bindAutoFit() {
    const options = this.options();
    const { autoFit } = options;
    if (this._hasBindAutoFit) {
      if (!autoFit)
        this._unbindAutoFit();
      return;
    }
    if (autoFit) {
      this._hasBindAutoFit = true;
      window.addEventListener("resize", this._onResize);
    }
  }
  _unbindAutoFit() {
    if (this._hasBindAutoFit) {
      this._hasBindAutoFit = false;
      window.removeEventListener("resize", this._onResize);
    }
  }
};

// node_modules/@antv/g2/esm/api/chart.js
var Chart = extend3(Runtime, library);

// node_modules/@antv/g2/esm/index.js
var library2 = Object.assign({}, stdlib());
var Chart2 = extend3(Runtime, library2);

// node_modules/@ant-design/charts-util/es/react/render.js
var React = __toESM(require_react());
var version2 = React.version || "";
var createRoot;
var legacyRender;
var legacyUnmount;
var MARK = "__rc_react_root__";
try {
  mainVersion = parseInt(version2.split(".")[0], 10);
  if (mainVersion >= 18) {
    client = require_client();
    createRoot = client.createRoot;
  } else {
    legacyReactDOM = require_react_dom();
    legacyRender = legacyReactDOM.render;
    legacyUnmount = legacyReactDOM.unmountComponentAtNode;
  }
} catch (e3) {
}
var mainVersion;
var client;
var legacyReactDOM;
function modernRender(node, container) {
  if (!container[MARK]) {
    container[MARK] = createRoot(container);
  }
  container[MARK].render(node);
}
function fallbackLegacyRender(node, container) {
  if (legacyRender) {
    legacyRender(node, container);
  } else {
    throw new Error("ReactDOM.render is not available in this React version");
  }
}
function render2(node, container) {
  if (createRoot) {
    modernRender(node, container);
  } else {
    fallbackLegacyRender(node, container);
  }
}

// node_modules/@ant-design/charts-util/es/rc/create-node.js
var mountMapping = /* @__PURE__ */ new Map();
if (typeof document !== "undefined") {
  mountMapping.set("tooltip", document.createElement("div"));
}
var createNode2 = function(children, isTooltip) {
  if (isTooltip === void 0) {
    isTooltip = false;
  }
  var mount = null;
  if (isTooltip) {
    mount = mountMapping.get("tooltip");
  } else {
    mount = document.createElement("div");
    if (children === null || children === void 0 ? void 0 : children.key) {
      var exist = mountMapping.get(children.key);
      if (exist) {
        mount = exist;
      } else {
        mountMapping.set(children.key, mount);
      }
    }
  }
  render2(children, mount);
  return mount;
};

// node_modules/@ant-design/charts-util/es/rc/chart-loading.js
var import_react = __toESM(require_react());
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t[p3] = s3[p3];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var shadowLoading = function(ele, style) {
  if (style === void 0) {
    style = {};
  }
  if (typeof document === "undefined") {
    return "loading";
  }
  var overStyle = "";
  if (style) {
    Object.keys(style).forEach(function(key) {
      overStyle += "".concat(key, ": ").concat(style[key], ";\n");
    });
  }
  var shadowRoot = ele.attachShadow({ mode: "open" });
  var shadowDiv = document.createElement("div");
  var shadowStyle = document.createElement("style");
  shadowStyle.innerHTML = ".loading {\n    display: inline-block;\n    position: relative;\n    width: 80px;\n    height: 80px;\n  }\n  .loading div {\n    position: absolute;\n    top: 33px;\n    width: 13px;\n    height: 13px;\n    border-radius: 50%;\n    background: #ccc;\n    animation-timing-function: cubic-bezier(0, 1, 1, 0);\n    ".concat(overStyle, "\n  }\n  .loading div:nth-child(1) {\n    left: 8px;\n    animation: loading1 0.6s infinite;\n  }\n  .loading div:nth-child(2) {\n    left: 8px;\n    animation: loading2 0.6s infinite;\n  }\n  .loading div:nth-child(3) {\n    left: 32px;\n    animation: loading2 0.6s infinite;\n  }\n  .loading div:nth-child(4) {\n    left: 56px;\n    animation: loading3 0.6s infinite;\n  }\n  @keyframes loading1 {\n    0% {\n      transform: scale(0);\n    }\n    100% {\n      transform: scale(1);\n    }\n  }\n  @keyframes loading3 {\n    0% {\n      transform: scale(1);\n    }\n    100% {\n      transform: scale(0);\n    }\n  }\n  @keyframes loading2 {\n    0% {\n      transform: translate(0, 0);\n    }\n    100% {\n      transform: translate(24px, 0);\n    }\n  }\n  ");
  shadowDiv.classList.add("loading");
  shadowDiv.innerHTML = "<div></div><div></div><div></div><div></div>";
  shadowRoot.appendChild(shadowStyle);
  shadowRoot.appendChild(shadowDiv);
};
var ChartLoading = function(_a) {
  var loadingTemplate = _a.loadingTemplate, _b = _a.theme, theme = _b === void 0 ? "light" : _b, loading = _a.loading;
  var shadow = import_react.default.useRef(null);
  var _c = typeof loading === "object" ? loading : {}, _d = _c.container, container = _d === void 0 ? {} : _d, _e = _c.icon, icon = _e === void 0 ? {} : _e;
  import_react.default.useEffect(function() {
    if (!loadingTemplate && shadow.current) {
      shadowLoading(shadow.current, icon);
    }
  }, []);
  var renderLoading = function() {
    if (loadingTemplate)
      return loadingTemplate;
    return import_react.default.createElement("div", { ref: shadow });
  };
  return import_react.default.createElement("div", { className: "charts-loading-container", style: __assign2({ position: "absolute", width: "100%", height: "100%", display: "flex", alignItems: "center", justifyContent: "center", left: 0, top: 0, zIndex: 99, background: theme === "dark" ? "rgb(20, 20, 20)" : "rgb(255, 255, 255)" }, container) }, renderLoading());
};

// node_modules/@ant-design/charts-util/es/rc/error-boundary.js
var import_react2 = __toESM(require_react());
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ErrorBoundary = (
  /** @class */
  function(_super) {
    __extends(ErrorBoundary2, _super);
    function ErrorBoundary2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.state = {
        hasError: false
      };
      _this.renderError = function(e3) {
        var errorTemplate = _this.props.errorTemplate;
        switch (e3) {
          default:
            if (typeof errorTemplate === "function")
              return errorTemplate(e3);
            return errorTemplate ? errorTemplate : import_react2.default.createElement(
              "h5",
              null,
              " ",
              e3.message
            );
        }
      };
      return _this;
    }
    ErrorBoundary2.getDerivedStateFromError = function(error2) {
      return { hasError: true, error: error2 };
    };
    ErrorBoundary2.getDerivedStateFromProps = function(nextProps, state) {
      if (state.children !== nextProps.children) {
        return {
          children: nextProps.children,
          hasError: false,
          error: void 0
        };
      }
      return null;
    };
    ErrorBoundary2.prototype.render = function() {
      if (this.state.hasError) {
        return this.renderError(this.state.error);
      }
      return import_react2.default.createElement(import_react2.Fragment, null, this.props.children);
    };
    return ErrorBoundary2;
  }(import_react2.default.Component)
);

// node_modules/@ant-design/charts-util/es/utils/measure-text.js
var import_lodash2 = __toESM(require_lodash());

// node_modules/@ant-design/charts-util/es/utils/context.js
var ctx2;
var getCanvasContext = function() {
  if (!ctx2) {
    ctx2 = document.createElement("canvas").getContext("2d");
  }
  return ctx2;
};

// node_modules/@ant-design/charts-util/es/utils/measure-text.js
var __spreadArray6 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var measureText = (0, import_lodash2.memoize)(function(text, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, _a = font.fontFamily, fontFamily = _a === void 0 ? "sans-serif" : _a, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  var ctx3 = getCanvasContext();
  ctx3.font = [fontStyle, fontWeight, fontVariant, "".concat(fontSize, "px"), fontFamily].join(" ");
  return ctx3.measureText((0, import_lodash2.isString)(text) ? text : "");
}, function(text, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArray6([text], (0, import_lodash2.values)(font), true).join("");
});
var measureTextWidth2 = function(text, font) {
  if (font === void 0) {
    font = {};
  }
  return measureText(text, font).width;
};

// node_modules/@ant-design/plots/es/components/base/index.js
var import_react4 = __toESM(require_react());

// node_modules/@ant-design/plots/es/hooks/useChart.js
var import_react3 = __toESM(require_react());

// node_modules/@ant-design/plots/es/util/index.js
var import_lodash3 = __toESM(require_lodash());

// node_modules/@ant-design/plots/es/util/is-valid-element.js
var isValidElement = function(jsxCode) {
  var basicReactPatterns = [/\breact\b/i, /\.jsx/, /children:\s*\[/, /\*#__PURE__\*/];
  var createElementPattern = /(\w+)?\.createElement\(\s*(['"`])([^'"`]+)\2/g;
  var GElements = /* @__PURE__ */ new Set([
    "g",
    "circle",
    "ellipse",
    "image",
    "rect",
    "line",
    "polyline",
    "polygon",
    "text",
    "path",
    "html",
    "mesh"
  ]);
  if (basicReactPatterns.some(function(pattern) {
    return pattern.test(jsxCode);
  })) {
    return true;
  }
  var matches = jsxCode.match(createElementPattern);
  if (!matches) {
    return false;
  }
  return matches.some(function(match) {
    var elementMatch = match.match(/\.createElement\(\s*(['"`])([^'"`]+)\1/);
    return elementMatch && !GElements.has(elementMatch[2].toLowerCase());
  });
};

// node_modules/@ant-design/plots/es/hooks/useChart.js
var __assign3 = function() {
  __assign3 = Object.assign || function(t) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t[p3] = s3[p3];
    }
    return t;
  };
  return __assign3.apply(this, arguments);
};
function useChart(ChartClass, config) {
  var chart = (0, import_react3.useRef)(null);
  var chartOptions = (0, import_react3.useRef)(null);
  var container = (0, import_react3.useRef)(null);
  var onReady = config.onReady, onEvent = config.onEvent;
  var toDataURL = function(type, encoderOptions) {
    var _a;
    if (type === void 0) {
      type = "image/png";
    }
    var canvas = (_a = container.current) === null || _a === void 0 ? void 0 : _a.getElementsByTagName("canvas")[0];
    return canvas === null || canvas === void 0 ? void 0 : canvas.toDataURL(type, encoderOptions);
  };
  var downloadImage = function(name2, type, encoderOptions) {
    if (name2 === void 0) {
      name2 = "download";
    }
    if (type === void 0) {
      type = "image/png";
    }
    var imageName = name2;
    if (name2.indexOf(".") === -1) {
      imageName = "".concat(name2, ".").concat(type.split("/")[1]);
    }
    var base64 = toDataURL(type, encoderOptions);
    var a4 = document.createElement("a");
    a4.href = base64;
    a4.download = imageName;
    document.body.appendChild(a4);
    a4.click();
    document.body.removeChild(a4);
    a4 = null;
    return imageName;
  };
  var processConfig = function(cfg, flag) {
    if (flag === void 0) {
      flag = false;
    }
    var keys = Object.keys(cfg);
    var isTooltip = flag;
    keys.forEach(function(key) {
      var current = cfg[key];
      if (key === "tooltip") {
        isTooltip = true;
      }
      if ((0, import_lodash3.isFunction)(current) && isValidElement("".concat(current))) {
        cfg[key] = function() {
          var arg = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            arg[_i] = arguments[_i];
          }
          return createNode2(current.apply(void 0, arg), isTooltip);
        };
      } else {
        if ((0, import_lodash3.isArray)(current)) {
          current.forEach(function(item) {
            processConfig(item, isTooltip);
          });
        } else if ((0, import_lodash3.isObject)(current)) {
          processConfig(current, isTooltip);
        } else {
          isTooltip = flag;
        }
      }
    });
  };
  (0, import_react3.useEffect)(function() {
    if (chart.current && !(0, import_lodash3.isEqual)(chartOptions.current, config)) {
      chartOptions.current = (0, import_lodash3.cloneDeep)(config);
      processConfig(config);
      chart.current.update(config);
      chart.current.render();
    }
  }, [config]);
  (0, import_react3.useEffect)(function() {
    if (!container.current) {
      return function() {
        return null;
      };
    }
    if (!chartOptions.current) {
      chartOptions.current = (0, import_lodash3.cloneDeep)(config);
    }
    processConfig(config);
    var chartInstance = new ChartClass(container.current, __assign3({}, config));
    chartInstance.toDataURL = toDataURL;
    chartInstance.downloadImage = downloadImage;
    chartInstance.render();
    chart.current = chartInstance;
    if (onReady) {
      onReady(chartInstance);
    }
    var handler = function(event) {
      if (onEvent) {
        onEvent(chartInstance, event);
      }
    };
    chartInstance.on("*", handler);
    return function() {
      if (chart.current) {
        chart.current.destroy();
        chart.current.off("*", handler);
        chart.current = void 0;
      }
    };
  }, []);
  return {
    chart,
    container
  };
}

// node_modules/@antv/g2-extension-plot/esm/utils/hierarchy/partition.js
var DEFAULT_OPTIONS7 = {
  field: "value",
  size: [1, 1],
  // width, height
  round: false,
  padding: 0,
  // Default desc.
  sort: (a4, b) => b.value - a4.value,
  as: ["x", "y"],
  // Whether to ignore parentValue. When set to true, the weight of the parent node is determined by the child element.
  ignoreParentValue: true
};
var NODE_INDEX_FIELD = "nodeIndex";
var CHILD_NODE_COUNT2 = "childNodeCount";
var NODE_ANCESTORS_FIELD = "nodeAncestor";
var INVALID_FIELD_ERR_MSG = "Invalid field: it must be a string!";
function getField(options, defaultField) {
  const { field: field3, fields } = options;
  if (isString(field3)) {
    return field3;
  }
  if (isArray(field3)) {
    console.warn(INVALID_FIELD_ERR_MSG);
    return field3[0];
  }
  console.warn(`${INVALID_FIELD_ERR_MSG} will try to get fields instead.`);
  if (isString(fields)) {
    return fields;
  }
  if (isArray(fields) && fields.length) {
    return fields[0];
  }
  if (defaultField) {
    return defaultField;
  }
  throw new TypeError(INVALID_FIELD_ERR_MSG);
}
function getAllNodes(root) {
  const nodes = [];
  if (root && root.each) {
    let parent;
    let index2;
    root.each((node) => {
      var _a, _b;
      if (node.parent !== parent) {
        parent = node.parent;
        index2 = 0;
      } else {
        index2 += 1;
      }
      const ancestors = filter_default((((_a = node.ancestors) === null || _a === void 0 ? void 0 : _a.call(node)) || []).map((d3) => nodes.find((n2) => n2.name === d3.name) || d3), ({ depth }) => depth > 0 && depth < node.depth);
      node[NODE_ANCESTORS_FIELD] = ancestors;
      node[CHILD_NODE_COUNT2] = ((_b = node.children) === null || _b === void 0 ? void 0 : _b.length) || 0;
      node[NODE_INDEX_FIELD] = index2;
      nodes.push(node);
    });
  } else if (root && root.eachNode) {
    root.eachNode((node) => {
      nodes.push(node);
    });
  }
  return nodes;
}
function partition(data, options) {
  options = mix({}, DEFAULT_OPTIONS7, options);
  const as = options.as;
  if (!isArray(as) || as.length !== 2) {
    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
  }
  let field3;
  try {
    field3 = getField(options);
  } catch (e3) {
    console.warn(e3);
  }
  const partition2 = (data2) => partition_default().size(options.size).round(options.round).padding(options.padding)(
    /**
     * The sum function must be specified in the d3Hierarchy layout to compute node values by calling the specified value function
     * from the current node in post-order traversal order for the current node and for each descendant node and returning the current node.
     * for example:
     * { node: 'parent', value: 10, children: [{node: 'child1', value: 5}, {node: 'child2', value: 5}, ]}.
     * The computed value obtained by the parent is sum(node(parent)) + sum(node(child1)) + sum(node(child2)).
     * In the sum function, d is the data passed in by the user and children is the reserved field.
     */
    hierarchy(data2).sum((d3) => size(d3.children) ? options.ignoreParentValue ? 0 : d3[field3] - reduce_default(d3.children, (a4, b) => a4 + b[field3], 0) : d3[field3]).sort(options.sort)
  );
  const root = partition2(data);
  const x2 = as[0];
  const y3 = as[1];
  root.each((node) => {
    var _a, _b;
    node[x2] = [node.x0, node.x1, node.x1, node.x0];
    node[y3] = [node.y1, node.y1, node.y0, node.y0];
    node.name = node.name || ((_a = node.data) === null || _a === void 0 ? void 0 : _a.name) || ((_b = node.data) === null || _b === void 0 ? void 0 : _b.label);
    node.data.name = node.name;
    ["x0", "x1", "y0", "y1"].forEach((prop) => {
      if (as.indexOf(prop) === -1) {
        delete node[prop];
      }
    });
  });
  return getAllNodes(root);
}

// node_modules/@antv/g2-extension-plot/esm/mark/sunburst.js
var __rest92 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var SUNBURST_TYPE = "sunburst";
var SUNBURST_TYPE_FIELD = "markType";
var SUNBURST_PATH_FIELD = "path";
var SUNBURST_ANCESTOR_FIELD = "ancestor-node";
function transformData2(options) {
  const { data, encode } = options;
  const { color, value: value2 } = encode;
  const type = "partition";
  const nodes = partition(data, {
    field: value2,
    // @ts-ignore
    type: `hierarchy.${type}`,
    as: ["x", "y"]
  });
  const result = [];
  nodes.forEach((node) => {
    var _a, _b, _c, _d;
    if (node.depth === 0) {
      return null;
    }
    let path2 = node.data.name;
    const pathList = [path2];
    let ancestorNode = Object.assign({}, node);
    while (ancestorNode.depth > 1) {
      path2 = `${(_a = ancestorNode.parent.data) === null || _a === void 0 ? void 0 : _a.name} / ${path2}`;
      pathList.unshift((_b = ancestorNode.parent.data) === null || _b === void 0 ? void 0 : _b.name);
      ancestorNode = ancestorNode.parent;
    }
    const nodeInfo = Object.assign(Object.assign(Object.assign({}, pick_default(node.data, [value2])), { [SUNBURST_PATH_FIELD]: path2, [SUNBURST_ANCESTOR_FIELD]: ancestorNode.data.name }), node);
    if (color && color !== SUNBURST_ANCESTOR_FIELD) {
      nodeInfo[color] = node.data[color] || ((_d = (_c = node.parent) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d[color]);
    }
    result.push(nodeInfo);
  });
  return result.map((d3) => {
    const x2 = d3.x.slice(0, 2);
    const y3 = [d3.y[2], d3.y[0]];
    if (x2[0] === x2[1]) {
      y3[0] = y3[1] = (d3.y[2] + d3.y[0]) / 2;
    }
    return Object.assign(Object.assign({}, d3), {
      x: x2,
      y: y3,
      fillOpacity: Math.pow(0.85, d3.depth)
    });
  });
}
var DEFAULT_OPTIONS8 = {
  id: SUNBURST_TYPE,
  encode: {
    x: "x",
    y: "y",
    key: SUNBURST_PATH_FIELD,
    color: SUNBURST_ANCESTOR_FIELD,
    value: "value"
  },
  axis: { x: false, y: false },
  style: {
    [SUNBURST_TYPE_FIELD]: SUNBURST_TYPE,
    stroke: "#fff",
    lineWidth: 0.5,
    fillOpacity: "fillOpacity",
    [CHILD_NODE_COUNT2]: CHILD_NODE_COUNT2,
    depth: "depth"
  },
  state: {
    active: { zIndex: 2, stroke: "#000" },
    inactive: { zIndex: 1, stroke: "#fff" }
  },
  legend: false,
  interaction: { drillDown: true },
  coordinate: {
    type: "polar",
    innerRadius: 0.2
  }
};
var Sunburst = (options) => {
  const { encode: encodeOption, data = [] } = options, resOptions = __rest92(options, ["encode", "data"]);
  const coordinate = Object.assign(Object.assign({}, resOptions.coordinate), {
    // Reac Bug InnerRadius = 0.
    innerRadius: Math.max(get_default(resOptions, ["coordinate", "innerRadius"], 0.2), 1e-5)
  });
  const encode = Object.assign(Object.assign({}, DEFAULT_OPTIONS8.encode), encodeOption);
  const { value: value2 } = encode;
  const rectData = transformData2({ encode, data });
  return [
    deep_mix_default({}, DEFAULT_OPTIONS8, Object.assign(Object.assign({ type: "rect", data: rectData, encode, tooltip: {
      title: "path",
      items: [
        (d3) => {
          return {
            name: value2,
            value: d3[value2]
          };
        }
      ]
    } }, resOptions), { coordinate }))
  ];
};
Sunburst.props = {};

// node_modules/@antv/g2-extension-plot/esm/interaction/drillDown.js
var __awaiter17 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getElementsSunburst = (plot2) => {
  return plot2.querySelectorAll(".element").filter((item) => get_default(item, ["style", SUNBURST_TYPE_FIELD]) === SUNBURST_TYPE);
};
function selectPlotArea4(root) {
  return select(root).select(`.${PLOT_CLASS_NAME}`).node();
}
var DEFAULT_BREADCRUMB2 = {
  rootText: "root",
  style: {
    fill: "rgba(0, 0, 0, 0.85)",
    fontSize: 12,
    y: 1
  },
  active: {
    fill: "rgba(0, 0, 0, 0.5)"
  }
};
function DrillDown2(drillDownOptions = {}) {
  const { breadCrumb: textConfig = {}, isFixedColor = false } = drillDownOptions;
  const breadCrumb = deep_mix_default({}, DEFAULT_BREADCRUMB2, textConfig);
  return (context) => {
    const { update, setState, container, view, options } = context;
    const document2 = container.ownerDocument;
    const plotArea = selectPlotArea4(container);
    const sunburstMark = options.marks.find(({ id: id2 }) => id2 === SUNBURST_TYPE);
    const { state } = sunburstMark;
    const textGroup = document2.createElement("g");
    plotArea.appendChild(textGroup);
    const drillDownClick = (path2, depth) => __awaiter17(this, void 0, void 0, function* () {
      textGroup.removeChildren();
      if (path2) {
        const rootText = document2.createElement("text", {
          style: Object.assign({
            x: 0,
            text: breadCrumb.rootText,
            // @ts-ignore
            depth: 0
          }, breadCrumb.style)
        });
        textGroup.appendChild(rootText);
        let name2 = "";
        const pathArray = path2 === null || path2 === void 0 ? void 0 : path2.split(" / ");
        let y3 = breadCrumb.style.y;
        let x2 = textGroup.getBBox().width;
        const maxWidth = plotArea.getBBox().width;
        const drillTexts = pathArray.map((text, index2) => {
          const textSeparator = document2.createElement("text", {
            style: Object.assign(Object.assign({ x: x2, text: " / " }, breadCrumb.style), { y: y3 })
          });
          textGroup.appendChild(textSeparator);
          x2 += textSeparator.getBBox().width;
          name2 = `${name2}${text} / `;
          const drillText = document2.createElement("text", {
            name: name2.replace(/\s\/\s$/, ""),
            style: Object.assign(Object.assign({
              text,
              x: x2,
              // @ts-ignore
              depth: index2 + 1
            }, breadCrumb.style), { y: y3 })
          });
          textGroup.appendChild(drillText);
          x2 += drillText.getBBox().width;
          if (x2 > maxWidth) {
            y3 = textGroup.getBBox().height;
            x2 = 0;
            textSeparator.attr({
              x: x2,
              y: y3
            });
            x2 += textSeparator.getBBox().width;
            drillText.attr({
              x: x2,
              y: y3
            });
            x2 += drillText.getBBox().width;
          }
          return drillText;
        });
        [rootText, ...drillTexts].forEach((item, index2) => {
          if (index2 === drillTexts.length)
            return;
          const originalAttrs = Object.assign({}, item.attributes);
          item.attr("cursor", "pointer");
          item.addEventListener("mouseenter", () => {
            item.attr(breadCrumb.active);
          });
          item.addEventListener("mouseleave", () => {
            item.attr(originalAttrs);
          });
          item.addEventListener("click", () => {
            drillDownClick(item.name, get_default(item, ["style", "depth"]));
          });
        });
      }
      setState("drillDown", (viewOptions) => {
        const { marks } = viewOptions;
        const newMarks = marks.map((mark2) => {
          if (mark2.id !== SUNBURST_TYPE && mark2.type !== "rect")
            return mark2;
          const { data } = mark2;
          const newScale = Object.fromEntries(["color"].map((channel) => [channel, { domain: view.scale[channel].getOptions().domain }]));
          const newData = data.filter((item) => {
            const key = item.path;
            if (!isFixedColor) {
              item[SUNBURST_ANCESTOR_FIELD] = key.split(" / ")[depth];
            }
            if (!path2)
              return true;
            const reg = new RegExp(`^${path2}.+`);
            return reg.test(key);
          });
          return deep_mix_default({}, mark2, isFixedColor ? {
            data: newData,
            scale: newScale
          } : {
            data: newData
          });
        });
        return Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
      });
      yield update();
    });
    const createDrillClick = (e3) => {
      const item = e3.target;
      if (get_default(item, ["style", SUNBURST_TYPE_FIELD]) !== SUNBURST_TYPE || get_default(item, ["markType"]) !== "rect" || !get_default(item, ["style", CHILD_NODE_COUNT2]))
        return;
      const path2 = get_default(item, ["__data__", "key"]);
      const depth = get_default(item, ["style", "depth"]);
      item.style.cursor = "pointer";
      drillDownClick(path2, depth);
    };
    plotArea.addEventListener("click", createDrillClick);
    const changeStyleKey = keys_default(Object.assign(Object.assign({}, state.active), state.inactive));
    const createActive = () => {
      const elements = getElementsSunburst(plotArea);
      elements.forEach((element) => {
        const childNodeCount = get_default(element, ["style", CHILD_NODE_COUNT2]);
        const cursor = get_default(element, ["style", "cursor"]);
        if (cursor !== "pointer" && childNodeCount) {
          element.style.cursor = "pointer";
          const originalAttrs = pick_default(element.attributes, changeStyleKey);
          element.addEventListener("mouseenter", () => {
            element.attr(state.active);
          });
          element.addEventListener("mouseleave", () => {
            element.attr(deep_mix_default(originalAttrs, state.inactive));
          });
        }
      });
    };
    plotArea.addEventListener("mousemove", createActive);
    return () => {
      textGroup.remove();
      plotArea.removeEventListener("click", createDrillClick);
      plotArea.removeEventListener("mousemove", createActive);
    };
  };
}

// node_modules/@antv/g2-extension-plot/esm/lib.js
function plotlib2() {
  return {
    "interaction.drillDown": DrillDown2,
    "mark.sunburst": Sunburst
  };
}

// node_modules/@ant-design/plots/es/core/base/chart.js
var __assign4 = function() {
  __assign4 = Object.assign || function(t) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t[p3] = s3[p3];
    }
    return t;
  };
  return __assign4.apply(this, arguments);
};
var Chart3 = extend3(Runtime, __assign4(__assign4({}, stdlib()), plotlib2()));

// node_modules/@ant-design/plots/es/core/utils/index.js
var import_lodash4 = __toESM(require_lodash());

// node_modules/@ant-design/plots/es/core/utils/transform.js
var __assign5 = function() {
  __assign5 = Object.assign || function(t) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t[p3] = s3[p3];
    }
    return t;
  };
  return __assign5.apply(this, arguments);
};
var transformOptions = function(params) {
  var options = filterTransformed(params);
  var _a = options.children, children = _a === void 0 ? [] : _a;
  var rest = (0, import_lodash4.omit)(options, [].concat(VIEW_OPTIONS, CONFIG_SHAPE.map(function(item) {
    return item.key;
  })));
  var getCustomTransform = function(key) {
    var _a2;
    return (_a2 = SPECIAL_OPTIONS.find(function(option) {
      return option.key === key;
    })) === null || _a2 === void 0 ? void 0 : _a2.callback;
  };
  var updateOptions = function(origin, key, value2) {
    var callback = getCustomTransform(key);
    if (callback) {
      callback(origin, key, value2);
    } else {
      origin[key] = mergeWithArrayCoverage({}, origin[key], value2);
    }
  };
  var transformShape = function(config) {
    Object.keys(config).forEach(function(key) {
      if (!config[key])
        return;
      var exist = CONFIG_SHAPE.find(function(item) {
        return item.key === key;
      });
      if (exist) {
        var type = exist.type, extendedProperties = exist.extendedProperties, _a2 = exist.defaultShapeConfig, defaultShapeConfig = _a2 === void 0 ? {} : _a2;
        if (type) {
          var tooltip2 = config[key].tooltip;
          children.push(transformConfig(mergeWithArrayCoverage({}, (0, import_lodash4.pick)(config, extendedProperties), defaultShapeConfig, { type }, config[key], {
            tooltip: tooltip2 ? tooltip2 : false
          })));
        } else {
          if ((0, import_lodash4.isArray)(config[key])) {
            var isText_1 = config[key].some(function(item) {
              return item.type === "text";
            });
            config[key].forEach(function(annotation) {
              children.push(transformConfig(__assign5(__assign5(__assign5({}, isText_1 ? { data: [] } : {}), { tooltip: false }), annotation)));
            });
          }
        }
      }
    });
  };
  var transformConfig = function(config) {
    transformShape(config);
    Object.keys(TRANSFORM_OPTION_KEY).forEach(function(key) {
      var transformTarget = TRANSFORM_OPTION_KEY[key];
      if (!(0, import_lodash4.isUndefined)(config[key])) {
        if ((0, import_lodash4.isObject)(transformTarget)) {
          var value2 = transformTarget.value, target = transformTarget.target;
          var transformValue = value2(config[key]);
          updateOptions(config, target, transformValue);
        } else {
          (0, import_lodash4.set)(config, transformTarget, config[key]);
        }
      }
    });
    return config;
  };
  children.forEach(function(child) {
    var config = mergeWithArrayCoverage({}, rest, child);
    transformConfig(mergeWithArrayCoverage(child, config));
  });
  transformShape(options);
  deleteExcessKeys(options);
  return params;
};

// node_modules/@ant-design/plots/es/core/utils/delete-excess-keys.js
var __spreadArray7 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var deleteExcessKeys = function(options) {
  var _a = options.children, children = _a === void 0 ? [] : _a;
  var deleteKeys = Object.keys(TRANSFORM_OPTION_KEY).concat(CONFIG_SHAPE.map(function(item) {
    return item.key;
  }));
  deleteKeys.forEach(function(key) {
    delete options[key];
  });
  children.forEach(function(child) {
    Object.keys(child).forEach(function(key) {
      if (deleteKeys.includes(key)) {
        delete child[key];
      }
    });
  });
  Object.keys(options).forEach(function(key) {
    if (!__spreadArray7(__spreadArray7([], VIEW_OPTIONS, true), ANNOTATION_LIST.map(function(item) {
      return item.key;
    }), true).includes(key)) {
      delete options[key];
    }
  });
  return options;
};

// node_modules/@ant-design/plots/es/core/utils/filter-transformed.js
var filterTransformed = function(params) {
  var options = params.options;
  var _a = options.children, children = _a === void 0 ? [] : _a;
  children.forEach(function(child) {
    Object.keys(child).forEach(function(key) {
      if ((0, import_lodash4.isArray)(child[key]) && key !== "data") {
        child[key] = child[key].filter(function(item) {
          return !item[TRANSFORM_SIGN];
        });
      }
    });
  });
  return options;
};

// node_modules/@ant-design/plots/es/core/utils/merge-with-array-coverage.js
var __spreadArray8 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var arrayCoverage = function(objValue, srcValue) {
  if ((0, import_lodash4.isArray)(srcValue)) {
    return srcValue;
  }
};
var mergeWithArrayCoverage = function() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return import_lodash4.mergeWith.apply(void 0, __spreadArray8(__spreadArray8([], args, false), [arrayCoverage], false));
};

// node_modules/@ant-design/plots/es/core/utils/field-adapter.js
function fieldAdapter(field3) {
  switch (typeof field3) {
    case "function":
      return field3;
    case "string":
      return function(d3) {
        return (0, import_lodash4.get)(d3, [field3]);
      };
    default:
      return function() {
        return field3;
      };
  }
}

// node_modules/@ant-design/plots/es/core/utils/data-transform.js
var dataTransform4 = function(params) {
  var options = params.options;
  var data = options.data;
  if ((0, import_lodash4.get)(data, "value"))
    return params;
  if ((0, import_lodash4.get)(data, "type") !== "fetch" && (0, import_lodash4.isPlainObject)(data)) {
    (0, import_lodash4.set)(options, "data.value", data);
  }
  return params;
};

// node_modules/@ant-design/plots/es/core/constants/index.js
var __assign6 = function() {
  __assign6 = Object.assign || function(t) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t[p3] = s3[p3];
    }
    return t;
  };
  return __assign6.apply(this, arguments);
};
var __rest93 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var CHART_OPTIONS = ["renderer", "plugins"];
var VIEW_OPTIONS = [
  "width",
  "height",
  "autoFit",
  "theme",
  "inset",
  "insetLeft",
  "insetRight",
  "insetTop",
  "insetBottom",
  "padding",
  "paddingTop",
  "paddingRight",
  "paddingBottom",
  "paddingLeft",
  "margin",
  "marginTop",
  "marginRight",
  "marginBottom",
  "marginLeft",
  "depth",
  "title",
  "clip",
  "children",
  "type",
  "data",
  "direction",
  "plugins"
];
var TRANSFORM_SIGN = "__transform__";
var SKIP_DEL_CUSTOM_SIGN = "__skipDelCustomKeys__";
var commonCallback = function(type, value2) {
  if ((0, import_lodash4.isBoolean)(value2)) {
    return {
      type,
      available: value2
    };
  }
  return __assign6({ type }, value2);
};
var TRANSFORM_OPTION_KEY = {
  /** encode */
  xField: "encode.x",
  yField: "encode.y",
  colorField: "encode.color",
  angleField: "encode.y",
  keyField: "encode.key",
  y1Field: "encode.y1",
  sizeField: "encode.size",
  setsField: "encode.sets",
  shapeField: "encode.shape",
  seriesField: "encode.series",
  positionField: "encode.position",
  textField: "encode.text",
  valueField: "encode.value",
  binField: "encode.x",
  srcField: "encode.src",
  linkColorField: "encode.linkColor",
  fontSizeField: "encode.fontSize",
  coordinateType: "coordinate.type",
  radius: "coordinate.outerRadius",
  innerRadius: "coordinate.innerRadius",
  startAngle: "coordinate.startAngle",
  endAngle: "coordinate.endAngle",
  focusX: "coordinate.focusX",
  focusY: "coordinate.focusY",
  distortionX: "coordinate.distortionX",
  distortionY: "coordinate.distortionY",
  visual: "coordinate.visual",
  /**
   * @title 
   * @example
   *  1. stack: true -> transform: [{type: 'stackY'}]
   */
  stack: {
    target: "transform",
    value: function(value2) {
      return commonCallback("stackY", value2);
    }
  },
  /**
   * @title 
   * @example
   *  1. normalize: true -> transform: [{type: 'normalizeY'}]
   */
  normalize: {
    target: "transform",
    value: function(value2) {
      return commonCallback("normalizeY", value2);
    }
  },
  /**
   * @title 
   * @description  normalize
   * @example
   *  1. percent: true -> transform: [{type: 'normalizeY'}]
   */
  percent: {
    target: "transform",
    value: function(value2) {
      return commonCallback("normalizeY", value2);
    }
  },
  /**
   * @title 
   * @example
   *  1. group: true -> transform: [{type: 'dodgeX'}]
   */
  group: {
    target: "transform",
    value: function(value2) {
      return commonCallback("dodgeX", value2);
    }
  },
  /**
   * @title 
   * @example
   *  1. sort: true -> transform: [{type: 'sortX'}]
   */
  sort: {
    target: "transform",
    value: function(value2) {
      return commonCallback("sortX", value2);
    }
  },
  /**
   * @title 
   * @example
   *  1. symmetry: true -> transform: [{type: 'symmetryY'}]
   */
  symmetry: {
    target: "transform",
    value: function(value2) {
      return commonCallback("symmetryY", value2);
    }
  },
  /**
   * @title  y  y1 
   * @example
   *  1. diff: true -> transform: [{type: 'diffY'}]
   */
  diff: {
    target: "transform",
    value: function(value2) {
      return commonCallback("diffY", value2);
    }
  },
  meta: {
    target: "scale",
    value: function(value2) {
      return value2;
    }
  },
  label: {
    target: "labels",
    value: function(value2) {
      return value2;
    }
  },
  /**
   * @title 
   * @example
   *  1. shape: 'smooth' -> style: {shape: 'smooth'}
   */
  shape: "style.shape",
  /**
   * @title 
   * @description  boolean  
   */
  connectNulls: {
    target: "style",
    value: function(value2) {
      if ((0, import_lodash4.isBoolean)(value2)) {
        return {
          connect: value2
        };
      }
      return value2;
    }
  },
  /**
   * @title 
   * @example
   *  1. transpose: true -> coordinate: { transform: [{ type: 'transpose' }]}
   *  2. transpose: false -> coordinate: { }
   */
  transpose: {
    target: "transpose",
    value: function(value2) {
      return commonCallback("transpose", value2);
    }
  }
};
var EXTENDED_PROPERTIES = [
  "xField",
  "yField",
  "seriesField",
  "colorField",
  "shapeField",
  "keyField",
  "positionField",
  "meta",
  "tooltip",
  "animate",
  "stack",
  "normalize",
  "percent",
  "group",
  "sort",
  "symmetry",
  "diff"
];
var CONFIG_SHAPE = [
  {
    key: "annotations",
    extendedProperties: []
  },
  {
    key: "line",
    type: "line",
    extendedProperties: EXTENDED_PROPERTIES
  },
  {
    key: "connector",
    type: "connector",
    extendedProperties: []
  },
  {
    key: "point",
    type: "point",
    extendedProperties: EXTENDED_PROPERTIES,
    defaultShapeConfig: {
      shapeField: "circle"
    }
  },
  {
    key: "area",
    type: "area",
    extendedProperties: EXTENDED_PROPERTIES
  }
];
var SPECIAL_OPTIONS = [
  {
    key: "transform",
    callback: function(origin, key, value2) {
      var _a;
      origin[key] = origin[key] || [];
      var _b = value2.available, available = _b === void 0 ? true : _b, rest = __rest93(value2, ["available"]);
      if (available) {
        origin[key].push(__assign6((_a = {}, _a[TRANSFORM_SIGN] = true, _a), rest));
      } else {
        var index2 = origin[key].indexOf(function(item) {
          return item.type === value2.type;
        });
        if (index2 !== -1) {
          origin[key].splice(index2, 1);
        }
      }
    }
  },
  {
    key: "labels",
    callback: function(origin, key, value2) {
      var _a;
      if (!value2 || (0, import_lodash4.isArray)(value2)) {
        origin[key] = value2 ? value2 : [];
        return;
      }
      if (!value2.text) {
        value2["text"] = origin["yField"];
      }
      origin[key] = origin[key] || [];
      origin[key].push(__assign6((_a = {}, _a[TRANSFORM_SIGN] = true, _a), value2));
    }
  },
  {
    key: "transpose",
    callback: function(origin, key, value2) {
      var _a;
      if (value2.available) {
        origin["coordinate"] = {
          transform: [__assign6((_a = {}, _a[TRANSFORM_SIGN] = true, _a), value2)]
        };
      } else {
        origin["coordinate"] = {};
      }
    }
  }
];
var ANNOTATION_LIST = [
  {
    key: "conversionTag",
    shape: "ConversionTag"
  },
  {
    key: "axisText",
    shape: "BidirectionalBarAxisText"
  }
];

// node_modules/@ant-design/plots/es/core/annotation/shapes/Text.js
var __extends2 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign7 = function() {
  __assign7 = Object.assign || function(t) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t[p3] = s3[p3];
    }
    return t;
  };
  return __assign7.apply(this, arguments);
};
var __rest94 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var Text4 = (
  /** @class */
  function(_super) {
    __extends2(Text5, _super);
    function Text5(_a) {
      if (_a === void 0) {
        _a = {};
      }
      var style = _a.style, restOptions = __rest94(_a, ["style"]);
      return _super.call(this, __assign7({ style: __assign7({ text: "", fontSize: 12, textBaseline: "middle", textAlign: "center", fill: "#000", fontStyle: "normal", fontVariant: "normal", fontWeight: "normal", lineWidth: 1 }, style) }, restOptions)) || this;
    }
    return Text5;
  }(Text)
);

// node_modules/@ant-design/plots/es/core/annotation/shapes/Polygon.js
var __extends3 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign8 = function() {
  __assign8 = Object.assign || function(t) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t[p3] = s3[p3];
    }
    return t;
  };
  return __assign8.apply(this, arguments);
};
var __rest95 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var Polygon4 = (
  /** @class */
  function(_super) {
    __extends3(Polygon5, _super);
    function Polygon5(_a) {
      if (_a === void 0) {
        _a = {};
      }
      var style = _a.style, restOptions = __rest95(_a, ["style"]);
      return _super.call(this, __assign8({ style: __assign8({ fill: "#eee" }, style) }, restOptions)) || this;
    }
    return Polygon5;
  }(Polygon)
);

// node_modules/@ant-design/plots/es/core/annotation/core.js
var __extends4 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Annotation = (
  /** @class */
  function(_super) {
    __extends4(Annotation2, _super);
    function Annotation2(chart, config, defaultOptions) {
      var _this = _super.call(this, { style: mergeWithArrayCoverage(defaultOptions, config) }) || this;
      _this.chart = chart;
      return _this;
    }
    Annotation2.prototype.connectedCallback = function() {
      this.render(this.attributes, this);
      this.bindEvents(this.attributes, this);
    };
    Annotation2.prototype.disconnectedCallback = function() {
    };
    Annotation2.prototype.attributeChangedCallback = function(name2) {
    };
    Annotation2.prototype.update = function(attr, animate) {
      var _a;
      this.attr(mergeWithArrayCoverage({}, this.attributes, attr || {}));
      return (_a = this.render) === null || _a === void 0 ? void 0 : _a.call(this, this.attributes, this, animate);
    };
    Annotation2.prototype.clear = function() {
      this.removeChildren();
    };
    Annotation2.prototype.getElementsLayout = function() {
      var canvas = this.chart.getContext().canvas;
      var elements = canvas.document.getElementsByClassName("element");
      var elementsLayout = [];
      elements.forEach(function(element) {
        var bbox = element.getBBox();
        var x2 = bbox.x, y3 = bbox.y, width = bbox.width, height = bbox.height;
        var data = element["__data__"];
        elementsLayout.push({
          bbox,
          x: x2,
          y: y3,
          width,
          height,
          key: data.key,
          data
        });
      });
      return elementsLayout;
    };
    Annotation2.prototype.bindEvents = function(attributes, container) {
    };
    return Annotation2;
  }(CustomElement)
);

// node_modules/@ant-design/plots/es/core/annotation/conversion-tag.js
var __extends5 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign9 = function() {
  __assign9 = Object.assign || function(t) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t[p3] = s3[p3];
    }
    return t;
  };
  return __assign9.apply(this, arguments);
};
var ConversionTag = (
  /** @class */
  function(_super) {
    __extends5(ConversionTag2, _super);
    function ConversionTag2(chart, options) {
      return _super.call(this, chart, options, { type: ConversionTag2.tag }) || this;
    }
    ConversionTag2.prototype.getConversionTagLayout = function() {
      var isVertical2 = this.direction === "vertical";
      var elementsLayout = Array.from(this.getElementsLayout()).sort(function(a4, b) {
        if (isVertical2) {
          return a4.y - b.y;
        }
        return a4.x - b.x;
      });
      var _a = elementsLayout[0], firstX = _a.x, firstY = _a.y, firstHeight = _a.height, firstWidth = _a.width, firstData = _a.data;
      var valuePath = ["items", 0, "value"];
      var preValue = (0, import_lodash4.get)(firstData, valuePath);
      var elementDistance = isVertical2 ? elementsLayout[1].y - firstY - firstHeight : elementsLayout[1].x - firstX - firstWidth;
      var tagLayout = [];
      var _b = this.attributes, _c = _b.size, size4 = _c === void 0 ? 40 : _c, _d = _b.arrowSize, arrowSize = _d === void 0 ? 20 : _d, _e = _b.spacing, spacing = _e === void 0 ? 4 : _e;
      elementsLayout.forEach(function(element, index2) {
        if (index2 > 0) {
          var x2 = element.x, y3 = element.y, height = element.height, width = element.width, data = element.data, key = element.key;
          var currentValue = (0, import_lodash4.get)(data, valuePath);
          var halfSize = size4 / 2;
          if (isVertical2) {
            var arrowVertexX = x2 + width / 2;
            var arrowVertexY = y3;
            tagLayout.push({
              points: [
                [arrowVertexX + halfSize, arrowVertexY - elementDistance + spacing],
                [arrowVertexX + halfSize, arrowVertexY - arrowSize - spacing],
                [arrowVertexX, arrowVertexY - spacing],
                [arrowVertexX - halfSize, arrowVertexY - arrowSize - spacing],
                [arrowVertexX - halfSize, arrowVertexY - elementDistance + spacing]
              ],
              center: [arrowVertexX, arrowVertexY - elementDistance / 2],
              width: elementDistance,
              value: [preValue, currentValue],
              key
            });
          } else {
            var arrowVertexX = x2;
            var arrowVertexY = y3 + height / 2;
            tagLayout.push({
              points: [
                [x2 - elementDistance + spacing, arrowVertexY - halfSize],
                [x2 - arrowSize - spacing, arrowVertexY - halfSize],
                [arrowVertexX - spacing, arrowVertexY],
                [x2 - arrowSize - spacing, arrowVertexY + halfSize],
                [x2 - elementDistance + spacing, arrowVertexY + halfSize]
              ],
              center: [arrowVertexX - elementDistance / 2, arrowVertexY],
              width: elementDistance,
              value: [preValue, currentValue],
              key
            });
          }
          preValue = currentValue;
        }
      });
      return tagLayout;
    };
    ConversionTag2.prototype.render = function() {
      this.setDirection();
      this.drawConversionTag();
    };
    ConversionTag2.prototype.setDirection = function() {
      var coordinate = this.chart.getCoordinate();
      var transformations = (0, import_lodash4.get)(coordinate, "options.transformations");
      var direction2 = "horizontal";
      transformations.forEach(function(transformation) {
        if (transformation.includes("transpose")) {
          direction2 = "vertical";
        }
      });
      this.direction = direction2;
    };
    ConversionTag2.prototype.drawConversionTag = function() {
      var _this = this;
      var conversionLayout = this.getConversionTagLayout();
      var _a = this.attributes, style = _a.style, _b = _a.text, textStyle = _b.style, formatter = _b.formatter;
      conversionLayout.forEach(function(layout) {
        var points = layout.points, center2 = layout.center, value2 = layout.value, key = layout.key;
        var prev = value2[0], next = value2[1];
        var x2 = center2[0], y3 = center2[1];
        var polygon = new Polygon4({
          style: __assign9({ points, fill: "#eee" }, style),
          id: "polygon-".concat(key)
        });
        var text = new Text4({
          style: __assign9({ x: x2, y: y3, text: (0, import_lodash4.isFunction)(formatter) ? formatter(prev, next) : (next / prev * 100).toFixed(2) + "%" }, textStyle),
          id: "text-".concat(key)
        });
        _this.appendChild(polygon);
        _this.appendChild(text);
      });
    };
    ConversionTag2.prototype.update = function() {
      this.clear();
      this.drawConversionTag();
    };
    ConversionTag2.prototype.destroy = function() {
      this.clear();
    };
    ConversionTag2.tag = "ConversionTag";
    return ConversionTag2;
  }(Annotation)
);

// node_modules/@ant-design/plots/es/core/plots/bidirectional-bar/constants.js
var VERTICAL_MARGIN = 32;
var HORIZONTAL_MARGIN = 16;
var AXIS_LABEL_PADDING = 48;

// node_modules/@ant-design/plots/es/core/annotation/bidirectional-bar-axis-text.js
var __extends6 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign10 = function() {
  __assign10 = Object.assign || function(t) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t[p3] = s3[p3];
    }
    return t;
  };
  return __assign10.apply(this, arguments);
};
var __rest96 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var BidirectionalBarAxisText = (
  /** @class */
  function(_super) {
    __extends6(BidirectionalBarAxisText2, _super);
    function BidirectionalBarAxisText2(chart, options) {
      return _super.call(this, chart, options, { type: BidirectionalBarAxisText2.tag }) || this;
    }
    BidirectionalBarAxisText2.prototype.render = function() {
      this.drawText();
    };
    BidirectionalBarAxisText2.prototype.getBidirectionalBarAxisTextLayout = function() {
      var layout = this.attributes.layout;
      var isVertical2 = layout === "vertical";
      var allElementsLayout = this.getElementsLayout();
      var elementsLayout = isVertical2 ? (0, import_lodash4.uniqBy)(allElementsLayout, "x") : (0, import_lodash4.uniqBy)(allElementsLayout, "y");
      var textPath = ["title"];
      var textLayout = [];
      var views = this.chart.getContext().views;
      var _a = (0, import_lodash4.get)(views, [0, "layout"]), viewWidth = _a.width, viewHeight = _a.height;
      elementsLayout.forEach(function(element) {
        var x2 = element.x, y3 = element.y, height = element.height, width = element.width, data = element.data, key = element.key;
        var text = (0, import_lodash4.get)(data, textPath);
        if (isVertical2) {
          textLayout.push({
            x: x2 + width / 2,
            y: viewHeight,
            text,
            key
          });
        } else {
          textLayout.push({
            x: viewWidth,
            y: y3 + height / 2,
            text,
            key
          });
        }
      });
      if ((0, import_lodash4.uniqBy)(textLayout, "text").length !== textLayout.length) {
        textLayout = Object.values((0, import_lodash4.groupBy)(textLayout, "text")).map(function(items) {
          var _a2;
          var sum4 = items.reduce(function(pre, cur) {
            return pre + (isVertical2 ? cur.x : cur.y);
          }, 0);
          return __assign10(__assign10({}, items[0]), (_a2 = {}, _a2[isVertical2 ? "x" : "y"] = sum4 / items.length, _a2));
        });
      }
      return textLayout;
    };
    BidirectionalBarAxisText2.prototype.transformLabelStyle = function(style) {
      var removeLabel = {};
      var reg = /^label[A-Z]/;
      Object.keys(style).forEach(function(key) {
        if (reg.test(key)) {
          removeLabel[key.replace("label", "").replace(/^[A-Z]/, function(match) {
            return match.toLowerCase();
          })] = style[key];
        }
      });
      return removeLabel;
    };
    BidirectionalBarAxisText2.prototype.drawText = function() {
      var _this = this;
      var axisLayout = this.getBidirectionalBarAxisTextLayout();
      var _a = this.attributes, viewLayout = _a.layout, labelFormatter = _a.labelFormatter, textStyle = __rest96(_a, ["layout", "labelFormatter"]);
      axisLayout.forEach(function(layout) {
        var x2 = layout.x, y3 = layout.y, text = layout.text, key = layout.key;
        var textNode = new Text4({
          style: __assign10({ x: x2, y: y3, text: (0, import_lodash4.isFunction)(labelFormatter) ? labelFormatter(text) : text, wordWrap: true, wordWrapWidth: viewLayout === "horizontal" ? VERTICAL_MARGIN * 2 : 120, maxLines: 2, textOverflow: "ellipsis" }, _this.transformLabelStyle(textStyle)),
          id: "text-".concat(key)
        });
        _this.appendChild(textNode);
      });
    };
    BidirectionalBarAxisText2.prototype.destroy = function() {
      this.clear();
    };
    BidirectionalBarAxisText2.prototype.update = function() {
      this.destroy();
      this.drawText();
    };
    BidirectionalBarAxisText2.tag = "BidirectionalBarAxisText";
    return BidirectionalBarAxisText2;
  }(Annotation)
);

// node_modules/@ant-design/plots/es/core/annotation/index.js
var Annotaion = { ConversionTag, BidirectionalBarAxisText };
var Controller = (
  /** @class */
  function() {
    function Controller2(chart, config) {
      this.container = /* @__PURE__ */ new Map();
      this.chart = chart;
      this.config = config;
      this.init();
    }
    Controller2.prototype.init = function() {
      var _this = this;
      ANNOTATION_LIST.forEach(function(annotation) {
        var _a;
        var key = annotation.key, shape24 = annotation.shape;
        var annotationOptions = _this.config[key];
        if (annotationOptions) {
          var annotationInstance = new Annotaion[shape24](_this.chart, annotationOptions);
          var canvas = _this.chart.getContext().canvas;
          canvas.appendChild(annotationInstance);
          _this.container.set(key, annotationInstance);
        } else {
          (_a = _this.container.get(key)) === null || _a === void 0 ? void 0 : _a.clear();
        }
      });
    };
    Controller2.prototype.update = function() {
      var _this = this;
      if (!this.container.size)
        return;
      ANNOTATION_LIST.forEach(function(annotation) {
        var key = annotation.key;
        var annotationInstance = _this.container.get(key);
        annotationInstance === null || annotationInstance === void 0 ? void 0 : annotationInstance.update();
      });
    };
    Controller2.prototype.destroy = function() {
      this.container.forEach(function(annotationInstance) {
        annotationInstance.destroy();
      });
      this.container.clear();
    };
    return Controller2;
  }()
);

// node_modules/@ant-design/plots/es/core/base/index.js
var __extends7 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign11 = function() {
  __assign11 = Object.assign || function(t) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t[p3] = s3[p3];
    }
    return t;
  };
  return __assign11.apply(this, arguments);
};
var SOURCE_ATTRIBUTE_NAME = "data-chart-source-type";
var Plot = (
  /** @class */
  function(_super) {
    __extends7(Plot2, _super);
    function Plot2(container, options) {
      var _this = _super.call(this) || this;
      _this.eventListeners = [];
      _this.bindedEvents = false;
      _this.container = typeof container === "string" ? document.getElementById(container) : container;
      _this.options = _this.mergeOption(options);
      _this.createG2();
      _this.bindEvents();
      return _this;
    }
    Plot2.prototype.getChartOptions = function() {
      return __assign11(__assign11({}, (0, import_lodash4.pick)(this.options, CHART_OPTIONS)), { container: this.container });
    };
    Plot2.prototype.getSpecOptions = function() {
      if (this.type === "base" || this[SKIP_DEL_CUSTOM_SIGN]) {
        return __assign11(__assign11({}, this.options), this.getChartOptions());
      }
      return this.options;
    };
    Plot2.prototype.createG2 = function() {
      if (!this.container) {
        throw Error("The container is not initialized!");
      }
      this.chart = new Chart3(this.getChartOptions());
      this.container.setAttribute(SOURCE_ATTRIBUTE_NAME, "Ant Design Charts");
    };
    Plot2.prototype.bindEvents = function() {
      var _this = this;
      if (this.chart) {
        var eventHandler_1 = function(e3) {
          if (e3 === null || e3 === void 0 ? void 0 : e3.type) {
            _this.emit(e3.type, e3);
          }
        };
        this.chart.on("*", eventHandler_1);
        this.eventListeners.push(function() {
          var _a;
          (_a = _this.chart) === null || _a === void 0 ? void 0 : _a.off("*", eventHandler_1);
        });
      }
    };
    Plot2.prototype.getBaseOptions = function() {
      return { type: "view", autoFit: true };
    };
    Plot2.prototype.getDefaultOptions = function() {
    };
    Plot2.prototype.render = function() {
      var _this = this;
      if (this.type !== "base") {
        this.execAdaptor();
      }
      this.chart.options(this.getSpecOptions());
      this.chart.render().then(function() {
        if (_this.annotation) {
          _this.annotation.update();
        } else {
          _this.annotation = new Controller(_this.chart, _this.options);
        }
        _this.bindSizeSensor();
      });
    };
    Plot2.prototype.update = function(options) {
      this.options = this.mergeOption(options);
    };
    Plot2.prototype.mergeOption = function(options) {
      return mergeWithArrayCoverage({}, this.getBaseOptions(), this.getDefaultOptions(), options);
    };
    Plot2.prototype.changeData = function(data) {
      this.chart.changeData(data);
    };
    Plot2.prototype.changeSize = function(width, height) {
      this.chart.changeSize(width, height);
    };
    Plot2.prototype.destroy = function() {
      this.eventListeners.forEach(function(cleanup) {
        return cleanup();
      });
      this.eventListeners = [];
      if (this.annotation && typeof this.annotation.destroy === "function") {
        this.annotation.destroy();
      }
      this.annotation = null;
      this.chart.destroy();
      this.off();
      this.bindedEvents = false;
      this.container.removeAttribute(SOURCE_ATTRIBUTE_NAME);
    };
    Plot2.prototype.execAdaptor = function() {
      var adaptor33 = this.getSchemaAdaptor();
      adaptor33({
        chart: this.chart,
        options: this.options
      });
    };
    Plot2.prototype.triggerResize = function() {
      this.chart.forceFit();
    };
    Plot2.prototype.bindSizeSensor = function() {
      var _this = this;
      if (this.bindedEvents)
        return;
      var _a = this.options.autoFit, autoFit = _a === void 0 ? true : _a;
      if (autoFit) {
        var resizeHandler_1 = function() {
          if (_this.annotation) {
            _this.annotation.update();
          }
        };
        this.chart.on(ChartEvent.AFTER_CHANGE_SIZE, resizeHandler_1);
        this.eventListeners.push(function() {
          var _a2;
          (_a2 = _this.chart) === null || _a2 === void 0 ? void 0 : _a2.off(ChartEvent.AFTER_CHANGE_SIZE, resizeHandler_1);
        });
        this.bindedEvents = true;
      }
    };
    return Plot2;
  }(esm_default)
);

// node_modules/@ant-design/plots/es/core/plots/base/index.js
var __extends8 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Base3 = (
  /** @class */
  function(_super) {
    __extends8(Base4, _super);
    function Base4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "base";
      return _this;
    }
    Base4.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "line" }]
      };
    };
    Base4.prototype.getDefaultOptions = function() {
      return Base4.getDefaultOptions();
    };
    Base4.prototype.getSchemaAdaptor = function() {
      return function(params) {
        return params;
      };
    };
    return Base4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/adaptor/shape-stack.js
var __assign12 = function() {
  __assign12 = Object.assign || function(t) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t[p3] = s3[p3];
    }
    return t;
  };
  return __assign12.apply(this, arguments);
};
function shapeStack(params) {
  var options = params.options;
  var stack = options.stack, tooltip2 = options.tooltip, xField = options.xField;
  if (!stack)
    return params;
  var shapes = CONFIG_SHAPE.map(function(item) {
    return item.type;
  }).filter(function(item) {
    return !!item;
  });
  var hasStack = false;
  shapes.forEach(function(shape24) {
    if (options[shape24]) {
      hasStack = true;
      (0, import_lodash4.set)(options, [shape24, "stack"], __assign12({ y1: "y" }, typeof stack === "object" ? stack : {}));
    }
  });
  if (hasStack && !(0, import_lodash4.isBoolean)(tooltip2) && !tooltip2) {
    (0, import_lodash4.set)(options, "tooltip", {
      title: xField,
      items: [
        {
          channel: "y"
        }
      ]
    });
  }
  return params;
}

// node_modules/@ant-design/plots/es/core/adaptor/mark.js
function mark(params) {
  return (0, import_lodash4.flow)(shapeStack)(params);
}

// node_modules/@ant-design/plots/es/core/adaptor/coordinate-layout.js
function coordinateLayout(params) {
  var _a = params.options.layout, layout = _a === void 0 ? "horizontal" : _a;
  params.options.coordinate.transform = layout !== "horizontal" ? void 0 : [{ type: "transpose" }];
  return params;
}
function allCoordinateLayout(params) {
  coordinateLayout(params);
  var _a = params.options.layout, layout = _a === void 0 ? "horizontal" : _a;
  params.options.children.forEach(function(item) {
    var _a2;
    if ((_a2 = item === null || item === void 0 ? void 0 : item.coordinate) === null || _a2 === void 0 ? void 0 : _a2.transform) {
      item.coordinate.transform = layout !== "horizontal" ? void 0 : [{ type: "transpose" }];
    }
  });
  return params;
}

// node_modules/@ant-design/plots/es/core/plots/area/adaptor.js
function adaptor2(params) {
  return (0, import_lodash4.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/area/index.js
var __extends9 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Area3 = (
  /** @class */
  function(_super) {
    __extends9(Area4, _super);
    function Area4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "area";
      return _this;
    }
    Area4.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "area" }],
        scale: {
          y: { nice: true }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        interaction: {
          tooltip: {
            shared: true
          }
        }
      };
    };
    Area4.prototype.getDefaultOptions = function() {
      return Area4.getDefaultOptions();
    };
    Area4.prototype.getSchemaAdaptor = function() {
      return adaptor2;
    };
    return Area4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/bar/adaptor.js
var __assign13 = function() {
  __assign13 = Object.assign || function(t) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t[p3] = s3[p3];
    }
    return t;
  };
  return __assign13.apply(this, arguments);
};
function adaptor3(params) {
  var background = function(params2) {
    var options = params2.options;
    if ((0, import_lodash4.get)(options, "children.length") > 1) {
      (0, import_lodash4.set)(options, "children", [{ type: "interval" }]);
    }
    var scale4 = options.scale, markBackground = options.markBackground, data = options.data, children = options.children, yField = options.yField;
    var domain = (0, import_lodash4.get)(scale4, "y.domain", []);
    if (markBackground && domain.length && (0, import_lodash4.isArray)(data)) {
      var domainMax_1 = "domainMax";
      var backgroundData = data.map(function(item) {
        var _a;
        return __assign13(__assign13({ originData: __assign13({}, item) }, (0, import_lodash4.omit)(item, yField)), (_a = {}, _a[domainMax_1] = domain[domain.length - 1], _a));
      });
      children.unshift(__assign13({ type: "interval", data: backgroundData, yField: domainMax_1, tooltip: false, style: {
        fill: "#eee"
      }, label: false }, markBackground));
    }
    return params2;
  };
  return (0, import_lodash4.flow)(background, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/bar/shape.js
var reisterShape = function() {
  var draw25DBar = function(style, context) {
    return function(points) {
      var _a = style.fill, fill = _a === void 0 ? "#2888FF" : _a, stroke2 = style.stroke, _b = style.fillOpacity, fillOpacity = _b === void 0 ? 1 : _b, _c = style.strokeOpacity, strokeOpacity = _c === void 0 ? 0.2 : _c, _d = style.pitch, pitch = _d === void 0 ? 8 : _d;
      var p1 = points[0], p22 = points[1], p3 = points[2], p4 = points[3];
      var height = (p22[1] - p1[1]) / 2;
      var document2 = context.document;
      var g = document2.createElement("g", {});
      var top = document2.createElement("polygon", {
        style: {
          points: [p1, [p1[0] - pitch, p1[1] + height], [p3[0] - pitch, p1[1] + height], p4],
          fill,
          fillOpacity,
          stroke: stroke2,
          strokeOpacity,
          inset: 30
        }
      });
      var bottom = document2.createElement("polygon", {
        style: {
          points: [[p1[0] - pitch, p1[1] + height], p22, p3, [p3[0] - pitch, p1[1] + height]],
          fill,
          fillOpacity,
          stroke: stroke2,
          strokeOpacity
        }
      });
      var right2 = document2.createElement("polygon", {
        style: {
          points: [p1, [p1[0] - pitch, p1[1] + height], p22, [p1[0] + pitch, p1[1] + height]],
          fill,
          fillOpacity: fillOpacity - 0.2
        }
      });
      g.appendChild(top);
      g.appendChild(bottom);
      g.appendChild(right2);
      return g;
    };
  };
  register("shape.interval.bar25D", draw25DBar);
};

// node_modules/@ant-design/plots/es/core/plots/bar/index.js
var __extends10 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
reisterShape();
var Bar = (
  /** @class */
  function(_super) {
    __extends10(Bar2, _super);
    function Bar2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "Bar";
      return _this;
    }
    Bar2.getDefaultOptions = function() {
      return {
        type: "view",
        coordinate: { transform: [{ type: "transpose" }] },
        children: [{ type: "interval" }],
        scale: {
          y: { nice: true }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        interaction: {
          tooltip: {
            shared: true
          },
          elementHighlight: {
            background: true
          }
        }
      };
    };
    Bar2.prototype.getDefaultOptions = function() {
      return Bar2.getDefaultOptions();
    };
    Bar2.prototype.getSchemaAdaptor = function() {
      return adaptor3;
    };
    return Bar2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/column/shape.js
var reisterShape2 = function() {
  var draw25DColumn = function(style, context) {
    return function(points) {
      var _a = style.fill, fill = _a === void 0 ? "#2888FF" : _a, stroke2 = style.stroke, _b = style.fillOpacity, fillOpacity = _b === void 0 ? 1 : _b, _c = style.strokeOpacity, strokeOpacity = _c === void 0 ? 0.2 : _c, _d = style.pitch, pitch = _d === void 0 ? 8 : _d;
      var x3 = points[1][0] - points[0][0];
      var x4 = x3 / 2 + points[0][0];
      var document2 = context.document;
      var g = document2.createElement("g", {});
      var left2 = document2.createElement("polygon", {
        style: {
          points: [
            [points[0][0], points[0][1]],
            [x4, points[1][1] + pitch],
            [x4, points[3][1] + pitch],
            [points[3][0], points[3][1]]
          ],
          fill,
          fillOpacity,
          stroke: stroke2,
          strokeOpacity,
          inset: 30
        }
      });
      var right2 = document2.createElement("polygon", {
        style: {
          points: [
            [x4, points[1][1] + pitch],
            [points[1][0], points[1][1]],
            [points[2][0], points[2][1]],
            [x4, points[2][1] + pitch]
          ],
          fill,
          fillOpacity,
          stroke: stroke2,
          strokeOpacity
        }
      });
      var top = document2.createElement("polygon", {
        style: {
          points: [
            [points[0][0], points[0][1]],
            [x4, points[1][1] - pitch],
            [points[1][0], points[1][1]],
            [x4, points[1][1] + pitch]
          ],
          fill,
          fillOpacity: fillOpacity - 0.2
        }
      });
      g.appendChild(right2);
      g.appendChild(left2);
      g.appendChild(top);
      return g;
    };
  };
  register("shape.interval.column25D", draw25DColumn);
};

// node_modules/@ant-design/plots/es/core/plots/column/index.js
var __extends11 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
reisterShape2();
var Column2 = (
  /** @class */
  function(_super) {
    __extends11(Column3, _super);
    function Column3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "column";
      return _this;
    }
    Column3.getDefaultOptions = function() {
      return {
        type: "view",
        scale: {
          y: { nice: true }
        },
        interaction: {
          tooltip: {
            shared: true
          },
          elementHighlight: {
            background: true
          }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        children: [
          {
            type: "interval"
          }
        ]
      };
    };
    Column3.prototype.getDefaultOptions = function() {
      return Column3.getDefaultOptions();
    };
    Column3.prototype.getSchemaAdaptor = function() {
      return adaptor3;
    };
    return Column3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/dual-axes/adaptor.js
function adaptor4(params) {
  var colorField = function(params2) {
    var options = params2.options;
    var _a = options.children, children = _a === void 0 ? [] : _a, legend = options.legend;
    if (!legend)
      return params2;
    children.forEach(function(option) {
      if (!(0, import_lodash4.get)(option, "colorField")) {
        var yField_1 = (0, import_lodash4.get)(option, "yField");
        (0, import_lodash4.set)(option, "colorField", function() {
          return yField_1;
        });
      }
    });
    return params2;
  };
  var annotations = function(params2) {
    var options = params2.options;
    var _a = options.annotations, annotations2 = _a === void 0 ? [] : _a, _b = options.children, children = _b === void 0 ? [] : _b, scale4 = options.scale;
    var sharedScale = false;
    if ((0, import_lodash4.get)(scale4, "y.key")) {
      return params2;
    }
    children.forEach(function(child, index2) {
      if (!(0, import_lodash4.get)(child, "scale.y.key")) {
        var scaleKey_1 = "child".concat(index2, "Scale");
        (0, import_lodash4.set)(child, "scale.y.key", scaleKey_1);
        var _a2 = child.annotations, childAnnotations = _a2 === void 0 ? [] : _a2;
        if (childAnnotations.length > 0) {
          (0, import_lodash4.set)(child, "scale.y.independent", false);
          childAnnotations.forEach(function(annotation) {
            (0, import_lodash4.set)(annotation, "scale.y.key", scaleKey_1);
          });
        }
        if (!sharedScale && annotations2.length > 0 && (0, import_lodash4.get)(child, "scale.y.independent") === void 0) {
          sharedScale = true;
          (0, import_lodash4.set)(child, "scale.y.independent", false);
          annotations2.forEach(function(annotation) {
            (0, import_lodash4.set)(annotation, "scale.y.key", scaleKey_1);
          });
        }
      }
    });
    return params2;
  };
  return (0, import_lodash4.flow)(colorField, annotations, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/dual-axes/index.js
var __extends12 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DualAxes = (
  /** @class */
  function(_super) {
    __extends12(DualAxes2, _super);
    function DualAxes2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "DualAxes";
      return _this;
    }
    DualAxes2.getDefaultOptions = function() {
      return {
        type: "view",
        axis: {
          y: { title: false, tick: false },
          x: { title: false }
        },
        scale: {
          y: {
            independent: true,
            nice: true
          }
        }
      };
    };
    DualAxes2.prototype.getDefaultOptions = function() {
      return DualAxes2.getDefaultOptions();
    };
    DualAxes2.prototype.getSchemaAdaptor = function() {
      return adaptor4;
    };
    return DualAxes2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/funnel/adaptor.js
function adaptor5(params) {
  var init = function(params2) {
    var options = params2.options;
    var xField = options.xField, colorField = options.colorField;
    if (!colorField) {
      (0, import_lodash4.set)(options, "colorField", xField);
    }
    return params2;
  };
  var transform2 = function(params2) {
    var options = params2.options;
    var compareField = options.compareField, transform3 = options.transform, _a = options.isTransposed, isTransposed = _a === void 0 ? true : _a, coordinate = options.coordinate;
    if (!transform3) {
      if (compareField) {
        (0, import_lodash4.set)(options, "transform", []);
      } else {
        (0, import_lodash4.set)(options, "transform", [{ type: "symmetryY" }]);
      }
    }
    if (!coordinate && isTransposed) {
      (0, import_lodash4.set)(options, "coordinate", { transform: [{ type: "transpose" }] });
    }
    return params2;
  };
  var compare = function(params2) {
    var options = params2.options;
    var compareField = options.compareField, seriesField = options.seriesField, data = options.data, children = options.children, yField = options.yField, _a = options.isTransposed, isTransposed = _a === void 0 ? true : _a;
    if (compareField || seriesField) {
      var groupedData = Object.values((0, import_lodash4.groupBy)(data, function(item) {
        return item[compareField || seriesField];
      }));
      children[0].data = groupedData[0];
      children.push({
        type: "interval",
        data: groupedData[1],
        // @ts-ignore
        yField: function(item) {
          return -item[yField];
        }
      });
      delete options["compareField"];
      delete options.data;
    }
    if (seriesField) {
      (0, import_lodash4.set)(options, "type", "spaceFlex");
      (0, import_lodash4.set)(options, "ratio", [1, 1]);
      (0, import_lodash4.set)(options, "direction", isTransposed ? "row" : "col");
      delete options["seriesField"];
    }
    return params2;
  };
  var tooltip2 = function(params2) {
    var options = params2.options;
    var tooltip3 = options.tooltip, xField = options.xField, yField = options.yField;
    if (!tooltip3) {
      (0, import_lodash4.set)(options, "tooltip", {
        title: false,
        items: [
          function(d3) {
            return { name: d3[xField], value: d3[yField] };
          }
        ]
      });
    }
    return params2;
  };
  return (0, import_lodash4.flow)(init, transform2, compare, tooltip2, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/funnel/index.js
var __extends13 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Funnel2 = (
  /** @class */
  function(_super) {
    __extends13(Funnel3, _super);
    function Funnel3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "column";
      return _this;
    }
    Funnel3.getDefaultOptions = function() {
      return {
        type: "view",
        scale: { x: { padding: 0 } },
        animate: { enter: { type: "fadeIn" } },
        axis: false,
        shapeField: "funnel",
        label: {
          position: "inside",
          transform: [{ type: "contrastReverse" }]
        },
        children: [
          {
            type: "interval"
          }
        ]
      };
    };
    Funnel3.prototype.getDefaultOptions = function() {
      return Funnel3.getDefaultOptions();
    };
    Funnel3.prototype.getSchemaAdaptor = function() {
      return adaptor5;
    };
    return Funnel3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/line/adaptor.js
function adaptor6(params) {
  return (0, import_lodash4.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/line/index.js
var __extends14 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Line6 = (
  /** @class */
  function(_super) {
    __extends14(Line7, _super);
    function Line7() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "line";
      return _this;
    }
    Line7.getDefaultOptions = function() {
      return {
        type: "view",
        scale: {
          y: { nice: true }
        },
        interaction: {
          tooltip: {
            shared: true
          }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        // - 
        // animate: {
        //   enter: { type: 'growInX' },
        // },
        children: [{ type: "line" }]
      };
    };
    Line7.prototype.getDefaultOptions = function() {
      return Line7.getDefaultOptions();
    };
    Line7.prototype.getSchemaAdaptor = function() {
      return adaptor6;
    };
    return Line7;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/pie/adaptor.js
var __assign14 = function() {
  __assign14 = Object.assign || function(t) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t[p3] = s3[p3];
    }
    return t;
  };
  return __assign14.apply(this, arguments);
};
function adaptor7(params) {
  var emptyData = function(params2) {
    var options = params2.options;
    var angleField = options.angleField, data = options.data, label = options.label, tooltip2 = options.tooltip, colorField = options.colorField;
    var getColorValue = fieldAdapter(colorField);
    if ((0, import_lodash4.isArray)(data) && data.length > 0) {
      var sum4 = data.reduce(function(a4, b) {
        return a4 + b[angleField];
      }, 0);
      if (sum4 === 0) {
        var normalization = data.map(function(item) {
          var _a;
          return __assign14(__assign14({}, item), (_a = {}, _a[angleField] = 1, _a));
        });
        (0, import_lodash4.set)(options, "data", normalization);
        if (label) {
          var isColorField = colorField === (0, import_lodash4.get)(label, "text");
          (0, import_lodash4.set)(options, "label", __assign14(__assign14({}, label), isColorField ? {} : { formatter: function() {
            return 0;
          } }));
        }
        if (tooltip2 !== false) {
          if ((0, import_lodash4.isFunction)(tooltip2)) {
            (0, import_lodash4.set)(options, "tooltip", function(arg, index2, items) {
              var _a;
              return tooltip2(__assign14(__assign14({}, arg), (_a = {}, _a[angleField] = 0, _a)), index2, items.map(function(item) {
                var _a2;
                return __assign14(__assign14({}, item), (_a2 = {}, _a2[angleField] = 0, _a2));
              }));
            });
          } else {
            (0, import_lodash4.set)(options, "tooltip", __assign14(__assign14({}, tooltip2), { items: [
              function(arg, i2, d3) {
                return {
                  name: getColorValue(arg, i2, d3),
                  value: 0
                };
              }
            ] }));
          }
        }
      }
    }
    return params2;
  };
  return (0, import_lodash4.flow)(emptyData, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/pie/index.js
var __extends15 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Pie = (
  /** @class */
  function(_super) {
    __extends15(Pie2, _super);
    function Pie2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "pie";
      return _this;
    }
    Pie2.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "interval" }],
        coordinate: { type: "theta" },
        transform: [{ type: "stackY", reverse: true }],
        animate: { enter: { type: "waveIn" } }
      };
    };
    Pie2.prototype.getDefaultOptions = function() {
      return Pie2.getDefaultOptions();
    };
    Pie2.prototype.getSchemaAdaptor = function() {
      return adaptor7;
    };
    return Pie2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/scatter/adaptor.js
function adaptor8(params) {
  return (0, import_lodash4.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/scatter/index.js
var __extends16 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Scatter = (
  /** @class */
  function(_super) {
    __extends16(Scatter2, _super);
    function Scatter2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "scatter";
      return _this;
    }
    Scatter2.getDefaultOptions = function() {
      return {
        axis: {
          y: { title: false },
          x: { title: false }
        },
        legend: {
          size: false
        },
        children: [{ type: "point" }]
      };
    };
    Scatter2.prototype.getDefaultOptions = function() {
      return Scatter2.getDefaultOptions();
    };
    Scatter2.prototype.getSchemaAdaptor = function() {
      return adaptor8;
    };
    return Scatter2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/radar/adaptor.js
function adaptor9(params) {
  var init = function(params2) {
    (0, import_lodash4.set)(params2, "options.coordinate", { type: (0, import_lodash4.get)(params2, "options.coordinateType", "polar") });
    return params2;
  };
  return (0, import_lodash4.flow)(init, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/radar/index.js
var __extends17 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Radar2 = (
  /** @class */
  function(_super) {
    __extends17(Radar3, _super);
    function Radar3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "radar";
      return _this;
    }
    Radar3.getDefaultOptions = function() {
      return {
        axis: {
          x: { grid: true, line: true },
          y: { zIndex: 1, title: false, line: true, nice: true }
        },
        meta: { x: { padding: 0.5, align: 0 } },
        interaction: { tooltip: { style: { crosshairsLineDash: [4, 4] } } },
        children: [{ type: "line" }],
        //   polar  radar 
        coordinateType: "polar"
      };
    };
    Radar3.prototype.getDefaultOptions = function() {
      return Radar3.getDefaultOptions();
    };
    Radar3.prototype.getSchemaAdaptor = function() {
      return adaptor9;
    };
    return Radar3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/stock/adaptor.js
function adaptor10(params) {
  var init = function(params2) {
    var options = params2.options;
    var yField = options.yField, children = options.children, _a = options.style, style = _a === void 0 ? {} : _a, _b = options.lineStyle, lineStyle = _b === void 0 ? {} : _b;
    var open = yField[0], close = yField[1], high = yField[2], low = yField[3];
    (0, import_lodash4.set)(children, [0, "yField"], [high, low]);
    (0, import_lodash4.set)(children, [0, "style"], lineStyle);
    (0, import_lodash4.set)(children, [1, "yField"], [open, close]);
    (0, import_lodash4.set)(children, [1, "style"], style);
    delete options.yField;
    delete options.lineStyle;
    delete options.style;
    return params2;
  };
  return (0, import_lodash4.flow)(init, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/stock/index.js
var __extends18 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DEFAULT_COLORS = ["#26a69a", "#999999", "#ef5350"];
var Stock = (
  /** @class */
  function(_super) {
    __extends18(Stock2, _super);
    function Stock2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "stock";
      return _this;
    }
    Stock2.getDefaultOptions = function() {
      return {
        type: "view",
        scale: {
          color: {
            domain: [-1, 0, 1],
            range: DEFAULT_COLORS
          },
          y: { nice: true }
        },
        children: [
          // line shadow
          {
            type: "link"
          },
          {
            type: "interval"
          }
        ],
        axis: {
          x: { title: false, grid: false },
          y: { title: false, grid: true, gridLineDash: null }
        },
        animate: { enter: { type: "scaleInY" } },
        interaction: {
          tooltip: {
            shared: true,
            marker: false,
            groupName: false,
            crosshairs: true
          }
        }
      };
    };
    Stock2.prototype.getDefaultOptions = function() {
      return Stock2.getDefaultOptions();
    };
    Stock2.prototype.getSchemaAdaptor = function() {
      return adaptor10;
    };
    return Stock2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-line/adaptor.js
function adaptor11(params) {
  return (0, import_lodash4.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-line/index.js
var __extends19 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyLine = (
  /** @class */
  function(_super) {
    __extends19(TinyLine2, _super);
    function TinyLine2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "TinyLine";
      return _this;
    }
    TinyLine2.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "line", axis: false }],
        // - 
        // animate: {
        //   enter: { type: 'growInX', duration: 500 },
        // },
        padding: 0,
        margin: 0,
        tooltip: false
      };
    };
    TinyLine2.prototype.getDefaultOptions = function() {
      return TinyLine2.getDefaultOptions();
    };
    TinyLine2.prototype.getSchemaAdaptor = function() {
      return adaptor11;
    };
    return TinyLine2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-area/adaptor.js
function adaptor12(params) {
  return (0, import_lodash4.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-area/index.js
var __extends20 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyArea = (
  /** @class */
  function(_super) {
    __extends20(TinyArea2, _super);
    function TinyArea2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "TinyArea";
      return _this;
    }
    TinyArea2.getDefaultOptions = function() {
      return {
        type: "view",
        animate: {
          enter: { type: "growInX", duration: 500 }
        },
        children: [{ type: "area", axis: false }],
        padding: 0,
        margin: 0,
        tooltip: false
      };
    };
    TinyArea2.prototype.getDefaultOptions = function() {
      return TinyArea2.getDefaultOptions();
    };
    TinyArea2.prototype.getSchemaAdaptor = function() {
      return adaptor12;
    };
    return TinyArea2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-column/adaptor.js
function adaptor13(params) {
  return (0, import_lodash4.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-column/index.js
var __extends21 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyColumn = (
  /** @class */
  function(_super) {
    __extends21(TinyColumn2, _super);
    function TinyColumn2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "TinyColumn";
      return _this;
    }
    TinyColumn2.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "interval", axis: false }],
        padding: 0,
        margin: 0,
        tooltip: false
      };
    };
    TinyColumn2.prototype.getDefaultOptions = function() {
      return TinyColumn2.getDefaultOptions();
    };
    TinyColumn2.prototype.getSchemaAdaptor = function() {
      return adaptor13;
    };
    return TinyColumn2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-progress/adaptor.js
var __assign15 = function() {
  __assign15 = Object.assign || function(t) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t[p3] = s3[p3];
    }
    return t;
  };
  return __assign15.apply(this, arguments);
};
function adaptor14(params) {
  var transformData3 = function(params2) {
    var options = params2.options;
    var percent = options.percent, _a = options.color, color = _a === void 0 ? [] : _a;
    if (!percent)
      return params2;
    var transformOption = {
      scale: {
        color: { range: color.length ? color : [] }
      },
      data: [1, percent]
    };
    Object.assign(options, __assign15({}, transformOption));
    return params2;
  };
  return (0, import_lodash4.flow)(transformData3, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-progress/index.js
var __extends22 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyProgress = (
  /** @class */
  function(_super) {
    __extends22(TinyProgress2, _super);
    function TinyProgress2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "TinyProgress";
      return _this;
    }
    TinyProgress2.getDefaultOptions = function() {
      return {
        type: "view",
        data: [],
        margin: 0,
        padding: 0,
        tooltip: false,
        children: [
          {
            interaction: { tooltip: false },
            coordinate: { transform: [{ type: "transpose" }] },
            type: "interval",
            axis: false,
            legend: false,
            encode: { y: function(d3) {
              return d3;
            }, color: function(d3, idx) {
              return idx;
            } }
          }
        ]
      };
    };
    TinyProgress2.prototype.getDefaultOptions = function() {
      return TinyProgress2.getDefaultOptions();
    };
    TinyProgress2.prototype.getSchemaAdaptor = function() {
      return adaptor14;
    };
    return TinyProgress2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-ring/adaptor.js
var __assign16 = function() {
  __assign16 = Object.assign || function(t) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t[p3] = s3[p3];
    }
    return t;
  };
  return __assign16.apply(this, arguments);
};
function adaptor15(params) {
  var radius = function(params2) {
    var options = params2.options;
    var _a = options.radius, radius2 = _a === void 0 ? 0.8 : _a;
    (0, import_lodash4.set)(params2, "options.coordinate.innerRadius", radius2);
    return params2;
  };
  var transformData3 = function(params2) {
    var options = params2.options;
    var percent = options.percent, _a = options.color, color = _a === void 0 ? [] : _a;
    if (!percent)
      return params2;
    var transformOption = {
      scale: {
        color: { range: color.length ? color : [] }
      },
      data: [1, percent]
    };
    Object.assign(options, __assign16({}, transformOption));
    return params2;
  };
  return (0, import_lodash4.flow)(radius, transformData3, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-ring/index.js
var __extends23 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyRing = (
  /** @class */
  function(_super) {
    __extends23(TinyRing2, _super);
    function TinyRing2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "TinyRing";
      return _this;
    }
    TinyRing2.getDefaultOptions = function() {
      return {
        type: "view",
        data: [],
        margin: 0,
        padding: 0,
        coordinate: { type: "theta" },
        animate: { enter: { type: "waveIn" } },
        interaction: { tooltip: false },
        tooltip: false,
        children: [
          {
            type: "interval",
            axis: false,
            legend: false,
            encode: { y: function(d3) {
              return d3;
            }, color: function(d3, idx) {
              return idx;
            } }
          }
        ]
      };
    };
    TinyRing2.prototype.getDefaultOptions = function() {
      return TinyRing2.getDefaultOptions();
    };
    TinyRing2.prototype.getSchemaAdaptor = function() {
      return adaptor15;
    };
    return TinyRing2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/rose/adaptor.js
function adaptor16(params) {
  return (0, import_lodash4.flow)(transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/rose/index.js
var __extends24 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Rose = (
  /** @class */
  function(_super) {
    __extends24(Rose2, _super);
    function Rose2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "rose";
      return _this;
    }
    Rose2.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "interval" }],
        coordinate: { type: "polar" },
        animate: { enter: { type: "waveIn" } }
      };
    };
    Rose2.prototype.getDefaultOptions = function() {
      return Rose2.getDefaultOptions();
    };
    Rose2.prototype.getSchemaAdaptor = function() {
      return adaptor16;
    };
    return Rose2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/waterfall/constants.js
var START_KEY = "__start__";
var END_KEY = "__end__";
var WATERFALL_VALUE = "__waterfall_value__";

// node_modules/@ant-design/plots/es/core/plots/waterfall/adaptor.js
var __assign17 = function() {
  __assign17 = Object.assign || function(t) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t[p3] = s3[p3];
    }
    return t;
  };
  return __assign17.apply(this, arguments);
};
var __spreadArray9 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function adaptor17(params) {
  var transformData3 = function(params2) {
    var options = params2.options;
    var _a = options.data, data = _a === void 0 ? [] : _a, yField = options.yField;
    if (!data.length)
      return params2;
    data.reduce(function(prev, cur, index2) {
      var _a2;
      var getFieldData = fieldAdapter(yField);
      var newCur = getFieldData(cur, index2, data);
      if (index2 === 0 || cur.isTotal) {
        cur[START_KEY] = 0;
        cur[END_KEY] = newCur;
        cur[WATERFALL_VALUE] = newCur;
      } else {
        var start = (_a2 = prev[END_KEY]) !== null && _a2 !== void 0 ? _a2 : getFieldData(prev, index2, data);
        cur[START_KEY] = start;
        cur[END_KEY] = start + newCur;
        cur[WATERFALL_VALUE] = prev[END_KEY];
      }
      return cur;
    }, []);
    Object.assign(options, { yField: [START_KEY, END_KEY] });
    return params2;
  };
  var link3 = function(params2) {
    var options = params2.options;
    var _a = options.data, data = _a === void 0 ? [] : _a, xField = options.xField, children = options.children, linkStyle = options.linkStyle;
    var linkData = __spreadArray9([], data, true);
    linkData.reduce(function(prev, cur, index2) {
      if (index2 > 0) {
        cur.x1 = prev[xField];
        cur.x2 = cur[xField];
        cur.y1 = prev[END_KEY];
      }
      return cur;
    }, []);
    linkData.shift();
    children.push({
      type: "link",
      xField: ["x1", "x2"],
      yField: "y1",
      //  scrollbar  link  interval
      zIndex: -1,
      data: linkData,
      style: __assign17({ stroke: "#697474" }, linkStyle),
      label: false,
      tooltip: false
    });
    return params2;
  };
  var connectorTransform = function(params2) {
    var options = params2.options;
    var _a = options.data, data = _a === void 0 ? [] : _a, connector = options.connector;
    if (!connector)
      return params2;
    (0, import_lodash4.set)(options, "connector", __assign17({ xField: connector.reverse ? ["x2", "x1"] : ["x1", "x2"], yField: connector.reverse ? ["y2", "y1"] : ["y1", "y2"], data: [
      {
        x1: data[0].x,
        y1: data[0][END_KEY],
        x2: data[data.length - 1].x,
        y2: data[data.length - 1][END_KEY]
      }
    ] }, (0, import_lodash4.isObject)(connector) ? connector : {}));
    return params2;
  };
  return (0, import_lodash4.flow)(transformData3, link3, mark, connectorTransform, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/waterfall/index.js
var __extends25 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Waterfall = (
  /** @class */
  function(_super) {
    __extends25(Waterfall2, _super);
    function Waterfall2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "waterfall";
      return _this;
    }
    Waterfall2.getDefaultOptions = function() {
      return {
        type: "view",
        legend: null,
        tooltip: {
          field: WATERFALL_VALUE,
          valueFormatter: "~s",
          name: "value"
        },
        axis: {
          y: {
            title: null,
            labelFormatter: "~s"
          },
          x: {
            title: null
          }
        },
        children: [
          {
            type: "interval",
            interaction: {
              elementHighlight: {
                background: true
              }
            }
          }
        ]
      };
    };
    Waterfall2.prototype.getDefaultOptions = function() {
      return Waterfall2.getDefaultOptions();
    };
    Waterfall2.prototype.getSchemaAdaptor = function() {
      return adaptor17;
    };
    return Waterfall2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/histogram/adaptor.js
function adaptor18(params) {
  var transformHistogramConfig = function(params2) {
    var options = params2.options;
    var data = options.data, binNumber = options.binNumber, binWidth = options.binWidth, children = options.children, _a = options.channel, channel = _a === void 0 ? "count" : _a;
    var targetTransform = (0, import_lodash4.get)(children, "[0].transform[0]", {});
    if ((0, import_lodash4.isNumber)(binWidth)) {
      (0, import_lodash4.assign)(targetTransform, { thresholds: (0, import_lodash4.ceil)((0, import_lodash4.divide)(data.length, binWidth)), y: channel });
      return params2;
    }
    if ((0, import_lodash4.isNumber)(binNumber)) {
      (0, import_lodash4.assign)(targetTransform, { thresholds: binNumber, y: channel });
      return params2;
    }
    return params2;
  };
  return (0, import_lodash4.flow)(transformHistogramConfig, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/histogram/index.js
var __extends26 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Histogram = (
  /** @class */
  function(_super) {
    __extends26(Histogram2, _super);
    function Histogram2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "Histogram";
      return _this;
    }
    Histogram2.getDefaultOptions = function() {
      return {
        type: "view",
        autoFit: true,
        axis: {
          y: { title: false },
          x: { title: false }
        },
        children: [
          {
            type: "rect",
            transform: [{ type: "binX", y: "count" }],
            interaction: {
              elementHighlight: {
                background: true
              }
            }
          }
        ]
      };
    };
    Histogram2.prototype.getDefaultOptions = function() {
      return Histogram2.getDefaultOptions();
    };
    Histogram2.prototype.getSchemaAdaptor = function() {
      return adaptor18;
    };
    return Histogram2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/heatmap/adaptor.js
function adaptor19(params) {
  var tooltip2 = function(params2) {
    var options = params2.options;
    var _a = options.tooltip, tooltip3 = _a === void 0 ? {} : _a, colorField = options.colorField, sizeField = options.sizeField;
    if (tooltip3 && !tooltip3.field) {
      tooltip3.field = colorField || sizeField;
    }
    return params2;
  };
  var transformMark = function(params2) {
    var options = params2.options;
    var mark2 = options.mark, children = options.children;
    if (mark2) {
      children[0].type = mark2;
    }
    return params2;
  };
  return (0, import_lodash4.flow)(tooltip2, transformMark, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/heatmap/index.js
var __extends27 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Heatmap3 = (
  /** @class */
  function(_super) {
    __extends27(Heatmap4, _super);
    function Heatmap4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "heatmap";
      return _this;
    }
    Heatmap4.getDefaultOptions = function() {
      return {
        type: "view",
        legend: null,
        tooltip: {
          valueFormatter: "~s"
        },
        axis: {
          y: {
            title: null,
            grid: true
          },
          x: {
            title: null,
            grid: true
          }
        },
        children: [
          {
            type: "point"
          }
        ]
      };
    };
    Heatmap4.prototype.getDefaultOptions = function() {
      return Heatmap4.getDefaultOptions();
    };
    Heatmap4.prototype.getSchemaAdaptor = function() {
      return adaptor19;
    };
    return Heatmap4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/box/adaptor.js
function adaptor20(params) {
  var init = function(params2) {
    var _a = params2.options.boxType, boxType = _a === void 0 ? "box" : _a;
    params2.options.children[0].type = boxType;
    return params2;
  };
  return (0, import_lodash4.flow)(init, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/box/index.js
var __extends28 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Box3 = (
  /** @class */
  function(_super) {
    __extends28(Box4, _super);
    function Box4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "box";
      return _this;
    }
    Box4.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "box" }],
        axis: {
          y: { title: false },
          x: { title: false }
        },
        //  tooltip
        tooltip: {
          items: [
            { name: "min", channel: "y" },
            { name: "q1", channel: "y1" },
            { name: "q2", channel: "y2" },
            { name: "q3", channel: "y3" },
            { name: "max", channel: "y4" }
          ]
        }
      };
    };
    Box4.prototype.getDefaultOptions = function() {
      return Box4.getDefaultOptions();
    };
    Box4.prototype.getSchemaAdaptor = function() {
      return adaptor20;
    };
    return Box4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/sankey/adaptor.js
var defaultTransform = function(params) {
  var options = params.options;
  var data = options.data;
  var transformLinks = [
    {
      type: "custom",
      callback: function(datum) {
        return { links: datum };
      }
    }
  ];
  if ((0, import_lodash4.isArray)(data)) {
    if (data.length > 0) {
      (0, import_lodash4.set)(options, "data", {
        value: data,
        transform: transformLinks
      });
    } else {
      delete options.children;
    }
  } else if ((0, import_lodash4.get)(data, "type") === "fetch" && (0, import_lodash4.get)(data, "value")) {
    var transform2 = (0, import_lodash4.get)(data, "transform");
    if (!(0, import_lodash4.isArray)(transform2)) {
      (0, import_lodash4.set)(data, "transform", transformLinks);
    }
  }
  return params;
};
function adaptor21(params) {
  return (0, import_lodash4.flow)(dataTransform4, defaultTransform, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/sankey/index.js
var __extends29 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Sankey4 = (
  /** @class */
  function(_super) {
    __extends29(Sankey5, _super);
    function Sankey5() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "sankey";
      return _this;
    }
    Sankey5.getDefaultOptions = function() {
      return { type: "view", children: [{ type: "sankey" }] };
    };
    Sankey5.prototype.getDefaultOptions = function() {
      return Sankey5.getDefaultOptions();
    };
    Sankey5.prototype.getSchemaAdaptor = function() {
      return adaptor21;
    };
    return Sankey5;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/bullet/adaptor.js
var __assign18 = function() {
  __assign18 = Object.assign || function(t) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t[p3] = s3[p3];
    }
    return t;
  };
  return __assign18.apply(this, arguments);
};
var DEFAULT_COLORS2 = ["#f0efff", "#5B8FF9", "#3D76DD"];
function getTransformData(data, field3, xField, isSort) {
  if (isSort === void 0) {
    isSort = true;
  }
  var maxSize = 0;
  var isArrayData = false;
  var transformData3 = (0, import_lodash4.map)(data, function(d3) {
    var _a, _b;
    var fieldData = (0, import_lodash4.get)(d3, [field3]);
    if ((0, import_lodash4.isNil)(fieldData))
      return [];
    if ((0, import_lodash4.isString)(fieldData)) {
      var numberData = Number(fieldData);
      if (isNaN(numberData))
        return [];
      return _a = {}, _a[xField] = d3[xField], _a[field3] = numberData, _a;
    }
    if ((0, import_lodash4.isArray)(fieldData)) {
      isArrayData = true;
      maxSize = Math.max(maxSize, fieldData.length);
      return (0, import_lodash4.map)(isSort ? fieldData.sort(function(a4, b) {
        return b - a4;
      }) : fieldData, function(value2, index2) {
        var _a2;
        return _a2 = {}, _a2[xField] = d3[xField], _a2[field3] = value2, _a2.index = index2, _a2;
      });
    }
    maxSize = Math.max(1, maxSize);
    return _b = {}, _b[xField] = d3[xField], _b[field3] = fieldData, _b;
  }).flat();
  if (isArrayData) {
    return [
      transformData3.map(function(item) {
        return __assign18({ index: 0 }, item);
      }),
      maxSize
    ];
  }
  return [transformData3, maxSize];
}
function getFieldColor(maxSize, color) {
  return new Array(maxSize).fill("").map(function(d3, i2) {
    return (0, import_lodash4.isArray)(color) ? color[i2 % color.length] : color;
  });
}
function adaptor22(params) {
  var init = function(params2) {
    var options = params2.options;
    var color = options.color, _a = options.rangeField, rangeField = _a === void 0 ? "ranges" : _a, _b = options.measureField, measureField = _b === void 0 ? "measures" : _b, _c = options.targetField, targetField = _c === void 0 ? "targets" : _c, _d = options.xField, xField = _d === void 0 ? "title" : _d, mapField = options.mapField, data = options.data;
    var _e = getTransformData(data, rangeField, xField), rangesData = _e[0], rangesMaxSize = _e[1];
    var _f = getTransformData(data, measureField, xField, false), measuresData = _f[0], measuresMaxSize = _f[1];
    var _g = getTransformData(data, targetField, xField, false), targetsData = _g[0], targetsMaxSize = _g[1];
    var rangesColor = (0, import_lodash4.get)(color, [rangeField], DEFAULT_COLORS2[0]);
    var measuresColor = (0, import_lodash4.get)(color, [measureField], DEFAULT_COLORS2[1]);
    var targetsColor = (0, import_lodash4.get)(color, [targetField], DEFAULT_COLORS2[2]);
    var colors = [
      getFieldColor(rangesMaxSize, rangesColor),
      getFieldColor(measuresMaxSize, measuresColor),
      getFieldColor(targetsMaxSize, targetsColor)
    ].flat();
    options.children = (0, import_lodash4.map)(options.children, function(c5, i2) {
      var datas = [rangesData, measuresData, targetsData][i2];
      var yField = [rangeField, measureField, targetField][i2];
      return __assign18(__assign18({}, c5), { data: datas, encode: __assign18(__assign18({}, c5.encode || {}), { x: xField, y: yField, color: function(d3) {
        var index2 = d3.index;
        var mapString = (0, import_lodash4.isNumber)(index2) ? "".concat(yField, "_").concat(index2) : yField;
        return mapField ? (0, import_lodash4.get)(mapField, [yField, index2], mapString) : mapString;
      } }) });
    });
    (0, import_lodash4.set)(options, "scale.color.range", colors);
    options.legend.color.itemMarker = function(d3) {
      if (mapField && (0, import_lodash4.includes)(mapField === null || mapField === void 0 ? void 0 : mapField[targetField], d3)) {
        return "line";
      }
      return (d3 === null || d3 === void 0 ? void 0 : d3.replace(/\_\d$/, "")) === targetField ? "line" : "square";
    };
    return params2;
  };
  var layoutAdaptor = function(params2) {
    var _a = params2.options.transpose, transpose3 = _a === void 0 ? true : _a;
    if (!transpose3) {
      (0, import_lodash4.set)(params2, "options.children[2].shapeField", "hyphen");
    }
    return params2;
  };
  var cfgAdaptor = function(params2) {
    var options = params2.options;
    var _a = options.range, range3 = _a === void 0 ? {} : _a, _b = options.measure, measure = _b === void 0 ? {} : _b, _c = options.target, target = _c === void 0 ? {} : _c, children = options.children;
    options.children = [range3, measure, target].map(function(c5, i2) {
      return mergeWithArrayCoverage(children[i2], c5);
    });
    return params2;
  };
  return (0, import_lodash4.flow)(init, layoutAdaptor, cfgAdaptor, allCoordinateLayout, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/bullet/index.js
var __extends30 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Bullet = (
  /** @class */
  function(_super) {
    __extends30(Bullet2, _super);
    function Bullet2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "bullet";
      return _this;
    }
    Bullet2.getDefaultOptions = function() {
      return {
        type: "view",
        scale: {
          color: {
            range: DEFAULT_COLORS2
          }
        },
        legend: {
          color: {
            itemMarker: function(d3) {
              return d3 === "targets" ? "line" : "square";
            }
          }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        children: [
          {
            type: "interval",
            style: { maxWidth: 30, zIndex: -2 },
            axis: { y: { grid: true, gridLineWidth: 2 } }
          },
          {
            type: "interval",
            style: { maxWidth: 20, zIndex: -1 },
            transform: [{ type: "stackY" }]
          },
          {
            type: "point",
            encode: { size: 8, shape: "line" }
          }
        ],
        interaction: { tooltip: { shared: true } },
        coordinate: { transform: [{ type: "transpose" }] }
      };
    };
    Bullet2.prototype.getDefaultOptions = function() {
      return Bullet2.getDefaultOptions();
    };
    Bullet2.prototype.getSchemaAdaptor = function() {
      return adaptor22;
    };
    return Bullet2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/gauge/adaptor.js
function adaptor23(params) {
  var init = function(params2) {
    var data = params2.options.data;
    params2.options.data = {
      value: data
    };
    return params2;
  };
  return (0, import_lodash4.flow)(init, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/gauge/index.js
var __extends31 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Gauge2 = (
  /** @class */
  function(_super) {
    __extends31(Gauge3, _super);
    function Gauge3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "Gauge";
      return _this;
    }
    Gauge3.getDefaultOptions = function() {
      return {
        type: "view",
        legend: false,
        children: [{ type: "gauge" }]
      };
    };
    Gauge3.prototype.getDefaultOptions = function() {
      return Gauge3.getDefaultOptions();
    };
    Gauge3.prototype.getSchemaAdaptor = function() {
      return adaptor23;
    };
    return Gauge3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/liquid/adaptor.js
function adaptor24(params) {
  var init = function(params2) {
    var percent = params2.options.percent;
    if ((0, import_lodash4.isNumber)(percent)) {
      (0, import_lodash4.set)(params2, "options.data", percent);
      delete params2.options.percent;
    }
    return params2;
  };
  return (0, import_lodash4.flow)(init, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/liquid/index.js
var __extends32 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Liquid3 = (
  /** @class */
  function(_super) {
    __extends32(Liquid4, _super);
    function Liquid4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "Liquid";
      return _this;
    }
    Liquid4.getDefaultOptions = function() {
      return { type: "view", children: [{ type: "liquid" }] };
    };
    Liquid4.prototype.getDefaultOptions = function() {
      return Liquid4.getDefaultOptions();
    };
    Liquid4.prototype.getSchemaAdaptor = function() {
      return adaptor24;
    };
    return Liquid4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/wordCloud/adaptor.js
function adaptor25(params) {
  return (0, import_lodash4.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/wordCloud/index.js
var __extends33 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var WordCloud3 = (
  /** @class */
  function(_super) {
    __extends33(WordCloud4, _super);
    function WordCloud4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "WordCloud";
      return _this;
    }
    WordCloud4.getDefaultOptions = function() {
      return { type: "view", legend: false, children: [{ type: "wordCloud" }] };
    };
    WordCloud4.prototype.getDefaultOptions = function() {
      return WordCloud4.getDefaultOptions();
    };
    WordCloud4.prototype.getSchemaAdaptor = function() {
      return adaptor25;
    };
    return WordCloud4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/treemap/adaptor.js
function adaptor26(params) {
  return (0, import_lodash4.flow)(dataTransform4, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/treemap/index.js
var __extends34 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Treemap2 = (
  /** @class */
  function(_super) {
    __extends34(Treemap3, _super);
    function Treemap3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "treemap";
      return _this;
    }
    Treemap3.getDefaultOptions = function() {
      return {
        type: "view",
        children: [
          {
            type: "treemap"
          }
        ]
      };
    };
    Treemap3.prototype.getDefaultOptions = function() {
      return Treemap3.getDefaultOptions();
    };
    Treemap3.prototype.getSchemaAdaptor = function() {
      return adaptor26;
    };
    return Treemap3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/radial-bar/adaptor.js
var __assign19 = function() {
  __assign19 = Object.assign || function(t) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t[p3] = s3[p3];
    }
    return t;
  };
  return __assign19.apply(this, arguments);
};
var __rest97 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function adaptor27(params) {
  var coordinate = function(params2) {
    var options = params2.options;
    var startAngle = options.startAngle, maxAngle = options.maxAngle, coordinate2 = options.coordinate;
    var start = (0, import_lodash4.isNumber)(startAngle) ? startAngle / (2 * Math.PI) * 360 : -90;
    var end = (0, import_lodash4.isNumber)(maxAngle) ? (Number(maxAngle) + start) / 180 * Math.PI : Math.PI;
    (0, import_lodash4.set)(params2, ["options", "coordinate"], __assign19(__assign19({}, coordinate2), { endAngle: end, startAngle: startAngle !== null && startAngle !== void 0 ? startAngle : -Math.PI / 2 }));
    return params2;
  };
  var tooltip2 = function(params2) {
    var options = params2.options;
    var tooltip3 = options.tooltip, xField = options.xField, yField = options.yField;
    var getXFieldData = fieldAdapter(xField);
    var getYFieldData = fieldAdapter(yField);
    if (!tooltip3) {
      (0, import_lodash4.set)(options, "tooltip", {
        title: false,
        items: [function(d3, i2, data) {
          return { name: getXFieldData(d3, i2, data), value: getYFieldData(d3, i2, data) };
        }]
      });
    }
    return params2;
  };
  var background = function(params2) {
    var options = params2.options;
    var markBackground = options.markBackground, children = options.children, scale4 = options.scale, coordinate2 = options.coordinate, xField = options.xField;
    var domain = (0, import_lodash4.get)(scale4, "y.domain", []);
    if (markBackground) {
      var style = markBackground.style, rest = __rest97(markBackground, ["style"]);
      children.unshift(__assign19({
        type: "interval",
        xField,
        yField: domain[domain.length - 1],
        style: __assign19({ fillOpacity: 0.4, fill: "#e0e4ee" }, style),
        // 
        coordinate: __assign19(__assign19({}, coordinate2), { startAngle: -Math.PI / 2, endAngle: 3 / 2 * Math.PI }),
        animate: false
      }, rest));
    }
    return params2;
  };
  return (0, import_lodash4.flow)(coordinate, tooltip2, background, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/radial-bar/index.js
var __extends35 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var RadialBar = (
  /** @class */
  function(_super) {
    __extends35(RadialBar3, _super);
    function RadialBar3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "radial";
      return _this;
    }
    RadialBar3.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "interval" }],
        coordinate: { type: "radial", innerRadius: 0.1, outerRadius: 1, endAngle: Math.PI },
        animate: { enter: { type: "waveIn", duration: 800 } },
        axis: {
          y: {
            nice: true,
            labelAutoHide: true,
            labelAutoRotate: false
          },
          x: {
            title: false,
            nice: true,
            labelAutoRotate: false,
            labelAutoHide: { type: "equidistance", cfg: { minGap: 6 } }
          }
        }
      };
    };
    RadialBar3.prototype.getDefaultOptions = function() {
      return RadialBar3.getDefaultOptions();
    };
    RadialBar3.prototype.getSchemaAdaptor = function() {
      return adaptor27;
    };
    return RadialBar3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/circle-packing/adaptor.js
function adaptor28(params) {
  return (0, import_lodash4.flow)(dataTransform4, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/circle-packing/index.js
var __extends36 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CirclePacking = (
  /** @class */
  function(_super) {
    __extends36(CirclePacking2, _super);
    function CirclePacking2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "CirclePacking";
      return _this;
    }
    CirclePacking2.getDefaultOptions = function() {
      return {
        legend: false,
        type: "view",
        children: [
          {
            type: "pack",
            encode: {
              color: "depth"
            }
          }
        ]
      };
    };
    CirclePacking2.prototype.getDefaultOptions = function() {
      return CirclePacking2.getDefaultOptions();
    };
    CirclePacking2.prototype.getSchemaAdaptor = function() {
      return adaptor28;
    };
    return CirclePacking2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/violin/adaptor.js
var __assign20 = function() {
  __assign20 = Object.assign || function(t) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t[p3] = s3[p3];
    }
    return t;
  };
  return __assign20.apply(this, arguments);
};
function withField(field1, field22) {
  if (field1)
    return field1;
  return field22;
}
function adaptor29(params) {
  var customTransform = function(params2) {
    var options = params2.options;
    var xField = options.xField, yField = options.yField, colorField = options.colorField, seriesField = options.seriesField, children = options.children;
    var newChildren = children === null || children === void 0 ? void 0 : children.map(function(item) {
      return __assign20(__assign20({}, item), { xField, yField, seriesField: withField(seriesField, colorField), colorField: withField(colorField, seriesField), data: item.type === "density" ? {
        transform: [
          {
            type: "kde",
            field: yField,
            groupBy: [xField, withField(seriesField, colorField)]
          }
        ]
      } : item.data });
    }).filter(function(item) {
      return options.box || item.type === "density";
    });
    (0, import_lodash4.set)(options, "children", newChildren);
    delete options.box;
    return params2;
  };
  return (0, import_lodash4.flow)(customTransform, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/violin/index.js
var __extends37 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Violin2 = (
  /** @class */
  function(_super) {
    __extends37(Violin3, _super);
    function Violin3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "violin";
      return _this;
    }
    Violin3.getDefaultOptions = function() {
      return {
        type: "view",
        children: [
          {
            type: "density",
            sizeField: "size",
            tooltip: false
          },
          {
            type: "boxplot",
            shapeField: "violin",
            style: {
              opacity: 0.5,
              point: false
            }
          }
        ],
        animate: { enter: { type: "fadeIn" } }
      };
    };
    Violin3.prototype.getDefaultOptions = function() {
      return Violin3.getDefaultOptions();
    };
    Violin3.prototype.getSchemaAdaptor = function() {
      return adaptor29;
    };
    return Violin3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/bidirectional-bar/adaptor.js
var __assign21 = function() {
  __assign21 = Object.assign || function(t) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t[p3] = s3[p3];
    }
    return t;
  };
  return __assign21.apply(this, arguments);
};
var __spreadArray10 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function adaptor30(params) {
  var field3 = function(params2) {
    var options = params2.options;
    var yField = options.yField, children = options.children;
    children.forEach(function(child, index2) {
      (0, import_lodash4.set)(child, "yField", yField[index2]);
    });
    return params2;
  };
  var data = function(params2) {
    var options = params2.options;
    var yField = options.yField, children = options.children, data2 = options.data;
    if ((0, import_lodash4.isPlainObject)(data2))
      return params2;
    var transformData3 = (0, import_lodash4.isArray)((0, import_lodash4.get)(data2, [0])) ? data2 : [data2, data2];
    children.forEach(function(child, index2) {
      (0, import_lodash4.set)(child, "data", __spreadArray10([], transformData3[index2].map(function(item) {
        return __assign21({ groupKey: yField[index2] }, item);
      }), true));
    });
    return params2;
  };
  var tooltip2 = function(params2) {
    var options = params2.options;
    var _a = options.yField, y12 = _a[0], y22 = _a[1], tooltip3 = options.tooltip;
    if (!tooltip3) {
      (0, import_lodash4.set)(options, "tooltip", {
        items: [
          {
            field: y12,
            value: y12
          },
          {
            field: y22,
            value: y22
          }
        ]
      });
    }
    return params2;
  };
  var layout = function(params2) {
    var options = params2.options;
    var children = options.children, layout2 = options.layout, transform2 = options.coordinate.transform, _a = options.paddingBottom, paddingBottom = _a === void 0 ? AXIS_LABEL_PADDING : _a, _b = options.paddingLeft, paddingLeft = _b === void 0 ? AXIS_LABEL_PADDING : _b, axis = options.axis;
    (0, import_lodash4.set)(options, "axisText", __assign21(__assign21({}, (axis === null || axis === void 0 ? void 0 : axis.x) || {}), { layout: layout2 }));
    var child1 = children[0], child2 = children[1];
    if (layout2 === "vertical") {
      (0, import_lodash4.set)(options, "direction", "col");
      (0, import_lodash4.set)(options, "paddingLeft", paddingLeft);
      (0, import_lodash4.set)(options, "coordinate.transform", transform2.filter(function(item) {
        return item.type !== "transpose";
      }));
      (0, import_lodash4.set)(child1, "paddingBottom", HORIZONTAL_MARGIN);
      (0, import_lodash4.set)(child2, "paddingTop", HORIZONTAL_MARGIN);
      (0, import_lodash4.set)(child2, "axis.x.position", "top");
      (0, import_lodash4.set)(child2, "scale.y.range", [0, 1]);
    } else {
      (0, import_lodash4.set)(options, "paddingBottom", paddingBottom);
      (0, import_lodash4.set)(child1, "scale.y.range", [0, 1]);
      var _c = child1.paddingRight, paddingRight = _c === void 0 ? VERTICAL_MARGIN : _c;
      var _d = child2.paddingLeft, paddingLeft_1 = _d === void 0 ? VERTICAL_MARGIN : _d;
      (0, import_lodash4.set)(child1, "paddingRight", paddingRight);
      (0, import_lodash4.set)(child1, "axis.x.position", "right");
      (0, import_lodash4.set)(child2, "paddingLeft", paddingLeft_1);
    }
    return params2;
  };
  return (0, import_lodash4.flow)(field3, data, tooltip2, layout, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/bidirectional-bar/index.js
var __extends38 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var BidirectionalBar = (
  /** @class */
  function(_super) {
    __extends38(BidirectionalBar2, _super);
    function BidirectionalBar2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "BidirectionalBar";
      return _this;
    }
    BidirectionalBar2.getDefaultOptions = function() {
      return {
        type: "spaceFlex",
        coordinate: { transform: [{ type: "transpose" }] },
        scale: {
          y: { nice: true }
        },
        direction: "row",
        layout: "horizontal",
        legend: false,
        axis: {
          y: {
            title: false
          },
          x: { title: false, label: false }
        },
        children: [{ type: "interval" }, { type: "interval" }]
      };
    };
    BidirectionalBar2.prototype.getDefaultOptions = function() {
      return BidirectionalBar2.getDefaultOptions();
    };
    BidirectionalBar2.prototype.getSchemaAdaptor = function() {
      return adaptor30;
    };
    return BidirectionalBar2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/venn/type.js
var DefaultTransformKey;
(function(DefaultTransformKey2) {
  DefaultTransformKey2["color"] = "key";
  DefaultTransformKey2["d"] = "path";
})(DefaultTransformKey || (DefaultTransformKey = {}));

// node_modules/@ant-design/plots/es/core/plots/venn/adaptor.js
function adaptor31(params) {
  var init = function(params2) {
    var options = params2.options;
    var data = options.data, setsField = options.setsField, sizeField = options.sizeField;
    if ((0, import_lodash4.isArray)(data)) {
      (0, import_lodash4.set)(options, "data", {
        type: "inline",
        value: data,
        transform: [
          {
            type: "venn",
            sets: setsField,
            size: sizeField,
            as: [DefaultTransformKey.color, DefaultTransformKey.d]
          }
        ]
      });
      (0, import_lodash4.set)(options, "colorField", DefaultTransformKey.color);
      (0, import_lodash4.set)(options, ["children", "0", "encode", "d"], DefaultTransformKey.d);
    }
    return params2;
  };
  return (0, import_lodash4.flow)(init, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/venn/index.js
var __extends39 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Venn2 = (
  /** @class */
  function(_super) {
    __extends39(Venn3, _super);
    function Venn3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "venn";
      return _this;
    }
    Venn3.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "path" }],
        legend: {
          color: { itemMarker: "circle" }
        },
        encode: { color: DefaultTransformKey.color, d: DefaultTransformKey.d }
      };
    };
    Venn3.prototype.getDefaultOptions = function() {
      return Venn3.getDefaultOptions();
    };
    Venn3.prototype.getSchemaAdaptor = function() {
      return adaptor31;
    };
    return Venn3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/sunburst/adaptor.js
function adaptor32(params) {
  return (0, import_lodash4.flow)(dataTransform4, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/sunburst/index.js
var __extends40 = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d4[p3] = b2[p3];
    };
    return extendStatics(d3, b);
  };
  return function(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Sunburst2 = (
  /** @class */
  function(_super) {
    __extends40(Sunburst3, _super);
    function Sunburst3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "Sunburst";
      return _this;
    }
    Sunburst3.getDefaultOptions = function() {
      return { type: "view", children: [{ type: "sunburst" }] };
    };
    Sunburst3.prototype.getDefaultOptions = function() {
      return Sunburst3.getDefaultOptions();
    };
    Sunburst3.prototype.getSchemaAdaptor = function() {
      return adaptor32;
    };
    return Sunburst3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/index.js
var Plots = {
  Base: Base3,
  Line: Line6,
  Column: Column2,
  Pie,
  Area: Area3,
  Bar,
  DualAxes,
  Funnel: Funnel2,
  Scatter,
  Radar: Radar2,
  Rose,
  Stock,
  TinyLine,
  TinyArea,
  TinyColumn,
  TinyProgress,
  TinyRing,
  Waterfall,
  Histogram,
  Heatmap: Heatmap3,
  Box: Box3,
  Sankey: Sankey4,
  Bullet,
  Gauge: Gauge2,
  Liquid: Liquid3,
  WordCloud: WordCloud3,
  Treemap: Treemap2,
  RadialBar,
  CirclePacking,
  Violin: Violin2,
  BidirectionalBar,
  Venn: Venn2,
  Mix: DualAxes,
  Sunburst: Sunburst2
};

// node_modules/@ant-design/plots/es/components/base/index.js
var __assign22 = function() {
  __assign22 = Object.assign || function(t) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t[p3] = s3[p3];
    }
    return t;
  };
  return __assign22.apply(this, arguments);
};
var __rest98 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
var BaseChart = (0, import_react4.forwardRef)(function(_a, ref) {
  var _b = _a.chartType, chartType = _b === void 0 ? "Base" : _b, config = __rest98(_a, ["chartType"]);
  var _c = config.containerStyle, containerStyle = _c === void 0 ? {
    height: "inherit",
    flex: 1
  } : _c, _d = config.containerAttributes, containerAttributes = _d === void 0 ? {} : _d, className2 = config.className, loading = config.loading, loadingTemplate = config.loadingTemplate, errorTemplate = config.errorTemplate, onReady = config.onReady, rest = __rest98(config, ["containerStyle", "containerAttributes", "className", "loading", "loadingTemplate", "errorTemplate", "onReady"]);
  var _e = useChart(Plots[chartType], __assign22(__assign22({}, rest), { onReady: function(chartInstance) {
    if (ref) {
      if (typeof ref === "function") {
        ref(chartInstance);
      } else {
        ref.current = chartInstance;
      }
    }
    onReady === null || onReady === void 0 ? void 0 : onReady(chartInstance);
  } })), chart = _e.chart, container = _e.container;
  return import_react4.default.createElement(
    ErrorBoundary,
    { errorTemplate },
    loading && import_react4.default.createElement(ChartLoading, { loadingTemplate, theme: config.theme, loading }),
    import_react4.default.createElement("div", __assign22({ className: className2, style: containerStyle, ref: container }, containerAttributes))
  );
});

// node_modules/@ant-design/plots/es/util/makeChartComp.js
var import_react7 = __toESM(require_react());

// node_modules/@ant-design/plots/es/hooks/useConfig.js
var import_react6 = __toESM(require_react());

// node_modules/@ant-design/plots/es/context.js
var import_react5 = __toESM(require_react());
var ConfigContext = (0, import_react5.createContext)({});

// node_modules/@ant-design/plots/es/hooks/useConfig.js
function useConfig() {
  return (0, import_react6.useContext)(ConfigContext);
}

// node_modules/@ant-design/plots/es/util/scale.js
var __assign23 = function() {
  __assign23 = Object.assign || function(t) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t[p3] = s3[p3];
    }
    return t;
  };
  return __assign23.apply(this, arguments);
};
function scale3(props) {
  var yField = props.yField, data = props.data;
  var noDomainMax = (0, import_lodash3.isArray)(data) && data.length > 0 && (0, import_lodash3.isString)(yField) && !(0, import_lodash3.get)(props, "scale.y.domainMax");
  var newProps = Object.isFrozen(props) ? __assign23({}, props) : props;
  if (noDomainMax && data.reduce(function(acc, item) {
    return acc + item[yField];
  }, 0) === 0) {
    (0, import_lodash3.set)(newProps, "scale.y.domainMax", 1);
  } else if (noDomainMax && data.reduce(function(acc, item) {
    return acc + item[yField];
  }, 0) !== 0) {
    (0, import_lodash3.set)(newProps, "scale.y.domainMax", void 0);
  }
  return newProps;
}

// node_modules/@ant-design/plots/es/util/makeChartComp.js
var __assign24 = function() {
  __assign24 = Object.assign || function(t) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3))
        t[p3] = s3[p3];
    }
    return t;
  };
  return __assign24.apply(this, arguments);
};
function makeChartComp(chartType) {
  var configKey = chartType.charAt(0).toLowerCase() + chartType.slice(1);
  return (0, import_react7.forwardRef)(function(props, ref) {
    var _a, _b;
    var config = useConfig();
    var configKey2 = (0, import_react7.useMemo)(function() {
      return chartType.charAt(0).toLowerCase() + chartType.slice(1);
    }, [chartType]);
    var flowProps = (0, import_lodash3.flow)([scale3])(props);
    var mergedConfig = __assign24(__assign24({}, (_a = config === null || config === void 0 ? void 0 : config.common) !== null && _a !== void 0 ? _a : {}), (_b = config === null || config === void 0 ? void 0 : config[configKey2]) !== null && _b !== void 0 ? _b : {});
    return import_react7.default.createElement(BaseChart, __assign24({}, mergedConfig, flowProps, { chartType, ref }));
  });
}

// node_modules/@ant-design/plots/es/components/area/index.js
var AreaChart = makeChartComp("Area");
var area_default4 = AreaChart;

// node_modules/@ant-design/plots/es/components/bar/index.js
var BarChart = makeChartComp("Bar");
var bar_default = BarChart;

// node_modules/@ant-design/plots/es/components/column/index.js
var ColumnChart = makeChartComp("Column");
var column_default = ColumnChart;

// node_modules/@ant-design/plots/es/components/config-provider/index.js
var import_react8 = __toESM(require_react());
var __rest99 = function(s3, e3) {
  var t = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
    t[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s3); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i2]))
        t[p3[i2]] = s3[p3[i2]];
    }
  return t;
};
function ConfigProvider(_a) {
  var children = _a.children, value2 = __rest99(_a, ["children"]);
  return import_react8.default.createElement(ConfigContext.Provider, { value: value2 }, children);
}

// node_modules/@ant-design/plots/es/components/dual-axes/index.js
var DualAxesChart = makeChartComp("DualAxes");
var dual_axes_default = DualAxesChart;

// node_modules/@ant-design/plots/es/components/funnel/index.js
var FunnelChart = makeChartComp("Funnel");
var funnel_default = FunnelChart;

// node_modules/@ant-design/plots/es/components/line/index.js
var LineChart = makeChartComp("Line");
var line_default3 = LineChart;

// node_modules/@ant-design/plots/es/components/pie/index.js
var PieChart = makeChartComp("Pie");
var pie_default2 = PieChart;

// node_modules/@ant-design/plots/es/components/scatter/index.js
var ScatterChart = makeChartComp("Scatter");
var scatter_default = ScatterChart;

// node_modules/@ant-design/plots/es/components/radar/index.js
var RadarChart = makeChartComp("Radar");
var radar_default = RadarChart;

// node_modules/@ant-design/plots/es/components/tiny/line/index.js
var TinyLineChart = makeChartComp("TinyLine");
var line_default4 = TinyLineChart;

// node_modules/@ant-design/plots/es/components/tiny/area/index.js
var TinyAreaChart = makeChartComp("TinyArea");
var area_default5 = TinyAreaChart;

// node_modules/@ant-design/plots/es/components/tiny/column/index.js
var TinyLineChart2 = makeChartComp("TinyColumn");
var column_default2 = TinyLineChart2;

// node_modules/@ant-design/plots/es/components/tiny/progress/index.js
var TinyProgressChart = makeChartComp("TinyProgress");
var progress_default = TinyProgressChart;

// node_modules/@ant-design/plots/es/components/tiny/ring/index.js
var TinyRingChart = makeChartComp("TinyRing");
var ring_default = TinyRingChart;

// node_modules/@ant-design/plots/es/components/tiny/index.js
var Tiny = { Line: line_default4, Area: area_default5, Column: column_default2, Progress: progress_default, Ring: ring_default };

// node_modules/@ant-design/plots/es/components/rose/index.js
var RoseChart = makeChartComp("Rose");
var rose_default = RoseChart;

// node_modules/@ant-design/plots/es/components/waterfall/index.js
var WaterfallChart = makeChartComp("Waterfall");
var waterfall_default = WaterfallChart;

// node_modules/@ant-design/plots/es/components/histogram/index.js
var HistogramChart = makeChartComp("Histogram");
var histogram_default = HistogramChart;

// node_modules/@ant-design/plots/es/components/heatmap/index.js
var HeatmapChart = makeChartComp("Heatmap");
var heatmap_default = HeatmapChart;

// node_modules/@ant-design/plots/es/components/box/index.js
var BoxChart = makeChartComp("Box");
var box_default = BoxChart;

// node_modules/@ant-design/plots/es/components/sankey/index.js
var SankeyChart = makeChartComp("Sankey");
var sankey_default = SankeyChart;

// node_modules/@ant-design/plots/es/components/stock/index.js
var StockChart = makeChartComp("Stock");
var stock_default = StockChart;

// node_modules/@ant-design/plots/es/components/bullet/index.js
var BulletChart = makeChartComp("Bullet");
var bullet_default = BulletChart;

// node_modules/@ant-design/plots/es/components/gauge/index.js
var GaugeChart = makeChartComp("Gauge");
var gauge_default = GaugeChart;

// node_modules/@ant-design/plots/es/components/liquid/index.js
var LiquidChart = makeChartComp("Liquid");
var liquid_default = LiquidChart;

// node_modules/@ant-design/plots/es/components/wordCloud/index.js
var WordCloudChart = makeChartComp("WordCloud");
var wordCloud_default = WordCloudChart;

// node_modules/@ant-design/plots/es/components/treemap/index.js
var TreemapChart = makeChartComp("Treemap");
var treemap_default2 = TreemapChart;

// node_modules/@ant-design/plots/es/components/radial-bar/index.js
var RadialBar2 = makeChartComp("RadialBar");
var radial_bar_default = RadialBar2;

// node_modules/@ant-design/plots/es/components/circlePacking/index.js
var CirclePackingChart = makeChartComp("CirclePacking");
var circlePacking_default = CirclePackingChart;

// node_modules/@ant-design/plots/es/components/violin/index.js
var ViolinChart = makeChartComp("Violin");
var violin_default = ViolinChart;

// node_modules/@ant-design/plots/es/components/bidirectional-bar/index.js
var BidirectionalBarChart = makeChartComp("BidirectionalBar");
var bidirectional_bar_default = BidirectionalBarChart;

// node_modules/@ant-design/plots/es/components/venn/index.js
var VennChart = makeChartComp("Venn");
var venn_default = VennChart;

// node_modules/@ant-design/plots/es/components/mix/index.js
var MixChart = makeChartComp("Mix");
var mix_default = MixChart;

// node_modules/@ant-design/plots/es/components/sunburst/index.js
var SunburstChart = makeChartComp("Sunburst");
var sunburst_default = SunburstChart;
export {
  area_default4 as Area,
  bar_default as Bar,
  BaseChart as Base,
  bidirectional_bar_default as BidirectionalBar,
  box_default as Box,
  bullet_default as Bullet,
  ChartEvent,
  circlePacking_default as CirclePacking,
  column_default as Column,
  ConfigProvider,
  dual_axes_default as DualAxes,
  funnel_default as Funnel,
  esm_exports as G2,
  gauge_default as Gauge,
  heatmap_default as Heatmap,
  histogram_default as Histogram,
  line_default3 as Line,
  liquid_default as Liquid,
  mix_default as Mix,
  pie_default2 as Pie,
  radar_default as Radar,
  radial_bar_default as RadialBar,
  rose_default as Rose,
  sankey_default as Sankey,
  scatter_default as Scatter,
  stock_default as Stock,
  sunburst_default as Sunburst,
  Tiny,
  treemap_default2 as Treemap,
  venn_default as Venn,
  violin_default as Violin,
  waterfall_default as Waterfall,
  wordCloud_default as WordCloud,
  measureTextWidth2 as measureTextWidth,
  register
};
//# sourceMappingURL=@ant-design_charts.js.map
