import {
  init_emotion_is_prop_valid_esm,
  isPropValid
} from "./chunk-EVUI25IS.js";
import {
  AABB,
  Canvas,
  CanvasEvent,
  Category,
  Circle,
  CustomElement,
  Document,
  ElementEvent,
  Ellipse,
  FederatedPointerEvent,
  Group,
  HTML,
  Image as Image2,
  Line,
  Path,
  Plugin,
  Polygon,
  Polyline,
  Rect,
  Renderer,
  Text,
  Timebar,
  Tooltip,
  center_default,
  clamp_default,
  clone_default,
  collide_default,
  createDOM,
  debounce_default,
  deep_mix_default,
  difference_default,
  esm_default,
  get_default,
  group_by_default,
  isArray,
  isDate,
  isFunction,
  isNil,
  isNumber,
  isString,
  is_boolean_default,
  is_empty_default,
  is_equal_default,
  is_object_default,
  is_undefined_default,
  link_default,
  lower_first_default,
  manyBody_default,
  memoize,
  omit_default,
  pick_default,
  quadtree,
  rad2deg,
  radial_default,
  require_lodash,
  set_default,
  simulation_default,
  throttle_default,
  uniq,
  unique_id_default,
  upper_first_default,
  x_default,
  y_default
} from "./chunk-2C3BOJAR.js";
import "./chunk-YZIFLJUH.js";
import "./chunk-A3W4J62T.js";
import "./chunk-OERZF2CA.js";
import {
  require_arrayEach,
  require_arrayMap,
  require_assignValue,
  require_baseAssignValue,
  require_baseClone,
  require_baseCreate,
  require_baseEach,
  require_baseFor,
  require_baseForOwn,
  require_baseGet,
  require_baseIteratee,
  require_baseMap,
  require_baseProperty,
  require_baseRest,
  require_castFunction,
  require_castPath,
  require_cloneDeep,
  require_constant,
  require_each,
  require_forEach,
  require_hasIn,
  require_hasPath,
  require_identity,
  require_isArrayLikeObject,
  require_isIterateeCall,
  require_isString,
  require_keysIn,
  require_map,
  require_merge,
  require_overRest,
  require_setToString,
  require_toKey,
  require_toString
} from "./chunk-RT4SFNCA.js";
import {
  require_Set,
  require_SetCache,
  require_arrayFilter,
  require_arrayPush,
  require_baseKeys,
  require_baseUnary,
  require_cacheHas,
  require_eq,
  require_getTag,
  require_isArguments,
  require_isArray,
  require_isArrayLike,
  require_isBuffer,
  require_isFunction,
  require_isIndex,
  require_isPrototype,
  require_isTypedArray,
  require_keys,
  require_setToArray
} from "./chunk-LRIX7P5L.js";
import "./chunk-ARQYEDIX.js";
import {
  require_Symbol,
  require_getPrototype,
  require_isObject,
  require_isSymbol,
  require_now,
  require_toNumber
} from "./chunk-6LK6LHT3.js";
import {
  __assign,
  __awaiter,
  __rest,
  __spreadArray,
  __spreadArrays
} from "./chunk-WJK6EJH2.js";
import {
  RULESET,
  compile,
  middleware,
  prefixer,
  rulesheet,
  serialize,
  stringify
} from "./chunk-CKSH3UQX.js";
import "./chunk-ZY7H3YXG.js";
import {
  require_react_dom
} from "./chunk-4DDZX4I5.js";
import {
  require_react
} from "./chunk-KTKTKB6L.js";
import {
  __async,
  __commonJS,
  __esm,
  __export,
  __objRest,
  __pow,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField,
  __require,
  __spreadProps,
  __spreadValues,
  __toCommonJS,
  __toESM
} from "./chunk-JMNN7AZU.js";

// node_modules/is-any-array/lib-esm/index.js
var lib_esm_exports = {};
__export(lib_esm_exports, {
  isAnyArray: () => isAnyArray
});
function isAnyArray(value) {
  const tag = toString3.call(value);
  return tag.endsWith("Array]") && !tag.includes("Big");
}
var toString3;
var init_lib_esm = __esm({
  "node_modules/is-any-array/lib-esm/index.js"() {
    toString3 = Object.prototype.toString;
  }
});

// node_modules/ml-array-max/lib-es6/index.js
function max(input) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!isAnyArray(input)) {
    throw new TypeError("input must be an array");
  }
  if (input.length === 0) {
    throw new TypeError("input must not be empty");
  }
  var _options$fromIndex = options.fromIndex, fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex, _options$toIndex = options.toIndex, toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;
  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
    throw new Error("fromIndex must be a positive integer smaller than length");
  }
  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
    throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");
  }
  var maxValue = input[fromIndex];
  for (var i2 = fromIndex + 1; i2 < toIndex; i2++) {
    if (input[i2] > maxValue) maxValue = input[i2];
  }
  return maxValue;
}
var init_lib_es6 = __esm({
  "node_modules/ml-array-max/lib-es6/index.js"() {
    init_lib_esm();
  }
});

// node_modules/ml-array-min/lib-es6/index.js
function min(input) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!isAnyArray(input)) {
    throw new TypeError("input must be an array");
  }
  if (input.length === 0) {
    throw new TypeError("input must not be empty");
  }
  var _options$fromIndex = options.fromIndex, fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex, _options$toIndex = options.toIndex, toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;
  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
    throw new Error("fromIndex must be a positive integer smaller than length");
  }
  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
    throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");
  }
  var minValue = input[fromIndex];
  for (var i2 = fromIndex + 1; i2 < toIndex; i2++) {
    if (input[i2] < minValue) minValue = input[i2];
  }
  return minValue;
}
var init_lib_es62 = __esm({
  "node_modules/ml-array-min/lib-es6/index.js"() {
    init_lib_esm();
  }
});

// node_modules/ml-array-rescale/lib-es6/index.js
var lib_es6_exports = {};
__export(lib_es6_exports, {
  default: () => rescale
});
function rescale(input) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!isAnyArray(input)) {
    throw new TypeError("input must be an array");
  } else if (input.length === 0) {
    throw new TypeError("input must not be empty");
  }
  var output;
  if (options.output !== void 0) {
    if (!isAnyArray(options.output)) {
      throw new TypeError("output option must be an array if specified");
    }
    output = options.output;
  } else {
    output = new Array(input.length);
  }
  var currentMin = min(input);
  var currentMax = max(input);
  if (currentMin === currentMax) {
    throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");
  }
  var _options$min = options.min, minValue = _options$min === void 0 ? options.autoMinMax ? currentMin : 0 : _options$min, _options$max = options.max, maxValue = _options$max === void 0 ? options.autoMinMax ? currentMax : 1 : _options$max;
  if (minValue >= maxValue) {
    throw new RangeError("min option must be smaller than max option");
  }
  var factor = (maxValue - minValue) / (currentMax - currentMin);
  for (var i2 = 0; i2 < input.length; i2++) {
    output[i2] = (input[i2] - currentMin) * factor + minValue;
  }
  return output;
}
var init_lib_es63 = __esm({
  "node_modules/ml-array-rescale/lib-es6/index.js"() {
    init_lib_esm();
    init_lib_es6();
    init_lib_es62();
  }
});

// node_modules/ml-matrix/matrix.js
var require_matrix = __commonJS({
  "node_modules/ml-matrix/matrix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var isAnyArray2 = (init_lib_esm(), __toCommonJS(lib_esm_exports));
    var rescale2 = (init_lib_es63(), __toCommonJS(lib_es6_exports));
    var indent = " ".repeat(2);
    var indentData = " ".repeat(4);
    function inspectMatrix() {
      return inspectMatrixWithOptions(this);
    }
    function inspectMatrixWithOptions(matrix2, options = {}) {
      const {
        maxRows = 15,
        maxColumns = 10,
        maxNumSize = 8,
        padMinus = "auto"
      } = options;
      return `${matrix2.constructor.name} {
${indent}[
${indentData}${inspectData(matrix2, maxRows, maxColumns, maxNumSize, padMinus)}
${indent}]
${indent}rows: ${matrix2.rows}
${indent}columns: ${matrix2.columns}
}`;
    }
    function inspectData(matrix2, maxRows, maxColumns, maxNumSize, padMinus) {
      const { rows, columns } = matrix2;
      const maxI = Math.min(rows, maxRows);
      const maxJ = Math.min(columns, maxColumns);
      const result = [];
      if (padMinus === "auto") {
        padMinus = false;
        loop: for (let i2 = 0; i2 < maxI; i2++) {
          for (let j2 = 0; j2 < maxJ; j2++) {
            if (matrix2.get(i2, j2) < 0) {
              padMinus = true;
              break loop;
            }
          }
        }
      }
      for (let i2 = 0; i2 < maxI; i2++) {
        let line = [];
        for (let j2 = 0; j2 < maxJ; j2++) {
          line.push(formatNumber(matrix2.get(i2, j2), maxNumSize, padMinus));
        }
        result.push(`${line.join(" ")}`);
      }
      if (maxJ !== columns) {
        result[result.length - 1] += ` ... ${columns - maxColumns} more columns`;
      }
      if (maxI !== rows) {
        result.push(`... ${rows - maxRows} more rows`);
      }
      return result.join(`
${indentData}`);
    }
    function formatNumber(num, maxNumSize, padMinus) {
      return (num >= 0 && padMinus ? ` ${formatNumber2(num, maxNumSize - 1)}` : formatNumber2(num, maxNumSize)).padEnd(maxNumSize);
    }
    function formatNumber2(num, len) {
      let str = num.toString();
      if (str.length <= len) return str;
      let fix = num.toFixed(len);
      if (fix.length > len) {
        fix = num.toFixed(Math.max(0, len - (fix.length - len)));
      }
      if (fix.length <= len && !fix.startsWith("0.000") && !fix.startsWith("-0.000")) {
        return fix;
      }
      let exp = num.toExponential(len);
      if (exp.length > len) {
        exp = num.toExponential(Math.max(0, len - (exp.length - len)));
      }
      return exp.slice(0);
    }
    function installMathOperations(AbstractMatrix3, Matrix4) {
      AbstractMatrix3.prototype.add = function add4(value) {
        if (typeof value === "number") return this.addS(value);
        return this.addM(value);
      };
      AbstractMatrix3.prototype.addS = function addS(value) {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) + value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.addM = function addM(matrix2) {
        matrix2 = Matrix4.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) + matrix2.get(i2, j2));
          }
        }
        return this;
      };
      AbstractMatrix3.add = function add4(matrix2, value) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.add(value);
      };
      AbstractMatrix3.prototype.sub = function sub(value) {
        if (typeof value === "number") return this.subS(value);
        return this.subM(value);
      };
      AbstractMatrix3.prototype.subS = function subS(value) {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) - value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.subM = function subM(matrix2) {
        matrix2 = Matrix4.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) - matrix2.get(i2, j2));
          }
        }
        return this;
      };
      AbstractMatrix3.sub = function sub(matrix2, value) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.sub(value);
      };
      AbstractMatrix3.prototype.subtract = AbstractMatrix3.prototype.sub;
      AbstractMatrix3.prototype.subtractS = AbstractMatrix3.prototype.subS;
      AbstractMatrix3.prototype.subtractM = AbstractMatrix3.prototype.subM;
      AbstractMatrix3.subtract = AbstractMatrix3.sub;
      AbstractMatrix3.prototype.mul = function mul(value) {
        if (typeof value === "number") return this.mulS(value);
        return this.mulM(value);
      };
      AbstractMatrix3.prototype.mulS = function mulS(value) {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) * value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.mulM = function mulM(matrix2) {
        matrix2 = Matrix4.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) * matrix2.get(i2, j2));
          }
        }
        return this;
      };
      AbstractMatrix3.mul = function mul(matrix2, value) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.mul(value);
      };
      AbstractMatrix3.prototype.multiply = AbstractMatrix3.prototype.mul;
      AbstractMatrix3.prototype.multiplyS = AbstractMatrix3.prototype.mulS;
      AbstractMatrix3.prototype.multiplyM = AbstractMatrix3.prototype.mulM;
      AbstractMatrix3.multiply = AbstractMatrix3.mul;
      AbstractMatrix3.prototype.div = function div(value) {
        if (typeof value === "number") return this.divS(value);
        return this.divM(value);
      };
      AbstractMatrix3.prototype.divS = function divS(value) {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) / value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.divM = function divM(matrix2) {
        matrix2 = Matrix4.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) / matrix2.get(i2, j2));
          }
        }
        return this;
      };
      AbstractMatrix3.div = function div(matrix2, value) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.div(value);
      };
      AbstractMatrix3.prototype.divide = AbstractMatrix3.prototype.div;
      AbstractMatrix3.prototype.divideS = AbstractMatrix3.prototype.divS;
      AbstractMatrix3.prototype.divideM = AbstractMatrix3.prototype.divM;
      AbstractMatrix3.divide = AbstractMatrix3.div;
      AbstractMatrix3.prototype.mod = function mod2(value) {
        if (typeof value === "number") return this.modS(value);
        return this.modM(value);
      };
      AbstractMatrix3.prototype.modS = function modS(value) {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) % value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.modM = function modM(matrix2) {
        matrix2 = Matrix4.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) % matrix2.get(i2, j2));
          }
        }
        return this;
      };
      AbstractMatrix3.mod = function mod2(matrix2, value) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.mod(value);
      };
      AbstractMatrix3.prototype.modulus = AbstractMatrix3.prototype.mod;
      AbstractMatrix3.prototype.modulusS = AbstractMatrix3.prototype.modS;
      AbstractMatrix3.prototype.modulusM = AbstractMatrix3.prototype.modM;
      AbstractMatrix3.modulus = AbstractMatrix3.mod;
      AbstractMatrix3.prototype.and = function and(value) {
        if (typeof value === "number") return this.andS(value);
        return this.andM(value);
      };
      AbstractMatrix3.prototype.andS = function andS(value) {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) & value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.andM = function andM(matrix2) {
        matrix2 = Matrix4.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) & matrix2.get(i2, j2));
          }
        }
        return this;
      };
      AbstractMatrix3.and = function and(matrix2, value) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.and(value);
      };
      AbstractMatrix3.prototype.or = function or(value) {
        if (typeof value === "number") return this.orS(value);
        return this.orM(value);
      };
      AbstractMatrix3.prototype.orS = function orS(value) {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) | value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.orM = function orM(matrix2) {
        matrix2 = Matrix4.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) | matrix2.get(i2, j2));
          }
        }
        return this;
      };
      AbstractMatrix3.or = function or(matrix2, value) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.or(value);
      };
      AbstractMatrix3.prototype.xor = function xor(value) {
        if (typeof value === "number") return this.xorS(value);
        return this.xorM(value);
      };
      AbstractMatrix3.prototype.xorS = function xorS(value) {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) ^ value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.xorM = function xorM(matrix2) {
        matrix2 = Matrix4.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) ^ matrix2.get(i2, j2));
          }
        }
        return this;
      };
      AbstractMatrix3.xor = function xor(matrix2, value) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.xor(value);
      };
      AbstractMatrix3.prototype.leftShift = function leftShift(value) {
        if (typeof value === "number") return this.leftShiftS(value);
        return this.leftShiftM(value);
      };
      AbstractMatrix3.prototype.leftShiftS = function leftShiftS(value) {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) << value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.leftShiftM = function leftShiftM(matrix2) {
        matrix2 = Matrix4.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) << matrix2.get(i2, j2));
          }
        }
        return this;
      };
      AbstractMatrix3.leftShift = function leftShift(matrix2, value) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.leftShift(value);
      };
      AbstractMatrix3.prototype.signPropagatingRightShift = function signPropagatingRightShift(value) {
        if (typeof value === "number") return this.signPropagatingRightShiftS(value);
        return this.signPropagatingRightShiftM(value);
      };
      AbstractMatrix3.prototype.signPropagatingRightShiftS = function signPropagatingRightShiftS(value) {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) >> value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.signPropagatingRightShiftM = function signPropagatingRightShiftM(matrix2) {
        matrix2 = Matrix4.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) >> matrix2.get(i2, j2));
          }
        }
        return this;
      };
      AbstractMatrix3.signPropagatingRightShift = function signPropagatingRightShift(matrix2, value) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.signPropagatingRightShift(value);
      };
      AbstractMatrix3.prototype.rightShift = function rightShift(value) {
        if (typeof value === "number") return this.rightShiftS(value);
        return this.rightShiftM(value);
      };
      AbstractMatrix3.prototype.rightShiftS = function rightShiftS(value) {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) >>> value);
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.rightShiftM = function rightShiftM(matrix2) {
        matrix2 = Matrix4.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) >>> matrix2.get(i2, j2));
          }
        }
        return this;
      };
      AbstractMatrix3.rightShift = function rightShift(matrix2, value) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.rightShift(value);
      };
      AbstractMatrix3.prototype.zeroFillRightShift = AbstractMatrix3.prototype.rightShift;
      AbstractMatrix3.prototype.zeroFillRightShiftS = AbstractMatrix3.prototype.rightShiftS;
      AbstractMatrix3.prototype.zeroFillRightShiftM = AbstractMatrix3.prototype.rightShiftM;
      AbstractMatrix3.zeroFillRightShift = AbstractMatrix3.rightShift;
      AbstractMatrix3.prototype.not = function not() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, ~this.get(i2, j2));
          }
        }
        return this;
      };
      AbstractMatrix3.not = function not(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.not();
      };
      AbstractMatrix3.prototype.abs = function abs() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.abs(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.abs = function abs(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.abs();
      };
      AbstractMatrix3.prototype.acos = function acos() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.acos(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.acos = function acos(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.acos();
      };
      AbstractMatrix3.prototype.acosh = function acosh() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.acosh(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.acosh = function acosh(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.acosh();
      };
      AbstractMatrix3.prototype.asin = function asin() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.asin(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.asin = function asin(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.asin();
      };
      AbstractMatrix3.prototype.asinh = function asinh() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.asinh(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.asinh = function asinh(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.asinh();
      };
      AbstractMatrix3.prototype.atan = function atan() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.atan(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.atan = function atan(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.atan();
      };
      AbstractMatrix3.prototype.atanh = function atanh() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.atanh(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.atanh = function atanh(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.atanh();
      };
      AbstractMatrix3.prototype.cbrt = function cbrt() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.cbrt(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.cbrt = function cbrt(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.cbrt();
      };
      AbstractMatrix3.prototype.ceil = function ceil() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.ceil(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.ceil = function ceil(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.ceil();
      };
      AbstractMatrix3.prototype.clz32 = function clz32() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.clz32(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.clz32 = function clz32(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.clz32();
      };
      AbstractMatrix3.prototype.cos = function cos() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.cos(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.cos = function cos(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.cos();
      };
      AbstractMatrix3.prototype.cosh = function cosh() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.cosh(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.cosh = function cosh(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.cosh();
      };
      AbstractMatrix3.prototype.exp = function exp() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.exp(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.exp = function exp(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.exp();
      };
      AbstractMatrix3.prototype.expm1 = function expm1() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.expm1(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.expm1 = function expm1(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.expm1();
      };
      AbstractMatrix3.prototype.floor = function floor() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.floor(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.floor = function floor(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.floor();
      };
      AbstractMatrix3.prototype.fround = function fround() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.fround(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.fround = function fround(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.fround();
      };
      AbstractMatrix3.prototype.log = function log3() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.log(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.log = function log3(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.log();
      };
      AbstractMatrix3.prototype.log1p = function log1p() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.log1p(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.log1p = function log1p(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.log1p();
      };
      AbstractMatrix3.prototype.log10 = function log10() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.log10(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.log10 = function log10(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.log10();
      };
      AbstractMatrix3.prototype.log2 = function log22() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.log2(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.log2 = function log22(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.log2();
      };
      AbstractMatrix3.prototype.round = function round3() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.round(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.round = function round3(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.round();
      };
      AbstractMatrix3.prototype.sign = function sign() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.sign(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.sign = function sign(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.sign();
      };
      AbstractMatrix3.prototype.sin = function sin() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.sin(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.sin = function sin(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.sin();
      };
      AbstractMatrix3.prototype.sinh = function sinh() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.sinh(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.sinh = function sinh(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.sinh();
      };
      AbstractMatrix3.prototype.sqrt = function sqrt3() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.sqrt(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.sqrt = function sqrt3(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.sqrt();
      };
      AbstractMatrix3.prototype.tan = function tan() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.tan(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.tan = function tan(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.tan();
      };
      AbstractMatrix3.prototype.tanh = function tanh() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.tanh(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.tanh = function tanh(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.tanh();
      };
      AbstractMatrix3.prototype.trunc = function trunc() {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, Math.trunc(this.get(i2, j2)));
          }
        }
        return this;
      };
      AbstractMatrix3.trunc = function trunc(matrix2) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.trunc();
      };
      AbstractMatrix3.pow = function pow3(matrix2, arg0) {
        const newMatrix = new Matrix4(matrix2);
        return newMatrix.pow(arg0);
      };
      AbstractMatrix3.prototype.pow = function pow3(value) {
        if (typeof value === "number") return this.powS(value);
        return this.powM(value);
      };
      AbstractMatrix3.prototype.powS = function powS(value) {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, __pow(this.get(i2, j2), value));
          }
        }
        return this;
      };
      AbstractMatrix3.prototype.powM = function powM(matrix2) {
        matrix2 = Matrix4.checkMatrix(matrix2);
        if (this.rows !== matrix2.rows || this.columns !== matrix2.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, __pow(this.get(i2, j2), matrix2.get(i2, j2)));
          }
        }
        return this;
      };
    }
    function checkRowIndex(matrix2, index, outer) {
      let max2 = outer ? matrix2.rows : matrix2.rows - 1;
      if (index < 0 || index > max2) {
        throw new RangeError("Row index out of range");
      }
    }
    function checkColumnIndex(matrix2, index, outer) {
      let max2 = outer ? matrix2.columns : matrix2.columns - 1;
      if (index < 0 || index > max2) {
        throw new RangeError("Column index out of range");
      }
    }
    function checkRowVector(matrix2, vector) {
      if (vector.to1DArray) {
        vector = vector.to1DArray();
      }
      if (vector.length !== matrix2.columns) {
        throw new RangeError(
          "vector size must be the same as the number of columns"
        );
      }
      return vector;
    }
    function checkColumnVector(matrix2, vector) {
      if (vector.to1DArray) {
        vector = vector.to1DArray();
      }
      if (vector.length !== matrix2.rows) {
        throw new RangeError("vector size must be the same as the number of rows");
      }
      return vector;
    }
    function checkRowIndices(matrix2, rowIndices) {
      if (!isAnyArray2.isAnyArray(rowIndices)) {
        throw new TypeError("row indices must be an array");
      }
      for (let i2 = 0; i2 < rowIndices.length; i2++) {
        if (rowIndices[i2] < 0 || rowIndices[i2] >= matrix2.rows) {
          throw new RangeError("row indices are out of range");
        }
      }
    }
    function checkColumnIndices(matrix2, columnIndices) {
      if (!isAnyArray2.isAnyArray(columnIndices)) {
        throw new TypeError("column indices must be an array");
      }
      for (let i2 = 0; i2 < columnIndices.length; i2++) {
        if (columnIndices[i2] < 0 || columnIndices[i2] >= matrix2.columns) {
          throw new RangeError("column indices are out of range");
        }
      }
    }
    function checkRange(matrix2, startRow, endRow, startColumn, endColumn) {
      if (arguments.length !== 5) {
        throw new RangeError("expected 4 arguments");
      }
      checkNumber("startRow", startRow);
      checkNumber("endRow", endRow);
      checkNumber("startColumn", startColumn);
      checkNumber("endColumn", endColumn);
      if (startRow > endRow || startColumn > endColumn || startRow < 0 || startRow >= matrix2.rows || endRow < 0 || endRow >= matrix2.rows || startColumn < 0 || startColumn >= matrix2.columns || endColumn < 0 || endColumn >= matrix2.columns) {
        throw new RangeError("Submatrix indices are out of range");
      }
    }
    function newArray(length, value = 0) {
      let array = [];
      for (let i2 = 0; i2 < length; i2++) {
        array.push(value);
      }
      return array;
    }
    function checkNumber(name, value) {
      if (typeof value !== "number") {
        throw new TypeError(`${name} must be a number`);
      }
    }
    function checkNonEmpty(matrix2) {
      if (matrix2.isEmpty()) {
        throw new Error("Empty matrix has no elements to index");
      }
    }
    function sumByRow(matrix2) {
      let sum = newArray(matrix2.rows);
      for (let i2 = 0; i2 < matrix2.rows; ++i2) {
        for (let j2 = 0; j2 < matrix2.columns; ++j2) {
          sum[i2] += matrix2.get(i2, j2);
        }
      }
      return sum;
    }
    function sumByColumn(matrix2) {
      let sum = newArray(matrix2.columns);
      for (let i2 = 0; i2 < matrix2.rows; ++i2) {
        for (let j2 = 0; j2 < matrix2.columns; ++j2) {
          sum[j2] += matrix2.get(i2, j2);
        }
      }
      return sum;
    }
    function sumAll(matrix2) {
      let v3 = 0;
      for (let i2 = 0; i2 < matrix2.rows; i2++) {
        for (let j2 = 0; j2 < matrix2.columns; j2++) {
          v3 += matrix2.get(i2, j2);
        }
      }
      return v3;
    }
    function productByRow(matrix2) {
      let sum = newArray(matrix2.rows, 1);
      for (let i2 = 0; i2 < matrix2.rows; ++i2) {
        for (let j2 = 0; j2 < matrix2.columns; ++j2) {
          sum[i2] *= matrix2.get(i2, j2);
        }
      }
      return sum;
    }
    function productByColumn(matrix2) {
      let sum = newArray(matrix2.columns, 1);
      for (let i2 = 0; i2 < matrix2.rows; ++i2) {
        for (let j2 = 0; j2 < matrix2.columns; ++j2) {
          sum[j2] *= matrix2.get(i2, j2);
        }
      }
      return sum;
    }
    function productAll(matrix2) {
      let v3 = 1;
      for (let i2 = 0; i2 < matrix2.rows; i2++) {
        for (let j2 = 0; j2 < matrix2.columns; j2++) {
          v3 *= matrix2.get(i2, j2);
        }
      }
      return v3;
    }
    function varianceByRow(matrix2, unbiased, mean) {
      const rows = matrix2.rows;
      const cols = matrix2.columns;
      const variance = [];
      for (let i2 = 0; i2 < rows; i2++) {
        let sum1 = 0;
        let sum2 = 0;
        let x4 = 0;
        for (let j2 = 0; j2 < cols; j2++) {
          x4 = matrix2.get(i2, j2) - mean[i2];
          sum1 += x4;
          sum2 += x4 * x4;
        }
        if (unbiased) {
          variance.push((sum2 - sum1 * sum1 / cols) / (cols - 1));
        } else {
          variance.push((sum2 - sum1 * sum1 / cols) / cols);
        }
      }
      return variance;
    }
    function varianceByColumn(matrix2, unbiased, mean) {
      const rows = matrix2.rows;
      const cols = matrix2.columns;
      const variance = [];
      for (let j2 = 0; j2 < cols; j2++) {
        let sum1 = 0;
        let sum2 = 0;
        let x4 = 0;
        for (let i2 = 0; i2 < rows; i2++) {
          x4 = matrix2.get(i2, j2) - mean[j2];
          sum1 += x4;
          sum2 += x4 * x4;
        }
        if (unbiased) {
          variance.push((sum2 - sum1 * sum1 / rows) / (rows - 1));
        } else {
          variance.push((sum2 - sum1 * sum1 / rows) / rows);
        }
      }
      return variance;
    }
    function varianceAll(matrix2, unbiased, mean) {
      const rows = matrix2.rows;
      const cols = matrix2.columns;
      const size2 = rows * cols;
      let sum1 = 0;
      let sum2 = 0;
      let x4 = 0;
      for (let i2 = 0; i2 < rows; i2++) {
        for (let j2 = 0; j2 < cols; j2++) {
          x4 = matrix2.get(i2, j2) - mean;
          sum1 += x4;
          sum2 += x4 * x4;
        }
      }
      if (unbiased) {
        return (sum2 - sum1 * sum1 / size2) / (size2 - 1);
      } else {
        return (sum2 - sum1 * sum1 / size2) / size2;
      }
    }
    function centerByRow(matrix2, mean) {
      for (let i2 = 0; i2 < matrix2.rows; i2++) {
        for (let j2 = 0; j2 < matrix2.columns; j2++) {
          matrix2.set(i2, j2, matrix2.get(i2, j2) - mean[i2]);
        }
      }
    }
    function centerByColumn(matrix2, mean) {
      for (let i2 = 0; i2 < matrix2.rows; i2++) {
        for (let j2 = 0; j2 < matrix2.columns; j2++) {
          matrix2.set(i2, j2, matrix2.get(i2, j2) - mean[j2]);
        }
      }
    }
    function centerAll(matrix2, mean) {
      for (let i2 = 0; i2 < matrix2.rows; i2++) {
        for (let j2 = 0; j2 < matrix2.columns; j2++) {
          matrix2.set(i2, j2, matrix2.get(i2, j2) - mean);
        }
      }
    }
    function getScaleByRow(matrix2) {
      const scale2 = [];
      for (let i2 = 0; i2 < matrix2.rows; i2++) {
        let sum = 0;
        for (let j2 = 0; j2 < matrix2.columns; j2++) {
          sum += __pow(matrix2.get(i2, j2), 2) / (matrix2.columns - 1);
        }
        scale2.push(Math.sqrt(sum));
      }
      return scale2;
    }
    function scaleByRow(matrix2, scale2) {
      for (let i2 = 0; i2 < matrix2.rows; i2++) {
        for (let j2 = 0; j2 < matrix2.columns; j2++) {
          matrix2.set(i2, j2, matrix2.get(i2, j2) / scale2[i2]);
        }
      }
    }
    function getScaleByColumn(matrix2) {
      const scale2 = [];
      for (let j2 = 0; j2 < matrix2.columns; j2++) {
        let sum = 0;
        for (let i2 = 0; i2 < matrix2.rows; i2++) {
          sum += __pow(matrix2.get(i2, j2), 2) / (matrix2.rows - 1);
        }
        scale2.push(Math.sqrt(sum));
      }
      return scale2;
    }
    function scaleByColumn(matrix2, scale2) {
      for (let i2 = 0; i2 < matrix2.rows; i2++) {
        for (let j2 = 0; j2 < matrix2.columns; j2++) {
          matrix2.set(i2, j2, matrix2.get(i2, j2) / scale2[j2]);
        }
      }
    }
    function getScaleAll(matrix2) {
      const divider = matrix2.size - 1;
      let sum = 0;
      for (let j2 = 0; j2 < matrix2.columns; j2++) {
        for (let i2 = 0; i2 < matrix2.rows; i2++) {
          sum += __pow(matrix2.get(i2, j2), 2) / divider;
        }
      }
      return Math.sqrt(sum);
    }
    function scaleAll(matrix2, scale2) {
      for (let i2 = 0; i2 < matrix2.rows; i2++) {
        for (let j2 = 0; j2 < matrix2.columns; j2++) {
          matrix2.set(i2, j2, matrix2.get(i2, j2) / scale2);
        }
      }
    }
    var AbstractMatrix2 = class _AbstractMatrix {
      static from1DArray(newRows, newColumns, newData) {
        let length = newRows * newColumns;
        if (length !== newData.length) {
          throw new RangeError("data length does not match given dimensions");
        }
        let newMatrix = new Matrix3(newRows, newColumns);
        for (let row = 0; row < newRows; row++) {
          for (let column = 0; column < newColumns; column++) {
            newMatrix.set(row, column, newData[row * newColumns + column]);
          }
        }
        return newMatrix;
      }
      static rowVector(newData) {
        let vector = new Matrix3(1, newData.length);
        for (let i2 = 0; i2 < newData.length; i2++) {
          vector.set(0, i2, newData[i2]);
        }
        return vector;
      }
      static columnVector(newData) {
        let vector = new Matrix3(newData.length, 1);
        for (let i2 = 0; i2 < newData.length; i2++) {
          vector.set(i2, 0, newData[i2]);
        }
        return vector;
      }
      static zeros(rows, columns) {
        return new Matrix3(rows, columns);
      }
      static ones(rows, columns) {
        return new Matrix3(rows, columns).fill(1);
      }
      static rand(rows, columns, options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { random = Math.random } = options;
        let matrix2 = new Matrix3(rows, columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            matrix2.set(i2, j2, random());
          }
        }
        return matrix2;
      }
      static randInt(rows, columns, options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { min: min2 = 0, max: max2 = 1e3, random = Math.random } = options;
        if (!Number.isInteger(min2)) throw new TypeError("min must be an integer");
        if (!Number.isInteger(max2)) throw new TypeError("max must be an integer");
        if (min2 >= max2) throw new RangeError("min must be smaller than max");
        let interval = max2 - min2;
        let matrix2 = new Matrix3(rows, columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            let value = min2 + Math.round(random() * interval);
            matrix2.set(i2, j2, value);
          }
        }
        return matrix2;
      }
      static eye(rows, columns, value) {
        if (columns === void 0) columns = rows;
        if (value === void 0) value = 1;
        let min2 = Math.min(rows, columns);
        let matrix2 = this.zeros(rows, columns);
        for (let i2 = 0; i2 < min2; i2++) {
          matrix2.set(i2, i2, value);
        }
        return matrix2;
      }
      static diag(data, rows, columns) {
        let l3 = data.length;
        if (rows === void 0) rows = l3;
        if (columns === void 0) columns = rows;
        let min2 = Math.min(l3, rows, columns);
        let matrix2 = this.zeros(rows, columns);
        for (let i2 = 0; i2 < min2; i2++) {
          matrix2.set(i2, i2, data[i2]);
        }
        return matrix2;
      }
      static min(matrix1, matrix2) {
        matrix1 = this.checkMatrix(matrix1);
        matrix2 = this.checkMatrix(matrix2);
        let rows = matrix1.rows;
        let columns = matrix1.columns;
        let result = new Matrix3(rows, columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            result.set(i2, j2, Math.min(matrix1.get(i2, j2), matrix2.get(i2, j2)));
          }
        }
        return result;
      }
      static max(matrix1, matrix2) {
        matrix1 = this.checkMatrix(matrix1);
        matrix2 = this.checkMatrix(matrix2);
        let rows = matrix1.rows;
        let columns = matrix1.columns;
        let result = new this(rows, columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            result.set(i2, j2, Math.max(matrix1.get(i2, j2), matrix2.get(i2, j2)));
          }
        }
        return result;
      }
      static checkMatrix(value) {
        return _AbstractMatrix.isMatrix(value) ? value : new Matrix3(value);
      }
      static isMatrix(value) {
        return value != null && value.klass === "Matrix";
      }
      get size() {
        return this.rows * this.columns;
      }
      apply(callback) {
        if (typeof callback !== "function") {
          throw new TypeError("callback must be a function");
        }
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            callback.call(this, i2, j2);
          }
        }
        return this;
      }
      to1DArray() {
        let array = [];
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            array.push(this.get(i2, j2));
          }
        }
        return array;
      }
      to2DArray() {
        let copy = [];
        for (let i2 = 0; i2 < this.rows; i2++) {
          copy.push([]);
          for (let j2 = 0; j2 < this.columns; j2++) {
            copy[i2].push(this.get(i2, j2));
          }
        }
        return copy;
      }
      toJSON() {
        return this.to2DArray();
      }
      isRowVector() {
        return this.rows === 1;
      }
      isColumnVector() {
        return this.columns === 1;
      }
      isVector() {
        return this.rows === 1 || this.columns === 1;
      }
      isSquare() {
        return this.rows === this.columns;
      }
      isEmpty() {
        return this.rows === 0 || this.columns === 0;
      }
      isSymmetric() {
        if (this.isSquare()) {
          for (let i2 = 0; i2 < this.rows; i2++) {
            for (let j2 = 0; j2 <= i2; j2++) {
              if (this.get(i2, j2) !== this.get(j2, i2)) {
                return false;
              }
            }
          }
          return true;
        }
        return false;
      }
      isDistance() {
        if (!this.isSymmetric()) return false;
        for (let i2 = 0; i2 < this.rows; i2++) {
          if (this.get(i2, i2) !== 0) return false;
        }
        return true;
      }
      isEchelonForm() {
        let i2 = 0;
        let j2 = 0;
        let previousColumn = -1;
        let isEchelonForm = true;
        let checked = false;
        while (i2 < this.rows && isEchelonForm) {
          j2 = 0;
          checked = false;
          while (j2 < this.columns && checked === false) {
            if (this.get(i2, j2) === 0) {
              j2++;
            } else if (this.get(i2, j2) === 1 && j2 > previousColumn) {
              checked = true;
              previousColumn = j2;
            } else {
              isEchelonForm = false;
              checked = true;
            }
          }
          i2++;
        }
        return isEchelonForm;
      }
      isReducedEchelonForm() {
        let i2 = 0;
        let j2 = 0;
        let previousColumn = -1;
        let isReducedEchelonForm = true;
        let checked = false;
        while (i2 < this.rows && isReducedEchelonForm) {
          j2 = 0;
          checked = false;
          while (j2 < this.columns && checked === false) {
            if (this.get(i2, j2) === 0) {
              j2++;
            } else if (this.get(i2, j2) === 1 && j2 > previousColumn) {
              checked = true;
              previousColumn = j2;
            } else {
              isReducedEchelonForm = false;
              checked = true;
            }
          }
          for (let k2 = j2 + 1; k2 < this.rows; k2++) {
            if (this.get(i2, k2) !== 0) {
              isReducedEchelonForm = false;
            }
          }
          i2++;
        }
        return isReducedEchelonForm;
      }
      echelonForm() {
        let result = this.clone();
        let h3 = 0;
        let k2 = 0;
        while (h3 < result.rows && k2 < result.columns) {
          let iMax = h3;
          for (let i2 = h3; i2 < result.rows; i2++) {
            if (result.get(i2, k2) > result.get(iMax, k2)) {
              iMax = i2;
            }
          }
          if (result.get(iMax, k2) === 0) {
            k2++;
          } else {
            result.swapRows(h3, iMax);
            let tmp = result.get(h3, k2);
            for (let j2 = k2; j2 < result.columns; j2++) {
              result.set(h3, j2, result.get(h3, j2) / tmp);
            }
            for (let i2 = h3 + 1; i2 < result.rows; i2++) {
              let factor = result.get(i2, k2) / result.get(h3, k2);
              result.set(i2, k2, 0);
              for (let j2 = k2 + 1; j2 < result.columns; j2++) {
                result.set(i2, j2, result.get(i2, j2) - result.get(h3, j2) * factor);
              }
            }
            h3++;
            k2++;
          }
        }
        return result;
      }
      reducedEchelonForm() {
        let result = this.echelonForm();
        let m2 = result.columns;
        let n2 = result.rows;
        let h3 = n2 - 1;
        while (h3 >= 0) {
          if (result.maxRow(h3) === 0) {
            h3--;
          } else {
            let p3 = 0;
            let pivot = false;
            while (p3 < n2 && pivot === false) {
              if (result.get(h3, p3) === 1) {
                pivot = true;
              } else {
                p3++;
              }
            }
            for (let i2 = 0; i2 < h3; i2++) {
              let factor = result.get(i2, p3);
              for (let j2 = p3; j2 < m2; j2++) {
                let tmp = result.get(i2, j2) - factor * result.get(h3, j2);
                result.set(i2, j2, tmp);
              }
            }
            h3--;
          }
        }
        return result;
      }
      set() {
        throw new Error("set method is unimplemented");
      }
      get() {
        throw new Error("get method is unimplemented");
      }
      repeat(options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { rows = 1, columns = 1 } = options;
        if (!Number.isInteger(rows) || rows <= 0) {
          throw new TypeError("rows must be a positive integer");
        }
        if (!Number.isInteger(columns) || columns <= 0) {
          throw new TypeError("columns must be a positive integer");
        }
        let matrix2 = new Matrix3(this.rows * rows, this.columns * columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            matrix2.setSubMatrix(this, this.rows * i2, this.columns * j2);
          }
        }
        return matrix2;
      }
      fill(value) {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, value);
          }
        }
        return this;
      }
      neg() {
        return this.mulS(-1);
      }
      getRow(index) {
        checkRowIndex(this, index);
        let row = [];
        for (let i2 = 0; i2 < this.columns; i2++) {
          row.push(this.get(index, i2));
        }
        return row;
      }
      getRowVector(index) {
        return Matrix3.rowVector(this.getRow(index));
      }
      setRow(index, array) {
        checkRowIndex(this, index);
        array = checkRowVector(this, array);
        for (let i2 = 0; i2 < this.columns; i2++) {
          this.set(index, i2, array[i2]);
        }
        return this;
      }
      swapRows(row1, row2) {
        checkRowIndex(this, row1);
        checkRowIndex(this, row2);
        for (let i2 = 0; i2 < this.columns; i2++) {
          let temp = this.get(row1, i2);
          this.set(row1, i2, this.get(row2, i2));
          this.set(row2, i2, temp);
        }
        return this;
      }
      getColumn(index) {
        checkColumnIndex(this, index);
        let column = [];
        for (let i2 = 0; i2 < this.rows; i2++) {
          column.push(this.get(i2, index));
        }
        return column;
      }
      getColumnVector(index) {
        return Matrix3.columnVector(this.getColumn(index));
      }
      setColumn(index, array) {
        checkColumnIndex(this, index);
        array = checkColumnVector(this, array);
        for (let i2 = 0; i2 < this.rows; i2++) {
          this.set(i2, index, array[i2]);
        }
        return this;
      }
      swapColumns(column1, column2) {
        checkColumnIndex(this, column1);
        checkColumnIndex(this, column2);
        for (let i2 = 0; i2 < this.rows; i2++) {
          let temp = this.get(i2, column1);
          this.set(i2, column1, this.get(i2, column2));
          this.set(i2, column2, temp);
        }
        return this;
      }
      addRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) + vector[j2]);
          }
        }
        return this;
      }
      subRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) - vector[j2]);
          }
        }
        return this;
      }
      mulRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) * vector[j2]);
          }
        }
        return this;
      }
      divRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) / vector[j2]);
          }
        }
        return this;
      }
      addColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) + vector[i2]);
          }
        }
        return this;
      }
      subColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) - vector[i2]);
          }
        }
        return this;
      }
      mulColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) * vector[i2]);
          }
        }
        return this;
      }
      divColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) / vector[i2]);
          }
        }
        return this;
      }
      mulRow(index, value) {
        checkRowIndex(this, index);
        for (let i2 = 0; i2 < this.columns; i2++) {
          this.set(index, i2, this.get(index, i2) * value);
        }
        return this;
      }
      mulColumn(index, value) {
        checkColumnIndex(this, index);
        for (let i2 = 0; i2 < this.rows; i2++) {
          this.set(i2, index, this.get(i2, index) * value);
        }
        return this;
      }
      max(by) {
        if (this.isEmpty()) {
          return NaN;
        }
        switch (by) {
          case "row": {
            const max2 = new Array(this.rows).fill(Number.NEGATIVE_INFINITY);
            for (let row = 0; row < this.rows; row++) {
              for (let column = 0; column < this.columns; column++) {
                if (this.get(row, column) > max2[row]) {
                  max2[row] = this.get(row, column);
                }
              }
            }
            return max2;
          }
          case "column": {
            const max2 = new Array(this.columns).fill(Number.NEGATIVE_INFINITY);
            for (let row = 0; row < this.rows; row++) {
              for (let column = 0; column < this.columns; column++) {
                if (this.get(row, column) > max2[column]) {
                  max2[column] = this.get(row, column);
                }
              }
            }
            return max2;
          }
          case void 0: {
            let max2 = this.get(0, 0);
            for (let row = 0; row < this.rows; row++) {
              for (let column = 0; column < this.columns; column++) {
                if (this.get(row, column) > max2) {
                  max2 = this.get(row, column);
                }
              }
            }
            return max2;
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      maxIndex() {
        checkNonEmpty(this);
        let v3 = this.get(0, 0);
        let idx = [0, 0];
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            if (this.get(i2, j2) > v3) {
              v3 = this.get(i2, j2);
              idx[0] = i2;
              idx[1] = j2;
            }
          }
        }
        return idx;
      }
      min(by) {
        if (this.isEmpty()) {
          return NaN;
        }
        switch (by) {
          case "row": {
            const min2 = new Array(this.rows).fill(Number.POSITIVE_INFINITY);
            for (let row = 0; row < this.rows; row++) {
              for (let column = 0; column < this.columns; column++) {
                if (this.get(row, column) < min2[row]) {
                  min2[row] = this.get(row, column);
                }
              }
            }
            return min2;
          }
          case "column": {
            const min2 = new Array(this.columns).fill(Number.POSITIVE_INFINITY);
            for (let row = 0; row < this.rows; row++) {
              for (let column = 0; column < this.columns; column++) {
                if (this.get(row, column) < min2[column]) {
                  min2[column] = this.get(row, column);
                }
              }
            }
            return min2;
          }
          case void 0: {
            let min2 = this.get(0, 0);
            for (let row = 0; row < this.rows; row++) {
              for (let column = 0; column < this.columns; column++) {
                if (this.get(row, column) < min2) {
                  min2 = this.get(row, column);
                }
              }
            }
            return min2;
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      minIndex() {
        checkNonEmpty(this);
        let v3 = this.get(0, 0);
        let idx = [0, 0];
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            if (this.get(i2, j2) < v3) {
              v3 = this.get(i2, j2);
              idx[0] = i2;
              idx[1] = j2;
            }
          }
        }
        return idx;
      }
      maxRow(row) {
        checkRowIndex(this, row);
        if (this.isEmpty()) {
          return NaN;
        }
        let v3 = this.get(row, 0);
        for (let i2 = 1; i2 < this.columns; i2++) {
          if (this.get(row, i2) > v3) {
            v3 = this.get(row, i2);
          }
        }
        return v3;
      }
      maxRowIndex(row) {
        checkRowIndex(this, row);
        checkNonEmpty(this);
        let v3 = this.get(row, 0);
        let idx = [row, 0];
        for (let i2 = 1; i2 < this.columns; i2++) {
          if (this.get(row, i2) > v3) {
            v3 = this.get(row, i2);
            idx[1] = i2;
          }
        }
        return idx;
      }
      minRow(row) {
        checkRowIndex(this, row);
        if (this.isEmpty()) {
          return NaN;
        }
        let v3 = this.get(row, 0);
        for (let i2 = 1; i2 < this.columns; i2++) {
          if (this.get(row, i2) < v3) {
            v3 = this.get(row, i2);
          }
        }
        return v3;
      }
      minRowIndex(row) {
        checkRowIndex(this, row);
        checkNonEmpty(this);
        let v3 = this.get(row, 0);
        let idx = [row, 0];
        for (let i2 = 1; i2 < this.columns; i2++) {
          if (this.get(row, i2) < v3) {
            v3 = this.get(row, i2);
            idx[1] = i2;
          }
        }
        return idx;
      }
      maxColumn(column) {
        checkColumnIndex(this, column);
        if (this.isEmpty()) {
          return NaN;
        }
        let v3 = this.get(0, column);
        for (let i2 = 1; i2 < this.rows; i2++) {
          if (this.get(i2, column) > v3) {
            v3 = this.get(i2, column);
          }
        }
        return v3;
      }
      maxColumnIndex(column) {
        checkColumnIndex(this, column);
        checkNonEmpty(this);
        let v3 = this.get(0, column);
        let idx = [0, column];
        for (let i2 = 1; i2 < this.rows; i2++) {
          if (this.get(i2, column) > v3) {
            v3 = this.get(i2, column);
            idx[0] = i2;
          }
        }
        return idx;
      }
      minColumn(column) {
        checkColumnIndex(this, column);
        if (this.isEmpty()) {
          return NaN;
        }
        let v3 = this.get(0, column);
        for (let i2 = 1; i2 < this.rows; i2++) {
          if (this.get(i2, column) < v3) {
            v3 = this.get(i2, column);
          }
        }
        return v3;
      }
      minColumnIndex(column) {
        checkColumnIndex(this, column);
        checkNonEmpty(this);
        let v3 = this.get(0, column);
        let idx = [0, column];
        for (let i2 = 1; i2 < this.rows; i2++) {
          if (this.get(i2, column) < v3) {
            v3 = this.get(i2, column);
            idx[0] = i2;
          }
        }
        return idx;
      }
      diag() {
        let min2 = Math.min(this.rows, this.columns);
        let diag = [];
        for (let i2 = 0; i2 < min2; i2++) {
          diag.push(this.get(i2, i2));
        }
        return diag;
      }
      norm(type = "frobenius") {
        switch (type) {
          case "max":
            return this.max();
          case "frobenius":
            return Math.sqrt(this.dot(this));
          default:
            throw new RangeError(`unknown norm type: ${type}`);
        }
      }
      cumulativeSum() {
        let sum = 0;
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            sum += this.get(i2, j2);
            this.set(i2, j2, sum);
          }
        }
        return this;
      }
      dot(vector2) {
        if (_AbstractMatrix.isMatrix(vector2)) vector2 = vector2.to1DArray();
        let vector1 = this.to1DArray();
        if (vector1.length !== vector2.length) {
          throw new RangeError("vectors do not have the same size");
        }
        let dot2 = 0;
        for (let i2 = 0; i2 < vector1.length; i2++) {
          dot2 += vector1[i2] * vector2[i2];
        }
        return dot2;
      }
      mmul(other) {
        other = Matrix3.checkMatrix(other);
        let m2 = this.rows;
        let n2 = this.columns;
        let p3 = other.columns;
        let result = new Matrix3(m2, p3);
        let Bcolj = new Float64Array(n2);
        for (let j2 = 0; j2 < p3; j2++) {
          for (let k2 = 0; k2 < n2; k2++) {
            Bcolj[k2] = other.get(k2, j2);
          }
          for (let i2 = 0; i2 < m2; i2++) {
            let s2 = 0;
            for (let k2 = 0; k2 < n2; k2++) {
              s2 += this.get(i2, k2) * Bcolj[k2];
            }
            result.set(i2, j2, s2);
          }
        }
        return result;
      }
      mpow(scalar) {
        if (!this.isSquare()) {
          throw new RangeError("Matrix must be square");
        }
        if (!Number.isInteger(scalar) || scalar < 0) {
          throw new RangeError("Exponent must be a non-negative integer");
        }
        let result = Matrix3.eye(this.rows);
        let bb = this;
        for (let e2 = scalar; e2 >= 1; e2 /= 2) {
          if ((e2 & 1) !== 0) {
            result = result.mmul(bb);
          }
          bb = bb.mmul(bb);
        }
        return result;
      }
      strassen2x2(other) {
        other = Matrix3.checkMatrix(other);
        let result = new Matrix3(2, 2);
        const a11 = this.get(0, 0);
        const b11 = other.get(0, 0);
        const a12 = this.get(0, 1);
        const b12 = other.get(0, 1);
        const a21 = this.get(1, 0);
        const b21 = other.get(1, 0);
        const a22 = this.get(1, 1);
        const b22 = other.get(1, 1);
        const m1 = (a11 + a22) * (b11 + b22);
        const m2 = (a21 + a22) * b11;
        const m3 = a11 * (b12 - b22);
        const m4 = a22 * (b21 - b11);
        const m5 = (a11 + a12) * b22;
        const m6 = (a21 - a11) * (b11 + b12);
        const m7 = (a12 - a22) * (b21 + b22);
        const c00 = m1 + m4 - m5 + m7;
        const c01 = m3 + m5;
        const c10 = m2 + m4;
        const c11 = m1 - m2 + m3 + m6;
        result.set(0, 0, c00);
        result.set(0, 1, c01);
        result.set(1, 0, c10);
        result.set(1, 1, c11);
        return result;
      }
      strassen3x3(other) {
        other = Matrix3.checkMatrix(other);
        let result = new Matrix3(3, 3);
        const a00 = this.get(0, 0);
        const a01 = this.get(0, 1);
        const a02 = this.get(0, 2);
        const a10 = this.get(1, 0);
        const a11 = this.get(1, 1);
        const a12 = this.get(1, 2);
        const a20 = this.get(2, 0);
        const a21 = this.get(2, 1);
        const a22 = this.get(2, 2);
        const b00 = other.get(0, 0);
        const b01 = other.get(0, 1);
        const b02 = other.get(0, 2);
        const b10 = other.get(1, 0);
        const b11 = other.get(1, 1);
        const b12 = other.get(1, 2);
        const b20 = other.get(2, 0);
        const b21 = other.get(2, 1);
        const b22 = other.get(2, 2);
        const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;
        const m2 = (a00 - a10) * (-b01 + b11);
        const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);
        const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);
        const m5 = (a10 + a11) * (-b00 + b01);
        const m6 = a00 * b00;
        const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);
        const m8 = (-a00 + a20) * (b02 - b12);
        const m9 = (a20 + a21) * (-b00 + b02);
        const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;
        const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);
        const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);
        const m13 = (a02 - a22) * (b11 - b21);
        const m14 = a02 * b20;
        const m15 = (a21 + a22) * (-b20 + b21);
        const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);
        const m17 = (a02 - a12) * (b12 - b22);
        const m18 = (a11 + a12) * (-b20 + b22);
        const m19 = a01 * b10;
        const m20 = a12 * b21;
        const m21 = a10 * b02;
        const m22 = a20 * b01;
        const m23 = a22 * b22;
        const c00 = m6 + m14 + m19;
        const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;
        const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;
        const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;
        const c11 = m2 + m4 + m5 + m6 + m20;
        const c12 = m14 + m16 + m17 + m18 + m21;
        const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;
        const c21 = m12 + m13 + m14 + m15 + m22;
        const c22 = m6 + m7 + m8 + m9 + m23;
        result.set(0, 0, c00);
        result.set(0, 1, c01);
        result.set(0, 2, c02);
        result.set(1, 0, c10);
        result.set(1, 1, c11);
        result.set(1, 2, c12);
        result.set(2, 0, c20);
        result.set(2, 1, c21);
        result.set(2, 2, c22);
        return result;
      }
      mmulStrassen(y4) {
        y4 = Matrix3.checkMatrix(y4);
        let x4 = this.clone();
        let r1 = x4.rows;
        let c1 = x4.columns;
        let r22 = y4.rows;
        let c22 = y4.columns;
        if (c1 !== r22) {
          console.warn(
            `Multiplying ${r1} x ${c1} and ${r22} x ${c22} matrix: dimensions do not match.`
          );
        }
        function embed(mat, rows, cols) {
          let r4 = mat.rows;
          let c4 = mat.columns;
          if (r4 === rows && c4 === cols) {
            return mat;
          } else {
            let resultat = _AbstractMatrix.zeros(rows, cols);
            resultat = resultat.setSubMatrix(mat, 0, 0);
            return resultat;
          }
        }
        let r3 = Math.max(r1, r22);
        let c3 = Math.max(c1, c22);
        x4 = embed(x4, r3, c3);
        y4 = embed(y4, r3, c3);
        function blockMult(a3, b3, rows, cols) {
          if (rows <= 512 || cols <= 512) {
            return a3.mmul(b3);
          }
          if (rows % 2 === 1 && cols % 2 === 1) {
            a3 = embed(a3, rows + 1, cols + 1);
            b3 = embed(b3, rows + 1, cols + 1);
          } else if (rows % 2 === 1) {
            a3 = embed(a3, rows + 1, cols);
            b3 = embed(b3, rows + 1, cols);
          } else if (cols % 2 === 1) {
            a3 = embed(a3, rows, cols + 1);
            b3 = embed(b3, rows, cols + 1);
          }
          let halfRows = parseInt(a3.rows / 2, 10);
          let halfCols = parseInt(a3.columns / 2, 10);
          let a11 = a3.subMatrix(0, halfRows - 1, 0, halfCols - 1);
          let b11 = b3.subMatrix(0, halfRows - 1, 0, halfCols - 1);
          let a12 = a3.subMatrix(0, halfRows - 1, halfCols, a3.columns - 1);
          let b12 = b3.subMatrix(0, halfRows - 1, halfCols, b3.columns - 1);
          let a21 = a3.subMatrix(halfRows, a3.rows - 1, 0, halfCols - 1);
          let b21 = b3.subMatrix(halfRows, b3.rows - 1, 0, halfCols - 1);
          let a22 = a3.subMatrix(halfRows, a3.rows - 1, halfCols, a3.columns - 1);
          let b22 = b3.subMatrix(halfRows, b3.rows - 1, halfCols, b3.columns - 1);
          let m1 = blockMult(
            _AbstractMatrix.add(a11, a22),
            _AbstractMatrix.add(b11, b22),
            halfRows,
            halfCols
          );
          let m2 = blockMult(_AbstractMatrix.add(a21, a22), b11, halfRows, halfCols);
          let m3 = blockMult(a11, _AbstractMatrix.sub(b12, b22), halfRows, halfCols);
          let m4 = blockMult(a22, _AbstractMatrix.sub(b21, b11), halfRows, halfCols);
          let m5 = blockMult(_AbstractMatrix.add(a11, a12), b22, halfRows, halfCols);
          let m6 = blockMult(
            _AbstractMatrix.sub(a21, a11),
            _AbstractMatrix.add(b11, b12),
            halfRows,
            halfCols
          );
          let m7 = blockMult(
            _AbstractMatrix.sub(a12, a22),
            _AbstractMatrix.add(b21, b22),
            halfRows,
            halfCols
          );
          let c11 = _AbstractMatrix.add(m1, m4);
          c11.sub(m5);
          c11.add(m7);
          let c12 = _AbstractMatrix.add(m3, m5);
          let c21 = _AbstractMatrix.add(m2, m4);
          let c222 = _AbstractMatrix.sub(m1, m2);
          c222.add(m3);
          c222.add(m6);
          let result = _AbstractMatrix.zeros(2 * c11.rows, 2 * c11.columns);
          result = result.setSubMatrix(c11, 0, 0);
          result = result.setSubMatrix(c12, c11.rows, 0);
          result = result.setSubMatrix(c21, 0, c11.columns);
          result = result.setSubMatrix(c222, c11.rows, c11.columns);
          return result.subMatrix(0, rows - 1, 0, cols - 1);
        }
        return blockMult(x4, y4, r3, c3);
      }
      scaleRows(options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { min: min2 = 0, max: max2 = 1 } = options;
        if (!Number.isFinite(min2)) throw new TypeError("min must be a number");
        if (!Number.isFinite(max2)) throw new TypeError("max must be a number");
        if (min2 >= max2) throw new RangeError("min must be smaller than max");
        let newMatrix = new Matrix3(this.rows, this.columns);
        for (let i2 = 0; i2 < this.rows; i2++) {
          const row = this.getRow(i2);
          if (row.length > 0) {
            rescale2(row, { min: min2, max: max2, output: row });
          }
          newMatrix.setRow(i2, row);
        }
        return newMatrix;
      }
      scaleColumns(options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { min: min2 = 0, max: max2 = 1 } = options;
        if (!Number.isFinite(min2)) throw new TypeError("min must be a number");
        if (!Number.isFinite(max2)) throw new TypeError("max must be a number");
        if (min2 >= max2) throw new RangeError("min must be smaller than max");
        let newMatrix = new Matrix3(this.rows, this.columns);
        for (let i2 = 0; i2 < this.columns; i2++) {
          const column = this.getColumn(i2);
          if (column.length) {
            rescale2(column, {
              min: min2,
              max: max2,
              output: column
            });
          }
          newMatrix.setColumn(i2, column);
        }
        return newMatrix;
      }
      flipRows() {
        const middle = Math.ceil(this.columns / 2);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < middle; j2++) {
            let first = this.get(i2, j2);
            let last2 = this.get(i2, this.columns - 1 - j2);
            this.set(i2, j2, last2);
            this.set(i2, this.columns - 1 - j2, first);
          }
        }
        return this;
      }
      flipColumns() {
        const middle = Math.ceil(this.rows / 2);
        for (let j2 = 0; j2 < this.columns; j2++) {
          for (let i2 = 0; i2 < middle; i2++) {
            let first = this.get(i2, j2);
            let last2 = this.get(this.rows - 1 - i2, j2);
            this.set(i2, j2, last2);
            this.set(this.rows - 1 - i2, j2, first);
          }
        }
        return this;
      }
      kroneckerProduct(other) {
        other = Matrix3.checkMatrix(other);
        let m2 = this.rows;
        let n2 = this.columns;
        let p3 = other.rows;
        let q2 = other.columns;
        let result = new Matrix3(m2 * p3, n2 * q2);
        for (let i2 = 0; i2 < m2; i2++) {
          for (let j2 = 0; j2 < n2; j2++) {
            for (let k2 = 0; k2 < p3; k2++) {
              for (let l3 = 0; l3 < q2; l3++) {
                result.set(p3 * i2 + k2, q2 * j2 + l3, this.get(i2, j2) * other.get(k2, l3));
              }
            }
          }
        }
        return result;
      }
      kroneckerSum(other) {
        other = Matrix3.checkMatrix(other);
        if (!this.isSquare() || !other.isSquare()) {
          throw new Error("Kronecker Sum needs two Square Matrices");
        }
        let m2 = this.rows;
        let n2 = other.rows;
        let AxI = this.kroneckerProduct(Matrix3.eye(n2, n2));
        let IxB = Matrix3.eye(m2, m2).kroneckerProduct(other);
        return AxI.add(IxB);
      }
      transpose() {
        let result = new Matrix3(this.columns, this.rows);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            result.set(j2, i2, this.get(i2, j2));
          }
        }
        return result;
      }
      sortRows(compareFunction = compareNumbers) {
        for (let i2 = 0; i2 < this.rows; i2++) {
          this.setRow(i2, this.getRow(i2).sort(compareFunction));
        }
        return this;
      }
      sortColumns(compareFunction = compareNumbers) {
        for (let i2 = 0; i2 < this.columns; i2++) {
          this.setColumn(i2, this.getColumn(i2).sort(compareFunction));
        }
        return this;
      }
      subMatrix(startRow, endRow, startColumn, endColumn) {
        checkRange(this, startRow, endRow, startColumn, endColumn);
        let newMatrix = new Matrix3(
          endRow - startRow + 1,
          endColumn - startColumn + 1
        );
        for (let i2 = startRow; i2 <= endRow; i2++) {
          for (let j2 = startColumn; j2 <= endColumn; j2++) {
            newMatrix.set(i2 - startRow, j2 - startColumn, this.get(i2, j2));
          }
        }
        return newMatrix;
      }
      subMatrixRow(indices, startColumn, endColumn) {
        if (startColumn === void 0) startColumn = 0;
        if (endColumn === void 0) endColumn = this.columns - 1;
        if (startColumn > endColumn || startColumn < 0 || startColumn >= this.columns || endColumn < 0 || endColumn >= this.columns) {
          throw new RangeError("Argument out of range");
        }
        let newMatrix = new Matrix3(indices.length, endColumn - startColumn + 1);
        for (let i2 = 0; i2 < indices.length; i2++) {
          for (let j2 = startColumn; j2 <= endColumn; j2++) {
            if (indices[i2] < 0 || indices[i2] >= this.rows) {
              throw new RangeError(`Row index out of range: ${indices[i2]}`);
            }
            newMatrix.set(i2, j2 - startColumn, this.get(indices[i2], j2));
          }
        }
        return newMatrix;
      }
      subMatrixColumn(indices, startRow, endRow) {
        if (startRow === void 0) startRow = 0;
        if (endRow === void 0) endRow = this.rows - 1;
        if (startRow > endRow || startRow < 0 || startRow >= this.rows || endRow < 0 || endRow >= this.rows) {
          throw new RangeError("Argument out of range");
        }
        let newMatrix = new Matrix3(endRow - startRow + 1, indices.length);
        for (let i2 = 0; i2 < indices.length; i2++) {
          for (let j2 = startRow; j2 <= endRow; j2++) {
            if (indices[i2] < 0 || indices[i2] >= this.columns) {
              throw new RangeError(`Column index out of range: ${indices[i2]}`);
            }
            newMatrix.set(j2 - startRow, i2, this.get(j2, indices[i2]));
          }
        }
        return newMatrix;
      }
      setSubMatrix(matrix2, startRow, startColumn) {
        matrix2 = Matrix3.checkMatrix(matrix2);
        if (matrix2.isEmpty()) {
          return this;
        }
        let endRow = startRow + matrix2.rows - 1;
        let endColumn = startColumn + matrix2.columns - 1;
        checkRange(this, startRow, endRow, startColumn, endColumn);
        for (let i2 = 0; i2 < matrix2.rows; i2++) {
          for (let j2 = 0; j2 < matrix2.columns; j2++) {
            this.set(startRow + i2, startColumn + j2, matrix2.get(i2, j2));
          }
        }
        return this;
      }
      selection(rowIndices, columnIndices) {
        checkRowIndices(this, rowIndices);
        checkColumnIndices(this, columnIndices);
        let newMatrix = new Matrix3(rowIndices.length, columnIndices.length);
        for (let i2 = 0; i2 < rowIndices.length; i2++) {
          let rowIndex = rowIndices[i2];
          for (let j2 = 0; j2 < columnIndices.length; j2++) {
            let columnIndex = columnIndices[j2];
            newMatrix.set(i2, j2, this.get(rowIndex, columnIndex));
          }
        }
        return newMatrix;
      }
      trace() {
        let min2 = Math.min(this.rows, this.columns);
        let trace = 0;
        for (let i2 = 0; i2 < min2; i2++) {
          trace += this.get(i2, i2);
        }
        return trace;
      }
      clone() {
        return this.constructor.copy(this, new Matrix3(this.rows, this.columns));
      }
      /**
       * @template {AbstractMatrix} M
       * @param {AbstractMatrix} from
       * @param {M} to
       * @return {M}
       */
      static copy(from, to) {
        for (const [row, column, value] of from.entries()) {
          to.set(row, column, value);
        }
        return to;
      }
      sum(by) {
        switch (by) {
          case "row":
            return sumByRow(this);
          case "column":
            return sumByColumn(this);
          case void 0:
            return sumAll(this);
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      product(by) {
        switch (by) {
          case "row":
            return productByRow(this);
          case "column":
            return productByColumn(this);
          case void 0:
            return productAll(this);
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      mean(by) {
        const sum = this.sum(by);
        switch (by) {
          case "row": {
            for (let i2 = 0; i2 < this.rows; i2++) {
              sum[i2] /= this.columns;
            }
            return sum;
          }
          case "column": {
            for (let i2 = 0; i2 < this.columns; i2++) {
              sum[i2] /= this.rows;
            }
            return sum;
          }
          case void 0:
            return sum / this.size;
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      variance(by, options = {}) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { unbiased = true, mean = this.mean(by) } = options;
        if (typeof unbiased !== "boolean") {
          throw new TypeError("unbiased must be a boolean");
        }
        switch (by) {
          case "row": {
            if (!isAnyArray2.isAnyArray(mean)) {
              throw new TypeError("mean must be an array");
            }
            return varianceByRow(this, unbiased, mean);
          }
          case "column": {
            if (!isAnyArray2.isAnyArray(mean)) {
              throw new TypeError("mean must be an array");
            }
            return varianceByColumn(this, unbiased, mean);
          }
          case void 0: {
            if (typeof mean !== "number") {
              throw new TypeError("mean must be a number");
            }
            return varianceAll(this, unbiased, mean);
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      standardDeviation(by, options) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        const variance = this.variance(by, options);
        if (by === void 0) {
          return Math.sqrt(variance);
        } else {
          for (let i2 = 0; i2 < variance.length; i2++) {
            variance[i2] = Math.sqrt(variance[i2]);
          }
          return variance;
        }
      }
      center(by, options = {}) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { center = this.mean(by) } = options;
        switch (by) {
          case "row": {
            if (!isAnyArray2.isAnyArray(center)) {
              throw new TypeError("center must be an array");
            }
            centerByRow(this, center);
            return this;
          }
          case "column": {
            if (!isAnyArray2.isAnyArray(center)) {
              throw new TypeError("center must be an array");
            }
            centerByColumn(this, center);
            return this;
          }
          case void 0: {
            if (typeof center !== "number") {
              throw new TypeError("center must be a number");
            }
            centerAll(this, center);
            return this;
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      scale(by, options = {}) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        let scale2 = options.scale;
        switch (by) {
          case "row": {
            if (scale2 === void 0) {
              scale2 = getScaleByRow(this);
            } else if (!isAnyArray2.isAnyArray(scale2)) {
              throw new TypeError("scale must be an array");
            }
            scaleByRow(this, scale2);
            return this;
          }
          case "column": {
            if (scale2 === void 0) {
              scale2 = getScaleByColumn(this);
            } else if (!isAnyArray2.isAnyArray(scale2)) {
              throw new TypeError("scale must be an array");
            }
            scaleByColumn(this, scale2);
            return this;
          }
          case void 0: {
            if (scale2 === void 0) {
              scale2 = getScaleAll(this);
            } else if (typeof scale2 !== "number") {
              throw new TypeError("scale must be a number");
            }
            scaleAll(this, scale2);
            return this;
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      toString(options) {
        return inspectMatrixWithOptions(this, options);
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      /**
       * iterator from left to right, from top to bottom
       * yield [row, column, value]
       * @returns {Generator<[number, number, number], void, void>}
       */
      *entries() {
        for (let row = 0; row < this.rows; row++) {
          for (let col = 0; col < this.columns; col++) {
            yield [row, col, this.get(row, col)];
          }
        }
      }
      /**
       * iterator from left to right, from top to bottom
       * yield value
       * @returns {Generator<number, void, void>}
       */
      *values() {
        for (let row = 0; row < this.rows; row++) {
          for (let col = 0; col < this.columns; col++) {
            yield this.get(row, col);
          }
        }
      }
    };
    AbstractMatrix2.prototype.klass = "Matrix";
    if (typeof Symbol !== "undefined") {
      AbstractMatrix2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspectMatrix;
    }
    function compareNumbers(a3, b3) {
      return a3 - b3;
    }
    function isArrayOfNumbers(array) {
      return array.every((element) => {
        return typeof element === "number";
      });
    }
    AbstractMatrix2.random = AbstractMatrix2.rand;
    AbstractMatrix2.randomInt = AbstractMatrix2.randInt;
    AbstractMatrix2.diagonal = AbstractMatrix2.diag;
    AbstractMatrix2.prototype.diagonal = AbstractMatrix2.prototype.diag;
    AbstractMatrix2.identity = AbstractMatrix2.eye;
    AbstractMatrix2.prototype.negate = AbstractMatrix2.prototype.neg;
    AbstractMatrix2.prototype.tensorProduct = AbstractMatrix2.prototype.kroneckerProduct;
    var _Matrix_instances, initData_fn;
    var _Matrix = class _Matrix extends AbstractMatrix2 {
      constructor(nRows, nColumns) {
        super();
        __privateAdd(this, _Matrix_instances);
        /**
         * @type {Float64Array[]}
         */
        __publicField(this, "data");
        if (_Matrix.isMatrix(nRows)) {
          __privateMethod(this, _Matrix_instances, initData_fn).call(this, nRows.rows, nRows.columns);
          _Matrix.copy(nRows, this);
        } else if (Number.isInteger(nRows) && nRows >= 0) {
          __privateMethod(this, _Matrix_instances, initData_fn).call(this, nRows, nColumns);
        } else if (isAnyArray2.isAnyArray(nRows)) {
          const arrayData = nRows;
          nRows = arrayData.length;
          nColumns = nRows ? arrayData[0].length : 0;
          if (typeof nColumns !== "number") {
            throw new TypeError(
              "Data must be a 2D array with at least one element"
            );
          }
          this.data = [];
          for (let i2 = 0; i2 < nRows; i2++) {
            if (arrayData[i2].length !== nColumns) {
              throw new RangeError("Inconsistent array dimensions");
            }
            if (!isArrayOfNumbers(arrayData[i2])) {
              throw new TypeError("Input data contains non-numeric values");
            }
            this.data.push(Float64Array.from(arrayData[i2]));
          }
          this.rows = nRows;
          this.columns = nColumns;
        } else {
          throw new TypeError(
            "First argument must be a positive number or an array"
          );
        }
      }
      set(rowIndex, columnIndex, value) {
        this.data[rowIndex][columnIndex] = value;
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.data[rowIndex][columnIndex];
      }
      removeRow(index) {
        checkRowIndex(this, index);
        this.data.splice(index, 1);
        this.rows -= 1;
        return this;
      }
      addRow(index, array) {
        if (array === void 0) {
          array = index;
          index = this.rows;
        }
        checkRowIndex(this, index, true);
        array = Float64Array.from(checkRowVector(this, array));
        this.data.splice(index, 0, array);
        this.rows += 1;
        return this;
      }
      removeColumn(index) {
        checkColumnIndex(this, index);
        for (let i2 = 0; i2 < this.rows; i2++) {
          const newRow = new Float64Array(this.columns - 1);
          for (let j2 = 0; j2 < index; j2++) {
            newRow[j2] = this.data[i2][j2];
          }
          for (let j2 = index + 1; j2 < this.columns; j2++) {
            newRow[j2 - 1] = this.data[i2][j2];
          }
          this.data[i2] = newRow;
        }
        this.columns -= 1;
        return this;
      }
      addColumn(index, array) {
        if (typeof array === "undefined") {
          array = index;
          index = this.columns;
        }
        checkColumnIndex(this, index, true);
        array = checkColumnVector(this, array);
        for (let i2 = 0; i2 < this.rows; i2++) {
          const newRow = new Float64Array(this.columns + 1);
          let j2 = 0;
          for (; j2 < index; j2++) {
            newRow[j2] = this.data[i2][j2];
          }
          newRow[j2++] = array[i2];
          for (; j2 < this.columns + 1; j2++) {
            newRow[j2] = this.data[i2][j2 - 1];
          }
          this.data[i2] = newRow;
        }
        this.columns += 1;
        return this;
      }
    };
    _Matrix_instances = new WeakSet();
    /**
     * Init an empty matrix
     * @param {number} nRows
     * @param {number} nColumns
     */
    initData_fn = function(nRows, nColumns) {
      this.data = [];
      if (Number.isInteger(nColumns) && nColumns >= 0) {
        for (let i2 = 0; i2 < nRows; i2++) {
          this.data.push(new Float64Array(nColumns));
        }
      } else {
        throw new TypeError("nColumns must be a positive integer");
      }
      this.rows = nRows;
      this.columns = nColumns;
    };
    var Matrix3 = _Matrix;
    installMathOperations(AbstractMatrix2, Matrix3);
    var _matrix;
    var _SymmetricMatrix = class _SymmetricMatrix extends AbstractMatrix2 {
      /**
       * @param {number | AbstractMatrix | ArrayLike<ArrayLike<number>>} diagonalSize
       * @return {this}
       */
      constructor(diagonalSize) {
        super();
        /** @type {Matrix} */
        __privateAdd(this, _matrix);
        if (Matrix3.isMatrix(diagonalSize)) {
          if (!diagonalSize.isSymmetric()) {
            throw new TypeError("not symmetric data");
          }
          __privateSet(this, _matrix, Matrix3.copy(
            diagonalSize,
            new Matrix3(diagonalSize.rows, diagonalSize.rows)
          ));
        } else if (Number.isInteger(diagonalSize) && diagonalSize >= 0) {
          __privateSet(this, _matrix, new Matrix3(diagonalSize, diagonalSize));
        } else {
          __privateSet(this, _matrix, new Matrix3(diagonalSize));
          if (!this.isSymmetric()) {
            throw new TypeError("not symmetric data");
          }
        }
      }
      get size() {
        return __privateGet(this, _matrix).size;
      }
      get rows() {
        return __privateGet(this, _matrix).rows;
      }
      get columns() {
        return __privateGet(this, _matrix).columns;
      }
      get diagonalSize() {
        return this.rows;
      }
      /**
       * not the same as matrix.isSymmetric()
       * Here is to check if it's instanceof SymmetricMatrix without bundling issues
       *
       * @param value
       * @returns {boolean}
       */
      static isSymmetricMatrix(value) {
        return Matrix3.isMatrix(value) && value.klassType === "SymmetricMatrix";
      }
      /**
       * @param diagonalSize
       * @return {SymmetricMatrix}
       */
      static zeros(diagonalSize) {
        return new this(diagonalSize);
      }
      /**
       * @param diagonalSize
       * @return {SymmetricMatrix}
       */
      static ones(diagonalSize) {
        return new this(diagonalSize).fill(1);
      }
      clone() {
        const matrix2 = new _SymmetricMatrix(this.diagonalSize);
        for (const [row, col, value] of this.upperRightEntries()) {
          matrix2.set(row, col, value);
        }
        return matrix2;
      }
      toMatrix() {
        return new Matrix3(this);
      }
      get(rowIndex, columnIndex) {
        return __privateGet(this, _matrix).get(rowIndex, columnIndex);
      }
      set(rowIndex, columnIndex, value) {
        __privateGet(this, _matrix).set(rowIndex, columnIndex, value);
        __privateGet(this, _matrix).set(columnIndex, rowIndex, value);
        return this;
      }
      removeCross(index) {
        __privateGet(this, _matrix).removeRow(index);
        __privateGet(this, _matrix).removeColumn(index);
        return this;
      }
      addCross(index, array) {
        if (array === void 0) {
          array = index;
          index = this.diagonalSize;
        }
        const row = array.slice();
        row.splice(index, 1);
        __privateGet(this, _matrix).addRow(index, row);
        __privateGet(this, _matrix).addColumn(index, array);
        return this;
      }
      /**
       * @param {Mask[]} mask
       */
      applyMask(mask) {
        if (mask.length !== this.diagonalSize) {
          throw new RangeError("Mask size do not match with matrix size");
        }
        const sidesToRemove = [];
        for (const [index, passthroughs] of mask.entries()) {
          if (passthroughs) continue;
          sidesToRemove.push(index);
        }
        sidesToRemove.reverse();
        for (const sideIndex of sidesToRemove) {
          this.removeCross(sideIndex);
        }
        return this;
      }
      /**
       * Compact format upper-right corner of matrix
       * iterate from left to right, from top to bottom.
       *
       * ```
       *   A B C D
       * A 1 2 3 4
       * B 2 5 6 7
       * C 3 6 8 9
       * D 4 7 9 10
       * ```
       *
       * will return compact 1D array `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`
       *
       * length is S(i=0, n=sideSize) => 10 for a 4 sideSized matrix
       *
       * @returns {number[]}
       */
      toCompact() {
        const { diagonalSize } = this;
        const compact = new Array(diagonalSize * (diagonalSize + 1) / 2);
        for (let col = 0, row = 0, index = 0; index < compact.length; index++) {
          compact[index] = this.get(row, col);
          if (++col >= diagonalSize) col = ++row;
        }
        return compact;
      }
      /**
       * @param {number[]} compact
       * @return {SymmetricMatrix}
       */
      static fromCompact(compact) {
        const compactSize = compact.length;
        const diagonalSize = (Math.sqrt(8 * compactSize + 1) - 1) / 2;
        if (!Number.isInteger(diagonalSize)) {
          throw new TypeError(
            `This array is not a compact representation of a Symmetric Matrix, ${JSON.stringify(
              compact
            )}`
          );
        }
        const matrix2 = new _SymmetricMatrix(diagonalSize);
        for (let col = 0, row = 0, index = 0; index < compactSize; index++) {
          matrix2.set(col, row, compact[index]);
          if (++col >= diagonalSize) col = ++row;
        }
        return matrix2;
      }
      /**
       * half iterator upper-right-corner from left to right, from top to bottom
       * yield [row, column, value]
       *
       * @returns {Generator<[number, number, number], void, void>}
       */
      *upperRightEntries() {
        for (let row = 0, col = 0; row < this.diagonalSize; void 0) {
          const value = this.get(row, col);
          yield [row, col, value];
          if (++col >= this.diagonalSize) col = ++row;
        }
      }
      /**
       * half iterator upper-right-corner from left to right, from top to bottom
       * yield value
       *
       * @returns {Generator<[number, number, number], void, void>}
       */
      *upperRightValues() {
        for (let row = 0, col = 0; row < this.diagonalSize; void 0) {
          const value = this.get(row, col);
          yield value;
          if (++col >= this.diagonalSize) col = ++row;
        }
      }
    };
    _matrix = new WeakMap();
    var SymmetricMatrix2 = _SymmetricMatrix;
    SymmetricMatrix2.prototype.klassType = "SymmetricMatrix";
    var DistanceMatrix2 = class _DistanceMatrix extends SymmetricMatrix2 {
      /**
       * not the same as matrix.isSymmetric()
       * Here is to check if it's instanceof SymmetricMatrix without bundling issues
       *
       * @param value
       * @returns {boolean}
       */
      static isDistanceMatrix(value) {
        return SymmetricMatrix2.isSymmetricMatrix(value) && value.klassSubType === "DistanceMatrix";
      }
      constructor(sideSize) {
        super(sideSize);
        if (!this.isDistance()) {
          throw new TypeError("Provided arguments do no produce a distance matrix");
        }
      }
      set(rowIndex, columnIndex, value) {
        if (rowIndex === columnIndex) value = 0;
        return super.set(rowIndex, columnIndex, value);
      }
      addCross(index, array) {
        if (array === void 0) {
          array = index;
          index = this.diagonalSize;
        }
        array = array.slice();
        array[index] = 0;
        return super.addCross(index, array);
      }
      toSymmetricMatrix() {
        return new SymmetricMatrix2(this);
      }
      clone() {
        const matrix2 = new _DistanceMatrix(this.diagonalSize);
        for (const [row, col, value] of this.upperRightEntries()) {
          if (row === col) continue;
          matrix2.set(row, col, value);
        }
        return matrix2;
      }
      /**
       * Compact format upper-right corner of matrix
       * no diagonal (only zeros)
       * iterable from left to right, from top to bottom.
       *
       * ```
       *   A B C D
       * A 0 1 2 3
       * B 1 0 4 5
       * C 2 4 0 6
       * D 3 5 6 0
       * ```
       *
       * will return compact 1D array `[1, 2, 3, 4, 5, 6]`
       *
       * length is S(i=0, n=sideSize-1) => 6 for a 4 side sized matrix
       *
       * @returns {number[]}
       */
      toCompact() {
        const { diagonalSize } = this;
        const compactLength = (diagonalSize - 1) * diagonalSize / 2;
        const compact = new Array(compactLength);
        for (let col = 1, row = 0, index = 0; index < compact.length; index++) {
          compact[index] = this.get(row, col);
          if (++col >= diagonalSize) col = ++row + 1;
        }
        return compact;
      }
      /**
       * @param {number[]} compact
       */
      static fromCompact(compact) {
        const compactSize = compact.length;
        if (compactSize === 0) {
          return new this(0);
        }
        const diagonalSize = (Math.sqrt(8 * compactSize + 1) + 1) / 2;
        if (!Number.isInteger(diagonalSize)) {
          throw new TypeError(
            `This array is not a compact representation of a DistanceMatrix, ${JSON.stringify(
              compact
            )}`
          );
        }
        const matrix2 = new this(diagonalSize);
        for (let col = 1, row = 0, index = 0; index < compactSize; index++) {
          matrix2.set(col, row, compact[index]);
          if (++col >= diagonalSize) col = ++row + 1;
        }
        return matrix2;
      }
    };
    DistanceMatrix2.prototype.klassSubType = "DistanceMatrix";
    var BaseView = class extends AbstractMatrix2 {
      constructor(matrix2, rows, columns) {
        super();
        this.matrix = matrix2;
        this.rows = rows;
        this.columns = columns;
      }
    };
    var MatrixColumnView2 = class extends BaseView {
      constructor(matrix2, column) {
        checkColumnIndex(matrix2, column);
        super(matrix2, matrix2.rows, 1);
        this.column = column;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.column, value);
        return this;
      }
      get(rowIndex) {
        return this.matrix.get(rowIndex, this.column);
      }
    };
    var MatrixColumnSelectionView2 = class extends BaseView {
      constructor(matrix2, columnIndices) {
        checkColumnIndices(matrix2, columnIndices);
        super(matrix2, matrix2.rows, columnIndices.length);
        this.columnIndices = columnIndices;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.columnIndices[columnIndex], value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(rowIndex, this.columnIndices[columnIndex]);
      }
    };
    var MatrixFlipColumnView2 = class extends BaseView {
      constructor(matrix2) {
        super(matrix2, matrix2.rows, matrix2.columns);
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(rowIndex, this.columns - columnIndex - 1);
      }
    };
    var MatrixFlipRowView2 = class extends BaseView {
      constructor(matrix2) {
        super(matrix2, matrix2.rows, matrix2.columns);
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(this.rows - rowIndex - 1, columnIndex);
      }
    };
    var MatrixRowView2 = class extends BaseView {
      constructor(matrix2, row) {
        checkRowIndex(matrix2, row);
        super(matrix2, 1, matrix2.columns);
        this.row = row;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.row, columnIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(this.row, columnIndex);
      }
    };
    var MatrixRowSelectionView2 = class extends BaseView {
      constructor(matrix2, rowIndices) {
        checkRowIndices(matrix2, rowIndices);
        super(matrix2, rowIndices.length, matrix2.columns);
        this.rowIndices = rowIndices;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.rowIndices[rowIndex], columnIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(this.rowIndices[rowIndex], columnIndex);
      }
    };
    var MatrixSelectionView2 = class extends BaseView {
      constructor(matrix2, rowIndices, columnIndices) {
        checkRowIndices(matrix2, rowIndices);
        checkColumnIndices(matrix2, columnIndices);
        super(matrix2, rowIndices.length, columnIndices.length);
        this.rowIndices = rowIndices;
        this.columnIndices = columnIndices;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(
          this.rowIndices[rowIndex],
          this.columnIndices[columnIndex],
          value
        );
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(
          this.rowIndices[rowIndex],
          this.columnIndices[columnIndex]
        );
      }
    };
    var MatrixSubView2 = class extends BaseView {
      constructor(matrix2, startRow, endRow, startColumn, endColumn) {
        checkRange(matrix2, startRow, endRow, startColumn, endColumn);
        super(matrix2, endRow - startRow + 1, endColumn - startColumn + 1);
        this.startRow = startRow;
        this.startColumn = startColumn;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(
          this.startRow + rowIndex,
          this.startColumn + columnIndex,
          value
        );
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(
          this.startRow + rowIndex,
          this.startColumn + columnIndex
        );
      }
    };
    var MatrixTransposeView2 = class extends BaseView {
      constructor(matrix2) {
        super(matrix2, matrix2.columns, matrix2.rows);
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(columnIndex, rowIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(columnIndex, rowIndex);
      }
    };
    var WrapperMatrix1D2 = class extends AbstractMatrix2 {
      constructor(data, options = {}) {
        const { rows = 1 } = options;
        if (data.length % rows !== 0) {
          throw new Error("the data length is not divisible by the number of rows");
        }
        super();
        this.rows = rows;
        this.columns = data.length / rows;
        this.data = data;
      }
      set(rowIndex, columnIndex, value) {
        let index = this._calculateIndex(rowIndex, columnIndex);
        this.data[index] = value;
        return this;
      }
      get(rowIndex, columnIndex) {
        let index = this._calculateIndex(rowIndex, columnIndex);
        return this.data[index];
      }
      _calculateIndex(row, column) {
        return row * this.columns + column;
      }
    };
    var WrapperMatrix2D2 = class extends AbstractMatrix2 {
      constructor(data) {
        super();
        this.data = data;
        this.rows = data.length;
        this.columns = data[0].length;
      }
      set(rowIndex, columnIndex, value) {
        this.data[rowIndex][columnIndex] = value;
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.data[rowIndex][columnIndex];
      }
    };
    function wrap3(array, options) {
      if (isAnyArray2.isAnyArray(array)) {
        if (array[0] && isAnyArray2.isAnyArray(array[0])) {
          return new WrapperMatrix2D2(array);
        } else {
          return new WrapperMatrix1D2(array, options);
        }
      } else {
        throw new Error("the argument is not an array");
      }
    }
    var LuDecomposition2 = class {
      constructor(matrix2) {
        matrix2 = WrapperMatrix2D2.checkMatrix(matrix2);
        let lu = matrix2.clone();
        let rows = lu.rows;
        let columns = lu.columns;
        let pivotVector = new Float64Array(rows);
        let pivotSign = 1;
        let i2, j2, k2, p3, s2, t3, v3;
        let LUcolj, kmax;
        for (i2 = 0; i2 < rows; i2++) {
          pivotVector[i2] = i2;
        }
        LUcolj = new Float64Array(rows);
        for (j2 = 0; j2 < columns; j2++) {
          for (i2 = 0; i2 < rows; i2++) {
            LUcolj[i2] = lu.get(i2, j2);
          }
          for (i2 = 0; i2 < rows; i2++) {
            kmax = Math.min(i2, j2);
            s2 = 0;
            for (k2 = 0; k2 < kmax; k2++) {
              s2 += lu.get(i2, k2) * LUcolj[k2];
            }
            LUcolj[i2] -= s2;
            lu.set(i2, j2, LUcolj[i2]);
          }
          p3 = j2;
          for (i2 = j2 + 1; i2 < rows; i2++) {
            if (Math.abs(LUcolj[i2]) > Math.abs(LUcolj[p3])) {
              p3 = i2;
            }
          }
          if (p3 !== j2) {
            for (k2 = 0; k2 < columns; k2++) {
              t3 = lu.get(p3, k2);
              lu.set(p3, k2, lu.get(j2, k2));
              lu.set(j2, k2, t3);
            }
            v3 = pivotVector[p3];
            pivotVector[p3] = pivotVector[j2];
            pivotVector[j2] = v3;
            pivotSign = -pivotSign;
          }
          if (j2 < rows && lu.get(j2, j2) !== 0) {
            for (i2 = j2 + 1; i2 < rows; i2++) {
              lu.set(i2, j2, lu.get(i2, j2) / lu.get(j2, j2));
            }
          }
        }
        this.LU = lu;
        this.pivotVector = pivotVector;
        this.pivotSign = pivotSign;
      }
      isSingular() {
        let data = this.LU;
        let col = data.columns;
        for (let j2 = 0; j2 < col; j2++) {
          if (data.get(j2, j2) === 0) {
            return true;
          }
        }
        return false;
      }
      solve(value) {
        value = Matrix3.checkMatrix(value);
        let lu = this.LU;
        let rows = lu.rows;
        if (rows !== value.rows) {
          throw new Error("Invalid matrix dimensions");
        }
        if (this.isSingular()) {
          throw new Error("LU matrix is singular");
        }
        let count = value.columns;
        let X2 = value.subMatrixRow(this.pivotVector, 0, count - 1);
        let columns = lu.columns;
        let i2, j2, k2;
        for (k2 = 0; k2 < columns; k2++) {
          for (i2 = k2 + 1; i2 < columns; i2++) {
            for (j2 = 0; j2 < count; j2++) {
              X2.set(i2, j2, X2.get(i2, j2) - X2.get(k2, j2) * lu.get(i2, k2));
            }
          }
        }
        for (k2 = columns - 1; k2 >= 0; k2--) {
          for (j2 = 0; j2 < count; j2++) {
            X2.set(k2, j2, X2.get(k2, j2) / lu.get(k2, k2));
          }
          for (i2 = 0; i2 < k2; i2++) {
            for (j2 = 0; j2 < count; j2++) {
              X2.set(i2, j2, X2.get(i2, j2) - X2.get(k2, j2) * lu.get(i2, k2));
            }
          }
        }
        return X2;
      }
      get determinant() {
        let data = this.LU;
        if (!data.isSquare()) {
          throw new Error("Matrix must be square");
        }
        let determinant3 = this.pivotSign;
        let col = data.columns;
        for (let j2 = 0; j2 < col; j2++) {
          determinant3 *= data.get(j2, j2);
        }
        return determinant3;
      }
      get lowerTriangularMatrix() {
        let data = this.LU;
        let rows = data.rows;
        let columns = data.columns;
        let X2 = new Matrix3(rows, columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            if (i2 > j2) {
              X2.set(i2, j2, data.get(i2, j2));
            } else if (i2 === j2) {
              X2.set(i2, j2, 1);
            } else {
              X2.set(i2, j2, 0);
            }
          }
        }
        return X2;
      }
      get upperTriangularMatrix() {
        let data = this.LU;
        let rows = data.rows;
        let columns = data.columns;
        let X2 = new Matrix3(rows, columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            if (i2 <= j2) {
              X2.set(i2, j2, data.get(i2, j2));
            } else {
              X2.set(i2, j2, 0);
            }
          }
        }
        return X2;
      }
      get pivotPermutationVector() {
        return Array.from(this.pivotVector);
      }
    };
    function hypotenuse(a3, b3) {
      let r3 = 0;
      if (Math.abs(a3) > Math.abs(b3)) {
        r3 = b3 / a3;
        return Math.abs(a3) * Math.sqrt(1 + r3 * r3);
      }
      if (b3 !== 0) {
        r3 = a3 / b3;
        return Math.abs(b3) * Math.sqrt(1 + r3 * r3);
      }
      return 0;
    }
    var QrDecomposition2 = class {
      constructor(value) {
        value = WrapperMatrix2D2.checkMatrix(value);
        let qr = value.clone();
        let m2 = value.rows;
        let n2 = value.columns;
        let rdiag = new Float64Array(n2);
        let i2, j2, k2, s2;
        for (k2 = 0; k2 < n2; k2++) {
          let nrm = 0;
          for (i2 = k2; i2 < m2; i2++) {
            nrm = hypotenuse(nrm, qr.get(i2, k2));
          }
          if (nrm !== 0) {
            if (qr.get(k2, k2) < 0) {
              nrm = -nrm;
            }
            for (i2 = k2; i2 < m2; i2++) {
              qr.set(i2, k2, qr.get(i2, k2) / nrm);
            }
            qr.set(k2, k2, qr.get(k2, k2) + 1);
            for (j2 = k2 + 1; j2 < n2; j2++) {
              s2 = 0;
              for (i2 = k2; i2 < m2; i2++) {
                s2 += qr.get(i2, k2) * qr.get(i2, j2);
              }
              s2 = -s2 / qr.get(k2, k2);
              for (i2 = k2; i2 < m2; i2++) {
                qr.set(i2, j2, qr.get(i2, j2) + s2 * qr.get(i2, k2));
              }
            }
          }
          rdiag[k2] = -nrm;
        }
        this.QR = qr;
        this.Rdiag = rdiag;
      }
      solve(value) {
        value = Matrix3.checkMatrix(value);
        let qr = this.QR;
        let m2 = qr.rows;
        if (value.rows !== m2) {
          throw new Error("Matrix row dimensions must agree");
        }
        if (!this.isFullRank()) {
          throw new Error("Matrix is rank deficient");
        }
        let count = value.columns;
        let X2 = value.clone();
        let n2 = qr.columns;
        let i2, j2, k2, s2;
        for (k2 = 0; k2 < n2; k2++) {
          for (j2 = 0; j2 < count; j2++) {
            s2 = 0;
            for (i2 = k2; i2 < m2; i2++) {
              s2 += qr.get(i2, k2) * X2.get(i2, j2);
            }
            s2 = -s2 / qr.get(k2, k2);
            for (i2 = k2; i2 < m2; i2++) {
              X2.set(i2, j2, X2.get(i2, j2) + s2 * qr.get(i2, k2));
            }
          }
        }
        for (k2 = n2 - 1; k2 >= 0; k2--) {
          for (j2 = 0; j2 < count; j2++) {
            X2.set(k2, j2, X2.get(k2, j2) / this.Rdiag[k2]);
          }
          for (i2 = 0; i2 < k2; i2++) {
            for (j2 = 0; j2 < count; j2++) {
              X2.set(i2, j2, X2.get(i2, j2) - X2.get(k2, j2) * qr.get(i2, k2));
            }
          }
        }
        return X2.subMatrix(0, n2 - 1, 0, count - 1);
      }
      isFullRank() {
        let columns = this.QR.columns;
        for (let i2 = 0; i2 < columns; i2++) {
          if (this.Rdiag[i2] === 0) {
            return false;
          }
        }
        return true;
      }
      get upperTriangularMatrix() {
        let qr = this.QR;
        let n2 = qr.columns;
        let X2 = new Matrix3(n2, n2);
        let i2, j2;
        for (i2 = 0; i2 < n2; i2++) {
          for (j2 = 0; j2 < n2; j2++) {
            if (i2 < j2) {
              X2.set(i2, j2, qr.get(i2, j2));
            } else if (i2 === j2) {
              X2.set(i2, j2, this.Rdiag[i2]);
            } else {
              X2.set(i2, j2, 0);
            }
          }
        }
        return X2;
      }
      get orthogonalMatrix() {
        let qr = this.QR;
        let rows = qr.rows;
        let columns = qr.columns;
        let X2 = new Matrix3(rows, columns);
        let i2, j2, k2, s2;
        for (k2 = columns - 1; k2 >= 0; k2--) {
          for (i2 = 0; i2 < rows; i2++) {
            X2.set(i2, k2, 0);
          }
          X2.set(k2, k2, 1);
          for (j2 = k2; j2 < columns; j2++) {
            if (qr.get(k2, k2) !== 0) {
              s2 = 0;
              for (i2 = k2; i2 < rows; i2++) {
                s2 += qr.get(i2, k2) * X2.get(i2, j2);
              }
              s2 = -s2 / qr.get(k2, k2);
              for (i2 = k2; i2 < rows; i2++) {
                X2.set(i2, j2, X2.get(i2, j2) + s2 * qr.get(i2, k2));
              }
            }
          }
        }
        return X2;
      }
    };
    var SingularValueDecomposition3 = class {
      constructor(value, options = {}) {
        value = WrapperMatrix2D2.checkMatrix(value);
        if (value.isEmpty()) {
          throw new Error("Matrix must be non-empty");
        }
        let m2 = value.rows;
        let n2 = value.columns;
        const {
          computeLeftSingularVectors = true,
          computeRightSingularVectors = true,
          autoTranspose = false
        } = options;
        let wantu = Boolean(computeLeftSingularVectors);
        let wantv = Boolean(computeRightSingularVectors);
        let swapped = false;
        let a3;
        if (m2 < n2) {
          if (!autoTranspose) {
            a3 = value.clone();
            console.warn(
              "Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose"
            );
          } else {
            a3 = value.transpose();
            m2 = a3.rows;
            n2 = a3.columns;
            swapped = true;
            let aux = wantu;
            wantu = wantv;
            wantv = aux;
          }
        } else {
          a3 = value.clone();
        }
        let nu = Math.min(m2, n2);
        let ni = Math.min(m2 + 1, n2);
        let s2 = new Float64Array(ni);
        let U2 = new Matrix3(m2, nu);
        let V3 = new Matrix3(n2, n2);
        let e2 = new Float64Array(n2);
        let work = new Float64Array(m2);
        let si = new Float64Array(ni);
        for (let i2 = 0; i2 < ni; i2++) si[i2] = i2;
        let nct = Math.min(m2 - 1, n2);
        let nrt = Math.max(0, Math.min(n2 - 2, m2));
        let mrc = Math.max(nct, nrt);
        for (let k2 = 0; k2 < mrc; k2++) {
          if (k2 < nct) {
            s2[k2] = 0;
            for (let i2 = k2; i2 < m2; i2++) {
              s2[k2] = hypotenuse(s2[k2], a3.get(i2, k2));
            }
            if (s2[k2] !== 0) {
              if (a3.get(k2, k2) < 0) {
                s2[k2] = -s2[k2];
              }
              for (let i2 = k2; i2 < m2; i2++) {
                a3.set(i2, k2, a3.get(i2, k2) / s2[k2]);
              }
              a3.set(k2, k2, a3.get(k2, k2) + 1);
            }
            s2[k2] = -s2[k2];
          }
          for (let j2 = k2 + 1; j2 < n2; j2++) {
            if (k2 < nct && s2[k2] !== 0) {
              let t3 = 0;
              for (let i2 = k2; i2 < m2; i2++) {
                t3 += a3.get(i2, k2) * a3.get(i2, j2);
              }
              t3 = -t3 / a3.get(k2, k2);
              for (let i2 = k2; i2 < m2; i2++) {
                a3.set(i2, j2, a3.get(i2, j2) + t3 * a3.get(i2, k2));
              }
            }
            e2[j2] = a3.get(k2, j2);
          }
          if (wantu && k2 < nct) {
            for (let i2 = k2; i2 < m2; i2++) {
              U2.set(i2, k2, a3.get(i2, k2));
            }
          }
          if (k2 < nrt) {
            e2[k2] = 0;
            for (let i2 = k2 + 1; i2 < n2; i2++) {
              e2[k2] = hypotenuse(e2[k2], e2[i2]);
            }
            if (e2[k2] !== 0) {
              if (e2[k2 + 1] < 0) {
                e2[k2] = 0 - e2[k2];
              }
              for (let i2 = k2 + 1; i2 < n2; i2++) {
                e2[i2] /= e2[k2];
              }
              e2[k2 + 1] += 1;
            }
            e2[k2] = -e2[k2];
            if (k2 + 1 < m2 && e2[k2] !== 0) {
              for (let i2 = k2 + 1; i2 < m2; i2++) {
                work[i2] = 0;
              }
              for (let i2 = k2 + 1; i2 < m2; i2++) {
                for (let j2 = k2 + 1; j2 < n2; j2++) {
                  work[i2] += e2[j2] * a3.get(i2, j2);
                }
              }
              for (let j2 = k2 + 1; j2 < n2; j2++) {
                let t3 = -e2[j2] / e2[k2 + 1];
                for (let i2 = k2 + 1; i2 < m2; i2++) {
                  a3.set(i2, j2, a3.get(i2, j2) + t3 * work[i2]);
                }
              }
            }
            if (wantv) {
              for (let i2 = k2 + 1; i2 < n2; i2++) {
                V3.set(i2, k2, e2[i2]);
              }
            }
          }
        }
        let p3 = Math.min(n2, m2 + 1);
        if (nct < n2) {
          s2[nct] = a3.get(nct, nct);
        }
        if (m2 < p3) {
          s2[p3 - 1] = 0;
        }
        if (nrt + 1 < p3) {
          e2[nrt] = a3.get(nrt, p3 - 1);
        }
        e2[p3 - 1] = 0;
        if (wantu) {
          for (let j2 = nct; j2 < nu; j2++) {
            for (let i2 = 0; i2 < m2; i2++) {
              U2.set(i2, j2, 0);
            }
            U2.set(j2, j2, 1);
          }
          for (let k2 = nct - 1; k2 >= 0; k2--) {
            if (s2[k2] !== 0) {
              for (let j2 = k2 + 1; j2 < nu; j2++) {
                let t3 = 0;
                for (let i2 = k2; i2 < m2; i2++) {
                  t3 += U2.get(i2, k2) * U2.get(i2, j2);
                }
                t3 = -t3 / U2.get(k2, k2);
                for (let i2 = k2; i2 < m2; i2++) {
                  U2.set(i2, j2, U2.get(i2, j2) + t3 * U2.get(i2, k2));
                }
              }
              for (let i2 = k2; i2 < m2; i2++) {
                U2.set(i2, k2, -U2.get(i2, k2));
              }
              U2.set(k2, k2, 1 + U2.get(k2, k2));
              for (let i2 = 0; i2 < k2 - 1; i2++) {
                U2.set(i2, k2, 0);
              }
            } else {
              for (let i2 = 0; i2 < m2; i2++) {
                U2.set(i2, k2, 0);
              }
              U2.set(k2, k2, 1);
            }
          }
        }
        if (wantv) {
          for (let k2 = n2 - 1; k2 >= 0; k2--) {
            if (k2 < nrt && e2[k2] !== 0) {
              for (let j2 = k2 + 1; j2 < n2; j2++) {
                let t3 = 0;
                for (let i2 = k2 + 1; i2 < n2; i2++) {
                  t3 += V3.get(i2, k2) * V3.get(i2, j2);
                }
                t3 = -t3 / V3.get(k2 + 1, k2);
                for (let i2 = k2 + 1; i2 < n2; i2++) {
                  V3.set(i2, j2, V3.get(i2, j2) + t3 * V3.get(i2, k2));
                }
              }
            }
            for (let i2 = 0; i2 < n2; i2++) {
              V3.set(i2, k2, 0);
            }
            V3.set(k2, k2, 1);
          }
        }
        let pp = p3 - 1;
        let eps = Number.EPSILON;
        while (p3 > 0) {
          let k2, kase;
          for (k2 = p3 - 2; k2 >= -1; k2--) {
            if (k2 === -1) {
              break;
            }
            const alpha = Number.MIN_VALUE + eps * Math.abs(s2[k2] + Math.abs(s2[k2 + 1]));
            if (Math.abs(e2[k2]) <= alpha || Number.isNaN(e2[k2])) {
              e2[k2] = 0;
              break;
            }
          }
          if (k2 === p3 - 2) {
            kase = 4;
          } else {
            let ks;
            for (ks = p3 - 1; ks >= k2; ks--) {
              if (ks === k2) {
                break;
              }
              let t3 = (ks !== p3 ? Math.abs(e2[ks]) : 0) + (ks !== k2 + 1 ? Math.abs(e2[ks - 1]) : 0);
              if (Math.abs(s2[ks]) <= eps * t3) {
                s2[ks] = 0;
                break;
              }
            }
            if (ks === k2) {
              kase = 3;
            } else if (ks === p3 - 1) {
              kase = 1;
            } else {
              kase = 2;
              k2 = ks;
            }
          }
          k2++;
          switch (kase) {
            case 1: {
              let f3 = e2[p3 - 2];
              e2[p3 - 2] = 0;
              for (let j2 = p3 - 2; j2 >= k2; j2--) {
                let t3 = hypotenuse(s2[j2], f3);
                let cs = s2[j2] / t3;
                let sn = f3 / t3;
                s2[j2] = t3;
                if (j2 !== k2) {
                  f3 = -sn * e2[j2 - 1];
                  e2[j2 - 1] = cs * e2[j2 - 1];
                }
                if (wantv) {
                  for (let i2 = 0; i2 < n2; i2++) {
                    t3 = cs * V3.get(i2, j2) + sn * V3.get(i2, p3 - 1);
                    V3.set(i2, p3 - 1, -sn * V3.get(i2, j2) + cs * V3.get(i2, p3 - 1));
                    V3.set(i2, j2, t3);
                  }
                }
              }
              break;
            }
            case 2: {
              let f3 = e2[k2 - 1];
              e2[k2 - 1] = 0;
              for (let j2 = k2; j2 < p3; j2++) {
                let t3 = hypotenuse(s2[j2], f3);
                let cs = s2[j2] / t3;
                let sn = f3 / t3;
                s2[j2] = t3;
                f3 = -sn * e2[j2];
                e2[j2] = cs * e2[j2];
                if (wantu) {
                  for (let i2 = 0; i2 < m2; i2++) {
                    t3 = cs * U2.get(i2, j2) + sn * U2.get(i2, k2 - 1);
                    U2.set(i2, k2 - 1, -sn * U2.get(i2, j2) + cs * U2.get(i2, k2 - 1));
                    U2.set(i2, j2, t3);
                  }
                }
              }
              break;
            }
            case 3: {
              const scale2 = Math.max(
                Math.abs(s2[p3 - 1]),
                Math.abs(s2[p3 - 2]),
                Math.abs(e2[p3 - 2]),
                Math.abs(s2[k2]),
                Math.abs(e2[k2])
              );
              const sp = s2[p3 - 1] / scale2;
              const spm1 = s2[p3 - 2] / scale2;
              const epm1 = e2[p3 - 2] / scale2;
              const sk = s2[k2] / scale2;
              const ek = e2[k2] / scale2;
              const b3 = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
              const c3 = sp * epm1 * (sp * epm1);
              let shift = 0;
              if (b3 !== 0 || c3 !== 0) {
                if (b3 < 0) {
                  shift = 0 - Math.sqrt(b3 * b3 + c3);
                } else {
                  shift = Math.sqrt(b3 * b3 + c3);
                }
                shift = c3 / (b3 + shift);
              }
              let f3 = (sk + sp) * (sk - sp) + shift;
              let g3 = sk * ek;
              for (let j2 = k2; j2 < p3 - 1; j2++) {
                let t3 = hypotenuse(f3, g3);
                if (t3 === 0) t3 = Number.MIN_VALUE;
                let cs = f3 / t3;
                let sn = g3 / t3;
                if (j2 !== k2) {
                  e2[j2 - 1] = t3;
                }
                f3 = cs * s2[j2] + sn * e2[j2];
                e2[j2] = cs * e2[j2] - sn * s2[j2];
                g3 = sn * s2[j2 + 1];
                s2[j2 + 1] = cs * s2[j2 + 1];
                if (wantv) {
                  for (let i2 = 0; i2 < n2; i2++) {
                    t3 = cs * V3.get(i2, j2) + sn * V3.get(i2, j2 + 1);
                    V3.set(i2, j2 + 1, -sn * V3.get(i2, j2) + cs * V3.get(i2, j2 + 1));
                    V3.set(i2, j2, t3);
                  }
                }
                t3 = hypotenuse(f3, g3);
                if (t3 === 0) t3 = Number.MIN_VALUE;
                cs = f3 / t3;
                sn = g3 / t3;
                s2[j2] = t3;
                f3 = cs * e2[j2] + sn * s2[j2 + 1];
                s2[j2 + 1] = -sn * e2[j2] + cs * s2[j2 + 1];
                g3 = sn * e2[j2 + 1];
                e2[j2 + 1] = cs * e2[j2 + 1];
                if (wantu && j2 < m2 - 1) {
                  for (let i2 = 0; i2 < m2; i2++) {
                    t3 = cs * U2.get(i2, j2) + sn * U2.get(i2, j2 + 1);
                    U2.set(i2, j2 + 1, -sn * U2.get(i2, j2) + cs * U2.get(i2, j2 + 1));
                    U2.set(i2, j2, t3);
                  }
                }
              }
              e2[p3 - 2] = f3;
              break;
            }
            case 4: {
              if (s2[k2] <= 0) {
                s2[k2] = s2[k2] < 0 ? -s2[k2] : 0;
                if (wantv) {
                  for (let i2 = 0; i2 <= pp; i2++) {
                    V3.set(i2, k2, -V3.get(i2, k2));
                  }
                }
              }
              while (k2 < pp) {
                if (s2[k2] >= s2[k2 + 1]) {
                  break;
                }
                let t3 = s2[k2];
                s2[k2] = s2[k2 + 1];
                s2[k2 + 1] = t3;
                if (wantv && k2 < n2 - 1) {
                  for (let i2 = 0; i2 < n2; i2++) {
                    t3 = V3.get(i2, k2 + 1);
                    V3.set(i2, k2 + 1, V3.get(i2, k2));
                    V3.set(i2, k2, t3);
                  }
                }
                if (wantu && k2 < m2 - 1) {
                  for (let i2 = 0; i2 < m2; i2++) {
                    t3 = U2.get(i2, k2 + 1);
                    U2.set(i2, k2 + 1, U2.get(i2, k2));
                    U2.set(i2, k2, t3);
                  }
                }
                k2++;
              }
              p3--;
              break;
            }
          }
        }
        if (swapped) {
          let tmp = V3;
          V3 = U2;
          U2 = tmp;
        }
        this.m = m2;
        this.n = n2;
        this.s = s2;
        this.U = U2;
        this.V = V3;
      }
      solve(value) {
        let Y3 = value;
        let e2 = this.threshold;
        let scols = this.s.length;
        let Ls = Matrix3.zeros(scols, scols);
        for (let i2 = 0; i2 < scols; i2++) {
          if (Math.abs(this.s[i2]) <= e2) {
            Ls.set(i2, i2, 0);
          } else {
            Ls.set(i2, i2, 1 / this.s[i2]);
          }
        }
        let U2 = this.U;
        let V3 = this.rightSingularVectors;
        let VL = V3.mmul(Ls);
        let vrows = V3.rows;
        let urows = U2.rows;
        let VLU = Matrix3.zeros(vrows, urows);
        for (let i2 = 0; i2 < vrows; i2++) {
          for (let j2 = 0; j2 < urows; j2++) {
            let sum = 0;
            for (let k2 = 0; k2 < scols; k2++) {
              sum += VL.get(i2, k2) * U2.get(j2, k2);
            }
            VLU.set(i2, j2, sum);
          }
        }
        return VLU.mmul(Y3);
      }
      solveForDiagonal(value) {
        return this.solve(Matrix3.diag(value));
      }
      inverse() {
        let V3 = this.V;
        let e2 = this.threshold;
        let vrows = V3.rows;
        let vcols = V3.columns;
        let X2 = new Matrix3(vrows, this.s.length);
        for (let i2 = 0; i2 < vrows; i2++) {
          for (let j2 = 0; j2 < vcols; j2++) {
            if (Math.abs(this.s[j2]) > e2) {
              X2.set(i2, j2, V3.get(i2, j2) / this.s[j2]);
            }
          }
        }
        let U2 = this.U;
        let urows = U2.rows;
        let ucols = U2.columns;
        let Y3 = new Matrix3(vrows, urows);
        for (let i2 = 0; i2 < vrows; i2++) {
          for (let j2 = 0; j2 < urows; j2++) {
            let sum = 0;
            for (let k2 = 0; k2 < ucols; k2++) {
              sum += X2.get(i2, k2) * U2.get(j2, k2);
            }
            Y3.set(i2, j2, sum);
          }
        }
        return Y3;
      }
      get condition() {
        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
      }
      get norm2() {
        return this.s[0];
      }
      get rank() {
        let tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;
        let r3 = 0;
        let s2 = this.s;
        for (let i2 = 0, ii = s2.length; i2 < ii; i2++) {
          if (s2[i2] > tol) {
            r3++;
          }
        }
        return r3;
      }
      get diagonal() {
        return Array.from(this.s);
      }
      get threshold() {
        return Number.EPSILON / 2 * Math.max(this.m, this.n) * this.s[0];
      }
      get leftSingularVectors() {
        return this.U;
      }
      get rightSingularVectors() {
        return this.V;
      }
      get diagonalMatrix() {
        return Matrix3.diag(this.s);
      }
    };
    function inverse2(matrix2, useSVD = false) {
      matrix2 = WrapperMatrix2D2.checkMatrix(matrix2);
      if (useSVD) {
        return new SingularValueDecomposition3(matrix2).inverse();
      } else {
        return solve2(matrix2, Matrix3.eye(matrix2.rows));
      }
    }
    function solve2(leftHandSide, rightHandSide, useSVD = false) {
      leftHandSide = WrapperMatrix2D2.checkMatrix(leftHandSide);
      rightHandSide = WrapperMatrix2D2.checkMatrix(rightHandSide);
      if (useSVD) {
        return new SingularValueDecomposition3(leftHandSide).solve(rightHandSide);
      } else {
        return leftHandSide.isSquare() ? new LuDecomposition2(leftHandSide).solve(rightHandSide) : new QrDecomposition2(leftHandSide).solve(rightHandSide);
      }
    }
    function determinant2(matrix2) {
      matrix2 = Matrix3.checkMatrix(matrix2);
      if (matrix2.isSquare()) {
        if (matrix2.columns === 0) {
          return 1;
        }
        let a3, b3, c3, d3;
        if (matrix2.columns === 2) {
          a3 = matrix2.get(0, 0);
          b3 = matrix2.get(0, 1);
          c3 = matrix2.get(1, 0);
          d3 = matrix2.get(1, 1);
          return a3 * d3 - b3 * c3;
        } else if (matrix2.columns === 3) {
          let subMatrix0, subMatrix1, subMatrix2;
          subMatrix0 = new MatrixSelectionView2(matrix2, [1, 2], [1, 2]);
          subMatrix1 = new MatrixSelectionView2(matrix2, [1, 2], [0, 2]);
          subMatrix2 = new MatrixSelectionView2(matrix2, [1, 2], [0, 1]);
          a3 = matrix2.get(0, 0);
          b3 = matrix2.get(0, 1);
          c3 = matrix2.get(0, 2);
          return a3 * determinant2(subMatrix0) - b3 * determinant2(subMatrix1) + c3 * determinant2(subMatrix2);
        } else {
          return new LuDecomposition2(matrix2).determinant;
        }
      } else {
        throw Error("determinant can only be calculated for a square matrix");
      }
    }
    function xrange(n2, exception) {
      let range = [];
      for (let i2 = 0; i2 < n2; i2++) {
        if (i2 !== exception) {
          range.push(i2);
        }
      }
      return range;
    }
    function dependenciesOneRow(error, matrix2, index, thresholdValue = 1e-9, thresholdError = 1e-9) {
      if (error > thresholdError) {
        return new Array(matrix2.rows + 1).fill(0);
      } else {
        let returnArray = matrix2.addRow(index, [0]);
        for (let i2 = 0; i2 < returnArray.rows; i2++) {
          if (Math.abs(returnArray.get(i2, 0)) < thresholdValue) {
            returnArray.set(i2, 0, 0);
          }
        }
        return returnArray.to1DArray();
      }
    }
    function linearDependencies2(matrix2, options = {}) {
      const { thresholdValue = 1e-9, thresholdError = 1e-9 } = options;
      matrix2 = Matrix3.checkMatrix(matrix2);
      let n2 = matrix2.rows;
      let results = new Matrix3(n2, n2);
      for (let i2 = 0; i2 < n2; i2++) {
        let b3 = Matrix3.columnVector(matrix2.getRow(i2));
        let Abis = matrix2.subMatrixRow(xrange(n2, i2)).transpose();
        let svd = new SingularValueDecomposition3(Abis);
        let x4 = svd.solve(b3);
        let error = Matrix3.sub(b3, Abis.mmul(x4)).abs().max();
        results.setRow(
          i2,
          dependenciesOneRow(error, x4, i2, thresholdValue, thresholdError)
        );
      }
      return results;
    }
    function pseudoInverse2(matrix2, threshold = Number.EPSILON) {
      matrix2 = Matrix3.checkMatrix(matrix2);
      if (matrix2.isEmpty()) {
        return matrix2.transpose();
      }
      let svdSolution = new SingularValueDecomposition3(matrix2, { autoTranspose: true });
      let U2 = svdSolution.leftSingularVectors;
      let V3 = svdSolution.rightSingularVectors;
      let s2 = svdSolution.diagonal;
      for (let i2 = 0; i2 < s2.length; i2++) {
        if (Math.abs(s2[i2]) > threshold) {
          s2[i2] = 1 / s2[i2];
        } else {
          s2[i2] = 0;
        }
      }
      return V3.mmul(Matrix3.diag(s2).mmul(U2.transpose()));
    }
    function covariance2(xMatrix, yMatrix = xMatrix, options = {}) {
      xMatrix = new Matrix3(xMatrix);
      let yIsSame = false;
      if (typeof yMatrix === "object" && !Matrix3.isMatrix(yMatrix) && !isAnyArray2.isAnyArray(yMatrix)) {
        options = yMatrix;
        yMatrix = xMatrix;
        yIsSame = true;
      } else {
        yMatrix = new Matrix3(yMatrix);
      }
      if (xMatrix.rows !== yMatrix.rows) {
        throw new TypeError("Both matrices must have the same number of rows");
      }
      const { center = true } = options;
      if (center) {
        xMatrix = xMatrix.center("column");
        if (!yIsSame) {
          yMatrix = yMatrix.center("column");
        }
      }
      const cov = xMatrix.transpose().mmul(yMatrix);
      for (let i2 = 0; i2 < cov.rows; i2++) {
        for (let j2 = 0; j2 < cov.columns; j2++) {
          cov.set(i2, j2, cov.get(i2, j2) * (1 / (xMatrix.rows - 1)));
        }
      }
      return cov;
    }
    function correlation2(xMatrix, yMatrix = xMatrix, options = {}) {
      xMatrix = new Matrix3(xMatrix);
      let yIsSame = false;
      if (typeof yMatrix === "object" && !Matrix3.isMatrix(yMatrix) && !isAnyArray2.isAnyArray(yMatrix)) {
        options = yMatrix;
        yMatrix = xMatrix;
        yIsSame = true;
      } else {
        yMatrix = new Matrix3(yMatrix);
      }
      if (xMatrix.rows !== yMatrix.rows) {
        throw new TypeError("Both matrices must have the same number of rows");
      }
      const { center = true, scale: scale2 = true } = options;
      if (center) {
        xMatrix.center("column");
        if (!yIsSame) {
          yMatrix.center("column");
        }
      }
      if (scale2) {
        xMatrix.scale("column");
        if (!yIsSame) {
          yMatrix.scale("column");
        }
      }
      const sdx = xMatrix.standardDeviation("column", { unbiased: true });
      const sdy = yIsSame ? sdx : yMatrix.standardDeviation("column", { unbiased: true });
      const corr = xMatrix.transpose().mmul(yMatrix);
      for (let i2 = 0; i2 < corr.rows; i2++) {
        for (let j2 = 0; j2 < corr.columns; j2++) {
          corr.set(
            i2,
            j2,
            corr.get(i2, j2) * (1 / (sdx[i2] * sdy[j2])) * (1 / (xMatrix.rows - 1))
          );
        }
      }
      return corr;
    }
    var EigenvalueDecomposition2 = class {
      constructor(matrix2, options = {}) {
        const { assumeSymmetric = false } = options;
        matrix2 = WrapperMatrix2D2.checkMatrix(matrix2);
        if (!matrix2.isSquare()) {
          throw new Error("Matrix is not a square matrix");
        }
        if (matrix2.isEmpty()) {
          throw new Error("Matrix must be non-empty");
        }
        let n2 = matrix2.columns;
        let V3 = new Matrix3(n2, n2);
        let d3 = new Float64Array(n2);
        let e2 = new Float64Array(n2);
        let value = matrix2;
        let i2, j2;
        let isSymmetric = false;
        if (assumeSymmetric) {
          isSymmetric = true;
        } else {
          isSymmetric = matrix2.isSymmetric();
        }
        if (isSymmetric) {
          for (i2 = 0; i2 < n2; i2++) {
            for (j2 = 0; j2 < n2; j2++) {
              V3.set(i2, j2, value.get(i2, j2));
            }
          }
          tred2(n2, e2, d3, V3);
          tql2(n2, e2, d3, V3);
        } else {
          let H3 = new Matrix3(n2, n2);
          let ort = new Float64Array(n2);
          for (j2 = 0; j2 < n2; j2++) {
            for (i2 = 0; i2 < n2; i2++) {
              H3.set(i2, j2, value.get(i2, j2));
            }
          }
          orthes(n2, H3, ort, V3);
          hqr2(n2, e2, d3, V3, H3);
        }
        this.n = n2;
        this.e = e2;
        this.d = d3;
        this.V = V3;
      }
      get realEigenvalues() {
        return Array.from(this.d);
      }
      get imaginaryEigenvalues() {
        return Array.from(this.e);
      }
      get eigenvectorMatrix() {
        return this.V;
      }
      get diagonalMatrix() {
        let n2 = this.n;
        let e2 = this.e;
        let d3 = this.d;
        let X2 = new Matrix3(n2, n2);
        let i2, j2;
        for (i2 = 0; i2 < n2; i2++) {
          for (j2 = 0; j2 < n2; j2++) {
            X2.set(i2, j2, 0);
          }
          X2.set(i2, i2, d3[i2]);
          if (e2[i2] > 0) {
            X2.set(i2, i2 + 1, e2[i2]);
          } else if (e2[i2] < 0) {
            X2.set(i2, i2 - 1, e2[i2]);
          }
        }
        return X2;
      }
    };
    function tred2(n2, e2, d3, V3) {
      let f3, g3, h3, i2, j2, k2, hh, scale2;
      for (j2 = 0; j2 < n2; j2++) {
        d3[j2] = V3.get(n2 - 1, j2);
      }
      for (i2 = n2 - 1; i2 > 0; i2--) {
        scale2 = 0;
        h3 = 0;
        for (k2 = 0; k2 < i2; k2++) {
          scale2 = scale2 + Math.abs(d3[k2]);
        }
        if (scale2 === 0) {
          e2[i2] = d3[i2 - 1];
          for (j2 = 0; j2 < i2; j2++) {
            d3[j2] = V3.get(i2 - 1, j2);
            V3.set(i2, j2, 0);
            V3.set(j2, i2, 0);
          }
        } else {
          for (k2 = 0; k2 < i2; k2++) {
            d3[k2] /= scale2;
            h3 += d3[k2] * d3[k2];
          }
          f3 = d3[i2 - 1];
          g3 = Math.sqrt(h3);
          if (f3 > 0) {
            g3 = -g3;
          }
          e2[i2] = scale2 * g3;
          h3 = h3 - f3 * g3;
          d3[i2 - 1] = f3 - g3;
          for (j2 = 0; j2 < i2; j2++) {
            e2[j2] = 0;
          }
          for (j2 = 0; j2 < i2; j2++) {
            f3 = d3[j2];
            V3.set(j2, i2, f3);
            g3 = e2[j2] + V3.get(j2, j2) * f3;
            for (k2 = j2 + 1; k2 <= i2 - 1; k2++) {
              g3 += V3.get(k2, j2) * d3[k2];
              e2[k2] += V3.get(k2, j2) * f3;
            }
            e2[j2] = g3;
          }
          f3 = 0;
          for (j2 = 0; j2 < i2; j2++) {
            e2[j2] /= h3;
            f3 += e2[j2] * d3[j2];
          }
          hh = f3 / (h3 + h3);
          for (j2 = 0; j2 < i2; j2++) {
            e2[j2] -= hh * d3[j2];
          }
          for (j2 = 0; j2 < i2; j2++) {
            f3 = d3[j2];
            g3 = e2[j2];
            for (k2 = j2; k2 <= i2 - 1; k2++) {
              V3.set(k2, j2, V3.get(k2, j2) - (f3 * e2[k2] + g3 * d3[k2]));
            }
            d3[j2] = V3.get(i2 - 1, j2);
            V3.set(i2, j2, 0);
          }
        }
        d3[i2] = h3;
      }
      for (i2 = 0; i2 < n2 - 1; i2++) {
        V3.set(n2 - 1, i2, V3.get(i2, i2));
        V3.set(i2, i2, 1);
        h3 = d3[i2 + 1];
        if (h3 !== 0) {
          for (k2 = 0; k2 <= i2; k2++) {
            d3[k2] = V3.get(k2, i2 + 1) / h3;
          }
          for (j2 = 0; j2 <= i2; j2++) {
            g3 = 0;
            for (k2 = 0; k2 <= i2; k2++) {
              g3 += V3.get(k2, i2 + 1) * V3.get(k2, j2);
            }
            for (k2 = 0; k2 <= i2; k2++) {
              V3.set(k2, j2, V3.get(k2, j2) - g3 * d3[k2]);
            }
          }
        }
        for (k2 = 0; k2 <= i2; k2++) {
          V3.set(k2, i2 + 1, 0);
        }
      }
      for (j2 = 0; j2 < n2; j2++) {
        d3[j2] = V3.get(n2 - 1, j2);
        V3.set(n2 - 1, j2, 0);
      }
      V3.set(n2 - 1, n2 - 1, 1);
      e2[0] = 0;
    }
    function tql2(n2, e2, d3, V3) {
      let g3, h3, i2, j2, k2, l3, m2, p3, r3, dl1, c3, c22, c32, el1, s2, s22;
      for (i2 = 1; i2 < n2; i2++) {
        e2[i2 - 1] = e2[i2];
      }
      e2[n2 - 1] = 0;
      let f3 = 0;
      let tst1 = 0;
      let eps = Number.EPSILON;
      for (l3 = 0; l3 < n2; l3++) {
        tst1 = Math.max(tst1, Math.abs(d3[l3]) + Math.abs(e2[l3]));
        m2 = l3;
        while (m2 < n2) {
          if (Math.abs(e2[m2]) <= eps * tst1) {
            break;
          }
          m2++;
        }
        if (m2 > l3) {
          do {
            g3 = d3[l3];
            p3 = (d3[l3 + 1] - g3) / (2 * e2[l3]);
            r3 = hypotenuse(p3, 1);
            if (p3 < 0) {
              r3 = -r3;
            }
            d3[l3] = e2[l3] / (p3 + r3);
            d3[l3 + 1] = e2[l3] * (p3 + r3);
            dl1 = d3[l3 + 1];
            h3 = g3 - d3[l3];
            for (i2 = l3 + 2; i2 < n2; i2++) {
              d3[i2] -= h3;
            }
            f3 = f3 + h3;
            p3 = d3[m2];
            c3 = 1;
            c22 = c3;
            c32 = c3;
            el1 = e2[l3 + 1];
            s2 = 0;
            s22 = 0;
            for (i2 = m2 - 1; i2 >= l3; i2--) {
              c32 = c22;
              c22 = c3;
              s22 = s2;
              g3 = c3 * e2[i2];
              h3 = c3 * p3;
              r3 = hypotenuse(p3, e2[i2]);
              e2[i2 + 1] = s2 * r3;
              s2 = e2[i2] / r3;
              c3 = p3 / r3;
              p3 = c3 * d3[i2] - s2 * g3;
              d3[i2 + 1] = h3 + s2 * (c3 * g3 + s2 * d3[i2]);
              for (k2 = 0; k2 < n2; k2++) {
                h3 = V3.get(k2, i2 + 1);
                V3.set(k2, i2 + 1, s2 * V3.get(k2, i2) + c3 * h3);
                V3.set(k2, i2, c3 * V3.get(k2, i2) - s2 * h3);
              }
            }
            p3 = -s2 * s22 * c32 * el1 * e2[l3] / dl1;
            e2[l3] = s2 * p3;
            d3[l3] = c3 * p3;
          } while (Math.abs(e2[l3]) > eps * tst1);
        }
        d3[l3] = d3[l3] + f3;
        e2[l3] = 0;
      }
      for (i2 = 0; i2 < n2 - 1; i2++) {
        k2 = i2;
        p3 = d3[i2];
        for (j2 = i2 + 1; j2 < n2; j2++) {
          if (d3[j2] < p3) {
            k2 = j2;
            p3 = d3[j2];
          }
        }
        if (k2 !== i2) {
          d3[k2] = d3[i2];
          d3[i2] = p3;
          for (j2 = 0; j2 < n2; j2++) {
            p3 = V3.get(j2, i2);
            V3.set(j2, i2, V3.get(j2, k2));
            V3.set(j2, k2, p3);
          }
        }
      }
    }
    function orthes(n2, H3, ort, V3) {
      let low = 0;
      let high = n2 - 1;
      let f3, g3, h3, i2, j2, m2;
      let scale2;
      for (m2 = low + 1; m2 <= high - 1; m2++) {
        scale2 = 0;
        for (i2 = m2; i2 <= high; i2++) {
          scale2 = scale2 + Math.abs(H3.get(i2, m2 - 1));
        }
        if (scale2 !== 0) {
          h3 = 0;
          for (i2 = high; i2 >= m2; i2--) {
            ort[i2] = H3.get(i2, m2 - 1) / scale2;
            h3 += ort[i2] * ort[i2];
          }
          g3 = Math.sqrt(h3);
          if (ort[m2] > 0) {
            g3 = -g3;
          }
          h3 = h3 - ort[m2] * g3;
          ort[m2] = ort[m2] - g3;
          for (j2 = m2; j2 < n2; j2++) {
            f3 = 0;
            for (i2 = high; i2 >= m2; i2--) {
              f3 += ort[i2] * H3.get(i2, j2);
            }
            f3 = f3 / h3;
            for (i2 = m2; i2 <= high; i2++) {
              H3.set(i2, j2, H3.get(i2, j2) - f3 * ort[i2]);
            }
          }
          for (i2 = 0; i2 <= high; i2++) {
            f3 = 0;
            for (j2 = high; j2 >= m2; j2--) {
              f3 += ort[j2] * H3.get(i2, j2);
            }
            f3 = f3 / h3;
            for (j2 = m2; j2 <= high; j2++) {
              H3.set(i2, j2, H3.get(i2, j2) - f3 * ort[j2]);
            }
          }
          ort[m2] = scale2 * ort[m2];
          H3.set(m2, m2 - 1, scale2 * g3);
        }
      }
      for (i2 = 0; i2 < n2; i2++) {
        for (j2 = 0; j2 < n2; j2++) {
          V3.set(i2, j2, i2 === j2 ? 1 : 0);
        }
      }
      for (m2 = high - 1; m2 >= low + 1; m2--) {
        if (H3.get(m2, m2 - 1) !== 0) {
          for (i2 = m2 + 1; i2 <= high; i2++) {
            ort[i2] = H3.get(i2, m2 - 1);
          }
          for (j2 = m2; j2 <= high; j2++) {
            g3 = 0;
            for (i2 = m2; i2 <= high; i2++) {
              g3 += ort[i2] * V3.get(i2, j2);
            }
            g3 = g3 / ort[m2] / H3.get(m2, m2 - 1);
            for (i2 = m2; i2 <= high; i2++) {
              V3.set(i2, j2, V3.get(i2, j2) + g3 * ort[i2]);
            }
          }
        }
      }
    }
    function hqr2(nn, e2, d3, V3, H3) {
      let n2 = nn - 1;
      let low = 0;
      let high = nn - 1;
      let eps = Number.EPSILON;
      let exshift = 0;
      let norm = 0;
      let p3 = 0;
      let q2 = 0;
      let r3 = 0;
      let s2 = 0;
      let z4 = 0;
      let iter = 0;
      let i2, j2, k2, l3, m2, t3, w3, x4, y4;
      let ra, sa, vr, vi;
      let notlast, cdivres;
      for (i2 = 0; i2 < nn; i2++) {
        if (i2 < low || i2 > high) {
          d3[i2] = H3.get(i2, i2);
          e2[i2] = 0;
        }
        for (j2 = Math.max(i2 - 1, 0); j2 < nn; j2++) {
          norm = norm + Math.abs(H3.get(i2, j2));
        }
      }
      while (n2 >= low) {
        l3 = n2;
        while (l3 > low) {
          s2 = Math.abs(H3.get(l3 - 1, l3 - 1)) + Math.abs(H3.get(l3, l3));
          if (s2 === 0) {
            s2 = norm;
          }
          if (Math.abs(H3.get(l3, l3 - 1)) < eps * s2) {
            break;
          }
          l3--;
        }
        if (l3 === n2) {
          H3.set(n2, n2, H3.get(n2, n2) + exshift);
          d3[n2] = H3.get(n2, n2);
          e2[n2] = 0;
          n2--;
          iter = 0;
        } else if (l3 === n2 - 1) {
          w3 = H3.get(n2, n2 - 1) * H3.get(n2 - 1, n2);
          p3 = (H3.get(n2 - 1, n2 - 1) - H3.get(n2, n2)) / 2;
          q2 = p3 * p3 + w3;
          z4 = Math.sqrt(Math.abs(q2));
          H3.set(n2, n2, H3.get(n2, n2) + exshift);
          H3.set(n2 - 1, n2 - 1, H3.get(n2 - 1, n2 - 1) + exshift);
          x4 = H3.get(n2, n2);
          if (q2 >= 0) {
            z4 = p3 >= 0 ? p3 + z4 : p3 - z4;
            d3[n2 - 1] = x4 + z4;
            d3[n2] = d3[n2 - 1];
            if (z4 !== 0) {
              d3[n2] = x4 - w3 / z4;
            }
            e2[n2 - 1] = 0;
            e2[n2] = 0;
            x4 = H3.get(n2, n2 - 1);
            s2 = Math.abs(x4) + Math.abs(z4);
            p3 = x4 / s2;
            q2 = z4 / s2;
            r3 = Math.sqrt(p3 * p3 + q2 * q2);
            p3 = p3 / r3;
            q2 = q2 / r3;
            for (j2 = n2 - 1; j2 < nn; j2++) {
              z4 = H3.get(n2 - 1, j2);
              H3.set(n2 - 1, j2, q2 * z4 + p3 * H3.get(n2, j2));
              H3.set(n2, j2, q2 * H3.get(n2, j2) - p3 * z4);
            }
            for (i2 = 0; i2 <= n2; i2++) {
              z4 = H3.get(i2, n2 - 1);
              H3.set(i2, n2 - 1, q2 * z4 + p3 * H3.get(i2, n2));
              H3.set(i2, n2, q2 * H3.get(i2, n2) - p3 * z4);
            }
            for (i2 = low; i2 <= high; i2++) {
              z4 = V3.get(i2, n2 - 1);
              V3.set(i2, n2 - 1, q2 * z4 + p3 * V3.get(i2, n2));
              V3.set(i2, n2, q2 * V3.get(i2, n2) - p3 * z4);
            }
          } else {
            d3[n2 - 1] = x4 + p3;
            d3[n2] = x4 + p3;
            e2[n2 - 1] = z4;
            e2[n2] = -z4;
          }
          n2 = n2 - 2;
          iter = 0;
        } else {
          x4 = H3.get(n2, n2);
          y4 = 0;
          w3 = 0;
          if (l3 < n2) {
            y4 = H3.get(n2 - 1, n2 - 1);
            w3 = H3.get(n2, n2 - 1) * H3.get(n2 - 1, n2);
          }
          if (iter === 10) {
            exshift += x4;
            for (i2 = low; i2 <= n2; i2++) {
              H3.set(i2, i2, H3.get(i2, i2) - x4);
            }
            s2 = Math.abs(H3.get(n2, n2 - 1)) + Math.abs(H3.get(n2 - 1, n2 - 2));
            x4 = y4 = 0.75 * s2;
            w3 = -0.4375 * s2 * s2;
          }
          if (iter === 30) {
            s2 = (y4 - x4) / 2;
            s2 = s2 * s2 + w3;
            if (s2 > 0) {
              s2 = Math.sqrt(s2);
              if (y4 < x4) {
                s2 = -s2;
              }
              s2 = x4 - w3 / ((y4 - x4) / 2 + s2);
              for (i2 = low; i2 <= n2; i2++) {
                H3.set(i2, i2, H3.get(i2, i2) - s2);
              }
              exshift += s2;
              x4 = y4 = w3 = 0.964;
            }
          }
          iter = iter + 1;
          m2 = n2 - 2;
          while (m2 >= l3) {
            z4 = H3.get(m2, m2);
            r3 = x4 - z4;
            s2 = y4 - z4;
            p3 = (r3 * s2 - w3) / H3.get(m2 + 1, m2) + H3.get(m2, m2 + 1);
            q2 = H3.get(m2 + 1, m2 + 1) - z4 - r3 - s2;
            r3 = H3.get(m2 + 2, m2 + 1);
            s2 = Math.abs(p3) + Math.abs(q2) + Math.abs(r3);
            p3 = p3 / s2;
            q2 = q2 / s2;
            r3 = r3 / s2;
            if (m2 === l3) {
              break;
            }
            if (Math.abs(H3.get(m2, m2 - 1)) * (Math.abs(q2) + Math.abs(r3)) < eps * (Math.abs(p3) * (Math.abs(H3.get(m2 - 1, m2 - 1)) + Math.abs(z4) + Math.abs(H3.get(m2 + 1, m2 + 1))))) {
              break;
            }
            m2--;
          }
          for (i2 = m2 + 2; i2 <= n2; i2++) {
            H3.set(i2, i2 - 2, 0);
            if (i2 > m2 + 2) {
              H3.set(i2, i2 - 3, 0);
            }
          }
          for (k2 = m2; k2 <= n2 - 1; k2++) {
            notlast = k2 !== n2 - 1;
            if (k2 !== m2) {
              p3 = H3.get(k2, k2 - 1);
              q2 = H3.get(k2 + 1, k2 - 1);
              r3 = notlast ? H3.get(k2 + 2, k2 - 1) : 0;
              x4 = Math.abs(p3) + Math.abs(q2) + Math.abs(r3);
              if (x4 !== 0) {
                p3 = p3 / x4;
                q2 = q2 / x4;
                r3 = r3 / x4;
              }
            }
            if (x4 === 0) {
              break;
            }
            s2 = Math.sqrt(p3 * p3 + q2 * q2 + r3 * r3);
            if (p3 < 0) {
              s2 = -s2;
            }
            if (s2 !== 0) {
              if (k2 !== m2) {
                H3.set(k2, k2 - 1, -s2 * x4);
              } else if (l3 !== m2) {
                H3.set(k2, k2 - 1, -H3.get(k2, k2 - 1));
              }
              p3 = p3 + s2;
              x4 = p3 / s2;
              y4 = q2 / s2;
              z4 = r3 / s2;
              q2 = q2 / p3;
              r3 = r3 / p3;
              for (j2 = k2; j2 < nn; j2++) {
                p3 = H3.get(k2, j2) + q2 * H3.get(k2 + 1, j2);
                if (notlast) {
                  p3 = p3 + r3 * H3.get(k2 + 2, j2);
                  H3.set(k2 + 2, j2, H3.get(k2 + 2, j2) - p3 * z4);
                }
                H3.set(k2, j2, H3.get(k2, j2) - p3 * x4);
                H3.set(k2 + 1, j2, H3.get(k2 + 1, j2) - p3 * y4);
              }
              for (i2 = 0; i2 <= Math.min(n2, k2 + 3); i2++) {
                p3 = x4 * H3.get(i2, k2) + y4 * H3.get(i2, k2 + 1);
                if (notlast) {
                  p3 = p3 + z4 * H3.get(i2, k2 + 2);
                  H3.set(i2, k2 + 2, H3.get(i2, k2 + 2) - p3 * r3);
                }
                H3.set(i2, k2, H3.get(i2, k2) - p3);
                H3.set(i2, k2 + 1, H3.get(i2, k2 + 1) - p3 * q2);
              }
              for (i2 = low; i2 <= high; i2++) {
                p3 = x4 * V3.get(i2, k2) + y4 * V3.get(i2, k2 + 1);
                if (notlast) {
                  p3 = p3 + z4 * V3.get(i2, k2 + 2);
                  V3.set(i2, k2 + 2, V3.get(i2, k2 + 2) - p3 * r3);
                }
                V3.set(i2, k2, V3.get(i2, k2) - p3);
                V3.set(i2, k2 + 1, V3.get(i2, k2 + 1) - p3 * q2);
              }
            }
          }
        }
      }
      if (norm === 0) {
        return;
      }
      for (n2 = nn - 1; n2 >= 0; n2--) {
        p3 = d3[n2];
        q2 = e2[n2];
        if (q2 === 0) {
          l3 = n2;
          H3.set(n2, n2, 1);
          for (i2 = n2 - 1; i2 >= 0; i2--) {
            w3 = H3.get(i2, i2) - p3;
            r3 = 0;
            for (j2 = l3; j2 <= n2; j2++) {
              r3 = r3 + H3.get(i2, j2) * H3.get(j2, n2);
            }
            if (e2[i2] < 0) {
              z4 = w3;
              s2 = r3;
            } else {
              l3 = i2;
              if (e2[i2] === 0) {
                H3.set(i2, n2, w3 !== 0 ? -r3 / w3 : -r3 / (eps * norm));
              } else {
                x4 = H3.get(i2, i2 + 1);
                y4 = H3.get(i2 + 1, i2);
                q2 = (d3[i2] - p3) * (d3[i2] - p3) + e2[i2] * e2[i2];
                t3 = (x4 * s2 - z4 * r3) / q2;
                H3.set(i2, n2, t3);
                H3.set(
                  i2 + 1,
                  n2,
                  Math.abs(x4) > Math.abs(z4) ? (-r3 - w3 * t3) / x4 : (-s2 - y4 * t3) / z4
                );
              }
              t3 = Math.abs(H3.get(i2, n2));
              if (eps * t3 * t3 > 1) {
                for (j2 = i2; j2 <= n2; j2++) {
                  H3.set(j2, n2, H3.get(j2, n2) / t3);
                }
              }
            }
          }
        } else if (q2 < 0) {
          l3 = n2 - 1;
          if (Math.abs(H3.get(n2, n2 - 1)) > Math.abs(H3.get(n2 - 1, n2))) {
            H3.set(n2 - 1, n2 - 1, q2 / H3.get(n2, n2 - 1));
            H3.set(n2 - 1, n2, -(H3.get(n2, n2) - p3) / H3.get(n2, n2 - 1));
          } else {
            cdivres = cdiv(0, -H3.get(n2 - 1, n2), H3.get(n2 - 1, n2 - 1) - p3, q2);
            H3.set(n2 - 1, n2 - 1, cdivres[0]);
            H3.set(n2 - 1, n2, cdivres[1]);
          }
          H3.set(n2, n2 - 1, 0);
          H3.set(n2, n2, 1);
          for (i2 = n2 - 2; i2 >= 0; i2--) {
            ra = 0;
            sa = 0;
            for (j2 = l3; j2 <= n2; j2++) {
              ra = ra + H3.get(i2, j2) * H3.get(j2, n2 - 1);
              sa = sa + H3.get(i2, j2) * H3.get(j2, n2);
            }
            w3 = H3.get(i2, i2) - p3;
            if (e2[i2] < 0) {
              z4 = w3;
              r3 = ra;
              s2 = sa;
            } else {
              l3 = i2;
              if (e2[i2] === 0) {
                cdivres = cdiv(-ra, -sa, w3, q2);
                H3.set(i2, n2 - 1, cdivres[0]);
                H3.set(i2, n2, cdivres[1]);
              } else {
                x4 = H3.get(i2, i2 + 1);
                y4 = H3.get(i2 + 1, i2);
                vr = (d3[i2] - p3) * (d3[i2] - p3) + e2[i2] * e2[i2] - q2 * q2;
                vi = (d3[i2] - p3) * 2 * q2;
                if (vr === 0 && vi === 0) {
                  vr = eps * norm * (Math.abs(w3) + Math.abs(q2) + Math.abs(x4) + Math.abs(y4) + Math.abs(z4));
                }
                cdivres = cdiv(
                  x4 * r3 - z4 * ra + q2 * sa,
                  x4 * s2 - z4 * sa - q2 * ra,
                  vr,
                  vi
                );
                H3.set(i2, n2 - 1, cdivres[0]);
                H3.set(i2, n2, cdivres[1]);
                if (Math.abs(x4) > Math.abs(z4) + Math.abs(q2)) {
                  H3.set(
                    i2 + 1,
                    n2 - 1,
                    (-ra - w3 * H3.get(i2, n2 - 1) + q2 * H3.get(i2, n2)) / x4
                  );
                  H3.set(
                    i2 + 1,
                    n2,
                    (-sa - w3 * H3.get(i2, n2) - q2 * H3.get(i2, n2 - 1)) / x4
                  );
                } else {
                  cdivres = cdiv(
                    -r3 - y4 * H3.get(i2, n2 - 1),
                    -s2 - y4 * H3.get(i2, n2),
                    z4,
                    q2
                  );
                  H3.set(i2 + 1, n2 - 1, cdivres[0]);
                  H3.set(i2 + 1, n2, cdivres[1]);
                }
              }
              t3 = Math.max(Math.abs(H3.get(i2, n2 - 1)), Math.abs(H3.get(i2, n2)));
              if (eps * t3 * t3 > 1) {
                for (j2 = i2; j2 <= n2; j2++) {
                  H3.set(j2, n2 - 1, H3.get(j2, n2 - 1) / t3);
                  H3.set(j2, n2, H3.get(j2, n2) / t3);
                }
              }
            }
          }
        }
      }
      for (i2 = 0; i2 < nn; i2++) {
        if (i2 < low || i2 > high) {
          for (j2 = i2; j2 < nn; j2++) {
            V3.set(i2, j2, H3.get(i2, j2));
          }
        }
      }
      for (j2 = nn - 1; j2 >= low; j2--) {
        for (i2 = low; i2 <= high; i2++) {
          z4 = 0;
          for (k2 = low; k2 <= Math.min(j2, high); k2++) {
            z4 = z4 + V3.get(i2, k2) * H3.get(k2, j2);
          }
          V3.set(i2, j2, z4);
        }
      }
    }
    function cdiv(xr, xi, yr, yi) {
      let r3, d3;
      if (Math.abs(yr) > Math.abs(yi)) {
        r3 = yi / yr;
        d3 = yr + r3 * yi;
        return [(xr + r3 * xi) / d3, (xi - r3 * xr) / d3];
      } else {
        r3 = yr / yi;
        d3 = yi + r3 * yr;
        return [(r3 * xr + xi) / d3, (r3 * xi - xr) / d3];
      }
    }
    var CholeskyDecomposition2 = class {
      constructor(value) {
        value = WrapperMatrix2D2.checkMatrix(value);
        if (!value.isSymmetric()) {
          throw new Error("Matrix is not symmetric");
        }
        let a3 = value;
        let dimension = a3.rows;
        let l3 = new Matrix3(dimension, dimension);
        let positiveDefinite = true;
        let i2, j2, k2;
        for (j2 = 0; j2 < dimension; j2++) {
          let d3 = 0;
          for (k2 = 0; k2 < j2; k2++) {
            let s2 = 0;
            for (i2 = 0; i2 < k2; i2++) {
              s2 += l3.get(k2, i2) * l3.get(j2, i2);
            }
            s2 = (a3.get(j2, k2) - s2) / l3.get(k2, k2);
            l3.set(j2, k2, s2);
            d3 = d3 + s2 * s2;
          }
          d3 = a3.get(j2, j2) - d3;
          positiveDefinite && (positiveDefinite = d3 > 0);
          l3.set(j2, j2, Math.sqrt(Math.max(d3, 0)));
          for (k2 = j2 + 1; k2 < dimension; k2++) {
            l3.set(j2, k2, 0);
          }
        }
        this.L = l3;
        this.positiveDefinite = positiveDefinite;
      }
      isPositiveDefinite() {
        return this.positiveDefinite;
      }
      solve(value) {
        value = WrapperMatrix2D2.checkMatrix(value);
        let l3 = this.L;
        let dimension = l3.rows;
        if (value.rows !== dimension) {
          throw new Error("Matrix dimensions do not match");
        }
        if (this.isPositiveDefinite() === false) {
          throw new Error("Matrix is not positive definite");
        }
        let count = value.columns;
        let B3 = value.clone();
        let i2, j2, k2;
        for (k2 = 0; k2 < dimension; k2++) {
          for (j2 = 0; j2 < count; j2++) {
            for (i2 = 0; i2 < k2; i2++) {
              B3.set(k2, j2, B3.get(k2, j2) - B3.get(i2, j2) * l3.get(k2, i2));
            }
            B3.set(k2, j2, B3.get(k2, j2) / l3.get(k2, k2));
          }
        }
        for (k2 = dimension - 1; k2 >= 0; k2--) {
          for (j2 = 0; j2 < count; j2++) {
            for (i2 = k2 + 1; i2 < dimension; i2++) {
              B3.set(k2, j2, B3.get(k2, j2) - B3.get(i2, j2) * l3.get(i2, k2));
            }
            B3.set(k2, j2, B3.get(k2, j2) / l3.get(k2, k2));
          }
        }
        return B3;
      }
      get lowerTriangularMatrix() {
        return this.L;
      }
    };
    var nipals = class {
      constructor(X2, options = {}) {
        X2 = WrapperMatrix2D2.checkMatrix(X2);
        let { Y: Y3 } = options;
        const {
          scaleScores = false,
          maxIterations = 1e3,
          terminationCriteria = 1e-10
        } = options;
        let u3;
        if (Y3) {
          if (isAnyArray2.isAnyArray(Y3) && typeof Y3[0] === "number") {
            Y3 = Matrix3.columnVector(Y3);
          } else {
            Y3 = WrapperMatrix2D2.checkMatrix(Y3);
          }
          if (Y3.rows !== X2.rows) {
            throw new Error("Y should have the same number of rows as X");
          }
          u3 = Y3.getColumnVector(0);
        } else {
          u3 = X2.getColumnVector(0);
        }
        let diff = 1;
        let t3, q2, w3, tOld;
        for (let counter = 0; counter < maxIterations && diff > terminationCriteria; counter++) {
          w3 = X2.transpose().mmul(u3).div(u3.transpose().mmul(u3).get(0, 0));
          w3 = w3.div(w3.norm());
          t3 = X2.mmul(w3).div(w3.transpose().mmul(w3).get(0, 0));
          if (counter > 0) {
            diff = t3.clone().sub(tOld).pow(2).sum();
          }
          tOld = t3.clone();
          if (Y3) {
            q2 = Y3.transpose().mmul(t3).div(t3.transpose().mmul(t3).get(0, 0));
            q2 = q2.div(q2.norm());
            u3 = Y3.mmul(q2).div(q2.transpose().mmul(q2).get(0, 0));
          } else {
            u3 = t3;
          }
        }
        if (Y3) {
          let p3 = X2.transpose().mmul(t3).div(t3.transpose().mmul(t3).get(0, 0));
          p3 = p3.div(p3.norm());
          let xResidual = X2.clone().sub(t3.clone().mmul(p3.transpose()));
          let residual = u3.transpose().mmul(t3).div(t3.transpose().mmul(t3).get(0, 0));
          let yResidual = Y3.clone().sub(
            t3.clone().mulS(residual.get(0, 0)).mmul(q2.transpose())
          );
          this.t = t3;
          this.p = p3.transpose();
          this.w = w3.transpose();
          this.q = q2;
          this.u = u3;
          this.s = t3.transpose().mmul(t3);
          this.xResidual = xResidual;
          this.yResidual = yResidual;
          this.betas = residual;
        } else {
          this.w = w3.transpose();
          this.s = t3.transpose().mmul(t3).sqrt();
          if (scaleScores) {
            this.t = t3.clone().div(this.s.get(0, 0));
          } else {
            this.t = t3;
          }
          this.xResidual = X2.sub(t3.mmul(w3.transpose()));
        }
      }
    };
    exports.AbstractMatrix = AbstractMatrix2;
    exports.CHO = CholeskyDecomposition2;
    exports.CholeskyDecomposition = CholeskyDecomposition2;
    exports.DistanceMatrix = DistanceMatrix2;
    exports.EVD = EigenvalueDecomposition2;
    exports.EigenvalueDecomposition = EigenvalueDecomposition2;
    exports.LU = LuDecomposition2;
    exports.LuDecomposition = LuDecomposition2;
    exports.Matrix = Matrix3;
    exports.MatrixColumnSelectionView = MatrixColumnSelectionView2;
    exports.MatrixColumnView = MatrixColumnView2;
    exports.MatrixFlipColumnView = MatrixFlipColumnView2;
    exports.MatrixFlipRowView = MatrixFlipRowView2;
    exports.MatrixRowSelectionView = MatrixRowSelectionView2;
    exports.MatrixRowView = MatrixRowView2;
    exports.MatrixSelectionView = MatrixSelectionView2;
    exports.MatrixSubView = MatrixSubView2;
    exports.MatrixTransposeView = MatrixTransposeView2;
    exports.NIPALS = nipals;
    exports.Nipals = nipals;
    exports.QR = QrDecomposition2;
    exports.QrDecomposition = QrDecomposition2;
    exports.SVD = SingularValueDecomposition3;
    exports.SingularValueDecomposition = SingularValueDecomposition3;
    exports.SymmetricMatrix = SymmetricMatrix2;
    exports.WrapperMatrix1D = WrapperMatrix1D2;
    exports.WrapperMatrix2D = WrapperMatrix2D2;
    exports.correlation = correlation2;
    exports.covariance = covariance2;
    exports.default = Matrix3;
    exports.determinant = determinant2;
    exports.inverse = inverse2;
    exports.linearDependencies = linearDependencies2;
    exports.pseudoInverse = pseudoInverse2;
    exports.solve = solve2;
    exports.wrap = wrap3;
  }
});

// node_modules/lodash/clone.js
var require_clone = __commonJS({
  "node_modules/lodash/clone.js"(exports, module) {
    var baseClone = require_baseClone();
    var CLONE_SYMBOLS_FLAG = 4;
    function clone3(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }
    module.exports = clone3;
  }
});

// node_modules/lodash/_baseFilter.js
var require_baseFilter = __commonJS({
  "node_modules/lodash/_baseFilter.js"(exports, module) {
    var baseEach = require_baseEach();
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection2) {
        if (predicate(value, index, collection2)) {
          result.push(value);
        }
      });
      return result;
    }
    module.exports = baseFilter;
  }
});

// node_modules/lodash/filter.js
var require_filter = __commonJS({
  "node_modules/lodash/filter.js"(exports, module) {
    var arrayFilter = require_arrayFilter();
    var baseFilter = require_baseFilter();
    var baseIteratee = require_baseIteratee();
    var isArray3 = require_isArray();
    function filter(collection, predicate) {
      var func = isArray3(collection) ? arrayFilter : baseFilter;
      return func(collection, baseIteratee(predicate, 3));
    }
    module.exports = filter;
  }
});

// node_modules/lodash/_baseHas.js
var require_baseHas = __commonJS({
  "node_modules/lodash/_baseHas.js"(exports, module) {
    var objectProto2 = Object.prototype;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }
    module.exports = baseHas;
  }
});

// node_modules/lodash/has.js
var require_has = __commonJS({
  "node_modules/lodash/has.js"(exports, module) {
    var baseHas = require_baseHas();
    var hasPath = require_hasPath();
    function has2(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }
    module.exports = has2;
  }
});

// node_modules/lodash/isEmpty.js
var require_isEmpty = __commonJS({
  "node_modules/lodash/isEmpty.js"(exports, module) {
    var baseKeys = require_baseKeys();
    var getTag = require_getTag();
    var isArguments = require_isArguments();
    var isArray3 = require_isArray();
    var isArrayLike = require_isArrayLike();
    var isBuffer = require_isBuffer();
    var isPrototype = require_isPrototype();
    var isTypedArray = require_isTypedArray();
    var mapTag = "[object Map]";
    var setTag = "[object Set]";
    var objectProto2 = Object.prototype;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    function isEmpty4(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) && (isArray3(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }
    module.exports = isEmpty4;
  }
});

// node_modules/lodash/isUndefined.js
var require_isUndefined = __commonJS({
  "node_modules/lodash/isUndefined.js"(exports, module) {
    function isUndefined(value) {
      return value === void 0;
    }
    module.exports = isUndefined;
  }
});

// node_modules/lodash/_arrayReduce.js
var require_arrayReduce = __commonJS({
  "node_modules/lodash/_arrayReduce.js"(exports, module) {
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    module.exports = arrayReduce;
  }
});

// node_modules/lodash/_baseReduce.js
var require_baseReduce = __commonJS({
  "node_modules/lodash/_baseReduce.js"(exports, module) {
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    module.exports = baseReduce;
  }
});

// node_modules/lodash/reduce.js
var require_reduce = __commonJS({
  "node_modules/lodash/reduce.js"(exports, module) {
    var arrayReduce = require_arrayReduce();
    var baseEach = require_baseEach();
    var baseIteratee = require_baseIteratee();
    var baseReduce = require_baseReduce();
    var isArray3 = require_isArray();
    function reduce(collection, iteratee, accumulator) {
      var func = isArray3(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
      return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }
    module.exports = reduce;
  }
});

// node_modules/lodash/_asciiSize.js
var require_asciiSize = __commonJS({
  "node_modules/lodash/_asciiSize.js"(exports, module) {
    var baseProperty = require_baseProperty();
    var asciiSize = baseProperty("length");
    module.exports = asciiSize;
  }
});

// node_modules/lodash/_hasUnicode.js
var require_hasUnicode = __commonJS({
  "node_modules/lodash/_hasUnicode.js"(exports, module) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsZWJ = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    module.exports = hasUnicode;
  }
});

// node_modules/lodash/_unicodeSize.js
var require_unicodeSize = __commonJS({
  "node_modules/lodash/_unicodeSize.js"(exports, module) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    module.exports = unicodeSize;
  }
});

// node_modules/lodash/_stringSize.js
var require_stringSize = __commonJS({
  "node_modules/lodash/_stringSize.js"(exports, module) {
    var asciiSize = require_asciiSize();
    var hasUnicode = require_hasUnicode();
    var unicodeSize = require_unicodeSize();
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    module.exports = stringSize;
  }
});

// node_modules/lodash/size.js
var require_size = __commonJS({
  "node_modules/lodash/size.js"(exports, module) {
    var baseKeys = require_baseKeys();
    var getTag = require_getTag();
    var isArrayLike = require_isArrayLike();
    var isString3 = require_isString();
    var stringSize = require_stringSize();
    var mapTag = "[object Map]";
    var setTag = "[object Set]";
    function size2(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString3(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }
    module.exports = size2;
  }
});

// node_modules/lodash/transform.js
var require_transform = __commonJS({
  "node_modules/lodash/transform.js"(exports, module) {
    var arrayEach = require_arrayEach();
    var baseCreate = require_baseCreate();
    var baseForOwn = require_baseForOwn();
    var baseIteratee = require_baseIteratee();
    var getPrototype = require_getPrototype();
    var isArray3 = require_isArray();
    var isBuffer = require_isBuffer();
    var isFunction2 = require_isFunction();
    var isObject2 = require_isObject();
    var isTypedArray = require_isTypedArray();
    function transform(object, iteratee, accumulator) {
      var isArr = isArray3(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
      iteratee = baseIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor() : [];
        } else if (isObject2(object)) {
          accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
        } else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
        return iteratee(accumulator, value, index, object2);
      });
      return accumulator;
    }
    module.exports = transform;
  }
});

// node_modules/lodash/_isFlattenable.js
var require_isFlattenable = __commonJS({
  "node_modules/lodash/_isFlattenable.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var isArguments = require_isArguments();
    var isArray3 = require_isArray();
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray3(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    module.exports = isFlattenable;
  }
});

// node_modules/lodash/_baseFlatten.js
var require_baseFlatten = __commonJS({
  "node_modules/lodash/_baseFlatten.js"(exports, module) {
    var arrayPush = require_arrayPush();
    var isFlattenable = require_isFlattenable();
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    module.exports = baseFlatten;
  }
});

// node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "node_modules/lodash/_baseFindIndex.js"(exports, module) {
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    module.exports = baseFindIndex;
  }
});

// node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "node_modules/lodash/_baseIsNaN.js"(exports, module) {
    function baseIsNaN(value) {
      return value !== value;
    }
    module.exports = baseIsNaN;
  }
});

// node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "node_modules/lodash/_strictIndexOf.js"(exports, module) {
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    module.exports = strictIndexOf;
  }
});

// node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "node_modules/lodash/_baseIndexOf.js"(exports, module) {
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    module.exports = baseIndexOf;
  }
});

// node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "node_modules/lodash/_arrayIncludes.js"(exports, module) {
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    module.exports = arrayIncludes;
  }
});

// node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "node_modules/lodash/_arrayIncludesWith.js"(exports, module) {
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    module.exports = arrayIncludesWith;
  }
});

// node_modules/lodash/noop.js
var require_noop = __commonJS({
  "node_modules/lodash/noop.js"(exports, module) {
    function noop() {
    }
    module.exports = noop;
  }
});

// node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  "node_modules/lodash/_createSet.js"(exports, module) {
    var Set2 = require_Set();
    var noop = require_noop();
    var setToArray = require_setToArray();
    var INFINITY = 1 / 0;
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values3) {
      return new Set2(values3);
    };
    module.exports = createSet;
  }
});

// node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  "node_modules/lodash/_baseUniq.js"(exports, module) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var cacheHas = require_cacheHas();
    var createSet = require_createSet();
    var setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set2 = iteratee ? null : createSet(array);
        if (set2) {
          return setToArray(set2);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module.exports = baseUniq;
  }
});

// node_modules/lodash/union.js
var require_union = __commonJS({
  "node_modules/lodash/union.js"(exports, module) {
    var baseFlatten = require_baseFlatten();
    var baseRest = require_baseRest();
    var baseUniq = require_baseUniq();
    var isArrayLikeObject = require_isArrayLikeObject();
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });
    module.exports = union;
  }
});

// node_modules/lodash/_baseValues.js
var require_baseValues = __commonJS({
  "node_modules/lodash/_baseValues.js"(exports, module) {
    var arrayMap = require_arrayMap();
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    module.exports = baseValues;
  }
});

// node_modules/lodash/values.js
var require_values = __commonJS({
  "node_modules/lodash/values.js"(exports, module) {
    var baseValues = require_baseValues();
    var keys = require_keys();
    function values3(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }
    module.exports = values3;
  }
});

// node_modules/graphlib/lib/lodash.js
var require_lodash2 = __commonJS({
  "node_modules/graphlib/lib/lodash.js"(exports, module) {
    var lodash;
    if (typeof __require === "function") {
      try {
        lodash = {
          clone: require_clone(),
          constant: require_constant(),
          each: require_each(),
          filter: require_filter(),
          has: require_has(),
          isArray: require_isArray(),
          isEmpty: require_isEmpty(),
          isFunction: require_isFunction(),
          isUndefined: require_isUndefined(),
          keys: require_keys(),
          map: require_map(),
          reduce: require_reduce(),
          size: require_size(),
          transform: require_transform(),
          union: require_union(),
          values: require_values()
        };
      } catch (e2) {
      }
    }
    if (!lodash) {
      lodash = window._;
    }
    module.exports = lodash;
  }
});

// node_modules/graphlib/lib/graph.js
var require_graph = __commonJS({
  "node_modules/graphlib/lib/graph.js"(exports, module) {
    "use strict";
    var _2 = require_lodash2();
    module.exports = Graph5;
    var DEFAULT_EDGE_NAME = "\0";
    var GRAPH_NODE = "\0";
    var EDGE_KEY_DELIM = "";
    function Graph5(opts) {
      this._isDirected = _2.has(opts, "directed") ? opts.directed : true;
      this._isMultigraph = _2.has(opts, "multigraph") ? opts.multigraph : false;
      this._isCompound = _2.has(opts, "compound") ? opts.compound : false;
      this._label = void 0;
      this._defaultNodeLabelFn = _2.constant(void 0);
      this._defaultEdgeLabelFn = _2.constant(void 0);
      this._nodes = {};
      if (this._isCompound) {
        this._parent = {};
        this._children = {};
        this._children[GRAPH_NODE] = {};
      }
      this._in = {};
      this._preds = {};
      this._out = {};
      this._sucs = {};
      this._edgeObjs = {};
      this._edgeLabels = {};
    }
    Graph5.prototype._nodeCount = 0;
    Graph5.prototype._edgeCount = 0;
    Graph5.prototype.isDirected = function() {
      return this._isDirected;
    };
    Graph5.prototype.isMultigraph = function() {
      return this._isMultigraph;
    };
    Graph5.prototype.isCompound = function() {
      return this._isCompound;
    };
    Graph5.prototype.setGraph = function(label) {
      this._label = label;
      return this;
    };
    Graph5.prototype.graph = function() {
      return this._label;
    };
    Graph5.prototype.setDefaultNodeLabel = function(newDefault) {
      if (!_2.isFunction(newDefault)) {
        newDefault = _2.constant(newDefault);
      }
      this._defaultNodeLabelFn = newDefault;
      return this;
    };
    Graph5.prototype.nodeCount = function() {
      return this._nodeCount;
    };
    Graph5.prototype.nodes = function() {
      return _2.keys(this._nodes);
    };
    Graph5.prototype.sources = function() {
      var self = this;
      return _2.filter(this.nodes(), function(v3) {
        return _2.isEmpty(self._in[v3]);
      });
    };
    Graph5.prototype.sinks = function() {
      var self = this;
      return _2.filter(this.nodes(), function(v3) {
        return _2.isEmpty(self._out[v3]);
      });
    };
    Graph5.prototype.setNodes = function(vs, value) {
      var args = arguments;
      var self = this;
      _2.each(vs, function(v3) {
        if (args.length > 1) {
          self.setNode(v3, value);
        } else {
          self.setNode(v3);
        }
      });
      return this;
    };
    Graph5.prototype.setNode = function(v3, value) {
      if (_2.has(this._nodes, v3)) {
        if (arguments.length > 1) {
          this._nodes[v3] = value;
        }
        return this;
      }
      this._nodes[v3] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v3);
      if (this._isCompound) {
        this._parent[v3] = GRAPH_NODE;
        this._children[v3] = {};
        this._children[GRAPH_NODE][v3] = true;
      }
      this._in[v3] = {};
      this._preds[v3] = {};
      this._out[v3] = {};
      this._sucs[v3] = {};
      ++this._nodeCount;
      return this;
    };
    Graph5.prototype.node = function(v3) {
      return this._nodes[v3];
    };
    Graph5.prototype.hasNode = function(v3) {
      return _2.has(this._nodes, v3);
    };
    Graph5.prototype.removeNode = function(v3) {
      var self = this;
      if (_2.has(this._nodes, v3)) {
        var removeEdge = function(e2) {
          self.removeEdge(self._edgeObjs[e2]);
        };
        delete this._nodes[v3];
        if (this._isCompound) {
          this._removeFromParentsChildList(v3);
          delete this._parent[v3];
          _2.each(this.children(v3), function(child) {
            self.setParent(child);
          });
          delete this._children[v3];
        }
        _2.each(_2.keys(this._in[v3]), removeEdge);
        delete this._in[v3];
        delete this._preds[v3];
        _2.each(_2.keys(this._out[v3]), removeEdge);
        delete this._out[v3];
        delete this._sucs[v3];
        --this._nodeCount;
      }
      return this;
    };
    Graph5.prototype.setParent = function(v3, parent) {
      if (!this._isCompound) {
        throw new Error("Cannot set parent in a non-compound graph");
      }
      if (_2.isUndefined(parent)) {
        parent = GRAPH_NODE;
      } else {
        parent += "";
        for (var ancestor = parent; !_2.isUndefined(ancestor); ancestor = this.parent(ancestor)) {
          if (ancestor === v3) {
            throw new Error("Setting " + parent + " as parent of " + v3 + " would create a cycle");
          }
        }
        this.setNode(parent);
      }
      this.setNode(v3);
      this._removeFromParentsChildList(v3);
      this._parent[v3] = parent;
      this._children[parent][v3] = true;
      return this;
    };
    Graph5.prototype._removeFromParentsChildList = function(v3) {
      delete this._children[this._parent[v3]][v3];
    };
    Graph5.prototype.parent = function(v3) {
      if (this._isCompound) {
        var parent = this._parent[v3];
        if (parent !== GRAPH_NODE) {
          return parent;
        }
      }
    };
    Graph5.prototype.children = function(v3) {
      if (_2.isUndefined(v3)) {
        v3 = GRAPH_NODE;
      }
      if (this._isCompound) {
        var children = this._children[v3];
        if (children) {
          return _2.keys(children);
        }
      } else if (v3 === GRAPH_NODE) {
        return this.nodes();
      } else if (this.hasNode(v3)) {
        return [];
      }
    };
    Graph5.prototype.predecessors = function(v3) {
      var predsV = this._preds[v3];
      if (predsV) {
        return _2.keys(predsV);
      }
    };
    Graph5.prototype.successors = function(v3) {
      var sucsV = this._sucs[v3];
      if (sucsV) {
        return _2.keys(sucsV);
      }
    };
    Graph5.prototype.neighbors = function(v3) {
      var preds = this.predecessors(v3);
      if (preds) {
        return _2.union(preds, this.successors(v3));
      }
    };
    Graph5.prototype.isLeaf = function(v3) {
      var neighbors;
      if (this.isDirected()) {
        neighbors = this.successors(v3);
      } else {
        neighbors = this.neighbors(v3);
      }
      return neighbors.length === 0;
    };
    Graph5.prototype.filterNodes = function(filter) {
      var copy = new this.constructor({
        directed: this._isDirected,
        multigraph: this._isMultigraph,
        compound: this._isCompound
      });
      copy.setGraph(this.graph());
      var self = this;
      _2.each(this._nodes, function(value, v3) {
        if (filter(v3)) {
          copy.setNode(v3, value);
        }
      });
      _2.each(this._edgeObjs, function(e2) {
        if (copy.hasNode(e2.v) && copy.hasNode(e2.w)) {
          copy.setEdge(e2, self.edge(e2));
        }
      });
      var parents = {};
      function findParent(v3) {
        var parent = self.parent(v3);
        if (parent === void 0 || copy.hasNode(parent)) {
          parents[v3] = parent;
          return parent;
        } else if (parent in parents) {
          return parents[parent];
        } else {
          return findParent(parent);
        }
      }
      if (this._isCompound) {
        _2.each(copy.nodes(), function(v3) {
          copy.setParent(v3, findParent(v3));
        });
      }
      return copy;
    };
    Graph5.prototype.setDefaultEdgeLabel = function(newDefault) {
      if (!_2.isFunction(newDefault)) {
        newDefault = _2.constant(newDefault);
      }
      this._defaultEdgeLabelFn = newDefault;
      return this;
    };
    Graph5.prototype.edgeCount = function() {
      return this._edgeCount;
    };
    Graph5.prototype.edges = function() {
      return _2.values(this._edgeObjs);
    };
    Graph5.prototype.setPath = function(vs, value) {
      var self = this;
      var args = arguments;
      _2.reduce(vs, function(v3, w3) {
        if (args.length > 1) {
          self.setEdge(v3, w3, value);
        } else {
          self.setEdge(v3, w3);
        }
        return w3;
      });
      return this;
    };
    Graph5.prototype.setEdge = function() {
      var v3, w3, name, value;
      var valueSpecified = false;
      var arg0 = arguments[0];
      if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
        v3 = arg0.v;
        w3 = arg0.w;
        name = arg0.name;
        if (arguments.length === 2) {
          value = arguments[1];
          valueSpecified = true;
        }
      } else {
        v3 = arg0;
        w3 = arguments[1];
        name = arguments[3];
        if (arguments.length > 2) {
          value = arguments[2];
          valueSpecified = true;
        }
      }
      v3 = "" + v3;
      w3 = "" + w3;
      if (!_2.isUndefined(name)) {
        name = "" + name;
      }
      var e2 = edgeArgsToId(this._isDirected, v3, w3, name);
      if (_2.has(this._edgeLabels, e2)) {
        if (valueSpecified) {
          this._edgeLabels[e2] = value;
        }
        return this;
      }
      if (!_2.isUndefined(name) && !this._isMultigraph) {
        throw new Error("Cannot set a named edge when isMultigraph = false");
      }
      this.setNode(v3);
      this.setNode(w3);
      this._edgeLabels[e2] = valueSpecified ? value : this._defaultEdgeLabelFn(v3, w3, name);
      var edgeObj = edgeArgsToObj(this._isDirected, v3, w3, name);
      v3 = edgeObj.v;
      w3 = edgeObj.w;
      Object.freeze(edgeObj);
      this._edgeObjs[e2] = edgeObj;
      incrementOrInitEntry(this._preds[w3], v3);
      incrementOrInitEntry(this._sucs[v3], w3);
      this._in[w3][e2] = edgeObj;
      this._out[v3][e2] = edgeObj;
      this._edgeCount++;
      return this;
    };
    Graph5.prototype.edge = function(v3, w3, name) {
      var e2 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v3, w3, name);
      return this._edgeLabels[e2];
    };
    Graph5.prototype.hasEdge = function(v3, w3, name) {
      var e2 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v3, w3, name);
      return _2.has(this._edgeLabels, e2);
    };
    Graph5.prototype.removeEdge = function(v3, w3, name) {
      var e2 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v3, w3, name);
      var edge = this._edgeObjs[e2];
      if (edge) {
        v3 = edge.v;
        w3 = edge.w;
        delete this._edgeLabels[e2];
        delete this._edgeObjs[e2];
        decrementOrRemoveEntry(this._preds[w3], v3);
        decrementOrRemoveEntry(this._sucs[v3], w3);
        delete this._in[w3][e2];
        delete this._out[v3][e2];
        this._edgeCount--;
      }
      return this;
    };
    Graph5.prototype.inEdges = function(v3, u3) {
      var inV = this._in[v3];
      if (inV) {
        var edges = _2.values(inV);
        if (!u3) {
          return edges;
        }
        return _2.filter(edges, function(edge) {
          return edge.v === u3;
        });
      }
    };
    Graph5.prototype.outEdges = function(v3, w3) {
      var outV = this._out[v3];
      if (outV) {
        var edges = _2.values(outV);
        if (!w3) {
          return edges;
        }
        return _2.filter(edges, function(edge) {
          return edge.w === w3;
        });
      }
    };
    Graph5.prototype.nodeEdges = function(v3, w3) {
      var inEdges = this.inEdges(v3, w3);
      if (inEdges) {
        return inEdges.concat(this.outEdges(v3, w3));
      }
    };
    function incrementOrInitEntry(map, k2) {
      if (map[k2]) {
        map[k2]++;
      } else {
        map[k2] = 1;
      }
    }
    function decrementOrRemoveEntry(map, k2) {
      if (!--map[k2]) {
        delete map[k2];
      }
    }
    function edgeArgsToId(isDirected, v_, w_, name) {
      var v3 = "" + v_;
      var w3 = "" + w_;
      if (!isDirected && v3 > w3) {
        var tmp = v3;
        v3 = w3;
        w3 = tmp;
      }
      return v3 + EDGE_KEY_DELIM + w3 + EDGE_KEY_DELIM + (_2.isUndefined(name) ? DEFAULT_EDGE_NAME : name);
    }
    function edgeArgsToObj(isDirected, v_, w_, name) {
      var v3 = "" + v_;
      var w3 = "" + w_;
      if (!isDirected && v3 > w3) {
        var tmp = v3;
        v3 = w3;
        w3 = tmp;
      }
      var edgeObj = { v: v3, w: w3 };
      if (name) {
        edgeObj.name = name;
      }
      return edgeObj;
    }
    function edgeObjToId(isDirected, edgeObj) {
      return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
    }
  }
});

// node_modules/graphlib/lib/version.js
var require_version = __commonJS({
  "node_modules/graphlib/lib/version.js"(exports, module) {
    module.exports = "2.1.8";
  }
});

// node_modules/graphlib/lib/index.js
var require_lib = __commonJS({
  "node_modules/graphlib/lib/index.js"(exports, module) {
    module.exports = {
      Graph: require_graph(),
      version: require_version()
    };
  }
});

// node_modules/graphlib/lib/json.js
var require_json = __commonJS({
  "node_modules/graphlib/lib/json.js"(exports, module) {
    var _2 = require_lodash2();
    var Graph5 = require_graph();
    module.exports = {
      write,
      read
    };
    function write(g3) {
      var json = {
        options: {
          directed: g3.isDirected(),
          multigraph: g3.isMultigraph(),
          compound: g3.isCompound()
        },
        nodes: writeNodes(g3),
        edges: writeEdges(g3)
      };
      if (!_2.isUndefined(g3.graph())) {
        json.value = _2.clone(g3.graph());
      }
      return json;
    }
    function writeNodes(g3) {
      return _2.map(g3.nodes(), function(v3) {
        var nodeValue = g3.node(v3);
        var parent = g3.parent(v3);
        var node = { v: v3 };
        if (!_2.isUndefined(nodeValue)) {
          node.value = nodeValue;
        }
        if (!_2.isUndefined(parent)) {
          node.parent = parent;
        }
        return node;
      });
    }
    function writeEdges(g3) {
      return _2.map(g3.edges(), function(e2) {
        var edgeValue = g3.edge(e2);
        var edge = { v: e2.v, w: e2.w };
        if (!_2.isUndefined(e2.name)) {
          edge.name = e2.name;
        }
        if (!_2.isUndefined(edgeValue)) {
          edge.value = edgeValue;
        }
        return edge;
      });
    }
    function read(json) {
      var g3 = new Graph5(json.options).setGraph(json.value);
      _2.each(json.nodes, function(entry) {
        g3.setNode(entry.v, entry.value);
        if (entry.parent) {
          g3.setParent(entry.v, entry.parent);
        }
      });
      _2.each(json.edges, function(entry) {
        g3.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
      });
      return g3;
    }
  }
});

// node_modules/graphlib/lib/alg/components.js
var require_components = __commonJS({
  "node_modules/graphlib/lib/alg/components.js"(exports, module) {
    var _2 = require_lodash2();
    module.exports = components;
    function components(g3) {
      var visited = {};
      var cmpts = [];
      var cmpt;
      function dfs4(v3) {
        if (_2.has(visited, v3)) return;
        visited[v3] = true;
        cmpt.push(v3);
        _2.each(g3.successors(v3), dfs4);
        _2.each(g3.predecessors(v3), dfs4);
      }
      _2.each(g3.nodes(), function(v3) {
        cmpt = [];
        dfs4(v3);
        if (cmpt.length) {
          cmpts.push(cmpt);
        }
      });
      return cmpts;
    }
  }
});

// node_modules/graphlib/lib/data/priority-queue.js
var require_priority_queue = __commonJS({
  "node_modules/graphlib/lib/data/priority-queue.js"(exports, module) {
    var _2 = require_lodash2();
    module.exports = PriorityQueue;
    function PriorityQueue() {
      this._arr = [];
      this._keyIndices = {};
    }
    PriorityQueue.prototype.size = function() {
      return this._arr.length;
    };
    PriorityQueue.prototype.keys = function() {
      return this._arr.map(function(x4) {
        return x4.key;
      });
    };
    PriorityQueue.prototype.has = function(key) {
      return _2.has(this._keyIndices, key);
    };
    PriorityQueue.prototype.priority = function(key) {
      var index = this._keyIndices[key];
      if (index !== void 0) {
        return this._arr[index].priority;
      }
    };
    PriorityQueue.prototype.min = function() {
      if (this.size() === 0) {
        throw new Error("Queue underflow");
      }
      return this._arr[0].key;
    };
    PriorityQueue.prototype.add = function(key, priority) {
      var keyIndices = this._keyIndices;
      key = String(key);
      if (!_2.has(keyIndices, key)) {
        var arr = this._arr;
        var index = arr.length;
        keyIndices[key] = index;
        arr.push({ key, priority });
        this._decrease(index);
        return true;
      }
      return false;
    };
    PriorityQueue.prototype.removeMin = function() {
      this._swap(0, this._arr.length - 1);
      var min2 = this._arr.pop();
      delete this._keyIndices[min2.key];
      this._heapify(0);
      return min2.key;
    };
    PriorityQueue.prototype.decrease = function(key, priority) {
      var index = this._keyIndices[key];
      if (priority > this._arr[index].priority) {
        throw new Error("New priority is greater than current priority. Key: " + key + " Old: " + this._arr[index].priority + " New: " + priority);
      }
      this._arr[index].priority = priority;
      this._decrease(index);
    };
    PriorityQueue.prototype._heapify = function(i2) {
      var arr = this._arr;
      var l3 = 2 * i2;
      var r3 = l3 + 1;
      var largest = i2;
      if (l3 < arr.length) {
        largest = arr[l3].priority < arr[largest].priority ? l3 : largest;
        if (r3 < arr.length) {
          largest = arr[r3].priority < arr[largest].priority ? r3 : largest;
        }
        if (largest !== i2) {
          this._swap(i2, largest);
          this._heapify(largest);
        }
      }
    };
    PriorityQueue.prototype._decrease = function(index) {
      var arr = this._arr;
      var priority = arr[index].priority;
      var parent;
      while (index !== 0) {
        parent = index >> 1;
        if (arr[parent].priority < priority) {
          break;
        }
        this._swap(index, parent);
        index = parent;
      }
    };
    PriorityQueue.prototype._swap = function(i2, j2) {
      var arr = this._arr;
      var keyIndices = this._keyIndices;
      var origArrI = arr[i2];
      var origArrJ = arr[j2];
      arr[i2] = origArrJ;
      arr[j2] = origArrI;
      keyIndices[origArrJ.key] = i2;
      keyIndices[origArrI.key] = j2;
    };
  }
});

// node_modules/graphlib/lib/alg/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/graphlib/lib/alg/dijkstra.js"(exports, module) {
    var _2 = require_lodash2();
    var PriorityQueue = require_priority_queue();
    module.exports = dijkstra3;
    var DEFAULT_WEIGHT_FUNC = _2.constant(1);
    function dijkstra3(g3, source, weightFn, edgeFn) {
      return runDijkstra(
        g3,
        String(source),
        weightFn || DEFAULT_WEIGHT_FUNC,
        edgeFn || function(v3) {
          return g3.outEdges(v3);
        }
      );
    }
    function runDijkstra(g3, source, weightFn, edgeFn) {
      var results = {};
      var pq = new PriorityQueue();
      var v3, vEntry;
      var updateNeighbors = function(edge) {
        var w3 = edge.v !== v3 ? edge.v : edge.w;
        var wEntry = results[w3];
        var weight = weightFn(edge);
        var distance4 = vEntry.distance + weight;
        if (weight < 0) {
          throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
        }
        if (distance4 < wEntry.distance) {
          wEntry.distance = distance4;
          wEntry.predecessor = v3;
          pq.decrease(w3, distance4);
        }
      };
      g3.nodes().forEach(function(v4) {
        var distance4 = v4 === source ? 0 : Number.POSITIVE_INFINITY;
        results[v4] = { distance: distance4 };
        pq.add(v4, distance4);
      });
      while (pq.size() > 0) {
        v3 = pq.removeMin();
        vEntry = results[v3];
        if (vEntry.distance === Number.POSITIVE_INFINITY) {
          break;
        }
        edgeFn(v3).forEach(updateNeighbors);
      }
      return results;
    }
  }
});

// node_modules/graphlib/lib/alg/dijkstra-all.js
var require_dijkstra_all = __commonJS({
  "node_modules/graphlib/lib/alg/dijkstra-all.js"(exports, module) {
    var dijkstra3 = require_dijkstra();
    var _2 = require_lodash2();
    module.exports = dijkstraAll;
    function dijkstraAll(g3, weightFunc, edgeFunc) {
      return _2.transform(g3.nodes(), function(acc, v3) {
        acc[v3] = dijkstra3(g3, v3, weightFunc, edgeFunc);
      }, {});
    }
  }
});

// node_modules/graphlib/lib/alg/tarjan.js
var require_tarjan = __commonJS({
  "node_modules/graphlib/lib/alg/tarjan.js"(exports, module) {
    var _2 = require_lodash2();
    module.exports = tarjan;
    function tarjan(g3) {
      var index = 0;
      var stack = [];
      var visited = {};
      var results = [];
      function dfs4(v3) {
        var entry = visited[v3] = {
          onStack: true,
          lowlink: index,
          index: index++
        };
        stack.push(v3);
        g3.successors(v3).forEach(function(w4) {
          if (!_2.has(visited, w4)) {
            dfs4(w4);
            entry.lowlink = Math.min(entry.lowlink, visited[w4].lowlink);
          } else if (visited[w4].onStack) {
            entry.lowlink = Math.min(entry.lowlink, visited[w4].index);
          }
        });
        if (entry.lowlink === entry.index) {
          var cmpt = [];
          var w3;
          do {
            w3 = stack.pop();
            visited[w3].onStack = false;
            cmpt.push(w3);
          } while (v3 !== w3);
          results.push(cmpt);
        }
      }
      g3.nodes().forEach(function(v3) {
        if (!_2.has(visited, v3)) {
          dfs4(v3);
        }
      });
      return results;
    }
  }
});

// node_modules/graphlib/lib/alg/find-cycles.js
var require_find_cycles = __commonJS({
  "node_modules/graphlib/lib/alg/find-cycles.js"(exports, module) {
    var _2 = require_lodash2();
    var tarjan = require_tarjan();
    module.exports = findCycles;
    function findCycles(g3) {
      return _2.filter(tarjan(g3), function(cmpt) {
        return cmpt.length > 1 || cmpt.length === 1 && g3.hasEdge(cmpt[0], cmpt[0]);
      });
    }
  }
});

// node_modules/graphlib/lib/alg/floyd-warshall.js
var require_floyd_warshall = __commonJS({
  "node_modules/graphlib/lib/alg/floyd-warshall.js"(exports, module) {
    var _2 = require_lodash2();
    module.exports = floydWarshall2;
    var DEFAULT_WEIGHT_FUNC = _2.constant(1);
    function floydWarshall2(g3, weightFn, edgeFn) {
      return runFloydWarshall(
        g3,
        weightFn || DEFAULT_WEIGHT_FUNC,
        edgeFn || function(v3) {
          return g3.outEdges(v3);
        }
      );
    }
    function runFloydWarshall(g3, weightFn, edgeFn) {
      var results = {};
      var nodes = g3.nodes();
      nodes.forEach(function(v3) {
        results[v3] = {};
        results[v3][v3] = { distance: 0 };
        nodes.forEach(function(w3) {
          if (v3 !== w3) {
            results[v3][w3] = { distance: Number.POSITIVE_INFINITY };
          }
        });
        edgeFn(v3).forEach(function(edge) {
          var w3 = edge.v === v3 ? edge.w : edge.v;
          var d3 = weightFn(edge);
          results[v3][w3] = { distance: d3, predecessor: v3 };
        });
      });
      nodes.forEach(function(k2) {
        var rowK = results[k2];
        nodes.forEach(function(i2) {
          var rowI = results[i2];
          nodes.forEach(function(j2) {
            var ik = rowI[k2];
            var kj = rowK[j2];
            var ij = rowI[j2];
            var altDistance = ik.distance + kj.distance;
            if (altDistance < ij.distance) {
              ij.distance = altDistance;
              ij.predecessor = kj.predecessor;
            }
          });
        });
      });
      return results;
    }
  }
});

// node_modules/graphlib/lib/alg/topsort.js
var require_topsort = __commonJS({
  "node_modules/graphlib/lib/alg/topsort.js"(exports, module) {
    var _2 = require_lodash2();
    module.exports = topsort;
    topsort.CycleException = CycleException;
    function topsort(g3) {
      var visited = {};
      var stack = {};
      var results = [];
      function visit(node) {
        if (_2.has(stack, node)) {
          throw new CycleException();
        }
        if (!_2.has(visited, node)) {
          stack[node] = true;
          visited[node] = true;
          _2.each(g3.predecessors(node), visit);
          delete stack[node];
          results.push(node);
        }
      }
      _2.each(g3.sinks(), visit);
      if (_2.size(visited) !== g3.nodeCount()) {
        throw new CycleException();
      }
      return results;
    }
    function CycleException() {
    }
    CycleException.prototype = new Error();
  }
});

// node_modules/graphlib/lib/alg/is-acyclic.js
var require_is_acyclic = __commonJS({
  "node_modules/graphlib/lib/alg/is-acyclic.js"(exports, module) {
    var topsort = require_topsort();
    module.exports = isAcyclic;
    function isAcyclic(g3) {
      try {
        topsort(g3);
      } catch (e2) {
        if (e2 instanceof topsort.CycleException) {
          return false;
        }
        throw e2;
      }
      return true;
    }
  }
});

// node_modules/graphlib/lib/alg/dfs.js
var require_dfs = __commonJS({
  "node_modules/graphlib/lib/alg/dfs.js"(exports, module) {
    var _2 = require_lodash2();
    module.exports = dfs4;
    function dfs4(g3, vs, order2) {
      if (!_2.isArray(vs)) {
        vs = [vs];
      }
      var navigation = (g3.isDirected() ? g3.successors : g3.neighbors).bind(g3);
      var acc = [];
      var visited = {};
      _2.each(vs, function(v3) {
        if (!g3.hasNode(v3)) {
          throw new Error("Graph does not have node: " + v3);
        }
        doDfs(g3, v3, order2 === "post", visited, navigation, acc);
      });
      return acc;
    }
    function doDfs(g3, v3, postorder, visited, navigation, acc) {
      if (!_2.has(visited, v3)) {
        visited[v3] = true;
        if (!postorder) {
          acc.push(v3);
        }
        _2.each(navigation(v3), function(w3) {
          doDfs(g3, w3, postorder, visited, navigation, acc);
        });
        if (postorder) {
          acc.push(v3);
        }
      }
    }
  }
});

// node_modules/graphlib/lib/alg/postorder.js
var require_postorder = __commonJS({
  "node_modules/graphlib/lib/alg/postorder.js"(exports, module) {
    var dfs4 = require_dfs();
    module.exports = postorder;
    function postorder(g3, vs) {
      return dfs4(g3, vs, "post");
    }
  }
});

// node_modules/graphlib/lib/alg/preorder.js
var require_preorder = __commonJS({
  "node_modules/graphlib/lib/alg/preorder.js"(exports, module) {
    var dfs4 = require_dfs();
    module.exports = preorder;
    function preorder(g3, vs) {
      return dfs4(g3, vs, "pre");
    }
  }
});

// node_modules/graphlib/lib/alg/prim.js
var require_prim = __commonJS({
  "node_modules/graphlib/lib/alg/prim.js"(exports, module) {
    var _2 = require_lodash2();
    var Graph5 = require_graph();
    var PriorityQueue = require_priority_queue();
    module.exports = prim;
    function prim(g3, weightFunc) {
      var result = new Graph5();
      var parents = {};
      var pq = new PriorityQueue();
      var v3;
      function updateNeighbors(edge) {
        var w3 = edge.v === v3 ? edge.w : edge.v;
        var pri = pq.priority(w3);
        if (pri !== void 0) {
          var edgeWeight = weightFunc(edge);
          if (edgeWeight < pri) {
            parents[w3] = v3;
            pq.decrease(w3, edgeWeight);
          }
        }
      }
      if (g3.nodeCount() === 0) {
        return result;
      }
      _2.each(g3.nodes(), function(v4) {
        pq.add(v4, Number.POSITIVE_INFINITY);
        result.setNode(v4);
      });
      pq.decrease(g3.nodes()[0], 0);
      var init = false;
      while (pq.size() > 0) {
        v3 = pq.removeMin();
        if (_2.has(parents, v3)) {
          result.setEdge(v3, parents[v3]);
        } else if (init) {
          throw new Error("Input graph is not connected: " + g3);
        } else {
          init = true;
        }
        g3.nodeEdges(v3).forEach(updateNeighbors);
      }
      return result;
    }
  }
});

// node_modules/graphlib/lib/alg/index.js
var require_alg = __commonJS({
  "node_modules/graphlib/lib/alg/index.js"(exports, module) {
    module.exports = {
      components: require_components(),
      dijkstra: require_dijkstra(),
      dijkstraAll: require_dijkstra_all(),
      findCycles: require_find_cycles(),
      floydWarshall: require_floyd_warshall(),
      isAcyclic: require_is_acyclic(),
      postorder: require_postorder(),
      preorder: require_preorder(),
      prim: require_prim(),
      tarjan: require_tarjan(),
      topsort: require_topsort()
    };
  }
});

// node_modules/graphlib/index.js
var require_graphlib = __commonJS({
  "node_modules/graphlib/index.js"(exports, module) {
    var lib = require_lib();
    module.exports = {
      Graph: lib.Graph,
      json: require_json(),
      alg: require_alg(),
      version: lib.version
    };
  }
});

// node_modules/dagre/lib/graphlib.js
var require_graphlib2 = __commonJS({
  "node_modules/dagre/lib/graphlib.js"(exports, module) {
    var graphlib2;
    if (typeof __require === "function") {
      try {
        graphlib2 = require_graphlib();
      } catch (e2) {
      }
    }
    if (!graphlib2) {
      graphlib2 = window.graphlib;
    }
    module.exports = graphlib2;
  }
});

// node_modules/lodash/defaults.js
var require_defaults = __commonJS({
  "node_modules/lodash/defaults.js"(exports, module) {
    var baseRest = require_baseRest();
    var eq = require_eq();
    var isIterateeCall = require_isIterateeCall();
    var keysIn = require_keysIn();
    var objectProto2 = Object.prototype;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    var defaults = baseRest(function(object, sources) {
      object = Object(object);
      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }
      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;
        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];
          if (value === void 0 || eq(value, objectProto2[key]) && !hasOwnProperty.call(object, key)) {
            object[key] = source[key];
          }
        }
      }
      return object;
    });
    module.exports = defaults;
  }
});

// node_modules/lodash/_createFind.js
var require_createFind = __commonJS({
  "node_modules/lodash/_createFind.js"(exports, module) {
    var baseIteratee = require_baseIteratee();
    var isArrayLike = require_isArrayLike();
    var keys = require_keys();
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = baseIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) {
            return iteratee(iterable[key], key, iterable);
          };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;
      };
    }
    module.exports = createFind;
  }
});

// node_modules/lodash/toFinite.js
var require_toFinite = __commonJS({
  "node_modules/lodash/toFinite.js"(exports, module) {
    var toNumber = require_toNumber();
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    module.exports = toFinite;
  }
});

// node_modules/lodash/toInteger.js
var require_toInteger = __commonJS({
  "node_modules/lodash/toInteger.js"(exports, module) {
    var toFinite = require_toFinite();
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    module.exports = toInteger;
  }
});

// node_modules/lodash/findIndex.js
var require_findIndex = __commonJS({
  "node_modules/lodash/findIndex.js"(exports, module) {
    var baseFindIndex = require_baseFindIndex();
    var baseIteratee = require_baseIteratee();
    var toInteger = require_toInteger();
    var nativeMax = Math.max;
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, baseIteratee(predicate, 3), index);
    }
    module.exports = findIndex;
  }
});

// node_modules/lodash/find.js
var require_find = __commonJS({
  "node_modules/lodash/find.js"(exports, module) {
    var createFind = require_createFind();
    var findIndex = require_findIndex();
    var find = createFind(findIndex);
    module.exports = find;
  }
});

// node_modules/lodash/flatten.js
var require_flatten = __commonJS({
  "node_modules/lodash/flatten.js"(exports, module) {
    var baseFlatten = require_baseFlatten();
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }
    module.exports = flatten;
  }
});

// node_modules/lodash/forIn.js
var require_forIn = __commonJS({
  "node_modules/lodash/forIn.js"(exports, module) {
    var baseFor = require_baseFor();
    var castFunction = require_castFunction();
    var keysIn = require_keysIn();
    function forIn(object, iteratee) {
      return object == null ? object : baseFor(object, castFunction(iteratee), keysIn);
    }
    module.exports = forIn;
  }
});

// node_modules/lodash/last.js
var require_last = __commonJS({
  "node_modules/lodash/last.js"(exports, module) {
    function last2(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : void 0;
    }
    module.exports = last2;
  }
});

// node_modules/lodash/mapValues.js
var require_mapValues = __commonJS({
  "node_modules/lodash/mapValues.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var baseForOwn = require_baseForOwn();
    var baseIteratee = require_baseIteratee();
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = baseIteratee(iteratee, 3);
      baseForOwn(object, function(value, key, object2) {
        baseAssignValue(result, key, iteratee(value, key, object2));
      });
      return result;
    }
    module.exports = mapValues;
  }
});

// node_modules/lodash/_baseExtremum.js
var require_baseExtremum = __commonJS({
  "node_modules/lodash/_baseExtremum.js"(exports, module) {
    var isSymbol = require_isSymbol();
    function baseExtremum(array, iteratee, comparator) {
      var index = -1, length = array.length;
      while (++index < length) {
        var value = array[index], current2 = iteratee(value);
        if (current2 != null && (computed === void 0 ? current2 === current2 && !isSymbol(current2) : comparator(current2, computed))) {
          var computed = current2, result = value;
        }
      }
      return result;
    }
    module.exports = baseExtremum;
  }
});

// node_modules/lodash/_baseGt.js
var require_baseGt = __commonJS({
  "node_modules/lodash/_baseGt.js"(exports, module) {
    function baseGt(value, other) {
      return value > other;
    }
    module.exports = baseGt;
  }
});

// node_modules/lodash/max.js
var require_max = __commonJS({
  "node_modules/lodash/max.js"(exports, module) {
    var baseExtremum = require_baseExtremum();
    var baseGt = require_baseGt();
    var identity = require_identity();
    function max2(array) {
      return array && array.length ? baseExtremum(array, identity, baseGt) : void 0;
    }
    module.exports = max2;
  }
});

// node_modules/lodash/_baseLt.js
var require_baseLt = __commonJS({
  "node_modules/lodash/_baseLt.js"(exports, module) {
    function baseLt(value, other) {
      return value < other;
    }
    module.exports = baseLt;
  }
});

// node_modules/lodash/min.js
var require_min = __commonJS({
  "node_modules/lodash/min.js"(exports, module) {
    var baseExtremum = require_baseExtremum();
    var baseLt = require_baseLt();
    var identity = require_identity();
    function min2(array) {
      return array && array.length ? baseExtremum(array, identity, baseLt) : void 0;
    }
    module.exports = min2;
  }
});

// node_modules/lodash/minBy.js
var require_minBy = __commonJS({
  "node_modules/lodash/minBy.js"(exports, module) {
    var baseExtremum = require_baseExtremum();
    var baseIteratee = require_baseIteratee();
    var baseLt = require_baseLt();
    function minBy2(array, iteratee) {
      return array && array.length ? baseExtremum(array, baseIteratee(iteratee, 2), baseLt) : void 0;
    }
    module.exports = minBy2;
  }
});

// node_modules/lodash/_baseSet.js
var require_baseSet = __commonJS({
  "node_modules/lodash/_baseSet.js"(exports, module) {
    var assignValue = require_assignValue();
    var castPath = require_castPath();
    var isIndex = require_isIndex();
    var isObject2 = require_isObject();
    var toKey = require_toKey();
    function baseSet(object, path, value, customizer) {
      if (!isObject2(object)) {
        return object;
      }
      path = castPath(path, object);
      var index = -1, length = path.length, lastIndex = length - 1, nested = object;
      while (nested != null && ++index < length) {
        var key = toKey(path[index]), newValue = value;
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
          return object;
        }
        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }
    module.exports = baseSet;
  }
});

// node_modules/lodash/_basePickBy.js
var require_basePickBy = __commonJS({
  "node_modules/lodash/_basePickBy.js"(exports, module) {
    var baseGet = require_baseGet();
    var baseSet = require_baseSet();
    var castPath = require_castPath();
    function basePickBy(object, paths, predicate) {
      var index = -1, length = paths.length, result = {};
      while (++index < length) {
        var path = paths[index], value = baseGet(object, path);
        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }
    module.exports = basePickBy;
  }
});

// node_modules/lodash/_basePick.js
var require_basePick = __commonJS({
  "node_modules/lodash/_basePick.js"(exports, module) {
    var basePickBy = require_basePickBy();
    var hasIn = require_hasIn();
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }
    module.exports = basePick;
  }
});

// node_modules/lodash/_flatRest.js
var require_flatRest = __commonJS({
  "node_modules/lodash/_flatRest.js"(exports, module) {
    var flatten = require_flatten();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function flatRest(func) {
      return setToString(overRest(func, void 0, flatten), func + "");
    }
    module.exports = flatRest;
  }
});

// node_modules/lodash/pick.js
var require_pick = __commonJS({
  "node_modules/lodash/pick.js"(exports, module) {
    var basePick = require_basePick();
    var flatRest = require_flatRest();
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });
    module.exports = pick;
  }
});

// node_modules/lodash/_baseRange.js
var require_baseRange = __commonJS({
  "node_modules/lodash/_baseRange.js"(exports, module) {
    var nativeCeil = Math.ceil;
    var nativeMax = Math.max;
    function baseRange(start, end, step, fromRight) {
      var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }
    module.exports = baseRange;
  }
});

// node_modules/lodash/_createRange.js
var require_createRange = __commonJS({
  "node_modules/lodash/_createRange.js"(exports, module) {
    var baseRange = require_baseRange();
    var isIterateeCall = require_isIterateeCall();
    var toFinite = require_toFinite();
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
          end = step = void 0;
        }
        start = toFinite(start);
        if (end === void 0) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === void 0 ? start < end ? 1 : -1 : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }
    module.exports = createRange;
  }
});

// node_modules/lodash/range.js
var require_range = __commonJS({
  "node_modules/lodash/range.js"(exports, module) {
    var createRange = require_createRange();
    var range = createRange();
    module.exports = range;
  }
});

// node_modules/lodash/_baseSortBy.js
var require_baseSortBy = __commonJS({
  "node_modules/lodash/_baseSortBy.js"(exports, module) {
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    module.exports = baseSortBy;
  }
});

// node_modules/lodash/_compareAscending.js
var require_compareAscending = __commonJS({
  "node_modules/lodash/_compareAscending.js"(exports, module) {
    var isSymbol = require_isSymbol();
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    module.exports = compareAscending;
  }
});

// node_modules/lodash/_compareMultiple.js
var require_compareMultiple = __commonJS({
  "node_modules/lodash/_compareMultiple.js"(exports, module) {
    var compareAscending = require_compareAscending();
    function compareMultiple(object, other, orders) {
      var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order2 = orders[index];
          return result * (order2 == "desc" ? -1 : 1);
        }
      }
      return object.index - other.index;
    }
    module.exports = compareMultiple;
  }
});

// node_modules/lodash/_baseOrderBy.js
var require_baseOrderBy = __commonJS({
  "node_modules/lodash/_baseOrderBy.js"(exports, module) {
    var arrayMap = require_arrayMap();
    var baseGet = require_baseGet();
    var baseIteratee = require_baseIteratee();
    var baseMap = require_baseMap();
    var baseSortBy = require_baseSortBy();
    var baseUnary = require_baseUnary();
    var compareMultiple = require_compareMultiple();
    var identity = require_identity();
    var isArray3 = require_isArray();
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray3(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            };
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }
      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
      var result = baseMap(collection, function(value, key, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { "criteria": criteria, "index": ++index, "value": value };
      });
      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }
    module.exports = baseOrderBy;
  }
});

// node_modules/lodash/sortBy.js
var require_sortBy = __commonJS({
  "node_modules/lodash/sortBy.js"(exports, module) {
    var baseFlatten = require_baseFlatten();
    var baseOrderBy = require_baseOrderBy();
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });
    module.exports = sortBy;
  }
});

// node_modules/lodash/uniqueId.js
var require_uniqueId = __commonJS({
  "node_modules/lodash/uniqueId.js"(exports, module) {
    var toString4 = require_toString();
    var idCounter = 0;
    function uniqueId2(prefix) {
      var id = ++idCounter;
      return toString4(prefix) + id;
    }
    module.exports = uniqueId2;
  }
});

// node_modules/lodash/_baseZipObject.js
var require_baseZipObject = __commonJS({
  "node_modules/lodash/_baseZipObject.js"(exports, module) {
    function baseZipObject(props, values3, assignFunc) {
      var index = -1, length = props.length, valsLength = values3.length, result = {};
      while (++index < length) {
        var value = index < valsLength ? values3[index] : void 0;
        assignFunc(result, props[index], value);
      }
      return result;
    }
    module.exports = baseZipObject;
  }
});

// node_modules/lodash/zipObject.js
var require_zipObject = __commonJS({
  "node_modules/lodash/zipObject.js"(exports, module) {
    var assignValue = require_assignValue();
    var baseZipObject = require_baseZipObject();
    function zipObject2(props, values3) {
      return baseZipObject(props || [], values3 || [], assignValue);
    }
    module.exports = zipObject2;
  }
});

// node_modules/dagre/lib/lodash.js
var require_lodash3 = __commonJS({
  "node_modules/dagre/lib/lodash.js"(exports, module) {
    var lodash;
    if (typeof __require === "function") {
      try {
        lodash = {
          cloneDeep: require_cloneDeep(),
          constant: require_constant(),
          defaults: require_defaults(),
          each: require_each(),
          filter: require_filter(),
          find: require_find(),
          flatten: require_flatten(),
          forEach: require_forEach(),
          forIn: require_forIn(),
          has: require_has(),
          isUndefined: require_isUndefined(),
          last: require_last(),
          map: require_map(),
          mapValues: require_mapValues(),
          max: require_max(),
          merge: require_merge(),
          min: require_min(),
          minBy: require_minBy(),
          now: require_now(),
          pick: require_pick(),
          range: require_range(),
          reduce: require_reduce(),
          sortBy: require_sortBy(),
          uniqueId: require_uniqueId(),
          values: require_values(),
          zipObject: require_zipObject()
        };
      } catch (e2) {
      }
    }
    if (!lodash) {
      lodash = window._;
    }
    module.exports = lodash;
  }
});

// node_modules/dagre/lib/data/list.js
var require_list = __commonJS({
  "node_modules/dagre/lib/data/list.js"(exports, module) {
    module.exports = List3;
    function List3() {
      var sentinel = {};
      sentinel._next = sentinel._prev = sentinel;
      this._sentinel = sentinel;
    }
    List3.prototype.dequeue = function() {
      var sentinel = this._sentinel;
      var entry = sentinel._prev;
      if (entry !== sentinel) {
        unlink2(entry);
        return entry;
      }
    };
    List3.prototype.enqueue = function(entry) {
      var sentinel = this._sentinel;
      if (entry._prev && entry._next) {
        unlink2(entry);
      }
      entry._next = sentinel._next;
      sentinel._next._prev = entry;
      sentinel._next = entry;
      entry._prev = sentinel;
    };
    List3.prototype.toString = function() {
      var strs = [];
      var sentinel = this._sentinel;
      var curr = sentinel._prev;
      while (curr !== sentinel) {
        strs.push(JSON.stringify(curr, filterOutLinks2));
        curr = curr._prev;
      }
      return "[" + strs.join(", ") + "]";
    };
    function unlink2(entry) {
      entry._prev._next = entry._next;
      entry._next._prev = entry._prev;
      delete entry._next;
      delete entry._prev;
    }
    function filterOutLinks2(k2, v3) {
      if (k2 !== "_next" && k2 !== "_prev") {
        return v3;
      }
    }
  }
});

// node_modules/dagre/lib/greedy-fas.js
var require_greedy_fas = __commonJS({
  "node_modules/dagre/lib/greedy-fas.js"(exports, module) {
    var _2 = require_lodash3();
    var Graph5 = require_graphlib2().Graph;
    var List3 = require_list();
    module.exports = greedyFAS2;
    var DEFAULT_WEIGHT_FN2 = _2.constant(1);
    function greedyFAS2(g3, weightFn) {
      if (g3.nodeCount() <= 1) {
        return [];
      }
      var state = buildState2(g3, weightFn || DEFAULT_WEIGHT_FN2);
      var results = doGreedyFAS2(state.graph, state.buckets, state.zeroIdx);
      return _2.flatten(_2.map(results, function(e2) {
        return g3.outEdges(e2.v, e2.w);
      }), true);
    }
    function doGreedyFAS2(g3, buckets, zeroIdx) {
      var results = [];
      var sources = buckets[buckets.length - 1];
      var sinks = buckets[0];
      var entry;
      while (g3.nodeCount()) {
        while (entry = sinks.dequeue()) {
          removeNode2(g3, buckets, zeroIdx, entry);
        }
        while (entry = sources.dequeue()) {
          removeNode2(g3, buckets, zeroIdx, entry);
        }
        if (g3.nodeCount()) {
          for (var i2 = buckets.length - 2; i2 > 0; --i2) {
            entry = buckets[i2].dequeue();
            if (entry) {
              results = results.concat(removeNode2(g3, buckets, zeroIdx, entry, true));
              break;
            }
          }
        }
      }
      return results;
    }
    function removeNode2(g3, buckets, zeroIdx, entry, collectPredecessors) {
      var results = collectPredecessors ? [] : void 0;
      _2.forEach(g3.inEdges(entry.v), function(edge) {
        var weight = g3.edge(edge);
        var uEntry = g3.node(edge.v);
        if (collectPredecessors) {
          results.push({ v: edge.v, w: edge.w });
        }
        uEntry.out -= weight;
        assignBucket2(buckets, zeroIdx, uEntry);
      });
      _2.forEach(g3.outEdges(entry.v), function(edge) {
        var weight = g3.edge(edge);
        var w3 = edge.w;
        var wEntry = g3.node(w3);
        wEntry["in"] -= weight;
        assignBucket2(buckets, zeroIdx, wEntry);
      });
      g3.removeNode(entry.v);
      return results;
    }
    function buildState2(g3, weightFn) {
      var fasGraph = new Graph5();
      var maxIn = 0;
      var maxOut = 0;
      _2.forEach(g3.nodes(), function(v3) {
        fasGraph.setNode(v3, { v: v3, "in": 0, out: 0 });
      });
      _2.forEach(g3.edges(), function(e2) {
        var prevWeight = fasGraph.edge(e2.v, e2.w) || 0;
        var weight = weightFn(e2);
        var edgeWeight = prevWeight + weight;
        fasGraph.setEdge(e2.v, e2.w, edgeWeight);
        maxOut = Math.max(maxOut, fasGraph.node(e2.v).out += weight);
        maxIn = Math.max(maxIn, fasGraph.node(e2.w)["in"] += weight);
      });
      var buckets = _2.range(maxOut + maxIn + 3).map(function() {
        return new List3();
      });
      var zeroIdx = maxIn + 1;
      _2.forEach(fasGraph.nodes(), function(v3) {
        assignBucket2(buckets, zeroIdx, fasGraph.node(v3));
      });
      return { graph: fasGraph, buckets, zeroIdx };
    }
    function assignBucket2(buckets, zeroIdx, entry) {
      if (!entry.out) {
        buckets[0].enqueue(entry);
      } else if (!entry["in"]) {
        buckets[buckets.length - 1].enqueue(entry);
      } else {
        buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
      }
    }
  }
});

// node_modules/dagre/lib/acyclic.js
var require_acyclic = __commonJS({
  "node_modules/dagre/lib/acyclic.js"(exports, module) {
    "use strict";
    var _2 = require_lodash3();
    var greedyFAS2 = require_greedy_fas();
    module.exports = {
      run: run4,
      undo: undo4
    };
    function run4(g3) {
      var fas = g3.graph().acyclicer === "greedy" ? greedyFAS2(g3, weightFn(g3)) : dfsFAS2(g3);
      _2.forEach(fas, function(e2) {
        var label = g3.edge(e2);
        g3.removeEdge(e2);
        label.forwardName = e2.name;
        label.reversed = true;
        g3.setEdge(e2.w, e2.v, label, _2.uniqueId("rev"));
      });
      function weightFn(g4) {
        return function(e2) {
          return g4.edge(e2).weight;
        };
      }
    }
    function dfsFAS2(g3) {
      var fas = [];
      var stack = {};
      var visited = {};
      function dfs4(v3) {
        if (_2.has(visited, v3)) {
          return;
        }
        visited[v3] = true;
        stack[v3] = true;
        _2.forEach(g3.outEdges(v3), function(e2) {
          if (_2.has(stack, e2.w)) {
            fas.push(e2);
          } else {
            dfs4(e2.w);
          }
        });
        delete stack[v3];
      }
      _2.forEach(g3.nodes(), dfs4);
      return fas;
    }
    function undo4(g3) {
      _2.forEach(g3.edges(), function(e2) {
        var label = g3.edge(e2);
        if (label.reversed) {
          g3.removeEdge(e2);
          var forwardName = label.forwardName;
          delete label.reversed;
          delete label.forwardName;
          g3.setEdge(e2.w, e2.v, label, forwardName);
        }
      });
    }
  }
});

// node_modules/dagre/lib/util.js
var require_util = __commonJS({
  "node_modules/dagre/lib/util.js"(exports, module) {
    "use strict";
    var _2 = require_lodash3();
    var Graph5 = require_graphlib2().Graph;
    module.exports = {
      addDummyNode: addDummyNode2,
      simplify: simplify2,
      asNonCompoundGraph: asNonCompoundGraph2,
      successorWeights,
      predecessorWeights,
      intersectRect: intersectRect2,
      buildLayerMatrix: buildLayerMatrix2,
      normalizeRanks: normalizeRanks2,
      removeEmptyRanks: removeEmptyRanks2,
      addBorderNode: addBorderNode3,
      maxRank: maxRank2,
      partition: partition2,
      time,
      notime
    };
    function addDummyNode2(g3, type, attrs, name) {
      var v3;
      do {
        v3 = _2.uniqueId(name);
      } while (g3.hasNode(v3));
      attrs.dummy = type;
      g3.setNode(v3, attrs);
      return v3;
    }
    function simplify2(g3) {
      var simplified = new Graph5().setGraph(g3.graph());
      _2.forEach(g3.nodes(), function(v3) {
        simplified.setNode(v3, g3.node(v3));
      });
      _2.forEach(g3.edges(), function(e2) {
        var simpleLabel = simplified.edge(e2.v, e2.w) || { weight: 0, minlen: 1 };
        var label = g3.edge(e2);
        simplified.setEdge(e2.v, e2.w, {
          weight: simpleLabel.weight + label.weight,
          minlen: Math.max(simpleLabel.minlen, label.minlen)
        });
      });
      return simplified;
    }
    function asNonCompoundGraph2(g3) {
      var simplified = new Graph5({ multigraph: g3.isMultigraph() }).setGraph(g3.graph());
      _2.forEach(g3.nodes(), function(v3) {
        if (!g3.children(v3).length) {
          simplified.setNode(v3, g3.node(v3));
        }
      });
      _2.forEach(g3.edges(), function(e2) {
        simplified.setEdge(e2, g3.edge(e2));
      });
      return simplified;
    }
    function successorWeights(g3) {
      var weightMap = _2.map(g3.nodes(), function(v3) {
        var sucs = {};
        _2.forEach(g3.outEdges(v3), function(e2) {
          sucs[e2.w] = (sucs[e2.w] || 0) + g3.edge(e2).weight;
        });
        return sucs;
      });
      return _2.zipObject(g3.nodes(), weightMap);
    }
    function predecessorWeights(g3) {
      var weightMap = _2.map(g3.nodes(), function(v3) {
        var preds = {};
        _2.forEach(g3.inEdges(v3), function(e2) {
          preds[e2.v] = (preds[e2.v] || 0) + g3.edge(e2).weight;
        });
        return preds;
      });
      return _2.zipObject(g3.nodes(), weightMap);
    }
    function intersectRect2(rect2, point3) {
      var x4 = rect2.x;
      var y4 = rect2.y;
      var dx = point3.x - x4;
      var dy = point3.y - y4;
      var w3 = rect2.width / 2;
      var h3 = rect2.height / 2;
      if (!dx && !dy) {
        throw new Error("Not possible to find intersection inside of the rectangle");
      }
      var sx, sy;
      if (Math.abs(dy) * w3 > Math.abs(dx) * h3) {
        if (dy < 0) {
          h3 = -h3;
        }
        sx = h3 * dx / dy;
        sy = h3;
      } else {
        if (dx < 0) {
          w3 = -w3;
        }
        sx = w3;
        sy = w3 * dy / dx;
      }
      return { x: x4 + sx, y: y4 + sy };
    }
    function buildLayerMatrix2(g3) {
      var layering = _2.map(_2.range(maxRank2(g3) + 1), function() {
        return [];
      });
      _2.forEach(g3.nodes(), function(v3) {
        var node = g3.node(v3);
        var rank2 = node.rank;
        if (!_2.isUndefined(rank2)) {
          layering[rank2][node.order] = v3;
        }
      });
      return layering;
    }
    function normalizeRanks2(g3) {
      var min2 = _2.min(_2.map(g3.nodes(), function(v3) {
        return g3.node(v3).rank;
      }));
      _2.forEach(g3.nodes(), function(v3) {
        var node = g3.node(v3);
        if (_2.has(node, "rank")) {
          node.rank -= min2;
        }
      });
    }
    function removeEmptyRanks2(g3) {
      var offset = _2.min(_2.map(g3.nodes(), function(v3) {
        return g3.node(v3).rank;
      }));
      var layers = [];
      _2.forEach(g3.nodes(), function(v3) {
        var rank2 = g3.node(v3).rank - offset;
        if (!layers[rank2]) {
          layers[rank2] = [];
        }
        layers[rank2].push(v3);
      });
      var delta = 0;
      var nodeRankFactor = g3.graph().nodeRankFactor;
      _2.forEach(layers, function(vs, i2) {
        if (_2.isUndefined(vs) && i2 % nodeRankFactor !== 0) {
          --delta;
        } else if (delta) {
          _2.forEach(vs, function(v3) {
            g3.node(v3).rank += delta;
          });
        }
      });
    }
    function addBorderNode3(g3, prefix, rank2, order2) {
      var node = {
        width: 0,
        height: 0
      };
      if (arguments.length >= 4) {
        node.rank = rank2;
        node.order = order2;
      }
      return addDummyNode2(g3, "border", node, prefix);
    }
    function maxRank2(g3) {
      return _2.max(_2.map(g3.nodes(), function(v3) {
        var rank2 = g3.node(v3).rank;
        if (!_2.isUndefined(rank2)) {
          return rank2;
        }
      }));
    }
    function partition2(collection, fn) {
      var result = { lhs: [], rhs: [] };
      _2.forEach(collection, function(value) {
        if (fn(value)) {
          result.lhs.push(value);
        } else {
          result.rhs.push(value);
        }
      });
      return result;
    }
    function time(name, fn) {
      var start = _2.now();
      try {
        return fn();
      } finally {
        console.log(name + " time: " + (_2.now() - start) + "ms");
      }
    }
    function notime(name, fn) {
      return fn();
    }
  }
});

// node_modules/dagre/lib/normalize.js
var require_normalize = __commonJS({
  "node_modules/dagre/lib/normalize.js"(exports, module) {
    "use strict";
    var _2 = require_lodash3();
    var util = require_util();
    module.exports = {
      run: run4,
      undo: undo4
    };
    function run4(g3) {
      g3.graph().dummyChains = [];
      _2.forEach(g3.edges(), function(edge) {
        normalizeEdge2(g3, edge);
      });
    }
    function normalizeEdge2(g3, e2) {
      var v3 = e2.v;
      var vRank = g3.node(v3).rank;
      var w3 = e2.w;
      var wRank = g3.node(w3).rank;
      var name = e2.name;
      var edgeLabel = g3.edge(e2);
      var labelRank = edgeLabel.labelRank;
      if (wRank === vRank + 1) return;
      g3.removeEdge(e2);
      var dummy, attrs, i2;
      for (i2 = 0, ++vRank; vRank < wRank; ++i2, ++vRank) {
        edgeLabel.points = [];
        attrs = {
          width: 0,
          height: 0,
          edgeLabel,
          edgeObj: e2,
          rank: vRank
        };
        dummy = util.addDummyNode(g3, "edge", attrs, "_d");
        if (vRank === labelRank) {
          attrs.width = edgeLabel.width;
          attrs.height = edgeLabel.height;
          attrs.dummy = "edge-label";
          attrs.labelpos = edgeLabel.labelpos;
        }
        g3.setEdge(v3, dummy, { weight: edgeLabel.weight }, name);
        if (i2 === 0) {
          g3.graph().dummyChains.push(dummy);
        }
        v3 = dummy;
      }
      g3.setEdge(v3, w3, { weight: edgeLabel.weight }, name);
    }
    function undo4(g3) {
      _2.forEach(g3.graph().dummyChains, function(v3) {
        var node = g3.node(v3);
        var origLabel = node.edgeLabel;
        var w3;
        g3.setEdge(node.edgeObj, origLabel);
        while (node.dummy) {
          w3 = g3.successors(v3)[0];
          g3.removeNode(v3);
          origLabel.points.push({ x: node.x, y: node.y });
          if (node.dummy === "edge-label") {
            origLabel.x = node.x;
            origLabel.y = node.y;
            origLabel.width = node.width;
            origLabel.height = node.height;
          }
          v3 = w3;
          node = g3.node(v3);
        }
      });
    }
  }
});

// node_modules/dagre/lib/rank/util.js
var require_util2 = __commonJS({
  "node_modules/dagre/lib/rank/util.js"(exports, module) {
    "use strict";
    var _2 = require_lodash3();
    module.exports = {
      longestPath: longestPath2,
      slack: slack2
    };
    function longestPath2(g3) {
      var visited = {};
      function dfs4(v3) {
        var label = g3.node(v3);
        if (_2.has(visited, v3)) {
          return label.rank;
        }
        visited[v3] = true;
        var rank2 = _2.min(_2.map(g3.outEdges(v3), function(e2) {
          return dfs4(e2.w) - g3.edge(e2).minlen;
        }));
        if (rank2 === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3
        rank2 === void 0 || // return value of _.map([]) for Lodash 4
        rank2 === null) {
          rank2 = 0;
        }
        return label.rank = rank2;
      }
      _2.forEach(g3.sources(), dfs4);
    }
    function slack2(g3, e2) {
      return g3.node(e2.w).rank - g3.node(e2.v).rank - g3.edge(e2).minlen;
    }
  }
});

// node_modules/dagre/lib/rank/feasible-tree.js
var require_feasible_tree = __commonJS({
  "node_modules/dagre/lib/rank/feasible-tree.js"(exports, module) {
    "use strict";
    var _2 = require_lodash3();
    var Graph5 = require_graphlib2().Graph;
    var slack2 = require_util2().slack;
    module.exports = feasibleTree2;
    function feasibleTree2(g3) {
      var t3 = new Graph5({ directed: false });
      var start = g3.nodes()[0];
      var size2 = g3.nodeCount();
      t3.setNode(start, {});
      var edge, delta;
      while (tightTree2(t3, g3) < size2) {
        edge = findMinSlackEdge2(t3, g3);
        delta = t3.hasNode(edge.v) ? slack2(g3, edge) : -slack2(g3, edge);
        shiftRanks2(t3, g3, delta);
      }
      return t3;
    }
    function tightTree2(t3, g3) {
      function dfs4(v3) {
        _2.forEach(g3.nodeEdges(v3), function(e2) {
          var edgeV = e2.v, w3 = v3 === edgeV ? e2.w : edgeV;
          if (!t3.hasNode(w3) && !slack2(g3, e2)) {
            t3.setNode(w3, {});
            t3.setEdge(v3, w3, {});
            dfs4(w3);
          }
        });
      }
      _2.forEach(t3.nodes(), dfs4);
      return t3.nodeCount();
    }
    function findMinSlackEdge2(t3, g3) {
      return _2.minBy(g3.edges(), function(e2) {
        if (t3.hasNode(e2.v) !== t3.hasNode(e2.w)) {
          return slack2(g3, e2);
        }
      });
    }
    function shiftRanks2(t3, g3, delta) {
      _2.forEach(t3.nodes(), function(v3) {
        g3.node(v3).rank += delta;
      });
    }
  }
});

// node_modules/dagre/lib/rank/network-simplex.js
var require_network_simplex = __commonJS({
  "node_modules/dagre/lib/rank/network-simplex.js"(exports, module) {
    "use strict";
    var _2 = require_lodash3();
    var feasibleTree2 = require_feasible_tree();
    var slack2 = require_util2().slack;
    var initRank = require_util2().longestPath;
    var preorder = require_graphlib2().alg.preorder;
    var postorder = require_graphlib2().alg.postorder;
    var simplify2 = require_util().simplify;
    module.exports = networkSimplex2;
    networkSimplex2.initLowLimValues = initLowLimValues2;
    networkSimplex2.initCutValues = initCutValues2;
    networkSimplex2.calcCutValue = calcCutValue2;
    networkSimplex2.leaveEdge = leaveEdge2;
    networkSimplex2.enterEdge = enterEdge2;
    networkSimplex2.exchangeEdges = exchangeEdges2;
    function networkSimplex2(g3) {
      g3 = simplify2(g3);
      initRank(g3);
      var t3 = feasibleTree2(g3);
      initLowLimValues2(t3);
      initCutValues2(t3, g3);
      var e2, f3;
      while (e2 = leaveEdge2(t3)) {
        f3 = enterEdge2(t3, g3, e2);
        exchangeEdges2(t3, g3, e2, f3);
      }
    }
    function initCutValues2(t3, g3) {
      var vs = postorder(t3, t3.nodes());
      vs = vs.slice(0, vs.length - 1);
      _2.forEach(vs, function(v3) {
        assignCutValue2(t3, g3, v3);
      });
    }
    function assignCutValue2(t3, g3, child) {
      var childLab = t3.node(child);
      var parent = childLab.parent;
      t3.edge(child, parent).cutvalue = calcCutValue2(t3, g3, child);
    }
    function calcCutValue2(t3, g3, child) {
      var childLab = t3.node(child);
      var parent = childLab.parent;
      var childIsTail = true;
      var graphEdge = g3.edge(child, parent);
      var cutValue = 0;
      if (!graphEdge) {
        childIsTail = false;
        graphEdge = g3.edge(parent, child);
      }
      cutValue = graphEdge.weight;
      _2.forEach(g3.nodeEdges(child), function(e2) {
        var isOutEdge = e2.v === child, other = isOutEdge ? e2.w : e2.v;
        if (other !== parent) {
          var pointsToHead = isOutEdge === childIsTail, otherWeight = g3.edge(e2).weight;
          cutValue += pointsToHead ? otherWeight : -otherWeight;
          if (isTreeEdge2(t3, child, other)) {
            var otherCutValue = t3.edge(child, other).cutvalue;
            cutValue += pointsToHead ? -otherCutValue : otherCutValue;
          }
        }
      });
      return cutValue;
    }
    function initLowLimValues2(tree, root) {
      if (arguments.length < 2) {
        root = tree.nodes()[0];
      }
      dfsAssignLowLim2(tree, {}, 1, root);
    }
    function dfsAssignLowLim2(tree, visited, nextLim, v3, parent) {
      var low = nextLim;
      var label = tree.node(v3);
      visited[v3] = true;
      _2.forEach(tree.neighbors(v3), function(w3) {
        if (!_2.has(visited, w3)) {
          nextLim = dfsAssignLowLim2(tree, visited, nextLim, w3, v3);
        }
      });
      label.low = low;
      label.lim = nextLim++;
      if (parent) {
        label.parent = parent;
      } else {
        delete label.parent;
      }
      return nextLim;
    }
    function leaveEdge2(tree) {
      return _2.find(tree.edges(), function(e2) {
        return tree.edge(e2).cutvalue < 0;
      });
    }
    function enterEdge2(t3, g3, edge) {
      var v3 = edge.v;
      var w3 = edge.w;
      if (!g3.hasEdge(v3, w3)) {
        v3 = edge.w;
        w3 = edge.v;
      }
      var vLabel = t3.node(v3);
      var wLabel = t3.node(w3);
      var tailLabel = vLabel;
      var flip = false;
      if (vLabel.lim > wLabel.lim) {
        tailLabel = wLabel;
        flip = true;
      }
      var candidates = _2.filter(g3.edges(), function(edge2) {
        return flip === isDescendant2(t3, t3.node(edge2.v), tailLabel) && flip !== isDescendant2(t3, t3.node(edge2.w), tailLabel);
      });
      return _2.minBy(candidates, function(edge2) {
        return slack2(g3, edge2);
      });
    }
    function exchangeEdges2(t3, g3, e2, f3) {
      var v3 = e2.v;
      var w3 = e2.w;
      t3.removeEdge(v3, w3);
      t3.setEdge(f3.v, f3.w, {});
      initLowLimValues2(t3);
      initCutValues2(t3, g3);
      updateRanks2(t3, g3);
    }
    function updateRanks2(t3, g3) {
      var root = _2.find(t3.nodes(), function(v3) {
        return !g3.node(v3).parent;
      });
      var vs = preorder(t3, root);
      vs = vs.slice(1);
      _2.forEach(vs, function(v3) {
        var parent = t3.node(v3).parent, edge = g3.edge(v3, parent), flipped = false;
        if (!edge) {
          edge = g3.edge(parent, v3);
          flipped = true;
        }
        g3.node(v3).rank = g3.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
      });
    }
    function isTreeEdge2(tree, u3, v3) {
      return tree.hasEdge(u3, v3);
    }
    function isDescendant2(tree, vLabel, rootLabel) {
      return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
    }
  }
});

// node_modules/dagre/lib/rank/index.js
var require_rank = __commonJS({
  "node_modules/dagre/lib/rank/index.js"(exports, module) {
    "use strict";
    var rankUtil = require_util2();
    var longestPath2 = rankUtil.longestPath;
    var feasibleTree2 = require_feasible_tree();
    var networkSimplex2 = require_network_simplex();
    module.exports = rank2;
    function rank2(g3) {
      switch (g3.graph().ranker) {
        case "network-simplex":
          networkSimplexRanker2(g3);
          break;
        case "tight-tree":
          tightTreeRanker2(g3);
          break;
        case "longest-path":
          longestPathRanker2(g3);
          break;
        default:
          networkSimplexRanker2(g3);
      }
    }
    var longestPathRanker2 = longestPath2;
    function tightTreeRanker2(g3) {
      longestPath2(g3);
      feasibleTree2(g3);
    }
    function networkSimplexRanker2(g3) {
      networkSimplex2(g3);
    }
  }
});

// node_modules/dagre/lib/parent-dummy-chains.js
var require_parent_dummy_chains = __commonJS({
  "node_modules/dagre/lib/parent-dummy-chains.js"(exports, module) {
    var _2 = require_lodash3();
    module.exports = parentDummyChains2;
    function parentDummyChains2(g3) {
      var postorderNums = postorder(g3);
      _2.forEach(g3.graph().dummyChains, function(v3) {
        var node = g3.node(v3);
        var edgeObj = node.edgeObj;
        var pathData = findPath2(g3, postorderNums, edgeObj.v, edgeObj.w);
        var path = pathData.path;
        var lca = pathData.lca;
        var pathIdx = 0;
        var pathV = path[pathIdx];
        var ascending = true;
        while (v3 !== edgeObj.w) {
          node = g3.node(v3);
          if (ascending) {
            while ((pathV = path[pathIdx]) !== lca && g3.node(pathV).maxRank < node.rank) {
              pathIdx++;
            }
            if (pathV === lca) {
              ascending = false;
            }
          }
          if (!ascending) {
            while (pathIdx < path.length - 1 && g3.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {
              pathIdx++;
            }
            pathV = path[pathIdx];
          }
          g3.setParent(v3, pathV);
          v3 = g3.successors(v3)[0];
        }
      });
    }
    function findPath2(g3, postorderNums, v3, w3) {
      var vPath = [];
      var wPath = [];
      var low = Math.min(postorderNums[v3].low, postorderNums[w3].low);
      var lim = Math.max(postorderNums[v3].lim, postorderNums[w3].lim);
      var parent;
      var lca;
      parent = v3;
      do {
        parent = g3.parent(parent);
        vPath.push(parent);
      } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
      lca = parent;
      parent = w3;
      while ((parent = g3.parent(parent)) !== lca) {
        wPath.push(parent);
      }
      return { path: vPath.concat(wPath.reverse()), lca };
    }
    function postorder(g3) {
      var result = {};
      var lim = 0;
      function dfs4(v3) {
        var low = lim;
        _2.forEach(g3.children(v3), dfs4);
        result[v3] = { low, lim: lim++ };
      }
      _2.forEach(g3.children(), dfs4);
      return result;
    }
  }
});

// node_modules/dagre/lib/nesting-graph.js
var require_nesting_graph = __commonJS({
  "node_modules/dagre/lib/nesting-graph.js"(exports, module) {
    var _2 = require_lodash3();
    var util = require_util();
    module.exports = {
      run: run4,
      cleanup: cleanup2
    };
    function run4(g3) {
      var root = util.addDummyNode(g3, "root", {}, "_root");
      var depths = treeDepths2(g3);
      var height = _2.max(_2.values(depths)) - 1;
      var nodeSep = 2 * height + 1;
      g3.graph().nestingRoot = root;
      _2.forEach(g3.edges(), function(e2) {
        g3.edge(e2).minlen *= nodeSep;
      });
      var weight = sumWeights2(g3) + 1;
      _2.forEach(g3.children(), function(child) {
        dfs4(g3, root, nodeSep, weight, height, depths, child);
      });
      g3.graph().nodeRankFactor = nodeSep;
    }
    function dfs4(g3, root, nodeSep, weight, height, depths, v3) {
      var children = g3.children(v3);
      if (!children.length) {
        if (v3 !== root) {
          g3.setEdge(root, v3, { weight: 0, minlen: nodeSep });
        }
        return;
      }
      var top = util.addBorderNode(g3, "_bt");
      var bottom = util.addBorderNode(g3, "_bb");
      var label = g3.node(v3);
      g3.setParent(top, v3);
      label.borderTop = top;
      g3.setParent(bottom, v3);
      label.borderBottom = bottom;
      _2.forEach(children, function(child) {
        dfs4(g3, root, nodeSep, weight, height, depths, child);
        var childNode = g3.node(child);
        var childTop = childNode.borderTop ? childNode.borderTop : child;
        var childBottom = childNode.borderBottom ? childNode.borderBottom : child;
        var thisWeight = childNode.borderTop ? weight : 2 * weight;
        var minlen = childTop !== childBottom ? 1 : height - depths[v3] + 1;
        g3.setEdge(top, childTop, {
          weight: thisWeight,
          minlen,
          nestingEdge: true
        });
        g3.setEdge(childBottom, bottom, {
          weight: thisWeight,
          minlen,
          nestingEdge: true
        });
      });
      if (!g3.parent(v3)) {
        g3.setEdge(root, top, { weight: 0, minlen: height + depths[v3] });
      }
    }
    function treeDepths2(g3) {
      var depths = {};
      function dfs5(v3, depth) {
        var children = g3.children(v3);
        if (children && children.length) {
          _2.forEach(children, function(child) {
            dfs5(child, depth + 1);
          });
        }
        depths[v3] = depth;
      }
      _2.forEach(g3.children(), function(v3) {
        dfs5(v3, 1);
      });
      return depths;
    }
    function sumWeights2(g3) {
      return _2.reduce(g3.edges(), function(acc, e2) {
        return acc + g3.edge(e2).weight;
      }, 0);
    }
    function cleanup2(g3) {
      var graphLabel = g3.graph();
      g3.removeNode(graphLabel.nestingRoot);
      delete graphLabel.nestingRoot;
      _2.forEach(g3.edges(), function(e2) {
        var edge = g3.edge(e2);
        if (edge.nestingEdge) {
          g3.removeEdge(e2);
        }
      });
    }
  }
});

// node_modules/dagre/lib/add-border-segments.js
var require_add_border_segments = __commonJS({
  "node_modules/dagre/lib/add-border-segments.js"(exports, module) {
    var _2 = require_lodash3();
    var util = require_util();
    module.exports = addBorderSegments2;
    function addBorderSegments2(g3) {
      function dfs4(v3) {
        var children = g3.children(v3);
        var node = g3.node(v3);
        if (children.length) {
          _2.forEach(children, dfs4);
        }
        if (_2.has(node, "minRank")) {
          node.borderLeft = [];
          node.borderRight = [];
          for (var rank2 = node.minRank, maxRank2 = node.maxRank + 1; rank2 < maxRank2; ++rank2) {
            addBorderNode3(g3, "borderLeft", "_bl", v3, node, rank2);
            addBorderNode3(g3, "borderRight", "_br", v3, node, rank2);
          }
        }
      }
      _2.forEach(g3.children(), dfs4);
    }
    function addBorderNode3(g3, prop, prefix, sg, sgNode, rank2) {
      var label = { width: 0, height: 0, rank: rank2, borderType: prop };
      var prev = sgNode[prop][rank2 - 1];
      var curr = util.addDummyNode(g3, "border", label, prefix);
      sgNode[prop][rank2] = curr;
      g3.setParent(curr, sg);
      if (prev) {
        g3.setEdge(prev, curr, { weight: 1 });
      }
    }
  }
});

// node_modules/dagre/lib/coordinate-system.js
var require_coordinate_system = __commonJS({
  "node_modules/dagre/lib/coordinate-system.js"(exports, module) {
    "use strict";
    var _2 = require_lodash3();
    module.exports = {
      adjust: adjust2,
      undo: undo4
    };
    function adjust2(g3) {
      var rankDir = g3.graph().rankdir.toLowerCase();
      if (rankDir === "lr" || rankDir === "rl") {
        swapWidthHeight2(g3);
      }
    }
    function undo4(g3) {
      var rankDir = g3.graph().rankdir.toLowerCase();
      if (rankDir === "bt" || rankDir === "rl") {
        reverseY2(g3);
      }
      if (rankDir === "lr" || rankDir === "rl") {
        swapXY2(g3);
        swapWidthHeight2(g3);
      }
    }
    function swapWidthHeight2(g3) {
      _2.forEach(g3.nodes(), function(v3) {
        swapWidthHeightOne2(g3.node(v3));
      });
      _2.forEach(g3.edges(), function(e2) {
        swapWidthHeightOne2(g3.edge(e2));
      });
    }
    function swapWidthHeightOne2(attrs) {
      var w3 = attrs.width;
      attrs.width = attrs.height;
      attrs.height = w3;
    }
    function reverseY2(g3) {
      _2.forEach(g3.nodes(), function(v3) {
        reverseYOne2(g3.node(v3));
      });
      _2.forEach(g3.edges(), function(e2) {
        var edge = g3.edge(e2);
        _2.forEach(edge.points, reverseYOne2);
        if (_2.has(edge, "y")) {
          reverseYOne2(edge);
        }
      });
    }
    function reverseYOne2(attrs) {
      attrs.y = -attrs.y;
    }
    function swapXY2(g3) {
      _2.forEach(g3.nodes(), function(v3) {
        swapXYOne2(g3.node(v3));
      });
      _2.forEach(g3.edges(), function(e2) {
        var edge = g3.edge(e2);
        _2.forEach(edge.points, swapXYOne2);
        if (_2.has(edge, "x")) {
          swapXYOne2(edge);
        }
      });
    }
    function swapXYOne2(attrs) {
      var x4 = attrs.x;
      attrs.x = attrs.y;
      attrs.y = x4;
    }
  }
});

// node_modules/dagre/lib/order/init-order.js
var require_init_order = __commonJS({
  "node_modules/dagre/lib/order/init-order.js"(exports, module) {
    "use strict";
    var _2 = require_lodash3();
    module.exports = initOrder2;
    function initOrder2(g3) {
      var visited = {};
      var simpleNodes = _2.filter(g3.nodes(), function(v3) {
        return !g3.children(v3).length;
      });
      var maxRank2 = _2.max(_2.map(simpleNodes, function(v3) {
        return g3.node(v3).rank;
      }));
      var layers = _2.map(_2.range(maxRank2 + 1), function() {
        return [];
      });
      function dfs4(v3) {
        if (_2.has(visited, v3)) return;
        visited[v3] = true;
        var node = g3.node(v3);
        layers[node.rank].push(v3);
        _2.forEach(g3.successors(v3), dfs4);
      }
      var orderedVs = _2.sortBy(simpleNodes, function(v3) {
        return g3.node(v3).rank;
      });
      _2.forEach(orderedVs, dfs4);
      return layers;
    }
  }
});

// node_modules/dagre/lib/order/cross-count.js
var require_cross_count = __commonJS({
  "node_modules/dagre/lib/order/cross-count.js"(exports, module) {
    "use strict";
    var _2 = require_lodash3();
    module.exports = crossCount2;
    function crossCount2(g3, layering) {
      var cc = 0;
      for (var i2 = 1; i2 < layering.length; ++i2) {
        cc += twoLayerCrossCount2(g3, layering[i2 - 1], layering[i2]);
      }
      return cc;
    }
    function twoLayerCrossCount2(g3, northLayer, southLayer) {
      var southPos = _2.zipObject(
        southLayer,
        _2.map(southLayer, function(v3, i2) {
          return i2;
        })
      );
      var southEntries = _2.flatten(_2.map(northLayer, function(v3) {
        return _2.sortBy(_2.map(g3.outEdges(v3), function(e2) {
          return { pos: southPos[e2.w], weight: g3.edge(e2).weight };
        }), "pos");
      }), true);
      var firstIndex = 1;
      while (firstIndex < southLayer.length) firstIndex <<= 1;
      var treeSize = 2 * firstIndex - 1;
      firstIndex -= 1;
      var tree = _2.map(new Array(treeSize), function() {
        return 0;
      });
      var cc = 0;
      _2.forEach(southEntries.forEach(function(entry) {
        var index = entry.pos + firstIndex;
        tree[index] += entry.weight;
        var weightSum = 0;
        while (index > 0) {
          if (index % 2) {
            weightSum += tree[index + 1];
          }
          index = index - 1 >> 1;
          tree[index] += entry.weight;
        }
        cc += entry.weight * weightSum;
      }));
      return cc;
    }
  }
});

// node_modules/dagre/lib/order/barycenter.js
var require_barycenter = __commonJS({
  "node_modules/dagre/lib/order/barycenter.js"(exports, module) {
    var _2 = require_lodash3();
    module.exports = barycenter2;
    function barycenter2(g3, movable) {
      return _2.map(movable, function(v3) {
        var inV = g3.inEdges(v3);
        if (!inV.length) {
          return { v: v3 };
        } else {
          var result = _2.reduce(inV, function(acc, e2) {
            var edge = g3.edge(e2), nodeU = g3.node(e2.v);
            return {
              sum: acc.sum + edge.weight * nodeU.order,
              weight: acc.weight + edge.weight
            };
          }, { sum: 0, weight: 0 });
          return {
            v: v3,
            barycenter: result.sum / result.weight,
            weight: result.weight
          };
        }
      });
    }
  }
});

// node_modules/dagre/lib/order/resolve-conflicts.js
var require_resolve_conflicts = __commonJS({
  "node_modules/dagre/lib/order/resolve-conflicts.js"(exports, module) {
    "use strict";
    var _2 = require_lodash3();
    module.exports = resolveConflicts2;
    function resolveConflicts2(entries, cg) {
      var mappedEntries = {};
      _2.forEach(entries, function(entry, i2) {
        var tmp = mappedEntries[entry.v] = {
          indegree: 0,
          "in": [],
          out: [],
          vs: [entry.v],
          i: i2
        };
        if (!_2.isUndefined(entry.barycenter)) {
          tmp.barycenter = entry.barycenter;
          tmp.weight = entry.weight;
        }
      });
      _2.forEach(cg.edges(), function(e2) {
        var entryV = mappedEntries[e2.v];
        var entryW = mappedEntries[e2.w];
        if (!_2.isUndefined(entryV) && !_2.isUndefined(entryW)) {
          entryW.indegree++;
          entryV.out.push(mappedEntries[e2.w]);
        }
      });
      var sourceSet = _2.filter(mappedEntries, function(entry) {
        return !entry.indegree;
      });
      return doResolveConflicts2(sourceSet);
    }
    function doResolveConflicts2(sourceSet) {
      var entries = [];
      function handleIn(vEntry) {
        return function(uEntry) {
          if (uEntry.merged) {
            return;
          }
          if (_2.isUndefined(uEntry.barycenter) || _2.isUndefined(vEntry.barycenter) || uEntry.barycenter >= vEntry.barycenter) {
            mergeEntries2(vEntry, uEntry);
          }
        };
      }
      function handleOut(vEntry) {
        return function(wEntry) {
          wEntry["in"].push(vEntry);
          if (--wEntry.indegree === 0) {
            sourceSet.push(wEntry);
          }
        };
      }
      while (sourceSet.length) {
        var entry = sourceSet.pop();
        entries.push(entry);
        _2.forEach(entry["in"].reverse(), handleIn(entry));
        _2.forEach(entry.out, handleOut(entry));
      }
      return _2.map(
        _2.filter(entries, function(entry2) {
          return !entry2.merged;
        }),
        function(entry2) {
          return _2.pick(entry2, ["vs", "i", "barycenter", "weight"]);
        }
      );
    }
    function mergeEntries2(target, source) {
      var sum = 0;
      var weight = 0;
      if (target.weight) {
        sum += target.barycenter * target.weight;
        weight += target.weight;
      }
      if (source.weight) {
        sum += source.barycenter * source.weight;
        weight += source.weight;
      }
      target.vs = source.vs.concat(target.vs);
      target.barycenter = sum / weight;
      target.weight = weight;
      target.i = Math.min(source.i, target.i);
      source.merged = true;
    }
  }
});

// node_modules/dagre/lib/order/sort.js
var require_sort = __commonJS({
  "node_modules/dagre/lib/order/sort.js"(exports, module) {
    var _2 = require_lodash3();
    var util = require_util();
    module.exports = sort2;
    function sort2(entries, biasRight) {
      var parts = util.partition(entries, function(entry) {
        return _2.has(entry, "barycenter");
      });
      var sortable = parts.lhs, unsortable = _2.sortBy(parts.rhs, function(entry) {
        return -entry.i;
      }), vs = [], sum = 0, weight = 0, vsIndex = 0;
      sortable.sort(compareWithBias2(!!biasRight));
      vsIndex = consumeUnsortable2(vs, unsortable, vsIndex);
      _2.forEach(sortable, function(entry) {
        vsIndex += entry.vs.length;
        vs.push(entry.vs);
        sum += entry.barycenter * entry.weight;
        weight += entry.weight;
        vsIndex = consumeUnsortable2(vs, unsortable, vsIndex);
      });
      var result = { vs: _2.flatten(vs, true) };
      if (weight) {
        result.barycenter = sum / weight;
        result.weight = weight;
      }
      return result;
    }
    function consumeUnsortable2(vs, unsortable, index) {
      var last2;
      while (unsortable.length && (last2 = _2.last(unsortable)).i <= index) {
        unsortable.pop();
        vs.push(last2.vs);
        index++;
      }
      return index;
    }
    function compareWithBias2(bias) {
      return function(entryV, entryW) {
        if (entryV.barycenter < entryW.barycenter) {
          return -1;
        } else if (entryV.barycenter > entryW.barycenter) {
          return 1;
        }
        return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
      };
    }
  }
});

// node_modules/dagre/lib/order/sort-subgraph.js
var require_sort_subgraph = __commonJS({
  "node_modules/dagre/lib/order/sort-subgraph.js"(exports, module) {
    var _2 = require_lodash3();
    var barycenter2 = require_barycenter();
    var resolveConflicts2 = require_resolve_conflicts();
    var sort2 = require_sort();
    module.exports = sortSubgraph2;
    function sortSubgraph2(g3, v3, cg, biasRight) {
      var movable = g3.children(v3);
      var node = g3.node(v3);
      var bl = node ? node.borderLeft : void 0;
      var br = node ? node.borderRight : void 0;
      var subgraphs = {};
      if (bl) {
        movable = _2.filter(movable, function(w3) {
          return w3 !== bl && w3 !== br;
        });
      }
      var barycenters = barycenter2(g3, movable);
      _2.forEach(barycenters, function(entry) {
        if (g3.children(entry.v).length) {
          var subgraphResult = sortSubgraph2(g3, entry.v, cg, biasRight);
          subgraphs[entry.v] = subgraphResult;
          if (_2.has(subgraphResult, "barycenter")) {
            mergeBarycenters2(entry, subgraphResult);
          }
        }
      });
      var entries = resolveConflicts2(barycenters, cg);
      expandSubgraphs2(entries, subgraphs);
      var result = sort2(entries, biasRight);
      if (bl) {
        result.vs = _2.flatten([bl, result.vs, br], true);
        if (g3.predecessors(bl).length) {
          var blPred = g3.node(g3.predecessors(bl)[0]), brPred = g3.node(g3.predecessors(br)[0]);
          if (!_2.has(result, "barycenter")) {
            result.barycenter = 0;
            result.weight = 0;
          }
          result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);
          result.weight += 2;
        }
      }
      return result;
    }
    function expandSubgraphs2(entries, subgraphs) {
      _2.forEach(entries, function(entry) {
        entry.vs = _2.flatten(entry.vs.map(function(v3) {
          if (subgraphs[v3]) {
            return subgraphs[v3].vs;
          }
          return v3;
        }), true);
      });
    }
    function mergeBarycenters2(target, other) {
      if (!_2.isUndefined(target.barycenter)) {
        target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
        target.weight += other.weight;
      } else {
        target.barycenter = other.barycenter;
        target.weight = other.weight;
      }
    }
  }
});

// node_modules/dagre/lib/order/build-layer-graph.js
var require_build_layer_graph = __commonJS({
  "node_modules/dagre/lib/order/build-layer-graph.js"(exports, module) {
    var _2 = require_lodash3();
    var Graph5 = require_graphlib2().Graph;
    module.exports = buildLayerGraph2;
    function buildLayerGraph2(g3, rank2, relationship) {
      var root = createRootNode2(g3), result = new Graph5({ compound: true }).setGraph({ root }).setDefaultNodeLabel(function(v3) {
        return g3.node(v3);
      });
      _2.forEach(g3.nodes(), function(v3) {
        var node = g3.node(v3), parent = g3.parent(v3);
        if (node.rank === rank2 || node.minRank <= rank2 && rank2 <= node.maxRank) {
          result.setNode(v3);
          result.setParent(v3, parent || root);
          _2.forEach(g3[relationship](v3), function(e2) {
            var u3 = e2.v === v3 ? e2.w : e2.v, edge = result.edge(u3, v3), weight = !_2.isUndefined(edge) ? edge.weight : 0;
            result.setEdge(u3, v3, { weight: g3.edge(e2).weight + weight });
          });
          if (_2.has(node, "minRank")) {
            result.setNode(v3, {
              borderLeft: node.borderLeft[rank2],
              borderRight: node.borderRight[rank2]
            });
          }
        }
      });
      return result;
    }
    function createRootNode2(g3) {
      var v3;
      while (g3.hasNode(v3 = _2.uniqueId("_root"))) ;
      return v3;
    }
  }
});

// node_modules/dagre/lib/order/add-subgraph-constraints.js
var require_add_subgraph_constraints = __commonJS({
  "node_modules/dagre/lib/order/add-subgraph-constraints.js"(exports, module) {
    var _2 = require_lodash3();
    module.exports = addSubgraphConstraints2;
    function addSubgraphConstraints2(g3, cg, vs) {
      var prev = {}, rootPrev;
      _2.forEach(vs, function(v3) {
        var child = g3.parent(v3), parent, prevChild;
        while (child) {
          parent = g3.parent(child);
          if (parent) {
            prevChild = prev[parent];
            prev[parent] = child;
          } else {
            prevChild = rootPrev;
            rootPrev = child;
          }
          if (prevChild && prevChild !== child) {
            cg.setEdge(prevChild, child);
            return;
          }
          child = parent;
        }
      });
    }
  }
});

// node_modules/dagre/lib/order/index.js
var require_order = __commonJS({
  "node_modules/dagre/lib/order/index.js"(exports, module) {
    "use strict";
    var _2 = require_lodash3();
    var initOrder2 = require_init_order();
    var crossCount2 = require_cross_count();
    var sortSubgraph2 = require_sort_subgraph();
    var buildLayerGraph2 = require_build_layer_graph();
    var addSubgraphConstraints2 = require_add_subgraph_constraints();
    var Graph5 = require_graphlib2().Graph;
    var util = require_util();
    module.exports = order2;
    function order2(g3) {
      var maxRank2 = util.maxRank(g3), downLayerGraphs = buildLayerGraphs2(g3, _2.range(1, maxRank2 + 1), "inEdges"), upLayerGraphs = buildLayerGraphs2(g3, _2.range(maxRank2 - 1, -1, -1), "outEdges");
      var layering = initOrder2(g3);
      assignOrder2(g3, layering);
      var bestCC = Number.POSITIVE_INFINITY, best;
      for (var i2 = 0, lastBest = 0; lastBest < 4; ++i2, ++lastBest) {
        sweepLayerGraphs2(i2 % 2 ? downLayerGraphs : upLayerGraphs, i2 % 4 >= 2);
        layering = util.buildLayerMatrix(g3);
        var cc = crossCount2(g3, layering);
        if (cc < bestCC) {
          lastBest = 0;
          best = _2.cloneDeep(layering);
          bestCC = cc;
        }
      }
      assignOrder2(g3, best);
    }
    function buildLayerGraphs2(g3, ranks, relationship) {
      return _2.map(ranks, function(rank2) {
        return buildLayerGraph2(g3, rank2, relationship);
      });
    }
    function sweepLayerGraphs2(layerGraphs, biasRight) {
      var cg = new Graph5();
      _2.forEach(layerGraphs, function(lg) {
        var root = lg.graph().root;
        var sorted = sortSubgraph2(lg, root, cg, biasRight);
        _2.forEach(sorted.vs, function(v3, i2) {
          lg.node(v3).order = i2;
        });
        addSubgraphConstraints2(lg, cg, sorted.vs);
      });
    }
    function assignOrder2(g3, layering) {
      _2.forEach(layering, function(layer) {
        _2.forEach(layer, function(v3, i2) {
          g3.node(v3).order = i2;
        });
      });
    }
  }
});

// node_modules/dagre/lib/position/bk.js
var require_bk = __commonJS({
  "node_modules/dagre/lib/position/bk.js"(exports, module) {
    "use strict";
    var _2 = require_lodash3();
    var Graph5 = require_graphlib2().Graph;
    var util = require_util();
    module.exports = {
      positionX: positionX2,
      findType1Conflicts: findType1Conflicts2,
      findType2Conflicts: findType2Conflicts2,
      addConflict: addConflict2,
      hasConflict: hasConflict2,
      verticalAlignment: verticalAlignment2,
      horizontalCompaction: horizontalCompaction2,
      alignCoordinates: alignCoordinates2,
      findSmallestWidthAlignment: findSmallestWidthAlignment2,
      balance: balance2
    };
    function findType1Conflicts2(g3, layering) {
      var conflicts = {};
      function visitLayer(prevLayer, layer) {
        var k0 = 0, scanPos = 0, prevLayerLength = prevLayer.length, lastNode = _2.last(layer);
        _2.forEach(layer, function(v3, i2) {
          var w3 = findOtherInnerSegmentNode2(g3, v3), k1 = w3 ? g3.node(w3).order : prevLayerLength;
          if (w3 || v3 === lastNode) {
            _2.forEach(layer.slice(scanPos, i2 + 1), function(scanNode) {
              _2.forEach(g3.predecessors(scanNode), function(u3) {
                var uLabel = g3.node(u3), uPos = uLabel.order;
                if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g3.node(scanNode).dummy)) {
                  addConflict2(conflicts, u3, scanNode);
                }
              });
            });
            scanPos = i2 + 1;
            k0 = k1;
          }
        });
        return layer;
      }
      _2.reduce(layering, visitLayer);
      return conflicts;
    }
    function findType2Conflicts2(g3, layering) {
      var conflicts = {};
      function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
        var v3;
        _2.forEach(_2.range(southPos, southEnd), function(i2) {
          v3 = south[i2];
          if (g3.node(v3).dummy) {
            _2.forEach(g3.predecessors(v3), function(u3) {
              var uNode = g3.node(u3);
              if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
                addConflict2(conflicts, u3, v3);
              }
            });
          }
        });
      }
      function visitLayer(north, south) {
        var prevNorthPos = -1, nextNorthPos, southPos = 0;
        _2.forEach(south, function(v3, southLookahead) {
          if (g3.node(v3).dummy === "border") {
            var predecessors = g3.predecessors(v3);
            if (predecessors.length) {
              nextNorthPos = g3.node(predecessors[0]).order;
              scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
              southPos = southLookahead;
              prevNorthPos = nextNorthPos;
            }
          }
          scan(south, southPos, south.length, nextNorthPos, north.length);
        });
        return south;
      }
      _2.reduce(layering, visitLayer);
      return conflicts;
    }
    function findOtherInnerSegmentNode2(g3, v3) {
      if (g3.node(v3).dummy) {
        return _2.find(g3.predecessors(v3), function(u3) {
          return g3.node(u3).dummy;
        });
      }
    }
    function addConflict2(conflicts, v3, w3) {
      if (v3 > w3) {
        var tmp = v3;
        v3 = w3;
        w3 = tmp;
      }
      var conflictsV = conflicts[v3];
      if (!conflictsV) {
        conflicts[v3] = conflictsV = {};
      }
      conflictsV[w3] = true;
    }
    function hasConflict2(conflicts, v3, w3) {
      if (v3 > w3) {
        var tmp = v3;
        v3 = w3;
        w3 = tmp;
      }
      return _2.has(conflicts[v3], w3);
    }
    function verticalAlignment2(g3, layering, conflicts, neighborFn) {
      var root = {}, align = {}, pos = {};
      _2.forEach(layering, function(layer) {
        _2.forEach(layer, function(v3, order2) {
          root[v3] = v3;
          align[v3] = v3;
          pos[v3] = order2;
        });
      });
      _2.forEach(layering, function(layer) {
        var prevIdx = -1;
        _2.forEach(layer, function(v3) {
          var ws = neighborFn(v3);
          if (ws.length) {
            ws = _2.sortBy(ws, function(w4) {
              return pos[w4];
            });
            var mp = (ws.length - 1) / 2;
            for (var i2 = Math.floor(mp), il = Math.ceil(mp); i2 <= il; ++i2) {
              var w3 = ws[i2];
              if (align[v3] === v3 && prevIdx < pos[w3] && !hasConflict2(conflicts, v3, w3)) {
                align[w3] = v3;
                align[v3] = root[v3] = root[w3];
                prevIdx = pos[w3];
              }
            }
          }
        });
      });
      return { root, align };
    }
    function horizontalCompaction2(g3, layering, root, align, reverseSep) {
      var xs = {}, blockG = buildBlockGraph2(g3, layering, root, reverseSep), borderType = reverseSep ? "borderLeft" : "borderRight";
      function iterate(setXsFunc, nextNodesFunc) {
        var stack = blockG.nodes();
        var elem = stack.pop();
        var visited = {};
        while (elem) {
          if (visited[elem]) {
            setXsFunc(elem);
          } else {
            visited[elem] = true;
            stack.push(elem);
            stack = stack.concat(nextNodesFunc(elem));
          }
          elem = stack.pop();
        }
      }
      function pass1(elem) {
        xs[elem] = blockG.inEdges(elem).reduce(function(acc, e2) {
          return Math.max(acc, xs[e2.v] + blockG.edge(e2));
        }, 0);
      }
      function pass2(elem) {
        var min2 = blockG.outEdges(elem).reduce(function(acc, e2) {
          return Math.min(acc, xs[e2.w] - blockG.edge(e2));
        }, Number.POSITIVE_INFINITY);
        var node = g3.node(elem);
        if (min2 !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
          xs[elem] = Math.max(xs[elem], min2);
        }
      }
      iterate(pass1, blockG.predecessors.bind(blockG));
      iterate(pass2, blockG.successors.bind(blockG));
      _2.forEach(align, function(v3) {
        xs[v3] = xs[root[v3]];
      });
      return xs;
    }
    function buildBlockGraph2(g3, layering, root, reverseSep) {
      var blockGraph = new Graph5(), graphLabel = g3.graph(), sepFn = sep2(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
      _2.forEach(layering, function(layer) {
        var u3;
        _2.forEach(layer, function(v3) {
          var vRoot = root[v3];
          blockGraph.setNode(vRoot);
          if (u3) {
            var uRoot = root[u3], prevMax = blockGraph.edge(uRoot, vRoot);
            blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g3, v3, u3), prevMax || 0));
          }
          u3 = v3;
        });
      });
      return blockGraph;
    }
    function findSmallestWidthAlignment2(g3, xss) {
      return _2.minBy(_2.values(xss), function(xs) {
        var max2 = Number.NEGATIVE_INFINITY;
        var min2 = Number.POSITIVE_INFINITY;
        _2.forIn(xs, function(x4, v3) {
          var halfWidth = width2(g3, v3) / 2;
          max2 = Math.max(x4 + halfWidth, max2);
          min2 = Math.min(x4 - halfWidth, min2);
        });
        return max2 - min2;
      });
    }
    function alignCoordinates2(xss, alignTo) {
      var alignToVals = _2.values(alignTo), alignToMin = _2.min(alignToVals), alignToMax = _2.max(alignToVals);
      _2.forEach(["u", "d"], function(vert) {
        _2.forEach(["l", "r"], function(horiz) {
          var alignment = vert + horiz, xs = xss[alignment], delta;
          if (xs === alignTo) return;
          var xsVals = _2.values(xs);
          delta = horiz === "l" ? alignToMin - _2.min(xsVals) : alignToMax - _2.max(xsVals);
          if (delta) {
            xss[alignment] = _2.mapValues(xs, function(x4) {
              return x4 + delta;
            });
          }
        });
      });
    }
    function balance2(xss, align) {
      return _2.mapValues(xss.ul, function(ignore, v3) {
        if (align) {
          return xss[align.toLowerCase()][v3];
        } else {
          var xs = _2.sortBy(_2.map(xss, v3));
          return (xs[1] + xs[2]) / 2;
        }
      });
    }
    function positionX2(g3) {
      var layering = util.buildLayerMatrix(g3);
      var conflicts = _2.merge(
        findType1Conflicts2(g3, layering),
        findType2Conflicts2(g3, layering)
      );
      var xss = {};
      var adjustedLayering;
      _2.forEach(["u", "d"], function(vert) {
        adjustedLayering = vert === "u" ? layering : _2.values(layering).reverse();
        _2.forEach(["l", "r"], function(horiz) {
          if (horiz === "r") {
            adjustedLayering = _2.map(adjustedLayering, function(inner) {
              return _2.values(inner).reverse();
            });
          }
          var neighborFn = (vert === "u" ? g3.predecessors : g3.successors).bind(g3);
          var align = verticalAlignment2(g3, adjustedLayering, conflicts, neighborFn);
          var xs = horizontalCompaction2(
            g3,
            adjustedLayering,
            align.root,
            align.align,
            horiz === "r"
          );
          if (horiz === "r") {
            xs = _2.mapValues(xs, function(x4) {
              return -x4;
            });
          }
          xss[vert + horiz] = xs;
        });
      });
      var smallestWidth = findSmallestWidthAlignment2(g3, xss);
      alignCoordinates2(xss, smallestWidth);
      return balance2(xss, g3.graph().align);
    }
    function sep2(nodeSep, edgeSep, reverseSep) {
      return function(g3, v3, w3) {
        var vLabel = g3.node(v3);
        var wLabel = g3.node(w3);
        var sum = 0;
        var delta;
        sum += vLabel.width / 2;
        if (_2.has(vLabel, "labelpos")) {
          switch (vLabel.labelpos.toLowerCase()) {
            case "l":
              delta = -vLabel.width / 2;
              break;
            case "r":
              delta = vLabel.width / 2;
              break;
          }
        }
        if (delta) {
          sum += reverseSep ? delta : -delta;
        }
        delta = 0;
        sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
        sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;
        sum += wLabel.width / 2;
        if (_2.has(wLabel, "labelpos")) {
          switch (wLabel.labelpos.toLowerCase()) {
            case "l":
              delta = wLabel.width / 2;
              break;
            case "r":
              delta = -wLabel.width / 2;
              break;
          }
        }
        if (delta) {
          sum += reverseSep ? delta : -delta;
        }
        delta = 0;
        return sum;
      };
    }
    function width2(g3, v3) {
      return g3.node(v3).width;
    }
  }
});

// node_modules/dagre/lib/position/index.js
var require_position = __commonJS({
  "node_modules/dagre/lib/position/index.js"(exports, module) {
    "use strict";
    var _2 = require_lodash3();
    var util = require_util();
    var positionX2 = require_bk().positionX;
    module.exports = position2;
    function position2(g3) {
      g3 = util.asNonCompoundGraph(g3);
      positionY2(g3);
      _2.forEach(positionX2(g3), function(x4, v3) {
        g3.node(v3).x = x4;
      });
    }
    function positionY2(g3) {
      var layering = util.buildLayerMatrix(g3);
      var rankSep = g3.graph().ranksep;
      var prevY = 0;
      _2.forEach(layering, function(layer) {
        var maxHeight = _2.max(_2.map(layer, function(v3) {
          return g3.node(v3).height;
        }));
        _2.forEach(layer, function(v3) {
          g3.node(v3).y = prevY + maxHeight / 2;
        });
        prevY += maxHeight + rankSep;
      });
    }
  }
});

// node_modules/dagre/lib/layout.js
var require_layout = __commonJS({
  "node_modules/dagre/lib/layout.js"(exports, module) {
    "use strict";
    var _2 = require_lodash3();
    var acyclic = require_acyclic();
    var normalize2 = require_normalize();
    var rank2 = require_rank();
    var normalizeRanks2 = require_util().normalizeRanks;
    var parentDummyChains2 = require_parent_dummy_chains();
    var removeEmptyRanks2 = require_util().removeEmptyRanks;
    var nestingGraph = require_nesting_graph();
    var addBorderSegments2 = require_add_border_segments();
    var coordinateSystem = require_coordinate_system();
    var order2 = require_order();
    var position2 = require_position();
    var util = require_util();
    var Graph5 = require_graphlib2().Graph;
    module.exports = layout2;
    function layout2(g3, opts) {
      var time = opts && opts.debugTiming ? util.time : util.notime;
      time("layout", function() {
        var layoutGraph = time("  buildLayoutGraph", function() {
          return buildLayoutGraph2(g3);
        });
        time("  runLayout", function() {
          runLayout2(layoutGraph, time);
        });
        time("  updateInputGraph", function() {
          updateInputGraph2(g3, layoutGraph);
        });
      });
    }
    function runLayout2(g3, time) {
      time("    makeSpaceForEdgeLabels", function() {
        makeSpaceForEdgeLabels2(g3);
      });
      time("    removeSelfEdges", function() {
        removeSelfEdges2(g3);
      });
      time("    acyclic", function() {
        acyclic.run(g3);
      });
      time("    nestingGraph.run", function() {
        nestingGraph.run(g3);
      });
      time("    rank", function() {
        rank2(util.asNonCompoundGraph(g3));
      });
      time("    injectEdgeLabelProxies", function() {
        injectEdgeLabelProxies2(g3);
      });
      time("    removeEmptyRanks", function() {
        removeEmptyRanks2(g3);
      });
      time("    nestingGraph.cleanup", function() {
        nestingGraph.cleanup(g3);
      });
      time("    normalizeRanks", function() {
        normalizeRanks2(g3);
      });
      time("    assignRankMinMax", function() {
        assignRankMinMax2(g3);
      });
      time("    removeEdgeLabelProxies", function() {
        removeEdgeLabelProxies2(g3);
      });
      time("    normalize.run", function() {
        normalize2.run(g3);
      });
      time("    parentDummyChains", function() {
        parentDummyChains2(g3);
      });
      time("    addBorderSegments", function() {
        addBorderSegments2(g3);
      });
      time("    order", function() {
        order2(g3);
      });
      time("    insertSelfEdges", function() {
        insertSelfEdges2(g3);
      });
      time("    adjustCoordinateSystem", function() {
        coordinateSystem.adjust(g3);
      });
      time("    position", function() {
        position2(g3);
      });
      time("    positionSelfEdges", function() {
        positionSelfEdges2(g3);
      });
      time("    removeBorderNodes", function() {
        removeBorderNodes2(g3);
      });
      time("    normalize.undo", function() {
        normalize2.undo(g3);
      });
      time("    fixupEdgeLabelCoords", function() {
        fixupEdgeLabelCoords2(g3);
      });
      time("    undoCoordinateSystem", function() {
        coordinateSystem.undo(g3);
      });
      time("    translateGraph", function() {
        translateGraph2(g3);
      });
      time("    assignNodeIntersects", function() {
        assignNodeIntersects2(g3);
      });
      time("    reversePoints", function() {
        reversePointsForReversedEdges2(g3);
      });
      time("    acyclic.undo", function() {
        acyclic.undo(g3);
      });
    }
    function updateInputGraph2(inputGraph, layoutGraph) {
      _2.forEach(inputGraph.nodes(), function(v3) {
        var inputLabel = inputGraph.node(v3);
        var layoutLabel = layoutGraph.node(v3);
        if (inputLabel) {
          inputLabel.x = layoutLabel.x;
          inputLabel.y = layoutLabel.y;
          if (layoutGraph.children(v3).length) {
            inputLabel.width = layoutLabel.width;
            inputLabel.height = layoutLabel.height;
          }
        }
      });
      _2.forEach(inputGraph.edges(), function(e2) {
        var inputLabel = inputGraph.edge(e2);
        var layoutLabel = layoutGraph.edge(e2);
        inputLabel.points = layoutLabel.points;
        if (_2.has(layoutLabel, "x")) {
          inputLabel.x = layoutLabel.x;
          inputLabel.y = layoutLabel.y;
        }
      });
      inputGraph.graph().width = layoutGraph.graph().width;
      inputGraph.graph().height = layoutGraph.graph().height;
    }
    var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
    var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
    var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
    var nodeNumAttrs2 = ["width", "height"];
    var nodeDefaults2 = { width: 0, height: 0 };
    var edgeNumAttrs2 = ["minlen", "weight", "width", "height", "labeloffset"];
    var edgeDefaults2 = {
      minlen: 1,
      weight: 1,
      width: 0,
      height: 0,
      labeloffset: 10,
      labelpos: "r"
    };
    var edgeAttrs2 = ["labelpos"];
    function buildLayoutGraph2(inputGraph) {
      var g3 = new Graph5({ multigraph: true, compound: true });
      var graph = canonicalize2(inputGraph.graph());
      g3.setGraph(_2.merge(
        {},
        graphDefaults,
        selectNumberAttrs2(graph, graphNumAttrs),
        _2.pick(graph, graphAttrs)
      ));
      _2.forEach(inputGraph.nodes(), function(v3) {
        var node = canonicalize2(inputGraph.node(v3));
        g3.setNode(v3, _2.defaults(selectNumberAttrs2(node, nodeNumAttrs2), nodeDefaults2));
        g3.setParent(v3, inputGraph.parent(v3));
      });
      _2.forEach(inputGraph.edges(), function(e2) {
        var edge = canonicalize2(inputGraph.edge(e2));
        g3.setEdge(e2, _2.merge(
          {},
          edgeDefaults2,
          selectNumberAttrs2(edge, edgeNumAttrs2),
          _2.pick(edge, edgeAttrs2)
        ));
      });
      return g3;
    }
    function makeSpaceForEdgeLabels2(g3) {
      var graph = g3.graph();
      graph.ranksep /= 2;
      _2.forEach(g3.edges(), function(e2) {
        var edge = g3.edge(e2);
        edge.minlen *= 2;
        if (edge.labelpos.toLowerCase() !== "c") {
          if (graph.rankdir === "TB" || graph.rankdir === "BT") {
            edge.width += edge.labeloffset;
          } else {
            edge.height += edge.labeloffset;
          }
        }
      });
    }
    function injectEdgeLabelProxies2(g3) {
      _2.forEach(g3.edges(), function(e2) {
        var edge = g3.edge(e2);
        if (edge.width && edge.height) {
          var v3 = g3.node(e2.v);
          var w3 = g3.node(e2.w);
          var label = { rank: (w3.rank - v3.rank) / 2 + v3.rank, e: e2 };
          util.addDummyNode(g3, "edge-proxy", label, "_ep");
        }
      });
    }
    function assignRankMinMax2(g3) {
      var maxRank2 = 0;
      _2.forEach(g3.nodes(), function(v3) {
        var node = g3.node(v3);
        if (node.borderTop) {
          node.minRank = g3.node(node.borderTop).rank;
          node.maxRank = g3.node(node.borderBottom).rank;
          maxRank2 = _2.max(maxRank2, node.maxRank);
        }
      });
      g3.graph().maxRank = maxRank2;
    }
    function removeEdgeLabelProxies2(g3) {
      _2.forEach(g3.nodes(), function(v3) {
        var node = g3.node(v3);
        if (node.dummy === "edge-proxy") {
          g3.edge(node.e).labelRank = node.rank;
          g3.removeNode(v3);
        }
      });
    }
    function translateGraph2(g3) {
      var minX = Number.POSITIVE_INFINITY;
      var maxX = 0;
      var minY = Number.POSITIVE_INFINITY;
      var maxY = 0;
      var graphLabel = g3.graph();
      var marginX = graphLabel.marginx || 0;
      var marginY = graphLabel.marginy || 0;
      function getExtremes(attrs) {
        var x4 = attrs.x;
        var y4 = attrs.y;
        var w3 = attrs.width;
        var h3 = attrs.height;
        minX = Math.min(minX, x4 - w3 / 2);
        maxX = Math.max(maxX, x4 + w3 / 2);
        minY = Math.min(minY, y4 - h3 / 2);
        maxY = Math.max(maxY, y4 + h3 / 2);
      }
      _2.forEach(g3.nodes(), function(v3) {
        getExtremes(g3.node(v3));
      });
      _2.forEach(g3.edges(), function(e2) {
        var edge = g3.edge(e2);
        if (_2.has(edge, "x")) {
          getExtremes(edge);
        }
      });
      minX -= marginX;
      minY -= marginY;
      _2.forEach(g3.nodes(), function(v3) {
        var node = g3.node(v3);
        node.x -= minX;
        node.y -= minY;
      });
      _2.forEach(g3.edges(), function(e2) {
        var edge = g3.edge(e2);
        _2.forEach(edge.points, function(p3) {
          p3.x -= minX;
          p3.y -= minY;
        });
        if (_2.has(edge, "x")) {
          edge.x -= minX;
        }
        if (_2.has(edge, "y")) {
          edge.y -= minY;
        }
      });
      graphLabel.width = maxX - minX + marginX;
      graphLabel.height = maxY - minY + marginY;
    }
    function assignNodeIntersects2(g3) {
      _2.forEach(g3.edges(), function(e2) {
        var edge = g3.edge(e2);
        var nodeV = g3.node(e2.v);
        var nodeW = g3.node(e2.w);
        var p1, p22;
        if (!edge.points) {
          edge.points = [];
          p1 = nodeW;
          p22 = nodeV;
        } else {
          p1 = edge.points[0];
          p22 = edge.points[edge.points.length - 1];
        }
        edge.points.unshift(util.intersectRect(nodeV, p1));
        edge.points.push(util.intersectRect(nodeW, p22));
      });
    }
    function fixupEdgeLabelCoords2(g3) {
      _2.forEach(g3.edges(), function(e2) {
        var edge = g3.edge(e2);
        if (_2.has(edge, "x")) {
          if (edge.labelpos === "l" || edge.labelpos === "r") {
            edge.width -= edge.labeloffset;
          }
          switch (edge.labelpos) {
            case "l":
              edge.x -= edge.width / 2 + edge.labeloffset;
              break;
            case "r":
              edge.x += edge.width / 2 + edge.labeloffset;
              break;
          }
        }
      });
    }
    function reversePointsForReversedEdges2(g3) {
      _2.forEach(g3.edges(), function(e2) {
        var edge = g3.edge(e2);
        if (edge.reversed) {
          edge.points.reverse();
        }
      });
    }
    function removeBorderNodes2(g3) {
      _2.forEach(g3.nodes(), function(v3) {
        if (g3.children(v3).length) {
          var node = g3.node(v3);
          var t3 = g3.node(node.borderTop);
          var b3 = g3.node(node.borderBottom);
          var l3 = g3.node(_2.last(node.borderLeft));
          var r3 = g3.node(_2.last(node.borderRight));
          node.width = Math.abs(r3.x - l3.x);
          node.height = Math.abs(b3.y - t3.y);
          node.x = l3.x + node.width / 2;
          node.y = t3.y + node.height / 2;
        }
      });
      _2.forEach(g3.nodes(), function(v3) {
        if (g3.node(v3).dummy === "border") {
          g3.removeNode(v3);
        }
      });
    }
    function removeSelfEdges2(g3) {
      _2.forEach(g3.edges(), function(e2) {
        if (e2.v === e2.w) {
          var node = g3.node(e2.v);
          if (!node.selfEdges) {
            node.selfEdges = [];
          }
          node.selfEdges.push({ e: e2, label: g3.edge(e2) });
          g3.removeEdge(e2);
        }
      });
    }
    function insertSelfEdges2(g3) {
      var layers = util.buildLayerMatrix(g3);
      _2.forEach(layers, function(layer) {
        var orderShift = 0;
        _2.forEach(layer, function(v3, i2) {
          var node = g3.node(v3);
          node.order = i2 + orderShift;
          _2.forEach(node.selfEdges, function(selfEdge) {
            util.addDummyNode(g3, "selfedge", {
              width: selfEdge.label.width,
              height: selfEdge.label.height,
              rank: node.rank,
              order: i2 + ++orderShift,
              e: selfEdge.e,
              label: selfEdge.label
            }, "_se");
          });
          delete node.selfEdges;
        });
      });
    }
    function positionSelfEdges2(g3) {
      _2.forEach(g3.nodes(), function(v3) {
        var node = g3.node(v3);
        if (node.dummy === "selfedge") {
          var selfNode = g3.node(node.e.v);
          var x4 = selfNode.x + selfNode.width / 2;
          var y4 = selfNode.y;
          var dx = node.x - x4;
          var dy = selfNode.height / 2;
          g3.setEdge(node.e, node.label);
          g3.removeNode(v3);
          node.label.points = [
            { x: x4 + 2 * dx / 3, y: y4 - dy },
            { x: x4 + 5 * dx / 6, y: y4 - dy },
            { x: x4 + dx, y: y4 },
            { x: x4 + 5 * dx / 6, y: y4 + dy },
            { x: x4 + 2 * dx / 3, y: y4 + dy }
          ];
          node.label.x = node.x;
          node.label.y = node.y;
        }
      });
    }
    function selectNumberAttrs2(obj, attrs) {
      return _2.mapValues(_2.pick(obj, attrs), Number);
    }
    function canonicalize2(attrs) {
      var newAttrs = {};
      _2.forEach(attrs, function(v3, k2) {
        newAttrs[k2.toLowerCase()] = v3;
      });
      return newAttrs;
    }
  }
});

// node_modules/dagre/lib/debug.js
var require_debug = __commonJS({
  "node_modules/dagre/lib/debug.js"(exports, module) {
    var _2 = require_lodash3();
    var util = require_util();
    var Graph5 = require_graphlib2().Graph;
    module.exports = {
      debugOrdering
    };
    function debugOrdering(g3) {
      var layerMatrix = util.buildLayerMatrix(g3);
      var h3 = new Graph5({ compound: true, multigraph: true }).setGraph({});
      _2.forEach(g3.nodes(), function(v3) {
        h3.setNode(v3, { label: v3 });
        h3.setParent(v3, "layer" + g3.node(v3).rank);
      });
      _2.forEach(g3.edges(), function(e2) {
        h3.setEdge(e2.v, e2.w, {}, e2.name);
      });
      _2.forEach(layerMatrix, function(layer, i2) {
        var layerV = "layer" + i2;
        h3.setNode(layerV, { rank: "same" });
        _2.reduce(layer, function(u3, v3) {
          h3.setEdge(u3, v3, { style: "invis" });
          return v3;
        });
      });
      return h3;
    }
  }
});

// node_modules/dagre/lib/version.js
var require_version2 = __commonJS({
  "node_modules/dagre/lib/version.js"(exports, module) {
    module.exports = "0.8.5";
  }
});

// node_modules/dagre/index.js
var require_dagre = __commonJS({
  "node_modules/dagre/index.js"(exports, module) {
    module.exports = {
      graphlib: require_graphlib2(),
      layout: require_layout(),
      debug: require_debug(),
      util: {
        time: require_util().time,
        notime: require_util().notime
      },
      version: require_version2()
    };
  }
});

// node_modules/@antv/g6/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  AntVDagreLayout: () => AntVDagreLayout,
  AutoAdaptLabel: () => AutoAdaptLabel,
  Background: () => Background,
  Badge: () => Badge,
  BaseBehavior: () => BaseBehavior,
  BaseCombo: () => BaseCombo,
  BaseEdge: () => BaseEdge,
  BaseLayout: () => BaseLayout,
  BaseNode: () => BaseNode,
  BasePlugin: () => BasePlugin,
  BaseShape: () => BaseShape,
  BaseTransform: () => BaseTransform,
  BrushSelect: () => BrushSelect,
  BubbleSets: () => BubbleSets2,
  CameraSetting: () => CameraSetting,
  Canvas: () => Canvas2,
  CanvasEvent: () => CanvasEvent2,
  Circle: () => Circle2,
  CircleCombo: () => CircleCombo,
  CircularLayout: () => CircularLayout,
  ClickSelect: () => ClickSelect,
  CollapseExpand: () => CollapseExpand,
  ComboCombinedLayout: () => ComboCombinedLayout,
  ComboEvent: () => ComboEvent,
  CommonEvent: () => CommonEvent,
  CompactBoxLayout: () => H,
  ConcentricLayout: () => ConcentricLayout,
  ContainerEvent: () => ContainerEvent,
  Contextmenu: () => Contextmenu,
  CreateEdge: () => CreateEdge,
  Cubic: () => Cubic,
  CubicHorizontal: () => CubicHorizontal,
  CubicRadial: () => CubicRadial,
  CubicVertical: () => CubicVertical,
  D3ForceLayout: () => D3ForceLayout,
  DagreLayout: () => DagreLayout,
  DendrogramLayout: () => S,
  Diamond: () => Diamond,
  Donut: () => Donut,
  DragCanvas: () => DragCanvas,
  DragElement: () => DragElement,
  DragElementForce: () => DragElementForce,
  EdgeBundling: () => EdgeBundling,
  EdgeEvent: () => EdgeEvent,
  EdgeFilterLens: () => EdgeFilterLens,
  Ellipse: () => Ellipse2,
  ExtensionCategory: () => ExtensionCategory,
  FishboneLayout: () => FishboneLayout,
  Fisheye: () => Fisheye,
  FixElementSize: () => FixElementSize,
  FocusElement: () => FocusElement,
  ForceAtlas2Layout: () => ForceAtlas2Layout,
  ForceLayout: () => ForceLayout,
  FruchtermanLayout: () => FruchtermanLayout,
  Fullscreen: () => Fullscreen,
  Graph: () => Graph3,
  GraphEvent: () => GraphEvent,
  GridLayout: () => GridLayout,
  GridLine: () => GridLine,
  HTML: () => HTML2,
  Hexagon: () => Hexagon,
  History: () => History2,
  HistoryEvent: () => HistoryEvent,
  HoverActivate: () => HoverActivate,
  Hull: () => Hull,
  Icon: () => Icon,
  Image: () => Image4,
  IndentedLayout: () => C,
  Label: () => Label,
  LassoSelect: () => LassoSelect,
  Legend: () => Legend,
  Line: () => Line2,
  MDSLayout: () => MDSLayout,
  MapNodeSize: () => MapNodeSize,
  MindmapLayout: () => F,
  Minimap: () => Minimap,
  NodeEvent: () => NodeEvent,
  OptimizeViewportTransform: () => OptimizeViewportTransform,
  PlaceRadialLabels: () => PlaceRadialLabels,
  Polyline: () => Polyline2,
  ProcessParallelEdges: () => ProcessParallelEdges,
  Quadratic: () => Quadratic,
  RadialLayout: () => RadialLayout,
  RandomLayout: () => RandomLayout,
  Rect: () => Rect2,
  RectCombo: () => RectCombo,
  ScrollCanvas: () => ScrollCanvas,
  Shortcut: () => Shortcut,
  SnakeLayout: () => SnakeLayout,
  Snapline: () => Snapline,
  Star: () => Star,
  Timebar: () => Timebar2,
  Title: () => Title,
  Toolbar: () => Toolbar,
  Tooltip: () => Tooltip2,
  Triangle: () => Triangle,
  Watermark: () => Watermark,
  ZoomCanvas: () => ZoomCanvas,
  effect: () => effect,
  getExtension: () => getExtension,
  getExtensions: () => getExtensions,
  iconfont: () => iconfont,
  idOf: () => idOf,
  invokeLayoutMethod: () => invokeLayoutMethod,
  isCollapsed: () => isCollapsed,
  omitStyleProps: () => omitStyleProps,
  parseSize: () => parseSize,
  positionOf: () => positionOf,
  register: () => register,
  setVisibility: () => setVisibility,
  subStyleProps: () => subStyleProps,
  treeToGraphData: () => treeToGraphData,
  version: () => version
});

// node_modules/@antv/g6/esm/constants/animation.js
var DEFAULT_ANIMATION_OPTIONS = {
  duration: 500
};
var DEFAULT_ELEMENTS_ANIMATION_OPTIONS = {
  duration: 1e3,
  easing: "cubic-bezier(0.250, 0.460, 0.450, 0.940)",
  iterations: 1,
  fill: "both"
};

// node_modules/@antv/g6/esm/constants/change.js
var ChangeType;
(function(ChangeType2) {
  ChangeType2["NodeAdded"] = "NodeAdded";
  ChangeType2["NodeUpdated"] = "NodeUpdated";
  ChangeType2["NodeRemoved"] = "NodeRemoved";
  ChangeType2["EdgeAdded"] = "EdgeAdded";
  ChangeType2["EdgeUpdated"] = "EdgeUpdated";
  ChangeType2["EdgeRemoved"] = "EdgeRemoved";
  ChangeType2["ComboAdded"] = "ComboAdded";
  ChangeType2["ComboUpdated"] = "ComboUpdated";
  ChangeType2["ComboRemoved"] = "ComboRemoved";
})(ChangeType || (ChangeType = {}));

// node_modules/@antv/g6/esm/constants/events/animation.js
var AnimationType;
(function(AnimationType2) {
  AnimationType2["DRAW"] = "draw";
  AnimationType2["COLLAPSE"] = "collapse";
  AnimationType2["EXPAND"] = "expand";
  AnimationType2["TRANSFORM"] = "transform";
})(AnimationType || (AnimationType = {}));

// node_modules/@antv/g6/esm/constants/events/canvas.js
var CanvasEvent2;
(function(CanvasEvent3) {
  CanvasEvent3["CLICK"] = "canvas:click";
  CanvasEvent3["DBLCLICK"] = "canvas:dblclick";
  CanvasEvent3["POINTER_OVER"] = "canvas:pointerover";
  CanvasEvent3["POINTER_LEAVE"] = "canvas:pointerleave";
  CanvasEvent3["POINTER_ENTER"] = "canvas:pointerenter";
  CanvasEvent3["POINTER_MOVE"] = "canvas:pointermove";
  CanvasEvent3["POINTER_OUT"] = "canvas:pointerout";
  CanvasEvent3["POINTER_DOWN"] = "canvas:pointerdown";
  CanvasEvent3["POINTER_UP"] = "canvas:pointerup";
  CanvasEvent3["CONTEXT_MENU"] = "canvas:contextmenu";
  CanvasEvent3["DRAG_START"] = "canvas:dragstart";
  CanvasEvent3["DRAG"] = "canvas:drag";
  CanvasEvent3["DRAG_END"] = "canvas:dragend";
  CanvasEvent3["DRAG_ENTER"] = "canvas:dragenter";
  CanvasEvent3["DRAG_OVER"] = "canvas:dragover";
  CanvasEvent3["DRAG_LEAVE"] = "canvas:dragleave";
  CanvasEvent3["DROP"] = "canvas:drop";
  CanvasEvent3["WHEEL"] = "canvas:wheel";
})(CanvasEvent2 || (CanvasEvent2 = {}));

// node_modules/@antv/g6/esm/constants/events/combo.js
var ComboEvent;
(function(ComboEvent2) {
  ComboEvent2["CLICK"] = "combo:click";
  ComboEvent2["DBLCLICK"] = "combo:dblclick";
  ComboEvent2["POINTER_OVER"] = "combo:pointerover";
  ComboEvent2["POINTER_LEAVE"] = "combo:pointerleave";
  ComboEvent2["POINTER_ENTER"] = "combo:pointerenter";
  ComboEvent2["POINTER_MOVE"] = "combo:pointermove";
  ComboEvent2["POINTER_OUT"] = "combo:pointerout";
  ComboEvent2["POINTER_DOWN"] = "combo:pointerdown";
  ComboEvent2["POINTER_UP"] = "combo:pointerup";
  ComboEvent2["CONTEXT_MENU"] = "combo:contextmenu";
  ComboEvent2["DRAG_START"] = "combo:dragstart";
  ComboEvent2["DRAG"] = "combo:drag";
  ComboEvent2["DRAG_END"] = "combo:dragend";
  ComboEvent2["DRAG_ENTER"] = "combo:dragenter";
  ComboEvent2["DRAG_OVER"] = "combo:dragover";
  ComboEvent2["DRAG_LEAVE"] = "combo:dragleave";
  ComboEvent2["DROP"] = "combo:drop";
})(ComboEvent || (ComboEvent = {}));

// node_modules/@antv/g6/esm/constants/events/common.js
var CommonEvent;
(function(CommonEvent2) {
  CommonEvent2["CLICK"] = "click";
  CommonEvent2["DBLCLICK"] = "dblclick";
  CommonEvent2["POINTER_OVER"] = "pointerover";
  CommonEvent2["POINTER_LEAVE"] = "pointerleave";
  CommonEvent2["POINTER_ENTER"] = "pointerenter";
  CommonEvent2["POINTER_MOVE"] = "pointermove";
  CommonEvent2["POINTER_OUT"] = "pointerout";
  CommonEvent2["POINTER_DOWN"] = "pointerdown";
  CommonEvent2["POINTER_UP"] = "pointerup";
  CommonEvent2["CONTEXT_MENU"] = "contextmenu";
  CommonEvent2["DRAG_START"] = "dragstart";
  CommonEvent2["DRAG"] = "drag";
  CommonEvent2["DRAG_END"] = "dragend";
  CommonEvent2["DRAG_ENTER"] = "dragenter";
  CommonEvent2["DRAG_OVER"] = "dragover";
  CommonEvent2["DRAG_LEAVE"] = "dragleave";
  CommonEvent2["DROP"] = "drop";
  CommonEvent2["KEY_DOWN"] = "keydown";
  CommonEvent2["KEY_UP"] = "keyup";
  CommonEvent2["WHEEL"] = "wheel";
  CommonEvent2["PINCH"] = "pinch";
})(CommonEvent || (CommonEvent = {}));

// node_modules/@antv/g6/esm/constants/events/container.js
var ContainerEvent;
(function(ContainerEvent2) {
  ContainerEvent2["KEY_DOWN"] = "keydown";
  ContainerEvent2["KEY_UP"] = "keyup";
})(ContainerEvent || (ContainerEvent = {}));

// node_modules/@antv/g6/esm/constants/events/edge.js
var EdgeEvent;
(function(EdgeEvent2) {
  EdgeEvent2["CLICK"] = "edge:click";
  EdgeEvent2["DBLCLICK"] = "edge:dblclick";
  EdgeEvent2["POINTER_OVER"] = "edge:pointerover";
  EdgeEvent2["POINTER_LEAVE"] = "edge:pointerleave";
  EdgeEvent2["POINTER_ENTER"] = "edge:pointerenter";
  EdgeEvent2["POINTER_MOVE"] = "edge:pointermove";
  EdgeEvent2["POINTER_OUT"] = "edge:pointerout";
  EdgeEvent2["POINTER_DOWN"] = "edge:pointerdown";
  EdgeEvent2["POINTER_UP"] = "edge:pointerup";
  EdgeEvent2["CONTEXT_MENU"] = "edge:contextmenu";
  EdgeEvent2["DRAG_ENTER"] = "edge:dragenter";
  EdgeEvent2["DRAG_OVER"] = "edge:dragover";
  EdgeEvent2["DRAG_LEAVE"] = "edge:dragleave";
  EdgeEvent2["DROP"] = "edge:drop";
})(EdgeEvent || (EdgeEvent = {}));

// node_modules/@antv/g6/esm/constants/events/graph.js
var GraphEvent;
(function(GraphEvent2) {
  GraphEvent2["BEFORE_CANVAS_INIT"] = "beforecanvasinit";
  GraphEvent2["AFTER_CANVAS_INIT"] = "aftercanvasinit";
  GraphEvent2["BEFORE_SIZE_CHANGE"] = "beforesizechange";
  GraphEvent2["AFTER_SIZE_CHANGE"] = "aftersizechange";
  GraphEvent2["BEFORE_ELEMENT_CREATE"] = "beforeelementcreate";
  GraphEvent2["AFTER_ELEMENT_CREATE"] = "afterelementcreate";
  GraphEvent2["BEFORE_ELEMENT_UPDATE"] = "beforeelementupdate";
  GraphEvent2["AFTER_ELEMENT_UPDATE"] = "afterelementupdate";
  GraphEvent2["BEFORE_ELEMENT_DESTROY"] = "beforeelementdestroy";
  GraphEvent2["AFTER_ELEMENT_DESTROY"] = "afterelementdestroy";
  GraphEvent2["BEFORE_ELEMENT_TRANSLATE"] = "beforeelementtranslate";
  GraphEvent2["AFTER_ELEMENT_TRANSLATE"] = "afterelementtranslate";
  GraphEvent2["BEFORE_DRAW"] = "beforedraw";
  GraphEvent2["AFTER_DRAW"] = "afterdraw";
  GraphEvent2["BEFORE_RENDER"] = "beforerender";
  GraphEvent2["AFTER_RENDER"] = "afterrender";
  GraphEvent2["BEFORE_ANIMATE"] = "beforeanimate";
  GraphEvent2["AFTER_ANIMATE"] = "afteranimate";
  GraphEvent2["BEFORE_LAYOUT"] = "beforelayout";
  GraphEvent2["AFTER_LAYOUT"] = "afterlayout";
  GraphEvent2["BEFORE_STAGE_LAYOUT"] = "beforestagelayout";
  GraphEvent2["AFTER_STAGE_LAYOUT"] = "afterstagelayout";
  GraphEvent2["BEFORE_TRANSFORM"] = "beforetransform";
  GraphEvent2["AFTER_TRANSFORM"] = "aftertransform";
  GraphEvent2["BATCH_START"] = "batchstart";
  GraphEvent2["BATCH_END"] = "batchend";
  GraphEvent2["BEFORE_DESTROY"] = "beforedestroy";
  GraphEvent2["AFTER_DESTROY"] = "afterdestroy";
  GraphEvent2["BEFORE_RENDERER_CHANGE"] = "beforerendererchange";
  GraphEvent2["AFTER_RENDERER_CHANGE"] = "afterrendererchange";
})(GraphEvent || (GraphEvent = {}));

// node_modules/@antv/g6/esm/constants/events/history.js
var HistoryEvent;
(function(HistoryEvent2) {
  HistoryEvent2["UNDO"] = "undo";
  HistoryEvent2["REDO"] = "redo";
  HistoryEvent2["CANCEL"] = "cancel";
  HistoryEvent2["ADD"] = "add";
  HistoryEvent2["CLEAR"] = "clear";
  HistoryEvent2["CHANGE"] = "change";
})(HistoryEvent || (HistoryEvent = {}));

// node_modules/@antv/g6/esm/constants/events/node.js
var NodeEvent;
(function(NodeEvent2) {
  NodeEvent2["CLICK"] = "node:click";
  NodeEvent2["DBLCLICK"] = "node:dblclick";
  NodeEvent2["POINTER_OVER"] = "node:pointerover";
  NodeEvent2["POINTER_LEAVE"] = "node:pointerleave";
  NodeEvent2["POINTER_ENTER"] = "node:pointerenter";
  NodeEvent2["POINTER_MOVE"] = "node:pointermove";
  NodeEvent2["POINTER_OUT"] = "node:pointerout";
  NodeEvent2["POINTER_DOWN"] = "node:pointerdown";
  NodeEvent2["POINTER_UP"] = "node:pointerup";
  NodeEvent2["CONTEXT_MENU"] = "node:contextmenu";
  NodeEvent2["DRAG_START"] = "node:dragstart";
  NodeEvent2["DRAG"] = "node:drag";
  NodeEvent2["DRAG_END"] = "node:dragend";
  NodeEvent2["DRAG_ENTER"] = "node:dragenter";
  NodeEvent2["DRAG_OVER"] = "node:dragover";
  NodeEvent2["DRAG_LEAVE"] = "node:dragleave";
  NodeEvent2["DROP"] = "node:drop";
})(NodeEvent || (NodeEvent = {}));

// node_modules/@antv/g6/esm/constants/graphlib.js
var COMBO_KEY = "combo";
var TREE_KEY = "tree";

// node_modules/@antv/g6/esm/constants/registry.js
var ExtensionCategory;
(function(ExtensionCategory2) {
  ExtensionCategory2["NODE"] = "node";
  ExtensionCategory2["EDGE"] = "edge";
  ExtensionCategory2["COMBO"] = "combo";
  ExtensionCategory2["THEME"] = "theme";
  ExtensionCategory2["PALETTE"] = "palette";
  ExtensionCategory2["LAYOUT"] = "layout";
  ExtensionCategory2["BEHAVIOR"] = "behavior";
  ExtensionCategory2["PLUGIN"] = "plugin";
  ExtensionCategory2["ANIMATION"] = "animation";
  ExtensionCategory2["TRANSFORM"] = "transform";
  ExtensionCategory2["SHAPE"] = "shape";
})(ExtensionCategory || (ExtensionCategory = {}));

// node_modules/@antv/g6/esm/registry/store.js
var EXTENSION_REGISTRY = {
  animation: {},
  behavior: {},
  combo: {},
  edge: {},
  layout: {},
  node: {},
  palette: {},
  theme: {},
  plugin: {},
  transform: {},
  shape: {}
};

// node_modules/@antv/g6/esm/registry/get.js
function getExtension(category, type) {
  var _a;
  const extension = (_a = EXTENSION_REGISTRY[category]) === null || _a === void 0 ? void 0 : _a[type];
  if (extension) {
    return extension;
  }
  return void 0;
}
function getExtensions(category) {
  return EXTENSION_REGISTRY[category];
}

// node_modules/@antv/g6/esm/version.js
var version = "5.0.51";

// node_modules/@antv/g6/esm/utils/print.js
var BRAND = "G6";
function format(message) {
  return `[${BRAND} v${version}] ${message}`;
}
var print = {
  mute: false,
  debug: (message) => {
    !print.mute && console.debug(format(message));
  },
  info: (message) => {
    !print.mute && console.info(format(message));
  },
  warn: (message) => {
    !print.mute && console.warn(format(message));
  },
  error: (message) => {
    !print.mute && console.error(format(message));
  }
};

// node_modules/@antv/g6/esm/utils/theme.js
function themeOf(options) {
  const { theme } = options;
  if (!theme)
    return {};
  const themeOptions = getExtension(ExtensionCategory.THEME, theme);
  if (themeOptions)
    return themeOptions;
  print.warn(`The theme of ${theme} is not registered.`);
  return {};
}

// node_modules/@antv/g6/esm/utils/animation.js
function createAnimationsProxy(args1, args2) {
  if (Array.isArray(args1) && args1.length === 0)
    return null;
  const sourceAnimation = Array.isArray(args1) ? args1[0] : args1;
  const targetAnimations = Array.isArray(args1) ? args1.slice(1) : args2 || [];
  return new Proxy(sourceAnimation, {
    get(target, propKey) {
      if (typeof target[propKey] === "function" && !["onframe", "onfinish"].includes(propKey)) {
        return (...args) => {
          target[propKey](...args);
          targetAnimations.forEach((animation) => {
            var _a;
            return (_a = animation[propKey]) === null || _a === void 0 ? void 0 : _a.call(animation, ...args);
          });
        };
      }
      if (propKey === "finished") {
        return Promise.all([sourceAnimation.finished, ...targetAnimations.map((animation) => animation.finished)]);
      }
      return Reflect.get(target, propKey);
    },
    set(target, propKey, value) {
      if (!["onframe", "onfinish"].includes(propKey)) {
        targetAnimations.forEach((animation) => {
          animation[propKey] = value;
        });
      }
      return Reflect.set(target, propKey, value);
    }
  });
}
function preprocessKeyframes(keyframes) {
  const propertyIndexedKeyframes = keyframes.reduce((acc, kf) => {
    Object.entries(kf).forEach(([key, value]) => {
      if (acc[key] === void 0)
        acc[key] = [value];
      else
        acc[key].push(value);
    });
    return acc;
  }, {});
  Object.entries(propertyIndexedKeyframes).forEach(([key, values3]) => {
    if (
      //  / property value must exist in every frame
      values3.length !== keyframes.length || //  / property value cannot be empty
      values3.some((value) => isNil(value)) || //  / property value must not be exactly the same
      //  / property value can be the reserved property
      values3.every((value) => !["sourceNode", "targetNode", "childrenNode"].includes(key) && is_equal_default(value, values3[0]))
    ) {
      delete propertyIndexedKeyframes[key];
    }
  });
  const output = Object.entries(propertyIndexedKeyframes).reduce((acc, [key, values3]) => {
    values3.forEach((value, index) => {
      if (!acc[index])
        acc[index] = { [key]: value };
      else
        acc[index][key] = value;
    });
    return acc;
  }, []);
  if (keyframes.length !== 0 && output.length === 0)
    output.push(...[{ _: 0 }, { _: 0 }]);
  return output;
}
function inferDefaultValue(name) {
  switch (name) {
    case "opacity":
      return 1;
    case "x":
    case "y":
    case "z":
    case "zIndex":
      return 0;
    case "visibility":
      return "visible";
    case "collapsed":
      return false;
    case "states":
      return [];
    default:
      return void 0;
  }
}
function getAnimationOptions(options, localAnimation) {
  const { animation } = options;
  if (animation === false || localAnimation === false)
    return false;
  const effectTiming = Object.assign({}, DEFAULT_ANIMATION_OPTIONS);
  if (is_object_default(animation))
    Object.assign(effectTiming, animation);
  if (is_object_default(localAnimation))
    Object.assign(effectTiming, localAnimation);
  return effectTiming;
}
function animationOf(options) {
  if (typeof options === "string") {
    const animation = getExtension(ExtensionCategory.ANIMATION, options);
    if (animation)
      return animation;
    print.warn(`The animation of ${options} is not registered.`);
    return [];
  }
  return options;
}
function getElementAnimationOptions(options, elementType, stage, localAnimation) {
  var _a, _b;
  const { animation: globalAnimation } = options;
  if (globalAnimation === false || localAnimation === false)
    return [];
  const userElementAnimation = (_a = options === null || options === void 0 ? void 0 : options[elementType]) === null || _a === void 0 ? void 0 : _a.animation;
  if (userElementAnimation === false)
    return [];
  const useElementStageAnimation = userElementAnimation === null || userElementAnimation === void 0 ? void 0 : userElementAnimation[stage];
  if (useElementStageAnimation === false)
    return [];
  const themeElementAnimation = (_b = themeOf(options)[elementType]) === null || _b === void 0 ? void 0 : _b.animation;
  const combine = (_2 = []) => animationOf(_2).map((animation) => Object.assign(Object.assign(Object.assign(Object.assign({}, DEFAULT_ELEMENTS_ANIMATION_OPTIONS), is_object_default(globalAnimation) && globalAnimation), animation), is_object_default(localAnimation) && localAnimation));
  if (useElementStageAnimation)
    return combine(useElementStageAnimation);
  if (!themeElementAnimation)
    return [];
  const themeElementStageAnimation = themeElementAnimation[stage];
  if (themeElementStageAnimation === false)
    return [];
  return combine(themeElementStageAnimation);
}

// node_modules/@antv/g6/esm/utils/transform.js
function replaceTranslateInTransform(x4, y4, z4, transform = []) {
  if (!transform && x4 === 0 && y4 === 0 && z4 === 0)
    return null;
  if (Array.isArray(transform)) {
    let translateIndex = -1;
    const newTransform = [];
    for (let i2 = 0; i2 < transform.length; i2++) {
      const t3 = transform[i2];
      if (t3[0] === "translate") {
        if (t3[1] === x4 && t3[2] === y4)
          return null;
        translateIndex = i2;
        newTransform.push(["translate", x4, y4]);
      } else if (t3[0] === "translate3d") {
        if (t3[1] === x4 && t3[2] === y4 && t3[3] === z4)
          return null;
        translateIndex = i2;
        newTransform.push(["translate3d", x4, y4, z4 !== null && z4 !== void 0 ? z4 : 0]);
      } else {
        newTransform.push(t3);
      }
    }
    if (translateIndex === -1) {
      newTransform.splice(0, 0, isNumber(z4) ? ["translate3d", x4, y4, z4 !== null && z4 !== void 0 ? z4 : 0] : ["translate", x4, y4]);
    }
    if (newTransform.length === 0)
      return null;
    return newTransform;
  }
  const removedTranslate = transform ? transform.replace(/translate(3d)?\([^)]*\)/g, "") : "";
  if (z4 === 0) {
    return `translate(${x4}, ${y4})${removedTranslate}`;
  } else {
    return `translate3d(${x4}, ${y4}, ${z4})${removedTranslate}`;
  }
}

// node_modules/@antv/g6/esm/animations/executor.js
var __rest2 = function(s2, e2) {
  var t3 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t3[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t3[p3[i2]] = s2[p3[i2]];
    }
  return t3;
};
var executor = (element, keyframes, options) => {
  if (!options.length)
    return null;
  const [originalStyle, modifiedStyle] = keyframes;
  const getKeyframeStyle = (shapeID) => {
    var _a;
    if (shapeID) {
      const shape = element.getShape(shapeID);
      if (!shape)
        return null;
      const name = `get${upper_first_default(shapeID)}Style`;
      const styler = ((_a = element === null || element === void 0 ? void 0 : element[name]) === null || _a === void 0 ? void 0 : _a.bind(element)) || ((attrs) => attrs);
      const fromStyle = (styler === null || styler === void 0 ? void 0 : styler(originalStyle)) || {};
      const toStyle = (styler === null || styler === void 0 ? void 0 : styler(modifiedStyle)) || {};
      return { shape, fromStyle, toStyle };
    } else {
      const shape = element;
      return { shape, fromStyle: originalStyle, toStyle: modifiedStyle };
    }
  };
  let mainResult;
  const subResults = options.map((_a) => {
    var { fields, shape: shapeID, states: enabledStates } = _a, effectTiming = __rest2(_a, ["fields", "shape", "states"]);
    const keyframeStyle = getKeyframeStyle(shapeID);
    if (!keyframeStyle)
      return null;
    const { shape, fromStyle, toStyle } = keyframeStyle;
    const keyframes2 = [{}, {}];
    fields.forEach((attr) => {
      var _a2, _b;
      Object.assign(keyframes2[0], { [attr]: (_a2 = fromStyle[attr]) !== null && _a2 !== void 0 ? _a2 : inferDefaultValue(attr) });
      Object.assign(keyframes2[1], { [attr]: (_b = toStyle[attr]) !== null && _b !== void 0 ? _b : inferDefaultValue(attr) });
    });
    if (keyframes2.some((keyframe) => Object.keys(keyframe).some((attr) => ["x", "y", "z"].includes(attr)))) {
      const { x: x4 = 0, y: y4 = 0, z: z4, transform = "" } = shape.attributes || {};
      keyframes2.forEach((keyframe) => {
        var _a2, _b, _c;
        keyframe.transform = replaceTranslateInTransform((_a2 = keyframe.x) !== null && _a2 !== void 0 ? _a2 : x4, (_b = keyframe.y) !== null && _b !== void 0 ? _b : y4, (_c = keyframe.z) !== null && _c !== void 0 ? _c : z4, transform);
      });
    }
    const result2 = shape.animate(preprocessKeyframes(keyframes2), effectTiming);
    if (shapeID === void 0)
      mainResult = result2;
    return result2;
  }).filter(Boolean);
  const result = mainResult || (subResults === null || subResults === void 0 ? void 0 : subResults[0]);
  if (!result)
    return null;
  return createAnimationsProxy(result, subResults.filter((result2) => result2 !== result2));
};

// node_modules/@antv/g6/esm/animations/index.js
var Fade = [{ fields: ["opacity"] }];
var Translate = [{ fields: ["x", "y"] }];
var NodeCollapse = [{ fields: ["x", "y"] }];
var NodeExpand = NodeCollapse;
var PathIn = [{ fields: ["sourceNode", "targetNode"] }];
var PathOut = PathIn;
var ComboCollapse = [{ fields: ["childrenNode", "x", "y"] }];
var ComboExpand = ComboCollapse;

// node_modules/@antv/g6/esm/utils/is.js
function isEdgeData(data) {
  if ("source" in data && "target" in data)
    return true;
  return false;
}
function isVector2(vector) {
  return vector.length === 2;
}
function isPoint(p3) {
  if (p3 instanceof Float32Array)
    return true;
  if (Array.isArray(p3) && (p3.length === 2 || p3.length === 3)) {
    return p3.every((elem) => typeof elem === "number");
  }
  return false;
}

// node_modules/@antv/g6/esm/utils/math.js
function isBetween(value, min2, max2) {
  return value >= min2 && value <= max2;
}

// node_modules/@antv/g6/esm/utils/padding.js
function parsePadding(padding = 0) {
  if (Array.isArray(padding)) {
    const [top = 0, right = top, bottom = top, left = right] = padding;
    return [top, right, bottom, left];
  }
  return [padding, padding, padding, padding];
}
function getVerticalPadding(padding = 0) {
  const parsedPadding = parsePadding(padding);
  return parsedPadding[0] + parsedPadding[2];
}

// node_modules/@antv/g6/esm/utils/bbox.js
function getBBoxWidth(bbox) {
  return bbox.max[0] - bbox.min[0];
}
function getBBoxHeight(bbox) {
  return bbox.max[1] - bbox.min[1];
}
function getBBoxSize(bbox) {
  return [getBBoxWidth(bbox), getBBoxHeight(bbox)];
}
function getNodeBBox(node, padding) {
  const bbox = isPoint(node) ? getPointBBox(node) : node.getShape("key").getBounds();
  return padding ? getExpandedBBox(bbox, padding) : bbox;
}
function getPointBBox(point3) {
  const [x4, y4, z4 = 0] = point3;
  const bbox = new AABB();
  bbox.setMinMax([x4, y4, z4], [x4, y4, z4]);
  return bbox;
}
function getExpandedBBox(bbox, padding) {
  const [top, right, bottom, left] = parsePadding(padding);
  const [minX, minY, minZ] = bbox.min;
  const [maxX, maxY, maxZ] = bbox.max;
  const eBbox = new AABB();
  eBbox.setMinMax([minX - left, minY - top, minZ], [maxX + right, maxY + bottom, maxZ]);
  return eBbox;
}
function getCombinedBBox(bboxes) {
  if (bboxes.length === 0)
    return new AABB();
  if (bboxes.length === 1)
    return bboxes[0];
  const bbox = new AABB();
  bbox.setMinMax(bboxes[0].min, bboxes[0].max);
  for (let i2 = 1; i2 < bboxes.length; i2++) {
    const b22 = bboxes[i2];
    bbox.setMinMax([Math.min(bbox.min[0], b22.min[0]), Math.min(bbox.min[1], b22.min[1]), Math.min(bbox.min[2], b22.min[2])], [Math.max(bbox.max[0], b22.max[0]), Math.max(bbox.max[1], b22.max[1]), Math.max(bbox.max[2], b22.max[2])]);
  }
  return bbox;
}
function isBBoxInside(bbox1, bbox2) {
  const [minX1, minY1] = bbox1.min;
  const [maxX1, maxY1] = bbox1.max;
  const [minX2, minY2] = bbox2.min;
  const [maxX2, maxY2] = bbox2.max;
  return minX1 >= minX2 && maxX1 <= maxX2 && minY1 >= minY2 && maxY1 <= maxY2;
}
function isPointInBBox(point3, bbox) {
  return isBetween(point3[0], bbox.min[0], bbox.max[0]) && isBetween(point3[1], bbox.min[1], bbox.max[1]);
}
function isPointOnBBoxBoundary(point3, bbox, extended = false) {
  const { min: [minX, minY], max: [maxX, maxY] } = bbox;
  const onTopOrBottomLine = (point3[1] === minY || point3[1] === maxY) && (extended || isBetween(point3[0], minX, maxX));
  const onLeftOrRightLine = (point3[0] === minX || point3[0] === maxX) && (extended || isBetween(point3[1], minY, maxY));
  return onTopOrBottomLine || onLeftOrRightLine;
}
function isPointOutsideBBox(point3, bbox) {
  return !isPointInBBox(point3, bbox);
}
function isPointBBoxCenter(point3, bbox) {
  const { center } = bbox;
  return point3[0] === center[0] && point3[1] === center[1];
}
function getNearestBoundarySide(p3, bbox) {
  const [x4, y4] = p3;
  const [minX, minY] = bbox.min;
  const [maxX, maxY] = bbox.max;
  const left = x4 - minX;
  const right = maxX - x4;
  const top = y4 - minY;
  const bottom = maxY - y4;
  const min2 = Math.min(left, right, top, bottom);
  return min2 === left ? "left" : min2 === right ? "right" : min2 === top ? "top" : min2 === bottom ? "bottom" : "left";
}
function getNearestBoundaryPoint(p3, bbox) {
  const ref = clone_default(p3);
  if (isPointInBBox(p3, bbox)) {
    const side = getNearestBoundarySide(p3, bbox);
    switch (side) {
      case "left":
        ref[0] = bbox.min[0];
        break;
      case "right":
        ref[0] = bbox.max[0];
        break;
      case "top":
        ref[1] = bbox.min[1];
        break;
      case "bottom":
        ref[1] = bbox.max[1];
        break;
    }
  } else {
    const [x4, y4] = p3;
    const [minX, minY] = bbox.min;
    const [maxX, maxY] = bbox.max;
    ref[0] = isBetween(x4, minX, maxX) ? x4 : x4 < minX ? minX : maxX;
    ref[1] = isBetween(y4, minY, maxY) ? y4 : y4 < minY ? minY : maxY;
  }
  return ref;
}
function getTriangleCenter(bbox, direction) {
  const { center } = bbox;
  const [width2, height] = getBBoxSize(bbox);
  const x4 = direction === "up" || direction === "down" ? center[0] : direction === "right" ? center[0] - width2 / 6 : center[0] + width2 / 6;
  const y4 = direction === "left" || direction === "right" ? center[1] : direction === "down" ? center[1] - height / 6 : center[1] + height / 6;
  return [x4, y4];
}
function getIncircleRadius(bbox, direction) {
  let [w3, h3] = getBBoxSize(bbox);
  [w3, h3] = direction === "up" || direction === "down" ? [w3, h3] : [h3, w3];
  return (Math.pow(h3, 2) - Math.pow(Math.sqrt(Math.pow(w3 / 2, 2) + Math.pow(h3, 2)) - w3 / 2, 2)) / (2 * h3);
}
function getBBoxSegments(bbox) {
  const { min: [minX, minY], max: [maxX, maxY] } = bbox;
  const topLeftCorner = [minX, maxY];
  const topRightCorner = [maxX, maxY];
  const bottomRightCorner = [maxX, minY];
  const bottomLeftCorner = [minX, minY];
  const top = [topLeftCorner, topRightCorner];
  const right = [topRightCorner, bottomRightCorner];
  const bottom = [bottomRightCorner, bottomLeftCorner];
  const left = [bottomLeftCorner, topLeftCorner];
  return [top, right, bottom, left];
}

// node_modules/@antv/algorithm/es/structs/linked-list.js
var defaultComparator = function defaultComparator2(a3, b3) {
  if (a3 === b3) {
    return true;
  }
  return false;
};
var LinkedListNode = (
  /** @class */
  function() {
    function LinkedListNode2(value, next) {
      if (next === void 0) {
        next = null;
      }
      this.value = value;
      this.next = next;
    }
    LinkedListNode2.prototype.toString = function(callback) {
      return callback ? callback(this.value) : "".concat(this.value);
    };
    return LinkedListNode2;
  }()
);
var LinkedList = (
  /** @class */
  function() {
    function LinkedList2(comparator) {
      if (comparator === void 0) {
        comparator = defaultComparator;
      }
      this.head = null;
      this.tail = null;
      this.compare = comparator;
    }
    LinkedList2.prototype.prepend = function(value) {
      var newNode = new LinkedListNode(value, this.head);
      this.head = newNode;
      if (!this.tail) {
        this.tail = newNode;
      }
      return this;
    };
    LinkedList2.prototype.append = function(value) {
      var newNode = new LinkedListNode(value);
      if (!this.head) {
        this.head = newNode;
        this.tail = newNode;
        return this;
      }
      this.tail.next = newNode;
      this.tail = newNode;
      return this;
    };
    LinkedList2.prototype.delete = function(value) {
      if (!this.head) {
        return null;
      }
      var deleteNode = null;
      while (this.head && this.compare(this.head.value, value)) {
        deleteNode = this.head;
        this.head = this.head.next;
      }
      var currentNode = this.head;
      if (currentNode !== null) {
        while (currentNode.next) {
          if (this.compare(currentNode.next.value, value)) {
            deleteNode = currentNode.next;
            currentNode.next = currentNode.next.next;
          } else {
            currentNode = currentNode.next;
          }
        }
      }
      if (this.compare(this.tail.value, value)) {
        this.tail = currentNode;
      }
      return deleteNode;
    };
    LinkedList2.prototype.find = function(_a) {
      var _b = _a.value, value = _b === void 0 ? void 0 : _b, _c = _a.callback, callback = _c === void 0 ? void 0 : _c;
      if (!this.head) {
        return null;
      }
      var currentNode = this.head;
      while (currentNode) {
        if (callback && callback(currentNode.value)) {
          return currentNode;
        }
        if (value !== void 0 && this.compare(currentNode.value, value)) {
          return currentNode;
        }
        currentNode = currentNode.next;
      }
      return null;
    };
    LinkedList2.prototype.deleteTail = function() {
      var deletedTail = this.tail;
      if (this.head === this.tail) {
        this.head = null;
        this.tail = null;
        return deletedTail;
      }
      var currentNode = this.head;
      while (currentNode.next) {
        if (!currentNode.next.next) {
          currentNode.next = null;
        } else {
          currentNode = currentNode.next;
        }
      }
      this.tail = currentNode;
      return deletedTail;
    };
    LinkedList2.prototype.deleteHead = function() {
      if (!this.head) {
        return null;
      }
      var deletedHead = this.head;
      if (this.head.next) {
        this.head = this.head.next;
      } else {
        this.head = null;
        this.tail = null;
      }
      return deletedHead;
    };
    LinkedList2.prototype.fromArray = function(values3) {
      var _this = this;
      values3.forEach(function(value) {
        return _this.append(value);
      });
      return this;
    };
    LinkedList2.prototype.toArray = function() {
      var nodes = [];
      var currentNode = this.head;
      while (currentNode) {
        nodes.push(currentNode);
        currentNode = currentNode.next;
      }
      return nodes;
    };
    LinkedList2.prototype.reverse = function() {
      var currentNode = this.head;
      var prevNode = null;
      var nextNode = null;
      while (currentNode) {
        nextNode = currentNode.next;
        currentNode.next = prevNode;
        prevNode = currentNode;
        currentNode = nextNode;
      }
      this.tail = this.head;
      this.head = prevNode;
    };
    LinkedList2.prototype.toString = function(callback) {
      if (callback === void 0) {
        callback = void 0;
      }
      return this.toArray().map(function(node) {
        return node.toString(callback);
      }).toString();
    };
    return LinkedList2;
  }()
);
var linked_list_default = LinkedList;

// node_modules/@antv/algorithm/es/structs/queue.js
var Queue = (
  /** @class */
  function() {
    function Queue2() {
      this.linkedList = new linked_list_default();
    }
    Queue2.prototype.isEmpty = function() {
      return !this.linkedList.head;
    };
    Queue2.prototype.peek = function() {
      if (!this.linkedList.head) {
        return null;
      }
      return this.linkedList.head.value;
    };
    Queue2.prototype.enqueue = function(value) {
      this.linkedList.append(value);
    };
    Queue2.prototype.dequeue = function() {
      var removeHead = this.linkedList.deleteHead();
      return removeHead ? removeHead.value : null;
    };
    Queue2.prototype.toString = function(callback) {
      return this.linkedList.toString(callback);
    };
    return Queue2;
  }()
);

// node_modules/@antv/algorithm/es/util.js
var getNeighbors = function getNeighbors2(nodeId, edges, type) {
  if (edges === void 0) {
    edges = [];
  }
  var currentEdges = edges.filter(function(edge) {
    return edge.source === nodeId || edge.target === nodeId;
  });
  if (type === "target") {
    var neighhborsConverter_1 = function neighhborsConverter_12(edge) {
      return edge.source === nodeId;
    };
    return currentEdges.filter(neighhborsConverter_1).map(function(edge) {
      return edge.target;
    });
  }
  if (type === "source") {
    var neighhborsConverter_2 = function neighhborsConverter_22(edge) {
      return edge.target === nodeId;
    };
    return currentEdges.filter(neighhborsConverter_2).map(function(edge) {
      return edge.source;
    });
  }
  var neighhborsConverter = function neighhborsConverter2(edge) {
    return edge.source === nodeId ? edge.target : edge.source;
  };
  return currentEdges.map(neighhborsConverter);
};
var getOutEdgesNodeId = function getOutEdgesNodeId2(nodeId, edges) {
  return edges.filter(function(edge) {
    return edge.source === nodeId;
  });
};
var getEdgesByNodeId = function getEdgesByNodeId2(nodeId, edges) {
  return edges.filter(function(edge) {
    return edge.source === nodeId || edge.target === nodeId;
  });
};

// node_modules/@antv/algorithm/es/degree.js
var degree = function degree2(graphData) {
  var degrees = {};
  var _a = graphData.nodes, nodes = _a === void 0 ? [] : _a, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  nodes.forEach(function(node) {
    degrees[node.id] = {
      degree: 0,
      inDegree: 0,
      outDegree: 0
    };
  });
  edges.forEach(function(edge) {
    degrees[edge.source].degree++;
    degrees[edge.source].outDegree++;
    degrees[edge.target].degree++;
    degrees[edge.target].inDegree++;
  });
  return degrees;
};
var degree_default = degree;

// node_modules/@antv/algorithm/node_modules/@antv/util/esm/is-type.js
var toString = {}.toString;
var isType = function(value, type) {
  return toString.call(value) === "[object " + type + "]";
};
var is_type_default = isType;

// node_modules/@antv/algorithm/node_modules/@antv/util/esm/is-function.js
var is_function_default = function(value) {
  return is_type_default(value, "Function");
};

// node_modules/@antv/algorithm/node_modules/@antv/util/esm/is-array.js
var is_array_default = function(value) {
  return Array.isArray ? Array.isArray(value) : is_type_default(value, "Array");
};

// node_modules/@antv/algorithm/node_modules/@antv/util/esm/is-object.js
var is_object_default2 = function(value) {
  var type = typeof value;
  return value !== null && type === "object" || type === "function";
};

// node_modules/@antv/algorithm/node_modules/@antv/util/esm/each.js
function each(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (is_array_default(elements)) {
    for (var i2 = 0, len = elements.length; i2 < len; i2++) {
      rst = func(elements[i2], i2);
      if (rst === false) {
        break;
      }
    }
  } else if (is_object_default2(elements)) {
    for (var k2 in elements) {
      if (elements.hasOwnProperty(k2)) {
        rst = func(elements[k2], k2);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var each_default = each;

// node_modules/@antv/algorithm/node_modules/@antv/util/esm/pull.js
var arrPrototype = Array.prototype;
var splice = arrPrototype.splice;
var indexOf = arrPrototype.indexOf;

// node_modules/@antv/algorithm/node_modules/@antv/util/esm/pull-at.js
var splice2 = Array.prototype.splice;

// node_modules/@antv/algorithm/node_modules/@antv/util/esm/is-string.js
var is_string_default = function(str) {
  return is_type_default(str, "String");
};

// node_modules/@antv/algorithm/node_modules/@antv/util/esm/is-number.js
var isNumber2 = function(value) {
  return is_type_default(value, "Number");
};
var is_number_default = isNumber2;

// node_modules/@antv/algorithm/node_modules/@antv/util/esm/is-integer.js
var isInteger = Number.isInteger ? Number.isInteger : function(num) {
  return is_number_default(num) && num % 1 === 0;
};

// node_modules/@antv/algorithm/node_modules/@antv/util/esm/to-degree.js
var DEGREE = 180 / Math.PI;

// node_modules/@antv/algorithm/node_modules/@antv/util/esm/to-radian.js
var RADIAN = Math.PI / 180;

// node_modules/@antv/algorithm/node_modules/@antv/util/esm/values.js
var values = Object.values ? function(obj) {
  return Object.values(obj);
} : function(obj) {
  var result = [];
  each_default(obj, function(value, key) {
    if (!(is_function_default(obj) && key === "prototype")) {
      result.push(value);
    }
  });
  return result;
};
var values_default = values;

// node_modules/@antv/algorithm/node_modules/@antv/util/esm/get-type.js
var toString2 = {}.toString;

// node_modules/@antv/algorithm/node_modules/@antv/util/esm/is-prototype.js
var objectProto = Object.prototype;

// node_modules/@antv/algorithm/node_modules/@antv/util/esm/clone.js
var clone = function(obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  var rst;
  if (is_array_default(obj)) {
    rst = [];
    for (var i2 = 0, l3 = obj.length; i2 < l3; i2++) {
      if (typeof obj[i2] === "object" && obj[i2] != null) {
        rst[i2] = clone(obj[i2]);
      } else {
        rst[i2] = obj[i2];
      }
    }
  } else {
    rst = {};
    for (var k2 in obj) {
      if (typeof obj[k2] === "object" && obj[k2] != null) {
        rst[k2] = clone(obj[k2]);
      } else {
        rst[k2] = obj[k2];
      }
    }
  }
  return rst;
};
var clone_default2 = clone;

// node_modules/@antv/algorithm/node_modules/@antv/util/esm/memoize.js
var memoize_default = function(f3, resolver) {
  if (!is_function_default(f3)) {
    throw new TypeError("Expected a function");
  }
  var memoized = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    var cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = f3.apply(this, args);
    cache.set(key, result);
    return result;
  };
  memoized.cache = /* @__PURE__ */ new Map();
  return memoized;
};

// node_modules/@antv/algorithm/node_modules/@antv/util/esm/measure-text-width.js
var ctx;
var measure_text_width_default = memoize_default(function(text, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  if (!ctx) {
    ctx = document.createElement("canvas").getContext("2d");
  }
  ctx.font = [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ");
  return ctx.measureText(is_string_default(text) ? text : "").width;
}, function(text, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArrays([text], values_default(font)).join("");
});

// node_modules/@antv/algorithm/node_modules/@antv/util/esm/cache.js
var default_1 = (
  /** @class */
  function() {
    function default_12() {
      this.map = {};
    }
    default_12.prototype.has = function(key) {
      return this.map[key] !== void 0;
    };
    default_12.prototype.get = function(key, def) {
      var v3 = this.map[key];
      return v3 === void 0 ? def : v3;
    };
    default_12.prototype.set = function(key, value) {
      this.map[key] = value;
    };
    default_12.prototype.clear = function() {
      this.map = {};
    };
    default_12.prototype.delete = function(key) {
      delete this.map[key];
    };
    default_12.prototype.size = function() {
      return Object.keys(this.map).length;
    };
    return default_12;
  }()
);

// node_modules/@antv/algorithm/es/dijkstra.js
var minVertex = function minVertex2(D3, nodes, marks) {
  var minDis = Infinity;
  var minNode;
  for (var i2 = 0; i2 < nodes.length; i2++) {
    var nodeId = nodes[i2].id;
    if (!marks[nodeId] && D3[nodeId] <= minDis) {
      minDis = D3[nodeId];
      minNode = nodes[i2];
    }
  }
  return minNode;
};
var dijkstra = function dijkstra2(graphData, source, directed, weightPropertyName) {
  var _a = graphData.nodes, nodes = _a === void 0 ? [] : _a, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var nodeIds = [];
  var marks = {};
  var D3 = {};
  var prevs = {};
  nodes.forEach(function(node, i3) {
    var id = node.id;
    nodeIds.push(id);
    D3[id] = Infinity;
    if (id === source) D3[id] = 0;
  });
  var nodeNum = nodes.length;
  var _loop_1 = function _loop_12(i3) {
    var minNode = minVertex(D3, nodes, marks);
    var minNodeId = minNode.id;
    marks[minNodeId] = true;
    if (D3[minNodeId] === Infinity) return "continue";
    var relatedEdges = [];
    if (directed) relatedEdges = getOutEdgesNodeId(minNodeId, edges);
    else relatedEdges = getEdgesByNodeId(minNodeId, edges);
    relatedEdges.forEach(function(edge) {
      var edgeTarget = edge.target;
      var edgeSource = edge.source;
      var w3 = edgeTarget === minNodeId ? edgeSource : edgeTarget;
      var weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;
      if (D3[w3] > D3[minNode.id] + weight) {
        D3[w3] = D3[minNode.id] + weight;
        prevs[w3] = [minNode.id];
      } else if (D3[w3] === D3[minNode.id] + weight) {
        prevs[w3].push(minNode.id);
      }
    });
  };
  for (var i2 = 0; i2 < nodeNum; i2++) {
    _loop_1(i2);
  }
  prevs[source] = [source];
  var paths = {};
  for (var target in D3) {
    if (D3[target] !== Infinity) {
      findAllPaths(source, target, prevs, paths);
    }
  }
  var path = {};
  for (var target in paths) {
    path[target] = paths[target][0];
  }
  return {
    length: D3,
    path,
    allPath: paths
  };
};
var dijkstra_default = dijkstra;
function findAllPaths(source, target, prevs, foundPaths) {
  if (source === target) {
    return [source];
  }
  if (foundPaths[target]) {
    return foundPaths[target];
  }
  var paths = [];
  for (var _i = 0, _a = prevs[target]; _i < _a.length; _i++) {
    var prev = _a[_i];
    var prevPaths = findAllPaths(source, prev, prevs, foundPaths);
    if (!prevPaths) return;
    for (var _b = 0, prevPaths_1 = prevPaths; _b < prevPaths_1.length; _b++) {
      var prePath = prevPaths_1[_b];
      if (is_array_default(prePath)) paths.push(__spreadArray(__spreadArray([], prePath, true), [target], false));
      else paths.push([prePath, target]);
    }
  }
  foundPaths[target] = paths;
  return foundPaths[target];
}

// node_modules/@antv/algorithm/es/find-path.js
var findShortestPath = function findShortestPath2(graphData, start, end, directed, weightPropertyName) {
  var _a = dijkstra_default(graphData, start, directed, weightPropertyName), length = _a.length, path = _a.path, allPath = _a.allPath;
  return {
    length: length[end],
    path: path[end],
    allPath: allPath[end]
  };
};

// node_modules/@antv/algorithm/es/utils/vector.js
var Vector = (
  /** @class */
  function() {
    function Vector2(arr) {
      this.arr = arr;
    }
    Vector2.prototype.getArr = function() {
      return this.arr || [];
    };
    Vector2.prototype.add = function(otherVector) {
      var _a;
      var otherArr = otherVector.arr;
      if (!((_a = this.arr) === null || _a === void 0 ? void 0 : _a.length)) {
        return new Vector2(otherArr);
      }
      if (!(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
        return new Vector2(this.arr);
      }
      if (this.arr.length === otherArr.length) {
        var res = [];
        for (var index in this.arr) {
          res[index] = this.arr[index] + otherArr[index];
        }
        return new Vector2(res);
      }
    };
    Vector2.prototype.subtract = function(otherVector) {
      var _a;
      var otherArr = otherVector.arr;
      if (!((_a = this.arr) === null || _a === void 0 ? void 0 : _a.length)) {
        return new Vector2(otherArr);
      }
      if (!(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
        return new Vector2(this.arr);
      }
      if (this.arr.length === otherArr.length) {
        var res = [];
        for (var index in this.arr) {
          res[index] = this.arr[index] - otherArr[index];
        }
        return new Vector2(res);
      }
    };
    Vector2.prototype.avg = function(length) {
      var res = [];
      if (length !== 0) {
        for (var index in this.arr) {
          res[index] = this.arr[index] / length;
        }
      }
      return new Vector2(res);
    };
    Vector2.prototype.negate = function() {
      var res = [];
      for (var index in this.arr) {
        res[index] = -this.arr[index];
      }
      return new Vector2(res);
    };
    Vector2.prototype.squareEuclideanDistance = function(otherVector) {
      var _a;
      var otherArr = otherVector.arr;
      if (!((_a = this.arr) === null || _a === void 0 ? void 0 : _a.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
        return 0;
      }
      if (this.arr.length === otherArr.length) {
        var res = 0;
        for (var index in this.arr) {
          res += Math.pow(this.arr[index] - otherVector.arr[index], 2);
        }
        return res;
      }
    };
    Vector2.prototype.euclideanDistance = function(otherVector) {
      var _a;
      var otherArr = otherVector.arr;
      if (!((_a = this.arr) === null || _a === void 0 ? void 0 : _a.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
        return 0;
      }
      if (this.arr.length === otherArr.length) {
        var res = 0;
        for (var index in this.arr) {
          res += Math.pow(this.arr[index] - otherVector.arr[index], 2);
        }
        return Math.sqrt(res);
      } else {
        console.error("The two vectors are unequal in length.");
      }
    };
    Vector2.prototype.normalize = function() {
      var res = [];
      var cloneArr = clone_default2(this.arr);
      cloneArr.sort(function(a3, b3) {
        return a3 - b3;
      });
      var max2 = cloneArr[cloneArr.length - 1];
      var min2 = cloneArr[0];
      for (var index in this.arr) {
        res[index] = (this.arr[index] - min2) / (max2 - min2);
      }
      return new Vector2(res);
    };
    Vector2.prototype.norm2 = function() {
      var _a;
      if (!((_a = this.arr) === null || _a === void 0 ? void 0 : _a.length)) {
        return 0;
      }
      var res = 0;
      for (var index in this.arr) {
        res += Math.pow(this.arr[index], 2);
      }
      return Math.sqrt(res);
    };
    Vector2.prototype.dot = function(otherVector) {
      var _a;
      var otherArr = otherVector.arr;
      if (!((_a = this.arr) === null || _a === void 0 ? void 0 : _a.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
        return 0;
      }
      if (this.arr.length === otherArr.length) {
        var res = 0;
        for (var index in this.arr) {
          res += this.arr[index] * otherVector.arr[index];
        }
        return res;
      } else {
        console.error("The two vectors are unequal in length.");
      }
    };
    Vector2.prototype.equal = function(otherVector) {
      var _a;
      var otherArr = otherVector.arr;
      if (((_a = this.arr) === null || _a === void 0 ? void 0 : _a.length) !== (otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
        return false;
      }
      for (var index in this.arr) {
        if (this.arr[index] !== otherArr[index]) {
          return false;
        }
      }
      return true;
    };
    return Vector2;
  }()
);

// node_modules/@antv/algorithm/es/types.js
var DistanceType;
(function(DistanceType2) {
  DistanceType2["EuclideanDistance"] = "euclideanDistance";
})(DistanceType || (DistanceType = {}));

// node_modules/@antv/algorithm/es/structs/union-find.js
var UnionFind = (
  /** @class */
  function() {
    function UnionFind2(items) {
      this.count = items.length;
      this.parent = {};
      for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
        var i2 = items_1[_i];
        this.parent[i2] = i2;
      }
    }
    UnionFind2.prototype.find = function(item) {
      while (this.parent[item] !== item) {
        item = this.parent[item];
      }
      return item;
    };
    UnionFind2.prototype.union = function(a3, b3) {
      var rootA = this.find(a3);
      var rootB = this.find(b3);
      if (rootA === rootB) return;
      if (rootA < rootB) {
        if (this.parent[b3] !== b3) this.union(this.parent[b3], a3);
        this.parent[b3] = this.parent[a3];
      } else {
        if (this.parent[a3] !== a3) this.union(this.parent[a3], b3);
        this.parent[a3] = this.parent[b3];
      }
    };
    UnionFind2.prototype.connected = function(a3, b3) {
      return this.find(a3) === this.find(b3);
    };
    return UnionFind2;
  }()
);

// node_modules/@antv/algorithm/es/structs/binary-heap.js
var defaultCompare = function defaultCompare2(a3, b3) {
  return a3 - b3;
};
var MinBinaryHeap = (
  /** @class */
  function() {
    function MinBinaryHeap2(compareFn) {
      if (compareFn === void 0) {
        compareFn = defaultCompare;
      }
      this.compareFn = compareFn;
      this.list = [];
    }
    MinBinaryHeap2.prototype.getLeft = function(index) {
      return 2 * index + 1;
    };
    MinBinaryHeap2.prototype.getRight = function(index) {
      return 2 * index + 2;
    };
    MinBinaryHeap2.prototype.getParent = function(index) {
      if (index === 0) {
        return null;
      }
      return Math.floor((index - 1) / 2);
    };
    MinBinaryHeap2.prototype.isEmpty = function() {
      return this.list.length <= 0;
    };
    MinBinaryHeap2.prototype.top = function() {
      return this.isEmpty() ? void 0 : this.list[0];
    };
    MinBinaryHeap2.prototype.delMin = function() {
      var top = this.top();
      var bottom = this.list.pop();
      if (this.list.length > 0) {
        this.list[0] = bottom;
        this.moveDown(0);
      }
      return top;
    };
    MinBinaryHeap2.prototype.insert = function(value) {
      if (value !== null) {
        this.list.push(value);
        var index = this.list.length - 1;
        this.moveUp(index);
        return true;
      }
      return false;
    };
    MinBinaryHeap2.prototype.moveUp = function(index) {
      var parent = this.getParent(index);
      while (index && index > 0 && this.compareFn(this.list[parent], this.list[index]) > 0) {
        var tmp = this.list[parent];
        this.list[parent] = this.list[index];
        this.list[index] = tmp;
        index = parent;
        parent = this.getParent(index);
      }
    };
    MinBinaryHeap2.prototype.moveDown = function(index) {
      var _a;
      var element = index;
      var left = this.getLeft(index);
      var right = this.getRight(index);
      var size2 = this.list.length;
      if (left !== null && left < size2 && this.compareFn(this.list[element], this.list[left]) > 0) {
        element = left;
      } else if (right !== null && right < size2 && this.compareFn(this.list[element], this.list[right]) > 0) {
        element = right;
      }
      if (index !== element) {
        _a = [this.list[element], this.list[index]], this.list[index] = _a[0], this.list[element] = _a[1];
        this.moveDown(element);
      }
    };
    return MinBinaryHeap2;
  }()
);

// node_modules/@antv/algorithm/es/pageRank.js
var pageRank = function pageRank2(graphData, epsilon2, linkProb) {
  if (typeof epsilon2 !== "number") epsilon2 = 1e-6;
  if (typeof linkProb !== "number") linkProb = 0.85;
  var distance4 = 1;
  var leakedRank = 0;
  var maxIterations = 1e3;
  var _a = graphData.nodes, nodes = _a === void 0 ? [] : _a, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var nodesCount = nodes.length;
  var currentRank;
  var curRanks = {};
  var prevRanks = {};
  for (var j2 = 0; j2 < nodesCount; ++j2) {
    var node = nodes[j2];
    var nodeId = node.id;
    curRanks[nodeId] = 1 / nodesCount;
    prevRanks[nodeId] = 1 / nodesCount;
  }
  var nodeDegree = degree_default(graphData);
  while (maxIterations > 0 && distance4 > epsilon2) {
    leakedRank = 0;
    for (var j2 = 0; j2 < nodesCount; ++j2) {
      var node = nodes[j2];
      var nodeId = node.id;
      currentRank = 0;
      if (nodeDegree[node.id].inDegree === 0) {
        curRanks[nodeId] = 0;
      } else {
        var neighbors = getNeighbors(nodeId, edges, "source");
        for (var i2 = 0; i2 < neighbors.length; ++i2) {
          var neighbor = neighbors[i2];
          var outDegree = nodeDegree[neighbor].outDegree;
          if (outDegree > 0) currentRank += prevRanks[neighbor] / outDegree;
        }
        curRanks[nodeId] = linkProb * currentRank;
        leakedRank += curRanks[nodeId];
      }
    }
    leakedRank = (1 - leakedRank) / nodesCount;
    distance4 = 0;
    for (var j2 = 0; j2 < nodesCount; ++j2) {
      var node = nodes[j2];
      var nodeId = node.id;
      currentRank = curRanks[nodeId] + leakedRank;
      distance4 += Math.abs(currentRank - prevRanks[nodeId]);
      prevRanks[nodeId] = currentRank;
    }
    maxIterations -= 1;
  }
  return prevRanks;
};
var pageRank_default = pageRank;

// node_modules/@antv/algorithm/es/gSpan/struct.js
var VACANT_EDGE_ID = -1;
var VACANT_NODE_ID = -1;
var VACANT_EDGE_LABEL = "-1";
var VACANT_NODE_LABEL = "-1";
var VACANT_GRAPH_ID = -1;
var Edge = (
  /** @class */
  /* @__PURE__ */ function() {
    function Edge2(id, from, to, label) {
      if (id === void 0) {
        id = VACANT_EDGE_ID;
      }
      if (from === void 0) {
        from = VACANT_NODE_ID;
      }
      if (to === void 0) {
        to = VACANT_NODE_ID;
      }
      if (label === void 0) {
        label = VACANT_EDGE_LABEL;
      }
      this.id = id;
      this.from = from;
      this.to = to;
      this.label = label;
    }
    return Edge2;
  }()
);
var Node = (
  /** @class */
  function() {
    function Node2(id, label) {
      if (id === void 0) {
        id = VACANT_NODE_ID;
      }
      if (label === void 0) {
        label = VACANT_NODE_LABEL;
      }
      this.id = id;
      this.label = label;
      this.edges = [];
      this.edgeMap = {};
    }
    Node2.prototype.addEdge = function(edge) {
      this.edges.push(edge);
      this.edgeMap[edge.id] = edge;
    };
    return Node2;
  }()
);
var Graph = (
  /** @class */
  function() {
    function Graph5(id, edgeIdAutoIncrease, directed) {
      if (id === void 0) {
        id = VACANT_NODE_ID;
      }
      if (edgeIdAutoIncrease === void 0) {
        edgeIdAutoIncrease = true;
      }
      if (directed === void 0) {
        directed = false;
      }
      this.id = id;
      this.edgeIdAutoIncrease = edgeIdAutoIncrease;
      this.edges = [];
      this.nodes = [];
      this.nodeMap = {};
      this.edgeMap = {};
      this.nodeLabelMap = {};
      this.edgeLabelMap = {};
      this.counter = 0;
      this.directed = directed;
    }
    Graph5.prototype.getNodeNum = function() {
      return this.nodes.length;
    };
    Graph5.prototype.addNode = function(id, label) {
      if (this.nodeMap[id]) return;
      var node = new Node(id, label);
      this.nodes.push(node);
      this.nodeMap[id] = node;
      if (!this.nodeLabelMap[label]) this.nodeLabelMap[label] = [];
      this.nodeLabelMap[label].push(id);
    };
    Graph5.prototype.addEdge = function(id, from, to, label) {
      if (this.edgeIdAutoIncrease || id === void 0) id = this.counter++;
      if (this.nodeMap[from] && this.nodeMap[to] && this.nodeMap[to].edgeMap[id]) return;
      var edge = new Edge(id, from, to, label);
      this.edges.push(edge);
      this.edgeMap[id] = edge;
      this.nodeMap[from].addEdge(edge);
      if (!this.edgeLabelMap[label]) this.edgeLabelMap[label] = [];
      this.edgeLabelMap[label].push(edge);
      if (!this.directed) {
        var rEdge = new Edge(id, to, from, label);
        this.nodeMap[to].addEdge(rEdge);
        this.edgeLabelMap[label].push(rEdge);
      }
    };
    return Graph5;
  }()
);

// node_modules/@antv/algorithm/es/gSpan/gSpan.js
var DFSedge = (
  /** @class */
  function() {
    function DFSedge2(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel) {
      this.fromNode = fromNode;
      this.toNode = toNode;
      this.nodeEdgeNodeLabel = {
        nodeLabel1: fromNodeLabel || VACANT_NODE_LABEL,
        edgeLabel: edgeLabel || VACANT_EDGE_LABEL,
        nodeLabel2: toNodeLabel || VACANT_NODE_LABEL
      };
    }
    DFSedge2.prototype.equalTo = function(other) {
      return this.fromNode === other.formNode && this.toNode === other.toNode && this.nodeEdgeNodeLabel === other.nodeEdgeNodeLabel;
    };
    DFSedge2.prototype.notEqualTo = function(other) {
      return !this.equalTo(other);
    };
    return DFSedge2;
  }()
);
var DFScode = (
  /** @class */
  function() {
    function DFScode2() {
      this.rmpath = [];
      this.dfsEdgeList = [];
    }
    DFScode2.prototype.equalTo = function(other) {
      var aLength = this.dfsEdgeList.length;
      var bLength = other.length;
      if (aLength !== bLength) return false;
      for (var i2 = 0; i2 < aLength; i2++) {
        if (this.dfsEdgeList[i2] !== other[i2]) return false;
      }
      return true;
    };
    DFScode2.prototype.notEqualTo = function(other) {
      return !this.equalTo(other);
    };
    DFScode2.prototype.pushBack = function(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel) {
      this.dfsEdgeList.push(new DFSedge(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel));
      return this.dfsEdgeList;
    };
    DFScode2.prototype.toGraph = function(graphId, directed) {
      if (graphId === void 0) {
        graphId = VACANT_GRAPH_ID;
      }
      if (directed === void 0) {
        directed = false;
      }
      var graph = new Graph(graphId, true, directed);
      this.dfsEdgeList.forEach(function(dfsEdge) {
        var fromNodeId = dfsEdge.fromNode;
        var toNodeId = dfsEdge.toNode;
        var _a = dfsEdge.nodeEdgeNodeLabel, nodeLabel1 = _a.nodeLabel1, edgeLabel = _a.edgeLabel, nodeLabel2 = _a.nodeLabel2;
        if (nodeLabel1 !== VACANT_NODE_LABEL) graph.addNode(fromNodeId, nodeLabel1);
        if (nodeLabel2 !== VACANT_NODE_LABEL) graph.addNode(toNodeId, nodeLabel2);
        if (nodeLabel1 !== VACANT_NODE_LABEL && nodeLabel2 !== nodeLabel1) graph.addEdge(void 0, fromNodeId, toNodeId, edgeLabel);
      });
      return graph;
    };
    DFScode2.prototype.buildRmpath = function() {
      this.rmpath = [];
      var oldFrom = void 0;
      var selfLength = this.dfsEdgeList.length;
      for (var i2 = selfLength - 1; i2 >= 0; i2--) {
        var dfsEdge = this.dfsEdgeList[i2];
        var fromNodeIdx = dfsEdge.fromNode;
        var toNodeIdx = dfsEdge.toNode;
        if (fromNodeIdx < toNodeIdx && (oldFrom === void 0 || toNodeIdx === oldFrom)) {
          this.rmpath.push(i2);
          oldFrom = fromNodeIdx;
        }
      }
      return this.rmpath;
    };
    DFScode2.prototype.getNodeNum = function() {
      var nodeMap = {};
      this.dfsEdgeList.forEach(function(dfsEdge) {
        if (!nodeMap[dfsEdge.fromNode]) nodeMap[dfsEdge.fromNode] = true;
        if (!nodeMap[dfsEdge.toNode]) nodeMap[dfsEdge.toNode] = true;
      });
      return Object.keys(nodeMap).length;
    };
    return DFScode2;
  }()
);
var History = (
  /** @class */
  function() {
    function History3(pdfs) {
      this.his = {};
      this.nodesUsed = {};
      this.edgesUsed = {};
      this.edges = [];
      if (!pdfs) return;
      while (pdfs) {
        var e2 = pdfs.edge;
        this.edges.push(e2);
        this.nodesUsed[e2.from] = 1;
        this.nodesUsed[e2.to] = 1;
        this.edgesUsed[e2.id] = 1;
        pdfs = pdfs.preNode;
      }
      this.edges = this.edges.reverse();
    }
    History3.prototype.hasNode = function(node) {
      return this.nodesUsed[node.id] === 1;
    };
    History3.prototype.hasEdge = function(edge) {
      return this.edgesUsed[edge.id] === 1;
    };
    return History3;
  }()
);
var GSpan = (
  /** @class */
  function() {
    function GSpan2(_a) {
      var graphs = _a.graphs, _b = _a.minSupport, minSupport = _b === void 0 ? 2 : _b, _c = _a.minNodeNum, minNodeNum = _c === void 0 ? 1 : _c, _d = _a.maxNodeNum, maxNodeNum = _d === void 0 ? 4 : _d, _e2 = _a.top, top = _e2 === void 0 ? 10 : _e2, _f = _a.directed, directed = _f === void 0 ? false : _f, _g = _a.verbose, verbose = _g === void 0 ? false : _g;
      this.graphs = graphs;
      this.dfsCode = new DFScode();
      this.support = 0;
      this.frequentSize1Subgraphs = [];
      this.frequentSubgraphs = [];
      this.minSupport = minSupport;
      this.top = top;
      this.directed = directed;
      this.counter = 0;
      this.maxNodeNum = maxNodeNum;
      this.minNodeNum = minNodeNum;
      this.verbose = verbose;
      if (this.maxNodeNum < this.minNodeNum) this.maxNodeNum = this.minNodeNum;
      this.reportDF = [];
    }
    GSpan2.prototype.findForwardRootEdges = function(graph, fromNode) {
      var _this = this;
      var result = [];
      var nodeMap = graph.nodeMap;
      fromNode.edges.forEach(function(edge) {
        if (_this.directed || fromNode.label <= nodeMap[edge.to].label) result.push(edge);
      });
      return result;
    };
    GSpan2.prototype.findBackwardEdge = function(graph, edge1, edge2, history) {
      if (!this.directed && edge1 === edge2) return null;
      var nodeMap = graph.nodeMap;
      var edge2To = nodeMap[edge2.to];
      var edge2ToEdges = edge2To.edges;
      var edgeLength = edge2ToEdges.length;
      for (var i2 = 0; i2 < edgeLength; i2++) {
        var edge = edge2ToEdges[i2];
        if (history.hasEdge(edge) || edge.to !== edge1.from) continue;
        if (!this.directed) {
          if (edge1.label < edge.label || edge1.label === edge.label && nodeMap[edge1.to].label <= nodeMap[edge2.to].label) {
            return edge;
          }
        } else {
          if (nodeMap[edge1.from].label < nodeMap[edge2.to].label || nodeMap[edge1.from].label === nodeMap[edge2.to].label && edge1.label <= edge.label) {
            return edge;
          }
        }
      }
      return null;
    };
    GSpan2.prototype.findForwardPureEdges = function(graph, rightmostEdge, minNodeLabel, history) {
      var result = [];
      var rightmostEdgeToId = rightmostEdge.to;
      var edges = graph.nodeMap[rightmostEdgeToId].edges;
      var edgeLength = edges.length;
      for (var i2 = 0; i2 < edgeLength; i2++) {
        var edge = edges[i2];
        var toNode = graph.nodeMap[edge.to];
        if (minNodeLabel <= toNode.label && !history.hasNode(toNode)) {
          result.push(edge);
        }
      }
      return result;
    };
    GSpan2.prototype.findForwardRmpathEdges = function(graph, rightmostEdge, minNodeLabel, history) {
      var result = [];
      var nodeMap = graph.nodeMap;
      var toNodeLabel = nodeMap[rightmostEdge.to].label;
      var fromNode = nodeMap[rightmostEdge.from];
      var edges = fromNode.edges;
      var edgeLength = edges.length;
      for (var i2 = 0; i2 < edgeLength; i2++) {
        var edge = edges[i2];
        var newToNodeLabel = nodeMap[edge.to].label;
        if (rightmostEdge.to === edge.to || minNodeLabel > newToNodeLabel || history.hasNode(nodeMap[edge.to])) {
          continue;
        }
        if (rightmostEdge.label < edge.label || rightmostEdge.label === edge.label && toNodeLabel <= newToNodeLabel) {
          result.push(edge);
        }
      }
      return result;
    };
    GSpan2.prototype.getSupport = function(projected) {
      var graphMap = {};
      projected.forEach(function(pro) {
        if (!graphMap[pro.graphId]) graphMap[pro.graphId] = true;
      });
      return Object.keys(graphMap).length;
    };
    GSpan2.prototype.findMinLabel = function(obj) {
      var minLabel = void 0;
      Object.keys(obj).forEach(function(nodeEdgeNodeLabel) {
        var _a = obj[nodeEdgeNodeLabel], nodeLabel1 = _a.nodeLabel1, edgeLabel = _a.edgeLabel, nodeLabel2 = _a.nodeLabel2;
        if (!minLabel) {
          minLabel = {
            nodeLabel1,
            edgeLabel,
            nodeLabel2
          };
          return;
        }
        if (nodeLabel1 < minLabel.nodeLabel1 || nodeLabel1 === minLabel.nodeLabel1 && edgeLabel < minLabel.edgeLabel || nodeLabel1 === minLabel.nodeLabel1 && edgeLabel === minLabel.edgeLabel && nodeLabel2 < minLabel.nodeLabel2) {
          minLabel = {
            nodeLabel1,
            edgeLabel,
            nodeLabel2
          };
        }
      });
      return minLabel;
    };
    GSpan2.prototype.isMin = function() {
      var _this = this;
      var dfsCode = this.dfsCode;
      if (this.verbose) console.log("isMin checking", dfsCode);
      if (dfsCode.dfsEdgeList.length === 1) return true;
      var directed = this.directed;
      var graph = dfsCode.toGraph(VACANT_GRAPH_ID, directed);
      var nodeMap = graph.nodeMap;
      var dfsCodeMin = new DFScode();
      var root = {};
      graph.nodes.forEach(function(node) {
        var forwardEdges = _this.findForwardRootEdges(graph, node);
        forwardEdges.forEach(function(edge) {
          var otherNode = nodeMap[edge.to];
          var nodeEdgeNodeLabel = "".concat(node.label, "-").concat(edge.label, "-").concat(otherNode.label);
          if (!root[nodeEdgeNodeLabel]) root[nodeEdgeNodeLabel] = {
            projected: [],
            nodeLabel1: node.label,
            edgeLabel: edge.label,
            nodeLabel2: otherNode.label
          };
          var pdfs = {
            graphId: graph.id,
            edge,
            preNode: null
          };
          root[nodeEdgeNodeLabel].projected.push(pdfs);
        });
      });
      var minLabel = this.findMinLabel(root);
      if (!minLabel) return;
      dfsCodeMin.dfsEdgeList.push(new DFSedge(0, 1, minLabel.nodeLabel1, minLabel.edgeLabel, minLabel.nodeLabel2));
      var projectIsMin = function projectIsMin2(projected) {
        var rmpath = dfsCodeMin.buildRmpath();
        var minNodeLabel = dfsCodeMin.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1;
        var maxToC = dfsCodeMin.dfsEdgeList[rmpath[0]].toNode;
        var backwardRoot = {};
        var flag = false, newTo = 0;
        var end = directed ? -1 : 0;
        var _loop_1 = function _loop_12(i3) {
          if (flag) return "break";
          projected.forEach(function(p3) {
            var history = new History(p3);
            var backwardEdge = _this.findBackwardEdge(graph, history.edges[rmpath[i3]], history.edges[rmpath[0]], history);
            if (backwardEdge) {
              if (!backwardRoot[backwardEdge.label]) {
                backwardRoot[backwardEdge.label] = {
                  projected: [],
                  edgeLabel: backwardEdge.label
                };
              }
              backwardRoot[backwardEdge.label].projected.push({
                graphId: graph.id,
                edge: backwardRoot,
                preNode: p3
              });
              newTo = dfsCodeMin.dfsEdgeList[rmpath[i3]].fromNode;
              flag = true;
            }
          });
        };
        for (var i2 = rmpath.length - 1; i2 > end; i2--) {
          var state_1 = _loop_1(i2);
          if (state_1 === "break") break;
        }
        if (flag) {
          var minBackwardEdgeLabel = _this.findMinLabel(backwardRoot);
          dfsCodeMin.dfsEdgeList.push(new DFSedge(maxToC, newTo, VACANT_NODE_LABEL, minBackwardEdgeLabel.edgeLabel, VACANT_NODE_LABEL));
          var idx_1 = dfsCodeMin.dfsEdgeList.length - 1;
          if (_this.dfsCode.dfsEdgeList[idx_1] !== dfsCodeMin.dfsEdgeList[idx_1]) return false;
          return projectIsMin2(backwardRoot[minBackwardEdgeLabel.edgeLabel].projected);
        }
        var forwardRoot = {};
        flag = false;
        var newFrom = 0;
        projected.forEach(function(p3) {
          var history = new History(p3);
          var forwardPureEdges = _this.findForwardPureEdges(graph, history.edges[rmpath[0]], minNodeLabel, history);
          if (forwardPureEdges.length > 0) {
            flag = true;
            newFrom = maxToC;
            forwardPureEdges.forEach(function(edge) {
              var key2 = "".concat(edge.label, "-").concat(nodeMap[edge.to].label);
              if (!forwardRoot[key2]) forwardRoot[key2] = {
                projected: [],
                edgeLabel: edge.label,
                nodeLabel2: nodeMap[edge.to].label
              };
              forwardRoot[key2].projected.push({
                graphId: graph.id,
                edge,
                preNode: p3
              });
            });
          }
        });
        var pathLength = rmpath.length;
        var _loop_2 = function _loop_22(i3) {
          if (flag) return "break";
          var value = rmpath[i3];
          projected.forEach(function(p3) {
            var history = new History(p3);
            var forwardRmpathEdges = _this.findForwardRmpathEdges(graph, history.edges[value], minNodeLabel, history);
            if (forwardRmpathEdges.length > 0) {
              flag = true;
              newFrom = dfsCodeMin.dfsEdgeList[value].fromNode;
              forwardRmpathEdges.forEach(function(edge) {
                var key2 = "".concat(edge.label, "-").concat(nodeMap[edge.to].label);
                if (!forwardRoot[key2]) forwardRoot[key2] = {
                  projected: [],
                  edgeLabel: edge.label,
                  nodeLabel2: nodeMap[edge.to].label
                };
                forwardRoot[key2].projected.push({
                  graphId: graph.id,
                  edge,
                  preNode: p3
                });
              });
            }
          });
        };
        for (var i2 = 0; i2 < pathLength; i2++) {
          var state_2 = _loop_2(i2);
          if (state_2 === "break") break;
        }
        if (!flag) return true;
        var forwardMinEdgeNodeLabel = _this.findMinLabel(forwardRoot);
        dfsCodeMin.dfsEdgeList.push(new DFSedge(newFrom, maxToC + 1, VACANT_NODE_LABEL, forwardMinEdgeNodeLabel.edgeLabel, forwardMinEdgeNodeLabel.nodeLabel2));
        var idx = dfsCodeMin.dfsEdgeList.length - 1;
        if (dfsCode.dfsEdgeList[idx] !== dfsCodeMin.dfsEdgeList[idx]) return false;
        return projectIsMin2(forwardRoot["".concat(forwardMinEdgeNodeLabel.edgeLabel, "-").concat(forwardMinEdgeNodeLabel.nodeLabel2)].projected);
      };
      var key = "".concat(minLabel.nodeLabel1, "-").concat(minLabel.edgeLabel, "-").concat(minLabel.nodeLabel2);
      return projectIsMin(root[key].projected);
    };
    GSpan2.prototype.report = function() {
      if (this.dfsCode.getNodeNum() < this.minNodeNum) return;
      this.counter++;
      var graph = this.dfsCode.toGraph(this.counter, this.directed);
      this.frequentSubgraphs.push(clone_default2(graph));
    };
    GSpan2.prototype.subGraphMining = function(projected) {
      var _this = this;
      var support = this.getSupport(projected);
      if (support < this.minSupport) return;
      if (!this.isMin()) return;
      this.report();
      var nodeNum = this.dfsCode.getNodeNum();
      var rmpath = this.dfsCode.buildRmpath();
      var maxToC = this.dfsCode.dfsEdgeList[rmpath[0]].toNode;
      var minNodeLabel = this.dfsCode.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1;
      var forwardRoot = {};
      var backwardRoot = {};
      projected.forEach(function(p3) {
        var graph = _this.graphs[p3.graphId];
        var nodeMap = graph.nodeMap;
        var history = new History(p3);
        for (var i2 = rmpath.length - 1; i2 >= 0; i2--) {
          var backwardEdge = _this.findBackwardEdge(graph, history.edges[rmpath[i2]], history.edges[rmpath[0]], history);
          if (backwardEdge) {
            var key = "".concat(_this.dfsCode.dfsEdgeList[rmpath[i2]].fromNode, "-").concat(backwardEdge.label);
            if (!backwardRoot[key]) backwardRoot[key] = {
              projected: [],
              toNodeId: _this.dfsCode.dfsEdgeList[rmpath[i2]].fromNode,
              edgeLabel: backwardEdge.label
            };
            backwardRoot[key].projected.push({
              graphId: p3.graphId,
              edge: backwardEdge,
              preNode: p3
            });
          }
        }
        if (nodeNum >= _this.maxNodeNum) return;
        var forwardPureEdges = _this.findForwardPureEdges(graph, history.edges[rmpath[0]], minNodeLabel, history);
        forwardPureEdges.forEach(function(edge) {
          var key2 = "".concat(maxToC, "-").concat(edge.label, "-").concat(nodeMap[edge.to].label);
          if (!forwardRoot[key2]) forwardRoot[key2] = {
            projected: [],
            fromNodeId: maxToC,
            edgeLabel: edge.label,
            nodeLabel2: nodeMap[edge.to].label
          };
          forwardRoot[key2].projected.push({
            graphId: p3.graphId,
            edge,
            preNode: p3
          });
        });
        var _loop_3 = function _loop_32(i3) {
          var forwardRmpathEdges = _this.findForwardRmpathEdges(graph, history.edges[rmpath[i3]], minNodeLabel, history);
          forwardRmpathEdges.forEach(function(edge) {
            var key2 = "".concat(_this.dfsCode.dfsEdgeList[rmpath[i3]].fromNode, "-").concat(edge.label, "-").concat(nodeMap[edge.to].label);
            if (!forwardRoot[key2]) forwardRoot[key2] = {
              projected: [],
              fromNodeId: _this.dfsCode.dfsEdgeList[rmpath[i3]].fromNode,
              edgeLabel: edge.label,
              nodeLabel2: nodeMap[edge.to].label
            };
            forwardRoot[key2].projected.push({
              graphId: p3.graphId,
              edge,
              preNode: p3
            });
          });
        };
        for (var i2 = 0; i2 < rmpath.length; i2++) {
          _loop_3(i2);
        }
      });
      Object.keys(backwardRoot).forEach(function(key) {
        var _a = backwardRoot[key], toNodeId = _a.toNodeId, edgeLabel = _a.edgeLabel;
        _this.dfsCode.dfsEdgeList.push(new DFSedge(maxToC, toNodeId, "-1", edgeLabel, "-1"));
        _this.subGraphMining(backwardRoot[key].projected);
        _this.dfsCode.dfsEdgeList.pop();
      });
      Object.keys(forwardRoot).forEach(function(key) {
        var _a = forwardRoot[key], fromNodeId = _a.fromNodeId, edgeLabel = _a.edgeLabel, nodeLabel2 = _a.nodeLabel2;
        _this.dfsCode.dfsEdgeList.push(new DFSedge(fromNodeId, maxToC + 1, VACANT_NODE_LABEL, edgeLabel, nodeLabel2));
        _this.subGraphMining(forwardRoot[key].projected);
        _this.dfsCode.dfsEdgeList.pop();
      });
    };
    GSpan2.prototype.generate1EdgeFrequentSubGraphs = function() {
      var graphs = this.graphs;
      var directed = this.directed;
      var minSupport = this.minSupport;
      var frequentSize1Subgraphs = this.frequentSize1Subgraphs;
      var nodeLabelCounter = {}, nodeEdgeNodeCounter = {};
      var nodeLableCounted = {};
      var nodeEdgeNodeLabelCounted = {};
      Object.keys(graphs).forEach(function(key) {
        var graph = graphs[key];
        var nodeMap = graph.nodeMap;
        graph.nodes.forEach(function(node, i2) {
          var nodeLabel = node.label;
          var graphNodeKey = "".concat(key, "-").concat(nodeLabel);
          if (!nodeLableCounted[graphNodeKey]) {
            var counter = nodeLabelCounter[nodeLabel] || 0;
            counter++;
            nodeLabelCounter[nodeLabel] = counter;
          }
          nodeLableCounted[graphNodeKey] = {
            graphKey: key,
            label: nodeLabel
          };
          node.edges.forEach(function(edge) {
            var nodeLabel1 = nodeLabel;
            var nodeLabel2 = nodeMap[edge.to].label;
            if (!directed && nodeLabel1 > nodeLabel2) {
              var tmp = nodeLabel2;
              nodeLabel2 = nodeLabel1;
              nodeLabel1 = tmp;
            }
            var edgeLabel = edge.label;
            var graphNodeEdgeNodeKey = "".concat(key, "-").concat(nodeLabel1, "-").concat(edgeLabel, "-").concat(nodeLabel2);
            var nodeEdgeNodeKey = "".concat(nodeLabel1, "-").concat(edgeLabel, "-").concat(nodeLabel2);
            if (!nodeEdgeNodeCounter[nodeEdgeNodeKey]) {
              var counter2 = nodeEdgeNodeCounter[nodeEdgeNodeKey] || 0;
              counter2++;
              nodeEdgeNodeCounter[nodeEdgeNodeKey] = counter2;
            }
            nodeEdgeNodeLabelCounted[graphNodeEdgeNodeKey] = {
              graphId: key,
              nodeLabel1,
              edgeLabel,
              nodeLabel2
            };
          });
        });
      });
      Object.keys(nodeLabelCounter).forEach(function(label) {
        var count = nodeLabelCounter[label];
        if (count < minSupport) return;
        var g3 = {
          nodes: [],
          edges: []
        };
        g3.nodes.push({
          id: "0",
          label
        });
        frequentSize1Subgraphs.push(g3);
      });
      return frequentSize1Subgraphs;
    };
    GSpan2.prototype.run = function() {
      var _this = this;
      this.frequentSize1Subgraphs = this.generate1EdgeFrequentSubGraphs();
      if (this.maxNodeNum < 2) return;
      var graphs = this.graphs;
      var directed = this.directed;
      var root = {};
      Object.keys(graphs).forEach(function(graphId) {
        var graph = graphs[graphId];
        var nodeMap = graph.nodeMap;
        graph.nodes.forEach(function(node) {
          var forwardRootEdges = _this.findForwardRootEdges(graph, node);
          forwardRootEdges.forEach(function(edge) {
            var toNode = nodeMap[edge.to];
            var nodeEdgeNodeLabel = "".concat(node.label, "-").concat(edge.label, "-").concat(toNode.label);
            if (!root[nodeEdgeNodeLabel]) root[nodeEdgeNodeLabel] = {
              projected: [],
              nodeLabel1: node.label,
              edgeLabel: edge.label,
              nodeLabel2: toNode.label
            };
            var pdfs = {
              graphId,
              edge,
              preNode: null
            };
            root[nodeEdgeNodeLabel].projected.push(pdfs);
          });
        });
      });
      Object.keys(root).forEach(function(nodeEdgeNodeLabel) {
        var _a = root[nodeEdgeNodeLabel], projected = _a.projected, nodeLabel1 = _a.nodeLabel1, edgeLabel = _a.edgeLabel, nodeLabel2 = _a.nodeLabel2;
        _this.dfsCode.dfsEdgeList.push(new DFSedge(0, 1, nodeLabel1, edgeLabel, nodeLabel2));
        _this.subGraphMining(projected);
        _this.dfsCode.dfsEdgeList.pop();
      });
    };
    return GSpan2;
  }()
);

// node_modules/@antv/algorithm/es/structs/stack.js
var Stack = (
  /** @class */
  function() {
    function Stack2(maxStep) {
      if (maxStep === void 0) {
        maxStep = 10;
      }
      this.linkedList = new linked_list_default();
      this.maxStep = maxStep;
    }
    Object.defineProperty(Stack2.prototype, "length", {
      get: function get7() {
        return this.linkedList.toArray().length;
      },
      enumerable: false,
      configurable: true
    });
    Stack2.prototype.isEmpty = function() {
      return !this.linkedList.head;
    };
    Stack2.prototype.isMaxStack = function() {
      return this.toArray().length >= this.maxStep;
    };
    Stack2.prototype.peek = function() {
      if (this.isEmpty()) {
        return null;
      }
      return this.linkedList.head.value;
    };
    Stack2.prototype.push = function(value) {
      this.linkedList.prepend(value);
      if (this.length > this.maxStep) {
        this.linkedList.deleteTail();
      }
    };
    Stack2.prototype.pop = function() {
      var removeHead = this.linkedList.deleteHead();
      return removeHead ? removeHead.value : null;
    };
    Stack2.prototype.toArray = function() {
      return this.linkedList.toArray().map(function(node) {
        return node.value;
      });
    };
    Stack2.prototype.clear = function() {
      while (!this.isEmpty()) {
        this.pop();
      }
    };
    return Stack2;
  }()
);

// node_modules/@antv/g6/esm/utils/id.js
function idOf(data) {
  if (data.id !== void 0)
    return data.id;
  if (data.source !== void 0 && data.target !== void 0)
    return `${data.source}-${data.target}`;
  throw new Error(format("The datum does not have available id."));
}
function parentIdOf(data) {
  return data.combo;
}
function idsOf(data, flat) {
  const ids = {
    nodes: (data.nodes || []).map(idOf),
    edges: (data.edges || []).map(idOf),
    combos: (data.combos || []).map(idOf)
  };
  return flat ? Object.values(ids).flat() : ids;
}

// node_modules/@antv/g6/esm/utils/centrality.js
var getNodeCentralities = (graphData, getRelatedEdgesData, centrality) => {
  var _a;
  switch (centrality.type) {
    case "degree": {
      const centralityResult = /* @__PURE__ */ new Map();
      (_a = graphData.nodes) === null || _a === void 0 ? void 0 : _a.forEach((node) => {
        const degree3 = getRelatedEdgesData(idOf(node), centrality.direction).length;
        centralityResult.set(idOf(node), degree3);
      });
      return centralityResult;
    }
    case "betweenness":
      return computeNodeBetweennessCentrality(graphData, centrality.directed, centrality.weightPropertyName);
    case "closeness":
      return computeNodeClosenessCentrality(graphData, centrality.directed, centrality.weightPropertyName);
    case "eigenvector":
      return computeNodeEigenvectorCentrality(graphData, centrality.directed);
    case "pagerank":
      return computeNodePageRankCentrality(graphData, centrality.epsilon, centrality.linkProb);
    default:
      return initCentralityResult(graphData);
  }
};
var initCentralityResult = (graphData) => {
  var _a;
  const centralityResult = /* @__PURE__ */ new Map();
  (_a = graphData.nodes) === null || _a === void 0 ? void 0 : _a.forEach((node) => {
    centralityResult.set(idOf(node), 0);
  });
  return centralityResult;
};
var computeNodeBetweennessCentrality = (graphData, directed, weightPropertyName) => {
  const centralityResult = initCentralityResult(graphData);
  const { nodes = [] } = graphData;
  nodes.forEach((source) => {
    nodes.forEach((target) => {
      if (source !== target) {
        const { allPath } = findShortestPath(graphData, idOf(source), idOf(target), directed, weightPropertyName);
        const pathCount = allPath.length;
        allPath.flat().forEach((nodeId) => {
          if (nodeId !== idOf(source) && nodeId !== idOf(target)) {
            centralityResult.set(nodeId, centralityResult.get(nodeId) + 1 / pathCount);
          }
        });
      }
    });
  });
  return centralityResult;
};
var computeNodeClosenessCentrality = (graphData, directed, weightPropertyName) => {
  const centralityResult = /* @__PURE__ */ new Map();
  const { nodes = [] } = graphData;
  nodes.forEach((source) => {
    const totalLength = nodes.reduce((acc, target) => {
      if (source !== target) {
        const { length } = findShortestPath(graphData, idOf(source), idOf(target), directed, weightPropertyName);
        acc += length;
      }
      return acc;
    }, 0);
    centralityResult.set(idOf(source), 1 / totalLength);
  });
  return centralityResult;
};
var computeNodePageRankCentrality = (graphData, epsilon2, linkProb) => {
  var _a;
  const centralityResult = /* @__PURE__ */ new Map();
  const data = pageRank_default(graphData, epsilon2, linkProb);
  (_a = graphData.nodes) === null || _a === void 0 ? void 0 : _a.forEach((node) => {
    centralityResult.set(idOf(node), data[idOf(node)]);
  });
  return centralityResult;
};
var computeNodeEigenvectorCentrality = (graphData, directed) => {
  const { nodes = [] } = graphData;
  const adjacencyMatrix = createAdjacencyMatrix(graphData, directed);
  const eigenvector = powerIteration(adjacencyMatrix, nodes.length);
  const centralityResult = /* @__PURE__ */ new Map();
  nodes.forEach((node, index) => {
    centralityResult.set(idOf(node), eigenvector[index]);
  });
  return centralityResult;
};
var createAdjacencyMatrix = (graphData, directed) => {
  const { nodes = [], edges = [] } = graphData;
  const matrix2 = Array(nodes.length).fill(null).map(() => Array(nodes.length).fill(0));
  edges.forEach(({ source, target }) => {
    const uIndex = nodes.findIndex((node) => idOf(node) === source);
    const vIndex = nodes.findIndex((node) => idOf(node) === target);
    if (directed) {
      matrix2[uIndex][vIndex] = 1;
    } else {
      matrix2[uIndex][vIndex] = 1;
      matrix2[vIndex][uIndex] = 1;
    }
  });
  return matrix2;
};
var powerIteration = (matrix2, numNodes, maxIterations = 100, tolerance = 1e-6) => {
  let eigenvector = Array(numNodes).fill(1);
  let diff = Infinity;
  for (let iter = 0; iter < maxIterations && diff > tolerance; iter++) {
    const newEigenvector = Array(numNodes).fill(0);
    for (let i2 = 0; i2 < numNodes; i2++) {
      for (let j2 = 0; j2 < numNodes; j2++) {
        newEigenvector[i2] += matrix2[i2][j2] * eigenvector[j2];
      }
    }
    const norm = Math.sqrt(newEigenvector.reduce((sum, val) => sum + val * val, 0));
    for (let i2 = 0; i2 < numNodes; i2++) {
      newEigenvector[i2] /= norm;
    }
    diff = Math.sqrt(newEigenvector.reduce((sum, val, index) => sum + (val - eigenvector[index]) * val, 0));
    eigenvector = newEigenvector;
  }
  return eigenvector;
};

// node_modules/@antv/g6/esm/utils/diff.js
function arrayDiff(original, modified, key, comparator = is_equal_default) {
  const originalMap = new Map(original.map((d3) => [key(d3), d3]));
  const modifiedMap = new Map(modified.map((d3) => [key(d3), d3]));
  const originalSet = new Set(originalMap.keys());
  const modifiedSet = new Set(modifiedMap.keys());
  const enter = [];
  const update = [];
  const exit = [];
  const keep = [];
  modifiedSet.forEach((key2) => {
    if (originalSet.has(key2)) {
      if (!comparator(originalMap.get(key2), modifiedMap.get(key2))) {
        update.push(modifiedMap.get(key2));
      } else {
        keep.push(modifiedMap.get(key2));
      }
    } else {
      enter.push(modifiedMap.get(key2));
    }
  });
  originalSet.forEach((key2) => {
    if (!modifiedSet.has(key2)) {
      exit.push(originalMap.get(key2));
    }
  });
  return { enter, exit, keep, update };
}

// node_modules/@antv/g6/esm/utils/visibility.js
function setVisibility(shape, value, filter) {
  const callback = (node) => {
    if (filter && !filter(node))
      return;
    node.style.visibility = value;
  };
  shape.forEach((node) => {
    callback(node);
  });
}

// node_modules/@antv/g6/esm/utils/extension.js
function parseExtensions(graph, category, extensions) {
  const counter = {};
  const getKey = (type) => {
    if (!(type in counter))
      counter[type] = 0;
    return `${category}-${type}-${counter[type]++}`;
  };
  return extensions.map((extension) => {
    if (typeof extension === "string") {
      return { type: extension, key: getKey(extension) };
    }
    if (typeof extension === "function") {
      return extension.call(graph);
    }
    if (extension.key)
      return extension;
    return Object.assign(Object.assign({}, extension), { key: getKey(extension.type) });
  });
}

// node_modules/@antv/g6/esm/registry/extension/index.js
var ExtensionController = class {
  constructor(context) {
    this.extensions = [];
    this.extensionMap = {};
    this.context = context;
  }
  setExtensions(extensions) {
    const stdExtensions = parseExtensions(this.context.graph, this.category, extensions);
    const { enter, update, exit, keep } = arrayDiff(this.extensions, stdExtensions, (extension) => extension.key);
    this.createExtensions(enter);
    this.updateExtensions([...update, ...keep]);
    this.destroyExtensions(exit);
    this.extensions = stdExtensions;
  }
  createExtension(extension) {
    const { category } = this;
    const { key, type } = extension;
    const Ctor = getExtension(category, type);
    if (!Ctor)
      return print.warn(`The extension ${type} of ${category} is not registered.`);
    const instance = new Ctor(this.context, extension);
    instance.initialized = true;
    this.extensionMap[key] = instance;
  }
  createExtensions(extensions) {
    extensions.forEach((extension) => this.createExtension(extension));
  }
  updateExtension(extension) {
    const { key } = extension;
    const instance = this.extensionMap[key];
    if (instance) {
      instance.update(extension);
    }
  }
  updateExtensions(extensions) {
    extensions.forEach((extension) => this.updateExtension(extension));
  }
  destroyExtension(key) {
    const instance = this.extensionMap[key];
    if (!instance)
      return;
    if (instance.initialized && !instance.destroyed) {
      instance.destroy();
    }
    delete this.extensionMap[key];
  }
  destroyExtensions(extensions) {
    extensions.forEach(({ key }) => this.destroyExtension(key));
  }
  destroy() {
    this.destroyExtensions(this.extensions);
    this.context = {};
    this.extensions = [];
    this.extensionMap = {};
  }
};
var BaseExtension = class {
  constructor(context, options) {
    this.events = [];
    this.initialized = false;
    this.destroyed = false;
    this.context = context;
    this.options = options;
  }
  update(options) {
    this.options = Object.assign(this.options, options);
  }
  destroy() {
    this.context = {};
    this.options = {};
    this.destroyed = true;
  }
};

// node_modules/@antv/g6/esm/behaviors/base-behavior.js
var BaseBehavior = class extends BaseExtension {
};

// node_modules/@antv/g6/esm/behaviors/auto-adapt-label.js
var AutoAdaptLabel = class _AutoAdaptLabel extends BaseBehavior {
  constructor(context, options) {
    super(context, Object.assign({}, _AutoAdaptLabel.defaultOptions, options));
    this.isOverlapping = (bbox, bboxes) => {
      return bboxes.some((b3) => bbox.intersects(b3));
    };
    this.occupiedBounds = [];
    this.detectLabelCollision = (elements) => {
      const viewport = this.context.viewport;
      const res = { show: [], hide: [] };
      this.occupiedBounds = [];
      elements.forEach((element) => {
        const labelBounds = element.getShape("label").getRenderBounds();
        if (viewport.isInViewport(labelBounds, true) && !this.isOverlapping(labelBounds, this.occupiedBounds)) {
          res.show.push(element);
          this.occupiedBounds.push(getExpandedBBox(labelBounds, this.options.padding));
        } else {
          res.hide.push(element);
        }
      });
      return res;
    };
    this.hideLabelIfExceedViewport = (prevElementsInView, currentElementsInView) => {
      const { exit } = arrayDiff(prevElementsInView, currentElementsInView, (d3) => d3.id);
      exit === null || exit === void 0 ? void 0 : exit.forEach(this.hideLabel);
    };
    this.nodeCentralities = /* @__PURE__ */ new Map();
    this.sortNodesByCentrality = (nodes, centrality) => {
      const { model } = this.context;
      const graphData = model.getData();
      const getRelatedEdgesData = model.getRelatedEdgesData.bind(model);
      const nodesWithCentrality = nodes.map((node) => {
        if (!this.nodeCentralities.has(node.id)) {
          this.nodeCentralities = getNodeCentralities(graphData, getRelatedEdgesData, centrality);
        }
        return { node, centrality: this.nodeCentralities.get(node.id) };
      });
      return nodesWithCentrality.sort((a3, b3) => b3.centrality - a3.centrality).map((item) => item.node);
    };
    this.sortLabelElementsInView = (labelElements) => {
      const { sort: sort2, sortNode, sortCombo, sortEdge } = this.options;
      const { model } = this.context;
      if (isFunction(sort2))
        return labelElements.sort((a3, b3) => sort2(model.getElementDataById(a3.id), model.getElementDataById(b3.id)));
      const { node: nodes = [], edge: edges = [], combo: combos = [] } = group_by_default(labelElements, (el) => el.type);
      const sortedCombos = isFunction(sortCombo) ? combos.sort((a3, b3) => sortCombo(...model.getComboData([a3.id, b3.id]))) : combos;
      const sortedNodes = isFunction(sortNode) ? nodes.sort((a3, b3) => sortNode(...model.getNodeData([a3.id, b3.id]))) : this.sortNodesByCentrality(nodes, sortNode);
      const sortedEdges = isFunction(sortEdge) ? edges.sort((a3, b3) => sortEdge(...model.getEdgeData([a3.id, b3.id]))) : edges;
      return [...sortedCombos, ...sortedNodes, ...sortedEdges];
    };
    this.labelElementsInView = [];
    this.isFirstRender = true;
    this.onToggleVisibility = (event) => {
      var _a;
      if (((_a = event.data) === null || _a === void 0 ? void 0 : _a.stage) === "zIndex")
        return;
      if (!this.validate(event)) {
        if (this.hiddenElements.size > 0) {
          this.hiddenElements.forEach(this.showLabel);
          this.hiddenElements.clear();
        }
        return;
      }
      const labelElementsInView = this.isFirstRender ? this.getLabelElements() : this.getLabelElementsInView();
      this.hideLabelIfExceedViewport(this.labelElementsInView, labelElementsInView);
      this.labelElementsInView = labelElementsInView;
      const sortedElements = this.sortLabelElementsInView(this.labelElementsInView);
      const { show, hide } = this.detectLabelCollision(sortedElements);
      for (let i2 = show.length - 1; i2 >= 0; i2--) {
        this.showLabel(show[i2]);
      }
      hide.forEach(this.hideLabel);
    };
    this.hiddenElements = /* @__PURE__ */ new Map();
    this.hideLabel = (element) => {
      const label = element.getShape("label");
      if (label)
        setVisibility(label, "hidden");
      this.hiddenElements.set(element.id, element);
    };
    this.showLabel = (element) => {
      const label = element.getShape("label");
      if (label)
        setVisibility(label, "visible");
      element.toFront();
      this.hiddenElements.delete(element.id);
    };
    this.onTransform = throttle_default(this.onToggleVisibility, this.options.throttle, { leading: true });
    this.enableToggle = true;
    this.toggle = (event) => {
      if (!this.enableToggle)
        return;
      this.onToggleVisibility(event);
    };
    this.onBeforeRender = () => {
      this.enableToggle = false;
    };
    this.onAfterRender = (event) => {
      this.onToggleVisibility(event);
      this.enableToggle = true;
    };
    this.bindEvents();
  }
  update(options) {
    this.unbindEvents();
    super.update(options);
    this.bindEvents();
    this.onToggleVisibility({});
  }
  getLabelElements() {
    const { elementMap } = this.context.element;
    const elements = [];
    for (const key in elementMap) {
      const element = elementMap[key];
      if (element.isVisible() && element.getShape("label")) {
        elements.push(element);
      }
    }
    return elements;
  }
  getLabelElementsInView() {
    const viewport = this.context.viewport;
    return this.getLabelElements().filter((node) => viewport.isInViewport(node.getShape("key").getRenderBounds()));
  }
  bindEvents() {
    const { graph } = this.context;
    graph.on(GraphEvent.BEFORE_RENDER, this.onBeforeRender);
    graph.on(GraphEvent.AFTER_RENDER, this.onAfterRender);
    graph.on(GraphEvent.AFTER_DRAW, this.toggle);
    graph.on(GraphEvent.AFTER_LAYOUT, this.toggle);
    graph.on(GraphEvent.AFTER_TRANSFORM, this.onTransform);
  }
  unbindEvents() {
    const { graph } = this.context;
    graph.off(GraphEvent.BEFORE_RENDER, this.onBeforeRender);
    graph.off(GraphEvent.AFTER_RENDER, this.onAfterRender);
    graph.off(GraphEvent.AFTER_DRAW, this.toggle);
    graph.off(GraphEvent.AFTER_LAYOUT, this.toggle);
    graph.off(GraphEvent.AFTER_TRANSFORM, this.onTransform);
  }
  validate(event) {
    if (this.destroyed)
      return false;
    const { enable } = this.options;
    if (isFunction(enable))
      return enable(event);
    return !!enable;
  }
  destroy() {
    this.unbindEvents();
    super.destroy();
  }
};
AutoAdaptLabel.defaultOptions = {
  enable: true,
  throttle: 100,
  padding: 0,
  sortNode: { type: "degree" }
};

// node_modules/@antv/g6/esm/utils/vector.js
var VECTOR_ZERO = [0, 0, 0];
function add(a3, b3) {
  return a3.map((v3, i2) => v3 + b3[i2]);
}
function subtract(a3, b3) {
  return a3.map((v3, i2) => v3 - b3[i2]);
}
function multiply(a3, b3) {
  if (typeof b3 === "number")
    return a3.map((v3) => v3 * b3);
  return a3.map((v3, i2) => v3 * b3[i2]);
}
function divide(a3, b3) {
  if (typeof b3 === "number")
    return a3.map((v3) => v3 / b3);
  return a3.map((v3, i2) => v3 / b3[i2]);
}
function dot(a3, b3) {
  return a3.reduce((sum, v3, i2) => sum + v3 * b3[i2], 0);
}
function cross(a3, b3) {
  const a22 = toVector3(a3);
  const b22 = toVector3(b3);
  return [a22[1] * b22[2] - a22[2] * b22[1], a22[2] * b22[0] - a22[0] * b22[2], a22[0] * b22[1] - a22[1] * b22[0]];
}
function scale(a3, s2) {
  return a3.map((v3) => v3 * s2);
}
function distance(a3, b3) {
  return Math.sqrt(a3.reduce((sum, v3, i2) => sum + Math.pow(v3 - b3[i2] || 0, 2), 0));
}
function manhattanDistance(a3, b3) {
  return a3.reduce((sum, v3, i2) => sum + Math.abs(v3 - b3[i2]), 0);
}
function normalize(a3) {
  const length = a3.reduce((sum, v3) => sum + Math.pow(v3, 2), 0);
  return a3.map((v3) => v3 / Math.sqrt(length));
}
function angle(a3, b3, clockwise = false) {
  const determinant2 = a3[0] * b3[1] - a3[1] * b3[0];
  let angle2 = Math.acos(multiply(a3, b3).reduce((sum, v3) => sum + v3, 0) / (distance(a3, VECTOR_ZERO) * distance(b3, VECTOR_ZERO)));
  if (clockwise && determinant2 < 0) {
    angle2 = 2 * Math.PI - angle2;
  }
  return angle2;
}
function perpendicular(a3, clockwise = true) {
  return clockwise ? [-a3[1], a3[0]] : [a3[1], -a3[0]];
}
function mod(a3, b3) {
  return a3.map((v3) => v3 % b3);
}
function toVector2(a3) {
  return [a3[0], a3[1]];
}
function toVector3(a3) {
  return isVector2(a3) ? [a3[0], a3[1], 0] : a3;
}
function rad(a3) {
  const [x4, y4] = a3;
  if (!x4 && !y4)
    return 0;
  return Math.atan2(y4, x4);
}
function rotate(a3, angle2) {
  const [dx, dy] = a3;
  if (angle2 % 360 === 0)
    return [dx, dy];
  const rad2 = angle2 * Math.PI / 180;
  const cos = Math.cos(rad2);
  const sin = Math.sin(rad2);
  return [dx * cos - dy * sin, dx * sin + dy * cos];
}

// node_modules/@antv/g6/esm/utils/line.js
function isLinesParallel(l1, l22) {
  const [p1, p22] = l1;
  const [p3, p4] = l22;
  const v1 = subtract(p1, p22);
  const v22 = subtract(p3, p4);
  return cross(v1, v22).every((v3) => v3 === 0);
}
function getLinesIntersection(l1, l22, extended = false) {
  if (isLinesParallel(l1, l22))
    return void 0;
  const [p1, p22] = l1;
  const [p3, p4] = l22;
  const t3 = ((p1[0] - p3[0]) * (p3[1] - p4[1]) - (p1[1] - p3[1]) * (p3[0] - p4[0])) / ((p1[0] - p22[0]) * (p3[1] - p4[1]) - (p1[1] - p22[1]) * (p3[0] - p4[0]));
  const u3 = p4[0] - p3[0] ? (p1[0] - p3[0] + t3 * (p22[0] - p1[0])) / (p4[0] - p3[0]) : (p1[1] - p3[1] + t3 * (p22[1] - p1[1])) / (p4[1] - p3[1]);
  if (!extended && (!isBetween(t3, 0, 1) || !isBetween(u3, 0, 1)))
    return void 0;
  return [p1[0] + t3 * (p22[0] - p1[0]), p1[1] + t3 * (p22[1] - p1[1])];
}

// node_modules/@antv/g6/esm/utils/placement.js
function parsePlacement(placement) {
  if (Array.isArray(placement)) {
    return isBetween(placement[0], 0, 1) && isBetween(placement[1], 0, 1) ? placement : [0.5, 0.5];
  }
  const direction = placement.split("-");
  const x4 = direction.includes("left") ? 0 : direction.includes("right") ? 1 : 0.5;
  const y4 = direction.includes("top") ? 0 : direction.includes("bottom") ? 1 : 0.5;
  return [x4, y4];
}

// node_modules/@antv/g6/esm/utils/position.js
function positionOf(datum) {
  const { x: x4 = 0, y: y4 = 0, z: z4 = 0 } = datum.style || {};
  return [+x4, +y4, +z4];
}
function hasPosition(datum) {
  const { x: x4, y: y4, z: z4 } = datum.style || {};
  return x4 !== void 0 || y4 !== void 0 || z4 !== void 0;
}
function getXYByRelativePlacement(bbox, placement) {
  const [x4, y4] = placement;
  const { min: min2, max: max2 } = bbox;
  return [min2[0] + x4 * (max2[0] - min2[0]), min2[1] + y4 * (max2[1] - min2[1])];
}
function getXYByPlacement(bbox, placement = "center") {
  const relativePlacement = parsePlacement(placement);
  return getXYByRelativePlacement(bbox, relativePlacement);
}

// node_modules/@antv/g6/esm/utils/point.js
function parsePoint(point3) {
  var _a;
  return [point3.x, point3.y, (_a = point3.z) !== null && _a !== void 0 ? _a : 0];
}
function toPointObject(point3) {
  var _a;
  return { x: point3[0], y: point3[1], z: (_a = point3[2]) !== null && _a !== void 0 ? _a : 0 };
}
function round(point3, digits = 0) {
  return point3.map((p3) => parseFloat(p3.toFixed(digits)));
}
function moveTo(p3, ref, distance4, reverse = false) {
  if (is_equal_default(p3, ref))
    return p3;
  const direction = reverse ? subtract(p3, ref) : subtract(ref, p3);
  const normalizedDirection = normalize(direction);
  const moveVector = [normalizedDirection[0] * distance4, normalizedDirection[1] * distance4];
  return add(toVector2(p3), moveVector);
}
function isHorizontal(p1, p22) {
  return p1[1] === p22[1];
}
function isVertical(p1, p22) {
  return p1[0] === p22[0];
}
function isOrthogonal(p1, p22) {
  return isHorizontal(p1, p22) || isVertical(p1, p22);
}
function isCollinear(p1, p22, p3) {
  return isLinesParallel([p1, p22], [p22, p3]);
}
function getSymmetricPoint(p3, center) {
  return [2 * center[0] - p3[0], 2 * center[1] - p3[1]];
}
function getPolygonIntersectPoint(p3, center, points, isRelativePos = true, useExtendedLine = false) {
  for (let i2 = 0; i2 < points.length; i2++) {
    let start = points[i2];
    let end = points[(i2 + 1) % points.length];
    if (isRelativePos) {
      start = add(center, start);
      end = add(center, end);
    }
    const refP = useExtendedLine ? getSymmetricPoint(p3, center) : p3;
    const intersect = getLinesIntersection([center, refP], [start, end]);
    if (intersect) {
      return {
        point: intersect,
        line: [start, end]
      };
    }
  }
  return {
    point: center,
    line: void 0
  };
}
function isPointInPolygon(point3, points, start, end) {
  const x4 = point3[0];
  const y4 = point3[1];
  let inside = false;
  if (start === void 0)
    start = 0;
  if (end === void 0)
    end = points.length;
  const len = end - start;
  for (let i2 = 0, j2 = len - 1; i2 < len; j2 = i2++) {
    const xi = points[i2 + start][0];
    const yi = points[i2 + start][1];
    const xj = points[j2 + start][0];
    const yj = points[j2 + start][1];
    const intersect = yi > y4 !== yj > y4 && x4 < (xj - xi) * (y4 - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function getRectIntersectPoint(p3, bbox, useExtendedLine = false) {
  const center = getXYByPlacement(bbox, "center");
  const corners = [
    getXYByPlacement(bbox, "left-top"),
    getXYByPlacement(bbox, "right-top"),
    getXYByPlacement(bbox, "right-bottom"),
    getXYByPlacement(bbox, "left-bottom")
  ];
  return getPolygonIntersectPoint(p3, center, corners, false, useExtendedLine).point;
}
function getEllipseIntersectPoint(p3, bbox, useExtendedLine = false) {
  const center = bbox.center;
  const refP = useExtendedLine ? getSymmetricPoint(p3, center) : p3;
  const vec = subtract(refP, bbox.center);
  const angle2 = Math.atan2(vec[1], vec[0]);
  if (isNaN(angle2))
    return center;
  const rx = getBBoxWidth(bbox) / 2;
  const ry = getBBoxHeight(bbox) / 2;
  const intersectX = center[0] + rx * Math.cos(angle2);
  const intersectY = center[1] + ry * Math.sin(angle2);
  return [intersectX, intersectY];
}
function findNearestPoints(group1, group2) {
  let minDistance = Infinity;
  let nearestPoints = [group1[0], group2[0]];
  group1.forEach((p1) => {
    group2.forEach((p22) => {
      const dist = distance(p1, p22);
      if (dist < minDistance) {
        minDistance = dist;
        nearestPoints = [p1, p22];
      }
    });
  });
  return nearestPoints;
}
function findNearestLine(point3, lines) {
  let minDistance = Infinity;
  let nearestLine = [
    [0, 0],
    [0, 0]
  ];
  lines.forEach((line) => {
    const distance4 = getDistanceToLine(point3, line);
    if (distance4 < minDistance) {
      minDistance = distance4;
      nearestLine = line;
    }
  });
  return nearestLine;
}
function getDistanceToLine(point3, line) {
  const nearestPoint = findNearestPointOnLine(point3, line);
  return distance(point3, nearestPoint);
}
function findNearestPointOnLine(point3, line) {
  const [x1, y1] = line[0];
  const [x22, y22] = line[1];
  const [x32, y32] = point3;
  const px = x22 - x1;
  const py = y22 - y1;
  if (px === 0 && py === 0) {
    return [x1, y1];
  }
  let u3 = ((x32 - x1) * px + (y32 - y1) * py) / (px * px + py * py);
  if (u3 > 1) {
    u3 = 1;
  } else if (u3 < 0) {
    u3 = 0;
  }
  const x4 = x1 + u3 * px;
  const y4 = y1 + u3 * py;
  return [x4, y4];
}
function centerOf(points) {
  const totalPosition = points.reduce((acc, p3) => add(acc, p3), [0, 0]);
  return divide(totalPosition, points.length);
}
function sortByClockwise(points, clockwise = true) {
  const center = centerOf(points);
  return points.sort(([x1, y1], [x22, y22]) => {
    const angle1 = Math.atan2(y1 - center[1], x1 - center[0]);
    const angle2 = Math.atan2(y22 - center[1], x22 - center[0]);
    return clockwise ? angle2 - angle1 : angle1 - angle2;
  });
}
function getBoundingPoints(start, end) {
  return [start, [start[0], end[1]], end, [end[0], start[1]]];
}

// node_modules/@antv/g6/esm/utils/pinch.js
var PinchHandler = class _PinchHandler {
  constructor(emitter, phase, callback) {
    this.phase = phase;
    this.pointerByTouch = [];
    this.initialDistance = null;
    this.emitter = emitter;
    if (_PinchHandler.instance) {
      _PinchHandler.callbacks[this.phase].push(callback);
      return _PinchHandler.instance;
    }
    this.onPointerDown = this.onPointerDown.bind(this);
    this.onPointerMove = this.onPointerMove.bind(this);
    this.onPointerUp = this.onPointerUp.bind(this);
    this.bindEvents();
    _PinchHandler.instance = this;
    _PinchHandler.callbacks[this.phase].push(callback);
  }
  bindEvents() {
    const { emitter } = this;
    emitter.on(CommonEvent.POINTER_DOWN, this.onPointerDown);
    emitter.on(CommonEvent.POINTER_MOVE, this.onPointerMove);
    emitter.on(CommonEvent.POINTER_UP, this.onPointerUp);
  }
  /**
   * <zh/> 
   *
   * <en/> Update position of specified pointer
   * @param pointerId - <zh/>  | <en/> Pointer unique identifier<sup>1</sup>
   * @param x - <zh/> X | <en/> New X coordinate
   * @param y - <zh/> Y | <en/> New Y coordinate
   */
  updatePointerPosition(pointerId, x4, y4) {
    const index = this.pointerByTouch.findIndex((p3) => p3.pointerId === pointerId);
    if (index >= 0) {
      this.pointerByTouch[index] = { x: x4, y: y4, pointerId };
    }
  }
  /**
   * <zh/> 
   *
   * <en/> Handle pointer down event
   * @param event - <zh/>  | <en/> Pointer event object
   * @remarks
   * <zh/> 
   *
   * <en/> Record initial distance when detecting two touch points
   */
  onPointerDown(event) {
    const { x: x4, y: y4 } = event.client || {};
    if (x4 === void 0 || y4 === void 0)
      return;
    this.pointerByTouch.push({ x: x4, y: y4, pointerId: event.pointerId });
    if (event.pointerType === "touch" && this.pointerByTouch.length === 2) {
      _PinchHandler.isPinching = true;
      const dx = this.pointerByTouch[0].x - this.pointerByTouch[1].x;
      const dy = this.pointerByTouch[0].y - this.pointerByTouch[1].y;
      this.initialDistance = Math.sqrt(dx * dx + dy * dy);
      _PinchHandler.callbacks.pinchstart.forEach((cb) => cb(event, { scale: 0 }));
    }
  }
  /**
   * <zh/> 
   *
   * <en/> Handle pointer move event
   * @param event - <zh/>  | <en/> Pointer event object
   * @remarks
   * <zh/> 
   *
   * <en/> Calculate zoom ratio when two valid touch points exist
   */
  onPointerMove(event) {
    if (this.pointerByTouch.length !== 2 || this.initialDistance === null)
      return;
    const { x: x4, y: y4 } = event.client || {};
    if (x4 === void 0 || y4 === void 0)
      return;
    this.updatePointerPosition(event.pointerId, x4, y4);
    const dx = this.pointerByTouch[0].x - this.pointerByTouch[1].x;
    const dy = this.pointerByTouch[0].y - this.pointerByTouch[1].y;
    const currentDistance = Math.sqrt(dx * dx + dy * dy);
    const ratio = currentDistance / this.initialDistance;
    _PinchHandler.callbacks.pinchmove.forEach((cb) => cb(event, { scale: (ratio - 1) * 5 }));
  }
  /**
   * <zh/> 
   *
   * <en/> Handle pointer up event
   * @param event
   * @remarks
   * <zh/> 
   *
   * <en/> Reset touch state and initial distance
   */
  onPointerUp(event) {
    var _a;
    _PinchHandler.callbacks.pinchend.forEach((cb) => cb(event, { scale: 0 }));
    _PinchHandler.isPinching = false;
    this.initialDistance = null;
    this.pointerByTouch = [];
    (_a = _PinchHandler.instance) === null || _a === void 0 ? void 0 : _a.tryDestroy();
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy pinch gesture listeners
   * @remarks
   * <zh/> 
   *
   * <en/> Remove listeners for pointer down, move, and up events
   */
  destroy() {
    this.emitter.off(CommonEvent.POINTER_DOWN, this.onPointerDown);
    this.emitter.off(CommonEvent.POINTER_MOVE, this.onPointerMove);
    this.emitter.off(CommonEvent.POINTER_UP, this.onPointerUp);
    _PinchHandler.instance = null;
  }
  /**
   * <zh/> 
   * <en/> Unregister gesture callback for specific phase
   * @param phase - <zh/> (pinchstart)/(pinchmove)/(pinchend) | <en/> Gesture phase: start/move/end
   * @param callback - <zh/>  | <en/> Callback function to unregister
   * @remarks
   * <zh/> 
   * <en/> Remove specific callback from the phase's callback list, auto-destroy event listeners when all callbacks are unregistered
   */
  off(phase, callback) {
    const index = _PinchHandler.callbacks[phase].indexOf(callback);
    if (index > -1)
      _PinchHandler.callbacks[phase].splice(index, 1);
    this.tryDestroy();
  }
  /**
   * <zh/> 
   * <en/> Attempt to destroy the gesture handler
   * @remarks
   * <zh/> //
   * <en/> Perform actual destruction when all phase (pinchstart/pinchmove/pinchend) callback lists are empty
   * <zh/> 
   * <en/> Automatically remove event listeners and reset singleton instance
   */
  tryDestroy() {
    if (Object.values(_PinchHandler.callbacks).every((arr) => arr.length === 0)) {
      this.destroy();
    }
  }
};
PinchHandler.isPinching = false;
PinchHandler.instance = null;
PinchHandler.callbacks = { pinchstart: [], pinchmove: [], pinchend: [] };

// node_modules/@antv/g6/esm/utils/shortcut.js
var lowerCaseKeys = (keys) => keys.map((key) => isString(key) ? key.toLocaleLowerCase() : key);
var Shortcut = class {
  constructor(emitter) {
    this.map = /* @__PURE__ */ new Map();
    this.boundHandlePinch = () => {
    };
    this.recordKey = /* @__PURE__ */ new Set();
    this.onKeyDown = (event) => {
      if (!(event === null || event === void 0 ? void 0 : event.key))
        return;
      this.recordKey.add(event.key);
      this.trigger(event);
    };
    this.onKeyUp = (event) => {
      if (!(event === null || event === void 0 ? void 0 : event.key))
        return;
      this.recordKey.delete(event.key);
    };
    this.onWheel = (event) => {
      this.triggerExtendKey(CommonEvent.WHEEL, event);
    };
    this.onDrag = (event) => {
      this.triggerExtendKey(CommonEvent.DRAG, event);
    };
    this.handlePinch = (event, options) => {
      this.triggerExtendKey(CommonEvent.PINCH, Object.assign(Object.assign({}, event), options));
    };
    this.onFocus = () => {
      this.recordKey.clear();
    };
    this.emitter = emitter;
    this.bindEvents();
  }
  bind(key, handler) {
    if (key.length === 0)
      return;
    if (key.includes(CommonEvent.PINCH) && !this.pinchHandler) {
      this.boundHandlePinch = this.handlePinch.bind(this);
      this.pinchHandler = new PinchHandler(this.emitter, "pinchmove", this.boundHandlePinch);
    }
    this.map.set(key, handler);
  }
  unbind(key, handler) {
    this.map.forEach((h3, k2) => {
      if (is_equal_default(k2, key)) {
        if (!handler || handler === h3)
          this.map.delete(k2);
      }
    });
  }
  unbindAll() {
    this.map.clear();
  }
  match(key) {
    const recordKeyList = lowerCaseKeys(Array.from(this.recordKey)).sort();
    const keyList = lowerCaseKeys(key).sort();
    return is_equal_default(recordKeyList, keyList);
  }
  bindEvents() {
    var _a;
    const { emitter } = this;
    emitter.on(CommonEvent.KEY_DOWN, this.onKeyDown);
    emitter.on(CommonEvent.KEY_UP, this.onKeyUp);
    emitter.on(CommonEvent.WHEEL, this.onWheel);
    emitter.on(CommonEvent.DRAG, this.onDrag);
    (_a = globalThis.addEventListener) === null || _a === void 0 ? void 0 : _a.call(globalThis, "focus", this.onFocus);
  }
  trigger(event) {
    this.map.forEach((handler, key) => {
      if (this.match(key))
        handler(event);
    });
  }
  /**
   * <zh/>  wheel, drag 
   *
   * <en/> Extend wheel, drag operations
   * @param eventType - event name
   * @param event - event
   */
  triggerExtendKey(eventType, event) {
    this.map.forEach((handler, key) => {
      if (key.includes(eventType)) {
        if (is_equal_default(Array.from(this.recordKey), key.filter((k2) => k2 !== eventType))) {
          handler(event);
        }
      }
    });
  }
  destroy() {
    var _a, _b;
    this.unbindAll();
    this.emitter.off(CommonEvent.KEY_DOWN, this.onKeyDown);
    this.emitter.off(CommonEvent.KEY_UP, this.onKeyUp);
    this.emitter.off(CommonEvent.WHEEL, this.onWheel);
    this.emitter.off(CommonEvent.DRAG, this.onDrag);
    (_a = this.pinchHandler) === null || _a === void 0 ? void 0 : _a.off("pinchmove", this.boundHandlePinch);
    (_b = globalThis.removeEventListener) === null || _b === void 0 ? void 0 : _b.call(globalThis, "focus", this.onFocus);
  }
};

// node_modules/@antv/g6/esm/behaviors/brush-select.js
var BrushSelect = class _BrushSelect extends BaseBehavior {
  constructor(context, options) {
    super(context, deep_mix_default({}, _BrushSelect.defaultOptions, options));
    this.shortcut = new Shortcut(context.graph);
    this.onPointerDown = this.onPointerDown.bind(this);
    this.onPointerMove = this.onPointerMove.bind(this);
    this.onPointerUp = this.onPointerUp.bind(this);
    this.clearStates = this.clearStates.bind(this);
    this.bindEvents();
  }
  /**
   * Triggered when the pointer is pressed
   * @param event - Pointer event
   * @internal
   */
  onPointerDown(event) {
    if (!this.validate(event) || !this.isKeydown() || this.startPoint)
      return;
    const { canvas: canvas2, graph } = this.context;
    const style = Object.assign({}, this.options.style);
    if (this.options.style.lineWidth) {
      style.lineWidth = +this.options.style.lineWidth / graph.getZoom();
    }
    this.rectShape = new Rect({ id: "g6-brush-select", style });
    canvas2.appendChild(this.rectShape);
    this.startPoint = [event.canvas.x, event.canvas.y];
  }
  /**
   * Triggered when the pointer is moved
   * @param event - Pointer event
   * @internal
   */
  onPointerMove(event) {
    var _a;
    if (!this.startPoint)
      return;
    const { immediately, mode } = this.options;
    this.endPoint = getCursorPoint(event, this.context.graph);
    (_a = this.rectShape) === null || _a === void 0 ? void 0 : _a.attr({
      x: Math.min(this.endPoint[0], this.startPoint[0]),
      y: Math.min(this.endPoint[1], this.startPoint[1]),
      width: Math.abs(this.endPoint[0] - this.startPoint[0]),
      height: Math.abs(this.endPoint[1] - this.startPoint[1])
    });
    if (immediately && mode === "default")
      this.updateElementsStates(getBoundingPoints(this.startPoint, this.endPoint));
  }
  /**
   * Triggered when the pointer is released
   * @param event - Pointer event
   * @internal
   */
  onPointerUp(event) {
    if (!this.startPoint)
      return;
    if (!this.endPoint) {
      this.clearBrush();
      return;
    }
    this.endPoint = getCursorPoint(event, this.context.graph);
    this.updateElementsStates(getBoundingPoints(this.startPoint, this.endPoint));
    this.clearBrush();
  }
  /**
   * <zh/> 
   *
   * <en/> Clear state
   * @internal
   */
  clearStates() {
    if (this.endPoint)
      return;
    this.clearElementsStates();
  }
  /**
   * <zh/> 
   *
   * <en/> Clear the state of all elements on the canvas
   * @internal
   */
  clearElementsStates() {
    const { graph } = this.context;
    const states = Object.values(graph.getData()).reduce((acc, data) => {
      return Object.assign({}, acc, data.reduce((acc2, datum) => {
        var _a;
        const restStates = (_a = datum.states || []) === null || _a === void 0 ? void 0 : _a.filter((state) => state !== this.options.state);
        acc2[idOf(datum)] = restStates;
        return acc2;
      }, {}));
    }, {});
    graph.setElementState(states, this.options.animation);
  }
  /**
   * <zh/> 
   *
   * <en/> Update the state of the selected elements
   * @param points - <zh/>  | <en/> The vertex of the selection area
   * @internal
   */
  updateElementsStates(points) {
    const { graph } = this.context;
    const { enableElements, state, mode, onSelect } = this.options;
    const selectedIds = this.selector(graph, points, enableElements);
    const states = {};
    switch (mode) {
      case "union":
        selectedIds.forEach((id) => {
          states[id] = [...graph.getElementState(id), state];
        });
        break;
      case "diff":
        selectedIds.forEach((id) => {
          const prevStates = graph.getElementState(id);
          states[id] = prevStates.includes(state) ? prevStates.filter((s2) => s2 !== state) : [...prevStates, state];
        });
        break;
      case "intersect":
        selectedIds.forEach((id) => {
          const prevStates = graph.getElementState(id);
          states[id] = prevStates.includes(state) ? [state] : [];
        });
        break;
      case "default":
      default:
        selectedIds.forEach((id) => {
          states[id] = [state];
        });
        break;
    }
    if (isFunction(onSelect))
      onSelect(states);
    graph.setElementState(states, this.options.animation);
  }
  /**
   * <zh/>  combo combo 
   *
   * <en/> Find the elements displayed in the specified area on the canvas. A node is selected if the center of its bbox is inside the rect; An edge is selected if both end nodes are inside the rect ;A combo is selected if the center of its bbox is inside the rect.
   * @param graph - <zh/>  | <en/> Graph instance
   * @param points - <zh/>  | <en/> The vertex of the selection area
   * @param itemTypes - <zh/>  | <en/> Element type
   * @returns <zh/>  ID  | <en/> Selected element ID array
   * @internal
   */
  selector(graph, points, itemTypes) {
    if (!itemTypes || itemTypes.length === 0)
      return [];
    const elements = [];
    const graphData = graph.getData();
    itemTypes.forEach((itemType) => {
      graphData[`${itemType}s`].forEach((datum) => {
        const id = idOf(datum);
        if (graph.getElementVisibility(id) !== "hidden" && isPointInPolygon(graph.getElementPosition(id), points)) {
          elements.push(id);
        }
      });
    });
    if (itemTypes.includes("edge")) {
      const edges = graphData.edges;
      edges === null || edges === void 0 ? void 0 : edges.forEach((edge) => {
        const { source, target } = edge;
        if (elements.includes(source) && elements.includes(target)) {
          elements.push(idOf(edge));
        }
      });
    }
    return elements;
  }
  clearBrush() {
    var _a;
    (_a = this.rectShape) === null || _a === void 0 ? void 0 : _a.remove();
    this.rectShape = void 0;
    this.startPoint = void 0;
    this.endPoint = void 0;
  }
  /**
   * <zh/>  trigger 
   *
   * <en/> Is the current key consistent with the trigger configuration
   * @returns <zh/>  | <en/> Is consistent
   * @internal
   */
  isKeydown() {
    const { trigger } = this.options;
    const keys = Array.isArray(trigger) ? trigger : [trigger];
    return this.shortcut.match(keys.filter((key) => key !== "drag"));
  }
  /**
   * <zh/> 
   *
   * <en/> Verify whether brush select is enabled
   * @param event - <zh/>  | <en/> Event
   * @returns <zh/>  | <en/> Whether to enable
   * @internal
   */
  validate(event) {
    if (this.destroyed)
      return false;
    const { enable } = this.options;
    if (isFunction(enable))
      return enable(event);
    return !!enable;
  }
  bindEvents() {
    const { graph } = this.context;
    graph.on(CommonEvent.POINTER_DOWN, this.onPointerDown);
    graph.on(CommonEvent.POINTER_MOVE, this.onPointerMove);
    graph.on(CommonEvent.POINTER_UP, this.onPointerUp);
    graph.on(CanvasEvent2.CLICK, this.clearStates);
  }
  unbindEvents() {
    const { graph } = this.context;
    graph.off(CommonEvent.POINTER_DOWN, this.onPointerDown);
    graph.off(CommonEvent.POINTER_MOVE, this.onPointerMove);
    graph.off(CommonEvent.POINTER_UP, this.onPointerUp);
    graph.off(CanvasEvent2.CLICK, this.clearStates);
  }
  /**
   * <zh/> 
   *
   * <en/> Update configuration
   * @param options - <zh/>  | <en/> Options
   * @internal
   */
  update(options) {
    this.unbindEvents();
    this.options = deep_mix_default(this.options, options);
    this.bindEvents();
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy
   * @internal
   */
  destroy() {
    this.unbindEvents();
    super.destroy();
  }
};
BrushSelect.defaultOptions = {
  animation: false,
  enable: true,
  enableElements: ["node", "combo", "edge"],
  immediately: false,
  mode: "default",
  state: "selected",
  trigger: ["shift"],
  style: {
    width: 0,
    height: 0,
    lineWidth: 1,
    fill: "#1677FF",
    stroke: "#1677FF",
    fillOpacity: 0.1,
    zIndex: 2,
    pointerEvents: "none"
  }
};
var getCursorPoint = (event, graph) => {
  if ((event.targetType === "node" || event.targetType === "combo") && !(event.nativeEvent.target instanceof HTMLCanvasElement)) {
    const [x4, y4] = graph.getCanvasByClient([event.client.x, event.client.y]);
    return [x4, y4];
  }
  return [event.canvas.x, event.canvas.y];
};

// node_modules/@antv/g6/esm/constants/element.js
var ICON_SIZE_RATIO = 0.8;
var ELEMENT_TYPES = ["node", "edge", "combo"];

// node_modules/@antv/g6/esm/utils/traverse.js
function dfs(node, visitor, navigator2, mode, depth = 0) {
  if (mode === "TB")
    visitor(node, depth);
  const children = navigator2(node);
  if (children) {
    for (const child of children) {
      dfs(child, visitor, navigator2, mode, depth + 1);
    }
  }
  if (mode === "BT")
    visitor(node, depth);
}
function bfs(node, visitor, navigator2) {
  const queue = [[node, 0]];
  while (queue.length) {
    const [current2, depth] = queue.shift();
    visitor(current2, depth);
    const children = navigator2(current2);
    if (children) {
      for (const child of children) {
        queue.push([child, depth + 1]);
      }
    }
  }
}

// node_modules/@antv/g6/esm/utils/relation.js
function getElementNthDegreeIds(graph, elementType, elementId, degree3, direction = "both") {
  if (elementType === "combo" || elementType === "node") {
    return getNodeNthDegreeIds(graph, elementId, degree3, direction);
  }
  const edgeData = graph.getEdgeData(elementId);
  if (!edgeData)
    return [];
  const sourceRelations = getNodeNthDegreeIds(graph, edgeData.source, degree3 - 1, direction);
  const targetRelations = getNodeNthDegreeIds(graph, edgeData.target, degree3 - 1, direction);
  return Array.from(/* @__PURE__ */ new Set([...sourceRelations, ...targetRelations, elementId]));
}
function getNodeNthDegreeIds(graph, startNodeId, degree3, direction = "both") {
  const visitedNodes = /* @__PURE__ */ new Set();
  const visitedEdges = /* @__PURE__ */ new Set();
  const relations = /* @__PURE__ */ new Set();
  bfs(startNodeId, (nodeId, depth) => {
    if (depth > degree3)
      return;
    relations.add(nodeId);
    graph.getRelatedEdgesData(nodeId, direction).forEach((edge) => {
      const edgeId = idOf(edge);
      if (!visitedEdges.has(edgeId) && depth < degree3) {
        relations.add(edgeId);
        visitedEdges.add(edgeId);
      }
    });
  }, (nodeId) => {
    return graph.getRelatedEdgesData(nodeId, direction).map((edge) => edge.source === nodeId ? edge.target : edge.source).filter((neighborNodeId) => {
      if (!visitedNodes.has(neighborNodeId)) {
        visitedNodes.add(neighborNodeId);
        return true;
      }
      return false;
    });
  });
  return Array.from(relations);
}

// node_modules/@antv/g6/esm/utils/state.js
function statesOf(datum) {
  return datum.states || [];
}

// node_modules/@antv/g6/esm/behaviors/click-select.js
var __awaiter2 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ClickSelect = class _ClickSelect extends BaseBehavior {
  constructor(context, options) {
    super(context, Object.assign({}, _ClickSelect.defaultOptions, options));
    this.onClickSelect = (event) => __awaiter2(this, void 0, void 0, function* () {
      var _a, _b;
      if (!this.validate(event))
        return;
      yield this.updateState(event);
      (_b = (_a = this.options).onClick) === null || _b === void 0 ? void 0 : _b.call(_a, event);
    });
    this.onClickCanvas = (event) => __awaiter2(this, void 0, void 0, function* () {
      var _a, _b;
      if (!this.validate(event))
        return;
      yield this.clearState();
      (_b = (_a = this.options).onClick) === null || _b === void 0 ? void 0 : _b.call(_a, event);
    });
    this.shortcut = new Shortcut(context.graph);
    this.bindEvents();
  }
  bindEvents() {
    const { graph } = this.context;
    this.unbindEvents();
    ELEMENT_TYPES.forEach((type) => {
      graph.on(`${type}:${CommonEvent.CLICK}`, this.onClickSelect);
    });
    graph.on(CanvasEvent2.CLICK, this.onClickCanvas);
  }
  get isMultipleSelect() {
    const { multiple, trigger } = this.options;
    return multiple && this.shortcut.match(trigger);
  }
  getNeighborIds(event) {
    const { target, targetType } = event;
    const { graph } = this.context;
    const { degree: degree3 } = this.options;
    return getElementNthDegreeIds(graph, targetType, target.id, typeof degree3 === "function" ? degree3(event) : degree3).filter((id) => id !== target.id);
  }
  updateState(event) {
    return __awaiter2(this, void 0, void 0, function* () {
      const { state: selectState, unselectedState, neighborState, animation } = this.options;
      if (!selectState && !neighborState && !unselectedState)
        return;
      const { target } = event;
      const { graph } = this.context;
      const datum = graph.getElementData(target.id);
      const type = statesOf(datum).includes(selectState) ? "unselect" : "select";
      const states = {};
      const isMultipleSelect = this.isMultipleSelect;
      const click = [target.id];
      const neighbor = this.getNeighborIds(event);
      if (!isMultipleSelect) {
        if (type === "select") {
          Object.assign(states, this.getClearStates(!!unselectedState));
          const addState = (list, state) => {
            list.forEach((id) => {
              if (!states[id])
                states[id] = graph.getElementState(id);
              states[id].push(state);
            });
          };
          addState(click, selectState);
          addState(neighbor, neighborState);
          if (unselectedState) {
            Object.keys(states).forEach((id) => {
              if (!click.includes(id) && !neighbor.includes(id))
                states[id].push(unselectedState);
            });
          }
        } else
          Object.assign(states, this.getClearStates());
      } else {
        Object.assign(states, this.getDataStates());
        if (type === "select") {
          const addState = (list, state) => {
            list.forEach((id) => {
              const dataStatesSet = new Set(graph.getElementState(id));
              dataStatesSet.add(state);
              dataStatesSet.delete(unselectedState);
              states[id] = Array.from(dataStatesSet);
            });
          };
          addState(click, selectState);
          addState(neighbor, neighborState);
          if (unselectedState) {
            Object.keys(states).forEach((id) => {
              const _states = states[id];
              if (!_states.includes(selectState) && !_states.includes(neighborState) && !_states.includes(unselectedState)) {
                states[id].push(unselectedState);
              }
            });
          }
        } else {
          const targetState = states[target.id];
          states[target.id] = targetState.filter((s2) => s2 !== selectState && s2 !== neighborState);
          if (!targetState.includes(unselectedState))
            states[target.id].push(unselectedState);
          neighbor.forEach((id) => {
            states[id] = states[id].filter((s2) => s2 !== neighborState);
            if (!states[id].includes(selectState))
              states[id].push(unselectedState);
          });
        }
      }
      yield graph.setElementState(states, animation);
    });
  }
  getDataStates() {
    const { graph } = this.context;
    const { nodes, edges, combos } = graph.getData();
    const states = {};
    [...nodes, ...edges, ...combos].forEach((data) => {
      states[idOf(data)] = statesOf(data);
    });
    return states;
  }
  /**
   * <zh/> 
   *
   * <en/> Get the states that need to be cleared
   * @param complete - <zh/>  | <en/> Whether to return all states
   * @returns - <zh/>  | <en/> States that need to be cleared
   */
  getClearStates(complete = false) {
    const { graph } = this.context;
    const { state, unselectedState, neighborState } = this.options;
    const statesToClear = /* @__PURE__ */ new Set([state, unselectedState, neighborState]);
    const { nodes, edges, combos } = graph.getData();
    const states = {};
    [...nodes, ...edges, ...combos].forEach((data) => {
      const datumStates = statesOf(data);
      const newStates = datumStates.filter((s2) => !statesToClear.has(s2));
      if (complete)
        states[idOf(data)] = newStates;
      else if (newStates.length !== datumStates.length)
        states[idOf(data)] = newStates;
    });
    return states;
  }
  clearState() {
    return __awaiter2(this, void 0, void 0, function* () {
      const { graph } = this.context;
      yield graph.setElementState(this.getClearStates(), this.options.animation);
    });
  }
  validate(event) {
    if (this.destroyed)
      return false;
    const { enable } = this.options;
    if (isFunction(enable))
      return enable(event);
    return !!enable;
  }
  unbindEvents() {
    const { graph } = this.context;
    ELEMENT_TYPES.forEach((type) => {
      graph.off(`${type}:${CommonEvent.CLICK}`, this.onClickSelect);
    });
    graph.off(CanvasEvent2.CLICK, this.onClickCanvas);
  }
  destroy() {
    this.unbindEvents();
    super.destroy();
  }
};
ClickSelect.defaultOptions = {
  animation: true,
  enable: true,
  multiple: false,
  trigger: ["shift"],
  state: "selected",
  neighborState: "selected",
  unselectedState: void 0,
  degree: 0
};

// node_modules/@antv/g6/esm/utils/collapsibility.js
function isCollapsed(nodeLike) {
  var _a;
  return !!((_a = nodeLike.style) === null || _a === void 0 ? void 0 : _a.collapsed);
}

// node_modules/@antv/g6/esm/utils/prefix.js
function startsWith(str, prefix) {
  if (!str.startsWith(prefix))
    return false;
  const nextChart = str[prefix.length];
  return nextChart >= "A" && nextChart <= "Z";
}
function addPrefix(str, prefix) {
  return `${prefix}${upper_first_default(str)}`;
}
function removePrefix(string, prefix, lowercaseFirstLetter = true) {
  if (!prefix)
    return string;
  if (!startsWith(string, prefix))
    return string;
  const str = string.slice(prefix.length);
  return lowercaseFirstLetter ? lower_first_default(str) : str;
}
function subStyleProps(style, prefix) {
  const subStyle = Object.entries(style).reduce((acc, [key, value]) => {
    if (key === "className" || key === "class")
      return acc;
    if (startsWith(key, prefix)) {
      Object.assign(acc, { [removePrefix(key, prefix)]: value });
    }
    return acc;
  }, {});
  if ("opacity" in style) {
    const subOpacityKey = addPrefix("opacity", prefix);
    const opacity = style.opacity;
    if (subOpacityKey in style) {
      const subOpacity = style[subOpacityKey];
      Object.assign(subStyle, { opacity: opacity * subOpacity });
    } else
      Object.assign(subStyle, { opacity });
  }
  return subStyle;
}
function subObject(obj, prefix) {
  const prefixLength = prefix.length;
  return Object.keys(obj).reduce((acc, key) => {
    if (key.startsWith(prefix)) {
      const newKey = key.slice(prefixLength);
      acc[newKey] = obj[key];
    }
    return acc;
  }, {});
}
function omitStyleProps(style, prefix) {
  const prefixArray = typeof prefix === "string" ? [prefix] : prefix;
  const omitStyle = {};
  Object.keys(style).forEach((key) => {
    if (!prefixArray.find((p3) => key.startsWith(p3))) {
      omitStyle[key] = style[key];
    }
  });
  return omitStyle;
}

// node_modules/@antv/g6/esm/utils/size.js
function parseSize(size2 = 0) {
  if (typeof size2 === "number")
    return [size2, size2, size2];
  const [x4, y4 = x4, z4 = x4] = size2;
  return [x4, y4, z4];
}

// node_modules/@antv/g6/esm/utils/style.js
var __rest3 = function(s2, e2) {
  var t3 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t3[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t3[p3[i2]] = s2[p3[i2]];
    }
  return t3;
};
function computeElementCallbackStyle(callableStyle, context) {
  const { datum, graph } = context;
  if (typeof callableStyle === "function")
    return callableStyle.call(graph, datum);
  return Object.fromEntries(Object.entries(callableStyle).map(([key, style]) => {
    if (typeof style === "function")
      return [key, style.call(graph, datum)];
    return [key, style];
  }));
}
function mergeOptions(defaultOptions4, modifiedOptions) {
  const s1 = (defaultOptions4 === null || defaultOptions4 === void 0 ? void 0 : defaultOptions4.style) || {};
  const s2 = (modifiedOptions === null || modifiedOptions === void 0 ? void 0 : modifiedOptions.style) || {};
  for (const key in s1) {
    if (!(key in s2))
      s2[key] = s1[key];
  }
  return Object.assign({}, defaultOptions4, modifiedOptions, {
    style: s2
  });
}
function getSubShapeStyle(style) {
  const { x: x4, y: y4, z: z4, class: cls, className, transform, transformOrigin, zIndex, visibility } = style, rest = __rest3(style, ["x", "y", "z", "class", "className", "transform", "transformOrigin", "zIndex", "visibility"]);
  return rest;
}

// node_modules/@antv/g6/esm/utils/node.js
function inferIconStyle(size2, iconStyle) {
  const stdSize = parseSize(size2);
  let style = {};
  if (iconStyle.text && !iconStyle.fontSize)
    style = { fontSize: Math.min(...stdSize) * 0.5 };
  if (iconStyle.src && (!iconStyle.width || !iconStyle.height))
    style = { width: stdSize[0] * 0.5, height: stdSize[1] * 0.5 };
  return style;
}

// node_modules/@antv/g6/esm/utils/palette.js
function parsePalette(palette) {
  if (!palette)
    return void 0;
  if (
    //  palette name
    typeof palette === "string" || //  interpolate function
    typeof palette === "function" || //  color array
    Array.isArray(palette)
  ) {
    return {
      type: "group",
      field: (d3) => d3.id,
      color: palette,
      invert: false
    };
  }
  return palette;
}
function assignColorByPalette(data, palette) {
  if (!palette)
    return {};
  const { type, color: colorPalette, field, invert } = palette;
  const assignColor = (args) => {
    const palette2 = typeof colorPalette === "string" ? getExtension("palette", colorPalette) : colorPalette;
    if (typeof palette2 === "function") {
      const result = {};
      args.forEach(([id, value]) => {
        result[id] = palette2(invert ? 1 - value : value);
      });
      return result;
    } else if (Array.isArray(palette2)) {
      const colors = invert ? [...palette2].reverse() : palette2;
      const result = {};
      args.forEach(([id, index]) => {
        result[id] = colors[index % palette2.length];
      });
      return result;
    }
    return {};
  };
  const parseField = (field2, datum) => {
    var _a;
    return typeof field2 === "string" ? (_a = datum.data) === null || _a === void 0 ? void 0 : _a[field2] : field2 === null || field2 === void 0 ? void 0 : field2(datum);
  };
  if (type === "group") {
    const groupData = group_by_default(data, (datum) => {
      if (!field)
        return "default";
      const key = parseField(field, datum);
      return key ? String(key) : "default";
    });
    const groupKeys = Object.keys(groupData);
    const assignResult = assignColor(groupKeys.map((key, index) => [key, index]));
    const result = {};
    Object.entries(groupData).forEach(([groupKey, groupData2]) => {
      groupData2.forEach((datum) => {
        result[idOf(datum)] = assignResult[groupKey];
      });
    });
    return result;
  } else if (type === "value") {
    const [min2, max2] = data.reduce(([min3, max3], datum) => {
      const value = parseField(field, datum);
      if (typeof value !== "number")
        throw new Error(format(`Palette field ${field} is not a number`));
      return [Math.min(min3, value), Math.max(max3, value)];
    }, [Infinity, -Infinity]);
    const range = max2 - min2;
    return assignColor(data.map((datum) => [datum.id, (parseField(field, datum) - min2) / range]));
  }
}
function getPaletteColors(colorPalette) {
  const palette = typeof colorPalette === "string" ? getExtension("palette", colorPalette) : colorPalette;
  if (typeof palette === "function")
    return void 0;
  return palette;
}

// node_modules/@antv/g6/esm/utils/text.js
function getWordWrapWidthWithBase(length, maxWidth) {
  let wordWrapWidth = 2 * length;
  if (typeof maxWidth === "string") {
    wordWrapWidth = length * Number(maxWidth.replace("%", "")) / 100;
  } else if (typeof maxWidth === "number") {
    wordWrapWidth = maxWidth;
  }
  if (isNaN(wordWrapWidth))
    wordWrapWidth = 2 * length;
  return wordWrapWidth;
}
function getWordWrapWidthByBox(keyShapeBox, maxWidth, zoom = 1, enableBalanceShape = false) {
  const balanceZoom = enableBalanceShape ? zoom : 1;
  const keyShapeWidth = (keyShapeBox.max[0] - keyShapeBox.min[0]) * balanceZoom;
  return getWordWrapWidthWithBase(keyShapeWidth, maxWidth);
}
function getWordWrapWidthByEnds(points, maxWidth, zoom = 1) {
  const dist = distance(points[0], points[1]) * zoom;
  return getWordWrapWidthWithBase(dist, maxWidth);
}

// node_modules/@antv/g6/esm/elements/shapes/base-shape.js
var BaseShape = class extends CustomElement {
  constructor(options) {
    applyTransform(options.style);
    super(options);
    this.shapeMap = {};
    this.animateMap = {};
    this.render(this.attributes, this);
    this.setVisibility();
    this.bindEvents();
  }
  /**
   * <zh/> 
   *
   * <en/> parsed attributes
   * @returns <zh/>  | <en/> parsed attributes
   * @internal
   */
  get parsedAttributes() {
    return this.attributes;
  }
  /**
   * <zh/> 
   *
   * <en/> create, update or remove shape
   * @param className - <zh/>  | <en/> shape name
   * @param Ctor - <zh/>  | <en/> shape type
   * @param style - <zh/>  false | <en/> shape style. Pass false to remove the shape
   * @param container - <zh/>  | <en/> container
   * @param hooks - <zh/>  | <en/> hooks
   * @returns <zh/>  | <en/> shape instance
   */
  upsert(className, Ctor, style, container, hooks) {
    var _a, _b, _c, _d, _e2, _f, _g, _h;
    const target = this.shapeMap[className];
    if (style === false) {
      if (target) {
        (_a = hooks === null || hooks === void 0 ? void 0 : hooks.beforeDestroy) === null || _a === void 0 ? void 0 : _a.call(hooks, target);
        container.removeChild(target);
        delete this.shapeMap[className];
        (_b = hooks === null || hooks === void 0 ? void 0 : hooks.afterDestroy) === null || _b === void 0 ? void 0 : _b.call(hooks, target);
      }
      return;
    }
    const _Ctor = typeof Ctor === "string" ? getExtension(ExtensionCategory.SHAPE, Ctor) : Ctor;
    if (!_Ctor) {
      throw new Error(format(`Shape ${Ctor} not found`));
    }
    if (!target || target.destroyed || !(target instanceof _Ctor)) {
      if (target) {
        (_c = hooks === null || hooks === void 0 ? void 0 : hooks.beforeDestroy) === null || _c === void 0 ? void 0 : _c.call(hooks, target);
        target === null || target === void 0 ? void 0 : target.destroy();
        (_d = hooks === null || hooks === void 0 ? void 0 : hooks.afterDestroy) === null || _d === void 0 ? void 0 : _d.call(hooks, target);
      }
      (_e2 = hooks === null || hooks === void 0 ? void 0 : hooks.beforeCreate) === null || _e2 === void 0 ? void 0 : _e2.call(hooks);
      const instance = new _Ctor({ className, style });
      container.appendChild(instance);
      this.shapeMap[className] = instance;
      (_f = hooks === null || hooks === void 0 ? void 0 : hooks.afterCreate) === null || _f === void 0 ? void 0 : _f.call(hooks, instance);
      return instance;
    }
    (_g = hooks === null || hooks === void 0 ? void 0 : hooks.beforeUpdate) === null || _g === void 0 ? void 0 : _g.call(hooks, target);
    updateStyle(target, style);
    (_h = hooks === null || hooks === void 0 ? void 0 : hooks.afterUpdate) === null || _h === void 0 ? void 0 : _h.call(hooks, target);
    return target;
  }
  update(attr = {}) {
    const attributes = Object.assign({}, this.attributes, attr);
    applyTransform(attributes);
    setAttributes(this, attributes);
    this.render(attributes, this);
    this.setVisibility();
  }
  bindEvents() {
  }
  /**
   * <zh/> 
   *
   * <en/> Extracts the shape styles from a given attribute object.
   * Removes specific styles like position, transformation, and class name.
   * @param style - <zh/>  | <en/> attribute object
   * @returns <zh/>  | <en/> An object containing only the style properties.
   */
  getGraphicStyle(style) {
    return getSubShapeStyle(style);
  }
  /**
   * Get the prefix pairs for composite shapes used to handle animation
   * @returns tuples array where each tuple contains a key corresponding to a method `get${key}Style` and its shape prefix
   * @internal
   */
  get compositeShapes() {
    return [
      ["badges", "badge-"],
      ["ports", "port-"]
    ];
  }
  animate(keyframes, options) {
    if (keyframes.length === 0)
      return null;
    const animationMap = [];
    if (keyframes[0].x !== void 0 || keyframes[0].y !== void 0 || keyframes[0].z !== void 0) {
      const { x: _x = 0, y: _y = 0, z: _z = 0 } = this.attributes;
      keyframes.forEach((keyframe) => {
        const { x: x4 = _x, y: y4 = _y, z: z4 = _z } = keyframe;
        Object.assign(keyframe, { transform: z4 ? [["translate3d", x4, y4, z4]] : [["translate", x4, y4]] });
      });
    }
    const result = super.animate(keyframes, options);
    if (result) {
      releaseAnimation(this, result);
      animationMap.push(result);
    }
    if (Array.isArray(keyframes) && keyframes.length > 0) {
      const skippedAttrs = ["transform", "transformOrigin", "x", "y", "z", "zIndex"];
      if (Object.keys(keyframes[0]).some((attr) => !skippedAttrs.includes(attr))) {
        Object.entries(this.shapeMap).forEach(([key, shape]) => {
          const methodName = `get${upper_first_default(key)}Style`;
          const method = this[methodName];
          if (isFunction(method)) {
            const subKeyframes = keyframes.map((style) => method.call(this, Object.assign(Object.assign({}, this.attributes), style)));
            const result2 = shape.animate(preprocessKeyframes(subKeyframes), options);
            if (result2) {
              releaseAnimation(shape, result2);
              animationMap.push(result2);
            }
          }
        });
        const handleCompositeShapeAnimation = (shapeSet, name) => {
          if (!is_empty_default(shapeSet)) {
            const methodName = `get${upper_first_default(name)}Style`;
            const method = this[methodName];
            if (isFunction(method)) {
              const itemsKeyframes = keyframes.map((style) => method.call(this, Object.assign(Object.assign({}, this.attributes), style)));
              Object.entries(itemsKeyframes[0]).map(([key]) => {
                const subKeyframes = itemsKeyframes.map((styles) => styles[key]);
                const shape = shapeSet[key];
                if (shape) {
                  const result2 = shape.animate(preprocessKeyframes(subKeyframes), options);
                  if (result2) {
                    releaseAnimation(shape, result2);
                    animationMap.push(result2);
                  }
                }
              });
            }
          }
        };
        this.compositeShapes.forEach(([key, prefix]) => {
          const shapeSet = subObject(this.shapeMap, prefix);
          handleCompositeShapeAnimation(shapeSet, key);
        });
      }
    }
    return createAnimationsProxy(animationMap);
  }
  getShape(name) {
    return this.shapeMap[name];
  }
  setVisibility() {
    const { visibility } = this.attributes;
    setVisibility(this, visibility);
  }
  destroy() {
    this.shapeMap = {};
    this.animateMap = {};
    super.destroy();
  }
};
function releaseAnimation(target, animation) {
  animation === null || animation === void 0 ? void 0 : animation.finished.then(() => {
    const index = target.activeAnimations.findIndex((_2) => _2 === animation);
    if (index > -1)
      target.activeAnimations.splice(index, 1);
  });
}
function applyTransform(style) {
  if (!style)
    return {};
  if ("x" in style || "y" in style || "z" in style) {
    const { x: x4 = 0, y: y4 = 0, z: z4, transform } = style;
    const newTransform = replaceTranslateInTransform(x4, y4, z4, transform);
    if (newTransform)
      style.transform = newTransform;
  }
  return style;
}

// node_modules/@antv/g6/esm/elements/shapes/label.js
var __rest4 = function(s2, e2) {
  var t3 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t3[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t3[p3[i2]] = s2[p3[i2]];
    }
  return t3;
};
var Label = class _Label extends BaseShape {
  constructor(options) {
    super(mergeOptions({ style: _Label.defaultStyleProps }, options));
  }
  isTextStyle(key) {
    return startsWith(key, "label");
  }
  isBackgroundStyle(key) {
    return startsWith(key, "background");
  }
  getTextStyle(attributes) {
    const _a = this.getGraphicStyle(attributes), { padding } = _a, style = __rest4(_a, ["padding"]);
    return omitStyleProps(style, "background");
  }
  getBackgroundStyle(attributes) {
    if (attributes.background === false)
      return false;
    const style = this.getGraphicStyle(attributes);
    const { wordWrap, wordWrapWidth, padding } = style;
    const backgroundStyle = subStyleProps(style, "background");
    const { min: [minX, minY], center: [centerX, centerY], halfExtents: [halfWidth, halfHeight] } = this.shapeMap.text.getGeometryBounds();
    const [top, right, bottom, left] = parsePadding(padding);
    const totalWidth = halfWidth * 2 + left + right;
    const { width: width2, height } = backgroundStyle;
    if (width2 && height) {
      Object.assign(backgroundStyle, { x: centerX - Number(width2) / 2, y: centerY - Number(height) / 2 });
    } else {
      Object.assign(backgroundStyle, {
        x: minX - left,
        y: minY - top,
        width: wordWrap ? Math.min(totalWidth, wordWrapWidth + left + right) : totalWidth,
        height: halfHeight * 2 + top + bottom
      });
    }
    const { radius } = backgroundStyle;
    if (typeof radius === "string" && radius.endsWith("%")) {
      const percentage = Number(radius.replace("%", "")) / 100;
      backgroundStyle.radius = Math.min(+backgroundStyle.width, +backgroundStyle.height) * percentage;
    }
    return backgroundStyle;
  }
  render(attributes = this.parsedAttributes, container = this) {
    this.upsert("text", Text, this.getTextStyle(attributes), container);
    this.upsert("background", Rect, this.getBackgroundStyle(attributes), container);
  }
  getGeometryBounds() {
    const shape = this.getShape("background") || this.getShape("text");
    return shape.getGeometryBounds();
  }
};
Label.defaultStyleProps = {
  padding: 0,
  fontSize: 12,
  fontFamily: "system-ui, sans-serif",
  wordWrap: true,
  maxLines: 1,
  wordWrapWidth: 128,
  textOverflow: "...",
  textBaseline: "middle",
  backgroundOpacity: 0.75,
  backgroundZIndex: -1,
  backgroundLineWidth: 0
};

// node_modules/@antv/g6/esm/elements/shapes/badge.js
var Badge = class _Badge extends BaseShape {
  constructor(options) {
    super(mergeOptions({ style: _Badge.defaultStyleProps }, options));
  }
  getBadgeStyle(attributes) {
    return this.getGraphicStyle(attributes);
  }
  render(attributes = this.parsedAttributes, container = this) {
    this.upsert("label", Label, this.getBadgeStyle(attributes), container);
  }
  getGeometryBounds() {
    const labelShape = this.getShape("label");
    const shape = labelShape.getShape("background") || labelShape.getShape("text");
    return shape.getGeometryBounds();
  }
};
Badge.defaultStyleProps = {
  padding: [2, 4, 2, 4],
  fontSize: 10,
  wordWrap: false,
  backgroundRadius: "50%",
  backgroundOpacity: 1
};

// node_modules/@antv/g6/esm/utils/path.js
function pointsToPath(points, isClose = true) {
  const path = [];
  points.forEach((point3, index) => {
    path.push([index === 0 ? "M" : "L", ...point3]);
  });
  if (isClose) {
    path.push(["Z"]);
  }
  return path;
}
var PATH_COMMANDS = {
  M: ["x", "y"],
  m: ["dx", "dy"],
  H: ["x"],
  h: ["dx"],
  V: ["y"],
  v: ["dy"],
  L: ["x", "y"],
  l: ["dx", "dy"],
  Z: [],
  z: [],
  C: ["x1", "y1", "x2", "y2", "x", "y"],
  c: ["dx1", "dy1", "dx2", "dy2", "dx", "dy"],
  S: ["x2", "y2", "x", "y"],
  s: ["dx2", "dy2", "dx", "dy"],
  Q: ["x1", "y1", "x", "y"],
  q: ["dx1", "dy1", "dx", "dy"],
  T: ["x", "y"],
  t: ["dx", "dy"],
  A: ["rx", "ry", "rotation", "large-arc", "sweep", "x", "y"],
  a: ["rx", "ry", "rotation", "large-arc", "sweep", "dx", "dy"]
};
function parsePath(path) {
  const items = path.replace(/[\n\r]/g, "").replace(/-/g, " -").replace(/(\d*\.)(\d+)(?=\.)/g, "$1$2 ").trim().split(/\s*,|\s+/);
  const segments = [];
  let currentCommand = "";
  let currentElement = {};
  while (items.length > 0) {
    let it2 = items.shift();
    if (it2 in PATH_COMMANDS) {
      currentCommand = it2;
    } else {
      items.unshift(it2);
    }
    currentElement = { type: currentCommand };
    PATH_COMMANDS[currentCommand].forEach((prop) => {
      it2 = items.shift();
      currentElement[prop] = it2;
    });
    if (currentCommand === "M") {
      currentCommand = "L";
    } else if (currentCommand === "m") {
      currentCommand = "l";
    }
    const [type, ...values3] = Object.values(currentElement);
    segments.push([type, ...values3.map(Number)]);
  }
  return segments;
}
function pathToPoints(path) {
  const points = [];
  const segments = typeof path === "string" ? parsePath(path) : path;
  segments.forEach((seg) => {
    const command = seg[0];
    if (command === "Z") {
      points.push(points[0]);
      return;
    }
    if (command !== "A") {
      for (let i2 = 1; i2 < seg.length; i2 = i2 + 2) {
        points.push([seg[i2], seg[i2 + 1], 0]);
      }
    } else {
      const length = seg.length;
      points.push([seg[length - 2], seg[length - 1], 0]);
    }
  });
  return points;
}
var getClosedSpline = (points) => {
  if (points.length < 2)
    return [
      ["M", 0, 0],
      ["L", 0, 0]
    ];
  const first = points[0];
  const second = points[1];
  const last2 = points[points.length - 1];
  const lastSecond = points[points.length - 2];
  points.unshift(lastSecond, last2);
  points.push(first, second);
  const closedPath = [["M", last2[0], last2[1]]];
  for (let i2 = 1; i2 < points.length - 2; i2 += 1) {
    const [x0, y0] = points[i2 - 1];
    const [x1, y1] = points[i2];
    const [x22, y22] = points[i2 + 1];
    const [x32, y32] = i2 !== points.length - 2 ? points[i2 + 2] : [x22, y22];
    const cp1x = x1 + (x22 - x0) / 6;
    const cp1y = y1 + (y22 - y0) / 6;
    const cp2x = x22 - (x32 - x1) / 6;
    const cp2y = y22 - (y32 - y1) / 6;
    closedPath.push(["C", cp1x, cp1y, cp2x, cp2y, x22, y22]);
  }
  return closedPath;
};

// node_modules/@antv/g6/esm/utils/polygon.js
function getPolygonTextStyleByPlacement(bounds, placement, offsetX, offsetY, closeToContour, path, autoRotate) {
  const [x4, y4] = getXYByPlacement(bounds, placement);
  const style = {
    textAlign: placement === "left" ? "right" : placement === "right" ? "left" : "center",
    textBaseline: placement === "top" ? "bottom" : placement === "bottom" ? "top" : "middle",
    transform: [["translate", x4 + offsetX, y4 + offsetY]]
  };
  if (placement === "center" || !closeToContour)
    return style;
  const points = pathToPoints(path);
  if (!points || points.length <= 3)
    return style;
  const lines = points.map((point3, index) => {
    const p1 = point3;
    const p22 = points[(index + 1) % points.length];
    if (is_equal_default(p1, p22))
      return null;
    return [p1, p22];
  }).filter(Boolean);
  const line = findNearestLine([x4, y4], lines);
  const intersection = findNearestPointOnLine([x4, y4], line);
  if (intersection && line) {
    style.transform = [["translate", intersection[0] + offsetX, intersection[1] + offsetY]];
    if (autoRotate) {
      const angle2 = Math.atan((line[0][1] - line[1][1]) / (line[0][0] - line[1][0]));
      style.transform.push(["rotate", angle2 / Math.PI * 180]);
      style.textAlign = "center";
      if (placement === "right" || placement === "left") {
        if (angle2 > 0) {
          style.textBaseline = placement === "right" ? "bottom" : "top";
        } else {
          style.textBaseline = placement === "right" ? "top" : "bottom";
        }
      }
    }
  }
  return style;
}

// node_modules/@antv/g6/esm/elements/shapes/contour.js
var __rest5 = function(s2, e2) {
  var t3 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t3[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t3[p3[i2]] = s2[p3[i2]];
    }
  return t3;
};
var Contour = class _Contour extends BaseShape {
  constructor(options) {
    super(mergeOptions({ style: _Contour.defaultStyleProps }, options));
  }
  getLabelStyle(attributes) {
    if (!attributes.label || !attributes.d || attributes.d.length === 0)
      return false;
    const _a = subStyleProps(this.getGraphicStyle(attributes), "label"), { maxWidth, offsetX, offsetY, autoRotate, placement, closeToPath } = _a, labelStyle = __rest5(_a, ["maxWidth", "offsetX", "offsetY", "autoRotate", "placement", "closeToPath"]);
    const key = this.shapeMap.key;
    const keyBounds = key === null || key === void 0 ? void 0 : key.getRenderBounds();
    return Object.assign(getPolygonTextStyleByPlacement(keyBounds, placement, offsetX, offsetY, closeToPath, attributes.d, autoRotate), { wordWrapWidth: getWordWrapWidthByBox(keyBounds, maxWidth) }, labelStyle);
  }
  getKeyStyle(attributes) {
    return this.getGraphicStyle(attributes);
  }
  render(attributes, container) {
    this.upsert("key", Path, this.getKeyStyle(attributes), container);
    this.upsert("label", Label, this.getLabelStyle(attributes), container);
  }
};
Contour.defaultStyleProps = {
  label: true,
  labelPlacement: "bottom",
  labelCloseToPath: true,
  labelAutoRotate: true,
  labelOffsetX: 0,
  labelOffsetY: 0
};

// node_modules/@antv/g6/esm/utils/shape.js
function getDescendantShapes(shape) {
  const succeeds = [];
  const traverse = (shape2) => {
    if (shape2 === null || shape2 === void 0 ? void 0 : shape2.children.length) {
      shape2.children.forEach((child) => {
        succeeds.push(child);
        traverse(child);
      });
    }
  };
  traverse(shape);
  return succeeds;
}
function getAncestorShapes(shape) {
  const ancestors = [];
  let currentNode = shape.parentNode;
  while (currentNode) {
    ancestors.push(currentNode);
    currentNode = currentNode.parentNode;
  }
  return ancestors;
}

// node_modules/@antv/g6/esm/elements/shapes/image.js
var Image3 = class extends Image2 {
  constructor(options) {
    super(options);
    this.onMounted = () => {
      this.handleRadius();
    };
    this.onAttrModified = () => {
      this.handleRadius();
    };
    current = this;
    this.isMutationObserved = true;
    this.addEventListener(ElementEvent.MOUNTED, this.onMounted);
    this.addEventListener(ElementEvent.ATTR_MODIFIED, this.onAttrModified);
  }
  handleRadius() {
    const { radius, clipPath, width: width2 = 0, height = 0 } = this.attributes;
    if (radius && width2 && height) {
      const [x4, y4] = this.getBounds().min;
      const clipPathStyle = { x: x4, y: y4, radius, width: width2, height };
      if (clipPath) {
        Object.assign(this.parsedStyle.clipPath.style, clipPathStyle);
      } else {
        const rect2 = new Rect({ style: clipPathStyle });
        this.style.clipPath = rect2;
      }
    } else {
      if (clipPath)
        this.style.clipPath = null;
    }
  }
};
var ImagesWeakMap = /* @__PURE__ */ new WeakMap();
var current = null;
var connectImage = (target) => {
  if (current && getAncestorShapes(current).includes(target)) {
    const images = ImagesWeakMap.get(target);
    if (images) {
      if (!images.includes(current))
        images.push(current);
    } else
      ImagesWeakMap.set(target, [current]);
  }
};
var dispatchPositionChange = (target) => {
  const image = ImagesWeakMap.get(target);
  if (image) {
    image.forEach((i2) => i2.handleRadius());
  }
};

// node_modules/@antv/g6/esm/elements/shapes/icon.js
var Icon = class extends BaseShape {
  constructor(options) {
    super(options);
  }
  isImage() {
    const { src } = this.attributes;
    return !!src;
  }
  getIconStyle(attributes = this.attributes) {
    const { width: width2 = 0, height = 0 } = attributes;
    const style = this.getGraphicStyle(attributes);
    if (this.isImage()) {
      return Object.assign({ x: -width2 / 2, y: -height / 2 }, style);
    }
    return Object.assign({ textBaseline: "middle", textAlign: "center" }, style);
  }
  render(attributes = this.attributes, container = this) {
    this.upsert("icon", this.isImage() ? Image3 : Text, this.getIconStyle(attributes), container);
  }
};

// node_modules/@antv/g6/esm/elements/base-element.js
var BaseElement = class extends BaseShape {
  get context() {
    return this.config.context;
  }
  get parsedAttributes() {
    return this.attributes;
  }
  /**
   * <zh/> 
   *
   * <en/> Animation frame execution function
   */
  onframe() {
  }
  animate(keyframes, options) {
    const animation = super.animate(keyframes, options);
    if (animation) {
      animation.onframe = () => this.onframe();
      animation.finished.then(() => this.onframe());
    }
    return animation;
  }
};

// node_modules/@antv/g6/esm/elements/nodes/base-node.js
var __rest6 = function(s2, e2) {
  var t3 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t3[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t3[p3[i2]] = s2[p3[i2]];
    }
  return t3;
};
var BaseNode = class _BaseNode extends BaseElement {
  constructor(options) {
    super(mergeOptions({ style: _BaseNode.defaultStyleProps }, options));
    this.type = "node";
  }
  getSize(attributes = this.attributes) {
    const { size: size2 } = attributes;
    return parseSize(size2);
  }
  getKeyStyle(attributes) {
    const style = this.getGraphicStyle(attributes);
    return Object.assign(omitStyleProps(style, ["label", "halo", "icon", "badge", "port"]));
  }
  getLabelStyle(attributes) {
    if (attributes.label === false || !attributes.labelText)
      return false;
    const _a = subStyleProps(this.getGraphicStyle(attributes), "label"), { placement, maxWidth, offsetX, offsetY } = _a, labelStyle = __rest6(_a, ["placement", "maxWidth", "offsetX", "offsetY"]);
    const keyBounds = this.getShape("key").getLocalBounds();
    return Object.assign(getTextStyleByPlacement(keyBounds, placement, offsetX, offsetY), { wordWrapWidth: getWordWrapWidthByBox(keyBounds, maxWidth) }, labelStyle);
  }
  getHaloStyle(attributes) {
    if (attributes.halo === false)
      return false;
    const _a = this.getKeyStyle(attributes), { fill } = _a, keyStyle = __rest6(_a, ["fill"]);
    const haloStyle = subStyleProps(this.getGraphicStyle(attributes), "halo");
    return Object.assign(Object.assign(Object.assign({}, keyStyle), { stroke: fill }), haloStyle);
  }
  getIconStyle(attributes) {
    if (attributes.icon === false || !attributes.iconText && !attributes.iconSrc)
      return false;
    const iconStyle = subStyleProps(this.getGraphicStyle(attributes), "icon");
    return Object.assign(inferIconStyle(attributes.size, iconStyle), iconStyle);
  }
  getBadgesStyle(attributes) {
    var _a;
    const badges = subObject(this.shapeMap, "badge-");
    const badgesShapeStyle = {};
    Object.keys(badges).forEach((key) => {
      badgesShapeStyle[key] = false;
    });
    if (attributes.badge === false || !((_a = attributes.badges) === null || _a === void 0 ? void 0 : _a.length))
      return badgesShapeStyle;
    const { badges: badgeOptions = [], badgePalette, opacity = 1 } = attributes, restAttributes = __rest6(attributes, ["badges", "badgePalette", "opacity"]);
    const colors = getPaletteColors(badgePalette);
    const badgeStyle = subStyleProps(this.getGraphicStyle(restAttributes), "badge");
    badgeOptions.forEach((option, i2) => {
      badgesShapeStyle[i2] = Object.assign(Object.assign({ backgroundFill: colors ? colors[i2 % (colors === null || colors === void 0 ? void 0 : colors.length)] : void 0, opacity }, badgeStyle), this.getBadgeStyle(option));
    });
    return badgesShapeStyle;
  }
  getBadgeStyle(style) {
    const keyShape = this.getShape("key");
    const { placement = "top", offsetX, offsetY } = style, restStyle = __rest6(style, ["placement", "offsetX", "offsetY"]);
    const textStyle = getTextStyleByPlacement(keyShape.getLocalBounds(), placement, offsetX, offsetY, true);
    return Object.assign(Object.assign({}, textStyle), restStyle);
  }
  getPortsStyle(attributes) {
    var _a;
    const ports = this.getPorts();
    const portsShapeStyle = {};
    Object.keys(ports).forEach((key) => {
      portsShapeStyle[key] = false;
    });
    if (attributes.port === false || !((_a = attributes.ports) === null || _a === void 0 ? void 0 : _a.length))
      return portsShapeStyle;
    const portStyle = subStyleProps(this.getGraphicStyle(attributes), "port");
    const { ports: portOptions = [] } = attributes;
    portOptions.forEach((option, index) => {
      const key = option.key || index;
      const mergedStyle = Object.assign(Object.assign({}, portStyle), option);
      if (isSimplePort(mergedStyle)) {
        portsShapeStyle[key] = false;
      } else {
        const [x4, y4] = this.getPortXY(attributes, option);
        portsShapeStyle[key] = Object.assign({ transform: [["translate", x4, y4]] }, mergedStyle);
      }
    });
    return portsShapeStyle;
  }
  getPortXY(attributes, style) {
    const { placement = "left" } = style;
    const keyShape = this.getShape("key");
    return getPortXYByPlacement(getBoundsInOffscreen(this.context, keyShape), placement);
  }
  /**
   * Get the ports for the node.
   * @returns Ports shape map.
   */
  getPorts() {
    return subObject(this.shapeMap, "port-");
  }
  /**
   * Get the center point of the node.
   * @returns The center point of the node.
   */
  getCenter() {
    return this.getShape("key").getBounds().center;
  }
  /**
   * Get the point on the outer contour of the node that is the intersection with a line starting in the center the ending in the point `p`.
   * @param point - The point to intersect with the node.
   * @param useExtendedLine - Whether to use the extended line.
   * @returns The intersection point.
   */
  getIntersectPoint(point3, useExtendedLine = false) {
    const keyShapeBounds = this.getShape("key").getBounds();
    return getRectIntersectPoint(point3, keyShapeBounds, useExtendedLine);
  }
  drawHaloShape(attributes, container) {
    const style = this.getHaloStyle(attributes);
    const keyShape = this.getShape("key");
    this.upsert("halo", keyShape.constructor, style, container);
  }
  drawIconShape(attributes, container) {
    const style = this.getIconStyle(attributes);
    this.upsert("icon", Icon, style, container);
    connectImage(this);
  }
  drawBadgeShapes(attributes, container) {
    const badgesStyle = this.getBadgesStyle(attributes);
    Object.keys(badgesStyle).forEach((key) => {
      const style = badgesStyle[key];
      this.upsert(`badge-${key}`, Badge, style, container);
    });
  }
  drawPortShapes(attributes, container) {
    const portsStyle = this.getPortsStyle(attributes);
    Object.keys(portsStyle).forEach((key) => {
      const style = portsStyle[key];
      const shapeKey = `port-${key}`;
      this.upsert(shapeKey, Circle, style, container);
    });
  }
  drawLabelShape(attributes, container) {
    const style = this.getLabelStyle(attributes);
    this.upsert("label", Label, style, container);
  }
  //  / Used to decorate abstract methods
  _drawKeyShape(attributes, container) {
    return this.drawKeyShape(attributes, container);
  }
  render(attributes = this.parsedAttributes, container = this) {
    this._drawKeyShape(attributes, container);
    if (!this.getShape("key"))
      return;
    this.drawHaloShape(attributes, container);
    this.drawIconShape(attributes, container);
    this.drawBadgeShapes(attributes, container);
    this.drawLabelShape(attributes, container);
    this.drawPortShapes(attributes, container);
  }
  update(attr) {
    super.update(attr);
    if (attr && ("x" in attr || "y" in attr || "z" in attr)) {
      dispatchPositionChange(this);
    }
  }
  onframe() {
    this.drawBadgeShapes(this.parsedAttributes, this);
    this.drawLabelShape(this.parsedAttributes, this);
  }
};
BaseNode.defaultStyleProps = {
  x: 0,
  y: 0,
  size: 32,
  droppable: true,
  draggable: true,
  port: true,
  ports: [],
  portZIndex: 2,
  portLinkToCenter: false,
  badge: true,
  badges: [],
  badgeZIndex: 3,
  halo: false,
  haloDroppable: false,
  haloLineDash: 0,
  haloLineWidth: 12,
  haloStrokeOpacity: 0.25,
  haloPointerEvents: "none",
  haloZIndex: -1,
  icon: true,
  iconZIndex: 1,
  label: true,
  labelIsBillboard: true,
  labelMaxWidth: "200%",
  labelPlacement: "bottom",
  labelWordWrap: false,
  labelZIndex: 0
};
function getBoundsInOffscreen(context, shape) {
  if (!context)
    return shape.getLocalBounds();
  const canvas2 = context.canvas.getLayer();
  const substitute = shape.cloneNode();
  setVisibility(substitute, "hidden");
  canvas2.appendChild(substitute);
  const bounds = substitute.getLocalBounds();
  substitute.destroy();
  return bounds;
}

// node_modules/@antv/g6/esm/elements/nodes/circle.js
var Circle2 = class _Circle extends BaseNode {
  constructor(options) {
    super(mergeOptions({ style: _Circle.defaultStyleProps }, options));
  }
  drawKeyShape(attributes, container) {
    return this.upsert("key", Circle, this.getKeyStyle(attributes), container);
  }
  getKeyStyle(attributes) {
    const keyStyle = super.getKeyStyle(attributes);
    return Object.assign(Object.assign({}, keyStyle), { r: Math.min(...this.getSize(attributes)) / 2 });
  }
  getIconStyle(attributes) {
    const style = super.getIconStyle(attributes);
    const { r: r3 } = this.getShape("key").attributes;
    const size2 = r3 * 2 * ICON_SIZE_RATIO;
    return style ? Object.assign({ width: size2, height: size2 }, style) : false;
  }
  getIntersectPoint(point3, useExtendedLine = false) {
    const keyShapeBounds = this.getShape("key").getBounds();
    return getEllipseIntersectPoint(point3, keyShapeBounds, useExtendedLine);
  }
};
Circle2.defaultStyleProps = {
  size: 32
};

// node_modules/@antv/g6/esm/elements/shapes/polygon.js
var Polygon2 = class extends BaseNode {
  constructor(options) {
    super(options);
  }
  get parsedAttributes() {
    return this.attributes;
  }
  drawKeyShape(attributes, container) {
    return this.upsert("key", Polygon, this.getKeyStyle(attributes), container);
  }
  getKeyStyle(attributes) {
    const keyStyle = super.getKeyStyle(attributes);
    return Object.assign(Object.assign({}, keyStyle), { points: this.getPoints(attributes) });
  }
  getIntersectPoint(point3, useExtendedLine = false) {
    var _a, _b;
    const { points } = this.getShape("key").attributes;
    const center = [+(((_a = this.attributes) === null || _a === void 0 ? void 0 : _a.x) || 0), +(((_b = this.attributes) === null || _b === void 0 ? void 0 : _b.y) || 0)];
    return getPolygonIntersectPoint(point3, center, points, true, useExtendedLine).point;
  }
};

// node_modules/@antv/g6/esm/elements/nodes/diamond.js
var Diamond = class extends Polygon2 {
  constructor(options) {
    super(options);
  }
  getPoints(attributes) {
    const [width2, height] = this.getSize(attributes);
    return getDiamondPoints(width2, height);
  }
};

// node_modules/@antv/g6/esm/elements/nodes/donut.js
var __rest7 = function(s2, e2) {
  var t3 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t3[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t3[p3[i2]] = s2[p3[i2]];
    }
  return t3;
};
var Donut = class _Donut extends Circle2 {
  constructor(options) {
    super(mergeOptions({ style: _Donut.defaultStyleProps }, options));
  }
  parseOuterR() {
    const { size: size2 } = this.parsedAttributes;
    return Math.min(...parseSize(size2)) / 2;
  }
  parseInnerR() {
    const { innerR } = this.parsedAttributes;
    return isString(innerR) ? parseInt(innerR) / 100 * this.parseOuterR() : innerR;
  }
  drawDonutShape(attributes, container) {
    const { donuts } = attributes;
    if (!(donuts === null || donuts === void 0 ? void 0 : donuts.length))
      return;
    const parsedDonuts = donuts.map((round3) => isNumber(round3) ? { value: round3 } : round3);
    const style = subStyleProps(this.getGraphicStyle(attributes), "donut");
    const colors = getPaletteColors(attributes.donutPalette);
    if (!colors)
      return;
    const sum = parsedDonuts.reduce((acc, cur) => {
      var _a;
      return acc + ((_a = cur.value) !== null && _a !== void 0 ? _a : 0);
    }, 0);
    const outerR = this.parseOuterR();
    const innerR = this.parseInnerR();
    let start = 0;
    parsedDonuts.forEach((round3, index) => {
      const { value = 0, color = colors[index % colors.length] } = round3, roundStyle = __rest7(round3, ["value", "color"]);
      const angle2 = (sum === 0 ? 1 / parsedDonuts.length : value / sum) * 360;
      this.upsert(`round${index}`, Path, Object.assign(Object.assign(Object.assign({}, style), { d: arc(outerR, innerR, start, start + angle2), fill: color }), roundStyle), container);
      start += angle2;
    });
  }
  render(attributes, container = this) {
    super.render(attributes, container);
    this.drawDonutShape(attributes, container);
  }
};
Donut.defaultStyleProps = {
  innerR: "50%",
  donuts: [],
  donutPalette: "tableau"
};
var point = (x4, y4, r3, angel) => [x4 + Math.sin(angel) * r3, y4 - Math.cos(angel) * r3];
var full = (x4, y4, R3, r3) => {
  if (r3 <= 0 || R3 <= r3) {
    return [["M", x4 - R3, y4], ["A", R3, R3, 0, 1, 1, x4 + R3, y4], ["A", R3, R3, 0, 1, 1, x4 - R3, y4], ["Z"]];
  }
  return [
    ["M", x4 - R3, y4],
    ["A", R3, R3, 0, 1, 1, x4 + R3, y4],
    ["A", R3, R3, 0, 1, 1, x4 - R3, y4],
    ["Z"],
    ["M", x4 + r3, y4],
    ["A", r3, r3, 0, 1, 0, x4 - r3, y4],
    ["A", r3, r3, 0, 1, 0, x4 + r3, y4],
    ["Z"]
  ];
};
var part = (x4, y4, R3, r3, start, end) => {
  const [s2, e2] = [start / 360 * 2 * Math.PI, end / 360 * 2 * Math.PI];
  const P3 = [point(x4, y4, r3, s2), point(x4, y4, R3, s2), point(x4, y4, R3, e2), point(x4, y4, r3, e2)];
  const flag = e2 - s2 > Math.PI ? 1 : 0;
  return [
    ["M", P3[0][0], P3[0][1]],
    ["L", P3[1][0], P3[1][1]],
    ["A", R3, R3, 0, flag, 1, P3[2][0], P3[2][1]],
    ["L", P3[3][0], P3[3][1]],
    ["A", r3, r3, 0, flag, 0, P3[0][0], P3[0][1]],
    ["Z"]
  ];
};
var arc = (R3 = 0, r3 = 0, start, end) => {
  const [x4, y4] = [0, 0];
  if (Math.abs(start - end) % 360 < 1e-6)
    return full(x4, y4, R3, r3);
  return part(x4, y4, R3, r3, start, end);
};

// node_modules/@antv/g6/esm/elements/nodes/ellipse.js
var Ellipse2 = class _Ellipse extends BaseNode {
  constructor(options) {
    super(mergeOptions({ style: _Ellipse.defaultStyleProps }, options));
  }
  drawKeyShape(attributes, container) {
    return this.upsert("key", Ellipse, this.getKeyStyle(attributes), container);
  }
  getKeyStyle(attributes) {
    const keyStyle = super.getKeyStyle(attributes);
    const [majorAxis, minorAxis] = this.getSize(attributes);
    return Object.assign(Object.assign({}, keyStyle), { rx: majorAxis / 2, ry: minorAxis / 2 });
  }
  getIconStyle(attributes) {
    const style = super.getIconStyle(attributes);
    const { rx, ry } = this.getShape("key").attributes;
    const size2 = Math.min(+rx, +ry) * 2 * ICON_SIZE_RATIO;
    return style ? Object.assign({ width: size2, height: size2 }, style) : false;
  }
  getIntersectPoint(point3, useExtendedLine = false) {
    const keyShapeBounds = this.getShape("key").getBounds();
    return getEllipseIntersectPoint(point3, keyShapeBounds, useExtendedLine);
  }
};
Ellipse2.defaultStyleProps = {
  size: [45, 35]
};

// node_modules/@antv/g6/esm/elements/nodes/hexagon.js
var Hexagon = class extends Polygon2 {
  constructor(options) {
    super(options);
  }
  getOuterR(attributes) {
    return attributes.outerR || Math.min(...this.getSize(attributes)) / 2;
  }
  getPoints(attributes) {
    return getHexagonPoints(this.getOuterR(attributes));
  }
  getIconStyle(attributes) {
    const style = super.getIconStyle(attributes);
    const size2 = this.getOuterR(attributes) * ICON_SIZE_RATIO;
    return style ? Object.assign({ width: size2, height: size2 }, style) : false;
  }
};

// node_modules/@antv/g6/esm/elements/nodes/html.js
var __rest8 = function(s2, e2) {
  var t3 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t3[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t3[p3[i2]] = s2[p3[i2]];
    }
  return t3;
};
var HTML2 = class _HTML extends BaseNode {
  constructor(options) {
    super(Object.assign(Object.assign({}, options), { style: Object.assign({}, _HTML.defaultStyleProps, options.style) }));
    this.rootPointerEvent = new FederatedPointerEvent(null);
    this.forwardEvents = (nativeEvent) => {
      const canvas2 = this.context.canvas;
      const iCanvas = canvas2.context.renderingContext.root.ownerDocument.defaultView;
      const normalizedEvents = this.normalizeToPointerEvent(nativeEvent, iCanvas);
      normalizedEvents.forEach((normalizedEvent) => {
        const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvent, iCanvas, nativeEvent);
        set_default(canvas2.context.eventService, "mappingTable.pointerupoutside", []);
        canvas2.context.eventService.mapEvent(event);
      });
    };
  }
  get eventService() {
    return this.context.canvas.context.eventService;
  }
  get events() {
    return [
      CommonEvent.CLICK,
      CommonEvent.POINTER_DOWN,
      CommonEvent.POINTER_MOVE,
      CommonEvent.POINTER_UP,
      CommonEvent.POINTER_OVER,
      CommonEvent.POINTER_LEAVE
    ];
  }
  getDomElement() {
    return this.getShape("key").getDomElement();
  }
  /**
   * @override
   */
  render(attributes = this.parsedAttributes, container = this) {
    this.drawKeyShape(attributes, container);
    this.drawPortShapes(attributes, container);
  }
  getKeyStyle(attributes) {
    const _a = pick_default(attributes, ["dx", "dy", "innerHTML", "pointerEvents", "cursor"]), { dx = 0, dy = 0 } = _a, style = __rest8(_a, ["dx", "dy"]);
    const [width2, height] = this.getSize(attributes);
    return Object.assign(Object.assign({ x: dx, y: dy }, style), { width: width2, height });
  }
  drawKeyShape(attributes, container) {
    const style = this.getKeyStyle(attributes);
    const { x: x4, y: y4, width: width2 = 0, height = 0 } = style;
    const bounds = this.upsert("key-container", Rect, { x: x4, y: y4, width: width2, height, opacity: 0 }, container);
    return this.upsert("key", HTML, style, bounds);
  }
  connectedCallback() {
    const renderer = this.context.canvas.getRenderer("main");
    const isCanvasRenderer = renderer instanceof Renderer;
    if (!isCanvasRenderer)
      return;
    const element = this.getDomElement();
    this.events.forEach((eventName) => {
      element.addEventListener(eventName, this.forwardEvents);
    });
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === "zIndex" && oldValue !== newValue) {
      this.getDomElement().style.zIndex = newValue;
    }
  }
  destroy() {
    const element = this.getDomElement();
    this.events.forEach((eventName) => {
      element.removeEventListener(eventName, this.forwardEvents);
    });
    super.destroy();
  }
  normalizeToPointerEvent(event, canvas2) {
    const normalizedEvents = [];
    if (canvas2.isTouchEvent(event)) {
      for (let i2 = 0; i2 < event.changedTouches.length; i2++) {
        const touch = event.changedTouches[i2];
        if (is_undefined_default(touch.button))
          touch.button = 0;
        if (is_undefined_default(touch.buttons))
          touch.buttons = 1;
        if (is_undefined_default(touch.isPrimary)) {
          touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
        }
        if (is_undefined_default(touch.width))
          touch.width = touch.radiusX || 1;
        if (is_undefined_default(touch.height))
          touch.height = touch.radiusY || 1;
        if (is_undefined_default(touch.tiltX))
          touch.tiltX = 0;
        if (is_undefined_default(touch.tiltY))
          touch.tiltY = 0;
        if (is_undefined_default(touch.pointerType))
          touch.pointerType = "touch";
        if (is_undefined_default(touch.pointerId))
          touch.pointerId = touch.identifier || 0;
        if (is_undefined_default(touch.pressure))
          touch.pressure = touch.force || 0.5;
        if (is_undefined_default(touch.twist))
          touch.twist = 0;
        if (is_undefined_default(touch.tangentialPressure))
          touch.tangentialPressure = 0;
        touch.isNormalized = true;
        touch.type = event.type;
        normalizedEvents.push(touch);
      }
    } else if (canvas2.isMouseEvent(event)) {
      const tempEvent = event;
      if (is_undefined_default(tempEvent.isPrimary))
        tempEvent.isPrimary = true;
      if (is_undefined_default(tempEvent.width))
        tempEvent.width = 1;
      if (is_undefined_default(tempEvent.height))
        tempEvent.height = 1;
      if (is_undefined_default(tempEvent.tiltX))
        tempEvent.tiltX = 0;
      if (is_undefined_default(tempEvent.tiltY))
        tempEvent.tiltY = 0;
      if (is_undefined_default(tempEvent.pointerType))
        tempEvent.pointerType = "mouse";
      if (is_undefined_default(tempEvent.pointerId))
        tempEvent.pointerId = 1;
      if (is_undefined_default(tempEvent.pressure))
        tempEvent.pressure = 0.5;
      if (is_undefined_default(tempEvent.twist))
        tempEvent.twist = 0;
      if (is_undefined_default(tempEvent.tangentialPressure))
        tempEvent.tangentialPressure = 0;
      tempEvent.isNormalized = true;
      normalizedEvents.push(tempEvent);
    } else {
      normalizedEvents.push(event);
    }
    return normalizedEvents;
  }
  transferMouseData(event, nativeEvent) {
    event.isTrusted = nativeEvent.isTrusted;
    event.srcElement = nativeEvent.srcElement;
    event.timeStamp = performance.now();
    event.type = nativeEvent.type;
    event.altKey = nativeEvent.altKey;
    event.metaKey = nativeEvent.metaKey;
    event.shiftKey = nativeEvent.shiftKey;
    event.ctrlKey = nativeEvent.ctrlKey;
    event.button = nativeEvent.button;
    event.buttons = nativeEvent.buttons;
    event.client.x = nativeEvent.clientX;
    event.client.y = nativeEvent.clientY;
    event.movement.x = nativeEvent.movementX;
    event.movement.y = nativeEvent.movementY;
    event.page.x = nativeEvent.pageX;
    event.page.y = nativeEvent.pageY;
    event.screen.x = nativeEvent.screenX;
    event.screen.y = nativeEvent.screenY;
    event.relatedTarget = null;
  }
  bootstrapEvent(event, normalizedEvent, view, nativeEvent) {
    event.view = view;
    event.originalEvent = null;
    event.nativeEvent = nativeEvent;
    event.pointerId = normalizedEvent.pointerId;
    event.width = normalizedEvent.width;
    event.height = normalizedEvent.height;
    event.isPrimary = normalizedEvent.isPrimary;
    event.pointerType = normalizedEvent.pointerType;
    event.pressure = normalizedEvent.pressure;
    event.tangentialPressure = normalizedEvent.tangentialPressure;
    event.tiltX = normalizedEvent.tiltX;
    event.tiltY = normalizedEvent.tiltY;
    event.twist = normalizedEvent.twist;
    this.transferMouseData(event, normalizedEvent);
    const { x: x4, y: y4 } = this.getViewportXY(normalizedEvent);
    event.viewport.x = x4;
    event.viewport.y = y4;
    const [canvasX, canvasY] = this.context.canvas.getCanvasByViewport([x4, y4]);
    event.canvas.x = canvasX;
    event.canvas.y = canvasY;
    event.global.copyFrom(event.canvas);
    event.offset.copyFrom(event.canvas);
    event.isTrusted = nativeEvent.isTrusted;
    if (event.type === "pointerleave") {
      event.type = "pointerout";
    }
    return event;
  }
  getViewportXY(nativeEvent) {
    let x4;
    let y4;
    const { offsetX, offsetY, clientX, clientY } = nativeEvent;
    if (!isNil(offsetX) && !isNil(offsetY)) {
      x4 = offsetX;
      y4 = offsetY;
    } else {
      const point3 = this.eventService.client2Viewport({ x: clientX, y: clientY });
      x4 = point3.x;
      y4 = point3.y;
    }
    return { x: x4, y: y4 };
  }
  onframe() {
    super.onframe();
    const { opacity } = this.attributes;
    this.getDomElement().style.opacity = `${opacity}`;
  }
};
HTML2.defaultStyleProps = {
  size: [160, 80],
  halo: false,
  icon: false,
  label: false,
  pointerEvents: "auto"
};

// node_modules/@antv/g6/esm/elements/nodes/image.js
var __rest9 = function(s2, e2) {
  var t3 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t3[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t3[p3[i2]] = s2[p3[i2]];
    }
  return t3;
};
var Image4 = class _Image extends BaseNode {
  constructor(options) {
    super(mergeOptions({ style: _Image.defaultStyleProps }, options));
  }
  getKeyStyle(attributes) {
    const [width2, height] = this.getSize(attributes);
    const _a = super.getKeyStyle(attributes), { fillOpacity, opacity = fillOpacity } = _a, keyStyle = __rest9(_a, ["fillOpacity", "opacity"]);
    return Object.assign(Object.assign({ opacity }, keyStyle), {
      width: width2,
      height,
      x: -width2 / 2,
      y: -height / 2
    });
  }
  getBounds() {
    return this.getShape("key").getBounds();
  }
  getHaloStyle(attributes) {
    if (attributes.halo === false)
      return false;
    const _a = this.getShape("key").attributes, { fill: keyStyleFill, stroke: keyStyleStroke } = _a, keyStyle = __rest9(_a, ["fill", "stroke"]);
    const haloStyle = subStyleProps(this.getGraphicStyle(attributes), "halo");
    const haloLineWidth = Number(haloStyle.lineWidth);
    const [width2, height] = add(this.getSize(attributes), [haloLineWidth, haloLineWidth]);
    const { lineWidth } = haloStyle;
    const recalculate = {
      fill: "transparent",
      lineWidth: lineWidth / 2,
      width: width2 - lineWidth / 2,
      height: height - lineWidth / 2,
      x: -(width2 - lineWidth / 2) / 2,
      y: -(height - lineWidth / 2) / 2
    };
    return Object.assign(Object.assign({}, haloStyle), recalculate);
  }
  getIconStyle(attributes) {
    const style = super.getIconStyle(attributes);
    const [width2, height] = this.getSize(attributes);
    return style ? Object.assign({ width: width2 * ICON_SIZE_RATIO, height: height * ICON_SIZE_RATIO }, style) : false;
  }
  drawKeyShape(attributes, container) {
    const image = this.upsert("key", Image3, this.getKeyStyle(attributes), container);
    connectImage(this);
    return image;
  }
  drawHaloShape(attributes, container) {
    this.upsert("halo", Rect, this.getHaloStyle(attributes), container);
  }
  update(attr) {
    super.update(attr);
    if (attr && ("x" in attr || "y" in attr || "z" in attr)) {
      dispatchPositionChange(this);
    }
  }
};
Image4.defaultStyleProps = {
  size: 32
};

// node_modules/@antv/g6/esm/elements/nodes/rect.js
var Rect2 = class extends BaseNode {
  constructor(options) {
    super(options);
  }
  getKeyStyle(attributes) {
    const [width2, height] = this.getSize(attributes);
    return Object.assign(Object.assign({}, super.getKeyStyle(attributes)), {
      width: width2,
      height,
      x: -width2 / 2,
      y: -height / 2
    });
  }
  getIconStyle(attributes) {
    const style = super.getIconStyle(attributes);
    const { width: width2, height } = this.getShape("key").attributes;
    return style ? Object.assign({ width: width2 * ICON_SIZE_RATIO, height: height * ICON_SIZE_RATIO }, style) : false;
  }
  drawKeyShape(attributes, container) {
    return this.upsert("key", Rect, this.getKeyStyle(attributes), container);
  }
};

// node_modules/@antv/g6/esm/elements/nodes/star.js
var Star = class extends Polygon2 {
  constructor(options) {
    super(options);
  }
  getInnerR(attributes) {
    return attributes.innerR || this.getOuterR(attributes) * 3 / 8;
  }
  getOuterR(attributes) {
    return Math.min(...this.getSize(attributes)) / 2;
  }
  getPoints(attributes) {
    return getStarPoints(this.getOuterR(attributes), this.getInnerR(attributes));
  }
  getIconStyle(attributes) {
    const style = super.getIconStyle(attributes);
    const size2 = this.getInnerR(attributes) * 2 * ICON_SIZE_RATIO;
    return style ? Object.assign({ width: size2, height: size2 }, style) : false;
  }
  getPortXY(attributes, style) {
    const { placement = "top" } = style;
    const bbox = this.getShape("key").getLocalBounds();
    const ports = getStarPorts(this.getOuterR(attributes), this.getInnerR(attributes));
    return getPortXYByPlacement(bbox, placement, ports, false);
  }
};

// node_modules/@antv/g6/esm/elements/nodes/triangle.js
var Triangle = class _Triangle extends Polygon2 {
  constructor(options) {
    super(mergeOptions({ style: _Triangle.defaultStyleProps }, options));
  }
  getPoints(attributes) {
    const { direction } = attributes;
    const [width2, height] = this.getSize(attributes);
    return getTrianglePoints(width2, height, direction);
  }
  getPortXY(attributes, style) {
    const { direction } = attributes;
    const { placement = "top" } = style;
    const bbox = this.getShape("key").getLocalBounds();
    const [width2, height] = this.getSize(attributes);
    const ports = getTrianglePorts(width2, height, direction);
    return getPortXYByPlacement(bbox, placement, ports, false);
  }
  // icon 
  // icon is at the centroid of the triangle
  getIconStyle(attributes) {
    const { icon, iconText, iconSrc, direction } = attributes;
    if (icon === false || is_empty_default(iconText || iconSrc))
      return false;
    const iconStyle = subStyleProps(this.getGraphicStyle(attributes), "icon");
    const bbox = this.getShape("key").getLocalBounds();
    const [x4, y4] = getTriangleCenter(bbox, direction);
    const size2 = getIncircleRadius(bbox, direction) * 2 * ICON_SIZE_RATIO;
    return Object.assign({
      x: x4,
      y: y4,
      width: size2,
      height: size2
    }, iconStyle);
  }
};
Triangle.defaultStyleProps = {
  size: 40,
  direction: "up"
};

// node_modules/@antv/g6/esm/elements/combos/base-combo.js
var __rest10 = function(s2, e2) {
  var t3 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t3[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t3[p3[i2]] = s2[p3[i2]];
    }
  return t3;
};
var BaseCombo = class _BaseCombo extends BaseNode {
  constructor(options) {
    super(mergeOptions({ style: _BaseCombo.defaultStyleProps }, options));
    this.type = "combo";
    this.updateComboPosition(this.parsedAttributes);
  }
  getKeySize(attributes) {
    const { collapsed, childrenNode = [] } = attributes;
    if (childrenNode.length === 0)
      return this.getEmptyKeySize(attributes);
    return collapsed ? this.getCollapsedKeySize(attributes) : this.getExpandedKeySize(attributes);
  }
  getEmptyKeySize(attributes) {
    const { padding, collapsedSize } = attributes;
    const [top, right, bottom, left] = parsePadding(padding);
    return add(parseSize(collapsedSize), [left + right, top + bottom, 0]);
  }
  getCollapsedKeySize(attributes) {
    return parseSize(attributes.collapsedSize);
  }
  getExpandedKeySize(attributes) {
    const contentBBox = this.getContentBBox(attributes);
    return [getBBoxWidth(contentBBox), getBBoxHeight(contentBBox), 0];
  }
  getContentBBox(attributes) {
    const { childrenNode = [], padding } = attributes;
    const children = childrenNode.map((id) => this.context.element.getElement(id)).filter(Boolean);
    if (children.length === 0) {
      const bbox = new AABB();
      const { x: x4 = 0, y: y4 = 0, size: size2 } = attributes;
      const [width2, height] = parseSize(size2);
      bbox.setMinMax([x4 - width2 / 2, y4 - height / 2, 0], [x4 + width2 / 2, y4 + height / 2, 0]);
      return bbox;
    }
    const childrenBBox = getCombinedBBox(children.map((child) => child.getBounds()));
    if (!padding)
      return childrenBBox;
    return getExpandedBBox(childrenBBox, padding);
  }
  drawCollapsedMarkerShape(attributes, container) {
    const style = this.getCollapsedMarkerStyle(attributes);
    this.upsert("collapsed-marker", Icon, style, container);
    connectImage(this);
  }
  getCollapsedMarkerStyle(attributes) {
    if (!attributes.collapsed || !attributes.collapsedMarker)
      return false;
    const _a = subStyleProps(this.getGraphicStyle(attributes), "collapsedMarker"), { type } = _a, collapsedMarkerStyle = __rest10(_a, ["type"]);
    const keyShape = this.getShape("key");
    const [x4, y4] = getXYByPlacement(keyShape.getLocalBounds(), "center");
    const style = Object.assign(Object.assign({}, collapsedMarkerStyle), { x: x4, y: y4 });
    if (type) {
      const text = this.getCollapsedMarkerText(type, attributes);
      Object.assign(style, { text });
    }
    return style;
  }
  getCollapsedMarkerText(type, attributes) {
    const { childrenData = [] } = attributes;
    const { model } = this.context;
    if (type === "descendant-count")
      return model.getDescendantsData(this.id).length.toString();
    if (type === "child-count")
      return childrenData.length.toString();
    if (type === "node-count")
      return model.getDescendantsData(this.id).filter((datum) => model.getElementType(idOf(datum)) === "node").length.toString();
    if (isFunction(type))
      return type(childrenData);
    return "";
  }
  getComboPosition(attributes) {
    const { x: x4 = 0, y: y4 = 0, collapsed, childrenData = [] } = attributes;
    if (childrenData.length === 0)
      return [+x4, +y4, 0];
    if (collapsed) {
      const { model } = this.context;
      const descendants = model.getDescendantsData(this.id).filter((datum) => !model.isCombo(idOf(datum)));
      if (descendants.length > 0 && descendants.some(hasPosition)) {
        const totalPosition = descendants.reduce((acc, datum) => add(acc, positionOf(datum)), [0, 0, 0]);
        return divide(totalPosition, descendants.length);
      }
      return [+x4, +y4, 0];
    }
    return this.getContentBBox(attributes).center;
  }
  getComboStyle(attributes) {
    const [x4, y4] = this.getComboPosition(attributes);
    return { x: x4, y: y4, transform: [["translate", x4, y4]] };
  }
  updateComboPosition(attributes) {
    const comboStyle = this.getComboStyle(attributes);
    Object.assign(this.style, comboStyle);
    const { x: x4, y: y4 } = comboStyle;
    this.context.model.syncNodeLikeDatum({ id: this.id, style: { x: x4, y: y4 } });
    dispatchPositionChange(this);
  }
  render(attributes, container = this) {
    super.render(attributes, container);
    this.drawCollapsedMarkerShape(attributes, container);
  }
  update(attr = {}) {
    super.update(attr);
    this.updateComboPosition(this.parsedAttributes);
  }
  onframe() {
    super.onframe();
    if (!this.attributes.collapsed)
      this.updateComboPosition(this.parsedAttributes);
    this.drawKeyShape(this.parsedAttributes, this);
  }
  animate(keyframes, options) {
    const animation = super.animate(this.attributes.collapsed ? keyframes : (
      //  combo  x, y, z, transform 
      // If the current combo is in the expanded state, the animation is not affected by x, y, z, transform, and the position is determined only by the child elements
      keyframes.map((_a) => {
        var { x: x4, y: y4, z: z4, transform } = _a, keyframe = __rest10(_a, ["x", "y", "z", "transform"]);
        return keyframe;
      })
    ), options);
    if (!animation)
      return animation;
    return new Proxy(animation, {
      set: (target, propKey, value) => {
        if (propKey === "currentTime")
          Promise.resolve().then(() => this.onframe());
        return Reflect.set(target, propKey, value);
      }
    });
  }
};
BaseCombo.defaultStyleProps = {
  childrenNode: [],
  droppable: true,
  draggable: true,
  collapsed: false,
  collapsedSize: 32,
  collapsedMarker: true,
  collapsedMarkerZIndex: 1,
  collapsedMarkerFontSize: 12,
  collapsedMarkerTextAlign: "center",
  collapsedMarkerTextBaseline: "middle",
  collapsedMarkerType: "child-count"
};

// node_modules/@antv/g6/esm/elements/combos/circle.js
var CircleCombo = class extends BaseCombo {
  constructor(options) {
    super(options);
  }
  drawKeyShape(attributes, container) {
    return this.upsert("key", Circle, this.getKeyStyle(attributes), container);
  }
  getKeyStyle(attributes) {
    const { collapsed } = attributes;
    const keyStyle = super.getKeyStyle(attributes);
    const [width2] = this.getKeySize(attributes);
    return Object.assign(Object.assign(Object.assign({}, keyStyle), collapsed && subStyleProps(keyStyle, "collapsed")), { r: width2 / 2 });
  }
  getCollapsedKeySize(attributes) {
    const [collapsedWidth, collapsedHeight] = parseSize(attributes.collapsedSize);
    const collapsedR = Math.max(collapsedWidth, collapsedHeight) / 2;
    return [collapsedR * 2, collapsedR * 2, 0];
  }
  getExpandedKeySize(attributes) {
    const contentBBox = this.getContentBBox(attributes);
    const [width2, height] = getBBoxSize(contentBBox);
    const expandedR = Math.sqrt(Math.pow(width2, 2) + Math.pow(height, 2)) / 2;
    return [expandedR * 2, expandedR * 2, 0];
  }
  getIntersectPoint(point3, useExtendedLine = false) {
    const keyShapeBounds = this.getShape("key").getBounds();
    return getEllipseIntersectPoint(point3, keyShapeBounds, useExtendedLine);
  }
};

// node_modules/@antv/g6/esm/elements/combos/rect.js
var RectCombo = class extends BaseCombo {
  constructor(options) {
    super(options);
  }
  drawKeyShape(attributes, container) {
    return this.upsert("key", Rect, this.getKeyStyle(attributes), container);
  }
  getKeyStyle(attributes) {
    const keyStyle = super.getKeyStyle(attributes);
    const [width2, height] = this.getKeySize(attributes);
    return Object.assign(Object.assign(Object.assign({}, keyStyle), attributes.collapsed && subStyleProps(keyStyle, "collapsed")), {
      width: width2,
      height,
      x: -width2 / 2,
      y: -height / 2
    });
  }
};

// node_modules/@antv/g6/esm/utils/router/orth.js
var defaultOptions = {
  padding: 10
};
function orth(sourcePoint, targetPoint, sourceNode, targetNode, controlPoints, options) {
  const { padding } = Object.assign(defaultOptions, options);
  const sourceBBox = getNodeBBox(sourceNode, padding);
  const targetBBox = getNodeBBox(targetNode, padding);
  const points = [sourcePoint, ...controlPoints, targetPoint];
  let direction = null;
  const result = [];
  for (let fromIdx = 0, len = points.length; fromIdx < len - 1; fromIdx++) {
    const toIdx = fromIdx + 1;
    const from = points[fromIdx];
    const to = points[toIdx];
    const isOrth = isOrthogonal(from, to);
    let route = null;
    if (fromIdx === 0) {
      if (toIdx === len - 1) {
        if (sourceBBox.intersects(targetBBox)) {
          route = insideNode(from, to, sourceBBox, targetBBox);
        } else if (!isPointBBoxCenter(from, sourceBBox) && !isPointBBoxCenter(to, targetBBox)) {
          const fromWithPadding = getNearestBoundaryPoint(from, sourceBBox);
          const toWithPadding = getNearestBoundaryPoint(to, targetBBox);
          route = pointToPoint(fromWithPadding, toWithPadding, getDirection(fromWithPadding, toWithPadding));
          route.points.unshift(fromWithPadding);
          route.points.push(toWithPadding);
        } else if (!isOrth) {
          route = nodeToNode(from, to, sourceBBox, targetBBox);
        }
      } else {
        if (isPointInBBox(to, sourceBBox)) {
          route = insideNode(from, to, sourceBBox, getNodeBBox(to, padding), direction);
        } else if (!isOrth) {
          route = nodeToPoint(from, to, sourceBBox);
        }
      }
    } else if (toIdx === len - 1) {
      if (isPointInBBox(from, targetBBox)) {
        route = insideNode(from, to, getNodeBBox(from, padding), targetBBox, direction);
      } else if (!isOrth) {
        route = pointToNode(from, to, targetBBox, direction);
      }
    } else if (!isOrth) {
      route = pointToPoint(from, to, direction);
    }
    if (route) {
      result.push(...route.points);
      direction = route.direction;
    } else {
      direction = getDirection(from, to);
    }
    if (toIdx < len - 1)
      result.push(to);
  }
  return result.map(toVector2);
}
var opposites = {
  N: "S",
  S: "N",
  W: "E",
  E: "W"
};
var radians = {
  N: -Math.PI / 2,
  S: Math.PI / 2,
  E: 0,
  W: Math.PI
};
function getDirection(from, to) {
  const [fx, fy] = from;
  const [tx, ty] = to;
  if (fx === tx) {
    return fy > ty ? "N" : "S";
  }
  if (fy === ty) {
    return fx > tx ? "W" : "E";
  }
  return null;
}
function getBBoxSize2(bbox, direction) {
  return direction === "N" || direction === "S" ? getBBoxHeight(bbox) : getBBoxWidth(bbox);
}
function pointToPoint(from, to, direction) {
  const p1 = [from[0], to[1]];
  const p22 = [to[0], from[1]];
  const d1 = getDirection(from, p1);
  const d22 = getDirection(from, p22);
  const opposite = direction ? opposites[direction] : null;
  const p3 = d1 === direction || d1 !== opposite && d22 !== direction ? p1 : p22;
  return { points: [p3], direction: getDirection(p3, to) };
}
function nodeToPoint(from, to, fromBBox) {
  if (isPointBBoxCenter(from, fromBBox)) {
    const p3 = freeJoin(from, to, fromBBox);
    return { points: [p3], direction: getDirection(p3, to) };
  } else {
    const fromWithPadding = getNearestBoundaryPoint(from, fromBBox);
    const isHorizontal2 = ["left", "right"].includes(getNearestBoundarySide(from, fromBBox));
    const p3 = isHorizontal2 ? [to[0], fromWithPadding[1]] : [fromWithPadding[0], to[1]];
    return { points: [p3], direction: getDirection(p3, to) };
  }
}
function pointToNode(from, to, toBBox, direction) {
  const toWithPadding = isPointBBoxCenter(to, toBBox) ? to : getNearestBoundaryPoint(to, toBBox);
  const points = [
    [toWithPadding[0], from[1]],
    [from[0], toWithPadding[1]]
  ];
  const freePoints = points.filter((p3) => isPointOutsideBBox(p3, toBBox) && !isPointOnBBoxBoundary(p3, toBBox, true));
  const freeDirectionPoints = freePoints.filter((p3) => getDirection(p3, from) !== direction);
  if (freeDirectionPoints.length > 0) {
    const p3 = freeDirectionPoints.find((p4) => getDirection(from, p4) === direction) || freeDirectionPoints[0];
    return {
      points: [p3],
      direction: getDirection(p3, to)
    };
  } else {
    const p3 = difference_default(points, freePoints)[0];
    const p22 = moveTo(to, p3, getBBoxSize2(toBBox, direction) / 2);
    const p1 = freeJoin(p22, from, toBBox);
    return {
      points: [p1, p22],
      direction: getDirection(p22, to)
    };
  }
}
function nodeToNode(from, to, fromBBox, toBBox) {
  let route = nodeToPoint(from, to, fromBBox);
  const p1 = toVector3(route.points[0]);
  if (isPointInBBox(p1, toBBox)) {
    route = nodeToPoint(to, from, toBBox);
    const p22 = toVector3(route.points[0]);
    if (isPointInBBox(p22, fromBBox)) {
      const fromBorder = moveTo(from, p1, getBBoxSize2(fromBBox, getDirection(from, p1)) / 2);
      const toBorder = moveTo(to, p22, getBBoxSize2(toBBox, getDirection(to, p22)) / 2);
      const midPoint = [(fromBorder[0] + toBorder[0]) / 2, (fromBorder[1] + toBorder[1]) / 2];
      const startRoute = nodeToPoint(from, midPoint, fromBBox);
      const endRoute = pointToNode(midPoint, to, toBBox, startRoute.direction);
      route.points = [startRoute.points[0], endRoute.points[0]];
      route.direction = endRoute.direction;
    }
  }
  return route;
}
function insideNode(from, to, fromBBox, toBBox, direction) {
  const DEFAULT_OFFSET = 0.01;
  const boundary = getCombinedBBox([fromBBox, toBBox]);
  const reversed = distance(to, boundary.center) > distance(from, boundary.center);
  const [start, end] = reversed ? [to, from] : [from, to];
  const halfPerimeter = getBBoxHeight(boundary) + getBBoxWidth(boundary);
  let p1;
  if (direction) {
    const ref = [
      start[0] + halfPerimeter * Math.cos(radians[direction]),
      start[1] + halfPerimeter * Math.sin(radians[direction])
    ];
    p1 = moveTo(getNearestBoundaryPoint(ref, boundary), ref, DEFAULT_OFFSET);
  } else {
    p1 = moveTo(getNearestBoundaryPoint(start, boundary), start, -DEFAULT_OFFSET);
  }
  let p22 = freeJoin(p1, end, boundary);
  let points = [round(p1, 2), round(p22, 2)];
  if (is_equal_default(round(p1), round(p22))) {
    const rad2 = angle(subtract(p1, start), [1, 0, 0]) + Math.PI / 2;
    p22 = [end[0] + halfPerimeter * Math.cos(rad2), end[1] + halfPerimeter * Math.sin(rad2), 0];
    p22 = round(moveTo(getNearestBoundaryPoint(p22, boundary), end, -DEFAULT_OFFSET), 2);
    const p3 = freeJoin(p1, p22, boundary);
    points = [p1, p3, p22];
  }
  return {
    points: reversed ? points.reverse() : points,
    direction: reversed ? getDirection(p1, to) : getDirection(p22, to)
  };
}
function freeJoin(p1, p22, bbox) {
  let p3 = [p1[0], p22[1]];
  if (isPointInBBox(p3, bbox)) {
    p3 = [p22[0], p1[1]];
  }
  return p3;
}

// node_modules/@antv/g6/esm/utils/edge.js
function getLabelPositionStyle(key, placement, autoRotate, offsetX, offsetY) {
  const START_RATIO = 0;
  const MIDDLE_RATIO = 0.5;
  const END_RATIO = 0.99;
  let ratio = typeof placement === "number" ? placement : MIDDLE_RATIO;
  if (placement === "start")
    ratio = START_RATIO;
  if (placement === "end")
    ratio = END_RATIO;
  const point3 = parsePoint(key.getPoint(ratio));
  const pointOffset = parsePoint(key.getPoint(ratio + 0.01));
  let textAlign = placement === "start" ? "left" : placement === "end" ? "right" : "center";
  if (isHorizontal(point3, pointOffset) || !autoRotate) {
    const [x5, y5] = getXYByPlacement2(key, ratio, offsetX, offsetY);
    return { transform: [["translate", x5, y5]], textAlign };
  }
  let angle2 = Math.atan2(pointOffset[1] - point3[1], pointOffset[0] - point3[0]);
  const isRevert = pointOffset[0] < point3[0];
  if (isRevert) {
    textAlign = textAlign === "center" ? textAlign : textAlign === "left" ? "right" : "left";
    offsetX *= -1;
    angle2 += Math.PI;
  }
  const [x4, y4] = getXYByPlacement2(key, ratio, offsetX, offsetY, angle2);
  const transform = [
    ["translate", x4, y4],
    ["rotate", angle2 / Math.PI * 180]
  ];
  return {
    textAlign,
    transform
  };
}
function getBadgePositionStyle(shapeMap, placement, labelPlacement, offsetX, offsetY) {
  var _a, _b;
  const badgeWidth = ((_a = shapeMap.badge) === null || _a === void 0 ? void 0 : _a.getGeometryBounds().halfExtents[0]) * 2 || 0;
  const labelWidth = ((_b = shapeMap.label) === null || _b === void 0 ? void 0 : _b.getGeometryBounds().halfExtents[0]) * 2 || 0;
  return getLabelPositionStyle(shapeMap.key, labelPlacement, true, (labelWidth ? (labelWidth / 2 + badgeWidth / 2) * (placement === "suffix" ? 1 : -1) : 0) + offsetX, offsetY);
}
function getXYByPlacement2(key, ratio, offsetX, offsetY, angle2) {
  const [pointX, pointY] = parsePoint(key.getPoint(ratio));
  let actualOffsetX = offsetX;
  let actualOffsetY = offsetY;
  if (angle2) {
    actualOffsetX = offsetX * Math.cos(angle2) - offsetY * Math.sin(angle2);
    actualOffsetY = offsetX * Math.sin(angle2) + offsetY * Math.cos(angle2);
  }
  return [pointX + actualOffsetX, pointY + actualOffsetY];
}
function getCurveControlPoint(sourcePoint, targetPoint, curvePosition, curveOffset) {
  if (is_equal_default(sourcePoint, targetPoint))
    return sourcePoint;
  const lineVector = subtract(targetPoint, sourcePoint);
  const controlPoint = [
    sourcePoint[0] + curvePosition * lineVector[0],
    sourcePoint[1] + curvePosition * lineVector[1]
  ];
  const perpVector = normalize(perpendicular(lineVector, false));
  controlPoint[0] += curveOffset * perpVector[0];
  controlPoint[1] += curveOffset * perpVector[1];
  return controlPoint;
}
function parseCurveOffset(curveOffset) {
  if (isNumber(curveOffset))
    return [curveOffset, -curveOffset];
  return curveOffset;
}
function parseCurvePosition(curvePosition) {
  if (isNumber(curvePosition))
    return [curvePosition, 1 - curvePosition];
  return curvePosition;
}
function getQuadraticPath(sourcePoint, targetPoint, controlPoint) {
  return [
    ["M", sourcePoint[0], sourcePoint[1]],
    ["Q", controlPoint[0], controlPoint[1], targetPoint[0], targetPoint[1]]
  ];
}
function getCubicPath(sourcePoint, targetPoint, controlPoints) {
  return [
    ["M", sourcePoint[0], sourcePoint[1]],
    [
      "C",
      controlPoints[0][0],
      controlPoints[0][1],
      controlPoints[1][0],
      controlPoints[1][1],
      targetPoint[0],
      targetPoint[1]
    ]
  ];
}
function getPolylinePath(points, radius = 0, z4 = false) {
  const targetIndex = points.length - 1;
  const sourcePoint = points[0];
  const targetPoint = points[targetIndex];
  const controlPoints = points.slice(1, targetIndex);
  const pathArray = [["M", sourcePoint[0], sourcePoint[1]]];
  controlPoints.forEach((midPoint, i2) => {
    const prevPoint = controlPoints[i2 - 1] || sourcePoint;
    const nextPoint = controlPoints[i2 + 1] || targetPoint;
    if (!isCollinear(prevPoint, midPoint, nextPoint) && radius) {
      const [ps, pt2] = getBorderRadiusPoints(prevPoint, midPoint, nextPoint, radius);
      pathArray.push(["L", ps[0], ps[1]], ["Q", midPoint[0], midPoint[1], pt2[0], pt2[1]], ["L", pt2[0], pt2[1]]);
    } else {
      pathArray.push(["L", midPoint[0], midPoint[1]]);
    }
  });
  pathArray.push(["L", targetPoint[0], targetPoint[1]]);
  if (z4)
    pathArray.push(["Z"]);
  return pathArray;
}
function getBorderRadiusPoints(prevPoint, midPoint, nextPoint, radius) {
  const d0 = manhattanDistance(prevPoint, midPoint);
  const d1 = manhattanDistance(nextPoint, midPoint);
  const r3 = Math.min(radius, Math.min(d0, d1) / 2);
  const ps = [
    midPoint[0] - r3 / d0 * (midPoint[0] - prevPoint[0]),
    midPoint[1] - r3 / d0 * (midPoint[1] - prevPoint[1])
  ];
  const pt2 = [
    midPoint[0] - r3 / d1 * (midPoint[0] - nextPoint[0]),
    midPoint[1] - r3 / d1 * (midPoint[1] - nextPoint[1])
  ];
  return [ps, pt2];
}
var getRadians = (bbox) => {
  const halfPI = Math.PI / 2;
  const halfHeight = getBBoxHeight(bbox) / 2;
  const halfWidth = getBBoxWidth(bbox) / 2;
  const angleWithX = Math.atan2(halfHeight, halfWidth) / 2;
  const angleWithY = Math.atan2(halfWidth, halfHeight) / 2;
  return {
    top: [-halfPI - angleWithY, -halfPI + angleWithY],
    "top-right": [-halfPI + angleWithY, -angleWithX],
    "right-top": [-halfPI + angleWithY, -angleWithX],
    right: [-angleWithX, angleWithX],
    "bottom-right": [angleWithX, halfPI - angleWithY],
    "right-bottom": [angleWithX, halfPI - angleWithY],
    bottom: [halfPI - angleWithY, halfPI + angleWithY],
    "bottom-left": [halfPI + angleWithY, Math.PI - angleWithX],
    "left-bottom": [halfPI + angleWithY, Math.PI - angleWithX],
    left: [Math.PI - angleWithX, Math.PI + angleWithX],
    "top-left": [Math.PI + angleWithX, -halfPI - angleWithY],
    "left-top": [Math.PI + angleWithX, -halfPI - angleWithY]
  };
};
function getLoopEndpoints(node, placement, clockwise, sourcePort, targetPort) {
  const bbox = getNodeBBox(node);
  const center = node.getCenter();
  let sourcePoint = sourcePort && getPortPosition(sourcePort);
  let targetPoint = targetPort && getPortPosition(targetPort);
  if (!sourcePoint || !targetPoint) {
    const radians2 = getRadians(bbox);
    const angle1 = radians2[placement][0];
    const angle2 = radians2[placement][1];
    const [width2, height] = getBBoxSize(bbox);
    const r3 = Math.max(width2, height);
    const point1 = add(center, [r3 * Math.cos(angle1), r3 * Math.sin(angle1), 0]);
    const point22 = add(center, [r3 * Math.cos(angle2), r3 * Math.sin(angle2), 0]);
    sourcePoint = getNodeConnectionPoint(node, point1);
    targetPoint = getNodeConnectionPoint(node, point22);
    if (!clockwise) {
      [sourcePoint, targetPoint] = [targetPoint, sourcePoint];
    }
  }
  return [sourcePoint, targetPoint];
}
function getCubicLoopPath(node, placement, clockwise, dist, sourcePortKey, targetPortKey) {
  const sourcePort = node.getPorts()[sourcePortKey || targetPortKey];
  const targetPort = node.getPorts()[targetPortKey || sourcePortKey];
  let [sourcePoint, targetPoint] = getLoopEndpoints(node, placement, clockwise, sourcePort, targetPort);
  const controlPoints = getCubicLoopControlPoints(node, sourcePoint, targetPoint, dist);
  if (sourcePort)
    sourcePoint = getPortConnectionPoint(sourcePort, controlPoints[0]);
  if (targetPort)
    targetPoint = getPortConnectionPoint(targetPort, controlPoints.at(-1));
  return getCubicPath(sourcePoint, targetPoint, controlPoints);
}
function getCubicLoopControlPoints(node, sourcePoint, targetPoint, dist) {
  const center = node.getCenter();
  if (is_equal_default(sourcePoint, targetPoint)) {
    const direction = subtract(sourcePoint, center);
    const adjustment = [
      dist * Math.sign(direction[0]) || dist / 2,
      dist * Math.sign(direction[1]) || -dist / 2,
      0
    ];
    return [add(sourcePoint, adjustment), add(targetPoint, multiply(adjustment, [1, -1, 1]))];
  }
  return [
    moveTo(center, sourcePoint, distance(center, sourcePoint) + dist),
    moveTo(center, targetPoint, distance(center, targetPoint) + dist)
  ];
}
function getPolylineLoopPath(node, radius, placement, clockwise, dist, sourcePortKey, targetPortKey) {
  const allPortsMap = getAllPorts(node);
  const sourcePort = allPortsMap[sourcePortKey || targetPortKey];
  const targetPort = allPortsMap[targetPortKey || sourcePortKey];
  let [sourcePoint, targetPoint] = getLoopEndpoints(node, placement, clockwise, sourcePort, targetPort);
  const controlPoints = getPolylineLoopControlPoints(node, sourcePoint, targetPoint, dist);
  if (sourcePort)
    sourcePoint = getPortConnectionPoint(sourcePort, controlPoints[0]);
  if (targetPort)
    targetPoint = getPortConnectionPoint(targetPort, controlPoints.at(-1));
  return getPolylinePath([sourcePoint, ...controlPoints, targetPoint], radius);
}
function getPolylineLoopControlPoints(node, sourcePoint, targetPoint, dist) {
  const controlPoints = [];
  const bbox = getNodeBBox(node);
  if (is_equal_default(sourcePoint, targetPoint)) {
    const side = getNearestBoundarySide(sourcePoint, bbox);
    switch (side) {
      case "left":
        controlPoints.push([sourcePoint[0] - dist, sourcePoint[1]]);
        controlPoints.push([sourcePoint[0] - dist, sourcePoint[1] + dist]);
        controlPoints.push([sourcePoint[0], sourcePoint[1] + dist]);
        break;
      case "right":
        controlPoints.push([sourcePoint[0] + dist, sourcePoint[1]]);
        controlPoints.push([sourcePoint[0] + dist, sourcePoint[1] + dist]);
        controlPoints.push([sourcePoint[0], sourcePoint[1] + dist]);
        break;
      case "top":
        controlPoints.push([sourcePoint[0], sourcePoint[1] - dist]);
        controlPoints.push([sourcePoint[0] + dist, sourcePoint[1] - dist]);
        controlPoints.push([sourcePoint[0] + dist, sourcePoint[1]]);
        break;
      case "bottom":
        controlPoints.push([sourcePoint[0], sourcePoint[1] + dist]);
        controlPoints.push([sourcePoint[0] + dist, sourcePoint[1] + dist]);
        controlPoints.push([sourcePoint[0] + dist, sourcePoint[1]]);
        break;
    }
  } else {
    const sourceSide = getNearestBoundarySide(sourcePoint, bbox);
    const targetSide = getNearestBoundarySide(targetPoint, bbox);
    if (sourceSide === targetSide) {
      const side = sourceSide;
      let x4, y4;
      switch (side) {
        case "left":
          x4 = Math.min(sourcePoint[0], targetPoint[0]) - dist;
          controlPoints.push([x4, sourcePoint[1]]);
          controlPoints.push([x4, targetPoint[1]]);
          break;
        case "right":
          x4 = Math.max(sourcePoint[0], targetPoint[0]) + dist;
          controlPoints.push([x4, sourcePoint[1]]);
          controlPoints.push([x4, targetPoint[1]]);
          break;
        case "top":
          y4 = Math.min(sourcePoint[1], targetPoint[1]) - dist;
          controlPoints.push([sourcePoint[0], y4]);
          controlPoints.push([targetPoint[0], y4]);
          break;
        case "bottom":
          y4 = Math.max(sourcePoint[1], targetPoint[1]) + dist;
          controlPoints.push([sourcePoint[0], y4]);
          controlPoints.push([targetPoint[0], y4]);
          break;
      }
    } else {
      const getPointOffSide = (side, point3) => {
        return {
          left: [point3[0] - dist, point3[1]],
          right: [point3[0] + dist, point3[1]],
          top: [point3[0], point3[1] - dist],
          bottom: [point3[0], point3[1] + dist]
        }[side];
      };
      const p1 = getPointOffSide(sourceSide, sourcePoint);
      const p22 = getPointOffSide(targetSide, targetPoint);
      const p3 = freeJoin(p1, p22, bbox);
      controlPoints.push(p1, p3, p22);
    }
  }
  return controlPoints;
}
function getSubgraphRelatedEdges(ids, getRelatedEdges) {
  const edges = /* @__PURE__ */ new Set();
  const internal = /* @__PURE__ */ new Set();
  const external = /* @__PURE__ */ new Set();
  ids.forEach((id) => {
    const relatedEdges = getRelatedEdges(id);
    relatedEdges.forEach((edge) => {
      edges.add(edge);
      if (ids.includes(edge.source) && ids.includes(edge.target))
        internal.add(edge);
      else
        external.add(edge);
    });
  });
  return { edges: Array.from(edges), internal: Array.from(internal), external: Array.from(external) };
}
function findActualConnectNodeData(node, getParentData) {
  const path = [];
  let current2 = node;
  while (current2) {
    path.push(current2);
    const parent = getParentData(idOf(current2));
    if (parent)
      current2 = parent;
    else
      break;
  }
  if (path.some((n2) => {
    var _a;
    return (_a = n2.style) === null || _a === void 0 ? void 0 : _a.collapsed;
  })) {
    const index = path.reverse().findIndex(isCollapsed);
    return path[index] || path.at(-1);
  }
  return node;
}
function getArrowSize(lineWidth, size2) {
  if (size2)
    return size2;
  if (lineWidth < 4)
    return 10;
  if (lineWidth === 4)
    return 12;
  return lineWidth * 2.5;
}

// node_modules/@antv/g6/esm/utils/symbol.js
var symbol_exports = {};
__export(symbol_exports, {
  circle: () => circle,
  diamond: () => diamond,
  rect: () => rect,
  simple: () => simple,
  triangle: () => triangle,
  triangleRect: () => triangleRect,
  vee: () => vee
});
var circle = (width2, height) => {
  const r3 = Math.max(width2, height) / 2;
  return [["M", -width2 / 2, 0], ["A", r3, r3, 0, 1, 0, 2 * r3 - width2 / 2, 0], ["A", r3, r3, 0, 1, 0, -width2 / 2, 0], ["Z"]];
};
var triangle = (width2, height) => {
  return [["M", -width2 / 2, 0], ["L", width2 / 2, -height / 2], ["L", width2 / 2, height / 2], ["Z"]];
};
var diamond = (width2, height) => {
  return [["M", -width2 / 2, 0], ["L", 0, -height / 2], ["L", width2 / 2, 0], ["L", 0, height / 2], ["Z"]];
};
var vee = (width2, height) => {
  return [
    ["M", -width2 / 2, 0],
    ["L", width2 / 2, -height / 2],
    ["L", 4 * width2 / 5 - width2 / 2, 0],
    ["L", width2 / 2, height / 2],
    ["Z"]
  ];
};
var rect = (width2, height) => {
  return [
    ["M", -width2 / 2, -height / 2],
    ["L", width2 / 2, -height / 2],
    ["L", width2 / 2, height / 2],
    ["L", -width2 / 2, height / 2],
    ["Z"]
  ];
};
var triangleRect = (width2, height) => {
  const tWidth = width2 / 2;
  const rWidth = width2 / 7;
  const rBeginX = width2 - rWidth;
  return [
    ["M", -tWidth, 0],
    ["L", 0, -height / 2],
    ["L", 0, height / 2],
    ["Z"],
    ["M", rBeginX - tWidth, -height / 2],
    ["L", rBeginX + rWidth - tWidth, -height / 2],
    ["L", rBeginX + rWidth - tWidth, height / 2],
    ["L", rBeginX - tWidth, height / 2],
    ["Z"]
  ];
};
var simple = (width2, height) => {
  return [
    ["M", width2 / 2, -height / 2],
    ["L", -width2 / 2, 0],
    ["L", width2 / 2, 0],
    ["L", -width2 / 2, 0],
    ["L", width2 / 2, height / 2]
  ];
};

// node_modules/@antv/g6/esm/elements/edges/base-edge.js
var __rest11 = function(s2, e2) {
  var t3 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t3[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t3[p3[i2]] = s2[p3[i2]];
    }
  return t3;
};
var BaseEdge = class _BaseEdge extends BaseElement {
  constructor(options) {
    super(mergeOptions({ style: _BaseEdge.defaultStyleProps }, options));
    this.type = "edge";
  }
  get sourceNode() {
    const { sourceNode: source } = this.parsedAttributes;
    return this.context.element.getElement(source);
  }
  get targetNode() {
    const { targetNode: target } = this.parsedAttributes;
    return this.context.element.getElement(target);
  }
  getKeyStyle(attributes) {
    const _a = this.getGraphicStyle(attributes), { loop } = _a, style = __rest11(_a, ["loop"]);
    const { sourceNode, targetNode } = this;
    const d3 = loop && isSameNode(sourceNode, targetNode) ? this.getLoopPath(attributes) : this.getKeyPath(attributes);
    const keyStyle = { d: d3 };
    Path.PARSED_STYLE_LIST.forEach((key) => {
      if (key in style)
        keyStyle[key] = style[key];
    });
    return keyStyle;
  }
  getLoopPath(attributes) {
    const { sourcePort, targetPort } = attributes;
    const node = this.sourceNode;
    const bbox = getNodeBBox(node);
    const defaultDist = Math.max(getBBoxWidth(bbox), getBBoxHeight(bbox));
    const { placement, clockwise, dist = defaultDist } = subStyleProps(this.getGraphicStyle(attributes), "loop");
    return getCubicLoopPath(node, placement, clockwise, dist, sourcePort, targetPort);
  }
  getEndpoints(attributes, optimize = true, controlPoints = []) {
    const { sourcePort: sourcePortKey, targetPort: targetPortKey } = attributes;
    const { sourceNode, targetNode } = this;
    const [sourcePort, targetPort] = findPorts(sourceNode, targetNode, sourcePortKey, targetPortKey);
    if (!optimize) {
      const sourcePoint2 = sourcePort ? getPortPosition(sourcePort) : sourceNode.getCenter();
      const targetPoint2 = targetPort ? getPortPosition(targetPort) : targetNode.getCenter();
      return [sourcePoint2, targetPoint2];
    }
    const _controlPoints = typeof controlPoints === "function" ? controlPoints() : controlPoints;
    const sourcePoint = getConnectionPoint(sourcePort || sourceNode, _controlPoints[0] || targetPort || targetNode);
    const targetPoint = getConnectionPoint(targetPort || targetNode, _controlPoints[_controlPoints.length - 1] || sourcePort || sourceNode);
    return [sourcePoint, targetPoint];
  }
  getHaloStyle(attributes) {
    if (attributes.halo === false)
      return false;
    const keyStyle = this.getKeyStyle(attributes);
    const haloStyle = subStyleProps(this.getGraphicStyle(attributes), "halo");
    return Object.assign(Object.assign({}, keyStyle), haloStyle);
  }
  getLabelStyle(attributes) {
    if (attributes.label === false || !attributes.labelText)
      return false;
    const labelStyle = subStyleProps(this.getGraphicStyle(attributes), "label");
    const { placement, offsetX, offsetY, autoRotate, maxWidth } = labelStyle, restStyle = __rest11(labelStyle, ["placement", "offsetX", "offsetY", "autoRotate", "maxWidth"]);
    const labelPositionStyle = getLabelPositionStyle(this.shapeMap.key, placement, autoRotate, offsetX, offsetY);
    const bbox = this.shapeMap.key.getLocalBounds();
    const wordWrapWidth = getWordWrapWidthByEnds([bbox.min, bbox.max], maxWidth);
    return Object.assign({ wordWrapWidth }, labelPositionStyle, restStyle);
  }
  getBadgeStyle(attributes) {
    if (attributes.badge === false || !attributes.badgeText)
      return false;
    const _a = subStyleProps(attributes, "badge"), { offsetX, offsetY, placement } = _a, badgeStyle = __rest11(_a, ["offsetX", "offsetY", "placement"]);
    return Object.assign(badgeStyle, getBadgePositionStyle(this.shapeMap, placement, attributes.labelPlacement, offsetX, offsetY));
  }
  drawArrow(attributes, type) {
    var _a;
    const isStart = type === "start";
    const arrowType = type === "start" ? "startArrow" : "endArrow";
    const enable = attributes[arrowType];
    const keyShape = this.shapeMap.key;
    if (enable) {
      const arrowStyle = this.getArrowStyle(attributes, isStart);
      const [marker, markerOffset, arrowOffset] = isStart ? ["markerStart", "markerStartOffset", "startArrowOffset"] : ["markerEnd", "markerEndOffset", "endArrowOffset"];
      const arrow = keyShape.parsedStyle[marker];
      if (arrow)
        arrow.attr(arrowStyle);
      else {
        const Ctor = arrowStyle.src ? Image2 : Path;
        const arrowShape = new Ctor({ style: arrowStyle });
        keyShape.style[marker] = arrowShape;
      }
      keyShape.style[markerOffset] = attributes[arrowOffset] || arrowStyle.width / 2 + +arrowStyle.lineWidth;
    } else {
      const marker = isStart ? "markerStart" : "markerEnd";
      (_a = keyShape.style[marker]) === null || _a === void 0 ? void 0 : _a.destroy();
      keyShape.style[marker] = null;
    }
  }
  getArrowStyle(attributes, isStart) {
    const keyStyle = this.getShape("key").attributes;
    const arrowType = isStart ? "startArrow" : "endArrow";
    const _a = subStyleProps(this.getGraphicStyle(attributes), arrowType), { size: size2, type } = _a, arrowStyle = __rest11(_a, ["size", "type"]);
    const [width2, height] = parseSize(getArrowSize(keyStyle.lineWidth, size2));
    const arrowFn = isFunction(type) ? type : symbol_exports[type] || triangle;
    const d3 = arrowFn(width2, height);
    return Object.assign(pick_default(keyStyle, ["stroke", "strokeOpacity", "fillOpacity"]), { width: width2, height }, Object.assign({}, d3 && { d: d3, fill: type === "simple" ? "" : keyStyle.stroke }), arrowStyle);
  }
  drawLabelShape(attributes, container) {
    const style = this.getLabelStyle(attributes);
    this.upsert("label", Label, style, container);
  }
  drawHaloShape(attributes, container) {
    const style = this.getHaloStyle(attributes);
    this.upsert("halo", Path, style, container);
  }
  drawBadgeShape(attributes, container) {
    const style = this.getBadgeStyle(attributes);
    this.upsert("badge", Badge, style, container);
  }
  drawSourceArrow(attributes) {
    this.drawArrow(attributes, "start");
  }
  drawTargetArrow(attributes) {
    this.drawArrow(attributes, "end");
  }
  drawKeyShape(attributes, container) {
    const style = this.getKeyStyle(attributes);
    return this.upsert("key", Path, style, container);
  }
  render(attributes = this.parsedAttributes, container = this) {
    this.drawKeyShape(attributes, container);
    if (!this.getShape("key"))
      return;
    this.drawSourceArrow(attributes);
    this.drawTargetArrow(attributes);
    this.drawLabelShape(attributes, container);
    this.drawHaloShape(attributes, container);
    this.drawBadgeShape(attributes, container);
  }
  onframe() {
    this.drawKeyShape(this.parsedAttributes, this);
    this.drawSourceArrow(this.parsedAttributes);
    this.drawTargetArrow(this.parsedAttributes);
    this.drawHaloShape(this.parsedAttributes, this);
    this.drawLabelShape(this.parsedAttributes, this);
    this.drawBadgeShape(this.parsedAttributes, this);
  }
  animate(keyframes, options) {
    const animation = super.animate(keyframes, options);
    if (!animation)
      return animation;
    return new Proxy(animation, {
      set: (target, propKey, value) => {
        if (propKey === "currentTime")
          Promise.resolve().then(() => this.onframe());
        return Reflect.set(target, propKey, value);
      }
    });
  }
};
BaseEdge.defaultStyleProps = {
  badge: true,
  badgeOffsetX: 0,
  badgeOffsetY: 0,
  badgePlacement: "suffix",
  isBillboard: true,
  label: true,
  labelAutoRotate: true,
  labelIsBillboard: true,
  labelMaxWidth: "80%",
  labelOffsetX: 4,
  labelOffsetY: 0,
  labelPlacement: "center",
  labelTextBaseline: "middle",
  labelWordWrap: false,
  halo: false,
  haloDroppable: false,
  haloLineDash: 0,
  haloLineWidth: 12,
  haloPointerEvents: "none",
  haloStrokeOpacity: 0.25,
  haloZIndex: -1,
  loop: true,
  startArrow: false,
  startArrowLineDash: 0,
  startArrowLineJoin: "round",
  startArrowLineWidth: 1,
  startArrowTransformOrigin: "center",
  startArrowType: "vee",
  endArrow: false,
  endArrowLineDash: 0,
  endArrowLineJoin: "round",
  endArrowLineWidth: 1,
  endArrowTransformOrigin: "center",
  endArrowType: "vee",
  loopPlacement: "top",
  loopClockwise: true
};

// node_modules/@antv/g6/esm/elements/edges/cubic.js
var Cubic = class _Cubic extends BaseEdge {
  constructor(options) {
    super(mergeOptions({ style: _Cubic.defaultStyleProps }, options));
  }
  /**
   * @inheritdoc
   */
  getKeyPath(attributes) {
    const [sourcePoint, targetPoint] = this.getEndpoints(attributes);
    const { controlPoints, curvePosition, curveOffset } = attributes;
    const actualControlPoints = this.getControlPoints(sourcePoint, targetPoint, parseCurvePosition(curvePosition), parseCurveOffset(curveOffset), controlPoints);
    return getCubicPath(sourcePoint, targetPoint, actualControlPoints);
  }
  getControlPoints(sourcePoint, targetPoint, curvePosition, curveOffset, controlPoints) {
    return (controlPoints === null || controlPoints === void 0 ? void 0 : controlPoints.length) === 2 ? controlPoints : [
      getCurveControlPoint(sourcePoint, targetPoint, curvePosition[0], curveOffset[0]),
      getCurveControlPoint(sourcePoint, targetPoint, curvePosition[1], curveOffset[1])
    ];
  }
};
Cubic.defaultStyleProps = {
  curvePosition: 0.5,
  curveOffset: 20
};

// node_modules/@antv/g6/esm/elements/edges/cubic-horizontal.js
var CubicHorizontal = class _CubicHorizontal extends Cubic {
  constructor(options) {
    super(mergeOptions({ style: _CubicHorizontal.defaultStyleProps }, options));
  }
  getControlPoints(sourcePoint, targetPoint, curvePosition, curveOffset) {
    const xDist = targetPoint[0] - sourcePoint[0];
    return [
      [sourcePoint[0] + xDist * curvePosition[0] + curveOffset[0], sourcePoint[1]],
      [targetPoint[0] - xDist * curvePosition[1] + curveOffset[1], targetPoint[1]]
    ];
  }
};
CubicHorizontal.defaultStyleProps = {
  curvePosition: [0.5, 0.5],
  curveOffset: [0, 0]
};

// node_modules/@antv/g6/esm/elements/edges/cubic-radial.js
var CubicRadial = class _CubicRadial extends Cubic {
  constructor(options) {
    super(mergeOptions({ style: _CubicRadial.defaultStyleProps }, options));
  }
  get ref() {
    return this.context.model.getRootsData()[0];
  }
  getEndpoints(attributes) {
    if (this.sourceNode.id === this.ref.id) {
      return super.getEndpoints(attributes);
    }
    const refPoint = positionOf(this.ref);
    const sourcePoint = this.sourceNode.getIntersectPoint(refPoint, true);
    const targetPoint = this.targetNode.getIntersectPoint(refPoint);
    return [sourcePoint, targetPoint];
  }
  toRadialCoordinate(p3) {
    const refPoint = positionOf(this.ref);
    const r3 = distance(p3, refPoint);
    const radian = rad(subtract(p3, refPoint));
    return [r3, radian];
  }
  getControlPoints(sourcePoint, targetPoint, curvePosition, curveOffset) {
    const [r1, rad1] = this.toRadialCoordinate(sourcePoint);
    const [r22] = this.toRadialCoordinate(targetPoint);
    const rDist = r22 - r1;
    return [
      [
        sourcePoint[0] + (rDist * curvePosition[0] + curveOffset[0]) * Math.cos(rad1),
        sourcePoint[1] + (rDist * curvePosition[0] + curveOffset[0]) * Math.sin(rad1)
      ],
      [
        targetPoint[0] - (rDist * curvePosition[1] - curveOffset[0]) * Math.cos(rad1),
        targetPoint[1] - (rDist * curvePosition[1] - curveOffset[0]) * Math.sin(rad1)
      ]
    ];
  }
};
CubicRadial.defaultStyleProps = {
  curvePosition: 0.5,
  curveOffset: 20
};

// node_modules/@antv/g6/esm/elements/edges/cubic-vertical.js
var CubicVertical = class _CubicVertical extends Cubic {
  constructor(options) {
    super(mergeOptions({ style: _CubicVertical.defaultStyleProps }, options));
  }
  getControlPoints(sourcePoint, targetPoint, curvePosition, curveOffset) {
    const yDist = targetPoint[1] - sourcePoint[1];
    return [
      [sourcePoint[0], sourcePoint[1] + yDist * curvePosition[0] + curveOffset[0]],
      [targetPoint[0], targetPoint[1] - yDist * curvePosition[1] + curveOffset[1]]
    ];
  }
};
CubicVertical.defaultStyleProps = {
  curvePosition: [0.5, 0.5],
  curveOffset: [0, 0]
};

// node_modules/@antv/g6/esm/elements/edges/line.js
var Line2 = class _Line extends BaseEdge {
  constructor(options) {
    super(mergeOptions({ style: _Line.defaultStyleProps }, options));
  }
  getKeyPath(attributes) {
    const [sourcePoint, targetPoint] = this.getEndpoints(attributes);
    return [
      ["M", sourcePoint[0], sourcePoint[1]],
      ["L", targetPoint[0], targetPoint[1]]
    ];
  }
};
Line2.defaultStyleProps = {};

// node_modules/@antv/g6/esm/utils/router/shortest-path.js
var defaultCfg = {
  enableObstacleAvoidance: false,
  offset: 10,
  maxAllowedDirectionChange: Math.PI / 2,
  maximumLoops: 3e3,
  gridSize: 5,
  startDirections: ["top", "right", "bottom", "left"],
  endDirections: ["top", "right", "bottom", "left"],
  directionMap: {
    right: { stepX: 1, stepY: 0 },
    left: { stepX: -1, stepY: 0 },
    bottom: { stepX: 0, stepY: 1 },
    top: { stepX: 0, stepY: -1 }
  },
  penalties: { 0: 0, 90: 0 },
  distFunc: manhattanDistance
};
var keyOf = (point3) => `${Math.round(point3[0])}|||${Math.round(point3[1])}`;
function alignToGrid(p3, gridSize) {
  const align = (value) => Math.round(value / gridSize);
  if (isNumber(p3))
    return align(p3);
  return p3.map(align);
}
function getAngleDiff(angle1, angle2) {
  const directionChange = Math.abs(angle1 - angle2);
  return directionChange > Math.PI ? 2 * Math.PI - directionChange : directionChange;
}
function getDirectionAngle(p1, p22) {
  const deltaX = p22[0] - p1[0];
  const deltaY = p22[1] - p1[1];
  if (!deltaX && !deltaY)
    return 0;
  return Math.atan2(deltaY, deltaX);
}
function getDirectionChange(current2, neighbor, cameFrom, scaleStartPoint) {
  const directionAngle = getDirectionAngle(current2, neighbor);
  const currentCameFrom = cameFrom[keyOf(current2)];
  const prev = !currentCameFrom ? scaleStartPoint : currentCameFrom;
  const prevDirectionAngle = getDirectionAngle(prev, current2);
  return getAngleDiff(prevDirectionAngle, directionAngle);
}
var getObstacleMap = (nodes, options) => {
  const { offset, gridSize } = options;
  const obstacleMap = {};
  nodes.forEach((item) => {
    if (!item || item.destroyed || !item.isVisible())
      return;
    const bbox = getExpandedBBox(item.getRenderBounds(), offset);
    for (let x4 = alignToGrid(bbox.min[0], gridSize); x4 <= alignToGrid(bbox.max[0], gridSize); x4 += 1) {
      for (let y4 = alignToGrid(bbox.min[1], gridSize); y4 <= alignToGrid(bbox.max[1], gridSize); y4 += 1) {
        obstacleMap[`${x4}|||${y4}`] = true;
      }
    }
  });
  return obstacleMap;
};
function estimateCost(from, anchors, distFunc) {
  return Math.min(...anchors.map((anchor) => distFunc(from, anchor)));
}
function getNearestPoint(points, refPoint, distFunc) {
  let nearestPoint = points[0];
  let minDistance = distFunc(points[0], refPoint);
  for (let i2 = 0; i2 < points.length; i2++) {
    const point3 = points[i2];
    const dis = distFunc(point3, refPoint);
    if (dis < minDistance) {
      nearestPoint = point3;
      minDistance = dis;
    }
  }
  return nearestPoint;
}
var getBoxPoints = (point3, node, directions, options) => {
  if (!node)
    return [point3];
  const { directionMap, offset } = options;
  const expandedBBox = getExpandedBBox(node.getRenderBounds(), offset);
  const points = Object.keys(directionMap).reduce((res, directionKey) => {
    if (directions.includes(directionKey)) {
      const direction = directionMap[directionKey];
      const [width2, height] = getBBoxSize(expandedBBox);
      const otherPoint = [point3[0] + direction.stepX * width2, point3[1] + direction.stepY * height];
      const segments = getBBoxSegments(expandedBBox);
      for (let i2 = 0; i2 < segments.length; i2++) {
        const intersectP = getLinesIntersection([point3, otherPoint], segments[i2]);
        if (intersectP && isPointOnBBoxBoundary(intersectP, expandedBBox)) {
          res.push(intersectP);
        }
      }
    }
    return res;
  }, []);
  if (!isPointInBBox(point3, expandedBBox)) {
    points.push(point3);
  }
  return points.map((point4) => alignToGrid(point4, options.gridSize));
};
var getControlPoints = (current2, cameFrom, scaleStartPoint, endPoint, startPoints, scaleEndPoint, gridSize) => {
  const controlPoints = [];
  let pointZero = [
    scaleEndPoint[0] === endPoint[0] ? endPoint[0] : current2[0] * gridSize,
    scaleEndPoint[1] === endPoint[1] ? endPoint[1] : current2[1] * gridSize
  ];
  controlPoints.unshift(pointZero);
  let _current = current2;
  let _currentCameFrom = cameFrom[keyOf(_current)];
  while (_currentCameFrom) {
    const prePoint = _currentCameFrom;
    const point3 = _current;
    const directionChange = getDirectionChange(prePoint, point3, cameFrom, scaleStartPoint);
    if (directionChange) {
      pointZero = [
        prePoint[0] === point3[0] ? pointZero[0] : prePoint[0] * gridSize,
        prePoint[1] === point3[1] ? pointZero[1] : prePoint[1] * gridSize
      ];
      controlPoints.unshift(pointZero);
    }
    _currentCameFrom = cameFrom[keyOf(prePoint)];
    _current = prePoint;
  }
  const realStartPoints = startPoints.map((point3) => [point3[0] * gridSize, point3[1] * gridSize]);
  const startPoint = getNearestPoint(realStartPoints, pointZero, manhattanDistance);
  controlPoints.unshift(startPoint);
  return controlPoints;
};
function aStarSearch(sourceNode, targetNode, nodes, config) {
  const startPoint = toVector2(sourceNode.getCenter());
  const endPoint = toVector2(targetNode.getCenter());
  const options = Object.assign(defaultCfg, config);
  const { gridSize } = options;
  const obstacles = options.enableObstacleAvoidance ? nodes : [sourceNode, targetNode];
  const obstacleMap = getObstacleMap(obstacles, options);
  const scaleStartPoint = alignToGrid(startPoint, gridSize);
  const scaleEndPoint = alignToGrid(endPoint, gridSize);
  const startPoints = getBoxPoints(startPoint, sourceNode, options.startDirections, options);
  const endPoints = getBoxPoints(endPoint, targetNode, options.endDirections, options);
  startPoints.forEach((point3) => delete obstacleMap[keyOf(point3)]);
  endPoints.forEach((point3) => delete obstacleMap[keyOf(point3)]);
  const openList = {};
  const closedList = {};
  const cameFrom = {};
  const gScore = {};
  const fScore = {};
  const sortedOpenSet = new SortedArray();
  for (let i2 = 0; i2 < startPoints.length; i2++) {
    const firstStep = startPoints[i2];
    const key = keyOf(firstStep);
    openList[key] = firstStep;
    gScore[key] = 0;
    fScore[key] = estimateCost(firstStep, endPoints, options.distFunc);
    sortedOpenSet.add({
      id: key,
      value: fScore[key]
    });
  }
  const endPointsKeys = endPoints.map((point3) => keyOf(point3));
  let remainLoops = options.maximumLoops;
  let current2;
  let curCost = Infinity;
  for (const [id, value] of Object.entries(openList)) {
    if (fScore[id] <= curCost) {
      curCost = fScore[id];
      current2 = value;
    }
  }
  while (Object.keys(openList).length > 0 && remainLoops > 0) {
    const minId = sortedOpenSet.minId(false);
    if (minId) {
      current2 = openList[minId];
    } else {
      break;
    }
    const key = keyOf(current2);
    if (endPointsKeys.includes(key)) {
      return getControlPoints(current2, cameFrom, scaleStartPoint, endPoint, startPoints, scaleEndPoint, gridSize);
    }
    delete openList[key];
    sortedOpenSet.remove(key);
    closedList[key] = true;
    for (const dir of Object.values(options.directionMap)) {
      const neighbor = add(current2, [dir.stepX, dir.stepY]);
      const neighborId = keyOf(neighbor);
      if (closedList[neighborId])
        continue;
      const directionChange = getDirectionChange(current2, neighbor, cameFrom, scaleStartPoint);
      if (directionChange > options.maxAllowedDirectionChange)
        continue;
      if (obstacleMap[neighborId])
        continue;
      if (!openList[neighborId]) {
        openList[neighborId] = neighbor;
      }
      const directionPenalties = options.penalties[directionChange];
      const neighborCost = options.distFunc(current2, neighbor) + (isNaN(directionPenalties) ? gridSize : directionPenalties);
      const costFromStart = gScore[key] + neighborCost;
      const neighborGScore = gScore[neighborId];
      if (neighborGScore && costFromStart >= neighborGScore)
        continue;
      cameFrom[neighborId] = current2;
      gScore[neighborId] = costFromStart;
      fScore[neighborId] = costFromStart + estimateCost(neighbor, endPoints, options.distFunc);
      sortedOpenSet.add({
        id: neighborId,
        value: fScore[neighborId]
      });
    }
    remainLoops -= 1;
  }
  return [];
}
var SortedArray = class {
  constructor() {
    this.arr = [];
    this.map = {};
    this.arr = [];
    this.map = {};
  }
  _innerAdd(item, length) {
    let low = 0, high = length - 1;
    while (high - low > 1) {
      const mid = Math.floor((low + high) / 2);
      if (this.arr[mid].value > item.value) {
        high = mid;
      } else if (this.arr[mid].value < item.value) {
        low = mid;
      } else {
        this.arr.splice(mid, 0, item);
        this.map[item.id] = true;
        return;
      }
    }
    this.arr.splice(high, 0, item);
    this.map[item.id] = true;
  }
  /**
   * <zh/> 
   *
   * <en/> Add the new item to the appropriate index
   * @param item - <zh/>  | <en/> new item
   */
  add(item) {
    delete this.map[item.id];
    const length = this.arr.length;
    if (!length || this.arr[length - 1].value < item.value) {
      this.arr.push(item);
      this.map[item.id] = true;
      return;
    }
    this._innerAdd(item, length);
  }
  remove(id) {
    if (!this.map[id])
      return;
    delete this.map[id];
  }
  _clearAndGetMinId() {
    let res;
    for (let i2 = this.arr.length - 1; i2 >= 0; i2--) {
      if (this.map[this.arr[i2].id])
        res = this.arr[i2].id;
      else
        this.arr.splice(i2, 1);
    }
    return res;
  }
  _findFirstId() {
    while (this.arr.length) {
      const first = this.arr.shift();
      if (this.map[first.id])
        return first.id;
    }
  }
  minId(clear) {
    if (clear) {
      return this._clearAndGetMinId();
    } else {
      return this._findFirstId();
    }
  }
};

// node_modules/@antv/g6/esm/elements/edges/polyline.js
var Polyline2 = class _Polyline extends BaseEdge {
  constructor(options) {
    super(mergeOptions({ style: _Polyline.defaultStyleProps }, options));
  }
  getControlPoints(attributes) {
    const { router } = attributes;
    const { sourceNode, targetNode } = this;
    const [sourcePoint, targetPoint] = this.getEndpoints(attributes, false);
    let controlPoints = [];
    if (!router) {
      controlPoints = attributes.controlPoints;
    } else {
      if (router.type === "shortest-path") {
        const nodes = this.context.element.getNodes();
        controlPoints = aStarSearch(sourceNode, targetNode, nodes, router);
        if (!controlPoints.length) {
          controlPoints = orth(sourcePoint, targetPoint, sourceNode, targetNode, attributes.controlPoints, {
            padding: router.offset
          });
        }
      } else if (router.type === "orth") {
        controlPoints = orth(sourcePoint, targetPoint, sourceNode, targetNode, attributes.controlPoints, router);
      }
    }
    return controlPoints;
  }
  getPoints(attributes) {
    const controlPoints = this.getControlPoints(attributes);
    const [newSourcePoint, newTargetPoint] = this.getEndpoints(attributes, true, controlPoints);
    return [newSourcePoint, ...controlPoints, newTargetPoint];
  }
  getKeyPath(attributes) {
    const points = this.getPoints(attributes);
    return getPolylinePath(points, attributes.radius);
  }
  getLoopPath(attributes) {
    const { sourcePort: sourcePortKey, targetPort: targetPortKey, radius } = attributes;
    const node = this.sourceNode;
    const bbox = getNodeBBox(node);
    const defaultDist = Math.max(getBBoxWidth(bbox), getBBoxHeight(bbox)) / 4;
    const { placement, clockwise, dist = defaultDist } = subStyleProps(this.getGraphicStyle(attributes), "loop");
    return getPolylineLoopPath(node, radius, placement, clockwise, dist, sourcePortKey, targetPortKey);
  }
};
Polyline2.defaultStyleProps = {
  radius: 0,
  controlPoints: [],
  router: false
};

// node_modules/@antv/g6/esm/elements/edges/quadratic.js
var Quadratic = class _Quadratic extends BaseEdge {
  constructor(options) {
    super(mergeOptions({ style: _Quadratic.defaultStyleProps }, options));
  }
  getKeyPath(attributes) {
    const { curvePosition, curveOffset } = attributes;
    const [sourcePoint, targetPoint] = this.getEndpoints(attributes);
    const controlPoint = attributes.controlPoint || getCurveControlPoint(sourcePoint, targetPoint, curvePosition, curveOffset);
    return getQuadraticPath(sourcePoint, targetPoint, controlPoint);
  }
};
Quadratic.defaultStyleProps = {
  curvePosition: 0.5,
  curveOffset: 30
};

// node_modules/@antv/g6/esm/utils/element.js
var __rest12 = function(s2, e2) {
  var t3 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t3[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t3[p3[i2]] = s2[p3[i2]];
    }
  return t3;
};
function isNode(shape) {
  return shape instanceof BaseNode && shape.type === "node";
}
function isEdge(shape) {
  return shape instanceof BaseEdge;
}
function isCombo(shape) {
  return shape instanceof BaseCombo;
}
function isElement(shape) {
  return isNode(shape) || isEdge(shape) || isCombo(shape);
}
function isSameNode(node1, node2) {
  if (!node1 || !node2)
    return false;
  return node1 === node2;
}
var PORT_MAP = {
  top: [0.5, 0],
  right: [1, 0.5],
  bottom: [0.5, 1],
  left: [0, 0.5],
  "left-top": [0, 0],
  "top-left": [0, 0],
  "left-bottom": [0, 1],
  "bottom-left": [0, 1],
  "right-top": [1, 0],
  "top-right": [1, 0],
  "right-bottom": [1, 1],
  "bottom-right": [1, 1],
  default: [0.5, 0.5]
};
function getPortXYByPlacement(bbox, placement, portMap = PORT_MAP, isRelative = true) {
  const DEFAULT = [0.5, 0.5];
  const p3 = isString(placement) ? get_default(portMap, placement.toLocaleLowerCase(), DEFAULT) : placement;
  if (!isRelative && isString(placement))
    return p3;
  const [x4, y4] = p3 || DEFAULT;
  return [bbox.min[0] + getBBoxWidth(bbox) * x4, bbox.min[1] + getBBoxHeight(bbox) * y4];
}
function getAllPorts(node) {
  if (!node)
    return {};
  const ports = node.getPorts();
  const portsStyle = node.attributes.ports || [];
  portsStyle.forEach((portStyle, i2) => {
    var _a;
    const { key, placement } = portStyle;
    if (isSimplePort(portStyle)) {
      ports[_a = key || i2] || (ports[_a] = getXYByPlacement(node.getShape("key").getBounds(), placement));
    }
  });
  return ports;
}
function isSimplePort(portStyle) {
  const { r: r3 } = portStyle;
  return !r3 || Number(r3) === 0;
}
function getPortPosition(port) {
  return isPoint(port) ? port : port.getPosition();
}
function findPorts(sourceNode, targetNode, sourcePortKey, targetPortKey) {
  const sourcePort = findPort(sourceNode, targetNode, sourcePortKey, targetPortKey);
  const targetPort = findPort(targetNode, sourceNode, targetPortKey, sourcePortKey);
  return [sourcePort, targetPort];
}
function findPort(node, oppositeNode, portKey, oppositePortKey) {
  const portsMap = getAllPorts(node);
  if (portKey)
    return portsMap[portKey];
  const ports = Object.values(portsMap);
  if (ports.length === 0)
    return void 0;
  const positions = ports.map((port) => getPortPosition(port));
  const oppositePositions = findConnectionPoints(oppositeNode, oppositePortKey);
  const [nearestPosition] = findNearestPoints(positions, oppositePositions);
  return ports.find((port) => getPortPosition(port) === nearestPosition);
}
function findConnectionPoints(node, portKey) {
  const allPortsMap = getAllPorts(node);
  if (portKey)
    return [getPortPosition(allPortsMap[portKey])];
  const oppositePorts = Object.values(allPortsMap);
  return oppositePorts.length > 0 ? oppositePorts.map((port) => getPortPosition(port)) : [node.getCenter()];
}
function getConnectionPoint(node, opposite) {
  return isCombo(node) || isNode(node) ? getNodeConnectionPoint(node, opposite) : getPortConnectionPoint(node, opposite);
}
function getPortConnectionPoint(port, opposite) {
  if (!port || !opposite)
    return [0, 0, 0];
  if (isPoint(port))
    return port;
  if (port.attributes.linkToCenter)
    return port.getPosition();
  const oppositePosition = isPoint(opposite) ? opposite : isNode(opposite) ? opposite.getCenter() : opposite.getPosition();
  return getEllipseIntersectPoint(oppositePosition, port.getBounds());
}
function getNodeConnectionPoint(nodeLike, opposite) {
  if (!nodeLike || !opposite)
    return [0, 0, 0];
  const oppositePosition = isPoint(opposite) ? opposite : isNode(opposite) ? opposite.getCenter() : opposite.getPosition();
  return nodeLike.getIntersectPoint(oppositePosition) || nodeLike.getCenter();
}
function getTextStyleByPlacement(bbox, placement = "bottom", offsetX = 0, offsetY = 0, isReverseBaseline = false) {
  const direction = placement.split("-");
  const [x4, y4] = getXYByPlacement(bbox, placement);
  const [top, bottom] = isReverseBaseline ? ["bottom", "top"] : ["top", "bottom"];
  const textBaseline = direction.includes("top") ? bottom : direction.includes("bottom") ? top : "middle";
  const textAlign = direction.includes("left") ? "right" : direction.includes("right") ? "left" : "center";
  return {
    transform: [["translate", x4 + offsetX, y4 + offsetY]],
    textBaseline,
    textAlign
  };
}
function getStarPoints(outerR, innerR) {
  return [
    [0, -outerR],
    [innerR * Math.cos(3 * Math.PI / 10), -innerR * Math.sin(3 * Math.PI / 10)],
    [outerR * Math.cos(Math.PI / 10), -outerR * Math.sin(Math.PI / 10)],
    [innerR * Math.cos(Math.PI / 10), innerR * Math.sin(Math.PI / 10)],
    [outerR * Math.cos(3 * Math.PI / 10), outerR * Math.sin(3 * Math.PI / 10)],
    [0, innerR],
    [-outerR * Math.cos(3 * Math.PI / 10), outerR * Math.sin(3 * Math.PI / 10)],
    [-innerR * Math.cos(Math.PI / 10), innerR * Math.sin(Math.PI / 10)],
    [-outerR * Math.cos(Math.PI / 10), -outerR * Math.sin(Math.PI / 10)],
    [-innerR * Math.cos(3 * Math.PI / 10), -innerR * Math.sin(3 * Math.PI / 10)]
  ];
}
function getStarPorts(outerR, innerR) {
  const r3 = {};
  r3["top"] = [0, -outerR];
  r3["left"] = [-outerR * Math.cos(Math.PI / 10), -outerR * Math.sin(Math.PI / 10)];
  r3["left-bottom"] = [-outerR * Math.cos(3 * Math.PI / 10), outerR * Math.sin(3 * Math.PI / 10)];
  r3["bottom"] = [0, innerR];
  r3["right-bottom"] = [outerR * Math.cos(3 * Math.PI / 10), outerR * Math.sin(3 * Math.PI / 10)];
  r3["right"] = r3["default"] = [outerR * Math.cos(Math.PI / 10), -outerR * Math.sin(Math.PI / 10)];
  return r3;
}
function getTrianglePoints(width2, height, direction) {
  const halfHeight = height / 2;
  const halfWidth = width2 / 2;
  const MAP = {
    up: [
      [-halfWidth, halfHeight],
      [halfWidth, halfHeight],
      [0, -halfHeight]
    ],
    left: [
      [-halfWidth, 0],
      [halfWidth, halfHeight],
      [halfWidth, -halfHeight]
    ],
    right: [
      [-halfWidth, halfHeight],
      [-halfWidth, -halfHeight],
      [halfWidth, 0]
    ],
    down: [
      [-halfWidth, -halfHeight],
      [halfWidth, -halfHeight],
      [0, halfHeight]
    ]
  };
  return MAP[direction] || MAP["up"];
}
function getTrianglePorts(width2, height, direction) {
  const halfHeight = height / 2;
  const halfWidth = width2 / 2;
  const ports = {};
  if (direction === "down") {
    ports["bottom"] = ports["default"] = [0, halfHeight];
    ports["right"] = [halfWidth, -halfHeight];
    ports["left"] = [-halfWidth, -halfHeight];
  } else if (direction === "left") {
    ports["top"] = [halfWidth, -halfHeight];
    ports["bottom"] = [halfWidth, halfHeight];
    ports["left"] = ports["default"] = [-halfWidth, 0];
  } else if (direction === "right") {
    ports["top"] = [-halfWidth, -halfHeight];
    ports["bottom"] = [-halfWidth, halfHeight];
    ports["right"] = ports["default"] = [halfWidth, 0];
  } else {
    ports["left"] = [-halfWidth, halfHeight];
    ports["top"] = ports["default"] = [0, -halfHeight];
    ports["right"] = [halfWidth, halfHeight];
  }
  return ports;
}
function getDiamondPoints(width2, height) {
  return [
    [0, -height / 2],
    [width2 / 2, 0],
    [0, height / 2],
    [-width2 / 2, 0]
  ];
}
function isVisible(element) {
  return get_default(element, ["style", "visibility"]) !== "hidden";
}
function setAttributes(element, style) {
  const { zIndex, transform, transformOrigin, visibility, cursor, clipPath, component } = style, rest = __rest12(style, ["zIndex", "transform", "transformOrigin", "visibility", "cursor", "clipPath", "component"]);
  Object.assign(element.attributes, rest);
  if (transform)
    element.setAttribute("transform", transform);
  if (isNumber(zIndex))
    element.setAttribute("zIndex", zIndex);
  if (transformOrigin)
    element.setAttribute("transformOrigin", transformOrigin);
  if (visibility)
    element.setAttribute("visibility", visibility);
  if (cursor)
    element.setAttribute("cursor", cursor);
  if (clipPath)
    element.setAttribute("clipPath", clipPath);
  if (component)
    element.setAttribute("component", component);
}
function updateStyle(shape, style) {
  if ("update" in shape)
    shape.update(style);
  else
    shape.attr(style);
}
function getHexagonPoints(outerR) {
  return [
    [0, outerR],
    [outerR * Math.sqrt(3) / 2, outerR / 2],
    [outerR * Math.sqrt(3) / 2, -outerR / 2],
    [0, -outerR],
    [-outerR * Math.sqrt(3) / 2, -outerR / 2],
    [-outerR * Math.sqrt(3) / 2, outerR / 2]
  ];
}
function markToBeDestroyed(element) {
  set_default(element, "__to_be_destroyed__", true);
}
function isToBeDestroyed(element) {
  return get_default(element, "__to_be_destroyed__", false);
}

// node_modules/@antv/g6/esm/behaviors/collapse-expand.js
var __awaiter3 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CollapseExpand = class _CollapseExpand extends BaseBehavior {
  constructor(context, options) {
    super(context, Object.assign({}, _CollapseExpand.defaultOptions, options));
    this.onCollapseExpand = (event) => __awaiter3(this, void 0, void 0, function* () {
      if (!this.validate(event))
        return;
      const { target } = event;
      if (!isElement(target))
        return;
      const id = target.id;
      const { model, graph } = this.context;
      const data = model.getElementDataById(id);
      if (!data)
        return false;
      const { onCollapse, onExpand, animation, align } = this.options;
      if (isCollapsed(data)) {
        yield graph.expandElement(id, { animation, align });
        onExpand === null || onExpand === void 0 ? void 0 : onExpand(id);
      } else {
        yield graph.collapseElement(id, { animation, align });
        onCollapse === null || onCollapse === void 0 ? void 0 : onCollapse(id);
      }
    });
    this.bindEvents();
  }
  update(options) {
    this.unbindEvents();
    super.update(options);
    this.bindEvents();
  }
  bindEvents() {
    const { graph } = this.context;
    const { trigger } = this.options;
    graph.on(`node:${trigger}`, this.onCollapseExpand);
    graph.on(`combo:${trigger}`, this.onCollapseExpand);
  }
  unbindEvents() {
    const { graph } = this.context;
    const { trigger } = this.options;
    graph.off(`node:${trigger}`, this.onCollapseExpand);
    graph.off(`combo:${trigger}`, this.onCollapseExpand);
  }
  validate(event) {
    if (this.destroyed)
      return false;
    const { enable } = this.options;
    if (isFunction(enable))
      return enable(event);
    return !!enable;
  }
  destroy() {
    this.unbindEvents();
    super.destroy();
  }
};
CollapseExpand.defaultOptions = {
  enable: true,
  animation: true,
  trigger: CommonEvent.DBLCLICK,
  align: true
};

// node_modules/@antv/g6/esm/utils/data.js
var __rest13 = function(s2, e2) {
  var t3 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t3[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t3[p3[i2]] = s2[p3[i2]];
    }
  return t3;
};
function mergeElementsData(original, modified) {
  const { data: originalData, style: originalStyle } = original, originalAttrs = __rest13(original, ["data", "style"]);
  const { data: modifiedData, style: modifiedStyle } = modified, modifiedAttrs = __rest13(modified, ["data", "style"]);
  const result = Object.assign(Object.assign({}, originalAttrs), modifiedAttrs);
  if (originalData || modifiedData) {
    Object.assign(result, { data: Object.assign(Object.assign({}, originalData), modifiedData) });
  }
  if (originalStyle || modifiedStyle) {
    Object.assign(result, { style: Object.assign(Object.assign({}, originalStyle), modifiedStyle) });
  }
  return result;
}
function cloneElementData(data) {
  const { data: customData, style } = data, restAttrs = __rest13(data, ["data", "style"]);
  const clonedData = restAttrs;
  if (customData)
    clonedData.data = Object.assign({}, customData);
  if (style)
    clonedData.style = Object.assign({}, style);
  return clonedData;
}
function isElementDataEqual(original = {}, modified = {}) {
  const { states: originalStates = [], data: originalData = {}, style: originalStyle = {}, children: originalChildren = [] } = original, originalAttrs = __rest13(original, ["states", "data", "style", "children"]);
  const { states: modifiedStates = [], data: modifiedData = {}, style: modifiedStyle = {}, children: modifiedChildren = [] } = modified, modifiedAttrs = __rest13(modified, ["states", "data", "style", "children"]);
  const isArrayEqual = (arr1, arr2) => {
    if (arr1.length !== arr2.length)
      return false;
    return arr1.every((item, index) => item === arr2[index]);
  };
  const isObjectEqual = (obj1, obj2) => {
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    if (keys1.length !== keys2.length)
      return false;
    return keys1.every((key) => obj1[key] === obj2[key]);
  };
  if (!isObjectEqual(originalAttrs, modifiedAttrs))
    return false;
  if (!isArrayEqual(originalChildren, modifiedChildren))
    return false;
  if (!isArrayEqual(originalStates, modifiedStates))
    return false;
  if (!isObjectEqual(originalData, modifiedData))
    return false;
  if (!isObjectEqual(originalStyle, modifiedStyle))
    return false;
  return true;
}
var OVERRIDE_KEY = "__internal_override__";
function isOverridable(datum) {
  return datum[OVERRIDE_KEY] !== false;
}

// node_modules/@antv/g6/esm/behaviors/create-edge.js
var __awaiter4 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ASSIST_EDGE_ID = "g6-create-edge-assist-edge-id";
var ASSIST_NODE_ID = "g6-create-edge-assist-node-id";
var CreateEdge = class _CreateEdge extends BaseBehavior {
  constructor(context, options) {
    super(context, Object.assign({}, _CreateEdge.defaultOptions, options));
    this.drop = (event) => __awaiter4(this, void 0, void 0, function* () {
      const { targetType } = event;
      if (["combo", "node"].includes(targetType) && this.source) {
        yield this.handleCreateEdge(event);
      } else {
        yield this.cancelEdge();
      }
    });
    this.handleCreateEdge = (event) => __awaiter4(this, void 0, void 0, function* () {
      var _a, _b, _c;
      if (!this.validate(event))
        return;
      const { graph, canvas: canvas2, batch, element } = this.context;
      const { style } = this.options;
      if (this.source) {
        this.createEdge(event);
        yield this.cancelEdge();
        return;
      }
      batch.startBatch();
      canvas2.setCursor("crosshair");
      this.source = this.getSelectedNodeIDs([event.target.id])[0];
      const sourceNode = graph.getElementData(this.source);
      graph.addNodeData([
        {
          id: ASSIST_NODE_ID,
          type: "circle",
          [OVERRIDE_KEY]: false,
          style: {
            size: 1,
            visibility: "hidden",
            ports: [{ key: "port-1", placement: [0.5, 0.5] }],
            x: (_a = sourceNode.style) === null || _a === void 0 ? void 0 : _a.x,
            y: (_b = sourceNode.style) === null || _b === void 0 ? void 0 : _b.y
          }
        }
      ]);
      graph.addEdgeData([
        {
          id: ASSIST_EDGE_ID,
          source: this.source,
          target: ASSIST_NODE_ID,
          style: Object.assign({ pointerEvents: "none" }, style)
        }
      ]);
      yield (_c = element.draw({ animation: false })) === null || _c === void 0 ? void 0 : _c.finished;
    });
    this.updateAssistEdge = (event) => __awaiter4(this, void 0, void 0, function* () {
      var _a;
      if (!this.source)
        return;
      const { model, element } = this.context;
      model.translateNodeTo(ASSIST_NODE_ID, [event.client.x, event.client.y]);
      yield (_a = element.draw({ animation: false, silence: true })) === null || _a === void 0 ? void 0 : _a.finished;
    });
    this.createEdge = (event) => {
      var _a, _b;
      const { graph } = this.context;
      const { style, onFinish, onCreate } = this.options;
      const targetId = (_a = event.target) === null || _a === void 0 ? void 0 : _a.id;
      if (targetId === void 0 || this.source === void 0)
        return;
      const target = (_b = this.getSelectedNodeIDs([event.target.id])) === null || _b === void 0 ? void 0 : _b[0];
      const id = `${this.source}-${target}-${unique_id_default()}`;
      const edgeData = onCreate({ id, source: this.source, target, style });
      if (edgeData) {
        graph.addEdgeData([edgeData]);
        onFinish(edgeData);
      }
    };
    this.cancelEdge = () => __awaiter4(this, void 0, void 0, function* () {
      var _a;
      if (!this.source)
        return;
      const { graph, element, batch } = this.context;
      graph.removeNodeData([ASSIST_NODE_ID]);
      this.source = void 0;
      yield (_a = element.draw({ animation: false })) === null || _a === void 0 ? void 0 : _a.finished;
      batch.endBatch();
    });
    this.bindEvents();
  }
  /**
   * Update options
   * @param options - The options to update
   * @internal
   */
  update(options) {
    super.update(options);
    this.bindEvents();
  }
  bindEvents() {
    const { graph } = this.context;
    const { trigger } = this.options;
    this.unbindEvents();
    if (trigger === "click") {
      graph.on(NodeEvent.CLICK, this.handleCreateEdge);
      graph.on(ComboEvent.CLICK, this.handleCreateEdge);
      graph.on(CanvasEvent2.CLICK, this.cancelEdge);
      graph.on(EdgeEvent.CLICK, this.cancelEdge);
    } else {
      graph.on(NodeEvent.DRAG_START, this.handleCreateEdge);
      graph.on(ComboEvent.DRAG_START, this.handleCreateEdge);
      graph.on(CommonEvent.POINTER_UP, this.drop);
    }
    graph.on(CommonEvent.POINTER_MOVE, this.updateAssistEdge);
  }
  getSelectedNodeIDs(currTarget) {
    return Array.from(new Set(this.context.graph.getElementDataByState("node", this.options.state).map((node) => node.id).concat(currTarget)));
  }
  validate(event) {
    if (this.destroyed)
      return false;
    const { enable } = this.options;
    if (isFunction(enable))
      return enable(event);
    return !!enable;
  }
  unbindEvents() {
    const { graph } = this.context;
    graph.off(NodeEvent.CLICK, this.handleCreateEdge);
    graph.off(ComboEvent.CLICK, this.handleCreateEdge);
    graph.off(CanvasEvent2.CLICK, this.cancelEdge);
    graph.off(EdgeEvent.CLICK, this.cancelEdge);
    graph.off(NodeEvent.DRAG_START, this.handleCreateEdge);
    graph.off(ComboEvent.DRAG_START, this.handleCreateEdge);
    graph.off(CommonEvent.POINTER_UP, this.drop);
    graph.off(CommonEvent.POINTER_MOVE, this.updateAssistEdge);
  }
  destroy() {
    this.unbindEvents();
    super.destroy();
  }
};
CreateEdge.defaultOptions = {
  animation: true,
  enable: true,
  style: {},
  trigger: "drag",
  onCreate: (data) => data,
  onFinish: () => {
  }
};

// node_modules/@antv/g6/esm/behaviors/drag-canvas.js
var __awaiter5 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DragCanvas = class _DragCanvas extends BaseBehavior {
  constructor(context, options) {
    super(context, Object.assign({}, _DragCanvas.defaultOptions, options));
    this.isDragging = false;
    this.onDragStart = (event) => {
      if (!this.validate(event))
        return;
      this.isDragging = true;
      this.context.canvas.setCursor("grabbing");
    };
    this.onDrag = (event) => {
      var _a, _b, _c, _d;
      if (!this.isDragging || PinchHandler.isPinching)
        return;
      const x4 = (_b = (_a = event.movement) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : event.dx;
      const y4 = (_d = (_c = event.movement) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : event.dy;
      if ((x4 | y4) !== 0) {
        this.translate([x4, y4], false);
      }
    };
    this.onDragEnd = () => {
      var _a, _b;
      this.isDragging = false;
      this.context.canvas.setCursor(this.defaultCursor);
      (_b = (_a = this.options).onFinish) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    this.invokeOnFinish = debounce_default(() => {
      var _a, _b;
      (_b = (_a = this.options).onFinish) === null || _b === void 0 ? void 0 : _b.call(_a);
    }, 300);
    this.shortcut = new Shortcut(context.graph);
    this.bindEvents();
    this.defaultCursor = this.context.canvas.getConfig().cursor || "default";
  }
  /**
   * <zh/> 
   *
   * <en/> Update options
   * @param options - <zh/>  | <en/> Options
   * @internal
   */
  update(options) {
    this.unbindEvents();
    super.update(options);
    this.bindEvents();
  }
  bindEvents() {
    const { trigger } = this.options;
    if (is_object_default(trigger)) {
      const { up = [], down = [], left = [], right = [] } = trigger;
      this.shortcut.bind(up, (event) => this.onTranslate([0, 1], event));
      this.shortcut.bind(down, (event) => this.onTranslate([0, -1], event));
      this.shortcut.bind(left, (event) => this.onTranslate([1, 0], event));
      this.shortcut.bind(right, (event) => this.onTranslate([-1, 0], event));
    } else {
      const { graph } = this.context;
      graph.on(CommonEvent.DRAG_START, this.onDragStart);
      graph.on(CommonEvent.DRAG, this.onDrag);
      graph.on(CommonEvent.DRAG_END, this.onDragEnd);
    }
  }
  onTranslate(value, event) {
    return __awaiter5(this, void 0, void 0, function* () {
      if (!this.validate(event))
        return;
      const { sensitivity } = this.options;
      const delta = sensitivity * -1;
      yield this.translate(multiply(value, delta), this.options.animation);
      this.invokeOnFinish();
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Translate canvas
   * @param offset - <zh/>  | <en/> Translation distance
   * @param animation - <zh/>  | <en/> Animation configuration
   * @internal
   */
  translate(offset, animation) {
    return __awaiter5(this, void 0, void 0, function* () {
      offset = this.clampByDirection(offset);
      offset = this.clampByRange(offset);
      offset = this.clampByRotation(offset);
      yield this.context.graph.translateBy(offset, animation);
    });
  }
  clampByRotation([dx, dy]) {
    const rotation = this.context.graph.getRotation();
    return rotate([dx, dy], rotation);
  }
  clampByDirection([dx, dy]) {
    const { direction } = this.options;
    if (direction === "x") {
      dy = 0;
    } else if (direction === "y") {
      dx = 0;
    }
    return [dx, dy];
  }
  clampByRange([dx, dy]) {
    const { viewport, canvas: canvas2 } = this.context;
    const [canvasWidth, canvasHeight] = canvas2.getSize();
    const [top, right, bottom, left] = parsePadding(this.options.range);
    const range = [canvasHeight * top, canvasWidth * right, canvasHeight * bottom, canvasWidth * left];
    const draggableArea = getExpandedBBox(getPointBBox(viewport.getCanvasCenter()), range);
    const nextViewportCenter = subtract(viewport.getViewportCenter(), [dx, dy, 0]);
    if (!isPointInBBox(nextViewportCenter, draggableArea)) {
      const { min: [minX, minY], max: [maxX, maxY] } = draggableArea;
      if (nextViewportCenter[0] < minX && dx > 0 || nextViewportCenter[0] > maxX && dx < 0) {
        dx = 0;
      }
      if (nextViewportCenter[1] < minY && dy > 0 || nextViewportCenter[1] > maxY && dy < 0) {
        dy = 0;
      }
    }
    return [dx, dy];
  }
  validate(event) {
    if (this.destroyed)
      return false;
    const { enable } = this.options;
    if (typeof enable === "function")
      return enable(event);
    return !!enable;
  }
  unbindEvents() {
    this.shortcut.unbindAll();
    const { graph } = this.context;
    graph.off(CommonEvent.DRAG_START, this.onDragStart);
    graph.off(CommonEvent.DRAG, this.onDrag);
    graph.off(CommonEvent.DRAG_END, this.onDragEnd);
  }
  destroy() {
    this.shortcut.destroy();
    this.unbindEvents();
    this.context.canvas.setCursor(this.defaultCursor);
    super.destroy();
  }
};
DragCanvas.defaultOptions = {
  enable: (event) => {
    if ("targetType" in event)
      return event.targetType === "canvas";
    return true;
  },
  sensitivity: 10,
  direction: "both",
  range: Infinity
};

// node_modules/@antv/g6/esm/behaviors/drag-element.js
var __awaiter6 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DragElement = class _DragElement extends BaseBehavior {
  constructor(context, options) {
    super(context, Object.assign({}, _DragElement.defaultOptions, options));
    this.enable = false;
    this.enableElements = ["node", "combo"];
    this.target = [];
    this.shadowOrigin = [0, 0];
    this.hiddenEdges = [];
    this.isDragging = false;
    this.onDrop = (event) => __awaiter6(this, void 0, void 0, function* () {
      var _a;
      if (this.options.dropEffect !== "link")
        return;
      const { model, element } = this.context;
      const modifiedParentId = event.target.id;
      this.target.forEach((id) => {
        const originalParent = model.getParentData(id, COMBO_KEY);
        if (originalParent && idOf(originalParent) === modifiedParentId) {
          model.refreshComboData(modifiedParentId);
        }
        model.setParent(id, modifiedParentId, COMBO_KEY);
      });
      yield (_a = element === null || element === void 0 ? void 0 : element.draw({ animation: true })) === null || _a === void 0 ? void 0 : _a.finished;
    });
    this.setCursor = (event) => {
      if (this.isDragging)
        return;
      const { type } = event;
      const { canvas: canvas2 } = this.context;
      const { cursor } = this.options;
      if (type === CommonEvent.POINTER_ENTER)
        canvas2.setCursor((cursor === null || cursor === void 0 ? void 0 : cursor.grab) || "grab");
      else
        canvas2.setCursor((cursor === null || cursor === void 0 ? void 0 : cursor.default) || "default");
    };
    this.shortcut = new Shortcut(context.graph);
    this.onDragStart = this.onDragStart.bind(this);
    this.onDrag = this.onDrag.bind(this);
    this.onDragEnd = this.onDragEnd.bind(this);
    this.onDrop = this.onDrop.bind(this);
    this.bindEvents();
  }
  /**
   * <zh/> 
   *
   * <en/> Update the element dragging configuration
   * @param options - <zh/>  | <en/> options
   * @internal
   */
  update(options) {
    this.unbindEvents();
    super.update(options);
    this.bindEvents();
  }
  bindEvents() {
    const { graph, canvas: canvas2 } = this.context;
    const $canvas = canvas2.getLayer().getContextService().$canvas;
    if ($canvas) {
      $canvas.addEventListener("blur", this.onDragEnd);
      $canvas.addEventListener("contextmenu", this.onDragEnd);
    }
    this.enableElements.forEach((type) => {
      graph.on(`${type}:${CommonEvent.DRAG_START}`, this.onDragStart);
      graph.on(`${type}:${CommonEvent.DRAG}`, this.onDrag);
      graph.on(`${type}:${CommonEvent.DRAG_END}`, this.onDragEnd);
      graph.on(`${type}:${CommonEvent.POINTER_ENTER}`, this.setCursor);
      graph.on(`${type}:${CommonEvent.POINTER_LEAVE}`, this.setCursor);
    });
    if (["link"].includes(this.options.dropEffect)) {
      graph.on(ComboEvent.DROP, this.onDrop);
      graph.on(CanvasEvent2.DROP, this.onDrop);
    }
  }
  /**
   * <zh/>  id 
   *
   * <en/> Get the id collection of the currently selected node
   * @param currTarget - <zh/>  id  | <en/> The id collection of the current drag target element
   * @returns <zh/>  id  | <en/> The id collection of the currently selected node
   * @internal
   */
  getSelectedNodeIDs(currTarget) {
    return Array.from(new Set(this.context.graph.getElementDataByState("node", this.options.state).map((node) => node.id).concat(currTarget)));
  }
  /**
   * Get the delta of the drag
   * @param event - drag event object
   * @returns delta
   * @internal
   */
  getDelta(event) {
    const zoom = this.context.graph.getZoom();
    return divide([event.dx, event.dy], zoom);
  }
  /**
   * <zh/> 
   *
   * <en/> Callback when dragging starts
   * @param event - <zh/>  | <en/> drag event object
   * @internal
   */
  onDragStart(event) {
    var _a;
    this.enable = this.validate(event);
    if (!this.enable)
      return;
    const { batch, canvas: canvas2, graph } = this.context;
    canvas2.setCursor(((_a = this.options.cursor) === null || _a === void 0 ? void 0 : _a.grabbing) || "grabbing");
    this.isDragging = true;
    batch.startBatch();
    const id = event.target.id;
    const states = graph.getElementState(id);
    if (states.includes(this.options.state))
      this.target = this.getSelectedNodeIDs([id]);
    else
      this.target = [id];
    this.hideEdge();
    this.context.graph.frontElement(this.target);
    if (this.options.shadow)
      this.createShadow(this.target);
  }
  /**
   * <zh/> 
   *
   * <en/> Callback when dragging
   * @param event - <zh/>  | <en/> drag event object
   * @internal
   */
  onDrag(event) {
    if (!this.enable)
      return;
    const delta = this.getDelta(event);
    if (this.options.shadow)
      this.moveShadow(delta);
    else
      this.moveElement(this.target, delta);
  }
  /**
   * <zh/> 
   *
   * <en/> Callback when dragging ends
   * @internal
   */
  onDragEnd() {
    var _a, _b, _c;
    if (!this.enable)
      return;
    this.enable = false;
    if (this.options.shadow) {
      if (!this.shadow)
        return;
      this.shadow.style.visibility = "hidden";
      const { x: x4 = 0, y: y4 = 0 } = this.shadow.attributes;
      const [dx, dy] = subtract([+x4, +y4], this.shadowOrigin);
      this.moveElement(this.target, [dx, dy]);
    }
    this.showEdges();
    (_b = (_a = this.options).onFinish) === null || _b === void 0 ? void 0 : _b.call(_a, this.target);
    const { batch, canvas: canvas2 } = this.context;
    batch.endBatch();
    canvas2.setCursor(((_c = this.options.cursor) === null || _c === void 0 ? void 0 : _c.grab) || "grab");
    this.isDragging = false;
    this.target = [];
  }
  /**
   * <zh/>  trigger 
   *
   * <en/> Is the current key consistent with the trigger configuration
   * @returns <zh/>  | <en/> Is consistent
   * @internal
   */
  isKeydown() {
    const { trigger } = this.options;
    if (!(trigger === null || trigger === void 0 ? void 0 : trigger.length))
      return true;
    return this.shortcut.match(trigger);
  }
  /**
   * <zh/> 
   *
   * <en/> Verify if the element is allowed to be dragged
   * @param event - <zh/>  | <en/> drag event object
   * @returns <zh/>  | <en/> Whether to allow dragging
   * @internal
   */
  validate(event) {
    if (this.destroyed || isToBeDestroyed(event.target) || // @ts-expect-error private property
    // combo/node
    this.context.graph.isCollapsingExpanding || !this.isKeydown())
      return false;
    const { enable } = this.options;
    if (isFunction(enable))
      return enable(event);
    return !!enable;
  }
  clampByRotation([dx, dy]) {
    const rotation = this.context.graph.getRotation();
    return rotate([dx, dy], rotation);
  }
  /**
   * <zh/> 
   *
   * <en/> Move the element
   * @param ids - <zh/>  id  | <en/> element id collection
   * @param offset <zh/>  | <en/> offset
   * @internal
   */
  moveElement(ids, offset) {
    return __awaiter6(this, void 0, void 0, function* () {
      const { graph, model } = this.context;
      const { dropEffect } = this.options;
      if (dropEffect === "move")
        ids.forEach((id) => model.refreshComboData(id));
      graph.translateElementBy(Object.fromEntries(ids.map((id) => [id, this.clampByRotation(offset)])), false);
    });
  }
  moveShadow(offset) {
    if (!this.shadow)
      return;
    const { x: x4 = 0, y: y4 = 0 } = this.shadow.attributes;
    const [dx, dy] = offset;
    this.shadow.attr({ x: +x4 + dx, y: +y4 + dy });
  }
  createShadow(target) {
    const shadowStyle = subStyleProps(this.options, "shadow");
    const bbox = getCombinedBBox(target.map((id) => this.context.element.getElement(id).getBounds()));
    const [x4, y4] = bbox.min;
    this.shadowOrigin = [x4, y4];
    const [width2, height] = getBBoxSize(bbox);
    const positionStyle = { width: width2, height, x: x4, y: y4 };
    if (this.shadow) {
      this.shadow.attr(Object.assign(Object.assign(Object.assign({}, shadowStyle), positionStyle), { visibility: "visible" }));
    } else {
      this.shadow = new Rect({
        style: Object.assign(Object.assign(Object.assign({
          // @ts-ignore $layer is not in the type definition
          $layer: "transient"
        }, shadowStyle), positionStyle), { pointerEvents: "none" })
      });
      this.context.canvas.appendChild(this.shadow);
    }
  }
  showEdges() {
    if (this.options.shadow || this.hiddenEdges.length === 0)
      return;
    this.context.graph.showElement(this.hiddenEdges);
    this.hiddenEdges = [];
  }
  /**
   * Hide the edge
   * @internal
   */
  hideEdge() {
    const { hideEdge, shadow } = this.options;
    if (hideEdge === "none" || shadow)
      return;
    const { graph } = this.context;
    if (hideEdge === "all")
      this.hiddenEdges = graph.getEdgeData().map(idOf);
    else {
      this.hiddenEdges = Array.from(new Set(this.target.map((id) => graph.getRelatedEdgesData(id, hideEdge).map(idOf)).flat()));
    }
    graph.hideElement(this.hiddenEdges);
  }
  unbindEvents() {
    const { graph, canvas: canvas2 } = this.context;
    const $canvas = canvas2.getLayer().getContextService().$canvas;
    if ($canvas) {
      $canvas.removeEventListener("blur", this.onDragEnd);
      $canvas.removeEventListener("contextmenu", this.onDragEnd);
    }
    this.enableElements.forEach((type) => {
      graph.off(`${type}:${CommonEvent.DRAG_START}`, this.onDragStart);
      graph.off(`${type}:${CommonEvent.DRAG}`, this.onDrag);
      graph.off(`${type}:${CommonEvent.DRAG_END}`, this.onDragEnd);
      graph.off(`${type}:${CommonEvent.POINTER_ENTER}`, this.setCursor);
      graph.off(`${type}:${CommonEvent.POINTER_LEAVE}`, this.setCursor);
    });
    graph.off(`combo:${CommonEvent.DROP}`, this.onDrop);
    graph.off(`canvas:${CommonEvent.DROP}`, this.onDrop);
  }
  destroy() {
    var _a;
    this.unbindEvents();
    (_a = this.shadow) === null || _a === void 0 ? void 0 : _a.destroy();
    super.destroy();
  }
};
DragElement.defaultOptions = {
  animation: true,
  enable: (event) => ["node", "combo"].includes(event.targetType),
  trigger: [],
  dropEffect: "move",
  state: "selected",
  hideEdge: "none",
  shadow: false,
  shadowZIndex: 100,
  shadowFill: "#F3F9FF",
  shadowFillOpacity: 0.5,
  shadowStroke: "#1890FF",
  shadowStrokeOpacity: 0.9,
  shadowLineDash: [5, 5],
  cursor: {
    default: "default",
    grab: "grab",
    grabbing: "grabbing"
  }
};

// node_modules/@antv/graphlib/esm/utils/traverse.js
function doBFS(queue, visited, fn, navigator2) {
  while (queue.length) {
    const node = queue.shift();
    const abort = fn(node);
    if (abort) {
      return true;
    }
    visited.add(node.id);
    navigator2(node.id).forEach((n2) => {
      if (!visited.has(n2.id)) {
        visited.add(n2.id);
        queue.push(n2);
      }
    });
  }
  return false;
}
function doDFS(node, visited, fn, navigator2) {
  const abort = fn(node);
  if (abort) {
    return true;
  }
  visited.add(node.id);
  for (const n2 of navigator2(node.id)) {
    if (!visited.has(n2.id)) {
      if (doDFS(n2, visited, fn, navigator2)) {
        return true;
      }
    }
  }
  return false;
}

// node_modules/@antv/graphlib/esm/graphView.js
var defaultFilter = () => true;
var GraphView = class {
  constructor(options) {
    __publicField(this, "graph");
    __publicField(this, "nodeFilter");
    __publicField(this, "edgeFilter");
    // caches
    __publicField(this, "cacheEnabled");
    __publicField(this, "inEdgesMap", /* @__PURE__ */ new Map());
    __publicField(this, "outEdgesMap", /* @__PURE__ */ new Map());
    __publicField(this, "bothEdgesMap", /* @__PURE__ */ new Map());
    __publicField(this, "allNodesMap", /* @__PURE__ */ new Map());
    __publicField(this, "allEdgesMap", /* @__PURE__ */ new Map());
    /**
     * Clear all cache data. Therefore `getAllNodes()` will return `[]`.
     * If you want to disable caching, use `graphView.cacheEnabled = false` instead.
     */
    __publicField(this, "clearCache", () => {
      this.inEdgesMap.clear();
      this.outEdgesMap.clear();
      this.bothEdgesMap.clear();
      this.allNodesMap.clear();
      this.allEdgesMap.clear();
    });
    /**
     * Fully refresh all cache data to the current graph state.
     */
    __publicField(this, "refreshCache", () => {
      this.clearCache();
      this.updateCache(this.graph.getAllNodes().map((node) => node.id));
    });
    /**
     * Instead of a fully refreshment, this method partially update the cache data by specifying
     * involved(added, removed, updated) nodes. It's more efficient when handling small changes
     * on a large graph.
     */
    __publicField(this, "updateCache", (involvedNodeIds) => {
      const involvedEdgeIds = /* @__PURE__ */ new Set();
      involvedNodeIds.forEach((id) => {
        const oldEdgesSet = this.bothEdgesMap.get(id);
        if (oldEdgesSet) {
          oldEdgesSet.forEach((edge) => involvedEdgeIds.add(edge.id));
        }
        if (!this.hasNode(id)) {
          this.inEdgesMap.delete(id);
          this.outEdgesMap.delete(id);
          this.bothEdgesMap.delete(id);
          this.allNodesMap.delete(id);
        } else {
          const inEdges = this.graph.getRelatedEdges(id, "in").filter(this.edgeFilter);
          const outEdges = this.graph.getRelatedEdges(id, "out").filter(this.edgeFilter);
          const bothEdges = Array.from(/* @__PURE__ */ new Set([...inEdges, ...outEdges]));
          bothEdges.forEach((edge) => involvedEdgeIds.add(edge.id));
          this.inEdgesMap.set(id, inEdges);
          this.outEdgesMap.set(id, outEdges);
          this.bothEdgesMap.set(id, bothEdges);
          this.allNodesMap.set(id, this.graph.getNode(id));
        }
      });
      involvedEdgeIds.forEach((id) => {
        if (this.hasEdge(id)) {
          this.allEdgesMap.set(id, this.graph.getEdge(id));
        } else {
          this.allEdgesMap.delete(id);
        }
      });
    });
    __publicField(this, "handleGraphChanged", (event) => {
      const involvedNodeIds = /* @__PURE__ */ new Set();
      event.changes.forEach((change) => {
        switch (change.type) {
          case "NodeAdded":
            involvedNodeIds.add(change.value.id);
            break;
          case "NodeDataUpdated":
            involvedNodeIds.add(change.id);
            break;
          case "EdgeAdded":
            involvedNodeIds.add(change.value.source);
            involvedNodeIds.add(change.value.target);
            break;
          case "EdgeUpdated":
            if (change.propertyName === "source" || change.propertyName === "target") {
              involvedNodeIds.add(change.oldValue);
              involvedNodeIds.add(change.newValue);
            }
            break;
          case "EdgeDataUpdated":
            if (event.graph.hasEdge(change.id)) {
              const edge = event.graph.getEdge(change.id);
              involvedNodeIds.add(edge.source);
              involvedNodeIds.add(edge.target);
            }
            break;
          case "EdgeRemoved":
            involvedNodeIds.add(change.value.source);
            involvedNodeIds.add(change.value.target);
            break;
          case "NodeRemoved":
            involvedNodeIds.add(change.value.id);
            break;
          default:
            break;
        }
      });
      this.updateCache(involvedNodeIds);
    });
    this.graph = options.graph;
    const nodeFilter = options.nodeFilter || defaultFilter;
    const edgeFilter = options.edgeFilter || defaultFilter;
    this.nodeFilter = nodeFilter;
    this.edgeFilter = (edge) => {
      const { source, target } = this.graph.getEdgeDetail(edge.id);
      if (!nodeFilter(source) || !nodeFilter(target)) {
        return false;
      }
      return edgeFilter(edge, source, target);
    };
    if (options.cache === "auto") {
      this.cacheEnabled = true;
      this.startAutoCache();
    } else if (options.cache === "manual") {
      this.cacheEnabled = true;
    } else {
      this.cacheEnabled = false;
    }
  }
  startAutoCache() {
    this.refreshCache();
    this.graph.on("changed", this.handleGraphChanged);
  }
  stopAutoCache() {
    this.graph.off("changed", this.handleGraphChanged);
  }
  // ================= Node =================
  checkNodeExistence(id) {
    this.getNode(id);
  }
  hasNode(id) {
    if (!this.graph.hasNode(id))
      return false;
    const node = this.graph.getNode(id);
    return this.nodeFilter(node);
  }
  areNeighbors(firstNodeId, secondNodeId) {
    this.checkNodeExistence(firstNodeId);
    return this.getNeighbors(secondNodeId).some((neighbor) => neighbor.id === firstNodeId);
  }
  getNode(id) {
    const node = this.graph.getNode(id);
    if (!this.nodeFilter(node)) {
      throw new Error("Node not found for id: " + id);
    }
    return node;
  }
  getRelatedEdges(id, direction) {
    this.checkNodeExistence(id);
    if (this.cacheEnabled) {
      if (direction === "in") {
        return this.inEdgesMap.get(id);
      } else if (direction === "out") {
        return this.outEdgesMap.get(id);
      } else {
        return this.bothEdgesMap.get(id);
      }
    }
    const edges = this.graph.getRelatedEdges(id, direction);
    return edges.filter(this.edgeFilter);
  }
  getDegree(id, direction) {
    return this.getRelatedEdges(id, direction).length;
  }
  getSuccessors(id) {
    const outEdges = this.getRelatedEdges(id, "out");
    const targets = outEdges.map((edge) => this.getNode(edge.target));
    return Array.from(new Set(targets));
  }
  getPredecessors(id) {
    const inEdges = this.getRelatedEdges(id, "in");
    const sources = inEdges.map((edge) => this.getNode(edge.source));
    return Array.from(new Set(sources));
  }
  getNeighbors(id) {
    const predecessors = this.getPredecessors(id);
    const successors = this.getSuccessors(id);
    return Array.from(/* @__PURE__ */ new Set([...predecessors, ...successors]));
  }
  // ================= Edge =================
  hasEdge(id) {
    if (!this.graph.hasEdge(id))
      return false;
    const edge = this.graph.getEdge(id);
    return this.edgeFilter(edge);
  }
  getEdge(id) {
    const edge = this.graph.getEdge(id);
    if (!this.edgeFilter(edge)) {
      throw new Error("Edge not found for id: " + id);
    }
    return edge;
  }
  getEdgeDetail(id) {
    const edge = this.getEdge(id);
    return {
      edge,
      source: this.getNode(edge.source),
      target: this.getNode(edge.target)
    };
  }
  // ================= Tree =================
  hasTreeStructure(treeKey) {
    return this.graph.hasTreeStructure(treeKey);
  }
  getRoots(treeKey) {
    return this.graph.getRoots(treeKey).filter(this.nodeFilter);
  }
  getChildren(id, treeKey) {
    this.checkNodeExistence(id);
    return this.graph.getChildren(id, treeKey).filter(this.nodeFilter);
  }
  getParent(id, treeKey) {
    this.checkNodeExistence(id);
    const parent = this.graph.getParent(id, treeKey);
    if (!parent || !this.nodeFilter(parent))
      return null;
    return parent;
  }
  // ================= Graph =================
  getAllNodes() {
    if (this.cacheEnabled) {
      return Array.from(this.allNodesMap.values());
    }
    return this.graph.getAllNodes().filter(this.nodeFilter);
  }
  getAllEdges() {
    if (this.cacheEnabled) {
      return Array.from(this.allEdgesMap.values());
    }
    return this.graph.getAllEdges().filter(this.edgeFilter);
  }
  bfs(id, fn, direction = "out") {
    const navigator2 = {
      in: this.getPredecessors.bind(this),
      out: this.getSuccessors.bind(this),
      both: this.getNeighbors.bind(this)
    }[direction];
    doBFS([this.getNode(id)], /* @__PURE__ */ new Set(), fn, navigator2);
  }
  dfs(id, fn, direction = "out") {
    const navigator2 = {
      in: this.getPredecessors.bind(this),
      out: this.getSuccessors.bind(this),
      both: this.getNeighbors.bind(this)
    }[direction];
    doDFS(this.getNode(id), /* @__PURE__ */ new Set(), fn, navigator2);
  }
};

// node_modules/@antv/graphlib/esm/graph.js
var Graph2 = class _Graph extends esm_default {
  /**
   * Create a new Graph instance.
   * @param options - The options to initialize a graph. See {@link GraphOptions}.
   *
   * ```ts
   * const graph = new Graph({
   *   // Optional, initial nodes.
   *   nodes: [
   *     // Each node has a unique ID.
   *     { id: 'A', foo: 1 },
   *     { id: 'B', foo: 1 },
   *   ],
   *   // Optional, initial edges.
   *   edges: [
   *     { id: 'C', source: 'B', target: 'B', weight: 1 },
   *   ],
   *   // Optional, called with a GraphChangedEvent.
   *   onChanged: (event) => {
   *     console.log(event);
   *   }
   * });
   * ```
   */
  constructor(options) {
    super();
    __publicField(this, "nodeMap", /* @__PURE__ */ new Map());
    __publicField(this, "edgeMap", /* @__PURE__ */ new Map());
    __publicField(this, "inEdgesMap", /* @__PURE__ */ new Map());
    __publicField(this, "outEdgesMap", /* @__PURE__ */ new Map());
    __publicField(this, "bothEdgesMap", /* @__PURE__ */ new Map());
    __publicField(this, "treeIndices", /* @__PURE__ */ new Map());
    __publicField(this, "changes", []);
    __publicField(this, "batchCount", 0);
    /**
     * This function is called with a {@link GraphChangedEvent} each time a graph change happened.
     *
     * `event.changes` contains all the graph changes in order since last `onChanged`.
     */
    __publicField(this, "onChanged", () => {
    });
    /**
     * Batch several graph changes into one.
     *
     * Make several changes, but dispatch only one ChangedEvent at the end of batch:
     * ```ts
     * graph.batch(() => {
     *   graph.addNodes([]);
     *   graph.addEdges([]);
     * });
     * ```
     *
     * Batches can be nested. Only the outermost batch will dispatch a ChangedEvent:
     * ```ts
     * graph.batch(() => {
     *   graph.addNodes([]);
     *   graph.batch(() => {
     *     graph.addEdges([]);
     *   });
     * });
     * ```
     */
    __publicField(this, "batch", (fn) => {
      this.batchCount += 1;
      fn();
      this.batchCount -= 1;
      if (!this.batchCount) {
        this.commit();
      }
    });
    if (!options)
      return;
    if (options.nodes)
      this.addNodes(options.nodes);
    if (options.edges)
      this.addEdges(options.edges);
    if (options.tree)
      this.addTree(options.tree);
    if (options.onChanged)
      this.onChanged = options.onChanged;
  }
  /**
   * Reset changes and dispatch a ChangedEvent.
   */
  commit() {
    const changes = this.changes;
    this.changes = [];
    const event = {
      graph: this,
      changes
    };
    this.emit("changed", event);
    this.onChanged(event);
  }
  /**
   * Reduce the number of ordered graph changes by dropping or merging unnecessary changes.
   *
   * For example, if we update a node and remove it in a batch:
   *
   * ```ts
   * graph.batch(() => {
   *   graph.updateNodeData('A', 'foo', 2);
   *   graph.removeNode('A');
   * });
   * ```
   *
   * We get 2 atomic graph changes like
   *
   * ```ts
   * [
   *   { type: 'NodeDataUpdated', id: 'A', propertyName: 'foo', oldValue: 1, newValue: 2 },
   *   { type: 'NodeRemoved', value: { id: 'A', data: { foo: 2 } },
   * ]
   * ```
   *
   * Since node 'A' has been removed, we actually have no need to handle with NodeDataUpdated change.
   *
   * `reduceChanges()` here helps us remove such changes.
   */
  reduceChanges(changes) {
    let mergedChanges = [];
    changes.forEach((change) => {
      switch (change.type) {
        case "NodeRemoved": {
          let isNewlyAdded = false;
          mergedChanges = mergedChanges.filter((pastChange) => {
            if (pastChange.type === "NodeAdded") {
              const sameId = pastChange.value.id === change.value.id;
              if (sameId) {
                isNewlyAdded = true;
              }
              return !sameId;
            } else if (pastChange.type === "NodeDataUpdated") {
              return pastChange.id !== change.value.id;
            } else if (pastChange.type === "TreeStructureChanged") {
              return pastChange.nodeId !== change.value.id;
            }
            return true;
          });
          if (!isNewlyAdded) {
            mergedChanges.push(change);
          }
          break;
        }
        case "EdgeRemoved": {
          let isNewlyAdded = false;
          mergedChanges = mergedChanges.filter((pastChange) => {
            if (pastChange.type === "EdgeAdded") {
              const sameId = pastChange.value.id === change.value.id;
              if (sameId) {
                isNewlyAdded = true;
              }
              return !sameId;
            } else if (pastChange.type === "EdgeDataUpdated" || pastChange.type === "EdgeUpdated") {
              return pastChange.id !== change.value.id;
            }
            return true;
          });
          if (!isNewlyAdded) {
            mergedChanges.push(change);
          }
          break;
        }
        case "NodeDataUpdated":
        case "EdgeDataUpdated":
        case "EdgeUpdated": {
          const index = mergedChanges.findIndex((pastChange) => {
            return pastChange.type === change.type && pastChange.id === change.id && (change.propertyName === void 0 || pastChange.propertyName === change.propertyName);
          });
          const existingChange = mergedChanges[index];
          if (existingChange) {
            if (change.propertyName !== void 0) {
              existingChange.newValue = change.newValue;
            } else {
              mergedChanges.splice(index, 1);
              mergedChanges.push(change);
            }
          } else {
            mergedChanges.push(change);
          }
          break;
        }
        case "TreeStructureDetached": {
          mergedChanges = mergedChanges.filter((pastChange) => {
            if (pastChange.type === "TreeStructureAttached") {
              return pastChange.treeKey !== change.treeKey;
            } else if (pastChange.type === "TreeStructureChanged") {
              return pastChange.treeKey !== change.treeKey;
            }
            return true;
          });
          mergedChanges.push(change);
          break;
        }
        case "TreeStructureChanged": {
          const existingChange = mergedChanges.find((pastChange) => {
            return pastChange.type === "TreeStructureChanged" && pastChange.treeKey === change.treeKey && pastChange.nodeId === change.nodeId;
          });
          if (existingChange) {
            existingChange.newParentId = change.newParentId;
          } else {
            mergedChanges.push(change);
          }
          break;
        }
        default:
          mergedChanges.push(change);
          break;
      }
    });
    return mergedChanges;
  }
  // ================= Node =================
  checkNodeExistence(id) {
    this.getNode(id);
  }
  /**
   * Check if a node exists in the graph.
   * @group NodeMethods
   */
  hasNode(id) {
    return this.nodeMap.has(id);
  }
  /**
   * Tell if two nodes are neighbors.
   * @group NodeMethods
   */
  areNeighbors(firstNodeId, secondNodeId) {
    return this.getNeighbors(secondNodeId).some((neighbor) => neighbor.id === firstNodeId);
  }
  /**
   * Get the node data with given ID.
   * @group NodeMethods
   */
  getNode(id) {
    const node = this.nodeMap.get(id);
    if (!node) {
      throw new Error("Node not found for id: " + id);
    }
    return node;
  }
  /**
   * Given a node ID, find all edges of the node.
   * @param id - ID of the node
   * @param direction - Edge direction, defaults to 'both'.
   * @group NodeMethods
   */
  getRelatedEdges(id, direction) {
    this.checkNodeExistence(id);
    if (direction === "in") {
      const inEdges = this.inEdgesMap.get(id);
      return Array.from(inEdges);
    } else if (direction === "out") {
      const outEdges = this.outEdgesMap.get(id);
      return Array.from(outEdges);
    } else {
      const bothEdges = this.bothEdgesMap.get(id);
      return Array.from(bothEdges);
    }
  }
  /**
   * Get the degree of the given node.
   * @group NodeMethods
   */
  getDegree(id, direction) {
    return this.getRelatedEdges(id, direction).length;
  }
  /**
   * Get all successors of the given node.
   */
  getSuccessors(id) {
    const outEdges = this.getRelatedEdges(id, "out");
    const targets = outEdges.map((edge) => this.getNode(edge.target));
    return Array.from(new Set(targets));
  }
  /**
   * Get all predecessors of the given node.
   */
  getPredecessors(id) {
    const inEdges = this.getRelatedEdges(id, "in");
    const sources = inEdges.map((edge) => this.getNode(edge.source));
    return Array.from(new Set(sources));
  }
  /**
   * Given a node ID, find its neighbors.
   * @param id - ID of the node
   * @group NodeMethods
   */
  getNeighbors(id) {
    const predecessors = this.getPredecessors(id);
    const successors = this.getSuccessors(id);
    return Array.from(/* @__PURE__ */ new Set([...predecessors, ...successors]));
  }
  doAddNode(node) {
    if (this.hasNode(node.id)) {
      throw new Error("Node already exists: " + node.id);
    }
    this.nodeMap.set(node.id, node);
    this.inEdgesMap.set(node.id, /* @__PURE__ */ new Set());
    this.outEdgesMap.set(node.id, /* @__PURE__ */ new Set());
    this.bothEdgesMap.set(node.id, /* @__PURE__ */ new Set());
    this.treeIndices.forEach((tree) => {
      tree.childrenMap.set(node.id, /* @__PURE__ */ new Set());
    });
    this.changes.push({ type: "NodeAdded", value: node });
  }
  /**
   * Add all nodes of the given array, or iterable, into the graph.
   * @group NodeMethods
   */
  addNodes(nodes) {
    this.batch(() => {
      for (const node of nodes) {
        this.doAddNode(node);
      }
    });
  }
  /**
   * Add a single node into the graph.
   * @group NodeMethods
   */
  addNode(node) {
    this.addNodes([node]);
  }
  doRemoveNode(id) {
    const node = this.getNode(id);
    const bothEdges = this.bothEdgesMap.get(id);
    bothEdges == null ? void 0 : bothEdges.forEach((edge) => this.doRemoveEdge(edge.id));
    this.nodeMap.delete(id);
    this.treeIndices.forEach((tree) => {
      var _a, _b;
      (_a = tree.childrenMap.get(id)) == null ? void 0 : _a.forEach((child) => {
        tree.parentMap.delete(child.id);
      });
      const parent = tree.parentMap.get(id);
      if (parent)
        (_b = tree.childrenMap.get(parent.id)) == null ? void 0 : _b.delete(node);
      tree.parentMap.delete(id);
      tree.childrenMap.delete(id);
    });
    this.bothEdgesMap.delete(id);
    this.inEdgesMap.delete(id);
    this.outEdgesMap.delete(id);
    this.changes.push({ type: "NodeRemoved", value: node });
  }
  /**
   * Remove nodes and their attached edges from the graph.
   * @group NodeMethods
   */
  removeNodes(idList) {
    this.batch(() => {
      idList.forEach((id) => this.doRemoveNode(id));
    });
  }
  /**
   * Remove a single node and its attached edges from the graph.
   * @group NodeMethods
   */
  removeNode(id) {
    this.removeNodes([id]);
  }
  updateNodeDataProperty(id, propertyName, value) {
    const node = this.getNode(id);
    this.batch(() => {
      const oldValue = node.data[propertyName];
      const newValue = value;
      node.data[propertyName] = newValue;
      this.changes.push({
        type: "NodeDataUpdated",
        id,
        propertyName,
        oldValue,
        newValue
      });
    });
  }
  /**
   * Like Object.assign, merge all properties of `path` to the node data.
   * @param id Node ID.
   * @param patch A data object to merge.
   */
  mergeNodeData(id, patch) {
    this.batch(() => {
      Object.entries(patch).forEach(([propertyName, value]) => {
        this.updateNodeDataProperty(id, propertyName, value);
      });
    });
  }
  updateNodeData(...args) {
    const id = args[0];
    const node = this.getNode(id);
    if (typeof args[1] === "string") {
      this.updateNodeDataProperty(id, args[1], args[2]);
      return;
    }
    let data;
    if (typeof args[1] === "function") {
      const update = args[1];
      data = update(node.data);
    } else if (typeof args[1] === "object") {
      data = args[1];
    }
    this.batch(() => {
      const oldValue = node.data;
      const newValue = data;
      node.data = data;
      this.changes.push({
        type: "NodeDataUpdated",
        id,
        oldValue,
        newValue
      });
    });
  }
  // ================= Edge =================
  checkEdgeExistence(id) {
    if (!this.hasEdge(id)) {
      throw new Error("Edge not found for id: " + id);
    }
  }
  /**
   * Check if an edge exists in the graph.
   * @group NodeMethods
   */
  hasEdge(id) {
    return this.edgeMap.has(id);
  }
  /**
   * Get the edge data with given ID.
   * @group EdgeMethods
   */
  getEdge(id) {
    this.checkEdgeExistence(id);
    return this.edgeMap.get(id);
  }
  /**
   * Get the edge, the source node, and the target node by an edge ID.
   * @group EdgeMethods
   */
  getEdgeDetail(id) {
    const edge = this.getEdge(id);
    return {
      edge,
      source: this.getNode(edge.source),
      target: this.getNode(edge.target)
    };
  }
  doAddEdge(edge) {
    if (this.hasEdge(edge.id)) {
      throw new Error("Edge already exists: " + edge.id);
    }
    this.checkNodeExistence(edge.source);
    this.checkNodeExistence(edge.target);
    this.edgeMap.set(edge.id, edge);
    const inEdges = this.inEdgesMap.get(edge.target);
    const outEdges = this.outEdgesMap.get(edge.source);
    const bothEdgesOfSource = this.bothEdgesMap.get(edge.source);
    const bothEdgesOfTarget = this.bothEdgesMap.get(edge.target);
    inEdges.add(edge);
    outEdges.add(edge);
    bothEdgesOfSource.add(edge);
    bothEdgesOfTarget.add(edge);
    this.changes.push({ type: "EdgeAdded", value: edge });
  }
  /**
   * Add all edges of the given iterable(an array, a set, etc.) into the graph.
   * @group EdgeMethods
   */
  addEdges(edges) {
    this.batch(() => {
      for (const edge of edges) {
        this.doAddEdge(edge);
      }
    });
  }
  /**
   * Add a single edge pointing from `source` to `target` into the graph.
   *
   * ```ts
   * graph.addNode({ id: 'NodeA' });
   * graph.addNode({ id: 'NodeB' });
   * graph.addEdge({ id: 'EdgeA', source: 'NodeA', target: 'NodeB' });
   * ```
   *
   * If `source` or `target` were not found in the current graph, it throws an Error.
   * @group EdgeMethods
   */
  addEdge(edge) {
    this.addEdges([edge]);
  }
  doRemoveEdge(id) {
    const edge = this.getEdge(id);
    const outEdges = this.outEdgesMap.get(edge.source);
    const inEdges = this.inEdgesMap.get(edge.target);
    const bothEdgesOfSource = this.bothEdgesMap.get(edge.source);
    const bothEdgesOfTarget = this.bothEdgesMap.get(edge.target);
    outEdges.delete(edge);
    inEdges.delete(edge);
    bothEdgesOfSource.delete(edge);
    bothEdgesOfTarget.delete(edge);
    this.edgeMap.delete(id);
    this.changes.push({ type: "EdgeRemoved", value: edge });
  }
  /**
   * Remove edges whose id was included in the given id list.
   * @group EdgeMethods
   */
  removeEdges(idList) {
    this.batch(() => {
      idList.forEach((id) => this.doRemoveEdge(id));
    });
  }
  /**
   * Remove a single edge of the given id.
   * @group EdgeMethods
   */
  removeEdge(id) {
    this.removeEdges([id]);
  }
  /**
   * Change the source of an edge. The source must be found in current graph.
   * @group EdgeMethods
   */
  updateEdgeSource(id, source) {
    const edge = this.getEdge(id);
    this.checkNodeExistence(source);
    const oldSource = edge.source;
    const newSource = source;
    this.outEdgesMap.get(oldSource).delete(edge);
    this.bothEdgesMap.get(oldSource).delete(edge);
    this.outEdgesMap.get(newSource).add(edge);
    this.bothEdgesMap.get(newSource).add(edge);
    edge.source = source;
    this.batch(() => {
      this.changes.push({
        type: "EdgeUpdated",
        id,
        propertyName: "source",
        oldValue: oldSource,
        newValue: newSource
      });
    });
  }
  /**
   * Change the target of an edge. The target must be found in current graph.
   * @group EdgeMethods
   */
  updateEdgeTarget(id, target) {
    const edge = this.getEdge(id);
    this.checkNodeExistence(target);
    const oldTarget = edge.target;
    const newTarget = target;
    this.inEdgesMap.get(oldTarget).delete(edge);
    this.bothEdgesMap.get(oldTarget).delete(edge);
    this.inEdgesMap.get(newTarget).add(edge);
    this.bothEdgesMap.get(newTarget).add(edge);
    edge.target = target;
    this.batch(() => {
      this.changes.push({
        type: "EdgeUpdated",
        id,
        propertyName: "target",
        oldValue: oldTarget,
        newValue: newTarget
      });
    });
  }
  updateEdgeDataProperty(id, propertyName, value) {
    const edge = this.getEdge(id);
    this.batch(() => {
      const oldValue = edge.data[propertyName];
      const newValue = value;
      edge.data[propertyName] = newValue;
      this.changes.push({
        type: "EdgeDataUpdated",
        id,
        propertyName,
        oldValue,
        newValue
      });
    });
  }
  updateEdgeData(...args) {
    const id = args[0];
    const edge = this.getEdge(id);
    if (typeof args[1] === "string") {
      this.updateEdgeDataProperty(id, args[1], args[2]);
      return;
    }
    let data;
    if (typeof args[1] === "function") {
      const update = args[1];
      data = update(edge.data);
    } else if (typeof args[1] === "object") {
      data = args[1];
    }
    this.batch(() => {
      const oldValue = edge.data;
      const newValue = data;
      edge.data = data;
      this.changes.push({
        type: "EdgeDataUpdated",
        id,
        oldValue,
        newValue
      });
    });
  }
  /**
   * @group EdgeMethods
   */
  mergeEdgeData(id, patch) {
    this.batch(() => {
      Object.entries(patch).forEach(([propertyName, value]) => {
        this.updateEdgeDataProperty(id, propertyName, value);
      });
    });
  }
  // ================= Tree =================
  checkTreeExistence(treeKey) {
    if (!this.hasTreeStructure(treeKey)) {
      throw new Error("Tree structure not found for treeKey: " + treeKey);
    }
  }
  hasTreeStructure(treeKey) {
    return this.treeIndices.has(treeKey);
  }
  /**
   * Attach a new tree structure representing the hierarchy of all nodes in the graph.
   * @param treeKey A unique key of the tree structure. You can attach multiple tree structures with different keys.
   *
   * ```ts
   * const graph = new Graph({
   *   nodes: [{ id: 1 }, { id: 2 }, { id: 3 }],
   * });
   * graph.attachTreeStructure('Inheritance');
   * graph.setParent(2, 1, 'Inheritance');
   * graph.setParent(3, 1, 'Inheritance');
   * graph.getRoots('Inheritance'); // [1]
   * graph.getChildren(1, 'Inheritance'); // [2,3]
   * ```
   * @group TreeMethods
   */
  attachTreeStructure(treeKey) {
    if (this.treeIndices.has(treeKey)) {
      return;
    }
    this.treeIndices.set(treeKey, {
      parentMap: /* @__PURE__ */ new Map(),
      childrenMap: /* @__PURE__ */ new Map()
    });
    this.batch(() => {
      this.changes.push({
        type: "TreeStructureAttached",
        treeKey
      });
    });
  }
  /**
   * Detach the tree structure of the given tree key from the graph.
   *
   * ```ts
   * graph.detachTreeStructure('Inheritance');
   * graph.getRoots('Inheritance'); // Error!
   * ```
   * @group TreeMethods
   */
  detachTreeStructure(treeKey) {
    this.checkTreeExistence(treeKey);
    this.treeIndices.delete(treeKey);
    this.batch(() => {
      this.changes.push({
        type: "TreeStructureDetached",
        treeKey
      });
    });
  }
  /**
   * Traverse the given tree data, add each node into the graph, then attach the tree structure.
   *
   * ```ts
   * graph.addTree({
   *   id: 1,
   *   children: [
   *     { id: 2 },
   *     { id: 3 },
   *   ],
   * }, 'Inheritance');
   * graph.getRoots('Inheritance'); // [1]
   * graph.getChildren(1, 'Inheritance'); // [2, 3]
   * graph.getAllNodes(); // [1, 2, 3]
   * graph.getAllEdges(); // []
   * ```
   * @group TreeMethods
   */
  addTree(tree, treeKey) {
    this.batch(() => {
      this.attachTreeStructure(treeKey);
      const nodes = [];
      const stack = Array.isArray(tree) ? tree : [tree];
      while (stack.length) {
        const node = stack.shift();
        nodes.push(node);
        if (node.children) {
          stack.push(...node.children);
        }
      }
      this.addNodes(nodes);
      nodes.forEach((parent) => {
        var _a;
        (_a = parent.children) == null ? void 0 : _a.forEach((child) => {
          this.setParent(child.id, parent.id, treeKey);
        });
      });
    });
  }
  /**
   * Get the root nodes of an attached tree structure.
   *
   * Consider a graph with the following tree structure attached:
   * ```
   * Tree structure:
   *    O     3
   *   / \    |
   *  1   2   4
   * ```
   * `graph.getRoots()` takes all nodes without a parent, therefore [0, 3] was returned.
   *
   * Newly added nodes are also unparented. So they are counted as roots.
   * ```ts
   * graph.addNode({ id: 5 });
   * graph.getRoots(); // [0, 3, 5]
   * ```
   *
   * Here is how the tree structure looks like:
   * ```
   * Tree structure:
   *    O     3  5
   *   / \    |
   *  1   2   4
   * ```
   *
   * By setting a parent, a root node no more be a root.
   * ```ts
   * graph.setParent(5, 2);
   * graph.getRoots(); // [0, 3]
   * ```
   *
   * The tree structure now becomes:
   * ```
   * Tree structure:
   *    O     3
   *   / \    |
   *  1   2   4
   *      |
   *      5
   * ```
   *
   * Removing a node forces its children to be unparented, or roots.
   * ```ts
   * graph.removeNode(0);
   * graph.getRoots(); // [1, 2, 3]
   * ```
   *
   * You might draw the the structure as follow:
   * ```
   * Tree structure:
   *  1   2  3
   *      |  |
   *      5  4
   * ```
   * @group TreeMethods
   */
  getRoots(treeKey) {
    this.checkTreeExistence(treeKey);
    return this.getAllNodes().filter((node) => !this.getParent(node.id, treeKey));
  }
  /**
   * Given a node ID and an optional tree key, get the children of the node in the specified tree structure.
   * @group TreeMethods
   */
  getChildren(id, treeKey) {
    this.checkNodeExistence(id);
    this.checkTreeExistence(treeKey);
    const tree = this.treeIndices.get(treeKey);
    const children = tree.childrenMap.get(id);
    return Array.from(children || []);
  }
  /**
   * Given a node ID and an optional tree key, get the parent of the node in the specified tree structure.
   * If the given node is one of the tree roots, this returns null.
   * @group TreeMethods
   */
  getParent(id, treeKey) {
    this.checkNodeExistence(id);
    this.checkTreeExistence(treeKey);
    const tree = this.treeIndices.get(treeKey);
    return tree.parentMap.get(id) || null;
  }
  /**
   * Returns an array of all the ancestor nodes, staring from the parent to the root.
   */
  getAncestors(id, treeKey) {
    const ancestors = [];
    let current2 = this.getNode(id);
    let parent;
    while (parent = this.getParent(current2.id, treeKey)) {
      ancestors.push(parent);
      current2 = parent;
    }
    return ancestors;
  }
  /**
   * Set node parent. If this operation causes a circle, it fails with an error.
   * @param id - ID of the child node.
   * @param parent - ID of the parent node. If it is undefined or null, means unset parent for node with id.
   * @param treeKey - Which tree structure the relation is applied to.
   * @group TreeMethods
   */
  setParent(id, parent, treeKey) {
    var _a, _b;
    this.checkTreeExistence(treeKey);
    const tree = this.treeIndices.get(treeKey);
    if (!tree)
      return;
    const node = this.getNode(id);
    const oldParent = tree.parentMap.get(id);
    if ((oldParent == null ? void 0 : oldParent.id) === parent)
      return;
    if (parent === void 0 || parent === null) {
      if (oldParent) {
        (_a = tree.childrenMap.get(oldParent.id)) == null ? void 0 : _a.delete(node);
      }
      tree.parentMap.delete(id);
      return;
    }
    const newParent = this.getNode(parent);
    tree.parentMap.set(id, newParent);
    if (oldParent) {
      (_b = tree.childrenMap.get(oldParent.id)) == null ? void 0 : _b.delete(node);
    }
    let children = tree.childrenMap.get(newParent.id);
    if (!children) {
      children = /* @__PURE__ */ new Set();
      tree.childrenMap.set(newParent.id, children);
    }
    children.add(node);
    this.batch(() => {
      this.changes.push({
        type: "TreeStructureChanged",
        treeKey,
        nodeId: id,
        oldParentId: oldParent == null ? void 0 : oldParent.id,
        newParentId: newParent.id
      });
    });
  }
  dfsTree(id, fn, treeKey) {
    const navigator2 = (nodeId) => this.getChildren(nodeId, treeKey);
    return doDFS(this.getNode(id), /* @__PURE__ */ new Set(), fn, navigator2);
  }
  bfsTree(id, fn, treeKey) {
    const navigator2 = (nodeId) => this.getChildren(nodeId, treeKey);
    return doBFS([this.getNode(id)], /* @__PURE__ */ new Set(), fn, navigator2);
  }
  // ================= Graph =================
  /**
   * Get all nodes in the graph as an array.
   */
  getAllNodes() {
    return Array.from(this.nodeMap.values());
  }
  /**
   * Get all edges in the graph as an array.
   */
  getAllEdges() {
    return Array.from(this.edgeMap.values());
  }
  bfs(id, fn, direction = "out") {
    const navigator2 = {
      in: this.getPredecessors.bind(this),
      out: this.getSuccessors.bind(this),
      both: this.getNeighbors.bind(this)
    }[direction];
    return doBFS([this.getNode(id)], /* @__PURE__ */ new Set(), fn, navigator2);
  }
  dfs(id, fn, direction = "out") {
    const navigator2 = {
      in: this.getPredecessors.bind(this),
      out: this.getSuccessors.bind(this),
      both: this.getNeighbors.bind(this)
    }[direction];
    return doDFS(this.getNode(id), /* @__PURE__ */ new Set(), fn, navigator2);
  }
  clone() {
    const newNodes = this.getAllNodes().map((oldNode) => {
      return __spreadProps(__spreadValues({}, oldNode), { data: __spreadValues({}, oldNode.data) });
    });
    const newEdges = this.getAllEdges().map((oldEdge) => {
      return __spreadProps(__spreadValues({}, oldEdge), { data: __spreadValues({}, oldEdge.data) });
    });
    const newGraph = new _Graph({
      nodes: newNodes,
      edges: newEdges
    });
    this.treeIndices.forEach(({ parentMap: oldParentMap, childrenMap: oldChildrenMap }, treeKey) => {
      const parentMap = /* @__PURE__ */ new Map();
      oldParentMap.forEach((parent, key) => {
        parentMap.set(key, newGraph.getNode(parent.id));
      });
      const childrenMap = /* @__PURE__ */ new Map();
      oldChildrenMap.forEach((children, key) => {
        childrenMap.set(key, new Set(Array.from(children).map((n2) => newGraph.getNode(n2.id))));
      });
      newGraph.treeIndices.set(treeKey, {
        parentMap,
        childrenMap
      });
    });
    return newGraph;
  }
  toJSON() {
    return JSON.stringify({
      nodes: this.getAllNodes(),
      edges: this.getAllEdges()
      // FIXME: And tree structures?
    });
  }
  createView(options) {
    return new GraphView(__spreadValues({
      graph: this
    }, options));
  }
};

// node_modules/@antv/g6/esm/layouts/base-layout.js
var BaseLayout = class {
  constructor(context, options) {
    this.context = context;
    this.options = options || {};
  }
};

// node_modules/@antv/g6/esm/utils/layout.js
var __awaiter7 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest14 = function(s2, e2) {
  var t3 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t3[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t3[p3[i2]] = s2[p3[i2]];
    }
  return t3;
};
function isTreeLayout(options) {
  const { type } = options;
  return ["compact-box", "mindmap", "dendrogram", "indented"].includes(type);
}
function isPreLayout(options) {
  return !Array.isArray(options) && (options === null || options === void 0 ? void 0 : options.preLayout);
}
function layoutMapping2GraphData(layoutMapping) {
  const { nodes, edges } = layoutMapping;
  const data = { nodes: [], edges: [], combos: [] };
  nodes.forEach((nodeLike) => {
    const target = nodeLike.data._isCombo ? data.combos : data.nodes;
    const { x: x4, y: y4, z: z4 = 0 } = nodeLike.data;
    target === null || target === void 0 ? void 0 : target.push({
      id: nodeLike.id,
      style: { x: x4, y: y4, z: z4 }
    });
  });
  edges.forEach((edge) => {
    const { id, source, target, data: { points = [], controlPoints = points.slice(1, points.length - 1) } } = edge;
    data.edges.push({
      id,
      source,
      target,
      style: Object.assign({}, (controlPoints === null || controlPoints === void 0 ? void 0 : controlPoints.length) ? { controlPoints: controlPoints.map(parsePoint) } : {})
    });
  });
  return data;
}
function layoutAdapter(Ctor, context) {
  class AdaptLayout extends BaseLayout {
    constructor(context2, options) {
      super(context2, options);
      this.instance = new Ctor({});
      this.id = this.instance.id;
      if ("stop" in this.instance && "tick" in this.instance) {
        const instance = this.instance;
        this.stop = instance.stop.bind(instance);
        this.tick = (iterations) => {
          const tickResult = instance.tick(iterations);
          return layoutMapping2GraphData(tickResult);
        };
      }
    }
    execute(model, options) {
      return __awaiter7(this, void 0, void 0, function* () {
        return layoutMapping2GraphData(yield this.instance.execute(this.graphData2LayoutModel(model), this.transformOptions(deep_mix_default({}, this.options, options))));
      });
    }
    transformOptions(options) {
      if (!("onTick" in options))
        return options;
      const onTick = options.onTick;
      options.onTick = (data) => onTick(layoutMapping2GraphData(data));
      return options;
    }
    graphData2LayoutModel(data) {
      const { nodes = [], edges = [], combos = [] } = data;
      const nodesToLayout = nodes.map((datum) => {
        const id = idOf(datum);
        const { data: data2, style, combo } = datum, rest = __rest14(datum, ["data", "style", "combo"]);
        const result = {
          id,
          data: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, data2), { data: data2 }), combo ? { parentId: combo } : {}), { style }), rest)
        };
        if (style === null || style === void 0 ? void 0 : style.x)
          Object.assign(result.data, { x: style.x });
        if (style === null || style === void 0 ? void 0 : style.y)
          Object.assign(result.data, { y: style.y });
        if (style === null || style === void 0 ? void 0 : style.z)
          Object.assign(result.data, { z: style.z });
        return result;
      });
      const nodesIdMap = new Map(nodesToLayout.map((node) => [node.id, node]));
      const edgesToLayout = edges.filter((edge) => {
        const { source, target } = edge;
        return nodesIdMap.has(source) && nodesIdMap.has(target);
      }).map((edge) => {
        const { source, target, data: data2, style } = edge;
        return { id: idOf(edge), source, target, data: Object.assign({}, data2), style: Object.assign({}, style) };
      });
      const combosToLayout = combos.map((combo) => {
        return { id: idOf(combo), data: Object.assign({ _isCombo: true }, combo.data), style: Object.assign({}, combo.style) };
      });
      const layoutModel = new Graph2({
        nodes: [...nodesToLayout, ...combosToLayout],
        edges: edgesToLayout
      });
      if (context.model.model.hasTreeStructure(COMBO_KEY)) {
        layoutModel.attachTreeStructure(COMBO_KEY);
        nodesToLayout.forEach((node) => {
          const parent = context.model.model.getParent(node.id, COMBO_KEY);
          if (parent && layoutModel.hasNode(parent.id)) {
            layoutModel.setParent(node.id, parent.id, COMBO_KEY);
          }
        });
      }
      return layoutModel;
    }
  }
  return AdaptLayout;
}
function invokeLayoutMethod(layout2, method, ...args) {
  if (method in layout2) {
    return layout2[method](...args);
  }
  if ("instance" in layout2) {
    const instance = layout2.instance;
    if (method in instance)
      return instance[method](...args);
  }
  return null;
}
function getLayoutProperty(layout2, name) {
  if (name in layout2)
    return layout2[name];
  if ("instance" in layout2) {
    const instance = layout2.instance;
    if (name in instance)
      return instance[name];
  }
  return null;
}

// node_modules/@antv/g6/esm/behaviors/drag-element-force.js
var __awaiter8 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DragElementForce = class extends DragElement {
  get forceLayoutInstance() {
    return this.context.layout.getLayoutInstance().find((layout2) => ["d3-force", "d3-force-3d"].includes(layout2 === null || layout2 === void 0 ? void 0 : layout2.id));
  }
  /**
   * Whether the behavior is enabled
   * @param event - The event object
   * @returns Is the behavior enabled
   * @internal
   */
  validate(event) {
    if (!this.context.layout)
      return false;
    if (!this.forceLayoutInstance) {
      print.warn("DragElementForce only works with d3-force or d3-force-3d layout");
      return false;
    }
    return super.validate(event);
  }
  /**
   * Move selected elements by offset
   * @param ids - The selected element IDs
   * @param offset - The offset to move
   * @internal
   */
  moveElement(ids, offset) {
    return __awaiter8(this, void 0, void 0, function* () {
      const layout2 = this.forceLayoutInstance;
      this.context.graph.getNodeData(ids).forEach((element, index) => {
        const { x: x4 = 0, y: y4 = 0 } = element.style || {};
        if (layout2)
          invokeLayoutMethod(layout2, "setFixedPosition", ids[index], [...add([+x4, +y4], this.clampByRotation(offset))]);
      });
    });
  }
  /**
   * Triggered when the drag starts
   * @param event - The event object
   * @internal
   */
  onDragStart(event) {
    this.enable = this.validate(event);
    if (!this.enable)
      return;
    this.target = this.getSelectedNodeIDs([event.target.id]);
    this.hideEdge();
    this.context.graph.frontElement(this.target);
    const layout2 = this.forceLayoutInstance;
    if (layout2)
      getLayoutProperty(layout2, "simulation").alphaTarget(0.3).restart();
    this.context.graph.getNodeData(this.target).forEach((element) => {
      const { x: x4 = 0, y: y4 = 0 } = element.style || {};
      if (layout2)
        invokeLayoutMethod(layout2, "setFixedPosition", idOf(element), [+x4, +y4]);
    });
  }
  /**
   * Triggered when dragging
   * @param event - The event object
   * @internal
   */
  onDrag(event) {
    if (!this.enable)
      return;
    const delta = this.getDelta(event);
    this.moveElement(this.target, delta);
  }
  /**
   * Triggered when the drag ends
   * @internal
   */
  onDragEnd() {
    const layout2 = this.forceLayoutInstance;
    if (layout2)
      getLayoutProperty(layout2, "simulation").alphaTarget(0);
    if (this.options.fixed)
      return;
    this.context.graph.getNodeData(this.target).forEach((element) => {
      if (layout2)
        invokeLayoutMethod(layout2, "setFixedPosition", idOf(element), [null, null, null]);
    });
  }
};

// node_modules/@antv/g6/esm/behaviors/fix-element-size.js
var __awaiter9 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var FixElementSize = class _FixElementSize extends BaseBehavior {
  constructor(context, options) {
    super(context, Object.assign({}, _FixElementSize.defaultOptions, options));
    this.isZoomEvent = (event) => Boolean(event.data && "scale" in event.data);
    this.relatedEdgeToUpdate = /* @__PURE__ */ new Set();
    this.zoom = this.context.graph.getZoom();
    this.fixElementSize = (event) => __awaiter9(this, void 0, void 0, function* () {
      if (!this.validate(event))
        return;
      const { graph } = this.context;
      const { state, nodeFilter, edgeFilter, comboFilter } = this.options;
      const nodeData = (state ? graph.getElementDataByState("node", state) : graph.getNodeData()).filter(nodeFilter);
      const edgeData = (state ? graph.getElementDataByState("edge", state) : graph.getEdgeData()).filter(edgeFilter);
      const comboData = (state ? graph.getElementDataByState("combo", state) : graph.getComboData()).filter(comboFilter);
      const currentScale = this.isZoomEvent(event) ? this.zoom = Math.max(0.01, Math.min(event.data.scale, 10)) : this.zoom;
      const nodeLikeData = [...nodeData, ...comboData];
      if (nodeLikeData.length > 0) {
        nodeLikeData.forEach((datum) => this.fixNodeLike(datum, currentScale));
      }
      this.updateRelatedEdges();
      if (edgeData.length > 0) {
        edgeData.forEach((datum) => this.fixEdge(datum, currentScale));
      }
    });
    this.cachedStyles = /* @__PURE__ */ new Map();
    this.getOriginalFieldValue = (id, shape, field) => {
      var _a;
      const shapesStyle = this.cachedStyles.get(id) || [];
      const shapeStyle = ((_a = shapesStyle.find((style) => style.shape === shape)) === null || _a === void 0 ? void 0 : _a.style) || {};
      if (!(field in shapeStyle)) {
        shapeStyle[field] = shape.attributes[field];
        this.cachedStyles.set(id, [
          ...shapesStyle.filter((style) => style.shape !== shape),
          { shape, style: shapeStyle }
        ]);
      }
      return shapeStyle[field];
    };
    this.scaleEntireElement = (id, el, currentScale) => {
      el.setLocalScale(1 / currentScale);
      const shapesStyle = this.cachedStyles.get(id) || [];
      shapesStyle.push({ shape: el });
      this.cachedStyles.set(id, shapesStyle);
    };
    this.scaleSpecificShapes = (el, currentScale, config) => {
      const descendantShapes = getDescendantShapes(el);
      const configs = Array.isArray(config) ? config : [config];
      configs.forEach((config2) => {
        const { shape: shapeFilter, fields } = config2;
        const shape = typeof shapeFilter === "function" ? shapeFilter(descendantShapes) : el.getShape(shapeFilter);
        if (!shape)
          return;
        if (!fields) {
          this.scaleEntireElement(el.id, shape, currentScale);
          return;
        }
        fields.forEach((field) => {
          const oriFieldValue = this.getOriginalFieldValue(el.id, shape, field);
          if (!isNumber(oriFieldValue))
            return;
          shape.style[field] = oriFieldValue / currentScale;
        });
      });
    };
    this.skipIfExceedViewport = (el) => {
      const { viewport } = this.context;
      return !(viewport === null || viewport === void 0 ? void 0 : viewport.isInViewport(el.getRenderBounds(), false, 30));
    };
    this.fixNodeLike = (datum, currentScale) => {
      const id = idOf(datum);
      const { element, model } = this.context;
      const el = element.getElement(id);
      if (!el || this.skipIfExceedViewport(el))
        return;
      const edges = model.getRelatedEdgesData(id);
      edges.forEach((edge) => this.relatedEdgeToUpdate.add(idOf(edge)));
      const config = this.options[el.type];
      if (!config) {
        this.scaleEntireElement(id, el, currentScale);
        return;
      }
      this.scaleSpecificShapes(el, currentScale, config);
    };
    this.fixEdge = (datum, currentScale) => {
      const id = idOf(datum);
      const el = this.context.element.getElement(id);
      if (!el || this.skipIfExceedViewport(el))
        return;
      const config = this.options.edge;
      if (!config) {
        el.style.transformOrigin = "center";
        this.scaleEntireElement(id, el, currentScale);
        return;
      }
      this.scaleSpecificShapes(el, currentScale, config);
    };
    this.updateRelatedEdges = () => {
      const { element } = this.context;
      if (this.relatedEdgeToUpdate.size > 0) {
        this.relatedEdgeToUpdate.forEach((id) => {
          const edge = element.getElement(id);
          edge === null || edge === void 0 ? void 0 : edge.update({});
        });
      }
      this.relatedEdgeToUpdate.clear();
    };
    this.resetTransform = (event) => __awaiter9(this, void 0, void 0, function* () {
      var _a;
      if ((_a = event.data) === null || _a === void 0 ? void 0 : _a.firstRender)
        return;
      if (this.options.reset) {
        this.restoreCachedStyles();
      } else {
        this.fixElementSize({ data: { scale: this.zoom } });
      }
    });
    this.bindEvents();
  }
  restoreCachedStyles() {
    if (this.cachedStyles.size > 0) {
      this.cachedStyles.forEach((shapesStyle) => {
        shapesStyle.forEach(({ shape, style }) => {
          if (is_empty_default(style)) {
            shape.setLocalScale(1);
          } else {
            if (this.options.state)
              return;
            Object.entries(style).forEach(([field, value]) => shape.style[field] = value);
          }
        });
      });
      const { graph, element } = this.context;
      const nodeIds = Object.keys(Object.fromEntries(this.cachedStyles)).filter((id) => id && graph.getElementType(id) === "node");
      if (nodeIds.length > 0) {
        const edgeIds = /* @__PURE__ */ new Set();
        nodeIds.forEach((id) => {
          graph.getRelatedEdgesData(id).forEach((edge) => edgeIds.add(idOf(edge)));
        });
        edgeIds.forEach((id) => {
          const edge = element === null || element === void 0 ? void 0 : element.getElement(id);
          edge === null || edge === void 0 ? void 0 : edge.update({});
        });
      }
    }
  }
  bindEvents() {
    const { graph } = this.context;
    graph.on(GraphEvent.AFTER_DRAW, this.resetTransform);
    graph.on(GraphEvent.AFTER_TRANSFORM, this.fixElementSize);
  }
  unbindEvents() {
    const { graph } = this.context;
    graph.off(GraphEvent.AFTER_DRAW, this.resetTransform);
    graph.off(GraphEvent.AFTER_TRANSFORM, this.fixElementSize);
  }
  validate(event) {
    if (this.destroyed)
      return false;
    const { enable } = this.options;
    if (isFunction(enable))
      return enable(event);
    return !!enable;
  }
  destroy() {
    this.unbindEvents();
    super.destroy();
  }
};
FixElementSize.defaultOptions = {
  enable: (event) => event.data.scale < 1,
  nodeFilter: () => true,
  edgeFilter: () => true,
  comboFilter: () => true,
  edge: [{ shape: "key", fields: ["lineWidth"] }, { shape: "halo", fields: ["lineWidth"] }, { shape: "label" }],
  reset: false
};

// node_modules/@antv/g6/esm/behaviors/focus-element.js
var __awaiter10 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var FocusElement = class _FocusElement extends BaseBehavior {
  constructor(context, options) {
    super(context, Object.assign({}, _FocusElement.defaultOptions, options));
    this.focus = (event) => __awaiter10(this, void 0, void 0, function* () {
      if (!this.validate(event))
        return;
      const { graph } = this.context;
      yield graph.focusElement(event.target.id, this.options.animation);
    });
    this.shortcut = new Shortcut(context.graph);
    this.bindEvents();
  }
  bindEvents() {
    const { graph } = this.context;
    this.unbindEvents();
    ELEMENT_TYPES.forEach((type) => {
      graph.on(`${type}:${CommonEvent.CLICK}`, this.focus);
    });
  }
  validate(event) {
    if (this.destroyed || !this.isKeydown())
      return false;
    const { enable } = this.options;
    if (isFunction(enable))
      return enable(event);
    return !!enable;
  }
  /**
   * <zh/>  trigger 
   *
   * <en/> Is the current key consistent with the trigger configuration
   * @returns <zh/>  | <en/> Is consistent
   * @internal
   */
  isKeydown() {
    const { trigger } = this.options;
    if (!(trigger === null || trigger === void 0 ? void 0 : trigger.length))
      return true;
    return this.shortcut.match(trigger);
  }
  unbindEvents() {
    const { graph } = this.context;
    ELEMENT_TYPES.forEach((type) => {
      graph.off(`${type}:${CommonEvent.CLICK}`, this.focus);
    });
  }
  destroy() {
    this.unbindEvents();
    this.shortcut.destroy();
    super.destroy();
  }
};
FocusElement.defaultOptions = {
  animation: {
    easing: "ease-in",
    duration: 500
  },
  enable: true,
  trigger: []
};

// node_modules/@antv/g6/esm/behaviors/hover-activate.js
var HoverActivate = class _HoverActivate extends BaseBehavior {
  constructor(context, options) {
    super(context, Object.assign({}, _HoverActivate.defaultOptions, options));
    this.isFrozen = false;
    this.toggleFrozen = (e2) => {
      this.isFrozen = e2.type === "dragstart";
    };
    this.hoverElement = (event) => {
      if (!this.validate(event))
        return;
      const isEnter = event.type === CommonEvent.POINTER_ENTER;
      this.updateElementsState(event, isEnter);
      const { onHover, onHoverEnd } = this.options;
      if (isEnter)
        onHover === null || onHover === void 0 ? void 0 : onHover(event);
      else
        onHoverEnd === null || onHoverEnd === void 0 ? void 0 : onHoverEnd(event);
    };
    this.updateElementsState = (event, add4) => {
      if (!this.options.state && !this.options.inactiveState)
        return;
      const { graph } = this.context;
      const { state, animation, inactiveState } = this.options;
      const activeIds = this.getActiveIds(event);
      const states = {};
      if (state) {
        Object.assign(states, this.getElementsState(activeIds, state, add4));
      }
      if (inactiveState) {
        const inactiveIds = idsOf(graph.getData(), true).filter((id) => !activeIds.includes(id));
        Object.assign(states, this.getElementsState(inactiveIds, inactiveState, add4));
      }
      graph.setElementState(states, animation);
    };
    this.getElementsState = (ids, state, add4) => {
      const { graph } = this.context;
      const states = {};
      ids.forEach((id) => {
        const currentState = graph.getElementState(id);
        if (add4) {
          states[id] = currentState.includes(state) ? currentState : [...currentState, state];
        } else {
          states[id] = currentState.filter((s2) => s2 !== state);
        }
      });
      return states;
    };
    this.bindEvents();
  }
  bindEvents() {
    const { graph } = this.context;
    this.unbindEvents();
    ELEMENT_TYPES.forEach((type) => {
      graph.on(`${type}:${CommonEvent.POINTER_ENTER}`, this.hoverElement);
      graph.on(`${type}:${CommonEvent.POINTER_LEAVE}`, this.hoverElement);
    });
    const canvas2 = this.context.canvas.document;
    canvas2.addEventListener(`${CommonEvent.DRAG_START}`, this.toggleFrozen);
    canvas2.addEventListener(`${CommonEvent.DRAG_END}`, this.toggleFrozen);
  }
  getActiveIds(event) {
    const { graph } = this.context;
    const { degree: degree3, direction } = this.options;
    const elementId = event.target.id;
    return degree3 ? getElementNthDegreeIds(graph, event.targetType, elementId, typeof degree3 === "function" ? degree3(event) : degree3, direction) : [elementId];
  }
  validate(event) {
    if (this.destroyed || this.isFrozen || isToBeDestroyed(event.target) || // @ts-expect-error private property
    // combo/node
    this.context.graph.isCollapsingExpanding)
      return false;
    const { enable } = this.options;
    if (isFunction(enable))
      return enable(event);
    return !!enable;
  }
  unbindEvents() {
    const { graph } = this.context;
    ELEMENT_TYPES.forEach((type) => {
      graph.off(`${type}:${CommonEvent.POINTER_ENTER}`, this.hoverElement);
      graph.off(`${type}:${CommonEvent.POINTER_LEAVE}`, this.hoverElement);
    });
    const canvas2 = this.context.canvas.document;
    canvas2.removeEventListener(`${CommonEvent.DRAG_START}`, this.toggleFrozen);
    canvas2.removeEventListener(`${CommonEvent.DRAG_END}`, this.toggleFrozen);
  }
  destroy() {
    this.unbindEvents();
    super.destroy();
  }
};
HoverActivate.defaultOptions = {
  animation: false,
  enable: true,
  degree: 0,
  direction: "both",
  state: "active",
  inactiveState: void 0
};

// node_modules/@antv/g6/esm/behaviors/lasso-select.js
var LassoSelect = class extends BrushSelect {
  /**
   * Triggered when the mouse is pressed
   * @param event - mouse event
   * @internal
   */
  onPointerDown(event) {
    if (!super.validate(event) || !super.isKeydown() || this.points)
      return;
    const { canvas: canvas2, graph } = this.context;
    this.pathShape = new Path({
      id: "g6-lasso-select",
      style: this.options.style
    });
    canvas2.appendChild(this.pathShape);
    this.points = [getCursorPoint(event, graph)];
  }
  /**
   * Triggered when the mouse is moved
   * @param event - mouse event
   * @internal
   */
  onPointerMove(event) {
    var _a;
    if (!this.points)
      return;
    const { immediately, mode } = this.options;
    this.points.push(getCursorPoint(event, this.context.graph));
    (_a = this.pathShape) === null || _a === void 0 ? void 0 : _a.setAttribute("d", pointsToPath(this.points));
    if (immediately && mode === "default" && this.points.length > 2)
      super.updateElementsStates(this.points);
  }
  /**
   * Triggered when the mouse is released
   * @internal
   */
  onPointerUp() {
    if (!this.points)
      return;
    if (this.points.length < 2) {
      this.clearLasso();
      return;
    }
    super.updateElementsStates(this.points);
    this.clearLasso();
  }
  clearLasso() {
    var _a;
    (_a = this.pathShape) === null || _a === void 0 ? void 0 : _a.remove();
    this.pathShape = void 0;
    this.points = void 0;
  }
};

// node_modules/@antv/g6/esm/behaviors/optimize-viewport-transform.js
var OptimizeViewportTransform = class _OptimizeViewportTransform extends BaseBehavior {
  constructor(context, options) {
    super(context, Object.assign({}, _OptimizeViewportTransform.defaultOptions, options));
    this.hiddenShapes = [];
    this.isVisible = true;
    this.setElementsVisibility = (elements, visibility, filter) => {
      elements.filter(Boolean).forEach((element) => {
        if (visibility === "hidden" && !element.isVisible()) {
          this.hiddenShapes.push(element);
        } else if (visibility === "visible" && this.hiddenShapes.includes(element)) {
          this.hiddenShapes.splice(this.hiddenShapes.indexOf(element), 1);
        } else {
          setVisibility(element, visibility, filter);
        }
      });
    };
    this.filterShapes = (type, filter) => {
      if (isFunction(filter))
        return (shape) => !filter(type, shape);
      const includesClassnames = filter === null || filter === void 0 ? void 0 : filter[type];
      return (shape) => {
        if (!shape.className)
          return true;
        return !(includesClassnames === null || includesClassnames === void 0 ? void 0 : includesClassnames.includes(shape.className));
      };
    };
    this.hideShapes = (event) => {
      if (!this.validate(event) || !this.isVisible)
        return;
      const { element } = this.context;
      const { shapes = {} } = this.options;
      this.setElementsVisibility(element.getNodes(), "hidden", this.filterShapes("node", shapes));
      this.setElementsVisibility(element.getEdges(), "hidden", this.filterShapes("edge", shapes));
      this.setElementsVisibility(element.getCombos(), "hidden", this.filterShapes("combo", shapes));
      this.isVisible = false;
    };
    this.showShapes = debounce_default((event) => {
      if (!this.validate(event) || this.isVisible)
        return;
      const { element } = this.context;
      this.setElementsVisibility(element.getNodes(), "visible");
      this.setElementsVisibility(element.getEdges(), "visible");
      this.setElementsVisibility(element.getCombos(), "visible");
      this.isVisible = true;
    }, this.options.debounce);
    this.bindEvents();
  }
  bindEvents() {
    const { graph } = this.context;
    graph.on(GraphEvent.BEFORE_TRANSFORM, this.hideShapes);
    graph.on(GraphEvent.AFTER_TRANSFORM, this.showShapes);
  }
  unbindEvents() {
    const { graph } = this.context;
    graph.off(GraphEvent.BEFORE_TRANSFORM, this.hideShapes);
    graph.off(GraphEvent.AFTER_TRANSFORM, this.showShapes);
  }
  validate(event) {
    if (this.destroyed)
      return false;
    const { enable } = this.options;
    if (isFunction(enable))
      return enable(event);
    return !!enable;
  }
  update(options) {
    this.unbindEvents();
    super.update(options);
    this.bindEvents();
  }
  destroy() {
    this.unbindEvents();
    super.destroy();
  }
};
OptimizeViewportTransform.defaultOptions = {
  enable: true,
  debounce: 200,
  shapes: (type) => type === "node"
};

// node_modules/@antv/g6/esm/behaviors/scroll-canvas.js
var __awaiter11 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ScrollCanvas = class _ScrollCanvas extends BaseBehavior {
  constructor(context, options) {
    super(context, Object.assign({}, _ScrollCanvas.defaultOptions, options));
    this.onWheel = (event) => __awaiter11(this, void 0, void 0, function* () {
      if (this.options.preventDefault)
        event.preventDefault();
      const diffX = event.deltaX;
      const diffY = event.deltaY;
      yield this.scroll([-diffX, -diffY], event);
    });
    this.shortcut = new Shortcut(context.graph);
    this.bindEvents();
  }
  /**
   * <zh/> 
   *
   * <en/> Update options
   * @param options - <zh/>  | <en/> Options
   * @internal
   */
  update(options) {
    super.update(options);
    this.bindEvents();
  }
  bindEvents() {
    var _a, _b;
    const { trigger } = this.options;
    this.shortcut.unbindAll();
    if (is_object_default(trigger)) {
      (_a = this.graphDom) === null || _a === void 0 ? void 0 : _a.removeEventListener(CommonEvent.WHEEL, this.onWheel);
      const { up = [], down = [], left = [], right = [] } = trigger;
      this.shortcut.bind(up, (event) => this.scroll([0, -10], event));
      this.shortcut.bind(down, (event) => this.scroll([0, 10], event));
      this.shortcut.bind(left, (event) => this.scroll([-10, 0], event));
      this.shortcut.bind(right, (event) => this.scroll([10, 0], event));
    } else {
      (_b = this.graphDom) === null || _b === void 0 ? void 0 : _b.addEventListener(CommonEvent.WHEEL, this.onWheel, { passive: false });
    }
  }
  get graphDom() {
    return this.context.graph.getCanvas().getContextService().getDomElement();
  }
  formatDisplacement(d3) {
    const { sensitivity } = this.options;
    d3 = multiply(d3, sensitivity);
    d3 = this.clampByDirection(d3);
    d3 = this.clampByRange(d3);
    return d3;
  }
  clampByDirection([dx, dy]) {
    const { direction } = this.options;
    if (direction === "x") {
      dy = 0;
    } else if (direction === "y") {
      dx = 0;
    }
    return [dx, dy];
  }
  clampByRange([dx, dy]) {
    const { viewport, canvas: canvas2 } = this.context;
    const [canvasWidth, canvasHeight] = canvas2.getSize();
    const [top, right, bottom, left] = parsePadding(this.options.range);
    const range = [canvasHeight * top, canvasWidth * right, canvasHeight * bottom, canvasWidth * left];
    const scrollableArea = getExpandedBBox(getPointBBox(viewport.getCanvasCenter()), range);
    const nextViewportCenter = subtract(viewport.getViewportCenter(), [dx, dy, 0]);
    if (!isPointInBBox(nextViewportCenter, scrollableArea)) {
      const { min: [minX, minY], max: [maxX, maxY] } = scrollableArea;
      if (nextViewportCenter[0] < minX && dx > 0 || nextViewportCenter[0] > maxX && dx < 0) {
        dx = 0;
      }
      if (nextViewportCenter[1] < minY && dy > 0 || nextViewportCenter[1] > maxY && dy < 0) {
        dy = 0;
      }
    }
    return [dx, dy];
  }
  scroll(value, event) {
    return __awaiter11(this, void 0, void 0, function* () {
      if (!this.validate(event))
        return;
      const { onFinish } = this.options;
      const graph = this.context.graph;
      const formattedValue = this.formatDisplacement(value);
      yield graph.translateBy(formattedValue, false);
      onFinish === null || onFinish === void 0 ? void 0 : onFinish();
    });
  }
  validate(event) {
    if (this.destroyed)
      return false;
    const { enable } = this.options;
    if (isFunction(enable))
      return enable(event);
    return !!enable;
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy the canvas scrolling
   */
  destroy() {
    var _a;
    this.shortcut.destroy();
    (_a = this.graphDom) === null || _a === void 0 ? void 0 : _a.removeEventListener(CommonEvent.WHEEL, this.onWheel);
    super.destroy();
  }
};
ScrollCanvas.defaultOptions = {
  enable: true,
  sensitivity: 1,
  preventDefault: true,
  range: Infinity
};

// node_modules/@antv/g6/esm/behaviors/zoom-canvas.js
var __awaiter12 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ZoomCanvas = class _ZoomCanvas extends BaseBehavior {
  constructor(context, options) {
    super(context, Object.assign({}, _ZoomCanvas.defaultOptions, options));
    this.zoom = (value, event, animation) => __awaiter12(this, void 0, void 0, function* () {
      if (!this.validate(event))
        return;
      const { graph } = this.context;
      let origin = this.options.origin;
      if (!origin && "viewport" in event) {
        origin = parsePoint(event.viewport);
      }
      const { sensitivity, onFinish } = this.options;
      const ratio = 1 + clamp_default(value, -50, 50) * sensitivity / 100;
      const zoom = graph.getZoom();
      yield graph.zoomTo(zoom * ratio, animation, origin);
      onFinish === null || onFinish === void 0 ? void 0 : onFinish();
    });
    this.onReset = () => __awaiter12(this, void 0, void 0, function* () {
      yield this.context.graph.zoomTo(1, this.options.animation);
    });
    this.preventDefault = (event) => {
      if (this.options.preventDefault)
        event.preventDefault();
    };
    this.shortcut = new Shortcut(context.graph);
    this.bindEvents();
  }
  /**
   * <zh/> 
   *
   * <en/> Update options
   * @param options - <zh/>  | <en/> Options
   * @internal
   */
  update(options) {
    super.update(options);
    this.bindEvents();
  }
  bindEvents() {
    const { trigger } = this.options;
    this.shortcut.unbindAll();
    if (Array.isArray(trigger)) {
      if (trigger.includes(CommonEvent.PINCH)) {
        this.shortcut.bind([CommonEvent.PINCH], (event) => {
          this.zoom(event.scale, event, false);
        });
      } else {
        const container = this.context.canvas.getContainer();
        container === null || container === void 0 ? void 0 : container.addEventListener(CommonEvent.WHEEL, this.preventDefault);
        this.shortcut.bind([...trigger, CommonEvent.WHEEL], (event) => {
          const { deltaX, deltaY } = event;
          this.zoom(-(deltaY !== null && deltaY !== void 0 ? deltaY : deltaX), event, false);
        });
      }
    }
    if (typeof trigger === "object") {
      const { zoomIn = [], zoomOut = [], reset = [] } = trigger;
      this.shortcut.bind(zoomIn, (event) => this.zoom(10, event, this.options.animation));
      this.shortcut.bind(zoomOut, (event) => this.zoom(-10, event, this.options.animation));
      this.shortcut.bind(reset, this.onReset);
    }
  }
  /**
   * <zh/> 
   *
   * <en/> Verify whether it can be zoomed
   * @param event - <zh/>  | <en/> Event object
   * @returns <zh/>  | <en/> Whether it can be zoomed
   * @internal
   */
  validate(event) {
    if (this.destroyed)
      return false;
    const { enable } = this.options;
    if (isFunction(enable))
      return enable(event);
    return !!enable;
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy zoom canvas
   */
  destroy() {
    var _a;
    this.shortcut.destroy();
    (_a = this.context.canvas.getContainer()) === null || _a === void 0 ? void 0 : _a.removeEventListener(CommonEvent.WHEEL, this.preventDefault);
    super.destroy();
  }
};
ZoomCanvas.defaultOptions = {
  animation: { duration: 200 },
  enable: true,
  sensitivity: 1,
  trigger: [],
  preventDefault: true
};

// node_modules/@antv/hierarchy/dist/hierarchy.es.js
function t(t3, e2, i2, n2 = "height") {
  const h3 = t3[n2], r3 = e2[n2];
  return "center" === i2 ? (h3 + r3) / 2 : t3.height;
}
var e = Object.assign;
var i = { getId: (t3) => t3.id || t3.name, getPreH: (t3) => t3.preH || 0, getPreV: (t3) => t3.preV || 0, getHGap: (t3) => t3.hgap || 18, getVGap: (t3) => t3.vgap || 18, getChildren: (t3) => t3.children, getHeight: (t3) => t3.height || 36, getWidth(t3) {
  const e2 = t3.label || " ";
  return t3.width || 18 * e2.split("").length;
} };
var n = class _n {
  constructor(t3, e2) {
    if (this.x = 0, this.y = 0, this.depth = 0, this.children = [], this.hgap = 0, this.vgap = 0, t3 instanceof _n || "x" in t3 && "y" in t3 && "children" in t3) {
      const e3 = t3;
      return this.data = e3.data, this.id = e3.id, this.x = e3.x, this.y = e3.y, this.width = e3.width, this.height = e3.height, this.depth = e3.depth, this.children = e3.children, this.parent = e3.parent, this.hgap = e3.hgap, this.vgap = e3.vgap, this.preH = e3.preH, void (this.preV = e3.preV);
    }
    this.data = t3;
    const i2 = e2.getHGap(t3), h3 = e2.getVGap(t3);
    this.preH = e2.getPreH(t3), this.preV = e2.getPreV(t3), this.width = e2.getWidth(t3), this.height = e2.getHeight(t3), this.width += this.preH, this.height += this.preV, this.id = e2.getId(t3), this.addGap(i2, h3);
  }
  isRoot() {
    return 0 === this.depth;
  }
  isLeaf() {
    return 0 === this.children.length;
  }
  addGap(t3, e2) {
    this.hgap += t3, this.vgap += e2, this.width += 2 * t3, this.height += 2 * e2;
  }
  eachNode(t3) {
    let e2, i2 = [this];
    for (; e2 = i2.shift(); ) t3(e2), i2 = e2.children.concat(i2);
  }
  DFTraverse(t3) {
    this.eachNode(t3);
  }
  BFTraverse(t3) {
    let e2, i2 = [this];
    for (; e2 = i2.shift(); ) t3(e2), i2 = i2.concat(e2.children);
  }
  getBoundingBox() {
    const t3 = { left: Number.MAX_VALUE, top: Number.MAX_VALUE, width: 0, height: 0 };
    return this.eachNode((e2) => {
      t3.left = Math.min(t3.left, e2.x), t3.top = Math.min(t3.top, e2.y), t3.width = Math.max(t3.width, e2.x + e2.width), t3.height = Math.max(t3.height, e2.y + e2.height);
    }), t3;
  }
  translate(t3 = 0, e2 = 0) {
    this.eachNode((i2) => {
      i2.x += t3, i2.y += e2, i2.x += i2.preH, i2.y += i2.preV;
    });
  }
  right2left() {
    const t3 = this.getBoundingBox();
    this.eachNode((e2) => {
      e2.x = e2.x - 2 * (e2.x - t3.left) - e2.width;
    }), this.translate(t3.width, 0);
  }
  bottom2top() {
    const t3 = this.getBoundingBox();
    this.eachNode((e2) => {
      e2.y = e2.y - 2 * (e2.y - t3.top) - e2.height;
    }), this.translate(0, t3.height);
  }
};
function h(t3, h3 = {}, r3) {
  h3 = e({}, i, h3);
  const o3 = new n(t3, h3), s2 = [o3];
  let c3;
  if (!r3 && !t3.collapsed) {
    for (; c3 = s2.shift(); ) if (!c3.data.collapsed) {
      const t4 = h3.getChildren(c3.data), e2 = t4 ? t4.length : 0;
      if (c3.children = new Array(e2), t4 && e2) for (let i2 = 0; i2 < e2; i2++) {
        const e3 = new n(t4[i2], h3);
        c3.children[i2] = e3, s2.push(e3), e3.parent = c3, e3.depth = c3.depth + 1;
      }
    }
  }
  return o3;
}
var r = class {
  constructor(t3, e2 = {}) {
    this.options = e2, this.rootNode = h(t3, e2);
  }
  execute() {
    throw new Error("please override this method");
  }
};
var o = class t2 {
  constructor(t3 = 0, e2 = 0, i2 = 0, n2 = []) {
    this.x = 0, this.prelim = 0, this.mod = 0, this.shift = 0, this.change = 0, this.tl = null, this.tr = null, this.el = null, this.er = null, this.msel = 0, this.mser = 0, this.w = t3 || 0, this.h = e2 || 0, this.y = i2 || 0, this.c = n2 || [], this.cs = n2.length;
  }
  static fromNode(e2, i2) {
    if (!e2) return null;
    const n2 = [];
    return e2.children.forEach((e3) => {
      const h3 = t2.fromNode(e3, i2);
      h3 && n2.push(h3);
    }), i2 ? new t2(e2.height, e2.width, e2.x, n2) : new t2(e2.width, e2.height, e2.y, n2);
  }
};
function s(t3, e2, i2) {
  i2 ? t3.y += e2 : t3.x += e2, t3.children.forEach((t4) => {
    s(t4, e2, i2);
  });
}
function c(t3, e2) {
  let i2 = e2 ? t3.y : t3.x;
  return t3.children.forEach((t4) => {
    i2 = Math.min(c(t4, e2), i2);
  }), i2;
}
function l(t3, e2) {
  s(t3, -c(t3, e2), e2);
}
function a(t3, e2, i2) {
  i2 ? e2.y = t3.x : e2.x = t3.x, t3.c.forEach((t4, n2) => {
    a(t4, e2.children[n2], i2);
  });
}
function d(t3, e2, i2 = 0) {
  e2 ? (t3.x = i2, i2 += t3.width) : (t3.y = i2, i2 += t3.height), t3.children.forEach((t4) => {
    d(t4, e2, i2);
  });
}
function f(t3, e2 = {}) {
  const i2 = e2.isHorizontal;
  function n2(t4) {
    0 === t4.cs ? (t4.el = t4, t4.er = t4, t4.msel = t4.mser = 0) : (t4.el = t4.c[0].el, t4.msel = t4.c[0].msel, t4.er = t4.c[t4.cs - 1].er, t4.mser = t4.c[t4.cs - 1].mser);
  }
  function h3(t4, e3, i3) {
    let n3 = t4.c[e3 - 1], h4 = n3.mod, o3 = t4.c[e3], l3 = o3.mod;
    for (; null !== n3 && null !== o3; ) {
      i3 && f3(n3) > i3.low && (i3 = i3.nxt);
      const a3 = h4 + n3.prelim + n3.w - (l3 + o3.prelim);
      a3 > 0 && (l3 += a3, i3 && r3(t4, e3, i3.index, a3));
      const d3 = f3(n3), g4 = f3(o3);
      d3 <= g4 && (n3 = c3(n3), null !== n3 && (h4 += n3.mod)), d3 >= g4 && (o3 = s2(o3), null !== o3 && (l3 += o3.mod));
    }
    !n3 && o3 ? function(t5, e4, i4, n4) {
      const h5 = t5.c[0].el;
      h5.tl = i4;
      const r4 = n4 - i4.mod - t5.c[0].msel;
      h5.mod += r4, h5.prelim -= r4, t5.c[0].el = t5.c[e4].el, t5.c[0].msel = t5.c[e4].msel;
    }(t4, e3, o3, l3) : n3 && !o3 && function(t5, e4, i4, n4) {
      const h5 = t5.c[e4].er;
      h5.tr = i4;
      const r4 = n4 - i4.mod - t5.c[e4].mser;
      h5.mod += r4, h5.prelim -= r4, t5.c[e4].er = t5.c[e4 - 1].er, t5.c[e4].mser = t5.c[e4 - 1].mser;
    }(t4, e3, n3, h4);
  }
  function r3(t4, e3, i3, n3) {
    t4.c[e3].mod += n3, t4.c[e3].msel += n3, t4.c[e3].mser += n3, function(t5, e4, i4, n4) {
      if (i4 !== e4 - 1) {
        const h4 = e4 - i4;
        t5.c[i4 + 1].shift += n4 / h4, t5.c[e4].shift -= n4 / h4, t5.c[e4].change -= n4 - n4 / h4;
      }
    }(t4, e3, i3, n3);
  }
  function s2(t4) {
    return 0 === t4.cs ? t4.tl : t4.c[0];
  }
  function c3(t4) {
    return 0 === t4.cs ? t4.tr : t4.c[t4.cs - 1];
  }
  function f3(t4) {
    return t4.y + t4.h;
  }
  function g3(t4, e3, i3) {
    for (; null !== i3 && t4 >= i3.low; ) i3 = i3.nxt;
    return { low: t4, index: e3, nxt: i3 };
  }
  d(t3, i2);
  const u3 = o.fromNode(t3, i2);
  return u3 && (!function t4(e3) {
    if (0 === e3.cs) return void n2(e3);
    t4(e3.c[0]);
    let i3 = g3(f3(e3.c[0].el), 0, null);
    for (let n3 = 1; n3 < e3.cs; ++n3) {
      t4(e3.c[n3]);
      const r4 = f3(e3.c[n3].er);
      h3(e3, n3, i3), i3 = g3(r4, n3, i3);
    }
    !function(t5) {
      t5.prelim = (t5.c[0].prelim + t5.c[0].mod + t5.c[t5.cs - 1].mod + t5.c[t5.cs - 1].prelim + t5.c[t5.cs - 1].w) / 2 - t5.w / 2;
    }(e3), n2(e3);
  }(u3), function t4(e3, i3) {
    i3 += e3.mod, e3.x = e3.prelim + i3, function(t5) {
      let e4 = 0, i4 = 0;
      for (let n3 = 0; n3 < t5.cs; n3++) e4 += t5.c[n3].shift, i4 += e4 + t5.c[n3].change, t5.c[n3].mod += i4;
    }(e3);
    for (let n3 = 0; n3 < e3.cs; n3++) t4(e3.c[n3], i3);
  }(u3, 0), a(u3, t3, i2), l(t3, i2)), t3;
}
function g(t3, e2) {
  const i2 = h(t3.data, e2, true), n2 = h(t3.data, e2, true), r3 = t3.children.length, o3 = Math.round(r3 / 2), s2 = e2.getSide || function(t4, e3) {
    return e3 < o3 ? "right" : "left";
  };
  for (let h3 = 0; h3 < r3; h3++) {
    const e3 = t3.children[h3];
    "right" === s2(e3, h3) ? n2.children.push(e3) : i2.children.push(e3);
  }
  return i2.eachNode((t4) => {
    t4.isRoot() || (t4.side = "left");
  }), n2.eachNode((t4) => {
    t4.isRoot() || (t4.side = "right");
  }), { left: i2, right: n2 };
}
var u = ["LR", "RL", "TB", "BT", "H", "V"];
var p = ["LR", "RL", "H"];
var x = u[0];
function y(t3, e2, i2) {
  const n2 = e2.direction || x;
  if (e2.isHorizontal = ((t4) => p.indexOf(t4) > -1)(n2), n2 && -1 === u.indexOf(n2)) throw new TypeError(`Invalid direction: ${n2}`);
  if (n2 === u[0]) i2(t3, e2);
  else if (n2 === u[1]) i2(t3, e2), t3.right2left();
  else if (n2 === u[2]) i2(t3, e2);
  else if (n2 === u[3]) i2(t3, e2), t3.bottom2top();
  else if (n2 === u[4] || n2 === u[5]) {
    const { left: n3, right: h4 } = g(t3, e2);
    i2(n3, e2), i2(h4, e2), e2.isHorizontal ? n3.right2left() : n3.bottom2top(), h4.translate(n3.x - h4.x, n3.y - h4.y), t3.x = n3.x, t3.y = h4.y;
    const r3 = t3.getBoundingBox();
    e2.isHorizontal ? r3.top < 0 && t3.translate(0, -r3.top) : r3.left < 0 && t3.translate(-r3.left, 0);
  }
  let h3 = e2.fixedRoot;
  return void 0 === h3 && (h3 = true), h3 && t3.translate(-(t3.x + t3.width / 2 + t3.hgap), -(t3.y + t3.height / 2 + t3.vgap)), function(t4, e3) {
    if (e3.radial) {
      const [i3, n3] = e3.isHorizontal ? ["x", "y"] : ["y", "x"], h4 = { x: 1 / 0, y: 1 / 0 }, r3 = { x: -1 / 0, y: -1 / 0 };
      let o3 = 0;
      t4.DFTraverse((t5) => {
        o3++;
        const { x: e4, y: i4 } = t5;
        h4.x = Math.min(h4.x, e4), h4.y = Math.min(h4.y, i4), r3.x = Math.max(r3.x, e4), r3.y = Math.max(r3.y, i4);
      });
      const s2 = r3[n3] - h4[n3];
      if (0 === s2) return;
      const c3 = 2 * Math.PI / o3;
      t4.DFTraverse((e4) => {
        const r4 = e4[n3], o4 = h4[n3], l3 = e4[i3], a3 = t4[i3], d3 = (r4 - o4) / s2 * (2 * Math.PI - c3) + c3, f3 = l3 - a3;
        e4.x = Math.cos(d3) * f3, e4.y = Math.sin(d3) * f3;
      });
    }
  }(t3, e2), t3;
}
var m = class extends r {
  execute() {
    return y(this.rootNode, this.options, f);
  }
};
var w = {};
function H(t3, i2) {
  const n2 = e({}, w, i2);
  return new m(t3, n2).execute();
}
var N = class {
  constructor(t3 = 0, e2 = []) {
    this.x = 0, this.y = 0, this.leftChild = null, this.rightChild = null, this.isLeaf = false, this.height = t3, this.children = e2;
  }
};
var v = { isHorizontal: true, nodeSep: 20, nodeSize: 20, rankSep: 200, subTreeSep: 10 };
function M(t3, e2, i2) {
  i2 ? (e2.x = t3.x, e2.y = t3.y) : (e2.x = t3.y, e2.y = t3.x), t3.children.forEach((t4, n2) => {
    M(t4, e2.children[n2], i2);
  });
}
function E(t3, i2 = {}) {
  const n2 = e({}, v, i2);
  let h3 = 0;
  let r3 = null;
  const o3 = function t4(e2) {
    e2.width = 0, e2.depth && e2.depth > h3 && (h3 = e2.depth);
    const i3 = e2.children, n3 = i3.length, r4 = new N(0, []);
    return i3.forEach((e3, i4) => {
      const h4 = t4(e3);
      r4.children.push(h4), 0 === i4 && (r4.leftChild = h4), i4 === n3 - 1 && (r4.rightChild = h4);
    }), r4.originNode = e2, r4.isLeaf = e2.isLeaf(), r4;
  }(t3);
  return function t4(e2) {
    if (e2.isLeaf || 0 === e2.children.length) e2.drawingDepth = h3;
    else {
      const i3 = e2.children.map((e3) => t4(e3)), n3 = Math.min(...i3);
      e2.drawingDepth = n3 - 1;
    }
    return e2.drawingDepth;
  }(o3), function t4(e2) {
    e2.x = e2.drawingDepth * n2.rankSep, e2.isLeaf ? (e2.y = 0, r3 && (e2.y = r3.y + r3.height + n2.nodeSep, e2.originNode.parent !== r3.originNode.parent && (e2.y += n2.subTreeSep)), r3 = e2) : (e2.children.forEach((e3) => {
      t4(e3);
    }), e2.y = (e2.leftChild.y + e2.rightChild.y) / 2);
  }(o3), M(o3, t3, n2.isHorizontal), t3;
}
var B = class extends r {
  execute() {
    return this.rootNode.width = 0, y(this.rootNode, this.options, E);
  }
};
var T = {};
function S(t3, i2) {
  const n2 = e({}, T, i2);
  return new B(t3, n2).execute();
}
function b(e2, i2, n2, h3) {
  let r3 = null;
  e2.eachNode((e3) => {
    !function(e4, i3, n3, h4, r4) {
      const o3 = ("function" == typeof n3 ? n3(e4) : n3) * e4.depth;
      if (!h4) try {
        if (e4.parent && e4.id === e4.parent.children[0].id) return e4.x += o3, void (e4.y = i3 ? i3.y : 0);
      } catch (e5) {
      }
      if (e4.x += o3, i3) {
        if (e4.y = i3.y + t(i3, e4, r4), i3.parent && e4.parent && e4.parent.id !== i3.parent.id) {
          const n4 = i3.parent, h5 = n4.y + t(n4, e4, r4);
          e4.y = h5 > e4.y ? h5 : e4.y;
        }
      } else e4.y = 0;
    }(e3, r3, i2, n2, h3), r3 = e3;
  });
}
var L = ["LR", "RL", "H"];
var V = L[0];
var R = class extends r {
  execute() {
    const t3 = this.options, e2 = this.rootNode;
    t3.isHorizontal = true;
    const { indent: i2 = 20, dropCap: n2 = true, direction: h3 = V, align: r3 } = t3;
    if (h3 && -1 === L.indexOf(h3)) throw new TypeError(`Invalid direction: ${h3}`);
    if (h3 === L[0]) b(e2, i2, n2, r3);
    else if (h3 === L[1]) b(e2, i2, n2, r3), e2.right2left();
    else if (h3 === L[2]) {
      const { left: h4, right: o3 } = g(e2, t3);
      b(h4, i2, n2, r3), h4.right2left(), b(o3, i2, n2, r3);
      const s2 = h4.getBoundingBox();
      o3.translate(s2.width, 0), e2.x = o3.x - e2.width / 2;
    }
    return e2;
  }
};
var z = {};
function C(t3, i2) {
  const n2 = e({}, z, i2);
  return new R(t3, n2).execute();
}
function D(t3, e2) {
  let i2 = 0;
  return t3.children.length ? t3.children.forEach((t4) => {
    i2 += D(t4, e2);
  }) : i2 = t3.height, t3._subTreeSep = e2.getSubTreeSep(t3.data), t3.totalHeight = Math.max(t3.height, i2) + 2 * t3._subTreeSep, t3.totalHeight;
}
function Y(t3) {
  const e2 = t3.children, i2 = e2.length;
  if (i2) {
    e2.forEach((t4) => {
      Y(t4);
    });
    const n2 = e2[0], h3 = e2[i2 - 1], r3 = h3.y - n2.y + h3.height;
    let o3 = 0;
    if (e2.forEach((t4) => {
      o3 += t4.totalHeight;
    }), r3 > t3.height) t3.y = n2.y + r3 / 2 - t3.height / 2;
    else if (1 !== e2.length || t3.height > o3) {
      const i3 = t3.y + (t3.height - r3) / 2 - n2.y;
      e2.forEach((t4) => {
        t4.translate(0, i3);
      });
    } else t3.y = (n2.y + n2.height / 2 + h3.y + h3.height / 2) / 2 - t3.height / 2;
  }
}
var G = { getSubTreeSep: () => 0 };
function I(t3, i2 = {}) {
  return i2 = e({}, G, i2), t3.parent = { x: 0, width: 0, height: 0, y: 0 }, t3.BFTraverse((t4) => {
    t4.x = t4.parent.x + t4.parent.width;
  }), t3.parent = void 0, D(t3, i2), t3.startY = 0, t3.y = t3.totalHeight / 2 - t3.height / 2, t3.eachNode((t4) => {
    const e2 = t4.children, i3 = e2.length;
    if (i3) {
      const n2 = e2[0];
      if (n2.startY = t4.startY + t4._subTreeSep, 1 === i3) n2.y = t4.y + t4.height / 2 - n2.height / 2;
      else {
        n2.y = n2.startY + n2.totalHeight / 2 - n2.height / 2;
        for (let t5 = 1; t5 < i3; t5++) {
          const i4 = e2[t5];
          i4.startY = e2[t5 - 1].startY + e2[t5 - 1].totalHeight, i4.y = i4.startY + i4.totalHeight / 2 - i4.height / 2;
        }
      }
    }
  }), Y(t3), t3;
}
var P = class extends r {
  execute() {
    return y(this.rootNode, this.options, I);
  }
};
var A = {};
function F(t3, i2) {
  const n2 = e({}, A, i2);
  return new P(t3, n2).execute();
}

// node_modules/@antv/layout/lib/antv-dagre/data/list.js
var filterOutLinks = (k2, v3) => {
  if (k2 !== "next" && k2 !== "prev") {
    return v3;
  }
};
var unlink = (entry) => {
  entry.prev.next = entry.next;
  entry.next.prev = entry.prev;
  delete entry.next;
  delete entry.prev;
};
var List = class {
  constructor() {
    const shortcut = {};
    shortcut.prev = shortcut;
    shortcut.next = shortcut.prev;
    this.shortcut = shortcut;
  }
  dequeue() {
    const shortcut = this.shortcut;
    const entry = shortcut.prev;
    if (entry && entry !== shortcut) {
      unlink(entry);
      return entry;
    }
  }
  enqueue(entry) {
    const shortcut = this.shortcut;
    if (entry.prev && entry.next) {
      unlink(entry);
    }
    entry.next = shortcut.next;
    shortcut.next.prev = entry;
    shortcut.next = entry;
    entry.prev = shortcut;
  }
  toString() {
    const strs = [];
    const sentinel = this.shortcut;
    let curr = sentinel.prev;
    while (curr !== sentinel) {
      strs.push(JSON.stringify(curr, filterOutLinks));
      curr = curr === null || curr === void 0 ? void 0 : curr.prev;
    }
    return `[${strs.join(", ")}]`;
  }
};

// node_modules/@antv/layout/lib/antv-dagre/greedy-fas.js
var List2 = class extends List {
};
var DEFAULT_WEIGHT_FN = () => 1;
var greedyFAS = (g3, weightFn) => {
  var _a;
  if (g3.getAllNodes().length <= 1)
    return [];
  const state = buildState(g3, weightFn || DEFAULT_WEIGHT_FN);
  const results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);
  return (_a = results.map((e2) => g3.getRelatedEdges(e2.v, "out").filter(({ target }) => target === e2.w))) === null || _a === void 0 ? void 0 : _a.flat();
};
var doGreedyFAS = (g3, buckets, zeroIdx) => {
  let results = [];
  const sources = buckets[buckets.length - 1];
  const sinks = buckets[0];
  let entry;
  while (g3.getAllNodes().length) {
    while (entry = sinks.dequeue()) {
      removeNode(g3, buckets, zeroIdx, entry);
    }
    while (entry = sources.dequeue()) {
      removeNode(g3, buckets, zeroIdx, entry);
    }
    if (g3.getAllNodes().length) {
      for (let i2 = buckets.length - 2; i2 > 0; --i2) {
        entry = buckets[i2].dequeue();
        if (entry) {
          results = results.concat(removeNode(g3, buckets, zeroIdx, entry, true));
          break;
        }
      }
    }
  }
  return results;
};
var removeNode = (g3, buckets, zeroIdx, entry, collectPredecessors) => {
  var _a, _b;
  const results = [];
  if (g3.hasNode(entry.v)) {
    (_a = g3.getRelatedEdges(entry.v, "in")) === null || _a === void 0 ? void 0 : _a.forEach((edge) => {
      const weight = edge.data.weight;
      const uEntry = g3.getNode(edge.source);
      if (collectPredecessors) {
        results.push({ v: edge.source, w: edge.target, in: 0, out: 0 });
      }
      if (uEntry.data.out === void 0)
        uEntry.data.out = 0;
      uEntry.data.out -= weight;
      assignBucket(buckets, zeroIdx, Object.assign({ v: uEntry.id }, uEntry.data));
    });
    (_b = g3.getRelatedEdges(entry.v, "out")) === null || _b === void 0 ? void 0 : _b.forEach((edge) => {
      const weight = edge.data.weight;
      const w3 = edge.target;
      const wEntry = g3.getNode(w3);
      if (wEntry.data.in === void 0)
        wEntry.data.in = 0;
      wEntry.data.in -= weight;
      assignBucket(buckets, zeroIdx, Object.assign({ v: wEntry.id }, wEntry.data));
    });
    g3.removeNode(entry.v);
  }
  return collectPredecessors ? results : void 0;
};
var buildState = (g3, weightFn) => {
  const fasGraph = new Graph2();
  let maxIn = 0;
  let maxOut = 0;
  g3.getAllNodes().forEach((v3) => {
    fasGraph.addNode({
      id: v3.id,
      data: { v: v3.id, in: 0, out: 0 }
    });
  });
  g3.getAllEdges().forEach((e2) => {
    const edge = fasGraph.getRelatedEdges(e2.source, "out").find((edge2) => edge2.target === e2.target);
    const weight = (weightFn === null || weightFn === void 0 ? void 0 : weightFn(e2)) || 1;
    if (!edge) {
      fasGraph.addEdge({
        id: e2.id,
        source: e2.source,
        target: e2.target,
        data: {
          weight
        }
      });
    } else {
      fasGraph.updateEdgeData(edge === null || edge === void 0 ? void 0 : edge.id, Object.assign(Object.assign({}, edge.data), { weight: edge.data.weight + weight }));
    }
    maxOut = Math.max(maxOut, fasGraph.getNode(e2.source).data.out += weight);
    maxIn = Math.max(maxIn, fasGraph.getNode(e2.target).data.in += weight);
  });
  const buckets = [];
  const rangeMax = maxOut + maxIn + 3;
  for (let i2 = 0; i2 < rangeMax; i2++) {
    buckets.push(new List2());
  }
  const zeroIdx = maxIn + 1;
  fasGraph.getAllNodes().forEach((v3) => {
    assignBucket(buckets, zeroIdx, Object.assign({ v: v3.id }, fasGraph.getNode(v3.id).data));
  });
  return { buckets, zeroIdx, graph: fasGraph };
};
var assignBucket = (buckets, zeroIdx, entry) => {
  if (!entry.out) {
    buckets[0].enqueue(entry);
  } else if (!entry["in"]) {
    buckets[buckets.length - 1].enqueue(entry);
  } else {
    buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
  }
};

// node_modules/@antv/layout/lib/antv-dagre/acyclic.js
var run = (g3, acyclicer) => {
  const weightFn = (g4) => {
    return (e2) => e2.data.weight || 1;
  };
  const fas = acyclicer === "greedy" ? greedyFAS(g3, weightFn(g3)) : dfsFAS(g3);
  fas === null || fas === void 0 ? void 0 : fas.forEach((e2) => {
    const label = e2.data;
    g3.removeEdge(e2.id);
    label.forwardName = e2.data.name;
    label.reversed = true;
    g3.addEdge({
      id: e2.id,
      source: e2.target,
      target: e2.source,
      data: Object.assign({}, label)
    });
  });
};
var dfsFAS = (g3) => {
  const fas = [];
  const stack = {};
  const visited = {};
  const dfs4 = (v3) => {
    if (visited[v3]) {
      return;
    }
    visited[v3] = true;
    stack[v3] = true;
    g3.getRelatedEdges(v3, "out").forEach((e2) => {
      if (stack[e2.target]) {
        fas.push(e2);
      } else {
        dfs4(e2.target);
      }
    });
    delete stack[v3];
  };
  g3.getAllNodes().forEach((n2) => dfs4(n2.id));
  return fas;
};
var undo = (g3) => {
  g3.getAllEdges().forEach((e2) => {
    const label = e2.data;
    if (label.reversed) {
      g3.removeEdge(e2.id);
      const forwardName = label.forwardName;
      delete label.reversed;
      delete label.forwardName;
      g3.addEdge({
        id: e2.id,
        source: e2.target,
        target: e2.source,
        data: Object.assign(Object.assign({}, label), { forwardName })
      });
    }
  });
};

// node_modules/@antv/layout/lib/antv-dagre/util.js
var safeSort = (valueA, valueB) => {
  return Number(valueA) - Number(valueB);
};
var addDummyNode = (g3, type, data, name) => {
  let v3;
  do {
    v3 = `${name}${Math.random()}`;
  } while (g3.hasNode(v3));
  data.dummy = type;
  g3.addNode({
    id: v3,
    data
  });
  return v3;
};
var simplify = (g3) => {
  const simplified = new Graph2();
  g3.getAllNodes().forEach((v3) => {
    simplified.addNode(Object.assign({}, v3));
  });
  g3.getAllEdges().forEach((e2) => {
    const edge = simplified.getRelatedEdges(e2.source, "out").find((edge2) => edge2.target === e2.target);
    if (!edge) {
      simplified.addEdge({
        id: e2.id,
        source: e2.source,
        target: e2.target,
        data: {
          weight: e2.data.weight || 0,
          minlen: e2.data.minlen || 1
        }
      });
    } else {
      simplified.updateEdgeData(edge === null || edge === void 0 ? void 0 : edge.id, Object.assign(Object.assign({}, edge.data), { weight: edge.data.weight + e2.data.weight || 0, minlen: Math.max(edge.data.minlen, e2.data.minlen || 1) }));
    }
  });
  return simplified;
};
var asNonCompoundGraph = (g3) => {
  const simplified = new Graph2();
  g3.getAllNodes().forEach((node) => {
    if (!g3.getChildren(node.id).length) {
      simplified.addNode(Object.assign({}, node));
    }
  });
  g3.getAllEdges().forEach((edge) => {
    simplified.addEdge(edge);
  });
  return simplified;
};
var zipObject = (keys, values3) => {
  return keys === null || keys === void 0 ? void 0 : keys.reduce((obj, key, i2) => {
    obj[key] = values3[i2];
    return obj;
  }, {});
};
var intersectRect = (rect2, point3) => {
  const x4 = Number(rect2.x);
  const y4 = Number(rect2.y);
  const dx = Number(point3.x) - x4;
  const dy = Number(point3.y) - y4;
  let w3 = Number(rect2.width) / 2;
  let h3 = Number(rect2.height) / 2;
  if (!dx && !dy) {
    return { x: 0, y: 0 };
  }
  let sx;
  let sy;
  if (Math.abs(dy) * w3 > Math.abs(dx) * h3) {
    if (dy < 0) {
      h3 = -h3;
    }
    sx = h3 * dx / dy;
    sy = h3;
  } else {
    if (dx < 0) {
      w3 = -w3;
    }
    sx = w3;
    sy = w3 * dy / dx;
  }
  return { x: x4 + sx, y: y4 + sy };
};
var buildLayerMatrix = (g3) => {
  const layeringNodes = [];
  const rankMax = maxRank(g3) + 1;
  for (let i2 = 0; i2 < rankMax; i2++) {
    layeringNodes.push([]);
  }
  g3.getAllNodes().forEach((node) => {
    const rank2 = node.data.rank;
    if (rank2 !== void 0 && layeringNodes[rank2]) {
      layeringNodes[rank2].push(node.id);
    }
  });
  for (let i2 = 0; i2 < rankMax; i2++) {
    layeringNodes[i2] = layeringNodes[i2].sort((va, vb) => safeSort(g3.getNode(va).data.order, g3.getNode(vb).data.order));
  }
  return layeringNodes;
};
var normalizeRanks = (g3) => {
  const nodeRanks = g3.getAllNodes().filter((v3) => v3.data.rank !== void 0).map((v3) => v3.data.rank);
  const min2 = Math.min(...nodeRanks);
  g3.getAllNodes().forEach((v3) => {
    if (v3.data.hasOwnProperty("rank") && min2 !== Infinity) {
      v3.data.rank -= min2;
    }
  });
};
var removeEmptyRanks = (g3, nodeRankFactor = 0) => {
  const nodes = g3.getAllNodes();
  const nodeRanks = nodes.filter((v3) => v3.data.rank !== void 0).map((v3) => v3.data.rank);
  const offset = Math.min(...nodeRanks);
  const layers = [];
  nodes.forEach((v3) => {
    const rank2 = (v3.data.rank || 0) - offset;
    if (!layers[rank2]) {
      layers[rank2] = [];
    }
    layers[rank2].push(v3.id);
  });
  let delta = 0;
  for (let i2 = 0; i2 < layers.length; i2++) {
    const vs = layers[i2];
    if (vs === void 0) {
      if (i2 % nodeRankFactor !== 0) {
        delta -= 1;
      }
    } else if (delta) {
      vs === null || vs === void 0 ? void 0 : vs.forEach((v3) => {
        const node = g3.getNode(v3);
        if (node) {
          node.data.rank = node.data.rank || 0;
          node.data.rank += delta;
        }
      });
    }
  }
};
var addBorderNode = (g3, prefix, rank2, order2) => {
  const node = {
    width: 0,
    height: 0
  };
  if (isNumber(rank2) && isNumber(order2)) {
    node.rank = rank2;
    node.order = order2;
  }
  return addDummyNode(g3, "border", node, prefix);
};
var maxRank = (g3) => {
  let maxRank2;
  g3.getAllNodes().forEach((v3) => {
    const rank2 = v3.data.rank;
    if (rank2 !== void 0) {
      if (maxRank2 === void 0 || rank2 > maxRank2) {
        maxRank2 = rank2;
      }
    }
  });
  if (!maxRank2) {
    maxRank2 = 0;
  }
  return maxRank2;
};
var partition = (collection, fn) => {
  const result = { lhs: [], rhs: [] };
  collection === null || collection === void 0 ? void 0 : collection.forEach((value) => {
    if (fn(value)) {
      result.lhs.push(value);
    } else {
      result.rhs.push(value);
    }
  });
  return result;
};
var minBy = (array, func) => {
  return array.reduce((a3, b3) => {
    const valA = func(a3);
    const valB = func(b3);
    return valA > valB ? b3 : a3;
  });
};
var doDFS2 = (graph, node, postorder, visited, navigator2, result) => {
  if (!visited.includes(node.id)) {
    visited.push(node.id);
    if (!postorder) {
      result.push(node.id);
    }
    navigator2(node.id).forEach((n2) => doDFS2(graph, n2, postorder, visited, navigator2, result));
    if (postorder) {
      result.push(node.id);
    }
  }
};
var dfs2 = (graph, node, order2, isDirected) => {
  const nodes = Array.isArray(node) ? node : [node];
  const navigator2 = (n2) => isDirected ? graph.getSuccessors(n2) : graph.getNeighbors(n2);
  const results = [];
  const visited = [];
  nodes.forEach((node2) => {
    if (!graph.hasNode(node2.id)) {
      throw new Error(`Graph does not have node: ${node2}`);
    } else {
      doDFS2(graph, node2, order2 === "post", visited, navigator2, results);
    }
  });
  return results;
};

// node_modules/@antv/layout/lib/antv-dagre/add-border-segments.js
var addBorderSegments = (g3) => {
  const dfs4 = (v3) => {
    const children = g3.getChildren(v3);
    const node = g3.getNode(v3);
    if (children === null || children === void 0 ? void 0 : children.length) {
      children.forEach((child) => dfs4(child.id));
    }
    if (node.data.hasOwnProperty("minRank")) {
      node.data.borderLeft = [];
      node.data.borderRight = [];
      for (let rank2 = node.data.minRank, maxRank2 = node.data.maxRank + 1; rank2 < maxRank2; rank2 += 1) {
        addBorderNode2(g3, "borderLeft", "_bl", v3, node, rank2);
        addBorderNode2(g3, "borderRight", "_br", v3, node, rank2);
      }
    }
  };
  g3.getRoots().forEach((child) => dfs4(child.id));
};
var addBorderNode2 = (g3, prop, prefix, sg, sgNode, rank2) => {
  const label = { rank: rank2, borderType: prop, width: 0, height: 0 };
  const prev = sgNode.data[prop][rank2 - 1];
  const curr = addDummyNode(g3, "border", label, prefix);
  sgNode.data[prop][rank2] = curr;
  g3.setParent(curr, sg);
  if (prev) {
    g3.addEdge({
      id: `e${Math.random()}`,
      source: prev,
      target: curr,
      data: { weight: 1 }
    });
  }
};

// node_modules/@antv/layout/lib/antv-dagre/coordinate-system.js
var adjust = (g3, rankdir) => {
  const rd = rankdir.toLowerCase();
  if (rd === "lr" || rd === "rl") {
    swapWidthHeight(g3);
  }
};
var undo2 = (g3, rankdir) => {
  const rd = rankdir.toLowerCase();
  if (rd === "bt" || rd === "rl") {
    reverseY(g3);
  }
  if (rd === "lr" || rd === "rl") {
    swapXY(g3);
    swapWidthHeight(g3);
  }
};
var swapWidthHeight = (g3) => {
  g3.getAllNodes().forEach((v3) => {
    swapWidthHeightOne(v3);
  });
  g3.getAllEdges().forEach((e2) => {
    swapWidthHeightOne(e2);
  });
};
var swapWidthHeightOne = (node) => {
  const w3 = node.data.width;
  node.data.width = node.data.height;
  node.data.height = w3;
};
var reverseY = (g3) => {
  g3.getAllNodes().forEach((v3) => {
    reverseYOne(v3.data);
  });
  g3.getAllEdges().forEach((edge) => {
    var _a;
    (_a = edge.data.points) === null || _a === void 0 ? void 0 : _a.forEach((point3) => reverseYOne(point3));
    if (edge.data.hasOwnProperty("y")) {
      reverseYOne(edge.data);
    }
  });
};
var reverseYOne = (node) => {
  if (node === null || node === void 0 ? void 0 : node.y) {
    node.y = -node.y;
  }
};
var swapXY = (g3) => {
  g3.getAllNodes().forEach((v3) => {
    swapXYOne(v3.data);
  });
  g3.getAllEdges().forEach((edge) => {
    var _a;
    (_a = edge.data.points) === null || _a === void 0 ? void 0 : _a.forEach((point3) => swapXYOne(point3));
    if (edge.data.hasOwnProperty("x")) {
      swapXYOne(edge.data);
    }
  });
};
var swapXYOne = (node) => {
  const x4 = node.x;
  node.x = node.y;
  node.y = x4;
};

// node_modules/@antv/layout/lib/antv-dagre/nesting-graph.js
var run2 = (g3) => {
  const root = addDummyNode(g3, "root", {}, "_root");
  const depths = treeDepths(g3);
  let maxDepth = Math.max(...Object.values(depths));
  if (Math.abs(maxDepth) === Infinity) {
    maxDepth = 1;
  }
  const height = maxDepth - 1;
  const nodeSep = 2 * height + 1;
  g3.getAllEdges().forEach((e2) => {
    e2.data.minlen *= nodeSep;
  });
  const weight = sumWeights(g3) + 1;
  g3.getRoots().forEach((child) => {
    dfs3(g3, root, nodeSep, weight, height, depths, child.id);
  });
  return {
    nestingRoot: root,
    nodeRankFactor: nodeSep
  };
};
var dfs3 = (g3, root, nodeSep, weight, height, depths, v3) => {
  const children = g3.getChildren(v3);
  if (!(children === null || children === void 0 ? void 0 : children.length)) {
    if (v3 !== root) {
      g3.addEdge({
        id: `e${Math.random()}`,
        source: root,
        target: v3,
        data: { weight: 0, minlen: nodeSep }
      });
    }
    return;
  }
  const top = addBorderNode(g3, "_bt");
  const bottom = addBorderNode(g3, "_bb");
  const label = g3.getNode(v3);
  g3.setParent(top, v3);
  label.data.borderTop = top;
  g3.setParent(bottom, v3);
  label.data.borderBottom = bottom;
  children === null || children === void 0 ? void 0 : children.forEach((childNode) => {
    dfs3(g3, root, nodeSep, weight, height, depths, childNode.id);
    const childTop = childNode.data.borderTop ? childNode.data.borderTop : childNode.id;
    const childBottom = childNode.data.borderBottom ? childNode.data.borderBottom : childNode.id;
    const thisWeight = childNode.data.borderTop ? weight : 2 * weight;
    const minlen = childTop !== childBottom ? 1 : height - depths[v3] + 1;
    g3.addEdge({
      id: `e${Math.random()}`,
      source: top,
      target: childTop,
      data: {
        minlen,
        weight: thisWeight,
        nestingEdge: true
      }
    });
    g3.addEdge({
      id: `e${Math.random()}`,
      source: childBottom,
      target: bottom,
      data: {
        minlen,
        weight: thisWeight,
        nestingEdge: true
      }
    });
  });
  if (!g3.getParent(v3)) {
    g3.addEdge({
      id: `e${Math.random()}`,
      source: root,
      target: top,
      data: {
        weight: 0,
        minlen: height + depths[v3]
      }
    });
  }
};
var treeDepths = (g3) => {
  const depths = {};
  const dfs4 = (v3, depth) => {
    const children = g3.getChildren(v3);
    children === null || children === void 0 ? void 0 : children.forEach((child) => dfs4(child.id, depth + 1));
    depths[v3] = depth;
  };
  g3.getRoots().forEach((v3) => dfs4(v3.id, 1));
  return depths;
};
var sumWeights = (g3) => {
  let result = 0;
  g3.getAllEdges().forEach((e2) => {
    result += e2.data.weight;
  });
  return result;
};
var cleanup = (g3, nestingRoot) => {
  if (nestingRoot) {
    g3.removeNode(nestingRoot);
  }
  g3.getAllEdges().forEach((e2) => {
    if (e2.data.nestingEdge) {
      g3.removeEdge(e2.id);
    }
  });
};

// node_modules/@antv/layout/lib/antv-dagre/normalize.js
var DUMMY_NODE_EDGE = "edge";
var DUMMY_NODE_EDGE_LABEL = "edge-label";
var run3 = (g3, dummyChains) => {
  g3.getAllEdges().forEach((edge) => normalizeEdge(g3, edge, dummyChains));
};
var normalizeEdge = (g3, e2, dummyChains) => {
  let v3 = e2.source;
  let vRank = g3.getNode(v3).data.rank;
  const w3 = e2.target;
  const wRank = g3.getNode(w3).data.rank;
  const labelRank = e2.data.labelRank;
  if (wRank === vRank + 1)
    return;
  g3.removeEdge(e2.id);
  let dummy;
  let nodeData;
  let i2;
  for (i2 = 0, ++vRank; vRank < wRank; ++i2, ++vRank) {
    e2.data.points = [];
    nodeData = {
      originalEdge: e2,
      width: 0,
      height: 0,
      rank: vRank
    };
    dummy = addDummyNode(g3, DUMMY_NODE_EDGE, nodeData, "_d");
    if (vRank === labelRank) {
      nodeData.width = e2.data.width;
      nodeData.height = e2.data.height;
      nodeData.dummy = DUMMY_NODE_EDGE_LABEL;
      nodeData.labelpos = e2.data.labelpos;
    }
    g3.addEdge({
      id: `e${Math.random()}`,
      source: v3,
      target: dummy,
      data: { weight: e2.data.weight }
    });
    if (i2 === 0) {
      dummyChains.push(dummy);
    }
    v3 = dummy;
  }
  g3.addEdge({
    id: `e${Math.random()}`,
    source: v3,
    target: w3,
    data: { weight: e2.data.weight }
  });
};
var undo3 = (g3, dummyChains) => {
  dummyChains.forEach((v3) => {
    let node = g3.getNode(v3);
    const { data } = node;
    const originalEdge = data.originalEdge;
    let w3;
    if (originalEdge) {
      g3.addEdge(originalEdge);
    }
    let currentV = v3;
    while (node.data.dummy) {
      w3 = g3.getSuccessors(currentV)[0];
      g3.removeNode(currentV);
      originalEdge.data.points.push({
        x: node.data.x,
        y: node.data.y
      });
      if (node.data.dummy === DUMMY_NODE_EDGE_LABEL) {
        originalEdge.data.x = node.data.x;
        originalEdge.data.y = node.data.y;
        originalEdge.data.width = node.data.width;
        originalEdge.data.height = node.data.height;
      }
      currentV = w3.id;
      node = g3.getNode(currentV);
    }
  });
};

// node_modules/@antv/layout/lib/antv-dagre/order/add-subgraph-constraints.js
var addSubgraphConstraints = (g3, cg, vs) => {
  const prev = {};
  let rootPrev;
  vs === null || vs === void 0 ? void 0 : vs.forEach((v3) => {
    let child = g3.getParent(v3);
    let parent;
    let prevChild;
    while (child) {
      parent = g3.getParent(child.id);
      if (parent) {
        prevChild = prev[parent.id];
        prev[parent.id] = child.id;
      } else {
        prevChild = rootPrev;
        rootPrev = child.id;
      }
      if (prevChild && prevChild !== child.id) {
        if (!cg.hasNode(prevChild)) {
          cg.addNode({
            id: prevChild,
            data: {}
          });
        }
        if (!cg.hasNode(child.id)) {
          cg.addNode({
            id: child.id,
            data: {}
          });
        }
        if (!cg.hasEdge(`e${prevChild}-${child.id}`)) {
          cg.addEdge({
            id: `e${prevChild}-${child.id}`,
            source: prevChild,
            target: child.id,
            data: {}
          });
        }
        return;
      }
      child = parent;
    }
  });
};

// node_modules/@antv/layout/lib/antv-dagre/order/build-layer-graph.js
var buildLayerGraph = (g3, rank2, direction) => {
  const root = createRootNode(g3);
  const result = new Graph2({
    tree: [
      {
        id: root,
        children: [],
        data: {}
      }
    ]
  });
  g3.getAllNodes().forEach((v3) => {
    const parent = g3.getParent(v3.id);
    if (v3.data.rank === rank2 || v3.data.minRank <= rank2 && rank2 <= v3.data.maxRank) {
      if (!result.hasNode(v3.id)) {
        result.addNode(Object.assign({}, v3));
      }
      if ((parent === null || parent === void 0 ? void 0 : parent.id) && !result.hasNode(parent === null || parent === void 0 ? void 0 : parent.id)) {
        result.addNode(Object.assign({}, parent));
      }
      result.setParent(v3.id, (parent === null || parent === void 0 ? void 0 : parent.id) || root);
      g3.getRelatedEdges(v3.id, direction).forEach((e2) => {
        const u3 = e2.source === v3.id ? e2.target : e2.source;
        if (!result.hasNode(u3)) {
          result.addNode(Object.assign({}, g3.getNode(u3)));
        }
        const edge = result.getRelatedEdges(u3, "out").find(({ target }) => target === v3.id);
        const weight = edge !== void 0 ? edge.data.weight : 0;
        if (!edge) {
          result.addEdge({
            id: e2.id,
            source: u3,
            target: v3.id,
            data: {
              weight: e2.data.weight + weight
            }
          });
        } else {
          result.updateEdgeData(edge.id, Object.assign(Object.assign({}, edge.data), { weight: e2.data.weight + weight }));
        }
      });
      if (v3.data.hasOwnProperty("minRank")) {
        result.updateNodeData(v3.id, Object.assign(Object.assign({}, v3.data), { borderLeft: v3.data.borderLeft[rank2], borderRight: v3.data.borderRight[rank2] }));
      }
    }
  });
  return result;
};
var createRootNode = (g3) => {
  let v3;
  while (g3.hasNode(v3 = `_root${Math.random()}`))
    ;
  return v3;
};

// node_modules/@antv/layout/lib/antv-dagre/order/cross-count.js
var twoLayerCrossCount = (g3, northLayer, southLayer) => {
  const southPos = zipObject(southLayer, southLayer.map((v3, i2) => i2));
  const unflat = northLayer.map((v3) => {
    const unsort = g3.getRelatedEdges(v3, "out").map((e2) => {
      return { pos: southPos[e2.target] || 0, weight: e2.data.weight };
    });
    return unsort === null || unsort === void 0 ? void 0 : unsort.sort((a3, b3) => a3.pos - b3.pos);
  });
  const southEntries = unflat.flat().filter((entry) => entry !== void 0);
  let firstIndex = 1;
  while (firstIndex < southLayer.length)
    firstIndex <<= 1;
  const treeSize = 2 * firstIndex - 1;
  firstIndex -= 1;
  const tree = Array(treeSize).fill(0, 0, treeSize);
  let cc = 0;
  southEntries === null || southEntries === void 0 ? void 0 : southEntries.forEach((entry) => {
    if (entry) {
      let index = entry.pos + firstIndex;
      tree[index] += entry.weight;
      let weightSum = 0;
      while (index > 0) {
        if (index % 2) {
          weightSum += tree[index + 1];
        }
        index = index - 1 >> 1;
        tree[index] += entry.weight;
      }
      cc += entry.weight * weightSum;
    }
  });
  return cc;
};
var crossCount = (g3, layering) => {
  let cc = 0;
  for (let i2 = 1; i2 < (layering === null || layering === void 0 ? void 0 : layering.length); i2 += 1) {
    cc += twoLayerCrossCount(g3, layering[i2 - 1], layering[i2]);
  }
  return cc;
};

// node_modules/@antv/layout/lib/antv-dagre/order/init-order.js
var initOrder = (g3) => {
  const visited = {};
  const simpleNodes = g3.getAllNodes();
  const nodeRanks = simpleNodes.map((v3) => {
    var _a;
    return (_a = v3.data.rank) !== null && _a !== void 0 ? _a : -Infinity;
  });
  const maxRank2 = Math.max(...nodeRanks);
  const layers = [];
  for (let i2 = 0; i2 < maxRank2 + 1; i2++) {
    layers.push([]);
  }
  const orderedVs = simpleNodes.sort((a3, b3) => g3.getNode(a3.id).data.rank - g3.getNode(b3.id).data.rank);
  const beforeSort = orderedVs.filter((n2) => {
    return g3.getNode(n2.id).data.fixorder !== void 0;
  });
  const fixOrderNodes = beforeSort.sort((a3, b3) => g3.getNode(a3.id).data.fixorder - g3.getNode(b3.id).data.fixorder);
  fixOrderNodes === null || fixOrderNodes === void 0 ? void 0 : fixOrderNodes.forEach((n2) => {
    if (!isNaN(g3.getNode(n2.id).data.rank)) {
      layers[g3.getNode(n2.id).data.rank].push(n2.id);
    }
    visited[n2.id] = true;
  });
  orderedVs === null || orderedVs === void 0 ? void 0 : orderedVs.forEach((n2) => g3.dfsTree(n2.id, (node) => {
    if (visited.hasOwnProperty(node.id))
      return true;
    visited[node.id] = true;
    if (!isNaN(node.data.rank)) {
      layers[node.data.rank].push(node.id);
    }
  }));
  return layers;
};

// node_modules/@antv/layout/lib/antv-dagre/order/barycenter.js
var barycenter = (g3, movable) => {
  return movable.map((v3) => {
    const inV = g3.getRelatedEdges(v3, "in");
    if (!(inV === null || inV === void 0 ? void 0 : inV.length)) {
      return { v: v3 };
    }
    const result = { sum: 0, weight: 0 };
    inV === null || inV === void 0 ? void 0 : inV.forEach((e2) => {
      const nodeU = g3.getNode(e2.source);
      result.sum += e2.data.weight * nodeU.data.order;
      result.weight += e2.data.weight;
    });
    return {
      v: v3,
      barycenter: result.sum / result.weight,
      weight: result.weight
    };
  });
};

// node_modules/@antv/layout/lib/antv-dagre/order/resolve-conflicts.js
var resolveConflicts = (entries, cg) => {
  var _a, _b, _c;
  const mappedEntries = {};
  entries === null || entries === void 0 ? void 0 : entries.forEach((entry, i2) => {
    mappedEntries[entry.v] = {
      i: i2,
      indegree: 0,
      in: [],
      out: [],
      vs: [entry.v]
    };
    const tmp = mappedEntries[entry.v];
    if (entry.barycenter !== void 0) {
      tmp.barycenter = entry.barycenter;
      tmp.weight = entry.weight;
    }
  });
  (_a = cg.getAllEdges()) === null || _a === void 0 ? void 0 : _a.forEach((e2) => {
    const entryV = mappedEntries[e2.source];
    const entryW = mappedEntries[e2.target];
    if (entryV !== void 0 && entryW !== void 0) {
      entryW.indegree++;
      entryV.out.push(mappedEntries[e2.target]);
    }
  });
  const sourceSet = (_c = (_b = Object.values(mappedEntries)).filter) === null || _c === void 0 ? void 0 : _c.call(_b, (entry) => !entry.indegree);
  return doResolveConflicts(sourceSet);
};
var doResolveConflicts = (sourceSet) => {
  var _a, _b;
  const entries = [];
  const handleIn = (vEntry) => {
    return (uEntry) => {
      if (uEntry.merged)
        return;
      if (uEntry.barycenter === void 0 || vEntry.barycenter === void 0 || uEntry.barycenter >= vEntry.barycenter) {
        mergeEntries(vEntry, uEntry);
      }
    };
  };
  const handleOut = (vEntry) => {
    return (wEntry) => {
      wEntry["in"].push(vEntry);
      if (--wEntry.indegree === 0) {
        sourceSet.push(wEntry);
      }
    };
  };
  while (sourceSet === null || sourceSet === void 0 ? void 0 : sourceSet.length) {
    const entry = sourceSet.pop();
    entries.push(entry);
    (_a = entry["in"].reverse()) === null || _a === void 0 ? void 0 : _a.forEach((e2) => handleIn(entry)(e2));
    (_b = entry.out) === null || _b === void 0 ? void 0 : _b.forEach((e2) => handleOut(entry)(e2));
  }
  const filtered = entries.filter((entry) => !entry.merged);
  const keys = [
    "vs",
    "i",
    "barycenter",
    "weight"
  ];
  return filtered.map((entry) => {
    const picked = {};
    keys === null || keys === void 0 ? void 0 : keys.forEach((key) => {
      if (entry[key] === void 0)
        return;
      picked[key] = entry[key];
    });
    return picked;
  });
};
var mergeEntries = (target, source) => {
  var _a;
  let sum = 0;
  let weight = 0;
  if (target.weight) {
    sum += target.barycenter * target.weight;
    weight += target.weight;
  }
  if (source.weight) {
    sum += source.barycenter * source.weight;
    weight += source.weight;
  }
  target.vs = (_a = source.vs) === null || _a === void 0 ? void 0 : _a.concat(target.vs);
  target.barycenter = sum / weight;
  target.weight = weight;
  target.i = Math.min(source.i, target.i);
  source.merged = true;
};
var resolve_conflicts_default = resolveConflicts;

// node_modules/@antv/layout/lib/antv-dagre/order/sort.js
var sort = (entries, biasRight, usePrev, keepNodeOrder) => {
  const parts = partition(entries, (entry) => {
    const hasFixOrder = entry.hasOwnProperty("fixorder") && !isNaN(entry.fixorder);
    if (keepNodeOrder) {
      return !hasFixOrder && entry.hasOwnProperty("barycenter");
    }
    return hasFixOrder || entry.hasOwnProperty("barycenter");
  });
  const sortable = parts.lhs;
  const unsortable = parts.rhs.sort((a3, b3) => -a3.i - -b3.i);
  const vs = [];
  let sum = 0;
  let weight = 0;
  let vsIndex = 0;
  sortable === null || sortable === void 0 ? void 0 : sortable.sort(compareWithBias(!!biasRight, !!usePrev));
  vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
  sortable === null || sortable === void 0 ? void 0 : sortable.forEach((entry) => {
    var _a;
    vsIndex += (_a = entry.vs) === null || _a === void 0 ? void 0 : _a.length;
    vs.push(entry.vs);
    sum += entry.barycenter * entry.weight;
    weight += entry.weight;
    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
  });
  const result = {
    vs: vs.flat()
  };
  if (weight) {
    result.barycenter = sum / weight;
    result.weight = weight;
  }
  return result;
};
var consumeUnsortable = (vs, unsortable, index) => {
  let iindex = index;
  let last2;
  while (unsortable.length && (last2 = unsortable[unsortable.length - 1]).i <= iindex) {
    unsortable.pop();
    vs === null || vs === void 0 ? void 0 : vs.push(last2.vs);
    iindex++;
  }
  return iindex;
};
var compareWithBias = (bias, usePrev) => {
  return (entryV, entryW) => {
    if (entryV.fixorder !== void 0 && entryW.fixorder !== void 0) {
      return entryV.fixorder - entryW.fixorder;
    }
    if (entryV.barycenter < entryW.barycenter) {
      return -1;
    }
    if (entryV.barycenter > entryW.barycenter) {
      return 1;
    }
    if (usePrev && entryV.order !== void 0 && entryW.order !== void 0) {
      if (entryV.order < entryW.order) {
        return -1;
      }
      if (entryV.order > entryW.order) {
        return 1;
      }
    }
    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
  };
};

// node_modules/@antv/layout/lib/antv-dagre/order/sort-subgraph.js
var sortSubgraph = (g3, v3, cg, biasRight, usePrev, keepNodeOrder) => {
  var _a, _b, _c, _d;
  let movable = g3.getChildren(v3).map((n2) => n2.id);
  const node = g3.getNode(v3);
  const bl = node ? node.data.borderLeft : void 0;
  const br = node ? node.data.borderRight : void 0;
  const subgraphs = {};
  if (bl) {
    movable = movable === null || movable === void 0 ? void 0 : movable.filter((w3) => {
      return w3 !== bl && w3 !== br;
    });
  }
  const barycenters = barycenter(g3, movable || []);
  barycenters === null || barycenters === void 0 ? void 0 : barycenters.forEach((entry) => {
    var _a2;
    if ((_a2 = g3.getChildren(entry.v)) === null || _a2 === void 0 ? void 0 : _a2.length) {
      const subgraphResult = sortSubgraph(g3, entry.v, cg, biasRight, keepNodeOrder);
      subgraphs[entry.v] = subgraphResult;
      if (subgraphResult.hasOwnProperty("barycenter")) {
        mergeBarycenters(entry, subgraphResult);
      }
    }
  });
  const entries = resolve_conflicts_default(barycenters, cg);
  expandSubgraphs(entries, subgraphs);
  (_a = entries.filter((e2) => e2.vs.length > 0)) === null || _a === void 0 ? void 0 : _a.forEach((e2) => {
    const node2 = g3.getNode(e2.vs[0]);
    if (node2) {
      e2.fixorder = node2.data.fixorder;
      e2.order = node2.data.order;
    }
  });
  const result = sort(entries, biasRight, usePrev, keepNodeOrder);
  if (bl) {
    result.vs = [bl, result.vs, br].flat();
    if ((_b = g3.getPredecessors(bl)) === null || _b === void 0 ? void 0 : _b.length) {
      const blPred = g3.getNode(((_c = g3.getPredecessors(bl)) === null || _c === void 0 ? void 0 : _c[0].id) || "");
      const brPred = g3.getNode(((_d = g3.getPredecessors(br)) === null || _d === void 0 ? void 0 : _d[0].id) || "");
      if (!result.hasOwnProperty("barycenter")) {
        result.barycenter = 0;
        result.weight = 0;
      }
      result.barycenter = (result.barycenter * result.weight + blPred.data.order + brPred.data.order) / (result.weight + 2);
      result.weight += 2;
    }
  }
  return result;
};
var expandSubgraphs = (entries, subgraphs) => {
  entries === null || entries === void 0 ? void 0 : entries.forEach((entry) => {
    var _a;
    const vss = (_a = entry.vs) === null || _a === void 0 ? void 0 : _a.map((v3) => {
      if (subgraphs[v3]) {
        return subgraphs[v3].vs;
      }
      return v3;
    });
    entry.vs = vss.flat();
  });
};
var mergeBarycenters = (target, other) => {
  if (target.barycenter !== void 0) {
    target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
    target.weight += other.weight;
  } else {
    target.barycenter = other.barycenter;
    target.weight = other.weight;
  }
};

// node_modules/@antv/layout/lib/antv-dagre/order/index.js
var order = (g3, keepNodeOrder) => {
  const mxRank = maxRank(g3);
  const range1 = [];
  const range2 = [];
  for (let i2 = 1; i2 < mxRank + 1; i2++)
    range1.push(i2);
  for (let i2 = mxRank - 1; i2 > -1; i2--)
    range2.push(i2);
  const downLayerGraphs = buildLayerGraphs(g3, range1, "in");
  const upLayerGraphs = buildLayerGraphs(g3, range2, "out");
  let layering = initOrder(g3);
  assignOrder(g3, layering);
  let bestCC = Number.POSITIVE_INFINITY;
  let best;
  for (let i2 = 0, lastBest = 0; lastBest < 4; ++i2, ++lastBest) {
    sweepLayerGraphs(i2 % 2 ? downLayerGraphs : upLayerGraphs, i2 % 4 >= 2, false, keepNodeOrder);
    layering = buildLayerMatrix(g3);
    const cc = crossCount(g3, layering);
    if (cc < bestCC) {
      lastBest = 0;
      best = clone_default(layering);
      bestCC = cc;
    }
  }
  layering = initOrder(g3);
  assignOrder(g3, layering);
  for (let i2 = 0, lastBest = 0; lastBest < 4; ++i2, ++lastBest) {
    sweepLayerGraphs(i2 % 2 ? downLayerGraphs : upLayerGraphs, i2 % 4 >= 2, true, keepNodeOrder);
    layering = buildLayerMatrix(g3);
    const cc = crossCount(g3, layering);
    if (cc < bestCC) {
      lastBest = 0;
      best = clone_default(layering);
      bestCC = cc;
    }
  }
  assignOrder(g3, best);
};
var buildLayerGraphs = (g3, ranks, direction) => {
  return ranks.map((rank2) => {
    return buildLayerGraph(g3, rank2, direction);
  });
};
var sweepLayerGraphs = (layerGraphs, biasRight, usePrev, keepNodeOrder) => {
  const cg = new Graph2();
  layerGraphs === null || layerGraphs === void 0 ? void 0 : layerGraphs.forEach((lg) => {
    var _a;
    const root = lg.getRoots()[0].id;
    const sorted = sortSubgraph(lg, root, cg, biasRight, usePrev, keepNodeOrder);
    for (let i2 = 0; i2 < ((_a = sorted.vs) === null || _a === void 0 ? void 0 : _a.length) || 0; i2++) {
      const lnode = lg.getNode(sorted.vs[i2]);
      if (lnode) {
        lnode.data.order = i2;
      }
    }
    addSubgraphConstraints(lg, cg, sorted.vs);
  });
};
var assignOrder = (g3, layering) => {
  layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
    layer === null || layer === void 0 ? void 0 : layer.forEach((v3, i2) => {
      g3.getNode(v3).data.order = i2;
    });
  });
};

// node_modules/@antv/layout/lib/antv-dagre/order/init-data-order.js
var initDataOrder = (g3, nodeOrder) => {
  const simpleNodes = g3.getAllNodes().filter((v3) => {
    var _a;
    return !((_a = g3.getChildren(v3.id)) === null || _a === void 0 ? void 0 : _a.length);
  });
  const ranks = simpleNodes.map((v3) => v3.data.rank);
  const maxRank2 = Math.max(...ranks);
  const layers = [];
  for (let i2 = 0; i2 < maxRank2 + 1; i2++) {
    layers[i2] = [];
  }
  nodeOrder === null || nodeOrder === void 0 ? void 0 : nodeOrder.forEach((n2) => {
    const node = g3.getNode(n2);
    if (!node || node.data.dummy) {
      return;
    }
    if (!isNaN(node.data.rank)) {
      node.data.fixorder = layers[node.data.rank].length;
      layers[node.data.rank].push(n2);
    }
  });
};

// node_modules/@antv/layout/lib/antv-dagre/parent-dummy-chains.js
var dfsBothOrder = (g3) => {
  const result = {};
  let lim = 0;
  const dfs4 = (v3) => {
    const low = lim;
    g3.getChildren(v3).forEach((n2) => dfs4(n2.id));
    result[v3] = { low, lim: lim++ };
  };
  g3.getRoots().forEach((n2) => dfs4(n2.id));
  return result;
};
var findPath = (g3, postorderNums, v3, w3) => {
  var _a, _b;
  const vPath = [];
  const wPath = [];
  const low = Math.min(postorderNums[v3].low, postorderNums[w3].low);
  const lim = Math.max(postorderNums[v3].lim, postorderNums[w3].lim);
  let parent;
  let lca;
  parent = v3;
  do {
    parent = (_a = g3.getParent(parent)) === null || _a === void 0 ? void 0 : _a.id;
    vPath.push(parent);
  } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
  lca = parent;
  parent = w3;
  while (parent && parent !== lca) {
    wPath.push(parent);
    parent = (_b = g3.getParent(parent)) === null || _b === void 0 ? void 0 : _b.id;
  }
  return { lca, path: vPath.concat(wPath.reverse()) };
};
var parentDummyChains = (g3, dummyChains) => {
  const postorderNums = dfsBothOrder(g3);
  dummyChains.forEach((startV) => {
    var _a, _b;
    let v3 = startV;
    let node = g3.getNode(v3);
    const originalEdge = node.data.originalEdge;
    if (!originalEdge)
      return;
    const pathData = findPath(g3, postorderNums, originalEdge.source, originalEdge.target);
    const path = pathData.path;
    const lca = pathData.lca;
    let pathIdx = 0;
    let pathV = path[pathIdx];
    let ascending = true;
    while (v3 !== originalEdge.target) {
      node = g3.getNode(v3);
      if (ascending) {
        while (pathV !== lca && ((_a = g3.getNode(pathV)) === null || _a === void 0 ? void 0 : _a.data.maxRank) < node.data.rank) {
          pathIdx++;
          pathV = path[pathIdx];
        }
        if (pathV === lca) {
          ascending = false;
        }
      }
      if (!ascending) {
        while (pathIdx < path.length - 1 && ((_b = g3.getNode(path[pathIdx + 1])) === null || _b === void 0 ? void 0 : _b.data.minRank) <= node.data.rank) {
          pathIdx++;
        }
        pathV = path[pathIdx];
      }
      if (g3.hasNode(pathV)) {
        g3.setParent(v3, pathV);
      }
      v3 = g3.getSuccessors(v3)[0].id;
    }
  });
};

// node_modules/@antv/layout/lib/antv-dagre/position/bk.js
var findType1Conflicts = (g3, layering) => {
  const conflicts = {};
  const visitLayer = (prevLayer, layer) => {
    let k0 = 0;
    let scanPos = 0;
    const prevLayerLength = prevLayer.length;
    const lastNode = layer === null || layer === void 0 ? void 0 : layer[(layer === null || layer === void 0 ? void 0 : layer.length) - 1];
    layer === null || layer === void 0 ? void 0 : layer.forEach((v3, i2) => {
      var _a;
      const w3 = findOtherInnerSegmentNode(g3, v3);
      const k1 = w3 ? g3.getNode(w3.id).data.order : prevLayerLength;
      if (w3 || v3 === lastNode) {
        (_a = layer.slice(scanPos, i2 + 1)) === null || _a === void 0 ? void 0 : _a.forEach((scanNode) => {
          var _a2;
          (_a2 = g3.getPredecessors(scanNode)) === null || _a2 === void 0 ? void 0 : _a2.forEach((u3) => {
            var _a3;
            const uLabel = g3.getNode(u3.id);
            const uPos = uLabel.data.order;
            if ((uPos < k0 || k1 < uPos) && !(uLabel.data.dummy && ((_a3 = g3.getNode(scanNode)) === null || _a3 === void 0 ? void 0 : _a3.data.dummy))) {
              addConflict(conflicts, u3.id, scanNode);
            }
          });
        });
        scanPos = i2 + 1;
        k0 = k1;
      }
    });
    return layer;
  };
  if (layering === null || layering === void 0 ? void 0 : layering.length) {
    layering.reduce(visitLayer);
  }
  return conflicts;
};
var findType2Conflicts = (g3, layering) => {
  const conflicts = {};
  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
    var _a, _b;
    let v3;
    for (let i2 = southPos; i2 < southEnd; i2++) {
      v3 = south[i2];
      if ((_a = g3.getNode(v3)) === null || _a === void 0 ? void 0 : _a.data.dummy) {
        (_b = g3.getPredecessors(v3)) === null || _b === void 0 ? void 0 : _b.forEach((u3) => {
          const uNode = g3.getNode(u3.id);
          if (uNode.data.dummy && (uNode.data.order < prevNorthBorder || uNode.data.order > nextNorthBorder)) {
            addConflict(conflicts, u3.id, v3);
          }
        });
      }
    }
  }
  function getScannedKey(params) {
    return JSON.stringify(params.slice(1));
  }
  function scanIfNeeded(params, scanCache) {
    const cacheKey = getScannedKey(params);
    if (scanCache.get(cacheKey))
      return;
    scan(...params);
    scanCache.set(cacheKey, true);
  }
  const visitLayer = (north, south) => {
    let prevNorthPos = -1;
    let nextNorthPos;
    let southPos = 0;
    const scanned = /* @__PURE__ */ new Map();
    south === null || south === void 0 ? void 0 : south.forEach((v3, southLookahead) => {
      var _a;
      if (((_a = g3.getNode(v3)) === null || _a === void 0 ? void 0 : _a.data.dummy) === "border") {
        const predecessors = g3.getPredecessors(v3) || [];
        if (predecessors.length) {
          nextNorthPos = g3.getNode(predecessors[0].id).data.order;
          scanIfNeeded([south, southPos, southLookahead, prevNorthPos, nextNorthPos], scanned);
          southPos = southLookahead;
          prevNorthPos = nextNorthPos;
        }
      }
      scanIfNeeded([south, southPos, south.length, nextNorthPos, north.length], scanned);
    });
    return south;
  };
  if (layering === null || layering === void 0 ? void 0 : layering.length) {
    layering.reduce(visitLayer);
  }
  return conflicts;
};
var findOtherInnerSegmentNode = (g3, v3) => {
  var _a, _b;
  if ((_a = g3.getNode(v3)) === null || _a === void 0 ? void 0 : _a.data.dummy) {
    return (_b = g3.getPredecessors(v3)) === null || _b === void 0 ? void 0 : _b.find((u3) => g3.getNode(u3.id).data.dummy);
  }
};
var addConflict = (conflicts, v3, w3) => {
  let vv = v3;
  let ww = w3;
  if (vv > ww) {
    const tmp = vv;
    vv = ww;
    ww = tmp;
  }
  let conflictsV = conflicts[vv];
  if (!conflictsV) {
    conflicts[vv] = conflictsV = {};
  }
  conflictsV[ww] = true;
};
var hasConflict = (conflicts, v3, w3) => {
  let vv = v3;
  let ww = w3;
  if (vv > ww) {
    const tmp = v3;
    vv = ww;
    ww = tmp;
  }
  return !!conflicts[vv];
};
var verticalAlignment = (g3, layering, conflicts, neighborFn) => {
  const root = {};
  const align = {};
  const pos = {};
  layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
    layer === null || layer === void 0 ? void 0 : layer.forEach((v3, order2) => {
      root[v3] = v3;
      align[v3] = v3;
      pos[v3] = order2;
    });
  });
  layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
    let prevIdx = -1;
    layer === null || layer === void 0 ? void 0 : layer.forEach((v3) => {
      let ws = neighborFn(v3).map((n2) => n2.id);
      if (ws.length) {
        ws = ws.sort((a3, b3) => pos[a3] - pos[b3]);
        const mp = (ws.length - 1) / 2;
        for (let i2 = Math.floor(mp), il = Math.ceil(mp); i2 <= il; ++i2) {
          const w3 = ws[i2];
          if (align[v3] === v3 && prevIdx < pos[w3] && !hasConflict(conflicts, v3, w3)) {
            align[w3] = v3;
            align[v3] = root[v3] = root[w3];
            prevIdx = pos[w3];
          }
        }
      }
    });
  });
  return { root, align };
};
var horizontalCompaction = (g3, layering, root, align, nodesep, edgesep, reverseSep) => {
  var _a;
  const xs = {};
  const blockG = buildBlockGraph(g3, layering, root, nodesep, edgesep, reverseSep);
  const borderType = reverseSep ? "borderLeft" : "borderRight";
  const iterate = (setXsFunc, nextNodesFunc) => {
    let stack = blockG.getAllNodes();
    let elem = stack.pop();
    const visited = {};
    while (elem) {
      if (visited[elem.id]) {
        setXsFunc(elem.id);
      } else {
        visited[elem.id] = true;
        stack.push(elem);
        stack = stack.concat(nextNodesFunc(elem.id));
      }
      elem = stack.pop();
    }
  };
  const pass1 = (elem) => {
    xs[elem] = (blockG.getRelatedEdges(elem, "in") || []).reduce((acc, e2) => {
      return Math.max(acc, (xs[e2.source] || 0) + e2.data.weight);
    }, 0);
  };
  const pass2 = (elem) => {
    const min2 = (blockG.getRelatedEdges(elem, "out") || []).reduce((acc, e2) => {
      return Math.min(acc, (xs[e2.target] || 0) - e2.data.weight);
    }, Number.POSITIVE_INFINITY);
    const node = g3.getNode(elem);
    if (min2 !== Number.POSITIVE_INFINITY && node.data.borderType !== borderType) {
      xs[elem] = Math.max(xs[elem], min2);
    }
  };
  iterate(pass1, blockG.getPredecessors.bind(blockG));
  iterate(pass2, blockG.getSuccessors.bind(blockG));
  (_a = Object.values(align)) === null || _a === void 0 ? void 0 : _a.forEach((v3) => {
    xs[v3] = xs[root[v3]];
  });
  return xs;
};
var buildBlockGraph = (g3, layering, root, nodesep, edgesep, reverseSep) => {
  const blockGraph = new Graph2();
  const sepFn = sep(nodesep, edgesep, reverseSep);
  layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
    let u3;
    layer === null || layer === void 0 ? void 0 : layer.forEach((v3) => {
      const vRoot = root[v3];
      if (!blockGraph.hasNode(vRoot)) {
        blockGraph.addNode({
          id: vRoot,
          data: {}
        });
      }
      if (u3) {
        const uRoot = root[u3];
        const edge = blockGraph.getRelatedEdges(uRoot, "out").find((edge2) => edge2.target === vRoot);
        if (!edge) {
          blockGraph.addEdge({
            id: `e${Math.random()}`,
            source: uRoot,
            target: vRoot,
            data: {
              weight: Math.max(sepFn(g3, v3, u3), 0)
            }
          });
        } else {
          blockGraph.updateEdgeData(edge.id, Object.assign(Object.assign({}, edge.data), { weight: Math.max(sepFn(g3, v3, u3), edge.data.weight || 0) }));
        }
      }
      u3 = v3;
    });
  });
  return blockGraph;
};
var findSmallestWidthAlignment = (g3, xss) => {
  return minBy(Object.values(xss), (xs) => {
    var _a;
    let max2 = Number.NEGATIVE_INFINITY;
    let min2 = Number.POSITIVE_INFINITY;
    (_a = Object.keys(xs)) === null || _a === void 0 ? void 0 : _a.forEach((v3) => {
      const x4 = xs[v3];
      const halfWidth = width(g3, v3) / 2;
      max2 = Math.max(x4 + halfWidth, max2);
      min2 = Math.min(x4 - halfWidth, min2);
    });
    return max2 - min2;
  });
};
function alignCoordinates(xss, alignTo) {
  const alignToVals = Object.values(alignTo);
  const alignToMin = Math.min(...alignToVals);
  const alignToMax = Math.max(...alignToVals);
  ["u", "d"].forEach((vert) => {
    ["l", "r"].forEach((horiz) => {
      const alignment = vert + horiz;
      const xs = xss[alignment];
      let delta;
      if (xs === alignTo)
        return;
      const xsVals = Object.values(xs);
      delta = horiz === "l" ? alignToMin - Math.min(...xsVals) : alignToMax - Math.max(...xsVals);
      if (delta) {
        xss[alignment] = {};
        Object.keys(xs).forEach((key) => {
          xss[alignment][key] = xs[key] + delta;
        });
      }
    });
  });
}
var balance = (xss, align) => {
  const result = {};
  Object.keys(xss.ul).forEach((key) => {
    if (align) {
      result[key] = xss[align.toLowerCase()][key];
    } else {
      const values3 = Object.values(xss).map((x4) => x4[key]);
      result[key] = (values3[0] + values3[1]) / 2;
    }
  });
  return result;
};
var sep = (nodeSep, edgeSep, reverseSep) => {
  return (g3, v3, w3) => {
    const vLabel = g3.getNode(v3);
    const wLabel = g3.getNode(w3);
    let sum = 0;
    let delta = 0;
    sum += vLabel.data.width / 2;
    if (vLabel.data.hasOwnProperty("labelpos")) {
      switch ((vLabel.data.labelpos || "").toLowerCase()) {
        case "l":
          delta = -vLabel.data.width / 2;
          break;
        case "r":
          delta = vLabel.data.width / 2;
          break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;
    sum += (vLabel.data.dummy ? edgeSep : nodeSep) / 2;
    sum += (wLabel.data.dummy ? edgeSep : nodeSep) / 2;
    sum += wLabel.data.width / 2;
    if (wLabel.data.labelpos) {
      switch ((wLabel.data.labelpos || "").toLowerCase()) {
        case "l":
          delta = wLabel.data.width / 2;
          break;
        case "r":
          delta = -wLabel.data.width / 2;
          break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;
    return sum;
  };
};
var width = (g3, v3) => g3.getNode(v3).data.width || 0;

// node_modules/@antv/layout/lib/antv-dagre/position/index.js
var positionY = (g3, options) => {
  const { ranksep = 0 } = options || {};
  const layering = buildLayerMatrix(g3);
  let prevY = 0;
  layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
    const heights = layer.map((v3) => g3.getNode(v3).data.height);
    const maxHeight = Math.max(...heights, 0);
    layer === null || layer === void 0 ? void 0 : layer.forEach((v3) => {
      g3.getNode(v3).data.y = prevY + maxHeight / 2;
    });
    prevY += maxHeight + ranksep;
  });
};
var positionX = (g3, options) => {
  const { align: graphAlign, nodesep = 0, edgesep = 0 } = options || {};
  const layering = buildLayerMatrix(g3);
  const conflicts = Object.assign(findType1Conflicts(g3, layering), findType2Conflicts(g3, layering));
  const xss = {};
  let adjustedLayering = [];
  ["u", "d"].forEach((vert) => {
    adjustedLayering = vert === "u" ? layering : Object.values(layering).reverse();
    ["l", "r"].forEach((horiz) => {
      if (horiz === "r") {
        adjustedLayering = adjustedLayering.map((inner) => Object.values(inner).reverse());
      }
      const neighborFn = (vert === "u" ? g3.getPredecessors : g3.getSuccessors).bind(g3);
      const align = verticalAlignment(g3, adjustedLayering, conflicts, neighborFn);
      const xs = horizontalCompaction(g3, adjustedLayering, align.root, align.align, nodesep, edgesep, horiz === "r");
      if (horiz === "r") {
        Object.keys(xs).forEach((xsKey) => xs[xsKey] = -xs[xsKey]);
      }
      xss[vert + horiz] = xs;
    });
  });
  const smallestWidth = findSmallestWidthAlignment(g3, xss);
  smallestWidth && alignCoordinates(xss, smallestWidth);
  return balance(xss, graphAlign);
};
var position = (g3, options) => {
  var _a;
  const ng = asNonCompoundGraph(g3);
  positionY(ng, options);
  const xs = positionX(ng, options);
  (_a = Object.keys(xs)) === null || _a === void 0 ? void 0 : _a.forEach((key) => {
    ng.getNode(key).data.x = xs[key];
  });
};

// node_modules/@antv/layout/lib/antv-dagre/rank/util.js
var longestPath = (g3) => {
  const visited = {};
  const dfs4 = (v3) => {
    var _a;
    const label = g3.getNode(v3);
    if (!label)
      return 0;
    if (visited[v3]) {
      return label.data.rank;
    }
    visited[v3] = true;
    let rank2;
    (_a = g3.getRelatedEdges(v3, "out")) === null || _a === void 0 ? void 0 : _a.forEach((e2) => {
      const wRank = dfs4(e2.target);
      const minLen = e2.data.minlen;
      const r3 = wRank - minLen;
      if (r3) {
        if (rank2 === void 0 || r3 < rank2) {
          rank2 = r3;
        }
      }
    });
    if (!rank2) {
      rank2 = 0;
    }
    label.data.rank = rank2;
    return rank2;
  };
  g3.getAllNodes().filter((n2) => g3.getRelatedEdges(n2.id, "in").length === 0).forEach((source) => dfs4(source.id));
};
var longestPathWithLayer = (g3) => {
  const visited = {};
  let minRank;
  const dfs4 = (v3) => {
    var _a;
    const label = g3.getNode(v3);
    if (!label)
      return 0;
    if (visited[v3]) {
      return label.data.rank;
    }
    visited[v3] = true;
    let rank2;
    (_a = g3.getRelatedEdges(v3, "out")) === null || _a === void 0 ? void 0 : _a.forEach((e2) => {
      const wRank = dfs4(e2.target);
      const minLen = e2.data.minlen;
      const r3 = wRank - minLen;
      if (r3) {
        if (rank2 === void 0 || r3 < rank2) {
          rank2 = r3;
        }
      }
    });
    if (!rank2) {
      rank2 = 0;
    }
    if (minRank === void 0 || rank2 < minRank) {
      minRank = rank2;
    }
    label.data.rank = rank2;
    return rank2;
  };
  g3.getAllNodes().filter((n2) => g3.getRelatedEdges(n2.id, "in").length === 0).forEach((source) => {
    if (source)
      dfs4(source.id);
  });
  if (minRank === void 0) {
    minRank = 0;
  }
  const forwardVisited = {};
  const dfsForward = (v3, nextRank) => {
    var _a;
    const label = g3.getNode(v3);
    const currRank = !isNaN(label.data.layer) ? label.data.layer : nextRank;
    if (label.data.rank === void 0 || label.data.rank < currRank) {
      label.data.rank = currRank;
    }
    if (forwardVisited[v3])
      return;
    forwardVisited[v3] = true;
    (_a = g3.getRelatedEdges(v3, "out")) === null || _a === void 0 ? void 0 : _a.forEach((e2) => {
      dfsForward(e2.target, currRank + e2.data.minlen);
    });
  };
  g3.getAllNodes().forEach((n2) => {
    const label = n2.data;
    if (!label)
      return;
    if (!isNaN(label.layer)) {
      dfsForward(n2.id, label.layer);
    } else {
      label.rank -= minRank;
    }
  });
};
var slack = (g3, e2) => {
  return g3.getNode(e2.target).data.rank - g3.getNode(e2.source).data.rank - e2.data.minlen;
};

// node_modules/@antv/layout/lib/antv-dagre/rank/feasible-tree.js
var feasibleTree = (g3) => {
  const t3 = new Graph2({
    tree: []
  });
  const start = g3.getAllNodes()[0];
  const size2 = g3.getAllNodes().length;
  t3.addNode(start);
  let edge;
  let delta;
  while (tightTree(t3, g3) < size2) {
    edge = findMinSlackEdge(t3, g3);
    delta = t3.hasNode(edge.source) ? slack(g3, edge) : -slack(g3, edge);
    shiftRanks(t3, g3, delta);
  }
  return t3;
};
var tightTree = (t3, g3) => {
  const dfs4 = (v3) => {
    g3.getRelatedEdges(v3, "both").forEach((e2) => {
      const edgeV = e2.source;
      const w3 = v3 === edgeV ? e2.target : edgeV;
      if (!t3.hasNode(w3) && !slack(g3, e2)) {
        t3.addNode({
          id: w3,
          data: {}
        });
        t3.addEdge({
          id: e2.id,
          source: v3,
          target: w3,
          data: {}
        });
        dfs4(w3);
      }
    });
  };
  t3.getAllNodes().forEach((n2) => dfs4(n2.id));
  return t3.getAllNodes().length;
};
var feasibleTreeWithLayer = (g3) => {
  const t3 = new Graph2({ tree: [] });
  const start = g3.getAllNodes()[0];
  const size2 = g3.getAllNodes().length;
  t3.addNode(start);
  let edge;
  let delta;
  while (tightTreeWithLayer(t3, g3) < size2) {
    edge = findMinSlackEdge(t3, g3);
    delta = t3.hasNode(edge.source) ? slack(g3, edge) : -slack(g3, edge);
    shiftRanks(t3, g3, delta);
  }
  return t3;
};
var tightTreeWithLayer = (t3, g3) => {
  const dfs4 = (v3) => {
    var _a;
    (_a = g3.getRelatedEdges(v3, "both")) === null || _a === void 0 ? void 0 : _a.forEach((e2) => {
      const edgeV = e2.source;
      const w3 = v3 === edgeV ? e2.target : edgeV;
      if (!t3.hasNode(w3) && (g3.getNode(w3).data.layer !== void 0 || !slack(g3, e2))) {
        t3.addNode({
          id: w3,
          data: {}
        });
        t3.addEdge({
          id: e2.id,
          source: v3,
          target: w3,
          data: {}
        });
        dfs4(w3);
      }
    });
  };
  t3.getAllNodes().forEach((n2) => dfs4(n2.id));
  return t3.getAllNodes().length;
};
var findMinSlackEdge = (t3, g3) => {
  return minBy(g3.getAllEdges(), (e2) => {
    if (t3.hasNode(e2.source) !== t3.hasNode(e2.target)) {
      return slack(g3, e2);
    }
    return Infinity;
  });
};
var shiftRanks = (t3, g3, delta) => {
  t3.getAllNodes().forEach((tn) => {
    const v3 = g3.getNode(tn.id);
    if (!v3.data.rank)
      v3.data.rank = 0;
    v3.data.rank += delta;
  });
};

// node_modules/@antv/layout/lib/antv-dagre/rank/network-simplex.js
var networkSimplex = (og) => {
  const g3 = simplify(og);
  longestPath(g3);
  const t3 = feasibleTree(g3);
  initLowLimValues(t3);
  initCutValues(t3, g3);
  let e2;
  let f3;
  while (e2 = leaveEdge(t3)) {
    f3 = enterEdge(t3, g3, e2);
    exchangeEdges(t3, g3, e2, f3);
  }
};
var initCutValues = (t3, g3) => {
  let vs = dfs2(t3, t3.getAllNodes(), "post", false);
  vs = vs.slice(0, (vs === null || vs === void 0 ? void 0 : vs.length) - 1);
  vs.forEach((v3) => {
    assignCutValue(t3, g3, v3);
  });
};
var assignCutValue = (t3, g3, child) => {
  const childLab = t3.getNode(child);
  const parent = childLab.data.parent;
  const edge = t3.getRelatedEdges(child, "both").find((e2) => e2.target === parent || e2.source === parent);
  edge.data.cutvalue = calcCutValue(t3, g3, child);
};
var calcCutValue = (t3, g3, child) => {
  const childLab = t3.getNode(child);
  const parent = childLab.data.parent;
  let childIsTail = true;
  let graphEdge = g3.getRelatedEdges(child, "out").find((e2) => e2.target === parent);
  let cutValue = 0;
  if (!graphEdge) {
    childIsTail = false;
    graphEdge = g3.getRelatedEdges(parent, "out").find((e2) => e2.target === child);
  }
  cutValue = graphEdge.data.weight;
  g3.getRelatedEdges(child, "both").forEach((e2) => {
    const isOutEdge = e2.source === child;
    const other = isOutEdge ? e2.target : e2.source;
    if (other !== parent) {
      const pointsToHead = isOutEdge === childIsTail;
      const otherWeight = e2.data.weight;
      cutValue += pointsToHead ? otherWeight : -otherWeight;
      if (isTreeEdge(t3, child, other)) {
        const otherCutValue = t3.getRelatedEdges(child, "both").find((e3) => e3.source === other || e3.target === other).data.cutvalue;
        cutValue += pointsToHead ? -otherCutValue : otherCutValue;
      }
    }
  });
  return cutValue;
};
var initLowLimValues = (tree, root = tree.getAllNodes()[0].id) => {
  dfsAssignLowLim(tree, {}, 1, root);
};
var dfsAssignLowLim = (tree, visited, nextLim, v3, parent) => {
  var _a;
  const low = nextLim;
  let useNextLim = nextLim;
  const label = tree.getNode(v3);
  visited[v3] = true;
  (_a = tree.getNeighbors(v3)) === null || _a === void 0 ? void 0 : _a.forEach((w3) => {
    if (!visited[w3.id]) {
      useNextLim = dfsAssignLowLim(tree, visited, useNextLim, w3.id, v3);
    }
  });
  label.data.low = low;
  label.data.lim = useNextLim++;
  if (parent) {
    label.data.parent = parent;
  } else {
    delete label.data.parent;
  }
  return useNextLim;
};
var leaveEdge = (tree) => {
  return tree.getAllEdges().find((e2) => {
    return e2.data.cutvalue < 0;
  });
};
var enterEdge = (t3, g3, edge) => {
  let v3 = edge.source;
  let w3 = edge.target;
  if (!g3.getRelatedEdges(v3, "out").find((e2) => e2.target === w3)) {
    v3 = edge.target;
    w3 = edge.source;
  }
  const vLabel = t3.getNode(v3);
  const wLabel = t3.getNode(w3);
  let tailLabel = vLabel;
  let flip = false;
  if (vLabel.data.lim > wLabel.data.lim) {
    tailLabel = wLabel;
    flip = true;
  }
  const candidates = g3.getAllEdges().filter((edge2) => {
    return flip === isDescendant(t3.getNode(edge2.source), tailLabel) && flip !== isDescendant(t3.getNode(edge2.target), tailLabel);
  });
  return minBy(candidates, (edge2) => {
    return slack(g3, edge2);
  });
};
var exchangeEdges = (t3, g3, e2, f3) => {
  const existed = t3.getRelatedEdges(e2.source, "both").find((edge) => edge.source === e2.target || edge.target === e2.target);
  if (existed) {
    t3.removeEdge(existed.id);
  }
  t3.addEdge({
    id: `e${Math.random()}`,
    source: f3.source,
    target: f3.target,
    data: {}
  });
  initLowLimValues(t3);
  initCutValues(t3, g3);
  updateRanks(t3, g3);
};
var updateRanks = (t3, g3) => {
  const root = t3.getAllNodes().find((v3) => {
    return !v3.data.parent;
  });
  let vs = dfs2(t3, root, "pre", false);
  vs = vs.slice(1);
  vs.forEach((v3) => {
    const parent = t3.getNode(v3).data.parent;
    let edge = g3.getRelatedEdges(v3, "out").find((e2) => e2.target === parent);
    let flipped = false;
    if (!edge && g3.hasNode(parent)) {
      edge = g3.getRelatedEdges(parent, "out").find((e2) => e2.target === v3);
      flipped = true;
    }
    g3.getNode(v3).data.rank = (g3.hasNode(parent) && g3.getNode(parent).data.rank || 0) + (flipped ? edge === null || edge === void 0 ? void 0 : edge.data.minlen : -(edge === null || edge === void 0 ? void 0 : edge.data.minlen));
  });
};
var isTreeEdge = (tree, u3, v3) => {
  return tree.getRelatedEdges(u3, "both").find((e2) => e2.source === v3 || e2.target === v3);
};
var isDescendant = (vLabel, rootLabel) => {
  return rootLabel.data.low <= vLabel.data.lim && vLabel.data.lim <= rootLabel.data.lim;
};

// node_modules/@antv/layout/lib/antv-dagre/rank/index.js
var rank = (g3, ranker) => {
  switch (ranker) {
    case "network-simplex":
      networkSimplexRanker(g3);
      break;
    case "tight-tree":
      tightTreeRanker(g3);
      break;
    case "longest-path":
      longestPathRanker(g3);
      break;
    default:
      tightTreeRanker(g3);
  }
};
var longestPathRanker = longestPath;
var tightTreeRanker = (g3) => {
  longestPathWithLayer(g3);
  feasibleTreeWithLayer(g3);
};
var networkSimplexRanker = (g3) => {
  networkSimplex(g3);
};

// node_modules/@antv/layout/lib/antv-dagre/layout.js
var layout = (g3, options) => {
  const { edgeLabelSpace, keepNodeOrder, prevGraph, rankdir, ranksep } = options;
  if (!keepNodeOrder && prevGraph) {
    inheritOrder(g3, prevGraph);
  }
  const layoutGraph = buildLayoutGraph(g3);
  if (!!edgeLabelSpace) {
    options.ranksep = makeSpaceForEdgeLabels(layoutGraph, {
      rankdir,
      ranksep
    });
  }
  let dimension;
  try {
    dimension = runLayout(layoutGraph, options);
  } catch (e2) {
    if (e2.message === "Not possible to find intersection inside of the rectangle") {
      console.error("The following error may be caused by improper layer setting, please make sure your manual layer setting does not violate the graph's structure:\n", e2);
      return;
    }
    throw e2;
  }
  updateInputGraph(g3, layoutGraph);
  return dimension;
};
var runLayout = (g3, options) => {
  const { acyclicer, ranker, rankdir = "tb", nodeOrder, keepNodeOrder, align, nodesep = 50, edgesep = 20, ranksep = 50 } = options;
  removeSelfEdges(g3);
  run(g3, acyclicer);
  const { nestingRoot, nodeRankFactor } = run2(g3);
  rank(asNonCompoundGraph(g3), ranker);
  injectEdgeLabelProxies(g3);
  removeEmptyRanks(g3, nodeRankFactor);
  cleanup(g3, nestingRoot);
  normalizeRanks(g3);
  assignRankMinMax(g3);
  removeEdgeLabelProxies(g3);
  const dummyChains = [];
  run3(g3, dummyChains);
  parentDummyChains(g3, dummyChains);
  addBorderSegments(g3);
  if (keepNodeOrder) {
    initDataOrder(g3, nodeOrder);
  }
  order(g3, keepNodeOrder);
  insertSelfEdges(g3);
  adjust(g3, rankdir);
  position(g3, {
    align,
    nodesep,
    edgesep,
    ranksep
  });
  positionSelfEdges(g3);
  removeBorderNodes(g3);
  undo3(g3, dummyChains);
  fixupEdgeLabelCoords(g3);
  undo2(g3, rankdir);
  const { width: width2, height } = translateGraph(g3);
  assignNodeIntersects(g3);
  reversePointsForReversedEdges(g3);
  undo(g3);
  return { width: width2, height };
};
var inheritOrder = (currG, prevG) => {
  currG.getAllNodes().forEach((n2) => {
    const node = currG.getNode(n2.id);
    if (prevG.hasNode(n2.id)) {
      const prevNode = prevG.getNode(n2.id);
      node.data.fixorder = prevNode.data._order;
      delete prevNode.data._order;
    } else {
      delete node.data.fixorder;
    }
  });
};
var updateInputGraph = (inputGraph, layoutGraph) => {
  inputGraph.getAllNodes().forEach((v3) => {
    var _a;
    const inputLabel = inputGraph.getNode(v3.id);
    if (inputLabel) {
      const layoutLabel = layoutGraph.getNode(v3.id);
      inputLabel.data.x = layoutLabel.data.x;
      inputLabel.data.y = layoutLabel.data.y;
      inputLabel.data._order = layoutLabel.data.order;
      inputLabel.data._rank = layoutLabel.data.rank;
      if ((_a = layoutGraph.getChildren(v3.id)) === null || _a === void 0 ? void 0 : _a.length) {
        inputLabel.data.width = layoutLabel.data.width;
        inputLabel.data.height = layoutLabel.data.height;
      }
    }
  });
  inputGraph.getAllEdges().forEach((e2) => {
    const inputLabel = inputGraph.getEdge(e2.id);
    const layoutLabel = layoutGraph.getEdge(e2.id);
    inputLabel.data.points = layoutLabel ? layoutLabel.data.points : [];
    if (layoutLabel && layoutLabel.data.hasOwnProperty("x")) {
      inputLabel.data.x = layoutLabel.data.x;
      inputLabel.data.y = layoutLabel.data.y;
    }
  });
};
var nodeNumAttrs = ["width", "height", "layer", "fixorder"];
var nodeDefaults = { width: 0, height: 0 };
var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
var edgeDefaults = {
  minlen: 1,
  weight: 1,
  width: 0,
  height: 0,
  labeloffset: 10,
  labelpos: "r"
};
var edgeAttrs = ["labelpos"];
var buildLayoutGraph = (inputGraph) => {
  const g3 = new Graph2({ tree: [] });
  inputGraph.getAllNodes().forEach((v3) => {
    const node = canonicalize(inputGraph.getNode(v3.id).data);
    const defaultNode = Object.assign(Object.assign({}, nodeDefaults), node);
    const defaultAttrs = selectNumberAttrs(defaultNode, nodeNumAttrs);
    if (!g3.hasNode(v3.id)) {
      g3.addNode({
        id: v3.id,
        data: Object.assign({}, defaultAttrs)
      });
    }
    const parent = inputGraph.hasTreeStructure("combo") ? inputGraph.getParent(v3.id, "combo") : inputGraph.getParent(v3.id);
    if (!isNil(parent)) {
      if (!g3.hasNode(parent.id)) {
        g3.addNode(Object.assign({}, parent));
      }
      g3.setParent(v3.id, parent.id);
    }
  });
  inputGraph.getAllEdges().forEach((e2) => {
    const edge = canonicalize(inputGraph.getEdge(e2.id).data);
    const pickedProperties = {};
    edgeAttrs === null || edgeAttrs === void 0 ? void 0 : edgeAttrs.forEach((key) => {
      if (edge[key] !== void 0)
        pickedProperties[key] = edge[key];
    });
    g3.addEdge({
      id: e2.id,
      source: e2.source,
      target: e2.target,
      data: Object.assign({}, edgeDefaults, selectNumberAttrs(edge, edgeNumAttrs), pickedProperties)
    });
  });
  return g3;
};
var makeSpaceForEdgeLabels = (g3, options) => {
  const { ranksep = 0, rankdir } = options;
  g3.getAllNodes().forEach((node) => {
    if (!isNaN(node.data.layer)) {
      if (!node.data.layer)
        node.data.layer = 0;
    }
  });
  g3.getAllEdges().forEach((edge) => {
    var _a;
    edge.data.minlen *= 2;
    if (((_a = edge.data.labelpos) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== "c") {
      if (rankdir === "TB" || rankdir === "BT") {
        edge.data.width += edge.data.labeloffset;
      } else {
        edge.data.height += edge.data.labeloffset;
      }
    }
  });
  return ranksep / 2;
};
var injectEdgeLabelProxies = (g3) => {
  g3.getAllEdges().forEach((e2) => {
    if (e2.data.width && e2.data.height) {
      const v3 = g3.getNode(e2.source);
      const w3 = g3.getNode(e2.target);
      const label = {
        e: e2,
        rank: (w3.data.rank - v3.data.rank) / 2 + v3.data.rank
      };
      addDummyNode(g3, "edge-proxy", label, "_ep");
    }
  });
};
var assignRankMinMax = (g3) => {
  let maxRank2 = 0;
  g3.getAllNodes().forEach((node) => {
    var _a, _b;
    if (node.data.borderTop) {
      node.data.minRank = (_a = g3.getNode(node.data.borderTop)) === null || _a === void 0 ? void 0 : _a.data.rank;
      node.data.maxRank = (_b = g3.getNode(node.data.borderBottom)) === null || _b === void 0 ? void 0 : _b.data.rank;
      maxRank2 = Math.max(maxRank2, node.data.maxRank || -Infinity);
    }
  });
  return maxRank2;
};
var removeEdgeLabelProxies = (g3) => {
  g3.getAllNodes().forEach((node) => {
    if (node.data.dummy === "edge-proxy") {
      g3.getEdge(node.data.e.id).data.labelRank = node.data.rank;
      g3.removeNode(node.id);
    }
  });
};
var translateGraph = (g3, options) => {
  let minX;
  let maxX = 0;
  let minY;
  let maxY = 0;
  const { marginx: marginX = 0, marginy: marginY = 0 } = options || {};
  const getExtremes = (attrs) => {
    if (!attrs.data)
      return;
    const x4 = attrs.data.x;
    const y4 = attrs.data.y;
    const w3 = attrs.data.width;
    const h3 = attrs.data.height;
    if (!isNaN(x4) && !isNaN(w3)) {
      if (minX === void 0) {
        minX = x4 - w3 / 2;
      }
      minX = Math.min(minX, x4 - w3 / 2);
      maxX = Math.max(maxX, x4 + w3 / 2);
    }
    if (!isNaN(y4) && !isNaN(h3)) {
      if (minY === void 0) {
        minY = y4 - h3 / 2;
      }
      minY = Math.min(minY, y4 - h3 / 2);
      maxY = Math.max(maxY, y4 + h3 / 2);
    }
  };
  g3.getAllNodes().forEach((v3) => {
    getExtremes(v3);
  });
  g3.getAllEdges().forEach((e2) => {
    if (e2 === null || e2 === void 0 ? void 0 : e2.data.hasOwnProperty("x")) {
      getExtremes(e2);
    }
  });
  minX -= marginX;
  minY -= marginY;
  g3.getAllNodes().forEach((node) => {
    node.data.x -= minX;
    node.data.y -= minY;
  });
  g3.getAllEdges().forEach((edge) => {
    var _a;
    (_a = edge.data.points) === null || _a === void 0 ? void 0 : _a.forEach((p3) => {
      p3.x -= minX;
      p3.y -= minY;
    });
    if (edge.data.hasOwnProperty("x")) {
      edge.data.x -= minX;
    }
    if (edge.data.hasOwnProperty("y")) {
      edge.data.y -= minY;
    }
  });
  return {
    width: maxX - minX + marginX,
    height: maxY - minY + marginY
  };
};
var assignNodeIntersects = (g3) => {
  g3.getAllEdges().forEach((e2) => {
    const nodeV = g3.getNode(e2.source);
    const nodeW = g3.getNode(e2.target);
    let p1;
    let p22;
    if (!e2.data.points) {
      e2.data.points = [];
      p1 = { x: nodeW.data.x, y: nodeW.data.y };
      p22 = { x: nodeV.data.x, y: nodeV.data.y };
    } else {
      p1 = e2.data.points[0];
      p22 = e2.data.points[e2.data.points.length - 1];
    }
    e2.data.points.unshift(intersectRect(nodeV.data, p1));
    e2.data.points.push(intersectRect(nodeW.data, p22));
  });
};
var fixupEdgeLabelCoords = (g3) => {
  g3.getAllEdges().forEach((edge) => {
    if (edge.data.hasOwnProperty("x")) {
      if (edge.data.labelpos === "l" || edge.data.labelpos === "r") {
        edge.data.width -= edge.data.labeloffset;
      }
      switch (edge.data.labelpos) {
        case "l":
          edge.data.x -= edge.data.width / 2 + edge.data.labeloffset;
          break;
        case "r":
          edge.data.x += edge.data.width / 2 + edge.data.labeloffset;
          break;
      }
    }
  });
};
var reversePointsForReversedEdges = (g3) => {
  g3.getAllEdges().forEach((edge) => {
    var _a;
    if (edge.data.reversed) {
      (_a = edge.data.points) === null || _a === void 0 ? void 0 : _a.reverse();
    }
  });
};
var removeBorderNodes = (g3) => {
  g3.getAllNodes().forEach((v3) => {
    var _a, _b, _c;
    if ((_a = g3.getChildren(v3.id)) === null || _a === void 0 ? void 0 : _a.length) {
      const node = g3.getNode(v3.id);
      const t3 = g3.getNode(node.data.borderTop);
      const b3 = g3.getNode(node.data.borderBottom);
      const l3 = g3.getNode(node.data.borderLeft[((_b = node.data.borderLeft) === null || _b === void 0 ? void 0 : _b.length) - 1]);
      const r3 = g3.getNode(node.data.borderRight[((_c = node.data.borderRight) === null || _c === void 0 ? void 0 : _c.length) - 1]);
      node.data.width = Math.abs((r3 === null || r3 === void 0 ? void 0 : r3.data.x) - (l3 === null || l3 === void 0 ? void 0 : l3.data.x)) || 10;
      node.data.height = Math.abs((b3 === null || b3 === void 0 ? void 0 : b3.data.y) - (t3 === null || t3 === void 0 ? void 0 : t3.data.y)) || 10;
      node.data.x = ((l3 === null || l3 === void 0 ? void 0 : l3.data.x) || 0) + node.data.width / 2;
      node.data.y = ((t3 === null || t3 === void 0 ? void 0 : t3.data.y) || 0) + node.data.height / 2;
    }
  });
  g3.getAllNodes().forEach((n2) => {
    if (n2.data.dummy === "border") {
      g3.removeNode(n2.id);
    }
  });
};
var removeSelfEdges = (g3) => {
  g3.getAllEdges().forEach((e2) => {
    if (e2.source === e2.target) {
      const node = g3.getNode(e2.source);
      if (!node.data.selfEdges) {
        node.data.selfEdges = [];
      }
      node.data.selfEdges.push(e2);
      g3.removeEdge(e2.id);
    }
  });
};
var insertSelfEdges = (g3) => {
  const layers = buildLayerMatrix(g3);
  layers === null || layers === void 0 ? void 0 : layers.forEach((layer) => {
    let orderShift = 0;
    layer === null || layer === void 0 ? void 0 : layer.forEach((v3, i2) => {
      var _a;
      const node = g3.getNode(v3);
      node.data.order = i2 + orderShift;
      (_a = node.data.selfEdges) === null || _a === void 0 ? void 0 : _a.forEach((selfEdge) => {
        addDummyNode(g3, "selfedge", {
          width: selfEdge.data.width,
          height: selfEdge.data.height,
          rank: node.data.rank,
          order: i2 + ++orderShift,
          e: selfEdge
        }, "_se");
      });
      delete node.data.selfEdges;
    });
  });
};
var positionSelfEdges = (g3) => {
  g3.getAllNodes().forEach((v3) => {
    const node = g3.getNode(v3.id);
    if (node.data.dummy === "selfedge") {
      const selfNode = g3.getNode(node.data.e.source);
      const x4 = selfNode.data.x + selfNode.data.width / 2;
      const y4 = selfNode.data.y;
      const dx = node.data.x - x4;
      const dy = selfNode.data.height / 2;
      if (g3.hasEdge(node.data.e.id)) {
        g3.updateEdgeData(node.data.e.id, node.data.e.data);
      } else {
        g3.addEdge({
          id: node.data.e.id,
          source: node.data.e.source,
          target: node.data.e.target,
          data: node.data.e.data
        });
      }
      g3.removeNode(v3.id);
      node.data.e.data.points = [
        { x: x4 + 2 * dx / 3, y: y4 - dy },
        { x: x4 + 5 * dx / 6, y: y4 - dy },
        { y: y4, x: x4 + dx },
        { x: x4 + 5 * dx / 6, y: y4 + dy },
        { x: x4 + 2 * dx / 3, y: y4 + dy }
      ];
      node.data.e.data.x = node.data.x;
      node.data.e.data.y = node.data.y;
    }
  });
};
var selectNumberAttrs = (obj, attrs) => {
  const pickedProperties = {};
  attrs === null || attrs === void 0 ? void 0 : attrs.forEach((key) => {
    if (obj[key] === void 0)
      return;
    pickedProperties[key] = +obj[key];
  });
  return pickedProperties;
};
var canonicalize = (attrs = {}) => {
  const newAttrs = {};
  Object.keys(attrs).forEach((k2) => {
    newAttrs[k2.toLowerCase()] = attrs[k2];
  });
  return newAttrs;
};

// node_modules/@antv/layout/lib/util/array.js
var isArray2 = Array.isArray;

// node_modules/@antv/layout/lib/util/math.js
var floydWarshall = (adjMatrix) => {
  const dist = [];
  const size2 = adjMatrix.length;
  for (let i2 = 0; i2 < size2; i2 += 1) {
    dist[i2] = [];
    for (let j2 = 0; j2 < size2; j2 += 1) {
      if (i2 === j2) {
        dist[i2][j2] = 0;
      } else if (adjMatrix[i2][j2] === 0 || !adjMatrix[i2][j2]) {
        dist[i2][j2] = Infinity;
      } else {
        dist[i2][j2] = adjMatrix[i2][j2];
      }
    }
  }
  for (let k2 = 0; k2 < size2; k2 += 1) {
    for (let i2 = 0; i2 < size2; i2 += 1) {
      for (let j2 = 0; j2 < size2; j2 += 1) {
        if (dist[i2][j2] > dist[i2][k2] + dist[k2][j2]) {
          dist[i2][j2] = dist[i2][k2] + dist[k2][j2];
        }
      }
    }
  }
  return dist;
};
var getAdjMatrix = (data, directed) => {
  const { nodes, edges } = data;
  const matrix2 = [];
  const nodeMap = {};
  if (!nodes) {
    throw new Error("invalid nodes data!");
  }
  if (nodes) {
    nodes.forEach((node, i2) => {
      nodeMap[node.id] = i2;
      const row = [];
      matrix2.push(row);
    });
  }
  edges === null || edges === void 0 ? void 0 : edges.forEach((e2) => {
    const { source, target } = e2;
    const sIndex = nodeMap[source];
    const tIndex = nodeMap[target];
    if (sIndex === void 0 || tIndex === void 0)
      return;
    matrix2[sIndex][tIndex] = 1;
    if (!directed) {
      matrix2[tIndex][sIndex] = 1;
    }
  });
  return matrix2;
};
var scaleMatrix = (matrix2, ratio) => {
  const result = [];
  matrix2.forEach((row) => {
    const newRow = [];
    row.forEach((v3) => {
      newRow.push(v3 * ratio);
    });
    result.push(newRow);
  });
  return result;
};
var getLayoutBBox = (nodes) => {
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  nodes.forEach((node) => {
    let size2 = node.data.size;
    if (isArray2(size2)) {
      if (size2.length === 1)
        size2 = [size2[0], size2[0]];
    } else if (isNumber(size2)) {
      size2 = [size2, size2];
    } else if (size2 === void 0 || isNaN(size2)) {
      size2 = [30, 30];
    }
    const halfSize = [size2[0] / 2, size2[1] / 2];
    const left = node.data.x - halfSize[0];
    const right = node.data.x + halfSize[0];
    const top = node.data.y - halfSize[1];
    const bottom = node.data.y + halfSize[1];
    if (minX > left)
      minX = left;
    if (minY > top)
      minY = top;
    if (maxX < right)
      maxX = right;
    if (maxY < bottom)
      maxY = bottom;
  });
  return { minX, minY, maxX, maxY };
};
var getEuclideanDistance = (p1, p22) => Math.sqrt((p1.x - p22.x) * (p1.x - p22.x) + (p1.y - p22.y) * (p1.y - p22.y));
var graphTreeDfs = (graph, nodes, fn, mode = "TB", treeKey, stopFns = {}) => {
  if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
    return;
  const { stopBranchFn, stopAllFn } = stopFns;
  for (let i2 = 0; i2 < nodes.length; i2++) {
    const node = nodes[i2];
    if (!graph.hasNode(node.id))
      continue;
    if (stopBranchFn === null || stopBranchFn === void 0 ? void 0 : stopBranchFn(node))
      continue;
    if (stopAllFn === null || stopAllFn === void 0 ? void 0 : stopAllFn(node))
      return;
    if (mode === "TB")
      fn(node);
    graphTreeDfs(graph, graph.getChildren(node.id, treeKey), fn, mode, treeKey, stopFns);
    if (mode !== "TB")
      fn(node);
  }
};

// node_modules/@antv/layout/lib/util/object.js
var clone2 = (target) => {
  if (target === null) {
    return target;
  }
  if (target instanceof Date) {
    return new Date(target.getTime());
  }
  if (target instanceof Array) {
    const cp = [];
    target.forEach((v3) => {
      cp.push(v3);
    });
    return cp.map((n2) => clone2(n2));
  }
  if (typeof target === "object") {
    const cp = {};
    Object.keys(target).forEach((k2) => {
      cp[k2] = clone2(target[k2]);
    });
    return cp;
  }
  return target;
};
var cloneFormatData = (target, initRange) => {
  const cloned = clone2(target);
  cloned.data = cloned.data || {};
  if (initRange) {
    if (!isNumber(cloned.data.x))
      cloned.data.x = Math.random() * initRange[0];
    if (!isNumber(cloned.data.y))
      cloned.data.y = Math.random() * initRange[1];
  }
  return cloned;
};

// node_modules/@antv/layout/lib/util/size.js
function parseSize2(size2) {
  if (!size2)
    return [0, 0, 0];
  if (isNumber(size2))
    return [size2, size2, size2];
  else if (size2.length === 0)
    return [0, 0, 0];
  const [x4, y4 = x4, z4 = x4] = size2;
  return [x4, y4, z4];
}

// node_modules/@antv/layout/lib/util/function.js
function formatNumberFn(defaultValue, value) {
  let resultFunc;
  if (isFunction(value)) {
    resultFunc = value;
  } else if (isNumber(value)) {
    resultFunc = () => value;
  } else {
    resultFunc = () => defaultValue;
  }
  return resultFunc;
}
function formatSizeFn(defaultValue, value, resultIsNumber = true) {
  if (!value && value !== 0) {
    return (d3) => {
      const { size: size2 } = d3.data || {};
      if (size2) {
        if (Array.isArray(size2))
          return resultIsNumber ? Math.max(...size2) || defaultValue : size2;
        if (is_object_default(size2) && size2.width && size2.height) {
          return resultIsNumber ? Math.max(size2.width, size2.height) || defaultValue : [size2.width, size2.height];
        }
        return size2;
      }
      return defaultValue;
    };
  }
  if (isFunction(value))
    return value;
  if (isNumber(value))
    return () => value;
  if (Array.isArray(value)) {
    return () => {
      if (resultIsNumber)
        return Math.max(...value) || defaultValue;
      return value;
    };
  }
  if (is_object_default(value) && value.width && value.height) {
    return () => {
      if (resultIsNumber)
        return Math.max(value.width, value.height) || defaultValue;
      return [value.width, value.height];
    };
  }
  return () => defaultValue;
}
var formatNodeSizeToNumber = (nodeSize, nodeSpacing, defaultNodeSize = 10) => {
  let nodeSizeFunc;
  const nodeSpacingFunc = typeof nodeSpacing === "function" ? nodeSpacing : () => nodeSpacing || 0;
  if (!nodeSize) {
    nodeSizeFunc = (d3) => {
      var _a, _b, _c;
      if ((_a = d3.data) === null || _a === void 0 ? void 0 : _a.bboxSize)
        return (_b = d3.data) === null || _b === void 0 ? void 0 : _b.bboxSize;
      if ((_c = d3.data) === null || _c === void 0 ? void 0 : _c.size) {
        const dataSize = d3.data.size;
        if (Array.isArray(dataSize))
          return dataSize;
        if (is_object_default(dataSize))
          return [dataSize.width, dataSize.height];
        return dataSize;
      }
      return defaultNodeSize;
    };
  } else if (Array.isArray(nodeSize)) {
    nodeSizeFunc = (d3) => nodeSize;
  } else if (isFunction(nodeSize)) {
    nodeSizeFunc = nodeSize;
  } else {
    nodeSizeFunc = (d3) => nodeSize;
  }
  const func = (d3) => {
    const nodeSize2 = nodeSizeFunc(d3);
    const nodeSpacing2 = nodeSpacingFunc(d3);
    return Math.max(...parseSize2(nodeSize2)) + nodeSpacing2;
  };
  return func;
};

// node_modules/@antv/layout/lib/antv-dagre.js
var DEFAULTS_LAYOUT_OPTIONS = {
  rankdir: "TB",
  nodesep: 50,
  ranksep: 50,
  edgeLabelSpace: true,
  ranker: "tight-tree",
  controlPoints: false,
  radial: false,
  focusNode: null
  // radial  true 
};
var AntVDagreLayout = class {
  constructor(options = {}) {
    this.options = options;
    this.id = "antv-dagre";
    this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS), options);
  }
  /**
   * Return the positions of nodes and edges(if needed).
   */
  execute(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.genericDagreLayout(false, graph, options);
    });
  }
  /**
   * To directly assign the positions to the nodes.
   */
  assign(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.genericDagreLayout(true, graph, options);
    });
  }
  genericDagreLayout(assign, graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const mergedOptions = Object.assign(Object.assign({}, this.options), options);
      const {
        nodeSize,
        align,
        rankdir = "TB",
        ranksep,
        nodesep,
        ranksepFunc,
        nodesepFunc,
        edgeLabelSpace,
        ranker,
        nodeOrder,
        begin,
        controlPoints,
        radial,
        sortByCombo,
        // focusNode,
        preset
      } = mergedOptions;
      const g3 = new Graph2({
        tree: []
      });
      const ranksepfunc = formatNumberFn(ranksep || 50, ranksepFunc);
      const nodesepfunc = formatNumberFn(nodesep || 50, nodesepFunc);
      let horisep = nodesepfunc;
      let vertisep = ranksepfunc;
      if (rankdir === "LR" || rankdir === "RL") {
        horisep = ranksepfunc;
        vertisep = nodesepfunc;
      }
      const nodeSizeFunc = formatSizeFn(10, nodeSize, false);
      const nodes = graph.getAllNodes();
      const edges = graph.getAllEdges();
      nodes.forEach((node) => {
        const size2 = parseSize2(nodeSizeFunc(node));
        const verti = vertisep(node);
        const hori = horisep(node);
        const width2 = size2[0] + 2 * hori;
        const height = size2[1] + 2 * verti;
        const layer = node.data.layer;
        if (isNumber(layer)) {
          g3.addNode({
            id: node.id,
            data: { width: width2, height, layer }
          });
        } else {
          g3.addNode({
            id: node.id,
            data: { width: width2, height }
          });
        }
      });
      if (sortByCombo) {
        g3.attachTreeStructure("combo");
        nodes.forEach((node) => {
          const { parentId } = node.data;
          if (parentId === void 0)
            return;
          if (g3.hasNode(parentId)) {
            g3.setParent(node.id, parentId, "combo");
          }
        });
      }
      edges.forEach((edge) => {
        g3.addEdge({
          id: edge.id,
          source: edge.source,
          target: edge.target,
          data: {
            weight: edge.data.weight || 1
          }
        });
      });
      let prevGraph = void 0;
      if (preset === null || preset === void 0 ? void 0 : preset.length) {
        prevGraph = new Graph2({
          nodes: preset
        });
      }
      layout(g3, {
        prevGraph,
        edgeLabelSpace,
        keepNodeOrder: !!nodeOrder,
        nodeOrder: nodeOrder || [],
        acyclicer: "greedy",
        ranker,
        rankdir,
        nodesep,
        align
      });
      const layoutTopLeft = [0, 0];
      if (begin) {
        let minX = Infinity;
        let minY = Infinity;
        g3.getAllNodes().forEach((node) => {
          if (minX > node.data.x)
            minX = node.data.x;
          if (minY > node.data.y)
            minY = node.data.y;
        });
        g3.getAllEdges().forEach((edge) => {
          var _a;
          (_a = edge.data.points) === null || _a === void 0 ? void 0 : _a.forEach((point3) => {
            if (minX > point3.x)
              minX = point3.x;
            if (minY > point3.y)
              minY = point3.y;
          });
        });
        layoutTopLeft[0] = begin[0] - minX;
        layoutTopLeft[1] = begin[1] - minY;
      }
      const isHorizontal2 = rankdir === "LR" || rankdir === "RL";
      if (radial) {
      } else {
        const layerCoords = /* @__PURE__ */ new Set();
        const isInvert = rankdir === "BT" || rankdir === "RL";
        const layerCoordSort = isInvert ? (a3, b3) => b3 - a3 : (a3, b3) => a3 - b3;
        g3.getAllNodes().forEach((node) => {
          node.data.x = node.data.x + layoutTopLeft[0];
          node.data.y = node.data.y + layoutTopLeft[1];
          layerCoords.add(isHorizontal2 ? node.data.x : node.data.y);
        });
        const layerCoordsArr = Array.from(layerCoords).sort(layerCoordSort);
        const isDifferentLayer = isHorizontal2 ? (point1, point22) => point1.x !== point22.x : (point1, point22) => point1.y !== point22.y;
        const filterControlPointsOutOfBoundary = isHorizontal2 ? (ps, point1, point22) => {
          const max2 = Math.max(point1.y, point22.y);
          const min2 = Math.min(point1.y, point22.y);
          return ps.filter((point3) => point3.y <= max2 && point3.y >= min2);
        } : (ps, point1, point22) => {
          const max2 = Math.max(point1.x, point22.x);
          const min2 = Math.min(point1.x, point22.x);
          return ps.filter((point3) => point3.x <= max2 && point3.x >= min2);
        };
        g3.getAllEdges().forEach((edge, i2) => {
          var _a;
          if (edgeLabelSpace && controlPoints && edge.data.type !== "loop") {
            edge.data.controlPoints = getControlPoints2((_a = edge.data.points) === null || _a === void 0 ? void 0 : _a.map(({ x: x4, y: y4 }) => ({
              x: x4 + layoutTopLeft[0],
              y: y4 + layoutTopLeft[1]
            })), g3.getNode(edge.source), g3.getNode(edge.target), layerCoordsArr, isHorizontal2, isDifferentLayer, filterControlPointsOutOfBoundary);
          }
        });
      }
      let layoutNodes = [];
      layoutNodes = g3.getAllNodes().map((node) => cloneFormatData(node));
      const layoutEdges = g3.getAllEdges();
      if (assign) {
        layoutNodes.forEach((node) => {
          graph.mergeNodeData(node.id, {
            x: node.data.x,
            y: node.data.y
          });
        });
        layoutEdges.forEach((edge) => {
          graph.mergeEdgeData(edge.id, {
            controlPoints: edge.data.controlPoints
          });
        });
      }
      const result = {
        nodes: layoutNodes,
        edges: layoutEdges
      };
      return result;
    });
  }
};
var getControlPoints2 = (points, sourceNode, targetNode, layerCoordsArr, isHorizontal2, isDifferentLayer, filterControlPointsOutOfBoundary) => {
  let controlPoints = (points === null || points === void 0 ? void 0 : points.slice(1, points.length - 1)) || [];
  if (sourceNode && targetNode) {
    let { x: sourceX, y: sourceY } = sourceNode.data;
    let { x: targetX, y: targetY } = targetNode.data;
    if (isHorizontal2) {
      sourceX = sourceNode.data.y;
      sourceY = sourceNode.data.x;
      targetX = targetNode.data.y;
      targetY = targetNode.data.x;
    }
    if (targetY !== sourceY && sourceX !== targetX) {
      const sourceLayer = layerCoordsArr.indexOf(sourceY);
      const sourceNextLayerCoord = layerCoordsArr[sourceLayer + 1];
      if (sourceNextLayerCoord) {
        const firstControlPoint = controlPoints[0];
        const insertStartControlPoint = isHorizontal2 ? {
          x: (sourceY + sourceNextLayerCoord) / 2,
          y: (firstControlPoint === null || firstControlPoint === void 0 ? void 0 : firstControlPoint.y) || targetX
        } : {
          x: (firstControlPoint === null || firstControlPoint === void 0 ? void 0 : firstControlPoint.x) || targetX,
          y: (sourceY + sourceNextLayerCoord) / 2
        };
        if (!firstControlPoint || isDifferentLayer(firstControlPoint, insertStartControlPoint)) {
          controlPoints.unshift(insertStartControlPoint);
        }
      }
      const targetLayer = layerCoordsArr.indexOf(targetY);
      const layerDiff = Math.abs(targetLayer - sourceLayer);
      if (layerDiff === 1) {
        controlPoints = filterControlPointsOutOfBoundary(controlPoints, sourceNode.data, targetNode.data);
        if (!controlPoints.length) {
          controlPoints.push(isHorizontal2 ? {
            x: (sourceY + targetY) / 2,
            y: sourceX
          } : {
            x: sourceX,
            y: (sourceY + targetY) / 2
          });
        }
      } else if (layerDiff > 1) {
        const targetLastLayerCoord = layerCoordsArr[targetLayer - 1];
        if (targetLastLayerCoord) {
          const lastControlPoints = controlPoints[controlPoints.length - 1];
          const insertEndControlPoint = isHorizontal2 ? {
            x: (targetY + targetLastLayerCoord) / 2,
            y: (lastControlPoints === null || lastControlPoints === void 0 ? void 0 : lastControlPoints.y) || targetX
          } : {
            x: (lastControlPoints === null || lastControlPoints === void 0 ? void 0 : lastControlPoints.x) || sourceX,
            y: (targetY + targetLastLayerCoord) / 2
          };
          if (!lastControlPoints || isDifferentLayer(lastControlPoints, insertEndControlPoint)) {
            controlPoints.push(insertEndControlPoint);
          }
        }
      }
    }
  }
  return controlPoints;
};

// node_modules/@antv/layout/lib/util/common.js
var handleSingleNodeGraph = (graph, assign, center) => {
  const nodes = graph.getAllNodes();
  const edges = graph.getAllEdges();
  if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length)) {
    const result = { nodes: [], edges };
    return result;
  }
  if (nodes.length === 1) {
    if (assign) {
      graph.mergeNodeData(nodes[0].id, {
        x: center[0],
        y: center[1]
      });
    }
    const result = {
      nodes: [
        Object.assign(Object.assign({}, nodes[0]), { data: Object.assign(Object.assign({}, nodes[0].data), { x: center[0], y: center[1] }) })
      ],
      edges
    };
    return result;
  }
};

// node_modules/@antv/layout/lib/circular.js
var DEFAULTS_LAYOUT_OPTIONS2 = {
  radius: null,
  startRadius: null,
  endRadius: null,
  startAngle: 0,
  endAngle: 2 * Math.PI,
  clockwise: true,
  divisions: 1,
  ordering: null,
  angleRatio: 1
};
var CircularLayout = class {
  constructor(options = {}) {
    this.options = options;
    this.id = "circular";
    this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS2), options);
  }
  /**
   * Return the positions of nodes and edges(if needed).
   */
  execute(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.genericCircularLayout(false, graph, options);
    });
  }
  /**
   * To directly assign the positions to the nodes.
   */
  assign(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.genericCircularLayout(true, graph, options);
    });
  }
  genericCircularLayout(assign, graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const mergedOptions = Object.assign(Object.assign({}, this.options), options);
      const { width: width2, height, center, divisions, startAngle = 0, endAngle = 2 * Math.PI, angleRatio, ordering, clockwise, nodeSpacing: paramNodeSpacing, nodeSize: paramNodeSize } = mergedOptions;
      const nodes = graph.getAllNodes();
      const edges = graph.getAllEdges();
      const [calculatedWidth, calculatedHeight, calculatedCenter] = calculateCenter(width2, height, center);
      const n2 = nodes === null || nodes === void 0 ? void 0 : nodes.length;
      if (!n2 || n2 === 1) {
        return handleSingleNodeGraph(graph, assign, calculatedCenter);
      }
      const angleStep = (endAngle - startAngle) / n2;
      let { radius, startRadius, endRadius } = mergedOptions;
      if (paramNodeSpacing) {
        const nodeSpacing = formatNumberFn(10, paramNodeSpacing);
        const nodeSize = formatSizeFn(10, paramNodeSize);
        let maxNodeSize = -Infinity;
        nodes.forEach((node) => {
          const nSize = nodeSize(node);
          if (maxNodeSize < nSize)
            maxNodeSize = nSize;
        });
        let perimeter = 0;
        nodes.forEach((node, i2) => {
          if (i2 === 0)
            perimeter += maxNodeSize || 10;
          else
            perimeter += (nodeSpacing(node) || 0) + (maxNodeSize || 10);
        });
        radius = perimeter / (2 * Math.PI);
      } else if (!radius && !startRadius && !endRadius) {
        radius = Math.min(calculatedHeight, calculatedWidth) / 2;
      } else if (!startRadius && endRadius) {
        startRadius = endRadius;
      } else if (startRadius && !endRadius) {
        endRadius = startRadius;
      }
      const astep = angleStep * angleRatio;
      let layoutNodes = [];
      if (ordering === "topology") {
        layoutNodes = topologyOrdering(graph, nodes);
      } else if (ordering === "topology-directed") {
        layoutNodes = topologyOrdering(graph, nodes, true);
      } else if (ordering === "degree") {
        layoutNodes = degreeOrdering(graph, nodes);
      } else {
        layoutNodes = nodes.map((node) => cloneFormatData(node));
      }
      const divN = Math.ceil(n2 / divisions);
      for (let i2 = 0; i2 < n2; ++i2) {
        let r3 = radius;
        if (!r3 && startRadius !== null && endRadius !== null) {
          r3 = startRadius + i2 * (endRadius - startRadius) / (n2 - 1);
        }
        if (!r3) {
          r3 = 10 + i2 * 100 / (n2 - 1);
        }
        let angle2 = startAngle + i2 % divN * astep + 2 * Math.PI / divisions * Math.floor(i2 / divN);
        if (!clockwise) {
          angle2 = endAngle - i2 % divN * astep - 2 * Math.PI / divisions * Math.floor(i2 / divN);
        }
        layoutNodes[i2].data.x = calculatedCenter[0] + Math.cos(angle2) * r3;
        layoutNodes[i2].data.y = calculatedCenter[1] + Math.sin(angle2) * r3;
      }
      if (assign) {
        layoutNodes.forEach((node) => {
          graph.mergeNodeData(node.id, {
            x: node.data.x,
            y: node.data.y
          });
        });
      }
      const result = {
        nodes: layoutNodes,
        edges
      };
      return result;
    });
  }
};
var topologyOrdering = (graph, nodes, directed = false) => {
  const orderedCNodes = [cloneFormatData(nodes[0])];
  const pickFlags = {};
  const n2 = nodes.length;
  pickFlags[nodes[0].id] = true;
  let k2 = 0;
  nodes.forEach((node, i2) => {
    if (i2 !== 0) {
      if ((i2 === n2 - 1 || graph.getDegree(node.id, "both") !== graph.getDegree(nodes[i2 + 1].id, "both") || graph.areNeighbors(orderedCNodes[k2].id, node.id)) && !pickFlags[node.id]) {
        orderedCNodes.push(cloneFormatData(node));
        pickFlags[node.id] = true;
        k2++;
      } else {
        const children = directed ? graph.getSuccessors(orderedCNodes[k2].id) : graph.getNeighbors(orderedCNodes[k2].id);
        let foundChild = false;
        for (let j2 = 0; j2 < children.length; j2++) {
          const child = children[j2];
          if (graph.getDegree(child.id) === graph.getDegree(node.id) && !pickFlags[child.id]) {
            orderedCNodes.push(cloneFormatData(child));
            pickFlags[child.id] = true;
            foundChild = true;
            break;
          }
        }
        let ii = 0;
        while (!foundChild) {
          if (!pickFlags[nodes[ii].id]) {
            orderedCNodes.push(cloneFormatData(nodes[ii]));
            pickFlags[nodes[ii].id] = true;
            foundChild = true;
          }
          ii++;
          if (ii === n2) {
            break;
          }
        }
      }
    }
  });
  return orderedCNodes;
};
function degreeOrdering(graph, nodes) {
  const orderedNodes = [];
  nodes.forEach((node, i2) => {
    orderedNodes.push(cloneFormatData(node));
  });
  orderedNodes.sort((nodeA, nodeB) => graph.getDegree(nodeA.id, "both") - graph.getDegree(nodeB.id, "both"));
  return orderedNodes;
}
var calculateCenter = (width2, height, center) => {
  let calculatedWidth = width2;
  let calculatedHeight = height;
  let calculatedCenter = center;
  if (!calculatedWidth && typeof window !== "undefined") {
    calculatedWidth = window.innerWidth;
  }
  if (!calculatedHeight && typeof window !== "undefined") {
    calculatedHeight = window.innerHeight;
  }
  if (!calculatedCenter) {
    calculatedCenter = [calculatedWidth / 2, calculatedHeight / 2];
  }
  return [calculatedWidth, calculatedHeight, calculatedCenter];
};

// node_modules/@antv/layout/lib/concentric.js
var DEFAULTS_LAYOUT_OPTIONS3 = {
  nodeSize: 30,
  nodeSpacing: 10,
  preventOverlap: false,
  sweep: void 0,
  equidistant: false,
  startAngle: 3 / 2 * Math.PI,
  clockwise: true,
  maxLevelDiff: void 0,
  sortBy: "degree"
};
var ConcentricLayout = class {
  constructor(options = {}) {
    this.options = options;
    this.id = "concentric";
    this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS3), options);
  }
  /**
   * Return the positions of nodes and edges(if needed).
   */
  execute(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.genericConcentricLayout(false, graph, options);
    });
  }
  /**
   * To directly assign the positions to the nodes.
   */
  assign(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.genericConcentricLayout(true, graph, options);
    });
  }
  genericConcentricLayout(assign, graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const mergedOptions = Object.assign(Object.assign({}, this.options), options);
      const { center: propsCenter, width: propsWidth, height: propsHeight, sortBy: propsSortBy, maxLevelDiff: propsMaxLevelDiff, sweep: propsSweep, clockwise, equidistant, preventOverlap, startAngle = 3 / 2 * Math.PI, nodeSize, nodeSpacing } = mergedOptions;
      const nodes = graph.getAllNodes();
      const edges = graph.getAllEdges();
      const width2 = !propsWidth && typeof window !== "undefined" ? window.innerWidth : propsWidth;
      const height = !propsHeight && typeof window !== "undefined" ? window.innerHeight : propsHeight;
      const center = !propsCenter ? [width2 / 2, height / 2] : propsCenter;
      if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length) || nodes.length === 1) {
        return handleSingleNodeGraph(graph, assign, center);
      }
      const layoutNodes = [];
      let maxNodeSize;
      let maxNodeSpacing = 0;
      if (isArray2(nodeSize)) {
        maxNodeSize = Math.max(nodeSize[0], nodeSize[1]);
      } else if (isFunction(nodeSize)) {
        maxNodeSize = -Infinity;
        nodes.forEach((node) => {
          const currentSize = Math.max(...parseSize2(nodeSize(node)));
          if (currentSize > maxNodeSize)
            maxNodeSize = currentSize;
        });
      } else {
        maxNodeSize = nodeSize;
      }
      if (isArray2(nodeSpacing)) {
        maxNodeSpacing = Math.max(nodeSpacing[0], nodeSpacing[1]);
      } else if (isNumber(nodeSpacing)) {
        maxNodeSpacing = nodeSpacing;
      }
      nodes.forEach((node) => {
        const cnode = cloneFormatData(node);
        layoutNodes.push(cnode);
        let nodeSize2 = maxNodeSize;
        const { data } = cnode;
        if (isArray2(data.size)) {
          nodeSize2 = Math.max(data.size[0], data.size[1]);
        } else if (isNumber(data.size)) {
          nodeSize2 = data.size;
        } else if (is_object_default(data.size)) {
          nodeSize2 = Math.max(data.size.width, data.size.height);
        }
        maxNodeSize = Math.max(maxNodeSize, nodeSize2);
        if (isFunction(nodeSpacing)) {
          maxNodeSpacing = Math.max(nodeSpacing(node), maxNodeSpacing);
        }
      });
      const nodeIdxMap = {};
      layoutNodes.forEach((node, i2) => {
        nodeIdxMap[node.id] = i2;
      });
      let sortBy = propsSortBy;
      if (!isString(sortBy) || layoutNodes[0].data[sortBy] === void 0) {
        sortBy = "degree";
      }
      if (sortBy === "degree") {
        layoutNodes.sort((n1, n2) => graph.getDegree(n2.id, "both") - graph.getDegree(n1.id, "both"));
      } else {
        layoutNodes.sort((n1, n2) => n2.data[sortBy] - n1.data[sortBy]);
      }
      const maxValueNode = layoutNodes[0];
      const maxLevelDiff = (propsMaxLevelDiff || (sortBy === "degree" ? graph.getDegree(maxValueNode.id, "both") : maxValueNode.data[sortBy])) / 4;
      const levels = [{ nodes: [] }];
      let currentLevel = levels[0];
      layoutNodes.forEach((node) => {
        if (currentLevel.nodes.length > 0) {
          const diff = sortBy === "degree" ? Math.abs(graph.getDegree(currentLevel.nodes[0].id, "both") - graph.getDegree(node.id, "both")) : Math.abs(currentLevel.nodes[0].data[sortBy] - node.data[sortBy]);
          if (maxLevelDiff && diff >= maxLevelDiff) {
            currentLevel = { nodes: [] };
            levels.push(currentLevel);
          }
        }
        currentLevel.nodes.push(node);
      });
      let minDist = maxNodeSize + maxNodeSpacing;
      if (!preventOverlap) {
        const firstLvlHasMulti = levels.length > 0 && levels[0].nodes.length > 1;
        const maxR = Math.min(width2, height) / 2 - minDist;
        const rStep = maxR / (levels.length + (firstLvlHasMulti ? 1 : 0));
        minDist = Math.min(minDist, rStep);
      }
      let r3 = 0;
      levels.forEach((level) => {
        const sweep = propsSweep === void 0 ? 2 * Math.PI - 2 * Math.PI / level.nodes.length : propsSweep;
        level.dTheta = sweep / Math.max(1, level.nodes.length - 1);
        if (level.nodes.length > 1 && preventOverlap) {
          const dcos = Math.cos(level.dTheta) - Math.cos(0);
          const dsin = Math.sin(level.dTheta) - Math.sin(0);
          const rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin));
          r3 = Math.max(rMin, r3);
        }
        level.r = r3;
        r3 += minDist;
      });
      if (equidistant) {
        let rDeltaMax = 0;
        let rr = 0;
        for (let i2 = 0; i2 < levels.length; i2++) {
          const level = levels[i2];
          const rDelta = (level.r || 0) - rr;
          rDeltaMax = Math.max(rDeltaMax, rDelta);
        }
        rr = 0;
        levels.forEach((level, i2) => {
          if (i2 === 0) {
            rr = level.r || 0;
          }
          level.r = rr;
          rr += rDeltaMax;
        });
      }
      levels.forEach((level) => {
        const dTheta = level.dTheta || 0;
        const rr = level.r || 0;
        level.nodes.forEach((node, j2) => {
          const theta = startAngle + (clockwise ? 1 : -1) * dTheta * j2;
          node.data.x = center[0] + rr * Math.cos(theta);
          node.data.y = center[1] + rr * Math.sin(theta);
        });
      });
      if (assign) {
        layoutNodes.forEach((node) => graph.mergeNodeData(node.id, {
          x: node.data.x,
          y: node.data.y
        }));
      }
      const result = {
        nodes: layoutNodes,
        edges
      };
      return result;
    });
  }
};

// node_modules/d3-octree/src/add.js
function add_default(d3) {
  const x4 = +this._x.call(null, d3), y4 = +this._y.call(null, d3), z4 = +this._z.call(null, d3);
  return add2(this.cover(x4, y4, z4), x4, y4, z4, d3);
}
function add2(tree, x4, y4, z4, d3) {
  if (isNaN(x4) || isNaN(y4) || isNaN(z4)) return tree;
  var parent, node = tree._root, leaf = { data: d3 }, x0 = tree._x0, y0 = tree._y0, z0 = tree._z0, x1 = tree._x1, y1 = tree._y1, z1 = tree._z1, xm, ym, zm, xp, yp, zp, right, bottom, deep, i2, j2;
  if (!node) return tree._root = leaf, tree;
  while (node.length) {
    if (right = x4 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y4 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
    if (deep = z4 >= (zm = (z0 + z1) / 2)) z0 = zm;
    else z1 = zm;
    if (parent = node, !(node = node[i2 = deep << 2 | bottom << 1 | right])) return parent[i2] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  zp = +tree._z.call(null, node.data);
  if (x4 === xp && y4 === yp && z4 === zp) return leaf.next = node, parent ? parent[i2] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i2] = new Array(8) : tree._root = new Array(8);
    if (right = x4 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y4 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
    if (deep = z4 >= (zm = (z0 + z1) / 2)) z0 = zm;
    else z1 = zm;
  } while ((i2 = deep << 2 | bottom << 1 | right) === (j2 = (zp >= zm) << 2 | (yp >= ym) << 1 | xp >= xm));
  return parent[j2] = node, parent[i2] = leaf, tree;
}
function addAll(data) {
  if (!Array.isArray(data)) data = Array.from(data);
  const n2 = data.length;
  const xz = new Float64Array(n2);
  const yz = new Float64Array(n2);
  const zz = new Float64Array(n2);
  let x0 = Infinity, y0 = Infinity, z0 = Infinity, x1 = -Infinity, y1 = -Infinity, z1 = -Infinity;
  for (let i2 = 0, d3, x4, y4, z4; i2 < n2; ++i2) {
    if (isNaN(x4 = +this._x.call(null, d3 = data[i2])) || isNaN(y4 = +this._y.call(null, d3)) || isNaN(z4 = +this._z.call(null, d3))) continue;
    xz[i2] = x4;
    yz[i2] = y4;
    zz[i2] = z4;
    if (x4 < x0) x0 = x4;
    if (x4 > x1) x1 = x4;
    if (y4 < y0) y0 = y4;
    if (y4 > y1) y1 = y4;
    if (z4 < z0) z0 = z4;
    if (z4 > z1) z1 = z4;
  }
  if (x0 > x1 || y0 > y1 || z0 > z1) return this;
  this.cover(x0, y0, z0).cover(x1, y1, z1);
  for (let i2 = 0; i2 < n2; ++i2) {
    add2(this, xz[i2], yz[i2], zz[i2], data[i2]);
  }
  return this;
}

// node_modules/d3-octree/src/cover.js
function cover_default(x4, y4, z4) {
  if (isNaN(x4 = +x4) || isNaN(y4 = +y4) || isNaN(z4 = +z4)) return this;
  var x0 = this._x0, y0 = this._y0, z0 = this._z0, x1 = this._x1, y1 = this._y1, z1 = this._z1;
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x4)) + 1;
    y1 = (y0 = Math.floor(y4)) + 1;
    z1 = (z0 = Math.floor(z4)) + 1;
  } else {
    var t3 = x1 - x0 || 1, node = this._root, parent, i2;
    while (x0 > x4 || x4 >= x1 || y0 > y4 || y4 >= y1 || z0 > z4 || z4 >= z1) {
      i2 = (z4 < z0) << 2 | (y4 < y0) << 1 | x4 < x0;
      parent = new Array(8), parent[i2] = node, node = parent, t3 *= 2;
      switch (i2) {
        case 0:
          x1 = x0 + t3, y1 = y0 + t3, z1 = z0 + t3;
          break;
        case 1:
          x0 = x1 - t3, y1 = y0 + t3, z1 = z0 + t3;
          break;
        case 2:
          x1 = x0 + t3, y0 = y1 - t3, z1 = z0 + t3;
          break;
        case 3:
          x0 = x1 - t3, y0 = y1 - t3, z1 = z0 + t3;
          break;
        case 4:
          x1 = x0 + t3, y1 = y0 + t3, z0 = z1 - t3;
          break;
        case 5:
          x0 = x1 - t3, y1 = y0 + t3, z0 = z1 - t3;
          break;
        case 6:
          x1 = x0 + t3, y0 = y1 - t3, z0 = z1 - t3;
          break;
        case 7:
          x0 = x1 - t3, y0 = y1 - t3, z0 = z1 - t3;
          break;
      }
    }
    if (this._root && this._root.length) this._root = node;
  }
  this._x0 = x0;
  this._y0 = y0;
  this._z0 = z0;
  this._x1 = x1;
  this._y1 = y1;
  this._z1 = z1;
  return this;
}

// node_modules/d3-octree/src/data.js
function data_default() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do
      data.push(node.data);
    while (node = node.next);
  });
  return data;
}

// node_modules/d3-octree/src/extent.js
function extent_default(_2) {
  return arguments.length ? this.cover(+_2[0][0], +_2[0][1], +_2[0][2]).cover(+_2[1][0], +_2[1][1], +_2[1][2]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0, this._z0], [this._x1, this._y1, this._z1]];
}

// node_modules/d3-octree/src/octant.js
function octant_default(node, x0, y0, z0, x1, y1, z1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.z0 = z0;
  this.x1 = x1;
  this.y1 = y1;
  this.z1 = z1;
}

// node_modules/d3-octree/src/find.js
function find_default2(x4, y4, z4, radius) {
  var data, x0 = this._x0, y0 = this._y0, z0 = this._z0, x1, y1, z1, x22, y22, z22, x32 = this._x1, y32 = this._y1, z32 = this._z1, octs = [], node = this._root, q2, i2;
  if (node) octs.push(new octant_default(node, x0, y0, z0, x32, y32, z32));
  if (radius == null) radius = Infinity;
  else {
    x0 = x4 - radius, y0 = y4 - radius, z0 = z4 - radius;
    x32 = x4 + radius, y32 = y4 + radius, z32 = z4 + radius;
    radius *= radius;
  }
  while (q2 = octs.pop()) {
    if (!(node = q2.node) || (x1 = q2.x0) > x32 || (y1 = q2.y0) > y32 || (z1 = q2.z0) > z32 || (x22 = q2.x1) < x0 || (y22 = q2.y1) < y0 || (z22 = q2.z1) < z0) continue;
    if (node.length) {
      var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2, zm = (z1 + z22) / 2;
      octs.push(
        new octant_default(node[7], xm, ym, zm, x22, y22, z22),
        new octant_default(node[6], x1, ym, zm, xm, y22, z22),
        new octant_default(node[5], xm, y1, zm, x22, ym, z22),
        new octant_default(node[4], x1, y1, zm, xm, ym, z22),
        new octant_default(node[3], xm, ym, z1, x22, y22, zm),
        new octant_default(node[2], x1, ym, z1, xm, y22, zm),
        new octant_default(node[1], xm, y1, z1, x22, ym, zm),
        new octant_default(node[0], x1, y1, z1, xm, ym, zm)
      );
      if (i2 = (z4 >= zm) << 2 | (y4 >= ym) << 1 | x4 >= xm) {
        q2 = octs[octs.length - 1];
        octs[octs.length - 1] = octs[octs.length - 1 - i2];
        octs[octs.length - 1 - i2] = q2;
      }
    } else {
      var dx = x4 - +this._x.call(null, node.data), dy = y4 - +this._y.call(null, node.data), dz = z4 - +this._z.call(null, node.data), d22 = dx * dx + dy * dy + dz * dz;
      if (d22 < radius) {
        var d3 = Math.sqrt(radius = d22);
        x0 = x4 - d3, y0 = y4 - d3, z0 = z4 - d3;
        x32 = x4 + d3, y32 = y4 + d3, z32 = z4 + d3;
        data = node.data;
      }
    }
  }
  return data;
}

// node_modules/d3-octree/src/findAll.js
var distance2 = (x1, y1, z1, x22, y22, z22) => Math.sqrt(__pow(x1 - x22, 2) + __pow(y1 - y22, 2) + __pow(z1 - z22, 2));
function findAllWithinRadius(x4, y4, z4, radius) {
  const result = [];
  const xMin = x4 - radius;
  const yMin = y4 - radius;
  const zMin = z4 - radius;
  const xMax = x4 + radius;
  const yMax = y4 + radius;
  const zMax = z4 + radius;
  this.visit((node, x1, y1, z1, x22, y22, z22) => {
    if (!node.length) {
      do {
        const d3 = node.data;
        if (distance2(x4, y4, z4, this._x(d3), this._y(d3), this._z(d3)) <= radius) {
          result.push(d3);
        }
      } while (node = node.next);
    }
    return x1 > xMax || y1 > yMax || z1 > zMax || x22 < xMin || y22 < yMin || z22 < zMin;
  });
  return result;
}

// node_modules/d3-octree/src/remove.js
function remove_default2(d3) {
  if (isNaN(x4 = +this._x.call(null, d3)) || isNaN(y4 = +this._y.call(null, d3)) || isNaN(z4 = +this._z.call(null, d3))) return this;
  var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, z0 = this._z0, x1 = this._x1, y1 = this._y1, z1 = this._z1, x4, y4, z4, xm, ym, zm, right, bottom, deep, i2, j2;
  if (!node) return this;
  if (node.length) while (true) {
    if (right = x4 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y4 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
    if (deep = z4 >= (zm = (z0 + z1) / 2)) z0 = zm;
    else z1 = zm;
    if (!(parent = node, node = node[i2 = deep << 2 | bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[i2 + 1 & 7] || parent[i2 + 2 & 7] || parent[i2 + 3 & 7] || parent[i2 + 4 & 7] || parent[i2 + 5 & 7] || parent[i2 + 6 & 7] || parent[i2 + 7 & 7]) retainer = parent, j2 = i2;
  }
  while (node.data !== d3) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;
  if (previous) return next ? previous.next = next : delete previous.next, this;
  if (!parent) return this._root = next, this;
  next ? parent[i2] = next : delete parent[i2];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3] || parent[4] || parent[5] || parent[6] || parent[7]) && node === (parent[7] || parent[6] || parent[5] || parent[4] || parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer) retainer[j2] = node;
    else this._root = node;
  }
  return this;
}
function removeAll(data) {
  for (var i2 = 0, n2 = data.length; i2 < n2; ++i2) this.remove(data[i2]);
  return this;
}

// node_modules/d3-octree/src/root.js
function root_default() {
  return this._root;
}

// node_modules/d3-octree/src/size.js
function size_default() {
  var size2 = 0;
  this.visit(function(node) {
    if (!node.length) do
      ++size2;
    while (node = node.next);
  });
  return size2;
}

// node_modules/d3-octree/src/visit.js
function visit_default(callback) {
  var octs = [], q2, node = this._root, child, x0, y0, z0, x1, y1, z1;
  if (node) octs.push(new octant_default(node, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1));
  while (q2 = octs.pop()) {
    if (!callback(node = q2.node, x0 = q2.x0, y0 = q2.y0, z0 = q2.z0, x1 = q2.x1, y1 = q2.y1, z1 = q2.z1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2, zm = (z0 + z1) / 2;
      if (child = node[7]) octs.push(new octant_default(child, xm, ym, zm, x1, y1, z1));
      if (child = node[6]) octs.push(new octant_default(child, x0, ym, zm, xm, y1, z1));
      if (child = node[5]) octs.push(new octant_default(child, xm, y0, zm, x1, ym, z1));
      if (child = node[4]) octs.push(new octant_default(child, x0, y0, zm, xm, ym, z1));
      if (child = node[3]) octs.push(new octant_default(child, xm, ym, z0, x1, y1, zm));
      if (child = node[2]) octs.push(new octant_default(child, x0, ym, z0, xm, y1, zm));
      if (child = node[1]) octs.push(new octant_default(child, xm, y0, z0, x1, ym, zm));
      if (child = node[0]) octs.push(new octant_default(child, x0, y0, z0, xm, ym, zm));
    }
  }
  return this;
}

// node_modules/d3-octree/src/visitAfter.js
function visitAfter_default(callback) {
  var octs = [], next = [], q2;
  if (this._root) octs.push(new octant_default(this._root, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1));
  while (q2 = octs.pop()) {
    var node = q2.node;
    if (node.length) {
      var child, x0 = q2.x0, y0 = q2.y0, z0 = q2.z0, x1 = q2.x1, y1 = q2.y1, z1 = q2.z1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2, zm = (z0 + z1) / 2;
      if (child = node[0]) octs.push(new octant_default(child, x0, y0, z0, xm, ym, zm));
      if (child = node[1]) octs.push(new octant_default(child, xm, y0, z0, x1, ym, zm));
      if (child = node[2]) octs.push(new octant_default(child, x0, ym, z0, xm, y1, zm));
      if (child = node[3]) octs.push(new octant_default(child, xm, ym, z0, x1, y1, zm));
      if (child = node[4]) octs.push(new octant_default(child, x0, y0, zm, xm, ym, z1));
      if (child = node[5]) octs.push(new octant_default(child, xm, y0, zm, x1, ym, z1));
      if (child = node[6]) octs.push(new octant_default(child, x0, ym, zm, xm, y1, z1));
      if (child = node[7]) octs.push(new octant_default(child, xm, ym, zm, x1, y1, z1));
    }
    next.push(q2);
  }
  while (q2 = next.pop()) {
    callback(q2.node, q2.x0, q2.y0, q2.z0, q2.x1, q2.y1, q2.z1);
  }
  return this;
}

// node_modules/d3-octree/src/x.js
function defaultX(d3) {
  return d3[0];
}
function x_default2(_2) {
  return arguments.length ? (this._x = _2, this) : this._x;
}

// node_modules/d3-octree/src/y.js
function defaultY(d3) {
  return d3[1];
}
function y_default2(_2) {
  return arguments.length ? (this._y = _2, this) : this._y;
}

// node_modules/d3-octree/src/z.js
function defaultZ(d3) {
  return d3[2];
}
function z_default(_2) {
  return arguments.length ? (this._z = _2, this) : this._z;
}

// node_modules/d3-octree/src/octree.js
function octree(nodes, x4, y4, z4) {
  var tree = new Octree(x4 == null ? defaultX : x4, y4 == null ? defaultY : y4, z4 == null ? defaultZ : z4, NaN, NaN, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Octree(x4, y4, z4, x0, y0, z0, x1, y1, z1) {
  this._x = x4;
  this._y = y4;
  this._z = z4;
  this._x0 = x0;
  this._y0 = y0;
  this._z0 = z0;
  this._x1 = x1;
  this._y1 = y1;
  this._z1 = z1;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy = { data: leaf.data }, next = copy;
  while (leaf = leaf.next) next = next.next = { data: leaf.data };
  return copy;
}
var treeProto = octree.prototype = Octree.prototype;
treeProto.copy = function() {
  var copy = new Octree(this._x, this._y, this._z, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1), node = this._root, nodes, child;
  if (!node) return copy;
  if (!node.length) return copy._root = leaf_copy(node), copy;
  nodes = [{ source: node, target: copy._root = new Array(8) }];
  while (node = nodes.pop()) {
    for (var i2 = 0; i2 < 8; ++i2) {
      if (child = node.source[i2]) {
        if (child.length) nodes.push({ source: child, target: node.target[i2] = new Array(8) });
        else node.target[i2] = leaf_copy(child);
      }
    }
  }
  return copy;
};
treeProto.add = add_default;
treeProto.addAll = addAll;
treeProto.cover = cover_default;
treeProto.data = data_default;
treeProto.extent = extent_default;
treeProto.find = find_default2;
treeProto.findAllWithinRadius = findAllWithinRadius;
treeProto.remove = remove_default2;
treeProto.removeAll = removeAll;
treeProto.root = root_default;
treeProto.size = size_default;
treeProto.visit = visit_default;
treeProto.visitAfter = visitAfter_default;
treeProto.x = x_default2;
treeProto.y = y_default2;
treeProto.z = z_default;

// node_modules/@antv/layout/lib/force/force-n-body.js
var theta2 = 0.81;
var epsilon = 0.1;
function forceNBody(calcGraph, factor, coulombDisScale2, accMap, dimensions = 2) {
  const weightParam = factor / coulombDisScale2;
  const calcNodes = calcGraph.getAllNodes();
  const data = calcNodes.map((calcNode, i2) => {
    const { nodeStrength, x: x4, y: y4, z: z4, size: size2 } = calcNode.data;
    return {
      x: x4,
      y: y4,
      z: z4,
      size: size2,
      index: i2,
      id: calcNode.id,
      vx: 0,
      vy: 0,
      vz: 0,
      weight: weightParam * nodeStrength
    };
  });
  const tree = (dimensions === 2 ? quadtree(data, (d3) => d3.x, (d3) => d3.y) : octree(data, (d3) => d3.x, (d3) => d3.y, (d3) => d3.z)).visitAfter(accumulate);
  const nodeMap = /* @__PURE__ */ new Map();
  data.forEach((n2) => {
    nodeMap.set(n2.id, n2);
    computeForce(n2, tree, dimensions);
  });
  data.map((n2, i2) => {
    const { id, data: data2 } = calcNodes[i2];
    const { mass = 1 } = data2;
    accMap[id] = {
      x: n2.vx / mass,
      y: n2.vy / mass,
      z: n2.vz / mass
    };
  });
  return accMap;
}
function accumulate(treeNode) {
  let accWeight = 0;
  let accX = 0;
  let accY = 0;
  let accZ = 0;
  let accSize = 0;
  const numChildren = treeNode.length;
  if (numChildren) {
    for (let i2 = 0; i2 < numChildren; i2++) {
      const q2 = treeNode[i2];
      if (q2 && q2.weight) {
        accWeight += q2.weight;
        accX += q2.x * q2.weight;
        accY += q2.y * q2.weight;
        accZ += q2.z * q2.weight;
        accSize += q2.size * q2.weight;
      }
    }
    treeNode.x = accX / accWeight;
    treeNode.y = accY / accWeight;
    treeNode.z = accZ / accWeight;
    treeNode.size = accSize / accWeight;
    treeNode.weight = accWeight;
  } else {
    const q2 = treeNode;
    treeNode.x = q2.data.x;
    treeNode.y = q2.data.y;
    treeNode.z = q2.data.z;
    treeNode.size = q2.data.size;
    treeNode.weight = q2.data.weight;
  }
}
var apply = (treeNode, x1, arg1, arg2, arg3, node, dimensions) => {
  var _a;
  if (((_a = treeNode.data) === null || _a === void 0 ? void 0 : _a.id) === node.id)
    return;
  const x22 = [arg1, arg2, arg3][dimensions - 1];
  const dx = node.x - treeNode.x || epsilon;
  const dy = node.y - treeNode.y || epsilon;
  const dz = node.z - treeNode.z || epsilon;
  const pos = [dx, dy, dz];
  const width2 = x22 - x1;
  let len2 = 0;
  for (let i2 = 0; i2 < dimensions; i2++) {
    len2 += pos[i2] * pos[i2];
  }
  const len1 = Math.sqrt(len2);
  const len3 = len1 * len2;
  if (width2 * width2 * theta2 < len2) {
    const param = treeNode.weight / len3;
    node.vx += dx * param;
    node.vy += dy * param;
    node.vz += dz * param;
    return true;
  }
  if (treeNode.length)
    return false;
  if (treeNode.data !== node) {
    const param = treeNode.data.weight / len3;
    node.vx += dx * param;
    node.vy += dy * param;
    node.vz += dz * param;
  }
};
function computeForce(node, tree, dimensions) {
  tree.visit((treeNode, x1, y1, x22, y22) => apply(treeNode, x1, y1, x22, y22, node, dimensions));
}

// node_modules/@antv/layout/lib/force/index.js
var DEFAULTS_LAYOUT_OPTIONS4 = {
  dimensions: 2,
  maxIteration: 500,
  gravity: 10,
  factor: 1,
  edgeStrength: 50,
  nodeStrength: 1e3,
  coulombDisScale: 5e-3,
  damping: 0.9,
  maxSpeed: 200,
  minMovement: 0.4,
  interval: 0.02,
  linkDistance: 200,
  clusterNodeStrength: 20,
  preventOverlap: true,
  distanceThresholdMode: "mean"
};
var ForceLayout = class {
  constructor(options = {}) {
    this.options = options;
    this.id = "force";
    this.timeInterval = 0;
    this.judgingDistance = 0;
    this.running = false;
    this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS4), options);
  }
  /**
   * Return the positions of nodes and edges(if needed).
   */
  execute(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.genericForceLayout(false, graph, options);
    });
  }
  /**
   * To directly assign the positions to the nodes.
   */
  assign(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.genericForceLayout(true, graph, options);
    });
  }
  /**
   * Stop simulation immediately.
   */
  stop() {
    if (this.timeInterval && typeof window !== "undefined") {
      window.clearInterval(this.timeInterval);
    }
    this.running = false;
  }
  /**
   * Manually steps the simulation by the specified number of iterations.
   * @see https://github.com/d3/d3-force#simulation_tick
   */
  tick(iterations = this.options.maxIteration || 1) {
    if (this.lastResult) {
      return this.lastResult;
    }
    for (let i2 = 0; (this.judgingDistance > this.lastOptions.minMovement || i2 < 1) && i2 < iterations; i2++) {
      this.runOneStep(this.lastCalcGraph, this.lastGraph, i2, this.lastVelMap, this.lastOptions);
      this.updatePosition(this.lastGraph, this.lastCalcGraph, this.lastVelMap, this.lastOptions);
    }
    const result = {
      nodes: this.lastLayoutNodes,
      edges: this.lastLayoutEdges
    };
    if (this.lastAssign) {
      result.nodes.forEach((node) => this.lastGraph.mergeNodeData(node.id, {
        x: node.data.x,
        y: node.data.y,
        z: this.options.dimensions === 3 ? node.data.z : void 0
      }));
    }
    return result;
  }
  genericForceLayout(assign, graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const mergedOptions = Object.assign(Object.assign({}, this.options), options);
      const nodes = graph.getAllNodes();
      const edges = graph.getAllEdges();
      const formattedOptions = this.formatOptions(mergedOptions, graph);
      const { dimensions, width: width2, height, nodeSize, getMass, nodeStrength, edgeStrength, linkDistance } = formattedOptions;
      const layoutNodes = nodes.map((node, i2) => {
        return Object.assign(Object.assign({}, node), { data: Object.assign(Object.assign({}, node.data), {
          // ...randomDistribution(node, dimensions, 30, i),
          x: isNumber(node.data.x) ? node.data.x : Math.random() * width2,
          y: isNumber(node.data.y) ? node.data.y : Math.random() * height,
          z: isNumber(node.data.z) ? node.data.z : Math.random() * Math.sqrt(width2 * height),
          size: nodeSize(node) || 30,
          mass: getMass(node),
          nodeStrength: nodeStrength(node)
        }) });
      });
      const layoutEdges = edges.map((edge) => Object.assign(Object.assign({}, edge), { data: Object.assign(Object.assign({}, edge.data), { edgeStrength: edgeStrength(edge), linkDistance: linkDistance(edge, graph.getNode(edge.source), graph.getNode(edge.target)) }) }));
      if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length)) {
        this.lastResult = { nodes: [], edges };
        return { nodes: [], edges };
      }
      const velMap = {};
      nodes.forEach((node, i2) => {
        velMap[node.id] = {
          x: 0,
          y: 0,
          z: 0
        };
      });
      const calcGraph = new Graph2({
        nodes: layoutNodes,
        edges: layoutEdges
      });
      this.formatCentripetal(formattedOptions, calcGraph);
      const { maxIteration, minMovement, onTick } = formattedOptions;
      this.lastLayoutNodes = layoutNodes;
      this.lastLayoutEdges = layoutEdges;
      this.lastAssign = assign;
      this.lastGraph = graph;
      this.lastCalcGraph = calcGraph;
      this.lastOptions = formattedOptions;
      this.lastVelMap = velMap;
      if (typeof window === "undefined")
        return;
      let iter = 0;
      return new Promise((resolve) => {
        this.timeInterval = window.setInterval(() => {
          if (!nodes || !this.running) {
            resolve({
              nodes: formatOutNodes(graph, layoutNodes),
              edges
            });
          }
          this.runOneStep(calcGraph, graph, iter, velMap, formattedOptions);
          this.updatePosition(graph, calcGraph, velMap, formattedOptions);
          if (assign) {
            layoutNodes.forEach((node) => graph.mergeNodeData(node.id, {
              x: node.data.x,
              y: node.data.y,
              z: dimensions === 3 ? node.data.z : void 0
            }));
          }
          onTick === null || onTick === void 0 ? void 0 : onTick({
            nodes: formatOutNodes(graph, layoutNodes),
            edges
          });
          iter++;
          if (iter >= maxIteration || this.judgingDistance < minMovement) {
            window.clearInterval(this.timeInterval);
            resolve({
              nodes: formatOutNodes(graph, layoutNodes),
              edges
            });
          }
        }, 0);
        this.running = true;
      });
    });
  }
  /**
   * Format merged layout options.
   * @param options merged layout options
   * @param graph original graph
   * @returns
   */
  formatOptions(options, graph) {
    const formattedOptions = Object.assign({}, options);
    const { width: propsWidth, height: propsHeight, getMass } = options;
    formattedOptions.width = !propsWidth && typeof window !== "undefined" ? window.innerWidth : propsWidth;
    formattedOptions.height = !propsHeight && typeof window !== "undefined" ? window.innerHeight : propsHeight;
    if (!options.center) {
      formattedOptions.center = [
        formattedOptions.width / 2,
        formattedOptions.height / 2
      ];
    }
    if (!getMass) {
      formattedOptions.getMass = (d3) => {
        let massWeight = 1;
        if (isNumber(d3 === null || d3 === void 0 ? void 0 : d3.data.mass))
          massWeight = d3 === null || d3 === void 0 ? void 0 : d3.data.mass;
        const degree3 = graph.getDegree(d3.id, "both");
        return !degree3 || degree3 < 5 ? massWeight : degree3 * 5 * massWeight;
      };
    }
    formattedOptions.nodeSize = formatNodeSizeToNumber(options.nodeSize, options.nodeSpacing);
    const linkDistanceFn = options.linkDistance ? formatNumberFn(1, options.linkDistance) : (edge) => {
      return 1 + formattedOptions.nodeSize(graph.getNode(edge.source)) + formattedOptions.nodeSize(graph.getNode(edge.target));
    };
    formattedOptions.linkDistance = linkDistanceFn;
    formattedOptions.nodeStrength = formatNumberFn(1, options.nodeStrength);
    formattedOptions.edgeStrength = formatNumberFn(1, options.edgeStrength);
    return formattedOptions;
  }
  /**
   * Format centripetalOption in the option.
   * @param options merged layout options
   * @param calcGraph calculation graph
   */
  formatCentripetal(options, calcGraph) {
    const { dimensions, centripetalOptions, center, clusterNodeStrength, leafCluster, clustering, nodeClusterBy } = options;
    const calcNodes = calcGraph.getAllNodes();
    const basicCentripetal = centripetalOptions || {
      leaf: 2,
      single: 2,
      others: 1,
      // eslint-disable-next-line
      center: (n2) => {
        return {
          x: center[0],
          y: center[1],
          z: dimensions === 3 ? center[2] : void 0
        };
      }
    };
    if (typeof clusterNodeStrength !== "function") {
      options.clusterNodeStrength = (node) => clusterNodeStrength;
    }
    let sameTypeLeafMap;
    let clusters;
    if (leafCluster && nodeClusterBy) {
      sameTypeLeafMap = getSameTypeLeafMap(calcGraph, nodeClusterBy);
      clusters = Array.from(new Set(calcNodes === null || calcNodes === void 0 ? void 0 : calcNodes.map((node) => node.data[nodeClusterBy]))) || [];
      options.centripetalOptions = Object.assign(basicCentripetal, {
        single: 100,
        leaf: (node) => {
          const { siblingLeaves, sameTypeLeaves } = sameTypeLeafMap[node.id] || {};
          if ((sameTypeLeaves === null || sameTypeLeaves === void 0 ? void 0 : sameTypeLeaves.length) === (siblingLeaves === null || siblingLeaves === void 0 ? void 0 : siblingLeaves.length) || (clusters === null || clusters === void 0 ? void 0 : clusters.length) === 1) {
            return 1;
          }
          return options.clusterNodeStrength(node);
        },
        others: 1,
        center: (node) => {
          const degree3 = calcGraph.getDegree(node.id, "both");
          if (!degree3) {
            return {
              x: 100,
              y: 100,
              z: 0
            };
          }
          let centerPos;
          if (degree3 === 1) {
            const { sameTypeLeaves = [] } = sameTypeLeafMap[node.id] || {};
            if (sameTypeLeaves.length === 1) {
              centerPos = void 0;
            } else if (sameTypeLeaves.length > 1) {
              centerPos = getAvgNodePosition(sameTypeLeaves);
            }
          } else {
            centerPos = void 0;
          }
          return {
            x: centerPos === null || centerPos === void 0 ? void 0 : centerPos.x,
            y: centerPos === null || centerPos === void 0 ? void 0 : centerPos.y,
            z: centerPos === null || centerPos === void 0 ? void 0 : centerPos.z
          };
        }
      });
    }
    if (clustering && nodeClusterBy) {
      if (!sameTypeLeafMap) {
        sameTypeLeafMap = getSameTypeLeafMap(calcGraph, nodeClusterBy);
      }
      if (!clusters) {
        clusters = Array.from(new Set(calcNodes.map((node) => node.data[nodeClusterBy])));
      }
      clusters = clusters.filter((item) => item !== void 0);
      const centerInfo = {};
      clusters.forEach((cluster) => {
        const sameTypeNodes = calcNodes.filter((node) => node.data[nodeClusterBy] === cluster).map((node) => calcGraph.getNode(node.id));
        centerInfo[cluster] = getAvgNodePosition(sameTypeNodes);
      });
      options.centripetalOptions = Object.assign(basicCentripetal, {
        single: (node) => options.clusterNodeStrength(node),
        leaf: (node) => options.clusterNodeStrength(node),
        others: (node) => options.clusterNodeStrength(node),
        center: (node) => {
          const centerPos = centerInfo[node.data[nodeClusterBy]];
          return {
            x: centerPos === null || centerPos === void 0 ? void 0 : centerPos.x,
            y: centerPos === null || centerPos === void 0 ? void 0 : centerPos.y,
            z: centerPos === null || centerPos === void 0 ? void 0 : centerPos.z
          };
        }
      });
    }
    const { leaf, single, others } = options.centripetalOptions || {};
    if (leaf && typeof leaf !== "function") {
      options.centripetalOptions.leaf = () => leaf;
    }
    if (single && typeof single !== "function") {
      options.centripetalOptions.single = () => single;
    }
    if (others && typeof others !== "function") {
      options.centripetalOptions.others = () => others;
    }
  }
  /**
   * One iteration.
   * @param calcGraph calculation graph
   * @param graph origin graph
   * @param iter current iteration index
   * @param velMap nodes' velocity map
   * @param options formatted layout options
   * @returns
   */
  runOneStep(calcGraph, graph, iter, velMap, options) {
    const accMap = {};
    const calcNodes = calcGraph.getAllNodes();
    const calcEdges = calcGraph.getAllEdges();
    if (!(calcNodes === null || calcNodes === void 0 ? void 0 : calcNodes.length))
      return;
    const { monitor } = options;
    this.calRepulsive(calcGraph, accMap, options);
    if (calcEdges)
      this.calAttractive(calcGraph, accMap, options);
    this.calGravity(calcGraph, graph, accMap, options);
    this.updateVelocity(calcGraph, accMap, velMap, options);
    if (monitor) {
      const energy = this.calTotalEnergy(accMap, calcNodes);
      monitor({
        energy,
        nodes: graph.getAllNodes(),
        edges: graph.getAllEdges(),
        iterations: iter
      });
    }
  }
  /**
   * Calculate graph energy for monitoring convergence.
   * @param accMap acceleration map
   * @param nodes calculation nodes
   * @returns energy
   */
  calTotalEnergy(accMap, nodes) {
    if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
      return 0;
    let energy = 0;
    nodes.forEach((node, i2) => {
      const vx = accMap[node.id].x;
      const vy = accMap[node.id].y;
      const vz = this.options.dimensions === 3 ? accMap[node.id].z : 0;
      const speed2 = vx * vx + vy * vy + vz * vz;
      const { mass = 1 } = node.data;
      energy += mass * speed2 * 0.5;
    });
    return energy;
  }
  /**
   * Calculate the repulsive forces according to coulombs law.
   * @param calcGraph calculation graph
   * @param accMap acceleration map
   * @param options formatted layout options
   */
  calRepulsive(calcGraph, accMap, options) {
    const { dimensions, factor, coulombDisScale } = options;
    forceNBody(calcGraph, factor, coulombDisScale * coulombDisScale, accMap, dimensions);
  }
  /**
   * Calculate the attractive forces according to hooks law.
   * @param calcGraph calculation graph
   * @param accMap acceleration map
   */
  calAttractive(calcGraph, accMap, options) {
    const { dimensions, nodeSize } = options;
    calcGraph.getAllEdges().forEach((edge, i2) => {
      const { source, target } = edge;
      const sourceNode = calcGraph.getNode(source);
      const targetNode = calcGraph.getNode(target);
      if (!sourceNode || !targetNode)
        return;
      let vecX = targetNode.data.x - sourceNode.data.x;
      let vecY = targetNode.data.y - sourceNode.data.y;
      let vecZ = dimensions === 3 ? targetNode.data.z - sourceNode.data.z : 0;
      if (!vecX && !vecY) {
        vecX = Math.random() * 0.01;
        vecY = Math.random() * 0.01;
        if (dimensions === 3 && !vecZ) {
          vecZ = Math.random() * 0.01;
        }
      }
      const vecLength = Math.sqrt(vecX * vecX + vecY * vecY + vecZ * vecZ);
      if (vecLength < nodeSize(sourceNode) + nodeSize(targetNode))
        return;
      const direX = vecX / vecLength;
      const direY = vecY / vecLength;
      const direZ = vecZ / vecLength;
      const { linkDistance = 200, edgeStrength = 200 } = edge.data || {};
      const diff = linkDistance - vecLength;
      const param = diff * edgeStrength;
      const massSource = sourceNode.data.mass || 1;
      const massTarget = targetNode.data.mass || 1;
      const sourceMassRatio = 1 / massSource;
      const targetMassRatio = 1 / massTarget;
      const disX = direX * param;
      const disY = direY * param;
      const disZ = direZ * param;
      accMap[source].x -= disX * sourceMassRatio;
      accMap[source].y -= disY * sourceMassRatio;
      accMap[source].z -= disZ * sourceMassRatio;
      accMap[target].x += disX * targetMassRatio;
      accMap[target].y += disY * targetMassRatio;
      accMap[target].z += disZ * targetMassRatio;
    });
  }
  /**
   * Calculate the gravity forces toward center.
   * @param calcGraph calculation graph
   * @param graph origin graph
   * @param accMap acceleration map
   * @param options formatted layout options
   */
  calGravity(calcGraph, graph, accMap, options) {
    const { getCenter } = options;
    const calcNodes = calcGraph.getAllNodes();
    const nodes = graph.getAllNodes();
    const edges = graph.getAllEdges();
    const { width: width2, height, center, gravity: defaultGravity, centripetalOptions } = options;
    if (!calcNodes)
      return;
    calcNodes.forEach((calcNode) => {
      const { id, data } = calcNode;
      const { mass, x: x4, y: y4, z: z4 } = data;
      const node = graph.getNode(id);
      let vecX = 0;
      let vecY = 0;
      let vecZ = 0;
      let gravity = defaultGravity;
      const inDegree = calcGraph.getDegree(id, "in");
      const outDegree = calcGraph.getDegree(id, "out");
      const degree3 = calcGraph.getDegree(id, "both");
      const forceCenter = getCenter === null || getCenter === void 0 ? void 0 : getCenter(node, degree3);
      if (forceCenter) {
        const [centerX, centerY, strength] = forceCenter;
        vecX = x4 - centerX;
        vecY = y4 - centerY;
        gravity = strength;
      } else {
        vecX = x4 - center[0];
        vecY = y4 - center[1];
        vecZ = z4 - center[2];
      }
      if (gravity) {
        accMap[id].x -= gravity * vecX / mass;
        accMap[id].y -= gravity * vecY / mass;
        accMap[id].z -= gravity * vecZ / mass;
      }
      if (centripetalOptions) {
        const { leaf, single, others, center: centriCenter } = centripetalOptions;
        const { x: centriX, y: centriY, z: centriZ, centerStrength } = (centriCenter === null || centriCenter === void 0 ? void 0 : centriCenter(node, nodes, edges, width2, height)) || {
          x: 0,
          y: 0,
          z: 0,
          centerStrength: 0
        };
        if (!isNumber(centriX) || !isNumber(centriY))
          return;
        const vx = (x4 - centriX) / mass;
        const vy = (y4 - centriY) / mass;
        const vz = (z4 - centriZ) / mass;
        if (centerStrength) {
          accMap[id].x -= centerStrength * vx;
          accMap[id].y -= centerStrength * vy;
          accMap[id].z -= centerStrength * vz;
        }
        if (degree3 === 0) {
          const singleStrength = single(node);
          if (!singleStrength)
            return;
          accMap[id].x -= singleStrength * vx;
          accMap[id].y -= singleStrength * vy;
          accMap[id].z -= singleStrength * vz;
          return;
        }
        if (inDegree === 0 || outDegree === 0) {
          const leafStrength = leaf(node, nodes, edges);
          if (!leafStrength)
            return;
          accMap[id].x -= leafStrength * vx;
          accMap[id].y -= leafStrength * vy;
          accMap[id].z -= leafStrength * vz;
          return;
        }
        const othersStrength = others(node);
        if (!othersStrength)
          return;
        accMap[id].x -= othersStrength * vx;
        accMap[id].y -= othersStrength * vy;
        accMap[id].z -= othersStrength * vz;
      }
    });
  }
  /**
   * Update the velocities for nodes.
   * @param calcGraph calculation graph
   * @param accMap acceleration map
   * @param velMap velocity map
   * @param options formatted layout options
   * @returns
   */
  updateVelocity(calcGraph, accMap, velMap, options) {
    const { damping, maxSpeed, interval, dimensions } = options;
    const calcNodes = calcGraph.getAllNodes();
    if (!(calcNodes === null || calcNodes === void 0 ? void 0 : calcNodes.length))
      return;
    calcNodes.forEach((calcNode) => {
      const { id } = calcNode;
      let vx = (velMap[id].x + accMap[id].x * interval) * damping || 0.01;
      let vy = (velMap[id].y + accMap[id].y * interval) * damping || 0.01;
      let vz = dimensions === 3 ? (velMap[id].z + accMap[id].z * interval) * damping || 0.01 : 0;
      const vLength = Math.sqrt(vx * vx + vy * vy + vz * vz);
      if (vLength > maxSpeed) {
        const param2 = maxSpeed / vLength;
        vx = param2 * vx;
        vy = param2 * vy;
        vz = param2 * vz;
      }
      velMap[id] = {
        x: vx,
        y: vy,
        z: vz
      };
    });
  }
  /**
   * Update nodes' positions.
   * @param graph origin graph
   * @param calcGraph calculatition graph
   * @param velMap velocity map
   * @param options formatted layou options
   * @returns
   */
  updatePosition(graph, calcGraph, velMap, options) {
    const { distanceThresholdMode, interval, dimensions } = options;
    const calcNodes = calcGraph.getAllNodes();
    if (!(calcNodes === null || calcNodes === void 0 ? void 0 : calcNodes.length)) {
      this.judgingDistance = 0;
      return;
    }
    let sum = 0;
    if (distanceThresholdMode === "max")
      this.judgingDistance = -Infinity;
    else if (distanceThresholdMode === "min")
      this.judgingDistance = Infinity;
    calcNodes.forEach((calcNode) => {
      const { id } = calcNode;
      const node = graph.getNode(id);
      if (isNumber(node.data.fx) && isNumber(node.data.fy)) {
        calcGraph.mergeNodeData(id, {
          x: node.data.fx,
          y: node.data.fy,
          z: dimensions === 3 ? node.data.fz : void 0
        });
        return;
      }
      const distX = velMap[id].x * interval;
      const distY = velMap[id].y * interval;
      const distZ = dimensions === 3 ? velMap[id].z * interval : 0;
      calcGraph.mergeNodeData(id, {
        x: calcNode.data.x + distX,
        y: calcNode.data.y + distY,
        z: calcNode.data.z + distZ
      });
      const distanceMagnitude = Math.sqrt(distX * distX + distY * distY + distZ * distZ);
      switch (distanceThresholdMode) {
        case "max":
          if (this.judgingDistance < distanceMagnitude) {
            this.judgingDistance = distanceMagnitude;
          }
          break;
        case "min":
          if (this.judgingDistance > distanceMagnitude) {
            this.judgingDistance = distanceMagnitude;
          }
          break;
        default:
          sum = sum + distanceMagnitude;
          break;
      }
    });
    if (!distanceThresholdMode || distanceThresholdMode === "mean") {
      this.judgingDistance = sum / calcNodes.length;
    }
  }
};
var getSameTypeLeafMap = (calcGraph, nodeClusterBy) => {
  const calcNodes = calcGraph.getAllNodes();
  if (!(calcNodes === null || calcNodes === void 0 ? void 0 : calcNodes.length))
    return {};
  const sameTypeLeafMap = {};
  calcNodes.forEach((node, i2) => {
    const degree3 = calcGraph.getDegree(node.id, "both");
    if (degree3 === 1) {
      sameTypeLeafMap[node.id] = getCoreNodeAndSiblingLeaves(calcGraph, "leaf", node, nodeClusterBy);
    }
  });
  return sameTypeLeafMap;
};
var getCoreNodeAndSiblingLeaves = (calcGraph, type, node, nodeClusterBy) => {
  const inDegree = calcGraph.getDegree(node.id, "in");
  const outDegree = calcGraph.getDegree(node.id, "out");
  let coreNode = node;
  let siblingLeaves = [];
  if (inDegree === 0) {
    coreNode = calcGraph.getSuccessors(node.id)[0];
    siblingLeaves = calcGraph.getNeighbors(coreNode.id);
  } else if (outDegree === 0) {
    coreNode = calcGraph.getPredecessors(node.id)[0];
    siblingLeaves = calcGraph.getNeighbors(coreNode.id);
  }
  siblingLeaves = siblingLeaves.filter((node2) => calcGraph.getDegree(node2.id, "in") === 0 || calcGraph.getDegree(node2.id, "out") === 0);
  const sameTypeLeaves = getSameTypeNodes(calcGraph, type, nodeClusterBy, node, siblingLeaves);
  return { coreNode, siblingLeaves, sameTypeLeaves };
};
var getSameTypeNodes = (calcGraph, type, nodeClusterBy, node, relativeNodes) => {
  const typeName = node.data[nodeClusterBy] || "";
  let sameTypeNodes = (relativeNodes === null || relativeNodes === void 0 ? void 0 : relativeNodes.filter((item) => item.data[nodeClusterBy] === typeName)) || [];
  if (type === "leaf") {
    sameTypeNodes = sameTypeNodes.filter((item) => calcGraph.getDegree(item.id, "in") === 0 || calcGraph.getDegree(item.id, "out") === 0);
  }
  return sameTypeNodes;
};
var getAvgNodePosition = (nodes) => {
  const totalNodes = { x: 0, y: 0 };
  nodes.forEach((node) => {
    const { x: x4, y: y4 } = node.data;
    totalNodes.x += x4 || 0;
    totalNodes.y += y4 || 0;
  });
  const length = nodes.length || 1;
  return {
    x: totalNodes.x / length,
    y: totalNodes.y / length
  };
};
var formatOutNodes = (graph, layoutNodes) => layoutNodes.map((calcNode) => {
  const { id, data } = calcNode;
  const node = graph.getNode(id);
  return Object.assign(Object.assign({}, node), { data: Object.assign(Object.assign({}, node.data), { x: data.x, y: data.y, z: data.z }) });
});

// node_modules/ml-matrix/matrix.mjs
var matrix = __toESM(require_matrix(), 1);
var Matrix2 = matrix.Matrix;
var SingularValueDecomposition2 = matrix.SingularValueDecomposition;
var matrix_default = matrix.default.Matrix ? matrix.default.Matrix : matrix.Matrix;

// node_modules/@antv/layout/lib/mds.js
var DEFAULTS_LAYOUT_OPTIONS5 = {
  center: [0, 0],
  linkDistance: 50
};
var MDSLayout = class {
  constructor(options = {}) {
    this.options = options;
    this.id = "mds";
    this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS5), options);
  }
  /**
   * Return the positions of nodes and edges(if needed).
   */
  execute(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.genericMDSLayout(false, graph, options);
    });
  }
  /**
   * To directly assign the positions to the nodes.
   */
  assign(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.genericMDSLayout(true, graph, options);
    });
  }
  genericMDSLayout(assign, graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const mergedOptions = Object.assign(Object.assign({}, this.options), options);
      const { center = [0, 0], linkDistance = 50 } = mergedOptions;
      const nodes = graph.getAllNodes();
      const edges = graph.getAllEdges();
      if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length) || nodes.length === 1) {
        return handleSingleNodeGraph(graph, assign, center);
      }
      const adjMatrix = getAdjMatrix({ nodes, edges }, false);
      const distances = floydWarshall(adjMatrix);
      handleInfinity(distances);
      const scaledD = scaleMatrix(distances, linkDistance);
      const positions = runMDS(scaledD);
      const layoutNodes = [];
      positions.forEach((p3, i2) => {
        const cnode = cloneFormatData(nodes[i2]);
        cnode.data.x = p3[0] + center[0];
        cnode.data.y = p3[1] + center[1];
        layoutNodes.push(cnode);
      });
      if (assign) {
        layoutNodes.forEach((node) => graph.mergeNodeData(node.id, {
          x: node.data.x,
          y: node.data.y
        }));
      }
      const result = {
        nodes: layoutNodes,
        edges
      };
      return result;
    });
  }
};
var handleInfinity = (distances) => {
  let maxDistance = -999999;
  distances.forEach((row) => {
    row.forEach((value) => {
      if (value === Infinity) {
        return;
      }
      if (maxDistance < value) {
        maxDistance = value;
      }
    });
  });
  distances.forEach((row, i2) => {
    row.forEach((value, j2) => {
      if (value === Infinity) {
        distances[i2][j2] = maxDistance;
      }
    });
  });
};
var runMDS = (distances) => {
  const dimension = 2;
  const M3 = Matrix2.mul(Matrix2.pow(distances, 2), -0.5);
  const rowMeans = M3.mean("row");
  const colMeans = M3.mean("column");
  const totalMean = M3.mean();
  M3.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans);
  const ret = new SingularValueDecomposition2(M3);
  const eigenValues = Matrix2.sqrt(ret.diagonalMatrix).diagonal();
  return ret.leftSingularVectors.toJSON().map((row) => {
    return Matrix2.mul([row], [eigenValues]).toJSON()[0].splice(0, dimension);
  });
};

// node_modules/@antv/layout/lib/types.js
function isLayoutWithIterations(layout2) {
  return !!layout2.tick && !!layout2.stop;
}

// node_modules/@antv/layout/lib/combo-combined.js
var FORCE_LAYOUT_TYPE_MAP = {
  gForce: true,
  force2: true,
  d3force: true,
  fruchterman: true,
  forceAtlas2: true,
  force: true,
  "graphin-force": true
};
var DEFAULTS_LAYOUT_OPTIONS6 = {
  center: [0, 0],
  comboPadding: 10,
  treeKey: "combo"
};
var ComboCombinedLayout = class {
  constructor(options = {}) {
    this.options = options;
    this.id = "comboCombined";
    this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS6), options);
  }
  /**
   * Return the positions of nodes and edges(if needed).
   */
  execute(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.genericComboCombinedLayout(false, graph, options);
    });
  }
  /**
   * To directly assign the positions to the nodes.
   */
  assign(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.genericComboCombinedLayout(true, graph, options);
    });
  }
  genericComboCombinedLayout(assign, graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const mergedOptions = this.initVals(Object.assign(Object.assign({}, this.options), options));
      const { center, treeKey, outerLayout: propsOuterLayout } = mergedOptions;
      const nodes = graph.getAllNodes().filter((node) => !node.data._isCombo);
      const combos = graph.getAllNodes().filter((node) => node.data._isCombo);
      const edges = graph.getAllEdges();
      const n2 = nodes === null || nodes === void 0 ? void 0 : nodes.length;
      if (!n2 || n2 === 1) {
        return handleSingleNodeGraph(graph, assign, center);
      }
      const layoutNodes = [];
      const nodeMap = /* @__PURE__ */ new Map();
      nodes.forEach((node) => {
        nodeMap.set(node.id, node);
      });
      const comboMap = /* @__PURE__ */ new Map();
      combos.forEach((combo) => {
        comboMap.set(combo.id, combo);
      });
      const comboNodes = /* @__PURE__ */ new Map();
      const innerGraphLayoutPromises = this.getInnerGraphs(graph, treeKey, nodeMap, comboMap, edges, mergedOptions, comboNodes);
      yield Promise.all(innerGraphLayoutPromises);
      const outerNodeIds = /* @__PURE__ */ new Map();
      const outerLayoutNodes = [];
      const nodeAncestorIdMap = /* @__PURE__ */ new Map();
      let allHaveNoPosition = true;
      graph.getRoots(treeKey).forEach((root) => {
        const combo = comboNodes.get(root.id);
        const cacheCombo = comboMap.get(root.id) || nodeMap.get(root.id);
        const comboLayoutNode = {
          id: root.id,
          data: Object.assign(Object.assign({}, root.data), { x: combo.data.x || cacheCombo.data.x, y: combo.data.y || cacheCombo.data.y, fx: combo.data.fx || cacheCombo.data.fx, fy: combo.data.fy || cacheCombo.data.fy, mass: combo.data.mass || cacheCombo.data.mass, size: combo.data.size })
        };
        outerLayoutNodes.push(comboLayoutNode);
        outerNodeIds.set(root.id, true);
        if (!isNaN(comboLayoutNode.data.x) && comboLayoutNode.data.x !== 0 && !isNaN(comboLayoutNode.data.y) && comboLayoutNode.data.y !== 0) {
          allHaveNoPosition = false;
        } else {
          comboLayoutNode.data.x = Math.random() * 100;
          comboLayoutNode.data.y = Math.random() * 100;
        }
        graphTreeDfs(graph, [root], (child) => {
          if (child.id !== root.id)
            nodeAncestorIdMap.set(child.id, root.id);
        }, "TB", treeKey);
      });
      const outerLayoutEdges = [];
      edges.forEach((edge) => {
        const sourceAncestorId = nodeAncestorIdMap.get(edge.source) || edge.source;
        const targetAncestorId = nodeAncestorIdMap.get(edge.target) || edge.target;
        if (sourceAncestorId !== targetAncestorId && outerNodeIds.has(sourceAncestorId) && outerNodeIds.has(targetAncestorId)) {
          outerLayoutEdges.push({
            id: edge.id,
            source: sourceAncestorId,
            target: targetAncestorId,
            data: {}
          });
        }
      });
      let outerPositions;
      if (outerLayoutNodes === null || outerLayoutNodes === void 0 ? void 0 : outerLayoutNodes.length) {
        if (outerLayoutNodes.length === 1) {
          outerLayoutNodes[0].data.x = center[0];
          outerLayoutNodes[0].data.y = center[1];
        } else {
          const outerLayoutGraph = new Graph2({
            nodes: outerLayoutNodes,
            edges: outerLayoutEdges
          });
          const outerLayout = propsOuterLayout || new ForceLayout();
          if (allHaveNoPosition && FORCE_LAYOUT_TYPE_MAP[outerLayout.id]) {
            const outerLayoutPreset = outerLayoutNodes.length < 100 ? new MDSLayout() : new ConcentricLayout();
            yield outerLayoutPreset.assign(outerLayoutGraph);
          }
          const options2 = Object.assign({ center, kg: 5, preventOverlap: true, animate: false }, outerLayout.id === "force" ? {
            gravity: 1,
            factor: 4,
            linkDistance: (edge, source, target) => {
              const sourceSize = Math.max(...source.data.size) || 32;
              const targetSize = Math.max(...target.data.size) || 32;
              return sourceSize / 2 + targetSize / 2 + 200;
            }
          } : {});
          outerPositions = yield executeLayout(outerLayout, outerLayoutGraph, options2);
        }
        comboNodes.forEach((comboNode) => {
          var _a;
          const outerPosition = outerPositions.nodes.find((pos) => pos.id === comboNode.id);
          if (outerPosition) {
            const { x: x5, y: y5 } = outerPosition.data;
            comboNode.data.visited = true;
            comboNode.data.x = x5;
            comboNode.data.y = y5;
            layoutNodes.push({
              id: comboNode.id,
              data: { x: x5, y: y5 }
            });
          }
          const { x: x4, y: y4 } = comboNode.data;
          (_a = comboNode.data.nodes) === null || _a === void 0 ? void 0 : _a.forEach((node) => {
            layoutNodes.push({
              id: node.id,
              data: { x: node.data.x + x4, y: node.data.y + y4 }
            });
          });
        });
        comboNodes.forEach(({ data }) => {
          const { x: x4, y: y4, visited, nodes: nodes2 } = data;
          nodes2 === null || nodes2 === void 0 ? void 0 : nodes2.forEach((node) => {
            if (!visited) {
              const layoutNode = layoutNodes.find((n3) => n3.id === node.id);
              layoutNode.data.x += x4 || 0;
              layoutNode.data.y += y4 || 0;
            }
          });
        });
      }
      if (assign) {
        layoutNodes.forEach((node) => {
          graph.mergeNodeData(node.id, {
            x: node.data.x,
            y: node.data.y
          });
        });
      }
      const result = {
        nodes: layoutNodes,
        edges
      };
      return result;
    });
  }
  initVals(options) {
    const formattedOptions = Object.assign({}, options);
    const { nodeSize, spacing, comboPadding } = options;
    let nodeSizeFunc;
    let spacingFunc;
    if (isNumber(spacing)) {
      spacingFunc = () => spacing;
    } else if (isFunction(spacing)) {
      spacingFunc = spacing;
    } else {
      spacingFunc = () => 0;
    }
    formattedOptions.spacing = spacingFunc;
    if (!nodeSize) {
      nodeSizeFunc = (d3) => {
        const spacing2 = spacingFunc(d3);
        if (d3.size) {
          if (isArray2(d3.size)) {
            const res = d3.size[0] > d3.size[1] ? d3.size[0] : d3.size[1];
            return (res + spacing2) / 2;
          }
          if (is_object_default(d3.size)) {
            const res = d3.size.width > d3.size.height ? d3.size.width : d3.size.height;
            return (res + spacing2) / 2;
          }
          return (d3.size + spacing2) / 2;
        }
        return 32 + spacing2 / 2;
      };
    } else if (isFunction(nodeSize)) {
      nodeSizeFunc = (d3) => {
        const size2 = nodeSize(d3);
        const spacing2 = spacingFunc(d3);
        if (isArray2(d3.size)) {
          const res = d3.size[0] > d3.size[1] ? d3.size[0] : d3.size[1];
          return (res + spacing2) / 2;
        }
        return ((size2 || 32) + spacing2) / 2;
      };
    } else if (isArray2(nodeSize)) {
      const larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];
      const radius = larger / 2;
      nodeSizeFunc = (d3) => radius + spacingFunc(d3) / 2;
    } else {
      const radius = nodeSize / 2;
      nodeSizeFunc = (d3) => radius + spacingFunc(d3) / 2;
    }
    formattedOptions.nodeSize = nodeSizeFunc;
    let comboPaddingFunc;
    if (isNumber(comboPadding)) {
      comboPaddingFunc = () => comboPadding;
    } else if (isArray2(comboPadding)) {
      comboPaddingFunc = () => Math.max.apply(null, comboPadding);
    } else if (isFunction(comboPadding)) {
      comboPaddingFunc = comboPadding;
    } else {
      comboPaddingFunc = () => 0;
    }
    formattedOptions.comboPadding = comboPaddingFunc;
    return formattedOptions;
  }
  getInnerGraphs(graph, treeKey, nodeMap, comboMap, edges, options, comboNodes) {
    const { nodeSize, comboPadding, spacing, innerLayout } = options;
    const innerGraphLayout = innerLayout || new ConcentricLayout({});
    const innerLayoutOptions = {
      center: [0, 0],
      preventOverlap: true,
      nodeSpacing: spacing
    };
    const innerLayoutPromises = [];
    const getSize = (node) => {
      let padding = (comboPadding === null || comboPadding === void 0 ? void 0 : comboPadding(node)) || 10;
      if (isArray2(padding))
        padding = Math.max(...padding);
      return {
        size: padding ? [padding * 2, padding * 2] : [30, 30],
        padding
      };
    };
    graph.getRoots(treeKey).forEach((root) => {
      comboNodes.set(root.id, {
        id: root.id,
        data: {
          nodes: [],
          size: getSize(root).size
        }
      });
      let start = Promise.resolve();
      graphTreeDfs(graph, [root], (treeNode) => {
        var _a;
        if (!treeNode.data._isCombo)
          return;
        const { size: nsize, padding } = getSize(treeNode);
        if (!((_a = graph.getChildren(treeNode.id, treeKey)) === null || _a === void 0 ? void 0 : _a.length)) {
          comboNodes.set(treeNode.id, {
            id: treeNode.id,
            data: Object.assign(Object.assign({}, treeNode.data), { size: nsize })
          });
        } else {
          const comboNode = comboNodes.get(treeNode.id);
          comboNodes.set(treeNode.id, {
            id: treeNode.id,
            data: Object.assign({ nodes: [] }, comboNode === null || comboNode === void 0 ? void 0 : comboNode.data)
          });
          const innerLayoutNodeIds = /* @__PURE__ */ new Map();
          const innerLayoutNodes = graph.getChildren(treeNode.id, treeKey).map((child) => {
            if (child.data._isCombo) {
              if (!comboNodes.has(child.id)) {
                comboNodes.set(child.id, {
                  id: child.id,
                  data: Object.assign({}, child.data)
                });
              }
              innerLayoutNodeIds.set(child.id, true);
              return comboNodes.get(child.id);
            }
            const oriNode = nodeMap.get(child.id) || comboMap.get(child.id);
            innerLayoutNodeIds.set(child.id, true);
            return {
              id: child.id,
              data: Object.assign(Object.assign({}, oriNode.data), child.data)
            };
          });
          const innerGraphData = {
            nodes: innerLayoutNodes,
            edges: edges.filter((edge) => innerLayoutNodeIds.has(edge.source) && innerLayoutNodeIds.has(edge.target))
          };
          let minNodeSize = Infinity;
          innerLayoutNodes.forEach((node) => {
            var _a2;
            let { size: size2 } = node.data;
            if (!size2) {
              size2 = ((_a2 = comboNodes.get(node.id)) === null || _a2 === void 0 ? void 0 : _a2.data.size) || (nodeSize === null || nodeSize === void 0 ? void 0 : nodeSize(node)) || [30, 30];
            }
            if (isNumber(size2))
              size2 = [size2, size2];
            const [size0, size1] = size2;
            if (minNodeSize > size0)
              minNodeSize = size0;
            if (minNodeSize > size1)
              minNodeSize = size1;
            node.data.size = size2;
          });
          start = start.then(() => __awaiter(this, void 0, void 0, function* () {
            const innerGraphCore = new Graph2(innerGraphData);
            yield executeLayout(innerGraphLayout, innerGraphCore, innerLayoutOptions, true);
            const { minX, minY, maxX, maxY } = getLayoutBBox(innerLayoutNodes);
            const center = { x: (maxX + minX) / 2, y: (maxY + minY) / 2 };
            innerGraphData.nodes.forEach((node) => {
              node.data.x -= center.x;
              node.data.y -= center.y;
            });
            const size2 = [
              Math.max(maxX - minX, minNodeSize) + padding * 2,
              Math.max(maxY - minY, minNodeSize) + padding * 2
            ];
            comboNodes.get(treeNode.id).data.size = size2;
            comboNodes.get(treeNode.id).data.nodes = innerLayoutNodes;
          }));
        }
        return true;
      }, "BT", treeKey);
      innerLayoutPromises.push(start);
    });
    return innerLayoutPromises;
  }
};
function executeLayout(layout2, graph, options, assign) {
  var _a;
  return __awaiter(this, void 0, void 0, function* () {
    if (isLayoutWithIterations(layout2)) {
      layout2.execute(graph, options);
      layout2.stop();
      return layout2.tick((_a = options.iterations) !== null && _a !== void 0 ? _a : 300);
    }
    if (assign)
      return yield layout2.assign(graph, options);
    return yield layout2.execute(graph, options);
  });
}

// node_modules/@antv/layout/lib/d3-force/index.js
var D3ForceLayout = class {
  constructor(options) {
    this.id = "d3-force";
    this.config = {
      inputNodeAttrs: ["x", "y", "vx", "vy", "fx", "fy"],
      outputNodeAttrs: ["x", "y", "vx", "vy"],
      simulationAttrs: [
        "alpha",
        "alphaMin",
        "alphaDecay",
        "alphaTarget",
        "velocityDecay",
        "randomSource"
      ]
    };
    this.forceMap = {
      link: link_default,
      manyBody: manyBody_default,
      center: center_default,
      collide: collide_default,
      radial: radial_default,
      x: x_default,
      y: y_default
    };
    this.options = {
      link: {
        id: (edge) => edge.id
      },
      manyBody: {},
      center: {
        x: 0,
        y: 0
      }
    };
    this.context = {
      options: {},
      assign: false,
      nodes: [],
      edges: []
    };
    deep_mix_default(this.options, options);
    if (this.options.forceSimulation) {
      this.simulation = this.options.forceSimulation;
    }
  }
  execute(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.genericLayout(false, graph, options);
    });
  }
  assign(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.genericLayout(true, graph, options);
    });
  }
  stop() {
    this.simulation.stop();
  }
  tick(iterations) {
    this.simulation.tick(iterations);
    return this.getResult();
  }
  restart() {
    this.simulation.restart();
  }
  setFixedPosition(id, position2) {
    const node = this.context.nodes.find((n2) => n2.id === id);
    if (!node)
      return;
    position2.forEach((value, index) => {
      if (typeof value === "number" || value === null) {
        const key = ["fx", "fy", "fz"][index];
        node[key] = value;
      }
    });
  }
  getOptions(options) {
    var _a, _b;
    const _2 = deep_mix_default({}, this.options, options);
    if (_2.collide && ((_a = _2.collide) === null || _a === void 0 ? void 0 : _a.radius) === void 0) {
      _2.collide = _2.collide || {};
      _2.collide.radius = (_b = _2.nodeSize) !== null && _b !== void 0 ? _b : 10;
    }
    if (_2.iterations === void 0) {
      if (_2.link && _2.link.iterations === void 0) {
        _2.iterations = _2.link.iterations;
      }
      if (_2.collide && _2.collide.iterations === void 0) {
        _2.iterations = _2.collide.iterations;
      }
    }
    this.context.options = _2;
    return _2;
  }
  genericLayout(assign, graph, options) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      const _options = this.getOptions(options);
      const nodes = graph.getAllNodes().map(({ id, data }) => Object.assign(Object.assign({ id }, data), pick_default(data.data, this.config.inputNodeAttrs)));
      const edges = graph.getAllEdges().map((edge) => Object.assign({}, edge));
      Object.assign(this.context, { assign, nodes, edges, graph });
      const promise = new Promise((resolver) => {
        this.resolver = resolver;
      });
      const simulation = this.setSimulation(_options);
      simulation.nodes(nodes);
      (_a = simulation.force("link")) === null || _a === void 0 ? void 0 : _a.links(edges);
      return promise;
    });
  }
  getResult() {
    const { assign, nodes, edges, graph } = this.context;
    const nodesResult = nodes.map((node) => ({
      id: node.id,
      data: Object.assign(Object.assign({}, node.data), pick_default(node, this.config.outputNodeAttrs))
    }));
    const edgeResult = edges.map(({ id, source, target, data }) => ({
      id,
      source: typeof source === "object" ? source.id : source,
      target: typeof target === "object" ? target.id : target,
      data
    }));
    if (assign) {
      nodesResult.forEach((node) => graph.mergeNodeData(node.id, node.data));
    }
    return { nodes: nodesResult, edges: edgeResult };
  }
  initSimulation() {
    return simulation_default();
  }
  setSimulation(options) {
    const simulation = this.simulation || this.options.forceSimulation || this.initSimulation();
    if (!this.simulation) {
      this.simulation = simulation.on("tick", () => {
        var _a;
        return (_a = options.onTick) === null || _a === void 0 ? void 0 : _a.call(options, this.getResult());
      }).on("end", () => {
        var _a;
        return (_a = this.resolver) === null || _a === void 0 ? void 0 : _a.call(this, this.getResult());
      });
    }
    apply2(simulation, this.config.simulationAttrs.map((name) => [
      name,
      options[name]
    ]));
    Object.entries(this.forceMap).forEach(([name, Ctor]) => {
      const forceName = name;
      if (options[name]) {
        let force = simulation.force(forceName);
        if (!force) {
          force = Ctor();
          simulation.force(forceName, force);
        }
        apply2(force, Object.entries(options[forceName]));
      } else
        simulation.force(forceName, null);
    });
    return simulation;
  }
};
var apply2 = (target, params) => {
  return params.reduce((acc, [method, param]) => {
    if (!acc[method] || param === void 0)
      return acc;
    return acc[method].call(target, param);
  }, target);
};

// node_modules/d3-binarytree/src/add.js
function add_default2(d3) {
  const x4 = +this._x.call(null, d3);
  return add3(this.cover(x4), x4, d3);
}
function add3(tree, x4, d3) {
  if (isNaN(x4)) return tree;
  var parent, node = tree._root, leaf = { data: d3 }, x0 = tree._x0, x1 = tree._x1, xm, xp, right, i2, j2;
  if (!node) return tree._root = leaf, tree;
  while (node.length) {
    if (right = x4 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (parent = node, !(node = node[i2 = +right])) return parent[i2] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  if (x4 === xp) return leaf.next = node, parent ? parent[i2] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i2] = new Array(2) : tree._root = new Array(2);
    if (right = x4 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
  } while ((i2 = +right) === (j2 = +(xp >= xm)));
  return parent[j2] = node, parent[i2] = leaf, tree;
}
function addAll2(data) {
  if (!Array.isArray(data)) data = Array.from(data);
  const n2 = data.length;
  const xz = new Float64Array(n2);
  let x0 = Infinity, x1 = -Infinity;
  for (let i2 = 0, x4; i2 < n2; ++i2) {
    if (isNaN(x4 = +this._x.call(null, data[i2]))) continue;
    xz[i2] = x4;
    if (x4 < x0) x0 = x4;
    if (x4 > x1) x1 = x4;
  }
  if (x0 > x1) return this;
  this.cover(x0).cover(x1);
  for (let i2 = 0; i2 < n2; ++i2) {
    add3(this, xz[i2], data[i2]);
  }
  return this;
}

// node_modules/d3-binarytree/src/cover.js
function cover_default2(x4) {
  if (isNaN(x4 = +x4)) return this;
  var x0 = this._x0, x1 = this._x1;
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x4)) + 1;
  } else {
    var z4 = x1 - x0 || 1, node = this._root, parent, i2;
    while (x0 > x4 || x4 >= x1) {
      i2 = +(x4 < x0);
      parent = new Array(2), parent[i2] = node, node = parent, z4 *= 2;
      switch (i2) {
        case 0:
          x1 = x0 + z4;
          break;
        case 1:
          x0 = x1 - z4;
          break;
      }
    }
    if (this._root && this._root.length) this._root = node;
  }
  this._x0 = x0;
  this._x1 = x1;
  return this;
}

// node_modules/d3-binarytree/src/data.js
function data_default2() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do
      data.push(node.data);
    while (node = node.next);
  });
  return data;
}

// node_modules/d3-binarytree/src/extent.js
function extent_default2(_2) {
  return arguments.length ? this.cover(+_2[0][0]).cover(+_2[1][0]) : isNaN(this._x0) ? void 0 : [[this._x0], [this._x1]];
}

// node_modules/d3-binarytree/src/half.js
function half_default(node, x0, x1) {
  this.node = node;
  this.x0 = x0;
  this.x1 = x1;
}

// node_modules/d3-binarytree/src/find.js
function find_default3(x4, radius) {
  var data, x0 = this._x0, x1, x22, x32 = this._x1, halves = [], node = this._root, q2, i2;
  if (node) halves.push(new half_default(node, x0, x32));
  if (radius == null) radius = Infinity;
  else {
    x0 = x4 - radius;
    x32 = x4 + radius;
  }
  while (q2 = halves.pop()) {
    if (!(node = q2.node) || (x1 = q2.x0) > x32 || (x22 = q2.x1) < x0) continue;
    if (node.length) {
      var xm = (x1 + x22) / 2;
      halves.push(
        new half_default(node[1], xm, x22),
        new half_default(node[0], x1, xm)
      );
      if (i2 = +(x4 >= xm)) {
        q2 = halves[halves.length - 1];
        halves[halves.length - 1] = halves[halves.length - 1 - i2];
        halves[halves.length - 1 - i2] = q2;
      }
    } else {
      var d3 = Math.abs(x4 - +this._x.call(null, node.data));
      if (d3 < radius) {
        radius = d3;
        x0 = x4 - d3;
        x32 = x4 + d3;
        data = node.data;
      }
    }
  }
  return data;
}

// node_modules/d3-binarytree/src/remove.js
function remove_default3(d3) {
  if (isNaN(x4 = +this._x.call(null, d3))) return this;
  var parent, node = this._root, retainer, previous, next, x0 = this._x0, x1 = this._x1, x4, xm, right, i2, j2;
  if (!node) return this;
  if (node.length) while (true) {
    if (right = x4 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (!(parent = node, node = node[i2 = +right])) return this;
    if (!node.length) break;
    if (parent[i2 + 1 & 1]) retainer = parent, j2 = i2;
  }
  while (node.data !== d3) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;
  if (previous) return next ? previous.next = next : delete previous.next, this;
  if (!parent) return this._root = next, this;
  next ? parent[i2] = next : delete parent[i2];
  if ((node = parent[0] || parent[1]) && node === (parent[1] || parent[0]) && !node.length) {
    if (retainer) retainer[j2] = node;
    else this._root = node;
  }
  return this;
}
function removeAll2(data) {
  for (var i2 = 0, n2 = data.length; i2 < n2; ++i2) this.remove(data[i2]);
  return this;
}

// node_modules/d3-binarytree/src/root.js
function root_default2() {
  return this._root;
}

// node_modules/d3-binarytree/src/size.js
function size_default2() {
  var size2 = 0;
  this.visit(function(node) {
    if (!node.length) do
      ++size2;
    while (node = node.next);
  });
  return size2;
}

// node_modules/d3-binarytree/src/visit.js
function visit_default2(callback) {
  var halves = [], q2, node = this._root, child, x0, x1;
  if (node) halves.push(new half_default(node, this._x0, this._x1));
  while (q2 = halves.pop()) {
    if (!callback(node = q2.node, x0 = q2.x0, x1 = q2.x1) && node.length) {
      var xm = (x0 + x1) / 2;
      if (child = node[1]) halves.push(new half_default(child, xm, x1));
      if (child = node[0]) halves.push(new half_default(child, x0, xm));
    }
  }
  return this;
}

// node_modules/d3-binarytree/src/visitAfter.js
function visitAfter_default2(callback) {
  var halves = [], next = [], q2;
  if (this._root) halves.push(new half_default(this._root, this._x0, this._x1));
  while (q2 = halves.pop()) {
    var node = q2.node;
    if (node.length) {
      var child, x0 = q2.x0, x1 = q2.x1, xm = (x0 + x1) / 2;
      if (child = node[0]) halves.push(new half_default(child, x0, xm));
      if (child = node[1]) halves.push(new half_default(child, xm, x1));
    }
    next.push(q2);
  }
  while (q2 = next.pop()) {
    callback(q2.node, q2.x0, q2.x1);
  }
  return this;
}

// node_modules/d3-binarytree/src/x.js
function defaultX2(d3) {
  return d3[0];
}
function x_default3(_2) {
  return arguments.length ? (this._x = _2, this) : this._x;
}

// node_modules/d3-binarytree/src/binarytree.js
function binarytree(nodes, x4) {
  var tree = new Binarytree(x4 == null ? defaultX2 : x4, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Binarytree(x4, x0, x1) {
  this._x = x4;
  this._x0 = x0;
  this._x1 = x1;
  this._root = void 0;
}
function leaf_copy2(leaf) {
  var copy = { data: leaf.data }, next = copy;
  while (leaf = leaf.next) next = next.next = { data: leaf.data };
  return copy;
}
var treeProto2 = binarytree.prototype = Binarytree.prototype;
treeProto2.copy = function() {
  var copy = new Binarytree(this._x, this._x0, this._x1), node = this._root, nodes, child;
  if (!node) return copy;
  if (!node.length) return copy._root = leaf_copy2(node), copy;
  nodes = [{ source: node, target: copy._root = new Array(2) }];
  while (node = nodes.pop()) {
    for (var i2 = 0; i2 < 2; ++i2) {
      if (child = node.source[i2]) {
        if (child.length) nodes.push({ source: child, target: node.target[i2] = new Array(2) });
        else node.target[i2] = leaf_copy2(child);
      }
    }
  }
  return copy;
};
treeProto2.add = add_default2;
treeProto2.addAll = addAll2;
treeProto2.cover = cover_default2;
treeProto2.data = data_default2;
treeProto2.extent = extent_default2;
treeProto2.find = find_default3;
treeProto2.remove = remove_default3;
treeProto2.removeAll = removeAll2;
treeProto2.root = root_default2;
treeProto2.size = size_default2;
treeProto2.visit = visit_default2;
treeProto2.visitAfter = visitAfter_default2;
treeProto2.x = x_default3;

// node_modules/d3-force-3d/src/simulation.js
var initialAngleRoll = Math.PI * (3 - Math.sqrt(5));
var initialAngleYaw = Math.PI * 20 / (9 + Math.sqrt(221));

// node_modules/@antv/layout/lib/dagre.js
var import_dagre = __toESM(require_dagre());
var DagreLayout = class _DagreLayout {
  constructor(options) {
    this.id = "dagre";
    this.options = {};
    Object.assign(this.options, _DagreLayout.defaultOptions, options);
  }
  execute(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.genericDagreLayout(false, graph, Object.assign(Object.assign({}, this.options), options));
    });
  }
  assign(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.genericDagreLayout(true, graph, Object.assign(Object.assign({}, this.options), options));
    });
  }
  genericDagreLayout(assign, graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const { nodeSize } = options;
      const g3 = new import_dagre.graphlib.Graph();
      g3.setGraph(options);
      g3.setDefaultEdgeLabel(() => ({}));
      const nodes = graph.getAllNodes();
      const edges = graph.getAllEdges();
      if ([...nodes, ...edges].some(({ id }) => isNumber(id))) {
        console.error("Dagre layout only support string id, it will convert number to string.");
      }
      graph.getAllNodes().forEach((node) => {
        const { id } = node;
        const data = Object.assign({}, node.data);
        if (nodeSize !== void 0) {
          const [width2, height] = parseSize2(isFunction(nodeSize) ? nodeSize(node) : nodeSize);
          Object.assign(data, { width: width2, height });
        }
        g3.setNode(id.toString(), data);
      });
      graph.getAllEdges().forEach(({ id, source, target }) => {
        g3.setEdge(source.toString(), target.toString(), { id });
      });
      import_dagre.default.layout(g3);
      const mapping = { nodes: [], edges: [] };
      g3.nodes().forEach((id) => {
        const data = g3.node(id);
        mapping.nodes.push({ id, data });
        if (assign)
          graph.mergeNodeData(id, data);
      });
      g3.edges().forEach((edge) => {
        const _a = g3.edge(edge), { id } = _a, data = __rest(_a, ["id"]);
        const { v: source, w: target } = edge;
        mapping.edges.push({ id, source, target, data });
        if (assign)
          graph.mergeEdgeData(id, data);
      });
      return mapping;
    });
  }
};
DagreLayout.defaultOptions = {};

// node_modules/@antv/layout/lib/force-atlas2/body.js
var Body = class _Body {
  constructor(params) {
    this.id = params.id || 0;
    this.rx = params.rx;
    this.ry = params.ry;
    this.fx = 0;
    this.fy = 0;
    this.mass = params.mass;
    this.degree = params.degree;
    this.g = params.g || 0;
  }
  // returns the euclidean distance
  distanceTo(bo) {
    const dx = this.rx - bo.rx;
    const dy = this.ry - bo.ry;
    return Math.hypot(dx, dy);
  }
  setPos(x4, y4) {
    this.rx = x4;
    this.ry = y4;
  }
  // resets the forces
  resetForce() {
    this.fx = 0;
    this.fy = 0;
  }
  addForce(b3) {
    const dx = b3.rx - this.rx;
    const dy = b3.ry - this.ry;
    let dist = Math.hypot(dx, dy);
    dist = dist < 1e-4 ? 1e-4 : dist;
    const F3 = this.g * (this.degree + 1) * (b3.degree + 1) / dist;
    this.fx += F3 * dx / dist;
    this.fy += F3 * dy / dist;
  }
  // if quad contains this body
  in(quad) {
    return quad.contains(this.rx, this.ry);
  }
  // returns a new body
  add(bo) {
    const nenwMass = this.mass + bo.mass;
    const x4 = (this.rx * this.mass + bo.rx * bo.mass) / nenwMass;
    const y4 = (this.ry * this.mass + bo.ry * bo.mass) / nenwMass;
    const dg = this.degree + bo.degree;
    const params = {
      rx: x4,
      ry: y4,
      mass: nenwMass,
      degree: dg
    };
    return new _Body(params);
  }
};

// node_modules/@antv/layout/lib/force-atlas2/quad.js
var Quad = class _Quad {
  constructor(params) {
    this.xmid = params.xmid;
    this.ymid = params.ymid;
    this.length = params.length;
    this.massCenter = params.massCenter || [0, 0];
    this.mass = params.mass || 1;
  }
  getLength() {
    return this.length;
  }
  contains(x4, y4) {
    const halfLen = this.length / 2;
    return x4 <= this.xmid + halfLen && x4 >= this.xmid - halfLen && y4 <= this.ymid + halfLen && y4 >= this.ymid - halfLen;
  }
  // northwest quadrant
  // tslint:disable-next-line
  NW() {
    const x4 = this.xmid - this.length / 4;
    const y4 = this.ymid + this.length / 4;
    const len = this.length / 2;
    const params = {
      xmid: x4,
      ymid: y4,
      length: len
    };
    const NW = new _Quad(params);
    return NW;
  }
  // northeast
  // tslint:disable-next-line
  NE() {
    const x4 = this.xmid + this.length / 4;
    const y4 = this.ymid + this.length / 4;
    const len = this.length / 2;
    const params = {
      xmid: x4,
      ymid: y4,
      length: len
    };
    const NE = new _Quad(params);
    return NE;
  }
  // southwest
  // tslint:disable-next-line
  SW() {
    const x4 = this.xmid - this.length / 4;
    const y4 = this.ymid - this.length / 4;
    const len = this.length / 2;
    const params = {
      xmid: x4,
      ymid: y4,
      length: len
    };
    const SW = new _Quad(params);
    return SW;
  }
  // southeast
  // tslint:disable-next-line
  SE() {
    const x4 = this.xmid + this.length / 4;
    const y4 = this.ymid - this.length / 4;
    const len = this.length / 2;
    const params = {
      xmid: x4,
      ymid: y4,
      length: len
    };
    const SE = new _Quad(params);
    return SE;
  }
};

// node_modules/@antv/layout/lib/force-atlas2/quad-tree.js
var QuadTree = class _QuadTree {
  // each quadtree represents a quadrant and an aggregate body
  // that represents all bodies inside the quadrant
  constructor(param) {
    this.body = null;
    this.quad = null;
    this.NW = null;
    this.NE = null;
    this.SW = null;
    this.SE = null;
    this.theta = 0.5;
    if (param != null)
      this.quad = param;
  }
  // insert a body(node) into the tree
  insert(bo) {
    if (this.body == null) {
      this.body = bo;
      return;
    }
    if (!this._isExternal()) {
      this.body = this.body.add(bo);
      this._putBody(bo);
    } else {
      if (this.quad) {
        this.NW = new _QuadTree(this.quad.NW());
        this.NE = new _QuadTree(this.quad.NE());
        this.SW = new _QuadTree(this.quad.SW());
        this.SE = new _QuadTree(this.quad.SE());
      }
      this._putBody(this.body);
      this._putBody(bo);
      this.body = this.body.add(bo);
    }
  }
  // inserts bo into a quad
  // tslint:disable-next-line
  _putBody(bo) {
    if (!this.quad)
      return;
    if (bo.in(this.quad.NW()) && this.NW)
      this.NW.insert(bo);
    else if (bo.in(this.quad.NE()) && this.NE)
      this.NE.insert(bo);
    else if (bo.in(this.quad.SW()) && this.SW)
      this.SW.insert(bo);
    else if (bo.in(this.quad.SE()) && this.SE)
      this.SE.insert(bo);
  }
  // tslint:disable-next-line
  _isExternal() {
    return this.NW == null && this.NE == null && this.SW == null && this.SE == null;
  }
  // update the forces
  updateForce(bo) {
    if (this.body == null || bo === this.body) {
      return;
    }
    if (this._isExternal())
      bo.addForce(this.body);
    else {
      const s2 = this.quad ? this.quad.getLength() : 0;
      const d3 = this.body.distanceTo(bo);
      if (s2 / d3 < this.theta)
        bo.addForce(this.body);
      else {
        this.NW && this.NW.updateForce(bo);
        this.NE && this.NE.updateForce(bo);
        this.SW && this.SW.updateForce(bo);
        this.SE && this.SE.updateForce(bo);
      }
    }
  }
};

// node_modules/@antv/layout/lib/force-atlas2/index.js
var DEFAULTS_LAYOUT_OPTIONS7 = {
  center: [0, 0],
  width: 300,
  height: 300,
  kr: 5,
  kg: 1,
  mode: "normal",
  preventOverlap: false,
  dissuadeHubs: false,
  maxIteration: 0,
  ks: 0.1,
  ksmax: 10,
  tao: 0.1
};
var ForceAtlas2Layout = class {
  constructor(options = {}) {
    this.options = options;
    this.id = "forceAtlas2";
    this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS7), options);
  }
  /**
   * Return the positions of nodes and edges(if needed).
   */
  execute(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.genericForceAtlas2Layout(false, graph, options);
    });
  }
  /**
   * To directly assign the positions to the nodes.
   */
  assign(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.genericForceAtlas2Layout(true, graph, options);
    });
  }
  genericForceAtlas2Layout(assign, graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const edges = graph.getAllEdges();
      const nodes = graph.getAllNodes();
      const mergedOptions = this.formatOptions(options, nodes.length);
      const { width: width2, height, prune, maxIteration, nodeSize, center } = mergedOptions;
      if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length) || nodes.length === 1) {
        return handleSingleNodeGraph(graph, assign, center);
      }
      const calcNodes = nodes.map((node) => cloneFormatData(node, [width2, height]));
      const calcEdges = edges.filter((edge) => {
        const { source, target } = edge;
        return source !== target;
      });
      const calcGraph = new Graph2({
        nodes: calcNodes,
        edges: calcEdges
      });
      const sizes = this.getSizes(calcGraph, nodeSize);
      this.run(calcGraph, graph, maxIteration, sizes, assign, mergedOptions);
      if (prune) {
        for (let j2 = 0; j2 < calcEdges.length; j2 += 1) {
          const { source, target } = calcEdges[j2];
          const sourceDegree = calcGraph.getDegree(source);
          const targetDegree = calcGraph.getDegree(source);
          if (sourceDegree <= 1) {
            const targetNode = calcGraph.getNode(target);
            calcGraph.mergeNodeData(source, {
              x: targetNode.data.x,
              y: targetNode.data.y
            });
          } else if (targetDegree <= 1) {
            const sourceNode = calcGraph.getNode(source);
            calcGraph.mergeNodeData(target, {
              x: sourceNode.data.x,
              y: sourceNode.data.y
            });
          }
        }
        const postOptions = Object.assign(Object.assign({}, mergedOptions), { prune: false, barnesHut: false });
        this.run(calcGraph, graph, 100, sizes, assign, postOptions);
      }
      return {
        nodes: calcNodes,
        edges
      };
    });
  }
  /**
   * Init the node positions if there is no initial positions.
   * And pre-calculate the size (max of width and height) for each node.
   * @param calcGraph graph for calculation
   * @param nodeSize node size config from layout options
   * @returns {SizeMap} node'id mapped to max of its width and height
   */
  getSizes(calcGraph, nodeSize) {
    const nodes = calcGraph.getAllNodes();
    const sizes = {};
    for (let i2 = 0; i2 < nodes.length; i2 += 1) {
      const node = nodes[i2];
      sizes[node.id] = formatNodeSizeToNumber(nodeSize, void 0)(node);
    }
    return sizes;
  }
  /**
   * Format the options.
   * @param options input options
   * @param nodeNum number of nodes
   * @returns formatted options
   */
  formatOptions(options = {}, nodeNum) {
    const mergedOptions = Object.assign(Object.assign({}, this.options), options);
    const { center, width: width2, height, barnesHut, prune, maxIteration, kr, kg } = mergedOptions;
    mergedOptions.width = !width2 && typeof window !== "undefined" ? window.innerWidth : width2;
    mergedOptions.height = !height && typeof window !== "undefined" ? window.innerHeight : height;
    mergedOptions.center = !center ? [mergedOptions.width / 2, mergedOptions.height / 2] : center;
    if (barnesHut === void 0 && nodeNum > 250) {
      mergedOptions.barnesHut = true;
    }
    if (prune === void 0 && nodeNum > 100)
      mergedOptions.prune = true;
    if (maxIteration === 0 && !prune) {
      mergedOptions.maxIteration = 250;
      if (nodeNum <= 200 && nodeNum > 100)
        mergedOptions.maxIteration = 1e3;
      else if (nodeNum > 200)
        mergedOptions.maxIteration = 1200;
    } else if (maxIteration === 0 && prune) {
      mergedOptions.maxIteration = 100;
      if (nodeNum <= 200 && nodeNum > 100)
        mergedOptions.maxIteration = 500;
      else if (nodeNum > 200)
        mergedOptions.maxIteration = 950;
    }
    if (!kr) {
      mergedOptions.kr = 50;
      if (nodeNum > 100 && nodeNum <= 500)
        mergedOptions.kr = 20;
      else if (nodeNum > 500)
        mergedOptions.kr = 1;
    }
    if (!kg) {
      mergedOptions.kg = 20;
      if (nodeNum > 100 && nodeNum <= 500)
        mergedOptions.kg = 10;
      else if (nodeNum > 500)
        mergedOptions.kg = 1;
    }
    return mergedOptions;
  }
  /**
   * Loops for fa2.
   * @param calcGraph graph for calculation
   * @param graph original graph
   * @param iteration iteration number
   * @param sizes nodes' size
   * @param options formatted layout options
   * @returns
   */
  run(calcGraph, graph, iteration, sizes, assign, options) {
    const { kr, barnesHut, onTick } = options;
    const calcNodes = calcGraph.getAllNodes();
    let sg = 0;
    let iter = iteration;
    const forces = {};
    const preForces = {};
    const bodies = {};
    for (let i2 = 0; i2 < calcNodes.length; i2 += 1) {
      const { data, id } = calcNodes[i2];
      forces[id] = [0, 0];
      if (barnesHut) {
        const params = {
          id: i2,
          rx: data.x,
          ry: data.y,
          mass: 1,
          g: kr,
          degree: calcGraph.getDegree(id)
        };
        bodies[id] = new Body(params);
      }
    }
    while (iter > 0) {
      sg = this.oneStep(calcGraph, {
        iter,
        preventOverlapIters: 50,
        krPrime: 100,
        sg,
        forces,
        preForces,
        bodies,
        sizes
      }, options);
      iter--;
      onTick === null || onTick === void 0 ? void 0 : onTick({
        nodes: calcNodes,
        edges: graph.getAllEdges()
      });
    }
    return calcGraph;
  }
  /**
   * One step for a loop.
   * @param graph graph for calculation
   * @param params parameters for a loop
   * @param options formatted layout's input options
   * @returns
   */
  oneStep(graph, params, options) {
    const { iter, preventOverlapIters, krPrime, sg, preForces, bodies, sizes } = params;
    let { forces } = params;
    const { preventOverlap, barnesHut } = options;
    const nodes = graph.getAllNodes();
    for (let i2 = 0; i2 < nodes.length; i2 += 1) {
      const { id } = nodes[i2];
      preForces[id] = [...forces[id]];
      forces[id] = [0, 0];
    }
    forces = this.getAttrForces(graph, iter, preventOverlapIters, sizes, forces, options);
    if (barnesHut && (preventOverlap && iter > preventOverlapIters || !preventOverlap)) {
      forces = this.getOptRepGraForces(graph, forces, bodies, options);
    } else {
      forces = this.getRepGraForces(graph, iter, preventOverlapIters, forces, krPrime, sizes, options);
    }
    return this.updatePos(graph, forces, preForces, sg, options);
  }
  /**
   * Calculate the attract forces for nodes.
   * @param graph graph for calculation
   * @param iter current iteration index
   * @param preventOverlapIters the iteration number for preventing overlappings
   * @param sizes nodes' sizes
   * @param forces forces for nodes, which will be modified
   * @param options formatted layout's input options
   * @returns
   */
  getAttrForces(graph, iter, preventOverlapIters, sizes, forces, options) {
    const { preventOverlap, dissuadeHubs, mode, prune } = options;
    const edges = graph.getAllEdges();
    for (let i2 = 0; i2 < edges.length; i2 += 1) {
      const { source, target } = edges[i2];
      const sourceNode = graph.getNode(source);
      const targetNode = graph.getNode(target);
      const sourceDegree = graph.getDegree(source);
      const targetDegree = graph.getDegree(target);
      if (prune && (sourceDegree <= 1 || targetDegree <= 1))
        continue;
      const dir = [
        targetNode.data.x - sourceNode.data.x,
        targetNode.data.y - sourceNode.data.y
      ];
      let eucliDis = Math.hypot(dir[0], dir[1]);
      eucliDis = eucliDis < 1e-4 ? 1e-4 : eucliDis;
      dir[0] = dir[0] / eucliDis;
      dir[1] = dir[1] / eucliDis;
      if (preventOverlap && iter < preventOverlapIters) {
        eucliDis = eucliDis - sizes[source] - sizes[target];
      }
      let fa1 = eucliDis;
      let fa2 = fa1;
      if (mode === "linlog") {
        fa1 = Math.log(1 + eucliDis);
        fa2 = fa1;
      }
      if (dissuadeHubs) {
        fa1 = eucliDis / sourceDegree;
        fa2 = eucliDis / targetDegree;
      }
      if (preventOverlap && iter < preventOverlapIters && eucliDis <= 0) {
        fa1 = 0;
        fa2 = 0;
      } else if (preventOverlap && iter < preventOverlapIters && eucliDis > 0) {
        fa1 = eucliDis;
        fa2 = eucliDis;
      }
      forces[source][0] += fa1 * dir[0];
      forces[target][0] -= fa2 * dir[0];
      forces[source][1] += fa1 * dir[1];
      forces[target][1] -= fa2 * dir[1];
    }
    return forces;
  }
  /**
   * Calculate the repulsive forces for nodes under barnesHut mode.
   * @param graph graph for calculatiion
   * @param forces forces for nodes, which will be modified
   * @param bodies force body map
   * @param options formatted layout's input options
   * @returns
   */
  getOptRepGraForces(graph, forces, bodies, options) {
    const { kg, center, prune } = options;
    const nodes = graph.getAllNodes();
    const nodeNum = nodes.length;
    let minx = 9e10;
    let maxx = -9e10;
    let miny = 9e10;
    let maxy = -9e10;
    for (let i2 = 0; i2 < nodeNum; i2 += 1) {
      const { id, data } = nodes[i2];
      if (prune && graph.getDegree(id) <= 1)
        continue;
      bodies[id].setPos(data.x, data.y);
      if (data.x >= maxx)
        maxx = data.x;
      if (data.x <= minx)
        minx = data.x;
      if (data.y >= maxy)
        maxy = data.y;
      if (data.y <= miny)
        miny = data.y;
    }
    const width2 = Math.max(maxx - minx, maxy - miny);
    const quadParams = {
      xmid: (maxx + minx) / 2,
      ymid: (maxy + miny) / 2,
      length: width2,
      massCenter: center,
      mass: nodeNum
    };
    const quad = new Quad(quadParams);
    const quadTree = new QuadTree(quad);
    for (let i2 = 0; i2 < nodeNum; i2 += 1) {
      const { id } = nodes[i2];
      if (prune && graph.getDegree(id) <= 1)
        continue;
      if (bodies[id].in(quad))
        quadTree.insert(bodies[id]);
    }
    for (let i2 = 0; i2 < nodeNum; i2 += 1) {
      const { id, data } = nodes[i2];
      const degree3 = graph.getDegree(id);
      if (prune && degree3 <= 1)
        continue;
      bodies[id].resetForce();
      quadTree.updateForce(bodies[id]);
      forces[id][0] -= bodies[id].fx;
      forces[id][1] -= bodies[id].fy;
      const dir = [data.x - center[0], data.y - center[1]];
      let eucliDis = Math.hypot(dir[0], dir[1]);
      eucliDis = eucliDis < 1e-4 ? 1e-4 : eucliDis;
      dir[0] = dir[0] / eucliDis;
      dir[1] = dir[1] / eucliDis;
      const fg = kg * (degree3 + 1);
      forces[id][0] -= fg * dir[0];
      forces[id][1] -= fg * dir[1];
    }
    return forces;
  }
  /**
   * Calculate the repulsive forces for nodes.
   * @param graph graph for calculatiion
   * @param iter current iteration index
   * @param preventOverlapIters the iteration number for preventing overlappings
   * @param forces forces for nodes, which will be modified
   * @param krPrime larger the krPrime, larger the repulsive force
   * @param sizes nodes' sizes
   * @param options formatted layout's input options
   * @returns
   */
  getRepGraForces(graph, iter, preventOverlapIters, forces, krPrime, sizes, options) {
    const { preventOverlap, kr, kg, center, prune } = options;
    const nodes = graph.getAllNodes();
    const nodeNum = nodes.length;
    for (let i2 = 0; i2 < nodeNum; i2 += 1) {
      const nodei = nodes[i2];
      const degreei = graph.getDegree(nodei.id);
      for (let j2 = i2 + 1; j2 < nodeNum; j2 += 1) {
        const nodej = nodes[j2];
        const degreej = graph.getDegree(nodej.id);
        if (prune && (degreei <= 1 || degreej <= 1))
          continue;
        const dir2 = [nodej.data.x - nodei.data.x, nodej.data.y - nodei.data.y];
        let eucliDis2 = Math.hypot(dir2[0], dir2[1]);
        eucliDis2 = eucliDis2 < 1e-4 ? 1e-4 : eucliDis2;
        dir2[0] = dir2[0] / eucliDis2;
        dir2[1] = dir2[1] / eucliDis2;
        if (preventOverlap && iter < preventOverlapIters) {
          eucliDis2 = eucliDis2 - sizes[nodei.id] - sizes[nodej.id];
        }
        let fr = kr * (degreei + 1) * (degreej + 1) / eucliDis2;
        if (preventOverlap && iter < preventOverlapIters && eucliDis2 < 0) {
          fr = krPrime * (degreei + 1) * (degreej + 1);
        } else if (preventOverlap && iter < preventOverlapIters && eucliDis2 === 0) {
          fr = 0;
        } else if (preventOverlap && iter < preventOverlapIters && eucliDis2 > 0) {
          fr = kr * (degreei + 1) * (degreej + 1) / eucliDis2;
        }
        forces[nodei.id][0] -= fr * dir2[0];
        forces[nodej.id][0] += fr * dir2[0];
        forces[nodei.id][1] -= fr * dir2[1];
        forces[nodej.id][1] += fr * dir2[1];
      }
      const dir = [nodei.data.x - center[0], nodei.data.y - center[1]];
      const eucliDis = Math.hypot(dir[0], dir[1]);
      dir[0] = dir[0] / eucliDis;
      dir[1] = dir[1] / eucliDis;
      const fg = kg * (degreei + 1);
      forces[nodei.id][0] -= fg * dir[0];
      forces[nodei.id][1] -= fg * dir[1];
    }
    return forces;
  }
  /**
   * Update node positions.
   * @param graph graph for calculatiion
   * @param forces forces for nodes, which will be modified
   * @param preForces previous forces for nodes, which will be modified
   * @param sg constant for move distance of one step
   * @param options formatted layout's input options
   * @returns
   */
  updatePos(graph, forces, preForces, sg, options) {
    const { ks, tao, prune, ksmax } = options;
    const nodes = graph.getAllNodes();
    const nodeNum = nodes.length;
    const swgns = [];
    const trans = [];
    let swgG = 0;
    let traG = 0;
    let usingSg = sg;
    for (let i2 = 0; i2 < nodeNum; i2 += 1) {
      const { id } = nodes[i2];
      const degree3 = graph.getDegree(id);
      if (prune && degree3 <= 1)
        continue;
      const minus = [
        forces[id][0] - preForces[id][0],
        forces[id][1] - preForces[id][1]
      ];
      const minusNorm = Math.hypot(minus[0], minus[1]);
      const add4 = [
        forces[id][0] + preForces[id][0],
        forces[id][1] + preForces[id][1]
      ];
      const addNorm = Math.hypot(add4[0], add4[1]);
      swgns[i2] = minusNorm;
      trans[i2] = addNorm / 2;
      swgG += (degree3 + 1) * swgns[i2];
      traG += (degree3 + 1) * trans[i2];
    }
    const preSG = usingSg;
    usingSg = tao * traG / swgG;
    if (preSG !== 0) {
      usingSg = usingSg > 1.5 * preSG ? 1.5 * preSG : usingSg;
    }
    for (let i2 = 0; i2 < nodeNum; i2 += 1) {
      const { id, data } = nodes[i2];
      const degree3 = graph.getDegree(id);
      if (prune && degree3 <= 1)
        continue;
      if (isNumber(data.fx) && isNumber(data.fy))
        continue;
      let sn = ks * usingSg / (1 + usingSg * Math.sqrt(swgns[i2]));
      let absForce = Math.hypot(forces[id][0], forces[id][1]);
      absForce = absForce < 1e-4 ? 1e-4 : absForce;
      const max2 = ksmax / absForce;
      sn = sn > max2 ? max2 : sn;
      const dnx = sn * forces[id][0];
      const dny = sn * forces[id][1];
      graph.mergeNodeData(id, {
        x: data.x + dnx,
        y: data.y + dny
      });
    }
    return usingSg;
  }
};

// node_modules/@antv/layout/lib/fruchterman.js
var DEFAULTS_LAYOUT_OPTIONS8 = {
  maxIteration: 1e3,
  gravity: 10,
  speed: 5,
  clustering: false,
  clusterGravity: 10,
  width: 300,
  height: 300,
  nodeClusterBy: "cluster"
};
var SPEED_DIVISOR = 800;
var FruchtermanLayout = class {
  constructor(options = {}) {
    this.options = options;
    this.id = "fruchterman";
    this.timeInterval = 0;
    this.running = false;
    this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS8), options);
  }
  /**
   * Return the positions of nodes and edges(if needed).
   */
  execute(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.genericFruchtermanLayout(false, graph, options);
    });
  }
  /**
   * To directly assign the positions to the nodes.
   */
  assign(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.genericFruchtermanLayout(true, graph, options);
    });
  }
  /**
   * Stop simulation immediately.
   */
  stop() {
    if (this.timeInterval && typeof window !== "undefined") {
      window.clearInterval(this.timeInterval);
    }
    this.running = false;
  }
  /**
   * Manually steps the simulation by the specified number of iterations.
   * @see https://github.com/d3/d3-force#simulation_tick
   */
  tick(iterations = this.options.maxIteration || 1) {
    if (this.lastResult) {
      return this.lastResult;
    }
    for (let i2 = 0; i2 < iterations; i2++) {
      this.runOneStep(this.lastGraph, this.lastClusterMap, this.lastOptions);
    }
    const result = {
      nodes: this.lastLayoutNodes,
      edges: this.lastLayoutEdges
    };
    if (this.lastAssign) {
      result.nodes.forEach((node) => this.lastGraph.mergeNodeData(node.id, {
        x: node.data.x,
        y: node.data.y,
        z: this.options.dimensions === 3 ? node.data.z : void 0
      }));
    }
    return result;
  }
  genericFruchtermanLayout(assign, graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.running)
        return;
      const formattedOptions = this.formatOptions(options);
      const { dimensions, width: width2, height, center, clustering, nodeClusterBy, maxIteration, onTick } = formattedOptions;
      const nodes = graph.getAllNodes();
      const edges = graph.getAllEdges();
      if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length)) {
        const result = { nodes: [], edges };
        this.lastResult = result;
        return result;
      }
      if (nodes.length === 1) {
        if (assign) {
          graph.mergeNodeData(nodes[0].id, {
            x: center[0],
            y: center[1],
            z: dimensions === 3 ? center[2] : void 0
          });
        }
        const result = {
          nodes: [
            Object.assign(Object.assign({}, nodes[0]), { data: Object.assign(Object.assign({}, nodes[0].data), { x: center[0], y: center[1], z: dimensions === 3 ? center[2] : void 0 }) })
          ],
          edges
        };
        this.lastResult = result;
        return result;
      }
      const layoutNodes = nodes.map((node) => cloneFormatData(node, [width2, height]));
      const calcGraph = new Graph2({
        nodes: layoutNodes,
        edges
      });
      const clusterMap = {};
      if (clustering) {
        layoutNodes.forEach((node) => {
          const clusterValue = node.data[nodeClusterBy];
          if (!clusterMap[clusterValue]) {
            clusterMap[clusterValue] = {
              name: clusterValue,
              cx: 0,
              cy: 0,
              count: 0
            };
          }
        });
      }
      this.lastLayoutNodes = layoutNodes;
      this.lastLayoutEdges = edges;
      this.lastAssign = assign;
      this.lastGraph = calcGraph;
      this.lastOptions = formattedOptions;
      this.lastClusterMap = clusterMap;
      if (typeof window === "undefined")
        return;
      let iter = 0;
      return new Promise((resolve) => {
        this.timeInterval = window.setInterval(() => {
          if (!this.running) {
            resolve({ nodes: layoutNodes, edges });
            return;
          }
          this.runOneStep(calcGraph, clusterMap, formattedOptions);
          if (assign) {
            layoutNodes.forEach(({ id, data }) => graph.mergeNodeData(id, {
              x: data.x,
              y: data.y,
              z: dimensions === 3 ? data.z : void 0
            }));
          }
          onTick === null || onTick === void 0 ? void 0 : onTick({
            nodes: layoutNodes,
            edges
          });
          iter++;
          if (iter >= maxIteration) {
            window.clearInterval(this.timeInterval);
            resolve({ nodes: layoutNodes, edges });
          }
        }, 0);
        this.running = true;
      });
    });
  }
  formatOptions(options = {}) {
    const mergedOptions = Object.assign(Object.assign({}, this.options), options);
    const { clustering, nodeClusterBy } = mergedOptions;
    const { center: propsCenter, width: propsWidth, height: propsHeight } = mergedOptions;
    mergedOptions.width = !propsWidth && typeof window !== "undefined" ? window.innerWidth : propsWidth;
    mergedOptions.height = !propsHeight && typeof window !== "undefined" ? window.innerHeight : propsHeight;
    mergedOptions.center = !propsCenter ? [mergedOptions.width / 2, mergedOptions.height / 2] : propsCenter;
    mergedOptions.clustering = clustering && !!nodeClusterBy;
    return mergedOptions;
  }
  runOneStep(calcGraph, clusterMap, options) {
    const { dimensions, height, width: width2, gravity, center, speed, clustering, nodeClusterBy, clusterGravity: propsClusterGravity } = options;
    const area = height * width2;
    const maxDisplace = Math.sqrt(area) / 10;
    const nodes = calcGraph.getAllNodes();
    const k2 = area / (nodes.length + 1);
    const k3 = Math.sqrt(k2);
    const displacements = {};
    this.applyCalculate(calcGraph, displacements, k3, k2);
    if (clustering) {
      for (const key in clusterMap) {
        clusterMap[key].cx = 0;
        clusterMap[key].cy = 0;
        clusterMap[key].count = 0;
      }
      nodes.forEach((node) => {
        const { data } = node;
        const c3 = clusterMap[data[nodeClusterBy]];
        if (isNumber(data.x)) {
          c3.cx += data.x;
        }
        if (isNumber(data.y)) {
          c3.cy += data.y;
        }
        c3.count++;
      });
      for (const key in clusterMap) {
        clusterMap[key].cx /= clusterMap[key].count;
        clusterMap[key].cy /= clusterMap[key].count;
      }
      const clusterGravity = propsClusterGravity || gravity;
      nodes.forEach((node, j2) => {
        const { id, data } = node;
        if (!isNumber(data.x) || !isNumber(data.y))
          return;
        const c3 = clusterMap[data[nodeClusterBy]];
        const distLength = Math.sqrt((data.x - c3.cx) * (data.x - c3.cx) + (data.y - c3.cy) * (data.y - c3.cy));
        const gravityForce = k3 * clusterGravity;
        displacements[id].x -= gravityForce * (data.x - c3.cx) / distLength;
        displacements[id].y -= gravityForce * (data.y - c3.cy) / distLength;
      });
    }
    nodes.forEach((node, j2) => {
      const { id, data } = node;
      if (!isNumber(data.x) || !isNumber(data.y))
        return;
      const gravityForce = 0.01 * k3 * gravity;
      displacements[id].x -= gravityForce * (data.x - center[0]);
      displacements[id].y -= gravityForce * (data.y - center[1]);
      if (dimensions === 3) {
        displacements[id].z -= gravityForce * (data.z - center[2]);
      }
    });
    nodes.forEach((node, j2) => {
      const { id, data } = node;
      if (isNumber(data.fx) && isNumber(data.fy)) {
        data.x = data.fx;
        data.y = data.fy;
        if (dimensions === 3) {
          data.z = data.fz;
        }
        return;
      }
      if (!isNumber(data.x) || !isNumber(data.y))
        return;
      const distLength = Math.sqrt(displacements[id].x * displacements[id].x + displacements[id].y * displacements[id].y + (dimensions === 3 ? displacements[id].z * displacements[id].z : 0));
      if (distLength > 0) {
        const limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);
        calcGraph.mergeNodeData(id, {
          x: data.x + displacements[id].x / distLength * limitedDist,
          y: data.y + displacements[id].y / distLength * limitedDist,
          z: dimensions === 3 ? data.z + displacements[id].z / distLength * limitedDist : void 0
        });
      }
    });
  }
  applyCalculate(calcGraph, displacements, k2, k22) {
    this.calRepulsive(calcGraph, displacements, k22);
    this.calAttractive(calcGraph, displacements, k2);
  }
  calRepulsive(calcGraph, displacements, k2) {
    const nodes = calcGraph.getAllNodes();
    nodes.forEach(({ data: v3, id: vid }, i2) => {
      displacements[vid] = { x: 0, y: 0, z: 0 };
      nodes.forEach(({ data: u3, id: uid }, j2) => {
        if (i2 <= j2 || !isNumber(v3.x) || !isNumber(u3.x) || !isNumber(v3.y) || !isNumber(u3.y)) {
          return;
        }
        let vecX = v3.x - u3.x;
        let vecY = v3.y - u3.y;
        let vecZ = this.options.dimensions === 3 ? v3.z - u3.z : 0;
        let lengthSqr = vecX * vecX + vecY * vecY + vecZ * vecZ;
        if (lengthSqr === 0) {
          lengthSqr = 1;
          vecX = 0.01;
          vecY = 0.01;
          vecZ = 0.01;
        }
        const common = k2 / lengthSqr;
        const dispX = vecX * common;
        const dispY = vecY * common;
        const dispZ = vecZ * common;
        displacements[vid].x += dispX;
        displacements[vid].y += dispY;
        displacements[uid].x -= dispX;
        displacements[uid].y -= dispY;
        if (this.options.dimensions === 3) {
          displacements[vid].z += dispZ;
          displacements[uid].z -= dispZ;
        }
      });
    });
  }
  calAttractive(calcGraph, displacements, k2) {
    const edges = calcGraph.getAllEdges();
    edges.forEach((e2) => {
      const { source, target } = e2;
      if (!source || !target || source === target) {
        return;
      }
      const { data: u3 } = calcGraph.getNode(source);
      const { data: v3 } = calcGraph.getNode(target);
      if (!isNumber(v3.x) || !isNumber(u3.x) || !isNumber(v3.y) || !isNumber(u3.y)) {
        return;
      }
      const vecX = v3.x - u3.x;
      const vecY = v3.y - u3.y;
      const vecZ = this.options.dimensions === 3 ? v3.z - u3.z : 0;
      const common = Math.sqrt(vecX * vecX + vecY * vecY + vecZ * vecZ) / k2;
      const dispX = vecX * common;
      const dispY = vecY * common;
      const dispZ = vecZ * common;
      displacements[source].x += dispX;
      displacements[source].y += dispY;
      displacements[target].x -= dispX;
      displacements[target].y -= dispY;
      if (this.options.dimensions === 3) {
        displacements[source].z += dispZ;
        displacements[target].z -= dispZ;
      }
    });
  }
};

// node_modules/@antv/layout/lib/grid.js
var DEFAULTS_LAYOUT_OPTIONS9 = {
  begin: [0, 0],
  preventOverlap: true,
  preventOverlapPadding: 10,
  condense: false,
  rows: void 0,
  cols: void 0,
  position: void 0,
  sortBy: "degree",
  nodeSize: 30,
  width: 300,
  height: 300
};
var GridLayout = class {
  constructor(options = {}) {
    this.options = options;
    this.id = "grid";
    this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS9), options);
  }
  /**
   * Return the positions of nodes and edges(if needed).
   */
  execute(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.genericGridLayout(false, graph, options);
    });
  }
  /**
   * To directly assign the positions to the nodes.
   */
  assign(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.genericGridLayout(true, graph, options);
    });
  }
  genericGridLayout(assign, graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const mergedOptions = Object.assign(Object.assign({}, this.options), options);
      const { begin = [0, 0], condense, preventOverlapPadding, preventOverlap, rows: propsRows, cols: propsCols, nodeSpacing: paramNodeSpacing, nodeSize: paramNodeSize, width: propsWidth, height: propsHeight, position: position2 } = mergedOptions;
      let { sortBy } = mergedOptions;
      const nodes = graph.getAllNodes();
      const edges = graph.getAllEdges();
      const n2 = nodes === null || nodes === void 0 ? void 0 : nodes.length;
      if (!n2 || n2 === 1) {
        return handleSingleNodeGraph(graph, assign, begin);
      }
      const layoutNodes = nodes.map((node) => cloneFormatData(node));
      if (
        // `id` should be reserved keyword
        sortBy !== "id" && (!isString(sortBy) || layoutNodes[0].data[sortBy] === void 0)
      ) {
        sortBy = "degree";
      }
      if (sortBy === "degree") {
        layoutNodes.sort((n1, n22) => graph.getDegree(n22.id, "both") - graph.getDegree(n1.id, "both"));
      } else if (sortBy === "id") {
        layoutNodes.sort((n1, n22) => {
          if (isNumber(n22.id) && isNumber(n1.id)) {
            return n22.id - n1.id;
          }
          return `${n1.id}`.localeCompare(`${n22.id}`);
        });
      } else {
        layoutNodes.sort((n1, n22) => n22.data[sortBy] - n1.data[sortBy]);
      }
      const width2 = !propsWidth && typeof window !== "undefined" ? window.innerWidth : propsWidth;
      const height = !propsHeight && typeof window !== "undefined" ? window.innerHeight : propsHeight;
      const cells = n2;
      const rcs = { rows: propsRows, cols: propsCols };
      if (propsRows != null && propsCols != null) {
        rcs.rows = propsRows;
        rcs.cols = propsCols;
      } else if (propsRows != null && propsCols == null) {
        rcs.rows = propsRows;
        rcs.cols = Math.ceil(cells / rcs.rows);
      } else if (propsRows == null && propsCols != null) {
        rcs.cols = propsCols;
        rcs.rows = Math.ceil(cells / rcs.cols);
      } else {
        const splits = Math.sqrt(cells * height / width2);
        rcs.rows = Math.round(splits);
        rcs.cols = Math.round(width2 / height * splits);
      }
      rcs.rows = Math.max(rcs.rows, 1);
      rcs.cols = Math.max(rcs.cols, 1);
      if (rcs.cols * rcs.rows > cells) {
        const sm = small(rcs);
        const lg = large(rcs);
        if ((sm - 1) * lg >= cells) {
          small(rcs, sm - 1);
        } else if ((lg - 1) * sm >= cells) {
          large(rcs, lg - 1);
        }
      } else {
        while (rcs.cols * rcs.rows < cells) {
          const sm = small(rcs);
          const lg = large(rcs);
          if ((lg + 1) * sm >= cells) {
            large(rcs, lg + 1);
          } else {
            small(rcs, sm + 1);
          }
        }
      }
      let cellWidth = condense ? 0 : width2 / rcs.cols;
      let cellHeight = condense ? 0 : height / rcs.rows;
      if (preventOverlap || paramNodeSpacing) {
        const nodeSpacing = formatNumberFn(10, paramNodeSpacing);
        const nodeSize = formatSizeFn(30, paramNodeSize, false);
        layoutNodes.forEach((node) => {
          if (!node.data.x || !node.data.y) {
            node.data.x = 0;
            node.data.y = 0;
          }
          const oNode = graph.getNode(node.id);
          const [nodeW, nodeH] = parseSize2(nodeSize(oNode) || 30);
          const p3 = nodeSpacing !== void 0 ? nodeSpacing(node) : preventOverlapPadding;
          const w3 = nodeW + p3;
          const h3 = nodeH + p3;
          cellWidth = Math.max(cellWidth, w3);
          cellHeight = Math.max(cellHeight, h3);
        });
      }
      const cellUsed = {};
      const rc = { row: 0, col: 0 };
      const id2manPos = {};
      for (let i2 = 0; i2 < layoutNodes.length; i2++) {
        const node = layoutNodes[i2];
        let rcPos;
        if (position2) {
          rcPos = position2(graph.getNode(node.id));
        }
        if (rcPos && (rcPos.row !== void 0 || rcPos.col !== void 0)) {
          const pos = {
            row: rcPos.row,
            col: rcPos.col
          };
          if (pos.col === void 0) {
            pos.col = 0;
            while (used(cellUsed, pos)) {
              pos.col++;
            }
          } else if (pos.row === void 0) {
            pos.row = 0;
            while (used(cellUsed, pos)) {
              pos.row++;
            }
          }
          id2manPos[node.id] = pos;
          use(cellUsed, pos);
        }
        getPos(node, begin, cellWidth, cellHeight, id2manPos, rcs, rc, cellUsed);
      }
      const result = {
        nodes: layoutNodes,
        edges
      };
      if (assign) {
        layoutNodes.forEach((node) => {
          graph.mergeNodeData(node.id, {
            x: node.data.x,
            y: node.data.y
          });
        });
      }
      return result;
    });
  }
};
var small = (rcs, val) => {
  let res;
  const rows = rcs.rows || 5;
  const cols = rcs.cols || 5;
  if (val == null) {
    res = Math.min(rows, cols);
  } else {
    const min2 = Math.min(rows, cols);
    if (min2 === rcs.rows) {
      rcs.rows = val;
    } else {
      rcs.cols = val;
    }
  }
  return res;
};
var large = (rcs, val) => {
  let result;
  const usedRows = rcs.rows || 5;
  const usedCols = rcs.cols || 5;
  if (val == null) {
    result = Math.max(usedRows, usedCols);
  } else {
    const max2 = Math.max(usedRows, usedCols);
    if (max2 === rcs.rows) {
      rcs.rows = val;
    } else {
      rcs.cols = val;
    }
  }
  return result;
};
var used = (cellUsed, rc) => cellUsed[`c-${rc.row}-${rc.col}`] || false;
var use = (cellUsed, rc) => cellUsed[`c-${rc.row}-${rc.col}`] = true;
var moveToNextCell = (rcs, rc) => {
  const cols = rcs.cols || 5;
  rc.col++;
  if (rc.col >= cols) {
    rc.col = 0;
    rc.row++;
  }
};
var getPos = (node, begin, cellWidth, cellHeight, id2manPos, rcs, rc, cellUsed) => {
  let x4;
  let y4;
  const rcPos = id2manPos[node.id];
  if (rcPos) {
    x4 = rcPos.col * cellWidth + cellWidth / 2 + begin[0];
    y4 = rcPos.row * cellHeight + cellHeight / 2 + begin[1];
  } else {
    while (used(cellUsed, rc)) {
      moveToNextCell(rcs, rc);
    }
    x4 = rc.col * cellWidth + cellWidth / 2 + begin[0];
    y4 = rc.row * cellHeight + cellHeight / 2 + begin[1];
    use(cellUsed, rc);
    moveToNextCell(rcs, rc);
  }
  node.data.x = x4;
  node.data.y = y4;
};

// node_modules/@antv/layout/lib/radial/mds.js
var mds = (dimension, distances, linkDistance) => {
  try {
    const M3 = Matrix2.mul(Matrix2.pow(distances, 2), -0.5);
    const rowMeans = M3.mean("row");
    const colMeans = M3.mean("column");
    const totalMean = M3.mean();
    M3.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans);
    const ret = new SingularValueDecomposition2(M3);
    const eigenValues = Matrix2.sqrt(ret.diagonalMatrix).diagonal();
    return ret.leftSingularVectors.toJSON().map((row) => {
      return Matrix2.mul([row], [eigenValues]).toJSON()[0].splice(0, dimension);
    });
  } catch (_a) {
    const res = [];
    for (let i2 = 0; i2 < distances.length; i2++) {
      const x4 = Math.random() * linkDistance;
      const y4 = Math.random() * linkDistance;
      res.push([x4, y4]);
    }
    return res;
  }
};

// node_modules/@antv/layout/lib/radial/radial-nonoverlap-force.js
var SPEED_DIVISOR2 = 800;
var DEFAULTS_LAYOUT_OPTIONS10 = {
  iterations: 10,
  height: 10,
  width: 10,
  speed: 100,
  gravity: 10,
  k: 5
};
var radialNonoverlapForce = (graph, options) => {
  const mergedOptions = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS10), options);
  const { positions, iterations, width: width2, k: k2, speed = 100, strictRadial, focusIdx, radii = [], nodeSizeFunc } = mergedOptions;
  const nodes = graph.getAllNodes();
  const disp = [];
  const maxDisplace = width2 / 10;
  for (let i2 = 0; i2 < iterations; i2++) {
    positions.forEach((_2, k3) => {
      disp[k3] = { x: 0, y: 0 };
    });
    getRepulsion(nodes, positions, disp, k2, radii, nodeSizeFunc);
    updatePositions(positions, disp, speed, strictRadial, focusIdx, maxDisplace, width2, radii);
  }
  return positions;
};
var getRepulsion = (nodes, positions, disp, k2, radii, nodeSizeFunc) => {
  positions.forEach((v3, i2) => {
    disp[i2] = { x: 0, y: 0 };
    positions.forEach((u3, j2) => {
      if (i2 === j2) {
        return;
      }
      if (radii[i2] !== radii[j2]) {
        return;
      }
      let vecx = v3.x - u3.x;
      let vecy = v3.y - u3.y;
      let vecLength = Math.sqrt(vecx * vecx + vecy * vecy);
      if (vecLength === 0) {
        vecLength = 1;
        const sign = i2 > j2 ? 1 : -1;
        vecx = 0.01 * sign;
        vecy = 0.01 * sign;
      }
      if (vecLength < nodeSizeFunc(nodes[i2]) / 2 + nodeSizeFunc(nodes[j2]) / 2) {
        const common = k2 * k2 / vecLength;
        disp[i2].x += vecx / vecLength * common;
        disp[i2].y += vecy / vecLength * common;
      }
    });
  });
};
var updatePositions = (positions, disp, speed, strictRadial, focusIdx, maxDisplace, width2, radii) => {
  const maxDisp = maxDisplace || width2 / 10;
  if (strictRadial) {
    disp.forEach((di, i2) => {
      const vx = positions[i2].x - positions[focusIdx].x;
      const vy = positions[i2].y - positions[focusIdx].y;
      const vLength = Math.sqrt(vx * vx + vy * vy);
      let vpx = vy / vLength;
      let vpy = -vx / vLength;
      const diLength = Math.sqrt(di.x * di.x + di.y * di.y);
      let alpha = Math.acos((vpx * di.x + vpy * di.y) / diLength);
      if (alpha > Math.PI / 2) {
        alpha -= Math.PI / 2;
        vpx *= -1;
        vpy *= -1;
      }
      const tdispLength = Math.cos(alpha) * diLength;
      di.x = vpx * tdispLength;
      di.y = vpy * tdispLength;
    });
  }
  positions.forEach((n2, i2) => {
    if (i2 === focusIdx) {
      return;
    }
    const distLength = Math.sqrt(disp[i2].x * disp[i2].x + disp[i2].y * disp[i2].y);
    if (distLength > 0 && i2 !== focusIdx) {
      const limitedDist = Math.min(maxDisp * (speed / SPEED_DIVISOR2), distLength);
      n2.x += disp[i2].x / distLength * limitedDist;
      n2.y += disp[i2].y / distLength * limitedDist;
      if (strictRadial) {
        let vx = n2.x - positions[focusIdx].x;
        let vy = n2.y - positions[focusIdx].y;
        const nfDis = Math.sqrt(vx * vx + vy * vy);
        vx = vx / nfDis * radii[i2];
        vy = vy / nfDis * radii[i2];
        n2.x = positions[focusIdx].x + vx;
        n2.y = positions[focusIdx].y + vy;
      }
    }
  });
  return positions;
};

// node_modules/@antv/layout/lib/radial/index.js
var DEFAULTS_LAYOUT_OPTIONS11 = {
  maxIteration: 1e3,
  focusNode: null,
  unitRadius: null,
  linkDistance: 50,
  preventOverlap: false,
  strictRadial: true,
  maxPreventOverlapIteration: 200,
  sortStrength: 10
};
var RadialLayout = class {
  constructor(options = {}) {
    this.options = options;
    this.id = "radial";
    this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS11), options);
  }
  /**
   * Return the positions of nodes and edges(if needed).
   */
  execute(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.genericRadialLayout(false, graph, options);
    });
  }
  /**
   * To directly assign the positions to the nodes.
   */
  assign(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.genericRadialLayout(true, graph, options);
    });
  }
  genericRadialLayout(assign, graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const mergedOptions = Object.assign(Object.assign({}, this.options), options);
      const { width: propsWidth, height: propsHeight, center: propsCenter, focusNode: propsFocusNode, unitRadius: propsUnitRadius, nodeSize, nodeSpacing, strictRadial, preventOverlap, maxPreventOverlapIteration, sortBy, linkDistance = 50, sortStrength = 10, maxIteration = 1e3 } = mergedOptions;
      const nodes = graph.getAllNodes();
      const edges = graph.getAllEdges();
      const width2 = !propsWidth && typeof window !== "undefined" ? window.innerWidth : propsWidth;
      const height = !propsHeight && typeof window !== "undefined" ? window.innerHeight : propsHeight;
      const center = !propsCenter ? [width2 / 2, height / 2] : propsCenter;
      if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length) || nodes.length === 1) {
        return handleSingleNodeGraph(graph, assign, center);
      }
      let focusNode = nodes[0];
      if (isString(propsFocusNode)) {
        for (let i2 = 0; i2 < nodes.length; i2++) {
          if (nodes[i2].id === propsFocusNode) {
            focusNode = nodes[i2];
            break;
          }
        }
      } else {
        focusNode = propsFocusNode || nodes[0];
      }
      const focusIndex = getIndexById(nodes, focusNode.id);
      const adjMatrix = getAdjMatrix({ nodes, edges }, false);
      const distances = floydWarshall(adjMatrix);
      const maxDistance = maxToFocus(distances, focusIndex);
      handleInfinity2(distances, focusIndex, maxDistance + 1);
      const focusNodeD = distances[focusIndex];
      let semiWidth = width2 - center[0] > center[0] ? center[0] : width2 - center[0];
      let semiHeight = height - center[1] > center[1] ? center[1] : height - center[1];
      if (semiWidth === 0) {
        semiWidth = width2 / 2;
      }
      if (semiHeight === 0) {
        semiHeight = height / 2;
      }
      const maxRadius = Math.min(semiWidth, semiHeight);
      const maxD = Math.max(...focusNodeD);
      const radii = [];
      const unitRadius = !propsUnitRadius ? maxRadius / maxD : propsUnitRadius;
      focusNodeD.forEach((value, i2) => {
        radii[i2] = value * unitRadius;
      });
      const idealDistances = eIdealDisMatrix(nodes, distances, linkDistance, radii, unitRadius, sortBy, sortStrength);
      const weights = getWeightMatrix(idealDistances);
      const mdsResult = mds(linkDistance, idealDistances, linkDistance);
      let positions = mdsResult.map(([x4, y4]) => ({
        x: (isNaN(x4) ? Math.random() * linkDistance : x4) - mdsResult[focusIndex][0],
        y: (isNaN(y4) ? Math.random() * linkDistance : y4) - mdsResult[focusIndex][1]
      }));
      this.run(maxIteration, positions, weights, idealDistances, radii, focusIndex);
      let nodeSizeFunc;
      if (preventOverlap) {
        nodeSizeFunc = formatNodeSizeToNumber(nodeSize, nodeSpacing);
        const nonoverlapForceParams = {
          nodes,
          nodeSizeFunc,
          positions,
          radii,
          height,
          width: width2,
          strictRadial: Boolean(strictRadial),
          focusIdx: focusIndex,
          iterations: maxPreventOverlapIteration || 200,
          k: positions.length / 4.5
        };
        positions = radialNonoverlapForce(graph, nonoverlapForceParams);
      }
      const layoutNodes = [];
      positions.forEach((p3, i2) => {
        const cnode = cloneFormatData(nodes[i2]);
        cnode.data.x = p3.x + center[0];
        cnode.data.y = p3.y + center[1];
        layoutNodes.push(cnode);
      });
      if (assign) {
        layoutNodes.forEach((node) => graph.mergeNodeData(node.id, {
          x: node.data.x,
          y: node.data.y
        }));
      }
      const result = {
        nodes: layoutNodes,
        edges
      };
      return result;
    });
  }
  run(maxIteration, positions, weights, idealDistances, radii, focusIndex) {
    for (let i2 = 0; i2 <= maxIteration; i2++) {
      const param = i2 / maxIteration;
      this.oneIteration(param, positions, radii, idealDistances, weights, focusIndex);
    }
  }
  oneIteration(param, positions, radii, distances, weights, focusIndex) {
    const vparam = 1 - param;
    positions.forEach((v3, i2) => {
      const originDis = getEuclideanDistance(v3, { x: 0, y: 0 });
      const reciODis = originDis === 0 ? 0 : 1 / originDis;
      if (i2 === focusIndex) {
        return;
      }
      let xMolecule = 0;
      let yMolecule = 0;
      let denominator = 0;
      positions.forEach((u3, j2) => {
        if (i2 === j2) {
          return;
        }
        const edis = getEuclideanDistance(v3, u3);
        const reciEdis = edis === 0 ? 0 : 1 / edis;
        const idealDis = distances[j2][i2];
        denominator += weights[i2][j2];
        xMolecule += weights[i2][j2] * (u3.x + idealDis * (v3.x - u3.x) * reciEdis);
        yMolecule += weights[i2][j2] * (u3.y + idealDis * (v3.y - u3.y) * reciEdis);
      });
      const reciR = radii[i2] === 0 ? 0 : 1 / radii[i2];
      denominator *= vparam;
      denominator += param * reciR * reciR;
      xMolecule *= vparam;
      xMolecule += param * reciR * v3.x * reciODis;
      v3.x = xMolecule / denominator;
      yMolecule *= vparam;
      yMolecule += param * reciR * v3.y * reciODis;
      v3.y = yMolecule / denominator;
    });
  }
};
var eIdealDisMatrix = (nodes, distances, linkDistance, radii, unitRadius, sortBy, sortStrength) => {
  if (!nodes)
    return [];
  const result = [];
  if (distances) {
    const sortValueCache = {};
    distances.forEach((row, i2) => {
      const newRow = [];
      row.forEach((v3, j2) => {
        var _a, _b;
        if (i2 === j2) {
          newRow.push(0);
        } else if (radii[i2] === radii[j2]) {
          if (sortBy === "data") {
            newRow.push(v3 * (Math.abs(i2 - j2) * sortStrength) / (radii[i2] / unitRadius));
          } else if (sortBy) {
            let iValue;
            let jValue;
            if (sortValueCache[nodes[i2].id]) {
              iValue = sortValueCache[nodes[i2].id];
            } else {
              const value = (sortBy === "id" ? nodes[i2].id : (_a = nodes[i2].data) === null || _a === void 0 ? void 0 : _a[sortBy]) || 0;
              if (isString(value)) {
                iValue = value.charCodeAt(0);
              } else {
                iValue = value;
              }
              sortValueCache[nodes[i2].id] = iValue;
            }
            if (sortValueCache[nodes[j2].id]) {
              jValue = sortValueCache[nodes[j2].id];
            } else {
              const value = (sortBy === "id" ? nodes[j2].id : (_b = nodes[j2].data) === null || _b === void 0 ? void 0 : _b[sortBy]) || 0;
              if (isString(value)) {
                jValue = value.charCodeAt(0);
              } else {
                jValue = value;
              }
              sortValueCache[nodes[j2].id] = jValue;
            }
            newRow.push(v3 * (Math.abs(iValue - jValue) * sortStrength) / (radii[i2] / unitRadius));
          } else {
            newRow.push(v3 * linkDistance / (radii[i2] / unitRadius));
          }
        } else {
          const link = (linkDistance + unitRadius) / 2;
          newRow.push(v3 * link);
        }
      });
      result.push(newRow);
    });
  }
  return result;
};
var getWeightMatrix = (idealDistances) => {
  const rows = idealDistances.length;
  const cols = idealDistances[0].length;
  const result = [];
  for (let i2 = 0; i2 < rows; i2++) {
    const row = [];
    for (let j2 = 0; j2 < cols; j2++) {
      if (idealDistances[i2][j2] !== 0) {
        row.push(1 / (idealDistances[i2][j2] * idealDistances[i2][j2]));
      } else {
        row.push(0);
      }
    }
    result.push(row);
  }
  return result;
};
var getIndexById = (array, id) => {
  let index = -1;
  array.forEach((a3, i2) => {
    if (a3.id === id) {
      index = i2;
    }
  });
  return Math.max(index, 0);
};
var handleInfinity2 = (matrix2, focusIndex, step) => {
  const length = matrix2.length;
  for (let i2 = 0; i2 < length; i2++) {
    if (matrix2[focusIndex][i2] === Infinity) {
      matrix2[focusIndex][i2] = step;
      matrix2[i2][focusIndex] = step;
      for (let j2 = 0; j2 < length; j2++) {
        if (matrix2[i2][j2] !== Infinity && matrix2[focusIndex][j2] === Infinity) {
          matrix2[focusIndex][j2] = step + matrix2[i2][j2];
          matrix2[j2][focusIndex] = step + matrix2[i2][j2];
        }
      }
    }
  }
  for (let i2 = 0; i2 < length; i2++) {
    if (i2 === focusIndex) {
      continue;
    }
    for (let j2 = 0; j2 < length; j2++) {
      if (matrix2[i2][j2] === Infinity) {
        let minus = Math.abs(matrix2[focusIndex][i2] - matrix2[focusIndex][j2]);
        minus = minus === 0 ? 1 : minus;
        matrix2[i2][j2] = minus;
      }
    }
  }
};
var maxToFocus = (matrix2, focusIndex) => {
  let max2 = 0;
  for (let i2 = 0; i2 < matrix2[focusIndex].length; i2++) {
    if (matrix2[focusIndex][i2] === Infinity) {
      continue;
    }
    max2 = matrix2[focusIndex][i2] > max2 ? matrix2[focusIndex][i2] : max2;
  }
  return max2;
};

// node_modules/@antv/layout/lib/random.js
var DEFAULTS_LAYOUT_OPTIONS12 = {
  center: [0, 0],
  width: 300,
  height: 300
};
var RandomLayout = class {
  constructor(options = {}) {
    this.options = options;
    this.id = "random";
    this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS12), options);
  }
  /**
   * Return the positions of nodes and edges(if needed).
   */
  execute(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.genericRandomLayout(false, graph, options);
    });
  }
  /**
   * To directly assign the positions to the nodes.
   */
  assign(graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.genericRandomLayout(true, graph, options);
    });
  }
  genericRandomLayout(assign, graph, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const mergedOptions = Object.assign(Object.assign({}, this.options), options);
      const { center: propsCenter, width: propsWidth, height: propsHeight } = mergedOptions;
      const nodes = graph.getAllNodes();
      const layoutScale = 0.9;
      const width2 = !propsWidth && typeof window !== "undefined" ? window.innerWidth : propsWidth;
      const height = !propsHeight && typeof window !== "undefined" ? window.innerHeight : propsHeight;
      const center = !propsCenter ? [width2 / 2, height / 2] : propsCenter;
      const layoutNodes = [];
      if (nodes) {
        nodes.forEach((node) => {
          layoutNodes.push({
            id: node.id,
            data: {
              x: (Math.random() - 0.5) * layoutScale * width2 + center[0],
              y: (Math.random() - 0.5) * layoutScale * height + center[1]
            }
          });
        });
      }
      if (assign) {
        layoutNodes.forEach((node) => graph.mergeNodeData(node.id, {
          x: node.data.x,
          y: node.data.y
        }));
      }
      const result = {
        nodes: layoutNodes,
        edges: graph.getAllEdges()
      };
      return result;
    });
  }
};

// node_modules/comlink/dist/esm/comlink.mjs
var proxyMarker = Symbol("Comlink.proxy");
var createEndpoint = Symbol("Comlink.endpoint");
var releaseProxy = Symbol("Comlink.releaseProxy");
var finalizer = Symbol("Comlink.finalizer");
var throwMarker = Symbol("Comlink.thrown");
var isObject = (val) => typeof val === "object" && val !== null || typeof val === "function";
var proxyTransferHandler = {
  canHandle: (val) => isObject(val) && val[proxyMarker],
  serialize(obj) {
    const { port1, port2 } = new MessageChannel();
    expose(obj, port1);
    return [port2, [port2]];
  },
  deserialize(port) {
    port.start();
    return wrap2(port);
  }
};
var throwTransferHandler = {
  canHandle: (value) => isObject(value) && throwMarker in value,
  serialize({ value }) {
    let serialized;
    if (value instanceof Error) {
      serialized = {
        isError: true,
        value: {
          message: value.message,
          name: value.name,
          stack: value.stack
        }
      };
    } else {
      serialized = { isError: false, value };
    }
    return [serialized, []];
  },
  deserialize(serialized) {
    if (serialized.isError) {
      throw Object.assign(new Error(serialized.value.message), serialized.value);
    }
    throw serialized.value;
  }
};
var transferHandlers = /* @__PURE__ */ new Map([
  ["proxy", proxyTransferHandler],
  ["throw", throwTransferHandler]
]);
function isAllowedOrigin(allowedOrigins, origin) {
  for (const allowedOrigin of allowedOrigins) {
    if (origin === allowedOrigin || allowedOrigin === "*") {
      return true;
    }
    if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
      return true;
    }
  }
  return false;
}
function expose(obj, ep = globalThis, allowedOrigins = ["*"]) {
  ep.addEventListener("message", function callback(ev) {
    if (!ev || !ev.data) {
      return;
    }
    if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
      console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
      return;
    }
    const { id, type, path } = Object.assign({ path: [] }, ev.data);
    const argumentList = (ev.data.argumentList || []).map(fromWireValue);
    let returnValue;
    try {
      const parent = path.slice(0, -1).reduce((obj2, prop) => obj2[prop], obj);
      const rawValue = path.reduce((obj2, prop) => obj2[prop], obj);
      switch (type) {
        case "GET":
          {
            returnValue = rawValue;
          }
          break;
        case "SET":
          {
            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
            returnValue = true;
          }
          break;
        case "APPLY":
          {
            returnValue = rawValue.apply(parent, argumentList);
          }
          break;
        case "CONSTRUCT":
          {
            const value = new rawValue(...argumentList);
            returnValue = proxy(value);
          }
          break;
        case "ENDPOINT":
          {
            const { port1, port2 } = new MessageChannel();
            expose(obj, port2);
            returnValue = transfer(port1, [port1]);
          }
          break;
        case "RELEASE":
          {
            returnValue = void 0;
          }
          break;
        default:
          return;
      }
    } catch (value) {
      returnValue = { value, [throwMarker]: 0 };
    }
    Promise.resolve(returnValue).catch((value) => {
      return { value, [throwMarker]: 0 };
    }).then((returnValue2) => {
      const [wireValue, transferables] = toWireValue(returnValue2);
      ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
      if (type === "RELEASE") {
        ep.removeEventListener("message", callback);
        closeEndPoint(ep);
        if (finalizer in obj && typeof obj[finalizer] === "function") {
          obj[finalizer]();
        }
      }
    }).catch((error) => {
      const [wireValue, transferables] = toWireValue({
        value: new TypeError("Unserializable return value"),
        [throwMarker]: 0
      });
      ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
    });
  });
  if (ep.start) {
    ep.start();
  }
}
function isMessagePort(endpoint) {
  return endpoint.constructor.name === "MessagePort";
}
function closeEndPoint(endpoint) {
  if (isMessagePort(endpoint))
    endpoint.close();
}
function wrap2(ep, target) {
  const pendingListeners = /* @__PURE__ */ new Map();
  ep.addEventListener("message", function handleMessage(ev) {
    const { data } = ev;
    if (!data || !data.id) {
      return;
    }
    const resolver = pendingListeners.get(data.id);
    if (!resolver) {
      return;
    }
    try {
      resolver(data);
    } finally {
      pendingListeners.delete(data.id);
    }
  });
  return createProxy(ep, pendingListeners, [], target);
}
function throwIfProxyReleased(isReleased) {
  if (isReleased) {
    throw new Error("Proxy has been released and is not useable");
  }
}
function releaseEndpoint(ep) {
  return requestResponseMessage(ep, /* @__PURE__ */ new Map(), {
    type: "RELEASE"
  }).then(() => {
    closeEndPoint(ep);
  });
}
var proxyCounter = /* @__PURE__ */ new WeakMap();
var proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep) => {
  const newCount = (proxyCounter.get(ep) || 0) - 1;
  proxyCounter.set(ep, newCount);
  if (newCount === 0) {
    releaseEndpoint(ep);
  }
});
function registerProxy(proxy2, ep) {
  const newCount = (proxyCounter.get(ep) || 0) + 1;
  proxyCounter.set(ep, newCount);
  if (proxyFinalizers) {
    proxyFinalizers.register(proxy2, ep, proxy2);
  }
}
function unregisterProxy(proxy2) {
  if (proxyFinalizers) {
    proxyFinalizers.unregister(proxy2);
  }
}
function createProxy(ep, pendingListeners, path = [], target = function() {
}) {
  let isProxyReleased = false;
  const proxy2 = new Proxy(target, {
    get(_target, prop) {
      throwIfProxyReleased(isProxyReleased);
      if (prop === releaseProxy) {
        return () => {
          unregisterProxy(proxy2);
          releaseEndpoint(ep);
          pendingListeners.clear();
          isProxyReleased = true;
        };
      }
      if (prop === "then") {
        if (path.length === 0) {
          return { then: () => proxy2 };
        }
        const r3 = requestResponseMessage(ep, pendingListeners, {
          type: "GET",
          path: path.map((p3) => p3.toString())
        }).then(fromWireValue);
        return r3.then.bind(r3);
      }
      return createProxy(ep, pendingListeners, [...path, prop]);
    },
    set(_target, prop, rawValue) {
      throwIfProxyReleased(isProxyReleased);
      const [value, transferables] = toWireValue(rawValue);
      return requestResponseMessage(ep, pendingListeners, {
        type: "SET",
        path: [...path, prop].map((p3) => p3.toString()),
        value
      }, transferables).then(fromWireValue);
    },
    apply(_target, _thisArg, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const last2 = path[path.length - 1];
      if (last2 === createEndpoint) {
        return requestResponseMessage(ep, pendingListeners, {
          type: "ENDPOINT"
        }).then(fromWireValue);
      }
      if (last2 === "bind") {
        return createProxy(ep, pendingListeners, path.slice(0, -1));
      }
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep, pendingListeners, {
        type: "APPLY",
        path: path.map((p3) => p3.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    },
    construct(_target, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep, pendingListeners, {
        type: "CONSTRUCT",
        path: path.map((p3) => p3.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    }
  });
  registerProxy(proxy2, ep);
  return proxy2;
}
function myFlat(arr) {
  return Array.prototype.concat.apply([], arr);
}
function processArguments(argumentList) {
  const processed = argumentList.map(toWireValue);
  return [processed.map((v3) => v3[0]), myFlat(processed.map((v3) => v3[1]))];
}
var transferCache = /* @__PURE__ */ new WeakMap();
function transfer(obj, transfers) {
  transferCache.set(obj, transfers);
  return obj;
}
function proxy(obj) {
  return Object.assign(obj, { [proxyMarker]: true });
}
function toWireValue(value) {
  for (const [name, handler] of transferHandlers) {
    if (handler.canHandle(value)) {
      const [serializedValue, transferables] = handler.serialize(value);
      return [
        {
          type: "HANDLER",
          name,
          value: serializedValue
        },
        transferables
      ];
    }
  }
  return [
    {
      type: "RAW",
      value
    },
    transferCache.get(value) || []
  ];
}
function fromWireValue(value) {
  switch (value.type) {
    case "HANDLER":
      return transferHandlers.get(value.name).deserialize(value.value);
    case "RAW":
      return value.value;
  }
}
function requestResponseMessage(ep, pendingListeners, msg, transfers) {
  return new Promise((resolve) => {
    const id = generateUUID();
    pendingListeners.set(id, resolve);
    if (ep.start) {
      ep.start();
    }
    ep.postMessage(Object.assign({ id }, msg), transfers);
  });
}
function generateUUID() {
  return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
}

// node_modules/@antv/layout/lib/supervisor.js
var Supervisor = class extends esm_default {
  constructor(graph, layout2, options) {
    super();
    this.graph = graph;
    this.layout = layout2;
    this.options = options;
    this.spawnWorker();
  }
  spawnWorker() {
    this.proxy = wrap2(
      // @ts-ignore
      new Worker(new URL("./worker.js", import.meta.url), { type: "module" })
    );
    if (this.running) {
      this.running = false;
      this.execute();
    }
  }
  execute() {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      if (this.running)
        return this;
      this.running = true;
      const _b = this.layout.options, { onTick } = _b, rest = __rest(_b, ["onTick"]);
      const noFunctionOptions = {};
      Object.keys(rest).forEach((name) => {
        if (!isFunction(rest[name]))
          noFunctionOptions[name] = rest[name];
      });
      const payload = {
        layout: {
          id: this.layout.id,
          options: noFunctionOptions,
          iterations: (_a = this.options) === null || _a === void 0 ? void 0 : _a.iterations
        },
        nodes: this.graph.getAllNodes(),
        edges: this.graph.getAllEdges()
      };
      const arraybufferWithNodesEdges = new Float32Array([0]);
      const [positions] = yield this.proxy.calculateLayout(payload, [
        arraybufferWithNodesEdges
      ]);
      return positions;
    });
  }
  stop() {
    this.running = false;
    this.proxy.stopLayout();
    return this;
  }
  kill() {
    this.proxy[releaseProxy]();
  }
  isRunning() {
    return this.running;
  }
};

// node_modules/@antv/g6/esm/layouts/fishbone.js
var __awaiter13 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var FishboneLayout = class _FishboneLayout extends BaseLayout {
  constructor() {
    super(...arguments);
    this.id = "fishbone";
  }
  getRoot() {
    const roots = this.context.model.getRootsData();
    if (is_empty_default(roots) || roots.length > 2)
      return;
    return roots[0];
  }
  formatSize(nodeSize) {
    const nodeSizeFunc = typeof nodeSize === "function" ? nodeSize : () => nodeSize;
    return (node) => parseSize(nodeSizeFunc(node));
  }
  doLayout(root, options) {
    const { hGap, getRibSep, vGap, nodeSize, height } = options;
    const { model } = this.context;
    const getSize = this.formatSize(nodeSize);
    let ribX = getSize(root)[0] + getRibSep(root);
    const getHorizontalOffset = (node, result2 = 0) => {
      var _a;
      result2 += hGap * ((node.children || []).length + 1);
      (_a = node.children) === null || _a === void 0 ? void 0 : _a.forEach((childId) => {
        var _a2;
        const child = model.getNodeLikeDatum(childId);
        (_a2 = child.children) === null || _a2 === void 0 ? void 0 : _a2.forEach((grandChildId) => {
          const grandChild = model.getNodeLikeDatum(grandChildId);
          result2 = getHorizontalOffset(grandChild, result2);
        });
      });
      return result2;
    };
    const getAuxiliaryPoint = (node) => {
      if (node.depth === 1)
        return ribX;
      const parent = model.getParentData(node.id, "tree");
      if (isAtEvenDepth(node)) {
        const ancestor = model.getParentData(parent.id, "tree");
        const deltaY = calculateY(node) - calculateY(ancestor);
        return getAuxiliaryPoint(parent) + deltaY * hGap / vGap;
      } else {
        const nodeIndex = (parent.children || []).indexOf(node.id);
        const followingSiblingsIncludeSelf = model.getNodeData((parent.children || []).slice(nodeIndex));
        return calculateX(parent) - followingSiblingsIncludeSelf.reduce((acc, sibling) => acc + getHorizontalOffset(sibling), 0) - getSize(parent)[0] / 2;
      }
    };
    const calculateX = memoize((node) => {
      if (isRoot(node))
        return getSize(node)[0] / 2;
      const parent = model.getParentData(node.id, "tree");
      if (isAtEvenDepth(node)) {
        return getAuxiliaryPoint(node) + getHorizontalOffset(node) + getSize(node)[0] / 2;
      } else {
        const deltaY = calculateY(node) - calculateY(parent);
        const ratio = hGap / vGap;
        return getAuxiliaryPoint(node) + deltaY * ratio;
      }
    }, (node) => node.id);
    const getParentY = (nodeId) => calculateY(model.getParentData(nodeId, "tree"));
    const calculateY = memoize((node) => {
      if (isRoot(node))
        return height / 2;
      if (!isAtEvenDepth(node)) {
        if (is_empty_default(node.children))
          return getParentY(node.id) + vGap;
        const lastChild = model.getNodeLikeDatum(node.children.slice(-1)[0]);
        if (is_empty_default(lastChild.children))
          return calculateY(lastChild) + vGap;
        const lastDescendant = model.getDescendantsData(node.id).slice(-1)[0];
        return (isAtEvenDepth(lastDescendant) ? getParentY(lastDescendant.id) : calculateY(lastDescendant)) + vGap;
      } else {
        const parent = model.getParentData(node.id, "tree");
        const nodeIndex = parent.children.indexOf(node.id);
        if (nodeIndex === 0)
          return getParentY(parent.id) + vGap;
        const prevSibling = model.getNodeLikeDatum(parent.children[nodeIndex - 1]);
        if (is_empty_default(prevSibling.children))
          return calculateY(prevSibling) + vGap;
        const descendants = model.getDescendantsData(prevSibling.id);
        return Math.max(...descendants.map((descendant) => isAtEvenDepth(descendant) ? getParentY(descendant.id) : calculateY(descendant))) + vGap;
      }
    }, (node) => node.id);
    let tmpRibX = 0;
    const result = { nodes: [], edges: [] };
    const layout2 = (node) => {
      var _a;
      (_a = node.children) === null || _a === void 0 ? void 0 : _a.forEach((childId) => layout2(model.getNodeLikeDatum(childId)));
      const y4 = calculateY(node);
      const x4 = calculateX(node);
      result.nodes.push({ id: node.id, x: x4, y: y4 });
      if (isRoot(node))
        return;
      const edge = model.getRelatedEdgesData(node.id, "in")[0];
      const controlPoint = [getAuxiliaryPoint(node), isAtEvenDepth(node) ? y4 : getParentY(node.id)];
      result.edges.push({ id: idOf(edge), controlPoints: [controlPoint], relatedNodeId: node.id });
      tmpRibX = Math.max(tmpRibX, x4 + getRibSep(node));
      if (node.depth === 1)
        ribX = tmpRibX;
    };
    layout2(root);
    return result;
  }
  placeAlterative(result, root) {
    const oddIndexedRibs = (root.children || []).filter((_2, index) => index % 2 !== 0);
    if (oddIndexedRibs.length === 0)
      return result;
    const { model } = this.context;
    const rootY = result.nodes.find((node) => node.id === root.id).y;
    const shouldFlip = (nodeId) => {
      const ancestors = model.getAncestorsData(nodeId, "tree");
      if (is_empty_default(ancestors))
        return false;
      const ribId = ancestors.length === 1 ? nodeId : ancestors[ancestors.length - 2].id;
      return oddIndexedRibs.includes(ribId);
    };
    result.nodes.forEach((node) => {
      if (shouldFlip(node.id))
        node.y = 2 * rootY - node.y;
    });
    result.edges.forEach((edge) => {
      if (shouldFlip(edge.relatedNodeId)) {
        edge.controlPoints = edge.controlPoints.map((point3) => [point3[0], 2 * rootY - point3[1]]);
      }
    });
  }
  rightToLeft(result, options) {
    result.nodes.forEach((node) => node.x = options.width - node.x);
    result.edges.forEach((edge) => {
      edge.controlPoints = edge.controlPoints.map((point3) => [options.width - point3[0], point3[1]]);
    });
    return result;
  }
  execute(data, propOptions) {
    return __awaiter13(this, void 0, void 0, function* () {
      const options = Object.assign(Object.assign(Object.assign({}, _FishboneLayout.defaultOptions), this.options), propOptions);
      const { direction, nodeSize } = options;
      const root = this.getRoot();
      if (!root)
        return data;
      const getSize = this.formatSize(nodeSize);
      options.vGap || (options.vGap = Math.max(...(data.nodes || []).map((node) => getSize(node)[1])));
      options.hGap || (options.hGap = Math.max(...(data.nodes || []).map((node) => getSize(node)[0])));
      let result = this.doLayout(root, options);
      this.placeAlterative(result, root);
      if (direction === "RL") {
        result = this.rightToLeft(result, options);
      }
      const { model } = this.context;
      const nodes = [];
      const edges = [];
      result.nodes.forEach((node) => {
        const { id, x: x4, y: y4 } = node;
        const nodeData = model.getNodeLikeDatum(id);
        nodes.push(assignElementStyle(nodeData, { x: x4, y: y4 }));
      });
      result.edges.forEach((edge) => {
        const { id, controlPoints } = edge;
        const edgeData = model.getEdgeDatum(id);
        edges.push(assignElementStyle(edgeData, { controlPoints }));
      });
      return { nodes, edges };
    });
  }
};
FishboneLayout.defaultOptions = {
  direction: "RL",
  getRibSep: () => 60
};
var assignElementStyle = (element, style) => {
  return Object.assign(Object.assign({}, element), { style: Object.assign(Object.assign({}, element.style || {}), style) });
};
var isRoot = (node) => node.depth === 0;
var isAtEvenDepth = (node) => (node.depth || (node.depth = 0)) % 2 === 0;

// node_modules/@antv/g6/esm/layouts/snake.js
var __awaiter14 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SnakeLayout = class _SnakeLayout extends BaseLayout {
  constructor() {
    super(...arguments);
    this.id = "snake";
  }
  formatSize(nodes, size2) {
    const sizeFn = typeof size2 === "function" ? size2 : () => size2;
    return nodes.reduce((acc, node) => {
      const [w3, h3] = parseSize(sizeFn(node)) || [0, 0];
      return [Math.max(acc[0], w3), Math.max(acc[1], h3)];
    }, [0, 0]);
  }
  /**
   * Validates the graph data to ensure it meets the requirements for linear arrangement.
   * @param data - Graph data
   * @returns false if the graph is not connected, has more than one source or sink node, or contains cycles.
   */
  validate(data) {
    const { nodes = [], edges = [] } = data;
    const inDegree = {};
    const outDegree = {};
    const adjList = {};
    nodes.forEach((node) => {
      inDegree[node.id] = 0;
      outDegree[node.id] = 0;
      adjList[node.id] = [];
    });
    edges.forEach((edge) => {
      inDegree[edge.target]++;
      outDegree[edge.source]++;
      adjList[edge.source].push(edge.target);
    });
    const visited = /* @__PURE__ */ new Set();
    const dfs4 = (nodeId) => {
      if (visited.has(nodeId))
        return;
      visited.add(nodeId);
      adjList[nodeId].forEach(dfs4);
    };
    dfs4(nodes[0].id);
    if (visited.size !== nodes.length)
      return false;
    const sourceNodes = nodes.filter((node) => inDegree[node.id] === 0);
    const sinkNodes = nodes.filter((node) => outDegree[node.id] === 0);
    if (sourceNodes.length !== 1 || sinkNodes.length !== 1)
      return false;
    const middleNodes = nodes.filter((node) => inDegree[node.id] === 1 && outDegree[node.id] === 1);
    if (middleNodes.length !== nodes.length - 2)
      return false;
    return true;
  }
  execute(model, options) {
    return __awaiter14(this, void 0, void 0, function* () {
      var _a;
      if (!this.validate(model))
        return model;
      const { nodeSize: propNodeSize, padding: propPadding, sortBy, cols, colGap: propColSep, rowGap: propRowSep, clockwise, width: width2, height } = Object.assign({}, _SnakeLayout.defaultOptions, this.options, options);
      const [top, right, bottom, left] = parsePadding(propPadding);
      const nodeSize = this.formatSize(model.nodes || [], propNodeSize);
      const rows = Math.ceil((model.nodes || []).length / cols);
      let colSep = propColSep ? propColSep : (width2 - left - right - cols * nodeSize[0]) / (cols - 1);
      let rowSep = propRowSep ? propRowSep : (height - top - bottom - rows * nodeSize[1]) / (rows - 1);
      if (rowSep === Infinity || rowSep < 0)
        rowSep = 0;
      if (colSep === Infinity || colSep < 0)
        colSep = 0;
      const sortedNodes = sortBy ? (_a = model.nodes) === null || _a === void 0 ? void 0 : _a.sort(sortBy) : topologicalSort(model);
      const nodes = (sortedNodes || []).map((node, index) => {
        const rowIndex = Math.floor(index / cols);
        const colIndex = index % cols;
        const actualColIndex = clockwise ? rowIndex % 2 === 0 ? colIndex : cols - 1 - colIndex : rowIndex % 2 === 0 ? cols - 1 - colIndex : colIndex;
        const x4 = left + actualColIndex * (nodeSize[0] + colSep) + nodeSize[0] / 2;
        const y4 = top + rowIndex * (nodeSize[1] + rowSep) + nodeSize[1] / 2;
        return {
          id: node.id,
          style: { x: x4, y: y4 }
        };
      });
      return { nodes };
    });
  }
};
SnakeLayout.defaultOptions = {
  padding: 0,
  cols: 5,
  clockwise: true
};
function topologicalSort(data) {
  const { nodes = [], edges = [] } = data;
  const inDegree = {};
  const adjList = {};
  nodes.forEach((node) => {
    inDegree[node.id] = 0;
    adjList[node.id] = [];
  });
  edges.forEach((edge) => {
    inDegree[edge.target]++;
    adjList[edge.source].push(edge.target);
  });
  const queue = [];
  const sortedNodes = [];
  nodes.forEach((node) => {
    if (inDegree[node.id] === 0) {
      queue.push(node.id);
    }
  });
  while (queue.length > 0) {
    const nodeId = queue.shift();
    const node = nodes.find((n2) => n2.id === nodeId);
    sortedNodes.push(node);
    adjList[nodeId].forEach((neighbor) => {
      inDegree[neighbor]--;
      if (inDegree[neighbor] === 0) {
        queue.push(neighbor);
      }
    });
  }
  return sortedNodes;
}

// node_modules/@antv/g6/esm/palettes/index.js
var spectral = [
  "rgb(158, 1, 66)",
  "rgb(213, 62, 79)",
  "rgb(244, 109, 67)",
  "rgb(253, 174, 97)",
  "rgb(254, 224, 139)",
  "rgb(255, 255, 191)",
  "rgb(230, 245, 152)",
  "rgb(171, 221, 164)",
  "rgb(102, 194, 165)",
  "rgb(50, 136, 189)",
  "rgb(94, 79, 162)"
];
var tableau = [
  "rgb(78, 121, 167)",
  "rgb(242, 142, 44)",
  "rgb(225, 87, 89)",
  "rgb(118, 183, 178)",
  "rgb(89, 161, 79)",
  "rgb(237, 201, 73)",
  "rgb(175, 122, 161)",
  "rgb(255, 157, 167)",
  "rgb(156, 117, 95)",
  "rgb(186, 176, 171)"
];
var oranges = [
  "rgb(255, 245, 235)",
  "rgb(254, 230, 206)",
  "rgb(253, 208, 162)",
  "rgb(253, 174, 107)",
  "rgb(253, 141, 60)",
  "rgb(241, 105, 19)",
  "rgb(217, 72, 1)",
  "rgb(166, 54, 3)",
  "rgb(127, 39, 4)"
];
var greens = [
  "rgb(247, 252, 245)",
  "rgb(229, 245, 224)",
  "rgb(199, 233, 192)",
  "rgb(161, 217, 155)",
  "rgb(116, 196, 118)",
  "rgb(65, 171, 93)",
  "rgb(35, 139, 69)",
  "rgb(0, 109, 44)",
  "rgb(0, 68, 27)"
];
var blues = [
  "rgb(247, 251, 255)",
  "rgb(222, 235, 247)",
  "rgb(198, 219, 239)",
  "rgb(158, 202, 225)",
  "rgb(107, 174, 214)",
  "rgb(66, 146, 198)",
  "rgb(33, 113, 181)",
  "rgb(8, 81, 156)",
  "rgb(8, 48, 107)"
];

// node_modules/@antv/g6/esm/plugins/base-plugin.js
var BasePlugin = class extends BaseExtension {
};

// node_modules/@antv/g6/esm/plugins/utils/dom.js
function createPluginContainer(type, cover = true, style) {
  const container = document.createElement("div");
  container.setAttribute("class", `g6-${type}`);
  Object.assign(container.style, {
    position: "absolute",
    display: "block"
  });
  if (cover) {
    Object.assign(container.style, {
      position: "unset",
      gridArea: "1 / 1 / 2 / 2",
      inset: "0px",
      height: "100%",
      width: "100%",
      overflow: "hidden",
      pointerEvents: "none"
    });
  }
  if (style)
    Object.assign(container.style, style);
  return container;
}
function insertDOM(id, tag = "div", style = {}, innerHTML = "", container = document.body) {
  const dom = document.getElementById(id);
  if (dom)
    dom.remove();
  const div = document.createElement(tag);
  div.innerHTML = innerHTML;
  div.id = id;
  Object.assign(div.style, style);
  container.appendChild(div);
  return div;
}

// node_modules/@antv/g6/esm/plugins/background/index.js
var __awaiter15 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Background = class _Background extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, _Background.defaultOptions, options));
    this.$element = createPluginContainer("background");
    const $container = this.context.canvas.getContainer();
    $container.prepend(this.$element);
    this.update(options);
  }
  /**
   * <zh/> 
   *
   * <en/> Update the background image configuration
   * @param options - <zh/>  | <en/> Options
   * @internal
   */
  update(options) {
    const _super = Object.create(null, {
      update: { get: () => super.update }
    });
    return __awaiter15(this, void 0, void 0, function* () {
      _super.update.call(this, options);
      Object.assign(this.$element.style, omit_default(this.options, ["key", "type"]));
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy the background image
   * @internal
   */
  destroy() {
    super.destroy();
    this.$element.remove();
  }
};
Background.defaultOptions = {
  transition: "background 0.5s",
  backgroundSize: "cover",
  zIndex: "-1"
  // aviod to cover the other plugin's dom, eg: grid-line.
};

// node_modules/bubblesets-js/build/index.js
function linePtSegDistSq(lx1, ly1, lx2, ly2, x4, y4) {
  const x1 = lx1;
  const y1 = ly1;
  const x22 = lx2 - x1;
  const y22 = ly2 - y1;
  let px = x4 - x1;
  let py = y4 - y1;
  let dotprod = px * x22 + py * y22;
  let projlenSq = 0;
  if (dotprod <= 0) {
    projlenSq = 0;
  } else {
    px = x22 - px;
    py = y22 - py;
    dotprod = px * x22 + py * y22;
    if (dotprod <= 0) {
      projlenSq = 0;
    } else {
      projlenSq = dotprod * dotprod / (x22 * x22 + y22 * y22);
    }
  }
  const lenSq = px * px + py * py - projlenSq;
  if (lenSq < 0) {
    return 0;
  }
  return lenSq;
}
function ptsDistanceSq(x1, y1, x22, y22) {
  return (x1 - x22) * (x1 - x22) + (y1 - y22) * (y1 - y22);
}
function doublePointsEqual(x1, y1, x22, y22, delta) {
  return ptsDistanceSq(x1, y1, x22, y22) < delta * delta;
}
function round2(digits) {
  if (!Number.isFinite(digits)) {
    return (v3) => v3;
  }
  if (digits === 0) {
    return Math.round;
  }
  const factor = Math.pow(10, digits);
  return (v3) => Math.round(v3 * factor) / factor;
}
function lineBoundingBox(line) {
  const minX = Math.min(line.x1, line.x2);
  const maxX = Math.max(line.x1, line.x2);
  const minY = Math.min(line.y1, line.y2);
  const maxY = Math.max(line.y1, line.y2);
  return {
    x: minX,
    y: minY,
    x2: maxX,
    y2: maxY,
    width: maxX - minX,
    height: maxY - minY
  };
}
var Line3 = class _Line {
  constructor(x1, y1, x22, y22) {
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x22;
    this.y2 = y22;
  }
  equals(that) {
    return this.x1 === that.x1 && this.y1 === that.y1 && this.x2 === that.x2 && this.y2 === that.y2;
  }
  draw(ctx3) {
    ctx3.moveTo(this.x1, this.y1);
    ctx3.lineTo(this.x2, this.y2);
  }
  toString() {
    return `Line(from=(${this.x1},${this.y1}),to=(${this.x2},${this.y2}))`;
  }
  static from(l3) {
    return new _Line(l3.x1, l3.y1, l3.x2, l3.y2);
  }
  cuts(px, py) {
    if (this.y1 === this.y2) {
      return false;
    }
    if (py < this.y1 && py <= this.y2 || py > this.y1 && py >= this.y2) {
      return false;
    }
    if (px > this.x1 && px >= this.x2) {
      return false;
    }
    if (px < this.x1 && px <= this.x2) {
      return true;
    }
    const cross2 = this.x1 + (py - this.y1) * (this.x2 - this.x1) / (this.y2 - this.y1);
    return px <= cross2;
  }
  distSquare(x4, y4) {
    return linePtSegDistSq(this.x1, this.y1, this.x2, this.y2, x4, y4);
  }
  ptClose(x4, y4, r3) {
    if (this.x1 < this.x2) {
      if (x4 < this.x1 - r3 || x4 > this.x2 + r3) {
        return false;
      }
    } else {
      if (x4 < this.x2 - r3 || x4 > this.x1 + r3) {
        return false;
      }
    }
    if (this.y1 < this.y2) {
      if (y4 < this.y1 - r3 || y4 > this.y2 + r3) {
        return false;
      }
    } else {
      if (y4 < this.y2 - r3 || y4 > this.y1 + r3) {
        return false;
      }
    }
    return true;
  }
};
var EState;
(function(EState2) {
  EState2[EState2["POINT"] = 1] = "POINT";
  EState2[EState2["PARALLEL"] = 2] = "PARALLEL";
  EState2[EState2["COINCIDENT"] = 3] = "COINCIDENT";
  EState2[EState2["NONE"] = 4] = "NONE";
})(EState || (EState = {}));
var Intersection = class {
  constructor(state, x4 = 0, y4 = 0) {
    this.state = state;
    this.x = x4;
    this.y = y4;
  }
};
function intersectLineLine(la, lb) {
  const uaT = (lb.x2 - lb.x1) * (la.y1 - lb.y1) - (lb.y2 - lb.y1) * (la.x1 - lb.x1);
  const ubT = (la.x2 - la.x1) * (la.y1 - lb.y1) - (la.y2 - la.y1) * (la.x1 - lb.x1);
  const uB = (lb.y2 - lb.y1) * (la.x2 - la.x1) - (lb.x2 - lb.x1) * (la.y2 - la.y1);
  if (uB) {
    const ua = uaT / uB;
    const ub = ubT / uB;
    if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
      return new Intersection(EState.POINT, la.x1 + ua * (la.x2 - la.x1), la.y1 + ua * (la.y2 - la.y1));
    }
    return new Intersection(EState.NONE);
  }
  return new Intersection(uaT === 0 || ubT === 0 ? EState.COINCIDENT : EState.PARALLEL);
}
function fractionAlongLineA(la, lb) {
  const uaT = (lb.x2 - lb.x1) * (la.y1 - lb.y1) - (lb.y2 - lb.y1) * (la.x1 - lb.x1);
  const ubT = (la.x2 - la.x1) * (la.y1 - lb.y1) - (la.y2 - la.y1) * (la.x1 - lb.x1);
  const uB = (lb.y2 - lb.y1) * (la.x2 - la.x1) - (lb.x2 - lb.x1) * (la.y2 - la.y1);
  if (uB) {
    const ua = uaT / uB;
    const ub = ubT / uB;
    if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
      return ua;
    }
  }
  return Number.POSITIVE_INFINITY;
}
function hasFractionToLineCenter(bounds, line) {
  function testLine(xa, ya, xb, yb) {
    let testDistance = fractionAlongLineA(line, new Line3(xa, ya, xb, yb));
    testDistance = Math.abs(testDistance - 0.5);
    if (testDistance >= 0 && testDistance <= 1) {
      return 1;
    }
    return 0;
  }
  let countIntersections = testLine(bounds.x, bounds.y, bounds.x2, bounds.y);
  countIntersections += testLine(bounds.x, bounds.y, bounds.x, bounds.y2);
  if (countIntersections > 1) {
    return true;
  }
  countIntersections += testLine(bounds.x, bounds.y2, bounds.x2, bounds.y2);
  if (countIntersections > 1) {
    return true;
  }
  countIntersections += testLine(bounds.x2, bounds.y, bounds.x2, bounds.y2);
  return countIntersections > 0;
}
var OutCode;
(function(OutCode2) {
  OutCode2[OutCode2["LEFT"] = 0] = "LEFT";
  OutCode2[OutCode2["TOP"] = 1] = "TOP";
  OutCode2[OutCode2["RIGHT"] = 2] = "RIGHT";
  OutCode2[OutCode2["BOTTOM"] = 3] = "BOTTOM";
})(OutCode || (OutCode = {}));
function outcode(bounds, px, py) {
  const out = /* @__PURE__ */ new Set();
  if (bounds.width <= 0) {
    out.add(OutCode.LEFT);
    out.add(OutCode.RIGHT);
  } else if (px < bounds.x) {
    out.add(OutCode.LEFT);
  } else if (px > bounds.x + bounds.width) {
    out.add(OutCode.RIGHT);
  }
  if (bounds.height <= 0) {
    out.add(OutCode.TOP);
    out.add(OutCode.BOTTOM);
  } else if (py < bounds.y) {
    out.add(OutCode.TOP);
  } else if (py > bounds.y + bounds.height) {
    out.add(OutCode.BOTTOM);
  }
  return out;
}
function intersectsLine(bounds, line) {
  let x1 = line.x1;
  let y1 = line.y1;
  const x22 = line.x2;
  const y22 = line.y2;
  const out2 = Array.from(outcode(bounds, x22, y22));
  if (out2.length === 0) {
    return true;
  }
  let out1 = outcode(bounds, x1, y1);
  while (out1.size !== 0) {
    for (const a3 of out2) {
      if (out1.has(a3)) {
        return false;
      }
    }
    if (out1.has(OutCode.RIGHT) || out1.has(OutCode.LEFT)) {
      let x4 = bounds.x;
      if (out1.has(OutCode.RIGHT)) {
        x4 += bounds.width;
      }
      y1 = y1 + (x4 - x1) * (y22 - y1) / (x22 - x1);
      x1 = x4;
    } else {
      let y4 = bounds.y;
      if (out1.has(OutCode.BOTTOM)) {
        y4 += bounds.height;
      }
      x1 = x1 + (y4 - y1) * (x22 - x1) / (y22 - y1);
      y1 = y4;
    }
    out1 = outcode(bounds, x1, y1);
  }
  return true;
}
function fractionToLineCenter(bounds, line) {
  let minDistance = Number.POSITIVE_INFINITY;
  let countIntersections = 0;
  function testLine(xa, ya, xb, yb) {
    let testDistance = fractionAlongLineA(line, new Line3(xa, ya, xb, yb));
    testDistance = Math.abs(testDistance - 0.5);
    if (testDistance >= 0 && testDistance <= 1) {
      countIntersections++;
      if (testDistance < minDistance) {
        minDistance = testDistance;
      }
    }
  }
  testLine(bounds.x, bounds.y, bounds.x2, bounds.y);
  testLine(bounds.x, bounds.y, bounds.x, bounds.y2);
  if (countIntersections > 1) {
    return minDistance;
  }
  testLine(bounds.x, bounds.y2, bounds.x2, bounds.y2);
  if (countIntersections > 1) {
    return minDistance;
  }
  testLine(bounds.x2, bounds.y, bounds.x2, bounds.y2);
  if (countIntersections === 0) {
    return -1;
  }
  return minDistance;
}
function testIntersection(line, bounds) {
  let count = 0;
  const top = intersectLineLine(line, new Line3(bounds.x, bounds.y, bounds.x2, bounds.y));
  count += top.state === EState.POINT ? 1 : 0;
  const left = intersectLineLine(line, new Line3(bounds.x, bounds.y, bounds.x, bounds.y2));
  count += left.state === EState.POINT ? 1 : 0;
  const bottom = intersectLineLine(line, new Line3(bounds.x, bounds.y2, bounds.x2, bounds.y2));
  count += bottom.state === EState.POINT ? 1 : 0;
  const right = intersectLineLine(line, new Line3(bounds.x2, bounds.y, bounds.x2, bounds.y2));
  count += right.state === EState.POINT ? 1 : 0;
  return { top, left, bottom, right, count };
}
var Rectangle = class _Rectangle {
  constructor(x4, y4, width2, height) {
    this.x = x4;
    this.y = y4;
    this.width = width2;
    this.height = height;
  }
  get x2() {
    return this.x + this.width;
  }
  get y2() {
    return this.y + this.height;
  }
  get cx() {
    return this.x + this.width / 2;
  }
  get cy() {
    return this.y + this.height / 2;
  }
  get radius() {
    return Math.max(this.width, this.height) / 2;
  }
  static from(r3) {
    return new _Rectangle(r3.x, r3.y, r3.width, r3.height);
  }
  equals(that) {
    return this.x === that.x && this.y === that.y && this.width === that.width && this.height === that.height;
  }
  clone() {
    return new _Rectangle(this.x, this.y, this.width, this.height);
  }
  add(that) {
    const x4 = Math.min(this.x, that.x);
    const y4 = Math.min(this.y, that.y);
    const x22 = Math.max(this.x2, that.x + that.width);
    const y22 = Math.max(this.y2, that.y + that.height);
    this.x = x4;
    this.y = y4;
    this.width = x22 - x4;
    this.height = y22 - y4;
  }
  addPoint(p3) {
    const x4 = Math.min(this.x, p3.x);
    const y4 = Math.min(this.y, p3.y);
    const x22 = Math.max(this.x2, p3.x);
    const y22 = Math.max(this.y2, p3.y);
    this.x = x4;
    this.y = y4;
    this.width = x22 - x4;
    this.height = y22 - y4;
  }
  toString() {
    return `Rectangle[x=${this.x}, y=${this.y}, w=${this.width}, h=${this.height}]`;
  }
  draw(ctx3) {
    ctx3.rect(this.x, this.y, this.width, this.height);
  }
  containsPt(px, py) {
    return px >= this.x && px <= this.x2 && py >= this.y && py <= this.y2;
  }
  get area() {
    return this.width * this.height;
  }
  intersects(that) {
    if (this.area <= 0 || that.width <= 0 || that.height <= 0) {
      return false;
    }
    return that.x + that.width > this.x && that.y + that.height > this.y && that.x < this.x2 && that.y < this.y2;
  }
  distSquare(tempX, tempY) {
    if (this.containsPt(tempX, tempY)) {
      return 0;
    }
    const code = outcode(this, tempX, tempY);
    if (code.has(OutCode.TOP)) {
      if (code.has(OutCode.LEFT)) {
        return ptsDistanceSq(tempX, tempY, this.x, this.y);
      }
      if (code.has(OutCode.RIGHT)) {
        return ptsDistanceSq(tempX, tempY, this.x2, this.y);
      }
      return (this.y - tempY) * (this.y - tempY);
    }
    if (code.has(OutCode.BOTTOM)) {
      if (code.has(OutCode.LEFT)) {
        return ptsDistanceSq(tempX, tempY, this.x, this.y2);
      }
      if (code.has(OutCode.RIGHT)) {
        return ptsDistanceSq(tempX, tempY, this.x2, this.y2);
      }
      return (tempY - this.y2) * (tempY - this.y2);
    }
    if (code.has(OutCode.LEFT)) {
      return (this.x - tempX) * (this.x - tempX);
    }
    if (code.has(OutCode.RIGHT)) {
      return (tempX - this.x2) * (tempX - this.x2);
    }
    return 0;
  }
};
function boundingBox(path) {
  if (path.length === 0) {
    return null;
  }
  const first = path[0];
  const bb = new Rectangle(first.x, first.y, 0, 0);
  for (const point3 of path) {
    bb.addPoint(point3);
  }
  return bb;
}
var Circle3 = class _Circle {
  constructor(cx, cy, radius) {
    this.cx = cx;
    this.cy = cy;
    this.radius = radius;
  }
  get x() {
    return this.cx - this.radius;
  }
  get x2() {
    return this.cx + this.radius;
  }
  get width() {
    return this.radius * 2;
  }
  get y() {
    return this.cy - this.radius;
  }
  get y2() {
    return this.cy + this.radius;
  }
  get height() {
    return this.radius * 2;
  }
  static from(r3) {
    return new _Circle(r3.cx, r3.cy, r3.radius);
  }
  containsPt(x4, y4) {
    return ptsDistanceSq(this.cx, this.cy, x4, y4) < this.radius * this.radius;
  }
  distSquare(tempX, tempY) {
    const dist = ptsDistanceSq(this.cx, this.cy, tempX, tempY);
    if (dist < this.radius * this.radius) {
      return 0;
    }
    const offset = Math.sqrt(dist) - this.radius;
    return offset * offset;
  }
  draw(ctx3) {
    ctx3.ellipse(this.cx, this.cy, this.radius, this.radius, 0, 0, Math.PI * 2);
  }
};
var Area = class _Area {
  constructor(pixelGroup, i2 = 0, j2 = 0, pixelX = 0, pixelY = 0, width2 = 10, height = 10, pixels = new Float32Array(Math.max(0, width2 * height)).fill(0)) {
    this.pixelGroup = pixelGroup;
    this.i = i2;
    this.j = j2;
    this.pixelX = pixelX;
    this.pixelY = pixelY;
    this.width = width2;
    this.height = height;
    this.area = pixels;
  }
  createSub(rect2, pixelPos) {
    return new _Area(this.pixelGroup, rect2.x, rect2.y, pixelPos.x, pixelPos.y, rect2.width, rect2.height);
  }
  static fromPixelRegion(pixelRect, pixelGroup) {
    return new _Area(pixelGroup, 0, 0, pixelRect.x, pixelRect.y, Math.ceil(pixelRect.width / pixelGroup), Math.ceil(pixelRect.height / pixelGroup));
  }
  copy(sub, pixelPoint) {
    return new _Area(this.pixelGroup, this.scaleX(pixelPoint.x), this.scaleY(pixelPoint.y), pixelPoint.x, pixelPoint.y, sub.width, sub.height, sub.area);
  }
  boundX(pos) {
    if (pos < this.i) {
      return this.i;
    }
    if (pos >= this.width) {
      return this.width - 1;
    }
    return pos;
  }
  boundY(pos) {
    if (pos < this.j) {
      return this.j;
    }
    if (pos >= this.height) {
      return this.height - 1;
    }
    return pos;
  }
  scaleX(pixel) {
    return this.boundX(Math.floor((pixel - this.pixelX) / this.pixelGroup));
  }
  scaleY(pixel) {
    return this.boundY(Math.floor((pixel - this.pixelY) / this.pixelGroup));
  }
  scale(pixelRect) {
    const x4 = this.scaleX(pixelRect.x);
    const y4 = this.scaleY(pixelRect.y);
    const x22 = this.boundX(Math.ceil((pixelRect.x + pixelRect.width - this.pixelX) / this.pixelGroup));
    const y22 = this.boundY(Math.ceil((pixelRect.y + pixelRect.height - this.pixelY) / this.pixelGroup));
    const width2 = x22 - x4;
    const height = y22 - y4;
    return new Rectangle(x4, y4, width2, height);
  }
  invertScaleX(v3) {
    return Math.round(v3 * this.pixelGroup + this.pixelX);
  }
  invertScaleY(v3) {
    return Math.round(v3 * this.pixelGroup + this.pixelY);
  }
  addPadding(rect2, pixelPadding) {
    const padding = Math.ceil(pixelPadding / this.pixelGroup);
    const x4 = this.boundX(rect2.x - padding);
    const y4 = this.boundY(rect2.y - padding);
    const x22 = this.boundX(rect2.x2 + padding);
    const y22 = this.boundY(rect2.y2 + padding);
    const width2 = x22 - x4;
    const height = y22 - y4;
    return new Rectangle(x4, y4, width2, height);
  }
  get(i2, j2) {
    if (i2 < 0 || j2 < 0 || i2 >= this.width || j2 >= this.height) {
      return Number.NaN;
    }
    return this.area[i2 + j2 * this.width];
  }
  inc(i2, j2, v3) {
    if (i2 < 0 || j2 < 0 || i2 >= this.width || j2 >= this.height) {
      return;
    }
    this.area[i2 + j2 * this.width] += v3;
  }
  set(i2, j2, v3) {
    if (i2 < 0 || j2 < 0 || i2 >= this.width || j2 >= this.height) {
      return;
    }
    this.area[i2 + j2 * this.width] = v3;
  }
  incArea(sub, factor) {
    if (sub.width <= 0 || sub.height <= 0 || factor === 0) {
      return;
    }
    const w3 = this.width;
    const aw = sub.width;
    const i1 = Math.max(0, sub.i);
    const j1 = Math.max(0, sub.j);
    const i2 = Math.min(sub.i + sub.width, w3);
    const j2 = Math.min(sub.j + sub.height, this.height);
    if (j2 <= 0 || i2 <= 0 || i1 >= w3 || j2 >= this.height) {
      return;
    }
    for (let j3 = j1; j3 < j2; j3++) {
      const subRow = (j3 - sub.j) * aw;
      const row = j3 * w3;
      for (let i3 = i1; i3 < i2; i3++) {
        const v3 = sub.area[i3 - sub.i + subRow];
        if (v3 === 0) {
          continue;
        }
        this.area[i3 + row] += factor * v3;
      }
    }
  }
  fill(value) {
    this.area.fill(value);
  }
  fillArea(rect2, value) {
    const offset = rect2.x + rect2.y * this.width;
    for (let j2 = 0; j2 < rect2.height; j2++) {
      const pos = offset + j2 * this.width;
      this.area.fill(value, pos, pos + rect2.width);
    }
  }
  fillHorizontalLine(i2, j2, width2, value) {
    const offset = i2 + j2 * this.width;
    this.area.fill(value, offset, offset + width2);
  }
  fillVerticalLine(i2, j2, height, value) {
    const offset = i2 + j2 * this.width;
    for (let k2 = 0; k2 < height; k2++) {
      this.area[offset + k2 * this.width] = value;
    }
  }
  clear() {
    this.area.fill(0);
  }
  toString() {
    let r3 = "";
    for (let j2 = 0; j2 < this.height; j2++) {
      const row = j2 * this.width;
      for (let i2 = 0; i2 < this.width; i2++) {
        const v3 = this.area[row + i2];
        r3 += v3.toFixed(1).padStart(6);
        r3 += " ";
      }
      r3 += "\n";
    }
    return r3;
  }
  draw(ctx3, offset = true) {
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    ctx3.save();
    if (offset) {
      ctx3.translate(this.pixelX, this.pixelY);
    }
    const min2 = this.area.reduce((acc, v3) => Math.min(acc, v3), Number.POSITIVE_INFINITY);
    const max2 = this.area.reduce((acc, v3) => Math.max(acc, v3), Number.NEGATIVE_INFINITY);
    const scale2 = (v3) => (v3 - min2) / (max2 - min2);
    ctx3.scale(this.pixelGroup, this.pixelGroup);
    for (let i2 = 0; i2 < this.width; i2++) {
      for (let j2 = 0; j2 < this.height; j2++) {
        const v3 = this.area[i2 + j2 * this.width];
        ctx3.fillStyle = `rgba(0, 0, 0, ${scale2(v3)})`;
        ctx3.fillRect(i2, j2, 1, 1);
      }
    }
    ctx3.restore();
  }
  drawThreshold(ctx3, threshold, offset = true) {
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    ctx3.save();
    if (offset) {
      ctx3.translate(this.pixelX, this.pixelY);
    }
    ctx3.scale(this.pixelGroup, this.pixelGroup);
    for (let i2 = 0; i2 < this.width; i2++) {
      for (let j2 = 0; j2 < this.height; j2++) {
        const v3 = this.area[i2 + j2 * this.width];
        ctx3.fillStyle = v3 > threshold ? "black" : "white";
        ctx3.fillRect(i2, j2, 1, 1);
      }
    }
    ctx3.restore();
  }
};
function addPadding(rect2, padding) {
  const map = (r3) => ({
    x: r3.x - padding,
    y: r3.y - padding,
    width: r3.width + 2 * padding,
    height: r3.height + 2 * padding
  });
  if (Array.isArray(rect2)) {
    return rect2.map(map);
  }
  return map(rect2);
}
function createLineInfluenceArea(line, potentialArea, padding) {
  return createGenericInfluenceArea(Object.assign(lineBoundingBox(line), {
    distSquare: (x4, y4) => linePtSegDistSq(line.x1, line.y1, line.x2, line.y2, x4, y4)
  }), potentialArea, padding);
}
function createGenericInfluenceArea(shape, potentialArea, padding) {
  const lr = addPadding(shape, padding);
  const scaled = potentialArea.scale(lr);
  const area = potentialArea.createSub(scaled, lr);
  sample(area, potentialArea, padding, (x4, y4) => shape.distSquare(x4, y4));
  return area;
}
function sample(area, potentialArea, padding, distanceFunction) {
  const padding2 = padding * padding;
  for (let y4 = 0; y4 < area.height; y4++) {
    for (let x4 = 0; x4 < area.width; x4++) {
      const tempX = potentialArea.invertScaleX(area.i + x4);
      const tempY = potentialArea.invertScaleY(area.j + y4);
      const distanceSq = distanceFunction(tempX, tempY);
      if (distanceSq === 0) {
        area.set(x4, y4, padding2);
        continue;
      }
      if (distanceSq < padding2) {
        const dr = padding - Math.sqrt(distanceSq);
        area.set(x4, y4, dr * dr);
      }
    }
  }
  return area;
}
function createRectangleInfluenceArea(rect2, potentialArea, padding) {
  const scaled = potentialArea.scale(rect2);
  const padded = potentialArea.addPadding(scaled, padding);
  const area = potentialArea.createSub(padded, { x: rect2.x - padding, y: rect2.y - padding });
  const paddingLeft = scaled.x - padded.x;
  const paddingTop = scaled.y - padded.y;
  const paddingRight = padded.x2 - scaled.x2;
  const paddingBottom = padded.y2 - scaled.y2;
  const innerWidth = padded.width - paddingLeft - paddingRight;
  const innerHeight = padded.height - paddingTop - paddingBottom;
  const padding2 = padding * padding;
  area.fillArea({
    x: paddingLeft,
    y: paddingTop,
    width: innerWidth + 1,
    height: innerHeight + 1
  }, padding2);
  const straightDistances = [0];
  const maxPadding = Math.max(paddingTop, paddingLeft, paddingRight, paddingBottom);
  {
    const tempX = potentialArea.invertScaleX(scaled.x + scaled.width / 2);
    for (let i2 = 1; i2 < maxPadding; i2++) {
      const tempY = potentialArea.invertScaleY(scaled.y - i2);
      const distanceSq = rect2.distSquare(tempX, tempY);
      if (distanceSq < padding2) {
        const dr = padding - Math.sqrt(distanceSq);
        straightDistances.push(dr * dr);
      } else {
        break;
      }
    }
  }
  const cornerDistances = [];
  const maxHorizontalPadding = Math.max(paddingLeft, paddingRight);
  const maxVerticalPadding = Math.max(paddingTop, paddingRight);
  for (let i2 = 1; i2 < maxHorizontalPadding; i2++) {
    const tempX = potentialArea.invertScaleX(scaled.x - i2);
    const row = [];
    for (let j2 = 1; j2 < maxVerticalPadding; j2++) {
      const tempY = potentialArea.invertScaleY(scaled.y - j2);
      const distanceSq = rect2.distSquare(tempX, tempY);
      if (distanceSq < padding2) {
        const dr = padding - Math.sqrt(distanceSq);
        row.push(dr * dr);
      } else {
        row.push(0);
      }
    }
    cornerDistances.push(row);
  }
  for (let y4 = 1; y4 < Math.min(paddingTop, straightDistances.length); y4++) {
    const value = straightDistances[y4];
    area.fillHorizontalLine(paddingLeft, paddingTop - y4, innerWidth + 1, value);
  }
  for (let y4 = 1; y4 < Math.min(paddingBottom, straightDistances.length); y4++) {
    const value = straightDistances[y4];
    area.fillHorizontalLine(paddingLeft, paddingTop + innerHeight + y4, innerWidth + 1, value);
  }
  for (let x4 = 1; x4 < Math.min(paddingLeft, straightDistances.length); x4++) {
    const value = straightDistances[x4];
    area.fillVerticalLine(paddingLeft - x4, paddingTop, innerHeight + 1, value);
  }
  for (let x4 = 1; x4 < Math.min(paddingBottom, straightDistances.length); x4++) {
    const value = straightDistances[x4];
    area.fillVerticalLine(paddingLeft + innerWidth + x4, paddingTop, innerHeight + 1, value);
  }
  for (let i2 = 1; i2 < paddingLeft; i2++) {
    const row = cornerDistances[i2 - 1];
    const ii = paddingLeft - i2;
    for (let j2 = 1; j2 < paddingTop; j2++) {
      area.set(ii, paddingTop - j2, row[j2 - 1]);
    }
    for (let j2 = 1; j2 < paddingBottom; j2++) {
      area.set(ii, paddingTop + innerHeight + j2, row[j2 - 1]);
    }
  }
  for (let i2 = 1; i2 < paddingRight; i2++) {
    const row = cornerDistances[i2 - 1];
    const ii = paddingLeft + innerWidth + i2;
    for (let j2 = 1; j2 < paddingTop; j2++) {
      area.set(ii, paddingTop - j2, row[j2 - 1]);
    }
    for (let j2 = 1; j2 < paddingBottom; j2++) {
      area.set(ii, paddingTop + innerHeight + j2, row[j2 - 1]);
    }
  }
  return area;
}
function point2(x4, y4) {
  return { x: x4, y: y4 };
}
function calculateVirtualEdges(items, nonMembers, maxRoutingIterations, morphBuffer) {
  if (items.length === 0) {
    return [];
  }
  const sorted = sortByDistanceToCentroid(items);
  return sorted.map((d3, i2) => {
    const visited = sorted.slice(0, i2);
    return connectItem(nonMembers, d3, visited, maxRoutingIterations, morphBuffer);
  }).flat();
}
function connectItem(nonMembers, item, visited, maxRoutingIterations, morphBuffer) {
  const itemCenter = point2(item.cx, item.cy);
  const closestNeighbor = calculateClosestNeighbor(itemCenter, visited, nonMembers);
  if (closestNeighbor == null) {
    return [];
  }
  const directLine = new Line3(itemCenter.x, itemCenter.y, closestNeighbor.cx, closestNeighbor.cy);
  const scannedLines = computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer);
  return mergeLines(scannedLines, nonMembers);
}
function computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer) {
  const scannedLines = [];
  const linesToCheck = [];
  linesToCheck.push(directLine);
  let hasIntersection = true;
  for (let iterations = 0; iterations < maxRoutingIterations && hasIntersection; iterations++) {
    hasIntersection = false;
    while (!hasIntersection && linesToCheck.length > 0) {
      const line = linesToCheck.pop();
      const closestItem = getCenterItem(nonMembers, line);
      const intersections = closestItem ? testIntersection(line, closestItem) : null;
      if (!closestItem || !intersections || intersections.count !== 2) {
        if (!hasIntersection) {
          scannedLines.push(line);
        }
        continue;
      }
      let tempMorphBuffer = morphBuffer;
      let movePoint = rerouteLine(closestItem, tempMorphBuffer, intersections, true);
      let foundFirst = pointExists(movePoint, linesToCheck) || pointExists(movePoint, scannedLines);
      let pointInside = isPointInRectangles(movePoint, nonMembers);
      while (!foundFirst && pointInside && tempMorphBuffer >= 1) {
        tempMorphBuffer /= 1.5;
        movePoint = rerouteLine(closestItem, tempMorphBuffer, intersections, true);
        foundFirst = pointExists(movePoint, linesToCheck) || pointExists(movePoint, scannedLines);
        pointInside = isPointInRectangles(movePoint, nonMembers);
      }
      if (movePoint && !foundFirst && !pointInside) {
        linesToCheck.push(new Line3(line.x1, line.y1, movePoint.x, movePoint.y));
        linesToCheck.push(new Line3(movePoint.x, movePoint.y, line.x2, line.y2));
        hasIntersection = true;
      }
      if (hasIntersection) {
        continue;
      }
      tempMorphBuffer = morphBuffer;
      movePoint = rerouteLine(closestItem, tempMorphBuffer, intersections, false);
      let foundSecond = pointExists(movePoint, linesToCheck) || pointExists(movePoint, scannedLines);
      pointInside = isPointInRectangles(movePoint, nonMembers);
      while (!foundSecond && pointInside && tempMorphBuffer >= 1) {
        tempMorphBuffer /= 1.5;
        movePoint = rerouteLine(closestItem, tempMorphBuffer, intersections, false);
        foundSecond = pointExists(movePoint, linesToCheck) || pointExists(movePoint, scannedLines);
        pointInside = isPointInRectangles(movePoint, nonMembers);
      }
      if (movePoint && !foundSecond) {
        linesToCheck.push(new Line3(line.x1, line.y1, movePoint.x, movePoint.y));
        linesToCheck.push(new Line3(movePoint.x, movePoint.y, line.x2, line.y2));
        hasIntersection = true;
      }
      if (!hasIntersection) {
        scannedLines.push(line);
      }
    }
  }
  while (linesToCheck.length > 0) {
    scannedLines.push(linesToCheck.pop());
  }
  return scannedLines;
}
function mergeLines(scannedLines, nonMembers) {
  const finalRoute = [];
  while (scannedLines.length > 0) {
    const line1 = scannedLines.pop();
    if (scannedLines.length === 0) {
      finalRoute.push(line1);
      break;
    }
    const line2 = scannedLines.pop();
    const mergeLine = new Line3(line1.x1, line1.y1, line2.x2, line2.y2);
    const closestItem = getCenterItem(nonMembers, mergeLine);
    if (!closestItem) {
      scannedLines.push(mergeLine);
    } else {
      finalRoute.push(line1);
      scannedLines.push(line2);
    }
  }
  return finalRoute;
}
function calculateClosestNeighbor(itemCenter, visited, nonMembers) {
  let minLengthSq = Number.POSITIVE_INFINITY;
  return visited.reduce((closestNeighbor, neighborItem) => {
    const distanceSq = ptsDistanceSq(itemCenter.x, itemCenter.y, neighborItem.cx, neighborItem.cy);
    if (distanceSq > minLengthSq) {
      return closestNeighbor;
    }
    const directLine = new Line3(itemCenter.x, itemCenter.y, neighborItem.cx, neighborItem.cy);
    const numberInterferenceItems = itemsCuttingLine(nonMembers, directLine);
    if (distanceSq * (numberInterferenceItems + 1) * (numberInterferenceItems + 1) < minLengthSq) {
      closestNeighbor = neighborItem;
      minLengthSq = distanceSq * (numberInterferenceItems + 1) * (numberInterferenceItems + 1);
    }
    return closestNeighbor;
  }, null);
}
function sortByDistanceToCentroid(items) {
  if (items.length < 2) {
    return items;
  }
  let totalX = 0;
  let totalY = 0;
  items.forEach((item) => {
    totalX += item.cx;
    totalY += item.cy;
  });
  totalX /= items.length;
  totalY /= items.length;
  return items.map((item) => {
    const diffX = totalX - item.cx;
    const diffY = totalY - item.cy;
    const dist = diffX * diffX + diffY * diffY;
    return [item, dist];
  }).sort((a3, b3) => a3[1] - b3[1]).map((d3) => d3[0]);
}
function isPointInRectangles(p3, rects) {
  return rects.some((r3) => r3.containsPt(p3.x, p3.y));
}
function pointExists(pointToCheck, lines) {
  return lines.some((checkEndPointsLine) => {
    if (doublePointsEqual(checkEndPointsLine.x1, checkEndPointsLine.y1, pointToCheck.x, pointToCheck.y, 1e-3)) {
      return true;
    }
    if (doublePointsEqual(checkEndPointsLine.x2, checkEndPointsLine.y2, pointToCheck.x, pointToCheck.y, 1e-3)) {
      return true;
    }
    return false;
  });
}
function getCenterItem(items, testLine) {
  let minDistance = Number.POSITIVE_INFINITY;
  let closestItem = null;
  for (const item of items) {
    if (!intersectsLine(item, testLine)) {
      continue;
    }
    const distance4 = fractionToLineCenter(item, testLine);
    if (distance4 >= 0 && distance4 < minDistance) {
      closestItem = item;
      minDistance = distance4;
    }
  }
  return closestItem;
}
function itemsCuttingLine(items, testLine) {
  return items.reduce((count, item) => {
    if (intersectsLine(item, testLine) && hasFractionToLineCenter(item, testLine)) {
      return count + 1;
    }
    return count;
  }, 0);
}
function rerouteLine(item, rerouteBuffer, intersections, wrapNormal) {
  const topIntersect = intersections.top;
  const leftIntersect = intersections.left;
  const bottomIntersect = intersections.bottom;
  const rightIntersect = intersections.right;
  if (wrapNormal) {
    if (leftIntersect.state === EState.POINT) {
      if (topIntersect.state === EState.POINT)
        return point2(item.x - rerouteBuffer, item.y - rerouteBuffer);
      if (bottomIntersect.state === EState.POINT)
        return point2(item.x - rerouteBuffer, item.y2 + rerouteBuffer);
      const totalArea3 = item.width * item.height;
      const topArea = item.width * ((leftIntersect.y - item.y + (rightIntersect.y - item.y)) * 0.5);
      if (topArea < totalArea3 * 0.5) {
        if (leftIntersect.y > rightIntersect.y)
          return point2(item.x - rerouteBuffer, item.y - rerouteBuffer);
        return point2(item.x2 + rerouteBuffer, item.y - rerouteBuffer);
      }
      if (leftIntersect.y < rightIntersect.y)
        return point2(item.x - rerouteBuffer, item.y2 + rerouteBuffer);
      return point2(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);
    }
    if (rightIntersect.state === EState.POINT) {
      if (topIntersect.state === EState.POINT)
        return point2(item.x2 + rerouteBuffer, item.y - rerouteBuffer);
      if (bottomIntersect.state === EState.POINT)
        return point2(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);
    }
    const totalArea2 = item.height * item.width;
    const leftArea2 = item.height * ((topIntersect.x - item.x + (rightIntersect.x - item.x)) * 0.5);
    if (leftArea2 < totalArea2 * 0.5) {
      if (topIntersect.x > bottomIntersect.x)
        return point2(item.x - rerouteBuffer, item.y - rerouteBuffer);
      return point2(item.x - rerouteBuffer, item.y2 + rerouteBuffer);
    }
    if (topIntersect.x < bottomIntersect.x)
      return point2(item.x2 + rerouteBuffer, item.y - rerouteBuffer);
    return point2(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);
  }
  if (leftIntersect.state === EState.POINT) {
    if (topIntersect.state === EState.POINT)
      return point2(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);
    if (bottomIntersect.state === EState.POINT)
      return point2(item.x2 + rerouteBuffer, item.y - rerouteBuffer);
    const totalArea2 = item.height * item.width;
    const topArea = item.width * ((leftIntersect.y - item.y + (rightIntersect.y - item.y)) * 0.5);
    if (topArea < totalArea2 * 0.5) {
      if (leftIntersect.y > rightIntersect.y)
        return point2(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);
      return point2(item.x - rerouteBuffer, item.y2 + rerouteBuffer);
    }
    if (leftIntersect.y < rightIntersect.y)
      return point2(item.x2 + rerouteBuffer, item.y - rerouteBuffer);
    return point2(item.x - rerouteBuffer, item.y - rerouteBuffer);
  }
  if (rightIntersect.state === EState.POINT) {
    if (topIntersect.state === EState.POINT)
      return point2(item.x - rerouteBuffer, item.y2 + rerouteBuffer);
    if (bottomIntersect.state === EState.POINT)
      return point2(item.x - rerouteBuffer, item.y - rerouteBuffer);
  }
  const totalArea = item.height * item.width;
  const leftArea = item.height * ((topIntersect.x - item.x + (rightIntersect.x - item.x)) * 0.5);
  if (leftArea < totalArea * 0.5) {
    if (topIntersect.x > bottomIntersect.x)
      return point2(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);
    return point2(item.x2 + rerouteBuffer, item.y - rerouteBuffer);
  }
  if (topIntersect.x < bottomIntersect.x)
    return point2(item.x - rerouteBuffer, item.y2 + rerouteBuffer);
  return point2(item.x - rerouteBuffer, item.y - rerouteBuffer);
}
function canTakeNext(path, start, end, toleranceSquared) {
  const validEnd = path.closed ? end < path.length : end < path.length - 1;
  if (!validEnd) {
    return false;
  }
  const s2 = path.get(start);
  const e2 = path.get(end + 1);
  for (let index = start + 1; index <= end; index++) {
    const p3 = path.get(index);
    const len = linePtSegDistSq(s2.x, s2.y, e2.x, e2.y, p3.x, p3.y);
    if (len > toleranceSquared) {
      return false;
    }
  }
  return true;
}
function shapeSimplifier(tolerance = 0) {
  return (path) => {
    if (tolerance < 0 || path.length < 3) {
      return path;
    }
    const points = [];
    let start = 0;
    const toleranceSquared = tolerance * tolerance;
    while (start < path.length) {
      let end = start + 1;
      while (canTakeNext(path, start, end, toleranceSquared)) {
        end++;
      }
      points.push(path.get(start));
      start = end;
    }
    return new PointPath(points);
  };
}
function basicFunction(i2, t3) {
  switch (i2) {
    case -2:
      return (((-t3 + 3) * t3 - 3) * t3 + 1) / 6;
    case -1:
      return ((3 * t3 - 6) * t3 * t3 + 4) / 6;
    case 0:
      return (((-3 * t3 + 3) * t3 + 3) * t3 + 1) / 6;
    case 1:
      return t3 * t3 * t3 / 6;
    default:
      throw new Error("unknown error");
  }
}
function bSplineShapeGenerator(granularity = 6) {
  const ORDER = 3;
  const START_INDEX = ORDER - 1;
  const REL_END = 1;
  const REL_START = REL_END - ORDER;
  function calcPoint(path, i2, t3) {
    let px = 0;
    let py = 0;
    for (let j2 = REL_START; j2 <= REL_END; j2++) {
      const p3 = path.get(i2 + j2);
      const bf = basicFunction(j2, t3);
      px += bf * p3.x;
      py += bf * p3.y;
    }
    return { x: px, y: py };
  }
  return (path) => {
    if (path.length < 3) {
      return path;
    }
    const res = [];
    const closed = path.closed;
    const count = path.length + ORDER - 1 + (closed ? 0 : 2);
    res.push(calcPoint(path, START_INDEX - (closed ? 0 : 2), 0));
    for (let ix = START_INDEX - (closed ? 0 : 2); ix < count; ix++) {
      for (let k2 = 1; k2 <= granularity; k2++) {
        res.push(calcPoint(path, ix, k2 / granularity));
      }
    }
    return new PointPath(res);
  };
}
function samplePath(skip = 8) {
  return (path) => {
    let actSkip = skip;
    let size2 = path.length;
    if (actSkip > 1) {
      size2 = Math.floor(path.length / actSkip);
      while (size2 < 3 && actSkip > 1) {
        actSkip -= 1;
        size2 = Math.floor(path.length / actSkip);
      }
    }
    const finalHull = [];
    for (let i2 = 0, j2 = 0; j2 < size2; j2++, i2 += actSkip) {
      finalHull.push(path.get(i2));
    }
    return new PointPath(finalHull);
  };
}
var PointPath = class {
  constructor(points = [], closed = true) {
    this.points = points;
    this.closed = closed;
  }
  get(index) {
    const i2 = index;
    const l3 = this.points.length;
    if (index < 0) {
      return this.closed ? this.get(index + l3) : this.points[0];
    } else if (index >= l3) {
      return this.closed ? this.get(index - l3) : this.points[l3 - 1];
    }
    return this.points[i2];
  }
  get length() {
    return this.points.length;
  }
  toString(roundToDigits = Infinity) {
    const points = this.points;
    if (points.length === 0) {
      return "";
    }
    const rounder = typeof roundToDigits === "function" ? roundToDigits : round2(roundToDigits);
    let r3 = "M";
    for (const p3 of points) {
      r3 += `${rounder(p3.x)},${rounder(p3.y)} L`;
    }
    r3 = r3.slice(0, -1);
    if (this.closed) {
      r3 += " Z";
    }
    return r3;
  }
  draw(ctx3) {
    const points = this.points;
    if (points.length === 0) {
      return;
    }
    ctx3.beginPath();
    ctx3.moveTo(points[0].x, points[0].y);
    for (const p3 of points) {
      ctx3.lineTo(p3.x, p3.y);
    }
    if (this.closed) {
      ctx3.closePath();
    }
  }
  sample(skip) {
    return samplePath(skip)(this);
  }
  simplify(tolerance) {
    return shapeSimplifier(tolerance)(this);
  }
  bSplines(granularity) {
    return bSplineShapeGenerator(granularity)(this);
  }
  apply(transformer) {
    return transformer(this);
  }
  containsElements(members) {
    const bb = boundingBox(this.points);
    if (!bb) {
      return false;
    }
    return members.every((member) => {
      return bb.containsPt(member.cx, member.cy) && this.withinArea(member.cx, member.cy);
    });
  }
  withinArea(px, py) {
    if (this.length === 0) {
      return false;
    }
    let crossings = 0;
    const first = this.points[0];
    const line = new Line3(first.x, first.y, first.x, first.y);
    for (let i2 = 1; i2 < this.points.length; i2++) {
      const cur = this.points[i2];
      line.x1 = line.x2;
      line.y1 = line.y2;
      line.x2 = cur.x;
      line.y2 = cur.y;
      if (line.cuts(px, py)) {
        crossings++;
      }
    }
    line.x1 = line.x2;
    line.y1 = line.y2;
    line.x2 = first.x;
    line.y2 = first.y;
    if (line.cuts(px, py)) {
      crossings++;
    }
    return crossings % 2 === 1;
  }
};
var PointList = class {
  constructor(size2 = 0) {
    this.count = 0;
    this.arr = [];
    this.set = /* @__PURE__ */ new Set();
    this.arr.length = size2;
  }
  add(p3) {
    this.set.add(`${p3.x}x${p3.y}`);
    this.arr[this.count++] = p3;
  }
  contains(p3) {
    return this.set.has(`${p3.x}x${p3.y}`);
  }
  isFirst(p3) {
    if (this.count === 0) {
      return false;
    }
    const o3 = this.arr[0];
    return o3 != null && o3.x === p3.x && o3.y === p3.y;
  }
  path() {
    return new PointPath(this.arr.slice(0, this.count));
  }
  clear() {
    this.set.clear();
    this.count = 0;
  }
  get(ix) {
    return this.arr[ix];
  }
  get length() {
    return this.count;
  }
};
var N2 = 0;
var S2 = 1;
var E2 = 2;
var W = 3;
function marchingSquares(potentialArea, threshold) {
  const estLength = (Math.floor(potentialArea.width) + Math.floor(potentialArea.height)) * 2;
  const contour = new PointList(estLength);
  function updateDir(x4, y4, dir, res) {
    const v3 = potentialArea.get(x4, y4);
    if (Number.isNaN(v3)) {
      return Number.NaN;
    }
    if (v3 > threshold) {
      return dir + res;
    }
    return dir;
  }
  function getState(x4, y4) {
    let dir = N2;
    dir = updateDir(x4, y4, dir, 1);
    dir = updateDir(x4 + 1, y4, dir, 2);
    dir = updateDir(x4, y4 + 1, dir, 4);
    dir = updateDir(x4 + 1, y4 + 1, dir, 8);
    if (Number.isNaN(dir)) {
      return -1;
    }
    return dir;
  }
  let direction = S2;
  function doMarch(xPos, yPos) {
    let x4 = xPos;
    let y4 = yPos;
    let xPixel = potentialArea.invertScaleX(x4);
    let yPixel = potentialArea.invertScaleY(y4);
    for (let i2 = 0; i2 < potentialArea.width * potentialArea.height; i2++) {
      const p3 = { x: xPixel, y: yPixel };
      if (contour.contains(p3)) {
        if (!contour.isFirst(p3)) ;
        else {
          return true;
        }
      } else {
        contour.add(p3);
      }
      const state = getState(x4, y4);
      switch (state) {
        case -1:
          return true;
        case 0:
        case 3:
        case 2:
        case 7:
          direction = E2;
          break;
        case 12:
        case 14:
        case 4:
          direction = W;
          break;
        case 6:
          direction = direction === N2 ? W : E2;
          break;
        case 1:
        case 13:
        case 5:
          direction = N2;
          break;
        case 9:
          direction = direction === E2 ? N2 : S2;
          break;
        case 10:
        case 8:
        case 11:
          direction = S2;
          break;
        default:
          console.warn("Marching squares invalid state: " + state);
          return true;
      }
      switch (direction) {
        case N2:
          y4--;
          yPixel -= potentialArea.pixelGroup;
          break;
        case S2:
          y4++;
          yPixel += potentialArea.pixelGroup;
          break;
        case W:
          x4--;
          xPixel -= potentialArea.pixelGroup;
          break;
        case E2:
          x4++;
          xPixel += potentialArea.pixelGroup;
          break;
        default:
          console.warn("Marching squares invalid state: " + state);
          return true;
      }
    }
    return true;
  }
  for (let x4 = 0; x4 < potentialArea.width; x4++) {
    for (let y4 = 0; y4 < potentialArea.height; y4++) {
      if (potentialArea.get(x4, y4) <= threshold) {
        continue;
      }
      const state = getState(x4, y4);
      if (state < 0 || state === 15) {
        continue;
      }
      if (doMarch(x4, y4)) {
        return contour.path();
      }
    }
  }
  return null;
}
var defaultOptions2 = {
  maxRoutingIterations: 100,
  maxMarchingIterations: 20,
  pixelGroup: 4,
  edgeR0: 10,
  edgeR1: 20,
  nodeR0: 15,
  nodeR1: 50,
  morphBuffer: 10,
  threshold: 1,
  memberInfluenceFactor: 1,
  edgeInfluenceFactor: 1,
  nonMemberInfluenceFactor: -0.8,
  virtualEdges: true
};
function isCircle(v3) {
  return v3 != null && typeof v3.radius === "number";
}
function isEqual(a3, b3) {
  if (isCircle(a3) !== isCircle(b3)) {
    return false;
  }
  if (isCircle(a3)) {
    const bc = b3;
    return a3.cx === bc.cx && a3.cy === bc.cy && a3.radius === bc.radius;
  }
  const br = b3;
  return a3.x === br.x && a3.y === br.y && a3.width === br.width && a3.height === br.height;
}
var EDirty;
(function(EDirty2) {
  EDirty2[EDirty2["MEMBERS"] = 0] = "MEMBERS";
  EDirty2[EDirty2["NON_MEMBERS"] = 1] = "NON_MEMBERS";
  EDirty2[EDirty2["EDGES"] = 2] = "EDGES";
})(EDirty || (EDirty = {}));
var BubbleSets = class {
  constructor(options = {}) {
    this.dirty = /* @__PURE__ */ new Set();
    this.members = [];
    this.nonMembers = [];
    this.virtualEdges = [];
    this.edges = [];
    this.activeRegion = new Rectangle(0, 0, 0, 0);
    this.potentialArea = new Area(1, 0, 0, 0, 0, 0, 0);
    this.o = Object.assign({}, defaultOptions2, options);
  }
  pushMember(...members) {
    if (members.length === 0) {
      return;
    }
    this.dirty.add(EDirty.MEMBERS);
    for (const v3 of members) {
      this.members.push({
        raw: v3,
        obj: isCircle(v3) ? Circle3.from(v3) : Rectangle.from(v3),
        area: null
      });
    }
  }
  removeMember(member) {
    const index = this.members.findIndex((d3) => isEqual(d3.raw, member));
    if (index < 0) {
      return false;
    }
    this.members.splice(index, 1);
    this.dirty.add(EDirty.MEMBERS);
    return true;
  }
  removeNonMember(nonMember) {
    const index = this.nonMembers.findIndex((d3) => isEqual(d3.raw, nonMember));
    if (index < 0) {
      return false;
    }
    this.nonMembers.splice(index, 1);
    this.dirty.add(EDirty.NON_MEMBERS);
    return true;
  }
  removeEdge(edge) {
    const index = this.edges.findIndex((d3) => d3.obj.equals(edge));
    if (index < 0) {
      return false;
    }
    this.edges.splice(index, 1);
    this.dirty.add(EDirty.NON_MEMBERS);
    return true;
  }
  pushNonMember(...nonMembers) {
    if (nonMembers.length === 0) {
      return;
    }
    this.dirty.add(EDirty.NON_MEMBERS);
    for (const v3 of nonMembers) {
      this.nonMembers.push({
        raw: v3,
        obj: isCircle(v3) ? Circle3.from(v3) : Rectangle.from(v3),
        area: null
      });
    }
  }
  pushEdge(...edges) {
    if (edges.length === 0) {
      return;
    }
    this.dirty.add(EDirty.EDGES);
    for (const v3 of edges) {
      this.edges.push({
        raw: v3,
        obj: Line3.from(v3),
        area: null
      });
    }
  }
  update() {
    const dirtyMembers = this.dirty.has(EDirty.MEMBERS);
    const dirtyNonMembers = this.dirty.has(EDirty.NON_MEMBERS);
    let dirtyEdges = this.dirty.has(EDirty.EDGES);
    this.dirty.clear();
    const memberObjs = this.members.map((d3) => d3.obj);
    if (this.o.virtualEdges && (dirtyMembers || dirtyNonMembers)) {
      const nonMembersAsRects = this.nonMembers.map((d3) => d3.obj);
      const virtualEdges = calculateVirtualEdges(memberObjs, nonMembersAsRects, this.o.maxRoutingIterations, this.o.morphBuffer);
      const old = new Map(this.virtualEdges.map((e2) => [e2.obj.toString(), e2.area]));
      this.virtualEdges = virtualEdges.map((e2) => {
        var _a;
        return {
          raw: e2,
          obj: e2,
          area: (_a = old.get(e2.toString())) !== null && _a !== void 0 ? _a : null
        };
      });
      dirtyEdges = true;
    }
    let activeRegionDirty = false;
    if (dirtyMembers || dirtyEdges) {
      const edgesObj = this.virtualEdges.concat(this.edges).map((e2) => e2.obj);
      const bb = unionBoundingBox(memberObjs, edgesObj);
      const padding = Math.max(this.o.edgeR1, this.o.nodeR1) + this.o.morphBuffer;
      const activeRegion = Rectangle.from(addPadding(bb, padding));
      if (!activeRegion.equals(this.activeRegion)) {
        activeRegionDirty = true;
        this.activeRegion = activeRegion;
      }
    }
    if (activeRegionDirty) {
      const potentialWidth = Math.ceil(this.activeRegion.width / this.o.pixelGroup);
      const potentialHeight = Math.ceil(this.activeRegion.height / this.o.pixelGroup);
      if (this.activeRegion.x !== this.potentialArea.pixelX || this.activeRegion.y !== this.potentialArea.pixelY) {
        this.potentialArea = Area.fromPixelRegion(this.activeRegion, this.o.pixelGroup);
        this.members.forEach((m2) => m2.area = null);
        this.nonMembers.forEach((m2) => m2.area = null);
        this.edges.forEach((m2) => m2.area = null);
        this.virtualEdges.forEach((m2) => m2.area = null);
      } else if (potentialWidth !== this.potentialArea.width || potentialHeight !== this.potentialArea.height) {
        this.potentialArea = Area.fromPixelRegion(this.activeRegion, this.o.pixelGroup);
      }
    }
    const existing = /* @__PURE__ */ new Map();
    const addCache = (m2) => {
      if (m2.area) {
        const key = `${m2.obj.width}x${m2.obj.height}x${m2.obj instanceof Rectangle ? "R" : "C"}`;
        existing.set(key, m2.area);
      }
    };
    const createOrAddCache = (m2) => {
      if (m2.area) {
        return;
      }
      const key = `${m2.obj.width}x${m2.obj.height}x${m2.obj instanceof Rectangle ? "R" : "C"}`;
      if (existing.has(key)) {
        const r4 = existing.get(key);
        m2.area = this.potentialArea.copy(r4, { x: m2.obj.x - this.o.nodeR1, y: m2.obj.y - this.o.nodeR1 });
        return;
      }
      const r3 = m2.obj instanceof Rectangle ? createRectangleInfluenceArea(m2.obj, this.potentialArea, this.o.nodeR1) : createGenericInfluenceArea(m2.obj, this.potentialArea, this.o.nodeR1);
      m2.area = r3;
      existing.set(key, r3);
    };
    this.members.forEach(addCache);
    this.nonMembers.forEach(addCache);
    this.members.forEach(createOrAddCache);
    this.nonMembers.forEach((m2) => {
      if (!this.activeRegion.intersects(m2.obj)) {
        m2.area = null;
      } else {
        createOrAddCache(m2);
      }
    });
    this.edges.forEach((edge) => {
      if (!edge.area) {
        edge.area = createLineInfluenceArea(edge.obj, this.potentialArea, this.o.edgeR1);
      }
    });
    this.virtualEdges.forEach((edge) => {
      if (!edge.area) {
        edge.area = createLineInfluenceArea(edge.obj, this.potentialArea, this.o.edgeR1);
      }
    });
  }
  drawMembers(ctx3) {
    for (const member of this.members) {
      member.obj.draw(ctx3);
    }
  }
  drawNonMembers(ctx3) {
    for (const member of this.nonMembers) {
      member.obj.draw(ctx3);
    }
  }
  drawEdges(ctx3) {
    for (const edge of this.edges) {
      edge.obj.draw(ctx3);
    }
  }
  drawPotentialArea(ctx3, offset = true) {
    this.potentialArea.draw(ctx3, offset);
  }
  compute() {
    if (this.members.length === 0) {
      return new PointPath([]);
    }
    if (this.dirty.size > 0) {
      this.update();
    }
    const { o: o3, potentialArea } = this;
    const members = this.members.map((m2) => m2.area);
    const edges = this.virtualEdges.concat(this.edges).map((d3) => d3.area);
    const nonMembers = this.nonMembers.filter((d3) => d3.area != null).map((d3) => d3.area);
    const memberObjs = this.members.map((m2) => m2.obj);
    return calculatePotentialOutline(potentialArea, members, edges, nonMembers, (p3) => p3.containsElements(memberObjs), o3);
  }
};
function calculatePotentialOutline(potentialArea, members, edges, nonMembers, validPath, options = {}) {
  const o3 = Object.assign({}, defaultOptions2, options);
  let threshold = o3.threshold;
  let memberInfluenceFactor = o3.memberInfluenceFactor;
  let edgeInfluenceFactor = o3.edgeInfluenceFactor;
  let nonMemberInfluenceFactor = o3.nonMemberInfluenceFactor;
  const nodeInfA = (o3.nodeR0 - o3.nodeR1) * (o3.nodeR0 - o3.nodeR1);
  const edgeInfA = (o3.edgeR0 - o3.edgeR1) * (o3.edgeR0 - o3.edgeR1);
  for (let iterations = 0; iterations < o3.maxMarchingIterations; iterations++) {
    potentialArea.clear();
    if (memberInfluenceFactor !== 0) {
      const f3 = memberInfluenceFactor / nodeInfA;
      for (const item of members) {
        potentialArea.incArea(item, f3);
      }
    }
    if (edgeInfluenceFactor !== 0) {
      const f3 = edgeInfluenceFactor / edgeInfA;
      for (const area of edges) {
        potentialArea.incArea(area, f3);
      }
    }
    if (nonMemberInfluenceFactor !== 0) {
      const f3 = nonMemberInfluenceFactor / nodeInfA;
      for (const area of nonMembers) {
        potentialArea.incArea(area, f3);
      }
    }
    const contour = marchingSquares(potentialArea, threshold);
    if (contour && validPath(contour)) {
      return contour;
    }
    threshold *= 0.95;
    if (iterations <= o3.maxMarchingIterations * 0.5) {
      memberInfluenceFactor *= 1.2;
      edgeInfluenceFactor *= 1.2;
    } else if (nonMemberInfluenceFactor !== 0 && nonMembers.length > 0) {
      nonMemberInfluenceFactor *= 0.8;
    } else {
      break;
    }
  }
  return new PointPath([]);
}
function unionBoundingBox(memberItems, edgeItems) {
  if (memberItems.length === 0) {
    return new Rectangle(0, 0, 0, 0);
  }
  const activeRegion = Rectangle.from(memberItems[0]);
  for (const m2 of memberItems) {
    activeRegion.add(m2);
  }
  for (const l3 of edgeItems) {
    activeRegion.add(lineBoundingBox(l3));
  }
  return activeRegion;
}

// node_modules/@antv/g6/esm/plugins/bubble-sets.js
var __rest15 = function(s2, e2) {
  var t3 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t3[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t3[p3[i2]] = s2[p3[i2]];
    }
  return t3;
};
var BubbleSets2 = class _BubbleSets extends BasePlugin {
  constructor(context, options) {
    super(context, deep_mix_default({}, _BubbleSets.defaultOptions, options));
    this.path = null;
    this.members = /* @__PURE__ */ new Map();
    this.avoidMembers = /* @__PURE__ */ new Map();
    this.bubbleSetOptions = {};
    this.drawBubbleSets = () => {
      const { style, bubbleSetOptions } = this.parseOptions();
      if (!is_equal_default(this.bubbleSetOptions, bubbleSetOptions))
        this.init();
      this.bubbleSetOptions = Object.assign({}, bubbleSetOptions);
      const finalStyle = Object.assign(Object.assign({}, style), { d: this.getPath() });
      if (!this.shape) {
        this.shape = new Contour({ style: finalStyle });
        this.context.canvas.appendChild(this.shape);
      } else {
        this.shape.update(finalStyle);
      }
    };
    this.updateBubbleSetsPath = (event) => {
      if (!this.shape)
        return;
      const id = idOf(event.data);
      if (![...this.options.members, ...this.options.avoidMembers].includes(id))
        return;
      this.shape.update(Object.assign(Object.assign({}, this.parseOptions().style), { d: this.getPath(id) }));
    };
    this.getPath = (forceUpdateId) => {
      const { graph } = this.context;
      const currMembers = this.options.members;
      const prevMembers = [...this.members.keys()];
      const currAvoidMembers = this.options.avoidMembers;
      const prevAvoidMembers = [...this.avoidMembers.keys()];
      if (currMembers.length === 0 && currAvoidMembers.length === 0) {
        this.members.clear();
        this.avoidMembers.clear();
        this.path = [];
        return this.path;
      }
      if (!forceUpdateId && this.path && is_equal_default(currMembers, prevMembers) && is_equal_default(currAvoidMembers, prevAvoidMembers)) {
        return this.path;
      }
      const { enter: membersToEnter = [], exit: membersToExit = [] } = arrayDiff(prevMembers, currMembers, (d3) => d3);
      const { enter: avoidMembersToEnter = [], exit: avoidMembersToExit = [] } = arrayDiff(prevAvoidMembers, currAvoidMembers, (d3) => d3);
      if (forceUpdateId) {
        const isMemberNow = currMembers.includes(forceUpdateId);
        const isAvoidNow = currAvoidMembers.includes(forceUpdateId);
        if (isMemberNow) {
          membersToExit.push(forceUpdateId);
          membersToEnter.push(forceUpdateId);
        }
        if (isAvoidNow) {
          avoidMembersToExit.push(forceUpdateId);
          avoidMembersToEnter.push(forceUpdateId);
        }
      }
      const updateBubbleSets = (ids, isEntering, isMember) => {
        ids.forEach((id) => {
          const members = isMember ? this.members : this.avoidMembers;
          const pushMember = isMember ? "pushMember" : "pushNonMember";
          const removeMember = isMember ? "removeMember" : "removeNonMember";
          if (isEntering) {
            let area;
            if (graph.getElementType(id) === "edge") {
              [area] = convertToLine(graph, id);
              this.bubbleSets.pushEdge(area);
            } else {
              [area] = convertToRectangle(graph, id);
              this.bubbleSets[pushMember](area);
            }
            members.set(id, area);
          } else {
            const area = members.get(id);
            if (area) {
              if (graph.getElementType(id) === "edge") {
                this.bubbleSets.removeEdge(area);
              } else {
                this.bubbleSets[removeMember](area);
              }
              members.delete(id);
            }
          }
        });
      };
      updateBubbleSets(membersToExit, false, true);
      updateBubbleSets(membersToEnter, true, true);
      updateBubbleSets(avoidMembersToExit, false, false);
      updateBubbleSets(avoidMembersToEnter, true, false);
      const pointPath = this.bubbleSets.compute();
      const cleanPath = pointPath.sample(8).simplify(0).bSplines().simplify(0);
      this.path = getClosedSpline(cleanPath.points.map(parsePoint));
      return this.path;
    };
    this.bindEvents();
    this.bubbleSets = new BubbleSets(this.options);
  }
  bindEvents() {
    this.context.graph.on(GraphEvent.AFTER_RENDER, this.drawBubbleSets);
    this.context.graph.on(GraphEvent.AFTER_ELEMENT_UPDATE, this.updateBubbleSetsPath);
  }
  init() {
    this.bubbleSets = new BubbleSets(this.options);
    this.members.clear();
    this.avoidMembers.clear();
    this.path = null;
  }
  parseOptions() {
    const _a = this.options, { type, key, members, avoidMembers } = _a, rest = __rest15(_a, ["type", "key", "members", "avoidMembers"]);
    const res = Object.keys(rest).reduce((acc, key2) => {
      if (key2 in defaultOptions2) {
        acc.bubbleSetOptions[key2] = rest[key2];
      } else {
        acc.style[key2] = rest[key2];
      }
      return acc;
    }, { style: {}, bubbleSetOptions: {} });
    return Object.assign({ type, key, members, avoidMembers }, res);
  }
  /**
   * <zh/> 
   *
   * <en/> Add member elements
   * @param members - <zh/>  | <en/> single or multiple
   */
  addMember(members) {
    const membersToAdd = Array.isArray(members) ? members : [members];
    if (membersToAdd.some((member) => this.options.avoidMembers.includes(member))) {
      this.options.avoidMembers = this.options.avoidMembers.filter((id) => !membersToAdd.includes(id));
    }
    this.options.members = [.../* @__PURE__ */ new Set([...this.options.members, ...membersToAdd])];
    this.drawBubbleSets();
  }
  /**
   * <zh/> 
   *
   * <en/> Remove member elements
   * @param members - <zh/>  | <en/> single or multiple
   */
  removeMember(members) {
    const membersToRemove = Array.isArray(members) ? members : [members];
    this.options.members = this.options.members.filter((id) => !membersToRemove.includes(id));
    this.drawBubbleSets();
  }
  /**
   * <zh/> 
   *
   * <en/> Update member elements
   * @param members - <zh/>  | <en/> value or callback function
   */
  updateMember(members) {
    this.options.members = isFunction(members) ? members(this.options.members) : members;
    this.drawBubbleSets();
  }
  /**
   * <zh/> 
   *
   * <en/> Get member elements
   * @returns <zh/>  | <en/> member elements array
   */
  getMember() {
    return this.options.members;
  }
  /**
   * <zh/> 
   *
   * <en/> Add elements to avoid
   * @param avoidMembers - <zh/>  | <en/> single or multiple
   */
  addAvoidMember(avoidMembers) {
    const avoidMembersToAdd = Array.isArray(avoidMembers) ? avoidMembers : [avoidMembers];
    if (avoidMembersToAdd.some((avoidMember) => this.options.members.includes(avoidMember))) {
      this.options.members = this.options.members.filter((id) => !avoidMembersToAdd.includes(id));
    }
    this.options.avoidMembers = [.../* @__PURE__ */ new Set([...this.options.avoidMembers, ...avoidMembersToAdd])];
    this.drawBubbleSets();
  }
  /**
   * <zh/> 
   *
   * <en/> Remove elements to avoid
   * @param avoidMembers - <zh/>  | <en/> single or multiple
   */
  removeAvoidMember(avoidMembers) {
    const avoidMembersToRemove = Array.isArray(avoidMembers) ? avoidMembers : [avoidMembers];
    if (this.options.avoidMembers.some((member) => avoidMembersToRemove.includes(member))) {
      this.options.avoidMembers = this.options.avoidMembers.filter((id) => !avoidMembersToRemove.includes(id));
      this.drawBubbleSets();
    }
  }
  /**
   * <zh/> 
   *
   * <en/> Update elements to avoid
   * @param avoidMembers - <zh/>  | <en/> single or multiple
   */
  updateAvoidMember(avoidMembers) {
    this.options.avoidMembers = Array.isArray(avoidMembers) ? avoidMembers : [avoidMembers];
    this.drawBubbleSets();
  }
  /**
   * <zh/> 
   *
   * <en/> Get elements to avoid
   * @returns avoidMembers <zh/>  | <en/> member elements array
   */
  getAvoidMember() {
    return this.options.avoidMembers;
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy
   * @internal
   */
  destroy() {
    this.context.graph.off(GraphEvent.AFTER_RENDER, this.drawBubbleSets);
    this.context.graph.off(GraphEvent.AFTER_ELEMENT_UPDATE, this.updateBubbleSetsPath);
    if (this.shape) {
      this.shape.destroy();
      this.shape = void 0;
    }
    super.destroy();
  }
};
BubbleSets2.defaultOptions = Object.assign({
  members: [],
  avoidMembers: [],
  /** shape style */
  fill: "lightblue",
  fillOpacity: 0.2,
  stroke: "blue",
  strokeOpacity: 0.2
}, defaultOptions2);
var convertToRectangle = (graph, ids) => {
  const idArr = Array.isArray(ids) ? ids : [ids];
  return idArr.map((id) => {
    const bbox = graph.getElementRenderBounds(id);
    return new Rectangle(bbox.min[0], bbox.min[1], getBBoxWidth(bbox), getBBoxHeight(bbox));
  });
};
var convertToLine = (graph, ids) => {
  const idArr = Array.isArray(ids) ? ids : [ids];
  return idArr.map((id) => {
    const data = graph.getEdgeData(id);
    const source = graph.getElementPosition(data.source);
    const target = graph.getElementPosition(data.target);
    return Line3.from({ x1: source[0], y1: source[1], x2: target[0], y2: target[1] });
  });
};

// node_modules/@antv/g6/esm/plugins/camera-setting.js
var CameraSetting = class extends BasePlugin {
  constructor(context, options) {
    super(context, options);
    this.setOptions = (options2) => {
      const caller = {
        cameraType: "setType",
        near: "setNear",
        far: "setFar",
        fov: "setFov",
        aspect: "setAspect",
        //  projectionMode  near/far/fov/aspect 
        // Ensure that projectionMode is set after near/far/fov/aspect
        projectionMode: "setProjectionMode",
        distance: "setDistance",
        minDistance: "setMinDistance",
        maxDistance: "setMaxDistance",
        roll: "setRoll",
        elevation: "setElevation",
        azimuth: "setAzimuth"
      };
      const valueMapper = (key, value) => {
        switch (key) {
          case "projectionMode":
            return value === "perspective" ? 1 : 0;
          case "cameraType":
            return { orbiting: 0, exploring: 1, tracking: 2 }[value];
          case "aspect":
            if (typeof value === "number")
              return value;
            return this.getCanvasAspect();
          default:
            return value;
        }
      };
      Object.entries(caller).forEach(([key, method]) => {
        const value = options2[key];
        if (value !== void 0) {
          const actualValue = valueMapper(key, value);
          this.context.canvas.getCamera()[method](actualValue);
        }
      });
    };
    this.bindEvents();
  }
  /**
   * <zh/> 
   *
   * <en/> Update camera parameters
   * @param options - <zh/>  | <en/> Camera configuration options
   * @internal
   */
  update(options) {
    this.setOptions(options);
    super.update(options);
  }
  bindEvents() {
    this.context.graph.once(GraphEvent.BEFORE_DRAW, () => this.setOptions(this.options));
  }
  getCanvasAspect() {
    const [width2, height] = this.context.viewport.getCanvasSize();
    return width2 / height;
  }
};

// node_modules/@antv/g6/esm/plugins/contextmenu/util.js
function getContentFromItems(items) {
  return `
    <ul class="g6-contextmenu-ul">
      ${items.map((item) => `<li  class="g6-contextmenu-li" value="${item.value}">${item.name}</li>`).join("")}
    </ul>
  `;
}
var CONTEXTMENU_CSS = `
  .g6-contextmenu {
    font-size: 12px;
    background-color: rgba(255, 255, 255, 0.96);
    border-radius: 4px;
    overflow: hidden;
    box-shadow: rgba(0, 0, 0, 0.12) 0px 6px 12px 0px;
    transition: visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1) 0s, left 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s, top 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s;
  }

  .g6-contextmenu-ul {
    max-width: 256px;
    min-width: 96px;
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .g6-contextmenu-li {
    padding: 8px 12px;
    cursor: pointer;
    user-select: none;
  }

  .g6-contextmenu-li:hover {
    background-color: #f5f5f5;
    cursor: pointer;
  }
`;

// node_modules/@antv/g6/esm/plugins/contextmenu/index.js
var __awaiter16 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Contextmenu = class _Contextmenu extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, _Contextmenu.defaultOptions, options));
    this.targetElement = null;
    this.onTriggerEvent = (event) => {
      var _a;
      (_a = event.preventDefault) === null || _a === void 0 ? void 0 : _a.call(event);
      this.show(event);
    };
    this.onMenuItemClick = (event) => {
      const { onClick, trigger } = this.options;
      if (event.target instanceof HTMLElement) {
        if (event.target.className.includes("g6-contextmenu-li")) {
          const value = event.target.getAttribute("value");
          onClick === null || onClick === void 0 ? void 0 : onClick(value, event.target, this.targetElement);
          this.hide();
        }
      }
      if (trigger !== "click")
        this.hide();
    };
    this.initElement();
    this.update(options);
  }
  initElement() {
    this.$element = createPluginContainer("contextmenu", false, { zIndex: "99" });
    const { className } = this.options;
    if (className)
      this.$element.classList.add(className);
    const $container = this.context.canvas.getContainer();
    $container.appendChild(this.$element);
    insertDOM("g6-contextmenu-css", "style", {}, CONTEXTMENU_CSS, document.head);
  }
  /**
   * <zh/> 
   *
   * <en/> Show the contextmenu
   * @param event - <zh/>  | <en/> Element pointer event
   * @internal
   */
  show(event) {
    return __awaiter16(this, void 0, void 0, function* () {
      const { enable, offset } = this.options;
      if (typeof enable === "function" && !enable(event) || !enable) {
        this.hide();
        return;
      }
      const content = yield this.getDOMContent(event);
      if (content instanceof HTMLElement) {
        this.$element.innerHTML = "";
        this.$element.appendChild(content);
      } else {
        this.$element.innerHTML = content;
      }
      const clientRect = this.context.graph.getCanvas().getContainer().getBoundingClientRect();
      this.$element.style.left = `${event.client.x - clientRect.left + offset[0]}px`;
      this.$element.style.top = `${event.client.y - clientRect.top + offset[1]}px`;
      this.$element.style.display = "block";
      this.targetElement = event.target;
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Hide the contextmenu
   */
  hide() {
    this.$element.style.display = "none";
    this.targetElement = null;
  }
  /**
   * <zh/> 
   *
   * <en/> Update the contextmenu options
   * @param options - <zh/>  | <en/> Options
   * @internal
   */
  update(options) {
    this.unbindEvents();
    super.update(options);
    this.bindEvents();
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy the contextmenu
   * @internal
   */
  destroy() {
    this.unbindEvents();
    super.destroy();
    this.$element.remove();
  }
  getDOMContent(event) {
    return __awaiter16(this, void 0, void 0, function* () {
      const { getContent, getItems } = this.options;
      if (getItems) {
        return getContentFromItems(yield getItems(event));
      }
      return yield getContent(event);
    });
  }
  bindEvents() {
    const { graph } = this.context;
    const { trigger } = this.options;
    graph.on(`canvas:${trigger}`, this.onTriggerEvent);
    graph.on(`node:${trigger}`, this.onTriggerEvent);
    graph.on(`edge:${trigger}`, this.onTriggerEvent);
    graph.on(`combo:${trigger}`, this.onTriggerEvent);
    document.addEventListener("click", this.onMenuItemClick);
  }
  unbindEvents() {
    const { graph } = this.context;
    const { trigger } = this.options;
    graph.off(`canvas:${trigger}`, this.onTriggerEvent);
    graph.off(`node:${trigger}`, this.onTriggerEvent);
    graph.off(`edge:${trigger}`, this.onTriggerEvent);
    graph.off(`combo:${trigger}`, this.onTriggerEvent);
    document.removeEventListener("click", this.onMenuItemClick);
  }
};
Contextmenu.defaultOptions = {
  trigger: "contextmenu",
  offset: [4, 4],
  loadingContent: '<div class="g6-contextmenu-loading">Loading...</div>',
  getContent: () => "It is a empty context menu.",
  enable: () => true
};

// node_modules/@antv/g6/esm/plugins/edge-bundling/index.js
var EdgeBundling = class _EdgeBundling extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, _EdgeBundling.defaultOptions, options));
    this.edgeBundles = {};
    this.edgePoints = {};
    this.onBundle = () => {
      const { model, element } = this.context;
      const edges = model.getEdgeData();
      this.divideEdges(this.options.divisions);
      const { cycles, iterRate, divRate } = this.options;
      let { lambda, divisions, iterations } = this.options;
      for (let i2 = 0; i2 < cycles; i2++) {
        for (let j2 = 0; j2 < iterations; j2++) {
          const forces = {};
          edges.forEach((edge) => {
            var _a;
            if (edge.source === edge.target)
              return;
            const edgeId = idOf(edge);
            forces[edgeId] = this.getEdgeForces(edge, divisions, lambda);
            for (let p3 = 0; p3 < divisions + 1; p3++) {
              (_a = this.edgePoints)[edgeId] || (_a[edgeId] = []);
              this.edgePoints[edgeId][p3] = add(this.edgePoints[edgeId][p3], forces[edgeId][p3]);
            }
          });
        }
        lambda /= 2;
        divisions *= divRate;
        iterations *= iterRate;
        this.divideEdges(divisions);
      }
      edges.forEach((edge) => {
        const edgeId = idOf(edge);
        const edgeEl = element.getElement(edgeId);
        edgeEl === null || edgeEl === void 0 ? void 0 : edgeEl.update({ d: getPolylinePath(this.edgePoints[edgeId]) });
      });
    };
    this.bindEvents();
  }
  get nodeMap() {
    const nodes = this.context.model.getNodeData();
    return Object.fromEntries(nodes.map((node) => [idOf(node), toVector2(positionOf(node))]));
  }
  divideEdges(divisions) {
    const edges = this.context.model.getEdgeData();
    edges.forEach((edge) => {
      var _a;
      const edgeId = idOf(edge);
      (_a = this.edgePoints)[edgeId] || (_a[edgeId] = []);
      const source = this.nodeMap[edge.source];
      const target = this.nodeMap[edge.target];
      if (divisions === 1) {
        this.edgePoints[edgeId].push(source);
        this.edgePoints[edgeId].push(divide(add(source, target), 2));
        this.edgePoints[edgeId].push(target);
      } else {
        const edgeLength = this.edgePoints[edgeId].length === 0 ? (
          // edge is a straight line
          distance(source, target)
        ) : (
          // edge is a polyline
          getEdgeLength(this.edgePoints[edgeId])
        );
        const divisionLength = edgeLength / (divisions + 1);
        let currentDivisionLength = divisionLength;
        const newEdgePoints = [source];
        for (let i2 = 1; i2 < this.edgePoints[edgeId].length; i2++) {
          const prevEp = this.edgePoints[edgeId][i2 - 1];
          const ep = this.edgePoints[edgeId][i2];
          let oriDivisionLength = distance(ep, prevEp);
          while (oriDivisionLength > currentDivisionLength) {
            const ratio = currentDivisionLength / oriDivisionLength;
            const edgePoint = add(prevEp, multiply(subtract(ep, prevEp), ratio));
            newEdgePoints.push(edgePoint);
            oriDivisionLength -= currentDivisionLength;
            currentDivisionLength = divisionLength;
          }
          currentDivisionLength -= oriDivisionLength;
        }
        newEdgePoints.push(target);
        this.edgePoints[edgeId] = newEdgePoints;
      }
    });
  }
  getVectorPosition(edge) {
    const source = this.nodeMap[edge.source];
    const target = this.nodeMap[edge.target];
    const [vx, vy] = subtract(target, source);
    const length = distance(source, target);
    return { source, target, vx, vy, length };
  }
  measureEdgeCompatibility(edge1, edge2) {
    const vector1 = this.getVectorPosition(edge1);
    const vector2 = this.getVectorPosition(edge2);
    const ac = getAngleCompatibility(vector1, vector2);
    const sc = getScaleCompatibility(vector1, vector2);
    const pc = getPositionCompatibility(vector1, vector2);
    const vc = getVisibilityCompatibility(vector1, vector2);
    return ac * sc * pc * vc;
  }
  getEdgeBundles() {
    const edgeBundles = {};
    const bundleThreshold = this.options.bundleThreshold;
    const edges = this.context.model.getEdgeData();
    edges.forEach((edge1, i2) => {
      edges.forEach((edge2, j2) => {
        var _a, _b;
        if (j2 <= i2)
          return;
        const compatibility = this.measureEdgeCompatibility(edge1, edge2);
        if (compatibility >= bundleThreshold) {
          edgeBundles[_a = idOf(edge1)] || (edgeBundles[_a] = []);
          edgeBundles[idOf(edge1)].push(edge2);
          edgeBundles[_b = idOf(edge2)] || (edgeBundles[_b] = []);
          edgeBundles[idOf(edge2)].push(edge1);
        }
      });
    });
    return edgeBundles;
  }
  getSpringForce(divisions, kp) {
    const { pre, cur, next } = divisions;
    return multiply(subtract(add(pre, next), multiply(cur, 2)), kp);
  }
  getElectrostaticForce(pidx, edge) {
    if (is_empty_default(this.edgeBundles)) {
      this.edgeBundles = this.getEdgeBundles();
    }
    const edgeBundle = this.edgeBundles[idOf(edge)];
    let resForce = [0, 0];
    edgeBundle === null || edgeBundle === void 0 ? void 0 : edgeBundle.forEach((eb) => {
      const p1 = this.edgePoints[idOf(eb)][pidx];
      const p22 = this.edgePoints[idOf(edge)][pidx];
      const force = subtract(p1, p22);
      const length = distance(p1, p22);
      resForce = add(resForce, multiply(force, 1 / length));
    });
    return resForce;
  }
  getEdgeForces(edge, divisions, lambda) {
    const source = this.nodeMap[edge.source];
    const target = this.nodeMap[edge.target];
    const kp = this.options.K / (distance(source, target) * (divisions + 1));
    const edgePointForces = [[0, 0]];
    const edgeId = idOf(edge);
    for (let i2 = 1; i2 < divisions; i2++) {
      const spring = this.getSpringForce({
        pre: this.edgePoints[edgeId][i2 - 1],
        cur: this.edgePoints[edgeId][i2],
        next: this.edgePoints[edgeId][i2 + 1] || [0, 0]
      }, kp);
      const electrostatic = this.getElectrostaticForce(i2, edge);
      edgePointForces.push(multiply(add(spring, electrostatic), lambda));
    }
    edgePointForces.push([0, 0]);
    return edgePointForces;
  }
  bindEvents() {
    const { graph } = this.context;
    graph.on(GraphEvent.AFTER_RENDER, this.onBundle);
  }
  unbindEvents() {
    const { graph } = this.context;
    graph.off(GraphEvent.AFTER_RENDER, this.onBundle);
  }
  destroy() {
    this.unbindEvents();
    super.destroy();
  }
};
EdgeBundling.defaultOptions = {
  K: 0.1,
  lambda: 0.1,
  divisions: 1,
  divRate: 2,
  cycles: 6,
  iterations: 90,
  iterRate: 2 / 3,
  bundleThreshold: 0.6
};
var getAngleCompatibility = (p3, q2) => {
  return Math.abs(dot([p3.vx, p3.vy], [q2.vx, q2.vy]) / (p3.length * q2.length));
};
var getScaleCompatibility = (p3, q2) => {
  const aLength = (p3.length + q2.length) / 2;
  return 2 / (aLength / Math.min(p3.length, q2.length) + Math.max(p3.length, q2.length) / aLength);
};
var getPositionCompatibility = (p3, q2) => {
  const aLength = (p3.length + q2.length) / 2;
  const pMid = divide(add(p3.source, p3.target), 2);
  const qMid = divide(add(q2.source, q2.target), 2);
  return aLength / (aLength + distance(pMid, qMid));
};
var projectPointToEdge = (p3, e2) => {
  if (e2.source[0] === e2.target[0])
    return [e2.source[0], p3[1]];
  if (e2.source[1] === e2.target[1])
    return [p3[0], e2.source[1]];
  const k2 = (e2.source[1] - e2.target[1]) / (e2.source[0] - e2.target[0]);
  const x4 = (k2 * k2 * e2.source[0] + k2 * (p3[1] - e2.source[1]) + p3[0]) / (k2 * k2 + 1);
  const y4 = k2 * (x4 - e2.source[0]) + e2.source[1];
  return [x4, y4];
};
var getEdgeVisibility = (p3, q2) => {
  const is = projectPointToEdge(q2.source, p3);
  const it2 = projectPointToEdge(q2.target, p3);
  const iMid = divide(add(is, it2), 2);
  const pMid = divide(add(p3.source, p3.target), 2);
  if (distance(is, it2) === 0)
    return 0;
  return Math.max(0, 1 - 2 * distance(pMid, iMid) / distance(is, it2));
};
var getVisibilityCompatibility = (p3, q2) => {
  return Math.min(getEdgeVisibility(p3, q2), getEdgeVisibility(q2, p3));
};
var getEdgeLength = (points) => {
  let length = 0;
  for (let i2 = 1; i2 < points.length; i2++) {
    length += distance(points[i2], points[i2 - 1]);
  }
  return length;
};

// node_modules/@antv/g6/esm/plugins/edge-filter-lens/index.js
var defaultLensStyle = {
  fill: "#fff",
  fillOpacity: 1,
  lineWidth: 1,
  stroke: "#000",
  strokeOpacity: 0.8,
  zIndex: -Infinity
};
var DELTA = 0.05;
var EdgeFilterLens = class _EdgeFilterLens extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, _EdgeFilterLens.defaultOptions, options));
    this.shapes = /* @__PURE__ */ new Map();
    this.r = this.options.r;
    this.onEdgeFilter = (event) => {
      if (this.options.trigger === "drag" && this.isLensOn)
        return;
      const origin = parsePoint(event.canvas);
      this.renderLens(origin);
      this.renderFocusElements();
    };
    this.renderLens = (origin) => {
      const style = Object.assign({}, defaultLensStyle, this.options.style);
      if (!this.isLensOn) {
        this.lens = new Circle2({ style });
        this.canvas.appendChild(this.lens);
      }
      Object.assign(style, toPointObject(origin), { size: this.r * 2 });
      this.lens.update(style);
    };
    this.getFilterData = () => {
      const { filter } = this.options;
      const { model } = this.context;
      const data = model.getData();
      if (!filter)
        return data;
      const { nodes, edges, combos } = data;
      return {
        nodes: nodes.filter((node) => filter(idOf(node), "node")),
        edges: edges.filter((edge) => filter(idOf(edge), "edge")),
        combos: combos.filter((combo) => filter(idOf(combo), "combo"))
      };
    };
    this.getFocusElements = (origin) => {
      const { nodes, edges } = this.getFilterData();
      const focusNodes = nodes.filter((datum) => distance(positionOf(datum), origin) < this.r);
      const focusNodeIds = focusNodes.map((node) => idOf(node));
      const focusEdges = edges.filter((datum) => {
        const { source, target } = datum;
        const isSourceFocus = focusNodeIds.includes(source);
        const isTargetFocus = focusNodeIds.includes(target);
        switch (this.options.nodeType) {
          case "both":
            return isSourceFocus && isTargetFocus;
          case "either":
            return isSourceFocus !== isTargetFocus;
          case "source":
            return isSourceFocus && !isTargetFocus;
          case "target":
            return !isSourceFocus && isTargetFocus;
          default:
            return false;
        }
      });
      return { nodes: focusNodes, edges: focusEdges };
    };
    this.renderFocusElements = () => {
      const { element, graph } = this.context;
      if (!this.isLensOn)
        return;
      const origin = this.lens.getCenter();
      const { nodes, edges } = this.getFocusElements(origin);
      const ids = /* @__PURE__ */ new Set();
      const iterate = (datum) => {
        const id = idOf(datum);
        ids.add(id);
        const shape = element.getElement(id);
        if (!shape)
          return;
        const cloneShape = this.shapes.get(id) || shape.cloneNode();
        cloneShape.setPosition(shape.getPosition());
        cloneShape.id = shape.id;
        if (!this.shapes.has(id)) {
          this.canvas.appendChild(cloneShape);
          this.shapes.set(id, cloneShape);
        } else {
          Object.entries(shape.attributes).forEach(([key, value]) => {
            if (cloneShape.style[key] !== value)
              cloneShape.style[key] = value;
          });
        }
        const elementType = graph.getElementType(id);
        const style = this.getElementStyle(elementType, datum);
        cloneShape.update(style);
      };
      nodes.forEach(iterate);
      edges.forEach(iterate);
      this.shapes.forEach((shape, id) => {
        if (!ids.has(id)) {
          shape.destroy();
          this.shapes.delete(id);
        }
      });
    };
    this.scaleRByWheel = (event) => {
      var _a;
      if (this.options.preventDefault)
        event.preventDefault();
      const { clientX, clientY, deltaX, deltaY } = event;
      const { graph, canvas: canvas2 } = this.context;
      const scaleOrigin = graph.getCanvasByClient([clientX, clientY]);
      const origin = (_a = this.lens) === null || _a === void 0 ? void 0 : _a.getCenter();
      if (!this.isLensOn || distance(scaleOrigin, origin) > this.r) {
        return;
      }
      const { maxR, minR } = this.options;
      const ratio = deltaX + deltaY > 0 ? 1 / (1 - DELTA) : 1 - DELTA;
      const canvasR = Math.min(...canvas2.getSize()) / 2;
      this.r = Math.max(minR || 0, Math.min(maxR || canvasR, this.r * ratio));
      this.renderLens(origin);
      this.renderFocusElements();
    };
    this.isLensDragging = false;
    this.onDragStart = (event) => {
      var _a;
      const dragOrigin = parsePoint(event.canvas);
      const origin = (_a = this.lens) === null || _a === void 0 ? void 0 : _a.getCenter();
      if (!this.isLensOn || distance(dragOrigin, origin) > this.r)
        return;
      this.isLensDragging = true;
    };
    this.onDrag = (event) => {
      if (!this.isLensDragging)
        return;
      const dragOrigin = parsePoint(event.canvas);
      this.renderLens(dragOrigin);
      this.renderFocusElements();
    };
    this.onDragEnd = () => {
      this.isLensDragging = false;
    };
    this.bindEvents();
  }
  get canvas() {
    return this.context.canvas.getLayer("transient");
  }
  get isLensOn() {
    return this.lens && !this.lens.destroyed;
  }
  getElementStyle(elementType, datum) {
    const styler = elementType === "node" ? this.options.nodeStyle : this.options.edgeStyle;
    if (typeof styler === "function")
      return styler(datum);
    return styler;
  }
  get graphDom() {
    return this.context.graph.getCanvas().getContextService().getDomElement();
  }
  bindEvents() {
    var _a;
    const { graph } = this.context;
    const { trigger, scaleRBy } = this.options;
    const canvas2 = graph.getCanvas().getLayer();
    if (["click", "drag"].includes(trigger)) {
      canvas2.addEventListener(CommonEvent.CLICK, this.onEdgeFilter);
    }
    if (trigger === "pointermove") {
      canvas2.addEventListener(CommonEvent.POINTER_MOVE, this.onEdgeFilter);
    } else if (trigger === "drag") {
      canvas2.addEventListener(CommonEvent.DRAG_START, this.onDragStart);
      canvas2.addEventListener(CommonEvent.DRAG, this.onDrag);
      canvas2.addEventListener(CommonEvent.DRAG_END, this.onDragEnd);
    }
    if (scaleRBy === "wheel") {
      (_a = this.graphDom) === null || _a === void 0 ? void 0 : _a.addEventListener(CommonEvent.WHEEL, this.scaleRByWheel, { passive: false });
    }
  }
  unbindEvents() {
    var _a;
    const { graph } = this.context;
    const { trigger, scaleRBy } = this.options;
    const canvas2 = graph.getCanvas().getLayer();
    if (["click", "drag"].includes(trigger)) {
      canvas2.removeEventListener(CommonEvent.CLICK, this.onEdgeFilter);
    }
    if (trigger === "pointermove") {
      canvas2.removeEventListener(CommonEvent.POINTER_MOVE, this.onEdgeFilter);
    } else if (trigger === "drag") {
      canvas2.removeEventListener(CommonEvent.DRAG_START, this.onDragStart);
      canvas2.removeEventListener(CommonEvent.DRAG, this.onDrag);
      canvas2.removeEventListener(CommonEvent.DRAG_END, this.onDragEnd);
    }
    if (scaleRBy === "wheel") {
      (_a = this.graphDom) === null || _a === void 0 ? void 0 : _a.removeEventListener(CommonEvent.WHEEL, this.scaleRByWheel);
    }
  }
  update(options) {
    var _a;
    this.unbindEvents();
    super.update(options);
    this.r = (_a = options.r) !== null && _a !== void 0 ? _a : this.r;
    this.bindEvents();
  }
  destroy() {
    this.unbindEvents();
    if (this.isLensOn) {
      this.lens.destroy();
    }
    this.shapes.forEach((shape, id) => {
      shape.destroy();
      this.shapes.delete(id);
    });
    super.destroy();
  }
};
EdgeFilterLens.defaultOptions = {
  trigger: "pointermove",
  r: 60,
  nodeType: "both",
  filter: () => true,
  style: { lineWidth: 2 },
  nodeStyle: { label: false },
  edgeStyle: { label: true },
  scaleRBy: "wheel",
  preventDefault: true
};

// node_modules/@antv/g6/esm/plugins/fisheye/index.js
var defaultLensStyle2 = {
  fill: "#ccc",
  fillOpacity: 0.1,
  lineWidth: 2,
  stroke: "#000",
  strokeOpacity: 0.8,
  labelFontSize: 12
};
var R_DELTA = 0.05;
var D_DELTA = 0.1;
var Fisheye = class _Fisheye extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, _Fisheye.defaultOptions, options));
    this.r = this.options.r;
    this.d = this.options.d;
    this.onCreateFisheye = (event) => {
      if (this.options.trigger === "drag" && this.isLensOn)
        return;
      const origin = parsePoint(event.canvas);
      this.onMagnify(origin);
    };
    this.onMagnify = (origin) => {
      if (origin.some(isNaN))
        return;
      this.renderLens(origin);
      this.renderFocusElements();
    };
    this.renderLens = (origin) => {
      const style = Object.assign({}, defaultLensStyle2, this.options.style);
      if (!this.isLensOn) {
        this.lens = new Circle2({ style });
        this.canvas.appendChild(this.lens);
      }
      Object.assign(style, toPointObject(origin), {
        size: this.r * 2,
        label: this.options.showDPercent,
        labelText: this.getDPercent()
      });
      this.lens.update(style);
    };
    this.getDPercent = () => {
      const { minD, maxD } = this.options;
      const percent = Math.round((this.d - minD) / (maxD - minD) * 100);
      return `${percent}%`;
    };
    this.prevMagnifiedStyleMap = /* @__PURE__ */ new Map();
    this.prevOriginStyleMap = /* @__PURE__ */ new Map();
    this.renderFocusElements = () => {
      if (!this.isLensOn)
        return;
      const { graph } = this.context;
      const origin = this.lens.getCenter();
      const molecularParam = (this.d + 1) * this.r;
      const magnifiedStyleMap = /* @__PURE__ */ new Map();
      const originStyleMap = /* @__PURE__ */ new Map();
      const nodeData = graph.getNodeData();
      nodeData.forEach((datum) => {
        const position2 = positionOf(datum);
        const distanceToOrigin = distance(position2, origin);
        if (distanceToOrigin > this.r)
          return;
        const magnifiedDistance = molecularParam * distanceToOrigin / (this.d * distanceToOrigin + this.r);
        const [nodeX, nodeY] = position2;
        const [originX, originY] = origin;
        const cos = (nodeX - originX) / distanceToOrigin;
        const sin = (nodeY - originY) / distanceToOrigin;
        const newPoint = [originX + magnifiedDistance * cos, originY + magnifiedDistance * sin];
        const nodeId = idOf(datum);
        const style = this.getNodeStyle(datum);
        const originStyle = pick_default(graph.getElementRenderStyle(nodeId), Object.keys(style));
        magnifiedStyleMap.set(nodeId, Object.assign(Object.assign({}, toPointObject(newPoint)), style));
        originStyleMap.set(nodeId, Object.assign(Object.assign({}, toPointObject(position2)), originStyle));
      });
      this.updateStyle(magnifiedStyleMap, originStyleMap);
    };
    this.getNodeStyle = (datum) => {
      const { nodeStyle } = this.options;
      return typeof nodeStyle === "function" ? nodeStyle(datum) : nodeStyle;
    };
    this.updateStyle = (magnifiedStyleMap, originStyleMap) => {
      const { graph, element } = this.context;
      const { enter, exit, keep } = arrayDiff(Array.from(this.prevMagnifiedStyleMap.keys()), Array.from(magnifiedStyleMap.keys()), (d3) => d3);
      const relatedEdges = /* @__PURE__ */ new Set();
      const update = (nodeId, style) => {
        const node = element.getElement(nodeId);
        node === null || node === void 0 ? void 0 : node.update(style);
        graph.getRelatedEdgesData(nodeId).forEach((datum) => {
          relatedEdges.add(idOf(datum));
        });
      };
      [...enter, ...keep].forEach((nodeId) => {
        update(nodeId, magnifiedStyleMap.get(nodeId));
      });
      exit.forEach((nodeId) => {
        update(nodeId, this.prevOriginStyleMap.get(nodeId));
        this.prevOriginStyleMap.delete(nodeId);
      });
      relatedEdges.forEach((edgeId) => {
        const edge = element.getElement(edgeId);
        edge === null || edge === void 0 ? void 0 : edge.update({});
      });
      this.prevMagnifiedStyleMap = magnifiedStyleMap;
      originStyleMap.forEach((style, nodeId) => {
        if (!this.prevOriginStyleMap.has(nodeId)) {
          this.prevOriginStyleMap.set(nodeId, style);
        }
      });
    };
    this.isWheelValid = (event) => {
      if (this.options.preventDefault)
        event.preventDefault();
      if (!this.isLensOn)
        return false;
      const { clientX, clientY } = event;
      const scaleOrigin = this.context.graph.getCanvasByClient([clientX, clientY]);
      const origin = this.lens.getCenter();
      if (distance(scaleOrigin, origin) > this.r)
        return false;
      return true;
    };
    this.scaleR = (positive) => {
      const { maxR, minR } = this.options;
      const ratio = positive ? 1 / (1 - R_DELTA) : 1 - R_DELTA;
      const canvasR = Math.min(...this.context.canvas.getSize()) / 2;
      this.r = Math.max(minR || 0, Math.min(maxR || canvasR, this.r * ratio));
    };
    this.scaleD = (positive) => {
      const { maxD, minD } = this.options;
      const newD = positive ? this.d + D_DELTA : this.d - D_DELTA;
      this.d = Math.max(minD, Math.min(maxD, newD));
    };
    this.scaleRByWheel = (event) => {
      if (!this.isWheelValid(event))
        return;
      const { deltaX, deltaY } = event;
      this.scaleR(deltaX + deltaY > 0);
      const origin = this.lens.getCenter();
      this.onMagnify(origin);
    };
    this.scaleDByWheel = (event) => {
      if (!this.isWheelValid(event))
        return;
      const { deltaX, deltaY } = event;
      this.scaleD(deltaX + deltaY > 0);
      const origin = this.lens.getCenter();
      this.onMagnify(origin);
    };
    this.isDragValid = (event) => {
      if (this.options.preventDefault)
        event.preventDefault();
      if (!this.isLensOn)
        return false;
      const dragOrigin = parsePoint(event.canvas);
      const origin = this.lens.getCenter();
      if (distance(dragOrigin, origin) > this.r)
        return false;
      return true;
    };
    this.isLensDragging = false;
    this.onDragStart = (event) => {
      if (!this.isDragValid(event))
        return;
      this.isLensDragging = true;
    };
    this.onDrag = (event) => {
      if (!this.isLensDragging)
        return;
      const dragOrigin = parsePoint(event.canvas);
      this.onMagnify(dragOrigin);
    };
    this.onDragEnd = () => {
      this.isLensDragging = false;
    };
    this.scaleRByDrag = (event) => {
      if (!this.isLensDragging)
        return;
      const { dx, dy } = event;
      this.scaleR(dx - dy > 0);
      const origin = this.lens.getCenter();
      this.onMagnify(origin);
    };
    this.scaleDByDrag = (event) => {
      if (!this.isLensDragging)
        return;
      const { dx, dy } = event;
      this.scaleD(dx - dy > 0);
      const origin = this.lens.getCenter();
      this.onMagnify(origin);
    };
    this.bindEvents();
  }
  get canvas() {
    return this.context.canvas.getLayer("transient");
  }
  get isLensOn() {
    return this.lens && !this.lens.destroyed;
  }
  get graphDom() {
    return this.context.graph.getCanvas().getContextService().getDomElement();
  }
  bindEvents() {
    var _a;
    const { graph } = this.context;
    const { trigger, scaleRBy, scaleDBy } = this.options;
    const canvas2 = graph.getCanvas().getLayer();
    if (["click", "drag"].includes(trigger)) {
      canvas2.addEventListener(CommonEvent.CLICK, this.onCreateFisheye);
    }
    if (trigger === "pointermove") {
      canvas2.addEventListener(CommonEvent.POINTER_MOVE, this.onCreateFisheye);
    }
    if (trigger === "drag" || scaleRBy === "drag" || scaleDBy === "drag") {
      canvas2.addEventListener(CommonEvent.DRAG_START, this.onDragStart);
      canvas2.addEventListener(CommonEvent.DRAG_END, this.onDragEnd);
      const dragFunc = trigger === "drag" ? this.onDrag : scaleRBy === "drag" ? this.scaleRByDrag : this.scaleDByDrag;
      canvas2.addEventListener(CommonEvent.DRAG, dragFunc);
    }
    if (scaleRBy === "wheel" || scaleDBy === "wheel") {
      const wheelFunc = scaleRBy === "wheel" ? this.scaleRByWheel : this.scaleDByWheel;
      (_a = this.graphDom) === null || _a === void 0 ? void 0 : _a.addEventListener(CommonEvent.WHEEL, wheelFunc, { passive: false });
    }
  }
  unbindEvents() {
    var _a;
    const { graph } = this.context;
    const { trigger, scaleRBy, scaleDBy } = this.options;
    const canvas2 = graph.getCanvas().getLayer();
    if (["click", "drag"].includes(trigger)) {
      canvas2.removeEventListener(CommonEvent.CLICK, this.onCreateFisheye);
    }
    if (trigger === "pointermove") {
      canvas2.removeEventListener(CommonEvent.POINTER_MOVE, this.onCreateFisheye);
    }
    if (trigger === "drag" || scaleRBy === "drag" || scaleDBy === "drag") {
      canvas2.removeEventListener(CommonEvent.DRAG_START, this.onDragStart);
      canvas2.removeEventListener(CommonEvent.DRAG_END, this.onDragEnd);
      const dragFunc = trigger === "drag" ? this.onDrag : scaleRBy === "drag" ? this.scaleRByDrag : this.scaleDByDrag;
      canvas2.removeEventListener(CommonEvent.DRAG, dragFunc);
    }
    if (scaleRBy === "wheel" || scaleDBy === "wheel") {
      const wheelFunc = scaleRBy === "wheel" ? this.scaleRByWheel : this.scaleDByWheel;
      (_a = this.graphDom) === null || _a === void 0 ? void 0 : _a.removeEventListener(CommonEvent.WHEEL, wheelFunc);
    }
  }
  update(options) {
    var _a, _b;
    this.unbindEvents();
    super.update(options);
    this.r = (_a = options.r) !== null && _a !== void 0 ? _a : this.r;
    this.d = (_b = options.d) !== null && _b !== void 0 ? _b : this.d;
    this.bindEvents();
  }
  destroy() {
    var _a;
    this.unbindEvents();
    if (this.isLensOn) {
      (_a = this.lens) === null || _a === void 0 ? void 0 : _a.destroy();
    }
    this.prevMagnifiedStyleMap.clear();
    this.prevOriginStyleMap.clear();
    super.destroy();
  }
};
Fisheye.defaultOptions = {
  trigger: "pointermove",
  r: 120,
  d: 1.5,
  maxD: 5,
  minD: 0,
  showDPercent: true,
  style: {},
  nodeStyle: { label: true },
  preventDefault: true
};

// node_modules/@antv/g6/esm/plugins/fullscreen/index.js
var Fullscreen = class _Fullscreen extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, _Fullscreen.defaultOptions, options));
    this.$el = this.context.canvas.getContainer();
    this.graphSize = [0, 0];
    this.onFullscreenChange = () => {
      var _a, _b, _c, _d;
      const isFull = !!document.fullscreenElement;
      if (this.options.autoFit)
        this.setGraphSize(isFull);
      if (isFull) {
        (_b = (_a = this.options).onEnter) === null || _b === void 0 ? void 0 : _b.call(_a);
      } else {
        (_d = (_c = this.options).onExit) === null || _d === void 0 ? void 0 : _d.call(_c);
      }
    };
    this.shortcut = new Shortcut(context.graph);
    this.bindEvents();
    this.style = document.createElement("style");
    document.head.appendChild(this.style);
    this.style.innerHTML = `
      :not(:root):fullscreen::backdrop {
        background: transparent;
      }
    `;
  }
  bindEvents() {
    this.unbindEvents();
    this.shortcut.unbindAll();
    const { request = [], exit = [] } = this.options.trigger;
    this.shortcut.bind(request, this.request);
    this.shortcut.bind(exit, this.exit);
    const events = ["webkitfullscreenchange", "mozfullscreenchange", "fullscreenchange", "MSFullscreenChange"];
    events.forEach((eventName) => {
      document.addEventListener(eventName, this.onFullscreenChange, false);
    });
  }
  unbindEvents() {
    this.shortcut.unbindAll();
    const events = ["webkitfullscreenchange", "mozfullscreenchange", "fullscreenchange", "MSFullscreenChange"];
    events.forEach((eventName) => {
      document.removeEventListener(eventName, this.onFullscreenChange, false);
    });
  }
  setGraphSize(fullScreen = true) {
    var _a, _b;
    let width2, height;
    if (fullScreen) {
      width2 = ((_a = globalThis.screen) === null || _a === void 0 ? void 0 : _a.width) || 0;
      height = ((_b = globalThis.screen) === null || _b === void 0 ? void 0 : _b.height) || 0;
      this.graphSize = this.context.graph.getSize();
    } else {
      [width2, height] = this.graphSize;
    }
    this.context.graph.setSize(width2, height);
    this.context.graph.render();
  }
  /**
   * <zh/> 
   *
   * <en/> Request full screen
   */
  request() {
    if (document.fullscreenElement || !isFullscreenEnabled())
      return;
    this.$el.requestFullscreen().catch((err) => {
      print.warn(`Error attempting to enable full-screen: ${err.message} (${err.name})`);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Exit full screen
   */
  exit() {
    if (!document.fullscreenElement)
      return;
    document.exitFullscreen();
  }
  /**
   * <zh/> 
   *
   * <en/> Update options
   * @param options - <zh/>  | <en/> Options
   * @internal
   */
  update(options) {
    this.unbindEvents();
    super.update(options);
    this.bindEvents();
  }
  destroy() {
    this.exit();
    this.style.remove();
    super.destroy();
  }
};
Fullscreen.defaultOptions = {
  trigger: {},
  autoFit: true
};
function isFullscreenEnabled() {
  return document.fullscreenEnabled || // <zh/>  Reflect  ts  | <en/> use Reflect to avoid ts checking
  Reflect.get(document, "webkitFullscreenEnabled") || Reflect.get(document, "mozFullscreenEnabled") || Reflect.get(document, "msFullscreenEnabled");
}

// node_modules/@antv/g6/esm/plugins/grid-line.js
var GridLine = class _GridLine extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, _GridLine.defaultOptions, options));
    this.$element = createPluginContainer("grid-line", true);
    this.offset = [0, 0];
    this.currentScale = 1;
    this.followZoom = (event) => {
      const { data: { scale: scale2, origin } } = event;
      if (!scale2 || origin === void 0 && this.context.viewport === void 0)
        return;
      const prevScale = this.currentScale;
      this.currentScale = scale2;
      const deltaScale = scale2 / prevScale;
      const positionOffset = multiply(origin || this.context.graph.getCanvasCenter(), 1 - deltaScale);
      const scaledSize = this.baseSize * scale2;
      const scaledOffset = multiply(this.offset, deltaScale);
      const modulatedOffset = mod(scaledOffset, scaledSize);
      const newOffset = add(modulatedOffset, positionOffset);
      this.$element.style.backgroundSize = `${scaledSize}px ${scaledSize}px`;
      this.$element.style.backgroundPosition = `${newOffset[0]}px ${newOffset[1]}px`;
      this.offset = mod(newOffset, scaledSize);
    };
    this.followTranslate = (event) => {
      if (!this.options.follow)
        return;
      const { data: { translate } } = event;
      if (translate)
        this.updateOffset(translate);
    };
    this.onTransform = (event) => {
      const follow = this.parseFollow(this.options.follow);
      if (follow.zoom)
        this.followZoom(event);
      if (follow.translate)
        this.followTranslate(event);
    };
    const $container = this.context.canvas.getContainer();
    $container.prepend(this.$element);
    this.baseSize = this.options.size;
    this.updateStyle();
    this.bindEvents();
  }
  /**
   * <zh/> 
   *
   * <en/> Update the configuration of the grid line
   * @param options - <zh/>  | <en/> options
   * @internal
   */
  update(options) {
    super.update(options);
    if (options.size !== void 0) {
      this.baseSize = options.size;
    }
    this.updateStyle();
  }
  bindEvents() {
    const { graph } = this.context;
    graph.on(GraphEvent.AFTER_TRANSFORM, this.onTransform);
  }
  updateStyle() {
    const { stroke, lineWidth, border, borderLineWidth, borderStroke, borderStyle } = this.options;
    const scaledSize = this.baseSize * this.currentScale;
    Object.assign(this.$element.style, {
      border: border ? `${borderLineWidth}px ${borderStyle} ${borderStroke}` : "none",
      backgroundImage: `linear-gradient(${stroke} ${lineWidth}px, transparent ${lineWidth}px), linear-gradient(90deg, ${stroke} ${lineWidth}px, transparent ${lineWidth}px)`,
      backgroundSize: `${scaledSize}px ${scaledSize}px`,
      backgroundRepeat: "repeat"
    });
  }
  updateOffset(delta) {
    const scaledSize = this.baseSize * this.currentScale;
    this.offset = mod(add(this.offset, delta), scaledSize);
    this.$element.style.backgroundPosition = `${this.offset[0]}px ${this.offset[1]}px`;
  }
  parseFollow(follow) {
    var _a, _b;
    return is_boolean_default(follow) ? { translate: follow, zoom: follow } : { translate: (_a = follow === null || follow === void 0 ? void 0 : follow.translate) !== null && _a !== void 0 ? _a : false, zoom: (_b = follow === null || follow === void 0 ? void 0 : follow.zoom) !== null && _b !== void 0 ? _b : false };
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy the grid line
   * @internal
   */
  destroy() {
    this.context.graph.off(GraphEvent.AFTER_TRANSFORM, this.onTransform);
    this.$element.remove();
    super.destroy();
  }
};
GridLine.defaultOptions = {
  border: true,
  borderLineWidth: 1,
  borderStroke: "#eee",
  borderStyle: "solid",
  lineWidth: 1,
  size: 20,
  stroke: "#eee"
};

// node_modules/@antv/g6/esm/utils/change.js
function reduceDataChanges(changes) {
  const results = {
    Added: /* @__PURE__ */ new Map(),
    Updated: /* @__PURE__ */ new Map(),
    Removed: /* @__PURE__ */ new Map()
  };
  changes.forEach((change) => {
    const { type, value } = change;
    const id = idOf(value);
    if (type === "NodeAdded" || type === "EdgeAdded" || type === "ComboAdded") {
      results.Added.set(id, change);
    } else if (type === "NodeUpdated" || type === "EdgeUpdated" || type === "ComboUpdated") {
      if (results.Added.has(id)) {
        results.Added.set(id, { type: type.replace("Updated", "Added"), value });
      } else if (results.Updated.has(id)) {
        const { original } = results.Updated.get(id);
        results.Updated.set(id, { type, value, original });
      } else if (results.Removed.has(id)) {
      } else
        results.Updated.set(id, change);
    } else if (type === "NodeRemoved" || type === "EdgeRemoved" || type === "ComboRemoved") {
      if (results.Added.has(id)) {
        results.Added.delete(id);
      } else if (results.Updated.has(id)) {
        results.Updated.delete(id);
        results.Removed.set(id, change);
      } else {
        results.Removed.set(id, change);
      }
    }
  });
  return [
    ...Array.from(results.Added.values()),
    ...Array.from(results.Updated.values()),
    ...Array.from(results.Removed.values())
  ];
}
function groupByChangeType(changes) {
  const { NodeAdded = [], NodeUpdated = [], NodeRemoved = [], EdgeAdded = [], EdgeUpdated = [], EdgeRemoved = [], ComboAdded = [], ComboUpdated = [], ComboRemoved = [] } = group_by_default(changes, (change) => change.type);
  return {
    add: {
      nodes: NodeAdded,
      edges: EdgeAdded,
      combos: ComboAdded
    },
    update: {
      nodes: NodeUpdated,
      edges: EdgeUpdated,
      combos: ComboUpdated
    },
    remove: {
      nodes: NodeRemoved,
      edges: EdgeRemoved,
      combos: ComboRemoved
    }
  };
}

// node_modules/@antv/g6/esm/plugins/history/util.js
function alignFields(refObject, targetObject) {
  for (const key in refObject) {
    if (is_object_default(refObject[key]) && !Array.isArray(refObject[key]) && refObject[key] !== null) {
      if (!targetObject[key])
        targetObject[key] = {};
      alignFields(refObject[key], targetObject[key]);
    } else if (targetObject[key] === void 0) {
      targetObject[key] = inferDefaultValue(key);
    }
  }
}
function parseCommand(changes, animation = false, context) {
  const cmd = {
    animation,
    current: { add: {}, update: {}, remove: {} },
    original: { add: {}, update: {}, remove: {} }
  };
  const { add: add4, update, remove } = groupByChangeType(reduceDataChanges(changes));
  ["nodes", "edges", "combos"].forEach((category) => {
    if (update[category]) {
      update[category].forEach((item) => {
        var _a, _b;
        const newValue = Object.assign({}, item.value);
        let newOriginal = Object.assign({}, item.original);
        if (context) {
          const itemType = context.graph.getElementType(idOf(item.original));
          const colorKey = itemType === "edge" ? "stroke" : "fill";
          const style = context.element.getElementComputedStyle(itemType, item.original);
          newOriginal = Object.assign(Object.assign({}, item.original), { style: Object.assign({ [colorKey]: style[colorKey] }, item.original.style) });
        }
        alignFields(newValue, newOriginal);
        (_a = cmd.current.update)[category] || (_a[category] = []);
        cmd.current.update[category].push(newValue);
        (_b = cmd.original.update)[category] || (_b[category] = []);
        cmd.original.update[category].push(newOriginal);
      });
    }
    if (add4[category]) {
      add4[category].forEach((item) => {
        var _a, _b;
        const newValue = Object.assign({}, item.value);
        (_a = cmd.current.add)[category] || (_a[category] = []);
        cmd.current.add[category].push(newValue);
        (_b = cmd.original.remove)[category] || (_b[category] = []);
        cmd.original.remove[category].push(newValue);
      });
    }
    if (remove[category]) {
      remove[category].forEach((item) => {
        var _a, _b;
        const newValue = Object.assign({}, item.value);
        (_a = cmd.current.remove)[category] || (_a[category] = []);
        cmd.current.remove[category].push(newValue);
        (_b = cmd.original.add)[category] || (_b[category] = []);
        cmd.original.add[category].push(newValue);
      });
    }
  });
  return cmd;
}

// node_modules/@antv/g6/esm/plugins/history/index.js
var History2 = class _History extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, _History.defaultOptions, options));
    this.batchChanges = null;
    this.batchAnimation = false;
    this.undoStack = [];
    this.redoStack = [];
    this.freezed = false;
    this.executeCommand = (cmd, revert = true) => {
      var _a, _b, _c;
      this.freezed = true;
      (_b = (_a = this.options).executeCommand) === null || _b === void 0 ? void 0 : _b.call(_a, cmd);
      const values3 = revert ? cmd.original : cmd.current;
      this.context.graph.addData(values3.add);
      this.context.graph.updateData(values3.update);
      this.context.graph.removeData(idsOf(values3.remove, false));
      (_c = this.context.element) === null || _c === void 0 ? void 0 : _c.draw({ silence: true, animation: cmd.animation });
      this.freezed = false;
    };
    this.addCommand = (event) => {
      var _a;
      if (this.freezed)
        return;
      if (event.type === GraphEvent.AFTER_DRAW) {
        const { dataChanges = [], animation = true } = event.data;
        if ((_a = this.context.batch) === null || _a === void 0 ? void 0 : _a.isBatching) {
          if (!this.batchChanges)
            return;
          this.batchChanges.push(dataChanges);
          this.batchAnimation && (this.batchAnimation = animation);
          return;
        }
        this.batchChanges = [dataChanges];
        this.batchAnimation = animation;
      }
      this.undoStackPush(parseCommand(this.batchChanges.flat(), this.batchAnimation, this.context));
      this.notify(HistoryEvent.ADD, this.undoStack[this.undoStack.length - 1]);
    };
    this.initBatchCommand = (event) => {
      const { initiate } = event.data;
      this.batchAnimation = false;
      if (initiate) {
        this.batchChanges = [];
      } else {
        const cmd = this.undoStack.pop();
        if (!cmd)
          this.batchChanges = null;
      }
    };
    this.emitter = new esm_default();
    const { graph } = this.context;
    graph.on(GraphEvent.AFTER_DRAW, this.addCommand);
    graph.on(GraphEvent.BATCH_START, this.initBatchCommand);
    graph.on(GraphEvent.BATCH_END, this.addCommand);
  }
  /**
   * <zh/> 
   *
   * <en/> Whether undo can be done
   * @returns <zh/>  | <en/> Whether undo can be done
   */
  canUndo() {
    return this.undoStack.length > 0;
  }
  /**
   * <zh/> 
   *
   * <en/> Whether redo can be done
   * @returns <zh/>  | <en/> Whether redo can be done
   */
  canRedo() {
    return this.redoStack.length > 0;
  }
  /**
   * <zh/> 
   *
   * <en/> Execute undo
   * @returns <zh/>  | <en/> Return the current instance
   */
  undo() {
    var _a, _b, _c, _d;
    const cmd = this.undoStack.pop();
    if (cmd) {
      this.executeCommand(cmd);
      const before = (_b = (_a = this.options).beforeAddCommand) === null || _b === void 0 ? void 0 : _b.call(_a, cmd, false);
      if (before === false)
        return;
      this.redoStack.push(cmd);
      (_d = (_c = this.options).afterAddCommand) === null || _d === void 0 ? void 0 : _d.call(_c, cmd, false);
      this.notify(HistoryEvent.UNDO, cmd);
    }
    return this;
  }
  /**
   * <zh/> 
   *
   * <en/> Execute redo
   * @returns <zh/>  | <en/> Return the current instance
   */
  redo() {
    const cmd = this.redoStack.pop();
    if (cmd) {
      this.executeCommand(cmd, false);
      this.undoStackPush(cmd);
      this.notify(HistoryEvent.REDO, cmd);
    }
    return this;
  }
  /**
   * <zh/> 
   *
   * <en/> Execute undo and do not record in history
   * @returns <zh/>  | <en/> Return the current instance
   */
  undoAndCancel() {
    const cmd = this.undoStack.pop();
    if (cmd) {
      this.executeCommand(cmd, false);
      this.redoStack = [];
      this.notify(HistoryEvent.CANCEL, cmd);
    }
    return this;
  }
  undoStackPush(cmd) {
    var _a, _b, _c, _d;
    const { stackSize } = this.options;
    if (stackSize !== 0 && this.undoStack.length >= stackSize) {
      this.undoStack.shift();
    }
    const before = (_b = (_a = this.options).beforeAddCommand) === null || _b === void 0 ? void 0 : _b.call(_a, cmd, true);
    if (before === false)
      return;
    this.undoStack.push(cmd);
    (_d = (_c = this.options).afterAddCommand) === null || _d === void 0 ? void 0 : _d.call(_c, cmd, true);
  }
  /**
   * <zh/> 
   *
   * <en/> Clear history
   */
  clear() {
    this.undoStack = [];
    this.redoStack = [];
    this.batchChanges = null;
    this.batchAnimation = false;
    this.notify(HistoryEvent.CLEAR, null);
  }
  notify(event, cmd) {
    this.emitter.emit(event, { cmd });
    this.emitter.emit(HistoryEvent.CHANGE, { cmd });
  }
  /**
   * <zh/> 
   *
   * <en/> Listen to history events
   * @param event  - <zh/>  | <en/> Event name
   * @param handler - <zh/>  | <en/> Event handler
   */
  on(event, handler) {
    this.emitter.on(event, handler);
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy
   * @internal
   */
  destroy() {
    const { graph } = this.context;
    graph.off(GraphEvent.AFTER_DRAW, this.addCommand);
    graph.off(GraphEvent.BATCH_START, this.initBatchCommand);
    graph.off(GraphEvent.BATCH_END, this.addCommand);
    this.emitter.off();
    super.destroy();
    this.undoStack = [];
    this.redoStack = [];
  }
};
History2.defaultOptions = {
  stackSize: 0
};

// node_modules/@antv/g6/esm/plugins/hull/hull/format.js
var formatUtil = {
  toXy(pointset, format2) {
    if (!format2)
      return [...pointset];
    const xProperty = format2[0].slice(1);
    const yProperty = format2[1].slice(1);
    return pointset.map((pt2) => [pt2[xProperty], pt2[yProperty]]);
  },
  fromXy(coordinates, format2) {
    if (!format2)
      return [...coordinates];
    const xProperty = format2[0].slice(1);
    const yProperty = format2[1].slice(1);
    return coordinates.map(([x4, y4]) => ({
      [xProperty]: x4,
      [yProperty]: y4
    }));
  }
};

// node_modules/@antv/g6/esm/plugins/hull/hull/grid_handle.js
var Grid = class {
  constructor(points, cellSize) {
    this._cells = [];
    this._cellSize = cellSize;
    this._reverseCellSize = 1 / cellSize;
    for (const point3 of points) {
      const x4 = this.coordToCellNum(point3[0]);
      const y4 = this.coordToCellNum(point3[1]);
      if (!this._cells[x4]) {
        this._cells[x4] = [];
      }
      if (!this._cells[x4][y4]) {
        this._cells[x4][y4] = [];
      }
      this._cells[x4][y4].push(point3);
    }
  }
  cellPoints(x4, y4) {
    var _a;
    return ((_a = this._cells[x4]) === null || _a === void 0 ? void 0 : _a[y4]) || [];
  }
  rangePoints(bbox) {
    const tlCellX = this.coordToCellNum(bbox[0]);
    const tlCellY = this.coordToCellNum(bbox[1]);
    const brCellX = this.coordToCellNum(bbox[2]);
    const brCellY = this.coordToCellNum(bbox[3]);
    const points = [];
    for (let x4 = tlCellX; x4 <= brCellX; x4++) {
      for (let y4 = tlCellY; y4 <= brCellY; y4++) {
        const cell = this.cellPoints(x4, y4);
        for (const point3 of cell) {
          points.push(point3);
        }
      }
    }
    return points;
  }
  removePoint(point3) {
    const cellX = this.coordToCellNum(point3[0]);
    const cellY = this.coordToCellNum(point3[1]);
    const cell = this._cells[cellX][cellY];
    const index = cell.findIndex(([px, py]) => px === point3[0] && py === point3[1]);
    if (index > -1) {
      cell.splice(index, 1);
    }
    return cell;
  }
  trunc(val) {
    return Math.trunc(val);
  }
  coordToCellNum(x4) {
    return this.trunc(x4 * this._reverseCellSize);
  }
  extendBbox(bbox, scaleFactor) {
    return [
      bbox[0] - scaleFactor * this._cellSize,
      bbox[1] - scaleFactor * this._cellSize,
      bbox[2] + scaleFactor * this._cellSize,
      bbox[3] + scaleFactor * this._cellSize
    ];
  }
};
function grid(points, cellSize) {
  return new Grid(points, cellSize);
}

// node_modules/@antv/g6/esm/plugins/hull/hull/two-product.js
var SPLITTER = +(Math.pow(2, 27) + 1);
function twoProduct(a3, b3, result) {
  const x4 = a3 * b3;
  const c3 = SPLITTER * a3;
  const a_big = c3 - a3;
  const ahi = c3 - a_big;
  const alo = a3 - ahi;
  const d3 = SPLITTER * b3;
  const b_big = d3 - b3;
  const bhi = d3 - b_big;
  const blo = b3 - bhi;
  const err1 = x4 - ahi * bhi;
  const err2 = err1 - alo * bhi;
  const err3 = err2 - ahi * blo;
  const y4 = alo * blo - err3;
  if (result) {
    result[0] = y4;
    result[1] = x4;
    return result;
  }
  return [y4, x4];
}

// node_modules/@antv/g6/esm/plugins/hull/hull/two-sum.js
function fastTwoSum(a3, b3, result) {
  const x4 = a3 + b3;
  const bv = x4 - a3;
  const av = x4 - bv;
  const br = b3 - bv;
  const ar = a3 - av;
  if (result) {
    result[0] = ar + br;
    result[1] = x4;
    return result;
  }
  return [ar + br, x4];
}

// node_modules/@antv/g6/esm/plugins/hull/hull/robust-scale.js
function scaleLinearExpansion(e2, scale2) {
  const n2 = e2.length;
  if (n2 === 1) {
    const ts = twoProduct(e2[0], scale2);
    if (ts[0]) {
      return ts;
    }
    return [ts[1]];
  }
  const g3 = new Array(2 * n2);
  const q2 = [0.1, 0.1];
  const t3 = [0.1, 0.1];
  let count = 0;
  twoProduct(e2[0], scale2, q2);
  if (q2[0]) {
    g3[count++] = q2[0];
  }
  for (let i2 = 1; i2 < n2; ++i2) {
    twoProduct(e2[i2], scale2, t3);
    const pq = q2[1];
    fastTwoSum(pq, t3[0], q2);
    if (q2[0]) {
      g3[count++] = q2[0];
    }
    const a3 = t3[1];
    const b3 = q2[1];
    const x4 = a3 + b3;
    const bv = x4 - a3;
    const y4 = b3 - bv;
    q2[1] = x4;
    if (y4) {
      g3[count++] = y4;
    }
  }
  if (q2[1]) {
    g3[count++] = q2[1];
  }
  if (count === 0) {
    g3[count++] = 0;
  }
  g3.length = count;
  return g3;
}

// node_modules/@antv/g6/esm/plugins/hull/hull/robust-subtract.js
function scalarScalar(a3, b3) {
  const x4 = a3 + b3;
  const bv = x4 - a3;
  const av = x4 - bv;
  const br = b3 - bv;
  const ar = a3 - av;
  const y4 = ar + br;
  if (y4) {
    return [y4, x4];
  }
  return [x4];
}
function robustSubtract(e2, f3) {
  const ne2 = e2.length | 0;
  const nf = f3.length | 0;
  if (ne2 === 1 && nf === 1) {
    return scalarScalar(e2[0], -f3[0]);
  }
  const n2 = ne2 + nf;
  const g3 = new Array(n2);
  let count = 0;
  let ep_tr = 0;
  let fp_tr = 0;
  const abs = Math.abs;
  let ei = e2[ep_tr];
  let ea = abs(ei);
  let fi = -f3[fp_tr];
  let fa = abs(fi);
  let a3, b3;
  if (ea < fa) {
    b3 = ei;
    ep_tr += 1;
    if (ep_tr < ne2) {
      ei = e2[ep_tr];
      ea = abs(ei);
    }
  } else {
    b3 = fi;
    fp_tr += 1;
    if (fp_tr < nf) {
      fi = -f3[fp_tr];
      fa = abs(fi);
    }
  }
  if (ep_tr < ne2 && ea < fa || fp_tr >= nf) {
    a3 = ei;
    ep_tr += 1;
    if (ep_tr < ne2) {
      ei = e2[ep_tr];
      ea = abs(ei);
    }
  } else {
    a3 = fi;
    fp_tr += 1;
    if (fp_tr < nf) {
      fi = -f3[fp_tr];
      fa = abs(fi);
    }
  }
  let x4 = a3 + b3;
  let bv = x4 - a3;
  let y4 = b3 - bv;
  let q0 = y4;
  let q1 = x4;
  let _x, _bv, _av, _br, _ar;
  while (ep_tr < ne2 && fp_tr < nf) {
    if (ea < fa) {
      a3 = ei;
      ep_tr += 1;
      if (ep_tr < ne2) {
        ei = e2[ep_tr];
        ea = abs(ei);
      }
    } else {
      a3 = fi;
      fp_tr += 1;
      if (fp_tr < nf) {
        fi = -f3[fp_tr];
        fa = abs(fi);
      }
    }
    b3 = q0;
    x4 = a3 + b3;
    bv = x4 - a3;
    y4 = b3 - bv;
    if (y4) {
      g3[count++] = y4;
    }
    _x = q1 + x4;
    _bv = _x - q1;
    _av = _x - _bv;
    _br = x4 - _bv;
    _ar = q1 - _av;
    q0 = _ar + _br;
    q1 = _x;
  }
  while (ep_tr < ne2) {
    a3 = ei;
    b3 = q0;
    x4 = a3 + b3;
    bv = x4 - a3;
    y4 = b3 - bv;
    if (y4) {
      g3[count++] = y4;
    }
    _x = q1 + x4;
    _bv = _x - q1;
    _av = _x - _bv;
    _br = x4 - _bv;
    _ar = q1 - _av;
    q0 = _ar + _br;
    q1 = _x;
    ep_tr += 1;
    if (ep_tr < ne2) {
      ei = e2[ep_tr];
    }
  }
  while (fp_tr < nf) {
    a3 = fi;
    b3 = q0;
    x4 = a3 + b3;
    bv = x4 - a3;
    y4 = b3 - bv;
    if (y4) {
      g3[count++] = y4;
    }
    _x = q1 + x4;
    _bv = _x - q1;
    _av = _x - _bv;
    _br = x4 - _bv;
    _ar = q1 - _av;
    q0 = _ar + _br;
    q1 = _x;
    fp_tr += 1;
    if (fp_tr < nf) {
      fi = -f3[fp_tr];
    }
  }
  if (q0) {
    g3[count++] = q0;
  }
  if (q1) {
    g3[count++] = q1;
  }
  if (!count) {
    g3[count++] = 0;
  }
  g3.length = count;
  return g3;
}

// node_modules/@antv/g6/esm/plugins/hull/hull/robust-sum.js
function scalarScalar2(a3, b3) {
  const x4 = a3 + b3;
  const bv = x4 - a3;
  const av = x4 - bv;
  const br = b3 - bv;
  const ar = a3 - av;
  const y4 = ar + br;
  if (y4) {
    return [y4, x4];
  }
  return [x4];
}
function linearExpansionSum(e2, f3) {
  const ne2 = e2.length | 0;
  const nf = f3.length | 0;
  if (ne2 === 1 && nf === 1) {
    return scalarScalar2(e2[0], f3[0]);
  }
  const n2 = ne2 + nf;
  const g3 = new Array(n2);
  let count = 0;
  let ep_tr = 0;
  let fp_tr = 0;
  const abs = Math.abs;
  let ei = e2[ep_tr];
  let ea = abs(ei);
  let fi = f3[fp_tr];
  let fa = abs(fi);
  let a3, b3;
  if (ea < fa) {
    b3 = ei;
    ep_tr += 1;
    if (ep_tr < ne2) {
      ei = e2[ep_tr];
      ea = abs(ei);
    }
  } else {
    b3 = fi;
    fp_tr += 1;
    if (fp_tr < nf) {
      fi = f3[fp_tr];
      fa = abs(fi);
    }
  }
  if (ep_tr < ne2 && ea < fa || fp_tr >= nf) {
    a3 = ei;
    ep_tr += 1;
    if (ep_tr < ne2) {
      ei = e2[ep_tr];
      ea = abs(ei);
    }
  } else {
    a3 = fi;
    fp_tr += 1;
    if (fp_tr < nf) {
      fi = f3[fp_tr];
      fa = abs(fi);
    }
  }
  let x4 = a3 + b3;
  let bv = x4 - a3;
  let y4 = b3 - bv;
  let q0 = y4;
  let q1 = x4;
  let _x, _bv, _av, _br, _ar;
  while (ep_tr < ne2 && fp_tr < nf) {
    if (ea < fa) {
      a3 = ei;
      ep_tr += 1;
      if (ep_tr < ne2) {
        ei = e2[ep_tr];
        ea = abs(ei);
      }
    } else {
      a3 = fi;
      fp_tr += 1;
      if (fp_tr < nf) {
        fi = f3[fp_tr];
        fa = abs(fi);
      }
    }
    b3 = q0;
    x4 = a3 + b3;
    bv = x4 - a3;
    y4 = b3 - bv;
    if (y4) {
      g3[count++] = y4;
    }
    _x = q1 + x4;
    _bv = _x - q1;
    _av = _x - _bv;
    _br = x4 - _bv;
    _ar = q1 - _av;
    q0 = _ar + _br;
    q1 = _x;
  }
  while (ep_tr < ne2) {
    a3 = ei;
    b3 = q0;
    x4 = a3 + b3;
    bv = x4 - a3;
    y4 = b3 - bv;
    if (y4) {
      g3[count++] = y4;
    }
    _x = q1 + x4;
    _bv = _x - q1;
    _av = _x - _bv;
    _br = x4 - _bv;
    _ar = q1 - _av;
    q0 = _ar + _br;
    q1 = _x;
    ep_tr += 1;
    if (ep_tr < ne2) {
      ei = e2[ep_tr];
    }
  }
  while (fp_tr < nf) {
    a3 = fi;
    b3 = q0;
    x4 = a3 + b3;
    bv = x4 - a3;
    y4 = b3 - bv;
    if (y4) {
      g3[count++] = y4;
    }
    _x = q1 + x4;
    _bv = _x - q1;
    _av = _x - _bv;
    _br = x4 - _bv;
    _ar = q1 - _av;
    q0 = _ar + _br;
    q1 = _x;
    fp_tr += 1;
    if (fp_tr < nf) {
      fi = f3[fp_tr];
    }
  }
  if (q0) {
    g3[count++] = q0;
  }
  if (q1) {
    g3[count++] = q1;
  }
  if (!count) {
    g3[count++] = 0;
  }
  g3.length = count;
  return g3;
}

// node_modules/@antv/g6/esm/plugins/hull/hull/robust-orientation.js
var NUM_EXPAND = 5;
var EPSILON = 11102230246251565e-32;
var ERR_BOUND_3 = (3 + 16 * EPSILON) * EPSILON;
var ERR_BOUND_4 = (7 + 56 * EPSILON) * EPSILON;
function orientation_3(sum, prod, scale2, sub) {
  return function orientation3Exact2(m0, m1, m2) {
    const p3 = sum(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])));
    const n2 = sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0]));
    const d3 = sub(p3, n2);
    return d3[d3.length - 1];
  };
}
function orientation_4(sum, prod, scale2, sub) {
  return function orientation4Exact2(m0, m1, m2, m3) {
    const p3 = sum(sum(scale2(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale2(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale2(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), sum(scale2(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale2(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale2(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))));
    const n2 = sum(sum(scale2(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale2(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale2(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), sum(scale2(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale2(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale2(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))));
    const d3 = sub(p3, n2);
    return d3[d3.length - 1];
  };
}
function orientation_5(sum, prod, scale2, sub) {
  return function orientation5Exact(m0, m1, m2, m3, m4) {
    const p3 = sum(sum(sum(scale2(sum(scale2(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m2[2]), sum(scale2(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), -m3[2]), scale2(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m4[2]))), m1[3]), sum(scale2(sum(scale2(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m1[2]), sum(scale2(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m3[2]), scale2(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m4[2]))), -m2[3]), scale2(sum(scale2(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m1[2]), sum(scale2(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m2[2]), scale2(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m4[2]))), m3[3]))), sum(scale2(sum(scale2(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale2(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale2(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), -m4[3]), sum(scale2(sum(scale2(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m1[2]), sum(scale2(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m3[2]), scale2(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m4[2]))), m0[3]), scale2(sum(scale2(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m0[2]), sum(scale2(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m3[2]), scale2(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), m4[2]))), -m1[3])))), sum(sum(scale2(sum(scale2(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), m0[2]), sum(scale2(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m1[2]), scale2(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m4[2]))), m3[3]), sum(scale2(sum(scale2(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale2(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale2(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))), -m4[3]), scale2(sum(scale2(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale2(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale2(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), m0[3]))), sum(scale2(sum(scale2(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale2(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale2(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), -m1[3]), sum(scale2(sum(scale2(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale2(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale2(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))), m2[3]), scale2(sum(scale2(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale2(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale2(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))), -m3[3])))));
    const n2 = sum(sum(sum(scale2(sum(scale2(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m2[2]), sum(scale2(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), -m3[2]), scale2(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m4[2]))), m0[3]), scale2(sum(scale2(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m0[2]), sum(scale2(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m3[2]), scale2(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), m4[2]))), -m2[3])), sum(scale2(sum(scale2(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m0[2]), sum(scale2(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m2[2]), scale2(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m4[2]))), m3[3]), scale2(sum(scale2(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale2(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale2(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), -m4[3]))), sum(sum(scale2(sum(scale2(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m1[2]), sum(scale2(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m2[2]), scale2(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m4[2]))), m0[3]), scale2(sum(scale2(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m0[2]), sum(scale2(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m2[2]), scale2(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m4[2]))), -m1[3])), sum(scale2(sum(scale2(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), m0[2]), sum(scale2(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m1[2]), scale2(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m4[2]))), m2[3]), scale2(sum(scale2(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale2(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale2(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))), -m4[3]))));
    const d3 = sub(p3, n2);
    return d3[d3.length - 1];
  };
}
function orientation(n2) {
  const fn = n2 === 3 ? orientation_3 : n2 === 4 ? orientation_4 : orientation_5;
  return fn(linearExpansionSum, twoProduct, scaleLinearExpansion, robustSubtract);
}
var orientation3Exact = orientation(3);
var orientation4Exact = orientation(4);
var CACHED = [
  function orientation0() {
    return 0;
  },
  function orientation1() {
    return 0;
  },
  function orientation2(a3, b3) {
    return b3[0] - a3[0];
  },
  function orientation3(a3, b3, c3) {
    const l3 = (a3[1] - c3[1]) * (b3[0] - c3[0]);
    const r3 = (a3[0] - c3[0]) * (b3[1] - c3[1]);
    const det = l3 - r3;
    let s2;
    if (l3 > 0) {
      if (r3 <= 0) {
        return det;
      } else {
        s2 = l3 + r3;
      }
    } else if (l3 < 0) {
      if (r3 >= 0) {
        return det;
      } else {
        s2 = -(l3 + r3);
      }
    } else {
      return det;
    }
    const tol = ERR_BOUND_3 * s2;
    if (det >= tol || det <= -tol) {
      return det;
    }
    return orientation3Exact(a3, b3, c3);
  },
  function orientation4(a3, b3, c3, d3) {
    const adx = a3[0] - d3[0];
    const bdx = b3[0] - d3[0];
    const cdx = c3[0] - d3[0];
    const ady = a3[1] - d3[1];
    const bdy = b3[1] - d3[1];
    const cdy = c3[1] - d3[1];
    const adz = a3[2] - d3[2];
    const bdz = b3[2] - d3[2];
    const cdz = c3[2] - d3[2];
    const bdx_cdy = bdx * cdy;
    const cdx_bdy = cdx * bdy;
    const cdx_ady = cdx * ady;
    const adx_cdy = adx * cdy;
    const adx_bdy = adx * bdy;
    const bdx_ady = bdx * ady;
    const det = adz * (bdx_cdy - cdx_bdy) + bdz * (cdx_ady - adx_cdy) + cdz * (adx_bdy - bdx_ady);
    const permanent = (Math.abs(bdx_cdy) + Math.abs(cdx_bdy)) * Math.abs(adz) + (Math.abs(cdx_ady) + Math.abs(adx_cdy)) * Math.abs(bdz) + (Math.abs(adx_bdy) + Math.abs(bdx_ady)) * Math.abs(cdz);
    const tol = ERR_BOUND_4 * permanent;
    if (det > tol || -det > tol) {
      return det;
    }
    return orientation4Exact(a3, b3, c3, d3);
  }
];
function slowOrient(args) {
  let proc2 = CACHED[args.length];
  if (!proc2) {
    proc2 = CACHED[args.length] = orientation(args.length);
  }
  return proc2.apply(void 0, ...args);
}
function proc(slow, o0, o1, o22, o3, o4, o5) {
  return function getOrientation(...args) {
    switch (args.length) {
      case 0:
      case 1:
        return 0;
      case 2:
        return o22(args[0], args[1]);
      case 3:
        return o3(args[0], args[1], args[2]);
      case 4:
        return o4(args[0], args[1], args[2], args[3]);
      case 5:
        return o5(args[0], args[1], args[2], args[3], args[4]);
    }
    return slow(args);
  };
}
function generateOrientationProc() {
  while (CACHED.length <= NUM_EXPAND) {
    CACHED.push(orientation(CACHED.length));
  }
  const orientationProc = proc(void 0, slowOrient, ...CACHED);
  for (let i2 = 0; i2 <= NUM_EXPAND; ++i2) {
    orientationProc[i2] = CACHED[i2];
  }
  return orientationProc;
}
var robust_orientation_default = generateOrientationProc();

// node_modules/@antv/g6/esm/plugins/hull/hull/monotone-convex-hull-2d.js
var orient = robust_orientation_default[3];
function monotoneConvexHull2D(points) {
  const n2 = points.length;
  if (n2 < 3) {
    const result2 = new Array(n2);
    for (let i2 = 0; i2 < n2; ++i2) {
      result2[i2] = i2;
    }
    if (n2 === 2 && points[0][0] === points[1][0] && points[0][1] === points[1][1]) {
      return [0];
    }
    return result2;
  }
  const sorted = new Array(n2);
  for (let i2 = 0; i2 < n2; ++i2) {
    sorted[i2] = i2;
  }
  sorted.sort((a3, b3) => {
    const d3 = points[a3][0] - points[b3][0];
    if (d3) {
      return d3;
    }
    return points[a3][1] - points[b3][1];
  });
  const lower2 = [sorted[0], sorted[1]];
  const upper2 = [sorted[0], sorted[1]];
  for (let i2 = 2; i2 < n2; ++i2) {
    const idx = sorted[i2];
    const p3 = points[idx];
    let m2 = lower2.length;
    while (m2 > 1 && orient(points[lower2[m2 - 2]], points[lower2[m2 - 1]], p3) <= 0) {
      m2 -= 1;
      lower2.pop();
    }
    lower2.push(idx);
    m2 = upper2.length;
    while (m2 > 1 && orient(points[upper2[m2 - 2]], points[upper2[m2 - 1]], p3) >= 0) {
      m2 -= 1;
      upper2.pop();
    }
    upper2.push(idx);
  }
  const result = new Array(upper2.length + lower2.length - 2);
  let ptr = 0;
  for (let i2 = 0, nl = lower2.length; i2 < nl; ++i2) {
    result[ptr++] = lower2[i2];
  }
  for (let j2 = upper2.length - 2; j2 > 0; --j2) {
    result[ptr++] = upper2[j2];
  }
  return result;
}

// node_modules/@antv/g6/esm/plugins/hull/hull/robust-segment-intersect.js
function checkCollinear(a0, a1, b0, b1) {
  for (let d3 = 0; d3 < 2; ++d3) {
    const x0 = a0[d3];
    const y0 = a1[d3];
    const [l0, h0] = [Math.min(x0, y0), Math.max(x0, y0)];
    const x1 = b0[d3];
    const y1 = b1[d3];
    const [l1, h1] = [Math.min(x1, y1), Math.max(x1, y1)];
    if (h1 < l0 || h0 < l1)
      return false;
  }
  return true;
}
function segmentsIntersect(a0, a1, b0, b1) {
  const x0 = robust_orientation_default(a0, b0, b1);
  const y0 = robust_orientation_default(a1, b0, b1);
  if (x0 > 0 && y0 > 0 || x0 < 0 && y0 < 0)
    return false;
  const x1 = robust_orientation_default(b0, a0, a1);
  const y1 = robust_orientation_default(b1, a0, a1);
  if (x1 > 0 && y1 > 0 || x1 < 0 && y1 < 0)
    return false;
  if (x0 === 0 && y0 === 0 && x1 === 0 && y1 === 0) {
    return checkCollinear(a0, a1, b0, b1);
  }
  return true;
}

// node_modules/@antv/g6/esm/plugins/hull/hull/index.js
function _filterDuplicates(pointset) {
  const unique = [pointset[0]];
  let lastPoint = pointset[0];
  for (let i2 = 1; i2 < pointset.length; i2++) {
    const currentPoint = pointset[i2];
    if (lastPoint[0] !== currentPoint[0] || lastPoint[1] !== currentPoint[1]) {
      unique.push(currentPoint);
    }
    lastPoint = currentPoint;
  }
  return unique;
}
function _sortByX(pointset) {
  return pointset.sort(function(a3, b3) {
    return a3[0] - b3[0] || a3[1] - b3[1];
  });
}
function _sqLength(a3, b3) {
  return Math.pow(b3[0] - a3[0], 2) + Math.pow(b3[1] - a3[1], 2);
}
function _cos(o3, a3, b3) {
  const aShifted = [a3[0] - o3[0], a3[1] - o3[1]], bShifted = [b3[0] - o3[0], b3[1] - o3[1]], sqALen = _sqLength(o3, a3), sqBLen = _sqLength(o3, b3), dot2 = aShifted[0] * bShifted[0] + aShifted[1] * bShifted[1];
  return dot2 / Math.sqrt(sqALen * sqBLen);
}
function _intersect(segment, pointset) {
  for (let i2 = 0; i2 < pointset.length - 1; i2++) {
    const seg = [pointset[i2], pointset[i2 + 1]];
    if (segment[0][0] === seg[0][0] && segment[0][1] === seg[0][1] || segment[0][0] === seg[1][0] && segment[0][1] === seg[1][1]) {
      continue;
    }
    if (segmentsIntersect(segment[0], segment[1], seg[0], seg[1])) {
      return true;
    }
  }
  return false;
}
function _occupiedArea(pointset) {
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  for (let i2 = pointset.length - 1; i2 >= 0; i2--) {
    if (pointset[i2][0] < minX) {
      minX = pointset[i2][0];
    }
    if (pointset[i2][1] < minY) {
      minY = pointset[i2][1];
    }
    if (pointset[i2][0] > maxX) {
      maxX = pointset[i2][0];
    }
    if (pointset[i2][1] > maxY) {
      maxY = pointset[i2][1];
    }
  }
  return [
    maxX - minX,
    // width
    maxY - minY
    // height
  ];
}
function _bBoxAround(edge) {
  return [
    Math.min(edge[0][0], edge[1][0]),
    // left
    Math.min(edge[0][1], edge[1][1]),
    // top
    Math.max(edge[0][0], edge[1][0]),
    // right
    Math.max(edge[0][1], edge[1][1])
    // bottom
  ];
}
function _midPoint(edge, innerPoints, convex) {
  let point3 = null, angle1Cos = MAX_CONCAVE_ANGLE_COS, angle2Cos = MAX_CONCAVE_ANGLE_COS, a1Cos, a2Cos;
  for (let i2 = 0; i2 < innerPoints.length; i2++) {
    a1Cos = _cos(edge[0], edge[1], innerPoints[i2]);
    a2Cos = _cos(edge[1], edge[0], innerPoints[i2]);
    if (a1Cos > angle1Cos && a2Cos > angle2Cos && !_intersect([edge[0], innerPoints[i2]], convex) && !_intersect([edge[1], innerPoints[i2]], convex)) {
      angle1Cos = a1Cos;
      angle2Cos = a2Cos;
      point3 = innerPoints[i2];
    }
  }
  return point3;
}
function _concave(convex, maxSqEdgeLen, maxSearchArea, grid2, edgeSkipList) {
  let midPointInserted = false;
  for (let i2 = 0; i2 < convex.length - 1; i2++) {
    const edge = [convex[i2], convex[i2 + 1]];
    const keyInSkipList = edge[0][0] + "," + edge[0][1] + "," + edge[1][0] + "," + edge[1][1];
    if (_sqLength(edge[0], edge[1]) < maxSqEdgeLen || edgeSkipList.has(keyInSkipList)) {
      continue;
    }
    let scaleFactor = 0;
    let bBoxAround = _bBoxAround(edge);
    let bBoxWidth;
    let bBoxHeight;
    let midPoint;
    do {
      bBoxAround = grid2.extendBbox(bBoxAround, scaleFactor);
      bBoxWidth = bBoxAround[2] - bBoxAround[0];
      bBoxHeight = bBoxAround[3] - bBoxAround[1];
      midPoint = _midPoint(edge, grid2.rangePoints(bBoxAround), convex);
      scaleFactor++;
    } while (midPoint === null && (maxSearchArea[0] > bBoxWidth || maxSearchArea[1] > bBoxHeight));
    if (bBoxWidth >= maxSearchArea[0] && bBoxHeight >= maxSearchArea[1]) {
      edgeSkipList.add(keyInSkipList);
    }
    if (midPoint !== null) {
      convex.splice(i2 + 1, 0, midPoint);
      grid2.removePoint(midPoint);
      midPointInserted = true;
    }
  }
  if (midPointInserted) {
    return _concave(convex, maxSqEdgeLen, maxSearchArea, grid2, edgeSkipList);
  }
  return convex;
}
function hull(pointset, concavity, format2) {
  const maxEdgeLen = concavity || 20;
  const points = _filterDuplicates(_sortByX(formatUtil.toXy(pointset, format2)));
  if (points.length < 4) {
    const concave2 = points.concat([points[0]]);
    return format2 ? formatUtil.fromXy(concave2, format2) : concave2;
  }
  const occupiedArea = _occupiedArea(points);
  const maxSearchArea = [
    occupiedArea[0] * MAX_SEARCH_BBOX_SIZE_PERCENT,
    occupiedArea[1] * MAX_SEARCH_BBOX_SIZE_PERCENT
  ];
  const convex = monotoneConvexHull2D(points).reverse().map((idx) => points[idx]);
  convex.push(convex[0]);
  const innerPoints = points.filter(function(pt2) {
    return convex.indexOf(pt2) < 0;
  });
  const cellSize = Math.ceil(1 / (points.length / (occupiedArea[0] * occupiedArea[1])));
  const concave = _concave(convex, Math.pow(maxEdgeLen, 2), maxSearchArea, grid(innerPoints, cellSize), /* @__PURE__ */ new Set());
  return format2 ? formatUtil.fromXy(concave, format2) : concave;
}
var MAX_CONCAVE_ANGLE_COS = Math.cos(90 / (180 / Math.PI));
var MAX_SEARCH_BBOX_SIZE_PERCENT = 0.6;

// node_modules/@antv/g6/esm/plugins/hull/util.js
function computeHullPath(points, padding, corner) {
  if (points.length === 1)
    return genSinglePointHullPath(points[0], padding, corner);
  if (points.length === 2)
    return genTwoPointsHullPath(points, padding, corner);
  if (points.length === 3) {
    const [p1, p22, p3] = sortByClockwise(points);
    if (isCollinear(p1, p22, p3))
      return genTwoPointsHullPath([p1, p3], padding, corner);
  }
  switch (corner) {
    case "smooth":
      return genMultiPointsSmoothHull(points, padding);
    case "sharp":
      return genMultiPointsSharpHull(points, padding);
    case "rounded":
    default:
      return genMultiPointsRoundedHull(points, padding);
  }
}
var genSinglePointHullPath = (point3, padding, corner) => {
  if (corner === "sharp")
    return [
      ["M", point3[0] - padding, point3[1] - padding],
      ["L", point3[0] + padding, point3[1] - padding],
      ["L", point3[0] + padding, point3[1] + padding],
      ["L", point3[0] - padding, point3[1] + padding],
      ["Z"]
    ];
  const arcData = [padding, padding, 0, 0, 0];
  return [
    ["M", point3[0], point3[1] - padding],
    ["A", ...arcData, point3[0], point3[1] + padding],
    ["A", ...arcData, point3[0], point3[1] - padding]
  ];
};
var genTwoPointsHullPath = (points, padding, corner) => {
  const arcData = [padding, padding, 0, 0, 0];
  const point1 = corner === "sharp" ? add(points[0], scale(normalize(subtract(points[0], points[1])), padding)) : points[0];
  const point22 = corner === "sharp" ? add(points[1], scale(normalize(subtract(points[1], points[0])), padding)) : points[1];
  const offsetVector = scale(normalize(perpendicular(subtract(point1, point22), false)), padding);
  const invOffsetVector = scale(offsetVector, -1);
  const prev = add(point1, offsetVector);
  const current2 = add(point22, offsetVector);
  const p22 = add(point22, invOffsetVector);
  const p3 = add(point1, invOffsetVector);
  if (corner === "sharp") {
    return [["M", prev[0], prev[1]], ["L", current2[0], current2[1]], ["L", p22[0], p22[1]], ["L", p3[0], p3[1]], ["Z"]];
  }
  return [
    ["M", prev[0], prev[1]],
    ["L", current2[0], current2[1]],
    ["A", ...arcData, p22[0], p22[1]],
    ["L", p3[0], p3[1]],
    ["A", ...arcData, prev[0], prev[1]]
  ];
};
var genMultiPointsRoundedHull = (points, padding) => {
  const segments = sortByClockwise(points).map((current2, i2) => {
    const prev2Index = (i2 - 2 + points.length) % points.length;
    const prevIndex = (i2 - 1 + points.length) % points.length;
    const nextIndex = (i2 + 1) % points.length;
    const prev2 = points[prev2Index];
    const prev = points[prevIndex];
    const next = points[nextIndex];
    const v0 = subtract(prev2, prev);
    const v1 = subtract(prev, current2);
    const v22 = subtract(current2, next);
    const isConcave = (v12, v23) => {
      return angle(v12, v23, true) < Math.PI;
    };
    const concavePrev = isConcave(v0, v1);
    const concaveNext = isConcave(v1, v22);
    const offsetVector = (v3) => scale(normalize(perpendicular(v3, false)), padding);
    const offset = offsetVector(v1);
    return [
      {
        p: toVector2(concavePrev ? add(prev, offsetVector(v0)) : add(prev, offset)),
        concave: concavePrev && prev
      },
      {
        p: toVector2(concaveNext ? add(current2, offsetVector(v22)) : add(current2, offset)),
        concave: concaveNext && current2
      }
    ];
  });
  const arcData = [padding, padding, 0, 0, 0];
  const startIndex = segments.findIndex((segment, i2) => !segments[(i2 - 1 + segments.length) % segments.length][0].concave && !segments[(i2 - 1 + segments.length) % segments.length][1].concave && !segment[0].concave && !segment[0].concave && !segment[1].concave);
  const sortedSegments = segments.slice(startIndex).concat(segments.slice(0, startIndex));
  let concavePoints = [];
  return sortedSegments.flatMap((segment, i2) => {
    const pathFragment = [];
    const lastSegment = sortedSegments[segments.length - 1];
    if (i2 === 0)
      pathFragment.push(["M", ...lastSegment[1].p]);
    if (!segment[0].concave) {
      pathFragment.push(["A", ...arcData, ...segment[0].p]);
    } else {
      concavePoints.push(segment[0].p, segment[1].p);
    }
    if (!segment[1].concave) {
      pathFragment.push(["L", ...segment[1].p]);
    } else {
      concavePoints.unshift(segment[1].p);
    }
    if (concavePoints.length === 3) {
      pathFragment.pop();
      pathFragment.push(["C", ...concavePoints.flat()]);
      concavePoints = [];
    }
    return pathFragment;
  });
};
var genMultiPointsSmoothHull = (points, padding) => {
  const hullPoints = sortByClockwise(points).map((p3, i2) => {
    const pNext = points[(i2 + 1) % points.length];
    return { p: p3, v: normalize(subtract(pNext, p3)) };
  });
  hullPoints.forEach((hp, i2) => {
    const priorIndex = i2 > 0 ? i2 - 1 : points.length - 1;
    const prevV = hullPoints[priorIndex].v;
    const extensionVec = normalize(add(prevV, scale(hp.v, angle(prevV, hp.v, true) < Math.PI ? 1 : -1)));
    hp.p = add(hp.p, scale(extensionVec, padding));
  });
  return getClosedSpline(hullPoints.map((obj) => obj.p));
};
var genMultiPointsSharpHull = (points, padding) => {
  const segments = points.map((current2, i2) => {
    const prev = points[i2 === 0 ? points.length - 1 : i2 - 1];
    const offset = toVector3(scale(normalize(perpendicular(subtract(prev, current2), false)), padding));
    return [add(prev, offset), add(current2, offset)];
  });
  const arr = segments.flat();
  const vertices = arr.map((_2, i2) => {
    if (i2 % 2 === 0)
      return null;
    const l1 = [arr[(i2 - 1) % arr.length], arr[i2 % arr.length]];
    const l22 = [arr[(i2 + 1) % arr.length], arr[(i2 + 2) % arr.length]];
    return getLinesIntersection(l1, l22, true);
  }).filter(Boolean);
  return vertices.map((point3, i2) => [i2 === 0 ? "M" : "L", point3[0], point3[1]]).concat([["Z"]]);
};

// node_modules/@antv/g6/esm/plugins/hull/index.js
var __rest16 = function(s2, e2) {
  var t3 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t3[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t3[p3[i2]] = s2[p3[i2]];
    }
  return t3;
};
var Hull = class _Hull extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, _Hull.defaultOptions, options));
    this.hullMemberIds = [];
    this.drawHull = () => {
      if (!this.shape) {
        this.shape = new Contour({ style: this.getHullStyle() });
        this.context.canvas.appendChild(this.shape);
      } else {
        const forceUpdate = !is_equal_default(this.optionsCache, this.options);
        this.shape.update(this.getHullStyle(forceUpdate));
      }
      this.optionsCache = Object.assign({}, this.options);
    };
    this.updateHullPath = (event) => {
      if (!this.shape)
        return;
      if (!this.options.members.includes(idOf(event.data)))
        return;
      this.shape.update({ d: this.getHullPath(true) });
    };
    this.getHullPath = (forceUpdate = false) => {
      const { graph } = this.context;
      const members = this.getMember();
      if (members.length === 0)
        return "";
      const data = members.map((id) => graph.getNodeData(id));
      const vertices = hull(data.map(positionOf), this.options.concavity).slice(1).reverse();
      const hullMemberIds = vertices.flatMap((point3) => data.filter((m2) => is_equal_default(positionOf(m2), point3)).map(idOf));
      if (is_equal_default(hullMemberIds, this.hullMemberIds) && !forceUpdate)
        return this.path;
      this.hullMemberIds = hullMemberIds;
      this.path = computeHullPath(vertices, this.getPadding(), this.options.corner);
      return this.path;
    };
    this.bindEvents();
  }
  bindEvents() {
    this.context.graph.on(GraphEvent.AFTER_RENDER, this.drawHull);
    this.context.graph.on(GraphEvent.AFTER_ELEMENT_UPDATE, this.updateHullPath);
  }
  unbindEvents() {
    this.context.graph.off(GraphEvent.AFTER_RENDER, this.drawHull);
    this.context.graph.off(GraphEvent.AFTER_ELEMENT_UPDATE, this.updateHullPath);
  }
  getHullStyle(forceUpdate) {
    const _a = this.options, { members, padding, corner } = _a, style = __rest16(_a, ["members", "padding", "corner"]);
    return Object.assign(Object.assign({}, style), { d: this.getHullPath(forceUpdate) });
  }
  getPadding() {
    const { graph } = this.context;
    const memberPadding = this.hullMemberIds.reduce((acc, id) => {
      const { halfExtents } = graph.getElementRenderBounds(id);
      const size2 = Math.max(halfExtents[0], halfExtents[1]);
      return Math.max(acc, size2);
    }, 0);
    return memberPadding + this.options.padding;
  }
  /**
   * <zh/>  Hull 
   *
   * <en/> Add Hull member
   * @param members - <zh/>  Ids | <en/> Element Ids
   */
  addMember(members) {
    const membersToAdd = Array.isArray(members) ? members : [members];
    this.options.members = [.../* @__PURE__ */ new Set([...this.options.members, ...membersToAdd])];
    this.shape.update({ d: this.getHullPath() });
  }
  /**
   * <zh/>  Hull 
   *
   * <en/> Remove Hull member
   * @param members - <zh/>  Ids | <en/> Element Ids
   */
  removeMember(members) {
    const membersToRemove = Array.isArray(members) ? members : [members];
    this.options.members = this.options.members.filter((id) => !membersToRemove.includes(id));
    if (membersToRemove.some((id) => this.hullMemberIds.includes(id))) {
      this.shape.update({ d: this.getHullPath() });
    }
  }
  /**
   * <zh/>  Hull 
   *
   * <en/> Update Hull member
   * @param members - <zh/>  Ids | <en/> Element Ids
   */
  updateMember(members) {
    this.options.members = isFunction(members) ? members(this.options.members) : members;
    this.shape.update(this.getHullStyle(true));
  }
  /**
   * <zh/>  Hull 
   *
   * <en/> Get Hull member
   * @returns <zh/>  Ids | <en/> Element Ids
   */
  getMember() {
    return this.options.members;
  }
  /**
   * <zh/>  Hull
   *
   * <en/> Destroy Hull
   * @internal
   */
  destroy() {
    this.unbindEvents();
    this.shape.destroy();
    this.hullMemberIds = [];
    super.destroy();
  }
};
Hull.defaultOptions = {
  members: [],
  padding: 10,
  corner: "rounded",
  concavity: Infinity,
  /** hull style */
  fill: "lightblue",
  fillOpacity: 0.2,
  labelOpacity: 1,
  stroke: "blue",
  strokeOpacity: 0.2
};

// node_modules/@antv/g6/esm/plugins/utils/canvas.js
function createPluginCanvas(options) {
  const { width: width2, height, renderer } = options;
  const $container = getContainer(options);
  const canvas2 = new Canvas({
    width: width2,
    height,
    container: $container,
    renderer: renderer || new Renderer()
  });
  return [$container, canvas2];
}
function getContainer(options) {
  var _a;
  const { container, className, graphCanvas } = options;
  if (container) {
    return typeof container === "string" ? document.getElementById(container) : container;
  }
  const $container = createPluginContainer(className, false);
  const { width: width2, height, containerStyle } = options;
  const [x4, y4] = computePosition(options);
  Object.assign($container.style, Object.assign({ position: "absolute", left: x4 + "px", top: y4 + "px", width: width2 + "px", height: height + "px" }, containerStyle));
  (_a = graphCanvas.getContainer()) === null || _a === void 0 ? void 0 : _a.appendChild($container);
  return $container;
}
function computePosition(options) {
  const { width: width2, height, placement, graphCanvas } = options;
  const [W3, H3] = graphCanvas.getSize();
  const [xRatio, yRatio] = parsePlacement(placement);
  return [xRatio * (W3 - width2), yRatio * (H3 - height)];
}

// node_modules/@antv/g6/esm/plugins/legend.js
var __rest17 = function(s2, e2) {
  var t3 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t3[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t3[p3[i2]] = s2[p3[i2]];
    }
  return t3;
};
var Legend = class _Legend extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, _Legend.defaultOptions, options));
    this.typePrefix = "__data__";
    this.draw = false;
    this.fieldMap = {
      node: /* @__PURE__ */ new Map(),
      edge: /* @__PURE__ */ new Map(),
      combo: /* @__PURE__ */ new Map()
    };
    this.selectedItems = [];
    this.bindEvents = () => {
      const { graph } = this.context;
      graph.on(GraphEvent.AFTER_DRAW, this.createElement);
    };
    this.changeState = (el, state) => {
      const { graph } = this.context;
      const { typePrefix } = this;
      const composeId = get_default(el, [typePrefix, "id"]);
      const category = get_default(el, [typePrefix, "style", "labelText"]);
      const [type] = composeId.split("__");
      const ids = this.fieldMap[type].get(category) || [];
      graph.setElementState(Object.fromEntries(ids === null || ids === void 0 ? void 0 : ids.map((id) => [id, state])));
    };
    this.click = (event) => {
      if (this.options.trigger === "hover")
        return;
      const composeId = get_default(event, [this.typePrefix, "id"]);
      if (!this.selectedItems.includes(composeId)) {
        this.selectedItems.push(composeId);
        this.changeState(event, "selected");
      } else {
        this.selectedItems = this.selectedItems.filter((item) => item !== composeId);
        this.changeState(event, []);
      }
    };
    this.mouseleave = (event) => {
      if (this.options.trigger === "click")
        return;
      this.selectedItems = [];
      this.changeState(event, []);
    };
    this.mouseenter = (event) => {
      if (this.options.trigger === "click")
        return;
      const composeId = get_default(event, [this.typePrefix, "id"]);
      if (!this.selectedItems.includes(composeId)) {
        this.selectedItems.push(composeId);
        this.changeState(event, "active");
      } else {
        this.selectedItems = this.selectedItems.filter((item) => item !== composeId);
      }
    };
    this.setFieldMap = (field, id, type) => {
      if (!field)
        return;
      const map = this.fieldMap[type];
      if (!map)
        return;
      if (!map.has(field)) {
        map.set(field, [id]);
      } else {
        const ids = map.get(field);
        if (ids) {
          ids.push(id);
          map.set(field, ids);
        }
      }
    };
    this.getEvents = () => {
      return {
        mouseenter: this.mouseenter,
        mouseleave: this.mouseleave,
        click: this.click
      };
    };
    this.getMarkerData = (field, elementType) => {
      if (!field)
        return [];
      const { model, element } = this.context;
      const { nodes, edges, combos } = model.getData();
      const items = {};
      const getField = (item) => {
        if (isFunction(field))
          return field(item);
        return field;
      };
      const defaultType = {
        node: "circle",
        edge: "line",
        combo: "rect"
      };
      const markerMapping = {
        circle: "circle",
        ellipse: "circle",
        //  components  ellipse
        image: "bowtie",
        rect: "square",
        star: "cross",
        triangle: "triangle",
        diamond: "diamond",
        cubic: "dot",
        line: "hyphen",
        polyline: "hyphen",
        quadratic: "hv",
        "cubic-horizontal": "hyphen",
        "cubic-vertical": "line"
      };
      const getElementStyle = (type, datum) => {
        const style = element === null || element === void 0 ? void 0 : element.getElementComputedStyle(type, datum);
        return style;
      };
      const getElementModel = (data, type) => {
        data.forEach((item) => {
          const { id } = item;
          const value = get_default(item, ["data", getField(item)]);
          const marker = (element === null || element === void 0 ? void 0 : element.getElementType(type, item)) || "circle";
          const style = getElementStyle(type, item);
          const color = (type === "edge" ? style === null || style === void 0 ? void 0 : style.stroke : style === null || style === void 0 ? void 0 : style.fill) || "#1783ff";
          if (id && value && value.replace(/\s+/g, "")) {
            this.setFieldMap(value, id, type);
            if (!items[value]) {
              items[value] = {
                id: `${type}__${id}`,
                label: value,
                marker: markerMapping[marker] || defaultType[type],
                elementType: type,
                lineWidth: 1,
                stroke: color,
                fill: color
              };
            }
          }
        });
      };
      switch (elementType) {
        case "node":
          getElementModel(nodes, "node");
          break;
        case "edge":
          getElementModel(edges, "edge");
          break;
        case "combo":
          getElementModel(combos, "combo");
          break;
        default:
          return [];
      }
      return Object.values(items);
    };
    this.createElement = () => {
      if (this.draw) {
        this.updateElement();
        return;
      }
      const _a = this.options, { width: width2, height, nodeField, edgeField, comboField, trigger, position: position2, container, containerStyle, className } = _a, rest = __rest17(_a, ["width", "height", "nodeField", "edgeField", "comboField", "trigger", "position", "container", "containerStyle", "className"]);
      const nodeItems = this.getMarkerData(nodeField, "node");
      const edgeItems = this.getMarkerData(edgeField, "edge");
      const comboItems = this.getMarkerData(comboField, "combo");
      const items = [...nodeItems, ...comboItems, ...edgeItems];
      const categoryStyle = Object.assign({
        width: width2,
        height,
        data: items,
        itemMarkerLineWidth: ({ lineWidth }) => lineWidth,
        itemMarker: ({ marker }) => marker,
        itemMarkerStroke: ({ stroke }) => stroke,
        itemMarkerFill: ({ fill }) => fill,
        gridCol: nodeItems.length
      }, rest, this.getEvents());
      const category = new Category({
        className: "legend",
        style: categoryStyle
      });
      this.category = category;
      const canvas2 = this.upsertCanvas();
      canvas2.appendChild(category);
      this.draw = true;
    };
    this.bindEvents();
  }
  /**
   * <zh/> 
   *
   * <en/> Update the legend configuration
   * @param options - <zh/>  | <en/> Legend options
   * @internal
   */
  update(options) {
    super.update(options);
    this.clear();
    this.createElement();
  }
  clear() {
    var _a, _b;
    (_a = this.canvas) === null || _a === void 0 ? void 0 : _a.destroy();
    (_b = this.container) === null || _b === void 0 ? void 0 : _b.remove();
    this.canvas = void 0;
    this.container = void 0;
    this.draw = false;
  }
  /**
   * <zh/> 
   *
   * <en/> Refresh the status of the legend element
   */
  updateElement() {
    if (!this.category)
      return;
    this.category.update({
      itemMarkerOpacity: ({ id }) => {
        if (!this.selectedItems.length || this.selectedItems.includes(id))
          return 1;
        return 0.5;
      },
      itemLabelOpacity: ({ id }) => {
        if (!this.selectedItems.length || this.selectedItems.includes(id))
          return 1;
        return 0.5;
      }
    });
  }
  upsertCanvas() {
    if (this.canvas)
      return this.canvas;
    const graphCanvas = this.context.canvas;
    const [canvasWidth, canvasHeight] = graphCanvas.getSize();
    const { width: width2 = canvasWidth, height = canvasHeight, position: position2, container, containerStyle, className } = this.options;
    const [$container, canvas2] = createPluginCanvas({
      width: width2,
      height,
      graphCanvas,
      container,
      containerStyle,
      placement: position2,
      className: "legend"
    });
    this.container = $container;
    if (className)
      $container.classList.add(className);
    this.canvas = canvas2;
    return this.canvas;
  }
  /**
   * <zh/>
   *
   * <en/> Destroy the legend
   * @internal
   */
  destroy() {
    this.clear();
    this.context.graph.off(GraphEvent.AFTER_DRAW, this.createElement);
    super.destroy();
  }
};
Legend.defaultOptions = {
  position: "bottom",
  trigger: "hover",
  orientation: "horizontal",
  layout: "flex",
  itemSpacing: 4,
  rowPadding: 10,
  colPadding: 10,
  itemMarkerSize: 16,
  itemLabelFontSize: 16,
  width: 240,
  height: 160
};

// node_modules/@antv/g6/esm/plugins/minimap/index.js
var Minimap = class _Minimap extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, _Minimap.defaultOptions, options));
    this.onDraw = (event) => {
      var _a;
      if ((_a = event === null || event === void 0 ? void 0 : event.data) === null || _a === void 0 ? void 0 : _a.render)
        return;
      this.onRender();
    };
    this.landmarkMap = /* @__PURE__ */ new Map();
    this.mask = null;
    this.isMaskDragging = false;
    this.onMaskDragStart = (event) => {
      if (!this.mask)
        return;
      this.isMaskDragging = true;
      this.mask.setPointerCapture(event.pointerId);
      this.mask.addEventListener("pointermove", this.onMaskDrag);
      this.mask.addEventListener("pointerup", this.onMaskDragEnd);
      this.mask.addEventListener("pointercancel", this.onMaskDragEnd);
    };
    this.onMaskDrag = (event) => {
      if (!this.mask || !this.isMaskDragging)
        return;
      const { size: [minimapWidth, minimapHeight] } = this.options;
      const { movementX, movementY } = event;
      const { left, top, width: w3, height: h3 } = this.mask.style;
      const [, , fullWidth, fullHeight] = this.maskBBox;
      let x4 = parseInt(left) + movementX;
      let y4 = parseInt(top) + movementY;
      let width2 = parseInt(w3);
      let height = parseInt(h3);
      if (x4 < 0)
        x4 = 0;
      if (y4 < 0)
        y4 = 0;
      if (x4 + width2 > minimapWidth)
        x4 = lower(minimapWidth - width2, 0);
      if (y4 + height > minimapHeight)
        y4 = lower(minimapHeight - height, 0);
      if (width2 < fullWidth) {
        if (movementX > 0) {
          x4 = lower(x4 - movementX, 0);
          width2 = upper(width2 + movementX, minimapWidth);
        } else if (movementX < 0)
          width2 = upper(width2 - movementX, minimapWidth);
      }
      if (height < fullHeight) {
        if (movementY > 0) {
          y4 = lower(y4 - movementY, 0);
          height = upper(height + movementY, minimapHeight);
        } else if (movementY < 0)
          height = upper(height - movementY, minimapHeight);
      }
      Object.assign(this.mask.style, {
        left: x4 + "px",
        top: y4 + "px",
        width: width2 + "px",
        height: height + "px"
      });
      const deltaX = parseInt(left) - x4;
      const deltaY = parseInt(top) - y4;
      if (deltaX === 0 && deltaY === 0)
        return;
      const zoom1 = this.context.canvas.getCamera().getZoom();
      const zoom2 = this.canvas.getCamera().getZoom();
      const ratio = zoom1 / zoom2;
      this.context.graph.translateBy([deltaX * ratio, deltaY * ratio], false);
    };
    this.onMaskDragEnd = (event) => {
      if (!this.mask)
        return;
      this.isMaskDragging = false;
      this.mask.releasePointerCapture(event.pointerId);
      this.mask.removeEventListener("pointermove", this.onMaskDrag);
      this.mask.removeEventListener("pointerup", this.onMaskDragEnd);
      this.mask.removeEventListener("pointercancel", this.onMaskDragEnd);
    };
    this.onTransform = throttle_default(() => {
      if (this.isMaskDragging)
        return;
      this.updateMask();
      this.setCamera();
    }, 32, { leading: true });
    this.setOnRender();
    this.bindEvents();
  }
  update(options) {
    this.unbindEvents();
    super.update(options);
    if ("delay" in options)
      this.setOnRender();
    this.bindEvents();
  }
  setOnRender() {
    this.onRender = debounce_default(() => {
      this.renderMinimap();
      this.renderMask();
    }, this.options.delay);
  }
  bindEvents() {
    const { graph } = this.context;
    graph.on(GraphEvent.AFTER_DRAW, this.onDraw);
    graph.on(GraphEvent.AFTER_RENDER, this.onRender);
    graph.on(GraphEvent.AFTER_ANIMATE, this.onRender);
    graph.on(GraphEvent.AFTER_TRANSFORM, this.onTransform);
  }
  unbindEvents() {
    const { graph } = this.context;
    graph.off(GraphEvent.AFTER_DRAW, this.onDraw);
    graph.off(GraphEvent.AFTER_RENDER, this.onRender);
    graph.off(GraphEvent.AFTER_ANIMATE, this.onRender);
    graph.off(GraphEvent.AFTER_TRANSFORM, this.onTransform);
  }
  /**
   * <zh/> 
   *
   * <en/> Create or update the minimap
   */
  renderMinimap() {
    const data = this.getElements();
    const canvas2 = this.initCanvas();
    this.setShapes(canvas2, data);
  }
  getElements() {
    const { filter } = this.options;
    const { model, element } = this.context;
    const originData = model.getData();
    const data = {
      nodes: originData.nodes.filter((node) => element === null || element === void 0 ? void 0 : element.getElement(idOf(node))),
      edges: originData.edges.filter((edge) => {
        const edgeElement = element === null || element === void 0 ? void 0 : element.getElement(idOf(edge));
        return edgeElement && isVisible(edgeElement);
      }),
      combos: originData.combos.filter((combo) => element === null || element === void 0 ? void 0 : element.getElement(idOf(combo)))
    };
    if (!filter)
      return data;
    const { nodes, edges, combos } = data;
    return {
      nodes: nodes.filter((node) => filter(idOf(node), "node")),
      edges: edges.filter((edge) => filter(idOf(edge), "edge")),
      combos: combos.filter((combo) => filter(idOf(combo), "combo"))
    };
  }
  setShapes(canvas2, data) {
    const { nodes, edges, combos } = data;
    const { shape } = this.options;
    const { element } = this.context;
    const iterate = (datum, elType) => {
      const id = idOf(datum);
      const target = element === null || element === void 0 ? void 0 : element.getElement(id);
      if (!target)
        return;
      const keyShape = target.getShape("key");
      let cloneShape;
      if (typeof shape === "string") {
        const shapeName = shape;
        const miniShape = target.getShape(shapeName);
        cloneShape = miniShape.cloneNode();
      } else {
        const miniShape = shape(id, elType, target);
        if (miniShape === target) {
          cloneShape = miniShape.cloneNode(true);
        } else {
          cloneShape = miniShape;
        }
      }
      cloneShape.setPosition(keyShape.getPosition());
      if (target.style.zIndex)
        cloneShape.style.zIndex = target.style.zIndex;
      cloneShape.id = target.id;
      canvas2.appendChild(cloneShape);
    };
    canvas2.removeChildren();
    edges.forEach((datum) => iterate(datum, "edge"));
    combos.forEach((datum) => iterate(datum, "combo"));
    nodes.forEach((datum) => iterate(datum, "node"));
  }
  initCanvas() {
    const { renderer, size: [width2, height] } = this.options;
    if (this.canvas) {
      const { width: w3, height: h3 } = this.canvas.getConfig();
      if (width2 !== w3 || height !== h3)
        this.canvas.resize(width2, height);
      if (renderer)
        this.canvas.setRenderer(renderer);
    } else {
      const { className, position: position2, container, containerStyle } = this.options;
      const [$container, canvas2] = createPluginCanvas({
        renderer,
        width: width2,
        height,
        placement: position2,
        className: "minimap",
        container,
        containerStyle,
        graphCanvas: this.context.canvas
      });
      if (className)
        $container.classList.add(className);
      this.container = $container;
      this.canvas = canvas2;
    }
    this.setCamera();
    return this.canvas;
  }
  createLandmark(position2, focalPoint, zoom) {
    const key = `${position2.join(",")}-${focalPoint.join(",")}-${zoom}`;
    if (this.landmarkMap.has(key))
      return this.landmarkMap.get(key);
    const camera = this.canvas.getCamera();
    const landmark = camera.createLandmark(key, {
      position: position2,
      focalPoint,
      zoom
    });
    this.landmarkMap.set(key, landmark);
    return landmark;
  }
  setCamera() {
    var _a;
    const { canvas: canvas2 } = this.context;
    const camera = (_a = this.canvas) === null || _a === void 0 ? void 0 : _a.getCamera();
    if (!camera)
      return;
    const { size: [minimapWidth, minimapHeight], padding } = this.options;
    const [top, right, bottom, left] = parsePadding(padding);
    const { min: boundsMin, max: boundsMax, center } = canvas2.getBounds("elements");
    const boundsWidth = boundsMax[0] - boundsMin[0];
    const boundsHeight = boundsMax[1] - boundsMin[1];
    const availableWidth = minimapWidth - left - right;
    const availableHeight = minimapHeight - top - bottom;
    const scaleX = availableWidth / boundsWidth;
    const scaleY = availableHeight / boundsHeight;
    const scale2 = Math.min(scaleX, scaleY);
    const landmark = this.createLandmark(center, center, scale2);
    camera.gotoLandmark(landmark, 0);
  }
  get maskBBox() {
    const { canvas: graphCanvas } = this.context;
    const canvasSize = graphCanvas.getSize();
    const canvasMin = graphCanvas.getCanvasByViewport([0, 0]);
    const canvasMax = graphCanvas.getCanvasByViewport(canvasSize);
    const maskMin = this.canvas.canvas2Viewport(toPointObject(canvasMin));
    const maskMax = this.canvas.canvas2Viewport(toPointObject(canvasMax));
    const width2 = maskMax.x - maskMin.x;
    const height = maskMax.y - maskMin.y;
    return [maskMin.x, maskMin.y, width2, height];
  }
  /**
   * <zh/> 
   *
   * <en/> Calculate the bounding box of the mask
   * @returns <zh/>  | <en/> Mask bounding box
   */
  calculateMaskBBox() {
    const { size: [minimapWidth, minimapHeight] } = this.options;
    let [x4, y4, width2, height] = this.maskBBox;
    if (x4 < 0) {
      width2 = upper(width2 + x4, minimapWidth);
      x4 = 0;
    }
    if (y4 < 0) {
      height = upper(height + y4, minimapHeight);
      y4 = 0;
    }
    if (x4 + width2 > minimapWidth)
      width2 = lower(minimapWidth - x4, 0);
    if (y4 + height > minimapHeight)
      height = lower(minimapHeight - y4, 0);
    return [upper(x4, minimapWidth), upper(y4, minimapHeight), lower(width2, 0), lower(height, 0)];
  }
  /**
   * <zh/> 
   *
   * <en/> Create or update the mask
   */
  renderMask() {
    const { maskStyle } = this.options;
    if (!this.mask) {
      this.mask = document.createElement("div");
      this.mask.addEventListener("pointerdown", this.onMaskDragStart);
      this.mask.draggable = true;
      this.mask.addEventListener("dragstart", (event) => event.preventDefault && event.preventDefault());
    }
    this.container.appendChild(this.mask);
    Object.assign(this.mask.style, Object.assign(Object.assign({}, maskStyle), { cursor: "move", position: "absolute", pointerEvents: "auto" }));
    this.updateMask();
  }
  updateMask() {
    if (!this.mask)
      return;
    const [x4, y4, width2, height] = this.calculateMaskBBox();
    Object.assign(this.mask.style, {
      top: y4 + "px",
      left: x4 + "px",
      width: width2 + "px",
      height: height + "px"
    });
  }
  destroy() {
    var _a, _b, _c;
    this.unbindEvents();
    (_a = this.canvas) === null || _a === void 0 ? void 0 : _a.destroy();
    (_b = this.mask) === null || _b === void 0 ? void 0 : _b.remove();
    (_c = this.container) === null || _c === void 0 ? void 0 : _c.remove();
    super.destroy();
  }
};
Minimap.defaultOptions = {
  size: [240, 160],
  shape: "key",
  padding: 10,
  position: "right-bottom",
  maskStyle: {
    border: "1px solid #ddd",
    background: "rgba(0, 0, 0, 0.1)"
  },
  containerStyle: {
    border: "1px solid #ddd",
    background: "#fff"
  },
  delay: 128
};
var upper = (value, max2) => Math.min(value, max2);
var lower = (value, min2) => Math.max(value, min2);

// node_modules/@antv/g6/esm/plugins/snapline/index.js
var __awaiter17 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var defaultLineStyle = { x1: 0, y1: 0, x2: 0, y2: 0, visibility: "hidden" };
var Snapline = class _Snapline extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, _Snapline.defaultOptions, options));
    this.initSnapline = () => {
      const canvas2 = this.context.canvas.getLayer("transient");
      if (!this.horizontalLine) {
        this.horizontalLine = canvas2.appendChild(new Line({ style: Object.assign(Object.assign({}, defaultLineStyle), this.options.horizontalLineStyle) }));
      }
      if (!this.verticalLine) {
        this.verticalLine = canvas2.appendChild(new Line({ style: Object.assign(Object.assign({}, defaultLineStyle), this.options.verticalLineStyle) }));
      }
    };
    this.isHorizontalSticking = false;
    this.isVerticalSticking = false;
    this.enableStick = true;
    this.autoSnapToLine = (nodeId, bbox, metadata) => __awaiter17(this, void 0, void 0, function* () {
      const { verticalX, horizontalY } = metadata;
      const { tolerance } = this.options;
      const { min: [nodeMinX, nodeMinY], max: [nodeMaxX, nodeMaxY], center: [nodeCenterX, nodeCenterY] } = bbox;
      let dx = 0;
      let dy = 0;
      if (verticalX !== null) {
        if (distance3(nodeMaxX, verticalX) < tolerance)
          dx = verticalX - nodeMaxX;
        if (distance3(nodeMinX, verticalX) < tolerance)
          dx = verticalX - nodeMinX;
        if (distance3(nodeCenterX, verticalX) < tolerance)
          dx = verticalX - nodeCenterX;
        if (dx !== 0)
          this.isVerticalSticking = true;
      }
      if (horizontalY !== null) {
        if (distance3(nodeMaxY, horizontalY) < tolerance)
          dy = horizontalY - nodeMaxY;
        if (distance3(nodeMinY, horizontalY) < tolerance)
          dy = horizontalY - nodeMinY;
        if (distance3(nodeCenterY, horizontalY) < tolerance)
          dy = horizontalY - nodeCenterY;
        if (dy !== 0)
          this.isHorizontalSticking = true;
      }
      if (dx !== 0 || dy !== 0) {
        yield this.context.graph.translateElementBy({ [nodeId]: [dx, dy] }, false);
      }
    });
    this.enableSnap = (event) => {
      const { target } = event;
      const threshold = 0.5;
      if (this.isHorizontalSticking || this.isVerticalSticking) {
        const [dx, dy] = this.getDelta(event);
        if (this.isHorizontalSticking && this.isVerticalSticking && Math.abs(dx) <= threshold && Math.abs(dy) <= threshold) {
          this.context.graph.translateElementBy({ [target.id]: [-dx, -dy] }, false);
          return false;
        } else if (this.isHorizontalSticking && Math.abs(dy) <= threshold) {
          this.context.graph.translateElementBy({ [target.id]: [0, -dy] }, false);
          return false;
        } else if (this.isVerticalSticking && Math.abs(dx) <= threshold) {
          this.context.graph.translateElementBy({ [target.id]: [-dx, 0] }, false);
          return false;
        } else {
          this.isHorizontalSticking = false;
          this.isVerticalSticking = false;
          this.enableStick = false;
          setTimeout(() => {
            this.enableStick = true;
          }, 200);
        }
      }
      return this.enableStick;
    };
    this.calcSnaplineMetadata = (target, nodeBBox) => {
      const { tolerance, shape } = this.options;
      const { min: [nodeMinX, nodeMinY], max: [nodeMaxX, nodeMaxY], center: [nodeCenterX, nodeCenterY] } = nodeBBox;
      let verticalX = null;
      let verticalMinY = null;
      let verticalMaxY = null;
      let horizontalY = null;
      let horizontalMinX = null;
      let horizontalMaxX = null;
      this.getNodes().some((snapNode) => {
        if (is_equal_default(target.id, snapNode.id))
          return false;
        const snapBBox = getShape(snapNode, shape).getRenderBounds();
        const { min: [snapMinX, snapMinY], max: [snapMaxX, snapMaxY], center: [snapCenterX, snapCenterY] } = snapBBox;
        if (verticalX === null) {
          if (distance3(snapCenterX, nodeCenterX) < tolerance) {
            verticalX = snapCenterX;
          } else if (distance3(snapMinX, nodeMinX) < tolerance) {
            verticalX = snapMinX;
          } else if (distance3(snapMinX, nodeMaxX) < tolerance) {
            verticalX = snapMinX;
          } else if (distance3(snapMaxX, nodeMaxX) < tolerance) {
            verticalX = snapMaxX;
          } else if (distance3(snapMaxX, nodeMinX) < tolerance) {
            verticalX = snapMaxX;
          }
          if (verticalX !== null) {
            verticalMinY = Math.min(snapMinY, nodeMinY);
            verticalMaxY = Math.max(snapMaxY, nodeMaxY);
          }
        }
        if (horizontalY === null) {
          if (distance3(snapCenterY, nodeCenterY) < tolerance) {
            horizontalY = snapCenterY;
          } else if (distance3(snapMinY, nodeMinY) < tolerance) {
            horizontalY = snapMinY;
          } else if (distance3(snapMinY, nodeMaxY) < tolerance) {
            horizontalY = snapMinY;
          } else if (distance3(snapMaxY, nodeMaxY) < tolerance) {
            horizontalY = snapMaxY;
          } else if (distance3(snapMaxY, nodeMinY) < tolerance) {
            horizontalY = snapMaxY;
          }
          if (horizontalY !== null) {
            horizontalMinX = Math.min(snapMinX, nodeMinX);
            horizontalMaxX = Math.max(snapMaxX, nodeMaxX);
          }
        }
        return verticalX !== null && horizontalY !== null;
      });
      return { verticalX, verticalMinY, verticalMaxY, horizontalY, horizontalMinX, horizontalMaxX };
    };
    this.onDragStart = () => {
      this.initSnapline();
    };
    this.onDrag = (event) => __awaiter17(this, void 0, void 0, function* () {
      const { target } = event;
      if (this.options.autoSnap) {
        const enable = this.enableSnap(event);
        if (!enable)
          return;
      }
      const nodeBBox = getShape(target, this.options.shape).getRenderBounds();
      const metadata = this.calcSnaplineMetadata(target, nodeBBox);
      this.hideSnapline();
      if (metadata.verticalX !== null || metadata.horizontalY !== null) {
        this.updateSnapline(metadata);
      }
      if (this.options.autoSnap) {
        yield this.autoSnapToLine(target.id, nodeBBox, metadata);
      }
    });
    this.onDragEnd = () => {
      this.hideSnapline();
    };
    this.bindEvents();
  }
  getNodes() {
    var _a;
    const { filter } = this.options;
    const allNodes = ((_a = this.context.element) === null || _a === void 0 ? void 0 : _a.getNodes()) || [];
    const nodes = allNodes.filter((node) => {
      var _a2;
      return isVisible(node) && ((_a2 = this.context.viewport) === null || _a2 === void 0 ? void 0 : _a2.isInViewport(node.getRenderBounds()));
    });
    if (!filter)
      return nodes;
    return nodes.filter((node) => filter(node));
  }
  hideSnapline() {
    this.horizontalLine.style.visibility = "hidden";
    this.verticalLine.style.visibility = "hidden";
  }
  getLineWidth(direction) {
    const { lineWidth } = this.options[`${direction}LineStyle`];
    return +(lineWidth || defaultLineStyle.lineWidth || 1) / this.context.graph.getZoom();
  }
  updateSnapline(metadata) {
    const { verticalX, verticalMinY, verticalMaxY, horizontalY, horizontalMinX, horizontalMaxX } = metadata;
    const [canvasWidth, canvasHeight] = this.context.canvas.getSize();
    const { offset } = this.options;
    if (horizontalY !== null) {
      Object.assign(this.horizontalLine.style, {
        x1: offset === Infinity ? 0 : horizontalMinX - offset,
        y1: horizontalY,
        x2: offset === Infinity ? canvasWidth : horizontalMaxX + offset,
        y2: horizontalY,
        visibility: "visible",
        lineWidth: this.getLineWidth("horizontal")
      });
    } else {
      this.horizontalLine.style.visibility = "hidden";
    }
    if (verticalX !== null) {
      Object.assign(this.verticalLine.style, {
        x1: verticalX,
        y1: offset === Infinity ? 0 : verticalMinY - offset,
        x2: verticalX,
        y2: offset === Infinity ? canvasHeight : verticalMaxY + offset,
        visibility: "visible",
        lineWidth: this.getLineWidth("vertical")
      });
    } else {
      this.verticalLine.style.visibility = "hidden";
    }
  }
  /**
   * Get the delta of the drag
   * @param event - drag event object
   * @returns delta
   * @internal
   */
  getDelta(event) {
    const zoom = this.context.graph.getZoom();
    return divide([event.dx, event.dy], zoom);
  }
  bindEvents() {
    return __awaiter17(this, void 0, void 0, function* () {
      const { graph } = this.context;
      graph.on(NodeEvent.DRAG_START, this.onDragStart);
      graph.on(NodeEvent.DRAG, this.onDrag);
      graph.on(NodeEvent.DRAG_END, this.onDragEnd);
    });
  }
  unbindEvents() {
    const { graph } = this.context;
    graph.off(NodeEvent.DRAG_START, this.onDragStart);
    graph.off(NodeEvent.DRAG, this.onDrag);
    graph.off(NodeEvent.DRAG_END, this.onDragEnd);
  }
  destroyElements() {
    var _a, _b;
    (_a = this.horizontalLine) === null || _a === void 0 ? void 0 : _a.destroy();
    (_b = this.verticalLine) === null || _b === void 0 ? void 0 : _b.destroy();
  }
  destroy() {
    this.destroyElements();
    this.unbindEvents();
    super.destroy();
  }
};
Snapline.defaultOptions = {
  tolerance: 5,
  offset: 20,
  autoSnap: true,
  shape: "key",
  verticalLineStyle: { stroke: "#1783FF" },
  horizontalLineStyle: { stroke: "#1783FF" },
  filter: () => true
};
var distance3 = (a3, b3) => Math.abs(a3 - b3);
var getShape = (node, shapeFilter) => {
  return typeof shapeFilter === "function" ? shapeFilter(node) : node.getShape(shapeFilter);
};

// node_modules/@antv/g6/esm/plugins/timebar.js
var __awaiter18 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest18 = function(s2, e2) {
  var t3 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t3[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t3[p3[i2]] = s2[p3[i2]];
    }
  return t3;
};
var prospectiveTimeKeys = ["timestamp", "time", "date", "datetime"];
var Timebar2 = class _Timebar extends BasePlugin {
  get padding() {
    return parsePadding(this.options.padding);
  }
  constructor(context, options) {
    super(context, Object.assign({}, _Timebar.defaultOptions, options));
    this.backup();
    this.upsertTimebar();
  }
  /**
   * <zh/> 
   *
   * <en/> Play
   */
  play() {
    var _a;
    (_a = this.timebar) === null || _a === void 0 ? void 0 : _a.play();
  }
  /**
   * <zh/> 
   *
   * <en/> Pause
   */
  pause() {
    var _a;
    (_a = this.timebar) === null || _a === void 0 ? void 0 : _a.pause();
  }
  /**
   * <zh/> 
   *
   * <en/> Forward
   */
  forward() {
    var _a;
    (_a = this.timebar) === null || _a === void 0 ? void 0 : _a.forward();
  }
  /**
   * <zh/> 
   *
   * <en/> Backward
   */
  backward() {
    var _a;
    (_a = this.timebar) === null || _a === void 0 ? void 0 : _a.backward();
  }
  /**
   * <zh/> 
   *
   * <en/> Reset
   */
  reset() {
    var _a;
    (_a = this.timebar) === null || _a === void 0 ? void 0 : _a.reset();
  }
  /**
   * <zh/> 
   *
   * <en/> Update timebar configuration options
   * @param options - <zh/>  | <en/> Options
   * @internal
   */
  update(options) {
    super.update(options);
    this.backup();
    this.upsertTimebar();
  }
  /**
   * <zh/> 
   *
   * <en/> Backup data
   */
  backup() {
    this.originalData = shallowCopy(this.context.graph.getData());
  }
  upsertTimebar() {
    const { canvas: canvas2 } = this.context;
    const _a = this.options, { onChange, timebarType, data, x: x4, y: y4, width: width2, height, mode } = _a, restOptions = __rest18(_a, ["onChange", "timebarType", "data", "x", "y", "width", "height", "mode"]);
    const canvasSize = canvas2.getSize();
    const [top] = this.padding;
    this.upsertCanvas().ready.then(() => {
      var _a2;
      const style = Object.assign(Object.assign({ x: canvasSize[0] / 2 - width2 / 2, y: top, onChange: (value) => {
        const range = (isArray(value) ? value : [value, value]).map((time) => isDate(time) ? time.getTime() : time);
        if (this.options.mode === "modify")
          this.filterElements(range);
        else
          this.hiddenElements(range);
        onChange === null || onChange === void 0 ? void 0 : onChange(range);
      } }, restOptions), {
        data: data.map((datum) => isNumber(datum) ? { time: datum, value: 0 } : datum),
        width: width2,
        height,
        type: timebarType
      });
      if (!this.timebar) {
        this.timebar = new Timebar({ style });
        (_a2 = this.canvas) === null || _a2 === void 0 ? void 0 : _a2.appendChild(this.timebar);
      } else {
        this.timebar.update(style);
      }
    });
  }
  upsertCanvas() {
    if (this.canvas)
      return this.canvas;
    const { className, height, position: position2 } = this.options;
    const graphCanvas = this.context.canvas;
    const [width2] = graphCanvas.getSize();
    const [top, , bottom] = this.padding;
    const [$container, canvas2] = createPluginCanvas({
      width: width2,
      height: height + top + bottom,
      graphCanvas,
      className: "timebar",
      placement: position2
    });
    this.container = $container;
    if (className)
      $container.classList.add(className);
    this.canvas = canvas2;
    return this.canvas;
  }
  filterElements(range) {
    return __awaiter18(this, void 0, void 0, function* () {
      var _a;
      if (!this.originalData)
        return;
      const { elementTypes, getTime } = this.options;
      const { graph, element } = this.context;
      const newData = shallowCopy(this.originalData);
      elementTypes.forEach((type) => {
        const key = `${type}s`;
        newData[key] = (this.originalData[key] || []).filter((datum) => {
          const time = getTime(datum);
          if (match(time, range))
            return true;
          return false;
        });
      });
      const nodeLikeIds = [...newData.nodes, ...newData.combos].map((datum) => idOf(datum));
      newData.edges = newData.edges.filter((edge) => {
        const source = edge.source;
        const target = edge.target;
        return nodeLikeIds.includes(source) && nodeLikeIds.includes(target);
      });
      graph.setData(newData);
      yield (_a = element.draw({ animation: false, silence: true })) === null || _a === void 0 ? void 0 : _a.finished;
    });
  }
  hiddenElements(range) {
    const { graph } = this.context;
    const { elementTypes, getTime } = this.options;
    const hideElementId = [];
    const showElementId = [];
    elementTypes.forEach((elementType) => {
      var _a;
      const key = `${elementType}s`;
      const elementData = ((_a = this.originalData) === null || _a === void 0 ? void 0 : _a[key]) || [];
      elementData.forEach((elementDatum) => {
        const id = idOf(elementDatum);
        const time = getTime(elementDatum);
        if (match(time, range))
          showElementId.push(id);
        else
          hideElementId.push(id);
      });
    });
    graph.hideElement(hideElementId, false);
    graph.showElement(showElementId, false);
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy the timebar
   * @internal
   */
  destroy() {
    var _a, _b, _c;
    const { graph } = this.context;
    this.originalData && graph.setData(Object.assign({}, this.originalData));
    (_a = this.timebar) === null || _a === void 0 ? void 0 : _a.destroy();
    (_b = this.canvas) === null || _b === void 0 ? void 0 : _b.destroy();
    (_c = this.container) === null || _c === void 0 ? void 0 : _c.remove();
    this.originalData = void 0;
    this.container = void 0;
    this.timebar = void 0;
    this.canvas = void 0;
    super.destroy();
  }
};
Timebar2.defaultOptions = {
  position: "bottom",
  enable: true,
  timebarType: "time",
  className: "g6-timebar",
  width: 450,
  height: 60,
  zIndex: 3,
  elementTypes: ["node"],
  padding: 10,
  mode: "modify",
  getTime: (datum) => inferTime(datum, prospectiveTimeKeys, void 0),
  loop: false
};
var shallowCopy = (data) => {
  const { nodes = [], edges = [], combos = [] } = data;
  return {
    nodes: [...nodes],
    edges: [...edges],
    combos: [...combos]
  };
};
var match = (time, range) => {
  if (isNumber(range))
    return time === range;
  const [start, end] = range;
  return time >= start && time <= end;
};
var inferTime = (datum, optionsKeys, defaultValue) => {
  var _a;
  for (let i2 = 0; i2 < optionsKeys.length; i2++) {
    const key = optionsKeys[i2];
    const val = (_a = datum.data) === null || _a === void 0 ? void 0 : _a[key];
    if (val)
      return val;
  }
  return defaultValue;
};

// node_modules/@antv/g6/esm/plugins/title/index.js
var __rest19 = function(s2, e2) {
  var t3 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t3[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t3[p3[i2]] = s2[p3[i2]];
    }
  return t3;
};
var commonStyle = {
  fill: "#1D2129",
  wordWrap: true,
  // 
  maxLines: 1,
  // 
  textOverflow: "ellipsis",
  // 
  textBaseline: "top",
  /**
   * textAlign  x 
   * : :  width = 600
   * - textAlign: 'start' | 'left
   *     x = 0
   * - textAlign: 'end' | 'right'
   *     x = 600 ()
   * - textAlign: 'center'
   *     x = 300 ( / 2)
   */
  textAlign: "start",
  x: 0
};
var defaultTitleStyle = Object.assign(Object.assign({}, commonStyle), { fillOpacity: 0.9, fontSize: 16, fontWeight: "bold" });
var defaultSubTitleStyle = Object.assign(Object.assign({}, commonStyle), { fillOpacity: 0.65, fontSize: 12, fontWeight: "normal" });
var defaultOptions3 = {
  align: "left",
  spacing: 8,
  size: 44,
  padding: [16, 24, 0, 24]
};
var titleKey = "title";
var subtitleKey = "subtitle";
var Title = class extends BasePlugin {
  get padding() {
    return parsePadding(this.options.padding);
  }
  constructor(context, options) {
    const combineOption = Object.assign({}, defaultOptions3, options);
    super(context, combineOption);
    this.onRender = () => {
      const canvas2 = this.updateCanvas();
      this.renderTitle(canvas2);
    };
    this.bindEvents();
  }
  bindEvents() {
    const { graph } = this.context;
    graph.on(GraphEvent.AFTER_RENDER, this.onRender);
    graph.on(GraphEvent.AFTER_ANIMATE, this.onRender);
  }
  unbindEvents() {
    const { graph } = this.context;
    graph.off(GraphEvent.AFTER_RENDER, this.onRender);
    graph.off(GraphEvent.AFTER_ANIMATE, this.onRender);
  }
  destroy() {
    var _a, _b;
    this.unbindEvents();
    (_a = this.canvas) === null || _a === void 0 ? void 0 : _a.destroy();
    (_b = this.container) === null || _b === void 0 ? void 0 : _b.remove();
    super.destroy();
  }
  updateCanvas() {
    const { size: size2, className, align } = this.options;
    const [width2] = this.context.canvas.getSize();
    const [pt2 = 0, , pb = 0] = this.padding;
    const height = size2 + pt2 + pb;
    if (this.canvas) {
      const { width: w3, height: h3 } = this.canvas.getConfig();
      if (width2 !== w3 || height !== h3)
        this.canvas.resize(width2, height);
    } else {
      const positions = {
        left: "left-top",
        center: "top",
        right: "right-top"
      };
      const [$container, canvas2] = createPluginCanvas({
        width: width2,
        height,
        placement: positions[align] || positions.left,
        className: "title-canvas",
        graphCanvas: this.context.canvas
      });
      if (className)
        $container.classList.add(className);
      this.container = $container;
      this.canvas = canvas2;
    }
    return this.canvas;
  }
  renderTitle(canvas2) {
    const titles = new TitleComponent({
      options: this.options,
      ctx: this.context
    });
    canvas2.removeChildren();
    titles.getTitle().forEach((label) => {
      if (label)
        canvas2.appendChild(label);
    });
  }
};
var TitleComponent = class {
  get padding() {
    return parsePadding(this.options.padding);
  }
  constructor(props) {
    const { options, ctx: ctx3 } = props;
    this.options = options;
    this.context = ctx3;
  }
  getTitle() {
    const _a = this.options, _b = titleKey, propsTitle = _a[_b], _c = subtitleKey, propsSubtitle = _a[_c], { spacing = 44, padding, align } = _a, style = __rest19(_a, [typeof _b === "symbol" ? _b : _b + "", typeof _c === "symbol" ? _c : _c + "", "spacing", "padding", "align"]);
    const titleText = propsTitle;
    const subTitleText = propsSubtitle;
    const titleStyle = subStyleProps(style, titleKey);
    const subtitleStyle = subStyleProps(style, subtitleKey);
    const [topGraphWidth] = this.context.graph.getSize();
    const [pt2 = 0, pr = 0, , pl = 0] = this.padding;
    const canvasWidth = topGraphWidth;
    const textWidth = canvasWidth - pl - pr;
    let subTitle = null;
    let alignX = pl;
    let textAlign = "left";
    switch (align) {
      case "left":
        alignX = pl;
        textAlign = "left";
        break;
      case "center":
        alignX = canvasWidth / 2;
        textAlign = "center";
        break;
      case "right":
        alignX = canvasWidth - pr;
        textAlign = "right";
        break;
      default:
        alignX = pl;
        textAlign = "left";
    }
    const title = new Label({
      className: titleKey,
      style: Object.assign(Object.assign(Object.assign(Object.assign({}, defaultTitleStyle), { wordWrapWidth: textWidth - 5, x: alignX, y: pt2, textAlign }), titleStyle), { text: titleText })
    });
    const titleBBox = title.getBBox();
    if (subTitleText) {
      subTitle = new Label({
        className: "subTitle",
        style: Object.assign(Object.assign(Object.assign(Object.assign({}, defaultSubTitleStyle), { wordWrapWidth: textWidth - 5, x: alignX, y: titleBBox.height + spacing + pt2, textAlign }), subtitleStyle), { text: subTitleText })
      });
    }
    return [title, subTitle];
  }
};

// node_modules/@antv/g6/esm/plugins/toolbar/util.js
function parsePositionToStyle(position2) {
  const style = {
    top: "unset",
    right: "unset",
    bottom: "unset",
    left: "unset"
  };
  const directions = position2.split("-");
  directions.forEach((d3) => {
    style[d3] = "8px";
  });
  style.flexDirection = position2.startsWith("top") || position2.startsWith("bottom") ? "row" : "column";
  return style;
}
var TOOLBAR_CSS = `
  .g6-toolbar {
    position: absolute;
    z-index: 100;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    box-shadow: 0px 0px 8px rgba(0, 0, 0, 0.1);
    opacity: 0.65;
  }
  .g6-toolbar .g6-toolbar-item {
    display: inline-block;
    width: 16px;
    height: 16px;
    padding: 4px;
    cursor: pointer;
    box-sizing: content-box;
  }

  .g6-toolbar .g6-toolbar-item:hover {
    background-color: #f0f0f0;
  }

  .g6-toolbar .g6-toolbar-item svg {
    display: inline-block;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }
`;
var BUILD_IN_SVG_ICON = `
  <svg>
    <symbol id="zoom-in" viewBox="64 64 896 896">
      <path d="M637 443H519V309c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v134H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h118v134c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V519h118c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z"></path>
    </symbol>
    <symbol id="zoom-out" viewBox="64 64 896 896">
      <path d="M637 443H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h312c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z"></path>
    </symbol>
    <symbol id="edit" viewBox="64 64 896 896">
      <path d="M257.7 752c2 0 4-.2 6-.5L431.9 722c2-.4 3.9-1.3 5.3-2.8l423.9-423.9a9.96 9.96 0 000-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2a33.5 33.5 0 009.4 29.8c6.6 6.4 14.9 9.9 23.8 9.9zm67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z"></path>
    </symbol>
    <symbol id="delete" viewBox="64 64 896 896">
      <path d="M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z"></path>
    </symbol>
    <symbol id="redo" viewBox="64 64 896 896">
      <path d="M758.2 839.1C851.8 765.9 912 651.9 912 523.9 912 303 733.5 124.3 512.6 124 291.4 123.7 112 302.8 112 523.9c0 125.2 57.5 236.9 147.6 310.2 3.5 2.8 8.6 2.2 11.4-1.3l39.4-50.5c2.7-3.4 2.1-8.3-1.2-11.1-8.1-6.6-15.9-13.7-23.4-21.2a318.64 318.64 0 01-68.6-101.7C200.4 609 192 567.1 192 523.9s8.4-85.1 25.1-124.5c16.1-38.1 39.2-72.3 68.6-101.7 29.4-29.4 63.6-52.5 101.7-68.6C426.9 212.4 468.8 204 512 204s85.1 8.4 124.5 25.1c38.1 16.1 72.3 39.2 101.7 68.6 29.4 29.4 52.5 63.6 68.6 101.7 16.7 39.4 25.1 81.3 25.1 124.5s-8.4 85.1-25.1 124.5a318.64 318.64 0 01-68.6 101.7c-9.3 9.3-19.1 18-29.3 26L668.2 724a8 8 0 00-14.1 3l-39.6 162.2c-1.2 5 2.6 9.9 7.7 9.9l167 .8c6.7 0 10.5-7.7 6.3-12.9l-37.3-47.9z"></path>
    </symbol>
    <symbol id="undo" viewBox="64 64 896 896">
      <path d="M511.4 124C290.5 124.3 112 303 112 523.9c0 128 60.2 242 153.8 315.2l-37.5 48c-4.1 5.3-.3 13 6.3 12.9l167-.8c5.2 0 9-4.9 7.7-9.9L369.8 727a8 8 0 00-14.1-3L315 776.1c-10.2-8-20-16.7-29.3-26a318.64 318.64 0 01-68.6-101.7C200.4 609 192 567.1 192 523.9s8.4-85.1 25.1-124.5c16.1-38.1 39.2-72.3 68.6-101.7 29.4-29.4 63.6-52.5 101.7-68.6C426.9 212.4 468.8 204 512 204s85.1 8.4 124.5 25.1c38.1 16.1 72.3 39.2 101.7 68.6 29.4 29.4 52.5 63.6 68.6 101.7 16.7 39.4 25.1 81.3 25.1 124.5s-8.4 85.1-25.1 124.5a318.64 318.64 0 01-68.6 101.7c-7.5 7.5-15.3 14.5-23.4 21.2a7.93 7.93 0 00-1.2 11.1l39.4 50.5c2.8 3.5 7.9 4.1 11.4 1.3C854.5 760.8 912 649.1 912 523.9c0-221.1-179.4-400.2-400.6-399.9z"></path>
    </symbol>
    <symbol id="export" viewBox="64 64 896 896">
      <path d="M880 912H144c-17.7 0-32-14.3-32-32V144c0-17.7 14.3-32 32-32h360c4.4 0 8 3.6 8 8v56c0 4.4-3.6 8-8 8H184v656h656V520c0-4.4 3.6-8 8-8h56c4.4 0 8 3.6 8 8v360c0 17.7-14.3 32-32 32zM770.87 199.13l-52.2-52.2a8.01 8.01 0 014.7-13.6l179.4-21c5.1-.6 9.5 3.7 8.9 8.9l-21 179.4c-.8 6.6-8.9 9.4-13.6 4.7l-52.4-52.4-256.2 256.2a8.03 8.03 0 01-11.3 0l-42.4-42.4a8.03 8.03 0 010-11.3l256.1-256.3z"></path>
    </symbol>
    <symbol id="auto-fit" viewBox="64 64 896 896">
      <path d="M952 474H829.8C812.5 327.6 696.4 211.5 550 194.2V72c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v122.2C327.6 211.5 211.5 327.6 194.2 474H72c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h122.2C211.5 696.4 327.6 812.5 474 829.8V952c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V829.8C696.4 812.5 812.5 696.4 829.8 550H952c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zM512 756c-134.8 0-244-109.2-244-244s109.2-244 244-244 244 109.2 244 244-109.2 244-244 244z"></path>
      <path d="M512 392c-32.1 0-62.1 12.4-84.8 35.2-22.7 22.7-35.2 52.7-35.2 84.8s12.5 62.1 35.2 84.8C449.9 619.4 480 632 512 632s62.1-12.5 84.8-35.2C619.4 574.1 632 544 632 512s-12.5-62.1-35.2-84.8A118.57 118.57 0 00512 392z"></path>
    </symbol>
    <symbol id="reset" viewBox="64 64 896 896">
      <path d="M909.1 209.3l-56.4 44.1C775.8 155.1 656.2 92 521.9 92 290 92 102.3 279.5 102 511.5 101.7 743.7 289.8 932 521.9 932c181.3 0 335.8-115 394.6-276.1 1.5-4.2-.7-8.9-4.9-10.3l-56.7-19.5a8 8 0 00-10.1 4.8c-1.8 5-3.8 10-5.9 14.9-17.3 41-42.1 77.8-73.7 109.4A344.77 344.77 0 01655.9 829c-42.3 17.9-87.4 27-133.8 27-46.5 0-91.5-9.1-133.8-27A341.5 341.5 0 01279 755.2a342.16 342.16 0 01-73.7-109.4c-17.9-42.4-27-87.4-27-133.9s9.1-91.5 27-133.9c17.3-41 42.1-77.8 73.7-109.4 31.6-31.6 68.4-56.4 109.3-73.8 42.3-17.9 87.4-27 133.8-27 46.5 0 91.5 9.1 133.8 27a341.5 341.5 0 01109.3 73.8c9.9 9.9 19.2 20.4 27.8 31.4l-60.2 47a8 8 0 003 14.1l175.6 43c5 1.2 9.9-2.6 9.9-7.7l.8-180.9c-.1-6.6-7.8-10.3-13-6.2z"></path>
    </symbol>
    <symbol id="exit-fullscreen" viewBox="0 0 1024 1024">
      <path d="M418.13333333 361.43786666c0 0.2048-0.13653333 0.4096-0.13653334 0.68266667C417.99679999 362.32533333 418.13333333 362.53013333 418.13333333 362.73493333 418.13333333 371.54133333 414.44693333 379.392 408.78079999 385.39946666 408.43946666 385.7408 408.30293333 386.21866666 408.02986666 386.49173333c-1.09226667 1.09226667-2.59413333 1.77493333-3.82293333 2.73066667C398.40426666 393.65973333 391.64586666 396.8 383.93173333 396.8 383.72693333 396.8 383.59039999 396.73173333 383.38559999 396.73173333S382.97599999 396.8 382.77119999 396.8L112.29866666 396.8C92.50133333 396.8 76.79999999 381.50826666 76.79999999 362.66666666 76.66346666 343.89333333 92.63786666 328.53333333 112.16213333 328.53333333l189.44 0L87.44959999 114.51733333C73.59146666 100.59093333 73.25013333 78.5408 86.63039999 65.29706666c13.17546667-13.44853333 35.36213333-12.97066667 49.152 0.88746667l214.08426667 214.08426667L349.86666666 90.89706666C349.79839999 71.23626666 365.22666666 55.46666666 383.99999999 55.46666666 402.77333333 55.33013333 418.13333333 71.30453333 418.13333333 90.8288L418.13333333 361.43786666zM928.90453333 328.53333333l-189.44 0 214.15253333-214.08426667c13.85813333-13.9264 14.19946667-35.90826667 0.88746667-49.22026666-13.17546667-13.44853333-35.36213333-12.97066667-49.152 0.88746666l-214.08426667 214.08426667L691.26826666 90.89706666C691.26826666 71.23626666 675.83999999 55.46666666 657.06666666 55.46666666 638.29333333 55.33013333 622.93333333 71.30453333 622.93333333 90.8288l0 270.60906666c0 0.2048 0.13653333 0.4096 0.13653333 0.68266667C623.06986666 362.32533333 622.93333333 362.53013333 622.93333333 362.73493333 622.93333333 371.54133333 626.61973333 379.392 632.28586666 385.39946666c0.34133333 0.34133333 0.47786667 0.8192 0.8192 1.09226667 1.09226667 1.09226667 2.59413333 1.77493333 3.8912 2.73066667C642.66239999 393.65973333 649.42079999 396.8 657.13493333 396.8c0.2048 0 0.34133333-0.06826667 0.54613333-0.06826667S658.09066666 396.8 658.29546666 396.8l270.5408 0C948.56533333 396.8 964.26666666 381.50826666 964.26666666 362.66666666 964.40319999 343.89333333 948.42879999 328.53333333 928.90453333 328.53333333zM418.13333333 635.73333333c0-8.8064-3.6864-16.5888-9.35253334-22.66453333C408.43946666 612.72746666 408.30293333 612.2496 408.02986666 611.90826666 406.86933333 610.88426666 405.43573333 610.2016 404.20693333 609.24586666 398.47253333 604.80853333 391.64586666 601.6 383.93173333 601.6 383.72693333 601.6 383.59039999 601.73653333 383.38559999 601.73653333S382.97599999 601.6 382.77119999 601.6L112.29866666 601.6C92.50133333 601.6 76.79999999 616.96 76.79999999 635.73333333 76.66346666 654.50666666 92.63786666 669.86666666 112.16213333 669.86666666l189.44 0-214.15253334 214.15253334c-13.85813333 13.85813333-14.19946667 35.84-0.88746666 49.22026666 13.17546667 13.44853333 35.36213333 12.9024 49.152-0.95573333l214.08426666-214.08426667 0 189.37173334c0 19.59253333 15.42826667 35.49866667 34.2016 35.36213333C402.77333333 943.2064 418.13333333 927.232 418.13333333 907.5712L418.13333333 637.09866666c0-0.27306667-0.13653333-0.47786667-0.13653334-0.68266666C417.99679999 636.14293333 418.13333333 635.93813333 418.13333333 635.73333333zM739.46453333 669.86666666l189.44 0c19.456 0 35.49866667-15.36 35.36213333-34.13333333C964.26666666 616.96 948.56533333 601.6 928.76799999 601.6L658.29546666 601.6C658.09066666 601.6 657.88586666 601.73653333 657.68106666 601.73653333S657.33973333 601.6 657.13493333 601.6C649.42079999 601.6 642.59413333 604.80853333 636.85973333 609.24586666 635.63093333 610.2016 634.19733333 610.88426666 633.03679999 611.90826666 632.76373333 612.2496 632.62719999 612.72746666 632.28586666 613.0688 626.61973333 619.14453333 622.93333333 626.92693333 622.93333333 635.73333333c0 0.2048 0.13653333 0.4096 0.13653333 0.68266667C623.06986666 636.6208 622.93333333 636.8256 622.93333333 637.09866666l0 270.5408C622.93333333 927.232 638.29333333 943.2064 657.06666666 942.93333333c18.77333333 0.13653333 34.2016-15.70133333 34.2016-35.36213333l0-189.37173334 214.08426667 214.08426667c13.78986667 13.85813333 35.90826667 14.40426667 49.152 0.95573333 13.312-13.312 12.97066667-35.36213333-0.88746667-49.22026666L739.46453333 669.86666666z"  ></path></symbol>
    <symbol id="request-fullscreen" viewBox="0 0 1024 1024">
      <path d="M69.818182 87.598545v273.128728a34.909091 34.909091 0 0 0 69.818182 0V163.653818l221.928727 222.021818a33.512727 33.512727 0 0 0 47.383273-47.383272L186.926545 116.363636h197.073455a34.909091 34.909091 0 0 0 0-69.818181H110.871273C85.364364 46.545455 69.818182 59.671273 69.818182 87.598545zM938.542545 46.545455H665.413818a34.909091 34.909091 0 0 0 0 69.818181h197.073455L640.465455 338.292364a33.512727 33.512727 0 0 0 47.383272 47.383272l221.928728-222.021818v197.073455a34.909091 34.909091 0 0 0 69.818181 0V87.598545c0-27.927273-15.453091-41.053091-40.96-41.05309z m-827.671272 907.636363h273.128727a34.909091 34.909091 0 0 0 0-69.818182H186.926545l222.021819-221.928727a33.512727 33.512727 0 0 0-47.383273-47.383273L139.636364 837.073455V640a34.909091 34.909091 0 0 0-69.818182 0v273.128727c0 27.927273 15.546182 41.053091 41.053091 41.053091z m868.724363-41.053091V640a34.909091 34.909091 0 0 0-69.818181 0v197.073455L687.941818 615.051636a33.512727 33.512727 0 0 0-47.383273 47.383273L862.487273 884.363636H665.413818a34.909091 34.909091 0 0 0 0 69.818182h273.128727c25.6 0 41.053091-13.125818 41.053091-41.053091z"  ></path></symbol>
  </svg>
`;

// node_modules/@antv/g6/esm/plugins/toolbar/index.js
var __awaiter19 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Toolbar = class _Toolbar extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, _Toolbar.defaultOptions, options));
    this.$element = createPluginContainer("toolbar", false);
    this.onToolbarItemClick = (e2) => {
      const { onClick } = this.options;
      if (e2.target instanceof Element) {
        if (e2.target.className.includes("g6-toolbar-item")) {
          const v3 = e2.target.getAttribute("value");
          onClick === null || onClick === void 0 ? void 0 : onClick(v3, e2.target);
        }
      }
    };
    const $container = this.context.canvas.getContainer();
    this.$element.style.display = "flex";
    $container.appendChild(this.$element);
    insertDOM("g6-toolbar-css", "style", {}, TOOLBAR_CSS, document.head);
    insertDOM("g6-toolbar-svgicon", "div", { display: "none" }, BUILD_IN_SVG_ICON);
    this.$element.addEventListener("click", this.onToolbarItemClick);
    this.update(options);
  }
  /**
   * <zh/> 
   *
   * <en/> Update the configuration of the toolbar
   * @param options - <zh/>  | <en/> The options of the toolbar
   * @internal
   */
  update(options) {
    const _super = Object.create(null, {
      update: { get: () => super.update }
    });
    return __awaiter19(this, void 0, void 0, function* () {
      _super.update.call(this, options);
      const { className, position: position2, style } = this.options;
      this.$element.className = `g6-toolbar ${className || ""}`;
      Object.assign(this.$element.style, style, parsePositionToStyle(position2));
      this.$element.innerHTML = yield this.getDOMContent();
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy the toolbar
   * @internal
   */
  destroy() {
    this.$element.removeEventListener("click", this.onToolbarItemClick);
    this.$element.remove();
    super.destroy();
  }
  getDOMContent() {
    return __awaiter19(this, void 0, void 0, function* () {
      const items = yield this.options.getItems();
      return items.map((item) => {
        var _a;
        return `
          <div class="g6-toolbar-item" value="${item.value}" title="${(_a = item.title) !== null && _a !== void 0 ? _a : ""}">
            <svg aria-hidden="true" focusable="false">
              <use xlink:href="#${item.id}"></use>
            </svg>
          </div>`;
      }).join("");
    });
  }
};
Toolbar.defaultOptions = {
  position: "top-left"
};

// node_modules/@antv/g6/esm/plugins/tooltip.js
var __awaiter20 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Tooltip2 = class _Tooltip extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, _Tooltip.defaultOptions, options));
    this.currentTarget = null;
    this.tooltipElement = null;
    this.container = null;
    this.isEnable = (event, items) => {
      const { enable } = this.options;
      if (typeof enable === "function") {
        return enable(event, items);
      }
      return enable;
    };
    this.onClick = (event) => {
      const { target: { id } } = event;
      if (this.currentTarget === id) {
        this.hide(event);
      } else {
        this.show(event);
      }
    };
    this.onPointerMove = (event) => {
      const { target } = event;
      if (!this.currentTarget || target.id === this.currentTarget) {
        return;
      }
      this.show(event);
    };
    this.onPointerLeave = (event) => {
      this.hide(event);
    };
    this.onCanvasMove = (event) => {
      this.hide(event);
    };
    this.onPointerOver = (event) => {
      this.show(event);
    };
    this.showById = (id) => __awaiter20(this, void 0, void 0, function* () {
      const event = {
        target: { id }
      };
      yield this.show(event);
    });
    this.getElementData = (id, targetType) => {
      const { model } = this.context;
      switch (targetType) {
        case "node":
          return model.getNodeData([id]);
        case "edge":
          return model.getEdgeData([id]);
        case "combo":
          return model.getComboData([id]);
        default:
          return [];
      }
    };
    this.show = (event) => __awaiter20(this, void 0, void 0, function* () {
      var _a, _b;
      const { client, target: { id } } = event;
      if (isToBeDestroyed(event.target))
        return;
      const targetType = this.context.graph.getElementType(id);
      const { getContent, title } = this.options;
      const items = this.getElementData(id, targetType);
      if (!this.tooltipElement)
        return;
      if (!this.isEnable(event, items)) {
        this.hide(event);
        return;
      }
      let tooltipContent = {};
      if (getContent) {
        tooltipContent.content = yield getContent(event, items);
        if (!tooltipContent.content)
          return;
      } else {
        const style = this.context.graph.getElementRenderStyle(id);
        const color = targetType === "node" ? style.fill : style.stroke;
        tooltipContent = {
          title: title || targetType,
          data: items.map((item) => {
            return {
              name: "ID",
              value: item.id || `${item.source} -> ${item.target}`,
              color
            };
          })
        };
      }
      this.currentTarget = id;
      let x4;
      let y4;
      if (client) {
        x4 = client.x;
        y4 = client.y;
      } else {
        const style = get_default(items, "0.style", { x: 0, y: 0 });
        x4 = style.x;
        y4 = style.y;
      }
      (_b = (_a = this.options).onOpenChange) === null || _b === void 0 ? void 0 : _b.call(_a, true);
      this.tooltipElement.update(Object.assign(Object.assign(Object.assign({}, this.tooltipStyleProps), {
        x: x4,
        y: y4,
        style: {
          ".tooltip": {
            visibility: "visible"
          }
        }
      }), tooltipContent));
    });
    this.hide = (event) => {
      var _a, _b, _c, _d, _e2;
      if (!event) {
        (_b = (_a = this.options).onOpenChange) === null || _b === void 0 ? void 0 : _b.call(_a, false);
        (_c = this.tooltipElement) === null || _c === void 0 ? void 0 : _c.hide();
        this.currentTarget = null;
        return;
      }
      if (!this.tooltipElement)
        return;
      if (!this.currentTarget)
        return;
      const { client: { x: x4, y: y4 } } = event;
      (_e2 = (_d = this.options).onOpenChange) === null || _e2 === void 0 ? void 0 : _e2.call(_d, false);
      this.tooltipElement.hide(x4, y4);
      this.currentTarget = null;
    };
    this.initTooltip = () => {
      var _a;
      const tooltipElement = new Tooltip({
        className: "tooltip",
        style: this.tooltipStyleProps
      });
      (_a = this.container) === null || _a === void 0 ? void 0 : _a.appendChild(tooltipElement.HTMLTooltipElement);
      return tooltipElement;
    };
    this.render();
    this.bindEvents();
  }
  /**
   * <zh/> 
   *
   * <en/> Get event and handle event methods
   * @returns <zh/>  | <en/> Event and handling event methods
   */
  getEvents() {
    if (this.options.trigger === "click") {
      return {
        "node:click": this.onClick,
        "edge:click": this.onClick,
        "combo:click": this.onClick,
        "canvas:click": this.onPointerLeave,
        contextmenu: this.onPointerLeave,
        drag: this.onPointerLeave
      };
    }
    return {
      "node:pointerover": this.onPointerOver,
      "node:pointermove": this.onPointerMove,
      "canvas:pointermove": this.onCanvasMove,
      "edge:pointerover": this.onPointerOver,
      "edge:pointermove": this.onPointerMove,
      "combo:pointerover": this.onPointerOver,
      "combo:pointermove": this.onPointerMove,
      contextmenu: this.onPointerLeave,
      "node:drag": this.onPointerLeave
    };
  }
  /**
   * <zh/> tooltip
   *
   * <en/> Update the tooltip configuration
   * @param options - <zh/>  | <en/> options
   * @internal
   */
  update(options) {
    var _a;
    this.unbindEvents();
    super.update(options);
    if (this.tooltipElement) {
      (_a = this.container) === null || _a === void 0 ? void 0 : _a.removeChild(this.tooltipElement.HTMLTooltipElement);
    }
    this.tooltipElement = this.initTooltip();
    this.bindEvents();
  }
  render() {
    const { canvas: canvas2 } = this.context;
    const $container = canvas2.getContainer();
    if (!$container)
      return;
    this.container = $container;
    this.tooltipElement = this.initTooltip();
  }
  unbindEvents() {
    const { graph } = this.context;
    const events = this.getEvents();
    Object.keys(events).forEach((eventName) => {
      graph.off(eventName, events[eventName]);
    });
  }
  bindEvents() {
    const { graph } = this.context;
    const events = this.getEvents();
    Object.keys(events).forEach((eventName) => {
      graph.on(eventName, events[eventName]);
    });
  }
  get tooltipStyleProps() {
    const { canvas: canvas2 } = this.context;
    const { center } = canvas2.getBounds();
    const $container = canvas2.getContainer();
    const { top, left } = $container.getBoundingClientRect();
    const { style, position: position2, enterable, container = { x: -left, y: -top }, title, offset } = this.options;
    const [x4, y4] = center;
    const [width2, height] = canvas2.getSize();
    return {
      x: x4,
      y: y4,
      container,
      title,
      bounding: { x: 0, y: 0, width: width2, height },
      position: position2,
      enterable,
      offset,
      style
    };
  }
  /**
   * <zh/> tooltip
   *
   * <en/> Destroy tooltip
   * @internal
   */
  destroy() {
    var _a;
    this.unbindEvents();
    if (this.tooltipElement) {
      (_a = this.container) === null || _a === void 0 ? void 0 : _a.removeChild(this.tooltipElement.HTMLTooltipElement);
    }
    super.destroy();
  }
};
Tooltip2.defaultOptions = {
  trigger: "hover",
  position: "top-right",
  enterable: false,
  enable: true,
  offset: [10, 10],
  style: {
    ".tooltip": {
      visibility: "hidden"
    }
  }
};

// node_modules/@antv/g6/esm/plugins/watermark/util.js
var __awaiter21 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var canvas;
function createCanvas(width2, height) {
  if (!canvas) {
    canvas = document.createElement("canvas");
  }
  canvas.width = width2;
  canvas.height = height;
  const ctx3 = canvas.getContext("2d");
  ctx3.clearRect(0, 0, width2, height);
  return canvas;
}
function getTextWatermark(width2, height, text, style) {
  return __awaiter21(this, void 0, void 0, function* () {
    const canvas2 = createCanvas(width2, height);
    const ctx3 = canvas2.getContext("2d");
    const { rotate: rotate2, opacity, textFill, textFontSize, textFontFamily, textFontVariant, textFontWeight, textAlign, textBaseline } = style;
    ctx3.textAlign = textAlign;
    ctx3.textBaseline = textBaseline;
    ctx3.translate(width2 / 2, height / 2);
    ctx3.font = `${textFontSize}px ${textFontFamily} ${textFontVariant} ${textFontWeight}`;
    rotate2 && ctx3.rotate(rotate2);
    opacity && (ctx3.globalAlpha = opacity);
    if (textFill) {
      ctx3.fillStyle = textFill;
      ctx3.fillText(`${text}`, 0, 0);
    }
    return canvas2.toDataURL();
  });
}
function getImageWatermark(width2, height, imageURL, style) {
  return __awaiter21(this, void 0, void 0, function* () {
    const canvas2 = createCanvas(width2, height);
    const ctx3 = canvas2.getContext("2d");
    const { rotate: rotate2, opacity } = style;
    rotate2 && ctx3.rotate(rotate2);
    opacity && (ctx3.globalAlpha = opacity);
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.src = imageURL;
    return new Promise((resolve) => {
      img.onload = function() {
        const sepX = width2 > img.width ? (width2 - img.width) / 2 : 0;
        const sepY = height > img.height ? (height - img.height) / 2 : 0;
        ctx3.drawImage(img, 0, 0, img.width, img.height, sepX, sepY, width2 - sepX * 2, height - sepY * 2);
        resolve(canvas2.toDataURL());
      };
    });
  });
}

// node_modules/@antv/g6/esm/plugins/watermark/index.js
var __awaiter22 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest20 = function(s2, e2) {
  var t3 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t3[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t3[p3[i2]] = s2[p3[i2]];
    }
  return t3;
};
var Watermark = class _Watermark extends BasePlugin {
  constructor(context, options) {
    super(context, Object.assign({}, _Watermark.defaultOptions, options));
    this.$element = createPluginContainer("watermark");
    const $container = this.context.canvas.getContainer();
    $container.appendChild(this.$element);
    this.update(options);
  }
  /**
   * <zh/> 
   *
   * <en/> Update the watermark configuration
   * @param options - <zh/>  | <en/> Options
   * @internal
   */
  update(options) {
    const _super = Object.create(null, {
      update: { get: () => super.update }
    });
    return __awaiter22(this, void 0, void 0, function* () {
      _super.update.call(this, options);
      const _a = this.options, { width: width2, height, text, imageURL } = _a, rest = __rest20(_a, ["width", "height", "text", "imageURL"]);
      Object.keys(rest).forEach((key) => {
        if (key.startsWith("background")) {
          this.$element.style[key] = options[key];
        }
      });
      const base64 = imageURL ? yield getImageWatermark(width2, height, imageURL, rest) : yield getTextWatermark(width2, height, text, rest);
      this.$element.style.backgroundImage = `url(${base64})`;
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy the watermark
   * @internal
   */
  destroy() {
    super.destroy();
    this.$element.remove();
  }
};
Watermark.defaultOptions = {
  width: 200,
  height: 100,
  opacity: 0.2,
  rotate: Math.PI / 12,
  text: "",
  textFill: "#000",
  textFontSize: 16,
  textAlign: "center",
  textBaseline: "middle",
  backgroundRepeat: "repeat"
};

// node_modules/@antv/g6/esm/themes/base.js
var BADGE_PALETTE = ["#7E92B5", "#F4664A", "#FFBE3A"];
var NODE_PALETTE_OPTIONS = {
  type: "group",
  color: ["#1783FF", "#00C9C9", "#F08F56", "#D580FF", "#7863FF", "#DB9D0D", "#60C42D", "#FF80CA", "#2491B3", "#17C76F"]
};
var EDGE_PALETTE_OPTIONS = {
  type: "group",
  color: [
    "#99ADD1",
    "#1783FF",
    "#00C9C9",
    "#F08F56",
    "#D580FF",
    "#7863FF",
    "#DB9D0D",
    "#60C42D",
    "#FF80CA",
    "#2491B3",
    "#17C76F"
  ]
};
function create(tokens3) {
  const { bgColor, textColor, nodeColor, nodeColorDisabled, nodeStroke, nodeHaloStrokeOpacityActive = 0.15, nodeHaloStrokeOpacitySelected = 0.25, nodeOpacityDisabled = 0.06, nodeIconOpacityInactive = 0.85, nodeOpacityInactive = 0.25, nodeBadgePalette = BADGE_PALETTE, nodePaletteOptions = NODE_PALETTE_OPTIONS, edgeColor, edgeColorDisabled, edgePaletteOptions = EDGE_PALETTE_OPTIONS, comboColor, comboColorDisabled, comboStroke, comboStrokeDisabled, edgeColorInactive } = tokens3;
  return {
    background: bgColor,
    node: {
      palette: nodePaletteOptions,
      style: {
        donutOpacity: 1,
        badgeBackgroundOpacity: 1,
        badgeFill: "#fff",
        badgeFontSize: 8,
        badgePadding: [0, 4],
        badgePalette: nodeBadgePalette,
        fill: nodeColor,
        fillOpacity: 1,
        halo: false,
        iconFill: "#fff",
        iconOpacity: 1,
        labelBackground: false,
        labelBackgroundFill: bgColor,
        labelBackgroundLineWidth: 0,
        labelBackgroundOpacity: 0.75,
        labelFill: textColor,
        labelFillOpacity: 0.85,
        labelLineHeight: 16,
        labelPadding: [0, 2],
        labelFontSize: 12,
        labelFontWeight: 400,
        labelOpacity: 1,
        labelOffsetY: 2,
        lineWidth: 0,
        portFill: nodeColor,
        portLineWidth: 1,
        portStroke: nodeStroke,
        portStrokeOpacity: 0.65,
        size: 32,
        stroke: nodeStroke,
        strokeOpacity: 1,
        zIndex: 2
      },
      state: {
        selected: {
          halo: true,
          haloLineWidth: 24,
          haloStrokeOpacity: nodeHaloStrokeOpacitySelected,
          labelFontSize: 12,
          labelFontWeight: "bold",
          lineWidth: 4,
          stroke: nodeStroke
        },
        active: {
          halo: true,
          haloLineWidth: 12,
          haloStrokeOpacity: nodeHaloStrokeOpacityActive
        },
        highlight: {
          labelFontWeight: "bold",
          lineWidth: 4,
          stroke: nodeStroke,
          strokeOpacity: 0.85
        },
        inactive: {
          badgeBackgroundOpacity: nodeOpacityInactive,
          donutOpacity: nodeOpacityInactive,
          fillOpacity: nodeOpacityInactive,
          iconOpacity: nodeIconOpacityInactive,
          labelFill: textColor,
          labelFillOpacity: nodeOpacityInactive,
          strokeOpacity: nodeOpacityInactive
        },
        disabled: {
          badgeBackgroundOpacity: 0.25,
          donutOpacity: nodeOpacityDisabled,
          fill: nodeColorDisabled,
          fillOpacity: nodeOpacityDisabled,
          iconFill: nodeColorDisabled,
          iconOpacity: 0.25,
          labelFill: textColor,
          labelFillOpacity: 0.25,
          strokeOpacity: nodeOpacityDisabled
        }
      },
      animation: {
        enter: "fade",
        exit: "fade",
        show: "fade",
        hide: "fade",
        expand: "node-expand",
        collapse: "node-collapse",
        update: [{ fields: ["x", "y", "fill", "stroke"] }],
        translate: [{ fields: ["x", "y"] }]
      }
    },
    edge: {
      palette: edgePaletteOptions,
      style: {
        badgeBackgroundFill: edgeColor,
        badgeFill: "#fff",
        badgeFontSize: 8,
        badgeOffsetX: 10,
        badgeBackgroundOpacity: 1,
        fillOpacity: 1,
        halo: false,
        haloLineWidth: 12,
        haloStrokeOpacity: 1,
        increasedLineWidthForHitTesting: 2,
        labelBackground: false,
        labelBackgroundFill: bgColor,
        labelBackgroundLineWidth: 0,
        labelBackgroundOpacity: 0.75,
        labelBackgroundPadding: [4, 4, 4, 4],
        labelFill: textColor,
        labelFontSize: 12,
        labelFontWeight: 400,
        labelOpacity: 1,
        labelPlacement: "center",
        labelTextBaseline: "middle",
        lineWidth: 1,
        stroke: edgeColor,
        strokeOpacity: 1,
        zIndex: 1
      },
      state: {
        selected: {
          halo: true,
          haloStrokeOpacity: 0.25,
          labelFontSize: 14,
          labelFontWeight: "bold",
          lineWidth: 3
        },
        active: {
          halo: true,
          haloStrokeOpacity: 0.15
        },
        highlight: {
          labelFontWeight: "bold",
          lineWidth: 3
        },
        inactive: {
          stroke: edgeColorInactive,
          fillOpacity: 0.08,
          labelOpacity: 0.25,
          strokeOpacity: 0.08,
          badgeBackgroundOpacity: 0.25
        },
        disabled: {
          stroke: edgeColorDisabled,
          fillOpacity: 0.45,
          strokeOpacity: 0.45,
          labelOpacity: 0.25,
          badgeBackgroundOpacity: 0.45
        }
      },
      animation: {
        enter: "fade",
        exit: "fade",
        expand: "path-in",
        collapse: "path-out",
        show: "fade",
        hide: "fade",
        update: [{ fields: ["sourceNode", "targetNode"] }, { fields: ["stroke"], shape: "key" }],
        translate: [{ fields: ["sourceNode", "targetNode"] }]
      }
    },
    combo: {
      style: {
        collapsedMarkerFill: bgColor,
        collapsedMarkerFontSize: 12,
        collapsedMarkerFillOpacity: 1,
        collapsedSize: 32,
        collapsedFillOpacity: 1,
        fill: comboColor,
        halo: false,
        haloLineWidth: 12,
        haloStroke: comboStroke,
        haloStrokeOpacity: 0.25,
        labelBackground: false,
        labelBackgroundFill: bgColor,
        labelBackgroundLineWidth: 0,
        labelBackgroundOpacity: 0.75,
        labelBackgroundPadding: [2, 4, 2, 4],
        labelFill: textColor,
        labelFontSize: 12,
        labelFontWeight: 400,
        labelOpacity: 1,
        lineDash: 0,
        lineWidth: 1,
        fillOpacity: 0.04,
        strokeOpacity: 1,
        padding: 10,
        stroke: comboStroke
      },
      state: {
        selected: {
          halo: true,
          labelFontSize: 14,
          labelFontWeight: 700,
          lineWidth: 4
        },
        active: {
          halo: true
        },
        highlight: {
          labelFontWeight: 700,
          lineWidth: 4
        },
        inactive: {
          fillOpacity: 0.65,
          labelOpacity: 0.25,
          strokeOpacity: 0.65
        },
        disabled: {
          fill: comboColorDisabled,
          fillOpacity: 0.25,
          labelOpacity: 0.25,
          stroke: comboStrokeDisabled,
          strokeOpacity: 0.25
        }
      },
      animation: {
        enter: "fade",
        exit: "fade",
        show: "fade",
        hide: "fade",
        expand: "combo-expand",
        collapse: "combo-collapse",
        update: [{ fields: ["x", "y"] }, { fields: ["fill", "stroke", "lineWidth"], shape: "key" }],
        translate: [{ fields: ["x", "y"] }]
      }
    }
  };
}

// node_modules/@antv/g6/esm/themes/dark.js
var EDGE_PALETTE_OPTIONS2 = {
  type: "group",
  color: [
    "#637088",
    "#0F55A6",
    "#008383",
    "#9C5D38",
    "#8B53A6",
    "#4E40A6",
    "#8F6608",
    "#3E801D",
    "#A65383",
    "#175E75",
    "#0F8248"
  ]
};
var tokens = {
  bgColor: "#000000",
  comboColor: "#fdfdfd",
  comboColorDisabled: "#d0e4ff",
  comboStroke: "#99add1",
  comboStrokeDisabled: "#969696",
  edgeColor: "#637088",
  edgeColorDisabled: "#637088",
  edgeColorInactive: "#D0E4FF",
  edgePaletteOptions: EDGE_PALETTE_OPTIONS2,
  nodeColor: "#1783ff",
  nodeColorDisabled: "#D0E4FF",
  nodeHaloStrokeOpacityActive: 0.25,
  nodeHaloStrokeOpacitySelected: 0.45,
  nodeIconOpacityInactive: 0.45,
  nodeOpacityDisabled: 0.25,
  nodeOpacityInactive: 0.45,
  nodeStroke: "#d0e4ff",
  textColor: "#ffffff"
};
var dark = create(tokens);

// node_modules/@antv/g6/esm/themes/light.js
var tokens2 = {
  bgColor: "#ffffff",
  comboColor: "#99ADD1",
  comboColorDisabled: "#f0f0f0",
  comboStroke: "#99add1",
  comboStrokeDisabled: "#d9d9d9",
  edgeColor: "#99add1",
  edgeColorDisabled: "#d9d9d9",
  edgeColorInactive: "#1B324F",
  nodeColor: "#1783ff",
  nodeColorDisabled: "#1B324F",
  nodeHaloStrokeOpacityActive: 0.15,
  nodeHaloStrokeOpacitySelected: 0.25,
  nodeIconOpacityInactive: 0.85,
  nodeOpacityDisabled: 0.06,
  nodeOpacityInactive: 0.25,
  nodeStroke: "#000000",
  textColor: "#000000"
};
var light = create(tokens2);

// node_modules/@antv/g6/esm/transforms/base-transform.js
var BaseTransform = class extends BaseExtension {
  beforeDraw(data, context) {
    return data;
  }
  afterLayout(type, data) {
  }
};

// node_modules/@antv/g6/esm/transforms/arrange-draw-order.js
var ArrangeDrawOrder = class extends BaseTransform {
  beforeDraw(input) {
    const { model } = this.context;
    const combosToAdd = input.add.combos;
    const arrangeCombo = (combos) => {
      const order2 = [];
      combos.forEach((combo, id) => {
        const ancestors = model.getAncestorsData(id, "combo");
        const path = ancestors.map((ancestor) => idOf(ancestor)).reverse();
        order2.push([id, combo, path.length]);
      });
      return new Map(order2.sort(([, , zIndex1], [, , zIndex2]) => zIndex2 - zIndex1).map(([id, datum]) => [id, datum]));
    };
    input.add.combos = arrangeCombo(combosToAdd);
    input.update.combos = arrangeCombo(input.update.combos);
    return input;
  }
};

// node_modules/@antv/g6/esm/transforms/utils.js
function reassignTo(input, type, elementType, datum, overwrite) {
  const id = idOf(datum);
  const typeName = `${elementType}s`;
  const exitsDatum = overwrite ? datum : input.add[typeName].get(id) || input.update[typeName].get(id) || input.remove[typeName].get(id) || datum;
  Object.entries(input).forEach(([_type, value]) => {
    if (type === _type)
      value[typeName].set(id, exitsDatum);
    else
      value[typeName].delete(id);
  });
}
function isStyleEqual(style, originalStyle) {
  return Object.keys(style).every((key) => style[key] === originalStyle[key]);
}

// node_modules/@antv/g6/esm/transforms/collapse-expand-combo.js
var CollapseExpandCombo = class extends BaseTransform {
  beforeDraw(input, context) {
    if (context.stage === "visibility")
      return input;
    if (!this.context.model.model.hasTreeStructure(COMBO_KEY))
      return input;
    const { model } = this.context;
    const { add: add4, update } = input;
    const combos = [...input.update.combos.entries(), ...input.add.combos.entries()];
    while (combos.length) {
      const [id, combo] = combos.pop();
      if (isCollapsed(combo)) {
        const descendants = model.getDescendantsData(id);
        const descendantIds = descendants.map(idOf);
        const { internal, external } = getSubgraphRelatedEdges(descendantIds, (id2) => model.getRelatedEdgesData(id2));
        descendants.forEach((descendant) => {
          const descendantId = idOf(descendant);
          const comboIndex = combos.findIndex(([id2]) => id2 === descendantId);
          if (comboIndex !== -1)
            combos.splice(comboIndex, 1);
          const elementType = model.getElementType(descendantId);
          reassignTo(input, "remove", elementType, descendant);
        });
        internal.forEach((edge) => reassignTo(input, "remove", "edge", edge));
        external.forEach((edge) => {
          var _a;
          const id2 = idOf(edge);
          const edgeElement = (_a = this.context.element) === null || _a === void 0 ? void 0 : _a.getElement(id2);
          if (edgeElement)
            update.edges.set(id2, edge);
          else
            add4.edges.set(id2, edge);
        });
      } else {
        const children = model.getChildrenData(id);
        const childrenIds = children.map(idOf);
        const { edges } = getSubgraphRelatedEdges(childrenIds, (id2) => model.getRelatedEdgesData(id2));
        [...children, ...edges].forEach((descendant) => {
          var _a;
          const id2 = idOf(descendant);
          const elementType = model.getElementType(id2);
          const element = (_a = this.context.element) === null || _a === void 0 ? void 0 : _a.getElement(id2);
          if (element)
            reassignTo(input, "update", elementType, descendant);
          else
            reassignTo(input, "add", elementType, descendant);
          if (elementType === "combo")
            combos.push([id2, descendant]);
        });
      }
    }
    return input;
  }
};

// node_modules/@antv/g6/esm/transforms/collapse-expand-node.js
var weakAssignTo = (input, type, elementType, datum) => {
  const typeName = `${elementType}s`;
  const id = idOf(datum);
  if (!input.add[typeName].has(id) && !input.update[typeName].has(id)) {
    input[type][typeName].set(idOf(datum), datum);
  }
};
var CollapseExpandNode = class extends BaseTransform {
  getElement(id) {
    return this.context.element.getElement(id);
  }
  handleExpand(node, input) {
    weakAssignTo(input, "add", "node", node);
    if (isCollapsed(node))
      return;
    const id = idOf(node);
    weakAssignTo(input, "add", "node", node);
    const relatedEdges = this.context.model.getRelatedEdgesData(id);
    relatedEdges.forEach((edge) => {
      reassignTo(input, "add", "edge", edge);
    });
    const children = this.context.model.getChildrenData(id);
    children.forEach((child) => {
      this.handleExpand(child, input);
    });
  }
  beforeDraw(input) {
    const { graph, model } = this.context;
    if (!model.model.hasTreeStructure(TREE_KEY))
      return input;
    const { add: { nodes: nodesToAdd, edges: edgesToAdd }, update: { nodes: nodesToUpdate } } = input;
    const nodesToCollapse = /* @__PURE__ */ new Map();
    const nodesToExpand = /* @__PURE__ */ new Map();
    nodesToAdd.forEach((node, id) => {
      if (isCollapsed(node))
        nodesToCollapse.set(id, node);
    });
    edgesToAdd.forEach((edge) => {
      if (graph.getElementType(edge.source) !== "node")
        return;
      const source = graph.getNodeData(edge.source);
      if (isCollapsed(source))
        nodesToCollapse.set(edge.source, source);
    });
    nodesToUpdate.forEach((node, id) => {
      const nodeElement = this.getElement(id);
      if (!nodeElement)
        return;
      const isCurrentCollapsed = nodeElement.attributes.collapsed;
      if (isCollapsed(node)) {
        if (!isCurrentCollapsed)
          nodesToCollapse.set(id, node);
      } else {
        if (isCurrentCollapsed)
          nodesToExpand.set(id, node);
      }
    });
    const handledNodes = /* @__PURE__ */ new Set();
    nodesToCollapse.forEach((node, id) => {
      const descendants = model.getDescendantsData(id);
      descendants.forEach((descendant) => {
        const id2 = idOf(descendant);
        if (handledNodes.has(id2))
          return;
        reassignTo(input, "remove", "node", descendant);
        const relatedEdges = model.getRelatedEdgesData(id2);
        relatedEdges.forEach((edge) => {
          reassignTo(input, "remove", "edge", edge);
        });
        handledNodes.add(id2);
      });
    });
    nodesToExpand.forEach((node, id) => {
      const ancestors = model.getAncestorsData(id, TREE_KEY);
      if (ancestors.some(isCollapsed)) {
        reassignTo(input, "remove", "node", node);
        return;
      }
      this.handleExpand(node, input);
    });
    return input;
  }
};

// node_modules/@antv/g6/esm/elements/effect.js
var EFFECT_WEAKMAP = /* @__PURE__ */ new WeakMap();
function effect(target, key, style) {
  if (!EFFECT_WEAKMAP.has(target))
    EFFECT_WEAKMAP.set(target, {});
  const cache = EFFECT_WEAKMAP.get(target);
  if (!cache[key]) {
    cache[key] = style;
    return true;
  }
  const original = cache[key];
  if (isStyleEqual2(original, style))
    return false;
  cache[key] = style;
  return true;
}
var isStyleEqual2 = (a3, b3, depth = 2) => {
  if (typeof a3 !== "object" || typeof b3 !== "object")
    return a3 === b3;
  const keys1 = Object.keys(a3);
  const keys2 = Object.keys(b3);
  if (keys1.length !== keys2.length)
    return false;
  for (const key of keys1) {
    const val1 = a3[key];
    const val2 = b3[key];
    if (depth > 1 && typeof val1 === "object" && typeof val2 === "object") {
      if (!isStyleEqual2(val1, val2, depth - 1))
        return false;
    } else if (val1 !== val2)
      return false;
  }
  return true;
};

// node_modules/@antv/g6/esm/registry/register.js
function register(category, type, Ctor) {
  const ext = EXTENSION_REGISTRY[category][type];
  if (ext) {
    print.warn(`The extension ${type} of ${category} has been registered before, and will be overridden.`);
  }
  Object.assign(EXTENSION_REGISTRY[category], { [type]: Ctor });
}

// node_modules/@antv/g6/esm/runtime/canvas.js
var __awaiter23 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest21 = function(s2, e2) {
  var t3 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t3[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t3[p3[i2]] = s2[p3[i2]];
    }
  return t3;
};
var SINGLE_LAYER_NAME = ["main"];
var MULTI_LAYER_NAME = ["background", "main", "label", "transient"];
function getMainLayerOf(layers) {
  return layers.main;
}
var Canvas2 = class {
  getConfig() {
    return this.config;
  }
  getLayer(layer = "main") {
    return this.extends.layers[layer] || getMainLayerOf(this.getLayers());
  }
  /**
   * <zh/> 
   *
   * <en/> Get all layers
   * @returns <zh/>  <en/> Layer
   */
  getLayers() {
    return this.extends.layers;
  }
  /**
   * <zh/> 
   *
   * <en/> Get renderer
   * @param layer - <zh/>  <en/> Layer
   * @returns <zh/>  <en/> Renderer
   */
  getRenderer(layer) {
    return this.extends.renderers[layer];
  }
  /**
   * <zh/> 
   *
   * <en/> Get camera
   * @param layer - <zh/>  <en/> Layer
   * @returns <zh/>  <en/> Camera
   */
  getCamera(layer = "main") {
    return this.getLayer(layer).getCamera();
  }
  getRoot(layer = "main") {
    return this.getLayer(layer).getRoot();
  }
  getContextService(layer = "main") {
    return this.getLayer(layer).getContextService();
  }
  setCursor(cursor) {
    this.config.cursor = cursor;
    this.getLayer().setCursor(cursor);
  }
  get document() {
    return this.getLayer().document;
  }
  get context() {
    return this.getLayer().context;
  }
  constructor(config) {
    this.config = {
      enableMultiLayer: true
    };
    Object.assign(this.config, config);
    const _a = this.config, { renderer, background, cursor, enableMultiLayer } = _a, restConfig = __rest21(_a, ["renderer", "background", "cursor", "enableMultiLayer"]);
    const layersName = enableMultiLayer ? MULTI_LAYER_NAME : SINGLE_LAYER_NAME;
    const renderers = createRenderers(renderer, layersName);
    const layers = Object.fromEntries(layersName.map((layer) => {
      const canvas2 = new Canvas(Object.assign(Object.assign({}, restConfig), { supportsMutipleCanvasesInOneContainer: enableMultiLayer, renderer: renderers[layer], background: enableMultiLayer ? layer === "background" ? background : void 0 : background }));
      return [layer, canvas2];
    }));
    configCanvasDom(layers);
    this.extends = {
      config: this.config,
      renderer,
      renderers,
      layers
    };
  }
  get ready() {
    return Promise.all(Object.entries(this.getLayers()).map(([, canvas2]) => canvas2.ready));
  }
  resize(width2, height) {
    Object.assign(this.extends.config, { width: width2, height });
    Object.values(this.getLayers()).forEach((canvas2) => {
      const camera = canvas2.getCamera();
      const position2 = camera.getPosition();
      const focalPoint = camera.getFocalPoint();
      canvas2.resize(width2, height);
      camera.setPosition(position2);
      camera.setFocalPoint(focalPoint);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Get canvas boundary
   * @param group
   * <zh/> 
   * - undefined: 
   * - 'elements': 
   * - 'plugins': 
   *
   * <en/> Element group
   * - undefined: Get the entire canvas boundary
   * - 'elements': Get only the element boundary
   * - 'plugins': Get only the plugin boundary
   * @returns <zh/>  <en/> Boundary
   */
  getBounds(group) {
    return getCombinedBBox(Object.values(this.getLayers()).map((canvas2) => {
      const g3 = group ? canvas2.getRoot().childNodes.find((node) => node.classList.includes(group)) : canvas2.getRoot();
      return g3;
    }).filter((el) => (el === null || el === void 0 ? void 0 : el.childNodes.length) > 0).map((el) => el.getBounds()));
  }
  getContainer() {
    const container = this.extends.config.container;
    return typeof container === "string" ? document.getElementById(container) : container;
  }
  getSize() {
    return [this.extends.config.width || 0, this.extends.config.height || 0];
  }
  appendChild(child, index) {
    var _a;
    const layer = ((_a = child.style) === null || _a === void 0 ? void 0 : _a.$layer) || "main";
    return this.getLayer(layer).appendChild(child, index);
  }
  setRenderer(renderer) {
    if (renderer === this.extends.renderer)
      return;
    const renderers = createRenderers(renderer, this.config.enableMultiLayer ? MULTI_LAYER_NAME : SINGLE_LAYER_NAME);
    this.extends.renderers = renderers;
    Object.entries(renderers).forEach(([layer, instance]) => this.getLayer(layer).setRenderer(instance));
    configCanvasDom(this.getLayers());
  }
  getCanvasByViewport(point3) {
    return parsePoint(this.getLayer().viewport2Canvas(toPointObject(point3)));
  }
  getViewportByCanvas(point3) {
    return parsePoint(this.getLayer().canvas2Viewport(toPointObject(point3)));
  }
  getViewportByClient(point3) {
    return parsePoint(this.getLayer().client2Viewport(toPointObject(point3)));
  }
  getClientByViewport(point3) {
    return parsePoint(this.getLayer().viewport2Client(toPointObject(point3)));
  }
  getClientByCanvas(point3) {
    return this.getClientByViewport(this.getViewportByCanvas(point3));
  }
  getCanvasByClient(point3) {
    const main = this.getLayer();
    const viewportPoint = main.client2Viewport(toPointObject(point3));
    return parsePoint(main.viewport2Canvas(viewportPoint));
  }
  toDataURL() {
    return __awaiter23(this, arguments, void 0, function* (options = {}) {
      const devicePixelRatio = globalThis.devicePixelRatio || 1;
      const { mode = "viewport" } = options, restOptions = __rest21(options, ["mode"]);
      let [startX, startY, width2, height] = [0, 0, 0, 0];
      if (mode === "viewport") {
        [width2, height] = this.getSize();
      } else if (mode === "overall") {
        const bounds = this.getBounds();
        const size2 = getBBoxSize(bounds);
        [startX, startY] = bounds.min;
        [width2, height] = size2;
      }
      const container = createDOM('<div id="virtual-image"></div>');
      const offscreenCanvas = new Canvas({
        width: width2,
        height,
        renderer: new Renderer(),
        devicePixelRatio,
        container,
        background: this.extends.config.background
      });
      yield offscreenCanvas.ready;
      offscreenCanvas.appendChild(this.getLayer("background").getRoot().cloneNode(true));
      offscreenCanvas.appendChild(this.getRoot().cloneNode(true));
      const label = this.getLayer("label").getRoot().cloneNode(true);
      const originCanvasPosition = offscreenCanvas.viewport2Canvas({ x: 0, y: 0 });
      const currentCanvasPosition = this.getCanvasByViewport([0, 0]);
      label.translate([
        currentCanvasPosition[0] - originCanvasPosition.x,
        currentCanvasPosition[1] - originCanvasPosition.y
      ]);
      label.scale(1 / this.getCamera().getZoom());
      offscreenCanvas.appendChild(label);
      offscreenCanvas.appendChild(this.getLayer("transient").getRoot().cloneNode(true));
      const camera = this.getCamera();
      const offscreenCamera = offscreenCanvas.getCamera();
      if (mode === "viewport") {
        offscreenCamera.setZoom(camera.getZoom());
        offscreenCamera.setPosition(camera.getPosition());
        offscreenCamera.setFocalPoint(camera.getFocalPoint());
      } else if (mode === "overall") {
        const [x4, y4, z4] = offscreenCamera.getPosition();
        const [fx, fy, fz] = offscreenCamera.getFocalPoint();
        offscreenCamera.setPosition([x4 + startX, y4 + startY, z4]);
        offscreenCamera.setFocalPoint([fx + startX, fy + startY, fz]);
      }
      const contextService = offscreenCanvas.getContextService();
      return new Promise((resolve) => {
        offscreenCanvas.addEventListener(CanvasEvent.RERENDER, () => __awaiter23(this, void 0, void 0, function* () {
          yield new Promise((r3) => setTimeout(r3, 300));
          const url = yield contextService.toDataURL(restOptions);
          resolve(url);
        }));
      });
    });
  }
  destroy() {
    Object.values(this.getLayers()).forEach((canvas2) => {
      const camera = canvas2.getCamera();
      camera.cancelLandmarkAnimation();
      canvas2.destroy();
    });
  }
};
function createRenderers(renderer, layersName) {
  return Object.fromEntries(layersName.map((layer) => {
    const instance = (renderer === null || renderer === void 0 ? void 0 : renderer(layer)) || new Renderer();
    if (instance instanceof Renderer) {
      instance.setConfig({ enableDirtyRectangleRendering: false });
    }
    if (layer === "main") {
      instance.registerPlugin(new Plugin({
        isDocumentDraggable: true,
        isDocumentDroppable: true,
        dragstartDistanceThreshold: 10,
        dragstartTimeThreshold: 100
      }));
    } else {
      instance.unregisterPlugin(instance.getPlugin("dom-interaction"));
    }
    return [layer, instance];
  }));
}
function configCanvasDom(layers) {
  Object.entries(layers).forEach(([layer, canvas2]) => {
    const domElement = canvas2.getContextService().getDomElement();
    if (domElement === null || domElement === void 0 ? void 0 : domElement.style) {
      domElement.style.gridArea = "1 / 1 / 2 / 2";
      domElement.style.outline = "none";
      domElement.tabIndex = 1;
      if (layer !== "main")
        domElement.style.pointerEvents = "none";
    }
    if (domElement === null || domElement === void 0 ? void 0 : domElement.parentElement) {
      domElement.parentElement.style.display = "grid";
      domElement.parentElement.style.isolation = "isolate";
    }
  });
}

// node_modules/@antv/g6/esm/utils/dom.js
var parseInt10 = (d3) => d3 ? parseInt(d3) : 0;
function getContainerSize(container) {
  const style = getComputedStyle(container);
  const wrapperWidth = container.clientWidth || parseInt10(style.width);
  const wrapperHeight = container.clientHeight || parseInt10(style.height);
  const widthPadding = parseInt10(style.paddingLeft) + parseInt10(style.paddingRight);
  const heightPadding = parseInt10(style.paddingTop) + parseInt10(style.paddingBottom);
  return [wrapperWidth - widthPadding, wrapperHeight - heightPadding];
}
function sizeOf(container) {
  if (!container)
    return [0, 0];
  let effectiveWidth = 640;
  let effectiveHeight = 480;
  const [containerWidth, containerHeight] = getContainerSize(container);
  effectiveWidth = containerWidth || effectiveWidth;
  effectiveHeight = containerHeight || effectiveHeight;
  const MIN_CHART_WIDTH = 1;
  const MIN_CHART_HEIGHT = 1;
  return [
    Math.max(isNumber(effectiveWidth) ? effectiveWidth : MIN_CHART_WIDTH, MIN_CHART_WIDTH),
    Math.max(isNumber(effectiveHeight) ? effectiveHeight : MIN_CHART_HEIGHT, MIN_CHART_HEIGHT)
  ];
}

// node_modules/@antv/g6/esm/utils/event/events.js
var BaseEvent = class {
  constructor(type) {
    this.type = type;
  }
};
var GraphLifeCycleEvent = class extends BaseEvent {
  constructor(type, data) {
    super(type);
    this.data = data;
  }
};
var AnimateEvent = class extends BaseEvent {
  constructor(type, animationType, animation, data) {
    super(type);
    this.animationType = animationType;
    this.animation = animation;
    this.data = data;
  }
};
var ElementLifeCycleEvent = class extends BaseEvent {
  constructor(type, elementType, data) {
    super(type);
    this.elementType = elementType;
    this.data = data;
  }
};
var ViewportEvent = class extends BaseEvent {
  constructor(type, data) {
    super(type);
    this.data = data;
  }
};

// node_modules/@antv/g6/esm/utils/event/index.js
function emit(emitter, event) {
  emitter.emit(event.type, event);
}
function eventTargetOf(shape) {
  if (!shape)
    return null;
  if (shape instanceof Document) {
    return { type: "canvas", element: shape };
  }
  let element = shape;
  while (element) {
    if (isNode(element))
      return { type: "node", element };
    if (isEdge(element))
      return { type: "edge", element };
    if (isCombo(element))
      return { type: "combo", element };
    element = element.parentElement;
  }
  return null;
}

// node_modules/@antv/g6/esm/utils/z-index.js
function getZIndexOf(datum) {
  var _a;
  return ((_a = datum === null || datum === void 0 ? void 0 : datum.style) === null || _a === void 0 ? void 0 : _a.zIndex) || 0;
}

// node_modules/@antv/g6/esm/utils/cache.js
var CacheTargetKey = "cachedStyle";
var getStyleCacheKey = (name) => `__${name}__`;
function cacheStyle(element, name) {
  const names = Array.isArray(name) ? name : [name];
  if (!get_default(element, CacheTargetKey))
    set_default(element, CacheTargetKey, {});
  names.forEach((n2) => {
    set_default(get_default(element, CacheTargetKey), getStyleCacheKey(n2), element.attributes[n2]);
  });
}
function getCachedStyle(element, name) {
  return get_default(element, [CacheTargetKey, getStyleCacheKey(name)]);
}
function hasCachedStyle(element, name) {
  return getStyleCacheKey(name) in (get_default(element, CacheTargetKey) || {});
}

// node_modules/@antv/g6/esm/runtime/animation.js
var Animation = class {
  constructor(context) {
    this.tasks = [];
    this.animations = /* @__PURE__ */ new Set();
    this.context = context;
  }
  getTasks() {
    const tasks = [...this.tasks];
    this.tasks = [];
    return tasks;
  }
  add(context, callbacks) {
    this.tasks.push([context, callbacks]);
  }
  animate(localAnimation, callbacks, extendOptions) {
    var _a, _b, _c;
    (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.before) === null || _a === void 0 ? void 0 : _a.call(callbacks);
    const animations = this.getTasks().map(([context, cb]) => {
      var _a2, _b2, _c2;
      const { element, elementType, stage } = context;
      const options = getElementAnimationOptions(this.context.options, elementType, stage, localAnimation);
      (_a2 = cb === null || cb === void 0 ? void 0 : cb.before) === null || _a2 === void 0 ? void 0 : _a2.call(cb);
      const animation2 = options.length ? executor(element, this.inferStyle(context, extendOptions), options) : null;
      if (animation2) {
        (_b2 = cb === null || cb === void 0 ? void 0 : cb.beforeAnimate) === null || _b2 === void 0 ? void 0 : _b2.call(cb, animation2);
        animation2.finished.then(() => {
          var _a3, _b3;
          (_a3 = cb === null || cb === void 0 ? void 0 : cb.afterAnimate) === null || _a3 === void 0 ? void 0 : _a3.call(cb, animation2);
          (_b3 = cb === null || cb === void 0 ? void 0 : cb.after) === null || _b3 === void 0 ? void 0 : _b3.call(cb);
          this.animations.delete(animation2);
        });
      } else
        (_c2 = cb === null || cb === void 0 ? void 0 : cb.after) === null || _c2 === void 0 ? void 0 : _c2.call(cb);
      return animation2;
    }).filter(Boolean);
    animations.forEach((animation2) => this.animations.add(animation2));
    const animation = createAnimationsProxy(animations);
    if (animation) {
      (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.beforeAnimate) === null || _b === void 0 ? void 0 : _b.call(callbacks, animation);
      animation.finished.then(() => {
        var _a2, _b2;
        (_a2 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.afterAnimate) === null || _a2 === void 0 ? void 0 : _a2.call(callbacks, animation);
        (_b2 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.after) === null || _b2 === void 0 ? void 0 : _b2.call(callbacks);
        this.release();
      });
    } else
      (_c = callbacks === null || callbacks === void 0 ? void 0 : callbacks.after) === null || _c === void 0 ? void 0 : _c.call(callbacks);
    return animation;
  }
  /**
   * <zh/> 
   *
   * <en/> Infer additional animation styles
   * @param context - <zh/>  | <en/> Animation context
   * @param options - <zh/>  | <en/> Extend options
   * @returns <zh/>  | <en/> Initial style and final style
   */
  inferStyle(context, options) {
    var _a, _b;
    const { element, elementType, stage, originalStyle, updatedStyle = {} } = context;
    if (!context.modifiedStyle)
      context.modifiedStyle = Object.assign(Object.assign({}, originalStyle), updatedStyle);
    const { modifiedStyle } = context;
    const fromStyle = {};
    const toStyle = {};
    if (stage === "enter") {
      Object.assign(fromStyle, { opacity: 0 });
    } else if (stage === "exit") {
      Object.assign(toStyle, { opacity: 0 });
    } else if (stage === "show") {
      Object.assign(fromStyle, { opacity: 0 });
      Object.assign(toStyle, { opacity: (_a = getCachedStyle(element, "opacity")) !== null && _a !== void 0 ? _a : inferDefaultValue("opacity") });
    } else if (stage === "hide") {
      Object.assign(fromStyle, { opacity: (_b = getCachedStyle(element, "opacity")) !== null && _b !== void 0 ? _b : inferDefaultValue("opacity") });
      Object.assign(toStyle, { opacity: 0 });
    } else if (stage === "collapse") {
      const { collapse } = options || {};
      const { target, descendants, position: position2 } = collapse;
      if (elementType === "node") {
        if (descendants.includes(element.id)) {
          const [x4, y4, z4] = position2;
          Object.assign(toStyle, { x: x4, y: y4, z: z4 });
        }
      } else if (elementType === "combo") {
        if (element.id === target || descendants.includes(element.id)) {
          const [x4, y4] = position2;
          Object.assign(toStyle, { x: x4, y: y4, childrenNode: originalStyle.childrenNode });
        }
      } else if (elementType === "edge") {
        Object.assign(toStyle, { sourceNode: modifiedStyle.sourceNode, targetNode: modifiedStyle.targetNode });
      }
    } else if (stage === "expand") {
      const { expand } = options || {};
      const { target, descendants, position: position2 } = expand;
      if (elementType === "node") {
        if (element.id === target || descendants.includes(element.id)) {
          const [x4, y4, z4] = position2;
          Object.assign(fromStyle, { x: x4, y: y4, z: z4 });
        }
      } else if (elementType === "combo") {
        if (element.id === target || descendants.includes(element.id)) {
          const [x4, y4, z4] = position2;
          Object.assign(fromStyle, { x: x4, y: y4, z: z4, childrenNode: modifiedStyle.childrenNode });
        }
      } else if (elementType === "edge") {
        Object.assign(fromStyle, { sourceNode: modifiedStyle.sourceNode, targetNode: modifiedStyle.targetNode });
      }
    }
    return [
      Object.keys(fromStyle).length > 0 ? Object.assign({}, originalStyle, fromStyle) : originalStyle,
      Object.keys(toStyle).length > 0 ? Object.assign({}, modifiedStyle, toStyle) : modifiedStyle
    ];
  }
  stop() {
    this.animations.forEach((animation) => animation.cancel());
  }
  clear() {
    this.tasks = [];
  }
  /**
   * <zh/> 
   *
   * <en/> Release stock animation objects
   * @description see: https://github.com/antvis/G/issues/1731
   */
  release() {
    var _a, _b;
    const { canvas: canvas2 } = this.context;
    const animationsWithPromises = (_b = (_a = canvas2.document) === null || _a === void 0 ? void 0 : _a.timeline) === null || _b === void 0 ? void 0 : _b.animationsWithPromises;
    if (animationsWithPromises) {
      canvas2.document.timeline.animationsWithPromises = animationsWithPromises.filter((animation) => animation.playState !== "finished");
    }
  }
  destroy() {
    this.stop();
    this.animations.clear();
    this.tasks = [];
  }
};

// node_modules/@antv/g6/esm/runtime/batch.js
var BatchController = class {
  constructor(context) {
    this.batchCount = 0;
    this.context = context;
  }
  emit(event) {
    const { graph } = this.context;
    graph.emit(event.type, event);
  }
  startBatch(initiate = true) {
    this.batchCount++;
    if (this.batchCount === 1)
      this.emit(new GraphLifeCycleEvent(GraphEvent.BATCH_START, { initiate }));
  }
  endBatch() {
    this.batchCount--;
    if (this.batchCount === 0)
      this.emit(new GraphLifeCycleEvent(GraphEvent.BATCH_END));
  }
  get isBatching() {
    return this.batchCount > 0;
  }
  destroy() {
    this.context = null;
  }
};

// node_modules/@antv/g6/esm/runtime/behavior.js
var BehaviorController = class extends ExtensionController {
  constructor(context) {
    super(context);
    this.currentTarget = null;
    this.currentTargetType = null;
    this.category = "behavior";
    this.forwardCanvasEvents = (event) => {
      const { target: originalTarget } = event;
      const target = eventTargetOf(originalTarget);
      if (!target)
        return;
      const { graph, canvas: canvas2 } = this.context;
      const { type: targetType, element: targetElement } = target;
      if ("destroyed" in targetElement && (isToBeDestroyed(targetElement) || targetElement.destroyed))
        return;
      const { type, detail, button } = event;
      const stdEvent = Object.assign(Object.assign({}, event), { target: targetElement, targetType, originalTarget });
      if (type === CommonEvent.POINTER_MOVE) {
        if (this.currentTarget !== targetElement) {
          if (this.currentTarget) {
            graph.emit(`${this.currentTargetType}:${CommonEvent.POINTER_LEAVE}`, Object.assign(Object.assign({}, stdEvent), { type: CommonEvent.POINTER_LEAVE, target: this.currentTarget, targetType: this.currentTargetType }));
          }
          if (targetElement) {
            Object.assign(stdEvent, { type: CommonEvent.POINTER_ENTER });
            graph.emit(`${targetType}:${CommonEvent.POINTER_ENTER}`, stdEvent);
          }
        }
        this.currentTarget = targetElement;
        this.currentTargetType = targetType;
      }
      if (!(type === CommonEvent.CLICK && button === 2)) {
        graph.emit(`${targetType}:${type}`, stdEvent);
        graph.emit(type, stdEvent);
      }
      if (type === CommonEvent.CLICK && detail === 2) {
        Object.assign(stdEvent, { type: CommonEvent.DBLCLICK });
        graph.emit(`${targetType}:${CommonEvent.DBLCLICK}`, stdEvent);
        graph.emit(CommonEvent.DBLCLICK, stdEvent);
      }
      if (type === CommonEvent.POINTER_DOWN && button === 2) {
        Object.assign(stdEvent, {
          type: CommonEvent.CONTEXT_MENU,
          preventDefault: () => {
            var _a;
            (_a = canvas2.getContainer()) === null || _a === void 0 ? void 0 : _a.addEventListener(CommonEvent.CONTEXT_MENU, (e2) => e2.preventDefault(), {
              once: true
            });
          }
        });
        graph.emit(`${targetType}:${CommonEvent.CONTEXT_MENU}`, stdEvent);
        graph.emit(CommonEvent.CONTEXT_MENU, stdEvent);
      }
    };
    this.forwardContainerEvents = (event) => {
      this.context.graph.emit(event.type, event);
    };
    this.forwardEvents();
    this.setBehaviors(this.context.options.behaviors || []);
  }
  setBehaviors(behaviors) {
    this.setExtensions(behaviors);
  }
  forwardEvents() {
    const container = this.context.canvas.getContainer();
    if (container) {
      [ContainerEvent.KEY_DOWN, ContainerEvent.KEY_UP].forEach((name) => {
        container.addEventListener(name, this.forwardContainerEvents);
      });
    }
    const canvas2 = this.context.canvas.document;
    if (canvas2) {
      [
        CommonEvent.CLICK,
        CommonEvent.DBLCLICK,
        CommonEvent.POINTER_OVER,
        CommonEvent.POINTER_LEAVE,
        CommonEvent.POINTER_ENTER,
        CommonEvent.POINTER_MOVE,
        CommonEvent.POINTER_OUT,
        CommonEvent.POINTER_DOWN,
        CommonEvent.POINTER_UP,
        CommonEvent.CONTEXT_MENU,
        CommonEvent.DRAG_START,
        CommonEvent.DRAG,
        CommonEvent.DRAG_END,
        CommonEvent.DRAG_ENTER,
        CommonEvent.DRAG_OVER,
        CommonEvent.DRAG_LEAVE,
        CommonEvent.DROP,
        CommonEvent.WHEEL
      ].forEach((name) => {
        canvas2.addEventListener(name, this.forwardCanvasEvents);
      });
    }
  }
  destroy() {
    const container = this.context.canvas.getContainer();
    if (container) {
      [ContainerEvent.KEY_DOWN, ContainerEvent.KEY_UP].forEach((name) => {
        container.removeEventListener(name, this.forwardContainerEvents);
      });
    }
    this.context.canvas.document.removeAllEventListeners();
    super.destroy();
  }
};

// node_modules/@antv/g6/esm/utils/graphlib.js
var __rest22 = function(s2, e2) {
  var t3 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t3[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t3[p3[i2]] = s2[p3[i2]];
    }
  return t3;
};
function toGraphlibData(data) {
  const { id = idOf(data), style, data: customData } = data, rest = __rest22(data, ["id", "style", "data"]);
  const _data = Object.assign(Object.assign({}, data), { style: Object.assign({}, style), data: Object.assign({}, customData) });
  if (isEdgeData(data))
    return Object.assign({ id, data: _data }, rest);
  return { id, data: _data };
}
function toG6Data(data) {
  return data.data;
}
function createTreeStructure(model) {
  if (model.hasTreeStructure(TREE_KEY))
    return;
  model.attachTreeStructure(TREE_KEY);
  const edges = model.getAllEdges();
  for (const edge of edges) {
    const { source, target } = edge;
    model.setParent(target, source, TREE_KEY);
  }
}

// node_modules/@antv/g6/esm/runtime/data.js
var DataController = class {
  constructor() {
    this.latestRemovedComboIds = /* @__PURE__ */ new Set();
    this.comboIds = /* @__PURE__ */ new Set();
    this.changes = [];
    this.batchCount = 0;
    this.isTraceless = false;
    this.enableUpdateNodeLikeHierarchy = true;
    this.model = new Graph2();
  }
  pushChange(change) {
    if (this.isTraceless)
      return;
    const { type } = change;
    if (type === ChangeType.NodeUpdated || type === ChangeType.EdgeUpdated || type === ChangeType.ComboUpdated) {
      const { value, original } = change;
      this.changes.push({ value: cloneElementData(value), original: cloneElementData(original), type });
    } else {
      this.changes.push({ value: cloneElementData(change.value), type });
    }
  }
  getChanges() {
    return this.changes;
  }
  clearChanges() {
    this.changes = [];
  }
  batch(callback) {
    this.batchCount++;
    this.model.batch(callback);
    this.batchCount--;
  }
  isBatching() {
    return this.batchCount > 0;
  }
  /**
   * <zh/> 
   *
   * <en/> Perform operations without leaving records
   * @param callback - <zh/>  | <en/> callback function
   * @remarks
   * <zh/> 
   *
   * <en/> Usually used to adjust elements at runtime and synchronize data to avoid triggering data changes and causing redraws
   */
  silence(callback) {
    this.isTraceless = true;
    callback();
    this.isTraceless = false;
  }
  isCombo(id) {
    return this.comboIds.has(id) || this.latestRemovedComboIds.has(id);
  }
  getData() {
    return {
      nodes: this.getNodeData(),
      edges: this.getEdgeData(),
      combos: this.getComboData()
    };
  }
  getNodeData(ids) {
    return this.model.getAllNodes().reduce((acc, node) => {
      const data = toG6Data(node);
      if (this.isCombo(idOf(data)))
        return acc;
      if (ids === void 0)
        acc.push(data);
      else
        ids.includes(idOf(data)) && acc.push(data);
      return acc;
    }, []);
  }
  getEdgeDatum(id) {
    return toG6Data(this.model.getEdge(id));
  }
  getEdgeData(ids) {
    return this.model.getAllEdges().reduce((acc, edge) => {
      const data = toG6Data(edge);
      if (ids === void 0)
        acc.push(data);
      else
        ids.includes(idOf(data)) && acc.push(data);
      return acc;
    }, []);
  }
  getComboData(ids) {
    return this.model.getAllNodes().reduce((acc, combo) => {
      const data = toG6Data(combo);
      if (!this.isCombo(idOf(data)))
        return acc;
      if (ids === void 0)
        acc.push(data);
      else
        ids.includes(idOf(data)) && acc.push(data);
      return acc;
    }, []);
  }
  getRootsData(hierarchyKey = TREE_KEY) {
    return this.model.getRoots(hierarchyKey).map(toG6Data);
  }
  getAncestorsData(id, hierarchyKey) {
    const { model } = this;
    if (!model.hasNode(id) || !model.hasTreeStructure(hierarchyKey))
      return [];
    return model.getAncestors(id, hierarchyKey).map(toG6Data);
  }
  getDescendantsData(id) {
    const root = this.getElementDataById(id);
    const data = [];
    dfs(root, (node) => {
      if (node !== root)
        data.push(node);
    }, (node) => this.getChildrenData(idOf(node)), "TB");
    return data;
  }
  getParentData(id, hierarchyKey) {
    const { model } = this;
    if (!hierarchyKey) {
      print.warn("The hierarchy structure key is not specified");
      return void 0;
    }
    if (!model.hasNode(id) || !model.hasTreeStructure(hierarchyKey))
      return void 0;
    const parent = model.getParent(id, hierarchyKey);
    return parent ? toG6Data(parent) : void 0;
  }
  getChildrenData(id) {
    const structureKey = this.getElementType(id) === "node" ? TREE_KEY : COMBO_KEY;
    const { model } = this;
    if (!model.hasNode(id) || !model.hasTreeStructure(structureKey))
      return [];
    return model.getChildren(id, structureKey).map(toG6Data);
  }
  /**
   * <zh/> 
   *
   * <en/> Get the data of the specified type of element
   * @param elementType - <zh/>  | <en/> element type
   * @returns <zh/>  | <en/> element data
   */
  getElementsDataByType(elementType) {
    if (elementType === "node")
      return this.getNodeData();
    if (elementType === "edge")
      return this.getEdgeData();
    if (elementType === "combo")
      return this.getComboData();
    return [];
  }
  /**
   * <zh/>  ID 
   *
   * <en/> Get the data of the element by ID, no need to care about the type of the element
   * @param id - <zh/>  ID  | <en/> element ID array
   * @returns <zh/>  | <en/> data of the element
   */
  getElementDataById(id) {
    const type = this.getElementType(id);
    if (type === "edge")
      return this.getEdgeDatum(id);
    return this.getNodeLikeDatum(id);
  }
  /**
   * <zh/> 
   *
   * <en/> Get node data
   * @param id - <zh/>  ID | <en/> node ID
   * @returns <zh/>  | <en/> node data
   */
  getNodeLikeDatum(id) {
    const data = this.model.getNode(id);
    return toG6Data(data);
  }
  /**
   * <zh/>  combo 
   *
   * <en/> Get all node and combo data
   * @param ids - <zh/>  combo ID  | <en/> node and combo ID array
   * @returns <zh/>  combo  | <en/> node and combo data
   */
  getNodeLikeData(ids) {
    return this.model.getAllNodes().reduce((acc, node) => {
      const data = toG6Data(node);
      if (ids)
        ids.includes(idOf(data)) && acc.push(data);
      else
        acc.push(data);
      return acc;
    }, []);
  }
  getElementDataByState(elementType, state) {
    const elementData = this.getElementsDataByType(elementType);
    return elementData.filter((datum) => {
      var _a;
      return (_a = datum.states) === null || _a === void 0 ? void 0 : _a.includes(state);
    });
  }
  getElementState(id) {
    var _a;
    return ((_a = this.getElementDataById(id)) === null || _a === void 0 ? void 0 : _a.states) || [];
  }
  hasNode(id) {
    return this.model.hasNode(id) && !this.isCombo(id);
  }
  hasEdge(id) {
    return this.model.hasEdge(id);
  }
  hasCombo(id) {
    return this.model.hasNode(id) && this.isCombo(id);
  }
  getRelatedEdgesData(id, direction = "both") {
    return this.model.getRelatedEdges(id, direction).map(toG6Data);
  }
  getNeighborNodesData(id) {
    return this.model.getNeighbors(id).map(toG6Data);
  }
  setData(data) {
    const { nodes: modifiedNodes = [], edges: modifiedEdges = [], combos: modifiedCombos = [] } = data;
    const { nodes: originalNodes, edges: originalEdges, combos: originalCombos } = this.getData();
    const nodeDiff = arrayDiff(originalNodes, modifiedNodes, (node) => idOf(node), isElementDataEqual);
    const edgeDiff = arrayDiff(originalEdges, modifiedEdges, (edge) => idOf(edge), isElementDataEqual);
    const comboDiff = arrayDiff(originalCombos, modifiedCombos, (combo) => idOf(combo), isElementDataEqual);
    this.batch(() => {
      const dataToAdd = {
        nodes: nodeDiff.enter,
        edges: edgeDiff.enter,
        combos: comboDiff.enter
      };
      this.addData(dataToAdd);
      this.computeZIndex(dataToAdd, "add", true);
      const dataToUpdate = {
        nodes: nodeDiff.update,
        edges: edgeDiff.update,
        combos: comboDiff.update
      };
      this.updateData(dataToUpdate);
      this.computeZIndex(dataToUpdate, "update", true);
      const dataToRemove = {
        nodes: nodeDiff.exit.map(idOf),
        edges: edgeDiff.exit.map(idOf),
        combos: comboDiff.exit.map(idOf)
      };
      this.removeData(dataToRemove);
    });
  }
  addData(data) {
    const { nodes, edges, combos } = data;
    this.batch(() => {
      this.addComboData(combos);
      this.addNodeData(nodes);
      this.addEdgeData(edges);
    });
    this.computeZIndex(data, "add");
  }
  addNodeData(nodes = []) {
    if (!nodes.length)
      return;
    this.model.addNodes(nodes.map((node) => {
      this.pushChange({ value: node, type: ChangeType.NodeAdded });
      return toGraphlibData(node);
    }));
    this.updateNodeLikeHierarchy(nodes);
    this.computeZIndex({ nodes }, "add");
  }
  addEdgeData(edges = []) {
    if (!edges.length)
      return;
    this.model.addEdges(edges.map((edge) => {
      this.pushChange({ value: edge, type: ChangeType.EdgeAdded });
      return toGraphlibData(edge);
    }));
    this.computeZIndex({ edges }, "add");
  }
  addComboData(combos = []) {
    if (!combos.length)
      return;
    const { model } = this;
    if (!model.hasTreeStructure(COMBO_KEY)) {
      model.attachTreeStructure(COMBO_KEY);
    }
    model.addNodes(combos.map((combo) => {
      this.comboIds.add(idOf(combo));
      this.pushChange({ value: combo, type: ChangeType.ComboAdded });
      return toGraphlibData(combo);
    }));
    this.updateNodeLikeHierarchy(combos);
    this.computeZIndex({ combos }, "add");
  }
  addChildrenData(parentId, childrenData) {
    const parentData = this.getNodeLikeDatum(parentId);
    const childrenId = childrenData.map(idOf);
    this.addNodeData(childrenData);
    this.updateNodeData([{ id: parentId, children: [...parentData.children || [], ...childrenId] }]);
    this.addEdgeData(childrenId.map((childId) => ({ source: parentId, target: childId })));
  }
  /**
   * <zh/>  zIndex
   *
   * <en/> Calculate zIndex
   * @param data - <zh/>  | <en/> newly added data
   * @param type - <zh/>  | <en/> operation type
   * @param force - <zh/>  | <en/> ignore batch processing
   * @remarks
   * <zh/> 
   * - 
   * - / combo
   * -  children
   *
   * <en/> The situation of calling this function:
   * - Add element
   * - Update the combo of the node/combo
   * - Update the children of the node
   */
  computeZIndex(data, type, force = false) {
    if (!force && this.isBatching())
      return;
    this.batch(() => {
      const { nodes = [], edges = [], combos = [] } = data;
      combos.forEach((combo) => {
        var _a, _b, _c;
        const id = idOf(combo);
        if (type === "add" && isNumber((_a = combo.style) === null || _a === void 0 ? void 0 : _a.zIndex))
          return;
        if (type === "update" && !("combo" in combo))
          return;
        const parent = this.getParentData(id, COMBO_KEY);
        const zIndex = parent ? ((_c = (_b = parent.style) === null || _b === void 0 ? void 0 : _b.zIndex) !== null && _c !== void 0 ? _c : 0) + 1 : 0;
        this.preventUpdateNodeLikeHierarchy(() => {
          this.updateComboData([{ id, style: { zIndex } }]);
        });
      });
      nodes.forEach((node) => {
        var _a, _b, _c;
        const id = idOf(node);
        if (type === "add" && isNumber((_a = node.style) === null || _a === void 0 ? void 0 : _a.zIndex))
          return;
        if (type === "update" && !("combo" in node) && !("children" in node))
          return;
        let zIndex = 0;
        const comboParent = this.getParentData(id, COMBO_KEY);
        if (comboParent) {
          zIndex = (((_b = comboParent.style) === null || _b === void 0 ? void 0 : _b.zIndex) || 0) + 1;
        } else {
          const nodeParent = this.getParentData(id, TREE_KEY);
          if (nodeParent)
            zIndex = ((_c = nodeParent === null || nodeParent === void 0 ? void 0 : nodeParent.style) === null || _c === void 0 ? void 0 : _c.zIndex) || 0;
        }
        this.preventUpdateNodeLikeHierarchy(() => {
          this.updateNodeData([{ id, style: { zIndex } }]);
        });
      });
      edges.forEach((edge) => {
        var _a, _b, _c, _d, _e2;
        if (isNumber((_a = edge.style) === null || _a === void 0 ? void 0 : _a.zIndex))
          return;
        let { id, source, target } = edge;
        if (!id)
          id = idOf(edge);
        else {
          const datum = this.getEdgeDatum(id);
          source = datum.source;
          target = datum.target;
        }
        if (!source || !target)
          return;
        const sourceZIndex = ((_c = (_b = this.getNodeLikeDatum(source)) === null || _b === void 0 ? void 0 : _b.style) === null || _c === void 0 ? void 0 : _c.zIndex) || 0;
        const targetZIndex = ((_e2 = (_d = this.getNodeLikeDatum(target)) === null || _d === void 0 ? void 0 : _d.style) === null || _e2 === void 0 ? void 0 : _e2.zIndex) || 0;
        this.updateEdgeData([{ id: idOf(edge), style: { zIndex: Math.max(sourceZIndex, targetZIndex) - 1 } }]);
      });
    });
  }
  /**
   * <zh/>  zIndex
   *
   * <en/> Calculate the zIndex after the element is placed on top
   * @param id - <zh/>  ID | <en/> ID of the element
   * @returns <zh/> zIndex | <en/> zIndex
   */
  getFrontZIndex(id) {
    var _a;
    const elementType = this.getElementType(id);
    const elementData = this.getElementDataById(id);
    const data = this.getData();
    Object.assign(data, {
      [`${elementType}s`]: data[`${elementType}s`].filter((element) => idOf(element) !== id)
    });
    if (elementType === "combo") {
      if (!isCollapsed(elementData)) {
        const ancestorIds = new Set(this.getAncestorsData(id, COMBO_KEY).map(idOf));
        data.nodes = data.nodes.filter((element) => !ancestorIds.has(idOf(element)));
        data.combos = data.combos.filter((element) => !ancestorIds.has(idOf(element)));
        data.edges = data.edges.filter(({ source, target }) => !ancestorIds.has(source) && !ancestorIds.has(target));
      }
    }
    return Math.max(((_a = elementData.style) === null || _a === void 0 ? void 0 : _a.zIndex) || 0, 0, ...Object.values(data).flat().map((datum) => {
      var _a2;
      return (((_a2 = datum === null || datum === void 0 ? void 0 : datum.style) === null || _a2 === void 0 ? void 0 : _a2.zIndex) || 0) + 1;
    }));
  }
  updateNodeLikeHierarchy(data) {
    if (!this.enableUpdateNodeLikeHierarchy)
      return;
    const { model } = this;
    data.forEach((datum) => {
      const id = idOf(datum);
      const parent = parentIdOf(datum);
      if (parent !== void 0) {
        if (!model.hasTreeStructure(COMBO_KEY))
          model.attachTreeStructure(COMBO_KEY);
        if (parent === null) {
          this.refreshComboData(id);
        }
        this.setParent(id, parentIdOf(datum), COMBO_KEY);
      }
      const children = datum.children || [];
      if (children.length) {
        if (!model.hasTreeStructure(TREE_KEY))
          model.attachTreeStructure(TREE_KEY);
        const _children = children.filter((child) => model.hasNode(child));
        _children.forEach((child) => this.setParent(child, id, TREE_KEY));
        if (_children.length !== children.length) {
          this.updateNodeData([{ id, children: _children }]);
        }
      }
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Do not update the node hierarchy when executing changes
   * @param callback - <zh/>  | <en/> change function
   */
  preventUpdateNodeLikeHierarchy(callback) {
    this.enableUpdateNodeLikeHierarchy = false;
    callback();
    this.enableUpdateNodeLikeHierarchy = true;
  }
  updateData(data) {
    const { nodes, edges, combos } = data;
    this.batch(() => {
      this.updateNodeData(nodes);
      this.updateComboData(combos);
      this.updateEdgeData(edges);
    });
    this.computeZIndex(data, "update");
  }
  updateNodeData(nodes = []) {
    if (!nodes.length)
      return;
    const { model } = this;
    this.batch(() => {
      const modifiedNodes = [];
      nodes.forEach((modifiedNode) => {
        const id = idOf(modifiedNode);
        const originalNode = toG6Data(model.getNode(id));
        if (isElementDataEqual(originalNode, modifiedNode))
          return;
        const value = mergeElementsData(originalNode, modifiedNode);
        this.pushChange({ value, original: originalNode, type: ChangeType.NodeUpdated });
        model.mergeNodeData(id, value);
        modifiedNodes.push(value);
      });
      this.updateNodeLikeHierarchy(modifiedNodes);
    });
    this.computeZIndex({ nodes }, "update");
  }
  /**
   * <zh/> 
   *
   * <en/> Submit all data to the change record for redrawing
   */
  refreshData() {
    const { nodes, edges, combos } = this.getData();
    nodes.forEach((node) => {
      this.pushChange({ value: node, original: node, type: ChangeType.NodeUpdated });
    });
    edges.forEach((edge) => {
      this.pushChange({ value: edge, original: edge, type: ChangeType.EdgeUpdated });
    });
    combos.forEach((combo) => {
      this.pushChange({ value: combo, original: combo, type: ChangeType.ComboUpdated });
    });
  }
  syncNodeLikeDatum(datum) {
    const { model } = this;
    const id = idOf(datum);
    if (!model.hasNode(id))
      return;
    const original = toG6Data(model.getNode(id));
    const value = mergeElementsData(original, datum);
    model.mergeNodeData(id, value);
  }
  syncEdgeDatum(datum) {
    const { model } = this;
    const id = idOf(datum);
    if (!model.hasEdge(id))
      return;
    const original = toG6Data(model.getEdge(id));
    const value = mergeElementsData(original, datum);
    model.mergeEdgeData(id, value);
  }
  updateEdgeData(edges = []) {
    if (!edges.length)
      return;
    const { model } = this;
    this.batch(() => {
      edges.forEach((modifiedEdge) => {
        const id = idOf(modifiedEdge);
        const originalEdge = toG6Data(model.getEdge(id));
        if (isElementDataEqual(originalEdge, modifiedEdge))
          return;
        if (modifiedEdge.source && originalEdge.source !== modifiedEdge.source) {
          model.updateEdgeSource(id, modifiedEdge.source);
        }
        if (modifiedEdge.target && originalEdge.target !== modifiedEdge.target) {
          model.updateEdgeTarget(id, modifiedEdge.target);
        }
        const updatedData = mergeElementsData(originalEdge, modifiedEdge);
        this.pushChange({ value: updatedData, original: originalEdge, type: ChangeType.EdgeUpdated });
        model.mergeEdgeData(id, updatedData);
      });
    });
    this.computeZIndex({ edges }, "update");
  }
  updateComboData(combos = []) {
    if (!combos.length)
      return;
    const { model } = this;
    model.batch(() => {
      const modifiedCombos = [];
      combos.forEach((modifiedCombo) => {
        const id = idOf(modifiedCombo);
        const originalCombo = toG6Data(model.getNode(id));
        if (isElementDataEqual(originalCombo, modifiedCombo))
          return;
        const value = mergeElementsData(originalCombo, modifiedCombo);
        this.pushChange({ value, original: originalCombo, type: ChangeType.ComboUpdated });
        model.mergeNodeData(id, value);
        modifiedCombos.push(value);
      });
      this.updateNodeLikeHierarchy(modifiedCombos);
    });
    this.computeZIndex({ combos }, "update");
  }
  /**
   * <zh/> 
   *
   * <en/> Set the parent node of the node
   * @param id - <zh/>  ID | <en/> node ID
   * @param parent - <zh/>  ID | <en/> parent node ID
   * @param hierarchyKey - <zh/>  | <en/> hierarchy type
   * @param update - <zh/> / | <en/> add new/old parent node data update record
   */
  setParent(id, parent, hierarchyKey, update = true) {
    if (id === parent)
      return;
    const elementData = this.getNodeLikeDatum(id);
    const originalParentId = parentIdOf(elementData);
    if (originalParentId !== parent && hierarchyKey === COMBO_KEY) {
      const modifiedDatum = { id, combo: parent };
      if (this.isCombo(id))
        this.syncNodeLikeDatum(modifiedDatum);
      else
        this.syncNodeLikeDatum(modifiedDatum);
    }
    this.model.setParent(id, parent, hierarchyKey);
    if (update && hierarchyKey === COMBO_KEY) {
      uniq([originalParentId, parent]).forEach((pId) => {
        if (pId !== void 0)
          this.refreshComboData(pId);
      });
    }
  }
  /**
   * <zh/>  combo 
   *
   * <en/> Refresh combo data
   * @param id - <zh/> combo ID | <en/> combo ID
   * @remarks
   * <zh/> 
   *
   * <en/> Will not change the data, but will trigger data change events
   */
  refreshComboData(id) {
    const combo = this.getComboData([id])[0];
    const ancestors = this.getAncestorsData(id, COMBO_KEY);
    if (combo)
      this.pushChange({ value: combo, original: combo, type: ChangeType.ComboUpdated });
    ancestors.forEach((value) => {
      this.pushChange({ value, original: value, type: ChangeType.ComboUpdated });
    });
  }
  getElementPosition(id) {
    const datum = this.getElementDataById(id);
    return positionOf(datum);
  }
  translateNodeLikeBy(id, offset) {
    if (this.isCombo(id))
      this.translateComboBy(id, offset);
    else
      this.translateNodeBy(id, offset);
  }
  translateNodeLikeTo(id, position2) {
    if (this.isCombo(id))
      this.translateComboTo(id, position2);
    else
      this.translateNodeTo(id, position2);
  }
  translateNodeBy(id, offset) {
    const curr = this.getElementPosition(id);
    const position2 = add(curr, [...offset, 0].slice(0, 3));
    this.translateNodeTo(id, position2);
  }
  translateNodeTo(id, position2) {
    const [x4 = 0, y4 = 0, z4 = 0] = position2;
    this.preventUpdateNodeLikeHierarchy(() => {
      this.updateNodeData([{ id, style: { x: x4, y: y4, z: z4 } }]);
    });
  }
  translateComboBy(id, offset) {
    const [dx = 0, dy = 0, dz = 0] = offset;
    if ([dx, dy, dz].some(isNaN) || [dx, dy, dz].every((o3) => o3 === 0))
      return;
    const combo = this.getComboData([id])[0];
    if (!combo)
      return;
    const seenNodeLikeIds = /* @__PURE__ */ new Set();
    dfs(combo, (succeed) => {
      const succeedID = idOf(succeed);
      if (seenNodeLikeIds.has(succeedID))
        return;
      seenNodeLikeIds.add(succeedID);
      const [x4, y4, z4] = positionOf(succeed);
      const value = mergeElementsData(succeed, {
        style: { x: x4 + dx, y: y4 + dy, z: z4 + dz }
      });
      this.pushChange({
        value,
        // @ts-ignore
        original: succeed,
        type: this.isCombo(succeedID) ? ChangeType.ComboUpdated : ChangeType.NodeUpdated
      });
      this.model.mergeNodeData(succeedID, value);
    }, (node) => this.getChildrenData(idOf(node)), "BT");
  }
  translateComboTo(id, position2) {
    var _a;
    if (position2.some(isNaN))
      return;
    const [tx = 0, ty = 0, tz = 0] = position2;
    const combo = (_a = this.getComboData([id])) === null || _a === void 0 ? void 0 : _a[0];
    if (!combo)
      return;
    const [comboX, comboY, comboZ] = positionOf(combo);
    const dx = tx - comboX;
    const dy = ty - comboY;
    const dz = tz - comboZ;
    dfs(combo, (succeed) => {
      const succeedId = idOf(succeed);
      const [x4, y4, z4] = positionOf(succeed);
      const value = mergeElementsData(succeed, {
        style: { x: x4 + dx, y: y4 + dy, z: z4 + dz }
      });
      this.pushChange({
        value,
        // @ts-ignore
        original: succeed,
        type: this.isCombo(succeedId) ? ChangeType.ComboUpdated : ChangeType.NodeUpdated
      });
      this.model.mergeNodeData(succeedId, value);
    }, (node) => this.getChildrenData(idOf(node)), "BT");
  }
  removeData(data) {
    const { nodes, edges, combos } = data;
    this.batch(() => {
      this.removeEdgeData(edges);
      this.removeNodeData(nodes);
      this.removeComboData(combos);
      this.latestRemovedComboIds = new Set(combos);
    });
  }
  removeNodeData(ids = []) {
    if (!ids.length)
      return;
    this.batch(() => {
      ids.forEach((id) => {
        this.removeEdgeData(this.getRelatedEdgesData(id).map(idOf));
        this.pushChange({ value: this.getNodeData([id])[0], type: ChangeType.NodeRemoved });
        this.removeNodeLikeHierarchy(id);
      });
      this.model.removeNodes(ids);
    });
  }
  removeEdgeData(ids = []) {
    if (!ids.length)
      return;
    ids.forEach((id) => this.pushChange({ value: this.getEdgeData([id])[0], type: ChangeType.EdgeRemoved }));
    this.model.removeEdges(ids);
  }
  removeComboData(ids = []) {
    if (!ids.length)
      return;
    this.batch(() => {
      ids.forEach((id) => {
        this.pushChange({ value: this.getComboData([id])[0], type: ChangeType.ComboRemoved });
        this.removeNodeLikeHierarchy(id);
        this.comboIds.delete(id);
      });
      this.model.removeNodes(ids);
    });
  }
  /**
   * <zh/>  children 
   *
   * <en/> Remove the node hierarchy and move its child nodes to the parent node's children list
   * @param id - <zh/>  | <en/> node to be processed
   */
  removeNodeLikeHierarchy(id) {
    if (this.model.hasTreeStructure(COMBO_KEY)) {
      const grandParent = parentIdOf(this.getNodeLikeDatum(id));
      this.setParent(id, void 0, COMBO_KEY, false);
      this.model.getChildren(id, COMBO_KEY).forEach((child) => {
        const childData = toG6Data(child);
        const childId = idOf(childData);
        this.setParent(idOf(childData), grandParent, COMBO_KEY, false);
        const value = mergeElementsData(childData, {
          id: idOf(childData),
          combo: grandParent
        });
        this.pushChange({
          value,
          original: childData,
          type: this.isCombo(childId) ? ChangeType.ComboUpdated : ChangeType.NodeUpdated
        });
        this.model.mergeNodeData(idOf(childData), value);
      });
      if (!isNil(grandParent))
        this.refreshComboData(grandParent);
    }
  }
  /**
   * <zh/> 
   *
   * <en/> Get the type of the element
   * @param id - <zh/>  ID | <en/> ID of the element
   * @returns <zh/>  | <en/> type of the element
   */
  getElementType(id) {
    if (this.model.hasNode(id)) {
      if (this.isCombo(id))
        return "combo";
      return "node";
    }
    if (this.model.hasEdge(id))
      return "edge";
    throw new Error(format(`Unknown element type of id: ${id}`));
  }
  destroy() {
    const { model } = this;
    const nodes = model.getAllNodes();
    const edges = model.getAllEdges();
    model.removeEdges(edges.map((edge) => edge.id));
    model.removeNodes(nodes.map((node) => node.id));
    this.context = {};
  }
};

// node_modules/@antv/g6/esm/runtime/element.js
var __awaiter24 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ElementController = class {
  constructor(context) {
    this.elementMap = {};
    this.shapeTypeMap = {};
    this.paletteStyle = {};
    this.defaultStyle = {};
    this.stateStyle = {};
    this.visibilityCache = /* @__PURE__ */ new WeakMap();
    this.context = context;
  }
  init() {
    this.initContainer();
  }
  initContainer() {
    if (!this.container || this.container.destroyed) {
      const { canvas: canvas2 } = this.context;
      this.container = canvas2.appendChild(new Group({ className: "elements" }));
    }
  }
  emit(event, context) {
    if (context.silence)
      return;
    emit(this.context.graph, event);
  }
  forEachElementData(callback) {
    ELEMENT_TYPES.forEach((elementType) => {
      const elementData = this.context.model.getElementsDataByType(elementType);
      callback(elementType, elementData);
    });
  }
  getElementType(elementType, datum) {
    var _a;
    const { options, graph } = this.context;
    const userDefinedType = isOverridable(datum) ? ((_a = options[elementType]) === null || _a === void 0 ? void 0 : _a.type) || datum.type : datum.type;
    if (!userDefinedType) {
      if (elementType === "edge")
        return "line";
      else
        return "circle";
    }
    if (typeof userDefinedType === "string")
      return userDefinedType;
    return userDefinedType.call(graph, datum);
  }
  getTheme(elementType) {
    return themeOf(this.context.options)[elementType] || {};
  }
  getThemeStyle(elementType) {
    return this.getTheme(elementType).style || {};
  }
  getThemeStateStyle(elementType, states) {
    const { state = {} } = this.getTheme(elementType);
    return Object.assign({}, ...states.map((name) => state[name] || {}));
  }
  computePaletteStyle() {
    const { options } = this.context;
    this.paletteStyle = {};
    this.forEachElementData((elementType, elementData) => {
      var _a, _b;
      const palette = Object.assign({}, parsePalette((_a = this.getTheme(elementType)) === null || _a === void 0 ? void 0 : _a.palette), parsePalette((_b = options[elementType]) === null || _b === void 0 ? void 0 : _b.palette));
      if (palette === null || palette === void 0 ? void 0 : palette.field) {
        Object.assign(this.paletteStyle, assignColorByPalette(elementData, palette));
      }
    });
  }
  getPaletteStyle(elementType, id) {
    const color = this.paletteStyle[id];
    if (!color)
      return {};
    if (elementType === "edge")
      return { stroke: color };
    return { fill: color };
  }
  /**
   * <zh/> 
   *
   * <en/> compute default style of single element
   */
  computeElementDefaultStyle(elementType, context) {
    var _a;
    const { options } = this.context;
    const defaultStyle = ((_a = options[elementType]) === null || _a === void 0 ? void 0 : _a.style) || {};
    if ("transform" in defaultStyle && Array.isArray(defaultStyle.transform)) {
      defaultStyle.transform = [...defaultStyle.transform];
    }
    this.defaultStyle[idOf(context.datum)] = computeElementCallbackStyle(defaultStyle, context);
  }
  computeElementsDefaultStyle(ids) {
    const { graph } = this.context;
    this.forEachElementData((elementType, elementData) => {
      const length = elementData.length;
      for (let i2 = 0; i2 < length; i2++) {
        const datum = elementData[i2];
        if (ids === void 0 || ids.includes(idOf(datum))) {
          this.computeElementDefaultStyle(elementType, { datum, graph });
        }
      }
    });
  }
  getDefaultStyle(id) {
    return this.defaultStyle[id] || {};
  }
  getElementState(id) {
    try {
      const { model } = this.context;
      return model.getElementState(id);
    } catch (_a) {
      return [];
    }
  }
  /**
   * <zh/> 
   *
   * <en/> get single state style of single element
   */
  getElementStateStyle(elementType, state, context) {
    var _a, _b;
    const { options } = this.context;
    const stateStyle = ((_b = (_a = options[elementType]) === null || _a === void 0 ? void 0 : _a.state) === null || _b === void 0 ? void 0 : _b[state]) || {};
    return computeElementCallbackStyle(stateStyle, context);
  }
  /**
   * <zh/> 
   *
   * <en/> compute merged state style of single element
   */
  computeElementStatesStyle(elementType, states, context) {
    this.stateStyle[idOf(context.datum)] = Object.assign({}, ...states.map((state) => this.getElementStateStyle(elementType, state, context)));
  }
  /**
   * <zh/> 
   *
   * <en/> compute state style of all elements
   * @param ids - <zh/>  | <en/> compute state style of specified elements
   */
  computeElementsStatesStyle(ids) {
    const { graph } = this.context;
    this.forEachElementData((elementType, elementData) => {
      const length = elementData.length;
      for (let i2 = 0; i2 < length; i2++) {
        const datum = elementData[i2];
        if (ids === void 0 || ids.includes(idOf(datum))) {
          const states = this.getElementState(idOf(datum));
          this.computeElementStatesStyle(elementType, states, { datum, graph });
        }
      }
    });
  }
  getStateStyle(id) {
    return this.stateStyle[id] || {};
  }
  computeStyle(stage, ids) {
    const skip = ["translate", "zIndex"];
    if (stage && skip.includes(stage))
      return;
    this.computePaletteStyle();
    this.computeElementsDefaultStyle(ids);
    this.computeElementsStatesStyle(ids);
  }
  getElement(id) {
    return this.elementMap[id];
  }
  getNodes() {
    return this.context.model.getNodeData().map(({ id }) => this.elementMap[id]);
  }
  getEdges() {
    return this.context.model.getEdgeData().map((edge) => this.elementMap[idOf(edge)]);
  }
  getCombos() {
    return this.context.model.getComboData().map(({ id }) => this.elementMap[id]);
  }
  getElementComputedStyle(elementType, datum) {
    const id = idOf(datum);
    const themeStyle = this.getThemeStyle(elementType);
    const paletteStyle = this.getPaletteStyle(elementType, id);
    const dataStyle = datum.style || {};
    const defaultStyle = this.getDefaultStyle(id);
    const themeStateStyle = this.getThemeStateStyle(elementType, this.getElementState(id));
    const stateStyle = this.getStateStyle(id);
    const style = isOverridable(datum) ? Object.assign({}, themeStyle, paletteStyle, dataStyle, defaultStyle, themeStateStyle, stateStyle) : Object.assign({}, dataStyle);
    if (elementType === "combo") {
      const childrenData = this.context.model.getChildrenData(id);
      const isCollapsed2 = !!style.collapsed;
      const childrenNode = isCollapsed2 ? [] : childrenData.map(idOf).filter((id2) => this.getElement(id2));
      Object.assign(style, { childrenNode, childrenData });
    }
    return style;
  }
  getDrawData(context) {
    this.init();
    const data = this.computeChangesAndDrawData(context);
    if (!data)
      return null;
    const { type = "draw", stage = type } = context;
    this.markDestroyElement(data.drawData);
    this.computeStyle(stage);
    return { type, stage, data };
  }
  /**
   * <zh/> 
   *
   * <en/> start render process
   */
  draw(context = { animation: true }) {
    const drawData = this.getDrawData(context);
    if (!drawData)
      return;
    const { data: { drawData: { add: add4, update, remove } } } = drawData;
    this.destroyElements(remove, context);
    this.createElements(add4, context);
    this.updateElements(update, context);
    return this.setAnimationTask(context, drawData);
  }
  preLayoutDraw() {
    return __awaiter24(this, arguments, void 0, function* (context = { animation: true }) {
      var _a, _b;
      const preResult = this.getDrawData(context);
      if (!preResult)
        return;
      const { data: { drawData } } = preResult;
      yield (_b = (_a = this.context.layout) === null || _a === void 0 ? void 0 : _a.preLayout) === null || _b === void 0 ? void 0 : _b.call(_a, drawData);
      const { add: add4, update, remove } = drawData;
      this.destroyElements(remove, context);
      this.createElements(add4, context);
      this.updateElements(update, context);
      return this.setAnimationTask(context, preResult);
    });
  }
  setAnimationTask(context, data) {
    const { animation, silence } = context;
    const { data: { dataChanges, drawData }, stage, type } = data;
    return this.context.animation.animate(animation, silence ? {} : {
      before: () => this.emit(new GraphLifeCycleEvent(GraphEvent.BEFORE_DRAW, {
        dataChanges,
        animation,
        stage,
        render: type === "render"
      }), context),
      beforeAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.DRAW, animation2, drawData), context),
      afterAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.DRAW, animation2, drawData), context),
      after: () => this.emit(new GraphLifeCycleEvent(GraphEvent.AFTER_DRAW, {
        dataChanges,
        animation,
        stage,
        render: type === "render",
        firstRender: this.context.graph.rendered === false
      }), context)
    });
  }
  computeChangesAndDrawData(context) {
    const { model } = this.context;
    const dataChanges = model.getChanges();
    const tasks = reduceDataChanges(dataChanges);
    if (tasks.length === 0)
      return null;
    const { NodeAdded = [], NodeUpdated = [], NodeRemoved = [], EdgeAdded = [], EdgeUpdated = [], EdgeRemoved = [], ComboAdded = [], ComboUpdated = [], ComboRemoved = [] } = group_by_default(tasks, (change) => change.type);
    const moveToAddedIfUnrendered = (updated, added) => {
      const keptUpdates = [];
      updated.forEach((change) => {
        const id = idOf(change.value);
        if (!this.getElement(id)) {
          added.push(change);
        } else {
          keptUpdates.push(change);
        }
      });
      return keptUpdates;
    };
    const finalNodeUpdated = moveToAddedIfUnrendered(NodeUpdated, NodeAdded);
    const finalEdgeUpdated = moveToAddedIfUnrendered(EdgeUpdated, EdgeAdded);
    const finalComboUpdated = moveToAddedIfUnrendered(ComboUpdated, ComboAdded);
    const dataOf = (data) => new Map(data.map((datum) => {
      const data2 = datum.value;
      return [idOf(data2), data2];
    }));
    const input = {
      add: {
        nodes: dataOf(NodeAdded),
        edges: dataOf(EdgeAdded),
        combos: dataOf(ComboAdded)
      },
      update: {
        nodes: dataOf(finalNodeUpdated),
        edges: dataOf(finalEdgeUpdated),
        combos: dataOf(finalComboUpdated)
      },
      remove: {
        nodes: dataOf(NodeRemoved),
        edges: dataOf(EdgeRemoved),
        combos: dataOf(ComboRemoved)
      }
    };
    const drawData = this.transformData(input, context);
    model.clearChanges();
    return { dataChanges, drawData };
  }
  transformData(input, context) {
    const transforms = this.context.transform.getTransformInstance();
    return Object.values(transforms).reduce((data, transform) => transform.beforeDraw(data, context), input);
  }
  createElement(elementType, datum, context) {
    var _a;
    const id = idOf(datum);
    const currentElement = this.getElement(id);
    if (currentElement)
      return;
    const type = this.getElementType(elementType, datum);
    const style = this.getElementComputedStyle(elementType, datum);
    const Ctor = getExtension(elementType, type);
    if (!Ctor)
      return print.warn(`The element ${type} of ${elementType} is not registered.`);
    this.emit(new ElementLifeCycleEvent(GraphEvent.BEFORE_ELEMENT_CREATE, elementType, datum), context);
    const element = this.container.appendChild(new Ctor({
      id,
      context: this.context,
      style
    }));
    this.shapeTypeMap[id] = type;
    this.elementMap[id] = element;
    const { stage = "enter" } = context;
    (_a = this.context.animation) === null || _a === void 0 ? void 0 : _a.add({
      element,
      elementType,
      stage,
      originalStyle: Object.assign({}, element.attributes),
      updatedStyle: style
    }, {
      after: () => {
        var _a2;
        this.emit(new ElementLifeCycleEvent(GraphEvent.AFTER_ELEMENT_CREATE, elementType, datum), context);
        (_a2 = element.onCreate) === null || _a2 === void 0 ? void 0 : _a2.call(element);
      }
    });
  }
  createElements(data, context) {
    const { nodes, edges, combos } = data;
    const iteration = [
      ["node", nodes],
      ["combo", combos],
      ["edge", edges]
    ];
    iteration.forEach(([elementType, elementData]) => {
      elementData.forEach((datum) => this.createElement(elementType, datum, context));
    });
  }
  getUpdateStageStyle(elementType, datum, context) {
    const { stage = "update" } = context;
    if (stage === "translate") {
      if (elementType === "node" || elementType === "combo") {
        const { style: { x: x4 = 0, y: y4 = 0, z: z4 = 0 } = {} } = datum;
        return { x: x4, y: y4, z: z4 };
      } else
        return {};
    }
    return this.getElementComputedStyle(elementType, datum);
  }
  updateElement(elementType, datum, context) {
    var _a;
    const id = idOf(datum);
    const { stage = "update" } = context;
    const element = this.getElement(id);
    if (!element)
      return () => null;
    this.emit(new ElementLifeCycleEvent(GraphEvent.BEFORE_ELEMENT_UPDATE, elementType, datum), context);
    const type = this.getElementType(elementType, datum);
    const style = this.getUpdateStageStyle(elementType, datum, context);
    if (this.shapeTypeMap[id] !== type) {
      element.destroy();
      delete this.shapeTypeMap[id];
      delete this.elementMap[id];
      this.createElement(elementType, datum, { animation: false, silence: true });
    }
    const exactStage = stage !== "visibility" ? stage : style.visibility === "hidden" ? "hide" : "show";
    if (exactStage === "hide")
      delete style["visibility"];
    (_a = this.context.animation) === null || _a === void 0 ? void 0 : _a.add({
      element,
      elementType,
      stage: exactStage,
      originalStyle: Object.assign({}, element.attributes),
      updatedStyle: style
    }, {
      before: () => {
        const element2 = this.elementMap[id];
        if (stage !== "collapse")
          updateStyle(element2, style);
        if (stage === "visibility") {
          if (!hasCachedStyle(element2, "opacity"))
            cacheStyle(element2, "opacity");
          this.visibilityCache.set(element2, exactStage === "show" ? "visible" : "hidden");
          if (exactStage === "show")
            setVisibility(element2, "visible");
        }
      },
      after: () => {
        var _a2;
        const element2 = this.elementMap[id];
        if (stage === "collapse")
          updateStyle(element2, style);
        if (exactStage === "hide")
          setVisibility(element2, this.visibilityCache.get(element2));
        this.emit(new ElementLifeCycleEvent(GraphEvent.AFTER_ELEMENT_UPDATE, elementType, datum), context);
        (_a2 = element2.onUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(element2);
      }
    });
  }
  updateElements(data, context) {
    const { nodes, edges, combos } = data;
    const iteration = [
      ["node", nodes],
      ["combo", combos],
      ["edge", edges]
    ];
    iteration.forEach(([elementType, elementData]) => {
      elementData.forEach((datum) => this.updateElement(elementType, datum, context));
    });
  }
  /**
   * <zh/> 
   *
   * <en/> mark destroy element
   * @param data - <zh/>  | <en/> draw data
   */
  markDestroyElement(data) {
    Object.values(data.remove).forEach((elementData) => {
      elementData.forEach((datum) => {
        const id = idOf(datum);
        const element = this.getElement(id);
        if (element)
          markToBeDestroyed(element);
      });
    });
  }
  destroyElement(elementType, datum, context) {
    var _a;
    const { stage = "exit" } = context;
    const id = idOf(datum);
    const element = this.elementMap[id];
    if (!element)
      return () => null;
    this.emit(new ElementLifeCycleEvent(GraphEvent.BEFORE_ELEMENT_DESTROY, elementType, datum), context);
    (_a = this.context.animation) === null || _a === void 0 ? void 0 : _a.add({
      element,
      elementType,
      stage,
      originalStyle: Object.assign({}, element.attributes),
      updatedStyle: {}
    }, {
      after: () => {
        var _a2;
        this.clearElement(id);
        element.destroy();
        (_a2 = element.onDestroy) === null || _a2 === void 0 ? void 0 : _a2.call(element);
        this.emit(new ElementLifeCycleEvent(GraphEvent.AFTER_ELEMENT_DESTROY, elementType, datum), context);
      }
    });
  }
  destroyElements(data, context) {
    const { nodes, edges, combos } = data;
    const iteration = [
      ["combo", combos],
      ["edge", edges],
      ["node", nodes]
    ];
    iteration.forEach(([elementType, elementData]) => {
      elementData.forEach((datum) => this.destroyElement(elementType, datum, context));
    });
  }
  clearElement(id) {
    delete this.paletteStyle[id];
    delete this.defaultStyle[id];
    delete this.stateStyle[id];
    delete this.elementMap[id];
    delete this.shapeTypeMap[id];
  }
  /**
   * <zh/> 
   *
   * <en/> Align the layout result to the element to avoid view offset. Will modify the layout result
   * @param layoutResult - <zh/>  | <en/> layout result
   * @param id - <zh/>  ID | <en/> element ID
   */
  alignLayoutResultToElement(layoutResult, id) {
    var _a, _b;
    const target = (_a = layoutResult.nodes) === null || _a === void 0 ? void 0 : _a.find((node) => idOf(node) === id);
    if (target) {
      const originalPosition = positionOf(this.context.model.getNodeLikeDatum(id));
      const modifiedPosition = positionOf(target);
      const delta = subtract(originalPosition, modifiedPosition);
      (_b = layoutResult.nodes) === null || _b === void 0 ? void 0 : _b.forEach((node) => {
        var _a2, _b2, _c;
        if ((_a2 = node.style) === null || _a2 === void 0 ? void 0 : _a2.x)
          node.style.x += delta[0];
        if ((_b2 = node.style) === null || _b2 === void 0 ? void 0 : _b2.y)
          node.style.y += delta[1];
        if ((_c = node.style) === null || _c === void 0 ? void 0 : _c.z)
          node.style.z += delta[2] || 0;
      });
    }
  }
  /**
   * <zh/> 
   *
   * <en/> Sync layout result
   * @param id - <zh/>  ID | <en/> element ID
   * @param align - <zh/>  | <en/> whether to align
   */
  syncLayoutResult(id, align) {
    return __awaiter24(this, void 0, void 0, function* () {
      const { layout: layout2, model } = this.context;
      if (!layout2)
        return;
      const layoutOptions = this.context.options.layout;
      const forcePreLayout = (opts) => {
        if (Array.isArray(opts)) {
          return opts.map((o3) => Object.assign(Object.assign({}, o3), { preLayout: true }));
        }
        return Object.assign(Object.assign({}, opts), { preLayout: true });
      };
      const layoutResult = yield layout2.simulate(layoutOptions ? forcePreLayout(layoutOptions) : void 0);
      if (align)
        this.alignLayoutResultToElement(layoutResult, id);
      model.updateData(layoutResult);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> collapse node
   * @param id - <zh/>  ID | <en/> element ID
   * @param options - <zh/>  | <en/> options
   */
  collapseNode(id, options) {
    return __awaiter24(this, void 0, void 0, function* () {
      var _a;
      const { animation, align } = options;
      yield this.syncLayoutResult(id, align);
      const data = this.computeChangesAndDrawData({ stage: "collapse", animation });
      if (!data)
        return;
      const { drawData } = data;
      const { add: add4, remove, update } = drawData;
      this.markDestroyElement(drawData);
      const context = { animation, stage: "collapse", data: drawData };
      this.destroyElements(remove, context);
      this.createElements(add4, context);
      this.updateElements(update, context);
      yield (_a = this.context.animation.animate(animation, {
        beforeAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.COLLAPSE, animation2, drawData), context),
        afterAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.COLLAPSE, animation2, drawData), context)
      }, {
        collapse: {
          target: id,
          descendants: Array.from(remove.nodes).map(([, node]) => idOf(node)),
          position: positionOf(update.nodes.get(id))
        }
      })) === null || _a === void 0 ? void 0 : _a.finished;
    });
  }
  /**
   * <zh/> 
   *
   * <en/> expand node
   * @param id - <zh/>  ID | <en/> element ID
   * @param animation - <zh/>  true | <en/> Whether to use animation, default is true
   */
  expandNode(id, options) {
    return __awaiter24(this, void 0, void 0, function* () {
      var _a;
      const { model } = this.context;
      const { animation, align } = options;
      const position2 = positionOf(model.getNodeData([id])[0]);
      yield this.syncLayoutResult(id, align);
      const data = this.computeChangesAndDrawData({ stage: "expand", animation });
      this.createElements(data.drawData.add, { animation: false, stage: "expand", target: id });
      this.context.animation.clear();
      this.computeStyle("expand");
      if (!data)
        return;
      const { drawData } = data;
      const { update, add: add4 } = drawData;
      const context = { animation, stage: "expand", data: drawData };
      add4.edges.forEach((edge) => update.edges.set(idOf(edge), edge));
      add4.nodes.forEach((node) => update.nodes.set(idOf(node), node));
      this.updateElements(update, context);
      yield (_a = this.context.animation.animate(animation, {
        beforeAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.EXPAND, animation2, drawData), context),
        afterAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.EXPAND, animation2, drawData), context)
      }, {
        expand: {
          target: id,
          descendants: Array.from(add4.nodes).map(([, node]) => idOf(node)),
          position: position2
        }
      })) === null || _a === void 0 ? void 0 : _a.finished;
    });
  }
  collapseCombo(id, animation) {
    return __awaiter24(this, void 0, void 0, function* () {
      var _a;
      const { model, element } = this.context;
      if (model.getAncestorsData(id, COMBO_KEY).some((datum) => isCollapsed(datum)))
        return;
      const combo = element.getElement(id);
      const position2 = combo.getComboPosition(Object.assign(Object.assign({}, combo.attributes), { collapsed: true }));
      const data = this.computeChangesAndDrawData({ stage: "collapse", animation });
      if (!data)
        return;
      const { dataChanges, drawData } = data;
      this.markDestroyElement(drawData);
      const { update, remove } = drawData;
      const context = { animation, stage: "collapse", data: drawData };
      this.destroyElements(remove, context);
      this.updateElements(update, context);
      const idsOf2 = (data2) => Array.from(data2).map(([, node]) => idOf(node));
      yield (_a = this.context.animation.animate(animation, {
        before: () => this.emit(new GraphLifeCycleEvent(GraphEvent.BEFORE_DRAW, { dataChanges, animation }), context),
        beforeAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.COLLAPSE, animation2, drawData), context),
        afterAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.COLLAPSE, animation2, drawData), context),
        after: () => this.emit(new GraphLifeCycleEvent(GraphEvent.AFTER_DRAW, { dataChanges, animation }), context)
      }, {
        collapse: {
          target: id,
          descendants: [...idsOf2(remove.nodes), ...idsOf2(remove.combos)],
          position: position2
        }
      })) === null || _a === void 0 ? void 0 : _a.finished;
    });
  }
  expandCombo(id, animation) {
    return __awaiter24(this, void 0, void 0, function* () {
      var _a;
      const { model } = this.context;
      const position2 = positionOf(model.getComboData([id])[0]);
      this.computeStyle("expand");
      const data = this.computeChangesAndDrawData({ stage: "expand", animation });
      if (!data)
        return;
      const { dataChanges, drawData } = data;
      const { add: add4, update } = drawData;
      const context = { animation, stage: "expand", data: drawData, target: id };
      this.createElements(add4, context);
      this.updateElements(update, context);
      const idsOf2 = (data2) => Array.from(data2).map(([, node]) => idOf(node));
      yield (_a = this.context.animation.animate(animation, {
        before: () => this.emit(new GraphLifeCycleEvent(GraphEvent.BEFORE_DRAW, { dataChanges, animation }), context),
        beforeAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.EXPAND, animation2, drawData), context),
        afterAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.EXPAND, animation2, drawData), context),
        after: () => this.emit(new GraphLifeCycleEvent(GraphEvent.AFTER_DRAW, { dataChanges, animation }), context)
      }, {
        expand: {
          target: id,
          descendants: [...idsOf2(add4.nodes), ...idsOf2(add4.combos)],
          position: position2
        }
      })) === null || _a === void 0 ? void 0 : _a.finished;
    });
  }
  /**
   * <zh/> 
   *
   * <en/> clear all elements
   */
  clear() {
    this.container.destroy();
    this.initContainer();
    this.elementMap = {};
    this.shapeTypeMap = {};
    this.defaultStyle = {};
    this.stateStyle = {};
    this.paletteStyle = {};
  }
  destroy() {
    this.clear();
    this.container.destroy();
    this.context = {};
  }
};

// node_modules/@antv/g6/esm/runtime/layout.js
var __awaiter25 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest23 = function(s2, e2) {
  var t3 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t3[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t3[p3[i2]] = s2[p3[i2]];
    }
  return t3;
};
var LayoutController = class {
  get presetOptions() {
    return {
      animation: !!getAnimationOptions(this.context.options, true)
    };
  }
  get options() {
    const { options } = this.context;
    return options.layout;
  }
  constructor(context) {
    this.instances = [];
    this.context = context;
  }
  getLayoutInstance() {
    return this.instances;
  }
  /**
   * <zh/> 
   *
   * <en/> Pre-layout, that is, perform layout before drawing
   * @param data - <zh/>  | <en/> Draw data
   * @remarks
   * <zh/> 
   *
   * <en/> Pre-layout should only be executed before the first drawing, and subsequent updates will not trigger
   */
  preLayout(data) {
    return __awaiter25(this, void 0, void 0, function* () {
      var _a, _b, _c, _d;
      const { graph, model } = this.context;
      const { add: add4 } = data;
      emit(graph, new GraphLifeCycleEvent(GraphEvent.BEFORE_LAYOUT, { type: "pre" }));
      const simulate = yield (_a = this.context.layout) === null || _a === void 0 ? void 0 : _a.simulate();
      (_b = simulate === null || simulate === void 0 ? void 0 : simulate.nodes) === null || _b === void 0 ? void 0 : _b.forEach((l3) => {
        const id = idOf(l3);
        const node = add4.nodes.get(id);
        model.syncNodeLikeDatum(l3);
        if (node)
          Object.assign(node.style, l3.style);
      });
      (_c = simulate === null || simulate === void 0 ? void 0 : simulate.edges) === null || _c === void 0 ? void 0 : _c.forEach((l3) => {
        const id = idOf(l3);
        const edge = add4.edges.get(id);
        model.syncEdgeDatum(l3);
        if (edge)
          Object.assign(edge.style, l3.style);
      });
      (_d = simulate === null || simulate === void 0 ? void 0 : simulate.combos) === null || _d === void 0 ? void 0 : _d.forEach((l3) => {
        const id = idOf(l3);
        const combo = add4.combos.get(id);
        model.syncNodeLikeDatum(l3);
        if (combo)
          Object.assign(combo.style, l3.style);
      });
      emit(graph, new GraphLifeCycleEvent(GraphEvent.AFTER_LAYOUT, { type: "pre" }));
      this.transformDataAfterLayout("pre", data);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Post layout, that is, perform layout after drawing
   * @param layoutOptions - <zh/>  | <en/> Layout options
   */
  postLayout() {
    return __awaiter25(this, arguments, void 0, function* (layoutOptions = this.options) {
      if (!layoutOptions)
        return;
      const pipeline = Array.isArray(layoutOptions) ? layoutOptions : [layoutOptions];
      const { graph } = this.context;
      emit(graph, new GraphLifeCycleEvent(GraphEvent.BEFORE_LAYOUT, { type: "post" }));
      for (let index = 0; index < pipeline.length; index++) {
        const options = pipeline[index];
        const data = this.getLayoutData(options);
        const opts = Object.assign(Object.assign({}, this.presetOptions), options);
        emit(graph, new GraphLifeCycleEvent(GraphEvent.BEFORE_STAGE_LAYOUT, { options: opts, index }));
        const result = yield this.stepLayout(data, opts, index);
        emit(graph, new GraphLifeCycleEvent(GraphEvent.AFTER_STAGE_LAYOUT, { options: opts, index }));
        if (!options.animation) {
          this.updateElementPosition(result, false);
        }
      }
      emit(graph, new GraphLifeCycleEvent(GraphEvent.AFTER_LAYOUT, { type: "post" }));
      this.transformDataAfterLayout("post");
    });
  }
  transformDataAfterLayout(type, data) {
    const transforms = this.context.transform.getTransformInstance();
    Object.values(transforms).forEach((transform) => transform.afterLayout(type, data));
  }
  /**
   * <zh/> 
   *
   * <en/> Simulate layout
   * @param options - <zh/>  | <en/> Layout options
   * @returns <zh/>  | <en/> Simulated layout result
   */
  simulate() {
    return __awaiter25(this, arguments, void 0, function* (options = this.options) {
      if (!options)
        return {};
      const pipeline = Array.isArray(options) ? options : [options];
      let simulation = {};
      for (let index = 0; index < pipeline.length; index++) {
        const options2 = pipeline[index];
        const data = this.getLayoutData(options2);
        const result = yield this.stepLayout(data, Object.assign(Object.assign(Object.assign({}, this.presetOptions), options2), { animation: false }), index);
        simulation = result;
      }
      return simulation;
    });
  }
  stepLayout(data, options, index) {
    return __awaiter25(this, void 0, void 0, function* () {
      if (isTreeLayout(options))
        return yield this.treeLayout(data, options, index);
      return yield this.graphLayout(data, options, index);
    });
  }
  graphLayout(data, options, index) {
    return __awaiter25(this, void 0, void 0, function* () {
      const { animation, enableWorker, iterations = 300 } = options;
      const layout2 = this.initGraphLayout(options);
      if (!layout2)
        return {};
      this.instances[index] = layout2;
      this.instance = layout2;
      if (enableWorker) {
        const rawLayout = layout2;
        this.supervisor = new Supervisor(rawLayout.graphData2LayoutModel(data), rawLayout.instance, { iterations });
        return layoutMapping2GraphData(yield this.supervisor.execute());
      }
      if (isLayoutWithIterations(layout2)) {
        if (animation) {
          return yield layout2.execute(data, {
            onTick: (tickData) => {
              this.updateElementPosition(tickData, false);
            }
          });
        }
        layout2.execute(data);
        layout2.stop();
        return layout2.tick(iterations);
      }
      const layoutResult = yield layout2.execute(data);
      if (animation) {
        const animationResult = this.updateElementPosition(layoutResult, animation);
        yield animationResult === null || animationResult === void 0 ? void 0 : animationResult.finished;
      }
      return layoutResult;
    });
  }
  treeLayout(data, options, index) {
    return __awaiter25(this, void 0, void 0, function* () {
      const { type, animation } = options;
      const layout2 = getExtension("layout", type);
      if (!layout2)
        return {};
      const { nodes = [], edges = [] } = data;
      const model = new Graph2({
        nodes: nodes.map((node) => ({ id: idOf(node), data: node.data || {} })),
        edges: edges.map((edge) => ({ id: idOf(edge), source: edge.source, target: edge.target, data: edge.data || {} }))
      });
      createTreeStructure(model);
      const layoutPreset = { nodes: [], edges: [] };
      const layoutResult = { nodes: [], edges: [] };
      const roots = model.getRoots(TREE_KEY);
      roots.forEach((root) => {
        dfs(root, (node) => {
          node.children = model.getSuccessors(node.id);
        }, (node) => model.getSuccessors(node.id), "TB");
        const result = layout2(root, options);
        const { x: rx, y: ry, z: rz = 0 } = result;
        dfs(result, (node) => {
          const { id, x: x4, y: y4, z: z4 = 0 } = node;
          layoutPreset.nodes.push({ id, style: { x: rx, y: ry, z: rz } });
          layoutResult.nodes.push({ id, style: { x: x4, y: y4, z: z4 } });
        }, (node) => node.children, "TB");
      });
      const offset = this.inferTreeLayoutOffset(layoutResult);
      applyTreeLayoutOffset(layoutResult, offset);
      if (animation) {
        applyTreeLayoutOffset(layoutPreset, offset);
        this.updateElementPosition(layoutPreset, false);
        const animationResult = this.updateElementPosition(layoutResult, animation);
        yield animationResult === null || animationResult === void 0 ? void 0 : animationResult.finished;
      }
      return layoutResult;
    });
  }
  inferTreeLayoutOffset(data) {
    var _a;
    let [minX, maxX] = [Infinity, -Infinity];
    let [minY, maxY] = [Infinity, -Infinity];
    (_a = data.nodes) === null || _a === void 0 ? void 0 : _a.forEach((node) => {
      const { x: x4 = 0, y: y4 = 0 } = node.style || {};
      minX = Math.min(minX, x4);
      maxX = Math.max(maxX, x4);
      minY = Math.min(minY, y4);
      maxY = Math.max(maxY, y4);
    });
    const { canvas: canvas2 } = this.context;
    const canvasSize = canvas2.getSize();
    const [x1, y1] = canvas2.getCanvasByViewport([0, 0]);
    const [x22, y22] = canvas2.getCanvasByViewport(canvasSize);
    if (minX >= x1 && maxX <= x22 && minY >= y1 && maxY <= y22)
      return [0, 0];
    const cx = (x1 + x22) / 2;
    const cy = (y1 + y22) / 2;
    return [cx - (minX + maxX) / 2, cy - (minY + maxY) / 2];
  }
  stopLayout() {
    if (this.instance && isLayoutWithIterations(this.instance)) {
      this.instance.stop();
      this.instance = void 0;
    }
    if (this.supervisor) {
      this.supervisor.stop();
      this.supervisor = void 0;
    }
    if (this.animationResult) {
      this.animationResult.finish();
      this.animationResult = void 0;
    }
  }
  getLayoutData(options) {
    const { nodeFilter = () => true, comboFilter = () => true, preLayout = false, isLayoutInvisibleNodes = false } = options;
    const { nodes, edges, combos } = this.context.model.getData();
    const { element, model } = this.context;
    const getElement = (id) => element.getElement(id);
    const filterFn = preLayout ? (node) => {
      var _a;
      if (!isLayoutInvisibleNodes) {
        if (((_a = node.style) === null || _a === void 0 ? void 0 : _a.visibility) === "hidden")
          return false;
        if (model.getAncestorsData(node.id, TREE_KEY).some(isCollapsed))
          return false;
        if (model.getAncestorsData(node.id, COMBO_KEY).some(isCollapsed))
          return false;
      }
      return nodeFilter(node);
    } : (node) => {
      const id = idOf(node);
      const element2 = getElement(id);
      if (!element2)
        return false;
      if (isToBeDestroyed(element2))
        return false;
      return nodeFilter(node);
    };
    const nodesToLayout = nodes.filter(filterFn);
    const combosToLayout = combos.filter(comboFilter);
    const nodeLikeIdsMap = new Map(nodesToLayout.map((node) => [idOf(node), node]));
    combosToLayout.forEach((combo) => nodeLikeIdsMap.set(idOf(combo), combo));
    const edgesToLayout = edges.filter(({ source, target }) => {
      return nodeLikeIdsMap.has(source) && nodeLikeIdsMap.has(target);
    });
    return {
      nodes: nodesToLayout,
      edges: edgesToLayout,
      combos: combosToLayout
    };
  }
  /**
   * <zh/> 
   *
   * <en/> Create layout instance
   * @param options - <zh/>  | <en/> Layout options
   * @returns <zh/>  | <en/> Layout object
   */
  initGraphLayout(options) {
    var _a;
    const { element, viewport } = this.context;
    const { type, enableWorker, animation, iterations } = options, restOptions = __rest23(options, ["type", "enableWorker", "animation", "iterations"]);
    const [width2, height] = viewport.getCanvasSize();
    const center = [width2 / 2, height / 2];
    const nodeSize = (_a = options === null || options === void 0 ? void 0 : options.nodeSize) !== null && _a !== void 0 ? _a : (node) => {
      const nodeElement = element === null || element === void 0 ? void 0 : element.getElement(node.id);
      if (nodeElement)
        return nodeElement.attributes.size;
      return element === null || element === void 0 ? void 0 : element.getElementComputedStyle("node", node).size;
    };
    const Ctor = getExtension("layout", type);
    if (!Ctor)
      return print.warn(`The layout of ${type} is not registered.`);
    const STDCtor = Object.getPrototypeOf(Ctor.prototype) === BaseLayout.prototype ? Ctor : layoutAdapter(Ctor, this.context);
    const layout2 = new STDCtor(this.context);
    const config = { nodeSize, width: width2, height, center };
    switch (layout2.id) {
      case "d3-force":
      case "d3-force-3d":
        Object.assign(config, {
          center: { x: width2 / 2, y: height / 2, z: 0 }
        });
        break;
      default:
        break;
    }
    deep_mix_default(layout2.options, config, restOptions);
    return layout2;
  }
  updateElementPosition(layoutResult, animation) {
    const { model, element } = this.context;
    if (!element)
      return null;
    model.updateData(layoutResult);
    return element.draw({ animation, silence: true });
  }
  destroy() {
    var _a;
    this.stopLayout();
    this.context = {};
    (_a = this.supervisor) === null || _a === void 0 ? void 0 : _a.kill();
    this.supervisor = void 0;
    this.instance = void 0;
    this.instances = [];
    this.animationResult = void 0;
  }
};
var applyTreeLayoutOffset = (data, offset) => {
  var _a;
  const [ox, oy] = offset;
  (_a = data.nodes) === null || _a === void 0 ? void 0 : _a.forEach((node) => {
    if (node.style) {
      const { x: x4 = 0, y: y4 = 0 } = node.style;
      node.style.x = x4 + ox;
      node.style.y = y4 + oy;
    } else {
      node.style = { x: ox, y: oy };
    }
  });
};

// node_modules/@antv/g6/esm/runtime/options.js
function inferOptions(options) {
  const flow = [inferLayoutOptions];
  return flow.reduce((acc, infer) => infer(acc), options);
}
function inferLayoutOptions(options) {
  if (!options.layout)
    return options;
  if (Array.isArray(options.layout))
    return options;
  if ("preLayout" in options.layout)
    return options;
  if ([
    "antv-dagre",
    "combo-combined",
    "compact-box",
    "circular",
    "concentric",
    "dagre",
    "fishbone",
    "grid",
    "indented",
    "mds",
    "radial",
    "random",
    "snake",
    // <zh/>  preLayout false
    // <en/> The label position of the following layouts needs to be adapted, and preLayout needs to be manually configured as false
    "dendrogram",
    "mindmap"
  ].includes(options.layout.type)) {
    options.layout.preLayout = true;
  }
  return options;
}

// node_modules/@antv/g6/esm/runtime/plugin.js
var PluginController = class extends ExtensionController {
  constructor(context) {
    super(context);
    this.category = "plugin";
    this.setPlugins(this.context.options.plugins || []);
  }
  setPlugins(plugins) {
    this.setExtensions(plugins);
  }
  getPluginInstance(key) {
    const exactly = this.extensionMap[key];
    if (exactly)
      return exactly;
    print.warn(`Cannot find the plugin ${key}, will try to find it by type.`);
    const fussily = this.extensions.find((extension) => extension.type === key);
    if (fussily)
      return this.extensionMap[fussily.key];
  }
};

// node_modules/@antv/g6/esm/runtime/transform.js
var REQUIRED_TRANSFORMS = [
  "update-related-edges",
  "collapse-expand-node",
  "collapse-expand-combo",
  "get-edge-actual-ends",
  "arrange-draw-order"
];
var TransformController = class extends ExtensionController {
  constructor(context) {
    super(context);
    this.category = "transform";
    this.setTransforms(this.context.options.transforms || []);
  }
  getTransforms() {
  }
  setTransforms(transforms) {
    this.setExtensions([
      ...REQUIRED_TRANSFORMS.slice(0, REQUIRED_TRANSFORMS.length - 1),
      ...transforms,
      REQUIRED_TRANSFORMS[REQUIRED_TRANSFORMS.length - 1]
    ]);
  }
  getTransformInstance(key) {
    return key ? this.extensionMap[key] : this.extensionMap;
  }
};

// node_modules/@antv/g6/esm/runtime/viewport.js
var __awaiter26 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ViewportController = class {
  get padding() {
    return parsePadding(this.context.options.padding);
  }
  get paddingOffset() {
    const [top, right, bottom, left] = this.padding;
    const [offsetX, offsetY, offsetZ] = [(left - right) / 2, (top - bottom) / 2, 0];
    return [offsetX, offsetY, offsetZ];
  }
  constructor(context) {
    this.landmarkCounter = 0;
    this.context = context;
    const [px, py] = this.paddingOffset;
    const { zoom, rotation, x: x4 = px, y: y4 = py } = context.options;
    this.transform({ mode: "absolute", scale: zoom, translate: [x4, y4], rotate: rotation }, false);
  }
  get camera() {
    const { canvas: canvas2 } = this.context;
    return new Proxy(canvas2.getCamera(), {
      get: (target, prop) => {
        const layers = Object.entries(canvas2.getLayers()).filter(([name]) => !["main"].includes(name));
        const cameras = layers.map(([, layer]) => layer.getCamera());
        const value = target[prop];
        if (typeof value === "function") {
          return (...args) => {
            const result = value.apply(target, args);
            cameras.forEach((camera) => {
              camera[prop].apply(camera, args);
            });
            return result;
          };
        }
      }
    });
  }
  createLandmark(options) {
    return this.camera.createLandmark(`landmark-${this.landmarkCounter++}`, options);
  }
  getAnimation(animation) {
    const finalAnimation = getAnimationOptions(this.context.options, animation);
    if (!finalAnimation)
      return false;
    return pick_default(Object.assign({}, finalAnimation), ["easing", "duration"]);
  }
  getCanvasSize() {
    const { canvas: canvas2 } = this.context;
    const { width: width2 = 0, height = 0 } = canvas2.getConfig();
    return [width2, height];
  }
  /**
   * <zh/> 
   *
   * <en/> Get the center coordinates of the canvas
   * @returns - <zh/>  | <en/> Center coordinates of the canvas
   * @remarks
   * <zh/> 
   *
   * <en/> Calculate the center coordinates based on the width and height of the canvas, not affected by the viewport transformation
   */
  getCanvasCenter() {
    const { canvas: canvas2 } = this.context;
    const { width: width2 = 0, height = 0 } = canvas2.getConfig();
    return [width2 / 2, height / 2, 0];
  }
  /**
   * <zh/> 
   *
   * <en/> Current viewport center coordinates
   * @returns - <zh/>  | <en/> Viewport center coordinates
   * @remarks
   * <zh/> 
   *
   * <en/> With the origin of the canvas as the origin, affected by the viewport transformation
   */
  getViewportCenter() {
    const [x4, y4] = this.camera.getPosition();
    return [x4, y4, 0];
  }
  getGraphCenter() {
    return this.context.graph.getViewportByCanvas(this.getCanvasCenter());
  }
  getZoom() {
    return this.camera.getZoom();
  }
  getRotation() {
    return this.camera.getRoll();
  }
  getTranslateOptions(options) {
    const { camera } = this;
    const { mode, translate = [] } = options;
    const currentZoom = this.getZoom();
    const position2 = camera.getPosition();
    const focalPoint = camera.getFocalPoint();
    const [cx, cy] = this.getCanvasCenter();
    const [x4 = 0, y4 = 0, z4 = 0] = translate;
    const delta = divide([-x4, -y4, -z4], currentZoom);
    return mode === "relative" ? {
      position: add(position2, delta),
      focalPoint: add(focalPoint, delta)
    } : {
      position: add([cx, cy, position2[2]], delta),
      focalPoint: add([cx, cy, focalPoint[2]], delta)
    };
  }
  getRotateOptions(options) {
    const { mode, rotate: rotate2 = 0 } = options;
    const roll = mode === "relative" ? this.camera.getRoll() + rotate2 : rotate2;
    return { roll };
  }
  getZoomOptions(options) {
    const { zoomRange } = this.context.options;
    const currentZoom = this.camera.getZoom();
    const { mode, scale: scale2 = 1 } = options;
    return clamp_default(mode === "relative" ? currentZoom * scale2 : scale2, ...zoomRange);
  }
  transform(options, animation) {
    return __awaiter26(this, void 0, void 0, function* () {
      const { graph } = this.context;
      const { translate, rotate: rotate2, scale: scale2, origin } = options;
      this.cancelAnimation();
      const _animation = this.getAnimation(animation);
      emit(graph, new ViewportEvent(GraphEvent.BEFORE_TRANSFORM, options));
      if (!rotate2 && scale2 && !translate && origin && !_animation) {
        this.camera.setZoomByViewportPoint(this.getZoomOptions(options), origin);
        emit(graph, new ViewportEvent(GraphEvent.AFTER_TRANSFORM, options));
        return;
      }
      const landmarkOptions = {};
      if (translate)
        Object.assign(landmarkOptions, this.getTranslateOptions(options));
      if (isNumber(rotate2))
        Object.assign(landmarkOptions, this.getRotateOptions(options));
      if (isNumber(scale2))
        Object.assign(landmarkOptions, { zoom: this.getZoomOptions(options) });
      if (_animation) {
        emit(graph, new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.TRANSFORM, null, options));
        return new Promise((resolve) => {
          this.transformResolver = resolve;
          this.camera.gotoLandmark(this.createLandmark(landmarkOptions), Object.assign(Object.assign({}, _animation), { onfinish: () => {
            emit(graph, new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.TRANSFORM, null, options));
            emit(graph, new ViewportEvent(GraphEvent.AFTER_TRANSFORM, options));
            this.transformResolver = void 0;
            resolve();
          } }));
        });
      } else {
        this.camera.gotoLandmark(this.createLandmark(landmarkOptions), {
          duration: 0
        });
        emit(graph, new ViewportEvent(GraphEvent.AFTER_TRANSFORM, options));
      }
    });
  }
  fitView(options, animation) {
    return __awaiter26(this, void 0, void 0, function* () {
      const [top, right, bottom, left] = this.padding;
      const { when = "always", direction = "both" } = options || {};
      const [width2, height] = this.context.canvas.getSize();
      const innerWidth = width2 - left - right;
      const innerHeight = height - top - bottom;
      const canvasBounds = this.context.canvas.getBounds();
      const bboxInViewPort = this.getBBoxInViewport(canvasBounds);
      const [contentWidth, contentHeight] = getBBoxSize(bboxInViewPort);
      const isOverflow = direction === "x" && contentWidth >= innerWidth || direction === "y" && contentHeight >= innerHeight || direction === "both" && contentWidth >= innerWidth && contentHeight >= innerHeight;
      if (when === "overflow" && !isOverflow)
        return yield this.fitCenter({ animation });
      const scaleX = innerWidth / contentWidth;
      const scaleY = innerHeight / contentHeight;
      const scale2 = direction === "x" ? scaleX : direction === "y" ? scaleY : Math.min(scaleX, scaleY);
      const _animation = this.getAnimation(animation);
      if (!Number.isFinite(scale2)) {
        return;
      }
      yield this.transform({
        mode: "relative",
        scale: scale2,
        translate: add(subtract(this.getCanvasCenter(), this.getBBoxInViewport(canvasBounds).center), divide(this.paddingOffset, scale2))
      }, _animation);
    });
  }
  fitCenter(options) {
    return __awaiter26(this, void 0, void 0, function* () {
      const canvasBounds = this.context.canvas.getBounds();
      yield this.focus(canvasBounds, options);
    });
  }
  focusElements(ids_1) {
    return __awaiter26(this, arguments, void 0, function* (ids, options = {}) {
      const { element } = this.context;
      if (!element)
        return;
      const getBoundsOf = (el) => options.shapes ? el.getShape(options.shapes).getRenderBounds() : el.getRenderBounds();
      const elementsBounds = getCombinedBBox(ids.map((id) => getBoundsOf(element.getElement(id))));
      yield this.focus(elementsBounds, options);
    });
  }
  focus(bbox, options) {
    return __awaiter26(this, void 0, void 0, function* () {
      const center = this.context.graph.getViewportByCanvas(bbox.center);
      const position2 = options.position || this.getCanvasCenter();
      const delta = subtract(position2, center);
      yield this.transform({ mode: "relative", translate: add(delta, this.paddingOffset) }, options.animation);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Get the bounding box of the canvas element in the viewport
   * @param bbox - <zh/>  | <en/> Canvas element bounding box
   * @returns - <zh/>  | <en/> Bounding box in the viewport
   */
  getBBoxInViewport(bbox) {
    const { min: min2, max: max2 } = bbox;
    const { graph } = this.context;
    const [x1, y1] = graph.getViewportByCanvas(min2);
    const [x22, y22] = graph.getViewportByCanvas(max2);
    const bboxInViewport = new AABB();
    bboxInViewport.setMinMax([x1, y1, 0], [x22, y22, 0]);
    return bboxInViewport;
  }
  /**
   * <zh/> 
   *
   * <en/> Determine whether the point or bounding box is in the viewport
   * @param target - <zh/>  | <en/> Point or bounding box
   * @param complete - <zh/>  | <en/> Whether it is completely in the viewport
   * @param tolerance - <zh/>  | <en/> Tolerance outside the viewport
   * @returns - <zh/>  | <en/> Whether it is in the viewport
   */
  isInViewport(target, complete = false, tolerance = 0) {
    const { graph } = this.context;
    const size2 = this.getCanvasSize();
    const [x1, y1] = graph.getCanvasByViewport([0, 0]);
    const [x22, y22] = graph.getCanvasByViewport(size2);
    let viewportBBox = new AABB();
    viewportBBox.setMinMax([x1, y1, 0], [x22, y22, 0]);
    if (tolerance) {
      viewportBBox = getExpandedBBox(viewportBBox, tolerance);
    }
    return isPoint(target) ? isPointInBBox(target, viewportBBox) : !complete ? viewportBBox.intersects(target) : isBBoxInside(target, viewportBBox);
  }
  cancelAnimation() {
    var _a, _b;
    if ((_a = this.camera.landmarks) === null || _a === void 0 ? void 0 : _a.length) {
      this.camera.cancelLandmarkAnimation();
    }
    (_b = this.transformResolver) === null || _b === void 0 ? void 0 : _b.call(this);
  }
};

// node_modules/@antv/g6/esm/runtime/graph.js
var __awaiter27 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Graph3 = class _Graph extends esm_default {
  constructor(options) {
    var _a;
    super();
    this.options = {};
    this.rendered = false;
    this.destroyed = false;
    this.context = {
      model: new DataController()
    };
    this.isCollapsingExpanding = false;
    this.onResize = debounce_default(() => {
      this.resize();
    }, 300);
    this._setOptions(Object.assign({}, _Graph.defaultOptions, options), true);
    this.context.graph = this;
    this.options.autoResize && ((_a = globalThis.addEventListener) === null || _a === void 0 ? void 0 : _a.call(globalThis, "resize", this.onResize));
  }
  /**
   * <zh/> 
   *
   * <en/> Get options
   * @returns <zh/>  | <en/> options
   * @apiCategory option
   */
  getOptions() {
    return this.options;
  }
  /**
   * <zh/> 
   *
   * <en/> Set options
   * @param options - <zh/>  | <en/> options
   * @remarks
   * <zh/>  devicePixelRatiocontainer 
   *
   * <en/> To update devicePixelRatio and container properties, please destroy and recreate the instance
   * @apiCategory option
   */
  setOptions(options) {
    this._setOptions(options, false);
  }
  _setOptions(options, isInit) {
    this.updateCanvas(options);
    Object.assign(this.options, inferOptions(options));
    if (isInit) {
      const { data: data2 } = options;
      if (data2)
        this.addData(data2);
      return;
    }
    const { behaviors, combo, data, edge, layout: layout2, node, plugins, theme, transforms } = options;
    if (behaviors)
      this.setBehaviors(behaviors);
    if (data)
      this.setData(data);
    if (node)
      this.setNode(node);
    if (edge)
      this.setEdge(edge);
    if (combo)
      this.setCombo(combo);
    if (layout2)
      this.setLayout(layout2);
    if (theme)
      this.setTheme(theme);
    if (plugins)
      this.setPlugins(plugins);
    if (transforms)
      this.setTransforms(transforms);
  }
  /**
   * <zh/> 
   *
   * <en/> Get the size of the current canvas container
   * @returns <zh/>  | <en/> canvas size
   * @apiCategory canvas
   */
  getSize() {
    if (this.context.canvas)
      return this.context.canvas.getSize();
    return [this.options.width || 0, this.options.height || 0];
  }
  /**
   * <zh/> 
   *
   * <en/> Set the size of the current canvas container
   * @param width - <zh/>  | <en/> canvas width
   * @param height - <zh/>  | <en/> canvas height
   * @apiCategory canvas
   */
  setSize(width2, height) {
    if (width2)
      this.options.width = width2;
    if (height)
      this.options.height = height;
    this.resize(width2, height);
  }
  /**
   * <zh/> 
   *
   * <en/> Get the zoom range of the current graph
   * @param zoomRange - <zh/>  | <en/> zoom range
   * @apiCategory viewport
   */
  setZoomRange(zoomRange) {
    this.options.zoomRange = zoomRange;
  }
  /**
   * <zh/> 
   *
   * <en/> Get the zoom range of the current graph
   * @returns <zh/>  | <en/> zoom range
   * @apiCategory viewport
   */
  getZoomRange() {
    return this.options.zoomRange;
  }
  /**
   * <zh/> 
   *
   * <en/> Set node mapper
   * @param node - <zh/>  | <en/> node options
   * @remarks
   * <zh/>  `options.node` 
   *
   * <en/> The value of `options.node`
   * @apiCategory element
   */
  setNode(node) {
    this.options.node = node;
    this.context.model.refreshData();
  }
  /**
   * <zh/> 
   *
   * <en/> Set edge mapper
   * @param edge - <zh/>  | <en/> edge options
   * @remarks
   * <zh/>  `options.edge` 
   *
   * <en/> The value of `options.edge`
   * @apiCategory element
   */
  setEdge(edge) {
    this.options.edge = edge;
    this.context.model.refreshData();
  }
  /**
   * <zh/> 
   *
   * <en/> Set combo mapper
   * @param combo - <zh/>  | <en/> combo options
   * @remarks
   * <zh/>  `options.combo` 
   *
   * <en/> The value of `options.combo`
   * @apiCategory element
   */
  setCombo(combo) {
    this.options.combo = combo;
    this.context.model.refreshData();
  }
  /**
   * <zh/> 
   *
   * <en/> Get theme
   * @returns <zh/>  | <en/> current theme
   * @apiCategory theme
   */
  getTheme() {
    return this.options.theme;
  }
  /**
   * <zh/> 
   *
   * <en/> Set theme
   * @param theme - <zh/>  | <en/> theme name
   * @example
   * ```ts
   * graph.setTheme('dark');
   * ```
   * @apiCategory theme
   */
  setTheme(theme) {
    this.options.theme = isFunction(theme) ? theme(this.getTheme()) : theme;
  }
  /**
   * <zh/> 
   *
   * <en/> Set layout
   * @param layout - <zh/>  | <en/> layout options
   * @example
   * ```ts
   * graph.setLayout({
   *  type: 'dagre',
   * })
   * ```
   * @apiCategory layout
   */
  setLayout(layout2) {
    this.options.layout = isFunction(layout2) ? layout2(this.getLayout()) : layout2;
  }
  /**
   * <zh/> 
   *
   * <en/> Get layout options
   * @returns <zh/>  | <en/> layout options
   * @apiCategory layout
   */
  getLayout() {
    return this.options.layout;
  }
  /**
   * <zh/> 
   *
   * <en/> Set behaviors
   * @param behaviors - <zh/>  | <en/> behavior options
   * @remarks
   * <zh/> 
   *
   * <en/> The set behavior will completely replace the original behavior. If you need to add behavior, you can use the following method:
   *
   * ```ts
   * graph.setBehaviors((behaviors) => [...behaviors, { type: 'zoom-canvas' }])
   * ```
   * @apiCategory behavior
   */
  setBehaviors(behaviors) {
    var _a;
    this.options.behaviors = isFunction(behaviors) ? behaviors(this.getBehaviors()) : behaviors;
    (_a = this.context.behavior) === null || _a === void 0 ? void 0 : _a.setBehaviors(this.options.behaviors);
  }
  /**
   * <zh/> 
   *
   * <en/> Update specified behavior options
   * @param behavior - <zh/>  | <en/> behavior options
   * @remarks
   * <zh/>  key 
   *
   * <en/> If you want to update a behavior, you must specify the key field in the behavior options, for example:
   * ```ts
   * {
   *   behaviors: [{ type: 'zoom-canvas', key: 'zoom-canvas' }]
   * }
   *
   * graph.updateBehavior({ key: 'zoom-canvas', enable: false })
   * ```
   * @apiCategory behavior
   */
  updateBehavior(behavior) {
    this.setBehaviors((behaviors) => behaviors.map((_behavior) => {
      if (typeof _behavior === "object" && _behavior.key === behavior.key) {
        return Object.assign(Object.assign({}, _behavior), behavior);
      }
      return _behavior;
    }));
  }
  /**
   * <zh/> 
   *
   * <en/> Get behaviors options
   * @returns <zh/>  | <en/> behavior options
   * @apiCategory behavior
   */
  getBehaviors() {
    return this.options.behaviors || [];
  }
  /**
   * <zh/> 
   *
   * <en/> Set plugins options
   * @param plugins - <zh/>  | <en/> plugin options
   * @remarks
   * <zh/> 
   *
   * <en/> The set plugin will completely replace the original plugin configuration. If you need to add a plugin, you can use the following method:
   * ```ts
   * graph.setPlugins((plugins) => [...plugins, { key: 'grid-line' }])
   * ```
   * @apiCategory plugin
   */
  setPlugins(plugins) {
    var _a;
    this.options.plugins = isFunction(plugins) ? plugins(this.getPlugins()) : plugins;
    (_a = this.context.plugin) === null || _a === void 0 ? void 0 : _a.setPlugins(this.options.plugins);
  }
  /**
   * <zh/> 
   *
   * <en/> Update plugin options
   * @param plugin - <zh/>  | <en/> plugin options
   * @remarks
   * <zh/>  key 
   *
   * <en/> If you want to update a plugin, you must specify the key field in the plugin options, for example:
   * ```ts
   * {
   *   plugins: [{ key: 'grid-line' }]
   * }
   *
   * graph.updatePlugin({ key: 'grid-line', follow: true })
   * ```
   * @apiCategory plugin
   */
  updatePlugin(plugin) {
    this.setPlugins((plugins) => plugins.map((_plugin) => {
      if (typeof _plugin === "object" && _plugin.key === plugin.key) {
        return Object.assign(Object.assign({}, _plugin), plugin);
      }
      return _plugin;
    }));
  }
  /**
   * <zh/> 
   *
   * <en/> Get plugins options
   * @returns <zh/>  | <en/> plugin options
   * @apiCategory plugin
   */
  getPlugins() {
    return this.options.plugins || [];
  }
  /**
   * <zh/> 
   *
   * <en/> Get plugin instance
   * @param key - <zh/>  key plugin  | <en/> plugin key(need to be specified manually when configuring plugin)
   * @returns <zh/>  | <en/> plugin instance
   * @remarks
   * <zh/>  API  `request`  `exit` 
   *
   * <en/> Some plugins provide API methods for calling, such as the full-screen plugin can call the `request` and `exit` methods to request and exit full-screen
   * ```ts
   * const fullscreen = graph.getPluginInstance('fullscreen');
   *
   * fullscreen.request();
   *
   * fullscreen.exit();
   * ```
   * @apiCategory plugin
   */
  getPluginInstance(key) {
    return this.context.plugin.getPluginInstance(key);
  }
  /**
   * <zh/> 
   *
   * <en/> Set data transforms
   * @param transforms - <zh/>  | <en/> data transform options
   * @remarks
   * <zh/> 
   *
   * <en/> Data transforms can perform data transformation during the rendering process of the graph. Currently, it supports transforming the drawing data before rendering.
   * @apiCategory transform
   */
  setTransforms(transforms) {
    var _a;
    this.options.transforms = isFunction(transforms) ? transforms(this.getTransforms()) : transforms;
    (_a = this.context.transform) === null || _a === void 0 ? void 0 : _a.setTransforms(this.options.transforms);
  }
  /**
   * <zh/> 
   *
   * <en/> Update data transform
   * @param transform - <zh/>  | <en/> data transform options
   * @apiCategory transform
   */
  updateTransform(transform) {
    this.setTransforms((transforms) => transforms.map((_transform) => {
      if (typeof _transform === "object" && _transform.key === transform.key) {
        return Object.assign(Object.assign({}, _transform), transform);
      }
      return _transform;
    }));
    this.context.model.refreshData();
  }
  /**
   * <zh/> 
   *
   * <en/> Get data transforms options
   * @returns <zh/>  | <en/> data transform options
   * @apiCategory transform
   */
  getTransforms() {
    return this.options.transforms || [];
  }
  /**
   * <zh/> 
   *
   * <en/> Get graph data
   * @returns <zh/>  | <en/> Graph data
   * <zh/> 
   *
   * <en/> Get the data of the current graph, including node, edge, and combo data
   * @apiCategory data
   */
  getData() {
    return this.context.model.getData();
  }
  /**
   * <zh/> 
   * <en/> Determine whether a specified node exists in the graph
   * @param {ID} id
   * @returns {boolean}
   * @remarks <zh/> ,
   * <en/> Determine whether a specified node exists in the graph and avoid operating on non-existent nodes
   */
  hasNode(id) {
    return this.context.model.hasNode(id);
  }
  /**
   * <zh/> 
   * <en/> Determine whether a specified edge exists in the graph
   * @param {ID} id
   * @returns  {boolean}
   * @remarks <zh/> ,
   * <en/> Determine whether a specified edge exists in the graph and avoid operating on non-existent edges
   */
  hasEdge(id) {
    return this.context.model.hasEdge(id);
  }
  /**
   * <zh/> 
   * <en/> Determine whether a specified combo exists in the graph
   * @param {ID} id
   * @returns  {boolean}
   * @remarks <zh/> ,
   * <en/> Determine whether a specified combo exists in the graph and avoid operating on non-existent combos
   */
  hasCombo(id) {
    return this.context.model.hasCombo(id);
  }
  getElementData(ids) {
    if (Array.isArray(ids))
      return ids.map((id) => this.context.model.getElementDataById(id));
    return this.context.model.getElementDataById(ids);
  }
  getNodeData(id) {
    if (id === void 0)
      return this.context.model.getNodeData();
    if (Array.isArray(id))
      return this.context.model.getNodeData(id);
    return this.context.model.getNodeLikeDatum(id);
  }
  getEdgeData(id) {
    if (id === void 0)
      return this.context.model.getEdgeData();
    if (Array.isArray(id))
      return this.context.model.getEdgeData(id);
    return this.context.model.getEdgeDatum(id);
  }
  getComboData(id) {
    if (id === void 0)
      return this.context.model.getComboData();
    if (Array.isArray(id))
      return this.context.model.getComboData(id);
    return this.context.model.getNodeLikeDatum(id);
  }
  /**
   * <zh/> 
   *
   * <en/> Set full data
   * @param data - <zh/>  | <en/> data
   * @remarks
   * <zh/> G6 
   *
   * <en/> Setting full data will replace all data in the current graph, and G6 will automatically calculate the data difference
   * @apiCategory data
   */
  setData(data) {
    this.context.model.setData(isFunction(data) ? data(this.getData()) : data);
  }
  /**
   * <zh/> 
   *
   * <en/> Add element data
   * @param data - <zh/>  | <en/> element data
   * @example
   * ```ts
   * graph.addData({
   *  nodes: [{ id: 'node-1' }, { id: 'node-2' }],
   *  edges: [{ source: 'node-1', target: 'node-2' }],
   * });
   * ```
   * @apiCategory data
   */
  addData(data) {
    this.context.model.addData(isFunction(data) ? data(this.getData()) : data);
  }
  /**
   * <zh/> 
   *
   * <en/> Add node data
   * @param data - <zh/>  | <en/> node data
   * @example
   * ```ts
   * graph.addNodeData([{ id: 'node-1' }, { id: 'node-2' }]);
   * ```
   * @apiCategory data
   */
  addNodeData(data) {
    this.context.model.addNodeData(isFunction(data) ? data(this.getNodeData()) : data);
  }
  /**
   * <zh/> 
   *
   * <en/> Add edge data
   * @param data - <zh/>  | <en/> edge data
   * @example
   * ```ts
   * graph.addEdgeData([{ source: 'node-1', target: 'node-2' }]);
   * ```
   * @apiCategory data
   */
  addEdgeData(data) {
    this.context.model.addEdgeData(isFunction(data) ? data(this.getEdgeData()) : data);
  }
  /**
   * <zh/> 
   *
   * <en/> Add combo data
   * @param data - <zh/>  | <en/> combo data
   * @example
   * ```ts
   * graph.addComboData([{ id: 'combo-1' }]);
   * ```
   * @apiCategory data
   */
  addComboData(data) {
    this.context.model.addComboData(isFunction(data) ? data(this.getComboData()) : data);
  }
  /**
   * <zh/> 
   *
   * <en/> Add child node data to the tree node
   * @param parentId - <zh/>  ID | <en/> parent node ID
   * @param childrenData - <zh/>  | <en/> child node data
   * @remarks
   * <zh/>  addNodeData / addComboData 
   *
   * <en/> Use addNodeData / addComboData method to add child nodes to the combo
   * @apiCategory data
   */
  addChildrenData(parentId, childrenData) {
    this.context.model.addChildrenData(parentId, childrenData);
  }
  /**
   * <zh/> 
   *
   * <en/> Update element data
   * @param data - <zh/>  | <en/> element data
   * @remarks
   * <zh/> 
   *
   * <en/> Just pass in the data that needs to be updated, no need to pass in the complete data
   * @example
   * ```ts
   * graph.updateData({
   *   nodes: [{ id: 'node-1', style: { x: 100, y: 100 } }],
   *   edges: [{ id: 'edge-1', style: { lineWidth: 2 } }]
   * });
   * ```
   * @apiCategory data
   */
  updateData(data) {
    this.context.model.updateData(isFunction(data) ? data(this.getData()) : data);
  }
  /**
   * <zh/> 
   *
   * <en/> Update node data
   * @param data - <zh/>  | <en/> node data
   * @remarks
   * <zh/> 
   *
   * <en/> Just pass in the data that needs to be updated, no need to pass in the complete data
   * @example
   * ```ts
   * graph.updateNodeData([{ id: 'node-1', style: { x: 100, y: 100 } }]);
   * ```
   * @apiCategory data
   */
  updateNodeData(data) {
    this.context.model.updateNodeData(isFunction(data) ? data(this.getNodeData()) : data);
  }
  /**
   * <zh/> 
   *
   * <en/> Update edge data
   * @param data - <zh/>  | <en/> edge data
   * @remarks
   * <zh/> 
   *
   * <en/> Just pass in the data that needs to be updated, no need to pass in the complete data
   * @example
   * ```ts
   * graph.updateEdgeData([{ id: 'edge-1', style: { lineWidth: 2 } }]);
   * ```
   * @apiCategory data
   */
  updateEdgeData(data) {
    this.context.model.updateEdgeData(isFunction(data) ? data(this.getEdgeData()) : data);
  }
  /**
   * <zh/> 
   *
   * <en/> Update combo data
   * @param data - <zh/>  | <en/> combo data
   * @remarks
   * <zh/> 
   *
   * <en/> Just pass in the data that needs to be updated, no need to pass in the complete data
   * @example
   * ```ts
   * graph.updateComboData([{ id: 'combo-1', style: { x: 100, y: 100 } }]);
   * ```
   * @apiCategory data
   */
  updateComboData(data) {
    this.context.model.updateComboData(isFunction(data) ? data(this.getComboData()) : data);
  }
  /**
   * <zh/> 
   *
   * <en/> Remove element data
   * @param ids - <zh/>  ID  | <en/> element ID array
   * @example
   * ```ts
   * graph.removeData({
   *   nodes: ['node-1', 'node-2'],
   *   edges: ['edge-1'],
   * });
   * ```
   * @apiCategory data
   */
  removeData(ids) {
    this.context.model.removeData(isFunction(ids) ? ids(this.getData()) : ids);
  }
  /**
   * <zh/> 
   *
   * <en/> Remove node data
   * @param ids - <zh/>  ID  | <en/> node ID array
   * @example
   * ```ts
   * graph.removeNodeData(['node-1', 'node-2']);
   * ```
   * @apiCategory data
   */
  removeNodeData(ids) {
    this.context.model.removeNodeData(isFunction(ids) ? ids(this.getNodeData()) : ids);
  }
  /**
   * <zh/> 
   *
   * <en/> Remove edge data
   * @param ids - <zh/>  ID  | <en/> edge ID array
   * @remarks
   * <zh/>  source  target `idOf`  ID
   *
   * <en/> If only the source and target are provided when passing in the edge data, you need to get the actual ID of the edge through the `idOf` method
   * @example
   * ```ts
   * graph.removeEdgeData(['edge-1']);
   * ```
   * @apiCategory data
   */
  removeEdgeData(ids) {
    this.context.model.removeEdgeData(isFunction(ids) ? ids(this.getEdgeData()) : ids);
  }
  /**
   * <zh/> 
   *
   * <en/> Remove combo data
   * @param ids - <zh/>  ID  | <en/>  ID array
   * @example
   * ```ts
   * graph.removeComboData(['combo-1']);
   * ```
   * @apiCategory data
   */
  removeComboData(ids) {
    this.context.model.removeComboData(isFunction(ids) ? ids(this.getComboData()) : ids);
  }
  /**
   * <zh/> 
   *
   * <en/> Get element type
   * @param id - <zh/>  ID | <en/> element ID
   * @returns <zh/>  | <en/> element type
   * @apiCategory element
   */
  getElementType(id) {
    return this.context.model.getElementType(id);
  }
  /**
   * <zh/> 
   *
   * <en/> Get edge data related to the node or combo
   * @param id - <zh/> ID | <en/> node or combo ID
   * @param direction - <zh/>  | <en/> edge direction
   * @returns <zh/>  | <en/> edge data
   * @apiCategory data
   */
  getRelatedEdgesData(id, direction = "both") {
    return this.context.model.getRelatedEdgesData(id, direction);
  }
  /**
   * <zh/> 
   *
   * <en/> Get the one-hop neighbor node data of the node or combo
   * @param id - <zh/> ID | <en/> node or combo ID
   * @returns <zh/>  | <en/> neighbor node data
   * @apiCategory data
   */
  getNeighborNodesData(id) {
    return this.context.model.getNeighborNodesData(id);
  }
  /**
   * <zh/> 
   *
   * <en/> Get the ancestor element data of the node or combo
   * @param id - <zh/> ID | <en/> node or combo ID
   * @param hierarchy - <zh/>  | <en/> specify tree or combo hierarchy relationship
   * @returns <zh/>  | <en/> ancestor element data
   * @remarks
   * <zh/> 
   *
   * <en/> The order in the array is from the parent node to the ancestor node
   * @apiCategory data
   */
  getAncestorsData(id, hierarchy) {
    return this.context.model.getAncestorsData(id, hierarchy);
  }
  /**
   * <zh/> 
   *
   * <en/> Get the parent element data of the node or combo
   * @param id - <zh/> ID | <en/> node or combo ID
   * @param hierarchy - <zh/>  | <en/> specify tree or combo hierarchy relationship
   * @returns <zh/>  | <en/> parent element data
   * @apiCategory data
   */
  getParentData(id, hierarchy) {
    return this.context.model.getParentData(id, hierarchy);
  }
  /**
   * <zh/> 
   *
   * <en/> Get the child element data of the node or combo
   * @param id - <zh/> ID | <en/> node or combo ID
   * @returns <zh/>  | <en/> child element data
   * @apiCategory data
   */
  getChildrenData(id) {
    return this.context.model.getChildrenData(id);
  }
  /**
   * <zh/> 
   *
   * <en/> Get the descendant element data of the node or combo
   * @param id - <zh/> ID | <en/> node or combo ID
   * @returns <zh/>  | <en/> descendant element data
   * @apiCategory data
   */
  getDescendantsData(id) {
    return this.context.model.getDescendantsData(id);
  }
  getElementDataByState(elementType, state) {
    return this.context.model.getElementDataByState(elementType, state);
  }
  initCanvas() {
    return __awaiter27(this, void 0, void 0, function* () {
      var _a;
      if (this.context.canvas)
        return yield this.context.canvas.ready;
      const { container = "container", width: width2, height, renderer, cursor, background, canvas: canvasOptions, devicePixelRatio = (_a = globalThis.devicePixelRatio) !== null && _a !== void 0 ? _a : 1 } = this.options;
      if (container instanceof Canvas2) {
        this.context.canvas = container;
        if (cursor)
          container.setCursor(cursor);
        if (renderer)
          container.setRenderer(renderer);
        yield container.ready;
      } else {
        const $container = isString(container) ? document.getElementById(container) : container;
        const containerSize = sizeOf($container);
        this.emit(GraphEvent.BEFORE_CANVAS_INIT, { container: $container, width: width2, height });
        const options = Object.assign(Object.assign({}, canvasOptions), {
          container: $container,
          width: width2 || containerSize[0],
          height: height || containerSize[1],
          background,
          renderer,
          cursor,
          devicePixelRatio
        });
        const canvas2 = new Canvas2(options);
        this.context.canvas = canvas2;
        yield canvas2.ready;
        this.emit(GraphEvent.AFTER_CANVAS_INIT, { canvas: canvas2 });
      }
    });
  }
  updateCanvas(options) {
    var _a, _b;
    const { renderer, cursor, height, width: width2 } = options;
    const canvas2 = this.context.canvas;
    if (!canvas2)
      return;
    if (renderer) {
      this.emit(GraphEvent.BEFORE_RENDERER_CHANGE, { renderer: this.options.renderer });
      canvas2.setRenderer(renderer);
      this.emit(GraphEvent.AFTER_RENDERER_CHANGE, { renderer });
    }
    if (cursor)
      canvas2.setCursor(cursor);
    if (isNumber(width2) || isNumber(height))
      this.setSize((_a = width2 !== null && width2 !== void 0 ? width2 : this.options.width) !== null && _a !== void 0 ? _a : 0, (_b = height !== null && height !== void 0 ? height : this.options.height) !== null && _b !== void 0 ? _b : 0);
  }
  initRuntime() {
    this.context.options = this.options;
    if (!this.context.batch)
      this.context.batch = new BatchController(this.context);
    if (!this.context.plugin)
      this.context.plugin = new PluginController(this.context);
    if (!this.context.viewport)
      this.context.viewport = new ViewportController(this.context);
    if (!this.context.transform)
      this.context.transform = new TransformController(this.context);
    if (!this.context.element)
      this.context.element = new ElementController(this.context);
    if (!this.context.animation)
      this.context.animation = new Animation(this.context);
    if (!this.context.layout)
      this.context.layout = new LayoutController(this.context);
    if (!this.context.behavior)
      this.context.behavior = new BehaviorController(this.context);
  }
  prepare() {
    return __awaiter27(this, void 0, void 0, function* () {
      yield Promise.resolve();
      if (this.destroyed) {
        console.error(format("The graph instance has been destroyed"));
        return;
      }
      yield this.initCanvas();
      this.initRuntime();
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Render
   * @remarks
   * <zh/> 
   *
   * >  render  render  `await graph.render()`  GraphEvent.AFTER_RENDER 
   *
   * <en/> This process will execute data update, element rendering, and layout execution
   *
   * >  render is an asynchronous method. If you need to perform some operations after render, you can use `await graph.render()` or listen to the GraphEvent.AFTER_RENDER event
   * @apiCategory render
   */
  render() {
    return __awaiter27(this, void 0, void 0, function* () {
      yield this.prepare();
      emit(this, new GraphLifeCycleEvent(GraphEvent.BEFORE_RENDER));
      if (!this.options.layout) {
        const animation = this.context.element.draw({ type: "render" });
        yield Promise.all([animation === null || animation === void 0 ? void 0 : animation.finished, this.autoFit()]);
      } else if (!this.rendered && isPreLayout(this.options.layout)) {
        const animation = yield this.context.element.preLayoutDraw({ type: "render" });
        yield Promise.all([animation === null || animation === void 0 ? void 0 : animation.finished, this.autoFit()]);
      } else {
        const animation = this.context.element.draw({ type: "render" });
        yield Promise.all([animation === null || animation === void 0 ? void 0 : animation.finished, this.context.layout.postLayout()]);
        yield this.autoFit();
      }
      this.rendered = true;
      emit(this, new GraphLifeCycleEvent(GraphEvent.AFTER_RENDER));
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Draw elements
   * @returns <zh/>  | <en/> draw result
   * @remarks
   * <zh/> 
   *
   * <zh/>  draw  draw  `await graph.draw()`  GraphEvent.AFTER_DRAW 
   *
   * <en/> Only execute element drawing, no re-layout
   *
   * <en/>  draw is an asynchronous method. If you need to perform some operations after draw, you can use `await graph.draw()` or listen to the GraphEvent.AFTER_DRAW event
   * @apiCategory render
   */
  draw() {
    return __awaiter27(this, void 0, void 0, function* () {
      var _a;
      yield this.prepare();
      yield (_a = this.context.element.draw()) === null || _a === void 0 ? void 0 : _a.finished;
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Execute layout
   * @param layoutOptions - <zh/>  | <en/> Layout options
   * @apiCategory layout
   */
  layout(layoutOptions) {
    return __awaiter27(this, void 0, void 0, function* () {
      yield this.context.layout.postLayout(layoutOptions);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Stop layout
   * @remarks
   * <zh/>  `force` /
   *
   * <en/> Suitable for layouts with iterative animations. Currently, `force` belongs to this type of layout, that is, stop the iteration of the force-directed layout. It is generally used to manually stop the iteration animation when the layout iteration time is too long, such as calling in the click canvas/node listener
   * @apiCategory layout
   */
  stopLayout() {
    this.context.layout.stopLayout();
  }
  /**
   * <zh/> 
   *
   * <en/> Clear canvas elements
   * @apiCategory canvas
   */
  clear() {
    return __awaiter27(this, void 0, void 0, function* () {
      const { model, element } = this.context;
      model.setData({});
      model.clearChanges();
      element === null || element === void 0 ? void 0 : element.clear();
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Destroy the current graph instance
   * @remarks
   * <zh/> 
   *
   * <en/> After destruction, no operations can be performed. If you need to reuse it, you need to create a new graph instance
   * @apiCategory instance
   */
  destroy() {
    var _a;
    emit(this, new GraphLifeCycleEvent(GraphEvent.BEFORE_DESTROY));
    const { layout: layout2, animation, element, model, canvas: canvas2, behavior, plugin } = this.context;
    plugin === null || plugin === void 0 ? void 0 : plugin.destroy();
    behavior === null || behavior === void 0 ? void 0 : behavior.destroy();
    layout2 === null || layout2 === void 0 ? void 0 : layout2.destroy();
    animation === null || animation === void 0 ? void 0 : animation.destroy();
    element === null || element === void 0 ? void 0 : element.destroy();
    model.destroy();
    canvas2 === null || canvas2 === void 0 ? void 0 : canvas2.destroy();
    this.options = {};
    this.context = {};
    this.off();
    (_a = globalThis.removeEventListener) === null || _a === void 0 ? void 0 : _a.call(globalThis, "resize", this.onResize);
    this.destroyed = true;
    emit(this, new GraphLifeCycleEvent(GraphEvent.AFTER_DESTROY));
  }
  /**
   * <zh/> 
   *
   * <en/> Get canvas instance
   * @returns - <zh/>  | <en/> canvas instance
   * @apiCategory canvas
   */
  getCanvas() {
    return this.context.canvas;
  }
  resize(width2, height) {
    var _a;
    const containerSize = sizeOf((_a = this.context.canvas) === null || _a === void 0 ? void 0 : _a.getContainer());
    const specificSize = [width2 || containerSize[0], height || containerSize[1]];
    if (!this.context.canvas)
      return;
    const canvasSize = this.context.canvas.getSize();
    if (is_equal_default(specificSize, canvasSize))
      return;
    emit(this, new GraphLifeCycleEvent(GraphEvent.BEFORE_SIZE_CHANGE, { size: specificSize }));
    this.context.canvas.resize(...specificSize);
    emit(this, new GraphLifeCycleEvent(GraphEvent.AFTER_SIZE_CHANGE, { size: specificSize }));
  }
  /**
   * <zh/> 
   *
   * <en/> Zoom the graph to fit the viewport and move it to the center of the viewport
   * @param options - <zh/>  | <en/> fit options
   * @param animation - <zh/>  | <en/> animation options
   * @apiCategory viewport
   */
  fitView(options, animation) {
    return __awaiter27(this, void 0, void 0, function* () {
      var _a;
      yield (_a = this.context.viewport) === null || _a === void 0 ? void 0 : _a.fitView(options, animation);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Move the graph to the center of the viewport
   * @param animation - <zh/>  | <en/> animation options
   * @apiCategory viewport
   */
  fitCenter(animation) {
    return __awaiter27(this, void 0, void 0, function* () {
      var _a;
      yield (_a = this.context.viewport) === null || _a === void 0 ? void 0 : _a.fitCenter({ animation });
    });
  }
  autoFit() {
    return __awaiter27(this, void 0, void 0, function* () {
      const { autoFit } = this.context.options;
      if (!autoFit)
        return;
      if (isString(autoFit)) {
        if (autoFit === "view")
          yield this.fitView();
        else if (autoFit === "center")
          yield this.fitCenter();
      } else {
        const { type, animation } = autoFit;
        if (type === "view")
          yield this.fitView(autoFit.options, animation);
        else if (type === "center")
          yield this.fitCenter(animation);
      }
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Focus on element
   * @param id - <zh/>  ID | <en/> element ID
   * @param animation - <zh/>  | <en/> animation options
   * @remarks
   * <zh/> 
   *
   * <en/> Move the graph so that the element is aligned to the center of the viewport
   * @apiCategory viewport
   */
  focusElement(id, animation) {
    return __awaiter27(this, void 0, void 0, function* () {
      var _a;
      yield (_a = this.context.viewport) === null || _a === void 0 ? void 0 : _a.focusElements(Array.isArray(id) ? id : [id], { animation });
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Zoom based on the current zoom ratio (relative zoom)
   * @param ratio - <zh/>  | <en/> zoom ratio
   * @param animation - <zh/>  | <en/> animation options
   * @param origin - <zh/> () | <en/> zoom center(viewport coordinates)
   * @remarks
   * <zh/>
   * - ratio > 1 
   * - ratio < 1 
   *
   * <en/>
   * - ratio > 1 zoom in
   * - ratio < 1 zoom out
   * @apiCategory viewport
   */
  zoomBy(ratio, animation, origin) {
    return __awaiter27(this, void 0, void 0, function* () {
      yield this.context.viewport.transform({ mode: "relative", scale: ratio, origin }, animation);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Zoom the canvas to the specified ratio (absolute zoom)
   * @param zoom - <zh/>  | <en/> specified zoom ratio
   * @param animation - <zh/>  | <en/> animation options
   * @param origin - <zh/> () | <en/> zoom center(viewport coordinates)
   * @remarks
   * <zh/>
   * - zoom = 1 
   * - zoom > 1 
   * - zoom < 1 
   *
   * <en/>
   * - zoom = 1 default size
   * - zoom > 1 zoom in
   * - zoom < 1 zoom out
   * @apiCategory viewport
   */
  zoomTo(zoom, animation, origin) {
    return __awaiter27(this, void 0, void 0, function* () {
      yield this.context.viewport.transform({ mode: "absolute", scale: zoom, origin }, animation);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Get the current zoom ratio
   * @returns <zh/>  | <en/> zoom ratio
   * @apiCategory viewport
   */
  getZoom() {
    return this.context.viewport.getZoom();
  }
  /**
   * <zh/> 
   *
   * <en/> Rotate based on the current rotation angle (relative rotation)
   * @param angle - <zh/>  | <en/> rotation angle
   * @param animation - <zh/>  | <en/> animation options
   * @param origin - <zh/> () | <en/> rotation center(viewport coordinates)
   * @apiCategory viewport
   */
  rotateBy(angle2, animation, origin) {
    return __awaiter27(this, void 0, void 0, function* () {
      yield this.context.viewport.transform({ mode: "relative", rotate: angle2, origin }, animation);
    });
  }
  /**
   * <zh/>  ()
   *
   * <en/> Rotate the canvas to the specified angle (absolute rotation)
   * @param angle - <zh/>  | <en/> target angle
   * @param animation - <zh/>  | <en/> animation options
   * @param origin - <zh/> () | <en/> rotation center(viewport coordinates)
   * @apiCategory viewport
   */
  rotateTo(angle2, animation, origin) {
    return __awaiter27(this, void 0, void 0, function* () {
      yield this.context.viewport.transform({ mode: "absolute", rotate: angle2, origin }, animation);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Get the current rotation angle
   * @returns <zh/>  | <en/> rotation angle
   * @apiCategory viewport
   */
  getRotation() {
    return this.context.viewport.getRotation();
  }
  /**
   * <zh/>  ()
   *
   * <en/> Translate the graph by the specified distance (relative translation)
   * @param offset - <zh/>  | <en/> offset
   * @param animation - <zh/>  | <en/> animation options
   * @apiCategory viewport
   */
  translateBy(offset, animation) {
    return __awaiter27(this, void 0, void 0, function* () {
      yield this.context.viewport.transform({ mode: "relative", translate: offset }, animation);
    });
  }
  /**
   * <zh/>  ()
   *
   * <en/> Translate the graph to the specified position (absolute translation)
   * @param position - <zh/>  | <en/> specified position
   * @param animation - <zh/>  | <en/> animation options
   * @apiCategory viewport
   */
  translateTo(position2, animation) {
    return __awaiter27(this, void 0, void 0, function* () {
      yield this.context.viewport.transform({ mode: "absolute", translate: position2 }, animation);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Get the position of the graph
   * @returns <zh/>  | <en/> position of the graph
   * @remarks
   * <zh/>  [0, 0]
   *
   * <en/> That is, the position of the canvas origin in the viewport coordinate system. By default, the position of the graph is [0, 0]
   * @apiCategory viewport
   */
  getPosition() {
    return subtract([0, 0], this.getCanvasByViewport([0, 0]));
  }
  translateElementBy(args1_1, args2_1) {
    return __awaiter27(this, arguments, void 0, function* (args1, args2, args3 = true) {
      var _a, _b;
      const [config, animation] = is_object_default(args1) ? [args1, (_a = args2) !== null && _a !== void 0 ? _a : true] : [{ [args1]: args2 }, args3];
      Object.entries(config).forEach(([id, offset]) => this.context.model.translateNodeLikeBy(id, offset));
      yield (_b = this.context.element.draw({ animation, stage: "translate" })) === null || _b === void 0 ? void 0 : _b.finished;
    });
  }
  translateElementTo(args1_1, args2_1) {
    return __awaiter27(this, arguments, void 0, function* (args1, args2, args3 = true) {
      var _a, _b;
      const [config, animation] = is_object_default(args1) ? [args1, (_a = args2) !== null && _a !== void 0 ? _a : true] : [{ [args1]: args2 }, args3];
      Object.entries(config).forEach(([id, position2]) => this.context.model.translateNodeLikeTo(id, position2));
      yield (_b = this.context.element.draw({ animation, stage: "translate" })) === null || _b === void 0 ? void 0 : _b.finished;
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Get element position
   * @param id - <zh/>  ID | <en/> element ID
   * @returns <zh/>  | <en/> element position
   * @apiCategory element
   */
  getElementPosition(id) {
    return this.context.model.getElementPosition(id);
  }
  /**
   * <zh/> 
   *
   * <en/> Get element rendering style
   * @param id - <zh/>  ID | <en/> element ID
   * @returns <zh/>  | <en/> element rendering style
   * @apiCategory element
   */
  getElementRenderStyle(id) {
    return omit_default(this.context.element.getElement(id).attributes, ["context"]);
  }
  setElementVisibility(args1_1, args2_1) {
    return __awaiter27(this, arguments, void 0, function* (args1, args2, args3 = true) {
      var _a, _b;
      const [config, animation] = is_object_default(args1) ? [args1, (_a = args2) !== null && _a !== void 0 ? _a : true] : [{ [args1]: args2 }, args3];
      const dataToUpdate = { nodes: [], edges: [], combos: [] };
      Object.entries(config).forEach(([id, value]) => {
        const elementType = this.getElementType(id);
        dataToUpdate[`${elementType}s`].push({ id, style: { visibility: value } });
      });
      const { model, element } = this.context;
      model.preventUpdateNodeLikeHierarchy(() => {
        model.updateData(dataToUpdate);
      });
      yield (_b = element.draw({ animation, stage: "visibility" })) === null || _b === void 0 ? void 0 : _b.finished;
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Show element
   * @param id - <zh/>  ID | <en/> element ID
   * @param animation - <zh/>  | <en/> whether to enable animation
   * @apiCategory element
   */
  showElement(id, animation) {
    return __awaiter27(this, void 0, void 0, function* () {
      const ids = Array.isArray(id) ? id : [id];
      yield this.setElementVisibility(Object.fromEntries(ids.map((_id) => [_id, "visible"])), animation);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Hide element
   * @param id - <zh/>  ID | <en/> element ID
   * @param animation - <zh/>  | <en/> whether to enable animation
   * @apiCategory element
   */
  hideElement(id, animation) {
    return __awaiter27(this, void 0, void 0, function* () {
      const ids = Array.isArray(id) ? id : [id];
      yield this.setElementVisibility(Object.fromEntries(ids.map((_id) => [_id, "hidden"])), animation);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Get element visibility
   * @param id - <zh/>  ID | <en/> element ID
   * @returns <zh/>  | <en/> element visibility
   * @apiCategory element
   */
  getElementVisibility(id) {
    var _a, _b;
    const element = this.context.element.getElement(id);
    return (_b = (_a = element === null || element === void 0 ? void 0 : element.style) === null || _a === void 0 ? void 0 : _a.visibility) !== null && _b !== void 0 ? _b : "visible";
  }
  setElementZIndex(args1, args2) {
    return __awaiter27(this, void 0, void 0, function* () {
      var _a;
      const dataToUpdate = { nodes: [], edges: [], combos: [] };
      const config = is_object_default(args1) ? args1 : { [args1]: args2 };
      Object.entries(config).forEach(([id, value]) => {
        const elementType = this.getElementType(id);
        dataToUpdate[`${elementType}s`].push({ id, style: { zIndex: value } });
      });
      const { model, element } = this.context;
      model.preventUpdateNodeLikeHierarchy(() => model.updateData(dataToUpdate));
      yield (_a = element.draw({ animation: false, stage: "zIndex" })) === null || _a === void 0 ? void 0 : _a.finished;
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Bring the element to the front
   * @param id - <zh/>  ID | <en/> element ID
   * @apiCategory element
   */
  frontElement(id) {
    return __awaiter27(this, void 0, void 0, function* () {
      const ids = Array.isArray(id) ? id : [id];
      const { model } = this.context;
      const zIndexes = {};
      ids.map((_id) => {
        const zIndex = model.getFrontZIndex(_id);
        const elementType = model.getElementType(_id);
        if (elementType === "combo") {
          const ancestor = model.getAncestorsData(_id, COMBO_KEY).at(-1) || this.getComboData(_id);
          const descendants = [ancestor, ...model.getDescendantsData(idOf(ancestor))];
          const delta = zIndex - getZIndexOf(ancestor);
          descendants.forEach((combo) => {
            zIndexes[idOf(combo)] = this.getElementZIndex(idOf(combo)) + delta;
          });
          const { internal } = getSubgraphRelatedEdges(descendants.map(idOf), (id2) => model.getRelatedEdgesData(id2));
          internal.forEach((edge) => {
            const edgeId = idOf(edge);
            zIndexes[edgeId] = this.getElementZIndex(edgeId) + delta;
          });
        } else
          zIndexes[_id] = zIndex;
      });
      yield this.setElementZIndex(zIndexes);
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Get element z-index
   * @param id - <zh/>  ID | <en/> element ID
   * @returns <zh/>  | <en/> element z-index
   * @apiCategory element
   */
  getElementZIndex(id) {
    return getZIndexOf(this.context.model.getElementDataById(id));
  }
  setElementState(args1_1, args2_1) {
    return __awaiter27(this, arguments, void 0, function* (args1, args2, args3 = true) {
      var _a, _b;
      const [config, animation] = is_object_default(args1) ? [args1, (_a = args2) !== null && _a !== void 0 ? _a : true] : [{ [args1]: args2 }, args3];
      const parseState = (state) => {
        if (!state)
          return [];
        return Array.isArray(state) ? state : [state];
      };
      const dataToUpdate = { nodes: [], edges: [], combos: [] };
      Object.entries(config).forEach(([id, value]) => {
        const elementType = this.getElementType(id);
        dataToUpdate[`${elementType}s`].push({ id, states: parseState(value) });
      });
      this.updateData(dataToUpdate);
      yield (_b = this.context.element.draw({ animation, stage: "state" })) === null || _b === void 0 ? void 0 : _b.finished;
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Get element state
   * @param id - <zh/>  ID | <en/> element ID
   * @returns <zh/>  | <en/> element state
   * @apiCategory element
   */
  getElementState(id) {
    return this.context.model.getElementState(id);
  }
  /**
   * <zh/> 
   *
   * <en/> Get the rendering bounding box of the element itself and its child nodes in the world coordinate system
   * @param id - <zh/>  ID | <en/> element ID
   * @returns <zh/>  | <en/> render bounding box
   * @apiCategory element
   */
  getElementRenderBounds(id) {
    return this.context.element.getElement(id).getRenderBounds();
  }
  /**
   * <zh/> 
   *
   * <en/> Collapse element
   * @param id - <zh/>  ID | <en/> element ID
   * @param options - <zh/>  | <en/> whether to enable animation or the options of collapsing node
   * @apiCategory element
   */
  collapseElement(id_1) {
    return __awaiter27(this, arguments, void 0, function* (id, options = true) {
      const { model, element } = this.context;
      if (isCollapsed(model.getNodeLikeData([id])[0]))
        return;
      if (this.isCollapsingExpanding)
        return;
      if (typeof options === "boolean")
        options = { animation: options, align: false };
      const elementType = model.getElementType(id);
      yield this.frontElement(id);
      this.isCollapsingExpanding = true;
      model.updateData(elementType === "node" ? {
        nodes: [{ id, style: { collapsed: true } }]
      } : {
        combos: [{ id, style: { collapsed: true } }]
      });
      if (elementType === "node")
        yield element.collapseNode(id, options);
      else if (elementType === "combo")
        yield element.collapseCombo(id, !!options.animation);
      this.isCollapsingExpanding = false;
    });
  }
  /**
   * <zh/> 
   *
   * <en/> Expand Element
   * @param id - <zh/>  ID | <en/> element ID
   * @param animation - <zh/>  | <en/> whether to enable animation or the options of collapsing node
   * @param options
   * @apiCategory element
   */
  expandElement(id_1) {
    return __awaiter27(this, arguments, void 0, function* (id, options = true) {
      const { model, element } = this.context;
      if (!isCollapsed(model.getNodeLikeData([id])[0]))
        return;
      if (this.isCollapsingExpanding)
        return;
      if (typeof options === "boolean")
        options = { animation: options, align: false };
      const elementType = model.getElementType(id);
      this.isCollapsingExpanding = true;
      model.updateData(elementType === "node" ? {
        nodes: [{ id, style: { collapsed: false } }]
      } : {
        combos: [{ id, style: { collapsed: false } }]
      });
      if (elementType === "node")
        yield element.expandNode(id, options);
      else if (elementType === "combo")
        yield element.expandCombo(id, !!options.animation);
      this.isCollapsingExpanding = false;
    });
  }
  setElementCollapsibility(id, collapsed) {
    const elementType = this.getElementType(id);
    if (elementType === "node")
      this.updateNodeData([{ id, style: { collapsed } }]);
    else if (elementType === "combo")
      this.updateComboData([{ id, style: { collapsed } }]);
  }
  /**
   * <zh/>  DataURL
   *
   * <en/> Export canvas content as DataURL
   * @param options - <zh/>  | <en/> export options
   * @returns <zh/> DataURL | <en/> DataURL
   * @apiCategory exportImage
   */
  toDataURL() {
    return __awaiter27(this, arguments, void 0, function* (options = {}) {
      return this.context.canvas.toDataURL(options);
    });
  }
  /**
   * <zh/>  DOM 
   *
   * <en/> Convert the given viewport DOM coordinates to the drawing coordinates on the canvas
   * @param point - <zh/>  | <en/> viewport coordinates
   * @returns <zh/>  | <en/> drawing coordinates on the canvas
   * @apiCategory viewport
   */
  getCanvasByViewport(point3) {
    return this.context.canvas.getCanvasByViewport(point3);
  }
  /**
   * <zh/>  DOM 
   *
   * <en/> Convert the given drawing coordinates on the canvas to the coordinates of the viewport DOM
   * @param point - <zh/>  | <en/> canvas coordinates
   * @returns <zh/>  DOM  | <en/> coordinates of the viewport DOM
   * @apiCategory viewport
   */
  getViewportByCanvas(point3) {
    return this.context.canvas.getViewportByCanvas(point3);
  }
  /**
   * <zh/> 
   *
   * <en/> Convert the given drawing coordinates on the canvas to browser coordinates
   * @param point - <zh/>  | <en/> canvas coordinates
   * @returns <zh/>  | <en/> browser coordinates
   * @apiCategory viewport
   */
  getClientByCanvas(point3) {
    return this.context.canvas.getClientByCanvas(point3);
  }
  /**
   * <zh/> 
   *
   * <en/> Convert the given browser coordinates to drawing coordinates on the canvas
   * @param point - <zh/>  | <en/> browser coordinates
   * @returns <zh/>  | <en/> drawing coordinates on the canvas
   * @apiCategory viewport
   */
  getCanvasByClient(point3) {
    return this.context.canvas.getCanvasByClient(point3);
  }
  /**
   * <zh/> 
   *
   * <en/> Get the canvas coordinates of the viewport center
   * @returns <zh/>  | <en/> Canvas coordinates of the viewport center
   * @apiCategory viewport
   */
  getViewportCenter() {
    return this.context.viewport.getViewportCenter();
  }
  /**
   * <zh/> 
   *
   * <en/> Get the viewport coordinates of the viewport center
   * @returns <zh/>  | <en/> Viewport coordinates of the viewport center
   * @apiCategory viewport
   */
  getCanvasCenter() {
    return this.context.viewport.getCanvasCenter();
  }
  /**
   * <zh/> 
   *
   * <en/> Listen to events
   * @param eventName - <zh/>  | <en/> event name
   * @param callback - <zh/>  | <en/> callback function
   * @param once - <zh/>  | <en/> whether to listen only once
   * @returns <zh/> Graph  | <en/> Graph instance
   * @apiCategory event
   */
  on(eventName, callback, once) {
    return super.on(eventName, callback, once);
  }
  /**
   * <zh/> 
   *
   * <en/> Listen to events once
   * @param eventName - <zh/>  | <en/> event name
   * @param callback - <zh/>  | <en/> callback function
   * @returns <zh/> Graph  | <en/> Graph instance
   * @apiCategory event
   */
  once(eventName, callback) {
    return super.once(eventName, callback);
  }
  off(eventName, callback) {
    return super.off(eventName, callback);
  }
};
Graph3.defaultOptions = {
  autoResize: false,
  theme: "light",
  rotation: 0,
  zoom: 1,
  zoomRange: [0.01, 10]
};

// node_modules/@antv/g6/esm/utils/tree.js
var __rest24 = function(s2, e2) {
  var t3 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t3[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t3[p3[i2]] = s2[p3[i2]];
    }
  return t3;
};
function treeToGraphData(treeData, getter) {
  const { getNodeData = (datum, depth) => {
    datum.depth = depth;
    if (!datum.children)
      return datum;
    const { children } = datum, restDatum = __rest24(datum, ["children"]);
    return Object.assign(Object.assign({}, restDatum), { children: children.map((child) => child.id) });
  }, getEdgeData = (source, target) => ({ source: source.id, target: target.id }), getChildren = (datum) => datum.children || [] } = getter || {};
  const nodes = [];
  const edges = [];
  dfs(treeData, (node, depth) => {
    nodes.push(getNodeData(node, depth));
    const children = getChildren(node);
    for (const child of children) {
      edges.push(getEdgeData(node, child));
    }
  }, (node) => getChildren(node), "TB");
  return { nodes, edges };
}

// node_modules/@antv/g6/esm/transforms/get-edge-actual-ends.js
var GetEdgeActualEnds = class extends BaseTransform {
  beforeDraw(input) {
    const { add: add4, update } = input;
    const { model } = this.context;
    [...add4.edges.entries(), ...update.edges.entries()].forEach(([, edge]) => {
      getEdgeEndsContext(model, edge);
    });
    return input;
  }
};
var getEdgeEndsContext = (model, edge) => {
  const { source, target } = edge;
  const sourceNodeData = model.getElementDataById(source);
  const targetNodeData = model.getElementDataById(target);
  const actualSourceNode = findActualConnectNodeData(sourceNodeData, (id) => model.getParentData(id, COMBO_KEY));
  const actualTargetNode = findActualConnectNodeData(targetNodeData, (id) => model.getParentData(id, COMBO_KEY));
  const sourceNode = idOf(actualSourceNode);
  const targetNode = idOf(actualTargetNode);
  const ends = { sourceNode, targetNode };
  if (edge.style) {
    Object.assign(edge.style, ends);
  } else
    edge.style = ends;
  return edge;
};

// node_modules/@antv/g6/esm/utils/scale.js
var linear = (value, domain, range) => {
  const [d0, d1] = domain;
  const [r0, r1] = range;
  if (d1 === d0)
    return r0;
  const ratio = (value - d0) / (d1 - d0);
  return r0 + ratio * (r1 - r0);
};
var log = (value, domain, range) => {
  const [d0, d1] = domain;
  const [r0, r1] = range;
  const ratio = Math.log(value - d0 + 1) / Math.log(d1 - d0 + 1);
  return r0 + ratio * (r1 - r0);
};
var pow = (value, domain, range, exponent = 2) => {
  const [d0, d1] = domain;
  const [r0, r1] = range;
  const ratio = Math.pow((value - d0) / (d1 - d0), exponent);
  return r0 + ratio * (r1 - r0);
};
var sqrt = (value, domain, range) => {
  const [d0, d1] = domain;
  const [r0, r1] = range;
  const ratio = Math.sqrt((value - d0) / (d1 - d0));
  return r0 + ratio * (r1 - r0);
};

// node_modules/@antv/g6/esm/transforms/map-node-size.js
var MapNodeSize = class _MapNodeSize extends BaseTransform {
  constructor(context, options) {
    super(context, deep_mix_default({}, _MapNodeSize.defaultOptions, options));
    this.assignSizeByCentrality = (centrality, minCentrality, maxCentrality, minSize, maxSize, scale2) => {
      const domain = [minCentrality, maxCentrality];
      const rangeX = [minSize[0], maxSize[0]];
      const rangeY = [minSize[1], maxSize[1]];
      const rangeZ = [minSize[2], maxSize[2]];
      const interpolate = (centrality2, range) => {
        if (typeof scale2 === "function") {
          return scale2(centrality2, domain, range);
        }
        switch (scale2) {
          case "linear":
            return linear(centrality2, domain, range);
          case "log":
            return log(centrality2, domain, range);
          case "pow":
            return pow(centrality2, domain, range, 2);
          case "sqrt":
            return sqrt(centrality2, domain, range);
          default:
            return range[0];
        }
      };
      return [interpolate(centrality, rangeX), interpolate(centrality, rangeY), interpolate(centrality, rangeZ)];
    };
  }
  beforeDraw(input) {
    const { model } = this.context;
    const nodes = model.getNodeData();
    const maxSize = parseSize(this.options.maxSize);
    const minSize = parseSize(this.options.minSize);
    const centralities = this.getCentralities(this.options.centrality);
    const maxCentrality = centralities.size > 0 ? Math.max(...centralities.values()) : 0;
    const minCentrality = centralities.size > 0 ? Math.min(...centralities.values()) : 0;
    nodes.forEach((datum) => {
      var _a;
      const size2 = this.assignSizeByCentrality(centralities.get(idOf(datum)) || 0, minCentrality, maxCentrality, minSize, maxSize, this.options.scale);
      const element = (_a = this.context.element) === null || _a === void 0 ? void 0 : _a.getElement(idOf(datum));
      const style = { size: size2 };
      this.assignLabelStyle(style, size2, datum, element);
      if (!element || !isStyleEqual(style, element.attributes)) {
        reassignTo(input, element ? "update" : "add", "node", deep_mix_default(datum, { style }), true);
      }
    });
    return input;
  }
  assignLabelStyle(style, size2, datum, element) {
    var _a;
    const configStyle = element ? element.config.style : (_a = this.context.element) === null || _a === void 0 ? void 0 : _a.getElementComputedStyle("node", datum);
    Object.assign(style, pick_default(configStyle, ["labelFontSize", "labelLineHeight"]));
    if (this.options.mapLabelSize) {
      const fontSize = this.getLabelSizeByNodeSize(size2, Infinity, Number(style.labelFontSize));
      Object.assign(style, {
        labelFontSize: fontSize,
        labelLineHeight: fontSize + getVerticalPadding(style.labelPadding)
      });
    }
    return style;
  }
  getLabelSizeByNodeSize(size2, defaultMaxFontSize, defaultMinFontSize) {
    const fontSize = Math.min(...size2) / 2;
    const [minFontSize, maxFontSize] = !Array.isArray(this.options.mapLabelSize) ? [defaultMinFontSize, defaultMaxFontSize] : this.options.mapLabelSize;
    return Math.min(maxFontSize, Math.max(fontSize, minFontSize));
  }
  getCentralities(centrality) {
    const { model } = this.context;
    const graphData = model.getData();
    if (typeof centrality === "function")
      return centrality(graphData);
    const getRelatedEdgesData = model.getRelatedEdgesData.bind(model);
    return getNodeCentralities(graphData, getRelatedEdgesData, centrality);
  }
};
MapNodeSize.defaultOptions = {
  centrality: { type: "degree" },
  maxSize: 80,
  minSize: 20,
  scale: "linear",
  mapLabelSize: false
};

// node_modules/@antv/g6/esm/transforms/place-radial-labels.js
var PlaceRadialLabels = class _PlaceRadialLabels extends BaseTransform {
  constructor(context, options) {
    super(context, Object.assign({}, _PlaceRadialLabels.defaultOptions, options));
  }
  get ref() {
    return this.context.model.getRootsData()[0];
  }
  afterLayout() {
    var _a;
    const refPoint = positionOf(this.ref);
    const { graph, model } = this.context;
    const data = model.getData();
    (_a = data.nodes) === null || _a === void 0 ? void 0 : _a.forEach((datum) => {
      var _a2;
      if (idOf(datum) === idOf(this.ref))
        return;
      const radian = rad(subtract(positionOf(datum), refPoint));
      const isLeft = Math.abs(radian) > Math.PI / 2;
      const isLeaf = !datum.children || datum.children.length === 0;
      const nodeId = idOf(datum);
      const node = (_a2 = this.context.element) === null || _a2 === void 0 ? void 0 : _a2.getElement(nodeId);
      if (!node || !node.isVisible())
        return;
      const nodeHalfWidth = parseSize(graph.getElementRenderStyle(nodeId).size)[0] / 2;
      const offset = (isLeaf ? 1 : -1) * (nodeHalfWidth + this.options.offset);
      const labelTransform = [
        ["translate", offset * Math.cos(radian), offset * Math.sin(radian)],
        ["rotate", isLeft ? rad2deg(radian) + 180 : rad2deg(radian)]
      ];
      model.updateNodeData([
        {
          id: idOf(datum),
          style: {
            labelTextAlign: isLeft === isLeaf ? "right" : "left",
            labelTextBaseline: "middle",
            labelTransform
          }
        }
      ]);
    });
    graph.draw();
  }
};
PlaceRadialLabels.defaultOptions = {
  offset: 5
};

// node_modules/@antv/g6/esm/transforms/process-parallel-edges.js
var CUBIC_EDGE_TYPE = "quadratic";
var CUBIC_LOOP_PLACEMENTS = [
  "top",
  "top-right",
  "right",
  "right-bottom",
  "bottom",
  "bottom-left",
  "left",
  "left-top"
];
var ProcessParallelEdges = class _ProcessParallelEdges extends BaseTransform {
  constructor(context, options) {
    super(context, Object.assign({}, _ProcessParallelEdges.defaultOptions, options));
    this.cacheMergeStyle = /* @__PURE__ */ new Map();
    this.getAffectedParallelEdges = (input) => {
      const { add: { edges: edgesToAdd }, update: { nodes: nodesToUpdate, edges: edgesToUpdate, combos: combosToUpdate }, remove: { edges: edgesToRemove } } = input;
      const { model } = this.context;
      const edges = /* @__PURE__ */ new Map();
      const addRelatedEdges = (_2, id) => {
        const relatedEdgesData = model.getRelatedEdgesData(id);
        relatedEdgesData.forEach((edge) => !edges.has(idOf(edge)) && edges.set(idOf(edge), edge));
      };
      nodesToUpdate.forEach(addRelatedEdges);
      combosToUpdate.forEach(addRelatedEdges);
      const pushParallelEdges = (edge) => {
        const removedEdgeIds = new Set(input.remove.edges.keys());
        const validEdgeData = model.getEdgeData().filter((edge2) => !removedEdgeIds.has(idOf(edge2))).map((edge2) => getEdgeEndsContext(model, edge2));
        getParallelEdges(edge, validEdgeData, true).forEach((e2) => {
          const id = idOf(e2);
          if (!edges.has(id))
            edges.set(id, e2);
        });
      };
      if (edgesToRemove.size)
        edgesToRemove.forEach(pushParallelEdges);
      if (edgesToAdd.size)
        edgesToAdd.forEach(pushParallelEdges);
      if (edgesToUpdate.size) {
        const changes = groupByChangeType(reduceDataChanges(model.getChanges())).update.edges;
        edgesToUpdate.forEach((edge) => {
          var _a;
          pushParallelEdges(edge);
          const originalEdge = (_a = changes.find((e2) => idOf(e2.value) === idOf(edge))) === null || _a === void 0 ? void 0 : _a.original;
          if (originalEdge && !isParallelEdges(edge, originalEdge)) {
            pushParallelEdges(originalEdge);
          }
        });
      }
      if (!is_empty_default(this.options.edges)) {
        edges.forEach((_2, id) => !this.options.edges.includes(id) && edges.delete(id));
      }
      const edgeIds = model.getEdgeData().map(idOf);
      return new Map([...edges].sort((a3, b3) => edgeIds.indexOf(a3[0]) - edgeIds.indexOf(b3[0])));
    };
    this.applyBundlingStyle = (input, edges, distance4) => {
      const { edgeMap, reverses } = groupByEndpoints(edges);
      edgeMap.forEach((arcEdges) => {
        arcEdges.forEach((edge, i2, edgeArr) => {
          var _a;
          const length = edgeArr.length;
          const style = edge.style || {};
          if (edge.source === edge.target) {
            const len = CUBIC_LOOP_PLACEMENTS.length;
            style.loopPlacement = CUBIC_LOOP_PLACEMENTS[i2 % len];
            style.loopDist = Math.floor(i2 / len) * distance4 + 50;
          } else if (length === 1) {
            style.curveOffset = 0;
          } else {
            const sign = (i2 % 2 === 0 ? 1 : -1) * (reverses[`${edge.source}|${edge.target}|${i2}`] ? -1 : 1);
            style.curveOffset = length % 2 === 1 ? sign * Math.ceil(i2 / 2) * distance4 * 2 : sign * (Math.floor(i2 / 2) * distance4 * 2 + distance4);
          }
          const mergedEdgeData = Object.assign(edge, { type: CUBIC_EDGE_TYPE, style });
          const element = (_a = this.context.element) === null || _a === void 0 ? void 0 : _a.getElement(idOf(edge));
          if (!element || !isStyleEqual(mergedEdgeData.style, element.attributes)) {
            reassignTo(input, element ? "update" : "add", "edge", mergedEdgeData, true);
          }
        });
      });
    };
    this.resetEdgeStyle = (edge) => {
      const style = edge.style || {};
      const cacheStyle2 = this.cacheMergeStyle.get(idOf(edge)) || {};
      Object.keys(cacheStyle2).forEach((key) => {
        if (is_equal_default(style[key], cacheStyle2[key])) {
          if (edge[key]) {
            style[key] = edge[key];
          } else {
            delete style[key];
          }
        }
      });
      return Object.assign(edge, { style });
    };
    this.applyMergingStyle = (input, edges) => {
      const { edgeMap, reverses } = groupByEndpoints(edges);
      edgeMap.forEach((edges2) => {
        var _a;
        if (edges2.length === 1) {
          const edge = edges2[0];
          const element = (_a = this.context.element) === null || _a === void 0 ? void 0 : _a.getElement(idOf(edge));
          const edgeStyle = this.resetEdgeStyle(edge);
          if (!element || !isStyleEqual(edgeStyle, element.attributes)) {
            reassignTo(input, element ? "update" : "add", "edge", edgeStyle);
          }
          return;
        }
        const mergedStyle = edges2.map(({ source, target, style = {} }, i2) => {
          const { startArrow, endArrow } = style;
          const newStyle = {};
          const [start, end] = reverses[`${source}|${target}|${i2}`] ? ["endArrow", "startArrow"] : ["startArrow", "endArrow"];
          if (is_boolean_default(startArrow))
            newStyle[start] = startArrow;
          if (is_boolean_default(endArrow))
            newStyle[end] = endArrow;
          return newStyle;
        }).reduce((acc, style) => Object.assign(Object.assign({}, acc), style), {});
        edges2.forEach((edge, i2, edges3) => {
          var _a2;
          if (i2 !== 0) {
            reassignTo(input, "remove", "edge", edge);
            return;
          }
          const parsedStyle = Object.assign({}, isFunction(this.options.style) ? this.options.style(edges3) : this.options.style, { childrenData: edges3 });
          this.cacheMergeStyle.set(idOf(edge), parsedStyle);
          const mergedEdgeData = Object.assign(Object.assign({}, edge), { type: "line", style: Object.assign(Object.assign(Object.assign({}, edge.style), mergedStyle), parsedStyle) });
          const element = (_a2 = this.context.element) === null || _a2 === void 0 ? void 0 : _a2.getElement(idOf(edge));
          if (!element || !isStyleEqual(mergedEdgeData.style, element.attributes)) {
            reassignTo(input, element ? "update" : "add", "edge", mergedEdgeData, true);
          }
        });
      });
    };
  }
  /**
   * <zh/> 
   *
   * <en/> Process parallel edges before each drawing
   * @param input
   */
  beforeDraw(input) {
    const edges = this.getAffectedParallelEdges(input);
    if (edges.size === 0)
      return input;
    this.options.mode === "bundle" ? this.applyBundlingStyle(input, edges, this.options.distance) : this.applyMergingStyle(input, edges);
    return input;
  }
};
ProcessParallelEdges.defaultOptions = {
  mode: "bundle",
  distance: 15
  // only valid for bundling mode
};
var groupByEndpoints = (edges) => {
  const edgeMap = /* @__PURE__ */ new Map();
  const processedEdgesSet = /* @__PURE__ */ new Set();
  const reverses = {};
  const includedEdgesInGroup = /* @__PURE__ */ new Map();
  for (const [id, edge] of edges) {
    if (processedEdgesSet.has(id))
      continue;
    const { source, target } = edge;
    const sourceTarget = `${source}-${target}`;
    if (!edgeMap.has(sourceTarget)) {
      edgeMap.set(sourceTarget, []);
      includedEdgesInGroup.set(sourceTarget, /* @__PURE__ */ new Set());
    }
    const sourceTargetEdges = edgeMap.get(sourceTarget);
    const includedEdges = includedEdgesInGroup.get(sourceTarget);
    if (sourceTargetEdges && includedEdges && !includedEdges.has(id)) {
      sourceTargetEdges.push(edge);
      includedEdges.add(id);
      processedEdgesSet.add(id);
    }
    for (const [otherId, sedge] of edges) {
      if (processedEdgesSet.has(otherId) || otherId === id)
        continue;
      if (isParallelEdges(edge, sedge)) {
        const groupEdges = edgeMap.get(sourceTarget);
        const includedGroupEdges = includedEdgesInGroup.get(sourceTarget);
        if (groupEdges && includedGroupEdges && !includedGroupEdges.has(otherId)) {
          groupEdges.push(sedge);
          includedGroupEdges.add(otherId);
          if (source === sedge.target && target === sedge.source) {
            reverses[`${sedge.source}|${sedge.target}|${groupEdges.length - 1}`] = true;
          }
          processedEdgesSet.add(otherId);
        }
      }
    }
  }
  return { edgeMap, reverses };
};
var getParallelEdges = (edge, edges, containsSelf) => {
  return edges.filter((e2) => (containsSelf || idOf(e2) !== idOf(edge)) && isParallelEdges(e2, edge));
};
var isParallelEdges = (edge1, edge2) => {
  const { sourceNode: src1, targetNode: tgt1 } = edge1.style || {};
  const { sourceNode: src2, targetNode: tgt2 } = edge2.style || {};
  return src1 === src2 && tgt1 === tgt2 || src1 === tgt2 && tgt1 === src2;
};

// node_modules/@antv/g6/esm/transforms/update-related-edge.js
var UpdateRelatedEdge = class extends BaseTransform {
  beforeDraw(input, context) {
    const { stage } = context;
    if (stage === "visibility")
      return input;
    const { model } = this.context;
    const { update: { nodes, edges, combos } } = input;
    const addRelatedEdges = (_2, id) => {
      const relatedEdgesData = model.getRelatedEdgesData(id);
      relatedEdgesData.forEach((edge) => !edges.has(idOf(edge)) && edges.set(idOf(edge), edge));
    };
    nodes.forEach(addRelatedEdges);
    combos.forEach(addRelatedEdges);
    return input;
  }
};

// node_modules/@antv/g6/esm/registry/build-in.js
var BUILT_IN_EXTENSIONS = {
  animation: {
    "combo-collapse": ComboCollapse,
    "combo-expand": ComboExpand,
    "node-collapse": NodeCollapse,
    "node-expand": NodeExpand,
    "path-in": PathIn,
    "path-out": PathOut,
    fade: Fade,
    translate: Translate
  },
  behavior: {
    "brush-select": BrushSelect,
    "click-select": ClickSelect,
    "collapse-expand": CollapseExpand,
    "create-edge": CreateEdge,
    "drag-canvas": DragCanvas,
    "drag-element-force": DragElementForce,
    "drag-element": DragElement,
    "fix-element-size": FixElementSize,
    "focus-element": FocusElement,
    "hover-activate": HoverActivate,
    "lasso-select": LassoSelect,
    "auto-adapt-label": AutoAdaptLabel,
    "optimize-viewport-transform": OptimizeViewportTransform,
    "scroll-canvas": ScrollCanvas,
    "zoom-canvas": ZoomCanvas
  },
  combo: {
    circle: CircleCombo,
    rect: RectCombo
  },
  edge: {
    cubic: Cubic,
    line: Line2,
    polyline: Polyline2,
    quadratic: Quadratic,
    "cubic-horizontal": CubicHorizontal,
    "cubic-radial": CubicRadial,
    "cubic-vertical": CubicVertical
  },
  layout: {
    "antv-dagre": AntVDagreLayout,
    "combo-combined": ComboCombinedLayout,
    "compact-box": H,
    "d3-force": D3ForceLayout,
    "force-atlas2": ForceAtlas2Layout,
    circular: CircularLayout,
    concentric: ConcentricLayout,
    dagre: DagreLayout,
    dendrogram: S,
    fishbone: FishboneLayout,
    force: ForceLayout,
    fruchterman: FruchtermanLayout,
    grid: GridLayout,
    indented: C,
    mds: MDSLayout,
    mindmap: F,
    radial: RadialLayout,
    random: RandomLayout,
    snake: SnakeLayout
  },
  node: {
    circle: Circle2,
    diamond: Diamond,
    ellipse: Ellipse2,
    hexagon: Hexagon,
    html: HTML2,
    image: Image4,
    rect: Rect2,
    star: Star,
    donut: Donut,
    triangle: Triangle
  },
  palette: {
    spectral,
    tableau,
    oranges,
    greens,
    blues
  },
  theme: {
    dark,
    light
  },
  plugin: {
    "bubble-sets": BubbleSets2,
    "edge-bundling": EdgeBundling,
    "edge-filter-lens": EdgeFilterLens,
    "grid-line": GridLine,
    background: Background,
    contextmenu: Contextmenu,
    fisheye: Fisheye,
    fullscreen: Fullscreen,
    history: History2,
    hull: Hull,
    legend: Legend,
    minimap: Minimap,
    snapline: Snapline,
    timebar: Timebar2,
    title: Title,
    toolbar: Toolbar,
    tooltip: Tooltip2,
    watermark: Watermark
  },
  transform: {
    "arrange-draw-order": ArrangeDrawOrder,
    "collapse-expand-combo": CollapseExpandCombo,
    "collapse-expand-node": CollapseExpandNode,
    "get-edge-actual-ends": GetEdgeActualEnds,
    "map-node-size": MapNodeSize,
    "place-radial-labels": PlaceRadialLabels,
    "process-parallel-edges": ProcessParallelEdges,
    "update-related-edges": UpdateRelatedEdge
  },
  shape: {
    circle: Circle,
    ellipse: Ellipse,
    group: Group,
    html: HTML,
    image: Image3,
    line: Line,
    path: Path,
    polygon: Polygon,
    polyline: Polyline,
    rect: Rect,
    text: Text,
    label: Label,
    badge: Badge
  }
};
function registerBuiltInExtensions() {
  Object.entries(BUILT_IN_EXTENSIONS).forEach(([category, extensions]) => {
    Object.entries(extensions).forEach(([type, extension]) => {
      register(category, type, extension);
    });
  });
}

// node_modules/@antv/g6/esm/preset.js
registerBuiltInExtensions();

// node_modules/@antv/g6/esm/index.js
var iconfont = {
  css: "//at.alicdn.com/t/a/font_470089_8hnbbf8n4u8.css",
  js: "//at.alicdn.com/t/a/font_470089_8hnbbf8n4u8.js"
};

// node_modules/@antv/g6-extension-react/esm/react-node/render.js
var ReactDOM = __toESM(require_react_dom());
var __awaiter28 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var { version: version2 } = ReactDOM;
function getReactMajorVersion() {
  return Number((version2 || "").split(".")[0]);
}
var getRenderer = /* @__PURE__ */ (() => {
  let rendererPromise;
  return () => {
    if (!rendererPromise) {
      const majorVersion = getReactMajorVersion();
      if (majorVersion >= 18) {
        rendererPromise = import("./render18-MRFB7EKX.js");
      } else {
        rendererPromise = import("./render16-GLICT7FD.js");
      }
    }
    return rendererPromise;
  };
})();
function render(node, container) {
  return __awaiter28(this, void 0, void 0, function* () {
    const { render: render3 } = yield getRenderer();
    return render3(node, container);
  });
}
function unmount(container) {
  return __awaiter28(this, void 0, void 0, function* () {
    const { unmount: unmount3 } = yield getRenderer();
    return unmount3(container);
  });
}

// node_modules/@antv/g6-extension-react/esm/react-node/node.js
var ReactNode = class extends HTML2 {
  getKeyStyle(attributes) {
    return Object.assign({}, super.getKeyStyle(attributes));
  }
  constructor(options) {
    super(options);
  }
  update(attr) {
    super.update(attr);
  }
  connectedCallback() {
    super.connectedCallback();
    const { component } = this.attributes;
    render(component, this.getDomElement());
  }
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (name === "component" && oldValue !== newValue) {
      render(this.attributes.component, this.getDomElement());
    }
  }
  destroy() {
    unmount(this.getDomElement());
    super.destroy();
  }
};

// node_modules/@ant-design/graphs/es/core/behaviors/hover-activate-chain.js
var HoverActivateChain = class extends HoverActivate {
  getActiveIds(event) {
    const { model, graph } = this.context;
    const targetId = event.target.id;
    const targetType = graph.getElementType(targetId);
    const ids = [targetId];
    if (targetType === "edge") {
      const edge = model.getEdgeDatum(targetId);
      this.collectChainNodes(edge.source, "in", ids);
      this.collectChainNodes(edge.target, "out", ids);
    } else if (targetType === "node") {
      this.collectChainNodes(targetId, "both", ids);
    }
    graph.frontElement(ids);
    return ids;
  }
  collectChainNodes(nodeId, direction, ids) {
    const { model } = this.context;
    const edges = model.getRelatedEdgesData(nodeId, direction);
    edges.forEach((edge) => {
      if (!ids.includes(idOf(edge)))
        ids.push(idOf(edge));
      if (!ids.includes(edge.source)) {
        ids.push(edge.source);
        this.collectChainNodes(edge.source, "in", ids);
      }
      if (!ids.includes(edge.target)) {
        ids.push(edge.target);
        this.collectChainNodes(edge.target, "out", ids);
      }
    });
  }
};

// node_modules/@ant-design/graphs/es/core/behaviors/hover-activate-neighbors.js
var HoverActivateNeighbors = class extends HoverActivate {
  getActiveIds(event) {
    const { model, graph } = this.context;
    const targetId = event.target.id;
    const targetType = graph.getElementType(targetId);
    const ids = [targetId];
    if (targetType === "edge") {
      const edge = model.getEdgeDatum(targetId);
      ids.push(edge.source, edge.target);
    } else if (targetType === "node") {
      ids.push(...model.getRelatedEdgesData(targetId).map(idOf));
    }
    graph.frontElement(ids);
    return ids;
  }
};

// node_modules/@ant-design/graphs/es/core/edges/indented-edge.js
var IndentedEdge = class extends Polyline2 {
  getControlPoints(attributes) {
    const [sourcePoint, targetPoint] = this.getEndpoints(attributes, false);
    const [sx] = sourcePoint;
    const [, ty] = targetPoint;
    return [[sx, ty]];
  }
};

// node_modules/@ant-design/graphs/es/core/transform/arrange-edge-z-index.js
var ArrangeEdgeZIndex = class extends BaseTransform {
  beforeDraw(input) {
    const { model } = this.context;
    const { nodes, edges } = model.getData();
    const oneLevelNodes = nodes.filter((node) => node.depth === 1);
    const oneLevelNodeIds = oneLevelNodes.map((node) => node.id);
    edges.forEach((edge) => {
      if (oneLevelNodeIds.includes(edge.target)) {
        edge.style || (edge.style = {});
        edge.style.zIndex = oneLevelNodes.length - oneLevelNodes.findIndex((node) => node.id === edge.target);
      }
    });
    return input;
  }
};

// node_modules/@ant-design/graphs/es/core/transform/assign-color-by-branch.js
var _AssignColorByBranch = class _AssignColorByBranch extends BaseTransform {
  constructor(context, options) {
    super(context, Object.assign({}, _AssignColorByBranch.defaultOptions, options));
  }
  beforeDraw(input) {
    const nodes = this.context.model.getNodeData();
    if (nodes.length === 0)
      return input;
    let colorIndex = 0;
    const dfs4 = (nodeId, color) => {
      var _a;
      const node = nodes.find((datum) => datum.id == nodeId);
      if (!node)
        return;
      node.style || (node.style = {});
      node.style.color = color || this.options.colors[colorIndex++ % this.options.colors.length];
      (_a = node.children) == null ? void 0 : _a.forEach((childId) => {
        var _a2;
        return dfs4(childId, (_a2 = node.style) == null ? void 0 : _a2.color);
      });
    };
    nodes.filter((node) => node.depth === 1).forEach((rootNode) => dfs4(rootNode.id));
    return input;
  }
};
__publicField(_AssignColorByBranch, "defaultOptions", {
  colors: [
    "#1783FF",
    "#F08F56",
    "#D580FF",
    "#00C9C9",
    "#7863FF",
    "#DB9D0D",
    "#60C42D",
    "#FF80CA",
    "#2491B3",
    "#17C76F"
  ]
});
var AssignColorByBranch = _AssignColorByBranch;

// node_modules/@ant-design/graphs/es/core/transform/collapse-expand-react-node.js
var import_lodash3 = __toESM(require_lodash());
var import_react9 = __toESM(require_react());

// node_modules/@ant-design/graphs/es/core/base/collapse-expand-icon/index.js
var collapse_expand_icon_exports = {};
__export(collapse_expand_icon_exports, {
  ArrowCountIcon: () => ArrowCountIcon,
  PlusMinusIcon: () => PlusMinusIcon
});

// node_modules/@ant-design/graphs/es/core/base/collapse-expand-icon/arrow-count-icon.js
var import_react2 = __toESM(require_react());

// node_modules/styled-components/dist/styled-components.browser.esm.js
init_emotion_is_prop_valid_esm();
var import_react = __toESM(require_react());

// node_modules/styled-components/node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

// node_modules/styled-components/dist/styled-components.browser.esm.js
var a2 = "undefined" != typeof process && void 0 !== process.env && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled";
var c2 = "active";
var u2 = "data-styled-version";
var l2 = "6.3.8";
var d2 = "/*!sc*/\n";
var p2 = "undefined" != typeof window && "undefined" != typeof document;
var h2 = void 0 === import_react.default.createContext;
var f2 = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && void 0 !== process.env.REACT_APP_SC_DISABLE_SPEEDY && "" !== process.env.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== process.env.REACT_APP_SC_DISABLE_SPEEDY && process.env.REACT_APP_SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && void 0 !== process.env.SC_DISABLE_SPEEDY && "" !== process.env.SC_DISABLE_SPEEDY ? "false" !== process.env.SC_DISABLE_SPEEDY && process.env.SC_DISABLE_SPEEDY : true);
var y3 = /invalid hook call/i;
var v2 = /* @__PURE__ */ new Set();
var g2 = function(t3, n2) {
  if (true) {
    if (h2) return;
    var r3 = n2 ? ' with the id of "'.concat(n2, '"') : "", s2 = "The component ".concat(t3).concat(r3, " has been created dynamically.\n") + "You may see this warning because you've called styled inside another component.\nTo resolve this only create new StyledComponents outside of any render method and function component.\nSee https://styled-components.com/docs/basics#define-styled-components-outside-of-the-render-method for more info.\n", i2 = console.error;
    try {
      var a3 = true;
      console.error = function(t4) {
        for (var n3 = [], o3 = 1; o3 < arguments.length; o3++) n3[o3 - 1] = arguments[o3];
        y3.test(t4) ? (a3 = false, v2.delete(s2)) : i2.apply(void 0, __spreadArray([t4], n3, false));
      }, "function" == typeof import_react.default.useState && import_react.default.useState(null), a3 && !v2.has(s2) && (console.warn(s2), v2.add(s2));
    } catch (e2) {
      y3.test(e2.message) && v2.delete(s2);
    } finally {
      console.error = i2;
    }
  }
};
var S3 = Object.freeze([]);
var w2 = Object.freeze({});
function b2(e2, t3, n2) {
  return void 0 === n2 && (n2 = w2), e2.theme !== n2.theme && e2.theme || t3 || n2.theme;
}
var E3 = /* @__PURE__ */ new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "blockquote", "body", "button", "br", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "menu", "meter", "nav", "object", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "search", "section", "select", "slot", "small", "span", "strong", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "switch", "symbol", "text", "textPath", "tspan", "use"]);
var N3 = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g;
var C2 = /(^-|-$)/g;
function A2(e2) {
  return e2.replace(N3, "-").replace(C2, "");
}
var P2 = /(a)(d)/gi;
var _ = function(e2) {
  return String.fromCharCode(e2 + (e2 > 25 ? 39 : 97));
};
function I2(e2) {
  var t3, n2 = "";
  for (t3 = Math.abs(e2); t3 > 52; t3 = t3 / 52 | 0) n2 = _(t3 % 52) + n2;
  return (_(t3 % 52) + n2).replace(P2, "$1-$2");
}
var O;
var D2 = function(e2, t3) {
  for (var n2 = t3.length; n2; ) e2 = 33 * e2 ^ t3.charCodeAt(--n2);
  return e2;
};
var T2 = function(e2) {
  return D2(5381, e2);
};
function R2(e2) {
  return I2(T2(e2) >>> 0);
}
function x3(e2) {
  return "string" == typeof e2 && e2 || e2.displayName || e2.name || "Component";
}
function k(e2) {
  return "string" == typeof e2 && e2.charAt(0) === e2.charAt(0).toLowerCase();
}
var j = "function" == typeof Symbol && Symbol.for;
var M2 = j ? Symbol.for("react.memo") : 60115;
var V2 = j ? Symbol.for("react.forward_ref") : 60112;
var F2 = { childContextTypes: true, contextType: true, contextTypes: true, defaultProps: true, displayName: true, getDefaultProps: true, getDerivedStateFromError: true, getDerivedStateFromProps: true, mixins: true, propTypes: true, type: true };
var L2 = { name: true, length: true, prototype: true, caller: true, callee: true, arguments: true, arity: true };
var B2 = { $$typeof: true, compare: true, defaultProps: true, displayName: true, propTypes: true, type: true };
var G2 = ((O = {})[V2] = { $$typeof: true, render: true, defaultProps: true, displayName: true, propTypes: true }, O[M2] = B2, O);
function z3(e2) {
  return ("type" in (t3 = e2) && t3.type.$$typeof) === M2 ? B2 : "$$typeof" in e2 ? G2[e2.$$typeof] : F2;
  var t3;
}
var $ = Object.defineProperty;
var Y2 = Object.getOwnPropertyNames;
var q = Object.getOwnPropertySymbols;
var W2 = Object.getOwnPropertyDescriptor;
var H2 = Object.getPrototypeOf;
var U = Object.prototype;
function J(e2, t3, n2) {
  if ("string" != typeof t3) {
    if (U) {
      var o3 = H2(t3);
      o3 && o3 !== U && J(e2, o3, n2);
    }
    var r3 = Y2(t3);
    q && (r3 = r3.concat(q(t3)));
    for (var s2 = z3(e2), i2 = z3(t3), a3 = 0; a3 < r3.length; ++a3) {
      var c3 = r3[a3];
      if (!(c3 in L2 || n2 && n2[c3] || i2 && c3 in i2 || s2 && c3 in s2)) {
        var u3 = W2(t3, c3);
        try {
          $(e2, c3, u3);
        } catch (e3) {
        }
      }
    }
  }
  return e2;
}
function X(e2) {
  return "function" == typeof e2;
}
function Z(e2) {
  return "object" == typeof e2 && "styledComponentId" in e2;
}
function K(e2, t3) {
  return e2 && t3 ? "".concat(e2, " ").concat(t3) : e2 || t3 || "";
}
function Q(e2, t3) {
  if (0 === e2.length) return "";
  for (var n2 = e2[0], o3 = 1; o3 < e2.length; o3++) n2 += t3 ? t3 + e2[o3] : e2[o3];
  return n2;
}
function ee(e2) {
  return null !== e2 && "object" == typeof e2 && e2.constructor.name === Object.name && !("props" in e2 && e2.$$typeof);
}
function te(e2, t3, n2) {
  if (void 0 === n2 && (n2 = false), !n2 && !ee(e2) && !Array.isArray(e2)) return t3;
  if (Array.isArray(t3)) for (var o3 = 0; o3 < t3.length; o3++) e2[o3] = te(e2[o3], t3[o3]);
  else if (ee(t3)) for (var o3 in t3) e2[o3] = te(e2[o3], t3[o3]);
  return e2;
}
function ne(e2, t3) {
  Object.defineProperty(e2, "toString", { value: t3 });
}
var oe = true ? { 1: "Cannot create styled-component for component: %s.\n\n", 2: "Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\n\n- Are you trying to reuse it across renders?\n- Are you accidentally calling collectStyles twice?\n\n", 3: "Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\n\n", 4: "The `StyleSheetManager` expects a valid target or sheet prop!\n\n- Does this error occur on the client and is your target falsy?\n- Does this error occur on the server and is the sheet falsy?\n\n", 5: "The clone method cannot be used on the client!\n\n- Are you running in a client-like environment on the server?\n- Are you trying to run SSR on the client?\n\n", 6: "Trying to insert a new style tag, but the given Node is unmounted!\n\n- Are you using a custom target that isn't mounted?\n- Does your document not have a valid head element?\n- Have you accidentally removed a style tag manually?\n\n", 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: 'ThemeProvider: Please make your "theme" prop an object.\n\n', 9: "Missing document `<head>`\n\n", 10: "Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\n\n", 11: "_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\n\n", 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: "%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\n\n", 14: 'ThemeProvider: "theme" prop is required.\n\n', 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: "Reached the limit of how many styled components may be created at group %s.\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\nas for instance in your render method then you may be running into this limitation.\n\n", 17: "CSSStyleSheet could not be found on HTMLStyleElement.\nHas styled-components' style tag been unmounted or altered by another script?\n", 18: "ThemeProvider: Please make sure your useTheme hook is within a `<ThemeProvider>`" } : {};
function re() {
  for (var e2 = [], t3 = 0; t3 < arguments.length; t3++) e2[t3] = arguments[t3];
  for (var n2 = e2[0], o3 = [], r3 = 1, s2 = e2.length; r3 < s2; r3 += 1) o3.push(e2[r3]);
  return o3.forEach(function(e3) {
    n2 = n2.replace(/%[a-z]/, e3);
  }), n2;
}
function se(t3) {
  for (var n2 = [], o3 = 1; o3 < arguments.length; o3++) n2[o3 - 1] = arguments[o3];
  return false ? new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(t3, " for more information.").concat(n2.length > 0 ? " Args: ".concat(n2.join(", ")) : "")) : new Error(re.apply(void 0, __spreadArray([oe[t3]], n2, false)).trim());
}
var ie = function() {
  function e2(e3) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e3;
  }
  return e2.prototype.indexOfGroup = function(e3) {
    for (var t3 = 0, n2 = 0; n2 < e3; n2++) t3 += this.groupSizes[n2];
    return t3;
  }, e2.prototype.insertRules = function(e3, t3) {
    if (e3 >= this.groupSizes.length) {
      for (var n2 = this.groupSizes, o3 = n2.length, r3 = o3; e3 >= r3; ) if ((r3 <<= 1) < 0) throw se(16, "".concat(e3));
      this.groupSizes = new Uint32Array(r3), this.groupSizes.set(n2), this.length = r3;
      for (var s2 = o3; s2 < r3; s2++) this.groupSizes[s2] = 0;
    }
    for (var i2 = this.indexOfGroup(e3 + 1), a3 = (s2 = 0, t3.length); s2 < a3; s2++) this.tag.insertRule(i2, t3[s2]) && (this.groupSizes[e3]++, i2++);
  }, e2.prototype.clearGroup = function(e3) {
    if (e3 < this.length) {
      var t3 = this.groupSizes[e3], n2 = this.indexOfGroup(e3), o3 = n2 + t3;
      this.groupSizes[e3] = 0;
      for (var r3 = n2; r3 < o3; r3++) this.tag.deleteRule(n2);
    }
  }, e2.prototype.getGroup = function(e3) {
    var t3 = "";
    if (e3 >= this.length || 0 === this.groupSizes[e3]) return t3;
    for (var n2 = this.groupSizes[e3], o3 = this.indexOfGroup(e3), r3 = o3 + n2, s2 = o3; s2 < r3; s2++) t3 += "".concat(this.tag.getRule(s2)).concat(d2);
    return t3;
  }, e2;
}();
var ae = 1 << 30;
var ce = /* @__PURE__ */ new Map();
var ue = /* @__PURE__ */ new Map();
var le = 1;
var de = function(e2) {
  if (ce.has(e2)) return ce.get(e2);
  for (; ue.has(le); ) le++;
  var t3 = le++;
  if ((0 | t3) < 0 || t3 > ae) throw se(16, "".concat(t3));
  return ce.set(e2, t3), ue.set(t3, e2), t3;
};
var pe = function(e2, t3) {
  le = t3 + 1, ce.set(e2, t3), ue.set(t3, e2);
};
var he = "style[".concat(a2, "][").concat(u2, '="').concat(l2, '"]');
var fe = new RegExp("^".concat(a2, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'));
var me = function(e2, t3, n2) {
  for (var o3, r3 = n2.split(","), s2 = 0, i2 = r3.length; s2 < i2; s2++) (o3 = r3[s2]) && e2.registerName(t3, o3);
};
var ye = function(e2, t3) {
  for (var n2, o3 = (null !== (n2 = t3.textContent) && void 0 !== n2 ? n2 : "").split(d2), r3 = [], s2 = 0, i2 = o3.length; s2 < i2; s2++) {
    var a3 = o3[s2].trim();
    if (a3) {
      var c3 = a3.match(fe);
      if (c3) {
        var u3 = 0 | parseInt(c3[1], 10), l3 = c3[2];
        0 !== u3 && (pe(l3, u3), me(e2, l3, c3[3]), e2.getTag().insertRules(u3, r3)), r3.length = 0;
      } else r3.push(a3);
    }
  }
};
var ve = function(e2) {
  for (var t3 = document.querySelectorAll(he), n2 = 0, o3 = t3.length; n2 < o3; n2++) {
    var r3 = t3[n2];
    r3 && r3.getAttribute(a2) !== c2 && (ye(e2, r3), r3.parentNode && r3.parentNode.removeChild(r3));
  }
};
function ge() {
  return "undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : null;
}
var Se = function(e2) {
  var t3 = document.head, n2 = e2 || t3, o3 = document.createElement("style"), r3 = function(e3) {
    var t4 = Array.from(e3.querySelectorAll("style[".concat(a2, "]")));
    return t4[t4.length - 1];
  }(n2), s2 = void 0 !== r3 ? r3.nextSibling : null;
  o3.setAttribute(a2, c2), o3.setAttribute(u2, l2);
  var i2 = ge();
  return i2 && o3.setAttribute("nonce", i2), n2.insertBefore(o3, s2), o3;
};
var we = function() {
  function e2(e3) {
    this.element = Se(e3), this.element.appendChild(document.createTextNode("")), this.sheet = function(e4) {
      if (e4.sheet) return e4.sheet;
      for (var t3 = document.styleSheets, n2 = 0, o3 = t3.length; n2 < o3; n2++) {
        var r3 = t3[n2];
        if (r3.ownerNode === e4) return r3;
      }
      throw se(17);
    }(this.element), this.length = 0;
  }
  return e2.prototype.insertRule = function(e3, t3) {
    try {
      return this.sheet.insertRule(t3, e3), this.length++, true;
    } catch (e4) {
      return false;
    }
  }, e2.prototype.deleteRule = function(e3) {
    this.sheet.deleteRule(e3), this.length--;
  }, e2.prototype.getRule = function(e3) {
    var t3 = this.sheet.cssRules[e3];
    return t3 && t3.cssText ? t3.cssText : "";
  }, e2;
}();
var be = function() {
  function e2(e3) {
    this.element = Se(e3), this.nodes = this.element.childNodes, this.length = 0;
  }
  return e2.prototype.insertRule = function(e3, t3) {
    if (e3 <= this.length && e3 >= 0) {
      var n2 = document.createTextNode(t3);
      return this.element.insertBefore(n2, this.nodes[e3] || null), this.length++, true;
    }
    return false;
  }, e2.prototype.deleteRule = function(e3) {
    this.element.removeChild(this.nodes[e3]), this.length--;
  }, e2.prototype.getRule = function(e3) {
    return e3 < this.length ? this.nodes[e3].textContent : "";
  }, e2;
}();
var Ee = function() {
  function e2(e3) {
    this.rules = [], this.length = 0;
  }
  return e2.prototype.insertRule = function(e3, t3) {
    return e3 <= this.length && (this.rules.splice(e3, 0, t3), this.length++, true);
  }, e2.prototype.deleteRule = function(e3) {
    this.rules.splice(e3, 1), this.length--;
  }, e2.prototype.getRule = function(e3) {
    return e3 < this.length ? this.rules[e3] : "";
  }, e2;
}();
var Ne = p2;
var Ce = { isServer: !p2, useCSSOMInjection: !f2 };
var Ae = function() {
  function e2(e3, n2, o3) {
    void 0 === e3 && (e3 = w2), void 0 === n2 && (n2 = {});
    var r3 = this;
    this.options = __assign(__assign({}, Ce), e3), this.gs = n2, this.names = new Map(o3), this.server = !!e3.isServer, !this.server && p2 && Ne && (Ne = false, ve(this)), ne(this, function() {
      return function(e4) {
        for (var t3 = e4.getTag(), n3 = t3.length, o4 = "", r4 = function(n4) {
          var r5 = function(e5) {
            return ue.get(e5);
          }(n4);
          if (void 0 === r5) return "continue";
          var s3 = e4.names.get(r5), i2 = t3.getGroup(n4);
          if (void 0 === s3 || !s3.size || 0 === i2.length) return "continue";
          var c3 = "".concat(a2, ".g").concat(n4, '[id="').concat(r5, '"]'), u3 = "";
          void 0 !== s3 && s3.forEach(function(e5) {
            e5.length > 0 && (u3 += "".concat(e5, ","));
          }), o4 += "".concat(i2).concat(c3, '{content:"').concat(u3, '"}').concat(d2);
        }, s2 = 0; s2 < n3; s2++) r4(s2);
        return o4;
      }(r3);
    });
  }
  return e2.registerId = function(e3) {
    return de(e3);
  }, e2.prototype.rehydrate = function() {
    !this.server && p2 && ve(this);
  }, e2.prototype.reconstructWithOptions = function(n2, o3) {
    return void 0 === o3 && (o3 = true), new e2(__assign(__assign({}, this.options), n2), this.gs, o3 && this.names || void 0);
  }, e2.prototype.allocateGSInstance = function(e3) {
    return this.gs[e3] = (this.gs[e3] || 0) + 1;
  }, e2.prototype.getTag = function() {
    return this.tag || (this.tag = (e3 = function(e4) {
      var t3 = e4.useCSSOMInjection, n2 = e4.target;
      return e4.isServer ? new Ee(n2) : t3 ? new we(n2) : new be(n2);
    }(this.options), new ie(e3)));
    var e3;
  }, e2.prototype.hasNameForId = function(e3, t3) {
    return this.names.has(e3) && this.names.get(e3).has(t3);
  }, e2.prototype.registerName = function(e3, t3) {
    if (de(e3), this.names.has(e3)) this.names.get(e3).add(t3);
    else {
      var n2 = /* @__PURE__ */ new Set();
      n2.add(t3), this.names.set(e3, n2);
    }
  }, e2.prototype.insertRules = function(e3, t3, n2) {
    this.registerName(e3, t3), this.getTag().insertRules(de(e3), n2);
  }, e2.prototype.clearNames = function(e3) {
    this.names.has(e3) && this.names.get(e3).clear();
  }, e2.prototype.clearRules = function(e3) {
    this.getTag().clearGroup(de(e3)), this.clearNames(e3);
  }, e2.prototype.clearTag = function() {
    this.tag = void 0;
  }, e2;
}();
var Pe = /&/g;
var _e = 47;
function Ie(e2) {
  if (-1 === e2.indexOf("}")) return false;
  for (var t3 = e2.length, n2 = 0, o3 = 0, r3 = false, s2 = 0; s2 < t3; s2++) {
    var i2 = e2.charCodeAt(s2);
    if (0 !== o3 || r3 || i2 !== _e || 42 !== e2.charCodeAt(s2 + 1)) if (r3) 42 === i2 && e2.charCodeAt(s2 + 1) === _e && (r3 = false, s2++);
    else if (34 !== i2 && 39 !== i2 || 0 !== s2 && 92 === e2.charCodeAt(s2 - 1)) {
      if (0 === o3) {
        if (123 === i2) n2++;
        else if (125 === i2 && --n2 < 0) return true;
      }
    } else 0 === o3 ? o3 = i2 : o3 === i2 && (o3 = 0);
    else r3 = true, s2++;
  }
  return 0 !== n2 || 0 !== o3;
}
function Oe(e2, t3) {
  return e2.map(function(e3) {
    return "rule" === e3.type && (e3.value = "".concat(t3, " ").concat(e3.value), e3.value = e3.value.replaceAll(",", ",".concat(t3, " ")), e3.props = e3.props.map(function(e4) {
      return "".concat(t3, " ").concat(e4);
    })), Array.isArray(e3.children) && "@keyframes" !== e3.type && (e3.children = Oe(e3.children, t3)), e3;
  });
}
function De(e2) {
  var t3, n2, o3, r3 = void 0 === e2 ? w2 : e2, i2 = r3.options, a3 = void 0 === i2 ? w2 : i2, c3 = r3.plugins, u3 = void 0 === c3 ? S3 : c3, l3 = function(e3, o4, r4) {
    return r4.startsWith(n2) && r4.endsWith(n2) && r4.replaceAll(n2, "").length > 0 ? ".".concat(t3) : e3;
  }, d3 = u3.slice();
  d3.push(function(e3) {
    e3.type === RULESET && e3.value.includes("&") && (e3.props[0] = e3.props[0].replace(Pe, n2).replace(o3, l3));
  }), a3.prefix && d3.push(prefixer), d3.push(stringify);
  var p3 = function(e3, r4, i3, c4) {
    void 0 === r4 && (r4 = ""), void 0 === i3 && (i3 = ""), void 0 === c4 && (c4 = "&"), t3 = c4, n2 = r4, o3 = new RegExp("\\".concat(n2, "\\b"), "g");
    var u4 = function(e4) {
      if (!Ie(e4)) return e4;
      for (var t4 = e4.length, n3 = "", o4 = 0, r5 = 0, s2 = 0, i4 = false, a4 = 0; a4 < t4; a4++) {
        var c5 = e4.charCodeAt(a4);
        if (0 !== s2 || i4 || c5 !== _e || 42 !== e4.charCodeAt(a4 + 1)) if (i4) 42 === c5 && e4.charCodeAt(a4 + 1) === _e && (i4 = false, a4++);
        else if (34 !== c5 && 39 !== c5 || 0 !== a4 && 92 === e4.charCodeAt(a4 - 1)) {
          if (0 === s2) if (123 === c5) r5++;
          else if (125 === c5) {
            if (--r5 < 0) {
              for (var u5 = a4 + 1; u5 < t4; ) {
                var l5 = e4.charCodeAt(u5);
                if (59 === l5 || 10 === l5) break;
                u5++;
              }
              u5 < t4 && 59 === e4.charCodeAt(u5) && u5++, r5 = 0, a4 = u5 - 1, o4 = u5;
              continue;
            }
            0 === r5 && (n3 += e4.substring(o4, a4 + 1), o4 = a4 + 1);
          } else 59 === c5 && 0 === r5 && (n3 += e4.substring(o4, a4 + 1), o4 = a4 + 1);
        } else 0 === s2 ? s2 = c5 : s2 === c5 && (s2 = 0);
        else i4 = true, a4++;
      }
      if (o4 < t4) {
        var d4 = e4.substring(o4);
        Ie(d4) || (n3 += d4);
      }
      return n3;
    }(function(e4) {
      if (-1 === e4.indexOf("//")) return e4;
      for (var t4 = e4.length, n3 = [], o4 = 0, r5 = 0, s2 = 0, i4 = 0; r5 < t4; ) {
        var a4 = e4.charCodeAt(r5);
        if (34 !== a4 && 39 !== a4 || 0 !== r5 && 92 === e4.charCodeAt(r5 - 1)) if (0 === s2) if (40 === a4 && r5 >= 3 && 108 == (32 | e4.charCodeAt(r5 - 1)) && 114 == (32 | e4.charCodeAt(r5 - 2)) && 117 == (32 | e4.charCodeAt(r5 - 3))) i4 = 1, r5++;
        else if (i4 > 0) 41 === a4 ? i4-- : 40 === a4 && i4++, r5++;
        else if (a4 === _e && r5 + 1 < t4 && e4.charCodeAt(r5 + 1) === _e) {
          for (r5 > o4 && n3.push(e4.substring(o4, r5)); r5 < t4 && 10 !== e4.charCodeAt(r5); ) r5++;
          o4 = r5;
        } else r5++;
        else r5++;
        else 0 === s2 ? s2 = a4 : s2 === a4 && (s2 = 0), r5++;
      }
      return 0 === o4 ? e4 : (o4 < t4 && n3.push(e4.substring(o4)), n3.join(""));
    }(e3)), l4 = compile(i3 || r4 ? "".concat(i3, " ").concat(r4, " { ").concat(u4, " }") : u4);
    a3.namespace && (l4 = Oe(l4, a3.namespace));
    var p4 = [];
    return serialize(l4, middleware(d3.concat(rulesheet(function(e4) {
      return p4.push(e4);
    })))), p4;
  };
  return p3.hash = u3.length ? u3.reduce(function(e3, t4) {
    return t4.name || se(15), D2(e3, t4.name);
  }, 5381).toString() : "", p3;
}
var Te = new Ae();
var Re = De();
var xe = { shouldForwardProp: void 0, styleSheet: Te, stylis: Re };
var ke = h2 ? { Provider: function(e2) {
  return e2.children;
}, Consumer: function(e2) {
  return (0, e2.children)(xe);
} } : import_react.default.createContext(xe);
var je = ke.Consumer;
var Me = h2 ? { Provider: function(e2) {
  return e2.children;
}, Consumer: function(e2) {
  return (0, e2.children)(void 0);
} } : import_react.default.createContext(void 0);
function Ve() {
  return h2 ? xe : import_react.default.useContext(ke);
}
function Fe(e2) {
  if (h2 || !import_react.default.useMemo) return e2.children;
  var t3 = Ve().styleSheet, n2 = import_react.default.useMemo(function() {
    var n3 = t3;
    return e2.sheet ? n3 = e2.sheet : e2.target && (n3 = n3.reconstructWithOptions({ target: e2.target }, false)), e2.disableCSSOMInjection && (n3 = n3.reconstructWithOptions({ useCSSOMInjection: false })), n3;
  }, [e2.disableCSSOMInjection, e2.sheet, e2.target, t3]), r3 = import_react.default.useMemo(function() {
    return De({ options: { namespace: e2.namespace, prefix: e2.enableVendorPrefixes }, plugins: e2.stylisPlugins });
  }, [e2.enableVendorPrefixes, e2.namespace, e2.stylisPlugins]), s2 = import_react.default.useMemo(function() {
    return { shouldForwardProp: e2.shouldForwardProp, styleSheet: n2, stylis: r3 };
  }, [e2.shouldForwardProp, n2, r3]);
  return import_react.default.createElement(ke.Provider, { value: s2 }, import_react.default.createElement(Me.Provider, { value: r3 }, e2.children));
}
var Le = function() {
  function e2(e3, t3) {
    var n2 = this;
    this.inject = function(e4, t4) {
      void 0 === t4 && (t4 = Re);
      var o3 = n2.name + t4.hash;
      e4.hasNameForId(n2.id, o3) || e4.insertRules(n2.id, o3, t4(n2.rules, o3, "@keyframes"));
    }, this.name = e3, this.id = "sc-keyframes-".concat(e3), this.rules = t3, ne(this, function() {
      throw se(12, String(n2.name));
    });
  }
  return e2.prototype.getName = function(e3) {
    return void 0 === e3 && (e3 = Re), this.name + e3.hash;
  }, e2;
}();
function Be(e2, t3) {
  return null == t3 || "boolean" == typeof t3 || "" === t3 ? "" : "number" != typeof t3 || 0 === t3 || e2 in unitlessKeys || e2.startsWith("--") ? String(t3).trim() : "".concat(t3, "px");
}
var Ge = function(e2) {
  return e2 >= "A" && e2 <= "Z";
};
function ze(e2) {
  for (var t3 = "", n2 = 0; n2 < e2.length; n2++) {
    var o3 = e2[n2];
    if (1 === n2 && "-" === o3 && "-" === e2[0]) return e2;
    Ge(o3) ? t3 += "-" + o3.toLowerCase() : t3 += o3;
  }
  return t3.startsWith("ms-") ? "-" + t3 : t3;
}
var $e = function(e2) {
  return null == e2 || false === e2 || "" === e2;
};
var Ye = function(t3) {
  var n2 = [];
  for (var o3 in t3) {
    var r3 = t3[o3];
    t3.hasOwnProperty(o3) && !$e(r3) && (Array.isArray(r3) && r3.isCss || X(r3) ? n2.push("".concat(ze(o3), ":"), r3, ";") : ee(r3) ? n2.push.apply(n2, __spreadArray(__spreadArray(["".concat(o3, " {")], Ye(r3), false), ["}"], false)) : n2.push("".concat(ze(o3), ": ").concat(Be(o3, r3), ";")));
  }
  return n2;
};
function qe(e2, t3, n2, o3) {
  if ($e(e2)) return [];
  if (Z(e2)) return [".".concat(e2.styledComponentId)];
  if (X(e2)) {
    if (!X(s2 = e2) || s2.prototype && s2.prototype.isReactComponent || !t3) return [e2];
    var r3 = e2(t3);
    return "object" != typeof r3 || Array.isArray(r3) || r3 instanceof Le || ee(r3) || null === r3 || console.error("".concat(x3(e2), " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.")), qe(r3, t3, n2, o3);
  }
  var s2;
  return e2 instanceof Le ? n2 ? (e2.inject(n2, o3), [e2.getName(o3)]) : [e2] : ee(e2) ? Ye(e2) : Array.isArray(e2) ? Array.prototype.concat.apply(S3, e2.map(function(e3) {
    return qe(e3, t3, n2, o3);
  })) : [e2.toString()];
}
function We(e2) {
  for (var t3 = 0; t3 < e2.length; t3 += 1) {
    var n2 = e2[t3];
    if (X(n2) && !Z(n2)) return false;
  }
  return true;
}
var He = T2(l2);
var Ue = function() {
  function e2(e3, t3, n2) {
    this.rules = e3, this.staticRulesId = "", this.isStatic = false, this.componentId = t3, this.baseHash = D2(He, t3), this.baseStyle = n2, Ae.registerId(t3);
  }
  return e2.prototype.generateAndInjectStyles = function(e3, t3, n2) {
    var o3 = this.baseStyle ? this.baseStyle.generateAndInjectStyles(e3, t3, n2).className : "";
    if (this.isStatic && !n2.hash) if (this.staticRulesId && t3.hasNameForId(this.componentId, this.staticRulesId)) o3 = K(o3, this.staticRulesId);
    else {
      var r3 = Q(qe(this.rules, e3, t3, n2)), s2 = I2(D2(this.baseHash, r3) >>> 0);
      if (!t3.hasNameForId(this.componentId, s2)) {
        var i2 = n2(r3, ".".concat(s2), void 0, this.componentId);
        t3.insertRules(this.componentId, s2, i2);
      }
      o3 = K(o3, s2), this.staticRulesId = s2;
    }
    else {
      for (var a3 = D2(this.baseHash, n2.hash), c3 = "", u3 = 0; u3 < this.rules.length; u3++) {
        var l3 = this.rules[u3];
        if ("string" == typeof l3) c3 += l3, a3 = D2(a3, l3);
        else if (l3) {
          var d3 = Q(qe(l3, e3, t3, n2));
          a3 = D2(a3, d3 + u3), c3 += d3;
        }
      }
      if (c3) {
        var p3 = I2(a3 >>> 0);
        if (!t3.hasNameForId(this.componentId, p3)) {
          var h3 = n2(c3, ".".concat(p3), void 0, this.componentId);
          t3.insertRules(this.componentId, p3, h3);
        }
        o3 = K(o3, p3);
      }
    }
    return { className: o3, css: "undefined" == typeof window ? t3.getTag().getGroup(de(this.componentId)) : "" };
  }, e2;
}();
var Je = h2 ? { Provider: function(e2) {
  return e2.children;
}, Consumer: function(e2) {
  return (0, e2.children)(void 0);
} } : import_react.default.createContext(void 0);
var Xe = Je.Consumer;
var Qe = {};
var et = /* @__PURE__ */ new Set();
function tt(e2, s2, i2) {
  var a3 = Z(e2), c3 = e2, u3 = !k(e2), d3 = s2.attrs, p3 = void 0 === d3 ? S3 : d3, f3 = s2.componentId, m2 = void 0 === f3 ? function(e3, t3) {
    var n2 = "string" != typeof e3 ? "sc" : A2(e3);
    Qe[n2] = (Qe[n2] || 0) + 1;
    var o3 = "".concat(n2, "-").concat(R2(l2 + n2 + Qe[n2]));
    return t3 ? "".concat(t3, "-").concat(o3) : o3;
  }(s2.displayName, s2.parentComponentId) : f3, y4 = s2.displayName, v3 = void 0 === y4 ? function(e3) {
    return k(e3) ? "styled.".concat(e3) : "Styled(".concat(x3(e3), ")");
  }(e2) : y4, N4 = s2.displayName && s2.componentId ? "".concat(A2(s2.displayName), "-").concat(s2.componentId) : s2.componentId || m2, C3 = a3 && c3.attrs ? c3.attrs.concat(p3).filter(Boolean) : p3, P3 = s2.shouldForwardProp;
  if (a3 && c3.shouldForwardProp) {
    var _2 = c3.shouldForwardProp;
    if (s2.shouldForwardProp) {
      var I3 = s2.shouldForwardProp;
      P3 = function(e3, t3) {
        return _2(e3, t3) && I3(e3, t3);
      };
    } else P3 = _2;
  }
  var O2 = new Ue(i2, N4, a3 ? c3.componentStyle : void 0);
  function D3(e3, s3) {
    return function(e4, s4, i3) {
      var a4 = e4.attrs, c4 = e4.componentStyle, u4 = e4.defaultProps, l3 = e4.foldedComponentIds, d4 = e4.styledComponentId, p4 = e4.target, f4 = h2 ? void 0 : import_react.default.useContext(Je), m3 = Ve(), y5 = e4.shouldForwardProp || m3.shouldForwardProp;
      import_react.default.useDebugValue && import_react.default.useDebugValue(d4);
      var v4 = b2(s4, f4, u4) || w2, g3 = function(e5, n2, o3) {
        for (var r3, s5 = __assign(__assign({}, n2), { className: void 0, theme: o3 }), i4 = 0; i4 < e5.length; i4 += 1) {
          var a5 = X(r3 = e5[i4]) ? r3(s5) : r3;
          for (var c5 in a5) "className" === c5 ? s5.className = K(s5.className, a5[c5]) : "style" === c5 ? s5.style = __assign(__assign({}, s5.style), a5[c5]) : s5[c5] = a5[c5];
        }
        return "className" in n2 && "string" == typeof n2.className && (s5.className = K(s5.className, n2.className)), s5;
      }(a4, s4, v4), S4 = g3.as || p4, N5 = {};
      for (var C4 in g3) void 0 === g3[C4] || "$" === C4[0] || "as" === C4 || "theme" === C4 && g3.theme === v4 || ("forwardedAs" === C4 ? N5.as = g3.forwardedAs : y5 && !y5(C4, S4) || (N5[C4] = g3[C4], y5 || false || isPropValid(C4) || et.has(C4) || !E3.has(S4) || (et.add(C4), console.warn('styled-components: it looks like an unknown prop "'.concat(C4, '" is being sent through to the DOM, which will likely trigger a React console error. If you would like automatic filtering of unknown props, you can opt-into that behavior via `<StyleSheetManager shouldForwardProp={...}>` (connect an API like `@emotion/is-prop-valid`) or consider using transient props (`$` prefix for automatic filtering.)')))));
      var A3 = function(e5, t3) {
        var n2 = Ve(), r3 = e5.generateAndInjectStyles(t3, n2.styleSheet, n2.stylis);
        return import_react.default.useDebugValue && import_react.default.useDebugValue(r3.className), r3;
      }(c4, g3), P4 = A3.className, _3 = A3.css;
      e4.warnTooManyClasses && e4.warnTooManyClasses(P4);
      var I4 = K(l3, d4);
      P4 && (I4 += " " + P4), g3.className && (I4 += " " + g3.className), N5[k(S4) && !E3.has(S4) ? "class" : "className"] = I4, i3 && (N5.ref = i3);
      var O3 = (0, import_react.createElement)(S4, N5);
      return h2 && _3 ? import_react.default.createElement(import_react.default.Fragment, null, import_react.default.createElement("style", { precedence: "styled-components", href: "sc-".concat(d4, "-").concat(P4), children: _3 }), O3) : O3;
    }(T3, e3, s3);
  }
  D3.displayName = v3;
  var T3 = import_react.default.forwardRef(D3);
  return T3.attrs = C3, T3.componentStyle = O2, T3.displayName = v3, T3.shouldForwardProp = P3, T3.foldedComponentIds = a3 ? K(c3.foldedComponentIds, c3.styledComponentId) : "", T3.styledComponentId = N4, T3.target = a3 ? c3.target : e2, Object.defineProperty(T3, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(e3) {
    this._foldedDefaultProps = a3 ? function(e4) {
      for (var t3 = [], n2 = 1; n2 < arguments.length; n2++) t3[n2 - 1] = arguments[n2];
      for (var o3 = 0, r3 = t3; o3 < r3.length; o3++) te(e4, r3[o3], true);
      return e4;
    }({}, c3.defaultProps, e3) : e3;
  } }), g2(v3, N4), T3.warnTooManyClasses = /* @__PURE__ */ function(e3, t3) {
    var n2 = {}, o3 = false;
    return function(r3) {
      if (!o3 && (n2[r3] = true, Object.keys(n2).length >= 200)) {
        var s3 = t3 ? ' with the id of "'.concat(t3, '"') : "";
        console.warn("Over ".concat(200, " classes were generated for component ").concat(e3).concat(s3, ".\n") + "Consider using the attrs method, together with a style object for frequently changed styles.\nExample:\n  const Component = styled.div.attrs(props => ({\n    style: {\n      background: props.background,\n    },\n  }))`width: 100%;`\n\n  <Component />"), o3 = true, n2 = {};
      }
    };
  }(v3, N4), ne(T3, function() {
    return ".".concat(T3.styledComponentId);
  }), u3 && J(T3, e2, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true }), T3;
}
function nt(e2, t3) {
  for (var n2 = [e2[0]], o3 = 0, r3 = t3.length; o3 < r3; o3 += 1) n2.push(t3[o3], e2[o3 + 1]);
  return n2;
}
var ot = function(e2) {
  return Object.assign(e2, { isCss: true });
};
function rt(t3) {
  for (var n2 = [], o3 = 1; o3 < arguments.length; o3++) n2[o3 - 1] = arguments[o3];
  if (X(t3) || ee(t3)) return ot(qe(nt(S3, __spreadArray([t3], n2, true))));
  var r3 = t3;
  return 0 === n2.length && 1 === r3.length && "string" == typeof r3[0] ? qe(r3) : ot(qe(nt(r3, n2)));
}
function st(n2, o3, r3) {
  if (void 0 === r3 && (r3 = w2), !o3) throw se(1, o3);
  var s2 = function(t3) {
    for (var s3 = [], i2 = 1; i2 < arguments.length; i2++) s3[i2 - 1] = arguments[i2];
    return n2(o3, r3, rt.apply(void 0, __spreadArray([t3], s3, false)));
  };
  return s2.attrs = function(e2) {
    return st(n2, o3, __assign(__assign({}, r3), { attrs: Array.prototype.concat(r3.attrs, e2).filter(Boolean) }));
  }, s2.withConfig = function(e2) {
    return st(n2, o3, __assign(__assign({}, r3), e2));
  }, s2;
}
var it = function(e2) {
  return st(tt, e2);
};
var at = it;
E3.forEach(function(e2) {
  at[e2] = it(e2);
});
var ct = function() {
  function e2(e3, t3) {
    this.rules = e3, this.componentId = t3, this.isStatic = We(e3), Ae.registerId(this.componentId + 1);
  }
  return e2.prototype.createStyles = function(e3, t3, n2, o3) {
    var r3 = o3(Q(qe(this.rules, t3, n2, o3)), ""), s2 = this.componentId + e3;
    n2.insertRules(s2, s2, r3);
  }, e2.prototype.removeStyles = function(e3, t3) {
    t3.clearRules(this.componentId + e3);
  }, e2.prototype.renderStyles = function(e3, t3, n2, o3) {
    e3 > 2 && Ae.registerId(this.componentId + e3);
    var r3 = this.componentId + e3;
    this.isStatic ? n2.hasNameForId(r3, r3) || this.createStyles(e3, t3, n2, o3) : (this.removeStyles(e3, n2), this.createStyles(e3, t3, n2, o3));
  }, e2;
}();
var pt = function() {
  function e2() {
    var e3 = this;
    this._emitSheetCSS = function() {
      var t3 = e3.instance.toString();
      if (!t3) return "";
      var n2 = ge(), o3 = Q([n2 && 'nonce="'.concat(n2, '"'), "".concat(a2, '="true"'), "".concat(u2, '="').concat(l2, '"')].filter(Boolean), " ");
      return "<style ".concat(o3, ">").concat(t3, "</style>");
    }, this.getStyleTags = function() {
      if (e3.sealed) throw se(2);
      return e3._emitSheetCSS();
    }, this.getStyleElement = function() {
      var n2;
      if (e3.sealed) throw se(2);
      var r3 = e3.instance.toString();
      if (!r3) return [];
      var s2 = ((n2 = {})[a2] = "", n2[u2] = l2, n2.dangerouslySetInnerHTML = { __html: r3 }, n2), i2 = ge();
      return i2 && (s2.nonce = i2), [import_react.default.createElement("style", __assign({}, s2, { key: "sc-0-0" }))];
    }, this.seal = function() {
      e3.sealed = true;
    }, this.instance = new Ae({ isServer: true }), this.sealed = false;
  }
  return e2.prototype.collectStyles = function(e3) {
    if (this.sealed) throw se(2);
    return import_react.default.createElement(Fe, { sheet: this.instance }, e3);
  }, e2.prototype.interleaveWithNodeStream = function(e3) {
    throw se(3);
  }, e2;
}();
"undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("It looks like you've imported 'styled-components' on React Native.\nPerhaps you're looking to import 'styled-components/native'?\nRead more about this at https://www.styled-components.com/docs/basics#react-native");
var ft = "__sc-".concat(a2, "__");
"undefined" != typeof window && (window[ft] || (window[ft] = 0), 1 === window[ft] && console.warn("It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.\n\nSee https://styled-components.com/docs/faqs#why-am-i-getting-a-warning-about-several-instances-of-module-on-the-page for more info."), window[ft] += 1);

// node_modules/@ant-design/graphs/es/core/base/collapse-expand-icon/arrow-count-icon.js
var StyledWrapper = at.div`
  ${({ $placement }) => {
  switch ($placement) {
    case "top":
      return "transform: translate(-50%, -100%); flex-direction: column-reverse;";
    case "right":
      return "transform: translate(0, -50%);";
    case "left":
      return "transform: translate(-100%, -50%); flex-direction: row-reverse;";
    default:
      return "transform: translate(-50%, 0); flex-direction: column;";
  }
}}

  .arrow-count-icon-bar {
    ${({ $placement }) => {
  const isVertical2 = $placement === "top" || $placement === "bottom";
  return isVertical2 ? "width: 3px; height: 8px; margin: 0 7px;" : "width: 8px; height: 3px; margin: 7px 0;";
}}
    background-color: ${({ $color }) => $color};
  }

  .arrow-count-icon-circle {
    width: 16px;
    height: 16px;
    color: #fff;
    font-weight: 600;
    font-size: 10px;
    line-height: ${({ $isCollapsed }) => $isCollapsed ? "16px" : "14px"};
    text-align: center;
    background-color: ${({ $color }) => $color};
    border-radius: 50%;
  }

  .arrow-count-icon-circle-arrow {
    width: 16px;
    height: 16px;
    transform: ${({ $isCollapsed, $placement }) => {
  if ($isCollapsed)
    return "none";
  switch ($placement) {
    case "top":
      return "translateY(1px) rotate(-90deg)";
    case "right":
      return "translateX(-1px) rotate(0deg)";
    case "left":
      return "translateX(1px) rotate(180deg)";
    default:
      return "translateY(-1px) rotate(90deg)";
  }
}};
  }

  display: ${({ $isCollapsed }) => $isCollapsed ? "flex" : "none"};

  .collapsible-node-wrapper:hover & {
    display: flex;
  }
`;
var ArrowCountIcon = (props) => {
  var _a;
  const { className, style, graph, data, isCollapsed: isCollapsed2, countType = "descendant", placement = "bottom" } = props;
  const color = ((_a = graph.getNodeData(data.id).style) == null ? void 0 : _a.color) || "#99ADD1";
  const count = (countType === "descendant" ? graph.getDescendantsData(data.id) : graph.getChildrenData(data.id)).length;
  return import_react2.default.createElement(
    StyledWrapper,
    { "$color": color, "$isCollapsed": isCollapsed2, "$placement": placement, className: `arrow-count-icon ${isCollapsed2 ? `arrow-count-icon-collapsed` : ""} ${className || ""}`, style },
    import_react2.default.createElement("div", { className: "arrow-count-icon-bar" }),
    import_react2.default.createElement("div", { className: "arrow-count-icon-circle" }, isCollapsed2 ? count : import_react2.default.createElement(
      "div",
      { className: "arrow-count-icon-circle-arrow" },
      import_react2.default.createElement(
        "svg",
        { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none" },
        import_react2.default.createElement("path", { d: "M11,4 L5.5,8 L11,12", stroke: "white", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" })
      )
    ))
  );
};

// node_modules/@ant-design/graphs/es/core/base/collapse-expand-icon/plus-minus-icon.js
var import_react3 = __toESM(require_react());
var StyledWrapper2 = at.div`
  height: 16px;
  width: 16px;
  transform: translate(-50%, -50%);
  background: #fff;
  border-radius: 50%;
  border: 2px solid #99add1;
  color: #99add1;
  font-weight: 800;
  line-height: 14px;
  text-align: center;
  box-sizing: content-box;
`;
var PlusMinusIcon = (props) => {
  const { isCollapsed: isCollapsed2, style, className } = props;
  return import_react3.default.createElement(StyledWrapper2, { className, style }, isCollapsed2 ? "+" : "-");
};

// node_modules/@ant-design/graphs/es/core/base/node/index.js
var node_exports = {};
__export(node_exports, {
  OrganizationChartNode: () => OrganizationChartNode,
  TextNode: () => TextNode
});

// node_modules/@ant-design/graphs/es/core/base/node/organization-chart-node.js
var import_react4 = __toESM(require_react());
var StyledWrapper3 = at.div`
  height: inherit;
  width: inherit;
  border-radius: 8px;
  box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.12), 0 2px 4px 0 rgba(0, 0, 0, 0.1);
  position: relative;
  border: none;
  background-color: #fff;
  box-sizing: content-box;

  ${(props) => props.$isActive && rt`
      transform: translate(-3px, -3px);
      border: 2px solid #1783ff;
    `}

  .org-chart-node-line {
    width: 100%;
    height: 6px;
    background-color: ${(props) => props.$color};
    border-radius: 8px 8px 0 0;
  }

  .org-chart-node-content {
    height: calc(100% - 6px);
    margin: 0 16px 3px;
    display: flex;
    align-items: center;

    &-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      margin-right: 16px;
      background-color: ${(props) => props.$color};
      font-weight: 600;
      font-size: 18px;
      text-align: center;
      line-height: 40px;
      color: #fff;
    }

    &-detail {
      width: calc(100% - 56px);
    }

    &-name {
      color: #242424;
      font-weight: 600;
      font-size: 18px;
      margin-bottom: 5px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    &-post {
      color: #616161;
      font-size: 14px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  }
`;
var OrganizationChartNode = (props) => {
  const { name, position: position2, status = "online", isActive, className, style } = props;
  const colorMap = {
    online: "#1783FF",
    busy: "#00C9C9",
    offline: "#F08F56"
  };
  return import_react4.default.createElement(
    StyledWrapper3,
    { "$color": colorMap[status], "$isActive": isActive, className, style },
    import_react4.default.createElement("div", { className: "org-chart-node-line" }),
    import_react4.default.createElement(
      "div",
      { className: "org-chart-node-content" },
      import_react4.default.createElement("div", { className: "org-chart-node-content-avatar" }, name.slice(0, 1)),
      import_react4.default.createElement(
        "div",
        { className: "org-chart-node-content-detail" },
        import_react4.default.createElement("div", { className: "org-chart-node-content-name" }, name),
        position2 && import_react4.default.createElement("div", { className: "org-chart-node-content-post" }, position2)
      )
    )
  );
};

// node_modules/@ant-design/graphs/node_modules/@ant-design/charts-util/es/react/render.js
var ReactDOM2 = __toESM(require_react_dom());
var __assign2 = function() {
  __assign2 = Object.assign || function(t3) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3))
        t3[p3] = s2[p3];
    }
    return t3;
  };
  return __assign2.apply(this, arguments);
};
var fullClone = __assign2({}, ReactDOM2);
var version3 = fullClone.version;
var reactRender = fullClone.render;
var unmountComponentAtNode = fullClone.unmountComponentAtNode;
var createRoot;
try {
  mainVersion = Number((version3 || "").split(".")[0]);
  if (mainVersion >= 18) {
    createRoot = fullClone.createRoot;
  }
} catch (e2) {
}
var mainVersion;

// node_modules/@ant-design/graphs/node_modules/@ant-design/charts-util/es/rc/create-node.js
var mountMapping = /* @__PURE__ */ new Map();
if (typeof document !== "undefined") {
  mountMapping.set("tooltip", document.createElement("div"));
}

// node_modules/@ant-design/graphs/node_modules/@ant-design/charts-util/es/rc/chart-loading.js
var import_react5 = __toESM(require_react());
var shadowLoading = function(ele) {
  if (typeof document === "undefined") {
    return "loading";
  }
  var shadowRoot = ele.attachShadow({ mode: "open" });
  var shadowDiv = document.createElement("div");
  var shadowStyle = document.createElement("style");
  shadowStyle.innerHTML = ".loading {\n    display: inline-block;\n    position: relative;\n    width: 80px;\n    height: 80px;\n  }\n  .loading div {\n    position: absolute;\n    top: 33px;\n    width: 13px;\n    height: 13px;\n    border-radius: 50%;\n    background: #ccc;\n    animation-timing-function: cubic-bezier(0, 1, 1, 0);\n  }\n  .loading div:nth-child(1) {\n    left: 8px;\n    animation: loading1 0.6s infinite;\n  }\n  .loading div:nth-child(2) {\n    left: 8px;\n    animation: loading2 0.6s infinite;\n  }\n  .loading div:nth-child(3) {\n    left: 32px;\n    animation: loading2 0.6s infinite;\n  }\n  .loading div:nth-child(4) {\n    left: 56px;\n    animation: loading3 0.6s infinite;\n  }\n  @keyframes loading1 {\n    0% {\n      transform: scale(0);\n    }\n    100% {\n      transform: scale(1);\n    }\n  }\n  @keyframes loading3 {\n    0% {\n      transform: scale(1);\n    }\n    100% {\n      transform: scale(0);\n    }\n  }\n  @keyframes loading2 {\n    0% {\n      transform: translate(0, 0);\n    }\n    100% {\n      transform: translate(24px, 0);\n    }\n  }\n  ";
  shadowDiv.classList.add("loading");
  shadowDiv.innerHTML = "<div></div><div></div><div></div><div></div>";
  shadowRoot.appendChild(shadowStyle);
  shadowRoot.appendChild(shadowDiv);
};
var ChartLoading = function(_a) {
  var loadingTemplate = _a.loadingTemplate, _b = _a.theme, theme = _b === void 0 ? "light" : _b;
  var shadow = import_react5.default.useRef(null);
  import_react5.default.useEffect(function() {
    if (!loadingTemplate && shadow.current) {
      shadowLoading(shadow.current);
    }
  }, []);
  var renderLoading = function() {
    if (loadingTemplate)
      return loadingTemplate;
    return import_react5.default.createElement("div", { ref: shadow });
  };
  return import_react5.default.createElement("div", { className: "charts-loading-container", style: {
    position: "absolute",
    width: "100%",
    height: "100%",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    left: 0,
    top: 0,
    zIndex: 99,
    backgroundColor: theme === "dark" ? "rgb(20, 20, 20)" : "rgb(255, 255, 255)"
  } }, renderLoading());
};

// node_modules/@ant-design/graphs/node_modules/@ant-design/charts-util/es/rc/error-boundary.js
var import_react6 = __toESM(require_react());
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d3, b3) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b4) {
      d4.__proto__ = b4;
    } || function(d4, b4) {
      for (var p3 in b4) if (Object.prototype.hasOwnProperty.call(b4, p3)) d4[p3] = b4[p3];
    };
    return extendStatics(d3, b3);
  };
  return function(d3, b3) {
    if (typeof b3 !== "function" && b3 !== null)
      throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
    extendStatics(d3, b3);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
  };
}();
var ErrorBoundary = (
  /** @class */
  function(_super) {
    __extends(ErrorBoundary2, _super);
    function ErrorBoundary2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.state = {
        hasError: false
      };
      _this.renderError = function(e2) {
        var errorTemplate = _this.props.errorTemplate;
        switch (e2) {
          default:
            if (typeof errorTemplate === "function")
              return errorTemplate(e2);
            return errorTemplate ? errorTemplate : import_react6.default.createElement(
              "h5",
              null,
              " ",
              e2.message
            );
        }
      };
      return _this;
    }
    ErrorBoundary2.getDerivedStateFromError = function(error) {
      return { hasError: true, error };
    };
    ErrorBoundary2.getDerivedStateFromProps = function(nextProps, state) {
      if (state.children !== nextProps.children) {
        return {
          children: nextProps.children,
          hasError: false,
          error: void 0
        };
      }
      return null;
    };
    ErrorBoundary2.prototype.render = function() {
      if (this.state.hasError) {
        return this.renderError(this.state.error);
      }
      return import_react6.default.createElement(import_react6.Fragment, null, this.props.children);
    };
    return ErrorBoundary2;
  }(import_react6.default.Component)
);

// node_modules/@ant-design/graphs/node_modules/@ant-design/charts-util/es/utils/measure-text.js
var import_lodash = __toESM(require_lodash());

// node_modules/@ant-design/graphs/node_modules/@ant-design/charts-util/es/utils/context.js
var ctx2;
var getCanvasContext = function() {
  if (!ctx2) {
    ctx2 = document.createElement("canvas").getContext("2d");
  }
  return ctx2;
};

// node_modules/@ant-design/graphs/node_modules/@ant-design/charts-util/es/utils/measure-text.js
var __spreadArray2 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l3 = from.length, ar; i2 < l3; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var measureText = (0, import_lodash.memoize)(function(text, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, _a = font.fontFamily, fontFamily = _a === void 0 ? "sans-serif" : _a, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  var ctx3 = getCanvasContext();
  ctx3.font = [fontStyle, fontWeight, fontVariant, "".concat(fontSize, "px"), fontFamily].join(" ");
  return ctx3.measureText((0, import_lodash.isString)(text) ? text : "");
}, function(text, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArray2([text], (0, import_lodash.values)(font), true).join("");
});
var measureTextWidth = function(text, font) {
  if (font === void 0) {
    font = {};
  }
  return measureText(text, font).width;
};
var measureTextHeight = function(text, font) {
  if (font === void 0) {
    font = {};
  }
  var metrics = measureText(text, font);
  return metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
};

// node_modules/@ant-design/graphs/es/core/base/node/text-node.js
var import_react7 = __toESM(require_react());

// node_modules/@ant-design/graphs/es/core/utils/color.js
function hexToRgba(hex, opacity) {
  let r3 = 0, g3 = 0, b3 = 0;
  if (hex.length === 4) {
    r3 = parseInt(hex[1] + hex[1], 16);
    g3 = parseInt(hex[2] + hex[2], 16);
    b3 = parseInt(hex[3] + hex[3], 16);
  } else if (hex.length === 7) {
    r3 = parseInt(hex[1] + hex[2], 16);
    g3 = parseInt(hex[3] + hex[4], 16);
    b3 = parseInt(hex[5] + hex[6], 16);
  }
  return `rgba(${r3}, ${g3}, ${b3}, ${opacity})`;
}
function darkenHexColor(hex, amount) {
  let r3 = 0, g3 = 0, b3 = 0;
  if (hex.length === 4) {
    r3 = parseInt(hex[1] + hex[1], 16);
    g3 = parseInt(hex[2] + hex[2], 16);
    b3 = parseInt(hex[3] + hex[3], 16);
  } else if (hex.length === 7) {
    r3 = parseInt(hex[1] + hex[2], 16);
    g3 = parseInt(hex[3] + hex[4], 16);
    b3 = parseInt(hex[5] + hex[6], 16);
  }
  r3 = Math.max(0, r3 - amount);
  g3 = Math.max(0, g3 - amount);
  b3 = Math.max(0, b3 - amount);
  const toHex = (c3) => c3.toString(16).padStart(2, "0");
  return `#${toHex(r3)}${toHex(g3)}${toHex(b3)}`;
}

// node_modules/@ant-design/graphs/es/core/base/node/text-node.js
var StyledWrapper4 = at.div`
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow-wrap: anywhere;
  line-height: 1.5em;
  text-align: center;
  height: inherit;
  width: inherit;
  box-sizing: content-box;
  font-size: 14px;

  ${({ $type, $color, $borderWidth }) => {
  switch ($type) {
    case "normal":
      return `
          color: ${$color};
        `;
    case "filled":
      return rt`
          color: #fff;
          background-color: ${$color};
          border-radius: 8px;
        `;
    case "outlined":
      return rt`
          height: calc(100% - 2 * ${$borderWidth}px);
          width: calc(100% - 2 * ${$borderWidth}px);
          color: ${$color};
          background-color: #fff;
          border: ${$borderWidth}px solid ${$color};
          border-radius: 8px;
        `;
    case "underlined":
      return rt`
          height: calc(100% - ${$borderWidth}px / 2);
          width: inherit;
          border-bottom: ${$borderWidth}px solid ${$color};
          background-color: #fff;
          color: ${$color};
        `;
  }
}}

  ${({ $isActive, $isSelected, $borderWidth, $color }) => ($isActive || $isSelected) && rt`
      height: calc(100% - 2 * ${$borderWidth}px);
      width: calc(100% - 2 * ${$borderWidth}px);
      border: ${$borderWidth}px solid ${darkenHexColor($color, 100)};
      ${$isSelected && `box-shadow: 0 0 0 2px ${hexToRgba($color, 0.1)};`}
    `}
`;
var TextNode = (props) => {
  const { className, style = {}, type = "normal", text = "", font, color = "#1783ff", borderWidth = 3, maxWidth = Infinity, isActive = false, isSelected = false } = props;
  const isMultiLine = measureTextWidth(text, font) > maxWidth;
  return import_react7.default.createElement(
    StyledWrapper4,
    { "$type": type, "$color": color, "$borderWidth": borderWidth, "$isActive": isActive, "$isSelected": isSelected, className: `text-node text-node-${type} ${className || ""}`, style: __spreadValues(__spreadValues({}, style), font) },
    import_react7.default.createElement("div", { style: isMultiLine ? { width: "calc(100% - 12px)" } : {} }, text)
  );
};

// node_modules/@ant-design/graphs/es/core/hoc/with-collapsible-node.js
var import_lodash2 = __toESM(require_lodash());
var import_react8 = __toESM(require_react());
var StyledWrapper5 = at.div`
  position: relative;
  height: inherit;
  width: inherit;
`;
var StyledIconWrapper = at.div`
  position: absolute;
  z-index: 10;

  &:hover {
    cursor: pointer;
  }

  ${({ $placement, $offsetX, $offsetY }) => {
  const positions = {
    top: `left: calc(50% + ${$offsetX}px); top: ${$offsetY}px;`,
    bottom: `left: calc(50% + ${$offsetX}px); top: calc(100% + ${$offsetY}px);`,
    right: `left: calc(100% + ${$offsetX}px); top: calc(50% + ${$offsetY}px);`,
    left: `left: ${$offsetX}px; top: calc(50% + ${$offsetY}px);`
  };
  return rt`
      ${positions[$placement]}
    `;
}}
`;
var withCollapsibleNode = (NodeComponent) => {
  return (props) => {
    const { data, graph, trigger, iconRender, iconPlacement, iconOffsetX, iconOffsetY, iconClassName, iconStyle, refreshLayout } = props;
    const [isCollapsed2, setIsCollapsed] = (0, import_react8.useState)((0, import_lodash2.get)(data, "style.collapsed", false));
    const wrapperRef = (0, import_react8.useRef)(null);
    const iconRef = (0, import_react8.useRef)(null);
    const isIconShown = trigger === "icon" && !(0, import_lodash2.isEmpty)(data.children);
    const handleClickCollapse = (e2) => __async(void 0, null, function* () {
      e2.stopPropagation();
      const toggleExpandCollapse = isCollapsed2 ? "expandElement" : "collapseElement";
      yield graph[toggleExpandCollapse](idOf(data));
      setIsCollapsed((prev) => !prev);
      if (refreshLayout) {
        yield graph.layout();
      }
    });
    (0, import_react8.useEffect)(() => {
      const target = trigger === "icon" ? iconRef.current : trigger === "node" ? wrapperRef.current : trigger;
      target == null ? void 0 : target.addEventListener("click", handleClickCollapse);
      return () => {
        target == null ? void 0 : target.removeEventListener("click", handleClickCollapse);
      };
    }, [trigger, isCollapsed2]);
    const computeCallbackStyle = (callableStyle) => {
      return typeof callableStyle === "function" ? callableStyle.call(graph, data) : callableStyle;
    };
    return import_react8.default.createElement(
      StyledWrapper5,
      { ref: wrapperRef, className: "collapsible-node-wrapper" },
      isIconShown && import_react8.default.createElement(StyledIconWrapper, { ref: iconRef, "$placement": computeCallbackStyle(iconPlacement), "$offsetX": computeCallbackStyle(iconOffsetX), "$offsetY": computeCallbackStyle(iconOffsetY), className: iconClassName, style: iconStyle }, iconRender == null ? void 0 : iconRender.call(graph, isCollapsed2, data)),
      NodeComponent.call(graph, data)
    );
  };
};

// node_modules/@ant-design/graphs/es/core/utils/data.js
var getNeighborNodeIds = (nodeId, edges, direction) => {
  const getSuccessorNodeIds = (reverse = false) => {
    const [source, target] = reverse ? ["target", "source"] : ["source", "target"];
    return edges.filter((edge) => edge[source] === nodeId).map((edge) => edge[target]);
  };
  if (direction === "out")
    return getSuccessorNodeIds();
  if (direction === "in")
    return getSuccessorNodeIds(true);
  return getSuccessorNodeIds().concat(getSuccessorNodeIds(true));
};
var EMPTY_GRAPH_DATA = { nodes: [], edges: [] };
function isTreeData(data) {
  if (typeof data !== "object" || data === null)
    return false;
  if (!("id" in data))
    return false;
  if ("children" in data) {
    if (!Array.isArray(data.children))
      return false;
    for (const child of data.children) {
      if (!isTreeData(child))
        return false;
    }
  }
  return true;
}
function isGraphData(data) {
  if (typeof data !== "object" || data === null)
    return false;
  if (!Object.keys(data).every((key) => ["nodes", "edges", "combos"].includes(key))) {
    return false;
  }
  const { nodes = [], edges = [], combos = [] } = data;
  if (!Array.isArray(nodes) || !Array.isArray(edges) || !Array.isArray(combos)) {
    return false;
  }
  const nodeIds = new Set(nodes.map((node) => node.id));
  if (!nodes.every((node) => typeof node === "object" && node !== null && "id" in node)) {
    return false;
  }
  if (!edges.every((edge) => nodeIds.has(edge.source) && nodeIds.has(edge.target))) {
    return false;
  }
  return true;
}
function graphData2TreeData(data) {
  if (!isGraphData(data)) {
    return;
  }
  const { nodes = [], edges = [] } = data;
  const nodeMap = Object.fromEntries(nodes.map((node) => [node.id, node]));
  const indegree = Object.fromEntries(nodes.map((node) => [node.id, 0]));
  const adjList = Object.fromEntries(nodes.map((node) => [node.id, []]));
  for (const { source, target } of edges) {
    adjList[source].push(target);
    indegree[target] = (indegree[target] || 0) + 1;
  }
  const roots = Object.entries(indegree).filter(([_2, deg]) => deg === 0).map(([id]) => id);
  if (roots.length !== 1) {
    return;
  }
  const buildTree = (nodeId) => {
    const node = nodeMap[nodeId];
    return __spreadProps(__spreadValues({}, node), {
      children: adjList[nodeId].map(buildTree)
    });
  };
  return buildTree(roots[0]);
}
function treeData2GraphData(data, defaultExpandLevel) {
  if (!isTreeData(data))
    return EMPTY_GRAPH_DATA;
  return treeToGraphData(data, {
    getNodeData: (datum, depth) => {
      datum.depth = depth;
      datum.style || (datum.style = {});
      if (defaultExpandLevel) {
        datum.style.collapsed = depth >= defaultExpandLevel;
      }
      if (!datum.children)
        return datum;
      const _a = datum, { children } = _a, restDatum = __objRest(_a, ["children"]);
      return __spreadProps(__spreadValues({}, restDatum), { children: children.map((child) => child.id) });
    }
  });
}
function formatTreeData(data, defaultExpandLevel) {
  if (!data)
    return EMPTY_GRAPH_DATA;
  const treeData = isGraphData(data) ? graphData2TreeData(data) : data;
  if (!treeData)
    return EMPTY_GRAPH_DATA;
  return treeData2GraphData(treeData, defaultExpandLevel);
}

// node_modules/@ant-design/graphs/es/core/transform/collapse-expand-react-node.js
var { PlusMinusIcon: PlusMinusIcon2 } = collapse_expand_icon_exports;
var _CollapseExpandReactNode = class _CollapseExpandReactNode extends BaseTransform {
  constructor(context, options) {
    super(context, Object.assign({}, _CollapseExpandReactNode.defaultOptions, options));
  }
  afterLayout() {
    const { graph, element, model } = this.context;
    const { nodes = [], edges = [] } = graph.getData();
    const _a = this.options, { enable } = _a, options = __objRest(_a, ["enable"]);
    nodes.forEach((datum) => {
      const nodeId = idOf(datum);
      if (datum.children && datum.children.length > 0)
        return;
      const children = getNeighborNodeIds(nodeId, edges, this.options.direction);
      if (children.length === 0)
        return;
      model.updateNodeData([{ id: nodeId, children }]);
    });
    const nodeMapper = graph.getOptions().node;
    if ((0, import_lodash3.has)(nodeMapper, "style.component")) {
      const Component = (0, import_lodash3.get)(nodeMapper, "style.component");
      (0, import_lodash3.set)(nodeMapper, "style.component", (data) => {
        if (!(typeof enable === "function" ? enable(data) : enable))
          return Component.call(graph, data);
        const CollapsibleNode = withCollapsibleNode(Component);
        return import_react9.default.createElement(CollapsibleNode, __spreadValues({ data, graph }, options));
      });
    }
    graph.setNode(nodeMapper);
    graph.draw();
  }
};
__publicField(_CollapseExpandReactNode, "defaultOptions", {
  enable: true,
  trigger: "icon",
  direction: "out",
  iconRender: (isCollapsed2) => import_react9.default.createElement(PlusMinusIcon2, { isCollapsed: isCollapsed2 }),
  iconPlacement: "bottom",
  iconOffsetX: 0,
  iconOffsetY: 0,
  iconClassName: "",
  iconStyle: {},
  refreshLayout: false
});
var CollapseExpandReactNode = _CollapseExpandReactNode;

// node_modules/@ant-design/graphs/es/core/utils/scale.js
var linear2 = (value, domain, range) => {
  const [d0, d1] = domain;
  const [r0, r1] = range;
  if (d1 === d0)
    return r0;
  const ratio = (value - d0) / (d1 - d0);
  return r0 + ratio * (r1 - r0);
};
var log2 = (value, domain, range) => {
  const [d0, d1] = domain;
  const [r0, r1] = range;
  const ratio = Math.log(value - d0 + 1) / Math.log(d1 - d0 + 1);
  return r0 + ratio * (r1 - r0);
};
var pow2 = (value, domain, range, exponent = 2) => {
  const [d0, d1] = domain;
  const [r0, r1] = range;
  const ratio = Math.pow((value - d0) / (d1 - d0), exponent);
  return r0 + ratio * (r1 - r0);
};
var sqrt2 = (value, domain, range) => {
  const [d0, d1] = domain;
  const [r0, r1] = range;
  const ratio = Math.sqrt((value - d0) / (d1 - d0));
  return r0 + ratio * (r1 - r0);
};

// node_modules/@ant-design/graphs/es/core/transform/map-edge-line-width.js
var _MapEdgeLineWidth = class _MapEdgeLineWidth extends BaseTransform {
  constructor(context, options) {
    super(context, Object.assign({}, _MapEdgeLineWidth.defaultOptions, options));
    __publicField(this, "assignLineWidthByValue", (value, minValue, maxValue, minLineWidth, maxLineWidth, scale2) => {
      const domain = [minValue, maxValue];
      const range = [minLineWidth, maxLineWidth];
      if (value < minValue || value > maxValue || minValue === maxValue)
        return range[0];
      if (typeof scale2 === "function")
        return scale2(value, domain, range);
      switch (scale2) {
        case "linear":
          return linear2(value, domain, range);
        case "log":
          return log2(value, domain, range);
        case "pow":
          return pow2(value, domain, range, 2);
        case "sqrt":
          return sqrt2(value, domain, range);
        default:
          return range[0];
      }
    });
  }
  beforeDraw(input) {
    const { maxValue, minValue, maxLineWidth, minLineWidth, scale: scale2, value } = this.options;
    const edges = this.context.model.getEdgeData();
    const valueFunc = typeof value === "function" ? value : () => value;
    const values3 = Object.fromEntries(edges.map((edge) => [idOf(edge), valueFunc(edge)]));
    const { add: { edges: edgesToAdd }, update: { edges: edgesToUpdate } } = input;
    [...edgesToAdd.values(), ...edgesToUpdate.values()].forEach((edge) => {
      const lineWidth = this.assignLineWidthByValue(values3[idOf(edge)] || 0, typeof minValue === "function" ? minValue(edge, values3) : minValue, typeof maxValue === "function" ? maxValue(edge, values3) : maxValue, typeof minLineWidth === "function" ? minLineWidth(edge) : minLineWidth, typeof maxLineWidth === "function" ? maxLineWidth(edge) : maxLineWidth, scale2);
      edge.style || (edge.style = {});
      edge.style.lineWidth = lineWidth;
    });
    return input;
  }
};
__publicField(_MapEdgeLineWidth, "defaultOptions", {
  minValue: (edge, edges) => Math.min(...Object.values(edges)),
  maxValue: (edge, edges) => Math.max(...Object.values(edges)),
  minLineWidth: 1,
  maxLineWidth: 10,
  scale: "linear"
});
var MapEdgeLineWidth = _MapEdgeLineWidth;

// node_modules/@ant-design/graphs/es/core/transform/translate-react-node-origin.js
var TranslateReactNodeOrigin = class extends BaseTransform {
  beforeDraw(input) {
    const { graph, element } = this.context;
    const { add: { nodes: nodesToAdd }, update: { nodes: nodesToUpdate } } = input;
    [...nodesToAdd.values(), ...nodesToUpdate.values()].forEach((datum) => {
      element.computeElementDefaultStyle("node", { graph, datum });
      const style = element.getDefaultStyle(datum.id);
      const [width2, height] = parseSize(style.size);
      if (!datum.style)
        datum.style = {};
      datum.style.dx = -width2 / 2;
      datum.style.dy = -height / 2;
    });
    return input;
  }
};

// node_modules/@ant-design/graphs/es/core/registry/build-in.js
var BUILT_IN_EXTENSIONS2 = {
  node: {
    react: ReactNode
  },
  edge: {
    indented: IndentedEdge
  },
  behavior: {
    "hover-activate-neighbors": HoverActivateNeighbors,
    "hover-activate-chain": HoverActivateChain
  },
  transform: {
    "translate-react-node-origin": TranslateReactNodeOrigin,
    "collapse-expand-react-node": CollapseExpandReactNode,
    "assign-color-by-branch": AssignColorByBranch,
    "map-edge-line-width": MapEdgeLineWidth,
    "arrange-edge-z-index": ArrangeEdgeZIndex
  }
};

// node_modules/@ant-design/graphs/es/core/registry/register.js
function registerBuiltInExtensions2() {
  Object.entries(BUILT_IN_EXTENSIONS2).forEach(([category, extensions]) => {
    Object.entries(extensions).forEach(([type, extension]) => {
      register(category, type, extension);
    });
  });
}

// node_modules/@ant-design/graphs/es/preset.js
registerBuiltInExtensions2();

// node_modules/@ant-design/graphs/es/components/dendrogram/index.js
var import_react14 = __toESM(require_react());

// node_modules/@antv/graphin/es/context/index.js
var import_react10 = __toESM(require_react());
var GraphinContext = import_react10.default.createContext({
  graph: null,
  isReady: false
});

// node_modules/@antv/graphin/es/Graphin.js
var import_react12 = __toESM(require_react());

// node_modules/@antv/graphin/es/hooks/useGraph.js
var import_react11 = __toESM(require_react());
var __assign3 = function() {
  __assign3 = Object.assign || function(t3) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3))
        t3[p3] = s2[p3];
    }
    return t3;
  };
  return __assign3.apply(this, arguments);
};
var __read = function(o3, n2) {
  var m2 = typeof Symbol === "function" && o3[Symbol.iterator];
  if (!m2) return o3;
  var i2 = m2.call(o3), r3, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i2.next()).done) ar.push(r3.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
function useGraph(props) {
  var onInit = props.onInit, onReady = props.onReady, onDestroy = props.onDestroy, options = props.options;
  var _a = __read((0, import_react11.useState)(false), 2), isReady = _a[0], setIsReady = _a[1];
  var graphRef = (0, import_react11.useRef)(null);
  var containerRef = (0, import_react11.useRef)(null);
  (0, import_react11.useEffect)(function() {
    if (graphRef.current || !containerRef.current)
      return;
    var graph = new Graph3(__assign3({ container: containerRef.current }, options));
    graphRef.current = graph;
    setIsReady(true);
    onInit === null || onInit === void 0 ? void 0 : onInit(graphRef.current);
    return function() {
      var graph2 = graphRef.current;
      if (graph2) {
        graph2.destroy();
        onDestroy === null || onDestroy === void 0 ? void 0 : onDestroy();
        graphRef.current = null;
      }
    };
  }, []);
  (0, import_react11.useEffect)(function() {
    var container = containerRef.current;
    var graph = graphRef.current;
    if (!options || !container || !graph || graph.destroyed)
      return;
    graph.setOptions(options);
    graph.render().then(function() {
      return onReady === null || onReady === void 0 ? void 0 : onReady(graph);
    });
  }, [options]);
  return {
    graph: graphRef.current,
    containerRef,
    isReady
  };
}

// node_modules/@antv/graphin/es/Graphin.js
var __assign4 = function() {
  __assign4 = Object.assign || function(t3) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3))
        t3[p3] = s2[p3];
    }
    return t3;
  };
  return __assign4.apply(this, arguments);
};
var __rest25 = function(s2, e2) {
  var t3 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t3[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t3[p3[i2]] = s2[p3[i2]];
    }
  return t3;
};
var Graph4 = (0, import_react12.forwardRef)(function(props, ref) {
  var style = props.style, children = props.children, restProps = __rest25(props, ["style", "children"]);
  var _a = useGraph(restProps), graph = _a.graph, containerRef = _a.containerRef, isReady = _a.isReady;
  (0, import_react12.useImperativeHandle)(ref, function() {
    return graph;
  }, [graph]);
  var containerStyle = __assign4({ height: "inherit", position: "relative" }, style);
  if (children) {
    return import_react12.default.createElement(
      GraphinContext.Provider,
      { value: { graph, isReady } },
      import_react12.default.createElement("div", { ref: containerRef, style: containerStyle }, isReady && children)
    );
  }
  return import_react12.default.createElement("div", { ref: containerRef, style: containerStyle });
});
var Graphin = (0, import_react12.memo)(Graph4);

// node_modules/@ant-design/graphs/es/core/base-graph.js
var import_lodash4 = __toESM(require_lodash());
var import_react13 = __toESM(require_react());
var BaseGraph = (0, import_react13.forwardRef)((_a, ref) => {
  var _b = _a, { children } = _b, props = __objRest(_b, ["children"]);
  const _a2 = props, { containerStyle, className, onInit, onReady, onDestroy, errorTemplate, loading, loadingTemplate } = _a2, options = __objRest(_a2, ["containerStyle", "className", "onInit", "onReady", "onDestroy", "errorTemplate", "loading", "loadingTemplate"]);
  const graphRef = (0, import_react13.useRef)(null);
  (0, import_react13.useImperativeHandle)(ref, () => graphRef.current);
  return import_react13.default.createElement(
    ErrorBoundary,
    { errorTemplate },
    loading && import_react13.default.createElement(ChartLoading, { loadingTemplate }),
    !(0, import_lodash4.isEmpty)(options.data) && import_react13.default.createElement(Graphin, { ref: (ref2) => {
      graphRef.current = ref2;
    }, className, style: containerStyle, options, onInit, onReady, onDestroy }, children)
  );
});

// node_modules/@ant-design/graphs/es/core/constants/options.js
var COMMON_OPTIONS = {
  autoResize: true,
  behaviors: [
    {
      key: "zoom-canvas",
      type: "zoom-canvas"
    },
    {
      key: "drag-canvas",
      type: "drag-canvas"
    }
  ]
};

// node_modules/@ant-design/graphs/es/core/utils/options.js
var import_lodash5 = __toESM(require_lodash());
function mergeOptions2(...options) {
  if (options.length === 0)
    return {};
  const merged = __spreadValues({}, options[0]);
  for (let i2 = 1; i2 < options.length; i2++) {
    const currentOptions = options[i2];
    for (const key in currentOptions) {
      if (currentOptions.hasOwnProperty(key)) {
        const currValue = currentOptions[key];
        const prevValue = merged[key];
        if (["component", "data"].includes(key)) {
          merged[key] = currValue;
        } else if (typeof currValue === "function") {
          if (["plugins", "behaviors", "transforms"].includes(key)) {
            merged[key] = currValue(prevValue || []);
          } else {
            merged[key] = function(datum) {
              const value = currValue.call(this, datum);
              if ((0, import_lodash5.isPlainObject)(value))
                return mergeOptions2(prevValue, value);
              return value;
            };
          }
        } else if ((0, import_lodash5.isPlainObject)(currValue) && (0, import_lodash5.isPlainObject)(prevValue)) {
          merged[key] = mergeOptions2(prevValue, currValue);
        } else {
          merged[key] = currValue;
        }
      }
    }
  }
  return merged;
}

// node_modules/@ant-design/graphs/es/components/dendrogram/options.js
var import_lodash6 = __toESM(require_lodash());
var DEFAULT_OPTIONS = {
  node: {
    type: "circle",
    style: {
      labelText: (d3) => d3.id
    }
  }
};
var getDendrogramOptions = ({ direction, compact }) => {
  const isLeafNode = (d3) => (0, import_lodash6.isEmpty)(d3.children);
  const layoutType = compact ? "compact-box" : "dendrogram";
  if (direction === "vertical") {
    return {
      node: {
        style: {
          labelBackground: true,
          labelPlacement: "right",
          labelTransform: (d3) => isLeafNode(d3) ? "rotate(90deg) translate(18px)" : "translate(18px)",
          ports: [{ placement: "top" }, { placement: "bottom" }]
        }
      },
      edge: { type: "cubic-vertical" },
      layout: { type: layoutType, direction: "TB", nodeSep: 40, rankSep: 140, getVGap: () => 80, getHGap: () => 20 }
    };
  } else if (direction === "horizontal") {
    return {
      node: {
        style: {
          labelBackground: true,
          labelPlacement: (d3) => isLeafNode(d3) ? "right" : "left",
          ports: [{ placement: "left" }, { placement: "right" }]
        }
      },
      edge: { type: "cubic-horizontal" },
      layout: { type: layoutType, direction: "LR", nodeSep: 40, rankSep: 200, getVGap: () => 5, getHGap: () => 100 }
    };
  } else {
    return {
      node: { style: { labelBackground: true } },
      edge: { type: "cubic-radial" },
      layout: {
        type: layoutType,
        direction: "RL",
        radial: true,
        nodeSep: 40,
        rankSep: 200,
        getVGap: () => 30,
        getHGap: () => 60
      },
      transforms: (prev) => [...prev, "place-radial-labels"]
    };
  }
};

// node_modules/@ant-design/graphs/es/components/dendrogram/index.js
var Dendrogram = (0, import_react14.forwardRef)((_a, ref) => {
  var _b = _a, { children } = _b, props = __objRest(_b, ["children"]);
  const options = (0, import_react14.useMemo)(() => {
    const _a2 = props, { data, defaultExpandLevel, direction = "horizontal", compact = false } = _a2, restProps = __objRest(_a2, ["data", "defaultExpandLevel", "direction", "compact"]);
    return mergeOptions2(COMMON_OPTIONS, DEFAULT_OPTIONS, { data: formatTreeData(data, defaultExpandLevel) }, getDendrogramOptions({ direction, compact }), restProps);
  }, [props]);
  return import_react14.default.createElement(BaseGraph, __spreadProps(__spreadValues({}, options), { ref }), children);
});

// node_modules/@ant-design/graphs/es/components/fishbone/index.js
var import_react15 = __toESM(require_react());

// node_modules/@ant-design/graphs/es/components/fishbone/options.js
var import_lodash8 = __toESM(require_lodash());

// node_modules/@ant-design/graphs/es/core/utils/label.js
var import_lodash7 = __toESM(require_lodash());
function formatLabel(datum, labelField) {
  const label = labelField ? typeof labelField === "function" ? labelField(datum) : (0, import_lodash7.get)(datum, `data.${labelField}`, datum.id) : datum.id;
  return String(label);
}

// node_modules/@ant-design/graphs/es/core/utils/measure-text.js
function measureTextSize(text, offset = [0, 0], font = { fontSize: 16, fontFamily: "PingFang SC" }, minWidth = 0, maxWith = Infinity) {
  const height = measureTextHeight(text, font);
  const width2 = measureTextWidth(text, font) + 4;
  const lineNumber = maxWith === Infinity ? 1 : Math.ceil(width2 / maxWith);
  const [offsetWidth, offsetHeight] = offset;
  return [
    Math.max(minWidth, Math.min(maxWith, width2)) + offsetWidth,
    offsetHeight + height + height * 1.5 * (lineNumber - 1)
  ];
}

// node_modules/@ant-design/graphs/es/components/fishbone/options.js
var DEFAULT_OPTIONS2 = {
  node: {
    style: {
      size: 10,
      labelPlacement: "center"
    }
  },
  edge: {
    type: "polyline"
  },
  layout: {
    type: "fishbone",
    hGap: 40,
    vGap: 60
  },
  animation: false
};
var FONT_FAMILY = "system-ui, sans-serif";
var getNodeSize = (id, depth) => {
  if (depth === 0)
    return measureTextSize(id, [80, 48], { fontSize: 24, fontWeight: 600, fontFamily: FONT_FAMILY });
  if (depth === 1)
    return measureTextSize(id, [80, 30], { fontSize: 18, fontFamily: FONT_FAMILY });
  return [2, 30];
};
var getNodeFill = (node) => {
  var _a;
  const depth = node.depth;
  if (depth === 0)
    return "#EFF0F0";
  if (depth === 1)
    return ((_a = node.style) == null ? void 0 : _a.color) || "#EFF0F0";
  return "transparent";
};
function getFishboneOptions({ type, labelField }) {
  const options = {
    node: {
      type: "rect",
      style: {
        fill: (d3) => getNodeFill(d3),
        labelFill: (d3) => d3.depth === 1 ? "#fff" : "#262626",
        labelFillOpacity: 1,
        labelFontSize: (d3) => d3.depth === 0 ? 24 : d3.depth === 1 ? 18 : 16,
        labelFontWeight: (d3) => d3.depth === 0 ? 600 : 400,
        labelLineHeight: (d3) => d3.depth === 0 ? 26 : d3.depth === 1 ? 20 : 18,
        labelText: (d3) => formatLabel(d3, labelField),
        radius: 8,
        size: (d3) => getNodeSize(d3.id, d3.depth)
      }
    },
    edge: {
      type: "polyline",
      style: {
        lineWidth: 3,
        stroke: function(data) {
          const target = this.getNodeData(data.target);
          return (0, import_lodash8.get)(target, "style.color", "#99ADD1");
        }
      }
    },
    transforms: (prev) => [
      ...prev,
      {
        type: "assign-color-by-branch",
        key: "assign-color-by-branch"
      },
      {
        type: "arrange-edge-z-index",
        key: "arrange-edge-z-index"
      }
    ]
  };
  options.layout || (options.layout = {});
  if (type === "decision") {
    options.node.style.labelPlacement = (d3) => d3.depth === 0 || d3.depth === 1 ? "center" : "right";
    Object.assign(options.layout, { direction: "LR" });
  } else if (type === "cause") {
    options.node.style.labelPlacement = (d3) => d3.depth === 0 || d3.depth === 1 ? "center" : "left";
    Object.assign(options.layout, { direction: "RL" });
  }
  return options;
}

// node_modules/@ant-design/graphs/es/components/fishbone/index.js
var Fishbone = (0, import_react15.forwardRef)((_a, ref) => {
  var _b = _a, { children } = _b, props = __objRest(_b, ["children"]);
  const _a2 = props, { data, defaultExpandLevel, type = "cause", labelField } = _a2, restProps = __objRest(_a2, ["data", "defaultExpandLevel", "type", "labelField"]);
  const options = (0, import_react15.useMemo)(() => mergeOptions2(COMMON_OPTIONS, DEFAULT_OPTIONS2, { data: formatTreeData(data) }, getFishboneOptions({ type, labelField }), restProps), [props]);
  return import_react15.default.createElement(BaseGraph, __spreadProps(__spreadValues({}, options), { ref }), children);
});

// node_modules/@ant-design/graphs/es/components/flow-direction-graph/index.js
var import_react17 = __toESM(require_react());

// node_modules/@ant-design/graphs/es/components/flow-direction-graph/options.js
var import_react16 = __toESM(require_react());
var { TextNode: TextNode2 } = node_exports;
var DEFAULT_OPTIONS3 = {
  node: {
    type: "react",
    state: {
      active: {
        halo: false
      },
      selected: {
        halo: false
      }
    }
  },
  edge: {
    type: "cubic-horizontal",
    style: {
      strokeOpacity: 0.5
    },
    state: {
      active: {
        strokeOpacity: 1
      }
    }
  },
  layout: {
    type: "dagre",
    rankdir: "LR",
    animation: false
  },
  transforms: ["translate-react-node-origin"]
};
var getFlowDirectionGraphOptions = ({ labelField }) => {
  const options = {
    node: {
      style: {
        component: (data) => {
          const label = formatLabel(data, labelField);
          return import_react16.default.createElement(TextNode2, { type: "filled", text: label });
        },
        size: [100, 40],
        ports: [{ placement: "left" }, { placement: "right" }]
      }
    }
  };
  return options;
};

// node_modules/@ant-design/graphs/es/components/flow-direction-graph/index.js
var FlowDirectionGraph = (0, import_react17.forwardRef)((_a, ref) => {
  var _b = _a, { children } = _b, props = __objRest(_b, ["children"]);
  const _a2 = props, { labelField } = _a2, restProps = __objRest(_a2, ["labelField"]);
  const options = (0, import_react17.useMemo)(() => mergeOptions2(COMMON_OPTIONS, DEFAULT_OPTIONS3, getFlowDirectionGraphOptions({ labelField }), restProps), [props]);
  return import_react17.default.createElement(BaseGraph, __spreadProps(__spreadValues({}, options), { ref }), children);
});

// node_modules/@ant-design/graphs/es/components/flow-graph/index.js
var import_react19 = __toESM(require_react());

// node_modules/@ant-design/graphs/es/components/flow-graph/options.js
var import_react18 = __toESM(require_react());
var { TextNode: TextNode3 } = node_exports;
var DEFAULT_OPTIONS4 = {
  node: {
    type: "react",
    state: {
      active: {
        halo: false
      },
      selected: {
        halo: false
      }
    }
  },
  edge: {
    type: "polyline",
    style: {
      lineWidth: 2,
      endArrow: true,
      radius: 8,
      router: {
        type: "orth"
      }
    }
  },
  layout: {
    type: "dagre",
    animation: false
  },
  transforms: ["translate-react-node-origin"]
};
var getFlowGraphOptions = ({ direction, labelField }) => {
  const options = {
    node: {
      style: {
        component: (data) => {
          const label = formatLabel(data, labelField);
          return import_react18.default.createElement(TextNode3, { type: "filled", text: label });
        },
        size: [100, 40],
        ports: direction === "vertical" ? [{ placement: "top" }, { placement: "bottom" }] : [{ placement: "left" }, { placement: "right" }]
      }
    },
    layout: {
      type: "dagre",
      rankdir: direction === "vertical" ? "TB" : "LR"
    }
  };
  return options;
};

// node_modules/@ant-design/graphs/es/components/flow-graph/index.js
var FlowGraph = (0, import_react19.forwardRef)((_a, ref) => {
  var _b = _a, { children } = _b, props = __objRest(_b, ["children"]);
  const options = (0, import_react19.useMemo)(() => {
    const _a2 = props, { direction = "horizontal", labelField } = _a2, restProps = __objRest(_a2, ["direction", "labelField"]);
    return mergeOptions2(COMMON_OPTIONS, DEFAULT_OPTIONS4, getFlowGraphOptions({ direction, labelField }), restProps);
  }, [props]);
  return import_react19.default.createElement(BaseGraph, __spreadProps(__spreadValues({}, options), { ref }), children);
});

// node_modules/@ant-design/graphs/es/components/indented-tree/index.js
var import_react21 = __toESM(require_react());

// node_modules/@ant-design/graphs/es/components/indented-tree/options.js
var import_lodash11 = __toESM(require_lodash());
var import_react20 = __toESM(require_react());

// node_modules/@ant-design/graphs/es/core/utils/node.js
var import_lodash9 = __toESM(require_lodash());
var getRelativeSide = (0, import_lodash9.memoize)((nodeData, refNodeData) => {
  if (!refNodeData)
    return "center";
  const nodePositionX = positionOf(nodeData)[0];
  const refNodePositionX = positionOf(refNodeData)[0];
  return refNodePositionX > nodePositionX ? "left" : "right";
}, (nodeData, refNodeData) => refNodeData ? [positionOf(nodeData), positionOf(refNodeData)].flat().join("-") : "center");
var getNodeSide = (graph, data) => {
  const parentData = graph.getParentData(idOf(data), "tree");
  return getRelativeSide(data, parentData);
};

// node_modules/@ant-design/graphs/es/core/utils/tree.js
var import_lodash10 = __toESM(require_lodash());
var getLinearTextNodeStyle = (0, import_lodash10.memoize)((text, minWidth, maxWidth, depth = 0) => {
  const font = {
    fontWeight: depth === 0 ? 600 : 400,
    fontSize: depth === 0 ? 24 : 16
  };
  const offset = depth === 0 ? [64, 30] : [12, 12];
  const size2 = measureTextSize(text, offset, font, minWidth, maxWidth);
  return { font, size: size2 };
});
var getBoxedTextNodeStyle = (0, import_lodash10.memoize)((text, minWidth, maxWidth, depth = 0) => {
  const font = {
    fontWeight: depth === 0 || depth === 1 ? 600 : 400,
    fontSize: depth === 0 ? 24 : 16
  };
  const offset = depth === 0 ? [64, 30] : [36, 24];
  const size2 = measureTextSize(text, offset, font, minWidth, maxWidth);
  return { font, size: size2 };
});

// node_modules/@ant-design/graphs/es/components/indented-tree/options.js
var { ArrowCountIcon: ArrowCountIcon2 } = collapse_expand_icon_exports;
var { TextNode: TextNode4 } = node_exports;
var DEFAULT_OPTIONS5 = {
  node: {
    type: "react",
    state: {
      active: {
        halo: false
      },
      selected: {
        halo: false
      }
    }
  },
  edge: {
    type: "indented",
    style: {
      lineWidth: 3
    }
  },
  transforms: (prev) => [
    ...prev,
    {
      type: "collapse-expand-react-node",
      key: "collapse-expand-react-node",
      enable: false,
      trigger: "icon",
      iconRender: function(isCollapsed2, data) {
        return import_react20.default.createElement(ArrowCountIcon2, { graph: this, data, isCollapsed: isCollapsed2 });
      }
    }
  ],
  layout: {
    type: "indented",
    direction: "LR",
    indent: (node) => getIndent(node, 20),
    getVGap: () => 14,
    preLayout: false
  },
  animation: {
    duration: 500
  }
};
var getIndent = (node, preset) => {
  if (node.depth === 0)
    return 0;
  let totalWidth = preset;
  let currentNode = node.parent;
  while (currentNode) {
    totalWidth += currentNode.width / 2;
    currentNode = currentNode.parent;
  }
  return totalWidth / node.depth;
};
var getNodeTextAlign = (graph, data) => {
  const side = getNodeSide(graph, data);
  return side === "left" ? "right" : side === "center" ? "center" : "left";
};
var getIndentedTreeOptions = ({ type, nodeMinWidth, nodeMaxWidth, direction, labelField }) => {
  let options = {};
  const minWidth = nodeMinWidth || 0;
  const maxWidth = nodeMaxWidth || 300;
  if (type === "boxed") {
    options = {
      node: {
        style: {
          component: function(data) {
            var _a;
            const depth = data.depth;
            const color = (_a = data.style) == null ? void 0 : _a.color;
            const label = formatLabel(data, labelField);
            const { font } = getBoxedTextNodeStyle(label, minWidth, maxWidth, depth);
            const props = {
              type: depth === 0 || depth === 1 ? "filled" : "outlined",
              text: label,
              color: depth === 0 ? "#f1f4f5" : color,
              maxWidth,
              font,
              style: __spreadValues({
                textAlign: getNodeTextAlign(this, data)
              }, depth === 0 ? { color: "#252525" } : {})
            };
            return import_react20.default.createElement(TextNode4, __spreadValues({}, props));
          },
          size: (data) => {
            const label = formatLabel(data, labelField);
            return getBoxedTextNodeStyle(label, minWidth, maxWidth, data.depth).size;
          }
        }
      },
      edge: {
        style: {
          stroke: function(data) {
            const source = this.getNodeData(data.source);
            return (0, import_lodash11.get)(source, "style.color", "#99ADD1");
          },
          radius: 16
        }
      },
      transforms: (prev) => [
        ...prev,
        {
          type: "assign-color-by-branch",
          key: "assign-color-by-branch"
        }
      ],
      layout: {
        type: "indented",
        getWidth: (data) => {
          const label = formatLabel(data, labelField);
          const [width2] = getBoxedTextNodeStyle(label, minWidth, maxWidth, data.depth).size;
          return width2;
        },
        getHeight: (data) => {
          const label = formatLabel(data, labelField);
          const [, height] = getBoxedTextNodeStyle(label, minWidth, maxWidth, data.depth).size;
          return height;
        }
      }
    };
  } else if (type === "linear") {
    options = {
      node: {
        style: {
          component: function(data) {
            var _a;
            const depth = data.depth;
            const color = (_a = data.style) == null ? void 0 : _a.color;
            const label = formatLabel(data, labelField);
            const { font } = getLinearTextNodeStyle(label, minWidth, maxWidth, depth);
            const props = { text: label, color, maxWidth, font };
            Object.assign(props, depth === 0 ? { type: "filled", color: "#f1f4f5", style: { color: "#252525" } } : {
              type: "underlined",
              style: { textAlign: getNodeTextAlign(this, data) }
            });
            return import_react20.default.createElement(TextNode4, __spreadValues({}, props));
          },
          size: (data) => {
            const label = formatLabel(data, labelField);
            return getLinearTextNodeStyle(label, minWidth, maxWidth, data.depth).size;
          },
          ports: function(data) {
            const side = getNodeSide(this, data);
            return side === "left" ? [{ placement: "bottom" }, { placement: "bottom-right" }] : side === "center" ? [{ placement: "bottom" }] : [{ placement: "bottom" }, { placement: "bottom-left" }];
          }
        }
      },
      edge: {
        style: {
          stroke: function(data) {
            const target = this.getNodeData(data.target);
            return (0, import_lodash11.get)(target, "style.color", "#99ADD1");
          },
          radius: 24
        }
      },
      layout: {
        type: "indented",
        getWidth: (data) => {
          const label = formatLabel(data, labelField);
          const [width2] = getLinearTextNodeStyle(label, minWidth, maxWidth, data.depth).size;
          return width2;
        },
        getHeight: (data) => {
          const label = formatLabel(data, labelField);
          const [, height] = getLinearTextNodeStyle(label, minWidth, maxWidth, data.depth).size;
          return height;
        },
        getVGap: () => 12
      },
      transforms: (prev) => [
        ...prev,
        {
          type: "assign-color-by-branch",
          key: "assign-color-by-branch"
        },
        {
          type: "arrange-edge-z-index",
          key: "arrange-edge-z-index"
        }
      ]
    };
  } else {
    const PADDING = [24, 16];
    options = {
      node: {
        style: {
          component: (data) => {
            const label = formatLabel(data, labelField);
            return import_react20.default.createElement(TextNode4, { type: "filled", text: label });
          },
          size: (data) => {
            const label = formatLabel(data, labelField);
            return measureTextSize(label, PADDING);
          }
        }
      },
      layout: {
        type: "indented",
        getWidth: (data) => {
          const label = formatLabel(data, labelField);
          const [width2] = measureTextSize(label, PADDING);
          return width2;
        },
        getHeight: (data) => {
          const label = formatLabel(data, labelField);
          const [, height] = measureTextSize(label, PADDING);
          return height;
        }
      }
    };
  }
  if (direction) {
    options.layout || (options.layout = {});
    Object.assign(options.layout, {
      direction: direction === "alternate" ? "H" : direction === "left" ? "RL" : "LR"
    });
  }
  return options;
};

// node_modules/@ant-design/graphs/es/components/indented-tree/index.js
var IndentedTree = (0, import_react21.forwardRef)((_a, ref) => {
  var _b = _a, { children } = _b, props = __objRest(_b, ["children"]);
  const _a2 = props, { data, defaultExpandLevel, type = "default", nodeMinWidth, nodeMaxWidth, direction = "right", labelField } = _a2, restProps = __objRest(_a2, ["data", "defaultExpandLevel", "type", "nodeMinWidth", "nodeMaxWidth", "direction", "labelField"]);
  const options = (0, import_react21.useMemo)(() => mergeOptions2(COMMON_OPTIONS, DEFAULT_OPTIONS5, { data: formatTreeData(data, defaultExpandLevel) }, getIndentedTreeOptions({ type, nodeMinWidth, nodeMaxWidth, direction, labelField }), restProps), [props]);
  return import_react21.default.createElement(BaseGraph, __spreadProps(__spreadValues({}, options), { ref }), children);
});

// node_modules/@ant-design/graphs/es/components/mind-map/index.js
var import_react23 = __toESM(require_react());

// node_modules/@ant-design/graphs/es/components/mind-map/options.js
var import_lodash12 = __toESM(require_lodash());
var import_react22 = __toESM(require_react());
var { ArrowCountIcon: ArrowCountIcon3 } = collapse_expand_icon_exports;
var { TextNode: TextNode5 } = node_exports;
var DEFAULT_OPTIONS6 = {
  node: {
    type: "react",
    state: {
      active: {
        halo: false
      },
      selected: {
        halo: false
      }
    }
  },
  edge: {
    type: "cubic-horizontal",
    style: {
      lineWidth: 3
    }
  },
  transforms: (prev) => [
    ...prev,
    {
      type: "collapse-expand-react-node",
      key: "collapse-expand-react-node",
      enable: false,
      trigger: "icon",
      iconRender: function(isCollapsed2, data) {
        const side = getNodeSide(this, data);
        return import_react22.default.createElement(ArrowCountIcon3, { graph: this, data, isCollapsed: isCollapsed2, placement: side === "left" ? "left" : "right" });
      },
      iconPlacement: function(data) {
        const side = getNodeSide(this, data);
        return side === "left" ? "left" : "right";
      }
    }
  ],
  layout: {
    type: "mindmap",
    direction: "H",
    preLayout: false,
    getWidth: () => 120,
    getHGap: () => 64
  },
  animation: {
    duration: 500
  }
};
function getMindMapOptions({ type, direction, nodeMinWidth, nodeMaxWidth, labelField }) {
  let options = {};
  if (type === "boxed") {
    const minWidth = nodeMinWidth || 120;
    const maxWidth = nodeMaxWidth || 300;
    options = {
      node: {
        style: {
          component: (data) => {
            var _a;
            const depth = data.depth;
            const color = (_a = data.style) == null ? void 0 : _a.color;
            const label = formatLabel(data, labelField);
            const { font } = getBoxedTextNodeStyle(label, minWidth, maxWidth, depth);
            const props = { text: label, color, maxWidth, font };
            Object.assign(props, depth === 0 ? { type: "filled", color: "#f1f4f5", style: { color: "#252525" } } : depth === 1 ? { type: "filled" } : { type: "outlined" });
            return import_react22.default.createElement(TextNode5, __spreadValues({}, props));
          },
          size: (data) => {
            const label = formatLabel(data, labelField);
            return getBoxedTextNodeStyle(label, minWidth, maxWidth, data.depth).size;
          },
          dx: function(data) {
            const side = getNodeSide(this, data);
            const label = formatLabel(data, labelField);
            const [width2] = getBoxedTextNodeStyle(label, minWidth, maxWidth, data.depth).size;
            return side === "left" ? -width2 : side === "center" ? -width2 / 2 : 0;
          },
          ports: [{ placement: "left" }, { placement: "right" }]
        }
      },
      edge: {
        style: {
          stroke: function(data) {
            const source = this.getNodeData(data.source);
            return (0, import_lodash12.get)(source, "style.color", "#99ADD1");
          }
        }
      },
      transforms: (prev) => [...prev, { type: "assign-color-by-branch", key: "assign-color-by-branch" }],
      layout: {
        type: "mindmap",
        getHeight: (data) => {
          const label = formatLabel(data, labelField);
          const [, height] = getBoxedTextNodeStyle(label, minWidth, maxWidth, data.depth).size;
          return height;
        },
        getVGap: () => 14
      }
    };
  } else if (type === "linear") {
    const minWidth = nodeMinWidth || 0;
    const maxWidth = nodeMaxWidth || 300;
    options = {
      node: {
        style: {
          component: function(data) {
            var _a;
            const side = getNodeSide(this, data);
            const depth = data.depth;
            const color = (_a = data.style) == null ? void 0 : _a.color;
            const label = formatLabel(data, labelField);
            const { font } = getLinearTextNodeStyle(label, minWidth, maxWidth, depth);
            const props = { text: label, color, maxWidth, font };
            Object.assign(props, depth === 0 ? { type: "filled", color: "#f1f4f5", style: { color: "#252525" } } : {
              type: "underlined",
              style: side === "left" ? { textAlign: "right" } : side === "center" ? { textAlign: "center" } : {}
            });
            return import_react22.default.createElement(TextNode5, __spreadValues({}, props));
          },
          size: (data) => {
            const label = formatLabel(data, labelField);
            return getLinearTextNodeStyle(label, minWidth, maxWidth, data.depth).size;
          },
          dx: function(data) {
            const side = getNodeSide(this, data);
            const label = formatLabel(data, labelField);
            const [width2] = getLinearTextNodeStyle(label, minWidth, maxWidth, data.depth).size;
            return side === "left" ? -width2 : side === "center" ? -width2 / 2 : 0;
          },
          dy: function(data) {
            const label = formatLabel(data, labelField);
            const [, height] = getLinearTextNodeStyle(label, minWidth, maxWidth, data.depth).size;
            return height / 2;
          },
          ports: function(data) {
            const side = getNodeSide(this, data);
            return side === "center" ? [{ placement: "left" }, { placement: "right" }] : [{ placement: "left-bottom" }, { placement: "right-bottom" }];
          }
        }
      },
      edge: {
        style: {
          stroke: function(data) {
            const target = this.getNodeData(data.target);
            return (0, import_lodash12.get)(target, "style.color", "#99ADD1");
          }
        }
      },
      layout: {
        type: "mindmap",
        getHeight: (data) => {
          const label = formatLabel(data, labelField);
          const [, height] = getLinearTextNodeStyle(label, minWidth, maxWidth, data.depth).size;
          return height;
        },
        getVGap: () => 12
      },
      transforms: (prev) => [
        ...prev.filter((t3) => t3.key !== "collapse-expand-react-node"),
        {
          type: "assign-color-by-branch",
          key: "assign-color-by-branch"
        },
        __spreadProps(__spreadValues({}, prev.find((t3) => t3.key === "collapse-expand-react-node")), {
          iconOffsetY: (data) => {
            if (data.depth === 0)
              return 0;
            const label = formatLabel(data, labelField);
            const [, height] = getLinearTextNodeStyle(label, minWidth, maxWidth, data.depth).size;
            return height / 2;
          }
        })
      ]
    };
  } else {
    const PADDING = [24, 16];
    options = {
      node: {
        style: {
          component: (data) => {
            const label = formatLabel(data, labelField);
            return import_react22.default.createElement(TextNode5, { type: "filled", text: label });
          },
          size: (data) => {
            const label = formatLabel(data, labelField);
            return measureTextSize(label, PADDING);
          },
          dx: function(data) {
            const side = getNodeSide(this, data);
            const label = formatLabel(data, labelField);
            const [width2] = measureTextSize(label, PADDING);
            return side === "left" ? -width2 : side === "center" ? -width2 / 2 : 0;
          },
          ports: [{ placement: "left" }, { placement: "right" }]
        }
      },
      layout: {
        type: "mindmap",
        getHeight: (data) => {
          const label = formatLabel(data, labelField);
          const [, height] = measureTextSize(label, PADDING);
          return height;
        }
      }
    };
  }
  if (direction) {
    options.layout || (options.layout = {});
    options.layout.direction = direction === "alternate" ? "H" : direction === "left" ? "RL" : "LR";
  }
  return options;
}

// node_modules/@ant-design/graphs/es/components/mind-map/index.js
var MindMap = (0, import_react23.forwardRef)((_a, ref) => {
  var _b = _a, { children } = _b, props = __objRest(_b, ["children"]);
  const options = (0, import_react23.useMemo)(() => {
    const _a2 = props, { data, type = "default", nodeMinWidth, nodeMaxWidth, direction = "alternate", labelField, defaultExpandLevel } = _a2, restProps = __objRest(_a2, ["data", "type", "nodeMinWidth", "nodeMaxWidth", "direction", "labelField", "defaultExpandLevel"]);
    const options2 = mergeOptions2(COMMON_OPTIONS, DEFAULT_OPTIONS6, { data: formatTreeData(data, defaultExpandLevel) }, getMindMapOptions({ type, nodeMinWidth, nodeMaxWidth, direction, labelField }), restProps);
    return options2;
  }, [props]);
  return import_react23.default.createElement(BaseGraph, __spreadProps(__spreadValues({}, options), { ref }), children);
});

// node_modules/@ant-design/graphs/es/components/network-graph/index.js
var import_react24 = __toESM(require_react());

// node_modules/@ant-design/graphs/es/components/network-graph/options.js
var SIZE = 32;
var DEFAULT_OPTIONS7 = {
  node: {
    type: "circle"
  },
  layout: {
    type: "d3-force",
    link: {
      distance: SIZE * 4
    },
    collide: {
      radius: SIZE
    },
    manyBody: {
      strength: -SIZE * 22
    },
    x: {},
    y: {}
  }
};

// node_modules/@ant-design/graphs/es/components/network-graph/index.js
var NetworkGraph = (0, import_react24.forwardRef)((_a, ref) => {
  var _b = _a, { children } = _b, props = __objRest(_b, ["children"]);
  const options = (0, import_react24.useMemo)(() => mergeOptions2(COMMON_OPTIONS, DEFAULT_OPTIONS7, props), [props]);
  return import_react24.default.createElement(BaseGraph, __spreadProps(__spreadValues({}, options), { ref }), children);
});

// node_modules/@ant-design/graphs/es/components/organization-chart/index.js
var import_react26 = __toESM(require_react());

// node_modules/@ant-design/graphs/es/components/organization-chart/options.js
var import_react25 = __toESM(require_react());
var { TextNode: TextNode6 } = node_exports;
var DEFAULT_OPTIONS8 = {
  node: {
    type: "react",
    state: {
      active: {
        halo: false
      },
      selected: {
        halo: false
      }
    }
  },
  edge: {
    type: "polyline",
    style: {
      lineWidth: 2,
      router: {
        type: "orth"
      }
    }
  },
  layout: {
    type: "dagre",
    animation: false
  },
  transforms: ["translate-react-node-origin"]
};
function getOrganizationChartOptions({ direction, labelField }) {
  const options = {
    node: {
      style: {
        component: (data) => {
          const label = formatLabel(data, labelField);
          return import_react25.default.createElement(TextNode6, { type: "filled", text: label });
        },
        size: [100, 40],
        ports: direction === "vertical" ? [{ placement: "top" }, { placement: "bottom" }] : [{ placement: "left" }, { placement: "right" }]
      }
    },
    transforms: (prev) => [
      ...prev,
      {
        type: "collapse-expand-react-node",
        key: "collapse-expand-react-node",
        iconPlacement: direction === "vertical" ? "bottom" : "right",
        enable: false,
        refreshLayout: true
      }
    ],
    layout: {
      type: "dagre",
      rankdir: direction === "vertical" ? "TB" : "LR"
    }
  };
  return options;
}

// node_modules/@ant-design/graphs/es/components/organization-chart/index.js
var OrganizationChart = (0, import_react26.forwardRef)((_a, ref) => {
  var _b = _a, { children } = _b, props = __objRest(_b, ["children"]);
  const options = (0, import_react26.useMemo)(() => {
    const _a2 = props, { direction = "vertical", labelField } = _a2, restProps = __objRest(_a2, ["direction", "labelField"]);
    const options2 = mergeOptions2(COMMON_OPTIONS, DEFAULT_OPTIONS8, getOrganizationChartOptions({ direction, labelField }), restProps);
    return options2;
  }, [props]);
  return import_react26.default.createElement(BaseGraph, __spreadProps(__spreadValues({}, options), { ref }), children);
});
export {
  collapse_expand_icon_exports as CollapseExpandIcon,
  Dendrogram,
  Fishbone,
  FlowDirectionGraph,
  FlowGraph,
  esm_exports as G6,
  IndentedTree,
  MindMap,
  NetworkGraph,
  OrganizationChart,
  node_exports as RCNode,
  getNodeSide,
  measureTextSize,
  mergeOptions2 as mergeOptions
};
/*! Bundled license information:

comlink/dist/esm/comlink.mjs:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=@ant-design_graphs.js.map
