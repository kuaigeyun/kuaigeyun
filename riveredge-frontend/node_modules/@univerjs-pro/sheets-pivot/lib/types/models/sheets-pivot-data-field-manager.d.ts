import { IDataFieldValue, IFieldsCollectionJSON, PivotSubtotalTypeEnum, DataField, DataFieldManager, FieldsCollection } from '@univerjs-pro/engine-pivot';
import { ICellData, IRange, IUnitRangeName, IUniverInstanceService, Nullable, ObjectMatrix, Styles, Worksheet } from '@univerjs/core';
import { IRuntimeUnitDataType } from '@univerjs/engine-formula';
import { ICurrentDataMatrix, IDataFieldManagerJSON, IPivotCellPositionInfo, IUnitRangeNameWithSubUnitId, IUpdateInfo } from '../const/type';
import { SheetsPivotDataSourceModel } from './sheets-pivot-data-source-model';
interface IFeatureDirtyRangeType {
    [unitId: string]: Nullable<{
        [sheetId: string]: IRange[];
    }>;
}
export declare class SheetsPivotDataFieldManager extends DataFieldManager {
    /**
     * the key is pivot table id, the value is the data range info. those data range is one-to-one with the pivot table
     */
    rangeKeyMap: Record<string, string>;
    private _univerInstanceService;
    _host: SheetsPivotDataSourceModel;
    constructor(host: SheetsPivotDataSourceModel, univerInstanceService: IUniverInstanceService);
    initDataRanges(): void;
    getAutoDisplayNameFunction(): (baseName: string, subtotalType: PivotSubtotalTypeEnum) => string;
    deleteDataField(dataFieldId: string): void;
    /**
     * The field added here is derived, so donâ€™t need to consider rangeKey.
     * @param {DataField} dataField
     */
    addDataFieldWithoutUnitInfo(dataField: DataField): void;
    removeCollectionImp(token: string): void;
    getRangeKey(rangeInfo: IUnitRangeName, colIndex: number): string;
    getDataFieldByRangeKey(rangeKey: string): DataField | undefined;
    setRangeKeyMap(rangeKey: string, dataFieldId: string): void;
    updateRangeKeyMap(oldRangeKey: string, newRangeKey: string): void;
    addCollectionByJSON(token: string, collectionJSON: IFieldsCollectionJSON, sourceRangeInfo: IUnitRangeNameWithSubUnitId, targetCellInfo: IPivotCellPositionInfo): IUpdateInfo;
    getRangeStartEndInfo(range: IRange, sheet: Worksheet): IRange;
    /**
     * - when add pivot table, we should create a collection with data range first
     * @param {IUnitRangeName} dataRangeInfo the data range info
     * @returns {FieldsCollection} the created collection
     */
    createCollectionWithDataRange(dataRangeInfo: IUnitRangeName): IUpdateInfo;
    _getAutoName(colIndex: number): string;
    uniqueDataFieldName(name: IDataFieldValue, colIndex: number): string;
    getCollection(token: string): FieldsCollection;
    addCollection(token: string, collection: FieldsCollection, sourceRangeInfo: IUnitRangeNameWithSubUnitId, targetCellInfo: IPivotCellPositionInfo): void;
    handleMoveRange(token: string, sourceRangeInfo: IUnitRangeNameWithSubUnitId): void;
    getPivotDirtyViewInfo(): {
        runtimeCellData: IRuntimeUnitDataType;
        dirtyRanges: IFeatureDirtyRangeType;
    };
    getUpdateRangeDeleteIds(token: string, dataRangeInfo: IUnitRangeName): string[] | undefined;
    /**
     * get the matrix value from different matrix, when refresh the data source of pivot table
     * @param matrix the sheet cell matrix
     * @param arrayFormulaCellDataMatrix the array formula cell data matrix from run time data
     * @param unitDataMatrix the unit data matrix from runtime data
     * @param {number} rowIndex - the row index
     * @param {number} colIndex - the column index
     * @returns {Nullable<ICellData>} the cell data
     */
    getMatrixValue(matrix: ObjectMatrix<Nullable<ICellData>>, arrayFormulaCellDataMatrix: ObjectMatrix<Nullable<ICellData>> | undefined, unitDataMatrix: ObjectMatrix<Nullable<ICellData>> | undefined, rowIndex: number, colIndex: number): Nullable<ICellData>;
    refreshDataField(dataFieldId: string, dataRangeInfo: IUnitRangeNameWithSubUnitId, index: number, currentDataMatrix?: ICurrentDataMatrix): void;
    refreshData(collection: FieldsCollection, list: {
        index: number;
        dataField: DataField;
    }[], dataRangeInfo: IUnitRangeNameWithSubUnitId): void;
    getRangeKeyList(dataRangeInfo: IUnitRangeName): string[];
    /**
     * - adjust sheet cell value to the type that pivot engine can recognize
     * @param {Nullable<ICellData>} cellData the cell data
     * @param {Styles} styles styles in the workbook
     * @param {Record<string, any>} patternInfoRecord the pattern info record
     * @returns {IDataFieldValue} the value to add into the data field
     */
    adjustSheetCellData(cellData: Nullable<ICellData>, styles: Styles, patternInfoRecord: Record<string, any>): IDataFieldValue;
    getRangeData(dataRangeInfo: IUnitRangeName): {
        header: (string | null)[];
        data: IDataFieldValue[][];
    };
    toJSON(): IDataFieldManagerJSON;
    fromJSON(jsonData: IDataFieldManagerJSON): void;
    dispose(): void;
}
export {};
