import { DataField, FieldsCollection, IFieldsCollectionJSON, IPivotTableSnapshot, PivotView, PivotTable } from '@univerjs-pro/engine-pivot';
import { IUnitRangeName, Nullable, Disposable, ICommandService, Injector, IResourceManagerService, IUniverInstanceService, LifecycleService } from '@univerjs/core';
import { IMoveRangeMutationParams } from '@univerjs/sheets';
import { ICollectionChangeInfo, IDataFieldManagerJSON, IPivotCellPositionInfo, IPivotMutationDirtyViewInfo, IPivotTableConfig, IPivotTableJson, IPivotWorkerItemCache, ISendPivotConfigLocalMutationParams, IUnitRangeNameWithSubUnitId, IUpdateInfo, PivotTableOperationEnum } from '../const/type';
import { IViewTranslateCtx } from './view-util';
import { SheetsPivotDataFieldManager } from './sheets-pivot-data-field-manager';
export declare class SheetsPivotDataSourceModel extends Disposable {
    private readonly _injector;
    private readonly _univerInstanceService;
    readonly _lifecycleService: LifecycleService;
    private readonly _commandService;
    private _resourceManagerService;
    private _model;
    private _pivotTableInstanceCache;
    private _viewData;
    private _textInfo;
    private _collectionChange$;
    collectionChange$: import('rxjs').Observable<ICollectionChangeInfo>;
    private _viewData$;
    viewData$: import('rxjs').Observable<{
        unitId: string;
        subUnitId: string;
        pivotTableId: string;
    }>;
    private _fieldsCollectionChange$;
    fieldsCollectionChange$: import('rxjs').Observable<Record<string, FieldsCollection>>;
    private _dataFieldManagerCollection;
    needSameDeleteModel: {
        deleteUnitId: (unitId: string) => void;
    }[];
    /**
     * - this property is used to store the dirty pivot table collection which need to be marked dirty when mutations is executed
     */
    private _queryingMap;
    constructor(_injector: Injector, _univerInstanceService: IUniverInstanceService, _lifecycleService: LifecycleService, _commandService: ICommandService, _resourceManagerService: IResourceManagerService);
    getTextInfo(): Record<string, string>;
    setTextInfo(textInfo: Record<string, string>): void;
    handleMoveRange(params: IMoveRangeMutationParams): void;
    broadcastCollectionChange(info: ICollectionChangeInfo): void;
    getDataFieldManager(unitId: string): SheetsPivotDataFieldManager;
    getCollection(unitId: string, token: string): FieldsCollection;
    getUpdateRangeDeleteIds(unitId: string, token: string, dataRangeInfo: IUnitRangeName): string[] | undefined;
    private _ensurePivotMap;
    private _updateModelCache;
    private _deleteModelCache;
    private _updatePivotTableInstanceCache;
    private _deletePivotTableInstanceCache;
    private _ensureViewDataMap;
    updateConfig(info: ISendPivotConfigLocalMutationParams): void;
    updateView(unitId: string, subUnitId: string, type: PivotTableOperationEnum, pivotTableId: string, view: Nullable<PivotView>, pivotConfig: Nullable<IPivotTableConfig>, collectionConfig?: IDataFieldManagerJSON, ignoreDirty?: boolean): void;
    /**
     * - the function is used to save the dirty view data and range for formula calculation
     * @param {IViewTranslateCtx} ctx the dirty context
     * @param {boolean} ignoreDirty the flag to ignore the dirty view area, only in handleSourceRangeChange , we get a dirty change from the source range change, we need ignore the dirty view area,because the dirty view area has done immediately
     */
    updateViewData(ctx: IViewTranslateCtx, ignoreDirty: boolean): void;
    addPivotTable(unitId: string, subUnitId: string, pivotTableId: string, pivotTable: PivotTable, pivotTableConfig: IPivotTableConfig): void;
    removePivotTable(unitId: string, subUnitId: string, pivotTableId: string): void;
    setPivotTable(unitId: string, subUnitId: string, pivotTableId: string, pivotTableConfig: IPivotTableConfig): void;
    getPivotTableConfig(unitId: string, subUnitId: string, pivotTableId: string): IPivotTableConfig | undefined;
    /**
     * - get the pivot table model json config
     * @param {string} unitId
     * @param {string} subUnitId
     * @param {string} pivotTableId - the pivot table id
     * @returns {IPivotTableSnapshot|undefined} the pivot table model json config
     */
    getPivotTableModelConfig(unitId: string, subUnitId: string, pivotTableId: string): IPivotTableSnapshot | undefined;
    getPivotTableInstance(pivotTableId: string): PivotTable | undefined;
    deleteUnitId(unitId: string): void;
    addCollectionByJSON(token: string, collectionJSON: IFieldsCollectionJSON, sourceRangeInfo: IUnitRangeNameWithSubUnitId, targetCellInfo: IPivotCellPositionInfo): IUpdateInfo;
    /**
     * - this function just create a collection with data range info, but wil not add it to the dataFieldManager
     */
    createCollectionWithDataRange(dataRangeInfo: IUnitRangeNameWithSubUnitId): IUpdateInfo;
    refreshData(collection: FieldsCollection, updateDataFieldList: {
        index: number;
        dataField: DataField;
    }[], dataRangeInfo: IUnitRangeNameWithSubUnitId): void;
    removeDataField(unitId: string, dataFieldId: string): void;
    removeCollections(unitId: string, token: string): void;
    getSubUnitPivotConfigs(unitId: string, subUnitId: string): Map<string, IPivotTableConfig> | undefined;
    getTargetByPivotId(pivotTableId: string): {
        unitId: string;
        subUnitId: string;
    } | null;
    sideEffectUpdateWorkerCache(unitId: string, subUnitId: string, pivotTableId: string, workerCache?: IPivotWorkerItemCache): void;
    dispose(): void;
    getViewData(unitId: string, subUnitId: string, pivotTableId: string): IPivotWorkerItemCache | null;
    addDirtyPivotTable(dirtyInfo: IPivotMutationDirtyViewInfo): void;
    updateDirtyPivotTable(dirtyInfo: IPivotMutationDirtyViewInfo): void;
    /**
     * trigger the pivot table query
     * @param dirtyInfo
     */
    queryDirtyPivotTable(dirtyInfo: IPivotMutationDirtyViewInfo): void;
    toJSON(unitId: string): IPivotTableJson;
    fromJSON(jsonData: IPivotTableJson): void;
    private _initSnapshot;
}
