import { DataField } from '../field/data-field';
import { IDimensionMapItem, IMeasuresMapItem, IPivotSummaryLevelPool, IPivotTableQueryData, IPivotTableValueFilter, ITupleItem, IValueFilterInfoItem, PivotErrorTypeEnum, PivotSubtotalTypeEnum, PivotDataFieldSortOperatorEnum } from '../types';
import { TupleGroup } from './tuple-group';
import { NodeTree } from './node-tree';
export declare class SummaryManager {
    counter: number;
    rowDimOrder: number[];
    colDimOrder: number[];
    rowTableIdList: string[];
    colTableIdList: string[];
    rowDeep: number;
    colDeep: number;
    measureCount: number;
    leafCount: number;
    measuresMap: Record<string, IMeasuresMapItem>;
    /**
     * @property The tuples of the pivot table, it contains the path, indexes, and save the measure value of each tuple.
     */
    tuples: ITupleItem[];
    /**
     * @property The map of tuple, it is used to quickly find the tuple by the path of tuple. the key is the path of tuple, the value is the index of tuple in tuples.
     */
    tupleMap: Record<string, number>;
    /**
     * @property The dimensionIdList, it contains the id of dimension fields.Only the the row and col fields are dimension fields.
     */
    dimensionIdList: string[];
    dimensionTableIdList: string[];
    /**
     * @property The measureIdList, it contains the id of measure fields.It used to quickly find the measure field.
     */
    measureIdList: string[];
    _rowLevelPool: IPivotSummaryLevelPool;
    _colLevelPool: IPivotSummaryLevelPool;
    rowNodeTree: NodeTree;
    colNodeTree: NodeTree;
    dimensionMap: Record<string, IDimensionMapItem>;
    /**
     * fist Record key is combinePathMap
     */
    combinePathMap: Record<string, Record<string, number>>;
    collapseInfo: Record<string, boolean | Record<string, boolean>>;
    dimensionSortInfo: Record<string, {
        type: PivotDataFieldSortOperatorEnum;
        sortMap: Record<string, number>;
    }>;
    valueFilterInfo: IValueFilterInfoItem[];
    subtotalMap: Record<string, {
        subTotal: PivotSubtotalTypeEnum;
        dataFieldId: string;
    }>;
    constructor(queryData: IPivotTableQueryData, tupleGroup: TupleGroup);
    createSummaryLabelSortedMap(queryData: IPivotTableQueryData): void;
    getCellValue(index: number, id: string, subtotal: PivotSubtotalTypeEnum): number | {
        errorType: PivotErrorTypeEnum;
    } | undefined;
    getSortedMap(tableFieldId: string, dataField: DataField): Record<string, number>;
    doSummary(): void;
    private _getIndex;
    buildNodeTree(ignoreLeafSet: Set<number>): void;
    createTupleWithoutCheck(paths: string[], nodeIndex: number, tupleKey: string): void;
    _buildNodeTreeImp(dimOrder: number[], tableIdList: string[], levelPool: IPivotSummaryLevelPool, nodePathStr: string, ignoreLeafSet: Set<number>): NodeTree;
    combinePathMapList(colPathMapList: Record<string, number>[], basePath: string): Record<string, number>;
    calculateListSubtotal(tupleItem: ITupleItem, indexes: number[]): void;
    calculateSubtotal(ignoreLeafSet: Set<number>): void;
    getPathKeyWithFiledId(paths: string[], tableIdList: string[]): string;
    ensureTupleItem(index: number, paths: string[], tableIdList: string[]): void;
    ensureTupleItemByString(index: number, pathString: string): void;
    /**
     * - create tuple if not exist
     * @param {string[]} paths the path of tuple
     * @param {string} [pathsStr] the joined path string of tuple
     * @returns {void}
     */
    createTuple(paths: string[], pathsStr?: string, nodeIndex?: number): void;
    _calculateValueFilter(): Set<number>;
    _doValueFilter(fieldId: string, valueFieldId: string, filterInfo: IPivotTableValueFilter, leafSet: Set<number>): void;
    /**
     * get the filter tree by fieldId, if the fieldId is in rowTableIdList, return rowNodeTree, if the fieldId is in colTableIdList, return colNodeTree
     * @param fieldId The base field id of the value filter.
     */
    _getValueFilterTree(fieldId: string): {
        pool: IPivotSummaryLevelPool;
        fieldIdList: string[];
    } | null;
    _calculateSubtotalImp(levelPool: IPivotSummaryLevelPool, ignoreLeafSet: Set<number>): void;
}
