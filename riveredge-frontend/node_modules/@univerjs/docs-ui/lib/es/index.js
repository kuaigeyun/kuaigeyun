var Bc = Object.defineProperty;
var Mc = (n, e, t) => e in n ? Bc(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;
var O = (n, e, t) => Mc(n, typeof e != "symbol" ? e + "" : e, t);
import { IUniverInstanceService as L, Inject as j, Disposable as me, toDisposable as Mn, UniverInstanceType as _, BuildTextUtils as ce, JSONX as W, ObjectRelativeFromV as gt, ObjectRelativeFromH as Co, CommandType as D, sequenceExecuteAsync as Pr, ICommandService as T, DataStreamTreeTokenType as V, TextX as Ie, TextXActionType as G, PresetListType as ye, UpdateDocsAttributeType as nn, Tools as ue, generateRandomId as ge, TableRowHeightRule as _c, TableSizeType as Gi, TableTextWrapType as Dc, TableAlignmentType as wc, MemoryCursor as Nt, SHEET_EDITOR_UNITS as En, PositionedObjectLayoutType as Ro, BlockType as Pc, LRUMap as Nc, BaselineOffset as Ve, BooleanNumber as z, ColorKit as Qs, DrawingTypeEnum as Nr, skipParseTagNames as Lc, CustomRangeType as Lr, DataStreamTreeNodeType as sn, createIdentifier as Yi, ILogService as Qr, SliceBodyType as ir, DOCS_NORMAL_EDITOR_UNIT_ID_KEY as bo, DOC_RANGE_TYPE as He, normalizeBody as Qc, getBodySlice as Ki, FOCUSING_DOC as _n, EDITOR_ACTIVATED as eo, DashStyleType as Uc, RxDisposable as Ct, ThemeService as Ur, IUndoRedoService as yo, PRESET_LIST_TYPE as Fc, HorizontalAlign as Ue, NamedStyleType as K, RANGE_DIRECTION as De, COLORS as gn, Rectangle as Hc, DocumentFlavor as Pe, LocaleService as Ye, isInternalEditorID as Rt, IContextService as Fr, Injector as Dn, FOCUSING_EDITOR_STANDALONE as Us, VerticalAlign as kc, DEFAULT_EMPTY_DOCUMENT_VALUE as qi, PageOrientType as Vc, PAPER_TYPES as Wc, PAGE_SIZE as ar, DOCS_ZEN_EDITOR_UNIT_ID_KEY as nt, DEFAULT_STYLES as xo, NAMED_STYLE_MAP as jc, DisposableCollection as In, fromEventSubject as Mt, deepCompare as zc, FOCUSING_UNIVER_EDITOR as Hr, FOCUSING_COMMON_DRAWINGS as Xi, getPlainText as to, debounce as kr, SpacingRule as Xt, IConfigService as Vr, QuickListTypeMap as jo, Direction as le, DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY as Gc, checkForSubstrings as Yc, createInterceptorKey as Zi, InterceptorManager as Kc, UndoCommandId as Fs, RedoCommandId as Hs, DependentOn as qc, Plugin as Xc, merge as Zc, touchDependencies as ks, mergeOverrideWithDependencies as Jc, createInternalEditorID as $c } from "@univerjs/core";
import { DocSelectionManagerService as Y, RichTextEditingMutation as X, DocSkeletonManagerService as de, SetTextSelectionsOperation as Le, DocStateEmitService as el, DocInterceptorService as tl } from "@univerjs/docs";
import { IRenderManagerService as pe, DocumentEditArea as ve, hasListGlyph as nl, isIndentByGlyph as ol, isFirstGlyph as rl, getParagraphByGlyph as sl, pixelToPt as il, ptToPixel as Vs, parseDataStreamToTree as al, Liquid as Ji, GlyphType as $i, DocumentSkeletonPageType as Oe, getPageFromPath as cr, getTableIdAndSliceIndex as Ws, NORMAL_TEXT_SELECTION_PLUGIN_STYLE as Sn, getColor as fn, RegularPolygon as ea, Rect as Kn, getOffsetRectForDom as cl, ScrollTimer as ll, CURSOR_TYPE as Dt, getSystemHighlightColor as dl, Vector2 as vn, PageLayoutType as Cn, Shape as Al, Path as js, pxToNum as ta, TRANSFORM_CHANGE_OBSERVABLE_TYPE as na, getNumberUnitValue as on, Viewport as ul, ScrollBar as lr, Layer as zs, Documents as hl, DocBackground as gl, getLastLine as fl, lineIterator as pl, getLastColumn as ml, UniverRenderEnginePlugin as El, DeviceInputEventType as oa } from "@univerjs/engine-render";
import { IClipboardInterfaceService as ra, FILE_PNG_CLIPBOARD_MIME_TYPE as Il, FILE__WEBP_CLIPBOARD_MIME_TYPE as Sl, FILE__JPEG_CLIPBOARD_MIME_TYPE as vl, FILE__BMP_CLIPBOARD_MIME_TYPE as Cl, HTML_CLIPBOARD_MIME_TYPE as sa, PLAIN_TEXT_CLIPBOARD_MIME_TYPE as ia, CopyCommand as Rl, CutCommand as bl, PasteCommand as yl, ILayoutService as Oo, KeyCode as q, IConfirmService as aa, useDependency as J, ComponentManager as rn, ISidebarService as ca, getMenuHiddenObservable as se, MenuItemType as Z, COLOR_PICKER_COMPONENT as la, FONT_FAMILY_ITEM_COMPONENT as xl, FONT_FAMILY_COMPONENT as Ol, FONT_SIZE_LIST as Tl, FONT_SIZE_COMPONENT as Bl, HEADING_LIST as Gs, COMMON_LABEL_COMPONENT as Ml, HEADING_ITEM_COMPONENT as _l, ICanvasPopupService as Dl, IMenuManagerService as da, ToolbarItem as wl, MenuManagerPosition as Pl, useObservable as et, RectPopup as Nl, DesktopMenu as Ll, ContextMenuPosition as no, MetaKeys as te, Slider as Ql, useConfigValue as Aa, useEvent as mn, ContextMenuGroup as an, RibbonInsertGroup as Ul, RibbonStartGroup as Ys, IUIPartsService as Fl, IShortcutService as To, BuiltInUIPart as Ks, connectInjector as qs, imageMimeTypeSet as Hl, IContextMenuService as kl } from "@univerjs/ui";
import { ImageSourceType as Wr } from "@univerjs/drawing";
import { Subject as be, BehaviorSubject as Fe, merge as ua, filter as oo, takeUntil as ft, fromEvent as je, Observable as fe, map as wn, combineLatest as Pn, distinctUntilChanged as Wt, throttleTime as Rn, switchMap as Vl, take as Wl, first as jl, of as zl, animationFrameScheduler as Gl } from "rxjs";
import { useRef as ke, createElement as Te, forwardRef as Be, useState as Ee, useEffect as Ce, useMemo as _e, useCallback as ha, useImperativeHandle as Yl, useLayoutEffect as ga } from "react";
import { filter as dr, bufferTime as Kl, map as ql } from "rxjs/operators";
import { jsxs as re, jsx as Q, Fragment as Xl } from "react/jsx-runtime";
import { Checkbox as Xs, InputNumber as it, Button as Zl, clsx as ze, borderClassName as Nn, Select as fa, scrollbarClassName as Jl, Tooltip as $l } from "@univerjs/design";
var ed = Object.getOwnPropertyDescriptor, td = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? ed(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, Zs = (n, e) => (t, o) => e(t, o, n);
let wt = class extends me {
  constructor(e, t) {
    super();
    O(this, "_matches", /* @__PURE__ */ new Map());
    this._univerInstanceService = e, this._textSelectionManagerService = t;
  }
  registerAutoFormat(e) {
    const t = this._matches.get(e.id);
    return t ? (t.push(e), t.sort((o, r) => {
      var s, i;
      return ((s = r.priority) != null ? s : 0) - ((i = o.priority) != null ? i : 0);
    })) : this._matches.set(e.id, [e]), Mn(() => {
      const o = this._matches.get(e.id);
      if (o) {
        const r = o.findIndex((s) => s === e);
        r >= 0 && o.splice(r, 1);
      }
    });
  }
  onAutoFormat(e, t) {
    var a, c, d, l, A, h, u, g, f;
    const o = (a = this._matches.get(e)) != null ? a : [], r = this._univerInstanceService.getCurrentUnitForType(_.UNIVER_DOC), s = this._textSelectionManagerService.getDocRanges(), i = (c = s.find((p) => p.isActive)) != null ? c : s[0];
    if (r && i) {
      const p = r.getSelfOrHeaderFooterModel(i.segmentId), m = {
        unit: p,
        selection: i,
        isBody: !i.segmentId,
        paragraphs: ce.range.getParagraphsInRange(i, (l = (d = p.getBody()) == null ? void 0 : d.paragraphs) != null ? l : [], (h = (A = p.getBody()) == null ? void 0 : A.dataStream) != null ? h : ""),
        customRanges: ce.customRange.getCustomRangesInterestsWithSelection(i, (g = (u = p.getBody()) == null ? void 0 : u.customRanges) != null ? g : []),
        commandId: e,
        commandParams: t
      }, I = o.find((S) => S.match(m));
      return (f = I == null ? void 0 : I.getMutations(m)) != null ? f : [];
    }
    return [];
  }
};
wt = td([
  Zs(0, L),
  Zs(1, j(Y))
], wt);
const nd = {
  undo: !0,
  redo: !0,
  // Undo redo
  font: !0,
  // 'font'
  fontSize: !0,
  // 'Font size'
  bold: !0,
  // 'Bold (Ctrl+B)'
  italic: !0,
  // 'Italic (Ctrl+I)'
  strikethrough: !0,
  // 'Strikethrough (Alt+Shift+5)'
  underline: !0,
  // 'Underline (Alt+Shift+6)'
  textColor: !0,
  // 'Text color'
  fillColor: !0,
  // 'Cell color'
  horizontalAlignMode: !0,
  // 'Horizontal alignment'
  verticalAlignMode: !0,
  // 'Vertical alignment'
  textWrapMode: !0,
  // 'Wrap mode'
  textRotateMode: !0
  // 'Text Rotation Mode'
}, od = {
  outerLeft: !1,
  outerRight: !1,
  header: !0,
  footer: !0,
  innerLeft: !1,
  innerRight: !1,
  frozenHeaderLT: !1,
  frozenHeaderRT: !1,
  frozenHeaderLM: !1,
  frozenContent: !1,
  infoBar: !0,
  toolbar: !0
}, rd = "DOC_UI_PLUGIN";
var $e = /* @__PURE__ */ ((n) => (n.MAIN = "__Document_Render_Main__", n.BACKGROUND = "__Document_Render_Background__", n))($e || {}), We = /* @__PURE__ */ ((n) => (n.VIEW_MAIN = "viewMain", n.VIEW_TOP = "viewTop", n.VIEW_LEFT = "viewLeft", n.VIEW_LEFT_TOP = "viewLeftTop", n))(We || {});
const sd = 0, zo = 2, id = 4, Js = 10, jf = "normalTextSelectionPluginName";
function pt(n) {
  const { mainComponent: e, scene: t, engine: o, components: r } = n, s = e, i = r.get($e.BACKGROUND);
  return {
    document: s,
    docBackground: i,
    scene: t,
    engine: o
  };
}
function ad(n, e) {
  const t = n.getCurrentUnitOfType(_.UNIVER_DOC);
  if (!t)
    return null;
  const o = t.getUnitId(), r = e.getRenderById(o);
  if (r == null)
    return;
  const { mainComponent: s, scene: i, engine: a, components: c } = r, d = s, l = c.get($e.BACKGROUND);
  return {
    document: d,
    docBackground: l,
    scene: i,
    engine: a
  };
}
function zf(n, e) {
  const t = e.getRenderById(n);
  if (t == null)
    return;
  const { mainComponent: o, scene: r, engine: s, components: i } = t, a = o, c = i.get($e.BACKGROUND);
  return {
    document: a,
    docBackground: c,
    scene: r,
    engine: s
  };
}
function cd(n) {
  const { unitId: e, ranges: t, id: o, type: r, segmentId: s } = n, i = {
    id: X.id,
    params: {
      unitId: e,
      actions: [],
      textRanges: void 0,
      // noHistory: true,
      segmentId: s
    }
  }, a = W.getInstance(), c = ce.customDecoration.add({ ranges: t, id: o, type: r });
  return i.params.actions = a.editOp(c.serialize()), i;
}
function Gf(n, e) {
  const { segmentId: t, id: o, type: r, unitId: s } = e, i = n.get(Y), a = n.get(L), c = s ? a.getUnit(s, _.UNIVER_DOC) : a.getCurrentUnitForType(_.UNIVER_DOC);
  if (!c)
    return !1;
  const d = c.getUnitId(), l = i.getTextRanges({ unitId: d, subUnitId: d });
  return !l || !c.getBody() ? !1 : cd(
    {
      unitId: d,
      ranges: l,
      id: o,
      type: r,
      segmentId: t
    }
  );
}
function Yf(n, e) {
  const { unitId: t, id: o, segmentId: r } = e, i = n.get(L).getUnit(t);
  if (!i)
    return !1;
  const a = {
    id: X.id,
    params: {
      unitId: t,
      actions: [],
      textRanges: void 0,
      // noHistory: true,
      segmentId: r
    }
  }, c = ce.customDecoration.delete({ id: o, segmentId: r, documentDataModel: i });
  if (!c)
    return !1;
  const d = W.getInstance();
  return a.params.actions = d.editOp(c.serialize()), a;
}
function Kf(n, e) {
  return e.some((t) => n.startIndex > t.startIndex && n.startIndex < t.endIndex);
}
function Bo(n, e, t, o, r) {
  const { textRuns: s = [], dataStream: i } = n, a = r && i.startsWith("="), c = {
    st: 0,
    ed: 0,
    ts: {}
  };
  if (a)
    return c;
  for (let d = s.length - 1; d >= 0; d--) {
    const l = s[d], { st: A, ed: h } = l;
    e > A && e <= h && (c.st = A, c.ed = h, c.ts = {
      ...c.ts,
      ...l.ts
    });
  }
  if (e === 0) {
    const d = s == null ? void 0 : s[0];
    d && d.st === 0 && (c.ts = {
      ...c.ts,
      ...d.ts
    });
  }
  return o && (c.ts = {
    ...c.ts,
    ...o
  }), c;
}
function jr(n, e, t) {
  if (t) {
    const r = n.find((s) => e >= s.startIndex && e <= s.endIndex + 1);
    return r != null && r.wholeEntity ? null : r;
  }
  const o = n.find((r) => e > r.startIndex && e <= r.endIndex);
  return o != null && o.wholeEntity ? null : o;
}
function zr(n, e) {
  return n.filter((t) => e > t.startIndex && e <= t.endIndex);
}
function qf(n) {
  return {
    left: n.positionH.posOffset,
    top: n.positionV.posOffset,
    width: n.size.width,
    height: n.size.height
  };
}
function Xf(n, e = 0, t = 0) {
  return {
    size: {
      width: n.width,
      height: n.height
    },
    positionH: {
      relativeFrom: Co.MARGIN,
      posOffset: (n.left || 0) - e
    },
    positionV: {
      relativeFrom: gt.PAGE,
      posOffset: (n.top || 0) - t
    },
    angle: n.angle || 0
  };
}
const ld = "doc.command.tab", Jt = {
  id: ld,
  type: D.COMMAND,
  async handler(n, e) {
    const o = n.get(wt).onAutoFormat(Jt.id, e);
    return (await Pr(o, n.get(T))).result;
  }
}, dd = "doc.command.after-space", Mo = {
  id: dd,
  type: D.COMMAND,
  async handler(n) {
    const t = n.get(wt).onAutoFormat(Mo.id);
    return (await Pr(t, n.get(T))).result;
  }
}, bn = {
  id: "doc.command.enter",
  type: D.COMMAND,
  async handler(n) {
    const t = n.get(wt).onAutoFormat(bn.id);
    return (await Pr(t, n.get(T))).result;
  }
};
var Ad = Object.getOwnPropertyDescriptor, ud = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? Ad(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, Go = (n, e) => (t, o) => e(t, o, n);
const hd = 11, gd = 9, kn = {
  /**
   * fontFamily
   */
  ff: "Arial",
  /**
   * fontSize
   */
  fs: hd
};
let at = class extends me {
  constructor(e, t, o) {
    super();
    O(this, "_cacheStyle", null);
    this._textSelectionManagerService = e, this._univerInstanceService = t, this._renderManagerService = o, this._init();
  }
  _init() {
    this._listenDocRangeChange();
  }
  _listenDocRangeChange() {
    this.disposeWithMe(
      this._textSelectionManagerService.textSelection$.subscribe(() => {
        this._clearStyleCache();
      })
    );
  }
  getStyleCache() {
    return this._cacheStyle;
  }
  getDefaultStyle() {
    var i;
    const e = this._univerInstanceService.getCurrentUnitForType(_.UNIVER_DOC);
    if (e == null)
      return {
        ...kn
      };
    const t = e == null ? void 0 : e.getUnitId(), o = (i = this._renderManagerService.getRenderById(t)) == null ? void 0 : i.with(de), r = o == null ? void 0 : o.getViewModel();
    return r == null ? {
      ...kn
    } : r.getEditArea() === ve.BODY ? {
      ...kn
    } : {
      ...kn,
      fs: gd
    };
  }
  setStyleCache(e) {
    this._cacheStyle = {
      ...this._cacheStyle,
      ...e
    };
  }
  _clearStyleCache() {
    this._cacheStyle = null;
  }
};
at = ud([
  Go(0, j(Y)),
  Go(1, L),
  Go(2, pe)
], at);
function Ke(n, e) {
  var o;
  return (o = n.get(pe).getRenderById(e)) == null ? void 0 : o.with(de);
}
function Ae(n, e = "") {
  if (!e)
    return ["body"];
  const { headers: t, footers: o } = n.getSnapshot();
  if (t == null && o == null)
    throw new Error("Document data model must have headers or footers when update by segment id");
  if ((t == null ? void 0 : t[e]) != null)
    return ["headers", e, "body"];
  if ((o == null ? void 0 : o[e]) != null)
    return ["footers", e, "body"];
  throw new Error("Segment id not found in headers or footers");
}
function pa(n, e, t) {
  const o = [];
  for (let r = 0, s = n.length; r < s; r++)
    n[r] === V.PARAGRAPH && o.push({
      startIndex: r
    });
  if (e)
    for (const r of o)
      e.bullet && (r.bullet = ue.deepClone(e.bullet)), e.paragraphStyle && (r.paragraphStyle = ue.deepClone(e.paragraphStyle), delete r.paragraphStyle.borderBottom, e.paragraphStyle.headingId && (r.paragraphStyle.headingId = ge(6)));
  if (t)
    for (const r of o)
      r.paragraphStyle || (r.paragraphStyle = {}), r.paragraphStyle.borderBottom = t;
  return o;
}
const Gr = {
  id: "doc.command.break-line",
  type: D.COMMAND,
  // eslint-disable-next-line max-lines-per-function, complexity
  handler: (n, e) => {
    var N, ee, $, U, H;
    const t = n.get(Y), o = n.get(L), r = n.get(T), s = n.get(at), i = (N = e == null ? void 0 : e.textRange) != null ? N : t.getActiveTextRange(), a = t.getRectRanges();
    if (i == null)
      return !1;
    if (a && a.length) {
      const { startOffset: k } = i;
      return t.replaceDocRanges([{
        startOffset: k,
        endOffset: k
      }]), !0;
    }
    const { horizontalLine: c } = e != null ? e : {}, { segmentId: d } = i, l = o.getCurrentUnitForType(_.UNIVER_DOC), A = l == null ? void 0 : l.getSelfOrHeaderFooterModel(d != null ? d : "").getBody();
    if (l == null || A == null)
      return !1;
    const h = l.getUnitId(), { startOffset: u, endOffset: g } = i, p = ((ee = A.paragraphs) != null ? ee : []).find((k) => k.startIndex >= u);
    if (!p)
      return !1;
    const m = u === p.startIndex, I = p.startIndex, S = s.getDefaultStyle(), v = s.getStyleCache(), R = Bo(A, g, S, v), E = {
      dataStream: V.PARAGRAPH,
      paragraphs: pa(
        V.PARAGRAPH,
        p,
        c
      ),
      textRuns: [{
        st: 0,
        ed: 1,
        ts: {
          ...R.ts
        }
      }]
    };
    if (l == null)
      return !1;
    const b = t.getActiveTextRange();
    if (A == null)
      return !1;
    const { collapsed: y } = i, C = E.dataStream.length, B = [
      {
        startOffset: u + C,
        endOffset: u + C,
        style: b == null ? void 0 : b.style,
        collapsed: y
      }
    ], x = {
      id: X.id,
      params: {
        unitId: h,
        actions: [],
        textRanges: B,
        debounce: !0
      }
    }, M = new Ie(), w = W.getInstance();
    if (y)
      u > 0 && M.push({
        t: G.RETAIN,
        len: u
      }), M.push({
        t: G.INSERT,
        body: E,
        len: E.dataStream.length
      });
    else {
      const k = ce.selection.delete([i], A, 0, E);
      M.push(...k);
    }
    ((($ = p.bullet) == null ? void 0 : $.listType) === ye.CHECK_LIST_CHECKED || (U = p.paragraphStyle) != null && U.headingId) && (i.endOffset < I && M.push({
      t: G.RETAIN,
      len: I - i.endOffset
    }), M.push({
      t: G.RETAIN,
      len: 1,
      body: {
        dataStream: "",
        paragraphs: [
          {
            ...p,
            paragraphStyle: {
              ...p.paragraphStyle,
              ...m ? {
                headingId: void 0,
                namedStyleType: void 0
              } : null
            },
            startIndex: 0,
            bullet: (H = p.paragraphStyle) != null && H.headingId ? void 0 : {
              ...p.bullet,
              listType: ye.CHECK_LIST
            }
          }
        ]
      },
      coverType: nn.REPLACE
    })), x.params.textRanges = [{
      startOffset: u + C,
      endOffset: u + C,
      collapsed: y
    }];
    const F = Ae(l, d);
    return x.params.actions = w.editOp(M.serialize(), F), !!r.syncExecuteCommand(x.id, x.params);
  }
};
var _o = /* @__PURE__ */ ((n) => (n[n.ABOVE = 0] = "ABOVE", n[n.BELLOW = 1] = "BELLOW", n))(_o || {}), Yr = /* @__PURE__ */ ((n) => (n[n.LEFT = 0] = "LEFT", n[n.RIGHT = 1] = "RIGHT", n))(Yr || {});
function fd(n, e) {
  let t = V.TABLE_START;
  const o = [], r = [];
  for (let s = 0; s < n; s++) {
    t += V.TABLE_ROW_START;
    for (let i = 0; i < e; i++)
      t += `${V.TABLE_CELL_START}\r
${V.TABLE_CELL_END}`, o.push({
        startIndex: t.length - 3,
        paragraphStyle: {
          spaceAbove: { v: 3 },
          lineSpacing: 2,
          spaceBelow: { v: 0 }
        }
      }), r.push({
        startIndex: t.length - 2
      });
    t += V.TABLE_ROW_END;
  }
  return t += V.TABLE_END, {
    dataStream: t,
    paragraphs: o,
    sectionBreaks: r
  };
}
function Kr() {
  return {
    margin: {
      start: {
        v: 10
      },
      end: {
        v: 10
      },
      top: {
        v: 5
      },
      bottom: {
        v: 5
      }
    }
  };
}
function qr(n) {
  const e = Kr();
  return {
    tableCells: [...new Array(n).fill(null).map(() => ue.deepClone(e))],
    trHeight: {
      val: { v: 30 },
      hRule: _c.AUTO
    }
  };
}
function Xr(n) {
  return {
    size: {
      type: Gi.SPECIFIED,
      width: {
        v: n
      }
    }
  };
}
function ma(n, e, t) {
  const o = Xr(t / e), r = qr(e), s = [...new Array(n).fill(null).map(() => ue.deepClone(r))], i = [...new Array(e).fill(null).map(() => ue.deepClone(o))], a = ge(6);
  return {
    tableRows: s,
    tableColumns: i,
    tableId: a,
    align: wc.START,
    indent: {
      v: 0
    },
    textWrap: Dc.NONE,
    position: {
      positionH: {
        relativeFrom: Co.PAGE,
        posOffset: 0
      },
      positionV: {
        relativeFrom: gt.PAGE,
        posOffset: 0
      }
    },
    dist: {
      distB: 0,
      distL: 0,
      distR: 0,
      distT: 0
    },
    cellMargin: {
      start: {
        v: 10
      },
      end: {
        v: 10
      },
      top: {
        v: 5
      },
      bottom: {
        v: 5
      }
    },
    size: {
      type: Gi.UNSPECIFIED,
      width: {
        v: t
      }
    }
  };
}
function Ln(n, e) {
  if (!n && !e)
    return null;
  if (e && e.length > 0) {
    let t = Number.POSITIVE_INFINITY, o = Number.NEGATIVE_INFINITY;
    const r = "";
    for (const s of e) {
      const { startOffset: i, endOffset: a, segmentId: c } = s;
      i == null || a == null || c == null || (t = Math.min(t, i), o = Math.max(o, a));
    }
    if (Number.isFinite(t) && Number.isFinite(o))
      return {
        startOffset: t,
        endOffset: o,
        segmentId: r
      };
  } else if (n) {
    const { startOffset: t, endOffset: o, segmentId: r } = n;
    return t == null || o == null || r == null ? null : {
      startOffset: t,
      endOffset: o,
      segmentId: r
    };
  }
}
function pd(n) {
  let e = V.TABLE_ROW_START;
  const t = [], o = [];
  for (let r = 0; r < n; r++)
    e += `${V.TABLE_CELL_START}\r
${V.TABLE_CELL_END}`, t.push({
      startIndex: e.length - 3,
      paragraphStyle: {
        spaceAbove: { v: 3 },
        lineSpacing: 2,
        spaceBelow: { v: 0 }
      }
    }), o.push({
      startIndex: e.length - 2
    });
  return e += V.TABLE_ROW_END, {
    dataStream: e,
    paragraphs: t,
    sectionBreaks: o
  };
}
function md() {
  const n = `${V.TABLE_CELL_START}\r
${V.TABLE_CELL_END}`, e = [], t = [];
  return e.push({
    startIndex: 1,
    paragraphStyle: {
      spaceAbove: { v: 3 },
      lineSpacing: 2,
      spaceBelow: { v: 0 }
    }
  }), t.push({
    startIndex: 2
  }), {
    dataStream: n,
    paragraphs: e,
    sectionBreaks: t
  };
}
function Ed(n, e, t) {
  var A, h, u;
  const { startOffset: o, endOffset: r, segmentId: s } = n, i = t.getSelfOrHeaderFooterViewModel(s), a = e === 0 ? o : r;
  let c = null;
  const d = (u = (h = (A = t.getBody()) == null ? void 0 : A.tables) == null ? void 0 : h.find((g) => a >= g.startIndex && a <= g.endIndex)) == null ? void 0 : u.tableId;
  let l = 0;
  for (const g of i.getChildren()) {
    for (const f of g.children) {
      const { children: p } = f, m = p[0];
      if (m) {
        for (const I of m.children)
          if (I.startIndex <= a && a <= I.endIndex) {
            l = m.children.indexOf(I), c = I;
            break;
          }
      }
      if (c)
        break;
    }
    if (c)
      break;
  }
  return c == null || d == null ? null : {
    offset: e === 0 ? c.startIndex : c.endIndex + 1,
    colCount: c.children.length,
    tableId: d,
    insertRowIndex: e === 0 ? l : l + 1
  };
}
function Id(n, e, t) {
  var u, g, f;
  const { startOffset: o, endOffset: r, segmentId: s } = n, i = t.getSelfOrHeaderFooterViewModel(s), a = e === 0 ? o : r, c = (f = (g = (u = t.getBody()) == null ? void 0 : u.tables) == null ? void 0 : g.find((p) => a >= p.startIndex && a <= p.endIndex)) == null ? void 0 : f.tableId, d = [];
  let l = null, A = -1;
  for (const p of i.getChildren()) {
    for (const m of p.children) {
      const { children: I } = m, S = I[0];
      if (S) {
        if (a < S.startIndex || a > S.endIndex)
          continue;
        l = S;
        for (const v of S.children) {
          for (const R of v.children) {
            const E = v.children.indexOf(R);
            if (a >= R.startIndex && a <= R.endIndex) {
              A = E;
              break;
            }
          }
          if (A !== -1)
            break;
        }
      }
      if (l)
        break;
    }
    if (l)
      break;
  }
  if (l == null || c == null || A === -1)
    return null;
  let h = 0;
  for (const p of l.children) {
    const m = p.children[A], I = e === 0 ? m.startIndex : m.endIndex + 1;
    d.push(I - h), h = I;
  }
  return {
    offsets: d,
    tableId: c,
    columnIndex: A,
    rowCount: l.children.length
  };
}
function Sd(n, e, t) {
  const o = [];
  let r = e[t].size.width.v, s = 0;
  for (let i = 0; i < e.length; i++)
    s += e[i].size.width.v;
  s += r;
  for (let i = 0; i < e.length; i++)
    o.push(e[i].size.width.v / s * n);
  return r = r / s * n, {
    widths: o,
    newColWidth: r
  };
}
function Ea(n, e) {
  var h, u, g;
  const { startOffset: t, endOffset: o, segmentId: r } = n, s = e.getSelfOrHeaderFooterViewModel(r), i = (g = (u = (h = e.getBody()) == null ? void 0 : h.tables) == null ? void 0 : u.find((f) => t >= f.startIndex && o <= f.endIndex)) == null ? void 0 : g.tableId, a = [];
  let c = -1, d = 0, l = -1, A = !1;
  for (const f of s.getChildren()) {
    for (const p of f.children) {
      const { children: m } = p, I = m[0];
      if (I) {
        if (t < I.startIndex || o > I.endIndex)
          continue;
        l = I.startIndex + 3;
        for (const S of I.children) {
          const v = I.children.indexOf(S), { startIndex: R, endIndex: E } = S;
          t >= R && t <= E ? (c = R, a.push(v), d += E - R + 1) : (R > t && E < o || o >= R && o <= E) && (a.push(v), d += E - R + 1), a.length === I.children.length && (A = !0);
        }
      }
      if (a.length)
        break;
    }
    if (a.length)
      break;
  }
  return i == null || a.length === 0 ? null : {
    tableId: i,
    rowIndexes: a,
    offset: c,
    len: d,
    cursor: l,
    selectWholeTable: A
  };
}
function vd(n, e) {
  var g, f, p;
  const { startOffset: t, endOffset: o, segmentId: r } = n, s = e.getSelfOrHeaderFooterViewModel(r), i = (p = (f = (g = e.getBody()) == null ? void 0 : g.tables) == null ? void 0 : f.find((m) => t >= m.startIndex && o <= m.endIndex)) == null ? void 0 : p.tableId, a = [];
  let c = null;
  const d = [];
  let l = -1, A = -1, h = -1;
  for (const m of s.getChildren()) {
    for (const I of m.children) {
      const { children: S } = I, v = S[0];
      if (v) {
        if (t < v.startIndex || o > v.endIndex)
          continue;
        c = v;
        for (const R of v.children)
          for (const E of R.children) {
            const b = R.children.indexOf(E);
            t >= E.startIndex && t <= E.endIndex && (A = b), o >= E.startIndex && o <= E.endIndex && (h = b);
          }
      }
      if (c)
        break;
    }
    if (c)
      break;
  }
  if (c == null || i == null)
    return null;
  for (let m = A; m <= h; m++)
    d.push(m);
  let u = 0;
  for (const m of c.children) {
    const I = m.children[A], S = m.children[h];
    a.push({
      retain: I.startIndex - u,
      delete: S.endIndex - I.startIndex + 1
    }), u = S.endIndex + 1;
  }
  return l = c.startIndex + 3, {
    offsets: a,
    tableId: i,
    columnIndexes: d,
    cursor: l,
    selectWholeTable: d.length === c.children[0].children.length,
    rowCount: c.children.length
  };
}
function Ia(n, e) {
  var l, A, h;
  const { startOffset: t, endOffset: o, segmentId: r } = n, s = e.getSelfOrHeaderFooterViewModel(r), i = (h = (A = (l = e.getBody()) == null ? void 0 : l.tables) == null ? void 0 : A.find((u) => t >= u.startIndex && o <= u.endIndex)) == null ? void 0 : h.tableId;
  let a = -1, c = 0, d = -1;
  for (const u of s.getChildren()) {
    for (const g of u.children) {
      const { children: f } = g, p = f[0];
      if (p) {
        if (t < p.startIndex || o > p.endIndex)
          continue;
        a = p.startIndex, c = p.endIndex - p.startIndex + 1, d = p.startIndex;
      }
      if (p)
        break;
    }
    if (c > 0)
      break;
  }
  return i == null ? null : {
    tableId: i,
    offset: a,
    len: c,
    cursor: d
  };
}
function Cd(n, e) {
  var g, f, p;
  const { startOffset: t, endOffset: o, segmentId: r } = n, s = e.getSelfOrHeaderFooterViewModel(r), i = (p = (f = (g = e.getBody()) == null ? void 0 : g.tables) == null ? void 0 : f.find((m) => t >= m.startIndex && o <= m.endIndex)) == null ? void 0 : p.tableId, a = [];
  let c = null, d = -1, l = -1, A = -1, h = -1;
  for (const m of s.getChildren()) {
    for (const I of m.children) {
      const { children: S } = I, v = S[0];
      if (v) {
        if (t < v.startIndex || o > v.endIndex)
          continue;
        c = v;
        for (const R of v.children) {
          const E = v.children.indexOf(R);
          for (const b of R.children) {
            const y = R.children.indexOf(b);
            t >= b.startIndex && t <= b.endIndex && (l = E, A = y), o >= b.startIndex && o <= b.endIndex && (h = y);
          }
        }
      }
      if (c)
        break;
    }
    if (c)
      break;
  }
  if (c == null || i == null || l === -1)
    return null;
  const u = c.children[l];
  for (let m = A; m <= h; m++) {
    const I = u.children[m];
    a.push({
      retain: I.startIndex + 1,
      delete: I.endIndex - I.startIndex - 3
    });
  }
  return d = c.startIndex + 3, {
    offsets: a,
    tableId: i,
    cursor: d,
    rowCount: c.children.length
  };
}
var Ar = /* @__PURE__ */ ((n) => (n[n.NEXT = 0] = "NEXT", n[n.PREV = 1] = "PREV", n))(Ar || {});
function $s(n, e, t) {
  const { startOffset: o } = e;
  let r = null;
  for (const d of n.getChildren()) {
    for (const l of d.children) {
      const A = l.children[0];
      if (A && o > A.startIndex && o < A.endIndex) {
        r = A;
        break;
      }
    }
    if (r)
      break;
  }
  if (r == null)
    return null;
  let s = -1, i = -1, a = null;
  for (const d of r.children) {
    for (const l of d.children)
      if (o > l.startIndex && o < l.endIndex) {
        s = d.children.indexOf(l), i = r.children.indexOf(d), a = d;
        break;
      }
    if (s > -1)
      break;
  }
  if (s === -1 || i === -1 || a == null)
    return null;
  let c = null;
  if (t === 0) {
    if (c = a.children[s + 1], !c) {
      const d = r.children[i + 1];
      d && (c = d.children[0]);
    }
  } else if (c = a.children[s - 1], !c) {
    const d = r.children[i - 1];
    d && (c = d.children[d.children.length - 1]);
  }
  if (c) {
    const { startIndex: d, endIndex: l } = c;
    return {
      startOffset: d + 1,
      endOffset: l - 2
    };
  }
}
function Rd(n, e) {
  const t = [], { customBlocks: o = [] } = n;
  for (const r of e) {
    const { startOffset: s, endOffset: i } = r;
    if (!(s == null || i == null))
      for (const a of o) {
        const { startIndex: c } = a;
        c >= s && c < i && t.push(a.blockId);
      }
  }
  return t;
}
function bd(n) {
  return n.some((e) => {
    const { startNodePosition: t } = e;
    return t ? (t == null ? void 0 : t.path.indexOf("cells")) > -1 : !1;
  });
}
const yd = En, Sa = {
  id: "doc.command.inner-paste",
  type: D.COMMAND,
  // eslint-disable-next-line max-lines-per-function, complexity
  handler: async (n, e) => {
    var C, B, x, M, w, F;
    const { segmentId: t, textRanges: o, doc: r } = e, s = n.get(T), i = n.get(Y), a = n.get(L), c = i.getTextRanges(), d = i.getRectRanges(), { body: l, tableSource: A, drawings: h } = r;
    if (!Array.isArray(c) || c.length === 0 || l == null)
      return !1;
    const u = a.getCurrentUniverDocInstance(), g = u == null ? void 0 : u.getSelfOrHeaderFooterModel(t).getBody();
    if (u == null || g == null)
      return !1;
    const f = u.getUnitId(), p = {
      id: X.id,
      params: {
        unitId: f,
        actions: [],
        textRanges: o,
        segmentId: t
      }
    }, m = new Nt();
    m.reset();
    const I = new Ie(), S = W.getInstance(), v = [], R = !!((C = l.tables) != null && C.length), E = !!((B = l.customBlocks) != null && B.length);
    if (R && t || R && bd(c) || c.length && (d != null && d.length))
      return !1;
    for (let P = 0; P < c.length; P++) {
      const N = c[P], { startOffset: ee, endOffset: $, collapsed: U } = N, H = ee - m.cursor, k = ue.deepClone(l);
      if (R)
        for (const ae of k.tables) {
          const { tableId: oe } = ae, he = ge(6);
          ae.tableId = he;
          const we = ue.deepClone(A[oe]);
          we.tableId = he;
          const Ze = S.insertOp(["tableSource", he], we);
          v.push(Ze);
        }
      if (E && h) {
        const ae = (M = (x = u.getSnapshot().drawingsOrder) == null ? void 0 : x.length) != null ? M : 0;
        for (const oe of k.customBlocks) {
          const { blockId: he } = oe, we = ge(6);
          oe.blockId = we;
          const Ze = ue.deepClone(h[he]);
          Ze.drawingId = we;
          const At = S.insertOp(["drawings", we], Ze), Je = S.insertOp(["drawingsOrder", ae], we);
          v.push(At), v.push(Je);
        }
      }
      const ne = jr((w = g.customRanges) != null ? w : [], $, yd.includes(f)), ie = zr((F = g.customDecorations) != null ? F : [], $);
      if (ne && (k.customRanges = [{
        ...ne,
        startIndex: 0,
        endIndex: l.dataStream.length - 1
      }]), ie.length && (k.customDecorations = ie.map((ae) => ({
        ...ae,
        startIndex: 0,
        endIndex: l.dataStream.length - 1
      }))), U)
        I.push({
          t: G.RETAIN,
          len: H
        }), I.push({
          t: G.INSERT,
          body: k,
          len: l.dataStream.length
        });
      else {
        const ae = ce.selection.delete([N], l, m.cursor, k, c.length === 1);
        I.push(...ae);
      }
      m.reset(), m.moveCursor($);
    }
    const b = Ae(u, t);
    return v.push(S.editOp(I.serialize(), b)), p.params.actions = v.reduce((P, N) => W.compose(P, N), null), !!s.syncExecuteCommand(p.id, p.params);
  }
};
function xd(n, e) {
  const { startOffset: t, endOffset: o } = n, r = e.some((i) => i.startIndex === o), s = Math.max(t, r ? o - 1 : o);
  return {
    ...n,
    endOffset: s,
    collapsed: t === s
  };
}
function Od(n, e, t) {
  var g, f;
  const o = e.getSelfOrHeaderFooterModel(t).getBody(), r = new Ie(), s = W.getInstance(), i = [];
  if (o == null)
    return i;
  const { tables: a = [] } = o, c = new Nt();
  c.reset();
  for (let p = 0; p < n.length; p++) {
    const m = xd(n[p], a), { startOffset: I, endOffset: S, collapsed: v } = m, R = I - c.cursor;
    v ? r.push({
      t: G.RETAIN,
      len: R
    }) : r.push(...ce.selection.delete([m], o, c.cursor, null, !1)), c.reset(), c.moveCursor(S);
  }
  const d = Ae(e, t);
  i.push(s.editOp(r.serialize(), d));
  const l = Rd(o, n), A = (g = e.getDrawings()) != null ? g : {}, h = (f = e.getDrawingsOrder()) != null ? f : [], u = l.sort((p, m) => h.indexOf(p) > h.indexOf(m) ? -1 : h.indexOf(p) < h.indexOf(m) ? 1 : 0);
  if (u.length > 0)
    for (const p of u) {
      const m = A[p], I = h.indexOf(p);
      if (m == null || I < 0)
        continue;
      const S = s.removeOp(["drawings", p], m), v = s.removeOp(["drawingsOrder", I], p);
      i.push(S), i.push(v);
    }
  return i.reduce((p, m) => W.compose(p, m), null);
}
function Td(n, e, t, o) {
  const r = [];
  if (e.getSelfOrHeaderFooterModel(o).getBody() == null)
    return r;
  const i = new Ie(), a = W.getInstance(), c = new Nt();
  c.reset();
  for (const l of n) {
    const { startOffset: A, endOffset: h, spanEntireRow: u, spanEntireTable: g } = l;
    if (!(A == null || h == null))
      if (g) {
        const f = Ia({ startOffset: A, endOffset: h, segmentId: o }, t);
        if (f == null)
          continue;
        const { offset: p, len: m, tableId: I } = f;
        p - c.cursor > 0 && i.push({
          t: G.RETAIN,
          len: p - c.cursor
        }), i.push({
          t: G.DELETE,
          len: m
        });
        const S = a.removeOp(["tableSource", I]);
        r.push(S), c.moveCursorTo(p + m);
      } else if (u) {
        const f = Ea({ startOffset: A, endOffset: h, segmentId: o }, t);
        if (f == null)
          continue;
        const { offset: p, rowIndexes: m, len: I, tableId: S } = f;
        p - c.cursor > 0 && i.push({
          t: G.RETAIN,
          len: p - c.cursor
        }), i.push({
          t: G.DELETE,
          len: I
        });
        for (const v of m.reverse()) {
          const R = a.removeOp(["tableSource", S, "tableRows", v]);
          r.push(R);
        }
        c.moveCursorTo(p + I);
      } else {
        const f = Cd({ startOffset: A, endOffset: h, segmentId: o }, t);
        if (f == null)
          continue;
        const { offsets: p } = f;
        for (const m of p) {
          const { retain: I, delete: S } = m;
          I - c.cursor > 0 && i.push({
            t: G.RETAIN,
            len: I - c.cursor
          }), i.push({
            t: G.DELETE,
            len: S
          }), c.moveCursorTo(I + S);
        }
      }
  }
  const d = Ae(e, o);
  return r.push(a.editOp(i.serialize(), d)), r.reduce((l, A) => W.compose(l, A), null);
}
function Bd(n, e, t, o, r) {
  let s = [];
  if (Array.isArray(n) && (n == null ? void 0 : n.length) !== 0 && (s = Od(n, t, r)), Array.isArray(e) && (e == null ? void 0 : e.length) !== 0) {
    const i = Td(e, t, o, r);
    s == null || s.length === 0 ? s = i : s = W.compose(
      s,
      W.transform(i, s, "right")
    );
  }
  return s;
}
const $t = {
  id: "doc.command.inner-cut",
  type: D.COMMAND,
  handler: (n, e) => {
    var f;
    const t = n.get(Y), o = n.get(T), r = n.get(L), { segmentId: s, textRanges: i, selections: a = t.getTextRanges(), rectRanges: c = t.getRectRanges() } = e;
    if ((!Array.isArray(a) || a.length === 0) && (!Array.isArray(c) || c.length === 0))
      return !1;
    const d = (f = r.getCurrentUniverDocInstance()) == null ? void 0 : f.getUnitId();
    if (!d)
      return !1;
    const l = r.getUniverDocInstance(d);
    if (l == null)
      return !1;
    const A = Ke(n, d);
    if (A == null)
      return !1;
    const h = A.getViewModel(), u = {
      id: X.id,
      params: {
        unitId: d,
        actions: [],
        textRanges: i
      }
    };
    return u.params.actions = Bd(a, c, l, h, s), !!o.syncExecuteCommand(u.id, u.params);
  }
};
var Ne = /* @__PURE__ */ ((n) => (n[n.LEFT = 0] = "LEFT", n[n.RIGHT = 1] = "RIGHT", n))(Ne || {});
const Md = "doc.command.insert-text", va = {
  id: Md,
  type: D.COMMAND,
  handler: async (n, e) => {
    var E;
    const t = n.get(T), { range: o, segmentId: r, body: s, unitId: i, cursorOffset: a } = e, c = n.get(Y), l = n.get(L).getUnit(i, _.UNIVER_DOC);
    if (l == null)
      return !1;
    const A = c.getActiveTextRange(), h = l.getSelfOrHeaderFooterModel((E = A == null ? void 0 : A.segmentId) != null ? E : "").getBody();
    if (h == null)
      return !1;
    const { startOffset: u, collapsed: g } = o, f = a != null ? a : s.dataStream.length, p = [
      {
        startOffset: u + f,
        endOffset: u + f,
        style: A == null ? void 0 : A.style,
        collapsed: g
      }
    ], m = {
      id: X.id,
      params: {
        unitId: i,
        actions: [],
        textRanges: p,
        debounce: !0
      }
    }, I = new Ie(), S = W.getInstance();
    if (g)
      u > 0 && I.push({
        t: G.RETAIN,
        len: u
      }), I.push({
        t: G.INSERT,
        body: s,
        len: s.dataStream.length
      });
    else {
      const b = ce.selection.delete([o], h, 0, s);
      I.push(...b);
    }
    m.params.textRanges = [{
      startOffset: u + f,
      endOffset: u + f,
      collapsed: g
    }];
    const v = Ae(l, r);
    return m.params.actions = S.editOp(I.serialize(), v), !!t.syncExecuteCommand(m.id, m.params);
  }
}, yn = {
  id: "doc.command.delete-text",
  type: D.COMMAND,
  handler: async (n, e) => {
    var R;
    const t = n.get(T), o = n.get(L), { range: r, segmentId: s, unitId: i, direction: a, len: c = 1 } = e, d = o.getUnit(i, _.UNIVER_DOC), l = d == null ? void 0 : d.getSelfOrHeaderFooterModel(s).getBody();
    if (d == null || l == null)
      return !1;
    const { startOffset: A } = r;
    let h = a === Ne.LEFT ? A - c : A, u = a === Ne.LEFT ? A - 1 : A + c - 1;
    const g = (R = l.customRanges) == null ? void 0 : R.find((E) => E.startIndex <= h && E.endIndex >= u);
    g != null && g.wholeEntity && (h = g.startIndex, u = Math.max(u, g.endIndex));
    const f = {
      id: X.id,
      params: {
        unitId: i,
        actions: [],
        textRanges: [{
          startOffset: h,
          endOffset: h,
          collapsed: !0
        }],
        debounce: !0
      }
    }, p = new Ie(), m = W.getInstance();
    p.push({
      t: G.RETAIN,
      len: h - 0
    }), p.push({
      t: G.DELETE,
      len: u - h + 1
    });
    const S = Ae(d, s);
    return f.params.actions = m.editOp(p.serialize(), S), !!t.syncExecuteCommand(f.id, f.params);
  }
}, Ca = {
  id: "doc.command.update-text",
  type: D.COMMAND,
  handler: async (n, e) => {
    const { range: t, segmentId: o, updateBody: r, coverType: s, unitId: i, textRanges: a } = e, c = n.get(T), l = n.get(L).getCurrentUniverDocInstance();
    if (l == null)
      return !1;
    const A = {
      id: X.id,
      params: {
        unitId: i,
        actions: [],
        textRanges: a
      }
    }, h = new Ie(), u = W.getInstance(), { startOffset: g, endOffset: f } = t;
    h.push({
      t: G.RETAIN,
      len: g
    }), h.push({
      t: G.RETAIN,
      body: r,
      len: f - g,
      coverType: s
    });
    const p = Ae(l, o);
    return A.params.actions = u.editOp(h.serialize(), p), !!c.syncExecuteCommand(A.id, A.params);
  }
};
function Qn(n) {
  var i, a, c, d;
  const e = n.get(L), o = n.get(Y).getActiveTextRange(), r = e.getCurrentUnitOfType(_.UNIVER_DOC);
  return !o || !o.collapsed || !r || o.segmentId ? !1 : ce.range.getParagraphsInRange(o, (a = (i = r.getBody()) == null ? void 0 : i.paragraphs) != null ? a : [], (d = (c = r.getBody()) == null ? void 0 : c.dataStream) != null ? d : "")[0];
}
const Zr = {
  id: "doc.command.delete-custom-block",
  type: D.COMMAND,
  handler: async (n, e) => {
    var x;
    const t = n.get(Y), o = n.get(L), r = n.get(T), s = t.getActiveTextRange(), i = o.getCurrentUniverDocInstance();
    if (s == null || i == null)
      return !1;
    const { direction: a, range: c, unitId: d, drawingId: l } = e, { startOffset: A, segmentId: h, style: u } = s, g = a === Ne.LEFT ? A - 1 : A, f = [
      {
        startOffset: g,
        endOffset: g,
        style: u
      }
    ], p = {
      id: X.id,
      params: {
        unitId: d,
        actions: [],
        textRanges: f,
        prevTextRanges: [c]
      }
    }, m = new Ie(), I = W.getInstance(), S = [];
    A > 0 && m.push({
      t: G.RETAIN,
      len: a === Ne.LEFT ? A - 1 : A
    }), m.push({
      t: G.DELETE,
      len: 1
    });
    const v = Ae(i, h);
    S.push(I.editOp(m.serialize(), v));
    const R = ((x = i.getDrawings()) != null ? x : {})[l], b = i.getDrawingsOrder().indexOf(l), y = I.removeOp(["drawings", l], R), C = I.removeOp(["drawingsOrder", b], l);
    return S.push(y), S.push(C), p.params.actions = S.reduce((M, w) => W.compose(M, w), null), !!r.syncExecuteCommand(p.id, p.params);
  }
}, Jr = {
  id: "doc.command.merge-two-paragraph",
  type: D.COMMAND,
  // eslint-disable-next-line max-lines-per-function
  handler: async (n, e) => {
    const t = n.get(Y), o = n.get(L), r = n.get(T), { direction: s, range: i } = e, a = t.getActiveTextRange(), c = t.getTextRanges();
    if (a == null || c == null)
      return !1;
    const { segmentId: d, style: l } = a, A = o.getCurrentUnitForType(_.UNIVER_DOC), h = A == null ? void 0 : A.getSelfOrHeaderFooterModel(d).getBody();
    if (A == null || h == null)
      return !1;
    const u = h.dataStream, g = a, f = A.getUnitId(), { startOffset: p, collapsed: m } = g;
    if (!m)
      return !1;
    const I = s === Ne.LEFT ? p : p + 1;
    let S, v;
    for (const F of h.paragraphs) {
      if (F.startIndex >= I) {
        v = F;
        break;
      }
      S = F;
    }
    if (S == null || v == null)
      return !1;
    const R = s === Ne.LEFT ? p - 1 : p, E = [
      {
        startOffset: R,
        endOffset: R,
        style: l
      }
    ], b = {
      id: X.id,
      params: {
        unitId: f,
        actions: [],
        textRanges: E,
        prevTextRanges: [i]
      }
    }, y = new Ie(), C = W.getInstance();
    S.startIndex > 0 && y.push({
      t: G.RETAIN,
      len: S.startIndex
    }), y.push({
      t: G.DELETE,
      len: 1
    }), v.startIndex > S.startIndex + 1 && y.push({
      t: G.RETAIN,
      len: v.startIndex - S.startIndex - 1
    });
    const B = Object.values(V), x = u[S.startIndex - 1];
    (x && !B.includes(x) || x === " ") && y.push({
      t: G.RETAIN,
      len: 1,
      coverType: nn.REPLACE,
      body: {
        dataStream: "",
        paragraphs: [
          {
            ...ue.deepClone(S),
            startIndex: 0
          }
        ]
      }
    });
    const M = Ae(A, d);
    return b.params.actions = C.editOp(y.serialize(), M), !!r.syncExecuteCommand(b.id, b.params);
  }
}, Ra = {
  id: "doc.command.remove-horizontal-line",
  type: D.COMMAND,
  // eslint-disable-next-line max-lines-per-function
  handler: async (n) => {
    var R;
    const e = n.get(Y), t = n.get(L), o = n.get(T), r = e.getActiveTextRange(), s = e.getTextRanges();
    if (r == null || s == null)
      return !1;
    const { segmentId: i, style: a } = r, c = t.getCurrentUnitForType(_.UNIVER_DOC), d = c == null ? void 0 : c.getSelfOrHeaderFooterModel(i).getBody();
    if (c == null || d == null)
      return !1;
    const l = r, A = c.getUnitId(), { startOffset: h, collapsed: u } = l;
    if (!u)
      return !1;
    const g = (R = d.paragraphs) == null ? void 0 : R.find((E) => E.startIndex === h - 1);
    if (g == null)
      return !1;
    const f = [
      {
        startOffset: h,
        endOffset: h,
        style: a
      }
    ], p = {
      id: X.id,
      params: {
        unitId: A,
        actions: [],
        textRanges: f
      }
    }, m = new Ie(), I = W.getInstance();
    g.startIndex > 0 && m.push({
      t: G.RETAIN,
      len: g.startIndex
    }), m.push({
      t: G.RETAIN,
      len: 1,
      coverType: nn.REPLACE,
      body: {
        dataStream: "",
        paragraphs: [
          {
            ...ue.deepClone({
              ...g,
              paragraphStyle: {
                ...g.paragraphStyle,
                borderBottom: void 0
              }
            }),
            startIndex: 0
          }
        ]
      }
    });
    const S = Ae(c, i);
    return p.params.actions = I.editOp(m.serialize(), S), !!o.syncExecuteCommand(p.id, p.params);
  }
};
function $r(n, e) {
  let t = 0;
  if (n == null || n.length === 0) {
    if (typeof e[0].startOffset == "number") {
      const o = e[0], { spanEntireRow: r, spanEntireTable: s } = o;
      s ? t = o.startOffset - 3 : r ? o.startRow > 0 ? t = o.startOffset - 6 : t = o.startOffset : t = e[0].startOffset;
    }
  } else if (n.length > 0 && e.length > 0) {
    const o = n[0], r = e[0];
    if (o.startOffset != null && r.startOffset != null) {
      if (o.startOffset < r.startOffset)
        t = o.startOffset;
      else if (o.startOffset >= r.startOffset) {
        const { spanEntireRow: s, spanEntireTable: i } = r;
        i ? t = r.startOffset - 3 : s && (t = r.startOffset - 6);
      }
    }
  }
  return t;
}
const Do = {
  id: "doc.command.delete-left",
  type: D.COMMAND,
  // eslint-disable-next-line max-lines-per-function, complexity
  handler: async (n) => {
    var C, B, x, M, w, F;
    const e = n.get(Y), t = n.get(L), o = n.get(T);
    let r = !0;
    const s = t.getCurrentUniverDocInstance();
    if (s == null)
      return !1;
    const i = s.getUnitId(), a = Ke(n, i), c = e.getActiveTextRange(), d = e.getRectRanges(), l = e.getTextRanges(), A = a == null ? void 0 : a.getSkeleton();
    if (A == null)
      return !1;
    if (d != null && d.length) {
      const P = $r(l, d), N = d[0].segmentId, ee = [
        {
          startOffset: P,
          endOffset: P
        }
      ];
      return o.executeCommand($t.id, {
        segmentId: N,
        textRanges: ee
      });
    }
    if (c == null || l == null)
      return !1;
    const { segmentId: h, style: u, segmentPage: g } = c, f = s.getSelfOrHeaderFooterModel(h).getBody();
    if (f == null)
      return !1;
    const p = c, { startOffset: m, collapsed: I } = p, S = A.findNodeByCharIndex(m, h, g), v = nl(S), R = ol(S, f);
    let E = m;
    const b = A.findNodeByCharIndex(m - 1, h, g);
    if (rl(S) && b !== S && (v === !0 || R === !0) && I) {
      const P = sl(S, f);
      if (P == null)
        return !1;
      const N = P == null ? void 0 : P.startIndex, ee = { startIndex: 0 }, $ = P.paragraphStyle;
      if (v === !0) {
        const H = P.paragraphStyle;
        if (H) {
          ee.paragraphStyle = H;
          const { hanging: k } = H;
          k && (ee.paragraphStyle.indentStart = k, ee.paragraphStyle.hanging = void 0);
        }
      } else if (R === !0) {
        const H = P.bullet;
        H && (ee.bullet = H), $ != null && (ee.paragraphStyle = { ...$ }, delete ee.paragraphStyle.hanging, delete ee.paragraphStyle.indentStart);
      }
      const U = [
        {
          startOffset: E,
          endOffset: E,
          style: u
        }
      ];
      r = await o.executeCommand(Ca.id, {
        unitId: s.getUnitId(),
        updateBody: {
          dataStream: "",
          paragraphs: [{ ...ee }]
        },
        range: {
          startOffset: N,
          endOffset: N + 1
        },
        textRanges: U,
        coverType: nn.REPLACE,
        segmentId: h
      });
    } else if (I === !0) {
      if (b == null)
        return !0;
      if (b.content === "\r") {
        const P = (C = f.paragraphs) == null ? void 0 : C.find((N) => N.startIndex === m - 1);
        (B = P == null ? void 0 : P.paragraphStyle) != null && B.borderBottom ? r = await o.executeCommand(Ra.id) : r = await o.executeCommand(Jr.id, {
          direction: Ne.LEFT,
          range: p
        });
      } else if (b.streamType === "\b") {
        const P = (M = s.getSnapshot().drawings) == null ? void 0 : M[(x = b.drawingId) != null ? x : ""];
        if (P == null)
          return !0;
        const N = (F = (w = s.getBody()) == null ? void 0 : w.customBlocks) == null ? void 0 : F.find(($) => $.blockId === b.drawingId);
        if (P.layoutType === Ro.INLINE || (N == null ? void 0 : N.blockType) === Pc.CUSTOM) {
          const $ = s.getUnitId();
          r = await o.executeCommand(Zr.id, {
            direction: Ne.LEFT,
            range: c,
            unitId: $,
            drawingId: b.drawingId
          });
        } else {
          const $ = A.findNodeByCharIndex(m - 2);
          if ($ == null)
            return !0;
          E -= b.count, E -= $.count;
          const U = [
            {
              startOffset: E,
              endOffset: E,
              style: u
            }
          ];
          r = await o.executeCommand(yn.id, {
            unitId: s.getUnitId(),
            range: {
              ...c,
              startOffset: c.startOffset - 1,
              endOffset: c.endOffset - 1
            },
            segmentId: h,
            direction: Ne.LEFT,
            len: $.count,
            textRanges: U
          });
        }
      } else
        E -= b.count, r = await o.executeCommand(yn.id, {
          unitId: s.getUnitId(),
          range: p,
          segmentId: h,
          direction: Ne.LEFT,
          len: b.count
        });
    } else {
      const P = ya(p, [p]);
      r = await o.executeCommand($t.id, {
        segmentId: h,
        textRanges: P,
        selections: [p]
      });
    }
    return r;
  }
}, ba = {
  id: "doc.command.delete-right",
  type: D.COMMAND,
  // eslint-disable-next-line max-lines-per-function, complexity
  handler: async (n) => {
    var S, v;
    const e = n.get(Y), o = n.get(L).getCurrentUniverDocInstance();
    if (!o)
      return !1;
    const r = Ke(n, o.getUnitId()), s = n.get(T), i = e.getActiveTextRange(), a = e.getRectRanges(), c = e.getTextRanges(), d = r == null ? void 0 : r.getSkeleton();
    if (a != null && a.length) {
      const R = $r(c, a), E = a[0].segmentId, b = [
        {
          startOffset: R,
          endOffset: R
        }
      ];
      return s.executeCommand($t.id, {
        segmentId: E,
        textRanges: b
      });
    }
    if (i == null || d == null || c == null)
      return !1;
    const { segmentId: l, style: A, segmentPage: h } = i, u = o == null ? void 0 : o.getSelfOrHeaderFooterModel(l).getBody();
    if (!o || !u)
      return !1;
    const g = i, { startOffset: f, endOffset: p, collapsed: m } = g;
    if (f === u.dataStream.length - 2 && m)
      return !0;
    let I = !1;
    if (m === !0) {
      const R = d.findNodeByCharIndex(f, l, h), E = d.findNodeByCharIndex(f + 1);
      if (R.streamType === V.PARAGRAPH && (E == null ? void 0 : E.streamType) === V.SECTION_BREAK)
        return !1;
      if (R.content === "\r")
        I = await s.executeCommand(Jr.id, {
          direction: Ne.RIGHT,
          range: i
        });
      else if (R.streamType === "\b") {
        const b = (v = o.getSnapshot().drawings) == null ? void 0 : v[(S = R.drawingId) != null ? S : ""];
        if (b == null)
          return !0;
        if (b.layoutType === Ro.INLINE) {
          const C = o.getUnitId();
          I = await s.executeCommand(Zr.id, {
            direction: Ne.RIGHT,
            range: i,
            unitId: C,
            drawingId: R.drawingId
          });
        } else {
          if (E == null)
            return !0;
          const C = [
            {
              startOffset: f + 1,
              endOffset: f + 1,
              style: A
            }
          ];
          I = await s.executeCommand(yn.id, {
            unitId: o.getUnitId(),
            range: {
              ...i,
              startOffset: f + 1,
              endOffset: p + 1
            },
            segmentId: l,
            direction: Ne.RIGHT,
            textRanges: C,
            len: E.count
          });
        }
      } else {
        const b = [
          {
            startOffset: f,
            endOffset: f,
            style: A
          }
        ];
        I = await s.executeCommand(yn.id, {
          unitId: o.getUnitId(),
          range: g,
          segmentId: l,
          direction: Ne.RIGHT,
          textRanges: b,
          len: R.count
        });
      }
    } else {
      const R = ya(g, [g]);
      I = await s.executeCommand($t.id, {
        segmentId: l,
        textRanges: R,
        selections: [g]
      });
    }
    return I;
  }
};
function ya(n, e) {
  let t = n.endOffset;
  for (const r of e) {
    const { startOffset: s, endOffset: i } = r;
    s == null || i == null || i <= n.endOffset && (t -= i - s);
  }
  return [
    {
      startOffset: t,
      endOffset: t,
      style: n.style
    }
  ];
}
const es = {
  id: "doc.command.delete-current-paragraph",
  type: D.COMMAND,
  handler: async (n) => {
    var d, l;
    const e = n.get(L), t = n.get(T), o = e.getCurrentUnitOfType(_.UNIVER_DOC);
    if (!o)
      return !1;
    const r = (l = (d = o.getBody()) == null ? void 0 : d.dataStream) != null ? l : "", s = Qn(n);
    if (!s)
      return !1;
    const i = ce.selection.delete(
      [{
        startOffset: s.paragraphStart,
        endOffset: r[s.paragraphEnd + 1] === `
` ? s.paragraphEnd : s.paragraphEnd + 1,
        collapsed: !1
      }],
      o.getBody(),
      0,
      void 0,
      !0
    ), a = Ae(o), c = {
      unitId: o.getUnitId(),
      actions: W.getInstance().editOp(i, a),
      textRanges: [{
        startOffset: s.paragraphStart,
        endOffset: s.paragraphStart,
        collapsed: !0
      }]
    };
    return t.syncExecuteCommand(X.id, c);
  }
}, _d = 10, Dd = 6;
function wd() {
  return ge(Dd);
}
function Pd(n) {
  const e = n.match(/data-copy-id="([^\s]+)"/);
  return e && e[1] ? e[1] : null;
}
class Nd {
  constructor() {
    O(this, "_cache", new Nc(_d));
  }
  set(e, t) {
    this._cache.set(e, t);
  }
  get(e) {
    return this._cache.get(e);
  }
  clear() {
    this._cache.clear();
  }
}
const Yo = new Nd();
function ts(n) {
  const e = n.style, t = {}, o = n.tagName.toLowerCase();
  switch (o) {
    case "b":
    case "em":
    case "strong": {
      t.bl = z.TRUE;
      break;
    }
    case "s": {
      t.st = {
        s: z.TRUE
      };
      break;
    }
    case "u": {
      t.ul = {
        s: z.TRUE
      };
      break;
    }
    case "i": {
      t.it = z.TRUE;
      break;
    }
    case "sub":
    case "sup": {
      t.va = o === "sup" ? Ve.SUPERSCRIPT : Ve.SUBSCRIPT;
      break;
    }
  }
  for (let r = 0; r < e.length; r++) {
    const s = e[r], i = e.getPropertyValue(s);
    switch (s) {
      case "font-family": {
        t.ff = i.replace(/^"/g, "").replace(/"$/g, "");
        break;
      }
      case "font-size": {
        const a = Number.parseInt(i);
        Number.isNaN(a) || (i.endsWith("pt") ? t.fs = a : i.endsWith("px") && (t.fs = il(a)));
        break;
      }
      case "font-style": {
        i === "italic" && (t.it = z.TRUE);
        break;
      }
      case "font-weight": {
        (Number(i) > 400 || String(i) === "bold") && (t.bl = z.TRUE);
        break;
      }
      case "text-decoration": {
        /underline/.test(i) ? t.ul = {
          s: z.TRUE
        } : /overline/.test(i) ? t.ol = {
          s: z.TRUE
        } : /line-through/.test(i) && (t.st = {
          s: z.TRUE
        });
        break;
      }
      case "color": {
        try {
          const a = new Qs(i);
          a.isValid && (t.cl = {
            rgb: a.toRgbString()
          });
        } catch {
        }
        break;
      }
      case "background-color": {
        const a = new Qs(i);
        a.isValid && (t.bg = {
          rgb: a.toRgbString()
        });
        break;
      }
    }
  }
  return t;
}
function Ld(n) {
  const e = new DOMParser(), t = `<x-univer id="univer-root">${n}</x-univer>`;
  return e.parseFromString(t, "text/html").querySelector("#univer-root");
}
function ei(n, e) {
  const t = n.tagName.toLowerCase();
  return typeof e == "string" ? t === e : Array.isArray(e) ? e.some((o) => o === t) : e(n);
}
const ti = 660, vo = class vo {
  constructor() {
    O(this, "_tableCache", []);
    O(this, "_styleCache", /* @__PURE__ */ new Map());
    O(this, "_styleRules", []);
    O(this, "_afterProcessRules", []);
  }
  static use(e) {
    if (this._pluginList.includes(e))
      throw new Error(`Univer paste plugin ${e.name} already added`);
    this._pluginList.push(e);
  }
  convert(e, t = {}) {
    var a;
    const o = vo._pluginList.find((c) => c.checkPasteType(e)), r = Ld(e), i = {
      body: {
        dataStream: "",
        paragraphs: [],
        sectionBreaks: [],
        tables: [],
        textRuns: [],
        customBlocks: []
      },
      tableSource: {},
      id: (a = t == null ? void 0 : t.unitId) != null ? a : ""
    };
    return o && (this._styleRules = [...o.stylesRules], this._afterProcessRules = [...o.afterProcessRules]), this._tableCache = [], this._styleCache.clear(), this._process(null, r.childNodes, i), this._styleCache.clear(), this._styleRules = [], this._afterProcessRules = [], i;
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _process(e, t, o) {
    var s, i, a, c;
    const r = o.body;
    for (const d of t)
      if (d.nodeType === Node.TEXT_NODE) {
        if (((s = d.nodeValue) == null ? void 0 : s.trim()) === "")
          continue;
        const l = (i = d.nodeValue) == null ? void 0 : i.replace(/[\r\n]/g, "");
        let A;
        e && this._styleCache.has(e) && (A = this._styleCache.get(e)), r.dataStream += l, A && Object.getOwnPropertyNames(A).length && r.textRuns.push({
          st: r.dataStream.length - l.length,
          ed: r.dataStream.length,
          ts: A
        });
      } else if (d.nodeName === "IMG") {
        const l = d, A = l.dataset.imageSourceType, h = A === Wr.UUID ? l.dataset.source : l.src;
        if (h && A) {
          const u = Number(l.dataset.width || 100), g = Number(l.dataset.height || 100), f = Number(l.dataset.docTransformWidth || u), p = Number(l.dataset.docTransformHeight || g), m = ge(6);
          (c = (a = o.body) == null ? void 0 : a.customBlocks) == null || c.push({ startIndex: r.dataStream.length, blockId: m }), r.dataStream += "\b", o.drawings || (o.drawings = {}), o.drawings[m] = {
            drawingId: m,
            title: "",
            description: "",
            imageSourceType: A,
            source: h,
            transform: { width: u, height: g, left: 0 },
            docTransform: {
              size: { width: f, height: p },
              angle: 0,
              positionH: {
                relativeFrom: Co.PAGE,
                posOffset: 0
              },
              positionV: {
                relativeFrom: gt.PARAGRAPH,
                posOffset: 0
              }
            },
            layoutType: Ro.INLINE,
            drawingType: Nr.DRAWING_IMAGE,
            unitId: o.id || "",
            subUnitId: o.id || ""
          };
        }
      } else {
        if (Lc.includes(d.nodeName.toLowerCase()))
          continue;
        if (d.nodeType === Node.ELEMENT_NODE) {
          const l = d, A = this._processBeforeLink(l, o), h = e ? this._styleCache.get(e) : {}, u = this._styleRules.find(({ filter: m }) => ei(d, m)), g = u ? u.getStyle(d) : ts(d);
          this._styleCache.set(d, { ...h, ...g });
          const { childNodes: f } = d;
          this._processBeforeTable(d, o), this._process(d, f, o), this._processAfterTable(d, o);
          const p = this._afterProcessRules.find(
            ({ filter: m }) => ei(d, m)
          );
          p && p.handler(o, d), this._processAfterLink(l, o, A);
        }
      }
  }
  _processBeforeTable(e, t) {
    var s;
    const o = e.tagName.toUpperCase(), r = t.body;
    switch (o) {
      case "TABLE": {
        r.dataStream[r.dataStream.length - 1] !== "\r" && (r.dataStream += "\r", r.paragraphs == null && (r.paragraphs = []), (s = r.paragraphs) == null || s.push({
          startIndex: r.dataStream.length - 1
        }));
        const i = ma(0, 0, ti);
        this._tableCache.push({
          table: i,
          startIndex: r.dataStream.length
        }), r.dataStream += V.TABLE_START;
        break;
      }
      case "TR": {
        const i = qr(0);
        this._tableCache[this._tableCache.length - 1].table.tableRows.push(i), r.dataStream += V.TABLE_ROW_START;
        break;
      }
      case "TD": {
        const i = Kr(), a = this._tableCache[this._tableCache.length - 1].table;
        a.tableRows[a.tableRows.length - 1].tableCells.push(i), r.dataStream += V.TABLE_CELL_START;
        break;
      }
    }
  }
  _processAfterTable(e, t) {
    var i, a;
    const o = e.tagName.toUpperCase(), r = t.body;
    t.tableSource == null && (t.tableSource = {}), r.tables == null && (r.tables = []), r.sectionBreaks == null && (r.sectionBreaks = []);
    const { tableSource: s } = t;
    switch (o) {
      case "TABLE": {
        const c = this._tableCache.pop(), { startIndex: d, table: l } = c, A = l.tableRows[0].tableCells.length, h = Xr(ti / A), u = [...new Array(A).fill(null).map(() => ue.deepClone(h))];
        l.tableColumns = u, s[l.tableId] = l, r.dataStream += V.TABLE_END, r.tables.push({
          startIndex: d,
          endIndex: r.dataStream.length,
          tableId: l.tableId
        });
        break;
      }
      case "TR": {
        r.dataStream += V.TABLE_ROW_END;
        break;
      }
      case "TD": {
        r.dataStream[r.dataStream.length - 1] !== "\r" && ((i = r.paragraphs) == null || i.push({
          startIndex: r.dataStream.length
        }), r.dataStream += "\r"), (a = r.sectionBreaks) == null || a.push({
          startIndex: r.dataStream.length
        }), r.dataStream += `
${V.TABLE_CELL_END}`;
        break;
      }
    }
  }
  _processBeforeLink(e, t) {
    return t.body.dataStream.length;
  }
  _processAfterLink(e, t, o) {
    var i, a;
    const r = t.body, s = e;
    s.tagName.toUpperCase() === "A" && (r.customRanges = (i = r.customRanges) != null ? i : [], r.customRanges.push({
      startIndex: o,
      endIndex: r.dataStream.length - 1,
      rangeId: (a = s.dataset.rangeid) != null ? a : ge(),
      rangeType: Lr.HYPERLINK,
      properties: { url: s.href }
    }));
  }
};
O(vo, "_pluginList", []);
let en = vo;
const Qd = {
  name: "univer-doc-paste-plugin-lark",
  checkPasteType(n) {
    return /lark-record-clipboard/i.test(n);
  },
  // TODO: @JOCS, support inline code copy from lark.
  stylesRules: [
    {
      filter: ["s"],
      getStyle(n) {
        const e = ts(n);
        return {
          st: {
            s: z.TRUE
          },
          ...e
        };
      }
    }
  ],
  afterProcessRules: [
    {
      filter(n) {
        return n.tagName === "DIV" && /ace-line/i.test(n.className);
      },
      handler(n) {
        const e = n.body;
        e.paragraphs == null && (e.paragraphs = []), e.paragraphs.push({
          startIndex: e.dataStream.length
        }), e.dataStream += "\r";
      }
    }
  ]
};
function xa(n) {
  const e = n.style, t = {};
  for (let o = 0; o < e.length; o++) {
    const r = e[o], s = e.getPropertyValue(r);
    switch (r) {
      case "margin-top": {
        const i = Number.parseInt(s);
        t.spaceAbove = { v: /pt/.test(s) ? Vs(i) : i };
        break;
      }
      case "margin-bottom": {
        const i = Number.parseInt(s);
        t.spaceBelow = { v: /pt/.test(s) ? Vs(i) : i };
        break;
      }
      case "line-height": {
        let i = Number.parseFloat(s);
        s.endsWith("%") && (i /= 100), t.lineSpacing = i;
        break;
      }
    }
  }
  return Object.getOwnPropertyNames(t).length ? t : null;
}
const Ud = {
  name: "univer-doc-paste-plugin-univer",
  checkPasteType(n) {
    return /UniverNormal/i.test(n);
  },
  stylesRules: [],
  afterProcessRules: [
    {
      filter(n) {
        return n.tagName === "P" && /UniverNormal/i.test(n.className);
      },
      handler(n, e) {
        const t = n.body;
        t.paragraphs == null && (t.paragraphs = []);
        const o = {
          startIndex: t.dataStream.length
        }, r = xa(e);
        r && (o.paragraphStyle = r), t.paragraphs.push(o), t.dataStream += "\r";
      }
    }
  ]
}, Fd = {
  name: "univer-doc-paste-plugin-word",
  checkPasteType(n) {
    return /word|mso/i.test(n);
  },
  stylesRules: [
    {
      filter: ["b"],
      getStyle(n) {
        const e = ts(n);
        return { bl: z.TRUE, ...e };
      }
    }
  ],
  afterProcessRules: [
    {
      filter(n) {
        return n.tagName === "P";
      },
      handler(n, e) {
        const t = n.body;
        t.paragraphs == null && (t.paragraphs = []);
        const o = {
          startIndex: t.dataStream.length
        }, r = xa(e);
        r && (o.paragraphStyle = r), t.paragraphs.push(o), t.dataStream += "\r";
      }
    }
  ]
};
function Hd(n) {
  var o, r;
  const e = (s) => {
    let i = "";
    return Object.keys(s).forEach((a) => {
      s[a] !== void 0 && (i += ` ${a}=${s[a]}`);
    }), i;
  }, t = {
    "data-doc-transform-height": n.docTransform.size.height,
    "data-doc-transform-width": n.docTransform.size.width,
    "data-width": (o = n.transform) == null ? void 0 : o.width,
    "data-height": (r = n.transform) == null ? void 0 : r.height,
    "data-image-source-type": n.imageSourceType,
    "data-source": n.imageSourceType === Wr.UUID ? n.source : void 0,
    src: n.source
  };
  return `<img  ${e(t)}></img>`;
}
function ni(n, e) {
  const { st: t, ed: o, ts: r = {} } = e, { ff: s, fs: i, it: a, bl: c, ul: d, st: l, ol: A, bg: h, cl: u, va: g } = r;
  let f = n.slice(t, o);
  const p = [];
  return a === z.TRUE && (f = `<i>${f}</i>`), g === Ve.SUPERSCRIPT ? f = `<sup>${f}</sup>` : g === Ve.SUBSCRIPT && (f = `<sub>${f}</sub>`), (d == null ? void 0 : d.s) === z.TRUE && (f = `<u>${f}</u>`), (l == null ? void 0 : l.s) === z.TRUE && (f = `<s>${f}</s>`), c === z.TRUE && (f = `<strong>${f}</strong>`), s && p.push(`font-family: ${s}`), u && p.push(`color: ${u.rgb}`), i && p.push(`font-size: ${i}pt`), A && p.push("text-decoration: overline"), h && p.push(`background: ${h.rgb}`), p.length ? `<span style="${p.join("; ")};">${f}</span>` : f;
}
function Ko(n, e, t) {
  const { dataStream: o, textRuns: r = [] } = n;
  if (e === t)
    return "";
  let s = e;
  const i = [];
  for (const a of r) {
    const { st: c, ed: d } = a;
    ue.hasIntersectionBetweenTwoRanges(e, t, c, d) && (c > s ? (i.push(o.slice(s, c)), i.push(ni(o, {
      ...a,
      ed: Math.min(d, t)
    }))) : i.push(ni(o, {
      ...a,
      st: s,
      ed: Math.min(d, t)
    }))), s = Math.max(e, Math.min(d, t));
  }
  return s !== t && i.push(o.slice(s, t)), i.join("");
}
function kd(n, e, t) {
  const o = n.body, r = n.drawings || {}, { customRanges: s = [], customBlocks: i = [] } = o || {}, a = [...i], c = s.filter((u) => u.startIndex >= e && u.endIndex <= t);
  let d = e, l = "";
  const A = (u, g) => {
    let f = "", p = 0, m = u, I = a.findIndex((S) => u <= S.startIndex && g >= S.startIndex);
    if (I === -1)
      return f = Ko(o, u, g), { sliceHtml: f, customBlockLength: p };
    for (; I !== -1; ) {
      const S = a[I];
      a.splice(I, 1), f += Ko(o, m, S.startIndex);
      const v = r[S.blockId];
      if (v)
        switch (v.drawingType) {
          case Nr.DRAWING_IMAGE: {
            f += Hd(v), p++;
            break;
          }
        }
      m = S.startIndex + 1, I = a.findIndex((R) => m <= R.startIndex && g >= R.startIndex);
    }
    return f = f + Ko(o, m, g + 1), { sliceHtml: f, customBlockLength: p };
  };
  c.forEach((u) => {
    var v, R;
    const { startIndex: g, endIndex: f, rangeType: p, rangeId: m } = u, I = A(d, g);
    l += I.sliceHtml;
    const S = A(g, f + 1);
    switch (p) {
      case Lr.HYPERLINK: {
        l += `<a data-rangeid="${m}" href="${(R = (v = u.properties) == null ? void 0 : v.url) != null ? R : ""}">${S.sliceHtml}</a>`;
        break;
      }
      default: {
        l += S.sliceHtml;
        break;
      }
    }
    d = f + 1 + (I.customBlockLength + S.customBlockLength);
  });
  const h = A(d, t);
  return l += h.sliceHtml, l;
}
function Vd(n) {
  const e = n.body || {}, { paragraphs: t = [], sectionBreaks: o = [] } = e;
  let { dataStream: r = "" } = e;
  r.endsWith(`\r
`) || (r += `\r
`, t.push({
    startIndex: r.length - 2
  }), o.push({
    startIndex: r.length - 1
  }), e.dataStream = r, e.paragraphs = t, e.sectionBreaks = o);
  const s = { html: "" }, i = al(r).sectionList;
  for (const a of i)
    Kt(a, n, s);
  return s.html;
}
function Kt(n, e, t) {
  var o, r;
  switch (n.nodeType) {
    case sn.SECTION_BREAK: {
      for (const s of n.children)
        Kt(s, e, t);
      break;
    }
    case sn.PARAGRAPH: {
      const { children: s, startIndex: i, endIndex: a } = n, c = (r = (o = e.body) == null ? void 0 : o.paragraphs.find((g) => g.startIndex === a)) != null ? r : {}, { paragraphStyle: d = {} } = c, { spaceAbove: l, spaceBelow: A, lineSpacing: h } = d, u = [];
      if (l != null && (typeof l == "number" ? u.push(`margin-top: ${l}px`) : u.push(`margin-top: ${l.v}px`)), A != null && (typeof A == "number" ? u.push(`margin-bottom: ${A}px`) : u.push(`margin-bottom: ${A.v}px`)), h != null && u.push(`line-height: ${h}`), t.html += `<p class="UniverNormal" ${u.length ? `style="${u.join("; ")};"` : ""}>`, s.length)
        for (const g of s)
          Kt(g, e, t);
      t.html += `${kd(e, i, a)}</p>`;
      break;
    }
    case sn.TABLE: {
      const { children: s } = n;
      t.html += '<table class="UniverTable" style="width: 100%; border-collapse: collapse;"><tbody>';
      for (const i of s)
        Kt(i, e, t);
      t.html += "</tbody></table>";
      break;
    }
    case sn.TABLE_ROW: {
      const { children: s } = n;
      t.html += '<tr class="UniverTableRow">';
      for (const i of s)
        Kt(i, e, t);
      t.html += "</tr>";
      break;
    }
    case sn.TABLE_CELL: {
      const { children: s } = n;
      t.html += '<td class="UniverTableCell">';
      for (const i of s)
        Kt(i, e, t);
      t.html += "</td>";
      break;
    }
    default:
      throw new Error(`Unknown node type: ${n.nodeType}`);
  }
}
class Wd {
  convert(e) {
    if (e.length === 0)
      throw new Error("The bodyList length at least to be 1");
    let t = "";
    for (const o of ue.deepClone(e))
      t += Vd(o);
    return t;
  }
}
var jd = Object.getOwnPropertyDescriptor, zd = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? jd(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, cn = (n, e) => (t, o) => e(t, o, n);
en.use(Fd);
en.use(Qd);
en.use(Ud);
function oi(n, e, t) {
  var s, i, a;
  const o = Ki(n, e, t + 2), r = V.TABLE_START + V.TABLE_ROW_START + V.TABLE_CELL_START + o.dataStream + V.TABLE_CELL_END + V.TABLE_ROW_END + V.TABLE_END;
  return o.dataStream = r, (s = o.textRuns) == null || s.forEach((c) => {
    const { st: d, ed: l } = c;
    c.st = d + 3, c.ed = l + 3;
  }), (i = o.tables) == null || i.forEach((c) => {
    const { startIndex: d, endIndex: l } = c;
    c.startIndex = d + 3, c.endIndex = l + 3;
  }), (a = o.paragraphs) == null || a.forEach((c) => {
    const { startIndex: d } = c;
    c.startIndex = d + 3;
  }), o;
}
const Lt = Yi("doc.clipboard-service");
let ur = class extends me {
  constructor(e, t, o, r, s) {
    super();
    O(this, "_clipboardHooks", []);
    O(this, "_htmlToUDM", new en());
    O(this, "_umdToHtml", new Wd());
    this._univerInstanceService = e, this._logService = t, this._commandService = o, this._clipboardInterfaceService = r, this._docSelectionManagerService = s;
  }
  async copy(e = ir.copy, t) {
    var a, c;
    const { newSnapshotList: o = [], needCache: r = !1, snapshot: s, ranges: i } = (a = this._getDocumentBodyInRanges(e, t)) != null ? a : {};
    if (o.length === 0 || s == null)
      return !1;
    try {
      const d = !!((c = i == null ? void 0 : i[0]) != null && c.segmentId);
      this._setClipboardData(o, !d && r);
    } catch (d) {
      return this._logService.error("[DocClipboardService] copy failed", d), !1;
    }
    return !0;
  }
  async cut(e) {
    return this._cut(e);
  }
  async paste(e) {
    const t = await this._genDocDataFromClipboardItems(e);
    return this._paste(t);
  }
  async legacyPaste(e) {
    let { html: t, text: o, files: r } = e;
    const s = this._univerInstanceService.getCurrentUnitForType(_.UNIVER_DOC), i = (s == null ? void 0 : s.getUnitId()) || "";
    if (!t && !o && r.length && (t = await this._createImagePasteHtml(r)), !t && !o)
      return this._logService.warn("[DocClipboardController] html and text cannot be both empty!"), !1;
    const a = this._genDocDataFromHtmlAndText(t, o, i);
    if (i === bo)
      if (o) {
        const c = ce.transform.fromPlainText(o);
        return this._paste({ body: c });
      } else
        a.body.textRuns = [];
    return this._paste(a);
  }
  async _cut(e) {
    var a, c, d, l, A;
    const t = (c = (a = e == null ? void 0 : e.filter((h) => h.rangeType === He.TEXT)) != null ? a : this._docSelectionManagerService.getTextRanges()) != null ? c : [], o = (l = (d = e == null ? void 0 : e.filter((h) => h.rangeType === He.RECT)) != null ? d : this._docSelectionManagerService.getRectRanges()) != null ? l : [], {
      segmentId: r,
      endOffset: s,
      style: i
    } = (A = t[0]) != null ? A : {};
    if (r == null && this._logService.error("[DocClipboardController] segmentId is not existed"), t.length === 0 && o.length === 0)
      return !1;
    this.copy(ir.cut, e);
    try {
      let h = 0;
      if (o.length > 0)
        h = $r(t, o);
      else if (s != null) {
        h = s;
        for (const g of t) {
          const { startOffset: f, endOffset: p } = g;
          f == null || p == null || p <= s && (h -= p - f);
        }
      }
      const u = [
        {
          startOffset: h,
          endOffset: h,
          style: i
        }
      ];
      return this._commandService.executeCommand($t.id, {
        segmentId: r,
        textRanges: u,
        rectRanges: o,
        selections: t
      });
    } catch {
      return this._logService.error("[DocClipboardController] cut content failed"), !1;
    }
  }
  async _paste(e) {
    var l, A, h;
    const { body: t } = e;
    if (t == null)
      return !1;
    let o = Qc(t);
    if (!((l = this._univerInstanceService.getCurrentUnitForType(_.UNIVER_DOC)) == null ? void 0 : l.getUnitId()))
      return !1;
    this._clipboardHooks.forEach((u) => {
      u.onBeforePaste && (o = u.onBeforePaste(o));
    }), o.customRanges = (A = o.customRanges) == null ? void 0 : A.map(ce.customRange.copyCustomRange), (h = o.paragraphs) == null || h.forEach((u) => {
      var g;
      (g = u.paragraphStyle) != null && g.headingId && (u.paragraphStyle.headingId = ge(6));
    });
    const s = this._docSelectionManagerService.getActiveTextRange(), { segmentId: i, endOffset: a, style: c } = s || {}, d = this._docSelectionManagerService.getTextRanges();
    if (i == null && this._logService.error("[DocClipboardController] segmentId does not exist!"), a == null || d == null)
      return !1;
    try {
      let u = a;
      for (const f of d) {
        const { startOffset: p, endOffset: m } = f;
        p == null || m == null || m <= a && (u += o.dataStream.length - (m - p));
      }
      const g = [
        {
          startOffset: u,
          endOffset: u,
          style: c
        }
      ];
      return this._commandService.executeCommand(Sa.id, {
        doc: {
          ...e,
          body: o
        },
        segmentId: i,
        textRanges: g
      });
    } catch {
      return this._logService.error("[DocClipboardController]", "clipboard is empty."), !1;
    }
  }
  async _setClipboardData(e, t = !0) {
    var i, a, c, d;
    const o = wd(), r = (e.length > 1 ? e.map((l) => {
      var A;
      return ((A = l.body) == null ? void 0 : A.dataStream) || "";
    }).join(`
`) : ((i = e[0].body) == null ? void 0 : i.dataStream) || "").replaceAll(V.TABLE_START, "").replaceAll(V.TABLE_END, "").replaceAll(V.TABLE_ROW_START, "").replaceAll(V.TABLE_ROW_END, "").replaceAll(V.TABLE_CELL_START, "").replaceAll(V.TABLE_CELL_END, "").replaceAll(`\r
`, " ");
    let s = this._umdToHtml.convert(e);
    if (e.length === 1 && t) {
      s = s.replace(/(<[a-z]+)/, (h, u) => `${u} data-copy-id="${o}"`);
      const l = e[0], A = { body: l.body };
      if ((c = (a = l.body) == null ? void 0 : a.customBlocks) != null && c.length) {
        A.drawings = {};
        for (const h of l.body.customBlocks) {
          const { blockId: u } = h, g = (d = l.drawings) == null ? void 0 : d[u];
          if (g) {
            const f = ge(6);
            h.blockId = f, A.drawings[f] = {
              ...ue.deepClone(g),
              drawingId: f
            };
          }
        }
      }
      Yo.set(o, A);
    }
    return this._clipboardInterfaceService.write(r, s);
  }
  addClipboardHook(e) {
    return this._clipboardHooks.push(e), Mn(() => {
      const t = this._clipboardHooks.indexOf(e);
      t > -1 && this._clipboardHooks.splice(t, 1);
    });
  }
  _getDocumentBodyInRanges(e, t) {
    var l;
    const o = this._univerInstanceService.getCurrentUniverDocInstance(), r = t != null ? t : this._docSelectionManagerService.getDocRanges(), s = [];
    let i = !0;
    if (o == null || r.length === 0)
      return;
    const a = r[0].segmentId, c = (l = o == null ? void 0 : o.getSelfOrHeaderFooterModel(a)) == null ? void 0 : l.getBody(), d = o.getSnapshot();
    if (c != null) {
      for (const A of r) {
        const { startOffset: h, endOffset: u, collapsed: g, rangeType: f } = A;
        if (g || h == null || u == null)
          continue;
        if (f === He.RECT) {
          i = !1;
          const { spanEntireRow: I } = A;
          let S;
          S = oi(c, h, u), s.push(S);
          continue;
        }
        const p = { startOffset: h, endOffset: u }, m = o.getSelfOrHeaderFooterModel(a).sliceBody(p.startOffset, p.endOffset, e);
        m != null && s.push(m);
      }
      return {
        newSnapshotList: s.map((A) => ({ ...d, body: A })),
        needCache: i,
        snapshot: d,
        ranges: r
      };
    }
  }
  async _genDocDataFromClipboardItems(e) {
    try {
      let t = "", o = "";
      const r = [];
      for (const s of e)
        for (const i of s.types)
          switch (i) {
            case ia: {
              o = await s.getType(i).then((a) => a && a.text());
              break;
            }
            case sa: {
              t = await s.getType(i).then((a) => a && a.text());
              break;
            }
            case Cl:
            case vl:
            case Sl:
            case Il: {
              const a = await s.getType(i), c = new File([a], `pasted_image.${i.split("/")[1]}`, { type: i });
              r.push(c);
              break;
            }
          }
      return !t && !o && r.length && (t = await this._createImagePasteHtml(r)), this._genDocDataFromHtmlAndText(t, o);
    } catch (t) {
      return Promise.reject(t);
    }
  }
  _genDocDataFromHtmlAndText(e, t, o) {
    if (!e) {
      if (t)
        return { body: ce.transform.fromPlainText(t) };
      throw new Error("[DocClipboardService] html and text cannot be both empty!");
    }
    const r = Pd(e);
    if (r) {
      const i = Yo.get(r);
      if (i)
        return i;
    }
    if (!o) {
      const i = this._univerInstanceService.getCurrentUnitForType(_.UNIVER_DOC);
      o = (i == null ? void 0 : i.getUnitId()) || "";
    }
    const s = this._htmlToUDM.convert(e, { unitId: o });
    return r && Yo.set(r, s), s;
  }
  async _createImagePasteHtml(e) {
    var a, c;
    const t = {
      id: "",
      documentStyle: {},
      body: {
        dataStream: "",
        customBlocks: []
      },
      drawings: {}
    }, o = async (d) => {
      const l = new FileReader();
      return new Promise((A) => {
        l.onloadend = function() {
          A({
            source: l.result,
            imageSourceType: Wr.BASE64
          });
        }, l.readAsDataURL(d);
      });
    }, r = (d) => {
      const l = new Image(), A = 500;
      return new Promise((h) => {
        l.src = typeof d == "string" ? d : URL.createObjectURL(d), l.onload = () => {
          const u = Math.min(A, l.naturalWidth), g = l.naturalHeight / l.naturalWidth;
          h({ width: u, height: u * g });
        };
      });
    }, s = (c = (a = this._clipboardHooks.find((d) => d.onBeforePasteImage)) == null ? void 0 : a.onBeforePasteImage) != null ? c : o;
    return await Promise.all(e.map(async (d, l) => {
      var m;
      const A = await s(d);
      if (!A)
        return Promise.resolve();
      const { width: h = 100, height: u = 100 } = await r(d), g = `paste_image_id_${l}`, f = t.body, p = t.drawings;
      f.dataStream += "\b", (m = f.customBlocks) == null || m.push({ startIndex: l, blockId: g }), p[g] = {
        drawingId: g,
        unitId: "",
        subUnitId: "",
        imageSourceType: A.imageSourceType,
        title: "",
        source: A.source,
        description: "",
        layoutType: Ro.INLINE,
        drawingType: Nr.DRAWING_IMAGE,
        transform: {
          width: h,
          height: u,
          angle: 0
        },
        docTransform: {
          angle: 0,
          size: { width: h, height: u },
          positionH: { relativeFrom: Co.CHARACTER, posOffset: 0 },
          positionV: { relativeFrom: gt.LINE, posOffset: 0 }
        }
      };
    })), this._umdToHtml.convert([t]);
  }
};
ur = zd([
  cn(0, L),
  cn(1, Qr),
  cn(2, T),
  cn(3, ra),
  cn(4, j(Y))
], ur);
function wo(n) {
  return n.getContextValue(_n) || n.getContextValue(eo);
}
const ns = 999, ro = {
  id: Rl.id,
  name: "doc.command.copy",
  type: D.COMMAND,
  multi: !0,
  priority: ns,
  preconditions: wo,
  handler: async (n) => n.get(Lt).copy()
}, os = {
  id: "doc.command.copy-current-paragraph",
  type: D.COMMAND,
  handler: async (n) => {
    const e = n.get(Lt), t = Qn(n);
    return t ? e.copy(
      ir.copy,
      [{
        startOffset: t.paragraphStart,
        endOffset: t.paragraphEnd + 1,
        collapsed: !1
      }]
    ) : !1;
  }
}, rs = {
  id: bl.id,
  name: "doc.command.cut",
  type: D.COMMAND,
  multi: !0,
  priority: ns,
  preconditions: wo,
  handler: async (n) => n.get(Lt).cut()
}, ss = {
  id: "doc.command.cut-current-paragraph",
  type: D.COMMAND,
  handler: async (n) => {
    const e = n.get(Lt), t = Qn(n);
    return t ? e.cut(
      [{
        startOffset: t.paragraphStart,
        endOffset: t.paragraphEnd + 1,
        collapsed: !1,
        rangeType: He.TEXT
      }]
    ) : !1;
  }
}, is = {
  id: yl.id,
  name: "doc.command.paste",
  type: D.COMMAND,
  multi: !0,
  priority: ns,
  preconditions: wo,
  handler: async (n) => {
    const e = n.get(Lt), o = await n.get(ra).read();
    return o.length === 0 ? !1 : e.paste(o);
  }
}, Po = {
  id: "doc.command.horizontal-line",
  type: D.COMMAND,
  handler: (n, e) => n.get(T).syncExecuteCommand(Gr.id, {
    horizontalLine: {
      padding: 5,
      color: {
        rgb: "#CDD0D8"
      },
      width: 1,
      dashStyle: Uc.SOLID
    },
    textRange: e == null ? void 0 : e.insertRange
  })
}, as = {
  id: "doc.command.insert-horizontal-line-bellow",
  type: D.COMMAND,
  handler: (n) => {
    const e = n.get(T), t = Qn(n);
    return t ? e.syncExecuteCommand(Po.id, {
      insertRange: {
        startOffset: t.startIndex + 1,
        endOffset: t.startIndex + 1
      }
    }) : !1;
  }
}, Oa = {
  id: "doc.command.select-all",
  type: D.COMMAND,
  handler: async (n) => {
    var u;
    const e = n.get(L), t = n.get(Y), o = e.getCurrentUnitForType(_.UNIVER_DOC), r = t.getDocRanges(), s = (u = r.find((g) => g.isActive)) != null ? u : r[0];
    if (o == null || s == null)
      return !1;
    const { segmentId: i } = s, a = o.getUnitId(), c = o.getSelfOrHeaderFooterModel(i).getSnapshot().body;
    if (c == null)
      return !1;
    const { tables: d = [], dataStream: l } = c;
    if (l === `\r
`)
      return !0;
    const A = [];
    let h = 0;
    for (const g of d) {
      const { startIndex: f, endIndex: p } = g;
      h !== f && A.push({
        startOffset: h,
        endOffset: f - 1,
        rangeType: He.TEXT
      }), A.push({
        startOffset: f + 3,
        // 3 is TABLE_START, ROW_START, CELL_START.
        endOffset: p - 5,
        // 4 is CELL_END, ROW_END, TABLE_END AND \n.
        rangeType: He.RECT
      }), h = p;
    }
    return h !== c.dataStream.length - 2 && A.push({
      startOffset: h,
      endOffset: c.dataStream.length - 2,
      rangeType: He.TEXT
    }), t.replaceDocRanges(A, {
      unitId: a,
      subUnitId: a
    }, !1), !0;
  }
};
class No extends Ct {
  constructor(t) {
    super();
    O(this, "_previousActiveRange", null);
    O(this, "_undoMutationParamsCache", []);
    O(this, "_redoMutationParamsCache", []);
    this._context = t;
  }
  clearUndoRedoMutationParamsCache() {
    this._undoMutationParamsCache = [], this._redoMutationParamsCache = [];
  }
  getUndoRedoMutationParamsCache() {
    return {
      undoCache: this._undoMutationParamsCache,
      redoCache: this._redoMutationParamsCache
    };
  }
  setUndoRedoMutationParamsCache({ undoCache: t = [], redoCache: o = [] }) {
    this._undoMutationParamsCache = t, this._redoMutationParamsCache = o;
  }
  getActiveRange() {
    return this._previousActiveRange;
  }
  setActiveRange(t) {
    this._previousActiveRange = t;
  }
  pushUndoRedoMutationParams(t, o) {
    this._undoMutationParamsCache.push(t), this._redoMutationParamsCache.push(o);
  }
  fetchComposedUndoRedoMutationParams() {
    if (this._undoMutationParamsCache.length === 0 || this._previousActiveRange == null || this._redoMutationParamsCache.length === 0)
      return null;
    const { unitId: t } = this._undoMutationParamsCache[0], o = {
      unitId: t,
      actions: this._undoMutationParamsCache.reverse().reduce((s, i) => W.compose(s, i.actions), null),
      textRanges: []
      // Add empty array, will never use, just fix type error
    };
    return { redoMutationParams: {
      unitId: t,
      actions: this._redoMutationParamsCache.reduce((s, i) => W.compose(s, i.actions), null),
      textRanges: []
      // Add empty array, will never use, just fix type error
    }, undoMutationParams: o, previousActiveRange: this._previousActiveRange };
  }
  dispose() {
    this._undoMutationParamsCache = [], this._redoMutationParamsCache = [], this._previousActiveRange = null;
  }
}
const Ta = {
  id: "doc.command.ime-input",
  type: D.COMMAND,
  // eslint-disable-next-line max-lines-per-function
  handler: async (n, e) => {
    var N, ee, $;
    const { unitId: t, newText: o, oldTextLen: r, isCompositionEnd: s, isCompositionStart: i } = e, a = n.get(T), c = n.get(pe), d = n.get(L), l = n.get(at), A = (N = c.getRenderById(t)) == null ? void 0 : N.with(No), h = d.getUnit(t, _.UNIVER_DOC);
    if (h == null || A == null)
      return !1;
    const u = A.getActiveRange();
    if (u == null)
      return !1;
    const { style: g, segmentId: f } = u, p = h.getSelfOrHeaderFooterModel(f).getBody();
    if (p == null)
      return !1;
    Object.assign(u, u);
    const { startOffset: I, endOffset: S } = u, v = o.length, R = [
      {
        startOffset: I + v,
        endOffset: I + v,
        collapsed: !0,
        style: g
      }
    ], E = {
      id: X.id,
      params: {
        unitId: t,
        actions: [],
        textRanges: R
      }
    }, b = l.getDefaultStyle(), y = l.getStyleCache(), C = jr((ee = p.customRanges) != null ? ee : [], I + r, En.includes(t)), B = Bo(
      p,
      i ? S : I + r,
      b,
      y,
      En.includes(t)
    ), x = zr(($ = p.customDecorations) != null ? $ : [], I + r), M = new Ie(), w = W.getInstance();
    if (!u.collapsed && i) {
      const U = ce.selection.delete([u], p, 0, null, !1);
      M.push(...U), E.params.textRanges = [{
        startOffset: I + v,
        endOffset: I + v,
        collapsed: !0
      }];
    } else
      M.push({
        t: G.RETAIN,
        len: I
      });
    r > 0 && M.push({
      t: G.DELETE,
      len: r
    }), M.push({
      t: G.INSERT,
      body: {
        dataStream: o,
        textRuns: B ? [{
          ...B,
          st: 0,
          ed: o.length
        }] : [],
        customRanges: C ? [{
          ...C,
          startIndex: 0,
          endIndex: o.length - 1
        }] : [],
        customDecorations: x.map((U) => ({
          ...U,
          startIndex: 0,
          endIndex: o.length - 1
        }))
      },
      len: o.length
    });
    const F = Ae(h, f);
    E.params.actions = w.editOp(M.serialize(), F), E.params.noHistory = !s, E.params.isCompositionEnd = s;
    const P = a.syncExecuteCommand(E.id, E.params);
    return A.pushUndoRedoMutationParams(P, E.params), !!P;
  }
};
function qe(n, e, t) {
  return t.executeCommand(yt.id, {
    preCommandId: n,
    ...e != null ? e : {}
  });
}
const ri = "doc.command.set-inline-format-bold", Qt = {
  id: ri,
  type: D.COMMAND,
  handler: async (n, e) => {
    const t = n.get(T);
    return qe(
      ri,
      e,
      t
    );
  }
}, si = "doc.command.set-inline-format-italic", Ut = {
  id: si,
  type: D.COMMAND,
  handler: async (n, e) => {
    const t = n.get(T);
    return qe(
      si,
      e,
      t
    );
  }
}, ii = "doc.command.set-inline-format-underline", Ft = {
  id: ii,
  type: D.COMMAND,
  handler: async (n, e) => {
    const t = n.get(T);
    return qe(
      ii,
      e,
      t
    );
  }
}, ai = "doc.command.set-inline-format-strikethrough", Ht = {
  id: ai,
  type: D.COMMAND,
  handler: async (n, e) => {
    const t = n.get(T);
    return qe(
      ai,
      e,
      t
    );
  }
}, ci = "doc.command.set-inline-format-subscript", bt = {
  id: ci,
  type: D.COMMAND,
  handler: async (n, e) => {
    const t = n.get(T);
    return qe(
      ci,
      e,
      t
    );
  }
}, li = "doc.command.set-inline-format-superscript", kt = {
  id: li,
  type: D.COMMAND,
  handler: async (n, e) => {
    const t = n.get(T);
    return qe(
      li,
      e,
      t
    );
  }
}, di = "doc.command.set-inline-format-fontsize", ct = {
  id: di,
  type: D.COMMAND,
  handler: async (n, e) => {
    const t = n.get(T);
    return qe(
      di,
      e,
      t
    );
  }
}, Ai = "doc.command.set-inline-format-font-family", _t = {
  id: Ai,
  type: D.COMMAND,
  handler: async (n, e) => {
    const t = n.get(T);
    return qe(
      Ai,
      e,
      t
    );
  }
}, ui = "doc.command.set-inline-format-text-color", mt = {
  id: ui,
  type: D.COMMAND,
  handler: async (n, e) => {
    const t = n.get(T);
    return qe(
      ui,
      e,
      t
    );
  }
}, hi = "doc.command.set-inline-format-text-background-color", Et = {
  id: hi,
  type: D.COMMAND,
  handler: async (n, e) => {
    const t = n.get(T);
    return qe(
      hi,
      e,
      t
    );
  }
}, gi = "doc.command.reset-inline-format-text-background-color", Un = {
  id: gi,
  type: D.COMMAND,
  handler: async (n, e) => {
    const t = n.get(T);
    return qe(
      gi,
      e,
      t
    );
  }
}, hr = {
  [Qt.id]: "bl",
  [Ut.id]: "it",
  [Ft.id]: "ul",
  [Ht.id]: "st",
  [ct.id]: "fs",
  [_t.id]: "ff",
  [mt.id]: "cl",
  [Et.id]: "bg",
  [Un.id]: "bg",
  [bt.id]: "va",
  [kt.id]: "va"
}, yt = {
  id: "doc.command.set-inline-format",
  type: D.COMMAND,
  // eslint-disable-next-line max-lines-per-function, complexity
  handler: async (n, e) => {
    var R;
    const { value: t, preCommandId: o } = e, r = n.get(T), s = n.get(Y), i = n.get(L), a = n.get(at), c = s.getDocRanges(), d = (R = c.find((E) => E.isActive)) != null ? R : c[0];
    if (c.length === 0)
      return !1;
    const { segmentId: l } = c[0], A = i.getCurrentUnitForType(_.UNIVER_DOC);
    if (A == null)
      return !1;
    const h = A.getSelfOrHeaderFooterModel(l).getBody();
    if (h == null)
      return !1;
    const u = A.getUnitId();
    let g;
    switch (o) {
      case Qt.id:
      // fallthrough
      case Ut.id:
      // fallthrough
      case Ft.id:
      // fallthrough
      case Ht.id:
      // fallthrough
      case bt.id:
      // fallthrough
      case kt.id: {
        const E = a.getDefaultStyle(), b = Ma(
          h,
          d,
          E
        );
        g = Yd(
          b,
          o
        );
        break;
      }
      case ct.id:
      case _t.id: {
        g = t;
        break;
      }
      case mt.id:
      case Et.id: {
        g = {
          rgb: t
        };
        break;
      }
      case Un.id: {
        g = {
          rgb: null
        };
        break;
      }
      default:
        throw new Error(`Unknown command: ${o} in handleInlineFormat`);
    }
    const f = {
      id: X.id,
      params: {
        unitId: u,
        actions: [],
        textRanges: c
      }
    }, p = new Ie(), m = W.getInstance(), I = new Nt();
    I.reset();
    for (const E of c) {
      let { startOffset: b, endOffset: y, rangeType: C } = E;
      if (b == null || y == null)
        continue;
      if (C === He.RECT && (b = b - 1), b === y) {
        const M = a.getStyleCache(), w = hr[o];
        a.setStyleCache(
          {
            [w]: (M == null ? void 0 : M[w]) !== void 0 ? Ba(
              M,
              w,
              o
            ) : g
          }
        );
        continue;
      }
      const B = {
        dataStream: "",
        textRuns: [
          {
            st: 0,
            ed: y - b,
            ts: {
              [hr[o]]: g
            }
          }
        ]
      }, x = b - I.cursor;
      x !== 0 && p.push({
        t: G.RETAIN,
        len: x
      }), p.push({
        t: G.RETAIN,
        body: B,
        len: y - b
      }), I.reset(), I.moveCursor(y);
    }
    const S = Ae(A, l);
    return f.params.actions = m.editOp(p.serialize(), S), !!r.syncExecuteCommand(f.id, f.params);
  }
};
function Gd(n) {
  return n !== null && typeof n == "object";
}
function Ba(n, e, t) {
  if (/bl|it/.test(e))
    return (n == null ? void 0 : n[e]) === z.TRUE ? z.FALSE : z.TRUE;
  if (/ul|st/.test(e))
    return Gd(n == null ? void 0 : n[e]) && (n == null ? void 0 : n[e]).s === z.TRUE ? {
      s: z.FALSE
    } : {
      s: z.TRUE
    };
  if (/va/.test(e))
    return t === bt.id ? (n == null ? void 0 : n[e]) === Ve.SUBSCRIPT ? Ve.NORMAL : Ve.SUBSCRIPT : (n == null ? void 0 : n[e]) === Ve.SUPERSCRIPT ? Ve.NORMAL : Ve.SUPERSCRIPT;
}
function Ma(n, e, t) {
  var l, A, h, u, g, f, p, m, I, S, v, R, E, b;
  const { startOffset: o, endOffset: r, collapsed: s } = e;
  if (s) {
    const y = (l = n.textRuns) != null ? l : [];
    let C = null;
    for (let B = y.length - 1; B >= 0; B--) {
      const x = y[B];
      if (x.st < o && o <= x.ed) {
        C = x;
        break;
      }
    }
    return C != null && C.ts ? { ...t, ...C.ts } : t;
  }
  const { textRuns: i = [] } = Ki(n, o, r), a = ue.deepClone(t), c = i.map((y) => {
    var C;
    return (C = y == null ? void 0 : y.ts) == null ? void 0 : C.fs;
  }).filter(Boolean);
  a.fs = a.fs ? Math.max(a.fs, ...c) : c.length ? Math.max(...c) : void 0, a.fs = !a.fs || Number.isNaN(a.fs) ? void 0 : a.fs, a.ff = (u = (h = (A = i.find((y) => {
    var C;
    return ((C = y.ts) == null ? void 0 : C.ff) != null;
  })) == null ? void 0 : A.ts) == null ? void 0 : h.ff) != null ? u : a.ff, a.it = i.length && i.every((y) => {
    var C;
    return ((C = y.ts) == null ? void 0 : C.it) === z.TRUE;
  }) ? z.TRUE : z.FALSE, a.bl = i.length && i.every((y) => {
    var C;
    return ((C = y.ts) == null ? void 0 : C.bl) === z.TRUE;
  }) ? z.TRUE : z.FALSE, a.ul = i.length && i.every((y) => {
    var C, B;
    return ((B = (C = y.ts) == null ? void 0 : C.ul) == null ? void 0 : B.s) === z.TRUE;
  }) ? (g = i[0].ts) == null ? void 0 : g.ul : a.ul, a.st = i.length && i.every((y) => {
    var C, B;
    return ((B = (C = y.ts) == null ? void 0 : C.st) == null ? void 0 : B.s) === z.TRUE;
  }) ? (f = i[0].ts) == null ? void 0 : f.st : a.st, a.bg = (I = (m = (p = i.find((y) => {
    var C;
    return ((C = y.ts) == null ? void 0 : C.bg) != null;
  })) == null ? void 0 : p.ts) == null ? void 0 : m.bg) != null ? I : a.bg, a.cl = (R = (v = (S = i.find((y) => {
    var C;
    return ((C = y.ts) == null ? void 0 : C.cl) != null;
  })) == null ? void 0 : S.ts) == null ? void 0 : v.cl) != null ? R : a.cl;
  const d = i.filter((y) => {
    var C;
    return ((C = y == null ? void 0 : y.ts) == null ? void 0 : C.va) != null;
  });
  if (d.length > 0 && d.length === i.length) {
    const y = (E = d[0].ts) == null ? void 0 : E.va;
    let C = !0;
    for (let B = 1; B < d.length; B++)
      if (((b = d[B].ts) == null ? void 0 : b.va) !== y) {
        C = !1;
        break;
      }
    C && (a.va = y);
  }
  return a;
}
function Yd(n, e) {
  const t = hr[e];
  return Ba(n, t, e);
}
const _a = {
  id: "doc.command-replace-snapshot",
  type: D.COMMAND,
  // eslint-disable-next-line max-lines-per-function, complexity
  handler: (n, e) => {
    const { unitId: t, snapshot: o, textRanges: r, segmentId: s = "", options: i } = e, a = n.get(L), c = n.get(T), d = n.get(Y), l = a.getUnit(t, _.UNIVER_DOC), A = l == null ? void 0 : l.getSelfOrHeaderFooterModel(s).getSnapshot();
    if (l == null || A == null)
      return !1;
    const { body: h, tableSource: u, footers: g, headers: f, lists: p, drawings: m, drawingsOrder: I, documentStyle: S } = ue.deepClone(o), {
      body: v,
      tableSource: R,
      footers: E,
      headers: b,
      lists: y,
      drawings: C,
      drawingsOrder: B,
      documentStyle: x
    } = A;
    if (h == null || v == null)
      return !1;
    if (ue.diffValue(h, v) && r)
      return d.replaceDocRanges(r, {
        unitId: t,
        subUnitId: t
      }, !1), !0;
    const M = {
      id: X.id,
      params: {
        unitId: t,
        actions: [],
        textRanges: r
      }
    };
    i && (M.params.options = i);
    const w = [], F = W.getInstance();
    if (!ue.diffValue(x, S)) {
      const N = F.replaceOp(["documentStyle"], x, S);
      N != null && w.push(N);
    }
    if (!ue.diffValue(h, v)) {
      const N = F.replaceOp(["body"], v, h);
      N != null && w.push(N);
    }
    if (!ue.diffValue(u, R)) {
      const N = F.replaceOp(["tableSource"], R, u);
      N != null && w.push(N);
    }
    if (!ue.diffValue(g, E)) {
      const N = F.replaceOp(["footers"], E, g);
      N != null && w.push(N);
    }
    if (!ue.diffValue(f, b)) {
      const N = F.replaceOp(["headers"], b, f);
      N != null && w.push(N);
    }
    if (!ue.diffValue(p, y)) {
      const N = F.replaceOp(["lists"], y, p);
      N != null && w.push(N);
    }
    if (!ue.diffValue(m, C)) {
      const N = F.replaceOp(["drawings"], C, m);
      N != null && w.push(N);
    }
    if (!ue.diffValue(I, B)) {
      const N = F.replaceOp(["drawingsOrder"], B, I);
      N != null && w.push(N);
    }
    return M.params.actions = w.reduce((N, ee) => W.compose(N, ee), null), !!c.syncExecuteCommand(M.id, M.params);
  }
}, Kd = {
  id: "doc.command-replace-content",
  type: D.COMMAND,
  handler: async (n, e) => {
    const { unitId: t, body: o, textRanges: r, segmentId: s = "", options: i } = e, a = n.get(L), c = n.get(T), d = n.get(Y), l = a.getUnit(t, _.UNIVER_DOC), A = l == null ? void 0 : l.getSelfOrHeaderFooterModel(s).getSnapshot().body;
    if (l == null || A == null)
      return !1;
    const h = Da(t, s, l, A, o);
    return h.params.textRanges = r, i && (h.params.options = i), h.params.actions == null && r ? (d.replaceDocRanges(r, {
      unitId: t,
      subUnitId: t
    }, !1), !0) : !!c.syncExecuteCommand(h.id, h.params);
  }
}, qd = {
  id: "doc.command-cover-content",
  type: D.COMMAND,
  handler: (n, e) => {
    const { unitId: t, body: o, segmentId: r = "", textRanges: s } = e, i = n.get(L), a = n.get(T), c = n.get(yo), d = i.getUniverDocInstance(t), l = d == null ? void 0 : d.getSnapshot().body;
    if (d == null || l == null)
      return !1;
    const A = Da(t, r, d, l, o);
    return A.params.noNeedSetTextRange = !0, A.params.noHistory = !0, A.params.textRanges = s, a.syncExecuteCommand(
      A.id,
      A.params
    ), c.clearUndoRedo(t), !0;
  }
};
function Xd(n, e, t, o) {
  const r = new Ie(), s = W.getInstance(), i = (t == null ? void 0 : t.dataStream.length) - 2;
  i > 0 && r.push({
    t: G.DELETE,
    len: i
  }), o.dataStream.length > 0 && r.push({
    t: G.INSERT,
    body: o,
    len: o.dataStream.length
  });
  const a = Ae(e, n);
  return s.editOp(r.serialize(), a);
}
function Da(n, e, t, o, r) {
  const s = {
    id: X.id,
    params: {
      unitId: n,
      actions: [],
      textRanges: []
    }
  }, i = Xd(e, t, o, r);
  return s.params.actions = i, s;
}
const wa = {
  id: "doc.command.replace-selection",
  type: D.COMMAND,
  handler(n, e) {
    var g;
    if (!e)
      return !1;
    const t = n.get(T), { unitId: o, body: r, textRanges: s } = e, a = n.get(L).getUnit(o), c = n.get(Y);
    if (!a)
      return !1;
    const d = a.getBody(), l = (g = e.selection) != null ? g : c.getActiveTextRange();
    if (!l || !d)
      return !1;
    const A = {
      id: X.id,
      params: {
        unitId: o,
        actions: [],
        textRanges: s,
        debounce: !0
      }
    }, h = new Ie(), u = W.getInstance();
    return h.push(...ce.selection.delete([l], d, 0, r)), A.params.actions = u.editOp(h.serialize()), t.syncExecuteCommand(A.id, A.params);
  }
}, Zd = {
  id: "doc.command.replace-text-runs",
  type: D.COMMAND,
  handler: (n, e) => {
    const { unitId: t, body: o, textRanges: r, segmentId: s = "", options: i } = e, a = n.get(L), c = n.get(T), d = n.get(Ur), l = a.getUnit(t, _.UNIVER_DOC), A = l == null ? void 0 : l.getSelfOrHeaderFooterModel(s).getSnapshot().body;
    if (l == null || A == null)
      return !1;
    const h = ce.selection.replaceTextRuns({
      doc: l,
      body: o,
      selection: {
        startOffset: 0,
        endOffset: A.dataStream.length - 2,
        collapsed: !1
      },
      themeService: d
    });
    if (!h)
      return !1;
    const u = {
      id: X.id,
      params: {
        unitId: t,
        actions: [],
        textRanges: r,
        noHistory: !0
      }
    }, g = W.getInstance(), f = Ae(l, s);
    return u.params.actions = g.editOp(h.serialize(), f), u.params.textRanges = r, i && (u.params.options = i), !!c.syncExecuteCommand(u.id, u.params);
  }
}, Jd = {
  id: "doc.command.insert-custom-range",
  type: D.COMMAND,
  handler: (n, e) => {
    if (!e) return !1;
    const t = n.get(T), { unitId: o, rangeId: r = ge(), textRanges: s, properties: i, text: a, wholeEntity: c } = e, d = {
      unitId: o,
      textRanges: s,
      body: {
        dataStream: a,
        customRanges: [{
          startIndex: 0,
          endIndex: a.length - 1,
          rangeId: r,
          rangeType: Lr.CUSTOM,
          properties: i,
          wholeEntity: c
        }]
      }
    };
    return t.syncExecuteCommand(wa.id, d);
  }
}, Fn = {
  id: "doc.command.list-operation",
  type: D.COMMAND,
  handler: (n, e) => {
    var v, R, E, b, y, C;
    const t = n.get(Y), o = n.get(L), r = n.get(T), s = e.listType, i = o.getCurrentUnitForType(_.UNIVER_DOC), a = (R = (v = e.docRange) != null ? v : t.getDocRanges()) != null ? R : [];
    if (i == null || a.length === 0)
      return !1;
    const c = a[0].segmentId, d = i.getSelfOrHeaderFooterModel(c), l = (b = (E = d.getBody()) == null ? void 0 : E.paragraphs) != null ? b : [], A = (C = (y = d.getBody()) == null ? void 0 : y.dataStream) != null ? C : "";
    if (!l.length)
      return !1;
    const h = ce.range.getParagraphsInRanges(a, l, A), u = i.getUnitId(), g = {
      id: X.id,
      params: {
        unitId: u,
        actions: [],
        textRanges: a,
        isEditing: !1
      }
    };
    new Nt().reset();
    const p = ce.paragraph.bullet.switch({
      paragraphs: h,
      listType: s,
      document: i,
      segmentId: c
    }), m = W.getInstance(), I = Ae(i, c);
    return g.params.actions = m.editOp(p.serialize(), I), !!r.syncExecuteCommand(g.id, g.params);
  }
}, Lo = {
  id: "doc.command.change-list-type",
  type: D.COMMAND,
  handler: (n, e) => {
    var S, v, R, E, b;
    const t = n.get(Y), o = n.get(L), r = n.get(T), { listType: s } = e, i = o.getCurrentUnitForType(_.UNIVER_DOC), a = (S = e.docRange) != null ? S : t.getDocRanges();
    if (i == null || a == null || !a.length)
      return !1;
    const { segmentId: c } = a[0], d = i.getSelfOrHeaderFooterModel(c), l = (R = (v = d.getBody()) == null ? void 0 : v.paragraphs) != null ? R : [], A = (b = (E = d.getBody()) == null ? void 0 : E.dataStream) != null ? b : "";
    if (!l.length)
      return !1;
    const h = ce.range.getParagraphsInRanges(a, l, A), u = i.getUnitId(), g = ce.paragraph.bullet.set({
      paragraphs: h,
      listType: s,
      segmentId: c,
      document: i
    });
    if (!g)
      return !1;
    const f = W.getInstance(), p = {
      id: X.id,
      params: {
        unitId: u,
        actions: [],
        textRanges: a,
        isEditing: !1
      }
    }, m = Ae(i, c);
    return p.params.actions = f.editOp(g.serialize(), m), !!r.syncExecuteCommand(p.id, p.params);
  }
};
var qn = /* @__PURE__ */ ((n) => (n[n.increase = 1] = "increase", n[n.decrease = -1] = "decrease", n))(qn || {});
const gr = {
  id: "doc.command.change-list-nesting-level",
  type: D.COMMAND,
  handler: (n, e) => {
    var v, R, E, b, y;
    if (!e)
      return !1;
    const { type: t } = e, o = n.get(Y), r = n.get(L), s = n.get(T), i = r.getCurrentUnitForType(_.UNIVER_DOC), a = o.getActiveTextRange();
    if (i == null || a == null)
      return !1;
    const { segmentId: c } = a, d = (v = o.getDocRanges()) != null ? v : [], l = i.getSelfOrHeaderFooterModel(c), A = (E = (R = l.getBody()) == null ? void 0 : R.paragraphs) != null ? E : [], h = (y = (b = l.getBody()) == null ? void 0 : b.dataStream) != null ? y : "";
    if (!A.length)
      return !1;
    const u = ce.range.getParagraphsInRange(a, A, h), g = i.getUnitId(), f = W.getInstance(), p = ce.paragraph.bullet.changeNestLevel({
      paragraphs: u,
      type: t,
      segmentId: c,
      document: i
    }), m = {
      id: X.id,
      params: {
        unitId: g,
        actions: [],
        textRanges: d,
        isEditing: !1
      }
    }, I = Ae(i, c);
    return m.params.actions = f.editOp(p.serialize(), I), !!s.syncExecuteCommand(m.id, m.params);
  }
}, xn = {
  id: "doc.command.bullet-list",
  type: D.COMMAND,
  handler: (n, e) => {
    const t = n.get(T);
    return e != null && e.value ? t.syncExecuteCommand(Lo.id, {
      listType: e.value,
      docRange: e.docRange
    }) : t.syncExecuteCommand(Fn.id, {
      listType: ye.BULLET_LIST,
      docRange: e == null ? void 0 : e.docRange
    });
  }
}, so = {
  id: "doc.command.check-list",
  type: D.COMMAND,
  handler: (n, e) => {
    const t = n.get(T);
    return e != null && e.value ? t.syncExecuteCommand(Lo.id, {
      listType: e.value,
      docRange: e.docRange
    }) : t.syncExecuteCommand(Fn.id, {
      listType: ye.CHECK_LIST,
      docRange: e == null ? void 0 : e.docRange
    });
  }
}, Pa = {
  id: "doc.command.toggle-check-list",
  type: D.COMMAND,
  handler: (n, e) => {
    var f;
    if (!e)
      return !1;
    const t = n.get(L), o = n.get(T), { index: r, segmentId: s, textRanges: i } = e, a = t.getCurrentUnitForType(_.UNIVER_DOC);
    if (a == null || ((f = a.getSelfOrHeaderFooterModel(s).getBody()) == null ? void 0 : f.paragraphs) == null)
      return !1;
    const d = a.getUnitId(), l = {
      id: X.id,
      params: {
        unitId: d,
        actions: [],
        textRanges: i != null ? i : [],
        segmentId: s,
        isEditing: !1
      }
    }, A = ce.paragraph.bullet.toggleChecklist({
      document: a,
      paragraphIndex: r,
      segmentId: s
    });
    if (!A)
      return !1;
    const h = W.getInstance(), u = Ae(a, s);
    return l.params.actions = h.editOp(A.serialize(), u), !!o.syncExecuteCommand(l.id, l.params);
  }
}, On = {
  id: "doc.command.order-list",
  type: D.COMMAND,
  handler: (n, e) => {
    const t = n.get(T);
    return e != null && e.value ? t.syncExecuteCommand(Lo.id, {
      listType: e.value
    }) : t.syncExecuteCommand(Fn.id, {
      listType: ye.ORDER_LIST
    });
  }
}, Na = {
  id: "doc.command.quick-list",
  type: D.COMMAND,
  // eslint-disable-next-line max-lines-per-function
  handler(n, e) {
    var x, M, w;
    if (!e)
      return !1;
    const t = n.get(Y), o = n.get(L), r = n.get(T), s = o.getCurrentUnitForType(_.UNIVER_DOC), i = t.getActiveTextRange();
    if (s == null || i == null)
      return !1;
    const { segmentId: a, startOffset: c } = i, { listType: d, paragraph: l } = e, { paragraphStart: A, paragraphEnd: h } = l, u = new Ie(), g = W.getInstance(), { paragraphStyle: f = {} } = l, m = (Fc[d].nestingLevel[0].paragraphProperties || {}).textStyle;
    let S = ge(6);
    const v = (M = (x = s.getBody()) == null ? void 0 : x.paragraphs) != null ? M : [], R = v.findIndex((F) => F.startIndex === l.startIndex), E = v[R - 1], b = v[R + 1];
    E && E.bullet && E.bullet.listType.indexOf(d) === 0 ? S = E.bullet.listId : b && b.bullet && b.bullet.listType.indexOf(d) === 0 && (S = b.bullet.listId);
    const y = {
      id: X.id,
      params: {
        unitId: s.getUnitId(),
        actions: [],
        textRanges: [{
          startOffset: A,
          endOffset: A,
          collapsed: !0
        }],
        isEditing: !1
      }
    };
    u.push({
      t: G.RETAIN,
      len: A
    }), u.push({
      t: G.DELETE,
      len: c - A
    }), h > c && u.push({
      t: G.RETAIN,
      len: h - c
    }), u.push({
      t: G.RETAIN,
      len: 1,
      body: {
        dataStream: "",
        paragraphs: [
          {
            startIndex: 0,
            paragraphStyle: {
              ...f,
              textStyle: {
                ...f.textStyle,
                ...m
              },
              indentFirstLine: void 0
            },
            bullet: {
              ...(w = l.bullet) != null ? w : {
                nestingLevel: 0,
                textStyle: {
                  fs: 20
                }
              },
              listType: d,
              listId: S
            }
          }
        ]
      }
    });
    const C = Ae(s, a);
    return y.params.actions = g.editOp(u.serialize(), C), !!r.syncExecuteCommand(y.id, y.params);
  }
};
function cs(n, e) {
  var l, A;
  const t = n.get(T), o = Qn(n);
  if (!o)
    return !1;
  const r = n.get(L).getCurrentUnitOfType(_.UNIVER_DOC);
  if (!r)
    return !1;
  const s = ce.selection.replace({
    doc: r,
    selection: {
      startOffset: o.startIndex + 1,
      endOffset: o.startIndex + 1,
      collapsed: !0
    },
    body: {
      dataStream: "\r",
      paragraphs: [
        {
          startIndex: 0,
          paragraphStyle: {
            ...o.paragraphStyle
          },
          bullet: {
            listType: e,
            listId: ((l = o.bullet) == null ? void 0 : l.listType) === e ? o.bullet.listId : ge(6),
            nestingLevel: ((A = o.bullet) == null ? void 0 : A.listType) === e ? o.bullet.nestingLevel : 0
          }
        }
      ]
    }
  });
  if (!s)
    return !1;
  const i = {
    id: X.id,
    params: {
      unitId: r.getUnitId(),
      actions: [],
      textRanges: [{
        startOffset: o.startIndex + 1,
        endOffset: o.startIndex + 1,
        collapsed: !0
      }],
      isEditing: !1
    }
  }, a = W.getInstance(), c = Ae(r);
  return i.params.actions = a.editOp(s.serialize(), c), !!t.syncExecuteCommand(i.id, i.params);
}
const ls = {
  id: "doc.command.insert-bullet-list-bellow",
  type: D.COMMAND,
  handler: (n) => cs(n, ye.BULLET_LIST)
}, ds = {
  id: "doc.command.insert-order-list-bellow",
  type: D.COMMAND,
  handler: (n) => cs(n, ye.ORDER_LIST)
}, As = {
  id: "doc.command.insert-check-list-bellow",
  type: D.COMMAND,
  handler: (n) => cs(n, ye.CHECK_LIST)
}, lt = {
  id: "doc.command.align-action",
  type: D.COMMAND,
  // eslint-disable-next-line max-lines-per-function
  handler: (n, e) => {
    var R, E, b, y;
    const t = n.get(Y), o = n.get(L), r = n.get(T), { alignType: s } = e, i = o.getCurrentUniverDocInstance();
    if (i == null)
      return !1;
    const a = t.getDocRanges();
    if (a.length === 0)
      return !1;
    const c = a[0].segmentId, d = i.getSelfOrHeaderFooterModel(c), l = (E = (R = d.getBody()) == null ? void 0 : R.paragraphs) != null ? E : [], A = (y = (b = d.getBody()) == null ? void 0 : b.dataStream) != null ? y : "";
    if (l == null)
      return !1;
    const h = ce.range.getParagraphsInRanges(a, l, A), u = i.getUnitId(), g = h.every((C) => {
      var B;
      return ((B = C.paragraphStyle) == null ? void 0 : B.horizontalAlign) === s;
    }), f = {
      id: X.id,
      params: {
        unitId: u,
        actions: [],
        textRanges: a
      }
    }, p = new Nt();
    p.reset();
    const m = new Ie(), I = W.getInstance();
    for (const C of h) {
      const { startIndex: B } = C;
      m.push({
        t: G.RETAIN,
        len: B - p.cursor
      });
      const x = {
        ...C.paragraphStyle,
        horizontalAlign: g ? Ue.UNSPECIFIED : s
      };
      m.push({
        t: G.RETAIN,
        len: 1,
        body: {
          dataStream: "",
          paragraphs: [
            {
              ...C,
              paragraphStyle: x,
              startIndex: 0
            }
          ]
        },
        coverType: nn.REPLACE
      }), p.moveCursorTo(B + 1);
    }
    const S = Ae(i, c);
    return f.params.actions = I.editOp(m.serialize(), S), !!r.syncExecuteCommand(f.id, f.params);
  }
}, Qo = {
  id: "doc.command.align-left",
  type: D.COMMAND,
  handler: (n) => n.get(T).syncExecuteCommand(lt.id, {
    alignType: Ue.LEFT
  })
}, Uo = {
  id: "doc.command.align-center",
  type: D.COMMAND,
  handler: (n) => n.get(T).syncExecuteCommand(lt.id, {
    alignType: Ue.CENTER
  })
}, Fo = {
  id: "doc.command.align-right",
  type: D.COMMAND,
  handler: (n) => n.get(T).syncExecuteCommand(lt.id, {
    alignType: Ue.RIGHT
  })
}, Ho = {
  id: "doc.command.align-justify",
  type: D.COMMAND,
  handler: (n) => n.get(T).syncExecuteCommand(lt.id, {
    alignType: Ue.JUSTIFIED
  })
}, $d = (n, e) => {
  const o = n.get(L).getUnit(e.unitId, _.UNIVER_DOC);
  return o == null || o.setZoomRatio(e.zoomRatio), { ...e };
}, tt = {
  id: "doc.operation.set-zoom-ratio",
  type: D.OPERATION,
  handler: (n, e) => {
    const o = n.get(L).getUnit(e.unitId, _.UNIVER_DOC);
    return o ? (o.setZoomRatio(e.zoomRatio), !0) : !1;
  }
}, Xn = {
  type: D.COMMAND,
  id: "doc.command.set-zoom-ratio",
  handler: async (n, e) => {
    var A, h, u;
    const t = n.get(T), o = n.get(yo), r = n.get(L);
    let s = (A = r.getCurrentUniverDocInstance()) == null ? void 0 : A.getUnitId();
    if (!s) return !1;
    let i = 1;
    if (e && (s = (h = e.documentId) != null ? h : s, i = (u = e.zoomRatio) != null ? u : i), !r.getUniverDocInstance(s)) return !1;
    const c = {
      zoomRatio: i,
      unitId: s
    }, d = $d(n, c);
    return t.syncExecuteCommand(tt.id, c) ? (o.pushUndoRedo({
      unitID: s,
      undoMutations: [{ id: tt.id, params: d }],
      redoMutations: [{ id: tt.id, params: c }]
    }), !0) : !1;
  }
}, Xe = {
  id: "doc.command.set-paragraph-named-style",
  type: D.COMMAND,
  handler(n, e) {
    var g;
    if (!e)
      return !1;
    const o = n.get(L).getCurrentUnitOfType(_.UNIVER_DOC);
    if (!o)
      return !1;
    const r = o.getUnitId(), s = n.get(Y), i = (g = e.textRanges) != null ? g : s.getTextRanges({ unitId: r, subUnitId: r });
    if (!(i != null && i.length))
      return !1;
    const a = i[0].segmentId, c = ce.paragraph.style.set({
      document: o.getSelfOrHeaderFooterModel(a),
      textRanges: i,
      style: {
        namedStyleType: e.value,
        headingId: !e.value || e.value === K.NORMAL_TEXT ? void 0 : ge(6),
        spaceAbove: void 0,
        spaceBelow: void 0,
        lineSpacing: void 0
      },
      paragraphTextRun: {}
    }), d = {
      id: X.id,
      params: {
        actions: [],
        textRanges: i,
        unitId: r,
        segmentId: a
      }
    }, l = W.getInstance(), A = Ae(o, a);
    return d.params.actions = l.editOp(c.serialize(), A), !!n.get(T).syncExecuteCommand(d.id, d.params);
  }
}, La = {
  id: "doc.command.quick-heading",
  type: D.COMMAND,
  handler(n, e) {
    var R, E, b, y;
    if (!e)
      return !1;
    const { value: t } = e, o = n.get(Y), r = n.get(L), s = n.get(T), i = r.getCurrentUnitForType(_.UNIVER_DOC), a = o.getActiveTextRange();
    if (i == null || a == null || !a.collapsed)
      return !1;
    const { segmentId: c, startOffset: d } = a, l = i.getSelfOrHeaderFooterModel(c), A = (E = (R = l.getBody()) == null ? void 0 : R.paragraphs) != null ? E : [], h = (y = (b = l.getBody()) == null ? void 0 : b.dataStream) != null ? y : "", u = ce.paragraph.util.getParagraphsInRange(a, A, h)[0];
    if (!u)
      return !1;
    const { paragraphStart: g } = u, f = new Ie(), p = W.getInstance(), { paragraphStyle: m = {} } = u, I = {
      id: X.id,
      params: {
        unitId: i.getUnitId(),
        actions: [],
        textRanges: [{
          startOffset: g,
          endOffset: g,
          collapsed: !0
        }],
        isEditing: !1
      }
    };
    f.push({
      t: G.RETAIN,
      len: g
    }), ce.paragraph.style.set({
      textRanges: [a],
      document: i,
      style: {
        ...m,
        headingId: ge(6),
        namedStyleType: t
      },
      cursor: d,
      deleteLen: d - g,
      textX: f,
      paragraphTextRun: {}
    });
    const S = Ae(i, c);
    return I.params.actions = p.editOp(f.serialize(), S), !!s.syncExecuteCommand(I.id, I.params);
  }
}, qo = {
  "#": K.HEADING_1,
  "##": K.HEADING_2,
  "###": K.HEADING_3,
  "####": K.HEADING_4,
  "#####": K.HEADING_5
}, us = {
  id: "doc.command.h1-heading",
  type: D.COMMAND,
  handler: (n) => n.get(T).syncExecuteCommand(Xe.id, {
    value: K.HEADING_1
  })
}, hs = {
  id: "doc.command.h2-heading",
  type: D.COMMAND,
  handler: (n) => n.get(T).syncExecuteCommand(Xe.id, {
    value: K.HEADING_2
  })
}, gs = {
  id: "doc.command.h3-heading",
  type: D.COMMAND,
  handler: (n) => n.get(T).syncExecuteCommand(Xe.id, {
    value: K.HEADING_3
  })
}, fs = {
  id: "doc.command.h4-heading",
  type: D.COMMAND,
  handler: (n) => n.get(T).syncExecuteCommand(Xe.id, {
    value: K.HEADING_4
  })
}, ps = {
  id: "doc.command.h5-heading",
  type: D.COMMAND,
  handler: (n) => n.get(T).syncExecuteCommand(Xe.id, {
    value: K.HEADING_5
  })
}, io = {
  id: "doc.command.normal-text-heading",
  type: D.COMMAND,
  handler: (n) => n.get(T).syncExecuteCommand(Xe.id, {
    value: K.NORMAL_TEXT
  })
}, Qa = {
  id: "doc.command.title",
  type: D.COMMAND,
  handler: (n) => n.get(T).syncExecuteCommand(Xe.id, {
    value: K.TITLE
  })
}, Ua = {
  id: "doc.command.subtitle-heading",
  type: D.COMMAND,
  handler: (n) => n.get(T).syncExecuteCommand(Xe.id, {
    value: K.SUBTITLE
  })
};
var Zn = /* @__PURE__ */ ((n) => (n[n.page = 0] = "page", n[n.section = 1] = "section", n[n.column = 2] = "column", n[n.line = 3] = "line", n[n.divide = 4] = "divide", n[n.glyph = 5] = "glyph", n))(Zn || {});
const qt = {
  page: 0,
  section: 1,
  column: 2,
  line: 3,
  divide: 4,
  glyph: 5
};
function ms(n, e) {
  return n.page > e.page ? !1 : n.page < e.page ? !0 : n.section > e.section ? !1 : n.section < e.section ? !0 : n.column > e.column ? !1 : n.column < e.column ? !0 : n.line > e.line ? !1 : n.line < e.line ? !0 : n.divide > e.divide ? !1 : n.divide < e.divide ? !0 : n.glyph > e.glyph ? !1 : (n.glyph < e.glyph, !0);
}
function fr(n, e) {
  return ms(n, e) ? {
    start: n,
    end: e
  } : {
    start: e,
    end: n
  };
}
function fi(n) {
  const e = n.length;
  if (e === 0)
    return;
  const t = n[0], o = n[e - 1], r = n.length === 1 && t.collapsed;
  return {
    startOffset: t.startOffset,
    endOffset: o.endOffset,
    collapsed: r
  };
}
function eA(n, e, t, o) {
  let r = o, s = o;
  for (let i = 0; i < n.length; i++) {
    const c = n[i].count;
    i < e && (r += c), i < t && (s += c);
  }
  return {
    startOffset: r,
    endOffset: s
  };
}
function pr(n) {
  const { startX: e, startY: t, endX: o, endY: r } = n, s = [];
  return s.push({
    x: e,
    y: t
  }), s.push({
    x: o,
    y: t
  }), s.push({
    x: o,
    y: r
  }), s.push({
    x: e,
    y: r
  }), s.push({
    x: e,
    y: t
  }), s;
}
class It {
  constructor(e, t) {
    O(this, "_liquid", new Ji());
    O(this, "_currentStartState", {
      page: 0,
      section: 0,
      column: 0,
      line: 0,
      divide: 0,
      glyph: 0
      /* NORMAL */
    });
    O(this, "_currentEndState", {
      page: 0,
      section: 0,
      column: 0,
      line: 0,
      divide: 0,
      glyph: 0
      /* NORMAL */
    });
    this._documentOffsetConfig = e, this._docSkeleton = t;
  }
  // eslint-disable-next-line max-lines-per-function
  getRangePointData(e, t) {
    const o = [], r = [], s = [];
    if (e == null || t == null)
      return {
        borderBoxPointGroup: o,
        contentBoxPointGroup: r,
        cursorList: s
      };
    if (!this._isValidPosition(e, t))
      throw new Error(
        `
                Invalid positions in NodePositionConvertToCursor,
                they are not in the same segment page when in header or footer.`
      );
    const { start: a, end: c } = fr(e, t);
    return this._selectionIterator(a, c, (d, l, A, h, u, g) => {
      const { lineHeight: f, asc: p, paddingTop: m, marginTop: I, marginBottom: S } = g, { glyphGroup: v, st: R } = u;
      if (v.length === 0)
        return;
      const { x: E, y: b } = this._liquid;
      let y, C;
      const B = v[d], x = v[l], M = v[d - 1], w = (B == null ? void 0 : B.left) || 0, F = (B == null ? void 0 : B.width) || 0, P = (x == null ? void 0 : x.left) || 0, N = (x == null ? void 0 : x.width) || 0, ee = (B == null ? void 0 : B.glyphType) === $i.LIST, { startOffset: $, endOffset: U } = eA(v, d, l, R), H = a.glyph === d && A ? a.isBack : !0, k = c.glyph === l && h ? c.isBack : !1, ne = a === c, ie = H && M != null ? M : B;
      if (d === 0 && l === v.length - 1)
        y = {
          startX: E + w + (ee ? F : 0),
          startY: b,
          endX: E + P + (k ? 0 : N),
          endY: b + f - I - S
        }, C = {
          startX: E + w + (ee ? F : 0),
          startY: b + m + p - ie.bBox.ba,
          endX: E + P + (k ? 0 : N),
          endY: b + m + p + ie.bBox.bd
        };
      else {
        const ae = H && !ee;
        y = {
          startX: E + w + (ae ? 0 : F),
          startY: b,
          endX: E + P + (k ? 0 : N),
          endY: b + f - I - S
        }, C = {
          startX: E + w + (ae ? 0 : F),
          startY: b + m + p - ie.bBox.ba,
          endX: E + P + (k ? 0 : N),
          endY: b + m + p + ie.bBox.bd
        };
      }
      o.push(pr(y)), r.push(pr(C)), s.push({
        startOffset: H ? $ : $ + B.count,
        endOffset: k ? U : U + x.count,
        collapsed: ne
      });
    }), {
      borderBoxPointGroup: o,
      contentBoxPointGroup: r,
      cursorList: s
    };
  }
  _isValidPosition(e, t) {
    const { segmentPage: o, pageType: r } = e, { segmentPage: s, pageType: i } = t;
    return r !== i ? !1 : r === Oe.HEADER || r === Oe.FOOTER ? o === s : !0;
  }
  _resetCurrentNodePositionState() {
    this._currentStartState = {
      page: 0,
      section: 0,
      column: 0,
      line: 0,
      divide: 0,
      glyph: 0
      /* NORMAL */
    }, this._currentEndState = {
      page: 0,
      section: 0,
      column: 0,
      line: 0,
      divide: 0,
      glyph: 0
      /* NORMAL */
    };
  }
  _setNodePositionState(e = 0, t, o, r) {
    r === t ? this._currentStartState[e] = 1 : this._currentStartState[e] = 0, r === o ? this._currentEndState[e] = 2 : this._currentEndState[e] = 0;
  }
  _checkPreviousNodePositionState(e, t = !0) {
    let o = e, r;
    for (; o >= 0; ) {
      const s = Zn[o];
      let i;
      if (t ? i = this._currentStartState[s] : i = this._currentEndState[s], i === void 0)
        return;
      if (r === void 0 && (r = i), i !== r)
        return 0;
      o--;
    }
    return r;
  }
  _getSelectionRuler(e, t, o, r, s) {
    let i = 0, a = r;
    const c = Zn[e], d = Zn[e + 1];
    if (d === null || c === null)
      return {
        start_next: i,
        end_next: a
      };
    const l = t[c], A = o[c];
    this._setNodePositionState(c, l, A, s);
    const h = this._checkPreviousNodePositionState(e), u = this._checkPreviousNodePositionState(e, !1);
    return h === 1 && (i = t[d]), u === 2 && (a = o[d]), {
      start_next: i,
      end_next: a
    };
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _selectionIterator(e, t, o) {
    var v, R;
    const r = this._docSkeleton;
    if (!r)
      return [];
    const { pageType: s, path: i } = e;
    this._liquid.reset();
    const a = r.getSkeletonData();
    if (a == null)
      return [];
    const { pages: c, skeHeaders: d, skeFooters: l } = a, { page: A, segmentPage: h } = e, { page: u, segmentPage: g } = t;
    if (this._resetCurrentNodePositionState(), this._documentOffsetConfig == null)
      return [];
    const { pageLayoutType: f, pageMarginLeft: p, pageMarginTop: m } = this._documentOffsetConfig, I = s === Oe.BODY || s === Oe.CELL ? A : h;
    for (let E = 0; E < I; E++) {
      const b = c[E];
      this._liquid.translatePage(b, f, p, m);
    }
    const S = s === Oe.BODY || s === Oe.CELL ? u : g;
    for (let E = I; E <= S; E++) {
      const b = c[E], { headerId: y, footerId: C, pageWidth: B } = b;
      let x = b;
      if (s === Oe.HEADER ? x = (v = d.get(y)) == null ? void 0 : v.get(B) : s === Oe.FOOTER ? x = (R = l.get(C)) == null ? void 0 : R.get(B) : s === Oe.CELL && (x = cr(a, i)), x == null) {
        this._liquid.translatePage(b, f, p, m);
        continue;
      }
      const M = x.sections, { start_next: w, end_next: F } = this._getSelectionRuler(
        qt.page,
        e,
        t,
        M.length - 1,
        s === Oe.BODY || s === Oe.CELL ? E : 0
      );
      switch (this._liquid.translateSave(), s) {
        case Oe.HEADER:
          this._liquid.translatePagePadding({
            ...x,
            marginLeft: b.marginLeft
            // Because header or footer margin Left is 0.
          });
          break;
        case Oe.FOOTER: {
          const P = b.pageHeight - x.height - x.marginBottom;
          this._liquid.translate(b.marginLeft, P);
          break;
        }
        case Oe.CELL: {
          this._liquid.translatePagePadding(b);
          const P = x.parent, N = P.parent, { left: ee } = x, { top: $, left: U } = N, { top: H } = P;
          this._liquid.translate(U + ee, $ + H), this._liquid.translatePagePadding(x);
          break;
        }
        default:
          this._liquid.translatePagePadding(b);
          break;
      }
      for (let P = w; P <= F; P++) {
        const N = M[P], ee = N.columns, { start_next: $, end_next: U } = this._getSelectionRuler(
          qt.section,
          e,
          t,
          ee.length - 1,
          P
        );
        this._liquid.translateSection(N);
        for (let H = $; H <= U; H++) {
          const k = ee[H], ne = k.lines, { start_next: ie, end_next: ae } = this._getSelectionRuler(
            qt.column,
            e,
            t,
            ne.length - 1,
            H
          );
          this._liquid.translateColumn(k);
          for (let oe = ie; oe <= ae; oe++) {
            const he = ne[oe], { divides: we } = he, { start_next: Ze, end_next: At } = this._getSelectionRuler(
              qt.line,
              e,
              t,
              we.length - 1,
              oe
            );
            this._liquid.translateSave(), this._liquid.translateLine(he, !0, !1);
            for (let Je = Ze; Je <= At; Je++) {
              const Wo = we[Je];
              this._liquid.translateSave(), this._liquid.translateDivide(Wo);
              const { glyphGroup: xc } = Wo, { start_next: Oc, end_next: Tc } = this._getSelectionRuler(
                qt.divide,
                e,
                t,
                xc.length - 1,
                Je
              );
              let Ns = !1, Ls = !1;
              E === I && P === w && H === $ && oe === ie && Je === Ze && (Ns = !0), E === S && P === F && H === U && oe === ae && Je === At && (Ls = !0), o && o(Oc, Tc, Ns, Ls, Wo, he, k, N, x), this._liquid.translateRestore();
            }
            this._liquid.translateRestore();
          }
        }
      }
      this._liquid.translateRestore(), this._liquid.translatePage(b, f, p, m);
    }
  }
}
function tA(n, e) {
  const { path: t } = n, { path: o } = e;
  if (t.length !== o.length || t.indexOf("cells") === -1)
    return !1;
  const r = t.indexOf("skeTables") + 1, s = t.indexOf("rows") + 1, i = t.indexOf("cells") + 1, { tableId: a, sliceIndex: c } = Ws(t[r]), { tableId: d, sliceIndex: l } = Ws(o[r]);
  if (a !== d)
    return !1;
  const A = t[s], h = o[s], u = t[i], g = o[i];
  return !(A === h && u === g && c === l);
}
function Fa(n, e) {
  const { path: t } = n, { path: o } = e;
  return t.indexOf("cells") === -1 || o.indexOf("cells") === -1 || t.length !== o.length ? !1 : ue.diffValue(t, o);
}
function Ha(n, e, t) {
  var u, g, f, p, m, I, S, v;
  const { path: o } = e, { path: r } = t;
  if (o.indexOf("cells") === -1 || r.indexOf("cells") === -1)
    return !1;
  const s = n.findGlyphByPosition(e), i = n.findGlyphByPosition(t), a = (p = (f = (g = (u = s == null ? void 0 : s.parent) == null ? void 0 : u.parent) == null ? void 0 : g.parent) == null ? void 0 : f.parent) == null ? void 0 : p.parent, c = (v = (S = (I = (m = i == null ? void 0 : i.parent) == null ? void 0 : m.parent) == null ? void 0 : I.parent) == null ? void 0 : S.parent) == null ? void 0 : v.parent;
  if (a == null || c == null)
    return !1;
  const d = a.parent, l = c.parent, A = d.cells.indexOf(a), h = l.cells.indexOf(c);
  return A === h && d.index === l.index;
}
function Xo(n, e) {
  if (Fa(n, e))
    return ms(n, e);
  const { path: t } = n, { path: o } = e, r = t[t.length - 5], s = o[o.length - 5];
  if (r !== s && typeof r == "string" && typeof s == "string") {
    const l = r.split("#-#")[1], A = s.split("#-#")[1];
    return +l < +A;
  }
  const i = t[t.length - 3], a = o[o.length - 3], c = t[t.length - 1], d = o[o.length - 1];
  return i < a ? !0 : i > a ? !1 : c <= d;
}
function jt(n) {
  return n.sections[0].columns[0].lines.length === 0;
}
function nA(n, e, t) {
  let o = e, r = t, s = n[o], i = n[r];
  for (; o < r && (jt(s) || jt(i)); )
    jt(s) ? (o++, s = n[o]) : jt(i) && (r--, i = n[r]);
  if (!jt(s) && !jt(i))
    return [s, i];
}
class ka {
  constructor(e, t) {
    O(this, "_liquid", new Ji());
    this._documentOffsetConfig = e, this._docSkeleton = t;
  }
  // eslint-disable-next-line max-lines-per-function
  getRangePointData(e, t) {
    const o = [], s = this._docSkeleton.getSkeletonData();
    if (s == null)
      return;
    const { pages: i } = s, { segmentPage: a, page: c, pageType: d } = e, l = this._getTableRectRangeInfo(e, t);
    if (l == null)
      return;
    const {
      tableId: A,
      startRowIndex: h,
      startColumnIndex: u,
      endRowIndex: g,
      endColumnIndex: f
    } = l;
    this._liquid.reset();
    const { pageLayoutType: p, pageMarginLeft: m, pageMarginTop: I } = this._documentOffsetConfig, S = d === Oe.BODY || d === Oe.CELL ? c : a;
    for (let v = 0; v < S; v++) {
      const R = i[v];
      this._liquid.translatePage(R, p, m, I);
    }
    for (let v = S; v < i.length; v++) {
      const R = i[v];
      this._liquid.translatePagePadding(R);
      const { skeTables: E } = R;
      let b = null;
      for (const [x, M] of E.entries())
        x.startsWith(A) && (b = M);
      if (b == null) {
        this._liquid.restorePagePadding(R), this._liquid.translatePage(R, p, m, I);
        continue;
      }
      this._liquid.translateSave(), this._liquid.translate(0, b.top);
      const { x: y, y: C } = this._liquid, { left: B } = b;
      for (const x of b.rows)
        if (x.index >= h && x.index <= g) {
          const M = nA(x.cells, u, f);
          if (M == null)
            continue;
          const [w, F] = M, P = {
            startX: y + w.left + B,
            startY: C + x.top,
            endX: y + F.left + F.pageWidth + B,
            endY: C + x.top + x.height
          };
          o.push(pr(P));
        }
      this._liquid.translateRestore(), this._liquid.restorePagePadding(R), this._liquid.translatePage(R, p, m, I);
    }
    return {
      pointGroup: o,
      startRow: h,
      startColumn: u,
      endRow: g,
      endColumn: f,
      tableId: A
    };
  }
  getNodePositionGroup(e, t) {
    const o = [], r = this._docSkeleton.findCharIndexByPosition(e), s = this._docSkeleton.findCharIndexByPosition(t);
    if (r == null || s == null)
      return;
    const i = r < s, a = this._getTableRectRangeInfo(e, t);
    if (a == null)
      return;
    const { tableId: c, startRowIndex: d, startColumnIndex: l, endRowIndex: A, endColumnIndex: h } = a, u = this._docSkeleton.getViewModel().findTableNodeById(c);
    if (u == null)
      return;
    const g = u.children[0].children.length;
    if (l === 0 && h === g - 1) {
      const p = u.children[d].children[l], m = this._docSkeleton.findNodePositionByCharIndex(p.startIndex + 1), I = u.children[A].children[h], S = this._docSkeleton.findNodePositionByCharIndex(I.endIndex - 2);
      if (m == null || S == null)
        return;
      o.push({
        anchor: i ? m : S,
        focus: i ? S : m
      });
    } else
      for (let p = d; p <= A; p++) {
        const m = u.children[p], I = m.children[l], S = m.children[h], v = this._docSkeleton.findNodePositionByCharIndex(I.startIndex + 1), R = this._docSkeleton.findNodePositionByCharIndex(S.endIndex - 2);
        if (v == null || R == null)
          return;
        o.push({
          anchor: i ? v : R,
          focus: i ? R : v
        });
      }
    return o;
  }
  _getTableRectRangeInfo(e, t) {
    const r = this._docSkeleton.getSkeletonData();
    if (r == null)
      return;
    const { pages: s } = r, { path: i } = e, { path: a } = t, c = cr(r, i), d = cr(r, a);
    if (c == null || d == null)
      return;
    const l = c.segmentId, A = c.parent.index, h = c.parent.cells.indexOf(c), u = (d == null ? void 0 : d.parent).index, g = (d == null ? void 0 : d.parent).cells.indexOf(d), f = Math.min(A, u), p = Math.max(A, u), m = Math.min(h, g), I = Math.max(h, g);
    return {
      pages: s,
      tableId: l,
      startRowIndex: f,
      startColumnIndex: m,
      endRowIndex: p,
      endColumnIndex: I
    };
  }
}
const oA = "__TestSelectionRange__", rA = "__TestSelectionAnchor__", pi = 6, Zo = 500, sA = 500, mr = 3;
function Jn(n) {
  const e = n[0], t = e[0], o = e[2], { x: r, y: s } = t, { x: i, y: a } = o;
  return {
    left: r,
    top: s,
    width: i - r,
    height: a - s
  };
}
function Es(n) {
  return n.map((e) => {
    let t = 1 / 0, o = -1 / 0, r = 1 / 0, s = -1 / 0;
    return e.forEach((i) => {
      t = Math.min(i.x, t), o = Math.max(i.x, o), s = Math.max(i.y, s), r = Math.min(i.y, r);
    }), {
      left: t,
      right: o,
      top: r,
      bottom: s
    };
  });
}
class Zt {
  constructor(e, t, o, r, s, i = Sn, a = "", c = -1) {
    O(this, "rangeType", He.TEXT);
    // Identifies whether the range is the current one, most of which is the last range.
    O(this, "_current", !1);
    // The rendered range graphic when collapsed is false
    O(this, "_rangeShape");
    // The rendered range graphic when collapsed is true
    O(this, "_anchorShape");
    O(this, "_cursorList", []);
    O(this, "_anchorBlinkTimer", null);
    this._scene = e, this._document = t, this._docSkeleton = o, this.anchorNodePosition = r, this.focusNodePosition = s, this.style = i, this._segmentId = a, this._segmentPage = c, this._anchorBlink(), this.refresh();
  }
  _anchorBlink() {
    setTimeout(() => {
      this._anchorShape && this._anchorShape.visible && this.deactivateStatic();
    }, Zo), this._anchorBlinkTimer = setInterval(() => {
      this._anchorShape && this._anchorShape.visible && (this.activeStatic(), setTimeout(() => {
        this.deactivateStatic();
      }, Zo));
    }, sA + Zo);
  }
  // The start position of the range
  get startOffset() {
    var r;
    const { startOffset: e } = (r = fi(this._cursorList)) != null ? r : {}, t = this._docSkeleton.getViewModel().getDataModel().getSelfOrHeaderFooterModel(this._segmentId).getBody();
    if (e == null || t == null)
      return e;
    const o = t.dataStream.length - 2;
    return Math.min(o, e);
  }
  // The end position of the range
  get endOffset() {
    var r;
    const { endOffset: e } = (r = fi(this._cursorList)) != null ? r : {}, t = this._docSkeleton.getViewModel().getDataModel().getSelfOrHeaderFooterModel(this._segmentId).getBody();
    if (e == null || t == null)
      return e;
    const o = t.dataStream.length - 2;
    return Math.min(e, o);
  }
  get collapsed() {
    const { startOffset: e, endOffset: t } = this;
    return e != null && e === t;
  }
  get startNodePosition() {
    if (this.anchorNodePosition == null)
      return null;
    if (this.focusNodePosition == null)
      return this.anchorNodePosition;
    const { start: e } = fr(this.anchorNodePosition, this.focusNodePosition);
    return e;
  }
  get endNodePosition() {
    if (this.anchorNodePosition == null)
      return this.focusNodePosition;
    if (this.focusNodePosition == null)
      return null;
    const { end: e } = fr(this.anchorNodePosition, this.focusNodePosition);
    return e;
  }
  get direction() {
    const { collapsed: e, anchorNodePosition: t, focusNodePosition: o } = this;
    return e || t == null || o == null ? De.NONE : ms(t, o) ? De.FORWARD : De.BACKWARD;
  }
  get segmentId() {
    return this._segmentId;
  }
  get segmentPage() {
    return this._segmentPage;
  }
  getAbsolutePosition() {
    const e = this.anchorNodePosition, t = this.focusNodePosition;
    if (this._isEmpty())
      return;
    const o = this._document.getOffsetConfig(), { docsLeft: r, docsTop: s } = o, i = new It(o, this._docSkeleton);
    if (this._isCollapsed()) {
      const { contentBoxPointGroup: l, cursorList: A } = i.getRangePointData(e, e);
      if (this._setCursorList(A), l.length === 0)
        return;
      const h = Jn(l);
      return {
        ...h,
        left: h.left + r,
        top: h.top + s
      };
    }
    const { borderBoxPointGroup: a, cursorList: c } = i.getRangePointData(e, t);
    if (this._setCursorList(c), a.length === 0)
      return;
    const d = Jn(a);
    return {
      ...d,
      left: d.left + r,
      top: d.top + s
    };
  }
  getAnchor() {
    return this._anchorShape;
  }
  activeStatic() {
    var e, t;
    (t = this._anchorShape) == null || t.setProps({
      stroke: ((e = this.style) == null ? void 0 : e.strokeActive) || fn(gn.black, 1)
    });
  }
  deactivateStatic() {
    var e, t;
    (t = this._anchorShape) == null || t.setProps({
      stroke: ((e = this.style) == null ? void 0 : e.stroke) || fn(gn.black, 0)
    });
  }
  isActive() {
    return this._current === !0;
  }
  activate() {
    this._current = !0;
  }
  deactivate() {
    this._current = !1;
  }
  dispose() {
    var e, t;
    (e = this._rangeShape) == null || e.dispose(), this._rangeShape = null, (t = this._anchorShape) == null || t.dispose(), this._anchorShape = null, this._anchorBlinkTimer && (clearInterval(this._anchorBlinkTimer), this._anchorBlinkTimer = null);
  }
  isIntersection(e) {
    const { startOffset: t, endOffset: o } = this, { startOffset: r, endOffset: s } = e;
    return t == null || o == null || r == null || s == null ? !1 : t <= s && o >= r;
  }
  // render cursor and selection.
  refresh() {
    var A, h;
    const { _document: e, _docSkeleton: t } = this, o = this.anchorNodePosition, r = this.focusNodePosition;
    if ((A = this._anchorShape) == null || A.hide(), (h = this._rangeShape) == null || h.hide(), this._isEmpty())
      return;
    const s = e.getOffsetConfig(), { docsLeft: i, docsTop: a } = s, c = new It(s, t);
    if (this._isCollapsed()) {
      const { contentBoxPointGroup: u, cursorList: g } = c.getRangePointData(o, o);
      if (this._setCursorList(g), u.length > 0) {
        const f = t.findGlyphByPosition(o);
        this._createOrUpdateAnchor(u, i, a, f);
      }
      return;
    }
    const { borderBoxPointGroup: d, cursorList: l } = c.getRangePointData(o, r);
    this._setCursorList(l), d.length > 0 && this._createOrUpdateRange(d, i, a);
  }
  _isEmpty() {
    return this.anchorNodePosition == null && this.focusNodePosition == null;
  }
  _isCollapsed() {
    const e = this.anchorNodePosition, t = this.focusNodePosition;
    if (e != null && t == null)
      return !0;
    if (e == null || t == null)
      return !1;
    const o = Object.keys(qt);
    for (const r of o) {
      const s = e[r], i = t[r];
      if (s !== i)
        return !1;
    }
    return e.isBack === t.isBack;
  }
  _createOrUpdateRange(e, t, o) {
    var i;
    if (this._rangeShape) {
      this._rangeShape.translate(t, o), this._rangeShape.updatePointGroup(e), this._rangeShape.show();
      return;
    }
    const r = 0.3, s = new ea(oA + ge(pi), {
      pointsGroup: e,
      fill: ((i = this.style) == null ? void 0 : i.fill) || fn(gn.black, r),
      left: t,
      top: o,
      evented: !1,
      debounceParentDirty: !1
    });
    this._rangeShape = s, this._scene.addObject(s, mr);
  }
  _createOrUpdateAnchor(e, t, o, r) {
    var f, p, m;
    const s = Jn(e), { left: i } = s;
    let { top: a, height: c } = s;
    const d = 14;
    c < d && (a -= d - c, c = d);
    const l = 12;
    let A = i + t;
    const h = a + o, u = ((f = r == null ? void 0 : r.ts) == null ? void 0 : f.it) === z.TRUE;
    if (u && (A += c * Math.tan(l * Math.PI / 180) / 2), this._anchorShape) {
      this._anchorShape.transformByState({ left: A, top: h, height: c }), this._anchorShape.show(), u ? this._anchorShape.skew(-l, 0) : this._anchorShape.skew(0, 0);
      return;
    }
    const g = new Kn(rA + ge(pi), {
      left: A,
      top: h,
      height: c,
      strokeWidth: ((p = this.style) == null ? void 0 : p.strokeWidth) || 1,
      stroke: ((m = this.style) == null ? void 0 : m.strokeActive) || fn(gn.black, 1),
      evented: !1
    });
    u && g.skew(-l, 0), this._anchorShape = g, this._scene.addObject(g, mr), this.activeStatic();
  }
  _setCursorList(e) {
    e.length !== 0 && (this._cursorList = e);
  }
}
const iA = "__DocTableRectRange__", aA = 6;
function Jo(n, e, t, o, r, s = Sn, i = "", a = -1) {
  const c = e.getOffsetConfig(), l = new ka(c, t).getNodePositionGroup(o, r);
  return (l != null ? l : []).map((A) => new Va(
    n,
    e,
    t,
    A.anchor,
    A.focus,
    s,
    i,
    a
  ));
}
class Va {
  constructor(e, t, o, r, s, i = Sn, a = "", c = -1) {
    O(this, "rangeType", He.RECT);
    // The rendered rect range
    O(this, "_rangeShape");
    // Identifies whether the range is the current one, most of which is the last range.
    O(this, "_current", !1);
    // Rect Range start row.
    O(this, "_startRow");
    // Rect Range start column.
    O(this, "_startCol");
    // Rect Range end row.
    O(this, "_endRow");
    // Rect Range end column.
    O(this, "_endCol");
    // table id in view model.
    O(this, "_tableId");
    this._scene = e, this._document = t, this._docSkeleton = o, this.anchorNodePosition = r, this.focusNodePosition = s, this.style = i, this._segmentId = a, this._segmentPage = c, this.refresh();
  }
  get startOffset() {
    const { startNodePosition: e } = this;
    return this._docSkeleton.findCharIndexByPosition(e);
  }
  get endOffset() {
    const { endNodePosition: e } = this;
    return this._docSkeleton.findCharIndexByPosition(e);
  }
  get collapsed() {
    return !1;
  }
  get startRow() {
    return this._startRow;
  }
  get startColumn() {
    return this._startCol;
  }
  get endRow() {
    return this._endRow;
  }
  get endColumn() {
    return this._endCol;
  }
  get tableId() {
    return this._tableId;
  }
  get segmentId() {
    return this._segmentId;
  }
  get segmentPage() {
    return this._segmentPage;
  }
  get spanEntireRow() {
    var i;
    const t = (i = this._docSkeleton.getViewModel().getSnapshot().tableSource) == null ? void 0 : i[this._tableId], { _startCol: o, _endCol: r } = this;
    if (t == null)
      throw new Error("Table is not found.");
    const { tableColumns: s } = t;
    return o === 0 && r === s.length - 1;
  }
  get spanEntireColumn() {
    var i;
    const t = (i = this._docSkeleton.getViewModel().getSnapshot().tableSource) == null ? void 0 : i[this._tableId], { _startRow: o, _endRow: r } = this;
    if (t == null)
      throw new Error("Table is not found.");
    const { tableRows: s } = t;
    return o === 0 && r === s.length - 1;
  }
  get spanEntireTable() {
    return this.spanEntireRow && this.spanEntireColumn;
  }
  get startNodePosition() {
    const { anchorNodePosition: e, focusNodePosition: t } = this;
    return Xo(e, t) ? e : t;
  }
  get endNodePosition() {
    const { anchorNodePosition: e, focusNodePosition: t } = this;
    return Xo(e, t) ? t : e;
  }
  get direction() {
    const { anchorNodePosition: e, focusNodePosition: t } = this;
    return Xo(e, t) ? De.FORWARD : De.BACKWARD;
  }
  isActive() {
    return this._current === !0;
  }
  activate() {
    this._current = !0;
  }
  deactivate() {
    this._current = !1;
  }
  dispose() {
    var e;
    (e = this._rangeShape) == null || e.dispose(), this._rangeShape = null;
  }
  isIntersection(e) {
    const { startRow: t, startColumn: o, endRow: r, endColumn: s } = this, { startRow: i, startColumn: a, endRow: c, endColumn: d } = e, l = {
      left: o,
      top: t,
      right: s,
      bottom: r
    }, A = {
      left: a,
      top: i,
      right: d,
      bottom: c
    };
    return Hc.hasIntersectionBetweenTwoRect(l, A);
  }
  refresh() {
    var p;
    (p = this._rangeShape) == null || p.hide();
    const { startNodePosition: e, endNodePosition: t, _document: o, _docSkeleton: r } = this, s = o.getOffsetConfig(), { docsLeft: i, docsTop: a } = s, d = new ka(s, r).getRangePointData(e, t);
    if (d == null)
      return;
    const { pointGroup: l = [], startRow: A, endRow: h, startColumn: u, endColumn: g, tableId: f } = d;
    (l == null ? void 0 : l.length) > 0 && this._createOrUpdateRange(l, i, a), this._updateTableInfo(A, h, u, g, f);
  }
  _updateTableInfo(e, t, o, r, s) {
    this._startRow = e, this._endRow = t, this._startCol = o, this._endCol = r, this._tableId = s;
  }
  _createOrUpdateRange(e, t, o) {
    var i;
    if (this._rangeShape) {
      this._rangeShape.translate(t, o), this._rangeShape.updatePointGroup(e), this._rangeShape.show();
      return;
    }
    const r = 0.3, s = new ea(iA + ge(aA), {
      pointsGroup: e,
      fill: ((i = this.style) == null ? void 0 : i.fill) || fn(gn.black, r),
      left: t,
      top: o,
      evented: !1,
      debounceParentDirty: !1
    });
    this._rangeShape = s, this._scene.addObject(s, mr);
  }
}
function mi(n, e, t, o, r, s, i, a, c = !0, d = !0) {
  const l = r.findNodePositionByCharIndex(n, c, i, a), A = r.findNodePositionByCharIndex(e, d, i, a);
  if (!(l == null || A == null))
    return new Zt(t, o, r, l, A, s, i, a);
}
function cA(n, e, t, o, r, s, i, a) {
  const c = r.findNodePositionByCharIndex(n, !0, i, a), d = r.findNodePositionByCharIndex(e, !0, i, a);
  if (!(c == null || d == null))
    return new Va(t, o, r, c, d, s, i, a);
}
function lA(n, e, t, o, r, s, i, a) {
  const c = r.findNodePositionByCharIndex(n, !0, i, a), d = r.findNodePositionByCharIndex(e, !0, i, a);
  if (!(c == null || d == null))
    return Er(
      c,
      d,
      t,
      o,
      r,
      s,
      i,
      a
    );
}
function Er(n, e, t, o, r, s, i, a) {
  const c = [], d = [], l = [t, o, r, n, e, s, i, a];
  if (Ha(r, n, e)) {
    if (Fa(n, e))
      return c.push(new Zt(...l)), {
        textRanges: c,
        rectRanges: d
      };
    {
      const S = Jo(
        ...l
      );
      return d.push(...S), {
        textRanges: c,
        rectRanges: d
      };
    }
  }
  if (tA(n, e)) {
    const S = Jo(
      ...l
    );
    return d.push(...S), {
      textRanges: c,
      rectRanges: d
    };
  }
  const A = r.getViewModel().getSelfOrHeaderFooterViewModel(i), h = r.findCharIndexByPosition(n), u = r.findCharIndexByPosition(e);
  if (h == null || u == null)
    return;
  const g = h <= u ? De.FORWARD : De.BACKWARD, f = Math.min(h, u), p = Math.max(h, u);
  let m = f, I = p;
  for (const S of A.getChildren())
    for (const v of S.children) {
      const { startIndex: R, endIndex: E, children: b } = v, y = S.children.indexOf(v), C = S.children[y + 1], B = b[0];
      let x = !1;
      if (B) {
        const { startIndex: M, endIndex: w, children: F } = B;
        let P = null, N = null;
        const ee = F.find((U) => U.startIndex <= f && U.endIndex >= f), $ = F.find((U) => U.startIndex <= p && U.endIndex >= p);
        if (f > M && f < w)
          P = r.findNodePositionByCharIndex(ee.startIndex + 2, !0, i, a), N = r.findNodePositionByCharIndex(w - 4, !0, i, a), m = w + 1;
        else if (p > M && p < w)
          P = r.findNodePositionByCharIndex(M + 3, !0, i, a), N = r.findNodePositionByCharIndex($.endIndex - 3, !0, i, a), I = M - 1, x = !0;
        else if (M > f && w < p) {
          if (P = r.findNodePositionByCharIndex(M + 3, !0, i, a), N = r.findNodePositionByCharIndex(w - 4, !0, i, a), m <= M - 1) {
            const U = r.findNodePositionByCharIndex(m, !0, i, a), H = r.findNodePositionByCharIndex(M - 1, !1, i, a), k = g === De.FORWARD ? U : H, ne = g === De.FORWARD ? H : U;
            c.push(new Zt(t, o, r, k, ne, s, i, a));
          }
          m = w + 1;
        }
        if (P && N) {
          const U = g === De.FORWARD ? P : N, H = g === De.FORWARD ? N : P;
          d.push(...Jo(
            t,
            o,
            r,
            U,
            H,
            s,
            i,
            a
          ));
        }
      }
      if (I === E + 1 && !x && C && C.children.length && (I = E, x = !0), I >= R && I <= E || x) {
        const M = r.findNodePositionByCharIndex(m, !0, i, a), w = r.findNodePositionByCharIndex(I, !x, i, a), F = g === De.FORWARD ? M : w, P = g === De.FORWARD ? w : M;
        if (d.length && ue.diffValue(F, P))
          continue;
        c.push(new Zt(t, o, r, F, P, s, i, a));
      }
    }
  return {
    textRanges: c,
    rectRanges: d
  };
}
function dA(n) {
  const e = n == null ? void 0 : n.getCanvasElement();
  if (!e)
    return {
      left: 0,
      top: 0
    };
  const { top: t, left: o } = cl(e);
  return {
    left: o,
    top: t
  };
}
function Ei(n) {
  var c;
  const e = (c = n.parent) == null ? void 0 : c.parent, t = e == null ? void 0 : e.parent;
  if (e == null || t == null)
    return;
  const { paragraphIndex: o } = e, r = t.lines.filter((d) => d.paragraphIndex === o);
  let s = -1, i = "", a = !1;
  for (const d of r)
    for (const l of d.divides)
      for (const A of l.glyphGroup)
        a || (s += A.count), A === n && (a = !0), i += A.count > 0 ? A.content : "";
  return {
    st: r[0].st,
    ed: o,
    content: i,
    nodeIndex: s
  };
}
function Ir(n) {
  const { startOffset: e, endOffset: t, collapsed: o, rangeType: r, startNodePosition: s, endNodePosition: i, direction: a, segmentId: c, segmentPage: d } = n;
  return {
    startOffset: e,
    endOffset: t,
    collapsed: o,
    rangeType: r,
    startNodePosition: s,
    endNodePosition: i,
    direction: a,
    segmentId: c,
    segmentPage: d,
    isActive: n.isActive()
  };
}
function AA(n) {
  const e = Ir(n), {
    startRow: t,
    startColumn: o,
    endRow: r,
    endColumn: s,
    tableId: i,
    spanEntireRow: a,
    spanEntireColumn: c,
    spanEntireTable: d
  } = n;
  return {
    ...e,
    startRow: t,
    startColumn: o,
    endRow: r,
    endColumn: s,
    tableId: i,
    spanEntireRow: a,
    spanEntireColumn: c,
    spanEntireTable: d
  };
}
var uA = Object.getOwnPropertyDescriptor, hA = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? uA(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, Vn = (n, e) => (t, o) => e(t, o, n);
let Re = class extends Ct {
  constructor(e, t, o, r, s) {
    super();
    O(this, "_onInputBefore$", new be());
    O(this, "onInputBefore$", this._onInputBefore$.asObservable());
    O(this, "_onKeydown$", new be());
    O(this, "onKeydown$", this._onKeydown$.asObservable());
    O(this, "_onInput$", new be());
    O(this, "onInput$", this._onInput$.asObservable());
    O(this, "_onCompositionstart$", new Fe(null));
    O(this, "onCompositionstart$", this._onCompositionstart$.asObservable());
    O(this, "_onCompositionupdate$", new Fe(null));
    O(this, "onCompositionupdate$", this._onCompositionupdate$.asObservable());
    O(this, "_onCompositionend$", new Fe(null));
    O(this, "onCompositionend$", this._onCompositionend$.asObservable());
    O(this, "_onSelectionStart$", new Fe(null));
    O(this, "onSelectionStart$", this._onSelectionStart$.asObservable());
    O(this, "onChangeByEvent$", ua(
      this._onInput$,
      this._onKeydown$.pipe(oo((e) => e.event.keyCode === q.BACKSPACE)),
      this._onCompositionend$
    ));
    O(this, "_onPaste$", new be());
    O(this, "onPaste$", this._onPaste$.asObservable());
    O(this, "_textSelectionInner$", new Fe(null));
    O(this, "textSelectionInner$", this._textSelectionInner$.asObservable());
    O(this, "_onFocus$", new be());
    O(this, "onFocus$", this._onFocus$.asObservable());
    O(this, "_onBlur$", new be());
    O(this, "onBlur$", this._onBlur$.asObservable());
    O(this, "_onPointerDown$", new be());
    O(this, "onPointerDown$", this._onPointerDown$.asObservable());
    O(this, "_container");
    O(this, "_inputParent");
    O(this, "_input");
    O(this, "_scrollTimers", []);
    O(this, "_rangeList", []);
    // Use to cache range list in moving.
    O(this, "_rangeListCache", []);
    // Rect range list.
    O(this, "_rectRangeList", []);
    // Use to cache rect range list in moving.
    O(this, "_rectRangeListCache", []);
    O(this, "_anchorNodePosition", null);
    O(this, "_focusNodePosition", null);
    O(this, "_currentSegmentId", "");
    O(this, "_currentSegmentPage", -1);
    O(this, "_selectionStyle", Sn);
    O(this, "_onPointerEvent", !1);
    O(this, "_viewPortObserverMap", /* @__PURE__ */ new Map());
    O(this, "_isIMEInputApply", !1);
    O(this, "_scenePointerMoveSubs", []);
    O(this, "_scenePointerUpSubs", []);
    // When the user switches editors, whether to clear the doc ranges.
    O(this, "_reserveRanges", !1);
    this._context = e, this._layoutService = t, this._logService = o, this._univerInstanceService = r, this._docSkeletonManagerService = s, this._initDOM(), this._registerContainer(), this._setSystemHighlightColorToStyle(), this._listenCurrentUnitChange();
  }
  get isOnPointerEvent() {
    return this._onPointerEvent;
  }
  get isFocusing() {
    return this._input === document.activeElement;
  }
  get canFocusing() {
    return this.isFocusing || document.activeElement === document.body || document.activeElement === null;
  }
  _listenCurrentUnitChange() {
    this._univerInstanceService.getCurrentTypeOfUnit$(_.UNIVER_DOC).pipe(ft(this.dispose$)).subscribe((e) => {
      if (e == null)
        return;
      e.getUnitId() !== this._context.unitId && !this._reserveRanges && this.removeAllRanges();
    });
  }
  get activeViewPort() {
    return this._context.scene.getViewports()[0];
  }
  setSegment(e) {
    this._currentSegmentId = e;
  }
  getSegment() {
    return this._currentSegmentId;
  }
  setSegmentPage(e) {
    this._currentSegmentPage = e;
  }
  getSegmentPage() {
    return this._currentSegmentPage;
  }
  setReserveRangesStatus(e) {
    this._reserveRanges = e;
  }
  _setRangeStyle(e = Sn) {
    this._selectionStyle = e;
  }
  // eslint-disable-next-line max-lines-per-function
  addDocRanges(e, t = !0, o) {
    const {
      _currentSegmentId: r,
      _currentSegmentPage: s,
      _selectionStyle: i
    } = this, { scene: a, mainComponent: c } = this._context, d = c, l = this._docSkeletonManagerService.getSkeleton(), A = (h, u) => {
      const g = lA(
        h,
        u,
        a,
        d,
        l,
        i,
        r,
        s
      );
      if (g == null)
        return;
      const { textRanges: f, rectRanges: p } = g;
      for (const m of f)
        this._addTextRange(m);
      this._addRectRanges(p);
    };
    for (const h of e) {
      const { startOffset: u, endOffset: g, rangeType: f, startNodePosition: p, endNodePosition: m } = h;
      if (f === He.RECT) {
        const I = cA(
          u,
          g,
          a,
          d,
          l,
          i,
          r,
          s
        );
        I && this._addRectRanges([I]);
      } else if (f === He.TEXT)
        try {
          let I = null;
          p && m ? I = mi(
            p.isBack ? u : u - 1,
            m.isBack ? g : g - 1,
            a,
            d,
            l,
            i,
            r,
            s,
            p.isBack,
            m.isBack
          ) : I = mi(
            u,
            g,
            a,
            d,
            l,
            i,
            r,
            s
          ), I && this._addTextRange(I);
        } catch {
          A(u, g);
        }
      else
        A(u, g);
    }
    this._textSelectionInner$.next({
      textRanges: this._getAllTextRanges(),
      rectRanges: this._getAllRectRanges(),
      segmentId: r,
      segmentPage: s,
      style: i,
      isEditing: t,
      options: o
    }), !(!e.length || (o == null ? void 0 : o.shouldFocus) === !1) && this._updateInputPosition(o == null ? void 0 : o.forceFocus);
  }
  setCursorManually(e, t) {
    const o = this._findNodeByCoord(e, t, {
      strict: !0,
      segmentId: this._currentSegmentId,
      segmentPage: this._currentSegmentPage
    }), r = this._getNodePosition(o);
    if (r == null) {
      this._removeAllRanges();
      return;
    }
    (o == null ? void 0 : o.node.streamType) === V.PARAGRAPH && (r.isBack = !0), this._createTextRangeByAnchorPosition(r), this._textSelectionInner$.next({
      textRanges: this._getAllTextRanges(),
      rectRanges: this._getAllRectRanges(),
      segmentId: this._currentSegmentId,
      segmentPage: this._currentSegmentPage,
      style: this._selectionStyle,
      isEditing: !1
    });
  }
  // Sync canvas selection to dom selection.
  sync() {
    this._updateInputPosition();
  }
  /**
   * @deprecated
   */
  activate(e, t, o = !1) {
    this._container.style.left = `${e}px`, this._container.style.top = `${t}px`, this._container.style.zIndex = "1000", (this.canFocusing || o) && this.focus();
  }
  hasFocus() {
    return document.activeElement === this._input;
  }
  focus() {
    this._input.focus();
  }
  blur() {
    this._input.blur();
  }
  // FIXME: for editor cell editor we don't need to blur the input element
  /**
   * @deprecated
   */
  deactivate() {
    this._container.style.left = "0px", this._container.style.top = "0px";
  }
  // Handler double click.
  __handleDblClick(e) {
    const { offsetX: t, offsetY: o } = e, r = this._findNodeByCoord(t, o, {
      strict: !1,
      segmentId: this._currentSegmentId,
      segmentPage: this._currentSegmentPage
    });
    if (r == null || r.node == null)
      return;
    const s = Ei(r.node);
    if (s == null)
      return;
    const { content: i, st: a, nodeIndex: c } = s;
    if (c === -1 || Intl.Segmenter == null)
      return;
    const l = new Intl.Segmenter(void 0, { granularity: "word" }).segment(i);
    let A = Number.NEGATIVE_INFINITY, h = Number.NEGATIVE_INFINITY;
    for (const { segment: u, index: g, isWordLike: f } of l)
      if (g <= c && c < g + u.length && f) {
        A = g + a, h = g + a + u.length;
        break;
      }
    if (Number.isFinite(A) && Number.isFinite(h)) {
      this.removeAllRanges();
      const u = [
        {
          startOffset: A,
          endOffset: h
        }
      ];
      this.addDocRanges(u, !1, { forceFocus: !0 });
    }
  }
  __handleTripleClick(e) {
    const { offsetX: t, offsetY: o } = e, r = this._findNodeByCoord(t, o, {
      strict: !1,
      segmentId: this._currentSegmentId,
      segmentPage: this._currentSegmentPage
    });
    if (r == null || r.node == null)
      return;
    const s = Ei(r.node);
    if (s == null)
      return;
    this.removeAllRanges();
    const { st: i, ed: a } = s, c = [
      {
        startOffset: i,
        endOffset: a
      }
    ];
    this.addDocRanges(c, !1, { forceFocus: !0 });
  }
  // Handle pointer down.
  // eslint-disable-next-line max-lines-per-function, complexity
  __onPointDown(e) {
    var f, p;
    const { scene: t, mainComponent: o } = this._context, r = this._docSkeletonManagerService.getSkeleton(), { offsetX: s, offsetY: i } = e, a = this._findNodeByCoord(s, i, {
      strict: !1,
      segmentId: this._currentSegmentId,
      segmentPage: this._currentSegmentPage
    }), c = this._getNodePosition(a);
    if (c == null || a == null) {
      this._removeAllRanges();
      return;
    }
    (a == null ? void 0 : a.node.streamType) === V.PARAGRAPH && (c.isBack = !0);
    const d = this._textSelectionInner$.value;
    if (a && e.button === 2 && d) {
      const m = r.findCharIndexByPosition(c);
      if (typeof m == "number" && d.textRanges.some((I) => I.startOffset <= m && I.endOffset > m) || typeof m == "number" && d.rectRanges.some((I) => I.startOffset <= m && I.endOffset >= m))
        return;
    }
    const { segmentId: l, segmentPage: A } = a;
    l && this._currentSegmentId && l !== this._currentSegmentId && this.setSegment(l), l && A !== this._currentSegmentPage && this.setSegmentPage(A), this._anchorNodePosition = c, e.shiftKey && this._getActiveRangeInstance() ? this._updateActiveRangePosition(c) : e.ctrlKey ? this._removeAllCollapsedTextRanges() : this._isEmpty() || this._removeAllRanges(), t.disableObjectsEvent();
    const h = ll.create(t);
    this._scrollTimers.push(h), h.startScroll(s, i), this._onSelectionStart$.next((f = this._getActiveRangeInstance()) == null ? void 0 : f.startNodePosition), (p = t.getTransformer()) == null || p.clearSelectedObjects();
    let u = s, g = i;
    this._onPointerEvent = !0, this._scenePointerMoveSubs.push(t.onPointerMove$.subscribeEvent((m) => {
      const { offsetX: I, offsetY: S } = m;
      t.setCursor(Dt.TEXT), !(Math.sqrt((I - u) ** 2 + (S - g) ** 2) < 3) && (this._moving(I, S), h.scrolling(I, S, () => {
        this._moving(I, S);
      }), u = I, g = S);
    })), this._scenePointerUpSubs.push(t.onPointerUp$.subscribeEvent(() => {
      if ([...this._scenePointerMoveSubs, ...this._scenePointerUpSubs].forEach((I) => {
        I.unsubscribe();
      }), this._onPointerEvent = !1, t.enableObjectsEvent(), this._anchorNodePosition && !this._focusNodePosition) {
        if (e.ctrlKey) {
          this._disposeScrollTimers();
          return;
        }
        const I = new Zt(t, o, r, this._anchorNodePosition, void 0, this._selectionStyle, this._currentSegmentId, this._currentSegmentPage);
        this._addTextRange(I);
      } else if (this._anchorNodePosition && this._focusNodePosition) {
        for (const I of this._rangeListCache)
          e.ctrlKey ? I.collapsed ? I.dispose() : this._addTextRange(I) : this._addTextRange(I);
        this._addRectRanges(this._rectRangeListCache), this._rangeListCache = [], this._rectRangeListCache = [];
      }
      this._anchorNodePosition = null, this._focusNodePosition = null;
      const m = {
        textRanges: this._getAllTextRanges(),
        rectRanges: this._getAllRectRanges(),
        segmentId: this._currentSegmentId,
        segmentPage: this._currentSegmentPage,
        style: this._selectionStyle,
        isEditing: !1
      };
      this._textSelectionInner$.next(m), this._disposeScrollTimers(), this._updateInputPosition(!0);
    }));
  }
  removeAllRanges() {
    this._removeAllRanges(), this.deactivate();
  }
  getActiveTextRange() {
    return this._getActiveRangeInstance();
  }
  _disposeScrollTimers() {
    this._scrollTimers.forEach((e) => {
      e == null || e.dispose();
    }), this._scrollTimers = [];
  }
  _setSystemHighlightColorToStyle() {
    const { r: e, g: t, b: o, a: r } = dl(), s = {
      strokeWidth: 1,
      stroke: "rgba(0, 0, 0, 0)",
      strokeActive: "rgba(0, 0, 0, 1)",
      fill: `rgba(${e}, ${t}, ${o}, ${r != null ? r : 0.3})`
    };
    this._setRangeStyle(s);
  }
  _getAllTextRanges() {
    return this._rangeList.map(Ir);
  }
  _getAllRectRanges() {
    return this._rectRangeList.map(AA);
  }
  getAllTextRanges() {
    return this._getAllTextRanges();
  }
  getAllRectRanges() {
    return this._getAllRectRanges();
  }
  _getActiveRange() {
    const e = this._rangeList.find((r) => r.isActive());
    if (e == null)
      return null;
    const { startOffset: t, endOffset: o } = e;
    return t == null || o == null ? null : Ir(e);
  }
  _getActiveRangeInstance() {
    return this._rangeList.find((e) => e.isActive());
  }
  dispose() {
    super.dispose(), this._detachEvent(), this._removeAllRanges(), this._container.remove();
  }
  _initDOM() {
    const { unitId: e } = this._context, t = document.createElement("div");
    t.style.position = "fixed", t.style.left = "0px", t.style.top = "0px", t.id = `univer-doc-selection-container-${e}`;
    const o = document.createElement("div"), r = document.createElement("div");
    o.appendChild(r), t.appendChild(o), this._container = t, this._inputParent = o, this._input = r, this._initInput(), this._initInputEvents(), document.body.appendChild(t);
  }
  _registerContainer() {
    this.disposeWithMe(
      // the content editable div should be regarded as part of the applications container
      this._layoutService.registerContainerElement(this._container)
    );
  }
  _initInput() {
    this._inputParent.style.cssText = `
            position:absolute;
            height:1px;
            width:1px;
            overflow: hidden;
        `, this._input.contentEditable = "true", this._input.dataset.uComp = "editor", this._input.id = `__editor_${this._context.unitId}`, this._input.style.cssText = `
            position: absolute;
            overflow: hidden;
            opacity: 1;
            background: #000;
            color: transparent;
            outline: none;
            z-index: -2;
            caret-color: transparent;
            white-space: pre-wrap;
            user-select: text;
        `;
  }
  _getNodePosition(e) {
    if (e == null)
      return;
    const { node: t, ratioX: o, segmentPage: r } = e, i = this._docSkeletonManagerService.getSkeleton().findPositionByGlyph(t, r);
    if (i == null)
      return;
    let c = o < 0.5;
    return t.glyphType === $i.LIST && (c = !0), {
      ...i,
      isBack: c
    };
  }
  _interactTextRanges(e) {
    const t = [];
    for (const o of this._rangeList) {
      if (e.some((r) => r.isIntersection(o))) {
        o.dispose();
        continue;
      }
      t.push(o);
    }
    this._rangeList = t;
  }
  _interactRectRanges(e) {
    const t = [];
    for (const o of this._rectRangeList) {
      if (e.some((r) => r.isIntersection(o))) {
        o.dispose();
        continue;
      }
      t.push(o);
    }
    this._rectRangeList = t;
  }
  _removeAllRanges() {
    this._removeAllTextRanges(), this._removeAllRectRanges();
  }
  _removeAllCacheRanges() {
    this._rangeListCache.forEach((e) => {
      e.dispose();
    }), this._rectRangeListCache.forEach((e) => {
      e.dispose();
    }), this._rangeListCache = [], this._rectRangeListCache = [];
  }
  _removeAllTextRanges() {
    this._rangeList.forEach((e) => {
      e.dispose();
    }), this._rangeList = [];
  }
  _removeAllRectRanges() {
    this._rectRangeList.forEach((e) => {
      e.dispose();
    }), this._rectRangeList = [];
  }
  _removeAllCollapsedTextRanges() {
    for (const e of this._rangeList)
      e.collapsed && e.dispose();
  }
  _deactivateAllTextRanges() {
    this._rangeList.forEach((e) => {
      e.deactivate();
    });
  }
  _deactivateAllRectRanges() {
    this._rectRangeList.forEach((e) => {
      e.deactivate();
    });
  }
  _addTextRangesToCache(e) {
    this._rangeListCache.push(...e);
  }
  _addTextRange(e) {
    this._deactivateAllTextRanges(), e.activate(), this._rangeList.push(e);
  }
  _addRectRangesToCache(e) {
    this._rectRangeListCache.push(...e);
  }
  _addRectRanges(e) {
    e.length !== 0 && (this._deactivateAllRectRanges(), e[e.length - 1].activate(), this._rectRangeList.push(...e));
  }
  _createTextRangeByAnchorPosition(e) {
    this._removeAllRanges();
    const { scene: t, mainComponent: o } = this._context, r = this._docSkeletonManagerService.getSkeleton(), s = new Zt(t, o, r, e, void 0, this._selectionStyle, this._currentSegmentId, this._currentSegmentPage);
    this._addTextRange(s);
  }
  _updateActiveRangePosition(e) {
    const t = this._getActiveRangeInstance();
    if (t == null || t.anchorNodePosition == null) {
      this._logService.error(
        "[DocSelectionRenderService] _updateActiveRangeFocusPosition: active range has no anchor"
      );
      return;
    }
    this._removeAllRanges(), this._anchorNodePosition = t.anchorNodePosition, this._focusNodePosition = e;
    const { scene: o, mainComponent: r } = this._context, s = this._docSkeletonManagerService.getSkeleton(), { _anchorNodePosition: i, _focusNodePosition: a, _selectionStyle: c, _currentSegmentId: d, _currentSegmentPage: l } = this;
    if (i == null || a == null || r == null)
      return;
    const A = Er(
      i,
      a,
      o,
      r,
      s,
      c,
      d,
      l
    );
    if (A == null)
      return;
    const { textRanges: h, rectRanges: u } = A;
    this._addTextRangesToCache(h), this._addRectRangesToCache(u), this.deactivate();
  }
  _isEmpty() {
    return this._rangeList.length === 0 && this._rectRangeList.length === 0;
  }
  _getCanvasOffset() {
    var t;
    const e = (t = this._context.scene) == null ? void 0 : t.getEngine();
    return dA(e);
  }
  _updateInputPosition(e = !1) {
    const t = this._getActiveRangeInstance(), o = t == null ? void 0 : t.getAnchor();
    if (!o || o && !o.visible || this.activeViewPort == null) {
      this.focus();
      return;
    }
    const { left: r, top: s } = o, i = this.activeViewPort.getAbsoluteVector(vn.FromArray([r, s])), { x: a, y: c } = i;
    let { left: d, top: l } = this._getCanvasOffset();
    d += a, l += c, this.activate(d, l, e);
  }
  _moving(e, t) {
    var m, I;
    const { _currentSegmentId: o, _currentSegmentPage: r } = this, s = this._findNodeByCoord(e, t, {
      strict: !0,
      segmentId: o,
      segmentPage: r
    }), i = this._getNodePosition(s);
    if (i == null || s == null)
      return;
    const a = s == null ? void 0 : s.node.parent, c = a == null ? void 0 : a.glyphGroup[a.glyphGroup.indexOf(s.node) + 1];
    (s == null ? void 0 : s.node.streamType) === V.PARAGRAPH && (c == null ? void 0 : c.streamType) === V.SECTION_BREAK && (i.isBack = !0), this._focusNodePosition = i, this._removeAllCacheRanges();
    const { _anchorNodePosition: d, _selectionStyle: l } = this, { scene: A, mainComponent: h } = this._context, u = this._docSkeletonManagerService.getSkeleton();
    if (d == null || h == null)
      return;
    const g = Er(
      d,
      i,
      A,
      h,
      u,
      l,
      o,
      r
    );
    if (g == null)
      return;
    const { textRanges: f, rectRanges: p } = g;
    this._rangeList.length > 0 && f.length > 0 && this._interactTextRanges(f), this._rectRangeList.length > 0 && p.length > 0 && this._interactRectRanges(p), this._addTextRangesToCache(f), this._addRectRangesToCache(p), this.deactivate(), (I = (m = this._context.scene) == null ? void 0 : m.getEngine()) == null || I.setCapture();
  }
  __attachScrollEvent() {
    const e = this.activeViewPort;
    if (!e)
      return;
    const { unitId: t } = this._context;
    if (this._viewPortObserverMap.has(t))
      return;
    const o = e.onScrollAfter$.subscribeEvent((s) => {
      if (!s.viewport)
        return;
      const a = this._getActiveRangeInstance();
      a == null || a.activeStatic();
    }), r = e.onScrollEnd$.subscribeEvent((s) => {
      const i = s.viewport;
      if (!i)
        return;
      const a = i.getBounding(), c = this._getActiveRangeInstance(), d = c == null ? void 0 : c.getAnchor();
      if (!(!d || d && !d.visible)) {
        if (a) {
          const { left: l, top: A, right: h, bottom: u } = a.viewBound;
          if (d.left < l || d.left > h || d.top < A || d.top > u) {
            c == null || c.deactivateStatic();
            return;
          }
        }
        this._updateInputPosition();
      }
    });
    this._viewPortObserverMap.set(t, {
      scrollBefore: o,
      scrollStop: r
    });
  }
  // FIXME: listeners here are not correctly disposed
  // eslint-disable-next-line max-lines-per-function
  _initInputEvents() {
    this.disposeWithMe(
      je(this._input, "keydown").subscribe((e) => {
        this._isIMEInputApply || this._eventHandle(e, (t) => {
          this._onKeydown$.next(t);
        });
      })
    ), this.disposeWithMe(
      je(this._input, "input").subscribe((e) => {
        if (!(e.inputType === "historyUndo" || e.inputType === "historyRedo")) {
          if (this._rectRangeList.length > 0)
            return e.stopPropagation(), e.preventDefault();
          this._isIMEInputApply || this._eventHandle(e, (t) => {
            this._onInputBefore$.next(t), this._onInput$.next(t);
          });
        }
      })
    ), this.disposeWithMe(
      je(this._input, "compositionstart").subscribe((e) => {
        if (this._rectRangeList.length > 0)
          return e.stopPropagation(), e.preventDefault();
        this._isIMEInputApply = !0, this._eventHandle(e, (t) => {
          this._onCompositionstart$.next(t);
        });
      })
    ), this.disposeWithMe(
      je(this._input, "compositionend").subscribe((e) => {
        this._isIMEInputApply = !1, this._eventHandle(e, (t) => {
          this._onCompositionend$.next(t);
        });
      })
    ), this.disposeWithMe(
      je(this._input, "compositionupdate").subscribe((e) => {
        this._eventHandle(e, (t) => {
          this._onInputBefore$.next(t), this._onCompositionupdate$.next(t);
        });
      })
    ), this.disposeWithMe(
      je(this._input, "paste").subscribe((e) => {
        this._eventHandle(e, (t) => {
          this._onPaste$.next(t);
        });
      })
    ), this.disposeWithMe(
      je(this._input, "focus").subscribe((e) => {
        this._eventHandle(e, (t) => {
          this._onFocus$.next(t);
        });
      })
    ), this.disposeWithMe(
      je(this._input, "blur").subscribe((e) => {
        this._eventHandle(e, (t) => {
          this._onBlur$.next(t);
        });
      })
    );
  }
  _eventHandle(e, t) {
    const o = this._input.textContent || "";
    this._input.innerHTML = "";
    const r = this._getActiveRange(), s = this._getAllTextRanges();
    t({
      event: e,
      content: o,
      activeRange: r,
      rangeList: s
    });
  }
  _getTransformCoordForDocumentOffset(e, t) {
    const o = this._context.mainComponent, { documentTransform: r } = o.getOffsetConfig();
    if (this.activeViewPort == null || r == null)
      return;
    const s = this.activeViewPort.transformVector2SceneCoord(vn.FromArray([e, t]));
    if (s)
      return r.clone().invert().applyPoint(s);
  }
  _findNodeByCoord(e, t, o) {
    const r = this._getTransformCoordForDocumentOffset(e, t);
    if (r == null)
      return;
    const s = this._context.mainComponent, i = this._docSkeletonManagerService.getSkeleton(), {
      pageLayoutType: a = Cn.VERTICAL,
      pageMarginLeft: c,
      pageMarginTop: d
    } = s.getOffsetConfig();
    return i.findNodeByCoord(
      r,
      a,
      c,
      d,
      o
    );
  }
  _detachEvent() {
    this._onInputBefore$.complete(), this._onKeydown$.complete(), this._onInput$.complete(), this._onCompositionstart$.complete(), this._onCompositionupdate$.complete(), this._onCompositionend$.complete(), this._onSelectionStart$.complete(), this._textSelectionInner$.complete(), this._onPaste$.complete(), this._onFocus$.complete(), this._onBlur$.complete(), this._onPointerDown$.complete();
  }
};
Re = hA([
  Vn(1, Oo),
  Vn(2, Qr),
  Vn(3, L),
  Vn(4, j(de))
], Re);
const ko = {
  id: "doc.command.switch-mode",
  type: D.COMMAND,
  // eslint-disable-next-line max-lines-per-function, complexity
  handler: (n) => {
    var I, S, v, R, E;
    const e = n.get(T), t = n.get(pe), o = n.get(Y), s = n.get(L).getCurrentUniverDocInstance();
    if (s == null)
      return !1;
    const i = s.getUnitId(), a = (I = t.getRenderById(i)) == null ? void 0 : I.with(de).getSkeleton(), c = (S = t.getRenderById(i)) == null ? void 0 : S.with(Re);
    if (a == null || c == null)
      return !1;
    const d = c == null ? void 0 : c.getSegment(), l = c == null ? void 0 : c.getSegmentPage(), A = s.getSnapshot().documentStyle.documentFlavor, h = o.getDocRanges(), u = {
      id: X.id,
      params: {
        unitId: i,
        actions: [],
        textRanges: A === Pe.TRADITIONAL && d ? [] : h
      }
    }, g = W.getInstance(), f = [];
    let p;
    if (A === void 0 ? p = g.insertOp(["documentStyle", "documentFlavor"], Pe.MODERN) : A === Pe.MODERN ? p = g.replaceOp(["documentStyle", "documentFlavor"], A, Pe.TRADITIONAL) : p = g.replaceOp(["documentStyle", "documentFlavor"], A, Pe.MODERN), p)
      f.push(p);
    else
      return !1;
    if (A !== Pe.MODERN) {
      const b = s.getSnapshot(), { drawings: y = {}, body: C } = b, B = (v = C == null ? void 0 : C.customBlocks) != null ? v : [];
      for (const x in y) {
        const M = y[x], w = B.find((he) => he.blockId === x);
        if (w == null)
          continue;
        const F = M.docTransform.positionV, { relativeFrom: P, posOffset: N } = F;
        if (P === gt.PARAGRAPH)
          continue;
        const { startIndex: ee } = w, $ = a.findNodeByCharIndex(ee, d, l), U = (R = $ == null ? void 0 : $.parent) == null ? void 0 : R.parent, H = U == null ? void 0 : U.parent, k = H == null ? void 0 : H.lines.find((he) => he.paragraphIndex === (U == null ? void 0 : U.paragraphIndex) && he.paragraphStart), ne = (E = H == null ? void 0 : H.parent) == null ? void 0 : E.parent;
        if ($ == null || U == null || k == null || H == null || ne == null)
          continue;
        let ie = 0;
        P === gt.LINE ? ie -= U.top : P === gt.PAGE && (ie += ne.marginTop), ie += k.top;
        const ae = {
          ...F,
          relativeFrom: gt.PARAGRAPH,
          posOffset: (N != null ? N : 0) - ie
        }, oe = g.replaceOp(["drawings", x, "docTransform", "positionV"], F, ae);
        oe && f.push(oe);
      }
    }
    return u.params.actions = f.reduce((b, y) => W.compose(b, y), null), !!e.syncExecuteCommand(u.id, u.params);
  }
}, gA = "doc.command.create-table", Wa = {
  id: gA,
  type: D.COMMAND,
  // eslint-disable-next-line max-lines-per-function
  handler: async (n, e) => {
    var ae, oe, he, we, Ze;
    const { rowCount: t, colCount: o } = e, r = n.get(Y), s = n.get(L), i = n.get(T), a = n.get(at), c = r.getActiveTextRange();
    if (c == null)
      return !1;
    const { segmentId: d, segmentPage: l } = c, A = s.getCurrentUniverDocInstance(), h = A == null ? void 0 : A.getSelfOrHeaderFooterModel(d).getBody();
    if (A == null || h == null)
      return !1;
    const u = A.getUnitId(), g = Ke(n, u), f = g == null ? void 0 : g.getSkeleton();
    if (f == null)
      return !1;
    const { startOffset: p } = c, I = ((ae = h.paragraphs) != null ? ae : []).find((At) => At.startIndex >= p), S = f.findNodeByCharIndex(p, d, l);
    if (S == null)
      return !1;
    const v = new Ie(), R = W.getInstance(), E = [], b = p + 4, y = [{
      startOffset: b,
      endOffset: b,
      collapsed: !0
    }], C = {
      id: X.id,
      params: {
        unitId: u,
        actions: [],
        textRanges: y
      }
    };
    p > 0 && v.push({
      t: G.RETAIN,
      len: p
    }), v.push({
      t: G.INSERT,
      body: {
        dataStream: V.PARAGRAPH,
        paragraphs: pa(V.PARAGRAPH, I)
      },
      len: 1
    });
    const B = a.getDefaultStyle(), x = a.getStyleCache(), M = Bo(
      h,
      p,
      B,
      x
    ), { dataStream: w, paragraphs: F, sectionBreaks: P } = fd(t, o), N = (Ze = (we = (he = (oe = S.parent) == null ? void 0 : oe.parent) == null ? void 0 : he.parent) == null ? void 0 : we.parent) == null ? void 0 : Ze.parent;
    if (N == null)
      return !1;
    const { pageWidth: ee, marginLeft: $, marginRight: U } = N, H = ma(t, o, ee - $ - U);
    v.push({
      t: G.INSERT,
      body: {
        dataStream: w,
        paragraphs: F,
        sectionBreaks: P,
        textRuns: [{
          ...M,
          st: 0,
          ed: w.length
        }],
        tables: [
          {
            startIndex: 0,
            endIndex: w.length,
            tableId: H.tableId
          }
        ]
      },
      len: w.length
    });
    const k = Ae(A, d);
    E.push(R.editOp(v.serialize(), k));
    const ne = R.insertOp(["tableSource", H.tableId], H);
    return E.push(ne), C.params.actions = E.reduce((At, Je) => W.compose(At, Je), null), !!i.syncExecuteCommand(C.id, C.params);
  }
}, Is = {
  id: "doc.table.delete-rows",
  type: D.COMMAND,
  // eslint-disable-next-line max-lines-per-function
  handler: async (n) => {
    const e = n.get(Y), t = n.get(L), o = n.get(T), r = e.getRectRanges(), s = e.getActiveTextRange(), i = Ln(s, r);
    if (i == null)
      return !1;
    const { segmentId: a } = i, c = t.getCurrentUniverDocInstance(), d = c == null ? void 0 : c.getSelfOrHeaderFooterModel(a).getBody();
    if (c == null || d == null)
      return !1;
    const l = Ke(n, c.getUnitId());
    if (l == null)
      return !1;
    const A = l.getViewModel(), h = c == null ? void 0 : c.getUnitId(), u = new Ie(), g = W.getInstance(), f = Ea(i, A);
    if (f == null)
      return !1;
    const { offset: p, rowIndexes: m, len: I, tableId: S, cursor: v, selectWholeTable: R } = f;
    if (R)
      return o.executeCommand(Hn.id);
    const E = [], b = [{
      startOffset: v,
      endOffset: v,
      collapsed: !0
    }], y = {
      id: X.id,
      params: {
        unitId: h,
        actions: [],
        textRanges: b
      }
    };
    p > 0 && u.push({
      t: G.RETAIN,
      len: p
    }), u.push({
      t: G.DELETE,
      len: I
    });
    const C = Ae(c, a);
    E.push(g.editOp(u.serialize(), C));
    for (const x of m.reverse()) {
      const M = g.removeOp(["tableSource", S, "tableRows", x]);
      E.push(M);
    }
    return y.params.actions = E.reduce((x, M) => W.compose(x, M), null), !!o.syncExecuteCommand(y.id, y.params);
  }
}, Ss = {
  id: "doc.table.delete-columns",
  type: D.COMMAND,
  // eslint-disable-next-line max-lines-per-function
  handler: async (n) => {
    const e = n.get(Y), t = n.get(L), o = n.get(T), r = e.getRectRanges(), s = e.getActiveTextRange(), i = Ln(s, r);
    if (i == null)
      return !1;
    const { segmentId: a } = i, c = t.getCurrentUniverDocInstance(), d = c == null ? void 0 : c.getSelfOrHeaderFooterModel(a).getBody();
    if (c == null || d == null)
      return !1;
    const l = Ke(n, c.getUnitId());
    if (l == null)
      return !1;
    const A = l.getViewModel(), h = c == null ? void 0 : c.getUnitId(), u = new Ie(), g = W.getInstance(), f = vd(i, A);
    if (f == null)
      return !1;
    const { offsets: p, columnIndexes: m, tableId: I, cursor: S, rowCount: v, selectWholeTable: R } = f;
    if (R)
      return o.executeCommand(Hn.id);
    const E = [], b = [{
      startOffset: S,
      endOffset: S,
      collapsed: !0
    }], y = {
      id: X.id,
      params: {
        unitId: h,
        actions: [],
        textRanges: b
      }
    };
    for (const x of p) {
      const { retain: M, delete: w } = x;
      M > 0 && u.push({
        t: G.RETAIN,
        len: M
      }), u.push({
        t: G.DELETE,
        len: w
      });
    }
    const C = Ae(c, a);
    E.push(g.editOp(u.serialize(), C)), m.reverse();
    for (let x = 0; x < v; x++)
      for (const M of m) {
        const w = g.removeOp(["tableSource", I, "tableRows", x, "tableCells", M]);
        E.push(w);
      }
    for (const x of m) {
      const M = g.removeOp(["tableSource", I, "tableColumns", x]);
      E.push(M);
    }
    return y.params.actions = E.reduce((x, M) => W.compose(x, M), null), !!o.syncExecuteCommand(y.id, y.params);
  }
}, Hn = {
  id: "doc.table.delete-table",
  type: D.COMMAND,
  // eslint-disable-next-line max-lines-per-function
  handler: async (n) => {
    const e = n.get(Y), t = n.get(L), o = n.get(T), r = e.getRectRanges(), s = e.getActiveTextRange(), i = Ln(s, r);
    if (i == null)
      return !1;
    const { segmentId: a } = i, c = t.getCurrentUniverDocInstance(), d = c == null ? void 0 : c.getSelfOrHeaderFooterModel(a).getBody();
    if (c == null || d == null)
      return !1;
    const l = Ke(n, c.getUnitId());
    if (l == null)
      return !1;
    const A = l.getViewModel(), h = c == null ? void 0 : c.getUnitId(), u = new Ie(), g = W.getInstance(), f = Ia(i, A);
    if (f == null)
      return !1;
    const { offset: p, len: m, tableId: I, cursor: S } = f, v = [], R = [{
      startOffset: S,
      endOffset: S,
      collapsed: !0
    }], E = {
      id: X.id,
      params: {
        unitId: h,
        actions: [],
        textRanges: R
      }
    };
    p > 0 && u.push({
      t: G.RETAIN,
      len: p
    }), u.push({
      t: G.DELETE,
      len: m
    });
    const b = Ae(c, a);
    v.push(g.editOp(u.serialize(), b));
    const y = g.removeOp(["tableSource", I]);
    return v.push(y), E.params.actions = v.reduce((B, x) => W.compose(B, x), null), !!o.syncExecuteCommand(E.id, E.params);
  }
}, vs = "doc.command.table-insert-row", Cs = "doc.command.table-insert-column", fA = "doc.command.table-insert-row-above", pA = "doc.command.table-insert-row-bellow", mA = "doc.command.table-insert-column-left", EA = "doc.command.table-insert-column-right", Rs = {
  id: fA,
  type: D.COMMAND,
  handler: async (n) => n.get(T).executeCommand(vs, { position: _o.ABOVE })
}, bs = {
  id: pA,
  type: D.COMMAND,
  handler: async (n) => n.get(T).executeCommand(vs, { position: _o.BELLOW })
}, ys = {
  id: mA,
  type: D.COMMAND,
  handler: async (n) => n.get(T).executeCommand(Cs, { position: Yr.LEFT })
}, xs = {
  id: EA,
  type: D.COMMAND,
  handler: async (n) => n.get(T).executeCommand(Cs, { position: Yr.RIGHT })
}, ja = {
  id: vs,
  type: D.COMMAND,
  // eslint-disable-next-line max-lines-per-function
  handler: async (n, e) => {
    const { position: t } = e, o = n.get(Y), r = n.get(L), s = n.get(T), i = o.getRectRanges(), a = o.getActiveTextRange(), c = Ln(a, i);
    if (c == null)
      return !1;
    const { segmentId: d } = c, l = r.getCurrentUnitForType(_.UNIVER_DOC), A = l == null ? void 0 : l.getSelfOrHeaderFooterModel(d).getBody();
    if (l == null || A == null)
      return !1;
    const h = Ke(n, l.getUnitId());
    if (h == null)
      return !1;
    const u = h.getViewModel(), g = l == null ? void 0 : l.getUnitId(), f = new Ie(), p = W.getInstance(), m = Ed(c, t, u);
    if (m == null)
      return !1;
    const { offset: I, colCount: S, tableId: v, insertRowIndex: R } = m, E = [], b = I + 2, y = [{
      startOffset: b,
      endOffset: b,
      collapsed: !0
    }], C = {
      id: X.id,
      params: {
        unitId: g,
        actions: [],
        textRanges: y
      }
    };
    I > 0 && f.push({
      t: G.RETAIN,
      len: I
    });
    const B = pd(S);
    f.push({
      t: G.INSERT,
      body: B,
      len: B.dataStream.length
    });
    const x = Ae(l, d);
    E.push(p.editOp(f.serialize(), x));
    const M = qr(S), w = p.insertOp(["tableSource", v, "tableRows", R], M);
    return E.push(w), C.params.actions = E.reduce((P, N) => W.compose(P, N), null), !!s.syncExecuteCommand(C.id, C.params);
  }
}, IA = {
  id: Cs,
  type: D.COMMAND,
  // eslint-disable-next-line max-lines-per-function
  handler: async (n, e) => {
    var ne, ie, ae;
    const { position: t } = e, o = n.get(Y), r = n.get(L), s = n.get(T), i = o.getRectRanges(), a = o.getActiveTextRange(), c = Ln(a, i);
    if (c == null)
      return !1;
    const { segmentId: d } = c, l = r.getCurrentUniverDocInstance(), A = l == null ? void 0 : l.getSelfOrHeaderFooterModel(d).getBody();
    if (l == null || A == null)
      return !1;
    const h = Ke(n, l.getUnitId());
    if (h == null)
      return !1;
    const u = h.getViewModel(), g = l == null ? void 0 : l.getUnitId(), f = new Ie(), p = W.getInstance(), m = Id(c, t, u);
    if (m == null)
      return !1;
    const { offsets: I, columnIndex: S, tableId: v, rowCount: R } = m, E = [], b = I[0] + 1, y = [{
      startOffset: b,
      endOffset: b,
      collapsed: !0
    }], C = {
      id: X.id,
      params: {
        unitId: g,
        actions: [],
        textRanges: y
      }
    };
    for (const oe of I) {
      f.push({
        t: G.RETAIN,
        len: oe
      });
      const he = md();
      f.push({
        t: G.INSERT,
        body: he,
        len: he.dataStream.length
      });
    }
    const B = Ae(l, d);
    E.push(p.editOp(f.serialize(), B));
    for (let oe = 0; oe < R; oe++) {
      const he = Kr(), we = p.insertOp(["tableSource", v, "tableRows", oe, "tableCells", S], he);
      E.push(we);
    }
    const x = l.getSnapshot(), M = x.documentStyle, { marginLeft: w = 0, marginRight: F = 0 } = M, P = ((ie = (ne = M.pageSize) == null ? void 0 : ne.width) != null ? ie : 800) - w - F, N = (ae = x == null ? void 0 : x.tableSource) == null ? void 0 : ae[v].tableColumns, { newColWidth: ee, widths: $ } = Sd(P, N, S);
    for (let oe = 0; oe < $.length; oe++) {
      const he = p.replaceOp(["tableSource", v, "tableColumns", oe, "size", "width", "v"], N[oe].size.width.v, $[oe]);
      E.push(he);
    }
    const U = Xr(ee), H = p.insertOp(["tableSource", v, "tableColumns", S], U);
    return E.push(H), C.params.actions = E.reduce((oe, he) => W.compose(oe, he), null), !!s.syncExecuteCommand(C.id, C.params);
  }
}, za = {
  id: "doc.table.tab-in-table",
  type: D.COMMAND,
  handler: async (n, e) => {
    var g;
    const { shift: t } = e, o = n.get(Y), r = o.getDocRanges(), s = n.get(T), a = n.get(L).getCurrentUniverDocInstance();
    if (!a)
      return !1;
    const c = (g = r.find((f) => f.isActive)) != null ? g : r[0], d = a.getUnitId(), l = Ke(n, d), A = l == null ? void 0 : l.getSkeleton(), h = A == null ? void 0 : A.getViewModel().getSelfOrHeaderFooterViewModel(c == null ? void 0 : c.segmentId);
    if (h == null || c == null)
      return !1;
    let u = null;
    if (t ? u = $s(h, c, Ar.PREV) : u = $s(h, c, Ar.NEXT), u) {
      const { startOffset: f, endOffset: p } = u, m = [{
        startOffset: f,
        endOffset: p
      }];
      return o.replaceDocRanges(m), !0;
    }
    return t === !1 ? await s.executeCommand(ja.id, {
      position: _o.BELLOW
    }) : !0;
  }
}, Ga = "COMPONENT_DOC_CREATE_TABLE_CONFIRM", $o = "doc.component.create-table-confirm", Os = {
  id: "doc.operation.create-table",
  type: D.COMMAND,
  handler: async (n) => {
    const e = n.get(Ye), t = n.get(aa), o = n.get(T), r = {
      rowCount: 3,
      colCount: 5
    }, s = (i, a) => {
      r.rowCount = i, r.colCount = a;
    };
    return await t.open({
      id: $o,
      children: {
        label: {
          name: Ga,
          props: {
            handleRowColChange: s,
            tableCreateParams: r
          }
        }
      },
      width: "auto",
      title: { title: e.t("toolbar.table.insert") },
      onConfirm: () => {
        o.executeCommand(Wa.id, r), t.close($o);
      },
      onClose: () => {
        t.close($o);
      }
    }), !0;
  }
}, St = {
  id: "doc.operation.move-cursor",
  type: D.OPERATION,
  handler: (n, e) => !!e
}, vt = {
  id: "doc.operation.move-selection",
  type: D.OPERATION,
  handler: (n, e) => !!e
};
function Me({ ref: n, ...e }) {
  const { icon: t, id: o, className: r, extend: s, ...i } = e, a = `univerjs-icon univerjs-icon-${o} ${r || ""}`.trim(), c = ke(`_${CA()}`);
  return Ya(t, `${o}`, {
    defIds: t.defIds,
    idSuffix: c.current
  }, {
    ref: n,
    className: a,
    ...i
  }, s);
}
function Ya(n, e, t, o, r) {
  return Te(n.tag, {
    key: e,
    ...SA(n, t, r),
    ...o
  }, (vA(n, t).children || []).map((s, i) => Ya(s, `${e}-${n.tag}-${i}`, t, void 0, r)));
}
function SA(n, e, t) {
  const o = { ...n.attrs };
  t != null && t.colorChannel1 && o.fill === "colorChannel1" && (o.fill = t.colorChannel1), n.tag === "mask" && o.id && (o.id = o.id + e.idSuffix), Object.entries(o).forEach(([s, i]) => {
    s === "mask" && typeof i == "string" && (o[s] = i.replace(/url\(#(.*)\)/, `url(#$1${e.idSuffix})`));
  });
  const { defIds: r } = e;
  return !r || r.length === 0 || (n.tag === "use" && o["xlink:href"] && (o["xlink:href"] = o["xlink:href"] + e.idSuffix), Object.entries(o).forEach(([s, i]) => {
    typeof i == "string" && (o[s] = i.replace(/url\(#(.*)\)/, `url(#$1${e.idSuffix})`));
  })), o;
}
function vA(n, e) {
  var o;
  const { defIds: t } = e;
  return !t || t.length === 0 ? n : n.tag === "defs" && ((o = n.children) != null && o.length) ? {
    ...n,
    children: n.children.map((r) => typeof r.attrs.id == "string" && t && t.includes(r.attrs.id) ? {
      ...r,
      attrs: {
        ...r.attrs,
        id: r.attrs.id + e.idSuffix
      }
    } : r)
  } : n;
}
function CA() {
  return Math.random().toString(36).substring(2, 8);
}
Me.displayName = "UniverIcon";
const RA = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
  },
  children: [
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M1.9999 1.89941C1.66853 1.89941 1.3999 2.16804 1.3999 2.49941C1.3999 2.83078 1.66853 3.09941 1.9999 3.09941H13.9999C14.3313 3.09941 14.5999 2.83078 14.5999 2.49941C14.5999 2.16804 14.3313 1.89941 13.9999 1.89941H1.9999Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M1.9999 5.56641C1.66853 5.56641 1.3999 5.83504 1.3999 6.16641C1.3999 6.49778 1.66853 6.76641 1.9999 6.76641H13.9999C14.3313 6.76641 14.5999 6.49778 14.5999 6.16641C14.5999 5.83504 14.3313 5.56641 13.9999 5.56641H1.9999Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M1.3999 9.8334C1.3999 9.50203 1.66853 9.2334 1.9999 9.2334H13.9999C14.3313 9.2334 14.5999 9.50203 14.5999 9.8334C14.5999 10.1648 14.3313 10.4334 13.9999 10.4334H1.9999C1.66853 10.4334 1.3999 10.1648 1.3999 9.8334Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M1.9999 12.9004C1.66853 12.9004 1.3999 13.169 1.3999 13.5004C1.3999 13.8318 1.66853 14.1004 1.9999 14.1004H13.9999C14.3313 14.1004 14.5999 13.8318 14.5999 13.5004C14.5999 13.169 14.3313 12.9004 13.9999 12.9004H1.9999Z"
      }
    }
  ]
}, Ka = Be(function(e, t) {
  return Te(Me, Object.assign({}, e, {
    id: "align-text-both-icon",
    ref: t,
    icon: RA
  }));
});
Ka.displayName = "AlignTextBothIcon";
const bA = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
  },
  children: [
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M1.9834 3.98332C1.9834 3.61513 2.28188 3.31665 2.65007 3.31665H13.3167C13.6849 3.31665 13.9834 3.61513 13.9834 3.98332C13.9834 4.35151 13.6849 4.64998 13.3167 4.64998H2.65007C2.28188 4.64998 1.9834 4.35151 1.9834 3.98332Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M1.9834 7.98267C1.9834 7.61448 2.28188 7.316 2.65007 7.316H10.6501C11.0183 7.316 11.3167 7.61448 11.3167 7.98267C11.3167 8.35086 11.0183 8.64933 10.6501 8.64933H2.65007C2.28188 8.64933 1.9834 8.35086 1.9834 7.98267Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M2.65007 11.316C2.28188 11.316 1.9834 11.6145 1.9834 11.9827C1.9834 12.3509 2.28188 12.6493 2.65007 12.6493H7.9834C8.35159 12.6493 8.65006 12.3509 8.65006 11.9827C8.65006 11.6145 8.35159 11.316 7.9834 11.316H2.65007Z"
      }
    }
  ]
}, qa = Be(function(e, t) {
  return Te(Me, Object.assign({}, e, {
    id: "catalogue-icon",
    ref: t,
    icon: bA
  }));
});
qa.displayName = "CatalogueIcon";
const yA = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
  },
  children: [{
    tag: "path",
    attrs: {
      fill: "currentColor",
      d: "M2.50095 1.84399C2.73322 1.60765 3.11311 1.60435 3.34945 1.83662L8.00012 6.40726L12.6508 1.83662C12.8871 1.60435 13.267 1.60765 13.4993 1.84399C13.7316 2.08032 13.7283 2.46021 13.4919 2.69248L8.85611 7.24852L10.8941 9.25146C11.1382 9.17563 11.3976 9.13477 11.6667 9.13477C13.1026 9.13477 14.2667 10.2988 14.2667 11.7348C14.2667 13.1707 13.1026 14.3348 11.6667 14.3348C10.2307 14.3348 9.06665 13.1707 9.06665 11.7348C9.06665 11.0143 9.35973 10.3622 9.83319 9.89129L8.00012 8.08978L6.16708 9.89127C6.64055 10.3622 6.93364 11.0142 6.93364 11.7348C6.93364 13.1707 5.76958 14.3348 4.33364 14.3348C2.8977 14.3348 1.73364 13.1707 1.73364 11.7348C1.73364 10.2988 2.8977 9.13477 4.33364 9.13477C4.60263 9.13477 4.86208 9.17562 5.10612 9.25145L7.14413 7.24852L2.50831 2.69248C2.27197 2.46021 2.26868 2.08032 2.50095 1.84399ZM2.93364 11.7348C2.93364 10.9616 3.56044 10.3348 4.33364 10.3348C5.10684 10.3348 5.73364 10.9616 5.73364 11.7348C5.73364 12.508 5.10684 13.1348 4.33364 13.1348C3.56044 13.1348 2.93364 12.508 2.93364 11.7348ZM10.2667 11.7348C10.2667 10.9616 10.8935 10.3348 11.6667 10.3348C12.4398 10.3348 13.0667 10.9616 13.0667 11.7348C13.0667 12.508 12.4398 13.1348 11.6667 13.1348C10.8935 13.1348 10.2667 12.508 10.2667 11.7348Z",
      fillRule: "evenodd",
      clipRule: "evenodd"
    }
  }]
}, Xa = Be(function(e, t) {
  return Te(Me, Object.assign({}, e, {
    id: "cut-icon",
    ref: t,
    icon: yA
  }));
});
Xa.displayName = "CutIcon";
const xA = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
  },
  children: [
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M5.3313 1.4667C5.3313 1.13533 5.59993 0.866699 5.9313 0.866699H10.069C10.4004 0.866699 10.669 1.13533 10.669 1.4667C10.669 1.79807 10.4004 2.0667 10.069 2.0667H5.9313C5.59993 2.0667 5.3313 1.79807 5.3313 1.4667Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M1.09985 3.64443C1.09985 3.31306 1.36848 3.04443 1.69985 3.04443H14.2999C14.6312 3.04443 14.8999 3.31306 14.8999 3.64443C14.8999 3.9758 14.6312 4.24443 14.2999 4.24443H1.69985C1.36848 4.24443 1.09985 3.9758 1.09985 3.64443Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M6.12398 8.30171C6.35829 8.0674 6.73819 8.0674 6.97251 8.30171L8.00007 9.32928L9.02764 8.30171C9.26195 8.0674 9.64185 8.0674 9.87617 8.30171C10.1105 8.53603 10.1105 8.91593 9.87617 9.15024L8.8486 10.1778L9.87617 11.2054C10.1105 11.4397 10.1105 11.8196 9.87617 12.0539C9.64185 12.2882 9.26195 12.2882 9.02764 12.0539L8.00007 11.0263L6.97251 12.0539C6.73819 12.2882 6.35829 12.2882 6.12398 12.0539C5.88966 11.8196 5.88966 11.4397 6.12398 11.2054L7.15154 10.1778L6.12398 9.15024C5.88966 8.91593 5.88966 8.53603 6.12398 8.30171Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M4.75332 5.22217C3.86966 5.22217 3.15332 5.93851 3.15332 6.82217V12.5331C3.15332 13.9691 4.31738 15.1332 5.75332 15.1332H10.2465C11.6825 15.1332 12.8465 13.9691 12.8465 12.5331V6.82217C12.8465 5.93851 12.1302 5.22217 11.2465 5.22217H4.75332ZM4.35332 6.82217C4.35332 6.60125 4.53241 6.42217 4.75332 6.42217H11.2465C11.4674 6.42217 11.6465 6.60125 11.6465 6.82217V12.5331C11.6465 13.3063 11.0197 13.9332 10.2465 13.9332H5.75332C4.98012 13.9332 4.35332 13.3063 4.35332 12.5331V6.82217Z",
        fillRule: "evenodd",
        clipRule: "evenodd"
      }
    }
  ]
}, Za = Be(function(e, t) {
  return Te(Me, Object.assign({}, e, {
    id: "delete-icon",
    ref: t,
    icon: xA
  }));
});
Za.displayName = "DeleteIcon";
const OA = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
  },
  children: [
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M10.9913 10.8779C11.4971 10.8779 11.9073 11.2882 11.9073 11.7939C11.9073 12.2997 11.4971 12.71 10.9913 12.71C10.4857 12.7099 10.0754 12.2996 10.0753 11.7939C10.0753 11.2882 10.4857 10.878 10.9913 10.8779Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M11.9572 8.51465C12.5471 8.51471 13.0936 8.82742 13.3927 9.33594L14.3419 10.9502C14.6291 11.4386 14.6479 12.037 14.3966 12.5391L14.3419 12.6377L13.3927 14.252C13.0936 14.7605 12.5471 15.0732 11.9572 15.0732H10.0255C9.50941 15.0731 9.02688 14.8339 8.71399 14.4336L8.59094 14.252L7.64075 12.6377C7.33466 12.1169 7.33466 11.471 7.64075 10.9502L8.59094 9.33594L8.71399 9.1543C9.02688 8.75387 9.50935 8.51477 10.0255 8.51465H11.9572ZM10.0255 9.84473C9.93678 9.84483 9.85287 9.87988 9.79114 9.94043L9.73743 10.0098L8.78723 11.624C8.72565 11.7288 8.72564 11.8591 8.78723 11.9639L9.73743 13.5781L9.79114 13.6475C9.85286 13.7079 9.93684 13.7431 10.0255 13.7432H11.9572C12.0757 13.7431 12.186 13.6803 12.2462 13.5781L13.1954 11.9639L13.2306 11.8809C13.2536 11.7953 13.2415 11.7025 13.1954 11.624L12.2462 10.0098C12.186 9.90756 12.0758 9.84479 11.9572 9.84473H10.0255Z",
        fillRule: "evenodd",
        clipRule: "evenodd"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M10.5031 0.926758C11.9748 0.926758 13.1679 2.12013 13.1681 3.5918V6.41602C13.1679 6.78314 12.8702 7.08105 12.5031 7.08105C12.1361 7.08084 11.8382 6.783 11.838 6.41602V3.5918C11.8378 2.85467 11.2402 2.25684 10.5031 2.25684H4.0929C3.35572 2.25684 2.75813 2.85467 2.75793 3.5918V12.085C2.75818 12.8221 3.35574 13.4199 4.0929 13.4199H6.18958L6.32434 13.4326C6.62712 13.4947 6.85444 13.7639 6.85461 14.085C6.8544 14.406 6.62705 14.6742 6.32434 14.7363L6.18958 14.75H4.0929C2.62121 14.75 1.4281 13.5566 1.42786 12.085V3.5918C1.42806 2.12013 2.62118 0.926758 4.0929 0.926758H10.5031Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M8.04993 6.42969C8.35293 6.49172 8.58118 6.75971 8.58118 7.08105C8.581 7.40229 8.35289 7.67047 8.04993 7.73242L7.91614 7.74609H4.73547C4.36833 7.74609 4.07063 7.44816 4.07043 7.08105C4.07043 6.71379 4.3682 6.41602 4.73547 6.41602H7.91614L8.04993 6.42969Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M10.1007 3.92188C10.4034 3.98418 10.631 4.25215 10.631 4.57324C10.6309 4.8943 10.4033 5.16233 10.1007 5.22461L9.96594 5.23828H4.73547C4.36824 5.23828 4.0705 4.94046 4.07043 4.57324C4.07043 4.20597 4.3682 3.9082 4.73547 3.9082H9.96594L10.1007 3.92188Z"
      }
    }
  ]
}, Ja = Be(function(e, t) {
  return Te(Me, Object.assign({}, e, {
    id: "doc-setting-icon",
    ref: t,
    icon: OA
  }));
});
Ja.displayName = "DocSettingIcon";
const TA = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    width: "1em",
    height: "1em"
  },
  children: [{
    tag: "path",
    attrs: {
      fill: "currentColor",
      d: "M10.5547 14.1884C10.2599 14.5214 9.74019 14.5214 9.4454 14.1884L3.71321 7.71335C3.29002 7.23532 3.6294 6.48161 4.26784 6.48161L15.7322 6.48161C16.3707 6.48161 16.7101 7.23532 16.2869 7.71335L10.5547 14.1884Z"
    }
  }]
}, $a = Be(function(e, t) {
  return Te(Me, Object.assign({}, e, {
    id: "down-icon",
    ref: t,
    icon: TA
  }));
});
$a.displayName = "DownIcon";
const BA = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
  },
  children: [{
    tag: "path",
    attrs: {
      fill: "currentColor",
      d: "M3.0999 2.66689C3.0999 2.33552 2.83127 2.06689 2.4999 2.06689C2.16853 2.06689 1.8999 2.33552 1.8999 2.66689V13.3336C1.8999 13.6649 2.16853 13.9336 2.4999 13.9336C2.83127 13.9336 3.0999 13.6649 3.0999 13.3336V8.5999H8.2334V13.3336C8.2334 13.6649 8.50203 13.9336 8.8334 13.9336C9.16477 13.9336 9.4334 13.6649 9.4334 13.3336V2.66689C9.4334 2.33552 9.16477 2.06689 8.8334 2.06689C8.50203 2.06689 8.2334 2.33552 8.2334 2.66689V7.3999H3.0999V2.66689Z"
    }
  }, {
    tag: "path",
    attrs: {
      fill: "currentColor",
      d: "M14.0999 6.33879C14.0999 6.09377 13.9509 5.87336 13.7236 5.78203C13.4962 5.6907 13.2362 5.74679 13.0667 5.92373L11.4753 7.58486C11.2461 7.82415 11.2542 8.20396 11.4935 8.43319C11.7328 8.66243 12.1126 8.65427 12.3419 8.41499L12.8999 7.83245V13.3333C12.8999 13.6646 13.1686 13.9333 13.4999 13.9333C13.8313 13.9333 14.0999 13.6646 14.0999 13.3333V6.33879Z"
    }
  }]
}, ec = Be(function(e, t) {
  return Te(Me, Object.assign({}, e, {
    id: "h1-icon",
    ref: t,
    icon: BA
  }));
});
ec.displayName = "H1Icon";
const MA = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
  },
  children: [{
    tag: "path",
    attrs: {
      fill: "currentColor",
      d: "M2.5999 2.66689C2.5999 2.33552 2.33127 2.06689 1.9999 2.06689C1.66853 2.06689 1.3999 2.33552 1.3999 2.66689V13.3336C1.3999 13.6649 1.66853 13.9336 1.9999 13.9336C2.33127 13.9336 2.5999 13.6649 2.5999 13.3336V8.5999H7.3999V13.3336C7.3999 13.6649 7.66853 13.9336 7.9999 13.9336C8.33127 13.9336 8.5999 13.6649 8.5999 13.3336V2.66689C8.5999 2.33552 8.33127 2.06689 7.9999 2.06689C7.66853 2.06689 7.3999 2.33552 7.3999 2.66689V7.3999H2.5999V2.66689Z"
    }
  }, {
    tag: "path",
    attrs: {
      fill: "currentColor",
      d: "M11.2667 8.33356C11.2667 7.67245 11.8201 7.26689 12.3333 7.26689C12.8465 7.26689 13.4 7.67244 13.4 8.33356C13.4 8.62807 13.2712 8.94814 12.9954 9.32391C12.7183 9.70153 12.3394 10.0744 11.9174 10.4803L11.8355 10.559C11.4524 10.9268 11.0365 11.3263 10.7149 11.7373C10.3718 12.1759 10.0667 12.7122 10.0667 13.3336C10.0667 13.6649 10.3353 13.9336 10.6667 13.9336H14C14.3314 13.9336 14.6 13.6649 14.6 13.3336C14.6 13.0022 14.3314 12.7336 14 12.7336H11.4782C11.5286 12.6531 11.5889 12.5676 11.6601 12.4767C11.9269 12.1355 12.2843 11.792 12.6877 11.4043L12.7492 11.3452C13.1606 10.9496 13.615 10.5079 13.9629 10.0338C14.3122 9.55787 14.6 8.98906 14.6 8.33356C14.6 6.88362 13.3757 6.06689 12.3333 6.06689C11.291 6.06689 10.0667 6.88361 10.0667 8.33356C10.0667 8.66493 10.3353 8.93356 10.6667 8.93356C10.998 8.93356 11.2667 8.66493 11.2667 8.33356Z"
    }
  }]
}, tc = Be(function(e, t) {
  return Te(Me, Object.assign({}, e, {
    id: "h2-icon",
    ref: t,
    icon: MA
  }));
});
tc.displayName = "H2Icon";
const _A = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
  },
  children: [{
    tag: "path",
    attrs: {
      fill: "currentColor",
      d: "M2.5999 2.66689C2.5999 2.33552 2.33127 2.06689 1.9999 2.06689C1.66853 2.06689 1.3999 2.33552 1.3999 2.66689V13.3336C1.3999 13.6649 1.66853 13.9336 1.9999 13.9336C2.33127 13.9336 2.5999 13.6649 2.5999 13.3336V8.5999H7.3999V13.3336C7.3999 13.6649 7.66853 13.9336 7.9999 13.9336C8.33127 13.9336 8.5999 13.6649 8.5999 13.3336V2.66689C8.5999 2.33552 8.33127 2.06689 7.9999 2.06689C7.66853 2.06689 7.3999 2.33552 7.3999 2.66689V7.3999H2.5999V2.66689Z"
    }
  }, {
    tag: "path",
    attrs: {
      fill: "currentColor",
      d: "M10.6667 6.06689C10.3353 6.06689 10.0667 6.33552 10.0667 6.66689C10.0667 6.99827 10.3353 7.26689 10.6667 7.26689H12.7732L11.193 9.29853C11.0524 9.47942 11.027 9.72465 11.1277 9.93051C11.2283 10.1364 11.4375 10.2669 11.6667 10.2669C12.2418 10.2669 12.6786 10.4115 12.9585 10.6354C13.2204 10.845 13.4 11.166 13.4 11.6669C13.4 12.1622 13.2254 12.3937 13.0567 12.5202C12.8588 12.6686 12.5829 12.7336 12.3333 12.7336C11.7271 12.7336 11.3432 12.4858 11.1106 12.23C10.8877 11.9848 10.5082 11.9667 10.2631 12.1896C10.0179 12.4125 9.99979 12.792 10.2227 13.0372C10.6568 13.5147 11.3522 13.9336 12.3333 13.9336C12.7504 13.9336 13.3078 13.8319 13.7767 13.4802C14.2746 13.1068 14.6 12.5049 14.6 11.6669C14.6 10.8345 14.2796 10.1555 13.7081 9.69837C13.4342 9.47923 13.117 9.32231 12.7746 9.21971L14.4736 7.03526C14.6143 6.85437 14.6397 6.60914 14.539 6.40328C14.4383 6.19743 14.2291 6.06689 14 6.06689H10.6667Z"
    }
  }]
}, nc = Be(function(e, t) {
  return Te(Me, Object.assign({}, e, {
    id: "h3-icon",
    ref: t,
    icon: _A
  }));
});
nc.displayName = "H3Icon";
const DA = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
  },
  children: [{
    tag: "path",
    attrs: {
      fill: "currentColor",
      d: "M2.4334 2.66689C2.4334 2.33552 2.16477 2.06689 1.8334 2.06689C1.50203 2.06689 1.2334 2.33552 1.2334 2.66689V13.3336C1.2334 13.6649 1.50203 13.9336 1.8334 13.9336C2.16477 13.9336 2.4334 13.6649 2.4334 13.3336V8.5999H7.2334V13.3336C7.2334 13.6649 7.50203 13.9336 7.8334 13.9336C8.16477 13.9336 8.4334 13.6649 8.4334 13.3336V2.66689C8.4334 2.33552 8.16477 2.06689 7.8334 2.06689C7.50203 2.06689 7.2334 2.33552 7.2334 2.66689V7.3999H2.4334V2.66689Z"
    }
  }, {
    tag: "path",
    attrs: {
      fill: "currentColor",
      d: "M13.7591 6.66645C13.7591 6.40387 13.5884 6.1718 13.3377 6.09364C13.087 6.01549 12.8147 6.10941 12.6654 6.32546L9.67321 10.6577C9.60398 10.7579 9.56689 10.8769 9.56689 10.9987V11.6731C9.56689 12.0045 9.83552 12.2731 10.1669 12.2731H12.5591V13.3331C12.5591 13.6645 12.8278 13.9331 13.1591 13.9331C13.4905 13.9331 13.7591 13.6645 13.7591 13.3331V12.2731H14.1669C14.4983 12.2731 14.7669 12.0045 14.7669 11.6731C14.7669 11.3417 14.4983 11.0731 14.1669 11.0731H13.7591V6.66645ZM12.5591 8.59091V11.0731H10.8447L12.5591 8.59091Z",
      fillRule: "evenodd",
      clipRule: "evenodd"
    }
  }]
}, oc = Be(function(e, t) {
  return Te(Me, Object.assign({}, e, {
    id: "h4-icon",
    ref: t,
    icon: DA
  }));
});
oc.displayName = "H4Icon";
const wA = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
  },
  children: [{
    tag: "path",
    attrs: {
      fill: "currentColor",
      d: "M2.5999 2.66689C2.5999 2.33552 2.33127 2.06689 1.9999 2.06689C1.66853 2.06689 1.3999 2.33552 1.3999 2.66689V13.3336C1.3999 13.6649 1.66853 13.9336 1.9999 13.9336C2.33127 13.9336 2.5999 13.6649 2.5999 13.3336V8.5999H7.3999V13.3336C7.3999 13.6649 7.66853 13.9336 7.9999 13.9336C8.33127 13.9336 8.5999 13.6649 8.5999 13.3336V2.66689C8.5999 2.33552 8.33127 2.06689 7.9999 2.06689C7.66853 2.06689 7.3999 2.33552 7.3999 2.66689V7.3999H2.5999V2.66689Z"
    }
  }, {
    tag: "path",
    attrs: {
      fill: "currentColor",
      d: "M10.6669 6.40332C10.3355 6.40332 10.0669 6.67195 10.0669 7.00332V9.34492C10.0669 9.67629 10.3355 9.94492 10.6669 9.94492C10.7822 9.94492 10.8899 9.91238 10.9814 9.85599C10.9901 9.85195 11.0027 9.84632 11.0192 9.83936C11.0764 9.81533 11.1692 9.78033 11.2927 9.74447C11.5397 9.67268 11.8996 9.60022 12.3336 9.60022C12.4975 9.60022 12.5978 9.63412 12.6624 9.67167C12.7263 9.70877 12.79 9.76953 12.8503 9.87834C12.983 10.1181 13.0669 10.5337 13.0669 11.1669C13.0669 11.8061 12.9802 12.1936 12.8338 12.414C12.7252 12.5775 12.5275 12.7336 12.0002 12.7336C11.6445 12.7336 11.4936 12.622 11.4192 12.5328C11.3289 12.4245 11.2669 12.2453 11.2669 12.0028C11.2669 11.6714 10.9983 11.4028 10.6669 11.4028C10.3355 11.4028 10.0669 11.6714 10.0669 12.0028C10.0669 12.4244 10.1716 12.9106 10.4979 13.3016C10.8401 13.7118 11.356 13.9336 12.0002 13.9336C12.8063 13.9336 13.4419 13.6673 13.8334 13.0779C14.1869 12.5456 14.2669 11.8497 14.2669 11.1669C14.2669 10.4781 14.1841 9.81027 13.9002 9.29724C13.7521 9.02964 13.545 8.79662 13.2651 8.63403C12.986 8.4719 12.6697 8.40022 12.3336 8.40022C11.9239 8.40022 11.5627 8.44957 11.2669 8.51389V7.60332H13.3336C13.6649 7.60332 13.9336 7.33469 13.9336 7.00332C13.9336 6.67195 13.6649 6.40332 13.3336 6.40332H10.6669Z"
    }
  }]
}, rc = Be(function(e, t) {
  return Te(Me, Object.assign({}, e, {
    id: "h5-icon",
    ref: t,
    icon: wA
  }));
});
rc.displayName = "H5Icon";
const PA = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
  },
  children: [
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M1.9999 1.89941C1.66853 1.89941 1.3999 2.16804 1.3999 2.49941C1.3999 2.83078 1.66853 3.09941 1.9999 3.09941H13.9999C14.3313 3.09941 14.5999 2.83078 14.5999 2.49941C14.5999 2.16804 14.3313 1.89941 13.9999 1.89941H1.9999Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M3.33315 5.56641C3.00178 5.56641 2.73315 5.83504 2.73315 6.16641C2.73315 6.49778 3.00178 6.76641 3.33315 6.76641H12.6665C12.9979 6.76641 13.2665 6.49778 13.2665 6.16641C13.2665 5.83504 12.9979 5.56641 12.6665 5.56641H3.33315Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M1.3999 9.8334C1.3999 9.50203 1.66853 9.2334 1.9999 9.2334H13.9999C14.3313 9.2334 14.5999 9.50203 14.5999 9.8334C14.5999 10.1648 14.3313 10.4334 13.9999 10.4334H1.9999C1.66853 10.4334 1.3999 10.1648 1.3999 9.8334Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M3.33315 12.9004C3.00178 12.9004 2.73315 13.169 2.73315 13.5004C2.73315 13.8318 3.00178 14.1004 3.33315 14.1004H12.6665C12.9979 14.1004 13.2665 13.8318 13.2665 13.5004C13.2665 13.169 12.9979 12.9004 12.6665 12.9004H3.33315Z"
      }
    }
  ]
}, sc = Be(function(e, t) {
  return Te(Me, Object.assign({}, e, {
    id: "horizontally-icon",
    ref: t,
    icon: PA
  }));
});
sc.displayName = "HorizontallyIcon";
const NA = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
  },
  children: [{
    tag: "path",
    attrs: {
      fill: "currentColor",
      d: "M10.4713 3.52876C10.7317 3.78911 10.7317 4.21122 10.4713 4.47157L6.94273 8.00016L10.4713 11.5288C10.7317 11.7891 10.7317 12.2112 10.4713 12.4716C10.211 12.7319 9.78886 12.7319 9.52851 12.4716L5.52851 8.47157C5.26816 8.21122 5.26816 7.78911 5.52851 7.52876L9.52851 3.52876C9.78886 3.26841 10.211 3.26841 10.4713 3.52876Z",
      fillRule: "evenodd",
      clipRule: "evenodd"
    }
  }]
}, ic = Be(function(e, t) {
  return Te(Me, Object.assign({}, e, {
    id: "left-icon",
    ref: t,
    icon: NA
  }));
});
ic.displayName = "LeftIcon";
const LA = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
  },
  children: [
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M1.9999 1.89941C1.66853 1.89941 1.3999 2.16804 1.3999 2.49941C1.3999 2.83078 1.66853 3.09941 1.9999 3.09941H13.9999C14.3313 3.09941 14.5999 2.83078 14.5999 2.49941C14.5999 2.16804 14.3313 1.89941 13.9999 1.89941H1.9999Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M1.9999 5.56641C1.66853 5.56641 1.3999 5.83504 1.3999 6.16641C1.3999 6.49778 1.66853 6.76641 1.9999 6.76641H11.3332C11.6646 6.76641 11.9332 6.49778 11.9332 6.16641C11.9332 5.83504 11.6646 5.56641 11.3332 5.56641H1.9999Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M1.3999 9.8334C1.3999 9.50203 1.66853 9.2334 1.9999 9.2334H13.9999C14.3313 9.2334 14.5999 9.50203 14.5999 9.8334C14.5999 10.1648 14.3313 10.4334 13.9999 10.4334H1.9999C1.66853 10.4334 1.3999 10.1648 1.3999 9.8334Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M1.9999 12.9004C1.66853 12.9004 1.3999 13.169 1.3999 13.5004C1.3999 13.8318 1.66853 14.1004 1.9999 14.1004H11.3332C11.6646 14.1004 11.9332 13.8318 11.9332 13.5004C11.9332 13.169 11.6646 12.9004 11.3332 12.9004H1.9999Z"
      }
    }
  ]
}, ac = Be(function(e, t) {
  return Te(Me, Object.assign({}, e, {
    id: "left-justifying-icon",
    ref: t,
    icon: LA
  }));
});
ac.displayName = "LeftJustifyingIcon";
const QA = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
  },
  children: [
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M1.9999 1.89941C1.66853 1.89941 1.3999 2.16804 1.3999 2.49941C1.3999 2.83078 1.66853 3.09941 1.9999 3.09941H13.9999C14.3313 3.09941 14.5999 2.83078 14.5999 2.49941C14.5999 2.16804 14.3313 1.89941 13.9999 1.89941H1.9999Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M4.66665 5.56641C4.33528 5.56641 4.06665 5.83504 4.06665 6.16641C4.06665 6.49778 4.33528 6.76641 4.66665 6.76641H14C14.3314 6.76641 14.6 6.49778 14.6 6.16641C14.6 5.83504 14.3314 5.56641 14 5.56641H4.66665Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M1.3999 9.8334C1.3999 9.50203 1.66853 9.2334 1.9999 9.2334H13.9999C14.3313 9.2334 14.5999 9.50203 14.5999 9.8334C14.5999 10.1648 14.3313 10.4334 13.9999 10.4334H1.9999C1.66853 10.4334 1.3999 10.1648 1.3999 9.8334Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M4.66665 12.9004C4.33528 12.9004 4.06665 13.169 4.06665 13.5004C4.06665 13.8318 4.33528 14.1004 4.66665 14.1004H14C14.3314 14.1004 14.6 13.8318 14.6 13.5004C14.6 13.169 14.3314 12.9004 14 12.9004H4.66665Z"
      }
    }
  ]
}, cc = Be(function(e, t) {
  return Te(Me, Object.assign({}, e, {
    id: "right-justifying-icon",
    ref: t,
    icon: QA
  }));
});
cc.displayName = "RightJustifyingIcon";
const UA = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
  },
  children: [{
    tag: "path",
    attrs: {
      fill: "currentColor",
      d: "M2.06641 1.9999C2.06641 1.66853 2.33504 1.3999 2.66641 1.3999H13.3331C13.6644 1.3999 13.9331 1.66853 13.9331 1.9999V3.64434C13.9331 3.97571 13.6644 4.24434 13.3331 4.24434C13.0017 4.24434 12.7331 3.97571 12.7331 3.64434V2.5999H8.59966V13.3999H10.6665C10.9979 13.3999 11.2665 13.6685 11.2665 13.9999C11.2665 14.3313 10.9979 14.5999 10.6665 14.5999L7.99966 14.5999L5.33315 14.5999C5.00178 14.5999 4.73315 14.3313 4.73315 13.9999C4.73315 13.6685 5.00178 13.3999 5.33315 13.3999H7.39966V2.5999H3.26641V3.64434C3.26641 3.97571 2.99778 4.24434 2.66641 4.24434C2.33504 4.24434 2.06641 3.97571 2.06641 3.64434V1.9999Z"
    }
  }]
}, pn = Be(function(e, t) {
  return Te(Me, Object.assign({}, e, {
    id: "text-type-icon",
    ref: t,
    icon: UA
  }));
});
pn.displayName = "TextTypeIcon";
const FA = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
  },
  children: [
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M4.96372 2.59116C5.19803 2.35684 5.19803 1.97695 4.96372 1.74263C4.7294 1.50832 4.3495 1.50832 4.11519 1.74263L2.53945 3.31837L1.96372 2.74263C1.7294 2.50832 1.3495 2.50832 1.11519 2.74263C0.880874 2.97695 0.880874 3.35684 1.11519 3.59116L2.11519 4.59116C2.3495 4.82547 2.7294 4.82547 2.96372 4.59116L4.96372 2.59116Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M14.4605 2.56689H6.8981C6.56672 2.56689 6.2981 2.83552 6.2981 3.16689C6.2981 3.49827 6.56672 3.76689 6.8981 3.76689H14.4605C14.7918 3.76689 15.0605 3.49827 15.0605 3.16689C15.0605 2.83552 14.7918 2.56689 14.4605 2.56689Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M6.8981 7.2334C6.56672 7.2334 6.2981 7.50203 6.2981 7.8334C6.2981 8.16477 6.56672 8.4334 6.8981 8.4334H14.4605C14.7918 8.4334 15.0605 8.16477 15.0605 7.8334C15.0605 7.50203 14.7918 7.2334 14.4605 7.2334H6.8981Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M6.2981 12.4999C6.2981 12.1685 6.56672 11.8999 6.8981 11.8999H14.4605C14.7918 11.8999 15.0605 12.1685 15.0605 12.4999C15.0605 12.8313 14.7918 13.0999 14.4605 13.0999H6.8981C6.56672 13.0999 6.2981 12.8313 6.2981 12.4999Z"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M2.87279 5.8999C1.80504 5.8999 0.939453 6.76549 0.939453 7.83324C0.939453 8.90099 1.80504 9.76657 2.87279 9.76657C3.94054 9.76657 4.80612 8.90099 4.80612 7.83324C4.80612 6.76549 3.94054 5.8999 2.87279 5.8999ZM2.13945 7.83324C2.13945 7.42823 2.46778 7.0999 2.87279 7.0999C3.2778 7.0999 3.60612 7.42823 3.60612 7.83324C3.60612 8.23824 3.2778 8.56657 2.87279 8.56657C2.46778 8.56657 2.13945 8.23824 2.13945 7.83324Z",
        fillRule: "evenodd",
        clipRule: "evenodd"
      }
    },
    {
      tag: "path",
      attrs: {
        fill: "currentColor",
        d: "M0.939453 12.5002C0.939453 11.4325 1.80504 10.5669 2.87279 10.5669C3.94054 10.5669 4.80612 11.4325 4.80612 12.5002C4.80612 13.568 3.94054 14.4336 2.87279 14.4336C1.80504 14.4336 0.939453 13.568 0.939453 12.5002ZM2.87279 11.7669C2.46778 11.7669 2.13945 12.0952 2.13945 12.5002C2.13945 12.9052 2.46778 13.2336 2.87279 13.2336C3.2778 13.2336 3.60612 12.9052 3.60612 12.5002C3.60612 12.0952 3.2778 11.7669 2.87279 11.7669Z",
        fillRule: "evenodd",
        clipRule: "evenodd"
      }
    }
  ]
}, lc = Be(function(e, t) {
  return Te(Me, Object.assign({}, e, {
    id: "todo-list-double-icon",
    ref: t,
    icon: FA
  }));
});
lc.displayName = "TodoListDoubleIcon";
function dc(n) {
  var o;
  const { dataStream: e } = (o = n.body) != null ? o : {}, t = [
    V.TABLE_START,
    V.TABLE_CELL_END,
    V.TABLE_CELL_START,
    V.TABLE_END,
    V.TABLE_ROW_END,
    V.TABLE_ROW_START,
    V.COLUMN_BREAK,
    V.PAGE_BREAK,
    V.TAB,
    V.DOCS_END,
    V.CUSTOM_BLOCK
  ];
  if (typeof e == "string")
    for (let r = 0; r < e.length; r++) {
      const s = e[r];
      if (!t.includes(s))
        return r;
    }
  return 0;
}
class HA extends me {
  constructor(t, o, r, s, i, a) {
    super();
    // Emit change event when editor lose focus.
    O(this, "_change$", new be());
    O(this, "change$", this._change$.asObservable());
    // The input event fires when the value of a editor has been changed as a direct result of a user action.
    O(this, "_input$", new be());
    O(this, "input$", this._input$.asObservable());
    // paste event.
    O(this, "_paste$", new be());
    O(this, "paste$", this._paste$.asObservable());
    // Editor get focus.
    O(this, "_focus$", new be());
    O(this, "focus$", this._focus$.asObservable());
    // Editor lose focus.
    O(this, "_blur$", new be());
    O(this, "blur$", this._blur$.asObservable());
    // Emit when doc selection changed.
    O(this, "_selectionChange$", new be());
    O(this, "selectionChange$", this._selectionChange$.asObservable());
    this._param = t, this._univerInstanceService = o, this._docSelectionManagerService = r, this._commandService = s, this._undoRedoService = i, this._injector = a, this._listenSelection();
  }
  get docSelectionRenderService() {
    return this._param.render.with(Re);
  }
  _listenSelection() {
    const t = this._param.render.with(Re);
    this.disposeWithMe(
      t.onBlur$.subscribe((o) => {
        this._blur$.next(o);
        const r = this.getDocumentData();
        this._change$.next({
          target: this,
          data: r
        });
      })
    ), this.disposeWithMe(
      t.onFocus$.subscribe((o) => {
        this._focus$.next(o);
      })
    ), this.disposeWithMe(
      t.onPaste$.subscribe((o) => {
        this._paste$.next(o);
      })
    ), this.disposeWithMe(
      ua(
        t.onInput$,
        t.onKeydown$.pipe(dr((o) => {
          const r = o.event;
          return r.ctrlKey || r.metaKey ? [q.X, q.V].includes(r.keyCode) : [q.BACKSPACE].includes(r.keyCode);
        })),
        t.onCompositionupdate$,
        t.onCompositionend$,
        t.onPaste$
      ).subscribe((o) => {
        if (o == null)
          return;
        const { content: r = "" } = o, s = this.getDocumentData();
        this._input$.next({
          target: this,
          content: r,
          data: s,
          isComposing: o.event.type === "compositionupdate"
        });
      })
    ), this.disposeWithMe(
      this._docSelectionManagerService.textSelection$.subscribe((o) => {
        if (o == null)
          return;
        const { unitId: r, subUnitId: s, ...i } = o, a = this.getEditorId();
        r === a && this._selectionChange$.next(i);
      })
    );
  }
  isFocus() {
    const t = this._param.render.with(Re);
    return t.isFocusing && !!t.getActiveTextRange();
  }
  /**
   * @deprecated use `IEditorService.focus` as instead. this is for internal usage.
   */
  focus() {
    const t = this._univerInstanceService.getCurrentUnitForType(_.UNIVER_DOC), o = this.getEditorId();
    (t == null || t.getUnitId() !== o) && this._univerInstanceService.setCurrentUnitForType(o), this._param.render.with(Re).focus();
  }
  /**
   * @deprecated use `IEditorService.blur` as instead. this is for internal usage.
   */
  blur() {
    this._param.render.with(Re).blur();
  }
  // Selects the entire content of the editor.
  // Calling editor.select() will not necessarily focus the editor, so it is often used with Editor.focus
  select() {
    const t = this.getDocumentData();
    return this.setSelectionRanges([{
      startOffset: 0,
      endOffset: t.body ? t.body.dataStream.length - 2 : 0
    }]);
  }
  // Selects the specified range of characters within editor.
  setSelectionRanges(t, o = !0) {
    const r = this.getEditorId(), s = {
      unitId: r,
      subUnitId: r
    };
    return this._docSelectionManagerService.replaceDocRanges(t, s, !1, { shouldFocus: o });
  }
  // Get current doc ranges. include text range and rect range.
  getSelectionRanges() {
    const t = this.getEditorId(), o = {
      unitId: t,
      subUnitId: t
    };
    return this._docSelectionManagerService.getDocRanges(o);
  }
  getCursorPosition() {
    var o, r;
    return (r = (o = this.getSelectionRanges().find((s) => s.collapsed)) == null ? void 0 : o.startOffset) != null ? r : -1;
  }
  // get editor id.
  getEditorId() {
    return this._getEditorId();
  }
  // get document data.
  getDocumentData() {
    return this._getDocDataModel().getSnapshot();
  }
  getDocumentDataModel() {
    return this._getDocDataModel();
  }
  // Set the new document data.
  setDocumentData(t, o) {
    this._commandService.syncExecuteCommand(_a.id, {
      unitId: this.getEditorId(),
      snapshot: t,
      textRanges: o
    });
  }
  replaceText(t, o = !0) {
    const r = this.getDocumentData();
    this.setDocumentData(
      {
        ...r,
        body: {
          dataStream: `${t}\r
`,
          paragraphs: [{
            startIndex: 0
          }],
          customRanges: [],
          sectionBreaks: [],
          tables: [],
          textRuns: []
        }
      },
      typeof o == "object" ? o : o ? [{
        startOffset: t.length,
        endOffset: t.length,
        collapsed: !0
      }] : null
    );
  }
  // Clear the undo redo history of this editor.
  clearUndoRedoHistory() {
    const t = this.getEditorId();
    return this._undoRedoService.clearUndoRedo(t);
  }
  dispose() {
    this._getDocDataModel().dispose();
  }
  /**
   * @deprecated use getEditorId.
   */
  get editorUnitId() {
    return this._param.editorUnitId;
  }
  /**
   * @deprecated @TODO: @JOCS remove this in the future.
   */
  get params() {
    return this._param;
  }
  get cancelDefaultResizeListener() {
    return this._param.cancelDefaultResizeListener;
  }
  get render() {
    return this._param.render;
  }
  isReadOnly() {
    return this._param.readonly === !0;
  }
  getBoundingClientRect() {
    return this._param.editorDom.getBoundingClientRect();
  }
  get editorDOM() {
    return this._param.editorDom;
  }
  isVisible() {
    return this._param.visible;
  }
  getSkeleton() {
    var o;
    return (o = this._injector.get(pe).getRenderById(this._getEditorId())) == null ? void 0 : o.with(de).getSkeleton();
  }
  isSheetEditor() {
    return Rt(this._getEditorId());
  }
  /**
   * @deprecated use getDocumentData.
   */
  getValue() {
    var r;
    return (((r = this._getDocDataModel().getBody()) == null ? void 0 : r.dataStream) || "").replace(/\r\n/g, "").replace(/\n/g, "").replace(/\n/g, "");
  }
  /**
   * @deprecated use getDocumentData.
   */
  getBody() {
    return this._getDocDataModel().getBody();
  }
  /**
   * @deprecated.
   */
  update(t) {
    this._param = {
      ...this._param,
      ...t
    };
  }
  /**
   * @deprecated.
   */
  updateCanvasStyle() {
    var r;
    const t = this._getDocDataModel();
    if (t == null)
      return;
    const o = {};
    (r = this._param.canvasStyle) != null && r.fontSize && (o.textStyle == null && (o.textStyle = {}), o.textStyle.fs = this._param.canvasStyle.fontSize), t.updateDocumentStyle(o);
  }
  _getDocDataModel() {
    const t = this._getEditorId();
    return this._univerInstanceService.getUnit(t, _.UNIVER_DOC);
  }
  _getEditorId() {
    var t;
    return ((t = this._param.initialSnapshot) == null ? void 0 : t.id) || this._param.editorUnitId || "";
  }
}
var kA = Object.getOwnPropertyDescriptor, VA = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? kA(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, Ot = (n, e) => (t, o) => e(t, o, n);
const WA = [
  "editor",
  "render-canvas"
  // 'univer-range-selector',
  // 'univer-range-selector-editor',
  // 'univer-text-editor-container-placeholder',
];
let Sr = class extends me {
  constructor(e, t, o, r, s, i, a) {
    super();
    O(this, "_editors", /* @__PURE__ */ new Map());
    O(this, "_focusEditorUnitId");
    O(this, "_blur$", new be());
    O(this, "blur$", this._blur$.asObservable());
    O(this, "_focus$", new be());
    O(this, "focus$", this._focus$.asObservable());
    this._univerInstanceService = e, this._renderManagerService = t, this._docSelectionManagerService = o, this._contextService = r, this._commandService = s, this._undoRedoService = i, this._injector = a, this._initUniverFocusListener();
  }
  // REFACTOR: @Gggpound The specific business processing should not be placed here,
  // I moved from the layout service. https://github.com/dream-num/univer-pro/issues/1708
  _initUniverFocusListener() {
    this.disposeWithMe(
      je(window, "focusin").subscribe((e) => {
        const t = e.target;
        this._blurSheetEditor(t);
      })
    );
  }
  _blurSheetEditor(e) {
    if (WA.some((o) => e.dataset.uComp === o))
      return;
    const t = this.getFocusEditor();
    t && t.isSheetEditor() !== !0 && this.blur();
  }
  _setFocusId(e) {
    this._focusEditorUnitId = e;
  }
  getFocusId() {
    return this._focusEditorUnitId;
  }
  getFocusEditor() {
    if (this._focusEditorUnitId)
      return this.getEditor(this._focusEditorUnitId);
  }
  isEditor(e) {
    return this._editors.has(e);
  }
  isSheetEditor(e) {
    const t = this._editors.get(e);
    return !!(t && t.isSheetEditor());
  }
  blur(e) {
    const t = this.getFocusEditor();
    e && (t == null || t.setSelectionRanges([])), t == null || t.blur(), this._contextService.setContextValue(eo, !1), this._contextService.setContextValue(Us, !1), this._setFocusId(null), this._blur$.next(null);
  }
  focus(e) {
    if (e === this._focusEditorUnitId || (this._focusEditorUnitId && this.blur(), e == null))
      return;
    const t = this.getEditor(e);
    if (t == null)
      return;
    this._univerInstanceService.setCurrentUnitForType(e);
    const o = t.getValue().length;
    this._contextService.setContextValue(eo, !0), Rt(e) || this._contextService.setContextValue(Us, !0), t.focus(), this._setFocusId(e), this._focus$.next({
      startOffset: o,
      endOffset: o
    });
  }
  dispose() {
    this._editors.clear(), super.dispose();
  }
  getEditor(e = this._getCurrentEditorUnitId()) {
    return this._editors.get(e);
  }
  getAllEditor() {
    return this._editors;
  }
  register(e, t) {
    var c, d, l, A;
    const { initialSnapshot: o, canvasStyle: r = {} } = e, s = o.id;
    this._univerInstanceService.getUnit(s, _.UNIVER_DOC) == null && this._univerInstanceService.createUnit(
      _.UNIVER_DOC,
      o || this._getBlank(s),
      { makeCurrent: !1 }
    );
    let a = this._renderManagerService.getRenderById(s);
    if (a == null && (this._renderManagerService.create(s), a = this._renderManagerService.getRenderById(s)), a) {
      a.engine.setContainer(t);
      const h = new HA(
        { ...e, render: a, editorDom: t, canvasStyle: r },
        this._univerInstanceService,
        this._docSelectionManagerService,
        this._commandService,
        this._undoRedoService,
        this._injector
      );
      this._editors.set(s, h), e.scrollBar || (A = (l = (d = (c = a.mainComponent) == null ? void 0 : c.getScene()) == null ? void 0 : d.getViewports()) == null ? void 0 : l[0].getScrollBar()) == null || A.dispose();
    }
    return Mn(() => {
      this._unRegister(s);
    });
  }
  _unRegister(e) {
    const t = this._editors.get(e);
    t != null && (this._renderManagerService.removeRender(e), t.dispose(), this._editors.delete(e), this._univerInstanceService.disposeUnit(e));
  }
  _getCurrentEditorUnitId() {
    return this._univerInstanceService.getCurrentUniverDocInstance().getUnitId();
  }
  _getBlank(e) {
    return {
      id: e,
      body: {
        dataStream: `${qi}`,
        textRuns: [],
        paragraphs: [
          {
            startIndex: 0
          }
        ]
      },
      documentStyle: {
        renderConfig: {
          verticalAlign: kc.TOP,
          horizontalAlign: Ue.LEFT
        },
        marginLeft: 3,
        marginTop: 0,
        marginRight: 3
      }
    };
  }
};
Sr = VA([
  Ot(0, L),
  Ot(1, pe),
  Ot(2, j(Y)),
  Ot(3, Fr),
  Ot(4, T),
  Ot(5, yo),
  Ot(6, j(Dn))
], Sr);
const Ge = Yi("univer.editor.service"), vr = "COMPONENT_DOC_HEADER_FOOTER_PANEL";
function jA(n, e, t) {
  const {
    useFirstPageHeaderFooter: o,
    evenAndOddHeaders: r,
    defaultHeaderId: s,
    defaultFooterId: i,
    firstPageHeaderId: a,
    firstPageFooterId: c,
    evenPageHeaderId: d,
    evenPageFooterId: l
  } = n;
  return e === ve.HEADER ? o === z.TRUE ? t === 0 ? a : r === z.TRUE && t % 2 === 1 ? d : s : r === z.TRUE && t % 2 === 1 ? d : s : o === z.TRUE ? t === 0 ? c : r === z.TRUE && t % 2 === 1 ? l : i : r === z.TRUE && t % 2 === 1 ? l : i;
}
const zA = (n) => {
  const e = J(Ye), t = J(L), o = J(pe), r = J(T), s = J(Oo), { unitId: i } = n, a = o.getRenderById(i).with(Re), [c, d] = Ee({}), l = (u, g) => {
    var b;
    d((y) => ({
      ...y,
      [g]: u ? z.TRUE : z.FALSE
    }));
    const f = t.getUniverDocInstance(i), p = f == null ? void 0 : f.getSnapshot().documentStyle, m = (b = o.getRenderById(i)) == null ? void 0 : b.with(de), I = m == null ? void 0 : m.getViewModel();
    if (p == null || I == null)
      return;
    const S = I.getEditArea();
    let v = !1;
    const R = a.getSegmentPage();
    let E = !1;
    if (g === "useFirstPageHeaderFooter" && u === !0 && ((S === ve.HEADER && !p.firstPageHeaderId || S === ve.FOOTER && !p.firstPageFooterId) && (v = !0), v && R === 0 && (E = !0)), g === "evenAndOddHeaders" && u === !0 && ((S === ve.HEADER && !p.evenPageHeaderId || S === ve.FOOTER && !p.evenPageFooterId) && (v = !0), v && R % 2 === 1 && (E = !0)), v) {
      const C = ge(6);
      E && a.setSegment(C), r.executeCommand($n, {
        unitId: i,
        segmentId: C,
        headerFooterProps: {
          [g]: u ? z.TRUE : z.FALSE
        }
      });
    } else {
      const y = a.getSegmentPage(), C = a.getSegment(), B = jA(
        {
          ...p,
          [g]: u ? z.TRUE : z.FALSE
        },
        S,
        y
      );
      B && B !== C && a.setSegment(B), r.executeCommand($n, {
        unitId: i,
        headerFooterProps: {
          [g]: u ? z.TRUE : z.FALSE
        }
      });
    }
    s.focus();
  }, A = async (u, g) => {
    d((f) => ({
      ...f,
      [g]: u
    })), await r.executeCommand($n, {
      unitId: i,
      headerFooterProps: {
        [g]: u
      }
    }), a.removeAllRanges(), a.blur();
  }, h = () => {
    r.executeCommand(Ms.id, {
      unitId: i
    });
  };
  return Ce(() => {
    const u = t.getUniverDocInstance(i), g = u == null ? void 0 : u.getSnapshot().documentStyle;
    if (g) {
      const {
        marginHeader: f = 0,
        marginFooter: p = 0,
        useFirstPageHeaderFooter: m = z.FALSE,
        evenAndOddHeaders: I = z.FALSE
      } = g;
      d({
        marginHeader: f,
        marginFooter: p,
        useFirstPageHeaderFooter: m,
        evenAndOddHeaders: I
      });
    }
  }, [i]), /* @__PURE__ */ re("div", { className: "univer-grid univer-gap-4", children: [
    /* @__PURE__ */ re("div", { className: "univer-grid univer-gap-2", children: [
      /* @__PURE__ */ Q("div", { children: /* @__PURE__ */ Q(
        Xs,
        {
          checked: c.useFirstPageHeaderFooter === z.TRUE,
          onChange: (u) => {
            l(u, "useFirstPageHeaderFooter");
          },
          children: e.t("headerFooter.firstPageCheckBox")
        }
      ) }),
      /* @__PURE__ */ Q("div", { children: /* @__PURE__ */ Q(
        Xs,
        {
          checked: c.evenAndOddHeaders === z.TRUE,
          onChange: (u) => {
            l(u, "evenAndOddHeaders");
          },
          children: e.t("headerFooter.oddEvenCheckBox")
        }
      ) })
    ] }),
    /* @__PURE__ */ re("div", { className: "univer-mb-1 univer-flex", children: [
      /* @__PURE__ */ re("div", { children: [
        /* @__PURE__ */ Q("span", { children: e.t("headerFooter.headerTopMargin") }),
        /* @__PURE__ */ Q(
          it,
          {
            className: "univer-mt-1.5 univer-w-4/5",
            min: 0,
            max: 200,
            precision: 1,
            value: c.marginHeader,
            onChange: (u) => {
              A(u, "marginHeader");
            }
          }
        )
      ] }),
      /* @__PURE__ */ re("div", { children: [
        /* @__PURE__ */ Q("span", { children: e.t("headerFooter.footerBottomMargin") }),
        /* @__PURE__ */ Q(
          it,
          {
            className: "univer-mt-1.5 univer-w-4/5",
            min: 0,
            max: 200,
            precision: 1,
            value: c.marginFooter,
            onChange: (u) => {
              A(u, "marginFooter");
            }
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ Q("div", { className: "univer-flex univer-justify-end", children: /* @__PURE__ */ Q(Zl, { onClick: h, children: e.t("headerFooter.closeHeaderFooter") }) })
  ] });
}, GA = () => {
  var d;
  const n = J(Ye), e = J(pe), r = J(L).getCurrentUniverDocInstance().getUnitId(), i = ((d = e.getRenderById(r)) == null ? void 0 : d.with(de)).getViewModel(), [a, c] = Ee(!0);
  return Ce(() => {
    const l = i.getEditArea();
    c(l !== ve.BODY);
    const A = i.editAreaChange$.subscribe((h) => {
      h != null && c(h !== ve.BODY);
    });
    return () => {
      A.unsubscribe();
    };
  }, []), /* @__PURE__ */ Q("div", { className: "univer-text-sm", children: a ? /* @__PURE__ */ Q(zA, { unitId: r }) : /* @__PURE__ */ Q("div", { className: "univer-text-gray-400", children: n.t("headerFooter.disableText") }) });
}, Ii = 18, Si = 200, er = 6, YA = 4;
function KA(n, e) {
  let { radius: t, width: o, height: r } = e;
  t = t != null ? t : 0, o = o != null ? o : 30, r = r != null ? r : 30;
  let s = 0;
  s = Math.min(t, o / 2, r / 2), n.beginPath(), n.moveTo(0, 0), n.lineTo(o, 0), n.lineTo(o, r - s), n.arc(o - s, r - s, s, 0, Math.PI / 2, !1), n.lineTo(0, r), n.lineTo(0, 0), n.closePath(), e.fill && (n.save(), n.fillStyle = e.fill, e.fillRule === "evenodd" ? n.fill("evenodd") : n.fill(), n.restore());
}
class ao extends Al {
  constructor(t, o) {
    super(t, o);
    O(this, "color");
    O(this, "text");
    this.color = o == null ? void 0 : o.color, this.text = o == null ? void 0 : o.text;
  }
  static drawWith(t, o) {
    const { text: r, color: s } = o;
    t.save(), t.font = "13px Source Han Sans CN";
    const i = t.measureText(r).width, a = Math.min(
      i + 2 * er,
      Si
    );
    KA(t, {
      height: Ii,
      width: a,
      radius: 4,
      fill: s
    }), t.fillStyle = "rgba(58, 96, 247, 1)";
    const c = er, d = Ii - YA, l = Si - 2 * er;
    if (i > l) {
      let A = "", h = 0;
      for (const u of r) {
        const g = t.measureText(u).width;
        if (h + g <= l - t.measureText("...").width)
          A += u, h += g;
        else {
          A += "...";
          break;
        }
      }
      t.fillText(A, c, d);
    } else
      t.fillText(r, c, d);
    t.restore();
  }
  _draw(t) {
    ao.drawWith(t, this);
  }
}
var qA = Object.getOwnPropertyDescriptor, XA = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? qA(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, ut = (n, e) => (t, o) => e(t, o, n);
const vi = "rgba(58, 96, 247, 1)", Ci = "rgba(58, 96, 247, 0.08)";
var Qe = /* @__PURE__ */ ((n) => (n[n.FIRST_PAGE_HEADER = 0] = "FIRST_PAGE_HEADER", n[n.FIRST_PAGE_FOOTER = 1] = "FIRST_PAGE_FOOTER", n[n.DEFAULT_HEADER = 2] = "DEFAULT_HEADER", n[n.DEFAULT_FOOTER = 3] = "DEFAULT_FOOTER", n[n.EVEN_PAGE_HEADER = 4] = "EVEN_PAGE_HEADER", n[n.EVEN_PAGE_FOOTER = 5] = "EVEN_PAGE_FOOTER", n))(Qe || {});
function ZA(n, e, t) {
  const { documentStyle: o } = n.getDataModel().getSnapshot(), {
    defaultHeaderId: r,
    defaultFooterId: s,
    evenPageHeaderId: i,
    evenPageFooterId: a,
    firstPageHeaderId: c,
    firstPageFooterId: d,
    evenAndOddHeaders: l,
    useFirstPageHeaderFooter: A
  } = o;
  switch (e) {
    case ve.BODY:
      return {
        createType: null,
        headerFooterId: null
      };
    case ve.HEADER:
      return A === z.TRUE && !c ? {
        createType: 0,
        headerFooterId: null
      } : l === z.TRUE && t % 2 === 0 && !i ? {
        createType: 4,
        headerFooterId: null
      } : r ? {
        createType: null,
        headerFooterId: r
      } : {
        createType: 2,
        headerFooterId: null
      };
    case ve.FOOTER:
      return A === z.TRUE && !d ? {
        createType: 1,
        headerFooterId: null
      } : l === z.TRUE && t % 2 === 0 && !a ? {
        createType: 5,
        headerFooterId: null
      } : s ? {
        createType: null,
        headerFooterId: s
      } : {
        createType: 3,
        headerFooterId: null
      };
    default:
      throw new Error(`Invalid editArea: ${e}`);
  }
}
let Cr = class extends me {
  constructor(e, t, o, r, s, i, a, c, d) {
    super();
    O(this, "_loadedMap", /* @__PURE__ */ new WeakSet());
    this._context = e, this._commandService = t, this._editorService = o, this._instanceSrv = r, this._renderManagerService = s, this._docSkeletonManagerService = i, this._docSelectionRenderService = a, this._localeService = c, this._componentManager = d, this._initialize();
  }
  _initialize() {
    this._init(), this._drawHeaderFooterLabel(), this._initCustomComponents(), this._listenSwitchMode();
  }
  dispose() {
    super.dispose();
  }
  // Close header footer panel when switch mode.
  _listenSwitchMode() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((e) => {
        if (X.id === e.id) {
          const t = this._context.unit, r = this._docSkeletonManagerService.getViewModel().getEditArea(), s = t.getSnapshot().documentStyle.documentFlavor;
          r !== ve.BODY && s === Pe.MODERN && this._commandService.executeCommand(Ms.id, {
            unitId: this._context.unitId
          });
        }
      })
    );
  }
  _initCustomComponents() {
    this._componentManager.get(vr) || this.disposeWithMe(this._componentManager.register(vr, GA));
  }
  _init() {
    const { unitId: e } = this._context, t = pt(this._context);
    t == null || t.document == null || this._loadedMap.has(t.document) || (this._initialMain(e), this._loadedMap.add(t.document));
  }
  _initialMain(e) {
    const t = pt(this._context), { document: o } = t;
    this.disposeWithMe(o.onDblclick$.subscribeEvent(async (r) => {
      if (this._isEditorReadOnly(e) || !this._isTraditionalMode())
        return;
      const { offsetX: s, offsetY: i } = r, {
        pageLayoutType: a = Cn.VERTICAL,
        pageMarginLeft: c,
        pageMarginTop: d
      } = o.getOffsetConfig(), l = this._getTransformCoordForDocumentOffset(s, i);
      if (l == null)
        return;
      const A = this._docSkeletonManagerService.getViewModel(), h = this._docSkeletonManagerService.getSkeleton(), u = A.getEditArea(), { editArea: g, pageNumber: f } = h.findEditAreaByCoord(
        l,
        a,
        c,
        d
      );
      if (u === g)
        return;
      A.setEditArea(g);
      const { createType: p, headerFooterId: m } = ZA(A, g, f);
      if (g === ve.BODY)
        this._docSelectionRenderService.setSegment(""), this._docSelectionRenderService.setSegmentPage(-1), this._docSelectionRenderService.setCursorManually(s, i);
      else if (p != null) {
        const S = ge(6);
        this._docSelectionRenderService.setSegment(S), this._docSelectionRenderService.setSegmentPage(f), await this._commandService.executeCommand(Ac.id, {
          unitId: e,
          createType: p,
          segmentId: S
        });
      } else m != null && (this._docSelectionRenderService.setSegment(m), this._docSelectionRenderService.setSegmentPage(f), this._docSelectionRenderService.setCursorManually(s, i));
    }));
  }
  _getTransformCoordForDocumentOffset(e, t) {
    const o = pt(this._context), { document: r, scene: s } = o, { documentTransform: i } = r.getOffsetConfig(), a = s.getViewports()[0];
    if (a == null)
      return;
    const c = a.transformVector2SceneCoord(vn.FromArray([e, t]));
    return i.clone().invert().applyPoint(c);
  }
  // eslint-disable-next-line max-lines-per-function
  _drawHeaderFooterLabel() {
    const e = this._localeService;
    this.disposeWithMe(
      this._instanceSrv.getCurrentTypeOfUnit$(_.UNIVER_DOC).subscribe((t) => {
        if (t == null)
          return;
        const o = t.getUnitId(), r = this._renderManagerService.getRenderById(o);
        if (this._editorService.isEditor(o) || this._instanceSrv.getUniverDocInstance(o) == null || r == null)
          return;
        const { mainComponent: s } = r, i = s;
        this.disposeWithMe(
          Mn(
            // eslint-disable-next-line max-lines-per-function
            i.pageRender$.subscribe((a) => {
              if (this._editorService.isEditor(o) || !this._isTraditionalMode())
                return;
              const l = this._docSkeletonManagerService.getViewModel().getEditArea() === ve.BODY, { page: A, pageLeft: h, pageTop: u, ctx: g } = a, { pageWidth: f, pageHeight: p, marginTop: m, marginBottom: I } = A;
              if (g.save(), g.translate(h - 0.5, u - 0.5), l ? (Kn.drawWith(g, {
                left: 0,
                top: 0,
                width: f,
                height: m,
                fill: "rgba(255, 255, 255, 0.5)"
              }), g.save(), g.translate(0, p - I), Kn.drawWith(g, {
                left: 0,
                top: 0,
                width: f,
                height: I,
                fill: "rgba(255, 255, 255, 0.5)"
              }), g.restore()) : (g.save(), g.translate(0, m), Kn.drawWith(g, {
                left: 0,
                top: m,
                width: f,
                height: p - m - I,
                fill: "rgba(255, 255, 255, 0.5)"
              }), g.restore()), !l) {
                const S = {
                  dataArray: [{
                    command: "M",
                    points: [0, m]
                  }, {
                    command: "L",
                    points: [f, m]
                  }],
                  strokeWidth: 1,
                  stroke: vi
                }, v = {
                  dataArray: [{
                    command: "M",
                    points: [0, p - I]
                  }, {
                    command: "L",
                    points: [f, p - I]
                  }],
                  strokeWidth: 1,
                  stroke: vi
                };
                js.drawWith(g, S), js.drawWith(g, v), g.translate(0, m + 1), ao.drawWith(g, {
                  text: e.t("headerFooter.header"),
                  color: Ci
                }), g.translate(0, p - m - I), ao.drawWith(g, {
                  text: e.t("headerFooter.footer"),
                  color: Ci
                });
              }
              g.restore();
            })
          )
        );
      })
    );
  }
  _isEditorReadOnly(e) {
    const t = this._editorService.getEditor(e);
    return t ? t.isReadOnly() : !1;
  }
  _isTraditionalMode() {
    return this._context.unit.getSnapshot().documentStyle.documentFlavor === Pe.TRADITIONAL;
  }
};
Cr = XA([
  ut(1, T),
  ut(2, Ge),
  ut(3, L),
  ut(4, pe),
  ut(5, j(de)),
  ut(6, j(Re)),
  ut(7, j(Ye)),
  ut(8, j(rn))
], Cr);
const Ts = {
  id: "sidebar.operation.doc-header-footer-panel",
  type: D.OPERATION,
  handler: async (n, e) => {
    const t = n.get(ca), o = n.get(Ye);
    switch (e.value) {
      case "open":
        t.open({
          header: { title: o.t("headerFooter.panel") },
          children: { label: vr },
          onClose: () => {
          },
          width: 400
        });
        break;
      case "close":
      default:
        t.close();
        break;
    }
    return !0;
  }
};
function Ri() {
  return {
    dataStream: `\r
`,
    textRuns: [{
      st: 0,
      ed: 0,
      ts: {
        fs: 9
        // The default header footer text size.
      }
    }],
    customBlocks: [],
    paragraphs: [
      {
        startIndex: 0,
        paragraphStyle: {
          spaceAbove: { v: 0 },
          lineSpacing: 1.5,
          spaceBelow: { v: 0 }
        }
      }
    ],
    sectionBreaks: [
      {
        startIndex: 1
      }
    ]
  };
}
function tr(n, e, t, o) {
  const r = W.getInstance(), s = 6, i = n != null ? n : ge(s), a = e === Qe.DEFAULT_HEADER || e === Qe.FIRST_PAGE_HEADER || e === Qe.EVEN_PAGE_HEADER, c = r.insertOp([a ? "headers" : "footers", i], {
    [a ? "headerId" : "footerId"]: i,
    body: Ri()
  });
  o.push(c);
  const d = ge(s), l = r.insertOp([a ? "footers" : "headers", d], {
    [a ? "footerId" : "headerId"]: d,
    body: Ri()
  });
  o.push(l);
  let A = "defaultHeaderId", h = "defaultFooterId";
  switch (e) {
    case Qe.DEFAULT_HEADER:
      A = "defaultHeaderId", h = "defaultFooterId";
      break;
    case Qe.DEFAULT_FOOTER:
      A = "defaultFooterId", h = "defaultHeaderId";
      break;
    case Qe.FIRST_PAGE_HEADER:
      A = "firstPageHeaderId", h = "firstPageFooterId";
      break;
    case Qe.FIRST_PAGE_FOOTER:
      A = "firstPageFooterId", h = "firstPageHeaderId";
      break;
    case Qe.EVEN_PAGE_HEADER:
      A = "evenPageHeaderId", h = "evenPageFooterId";
      break;
    case Qe.EVEN_PAGE_FOOTER:
      A = "evenPageFooterId", h = "evenPageHeaderId";
      break;
    default:
      throw new Error(`Unknown header footer type: ${e}`);
  }
  for (const [u, g] of [[A, i], [h, d]])
    if (t[u] != null) {
      const f = r.replaceOp(["documentStyle", u], t[u], g);
      o.push(f);
    } else {
      const f = r.insertOp(["documentStyle", u], g);
      o.push(f);
    }
  return o;
}
const $n = "doc.command.core-header-footer", Ac = {
  id: $n,
  type: D.COMMAND,
  // eslint-disable-next-line max-lines-per-function
  handler: async (n, e) => {
    var v;
    const t = n.get(T), o = n.get(L), r = n.get(pe), { unitId: s, segmentId: i, createType: a, headerFooterProps: c } = e, d = (v = r.getRenderById(s)) == null ? void 0 : v.with(de), l = o.getUniverDocInstance(s), A = d == null ? void 0 : d.getViewModel();
    if (l == null || A == null)
      return !1;
    const h = A.getEditArea(), { documentStyle: u } = l.getSnapshot(), g = (c == null ? void 0 : c.marginFooter) != null || (c == null ? void 0 : c.marginHeader) != null, f = [{
      startOffset: 0,
      endOffset: 0,
      collapsed: !0
    }], p = {
      id: X.id,
      params: {
        unitId: s,
        actions: [],
        textRanges: f,
        debounce: !0
      }
    };
    g && (p.params.noNeedSetTextRange = !0);
    const m = W.getInstance(), I = [];
    return a != null && tr(i, a, u, I), c != null && Object.keys(c).forEach((R) => {
      const E = c[R], b = u[R];
      if (E === b)
        return;
      let y;
      if (b === void 0 ? y = m.insertOp(["documentStyle", R], E) : y = m.replaceOp(["documentStyle", R], b, E), I.push(y), R === "useFirstPageHeaderFooter" && E === z.TRUE && !u.firstPageHeaderId) {
        const C = h === ve.HEADER ? Qe.FIRST_PAGE_HEADER : Qe.FIRST_PAGE_FOOTER;
        tr(i, C, u, I);
      } else if (R === "evenAndOddHeaders" && E === z.TRUE && !u.evenPageHeaderId) {
        const C = h === ve.HEADER ? Qe.EVEN_PAGE_HEADER : Qe.EVEN_PAGE_FOOTER;
        tr(i, C, u, I);
      }
    }), I.length === 0 ? !1 : (p.params.actions = I.reduce((R, E) => W.compose(R, E), null), !!t.syncExecuteCommand(p.id, p.params));
  }
}, Bs = {
  id: "doc.command.open-header-footer-panel",
  type: D.COMMAND,
  handler: async (n, e) => n.get(T).executeCommand(Ts.id, { value: "open" })
}, Ms = {
  id: "doc.command.close-header-footer",
  type: D.COMMAND,
  handler: async (n, e) => {
    var g;
    const t = n.get(T), o = n.get(pe), r = n.get(Y), s = n.get(L), { unitId: i } = e, a = o.getRenderById(i);
    if (a == null)
      return !1;
    const { scene: c } = a, d = c.getTransformerByCreate(), l = a.with(de), A = a.with(Re), h = l == null ? void 0 : l.getSkeleton(), u = l == null ? void 0 : l.getViewModel();
    return u == null || h == null ? !1 : (r.replaceDocRanges([]), d.clearSelectedObjects(), A.setSegment(""), A.setSegmentPage(-1), u.setEditArea(ve.BODY), h.calculate(), (g = a.mainComponent) == null || g.makeDirty(!0), queueMicrotask(() => {
      const f = s.getUnit(i), p = f == null ? void 0 : f.getSnapshot();
      if (p == null)
        return;
      const m = dc(p);
      r.replaceDocRanges([
        {
          startOffset: m,
          endOffset: m
        }
      ]);
    }), t.executeCommand(Ts.id, { value: "close" }), !0);
  }
}, uc = "UI_PLUGIN_DOCS", hc = (n) => {
  const { value: e, onChange: t, options: o } = n;
  return /* @__PURE__ */ Q("div", { className: "univer-grid univer-grid-cols-3 univer-gap-2 univer-p-1.5", children: o.map((r) => /* @__PURE__ */ Q(
    "a",
    {
      className: ze("univer-block univer-h-20 univer-w-[72px] univer-cursor-pointer univer-overflow-hidden univer-rounded univer-transition-all hover:univer-border-primary-500", Nn, {
        "univer-border-primary-500": e === r.value
      }),
      onClick: () => {
        t(r.value);
      },
      children: /* @__PURE__ */ Q(
        "img",
        {
          className: "univer-size-full",
          src: r.img,
          draggable: !1
        }
      )
    },
    r.value
  )) });
}, JA = [
  {
    value: ye.ORDER_LIST,
    img: "data:image/jpeg;base64,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"
  },
  {
    value: ye.ORDER_LIST_1,
    img: "data:image/jpeg;base64,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"
  },
  {
    value: ye.ORDER_LIST_2,
    img: "data:image/jpeg;base64,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"
  },
  {
    value: ye.ORDER_LIST_3,
    img: "data:image/jpeg;base64,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"
  },
  {
    value: ye.ORDER_LIST_4,
    img: "data:image/jpeg;base64,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"
  },
  {
    value: ye.ORDER_LIST_5,
    img: "data:image/jpeg;base64,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"
  }
], $A = (n) => /* @__PURE__ */ Q(
  hc,
  {
    ...n,
    options: JA
  }
), eu = [
  {
    value: ye.BULLET_LIST,
    img: "data:image/jpeg;base64,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"
  },
  {
    value: ye.BULLET_LIST_1,
    img: "data:image/jpeg;base64,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"
  },
  {
    value: ye.BULLET_LIST_2,
    img: "data:image/jpeg;base64,/9j/4AAQSkZJRgABAgEA2ADYAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/CABEIAPQA2AMBEQACEQEDEQH/xAA1AAEAAQUBAQEAAAAAAAAAAAAACgYHCAkLBQMEAQEAAwEBAQAAAAAAAAAAAAAAAwQFAgEG/9oADAMBAAIQAxAAAACfwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY8d832469EAAAAAAAAAAAGsueOJbo1p/8Aj3fuAAAAAAAAAACkPWuaeOJvoVp5OTcuPz6BiSAAAAAAAVcZEAAHO72aObsXc2fLtgCiwAAAAAAD9pU4ABaDry3vXmUMfQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAh26VXVVYjmyZdvYHD2AAAAAAAAAABq1sR8mD6HNEielP0wsO+KYLFAAAAAFTl9QAAAYrSc8hn6PMtL15MozLU8HJuDzChAAAAAD1CugAAADC6XjX9NxvBqTeiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYRS8R1rsEwbNtAAAAAAAAAAADCmXjlk7+fhFLxN7y7c27KtinyzoABUJeEAAAAAAFg++eXXvZ+rSxH0Nsa9Klz7A8UtiAAe0XOAAAAAAALB986RbUUjalOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABaXryFlqVJx+Vc9jwAAAAAAAAAAAIXepVkMUptlkEgFlwAAAAAAD2i5wAKQ9c7Tao3j496C+PdAGPoAAAAAABUJeEAA1G2Yqb9blqsoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH/xAAoEAABBAMAAgEDBAMAAAAAAAAGAAUHFwQICQoWECBAYAIDFTABGFD/2gAIAQEAAQgA/wC3J+3ep8JEuMFzOzvDQQtDW/sH3HXTfTB516PyhO+DwK5Fue+8iP3RPenFxcbCxsfDw/tpAN2KMwM0kco0C7EaQ9H3MiFoE6yS4T9mOyMLc9oXh+JgKB4sj2GIt+fZCJeyES9kIl7IRL2QiXshEvZCJeyES9kIl7IRL2QiXshEvZCJeyES9kIkCvbzmFTXj5f099uZh1zk2VYt/NOvEf07/c/V+zsLvmYfRXgeq8D1Xgeq8D1Xgeq8D1Xgeq8D1Xgeq8D1Xgeq8D1Xgeq8D1Xgem4NG2rM/Zz8D6Z9gmMNm4bkOBpm0v1SAdIdYIg1djT8u6ZeUuzwrIhVB+hkS+WF0QEDDHc5V5y9Itf+mEIfql+Evt+104l+unLPciUwL48XubyqNOqILGLT8GTjmNQ25Z+BYZgrDMFYZgrDMFYZgrDMFYZgrDMFYZgrDMFYZgg0yJHUkbcDP/o3h1jZ9y9R9gdYXmdYMlPWuWjmD5qXinc8jpxlol6HSJ8PLTjvjbkteXVA6qoHVVA6qoHVVA6qoHVVA6qoHVVA6qoHVVA6maPmZjcsZ0xP6du+eOme9rPgte0cT+OHyZikoxSz/DOztA81NrEwfl+/m/kCc6YEep0nTk35MH+xc9ksGbz/AHG/W+UG87NeyDYCcd/N/J76LT29TpOi8f7vdk5uSBaF7tfBU7ZDGw57piWuRK1yJWuRK1yJWuRIVkF5fH7Aa8v+7ZvWSFtwIWM4Bn7q5yjmnl9NP6holbGxye3JvZmbg1wabdRW0b2828+CFn/nmfMaVUKqFVCqhVQoejj+BeMN2+w2b1khbcCFjOAZ+5XePFC3PmaTafpJ/IZ4m6O9bYakyepZ1X6x9pevW6mbHunY7gOTUPsbW8/ceUju2Sm5BDfKmB+UHPQO5u6hAsKt3zbyt5W8reVvK3lbyt5W8reVvK3lbyt5W8h6R/554w2n6ZADG+RwM0j52ZNod8/G/wB6TWAi/wAfuIj3pR1WmfojsP8ARVBEqoIlVBEqoIlVBEqoIlVBEqoIlVBEqoIlVBEqoIlVBEqoIlVBEhWPnljfsB0y/p7JcwxTppq05hmBwh0Ue9DefUfBUhfk/wD/xAA6EAABBAECAwYEAgkEAwAAAAAEAgMFBgEABxITpREUlNTV5QgVldMQIBYhIiMkMDNAYBc0VHIYUHP/2gAIAQEACT8A/wDd/E98PG0dxNQK6HU9z96ttqDZS2juHITg0Fa7LEyj6DMLR3VbQq0kcaeVlfFjtlI6cgpyOBmISbhzhpOImIiTGaNjZSLkgnXw5COkA32SwThHnhixnmn2HXGnELz/AHBEcrdKTQxtxsTESLbJTMtu5bxzW4It6PfzhqRjqdGBzV/mo91TTcjD1U2Mw8gg4fChpjcradq6S0lSYLcEouaJ+IzdgWUy9Y7ne3ZbvBFm26q8th8M0Mpx0G8XFsuFk3H4Ks2ODmx2BAxGGhRBBWmxxhRh20tMDjsNJQ0ywy0hLbTTaUtttpShCcJxjGP7bEvmtUGqWG52HEBAzNpnMwlYiS5qV+T1qugyc/YJPuIT/cYaFjjpSSJ5YYAhBLzbSrvOQW49b55T21O68ZFUzcOYgR+LmWqrRAk/PA2iAYwntkXYSVNkIDDgqrHHQ6T4/JVlKJ2U2lvatpFTMCS0bF/PhFLn/iX3eYay5mOkl0atV+Ur0Jh5To5qKE87FEYbtTiXoEasbd7X1CCpFOghu1aQIGux7EcCl8hfa8ce+2x3qTky1OnSsk+VJHvvmlPvOfjPzX1Q77+p+a+qHff1PzX1Q77+p+a+qHff1PzX1Q77+p+a+qHff1PzX1Q77+p+a+qHff1PzX1Q77+p+a+qHff1PzX1Q77+p+a+qHff1PzX1Q77+p+a+qHff1PzX1Q77+peUKHc79zGCDy32V8EcYtHG066pCuFaUrTxJzwqSlWOzOMZ/MRY9t9ndx7vibbkdsyTasd8OO+JaXjHwIQ6BfGIr9PvakyMzUXQlCx0PIrnqRhgCLRVxZQHnkHv/8Aj7tOWakYh7PAuJuW7lhbyQh41t8h5yiQEdKjuDcxCLlHOrKw68hj8kR1CU87qI6hKed1EdQlPO6iOoSnndRHUJTzuojqEp53UR1CU87qI6hKed1EdQlPO6iOoSnndRHUJTzuojqEp53UR1CU87qI6hKed1EdQlPO6jeQWxzOU73w93g5rS2XP3bxTjSuJpxaf2kZ7O3tx2KxjOPy1kO3ba7nVs6s2eGLaZWvu5SUuBysW+8y/wDLLDASLQc7W5phvvsHPR0dLgrbMCZcSSZJVbaetrisTskOKLKWeelZM+xWy1SQ4eMDjmWS0S8vMuCNLeQCgxsFsh9sZDqv8uodN3YmKcefX7PvzuI5Jn7bKsAD7Q54m3NXrspDSFyj455JwKrdJT8RCmSI3PhIuxwChJeRo3w/7wUl0ptUtU26lNbeTKAMP4ceYrNugZ49qIOW1jI7J1grVyGZQrjcjCHcYXomRh5ivHDwO6G11mUIm57aWYll18UKWwE46JJwc2OOQdVbRHKzHzoTBTS2o6ci52DiP7cwyNtgu3ETRoiVjlZbkYZW8F9qOz5k3HEJWhwM+Fj72XKBHsLSTHlCNGjZwQO3+Jbuax8Rm2u6+39ujFvv9yc/QuiTu80BM4ESru65aMkNuXYwE15GXRIywzorDiEyJCHvwe5BbHc+U7y2neDmnisufu3kONK4mnFp/aRns7e3HYrGM4l+nxfktS/T4vyWpfp8X5LUv0+L8lqX6fF+S1L9Pi/Jal+nxfktS/T4vyWpfp8X5LUv0+L8lqX6fF+S1Jc8R/vnNa7mA1x8oAp5v94yK26nhdbQr9leO3s7M9qc5xn+QULHJ3h22nK1CzBzbzwNfubKWpmg2Ywcf+IJFrF4i69YCBWex0pmNWO2pKnMKxT5Wi7l7dzhMDZq7LMLadZfZ7HBjwH8pwzJwcwE4PLQM2Ct6Nm4cwKUjiCAi2Hl6r0jA7d1Gq2PbvYR+TFeCVerlaeKDu9xg8vN4UZWahW2pmnuSDSe5SdhsxogRjhVUmRW/wAFvtjlcnmLHU2h7HIfaIRwKdbeRjtWynCuJtXanKsY7M5wrBs14gH07Rs14gH07Rs14gH07Rs14gH07Rs14gH07Rs14gH07Rs14gH07Rs14gH07Rs14gH07Rs14gH07Rs14gH07RMo4QLzuWgh4RbOeew6OvjS0EyvPYh5WU8LiexWE5z24xlOf5Ow9Q3LNhxnRa/b1Zk6xuFXB3cuOd1hNwakfB28OM7y5312CzMO180xtp6RijMt4xrYCY3JOAfUQBGbsbi2+5VdhxSeHCSqpmRj69OMITlXCLZI6ZGypXGtpbiGlNxcdBwcMCLGRENDgjRkVFRoLKBwo+NjgmmBAQRB222BRBWWmB2UIaabQhKU4/y+a/5EVt9t9FEDfpnunc+7KeCqlUCeV/0InJwhHyqtRXMkpJz/AGwxYlI2s/1Tu5ZPw+bhQSPlFMqvzclDMLszfDTXf/iPV9xZBbHzKVfejbIkTvcYUz/cST6gx3/kNFpEQppVq3MvhYRhkPTK0y72tNvlNBFGSkuXhMdAQwh0qcpSR2xyJr/kRW3u3sUQT+hm1lM7yp4Kq1UJ5X/QicnCEfNbLK8ySknP9qKJq2PlllvxVM+HHfiwFOEEkkkOMxte2i3Nk31LdefedWNFUG5mOKcccULWLC8pSouS/FDLhAvdeWghLi2c88wcdfGlpxleexDysp4XE9isJzntxjKchQvhzvUdBQvhzvUdBQvhzvUdBQvhzvUdBQvhzvUdDRjY5XeuYsdktD2OQGQQjgU6a8jHatlOFcTau1OVYx2ZzhWP51MBu+3F3ByOcCRjDMlDyTOFqirPWJVKFFQFpgClYNhZoLKSBCE5bcw+G+UKQk677E3c48jZTescDLMbZ41nOX11izoYwoWA3FgBVITNQqlpHkh0pnoFT8W+tAUedLzEucJGRUVGCEHyUnJHkNigx8eCK26UacaU60MIIM06QSQ62yy2txaU5rYMv8UsuC1J7cbcSbQ58b8PMaeP2tyEg3nmim7wmiu5QWWjLo9DHdci4txc4uQkGPwI7p3vu/8AEcnn8vkFME/0uazxcXJ4P6ieHi4v19nDmw9J9z1Yek+56sPSfc9WHpPuerD0n3PUz3vuneP4f5dyOZzxXxv6vfnuHh53H/TVxcPD+rt4sfz6YDd9uLuDkc4EjGGZKHkmcLVFWesSqUKKgLTAFKwbCzQWUkCEJy25h8N8oUi3g/EHuPE2mWH+HY6TgcARu19JXnKY6zyEURzRTd4TRXXAi5sTGYmuDtuOVlKDJJ4oX/IZn5BtztPT5q7W2SQ2kgvEZDCrI7jFh5cazIzksRhiJgYlpxJEtMnARo3aQU1jN5pPwp7FwRjViuhbW0u3G5sFtVtamT7qEbdrLuPVJ6bue4E+02sCIgKudSmrPMpOejw6rW4qbm4OdKtMxGw8YBLWY4KMjTrHJBhMDnTpkdCiAQwBUuU27IEBRIIUYK8QtgAQcVtplH9w2dY7tuLY6Jdd3oavPc+SnJidmEgbHbN90RngeOnLA+Dfzo8hTTqX2NtTB18osjGRIozdOcFDuu/t1BQl5227qSoA+ZgcaRU20QTVqejhqlNaU0K1mGjcTDoI8xOTLpP417q3tmq91b2zVe6t7ZqvdW9s1Xure2ar3VvbNV7q3tmq91b2zVe6t7ZqvdW9s1Xure2ar3VvbNV7q3tmq91b2zVe6t7ZqG7p3vvH8R8x5/L5Ar5P9LuLPFxcng/qJ4eLi/X2cOfySdkhYu81Sw1CSmKbYZSo26KBskSXDlyVXtUI+LMVuwgsGLJhpyLJYPipBoc4R1DzCM4mLDvr8Nk3L/paLSrhIGgVbejbiZeKRC7nbeTZ7E87t7uGMpJMTa8w+JGKXaYiTg7MBZQ4+DlWErsuNmpEvd2QKdEYcgSN7txHJGC2qrgQ5bmXB4fbusx1gnqsyBh5dbJo9HYdWwy4L3j8hsL4g707RsL4g707RsL4g707RsL4g707RsL4g707RsL4g707RsL4g707RsL4g707RsL4g707RsL4g707RsL4g707RsL4g707RsL4g707RsL4g707RsL4g707RMY4OL3rmIHeLW9nnhkDo4EuhMoz2LeTlXE4nsThWcducYTn8rMVD/EHtkiUt/w+3kxlpChLNkVtUnQZk7Lo62KfuQOEJDS7jjyx4WWYr9tUGe5XER5dbdrO9260vLby7yxZ7ISZeEsFnSKDWage6Mlb7btUosTWgZGLKKJ+W2l6z5a7v3p1hH+T/wD/xAA3EQACAQEFBQQIBQUAAAAAAAABAhEDBCExQVEAEkBhgSIycZEFEBNCYHKxwSNSodHwUGKCkuL/2gAIAQIBAT8A/ra06jCVpuw1VWI8wI2IIJBEEXEHEHQ8TZqPtqqp7vec6KMfO5RzM7Wy0iiooUey0AErduLFwGjEeQ5kEcOoLEKMWIAkgCSYEk3DxN21azVaEFwCp95ZKg6EwIPjjltZ1FlszVnHaYb0HGMEXqTJ8eWzMXYsxlmJJPM8TY64r0zRqwzKI7V++nOcSMD0Ou3pGr3KI+dvoo01PlxSO1NldTDKZH7HkcCMxtVqGrUao1xY4DIAQB0AA+L6FgLqHrErN4Qd6P7iZidImMSDcG9HUSIUup1kN5gi/oRtWoPQfdfA3qwwYcuYzGXhBPD2VA9opKcN4nx3QWjrHrt6BrOWzRlI6kKena/QcRSqeyqJU/KwJGowI6iRsjrUUOhlWEg/zAjMZH1ekKy7ooqZYkM/IC8DxJg+A58TTrVaR/DcrOIxU+KmR1idmttoYRv7vyqAfOJHQjbG8/GFGi9ZwiDxOSjU/YZ7Wiw7iB6UtujtqbyYxYfddMOJo0XrOETxJOCjMn9szdtRopQQIg+Zs2Op+wy9VssmNakNS6D9WX6kdRxFOo1Ng6GGH8g6g5jaz2hbQsi5x3l05jVTkcsDthebgMTta7X7WadMxTHeb8//AD9cTxNOo1Ng6GGH8g6g5ja0W16yhFG4sDfg946fLyzz+IkRnZUUSzEAdfsMSchtUs9ls1IGqDUc3DtMpZoyAIAUamYGMmATeSQIE3DTlffdz4mwUgA1oe4KCFJwAA7bdBd/ttaKxr1C57ouQaLl1OJ58gOIU7pDXGCDBEgwZvGY1Gexp0bbSDgBKgESMVYe6wzXMTfBkRftbGFCzrRS7e7PPdW9j/kYB1k8VZq5oVJ9xoDjlqOa4jW8Z7WuqK1ZiplFAVcYIGJ6mfER8Uf/xAAzEQEAAQICBwYFAwUAAAAAAAABAgMRITEAEkBBUWGRBHGBobHBECJg0fAyQlJQctLh8f/aAAgBAwEBPwD+tsomDKI80PXaqs9SDLfkd7l0z8NKNLXdeeJfC/7ni8Q83uTaFsLwx46QqwqYDjwcHvOP5fSotWqQHAbf5Phj00AiAZBY2mtTacteOAu7DVfs7unDTs0f1Tf7T1fbz2pCQiXHP89NIRIRImR/18/q+p2iykAbYMnK/Lj3+pmdpmONk4Wt0T3HSnUjULnibx/Mn3ubRVWNOSZ2t1Q9/j2dSoH8hHwL+20TjrxlHiee58HRGKiWTM+HZ4N9dMASPNyXuDDveTtMoQn+qI89/Ux0KFMb2v3tzp9/rGc4043fA3r+Zu7SlX1m07F35Xccn2eu0zmU46z4HF4aTnKctaXgbg4Hwo1soTeUX2fZ2iUSQxkXH866VKbTeI5Ps8/hRo6vzS/VuP4/79NplEkMZFx/OulOgQWS6zf5eR9/qJSIycgu6RqVas7RSJvwGxzuYvda/Iu6efPae0TvanHNstvKPo9NKcCnEN+cni/YyNoS4nHDDB8HdprToTYuMc7OScTOzx54Y6URqVGbux8XI8MU4WNqq0ypG37jGL7dz9ndpRhqQBLLi+x087/VH//Z"
  },
  {
    value: ye.BULLET_LIST_3,
    img: "data:image/jpeg;base64,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"
  },
  {
    value: ye.BULLET_LIST_4,
    img: "data:image/jpeg;base64,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"
  },
  {
    value: ye.BULLET_LIST_5,
    img: "data:image/jpeg;base64,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"
  }
], tu = (n) => /* @__PURE__ */ Q(
  hc,
  {
    ...n,
    options: eu
  }
), gc = `${uc}_ORDER_LIST_TYPE_COMPONENT`, fc = `${uc}_BULLET_LIST_TYPE_COMPONENT`, nu = (n) => {
  const t = Object.keys(ar).find((o) => {
    const { width: r, height: s } = ar[o];
    return n.width === r && n.height === s;
  });
  return t != null ? t : "A4";
};
function ou(n) {
  const { hooks: e } = n, r = J(L).getCurrentUnitOfType(_.UNIVER_DOC).getDocumentStyle(), s = J(Ye), [i, a] = Ee(() => {
    var l, A, h, u, g;
    return {
      paperSize: nu(r.pageSize),
      orientation: (l = r.pageOrient) != null ? l : Vc.PORTRAIT,
      margins: {
        top: (A = r.marginTop) != null ? A : 0,
        bottom: (h = r.marginBottom) != null ? h : 0,
        left: (u = r.marginLeft) != null ? u : 0,
        right: (g = r.marginRight) != null ? g : 0
      }
    };
  });
  Ce(() => {
    e.beforeClose = () => i, e.beforeConfirm = () => i;
  }, [i]);
  const c = (l) => {
    a((A) => ({ ...A, paperSize: l }));
  }, d = (l, A) => {
    a((h) => ({
      ...h,
      margins: {
        ...h.margins,
        [l]: A || 0
      }
    }));
  };
  return /* @__PURE__ */ re("div", { className: "univer-flex univer-flex-col univer-gap-4", children: [
    /* @__PURE__ */ re("div", { className: "univer-flex univer-flex-col univer-gap-2", children: [
      /* @__PURE__ */ Q(
        "label",
        {
          className: "univer-text-sm univer-font-medium univer-text-gray-900 dark:!univer-text-white",
          children: s.t("page-settings.paper-size")
        }
      ),
      /* @__PURE__ */ Q(
        fa,
        {
          value: i.paperSize,
          onChange: c,
          options: Wc.map((l) => ({
            label: s.t(`page-settings.page-size.${l.toLocaleLowerCase()}`),
            value: l
          }))
        }
      )
    ] }),
    /* @__PURE__ */ re("div", { className: "univer-flex univer-flex-col univer-gap-2", children: [
      /* @__PURE__ */ Q(
        "label",
        {
          className: "univer-text-sm univer-font-medium univer-text-gray-900 dark:!univer-text-white",
          children: s.t("page-settings.custom-paper-size")
        }
      ),
      /* @__PURE__ */ re("div", { className: "univer-flex univer-flex-col univer-gap-2.5", children: [
        /* @__PURE__ */ re("div", { className: "univer-flex univer-gap-2.5", children: [
          /* @__PURE__ */ re("div", { className: "univer-flex univer-flex-1 univer-flex-col univer-gap-2", children: [
            /* @__PURE__ */ Q("label", { className: "univer-text-sm univer-font-medium univer-text-gray-500", children: s.t("page-settings.top") }),
            /* @__PURE__ */ Q(
              it,
              {
                value: i.margins.top,
                onChange: (l) => d("top", l)
              }
            )
          ] }),
          /* @__PURE__ */ re("div", { className: "univer-flex univer-flex-1 univer-flex-col univer-gap-2", children: [
            /* @__PURE__ */ Q("label", { className: "univer-text-sm univer-font-medium univer-text-gray-500", children: s.t("page-settings.bottom") }),
            /* @__PURE__ */ Q(
              it,
              {
                value: i.margins.bottom,
                onChange: (l) => d("bottom", l)
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ re("div", { className: "univer-flex univer-gap-2.5", children: [
          /* @__PURE__ */ re("div", { className: "univer-flex univer-flex-1 univer-flex-col univer-gap-2", children: [
            /* @__PURE__ */ Q("label", { className: "univer-text-sm univer-font-medium univer-text-gray-500", children: s.t("page-settings.left") }),
            /* @__PURE__ */ Q(
              it,
              {
                value: i.margins.left,
                onChange: (l) => d("left", l)
              }
            )
          ] }),
          /* @__PURE__ */ re("div", { className: "univer-flex univer-flex-1 univer-flex-col univer-gap-2", children: [
            /* @__PURE__ */ Q("label", { className: "univer-text-sm univer-font-medium univer-text-gray-500", children: s.t("page-settings.right") }),
            /* @__PURE__ */ Q(
              it,
              {
                value: i.margins.right,
                onChange: (l) => d("right", l)
              }
            )
          ] })
        ] })
      ] })
    ] })
  ] });
}
const Rr = "docs.component.page-setting", pc = {
  id: "docs.command.page-setup",
  type: D.COMMAND,
  // eslint-disable-next-line complexity, max-lines-per-function
  handler: (n, e) => {
    if (!e) return !1;
    const t = n.get(L), o = n.get(T), r = t.getCurrentUnitOfType(_.UNIVER_DOC);
    if (!r) return !1;
    const { marginLeft: s, marginRight: i, marginBottom: a, marginTop: c, pageOrient: d, pageSize: l } = e, A = W.getInstance(), h = r.getDocumentStyle(), {
      marginBottom: u,
      marginLeft: g,
      marginRight: f,
      marginTop: p,
      pageOrient: m,
      pageSize: I
    } = h, S = [];
    if (u === void 0) {
      const E = A.insertOp(["documentStyle", "marginBottom"], a);
      E && S.push(E);
    } else {
      const E = A.replaceOp(["documentStyle", "marginBottom"], u, a);
      E && S.push(E);
    }
    if (g === void 0) {
      const E = A.insertOp(["documentStyle", "marginLeft"], s);
      E && S.push(E);
    } else {
      const E = A.replaceOp(["documentStyle", "marginLeft"], g, s);
      E && S.push(E);
    }
    if (f === void 0) {
      const E = A.insertOp(["documentStyle", "marginRight"], i);
      E && S.push(E);
    } else {
      const E = A.replaceOp(["documentStyle", "marginRight"], f, i);
      E && S.push(E);
    }
    if (p === void 0) {
      const E = A.insertOp(["documentStyle", "marginTop"], c);
      E && S.push(E);
    } else {
      const E = A.replaceOp(["documentStyle", "marginTop"], p, c);
      E && S.push(E);
    }
    if (I === void 0) {
      const E = A.insertOp(["documentStyle", "pageSize"], l);
      E && S.push(E);
    } else {
      const E = A.replaceOp(["documentStyle", "pageSize"], I, l);
      E && S.push(E);
    }
    if (m === void 0) {
      const E = A.insertOp(["documentStyle", "pageOrient"], d);
      E && S.push(E);
    } else {
      const E = A.replaceOp(["documentStyle", "pageOrient"], m, d);
      E && S.push(E);
    }
    const v = {
      id: X.id,
      params: {
        unitId: r.getUnitId(),
        actions: [],
        textRanges: void 0
      }
    };
    return v.params.actions = S.reduce((E, b) => W.compose(E, b), null), !!o.syncExecuteCommand(v.id, v.params);
  }
}, _s = {
  id: "docs.operation.open-page-setting",
  type: D.OPERATION,
  handler: (n) => {
    const e = n.get(aa), t = n.get(T), o = n.get(Ye), r = e.open({
      id: Rr,
      title: {
        label: o.t("page-settings.document-setting")
      },
      children: {
        label: Rr
      },
      width: 528,
      onClose: () => {
        r.dispose();
      },
      onConfirm: (s) => {
        if (r.dispose(), !s) return;
        const i = ar[s.paperSize];
        t.executeCommand(pc.id, {
          pageOrient: s.orientation,
          marginTop: s.margins.top,
          marginBottom: s.margins.bottom,
          marginLeft: s.margins.left,
          marginRight: s.margins.right,
          pageSize: i
        });
      },
      confirmText: o.t("page-settings.confirm"),
      cancelText: o.t("page-settings.cancel")
    });
    return !0;
  }
};
function ru(n) {
  const e = n.get(L), t = n.get(pe);
  return new fe((o) => {
    const r = e.focused$.subscribe((s) => {
      if (s == null || e.getUnitType(s) !== _.UNIVER_DOC)
        return o.next(!0);
      const a = t.getRenderById(s);
      if (a == null)
        return o.next(!0);
      a.with(de).getViewModel().editAreaChange$.subscribe((d) => {
        o.next(d === ve.HEADER || d === ve.FOOTER);
      });
    });
    return () => r.unsubscribe();
  });
}
function su(n) {
  const e = n.get(L), t = n.get(T);
  return new fe((o) => {
    const r = t.onCommandExecuted((c) => {
      if (c.id === X.id) {
        const { unitId: d } = c.params, l = e.getUnit(d);
        if (l == null) {
          o.next(!0);
          return;
        }
        const { documentStyle: A } = l.getSnapshot();
        o.next((A == null ? void 0 : A.documentFlavor) !== Pe.TRADITIONAL);
      }
    }), s = e.focused$.subscribe((c) => {
      if (c == null)
        return o.next(!0);
      const d = e.getUniverDocInstance(c), l = d == null ? void 0 : d.getSnapshot().documentStyle.documentFlavor;
      o.next(l !== Pe.TRADITIONAL);
    }), i = e.getCurrentUniverDocInstance();
    if (i == null)
      return o.next(!0);
    const a = i == null ? void 0 : i.getSnapshot().documentStyle.documentFlavor;
    return o.next(a !== Pe.TRADITIONAL), () => {
      r.dispose(), s.unsubscribe();
    };
  });
}
function iu(n) {
  const e = n.get(Y), t = n.get(L);
  return new fe((o) => {
    const r = e.textSelection$.subscribe((s) => {
      if (s == null) {
        o.next(!0);
        return;
      }
      const { textRanges: i } = s;
      if (i.length !== 1) {
        o.next(!0);
        return;
      }
      const a = i[0], { collapsed: c, startNodePosition: d, startOffset: l } = a;
      if (!c || l == null) {
        o.next(!0);
        return;
      }
      const A = t.getCurrentUniverDocInstance();
      if (A == null) {
        o.next(!0);
        return;
      }
      const h = Ke(n, A.getUnitId());
      if (h == null) {
        o.next(!0);
        return;
      }
      if (h.getViewModel().getCustomRangeRaw(l)) {
        o.next(!0);
        return;
      }
      if (d != null) {
        const { path: f } = d;
        if (f.indexOf("cells") !== -1) {
          o.next(!0);
          return;
        }
      }
      o.next(!1);
    });
    return () => r.unsubscribe();
  });
}
function xe(n) {
  const e = n.get(Y);
  return new fe((t) => {
    const o = e.textSelection$.subscribe((r) => {
      if (r == null) {
        t.next(!0);
        return;
      }
      const { textRanges: s, rectRanges: i } = r;
      if (s.length === 0 && i.length === 0) {
        t.next(!0);
        return;
      }
      t.next(!1);
    });
    return () => o.unsubscribe();
  });
}
function au(n) {
  const e = n.get(T);
  return {
    id: Qt.id,
    type: Z.BUTTON,
    icon: "BoldIcon",
    title: "Set bold",
    tooltip: "toolbar.bold",
    activated$: new fe((t) => {
      const o = () => {
        var a;
        const s = ot(n);
        if (s == null) {
          t.next(!1);
          return;
        }
        const i = (a = s.ts) == null ? void 0 : a.bl;
        t.next(i === z.TRUE);
      }, r = e.onCommandExecuted((s) => {
        const i = s.id;
        (i === Le.id || i === yt.id) && o();
      });
      return o(), r.dispose;
    }),
    disabled$: xe(n),
    hidden$: se(n, _.UNIVER_DOC)
  };
}
function cu(n) {
  const e = n.get(T);
  return {
    id: Ut.id,
    type: Z.BUTTON,
    icon: "ItalicIcon",
    title: "Set italic",
    tooltip: "toolbar.italic",
    activated$: new fe((t) => {
      const o = () => {
        var a;
        const s = ot(n);
        if (s == null) {
          t.next(!1);
          return;
        }
        const i = (a = s.ts) == null ? void 0 : a.it;
        t.next(i === z.TRUE);
      }, r = e.onCommandExecuted((s) => {
        const i = s.id;
        (i === Le.id || i === yt.id) && o();
      });
      return o(), r.dispose;
    }),
    disabled$: xe(n),
    hidden$: se(n, _.UNIVER_DOC)
  };
}
function lu(n) {
  const e = n.get(T);
  return {
    id: Ft.id,
    type: Z.BUTTON,
    icon: "UnderlineIcon",
    title: "Set underline",
    tooltip: "toolbar.underline",
    activated$: new fe((t) => {
      const o = () => {
        var a;
        const s = ot(n);
        if (s == null) {
          t.next(!1);
          return;
        }
        const i = (a = s.ts) == null ? void 0 : a.ul;
        t.next((i == null ? void 0 : i.s) === z.TRUE);
      }, r = e.onCommandExecuted((s) => {
        const i = s.id;
        (i === Le.id || i === yt.id) && o();
      });
      return o(), r.dispose;
    }),
    disabled$: xe(n),
    hidden$: se(n, _.UNIVER_DOC)
  };
}
function du(n) {
  const e = n.get(T);
  return {
    id: Ht.id,
    type: Z.BUTTON,
    icon: "StrikethroughIcon",
    title: "Set strike through",
    tooltip: "toolbar.strikethrough",
    activated$: new fe((t) => {
      const o = () => {
        var a;
        const s = ot(n);
        if (s == null) {
          t.next(!1);
          return;
        }
        const i = (a = s.ts) == null ? void 0 : a.st;
        t.next((i == null ? void 0 : i.s) === z.TRUE);
      }, r = e.onCommandExecuted((s) => {
        const i = s.id;
        (i === Le.id || i === yt.id) && o();
      });
      return o(), r.dispose;
    }),
    disabled$: xe(n),
    hidden$: se(n, _.UNIVER_DOC)
  };
}
function Au(n) {
  const e = n.get(T);
  return {
    id: bt.id,
    type: Z.BUTTON,
    icon: "SubscriptIcon",
    tooltip: "toolbar.subscript",
    activated$: new fe((t) => {
      const o = () => {
        var a;
        const s = ot(n);
        if (s == null) {
          t.next(!1);
          return;
        }
        const i = (a = s.ts) == null ? void 0 : a.va;
        t.next(i === Ve.SUBSCRIPT);
      }, r = e.onCommandExecuted((s) => {
        const i = s.id;
        (i === Le.id || i === yt.id) && o();
      });
      return o(), r.dispose;
    }),
    disabled$: xe(n),
    hidden$: se(n, _.UNIVER_DOC)
  };
}
function uu(n) {
  const e = n.get(T);
  return {
    id: kt.id,
    type: Z.BUTTON,
    icon: "SuperscriptIcon",
    tooltip: "toolbar.superscript",
    activated$: new fe((t) => {
      const o = () => {
        var a;
        const s = ot(n);
        if (s == null) {
          t.next(!1);
          return;
        }
        const i = (a = s.ts) == null ? void 0 : a.va;
        t.next(i === Ve.SUPERSCRIPT);
      }, r = e.onCommandExecuted((s) => {
        const i = s.id;
        (i === Le.id || i === yt.id) && o();
      });
      return o(), r.dispose;
    }),
    disabled$: xe(n),
    hidden$: se(n, _.UNIVER_DOC)
  };
}
function hu(n) {
  const e = n.get(T);
  return {
    id: _t.id,
    tooltip: "toolbar.font",
    type: Z.SELECTOR,
    label: Ol,
    selections: [{
      label: {
        name: xl,
        hoverable: !1,
        selectable: !1,
        props: {
          id: _t.id
        }
      }
    }],
    // disabled$: getCurrentSheetDisabled$(accessor),
    value$: new fe((t) => {
      const o = xo.ff, r = () => {
        var c;
        const i = ot(n);
        if (i == null) {
          t.next(o);
          return;
        }
        const a = (c = i.ts) == null ? void 0 : c.ff;
        t.next(a != null ? a : o);
      }, s = e.onCommandExecuted((i) => {
        const a = i.id;
        (a === Le.id || a === _t.id) && r();
      });
      return r(), s.dispose;
    }),
    disabled$: xe(n),
    hidden$: se(n, _.UNIVER_DOC)
  };
}
function gu(n) {
  const e = n.get(T);
  return {
    id: ct.id,
    type: Z.SELECTOR,
    tooltip: "toolbar.fontSize",
    label: {
      name: Bl,
      props: {
        min: 1,
        max: 400
        // disabled$,
      }
    },
    selections: Tl,
    // disabled$,
    value$: new fe((t) => {
      const o = xo.fs, r = () => {
        var c;
        const i = ot(n);
        if (i == null) {
          t.next(o);
          return;
        }
        const a = (c = i.ts) == null ? void 0 : c.fs;
        t.next(a != null ? a : o);
      }, s = e.onCommandExecuted((i) => {
        const a = i.id;
        (a === Le.id || a === ct.id) && r();
      });
      return r(), s.dispose;
    }),
    disabled$: xe(n),
    hidden$: se(n, _.UNIVER_DOC)
  };
}
function fu(n) {
  const e = n.get(T);
  return {
    id: Xe.id,
    type: Z.SELECTOR,
    tooltip: "toolbar.heading.tooltip",
    label: {
      name: Ml,
      props: {
        selections: Gs
      }
    },
    selections: Gs.map((t) => ({
      label: {
        name: _l,
        props: {
          value: t.value,
          text: t.label
        }
      },
      value: t.value
    })),
    value$: new fe((t) => {
      const o = K.NORMAL_TEXT, r = () => {
        var c, d;
        const i = Vt(n);
        if (i == null) {
          t.next(o);
          return;
        }
        const a = (d = (c = i.paragraphStyle) == null ? void 0 : c.namedStyleType) != null ? d : o;
        t.next(a);
      }, s = e.onCommandExecuted((i) => {
        const a = i.id;
        (a === Le.id || a === ct.id) && r();
      });
      return r(), s.dispose;
    }),
    disabled$: xe(n),
    hidden$: se(n, _.UNIVER_DOC)
  };
}
function pu(n) {
  const e = n.get(T), t = n.get(Ur);
  return {
    id: mt.id,
    icon: "FontColorDoubleIcon",
    tooltip: "toolbar.textColor.main",
    type: Z.BUTTON_SELECTOR,
    selections: [
      {
        label: {
          name: la,
          hoverable: !1,
          selectable: !1
        },
        value$: new fe((o) => {
          const r = xo.cl.rgb, s = () => {
            var d, l;
            const a = ot(n);
            if (!a) {
              o.next(r);
              return;
            }
            const c = (l = (d = a.ts) == null ? void 0 : d.cl) == null ? void 0 : l.rgb;
            o.next(c != null ? c : r);
          }, i = e.onCommandExecuted((a) => {
            a.id === mt.id && s();
          });
          return s(), i.dispose;
        })
      }
    ],
    value$: new fe((o) => {
      const r = t.getColorFromTheme("gray.900"), s = e.onCommandExecuted((i) => {
        if (i.id === mt.id) {
          const a = i.params.value;
          o.next(a != null ? a : r);
        }
      });
      return o.next(r), s.dispose;
    }),
    disabled$: xe(n),
    hidden$: se(n, _.UNIVER_DOC)
    // disabled$: getCurrentSheetDisabled$(accessor),
  };
}
function mu(n) {
  return {
    id: Bs.id,
    type: Z.BUTTON,
    icon: "HeaderFooterIcon",
    tooltip: "toolbar.headerFooter",
    hidden$: Pn(se(n, _.UNIVER_DOC, void 0, nt), su(n), (e, t) => e || t)
  };
}
const Eu = "GridIcon", mc = "doc.menu.table";
function Iu(n) {
  return {
    id: mc,
    type: Z.SUBITEMS,
    icon: Eu,
    tooltip: "toolbar.table.main",
    disabled$: iu(n),
    // Do not show header footer menu and insert table at zen mode.
    hidden$: Pn(se(n, _.UNIVER_DOC, void 0, nt), ru(n), (e, t) => e || t)
  };
}
function Su(n) {
  return {
    id: Os.id,
    title: "toolbar.table.insert",
    type: Z.BUTTON,
    hidden$: se(n, _.UNIVER_DOC)
  };
}
function vu(n) {
  const e = n.get(T);
  return {
    id: Qo.id,
    type: Z.BUTTON,
    icon: "LeftJustifyingIcon",
    tooltip: "toolbar.alignLeft",
    disabled$: xe(n),
    activated$: new fe((t) => {
      const o = e.onCommandExecuted((r) => {
        var i;
        const s = r.id;
        if (s === Le.id || s === lt.id) {
          const a = Vt(n);
          if (a == null)
            return;
          const c = (i = a.paragraphStyle) == null ? void 0 : i.horizontalAlign;
          t.next(c === Ue.LEFT);
        }
      });
      return t.next(!1), o.dispose;
    }),
    hidden$: se(n, _.UNIVER_DOC, void 0, nt)
  };
}
function Cu(n) {
  const e = n.get(T);
  return {
    id: Uo.id,
    type: Z.BUTTON,
    icon: "HorizontallyIcon",
    tooltip: "toolbar.alignCenter",
    activated$: new fe((t) => {
      const o = e.onCommandExecuted((r) => {
        var i;
        const s = r.id;
        if (s === Le.id || s === lt.id) {
          const a = Vt(n);
          if (a == null)
            return;
          const c = (i = a.paragraphStyle) == null ? void 0 : i.horizontalAlign;
          t.next(c === Ue.CENTER);
        }
      });
      return t.next(!1), o.dispose;
    }),
    disabled$: xe(n),
    hidden$: se(n, _.UNIVER_DOC, void 0, nt)
  };
}
function Ru(n) {
  const e = n.get(T);
  return {
    id: Fo.id,
    type: Z.BUTTON,
    icon: "RightJustifyingIcon",
    tooltip: "toolbar.alignRight",
    activated$: new fe((t) => {
      const o = e.onCommandExecuted((r) => {
        var i;
        const s = r.id;
        if (s === Le.id || s === lt.id) {
          const a = Vt(n);
          if (a == null)
            return;
          const c = (i = a.paragraphStyle) == null ? void 0 : i.horizontalAlign;
          t.next(c === Ue.RIGHT);
        }
      });
      return t.next(!1), o.dispose;
    }),
    disabled$: xe(n),
    hidden$: se(n, _.UNIVER_DOC, void 0, nt)
  };
}
function bu(n) {
  const e = n.get(T);
  return {
    id: Ho.id,
    type: Z.BUTTON,
    icon: "AlignTextBothIcon",
    tooltip: "toolbar.alignJustify",
    activated$: new fe((t) => {
      const o = e.onCommandExecuted((r) => {
        var i;
        const s = r.id;
        if (s === Le.id || s === lt.id) {
          const a = Vt(n);
          if (a == null)
            return;
          const c = (i = a.paragraphStyle) == null ? void 0 : i.horizontalAlign;
          t.next(c === Ue.JUSTIFIED);
        }
      });
      return t.next(!1), o.dispose;
    }),
    disabled$: xe(n),
    hidden$: se(n, _.UNIVER_DOC, void 0, nt)
  };
}
function yu(n) {
  return {
    id: Po.id,
    type: Z.BUTTON,
    icon: "ReduceIcon",
    tooltip: "toolbar.horizontalLine",
    disabled$: xe(n),
    hidden$: se(n, _.UNIVER_DOC, void 0, nt)
  };
}
const Tn = (n) => new fe((e) => {
  const t = n.get(L), o = n.get(Y);
  let r;
  const s = t.focused$.subscribe((i) => {
    if (r == null || r.unsubscribe(), i == null)
      return;
    const a = t.getUniverDocInstance(i);
    a != null && (r = o.textSelection$.subscribe(() => {
      var l, A, h, u, g;
      const c = o.getDocRanges(), d = (l = c.find((f) => f.isActive)) != null ? l : c[0];
      if (d) {
        const f = a.getSelfOrHeaderFooterModel(d == null ? void 0 : d.segmentId), p = ce.range.getParagraphsInRange(d, (h = (A = f.getBody()) == null ? void 0 : A.paragraphs) != null ? h : [], (g = (u = f.getBody()) == null ? void 0 : u.dataStream) != null ? g : "");
        let m;
        if (p.every((I) => {
          var S;
          return m || (m = (S = I.bullet) == null ? void 0 : S.listType), I.bullet && I.bullet.listType === m;
        })) {
          e.next(m);
          return;
        }
      }
      e.next(void 0);
    }));
  });
  return () => {
    s.unsubscribe(), r == null || r.unsubscribe();
  };
});
function bi(n) {
  return {
    id: On.id,
    type: Z.BUTTON_SELECTOR,
    slot: !0,
    selections: [
      {
        label: {
          name: gc,
          hoverable: !1,
          selectable: !1
        },
        value$: Tn(n)
      }
    ],
    icon: "OrderIcon",
    tooltip: "toolbar.order",
    hidden$: se(n, _.UNIVER_DOC),
    disabled$: xe(n),
    activated$: Tn(n).pipe(wn((e) => !!(e && e.indexOf("ORDER_LIST") === 0)))
  };
}
function yi(n) {
  return {
    id: xn.id,
    type: Z.BUTTON_SELECTOR,
    slot: !0,
    selections: [
      {
        label: {
          name: fc,
          hoverable: !1,
          selectable: !1
        },
        value$: Tn(n)
      }
    ],
    icon: "UnorderIcon",
    tooltip: "toolbar.unorder",
    disabled$: xe(n),
    hidden$: se(n, _.UNIVER_DOC),
    activated$: Tn(n).pipe(wn((e) => !!(e && e.indexOf("BULLET_LIST") === 0)))
  };
}
function xi(n) {
  return {
    id: so.id,
    type: Z.BUTTON,
    icon: "TodoListDoubleIcon",
    tooltip: "toolbar.checklist",
    disabled$: xe(n),
    hidden$: se(n, _.UNIVER_DOC),
    activated$: Tn(n).pipe(wn((e) => !!(e && e.indexOf("CHECK_LIST") === 0)))
  };
}
function xu(n) {
  const e = n.get(T), t = n.get(L);
  return {
    id: ko.id,
    type: Z.BUTTON,
    icon: "KeyboardIcon",
    tooltip: "toolbar.documentFlavor",
    hidden$: se(n, _.UNIVER_DOC, void 0, nt),
    activated$: new fe((o) => {
      var i;
      const r = e.onCommandExecuted((a) => {
        var c;
        if (a.id === X.id) {
          const d = t.getCurrentUnitForType(_.UNIVER_DOC);
          o.next(((c = d == null ? void 0 : d.getSnapshot()) == null ? void 0 : c.documentStyle.documentFlavor) === Pe.MODERN);
        }
      }), s = t.getCurrentUnitForType(_.UNIVER_DOC);
      return o.next(((i = s == null ? void 0 : s.getSnapshot()) == null ? void 0 : i.documentStyle.documentFlavor) === Pe.MODERN), () => r.dispose();
    })
  };
}
function Ou(n) {
  return {
    id: Un.id,
    type: Z.BUTTON,
    title: "toolbar.resetColor",
    icon: "NoColorDoubleIcon"
  };
}
function Tu(n) {
  const e = n.get(T), t = n.get(Ur);
  return {
    id: Et.id,
    tooltip: "toolbar.fillColor.main",
    type: Z.BUTTON_SELECTOR,
    icon: "PaintBucketDoubleIcon",
    selections: [
      {
        label: {
          name: la,
          hoverable: !1,
          selectable: !1
        },
        value$: new fe((o) => {
          const r = xo.bg.rgb, s = () => {
            var d, l;
            const a = ot(n);
            if (!a) {
              o.next(r);
              return;
            }
            const c = (l = (d = a.ts) == null ? void 0 : d.bg) == null ? void 0 : l.rgb;
            o.next(c != null ? c : r);
          }, i = e.onCommandExecuted((a) => {
            a.id === Et.id && s();
          });
          return s(), i.dispose;
        })
      }
    ],
    value$: new fe((o) => {
      const r = t.getColorFromTheme("primary.600"), s = e.onCommandExecuted((i) => {
        if (i.id === Et.id) {
          const a = i.params.value;
          o.next(a != null ? a : r);
        }
      });
      return o.next(r), s.dispose;
    }),
    disabled$: xe(n),
    hidden$: se(n, _.UNIVER_DOC)
  };
}
function ot(n) {
  var g, f, p, m;
  const e = n.get(L), t = n.get(Y), o = n.get(at), r = e.getCurrentUnitForType(_.UNIVER_DOC), s = t.getDocRanges(), i = (g = s.find((I) => I.isActive)) != null ? g : s[0], a = o.getDefaultStyle(), c = (f = o.getStyleCache()) != null ? f : {}, d = Vt(n), l = (p = d == null ? void 0 : d.paragraphStyle) != null && p.namedStyleType ? jc[(m = d == null ? void 0 : d.paragraphStyle) == null ? void 0 : m.namedStyleType] : null;
  if (r == null || i == null)
    return {
      ts: {
        ...a,
        ...l,
        ...c
      }
    };
  const { segmentId: A } = i, h = r.getSelfOrHeaderFooterModel(A).getBody();
  if (h == null)
    return {
      ts: {
        ...a,
        ...l,
        ...c
      }
    };
  const u = Ma(h, i, {});
  return ue.deleteNull(u), {
    ts: {
      ...a,
      ...l,
      ...u,
      ...c
    }
  };
}
function Vt(n) {
  var l, A;
  const e = n.get(L), t = n.get(Y), o = e.getCurrentUniverDocInstance(), r = t.getDocRanges(), s = (l = r.find((h) => h.isActive)) != null ? l : r[0];
  if (o == null || s == null)
    return;
  const { startOffset: i, segmentId: a } = s, c = (A = o.getSelfOrHeaderFooterModel(a).getBody()) == null ? void 0 : A.paragraphs;
  if (c == null)
    return;
  let d = -1;
  for (const h of c) {
    const { startIndex: u } = h;
    if (i > d && i <= u)
      return h;
    d = u;
  }
  return null;
}
function Bu(n) {
  return {
    id: _s.id,
    type: Z.BUTTON,
    icon: "DocumentSettingIcon",
    tooltip: "toolbar.pageSetup",
    hidden$: se(n, _.UNIVER_DOC)
  };
}
const Mu = {
  [K.HEADING_1]: us,
  [K.HEADING_2]: hs,
  [K.HEADING_3]: gs,
  [K.HEADING_4]: fs,
  [K.HEADING_5]: ps,
  [K.NORMAL_TEXT]: io,
  [K.TITLE]: Qa,
  [K.SUBTITLE]: Ua,
  [K.NAMED_STYLE_TYPE_UNSPECIFIED]: io
}, Ec = {
  [K.HEADING_1]: { key: "H1Icon", component: ec },
  [K.HEADING_2]: { key: "H2Icon", component: tc },
  [K.HEADING_3]: { key: "H3Icon", component: nc },
  [K.HEADING_4]: { key: "H4Icon", component: oc },
  [K.HEADING_5]: { key: "H5Icon", component: rc },
  [K.NORMAL_TEXT]: { key: "TextTypeIcon", component: pn },
  [K.TITLE]: { key: "TextTypeIcon", component: pn },
  [K.SUBTITLE]: { key: "TextTypeIcon", component: pn },
  [K.NAMED_STYLE_TYPE_UNSPECIFIED]: { key: "TextTypeIcon", component: pn }
}, xt = (n) => (e) => {
  const t = e.get(T), o = e.get(rn), r = Ec[n];
  return o.get(r.key) || o.register(r.key, r.component), {
    id: Mu[n].id,
    type: Z.BUTTON,
    icon: r.key,
    tooltip: "toolbar.heading.tooltip",
    disabled$: xe(e),
    hidden$: se(e, _.UNIVER_DOC),
    activated$: new fe((s) => {
      const i = K.NORMAL_TEXT, a = () => {
        var A, h;
        const d = Vt(e);
        if (d == null) {
          s.next(i === n);
          return;
        }
        const l = (h = (A = d.paragraphStyle) == null ? void 0 : A.namedStyleType) != null ? h : i;
        s.next(l === n);
      }, c = t.onCommandExecuted((d) => {
        const l = d.id;
        (l === Le.id || l === ct.id) && a();
      });
      return a(), c.dispose;
    })
  };
}, _u = xt(K.HEADING_1), Du = xt(K.HEADING_2), wu = xt(K.HEADING_3), Pu = xt(K.HEADING_4), Nu = xt(K.HEADING_5), Lu = xt(K.NORMAL_TEXT);
xt(K.TITLE);
xt(K.SUBTITLE);
const Qu = (n) => ({
  id: os.id,
  type: Z.BUTTON,
  icon: "CopyDoubleIcon",
  title: "rightClick.copy"
}), Uu = (n) => ({
  id: ss.id,
  type: Z.BUTTON,
  icon: "CutIcon",
  title: "rightClick.cut"
}), Fu = (n) => ({
  id: es.id,
  type: Z.BUTTON,
  icon: "DeleteIcon",
  title: "rightClick.delete"
}), Hu = (n) => ({
  id: ls.id,
  type: Z.BUTTON,
  icon: "UnorderIcon",
  title: "rightClick.bulletList"
}), ku = (n) => ({
  id: ds.id,
  type: Z.BUTTON,
  icon: "OrderIcon",
  title: "rightClick.orderList"
}), Vu = (n) => ({
  id: As.id,
  type: Z.BUTTON,
  icon: "TodoListDoubleIcon",
  title: "rightClick.checkList"
}), Wu = (n) => ({
  id: as.id,
  type: Z.BUTTON,
  icon: "ReduceIcon",
  title: "toolbar.horizontalLine"
}), Ic = "doc.menu.insert-bellow";
function ju(n) {
  return {
    id: Ic,
    type: Z.SUBITEMS,
    title: "rightClick.insertBellow"
  };
}
const Oi = 4;
var zu = Object.getOwnPropertyDescriptor, Gu = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? zu(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, Wn = (n, e) => (t, o) => e(t, o, n);
function Sc(n, e) {
  const t = Ti(n.left, n.top, e), o = Ti(n.right, n.bottom, e);
  return {
    left: t.x,
    top: t.y,
    right: o.x,
    bottom: o.y
  };
}
function Ti(n, e, t) {
  const { scaleX: o, scaleY: r } = t.getAncestorScale(), s = t.getViewport(We.VIEW_MAIN);
  if (!s)
    return {
      x: n,
      y: e
    };
  const { viewportScrollX: i, viewportScrollY: a } = s, c = (n - i) * o, d = (e - a) * r;
  return {
    x: c,
    y: d
  };
}
function Bi(n, e, t) {
  const { scaleX: o, scaleY: r } = t.getAncestorScale(), s = t.getViewport(We.VIEW_MAIN);
  if (!s)
    return {
      x: n,
      y: e
    };
  const { viewportScrollX: i, viewportScrollY: a } = s, c = n / o + i, d = e / r + a;
  return {
    x: c,
    y: d
  };
}
const nr = (n, e) => {
  const { scene: t, mainComponent: o, engine: r } = e, s = e.with(de).getSkeleton(), i = s.findNodePositionByCharIndex(n.startOffset, !0, n.segmentId, n.segmentPage), a = n.collapsed ? n.startOffset : n.endOffset - 1, c = s.findNodePositionByCharIndex(a, !0, n.segmentId, n.segmentPage), d = o;
  if (!c || !i)
    return;
  const l = d.getOffsetConfig(), { docsLeft: A, docsTop: h } = l, u = r.getCanvasElement(), g = u.getBoundingClientRect(), f = ta(u.style.width), { top: p, left: m, width: I } = g, S = I / f, { scaleX: v, scaleY: R } = t.getAncestorScale(), E = new It(l, s), { borderBoxPointGroup: b } = E.getRangePointData(i, c);
  return Es(b).map((B) => Sc(B, t)).map((B) => ({
    left: (B.left + A * v) * S + m,
    right: (B.right + A * v) * S + m,
    top: (B.top + h * R) * S + p,
    bottom: (B.bottom + h * R) * S + p
  }));
};
let Bn = class extends me {
  constructor(n, e, t, o) {
    super(), this._globalPopupManagerService = n, this._renderManagerService = e, this._univerInstanceService = t, this._commandService = o;
  }
  _createRectPositionObserver(n, e) {
    const t = () => {
      const { scene: a, engine: c } = e, d = typeof n == "function" ? n() : n, l = c.getCanvasElement(), A = l.getBoundingClientRect(), h = ta(l.style.width), u = Sc(d, a), { top: g, left: f, width: p } = A, m = p / h;
      return {
        left: u.left * m + f,
        right: u.right * m + f,
        top: u.top * m + g,
        bottom: u.bottom * m + g
      };
    }, o = t(), r = new Fe(o), s = new In();
    s.add(this._commandService.onCommandExecuted((a) => {
      if (a.id === tt.id || a.id === X.id) {
        const c = t();
        c && r.next(c);
      }
    }));
    const i = e.scene.getViewport(We.VIEW_MAIN);
    return i && s.add(i.onScrollAfter$.subscribeEvent(() => {
      r.next(t());
    })), {
      position: o,
      position$: r,
      disposable: s
    };
  }
  _createObjectPositionObserver(n, e) {
    const t = () => {
      const { left: o, top: r, width: s, height: i } = n;
      return {
        left: o,
        right: o + s,
        top: r,
        bottom: r + i
      };
    };
    return this._createRectPositionObserver(t, e);
  }
  _createRangePositionObserver(n, e) {
    var i;
    const t = (i = nr(n, e)) != null ? i : [], o = new Fe(t), r = new In();
    r.add(this._commandService.onCommandExecuted((a) => {
      if ((a.id === tt.id || a.id === X.id) && a.params.unitId === e.unitId) {
        const d = nr(n, e);
        d && o.next(d);
      }
    }));
    const s = e.scene.getViewport(We.VIEW_MAIN);
    return s && r.add(s.onScrollAfter$.subscribeEvent(() => {
      const a = nr(n, e);
      a && o.next(a);
    })), {
      positions: t,
      positions$: o,
      disposable: r
    };
  }
  attachPopupToRect(n, e, t) {
    const o = this._renderManagerService.getRenderById(t);
    if (!o)
      throw new Error(`Current render not found, unitId: ${t}`);
    const { position: r, position$: s, disposable: i } = this._createRectPositionObserver(n, o), a = this._globalPopupManagerService.addPopup({
      ...e,
      unitId: t,
      subUnitId: "default",
      anchorRect: r,
      anchorRect$: s,
      canvasElement: o.engine.getCanvasElement()
    });
    return {
      dispose: () => {
        this._globalPopupManagerService.removePopup(a), s.complete(), i.dispose();
      },
      canDispose: () => this._globalPopupManagerService.activePopupId !== a
    };
  }
  // #region attach to object
  /**
   * attach a popup to canvas object
   * @param targetObject target canvas object
   * @param popup popup item
   * @returns disposable
   */
  attachPopupToObject(n, e, t) {
    const o = this._renderManagerService.getRenderById(t);
    if (!o)
      throw new Error(`Current render not found, unitId: ${t}`);
    const { position: r, position$: s, disposable: i } = this._createObjectPositionObserver(n, o), a = this._globalPopupManagerService.addPopup({
      ...e,
      unitId: t,
      subUnitId: "default",
      anchorRect: r,
      anchorRect$: s,
      canvasElement: o.engine.getCanvasElement()
    });
    return {
      dispose: () => {
        this._globalPopupManagerService.removePopup(a), s.complete(), i.dispose();
      },
      canDispose: () => this._globalPopupManagerService.activePopupId !== a
    };
  }
  // #endregion
  // #region attach to range
  /**
   * attach a popup to doc range
   * @param range doc range
   * @param popup popup item
   * @param unitId unit id
   * @returns disposable
   */
  attachPopupToRange(n, e, t) {
    if (!this._univerInstanceService.getUnit(t))
      throw new Error(`Document not found, unitId: ${t}`);
    const { direction: r = "top", multipleDirection: s } = e, i = this._renderManagerService.getRenderById(t);
    if (!i)
      throw new Error(`Current render not found, unitId: ${t}`);
    const { positions: a, positions$: c, disposable: d } = this._createRangePositionObserver(n, i), l = c.pipe(wn((h) => r.includes("top") ? h[0] : h[h.length - 1])), A = this._globalPopupManagerService.addPopup({
      ...e,
      unitId: t,
      subUnitId: "default",
      anchorRect: r.includes("top") ? a[0] : a[a.length - 1],
      anchorRect$: l,
      excludeRects: a,
      excludeRects$: c,
      direction: ["top", "bottom", "horizontal"].some((h) => r.includes(h)) && a.length > 1 && s != null ? s : r,
      canvasElement: i.engine.getCanvasElement()
    });
    return {
      dispose: () => {
        this._globalPopupManagerService.removePopup(A), c.complete(), d.dispose();
      },
      canDispose: () => this._globalPopupManagerService.activePopupId !== A
    };
  }
  // #endregion
};
Bn = Gu([
  Wn(0, j(Dl)),
  Wn(1, pe),
  Wn(2, L),
  Wn(3, T)
], Bn);
var Yu = Object.getOwnPropertyDescriptor, Ku = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? Yu(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, qu = (n, e) => (t, o) => e(t, o, n);
const Xu = (n, e, t, o) => {
  var h, u, g, f, p;
  const r = t.findNodePositionByCharIndex(n.startOffset, !0, n.segmentId, o), s = t.getSkeletonData();
  let i = n.endOffset - 1;
  if (n.segmentId) {
    const m = (p = Array.from((u = (h = s == null ? void 0 : s.skeFooters.get(n.segmentId)) == null ? void 0 : h.values()) != null ? u : [])[0]) != null ? p : Array.from((f = (g = s == null ? void 0 : s.skeHeaders.get(n.segmentId)) == null ? void 0 : g.values()) != null ? f : [])[0];
    m && (i = Math.min(m.ed, i));
  }
  const a = t.findNodePositionByCharIndex(i, !0, n.segmentId, o);
  if (!a || !r)
    return;
  const c = e.getOffsetConfig(), d = new It(c, t), { borderBoxPointGroup: l } = d.getRangePointData(r, a);
  return Es(l).map((m) => ({
    top: m.top + c.docsTop - Oi,
    bottom: m.bottom + c.docsTop + Oi,
    left: m.left + c.docsLeft,
    right: m.right + c.docsLeft
  }));
}, Mi = (n, e, t, o) => {
  const r = [];
  for (const s of n) {
    const i = s.top;
    for (const a of s.columns) {
      const c = a.left, d = s.colCount === 1 ? o : a.width;
      let l = null;
      for (const A of a.lines) {
        const h = A.paragraphIndex;
        if (A.paragraphStart) {
          l && (r.push(l), l = null);
          const u = {
            top: e + i + A.top,
            left: t + c,
            right: t + c + d,
            bottom: e + i + A.top + A.lineHeight
          };
          l = {
            paragraphStart: A.st,
            paragraphEnd: h,
            startIndex: h,
            rect: u,
            fisrtLine: {
              top: e + i + A.top + A.marginTop + A.paddingTop,
              left: t + c,
              right: t + c + d,
              bottom: e + i + A.top + A.marginTop + A.paddingTop + A.contentHeight
            }
          };
        } else
          l && l.startIndex === h && (l.rect.bottom = e + i + A.top + A.lineHeight);
      }
      l && r.push(l);
    }
  }
  return r;
}, Zu = (n, e, t, o = -1) => {
  const r = t.findPositionByGlyph(n, o);
  if (!r)
    return;
  const s = e.getOffsetConfig(), i = { ...r, isBack: !0 }, a = new It(s, t), { borderBoxPointGroup: c } = a.getRangePointData(i, i), l = Es(c)[0];
  return {
    top: l.top + s.docsTop,
    bottom: l.bottom + s.docsTop,
    left: l.left + s.docsLeft,
    right: l.left + s.docsLeft + n.width
  };
};
function Tt(n, e, t) {
  const { left: o, right: r, top: s, bottom: i } = t;
  return n >= o && n <= r && e >= s && e <= i;
}
let Pt = class extends me {
  constructor(e, t) {
    super();
    O(this, "_hoverCustomRanges$", new Fe([]));
    O(this, "hoverCustomRanges$", this._hoverCustomRanges$.pipe(Wt((e, t) => e.length === t.length && e.every((o, r) => t[r].range.rangeId === o.range.rangeId && t[r].segmentId === o.segmentId && t[r].segmentPageIndex === o.segmentPageIndex && t[r].range.startIndex === o.range.startIndex))));
    O(this, "_clickCustomRanges$", new be());
    O(this, "clickCustomRanges$", this._clickCustomRanges$.asObservable());
    O(this, "_hoverBullet$", new be());
    O(this, "hoverBullet$", this._hoverBullet$.pipe(Wt((e, t) => (e == null ? void 0 : e.paragraph.startIndex) === (t == null ? void 0 : t.paragraph.startIndex) && (e == null ? void 0 : e.segmentId) === (t == null ? void 0 : t.segmentId) && (e == null ? void 0 : e.segmentPageIndex) === (t == null ? void 0 : t.segmentPageIndex))));
    O(this, "_clickBullet$", new be());
    O(this, "clickBullets$", this._clickBullet$.asObservable());
    O(this, "_hoverParagraph$", new Fe(null));
    O(this, "hoverParagraph$", this._hoverParagraph$.pipe(Wt((e, t) => (e == null ? void 0 : e.startIndex) === (t == null ? void 0 : t.startIndex) && (e == null ? void 0 : e.segmentId) === (t == null ? void 0 : t.segmentId) && (e == null ? void 0 : e.pageIndex) === (t == null ? void 0 : t.pageIndex))));
    O(this, "hoverParagraphRealTime$", this._hoverParagraph$.asObservable());
    O(this, "_hoverParagraphLeft$", new Fe(null));
    O(this, "hoverParagraphLeft$", this._hoverParagraphLeft$.pipe(Wt((e, t) => (e == null ? void 0 : e.startIndex) === (t == null ? void 0 : t.startIndex) && (e == null ? void 0 : e.segmentId) === (t == null ? void 0 : t.segmentId) && (e == null ? void 0 : e.pageIndex) === (t == null ? void 0 : t.pageIndex))));
    O(this, "hoverParagraphLeftRealTime$", this._hoverParagraphLeft$.asObservable());
    O(this, "_hoverTableCell$", new be());
    O(this, "hoverTableCell$", this._hoverTableCell$.pipe(Wt((e, t) => (e == null ? void 0 : e.rowIndex) === (t == null ? void 0 : t.rowIndex) && (e == null ? void 0 : e.colIndex) === (t == null ? void 0 : t.colIndex) && (e == null ? void 0 : e.tableId) === (t == null ? void 0 : t.tableId) && (e == null ? void 0 : e.pageIndex) === (t == null ? void 0 : t.pageIndex))));
    O(this, "hoverTableCellRealTime$", this._hoverTableCell$.asObservable());
    O(this, "_hoverTable$", new be());
    O(this, "hoverTable$", this._hoverTable$.pipe(Wt((e, t) => (e == null ? void 0 : e.tableId) === (t == null ? void 0 : t.tableId) && (e == null ? void 0 : e.pageIndex) === (t == null ? void 0 : t.pageIndex))));
    O(this, "hoverTableRealTime$", this._hoverTable$.asObservable());
    O(this, "_customRangeDirty", !0);
    O(this, "_bulletDirty", !0);
    O(this, "_paragraphDirty", !0);
    /**
     * cache the bounding of custom ranges,
     * it will be updated when the doc-skeleton is recalculated
     */
    O(this, "_customRangeBounds", []);
    /**
     * cache the bounding of bullets,
     * it will be updated when the doc-skeleton is recalculated
     */
    O(this, "_bulletBounds", []);
    /**
     * cache the bounding of paragraphs,
     * it will be updated when the doc-skeleton is recalculated
     */
    O(this, "_paragraphBounds", /* @__PURE__ */ new Map());
    O(this, "_paragraphLeftBounds", []);
    O(this, "_tableParagraphBounds", /* @__PURE__ */ new Map());
    O(this, "_segmentParagraphBounds", /* @__PURE__ */ new Map());
    O(this, "_tableCellBounds", /* @__PURE__ */ new Map());
    O(this, "_tableBounds", /* @__PURE__ */ new Map());
    this._context = e, this._docSkeletonManagerService = t, this._initResetDirty(), this._initEvents(), this._initPointer();
  }
  get hoverParagraph() {
    return this._hoverParagraph$.value;
  }
  get hoverParagraphLeft() {
    return this._hoverParagraphLeft$.value;
  }
  get _skeleton() {
    return this._docSkeletonManagerService.getSkeleton();
  }
  get _documents() {
    return this._context.mainComponent;
  }
  dispose() {
    this._hoverCustomRanges$.complete(), this._clickCustomRanges$.complete(), super.dispose();
  }
  _initPointer() {
    let e = Dt.TEXT;
    this.disposeWithMe(this.hoverCustomRanges$.subscribe((t) => {
      t.length ? (e = this._context.scene.getCursor(), this._context.scene.setCursor(Dt.POINTER)) : this._context.scene.setCursor(e);
    }));
  }
  _initResetDirty() {
    this.disposeWithMe(this._skeleton.dirty$.subscribe(() => {
      this._customRangeDirty = !0, this._bulletDirty = !0, this._paragraphDirty = !0;
    })), this.disposeWithMe(
      Mt(this._context.engine.onTransformChange$).pipe(
        oo((e) => e.type === na.resize)
      ).subscribe(() => {
        this._customRangeDirty = !0, this._bulletDirty = !0, this._paragraphDirty = !0;
      })
    );
  }
  _initEvents() {
    this.disposeWithMe(Mt(this._context.scene.onPointerMove$).pipe(Rn(30)).subscribe((o) => {
      if (o.buttons > 0) {
        this._hoverBullet$.next(null), this._hoverCustomRanges$.next([]), this._hoverParagraph$.next(null), this._hoverParagraphLeft$.next(null), this._hoverTableCell$.next(null), this._hoverTable$.next(null);
        return;
      }
      const { x: r, y: s } = Bi(o.offsetX, o.offsetY, this._context.scene);
      this._hoverCustomRanges$.next(
        this._calcActiveRanges({ x: r, y: s })
      ), this._hoverParagraph$.next(
        this._calcActiveParagraph({ x: r, y: s })
      ), this._hoverParagraphLeft$.next(
        this._calcActiveParagraphLeft({ x: r, y: s })
      ), this._hoverBullet$.next(
        this._calcActiveBullet({ x: r, y: s })
      );
    })), this.disposeWithMe(this._context.scene.onPointerEnter$.subscribeEvent(() => {
      this._hoverBullet$.next(null), this._hoverCustomRanges$.next([]);
    }));
    const e = Mt(this._context.mainComponent.onPointerDown$), t = Mt(this._context.scene.onPointerUp$);
    this.disposeWithMe(e.pipe(
      Vl((o) => t.pipe(Wl(1), wn((r) => ({ down: o, up: r })))),
      oo(({ down: o, up: r }) => o.target === r.target && r.timeStamp - o.timeStamp < 300)
    ).subscribe(({ down: o }) => {
      if (o.button === 2)
        return;
      const r = Bi(o.offsetX, o.offsetY, this._context.scene), s = this._calcActiveRanges(r);
      s.length && this._clickCustomRanges$.next(s.pop());
      const i = this._calcActiveBullet(r);
      i && this._clickBullet$.next(i);
    }));
  }
  _buildCustomRangeBoundsBySegment(e, t = -1) {
    var s, i, a;
    const o = (a = (i = (s = this._context.unit.getSelfOrHeaderFooterModel(e)) == null ? void 0 : s.getBody()) == null ? void 0 : i.customRanges) != null ? a : [], r = [];
    return o.forEach((c) => {
      const d = {
        startOffset: c.startIndex,
        endOffset: c.endIndex + 1,
        segmentId: e
      }, l = Xu(d, this._documents, this._skeleton, t);
      if (!l)
        return null;
      r.push({
        customRange: c,
        rects: l,
        segmentId: e,
        segmentPageIndex: t
      });
    }), r;
  }
  _buildCustomRangeBounds() {
    var t;
    if (!this._customRangeDirty)
      return;
    this._customRangeDirty = !1;
    const e = [];
    e.push(...this._buildCustomRangeBoundsBySegment()), (t = this._skeleton.getSkeletonData()) == null || t.pages.forEach((o, r) => {
      o.headerId && e.push(...this._buildCustomRangeBoundsBySegment(o.headerId, r)), o.footerId && e.push(...this._buildCustomRangeBoundsBySegment(o.footerId, r));
    }), this._customRangeBounds = e;
  }
  _calcActiveRanges(e) {
    this._buildCustomRangeBounds();
    const { x: t, y: o } = e;
    return this._customRangeBounds.filter((s) => s.rects.some((i) => Tt(t, o, i))).map(
      (s) => ({
        segmentId: s.segmentId,
        range: s.customRange,
        segmentPageIndex: s.segmentPageIndex,
        rects: s.rects
      })
    );
  }
  _buildBulletBoundsBySegment(e, t = -1) {
    var c, d, l, A, h;
    const o = (c = this._context.unit.getSelfOrHeaderFooterModel(e)) == null ? void 0 : c.getBody(), r = ((d = o == null ? void 0 : o.paragraphs) != null ? d : []).filter((u) => u.bullet && u.bullet.listType.indexOf("CHECK_LIST") === 0), s = [], i = this._skeleton.getSkeletonData();
    if (!i)
      return s;
    const a = (u) => {
      var g, f, p;
      for (const m of u) {
        const I = [...m.sections];
        if (m.skeTables) {
          const S = Array.from(m.skeTables.values());
          I.push(...S.map((v) => v.rows.map((R) => R.cells.map((E) => E.sections))).flat(4));
        }
        for (const S of I)
          for (const v of S.columns)
            for (const R of v.lines)
              if (R.paragraphStart) {
                const E = r.find((b) => b.startIndex === R.paragraphIndex);
                if (E) {
                  const b = R, y = (p = (f = (g = b == null ? void 0 : b.divides) == null ? void 0 : g[0]) == null ? void 0 : f.glyphGroup) == null ? void 0 : p[0];
                  if (!y)
                    continue;
                  const C = Zu(y, this._documents, this._skeleton, t);
                  if (!C)
                    continue;
                  s.push({
                    rect: C,
                    segmentId: e,
                    segmentPageIndex: t,
                    paragraph: E
                  });
                }
              }
      }
      return s;
    };
    if (e) {
      const u = (h = (l = i.skeFooters.get(e)) == null ? void 0 : l.values()) != null ? h : (A = i.skeHeaders.get(e)) == null ? void 0 : A.values();
      return u ? a(Array.from(u)) : s;
    }
    return a(i.pages);
  }
  _buildBulletBounds() {
    var e;
    this._bulletDirty && (this._bulletDirty = !1, this._bulletBounds = [], this._bulletBounds.push(...this._buildBulletBoundsBySegment()), (e = this._skeleton.getSkeletonData()) == null || e.pages.forEach((t, o) => {
      t.headerId && this._bulletBounds.push(...this._buildBulletBoundsBySegment(t.headerId, o)), t.footerId && this._bulletBounds.push(...this._buildBulletBoundsBySegment(t.footerId, o));
    }));
  }
  _calcActiveBullet(e) {
    this._buildBulletBounds();
    const { x: t, y: o } = e;
    return this._bulletBounds.find((s) => Tt(t, o, s.rect));
  }
  // eslint-disable-next-line max-lines-per-function
  _buildParagraphBoundsBySegment(e) {
    var i, a, c;
    const t = this._skeleton.getSkeletonData(), r = this._documents.getOffsetConfig();
    if (!t)
      return null;
    const s = (d) => {
      const l = /* @__PURE__ */ new Map(), A = (h, u, g, f) => {
        Mi(h.sections, g, f, h.pageWidth - h.marginLeft - h.marginRight).forEach((m) => {
          if (!l.has(m.startIndex))
            l.set(m.startIndex, {
              rect: m.rect,
              paragraphStart: m.paragraphStart,
              paragraphEnd: m.paragraphEnd,
              startIndex: m.startIndex,
              rects: [m.rect],
              pageIndex: u,
              segmentId: e,
              firstLine: m.fisrtLine
            });
          else {
            const I = l.get(m.startIndex);
            I && (I.rect.bottom = m.rect.bottom, I.rects.push(m.rect));
          }
        });
      };
      for (let h = 0; h < d.length; h++) {
        const u = d[h], g = ((u.pageHeight === 1 / 0 ? 0 : u.pageHeight) + r.pageMarginTop) * h + u.marginTop + r.docsTop, f = u.marginLeft + r.docsLeft;
        u.skeTables && Array.from(u.skeTables.values()).forEach((p) => {
          const m = p.left + f, I = p.top + g, S = m + p.width, v = I + p.height, R = p.tableId;
          this._tableBounds.set(R, {
            rect: {
              left: m,
              top: I,
              right: S,
              bottom: v
            },
            pageIndex: h,
            tableId: R
          }), p.rows.forEach((E, b) => {
            E.cells.forEach((y, C) => {
              const B = ((u.pageHeight === 1 / 0 ? 0 : u.pageHeight) + r.pageMarginTop) * h + p.top + r.docsTop + u.marginTop + E.top + y.marginTop, x = p.left + r.docsLeft + u.marginLeft + y.left + y.marginLeft, M = Mi(y.sections, B, x, y.pageWidth - y.marginLeft - y.marginRight);
              let w = this._tableParagraphBounds.get(R);
              w || (w = [], this._tableParagraphBounds.set(R, w)), w.push(
                ...M.map((P) => ({
                  rect: P.rect,
                  paragraphStart: P.paragraphStart,
                  paragraphEnd: P.paragraphEnd,
                  startIndex: P.startIndex,
                  pageIndex: h,
                  segmentId: e,
                  rowIndex: b,
                  colIndex: C,
                  firstLine: P.fisrtLine,
                  tableId: R
                }))
              );
              let F = this._tableCellBounds.get(R);
              F || (F = [], this._tableCellBounds.set(R, F)), F.push({
                rect: {
                  top: B,
                  left: x,
                  right: x + y.pageWidth - y.marginLeft - y.marginRight,
                  bottom: B + y.pageHeight - y.marginBottom - y.marginTop
                },
                pageIndex: h,
                rowIndex: b,
                colIndex: C,
                tableId: R
              });
            });
          });
        }), A(u, h, g, f);
      }
      return l;
    };
    if (e) {
      const d = (c = (i = t.skeFooters.get(e)) == null ? void 0 : i.values()) != null ? c : (a = t.skeHeaders.get(e)) == null ? void 0 : a.values();
      return d ? s(Array.from(d)) : null;
    }
    return s(t.pages);
  }
  _buildParagraphBounds() {
    var t, o;
    if (!this._paragraphDirty)
      return;
    this._paragraphDirty = !1, this._tableParagraphBounds = /* @__PURE__ */ new Map(), this._tableCellBounds = /* @__PURE__ */ new Map(), this._tableBounds = /* @__PURE__ */ new Map(), this._paragraphBounds = (t = this._buildParagraphBoundsBySegment()) != null ? t : /* @__PURE__ */ new Map(), this._paragraphLeftBounds = Array.from(this._paragraphBounds.values()).map((r) => ({
      ...r,
      rect: {
        left: r.rect.left - 60,
        right: r.rect.left,
        top: r.rect.top,
        bottom: r.rect.bottom
      }
    }));
    const e = (r) => {
      var s;
      this._segmentParagraphBounds.set(r, (s = this._buildParagraphBoundsBySegment(r)) != null ? s : /* @__PURE__ */ new Map());
    };
    (o = this._skeleton.getSkeletonData()) == null || o.pages.forEach((r) => {
      r.headerId && e(r.headerId), r.footerId && e(r.footerId);
    });
  }
  _calcActiveParagraph(e) {
    var i, a;
    this._buildParagraphBounds();
    const { x: t, y: o } = e, r = Array.from(this._tableBounds.values()).find((c) => Tt(t, o, c.rect));
    if (this._hoverTable$.next(r), r) {
      const c = (i = this._tableCellBounds.get(r.tableId)) == null ? void 0 : i.find((A) => Tt(t, o, A.rect));
      if (this._hoverTableCell$.next(c), !c)
        return null;
      const d = (a = this._tableParagraphBounds.get(c.tableId)) == null ? void 0 : a.filter((A) => A.colIndex === c.colIndex && A.rowIndex === c.rowIndex), l = d == null ? void 0 : d.find((A) => Tt(t, o, A.rect));
      return l && {
        ...l,
        rects: [l.rect]
      };
    }
    let s;
    for (const c of this._paragraphBounds) {
      const d = c[1];
      if (d.rects.some((l) => Tt(t, o, l))) {
        s = d;
        break;
      }
    }
    return s;
  }
  _calcActiveParagraphLeft(e) {
    this._buildParagraphBounds();
    const { x: t, y: o } = e;
    return this._paragraphLeftBounds.find((s) => Tt(t, o, s.rect));
  }
  get paragraphBounds() {
    return this._buildParagraphBounds(), this._paragraphBounds;
  }
  findParagraphBoundByIndex(e) {
    this._buildParagraphBounds();
    const t = this._paragraphBounds.get(e);
    return t || Array.from(this._tableParagraphBounds.values()).flat().find((r) => r.startIndex === e);
  }
};
Pt = Ku([
  qu(1, j(de))
], Pt);
const Ju = [
  ct.id,
  Qt.id,
  Ut.id,
  Ft.id,
  Ht.id,
  bt.id,
  kt.id,
  mt.id,
  Et.id
];
function $u(n) {
  const { avaliableMenus: e = Ju } = n, t = J(da), [o, r] = Ee([]);
  return Ce(() => {
    function s() {
      const a = t.getFlatMenuByPositionKey(Pl.RIBBON), c = [];
      for (const d of e) {
        const l = a.find((A) => A.key === d);
        l && c.push(l);
      }
      r(c);
    }
    s();
    const i = t.menuChanged$.subscribe(s);
    return () => {
      i.unsubscribe();
    };
  }, [t]), /* @__PURE__ */ Q(
    "div",
    {
      className: ze("univer-box-border univer-flex univer-rounded univer-bg-white univer-py-1.5 univer-shadow-sm dark:!univer-border-gray-700 dark:!univer-bg-gray-900", Nn),
      children: o.map((s) => s.item && /* @__PURE__ */ Q("div", { className: "univer-flex univer-flex-nowrap univer-gap-2 univer-px-2", children: /* @__PURE__ */ Q(wl, { ...s.item }, s.key) }, s.key))
    }
  );
}
var eh = Object.getOwnPropertyDescriptor, th = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? eh(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, ln = (n, e) => (t, o) => e(t, o, n);
const _i = "univer.doc.float-menu";
function nh(n, e) {
  if (n == null || e == null)
    return !1;
  const { glyph: t, ...o } = n, { glyph: r, ...s } = e;
  return zc(o, s);
}
const oh = [
  V.CUSTOM_BLOCK,
  V.PARAGRAPH
];
let co = class extends me {
  constructor(e, t, o, r, s, i) {
    super();
    O(this, "_floatMenu", null);
    this._context = e, this._docSelectionManagerService = t, this._docCanvasPopManagerService = o, this._componentManager = r, this._univerInstanceService = s, this._docSelectionRenderService = i, !Rt(this._context.unitId) && (this._registerFloatMenu(), this._initSelectionChange(), this.disposeWithMe(() => {
      this._hideFloatMenu();
    }));
  }
  get floatMenu() {
    return this._floatMenu;
  }
  _registerFloatMenu() {
    this.disposeWithMe(this._componentManager.register(_i, $u));
  }
  _initSelectionChange() {
    this.disposeWithMe(this._docSelectionRenderService.onSelectionStart$.subscribe(() => {
      this._hideFloatMenu();
    })), this.disposeWithMe(this._docSelectionManagerService.textSelection$.subscribe((e) => {
      var s, i;
      const { unitId: t, textRanges: o } = e;
      if (t !== this._context.unitId)
        return;
      const r = o.length > 0 && o.find((a) => !a.collapsed);
      if (r) {
        if (r.startOffset === ((s = this._floatMenu) == null ? void 0 : s.start) && r.endOffset === ((i = this._floatMenu) == null ? void 0 : i.end))
          return;
        this._hideFloatMenu(), this._showFloatMenu(t, r);
        return;
      }
      this._hideFloatMenu();
    }));
  }
  _hideFloatMenu() {
    var e;
    (e = this._floatMenu) == null || e.disposable.dispose(), this._floatMenu = null;
  }
  _showFloatMenu(e, t) {
    var i, a, c;
    const o = this._univerInstanceService.getUnit(e, _.UNIVER_DOC);
    if (!o || o.getDisabled())
      return;
    const r = (i = o.getBody()) == null ? void 0 : i.dataStream[t.startOffset];
    if (t.endOffset - t.startOffset === 1 && r && oh.includes(r))
      return;
    const s = (c = (a = o.getBody()) == null ? void 0 : a.customRanges) == null ? void 0 : c.filter((d) => d.wholeEntity);
    if (!(s != null && s.some((d) => d.startIndex === t.startOffset && d.endIndex === t.endOffset - 1)))
      return this._floatMenu = {
        disposable: this._docCanvasPopManagerService.attachPopupToRange(
          t,
          {
            componentKey: _i,
            direction: t.direction === "backward" || nh(t.startNodePosition, t.endNodePosition) ? "top-center" : "bottom-center",
            offset: [0, 4]
          },
          e
        ),
        start: t.startOffset,
        end: t.endOffset
      }, Mn(() => this._hideFloatMenu());
  }
};
co = th([
  ln(1, j(Y)),
  ln(2, j(Bn)),
  ln(3, j(rn)),
  ln(4, j(L)),
  ln(5, j(Re))
], co);
var rh = Object.getOwnPropertyDescriptor, sh = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? rh(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, dn = (n, e) => (t, o) => e(t, o, n);
let lo = class extends me {
  constructor(e, t, o, r, s, i) {
    super();
    O(this, "_paragrahMenu", null);
    this._context = e, this._docSelectionManagerService = t, this._docEventManagerService = o, this._docPopupManagerService = r, this._docSkeletonManagerService = s, this._floatMenuService = i, !Rt(this._context.unitId) && this._init();
  }
  get activeParagraph() {
    var e;
    return (e = this._paragrahMenu) == null ? void 0 : e.paragraph;
  }
  _isCursorInActiveParagraph() {
    if (!this._paragrahMenu)
      return !1;
    const e = this._docSelectionManagerService.getActiveTextRange();
    return !(!(e != null && e.collapsed) || !(e != null && e.collapsed) || e.startOffset < this._paragrahMenu.paragraph.paragraphStart || e.startOffset > this._paragrahMenu.paragraph.paragraphEnd);
  }
  setParagraphMenuActive(e) {
    this._paragrahMenu && (this._paragrahMenu.active = e, this._isCursorInActiveParagraph() || this._docSelectionManagerService.replaceDocRanges([{
      startOffset: this._paragrahMenu.paragraph.paragraphStart,
      endOffset: this._paragrahMenu.paragraph.paragraphStart
    }]));
  }
  _init() {
    const e = (o) => {
      var s;
      if (this._docSkeletonManagerService.getViewModel().getEditArea() === ve.BODY && !this._floatMenuService.floatMenu && !this._context.unit.getDisabled()) {
        if ((s = this._paragrahMenu) != null && s.active)
          return;
        if (o) {
          this.showParagraphMenu(o);
          return;
        }
      }
      this.hideParagraphMenu(!0);
    };
    this.disposeWithMe(
      Pn([this._docEventManagerService.hoverParagraphRealTime$, this._docEventManagerService.hoverParagraphLeft$]).pipe(Rn(16)).subscribe(([o, r]) => {
        const s = o != null ? o : r;
        e(s);
      })
    );
    let t = 0;
    this.disposeWithMe(this._context.scene.getViewport(We.VIEW_MAIN).onScrollAfter$.subscribeEvent((o) => {
      t !== o.scrollY && (t = o.scrollY, this.hideParagraphMenu(!0));
    })), this.disposeWithMe(this._docEventManagerService.clickCustomRanges$.subscribe(() => {
      this.hideParagraphMenu(!0);
    }));
  }
  showParagraphMenu(e) {
    var c, d, l;
    if (((c = this._paragrahMenu) == null ? void 0 : c.paragraph.startIndex) === e.startIndex)
      return;
    this.hideParagraphMenu(!0);
    const t = (l = (d = this._context.unit.getBody()) == null ? void 0 : d.dataStream) != null ? l : "", o = e ? t.slice(e.paragraphStart, e.paragraphEnd) : "";
    if (o === "\b" || o === "")
      return;
    const a = this._docPopupManagerService.attachPopupToRect(
      e.firstLine,
      {
        componentKey: "doc.paragraph.menu",
        direction: "left-center",
        onClickOutside: () => {
          this._docSelectionManagerService.textSelection$.pipe(jl()).subscribe(() => {
            this._isCursorInActiveParagraph() || this.hideParagraphMenu(!0);
          });
        },
        zIndex: 101
      },
      this._context.unitId
    );
    this._paragrahMenu = {
      paragraph: e,
      disposable: a,
      active: !1
    };
  }
  hideParagraphMenu(e = !1) {
    this._paragrahMenu && (this._paragrahMenu.disposable.canDispose() || e) && (this._paragrahMenu.disposable.dispose(), this._paragrahMenu = null);
  }
};
lo = sh([
  dn(1, j(Y)),
  dn(2, j(Pt)),
  dn(3, j(Bn)),
  dn(4, j(de)),
  dn(5, j(co))
], lo);
const ih = ({ popup: n }) => {
  var E, b;
  const [e, t] = Ee(!1), o = ke(null), r = J(T), s = J(Oo), i = ke(null), a = ke(!1), c = J(pe), d = J(L), l = c.getRenderById(n.unitId), A = d.getUnit(n.unitId, _.UNIVER_DOC), h = l == null ? void 0 : l.with(lo), u = l == null ? void 0 : l.with(Pt), g = et(u == null ? void 0 : u.hoverParagraph$), f = et(u == null ? void 0 : u.hoverParagraphLeft$), p = (E = g != null ? g : f) == null ? void 0 : E.startIndex, m = _e(() => {
    var y, C;
    return (C = (y = A == null ? void 0 : A.getBody()) == null ? void 0 : y.paragraphs) == null ? void 0 : C.find((B) => B.startIndex === p);
  }, [A, g]), I = (b = m == null ? void 0 : m.paragraphStyle) == null ? void 0 : b.namedStyleType, S = Ec[I != null ? I : K.NORMAL_TEXT], v = _e(() => new Fe({
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  }), []), R = () => {
    t(!1), h == null || h.hideParagraphMenu(!0);
  };
  return /* @__PURE__ */ re(Xl, { children: [
    /* @__PURE__ */ re(
      "div",
      {
        "data-u-comp": "paragraph-menu",
        ref: i,
        className: ze("univer-mr-1 univer-inline-flex univer-h-7 univer-cursor-pointer univer-items-center univer-gap-1 univer-rounded-full univer-px-2.5 univer-py-0 hover:univer-bg-gray-100 dark:hover:!univer-bg-gray-600", Nn, {
          "univer-bg-gray-100 dark:!univer-bg-gray-700": e,
          "univer-bg-white dark:!univer-bg-gray-700": !e
        }),
        onMouseEnter: (y) => {
          var B, x, M, w, F, P;
          (B = n.onPointerEnter) == null || B.call(n, y), a.current = !0;
          const C = (x = i.current) == null ? void 0 : x.getBoundingClientRect();
          v.next({
            left: ((M = C == null ? void 0 : C.left) != null ? M : 0) - 4,
            right: (w = C == null ? void 0 : C.right) != null ? w : 0,
            top: (F = C == null ? void 0 : C.top) != null ? F : 0,
            bottom: (P = C == null ? void 0 : C.bottom) != null ? P : 0
          });
        },
        onMouseLeave: () => {
          a.current = !1;
        },
        onClick: () => {
          t(!0), h == null || h.setParagraphMenuActive(!0);
        },
        children: [
          /* @__PURE__ */ Q(
            S.component,
            {
              className: "univer-size-4 univer-text-gray-900 dark:!univer-text-white"
            }
          ),
          /* @__PURE__ */ Q(
            $a,
            {
              className: "univer-size-3 univer-text-gray-600 dark:!univer-text-gray-200"
            }
          )
        ]
      }
    ),
    e && /* @__PURE__ */ Q(
      Nl,
      {
        portal: !0,
        mask: !0,
        maskZIndex: 100,
        anchorRect$: v,
        direction: "left",
        onMaskClick: R,
        children: /* @__PURE__ */ Q(
          "section",
          {
            ref: o,
            onMouseEnter: (y) => {
              var C;
              (C = n.onPointerEnter) == null || C.call(n, y), a.current = !0;
            },
            onMouseLeave: () => {
              a.current = !1;
            },
            children: /* @__PURE__ */ Q(
              Ll,
              {
                style: { width: 212 },
                menuType: no.PARAGRAPH,
                onOptionSelect: (y) => {
                  const { label: C, commandId: B, value: x } = y;
                  r && r.executeCommand(B != null ? B : C, { value: x }), s.focus(), R();
                }
              }
            )
          }
        )
      }
    )
  ] });
};
function Se(n) {
  return n.getContextValue(_n) && n.getContextValue(Hr) && !n.getContextValue(Xi);
}
function ah(n) {
  return n.getContextValue(_n) && n.getContextValue(Hr) && !n.getContextValue(Xi);
}
const ch = {
  id: Jt.id,
  binding: q.TAB,
  preconditions: Se
}, lh = {
  id: Jt.id,
  binding: q.TAB | te.SHIFT,
  preconditions: Se,
  staticParameters: {
    shift: !0
  }
}, dh = {
  id: Qt.id,
  binding: q.B | te.CTRL_COMMAND,
  preconditions: Se
}, Ah = {
  id: Ut.id,
  binding: q.I | te.CTRL_COMMAND,
  preconditions: Se
}, uh = {
  id: Ft.id,
  binding: q.U | te.CTRL_COMMAND,
  preconditions: Se
}, hh = {
  id: Ht.id,
  binding: q.X | te.SHIFT | te.CTRL_COMMAND,
  preconditions: Se
}, gh = {
  id: bt.id,
  binding: q.COMMA | te.CTRL_COMMAND,
  preconditions: Se
}, fh = {
  id: kt.id,
  binding: q.PERIOD | te.CTRL_COMMAND,
  preconditions: Se
}, ph = {
  id: Qo.id,
  binding: q.L | te.CTRL_COMMAND | te.SHIFT,
  preconditions: Se
}, mh = {
  id: Fo.id,
  binding: q.R | te.CTRL_COMMAND | te.SHIFT,
  preconditions: Se
}, Eh = {
  id: Uo.id,
  binding: q.E | te.CTRL_COMMAND | te.SHIFT,
  preconditions: Se
}, Ih = {
  id: Ho.id,
  binding: q.J | te.CTRL_COMMAND | te.SHIFT,
  preconditions: Se
}, Sh = {
  id: On.id,
  binding: q.Digit7 | te.CTRL_COMMAND | te.SHIFT,
  preconditions: Se
}, vh = {
  id: xn.id,
  binding: q.Digit8 | te.CTRL_COMMAND | te.SHIFT,
  preconditions: Se
}, Vo = "docs-ui.config", Di = {
  layout: {
    docContainerConfig: od,
    toolbarConfig: nd
  }
}, Ch = [50, 80, 100, 130, 150, 170, 200, 400], Rh = [10, 400];
function bh() {
  const n = J(T), e = J(L), t = _e(() => e.getCurrentTypeOfUnit$(_.UNIVER_DOC), []), o = et(t), r = ha(() => {
    var d, l;
    if (!o) return 100;
    const c = ((l = (d = o.getSettings()) == null ? void 0 : d.zoomRatio) != null ? l : 1) * 100;
    return Math.round(c);
  }, [o]), [s, i] = Ee(() => r());
  Ce(() => (i(r()), n.onCommandExecuted((d) => {
    if (d.id === tt.id) {
      const l = r();
      i(l);
    }
  }).dispose), [n, r]);
  function a(c) {
    if (i(c), o == null)
      return;
    const d = c / 100;
    n.executeCommand(tt.id, {
      unitId: o.getUnitId(),
      zoomRatio: d
    });
  }
  return /* @__PURE__ */ Q(
    Ql,
    {
      min: Rh[0],
      value: s,
      shortcuts: Ch,
      onChange: a
    }
  );
}
function yh(n) {
  return /* @__PURE__ */ Q("section", { className: "univer-flex univer-flex-shrink-0 univer-justify-end", children: /* @__PURE__ */ Q(bh, {}) });
}
function xh() {
  var r, s, i;
  const n = J(L), e = Aa(Vo), t = et(() => n.getCurrentTypeOfUnit$(_.UNIVER_SHEET), void 0, void 0, []), o = (i = (s = (r = e == null ? void 0 : e.layout) == null ? void 0 : r.docContainerConfig) == null ? void 0 : s.footer) != null ? i : !0;
  return t ? null : o && /* @__PURE__ */ re(
    "div",
    {
      className: "univer-box-border univer-flex univer-items-center univer-justify-between univer-px-5 univer-py-1.5",
      children: [
        /* @__PURE__ */ Q("div", {}),
        /* @__PURE__ */ Q(yh, {})
      ]
    }
  );
}
const Oh = "univer-font-[500] univer-truncate univer-h-[24px] univer-mb-2 univer-leading-[24px] univer-cursor-pointer univer-pr-1 ", Th = "univer-text-base univer-font-semibold", Bh = "univer-text-sm univer-font-semibold", Mh = "univer-text-sm", _h = Be((n, e) => {
  const { menus: t, onClick: o, className: r, style: s, mode: i, maxHeight: a, activeId: c, open: d, onOpenChange: l, maxWidth: A, wrapperClass: h, wrapperStyle: u, iconClass: g, iconStyle: f } = n, p = i === "side-bar", m = ke(null), I = ke(t);
  I.current = t;
  const S = _e(() => ({
    scrollTo: (v) => {
      var x;
      if (!I.current || I.current.findIndex((M) => M.id === v) === -1 || !m.current) return;
      const E = document.getElementById(`univer-side-menu-${v}`);
      if (!E) return;
      const b = E.offsetTop, y = m.current.clientHeight, C = m.current.scrollHeight - y, B = Math.max(0, Math.min(b - y / 2 + E.clientHeight / 2, C));
      (x = m.current) == null || x.scrollTo({
        behavior: "smooth",
        top: B
      });
    }
  }), []);
  return Yl(e, () => S), Ce(() => {
    c && S.scrollTo(c);
  }, [c, S]), /* @__PURE__ */ re("div", { className: ze("univer-relative", h), style: u, children: [
    /* @__PURE__ */ Q(
      "div",
      {
        onClick: () => l == null ? void 0 : l(!d),
        className: ze("univer-absolute univer-left-5 univer-top-4 univer-z-[100] univer-flex univer-h-8 univer-w-8 univer-cursor-pointer univer-items-center univer-justify-center univer-rounded-full univer-bg-white univer-text-gray-800 univer-shadow-sm dark:!univer-bg-gray-600 dark:!univer-text-gray-200", g),
        style: f,
        children: d ? /* @__PURE__ */ Q(ic, {}) : /* @__PURE__ */ Q(qa, {})
      }
    ),
    /* @__PURE__ */ Q(
      "div",
      {
        className: ze(
          r,
          `
                      univer-absolute univer-left-0 univer-top-0 univer-box-border univer-flex univer-min-w-[180px]
                      univer-flex-col univer-px-4 univer-pb-4 univer-pt-14 univer-transition-all univer-duration-300
                    `,
          {
            "univer-rounded-r-2xl univer-bg-white univer-shadow univer-backdrop-blur-[10px] dark:!univer-bg-gray-900": p
          }
        ),
        style: {
          ...s,
          transform: d ? "translateX(0)" : "translateX(-100%)",
          maxHeight: a,
          opacity: d ? 1 : 0,
          maxWidth: A != null ? A : i === "side-bar" ? 320 : 180,
          paddingRight: i === "float" ? void 0 : 0
        },
        children: /* @__PURE__ */ Q(
          "div",
          {
            ref: m,
            className: ze("univer-flex-1 univer-overflow-y-auto univer-overflow-x-hidden", Jl),
            children: t == null ? void 0 : t.map((v) => /* @__PURE__ */ Q(
              "div",
              {
                id: `univer-side-menu-${v.id}`,
                className: ze(
                  Oh,
                  {
                    [Th]: v.isTitle,
                    [Bh]: v.level === 1,
                    [Mh]: v.level > 1,
                    "univer-text-gray-500 dark:!univer-text-gray-400": v.id !== c,
                    "univer-text-gray-800 dark:!univer-text-gray-200": v.id === c
                  }
                ),
                style: {
                  paddingLeft: (v.level - 1) * 12
                },
                onClick: () => {
                  o == null || o(v);
                },
                children: v.text
              },
              v.id
            ))
          }
        )
      }
    )
  ] });
}), Dh = (n) => {
  switch (n) {
    case K.HEADING_1:
      return 1;
    case K.HEADING_2:
      return 2;
    case K.HEADING_3:
      return 3;
    case K.HEADING_4:
      return 4;
    case K.HEADING_5:
      return 5;
    case K.TITLE:
      return 1;
    default:
      return 1;
  }
};
function wh(n, e, t, o) {
  var a, c;
  if (!n)
    return;
  const r = Array.from(n.values()), s = r.findIndex((d) => d.paragraphStart !== d.paragraphEnd && d.rect.top < o && d.rect.bottom > t);
  if (s === -1) return;
  const i = r == null ? void 0 : r.findLastIndex((d) => d.paragraphStart !== d.paragraphEnd && d.rect.top < o && d.rect.bottom > t);
  for (let d = s; d <= i; d++) {
    const l = r[d], A = e.get(l.startIndex);
    if ((a = A == null ? void 0 : A.paragraphStyle) != null && a.headingId)
      return A.paragraphStyle.headingId;
  }
  for (let d = s; d >= 0; d--) {
    const l = r[d], A = e.get(l.startIndex);
    if ((c = A == null ? void 0 : A.paragraphStyle) != null && c.headingId)
      return A.paragraphStyle.headingId;
  }
}
const wi = "__title";
function Ph() {
  var e, t, o;
  const n = Aa(Vo);
  return (o = (t = (e = n == null ? void 0 : n.layout) == null ? void 0 : e.docContainerConfig) == null ? void 0 : t.sideMenu) == null || o ? /* @__PURE__ */ Q(Nh, {}) : null;
}
function Nh() {
  var B, x, M, w, F, P, N, ee, $;
  const n = J(T), e = J(L), t = et(_e(() => e.getCurrentTypeOfUnit$(_.UNIVER_DOC), [])), o = J(pe), r = (x = (B = t == null ? void 0 : t.getBody()) == null ? void 0 : B.dataStream) != null ? x : "", [s, i] = Ee(0), [a, c] = Ee(void 0), d = (M = t == null ? void 0 : t.getUnitId()) != null ? M : "", l = o.getRenderById(d), A = t == null ? void 0 : t.getTitle(), h = l == null ? void 0 : l.with(Pt), u = h == null ? void 0 : h.paragraphBounds, g = (F = (w = l == null ? void 0 : l.mainComponent) == null ? void 0 : w.left) != null ? F : 0, f = (P = l == null ? void 0 : l.engine.height) != null ? P : 0, p = (N = l == null ? void 0 : l.scene.scaleY) != null ? N : 1, m = ($ = (ee = t == null ? void 0 : t.getBody()) == null ? void 0 : ee.paragraphs) != null ? $ : [], I = _e(() => {
    const U = /* @__PURE__ */ new Map();
    return m.forEach((H) => {
      U.set(H.startIndex, H);
    }), U;
  }, [m]);
  et(_e(() => l != null && l.engine.onTransformChange$ ? Mt(l == null ? void 0 : l.engine.onTransformChange$).pipe(Rn(33)) : zl(null), [l == null ? void 0 : l.engine.onTransformChange$]));
  const S = g < 180 ? "float" : "side-bar", v = m == null ? void 0 : m.filter(
    (U) => {
      var H;
      return ((H = U.paragraphStyle) == null ? void 0 : H.namedStyleType) !== void 0 && U.paragraphStyle.namedStyleType !== K.SUBTITLE && U.paragraphStyle.namedStyleType !== K.NORMAL_TEXT;
    }
  ).map((U) => {
    var ae;
    const H = Dh(U.paragraphStyle.namedStyleType), k = u == null ? void 0 : u.get(U.startIndex);
    if (!k) return null;
    const { paragraphStart: ne, paragraphEnd: ie } = k;
    return {
      id: U.paragraphStyle.headingId,
      text: to(r.slice(ne, ie)),
      level: H,
      isTitle: ((ae = U.paragraphStyle) == null ? void 0 : ae.namedStyleType) === K.TITLE
    };
  }).filter((U) => U == null ? void 0 : U.text), R = mn((U) => {
    const H = U.viewportScrollY, k = H + f / p, ne = wh(u, I, H, k);
    ne && c(ne);
  }), E = v != null && v.find((U) => U.isTitle) ? v : [
    ...A ? [{
      id: wi,
      text: A,
      level: 1,
      isTitle: !0
    }] : [],
    ...v != null ? v : []
  ].filter(Boolean), [b, y] = Ee(!0);
  Ce(() => {
    const U = kr(i, 100), H = n.onCommandExecuted((k) => {
      k.id === X.id && k.params.unitId === (t == null ? void 0 : t.getUnitId()) && U((ie) => ie + 1);
    });
    return () => {
      H.dispose();
    };
  }, [n, t]), Ce(() => {
    const U = l == null ? void 0 : l.scene.getViewport(We.VIEW_MAIN);
    if (!U)
      return;
    const H = Mt(U.onScrollAfter$).pipe(Rn(33)).subscribe(R);
    return () => {
      H.unsubscribe();
    };
  }, [l]);
  const C = mn((U) => {
    const H = l == null ? void 0 : l.scene.getViewport(We.VIEW_MAIN);
    if (!H)
      return;
    if (U.id === wi) {
      H.scrollToViewportPos({ viewportScrollY: 0 });
      return;
    }
    const k = m.find((ie) => {
      var ae;
      return ((ae = ie.paragraphStyle) == null ? void 0 : ae.headingId) === U.id;
    });
    if (!k)
      return;
    const ne = u == null ? void 0 : u.get(k.startIndex);
    ne && (H.scrollToViewportPos({ viewportScrollY: ne.rect.top }), c(U.id));
  });
  return !t || Rt(d) || !(E != null && E.length) ? null : /* @__PURE__ */ Q(
    "div",
    {
      className: "univer-absolute univer-bottom-0 univer-left-0 univer-top-0 univer-z-[100] univer-w-[0px]",
      children: /* @__PURE__ */ Q(
        _h,
        {
          menus: E,
          open: b,
          onOpenChange: y,
          mode: S,
          maxWidth: S === "float" ? void 0 : Math.floor(g) - 10,
          wrapperClass: "univer-mt-12",
          activeId: a,
          onClick: C,
          maxHeight: f - 48
        }
      )
    }
  );
}
const rt = {
  id: "doc-paragraph-setting.command",
  type: D.COMMAND,
  handler: async (n, e) => {
    var S, v, R, E, b;
    const t = n.get(Y), o = n.get(L), r = n.get(T), s = o.getCurrentUnitForType(_.UNIVER_DOC), i = t.getDocRanges();
    if (!s || i.length === 0 || !e)
      return !1;
    const a = i[0].segmentId, c = s.getUnitId(), d = s.getSelfOrHeaderFooterModel(a), l = (v = (S = d.getBody()) == null ? void 0 : S.paragraphs) != null ? v : [], A = (E = (R = d.getBody()) == null ? void 0 : R.dataStream) != null ? E : "", h = (b = ce.range.getParagraphsInRanges(i, l, A)) != null ? b : [], u = {
      id: X.id,
      params: {
        unitId: c,
        actions: [],
        textRanges: i
      }
    }, g = new Nt();
    g.reset();
    const f = new Ie(), p = W.getInstance();
    for (const y of h) {
      const { startIndex: C } = y;
      f.push({
        t: G.RETAIN,
        len: C - g.cursor
      });
      const B = {
        ...y.paragraphStyle,
        ...e.paragraph
      };
      f.push({
        t: G.RETAIN,
        len: 1,
        body: {
          dataStream: "",
          paragraphs: [
            {
              ...y,
              paragraphStyle: B,
              startIndex: 0
            }
          ]
        },
        coverType: nn.REPLACE
      }), g.moveCursorTo(C + 1);
    }
    const m = Ae(s, a);
    return u.params.actions = p.editOp(f.serialize(), m), !!r.syncExecuteCommand(u.id, u.params);
  }
}, Lh = () => {
  const n = J(Y), e = J(tn), t = _e(() => n.getDocRanges(), []);
  return Ce(() => {
    t.length || e.closePanel();
  }, [t]), t;
}, Qh = () => {
  var c, d, l, A, h;
  const e = J(L).getCurrentUnitForType(_.UNIVER_DOC), t = Lh();
  if (!e || t.length === 0)
    return [];
  const o = t[0].segmentId, r = e.getSelfOrHeaderFooterModel(o), s = (d = (c = r.getBody()) == null ? void 0 : c.paragraphs) != null ? d : [], i = (A = (l = r.getBody()) == null ? void 0 : l.dataStream) != null ? A : "";
  return (h = ce.range.getParagraphsInRanges(t, s, i)) != null ? h : [];
}, Uh = (n, e) => {
  const t = J(T), [o, r] = Ee(() => {
    var a, c;
    const i = n[0];
    return i ? String((c = (a = i.paragraphStyle) == null ? void 0 : a.horizontalAlign) != null ? c : e) : e;
  });
  return [o, (i) => (r(i), t.executeCommand(rt.id, {
    paragraph: { horizontalAlign: Number(i) }
  }))];
}, Fh = (n) => {
  const e = J(T), [t, o] = Ee(() => {
    var i;
    const s = n[0];
    return s ? on((i = s.paragraphStyle) == null ? void 0 : i.indentStart, 0) : 0;
  });
  return [t, (s) => (o(s), e.executeCommand(rt.id, {
    paragraph: { indentStart: { v: s } }
  }))];
}, Hh = (n) => {
  const e = J(T), [t, o] = Ee(() => {
    var i;
    const s = n[0];
    return s ? on((i = s.paragraphStyle) == null ? void 0 : i.indentEnd, 0) : 0;
  });
  return [t, (s) => (o(s), e.executeCommand(rt.id, {
    paragraph: { indentEnd: { v: s } }
  }))];
}, kh = (n) => {
  const e = J(T), [t, o] = Ee(() => {
    var i;
    const s = n[0];
    return s ? on((i = s.paragraphStyle) == null ? void 0 : i.indentFirstLine, 0) : 0;
  });
  return [t, (s) => (o(s), e.executeCommand(rt.id, {
    paragraph: { indentFirstLine: { v: s } }
  }))];
}, Vh = (n) => {
  const e = J(T), [t, o] = Ee(() => {
    var i;
    const s = n[0];
    return s ? on((i = s.paragraphStyle) == null ? void 0 : i.hanging, 0) : 0;
  });
  return [t, (s) => (o(s), e.executeCommand(rt.id, {
    paragraph: { hanging: { v: s } }
  }))];
}, Wh = (n) => {
  const e = J(T), [t, o] = Ee(() => {
    var i;
    const s = n[0];
    return s ? on((i = s.paragraphStyle) == null ? void 0 : i.spaceAbove, 0) : 0;
  });
  return [t, (s) => (o(s), e.executeCommand(rt.id, {
    paragraph: { spaceAbove: { v: s } }
  }))];
}, jh = (n) => {
  const e = J(T), [t, o] = Ee(() => {
    var i;
    const s = n[0];
    return s ? on((i = s.paragraphStyle) == null ? void 0 : i.spaceBelow, 0) : 0;
  });
  return [t, (s) => (o(s), e.executeCommand(rt.id, {
    paragraph: { spaceBelow: { v: s } }
  }))];
}, zh = (n) => {
  const e = J(T), t = J(pe), o = J(L), r = _e(() => {
    var g;
    const u = o.getCurrentUnitForType(_.UNIVER_DOC);
    if (u)
      return (g = t.getRenderById(u == null ? void 0 : u.getUnitId())) == null ? void 0 : g.with(de).getSkeleton();
  }, []), s = _e(() => new Fe({}), []), [i, a] = Ee(() => {
    var g, f;
    const u = n[0];
    return u && (f = (g = u.paragraphStyle) == null ? void 0 : g.lineSpacing) != null ? f : 1;
  }), c = ke(i), [d, l] = Ee(() => {
    var g, f;
    const u = n[0];
    return u ? (f = (g = u.paragraphStyle) == null ? void 0 : g.spacingRule) != null ? f : Xt.AUTO : Xt.AUTO;
  }), A = async (u) => {
    a(u), s.next({ lineSpacing: u, spacingRule: d });
  }, h = async (u) => {
    if (u !== d) {
      let g = c.current;
      if (u === Xt.AT_LEAST) {
        const f = r == null ? void 0 : r.findNodeByCharIndex(n[0].startIndex), p = f == null ? void 0 : f.parent, m = p == null ? void 0 : p.parent;
        (m == null ? void 0 : m.contentHeight) !== void 0 && (g = Math.max(m.contentHeight, g));
      } else
        g > 5 && (g = 2);
      c.current = i, A(g), l(u), s.next({ spacingRule: u });
    }
  };
  return Ce(() => {
    const u = s.pipe(
      dr((g) => !!Object.keys(g).length),
      Kl(16),
      dr((g) => !!g.length),
      ql((g) => g.reduce((f, p) => (Object.keys(p).forEach((m) => {
        f[m] = p[m];
      }), f), {}))
    ).subscribe((g) => e.executeCommand(rt.id, {
      paragraph: { ...g }
    }));
    return () => u.unsubscribe();
  }, []), {
    lineSpacing: [i, A],
    spacingRule: [d, h]
  };
}, Bt = (n) => {
  const { value: e, onChange: t, className: o = "", min: r = 0, max: s = 100, step: i = 1 } = n, a = ke(null);
  return /* @__PURE__ */ Q(
    it,
    {
      step: i,
      ref: a,
      min: r,
      max: s,
      value: e,
      onChange: (c) => {
        t(c != null ? c : 0).finally(() => {
          setTimeout(() => {
            var d;
            (d = a.current) == null || d.focus();
          }, 30);
        });
      },
      className: o
    }
  );
};
function Gh() {
  const n = J(Ye), e = _e(() => [
    { label: n.t("toolbar.alignLeft"), value: String(Ue.LEFT), icon: /* @__PURE__ */ Q(ac, {}) },
    { label: n.t("toolbar.alignCenter"), value: String(Ue.CENTER), icon: /* @__PURE__ */ Q(sc, {}) },
    { label: n.t("toolbar.alignRight"), value: String(Ue.RIGHT), icon: /* @__PURE__ */ Q(cc, {}) },
    { label: n.t("toolbar.alignJustify"), value: String(Ue.JUSTIFIED), icon: /* @__PURE__ */ Q(Ka, {}) }
  ], []), t = Qh(), [o, r] = Uh(t, e[0].value), [s, i] = Fh(t), [a, c] = Hh(t), [d, l] = kh(t), [A, h] = Vh(t), [u, g] = Wh(t), [f, p] = jh(t), { lineSpacing: [m, I], spacingRule: [S, v] } = zh(t), R = _e(() => S === Xt.AUTO ? { min: 1, max: 5, step: m < 2 ? 0.5 : 1 } : { min: 1, max: 100 }, [S, m]);
  return /* @__PURE__ */ re("div", { children: [
    /* @__PURE__ */ Q("div", { className: "univer-t-4 univer-text-sm univer-font-medium", children: n.t("doc.paragraphSetting.alignment") }),
    /* @__PURE__ */ Q(
      "div",
      {
        className: ze("univer-mt-4 univer-box-border univer-flex univer-w-full univer-items-center univer-justify-between univer-gap-1 univer-rounded-md univer-p-1", Nn),
        children: e.map((E) => /* @__PURE__ */ Q($l, { title: E.label, placement: "bottom", children: /* @__PURE__ */ Q(
          "span",
          {
            className: ze("hover:univer-bg-black/60 univer-flex univer-cursor-pointer univer-items-center univer-justify-center univer-rounded univer-bg-none univer-px-3 univer-py-1", {
              "univer-bg-blend-color-dodge/90": o === E.value
            }),
            onClick: () => r(E.value),
            children: E.icon
          }
        ) }, E.value))
      }
    ),
    /* @__PURE__ */ Q("div", { className: "univer-t-4 univer-text-sm univer-font-medium", children: n.t("doc.paragraphSetting.indentation") }),
    /* @__PURE__ */ re("div", { children: [
      /* @__PURE__ */ re("div", { className: "univer-item-center univer-flex univer-justify-between", children: [
        /* @__PURE__ */ re("div", { className: "univer-mt-3 univer-text-xs", children: [
          n.t("doc.paragraphSetting.left"),
          "(px)"
        ] }),
        /* @__PURE__ */ Q(Bt, { className: "univer-mt-4", value: s, onChange: (E) => i(E != null ? E : 0) })
      ] }),
      /* @__PURE__ */ re("div", { className: "univer-item-center univer-flex univer-justify-between", children: [
        /* @__PURE__ */ re("div", { className: "univer-mt-3 univer-text-xs", children: [
          n.t("doc.paragraphSetting.right"),
          "(px)"
        ] }),
        /* @__PURE__ */ Q(Bt, { className: "univer-mt-4", value: a, onChange: (E) => c(E != null ? E : 0) })
      ] }),
      /* @__PURE__ */ re("div", { className: "univer-item-center univer-flex univer-justify-between", children: [
        /* @__PURE__ */ re("div", { className: "univer-mt-3 univer-text-xs", children: [
          n.t("doc.paragraphSetting.firstLine"),
          "(px)"
        ] }),
        /* @__PURE__ */ Q(Bt, { className: "univer-mt-4", value: d, onChange: (E) => l(E != null ? E : 0) })
      ] }),
      /* @__PURE__ */ re("div", { className: "univer-item-center univer-flex univer-justify-between", children: [
        /* @__PURE__ */ re("div", { className: "univer-mt-3 univer-text-xs", children: [
          n.t("doc.paragraphSetting.hanging"),
          "(px)"
        ] }),
        /* @__PURE__ */ Q(Bt, { className: "univer-mt-4", value: A, onChange: (E) => h(E != null ? E : 0) })
      ] })
    ] }),
    /* @__PURE__ */ Q("div", { className: "univer-t-4 univer-text-sm univer-font-medium", children: n.t("doc.paragraphSetting.spacing") }),
    /* @__PURE__ */ re("div", { children: [
      /* @__PURE__ */ re("div", { className: "univer-justify-betweenuniver-item-center univer-flex", children: [
        /* @__PURE__ */ re("div", { className: "univer-mt-3 univer-text-xs", children: [
          n.t("doc.paragraphSetting.before"),
          "(px)"
        ] }),
        /* @__PURE__ */ Q(Bt, { className: "univer-mt-4", value: u, onChange: (E) => g(E != null ? E : 0) })
      ] }),
      /* @__PURE__ */ re("div", { className: "univer-item-center univer-flex univer-justify-between", children: [
        /* @__PURE__ */ re("div", { className: "univer-mt-3 univer-text-xs", children: [
          n.t("doc.paragraphSetting.after"),
          "(px)"
        ] }),
        /* @__PURE__ */ Q(Bt, { className: "univer-mt-4", value: f, onChange: (E) => p(E != null ? E : 0) })
      ] }),
      /* @__PURE__ */ re("div", { className: "item-center univer-flex univer-justify-between", children: [
        /* @__PURE__ */ Q("div", { className: "univer-mt-3 univer-text-xs", children: n.t("doc.paragraphSetting.lineSpace") }),
        /* @__PURE__ */ re(
          "div",
          {
            className: "univer-mt-4 univer-flex univer-w-[162px] univer-flex-col univer-gap-1.5",
            children: [
              /* @__PURE__ */ Q(
                fa,
                {
                  value: `${S}`,
                  options: [
                    { label: n.t("doc.paragraphSetting.multiSpace"), value: `${Xt.AUTO}` },
                    { label: n.t("doc.paragraphSetting.fixedValue"), value: `${Xt.AT_LEAST}` }
                  ],
                  onChange: (E) => v(Number(E))
                }
              ),
              /* @__PURE__ */ Q(
                Bt,
                {
                  ...R,
                  value: m,
                  onChange: (E) => I(E != null ? E : 0)
                }
              )
            ]
          }
        )
      ] })
    ] })
  ] });
}
const Yh = (n, e) => e.length === n.length && n.some((t) => e.some((o) => o.startOffset === t.startOffset && o.endOffset === t.endOffset));
function Kh() {
  const n = J(T), e = J(Ye), t = et(e.currentLocale$), [o, r] = Ee(""), s = _e(() => kr(() => r(ge(4)), 300), []), i = ke([]);
  return Ce(() => {
    const a = n.onCommandExecuted((c) => {
      if (Le.id === c.id) {
        const d = c.params.ranges;
        Yh(d, i.current) || r(ge(4)), i.current = d;
      }
      X.id === c.id && c.params.trigger !== rt.id && s();
    });
    return () => a.dispose();
  }, [s]), Ce(() => {
    r(ge(4));
  }, [t]), Ce(() => () => s.cancel(), [s]), /* @__PURE__ */ Q(Gh, {}, o);
}
var qh = Object.getOwnPropertyDescriptor, Xh = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? qh(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, or = (n, e) => (t, o) => e(t, o, n);
const Pi = "doc_ui_paragraph-setting-panel";
let tn = class extends me {
  constructor(e, t, o) {
    super();
    O(this, "_id");
    this._commandService = e, this._componentManager = t, this._sidebarService = o, this._init();
  }
  _init() {
    this.disposeWithMe(this._componentManager.register(Pi, Kh));
  }
  openPanel() {
    const e = {
      header: { title: "doc.slider.paragraphSetting" },
      id: this._id,
      children: {
        label: Pi
      },
      width: 300
    };
    this._sidebarService.open(e);
  }
  closePanel() {
    this._sidebarService.close(this._id);
  }
};
tn = Xh([
  or(0, T),
  or(1, j(rn)),
  or(2, j(ca))
], tn);
const Ds = {
  id: "sidebar.operation.doc-paragraph-setting-panel",
  type: D.OPERATION,
  handler: (n) => (n.get(tn).openPanel(), !0)
}, ws = (n) => {
  const e = n.get(Y);
  return new fe((t) => {
    const o = e.textSelection$.subscribe(() => {
      e.getDocRanges().some((i) => i.collapsed === !1 || i.rangeType === He.RECT) ? t.next(!1) : t.next(!0);
    });
    return () => o.unsubscribe();
  });
};
function Zh(n) {
  if (n.length < 2)
    return !0;
  const e = n.map((t) => t.tableId);
  return e.every((t) => t === e[0]);
}
function Ni(n, e, t) {
  var s;
  const o = e.getRectRanges(), r = e.getActiveTextRange();
  if (o && o.length && Zh(o) && r == null) {
    n.next(!1);
    return;
  }
  if (r && (o == null || o.length === 0)) {
    const { segmentId: i, startOffset: a, endOffset: c } = r, d = t.getCurrentUniverDocInstance(), l = (s = d == null ? void 0 : d.getSelfOrHeaderFooterModel(i).getBody()) == null ? void 0 : s.tables;
    if (l && l.length && l.some((A) => {
      const { startIndex: h, endIndex: u } = A;
      return a > h && a < u || c > h && c < u;
    })) {
      n.next(!1);
      return;
    }
  }
  n.next(!0);
}
const dt = (n) => {
  const e = n.get(Y), t = n.get(L);
  return new fe((o) => {
    const r = e.textSelection$.subscribe(() => {
      Ni(o, e, t);
    });
    return Ni(o, e, t), () => r.unsubscribe();
  });
}, Jh = (n) => ({
  id: ro.name,
  commandId: ro.id,
  type: Z.BUTTON,
  icon: "CopyDoubleIcon",
  title: "rightClick.copy",
  disabled$: ws(n),
  hidden$: se(n, _.UNIVER_DOC)
}), $h = (n) => ({
  id: Ds.id,
  type: Z.BUTTON,
  icon: "MenuIcon",
  title: "doc.menu.paragraphSetting",
  hidden$: se(n, _.UNIVER_DOC)
}), eg = (n) => ({
  id: rs.id,
  type: Z.BUTTON,
  icon: "CopyDoubleIcon",
  title: "rightClick.cut",
  disabled$: ws(n),
  hidden$: se(n, _.UNIVER_DOC)
}), tg = (n) => ({
  id: is.id,
  type: Z.BUTTON,
  icon: "PasteSpecialDoubleIcon",
  title: "rightClick.paste",
  hidden$: se(n, _.UNIVER_DOC)
}), ng = (n) => ({
  id: Do.id,
  type: Z.BUTTON,
  icon: "PasteSpecialDoubleIcon",
  title: "rightClick.delete",
  disabled$: ws(n),
  hidden$: se(n, _.UNIVER_DOC)
}), vc = "doc.menu.table-insert";
function og(n) {
  return {
    id: vc,
    type: Z.SUBITEMS,
    title: "table.insert",
    icon: "InsertDoubleIcon",
    hidden$: Pn(se(n, _.UNIVER_DOC), dt(n), (e, t) => e || t)
  };
}
function rg(n) {
  return {
    id: Rs.id,
    type: Z.BUTTON,
    title: "table.insertRowAbove",
    icon: "InsertRowAboveDoubleIcon",
    disabled$: dt(n),
    hidden$: se(n, _.UNIVER_DOC)
  };
}
function sg(n) {
  return {
    id: bs.id,
    type: Z.BUTTON,
    title: "table.insertRowBelow",
    icon: "InsertRowBelowDoubleIcon",
    disabled$: dt(n),
    hidden$: se(n, _.UNIVER_DOC)
  };
}
function ig(n) {
  return {
    id: ys.id,
    type: Z.BUTTON,
    title: "table.insertColumnLeft",
    icon: "LeftInsertColumnDoubleIcon",
    disabled$: dt(n),
    hidden$: se(n, _.UNIVER_DOC)
  };
}
function ag(n) {
  return {
    id: xs.id,
    type: Z.BUTTON,
    title: "table.insertColumnRight",
    icon: "RightInsertColumnDoubleIcon",
    disabled$: dt(n),
    hidden$: se(n, _.UNIVER_DOC)
  };
}
const Cc = "doc.menu.table-delete";
function cg(n) {
  return {
    id: Cc,
    type: Z.SUBITEMS,
    title: "table.delete",
    icon: "ReduceDoubleIcon",
    hidden$: Pn(se(n, _.UNIVER_DOC), dt(n), (e, t) => e || t)
  };
}
function lg(n) {
  return {
    id: Is.id,
    type: Z.BUTTON,
    title: "table.deleteRows",
    icon: "DeleteRowDoubleIcon",
    disabled$: dt(n),
    hidden$: se(n, _.UNIVER_DOC)
  };
}
function dg(n) {
  return {
    id: Ss.id,
    type: Z.BUTTON,
    title: "table.deleteColumns",
    icon: "DeleteColumnDoubleIcon",
    disabled$: dt(n),
    hidden$: se(n, _.UNIVER_DOC)
  };
}
function Ag(n) {
  return {
    id: Hn.id,
    type: Z.BUTTON,
    title: "table.deleteTable",
    icon: "GridIcon",
    disabled$: dt(n),
    hidden$: se(n, _.UNIVER_DOC)
  };
}
const ug = {
  [Ys.FORMAT]: {
    [Qt.id]: {
      order: 0,
      menuItemFactory: au
    },
    [Ut.id]: {
      order: 1,
      menuItemFactory: cu
    },
    [Ft.id]: {
      order: 2,
      menuItemFactory: lu
    },
    [Ht.id]: {
      order: 3,
      menuItemFactory: du
    },
    [bt.id]: {
      order: 4,
      menuItemFactory: Au
    },
    [kt.id]: {
      order: 5,
      menuItemFactory: uu
    },
    [Xe.id]: {
      order: 5.5,
      menuItemFactory: fu
    },
    [ct.id]: {
      order: 6,
      menuItemFactory: gu
    },
    [_t.id]: {
      order: 7,
      menuItemFactory: hu
    },
    [mt.id]: {
      order: 8,
      menuItemFactory: pu
    },
    [Et.id]: {
      order: 9,
      menuItemFactory: Tu,
      [Un.id]: {
        order: 0,
        menuItemFactory: Ou
      }
    }
  },
  [Ys.LAYOUT]: {
    [Qo.id]: {
      order: 2,
      menuItemFactory: vu
    },
    [Uo.id]: {
      order: 3,
      menuItemFactory: Cu
    },
    [Fo.id]: {
      order: 4,
      menuItemFactory: Ru
    },
    [Ho.id]: {
      order: 5,
      menuItemFactory: bu
    },
    [Po.id]: {
      order: 6,
      menuItemFactory: yu
    },
    [On.id]: {
      order: 7,
      menuItemFactory: bi
    },
    [xn.id]: {
      order: 8,
      menuItemFactory: yi
    },
    [so.id]: {
      order: 9,
      menuItemFactory: xi
    },
    [Bs.id]: {
      order: 10,
      menuItemFactory: mu
    },
    [ko.id]: {
      order: 11,
      menuItemFactory: xu
    },
    [_s.id]: {
      order: 12,
      menuItemFactory: Bu
    }
  },
  [Ul.MEDIA]: {
    [mc]: {
      order: 2,
      menuItemFactory: Iu,
      [Os.id]: {
        order: 0,
        menuItemFactory: Su
      }
    }
  },
  [no.MAIN_AREA]: {
    [an.FORMAT]: {
      [ro.name]: {
        order: 0,
        menuItemFactory: Jh
      },
      [rs.id]: {
        order: 1,
        menuItemFactory: eg
      },
      [is.id]: {
        order: 2,
        menuItemFactory: tg
      },
      [Do.id]: {
        order: 3,
        menuItemFactory: ng
      }
    },
    [an.LAYOUT]: {
      [Ds.id]: {
        order: 0,
        menuItemFactory: $h
      },
      [vc]: {
        order: 1,
        menuItemFactory: og,
        [Rs.id]: {
          order: 1,
          menuItemFactory: rg
        },
        [bs.id]: {
          order: 2,
          menuItemFactory: sg
        },
        [ys.id]: {
          order: 3,
          menuItemFactory: ig
        },
        [xs.id]: {
          order: 4,
          menuItemFactory: ag
        }
      },
      [Cc]: {
        order: 2,
        menuItemFactory: cg,
        [Is.id]: {
          order: 1,
          menuItemFactory: lg
        },
        [Ss.id]: {
          order: 2,
          menuItemFactory: dg
        },
        [Hn.id]: {
          order: 3,
          menuItemFactory: Ag
        }
      }
    }
  },
  [no.PARAGRAPH]: {
    [an.QUICK]: {
      [us.id]: {
        order: 0,
        menuItemFactory: _u
      },
      [hs.id]: {
        order: 1,
        menuItemFactory: Du
      },
      [gs.id]: {
        order: 2,
        menuItemFactory: wu
      },
      [fs.id]: {
        order: 3,
        menuItemFactory: Pu
      },
      [ps.id]: {
        order: 4,
        menuItemFactory: Nu
      },
      [io.id]: {
        order: 5,
        menuItemFactory: Lu
      },
      [On.id]: {
        order: 6,
        menuItemFactory: bi
      },
      [xn.id]: {
        order: 7,
        menuItemFactory: yi
      },
      [so.id]: {
        order: 8,
        menuItemFactory: xi
      }
    },
    [an.FORMAT]: {
      [os.id]: {
        order: 0,
        menuItemFactory: Qu
      },
      [ss.id]: {
        order: 1,
        menuItemFactory: Uu
      },
      [es.id]: {
        order: 2,
        menuItemFactory: Fu
      }
    },
    [an.LAYOUT]: {
      // title: 'rightClick.insertBellow',
      [Ic]: {
        menuItemFactory: ju,
        [ls.id]: {
          order: 0,
          menuItemFactory: Hu
        },
        [ds.id]: {
          order: 1,
          menuItemFactory: ku
        },
        [As.id]: {
          order: 2,
          menuItemFactory: Vu
        },
        [as.id]: {
          order: 3,
          menuItemFactory: Wu
        }
      }
    }
  }
};
var hg = Object.getOwnPropertyDescriptor, gg = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? hg(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, st = (n, e) => (t, o) => e(t, o, n);
let Ao = class extends me {
  constructor(n, e, t, o, r, s, i, a, c) {
    super(), this._injector = n, this._componentManager = e, this._commandService = t, this._layoutService = o, this._menuManagerService = r, this._uiPartsService = s, this._univerInstanceService = i, this._shortcutService = a, this._configService = c, this._init();
  }
  _initCustomComponents() {
    [
      [fc, tu],
      [gc, $A],
      ["TodoListDoubleIcon", lc],
      ["doc.paragraph.menu", ih],
      ["CutIcon", Xa],
      ["DeleteIcon", Za],
      [Rr, ou],
      ["DocumentSettingIcon", Ja]
    ].forEach(([n, e]) => {
      this.disposeWithMe(
        this._componentManager.register(n, e)
      );
    });
  }
  _initUiParts() {
    this.disposeWithMe(this._uiPartsService.registerComponent(Ks.FOOTER, () => qs(xh, this._injector))), this.disposeWithMe(this._uiPartsService.registerComponent(Ks.CONTENT, () => qs(Ph, this._injector)));
  }
  _initMenus() {
    this._menuManagerService.mergeMenu(ug);
  }
  _initShortCut() {
    [
      dh,
      Ah,
      uh,
      hh,
      gh,
      fh,
      Eh,
      Ih,
      mh,
      ph,
      Sh,
      vh,
      ch
    ].forEach((n) => {
      this.disposeWithMe(this._shortcutService.registerShortcut(n));
    });
  }
  _init() {
    this._initCustomComponents(), this._initMenus(), this._initFocusHandler(), this._initCommands(), this._initUiParts(), this._initShortCut();
  }
  _initCommands() {
    [
      Ac,
      Bs,
      Ts
    ].forEach((n) => this.disposeWithMe(this._commandService.registerCommand(n)));
  }
  _initFocusHandler() {
    this.disposeWithMe(
      this._layoutService.registerFocusHandler(_.UNIVER_DOC, (n) => {
        this._injector.get(pe).getRenderById(n).with(Re).focus();
      })
    );
  }
};
Ao = gg([
  st(0, j(Dn)),
  st(1, j(rn)),
  st(2, T),
  st(3, Oo),
  st(4, da),
  st(5, Fl),
  st(6, L),
  st(7, To),
  st(8, Vr)
], Ao);
var fg = Object.getOwnPropertyDescriptor, pg = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? fg(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, rr = (n, e) => (t, o) => e(t, o, n);
const Li = 1.5;
let uo = class extends Ct {
  constructor(n, e, t, o) {
    super(), this._context = n, this._textSelectionManagerService = e, this._editorService = t, this._docSkeletonManagerService = o, this._init();
  }
  _init() {
    this._textSelectionManagerService.textSelection$.pipe(ft(this.dispose$)).subscribe((n) => {
      if (n == null)
        return;
      const { isEditing: e, unitId: t } = n;
      t !== this._context.unitId || !e || this._context.unitId !== bo && this._scrollToSelection();
    });
  }
  scrollToRange(n) {
    const e = this._docSkeletonManagerService.getSkeleton();
    if (!e)
      return;
    const { startOffset: t } = n, o = e.findNodePositionByCharIndex(t);
    o && this.scrollToNode(o);
  }
  scrollToNode(n) {
    var C;
    const { unitId: e, scene: t, mainComponent: o } = this._context, r = this._docSkeletonManagerService.getSkeleton();
    if (o == null || r == null)
      return;
    const s = o.getOffsetConfig(), { docsLeft: i, docsTop: a } = s, c = new It(s, r), { contentBoxPointGroup: d } = c.getRangePointData(n, n), { left: l, top: A, height: h } = Jn(d), u = l + i, g = A + a, f = t.getViewport(We.VIEW_MAIN), p = this._editorService.getEditor(e);
    if (f == null)
      return;
    const {
      left: m,
      top: I,
      right: S,
      bottom: v
    } = f.getBounding().viewBound;
    let R = 0, E = 0;
    const b = p ? (C = p.params.backScrollOffset) != null ? C : 0 : 100;
    g < I ? R = g - I - b : g > v - h && (R = g - v + h + b), u < m ? E = u - m : u > S - Li && (E = u - S + Li);
    const y = f.transViewportScroll2ScrollValue(E, R);
    f.scrollByBarDeltaValue(y);
  }
  // Let the selection show on the current screen.
  _scrollToSelection() {
    const n = this._textSelectionManagerService.getActiveTextRange();
    if (n == null)
      return;
    const { collapsed: e, startNodePosition: t } = n;
    e && this.scrollToNode(t);
  }
};
uo = pg([
  rr(1, j(Y)),
  rr(2, Ge),
  rr(3, j(de))
], uo);
var mg = Object.getOwnPropertyDescriptor, Eg = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? mg(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, zt = (n, e) => (t, o) => e(t, o, n);
let br = class extends Ct {
  constructor(n, e, t, o, r, s, i) {
    super(), this._context = n, this._commandService = e, this._docSelectionRenderService = t, this._docSkeletonManagerService = o, this._editorService = r, this._renderManagerService = s, this._univerInstanceService = i, this._addNewRender(), this._initRenderRefresh(), this._initCommandListener();
  }
  reRender(n) {
    var s, i;
    const e = (s = this._renderManagerService.getRenderById(n)) == null ? void 0 : s.with(de), t = e == null ? void 0 : e.getSkeleton();
    if (!t || !!t.getViewModel().getDataModel().getSnapshot().disabled)
      return;
    t.calculate();
    const r = this._editorService.getEditor(n);
    if (this._editorService.isEditor(n) && !(r != null && r.params.scrollBar)) {
      (i = this._context.mainComponent) == null || i.makeDirty();
      return;
    }
    this._recalculateSizeBySkeleton(t);
  }
  _addNewRender() {
    const { scene: n, engine: e } = this._context, t = new ul(We.VIEW_MAIN, n, {
      left: 0,
      top: 0,
      bottom: 0,
      right: 0,
      isWheelPreventDefaultX: !0
    });
    n.attachControl(), n.onMouseWheel$.subscribeEvent((r, s) => {
      const i = this._univerInstanceService.getCurrentUnitForType(_.UNIVER_DOC);
      if ((i == null ? void 0 : i.getUnitId()) !== this._context.unitId)
        return;
      const a = r;
      if (a.ctrlKey) {
        const c = Math.abs(a.deltaX);
        let d = c < 40 ? 0.2 : c < 80 ? 0.4 : 0.2;
        d *= a.deltaY > 0 ? -1 : 1, n.scaleX < 1 && (d /= 2), n.scaleX + d > 4 ? n.scale(4, 4) : n.scaleX + d < 0.1 ? n.scale(0.1, 0.1) : a.preventDefault();
      } else
        t.onMouseWheel(a, s);
    }), new lr(t), n.addLayer(
      new zs(n, [], zo),
      new zs(n, [], id)
    ), this._addComponent();
    const o = () => n.render();
    this.disposeWithMe(this._context.activated$.subscribe((r) => {
      r ? e.runRenderLoop(o) : e.stopRenderLoop(o);
    })), this._docSelectionRenderService.__attachScrollEvent();
  }
  _addComponent() {
    const { scene: n, unit: e, components: t } = this._context, s = {
      pageMarginLeft: 20,
      pageMarginTop: 20
    }, i = new hl($e.MAIN, void 0, s);
    i.zIndex = Js;
    const a = new gl($e.BACKGROUND, void 0, s);
    a.zIndex = Js, this._context.mainComponent = i, t.set($e.MAIN, i), t.set($e.BACKGROUND, a), n.addObjects([i], zo), n.addObjects([a], sd), this._editorService.getEditor(e.getUnitId()) == null && n.enableLayerCache(zo);
  }
  _initRenderRefresh() {
    this._docSkeletonManagerService.currentSkeletonBefore$.pipe(ft(this.dispose$)).subscribe((n) => {
      this._create(n);
    });
  }
  _create(n) {
    var a;
    if (!n)
      return;
    const { mainComponent: e, components: t } = this._context, o = e, r = t.get($e.BACKGROUND);
    o.changeSkeleton(n), r.changeSkeleton(n);
    const { unitId: s } = this._context, i = this._editorService.getEditor(s);
    if (this._editorService.isEditor(s) && !(i != null && i.params.scrollBar)) {
      (a = this._context.mainComponent) == null || a.makeDirty();
      return;
    }
    this._recalculateSizeBySkeleton(n);
  }
  _initCommandListener() {
    const n = [X.id];
    this.disposeWithMe(this._commandService.onCommandExecuted((e) => {
      if (n.includes(e.id)) {
        const t = e.params, { unitId: o } = t;
        this.reRender(o);
      }
    }));
  }
  _recalculateSizeBySkeleton(n) {
    var u;
    const { mainComponent: e, scene: t, unitId: o, components: r } = this._context, s = e, i = r.get($e.BACKGROUND), a = (u = n.getSkeletonData()) == null ? void 0 : u.pages;
    if (a == null)
      return;
    let c = 0, d = 0;
    const A = this._context.unit.getSnapshot().documentStyle.documentFlavor;
    for (let g = 0, f = a.length; g < f; g++) {
      const p = a[g];
      let { pageWidth: m, pageHeight: I } = p;
      if (A === Pe.MODERN) {
        const S = Ig(p);
        m = S.pageWidth, I = S.pageHeight;
      }
      s.pageLayoutType === Cn.VERTICAL ? (d += I, d += s.pageMarginTop, g === f - 1 && (d += s.pageMarginTop), c = Math.max(c, m)) : s.pageLayoutType === Cn.HORIZONTAL && (c += m, g !== f - 1 && (c += s.pageMarginLeft), d = Math.max(d, I));
    }
    s.resize(c, d), i.resize(c, d);
    const h = this._editorService.getEditor(o);
    (!this._editorService.isEditor(o) || h != null && h.params.scrollBar) && t.resize(c, d);
  }
};
br = Eg([
  zt(1, T),
  zt(2, j(Re)),
  zt(3, j(de)),
  zt(4, Ge),
  zt(5, pe),
  zt(6, L)
], br);
function Ig(n) {
  let { pageWidth: e, pageHeight: t } = n;
  const { marginLeft: o, marginRight: r, marginTop: s, marginBottom: i, skeDrawings: a, skeTables: c } = n;
  e === Number.POSITIVE_INFINITY && (e = n.width + o + r), t === Number.POSITIVE_INFINITY && (t = n.height + s + i);
  for (const d of a.values())
    e = Math.max(e, d.aLeft + d.width + o + r), t = Math.max(t, d.aTop + d.height + s + i);
  for (const d of c.values())
    e = Math.max(e, d.left + d.width + o + r), t = Math.max(t, d.top + d.height + s + i);
  return { pageWidth: e, pageHeight: t };
}
var Sg = Object.getOwnPropertyDescriptor, vg = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? Sg(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, sr = (n, e) => (t, o) => e(t, o, n);
let yr = class {
  constructor(n, e, t) {
    O(this, "_docContainer");
    // SheetContainer
    O(this, "getComponent", (n) => {
      if (this._docContainer = n, !n.getContentRef().current)
        throw new Error("container is not ready");
    });
    /**
     * Change language
     * @param {string} lang new language
     *
     * e: {target: HTMLSelectElement } reference from  https://stackoverflow.com/a/48443771
     *
     */
    O(this, "changeLocale", (n) => {
      this._localeService.setLocale(n);
    });
    this._localeService = n, this._injector = e, this._configService = t;
  }
  getUIConfig() {
    return {
      injector: this._injector,
      config: this._configService.getConfig(Vo),
      changeLocale: this.changeLocale,
      getComponent: this.getComponent
    };
  }
  getContentRef() {
    return this._docContainer.getContentRef();
  }
  UIDidMount(n) {
    if (this._docContainer)
      return n(this._docContainer);
  }
  getDocContainer() {
    return this._docContainer;
  }
};
yr = vg([
  sr(0, j(Ye)),
  sr(1, j(Dn)),
  sr(2, Vr)
], yr);
var Cg = Object.getOwnPropertyDescriptor, Rg = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? Cg(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, bg = (n, e) => (t, o) => e(t, o, n);
let ho = class extends Ct {
  constructor(e) {
    super();
    O(this, "_docContainerController");
    this._injector = e, this._docContainerController = this._injector.createInstance(yr);
  }
};
ho = Rg([
  bg(0, j(Dn))
], ho);
var yg = Object.getOwnPropertyDescriptor, xg = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? yg(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, Qi = (n, e) => (t, o) => e(t, o, n);
let go = class extends me {
  constructor(n, e) {
    super(), this._docAutoFormatService = n, this._renderManagerService = e, this._initListTabAutoFormat(), this._initSpaceAutoFormat(), this._initDefaultEnterFormat(), this._initExitListAutoFormat();
  }
  _initListTabAutoFormat() {
    this.disposeWithMe(
      this._docAutoFormatService.registerAutoFormat({
        id: Jt.id,
        match: (n) => {
          var r;
          const { selection: e, paragraphs: t, unit: o } = n;
          if (t.length === 1 && e.startOffset === t[0].paragraphStart && t[0].bullet) {
            const s = (r = o.getBody()) == null ? void 0 : r.paragraphs, i = s == null ? void 0 : s.filter((a) => {
              var c;
              return ((c = a.bullet) == null ? void 0 : c.listId) === t[0].bullet.listId;
            });
            return (i == null ? void 0 : i.findIndex((a) => a.startIndex === t[0].startIndex)) !== 0;
          } else if (t.length > 1 && t.some((s) => s.bullet))
            return !0;
          return !1;
        },
        // traverse all paragraphs, set paragraph
        getMutations(n) {
          const e = n.commandParams;
          return [{
            id: gr.id,
            params: {
              type: e != null && e.shift ? qn.decrease : qn.increase
            }
          }];
        },
        priority: 100
      })
    ), this.disposeWithMe(
      this._docAutoFormatService.registerAutoFormat({
        id: Jt.id,
        match: (n) => {
          const { selection: e, unit: t } = n, { startNodePosition: o, endNodePosition: r } = e, s = this._renderManagerService.getRenderById(t.getUnitId()), i = s == null ? void 0 : s.with(de).getSkeleton();
          return i == null ? !1 : !!(o && r && Ha(i, o, r) || o && !r && o.path.indexOf("cells") > -1);
        },
        getMutations(n) {
          const e = n.commandParams;
          return [{
            id: za.id,
            params: {
              shift: !!(e != null && e.shift)
            }
          }];
        },
        priority: 99
      })
    );
  }
  _initSpaceAutoFormat() {
    this.disposeWithMe(
      this._docAutoFormatService.registerAutoFormat({
        id: Mo.id,
        match: (n) => {
          var s;
          const { selection: e, paragraphs: t, unit: o } = n;
          if (!e.collapsed || t.length !== 1 || !e.collapsed)
            return !1;
          const r = (s = o.getBody()) == null ? void 0 : s.dataStream.slice(t[0].paragraphStart, e.startOffset - 1);
          return !!(r && (Object.keys(jo).includes(r) || Object.keys(qo).includes(r)));
        },
        getMutations(n) {
          var s;
          const { paragraphs: e, unit: t, selection: o } = n, r = (s = t.getBody()) == null ? void 0 : s.dataStream.slice(e[0].paragraphStart, o.startOffset - 1);
          if (r && Object.keys(jo).includes(r)) {
            const i = jo[r];
            return [{
              id: Na.id,
              params: {
                listType: i,
                paragraph: e[0]
              }
            }];
          }
          if (r && Object.keys(qo).includes(r)) {
            const i = qo[r];
            return [{
              id: La.id,
              params: {
                value: i
              }
            }];
          }
          return [];
        }
      })
    );
  }
  _initExitListAutoFormat() {
    this.disposeWithMe(
      this._docAutoFormatService.registerAutoFormat({
        id: bn.id,
        match: (n) => {
          const { paragraphs: e } = n;
          return !!(e.length === 1 && e[0].bullet && e[0].paragraphStart === e[0].paragraphEnd);
        },
        getMutations: (n) => {
          const e = n.paragraphs[0].bullet;
          return e ? e.nestingLevel > 0 ? [{
            id: gr.id,
            params: {
              type: qn.decrease
            }
          }] : [{
            id: Fn.id,
            params: {
              listType: n.paragraphs[0].bullet.listType
            }
          }] : [];
        }
      })
    );
  }
  _initDefaultEnterFormat() {
    this.disposeWithMe(
      this._docAutoFormatService.registerAutoFormat({
        id: bn.id,
        match: () => !0,
        getMutations() {
          return [{
            id: Gr.id
          }];
        },
        priority: -9999
      })
    );
  }
};
go = xg([
  Qi(0, j(wt)),
  Qi(1, pe)
], go);
function Og(n) {
  return n.rows[0].cells[0].sections[0].columns[0].lines[0];
}
function Tg(n) {
  const e = n.rows[n.rows.length - 1], t = e.cells[e.cells.length - 1];
  return fl(t);
}
function Bg(n, e) {
  const { ed: t } = n, { skeTables: o } = e;
  let r = null;
  for (const s of o.values())
    if (s.st === t + 1) {
      r = s;
      break;
    }
  return r;
}
function Ui(n) {
  const e = n == null ? void 0 : n.parent;
  let t = null, o = null;
  if (n == null || e == null)
    return {
      lineBeforeTable: t,
      lineAfterTable: o
    };
  const { st: r, ed: s } = n, i = e.type === Oe.CELL ? [e] : e.parent.pages;
  return pl(i, (a) => {
    a.st === s + 1 ? o = a : a.ed === r - 1 && (t = a);
  }), {
    lineBeforeTable: t,
    lineAfterTable: o
  };
}
function Rc(n) {
  return n.sections[0].columns[0].lines.length === 0;
}
function bc(n) {
  var i, a;
  const e = n.parent, t = e == null ? void 0 : e.parent, o = t == null ? void 0 : t.tableId;
  if (e == null || t == null)
    return;
  const r = e.cells.indexOf(n);
  let s = t.rows[t.rows.indexOf(e) + 1];
  if (s == null && o.indexOf("#-#")) {
    const [c, d] = o.split("#-#"), l = (a = (i = t.parent) == null ? void 0 : i.parent) == null ? void 0 : a.pages, A = `${c}#-#${Number.parseInt(d) + 1}`;
    if (l)
      for (const h of l) {
        const { skeTables: u } = h;
        if (u.has(A)) {
          const g = u.get(A);
          if (g != null && g.rows.length) {
            s = g.rows.find((f) => !f.isRepeatRow);
            break;
          }
        }
      }
  }
  if (s != null) {
    const c = s.cells[r];
    return Rc(c) ? bc(c) : c;
  }
}
function yc(n) {
  var s, i;
  const e = n.parent, t = e == null ? void 0 : e.parent;
  if (e == null || t == null)
    return;
  let o = t.rows[t.rows.indexOf(e) - 1];
  const r = e.cells.indexOf(n);
  if ((o == null || o.isRepeatRow) && t.tableId.indexOf("#-#")) {
    const [a, c] = t.tableId.split("#-#"), d = (i = (s = t.parent) == null ? void 0 : s.parent) == null ? void 0 : i.pages, l = `${a}#-#${Number.parseInt(c) - 1}`;
    if (d)
      for (const A of d) {
        const { skeTables: h } = A;
        if (h.has(l)) {
          const u = h.get(l);
          if (u != null && u.rows.length) {
            o = u.rows[u.rows.length - 1];
            break;
          }
        }
      }
  }
  if (o != null) {
    const a = o.cells[r];
    return Rc(a) ? yc(a) : a;
  }
}
function Mg(n, e) {
  const { st: t } = n, { skeTables: o } = e;
  let r = null;
  for (const s of o.values())
    if (s.ed === t - 1) {
      r = s;
      break;
    }
  return r;
}
function _g(n) {
  return n.sections[0].columns[0].lines[0];
}
function Dg(n) {
  const e = ml(n);
  return e.lines[e.lines.length - 1];
}
var wg = Object.getOwnPropertyDescriptor, Pg = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? wg(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, jn = (n, e) => (t, o) => e(t, o, n);
let fo = class extends me {
  constructor(e, t, o, r) {
    super();
    O(this, "_onInputSubscription");
    this._univerInstanceService = e, this._renderManagerService = t, this._textSelectionManagerService = o, this._commandService = r, this._commandExecutedListener();
  }
  dispose() {
    var e;
    super.dispose(), (e = this._onInputSubscription) == null || e.unsubscribe();
  }
  _commandExecutedListener() {
    const e = [St.id, vt.id];
    this.disposeWithMe(
      this._commandService.onCommandExecuted((t) => {
        if (!e.includes(t.id))
          return;
        const o = t.params;
        switch (t.id) {
          case St.id:
            return this._handleMoveCursor(o.direction);
          case vt.id:
            return this._handleShiftMoveSelection(o.direction);
          default:
            throw new Error("Unknown command");
        }
      })
    );
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _handleShiftMoveSelection(e) {
    var S, v, R;
    const t = this._textSelectionManagerService.getActiveTextRange(), o = this._textSelectionManagerService.getTextRanges(), r = this._univerInstanceService.getCurrentUniverDocInstance();
    if (r == null)
      return;
    const s = (S = this._renderManagerService.getRenderById(r.getUnitId())) == null ? void 0 : S.with(de).getSkeleton(), i = this._getDocObject();
    if (t == null || s == null || i == null)
      return;
    const {
      startOffset: a,
      endOffset: c,
      style: d,
      collapsed: l,
      direction: A,
      segmentId: h,
      startNodePosition: u,
      endNodePosition: g,
      segmentPage: f
    } = t;
    if (o.length > 1) {
      let E = Number.POSITIVE_INFINITY, b = Number.NEGATIVE_INFINITY;
      for (const y of o)
        E = Math.min(E, y.startOffset), b = Math.max(b, y.endOffset);
      this._textSelectionManagerService.replaceTextRanges([
        {
          startOffset: e === le.LEFT || e === le.UP ? b : E,
          endOffset: e === le.LEFT || e === le.UP ? E : b,
          style: d
        }
      ], !1);
      return;
    }
    const p = l || A === De.FORWARD ? a : c;
    let m = l || A === De.FORWARD ? c : a;
    const I = (v = r.getSelfOrHeaderFooterModel(h).getBody().dataStream.length) != null ? v : Number.POSITIVE_INFINITY;
    if (e === le.LEFT || e === le.RIGHT) {
      const E = s.findNodeByCharIndex(m - 1, h, f), b = s.findNodeByCharIndex(m, h, f);
      m = e === le.RIGHT ? m + b.count : m - ((R = E == null ? void 0 : E.count) != null ? R : 0), m = Math.min(I - 2, Math.max(0, m)), this._textSelectionManagerService.replaceTextRanges([
        {
          startOffset: p,
          endOffset: m,
          style: d
        }
      ], !1), this._scrollToFocusNodePosition(r.getUnitId(), m);
    } else {
      const E = s.findNodeByCharIndex(m, h, f), b = i.document.getOffsetConfig(), y = l ? u : A === De.FORWARD ? g : u, C = this._getTopOrBottomPosition(s, E, y, e === le.DOWN, !0);
      if (C == null) {
        const x = e === le.UP ? 0 : I - 2;
        if (x === m)
          return;
        this._textSelectionManagerService.replaceTextRanges([
          {
            startOffset: p,
            endOffset: x,
            style: d
          }
        ], !1);
        return;
      }
      const B = new It(b, s).getRangePointData(
        C,
        C
      ).cursorList[0];
      this._textSelectionManagerService.replaceTextRanges([
        {
          startOffset: p,
          endOffset: B.endOffset,
          style: d
        }
      ], !1), this._scrollToFocusNodePosition(r.getUnitId(), B.endOffset);
    }
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _handleMoveCursor(e) {
    var I, S, v, R;
    const t = this._textSelectionManagerService.getActiveTextRange(), o = this._textSelectionManagerService.getTextRanges(), r = this._univerInstanceService.getCurrentUniverDocInstance();
    if (r == null)
      return !1;
    const s = (I = this._renderManagerService.getRenderById(r.getUnitId())) == null ? void 0 : I.with(de).getSkeleton(), i = this._getDocObject();
    if (t == null || s == null || i == null || o == null)
      return;
    const { startOffset: a, endOffset: c, style: d, collapsed: l, segmentId: A, startNodePosition: h, endNodePosition: u, segmentPage: g } = t, f = r.getSelfOrHeaderFooterModel(A).getBody();
    if (f == null)
      return;
    const p = (S = f.dataStream.length) != null ? S : Number.POSITIVE_INFINITY, m = (v = r.getCustomRanges()) != null ? v : [];
    if (e === le.LEFT || e === le.RIGHT) {
      let E;
      if (!t.collapsed || o.length > 1) {
        let C = Number.POSITIVE_INFINITY, B = Number.NEGATIVE_INFINITY;
        for (const x of o)
          C = Math.min(C, x.startOffset), B = Math.max(B, x.endOffset);
        E = e === le.LEFT ? C : B;
      } else {
        const C = s.findNodeByCharIndex(a - 1, A, g), B = s.findNodeByCharIndex(a, A, g), x = s.findNodeByCharIndex(a + 1, A, g);
        e === le.LEFT ? E = Math.max(0, a - ((R = C == null ? void 0 : C.count) != null ? R : 1)) : E = Math.min(p - 2, c + B.count + ((x == null ? void 0 : x.streamType) === V.SECTION_BREAK ? 1 : 0));
      }
      const b = [
        V.TABLE_START,
        V.TABLE_END,
        V.TABLE_ROW_START,
        V.TABLE_ROW_END,
        V.TABLE_CELL_START,
        V.TABLE_CELL_END,
        V.SECTION_BREAK
      ];
      if (e === le.LEFT)
        for (; b.includes(f.dataStream[E]); )
          E--;
      else
        for (; b.includes(f.dataStream[E]); )
          E++;
      m.filter((C) => C.wholeEntity && C.startIndex < E && C.endIndex >= E).forEach((C) => {
        e === le.LEFT ? E = Math.min(C.startIndex, E) : E = Math.max(C.endIndex + 1, E);
      }), this._textSelectionManagerService.replaceTextRanges([
        {
          startOffset: Math.max(0, E),
          endOffset: Math.max(0, E),
          style: d
        }
      ], !1), this._scrollToFocusNodePosition(r.getUnitId(), E);
    } else {
      const E = s.findNodeByCharIndex(a, A, g), b = s.findNodeByCharIndex(c, A, g), y = i.document.getOffsetConfig(), C = this._getTopOrBottomPosition(
        s,
        e === le.UP || l ? E : b,
        e === le.UP || l ? h : u,
        e === le.DOWN
      );
      if (C == null) {
        let x;
        l ? x = e === le.UP ? 0 : p - 2 : x = e === le.UP ? a : c, this._textSelectionManagerService.replaceTextRanges([
          {
            startOffset: Math.max(0, x),
            endOffset: Math.max(0, x),
            style: d
          }
        ], !1);
        return;
      }
      const B = new It(y, s).getRangePointData(
        C,
        C
      ).cursorList[0];
      this._textSelectionManagerService.replaceTextRanges([
        {
          ...B,
          style: d
        }
      ], !1), this._scrollToFocusNodePosition(r.getUnitId(), B.endOffset);
    }
  }
  _getTopOrBottomPosition(e, t, o, r, s = !1) {
    if (t == null || o == null)
      return;
    const i = this._getGlyphLeftOffsetInLine(t), a = this._getNextOrPrevLine(t, r, s);
    if (a == null)
      return;
    const c = this._matchPositionByLeftOffset(e, a, i, o);
    if (c != null)
      return { ...c, isBack: !0 };
  }
  _getGlyphLeftOffsetInLine(e) {
    const t = e.parent;
    if (t == null)
      return Number.NEGATIVE_INFINITY;
    const o = t.left, { left: r } = e;
    return o + r;
  }
  _matchPositionByLeftOffset(e, t, o, r) {
    const s = {
      distance: Number.POSITIVE_INFINITY
    };
    for (const a of t.divides) {
      const c = a.left;
      for (const d of a.glyphGroup) {
        if (d.streamType === V.SECTION_BREAK)
          continue;
        const { left: l } = d, A = c + l, h = Math.abs(o - A);
        h < s.distance && (s.glyph = d, s.distance = h);
      }
    }
    if (s.glyph == null)
      return;
    const { segmentPage: i } = r;
    return e.findPositionByGlyph(s.glyph, i);
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _getNextOrPrevLine(e, t, o = !1) {
    var f, p, m, I, S, v, R, E, b, y, C, B;
    const r = e.parent, s = r == null ? void 0 : r.parent, i = s == null ? void 0 : s.parent, a = i == null ? void 0 : i.parent, c = a == null ? void 0 : a.parent;
    if (r == null || s == null || i == null || a == null || c == null)
      return;
    const d = i.lines.indexOf(s);
    if (d === -1)
      return;
    let l;
    if (c.type === Oe.CELL && o) {
      const x = Fi(c, t);
      if (x)
        return x;
    }
    if (t === !0) {
      l = i.lines[d + 1];
      const x = Bg(s, c);
      if (x) {
        const M = Og(x);
        M && (l = M);
      }
    } else {
      l = i.lines[d - 1];
      const x = Mg(s, c);
      if (x) {
        const M = Tg(x);
        M && (l = M);
      }
    }
    if (l != null)
      return l;
    const A = a.columns.indexOf(i);
    if (A === -1)
      return;
    if (t === !0)
      l = (f = a.columns[A + 1]) == null ? void 0 : f.lines[0];
    else {
      const x = (m = (p = a.columns) == null ? void 0 : p[A - 1]) == null ? void 0 : m.lines;
      l = x == null ? void 0 : x[x.length - 1];
    }
    if (l != null)
      return l;
    const h = c.sections.indexOf(a);
    if (h === -1)
      return;
    if (t === !0)
      l = (S = (I = c.sections[h - 1]) == null ? void 0 : I.columns[0]) == null ? void 0 : S.lines[0];
    else {
      const x = (R = (v = c.sections) == null ? void 0 : v[h - 1]) == null ? void 0 : R.columns, M = x == null ? void 0 : x[x.length - 1], w = M == null ? void 0 : M.lines;
      l = w == null ? void 0 : w[w.length - 1];
    }
    if (l != null)
      return l;
    if (c.type === Oe.CELL)
      return Fi(c, t);
    const u = c.parent;
    if (u == null)
      return;
    const g = u.pages.indexOf(c);
    if (g !== -1) {
      if (t === !0)
        l = (y = (b = (E = u.pages[g + 1]) == null ? void 0 : E.sections[0]) == null ? void 0 : b.columns[0]) == null ? void 0 : y.lines[0];
      else {
        const x = (C = u.pages[g - 1]) == null ? void 0 : C.sections;
        if (x == null)
          return;
        const M = (B = x[x.length - 1]) == null ? void 0 : B.columns, w = M[M.length - 1], F = w == null ? void 0 : w.lines;
        l = F[F.length - 1];
      }
      if (l != null)
        return l;
    }
  }
  _scrollToFocusNodePosition(e, t) {
    var r;
    const o = (r = this._renderManagerService.getRenderById(e)) == null ? void 0 : r.with(uo);
    o != null && o.scrollToRange({
      startOffset: t,
      endOffset: t,
      collapsed: !0
    });
  }
  _getDocObject() {
    return ad(this._univerInstanceService, this._renderManagerService);
  }
};
fo = Pg([
  jn(0, L),
  jn(1, pe),
  jn(2, j(Y)),
  jn(3, T)
], fo);
function Fi(n, e) {
  var o, r;
  let t = null;
  if (e === !0) {
    const s = bc(n);
    if (s)
      t = _g(s);
    else {
      const i = (o = n.parent) == null ? void 0 : o.parent, { lineAfterTable: a } = Ui(i);
      a && (t = a);
    }
  } else {
    const s = yc(n);
    if (s)
      t = Dg(s);
    else {
      const i = (r = n.parent) == null ? void 0 : r.parent, { lineBeforeTable: a } = Ui(i);
      a && (t = a);
    }
  }
  return t;
}
const Ng = ({
  handleRowColChange: n,
  tableCreateParams: e
}) => {
  const t = J(Ye), [o, r] = Ee(3), [s, i] = Ee(5);
  function a(c, d) {
    r(c), i(d), n(c, d);
  }
  return Ce(() => {
    r(e.rowCount), i(e.colCount);
  }, [e]), /* @__PURE__ */ re("div", { className: "univer-flex univer-items-center univer-justify-between univer-gap-2", children: [
    /* @__PURE__ */ re("div", { className: "univer-flex univer-items-center univer-gap-2", children: [
      /* @__PURE__ */ Q("span", { children: t.t("toolbar.table.rowCount") }),
      /* @__PURE__ */ Q(
        it,
        {
          className: "univer-w-28",
          min: 1,
          max: 20,
          precision: 0,
          value: o,
          onChange: (c) => {
            a(c, s);
          }
        }
      )
    ] }),
    /* @__PURE__ */ re("div", { className: "univer-flex univer-items-center univer-gap-2", children: [
      /* @__PURE__ */ Q("span", { children: t.t("toolbar.table.colCount") }),
      /* @__PURE__ */ Q(
        it,
        {
          className: "univer-w-28",
          min: 1,
          max: 20,
          precision: 0,
          value: s,
          onChange: (c) => {
            a(o, c);
          }
        }
      )
    ] })
  ] });
};
var Lg = Object.getOwnPropertyDescriptor, Qg = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? Lg(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, Hi = (n, e) => (t, o) => e(t, o, n);
let po = class extends me {
  constructor(n, e) {
    super(), this._commandService = n, this._componentManager = e, this._initialize();
  }
  _initialize() {
    this._init(), this._registerCommands(), this._initCustomComponents();
  }
  _registerCommands() {
    [
      Os
    ].forEach((n) => this.disposeWithMe(this._commandService.registerCommand(n)));
  }
  _initCustomComponents() {
    const n = this._componentManager;
    this.disposeWithMe(n.register(Ga, Ng));
  }
  _init() {
  }
};
po = Qg([
  Hi(0, T),
  Hi(1, j(rn))
], po);
var Ug = Object.getOwnPropertyDescriptor, Fg = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? Ug(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, zn = (n, e) => (t, o) => e(t, o, n);
let xr = class extends me {
  constructor(n, e, t, o, r) {
    super(), this._context = n, this._docSkeletonManagerService = e, this._commandService = t, this._docEventManagerService = o, this._textSelectionManagerService = r, this._initPointerDownObserver(), this._initHoverCursor();
  }
  _initPointerDownObserver() {
    this._docEventManagerService.clickBullets$.subscribe((n) => {
      const e = this._textSelectionManagerService.getTextRanges();
      this._commandService.executeCommand(Pa.id, {
        index: n.paragraph.startIndex,
        segmentId: n.segmentId,
        textRanges: e
      });
    });
  }
  _initHoverCursor() {
    this.disposeWithMe(
      this._docEventManagerService.hoverBullet$.subscribe((n) => {
        n ? this._context.mainComponent.setCursor(Dt.POINTER) : this._context.mainComponent.setCursor(Dt.TEXT);
      })
    );
  }
  _getTransformCoordForDocumentOffset(n, e, t, o) {
    const { documentTransform: r } = n.getOffsetConfig(), s = e.transformVector2SceneCoord(vn.FromArray([t, o]));
    if (s)
      return r.clone().invert().applyPoint(s);
  }
};
xr = Fg([
  zn(1, j(de)),
  zn(2, T),
  zn(3, j(Pt)),
  zn(4, j(Y))
], xr);
var Hg = Object.getOwnPropertyDescriptor, kg = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? Hg(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, An = (n, e) => (t, o) => e(t, o, n);
let mo = class extends Ct {
  constructor(n, e, t, o, r, s) {
    super(), this._context = n, this._commandService = e, this._docClipboardService = t, this._docSelectionRenderService = o, this._contextService = r, this._editorService = s, this._init();
  }
  _init() {
    this._initLegacyPasteCommand();
  }
  _initLegacyPasteCommand() {
    var n;
    (n = this._docSelectionRenderService) == null || n.onPaste$.pipe(ft(this.dispose$)).subscribe((e) => {
      var a, c, d;
      if (!wo(this._contextService))
        return;
      e.event.preventDefault();
      const t = e.event;
      let o = (a = t.clipboardData) == null ? void 0 : a.getData(sa);
      const r = (c = t.clipboardData) == null ? void 0 : c.getData(ia), s = [...((d = t.clipboardData) == null ? void 0 : d.items) || []].filter((l) => Hl.has(l.type)).map((l) => l.getAsFile()).filter((l) => !!l);
      this._editorService.getEditor(this._context.unitId) && (o != null ? o : "").indexOf("</table>") > -1 && (o = ""), this._docClipboardService.legacyPaste({ html: o, text: r, files: s });
    });
  }
};
mo = kg([
  An(1, T),
  An(2, Lt),
  An(3, j(Re)),
  An(4, Fr),
  An(5, Ge)
], mo);
var Vg = Object.getOwnPropertyDescriptor, Wg = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? Vg(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, ki = (n, e) => (t, o) => e(t, o, n);
const jg = [
  qi,
  Gc,
  bo,
  nt
];
let Or = class extends me {
  constructor(n, e, t) {
    super(), this._context = n, this._contextMenuService = e, this._commandService = t, jg.includes(this._context.unitId) || (this._initPointerDown(), this._initEditChange());
  }
  _initPointerDown() {
    var t, o;
    const e = ((o = (t = this._context) == null ? void 0 : t.mainComponent) == null ? void 0 : o.onPointerDown$).subscribeEvent((r) => {
      r.button === 2 && this._contextMenuService.triggerContextMenu(r, no.MAIN_AREA);
    });
    this.disposeWithMe(e);
  }
  _initEditChange() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((n) => {
        n.id === X.id && this._contextMenuService.visible && this._contextMenuService.hideContextMenu();
      })
    );
  }
};
Or = Wg([
  ki(1, kl),
  ki(2, T)
], Or);
var zg = Object.getOwnPropertyDescriptor, Gg = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? zg(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, Gt = (n, e) => (t, o) => e(t, o, n);
let Eo = class extends me {
  constructor(e, t, o, r, s, i, a) {
    super();
    O(this, "_initialEditors", /* @__PURE__ */ new Set());
    this._context = e, this._univerInstanceService = t, this._editorService = o, this._commandService = r, this._docSelectionRenderService = s, this._docSkeletonManagerService = i, this._renderManagerService = a, this._initialize();
  }
  _initialize() {
    this._editorService.getAllEditor().forEach((e) => {
      const t = e.getEditorId();
      t === this._context.unitId && (this._initialEditors.has(t) || (this._initialEditors.add(t), this._resize(t)));
    }), this._commandExecutedListener(), this._initialBlur(), this._initialFocus();
  }
  _resize(e) {
    if (e == null)
      return;
    const t = this._editorService.getEditor(e);
    if ((t == null ? void 0 : t.cancelDefaultResizeListener) === !0)
      return;
    const o = this._univerInstanceService.getUniverDocInstance(e);
    if (!o)
      return;
    const r = this._docSkeletonManagerService.getSkeleton();
    if (t == null || t.render == null || r == null || o == null)
      return;
    r.calculate();
    const { marginTop: s = 0, marginBottom: i = 0, marginLeft: a = 0, marginRight: c = 0 } = o.getSnapshot().documentStyle, { scene: d, mainComponent: l } = t.render;
    let { actualHeight: A, actualWidth: h } = r.getActualSize();
    A += s + i, h += a + c;
    const { width: u, height: g } = t.getBoundingClientRect(), f = Math.max(h, u), p = Math.max(A, g);
    d.transformByState({
      width: f,
      height: p
    }), l == null || l.resize(f, p);
  }
  _initialBlur() {
    this.disposeWithMe(
      this._editorService.blur$.subscribe(() => {
        this._docSelectionRenderService.blur();
      })
    ), this.disposeWithMe(
      this._docSelectionRenderService.onBlur$.subscribe(() => {
        const { unitId: e } = this._context, t = this._editorService.getEditor(e), o = this._editorService.getFocusEditor();
        t == null || t.isSheetEditor() || o && o.getEditorId() === e || e.includes("range_selector") || e.includes("embedding_formula_editor") || this._editorService.blur();
      })
    );
  }
  _initialFocus() {
    const e = [
      "univer-formula-search",
      "univer-formula-help",
      "formula-help-decorator",
      "univer-formula-help-param"
    ];
    this.disposeWithMe(
      je(window, "mousedown").subscribe((o) => {
        const s = o.target.classList[0] || "";
        Yc(s, e) && o.stopPropagation();
      })
    );
    const t = new In();
    this.disposeWithMe(
      this._univerInstanceService.getCurrentTypeOfUnit$(_.UNIVER_SHEET).subscribe((o) => {
        if (t.dispose(), !o)
          return;
        const r = o.getUnitId(), s = this._renderManagerService.getRenderById(r), i = s == null ? void 0 : s.engine.getCanvas().getCanvasEle();
        if (i == null)
          return;
        const a = je(i, "mousedown").subscribe((c) => {
          c.stopPropagation();
        });
        t.add(a);
      })
    ), this.disposeWithMe(() => t.dispose());
  }
  /**
   * Listen to document edits to refresh the size of the formula editor.
   */
  _commandExecutedListener() {
    const e = [X.id];
    this.disposeWithMe(
      this._commandService.onCommandExecuted((t) => {
        if (e.includes(t.id)) {
          const o = t.params, { unitId: r } = o;
          if (this._editorService.isSheetEditor(r) || r !== this._context.unitId)
            return;
          const s = this._editorService.getEditor(r);
          s && !s.params.scrollBar && this._resize(r);
        }
      })
    );
  }
};
Eo = Gg([
  Gt(1, L),
  Gt(2, Ge),
  Gt(3, T),
  Gt(4, j(Re)),
  Gt(5, j(de)),
  Gt(6, pe)
], Eo);
var Yg = Object.getOwnPropertyDescriptor, Kg = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? Yg(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, Gn = (n, e) => (t, o) => e(t, o, n);
let Tr = class extends me {
  constructor(e, t, o, r, s) {
    super();
    O(this, "_previousIMEContent", "");
    O(this, "_isCompositionStart", !0);
    O(this, "_onStartSubscription");
    O(this, "_onUpdateSubscription");
    O(this, "_onEndSubscription");
    this._context = e, this._docSelectionRenderService = t, this._docImeInputManagerService = o, this._docSkeletonManagerService = r, this._commandService = s, this._initialize();
  }
  dispose() {
    var e, t, o;
    (e = this._onStartSubscription) == null || e.unsubscribe(), (t = this._onUpdateSubscription) == null || t.unsubscribe(), (o = this._onEndSubscription) == null || o.unsubscribe();
  }
  _initialize() {
    this._initialOnCompositionstart(), this._initialOnCompositionUpdate(), this._initialOnCompositionend();
  }
  _initialOnCompositionstart() {
    this._onStartSubscription = this._docSelectionRenderService.onCompositionstart$.subscribe((e) => {
      if (e == null)
        return;
      this._resetIME();
      const { activeRange: t } = e;
      t != null && this._docImeInputManagerService.setActiveRange(ue.deepClone(t));
    });
  }
  _initialOnCompositionUpdate() {
    this._onUpdateSubscription = this._docSelectionRenderService.onCompositionupdate$.subscribe((e) => {
      this._updateContent(e, !0);
    });
  }
  _initialOnCompositionend() {
    this._onEndSubscription = this._docSelectionRenderService.onCompositionend$.subscribe((e) => {
      this._updateContent(e, !1);
    });
  }
  async _updateContent(e, t) {
    if (e == null)
      return;
    const o = this._context.unitId, r = this._docSkeletonManagerService.getSkeleton(), { event: s, activeRange: i } = e;
    if (r == null || i == null)
      return;
    const c = s.data;
    c === this._previousIMEContent && t || (await this._commandService.executeCommand(Ta.id, {
      unitId: o,
      newText: c,
      oldTextLen: this._previousIMEContent.length,
      isCompositionStart: this._isCompositionStart,
      isCompositionEnd: !t
    }), t ? (this._isCompositionStart && (this._isCompositionStart = !1), this._previousIMEContent = c) : this._resetIME());
  }
  _resetIME() {
    this._previousIMEContent = "", this._isCompositionStart = !0, this._docImeInputManagerService.clearUndoRedoMutationParamsCache(), this._docImeInputManagerService.setActiveRange(null);
  }
};
Tr = Kg([
  Gn(1, j(Re)),
  Gn(2, j(No)),
  Gn(3, j(de)),
  Gn(4, T)
], Tr);
var qg = Object.getOwnPropertyDescriptor, Xg = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? qg(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, Yn = (n, e) => (t, o) => e(t, o, n);
let Br = class extends me {
  constructor(e, t, o, r, s) {
    super();
    O(this, "_onInputSubscription");
    this._context = e, this._docSelectionRenderService = t, this._docSkeletonManagerService = o, this._commandService = r, this._docMenuStyleService = s, this._init();
  }
  dispose() {
    var e;
    super.dispose(), (e = this._onInputSubscription) == null || e.unsubscribe();
  }
  _init() {
    this._initialNormalInput();
  }
  _initialNormalInput() {
    this._onInputSubscription = this._docSelectionRenderService.onInput$.subscribe(async (e) => {
      var p, m;
      if (e == null)
        return;
      const { unitId: t } = this._context, { event: o, content: r = "", activeRange: s } = e, i = o, a = this._docSkeletonManagerService.getSkeleton();
      if (i.data == null || a == null || s == null)
        return;
      const { segmentId: c } = s, l = this._context.unit.getSelfOrHeaderFooterModel(c).getBody(), A = this._docMenuStyleService.getDefaultStyle(), h = this._docMenuStyleService.getStyleCache(), u = jr((p = l == null ? void 0 : l.customRanges) != null ? p : [], s.endOffset, En.includes(t)), g = Bo(l, s.endOffset, A, h, En.includes(t)), f = zr((m = l == null ? void 0 : l.customDecorations) != null ? m : [], s.endOffset);
      await this._commandService.executeCommand(va.id, {
        unitId: t,
        body: {
          dataStream: r,
          textRuns: g ? [
            {
              ...g,
              st: 0,
              ed: r.length
            }
          ] : [],
          customRanges: u ? [{
            ...u,
            startIndex: 0,
            endIndex: r.length - 1
          }] : [],
          customDecorations: f.map((I) => ({
            ...I,
            startIndex: 0,
            endIndex: r.length - 1
          }))
        },
        range: s,
        segmentId: c
      }), r === " " && await this._commandService.executeCommand(Mo.id);
    });
  }
};
Br = Xg([
  Yn(1, j(Re)),
  Yn(2, j(de)),
  Yn(3, T),
  Yn(4, j(at))
], Br);
class Ps extends me {
  constructor(e) {
    super(), this._context = e;
  }
  calculatePagePosition() {
    var v, R;
    const e = pt(this._context), o = (R = (v = this._context.unit.getSettings()) == null ? void 0 : v.zoomRatio) != null ? R : 1, { document: r, scene: s, docBackground: i } = e, a = s == null ? void 0 : s.getParent(), { width: c, height: d, pageMarginLeft: l, pageMarginTop: A } = r;
    if (a == null || c === Number.POSITIVE_INFINITY || d === Number.POSITIVE_INFINITY)
      return;
    const { width: h, height: u } = a;
    let g = 0, f = A, p = 0, m = 0, I = Number.POSITIVE_INFINITY;
    h > (c + l * 2) * o ? (g = h / 2 - c * o / 2, g /= o, p = (h - l * 2) / o, I = 0) : (g = l, p = c + l * 2, I = (p - h / o) / 2), u > d ? m = (u - A * 2) / o : m = d + A * 2, s.resize(p, m), h <= 1 && (g = -1e4, f = -1e4), r.translate(g, f), i.translate(g, f);
    const S = s.getViewport(We.VIEW_MAIN);
    return I !== Number.POSITIVE_INFINITY && S != null && S.scrollToViewportPos({
      viewportScrollX: I
    }), this;
  }
}
var Zg = Object.getOwnPropertyDescriptor, Jg = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? Zg(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, Vi = (n, e) => (t, o) => e(t, o, n);
let Mr = class extends me {
  constructor(n, e, t) {
    super(), this._context = n, this._docPageLayoutService = e, this._textSelectionManagerService = t;
    const o = this._context.unitId;
    if (Rt(o) && o !== nt) return this;
    this._initResize();
  }
  _initResize() {
    this.disposeWithMe(
      Mt(this._context.engine.onTransformChange$).pipe(
        oo((n) => n.type === na.resize),
        Rn(0, Gl)
      ).subscribe(() => {
        this._docPageLayoutService.calculatePagePosition(), this._textSelectionManagerService.refreshSelection();
      })
    );
  }
};
Mr = Jg([
  Vi(1, j(Ps)),
  Vi(2, j(Y))
], Mr);
var $g = Object.getOwnPropertyDescriptor, ef = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? $g(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, Yt = (n, e) => (t, o) => e(t, o, n);
let _r = class extends me {
  constructor(e, t, o, r, s, i, a) {
    super();
    O(this, "_loadedMap", /* @__PURE__ */ new WeakSet());
    this._context = e, this._commandService = t, this._editorService = o, this._instanceSrv = r, this._docSelectionRenderService = s, this._docSkeletonManagerService = i, this._docSelectionManagerService = a, this._initialize();
  }
  _initialize() {
    this._init(), this._skeletonListener(), this._commandExecutedListener(), this._refreshListener(), this._syncSelection();
  }
  _init() {
    const { unitId: e } = this._context, t = pt(this._context);
    t == null || t.document == null || this._loadedMap.has(t.document) || (this._initialMain(e), this._loadedMap.add(t.document));
  }
  _refreshListener() {
    this.disposeWithMe(
      this._docSelectionManagerService.refreshSelection$.subscribe((e) => {
        if (e == null)
          return;
        const { unitId: t, docRanges: o, isEditing: r, options: s } = e;
        t === this._context.unitId && (this._docSelectionRenderService.removeAllRanges(), this._docSelectionRenderService.addDocRanges(o, r, s));
      })
    );
  }
  _syncSelection() {
    this.disposeWithMe(
      this._docSelectionRenderService.textSelectionInner$.subscribe((e) => {
        e != null && this._docSelectionManagerService.__replaceTextRangesWithNoRefresh(e, {
          unitId: this._context.unitId,
          subUnitId: this._context.unitId
        });
      })
    );
  }
  // eslint-disable-next-line max-lines-per-function
  _initialMain(e) {
    const t = pt(this._context), { document: o, scene: r } = t;
    this.disposeWithMe(o.onPointerEnter$.subscribeEvent(() => {
      this._isEditorReadOnly(e) || (o.cursor = Dt.TEXT);
    })), this.disposeWithMe(o.onPointerLeave$.subscribeEvent(() => {
      o.cursor = Dt.DEFAULT, r.resetCursor();
    })), this.disposeWithMe(o.onPointerDown$.subscribeEvent((s, i) => {
      if (this._isEditorReadOnly(e))
        return;
      const a = this._instanceSrv.getCurrentUnitForType(_.UNIVER_DOC);
      (a == null ? void 0 : a.getUnitId()) !== e && this._instanceSrv.setCurrentUnitForType(e);
      const c = this._docSkeletonManagerService.getSkeleton(), { offsetX: d, offsetY: l } = s, A = this._getTransformCoordForDocumentOffset(d, l);
      if (A != null) {
        const {
          pageLayoutType: h = Cn.VERTICAL,
          pageMarginLeft: u,
          pageMarginTop: g
        } = o.getOffsetConfig(), { editArea: f } = c.findEditAreaByCoord(
          A,
          h,
          u,
          g
        ), p = this._docSkeletonManagerService.getViewModel(), m = p.getEditArea();
        m !== ve.BODY && f !== ve.BODY && f !== m && p.setEditArea(f);
      }
      if (this._docSelectionRenderService.__onPointDown(s), this._editorService.getEditor(e)) {
        this._setEditorFocus(e);
        const { offsetX: h, offsetY: u } = s;
        setTimeout(() => {
          e === this._editorService.getFocusId() || this._docSelectionRenderService.isOnPointerEvent || (this._setEditorFocus(e), this._docSelectionRenderService.setCursorManually(h, u));
        }, 0);
      }
      s.button !== 2 && i.stopPropagation();
    })), this.disposeWithMe(o.onDblclick$.subscribeEvent((s) => {
      this._isEditorReadOnly(e) || this._docSelectionRenderService.__handleDblClick(s);
    })), this.disposeWithMe(o.onTripleClick$.subscribeEvent((s) => {
      this._isEditorReadOnly(e) || this._docSelectionRenderService.__handleTripleClick(s);
    }));
  }
  _getTransformCoordForDocumentOffset(e, t) {
    const o = pt(this._context), { document: r, scene: s } = o, { documentTransform: i } = r.getOffsetConfig(), a = s.getViewports()[0];
    if (a == null)
      return;
    const c = a.transformVector2SceneCoord(vn.FromArray([e, t]));
    return i.clone().invert().applyPoint(c);
  }
  _isEditorReadOnly(e) {
    const t = this._editorService.getEditor(e);
    return t ? t.isReadOnly() : !1;
  }
  _setEditorFocus(e) {
    this._editorService.focus(e);
  }
  _commandExecutedListener() {
    const e = [tt.id];
    this.disposeWithMe(
      this._commandService.onCommandExecuted((t) => {
        var o;
        if (e.includes(t.id)) {
          const r = t.params, { unitId: s } = r, i = (o = this._docSelectionManagerService.__getCurrentSelection()) == null ? void 0 : o.unitId;
          if (s !== i)
            return;
          this._docSelectionManagerService.refreshSelection();
        }
      })
    );
  }
  _skeletonListener() {
    this.disposeWithMe(this._docSkeletonManagerService.currentSkeleton$.subscribe((e) => {
      if (!e) return;
      const { unitId: t } = this._context;
      if (!Rt(t)) {
        this._docSelectionRenderService.focus();
        const s = this._context.unit.getSnapshot(), i = dc(s);
        this._docSelectionManagerService.replaceDocRanges([
          {
            startOffset: i,
            endOffset: i
          }
        ], {
          unitId: t,
          subUnitId: t
        }, !1);
      }
    }));
  }
};
_r = ef([
  Yt(1, T),
  Yt(2, Ge),
  Yt(3, L),
  Yt(4, j(Re)),
  Yt(5, j(de)),
  Yt(6, j(Y))
], _r);
var tf = Object.getOwnPropertyDescriptor, nf = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? tf(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, ht = (n, e) => (t, o) => e(t, o, n);
let Dr = class extends me {
  constructor(e, t, o, r, s, i, a, c, d) {
    super();
    O(this, "_isSheetEditor", !1);
    this._context = e, this._contextService = t, this._docSkeletonManagerService = o, this._univerInstanceService = r, this._commandService = s, this._textSelectionManagerService = i, this._editorService = a, this._docPageLayoutService = c, this._renderManagerService = d, this._initSkeletonListener(), this._initCommandExecutedListener(), this._initRenderRefresher(), this._isSheetEditor = this._context.unitId === bo;
    const l = this._univerInstanceService.getCurrentUnitOfType(_.UNIVER_SHEET), A = l && this._renderManagerService.getRenderById(l.getUnitId());
    setTimeout(() => this.updateViewZoom(A && this._isSheetEditor ? A.scene.scaleX : 1, !0), 20), Rt(this._context.unitId) || this._initZoomEventListener();
  }
  _initRenderRefresher() {
    this._docSkeletonManagerService.currentSkeleton$.subscribe((e) => {
      if (e == null)
        return;
      const { unitId: t, scene: o } = this._context;
      this._editorService.isEditor(t) || this.disposeWithMe(o.onMouseWheel$.subscribeEvent((r) => {
        if (!r.ctrlKey || !this._contextService.getContextValue(_n))
          return;
        const s = this._univerInstanceService.getCurrentUniverDocInstance();
        if (!s)
          return;
        const { documentFlavor: i } = s.getSnapshot().documentStyle;
        if (i === Pe.MODERN)
          return;
        const a = Math.abs(r.deltaX);
        let c = a < 40 ? 0.2 : a < 80 ? 0.4 : 0.2;
        c *= r.deltaY > 0 ? -1 : 1, o.scaleX < 1 && (c /= 2);
        const d = s.zoomRatio;
        let l = +Number.parseFloat(`${d + c}`).toFixed(1);
        l = l >= 4 ? 4 : l <= 0.1 ? 0.1 : l, this._commandService.executeCommand(Xn.id, {
          zoomRatio: l,
          unitId: s.getUnitId()
        }), r.preventDefault();
      }));
    });
  }
  _initSkeletonListener() {
    this.disposeWithMe(this._docSkeletonManagerService.currentSkeleton$.subscribe((e) => {
      if (e == null)
        return;
      const t = this._univerInstanceService.getCurrentUniverDocInstance();
      t && setTimeout(() => {
        const o = this._univerInstanceService.getCurrentUnitOfType(_.UNIVER_SHEET), r = o && this._renderManagerService.getRenderById(o.getUnitId()), s = this._isSheetEditor ? (r == null ? void 0 : r.scene.scaleX) || 1 : t.zoomRatio;
        this.updateViewZoom(s, !1);
      });
    }));
  }
  _initCommandExecutedListener() {
    const e = [tt.id];
    this.disposeWithMe(this._commandService.onCommandExecuted((t) => {
      if (e.includes(t.id) && t.params.unitId === this._context.unitId) {
        const r = this._context.unit.zoomRatio || 1;
        this.updateViewZoom(r);
      }
    })), this.disposeWithMe(
      this._commandService.beforeCommandExecuted((t) => {
        t.id === ko.id && this._commandService.executeCommand(Xn.id, {
          zoomRatio: 1,
          unitId: this._context.unitId
        });
      })
    );
  }
  updateViewZoom(e, t = !0) {
    var r;
    const o = pt(this._context);
    o.scene.scale(e, e), this._editorService.isEditor(this._context.unitId) || this._docPageLayoutService.calculatePagePosition(), t && !this._editorService.isEditor(this._context.unitId) && this._textSelectionManagerService.refreshSelection(), (r = o.scene.getTransformer()) == null || r.clearSelectedObjects();
  }
  _initZoomEventListener() {
    const e = this._context.scene;
    this.disposeWithMe(
      // hold ctrl & mousewheel ---> zoom
      e.onMouseWheel$.subscribeEvent((t) => {
        if (!t.ctrlKey)
          return;
        const o = Math.abs(t.deltaX);
        let r = o < 40 ? 0.2 : o < 80 ? 0.4 : 0.2;
        r *= t.deltaY > 0 ? -1 : 1, e.scaleX < 1 && (r /= 2);
        const s = this._context.unit.zoomRatio;
        let i = +Number.parseFloat(`${s + r}`).toFixed(1);
        i = i >= 4 ? 4 : i <= 0.1 ? 0.1 : i, this._commandService.executeCommand(Xn.id, {
          zoomRatio: Math.round(i * 10) / 10,
          documentId: this._context.unitId
        }), t.preventDefault();
      })
    );
  }
};
Dr = nf([
  ht(1, Fr),
  ht(2, j(de)),
  ht(3, L),
  ht(4, T),
  ht(5, j(Y)),
  ht(6, Ge),
  ht(7, j(Ps)),
  ht(8, pe)
], Dr);
const of = Zi("PRINTING_COMPONENT_COLLECT"), rf = Zi("PRINTING_DOM_COLLECT");
class sf extends me {
  constructor() {
    super();
    O(this, "_printComponentMap", /* @__PURE__ */ new Map());
    O(this, "interceptor", new Kc({
      PRINTING_COMPONENT_COLLECT: of,
      PRINTING_DOM_COLLECT: rf
    }));
    this.disposeWithMe(this.interceptor.intercept(this.interceptor.getInterceptPoints().PRINTING_COMPONENT_COLLECT, {
      priority: -1,
      handler: (t) => t
    })), this.disposeWithMe(this.interceptor.intercept(this.interceptor.getInterceptPoints().PRINTING_DOM_COLLECT, {
      priority: -1,
      handler: (t) => t
    }));
  }
  registerPrintComponent(t, o) {
    this._printComponentMap.set(t, o);
  }
  getPrintComponent(t) {
    return this._printComponentMap.get(t);
  }
}
var af = Object.getOwnPropertyDescriptor, cf = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? af(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, un = (n, e) => (t, o) => e(t, o, n);
const Wi = 300;
let Io = class extends Ct {
  constructor(e, t, o, r, s) {
    super();
    O(this, "_docStateChange$", new Fe(null));
    O(this, "docStateChange$", this._docStateChange$.asObservable());
    // This cache used for history compose.
    O(this, "_historyStateCache", /* @__PURE__ */ new Map());
    // This cache used for collaboration state compose.
    O(this, "_changeStateCache", /* @__PURE__ */ new Map());
    O(this, "_historyTimer", null);
    O(this, "_changeStateCacheTimer", null);
    this._undoRedoService = e, this._commandService = t, this._univerInstanceService = o, this._docStateEmitService = r, this._renderManagerService = s, this._initialize(), this._listenDocStateChange();
  }
  getStateCache(e) {
    var t, o;
    return {
      history: (t = this._historyStateCache.get(e)) != null ? t : [],
      collaboration: (o = this._changeStateCache.get(e)) != null ? o : []
    };
  }
  setStateCache(e, t) {
    this._historyStateCache.set(e, t.history), this._changeStateCache.set(e, t.collaboration);
  }
  _setChangeState(e) {
    this._cacheChangeState(e, "history"), this._cacheChangeState(e, "collaboration");
  }
  _initialize() {
    this.disposeWithMe(
      this._commandService.beforeCommandExecuted((e) => {
        if (e.id === Fs || e.id === Hs) {
          const t = this._univerInstanceService.getCurrentUniverDocInstance();
          if (t == null)
            return;
          const o = t.getUnitId();
          this._pushHistory(o), this._emitChangeState(o);
        }
      })
    );
  }
  _listenDocStateChange() {
    this._docStateEmitService.docStateChangeParams$.pipe(ft(this.dispose$)).subscribe((e) => {
      var a;
      if (e == null)
        return;
      const { isCompositionEnd: t, isSync: o, syncer: r, ...s } = e, i = (a = this._renderManagerService.getRenderById(o ? r : e.unitId)) == null ? void 0 : a.with(No);
      if (i != null) {
        if (t) {
          const c = i.fetchComposedUndoRedoMutationParams();
          if (c == null)
            throw new Error("historyParams is null in RichTextEditingMutation");
          const { undoMutationParams: d, redoMutationParams: l, previousActiveRange: A } = c;
          s.redoState.actions = l.actions, s.undoState.actions = d.actions, s.undoState.textRanges = [A];
        }
        this._setChangeState(s);
      }
    });
  }
  _cacheChangeState(e, t = "history") {
    const { trigger: o, unitId: r, noHistory: s, debounce: i = !1 } = e;
    if (s || o == null || t === "history" && (o === Hs || o === Fs))
      return;
    const a = t === "history" ? this._historyStateCache : this._changeStateCache, c = t === "history" ? this._pushHistory.bind(this) : this._emitChangeState.bind(this);
    if (a.has(r)) {
      const d = a.get(r);
      d == null || d.push(e);
    } else
      a.set(r, [e]);
    i ? t === "history" ? (this._historyTimer && clearTimeout(this._historyTimer), this._historyTimer = setTimeout(() => {
      c(r);
    }, Wi)) : (this._changeStateCacheTimer && clearTimeout(this._changeStateCacheTimer), this._changeStateCacheTimer = setTimeout(() => {
      c(r);
    }, Wi)) : c(r);
  }
  _pushHistory(e) {
    const t = this._undoRedoService, o = this._historyStateCache.get(e);
    if (!Array.isArray(o) || o.length === 0)
      return;
    const r = o.length, s = o[0].commandId, i = o[0], a = o[r - 1], c = {
      unitId: e,
      actions: o.reduce((l, A) => W.compose(l, A.redoState.actions), null),
      textRanges: a.redoState.textRanges
    }, d = {
      unitId: e,
      // Always need to put undoParams after redoParams, because `reverse` will change the `cacheStates` order.
      actions: o.reverse().reduce((l, A) => W.compose(l, A.undoState.actions), null),
      textRanges: i.undoState.textRanges
    };
    t.pushUndoRedo({
      unitID: e,
      undoMutations: [{ id: s, params: d }],
      redoMutations: [{ id: s, params: c }]
    }), o.length = 0;
  }
  _emitChangeState(e) {
    const t = this._changeStateCache.get(e);
    if (!Array.isArray(t) || t.length === 0)
      return;
    const o = t.length, { commandId: r, trigger: s, segmentId: i, noHistory: a, debounce: c } = t[0], d = t[0], l = t[o - 1], A = {
      unitId: e,
      actions: t.reduce((g, f) => W.compose(g, f.redoState.actions), null),
      textRanges: l.redoState.textRanges
    }, h = {
      unitId: e,
      // Always need to put undoParams after redoParams, because `reverse` will change the `cacheStates` order.
      actions: t.reverse().reduce((g, f) => W.compose(g, f.undoState.actions), null),
      textRanges: d.undoState.textRanges
    }, u = {
      commandId: r,
      unitId: e,
      trigger: s,
      redoState: A,
      undoState: h,
      segmentId: i,
      noHistory: a,
      debounce: c
    };
    t.length = 0, this._docStateChange$.next(u);
  }
};
Io = cf([
  un(0, j(yo)),
  un(1, T),
  un(2, L),
  un(3, j(el)),
  un(4, pe)
], Io);
var lf = Object.getOwnPropertyDescriptor, df = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? lf(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, ji = (n, e) => (t, o) => e(t, o, n);
const zi = "univer-doc-main-canvas";
let So = class extends Ct {
  constructor(n, e) {
    super(), this._instanceSrv = n, this._renderManagerService = e, this._init();
  }
  _init() {
    this._renderManagerService.createRender$.pipe(ft(this.dispose$)).subscribe((n) => this._createRenderWithId(n)), this._instanceSrv.getAllUnitsForType(_.UNIVER_DOC).forEach((n) => this._createRenderer(n)), this._instanceSrv.getTypeOfUnitAdded$(_.UNIVER_DOC).pipe(ft(this.dispose$)).subscribe((n) => this._createRenderer(n)), this._instanceSrv.getTypeOfUnitDisposed$(_.UNIVER_DOC).pipe(ft(this.dispose$)).subscribe((n) => this._disposeRenderer(n));
  }
  _createRenderer(n) {
    var o;
    const e = n.getUnitId(), t = (o = this._instanceSrv.getCurrentUnitForType(_.UNIVER_DOC)) == null ? void 0 : o.getUnitId();
    this._renderManagerService.created$.subscribe((r) => {
      r.unitId === t && (r.engine.getCanvas().setId(zi), r.engine.getCanvas().getContext().setId(zi));
    }), this._renderManagerService.has(e) || this._createRenderWithId(e);
  }
  _createRenderWithId(n) {
    this._renderManagerService.createRender(n);
  }
  _disposeRenderer(n) {
    const e = n.getUnitId();
    this._renderManagerService.removeRender(e);
  }
};
So = df([
  ji(0, L),
  ji(1, pe)
], So);
const Af = {
  id: bn.id,
  preconditions: ah,
  binding: q.ENTER
}, uf = {
  id: Do.id,
  preconditions: Se,
  binding: q.BACKSPACE
}, hf = {
  id: ba.id,
  preconditions: Se,
  binding: q.DELETE
}, gf = {
  id: St.id,
  binding: q.ARROW_UP,
  preconditions: Se,
  staticParameters: {
    direction: le.UP
  }
}, ff = {
  id: St.id,
  binding: q.ARROW_DOWN,
  preconditions: Se,
  staticParameters: {
    direction: le.DOWN
  }
}, pf = {
  id: St.id,
  binding: q.ARROW_LEFT,
  preconditions: Se,
  staticParameters: {
    direction: le.LEFT
  }
}, mf = {
  id: St.id,
  binding: q.ARROW_RIGHT,
  preconditions: Se,
  staticParameters: {
    direction: le.RIGHT
  }
}, Ef = {
  id: vt.id,
  binding: q.ARROW_UP | te.SHIFT,
  preconditions: Se,
  staticParameters: {
    direction: le.UP
  }
}, If = {
  id: vt.id,
  binding: q.ARROW_DOWN | te.SHIFT,
  preconditions: Se,
  staticParameters: {
    direction: le.DOWN
  }
}, Sf = {
  id: vt.id,
  binding: q.ARROW_LEFT | te.SHIFT,
  preconditions: Se,
  staticParameters: {
    direction: le.LEFT
  }
}, vf = {
  id: vt.id,
  binding: q.ARROW_RIGHT | te.SHIFT,
  preconditions: Se,
  staticParameters: {
    direction: le.RIGHT
  }
}, Cf = {
  id: Oa.id,
  binding: q.A | te.CTRL_COMMAND,
  preconditions: (n) => n.getContextValue(Hr) && (n.getContextValue(_n) || n.getContextValue(eo))
};
var Rf = Object.defineProperty, bf = Object.getOwnPropertyDescriptor, yf = (n, e, t) => e in n ? Rf(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, xf = (n, e, t, o) => {
  for (var r = o > 1 ? void 0 : o ? bf(e, t) : e, s = n.length - 1, i; s >= 0; s--)
    (i = n[s]) && (r = i(r) || r);
  return r;
}, hn = (n, e) => (t, o) => e(t, o, n), Of = (n, e, t) => yf(n, e + "", t);
let wr = class extends Xc {
  // static override type = UniverInstanceType.UNIVER_DOC;
  constructor(n = Di, e, t, o, r, s) {
    super(), this._config = n, this._injector = e, this._renderManagerSrv = t, this._commandService = o, this._logService = r, this._configService = s;
    const { menu: i, ...a } = Zc(
      {},
      Di,
      this._config
    );
    i && this._configService.setConfig("menu", i, { merge: !0 }), this._configService.setConfig(Vo, a), this._initDependencies(e), this._initializeShortcut(), this._initCommand();
  }
  onReady() {
    this._initRenderBasics(), this._markDocAsFocused(), ks(this._injector, [
      [Io],
      [So]
    ]);
  }
  onRendered() {
    this._initUI(), this._initRenderModules(), ks(this._injector, [
      [go],
      [fo],
      [tn],
      [po],
      // FIXME: LifecycleStages.Rendered must be used, otherwise the menu cannot be added to the DOM, but the sheet ui
      // plugin can be added in LifecycleStages.Ready
      [Ao]
    ]);
  }
  // eslint-disable-next-line max-lines-per-function
  _initCommand() {
    [
      Do,
      ba,
      Qt,
      Ut,
      Ft,
      Ht,
      bt,
      kt,
      ct,
      _t,
      mt,
      Un,
      Et,
      yt,
      Gr,
      va,
      yn,
      Zr,
      Ca,
      Jr,
      Ra,
      tt,
      On,
      xn,
      Fn,
      Qo,
      Uo,
      Fo,
      lt,
      Ho,
      Po,
      Wa,
      ja,
      Rs,
      bs,
      IA,
      ys,
      xs,
      Is,
      Ss,
      Hn,
      Ms,
      za,
      Jt,
      Mo,
      bn,
      gr,
      Lo,
      so,
      Pa,
      Na,
      Ta,
      ko,
      rt,
      Sa,
      $t,
      Kd,
      _a,
      qd,
      Xn,
      Oa,
      Ds,
      St,
      vt,
      Zd,
      wa,
      Jd,
      Xe,
      La,
      es,
      os,
      ss,
      us,
      hs,
      gs,
      fs,
      ps,
      io,
      Qa,
      Ua,
      ls,
      ds,
      As,
      as,
      pc,
      _s
    ].forEach((n) => {
      this.disposeWithMe(this._commandService.registerCommand(n));
    }), [ro, rs, is].forEach((n) => this.disposeWithMe(this._commandService.registerMultipleCommand(n)));
  }
  _initializeShortcut() {
    [
      gf,
      ff,
      mf,
      pf,
      Ef,
      If,
      Sf,
      vf,
      Cf,
      uf,
      hf,
      Af,
      lh
    ].forEach((n) => {
      this._injector.get(To).registerShortcut(n);
    });
  }
  _initDependencies(n) {
    Jc([
      [sf],
      [mo],
      [Eo],
      [Ao],
      [go],
      [po],
      [fo],
      [ho],
      [tn],
      [Ge, { useClass: Sr }],
      [Lt, { useClass: ur }],
      [Bn],
      [So],
      [Io],
      [wt],
      [at]
    ], this._config.override).forEach((t) => n.add(t));
  }
  _markDocAsFocused() {
    const n = this._injector.get(L), e = this._injector.get(Ge);
    try {
      const t = n.getCurrentUnitForType(_.UNIVER_DOC);
      if (!t) return;
      const o = t.getUnitId();
      e.isEditor(o) || n.focusUnit(t.getUnitId());
    } catch (t) {
      this._logService.warn(t);
    }
  }
  _initUI() {
    this._injector.get(ho);
  }
  _initRenderBasics() {
    [
      [de],
      [Re],
      [tl],
      [Ps],
      [No],
      [br],
      [Dr]
    ].forEach((n) => {
      this._renderManagerSrv.registerRenderModule(_.UNIVER_DOC, n);
    });
  }
  _initRenderModules() {
    [
      [Pt],
      [co],
      [lo],
      [uo],
      [_r],
      [Cr],
      [Mr],
      [Or],
      [xr],
      [mo],
      [Br],
      [Tr],
      [Eo]
    ].forEach((n) => {
      this._renderManagerSrv.registerRenderModule(_.UNIVER_DOC, n);
    });
  }
};
Of(wr, "pluginName", rd);
wr = xf([
  qc(El),
  hn(1, j(Dn)),
  hn(2, pe),
  hn(3, T),
  hn(4, Qr),
  hn(5, Vr)
], wr);
function Tf(n, e, t) {
  const o = J(T), r = J(To), s = _e(() => ge(4), []);
  Ce(() => {
    if (!t || !n || !e)
      return;
    const a = `sheet.operation.editor-${t.getEditorId()}-keyboard-${s}`, c = new In();
    return c.add(o.registerCommand({
      id: a,
      type: D.OPERATION,
      handler(d, l) {
        const { keyCode: A, metaKey: h } = l;
        e.handler(A, h);
      }
    })), e.keyCodes.map((d) => ({
      id: a,
      binding: d.metaKey ? d.keyCode | d.metaKey : d.keyCode,
      preconditions: () => !0,
      priority: 901,
      staticParameters: {
        eventType: oa.Keyboard,
        keyCode: d.keyCode,
        metaKey: d.metaKey
      }
    })).forEach((d) => {
      c.add(r.registerShortcut(d));
    }), () => {
      c.dispose();
    };
  }, [o, e, t, n, s, r]);
}
const Bf = (n, e = !0, t, o) => {
  const r = ha(() => {
    if (n) {
      const { scene: i, mainComponent: a } = n.render, c = n.render.with(de), { width: d, height: l } = n.getBoundingClientRect();
      c.getViewModel().getDataModel().updateDocumentDataPageSize(e ? 1 / 0 : d, 1 / 0), i.transformByState({
        width: d,
        height: l
      }), a == null || a.resize(d, l);
    }
  }, [n, e]), s = _e(() => kr(() => {
    var I, S;
    if (!t || !n || !t)
      return;
    const a = n.render.with(de).getSkeleton(), { scene: c, mainComponent: d } = n.render, l = c.getViewport(We.VIEW_MAIN), { actualWidth: A, actualHeight: h } = a.getActualSize(), { width: u, height: g } = n.getBoundingClientRect();
    let f = l == null ? void 0 : l.getScrollBar();
    const p = Math.max(A, u), m = Math.max(h, g);
    c.transformByState({
      width: p,
      height: m
    }), d == null || d.resize(p, m), e ? A > u ? (f == null ? l && new lr(l, {
      barSize: 8,
      enableVertical: !1,
      enableHorizontal: !0,
      minThumbSizeV: 8
    }) : l == null || l.resetCanvasSizeAndUpdateScroll(), o && (l == null || l.scrollToBarPos({ x: 1 / 0, y: 0 }))) : (f = null, l == null || l.scrollToBarPos({ x: 0, y: 0 }), (S = l == null ? void 0 : l.getScrollBar()) == null || S.dispose()) : h > g ? (f == null ? l && (f = new lr(l, {
      enableHorizontal: !1,
      enableVertical: !0,
      barSize: 8,
      minThumbSizeV: 8
    })) : l == null || l.resetCanvasSizeAndUpdateScroll(), o && (l == null || l.scrollToBarPos({ x: 0, y: 1 / 0 }))) : (f = null, l == null || l.scrollToBarPos({ x: 0, y: 0 }), (I = l == null ? void 0 : l.getScrollBar()) == null || I.dispose());
  }, 30), [n, t, e, o]);
  return Ce(() => {
    if (t && n) {
      const i = setTimeout(() => {
        r(), s();
      }, 500);
      return () => {
        clearTimeout(i);
      };
    }
  }, [n, t, r, s]), Ce(() => {
    if (t && n) {
      const i = n.input$.subscribe(() => {
        s();
      });
      return () => {
        i.unsubscribe();
      };
    }
  }, [n, t, s]), { resize: r, checkScrollBar: s };
};
function Mf(n) {
  const { editorId: e, initialValue: t, container: o, autoFocus: r, isSingle: s } = n, i = _e(() => r != null ? r : !1, []), [a, c] = Ee(), d = J(Ge);
  return ga(() => {
    var l, A;
    if (o.current) {
      const h = typeof t == "string" ? void 0 : ue.deepClone(t), u = {
        body: {
          dataStream: typeof t == "string" ? `${t}\r
` : `\r
`,
          textRuns: [],
          customBlocks: [],
          customDecorations: [],
          customRanges: [],
          paragraphs: [{
            startIndex: 0
          }]
        },
        ...h,
        documentStyle: {
          ...h == null ? void 0 : h.documentStyle,
          pageSize: {
            width: s ? 1 / 0 : o.current.clientWidth,
            height: 1 / 0
          }
        },
        id: e
      }, g = d.register(
        {
          autofocus: !0,
          editorUnitId: e,
          initialSnapshot: u
        },
        o.current
      ), f = d.getEditor(e);
      if (c(f), i) {
        f.focus();
        const p = ((A = (l = u.body) == null ? void 0 : l.dataStream.length) != null ? A : 2) - 2;
        f.setSelectionRanges([{ startOffset: p, endOffset: p }]);
      }
      return () => {
        g == null || g.dispose();
      };
    }
  }, []), a;
}
const _f = (n, e, t, o) => {
  const r = J(T), s = J(To), i = ke(e);
  i.current = e;
  const a = ke(o);
  a.current = o, Ce(() => {
    if (!t || !n)
      return;
    const d = `sheet.formula-embedding-editor.${t.getEditorId()}`, l = new In(), A = (u, g) => {
      if (a.current) {
        a.current(u, g);
        return;
      }
      let f = le.LEFT;
      u === q.ARROW_DOWN ? f = le.DOWN : u === q.ARROW_UP ? f = le.UP : u === q.ARROW_RIGHT && (f = le.RIGHT), g === te.SHIFT ? r.executeCommand(vt.id, {
        direction: f
      }) : r.executeCommand(St.id, {
        direction: f
      });
    };
    return l.add(r.registerCommand({
      id: d,
      type: D.OPERATION,
      handler(u, g) {
        const { keyCode: f } = g;
        A(f);
      }
    })), [
      { keyCode: q.ARROW_DOWN },
      { keyCode: q.ARROW_LEFT },
      { keyCode: q.ARROW_RIGHT },
      { keyCode: q.ARROW_UP },
      { keyCode: q.ARROW_DOWN, metaKey: te.SHIFT },
      { keyCode: q.ARROW_LEFT, metaKey: te.SHIFT },
      { keyCode: q.ARROW_RIGHT, metaKey: te.SHIFT },
      { keyCode: q.ARROW_UP, metaKey: te.SHIFT },
      { keyCode: q.ARROW_DOWN, metaKey: te.CTRL_COMMAND },
      { keyCode: q.ARROW_LEFT, metaKey: te.CTRL_COMMAND },
      { keyCode: q.ARROW_RIGHT, metaKey: te.CTRL_COMMAND },
      { keyCode: q.ARROW_UP, metaKey: te.CTRL_COMMAND },
      { keyCode: q.ARROW_DOWN, metaKey: te.CTRL_COMMAND | te.SHIFT },
      { keyCode: q.ARROW_LEFT, metaKey: te.CTRL_COMMAND | te.SHIFT },
      { keyCode: q.ARROW_RIGHT, metaKey: te.CTRL_COMMAND | te.SHIFT },
      { keyCode: q.ARROW_UP, metaKey: te.CTRL_COMMAND | te.SHIFT }
    ].map(({ keyCode: u, metaKey: g }) => ({
      id: d,
      binding: g ? u | g : u,
      preconditions: () => !0,
      priority: 900,
      staticParameters: {
        eventType: oa.Keyboard,
        keyCode: u
      }
    })).forEach((u) => {
      l.add(s.registerShortcut(u));
    }), () => {
      l.dispose();
    };
  }, [r, t, n, s]);
};
function Df(n, e) {
  const t = J(T);
  Ce(() => {
    if (!n) return;
    const o = t.onCommandExecuted((r) => {
      var s, i;
      if (r.id === X.id) {
        if (r.params.unitId !== n.getEditorId()) return;
        const c = n.getDocumentData();
        e(c, to((i = (s = c.body) == null ? void 0 : s.dataStream) != null ? i : ""));
      }
    });
    return () => {
      o.dispose();
    };
  }, [n, e, t]);
}
const Zf = (n) => {
  var H;
  const {
    className: e,
    autoFocus: t,
    onFocusChange: o,
    initialValue: r,
    onClickOutside: s,
    keyboardEventConfig: i,
    moveCursor: a = !0,
    style: c,
    isSingle: d,
    editorId: l,
    onHeightChange: A,
    onChange: h,
    defaultHeight: u = 32,
    maxHeight: g = 32,
    icon: f,
    editorRef: p,
    placeholder: m
  } = n, I = J(Ge), S = mn(o), v = mn(s), [R, E] = Ee(u), b = ke(null), y = _e(() => l != null ? l : $c(`RICH_TEXT_EDITOR-${ge(4)}`), [l]), C = Mf({
    editorId: y,
    initialValue: r,
    container: b,
    autoFocus: t,
    isSingle: d
  }), x = J(pe).getRenderById(y), M = x == null ? void 0 : x.with(Re), w = et(M == null ? void 0 : M.textSelectionInner$), F = !!((H = M == null ? void 0 : M.isFocusing) != null && H && (w != null && w.textRanges.some((k) => k.collapsed))), P = ke(null), [N, ee] = Ee(() => {
    var k, ne;
    return !ce.transform.getPlainText((ne = (k = C == null ? void 0 : C.getDocumentData().body) == null ? void 0 : k.dataStream) != null ? ne : "");
  }), { checkScrollBar: $ } = Bf(C, d, !0, !0);
  ga(() => {
    if (!(!p || !C)) {
      if (typeof p == "function") {
        p(C);
        return;
      }
      p.current = C;
    }
  }, [C]);
  const U = mn((k) => {
    var ae, oe;
    const ne = x == null ? void 0 : x.with(de), ie = ne == null ? void 0 : ne.getSkeleton().getActualSize();
    ie && (A == null || A(ie.actualHeight), E(Math.max(u, Math.min(ie.actualHeight + 10, g)))), h == null || h(k, to((oe = (ae = k.body) == null ? void 0 : ae.dataStream) != null ? oe : "")), $();
  });
  return Ce(() => {
    var ne, ie;
    ee(!ce.transform.getPlainText((ie = (ne = C == null ? void 0 : C.getDocumentData().body) == null ? void 0 : ne.dataStream) != null ? ie : ""));
    const k = C == null ? void 0 : C.selectionChange$.subscribe(() => {
      var ae, oe;
      ee(!ce.transform.getPlainText((oe = (ae = C == null ? void 0 : C.getDocumentData().body) == null ? void 0 : ae.dataStream) != null ? oe : ""));
    });
    return () => k == null ? void 0 : k.unsubscribe();
  }, [C]), et(C == null ? void 0 : C.blur$), et(C == null ? void 0 : C.focus$), Ce(() => {
    var ne, ie;
    const k = C == null ? void 0 : C.getDocumentData();
    S == null || S(F, to((ie = (ne = k == null ? void 0 : k.body) == null ? void 0 : ne.dataStream) != null ? ie : ""));
  }, [F, S]), Ce(() => {
    const k = (ie) => {
      var oe, he;
      I.getFocusId() !== y || ((he = (oe = ie.target) == null ? void 0 : oe.dataset) == null ? void 0 : he.editorid) === y || P.current && !P.current.contains(ie.target) && (v == null || v());
    }, ne = setTimeout(() => {
      document.addEventListener("click", k);
    }, 100);
    return () => {
      document.removeEventListener("click", k), clearTimeout(ne);
    };
  }, [C, y, I, v]), _f(F && a, !1, C), Tf(F, i, C), Df(C, U), /* @__PURE__ */ Q("div", { className: e, style: c, children: /* @__PURE__ */ re(
    "div",
    {
      className: ze("univer-relative univer-box-border univer-flex univer-h-8 univer-w-full univer-items-center univer-justify-around univer-gap-2 univer-rounded-md univer-pb-0.5 univer-pl-1.5 univer-pr-2 univer-pt-1.5", Nn, {
        "univer-border-primary-500": F
      }),
      style: { height: R },
      ref: P,
      children: [
        /* @__PURE__ */ Q(
          "div",
          {
            ref: b,
            className: "univer-relative univer-size-full",
            onMouseUp: () => C == null ? void 0 : C.focus()
          }
        ),
        f,
        N ? /* @__PURE__ */ Q(
          "div",
          {
            className: "univer-absolute univer-left-[5px] univer-top-[5px] univer-text-sm univer-text-gray-500",
            children: m
          }
        ) : null
      ]
    }
  ) });
};
export {
  Mo as AfterSpaceCommand,
  Uo as AlignCenterCommand,
  Ho as AlignJustifyCommand,
  Qo as AlignLeftCommand,
  lt as AlignOperationCommand,
  Fo as AlignRightCommand,
  Gr as BreakLineCommand,
  xn as BulletListCommand,
  gr as ChangeListNestingLevelCommand,
  qn as ChangeListNestingLevelType,
  Lo as ChangeListTypeCommand,
  so as CheckListCommand,
  qd as CoverContentCommand,
  Wa as CreateDocTableCommand,
  $t as CutContentCommand,
  sd as DOCS_COMPONENT_BACKGROUND_LAYER_INDEX,
  Js as DOCS_COMPONENT_DEFAULT_Z_INDEX,
  id as DOCS_COMPONENT_HEADER_LAYER_INDEX,
  zo as DOCS_COMPONENT_MAIN_LAYER_INDEX,
  $e as DOCS_VIEW_KEY,
  rd as DOC_UI_PLUGIN_NAME,
  Oi as DOC_VERTICAL_PADDING,
  od as DefaultDocContainerConfig,
  nd as DefaultToolbarConfig,
  yn as DeleteCommand,
  Zr as DeleteCustomBlockCommand,
  Do as DeleteLeftCommand,
  ba as DeleteRightCommand,
  wt as DocAutoFormatService,
  uo as DocBackScrollRenderController,
  Bn as DocCanvasPopManagerService,
  ro as DocCopyCommand,
  Os as DocCreateTableOperation,
  rs as DocCutCommand,
  Pt as DocEventManagerService,
  No as DocIMEInputManagerService,
  is as DocPasteCommand,
  sf as DocPrintInterceptorService,
  br as DocRenderController,
  Oa as DocSelectAllCommand,
  Re as DocSelectionRenderService,
  Io as DocStateChangeManagerService,
  Ss as DocTableDeleteColumnsCommand,
  Is as DocTableDeleteRowsCommand,
  Hn as DocTableDeleteTableCommand,
  IA as DocTableInsertColumnCommand,
  ys as DocTableInsertColumnLeftCommand,
  xs as DocTableInsertColumnRightCommand,
  Rs as DocTableInsertRowAboveCommand,
  bs as DocTableInsertRowBellowCommand,
  ja as DocTableInsertRowCommand,
  za as DocTableTabCommand,
  Ao as DocUIController,
  So as DocsRenderService,
  ug as DocsUIMenuSchema,
  HA as Editor,
  Md as EditorInsertTextCommandId,
  Sr as EditorService,
  bn as EnterCommand,
  Po as HorizontalLineCommand,
  Lt as IDocClipboardService,
  Ge as IEditorService,
  Ta as IMEInputCommand,
  Sa as InnerPasteCommand,
  va as InsertCommand,
  Jd as InsertCustomRangeCommand,
  Fn as ListOperationCommand,
  Jr as MergeTwoParagraphCommand,
  St as MoveCursorOperation,
  vt as MoveSelectionOperation,
  jf as NORMAL_TEXT_SELECTION_PLUGIN_NAME,
  It as NodePositionConvertToCursor,
  ka as NodePositionConvertToRectRange,
  On as OrderListCommand,
  Qd as PastePluginLark,
  Ud as PastePluginUniver,
  Fd as PastePluginWord,
  Na as QuickListCommand,
  Va as RectRange,
  Kd as ReplaceContentCommand,
  wa as ReplaceSelectionCommand,
  _a as ReplaceSnapshotCommand,
  Zd as ReplaceTextRunsCommand,
  Un as ResetInlineFormatTextBackgroundColorCommand,
  Zf as RichTextEditor,
  Xn as SetDocZoomRatioCommand,
  tt as SetDocZoomRatioOperation,
  Qt as SetInlineFormatBoldCommand,
  yt as SetInlineFormatCommand,
  _t as SetInlineFormatFontFamilyCommand,
  ct as SetInlineFormatFontSizeCommand,
  Ut as SetInlineFormatItalicCommand,
  Ht as SetInlineFormatStrikethroughCommand,
  bt as SetInlineFormatSubscriptCommand,
  kt as SetInlineFormatSuperscriptCommand,
  Et as SetInlineFormatTextBackgroundColorCommand,
  mt as SetInlineFormatTextColorCommand,
  Ft as SetInlineFormatUnderlineCommand,
  Xe as SetParagraphNamedStyleCommand,
  ko as SwitchDocModeCommand,
  mr as TEXT_RANGE_LAYER_INDEX,
  Jt as TabCommand,
  Zt as TextRange,
  Pa as ToggleCheckListCommand,
  wr as UniverDocsUIPlugin,
  Ca as UpdateCommand,
  We as VIEWPORT_KEY,
  Gf as addCustomDecorationBySelectionFactory,
  cd as addCustomDecorationFactory,
  nr as calcDocRangePositions,
  Vd as convertBodyToHtml,
  Jo as convertPositionsToRectRanges,
  Yf as deleteCustomDecorationFactory,
  qf as docDrawingPositionToTransform,
  ma as genTableSource,
  pa as generateParagraphs,
  Jn as getAnchorBounding,
  dA as getCanvasOffsetByEngine,
  Ke as getCommandSkeleton,
  $r as getCursorWhenDelete,
  Rd as getCustomBlockIdsInSelections,
  Bd as getCutActionsFromDocRanges,
  ad as getDocObject,
  zf as getDocObjectById,
  Kr as getEmptyTableCell,
  qr as getEmptyTableRow,
  Es as getLineBounding,
  fi as getOneTextSelectionRange,
  Ae as getRichTextEditPath,
  Xr as getTableColumn,
  Kf as hasParagraphInTable,
  Fa as isInSameTableCell,
  tA as isValidRectRange,
  pt as neoGetDocObject,
  Xf as transformToDocDrawingPosition,
  Tf as useKeyboardEvent,
  Bf as useResize,
  Se as whenDocAndEditorFocused
};
