import { Metadata } from '@grpc/grpc-js';
import { Observable } from 'rxjs';
import { Error } from '../../univer/constants/errors';
export declare const protobufPackage = "universer.v1";
export declare enum ExecutionTriggerType {
    ExecutionTriggerType_None = 0,
    /** ExecutionTriggerType_IDE - trigger by IDE debug/run */
    ExecutionTriggerType_IDE = 1,
    /** ExecutionTriggerType_UI - trigger by self-designed UI components */
    ExecutionTriggerType_UI = 2,
    /** ExecutionTriggerType_HOOKS - trigger by pre-designed hooks */
    ExecutionTriggerType_HOOKS = 3,
    /** ExecutionTriggerType_TriggerCron - triggered by triggerCron */
    ExecutionTriggerType_TriggerCron = 4,
    /** ExecutionTriggerType_TriggerSheet - triggered by triggerSheet */
    ExecutionTriggerType_TriggerSheet = 5,
    UNRECOGNIZED = -1
}
export declare enum ExecutionStatus {
    ExecutionStatus_None = 0,
    ExecutionStatus_Executing = 1,
    ExecutionStatus_Success = 2,
    ExecutionStatus_Fail = 3,
    ExecutionStatus_Cancelled = 4,
    ExecutionStatus_Timeout = 5,
    UNRECOGNIZED = -1
}
export declare enum LogSource {
    LogSource_None = 0,
    LogSource_ClientScript = 1,
    LogSource_NodeScript = 2,
    LogSource_PythonScript = 3,
    UNRECOGNIZED = -1
}
export declare enum ExecutionEvent {
    ExecutionEvent_None = 0,
    /** ExecutionEvent_Begin - execution begin */
    ExecutionEvent_Begin = 1,
    /** ExecutionEvent_Success - execution completed success */
    ExecutionEvent_Success = 2,
    /** ExecutionEvent_Fail - execution complete with fail */
    ExecutionEvent_Fail = 3,
    /** ExecutionEvent_Cancelled - execution cancelled */
    ExecutionEvent_Cancelled = 4,
    /** ExecutionEvent_Timeout - execute timeout & killed */
    ExecutionEvent_Timeout = 5,
    UNRECOGNIZED = -1
}
export interface Execution {
    executionId: string;
    triggerType: ExecutionTriggerType;
    workspaceId: string;
    functionName: string;
    /** should set triggerId if triggerType in(TriggerCron, TriggerSheet) */
    triggerId: string;
    /** timestamp milli-seconds */
    beginTime: string;
    /** timestamp milli-seconds */
    endTime: string;
    /** DO NOT set this field when call UpsertExecution */
    status: ExecutionStatus;
}
export interface LogEntry {
    executionId: string;
    source: LogSource;
    /**
     * should generate a log with non-empty invokeId
     * when client script call server script,
     * otherwise, left it's empty
     */
    invokeId: string;
    /**
     * when server script called by client script
     * fill the parentInvokeId with the invokeId of the system script call log.
     */
    parentInvokeId: string;
    /**
     * timestamp of the log entry generated
     * precision: milli-seconds
     */
    timestamp: string;
    level: string;
    /** raw log entry message */
    message: string;
    /** extra infos explain by js/python it's self. */
    extra: string;
}
export interface UpsertExecutionRequest {
    event: ExecutionEvent;
    execution: Execution | undefined;
}
export interface UpsertExecutionResponse {
    error: Error | undefined;
}
export interface AppendExecutionLogsRequest {
    logs: LogEntry[];
}
export interface AppendExecutionLogsResponse {
    error: Error | undefined;
}
export interface ListExecutionsRequest {
    /** workspaceId is needed */
    workspaceId: string;
    /**
     * execution time range, timestamp seconds
     * empty means no limit, end should GE begin.
     */
    timeRangeBegin: string;
    timeRangeEnd: string;
    status: ExecutionStatus[];
    triggerTypes: ExecutionTriggerType[];
    triggerId: string;
    functionName: string;
    /** pageNo, start with 1. */
    pageNo: number;
    pageSize: number;
}
export interface ListExecutionsResponse {
    executions: Execution[];
    totalCnt: number;
    error: Error | undefined;
}
export interface ListExecutionLogsRequest {
    executionId: string;
    /** batchId, 1st batch set empty */
    batchId: string;
}
export interface ListExecutionLogsResponse {
    logs: LogEntry[];
    hasMore: boolean;
    /** if hasMore=true, return nextBatchId */
    nextBatchId: string;
    error: Error | undefined;
}
export interface GetExecutionProgressRequest {
    executionId: string;
    /** logsPoint fetched to, set to empty in the 1st query */
    logsPoint: string;
}
export interface GetExecutionProgressResponse {
    /** newest execution data */
    execution: Execution | undefined;
    /** newly logs */
    newlyLogs: LogEntry[];
    /** nextLogsPoint, use this point in the next query. */
    nextLogsPoint: string;
    error: Error | undefined;
}
export interface UniscriptLogService {
    UpsertExecution(request: UpsertExecutionRequest, metadata?: Metadata): Observable<UpsertExecutionResponse>;
    AppendExecutionLogs(request: AppendExecutionLogsRequest, metadata?: Metadata): Observable<AppendExecutionLogsResponse>;
    /** order by execution start-time desc default. */
    ListExecutions(request: ListExecutionsRequest, metadata?: Metadata): Observable<ListExecutionsResponse>;
    /** order by log time asc default. */
    ListExecutionLogs(request: ListExecutionLogsRequest, metadata?: Metadata): Observable<ListExecutionLogsResponse>;
    GetExecutionProgress(request: GetExecutionProgressRequest, metadata?: Metadata): Observable<GetExecutionProgressResponse>;
}
