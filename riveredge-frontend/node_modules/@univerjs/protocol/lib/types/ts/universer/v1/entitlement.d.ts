import { Metadata } from '@grpc/grpc-js';
import { Observable } from 'rxjs';
import { Error } from '../../univer/constants/errors';
export declare const protobufPackage = "universer.v1";
export declare enum Interval {
    Hour = 0,
    Day = 1,
    Week = 2,
    Month = 3,
    Year = 4,
    UNRECOGNIZED = -1
}
export declare enum EntitlementItemType {
    Ability = 0,
    Rate = 1,
    BizDefined = 2,
    UNRECOGNIZED = -1
}
export declare enum EntitlementItemId {
    WebTableExtractRate = 0,
    ServerExtractHistory = 1,
    TabsPerExtract = 2,
    TargetedExtract = 3,
    StandardSearchRate = 4,
    ProSearchRate = 5,
    AvailableAImodels = 6,
    RowsLimitedPerDrillDown = 7,
    /** BiaoDaReportRate - for biaoda */
    BiaoDaReportRate = 11,
    /** BiaoDaChatReserveTime - 对话保存时间, type=BizDefined, value format: "30" means 30days, "-N" negative or 0 means infinity. */
    BiaoDaChatReserveTime = 13,
    /** BiaoDaAvailableModels - 可用模型, type=BizDefined, value format: "model-1,model-2", models seperate by ',' */
    BiaoDaAvailableModels = 14,
    /** BiaoDaMaxTextAnalyzeRows - 文本分析行数限制, type=BizDefined, value format: "10000" means max 10000 rows, "-N" negative or 0 means infinity. */
    BiaoDaMaxTextAnalyzeRows = 15,
    /** BiaoDaChartsWatermark - 下载图表水印, type=BizDefined, value format: "true" means should add watermark, "false" means no watermark. */
    BiaoDaChartsWatermark = 16,
    /** BiaoDaBasicModelChatRate - 基础模型对话分析频控 */
    BiaoDaBasicModelChatRate = 17,
    /** BiaoDaPremiumModelChatRate - 高级模型对话分析频控 */
    BiaoDaPremiumModelChatRate = 18,
    /** BiaoDaSubPageDrillDownRate - 子页面下钻频控 */
    BiaoDaSubPageDrillDownRate = 19,
    /** BiaoDaURLScrapeRate - URL采集频控 */
    BiaoDaURLScrapeRate = 20,
    /** BiaoDaMaxEnrichmentRows - 数据增强限制行数, type=BizDefined, value format: "10000" means max 10000 rows, "-N" negative or 0 means infinity. */
    BiaoDaMaxEnrichmentRows = 26,
    /** BiaoDaUnitDownload - unit下载，type=Ability */
    BiaoDaUnitDownload = 31,
    /** XlsxAIBasicPoints - xlsx.ai 基础积分 */
    XlsxAIBasicPoints = 101,
    UNRECOGNIZED = -1
}
export declare enum ProductType {
    NonProduct = 0,
    Recurring = 1,
    /** Freebie - freebie product, like the anonymous users can enjoy pro search 5 times per 4 hours */
    Freebie = 2,
    OneTime = 3,
    UNRECOGNIZED = -1
}
export declare enum SessionType {
    /** SetupIntent - collect payment method */
    SetupIntent = 0,
    /** PaymentIntent - pay directly */
    PaymentIntent = 1,
    UNRECOGNIZED = -1
}
export declare enum SubscriptionStatus {
    /** PendingCreate - the subscription is creating */
    PendingCreate = 0,
    /** Active - the subscription is active */
    Active = 1,
    /** PastDue - the subscription renewaled and pay failed */
    PastDue = 2,
    /** Expired - the subscription expired, due to not paid or offer the payment method */
    Expired = 3,
    /** Cancelled - cancelled, by user or system */
    Cancelled = 4,
    UNRECOGNIZED = -1
}
export declare enum UserInfoType {
    Email = 0,
    BillingAddress = 1,
    UNRECOGNIZED = -1
}
export declare enum InvoiceStatus {
    PendingPay = 0,
    Paid = 1,
    Void = 2,
    UNRECOGNIZED = -1
}
export declare enum PaymentChannel {
    NonPay = 0,
    AliPay = 1,
    WechatPay = 2,
    Stripe = 3,
    UNRECOGNIZED = -1
}
export declare enum OrderStatus {
    Order_StatusNone = 0,
    Order_PendingPay = 1,
    Order_Cancelled = 2,
    Order_Expired = 3,
    Order_Completed = 4,
    UNRECOGNIZED = -1
}
export interface RateLimiter {
    /** negative value means infinity */
    limitedCnt: number;
    /** eg. if interval=Week and interval_cnt=3, it's mean 3 weeks */
    interval: Interval;
    intervalCnt: number;
}
export interface EntitlementItem {
    itemId: string;
    name: string;
    /** optional */
    tips: string;
    type: EntitlementItemType;
    /** is the ability enable? set if type is Ability */
    enable: boolean;
    /** set if type is Rate, the bool logic relation of each limiter is 'AND' */
    rateLimiters: RateLimiter[];
    /** biz defined value, set if type is BizDefined */
    bizDefinedValue: string;
    /** desc of biz defined value, set if type is BizDefined */
    bizDefinedValueDesc: string;
}
export interface EntitlementItemGroup {
    name: string;
    items: EntitlementItem[];
}
export interface Entitlement {
    /** level of the entitlement, higher is better */
    level: number;
    name: string;
    groups: EntitlementItemGroup[];
    id: string;
}
export interface RateDetail {
    /** eg. if interval=Week and interval_cnt=3, it's mean 3 weeks */
    interval: Interval;
    intervalCnt: number;
    /** total limit count, negative value means infinity */
    limitedCnt: number;
    /** left limit count, negative value means infinity */
    leftCnt: number;
    /** next time to reset the limit */
    nextResetTime: number;
}
export interface EntitlementItemDetail {
    itemId: string;
    type: EntitlementItemType;
    /** is the ability enable? set if type is Ability */
    enable: boolean;
    /** set if type is Rate, the bool logic relation of each limiter is 'AND' */
    rateDetails: RateDetail[];
    /** biz defined value, set if type is BizDefined */
    bizDefinedValue: string;
}
export interface MGetEntitlementItemsByUserRequest {
    userId: string;
    /** item_id, string id of enum EntitlementItemId */
    itemIds: string[];
}
export interface MGetEntitlementItemsByUserResponse {
    /** key is item_id */
    items: {
        [key: string]: EntitlementItemDetail;
    };
    error: Error | undefined;
}
export interface MGetEntitlementItemsByUserResponse_ItemsEntry {
    key: string;
    value: EntitlementItemDetail | undefined;
}
export interface TakeNItemRateByUserRequest {
    userId: string;
    itemId: string;
    n: number;
}
export interface TakeNItemRateByUserResponse {
    allow: boolean;
    /** if not allow, return how much lack */
    lackCnt: number;
    error: Error | undefined;
}
export interface DeductQuotaByUserRequest {
    itemId: string;
    /** deduct n, if available count less than n, deduct to 0. */
    n: number;
}
export interface DeductQuotaByUserResponse {
    error: Error | undefined;
}
export interface Product {
    productId: string;
    productType: ProductType;
    entitlement: Entitlement | undefined;
    name: string;
    /** optional, recommendation text of the product */
    recommendation: string;
    tags: string[];
    interval: Interval;
    intervalCnt: number;
    /** the origin price */
    price: string;
    /** currency of the price */
    currency: string;
    /** optional, promotion price, set if there's any promotion */
    promotionPrice: string;
    /** optional, how many interval the promotion last, set if there's any promotion and product_type is Recurring */
    promotionIntervalCnt: number;
    /** optional, the product table name */
    tabName: string;
}
export interface PaymentSession {
    sessionType: SessionType;
    clientSecret: string;
    /** eg:15.99, set if session_type is PaymentIntent */
    amount: string;
    /** eg:usd, set if session_type is PaymentIntent */
    currency: string;
}
export interface Subscription {
    subscriptionId: string;
    productId: string;
    productName: string;
    status: SubscriptionStatus;
    /** unix timestamp of UTC 0 */
    subscriptTime: number;
    /** unix timestamp of UTC 0 */
    nextChargeTime: number;
    /** is the subscription need payment */
    paymentNeeded: boolean;
    /** optional, set session data if payment_needed is true */
    session: PaymentSession | undefined;
}
export interface PaymentMethodCard {
    brand: string;
    country: string;
    expMonth: number;
    expYear: number;
    fingerprint: string;
    last4: string;
}
export interface PaymentMethod {
    card: PaymentMethodCard | undefined;
}
/** entitlement identity of the user */
export interface Identity {
    entitlementLevel: number;
    entitlementName: string;
    /** deprecated, this value has no significance. */
    startTime: number;
    /** deprecated, due to potential overflow risks, use expireTimeSec instead. */
    expireTime: number;
    /** is the system's default identity? */
    isDefault: boolean;
    /** expire time in seconds, negative value means the identity will never expire */
    expireTimeSec: string;
}
export interface GetSubscriptionSummaryRequest {
}
export interface GetSubscriptionSummaryResponse {
    identity: Identity | undefined;
    /** optional */
    currentSubscription: Subscription | undefined;
    /** optional, may be set if currently has any subscription */
    paymentMethod: PaymentMethod | undefined;
    error: Error | undefined;
}
export interface Address {
    City: string;
    Country: string;
    Line1: string;
    Line2: string;
    PostalCode: string;
    State: string;
}
export interface ProductGroup {
    interval: Interval;
    intervalCnt: number;
    /** optional, eg. 20 means the saving percent is 20%, 0 or nil mean do not display percent */
    maxSavingPercent: number;
    products: Product[];
}
export interface ListProductsRequest {
}
export interface ListProductsResponse {
    groups: ProductGroup[];
    /** set if has subscription */
    currentSubscription: Subscription | undefined;
    identity: Identity | undefined;
    missingUserInfoTypes: UserInfoType[];
    error: Error | undefined;
}
export interface CreateSubscriptionRequest {
    productId: string;
    /** set if previous CreateSubscriptionResponse returns error code ENTITLE_NEED_BILLING_ADDRESS */
    billingAddress: Address | undefined;
    /** deprecated, ignore this field */
    email: string;
    /** set the return url after payment complete */
    paymentReturnUrl: string;
}
export interface CreateSubscriptionResponse {
    session: PaymentSession | undefined;
    /** if error code is ENTITLE_NEED_BILLING_ADDRESS, collect user's billing address and try again */
    error: Error | undefined;
}
export interface CancelSubscriptionRequest {
    subscriptionId: string;
    /** optional */
    reason: string;
}
export interface CancelSubscriptionResponse {
    error: Error | undefined;
}
export interface Invoice {
    id: string;
    status: InvoiceStatus;
    /** unixtimestamp of utc 0 */
    payTime: number;
    /** format 12.45 */
    payAmount: string;
    currency: string;
    productId: string;
    productName: string;
    description: string;
    /** link of the receipt */
    receiptUrl: string;
    /** download link of the invoice PDF */
    invoicePdf: string;
    /** invoice number */
    invoiceNumber: string;
}
export interface ListInvoicesRequest {
    /** no of the first page is 1 */
    pageNo: number;
    /** max 100, default is 20 */
    pageSize: number;
    /** if set end_time but no start_time, it's mean [-infi, end_time) */
    startTime: number;
    /** if set start_time but no end_time, it's mean [start_time, now) */
    endTime: number;
    /** if set, only return the invoices generated by the subscription */
    subscriptionId: string;
}
export interface ListInvoicesResponse {
    invoices: Invoice[];
    totalCnt: number;
    error: Error | undefined;
}
export interface GetPaymentConfigRequest {
}
export interface GetPaymentConfigResponse {
    channels: PaymentChannel[];
    /** returned if has stripe channel */
    stripePublicApiKey: string;
    error: Error | undefined;
}
export interface PaymentRequest {
    productId: string;
    qty: number;
    channel: PaymentChannel;
    orderId: string;
}
export interface PaymentResponse {
    orderId: string;
    payQRCode: string;
    error: Error | undefined;
}
export interface GetOrderStatusRequest {
    orderId: string;
}
export interface GetOrderStatusResponse {
    order: Order | undefined;
    error: Error | undefined;
}
export interface Order {
    id: string;
    productId: string;
    qty: number;
    currency: string;
    price: string;
    amount: string;
    status: OrderStatus;
    expireTime: string;
}
export interface ListActiveEntitlementsRequest {
}
export interface ListActiveEntitlementsResponse {
    entitlements: Entitlement[];
    error: Error | undefined;
}
export interface GrantEntitlementRequest {
    bizId: string;
    bizGrantId: string;
    toUserId: string;
    entitlementId: string;
    interval: Interval;
    intervalCnt: number;
}
export interface GrantEntitlementResponse {
    error: Error | undefined;
}
export interface EntitlementService {
    MGetEntitlementItemsByUser(request: MGetEntitlementItemsByUserRequest, metadata?: Metadata): Observable<MGetEntitlementItemsByUserResponse>;
    /** for back-end only, can deduct and add. */
    TakeNItemRateByUser(request: TakeNItemRateByUserRequest, metadata?: Metadata): Observable<TakeNItemRateByUserResponse>;
    /** for front-end only case, just deduct, can not return quota. */
    DeductQuotaByUser(request: DeductQuotaByUserRequest, metadata?: Metadata): Observable<DeductQuotaByUserResponse>;
    GetPaymentConfig(request: GetPaymentConfigRequest, metadata?: Metadata): Observable<GetPaymentConfigResponse>;
    ListProducts(request: ListProductsRequest, metadata?: Metadata): Observable<ListProductsResponse>;
    GetSubscriptionSummary(request: GetSubscriptionSummaryRequest, metadata?: Metadata): Observable<GetSubscriptionSummaryResponse>;
    CreateSubscription(request: CreateSubscriptionRequest, metadata?: Metadata): Observable<CreateSubscriptionResponse>;
    CancelSubscription(request: CancelSubscriptionRequest, metadata?: Metadata): Observable<CancelSubscriptionResponse>;
    ListInvoices(request: ListInvoicesRequest, metadata?: Metadata): Observable<ListInvoicesResponse>;
    Pay(request: PaymentRequest, metadata?: Metadata): Observable<PaymentResponse>;
    GetOrderStatus(request: GetOrderStatusRequest, metadata?: Metadata): Observable<GetOrderStatusResponse>;
    ListActiveEntitlements(request: ListActiveEntitlementsRequest, metadata?: Metadata): Observable<ListActiveEntitlementsResponse>;
    GrantEntitlement(request: GrantEntitlementRequest, metadata?: Metadata): Observable<GrantEntitlementResponse>;
}
