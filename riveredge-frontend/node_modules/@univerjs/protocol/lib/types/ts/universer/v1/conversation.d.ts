import { Metadata } from '@grpc/grpc-js';
import { Observable } from 'rxjs';
import { SystemHint } from '../../ai_common/common';
import { Error } from '../../univer/constants/errors';
import { DataFragmentationType } from './analyse_cmn';
import { RateDetail } from './entitlement';
export declare const protobufPackage = "universer.v1";
export declare enum CompletionStatus {
    Completion_None = 0,
    Completion_Completed = 1,
    Completion_UserCancelled = 2,
    Completion_SystemErr = 3,
    UNRECOGNIZED = -1
}
export declare enum ConversationRoleType {
    RoleType_None = 0,
    RoleType_User = 1,
    RoleType_Agent = 2,
    UNRECOGNIZED = -1
}
export declare enum ContentBlockType {
    ContentBlockType_None = 0,
    ContentBlockType_Prompt = 1,
    ContentBlockType_Thinking = 2,
    ContentBlockType_Report = 3,
    UNRECOGNIZED = -1
}
export declare enum ContentType {
    ContentType_None = 0,
    ContentType_PlainText = 1,
    ContentType_Markdown = 2,
    UNRECOGNIZED = -1
}
export declare enum AttachmentType {
    AttachmentType_None = 0,
    AttachmentType_Unit = 1,
    AttachmentType_Recommendation = 3,
    AttachmentType_DataSource = 4,
    UNRECOGNIZED = -1
}
export declare enum MessageReaction {
    Reaction_NoReact = 0,
    Reaction_ThumbsUp = 1,
    Reaction_ThumbsDown = 2,
    UNRECOGNIZED = -1
}
export declare enum ChatSSEBlockType {
    ChatSSEBlockType_None = 0,
    /** ChatSSEBlockType_EndOfStream - indicates that SSE stream ended */
    ChatSSEBlockType_EndOfStream = 1,
    /** ChatSSEBlockType_Reject - prompt rejected univer.constants.Error */
    ChatSSEBlockType_Reject = 2,
    /** ChatSSEBlockType_ModConversation - conversation modified */
    ChatSSEBlockType_ModConversation = 3,
    /** ChatSSEBlockType_PromptAck - prompt message ACK */
    ChatSSEBlockType_PromptAck = 4,
    /** ChatSSEBlockType_ChatContent - chat answer stream content */
    ChatSSEBlockType_ChatContent = 5,
    /** ChatSSEBlockType_Attachment - attachment of chat answer */
    ChatSSEBlockType_Attachment = 6,
    /** ChatSSEBlockType_RespMeta - meta data of the response message */
    ChatSSEBlockType_RespMeta = 7,
    /** ChatSSEBlockType_StreamErr - stream error */
    ChatSSEBlockType_StreamErr = 8,
    /** ChatSSEBlockType_ChatThinking - chat thinking stream content */
    ChatSSEBlockType_ChatThinking = 9,
    /** ChatSSEBlockType_Fragmentation - content data fragmentation */
    ChatSSEBlockType_Fragmentation = 10,
    UNRECOGNIZED = -1
}
export declare enum ChatSSEStatus {
    ChatSSEStatus_None = 0,
    /** ChatSSEStatus_Appending - streaming still ongoing */
    ChatSSEStatus_Appending = 1,
    /** ChatSSEStatus_Success - streaming completed successfully */
    ChatSSEStatus_Success = 2,
    UNRECOGNIZED = -1
}
export interface ModelDetail {
    /** use string representation of enum ai_common.UniverAIModel */
    modelId: string;
    rateDetails: RateDetail[];
}
export interface ListAvailableModelsRequest {
}
export interface ListAvailableModelsResponse {
    models: ModelDetail[];
    error: Error | undefined;
}
export interface GetConversationModelsRequest {
}
export interface GetConversationModel {
    /** model id */
    id: string;
    /** show name */
    name: string;
}
export interface GetConversationModelsResponse {
    models: GetConversationModel[];
    error: Error | undefined;
}
export interface GetPromptRecommendationsRequest {
    /** must specify the unitIds */
    unitIds: string[];
    /**
     * if not in an existing conversation,
     * leave conversationId empty.
     */
    conversationId: string;
    /** Locale Code */
    locale: string;
    modelId: string;
    /** how many recommendations needed, default is 3 */
    count: number;
    /** use unit or data source. */
    dataSourceId: string;
}
export interface GetPromptRecommendationsResponse {
    recommendations: string[];
    error: Error | undefined;
}
export interface Conversation {
    conversationId: string;
    /** unix timestamp milli seconds */
    createTime: string;
    /** unix timestamp milli seconds */
    lastUpdate: string;
    title: string;
    creatorUid: string;
    expireTime: string;
    shared: boolean;
}
export interface GetConversationRequest {
    conversationId: string;
}
export interface GetConversationResponse {
    conversation: Conversation | undefined;
    error: Error | undefined;
}
export interface ListConversationsRequest {
    /**
     * batchId,
     * set to empty in the 1st scroller request,
     * then set to nextBatchId(which was returned by the previous request) in the following scroller request.
     */
    batchId: string;
    /** limit, specify how many records needed. */
    limit: number;
}
export interface ListConversationsResponse {
    /** conversations, order by lastUpdate desc default. */
    conversations: Conversation[];
    hasMore: boolean;
    nextBatchId: string;
    error: Error | undefined;
}
export interface RenameConversationRequest {
    conversationId: string;
    newTitle: string;
}
export interface RenameConversationResponse {
    error: Error | undefined;
}
export interface ShareConversationRequest {
    conversationId: string;
}
export interface ShareConversationResponse {
    error: Error | undefined;
}
export interface UnshareConversationRequest {
    conversationId: string;
}
export interface UnshareConversationResponse {
    error: Error | undefined;
}
export interface DeleteConversationRequest {
    conversationId: string;
}
export interface DeleteConversationResponse {
    error: Error | undefined;
}
export interface ConversationMessage {
    messageId: string;
    roleType: ConversationRoleType;
    /** unix timestamp milli seconds */
    createTime: string;
    /** reaction of the owner */
    reaction: MessageReaction;
    /** completionStatus, set if message is answer */
    completionStatus: CompletionStatus;
    contents: ContentBlock[];
    attachments: Attachment[];
}
export interface ContentBlock {
    blockType: ContentBlockType;
    contentType: ContentType;
    body: string;
    /** for multi-channel response, default is empty */
    channelId?: string | undefined;
}
export interface Attachment {
    type: AttachmentType;
    /**
     * id of the Attachment,
     * vary with the AttachmentType,
     * AttachmentType_Unit           -> unitId;
     * AttachmentType_Recommendation -> no ID;
     * AttachmentType_DataSource     -> dataSourceId;
     */
    id: string;
    /**
     * content of the Attachment,
     * vary with the AttachmentType,
     * AttachmentType_Unit           -> empty;
     * AttachmentType_Recommendation -> json string of recommendations(json string array);
     * AttachmentType_DataSource     -> json string of v1.DataSource
     */
    content: string;
}
export interface ListConversationMessagesRequest {
    conversationId: string;
    /**
     * batchId,
     * set to empty in the 1st scroller request,
     * then set to nextBatchId(which was returned by the previous request) in the following scroller request.
     */
    batchId: string;
    /** limit, specify how many records needed. */
    limit: number;
}
export interface ListConversationMessagesResponse {
    /** messages, order by createTime desc default. */
    messages: ConversationMessage[];
    nextBatchId: string;
    hasMore: boolean;
    error: Error | undefined;
}
export interface ReactMessageRequest {
    /** conversationId, required */
    conversationId: string;
    /** messageId, required */
    messageId: string;
    reaction: MessageReaction;
}
export interface ReactMessageResponse {
    error: Error | undefined;
}
/** SSE api: /universer-api/conversation/prompt */
export interface SubmitPromptRequest {
    /** set to empty when begin a new conversation */
    conversationId: string;
    promptText: string;
    attachedUnitIds: string[];
    model: string;
    /** use unit or data source */
    dataSourceId: string;
    systemHints: SystemHint[];
    /** Locale Code */
    locale?: string | undefined;
}
/** SSE api: /universer-api/conversation/resume */
export interface ResumeConversationRequest {
    conversationId: string;
    /** see HITLType, use string, see ai_common/common.proto, eg. hitl_select_table */
    type: string;
    /** json string, see ai_common/common.proto */
    resumeData: string;
    /** Locale Code */
    locale?: string | undefined;
    model?: string | undefined;
}
/** SSE api: /universer-api/conversation/reconnect */
export interface ReconnectConversationRequest {
    conversationId: string;
}
/** chat streaming response SSE block */
export interface ChatSSEBlock {
    blockType: ChatSSEBlockType;
    /**
     * body,
     * json string identicated by blockType,
     * ChatSSEBlockType_EndOfStream     -> empty;
     * ChatSSEBlockType_StreamErr       -> json string of error reason: univer.constants.Error;
     * ChatSSEBlockType_Reject          -> json string of reject reason: univer.constants.Error;
     * ChatSSEBlockType_ModConversation -> json string of Conversation;
     * ChatSSEBlockType_PromptAck       -> json string of PromptAck;
     * ChatSSEBlockType_ChatContent     -> json string of ChatContentSSEBlock;
     * ChatSSEBlockType_Attachment      -> json string of Attachment;
     * ChatSSEBlockType_RespMeta        -> json string of ChatRespMeta;
     * ChatSSEBlockType_ChatThinking    -> json string of ChatThinkingSSEBlock;
     * ChatSSEBlockType_Fragmentation   -> json string of ChatFragmentationSSEBlock;
     */
    body: string;
    status: ChatSSEStatus;
    /** for multi-channel response, default is empty */
    channelId?: string | undefined;
}
export interface ChatContentSSEBlock {
    contentType: ContentType;
    body: string;
}
export interface ChatThinkingSSEBlock {
    contentType: ContentType;
    body: string;
}
export interface ChatFragmentationSSEBlock {
    fragmentationId: string;
    /** json string of CodeFragmentation */
    content: string;
}
export interface PromptAck {
    /** id of the user prompt message. */
    messageId: string;
}
export interface ChatRespMeta {
    messageId: string;
}
export interface ConversationDataFragmentation {
    conversationId: string;
    messageId: string;
    fragmentationId: string;
    type: DataFragmentationType;
    title: string;
    unitId: string;
    subUnitId: string;
}
export interface GetConversationDataFragmentationRequest {
    conversationId: string;
    fragmentationId: string;
}
export interface GetConversationDataFragmentationResponse {
    content: string;
    error: Error | undefined;
}
export interface ListConversationDataFragmentationsRequest {
    conversationId: string;
}
export interface ListConversationDataFragmentationsResponse {
    fragmentations: ConversationDataFragmentation[];
    error: Error | undefined;
}
export interface UpdateConversationDataFragmentationRequest {
    conversationId: string;
    fragmentationId: string;
    newContent: string;
}
export interface UpdateConversationDataFragmentationResponse {
    error: Error | undefined;
}
export interface BindUnitWithConversationRequest {
    unitId: string;
    conversationId: string;
    messageId: string;
}
export interface BindUnitWithConversationResponse {
    error: Error | undefined;
}
export interface CancelConversationRequest {
    conversationId: string;
}
export interface CancelConversationResponse {
    error: Error | undefined;
}
export interface NeedReconnectConversationRequest {
    conversationId: string;
}
export interface NeedReconnectConversationResponse {
    needReconnect: boolean;
    error: Error | undefined;
}
export interface CreateReportRequest {
    conversationId: string;
    messageId: string;
}
export interface CreateReportResponse {
    report: Report | undefined;
    error: Error | undefined;
}
export interface Report {
    reportId: string;
    conversationId: string;
    messageId: string;
    /** unix timestamp milli seconds */
    createTime: number;
    updateTime: number;
    status: string;
    fragmentationId: string;
    title: string;
    summary: string;
}
export interface ListReportsRequest {
    conversationId: string;
}
export interface ListReportsResponse {
    reports: Report[];
    error: Error | undefined;
}
export interface FinishReportRequest {
    reportId: string;
    status: string;
    title: string;
    summary: string;
    content: string;
}
export interface FinishReportResponse {
    error: Error | undefined;
}
export interface ConversationService {
    GetConversation(request: GetConversationRequest, metadata?: Metadata): Observable<GetConversationResponse>;
    /** the conversation list is order by lastUpdate desc default. */
    ListConversations(request: ListConversationsRequest, metadata?: Metadata): Observable<ListConversationsResponse>;
    RenameConversation(request: RenameConversationRequest, metadata?: Metadata): Observable<RenameConversationResponse>;
    ShareConversation(request: ShareConversationRequest, metadata?: Metadata): Observable<ShareConversationResponse>;
    UnshareConversation(request: UnshareConversationRequest, metadata?: Metadata): Observable<UnshareConversationResponse>;
    DeleteConversation(request: DeleteConversationRequest, metadata?: Metadata): Observable<DeleteConversationResponse>;
    /** the message list is order by createTime desc default. */
    ListConversationMessages(request: ListConversationMessagesRequest, metadata?: Metadata): Observable<ListConversationMessagesResponse>;
    ReactMessage(request: ReactMessageRequest, metadata?: Metadata): Observable<ReactMessageResponse>;
    GetPromptRecommendations(request: GetPromptRecommendationsRequest, metadata?: Metadata): Observable<GetPromptRecommendationsResponse>;
    /** deprecated, use ListAvailableModels instead */
    GetConversationModels(request: GetConversationModelsRequest, metadata?: Metadata): Observable<GetConversationModelsResponse>;
    ListAvailableModels(request: ListAvailableModelsRequest, metadata?: Metadata): Observable<ListAvailableModelsResponse>;
    GetConversationDataFragmentation(request: GetConversationDataFragmentationRequest, metadata?: Metadata): Observable<GetConversationDataFragmentationResponse>;
    ListConversationDataFragmentations(request: ListConversationDataFragmentationsRequest, metadata?: Metadata): Observable<ListConversationDataFragmentationsResponse>;
    UpdateConversationDataFragmentation(request: UpdateConversationDataFragmentationRequest, metadata?: Metadata): Observable<UpdateConversationDataFragmentationResponse>;
    BindUnitWithConversation(request: BindUnitWithConversationRequest, metadata?: Metadata): Observable<BindUnitWithConversationResponse>;
    CancelConversation(request: CancelConversationRequest, metadata?: Metadata): Observable<CancelConversationResponse>;
    NeedReconnectConversation(request: NeedReconnectConversationRequest, metadata?: Metadata): Observable<NeedReconnectConversationResponse>;
    CreateReport(request: CreateReportRequest, metadata?: Metadata): Observable<CreateReportResponse>;
    ListReports(request: ListReportsRequest, metadata?: Metadata): Observable<ListReportsResponse>;
    FinishReport(request: FinishReportRequest, metadata?: Metadata): Observable<FinishReportResponse>;
}
