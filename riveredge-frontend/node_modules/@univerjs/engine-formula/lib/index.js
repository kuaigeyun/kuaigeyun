var Vc = Object.defineProperty;
var Oc = (a, i, e) => i in a ? Vc(a, i, { enumerable: !0, configurable: !0, writable: !0, value: e }) : a[i] = e;
var A = (a, i, e) => Oc(a, typeof i != "symbol" ? i + "" : i, e);
import { ObjectMatrix as de, CommandType as Ie, RANGE_TYPE as rt, AbsoluteRefType as Le, Tools as Ge, createIdentifier as Je, Disposable as Se, IUniverInstanceService as Jn, LRUMap as Sc, hashAlgorithm as Mc, moveRangeByOffset as ga, isValidRange as Dc, isFormulaString as Et, isFormulaId as wt, Rectangle as ai, cellToRange as wc, Inject as ye, UniverInstanceType as Cr, BooleanNumber as co, LocaleService as Lc, BuildTextUtils as Pc, LocaleType as _t, numfmt as ht, isRealNum as q, getNumfmtParseValueFilter as lo, CellValueType as Dt, isTextFormat as xc, RichTextBuilder as jc, toDisposable as Uc, Injector as fo, generateRandomId as vc, sortRules as Tc, RTree as js, IConfigService as da, AsyncLock as Ic, requestImmediateMacroTask as Bc, ICommandService as lr, DataStreamTreeTokenType as Fe, DisposableCollection as Fc, Optional as kc, Plugin as $c, merge as Yc, touchDependencies as Es } from "@univerjs/core";
import { Subject as tr, BehaviorSubject as mo, distinctUntilChanged as ho, combineLatest as Hc, map as Gc, Observable as Wc, shareReplay as Qc } from "rxjs";
import { DataSyncPrimaryController as qc } from "@univerjs/rpc";
var ir = /* @__PURE__ */ ((a) => (a.FALSE = "FALSE", a.TRUE = "TRUE", a))(ir || {}), It = /* @__PURE__ */ ((a) => (a[a.SUCCESS = 0] = "SUCCESS", a[a.ERROR = 1] = "ERROR", a))(It || {}), De = /* @__PURE__ */ ((a) => (a.ALL = "#All", a.DATA = "#Data", a.HEADERS = "#Headers", a.TOTALS = "#Totals", a.THIS_ROW = "#This Row", a))(De || {}), ft = /* @__PURE__ */ ((a) => (a[a.FRONT = 0] = "FRONT", a[a.BACK = 1] = "BACK", a))(ft || {});
function Xc(a, i, e, t, r) {
  for (let n = 0, s = a.length; n < s; n++) {
    const o = a[n];
    if (i !== o.unitId || e !== o.sheetId)
      continue;
    const { startRow: u, startColumn: c, endRow: l, endColumn: f } = o.range;
    if (t >= u && t <= l && r >= c && r <= f)
      return !0;
  }
  return !1;
}
var h = /* @__PURE__ */ ((a) => (a.DIV_BY_ZERO = "#DIV/0!", a.NAME = "#NAME?", a.VALUE = "#VALUE!", a.NUM = "#NUM!", a.NA = "#N/A", a.CYCLE = "#CYCLE!", a.REF = "#REF!", a.SPILL = "#SPILL!", a.CALC = "#CALC!", a.ERROR = "#ERROR!", a.CONNECT = "#GETTING_DATA", a.NULL = "#NULL!", a))(h || {});
const fr = new Set(Object.values(h)), ii = [...new Set(Object.values(h).map((a) => a.length))];
var Kc = /* @__PURE__ */ ((a) => (a[a.Financial = 0] = "Financial", a[a.Date = 1] = "Date", a[a.Math = 2] = "Math", a[a.Statistical = 3] = "Statistical", a[a.Lookup = 4] = "Lookup", a[a.Database = 5] = "Database", a[a.Text = 6] = "Text", a[a.Logical = 7] = "Logical", a[a.Information = 8] = "Information", a[a.Engineering = 9] = "Engineering", a[a.Cube = 10] = "Cube", a[a.Compatibility = 11] = "Compatibility", a[a.Web = 12] = "Web", a[a.Array = 13] = "Array", a[a.Univer = 14] = "Univer", a[a.User = 15] = "User", a[a.DefinedName = 16] = "DefinedName", a[a.Table = 17] = "Table", a))(Kc || {}), Z = /* @__PURE__ */ ((a) => (a.PLUS = "+", a.MINUS = "-", a.MULTIPLY = "*", a.DIVIDED = "/", a.CONCATENATE = "&", a.POWER = "^", a.EQUALS = "=", a.NOT_EQUAL = "<>", a.GREATER_THAN = ">", a.GREATER_THAN_OR_EQUAL = ">=", a.LESS_THAN = "<", a.LESS_THAN_OR_EQUAL = "<=", a))(Z || {}), Y = /* @__PURE__ */ ((a) => (a.EQUALS = "=", a.NOT_EQUAL = "<>", a.GREATER_THAN = ">", a.GREATER_THAN_OR_EQUAL = ">=", a.LESS_THAN = "<", a.LESS_THAN_OR_EQUAL = "<=", a))(Y || {});
const dn = /* @__PURE__ */ new Map([
  ["<>", 4],
  ["<", 4],
  [">=", 4],
  ["=", 4],
  [">", 4],
  ["<=", 4],
  ["&", 3],
  ["+", 2],
  ["-", 2],
  ["/", 1],
  ["*", 1],
  ["^", 0]
  // ^
]), Mt = new Set(dn.keys()), Zc = /* @__PURE__ */ new Set([
  "=",
  "<>",
  ">",
  ">=",
  "<",
  "<="
  /* LESS_THAN_OR_EQUAL */
]);
var X = /* @__PURE__ */ ((a) => (a.OPEN_BRACKET = "(", a.CLOSE_BRACKET = ")", a.COMMA = ",", a.SINGLE_QUOTATION = "'", a.DOUBLE_QUOTATION = '"', a.OPEN_BRACES = "{", a.CLOSE_BRACES = "}", a.COLON = ":", a.OPEN_SQUARE_BRACKET = "[", a.CLOSE_SQUARE_BRACKET = "]", a))(X || {}), nt = /* @__PURE__ */ ((a) => (a.PERCENTAGE = "%", a.POUND = "#", a))(nt || {});
const Rs = /* @__PURE__ */ new Set([
  "%",
  "#"
  /* POUND */
]);
var we = /* @__PURE__ */ ((a) => (a.AT = "@", a.MINUS = "-", a.PLUS = "+", a))(we || {});
const zc = " ", go = [
  ...Object.values(Y),
  ...Object.values(Z),
  ...Object.values(X),
  ...Object.values(nt),
  ...Object.values(we)
];
function Cn(a) {
  return go.includes(a);
}
function Jc(a) {
  for (const i of go)
    if (a.indexOf(i) > -1)
      return !0;
  return !1;
}
function vb(a) {
  return a[0] === "'" && a[a.length - 1] === "'" ? a.substring(1, a.length - 1) : a;
}
function Tb(a) {
  return Cn(a) && a !== X.CLOSE_BRACES && a !== X.CLOSE_BRACKET && a !== X.SINGLE_QUOTATION && a !== X.DOUBLE_QUOTATION || a === " ";
}
const el = /* @__PURE__ */ new Set([
  Z.PLUS,
  Z.MINUS,
  Z.MULTIPLY,
  Z.DIVIDED,
  Z.CONCATENATE,
  Z.POWER,
  Z.EQUALS,
  Z.NOT_EQUAL,
  Z.GREATER_THAN,
  Z.GREATER_THAN_OR_EQUAL,
  Z.LESS_THAN,
  Z.LESS_THAN_OR_EQUAL,
  X.OPEN_BRACKET,
  X.COMMA,
  X.COLON,
  X.OPEN_BRACES,
  X.OPEN_SQUARE_BRACKET
]);
function tl(a) {
  return el.has(a);
}
const rl = /* @__PURE__ */ new Set([
  Z.PLUS,
  Z.MINUS,
  Z.MULTIPLY,
  Z.DIVIDED,
  Z.CONCATENATE,
  Z.POWER,
  Z.EQUALS,
  Z.NOT_EQUAL,
  Z.GREATER_THAN,
  Z.GREATER_THAN_OR_EQUAL,
  Z.LESS_THAN,
  Z.LESS_THAN_OR_EQUAL,
  X.OPEN_BRACKET,
  X.COMMA,
  X.COLON,
  X.OPEN_BRACES,
  X.OPEN_SQUARE_BRACKET,
  nt.PERCENTAGE,
  nt.POUND
]);
function nl(a) {
  return rl.has(a);
}
const Dr = '\\[([^\\[\\]\\/?:"<>|*\\\\]+)\\]', oi = new RegExp(Dr), sl = "((?![\\[\\]\\/?*\\\\]).)*!", $t = "$", es = "\\s*?:\\s*?", Nn = "[A-Za-z]+", Vn = "[1-9][0-9]*", wr = `'?(${Dr})?(${sl})?'?`, Us = `\\${$t}?${Nn}\\${$t}?${Vn}`, al = `^(${we.AT})?${wr}${Us}${es}${Us}$`, ui = new RegExp(al), il = `^${wr}\\s*?${Us}(${nt.POUND})?$`, ci = new RegExp(il), ol = `^${wr}\\${$t}?${Vn}${es}\\${$t}?${Vn}$`, li = new RegExp(ol), ul = `^${wr}\\${$t}?${Nn}${es}\\${$t}?${Nn}$`, fi = new RegExp(ul), cl = `^${wr}\\s*?\\${$t}?${Vn}$`, mi = new RegExp(cl), ll = `^${wr}\\s*?\\${$t}?${Nn}$`, hi = new RegExp(ll), Br = "((?![~!@#$%^&*()_+<>?:,./;’，。、‘：“《》？~！@#￥%……（）【】\\[\\]\\/\\\\]).)+", Co = "\\[#.+\\]\\s*?,\\s*?", On = "\\[((?<!#).)*\\]", gi = `${On}${es}${On}`, fl = `^(${Dr})?${Br}$`, ml = `^(${Dr})?${Br}(${On}|\\[${Co}${On}\\])+$`, hl = `^(${Dr})?${Br}(\\[${gi}\\])?$|^${Br}(\\[${Co}${gi}\\])?$`, gl = `^(${Dr})?${Br}\\[\\s*#([^\\]]+)\\s*\\]$`, di = new RegExp(fl), Ci = new RegExp(ml), _i = new RegExp(hl), Ai = new RegExp(gl), dl = "{.*?}", Ei = new RegExp(dl, "g");
function qr(a) {
  return ci.lastIndex = 0, ci.test(a);
}
function Cl(a) {
  return ui.lastIndex = 0, ui.test(a);
}
function _o(a) {
  return li.lastIndex = 0, li.test(a);
}
function Ao(a) {
  return fi.lastIndex = 0, fi.test(a);
}
function Eo(a) {
  return mi.lastIndex = 0, mi.test(a);
}
function Ro(a) {
  return hi.lastIndex = 0, hi.test(a);
}
function _l(a) {
  return di.lastIndex = 0, di.test(a);
}
function Al(a) {
  return Ci.lastIndex = 0, Ci.test(a);
}
function El(a) {
  return _i.lastIndex = 0, _i.test(a);
}
function Rl(a) {
  return Ai.lastIndex = 0, Ai.test(a);
}
function bl(a) {
  return Ei.lastIndex = 0, Ei.test(a);
}
function bo(a) {
  return qr(a) || Cl(a) || _o(a) || Ao(a);
}
function yl(a) {
  const i = {};
  return Object.keys(a).forEach((e) => {
    const t = a[e];
    if (t == null)
      return !0;
    i[e] == null && (i[e] = {}), Object.keys(t).forEach((r) => {
      const n = t[r];
      i[e][r] = new de(n);
    });
  }), i;
}
function pl(a) {
  const i = {};
  for (const e in a) {
    const t = a[e];
    if (t != null) {
      i[e] == null && (i[e] = {});
      for (const r in t) {
        const n = t[r], s = {};
        n.forValue((o, u, c) => {
          s[o] === void 0 && (s[o] = {}), s[o][u] = c;
        }), i[e][r] = s;
      }
    }
  }
  return i;
}
const At = "P_1", Ft = "R_1", Rr = "L_1", Xr = "LR_1", yo = "LO_1", Nl = "LET", Fr = "LAMBDA", Vl = "CUBE", Ol = /* @__PURE__ */ new Set(["RAND", "RANDBETWEEN", "NOW", "TODAY"]), Sl = {
  id: "formula.mutation.register-function",
  type: Ie.MUTATION,
  handler: () => !0
}, vs = {
  id: "formula.mutation.set-array-formula-data",
  type: Ie.MUTATION,
  handler: (a, i) => !0
}, Ml = /[^0-9]/g, Dl = /[^A-Za-z]/g;
function _n(a) {
  let i = a[0] === "$";
  const e = a.substring(1);
  let t = e.indexOf("$") > -1;
  return Ge.isStringNumber(e) && i && !t && (i = !1, t = !0), i && t ? Le.ALL : i ? Le.COLUMN : t ? Le.ROW : Le.NONE;
}
function Ib(a) {
  const i = a.split("!");
  i.length > 1 && (a = i[i.length - 1]);
  const e = a.split(":");
  return e.length > 1 ? {
    startAbsoluteRefType: _n(e[0]),
    endAbsoluteRefType: _n(e[1])
  } : { startAbsoluteRefType: _n(e[0]) };
}
function Ri(a = Le.NONE) {
  let i = "", e = "";
  return a === Le.ROW ? i = "$" : a === Le.COLUMN ? e = "$" : a === Le.ALL && (i = "$", e = "$"), {
    rowAbsoluteString: i,
    columnAbsoluteString: e
  };
}
function Yt(a) {
  const {
    startColumn: i,
    startRow: e,
    endColumn: t,
    endRow: r,
    startAbsoluteRefType: n,
    endAbsoluteRefType: s,
    rangeType: o = rt.NORMAL
  } = a, u = Ri(n), c = Ri(s);
  if (o === rt.ROW || o === rt.ALL) {
    const m = `${u.rowAbsoluteString}${e + 1}`, d = `${c.rowAbsoluteString}${r + 1}`;
    return `${m}:${d}`;
  }
  if (o === rt.COLUMN) {
    const m = `${u.columnAbsoluteString}${Ge.chatAtABC(i)}`, d = `${c.columnAbsoluteString}${Ge.chatAtABC(t)}`;
    return `${m}:${d}`;
  }
  const l = `${u.columnAbsoluteString}${Ge.chatAtABC(i)}${u.rowAbsoluteString}${e + 1}`, f = `${c.columnAbsoluteString}${Ge.chatAtABC(t)}${c.rowAbsoluteString}${r + 1}`;
  return l === f ? l : `${l}:${f}`;
}
function wl(a, i) {
  return `${No(a)}!${Yt(i)}`;
}
function Ll(a, i, e) {
  return Is(a) || Is(i) ? `'[${Bs(a)}]${Bs(i)}'!${Yt(e)}` : `[${a}]${i}!${Yt(e)}`;
}
function Ts(a) {
  const { unitId: i, sheetName: e, range: t } = a;
  return i != null && i.length > 0 && e != null && e.length > 0 ? Ll(i, e, t) : e != null && e.length > 0 ? wl(e, t) : Yt(t);
}
function bs(a) {
  const i = Number.parseInt(a.replace(Ml, "")) - 1, e = Ge.ABCatNum(a.replace(Dl, "")), t = _n(a);
  return {
    row: i,
    column: e,
    absoluteRefType: t
  };
}
function Ca(a) {
  const i = oi.exec(a);
  let e = "";
  i != null && (e = i[0].trim(), e = bi(e.slice(1, e.length - 1)), a = a.replace(oi, ""));
  const t = a.indexOf("!");
  let r = "", n = "";
  return t > -1 ? (r = a.substring(0, t), r[0] === "'" && r[r.length - 1] === "'" && (r = r.substring(1, r.length - 1)), r = bi(r), n = a.substring(t + 1)) : n = a, {
    refBody: n,
    sheetName: r,
    unitId: e
  };
}
function kr(a) {
  const { refBody: i, sheetName: e, unitId: t } = Ca(a), r = i.indexOf(":");
  if (r === -1) {
    const _ = bs(i), C = _.row, E = _.column, R = _.absoluteRefType;
    return {
      unitId: t,
      sheetName: e,
      range: {
        startRow: C,
        startColumn: E,
        endRow: C,
        endColumn: E,
        startAbsoluteRefType: R,
        endAbsoluteRefType: R
      }
    };
  }
  const n = i.substring(0, r), s = i.substring(r + 1), o = bs(n), u = bs(s), c = o.row > u.row ? u.row : o.row, l = o.column > u.column ? u.column : o.column, f = o.row > u.row ? o.row : u.row, m = o.column > u.column ? o.column : u.column;
  let d = rt.NORMAL;
  return Number.isNaN(c) && Number.isNaN(f) ? d = rt.COLUMN : Number.isNaN(l) && Number.isNaN(m) && (d = rt.ROW), {
    unitId: t,
    sheetName: e,
    range: {
      startRow: c,
      startColumn: l,
      endRow: f,
      endColumn: m,
      startAbsoluteRefType: o.absoluteRefType,
      endAbsoluteRefType: u.absoluteRefType,
      rangeType: d
    }
  };
}
const Pl = ["LOG10"];
function An(a) {
  const i = po(a);
  if (!bo(i) || Pl.includes(i.toUpperCase().trim()))
    return !1;
  const { range: e } = kr(i);
  return !(e.endColumn >= 16384);
}
function po(a) {
  const i = [];
  let e = !1;
  for (let t = 0, r = a.length; t < r; t++) {
    const n = a[t];
    if (n === zc && !e)
      i.push(n);
    else {
      if (!e && (n === we.AT || n === we.MINUS || n === we.PLUS))
        continue;
      i.push(n), e = !0;
    }
  }
  return i.join("");
}
function Bb(a, i) {
  const e = (a == null ? void 0 : a.split(",")) || [];
  return a === "" || e.length === 0 ? [] : xl(a) ? e.map((n) => {
    const s = kr(n);
    return {
      unitId: s.unitId,
      sheetId: i(s.sheetName),
      range: s.range,
      sheetName: s.sheetName
    };
  }) : [];
}
function xl(a) {
  return ((a == null ? void 0 : a.split(",")) || []).every((e) => An(e.trim()));
}
function Is(a) {
  return a.length === 0 ? !1 : !!(Jc(a) || jl(a) || Ul(a) || vl(a) || /[\s!$%^&*()+\-=\[\]{};':"\\|,.<>\/?（）]/.test(a));
}
function No(a) {
  return Is(a) ? `'${Bs(a)}'` : a;
}
function Bs(a) {
  return a.replace(/'/g, "''");
}
function bi(a) {
  return a.replace(/''/g, "'");
}
function jl(a) {
  const i = a.match(/[1-9][0-9]{0,6}/);
  return /^[A-Z]+[1-9][0-9]{0,6}$/.test(a) && i !== null;
}
function Ul(a) {
  return /^(R(-?[0-9]+)?C(-?[0-9]+)?|C(-?[0-9]+)?|R(-?[0-9]+)?)$/.test(a);
}
function vl(a) {
  return !new RegExp("^\\p{Letter}", "u").test(a.charAt(0));
}
var Tl = Object.getOwnPropertyDescriptor, Il = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Tl(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, Bl = (a, i) => (e, t) => i(e, t, a);
let Fs = class extends Se {
  constructor(i) {
    super();
    // 18.2.6 definedNames (Defined Names)
    A(this, "_definedNameMap", {});
    A(this, "_nameCacheMap", {});
    // Cache for name-to-definition mapping
    A(this, "_update$", new tr());
    A(this, "update$", this._update$.asObservable());
    A(this, "_currentRange", {
      unitId: "",
      sheetId: "",
      range: {
        startRow: 0,
        endRow: 0,
        startColumn: 0,
        endColumn: 0
      }
    });
    A(this, "_currentRange$", new tr());
    A(this, "currentRange$", this._currentRange$.asObservable());
    A(this, "_focusRange$", new tr());
    A(this, "focusRange$", this._focusRange$.asObservable());
    this._univerInstanceService = i;
  }
  dispose() {
    super.dispose(), this._definedNameMap = {}, this._nameCacheMap = {}, this._update$.complete(), this._currentRange$.complete(), this._focusRange$.complete();
  }
  getWorksheetByRef(i, e) {
    var r;
    const { sheetName: t } = Ca(e);
    return (r = this._univerInstanceService.getUnit(i)) == null ? void 0 : r.getSheetBySheetName(t);
  }
  focusRange(i, e) {
    const t = this.getValueById(i, e);
    t !== void 0 && this._focusRange$.next({ ...t, unitId: i });
  }
  setCurrentRange(i) {
    this._currentRange = i, this._currentRange$.next(i);
  }
  getCurrentRange() {
    return this._currentRange;
  }
  getCurrentRangeForString() {
    return Yt(this._currentRange.range);
  }
  registerDefinedNames(i, e) {
    this._definedNameMap[i] = e, this._updateCache(i), this._update();
  }
  registerDefinedName(i, e) {
    this._definedNameMap[i] === void 0 && (this._definedNameMap[i] = {}), this._definedNameMap[i][e.id] = e, this._updateCache(i), this._update();
  }
  removeDefinedName(i, e) {
    var t;
    (t = this._definedNameMap[i]) == null || delete t[e], this._updateCache(i), this._update();
  }
  removeUnitDefinedName(i) {
    delete this._definedNameMap[i], this._updateCache(i), this._update();
  }
  getDefinedNameMap(i) {
    return this._definedNameMap[i];
  }
  getValueByName(i, e) {
    const t = this._nameCacheMap[i];
    if (t)
      return t[e] || null;
    const r = this._definedNameMap[i];
    if (r === void 0)
      return null;
    let n = null;
    for (const s of Object.values(r))
      if (s.name === e) {
        n = s;
        break;
      }
    return n && (this._nameCacheMap[i] = this._nameCacheMap[i] || {}, this._nameCacheMap[i][e] = n), n;
  }
  getValueById(i, e) {
    var t;
    return (t = this._definedNameMap[i]) == null ? void 0 : t[e];
  }
  hasDefinedName(i) {
    return this._definedNameMap[i] === void 0 ? !1 : (Array.from(Object.values(this._definedNameMap[i])).length || 0) !== 0;
  }
  getAllDefinedNames() {
    return this._definedNameMap;
  }
  _update() {
    this._update$.next(null);
  }
  _updateCache(i) {
    const e = this._definedNameMap[i];
    if (e === void 0) {
      delete this._nameCacheMap[i];
      return;
    }
    this._nameCacheMap[i] = {};
    for (const t of Object.values(e))
      this._nameCacheMap[i][t.name] = t;
  }
};
Fs = Il([
  Bl(0, Jn)
], Fs);
const Lr = Je("univer.formula.defined-names.service"), Fb = (a, i) => {
  const { unitId: e, id: t } = i;
  return {
    ...a.get(Lr).getValueById(e, t),
    unitId: e
  };
}, _a = {
  id: "formula.mutation.set-defined-name",
  type: Ie.MUTATION,
  handler: (a, i) => {
    if (i == null)
      return !1;
    const e = a.get(Lr), { id: t, unitId: r, name: n, formulaOrRefString: s, comment: o, hidden: u, localSheetId: c, formulaOrRefStringWithPrefix: l } = i;
    return e.registerDefinedName(r, {
      id: t,
      name: n.trim(),
      formulaOrRefString: s.trim(),
      comment: o == null ? void 0 : o.trim(),
      hidden: u,
      localSheetId: c,
      formulaOrRefStringWithPrefix: l
    }), !0;
  }
}, Vo = {
  id: "formula.mutation.remove-defined-name",
  type: Ie.MUTATION,
  handler: (a, i) => {
    if (i == null)
      return !1;
    const e = a.get(Lr), { unitId: t, id: r } = i;
    return e.removeDefinedName(t, r), !0;
  }
}, Aa = {
  id: "formula.mutation.set-feature-calculation",
  type: Ie.MUTATION,
  handler: () => !0
}, Ea = {
  id: "formula.mutation.remove-feature-calculation",
  type: Ie.MUTATION,
  handler: () => !0
}, Oo = {
  id: "formula.mutation.set-formula-calculation-start",
  type: Ie.MUTATION,
  handler: () => !0
}, So = {
  id: "formula.mutation.set-formula-calculation-stop",
  type: Ie.MUTATION,
  handler: () => !0
}, Sn = {
  id: "formula.mutation.set-formula-calculation-notification",
  type: Ie.MUTATION,
  handler: () => !0
}, Mo = {
  id: "formula.mutation.set-formula-calculation-result",
  type: Ie.MUTATION,
  handler: () => !0
}, Do = {
  id: "formula.mutation.set-formula-data",
  type: Ie.MUTATION,
  handler: (a, i) => !0
}, wo = {
  id: "formula.mutation.set-image-formula-data",
  type: Ie.MUTATION,
  handler: (a, i) => !0
}, Ra = {
  id: "formula.mutation.set-other-formula",
  type: Ie.MUTATION,
  handler: () => !0
}, ba = {
  id: "formula.mutation.remove-other-formula",
  type: Ie.MUTATION,
  handler: () => !0
};
class Fl extends Se {
  constructor() {
    super();
    // 18.5.1.2 table (Table)
    A(this, "_tableMap", /* @__PURE__ */ new Map());
    // 18.5.1.2 table (Table) for I18N
    A(this, "_tableOptionMap", /* @__PURE__ */ new Map());
    A(this, "_update$", new tr());
    A(this, "update$", this._update$.asObservable());
    this.registerTableOptionMap(De.ALL, De.ALL), this.registerTableOptionMap(De.DATA, De.DATA), this.registerTableOptionMap(De.HEADERS, De.HEADERS), this.registerTableOptionMap(De.TOTALS, De.TOTALS), this.registerTableOptionMap(De.THIS_ROW, De.THIS_ROW);
  }
  dispose() {
    super.dispose(), this._update$.complete(), this._tableMap.clear(), this._tableOptionMap.clear();
  }
  remove(e, t) {
    var r;
    (r = this._tableMap.get(e)) == null || r.delete(t), this._update();
  }
  getTableMap(e) {
    return this._tableMap.get(e);
  }
  getTableOptionMap() {
    return this._tableOptionMap;
  }
  registerTable(e, t, r) {
    var n;
    this._tableMap.get(e) == null && this._tableMap.set(e, /* @__PURE__ */ new Map()), (n = this._tableMap.get(e)) == null || n.set(t, r), this._update();
  }
  registerTableOptionMap(e, t) {
    this._tableOptionMap.set(e, t);
  }
  _update() {
    this._update$.next(null);
  }
}
const Pr = Je("univer.formula.super-table.service"), kl = {
  id: "formula.mutation.set-super-table",
  type: Ie.MUTATION,
  handler: (a, i) => {
    const { unitId: e, tableName: t, reference: r } = i;
    return a.get(Pr).registerTable(e, t, r), !0;
  }
}, $l = {
  id: "formula.mutation.remove-super-table",
  type: Ie.MUTATION,
  handler: (a, i) => {
    const { unitId: e, tableName: t } = i;
    return a.get(Pr).remove(e, t), !0;
  }
}, Lo = {
  id: "formula.mutation.set-super-table-option",
  type: Ie.MUTATION,
  handler: (a, i) => {
    const { tableOption: e, tableOptionType: t } = i;
    return a.get(Pr).registerTableOptionMap(e, t), !0;
  }
};
class xt {
  constructor(i) {
    A(this, "_cache");
    this._cache = new Sc(i);
  }
  set(i, e) {
    const t = this._hash(i);
    this._cache.set(t, e);
  }
  get(i) {
    const e = this._hash(i);
    return this._cache.get(e);
  }
  clear() {
    this._cache.clear();
  }
  delete(i) {
    this._cache.delete(this._hash(i));
  }
  forEach(i, e) {
    this._cache.forEach(i, e);
  }
  _hash(i) {
    return i.length <= 64 ? i : Mc(i).toString();
  }
}
const ks = new xt(1e5);
function br(a) {
  const i = ks.get(a);
  if (i)
    return i;
  const e = kr(a);
  return ks.set(a, e), kr(a);
}
function Yl() {
  ks.clear();
}
var He = /* @__PURE__ */ ((a) => (a[a.NORMAL = 0] = "NORMAL", a[a.NUMBER = 1] = "NUMBER", a[a.STRING = 2] = "STRING", a[a.FUNCTION = 3] = "FUNCTION", a[a.REFERENCE = 4] = "REFERENCE", a[a.ARRAY = 5] = "ARRAY", a[a.DEFINED_NAME = 6] = "DEFINED_NAME", a))(He || {});
function yi(a) {
  let i = "";
  for (const e of a)
    typeof e == "string" ? i += e : i += e.token;
  return i;
}
class ie {
  constructor() {
    A(this, "_parent");
    A(this, "_token", Ft);
    A(this, "_children", []);
    A(this, "_lambdaId");
    A(this, "_functionDefinitionPrivacyVar");
    A(this, "_lambdaParameter", "");
    A(this, "_startIndex", -1);
    A(this, "_endIndex", -1);
    A(this, "_definedNames", []);
  }
  dispose() {
    var i;
    this._children.forEach((e) => {
      typeof e != "string" && e.dispose();
    }), (i = this._functionDefinitionPrivacyVar) == null || i.clear(), this._functionDefinitionPrivacyVar = null, this._children = [], this._parent = null, this._definedNames = [];
  }
  getDefinedNames() {
    return this._definedNames;
  }
  getStartIndex() {
    return this._startIndex;
  }
  getLambdaId() {
    return this._lambdaId;
  }
  setLambdaId(i) {
    this._lambdaId = i;
  }
  getFunctionDefinitionPrivacyVar() {
    return this._functionDefinitionPrivacyVar;
  }
  setLambdaPrivacyVar(i) {
    this._functionDefinitionPrivacyVar = i;
  }
  getLambdaParameter() {
    return this._lambdaParameter;
  }
  setLambdaParameter(i) {
    this._lambdaParameter = i;
  }
  getParent() {
    return this._parent;
  }
  setParent(i) {
    this._parent = i;
  }
  getChildren() {
    return this._children;
  }
  setChildren(i) {
    this._children = i;
  }
  addChildren(i) {
    this._children.push(i);
  }
  addChildrenFirst(i) {
    this._children.unshift(i);
  }
  getToken() {
    return this._token;
  }
  setToken(i) {
    this._token = i;
  }
  setIndex(i, e) {
    this._startIndex = i, this._endIndex = e;
  }
  setDefinedNames(i) {
    this._definedNames = i;
  }
  hasDefinedNames() {
    return this._definedNames.length > 0;
  }
  replaceChild(i, e) {
    const t = this._getIndexInParent(i);
    t != null && (this.getChildren().splice(t, 1, e), e.setParent(this));
  }
  changeToParent(i) {
    const e = this.getParent();
    e && e.removeChild(this), this.setParent(i), i.getChildren().push(this);
  }
  removeChild(i) {
    const e = this._getIndexInParent(i);
    e != null && this.getChildren().splice(e, 1);
  }
  serialize() {
    const i = this.getToken(), e = this.getChildren(), t = [], r = e.length;
    for (let n = 0; n < r; n++) {
      const s = e[n];
      s instanceof ie ? t.push(s.serialize()) : t.push(s);
    }
    return {
      token: i,
      st: this._startIndex,
      ed: this._endIndex,
      children: t
    };
  }
  _getIndexInParent(i) {
    const e = this.getChildren(), t = e.length;
    for (let r = 0; r < t; r++)
      if (e[r] === i)
        return r;
  }
}
const Po = 2e3, ys = new xt(Po), ps = new xt(Po);
class Mn extends Se {
  constructor() {
    super(...arguments);
    A(this, "_currentLexerNode", new ie());
    A(this, "_upLevel", 0);
    A(this, "_segment", "");
    A(this, "_bracketState", []);
    // ()
    A(this, "_squareBracketState", 0);
    A(this, "_bracesState", 0);
    // {}
    A(this, "_singleQuotationState", 0);
    // ''
    A(this, "_doubleQuotationState", 0);
    // ""
    A(this, "_lambdaState", !1);
    // Lambda
    A(this, "_colonState", !1);
    // :
    A(this, "_formulaErrorCount", 0);
    A(this, "_tableBracketState", !1);
  }
  // Table3[[#All],[Column1]:[Column2]]
  dispose() {
    this._resetTemp(), this._currentLexerNode.dispose(), ys.clear(), ps.clear();
  }
  getUpLevel() {
    return this._upLevel;
  }
  isColonClose() {
    return this._colonState === !1;
  }
  isColonOpen() {
    return this._colonState === !0;
  }
  isDoubleQuotationClose() {
    return this._doubleQuotationState === 0;
  }
  isLambdaOpen() {
    return this._lambdaState === !0;
  }
  isLambdaClose() {
    return this._lambdaState === !1;
  }
  isSingleQuotationClose() {
    return this._singleQuotationState === 0;
  }
  isBracesClose() {
    return this._bracesState === 0;
  }
  isBracketClose() {
    return this._bracketState.length === 0;
  }
  isSquareBracketClose() {
    return this._squareBracketState === 0;
  }
  getCurrentLexerNode() {
    return this._currentLexerNode;
  }
  getFunctionAndParameter(e, t) {
    const r = this._getCurrentParamIndex(e, t);
    if (r == null || r === h.VALUE)
      return;
    const n = r[0];
    if (typeof n == "string")
      return;
    let s = n.getParent(), o = n;
    for (; s; ) {
      const u = s.getToken();
      if (u !== At && !Cn(u) && s.getStartIndex() !== -1) {
        const c = s.getChildren().indexOf(o);
        return {
          functionName: u,
          paramIndex: c
        };
      }
      o = s, s = s.getParent();
    }
  }
  /**
   * Estimate the number of right brackets that need to be automatically added to the end of the formula.
   * @param formulaString
   */
  checkIfAddBracket(e) {
    let t = 0, r = e.length - 1, n = e[r];
    for (; (n === X.CLOSE_BRACKET || n === " ") && r >= 0; )
      n === X.CLOSE_BRACKET && t++, n = e[--r];
    const s = this._getCurrentParamIndex(e, e.length - 2);
    if (s == null || s === h.VALUE)
      return 0;
    const o = s[0];
    if (typeof o == "string")
      return 0;
    let u = o.getParent(), c = 0;
    for (s[1] === X.OPEN_BRACKET && c++; u; ) {
      const l = u.getToken();
      l !== At && l !== X.COLON && u.getStartIndex() !== -1 && l.toUpperCase() !== Fr && (t === 0 ? c += 1 : t--), u = u.getParent();
    }
    return c;
  }
  sequenceNodesBuilder(e) {
    const t = ps.get(e);
    if (t)
      return [...t];
    const r = this._getSequenceArray(e);
    if (r.length === 0)
      return;
    const n = this.getSequenceNode(r);
    return ps.set(e, [...n]), n;
  }
  convertRefersToAbsolute(e, t, r, n = "") {
    const s = this.sequenceNodesBuilder(e);
    if (s == null)
      return e;
    let o = "";
    e.substring(0, 1) === Z.EQUALS && (o = Z.EQUALS);
    for (let u = 0, c = s.length; u < c; u++) {
      const l = s[u];
      if (typeof l != "string" && l.nodeType === He.REFERENCE) {
        const { token: f, endIndex: m } = l, d = br(f);
        if (d == null)
          continue;
        const { range: _, sheetName: C, unitId: E } = d, R = {
          ..._,
          startAbsoluteRefType: t,
          endAbsoluteRefType: r
        }, b = Ts({
          range: R,
          unitId: E,
          sheetName: C || n
        }), p = b.length - f.length;
        s[u] = {
          ...l,
          token: b,
          endIndex: m + p
        };
        for (let V = u + 1; V < c; V++) {
          const S = s[V];
          typeof S != "string" && (S.startIndex += p, S.endIndex += p);
        }
      }
    }
    return `${o}${yi(s)}`;
  }
  moveFormulaRefOffset(e, t, r, n = !1) {
    const s = this.sequenceNodesBuilder(e);
    if (s == null)
      return e;
    const o = [];
    for (let u = 0, c = s.length; u < c; u++) {
      const l = s[u];
      if (typeof l == "string" || l.nodeType !== He.REFERENCE) {
        o.push(l);
        continue;
      }
      const { token: f } = l, m = br(f), { sheetName: d, unitId: _ } = m;
      let C = m.range;
      if (!n && C.startAbsoluteRefType === Le.ALL && C.endAbsoluteRefType === Le.ALL) {
        o.push(l);
        continue;
      } else
        C = ga(C, t, r, n);
      let E = "";
      Dc(C) ? E = Ts({
        range: C,
        unitId: _,
        sheetName: d
      }) : E = h.REF, o.push({
        ...l,
        token: E
      });
    }
    return `=${yi(o)}`;
  }
  /**
   * univer-pro/issues/1684
   * =sum({}{})
   */
  _formulaSpellCheck() {
    if (this._currentLexerNode.getChildren().length === 0)
      return !0;
    const e = this._currentLexerNode.getChildren()[0];
    return e instanceof ie ? !0 : !!(this._passArrayOperator(e) || Mt.has(e) || Rs.has(e) || e === we.AT || e === X.COMMA || e === X.COLON || e === X.OPEN_BRACKET);
  }
  /**
   * ={0,1,2,3,4,5,6} + {0;1;2;3;4;5;6}*7
   */
  _passArrayOperator(e) {
    if (e.length === 0 || !(e[0] === "{" && e[e.length - 1] === "}"))
      return !1;
    const t = this._currentLexerNode.getChildren(), r = t[t.length - 1];
    return r instanceof ie ? !1 : !!Mt.has(r);
  }
  // eslint-disable-next-line complexity
  getSequenceNode(e) {
    const t = [];
    let r = !1;
    for (let n = 0, s = e.length; n < s; n++) {
      const o = e[n], u = e[n - 1], { segment: c, currentString: l } = o;
      if (l === X.DOUBLE_QUOTATION && (r = !0), (c !== "" || n === 0) && n !== s - 1) {
        t.push(l);
        continue;
      }
      let f = (u == null ? void 0 : u.segment) || "";
      const m = n - f.length;
      let d = n - 1;
      const _ = n - 1;
      if (n === s - 1 && this._isLastMergeString(l) && (f += l, d += 1), f === "" || dn.has(f)) {
        t.push(l);
        continue;
      }
      const C = f.trim(), E = po(C);
      r === !0 && C[C.length - 1] === X.DOUBLE_QUOTATION && C[0] !== X.OPEN_BRACES ? (r = !1, this._processPushSequenceNode(t, He.STRING, f, m, d, _)) : qr(E) && An(E) ? this._processPushSequenceNode(t, He.REFERENCE, f, m, d, _) : Ge.isStringNumber(C) ? this._processPushSequenceNode(t, He.NUMBER, f, m, d, _) : C.length > 0 && this._processPushSequenceNode(t, He.FUNCTION, f, m, d, _), (n !== s - 1 || !this._isLastMergeString(l)) && t.push(l);
    }
    return this._mergeSequenceNodeReference(t);
  }
  _processPushSequenceNode(e, t, r, n, s, o) {
    this._pushSequenceNode(
      e,
      {
        nodeType: t,
        token: r,
        startIndex: n,
        endIndex: s
      },
      o
    );
  }
  _getCurrentParamIndex(e, t) {
    return this._nodeMaker(e, void 0, t);
  }
  _isLastMergeString(e) {
    return e === X.DOUBLE_QUOTATION || Ge.isStringNumber(e) || !Cn(e);
  }
  /**
   * Merge array and handle ref operations
   *
   */
  _mergeSequenceNodeReference(e) {
    const t = [], r = e.length;
    let n = 0;
    for (; n < r; ) {
      const s = e[n];
      if (typeof s == "string") {
        const o = e[n - 1];
        if (s.trim() === X.CLOSE_BRACES && o != null && typeof o != "string" && o.nodeType === He.FUNCTION && o.token.trim().substring(0, 1) === X.OPEN_BRACES) {
          o.nodeType = He.ARRAY, o.token += s, o.endIndex += s.length, n++;
          continue;
        }
        t.push(s);
      } else {
        const o = e[n + 1], u = e[n + 2];
        o === X.COLON && typeof s != "string" && u != null && typeof u != "string" && An((s.token + o + u.token).trim()) && (s.nodeType = He.REFERENCE, s.token += o + u.token, s.endIndex = u.endIndex, n += 2), t.push(s);
      }
      n++;
    }
    return this._minusSplitSequenceNode(t);
  }
  /**
   * =-A1  Separate the negative sign from the ref string.
   */
  _minusSplitSequenceNode(e) {
    const t = [];
    for (const r of e) {
      if (typeof r != "string") {
        const s = r.token.match(/^(\s*([-@+]\s*)+)(.*)$/);
        if (s) {
          const o = s[1], u = s[3];
          if (An(u.trim())) {
            const c = o.length, l = r.startIndex, f = r.startIndex + c - 1, m = {
              nodeType: He.NORMAL,
              // Use appropriate nodeType for operators
              token: o,
              startIndex: l,
              endIndex: f
            }, d = {
              nodeType: He.REFERENCE,
              token: u,
              startIndex: f + 1,
              endIndex: r.endIndex
            };
            t.push(m), t.push(d);
            continue;
          }
        }
      }
      t.push(r);
    }
    return t;
  }
  _pushSequenceNode(e, t, r) {
    const n = r - t.startIndex + 1;
    e.splice(e.length - n, n, t);
  }
  nodeMakerTest(e) {
    return this._nodeMaker(e);
  }
  treeBuilder(e, t = !0, r) {
    var f;
    if (t === !0) {
      const m = ys.get(e), d = r && ((f = this._simpleCheckDefinedName) == null ? void 0 : f.call(this, e, r));
      if (m && !d)
        return m;
    }
    this._resetCurrentLexerNode(), this._currentLexerNode.setToken(Ft);
    const n = [];
    let s = this._nodeMaker(e, n);
    if (s === h.VALUE || n.length === 0)
      return s;
    let o = !1, u = "", c = [];
    if (r) {
      const { hasDefinedName: m, sequenceString: d, definedNames: _ } = this._handleDefinedName(n, r);
      o = m, u = d, c = _;
    }
    if (o && (this._resetCurrentLexerNode(), this._currentLexerNode.setToken(Ft), s = this._nodeMaker(`=${u}`), s === h.VALUE))
      return s;
    const l = this._getTopNode(this._currentLexerNode);
    if (l && (this._currentLexerNode = l), t) {
      if (!this._suffixExpressionHandler(this._currentLexerNode))
        return h.VALUE;
      ys.set(e, this._currentLexerNode);
    }
    return o && this._currentLexerNode.setDefinedNames(c), this._currentLexerNode;
  }
  _handleDefinedName(e, t) {
    const { unitId: r, getValueByName: n, getSheetName: s } = t;
    if (r == null)
      return {
        sequenceString: "",
        hasDefinedName: !1,
        definedNames: []
      };
    const o = this.getSequenceNode(e);
    let u = "", c = !1;
    const l = [];
    for (let f = 0, m = o.length; f < m; f++) {
      const d = o[f];
      if (typeof d == "string") {
        u += d;
        continue;
      }
      const { nodeType: _, token: C } = d;
      let E = C;
      if (_ === He.REFERENCE || _ === He.FUNCTION) {
        _ === He.FUNCTION && (E = this._getHasSheetNameDefinedName(C, r, t));
        const R = n(r, E);
        if (R) {
          const b = R.formulaOrRefString, p = this._handleNestedDefinedName(b, t);
          if (p == null || typeof p != "object")
            u += p || h.NAME, c = !0, l.push(E);
          else if (typeof p == "object") {
            const { sequenceString: V, definedNames: S } = p;
            u += V, S.forEach((M) => {
              l.push(M);
            }), c = !0;
          }
        } else this._checkDefinedNameDirty(E, t) ? (u += h.NAME, c = !0, l.push(E)) : u += E;
      } else
        u += E;
    }
    return {
      sequenceString: u,
      hasDefinedName: c,
      definedNames: l
    };
  }
  _getHasSheetNameDefinedName(e, t, r) {
    if (!e.includes("!"))
      return e;
    const n = e.split("!");
    if (n.length !== 2)
      return e;
    const s = n[0], o = n[1].trim(), u = r.getValueByName(t, o);
    if (!u)
      return e;
    const c = u.localSheetId;
    if (c !== void 0) {
      if (c === "AllDefaultWorkbook")
        return o;
      const l = r.getSheetName(t, c);
      if (s === l)
        return o;
    } else
      return o;
    return e;
  }
  _handleNestedDefinedName(e, t) {
    const r = [], n = this._nodeMaker(e, r);
    return n === h.VALUE || r.length === 0 ? n : this._handleDefinedName(r, t);
  }
  _simpleCheckDefinedName(e, t) {
    const { getDirtyDefinedNameMap: r, unitId: n } = t, s = r(), o = n;
    if (o != null && s[o] != null) {
      const u = Object.keys(s[o]);
      for (let c = 0, l = u.length; c < l; c++) {
        const f = u[c];
        if (e.indexOf(f) > -1)
          return !0;
      }
    }
    return !1;
  }
  _checkDefinedNameDirty(e, t) {
    const { getDirtyDefinedNameMap: r, unitId: n } = t, s = r(), o = n;
    if (o != null && s[o] != null) {
      const u = Object.keys(s[o]);
      for (let c = 0, l = u.length; c < l; c++)
        if (u[c] === e)
          return !0;
    }
    return !1;
  }
  // eslint-disable-next-line complexity
  _suffixExpressionHandler(e) {
    var u;
    const t = e.getChildren();
    if (!t)
      return !1;
    const r = t.length, n = [], s = [];
    let o = !0;
    for (let c = 0; c < r; c++) {
      const l = t[c];
      if (l instanceof ie)
        o = this._suffixExpressionHandler(l), n.push(l);
      else {
        const f = l.trim();
        if (f === "")
          continue;
        if (Mt.has(f)) {
          if (f === Z.PLUS && this._deletePlusForPreNode(t[c - 1]))
            continue;
          if (f !== Z.PLUS && f !== Z.MINUS && this._deletePlusForPreNode(t[c - 1]))
            return !1;
          for (; s.length > 0; ) {
            const m = (u = s[s.length - 1]) == null ? void 0 : u.trim();
            if (!m || m === X.OPEN_BRACKET)
              break;
            const d = dn.get(m), _ = dn.get(f);
            if (d === void 0 || _ === void 0)
              break;
            if (_ >= d)
              n.push(s.pop());
            else
              break;
          }
          s.push(l);
        } else if (f === X.OPEN_BRACKET)
          s.push(l);
        else if (f === X.CLOSE_BRACKET)
          this._processSuffixExpressionCloseBracket(n, s, t, c);
        else {
          if (this._checkCloseBracket(t[c - 1]))
            return !1;
          n.push(l);
        }
      }
    }
    return o ? this._processSuffixExpressionRemain(n, s, e) : !1;
  }
  _processSuffixExpressionRemain(e, t, r) {
    const n = e.length, s = e[n - 1];
    for (; t.length > 0; ) {
      const o = t.pop();
      if (!(s instanceof ie) && (o === X.OPEN_BRACKET || o === X.CLOSE_BRACKET))
        return !1;
      e.push(o);
    }
    return r.setChildren(e), !0;
  }
  _processSuffixExpressionCloseBracket(e, t, r, n) {
    var s;
    if (this._checkOpenBracket(r[n - 1]) || this._checkOperator(r[n - 1]))
      return !1;
    for (; t.length > 0; ) {
      const o = (s = t[t.length - 1]) == null ? void 0 : s.trim();
      if (!o)
        break;
      if (o === X.OPEN_BRACKET) {
        t.pop();
        break;
      }
      e.push(t.pop());
    }
  }
  _checkCloseBracket(e) {
    return e === X.CLOSE_BRACKET || e instanceof ie;
  }
  _checkOpenBracket(e) {
    return e === X.OPEN_BRACKET;
  }
  _checkOperator(e) {
    return e == null || e instanceof ie ? !1 : Mt.has(e);
  }
  _deletePlusForPreNode(e) {
    if (e == null)
      return !0;
    if (!(e instanceof ie)) {
      const t = e.trim();
      if (Mt.has(t) || t === X.OPEN_BRACKET)
        return !0;
    }
    return !1;
  }
  _resetCurrentLexerNode() {
    this._currentLexerNode = new ie();
  }
  _resetSegment() {
    this._segment = "";
  }
  _openBracket(e = 0) {
    this._bracketState.push(e);
  }
  _closeBracket() {
    this._bracketState.pop();
  }
  _openSquareBracket() {
    this._squareBracketState += 1;
  }
  _closeSquareBracket() {
    this._squareBracketState -= 1;
  }
  _getCurrentBracket() {
    const e = this._bracketState;
    return e[e.length - 1];
  }
  _changeCurrentBracket(e) {
    const t = this._bracketState;
    t[t.length - 1] = e;
  }
  _openBraces() {
    this._bracesState += 1;
  }
  _closeBraces() {
    this._bracesState -= 1;
  }
  _openSingleQuotation() {
    this._singleQuotationState += 1;
  }
  _closeSingleQuotation() {
    this._singleQuotationState -= 1;
  }
  _openDoubleQuotation() {
    this._doubleQuotationState += 1;
  }
  _closeDoubleQuotation() {
    this._doubleQuotationState -= 1;
  }
  _openLambda() {
    this._lambdaState = !0;
  }
  _closeLambda() {
    this._lambdaState = !1;
  }
  _openColon(e) {
    this._upLevel = e, this._colonState = !0;
  }
  _closeColon() {
    this._upLevel = 0, this._colonState = !1;
  }
  _isTableBracket() {
    return this._tableBracketState;
  }
  _openTableBracket() {
    this._tableBracketState = !0;
  }
  _closeTableBracket() {
    this._tableBracketState = !1;
  }
  _formalErrorOccurred() {
    this._formulaErrorCount += 1;
  }
  _hasFormalError() {
    return this._formulaErrorCount > 0;
  }
  _getLastChildCurrentLexerNode() {
    const e = this._currentLexerNode.getChildren();
    if (e && e.length > 0) {
      const t = e[e.length - 1];
      if (t instanceof ie)
        return t;
    }
    return !1;
  }
  _getLastChildCurrent() {
    const e = this._currentLexerNode.getChildren();
    return e && e.length > 0 ? e[e.length - 1] : !1;
  }
  _setParentCurrentLexerNode() {
    const e = this._currentLexerNode.getParent();
    return e ? (this._currentLexerNode = e, !0) : !1;
  }
  _setAncestorCurrentLexerNode() {
    var r, n, s, o, u, c;
    const e = (r = this._currentLexerNode) == null ? void 0 : r.getParent();
    let t = !1;
    if (e && e.getToken() === Rr) {
      if ((n = e == null ? void 0 : e.getParent()) != null && n.getParent()) {
        const l = (o = (s = this._currentLexerNode.getParent()) == null ? void 0 : s.getParent()) == null ? void 0 : o.getParent();
        l && (this._currentLexerNode = l), t = !0;
      }
    } else if (e != null && e.getParent()) {
      const l = (u = this._currentLexerNode.getParent()) == null ? void 0 : u.getParent();
      l && (this._currentLexerNode = l), t = !0;
    }
    for (let l = 0; l < this._upLevel; l++) {
      const f = (c = this._currentLexerNode) == null ? void 0 : c.getParent();
      f && (this._currentLexerNode = f), this._currentLexerNode ? t = !0 : t = !1;
    }
    return t;
  }
  _segmentCount() {
    return this._segment.trim().length;
  }
  _pushSegment(e) {
    this._segment += e;
  }
  _pushNodeToChildren(e, t = !1) {
    let r = e;
    if (r !== "") {
      const n = this._currentLexerNode.getChildren();
      if (!(r instanceof ie) && this.isColonOpen()) {
        const s = new ie();
        s.setToken(r), s.setParent(this._currentLexerNode), r = s;
      }
      t ? n.unshift(r) : n.push(r);
    }
    this.isColonOpen() && (this._setAncestorCurrentLexerNode(), this._closeColon());
  }
  _setCurrentLexerNode(e, t = !1) {
    this._pushNodeToChildren(e, t), e.setParent(this._currentLexerNode), this._currentLexerNode = e;
  }
  _newAndPushCurrentLexerNode(e, t, r = !1) {
    const n = new ie();
    n.setToken(e), n.setIndex(t - e.length, t - 1), this._setCurrentLexerNode(n, r);
  }
  _getTopNode(e) {
    let t = e;
    for (; t != null && t.getParent(); )
      t = t.getParent();
    return t;
  }
  _removeLastChild() {
    this._currentLexerNode.getChildren().splice(-1);
  }
  /**
   * fix univer-pro/issues/2447
   * =1/3+
   * =+
   * =sum(A1+)
   */
  _formulaErrorLastTokenCheck(e, t) {
    const r = this._findPreviousToken(e, t) || "", n = e.length - 1 === t;
    if (!n && this._isOperatorToken(r) || n && tl(r))
      return !0;
    if (Rs.has(r)) {
      const s = this._findSecondLastNonSpaceToken(e, t);
      if (s == null || nl(s))
        return !0;
    }
    return !1;
  }
  _findPreviousToken(e, t) {
    let r = t;
    for (; r >= 0; ) {
      const n = e[r];
      if (n !== " ")
        return n;
      r--;
    }
  }
  _findSecondLastNonSpaceToken(e, t) {
    let r = t, n = 0;
    for (; r >= 0; ) {
      const s = e[r];
      if (s !== " " && (n++, n === 2))
        return s;
      r--;
    }
    return null;
  }
  _findNextToken(e, t) {
    let r = t;
    for (; r >= 0; ) {
      const n = e[r];
      if (n !== " ")
        return n;
      r++;
    }
  }
  _unexpectedEndingTokenExcludeOperator(e) {
    return (
      // OPERATOR_TOKEN_SET.has(prevString) ||
      e === X.OPEN_BRACKET || e === X.COMMA || e === Z.EQUALS || e === ""
    );
  }
  _unexpectedEndingToken(e) {
    return !!(this._isOperatorToken(e) || this._unexpectedEndingTokenExcludeOperator(e));
  }
  _isOperatorToken(e) {
    return !!Mt.has(e);
  }
  _getSequenceArray(e) {
    const t = [];
    return this._nodeMaker(e, t), t;
  }
  _resetTemp() {
    this._currentLexerNode = new ie(), this._upLevel = 0, this._segment = "", this._bracketState = [], this._bracesState = 0, this._singleQuotationState = 0, this._doubleQuotationState = 0, this._lambdaState = !1, this._colonState = !1, this._formulaErrorCount = 0;
  }
  _checkErrorState() {
    return !!(this._bracketState.length > 0 || this._bracesState > 0 || this._singleQuotationState > 0 || this._doubleQuotationState > 0 || this._hasFormalError());
  }
  _checkSimilarErrorToken(e, t, r) {
    let n = t;
    if (e !== nt.POUND)
      return !0;
    let s = r[++n];
    for (; s === " "; )
      s = r[++n];
    return !!Cn(s);
  }
  _checkIfErrorObject(e, t) {
    return !!this._findErrorObject(e, t);
  }
  _findErrorObject(e, t) {
    for (let r = 0; r < ii.length; r++) {
      const n = ii[r], s = t.slice(e, e + n).join("").toUpperCase();
      if (fr.has(s))
        return s;
    }
  }
  // NOTE@wzhudev: this method is over complex, need to refactor. Using recursive descend to parse the formula string
  // without a standalone lexer phase
  // eslint-disable-next-line max-lines-per-function, complexity
  _nodeMaker(e, t, r) {
    let n = e.replace(/\r\n$|\r|\n/g, " ");
    n.substring(0, 1) === Z.EQUALS && (n = n.substring(1));
    const s = n.split(""), o = s.length;
    this._resetTemp(), this._formulaErrorLastTokenCheck(s, o - 1) && this._formalErrorOccurred();
    let u = 0;
    for (; u < o; ) {
      const c = s[u];
      if (r === u)
        return [this._currentLexerNode, c];
      if (c === nt.POUND && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isBracesClose() && this.isSquareBracketClose() && this._checkIfErrorObject(u, s)) {
        const l = this._findErrorObject(u, s);
        if (l == null)
          return h.VALUE;
        this._pushNodeToChildren(l);
        for (let f = 0; f < l.length; f++) {
          const m = s[u];
          this._pushSegment(m), this._addSequenceArray(t, m, u), u++;
        }
        this._resetSegment();
        continue;
      } else if (c === X.OPEN_BRACKET && this.isSingleQuotationClose() && this.isDoubleQuotationClose())
        if (this._segmentCount() > 0 || this.isLambdaOpen()) {
          this.isLambdaClose() && (this._newAndPushCurrentLexerNode(this._segment, u), this._resetSegment()), this._openBracket(
            1
            /* FUNCTION */
          ), this._closeLambda();
          const l = s[u + 1];
          if (l && l === X.CLOSE_BRACKET) {
            if (!this._setParentCurrentLexerNode() && u !== o - 1)
              return h.VALUE;
            this._addSequenceArray(t, c, u), u++, this._addSequenceArray(t, l, u), u++, this._closeBracket();
            continue;
          } else l && this._newAndPushCurrentLexerNode(At, u);
        } else
          this._pushNodeToChildren(c), this._openBracket(
            0
            /* NORMAL */
          ), this._resetSegment();
      else if (c === X.CLOSE_BRACKET && this.isSingleQuotationClose() && this.isDoubleQuotationClose()) {
        this._formulaErrorLastTokenCheck(s, u - 1) && this._formalErrorOccurred(), this._pushNodeToChildren(this._segment), this._resetSegment();
        const l = this._getCurrentBracket();
        if (l === 0)
          this._pushNodeToChildren(c);
        else if (l === 1) {
          const f = s[u + 1];
          if (f && f === X.OPEN_BRACKET) {
            if (!this._setParentCurrentLexerNode() && u !== o - 1)
              return h.VALUE;
            this._newAndPushCurrentLexerNode(Rr, u, !0), this._openLambda();
          } else if (!this._setAncestorCurrentLexerNode() && u !== o - 1)
            return h.VALUE;
        } else
          return h.VALUE;
        this._closeBracket();
      } else if (c === X.OPEN_BRACES && this.isSingleQuotationClose() && this.isDoubleQuotationClose()) {
        if (this._pushSegment(c), this._openBraces(), !this._formulaSpellCheck())
          return h.VALUE;
      } else if (c === X.CLOSE_BRACES && this.isSingleQuotationClose() && this.isDoubleQuotationClose())
        this._pushSegment(c), this._pushNodeToChildren(this._segment), this._resetSegment(), this._closeBraces();
      else if (c === X.OPEN_SQUARE_BRACKET && this.isSingleQuotationClose() && this.isDoubleQuotationClose())
        this._segment.length > 0 && this._openTableBracket(), this._pushSegment(c), this._openSquareBracket();
      else if (c === X.CLOSE_SQUARE_BRACKET && this.isSingleQuotationClose() && this.isDoubleQuotationClose())
        this._closeSquareBracket(), this.isSquareBracketClose() ? (this._pushSegment(c), this._isTableBracket() && (this._pushNodeToChildren(this._segment), this._resetSegment()), this._closeTableBracket()) : this._pushSegment(c);
      else if (c === X.DOUBLE_QUOTATION && this.isSingleQuotationClose() && this.isSquareBracketClose()) {
        if (this.isDoubleQuotationClose())
          this._openDoubleQuotation();
        else {
          const l = s[u + 1];
          l && l === X.DOUBLE_QUOTATION ? u++ : this._closeDoubleQuotation();
        }
        this._pushSegment(c);
      } else if (c === X.SINGLE_QUOTATION && this.isDoubleQuotationClose()) {
        if (this.isSingleQuotationClose())
          this._openSingleQuotation(), this._segmentCount() === 0 && this._resetSegment();
        else {
          const l = s[u + 1];
          if (l && l === X.SINGLE_QUOTATION) {
            this._pushSegment(c), this._addSequenceArray(t, c, u), u++, this._pushSegment(l), this._addSequenceArray(t, l, u), u++;
            continue;
          } else
            this._closeSingleQuotation();
        }
        this._pushSegment(c);
      } else if (c === X.COMMA && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isBracesClose() && this.isSquareBracketClose()) {
        this._formulaErrorLastTokenCheck(s, u - 1) && this._formalErrorOccurred();
        const l = this._getCurrentBracket();
        if (l === 1 || l == null) {
          if (this._pushNodeToChildren(this._segment), this._resetSegment(), !this._setParentCurrentLexerNode() && u !== o - 1 && l != null)
            return h.VALUE;
          this._newAndPushCurrentLexerNode(At, u);
        } else {
          const f = new ie();
          f.setToken(Vl);
          const m = new ie();
          m.setToken(At), m.changeToParent(f);
          const d = this._currentLexerNode.getParent();
          if (d && d.getToken() === X.COLON) {
            const _ = d.getParent();
            if (!_)
              return h.VALUE;
            d.changeToParent(m), _.setChildren([]), f.changeToParent(_);
          } else
            return h.VALUE;
          this._changeCurrentBracket(
            1
            /* FUNCTION */
          ), this._pushNodeToChildren(this._segment), this._resetSegment(), this._currentLexerNode = f, this._newAndPushCurrentLexerNode(At, u);
        }
      } else if (c === X.COLON && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isBracesClose() && this.isSquareBracketClose()) {
        const l = new ie();
        l.setToken(c);
        const f = new ie();
        f.setToken(At), f.setParent(l);
        const m = new ie();
        m.setToken(At), m.setParent(l), l.getChildren().push(f, m);
        let d = l, _ = 0;
        if (this._segmentCount() > 0) {
          let C, E, R = 0;
          const b = this._segment.trim(), p = b[0], V = b[1];
          if (p === we.MINUS && (C = new ie(), C.setToken(we.MINUS), R++), (p === we.AT || V === we.AT) && (E = new ie(), E.setToken(we.AT), C && (C.addChildren(E), E.setParent(C)), R++), R > 0 && (this._segment = b.slice(R)), _ = R, E)
            if (E.addChildren(l), l.setParent(E), E.getParent()) {
              const M = E.getParent();
              M && (d = M);
            } else
              d = E;
          else C && (d = C, C.addChildren(l), l.setParent(C));
          const S = new ie();
          S.setToken(this._segment), S.setParent(f), f.getChildren().push(S), this._resetSegment();
        } else {
          const C = this._getLastChildCurrentLexerNode();
          C && C.changeToParent(f);
        }
        this._setCurrentLexerNode(d), this._currentLexerNode = m, this._openColon(_);
      } else if (Rs.has(c) && this._checkSimilarErrorToken(c, u, s) && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isSquareBracketClose() && this.isBracesClose()) {
        this._pushNodeToChildren(this._segment);
        const l = new ie();
        l.setToken(c);
        const f = this._getLastChildCurrent();
        f instanceof ie ? f.changeToParent(l) : f !== !1 && (l.getChildren().push(f), this._removeLastChild()), this._pushNodeToChildren(l), l.setParent(this._currentLexerNode), this._resetSegment();
      } else if (Mt.has(c) && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isSquareBracketClose() && this.isBracesClose()) {
        let l = this._segment.trim();
        if (c === Z.MINUS && l === "") {
          const f = this._findPreviousToken(s, u - 1) || "", m = this._findNextToken(s, u + 1) || "";
          if (this._unexpectedEndingTokenExcludeOperator(f) && this._isOperatorToken(m)) {
            this._pushNodeToChildren("0"), this._pushNodeToChildren(Z.MINUS), this._addSequenceArray(t, c, u), this._resetSegment(), u++;
            continue;
          } else if (this._unexpectedEndingToken(f))
            if (m === Z.PLUS) {
              this._pushSegment(Z.MINUS), this._addSequenceArray(t, c, u), this._addSequenceArray(t, Z.PLUS, u + 1), u += 2;
              continue;
            } else {
              this._pushSegment(Z.MINUS), this._addSequenceArray(t, c, u), u++;
              continue;
            }
        } else if (this._segment.length > 0 && this._isScientificNotation(s, u, c)) {
          this._pushSegment(c), this._addSequenceArray(t, c, u), u++;
          continue;
        } else this._segment.length > 0 && l === "" ? l = this._segment : (this._pushNodeToChildren(this._segment), l = "");
        if (c === Z.LESS_THAN || c === Z.GREATER_THAN) {
          const f = s[u + 1];
          if (f && Mt.has(c + f)) {
            this._pushNodeToChildren(l + c + f), this._resetSegment(), this._addSequenceArray(t, c, u), u++, this._addSequenceArray(t, f, u), u++;
            continue;
          } else
            this._pushNodeToChildren(l + c);
        } else
          this._pushNodeToChildren(l + c);
        this._resetSegment();
      } else
        (this._segment !== "" || c !== " ") && this._pushSegment(c);
      this._addSequenceArray(t, c, u), u++;
    }
    if (this._pushNodeToChildren(this._segment), this._checkErrorState())
      return h.VALUE;
  }
  _isScientificNotation(e, t, r) {
    const n = e[t - 2];
    if (n && Number.isNaN(Number(n)) || !(r === Z.MINUS || r === Z.PLUS))
      return !1;
    const s = e[t + 1];
    if (s && Number.isNaN(Number(s)))
      return !1;
    const o = e[t - 1];
    return o && o.toUpperCase() === "E";
  }
  _addSequenceArray(e, t, r) {
    e == null || e.push({
      segment: this._segment,
      currentString: t,
      cur: r,
      currentLexerNode: this._currentLexerNode
    });
  }
  getNewFormulaWithPrefix(e, t) {
    return null;
  }
}
function Hl(a, i, e, t, r, n, s) {
  const o = (s == null ? void 0 : s.f) || "", u = (s == null ? void 0 : s.si) || "", c = Et(o), l = wt(u), f = a.getValue(r, n), m = (f == null ? void 0 : f.f) || "", d = (f == null ? void 0 : f.si) || "";
  function _() {
    var C;
    if (Et(m) && wt(d)) {
      const E = (C = e == null ? void 0 : e[d]) == null ? void 0 : C.f;
      E ? t.set(d, E) : t.set(d, m);
    }
  }
  c && l ? (d !== u && _(), a.setValue(r, n, {
    f: o,
    si: u
  }), e[u] = { f: o, r, c: n }, i.setValue(r, n, {
    f: o,
    si: u
  })) : c && !l ? (m !== o && _(), a.setValue(r, n, {
    f: o
  }), i.setValue(r, n, {
    f: o
  })) : !c && l ? (d !== u && _(), a.setValue(r, n, {
    f: "",
    si: u
  })) : !c && !l && a.getValue(r, n) && (_(), a.realDeleteValue(r, n), i.setValue(r, n, null));
}
function Gl(a, i, e, t) {
  const r = a == null ? void 0 : a.getValue(e, t);
  if (r == null)
    return !0;
  const n = [];
  a.forValue((l, f, m) => {
    l === e && f === t || ai.intersects(m, r) && n.push(m);
  });
  const { startRow: s, startColumn: o, endRow: u, endColumn: c } = r;
  for (let l = s; l <= u; l++)
    for (let f = o; f <= c; f++) {
      let m = !1;
      const d = wc(l, f);
      n.some((_) => ai.contains(_, d) ? (m = !0, !0) : !1), m || i.realDeleteValue(l, f);
    }
}
var Wl = Object.getOwnPropertyDescriptor, Ql = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Wl(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, pi = (a, i) => (e, t) => i(e, t, a);
let yr = class extends Se {
  constructor(i, e) {
    super();
    A(this, "_arrayFormulaRange", {});
    A(this, "_arrayFormulaCellData", {});
    A(this, "_unitImageFormulaData", {});
    this._univerInstanceService = i, this._lexerTreeBuilder = e;
  }
  dispose() {
    super.dispose(), this._arrayFormulaRange = {}, this._arrayFormulaCellData = {}, this._unitImageFormulaData = {};
  }
  clearPreviousArrayFormulaCellData(i) {
    Object.keys(i).forEach((e) => {
      const t = i[e];
      if (t == null)
        return !0;
      Object.keys(t).forEach((r) => {
        var c, l, f, m;
        const n = t[r], s = (l = (c = this._arrayFormulaRange) == null ? void 0 : c[e]) == null ? void 0 : l[r];
        if (s == null)
          return !0;
        const o = new de(s);
        let u = new de();
        ((f = this._arrayFormulaCellData[e]) == null ? void 0 : f[r]) != null && (u = new de(
          (m = this._arrayFormulaCellData[e]) == null ? void 0 : m[r]
        )), n.forValue((d, _) => {
          const C = o.getValue(d, _);
          if (C == null)
            return !0;
          const { startRow: E, startColumn: R, endRow: b, endColumn: p } = C;
          for (let V = E; V <= b; V++)
            for (let S = R; S <= p; S++)
              u.setValue(V, S, null);
          o.realDeleteValue(d, _);
        }), this._arrayFormulaCellData[e] && (this._arrayFormulaCellData[e][r] = u.getData());
      });
    });
  }
  mergeArrayFormulaCellData(i) {
    Object.keys(i).forEach((e) => {
      const t = i[e];
      if (t == null)
        return !0;
      this._arrayFormulaRange[e] == null && (this._arrayFormulaRange[e] = {}), this._arrayFormulaCellData[e] == null && (this._arrayFormulaCellData[e] = {}), Object.keys(t).forEach((r) => {
        var u, c;
        const n = t[r], s = new de((u = this._arrayFormulaRange[e]) == null ? void 0 : u[r]), o = new de((c = this._arrayFormulaCellData[e]) == null ? void 0 : c[r]);
        n.forValue((l, f) => {
          const m = s == null ? void 0 : s.getValue(l, f);
          if (m == null)
            return !0;
          const { startRow: d, startColumn: _, endRow: C, endColumn: E } = m;
          for (let R = d; R <= C; R++)
            for (let b = _; b <= E; b++)
              o.setValue(R, b, null);
        }), n.forValue((l, f, m) => {
          o.setValue(l, f, m);
        }), this._arrayFormulaCellData[e] && (this._arrayFormulaCellData[e][r] = o.getData());
      });
    });
  }
  getFormulaData() {
    const i = {}, e = this._univerInstanceService.getAllUnitsForType(Cr.UNIVER_SHEET);
    return e.length === 0 || e.forEach((t) => {
      const r = t.getUnitId();
      i[r] = {}, t.getSheets().forEach((s) => {
        const o = s.getCellMatrix(), u = s.getSheetId();
        Ni(i, r, u, o);
      });
    }), i;
  }
  getSheetFormulaData(i, e) {
    const t = {}, r = this._univerInstanceService.getUnit(i);
    if (r == null)
      return {};
    t[i] = {};
    const n = r.getSheetBySheetId(e);
    if (n == null)
      return {};
    const s = n.getCellMatrix();
    return Ni(t, i, e, s), t[i][e];
  }
  getArrayFormulaRange() {
    return this._arrayFormulaRange;
  }
  setArrayFormulaRange(i) {
    this._arrayFormulaRange = i;
  }
  getArrayFormulaCellData() {
    return this._arrayFormulaCellData;
  }
  setArrayFormulaCellData(i) {
    this._arrayFormulaCellData = i;
  }
  getUnitImageFormulaData() {
    return this._unitImageFormulaData;
  }
  setUnitImageFormulaData(i) {
    this._unitImageFormulaData = i;
  }
  mergeArrayFormulaRange(i) {
    Object.keys(i).forEach((e) => {
      const t = i[e];
      if (t == null)
        return !0;
      this._arrayFormulaRange[e] || (this._arrayFormulaRange[e] = {}), Object.keys(t).forEach((r) => {
        var o;
        const n = new de(t[r]), s = new de((o = this._arrayFormulaRange[e]) == null ? void 0 : o[r]);
        n.forValue((u, c, l) => {
          s.setValue(u, c, l);
        }), this._arrayFormulaRange[e] && (this._arrayFormulaRange[e][r] = s.getData());
      });
    });
  }
  mergeUnitImageFormulaData(i) {
    const e = Object.keys(i);
    for (let t = 0; t < e.length; t++) {
      const r = e[t], n = i[r];
      if (!n) continue;
      this._unitImageFormulaData[r] || (this._unitImageFormulaData[r] = {});
      const s = Object.keys(n);
      for (let o = 0; o < s.length; o++) {
        const u = s[o], c = n[u];
        c && (this._unitImageFormulaData[r][u] || (this._unitImageFormulaData[r][u] = new de()), c.forValue((l, f, m) => {
          this._unitImageFormulaData[r][u].setValue(l, f, m);
        }));
      }
    }
  }
  deleteArrayFormulaRange(i, e, t, r) {
    var o;
    const n = (o = this._arrayFormulaRange[i]) == null ? void 0 : o[e];
    if (n == null)
      return;
    const s = new de(n);
    s.getValue(t, r) && (s.realDeleteValue(t, r), this._arrayFormulaRange[i] && (this._arrayFormulaRange[i][e] = s.getData()));
  }
  getCalculateData() {
    const i = this._univerInstanceService.getAllUnitsForType(Cr.UNIVER_SHEET), e = {}, t = {}, r = {};
    for (const n of i) {
      const s = n.getUnitId(), o = n.getSheets(), u = {}, c = {};
      for (const l of o) {
        const f = l.getSheetId(), m = l.getConfig();
        u[f] = {
          cellData: new de(m.cellData),
          rowCount: m.rowCount,
          columnCount: m.columnCount,
          rowData: m.rowData,
          columnData: m.columnData,
          defaultRowHeight: m.defaultRowHeight,
          defaultColumnWidth: m.defaultColumnWidth
        }, c[l.getName()] = l.getSheetId();
      }
      e[s] = u, t[s] = n.getStyles(), r[s] = c;
    }
    return {
      allUnitData: e,
      unitStylesData: t,
      unitSheetNameMap: r
    };
  }
  /**
   * Get the hidden rows that are filtered or manually hidden.
   *
   * For formulas that are sensitive to hidden rows.
   */
  getHiddenRowsFiltered() {
    const i = this._univerInstanceService.getAllUnitsForType(Cr.UNIVER_SHEET), e = {};
    for (const t of i) {
      const r = t.getUnitId(), n = t.getSheets();
      e[r] = {};
      for (const s of n) {
        const o = s.getSheetId();
        e[r][o] = {};
        const u = 0, c = s.getRowCount() - 1, l = {};
        for (let f = u; f <= c; f++)
          s.getRowVisible(f) || (l[f] = {
            hd: co.TRUE
          });
        e[r][o] = l;
      }
    }
    return e;
  }
  updateFormulaData(i, e, t) {
    const r = new de(t), n = this._getSheetFormulaIdMap(i, e), s = /* @__PURE__ */ new Map(), o = this.getFormulaData();
    o[i] == null && (o[i] = {});
    const u = o[i];
    u[e] == null && (u[e] = {});
    const c = new de(u[e] || {}), l = new de();
    return r.forValue((f, m, d) => {
      Hl(c, l, n, s, f, m, d);
    }), c.forValue((f, m, d) => {
      const _ = (d == null ? void 0 : d.f) || "", C = (d == null ? void 0 : d.si) || "";
      if (wt(C)) {
        const E = n == null ? void 0 : n[C], R = s.get(C);
        if (E && !Et(_)) {
          const b = E.f, p = m - E.c, V = f - E.r;
          c.setValue(f, m, { f: b, si: C, x: p, y: V }), l.setValue(f, m, { f: b, si: C, x: p, y: V });
        } else if (typeof R == "string") {
          const b = (d == null ? void 0 : d.x) || 0, p = (d == null ? void 0 : d.y) || 0, V = this._lexerTreeBuilder.moveFormulaRefOffset(R, b, p);
          s.set(C, { r: f, c: m, f: V }), c.setValue(f, m, { f: V, si: C }), l.setValue(f, m, { f: V, si: C });
        } else if (typeof R == "object") {
          const b = m - R.c, p = f - R.r;
          c.setValue(f, m, { f: R.f, si: C, x: b, y: p }), l.setValue(f, m, { f: R.f, si: C, x: b, y: p });
        }
      }
    }), l.getMatrix();
  }
  updateArrayFormulaRange(i, e, t) {
    var o;
    const r = (o = this._arrayFormulaRange[i]) == null ? void 0 : o[e];
    if (!r) return;
    const n = new de(r);
    new de(t).forValue((u, c, l) => {
      n.realDeleteValue(u, c);
    });
  }
  updateArrayFormulaCellData(i, e, t) {
    var c, l;
    const r = (c = this._arrayFormulaRange[i]) == null ? void 0 : c[e];
    if (!r) return;
    const n = new de(r), s = (l = this._arrayFormulaCellData[i]) == null ? void 0 : l[e];
    if (!s) return;
    const o = new de(s);
    new de(t).forValue((f, m, d) => {
      Gl(n, o, f, m);
    });
  }
  updateImageFormulaData(i, e, t) {
    var s;
    const r = (s = this._unitImageFormulaData[i]) == null ? void 0 : s[e];
    if (!r)
      return;
    new de(t).forValue((o, u) => {
      r.realDeleteValue(o, u);
    });
  }
  getFormulaStringByCell(i, e, t, r) {
    const n = this._univerInstanceService.getUnit(r);
    if (n == null)
      return null;
    const s = n.getSheetBySheetId(t);
    if (s == null)
      return null;
    const o = s.getCellMatrix(), u = o.getValue(i, e);
    if (u == null)
      return null;
    const { f: c, si: l } = u;
    if (Et(c))
      return c;
    if (wt(l)) {
      let f = null;
      return o.forValue((m, d, _) => {
        if (_ == null)
          return !0;
        const { f: C, si: E } = _;
        if (Et(C) && l === E)
          return f = this._lexerTreeBuilder.moveFormulaRefOffset(
            C,
            e - d,
            i - m
          ), !1;
      }), f;
    }
    return null;
  }
  /**
   * Function to get all formula ranges
   * @returns
   */
  getFormulaDirtyRanges() {
    const i = this.getFormulaData(), e = [];
    for (const t in i) {
      const r = i[t];
      if (!r) continue;
      const n = this._univerInstanceService.getUnit(t);
      if (n)
        for (const s in r) {
          const o = r[s];
          if (!o) continue;
          const u = n.getSheetBySheetId(s);
          if (!u) continue;
          const c = {};
          for (const l of Object.keys(o)) {
            const f = Number(l);
            for (const m in o[f]) {
              const d = Number(m), _ = u.getCellRaw(f, d), C = Et(_ == null ? void 0 : _.f) || wt(_ == null ? void 0 : _.si), E = (_ == null ? void 0 : _.v) === void 0;
              if (!(C && E)) continue;
              c[d] || (c[d] = []);
              const R = c[d].slice(-1)[0];
              R && R.endRow === f - 1 ? R.endRow = f : c[d].push({ startRow: f, endRow: f });
            }
          }
          for (const l in c) {
            const f = c[l];
            for (let m = 0; m < f.length; m++) {
              const d = f[m];
              e.push({
                unitId: t,
                sheetId: s,
                range: {
                  rangeType: rt.NORMAL,
                  startRow: d.startRow,
                  endRow: d.endRow,
                  // Use endRow as the inclusive end row
                  startColumn: Number(l),
                  endColumn: Number(l)
                }
              });
            }
          }
        }
    }
    return e;
  }
  _getSheetFormulaIdMap(i, e) {
    const t = {}, r = this._univerInstanceService.getUnit(i);
    if (r == null)
      return t;
    const n = r.getSheetBySheetId(e);
    return n == null || n.getCellMatrix().forValue((o, u, c) => {
      if (c == null)
        return !0;
      const { f: l, si: f } = c;
      Et(l) && wt(f) && (t[f] = { f: l, r: o, c: u });
    }), t;
  }
};
yr = Ql([
  pi(0, Jn),
  pi(1, ye(Mn))
], yr);
function Ni(a, i, e, t) {
  a[i] || (a[i] = {}), a[i][e] || (a[i][e] = {});
  const r = /* @__PURE__ */ new Map(), n = new de(a[i][e]);
  t.forValue((o, u, c) => {
    const l = (c == null ? void 0 : c.f) || "", f = (c == null ? void 0 : c.si) || "", m = Et(l), d = wt(f);
    m && d ? (n.setValue(o, u, {
      f: l,
      si: f
    }), r.set(f, { f: l, r: o, c: u })) : m && !d ? n.setValue(o, u, {
      f: l
    }) : !m && d && n.setValue(o, u, {
      f: "",
      si: f
    });
  }), n.forValue((o, u, c) => {
    const l = (c == null ? void 0 : c.f) || "", f = (c == null ? void 0 : c.si) || "";
    if (wt(f) && !Et(l)) {
      const m = r.get(f);
      if (m) {
        const d = m.f, _ = u - m.c, C = o - m.r;
        n.setValue(o, u, { f: d, si: f, x: _, y: C });
      } else
        n.realDeleteValue(o, u);
    }
  });
  const s = n.getMatrix();
  return {
    [i]: {
      [e]: s
    }
  };
}
const ql = class $s {
  /**
   * Accept two comparable values and creates new instance of interval
   * Predicate Interval.comparable_less(low, high) supposed to return true on these values
   * @param low
   * @param high
   */
  constructor(i, e) {
    this.low = i, this.high = e;
  }
  /**
   * Clone interval
   * @returns {Interval}
   */
  clone() {
    return new $s(this.low, this.high);
  }
  /**
   * Propery max returns clone of this interval
   * @returns {Interval}
   */
  get max() {
    return this.clone();
  }
  /**
   * Predicate returns true is this interval less than other interval
   * @param other_interval
   * @returns {boolean}
   */
  less_than(i) {
    return this.low < i.low || this.low === i.low && this.high < i.high;
  }
  /**
   * Predicate returns true is this interval equals to other interval
   * @param other_interval
   * @returns {boolean}
   */
  equal_to(i) {
    return this.low === i.low && this.high === i.high;
  }
  /**
   * Predicate returns true if this interval intersects other interval
   * @param other_interval
   * @returns {boolean}
   */
  intersect(i) {
    return !this.not_intersect(i);
  }
  /**
   * Predicate returns true if this interval does not intersect other interval
   * @param other_interval
   * @returns {boolean}
   */
  not_intersect(i) {
    return this.high < i.low || i.high < this.low;
  }
  /**
   * Returns new interval merged with other interval
   * @param {Interval} other_interval - Other interval to merge with
   * @returns {Interval}
   */
  merge(i) {
    return new $s(
      this.low === void 0 ? i.low : this.low < i.low ? this.low : i.low,
      this.high === void 0 ? i.high : this.high > i.high ? this.high : i.high
    );
  }
  /**
   * Returns how key should return
   */
  output() {
    return [this.low, this.high];
  }
  /**
   * Function returns maximum between two comparable values
   * @param interval1
   * @param interval2
   * @returns {Interval}
   */
  static comparable_max(i, e) {
    return i.merge(e);
  }
  /**
   * Predicate returns true if first value less than second value
   * @param val1
   * @param val2
   * @returns {boolean}
   */
  static comparable_less_than(i, e) {
    return i < e;
  }
}, ve = 0, Re = 1;
class Kt {
  constructor(i = void 0, e = void 0, t = null, r = null, n = null, s = Re) {
    if (this.left = t, this.right = r, this.parent = n, this.color = s, this.item = { key: i, value: e }, i && i instanceof Array && i.length === 2 && !Number.isNaN(i[0]) && !Number.isNaN(i[1])) {
      let [o, u] = i;
      o > u && ([o, u] = [u, o]), this.item.key = new ql(o, u);
    }
    this.max = this.item.key ? this.item.key.max : void 0;
  }
  isNil() {
    return this.item.key === void 0 && this.item.value === void 0 && this.left === null && this.right === null && this.color === Re;
  }
  _value_less_than(i) {
    return this.item.value && i.item.value && this.item.value.less_than ? this.item.value.less_than(i.item.value) : this.item.value < i.item.value;
  }
  less_than(i) {
    return this.item.value === this.item.key && i.item.value === i.item.key ? this.item.key.less_than(i.item.key) : this.item.key.less_than(i.item.key) || this.item.key.equal_to(i.item.key) && this._value_less_than(i);
  }
  _value_equal(i) {
    return this.item.value && i.item.value && this.item.value.equal_to ? this.item.value.equal_to(i.item.value) : this.item.value === i.item.value;
  }
  equal_to(i) {
    return this.item.value === this.item.key && i.item.value === i.item.key ? this.item.key.equal_to(i.item.key) : this.item.key.equal_to(i.item.key) && this._value_equal(i);
  }
  intersect(i) {
    return this.item.key.intersect(i.item.key);
  }
  copy_data(i) {
    this.item.key = i.item.key, this.item.value = i.item.value;
  }
  update_max() {
    if (this.max = this.item.key ? this.item.key.max : void 0, this.right && this.right.max) {
      const i = this.item.key.constructor.comparable_max;
      this.max = i(this.max, this.right.max);
    }
    if (this.left && this.left.max) {
      const i = this.item.key.constructor.comparable_max;
      this.max = i(this.max, this.left.max);
    }
  }
  // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low
  not_intersect_left_subtree(i) {
    const e = this.item.key.constructor.comparable_less_than;
    let t = this.left.max.high !== void 0 ? this.left.max.high : this.left.max;
    return e(t, i.item.key.low);
  }
  // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low
  not_intersect_right_subtree(i) {
    const e = this.item.key.constructor.comparable_less_than;
    let t = this.right.max.low !== void 0 ? this.right.max.low : this.right.item.key.low;
    return e(i.item.key.high, t);
  }
}
class ya {
  /**
   * Construct new empty instance of IntervalTree
   */
  constructor() {
    this.root = null, this.nil_node = new Kt();
  }
  /**
   * Returns number of items stored in the interval tree
   * @returns {number}
   */
  get size() {
    let i = 0;
    return this.tree_walk(this.root, () => i++), i;
  }
  /**
   * Returns array of sorted keys in the ascending order
   * @returns {Array}
   */
  get keys() {
    let i = [];
    return this.tree_walk(this.root, (e) => i.push(
      e.item.key.output ? e.item.key.output() : e.item.key
    )), i;
  }
  /**
   * Return array of values in the ascending keys order
   * @returns {Array}
   */
  get values() {
    let i = [];
    return this.tree_walk(this.root, (e) => i.push(e.item.value)), i;
  }
  /**
   * Returns array of items (<key,value> pairs) in the ascended keys order
   * @returns {Array}
   */
  get items() {
    let i = [];
    return this.tree_walk(this.root, (e) => i.push({
      key: e.item.key.output ? e.item.key.output() : e.item.key,
      value: e.item.value
    })), i;
  }
  /**
   * Returns true if tree is empty
   * @returns {boolean}
   */
  isEmpty() {
    return this.root == null || this.root === this.nil_node;
  }
  /**
   * Clear tree
   */
  clear() {
    this.root = null;
  }
  /**
   * Insert new item into interval tree
   * @param {Interval} key - interval object or array of two numbers [low, high]
   * @param {any} value - value representing any object (optional)
   * @returns {Node} returns reference to inserted node as an object {key:interval, value: value}
   */
  insert(i, e = i) {
    if (i === void 0) return;
    let t = new Kt(i, e, this.nil_node, this.nil_node, null, ve);
    return this.tree_insert(t), this.recalc_max(t), t;
  }
  /**
   * Returns true if item {key,value} exist in the tree
   * @param {Interval} key - interval correspondent to keys stored in the tree
   * @param {any} value - value object to be checked
   * @returns {boolean} true if item {key, value} exist in the tree, false otherwise
   */
  exist(i, e = i) {
    let t = new Kt(i, e);
    return !!this.tree_search(this.root, t);
  }
  /**
   * Remove entry {key, value} from the tree
   * @param {Interval} key - interval correspondent to keys stored in the tree
   * @param {any} value - value object
   * @returns {boolean} true if item {key, value} deleted, false if not found
   */
  remove(i, e = i) {
    let t = new Kt(i, e), r = this.tree_search(this.root, t);
    return r && this.tree_delete(r), r;
  }
  /**
   * Returns array of entry values which keys intersect with given interval <br/>
   * If no values stored in the tree, returns array of keys which intersect given interval
   * @param {Interval} interval - search interval, or tuple [low, high]
   * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output
   * @returns {Array}
   */
  search(i, e = (t, r) => t === r ? r.output() : t) {
    let t = new Kt(i), r = [];
    return this.tree_search_interval(this.root, t, r), r.map((n) => e(n.item.value, n.item.key));
  }
  /**
   * Returns true if intersection between given and any interval stored in the tree found
   * @param {Interval} interval - search interval or tuple [low, high]
   * @returns {boolean}
   */
  intersect_any(i) {
    let e = new Kt(i);
    return this.tree_find_any_interval(this.root, e);
  }
  /**
   * Tree visitor. For each node implement a callback function. <br/>
   * Method calls a callback function with two parameters (key, value)
   * @param visitor(key,value) - function to be called for each tree item
   */
  forEach(i) {
    this.tree_walk(this.root, (e) => i(e.item.key, e.item.value));
  }
  /**
   * Value Mapper. Walk through every node and map node value to another value
   * @param callback(value,key) - function to be called for each tree item
   */
  map(i) {
    const e = new ya();
    return this.tree_walk(this.root, (t) => e.insert(t.item.key, i(t.item.value, t.item.key))), e;
  }
  /**
   * @param {Interval} interval - optional if the iterator is intended to start from the beginning
   * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output
   * @returns {Iterator}
   */
  *iterate(i, e = (t, r) => t === r ? r.output() : t) {
    let t;
    for (i ? t = this.tree_search_nearest_forward(this.root, new Kt(i)) : this.root && (t = this.local_minimum(this.root)); t; )
      yield e(t.item.value, t.item.key), t = this.tree_successor(t);
  }
  recalc_max(i) {
    let e = i;
    for (; e.parent != null; )
      e.parent.update_max(), e = e.parent;
  }
  tree_insert(i) {
    let e = this.root, t = null;
    if (this.root == null || this.root === this.nil_node)
      this.root = i;
    else {
      for (; e !== this.nil_node; )
        t = e, i.less_than(e) ? e = e.left : e = e.right;
      i.parent = t, i.less_than(t) ? t.left = i : t.right = i;
    }
    this.insert_fixup(i);
  }
  // After insertion insert_node may have red-colored parent, and this is a single possible violation
  // Go upwords to the root and re-color until violation will be resolved
  insert_fixup(i) {
    let e, t;
    for (e = i; e !== this.root && e.parent.color === ve; )
      e.parent === e.parent.parent.left ? (t = e.parent.parent.right, t.color === ve ? (e.parent.color = Re, t.color = Re, e.parent.parent.color = ve, e = e.parent.parent) : (e === e.parent.right && (e = e.parent, this.rotate_left(e)), e.parent.color = Re, e.parent.parent.color = ve, this.rotate_right(e.parent.parent))) : (t = e.parent.parent.left, t.color === ve ? (e.parent.color = Re, t.color = Re, e.parent.parent.color = ve, e = e.parent.parent) : (e === e.parent.left && (e = e.parent, this.rotate_right(e)), e.parent.color = Re, e.parent.parent.color = ve, this.rotate_left(e.parent.parent)));
    this.root.color = Re;
  }
  tree_delete(i) {
    let e, t;
    i.left === this.nil_node || i.right === this.nil_node ? e = i : e = this.tree_successor(i), e.left !== this.nil_node ? t = e.left : t = e.right, t.parent = e.parent, e === this.root ? this.root = t : (e === e.parent.left ? e.parent.left = t : e.parent.right = t, e.parent.update_max()), this.recalc_max(t), e !== i && (i.copy_data(e), i.update_max(), this.recalc_max(i)), /*fix_node != this.nil_node && */
    e.color === Re && this.delete_fixup(t);
  }
  delete_fixup(i) {
    let e = i, t;
    for (; e !== this.root && e.parent != null && e.color === Re; )
      e === e.parent.left ? (t = e.parent.right, t.color === ve && (t.color = Re, e.parent.color = ve, this.rotate_left(e.parent), t = e.parent.right), t.left.color === Re && t.right.color === Re ? (t.color = ve, e = e.parent) : (t.right.color === Re && (t.color = ve, t.left.color = Re, this.rotate_right(t), t = e.parent.right), t.color = e.parent.color, e.parent.color = Re, t.right.color = Re, this.rotate_left(e.parent), e = this.root)) : (t = e.parent.left, t.color === ve && (t.color = Re, e.parent.color = ve, this.rotate_right(e.parent), t = e.parent.left), t.left.color === Re && t.right.color === Re ? (t.color = ve, e = e.parent) : (t.left.color === Re && (t.color = ve, t.right.color = Re, this.rotate_left(t), t = e.parent.left), t.color = e.parent.color, e.parent.color = Re, t.left.color = Re, this.rotate_right(e.parent), e = this.root));
    e.color = Re;
  }
  tree_search(i, e) {
    if (!(i == null || i === this.nil_node))
      return e.equal_to(i) ? i : e.less_than(i) ? this.tree_search(i.left, e) : this.tree_search(i.right, e);
  }
  tree_search_nearest_forward(i, e) {
    let t, r = i;
    for (; r && r !== this.nil_node; )
      r.less_than(e) ? r.intersect(e) ? (t = r, r = r.left) : r = r.right : ((!t || r.less_than(t)) && (t = r), r = r.left);
    return t || null;
  }
  // Original search_interval method; container res support push() insertion
  // Search all intervals intersecting given one
  tree_search_interval(i, e, t) {
    i != null && i !== this.nil_node && (i.left !== this.nil_node && !i.not_intersect_left_subtree(e) && this.tree_search_interval(i.left, e, t), i.intersect(e) && t.push(i), i.right !== this.nil_node && !i.not_intersect_right_subtree(e) && this.tree_search_interval(i.right, e, t));
  }
  tree_find_any_interval(i, e) {
    let t = !1;
    return i != null && i !== this.nil_node && (i.left !== this.nil_node && !i.not_intersect_left_subtree(e) && (t = this.tree_find_any_interval(i.left, e)), t || (t = i.intersect(e)), !t && i.right !== this.nil_node && !i.not_intersect_right_subtree(e) && (t = this.tree_find_any_interval(i.right, e))), t;
  }
  local_minimum(i) {
    let e = i;
    for (; e.left != null && e.left !== this.nil_node; )
      e = e.left;
    return e;
  }
  // not in use
  local_maximum(i) {
    let e = i;
    for (; e.right != null && e.right !== this.nil_node; )
      e = e.right;
    return e;
  }
  tree_successor(i) {
    let e, t, r;
    if (i.right !== this.nil_node)
      e = this.local_minimum(i.right);
    else {
      for (t = i, r = i.parent; r != null && r.right === t; )
        t = r, r = r.parent;
      e = r;
    }
    return e;
  }
  //           |            right-rotate(T,y)       |
  //           y            ---------------.       x
  //          / \                                  / \
  //         x   c          left-rotate(T,x)      a   y
  //        / \             <---------------         / \
  //       a   b                                    b   c
  rotate_left(i) {
    let e = i.right;
    i.right = e.left, e.left !== this.nil_node && (e.left.parent = i), e.parent = i.parent, i === this.root ? this.root = e : i === i.parent.left ? i.parent.left = e : i.parent.right = e, e.left = i, i.parent = e, i != null && i !== this.nil_node && i.update_max(), e = i.parent, e != null && e !== this.nil_node && e.update_max();
  }
  rotate_right(i) {
    let e = i.left;
    i.left = e.right, e.right !== this.nil_node && (e.right.parent = i), e.parent = i.parent, i === this.root ? this.root = e : i === i.parent.left ? i.parent.left = e : i.parent.right = e, e.right = i, i.parent = e, i !== null && i !== this.nil_node && i.update_max(), e = i.parent, e != null && e !== this.nil_node && e.update_max();
  }
  tree_walk(i, e) {
    i != null && i !== this.nil_node && (this.tree_walk(i.left, e), e(i), this.tree_walk(i.right, e));
  }
  /* Return true if all red nodes have exactly two black child nodes */
  testRedBlackProperty() {
    let i = !0;
    return this.tree_walk(this.root, function(e) {
      e.color === ve && (e.left.color === Re && e.right.color === Re || (i = !1));
    }), i;
  }
  /* Throw error if not every path from root to bottom has same black height */
  testBlackHeightProperty(i) {
    let e = 0, t = 0, r = 0;
    if (i.color === Re && e++, i.left !== this.nil_node ? t = this.testBlackHeightProperty(i.left) : t = 1, i.right !== this.nil_node ? r = this.testBlackHeightProperty(i.right) : r = 1, t !== r)
      throw new Error("Red-black height property violated");
    return e += t, e;
  }
}
const Ys = Symbol("EMPTY_CELL");
class Xl {
  constructor() {
    /**
     * {
     *    unitId:{
     *       sheetId:{
     *          'columnIndex': {
     *              10:[1,3,4,5],
     *              5:[2,6,11,22]
     *          }
     *       }
     *    }
     * }
     */
    A(this, "_cache", /* @__PURE__ */ new Map());
    A(this, "_continueBuildingCache", /* @__PURE__ */ new Map());
  }
  set(i, e, t, r, n, s = !1) {
    if (!this.shouldContinueBuildingCache(i, e, t, n) && !s)
      return;
    let o = this._cache.get(i);
    o == null && (o = /* @__PURE__ */ new Map(), this._cache.set(i, o));
    let u = o.get(e);
    u == null && (u = /* @__PURE__ */ new Map(), o.set(e, u));
    let c = u.get(t);
    if (c == null && (c = /* @__PURE__ */ new Map(), u.set(t, c)), s) {
      for (const [m, d] of c)
        if (d.has(n)) {
          d.delete(n);
          break;
        }
    }
    let l = typeof r == "string" ? r.toLowerCase() : r;
    (l === "" || l === null) && (l = Ys);
    let f = c.get(l);
    f == null && (f = /* @__PURE__ */ new Set(), c.set(l, f)), f.add(n);
  }
  getCellValuePositions(i, e, t) {
    var r, n;
    return (n = (r = this._cache.get(i)) == null ? void 0 : r.get(e)) == null ? void 0 : n.get(t);
  }
  getCellPositions(i, e, t, r, n) {
    var u, c, l;
    let s = typeof r == "string" ? r.toLowerCase() : r;
    (s === "" || s === null) && (s = Ys);
    const o = (l = (c = (u = this._cache.get(i)) == null ? void 0 : u.get(e)) == null ? void 0 : c.get(t)) == null ? void 0 : l.get(s);
    return o && [...o].filter((f) => n.some(([m, d]) => f >= m && f <= d));
  }
  setContinueBuildingCache(i, e, t, r, n) {
    if (t === -1 || r === -1 || n === -1)
      return;
    let s = this._continueBuildingCache.get(i);
    s == null && (s = /* @__PURE__ */ new Map(), this._continueBuildingCache.set(i, s));
    let o = s.get(e);
    o == null && (o = /* @__PURE__ */ new Map(), s.set(e, o));
    let u = o.get(t);
    if (u == null) {
      u = new ya(), u.insert([r, n]), o.set(t, u);
      return;
    }
    this._handleNewInterval(u, r, n);
  }
  shouldContinueBuildingCache(i, e, t, r) {
    var o, u;
    if (t === -1 || r === -1)
      return !1;
    const n = (u = (o = this._continueBuildingCache.get(i)) == null ? void 0 : o.get(e)) == null ? void 0 : u.get(t);
    return n ? n.search([r, r]).length === 0 : !0;
  }
  canUseCache(i, e, t, r, n) {
    var f, m;
    const s = (m = (f = this._continueBuildingCache.get(i)) == null ? void 0 : f.get(e)) == null ? void 0 : m.get(t);
    if (t === -1 || r === -1 || n === -1 || !s)
      return {
        rowsInCache: [],
        rowsNotInCache: []
      };
    const o = s.search([r, n]);
    if (o.length === 0)
      return {
        rowsInCache: [],
        rowsNotInCache: []
      };
    o.sort((d, _) => d[0] - _[0]);
    const u = [], c = [];
    let l = r;
    for (let d = 0; d < o.length; d++) {
      const [_, C] = o[d];
      if (l >= _) {
        if (n <= C) {
          u.push([l, n]);
          break;
        }
        u.push([l, C]), l = C + 1, d === o.length - 1 && l <= n && c.push([l, n]);
      } else {
        if (n > C) {
          u.push([_, C]), c.push([l, _ - 1]), l = C + 1, d === o.length - 1 && l <= n && c.push([l, n]);
          continue;
        }
        u.push([_, n]), c.push([l, _ - 1]);
      }
    }
    return {
      rowsInCache: u,
      rowsNotInCache: c
    };
  }
  clear() {
    this._cache.clear(), this._continueBuildingCache.clear();
  }
  _handleNewInterval(i, e, t) {
    let r = i.search([e, t]);
    if (r.length === 0) {
      const o = [e - 1 < 0 ? 0 : e - 1, t + 1];
      if (r = i.search(o), r.length === 0) {
        i.insert([e, t]);
        return;
      }
    }
    let n = e, s = t;
    for (const o of r)
      n = Math.min(n, o[0]), s = Math.max(s, o[1]), i.remove(o);
    i.insert([n, s]);
  }
}
const Ke = new Xl(), pa = "engine-formula.config", xo = 1, kb = "CYCLE_REFERENCE_COUNT", Vi = {};
class Kl extends Se {
  constructor() {
    super(...arguments);
    A(this, "_getRowFilteredCallback");
  }
  register(e) {
    this._getRowFilteredCallback = e;
  }
  getRowFiltered(e, t, r) {
    var n;
    return this._getRowFilteredCallback && (n = this._getRowFilteredCallback(e, t, r)) != null ? n : !1;
  }
}
const jo = Je(
  "univer.formula.sheet-row-filtered.service"
);
var Zl = Object.getOwnPropertyDescriptor, zl = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Zl(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, an = (a, i) => (e, t) => i(e, t, a);
let Hs = class extends Se {
  constructor(i, e, t, r) {
    super();
    A(this, "_unitData", {});
    A(this, "_unitStylesData", {});
    A(this, "_arrayFormulaCellData", {});
    A(this, "_arrayFormulaRange", {});
    A(this, "_formulaData", {});
    A(this, "_sheetNameMap", {});
    A(this, "_forceCalculate", !1);
    A(this, "_clearDependencyTreeCache", {});
    A(this, "_dirtyRanges", []);
    A(this, "_dirtyNameMap", {});
    A(this, "_dirtyDefinedNameMap", {});
    A(this, "_dirtyUnitFeatureMap", {});
    A(this, "_dirtyUnitOtherFormulaMap", {});
    A(this, "_excludedCell");
    A(this, "_sheetIdToNameMap", {});
    A(this, "_executeUnitId", "");
    A(this, "_executeSubUnitId", "");
    this._univerInstanceService = i, this._localeService = e, this._formulaDataModel = t, this._sheetRowFilteredService = r;
  }
  dispose() {
    super.dispose(), this._unitData = {}, this._unitStylesData = {}, this._arrayFormulaCellData = {}, this._arrayFormulaRange = {}, this._formulaData = {}, this._sheetNameMap = {}, this._clearDependencyTreeCache = {}, this._dirtyRanges = [], this._dirtyNameMap = {}, this._dirtyDefinedNameMap = {}, this._dirtyUnitFeatureMap = {}, this._dirtyUnitOtherFormulaMap = {}, this._excludedCell = {}, this._sheetIdToNameMap = {};
  }
  getExecuteUnitId() {
    return this._executeUnitId;
  }
  getExecuteSubUnitId() {
    return this._executeSubUnitId;
  }
  setExecuteUnitId(i) {
    this._executeUnitId = i;
  }
  setExecuteSubUnitId(i) {
    this._executeSubUnitId = i;
  }
  getExcludedRange() {
    return this._excludedCell;
  }
  getUnitData() {
    return this._unitData;
  }
  getUnitStylesData() {
    return this._unitStylesData;
  }
  getFormulaData() {
    return this._formulaData;
  }
  getArrayFormulaCellData() {
    return this._arrayFormulaCellData;
  }
  getArrayFormulaRange() {
    return this._arrayFormulaRange;
  }
  getSheetNameMap() {
    return this._sheetNameMap;
  }
  isForceCalculate() {
    return this._forceCalculate;
  }
  getDirtyRanges() {
    return this._dirtyRanges;
  }
  getDirtyNameMap() {
    return this._dirtyNameMap;
  }
  getDirtyDefinedNameMap() {
    return this._dirtyDefinedNameMap;
  }
  getDirtyUnitFeatureMap() {
    return this._dirtyUnitFeatureMap;
  }
  getDirtyUnitOtherFormulaMap() {
    return this._dirtyUnitOtherFormulaMap;
  }
  getSheetName(i, e) {
    return this._sheetIdToNameMap[i] == null ? "" : this._sheetIdToNameMap[i][e] || "";
  }
  setSheetNameMap(i) {
    this._sheetIdToNameMap = i;
  }
  getClearDependencyTreeCache() {
    return this._clearDependencyTreeCache;
  }
  getLocale() {
    return this._localeService.getCurrentLocale();
  }
  getSheetsInfo() {
    const i = this._univerInstanceService.getCurrentUnitForType(Cr.UNIVER_SHEET), { id: e, sheetOrder: t } = i.getSnapshot();
    return {
      sheetOrder: t,
      sheetNameMap: this._sheetIdToNameMap[e]
    };
  }
  getSheetRowColumnCount(i, e) {
    const t = this._univerInstanceService.getUnit(i), r = t == null ? void 0 : t.getSheetBySheetId(e), n = r == null ? void 0 : r.getSnapshot();
    if (!n)
      return { rowCount: 0, columnCount: 0 };
    const { rowCount: s, columnCount: o } = n;
    return { rowCount: s, columnCount: o };
  }
  getFilteredOutRows(i, e, t, r) {
    const n = [];
    for (let s = t; s <= r; s++)
      this._sheetRowFilteredService.getRowFiltered(i, e, s) && n.push(s);
    return n;
  }
  load(i) {
    if (i.allUnitData && i.unitSheetNameMap && i.unitStylesData)
      this._unitData = i.allUnitData, this._unitStylesData = i.unitStylesData, this._sheetNameMap = i.unitSheetNameMap;
    else {
      const { allUnitData: e, unitSheetNameMap: t, unitStylesData: r } = this._loadSheetData();
      this._unitData = e, this._unitStylesData = r, this._sheetNameMap = t;
    }
    i.rowData && this._applyUnitRowData(i.rowData), this._formulaData = i.formulaData, this._arrayFormulaCellData = yl(i.arrayFormulaCellData), this._arrayFormulaRange = i.arrayFormulaRange, this._forceCalculate = i.forceCalculate, this._clearDependencyTreeCache = i.clearDependencyTreeCache || {}, this._dirtyRanges = i.dirtyRanges, this._dirtyNameMap = i.dirtyNameMap, this._dirtyDefinedNameMap = i.dirtyDefinedNameMap, this._dirtyUnitFeatureMap = i.dirtyUnitFeatureMap, this._dirtyUnitOtherFormulaMap = i.dirtyUnitOtherFormulaMap, this._excludedCell = i.excludedCell, this._mergeNameMap(this._sheetNameMap, this._dirtyNameMap);
  }
  getDirtyData() {
    return {
      forceCalculation: this._forceCalculate,
      dirtyRanges: this._dirtyRanges,
      dirtyNameMap: this._dirtyNameMap,
      dirtyDefinedNameMap: this._dirtyDefinedNameMap,
      dirtyUnitFeatureMap: this._dirtyUnitFeatureMap,
      dirtyUnitOtherFormulaMap: this._dirtyUnitOtherFormulaMap,
      clearDependencyTreeCache: this._clearDependencyTreeCache
    };
  }
  loadDirtyRangesAndExcludedCell(i, e) {
    this._dirtyRanges = i, this._excludedCell = e, this._dirtyNameMap = {};
  }
  registerUnitData(i) {
    this._unitData = i;
  }
  registerFormulaData(i) {
    this._formulaData = i;
  }
  registerSheetNameMap(i) {
    this._sheetNameMap = i;
  }
  // private _loadOtherFormulaData() {
  //     const unitAllDoc = this._univerInstanceService.getAllUniverDocsInstance();
  //     const unitAllSlide = this._univerInstanceService.getAllUniverSlidesInstance();
  //     const otherFormulaData: IOtherFormulaData = {};
  //     for (const documentDataModel of unitAllDoc) {
  //         const unitId = documentDataModel.getUnitId();
  //         if (otherFormulaData[unitId] == null) {
  //             otherFormulaData[unitId] = {};
  //         }
  //         if (otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID] == null) {
  //             otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID] = {};
  //         }
  //         const subComponent = otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID];
  //         const customRanges = documentDataModel.getBody()?.customRanges;
  //         if (customRanges == null) {
  //             continue;
  //         }
  //         for (const customRange of customRanges) {
  //             subComponent[customRange.rangeId] = {
  //                 f: customRange.endIndex.toString(),
  //             };
  //         }
  //     }
  //     for (const slide of unitAllSlide) {
  //         const unitId = slide.getUnitId();
  //         if (otherFormulaData[unitId] == null) {
  //             otherFormulaData[unitId] = {};
  //         }
  //         if (otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID] == null) {
  //             otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID] = {};
  //         }
  //         const pages = slide.getPages();
  //         if (pages == null) {
  //             continue;
  //         }
  //         const pageIds = Object.keys(pages);
  //         for (const pageId of pageIds) {
  //             const page = pages[pageId];
  //             const subComponent = otherFormulaData[unitId][pageId];
  //             const pageElements = page.pageElements;
  //             if (pageElements == null) {
  //                 continue;
  //             }
  //             const pageElementIds = Object.keys(pageElements);
  //             for (const pageElementId of pageElementIds) {
  //                 const pageElement = pageElements[pageElementId];
  //                 subComponent[pageElementId] = {
  //                     f: pageElement.title,
  //                 };
  //             }
  //         }
  //     }
  //     return otherFormulaData;
  // }
  _mergeNameMap(i, e) {
    Object.keys(e).forEach((t) => {
      e[t] && Object.keys(e[t]).forEach((r) => {
        i[t] == null && (i[t] = {}), i[t][e[t][r]] = r;
      });
    }), this._sheetIdToNameMap = {}, Object.keys(i).forEach((t) => {
      Object.keys(i[t]).forEach((r) => {
        this._sheetIdToNameMap[t] == null && (this._sheetIdToNameMap[t] = {}), this._sheetIdToNameMap[t][i[t][r]] = r;
      });
    });
  }
  _loadSheetData() {
    const i = this._univerInstanceService.getCurrentUnitForType(Cr.UNIVER_SHEET), e = i == null ? void 0 : i.getActiveSheet();
    return this._executeUnitId = i == null ? void 0 : i.getUnitId(), this._executeSubUnitId = e == null ? void 0 : e.getSheetId(), this._formulaDataModel.getCalculateData();
  }
  /**
   * There is no filter information in the worker, it must be passed in from the main thread after it is ready
   * @param rowData
   */
  _applyUnitRowData(i) {
    for (const e in i)
      if (i[e] != null)
        for (const t in i[e])
          i[e][t] != null && (this._unitData[e] == null && (this._unitData[e] = {}), this._unitData[e][t] == null && (this._unitData[e][t] = {
            cellData: new de({}),
            rowCount: 0,
            columnCount: 0,
            rowData: {},
            columnData: {}
          }), this._unitData[e][t].rowData = i[e][t]);
  }
};
Hs = zl([
  an(0, Jn),
  an(1, ye(Lc)),
  an(2, ye(yr)),
  an(3, ye(jo))
], Hs);
const Wt = Je(
  "univer.formula.current-data.service"
);
var Jl = Object.getOwnPropertyDescriptor, ef = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Jl(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, Ns = (a, i) => (e, t) => i(e, t, a);
let pr = class extends Se {
  constructor(a, i, e) {
    super(), this._definedNamesService = a, this._lexerTreeBuilder = i, this._formulaCurrentConfigService = e;
  }
  treeBuilder(a, i = !0) {
    const e = this._definedNamesService.getAllDefinedNames();
    return this._isDeepDefinedNameMapEmpty(e) ? this._lexerTreeBuilder.treeBuilder(a, i) : this._lexerTreeBuilder.treeBuilder(a, i, {
      unitId: this._formulaCurrentConfigService.getExecuteUnitId(),
      getValueByName: this._definedNamesService.getValueByName.bind(this._definedNamesService),
      getDirtyDefinedNameMap: this._formulaCurrentConfigService.getDirtyDefinedNameMap.bind(this._formulaCurrentConfigService),
      getSheetName: this._formulaCurrentConfigService.getSheetName.bind(this._formulaCurrentConfigService)
    });
  }
  _isDeepDefinedNameMapEmpty(a) {
    for (const i in a)
      if (Object.keys(a[i]).length > 0)
        return !1;
    return !0;
  }
};
pr = ef([
  Ns(0, Lr),
  Ns(1, ye(Mn)),
  Ns(2, Wt)
], pr);
function En(a) {
  if (a == null)
    return !0;
  const { v: i, f: e, si: t, p: r } = a;
  return !(!(i == null || typeof i == "string" && i.length === 0) || e != null && e.length > 0 || t != null && t.length > 0 || r != null);
}
class ts {
  constructor() {
    A(this, "pattern", "");
  }
  dispose() {
  }
  getPattern() {
    return this.pattern;
  }
  /**
   * Only used in NumberValueObject
   * @param pattern
   */
  setPattern(i) {
    this.pattern = i;
  }
  isError() {
    return !1;
  }
  isAsyncObject() {
    return !1;
  }
  isAsyncArrayObject() {
    return !1;
  }
  isReferenceObject() {
    return !1;
  }
  isArray() {
    return !1;
  }
  isValueObject() {
    return !1;
  }
  isEqualType(i) {
    return !1;
  }
}
function tf(a) {
  var i;
  if (a === null)
    return 0;
  if (a != null && a.p) {
    const e = a == null ? void 0 : a.p.body;
    if (e == null)
      return 0;
    const t = e.dataStream;
    return Pc.transform.getPlainText(t);
  }
  return (i = a == null ? void 0 : a.v) != null ? i : 0;
}
function $b(a, i = !1) {
  return !i && !(Et(a == null ? void 0 : a.f) || wt(a == null ? void 0 : a.si)) ? null : typeof (a == null ? void 0 : a.v) == "string" && fr.has(a.v) ? a.v : null;
}
function Uo(a, i, e, t, r) {
  var s;
  const n = Object.keys(r);
  for (const o of n) {
    const u = r[o], c = (s = u == null ? void 0 : u[t]) == null ? void 0 : s[e];
    if (c == null)
      continue;
    const l = c.getValue(a, i);
    if (l != null)
      return l;
  }
}
var zt = /* @__PURE__ */ ((a) => (a[a.MIN = 0] = "MIN", a[a.MAX = 1] = "MAX", a))(zt || {}), xe = /* @__PURE__ */ ((a) => (a[a.NORMAL = 0] = "NORMAL", a[a.MIN = 1] = "MIN", a[a.MAX = 2] = "MAX", a))(xe || {});
function Dn() {
  return Intl && Intl.Collator ? new Intl.Collator(void 0, { numeric: !1 }).compare : (a, i) => a.localeCompare(i);
}
function vo(a) {
  return a.indexOf("*") > -1 || a.indexOf("?") > -1;
}
function Vs(a, i) {
  const e = nf(i).replace(/~?[*?]/g, (r) => r.startsWith("~") ? `\\${r.substring(1)}` : r === "*" ? ".*" : r === "?" ? "." : r);
  return new RegExp(`^${e}$`).test(a);
}
function Oi(a) {
  return a.replace(/~?[*?]/g, (i) => i.startsWith("~") ? i.substring(1) : " ");
}
function rf(a, i, e) {
  let t = !1;
  switch (e) {
    case Y.EQUALS:
      t = Vs(a, i);
      break;
    case Y.NOT_EQUAL:
      t = !Vs(a, i);
      break;
    case Y.GREATER_THAN:
    case Y.GREATER_THAN_OR_EQUAL:
      t = Vs(a, i) || a > Oi(i);
      break;
    case Y.LESS_THAN:
    case Y.LESS_THAN_OR_EQUAL:
      t = a < Oi(i);
      break;
  }
  return t;
}
function nf(a) {
  return a.replace(/[.+^${}()|[\]\\]/g, "\\$&");
}
function Gs(a) {
  switch (a) {
    case 1:
      return 2;
    case 0:
      return 0;
    case -1:
      return 1;
    default:
      return 0;
  }
}
function Ws(a) {
  return a === -2 ? 1 : 0;
}
const sf = [
  "$",
  "£",
  "¥",
  "¤",
  "֏",
  "؋",
  "৳",
  "฿",
  "៛",
  "₡",
  "₦",
  "₩",
  "₪",
  "₫",
  "€",
  "₭",
  "₮",
  "₱",
  "₲",
  "₴",
  "₸",
  "₹",
  "₺",
  "₼",
  "₽",
  "₾",
  "₿"
], af = {
  currency: 2,
  date: 4,
  datetime: 5,
  error: 11,
  fraction: 7,
  general: 0,
  grouped: 11,
  number: 1,
  percent: 6,
  scientific: 8,
  text: 9,
  time: 5,
  unknown: 11
  /* Custom */
};
function Yb(a, i, e) {
  var u, c;
  if (a == null || i == null)
    return i;
  const t = (e == null ? void 0 : e.getStyleByCell(a)) || a.s, r = (e == null ? void 0 : e.getStyleByCell(i)) || i.s;
  if (t == null || r == null || typeof t != "object" || typeof r != "object")
    return i;
  const n = (u = t == null ? void 0 : t.n) == null ? void 0 : u.pattern, s = (c = r == null ? void 0 : r.n) == null ? void 0 : c.pattern;
  if (n == null || s == null)
    return i;
  const o = n || s;
  return r.n.pattern = o, i;
}
const Qs = new xt(1e5);
function Si(a) {
  const i = Qs.get(a);
  if (i !== void 0)
    return i;
  const e = uf(a);
  return Qs.set(a, e), e;
}
function of() {
  Qs.clear();
}
function uf(a) {
  if (cf(a))
    return 3;
  const i = ht.getFormatInfo(a).type || "unknown";
  return af[i];
}
function cf(a) {
  return !!sf.find((i) => a.includes(i)) && a.startsWith("_(");
}
function on(a, i, e) {
  if (a === "")
    return i;
  if (i === "")
    return a;
  const t = Si(a), r = Si(i);
  return e === Z.PLUS || e === Z.MINUS ? t === 4 && r === 4 || t === 11 && r === 11 ? "" : i : e === Z.MULTIPLY || e === Z.DIVIDED ? t === 6 && r === 6 || t === 7 && r === 7 || t === 8 && r === 8 || t === 9 && r === 9 ? i : "" : a || i;
}
const lf = /* @__PURE__ */ new Map([
  [_t.EN_US, "$"],
  [_t.RU_RU, "₽"],
  [_t.VI_VN, "₫"],
  [_t.ZH_CN, "¥"],
  [_t.ZH_TW, "NT$"],
  [_t.FR_FR, "€"],
  [_t.FA_IR, "﷼"],
  [_t.KO_KR, "₩"],
  [_t.ES_ES, "€"],
  [_t.CA_ES, "€"]
]);
function Mi(a) {
  return lf.get(a) || "$";
}
function et(a, i = 2) {
  let e = i;
  i > 127 && (e = 127);
  let t = "";
  return e > 0 && (t = `.${"0".repeat(e)}`), `"${Mi(a)}"#,##0${t}_);[Red]("${Mi(a)}"#,##0${t})`;
}
function ff(a, i, e = 2) {
  return ht.format(et(a, e), i);
}
const Na = new xt(1e5);
function mf(a) {
  let i = a;
  i.startsWith('"') && i.endsWith('"') && (i = i.slice(1, -1));
  const e = Na.get(i);
  if (e)
    return {
      isNumberPattern: !0,
      value: e.value,
      pattern: e.pattern
    };
  const t = ht.parseNumber(i);
  if (t && t.z)
    return Os(i, t.v, t.z);
  const r = ht.parseDate(i);
  if (r && r.z)
    return Os(i, r.v, r.z);
  const n = ht.parseTime(i);
  return n && n.z ? Os(i, n.v, n.z) : {
    isNumberPattern: !1
  };
}
function Os(a, i, e) {
  return Na.set(a, {
    value: i,
    pattern: e
  }), {
    isNumberPattern: !0,
    value: i,
    pattern: e
  };
}
function hf() {
  Na.clear();
}
class Qt extends ts {
  constructor(e) {
    super();
    A(this, "_customData");
    this._rawValue = e;
  }
  isValueObject() {
    return !0;
  }
  toUnitRange() {
    return {
      range: {
        startColumn: -1,
        startRow: -1,
        endRow: -1,
        endColumn: -1
      },
      sheetId: "",
      unitId: ""
    };
  }
  getValue() {
    return 0;
  }
  getArrayValue() {
    return [];
  }
  setValue(e) {
  }
  setArrayValue(e) {
  }
  withCustomData(e) {
    return this._customData = e, this;
  }
  getCustomData() {
    return this._customData;
  }
  isCube() {
    return !1;
  }
  isString() {
    return !1;
  }
  isNumber() {
    return !1;
  }
  isBoolean() {
    return !1;
  }
  isLambda() {
    return !1;
  }
  isDateFormat() {
    return !1;
  }
  isError() {
    return !1;
  }
  isNull() {
    return !1;
  }
  isHyperlink() {
    return !1;
  }
  isImage() {
    return !1;
  }
  sum() {
    return g.create(h.VALUE);
  }
  max() {
    return g.create(h.VALUE);
  }
  min() {
    return g.create(h.VALUE);
  }
  count() {
    return g.create(h.VALUE);
  }
  countA() {
    return g.create(h.VALUE);
  }
  countBlank() {
    return g.create(h.VALUE);
  }
  getNegative() {
    return g.create(h.VALUE);
  }
  getReciprocal() {
    return g.create(h.VALUE);
  }
  plus(e) {
    return g.create(h.VALUE);
  }
  minus(e) {
    return g.create(h.VALUE);
  }
  multiply(e) {
    return g.create(h.VALUE);
  }
  divided(e) {
    return g.create(h.VALUE);
  }
  mod(e) {
    return g.create(h.VALUE);
  }
  /**
   * return every value in the array after the callback function, excluding the error value
   * @param callbackFn
   * @returns
   */
  map(e) {
    return g.create(h.NAME);
  }
  /**
   * return every value in the array after the callback function
   * @param callbackFn
   * @returns
   */
  mapValue(e) {
    return g.create(h.NAME);
  }
  compare(e, t, r = !1) {
    return g.create(h.NAME);
  }
  isEqual(e) {
    return this.compare(e, Y.EQUALS);
  }
  isNotEqual(e) {
    return this.compare(e, Y.NOT_EQUAL);
  }
  isGreaterThanOrEqual(e) {
    return this.compare(e, Y.GREATER_THAN_OR_EQUAL);
  }
  isLessThanOrEqual(e) {
    return this.compare(e, Y.LESS_THAN_OR_EQUAL);
  }
  isLessThan(e) {
    return this.compare(e, Y.LESS_THAN);
  }
  isGreaterThan(e) {
    return this.compare(e, Y.GREATER_THAN);
  }
  concatenateFront(e) {
    return g.create(h.NAME);
  }
  concatenateBack(e) {
    return g.create(h.NAME);
  }
  plusBy(e) {
    return g.create(h.VALUE);
  }
  minusBy(e) {
    return g.create(h.VALUE);
  }
  multiplyBy(e) {
    return g.create(h.VALUE);
  }
  dividedBy(e) {
    return g.create(h.VALUE);
  }
  modInverse(e) {
    return g.create(h.VALUE);
  }
  compareBy(e, t, r = !1) {
    return g.create(h.NAME);
  }
  concatenate(e, t = ft.FRONT) {
    let r = this.getValue().toString();
    if (typeof e == "string")
      t === ft.FRONT ? r = e + r : r += e;
    else if (typeof e == "number")
      t === ft.FRONT ? r = e.toString() + r : r += e.toString();
    else if (typeof e == "boolean") {
      const n = e ? "TRUE" : "FALSE";
      t === ft.FRONT ? r = n + r : r += n;
    }
    return r;
  }
  pow(e) {
    return g.create(h.VALUE);
  }
  powInverse(e) {
    return g.create(h.VALUE);
  }
  sqrt() {
    return g.create(h.VALUE);
  }
  cbrt() {
    return g.create(h.VALUE);
  }
  cos() {
    return g.create(h.VALUE);
  }
  cosh() {
    return g.create(h.VALUE);
  }
  acos() {
    return g.create(h.VALUE);
  }
  acosh() {
    return g.create(h.VALUE);
  }
  sin() {
    return g.create(h.VALUE);
  }
  sinh() {
    return g.create(h.VALUE);
  }
  asin() {
    return g.create(h.VALUE);
  }
  asinh() {
    return g.create(h.VALUE);
  }
  tan() {
    return g.create(h.VALUE);
  }
  tanh() {
    return g.create(h.VALUE);
  }
  atan() {
    return g.create(h.VALUE);
  }
  atan2(e) {
    return g.create(h.VALUE);
  }
  atan2Inverse(e) {
    return g.create(h.VALUE);
  }
  atanh() {
    return g.create(h.VALUE);
  }
  /**
   * Calculate the mean of the entire array.
   *
   * reference https://numpy.org/doc/stable/reference/generated/numpy.mean.html#numpy.mean
   *
   */
  mean() {
    return this;
  }
  /**
   * Calculate the median of the entire array.
   *
   * reference https://numpy.org/doc/stable/reference/generated/numpy.median.html
   *
   */
  median() {
    return this;
  }
  /**
   * Calculate the variance of the entire array.
   *
   * reference https://numpy.org/doc/stable/reference/generated/numpy.var.html
   */
  var() {
    return this;
  }
  /**
   * Calculate the standard deviation of the entire array.
   *
   * reference https://numpy.org/doc/stable/reference/generated/numpy.std.html
   */
  std() {
    return this;
  }
  log() {
    return g.create(h.VALUE);
  }
  log10() {
    return g.create(h.VALUE);
  }
  exp() {
    return g.create(h.VALUE);
  }
  abs() {
    return g.create(h.VALUE);
  }
  round(e) {
    return g.create(h.VALUE);
  }
  roundInverse(e) {
    return g.create(h.VALUE);
  }
  floor(e) {
    return g.create(h.VALUE);
  }
  floorInverse(e) {
    return g.create(h.VALUE);
  }
  ceil(e) {
    return g.create(h.VALUE);
  }
  ceilInverse(e) {
    return g.create(h.VALUE);
  }
  convertToNumberObjectValue() {
    return g.create(h.VALUE);
  }
  convertToBooleanObjectValue() {
    return g.create(h.VALUE);
  }
}
const gf = 1e3, qs = new xt(gf);
class g extends Qt {
  constructor(i, e = "") {
    super(i), this._errorType = i, this._errorContent = e;
  }
  static create(i, e = "") {
    const t = `${i}-${e}`, r = qs.get(t);
    if (r)
      return r;
    const n = new g(i, e);
    return qs.set(t, n), n;
  }
  getValue() {
    return this._errorType;
  }
  getErrorType() {
    return this._errorType;
  }
  getErrorContent() {
    return this._errorContent;
  }
  isEqualType(i) {
    return i.getErrorType() === this.getErrorType();
  }
  isError() {
    return !0;
  }
}
function Va(a) {
  let i;
  switch (a) {
    case Y.EQUALS:
      i = Y.EQUALS;
      break;
    case Y.GREATER_THAN:
      i = Y.LESS_THAN;
      break;
    case Y.GREATER_THAN_OR_EQUAL:
      i = Y.LESS_THAN_OR_EQUAL;
      break;
    case Y.LESS_THAN:
      i = Y.GREATER_THAN;
      break;
    case Y.LESS_THAN_OR_EQUAL:
      i = Y.GREATER_THAN_OR_EQUAL;
      break;
    case Y.NOT_EQUAL:
      i = Y.NOT_EQUAL;
      break;
  }
  return i;
}
var dr = 9e15, qt = 1e9, Xs = "0123456789abcdef", wn = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", Ln = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", Ks = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -dr,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: dr,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: !1
  // true/false
}, To, Lt, ue = !0, rs = "[DecimalError] ", Ht = rs + "Invalid argument: ", Io = rs + "Precision limit exceeded", Bo = rs + "crypto unavailable", Fo = "[object Decimal]", $e = Math.floor, je = Math.pow, df = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, Cf = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, _f = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, ko = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, gt = 1e7, se = 7, Af = 9007199254740991, Ef = wn.length - 1, Zs = Ln.length - 1, B = { toStringTag: Fo };
B.absoluteValue = B.abs = function() {
  var a = new this.constructor(this);
  return a.s < 0 && (a.s = 1), te(a);
};
B.ceil = function() {
  return te(new this.constructor(this), this.e + 1, 2);
};
B.clampedTo = B.clamp = function(a, i) {
  var e, t = this, r = t.constructor;
  if (a = new r(a), i = new r(i), !a.s || !i.s) return new r(NaN);
  if (a.gt(i)) throw Error(Ht + i);
  return e = t.cmp(a), e < 0 ? a : t.cmp(i) > 0 ? i : new r(t);
};
B.comparedTo = B.cmp = function(a) {
  var i, e, t, r, n = this, s = n.d, o = (a = new n.constructor(a)).d, u = n.s, c = a.s;
  if (!s || !o)
    return !u || !c ? NaN : u !== c ? u : s === o ? 0 : !s ^ u < 0 ? 1 : -1;
  if (!s[0] || !o[0]) return s[0] ? u : o[0] ? -c : 0;
  if (u !== c) return u;
  if (n.e !== a.e) return n.e > a.e ^ u < 0 ? 1 : -1;
  for (t = s.length, r = o.length, i = 0, e = t < r ? t : r; i < e; ++i)
    if (s[i] !== o[i]) return s[i] > o[i] ^ u < 0 ? 1 : -1;
  return t === r ? 0 : t > r ^ u < 0 ? 1 : -1;
};
B.cosine = B.cos = function() {
  var a, i, e = this, t = e.constructor;
  return e.d ? e.d[0] ? (a = t.precision, i = t.rounding, t.precision = a + Math.max(e.e, e.sd()) + se, t.rounding = 1, e = Rf(t, Wo(t, e)), t.precision = a, t.rounding = i, te(Lt == 2 || Lt == 3 ? e.neg() : e, a, i, !0)) : new t(1) : new t(NaN);
};
B.cubeRoot = B.cbrt = function() {
  var a, i, e, t, r, n, s, o, u, c, l = this, f = l.constructor;
  if (!l.isFinite() || l.isZero()) return new f(l);
  for (ue = !1, n = l.s * je(l.s * l, 1 / 3), !n || Math.abs(n) == 1 / 0 ? (e = Te(l.d), a = l.e, (n = (a - e.length + 1) % 3) && (e += n == 1 || n == -2 ? "0" : "00"), n = je(e, 1 / 3), a = $e((a + 1) / 3) - (a % 3 == (a < 0 ? -1 : 2)), n == 1 / 0 ? e = "5e" + a : (e = n.toExponential(), e = e.slice(0, e.indexOf("e") + 1) + a), t = new f(e), t.s = l.s) : t = new f(n.toString()), s = (a = f.precision) + 3; ; )
    if (o = t, u = o.times(o).times(o), c = u.plus(l), t = Oe(c.plus(l).times(o), c.plus(u), s + 2, 1), Te(o.d).slice(0, s) === (e = Te(t.d)).slice(0, s))
      if (e = e.slice(s - 3, s + 1), e == "9999" || !r && e == "4999") {
        if (!r && (te(o, a + 1, 0), o.times(o).times(o).eq(l))) {
          t = o;
          break;
        }
        s += 4, r = 1;
      } else {
        (!+e || !+e.slice(1) && e.charAt(0) == "5") && (te(t, a + 1, 1), i = !t.times(t).times(t).eq(l));
        break;
      }
  return ue = !0, te(t, a, f.rounding, i);
};
B.decimalPlaces = B.dp = function() {
  var a, i = this.d, e = NaN;
  if (i) {
    if (a = i.length - 1, e = (a - $e(this.e / se)) * se, a = i[a], a) for (; a % 10 == 0; a /= 10) e--;
    e < 0 && (e = 0);
  }
  return e;
};
B.dividedBy = B.div = function(a) {
  return Oe(this, new this.constructor(a));
};
B.dividedToIntegerBy = B.divToInt = function(a) {
  var i = this, e = i.constructor;
  return te(Oe(i, new e(a), 0, 1, 1), e.precision, e.rounding);
};
B.equals = B.eq = function(a) {
  return this.cmp(a) === 0;
};
B.floor = function() {
  return te(new this.constructor(this), this.e + 1, 3);
};
B.greaterThan = B.gt = function(a) {
  return this.cmp(a) > 0;
};
B.greaterThanOrEqualTo = B.gte = function(a) {
  var i = this.cmp(a);
  return i == 1 || i === 0;
};
B.hyperbolicCosine = B.cosh = function() {
  var a, i, e, t, r, n = this, s = n.constructor, o = new s(1);
  if (!n.isFinite()) return new s(n.s ? 1 / 0 : NaN);
  if (n.isZero()) return o;
  e = s.precision, t = s.rounding, s.precision = e + Math.max(n.e, n.sd()) + 4, s.rounding = 1, r = n.d.length, r < 32 ? (a = Math.ceil(r / 3), i = (1 / ss(4, a)).toString()) : (a = 16, i = "2.3283064365386962890625e-10"), n = Nr(s, 1, n.times(i), new s(1), !0);
  for (var u, c = a, l = new s(8); c--; )
    u = n.times(n), n = o.minus(u.times(l.minus(u.times(l))));
  return te(n, s.precision = e, s.rounding = t, !0);
};
B.hyperbolicSine = B.sinh = function() {
  var a, i, e, t, r = this, n = r.constructor;
  if (!r.isFinite() || r.isZero()) return new n(r);
  if (i = n.precision, e = n.rounding, n.precision = i + Math.max(r.e, r.sd()) + 4, n.rounding = 1, t = r.d.length, t < 3)
    r = Nr(n, 2, r, r, !0);
  else {
    a = 1.4 * Math.sqrt(t), a = a > 16 ? 16 : a | 0, r = r.times(1 / ss(5, a)), r = Nr(n, 2, r, r, !0);
    for (var s, o = new n(5), u = new n(16), c = new n(20); a--; )
      s = r.times(r), r = r.times(o.plus(s.times(u.times(s).plus(c))));
  }
  return n.precision = i, n.rounding = e, te(r, i, e, !0);
};
B.hyperbolicTangent = B.tanh = function() {
  var a, i, e = this, t = e.constructor;
  return e.isFinite() ? e.isZero() ? new t(e) : (a = t.precision, i = t.rounding, t.precision = a + 7, t.rounding = 1, Oe(e.sinh(), e.cosh(), t.precision = a, t.rounding = i)) : new t(e.s);
};
B.inverseCosine = B.acos = function() {
  var a = this, i = a.constructor, e = a.abs().cmp(1), t = i.precision, r = i.rounding;
  return e !== -1 ? e === 0 ? a.isNeg() ? bt(i, t, r) : new i(0) : new i(NaN) : a.isZero() ? bt(i, t + 4, r).times(0.5) : (i.precision = t + 6, i.rounding = 1, a = new i(1).minus(a).div(a.plus(1)).sqrt().atan(), i.precision = t, i.rounding = r, a.times(2));
};
B.inverseHyperbolicCosine = B.acosh = function() {
  var a, i, e = this, t = e.constructor;
  return e.lte(1) ? new t(e.eq(1) ? 0 : NaN) : e.isFinite() ? (a = t.precision, i = t.rounding, t.precision = a + Math.max(Math.abs(e.e), e.sd()) + 4, t.rounding = 1, ue = !1, e = e.times(e).minus(1).sqrt().plus(e), ue = !0, t.precision = a, t.rounding = i, e.ln()) : new t(e);
};
B.inverseHyperbolicSine = B.asinh = function() {
  var a, i, e = this, t = e.constructor;
  return !e.isFinite() || e.isZero() ? new t(e) : (a = t.precision, i = t.rounding, t.precision = a + 2 * Math.max(Math.abs(e.e), e.sd()) + 6, t.rounding = 1, ue = !1, e = e.times(e).plus(1).sqrt().plus(e), ue = !0, t.precision = a, t.rounding = i, e.ln());
};
B.inverseHyperbolicTangent = B.atanh = function() {
  var a, i, e, t, r = this, n = r.constructor;
  return r.isFinite() ? r.e >= 0 ? new n(r.abs().eq(1) ? r.s / 0 : r.isZero() ? r : NaN) : (a = n.precision, i = n.rounding, t = r.sd(), Math.max(t, a) < 2 * -r.e - 1 ? te(new n(r), a, i, !0) : (n.precision = e = t - r.e, r = Oe(r.plus(1), new n(1).minus(r), e + a, 1), n.precision = a + 4, n.rounding = 1, r = r.ln(), n.precision = a, n.rounding = i, r.times(0.5))) : new n(NaN);
};
B.inverseSine = B.asin = function() {
  var a, i, e, t, r = this, n = r.constructor;
  return r.isZero() ? new n(r) : (i = r.abs().cmp(1), e = n.precision, t = n.rounding, i !== -1 ? i === 0 ? (a = bt(n, e + 4, t).times(0.5), a.s = r.s, a) : new n(NaN) : (n.precision = e + 6, n.rounding = 1, r = r.div(new n(1).minus(r.times(r)).sqrt().plus(1)).atan(), n.precision = e, n.rounding = t, r.times(2)));
};
B.inverseTangent = B.atan = function() {
  var a, i, e, t, r, n, s, o, u, c = this, l = c.constructor, f = l.precision, m = l.rounding;
  if (c.isFinite()) {
    if (c.isZero())
      return new l(c);
    if (c.abs().eq(1) && f + 4 <= Zs)
      return s = bt(l, f + 4, m).times(0.25), s.s = c.s, s;
  } else {
    if (!c.s) return new l(NaN);
    if (f + 4 <= Zs)
      return s = bt(l, f + 4, m).times(0.5), s.s = c.s, s;
  }
  for (l.precision = o = f + 10, l.rounding = 1, e = Math.min(28, o / se + 2 | 0), a = e; a; --a) c = c.div(c.times(c).plus(1).sqrt().plus(1));
  for (ue = !1, i = Math.ceil(o / se), t = 1, u = c.times(c), s = new l(c), r = c; a !== -1; )
    if (r = r.times(u), n = s.minus(r.div(t += 2)), r = r.times(u), s = n.plus(r.div(t += 2)), s.d[i] !== void 0) for (a = i; s.d[a] === n.d[a] && a--; ) ;
  return e && (s = s.times(2 << e - 1)), ue = !0, te(s, l.precision = f, l.rounding = m, !0);
};
B.isFinite = function() {
  return !!this.d;
};
B.isInteger = B.isInt = function() {
  return !!this.d && $e(this.e / se) > this.d.length - 2;
};
B.isNaN = function() {
  return !this.s;
};
B.isNegative = B.isNeg = function() {
  return this.s < 0;
};
B.isPositive = B.isPos = function() {
  return this.s > 0;
};
B.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
B.lessThan = B.lt = function(a) {
  return this.cmp(a) < 0;
};
B.lessThanOrEqualTo = B.lte = function(a) {
  return this.cmp(a) < 1;
};
B.logarithm = B.log = function(a) {
  var i, e, t, r, n, s, o, u, c = this, l = c.constructor, f = l.precision, m = l.rounding, d = 5;
  if (a == null)
    a = new l(10), i = !0;
  else {
    if (a = new l(a), e = a.d, a.s < 0 || !e || !e[0] || a.eq(1)) return new l(NaN);
    i = a.eq(10);
  }
  if (e = c.d, c.s < 0 || !e || !e[0] || c.eq(1))
    return new l(e && !e[0] ? -1 / 0 : c.s != 1 ? NaN : e ? 0 : 1 / 0);
  if (i)
    if (e.length > 1)
      n = !0;
    else {
      for (r = e[0]; r % 10 === 0; ) r /= 10;
      n = r !== 1;
    }
  if (ue = !1, o = f + d, s = Bt(c, o), t = i ? Pn(l, o + 10) : Bt(a, o), u = Oe(s, t, o, 1), $r(u.d, r = f, m))
    do
      if (o += 10, s = Bt(c, o), t = i ? Pn(l, o + 10) : Bt(a, o), u = Oe(s, t, o, 1), !n) {
        +Te(u.d).slice(r + 1, r + 15) + 1 == 1e14 && (u = te(u, f + 1, 0));
        break;
      }
    while ($r(u.d, r += 10, m));
  return ue = !0, te(u, f, m);
};
B.minus = B.sub = function(a) {
  var i, e, t, r, n, s, o, u, c, l, f, m, d = this, _ = d.constructor;
  if (a = new _(a), !d.d || !a.d)
    return !d.s || !a.s ? a = new _(NaN) : d.d ? a.s = -a.s : a = new _(a.d || d.s !== a.s ? d : NaN), a;
  if (d.s != a.s)
    return a.s = -a.s, d.plus(a);
  if (c = d.d, m = a.d, o = _.precision, u = _.rounding, !c[0] || !m[0]) {
    if (m[0]) a.s = -a.s;
    else if (c[0]) a = new _(d);
    else return new _(u === 3 ? -0 : 0);
    return ue ? te(a, o, u) : a;
  }
  if (e = $e(a.e / se), l = $e(d.e / se), c = c.slice(), n = l - e, n) {
    for (f = n < 0, f ? (i = c, n = -n, s = m.length) : (i = m, e = l, s = c.length), t = Math.max(Math.ceil(o / se), s) + 2, n > t && (n = t, i.length = 1), i.reverse(), t = n; t--; ) i.push(0);
    i.reverse();
  } else {
    for (t = c.length, s = m.length, f = t < s, f && (s = t), t = 0; t < s; t++)
      if (c[t] != m[t]) {
        f = c[t] < m[t];
        break;
      }
    n = 0;
  }
  for (f && (i = c, c = m, m = i, a.s = -a.s), s = c.length, t = m.length - s; t > 0; --t) c[s++] = 0;
  for (t = m.length; t > n; ) {
    if (c[--t] < m[t]) {
      for (r = t; r && c[--r] === 0; ) c[r] = gt - 1;
      --c[r], c[t] += gt;
    }
    c[t] -= m[t];
  }
  for (; c[--s] === 0; ) c.pop();
  for (; c[0] === 0; c.shift()) --e;
  return c[0] ? (a.d = c, a.e = ns(c, e), ue ? te(a, o, u) : a) : new _(u === 3 ? -0 : 0);
};
B.modulo = B.mod = function(a) {
  var i, e = this, t = e.constructor;
  return a = new t(a), !e.d || !a.s || a.d && !a.d[0] ? new t(NaN) : !a.d || e.d && !e.d[0] ? te(new t(e), t.precision, t.rounding) : (ue = !1, t.modulo == 9 ? (i = Oe(e, a.abs(), 0, 3, 1), i.s *= a.s) : i = Oe(e, a, 0, t.modulo, 1), i = i.times(a), ue = !0, e.minus(i));
};
B.naturalExponential = B.exp = function() {
  return zs(this);
};
B.naturalLogarithm = B.ln = function() {
  return Bt(this);
};
B.negated = B.neg = function() {
  var a = new this.constructor(this);
  return a.s = -a.s, te(a);
};
B.plus = B.add = function(a) {
  var i, e, t, r, n, s, o, u, c, l, f = this, m = f.constructor;
  if (a = new m(a), !f.d || !a.d)
    return !f.s || !a.s ? a = new m(NaN) : f.d || (a = new m(a.d || f.s === a.s ? f : NaN)), a;
  if (f.s != a.s)
    return a.s = -a.s, f.minus(a);
  if (c = f.d, l = a.d, o = m.precision, u = m.rounding, !c[0] || !l[0])
    return l[0] || (a = new m(f)), ue ? te(a, o, u) : a;
  if (n = $e(f.e / se), t = $e(a.e / se), c = c.slice(), r = n - t, r) {
    for (r < 0 ? (e = c, r = -r, s = l.length) : (e = l, t = n, s = c.length), n = Math.ceil(o / se), s = n > s ? n + 1 : s + 1, r > s && (r = s, e.length = 1), e.reverse(); r--; ) e.push(0);
    e.reverse();
  }
  for (s = c.length, r = l.length, s - r < 0 && (r = s, e = l, l = c, c = e), i = 0; r; )
    i = (c[--r] = c[r] + l[r] + i) / gt | 0, c[r] %= gt;
  for (i && (c.unshift(i), ++t), s = c.length; c[--s] == 0; ) c.pop();
  return a.d = c, a.e = ns(c, t), ue ? te(a, o, u) : a;
};
B.precision = B.sd = function(a) {
  var i, e = this;
  if (a !== void 0 && a !== !!a && a !== 1 && a !== 0) throw Error(Ht + a);
  return e.d ? (i = $o(e.d), a && e.e + 1 > i && (i = e.e + 1)) : i = NaN, i;
};
B.round = function() {
  var a = this, i = a.constructor;
  return te(new i(a), a.e + 1, i.rounding);
};
B.sine = B.sin = function() {
  var a, i, e = this, t = e.constructor;
  return e.isFinite() ? e.isZero() ? new t(e) : (a = t.precision, i = t.rounding, t.precision = a + Math.max(e.e, e.sd()) + se, t.rounding = 1, e = yf(t, Wo(t, e)), t.precision = a, t.rounding = i, te(Lt > 2 ? e.neg() : e, a, i, !0)) : new t(NaN);
};
B.squareRoot = B.sqrt = function() {
  var a, i, e, t, r, n, s = this, o = s.d, u = s.e, c = s.s, l = s.constructor;
  if (c !== 1 || !o || !o[0])
    return new l(!c || c < 0 && (!o || o[0]) ? NaN : o ? s : 1 / 0);
  for (ue = !1, c = Math.sqrt(+s), c == 0 || c == 1 / 0 ? (i = Te(o), (i.length + u) % 2 == 0 && (i += "0"), c = Math.sqrt(i), u = $e((u + 1) / 2) - (u < 0 || u % 2), c == 1 / 0 ? i = "5e" + u : (i = c.toExponential(), i = i.slice(0, i.indexOf("e") + 1) + u), t = new l(i)) : t = new l(c.toString()), e = (u = l.precision) + 3; ; )
    if (n = t, t = n.plus(Oe(s, n, e + 2, 1)).times(0.5), Te(n.d).slice(0, e) === (i = Te(t.d)).slice(0, e))
      if (i = i.slice(e - 3, e + 1), i == "9999" || !r && i == "4999") {
        if (!r && (te(n, u + 1, 0), n.times(n).eq(s))) {
          t = n;
          break;
        }
        e += 4, r = 1;
      } else {
        (!+i || !+i.slice(1) && i.charAt(0) == "5") && (te(t, u + 1, 1), a = !t.times(t).eq(s));
        break;
      }
  return ue = !0, te(t, u, l.rounding, a);
};
B.tangent = B.tan = function() {
  var a, i, e = this, t = e.constructor;
  return e.isFinite() ? e.isZero() ? new t(e) : (a = t.precision, i = t.rounding, t.precision = a + 10, t.rounding = 1, e = e.sin(), e.s = 1, e = Oe(e, new t(1).minus(e.times(e)).sqrt(), a + 10, 0), t.precision = a, t.rounding = i, te(Lt == 2 || Lt == 4 ? e.neg() : e, a, i, !0)) : new t(NaN);
};
B.times = B.mul = function(a) {
  var i, e, t, r, n, s, o, u, c, l = this, f = l.constructor, m = l.d, d = (a = new f(a)).d;
  if (a.s *= l.s, !m || !m[0] || !d || !d[0])
    return new f(!a.s || m && !m[0] && !d || d && !d[0] && !m ? NaN : !m || !d ? a.s / 0 : a.s * 0);
  for (e = $e(l.e / se) + $e(a.e / se), u = m.length, c = d.length, u < c && (n = m, m = d, d = n, s = u, u = c, c = s), n = [], s = u + c, t = s; t--; ) n.push(0);
  for (t = c; --t >= 0; ) {
    for (i = 0, r = u + t; r > t; )
      o = n[r] + d[t] * m[r - t - 1] + i, n[r--] = o % gt | 0, i = o / gt | 0;
    n[r] = (n[r] + i) % gt | 0;
  }
  for (; !n[--s]; ) n.pop();
  return i ? ++e : n.shift(), a.d = n, a.e = ns(n, e), ue ? te(a, f.precision, f.rounding) : a;
};
B.toBinary = function(a, i) {
  return Oa(this, 2, a, i);
};
B.toDecimalPlaces = B.toDP = function(a, i) {
  var e = this, t = e.constructor;
  return e = new t(e), a === void 0 ? e : (Qe(a, 0, qt), i === void 0 ? i = t.rounding : Qe(i, 0, 8), te(e, a + e.e + 1, i));
};
B.toExponential = function(a, i) {
  var e, t = this, r = t.constructor;
  return a === void 0 ? e = pt(t, !0) : (Qe(a, 0, qt), i === void 0 ? i = r.rounding : Qe(i, 0, 8), t = te(new r(t), a + 1, i), e = pt(t, !0, a + 1)), t.isNeg() && !t.isZero() ? "-" + e : e;
};
B.toFixed = function(a, i) {
  var e, t, r = this, n = r.constructor;
  return a === void 0 ? e = pt(r) : (Qe(a, 0, qt), i === void 0 ? i = n.rounding : Qe(i, 0, 8), t = te(new n(r), a + r.e + 1, i), e = pt(t, !1, a + t.e + 1)), r.isNeg() && !r.isZero() ? "-" + e : e;
};
B.toFraction = function(a) {
  var i, e, t, r, n, s, o, u, c, l, f, m, d = this, _ = d.d, C = d.constructor;
  if (!_) return new C(d);
  if (c = e = new C(1), t = u = new C(0), i = new C(t), n = i.e = $o(_) - d.e - 1, s = n % se, i.d[0] = je(10, s < 0 ? se + s : s), a == null)
    a = n > 0 ? i : c;
  else {
    if (o = new C(a), !o.isInt() || o.lt(c)) throw Error(Ht + o);
    a = o.gt(i) ? n > 0 ? i : c : o;
  }
  for (ue = !1, o = new C(Te(_)), l = C.precision, C.precision = n = _.length * se * 2; f = Oe(o, i, 0, 1, 1), r = e.plus(f.times(t)), r.cmp(a) != 1; )
    e = t, t = r, r = c, c = u.plus(f.times(r)), u = r, r = i, i = o.minus(f.times(r)), o = r;
  return r = Oe(a.minus(e), t, 0, 1, 1), u = u.plus(r.times(c)), e = e.plus(r.times(t)), u.s = c.s = d.s, m = Oe(c, t, n, 1).minus(d).abs().cmp(Oe(u, e, n, 1).minus(d).abs()) < 1 ? [c, t] : [u, e], C.precision = l, ue = !0, m;
};
B.toHexadecimal = B.toHex = function(a, i) {
  return Oa(this, 16, a, i);
};
B.toNearest = function(a, i) {
  var e = this, t = e.constructor;
  if (e = new t(e), a == null) {
    if (!e.d) return e;
    a = new t(1), i = t.rounding;
  } else {
    if (a = new t(a), i === void 0 ? i = t.rounding : Qe(i, 0, 8), !e.d) return a.s ? e : a;
    if (!a.d)
      return a.s && (a.s = e.s), a;
  }
  return a.d[0] ? (ue = !1, e = Oe(e, a, 0, i, 1).times(a), ue = !0, te(e)) : (a.s = e.s, e = a), e;
};
B.toNumber = function() {
  return +this;
};
B.toOctal = function(a, i) {
  return Oa(this, 8, a, i);
};
B.toPower = B.pow = function(a) {
  var i, e, t, r, n, s, o = this, u = o.constructor, c = +(a = new u(a));
  if (!o.d || !a.d || !o.d[0] || !a.d[0]) return new u(je(+o, c));
  if (o = new u(o), o.eq(1)) return o;
  if (t = u.precision, n = u.rounding, a.eq(1)) return te(o, t, n);
  if (i = $e(a.e / se), i >= a.d.length - 1 && (e = c < 0 ? -c : c) <= Af)
    return r = Yo(u, o, e, t), a.s < 0 ? new u(1).div(r) : te(r, t, n);
  if (s = o.s, s < 0) {
    if (i < a.d.length - 1) return new u(NaN);
    if ((a.d[i] & 1) == 0 && (s = 1), o.e == 0 && o.d[0] == 1 && o.d.length == 1)
      return o.s = s, o;
  }
  return e = je(+o, c), i = e == 0 || !isFinite(e) ? $e(c * (Math.log("0." + Te(o.d)) / Math.LN10 + o.e + 1)) : new u(e + "").e, i > u.maxE + 1 || i < u.minE - 1 ? new u(i > 0 ? s / 0 : 0) : (ue = !1, u.rounding = o.s = 1, e = Math.min(12, (i + "").length), r = zs(a.times(Bt(o, t + e)), t), r.d && (r = te(r, t + 5, 1), $r(r.d, t, n) && (i = t + 10, r = te(zs(a.times(Bt(o, i + e)), i), i + 5, 1), +Te(r.d).slice(t + 1, t + 15) + 1 == 1e14 && (r = te(r, t + 1, 0)))), r.s = s, ue = !0, u.rounding = n, te(r, t, n));
};
B.toPrecision = function(a, i) {
  var e, t = this, r = t.constructor;
  return a === void 0 ? e = pt(t, t.e <= r.toExpNeg || t.e >= r.toExpPos) : (Qe(a, 1, qt), i === void 0 ? i = r.rounding : Qe(i, 0, 8), t = te(new r(t), a, i), e = pt(t, a <= t.e || t.e <= r.toExpNeg, a)), t.isNeg() && !t.isZero() ? "-" + e : e;
};
B.toSignificantDigits = B.toSD = function(a, i) {
  var e = this, t = e.constructor;
  return a === void 0 ? (a = t.precision, i = t.rounding) : (Qe(a, 1, qt), i === void 0 ? i = t.rounding : Qe(i, 0, 8)), te(new t(e), a, i);
};
B.toString = function() {
  var a = this, i = a.constructor, e = pt(a, a.e <= i.toExpNeg || a.e >= i.toExpPos);
  return a.isNeg() && !a.isZero() ? "-" + e : e;
};
B.truncated = B.trunc = function() {
  return te(new this.constructor(this), this.e + 1, 1);
};
B.valueOf = B.toJSON = function() {
  var a = this, i = a.constructor, e = pt(a, a.e <= i.toExpNeg || a.e >= i.toExpPos);
  return a.isNeg() ? "-" + e : e;
};
function Te(a) {
  var i, e, t, r = a.length - 1, n = "", s = a[0];
  if (r > 0) {
    for (n += s, i = 1; i < r; i++)
      t = a[i] + "", e = se - t.length, e && (n += Tt(e)), n += t;
    s = a[i], t = s + "", e = se - t.length, e && (n += Tt(e));
  } else if (s === 0)
    return "0";
  for (; s % 10 === 0; ) s /= 10;
  return n + s;
}
function Qe(a, i, e) {
  if (a !== ~~a || a < i || a > e)
    throw Error(Ht + a);
}
function $r(a, i, e, t) {
  var r, n, s, o;
  for (n = a[0]; n >= 10; n /= 10) --i;
  return --i < 0 ? (i += se, r = 0) : (r = Math.ceil((i + 1) / se), i %= se), n = je(10, se - i), o = a[r] % n | 0, t == null ? i < 3 ? (i == 0 ? o = o / 100 | 0 : i == 1 && (o = o / 10 | 0), s = e < 4 && o == 99999 || e > 3 && o == 49999 || o == 5e4 || o == 0) : s = (e < 4 && o + 1 == n || e > 3 && o + 1 == n / 2) && (a[r + 1] / n / 100 | 0) == je(10, i - 2) - 1 || (o == n / 2 || o == 0) && (a[r + 1] / n / 100 | 0) == 0 : i < 4 ? (i == 0 ? o = o / 1e3 | 0 : i == 1 ? o = o / 100 | 0 : i == 2 && (o = o / 10 | 0), s = (t || e < 4) && o == 9999 || !t && e > 3 && o == 4999) : s = ((t || e < 4) && o + 1 == n || !t && e > 3 && o + 1 == n / 2) && (a[r + 1] / n / 1e3 | 0) == je(10, i - 3) - 1, s;
}
function Rn(a, i, e) {
  for (var t, r = [0], n, s = 0, o = a.length; s < o; ) {
    for (n = r.length; n--; ) r[n] *= i;
    for (r[0] += Xs.indexOf(a.charAt(s++)), t = 0; t < r.length; t++)
      r[t] > e - 1 && (r[t + 1] === void 0 && (r[t + 1] = 0), r[t + 1] += r[t] / e | 0, r[t] %= e);
  }
  return r.reverse();
}
function Rf(a, i) {
  var e, t, r;
  if (i.isZero()) return i;
  t = i.d.length, t < 32 ? (e = Math.ceil(t / 3), r = (1 / ss(4, e)).toString()) : (e = 16, r = "2.3283064365386962890625e-10"), a.precision += e, i = Nr(a, 1, i.times(r), new a(1));
  for (var n = e; n--; ) {
    var s = i.times(i);
    i = s.times(s).minus(s).times(8).plus(1);
  }
  return a.precision -= e, i;
}
var Oe = /* @__PURE__ */ (function() {
  function a(t, r, n) {
    var s, o = 0, u = t.length;
    for (t = t.slice(); u--; )
      s = t[u] * r + o, t[u] = s % n | 0, o = s / n | 0;
    return o && t.unshift(o), t;
  }
  function i(t, r, n, s) {
    var o, u;
    if (n != s)
      u = n > s ? 1 : -1;
    else
      for (o = u = 0; o < n; o++)
        if (t[o] != r[o]) {
          u = t[o] > r[o] ? 1 : -1;
          break;
        }
    return u;
  }
  function e(t, r, n, s) {
    for (var o = 0; n--; )
      t[n] -= o, o = t[n] < r[n] ? 1 : 0, t[n] = o * s + t[n] - r[n];
    for (; !t[0] && t.length > 1; ) t.shift();
  }
  return function(t, r, n, s, o, u) {
    var c, l, f, m, d, _, C, E, R, b, p, V, S, M, D, w, L, v, j, k, G = t.constructor, ne = t.s == r.s ? 1 : -1, z = t.d, $ = r.d;
    if (!z || !z[0] || !$ || !$[0])
      return new G(
        // Return NaN if either NaN, or both Infinity or 0.
        !t.s || !r.s || (z ? $ && z[0] == $[0] : !$) ? NaN : (
          // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.
          z && z[0] == 0 || !$ ? ne * 0 : ne / 0
        )
      );
    for (u ? (d = 1, l = t.e - r.e) : (u = gt, d = se, l = $e(t.e / d) - $e(r.e / d)), j = $.length, L = z.length, R = new G(ne), b = R.d = [], f = 0; $[f] == (z[f] || 0); f++) ;
    if ($[f] > (z[f] || 0) && l--, n == null ? (M = n = G.precision, s = G.rounding) : o ? M = n + (t.e - r.e) + 1 : M = n, M < 0)
      b.push(1), _ = !0;
    else {
      if (M = M / d + 2 | 0, f = 0, j == 1) {
        for (m = 0, $ = $[0], M++; (f < L || m) && M--; f++)
          D = m * u + (z[f] || 0), b[f] = D / $ | 0, m = D % $ | 0;
        _ = m || f < L;
      } else {
        for (m = u / ($[0] + 1) | 0, m > 1 && ($ = a($, m, u), z = a(z, m, u), j = $.length, L = z.length), w = j, p = z.slice(0, j), V = p.length; V < j; ) p[V++] = 0;
        k = $.slice(), k.unshift(0), v = $[0], $[1] >= u / 2 && ++v;
        do
          m = 0, c = i($, p, j, V), c < 0 ? (S = p[0], j != V && (S = S * u + (p[1] || 0)), m = S / v | 0, m > 1 ? (m >= u && (m = u - 1), C = a($, m, u), E = C.length, V = p.length, c = i(C, p, E, V), c == 1 && (m--, e(C, j < E ? k : $, E, u))) : (m == 0 && (c = m = 1), C = $.slice()), E = C.length, E < V && C.unshift(0), e(p, C, V, u), c == -1 && (V = p.length, c = i($, p, j, V), c < 1 && (m++, e(p, j < V ? k : $, V, u))), V = p.length) : c === 0 && (m++, p = [0]), b[f++] = m, c && p[0] ? p[V++] = z[w] || 0 : (p = [z[w]], V = 1);
        while ((w++ < L || p[0] !== void 0) && M--);
        _ = p[0] !== void 0;
      }
      b[0] || b.shift();
    }
    if (d == 1)
      R.e = l, To = _;
    else {
      for (f = 1, m = b[0]; m >= 10; m /= 10) f++;
      R.e = f + l * d - 1, te(R, o ? n + R.e + 1 : n, s, _);
    }
    return R;
  };
})();
function te(a, i, e, t) {
  var r, n, s, o, u, c, l, f, m, d = a.constructor;
  e: if (i != null) {
    if (f = a.d, !f) return a;
    for (r = 1, o = f[0]; o >= 10; o /= 10) r++;
    if (n = i - r, n < 0)
      n += se, s = i, l = f[m = 0], u = l / je(10, r - s - 1) % 10 | 0;
    else if (m = Math.ceil((n + 1) / se), o = f.length, m >= o)
      if (t) {
        for (; o++ <= m; ) f.push(0);
        l = u = 0, r = 1, n %= se, s = n - se + 1;
      } else
        break e;
    else {
      for (l = o = f[m], r = 1; o >= 10; o /= 10) r++;
      n %= se, s = n - se + r, u = s < 0 ? 0 : l / je(10, r - s - 1) % 10 | 0;
    }
    if (t = t || i < 0 || f[m + 1] !== void 0 || (s < 0 ? l : l % je(10, r - s - 1)), c = e < 4 ? (u || t) && (e == 0 || e == (a.s < 0 ? 3 : 2)) : u > 5 || u == 5 && (e == 4 || t || e == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (n > 0 ? s > 0 ? l / je(10, r - s) : 0 : f[m - 1]) % 10 & 1 || e == (a.s < 0 ? 8 : 7)), i < 1 || !f[0])
      return f.length = 0, c ? (i -= a.e + 1, f[0] = je(10, (se - i % se) % se), a.e = -i || 0) : f[0] = a.e = 0, a;
    if (n == 0 ? (f.length = m, o = 1, m--) : (f.length = m + 1, o = je(10, se - n), f[m] = s > 0 ? (l / je(10, r - s) % je(10, s) | 0) * o : 0), c)
      for (; ; )
        if (m == 0) {
          for (n = 1, s = f[0]; s >= 10; s /= 10) n++;
          for (s = f[0] += o, o = 1; s >= 10; s /= 10) o++;
          n != o && (a.e++, f[0] == gt && (f[0] = 1));
          break;
        } else {
          if (f[m] += o, f[m] != gt) break;
          f[m--] = 0, o = 1;
        }
    for (n = f.length; f[--n] === 0; ) f.pop();
  }
  return ue && (a.e > d.maxE ? (a.d = null, a.e = NaN) : a.e < d.minE && (a.e = 0, a.d = [0])), a;
}
function pt(a, i, e) {
  if (!a.isFinite()) return Go(a);
  var t, r = a.e, n = Te(a.d), s = n.length;
  return i ? (e && (t = e - s) > 0 ? n = n.charAt(0) + "." + n.slice(1) + Tt(t) : s > 1 && (n = n.charAt(0) + "." + n.slice(1)), n = n + (a.e < 0 ? "e" : "e+") + a.e) : r < 0 ? (n = "0." + Tt(-r - 1) + n, e && (t = e - s) > 0 && (n += Tt(t))) : r >= s ? (n += Tt(r + 1 - s), e && (t = e - r - 1) > 0 && (n = n + "." + Tt(t))) : ((t = r + 1) < s && (n = n.slice(0, t) + "." + n.slice(t)), e && (t = e - s) > 0 && (r + 1 === s && (n += "."), n += Tt(t))), n;
}
function ns(a, i) {
  var e = a[0];
  for (i *= se; e >= 10; e /= 10) i++;
  return i;
}
function Pn(a, i, e) {
  if (i > Ef)
    throw ue = !0, e && (a.precision = e), Error(Io);
  return te(new a(wn), i, 1, !0);
}
function bt(a, i, e) {
  if (i > Zs) throw Error(Io);
  return te(new a(Ln), i, e, !0);
}
function $o(a) {
  var i = a.length - 1, e = i * se + 1;
  if (i = a[i], i) {
    for (; i % 10 == 0; i /= 10) e--;
    for (i = a[0]; i >= 10; i /= 10) e++;
  }
  return e;
}
function Tt(a) {
  for (var i = ""; a--; ) i += "0";
  return i;
}
function Yo(a, i, e, t) {
  var r, n = new a(1), s = Math.ceil(t / se + 4);
  for (ue = !1; ; ) {
    if (e % 2 && (n = n.times(i), wi(n.d, s) && (r = !0)), e = $e(e / 2), e === 0) {
      e = n.d.length - 1, r && n.d[e] === 0 && ++n.d[e];
      break;
    }
    i = i.times(i), wi(i.d, s);
  }
  return ue = !0, n;
}
function Di(a) {
  return a.d[a.d.length - 1] & 1;
}
function Ho(a, i, e) {
  for (var t, r, n = new a(i[0]), s = 0; ++s < i.length; ) {
    if (r = new a(i[s]), !r.s) {
      n = r;
      break;
    }
    t = n.cmp(r), (t === e || t === 0 && n.s === e) && (n = r);
  }
  return n;
}
function zs(a, i) {
  var e, t, r, n, s, o, u, c = 0, l = 0, f = 0, m = a.constructor, d = m.rounding, _ = m.precision;
  if (!a.d || !a.d[0] || a.e > 17)
    return new m(a.d ? a.d[0] ? a.s < 0 ? 0 : 1 / 0 : 1 : a.s ? a.s < 0 ? 0 : a : NaN);
  for (i == null ? (ue = !1, u = _) : u = i, o = new m(0.03125); a.e > -2; )
    a = a.times(o), f += 5;
  for (t = Math.log(je(2, f)) / Math.LN10 * 2 + 5 | 0, u += t, e = n = s = new m(1), m.precision = u; ; ) {
    if (n = te(n.times(a), u, 1), e = e.times(++l), o = s.plus(Oe(n, e, u, 1)), Te(o.d).slice(0, u) === Te(s.d).slice(0, u)) {
      for (r = f; r--; ) s = te(s.times(s), u, 1);
      if (i == null)
        if (c < 3 && $r(s.d, u - t, d, c))
          m.precision = u += 10, e = n = o = new m(1), l = 0, c++;
        else
          return te(s, m.precision = _, d, ue = !0);
      else
        return m.precision = _, s;
    }
    s = o;
  }
}
function Bt(a, i) {
  var e, t, r, n, s, o, u, c, l, f, m, d = 1, _ = 10, C = a, E = C.d, R = C.constructor, b = R.rounding, p = R.precision;
  if (C.s < 0 || !E || !E[0] || !C.e && E[0] == 1 && E.length == 1)
    return new R(E && !E[0] ? -1 / 0 : C.s != 1 ? NaN : E ? 0 : C);
  if (i == null ? (ue = !1, l = p) : l = i, R.precision = l += _, e = Te(E), t = e.charAt(0), Math.abs(n = C.e) < 15e14) {
    for (; t < 7 && t != 1 || t == 1 && e.charAt(1) > 3; )
      C = C.times(a), e = Te(C.d), t = e.charAt(0), d++;
    n = C.e, t > 1 ? (C = new R("0." + e), n++) : C = new R(t + "." + e.slice(1));
  } else
    return c = Pn(R, l + 2, p).times(n + ""), C = Bt(new R(t + "." + e.slice(1)), l - _).plus(c), R.precision = p, i == null ? te(C, p, b, ue = !0) : C;
  for (f = C, u = s = C = Oe(C.minus(1), C.plus(1), l, 1), m = te(C.times(C), l, 1), r = 3; ; ) {
    if (s = te(s.times(m), l, 1), c = u.plus(Oe(s, new R(r), l, 1)), Te(c.d).slice(0, l) === Te(u.d).slice(0, l))
      if (u = u.times(2), n !== 0 && (u = u.plus(Pn(R, l + 2, p).times(n + ""))), u = Oe(u, new R(d), l, 1), i == null)
        if ($r(u.d, l - _, b, o))
          R.precision = l += _, c = s = C = Oe(f.minus(1), f.plus(1), l, 1), m = te(C.times(C), l, 1), r = o = 1;
        else
          return te(u, R.precision = p, b, ue = !0);
      else
        return R.precision = p, u;
    u = c, r += 2;
  }
}
function Go(a) {
  return String(a.s * a.s / 0);
}
function bn(a, i) {
  var e, t, r;
  for ((e = i.indexOf(".")) > -1 && (i = i.replace(".", "")), (t = i.search(/e/i)) > 0 ? (e < 0 && (e = t), e += +i.slice(t + 1), i = i.substring(0, t)) : e < 0 && (e = i.length), t = 0; i.charCodeAt(t) === 48; t++) ;
  for (r = i.length; i.charCodeAt(r - 1) === 48; --r) ;
  if (i = i.slice(t, r), i) {
    if (r -= t, a.e = e = e - t - 1, a.d = [], t = (e + 1) % se, e < 0 && (t += se), t < r) {
      for (t && a.d.push(+i.slice(0, t)), r -= se; t < r; ) a.d.push(+i.slice(t, t += se));
      i = i.slice(t), t = se - i.length;
    } else
      t -= r;
    for (; t--; ) i += "0";
    a.d.push(+i), ue && (a.e > a.constructor.maxE ? (a.d = null, a.e = NaN) : a.e < a.constructor.minE && (a.e = 0, a.d = [0]));
  } else
    a.e = 0, a.d = [0];
  return a;
}
function bf(a, i) {
  var e, t, r, n, s, o, u, c, l;
  if (i.indexOf("_") > -1) {
    if (i = i.replace(/(\d)_(?=\d)/g, "$1"), ko.test(i)) return bn(a, i);
  } else if (i === "Infinity" || i === "NaN")
    return +i || (a.s = NaN), a.e = NaN, a.d = null, a;
  if (Cf.test(i))
    e = 16, i = i.toLowerCase();
  else if (df.test(i))
    e = 2;
  else if (_f.test(i))
    e = 8;
  else
    throw Error(Ht + i);
  for (n = i.search(/p/i), n > 0 ? (u = +i.slice(n + 1), i = i.substring(2, n)) : i = i.slice(2), n = i.indexOf("."), s = n >= 0, t = a.constructor, s && (i = i.replace(".", ""), o = i.length, n = o - n, r = Yo(t, new t(e), n, n * 2)), c = Rn(i, e, gt), l = c.length - 1, n = l; c[n] === 0; --n) c.pop();
  return n < 0 ? new t(a.s * 0) : (a.e = ns(c, l), a.d = c, ue = !1, s && (a = Oe(a, r, o * 4)), u && (a = a.times(Math.abs(u) < 54 ? je(2, u) : x.pow(2, u))), ue = !0, a);
}
function yf(a, i) {
  var e, t = i.d.length;
  if (t < 3)
    return i.isZero() ? i : Nr(a, 2, i, i);
  e = 1.4 * Math.sqrt(t), e = e > 16 ? 16 : e | 0, i = i.times(1 / ss(5, e)), i = Nr(a, 2, i, i);
  for (var r, n = new a(5), s = new a(16), o = new a(20); e--; )
    r = i.times(i), i = i.times(n.plus(r.times(s.times(r).minus(o))));
  return i;
}
function Nr(a, i, e, t, r) {
  var n, s, o, u, c = a.precision, l = Math.ceil(c / se);
  for (ue = !1, u = e.times(e), o = new a(t); ; ) {
    if (s = Oe(o.times(u), new a(i++ * i++), c, 1), o = r ? t.plus(s) : t.minus(s), t = Oe(s.times(u), new a(i++ * i++), c, 1), s = o.plus(t), s.d[l] !== void 0) {
      for (n = l; s.d[n] === o.d[n] && n--; ) ;
      if (n == -1) break;
    }
    n = o, o = t, t = s, s = n;
  }
  return ue = !0, s.d.length = l + 1, s;
}
function ss(a, i) {
  for (var e = a; --i; ) e *= a;
  return e;
}
function Wo(a, i) {
  var e, t = i.s < 0, r = bt(a, a.precision, 1), n = r.times(0.5);
  if (i = i.abs(), i.lte(n))
    return Lt = t ? 4 : 1, i;
  if (e = i.divToInt(r), e.isZero())
    Lt = t ? 3 : 2;
  else {
    if (i = i.minus(e.times(r)), i.lte(n))
      return Lt = Di(e) ? t ? 2 : 3 : t ? 4 : 1, i;
    Lt = Di(e) ? t ? 1 : 4 : t ? 3 : 2;
  }
  return i.minus(r).abs();
}
function Oa(a, i, e, t) {
  var r, n, s, o, u, c, l, f, m, d = a.constructor, _ = e !== void 0;
  if (_ ? (Qe(e, 1, qt), t === void 0 ? t = d.rounding : Qe(t, 0, 8)) : (e = d.precision, t = d.rounding), !a.isFinite())
    l = Go(a);
  else {
    for (l = pt(a), s = l.indexOf("."), _ ? (r = 2, i == 16 ? e = e * 4 - 3 : i == 8 && (e = e * 3 - 2)) : r = i, s >= 0 && (l = l.replace(".", ""), m = new d(1), m.e = l.length - s, m.d = Rn(pt(m), 10, r), m.e = m.d.length), f = Rn(l, 10, r), n = u = f.length; f[--u] == 0; ) f.pop();
    if (!f[0])
      l = _ ? "0p+0" : "0";
    else {
      if (s < 0 ? n-- : (a = new d(a), a.d = f, a.e = n, a = Oe(a, m, e, t, 0, r), f = a.d, n = a.e, c = To), s = f[e], o = r / 2, c = c || f[e + 1] !== void 0, c = t < 4 ? (s !== void 0 || c) && (t === 0 || t === (a.s < 0 ? 3 : 2)) : s > o || s === o && (t === 4 || c || t === 6 && f[e - 1] & 1 || t === (a.s < 0 ? 8 : 7)), f.length = e, c)
        for (; ++f[--e] > r - 1; )
          f[e] = 0, e || (++n, f.unshift(1));
      for (u = f.length; !f[u - 1]; --u) ;
      for (s = 0, l = ""; s < u; s++) l += Xs.charAt(f[s]);
      if (_) {
        if (u > 1)
          if (i == 16 || i == 8) {
            for (s = i == 16 ? 4 : 3, --u; u % s; u++) l += "0";
            for (f = Rn(l, r, i), u = f.length; !f[u - 1]; --u) ;
            for (s = 1, l = "1."; s < u; s++) l += Xs.charAt(f[s]);
          } else
            l = l.charAt(0) + "." + l.slice(1);
        l = l + (n < 0 ? "p" : "p+") + n;
      } else if (n < 0) {
        for (; ++n; ) l = "0" + l;
        l = "0." + l;
      } else if (++n > u) for (n -= u; n--; ) l += "0";
      else n < u && (l = l.slice(0, n) + "." + l.slice(n));
    }
    l = (i == 16 ? "0x" : i == 2 ? "0b" : i == 8 ? "0o" : "") + l;
  }
  return a.s < 0 ? "-" + l : l;
}
function wi(a, i) {
  if (a.length > i)
    return a.length = i, !0;
}
function pf(a) {
  return new this(a).abs();
}
function Nf(a) {
  return new this(a).acos();
}
function Vf(a) {
  return new this(a).acosh();
}
function Of(a, i) {
  return new this(a).plus(i);
}
function Sf(a) {
  return new this(a).asin();
}
function Mf(a) {
  return new this(a).asinh();
}
function Df(a) {
  return new this(a).atan();
}
function wf(a) {
  return new this(a).atanh();
}
function Lf(a, i) {
  a = new this(a), i = new this(i);
  var e, t = this.precision, r = this.rounding, n = t + 4;
  return !a.s || !i.s ? e = new this(NaN) : !a.d && !i.d ? (e = bt(this, n, 1).times(i.s > 0 ? 0.25 : 0.75), e.s = a.s) : !i.d || a.isZero() ? (e = i.s < 0 ? bt(this, t, r) : new this(0), e.s = a.s) : !a.d || i.isZero() ? (e = bt(this, n, 1).times(0.5), e.s = a.s) : i.s < 0 ? (this.precision = n, this.rounding = 1, e = this.atan(Oe(a, i, n, 1)), i = bt(this, n, 1), this.precision = t, this.rounding = r, e = a.s < 0 ? e.minus(i) : e.plus(i)) : e = this.atan(Oe(a, i, n, 1)), e;
}
function Pf(a) {
  return new this(a).cbrt();
}
function xf(a) {
  return te(a = new this(a), a.e + 1, 2);
}
function jf(a, i, e) {
  return new this(a).clamp(i, e);
}
function Uf(a) {
  if (!a || typeof a != "object") throw Error(rs + "Object expected");
  var i, e, t, r = a.defaults === !0, n = [
    "precision",
    1,
    qt,
    "rounding",
    0,
    8,
    "toExpNeg",
    -dr,
    0,
    "toExpPos",
    0,
    dr,
    "maxE",
    0,
    dr,
    "minE",
    -dr,
    0,
    "modulo",
    0,
    9
  ];
  for (i = 0; i < n.length; i += 3)
    if (e = n[i], r && (this[e] = Ks[e]), (t = a[e]) !== void 0)
      if ($e(t) === t && t >= n[i + 1] && t <= n[i + 2]) this[e] = t;
      else throw Error(Ht + e + ": " + t);
  if (e = "crypto", r && (this[e] = Ks[e]), (t = a[e]) !== void 0)
    if (t === !0 || t === !1 || t === 0 || t === 1)
      if (t)
        if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
          this[e] = !0;
        else
          throw Error(Bo);
      else
        this[e] = !1;
    else
      throw Error(Ht + e + ": " + t);
  return this;
}
function vf(a) {
  return new this(a).cos();
}
function Tf(a) {
  return new this(a).cosh();
}
function Qo(a) {
  var i, e, t;
  function r(n) {
    var s, o, u, c = this;
    if (!(c instanceof r)) return new r(n);
    if (c.constructor = r, Li(n)) {
      c.s = n.s, ue ? !n.d || n.e > r.maxE ? (c.e = NaN, c.d = null) : n.e < r.minE ? (c.e = 0, c.d = [0]) : (c.e = n.e, c.d = n.d.slice()) : (c.e = n.e, c.d = n.d ? n.d.slice() : n.d);
      return;
    }
    if (u = typeof n, u === "number") {
      if (n === 0) {
        c.s = 1 / n < 0 ? -1 : 1, c.e = 0, c.d = [0];
        return;
      }
      if (n < 0 ? (n = -n, c.s = -1) : c.s = 1, n === ~~n && n < 1e7) {
        for (s = 0, o = n; o >= 10; o /= 10) s++;
        ue ? s > r.maxE ? (c.e = NaN, c.d = null) : s < r.minE ? (c.e = 0, c.d = [0]) : (c.e = s, c.d = [n]) : (c.e = s, c.d = [n]);
        return;
      }
      if (n * 0 !== 0) {
        n || (c.s = NaN), c.e = NaN, c.d = null;
        return;
      }
      return bn(c, n.toString());
    }
    if (u === "string")
      return (o = n.charCodeAt(0)) === 45 ? (n = n.slice(1), c.s = -1) : (o === 43 && (n = n.slice(1)), c.s = 1), ko.test(n) ? bn(c, n) : bf(c, n);
    if (u === "bigint")
      return n < 0 ? (n = -n, c.s = -1) : c.s = 1, bn(c, n.toString());
    throw Error(Ht + n);
  }
  if (r.prototype = B, r.ROUND_UP = 0, r.ROUND_DOWN = 1, r.ROUND_CEIL = 2, r.ROUND_FLOOR = 3, r.ROUND_HALF_UP = 4, r.ROUND_HALF_DOWN = 5, r.ROUND_HALF_EVEN = 6, r.ROUND_HALF_CEIL = 7, r.ROUND_HALF_FLOOR = 8, r.EUCLID = 9, r.config = r.set = Uf, r.clone = Qo, r.isDecimal = Li, r.abs = pf, r.acos = Nf, r.acosh = Vf, r.add = Of, r.asin = Sf, r.asinh = Mf, r.atan = Df, r.atanh = wf, r.atan2 = Lf, r.cbrt = Pf, r.ceil = xf, r.clamp = jf, r.cos = vf, r.cosh = Tf, r.div = If, r.exp = Bf, r.floor = Ff, r.hypot = kf, r.ln = $f, r.log = Yf, r.log10 = Gf, r.log2 = Hf, r.max = Wf, r.min = Qf, r.mod = qf, r.mul = Xf, r.pow = Kf, r.random = Zf, r.round = zf, r.sign = Jf, r.sin = em, r.sinh = tm, r.sqrt = rm, r.sub = nm, r.sum = sm, r.tan = am, r.tanh = im, r.trunc = om, a === void 0 && (a = {}), a && a.defaults !== !0)
    for (t = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], i = 0; i < t.length; ) a.hasOwnProperty(e = t[i++]) || (a[e] = this[e]);
  return r.config(a), r;
}
function If(a, i) {
  return new this(a).div(i);
}
function Bf(a) {
  return new this(a).exp();
}
function Ff(a) {
  return te(a = new this(a), a.e + 1, 3);
}
function kf() {
  var a, i, e = new this(0);
  for (ue = !1, a = 0; a < arguments.length; )
    if (i = new this(arguments[a++]), i.d)
      e.d && (e = e.plus(i.times(i)));
    else {
      if (i.s)
        return ue = !0, new this(1 / 0);
      e = i;
    }
  return ue = !0, e.sqrt();
}
function Li(a) {
  return a instanceof x || a && a.toStringTag === Fo || !1;
}
function $f(a) {
  return new this(a).ln();
}
function Yf(a, i) {
  return new this(a).log(i);
}
function Hf(a) {
  return new this(a).log(2);
}
function Gf(a) {
  return new this(a).log(10);
}
function Wf() {
  return Ho(this, arguments, -1);
}
function Qf() {
  return Ho(this, arguments, 1);
}
function qf(a, i) {
  return new this(a).mod(i);
}
function Xf(a, i) {
  return new this(a).mul(i);
}
function Kf(a, i) {
  return new this(a).pow(i);
}
function Zf(a) {
  var i, e, t, r, n = 0, s = new this(1), o = [];
  if (a === void 0 ? a = this.precision : Qe(a, 1, qt), t = Math.ceil(a / se), this.crypto)
    if (crypto.getRandomValues)
      for (i = crypto.getRandomValues(new Uint32Array(t)); n < t; )
        r = i[n], r >= 429e7 ? i[n] = crypto.getRandomValues(new Uint32Array(1))[0] : o[n++] = r % 1e7;
    else if (crypto.randomBytes) {
      for (i = crypto.randomBytes(t *= 4); n < t; )
        r = i[n] + (i[n + 1] << 8) + (i[n + 2] << 16) + ((i[n + 3] & 127) << 24), r >= 214e7 ? crypto.randomBytes(4).copy(i, n) : (o.push(r % 1e7), n += 4);
      n = t / 4;
    } else
      throw Error(Bo);
  else for (; n < t; ) o[n++] = Math.random() * 1e7 | 0;
  for (t = o[--n], a %= se, t && a && (r = je(10, se - a), o[n] = (t / r | 0) * r); o[n] === 0; n--) o.pop();
  if (n < 0)
    e = 0, o = [0];
  else {
    for (e = -1; o[0] === 0; e -= se) o.shift();
    for (t = 1, r = o[0]; r >= 10; r /= 10) t++;
    t < se && (e -= se - t);
  }
  return s.e = e, s.d = o, s;
}
function zf(a) {
  return te(a = new this(a), a.e + 1, this.rounding);
}
function Jf(a) {
  return a = new this(a), a.d ? a.d[0] ? a.s : 0 * a.s : a.s || NaN;
}
function em(a) {
  return new this(a).sin();
}
function tm(a) {
  return new this(a).sinh();
}
function rm(a) {
  return new this(a).sqrt();
}
function nm(a, i) {
  return new this(a).sub(i);
}
function sm() {
  var a = 0, i = arguments, e = new this(i[a]);
  for (ue = !1; e.s && ++a < i.length; ) e = e.plus(i[a]);
  return ue = !0, te(e, this.precision, this.rounding);
}
function am(a) {
  return new this(a).tan();
}
function im(a) {
  return new this(a).tanh();
}
function om(a) {
  return te(a = new this(a), a.e + 1, 1);
}
B[Symbol.for("nodejs.util.inspect.custom")] = B.toString;
B[Symbol.toStringTag] = "Decimal";
var x = B.constructor = Qo(Ks);
wn = new x(wn);
Ln = new x(Ln);
function um(a, i) {
  const e = a + i;
  return Number.isSafeInteger(e) ? e : new x(a).add(i).toNumber();
}
function cm(a, i) {
  const e = a - i;
  return Number.isSafeInteger(e) ? e : new x(a).sub(i).toNumber();
}
function xr(a, i) {
  const e = a * i;
  return Number.isSafeInteger(e) ? e : new x(a).mul(i).toNumber();
}
function lm(a, i) {
  const e = a / i;
  return Number.isSafeInteger(e) ? e : new x(a).div(i).toNumber();
}
function kt(a, i) {
  const e = 10 ** Math.trunc(i), t = as(a, e);
  return Math.round(xr(a, e) + t) / e;
}
function Ze(a, i) {
  const e = 10 ** Math.trunc(i), t = as(a, e);
  return Math.floor(xr(a, e) + t) / e;
}
function We(a, i) {
  const e = 10 ** Math.trunc(i), t = as(a, e);
  return Math.ceil(xr(a, e) - t) / e;
}
function as(a, i) {
  return Number.EPSILON * Math.max(1, Math.abs(xr(a, i)));
}
function Pi(a, i) {
  return a - i * Math.floor(a / i);
}
function fm(a, i) {
  return a ** i;
}
function mm(a) {
  return Math.sqrt(a);
}
function xi(a, i) {
  return a === i;
}
function hm(a, i) {
  return a > i;
}
function gm(a, i) {
  return a >= i;
}
function dm(a, i) {
  return a < i;
}
function Cm(a, i) {
  return a <= i;
}
function ji(a, i = 15) {
  return Math.floor(Math.abs(a)).toString().length >= i ? a : Number.parseFloat(a.toPrecision(i));
}
function _m(a, i, e = Number.EPSILON) {
  return Math.abs(a - i) < e;
}
function Sa(a, i = 12, e = 1e-10) {
  const t = ji(a, i);
  return _m(a, t, e) ? t : ji(a);
}
function Am(a) {
  return a - Math.trunc(a);
}
const zn = class zn extends Qt {
  static create() {
    return this._instance = this._instance || new zn(0), this._instance;
  }
  isNull() {
    return !0;
  }
  plus(i) {
    return y.create(0).plus(i);
  }
  minus(i) {
    return y.create(0).minus(i);
  }
  multiply(i) {
    return y.create(0).multiply(i);
  }
  divided(i) {
    return y.create(0).divided(i);
  }
  mod(i) {
    return y.create(0).mod(i);
  }
  compare(i, e) {
    return i.isString() ? U.create("").compare(i, e) : i.isBoolean() ? T.create(!1).compare(i, e) : y.create(0).compare(i, e);
  }
  concatenateFront(i) {
    return i.isArray() ? i.concatenateBack(U.create("")) : U.create(this.concatenate(i.getValue(), ft.FRONT));
  }
  concatenateBack(i) {
    return i.isArray() ? i.concatenateFront(U.create("")) : U.create(this.concatenate(i.getValue(), ft.BACK));
  }
  plusBy(i) {
    return y.create(0).plusBy(i);
  }
  minusBy(i) {
    return y.create(0).minusBy(i);
  }
  multiplyBy(i) {
    return y.create(0).multiplyBy(i);
  }
  dividedBy(i) {
    return y.create(0).dividedBy(i);
  }
  compareBy(i, e) {
    return typeof i == "string" ? U.create("").compareBy(i, e) : typeof i == "boolean" ? T.create(!1).compareBy(i, e) : y.create(0).compareBy(i, e);
  }
  pow(i) {
    return y.create(0).pow(i);
  }
  sqrt() {
    return y.create(0).sqrt();
  }
  cbrt() {
    return y.create(0).cbrt();
  }
  cos() {
    return y.create(0).cos();
  }
  cosh() {
    return y.create(0).cosh();
  }
  acos() {
    return y.create(0).acos();
  }
  acosh() {
    return y.create(0).acosh();
  }
  sin() {
    return y.create(0).sin();
  }
  sinh() {
    return y.create(0).sinh();
  }
  asin() {
    return y.create(0).asin();
  }
  asinh() {
    return y.create(0).asinh();
  }
  tan() {
    return y.create(0).tan();
  }
  tanh() {
    return y.create(0).tanh();
  }
  atan() {
    return y.create(0).atan();
  }
  atan2(i) {
    return y.create(0).atan2(i);
  }
  atanh() {
    return y.create(0).atanh();
  }
  log() {
    return g.create(h.NUM);
  }
  log10() {
    return g.create(h.NUM);
  }
  exp() {
    return y.create(0).exp();
  }
  abs() {
    return y.create(0).abs();
  }
  round(i) {
    return y.create(0).round(i);
  }
  floor(i) {
    return y.create(0).floor(i);
  }
  ceil(i) {
    return y.create(0).ceil(i);
  }
  convertToNumberObjectValue() {
    return y.create(0);
  }
  convertToBooleanObjectValue() {
    return T.create(!1);
  }
};
A(zn, "_instance");
let ce = zn;
const Jt = class Jt extends Qt {
  constructor(e) {
    super(e);
    A(this, "_value", !1);
    this._value = e;
  }
  static create(e) {
    return e ? (this._instanceTrue = this._instanceTrue || new Jt(!0), this._instanceTrue) : (this._instanceFalse = this._instanceFalse || new Jt(!1), this._instanceFalse);
  }
  getValue() {
    return this._value;
  }
  isBoolean() {
    return !0;
  }
  getNegative() {
    const e = this.getValue();
    let t = 0;
    return e && (t = 1), y.create(-t);
  }
  getReciprocal() {
    return this.getValue() ? y.create(1) : g.create(h.DIV_BY_ZERO);
  }
  plus(e) {
    return this._convertToNumber().plus(e);
  }
  minus(e) {
    return this._convertToNumber().minus(e);
  }
  multiply(e) {
    return this._convertToNumber().multiply(e);
  }
  divided(e) {
    return this._convertToNumber().divided(e);
  }
  mod(e) {
    return this._convertToNumber().mod(e);
  }
  compare(e, t) {
    return e.isArray() ? e.compare(this, Va(t)) : e.isNull() ? this._convertToNumber().compare(e, t) : this.compareBy(e.getValue(), t);
  }
  compareBy(e, t) {
    let r = !1;
    if (typeof e == "string" || typeof e == "number")
      r = this._compareString(t);
    else if (typeof e == "boolean") {
      const n = y.create(e ? 1 : 0);
      return this._convertToNumber().compare(n, t);
    }
    return Jt.create(r);
  }
  _compareString(e) {
    switch (e) {
      case Y.GREATER_THAN:
      case Y.GREATER_THAN_OR_EQUAL:
        return !0;
      case Y.EQUALS:
      case Y.LESS_THAN:
      case Y.LESS_THAN_OR_EQUAL:
      case Y.NOT_EQUAL:
        return !1;
    }
  }
  concatenateFront(e) {
    return this._convertToNumber().concatenateFront(e);
  }
  concatenateBack(e) {
    return this._convertToNumber().concatenateBack(e);
  }
  _convertToNumber() {
    const e = this.getValue();
    let t = 0;
    return e && (t = 1), y.create(t);
  }
  pow(e) {
    return this._convertToNumber().pow(e);
  }
  sqrt() {
    return this._convertToNumber().sqrt();
  }
  cbrt() {
    return this._convertToNumber().cbrt();
  }
  cos() {
    return this._convertToNumber().cos();
  }
  cosh() {
    return this._convertToNumber().cosh();
  }
  acos() {
    return this._convertToNumber().acos();
  }
  acosh() {
    return this._convertToNumber().acosh();
  }
  sin() {
    return this._convertToNumber().sin();
  }
  sinh() {
    return this._convertToNumber().sinh();
  }
  asin() {
    return this._convertToNumber().asin();
  }
  asinh() {
    return this._convertToNumber().asinh();
  }
  tan() {
    return this._convertToNumber().tan();
  }
  tanh() {
    return this._convertToNumber().tanh();
  }
  atan() {
    return this._convertToNumber().atan();
  }
  atan2(e) {
    return this._convertToNumber().atan2(e);
  }
  atanh() {
    return this._convertToNumber().atanh();
  }
  log() {
    return this._convertToNumber().log();
  }
  log10() {
    return this._convertToNumber().log10();
  }
  exp() {
    return this._convertToNumber().exp();
  }
  abs() {
    return this._convertToNumber().abs();
  }
  round(e) {
    return this._convertToNumber().round(e);
  }
  floor(e) {
    return this._convertToNumber().floor(e);
  }
  ceil(e) {
    return this._convertToNumber().ceil(e);
  }
  convertToNumberObjectValue() {
    return Yr(this.getValue());
  }
  convertToBooleanObjectValue() {
    return this;
  }
};
A(Jt, "_instanceTrue"), A(Jt, "_instanceFalse");
let T = Jt;
class y extends Qt {
  constructor(e) {
    super(e);
    A(this, "_value", 0);
    this._value = Number(e);
  }
  static create(e, t = "") {
    const r = new y(e);
    return t && r.setPattern(t), r;
  }
  getValue() {
    return this._value;
  }
  setValue(e) {
    this._value = e;
  }
  isNumber() {
    return !0;
  }
  getNegative() {
    return y.create(0).minus(this);
  }
  getReciprocal() {
    return y.create(1).divided(this);
  }
  plus(e) {
    if (e.isArray())
      return e.plus(this);
    let t = e;
    e.isNumber() || (t = e.convertToNumberObjectValue());
    let r = this.plusBy(t.getValue());
    if (r.isError())
      return r;
    const n = on(this.getPattern(), t.getPattern(), Z.PLUS);
    return r = y.create(Number(r.getValue()), n), r;
  }
  equalZero() {
    return this._value === 0;
  }
  minus(e) {
    if (e.isArray()) {
      const s = e.getNegative();
      return s.isError() ? s : s.plus(this);
    }
    let t = e;
    e.isNumber() || (t = e.convertToNumberObjectValue());
    let r = this.minusBy(t.getValue());
    if (r.isError())
      return r;
    const n = on(this.getPattern(), t.getPattern(), Z.MINUS);
    return r = y.create(Number(r.getValue()), n), r;
  }
  multiply(e) {
    if (e.isArray())
      return e.multiply(this);
    let t = e;
    e.isNumber() || (t = e.convertToNumberObjectValue());
    let r = this.multiplyBy(t.getValue());
    if (r.isError())
      return r;
    const n = on(this.getPattern(), t.getPattern(), Z.MULTIPLY);
    return r = y.create(Number(r.getValue()), n), r;
  }
  divided(e) {
    if (e.isArray()) {
      const s = e.getReciprocal();
      return s.isError() ? s : s.multiply(this);
    }
    let t = e;
    e.isNumber() || (t = e.convertToNumberObjectValue());
    let r = this.dividedBy(t.getValue());
    if (r.isError())
      return r;
    const n = on(this.getPattern(), t.getPattern(), Z.DIVIDED);
    return r = y.create(Number(r.getValue()), n), r;
  }
  mod(e) {
    if (e.isArray())
      return e.modInverse(this);
    const t = this.getValue(), r = e.getValue();
    if (e.isNull())
      return g.create(h.DIV_BY_ZERO);
    if (typeof r == "string")
      return g.create(h.VALUE);
    if (typeof r == "number") {
      if (r === 0)
        return g.create(h.DIV_BY_ZERO);
      if (!Number.isFinite(t) || !Number.isFinite(r) || Math.abs(r) * 11259e8 <= Math.abs(t))
        return g.create(h.NUM);
      const n = Pi(t, r);
      return Number.isFinite(n) ? y.create(n) : g.create(h.NUM);
    }
    if (typeof r == "boolean") {
      const n = r ? 1 : 0;
      return n === 0 ? g.create(h.DIV_BY_ZERO) : y.create(Pi(t, n));
    }
    return this;
  }
  concatenateFront(e) {
    return e.isArray() ? e.concatenateBack(this) : U.create(this.concatenate(e.getValue(), ft.FRONT));
  }
  concatenateBack(e) {
    return e.isArray() ? e.concatenateFront(this) : U.create(this.concatenate(e.getValue(), ft.BACK));
  }
  isDateFormat() {
    const e = this.getPattern();
    return ht.isDateFormat(e);
  }
  compare(e, t) {
    if (e.isArray())
      return e.compare(this, Va(t));
    let r = !1;
    return e.isDateFormat() && this.isDateFormat() && (r = !0), this.compareBy(e.getValue(), t, r);
  }
  plusBy(e) {
    if (typeof e == "string" && e.trim() === "")
      return g.create(h.VALUE);
    const t = +this.getValue(), r = +e;
    if (Number.isNaN(t) || Number.isNaN(r))
      return g.create(h.VALUE);
    if (!Number.isFinite(t) || !Number.isFinite(r))
      return g.create(h.NUM);
    const n = um(t, r);
    return Number.isFinite(n) ? y.create(n) : g.create(h.NUM);
  }
  minusBy(e) {
    if (typeof e == "string" && e.trim() === "")
      return g.create(h.VALUE);
    const t = +this.getValue(), r = +e;
    if (Number.isNaN(t) || Number.isNaN(r))
      return g.create(h.VALUE);
    if (!Number.isFinite(t) || !Number.isFinite(r))
      return g.create(h.NUM);
    const n = cm(t, r);
    return Number.isFinite(n) ? y.create(n) : g.create(h.NUM);
  }
  multiplyBy(e) {
    if (typeof e == "string" && e.trim() === "")
      return g.create(h.VALUE);
    const t = +this.getValue(), r = +e;
    if (Number.isNaN(t) || Number.isNaN(r))
      return g.create(h.VALUE);
    if (!Number.isFinite(t) || !Number.isFinite(r))
      return g.create(h.NUM);
    const n = xr(t, r);
    return Number.isFinite(n) ? y.create(n) : g.create(h.NUM);
  }
  dividedBy(e) {
    if (typeof e == "string" && e.trim() === "")
      return g.create(h.VALUE);
    const t = +this.getValue(), r = +e;
    if (Number.isNaN(t) || Number.isNaN(r))
      return g.create(h.VALUE);
    if (!Number.isFinite(t) || !Number.isFinite(r))
      return g.create(h.NUM);
    if (r === 0)
      return g.create(h.DIV_BY_ZERO);
    const n = lm(t, r);
    return Number.isFinite(n) ? y.create(n) : g.create(h.NUM);
  }
  compareBy(e, t, r = !1) {
    const n = this.getValue();
    let s = !1, o = n, u = e;
    return r && (o = Math.round(n * 1e8) / 1e8, u = Math.round(e * 1e8) / 1e8), typeof u == "string" ? s = this._compareString(t) : typeof u == "number" ? s = this._compareNumber(o, u, t) : typeof u == "boolean" && (s = this._compareBoolean(t)), T.create(s);
  }
  _compareString(e) {
    switch (e) {
      case Y.EQUALS:
      case Y.GREATER_THAN:
      case Y.GREATER_THAN_OR_EQUAL:
        return !1;
      case Y.LESS_THAN:
      case Y.LESS_THAN_OR_EQUAL:
      case Y.NOT_EQUAL:
        return !0;
    }
  }
  _compareNumber(e, t, r) {
    return !Number.isFinite(e) || !Number.isFinite(t) ? this._compareInfinity(e, t, r) : this._compareFiniteNumber(e, t, r);
  }
  _compareFiniteNumber(e, t, r) {
    switch (r) {
      case Y.EQUALS:
        return xi(e, t);
      case Y.GREATER_THAN:
        return hm(e, t);
      case Y.GREATER_THAN_OR_EQUAL:
        return gm(e, t);
      case Y.LESS_THAN:
        return dm(e, t);
      case Y.LESS_THAN_OR_EQUAL:
        return Cm(e, t);
      case Y.NOT_EQUAL:
        return !xi(e, t);
    }
  }
  _compareBoolean(e) {
    switch (e) {
      case Y.EQUALS:
      case Y.GREATER_THAN:
      case Y.GREATER_THAN_OR_EQUAL:
        return !1;
      case Y.LESS_THAN:
      case Y.LESS_THAN_OR_EQUAL:
      case Y.NOT_EQUAL:
        return !0;
    }
  }
  pow(e) {
    if (e.isArray())
      return e.powInverse(this);
    if (this.isError())
      return this;
    const t = this.getValue();
    let r = e;
    if (e.isString() && (r = e.convertToNumberObjectValue()), r.isError())
      return r;
    const n = +r.getValue();
    if (Number.isNaN(n))
      return g.create(h.VALUE);
    if (!Number.isFinite(t) || !Number.isFinite(n))
      return g.create(h.NUM);
    if (t === 0)
      return n < 0 ? g.create(h.DIV_BY_ZERO) : n === 0 ? g.create(h.NUM) : y.create(0);
    const s = fm(t, n);
    return Number.isFinite(s) ? y.create(s) : g.create(h.NUM);
  }
  sqrt() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(h.NUM);
    const t = mm(e);
    return Number.isFinite(t) ? y.create(t) : g.create(h.NUM);
  }
  cbrt() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(h.NUM);
    const t = Math.cbrt(e);
    return Number.isFinite(t) ? y.create(t) : g.create(h.NUM);
  }
  cos() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(h.NUM);
    const t = Math.cos(e);
    return Number.isFinite(t) ? y.create(t) : g.create(h.NUM);
  }
  cosh() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(h.NUM);
    const t = Math.cosh(e);
    return Number.isFinite(t) ? y.create(t) : g.create(h.NUM);
  }
  acos() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(h.NUM);
    const t = Math.acos(e);
    return Number.isNaN(t) ? g.create(h.NUM) : y.create(t);
  }
  acosh() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(h.NUM);
    const t = Math.acosh(e);
    return Number.isNaN(t) ? g.create(h.NUM) : y.create(t);
  }
  sin() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(h.NUM);
    const t = Math.sin(e);
    return Number.isFinite(t) ? y.create(t) : g.create(h.NUM);
  }
  sinh() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(h.NUM);
    const t = Math.sinh(e);
    return Number.isFinite(t) ? y.create(t) : g.create(h.NUM);
  }
  asin() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(h.NUM);
    const t = Math.asin(e);
    return Number.isNaN(t) ? g.create(h.NUM) : y.create(t);
  }
  asinh() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(h.NUM);
    const t = Math.asinh(e);
    return Number.isNaN(t) ? g.create(h.NUM) : y.create(t);
  }
  tan() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(h.NUM);
    const t = Math.tan(e);
    return Number.isFinite(t) ? y.create(t) : g.create(h.NUM);
  }
  tanh() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(h.NUM);
    const t = Math.tanh(e);
    return Number.isFinite(t) ? y.create(t) : g.create(h.NUM);
  }
  atan() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(h.NUM);
    const t = Math.atan(e);
    return Number.isFinite(t) ? y.create(t) : g.create(h.NUM);
  }
  atan2(e) {
    if (e.isArray())
      return e.atan2Inverse(this);
    const t = this.getValue(), r = e.getValue();
    if (typeof r == "string")
      return g.create(h.VALUE);
    if (typeof r == "number") {
      if (!Number.isFinite(t) || !Number.isFinite(r))
        return g.create(h.NUM);
      if (t === 0 && r === 0)
        return g.create(h.DIV_BY_ZERO);
      const n = Math.atan2(t, r);
      return Number.isFinite(n) ? y.create(n) : g.create(h.NUM);
    }
    return typeof r == "boolean" ? y.create(Math.atan2(t, r ? 1 : 0)) : this;
  }
  atanh() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(h.NUM);
    const t = Math.atanh(e);
    return Number.isFinite(t) ? y.create(t) : g.create(h.NUM);
  }
  log() {
    const e = this.getValue();
    if (typeof e == "number" && e <= 0 || !Number.isFinite(e))
      return g.create(h.NUM);
    const t = Math.log(e);
    return Number.isFinite(t) ? y.create(t) : g.create(h.NUM);
  }
  log10() {
    const e = this.getValue();
    if (typeof e == "number" && e <= 0 || !Number.isFinite(e))
      return g.create(h.NUM);
    const t = Math.log10(e);
    return Number.isFinite(t) ? y.create(t) : g.create(h.NUM);
  }
  exp() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(h.NUM);
    const t = Math.exp(e);
    return Number.isFinite(t) ? y.create(t) : g.create(h.NUM);
  }
  abs() {
    const e = this.getValue();
    if (!Number.isFinite(e))
      return g.create(h.NUM);
    const t = Math.abs(e);
    return Number.isFinite(t) ? y.create(t) : g.create(h.NUM);
  }
  round(e) {
    if (e.isArray())
      return e.roundInverse(this);
    const t = this.getValue(), r = e.getValue();
    if (typeof r == "string")
      return g.create(h.VALUE);
    if (typeof r == "number") {
      if (!Number.isFinite(t) || !Number.isFinite(r))
        return g.create(h.NUM);
      const n = t < 0 ? -kt(Math.abs(t), r) : kt(t, r);
      return Number.isFinite(n) ? y.create(n) : g.create(h.NUM);
    }
    return typeof r == "boolean" ? y.create(kt(t, r ? 1 : 0)) : this;
  }
  floor(e) {
    if (e.isArray())
      return e.floorInverse(this);
    const t = this.getValue(), r = e.getValue();
    if (typeof r == "string")
      return g.create(h.VALUE);
    if (typeof r == "number") {
      if (!Number.isFinite(t) || !Number.isFinite(r))
        return g.create(h.NUM);
      const n = t < 0 ? -Ze(Math.abs(t), r) : Ze(t, r);
      return Number.isFinite(n) ? y.create(n) : g.create(h.NUM);
    }
    return typeof r == "boolean" ? y.create(Ze(t, r ? 1 : 0)) : this;
  }
  ceil(e) {
    if (e.isArray())
      return e.ceilInverse(this);
    const t = this.getValue(), r = e.getValue();
    if (typeof r == "string")
      return g.create(h.VALUE);
    if (typeof r == "number") {
      if (!Number.isFinite(t) || !Number.isFinite(r))
        return g.create(h.NUM);
      const n = t < 0 ? -We(Math.abs(t), r) : We(t, r);
      return Number.isFinite(n) ? y.create(n) : g.create(h.NUM);
    }
    return typeof r == "boolean" ? y.create(We(t, r ? 1 : 0)) : this;
  }
  convertToNumberObjectValue() {
    return this;
  }
  convertToBooleanObjectValue() {
    return is(!0);
  }
  _compareInfinity(e, t, r) {
    let n = !1;
    switch (r) {
      case Y.EQUALS:
        n = e === t;
        break;
      case Y.GREATER_THAN:
        n = e > t;
        break;
      case Y.GREATER_THAN_OR_EQUAL:
        n = e >= t;
        break;
      case Y.LESS_THAN:
        n = e < t;
        break;
      case Y.LESS_THAN_OR_EQUAL:
        n = e <= t;
        break;
      case Y.NOT_EQUAL:
        n = e !== t;
        break;
    }
    return n;
  }
}
const Em = 1e5, Js = new xt(Em);
class U extends Qt {
  constructor(e) {
    super(e);
    A(this, "_value");
    A(this, "_isHyperlink", !1);
    A(this, "_hyperlinkUrl", "");
    A(this, "_isImage", !1);
    A(this, "_imageInfo");
    this._value = e;
  }
  static create(e, t) {
    var s;
    const r = Js.get(e);
    if (r && t && this.checkCacheByOptions(r, t))
      return r;
    const n = new U(e);
    return t != null && t.isHyperlink && (n._isHyperlink = t.isHyperlink, n._hyperlinkUrl = (s = t.hyperlinkUrl) != null ? s : ""), t != null && t.isImage && (n._isImage = t.isImage, n._imageInfo = t.imageInfo), Js.set(e, n), n;
  }
  static checkCacheByOptions(e, t) {
    return !(e.isHyperlink() !== t.isHyperlink || e.getHyperlinkUrl() !== t.hyperlinkUrl || e.isImage() !== t.isImage || !Ge.diffValue(e.getImageInfo(), t.imageInfo));
  }
  getValue() {
    return this._value;
  }
  isString() {
    return !0;
  }
  isHyperlink() {
    return this._isHyperlink;
  }
  getHyperlinkUrl() {
    return this._hyperlinkUrl;
  }
  isImage() {
    return this._isImage;
  }
  getImageInfo() {
    return this._imageInfo;
  }
  concatenateFront(e) {
    return e.isArray() ? e.concatenateBack(this) : U.create(this.concatenate(e.getValue(), ft.FRONT));
  }
  concatenateBack(e) {
    return e.isArray() ? e.concatenateFront(this) : U.create(this.concatenate(e.getValue(), ft.BACK));
  }
  plus(e) {
    return this.convertToNumberObjectValue().plus(e);
  }
  minus(e) {
    return this.convertToNumberObjectValue().minus(e);
  }
  multiply(e) {
    return this.convertToNumberObjectValue().multiply(e);
  }
  divided(e) {
    return this.convertToNumberObjectValue().divided(e);
  }
  compare(e, t, r) {
    return e.isArray() ? e.compare(this, Va(t), r) : this.compareBy(e.getValue(), t, r);
  }
  compareBy(e, t, r = !1) {
    let n = this.getValue(), s = !1;
    if (typeof e == "string") {
      let o = e;
      if (r || (n = n.toLocaleLowerCase(), o = o.toLocaleLowerCase()), vo(o))
        return this._checkWildcard(o, t);
      s = this._compareString(n, o, t);
    } else typeof e == "number" ? s = this._compareNumber(t) : typeof e == "boolean" && (s = this._compareBoolean(t));
    return T.create(s);
  }
  _compareString(e, t, r) {
    switch (r) {
      case Y.EQUALS:
        return e === t;
      case Y.GREATER_THAN:
        return e > t;
      case Y.GREATER_THAN_OR_EQUAL:
        return e >= t;
      case Y.LESS_THAN:
        return e < t;
      case Y.LESS_THAN_OR_EQUAL:
        return e <= t;
      case Y.NOT_EQUAL:
        return e !== t;
    }
  }
  _compareNumber(e) {
    switch (e) {
      case Y.NOT_EQUAL:
      case Y.GREATER_THAN:
      case Y.GREATER_THAN_OR_EQUAL:
        return !0;
      case Y.EQUALS:
      case Y.LESS_THAN:
      case Y.LESS_THAN_OR_EQUAL:
        return !1;
    }
  }
  _compareBoolean(e) {
    switch (e) {
      case Y.EQUALS:
      case Y.GREATER_THAN:
      case Y.GREATER_THAN_OR_EQUAL:
        return !1;
      case Y.LESS_THAN:
      case Y.LESS_THAN_OR_EQUAL:
      case Y.NOT_EQUAL:
        return !0;
    }
  }
  convertToNumberObjectValue() {
    const e = this.getValue(), t = lo(e);
    return t && t.z ? Yr(t.v, t.z) : Yr(e);
  }
  convertToBooleanObjectValue() {
    return T.create(!0);
  }
  _checkWildcard(e, t) {
    const r = this.getValue().toLocaleLowerCase(), n = rf(r, e, t);
    return T.create(n);
  }
}
function is(a) {
  if (typeof a == "boolean")
    return T.create(a);
  let i = !1;
  if (typeof a == "string") {
    const e = a.toLocaleUpperCase();
    e === ir.TRUE ? i = !0 : e === ir.FALSE && (i = !1);
  } else
    a === 1 ? i = !0 : i = !1;
  return T.create(i);
}
function Rm(a) {
  let i = a.toString();
  return i.charAt(0) === '"' && i.charAt(i.length - 1) === '"' && (i = i.slice(1, -1), i = i.replace(/""/g, '"')), U.create(i);
}
function Yr(a, i = "") {
  if (typeof a == "boolean") {
    let e = 0;
    return a && (e = 1), y.create(e, i);
  } else {
    if (typeof a == "number")
      return Number.isFinite(a) ? y.create(a, i) : g.create(h.NUM);
    if (q(a))
      return y.create(Number(a), i);
  }
  return g.create(h.VALUE);
}
function bm(a) {
  return "";
}
function qo(a = [], i = !1) {
  const e = [];
  for (let t = 0; t < a.length; t++) {
    const r = a[t];
    e[t] == null && (e[t] = []);
    for (let n = 0; n < r.length; n++) {
      const s = r[n];
      e[t][n] = Pt.create(s, i);
    }
  }
  return e;
}
function ym(a = []) {
  const i = [];
  for (let e = 0; e < a.length; e++) {
    const t = a[e];
    i[e] == null && (i[e] = []);
    for (let r = 0; r < t.length; r++) {
      const n = t[r];
      n == null ? i[e][r] = null : n.isError() ? i[e][r] = n.getErrorType() : i[e][r] = n.getValue();
    }
  }
  return i;
}
class K extends Qt {
  constructor(e) {
    super(typeof e == "string" ? e : bm());
    A(this, "_values", []);
    A(this, "_rowCount", -1);
    A(this, "_columnCount", -1);
    A(this, "_unitId", "");
    A(this, "_sheetId", "");
    A(this, "_currentRow", -1);
    A(this, "_currentColumn", -1);
    A(this, "_sliceCache", /* @__PURE__ */ new Map());
    A(this, "_flattenCache");
    /**
     * The default value of the array, null values in comparison results support setting to false
     */
    A(this, "_defaultValue", null);
    A(this, "_flattenPosition");
    this._values = this._formatValue(e);
  }
  /**
   * Create an array value object based on the string or IArrayValueObject data.
   * @param rawValue
   * @returns
   */
  static create(e) {
    return new K(e);
  }
  /**
   * Create an array value object based on the array data.
   * @param array
   * @returns
   */
  static createByArray(e) {
    const r = {
      calculateValueList: qo(e),
      rowCount: e.length,
      columnCount: e[0].length || 0,
      unitId: "",
      sheetId: "",
      row: -1,
      column: -1
    };
    return new K(r);
  }
  dispose() {
    this._values = [], this._defaultValue = null, this._flattenPosition = null, this._clearCache();
  }
  clone() {
    return this.map((e) => e);
  }
  getRowCount() {
    return this._rowCount;
  }
  setRowCount(e) {
    this._rowCount = e;
  }
  getColumnCount() {
    return this._columnCount;
  }
  setColumnCount(e) {
    this._columnCount = e;
  }
  setCurrent(e, t) {
    this._currentRow = e, this._currentColumn = t;
  }
  setUnitId(e) {
    this._unitId = e;
  }
  getUnitId() {
    return this._unitId;
  }
  setSheetId(e) {
    this._sheetId = e;
  }
  getSheetId() {
    return this._sheetId;
  }
  getCurrentRow() {
    return this._currentRow;
  }
  getCurrentColumn() {
    return this._currentColumn;
  }
  getArrayValue() {
    return this._values;
  }
  setArrayValue(e) {
    this._clearCache(), this._values = e;
  }
  isArray() {
    return !0;
  }
  setDefaultValue(e) {
    this._defaultValue = e;
  }
  get(e, t) {
    var r;
    return ((r = this._values[e]) == null ? void 0 : r[t]) || this._defaultValue;
  }
  getRealValue(e, t) {
    const r = this._values[e];
    if (r == null)
      return null;
    const n = r[t];
    return n == null ? null : n;
  }
  getValueOrDefault(e, t) {
    return this.get(e, t) || this._defaultValue;
  }
  set(e, t, r) {
    if (e >= this._rowCount || t >= this._columnCount)
      throw new Error("Exceeding array bounds.");
    this._clearCache(), this._values[e][t] = r;
  }
  getRangePosition() {
    const t = this.getRowCount(), r = 0, n = this.getColumnCount();
    return {
      startRow: 0,
      endRow: t - 1,
      startColumn: r,
      endColumn: n - 1
    };
  }
  iterator(e) {
    var u;
    const { startRow: t, endRow: r, startColumn: n, endColumn: s } = this.getRangePosition(), o = this.getArrayValue();
    for (let c = t; c <= r; c++)
      for (let l = n; l <= s; l++)
        if (e(((u = o[c]) == null ? void 0 : u[l]) || this._defaultValue, c, l) === !1)
          return;
  }
  iteratorReverse(e) {
    var u;
    const { startRow: t, endRow: r, startColumn: n, endColumn: s } = this.getRangePosition(), o = this.getArrayValue();
    for (let c = r; c >= t; c--)
      for (let l = s; l >= n; l--)
        if (e(((u = o[c]) == null ? void 0 : u[l]) || this._defaultValue, c, l) === !1)
          return;
  }
  getLastTruePosition() {
    let e;
    return this.iteratorReverse((t, r, n) => {
      if (t != null && t.isBoolean() && t.getValue() === !0)
        return e = {
          row: r,
          column: n
        }, !1;
    }), e;
  }
  getFirstTruePosition() {
    let e;
    return this.iterator((t, r, n) => {
      if (t != null && t.isBoolean() && t.getValue() === !0)
        return e = {
          row: r,
          column: n
        }, !1;
    }), e;
  }
  getFirstCell() {
    const { startRow: e, startColumn: t } = this.getRangePosition();
    return this.get(e, t) || this._defaultValue || ce.create();
  }
  getLastCell() {
    const { endRow: e, endColumn: t } = this.getRangePosition();
    return this.get(e, t) || this._defaultValue || ce.create();
  }
  /**
   * Referring to matrix calculations,
   * extract the matching values from a true/false matrix based on parameters and store them in a two-dimensional array.
   * implement x[x<10]
   * https://numpy.org/doc/stable/user/basics.indexing.html
   * @param takeArray
   */
  pick(e) {
    const t = this.pickRaw(e);
    return this._createNewArray(t, 1, t[0].length);
  }
  pickRaw(e) {
    const t = e.getRowCount(), r = e.getColumnCount();
    if (t !== this._rowCount || r !== this._columnCount)
      return [[ce.create()]];
    const n = [];
    n[0] = [];
    for (let s = 0; s < t; s++)
      for (let o = 0; o < r; o++) {
        const u = e.get(s, o);
        if (!(u == null || u.isError()) && u.getValue() === !0) {
          const c = this.get(s, o);
          n[0].push(c);
        }
      }
    return n;
  }
  /**
   * Flatten a 2D array.
   * https://numpy.org/doc/stable/reference/generated/numpy.chararray.flatten.html#numpy.chararray.flatten
   */
  flatten() {
    if (this._flattenCache != null)
      return this._flattenCache;
    const e = [];
    e[0] = [];
    for (let r = 0; r < this._rowCount; r++)
      for (let n = 0; n < this._columnCount; n++) {
        const s = this.get(r, n);
        e[0].push(s);
      }
    const t = this._createNewArray(e, 1, e[0].length);
    return t.setDefaultValue(this._defaultValue), this._flattenCache = t, t;
  }
  /**
   * Flatten a 2D array.
   * In Excel, errors and blank cells are ignored, which results in a binary search that cannot strictly adhere to the number of cells.
   */
  flattenPosition() {
    if (this._flattenPosition != null)
      return this._flattenPosition;
    const e = [], t = [], r = [], n = [];
    let s = 0;
    for (let u = 0; u < this._rowCount; u++)
      for (let c = 0; c < this._columnCount; c++) {
        const l = this.get(u, c);
        if (l == null || l.isError() || l.isNull()) {
          s++;
          continue;
        }
        l.isString() ? (e.push(l), r.push(s++)) : (t.push(l), n.push(s++));
      }
    const o = {
      stringArray: e,
      numberArray: t,
      stringPosition: r,
      numberPosition: n
    };
    return this._flattenPosition = o, o;
  }
  /**
   * I'm looking to perform slicing operations on 2D arrays, similar to the functionality provided by NumPy.
   * https://numpy.org/doc/stable/user/basics.indexing.html
   * @rowParam start:stop:step
   * @columnParam start:stop:step
   * @param takeArray
   */
  slice(e, t) {
    let r = 0, n = this._rowCount, s = 1, o = 0, u = this._columnCount, c = 1;
    if (e != null && (r = e[0] || 0, n = e[1] || this._rowCount, s = e[2] || 1), t != null && (o = t[0] || 0, u = t[1] || this._columnCount, c = t[2] || 1), r >= this._rowCount || o >= this._columnCount)
      return;
    const l = `${r}_${n}_${s}_${o}_${u}_${c}`, f = this._sliceCache.get(l);
    if (f != null)
      return f;
    const m = [], d = this._values;
    let _ = 0, C = 0;
    for (let p = r; p < n; p += s) {
      C = 0, m[_] == null && (m[_] = []);
      for (let V = o; V < u; V += c) {
        if (!d[p])
          return;
        let S = d[p][V] || this._defaultValue;
        S == null && (S = ce.create()), m[_][C] = S, C++;
      }
      _++;
    }
    if (m.length === 0 || m[0].length === 0)
      return;
    const E = s > 1 ? -1 : r + this._currentRow, R = c > 1 ? -1 : o + this._currentColumn, b = this._createNewArray(m, m.length, m[0].length, E, R);
    return b.setDefaultValue(this._defaultValue), this._sliceCache.set(l, b), b;
  }
  sortByRow(e) {
    const t = this._transposeArray(this._values);
    t.sort(this._sort(e)), this._clearCache(), this._values = this._transposeArray(t);
  }
  sortByColumn(e) {
    this._clearCache(), this._values.sort(this._sort(e));
  }
  transpose() {
    const e = this._transposeArray(this._values), t = this._rowCount, r = this._columnCount, n = this._createNewArray(e, r, t);
    return n.setDefaultValue(this._defaultValue), n;
  }
  /**
   * Due to the inability to effectively utilize the cache,
   * the sequential matching approach is only used for special matches in XLOOKUP and XMATCH.
   * For example, when match_mode is set to 1 and -1 for an exact match. If not found, it returns the next smaller item.
   */
  orderSearch(e, t = xe.MIN, r = !1, n = !1) {
    let s, o, u, c;
    const l = (f, m, d) => {
      if (f == null || f.isNull())
        return !0;
      let _;
      if (n === !0 ? _ = f.compare(e, Y.EQUALS) : _ = f.isEqual(e), (_ == null ? void 0 : _.getValue()) === !0)
        return s = f, u = { row: m, column: d }, !1;
      t === xe.MAX ? f.isGreaterThan(e).getValue() === !0 && (o == null || f.minus(e).abs().isLessThanOrEqual(o.minus(e).abs()).getValue() === !0) && (o = f, c = { row: m, column: d }) : t === xe.MIN && f.isLessThan(e).getValue() === !0 && (o == null || f.minus(e).abs().isLessThanOrEqual(o.minus(e).abs()).getValue() === !0) && (o = f, c = { row: m, column: d });
    };
    if (r ? this.iteratorReverse((f, m, d) => l(f, m, d)) : this.iterator((f, m, d) => l(f, m, d)), s != null)
      return u;
    if (o != null)
      return c;
  }
  binarySearch(e, t = zt.MIN, r = xe.MIN) {
    if (e.isError())
      return;
    const { stringArray: n, stringPosition: s, numberArray: o, numberPosition: u } = this.flattenPosition();
    return e.isString() ? this._binarySearch(e, n, s, t, r) : this._binarySearch(e, o, u, t, r);
  }
  /**
   * searchType defaults to ascending order
   *
   * matchType defaults to the maximum value less than the search value, which is used for the default matching mode of VLOOKUP/LOOKUP/HLOOKUP.
   * @param valueObject
   * @param searchArray
   * @param positionArray
   * @param searchType
   * @param matchType
   * @returns
   */
  _binarySearch(e, t, r, n = zt.MIN, s = xe.MIN) {
    const o = Dn(), u = Number(e.getValue()), c = !Number.isNaN(u);
    let l = 0, f = t.length - 1, m = -1, d = -1, _ = -1;
    for (; l <= f; ) {
      const C = Math.floor((l + f) / 2), E = t[C];
      let R;
      if (E.isNull())
        R = n === zt.MIN ? 1 : -1;
      else {
        const b = E.getValue();
        if (c) {
          const p = Number(b);
          R = Number.isNaN(p) ? 1 : Math.sign(p - u);
        } else
          R = o(b.toString().toLocaleLowerCase(), e.getValue().toString().toLocaleLowerCase());
      }
      if (n === zt.MAX && (R = -R), R === 0) {
        m = C;
        break;
      }
      R < 0 ? (d = C, l = C + 1) : (_ = C, f = C - 1);
    }
    if (s === xe.NORMAL)
      return m !== -1 ? r[m] : void 0;
    if (s === xe.MIN)
      return m !== -1 ? r[m] : n === zt.MIN ? r[d] : r[_];
    if (s === xe.MAX)
      return m !== -1 ? r[m] : n === zt.MIN ? r[_] : r[d];
  }
  sum() {
    let e = y.create(0);
    return this.iterator((t) => {
      if (t == null || t.isString() || t.isBoolean() || t.isNull())
        return !0;
      if (t.isError())
        return e = t, !1;
      e = e.plus(
        t
      );
    }), e;
  }
  max() {
    let e = y.create(Number.NEGATIVE_INFINITY);
    return this.iterator((t) => {
      if (t == null)
        return !0;
      if (t.isError())
        return e = t, !1;
      if (t.isString() || t.isNull() || t.isBoolean())
        return !0;
      e.isLessThan(t).getValue() && (e = t);
    }), e;
  }
  min() {
    let e = y.create(Number.POSITIVE_INFINITY);
    return this.iterator((t) => {
      if (t == null)
        return !0;
      if (t.isError())
        return e = t, !1;
      if (t.isString() || t.isNull() || t.isBoolean())
        return !0;
      e.isGreaterThan(t).getValue() && (e = t);
    }), e;
  }
  count() {
    let e = y.create(0);
    return this.iterator((t) => {
      if (t == null || t.isError() || t.isString() || t.isNull() || t.isBoolean())
        return !0;
      e = e.plusBy(1);
    }), e;
  }
  countA() {
    let e = y.create(0);
    return this.iterator((t) => {
      if (t == null || t.isNull())
        return !0;
      e = e.plusBy(1);
    }), e;
  }
  countBlank() {
    let e = y.create(0);
    return this.iterator((t) => {
      (t == null || t.isNull() || t.getValue() === "") && (e = e.plusBy(1));
    }), e;
  }
  getNegative() {
    return K.create("{0}").minus(this);
  }
  getReciprocal() {
    return K.create("{1}").divided(this);
  }
  plus(e) {
    return this._batchOperator(
      e,
      1
      /* PLUS */
    );
  }
  minus(e) {
    return this._batchOperator(
      e,
      0
      /* MINUS */
    );
  }
  multiply(e) {
    return this._batchOperator(
      e,
      2
      /* MULTIPLY */
    );
  }
  divided(e) {
    return this._batchOperator(
      e,
      3
      /* DIVIDED */
    );
  }
  mod(e) {
    return this._batchOperator(
      e,
      4
      /* MOD */
    );
  }
  modInverse(e) {
    return this.map((t) => t.isError() ? t : e.mod(t));
  }
  compare(e, t, r) {
    return this._batchOperator(e, 5, t, r);
  }
  concatenateFront(e) {
    return this._batchOperator(
      e,
      6
      /* CONCATENATE_FRONT */
    );
  }
  concatenateBack(e) {
    return this._batchOperator(
      e,
      7
      /* CONCATENATE_BACK */
    );
  }
  map(e) {
    const t = (r, n, s) => r == null ? ce.create() : r.isError() ? r : e(r, n, s);
    return this.mapValue(t);
  }
  mapValue(e) {
    var s;
    const t = this._rowCount, r = this._columnCount, n = [];
    for (let o = 0; o < t; o++) {
      const u = [];
      for (let c = 0; c < r; c++) {
        const l = (s = this._values) == null ? void 0 : s[o];
        if (l == null)
          u[c] = g.create(h.VALUE);
        else {
          const f = l[c] || this._defaultValue;
          f ? u[c] = e(f, o, c) : u[c] = ce.create();
        }
      }
      n.push(u);
    }
    return this._createNewArray(n, t, r);
  }
  pow(e) {
    return this._batchOperator(
      e,
      8
      /* POW */
    );
  }
  /**
   *
   * @param valueObject In the case of an inverse, it is certainly not an array.
   * @returns
   */
  powInverse(e) {
    return this.map((t) => t.isError() ? t : e.pow(t));
  }
  sqrt() {
    return this.map((e) => e.isError() ? e : e.sqrt());
  }
  cbrt() {
    return this.map((e) => e.isError() ? e : e.cbrt());
  }
  cos() {
    return this.map((e) => e.isError() ? e : e.cos());
  }
  cosh() {
    return this.map((e) => e.isError() ? e : e.cosh());
  }
  acos() {
    return this.map((e) => e.isError() ? e : e.acos());
  }
  acosh() {
    return this.map((e) => e.isError() ? e : e.acosh());
  }
  sin() {
    return this.map((e) => e.isError() ? e : e.sin());
  }
  sinh() {
    return this.map((e) => e.isError() ? e : e.sinh());
  }
  asin() {
    return this.map((e) => e.isError() ? e : e.asin());
  }
  asinh() {
    return this.map((e) => e.isError() ? e : e.asinh());
  }
  tan() {
    return this.map((e) => e.isError() ? e : e.tan());
  }
  tanh() {
    return this.map((e) => e.isError() ? e : e.tanh());
  }
  atan() {
    return this.map((e) => e.isError() ? e : e.atan());
  }
  atanh() {
    return this.map((e) => e.isError() ? e : e.atanh());
  }
  atan2(e) {
    return this._batchOperator(
      e,
      12
      /* ATAN2 */
    );
  }
  atan2Inverse(e) {
    return this.map((t) => t.isError() ? t : e.atan2(t));
  }
  mean(e = 0) {
    const t = this.sum(), r = this.count();
    return t.divided(e === 0 ? r : r.minusBy(1));
  }
  /**
   * TODO: @DR-Univer
   * This calculation method contains an error, please note.
   * Please refer `getMedianResult` function in /engine-formula/src/basics/statistical.ts
   */
  median() {
    const e = this.flattenPosition().numberArray, t = this._createNewArray([e], 1, e.length), r = t.getColumnCount();
    if (r <= 1)
      return t.get(0, 0) || ce.create();
    if (t.sortByRow(0), r % 2 === 0) {
      const n = t.get(0, r / 2) || ce.create(), s = t.get(0, r / 2 - 1) || ce.create();
      return n.plus(s).divided(y.create(2));
    }
    return t.get(0, (r - 1) / 2) || ce.create();
  }
  /**
   * ┌──────────────┬────────────────────────────────┬───────────────────┐
   * │ Function     │ Ignore logical values and text │ Type              │
   * ├──────────────┼────────────────────────────────┼───────────────────┤
   * │ VAR.S (VAR)  │ TRUE                           │ sample            │
   * │ VAR.P (VARP) │ TRUE                           │ entire population │
   * │ VARA         │ FALSE                          │ sample            │
   * │ VARPA        │ FALSE                          │ entire population │
   * └──────────────┴────────────────────────────────┴───────────────────┘
   *
   * for VARPA and VARA, strings and FALSE are counted as 0, TRUE is counted as 1
   * for VAR.S/VAR, or VAR.P/VARP, strings,TRUE and FALSE are ignored
   * Since sum ignores strings and booleans, they are ignored here too, and VAR.S and VAR.P are used more
   *
   * VAR.S assumes that its arguments are a sample of the population, like numpy.var(data, ddof=1)
   * VAR.P assumes that its arguments are the entire population, like numpy.var(data, ddof=0)
   * numpy.var uses ddof=0 (Delta Degrees of Freedom) by default, so we use ddof=0 here
   *
   */
  var(e = 0) {
    const t = this.mean(), r = [[]];
    this.iterator((l) => {
      if (l == null || l.isError() || l.isString() || l.isBoolean() || l.isNull())
        return;
      const f = l.minus(t).pow(y.create(2));
      f.isError() || r[0].push(f);
    });
    const { _unitId: n, _sheetId: s, _currentRow: o, _currentColumn: u } = this;
    return K.create({
      calculateValueList: r,
      rowCount: 1,
      columnCount: r[0].length,
      unitId: n,
      sheetId: s,
      row: o,
      column: u
    }).mean(e);
  }
  /**
   * STDEV.P (STDEVP): ddof=0, ignore strings and booleans
   * STDEV.S (STDEV): ddof=1, ignore strings and booleans
   *
   * STDEVPA: ddof=0,
   * STDEVA: ddof=1,
   * @returns
   */
  std(e = 0) {
    const t = this.var(e);
    return t.isError() ? t : t.sqrt();
  }
  log() {
    return this.map((e) => e.isError() ? e : e.log());
  }
  log10() {
    return this.map((e) => e.isError() ? e : e.log10());
  }
  exp() {
    return this.map((e) => e.isError() ? e : e.exp());
  }
  abs() {
    return this.map((e) => e.isError() ? e : e.abs());
  }
  round(e) {
    return this._batchOperator(
      e,
      9
      /* ROUND */
    );
  }
  roundInverse(e) {
    return this.map((t) => t.isError() ? t : e.round(t));
  }
  floor(e) {
    return this._batchOperator(
      e,
      10
      /* FLOOR */
    );
  }
  floorInverse(e) {
    return this.map((t) => t.isError() ? t : e.floor(t));
  }
  ceil(e) {
    return this._batchOperator(
      e,
      11
      /* CEIL */
    );
  }
  ceilInverse(e) {
    return this.map((t) => t.isError() ? t : e.ceil(t));
  }
  toValue() {
    return ym(this._values);
  }
  _clearCache() {
    this._flattenCache = null, this._sliceCache.clear();
  }
  _sort(e) {
    const t = Dn();
    return (r, n) => {
      const s = r[e], o = n[e];
      return s == null ? 1 : o == null ? -1 : s.isError() && s.isError() ? 0 : s.isError() ? 1 : o.isError() ? -1 : t(
        s.getValue(),
        o.getValue()
      );
    };
  }
  _transposeArray(e) {
    const t = e.length, r = e[0].length, n = [];
    for (let s = 0; s < r; s++) {
      n[s] = [];
      for (let o = 0; o < t; o++)
        n[s][o] = e[o][s];
    }
    return n;
  }
  _batchOperator(e, t, r, n) {
    const s = [];
    let o = this._rowCount, u = this._columnCount;
    if (e.isArray()) {
      const f = e.getRowCount(), m = e.getColumnCount();
      if (o = Math.max(f, o), u = Math.max(m, u), f === 1 && m === 1) {
        const d = e.getFirstCell();
        for (let _ = 0; _ < u; _++)
          s.push(d);
      } else if (f === 1 && this._columnCount > 1) {
        const d = e.getArrayValue();
        for (let _ = 0; _ < u; _++)
          d[0] && d[0][_] ? s.push(d[0][_]) : s.push(ce.create());
      } else
        return this._batchOperatorArray(e, t, r, n);
    } else
      for (let f = 0; f < u; f++)
        s.push(e);
    const c = [];
    for (let f = 0; f < u; f++) {
      const m = s[f];
      this._batchOperatorValue(
        m,
        f,
        c,
        t,
        r,
        n
      );
    }
    const l = this._createNewArray(c, o, u);
    return l.setDefaultValue(T.create(!1)), l;
  }
  // eslint-disable-next-line max-lines-per-function
  _batchOperatorValue(e, t, r, n, s, o) {
    const u = this._rowCount, c = this.getUnitId(), l = this.getSheetId(), f = this.getCurrentRow(), m = this.getCurrentColumn();
    if (n === 5) {
      const { rowsInCache: d, rowsNotInCache: _ } = Ke.canUseCache(
        c,
        l,
        t + m,
        f,
        f + u - 1
      );
      if (d.length > 0) {
        if (s === Y.EQUALS && !(e.isString() && vo(e.getValue()))) {
          const C = Ke.getCellPositions(
            c,
            l,
            t + m,
            e.isNull() ? null : e.getValue(),
            d
          );
          C != null && C.forEach((E) => {
            if (E < f || E > f + u - 1)
              return;
            const R = E - f;
            r[R] == null && (r[R] = []), r[R][t] = T.create(!0);
          });
        } else {
          const C = Ke.getCellValuePositions(
            c,
            l,
            t + m
          );
          C != null && C.forEach((E, R) => {
            let b = ce.create();
            fr.has(R) ? b = g.create(R) : typeof R == "string" ? b = U.create(R) : typeof R == "number" ? b = y.create(R) : typeof R == "boolean" && (b = T.create(R));
            let p;
            b.isError() ? p = b : e.isError() ? p = e : p = b.compare(e, s, o), E.forEach((V) => {
              V >= f && V <= f + u - 1 && (r[V - f] == null && (r[V - f] = []), r[V - f][t] = p);
            });
          });
        }
        if (_.length > 0)
          for (const C of _) {
            const [E, R] = C;
            for (let b = E; b <= R; b++)
              this.__batchOperatorRowValue(
                e,
                t,
                r,
                n,
                b - f,
                c,
                l,
                f,
                m,
                s,
                o
              );
            Ke.setContinueBuildingCache(
              c,
              l,
              t + m,
              E,
              R
            );
          }
        return;
      }
    }
    for (let d = 0; d < u; d++)
      this.__batchOperatorRowValue(
        e,
        t,
        r,
        n,
        d,
        c,
        l,
        f,
        m,
        s,
        o
      );
    Ke.setContinueBuildingCache(
      c,
      l,
      t + m,
      f,
      f + u - 1
    );
  }
  // eslint-disable-next-line
  __batchOperatorRowValue(e, t, r, n, s, o, u, c, l, f, m) {
    const d = this.getValueOrDefault(s, t);
    if (r[s] == null && (r[s] = []), d && e)
      if (d.isError())
        r[s][t] = d;
      else if (e.isError())
        r[s][t] = e;
      else
        switch (n) {
          case 1:
            r[s][t] = d.plus(e);
            break;
          case 0:
            r[s][t] = d.minus(e);
            break;
          case 2:
            r[s][t] = d.multiply(e);
            break;
          case 3:
            r[s][t] = d.divided(e);
            break;
          case 4:
            r[s][t] = d.mod(e);
            break;
          case 5:
            f ? r[s][t] = d.compare(e, f, m) : r[s][t] = g.create(h.VALUE);
            break;
          case 6:
            r[s][t] = d.concatenateFront(e);
            break;
          case 7:
            r[s][t] = d.concatenateBack(e);
            break;
          case 8:
            r[s][t] = d.pow(e);
            break;
          case 9:
            r[s][t] = d.round(e);
            break;
          case 10:
            r[s][t] = d.floor(e);
            break;
          case 12:
            r[s][t] = d.atan2(e);
            break;
          case 11:
            r[s][t] = d.ceil(e);
            break;
        }
    else
      r[s][t] = g.create(h.NA);
    !d || d != null && d.isNull() ? Ke.set(
      o,
      u,
      t + l,
      Ys,
      s + c
    ) : Ke.set(
      o,
      u,
      t + l,
      d.getValue(),
      s + c
    );
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _batchOperatorArray(e, t, r, n) {
    let s = e.getRowCount(), o = e.getColumnCount();
    s < this._rowCount && (s = this._rowCount), o < this._columnCount && (o = this._columnCount);
    const u = [], c = this._checkArrayCalculateType(this), l = this._checkArrayCalculateType(e);
    for (let f = 0; f < s; f++) {
      const m = [];
      for (let d = 0; d < o; d++) {
        let _;
        c === 3 ? _ = this.getValueOrDefault(0, 0) : c === 1 ? _ = this.getValueOrDefault(0, d) : c === 2 ? _ = this.getValueOrDefault(f, 0) : _ = this.getValueOrDefault(f, d);
        let C;
        if (l === 3 ? C = e.getValueOrDefault(0, 0) : l === 1 ? C = e.getValueOrDefault(0, d) : l === 2 ? C = e.getValueOrDefault(f, 0) : C = e.getValueOrDefault(f, d), _ && C)
          if (_.isError())
            m[d] = _;
          else if (C.isError())
            m[d] = C;
          else
            switch (t) {
              case 1:
                m[d] = _.plus(C);
                break;
              case 0:
                m[d] = _.minus(C);
                break;
              case 2:
                m[d] = _.multiply(C);
                break;
              case 3:
                m[d] = _.divided(C);
                break;
              case 4:
                m[d] = _.mod(C);
                break;
              case 5:
                r ? m[d] = _.compare(C, r, n) : m[d] = g.create(h.VALUE);
                break;
              case 6:
                m[d] = _.concatenateFront(C);
                break;
              case 7:
                m[d] = _.concatenateBack(C);
                break;
              case 8:
                m[d] = _.pow(C);
                break;
              case 9:
                m[d] = _.round(C);
                break;
              case 12:
                m[d] = _.atan2(C);
                break;
              case 10:
                m[d] = _.floor(C);
                break;
              case 11:
                m[d] = _.ceil(C);
                break;
            }
        else
          m[d] = g.create(h.NA);
      }
      u.push(m);
    }
    return this._createNewArray(u, s, o);
  }
  _checkArrayCalculateType(e) {
    return e.getRowCount() === 1 && e.getColumnCount() === 1 ? 3 : e.getRowCount() === 1 ? 1 : e.getColumnCount() === 1 ? 2 : 0;
  }
  _formatValue(e) {
    if (typeof e != "string")
      return e = e, this._rowCount = e.rowCount, this._columnCount = e.columnCount, this._unitId = e.unitId, this._sheetId = e.sheetId, this._currentRow = e.row, this._currentColumn = e.column, e.calculateValueList;
    e = e.slice(1, -1);
    const t = e.split(";"), r = t.length, n = [];
    let s = 0;
    for (let o = 0; o < r; o++) {
      const c = t[o].split(","), l = c.length;
      s < l && (s = l);
      const f = [];
      for (let m = 0; m < l; m++) {
        const d = c[m].trim();
        f.push(Pt.create(d));
      }
      n.push(f);
    }
    return this._rowCount = r, this._columnCount = s, n;
  }
  _createNewArray(e, t, r, n = -1, s = -1) {
    (this._currentColumn === -1 || this._currentRow === -1) && (n = -1, s = -1);
    const o = {
      calculateValueList: e,
      rowCount: t,
      columnCount: r,
      unitId: this.getUnitId(),
      sheetId: this.getSheetId(),
      row: n,
      column: s
    };
    return K.create(o);
  }
}
class Pt {
  static create(i, e = !1) {
    if (i == null)
      return ce.create();
    if (typeof i == "boolean")
      return T.create(i);
    if (typeof i == "string") {
      const t = i.toLocaleUpperCase().trim();
      if (fr.has(t))
        return g.create(t);
      if (t === ir.TRUE || t === ir.FALSE)
        return is(i);
      if (q(i))
        return y.create(Number(i));
      if (!e) {
        const { isNumberPattern: n, value: s, pattern: o } = mf(i);
        if (n)
          return y.create(s, o);
      }
      const r = i.replace(/\n/g, "").replace(/\r/g, "");
      return !pm(r) && bl(r) ? K.create(r) : Rm(i);
    }
    return typeof i == "number" ? Yr(i) : g.create(h.VALUE);
  }
}
function pm(a) {
  const i = a.trim();
  return i.startsWith('"') && i.endsWith('"');
}
const Nm = 1e4, _r = new xt(Nm);
class jr extends ts {
  constructor(e) {
    super();
    A(this, "_forcedSheetId", "");
    A(this, "_forcedSheetName", "");
    A(this, "_defaultSheetId", "");
    A(this, "_rangeData", {
      startColumn: -1,
      startRow: -1,
      endRow: -1,
      endColumn: -1
    });
    A(this, "_unitData", {});
    A(this, "_unitStylesData", {});
    A(this, "_filteredOutRows", []);
    A(this, "_defaultUnitId", "");
    A(this, "_forcedUnitId", "");
    A(this, "_runtimeData", {});
    A(this, "_arrayFormulaCellData", {});
    A(this, "_runtimeArrayFormulaCellData", {});
    A(this, "_runtimeFeatureCellData", {});
    A(this, "_refOffsetX", 0);
    A(this, "_refOffsetY", 0);
    A(this, "_currentRow");
    A(this, "_currentColumn");
    this._token = e;
  }
  dispose() {
    this._unitData = {}, this._unitStylesData = {}, this._runtimeData = {};
  }
  getToken() {
    return this._token;
  }
  setToken(e) {
    this._token = e;
  }
  isExceedRange() {
    const { startRow: e, endRow: t, startColumn: r, endColumn: n } = this.getRangePosition();
    return e < 0 || r < 0 || t >= this.getActiveSheetRowCount() || n >= this.getActiveSheetColumnCount();
  }
  setRefOffset(e = 0, t = 0) {
    this._refOffsetX = e, this._refOffsetY = t;
  }
  getRefOffset() {
    return {
      x: this._refOffsetX,
      y: this._refOffsetY
    };
  }
  getRangePosition() {
    const { x: e, y: t } = this.getRefOffset(), r = this.getRangeData();
    let { startRow: n, startColumn: s, endRow: o, endColumn: u } = ga(r, e, t);
    return Number.isNaN(n) && (n = 0), Number.isNaN(s) && (s = 0), Number.isNaN(o) && (o = this.getActiveSheetRowCount() - 1), Number.isNaN(u) && (u = this.getActiveSheetColumnCount() - 1), {
      startRow: n,
      endRow: o,
      startColumn: s,
      endColumn: u
    };
  }
  isReferenceObject() {
    return !0;
  }
  iterator(e) {
    const { startRow: t, endRow: r, startColumn: n, endColumn: s } = this.getRangePosition();
    if (this._checkIfWorksheetMiss())
      return e(g.create(h.VALUE), t, n);
    const o = this._forcedUnitId || this._defaultUnitId, u = this._forcedSheetId || this._defaultSheetId;
    for (let c = t; c <= r; c++)
      for (let l = n; l <= s; l++) {
        if (c < 0 || l < 0)
          return e(g.create(h.REF), c, l);
        const f = this.getCellData(c, l);
        let m = !1;
        if (En(f)) {
          m = e(null, c, l);
          continue;
        }
        let d = this.getCellValueObject(f);
        if (c === t && l === n) {
          const _ = this.getCellPattern(o, u, c, l);
          if (_ && d.isNumber()) {
            const C = Number(d.getValue());
            d = y.create(C, _);
          }
        }
        if (m = e(d, c, l), m === !1)
          return;
      }
  }
  getFirstCell() {
    if (this._checkIfWorksheetMiss())
      return g.create(h.VALUE);
    const { startRow: e, startColumn: t } = this.getRangePosition(), r = this.getCellData(e, t);
    if (!r)
      return y.create(0);
    let n = this.getCellValueObject(r);
    const s = this._forcedUnitId || this._defaultUnitId, o = this._forcedSheetId || this._defaultSheetId, u = this.getCellPattern(s, o, e, t);
    if (u && n.isNumber()) {
      const c = Number(n.getValue());
      n = y.create(c, u);
    }
    return n;
  }
  getRangeData() {
    return this._rangeData;
  }
  setRangeData(e) {
    this._rangeData = e;
  }
  getUnitId() {
    return this._forcedUnitId && this._forcedUnitId.length > 0 ? this._forcedUnitId : this._defaultUnitId;
  }
  getSheetId() {
    return this._forcedSheetId && this._forcedSheetId.length > 0 ? this._forcedSheetId : this._defaultSheetId;
  }
  setForcedUnitIdDirect(e) {
    e.length > 0 && (this._forcedUnitId = e);
  }
  getForcedUnitId() {
    return this._forcedUnitId;
  }
  setForcedSheetId(e) {
    var t;
    this._forcedSheetId = (t = e[this.getUnitId()]) == null ? void 0 : t[this._forcedSheetName];
  }
  setForcedSheetIdDirect(e) {
    this._forcedSheetId = e;
  }
  getForcedSheetId() {
    return this._forcedSheetId;
  }
  setForcedSheetName(e) {
    e.length > 0 && (this._forcedSheetName = e);
  }
  getForcedSheetName() {
    return this._forcedSheetName;
  }
  setDefaultSheetId(e) {
    this._defaultSheetId = e;
  }
  getDefaultSheetId() {
    return this._defaultSheetId;
  }
  setDefaultUnitId(e) {
    this._defaultUnitId = e;
  }
  getDefaultUnitId() {
    return this._defaultUnitId;
  }
  getUnitData() {
    return this._unitData;
  }
  setUnitData(e) {
    this._unitData = e;
  }
  getUnitStylesData() {
    return this._unitStylesData;
  }
  setUnitStylesData(e) {
    this._unitStylesData = e;
  }
  getFilteredOutRows() {
    return this._filteredOutRows;
  }
  setFilteredOutRows(e) {
    this._filteredOutRows = e;
  }
  getRuntimeData() {
    return this._runtimeData;
  }
  setRuntimeData(e) {
    this._runtimeData = e;
  }
  getArrayFormulaCellData() {
    return this._arrayFormulaCellData;
  }
  setArrayFormulaCellData(e) {
    this._arrayFormulaCellData = e;
  }
  getRuntimeArrayFormulaCellData() {
    return this._runtimeArrayFormulaCellData;
  }
  setRuntimeArrayFormulaCellData(e) {
    this._runtimeArrayFormulaCellData = e;
  }
  getRuntimeFeatureCellData() {
    return this._runtimeFeatureCellData;
  }
  setRuntimeFeatureCellData(e) {
    this._runtimeFeatureCellData = e;
  }
  getActiveSheetRowCount() {
    var e;
    return ((e = this.getCurrentActiveSheetData()) == null ? void 0 : e.rowCount) || 0;
  }
  getActiveSheetColumnCount() {
    var e;
    return ((e = this.getCurrentActiveSheetData()) == null ? void 0 : e.columnCount) || 0;
  }
  getRowCount() {
    const e = this.getRangeData();
    return e.endRow - e.startRow + 1;
  }
  getColumnCount() {
    const e = this.getRangeData();
    return e.endColumn - e.startColumn + 1;
  }
  getRowData() {
    var e;
    return ((e = this.getCurrentActiveSheetData()) == null ? void 0 : e.rowData) || {};
  }
  getColumnData() {
    var e;
    return ((e = this.getCurrentActiveSheetData()) == null ? void 0 : e.columnData) || {};
  }
  isCell() {
    return !1;
  }
  isColumn() {
    return !1;
  }
  isRow() {
    return !1;
  }
  isRange() {
    return !1;
  }
  isTable() {
    return !1;
  }
  isCurrentRowForRange() {
    return !1;
  }
  isCurrentColumnForRange() {
    return !1;
  }
  isMultiArea() {
    return !1;
  }
  unionBy(e) {
    return g.create(h.REF);
  }
  unionRange(e, t) {
    return {
      startRow: -1,
      startColumn: -1,
      endRow: -1,
      endColumn: -1
    };
  }
  getCellValueObject(e) {
    const t = tf(e);
    if (fr.has(t))
      return g.create(t);
    if (e.t === Dt.NUMBER) {
      const r = this._getPatternByCell(e);
      return xc(r) ? U.create(t.toString()) : Yr(t, r);
    }
    return e.t === Dt.STRING || e.t === Dt.FORCE_STRING ? U.create(t.toString()) : e.t === Dt.BOOLEAN ? is(t) : Pt.create(t);
  }
  _getPatternByCell(e) {
    var n;
    const t = this._unitStylesData[this.getUnitId()];
    if (!t) return "";
    const r = t.getStyleByCell(e);
    return ((n = r == null ? void 0 : r.n) == null ? void 0 : n.pattern) || "";
  }
  getCellByRow(e) {
    return this.getCellByPosition(e);
  }
  getCellByColumn(e) {
    return this.getCellByPosition(void 0, e);
  }
  getCurrentActiveSheetData() {
    var e;
    return (e = this._unitData[this.getUnitId()]) == null ? void 0 : e[this.getSheetId()];
  }
  getCurrentStylesData() {
    return this._unitStylesData[this.getUnitId()];
  }
  getCurrentRuntimeSheetData() {
    var e, t;
    return (t = (e = this._runtimeData) == null ? void 0 : e[this.getUnitId()]) == null ? void 0 : t[this.getSheetId()];
  }
  getCurrentActiveArrayFormulaCellData() {
    var e, t;
    return (t = (e = this._arrayFormulaCellData) == null ? void 0 : e[this.getUnitId()]) == null ? void 0 : t[this.getSheetId()];
  }
  getCurrentRuntimeActiveArrayFormulaCellData() {
    var e, t;
    return (t = (e = this._runtimeArrayFormulaCellData) == null ? void 0 : e[this.getUnitId()]) == null ? void 0 : t[this.getSheetId()];
  }
  getCellData(e, t) {
    const r = this.getCurrentActiveSheetData(), n = this.getCurrentRuntimeSheetData(), s = this.getCurrentActiveArrayFormulaCellData(), o = this.getCurrentRuntimeActiveArrayFormulaCellData();
    return (n == null ? void 0 : n.getValue(e, t)) || (o == null ? void 0 : o.getValue(e, t)) || this.getRuntimeFeatureCellValue(e, t) || (s == null ? void 0 : s.getValue(e, t)) || (r == null ? void 0 : r.cellData.getValue(e, t));
  }
  getRuntimeFeatureCellValue(e, t) {
    return Uo(e, t, this.getSheetId(), this.getUnitId(), this._runtimeFeatureCellData);
  }
  getCellByPosition(e, t) {
    let r = e, n = t;
    const s = this.getRangeData();
    r || (r = s.startRow), n || (n = s.startColumn);
    const o = this.getCellData(r, n);
    return o ? this.getCellValueObject(o) : g.create(h.VALUE);
  }
  setCurrentRowAndColumn(e, t) {
    this._currentRow = e, this._currentColumn = t;
  }
  getCurrentRow() {
    return this._currentRow;
  }
  getCurrentColumn() {
    return this._currentColumn;
  }
  /**
   * Get the pattern of the cell
   * @param unitId
   * @param sheetId
   * @param row
   * @param column
   * @returns
   */
  getCellPattern(e, t, r, n) {
    var c, l, f, m;
    const s = this._unitStylesData[e];
    if (!s)
      return "";
    const o = (f = (l = (c = this._unitData[e]) == null ? void 0 : c[t]) == null ? void 0 : l.cellData) == null ? void 0 : f.getValue(r, n);
    if (!o)
      return "";
    const u = s.getStyleByCell(o);
    return ((m = u == null ? void 0 : u.n) == null ? void 0 : m.pattern) || "";
  }
  toArrayValueObject(e = !0) {
    var _;
    const { startRow: t, endRow: r, startColumn: n, endColumn: s } = this.getRangePosition(), o = `${this.getUnitId()}_${this.getSheetId()}_${t}_${r}_${n}_${s}`, u = _r.get(o);
    if (u && e)
      return u;
    const c = r - t + 1, l = s - n + 1;
    if (c < 0 || l < 0)
      return this._getBlankArrayValueObject();
    const f = new Array(c);
    this.iterator((C, E, R) => {
      const b = E - t, p = R - n;
      f[b] || (f[b] = new Array(l)), C == null && (C = ce.create()), f[b][p] = C;
    });
    const m = {
      calculateValueList: f,
      rowCount: f.length,
      columnCount: ((_ = f[0]) == null ? void 0 : _.length) || 0,
      unitId: this.getUnitId(),
      sheetId: this.getSheetId(),
      row: t,
      column: n
    }, d = K.create(m);
    return e && _r.set(o, d), d;
  }
  toUnitRange() {
    return {
      range: this.getRangePosition(),
      sheetId: this.getSheetId(),
      unitId: this.getUnitId()
    };
  }
  _checkIfWorksheetMiss() {
    return (this._forcedSheetId == null || this._forcedSheetId.length === 0) && this._forcedSheetName.length > 0;
  }
  _getBlankArrayValueObject() {
    const e = {
      calculateValueList: [],
      rowCount: 0,
      columnCount: 0,
      unitId: this.getUnitId(),
      sheetId: this.getSheetId(),
      row: 0,
      column: 0
    };
    return K.create(e);
  }
}
class Vm extends ts {
  constructor(i) {
    super(), this._promise = i;
  }
  isAsyncObject() {
    return !0;
  }
  async getValue() {
    return this._promise;
  }
}
class Om extends ts {
  constructor(i) {
    super(), this._promiseList = i;
  }
  isAsyncArrayObject() {
    return !0;
  }
  async getValue() {
    var t;
    const i = [];
    for (let r = 0; r < this._promiseList.length; r++) {
      const n = this._promiseList[r];
      i[r] == null && (i[r] = []);
      for (let s = 0; s < n.length; s++) {
        const o = n[s];
        o.isAsyncObject() ? i[r][s] = await o.getValue() : i[r][s] = o;
      }
    }
    const e = {
      calculateValueList: i,
      rowCount: i.length,
      columnCount: ((t = i[0]) == null ? void 0 : t.length) || 0,
      unitId: "",
      sheetId: "",
      row: 0,
      column: 0
    };
    return K.create(e);
  }
}
class xn extends jr {
  constructor(i, e, t) {
    super(""), this.setRangeData(i), e && this.setForcedSheetIdDirect(e), t && this.setForcedUnitIdDirect(t);
  }
  isRange() {
    return !0;
  }
}
class Ma extends jr {
  constructor(i) {
    super(i);
    const e = br(i);
    this.setForcedUnitIdDirect(e.unitId), this.setForcedSheetName(e.sheetName), this.setRangeData(e.range);
  }
  isCell() {
    return !0;
  }
  unionBy(i) {
    if (!i.isCell())
      return g.create(h.REF);
    const e = i, t = this.unionRange(this.getRangeData(), e.getRangeData());
    return this._createRange(t);
  }
  unionRange(i, e) {
    const t = i.startRow, r = i.startColumn, n = e.startRow, s = e.startColumn, o = {
      startRow: -1,
      startColumn: -1,
      endRow: -1,
      endColumn: -1
    };
    return t > n ? (o.startRow = n, o.endRow = t) : (o.startRow = t, o.endRow = n), r > s ? (o.startColumn = s, o.endColumn = r) : (o.startColumn = r, o.endColumn = s), i.startAbsoluteRefType && (o.startAbsoluteRefType = i.startAbsoluteRefType), e.startAbsoluteRefType && (o.endAbsoluteRefType = e.startAbsoluteRefType), o;
  }
  _createRange(i) {
    const e = new xn(
      i,
      this.getForcedSheetId(),
      this.getForcedUnitId()
    );
    e.setUnitData(this.getUnitData()), e.setDefaultSheetId(this.getDefaultSheetId()), e.setDefaultUnitId(this.getDefaultUnitId()), e.setRuntimeData(this.getRuntimeData()), e.setUnitStylesData(this.getUnitStylesData()), e.setArrayFormulaCellData(this.getArrayFormulaCellData()), e.setRuntimeArrayFormulaCellData(this.getRuntimeArrayFormulaCellData()), e.setRuntimeFeatureCellData(this.getRuntimeFeatureCellData());
    const { x: t, y: r } = this.getRefOffset();
    e.setRefOffset(t, r);
    const n = this.getForcedSheetId();
    e.setForcedSheetName(this.getForcedSheetName()), n != null && e.setForcedSheetIdDirect(n);
    const s = this.getForcedUnitId();
    return s && e.setForcedUnitIdDirect(s), e;
  }
}
class Da extends jr {
  constructor(i) {
    super(i);
    const e = br(i);
    this.setForcedUnitIdDirect(e.unitId), this.setForcedSheetName(e.sheetName);
    const t = {
      ...e.range,
      startColumn: e.range.startColumn,
      startRow: Number.NaN,
      endColumn: e.range.endColumn,
      endRow: Number.NaN,
      rangeType: rt.COLUMN
    };
    this.setRangeData(t);
  }
  isColumn() {
    return !0;
  }
  unionBy(i) {
    if (!i.isColumn())
      return g.create(h.REF);
    const e = i;
    if (e.getForcedSheetName() !== void 0 && e.getForcedSheetName() !== "")
      return g.create(h.REF);
    const t = this.getRangeData(), r = e.getRangeData(), n = r.startColumn;
    if (n >= t.startColumn && n <= t.endColumn)
      return this;
    const s = t.startColumn;
    return n > s ? t.endColumn = n : (t.startColumn = n, t.endColumn = s), r.startAbsoluteRefType && (t.endAbsoluteRefType = r.startAbsoluteRefType), t.rangeType = rt.COLUMN, this.setToken(`${this.getToken()}${X.COLON}${e.getToken()}`), this;
  }
}
class wa extends jr {
  constructor(i) {
    super(i);
    const e = br(i);
    this.setForcedUnitIdDirect(e.unitId), this.setForcedSheetName(e.sheetName);
    const t = {
      ...e.range,
      startColumn: Number.NaN,
      startRow: e.range.startRow,
      endColumn: Number.NaN,
      endRow: e.range.endRow,
      rangeType: rt.ROW
    };
    this.setRangeData(t);
  }
  isRow() {
    return !0;
  }
  unionBy(i) {
    if (!i.isRow())
      return g.create(h.REF);
    const e = i;
    if (e.getForcedSheetName() !== void 0 && e.getForcedSheetName() !== "")
      return g.create(h.REF);
    const t = this.getRangeData(), r = e.getRangeData(), n = r.startRow;
    if (n >= t.startRow && n <= t.endRow)
      return this;
    const s = t.startRow;
    return n > s ? t.endRow = n : (t.startRow = n, t.endRow = s), r.startAbsoluteRefType && (t.endAbsoluteRefType = r.startAbsoluteRefType), t.rangeType = rt.ROW, this.setToken(`${this.getToken()}${X.COLON}${e.getToken()}`), this;
  }
}
function O(a, i, e, t) {
  const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = [];
  for (let o = 0; o < a; o++) {
    const u = [];
    for (let c = 0; c < i; c++) {
      if (r === 1 && n === 1) {
        const f = e.isArray() ? e.get(0, 0) : e;
        u.push(f);
        continue;
      }
      if (r === 1 && c < n) {
        const f = e.get(0, c);
        u.push(f);
        continue;
      }
      if (n === 1 && o < r) {
        const f = e.get(o, 0);
        u.push(f);
        continue;
      }
      if (o >= r || c >= n) {
        u.push(t != null ? t : ce.create());
        continue;
      }
      const l = e.get(o, c);
      u.push(l);
    }
    s.push(u);
  }
  return mt(s, a, i);
}
function mt(a, i, e, t = "", r = "") {
  const n = {
    calculateValueList: a,
    rowCount: i,
    columnCount: e,
    unitId: t,
    sheetId: r,
    row: -1,
    column: -1
  };
  return K.create(n);
}
function La(a) {
  const i = [
    Y.EQUALS,
    Y.NOT_EQUAL,
    Y.GREATER_THAN_OR_EQUAL,
    Y.GREATER_THAN,
    Y.LESS_THAN_OR_EQUAL,
    Y.LESS_THAN
  ];
  for (const e of i)
    if (a.startsWith(e)) {
      const t = a.substring(e.length);
      return [e, Pt.create(t)];
    }
  return [Y.EQUALS, Pt.create(a)];
}
function os(a, i, e, t) {
  if (!e)
    if (i.isString()) {
      const r = `${i.getValue()}`, [n, s] = La(r);
      e = n, i = s;
    } else
      e = Y.EQUALS;
  return a.compare(i, e, t);
}
function Sm(a, i) {
  const e = Math.max(a.isArray() ? a.getRowCount() : 1, i.isArray() ? i.getRowCount() : 1), t = Math.max(a.isArray() ? a.getColumnCount() : 1, i.isArray() ? i.getColumnCount() : 1), r = O(e, t, a), n = O(e, t, i);
  return r.mapValue((s, o, u) => {
    const c = n.get(o, u);
    return s != null && s.isError() ? s : c != null && c.isError() ? c : s != null && s.isBoolean() && (c != null && c.isBoolean()) ? is(s.getValue() && c.getValue()) : T.create(!1);
  });
}
function Mm(a) {
  const i = a.getValue();
  let e = 0;
  return i && (e = 1), y.create(e);
}
function Ui(a) {
  return a.isArray() && a.getRowCount() === 1 && a.getColumnCount() === 1 ? !0 : a.isReferenceObject() ? !!(a.isCell() || a.getRowCount() === 1 && a.getColumnCount() === 1) : (a = a, !!(a.isString() || a.isNumber() || a.isBoolean() || a.isError() || a.isNull()));
}
function Dm(a) {
  const i = a == null ? void 0 : a.getPattern();
  let e = {}, t = {};
  if (i && (e = {
    s: {
      n: {
        pattern: i
      }
    }
  }), a != null && a.getCustomData() && (t = {
    custom: a.getCustomData()
  }), a == null)
    return {
      v: null,
      ...e
    };
  if (a.isError())
    return {
      v: a.getErrorType(),
      t: Dt.STRING,
      ...e,
      ...t
    };
  if (a.isValueObject()) {
    const r = a, n = r.getValue();
    return r.isNumber() ? {
      v: n,
      t: Dt.NUMBER,
      ...e,
      ...t
    } : r.isBoolean() ? {
      v: n ? 1 : 0,
      t: Dt.BOOLEAN,
      ...e,
      ...t
    } : r.isString() ? {
      v: n,
      t: Dt.STRING,
      ...e,
      ...t
    } : r.isNull() ? {
      v: null,
      ...e,
      ...t
    } : {
      v: n,
      t: Dt.STRING,
      ...e,
      ...t
    };
  }
}
function wm(a) {
  let i = 0, e = 0;
  return a.forEach((t, r) => {
    if (r % 2 === 1)
      if (t.isArray()) {
        const n = t;
        i = Math.max(i, n.getRowCount()), e = Math.max(e, n.getColumnCount());
      } else
        i = Math.max(i, 1), e = Math.max(e, 1);
  }), { maxRowLength: i, maxColumnLength: e };
}
function Kr(a, i) {
  if (a.length === 0 || a.length % 2 !== 0)
    return {
      isError: !0,
      errorObject: g.create(h.VALUE),
      rangeIsDifferentSize: !1,
      criteriaMaxRowLength: 0,
      criteriaMaxColumnLength: 0,
      targetRange: null,
      variants: []
    };
  let e = null, t = -1, r = -1;
  if (i) {
    if (!i.isReferenceObject())
      return {
        isError: !0,
        errorObject: g.create(h.VALUE),
        rangeIsDifferentSize: !1,
        criteriaMaxRowLength: 0,
        criteriaMaxColumnLength: 0,
        targetRange: null,
        variants: []
      };
    e = i.toArrayValueObject(), t = e.getRowCount(), r = e.getColumnCount();
  }
  let n = 0, s = 0, o = !1;
  const u = [];
  for (let c = 0; c < a.length; c++)
    if (c % 2 === 1) {
      const l = a[c - 1], f = a[c];
      if (!l.isReferenceObject())
        return {
          isError: !0,
          errorObject: g.create(h.VALUE),
          rangeIsDifferentSize: !1,
          criteriaMaxRowLength: 0,
          criteriaMaxColumnLength: 0,
          targetRange: null,
          variants: []
        };
      const m = l.toArrayValueObject(), d = m.getRowCount(), _ = m.getColumnCount();
      c === 1 && t === -1 && r === -1 ? (t = d, r = _) : !o && (t !== d || r !== _) && (o = !0);
      let C = f;
      f.isReferenceObject() && (C = f.toArrayValueObject()), n = Math.max(n, C.isArray() ? C.getRowCount() : 1), s = Math.max(s, C.isArray() ? C.getColumnCount() : 1), u.push(m), u.push(C);
    }
  return {
    isError: !1,
    errorObject: null,
    rangeIsDifferentSize: o,
    criteriaMaxRowLength: n,
    criteriaMaxColumnLength: s,
    targetRange: e,
    variants: u
  };
}
function ea(a) {
  return a.isArray() ? a : K.createByArray([[a.getValue()]]);
}
function Zr(a, i, e, t = !1) {
  const r = [];
  for (let n = 0; n < a.length; n++) {
    if (n % 2 === 1) continue;
    const s = a[n], o = a[n + 1];
    O(i, e, o, g.create(h.NA)).iterator((c, l, f) => {
      if (!c)
        return;
      let m = os(s, c);
      if (t && (m = us(m, s, c)), r[l] === void 0 && (r[l] = []), r[l][f] === void 0) {
        r[l][f] = m;
        return;
      }
      r[l][f] = Sm(r[l][f], m);
    });
  }
  return r;
}
function us(a, i, e) {
  const [t, r] = La(`${e.getValue()}`);
  return a.mapValue((n, s, o) => {
    const u = i.get(s, o);
    if (u && Lm(u, r))
      return n;
    if (u != null && u.isError() && r.isError() && u.getValue() === r.getValue())
      return T.create(!0);
    if (t === Y.EQUALS || t === Y.NOT_EQUAL) {
      if (u != null && u.isNumber() && r.isString()) {
        const c = r.convertToNumberObjectValue();
        if (c.isNumber())
          return u.compare(c, t);
      }
      if (r.isNumber() && (u != null && u.isString())) {
        const c = u.convertToNumberObjectValue();
        if (c.isNumber())
          return c.compare(r, t);
      }
      if (t === Y.EQUALS)
        return T.create(!1);
      if (t === Y.NOT_EQUAL)
        return T.create(!0);
    }
    return T.create(!1);
  });
}
function Lm(a, i) {
  if (a.isNumber() && i.isNumber() || a.isBoolean() && i.isBoolean())
    return !0;
  const e = a.isString() && a.getValue() === "", t = i.isString() && i.getValue() === "";
  return !!((e || a.isNull()) && (t || i.isNull()) || a.isString() && !e && i.isString() && !t);
}
var Tr = /* @__PURE__ */ ((a) => (a[a.CELL = 0] = "CELL", a[a.COLUMN = 1] = "COLUMN", a[a.ROW = 2] = "ROW", a))(Tr || {});
function Pm(a, i) {
  let e;
  switch (i) {
    case 0:
      e = new Ma(a);
      break;
    case 1:
      e = new Da(a);
      break;
    case 2:
      e = new wa(a);
      break;
    default:
      throw new Error("Unknown reference object type");
  }
  return e;
}
function xm(a, i) {
  let e;
  return a.isCell() && i.isCell() || a.isRow() && i.isRow() || a.isColumn() && i.isColumn() ? e = a.unionBy(i) : e = g.create(h.NAME), e;
}
var jm = Object.getOwnPropertyDescriptor, Um = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? jm(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, vm = (a, i) => (e, t) => i(e, t, a);
let ta = class extends Se {
  constructor(a) {
    super(), this._univerInstanceService = a;
  }
  generateCellValue(a, i) {
    if (i.trim() === "")
      return {
        v: ""
      };
    let e = a;
    if (a.startsWith("#") && bo(a.slice(1))) {
      const { unitId: t, sheetName: r, range: n } = kr(a.slice(1)), s = this._univerInstanceService.getCurrentUnitOfType(Cr.UNIVER_SHEET);
      if (t === "" || t === s.getUnitId())
        if (r === "")
          e = `#gid=${s.getActiveSheet().getSheetId()}&range=${Yt(n)}`;
        else {
          const o = s.getSheetBySheetName(r);
          o && (e = `#gid=${o.getSheetId()}&range=${Yt(n)}`);
        }
    } else Ge.isLegalUrl(a) && (e = Ge.normalizeUrl(a));
    return {
      p: jc.create().insertLink(i, e).getData()
    };
  }
};
ta = Um([
  vm(0, Jn)
], ta);
const Xo = Je(
  "univer.formula.hyperlink-engine-formula.service"
);
var Tm = Object.getOwnPropertyDescriptor, Im = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Tm(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, vi = (a, i) => (e, t) => i(e, t, a), tt = /* @__PURE__ */ ((a) => (a[a.IDLE = 0] = "IDLE", a[a.START = 1] = "START", a[a.START_DEPENDENCY = 2] = "START_DEPENDENCY", a[a.START_CALCULATION = 3] = "START_CALCULATION", a[a.CURRENTLY_CALCULATING = 4] = "CURRENTLY_CALCULATING", a[a.START_DEPENDENCY_ARRAY_FORMULA = 5] = "START_DEPENDENCY_ARRAY_FORMULA", a[a.START_CALCULATION_ARRAY_FORMULA = 6] = "START_CALCULATION_ARRAY_FORMULA", a[a.CURRENTLY_CALCULATING_ARRAY_FORMULA = 7] = "CURRENTLY_CALCULATING_ARRAY_FORMULA", a[a.CALCULATION_COMPLETED = 8] = "CALCULATION_COMPLETED", a))(tt || {}), Ir = /* @__PURE__ */ ((a) => (a[a.INITIAL = 0] = "INITIAL", a[a.STOP_EXECUTION = 1] = "STOP_EXECUTION", a[a.NOT_EXECUTED = 2] = "NOT_EXECUTED", a[a.SUCCESS = 3] = "SUCCESS", a))(Ir || {});
let ra = class extends Se {
  constructor(i, e) {
    super();
    A(this, "_formulaExecuteStage", 0);
    A(this, "_stopState", !1);
    A(this, "_currentRow", -1);
    A(this, "_currentColumn", -1);
    A(this, "_currentRowCount", Number.NEGATIVE_INFINITY);
    A(this, "_currentColumnCount", Number.NEGATIVE_INFINITY);
    A(this, "_currentSubUnitId", "");
    A(this, "_currentUnitId", "");
    A(this, "_runtimeData", {});
    A(this, "_runtimeOtherData", {});
    // Data returned by other businesses through formula calculation, excluding the sheet.
    A(this, "_unitArrayFormulaRange", {});
    A(this, "_unitArrayFormulaEmbeddedMap", {});
    A(this, "_runtimeArrayFormulaCellData", {});
    A(this, "_runtimeClearArrayFormulaCellData", {});
    A(this, "_runtimeFeatureRange", {});
    A(this, "_runtimeFeatureCellData", {});
    A(this, "_runtimeImageFormulaData", []);
    A(this, "_functionsExecutedState", 0);
    // lambdaId: { key: BaseAstNode }
    A(this, "_functionDefinitionPrivacyVar", /* @__PURE__ */ new Map());
    A(this, "_totalFormulasToCalculate", 0);
    A(this, "_completedFormulasCount", 0);
    A(this, "_totalArrayFormulasToCalculate", 0);
    A(this, "_completedArrayFormulasCount", 0);
    A(this, "_formulaCycleIndex", 0);
    A(this, "_isCycleDependency", !1);
    this._currentConfigService = i, this._hyperlinkEngineFormulaService = e;
  }
  get currentRow() {
    return this._currentRow;
  }
  get currentColumn() {
    return this._currentColumn;
  }
  get currentRowCount() {
    return this._currentRowCount;
  }
  get currentColumnCount() {
    return this._currentColumnCount;
  }
  get currentSubUnitId() {
    return this._currentSubUnitId;
  }
  get currentUnitId() {
    return this._currentUnitId;
  }
  dispose() {
    super.dispose(), this.reset(), this._runtimeFeatureCellData = {}, this._runtimeFeatureRange = {}, this.clearReferenceAndNumberformatCache();
  }
  enableCycleDependency() {
    this._isCycleDependency = !0;
  }
  disableCycleDependency() {
    this._isCycleDependency = !1;
  }
  isCycleDependency() {
    return this._isCycleDependency;
  }
  setFormulaCycleIndex(i) {
    this._formulaCycleIndex = i;
  }
  getFormulaCycleIndex() {
    return this._formulaCycleIndex;
  }
  setTotalArrayFormulasToCalculate(i) {
    this._totalArrayFormulasToCalculate = i;
  }
  getTotalArrayFormulasToCalculate() {
    return this._totalArrayFormulasToCalculate;
  }
  setCompletedArrayFormulasCount(i) {
    this._completedArrayFormulasCount = i;
  }
  getCompletedArrayFormulasCount() {
    return this._completedArrayFormulasCount;
  }
  setTotalFormulasToCalculate(i) {
    this._totalFormulasToCalculate = i;
  }
  getTotalFormulasToCalculate() {
    return this._totalFormulasToCalculate;
  }
  setCompletedFormulasCount(i) {
    this._completedFormulasCount = i;
  }
  getCompletedFormulasCount() {
    return this._completedFormulasCount;
  }
  markedAsSuccessfullyExecuted() {
    this._functionsExecutedState = 3;
  }
  markedAsNoFunctionsExecuted() {
    this._functionsExecutedState = 2;
  }
  markedAsStopFunctionsExecuted() {
    this._functionsExecutedState = 1;
  }
  markedAsInitialFunctionsExecuted() {
    this._functionsExecutedState = 0;
  }
  stopExecution() {
    this._stopState = !0, this.setFormulaExecuteStage(
      0
      /* IDLE */
    );
  }
  isStopExecution() {
    return this._stopState;
  }
  setFormulaExecuteStage(i) {
    this._formulaExecuteStage = i;
  }
  getFormulaExecuteStage() {
    return this._formulaExecuteStage;
  }
  reset() {
    this._formulaExecuteStage = 0, this._runtimeData = {}, this._runtimeOtherData = {}, this._unitArrayFormulaRange = {}, this._unitArrayFormulaEmbeddedMap = {}, this._runtimeArrayFormulaCellData = {}, this._runtimeClearArrayFormulaCellData = {}, this._runtimeImageFormulaData = [], this._functionDefinitionPrivacyVar.clear(), this.markedAsInitialFunctionsExecuted(), this._stopState = !1, this._isCycleDependency = !1, this._totalFormulasToCalculate = 0, this._completedFormulasCount = 0, this.clearReferenceAndNumberformatCache();
  }
  clearReferenceAndNumberformatCache() {
    of(), hf(), Yl();
  }
  setCurrent(i, e, t, r, n, s) {
    this._currentRow = i, this._currentColumn = e, this._currentRowCount = t, this._currentColumnCount = r, this._currentSubUnitId = n, this._currentUnitId = s;
  }
  clearFunctionDefinitionPrivacyVar() {
    this._functionDefinitionPrivacyVar.clear();
  }
  registerFunctionDefinitionPrivacyVar(i, e) {
    this._functionDefinitionPrivacyVar.set(i, e);
  }
  getFunctionDefinitionPrivacyVar(i) {
    return this._functionDefinitionPrivacyVar.get(i);
  }
  setRuntimeOtherData(i, e, t, r) {
    const n = this._currentSubUnitId, s = this._currentUnitId;
    this._runtimeOtherData[s] === void 0 && (this._runtimeOtherData[s] = {});
    const o = this._runtimeOtherData[s];
    (o[n] === void 0 || o[n] === null) && (o[n] = {});
    const u = o[n];
    let c = [];
    if (r.isReferenceObject() || r.isValueObject() && r.isArray()) {
      const l = r, { startRow: f, startColumn: m } = l.getRangePosition();
      l.iterator((d, _, C) => {
        const E = this._getValueObjectOfRuntimeData(d), R = _ - f, b = C - m;
        c[R] == null && (c[R] = []), c[R][b] = E;
      });
    } else
      c = [[this._getValueObjectOfRuntimeData(r)]];
    (u[i] === void 0 || u[i] === null) && (u[i] = {}), (u[i][t] === void 0 || u[i][t] === null) && (u[i][t] = {}), u[i][t][e] = c;
  }
  // eslint-disable-next-line max-lines-per-function
  setRuntimeData(i) {
    const e = this._currentRow, t = this._currentColumn, r = this._currentRowCount, n = this.currentColumnCount, s = this._currentSubUnitId, o = this._currentUnitId;
    this._runtimeData[o] == null && (this._runtimeData[o] = {});
    const u = this._runtimeData[o];
    u[s] == null && (u[s] = new de());
    const c = u[s];
    this._unitArrayFormulaRange[o] == null && (this._unitArrayFormulaRange[o] = {});
    const l = this._unitArrayFormulaRange[o];
    (l[s] === null || l[s] === void 0) && (l[s] = {});
    const f = new de(l[s]);
    this._runtimeArrayFormulaCellData[o] === void 0 && (this._runtimeArrayFormulaCellData[o] = {});
    const m = this._runtimeArrayFormulaCellData[o];
    m[s] == null && (m[s] = new de());
    const d = m[s];
    this._runtimeClearArrayFormulaCellData[o] === void 0 && (this._runtimeClearArrayFormulaCellData[o] = {});
    const _ = this._runtimeClearArrayFormulaCellData[o];
    _[s] == null && (_[s] = new de());
    const C = _[s];
    if (i.isReferenceObject() || i.isValueObject() && i.isArray()) {
      const E = i, { startRow: R, startColumn: b, endRow: p, endColumn: V } = E.getRangePosition();
      if (R === p && b === V) {
        const M = E.getFirstCell(), D = this._getValueObjectOfRuntimeData(M);
        c.setValue(e, t, D), C.setValue(e, t, D), Ke.set(
          o,
          s,
          t,
          M.getValue(),
          e,
          !0
        );
        return;
      }
      const S = {
        startRow: e,
        startColumn: t,
        endRow: p - R + e,
        endColumn: V - b + t
      };
      if (f.setValue(e, t, S), this._checkIfArrayFormulaRangeHasData(o, s, e, t, S) || this._checkIfArrayFormulaExceeded(r, n, S)) {
        const M = this._getValueObjectOfRuntimeData(g.create(h.SPILL));
        c.setValue(e, t, M), C.setValue(e, t, M), Ke.set(
          o,
          s,
          t,
          h.SPILL,
          e,
          !0
        );
        const D = this._currentConfigService.getUnitData();
        E.iterator((w, L, v) => {
          var ne, z;
          const j = L - R + e, k = v - b + t, G = (z = (ne = D[o]) == null ? void 0 : ne[s]) == null ? void 0 : z.cellData.getValue(j, k);
          if (L === R && v === b)
            d.setValue(e, t, M);
          else if (G != null)
            G.v == null && (G.v = ""), d.setValue(j, k, G);
          else {
            if (this._isInOtherArrayFormulaRange(o, s, e, t, j, k))
              return !0;
            d.setValue(j, k, { v: "" });
          }
        });
      } else {
        const M = g.create(h.SPILL);
        E.iterator((D, w, L) => {
          Ke.set(
            o,
            s,
            t - b + L,
            D ? D.getValue() : 0,
            e - R + w,
            !0
          );
          const v = this._getValueObjectOfRuntimeData(D);
          if (w === R && L === b) {
            if (D != null && D.isError() && D.isEqualType(M))
              return C.setValue(e, t, {}), c.setValue(e, t, { ...this._getValueObjectOfRuntimeData(M) }), !1;
            c.setValue(e, t, { ...v });
          }
          const j = w - R + e, k = L - b + t;
          d.setValue(j, k, v);
        });
      }
    } else {
      const E = this._getValueObjectOfRuntimeData(i);
      if (c.setValue(e, t, E), i.isString() && i.isImage()) {
        const R = i.getImageInfo();
        R && this._runtimeImageFormulaData.push({
          ...R,
          unitId: o,
          sheetId: s,
          row: e,
          column: t
        });
      }
      Ke.set(
        o,
        s,
        t,
        i.getValue(),
        e,
        !0
      ), C.setValue(e, t, E);
    }
  }
  _getValueObjectOfRuntimeData(i) {
    return i != null && i.isString() && i.isHyperlink() ? this._hyperlinkEngineFormulaService.generateCellValue(
      i.getHyperlinkUrl(),
      i.getValue()
    ) : Dm(i);
  }
  getUnitData() {
    return this._runtimeData;
  }
  getUnitArrayFormula() {
    return this._unitArrayFormulaRange;
  }
  getUnitArrayFormulaEmbeddedMap() {
    return this._unitArrayFormulaEmbeddedMap;
  }
  setUnitArrayFormulaEmbeddedMap() {
    const i = this._currentUnitId, e = this._currentSubUnitId, t = this._currentRow, r = this._currentColumn, n = this._unitArrayFormulaEmbeddedMap;
    n[i] == null && (n[i] = {}), n[i][e] == null && (n[i][e] = {}), n[i][e][t] == null && (n[i][e][t] = {}), n[i][e][t][r] = !0;
  }
  getRuntimeOtherData() {
    return this._runtimeOtherData;
  }
  getRuntimeArrayFormulaCellData() {
    return this._runtimeArrayFormulaCellData;
  }
  getRuntimeClearArrayFormulaCellData() {
    return this._runtimeClearArrayFormulaCellData;
  }
  getRuntimeFeatureRange() {
    return this._runtimeFeatureRange;
  }
  setRuntimeFeatureRange(i, e) {
    this._runtimeFeatureRange[i] = e;
  }
  getRuntimeFeatureCellData() {
    return this._runtimeFeatureCellData;
  }
  setRuntimeFeatureCellData(i, e) {
    this._runtimeFeatureCellData[i] = e;
  }
  getRuntimeImageFormulaData() {
    return this._runtimeImageFormulaData;
  }
  getAllRuntimeData() {
    return {
      unitData: this.getUnitData(),
      arrayFormulaRange: this.getUnitArrayFormula(),
      arrayFormulaEmbedded: this.getUnitArrayFormulaEmbeddedMap(),
      unitOtherData: this.getRuntimeOtherData(),
      functionsExecutedState: this._functionsExecutedState,
      arrayFormulaCellData: this.getRuntimeArrayFormulaCellData(),
      clearArrayFormulaCellData: this.getRuntimeClearArrayFormulaCellData(),
      imageFormulaData: this.getRuntimeImageFormulaData(),
      runtimeFeatureRange: this.getRuntimeFeatureRange(),
      runtimeFeatureCellData: this.getRuntimeFeatureCellData()
    };
  }
  getRuntimeState() {
    return {
      totalFormulasToCalculate: this.getTotalFormulasToCalculate(),
      completedFormulasCount: this.getCompletedFormulasCount(),
      totalArrayFormulasToCalculate: this.getTotalArrayFormulasToCalculate(),
      completedArrayFormulasCount: this.getCompletedArrayFormulasCount(),
      stage: this.getFormulaExecuteStage(),
      formulaCycleIndex: this.getFormulaCycleIndex()
    };
  }
  clearArrayObjectCache() {
    _r.clear();
  }
  // eslint-disable-next-line complexity
  _checkIfArrayFormulaRangeHasData(i, e, t, r, n) {
    var m, d, _, C, E, R, b, p, V, S, M;
    const { startRow: s, startColumn: o, endRow: u, endColumn: c } = n, l = this._currentConfigService.getUnitData(), f = this._currentConfigService.getArrayFormulaCellData();
    (_ = (d = (m = this._unitArrayFormulaRange[i]) == null ? void 0 : m[e]) == null ? void 0 : d[t]) == null || _[r];
    for (let D = s; D <= u; D++)
      for (let w = o; w <= c; w++) {
        if (D === t && r === w)
          continue;
        const L = (R = (E = (C = this._runtimeData) == null ? void 0 : C[i]) == null ? void 0 : E[e]) == null ? void 0 : R.getValue(D, w);
        (p = (b = f == null ? void 0 : f[i]) == null ? void 0 : b[e]) == null || p.getValue(
          D,
          w
        );
        const v = (M = (S = (V = l == null ? void 0 : l[i]) == null ? void 0 : V[e]) == null ? void 0 : S.cellData) == null ? void 0 : M.getValue(D, w), j = this._getRuntimeFeatureCellValue(D, w, e, i);
        if (!En(L) || this._isInOtherArrayFormulaRange(i, e, t, r, D, w) || !En(v) || !En(j))
          return !0;
      }
    return !1;
  }
  _getRuntimeFeatureCellValue(i, e, t, r) {
    return Uo(i, e, t, r, this._runtimeFeatureCellData);
  }
  _arrayCellHasData(i) {
    return i == null ? !1 : i.v !== void 0;
  }
  /**
   * If the current array formula in the extended area intersects with the existing array formula, a #SPILL! error will be reported. Note that if other array formulas are already #SPILL!, they will not conflict with the current array formula
   * @param formulaUnitId
   * @param formulaSheetId
   * @param formulaRow
   * @param formulaColumn
   * @param r
   * @param c
   * @returns
   */
  _isInOtherArrayFormulaRange(i, e, t, r, n, s) {
    var l;
    const o = (l = this._currentConfigService.getArrayFormulaRange()[i]) == null ? void 0 : l[e];
    if (o == null)
      return !1;
    let u = !1;
    return new de(o).forValue((f, m, d) => {
      var E, R;
      if (f === t && m === r)
        return;
      const _ = this._isInArrayFormulaRange(d, n, s), C = (R = (E = this._runtimeData[i]) == null ? void 0 : E[e]) == null ? void 0 : R.getValue(f, m);
      _ && (C == null ? void 0 : C.v) !== h.SPILL && (u = !0);
    }), u;
  }
  _isInArrayFormulaRange(i, e, t) {
    if (i == null)
      return !1;
    const { startRow: r, startColumn: n, endRow: s, endColumn: o } = i;
    return e >= r && e <= s && t >= n && t <= o;
  }
  _checkIfArrayFormulaExceeded(i, e, t) {
    return t.endRow >= i || t.endColumn >= e;
  }
  _isInDirtyRange(i, e, t, r) {
    const n = this._currentConfigService.getDirtyRanges();
    return n.length === 0 ? !0 : Xc(n, i, e, t, r);
  }
};
ra = Im([
  vi(0, Wt),
  vi(1, Xo)
], ra);
const Nt = Je("univer.formula.runtime.service");
var oe = /* @__PURE__ */ ((a) => (a[a.REFERENCE = 1] = "REFERENCE", a[a.VALUE = 2] = "VALUE", a[a.OPERATOR = 3] = "OPERATOR", a[a.FUNCTION = 4] = "FUNCTION", a[a.LAMBDA = 5] = "LAMBDA", a[a.LAMBDA_PARAMETER = 6] = "LAMBDA_PARAMETER", a[a.ERROR = 7] = "ERROR", a[a.BASE = 8] = "BASE", a[a.ROOT = 9] = "ROOT", a[a.UNION = 10] = "UNION", a[a.PREFIX = 11] = "PREFIX", a[a.SUFFIX = 12] = "SUFFIX", a[a.NULL = 13] = "NULL", a))(oe || {});
const Vt = /* @__PURE__ */ new Map([
  [1, 7],
  [2, 9],
  [3, 8],
  [4, 6],
  [5, 1],
  [6, 2],
  [9, 10],
  [10, 3],
  [11, 4],
  [12, 5]
]);
class qe {
  constructor(i) {
    A(this, "_children", []);
    A(this, "_definedNames");
    A(this, "_parent");
    A(this, "_valueObject");
    A(this, "_calculateState", !1);
    A(this, "_async", !1);
    A(this, "_address", !1);
    A(this, "_isForcedCalculateFunction", !1);
    this._token = i;
  }
  dispose() {
    var i;
    this._children.forEach((e) => {
      e.dispose();
    }), (i = this._valueObject) == null || i.dispose(), this._valueObject = null, this._children = [], this._definedNames = null, this._parent = null;
  }
  get nodeType() {
    return oe.BASE;
  }
  resetCalculationState() {
    this._children.forEach((i) => {
      i.resetCalculationState();
    }), this._valueObject = null, this._calculateState = !1;
  }
  isAsync() {
    return this._async;
  }
  isAddress() {
    return this._address;
  }
  isForcedCalculateFunction() {
    return this._isForcedCalculateFunction;
  }
  setAsync() {
    this._async = !0;
  }
  setAddress() {
    this._address = !0;
  }
  getParent() {
    return this._parent;
  }
  setParent(i) {
    this._parent = i, i.addChildren(this);
  }
  setForcedCalculateFunction() {
    this._isForcedCalculateFunction = !0;
  }
  getChildren() {
    return this._children;
  }
  addChildren(...i) {
    this._children.push(...i);
  }
  getToken() {
    return this._token;
  }
  setValue(i) {
    this._valueObject = i;
  }
  getValue() {
    return this._valueObject;
  }
  isCalculated() {
    return this._calculateState;
  }
  setCalculated() {
    this._calculateState = !0;
  }
  execute() {
  }
  setNotEmpty(i = !0) {
  }
  async executeAsync() {
    return Promise.resolve(It.SUCCESS);
  }
  serialize() {
    const i = this.getToken(), e = this.getChildren(), t = [], r = e.length;
    for (let s = 0; s < r; s++) {
      const o = e[s];
      t.push(o.serialize());
    }
    const n = {
      token: i,
      nodeType: this.nodeType
    };
    return r > 0 && (n.children = t), n;
  }
  hasDefinedName(i) {
    var e;
    return ((e = this._definedNames) == null ? void 0 : e.includes(i)) || !1;
  }
  setDefinedNames(i) {
    this._definedNames = i;
  }
  getDefinedNames() {
    return this._definedNames;
  }
}
class Ue extends qe {
  constructor(e) {
    super(e);
    A(this, "_errorValueObject");
    this._errorValueObject = g.create(e);
  }
  get nodeType() {
    return oe.ERROR;
  }
  static create(e) {
    return new Ue(e);
  }
  getValue() {
    return this._errorValueObject;
  }
}
const Ot = 100;
class St {
  get zIndex() {
    return 0;
  }
  dispose() {
  }
  create(i, e, t) {
    let r;
    return i instanceof ie ? r = i.getToken() : r = i, new qe(r);
  }
}
class na extends qe {
  get nodeType() {
    return oe.ROOT;
  }
  execute() {
    const i = this.getChildren();
    if (i.length > 1) {
      this.setValue(g.create(h.VALUE));
      return;
    }
    const e = i[0];
    e == null ? this.setValue(g.create(h.VALUE)) : this.setValue(e.getValue());
  }
}
class Ko extends St {
  get zIndex() {
    return Vt.get(oe.ROOT) || Ot;
  }
  checkAndCreateNodeType(i) {
    if (!(i instanceof ie))
      return;
    if (i.getToken() === Ft)
      return new na(Ft);
  }
}
const Bm = 5e3, Hr = new xt(Bm);
function Ti(a, i, e, t, r) {
  let n = Hr.get(`${a}${i}`);
  if (n && !Zo(n, r))
    return n;
  const s = e.treeBuilder(i);
  if (fr.has(s))
    return Ue.create(s);
  if (n = t.parse(s), n == null)
    throw new Error("astNode is null");
  return Hr.set(`${a}${i}`, n), n;
}
function Zo(a, i) {
  const e = i.getDirtyDefinedNameMap(), t = i.getExecuteUnitId();
  if (t != null && e[t] != null) {
    const r = Object.keys(e[t]);
    for (let n = 0, s = r.length; n < s; n++) {
      const o = r[n];
      if (a.hasDefinedName(o))
        return !0;
    }
  }
  return !1;
}
function Fm(a, i, e) {
  return !!(i != null && Zo(i, e));
}
const Xt = Je("univer.formula-function.service");
class km extends Se {
  constructor() {
    super(...arguments);
    A(this, "_functionExecutors", /* @__PURE__ */ new Map());
    A(this, "_functionDescriptions", /* @__PURE__ */ new Map());
  }
  dispose() {
    super.dispose(), this._functionExecutors.clear(), this._functionDescriptions.clear();
  }
  registerExecutors(...e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      this._functionExecutors.set(r.name, r);
    }
  }
  getExecutors() {
    return this._functionExecutors;
  }
  getExecutor(e) {
    return this._functionExecutors.get(e);
  }
  hasExecutor(e) {
    return this._functionExecutors.has(e);
  }
  unregisterExecutors(...e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      this._functionExecutors.delete(r);
    }
  }
  registerDescriptions(...e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      this._functionDescriptions.set(r.functionName, r);
    }
    return Uc(() => {
      for (let t = 0; t < e.length; t++) {
        const r = e[t];
        this._functionDescriptions.delete(r.functionName);
      }
    });
  }
  getDescriptions() {
    return this._functionDescriptions;
  }
  getDescription(e) {
    return this._functionDescriptions.get(e);
  }
  hasDescription(e) {
    return this._functionDescriptions.has(e);
  }
  unregisterDescriptions(...e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      this._functionDescriptions.delete(r);
    }
  }
  deleteFormulaAstCacheKey(...e) {
    Hr.forEach((t, r) => {
      e.forEach((n) => {
        r.includes(n) && Hr.delete(r);
      });
    });
  }
}
var ke = /* @__PURE__ */ ((a) => (a.COMPARE = "COMPARE", a.DIVIDED = "DIVIDED", a.MINUS = "MINUS", a.MULTIPLY = "MULTIPLY", a.PLUS = "PLUS", a.UNION = "UNION", a.CUBE = "CUBE", a))(ke || {}), $m = Object.getOwnPropertyDescriptor, Ym = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? $m(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, Ii = (a, i) => (e, t) => i(e, t, a);
class jn extends qe {
  constructor(i, e, t) {
    super(e), this._runtimeService = i, this._operatorString = e, this._functionExecutor = t;
  }
  get nodeType() {
    return oe.PREFIX;
  }
  execute() {
    let e = this.getChildren()[0].getValue(), t;
    if (e == null)
      throw new Error("object is null");
    this._operatorString === we.MINUS ? (e.isReferenceObject() && (e = e.toArrayValueObject()), t = this._functionExecutor.calculate(
      y.create(0),
      e
    )) : this._operatorString === we.AT ? t = this._handlerAT(e) : t = g.create(h.VALUE), this.setValue(t);
  }
  _handlerAT(i) {
    if (!i.isReferenceObject())
      return g.create(h.VALUE);
    const e = i;
    if (e.isCell())
      return g.create(h.VALUE);
    const t = this._runtimeService, r = t.currentRow || 0, n = t.currentColumn || 0, s = e.getRangePosition(), { startRow: o, startColumn: u, endRow: c, endColumn: l } = s;
    return l !== u && c !== o || o === c && u === l ? g.create(h.VALUE) : c === o && n >= u && n <= l ? e.getCellByColumn(n) : u === l && r >= o && r <= c ? e.getCellByRow(r) : e.isTable() ? e.getCellByPosition(r) : g.create(h.VALUE);
  }
}
let Un = class extends St {
  constructor(a, i) {
    super(), this._functionService = a, this._runtimeService = i;
  }
  get zIndex() {
    return Vt.get(oe.PREFIX) || Ot;
  }
  checkAndCreateNodeType(a) {
    if (!(a instanceof ie))
      return;
    const i = a.getToken(), e = i.trim();
    if (e.charAt(0) === '"' && e.charAt(e.length - 1) === '"')
      return;
    let t = "";
    if (e === we.MINUS)
      t = ke.MINUS;
    else return e === we.AT ? new jn(this._runtimeService, e) : void 0;
    const r = this._functionService.getExecutor(t);
    return r ? new jn(this._runtimeService, e, r) : (console.error(`No function ${i}`), Ue.create(h.NAME));
  }
};
Un = Ym([
  Ii(0, Xt),
  Ii(1, Nt)
], Un);
function zo(a, i, e) {
  let t, r, n = a;
  const s = n[0];
  let o = 0;
  if (s === we.MINUS) {
    const u = i.getExecutor(ke.MINUS);
    t = new jn(e, we.MINUS, u), o++;
  } else s === we.AT && (r = new jn(e, we.AT), t && r.setParent(t), o++);
  return o > 0 && (n = n.slice(o)), { tokenTrim: n, minusPrefixNode: t, atPrefixNode: r };
}
var Hm = Object.getOwnPropertyDescriptor, Gm = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Hm(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, hr = (a, i) => (e, t) => i(e, t, a);
class Wm extends qe {
  constructor(i, e, t, r, n, s) {
    super(i), this._functionExecutor = e, this._currentConfigService = t, this._runtimeService = r, this._definedNamesService = n, this._formulaDataModel = s, this._functionExecutor.isAsync() && this.setAsync(), this._functionExecutor.isAddress() && this.setAddress(), this._functionExecutor.needsLocale && this._setLocale(), this._functionExecutor.needsSheetsInfo && this._setSheetsInfo(), this._functionExecutor.needsFormulaDataModel && this._functionExecutor.setFormulaDataModel(this._formulaDataModel);
  }
  get nodeType() {
    return oe.FUNCTION;
  }
  async executeAsync() {
    const i = [], e = this.getChildren(), t = e.length;
    this._compatibility();
    for (let s = 0; s < t; s++) {
      const u = e[s].getValue();
      u != null && (u.isReferenceObject() && !this._functionExecutor.needsReferenceObject ? i.push(u.toArrayValueObject()) : i.push(u));
    }
    const r = await this._calculateAsync(i);
    let n;
    return r.isAsyncObject() || r.isAsyncArrayObject() ? n = await r.getValue() : n = r, this._setEmbeddedArrayFormulaToResult(n), this._setRefData(n), this.setValue(n), Promise.resolve(It.SUCCESS);
  }
  execute() {
    const i = [], e = this.getChildren(), t = e.length;
    this._compatibility();
    for (let n = 0; n < t; n++) {
      const o = e[n].getValue();
      o != null && (o.isReferenceObject() && this._functionExecutor.needsFilteredOutRows && this._setFilteredOutRows(o), o.isReferenceObject() && !this._functionExecutor.needsReferenceObject ? i.push(o.toArrayValueObject()) : i.push(o));
    }
    const r = this._calculate(i);
    this._setEmbeddedArrayFormulaToResult(r), this._setRefData(r), this.setValue(r);
  }
  isFunctionExecutorArgumentsIgnoreNumberPattern() {
    return this._functionExecutor.isArgumentsIgnoreNumberPattern();
  }
  /**
   * If it contains an array formula, set the current cell to the cache and send itself as a ref outward
   */
  _setEmbeddedArrayFormulaToResult(i) {
    if (!i.isArray())
      return;
    const e = i.getRowCount(), t = i.getColumnCount();
    e <= 1 && t <= 1 || this._runtimeService.setUnitArrayFormulaEmbeddedMap();
  }
  /**
   * Compatibility handling for special functions.
   */
  _compatibility() {
    this._lookupCompatibility();
  }
  /**
   * The LOOKUP function follows the following rules when dealing with vectors of different sizes:
   *    If the lookup_vector is larger than the result_vector,
   *    the LOOKUP function will ignore the extra portion of the lookup_vector and only use the portion of the result_vector that is the same size as the lookup_vector for lookup and returning results.
   *    If the lookup_vector is smaller than the result_vector,
   *    the LOOKUP function will continue using the last value of the result_vector for lookup and returning results after the last value of the lookup_vector.
   */
  _lookupCompatibility() {
    const i = this.getChildren(), e = i.length;
    if (!this._functionExecutor.needsExpandParams || e !== 3)
      return;
    const t = i[1].getValue(), r = i[2].getValue();
    if (!(t != null && t.isReferenceObject()) && !(r != null && r.isReferenceObject()))
      return;
    let n, s;
    if (t != null && t.isReferenceObject()) {
      const _ = t.getRangeData(), { startRow: C, startColumn: E, endRow: R, endColumn: b } = _;
      n = R - C + 1, s = b - E + 1;
    } else
      n = t != null && t.isArray() ? t.getRowCount() : 1, s = t != null && t.isArray() ? t.getColumnCount() : 1;
    const o = r.getRangeData(), { startRow: u, startColumn: c, endRow: l, endColumn: f } = o, m = l - u + 1, d = f - c + 1;
    n !== m && (o.endRow += n - m), s !== d && (o.endColumn += s - d);
  }
  /**
   * Transform the result of a custom function to a NodeValueType.
   */
  _handleCustomResult(i) {
    var t;
    if (typeof i != "object" || i == null)
      return Pt.create(i);
    const e = qo(i);
    return K.create({
      calculateValueList: e,
      rowCount: e.length,
      columnCount: ((t = e[0]) == null ? void 0 : t.length) || 0,
      unitId: "",
      sheetId: "",
      row: -1,
      column: -1
    });
  }
  _handleAddressFunction() {
    this._functionExecutor.isAddress() && this._setDefinedNamesForFunction();
  }
  _mapVariantsToValues(i) {
    return i.map((e) => e.isArray() ? e.toValue() : e.isLambda() ? e : e.getValue());
  }
  _calculate(i) {
    const { minParams: e, maxParams: t } = this._functionExecutor;
    if (e !== -1 && t !== -1 && (i.length < e || i.length > t))
      return g.create(h.NA);
    let r;
    if (this._setRefInfo(), this._functionExecutor.isCustom()) {
      const n = this._functionExecutor.calculateCustom(
        ...this._mapVariantsToValues(i)
      );
      r = this._handleCustomResult(n);
    } else
      this._handleAddressFunction(), r = this._functionExecutor.calculate(...i);
    return r;
  }
  async _calculateAsync(i) {
    const { minParams: e, maxParams: t } = this._functionExecutor;
    if (e !== -1 && t !== -1 && (i.length < e || i.length > t))
      return g.create(h.NA);
    let r;
    if (this._setRefInfo(), this._functionExecutor.isCustom()) {
      const n = await this._functionExecutor.calculateCustom(
        ...this._mapVariantsToValues(i)
      );
      r = this._handleCustomResult(n);
    } else
      this._handleAddressFunction(), r = this._functionExecutor.calculate(...i);
    return r;
  }
  _setDefinedNamesForFunction() {
    const i = this._currentConfigService.getExecuteUnitId();
    if (i == null)
      return;
    const e = this._definedNamesService.getDefinedNameMap(i);
    e != null && this._functionExecutor.setDefinedNames(e);
  }
  _setRefInfo() {
    const { currentUnitId: i, currentSubUnitId: e, currentRow: t, currentColumn: r } = this._runtimeService;
    if (this._functionExecutor.setRefInfo(i, e, t, r), this._functionExecutor.needsSheetRowColumnCount) {
      const { rowCount: n, columnCount: s } = this._currentConfigService.getSheetRowColumnCount(i, e);
      this._functionExecutor.setSheetRowColumnCount(n, s);
    }
  }
  _setRefData(i) {
    if (!i.isReferenceObject())
      return;
    const e = i;
    e.setForcedSheetId(this._currentConfigService.getSheetNameMap()), e.setUnitData(this._currentConfigService.getUnitData()), e.setArrayFormulaCellData(this._currentConfigService.getArrayFormulaCellData()), e.setRuntimeData(this._runtimeService.getUnitData()), e.setRuntimeArrayFormulaCellData(this._runtimeService.getRuntimeArrayFormulaCellData()), e.setRuntimeFeatureCellData(this._runtimeService.getRuntimeFeatureCellData());
  }
  _setLocale() {
    this._functionExecutor.setLocale(this._currentConfigService.getLocale());
  }
  _setSheetsInfo() {
    this._functionExecutor.setSheetsInfo(this._currentConfigService.getSheetsInfo());
  }
  _setFilteredOutRows(i) {
    const { startRow: e, endRow: t } = i.getRangePosition(), r = this._currentConfigService.getFilteredOutRows(
      i.getUnitId(),
      i.getSheetId(),
      e,
      t
    );
    i.setFilteredOutRows(r);
  }
}
class Qm extends qe {
  constructor(i = "Error") {
    super(i);
  }
  get nodeType() {
    return oe.FUNCTION;
  }
  async executeAsync() {
    return this.setValue(g.create(h.NAME)), Promise.resolve(It.SUCCESS);
  }
  execute() {
    this.setValue(g.create(h.NAME));
  }
}
let vn = class extends St {
  constructor(a, i, e, t, r, n) {
    super(), this._functionService = a, this._currentConfigService = i, this._runtimeService = e, this._definedNamesService = t, this._injector = r, this._formulaDataModel = n;
  }
  get zIndex() {
    return Vt.get(oe.FUNCTION) || Ot;
  }
  create(a) {
    const i = this._functionService.getExecutor(a);
    return i ? new Wm(
      a,
      i,
      this._currentConfigService,
      this._runtimeService,
      this._definedNamesService,
      this._formulaDataModel
    ) : (console.error(`No function ${a}`), Ue.create(h.NAME));
  }
  checkAndCreateNodeType(a) {
    if (typeof a == "string")
      return;
    const i = a.getToken(), { tokenTrim: e, minusPrefixNode: t, atPrefixNode: r } = zo(i.trim(), this._functionService, this._runtimeService);
    if (!Number.isNaN(Number(e)) && !this._isParentUnionNode(a))
      return Ue.create(h.VALUE);
    const n = e.toUpperCase();
    if (this._functionService.hasExecutor(n)) {
      const s = this.create(n);
      return r ? s.setParent(r) : t && s.setParent(t), s;
    }
  }
  _isParentUnionNode(a) {
    var i, e;
    return ((e = (i = a.getParent()) == null ? void 0 : i.getParent()) == null ? void 0 : e.getToken()) === X.COLON;
  }
};
vn = Gm([
  hr(0, Xt),
  hr(1, Wt),
  hr(2, Nt),
  hr(3, Lr),
  hr(4, ye(fo)),
  hr(5, ye(yr))
], vn);
var qm = Object.getOwnPropertyDescriptor, Xm = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? qm(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, Km = (a, i) => (e, t) => i(e, t, a);
let Vr = class extends Se {
  constructor(a) {
    super(), this._runtimeService = a;
  }
  async executeAsync(a) {
    if (!a || !a.node)
      return Promise.resolve(g.create(h.VALUE));
    const i = a.node, e = a.refOffsetX, t = a.refOffsetY;
    await this._executeAsync(i, e, t);
    const r = i.getValue();
    return r == null ? Promise.resolve(g.create(h.VALUE)) : Promise.resolve(r);
  }
  execute(a) {
    if (!a || !a.node)
      return g.create(h.VALUE);
    const i = a.node, e = a.refOffsetX, t = a.refOffsetY;
    this._execute(i, e, t);
    const r = i.getValue();
    return r == null ? g.create(h.VALUE) : r;
  }
  executePreCalculateNode(a) {
    return a.execute(), a.getValue();
  }
  checkAsyncNode(a) {
    if (a == null)
      return !1;
    const i = [];
    this._checkAsyncNode(a, i);
    for (let e = 0, t = i.length; e < t; e++)
      if (i[e] === !0)
        return !0;
    return !1;
  }
  _checkAsyncNode(a, i) {
    const e = a.getChildren(), t = e.length;
    for (let r = 0; r < t; r++) {
      const n = e[r];
      i.push(n.isAsync()), this._checkAsyncNode(n, i);
    }
  }
  async _executeAsync(a, i = 0, e = 0) {
    if (this._runtimeService.isStopExecution())
      return Promise.resolve(It.ERROR);
    const t = a.getChildren(), r = t.length;
    for (let n = 0; n < r; n++) {
      const s = t[n];
      if (s.getToken().toUpperCase() === Fr && s.isEmptyParamFunction()) {
        s.execute();
        continue;
      }
      await this._executeAsync(s, i, e);
    }
    return a.nodeType === oe.REFERENCE && a.setRefOffset(i, e), a.nodeType === oe.FUNCTION && a.isAsync() ? await a.executeAsync() : a.execute(), Promise.resolve(It.SUCCESS);
  }
  _execute(a, i = 0, e = 0) {
    if (this._runtimeService.isStopExecution())
      return It.ERROR;
    const t = a.getChildren(), r = t.length;
    for (let n = 0; n < r; n++) {
      const s = t[n];
      if (s.getToken().toUpperCase() === Fr && s.isEmptyParamFunction()) {
        s.execute();
        continue;
      }
      this._execute(s, i, e);
    }
    return a.nodeType === oe.REFERENCE && a.setRefOffset(i, e), a.execute(), It.SUCCESS;
  }
};
Vr = Xm([
  Km(0, Nt)
], Vr);
function Jo(a) {
  return a instanceof ie ? a.getToken() === Rr : !1;
}
function Zm(a) {
  return a instanceof ie ? a.getToken() === yo : !1;
}
function Pa(a, i, e) {
  const t = a.getChildren(), r = t.length, n = t[0];
  for (let s = 0; s < r; s++) {
    const o = t[s];
    if (!(Jo(n) && s !== 0))
      if (o instanceof ie)
        Pa(o, i, e);
      else {
        const u = o.trim();
        if (e.has(u)) {
          const c = new ie();
          c.setToken(Xr), c.setLambdaId(i), c.setLambdaPrivacyVar(e), c.setLambdaParameter(u), t[s] = c;
        }
      }
  }
}
function zm(a) {
  let i = a;
  for (; i != null && i.getParent(); )
    i = i.getParent();
  return i;
}
function Bi(a, i = 0, e = 0) {
  return {
    node: a,
    refOffsetX: i,
    refOffsetY: e
  };
}
function eu(a) {
  if (!a)
    return;
  if (a.getToken() !== Xr)
    return a;
  const i = a, e = i.getCurrentLambdaPrivacyVar(), t = i.getLambdaParameter();
  if (!e)
    return;
  const r = e.get(t);
  return r == null && a.getValue() ? a : eu(r);
}
class xa extends Qt {
  constructor(e, t, r) {
    super(0);
    A(this, "_lambdaPrivacyValueMap", /* @__PURE__ */ new Map());
    this._lambdaNode = e, this._interpreter = t, this._lambdaPrivacyVarKeys = r, this._lambdaPrivacyValueMap.clear();
  }
  static create(e, t, r) {
    return new xa(e, t, r);
  }
  dispose() {
    this._lambdaPrivacyValueMap.clear(), this._lambdaPrivacyValueMap = /* @__PURE__ */ new Map(), this._lambdaNode = null, this._interpreter = null, this._lambdaPrivacyVarKeys = [];
  }
  isLambda() {
    return !0;
  }
  execute(...e) {
    const t = this._lambdaPrivacyVarKeys.length;
    if (e.length !== t || !this._interpreter || !this._lambdaNode)
      return g.create(h.VALUE);
    this._setLambdaPrivacyValueMap(e), this._setLambdaNodeValue(this._lambdaNode), this._lambdaNode.setNotEmpty(!1);
    let r;
    if (this._interpreter.checkAsyncNode(this._lambdaNode))
      r = new Vm(this._interpreter.executeAsync(Bi(this._lambdaNode)));
    else {
      const n = this._interpreter.execute(Bi(this._lambdaNode));
      n.isReferenceObject() ? r = n.toArrayValueObject() : r = n;
    }
    return this._lambdaNode.setNotEmpty(!0), r;
  }
  /**
   * Execute custom lambda function, handle basic types
   * @param variants
   */
  executeCustom(...e) {
    const t = e.map((r) => Pt.create(r));
    return this.execute(...t);
  }
  _setLambdaNodeValue(e) {
    if (!e)
      return;
    const t = e.getChildren(), r = t.length;
    for (let n = 0; n < r; n++) {
      const s = t[n];
      if (s.getToken() === Xr) {
        const u = s.getLambdaParameter(), c = this._lambdaPrivacyValueMap.get(u);
        if (c)
          s.setValue(c);
        else {
          const l = s.getCurrentLambdaPrivacyVar(), f = eu(l.get(u));
          f != null && s.setValue(f.getValue());
        }
        continue;
      }
      this._setLambdaNodeValue(s);
    }
  }
  _setLambdaPrivacyValueMap(e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t], n = this._lambdaPrivacyVarKeys[t];
      this._lambdaPrivacyValueMap.set(n, r);
    }
  }
  getLambdaPrivacyVarKeys() {
    return this._lambdaPrivacyVarKeys;
  }
}
var Jm = Object.getOwnPropertyDescriptor, eh = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Jm(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, Fi = (a, i) => (e, t) => i(e, t, a);
class th extends qe {
  constructor(e, t, r, n, s) {
    super(e);
    A(this, "_isNotEmpty", !0);
    this._lambdaId = t, this._interpreter = r, this._lambdaPrivacyVarKeys = n, this._runtimeService = s;
  }
  get nodeType() {
    return oe.LAMBDA;
  }
  setNotEmpty(e = !1) {
    this._isNotEmpty = e;
  }
  isEmptyParamFunction() {
    return this.getChildren().length < 2 && this._isNotEmpty;
  }
  isFunctionParameter() {
    return this._lambdaId === null;
  }
  getLambdaId() {
    return this._lambdaId;
  }
  execute() {
    if (this.isEmptyParamFunction())
      this.setValue(xa.create(this, this._interpreter, this._lambdaPrivacyVarKeys));
    else {
      const e = this.getChildren(), t = e.length;
      this.setValue(e[t - 1].getValue());
    }
    this._runtimeService.setUnitArrayFormulaEmbeddedMap();
  }
  // override async executeAsync() {
  //     if (this.isEmptyParamFunction()) {
  //         await this.setValue(LambdaValueObjectObject.create(this, this._interpreter, this._lambdaPrivacyVarKeys));
  //     } else {
  //         const children = this.getChildren();
  //         const childrenCount = children.length;
  //         await this.setValue(children[childrenCount - 1].getValue());
  //     }
  //     return Promise.resolve(AstNodePromiseType.SUCCESS);
  // }
}
let Tn = class extends St {
  constructor(a, i) {
    super(), this._runtimeService = a, this._interpreter = i;
  }
  get zIndex() {
    return Vt.get(oe.LAMBDA) || Ot;
  }
  create(a) {
    const i = a.getChildren(), e = i[0];
    let t = i.slice(1, -1);
    const r = i[i.length - 1];
    if (!(e instanceof ie && r instanceof ie))
      return Ue.create(h.NAME);
    if (e.getToken() === Rr) {
      const o = e.getChildren();
      if (t.length !== o.length)
        return Ue.create(h.VALUE);
    } else
      t = i.slice(0, -1);
    const n = vc(8), s = /* @__PURE__ */ new Map();
    for (let o = 0; o < t.length; o++) {
      const u = t[o];
      if (u instanceof ie) {
        const c = u.getChildren()[0];
        u.setToken(yo), s.set(c.trim(), void 0);
      } else
        return Ue.create(h.VALUE);
    }
    return this._runtimeService.registerFunctionDefinitionPrivacyVar(n, s), this._updateLambdaStatement(r, n, s), new th(a.getToken(), n, this._interpreter, [...s.keys()], this._runtimeService);
  }
  checkAndCreateNodeType(a) {
    if (!(!(a instanceof ie) || a.getToken().trim().toUpperCase() !== Fr))
      return this.create(a);
  }
  _updateLambdaStatement(a, i, e) {
    Pa(a, i, e);
  }
};
Tn = eh([
  Fi(0, Nt),
  Fi(1, ye(Vr))
], Tn);
function tu(a) {
  if (!a)
    return;
  if (a.getToken() !== Xr)
    return a;
  const i = a, e = i.getCurrentLambdaPrivacyVar(), t = i.getLambdaParameter();
  if (e)
    return tu(e.get(t));
}
class rh extends qe {
  constructor(i, e, t) {
    super(i), this._lambdaParameter = e, this._currentLambdaPrivacyVar = t;
  }
  getLambdaParameter() {
    return this._lambdaParameter;
  }
  getCurrentLambdaPrivacyVar() {
    return this._currentLambdaPrivacyVar;
  }
  get nodeType() {
    return oe.LAMBDA_PARAMETER;
  }
  execute() {
    const i = tu(this._currentLambdaPrivacyVar.get(this._lambdaParameter));
    if (i)
      this.setValue(i.getValue());
    else {
      const e = this.getValue();
      (e == null || e.isError()) && this.setValue(g.create(h.NAME));
    }
  }
}
class ru extends St {
  get zIndex() {
    return Vt.get(oe.LAMBDA_PARAMETER) || Ot;
  }
  create(i) {
    const e = i.getFunctionDefinitionPrivacyVar(), t = i.getLambdaParameter();
    return e ? new rh(i.getToken(), t, e) : new Ue(h.NAME);
  }
  checkAndCreateNodeType(i) {
    if (!(!(i instanceof ie) || i.getToken().trim() !== Xr))
      return this.create(i);
  }
}
class nh extends qe {
  constructor(i) {
    super(i), this._operatorString = i;
  }
  get nodeType() {
    return oe.NULL;
  }
  execute() {
    this.setValue(ce.create());
  }
}
var F = /* @__PURE__ */ ((a) => (a.ABS = "ABS", a.ACOS = "ACOS", a.ACOSH = "ACOSH", a.ACOT = "ACOT", a.ACOTH = "ACOTH", a.AGGREGATE = "AGGREGATE", a.ARABIC = "ARABIC", a.ASIN = "ASIN", a.ASINH = "ASINH", a.ATAN = "ATAN", a.ATAN2 = "ATAN2", a.ATANH = "ATANH", a.BASE = "BASE", a.CEILING = "CEILING", a.CEILING_MATH = "CEILING.MATH", a.CEILING_PRECISE = "CEILING.PRECISE", a.COMBIN = "COMBIN", a.COMBINA = "COMBINA", a.COS = "COS", a.COSH = "COSH", a.COT = "COT", a.COTH = "COTH", a.CSC = "CSC", a.CSCH = "CSCH", a.DECIMAL = "DECIMAL", a.DEGREES = "DEGREES", a.EVEN = "EVEN", a.EXP = "EXP", a.FACT = "FACT", a.FACTDOUBLE = "FACTDOUBLE", a.FLOOR = "FLOOR", a.FLOOR_MATH = "FLOOR.MATH", a.FLOOR_PRECISE = "FLOOR.PRECISE", a.GCD = "GCD", a.INT = "INT", a.ISO_CEILING = "ISO.CEILING", a.LCM = "LCM", a.LET = "LET", a.LN = "LN", a.LOG = "LOG", a.LOG10 = "LOG10", a.MDETERM = "MDETERM", a.MINVERSE = "MINVERSE", a.MMULT = "MMULT", a.MOD = "MOD", a.MROUND = "MROUND", a.MULTINOMIAL = "MULTINOMIAL", a.MUNIT = "MUNIT", a.ODD = "ODD", a.PI = "PI", a.POWER = "POWER", a.PRODUCT = "PRODUCT", a.QUOTIENT = "QUOTIENT", a.RADIANS = "RADIANS", a.RAND = "RAND", a.RANDARRAY = "RANDARRAY", a.RANDBETWEEN = "RANDBETWEEN", a.ROMAN = "ROMAN", a.ROUND = "ROUND", a.ROUNDBANK = "ROUNDBANK", a.ROUNDDOWN = "ROUNDDOWN", a.ROUNDUP = "ROUNDUP", a.SEC = "SEC", a.SECH = "SECH", a.SERIESSUM = "SERIESSUM", a.SEQUENCE = "SEQUENCE", a.SIGN = "SIGN", a.SIN = "SIN", a.SINH = "SINH", a.SQRT = "SQRT", a.SQRTPI = "SQRTPI", a.SUBTOTAL = "SUBTOTAL", a.SUM = "SUM", a.SUMIF = "SUMIF", a.SUMIFS = "SUMIFS", a.SUMPRODUCT = "SUMPRODUCT", a.SUMSQ = "SUMSQ", a.SUMX2MY2 = "SUMX2MY2", a.SUMX2PY2 = "SUMX2PY2", a.SUMXMY2 = "SUMXMY2", a.TAN = "TAN", a.TANH = "TANH", a.TRUNC = "TRUNC", a))(F || {}), J = /* @__PURE__ */ ((a) => (a.ASC = "ASC", a.ARRAYTOTEXT = "ARRAYTOTEXT", a.BAHTTEXT = "BAHTTEXT", a.CHAR = "CHAR", a.CLEAN = "CLEAN", a.CODE = "CODE", a.CONCAT = "CONCAT", a.CONCATENATE = "CONCATENATE", a.DBCS = "DBCS", a.DOLLAR = "DOLLAR", a.EXACT = "EXACT", a.FIND = "FIND", a.FINDB = "FINDB", a.FIXED = "FIXED", a.LEFT = "LEFT", a.LEFTB = "LEFTB", a.LEN = "LEN", a.LENB = "LENB", a.LOWER = "LOWER", a.MID = "MID", a.MIDB = "MIDB", a.NUMBERSTRING = "NUMBERSTRING", a.NUMBERVALUE = "NUMBERVALUE", a.PHONETIC = "PHONETIC", a.PROPER = "PROPER", a.REGEXEXTRACT = "REGEXEXTRACT", a.REGEXMATCH = "REGEXMATCH", a.REGEXREPLACE = "REGEXREPLACE", a.REPLACE = "REPLACE", a.REPLACEB = "REPLACEB", a.REPT = "REPT", a.RIGHT = "RIGHT", a.RIGHTB = "RIGHTB", a.SEARCH = "SEARCH", a.SEARCHB = "SEARCHB", a.SUBSTITUTE = "SUBSTITUTE", a.T = "T", a.TEXT = "TEXT", a.TEXTAFTER = "TEXTAFTER", a.TEXTBEFORE = "TEXTBEFORE", a.TEXTJOIN = "TEXTJOIN", a.TEXTSPLIT = "TEXTSPLIT", a.TRIM = "TRIM", a.UNICHAR = "UNICHAR", a.UNICODE = "UNICODE", a.UPPER = "UPPER", a.VALUE = "VALUE", a.VALUETOTEXT = "VALUETOTEXT", a.CALL = "CALL", a.EUROCONVERT = "EUROCONVERT", a.REGISTER_ID = "REGISTER.ID", a))(J || {}), sh = Object.getOwnPropertyDescriptor, ah = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? sh(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, ki = (a, i) => (e, t) => i(e, t, a);
class ih extends qe {
  constructor(i, e, t) {
    super(i), this._functionExecutor = e, this._runtimeService = t;
  }
  get nodeType() {
    return oe.OPERATOR;
  }
  execute() {
    const i = this.getChildren();
    this._functionExecutor.name === ke.COMPARE && this._functionExecutor.setCompareType(this.getToken());
    const e = i[0], t = i[1];
    let r = e == null ? void 0 : e.getValue(), n = t == null ? void 0 : t.getValue();
    const s = this.getToken();
    if ((r == null || n == null) && s !== Z.MINUS && s !== Z.PLUS) {
      this.setValue(g.create(h.VALUE));
      return;
    }
    r == null && (r = ce.create()), n == null && (n = ce.create()), r.isReferenceObject() && (r = r.toArrayValueObject()), n.isReferenceObject() && (n = n.toArrayValueObject());
    const o = this._functionExecutor.calculate(
      r,
      n
    );
    this._setEmbeddedArrayFormulaToResult(o), this.setValue(o);
  }
  /**
   * If it contains an array formula, set the current cell to the cache and send itself as a ref outward
   */
  _setEmbeddedArrayFormulaToResult(i) {
    if (!i.isArray())
      return;
    const e = i.getRowCount(), t = i.getColumnCount();
    e <= 1 && t <= 1 || this._runtimeService.setUnitArrayFormulaEmbeddedMap();
  }
}
let In = class extends St {
  constructor(a, i) {
    super(), this._functionService = a, this._runtimeService = i;
  }
  get zIndex() {
    return Vt.get(oe.OPERATOR) || Ot;
  }
  create(a) {
    let i = "";
    const e = a;
    e === Z.PLUS ? i = ke.PLUS : e === Z.MINUS ? i = ke.MINUS : e === Z.MULTIPLY ? i = ke.MULTIPLY : e === Z.DIVIDED ? i = ke.DIVIDED : e === Z.CONCATENATE ? i = J.CONCATENATE : e === Z.POWER ? i = F.POWER : Zc.has(e) && (i = ke.COMPARE);
    const t = this._functionService.getExecutor(i);
    return t ? new ih(e, t, this._runtimeService) : (console.error(`No function ${a}`), Ue.create(h.NAME));
  }
  checkAndCreateNodeType(a) {
    if (a instanceof ie)
      return;
    const i = a.trim();
    if (!(i.charAt(0) === '"' && i.charAt(i.length - 1) === '"') && Mt.has(i))
      return this.create(i);
  }
};
In = ah([
  ki(0, Xt),
  ki(1, Nt)
], In);
class oh extends jr {
  constructor(e, t, r, n) {
    super(e);
    A(this, "_isCurrentRowForRange", !1);
    this._tableData = t, this._columnDataString = r, this._tableOptionMap = n;
    const { sheetId: s, range: o, titleMap: u } = this._tableData;
    this.setForcedSheetIdDirect(s);
    const { startColumn: c, endColumn: l, type: f } = this._parseStructuredRef(this._columnDataString, u), m = o.startRow, d = o.endRow;
    let _ = -1, C = -1;
    switch (f) {
      case De.ALL:
        _ = m, C = d;
        break;
      case De.DATA:
        _ = m + 1, C = d;
        break;
      case De.HEADERS:
        _ = m, C = m;
        break;
      case De.TOTALS:
        _ = d, C = d;
        break;
      case De.THIS_ROW: {
        const E = this._resolveThisRow(m, d);
        _ = E, C = E;
        break;
      }
      default:
        _ = m + 1, C = d;
        break;
    }
    this.setRangeData({
      startColumn: c,
      endColumn: l,
      startRow: _,
      endRow: C
    });
  }
  getRangeData() {
    const e = super.getRangeData();
    if (this._isCurrentRowForRange) {
      const { startRow: t, startColumn: r, endRow: n, endColumn: s } = e, o = this.getCurrentRow();
      return {
        startRow: o == null ? t : o,
        endRow: o == null ? n : o,
        startColumn: r,
        endColumn: s
      };
    }
    return e;
  }
  getRefOffset() {
    return {
      x: 0,
      y: 0
    };
  }
  isTable() {
    return !0;
  }
  isCurrentRowForRange() {
    return this._isCurrentRowForRange;
  }
  setForcedSheetId(e) {
  }
  /**
   * Parse structured reference body, returning column range and Section type.
   * Determination rules:
   *  - Whether it's a Section depends on "whether it starts with # after stripping", not whether it still has brackets.
   *  - No comma: Either Section, or column/column range
   *  - Has comma: Left is Section, right is column/column range
   */
  _parseStructuredRef(e, t) {
    var C, E;
    const { range: r } = this._tableData, n = (C = r.startColumn) != null ? C : 0, s = (E = r.endColumn) != null ? E : 0;
    if (!e || e.trim().length === 0)
      return { startColumn: n, endColumn: s, type: De.DATA };
    const o = e.trim();
    if (o[0] !== "[") {
      const R = this._mapSection(o);
      if (R !== void 0)
        return { startColumn: n, endColumn: s, type: R };
      const { startColumn: b, endColumn: p } = this._parseColumnOrRange(o, t, n);
      return { startColumn: b, endColumn: p, type: De.DATA };
    }
    const u = this._stripOuterBracketOnce(o), c = this._findCommaAtTopLevel(u);
    if (u.length === 0)
      return { startColumn: n, endColumn: s, type: De.DATA };
    if (c === -1) {
      if (u.startsWith("#")) {
        const p = this._mapSection(u);
        return p !== void 0 ? { startColumn: n, endColumn: s, type: p } : { startColumn: n, endColumn: s, type: De.DATA };
      }
      const { startColumn: R, endColumn: b } = this._parseColumnOrRange(u, t, n);
      return { startColumn: R, endColumn: b, type: De.DATA };
    }
    const l = u.slice(0, c).trim(), f = u.slice(c + 1).trim(), m = this._parseSectionMaybeBracketed(l), { startColumn: d, endColumn: _ } = this._parseColumnOrRange(f, t, n);
    return { startColumn: d, endColumn: _, type: m };
  }
  /** Strip one layer of outer brackets from "[...]" (return as-is if none) */
  _stripOuterBracketOnce(e) {
    return e.length >= 2 && e[0] === "[" && e[e.length - 1] === "]" ? e.slice(1, -1) : e;
  }
  /**
   * Find first comma at depth=0 (used to split Section and column parts)
   * Compatible with nesting like "[[#Data],[ColA]:[ColB]]".
   */
  _findCommaAtTopLevel(e) {
    let t = 0;
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      if (n === "[") t++;
      else if (n === "]") t = Math.max(0, t - 1);
      else if (n === X.COMMA && t === 0) return r;
    }
    return -1;
  }
  /**
   * Parse Section, compatible with both "[#Data]" and "#Data" inputs
   * Returns TableOptionType if matched; returns DATA if not (could throw error instead)
   */
  _parseSectionMaybeBracketed(e) {
    const t = e.trim(), r = t.startsWith("[") && t.endsWith("]") ? this._stripOuterBracketOnce(t) : t, n = this._mapSection(r);
    return n != null ? n : De.DATA;
  }
  /**
   * Section mapping: Only accepts keywords starting with #.
   * Returns undefined if not a valid Section (caller treats as column or fallback).
   */
  _mapSection(e) {
    const t = e.trim();
    if (!t.startsWith("#")) return;
    const r = this._tableOptionMap.get(t);
    if (r !== void 0) return r;
    const n = t.replace(/\s+/g, " ").toLowerCase();
    for (const [s, o] of this._tableOptionMap.entries())
      if (s.replace(/\s+/g, " ").toLowerCase() === n) return o;
  }
  /**
   * Parse column selection:
   * - "[Col]" / "Col"               => Single column
   * - "[[ColA]:[ColB]]" / "[ColA]:[ColB]" / "ColA:ColB"  => Column range
   *
   * Rules:
   * - First find colon at top level, strip one layer of brackets from left and right sides (if present)
   * - Returns -1 if column name not found (caller should handle as parse error)
   */
  _parseColumnOrRange(e, t, r) {
    const n = e.trim(), s = this._findColonAtTopLevel(n);
    if (s === -1) {
      const d = this._stripOuterBracketIfAny(n), _ = this._titleToIndex(d, t);
      return { startColumn: r + _, endColumn: +r + _ };
    }
    const o = n.slice(0, s).trim(), u = n.slice(s + 1).trim(), c = this._stripOuterBracketIfAny(o), l = this._stripOuterBracketIfAny(u), f = this._titleToIndex(c, t), m = this._titleToIndex(l, t);
    return f !== -1 && m !== -1 && f > m ? { startColumn: r + m, endColumn: r + f } : { startColumn: r + f, endColumn: r + m };
  }
  /** Strip one layer of outer brackets; return as-is if none (compatible with "[Col]" and "Col") */
  _stripOuterBracketIfAny(e) {
    return e.length >= 2 && e[0] === "[" && e[e.length - 1] === "]" ? e.slice(1, -1) : e;
  }
  /** Find range colon at depth=0 */
  _findColonAtTopLevel(e) {
    let t = 0;
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      if (n === "[") t++;
      else if (n === "]") t = Math.max(0, t - 1);
      else if (n === X.COLON && t === 0) return r;
    }
    return -1;
  }
  /** Column title → column index; returns -1 if not found (caller should handle as parse error) */
  _titleToIndex(e, t) {
    var o;
    const r = e.trim(), n = t.get(r);
    if (n !== void 0) return n;
    const s = r.replace(/\u3000/g, " ").trim();
    return (o = t.get(s)) != null ? o : -1;
  }
  /** Resolve #This Row's row number; takes first data row (tableStartRow+1) when no context available */
  _resolveThisRow(e, t) {
    return this._isCurrentRowForRange = !0, Math.min(e + 1, t);
  }
}
var uh = Object.getOwnPropertyDescriptor, ch = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? uh(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, un = (a, i) => (e, t) => i(e, t, a);
class $i extends qe {
  constructor(e, t, r, n, s = !1, o) {
    super(r);
    A(this, "_refOffsetX", 0);
    A(this, "_refOffsetY", 0);
    this._currentConfigService = e, this._runtimeService = t, this._referenceObjectType = n, this._isPrepareMerge = s, this._tableReferenceObject = o;
  }
  get nodeType() {
    return oe.REFERENCE;
  }
  execute() {
    const e = this._currentConfigService, t = this._runtimeService, r = this._tableReferenceObject || Pm(this.getToken(), this._referenceObjectType);
    r.setDefaultUnitId(t.currentUnitId), r.setDefaultSheetId(t.currentSubUnitId), r.setForcedSheetId(e.getSheetNameMap()), r.setUnitData(e.getUnitData()), r.setArrayFormulaCellData(e.getArrayFormulaCellData()), r.setRuntimeData(t.getUnitData()), r.setUnitStylesData(e.getUnitStylesData()), r.setRuntimeArrayFormulaCellData(t.getRuntimeArrayFormulaCellData()), r.setRuntimeFeatureCellData(t.getRuntimeFeatureCellData());
    const n = t.currentRow, s = t.currentColumn;
    r.setCurrentRowAndColumn(n, s);
    const { x: o, y: u } = this.getRefOffset();
    r.setRefOffset(o, u), !this._isPrepareMerge && r.isExceedRange() ? this.setValue(g.create(h.NAME)) : this.setValue(r);
  }
  setRefOffset(e = 0, t = 0) {
    this._refOffsetX = e, this._refOffsetY = t;
  }
  getRefOffset() {
    return {
      x: this._refOffsetX,
      y: this._refOffsetY
    };
  }
}
let Bn = class extends St {
  constructor(a, i, e, t) {
    super(), this._currentConfigService = a, this._formulaRuntimeService = i, this._functionService = e, this._superTableService = t;
  }
  get zIndex() {
    return Vt.get(oe.REFERENCE) || Ot;
  }
  checkAndCreateNodeType(a) {
    var u, c;
    let i = !1, e, t = !1;
    a instanceof ie ? (i = !0, e = a.getToken().trim(), ((c = (u = a.getParent()) == null ? void 0 : u.getParent()) == null ? void 0 : c.getToken().trim()) === X.COLON && (t = !0)) : e = a.trim();
    const { tokenTrim: r, minusPrefixNode: n, atPrefixNode: s } = zo(e, this._functionService, this._formulaRuntimeService);
    if (!i && r.charAt(0) === '"' && r.charAt(r.length - 1) === '"')
      return;
    const o = this._getNode(r, i, t, a);
    if (o)
      return s ? o.setParent(s) : n && o.setParent(n), o;
  }
  _getTableMap() {
    const a = this._currentConfigService.getExecuteUnitId();
    if (a)
      return this._superTableService.getTableMap(a);
  }
  _getNode(a, i, e, t) {
    var d;
    const r = this._currentConfigService, n = this._formulaRuntimeService, s = (_) => new $i(r, n, a, _, e);
    if (qr(a))
      return s(Tr.CELL);
    const u = i && this._checkParentIsUnionOperator(t);
    if (u && Eo(a))
      return s(Tr.ROW);
    if (u && Ro(a))
      return s(Tr.COLUMN);
    const f = this._getTableMap();
    return ((d = f == null ? void 0 : f.has(a)) != null ? d : !1) ? this._getTableReferenceNode(a, i, e, !0) : this._getTableReferenceNode(a, i, e, !1);
  }
  _getTableReferenceNode(a, i, e, t = !1) {
    if (!this._checkTokenIsTableReference(a) && !t)
      return;
    const { tableName: r, columnStruct: n } = this._splitTableStructuredRef(a), s = this._getTableMap();
    if (!i && (s != null && s.has(r))) {
      const o = n, u = s.get(r), c = this._superTableService.getTableOptionMap();
      return new $i(
        this._currentConfigService,
        this._formulaRuntimeService,
        a,
        Tr.COLUMN,
        e,
        new oh(a, u, o, c)
      );
    }
  }
  _splitTableStructuredRef(a) {
    const i = a.indexOf("[");
    return i === -1 ? { tableName: a, struct: "" } : {
      tableName: a.slice(0, i),
      columnStruct: a.slice(i)
      // 包含外层 [[...]]
    };
  }
  _checkTokenIsTableReference(a) {
    return _l(a) || Al(a) || El(a) || Rl(a);
  }
  _checkParentIsUnionOperator(a) {
    var i, e;
    return ((e = (i = a.getParent()) == null ? void 0 : i.getParent()) == null ? void 0 : e.getToken().trim()) === X.COLON;
  }
};
Bn = ch([
  un(0, Wt),
  un(1, Nt),
  un(2, Xt),
  un(3, Pr)
], Bn);
var lh = Object.getOwnPropertyDescriptor, fh = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? lh(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, Ss = (a, i) => (e, t) => i(e, t, a);
class Yi extends qe {
  constructor(i, e, t, r) {
    super(t), this._currentConfigService = i, this._lexer = e, this._operatorString = t, this._functionExecutor = r;
  }
  get nodeType() {
    return oe.SUFFIX;
  }
  execute() {
    var r;
    let e = (r = this.getChildren()[0]) == null ? void 0 : r.getValue(), t;
    if (e == null) {
      this.setValue(g.create(h.ERROR));
      return;
    }
    if (this._operatorString === nt.PERCENTAGE) {
      if (e.isReferenceObject() && (e = e.toArrayValueObject()), t = this._functionExecutor.calculate(
        e,
        y.create(100)
      ), t.isNumber()) {
        const n = Number(t.getValue());
        t = y.create(n, "0.00%");
      }
    } else this._operatorString === nt.POUND ? t = this._handlerPound(e) : t = g.create(h.VALUE);
    this.setValue(t);
  }
  _handlerPound(i) {
    var u, c, l, f;
    if (!i.isReferenceObject() || !i.isCell())
      return g.create(h.VALUE);
    const e = i, t = e.getRangePosition(), r = e.getUnitId(), n = e.getSheetId(), s = this._currentConfigService.getFormulaData(), o = (f = (l = (c = (u = s == null ? void 0 : s[r]) == null ? void 0 : u[n]) == null ? void 0 : c[t.startRow]) == null ? void 0 : l[t.startColumn]) == null ? void 0 : f.f;
    return o && this._lexer.treeBuilder(o), g.create(h.VALUE);
  }
}
let Fn = class extends St {
  constructor(a, i, e) {
    super(), this._functionService = a, this._lexer = i, this._currentConfigService = e;
  }
  get zIndex() {
    return Vt.get(oe.SUFFIX) || Ot;
  }
  checkAndCreateNodeType(a) {
    if (!(a instanceof ie))
      return;
    const i = a.getToken().trim();
    if (i.charAt(0) === '"' && i.charAt(i.length - 1) === '"')
      return;
    let e = "";
    if (i === nt.PERCENTAGE)
      e = ke.DIVIDED;
    else return i === nt.POUND ? new Yi(this._currentConfigService, this._lexer, i) : void 0;
    const t = this._functionService.getExecutor(e);
    return t ? new Yi(this._currentConfigService, this._lexer, i, t) : (console.error(`No function ${a}`), Ue.create(h.NAME));
  }
};
Fn = fh([
  Ss(0, Xt),
  Ss(1, ye(pr)),
  Ss(2, Wt)
], Fn);
var mh = Object.getOwnPropertyDescriptor, hh = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? mh(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, gh = (a, i) => (e, t) => i(e, t, a);
class dh extends qe {
  constructor(i) {
    super(i);
  }
  get nodeType() {
    return oe.UNION;
  }
  execute() {
    const i = this.getChildren(), e = i[0], t = i[1], r = e.getValue(), n = t.getValue();
    if (r == null || n == null)
      throw new Error("leftNode and rightNode");
    let s;
    this.getToken() === X.COLON ? s = this._unionFunction(r, n) : s = g.create(h.NAME), this.setValue(s);
  }
  _unionFunction(i, e) {
    return i.isError() || e.isError() || !i.isReferenceObject() || !e.isReferenceObject() ? g.create(h.REF) : (i = i, e = e, xm(i, e));
  }
}
let kn = class extends St {
  constructor(a) {
    super(), this._functionService = a;
  }
  get zIndex() {
    return Vt.get(oe.UNION) || Ot;
  }
  create(a) {
    return new dh(a);
  }
  checkAndCreateNodeType(a) {
    if (!(a instanceof ie))
      return;
    const e = a.getToken().trim();
    if (!(e.charAt(0) === '"' && e.charAt(e.length - 1) === '"') && e === X.COLON)
      return this.create(e);
  }
};
kn = hh([
  gh(0, Xt)
], kn);
class Ch extends qe {
  constructor(i) {
    super(i);
  }
  get nodeType() {
    return oe.VALUE;
  }
  execute() {
    var e, t, r;
    const i = ((e = this.getParent()) == null ? void 0 : e.nodeType) === oe.FUNCTION && ((r = (t = this.getParent()) == null ? void 0 : t.isFunctionExecutorArgumentsIgnoreNumberPattern) == null ? void 0 : r.call(t));
    this.setValue(Pt.create(this.getToken(), i));
  }
}
class nu extends St {
  get zIndex() {
    return Vt.get(oe.VALUE) || Ot;
  }
  _checkValueNode(i) {
    if (Number.isNaN(Number(i))) {
      const e = i.trim(), t = e.charAt(0), r = e.charAt(e.length - 1);
      if (fr.has(e))
        return this.create(e);
      if (t === '"' && r === '"')
        return this.create(e);
      if (t === "{" && r === "}")
        return this.create(e);
      const n = e.toUpperCase();
      if (n === ir.TRUE || n === ir.FALSE)
        return this.create(n);
    } else
      return this.create(i);
  }
  create(i) {
    return new Ch(i);
  }
  checkAndCreateNodeType(i) {
    if (!(i instanceof ie))
      return this._checkValueNode(i);
  }
}
var _h = Object.getOwnPropertyDescriptor, Ah = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? _h(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, lt = (a, i) => (e, t) => i(e, t, a);
let Gr = class extends Se {
  constructor(i, e, t, r, n, s, o, u, c, l, f) {
    super();
    A(this, "_astNodeFactoryList", []);
    this._runtimeService = i, this._astRootNodeFactory = e, this._functionNodeFactory = t, this._lambdaNodeFactory = r, this._lambdaParameterNodeFactory = n, this._operatorNodeFactory = s, this._prefixNodeFactory = o, this._referenceNodeFactory = u, this._suffixNodeFactory = c, this._unionNodeFactory = l, this._valueNodeFactory = f, this._initializeAstNode();
  }
  dispose() {
    this._astNodeFactoryList.forEach((i) => {
      i.dispose();
    }), this._astNodeFactoryList = [];
  }
  parse(i) {
    const e = new na(Ft), t = this._parse(i, e);
    return i.hasDefinedNames() && (t == null || t.setDefinedNames(i.getDefinedNames())), t;
  }
  _lambdaParameterHandler(i, e) {
    if (e.getLambdaId == null)
      return Ue.create(h.VALUE);
    const t = e.getLambdaId(), r = new na(Ft), n = this._runtimeService.getFunctionDefinitionPrivacyVar(t);
    if (!n)
      return !1;
    const s = [...n.keys()], o = i.getChildren(), u = o.length;
    for (let c = 0; c < u; c++) {
      const l = o[c];
      if (l instanceof ie) {
        Pa(l, t, n), this._parse(l, r);
        const m = r.getChildren()[c];
        m != null && n.set(s[c], m);
      } else
        return !1;
    }
    return r.setParent(e), e;
  }
  _changeLetToLambda(i) {
    const e = i.getChildren(), t = e.length;
    if (t % 2 !== 1 || t === 0)
      return;
    const r = new ie();
    r.setToken(Fr);
    const n = new ie();
    n.setToken(Rr);
    const s = [...e];
    for (let u = 0; u < t; u++) {
      const c = s[u];
      if (!(c instanceof ie))
        return;
      u % 2 === 0 ? c.changeToParent(r) : c.changeToParent(n);
    }
    r.addChildrenFirst(n), n.setParent(r);
    const o = i.getParent();
    return o == null || o.replaceChild(i, r), r;
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _parse(i, e) {
    var l;
    const t = i.getChildren(), r = t.length, n = [];
    let s = null;
    const o = i.getToken().trim().toUpperCase();
    if (o === Nl) {
      const f = this._changeLetToLambda(i);
      return f != null ? this._parse(f, e) : Ue.create(h.ERROR);
    }
    if (o === At) {
      if (s = e, r === 0)
        return new nh(Ft).setParent(e), s;
    } else {
      if (o === Rr) {
        let f = this._lambdaParameterHandler(i, e);
        return f === !1 && (f = Ue.create(h.ERROR)), f;
      }
      if (s = this._checkAstNode(i), s == null)
        return Ue.create(h.NAME);
    }
    const u = t[0];
    for (let f = 0; f < r; f++) {
      const m = t[f];
      if (Jo(u)) {
        if (f !== 0 && f !== r - 1)
          continue;
      } else if (Zm(m) && f !== r - 1)
        continue;
      let d = null;
      if (m instanceof ie) {
        if (m.getToken() === At && m.getChildren().length === 0) {
          const _ = (l = m.getParent()) == null ? void 0 : l.getChildren();
          if (_ && _.length === 1)
            return Ue.create(h.NAME);
        }
        if (d = this._parse(m, s), d === s)
          continue;
      } else
        d = this._checkAstNode(m);
      if (d == null)
        return Ue.create(h.NAME);
      if (d = zm(d), d == null || (d == null ? void 0 : d.nodeType) === oe.ERROR)
        return d;
      switch (d.nodeType) {
        // case NodeType.ERROR:
        //     return astNode;
        case oe.FUNCTION: {
          const _ = d.getToken().trim().toUpperCase();
          Ol.has(_) && d.setForcedCalculateFunction(), n.push(d);
          break;
        }
        case oe.LAMBDA:
          n.push(d);
          break;
        case oe.LAMBDA_PARAMETER:
          n.push(d);
          break;
        case oe.OPERATOR: {
          const _ = n.pop(), C = n.pop();
          C && C.setParent(d), _ && _.setParent(d), n.push(d);
          break;
        }
        case oe.REFERENCE:
          n.push(d);
          break;
        case oe.ROOT:
          n.push(d);
          break;
        case oe.UNION:
          n.push(d);
          break;
        case oe.VALUE:
          n.push(d);
          break;
        case oe.PREFIX:
          n.push(d);
          break;
        case oe.SUFFIX:
          n.push(d);
          break;
      }
    }
    const c = n.length;
    for (let f = 0; f < c; f++)
      n[f].setParent(s);
    return s;
  }
  // private _setPrefixRefOffset(astNode: BaseAstNode) {
  //     const children = astNode.getChildren();
  //     const childrenCount = children.length;
  //     for (let i = 0; i < childrenCount; i++) {
  //         const item = children[i];
  //         if (item.nodeType === NodeType.REFERENCE) {
  //             item.setRefOffset(this._refOffsetX, this._refOffsetY);
  //         }
  //     }
  // }
  _checkAstNode(i) {
    let e = null;
    const t = this._astNodeFactoryList.length;
    for (let r = 0; r < t && (e = this._astNodeFactoryList[r].checkAndCreateNodeType(i), e == null); r++)
      ;
    return e == null ? new Qm() : e;
  }
  _initializeAstNode() {
    this._astNodeFactoryList = [
      this._astRootNodeFactory,
      this._functionNodeFactory,
      this._lambdaNodeFactory,
      this._lambdaParameterNodeFactory,
      this._operatorNodeFactory,
      this._prefixNodeFactory,
      this._referenceNodeFactory,
      this._suffixNodeFactory,
      this._unionNodeFactory,
      this._valueNodeFactory
    ].sort(Tc);
  }
};
Gr = Ah([
  lt(0, Nt),
  lt(1, ye(Ko)),
  lt(2, ye(vn)),
  lt(3, ye(Tn)),
  lt(4, ye(ru)),
  lt(5, ye(In)),
  lt(6, ye(Un)),
  lt(7, ye(Bn)),
  lt(8, ye(Fn)),
  lt(9, ye(kn)),
  lt(10, ye(nu))
], Gr);
class Eh extends Se {
  constructor() {
    super(...arguments);
    A(this, "_otherFormulaData", /* @__PURE__ */ new Map());
    //  [unitId: string]: Nullable<{ [sheetId: string]: { [formulaId: string]: Set<number> } }>;
    A(this, "_featureFormulaData", /* @__PURE__ */ new Map());
    // [unitId: string]: Nullable<{ [sheetId: string]: { [featureId: string]: Nullable<number> } }>;
    A(this, "_formulaData", /* @__PURE__ */ new Map());
    // [unitId: string]: Nullable<{ [sheetId: string]: ObjectMatrix<number> }>;
    A(this, "_definedNameMap", /* @__PURE__ */ new Map());
    // unitId -> definedName -> treeId
    A(this, "_otherFormulaDataMainData", /* @__PURE__ */ new Set());
    A(this, "_dependencyRTreeCache", new js());
    A(this, "_dependencyTreeIdLast", 0);
  }
  buildDependencyTree(e, t) {
    throw new Error("Method not implemented.");
  }
  getTreeById(e) {
    throw new Error("Method not implemented.");
  }
  getAllTree() {
    throw new Error("Method not implemented.");
  }
  reset() {
    throw new Error("Method not implemented.");
  }
  addOtherFormulaDependency(e, t, r, n) {
    throw new Error("Method not implemented.");
  }
  removeOtherFormulaDependency(e, t, r) {
    throw new Error("Method not implemented.");
  }
  clearOtherFormulaDependency(e, t) {
    throw new Error("Method not implemented.");
  }
  addFeatureFormulaDependency(e, t, r, n) {
    throw new Error("Method not implemented.");
  }
  removeFeatureFormulaDependency(e, t, r) {
    throw new Error("Method not implemented.");
  }
  clearFeatureFormulaDependency(e, t) {
    throw new Error("Method not implemented.");
  }
  addFormulaDependency(e, t, r, n, s) {
    throw new Error("Method not implemented.");
  }
  removeFormulaDependency(e, t, r, n) {
    throw new Error("Method not implemented.");
  }
  clearFormulaDependency(e, t) {
    throw new Error("Method not implemented.");
  }
  removeFormulaDependencyByDefinedName(e, t) {
    throw new Error("Method not implemented.");
  }
  searchDependency(e, t) {
    return this._dependencyRTreeCache.bulkSearch(e, t);
  }
  _restDependencyTreeId() {
    this._dependencyTreeIdLast = 0;
  }
  getOtherFormulaDependency(e, t, r) {
    var n, s;
    return (s = (n = this._otherFormulaData.get(e)) == null ? void 0 : n.get(t)) == null ? void 0 : s.get(r);
  }
  addOtherFormulaDependencyMainData(e) {
    this._otherFormulaDataMainData.add(e);
  }
  hasOtherFormulaDataMainData(e) {
    return this._otherFormulaDataMainData.has(e);
  }
  _removeDependencyRTreeCacheById(e, t) {
    this._dependencyRTreeCache.removeById(e, t);
  }
  getFeatureFormulaDependency(e, t, r) {
    var n, s;
    return (s = (n = this._featureFormulaData.get(e)) == null ? void 0 : n.get(t)) == null ? void 0 : s.get(r);
  }
  getFormulaDependency(e, t, r, n) {
    var s, o;
    return (o = (s = this._formulaData.get(e)) == null ? void 0 : s.get(t)) == null ? void 0 : o.getValue(r, n);
  }
  addDependencyRTreeCache(e) {
    const t = [];
    for (let r = 0; r < e.rangeList.length; r++) {
      const n = e.rangeList[r], { unitId: s, sheetId: o, range: u } = n;
      t.push({
        unitId: s,
        sheetId: o,
        range: u,
        id: e.treeId
      });
    }
    this._dependencyRTreeCache.bulkInsert(t), this._addAllTreeMap(e);
  }
  getLastTreeId() {
    const e = this._dependencyTreeIdLast;
    return this._dependencyTreeIdLast++, e;
  }
  _addAllTreeMap(e) {
    throw new Error("Method not implemented.");
  }
  _addDefinedName(e, t, r) {
    this._definedNameMap.has(e) || this._definedNameMap.set(e, /* @__PURE__ */ new Map());
    const n = this._definedNameMap.get(e);
    n.has(t) || n.set(t, /* @__PURE__ */ new Set()), n.get(t).add(r);
  }
  addFormulaDependencyByDefinedName(e, t) {
    const r = e.treeId, n = (t == null ? void 0 : t.getDefinedNames()) || [];
    for (const s of n)
      this._addDefinedName(e.unitId, s, r);
  }
}
class Rh extends Eh {
  constructor() {
    super(...arguments);
    A(this, "_allTreeMap", /* @__PURE__ */ new Map());
  }
  dispose() {
    super.dispose(), this.reset();
  }
  buildDependencyTree(e, t = []) {
    const r = this.getAllTree();
    return e.length === 0 ? (this._buildReverseDependency(r, t), r) : (this._buildDependencyTree(r, e), this._buildReverseDependency(r, e), r);
  }
  /**
   * Build the dependency relationship between the trees.
   * @param allTrees  all FormulaDependencyTree
   * @param shouldBeBuildTrees  FormulaDependencyTree[] | FormulaDependencyTreeCache
   */
  _buildDependencyTree(e, t) {
    const r = /* @__PURE__ */ new Map();
    for (let n = 0; n < t.length; n++) {
      const s = t[n];
      r.set(s.treeId, s);
    }
    for (let n = 0; n < e.length; n++) {
      const s = e[n], o = s.toRTreeItem(), u = this._dependencyRTreeCache.bulkSearch(o);
      for (const c of u) {
        const l = r.get(c);
        l && s !== l && !l.hasChildren(s.treeId) && l.pushChildren(s);
      }
    }
    r.clear();
  }
  /**
   * Build the reverse dependency relationship between the trees.
   * @param allTrees
   * @param dependencyTrees
   */
  _buildReverseDependency(e, t) {
    const r = /* @__PURE__ */ new Map();
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      r.set(s.treeId, s);
    }
    for (let n = 0; n < t.length; n++) {
      const s = t[n], o = s.toRTreeItem(), u = this._dependencyRTreeCache.bulkSearch(o);
      for (const c of u) {
        const l = r.get(c);
        l && s !== l && !l.hasChildren(s.treeId) && l.pushChildren(s);
      }
    }
    r.clear();
  }
  /**
   * Get all FormulaDependencyTree from _otherFormulaData, _featureFormulaData, _formulaData
   * return FormulaDependencyTree[]
   */
  getAllTree() {
    const e = [];
    return this._allTreeMap.forEach((t) => {
      t.resetState(), e.push(t);
    }), e;
  }
  getTreeById(e) {
    return this._allTreeMap.get(e);
  }
  reset() {
    this._otherFormulaData.clear(), this._featureFormulaData.clear(), this._formulaData.clear(), this._definedNameMap.clear(), this._otherFormulaDataMainData.clear(), this._dependencyRTreeCache.clear(), this._allTreeMap.clear(), this._restDependencyTreeId();
  }
  addOtherFormulaDependency(e, t, r, n) {
    this._otherFormulaData.has(e) || this._otherFormulaData.set(e, /* @__PURE__ */ new Map());
    const s = this._otherFormulaData.get(e);
    s.has(t) || s.set(t, /* @__PURE__ */ new Map());
    const o = s.get(t);
    o.has(r) || o.set(r, new de()), o.get(r).setValue(n.refOffsetX, n.refOffsetY, n.treeId), this._addAllTreeMap(n);
  }
  removeOtherFormulaDependency(e, t, r) {
    const n = this._otherFormulaData.get(e);
    if (n && n.has(t)) {
      const s = n.get(t);
      r.forEach((o) => {
        const u = s.get(o);
        u != null && (u.forValue((c, l, f) => {
          this._removeDependencyRTreeCache(f), this.clearDependencyForTree(this._allTreeMap.get(f)), this._removeAllTreeMap(f);
        }), s.delete(o), this._otherFormulaDataMainData.delete(o));
      }), s.size === 0 && n.delete(t), n.size === 0 && this._otherFormulaData.delete(e);
    }
  }
  clearOtherFormulaDependency(e, t) {
    const r = this._otherFormulaData.get(e);
    if (t && r && r.has(t)) {
      const n = r.get(t);
      this._removeDependencyRTreeCacheById(e, t);
      for (const s of n.keys()) {
        const o = n.get(s);
        o != null && (o.forValue((u, c, l) => {
          const f = this._allTreeMap.get(l);
          f && (this.clearDependencyForTree(f), this._removeAllTreeMap(l));
        }), this._otherFormulaDataMainData.delete(s));
      }
      n.clear();
    } else if (r) {
      for (const n of r.keys()) {
        const s = r.get(n);
        this._removeDependencyRTreeCacheById(e, n);
        for (const o of s.keys()) {
          const u = s.get(o);
          u != null && (u.forValue((c, l, f) => {
            const m = this._allTreeMap.get(f);
            m && (this.clearDependencyForTree(m), this._removeAllTreeMap(f));
          }), this._otherFormulaDataMainData.delete(o));
        }
      }
      this._otherFormulaData.delete(e);
    }
  }
  addFeatureFormulaDependency(e, t, r, n) {
    this._featureFormulaData.has(e) || this._featureFormulaData.set(e, /* @__PURE__ */ new Map());
    const s = this._featureFormulaData.get(e);
    s.has(t) || s.set(t, /* @__PURE__ */ new Map()), s.get(t).set(r, n.treeId), this._addAllTreeMap(n);
  }
  removeFeatureFormulaDependency(e, t, r) {
    const n = this._featureFormulaData.get(e);
    if (n && n.has(t)) {
      const s = n.get(t);
      r.forEach((o) => {
        const u = s.get(o);
        u != null && (this._removeDependencyRTreeCache(u), s.delete(o), this.clearDependencyForTree(this._allTreeMap.get(u)), this._removeAllTreeMap(u));
      });
    }
  }
  clearFeatureFormulaDependency(e, t) {
    const r = this._featureFormulaData.get(e);
    if (t && r && r.has(t)) {
      const n = r.get(t);
      this._removeDependencyRTreeCacheById(e, t), n.forEach((s) => {
        s != null && (this.clearDependencyForTree(this._allTreeMap.get(s)), this._removeAllTreeMap(s));
      }), n.clear();
    } else r && (r.forEach((n, s) => {
      this._removeDependencyRTreeCacheById(e, s), n.forEach((o) => {
        o != null && (this.clearDependencyForTree(this._allTreeMap.get(o)), this._removeAllTreeMap(o));
      });
    }), this._featureFormulaData.delete(e));
  }
  addFormulaDependency(e, t, r, n, s) {
    this._formulaData.has(e) || this._formulaData.set(e, /* @__PURE__ */ new Map());
    const o = this._formulaData.get(e);
    o.has(t) || o.set(t, new de()), o.get(t).setValue(r, n, s.treeId), this._addAllTreeMap(s);
  }
  removeFormulaDependency(e, t, r, n) {
    const s = this._formulaData.get(e);
    if (s && s.has(t)) {
      const o = s.get(t), u = o.getValue(r, n);
      if (u == null)
        return;
      this._removeDependencyRTreeCache(u), o.realDeleteValue(r, n), this.clearDependencyForTree(this._allTreeMap.get(u)), this._removeAllTreeMap(u);
    }
  }
  clearFormulaDependency(e, t) {
    const r = this._formulaData.get(e);
    if (t && r && r.has(t)) {
      const n = r.get(t);
      this._removeDependencyRTreeCacheById(e, t), n.forValue((s, o, u) => {
        if (u == null)
          return !0;
        this.clearDependencyForTree(this._allTreeMap.get(u)), this._removeAllTreeMap(u);
      }), n.reset();
    } else r && (r.forEach((n, s) => {
      this._removeDependencyRTreeCacheById(e, s), n.forValue((o, u, c) => {
        if (c == null)
          return !0;
        this.clearDependencyForTree(this._allTreeMap.get(c)), this._removeAllTreeMap(c);
      });
    }), this._formulaData.delete(e));
  }
  /**
   * Clear the dependency relationship of the tree.
   * establish the relationship between the parent and the child.
   * @param shouldBeClearTree
   */
  clearDependencyForTree(e) {
    if (e == null)
      return;
    const t = e.parents, r = e.children, n = this._allTreeMap;
    for (const s of t) {
      const o = n.get(s);
      o == null || o.children.delete(e.treeId);
    }
    for (const s of r) {
      const o = n.get(s);
      o == null || o.parents.delete(e.treeId);
    }
    e.dispose();
  }
  _removeDependencyRTreeCache(e) {
    if (e == null)
      return;
    const t = this._allTreeMap.get(e);
    if (t) {
      const r = [];
      for (let n = 0; n < t.rangeList.length; n++) {
        const s = t.rangeList[n], { unitId: o, sheetId: u, range: c } = s;
        r.push({
          unitId: o,
          sheetId: u,
          range: c,
          id: e
        });
      }
      this._dependencyRTreeCache.bulkRemove(r);
    }
  }
  removeFormulaDependencyByDefinedName(e, t) {
    const r = this._definedNameMap.get(e);
    if (r) {
      const n = r.get(t);
      if (n) {
        for (const s of n)
          this._removeDependencyRTreeCache(s), this.clearDependencyForTree(this._allTreeMap.get(s)), this._removeAllTreeMap(s);
        n.clear();
      }
    }
  }
  _removeAllTreeMap(e) {
    e != null && this._allTreeMap.delete(e);
  }
  _addAllTreeMap(e) {
    this._allTreeMap.set(e.treeId, e);
  }
}
const cs = Je(
  "univer.formula.dependency-manager.service"
);
class bh extends Se {
  constructor() {
    super(...arguments);
    A(this, "_referenceExecutorMap", /* @__PURE__ */ new Map());
    // unitId -> subUnitId -> featureId -> IFeatureCalculationManagerParam
    A(this, "_onChanged$", new tr());
    A(this, "onChanged$", this._onChanged$.asObservable());
  }
  dispose() {
    super.dispose(), this._referenceExecutorMap.clear(), this._onChanged$.complete();
  }
  remove(e, t, r) {
    r.forEach((n) => {
      var s, o;
      (o = (s = this._referenceExecutorMap.get(e)) == null ? void 0 : s.get(t)) == null || o.delete(n);
    }), this._onChanged$.next({
      unitId: e,
      subUnitId: t,
      featureIds: r
    });
  }
  get(e, t, r) {
    var n, s;
    return (s = (n = this._referenceExecutorMap.get(e)) == null ? void 0 : n.get(t)) == null ? void 0 : s.get(r);
  }
  has(e, t, r) {
    var n, s;
    return !!((s = (n = this._referenceExecutorMap.get(e)) == null ? void 0 : n.get(t)) != null && s.has(r));
  }
  register(e, t, r, n) {
    let s = this._referenceExecutorMap.get(e);
    s || (s = /* @__PURE__ */ new Map(), this._referenceExecutorMap.set(e, s));
    let o = s.get(t);
    o || (o = /* @__PURE__ */ new Map(), s.set(t, o)), this._onChanged$.next({
      unitId: e,
      subUnitId: t,
      featureIds: [r]
    }), o.set(r, n);
  }
  getReferenceExecutorMap() {
    return this._referenceExecutorMap;
  }
}
const Wr = Je(
  "univer.formula.feature-calculation-manager.service"
);
class yh extends Se {
  constructor() {
    super(...arguments);
    A(this, "_otherFormulaData", {});
  }
  dispose() {
    super.dispose(), this._otherFormulaData = {};
  }
  remove(e) {
    var s, o, u;
    const { unitId: t, subUnitId: r, formulaId: n } = e;
    (u = (o = (s = this._otherFormulaData) == null ? void 0 : s[t]) == null ? void 0 : o[r]) == null || delete u[n];
  }
  get(e) {
    var s, o;
    const { unitId: t, subUnitId: r, formulaId: n } = e;
    return (o = (s = this._otherFormulaData[t]) == null ? void 0 : s[r]) == null ? void 0 : o[n];
  }
  has(e) {
    var s, o;
    const { unitId: t, subUnitId: r, formulaId: n } = e;
    return ((o = (s = this._otherFormulaData[t]) == null ? void 0 : s[r]) == null ? void 0 : o[n]) != null;
  }
  register(e) {
    const { unitId: t, subUnitId: r, formulaId: n, item: s } = e;
    this._otherFormulaData[t] || (this._otherFormulaData[t] = {}), this._otherFormulaData[t][r] || (this._otherFormulaData[t][r] = {}), this._otherFormulaData[t][r][n] = s;
  }
  batchRegister(e) {
    Object.keys(e).forEach((t) => {
      const r = e[t];
      if (r == null)
        return !0;
      Object.keys(r).forEach((n) => {
        const s = r[n];
        if (s == null)
          return !0;
        Object.keys(s).forEach((o) => {
          const u = s[o];
          if (u == null)
            return !0;
          this.register({
            unitId: t,
            subUnitId: n,
            formulaId: o,
            item: u
          });
        });
      });
    });
  }
  batchRemove(e) {
    Object.keys(e).forEach((t) => {
      const r = e[t];
      if (r == null)
        return !0;
      Object.keys(r).forEach((n) => {
        const s = r[n];
        if (s == null)
          return !0;
        Object.keys(s).forEach((o) => {
          this.remove({
            unitId: t,
            subUnitId: n,
            formulaId: o
          });
        });
      });
    });
  }
  getOtherFormulaData() {
    return this._otherFormulaData;
  }
}
const ja = Je(
  "univer.formula.other-formula-manager.service"
);
var sa = /* @__PURE__ */ ((a) => (a[a.NORMAL_FORMULA = 0] = "NORMAL_FORMULA", a[a.OTHER_FORMULA = 1] = "OTHER_FORMULA", a[a.FEATURE_FORMULA = 2] = "FEATURE_FORMULA", a))(sa || {});
class su {
  constructor() {
    A(this, "_state", 0);
    A(this, "treeId");
    A(this, "children", /* @__PURE__ */ new Set());
    A(this, "parents", /* @__PURE__ */ new Set());
  }
  resetState() {
    this._state = 0;
  }
  setAdded() {
    this._state = 1;
  }
  isAdded() {
    return this._state === 1;
  }
  setSkip() {
    this._state = 2;
  }
  isSkip() {
    return this._state === 2;
  }
  pushChildren(i) {
    this.children.add(i.treeId), i._pushParent(this);
  }
  hasChildren(i) {
    return this.children.has(i);
  }
  _pushParent(i) {
    this.parents.add(i.treeId);
  }
}
class Hi extends su {
  constructor() {
    super(...arguments);
    A(this, "refTree");
    A(this, "refOffsetX", -1);
    A(this, "refOffsetY", -1);
    A(this, "isCache", !1);
    A(this, "isDirty", !1);
    A(this, "addressFunctionNodes", []);
    A(this, "getDirtyData");
    A(this, "featureId");
  }
  get isVirtual() {
    return !0;
  }
  get row() {
    return this.refTree == null ? -1 : this.refTree.row + this.refOffsetY;
  }
  get column() {
    return this.refTree == null ? -1 : this.refTree.column + this.refOffsetX;
  }
  get rowCount() {
    return this.refTree == null ? 0 : this.refTree.rowCount;
  }
  get columnCount() {
    return this.refTree == null ? 0 : this.refTree.columnCount;
  }
  get unitId() {
    return this.refTree == null ? "" : this.refTree.unitId;
  }
  get subUnitId() {
    return this.refTree == null ? "" : this.refTree.subUnitId;
  }
  get formula() {
    var e, t;
    return (t = (e = this.refTree) == null ? void 0 : e.formula) != null ? t : "";
  }
  get nodeData() {
    return {
      node: this.node,
      refOffsetX: this.refOffsetX,
      refOffsetY: this.refOffsetY
    };
  }
  get node() {
    var e;
    return (e = this.refTree) == null ? void 0 : e.node;
  }
  dispose() {
    this.refTree = null;
  }
  get rangeList() {
    const e = [];
    if (this.refTree == null)
      return [];
    for (let t = 0; t < this.refTree.rangeList.length; t++) {
      const r = this.refTree.rangeList[t];
      e.push({
        unitId: r.unitId,
        sheetId: r.sheetId,
        range: ga(r.range, this.refOffsetX, this.refOffsetY)
      });
    }
    return e;
  }
  toRTreeItem() {
    const e = this.row, t = this.column;
    return [{
      unitId: this.unitId,
      sheetId: this.subUnitId,
      range: {
        startRow: e,
        startColumn: t,
        endRow: e,
        endColumn: t
      }
    }];
  }
  inRangeData(e) {
    const t = e.startRow, r = e.startColumn, n = e.endRow, s = e.endColumn, o = this.row, u = this.column;
    return !(o < t || o > n || u < r || u > s);
  }
  dependencySheetName(e) {
    return this.refTree == null ? !1 : this.refTree.dependencySheetName(e);
  }
  isExcludeRange(e) {
    var r;
    const t = this.rangeList;
    if (t.length === 0)
      return !1;
    for (let n = 0, s = t.length; n < s; n++) {
      const o = t[n], { unitId: u, sheetId: c, range: l } = o, f = (r = e == null ? void 0 : e[u]) == null ? void 0 : r[c];
      let { startRow: m, endRow: d, startColumn: _, endColumn: C } = l;
      Number.isNaN(m) && (m = 0), Number.isNaN(_) && (_ = 0), Number.isNaN(d) && (d = Number.POSITIVE_INFINITY), Number.isNaN(C) && (C = Number.POSITIVE_INFINITY);
      let E = !1;
      if (f == null || f.forValue((R, b) => {
        if (R >= m && R <= d && b >= _ && b <= C)
          return E = !0, !1;
      }), E)
        return !0;
    }
    return !1;
  }
  get formulaId() {
    return this.refTree == null ? "" : this.refTree.formulaId;
  }
}
class Ms extends su {
  constructor(e) {
    super();
    A(this, "isCache", !1);
    A(this, "featureId");
    A(this, "featureDirtyRanges", []);
    A(this, "refOffsetX", 0);
    A(this, "refOffsetY", 0);
    A(this, "type", 0);
    A(this, "formulaId");
    A(this, "subUnitId", "");
    A(this, "unitId", "");
    A(this, "rangeList", []);
    A(this, "formula", "");
    A(this, "row", -1);
    A(this, "column", -1);
    A(this, "rowCount", Number.NEGATIVE_INFINITY);
    A(this, "columnCount", Number.NEGATIVE_INFINITY);
    A(this, "isDirty", !1);
    A(this, "node");
    A(this, "addressFunctionNodes", []);
    A(this, "getDirtyData");
    this.treeId = e;
  }
  get isVirtual() {
    return !1;
  }
  get nodeData() {
    return {
      node: this.node,
      refOffsetX: 0,
      refOffsetY: 0
    };
  }
  toJson() {
    return {
      formula: this.formula,
      refOffsetX: this.refOffsetX,
      refOffsetY: this.refOffsetY
    };
  }
  dispose() {
    this.featureDirtyRanges = [], this.rangeList = [], this.addressFunctionNodes = [], this.getDirtyData = null;
  }
  inRangeData(e) {
    const t = e.startRow, r = e.startColumn, n = e.endRow, s = e.endColumn, o = this.row, u = this.column;
    return !(o < t || o > n || u < r || u > s);
  }
  dependencySheetName(e) {
    var r;
    const t = this.rangeList;
    if (t.length === 0 || e == null)
      return !1;
    for (let n = 0, s = t.length; n < s; n++) {
      const o = t[n], { unitId: u, sheetId: c } = o;
      if (((r = e[u]) == null ? void 0 : r[c]) != null)
        return !0;
    }
    return !1;
  }
  isExcludeRange(e) {
    var r;
    const t = this.rangeList;
    if (t.length === 0)
      return !1;
    for (let n = 0, s = t.length; n < s; n++) {
      const o = t[n], { unitId: u, sheetId: c, range: l } = o, f = (r = e == null ? void 0 : e[u]) == null ? void 0 : r[c];
      let { startRow: m, endRow: d, startColumn: _, endColumn: C } = l;
      Number.isNaN(m) && (m = 0), Number.isNaN(_) && (_ = 0), Number.isNaN(d) && (d = Number.POSITIVE_INFINITY), Number.isNaN(C) && (C = Number.POSITIVE_INFINITY);
      let E = !1;
      if (f == null || f.forValue((R, b) => {
        if (R >= m && R <= d && b >= _ && b <= C)
          return E = !0, !1;
      }), E)
        return !0;
    }
    return !1;
  }
  // pushChildren(tree: FormulaDependencyTree) {
  //     this.children.add(tree.treeId);
  //     tree._pushParent(this);
  // }
  /**
   * Add the range corresponding to the current ast node.
   * @param range
   */
  pushRangeList(e) {
    this.rangeList.push(...e);
  }
  shouldBePushRangeList() {
    return this.rangeList.length === 0 && this.type !== 2;
  }
  // hasChildren(treeId: number) {
  //     return this.children.has(treeId);
  // }
  toRTreeItem() {
    if (this.featureId != null)
      return this.featureDirtyRanges;
    const e = this.row, t = this.column;
    return [{
      unitId: this.unitId,
      sheetId: this.subUnitId,
      range: {
        startRow: e,
        startColumn: t,
        endRow: e,
        endColumn: t
      }
    }];
  }
  /**
   * Determine whether it is dependent on other trees.
   * @param dependenceTree
   */
  // dependency(dependenceTree: FormulaDependencyTree) {
  //     if (this.rangeList.length === 0) {
  //         return false;
  //     }
  //     for (let r = 0, len = this.rangeList.length; r < len; r++) {
  //         const unitRange = this.rangeList[r];
  //         const unitId = unitRange.unitId;
  //         const sheetId = unitRange.sheetId;
  //         const range = unitRange.range;
  //         if (
  //             dependenceTree.unitId === unitId &&
  //             dependenceTree.subUnitId === sheetId &&
  //             dependenceTree.inRangeData(range)
  //         ) {
  //             return true;
  //         }
  //     }
  //     return false;
  // }
  // private _pushParent(tree: FormulaDependencyTree) {
  //     this.parents.add(tree.treeId);
  // }
}
var ph = Object.getOwnPropertyDescriptor, Nh = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? ph(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, vt = (a, i) => (e, t) => i(e, t, a);
function gr(a) {
  return a.getLastTreeId() || 0;
}
const aa = Je("engine-formula.dependency-generator");
let ia = class extends Se {
  constructor(i, e, t, r, n, s, o, u) {
    super();
    A(this, "_updateRangeFlattenCache", /* @__PURE__ */ new Map());
    A(this, "_dependencyRTreeCacheForAddressFunction", new js());
    A(this, "_executedAddressFunctionNodeIds", /* @__PURE__ */ new Set());
    this._currentConfigService = i, this._runtimeService = e, this._otherFormulaManagerService = t, this._featureCalculationManagerService = r, this._interpreter = n, this._astTreeBuilder = s, this._lexer = o, this._dependencyManagerService = u;
  }
  dispose() {
    this._updateRangeFlattenCache.clear(), this._dependencyRTreeCacheForAddressFunction.clear(), Hr.clear();
  }
  async generate() {
    this._updateRangeFlatten();
    const i = this._currentConfigService.getFormulaData(), e = this._otherFormulaManagerService.getOtherFormulaData(), t = this._currentConfigService.getClearDependencyTreeCache();
    t != null && Object.keys(t).forEach((l) => {
      l != null && Object.keys(t[l]).forEach((f) => {
        f != null && (this._dependencyManagerService.clearOtherFormulaDependency(l, f), this._dependencyManagerService.clearFeatureFormulaDependency(l, f), this._dependencyManagerService.clearFormulaDependency(l, f));
      });
    });
    const r = this._currentConfigService.getUnitData(), n = await this._generateTreeList(i, e, r), s = this._getUpdateTreeListAndMakeDependency(n);
    let o = this._calculateRunList(s);
    return this._dependencyFeatureCalculation(o) && (o.forEach((l) => {
      l.resetState();
    }), o = this._calculateRunList(o)), this._checkIsCycleDependency(o) && this._runtimeService.enableCycleDependency(), this._dependencyRTreeCacheForAddressFunction.clear(), this._runtimeService.clearArrayObjectCache(), Promise.resolve(o);
  }
  _dependencyFeatureCalculation(i) {
    const e = this._featureCalculationManagerService.getReferenceExecutorMap();
    if (e.size === 0)
      return;
    this._clearFeatureCalculationNode(i);
    let t = !1;
    return e.forEach((r, n) => {
      r.forEach((s, o) => {
        s.forEach((u, c) => {
          const { unitId: l, subUnitId: f, getDirtyData: m } = u, d = m(this._currentConfigService.getDirtyData(), this._runtimeService.getAllRuntimeData()), _ = this._convertDirtyRangesToUnitRange(d.dirtyRanges), C = this._intersectFeatureCalculation(_, i, { unitId: l, subUnitId: f, featureId: c });
          if (C.length > 0) {
            let E = this._getExistTreeList({ unitId: l, subUnitId: f, featureId: c }, i);
            E == null && (E = this._getFeatureFormulaTree(c, gr(this._dependencyManagerService), u), i.push(E)), E.parents = /* @__PURE__ */ new Set(), C.forEach((R) => {
              R.hasChildren(E.treeId) || R.pushChildren(E);
            }), t = !0;
          }
        });
      });
    }), t;
  }
  _clearFeatureCalculationNode(i) {
    const e = this._featureCalculationManagerService.getReferenceExecutorMap();
    i.forEach((t) => {
      var s, o, u, c;
      const r = /* @__PURE__ */ new Set();
      for (const l of t.children) {
        const f = this._dependencyManagerService.getTreeById(l);
        f && (f.featureId && (o = (s = e.get(t.unitId)) == null ? void 0 : s.get(t.subUnitId)) != null && o.has(f.featureId) || r.add(l));
      }
      t.children = r;
      const n = /* @__PURE__ */ new Set();
      for (const l of t.parents) {
        const f = this._dependencyManagerService.getTreeById(l);
        f && (f.featureId && (c = (u = e.get(t.unitId)) == null ? void 0 : u.get(t.subUnitId)) != null && c.has(f.featureId) || n.add(l));
      }
      t.parents = n;
    });
  }
  /**
   * TODO @DR-Univer: The next step will be to try changing the incoming dirtyRanges to an array, thus avoiding conversion.
   * @param dirtyRanges
   * @returns
   */
  _convertDirtyRangesToUnitRange(i) {
    const e = [];
    for (const t in i) {
      const r = i[t];
      for (const n in r) {
        const s = r[n];
        for (const o of s)
          e.push({
            unitId: t,
            sheetId: n,
            range: o
          });
      }
    }
    return e;
  }
  _intersectFeatureCalculation(i, e, t) {
    const r = [], n = this._dependencyManagerService.searchDependency(i);
    for (let s = 0, o = e.length; s < o; s++) {
      const u = e[s];
      if (u.unitId === t.unitId && u.subUnitId === t.subUnitId && u.featureId === t.featureId)
        continue;
      n.has(u.treeId) && r.push(u);
    }
    return r;
  }
  _getExistTreeList(i, e) {
    const { unitId: t, subUnitId: r, featureId: n } = i;
    for (let s = 0, o = e.length; s < o; s++) {
      const u = e[s];
      if (u.unitId === t && u.subUnitId === r && u.featureId === n)
        return u;
    }
  }
  _isCyclicUtil(i, e, t) {
    const r = this._dependencyManagerService.getTreeById(i);
    if (r == null)
      return !1;
    if (!e.has(r.treeId)) {
      e.add(r.treeId), t.add(r.treeId);
      for (const n of r.children)
        if (!e.has(n) && this._isCyclicUtil(n, e, t) || t.has(n))
          return !0;
    }
    return t.delete(r.treeId), !1;
  }
  _checkIsCycleDependency(i) {
    const e = /* @__PURE__ */ new Set(), t = /* @__PURE__ */ new Set();
    for (let r = 0, n = i.length; r < n; r++) {
      const s = i[r];
      if (this._isCyclicUtil(s.treeId, e, t) === !0)
        return !0;
    }
    return !1;
  }
  /**
   * Generate nodes for the dependency tree, where each node contains all the reference data ranges included in each formula.
   * @param formulaData
   */
  async _generateTreeList(i, e, t) {
    const r = Object.keys(i), n = Object.keys(e), s = [];
    this._currentConfigService.isForceCalculate() && this._dependencyManagerService.reset(), this._registerFormulas(r, i, t, s), this._registerOtherFormulas(e, n, s), this._registerFeatureFormulas(s);
    for (let u = 0, c = s.length; u < c; u++) {
      const l = s[u];
      if (!l.formula)
        continue;
      const f = this._getTreeNode(l);
      l.isDirty = this._includeTree(l, f);
      const m = this._getAddressFunctionNodeList(f);
      if (m.length > 0 && (l.addressFunctionNodes = m), l.isVirtual)
        continue;
      this._runtimeService.setCurrent(
        l.row,
        l.column,
        l.rowCount,
        l.columnCount,
        l.subUnitId,
        l.unitId
      );
      const d = await this._getRangeListByNode({
        node: f,
        refOffsetX: l.refOffsetX,
        refOffsetY: l.refOffsetY
      });
      l.pushRangeList(d);
    }
    for (let u = 0, c = s.length; u < c; u++) {
      const l = s[u];
      l.isCache || this._dependencyManagerService.addDependencyRTreeCache(l);
    }
    return await this._calculateListByFunctionRefNode(s), s;
  }
  // private _moveRangeList(tree: FormulaDependencyTree, refOffsetX: number, refOffsetY: number) {
  //     const rangeList = tree.rangeList;
  //     const newRangeList = [];
  //     for (let i = 0, len = rangeList.length; i < len; i++) {
  //         const unitRange = rangeList[i];
  //         const newRange = {
  //             unitId: tree.unitId,
  //             sheetId: tree.subUnitId,
  //             range: moveRangeByOffset(unitRange.range, refOffsetX, refOffsetY),
  //         };
  //         newRangeList.push(newRange);
  //     }
  //     return newRangeList;
  // }
  _registerFeatureFormulas(i) {
    this._featureCalculationManagerService.getReferenceExecutorMap().forEach((t, r) => {
      t.forEach((n, s) => {
        n.forEach((o, u) => {
          const c = this._dependencyManagerService.getFeatureFormulaDependency(o.unitId, o.subUnitId, u);
          i.push(this._getFeatureFormulaTree(u, c, o));
        });
      });
    });
  }
  _getFeatureFormulaTree(i, e, t) {
    const { unitId: r, subUnitId: n, dependencyRanges: s, getDirtyData: o } = t, u = e || gr(this._dependencyManagerService), c = new Ms(u);
    c.unitId = r, c.subUnitId = n, c.rangeList = s, c.getDirtyData = o;
    const l = o(this._currentConfigService.getDirtyData(), this._runtimeService.getAllRuntimeData()), f = this._convertDirtyRangesToUnitRange(l.dirtyRanges);
    return c.featureDirtyRanges = f, c.featureId = i, c.type = sa.FEATURE_FORMULA, this._dependencyManagerService.addFeatureFormulaDependency(r, n, i, c), this._dependencyManagerService.getFeatureFormulaDependency(t.unitId, t.subUnitId, i) && (c.isCache = !0), c;
  }
  _registerOtherFormulas(i, e, t) {
    for (const r of e) {
      const n = i[r];
      if (n == null)
        continue;
      const s = Object.keys(n);
      for (const o of s) {
        const u = n[o];
        if (u == null)
          continue;
        const c = Object.keys(u);
        for (const l of c) {
          const f = this._dependencyManagerService.hasOtherFormulaDataMainData(l), m = u[l], { f: d, ranges: _ } = m;
          let C = !1;
          f && (C = !0);
          const E = Ti(r, d, this._lexer, this._astTreeBuilder, this._currentConfigService), { firstRow: R, firstColumn: b } = this._getFirstCellOfRange(_), p = this._dependencyManagerService.getOtherFormulaDependency(r, o, l), V = (p == null ? void 0 : p.getValue(0, 0)) || gr(this._dependencyManagerService), S = new Ms(V);
          for (let M = 0; M < _.length; M++) {
            const D = _[M], { startRow: w, startColumn: L, endRow: v, endColumn: j } = D;
            for (let k = w; k <= v; k++)
              for (let G = L; G <= j; G++) {
                const ne = G - b, z = k - R;
                if (ne === 0 && z === 0) {
                  S.node = E, S.formula = d, S.unitId = r, S.subUnitId = o, S.formulaId = l, S.type = sa.OTHER_FORMULA, S.isCache = C, t.push(S), this._dependencyManagerService.addOtherFormulaDependency(r, o, l, S), this._dependencyManagerService.addFormulaDependencyByDefinedName(S);
                  continue;
                }
                const $ = new Hi();
                $.treeId = (p == null ? void 0 : p.getValue(ne, z)) || gr(this._dependencyManagerService), $.refTree = S, $.refOffsetX = ne, $.refOffsetY = z, $.isCache = C, this._dependencyManagerService.addOtherFormulaDependency(r, o, l, $), this._dependencyManagerService.addFormulaDependencyByDefinedName($), t.push($);
              }
          }
          this._dependencyManagerService.addOtherFormulaDependencyMainData(l);
        }
      }
    }
  }
  _getFirstCellOfRange(i) {
    const e = i[0];
    return {
      firstRow: e.startRow,
      firstColumn: e.startColumn
    };
  }
  _registerFormulas(i, e, t, r) {
    for (const n of i) {
      const s = e[n];
      if (s == null)
        continue;
      const o = Object.keys(s);
      for (const u of o) {
        const c = new de(s[u] || {}), l = /* @__PURE__ */ new Map();
        c.forValue((f, m, d) => {
          if (d == null)
            return !0;
          const { x: _ = 0, y: C = 0, si: E } = d;
          if (!(_ === 0 && C === 0 && E != null))
            return !0;
          const R = this._createFDtree(n, u, f, m, t, d), b = this._dependencyManagerService.getFormulaDependency(n, u, f, m);
          b != null ? (R.treeId = b, R.isCache = !0) : (this._dependencyManagerService.addFormulaDependency(n, u, f, m, R), this._dependencyManagerService.addFormulaDependencyByDefinedName(R)), l.set(E, R), r.push(R);
        }), c.forValue((f, m, d) => {
          if (d == null)
            return !0;
          const { x: _ = 0, y: C = 0, si: E } = d;
          if (_ === 0 && C === 0 && E != null)
            return !0;
          let R;
          if (E && l.has(E)) {
            const p = l.get(E);
            R = this._createVirtualFDtree(p, d);
          } else
            R = this._createFDtree(n, u, f, m, t, d);
          const b = this._dependencyManagerService.getFormulaDependency(n, u, f, m);
          b != null ? (R.treeId = b, R.isCache = !0) : (this._dependencyManagerService.addFormulaDependency(n, u, f, m, R), this._dependencyManagerService.addFormulaDependencyByDefinedName(R)), r.push(R);
        }), l.clear();
      }
    }
  }
  _createFDtree(i, e, t, r, n, s) {
    const { f: o, x: u = 0, y: c = 0 } = s, l = new Ms(gr(this._dependencyManagerService)), f = n[i][e], m = Ti(i, o, this._lexer, this._astTreeBuilder, this._currentConfigService);
    return l.node = m, l.formula = o, l.unitId = i, l.subUnitId = e, l.row = t, l.column = r, l.rowCount = f.rowCount, l.columnCount = f.columnCount, l;
  }
  _createVirtualFDtree(i, e) {
    const { x: t = 0, y: r = 0 } = e, n = new Hi();
    return n.treeId = gr(this._dependencyManagerService), n.refTree = i, n.refOffsetX = t, n.refOffsetY = r, n;
  }
  /**
   * Break down the dirty areas into ranges for subsequent matching.
   */
  _updateRangeFlatten() {
    const i = this._currentConfigService.isForceCalculate(), e = this._currentConfigService.getDirtyRanges();
    if (!i) {
      this._updateRangeFlattenCache.clear();
      for (let t = 0; t < e.length; t++) {
        const r = e[t], n = r.range, s = r.sheetId, o = r.unitId;
        this._addFlattenCache(o, s, n);
      }
    }
  }
  _addFlattenCache(i, e, t) {
    let r = this._updateRangeFlattenCache.get(i);
    r == null && (r = /* @__PURE__ */ new Map(), this._updateRangeFlattenCache.set(i, r));
    let n = r.get(e);
    n == null && (n = [], r.set(e, n)), n.push(t);
  }
  _isPreCalculateNode(i) {
    return i.nodeType === oe.UNION || i.nodeType === oe.PREFIX && i.getToken() === we.AT || i.nodeType === oe.SUFFIX && i.getToken() === nt.POUND;
  }
  _nodeTraversalRef(i, e) {
    const t = i.getChildren(), r = t.length;
    for (let n = 0; n < r; n++) {
      const s = t[n];
      if (this._isPreCalculateNode(s)) {
        if (e.push(s), s.nodeType === oe.UNION)
          for (const o of s.getChildren())
            o.nodeType === oe.FUNCTION && o.isAddress() && this._nodeTraversalRef(o, e);
        continue;
      } else s.nodeType === oe.REFERENCE && e.push(s);
      this._nodeTraversalRef(s, e);
    }
  }
  _nodeTraversalReferenceFunction(i, e) {
    const t = i.getChildren(), r = t.length;
    for (let n = 0; n < r; n++) {
      const s = t[n];
      if (s.nodeType === oe.FUNCTION && s.isAddress()) {
        e.push(s);
        continue;
      }
      this._nodeTraversalReferenceFunction(s, e);
    }
  }
  async _executeNode(i, e = 0, t = 0) {
    let r;
    const n = {
      node: i,
      refOffsetX: e,
      refOffsetY: t
    };
    return this._interpreter.checkAsyncNode(i) ? r = await this._interpreter.executeAsync(n) : r = this._interpreter.execute(n), r;
  }
  /**
   * Calculate the range required for collection in advance,
   * including references and location functions (such as OFFSET, INDIRECT, INDEX, etc.).
   * @param node
   */
  async _getRangeListByNode(i) {
    const e = [], t = i.refOffsetX, r = i.refOffsetY, n = i.node;
    if (n == null)
      return [];
    this._nodeTraversalRef(n, e);
    const s = [];
    for (let o = 0, u = e.length; o < u; o++) {
      const c = e[o], f = (await this._executeNode(c, t, r)).toUnitRange();
      s.push(f), c.setValue(null);
    }
    return s;
  }
  _getAddressFunctionNodeList(i) {
    const e = [];
    return i == null ? [] : (this._nodeTraversalReferenceFunction(i, e), e);
  }
  _getTreeNode(i) {
    return i.node;
  }
  async _buildDirtyRangesByAddressFunction(i, e) {
    const t = e.addressFunctionNodes;
    if (t.length === 0)
      return;
    const r = e.refOffsetX, n = e.refOffsetY, s = await this._getRangeListByFunctionRefNode(t, r, n);
    e.addressFunctionNodes = [], this._addDependencyTreeByAddressFunction(e, s);
    const o = i.bulkSearch(s), u = this._buildTreeNodeById(o);
    u.length !== 0 && await this._calculateAddressFunctionRuntimeData(i, u);
  }
  async _calculateListByFunctionRefNode(i) {
    const e = new js();
    for (let t = 0, r = i.length; t < r; t++) {
      const n = i[t];
      e.insert({
        unitId: n.unitId,
        sheetId: n.subUnitId,
        range: {
          startRow: n.row,
          startColumn: n.column,
          endRow: n.row,
          endColumn: n.column
        },
        id: n.treeId
      });
    }
    this._executedAddressFunctionNodeIds.clear();
    for (let t = 0, r = i.length; t < r; t++) {
      const n = i[t];
      await this._calculateAddressFunction(e, n);
    }
  }
  async _calculateAddressFunction(i, e) {
    const t = e.addressFunctionNodes;
    if (t.length === 0)
      return;
    const r = e.refOffsetX, n = e.refOffsetY;
    this._runtimeService.setCurrent(
      e.row,
      e.column,
      e.rowCount,
      e.columnCount,
      e.subUnitId,
      e.unitId
    );
    const s = [];
    for (let c = 0, l = t.length; c < l; c++) {
      const f = await this._getRangeListByNode({
        node: t[c],
        refOffsetX: r,
        refOffsetY: n
      });
      s.push(...f);
    }
    const o = /* @__PURE__ */ new Set();
    this._searchDependencyByAddressFunction(i, s, o);
    const u = this._buildTreeNodeById(o);
    if (u.length === 0) {
      await this._buildDirtyRangesByAddressFunction(i, e);
      return;
    }
    await this._calculateAddressFunctionRuntimeData(i, u), await this._buildDirtyRangesByAddressFunction(i, e);
  }
  async _calculateAddressFunctionRuntimeData(i, e) {
    for (; e.length > 0; ) {
      const t = e.pop(), n = {
        node: this._getTreeNode(t),
        refOffsetX: t.refOffsetX,
        refOffsetY: t.refOffsetY
      };
      await this._calculateAddressFunction(i, t), this._runtimeService.setCurrent(
        t.row,
        t.column,
        t.rowCount,
        t.columnCount,
        t.subUnitId,
        t.unitId
      );
      let s;
      this._interpreter.checkAsyncNode(n.node) ? s = await this._interpreter.executeAsync(n) : s = this._interpreter.execute(n), t.formulaId != null ? this._runtimeService.setRuntimeOtherData(t.formulaId, t.refOffsetX, t.refOffsetY, s) : this._runtimeService.setRuntimeData(s);
    }
  }
  _buildTreeNodeById(i) {
    const e = [];
    for (const t of i) {
      const r = this._getTreeById(t);
      !r || this._executedAddressFunctionNodeIds.has(t) || (this._executedAddressFunctionNodeIds.add(t), e.push(r));
    }
    return e;
  }
  _searchDependencyByAddressFunction(i, e, t) {
    const r = i.bulkSearch(e), n = this._dependencyRTreeCacheForAddressFunction.bulkSearch(e);
    for (const o of n)
      t.has(o) || t.add(o);
    const s = [];
    for (const o of r) {
      const u = this._getTreeById(o);
      u && !t.has(o) && (s.push(...u.rangeList), t.add(o));
    }
    return s.length > 0 && this._searchDependencyByAddressFunction(i, s, t), t;
  }
  _getTreeById(i) {
    return this._dependencyManagerService.getTreeById(i);
  }
  _addDependencyTreeByAddressFunction(i, e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const n = e[r], { unitId: s, sheetId: o, range: u } = n;
      t.push({
        unitId: s,
        sheetId: o,
        range: u,
        id: i.treeId
      });
    }
    this._dependencyRTreeCacheForAddressFunction.bulkInsert(t);
  }
  /**
   * Calculate the range required for collection in advance,
   * including references and location functions (such as OFFSET, INDIRECT, INDEX, etc.).
   * @param node
   */
  async _getRangeListByFunctionRefNode(i, e, t) {
    const r = [];
    for (let n = 0, s = i.length; n < s; n++) {
      const o = i[n], c = (await this._executeNode(o, e, t)).toUnitRange();
      r.push(c), o.setValue(null);
    }
    return r;
  }
  /**
   * Build a formula dependency tree based on the dependency relationships.
   * @param treeList
   */
  _getUpdateTreeListAndMakeDependency(i) {
    const e = [], t = /* @__PURE__ */ new Set(), r = this._currentConfigService.isForceCalculate(), n = this._currentConfigService.getDirtyRanges(), s = this._dependencyManagerService.searchDependency(n), o = this._dependencyRTreeCacheForAddressFunction.bulkSearch(n);
    for (const c of o)
      s.add(c);
    const u = this._dependencyManagerService.buildDependencyTree(i);
    for (const c of u) {
      const l = c.treeId;
      (r || c.isDirty || c.dependencySheetName(this._currentConfigService.getDirtyNameMap()) || //O(n) n=tree.rangeList.length
      s.has(l) && !c.isExcludeRange(this._currentConfigService.getExcludedRange())) && !t.has(l) && (e.push(c), t.add(l));
    }
    return e;
  }
  _includeTreeFeature(i) {
    var n, s;
    const e = i.unitId, t = i.subUnitId, r = i.featureId;
    if (r != null) {
      const o = this._currentConfigService.getDirtyUnitFeatureMap();
      if (((s = (n = o == null ? void 0 : o[e]) == null ? void 0 : n[t]) == null ? void 0 : s[r]) != null)
        return !0;
    }
    return !1;
  }
  _includeOtherFormula(i) {
    var n, s;
    const e = i.unitId, t = i.subUnitId, r = i.formulaId;
    if (r != null) {
      const o = this._currentConfigService.getDirtyUnitOtherFormulaMap();
      if (((s = (n = o == null ? void 0 : o[e]) == null ? void 0 : n[t]) == null ? void 0 : s[r]) != null)
        return !0;
    }
    return !1;
  }
  _detectForcedRecalculationNode(i, e) {
    return e == null ? !1 : this._detectForcedRecalculationNodeRecursion(e);
  }
  _detectForcedRecalculationNodeRecursion(i) {
    if (i.isForcedCalculateFunction())
      return !0;
    const e = i.getChildren();
    for (let t = 0, r = e.length; t < r; t++) {
      const n = e[t];
      if (this._detectForcedRecalculationNodeRecursion(n))
        return !0;
    }
    return !1;
  }
  /**
   * Determine whether all ranges of the current node exist within the dirty area.
   * If they are within the dirty area, return true, indicating that this node needs to be calculated.
   * @param tree
   */
  _includeTree(i, e) {
    var c, l, f;
    const t = i.unitId, r = i.subUnitId;
    if (this._detectForcedRecalculationNode(i, e) === !0 || this._includeTreeFeature(i) === !0 || this._includeOtherFormula(i) === !0 || Fm(i, e, this._currentConfigService) === !0)
      return !0;
    const n = (l = (c = this._currentConfigService.getExcludedRange()) == null ? void 0 : c[t]) == null ? void 0 : l[r];
    if ((n == null ? void 0 : n.getValue(i.row, i.column)) != null)
      return !1;
    if (((f = this._currentConfigService.getDirtyNameMap()[t]) == null ? void 0 : f[r]) != null)
      return !0;
    if (!this._updateRangeFlattenCache.has(t))
      return !1;
    const o = this._updateRangeFlattenCache.get(t);
    if (!o.has(r))
      return !1;
    const u = o.get(r);
    for (const m of u)
      if (i.inRangeData(m))
        return !0;
    return !1;
  }
  /**
   * Generate the final formula calculation order array by traversing the dependency tree established via depth-first search.
   * @param treeList
   */
  _calculateRunList(i) {
    i.length;
    const e = i, t = [], r = [];
    for (; e.length > 0; ) {
      const n = e.pop();
      if (n === void 0 || n.isSkip())
        continue;
      if (n.isAdded()) {
        t.push(n), n.setSkip();
        continue;
      }
      r.length = 0;
      for (const o of n.parents) {
        const u = this._dependencyManagerService.getTreeById(o);
        if (!u)
          throw new Error("ParentDependencyTree object is null");
        u.isAdded() || n.isSkip() || r.push(u);
      }
      const s = this._dependencyRTreeCacheForAddressFunction.bulkSearch(n.toRTreeItem());
      for (const o of s) {
        const u = this._dependencyManagerService.getTreeById(o);
        if (!u)
          throw new Error("ParentDependencyTree object is null");
        u.isAdded() || n.isSkip() || r.push(u);
      }
      r.length === 0 ? (t.push(n), n.setSkip()) : (n.setAdded(), e.push(n, ...r));
    }
    return t;
  }
};
ia = Nh([
  vt(0, Wt),
  vt(1, Nt),
  vt(2, ja),
  vt(3, Wr),
  vt(4, ye(Vr)),
  vt(5, ye(Gr)),
  vt(6, ye(pr)),
  vt(7, cs)
], ia);
var Vh = Object.getOwnPropertyDescriptor, Oh = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Vh(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, Zt = (a, i) => (e, t) => i(e, t, a);
const Sh = 500, oa = Je("engine-formula.calculate-formula.service");
let ua = class extends Se {
  constructor(i, e, t, r, n, s, o) {
    super();
    A(this, "_executionInProgressListener$", new tr());
    A(this, "executionInProgressListener$", this._executionInProgressListener$.asObservable());
    A(this, "_executionCompleteListener$", new tr());
    A(this, "executionCompleteListener$", this._executionCompleteListener$.asObservable());
    A(this, "_executeLock", new Ic());
    this._configService = i, this._lexer = e, this._currentConfigService = t, this._runtimeService = r, this._formulaDependencyGenerator = n, this._interpreter = s, this._astTreeBuilder = o;
  }
  dispose() {
    super.dispose(), this._executionInProgressListener$.complete(), this._executionCompleteListener$.complete(), _r.clear(), Ke.clear(), qs.clear(), Js.clear();
  }
  /**
   * Stop the execution of the formula.
   */
  stopFormulaExecution() {
    this._runtimeService.stopExecution();
  }
  /**
   * When the feature is loading,
   * the pre-calculated content needs to be input to the formula engine in advance,
   * so that the formula can read the correct values.
   * @param featureId
   * @param featureData
   */
  setRuntimeFeatureCellData(i, e) {
    this._runtimeService.setRuntimeFeatureCellData(i, e);
  }
  setRuntimeFeatureRange(i, e) {
    this._runtimeService.setRuntimeFeatureRange(i, e);
  }
  async execute(i) {
    this._runtimeService.setFormulaExecuteStage(tt.START), this._executionInProgressListener$.next(this._runtimeService.getRuntimeState()), this._currentConfigService.load(i), this._runtimeService.reset();
    const e = i.maxIteration || xo;
    this._executeLock.acquire("FORMULA_EXECUTION_LOCK", async () => {
      for (let t = 0; t < e && (this._runtimeService.setFormulaCycleIndex(t), await this._executeStep(), _r.clear(), !!this._runtimeService.isCycleDependency()); t++)
        ;
      this._runtimeService.setFormulaExecuteStage(tt.CALCULATION_COMPLETED), this._executionInProgressListener$.next(this._runtimeService.getRuntimeState()), this._executionCompleteListener$.next(this._runtimeService.getAllRuntimeData()), Ke.clear(), this._runtimeService.reset();
    });
  }
  async _executeStep() {
    const i = await this._apply();
    if (i == null)
      return;
    const { arrayFormulaRange: e, runtimeFeatureRange: t } = i, { dirtyRanges: r, excludedCell: n } = this._getArrayFormulaDirtyRangeAndExcludedRange(
      e,
      t
    );
    return r == null || r.length === 0 || (_r.clear(), this._currentConfigService.loadDirtyRangesAndExcludedCell(r, n), await this._apply(!0)), !0;
  }
  _getArrayFormulaDirtyRangeAndExcludedRange(i, e) {
    const t = [], r = {};
    return Object.keys(i).forEach((n) => {
      const s = i[n];
      if (s == null)
        return !0;
      Object.keys(s).forEach((o) => {
        const u = new de(s[o]);
        if (u == null)
          return !0;
        const c = new de();
        u.forValue((l, f, m) => {
          c.setValue(l, f, !0), t.push({ unitId: n, sheetId: o, range: m });
        }), r[n] == null && (r[n] = {}), r[n][o] = c;
      });
    }), Object.keys(e).forEach((n) => {
      const s = e[n];
      Object.keys(s).forEach((o) => {
        const u = s[o];
        if (u == null)
          return !0;
        Object.keys(u).forEach((c) => {
          const l = u[c];
          if (l == null)
            return !0;
          for (const f of l)
            t.push({ unitId: o, sheetId: c, range: f });
        });
      });
    }), { dirtyRanges: t, excludedCell: r };
  }
  // eslint-disable-next-line max-lines-per-function
  async _apply(i = !1) {
    var u;
    i ? this._runtimeService.setFormulaExecuteStage(tt.START_DEPENDENCY_ARRAY_FORMULA) : this._runtimeService.setFormulaExecuteStage(tt.START_DEPENDENCY), this._executionInProgressListener$.next(this._runtimeService.getRuntimeState());
    const e = (await this._formulaDependencyGenerator.generate()).reverse(), t = this._interpreter;
    i ? (this._runtimeService.setFormulaExecuteStage(tt.START_CALCULATION_ARRAY_FORMULA), this._runtimeService.setTotalArrayFormulasToCalculate(e.length)) : (this._runtimeService.setFormulaExecuteStage(tt.START_CALCULATION), this._runtimeService.setTotalFormulasToCalculate(e.length)), this._executionInProgressListener$.next(this._runtimeService.getRuntimeState());
    let r = [];
    const n = this._configService.getConfig(pa), s = (n == null ? void 0 : n.intervalCount) || Sh, o = e.length;
    for (let c = 0; c < o; c++) {
      const l = e[c], f = l.nodeData, m = l.getDirtyData;
      if (c % s === 0 && (await new Promise((_) => {
        const C = Bc(_);
        r.push(C);
      }), i ? (this._runtimeService.setFormulaExecuteStage(
        tt.CURRENTLY_CALCULATING_ARRAY_FORMULA
      ), this._runtimeService.setCompletedArrayFormulasCount(c + 1)) : (this._runtimeService.setFormulaExecuteStage(tt.CURRENTLY_CALCULATING), this._runtimeService.setCompletedFormulasCount(c + 1)), this._executionInProgressListener$.next(this._runtimeService.getRuntimeState()), this._runtimeService.isStopExecution() || f == null && m == null)) {
        this._runtimeService.setFormulaExecuteStage(tt.IDLE), this._runtimeService.markedAsStopFunctionsExecuted(), this._executionCompleteListener$.next(this._runtimeService.getAllRuntimeData());
        return;
      }
      this._runtimeService.setCurrent(
        l.row,
        l.column,
        l.rowCount,
        l.columnCount,
        l.subUnitId,
        l.unitId
      );
      let d;
      if (m != null && l.featureId != null) {
        const { runtimeCellData: _, dirtyRanges: C } = m(this._currentConfigService.getDirtyData(), this._runtimeService.getAllRuntimeData());
        this._runtimeService.setRuntimeFeatureCellData(l.featureId, _), this._runtimeService.setRuntimeFeatureRange(l.featureId, C);
      } else f != null && (t.checkAsyncNode(f.node) ? d = await t.executeAsync(f) : d = t.execute(f), l.formulaId != null ? this._runtimeService.setRuntimeOtherData(l.formulaId, l.refOffsetX, l.refOffsetY, d) : this._runtimeService.setRuntimeData(d));
      (u = f.node) == null || u.resetCalculationState();
    }
    return r.forEach((c) => c()), r = [], o > 0 ? this._runtimeService.markedAsSuccessfullyExecuted() : i || this._runtimeService.markedAsNoFunctionsExecuted(), this._runtimeService.getAllRuntimeData();
  }
  calculate(i, e = !0) {
    const t = this._lexer.treeBuilder(i, e);
    if (Object.values(h).includes(t))
      return Ue.create(t);
    const r = this._astTreeBuilder.parse(t);
    r == null || r.serialize();
  }
};
ua = Oh([
  Zt(0, da),
  Zt(1, ye(pr)),
  Zt(2, Wt),
  Zt(3, Nt),
  Zt(4, aa),
  Zt(5, ye(Vr)),
  Zt(6, ye(Gr))
], ua);
var Mh = Object.getOwnPropertyDescriptor, Dh = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Mh(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, Ds = (a, i) => (e, t) => i(e, t, a);
let $n = class extends Se {
  constructor(a, i, e) {
    super(), this._commandService = a, this._calculateFormulaService = i, this._formulaDataModel = e, this._initialize();
  }
  _initialize() {
    this._commandExecutedListener(), this._initialExecuteFormulaListener();
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((a) => {
        if (a.id === So.id)
          this._calculateFormulaService.stopFormulaExecution();
        else if (a.id === Oo.id)
          this._calculate(a.params);
        else if (a.id === vs.id) {
          const i = a.params;
          if (i == null)
            return;
          const { arrayFormulaRange: e, arrayFormulaCellData: t } = i;
          this._formulaDataModel.setArrayFormulaRange(e), this._formulaDataModel.setArrayFormulaCellData(t);
        }
      })
    );
  }
  async _calculate(a) {
    const { forceCalculation: i = !1, dirtyRanges: e = [], dirtyNameMap: t = {}, dirtyDefinedNameMap: r = {}, dirtyUnitFeatureMap: n = {}, dirtyUnitOtherFormulaMap: s = {}, clearDependencyTreeCache: o = {}, maxIteration: u = xo, rowData: c } = a, l = this._formulaDataModel.getFormulaData(), f = this._formulaDataModel.getArrayFormulaCellData(), m = this._formulaDataModel.getArrayFormulaRange();
    this._calculateFormulaService.execute({
      formulaData: l,
      arrayFormulaCellData: f,
      arrayFormulaRange: m,
      forceCalculate: i,
      dirtyRanges: e,
      dirtyNameMap: t,
      dirtyDefinedNameMap: r,
      dirtyUnitFeatureMap: n,
      dirtyUnitOtherFormulaMap: s,
      clearDependencyTreeCache: o,
      maxIteration: u,
      rowData: c
    });
  }
  // Notification
  _initialExecuteFormulaListener() {
    this._calculateFormulaService.executionCompleteListener$.subscribe((a) => {
      const i = a.functionsExecutedState;
      switch (i) {
        case Ir.NOT_EXECUTED:
          break;
        case Ir.STOP_EXECUTION:
          break;
        case Ir.SUCCESS:
          this._applyResult(a);
          break;
        case Ir.INITIAL:
          break;
      }
      this._commandService.executeCommand(
        Sn.id,
        {
          functionsExecutedState: i
        },
        {
          onlyLocal: !0
        }
      );
    }), this._calculateFormulaService.executionInProgressListener$.subscribe((a) => {
      this._commandService.executeCommand(
        Sn.id,
        {
          stageInfo: a
        },
        {
          onlyLocal: !0
        }
      );
    });
  }
  async _applyResult(a) {
    const { unitData: i, unitOtherData: e, arrayFormulaRange: t, arrayFormulaCellData: r, clearArrayFormulaCellData: n, arrayFormulaEmbedded: s, imageFormulaData: o } = a;
    if (!i) {
      console.error("No sheetData from Formula Engine!");
      return;
    }
    (t || s) && (this._formulaDataModel.clearPreviousArrayFormulaCellData(n), this._formulaDataModel.mergeArrayFormulaCellData(r), this._formulaDataModel.mergeArrayFormulaRange(t), this._commandService.executeCommand(
      vs.id,
      {
        arrayFormulaRange: this._formulaDataModel.getArrayFormulaRange(),
        arrayFormulaCellData: this._formulaDataModel.getArrayFormulaCellData(),
        arrayFormulaEmbedded: s
      },
      {
        onlyLocal: !0
      }
    )), o && o.length > 0 && this._commandService.executeCommand(
      wo.id,
      {
        imageFormulaData: o
      },
      {
        onlyLocal: !0
      }
    ), this._commandService.executeCommand(
      Mo.id,
      {
        unitData: pl(i),
        unitOtherData: e
      },
      {
        onlyLocal: !0
      }
    );
  }
};
$n = Dh([
  Ds(0, lr),
  Ds(1, oa),
  Ds(2, ye(yr))
], $n);
const Gi = /[\[\]]/g;
function Wi(a, i) {
  if (Gi.test(a)) {
    const e = Number(a.replace(Gi, ""));
    return i + e;
  }
  return Number(a) - 1;
}
function ws(a, i = 0, e = 0) {
  a = a.toLocaleUpperCase();
  const t = a.split(/[RC]/), r = t[1], n = t[2], s = Wi(r, i), o = Wi(n, e);
  return {
    row: s,
    column: o,
    absoluteRefType: Le.NONE
  };
}
function wh(a, i = 0, e = 0) {
  const { refBody: t, sheetName: r, unitId: n } = Ca(a), s = t.indexOf(":");
  if (s === -1) {
    const C = ws(t, i, e), E = C.row, R = C.column, b = C.absoluteRefType;
    return {
      unitId: n,
      sheetName: r,
      range: {
        startRow: E,
        startColumn: R,
        endRow: E,
        endColumn: R,
        startAbsoluteRefType: b,
        endAbsoluteRefType: b
      }
    };
  }
  const o = t.substring(0, s), u = t.substring(s + 1), c = ws(o, i, e), l = ws(u, i, e), f = c.row, m = c.column, d = l.row, _ = l.column;
  return {
    unitId: n,
    sheetName: r,
    range: {
      startRow: f,
      startColumn: m,
      endRow: d,
      endColumn: _,
      startAbsoluteRefType: c.absoluteRefType,
      endAbsoluteRefType: l.absoluteRefType
    }
  };
}
function Lh(a) {
  const i = cn(a.startRow, a.startAbsoluteRefType, !0), e = cn(a.startColumn, a.startAbsoluteRefType, !1), t = cn(a.endRow, a.endAbsoluteRefType, !0), r = cn(a.endColumn, a.endAbsoluteRefType, !1);
  return i === t && e === r ? `R${i}C${e}` : `R${i}C${e}:R${t}C${r}`;
}
function cn(a, i = Le.ALL, e) {
  switch (a += 1, i) {
    case Le.ALL:
      return `${a}`;
    case Le.ROW:
      return e ? `${a}` : `[${a}]`;
    case Le.COLUMN:
      return e ? `[${a}]` : `${a}`;
    case Le.NONE:
      return `[${a}]`;
  }
}
function rr(a) {
  let i = a;
  if (a.isArray()) {
    const e = a.getRowCount(), t = a.getColumnCount();
    if (e > 1 || t > 1)
      return g.create(h.VALUE);
    i = a.get(0, 0);
  }
  return i.isError(), i;
}
function zr(...a) {
  for (let i = 0; i < a.length; i++) {
    const e = rr(a[i]);
    if (e.isError())
      return {
        isError: !0,
        errorObject: e
      };
    a[i] = e;
  }
  return {
    isError: !1,
    variants: a
  };
}
function W(...a) {
  for (let i = 0; i < a.length; i++) {
    const e = rr(a[i]);
    if (e.isError())
      return {
        isError: !0,
        errorObject: e
      };
    if (e.isBoolean())
      return {
        isError: !0,
        errorObject: g.create(h.VALUE)
      };
    a[i] = e;
  }
  return {
    isError: !1,
    variants: a
  };
}
function Ye(...a) {
  for (let i = 0; i < a.length; i++) {
    let e = a[i];
    if (e.isError())
      return {
        isError: !0,
        errorObject: e
      };
    if (e.isNull())
      return {
        isError: !0,
        errorObject: g.create(h.NA)
      };
    if (e = rr(a[i]), e.isError())
      return {
        isError: !0,
        errorObject: e
      };
    if (e.isBoolean())
      return {
        isError: !0,
        errorObject: g.create(h.VALUE)
      };
    a[i] = e;
  }
  return {
    isError: !1,
    variants: a
  };
}
function I(...a) {
  for (let i = 0; i < a.length; i++) {
    let e = a[i];
    if (e.isString() && (e = e.convertToNumberObjectValue()), e.isError())
      return {
        isError: !0,
        errorObject: e
      };
    a[i] = e;
  }
  return {
    isError: !1,
    variants: a
  };
}
class N {
  constructor(i) {
    A(this, "_unitId");
    A(this, "_subUnitId");
    A(this, "_row", -1);
    A(this, "_column", -1);
    A(this, "_definedNames");
    A(this, "_locale");
    A(this, "_sheetOrder");
    A(this, "_sheetNameMap");
    A(this, "_formulaDataModel");
    A(this, "_rowCount", -1);
    A(this, "_columnCount", -1);
    /**
     * Whether the function needs to expand the parameters
     */
    A(this, "needsExpandParams", !1);
    /**
     * Whether the function needs to pass in reference object
     */
    A(this, "needsReferenceObject", !1);
    /**
     * Whether the function needs handle locale
     */
    A(this, "needsLocale", !1);
    /**
     * Whether the function needs sheets info
     */
    A(this, "needsSheetsInfo", !1);
    /**
     * Whether the function needs function methods in FormulaDataModel
     */
    A(this, "needsFormulaDataModel", !1);
    /**
     * Whether the function needs the number of rows and columns in the sheet
     */
    A(this, "needsSheetRowColumnCount", !1);
    /**
     * Whether the function needs to filter out rows
     */
    A(this, "needsFilteredOutRows", !1);
    /**
     * Minimum number of parameters
     */
    A(this, "minParams", -1);
    /**
     * Maximum number of parameters
     */
    A(this, "maxParams", -1);
    this._name = i;
  }
  get name() {
    return this._name;
  }
  get unitId() {
    return this._unitId;
  }
  get subUnitId() {
    return this._subUnitId;
  }
  get row() {
    return this._row;
  }
  get column() {
    return this._column;
  }
  dispose() {
  }
  /**
   * In Excel, to inject a defined name into a function that has positioning capabilities,
   * such as using the INDIRECT function to reference a named range,
   * you can write it as follows:
   * =INDIRECT("DefinedName1")
   */
  getDefinedName(i) {
    var t;
    const e = this._definedNames;
    return e == null ? null : (t = Array.from(Object.values(e)).filter((r) => r.name === i)) == null ? void 0 : t[0];
  }
  setDefinedNames(i) {
    this._definedNames = i;
  }
  getLocale() {
    return this._locale;
  }
  setLocale(i) {
    this._locale = i;
  }
  getSheetsInfo() {
    return {
      sheetOrder: this._sheetOrder,
      sheetNameMap: this._sheetNameMap
    };
  }
  setSheetsInfo({
    sheetOrder: i,
    sheetNameMap: e
  }) {
    this._sheetOrder = i, this._sheetNameMap = e;
  }
  setFormulaDataModel(i) {
    this._formulaDataModel = i;
  }
  setSheetRowColumnCount(i, e) {
    this._rowCount = i, this._columnCount = e;
  }
  isAsync() {
    return !1;
  }
  isAddress() {
    return !1;
  }
  isCustom() {
    return !1;
  }
  isArgumentsIgnoreNumberPattern() {
    return !1;
  }
  setRefInfo(i, e, t, r) {
    this._unitId = i, this._subUnitId = e, this._row = t, this._column = r;
  }
  calculateCustom(...i) {
    return null;
  }
  calculate(...i) {
    return g.create(h.VALUE);
  }
  checkArrayType(i) {
    return i.isReferenceObject() || i.isValueObject() && i.isArray();
  }
  /**
   * Starting with 1
   * For instance, The column number (starting with 1 for the left-most column of table_array) that contains the return value.
   * https://support.microsoft.com/en-us/office/vlookup-function-0bbc8083-26fe-4963-8ab8-93a18ad188a1
   * @param indexNum
   */
  getIndexNumValue(i, e = 1) {
    let t = i;
    if (t.isArray() && (t = t.getFirstCell()), t.isBoolean())
      return t.getValue() === !1 ? g.create(h.VALUE) : e;
    if (t.isString()) {
      const r = Number(t.getValue());
      return Number.isNaN(r) ? g.create(h.REF) : r;
    } else if (t.isNumber())
      return t.getValue();
    return g.create(h.VALUE);
  }
  /**
   * A logical value that specifies 1/TRUE , 0/FALSE, default 1
   * For instance range_lookup, A logical value that specifies whether you want VLOOKUP to find an approximate or an exact match
   * Approximate match - 1/TRUE
   * Exact match - 0/FALSE
   * https://support.microsoft.com/en-us/office/vlookup-function-0bbc8083-26fe-4963-8ab8-93a18ad188a1
   * For instance A1, A logical value that specifies what type of reference is contained in the cell ref_text.
   * If a1 is TRUE or omitted, ref_text is interpreted as an A1-style reference.
   * If a1 is FALSE, ref_text is interpreted as an R1C1-style reference.
   * https://support.microsoft.com/zh-cn/office/indirect-%E5%87%BD%E6%95%B0-474b3a3a-8a26-4f44-b491-92b6306fa261
   * @param logicValueObject
   */
  getZeroOrOneByOneDefault(i) {
    if (i == null)
      return 1;
    let e = 1;
    if (i.isArray() && (i = i.getFirstCell()), i.isBoolean())
      i.getValue() === !1 && (e = 0);
    else {
      if (i.isString())
        return;
      i.isNumber() && i.getValue() === 0 && (e = 0);
    }
    return e;
  }
  /**
   * A logical value that specifies 1/TRUE , 0/FALSE, -1, default 1.
   * The difference from getZeroOrOneByOneDefault is that we need to get -1
   * @param logicValueObject
   */
  getMatchTypeValue(i) {
    if (i == null)
      return 1;
    let e = 1;
    if (i.isArray() && (i = i.getFirstCell()), i.isBoolean())
      i.getValue() === !1 && (e = 0);
    else {
      if (i.isString())
        return;
      if (i.isNumber()) {
        const t = i.getValue();
        t <= 0 && (e = t);
      }
    }
    return e;
  }
  binarySearch(i, e, t, r, n) {
    const s = e.binarySearch(i, r, n);
    if (s == null)
      return g.create(h.NA);
    let o;
    return t.getRowCount() === 1 ? o = t.get(0, s) || ce.create() : o = t.get(s, 0) || ce.create(), o.isNull() ? y.create(0) : o;
  }
  _getOneFirstByRaw(i) {
    return i.length === 0 ? g.create(h.NA) : i[0][0] || g.create(h.NA);
  }
  _getOneLastByRaw(i) {
    return i.length === 0 ? g.create(h.NA) : i[i.length - 1][i[0].length - 1] || g.create(h.NA);
  }
  equalSearch(i, e, t, r = !0) {
    const n = t.pickRaw(e.isEqual(i));
    return r ? this._getOneFirstByRaw(n) : this._getOneLastByRaw(n);
  }
  fuzzySearch(i, e, t, r = !0) {
    const n = t.pickRaw(e.compare(i, Y.EQUALS));
    return r ? this._getOneFirstByRaw(n) : this._getOneLastByRaw(n);
  }
  orderSearch(i, e, t, r = xe.MIN, n = !1) {
    const s = e.orderSearch(i, r, n);
    if (s == null)
      return g.create(h.NA);
    const o = t.get(s.row, s.column) || ce.create();
    return o.isNull() ? g.create(h.NA) : o;
  }
  binarySearchExpand(i, e, t, r = 0, n, s) {
    const o = e.binarySearch(i, n, s);
    return o == null ? g.create(h.NA) : r === 0 ? t.slice([o, o + 1]) : t.slice(void 0, [o, o + 1]);
  }
  equalSearchExpand(i, e, t, r = !0, n = 0) {
    const s = e.isEqual(i);
    let o;
    return r ? o = s.getFirstTruePosition() : o = s.getLastTruePosition(), o == null ? g.create(h.NA) : n === 0 ? t.slice([o.row, o.row + 1]) : t.slice(void 0, [o.column, o.column + 1]);
  }
  fuzzySearchExpand(i, e, t, r = !0, n = 0) {
    const s = e.compare(i, Y.EQUALS);
    let o;
    return r ? o = s.getFirstTruePosition() : o = s.getLastTruePosition(), o == null ? g.create(h.NA) : n === 0 ? t.slice([o.row, o.row + 1]) : t.slice(void 0, [o.column, o.column + 1]);
  }
  orderSearchExpand(i, e, t, r = xe.MIN, n = !1, s = 0) {
    const o = e.orderSearch(i, r, n);
    return o == null ? g.create(h.NA) : s === 0 ? t.slice([o.row, o.row + 1]) : t.slice(void 0, [o.column, o.column + 1]);
  }
  flattenArray(i, e = !0) {
    const t = [];
    t[0] = [];
    for (let r = 0; r < i.length; r++) {
      let n = i[r];
      if ((n.isString() || n.isBoolean() || n.isNull()) && (n = n.convertToNumberObjectValue()), n.isError())
        return n;
      if (n.isArray()) {
        let s;
        if (n.iterator((o) => {
          if (o == null || o.isNull() || e && (o.isString() || o.isBoolean()))
            return !0;
          if (o = this._includingLogicalValuesAndText(o), o.isError())
            return s = o, !1;
          t[0].push(o);
        }), s != null && s.isError())
          return s;
      } else
        t[0].push(n);
    }
    return mt(t, 1, t[0].length);
  }
  _includingLogicalValuesAndText(i) {
    if (i.isBoolean() && (i = Mm(i)), i.isString()) {
      const e = Number(i.getValue());
      i = y.create(Number.isNaN(e) ? 0 : e);
    }
    return i;
  }
  createReferenceObject(i, e) {
    const t = i.getForcedUnitId() || i.getDefaultUnitId() || "", r = i.getForcedSheetId() || i.getDefaultUnitId() || "", n = i.getForcedSheetName(), o = Ts({
      unitId: t,
      sheetName: n,
      range: e
    });
    let u;
    return qr(o) ? u = new Ma(o) : Eo(o) ? u = new wa(o) : Ro(o) ? u = new Da(o) : u = new xn(e, r, t), this._setReferenceDefault(i, u);
  }
  _setReferenceDefault(i, e) {
    if (this.unitId == null || this.subUnitId == null)
      return g.create(h.REF);
    e.setDefaultUnitId(this.unitId), e.setDefaultSheetId(this.subUnitId);
    const t = i.getUnitId();
    t != null && e.setForcedUnitIdDirect(t);
    const r = i.getForcedSheetId();
    return r != null && e.setForcedSheetIdDirect(r), e.setForcedSheetName(i.getForcedSheetName()), e.setUnitData(i.getUnitData()), e.setRuntimeData(i.getRuntimeData()), e.setArrayFormulaCellData(i.getArrayFormulaCellData()), e.setUnitStylesData(i.getUnitStylesData()), e;
  }
}
class Ph extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    if (e.isError())
      return e;
    const { isError: n, errorObject: s, variants: o } = zr(t, r);
    if (n)
      return s;
    const { isError: u, errorObject: c, variants: l } = I(...o);
    if (u)
      return c;
    const [f, m] = l, d = Math.floor(+f.getValue()), _ = Math.floor(+m.getValue());
    if (d < 0 || _ < 0)
      return g.create(h.NUM);
    if (d === 0 || _ === 0)
      return g.create(h.REF);
    const C = e.isArray() ? e.getRowCount() : 1, E = e.isArray() ? e.getColumnCount() : 1;
    if (C === 1 && E === 1)
      return e.isArray() ? e.get(0, 0) : e;
    const R = d > C ? C : d, b = _ > E ? E : _;
    return e.slice([0, R], [0, b]);
  }
}
class xh extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const n = e[r], s = n.isArray() ? n.getRowCount() : 1, o = n.isArray() ? n.getColumnCount() : 1;
      for (let u = 0; u < s; u++)
        for (let c = 0; c < o; c++) {
          const l = n.isArray() ? n.get(u, c) : n;
          t.push([l]);
        }
    }
    return K.create({
      calculateValueList: t,
      rowCount: t.length,
      columnCount: 1,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
}
var ca = /* @__PURE__ */ ((a) => (a.ARRAY_CONSTRAIN = "ARRAY_CONSTRAIN", a.FLATTEN = "FLATTEN", a))(ca || {});
const jh = [
  [Ph, ca.ARRAY_CONSTRAIN],
  [xh, ca.FLATTEN]
];
var Or;
((a) => {
  const i = 0.636619772;
  function e(n, s) {
    let o = 0;
    for (let u = 0; u < n.length; ++u)
      o = s * o + n[u];
    return o;
  }
  function t(n, s, o, u, c) {
    if (s === 0)
      return o;
    if (s === 1)
      return u;
    const l = 2 / n;
    let f = o, m = u, d = u;
    for (let _ = 1; _ < s; ++_)
      d = m * _ * l + c * f, f = m, m = d;
    return d;
  }
  function r(n, s, o, u) {
    return function(l, f) {
      if (o) {
        if (l === 0)
          return o === 1 ? -1 / 0 : 1 / 0;
        if (l < 0)
          return Number.NaN;
      }
      if (f === 0)
        return n(l);
      if (f === 1)
        return s(l);
      if (f < 0)
        return Number.NaN;
      const m = f | 0, d = n(l), _ = s(l);
      return t(l, m, d, _, u);
    };
  }
  a.besselj = /* @__PURE__ */ (() => {
    const n = [-184.9052456, 77392.33017, -1121442418e-2, 6516196407e-1, -13362590354, 57568490574], s = [1, 267.8532712, 59272.64853, 9494680718e-3, 1029532985, 57568490411], o = [2093887211e-16, -2073370639e-15, 2734510407e-14, -0.001098628627, 1], u = [-934935152e-16, 7621095161e-16, -6911147651e-15, 1430488765e-13, -0.01562499995];
    function c(C) {
      let E = 0, R = 0, b = 0, p = C * C;
      if (C < 8)
        R = e(n, p), b = e(s, p), E = R / b;
      else {
        const V = C - 0.785398164;
        p = 64 / p, R = e(o, p), b = e(u, p), E = Math.sqrt(i / C) * (Math.cos(V) * R - Math.sin(V) * b * 8 / C);
      }
      return E;
    }
    const l = [-30.16036606, 15704.4826, -2972611439e-3, 2423968531e-1, -7895059235, 72362614232], f = [1, 376.9991397, 99447.43394, 1858330474e-2, 2300535178, 144725228442], m = [-240337019e-15, 2457520174e-15, -3516396496e-14, 183105e-8, 1], d = [105787412e-15, -88228987e-14, 8449199096e-15, -2002690873e-13, 0.04687499995];
    function _(C) {
      let E = 0, R = 0, b = 0, p = C * C;
      const V = Math.abs(C) - 2.356194491;
      return Math.abs(C) < 8 ? (R = C * e(l, p), b = e(f, p), E = R / b) : (p = 64 / p, R = e(m, p), b = e(d, p), E = Math.sqrt(i / Math.abs(C)) * (Math.cos(V) * R - Math.sin(V) * b * 8 / Math.abs(C)), C < 0 && (E = -E)), E;
    }
    return function C(E, R) {
      const b = Math.round(R);
      if (!Number.isFinite(E))
        return Number.isNaN(E) ? E : 0;
      if (b < 0)
        return (b % 2 ? -1 : 1) * C(E, -b);
      if (E < 0)
        return (b % 2 ? -1 : 1) * C(-E, b);
      if (b === 0)
        return c(E);
      if (b === 1)
        return _(E);
      if (E === 0)
        return 0;
      let p = 0;
      if (E > b)
        p = t(E, b, c(E), _(E), -1);
      else {
        const V = 2 * Math.floor((b + Math.floor(Math.sqrt(40 * b))) / 2);
        let S = !1, M = 0, D = 0, w = 1, L = 0;
        const v = 2 / E;
        for (let j = V; j > 0; j--)
          if (L = j * v * w - M, M = w, w = L, Math.abs(w) > 1e10 && (w *= 1e-10, M *= 1e-10, p *= 1e-10, D *= 1e-10), S && (D += w), S = !S, j === b && (p = M), V - j > 100 && p === 0)
            return Number.NaN;
        D = 2 * D - w, p /= D;
      }
      return p;
    };
  })(), a.bessely = (() => {
    const n = [228.4622733, -86327.92757, 1087988129e-2, -5123598036e-1, 7062834065, -2957821389], s = [1, 226.1030244, 47447.2647, 7189466438e-3, 7452499648e-1, 40076544269], o = [2093887211e-16, -2073370639e-15, 2734510407e-14, -0.001098628627, 1], u = [-934945152e-16, 7621095161e-16, -6911147651e-15, 1430488765e-13, -0.01562499995];
    function c(C) {
      let E = 0, R = 0, b = 0, p = C * C;
      const V = C - 0.785398164;
      return C < 8 ? (R = e(n, p), b = e(s, p), E = R / b + i * (0, a.besselj)(C, 0) * Math.log(C)) : (p = 64 / p, R = e(o, p), b = e(u, p), E = Math.sqrt(i / C) * (Math.sin(V) * R + Math.cos(V) * b * 8 / C)), E;
    }
    const l = [8511.937935, -4237922726e-3, 7349264551e-1, -51534381390, 127527439e4, -4900604943e3], f = [1, 354.9632885, 102042.605, 2245904002e-2, 3733650367, 424441966400, 249958057e5], m = [-240337019e-15, 2457520174e-15, -3516396496e-14, 183105e-8, 1], d = [105787412e-15, -88228987e-14, 8449199096e-15, -2002690873e-13, 0.04687499995];
    function _(C) {
      let E = 0, R = 0, b = 0, p = C * C;
      const V = C - 2.356194491;
      return C < 8 ? (R = C * e(l, p), b = e(f, p), E = R / b + i * ((0, a.besselj)(C, 1) * Math.log(C) - 1 / C)) : (p = 64 / p, R = e(m, p), b = e(d, p), E = Math.sqrt(i / C) * (Math.sin(V) * R + Math.cos(V) * b * 8 / C)), E;
    }
    return r(c, _, 1, -1);
  })(), a.besseli = /* @__PURE__ */ (() => {
    const n = [45813e-7, 0.0360768, 0.2659732, 1.2067492, 3.0899424, 3.5156229, 1], s = [392377e-8, -0.01647633, 0.02635537, -0.02057706, 916281e-8, -157565e-8, 225319e-8, 0.01328592, 0.39894228];
    function o(f) {
      return f <= 3.75 ? e(n, f * f / (3.75 * 3.75)) : Math.exp(Math.abs(f)) / Math.sqrt(Math.abs(f)) * e(s, 3.75 / Math.abs(f));
    }
    const u = [32411e-8, 301532e-8, 0.02658733, 0.15084934, 0.51498869, 0.87890594, 0.5], c = [-420059e-8, 0.01787654, -0.02895312, 0.02282967, -0.01031555, 163801e-8, -362018e-8, -0.03988024, 0.39894228];
    function l(f) {
      return f < 3.75 ? f * e(u, f * f / (3.75 * 3.75)) : (f < 0 ? -1 : 1) * Math.exp(Math.abs(f)) / Math.sqrt(Math.abs(f)) * e(c, 3.75 / Math.abs(f));
    }
    return function f(m, d) {
      const _ = Math.round(d);
      if (_ === 0)
        return o(m);
      if (_ === 1)
        return l(m);
      if (_ < 0)
        return Number.NaN;
      if (Math.abs(m) === 0)
        return 0;
      if (m === 1 / 0)
        return 1 / 0;
      let C = 0, E;
      const R = 2 / Math.abs(m);
      let b = 0, p = 1, V = 0;
      const S = 2 * Math.round((_ + Math.round(Math.sqrt(40 * _))) / 2);
      for (E = S; E > 0; E--)
        if (V = E * R * p + b, b = p, p = V, Math.abs(p) > 1e10 && (p *= 1e-10, b *= 1e-10, C *= 1e-10), E === _ && (C = b), S - E > 100 && C === 0)
          return Number.NaN;
      return C *= f(m, 0) / p, m < 0 && _ % 2 ? -C : C;
    };
  })(), a.besselk = (() => {
    const n = [74e-7, 1075e-7, 262698e-8, 0.0348859, 0.23069756, 0.4227842, -0.57721566], s = [53208e-8, -25154e-7, 587872e-8, -0.01062446, 0.02189568, -0.07832358, 1.25331414];
    function o(f) {
      return f <= 2 ? -Math.log(f / 2) * (0, a.besseli)(f, 0) + e(n, f * f / 4) : Math.exp(-f) / Math.sqrt(f) * e(s, 2 / f);
    }
    const u = [-4686e-8, -110404e-8, -0.01919402, -0.18156897, -0.67278579, 0.15443144, 1], c = [-68245e-8, 325614e-8, -780353e-8, 0.01504268, -0.0365562, 0.23498619, 1.25331414];
    function l(f) {
      return f <= 2 ? Math.log(f / 2) * (0, a.besseli)(f, 1) + 1 / f * e(u, f * f / 4) : Math.exp(-f) / Math.sqrt(f) * e(c, 2 / f);
    }
    return r(o, l, 2, 1);
  })();
})(Or || (Or = {}));
function Ua(a) {
  return /^[01]{1,10}$/.test(a);
}
function va(a) {
  return /^[0-7]{1,10}$/.test(a);
}
function Ta(a) {
  return /^[0-9A-Fa-f]{1,10}$/.test(a);
}
function nr(a) {
  if (a === 0)
    return 0;
  const i = [
    -1.3026537197817094,
    // eslint-disable-next-line no-loss-of-precision
    0.6419697923564902,
    0.019476473204185836,
    -0.00956151478680863,
    -946595344482036e-18,
    366839497852761e-18,
    42523324806907e-18,
    -20278578112534e-18,
    -1624290004647e-18,
    130365583558e-17,
    15626441722e-18,
    -85238095915e-18,
    6529054439e-18,
    5059343495e-18,
    -991364156e-18,
    -227365122e-18,
    96467911e-18,
    2394038e-18,
    -6886027e-18,
    894487e-18,
    313092e-18,
    -112708e-18,
    381e-18,
    7106e-18,
    -1523e-18,
    -94e-18,
    121e-18,
    -28e-18
  ];
  let e = a, t = !1;
  e < 0 && (e = -e, t = !0);
  const r = 2 / (2 + e), n = 4 * r - 2;
  let s = 0, o = 0, u;
  for (let l = i.length - 1; l > 0; l--)
    u = s, s = n * s - o + i[l], o = u;
  const c = r * Math.exp(-e * e + 0.5 * (i[0] + n * s) - o);
  return t ? c - 1 : 1 - c;
}
function Ia(a) {
  return 1 - nr(a);
}
function Uh(a) {
  if (a >= 2)
    return -100;
  if (a <= 0)
    return 100;
  const i = a < 1 ? a : 2 - a, e = Math.sqrt(-2 * Math.log(i / 2));
  let t = -0.70711 * ((2.30753 + e * 0.27061) / (1 + e * (0.99229 + e * 0.04481)) - e);
  for (let r = 0; r < 2; r++) {
    const n = Ia(t) - i;
    t += n / (1.1283791670955126 * Math.exp(-t * t) - t * n);
  }
  return a < 1 ? t : -t;
}
function Ar(a, i = 1) {
  let e = Math.floor(a);
  if (a < 0)
    return Number.NaN;
  let t = 1;
  for (; e > 1 && Number.isFinite(t); )
    t *= e, e -= i;
  return t;
}
function sr(a, i) {
  const e = Math.min(a - i, i);
  let t = 1;
  for (let r = 1; r <= e && Number.isFinite(t); r++)
    t *= a - r + 1, t /= r;
  return t;
}
function la(a, i) {
  let e = Math.floor(a), t = Math.floor(i);
  for (; t !== 0; ) {
    const r = t;
    t = e % t, e = r;
  }
  return e;
}
function Qi(a, i) {
  const e = la(a, i);
  return e === 0 ? 0 : Math.abs(a * i) / e;
}
function Ba(a) {
  const i = a.length;
  if (i === 1)
    return a[0][0];
  if (i === 2)
    return a[0][0] * a[1][1] - a[0][1] * a[1][0];
  const { rowSwap: e, smallPivotDetected: t, luMatrix: r, permutation: n } = au(a);
  if (t)
    return 0;
  let s = e ? 1 : -1;
  for (let o = 0; o < n.length; o++)
    s *= r[o][o];
  return s === 0 ? 0 : s;
}
function vh(a) {
  const i = Ba(a);
  return i === 0 ? null : a.length === 1 ? [[1 / i]] : Ih(a).map((r) => r.map((n) => n / i));
}
function Th(a, i, e) {
  return a.filter((t, r) => r !== i).map((t) => t.filter((r, n) => n !== e));
}
function Ih(a) {
  const i = a.length, e = Array.from({ length: i }, () => new Array(i).fill(0));
  for (let t = 0; t < i; t++)
    for (let r = 0; r < i; r++) {
      const s = ((t + r) % 2 === 0 ? 1 : -1) * Ba(Th(a, t, r));
      e[r][t] = s === 0 ? 0 : s;
    }
  return e;
}
function Er(a, i) {
  return a.map((e) => i[0].map(
    (t, r) => e.reduce((n, s, o) => n + s * i[o][r], 0)
  ));
}
function Rt(a) {
  return a[0].map((i, e) => a.map((t) => t[e]));
}
function Bh(a) {
  const { smallPivotDetected: i, luMatrix: e, permutation: t } = au(a);
  return i ? null : Fh(e, t);
}
function au(a) {
  const i = Rt(a), e = i.length, t = i[0].length;
  let r = !0, n = !1;
  const s = fa(e, t, 0), o = new Array(t).fill(0).map((u, c) => c);
  for (let u = 0; u < t; u++) {
    for (let m = 0; m < u; m++) {
      let d = i[m][u];
      for (let _ = 0; _ < m; _++)
        d -= s[m][_] * s[_][u];
      s[m][u] = d;
    }
    let c = -1 / 0, l = u;
    for (let m = u; m < e; m++) {
      let d = i[m][u];
      for (let C = 0; C < u; C++)
        d -= s[m][C] * s[C][u];
      s[m][u] = d;
      const _ = Math.abs(d);
      _ > c && (c = _, l = m);
    }
    if (Math.abs(s[l][u]) < 1e-11) {
      n = !0;
      break;
    }
    l !== u && ([s[u], s[l]] = [s[l], s[u]], [i[u], i[l]] = [i[l], i[u]], [o[u], o[l]] = [o[l], o[u]], r = !r);
    const f = s[u][u];
    for (let m = u + 1; m < e; m++)
      s[m][u] /= f;
  }
  return {
    rowSwap: r,
    smallPivotDetected: n,
    luMatrix: s,
    permutation: o
  };
}
function Fh(a, i) {
  const e = i.length, t = fa(e, e, 0);
  for (let n = 0; n < e; n++)
    t[n][n] = 1;
  const r = fa(e, e, 0);
  for (let n = 0; n < e; n++) {
    const s = i[n];
    for (let o = 0; o < e; o++)
      r[n][o] = t[s][o];
  }
  for (let n = 0; n < e; n++) {
    const s = r[n];
    for (let o = n + 1; o < e; o++) {
      const u = a[o][n];
      for (let c = 0; c < e; c++)
        r[o][c] -= s[c] * u;
    }
  }
  for (let n = e - 1; n >= 0; n--) {
    const s = r[n], o = a[n][n];
    for (let u = 0; u < e; u++)
      s[u] /= o;
    for (let u = 0; u < n; u++) {
      const c = a[u][n];
      for (let l = 0; l < e; l++)
        r[u][l] -= s[l] * c;
    }
  }
  return r;
}
function fa(a, i, e) {
  const t = [];
  for (let r = 0; r < a; r++) {
    t[r] = [];
    for (let n = 0; n < i; n++)
      t[r].push(e);
  }
  return t;
}
function kh(a) {
  const i = $h(a);
  if (!i)
    return null;
  const { matrixU: e, matrixS: t, matrixV: r } = i, n = Rt(e), s = Array.from({ length: t.length }, () => new Array(a[0].length).fill(0)), o = Math.max(a.length, a[0].length) * Number.EPSILON * t[0];
  for (let u = 0; u < t.length; u++)
    Math.abs(t[u]) > o && (s[u][u] = 1 / t[u]);
  return Er(r, Er(s, n));
}
function $h(a) {
  const i = Rt(a), e = i.length, t = i[0].length;
  if (e < t)
    return null;
  const r = new Array(t).fill(0), n = new Array(t).fill(0), s = Array.from({ length: t }, () => new Array(t).fill(0));
  let o = Number.EPSILON, u = 0, c = 0, l = 0;
  for (let C = 0; C < t; C++) {
    if (r[C] = u, c = Ls(i, C, e, C, C), c <= 1e-64 / o)
      u = 0;
    else {
      u = Math.sqrt(c), i[C][C] >= 0 && (u = -u);
      const R = i[C][C] * u - c;
      i[C][C] -= u;
      for (let b = C + 1; b < t; b++) {
        c = Ls(i, C, e, C, b);
        for (let p = C; p < e; p++)
          i[p][b] += c / R * i[p][C];
      }
    }
    if (n[C] = u, c = qi(i, C + 1, t, C, C), c <= 1e-64 / o)
      u = 0;
    else {
      u = Math.sqrt(c), i[C][C + 1] >= 0 && (u = -u);
      const R = i[C][C + 1] * u - c;
      i[C][C + 1] -= u;
      for (let b = C + 1; b < t; b++)
        r[b] = i[C][b] / R;
      for (let b = C + 1; b < e; b++) {
        c = qi(i, C + 1, t, b, C);
        for (let p = C + 1; p < t; p++)
          i[b][p] += c * r[p];
      }
    }
    const E = Math.abs(n[C]) + Math.abs(r[C]);
    E > l && (l = E);
  }
  let f = 0;
  for (let C = t - 1; C >= 0; C--) {
    if (u !== 0) {
      for (let E = f; E < t; E++)
        s[E][C] = i[C][E] / (u * i[C][C + 1]);
      for (let E = f; E < t; E++) {
        c = 0;
        for (let R = f; R < t; R++)
          c += i[C][R] * s[R][E];
        for (let R = f; R < t; R++)
          s[R][E] += c * s[R][C];
      }
    }
    for (let E = f; E < t; E++)
      s[C][E] = 0, s[E][C] = 0;
    s[C][C] = 1, u = r[C], f = C;
  }
  for (let C = t - 1; C >= 0; C--) {
    u = n[C];
    for (let E = C + 1; E < t; E++)
      i[C][E] = 0;
    if (u !== 0) {
      for (let E = C + 1; E < t; E++) {
        c = Ls(i, C + 1, e, C, E);
        for (let R = C; R < e; R++)
          i[R][E] += c / (i[C][C] * u) * i[R][C];
      }
      for (let E = C; E < e; E++)
        i[E][C] /= u;
    } else
      for (let E = C; E < e; E++)
        i[E][C] = 0;
    i[C][C] += 1;
  }
  o *= l;
  let m = 0, d = 0, _ = 0;
  for (let C = t - 1; C >= 0; C--)
    for (let E = 0; E < 50; E++) {
      let R = !1, b = C;
      for (; b >= 0; b--) {
        if (Math.abs(r[b]) <= o) {
          R = !0;
          break;
        }
        if (Math.abs(n[b - 1]) <= o)
          break;
      }
      if (!R) {
        let M = 0, D = 1;
        for (let w = b; w < C + 1 && (m = D * r[w], d = n[w], r[w] *= M, !(Math.abs(m) <= o)); w++) {
          _ = ln(m, d), n[w] = _, M = d / _, D = -m / _;
          for (let L = 0; L < e; L++) {
            const v = i[L][b - 1], j = i[L][w];
            i[L][b - 1] = v * M + j * D, i[L][w] = -v * D + j * M;
          }
        }
      }
      if (b === C) {
        if (n[C] < 0) {
          n[C] = -n[C];
          for (let M = 0; M < t; M++)
            s[M][C] = -s[M][C];
        }
        break;
      }
      if (E >= 49)
        return null;
      let p = n[b];
      m = ((n[C - 1] - n[C]) * (n[C - 1] + n[C]) + (r[C - 1] - r[C]) * (r[C - 1] + r[C])) / (2 * r[C] * n[C - 1]), _ = ln(m, 1), m < 0 ? m = ((p - n[C]) * (p + n[C]) + r[C] * (n[C - 1] / (m - _) - r[C])) / p : m = ((p - n[C]) * (p + n[C]) + r[C] * (n[C - 1] / (m + _) - r[C])) / p;
      let V = 1, S = 1;
      for (let M = b + 1; M < C + 1; M++) {
        let D = r[M], w = n[M];
        d = S * D, D *= V, _ = ln(m, d), r[M - 1] = _, V = m / _, S = d / _, m = p * V + D * S, d = w * S, D = -p * S + D * V, w *= V;
        for (let L = 0; L < t; L++) {
          const v = s[L][M - 1], j = s[L][M];
          s[L][M - 1] = v * V + j * S, s[L][M] = -v * S + j * V;
        }
        _ = ln(m, d), n[M - 1] = _, V = m / _, S = d / _, m = V * D + S * w, p = -S * D + V * w;
        for (let L = 0; L < e; L++) {
          const v = i[L][M - 1], j = i[L][M];
          i[L][M - 1] = v * V + j * S, i[L][M] = -v * S + j * V;
        }
      }
      r[b] = 0, r[C] = m, n[C] = p;
    }
  for (let C = 0; C < n.length; C++)
    n[C] < o && (n[C] = 0);
  for (let C = 0; C < t; C++)
    for (let E = C - 1; E >= 0; E--)
      if (n[E] < n[C]) {
        const R = n[E];
        n[E] = n[C], n[C] = R;
        for (let b = 0; b < i.length; b++) {
          const p = i[b][C];
          i[b][C] = i[b][E], i[b][E] = p;
        }
        for (let b = 0; b < s.length; b++) {
          const p = s[b][C];
          s[b][C] = s[b][E], s[b][E] = p;
        }
        C = E;
      }
  return {
    matrixU: i,
    matrixS: n,
    matrixV: s
  };
}
function ln(a, i) {
  let e = 0;
  return Math.abs(a) > Math.abs(i) ? (e = i / a, Math.abs(a) * Math.sqrt(1 + e * e)) : i !== 0 ? (e = a / i, Math.abs(i) * Math.sqrt(1 + e * e)) : 0;
}
function Ls(a, i, e, t, r) {
  let n = 0;
  for (let s = i; s < e; s++)
    n += a[s][t] * a[s][r];
  return n;
}
function qi(a, i, e, t, r) {
  let n = 0;
  for (let s = i; s < e; s++)
    n += a[t][s] * a[r][s];
  return n;
}
const fn = /* @__PURE__ */ new Map([
  ["I", 1],
  ["V", 5],
  ["X", 10],
  ["L", 50],
  ["C", 100],
  ["D", 500],
  ["M", 1e3]
]), Yh = /* @__PURE__ */ new Map([
  [1, "I"],
  [4, "IV"],
  [5, "V"],
  [9, "IX"],
  [10, "X"],
  [40, "XL"],
  [45, "VL"],
  [49, "IL"],
  [50, "L"],
  [90, "XC"],
  [95, "VC"],
  [99, "IC"],
  [100, "C"],
  [400, "CD"],
  [450, "LD"],
  [490, "XD"],
  [495, "VD"],
  [499, "ID"],
  [500, "D"],
  [900, "CM"],
  [950, "LM"],
  [990, "XM"],
  [995, "VM"],
  [999, "IM"],
  [1e3, "M"]
]), Hh = [
  [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1e3, 4e3],
  [1, 4, 5, 9, 10, 40, 45, 50, 90, 95, 100, 400, 450, 500, 900, 950, 1e3, 4e3],
  [1, 4, 5, 9, 10, 40, 45, 49, 50, 90, 95, 99, 100, 400, 450, 490, 500, 900, 950, 990, 1e3, 4e3],
  [1, 4, 5, 9, 10, 40, 45, 49, 50, 90, 95, 99, 100, 400, 450, 490, 495, 500, 900, 950, 990, 995, 1e3, 4e3],
  [1, 4, 5, 9, 10, 40, 45, 49, 50, 90, 95, 99, 100, 400, 450, 490, 495, 499, 500, 900, 950, 990, 995, 999, 1e3, 4e3]
];
function iu(a, i, e) {
  return a <= 0 ? 0 : a >= 1 ? 1 : ls(a, i, e);
}
function Gh(a, i, e) {
  return a <= 0 || a >= 1 ? 0 : i === 1 && e === 1 ? 1 : i < 512 && e < 512 ? a ** (i - 1) * (1 - a) ** (e - 1) / ka(i, e) : Math.exp((i - 1) * Math.log(a) + (e - 1) * Math.log(1 - a) - $a(i, e));
}
function Fa(a, i, e) {
  if (a <= 0)
    return 0;
  if (a >= 1)
    return 1;
  const t = 1e-8;
  let r;
  if (i >= 1 && e >= 1) {
    const c = a < 0.5 ? a : 1 - a, l = Math.sqrt(-2 * Math.log(c));
    r = (2.30753 + l * 0.27061) / (1 + l * (0.99229 + l * 0.04481)) - l, a < 0.5 && (r = -r);
    const f = (r * r - 3) / 6, m = 2 / (1 / (2 * i - 1) + 1 / (2 * e - 1)), d = r * Math.sqrt(f + m) / m - (1 / (2 * e - 1) - 1 / (2 * i - 1)) * (f + 5 / 6 - 2 / (3 * m));
    r = i / (i + e * Math.exp(2 * d));
  } else {
    const c = Math.exp(i * Math.log(i / (i + e))) / i, l = Math.exp(e * Math.log(e / (i + e))) / e, f = c + l;
    a < c / f ? r = (i * f * a) ** (1 / i) : r = 1 - (e * f * (1 - a)) ** (1 / e);
  }
  const n = -$a(i, e);
  let s, o, u;
  for (let c = 0; c < 10; c++) {
    if (r === 0 || r === 1)
      return r;
    if (s = ls(r, i, e) - a, o = Math.exp((i - 1) * Math.log(r) + (e - 1) * Math.log(1 - r) + n), u = s / o, r -= o = u / (1 - 0.5 * Math.min(1, u * ((i - 1) / r - (e - 1) / (1 - r)))), r <= 0 && (r = 0.5 * (r + o)), r >= 1 && (r = 0.5 * (r + o + 1)), Math.abs(o) < t * r && c > 0)
      break;
  }
  return r;
}
function ls(a, i, e) {
  const t = a === 0 || a === 1 ? 0 : Math.exp(dt(i + e) - dt(i) - dt(e) + i * Math.log(a) + e * Math.log(1 - a));
  return a < (i + 1) / (i + e + 2) ? t * Xi(a, i, e) / i : 1 - t * Xi(1 - a, e, i) / e;
}
function Xi(a, i, e) {
  let n = 1 - (i + e) * a / (i + 1);
  Math.abs(n) < 1e-8 && (n = 1e-8), n = 1 / n;
  let s = 1, o = n;
  for (let u = 1; u <= 100; u++) {
    let c = u * (e - u) * a / ((i - 1 + u * 2) * (i + u * 2));
    if (n = 1 + c * n, Math.abs(n) < 1e-8 && (n = 1e-8), s = 1 + c / s, Math.abs(s) < 1e-8 && (s = 1e-8), n = 1 / n, o *= n * s, c = -(i + u) * (i + e + u) * a / ((i + u * 2) * (i + 1 + u * 2)), n = 1 + c * n, Math.abs(n) < 1e-8 && (n = 1e-8), s = 1 + c / s, Math.abs(s) < 1e-8 && (s = 1e-8), n = 1 / n, o *= n * s, Math.abs(n * s - 1) < 1e-8)
      break;
  }
  return o;
}
function ka(a, i) {
  return a + i > 170 ? Math.exp($a(a, i)) : yn(a) * yn(i) / yn(a + i);
}
function $a(a, i) {
  return dt(a) + dt(i) - dt(a + i);
}
function ou(a, i, e) {
  if (a < 0)
    return 0;
  if (a >= i)
    return 1;
  if (e < 0 || e > 1 || i <= 0)
    return Number.NaN;
  let t = 0;
  for (let r = 0; r <= a; r++)
    t += Ya(r, i, e);
  return t;
}
function Ya(a, i, e) {
  return e === 0 || e === 1 ? i * e === a ? 1 : 0 : sr(i, a) * e ** a * (1 - e) ** (i - a);
}
function Ha(a, i) {
  return a <= 0 ? 0 : Wa(i / 2, a / 2);
}
function Wh(a, i) {
  return a < 0 ? 0 : a === 0 && i === 2 ? 0.5 : Math.exp((i / 2 - 1) * Math.log(a) - a / 2 - i / 2 * Math.log(2) - dt(i / 2));
}
function uu(a, i) {
  return a <= 0 ? 0 : a >= 1 ? 1 / 0 : 2 * fu(a, i / 2);
}
function Ga(a, i, e) {
  return a < 0 ? 0 : ls(i * a / (i * a + e), i / 2, e / 2);
}
function Qh(a, i, e) {
  if (a < 0)
    return 0;
  if (a === 0 && i < 2)
    return 1 / 0;
  if (a === 0 && i === 2)
    return 1;
  let t = 1 / ka(i / 2, e / 2);
  return t *= (i / e) ** (i / 2), t *= a ** (i / 2 - 1), t *= (1 + i / e * a) ** (-(i + e) / 2), t;
}
function cu(a, i, e) {
  return a <= 0 ? 0 : a >= 1 ? 1 / 0 : e / (i * (1 / Fa(a, i / 2, e / 2) - 1));
}
function qh(a, i) {
  return a < 0 ? 0 : 1 - Math.exp(-i * a);
}
function Xh(a, i) {
  return a < 0 ? 0 : i * Math.exp(-i * a);
}
function lu(a, i, e) {
  const t = i.length;
  let r = 0, n = 0;
  for (let m = 0; m < t; m++)
    r += i[m], n += e[m];
  const s = r / t, o = n / t;
  let u = 0, c = 0;
  for (let m = 0; m < t; m++)
    u += (i[m] - s) * (e[m] - o), c += (e[m] - o) ** 2;
  if (c === 0)
    return 1 / 0;
  const l = u / c;
  return s - l * o + l * a;
}
function yn(a) {
  const i = [
    -1.716185138865495,
    24.76565080557592,
    -379.80425647094563,
    629.3311553128184,
    866.9662027904133,
    -31451.272968848367,
    -36144.413418691176,
    66456.14382024054
  ], e = [
    -30.8402300119739,
    315.35062697960416,
    -1015.1563674902192,
    -3107.771671572311,
    // eslint-disable-next-line no-loss-of-precision
    22538.11842098015,
    // eslint-disable-next-line no-loss-of-precision
    4755.846277527881,
    -134659.9598649693,
    -115132.2596755535
  ];
  let t = 0, r = a;
  if (a > 171.6243769536076)
    return 1 / 0;
  if (r <= 0) {
    const f = r % 1 + 36e-17;
    if (f)
      t = (r & 1 ? -1 : 1) * Math.PI / Math.sin(Math.PI * f), r = 1 - r;
    else
      return 1 / 0;
  }
  const n = r;
  let s = 0, o;
  r < 1 ? o = r++ : o = (r -= s = (r | 0) - 1) - 1;
  let u = 0, c = 0;
  for (let f = 0; f < 8; ++f)
    u = (u + i[f]) * o, c = c * o + e[f];
  let l = u / c + 1;
  if (n < r)
    l /= n;
  else if (n > r)
    for (let f = 0; f < s; ++f)
      l *= r, r++;
  return t && (l = t / l), l;
}
function Kh(a, i, e) {
  return a <= 0 ? 0 : Wa(i, a / e);
}
function Zh(a, i, e) {
  return a < 0 ? 0 : a === 0 && i === 1 ? 1 / e : Math.exp((i - 1) * Math.log(a) - a / e - dt(i) - i * Math.log(e));
}
function zh(a, i, e) {
  return a <= 0 ? 0 : a >= 1 ? 1 / 0 : e * fu(a, i);
}
function dt(a) {
  const i = [
    76.18009172947146,
    -86.50532032941678,
    24.01409824083091,
    // eslint-disable-line
    -1.231739572450155,
    0.001208650973866179,
    -5395239384953e-18
  ];
  let e = a, t = a + 5.5;
  t -= (a + 0.5) * Math.log(t);
  let r = 1.000000000190015;
  for (let n = 0; n < 6; n++)
    r += i[n] / ++e;
  return -t + Math.log(2.5066282746310007 * r / a);
}
function Wa(a, i) {
  if (i < 0 || a <= 0)
    return Number.NaN;
  const e = 1e-30, t = -~(Math.log(a >= 1 ? a : 1 / a) * 8.5 + a * 0.4 + 17), r = dt(a), n = Math.exp(-i + a * Math.log(i) - r);
  let s = a, o = 1 / a, u = o;
  if (i < a + 1) {
    if (n === 0)
      return 0;
    for (let d = 1; d <= t && (o += u *= i / ++s, !(Math.abs(u) < Math.abs(o) * e)); d++)
      ;
    return o * n;
  }
  if (n === 0)
    return 1;
  let c = i + 1 - a, l = 1 / e, f = 1 / c, m = f;
  for (let d = 1; d <= t; d++) {
    const _ = -d * (d - a);
    if (c += 2, f = _ * f + c, Math.abs(f) < e && (f = e), l = c + _ / l, Math.abs(l) < e && (l = e), f = 1 / f, m *= f * l, Math.abs(f * l - 1) < e)
      break;
  }
  return 1 - m * n;
}
function fu(a, i) {
  if (a <= 0)
    return 0;
  if (a >= 1)
    return Math.max(100, i + 100 * Math.sqrt(i));
  let e;
  if (i > 1) {
    const o = a < 0.5 ? a : 1 - a, u = Math.sqrt(-2 * Math.log(o));
    e = (2.30753 + u * 0.27061) / (1 + u * (0.99229 + u * 0.04481)) - u, a < 0.5 && (e = -e), e = Math.max(1e-3, i * (1 - 1 / (9 * i) - e / (3 * Math.sqrt(i))) ** 3);
  } else {
    const o = 1 - i * (0.253 + i * 0.12);
    a < o ? e = (a / o) ** (1 / i) : e = 1 - Math.log(1 - (a - o) / (1 - o));
  }
  const t = 1e-8, r = dt(i);
  let n, s;
  for (let o = 0; o < 12; o++) {
    if (e <= 0)
      return 0;
    if (n = Wa(i, e) - a, i > 1 ? s = Math.exp((i - 1) * (Math.log(i - 1) - 1) - r) * Math.exp(-(e - (i - 1)) + (i - 1) * (Math.log(e) - Math.log(i - 1))) : s = Math.exp(-e + (i - 1) * Math.log(e) - r), s !== 0 && (s = n / s / (1 - 0.5 * Math.min(1, n / s * ((i - 1) / e - 1)))), e -= s, e <= 0 && (e = 0.5 * (e + s)), Math.abs(s) < t * e)
      break;
  }
  return e;
}
function Jh(a, i, e, t) {
  let r = 0;
  for (let n = 0; n <= a; n++)
    r += Qa(n, i, e, t);
  return r;
}
function Qa(a, i, e, t) {
  return i - a > t - e ? 0 : sr(e, a) * sr(t - e, i - a) / sr(t, i);
}
function mu(a, i, e) {
  return a < 0 ? 0 : 0.5 + 0.5 * nr((Math.log(a) - i) / Math.sqrt(2 * e * e));
}
function eg(a, i, e) {
  return a <= 0 ? 0 : Math.exp(-Math.log(a) - 0.5 * Math.log(2 * Math.PI) - Math.log(e) - (Math.log(a) - i) ** 2 / (2 * e * e));
}
function tg(a, i, e) {
  return Math.exp(fs(a, i, e));
}
function rg(a, i, e) {
  if (a < 0)
    return 0;
  let t = 0;
  for (let r = 0; r <= a; r++)
    t += qa(r, i, e);
  return t;
}
function qa(a, i, e) {
  return a < 0 ? 0 : sr(a + i - 1, i - 1) * e ** i * (1 - e) ** a;
}
function Jr(a, i, e) {
  return 0.5 * (1 + nr((a - i) / Math.sqrt(2 * e * e)));
}
function hu(a, i, e) {
  return Math.exp(-0.5 * Math.log(2 * Math.PI) - Math.log(e) - (a - i) ** 2 / (2 * e * e));
}
function fs(a, i, e) {
  return -1.4142135623730951 * e * Uh(2 * a) + i;
}
function ng(a, i) {
  let e = 0;
  for (let t = 0; t <= a; t++)
    e += gu(t, i);
  return e;
}
function gu(a, i) {
  return Math.exp(-i) * i ** a / Ar(a);
}
function en(a, i) {
  const e = 0.5 * ls(i / (a ** 2 + i), i / 2, 0.5);
  return a < 0 ? e : 1 - e;
}
function sg(a, i) {
  const e = (1 + a ** 2 / i) ** (-(i + 1) / 2);
  return 1 / (Math.sqrt(i) * ka(0.5, i / 2)) * e;
}
function ms(a, i) {
  let e = Fa(2 * Math.min(a, 1 - a), 0.5 * i, 0.5);
  return e = Math.sqrt(i * (1 - e) / e), a > 0.5 ? e : -e;
}
function st(a, i, e, t, r) {
  const n = [], s = [];
  let o = !0;
  for (let u = 0; u < e; u++) {
    const c = Math.floor(u / t), l = u % t, f = Math.floor(u / r), m = u % r, d = a.isArray() ? a.get(c, l) : a, _ = i.isArray() ? i.get(f, m) : i;
    if (d.isError())
      return {
        isError: !0,
        errorObject: d,
        array1Values: n,
        array2Values: s,
        noCalculate: o
      };
    if (_.isError())
      return {
        isError: !0,
        errorObject: _,
        array1Values: n,
        array2Values: s,
        noCalculate: o
      };
    if (d.isNull() || _.isNull() || d.isBoolean() || _.isBoolean())
      continue;
    const C = d.getValue(), E = _.getValue();
    !q(C) || !q(E) || (n.push(+C), s.push(+E), o = !1);
  }
  return {
    isError: !1,
    errorObject: null,
    array1Values: n,
    array2Values: s,
    noCalculate: o
  };
}
function hs(a, i, e) {
  const t = a.isArray() ? a.getRowCount() : 1, r = a.isArray() ? a.getColumnCount() : 1;
  let n = t, s = r;
  if (i && !i.isNull() && (n = i.isArray() ? i.getRowCount() : 1, s = i.isArray() ? i.getColumnCount() : 1, t === 1 && s !== r || r === 1 && n !== t || t !== 1 && r !== 1 && (n !== t || s !== r)))
    return {
      isError: !0,
      errorObject: g.create(h.REF)
    };
  if (e && !e.isNull()) {
    const o = e.isArray() ? e.getRowCount() : 1, u = e.isArray() ? e.getColumnCount() : 1;
    if (t === 1 && n > 1 && o !== n || r === 1 && s > 1 && u !== s)
      return {
        isError: !0,
        errorObject: g.create(h.REF)
      };
  }
  return {
    isError: !1,
    errorObject: null
  };
}
function yt(a) {
  const i = a.isArray() ? a.getRowCount() : 1, e = a.isArray() ? a.getColumnCount() : 1, t = [];
  for (let r = 0; r < i; r++) {
    t[r] = [];
    for (let n = 0; n < e; n++) {
      const s = a.isArray() ? a.get(r, n) : a;
      if (s.isError() || s.isNull() || s.isBoolean() || s.isString())
        return g.create(h.VALUE);
      t[r].push(+s.getValue());
    }
  }
  return t;
}
function gs(a, i) {
  const e = [];
  let t = 1;
  for (let r = 0; r < a; r++) {
    e[r] = [];
    for (let n = 0; n < i; n++)
      e[r].push(t++);
  }
  return e;
}
function ds(a, i, e, t) {
  let r = i;
  t && (r = i.map((o) => Math.log(o)));
  let n, s;
  return e ? { slope: n, intercept: s } = ag(a, r) : { slope: n, intercept: s } = ig(a, r), t && (n = Math.exp(n), s = Math.exp(s)), Number.isNaN(n) && !e && (n = 0), { slope: n, intercept: s, Y: r };
}
function ag(a, i) {
  const e = i.length;
  let t = 0, r = 0, n = 0, s = 0;
  for (let l = 0; l < e; l++)
    t += a[l], r += i[l], n += a[l] * a[l], s += a[l] * i[l];
  const u = (e * s - t * r) / (e * n - t * t), c = 1 / e * r - u * (1 / e) * t;
  return {
    slope: u,
    intercept: c
  };
}
function ig(a, i) {
  const e = [[...a]], t = [...i];
  let r = e.length, n = e[0].length, s = Math.min(r, n);
  const o = new Array(s).fill(0);
  for (let c = 0; c < s; c++) {
    const l = e[c];
    let f = 0;
    for (let d = 0; d < n; d++)
      f += l[d] ** 2;
    const m = l[c] < 0 ? Math.sqrt(f) : -Math.sqrt(f);
    if (o[c] = m, m !== 0) {
      l[c] -= m;
      for (let d = c + 1; d < r; d++) {
        let _ = 0;
        for (let C = c; C < n; C++)
          _ -= e[d][C] * l[C];
        _ /= m * l[c];
        for (let C = c; C < n; C++)
          e[d][C] -= _ * l[C];
      }
    }
  }
  r = e.length, n = e[0].length, s = Math.min(r, n);
  const u = new Array(r).fill(0);
  for (let c = 0; c < s; c++) {
    const l = e[c];
    let f = 0;
    for (let m = 0; m < n; m++)
      f += t[m] * l[m];
    f /= o[c] * l[c];
    for (let m = 0; m < n; m++)
      t[m] += f * l[m];
  }
  for (let c = o.length - 1; c >= 0; c--) {
    t[c] /= o[c];
    const l = t[c], f = e[c];
    u[c] = l;
    for (let m = 0; m < c; m++)
      t[m] -= l * f[m];
  }
  return {
    slope: u[0],
    intercept: 0
  };
}
function Cs(a, i, e, t, r) {
  const n = a.length === 1 && a[0].length > 1;
  let s = a;
  r && (s = a.map((C) => C.map((E) => Math.log(E))));
  let o = i, u = e;
  n && (s = Rt(s), o = Rt(o), u = Rt(u)), t && (o = o.map((C) => [...C, 1]));
  const c = Rt(o), l = Er(c, o), f = Er(c, s);
  let m = Bh(l);
  if (!m && (m = kh(l), !m))
    return g.create(h.NA);
  let d = Er(m, f);
  t || d.push([0]), d = Rt(d);
  const _ = d[0].pop();
  if (d[0].reverse(), d[0].push(_), r)
    for (let C = 0; C < d[0].length; C++)
      d[0][C] = Math.exp(d[0][C]);
  return {
    coefficients: d,
    Y: s,
    X: o,
    newX: u,
    XTXInverse: m
  };
}
function du(a) {
  const i = [], e = [];
  let t = !1;
  for (let r = 0; r < a.length; r++) {
    const n = a[r];
    if (n.isReferenceObject())
      n.isMultiArea() ? i.push(n) : e.push(n);
    else {
      t = !0;
      break;
    }
  }
  return {
    isError: t,
    multiAreaRefs: i,
    normalRefs: e
  };
}
var Me = /* @__PURE__ */ ((a) => (a.AVERAGE = "AVERAGE", a.COUNT = "COUNT", a.COUNTA = "COUNTA", a.MAX = "MAX", a.MIN = "MIN", a.PRODUCT = "PRODUCT", a.STDEV = "STDEV", a.STDEV_S = "STDEV.S", a.STDEVP = "STDEVP", a.STDEV_P = "STDEV.P", a.SUM = "SUM", a.VAR = "VAR", a.VAR_S = "VAR.S", a.VARP = "VARP", a.VAR_P = "VAR.P", a.MEDIAN = "MEDIAN", a.MODE_SNGL = "MODE.SNGL", a))(Me || {});
function Cu(a, i) {
  const e = a[i];
  return e ? e.hd === co.TRUE : !1;
}
function _u(a, i, e, t, r, n) {
  const s = a.getValue(i, e);
  if (s != null && s.f || s != null && s.si) {
    const o = n.getFormulaStringByCell(i, e, t, r);
    if (o && (o.indexOf(`${F.SUBTOTAL}(`) > -1 || o.indexOf(`${F.AGGREGATE}(`) > -1))
      return !0;
  }
  return !1;
}
function Au(a, i) {
  const e = Object.entries(a).filter(([t, { count: r }]) => r === i).sort((t, r) => t[1].order - r[1].order).map(([t]) => +t);
  return y.create(e[0]);
}
function Eu(a, i) {
  var b, p;
  const { type: e, ignoreRowHidden: t, ignoreErrorValues: r, ignoreNested: n, formulaDataModel: s } = a, o = [];
  let u = 0, c = 0, l = 0, f = 0, m = 0, d = 0, _ = 1;
  const C = {};
  let E = 1, R = 0;
  for (let V = 0; V < i.length; V++) {
    const S = i[V], M = S.getFilteredOutRows(), D = S.getRowData(), w = S.getUnitId(), L = S.getSheetId(), j = (p = (b = S.getUnitData()[w]) == null ? void 0 : b[L]) == null ? void 0 : p.cellData;
    let k;
    if (S.iterator((G, ne, z) => {
      if (M.includes(ne) || t && Cu(D, ne) || n && _u(j, ne, z, L, w, s))
        return !0;
      if (e === "COUNT")
        return G != null && G.isNumber() && u++, !0;
      if (e === "COUNTA")
        return G != null && !G.isNull() && c++, !0;
      if (G != null && G.isError())
        return r ? !0 : (k = G, !1);
      if (!G || G.isNull() || G.isBoolean() || G.isString())
        return !0;
      let $ = G.getValue();
      if (!q($))
        return !0;
      if ($ = +$, f++, e === "MAX")
        return m = f === 1 ? $ : Math.max(m, $), !0;
      if (e === "MIN")
        return d = f === 1 ? $ : Math.min(d, $), !0;
      if (e === "MODE.SNGL")
        return C[$] ? (C[$].count++, C[$].count > E && (E = C[$].count)) : C[$] = { count: 1, order: R++ }, !0;
      l += $, _ *= $, o.push(G);
    }), k != null && k.isError())
      return k;
  }
  switch (e) {
    case "AVERAGE":
      return f === 0 ? g.create(h.DIV_BY_ZERO) : y.create(l / f);
    case "COUNT":
      return y.create(u);
    case "COUNTA":
      return y.create(c);
    case "MAX":
      return y.create(m);
    case "MIN":
      return y.create(d);
    case "PRODUCT":
      return y.create(f === 0 ? 0 : _);
    case "STDEV":
    case "STDEV.S":
      return f < 2 ? g.create(h.DIV_BY_ZERO) : mt([o], 1, f).std(1);
    case "STDEVP":
    case "STDEV.P":
      return f === 0 ? g.create(h.DIV_BY_ZERO) : mt([o], 1, f).std();
    case "SUM":
      return y.create(l);
    case "VAR":
    case "VAR.S":
      return f < 2 ? g.create(h.DIV_BY_ZERO) : mt([o], 1, f).var(1);
    case "VARP":
    case "VAR.P":
      return f === 0 ? g.create(h.DIV_BY_ZERO) : mt([o], 1, f).var();
    case "MEDIAN":
      return f === 0 ? g.create(h.NUM) : Ru(o.map((V) => +V.getValue()));
    case "MODE.SNGL":
      return R === 0 || E === 1 ? g.create(h.NA) : Au(C, E);
    default:
      return g.create(h.VALUE);
  }
}
function mr(a, i, e) {
  var o, u;
  const { ignoreRowHidden: t = !1, ignoreErrorValues: r = !1, ignoreNested: n = !1 } = i != null ? i : {}, s = [];
  if (a.isReferenceObject()) {
    const c = a.getFilteredOutRows(), l = a.getRowData(), f = a.getUnitId(), m = a.getSheetId(), _ = (u = (o = a.getUnitData()[f]) == null ? void 0 : o[m]) == null ? void 0 : u.cellData;
    let C;
    if (a.iterator((E, R, b) => {
      if (c.includes(R) || t && Cu(l, R))
        return !0;
      if (E != null && E.isError())
        return r ? !0 : (C = E, !1);
      if (n && e && _u(_, R, b, m, f, e) || !E || E.isNull() || E.isBoolean() || E.isString())
        return !0;
      const p = E.getValue();
      if (!q(p))
        return !0;
      s.push(+p);
    }), C)
      return C;
  } else {
    const c = a.isArray() ? a.getRowCount() : 1, l = a.isArray() ? a.getColumnCount() : 1;
    for (let f = 0; f < c; f++)
      for (let m = 0; m < l; m++) {
        const d = a.isArray() ? a.get(f, m) : a;
        if (d.isError()) {
          if (r) continue;
          return d;
        }
        if (!d || d.isNull() || d.isBoolean() || d.isString())
          continue;
        const _ = d.getValue();
        q(_) && s.push(+_);
      }
  }
  return s.length === 0 ? g.create(h.NUM) : s;
}
function Ru(a) {
  const i = a.length;
  a.sort((t, r) => t - r);
  let e;
  if (i % 2 === 0) {
    const t = i / 2;
    e = (a[t - 1] + a[t]) / 2;
  } else
    e = a[Math.floor(i / 2)];
  return y.create(e);
}
function bu(a, i) {
  if (i < 1 || i > a.length)
    return g.create(h.NUM);
  a.sort((t, r) => r - t);
  const e = Math.ceil(i);
  return y.create(a[e - 1]);
}
function yu(a, i) {
  if (i < 1 || i > a.length)
    return g.create(h.NUM);
  a.sort((t, r) => t - r);
  const e = Math.floor(i);
  return y.create(a[e - 1]);
}
function pu(a, i) {
  const e = a.length;
  if (i < 0 || i > 1)
    return g.create(h.NUM);
  a.sort((o, u) => o - u);
  const t = i * (e - 1), r = Math.floor(t), n = t - r;
  if (n === 0)
    return y.create(a[r]);
  const s = a[r] + n * (a[r + 1] - a[r]);
  return y.create(s);
}
function Nu(a, i) {
  const e = a.length;
  if (i < 1 / (e + 1) || i > 1 - 1 / (e + 1))
    return g.create(h.NUM);
  a.sort((o, u) => o - u);
  const t = i * (e + 1) - 1, r = Math.floor(t), n = t - r;
  if (n === 0)
    return y.create(a[r]);
  const s = a[r] + n * (a[r + 1] - a[r]);
  return y.create(s);
}
function Vu(a, i) {
  const e = a.length;
  if (i < 0 || i > 4)
    return g.create(h.NUM);
  a.sort((u, c) => u - c);
  const r = i / 4 * (e - 1), n = Math.floor(r), s = r - n;
  if (s === 0)
    return y.create(a[n]);
  const o = a[n] + s * (a[n + 1] - a[n]);
  return y.create(o);
}
function Ou(a, i) {
  const e = a.length;
  if (i <= 0 || i >= 4)
    return g.create(h.NUM);
  a.sort((u, c) => u - c);
  const t = i / 4;
  if (t < 1 / (e + 1) || t > 1 - 1 / (e + 1))
    return g.create(h.NUM);
  const r = t * (e + 1) - 1, n = Math.floor(r), s = r - n;
  if (s === 0)
    return y.create(a[n]);
  const o = a[n] + s * (a[n + 1] - a[n]);
  return y.create(o);
}
class Su extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    let o = n != null ? n : y.create(0), u = s != null ? s : y.create(1);
    o.isNull() && (o = y.create(0)), u.isNull() && (u = y.create(1));
    const c = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1
    ), l = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1
    ), f = O(c, l, e, g.create(h.NA)), m = O(c, l, t, g.create(h.NA)), d = O(c, l, r, g.create(h.NA)), _ = O(c, l, o, g.create(h.NA)), C = O(c, l, u, g.create(h.NA)), E = f.mapValue((R, b, p) => {
      const V = m.get(b, p), S = d.get(b, p), M = _.get(b, p), D = C.get(b, p);
      return this._handleSingleObject(R, V, S, M, D);
    });
    return c === 1 && l === 1 ? E.get(0, 0) : E;
  }
  _handleSingleObject(e, t, r, n, s) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (r.isError())
      return r;
    if (n.isError())
      return n;
    if (s.isError())
      return s;
    const { isError: o, errorObject: u, variants: c } = I(e, t, r, n, s);
    if (o)
      return u;
    const [l, f, m, d, _] = c, C = +l.getValue(), E = +f.getValue(), R = +m.getValue(), b = +d.getValue(), p = +_.getValue();
    if (E <= 0 || R <= 0 || C <= 0 || C >= 1 || b >= p)
      return g.create(h.NUM);
    const V = Fa(C, E, R) * (p - b) + b;
    return y.create(V);
  }
}
class Mu extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(h.NA)), c = O(s, o, t, g.create(h.NA)), l = O(s, o, r, g.create(h.NA)), f = O(s, o, n, g.create(h.NA)), m = u.mapValue((d, _, C) => {
      const E = c.get(_, C), R = l.get(_, C), b = f.get(_, C);
      return d.isError() ? d : E.isError() ? E : R.isError() ? R : b.isError() ? b : this._handleSingleObject(d, E, R, b);
    });
    return s === 1 && o === 1 ? m.get(0, 0) : m;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = I(e, t, r, n);
    if (s)
      return o;
    const [c, l, f, m] = u, d = Math.floor(+c.getValue()), _ = Math.floor(+l.getValue()), C = +f.getValue(), E = +m.getValue();
    if (d < 0 || d > _ || C < 0 || C > 1)
      return g.create(h.NUM);
    let R;
    return E ? R = ou(d, _, C) : R = Ya(d, _, C), y.create(R);
  }
}
class Du extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, t, g.create(h.NA)), c = O(n, s, r, g.create(h.NA)), l = o.mapValue((f, m, d) => {
      const _ = u.get(m, d), C = c.get(m, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = Math.floor(+u.getValue()), m = +c.getValue(), d = +l.getValue();
    if (f < 0 || m <= 0 || m >= 1 || d <= 0 || d >= 1)
      return g.create(h.NUM);
    let _ = 0;
    for (; _ <= f && !(ou(_, f, m) >= d); )
      _++;
    return y.create(_);
  }
}
class wu extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(h.NA)), o = O(r, n, t, g.create(h.NA)), u = s.mapValue((c, l, f) => {
      const m = o.get(l, f);
      return c.isError() ? c : m.isError() ? m : this._handleSingleObject(c, m);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = I(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (c < 0 || l < 1 || l > 10 ** 10)
      return g.create(h.NUM);
    const f = 1 - Ha(c, l);
    return y.create(f);
  }
}
class Lu extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(h.NA)), o = O(r, n, t, g.create(h.NA)), u = s.mapValue((c, l, f) => {
      const m = o.get(l, f);
      return c.isError() ? c : m.isError() ? m : this._handleSingleObject(c, m);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = I(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (c < 0 || c > 1 || l < 1 || l > 10 ** 10)
      return g.create(h.NUM);
    const f = uu(1 - c, l);
    return Number.isNaN(f) || !Number.isFinite(f) ? g.create(h.NUM) : y.create(f);
  }
}
class Pu extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if (r * n === 1 || s * o === 1)
      return u.isNull() || c.isNull() ? g.create(h.VALUE) : g.create(h.NA);
    if (r * n !== s * o)
      return g.create(h.NA);
    const {
      isError: l,
      errorObject: f,
      array1Values: m,
      array2Values: d,
      noCalculate: _
    } = st(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f : _ ? g.create(h.DIV_BY_ZERO) : this._getResult(m, d, r, n);
  }
  _getResult(e, t, r, n) {
    let s = 0;
    for (let c = 0; c < e.length; c++) {
      if (t[c] === 0)
        return g.create(h.DIV_BY_ZERO);
      s += (e[c] - t[c]) ** 2 / t[c];
    }
    let o = (r - 1) * (n - 1);
    r === 1 ? o = n - 1 : n === 1 && (o = r - 1);
    const u = 1 - Ha(s, o);
    return y.create(u);
  }
}
class xu extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, t, g.create(h.NA)), c = O(n, s, r, g.create(h.NA)), l = o.mapValue((f, m, d) => {
      const _ = u.get(m, d), C = c.get(m, d);
      if (f.isError())
        return f;
      if (_.isError())
        return _;
      if (C.isError())
        return C;
      const { isError: E, errorObject: R, variants: b } = I(f, _, C);
      if (E)
        return R;
      const [p, V, S] = b, M = +p.getValue(), D = +V.getValue(), w = Math.floor(+S.getValue());
      if (M <= 0 || M >= 1 || D <= 0 || w < 1)
        return g.create(h.NUM);
      const L = Math.abs(fs(M / 2, 0, 1) * D / Math.sqrt(w));
      return y.create(L);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
}
class ju extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if ((r * n === 1 || s * o === 1) && (u.isNull() || c.isNull()))
      return g.create(h.VALUE);
    if (r * n !== s * o)
      return g.create(h.NA);
    const {
      isError: l,
      errorObject: f,
      array1Values: m,
      array2Values: d,
      noCalculate: _
    } = st(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f : _ ? g.create(h.DIV_BY_ZERO) : this._getResult(m, d);
  }
  _getResult(e, t) {
    if (e.length === 0)
      return g.create(h.DIV_BY_ZERO);
    const r = e.length;
    let n = 0, s = 0;
    for (let l = 0; l < r; l++)
      n += e[l], s += t[l];
    const o = n / r, u = s / r;
    let c = 0;
    for (let l = 0; l < r; l++) {
      const f = e[l] - o, m = t[l] - u;
      c += f * m;
    }
    return y.create(c / r);
  }
}
class Uu extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, t, g.create(h.NA)), c = O(n, s, r, g.create(h.NA)), l = o.mapValue((f, m, d) => {
      const _ = u.get(m, d), C = c.get(m, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), m = +c.getValue(), d = +l.getValue();
    if (f < 0 || m <= 0)
      return g.create(h.NUM);
    let _;
    return d ? _ = qh(f, m) : _ = Xh(f, m), y.create(_);
  }
}
class vu extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, t, g.create(h.NA)), c = O(n, s, r, g.create(h.NA)), l = o.mapValue((f, m, d) => {
      const _ = u.get(m, d), C = c.get(m, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), m = Math.floor(+c.getValue()), d = Math.floor(+l.getValue());
    if (f < 0 || m < 1 || m > 10 ** 10 || d < 1 || d > 10 ** 10)
      return g.create(h.NUM);
    const _ = 1 - Ga(f, m, d);
    return y.create(_);
  }
}
class Tu extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, t, g.create(h.NA)), c = O(n, s, r, g.create(h.NA)), l = o.mapValue((f, m, d) => {
      const _ = u.get(m, d), C = c.get(m, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), m = Math.floor(+c.getValue()), d = Math.floor(+l.getValue());
    if (f < 0 || f > 1 || m < 1 || m > 10 ** 10 || d < 1 || d > 10 ** 10)
      return g.create(h.NUM);
    const _ = cu(1 - f, m, d);
    return Number.isNaN(_) || !Number.isFinite(_) ? g.create(h.NUM) : y.create(_);
  }
}
class Iu extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const {
      isError: r,
      errorObject: n,
      variance: s,
      ns1: o
    } = this._getValues(e);
    if (r)
      return n;
    const {
      isError: u,
      errorObject: c,
      variance: l,
      ns1: f
    } = this._getValues(t);
    if (u)
      return c;
    let m = 2 * (1 - Ga(s / l, o, f));
    return m > 1 && (m = 2 - m), y.create(m);
  }
  // eslint-disable-next-line
  _getValues(e) {
    let t = 0, r = 0;
    const n = e.isArray() ? e.getRowCount() : 1, s = e.isArray() ? e.getColumnCount() : 1;
    if (n === 1 && s === 1) {
      const f = e.isArray() ? e.get(0, 0) : e;
      return f.isError() ? {
        isError: !0,
        errorObject: f,
        variance: t,
        ns1: r
      } : f.isNull() ? {
        isError: !0,
        errorObject: g.create(h.VALUE),
        variance: t,
        ns1: r
      } : {
        isError: !0,
        errorObject: g.create(h.DIV_BY_ZERO),
        variance: t,
        ns1: r
      };
    }
    const o = [];
    let u = 0;
    for (let f = 0; f < n; f++)
      for (let m = 0; m < s; m++) {
        const d = e.isArray() ? e.get(f, m) : e;
        if (d.isError())
          return {
            isError: !0,
            errorObject: d,
            variance: t,
            ns1: r
          };
        if (d.isNull() || d.isBoolean())
          continue;
        const _ = d.getValue();
        q(_) && (o.push(+_), u += +_);
      }
    if (o.length <= 1)
      return {
        isError: !0,
        errorObject: g.create(h.DIV_BY_ZERO),
        variance: t,
        ns1: r
      };
    const c = u / o.length;
    let l = 0;
    for (let f = 0; f < o.length; f++)
      l += (o[f] - c) ** 2;
    return r = o.length - 1, t = l / r, t === 0 ? {
      isError: !0,
      errorObject: g.create(h.DIV_BY_ZERO),
      variance: t,
      ns1: r
    } : {
      isError: !1,
      errorObject: null,
      variance: t,
      ns1: r
    };
  }
}
class Bu extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(h.NA)), c = O(s, o, t, g.create(h.NA)), l = O(s, o, r, g.create(h.NA)), f = O(s, o, n, g.create(h.NA)), m = u.mapValue((d, _, C) => {
      const E = c.get(_, C), R = l.get(_, C), b = f.get(_, C);
      return d.isError() ? d : E.isError() ? E : R.isError() ? R : b.isError() ? b : this._handleSingleObject(d, E, R, b);
    });
    return s === 1 && o === 1 ? m.get(0, 0) : m;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = I(e, t, r, n);
    if (s)
      return o;
    const [c, l, f, m] = u, d = +c.getValue(), _ = +l.getValue(), C = +f.getValue(), E = +m.getValue();
    if (d < 0 || _ <= 0 || C <= 0)
      return g.create(h.NUM);
    let R;
    return E ? R = Kh(d, _, C) : R = Zh(d, _, C), y.create(R);
  }
}
class Fu extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, t, g.create(h.NA)), c = O(n, s, r, g.create(h.NA)), l = o.mapValue((f, m, d) => {
      const _ = u.get(m, d), C = c.get(m, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), m = +c.getValue(), d = +l.getValue();
    if (f < 0 || f > 1 || m <= 0 || d <= 0)
      return g.create(h.NUM);
    const _ = zh(f, m, d);
    return Number.isNaN(_) || !Number.isFinite(_) ? g.create(h.NUM) : y.create(_);
  }
}
class ku extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, t, g.create(h.NA)), c = O(n, s, r, g.create(h.NA)), l = o.mapValue((f, m, d) => {
      const _ = u.get(m, d), C = c.get(m, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), m = +c.getValue(), d = +l.getValue();
    if (f <= 0 || f >= 1 || d <= 0)
      return g.create(h.NUM);
    const _ = tg(f, m, d);
    return Number.isNaN(_) || !Number.isFinite(_) ? g.create(h.NUM) : y.create(_);
  }
}
class $u extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = {};
    let r = 0, n = 1;
    for (let s = 0; s < e.length; s++) {
      const o = e[s];
      if (o.isError())
        return o;
      if (o.isString()) {
        const l = o.convertToNumberObjectValue();
        if (l.isError())
          return l;
      }
      const u = o.isArray() ? o.getRowCount() : 1, c = o.isArray() ? o.getColumnCount() : 1;
      for (let l = 0; l < u; l++)
        for (let f = 0; f < c; f++) {
          const m = o.isArray() ? o.get(l, f) : o;
          if (m.isError())
            return m;
          if (m.isNull() || m.isBoolean() || m.isString())
            continue;
          const d = m.getValue();
          q(d) && (t[+d] ? (t[+d].count++, t[+d].count > n && (n = t[+d].count)) : t[+d] = { count: 1, order: r++ });
        }
    }
    return r === 0 || n === 1 ? new g(h.NA) : Au(t, n);
  }
}
class Yu extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(h.NA)), c = O(s, o, t, g.create(h.NA)), l = O(s, o, r, g.create(h.NA)), f = O(s, o, n, g.create(h.NA)), m = u.mapValue((d, _, C) => {
      const E = c.get(_, C), R = l.get(_, C), b = f.get(_, C);
      return d.isError() ? d : E.isError() ? E : R.isError() ? R : b.isError() ? b : this._handleSingleObject(d, E, R, b);
    });
    return s === 1 && o === 1 ? m.get(0, 0) : m;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = I(e, t, r, n);
    if (s)
      return o;
    const [c, l, f, m] = u, d = +c.getValue(), _ = +l.getValue(), C = +f.getValue(), E = +m.getValue();
    if (C <= 0)
      return g.create(h.NUM);
    let R;
    return E ? R = Jr(d, _, C) : R = hu(d, _, C), y.create(R);
  }
}
class Hu extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, t, g.create(h.NA)), c = O(n, s, r, g.create(h.NA)), l = o.mapValue((f, m, d) => {
      const _ = u.get(m, d), C = c.get(m, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), m = +c.getValue(), d = +l.getValue();
    if (f <= 0 || f >= 1 || d <= 0)
      return g.create(h.NUM);
    const _ = fs(f, m, d);
    return y.create(_);
  }
}
class Gu extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return e.getRowCount() === 1 && e.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = I(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue();
    if (o <= 0 || o >= 1)
      return g.create(h.NUM);
    const u = fs(o, 0, 1);
    return y.create(u);
  }
}
class Wu extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = mr(e);
    if (t.isArray()) {
      const n = t.mapValue((s) => this._handleSingleObject(r, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(r, t);
  }
  _handleSingleObject(e, t) {
    if (!Array.isArray(e))
      return e;
    const { isError: r, errorObject: n, variants: s } = I(t);
    if (r)
      return n;
    const [o] = s, u = +o.getValue();
    return pu(e, u);
  }
}
class Qu extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = this._getValues(e);
    let s = r != null ? r : y.create(3);
    s.isNull() && (s = y.create(3));
    const o = Math.max(
      t.isArray() ? t.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      t.isArray() ? t.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, t, g.create(h.NA)), l = O(o, u, s, g.create(h.NA)), f = c.mapValue((m, d, _) => {
      const C = l.get(d, _);
      return m.isError() ? m : C.isError() ? C : this._handleSingleObject(n, m, C);
    });
    return o === 1 && u === 1 ? f.get(0, 0) : f;
  }
  _handleSingleObject(e, t, r) {
    if (e instanceof g)
      return e;
    const { isError: n, errorObject: s, variants: o } = I(t, r);
    if (n)
      return s;
    const [u, c] = o, l = +u.getValue(), f = Math.floor(+c.getValue()), m = e.length;
    if (m === 0 || l < e[0] || l > e[m - 1])
      return g.create(h.NA);
    if (m === 1)
      return l === e[0] ? y.create(1) : g.create(h.NA);
    let d = 0, _ = !1, C = 0;
    for (; !_ && C < m; )
      l === e[C] ? (d = C / (m - 1), _ = !0) : l > e[C] && C + 1 < m && l < e[C + 1] && (d = (C + (l - e[C]) / (e[C + 1] - e[C])) / (m - 1), _ = !0), C++;
    return _ ? f < 1 ? g.create(h.NUM) : (d = Ze(d, f), y.create(d)) : g.create(h.NA);
  }
  _getValues(e) {
    const t = e.isArray() ? e.getRowCount() : 1, r = e.isArray() ? e.getColumnCount() : 1, n = [];
    for (let s = 0; s < t; s++)
      for (let o = 0; o < r; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        if (u.isNull() || u.isBoolean())
          continue;
        const c = u.getValue();
        q(c) && n.push(+c);
      }
    return n.sort((s, o) => s - o);
  }
}
class qu extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, t, g.create(h.NA)), c = O(n, s, r, g.create(h.NA)), l = o.mapValue((f, m, d) => {
      const _ = u.get(m, d), C = c.get(m, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = Math.floor(+u.getValue()), m = +c.getValue(), d = +l.getValue();
    if (f < 0 || m < 0)
      return g.create(h.NUM);
    let _;
    return d ? _ = ng(f, m) : _ = gu(f, m), y.create(_);
  }
}
class Xu extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = mr(e);
    if (t.isArray()) {
      const n = t.mapValue((s) => this._handleSingleObject(r, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(r, t);
  }
  _handleSingleObject(e, t) {
    if (!Array.isArray(e))
      return e;
    const { isError: r, errorObject: n, variants: s } = I(t);
    if (r)
      return n;
    const [o] = s, u = Math.floor(+o.getValue());
    return Vu(e, u);
  }
}
class Ku extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = this.flattenArray(e);
    return t.isError() ? t : t.std();
  }
}
class Zu extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = this.flattenArray(e);
    return t.isError() ? t : t.std(1);
  }
}
class zu extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(h.NA)), o = O(r, n, t, g.create(h.NA)), u = s.mapValue((c, l, f) => {
      const m = o.get(l, f);
      return c.isError() ? c : m.isError() ? m : this._handleSingleObject(c, m);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = I(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (c <= 0 || c > 1 || l < 1 || l > 10 ** 10)
      return g.create(h.NUM);
    const f = Math.abs(ms(c / 2, l));
    return Number.isNaN(f) || !Number.isFinite(f) ? g.create(h.NUM) : y.create(f);
  }
}
class Ju extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  // eslint-disable-next-line
  calculate(e, t, r, n) {
    const { isError: s, errorObject: o, array1Values: u, array2Values: c } = this._handleArray1AndArray2(e, t), l = this._getArrayValues(e), f = this._getArrayValues(t), m = Math.max(
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), d = Math.max(
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), _ = O(m, d, r, g.create(h.NA)), C = O(m, d, n, g.create(h.NA)), E = _.mapValue((R, b, p) => {
      const V = C.get(b, p);
      if (e.isError())
        return e;
      if (t.isError())
        return t;
      if (R.isError())
        return R;
      if (V.isError())
        return V;
      const { isError: S, errorObject: M, variants: D } = I(R, V);
      if (S)
        return M;
      const [w, L] = D, v = Math.floor(+w.getValue()), j = Math.floor(+L.getValue());
      return ![1, 2].includes(v) || ![1, 2, 3].includes(j) ? g.create(h.NUM) : j === 1 && s ? o : j !== 1 && l instanceof g ? l : j !== 1 && f instanceof g ? f : this._handleSingleObject(
        j === 1 ? u : l,
        j === 1 ? c : f,
        v,
        j
      );
    });
    return m === 1 && d === 1 ? E.get(0, 0) : E;
  }
  _handleSingleObject(e, t, r, n) {
    if (e.length < 2 || t.length < 2)
      return g.create(h.DIV_BY_ZERO);
    const { isError: s, errorObject: o, x: u, degFreedom: c } = this._getTDistParamByArrayValues(e, t, n);
    if (s)
      return o;
    let l = en(-u, c);
    return r === 2 && (l *= 2), Number.isNaN(l) || !Number.isFinite(l) ? g.create(h.NUM) : y.create(l);
  }
  _getArrayValues(e) {
    const t = e.isArray() ? e.getRowCount() : 1, r = e.isArray() ? e.getColumnCount() : 1, n = [];
    for (let s = 0; s < t; s++)
      for (let o = 0; o < r; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        if (u.isNull()) {
          if (t * r === 1)
            return g.create(h.VALUE);
          continue;
        }
        u.isBoolean() || u.isString() || n.push(+u.getValue());
      }
    return n;
  }
  // eslint-disable-next-line
  _handleArray1AndArray2(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return {
        isError: !0,
        errorObject: u,
        array1Values: [],
        array2Values: []
      };
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return {
        isError: !0,
        errorObject: c,
        array1Values: [],
        array2Values: []
      };
    if ((r * n === 1 || s * o === 1) && (u.isNull() || c.isNull()))
      return {
        isError: !0,
        errorObject: g.create(h.VALUE),
        array1Values: [],
        array2Values: []
      };
    if (r * n !== s * o)
      return {
        isError: !0,
        errorObject: g.create(h.NA),
        array1Values: [],
        array2Values: []
      };
    const {
      isError: l,
      errorObject: f,
      array1Values: m,
      array2Values: d,
      noCalculate: _
    } = st(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? {
      isError: !0,
      errorObject: f,
      array1Values: [],
      array2Values: []
    } : _ || m.length < 2 ? {
      isError: !0,
      errorObject: g.create(h.DIV_BY_ZERO),
      array1Values: [],
      array2Values: []
    } : {
      isError: !1,
      errorObject: null,
      array1Values: m,
      array2Values: d
    };
  }
  _getTDistParamByArrayValues(e, t, r) {
    return r === 1 ? this._getTDistParamByType1(e, t) : r === 2 ? this._getTDistParamByType2(e, t) : this._getTDistParamByType3(e, t);
  }
  _getTDistParamByType1(e, t) {
    const r = e.length;
    let n = 0, s = 0, o = 0;
    for (let m = 0; m < r; m++)
      n += e[m], s += t[m], o += (e[m] - t[m]) ** 2;
    const u = n - s, c = r * o - u ** 2, l = r - 1;
    return c === 0 ? {
      isError: !0,
      errorObject: g.create(h.DIV_BY_ZERO),
      x: 0,
      degFreedom: l
    } : {
      isError: !1,
      errorObject: null,
      x: Math.abs(u) * Math.sqrt(l / c),
      degFreedom: l
    };
  }
  _getTDistParamByType2(e, t) {
    const r = e.length, n = t.length;
    let s = 0, o = 0;
    for (let E = 0; E < r; E++)
      s += e[E], o += e[E] ** 2;
    let u = 0, c = 0;
    for (let E = 0; E < n; E++)
      u += t[E], c += t[E] ** 2;
    const l = o - s ** 2 / r, f = c - u ** 2 / n, m = Math.sqrt(l + f);
    if (m === 0)
      return {
        isError: !0,
        errorObject: g.create(h.DIV_BY_ZERO),
        x: 0,
        degFreedom: 0
      };
    const d = r - 1 + n - 1, _ = Math.sqrt(r * n * d / (r + n));
    return {
      isError: !1,
      errorObject: null,
      x: Math.abs(s / r - u / n) / m * _,
      degFreedom: d
    };
  }
  _getTDistParamByType3(e, t) {
    const r = e.length, n = t.length;
    let s = 0, o = 0;
    for (let C = 0; C < r; C++)
      s += e[C], o += e[C] ** 2;
    let u = 0, c = 0;
    for (let C = 0; C < n; C++)
      u += t[C], c += t[C] ** 2;
    const l = (o - s ** 2 / r) / (r * (r - 1)), f = (c - u ** 2 / n) / (n * (n - 1));
    if (l + f === 0)
      return {
        isError: !0,
        errorObject: g.create(h.DIV_BY_ZERO),
        x: 0,
        degFreedom: 0
      };
    const m = l / (l + f), d = Math.abs(s / r - u / n) / Math.sqrt(l + f), _ = 1 / (m ** 2 / (r - 1) + (1 - m) ** 2 / (n - 1));
    return {
      isError: !1,
      errorObject: null,
      x: d,
      degFreedom: _
    };
  }
}
class ec extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = this.flattenArray(e);
    return t.isError() ? t : t.var();
  }
}
class tc extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = this.flattenArray(e);
    return t.isError() ? t : t.var(1);
  }
}
class rc extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(h.NA)), c = O(s, o, t, g.create(h.NA)), l = O(s, o, r, g.create(h.NA)), f = O(s, o, n, g.create(h.NA)), m = u.mapValue((d, _, C) => {
      const E = c.get(_, C), R = l.get(_, C), b = f.get(_, C);
      return d.isError() ? d : E.isError() ? E : R.isError() ? R : b.isError() ? b : this._handleSingleObject(d, E, R, b);
    });
    return s === 1 && o === 1 ? m.get(0, 0) : m;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = I(e, t, r, n);
    if (s)
      return o;
    const [c, l, f, m] = u, d = +c.getValue(), _ = +l.getValue(), C = +f.getValue(), E = +m.getValue();
    if (d < 0 || _ <= 0 || C <= 0)
      return g.create(h.NUM);
    const R = Math.exp(-((d / C) ** _));
    let b;
    return E ? b = 1 - R : b = _ / C ** _ * d ** (_ - 1) * R, Number.isNaN(b) || !Number.isFinite(b) ? g.create(h.NUM) : y.create(b);
  }
}
class nc extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = this._getArrayValues(e), s = Math.max(
      t.isArray() ? t.getRowCount() : 1,
      r != null && r.isArray() ? r.getRowCount() : 1
    ), o = Math.max(
      t.isArray() ? t.getColumnCount() : 1,
      r != null && r.isArray() ? r.getColumnCount() : 1
    ), u = O(s, o, t, g.create(h.NA)), c = r ? O(s, o, r, g.create(h.NA)) : void 0, l = u.mapValue((f, m, d) => {
      if (n instanceof g)
        return n;
      if (f.isError())
        return f;
      const _ = r ? c.get(m, d) : void 0;
      return _ != null && _.isError() ? _ : n.length === 0 ? g.create(h.NA) : n.length === 1 ? g.create(h.DIV_BY_ZERO) : this._handleSingleObject(n, f, _);
    });
    return s === 1 && o === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I(t);
    if (n)
      return s;
    const [u] = o, c = +u.getValue(), l = e.length;
    let f = 0, m = 0;
    for (let E = 0; E < l; E++)
      f += e[E], m += e[E] ** 2;
    let d = 0;
    if (r !== void 0) {
      const { isError: E, errorObject: R, variants: b } = I(r);
      if (E)
        return R;
      const [p] = b;
      d = +p.getValue();
    } else {
      const E = f / l;
      d = Math.sqrt((m - 2 * E * f + l * E ** 2) / (l - 1));
    }
    if (d <= 0)
      return g.create(h.NUM);
    const _ = (f / l - c) / (d / Math.sqrt(l)), C = 1 - Jr(_, 0, 1);
    return Number.isNaN(C) || !Number.isFinite(C) ? g.create(h.NUM) : y.create(C);
  }
  _getArrayValues(e) {
    const t = [], r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1;
    for (let s = 0; s < r; s++)
      for (let o = 0; o < n; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        if (u.isNull() || u.isBoolean() || u.isString())
          continue;
        const c = u.getValue();
        q(c) && t.push(+c);
      }
    return t;
  }
}
class og extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    let o = n != null ? n : y.create(0), u = s != null ? s : y.create(1);
    o.isNull() && (o = y.create(0)), u.isNull() && (u = y.create(1));
    const c = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1
    ), l = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1
    ), f = O(c, l, e, g.create(h.NA)), m = O(c, l, t, g.create(h.NA)), d = O(c, l, r, g.create(h.NA)), _ = O(c, l, o, g.create(h.NA)), C = O(c, l, u, g.create(h.NA)), E = f.mapValue((R, b, p) => {
      const V = m.get(b, p), S = d.get(b, p), M = _.get(b, p), D = C.get(b, p);
      return this._handleSingleObject(R, V, S, M, D);
    });
    return c === 1 && l === 1 ? E.get(0, 0) : E;
  }
  _handleSingleObject(e, t, r, n, s) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (r.isError())
      return r;
    if (n.isError())
      return n;
    if (s.isError())
      return s;
    const { isError: o, errorObject: u, variants: c } = I(e, t, r, n, s);
    if (o)
      return u;
    const [l, f, m, d, _] = c, C = +l.getValue(), E = +f.getValue(), R = +m.getValue(), b = +d.getValue(), p = +_.getValue();
    if (E <= 0 || R <= 0 || C < b || C > p || b === p)
      return g.create(h.NUM);
    const V = iu((C - b) / (p - b), E, R);
    return y.create(V);
  }
}
var fe = /* @__PURE__ */ ((a) => (a.BETADIST = "BETADIST", a.BETAINV = "BETAINV", a.BINOMDIST = "BINOMDIST", a.CHIDIST = "CHIDIST", a.CHIINV = "CHIINV", a.CHITEST = "CHITEST", a.CONFIDENCE = "CONFIDENCE", a.COVAR = "COVAR", a.CRITBINOM = "CRITBINOM", a.EXPONDIST = "EXPONDIST", a.FDIST = "FDIST", a.FINV = "FINV", a.FTEST = "FTEST", a.GAMMADIST = "GAMMADIST", a.GAMMAINV = "GAMMAINV", a.HYPGEOMDIST = "HYPGEOMDIST", a.LOGINV = "LOGINV", a.LOGNORMDIST = "LOGNORMDIST", a.MODE = "MODE", a.NEGBINOMDIST = "NEGBINOMDIST", a.NORMDIST = "NORMDIST", a.NORMINV = "NORMINV", a.NORMSDIST = "NORMSDIST", a.NORMSINV = "NORMSINV", a.PERCENTILE = "PERCENTILE", a.PERCENTRANK = "PERCENTRANK", a.POISSON = "POISSON", a.QUARTILE = "QUARTILE", a.RANK = "RANK", a.STDEV = "STDEV", a.STDEVP = "STDEVP", a.TDIST = "TDIST", a.TINV = "TINV", a.TTEST = "TTEST", a.VAR = "VAR", a.VARP = "VARP", a.WEIBULL = "WEIBULL", a.ZTEST = "ZTEST", a))(fe || {});
class ug extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(h.NA)), c = O(s, o, t, g.create(h.NA)), l = O(s, o, r, g.create(h.NA)), f = O(s, o, n, g.create(h.NA)), m = u.mapValue((d, _, C) => {
      const E = c.get(_, C), R = l.get(_, C), b = f.get(_, C);
      return d.isError() ? d : E.isError() ? E : R.isError() ? R : b.isError() ? b : this._handleSingleObject(d, E, R, b);
    });
    return s === 1 && o === 1 ? m.get(0, 0) : m;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = I(e, t, r, n);
    if (s)
      return o;
    const [c, l, f, m] = u, d = Math.floor(+c.getValue()), _ = Math.floor(+l.getValue()), C = Math.floor(+f.getValue()), E = Math.floor(+m.getValue());
    if (d < 0 || d > _ || d > C || d < _ - E + C || _ <= 0 || _ > E || C <= 0 || C > E || E <= 0)
      return g.create(h.NUM);
    let R = Qa(d, _, C, E);
    return Number.isNaN(R) && (R = 0), y.create(R);
  }
}
class cg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, t, g.create(h.NA)), c = O(n, s, r, g.create(h.NA)), l = o.mapValue((f, m, d) => {
      const _ = u.get(m, d), C = c.get(m, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), m = +c.getValue(), d = +l.getValue();
    if (f <= 0 || d <= 0)
      return g.create(h.NUM);
    const _ = mu(f, m, d);
    return y.create(_);
  }
}
class lg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, t, g.create(h.NA)), c = O(n, s, r, g.create(h.NA)), l = o.mapValue((f, m, d) => {
      const _ = u.get(m, d), C = c.get(m, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = Math.floor(+u.getValue()), m = Math.floor(+c.getValue()), d = +l.getValue();
    if (f < 0 || m < 1 || d <= 0 || d >= 1)
      return g.create(h.NUM);
    const _ = qa(f, m, d);
    return y.create(_);
  }
}
class fg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return e.getRowCount() === 1 && e.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = I(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue(), u = Jr(o, 0, 1);
    return y.create(u);
  }
}
class mg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, t, r) {
    let n = e;
    n.isReferenceObject() && (n = n.toArrayValueObject());
    const { refHasError: s, refErrorObject: o, refNumbers: u } = this._checkRefReferenceObject(t);
    let c = r != null ? r : y.create(0);
    c.isReferenceObject() && (c = c.toArrayValueObject());
    const l = Math.max(
      n.isArray() ? n.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f = Math.max(
      n.isArray() ? n.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), m = O(l, f, n, g.create(h.NA)), d = O(l, f, c, g.create(h.NA)), _ = m.map((C, E, R) => {
      const b = d.get(E, R);
      if (!e.isReferenceObject() && e.isNull())
        return g.create(h.NA);
      if (s)
        return o;
      if (b.isError())
        return b;
      const p = +C.getValue(), V = +b.getValue();
      if (Number.isNaN(p) || Number.isNaN(V))
        return g.create(h.VALUE);
      const M = u.sort((D, w) => V ? D - w : w - D).indexOf(p);
      return M === -1 ? g.create(h.NA) : y.create(M + 1);
    });
    return l === 1 && f === 1 ? _.get(0, 0) : _;
  }
  _checkRefReferenceObject(e) {
    let t = !1, r = g.create(h.NA);
    const n = [];
    return e.isReferenceObject() ? (e.toArrayValueObject().iterator((o) => {
      const u = o;
      if (u.isError())
        return t = !0, r = u, !1;
      if (u.isNull() || u.isBoolean())
        return !0;
      const c = +u.getValue();
      if (Number.isNaN(c))
        return !0;
      n.push(c);
    }), {
      refHasError: t,
      refErrorObject: r,
      refNumbers: n
    }) : {
      refHasError: !0,
      refErrorObject: r,
      refNumbers: n
    };
  }
}
class hg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, t, g.create(h.NA)), c = O(n, s, r, g.create(h.NA)), l = o.mapValue((f, m, d) => {
      const _ = u.get(m, d), C = c.get(m, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), m = Math.floor(+c.getValue()), d = Math.floor(+l.getValue());
    if (f < 0 || m < 1 || m > 10 ** 10 || d < 1 || d > 2)
      return g.create(h.NUM);
    let _ = en(-f, m);
    return d === 2 && (_ *= 2), Number.isNaN(_) || !Number.isFinite(_) ? g.create(h.NUM) : y.create(_);
  }
}
const gg = [
  [og, fe.BETADIST],
  [Su, fe.BETAINV],
  [Mu, fe.BINOMDIST],
  [wu, fe.CHIDIST],
  [Lu, fe.CHIINV],
  [Pu, fe.CHITEST],
  [xu, fe.CONFIDENCE],
  [ju, fe.COVAR],
  [Du, fe.CRITBINOM],
  [Uu, fe.EXPONDIST],
  [vu, fe.FDIST],
  [Tu, fe.FINV],
  [Iu, fe.FTEST],
  [Bu, fe.GAMMADIST],
  [Fu, fe.GAMMAINV],
  [ug, fe.HYPGEOMDIST],
  [cg, fe.LOGNORMDIST],
  [ku, fe.LOGINV],
  [$u, fe.MODE],
  [lg, fe.NEGBINOMDIST],
  [Yu, fe.NORMDIST],
  [Hu, fe.NORMINV],
  [fg, fe.NORMSDIST],
  [Gu, fe.NORMSINV],
  [Wu, fe.PERCENTILE],
  [Qu, fe.PERCENTRANK],
  [qu, fe.POISSON],
  [Xu, fe.QUARTILE],
  [mg, fe.RANK],
  [Zu, fe.STDEV],
  [Ku, fe.STDEVP],
  [hg, fe.TDIST],
  [zu, fe.TINV],
  [Ju, fe.TTEST],
  [tc, fe.VAR],
  [ec, fe.VARP],
  [rc, fe.WEIBULL],
  [nc, fe.ZTEST]
], dg = [];
var Cg = /* @__PURE__ */ ((a) => (a.CUBEKPIMEMBER = "CUBEKPIMEMBER", a.CUBEMEMBER = "CUBEMEMBER", a.CUBEMEMBERPROPERTY = "CUBEMEMBERPROPERTY", a.CUBERANKEDMEMBER = "CUBERANKEDMEMBER", a.CUBESET = "CUBESET", a.CUBESETCOUNT = "CUBESETCOUNT", a.CUBEVALUE = "CUBEVALUE", a))(Cg || {});
class _g extends N {
  isCustom() {
    return !0;
  }
}
class Hb extends _g {
  isAsync() {
    return !0;
  }
}
function at(a) {
  const i = [];
  if (a.isError())
    return {
      isError: !0,
      errorObject: a,
      databaseValues: i
    };
  const e = a.isArray() ? a.getRowCount() : 1, t = a.isArray() ? a.getColumnCount() : 1;
  if (e < 2)
    return {
      isError: !0,
      errorObject: g.create(h.VALUE),
      databaseValues: i
    };
  for (let r = 0; r < e; r++) {
    const n = [];
    for (let s = 0; s < t; s++) {
      const o = a.get(r, s);
      if (o.isNull()) {
        n.push(null);
        continue;
      }
      let u = `${o.getValue()}`;
      if (o.isBoolean() && (u = u.toLocaleUpperCase()), o.isNumber() || q(u)) {
        n.push(+u);
        continue;
      }
      n.push(u);
    }
    i.push(n);
  }
  return {
    isError: !1,
    errorObject: null,
    databaseValues: i
  };
}
function it(a, i) {
  let e = -1;
  if (a.isError())
    return {
      isError: !0,
      errorObject: a,
      fieldIndex: e
    };
  const t = a.isArray() ? a.getRowCount() : 1, r = a.isArray() ? a.getColumnCount() : 1;
  if (t > 1 || r > 1)
    return {
      isError: !0,
      errorObject: g.create(h.VALUE),
      fieldIndex: e
    };
  const n = a.isArray() ? a.get(0, 0) : a;
  let s = `${n.getValue()}`;
  if (n.isNull() ? s = 0 : n.isBoolean() ? s = n.getValue() ? 1 : 0 : (n.isNumber() || q(s)) && (s = Math.floor(+s)), typeof s == "number") {
    if (s < 1 || s > i[0].length)
      return {
        isError: !0,
        errorObject: g.create(h.VALUE),
        fieldIndex: e
      };
    e = s - 1;
  } else if (e = i[0].findIndex((o) => o === null ? !1 : `${o}`.toLocaleLowerCase() === s.toLocaleLowerCase()), e === -1)
    return {
      isError: !0,
      errorObject: g.create(h.VALUE),
      fieldIndex: e
    };
  return {
    isError: !1,
    errorObject: null,
    fieldIndex: e
  };
}
function ot(a) {
  const i = [];
  if (a.isError())
    return {
      isError: !0,
      errorObject: a,
      criteriaValues: i
    };
  const e = a.isArray() ? a.getRowCount() : 1, t = a.isArray() ? a.getColumnCount() : 1;
  if (e < 2)
    return {
      isError: !0,
      errorObject: g.create(h.VALUE),
      criteriaValues: i
    };
  for (let r = 0; r < e; r++) {
    const n = [];
    for (let s = 0; s < t; s++) {
      const o = a.get(r, s);
      if (o.isNull()) {
        n.push(null);
        continue;
      }
      const u = `${o.getValue()}`;
      if (o.isBoolean()) {
        n.push(o.getValue() ? 1 : 0);
        continue;
      }
      if (o.isNumber() || q(u)) {
        n.push(+u);
        continue;
      }
      n.push(u);
    }
    i.push(n);
  }
  return {
    isError: !1,
    errorObject: null,
    criteriaValues: i
  };
}
function ut(a, i, e) {
  const t = a.length, r = a[0].length, n = {};
  let s = !1;
  for (let o = 1; o < t; o++) {
    let u = !0;
    for (let c = 0; c < r; c++) {
      const l = a[o][c];
      if (l === null)
        continue;
      let f = n[c];
      if (f === void 0) {
        const m = a[0][c];
        f = i[0].findIndex((d) => d === null || m === null ? !1 : `${d}`.toLocaleLowerCase() === `${m}`.toLocaleLowerCase()), n[c] = f;
      }
      if (f === -1 && (typeof l == "string" || l === 0)) {
        u = !1;
        break;
      } else if (f > -1) {
        const m = i[e][f];
        if (m === null) {
          u = !1;
          break;
        }
        const [d, _] = La(`${l}`);
        if (!Pt.create(`${m}`).compare(_, d).getValue()) {
          u = !1;
          break;
        }
      }
    }
    if (u) {
      s = !0;
      break;
    }
  }
  return s;
}
class Ag extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = at(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = it(t, o);
    if (u)
      return c;
    const { isError: f, errorObject: m, criteriaValues: d } = ot(r);
    if (f)
      return m;
    let _ = 0, C = 0;
    for (let E = 1; E < o.length; E++) {
      const R = o[E][l];
      typeof R == "number" && ut(d, o, E) && (_ += R, C++);
    }
    return C === 0 ? g.create(h.DIV_BY_ZERO) : y.create(_ / C);
  }
}
class Eg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = at(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = it(t, o);
    if (u)
      return c;
    const { isError: f, errorObject: m, criteriaValues: d } = ot(r);
    if (f)
      return m;
    let _ = 0;
    for (let C = 1; C < o.length; C++)
      typeof o[C][l] == "number" && ut(d, o, C) && _++;
    return y.create(_);
  }
}
class Rg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = at(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = it(t, o);
    if (u)
      return c;
    const { isError: f, errorObject: m, criteriaValues: d } = ot(r);
    if (f)
      return m;
    let _ = 0;
    for (let C = 1; C < o.length; C++) {
      const E = o[C][l];
      E != null && ut(d, o, C) && _++;
    }
    return y.create(_);
  }
}
class bg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = at(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = it(t, o);
    if (u)
      return c;
    const { isError: f, errorObject: m, criteriaValues: d } = ot(r);
    if (f)
      return m;
    let _ = 0, C = 0;
    for (let E = 1; E < o.length; E++) {
      const R = o[E][l];
      R != null && ut(d, o, E) && (_++, C = E);
    }
    return _ === 0 ? g.create(h.VALUE) : _ > 1 ? g.create(h.NUM) : e.get(C, l);
  }
}
class yg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = at(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = it(t, o);
    if (u)
      return c;
    const { isError: f, errorObject: m, criteriaValues: d } = ot(r);
    if (f)
      return m;
    let _ = -1 / 0, C = 0;
    for (let E = 1; E < o.length; E++) {
      const R = o[E][l];
      typeof R == "number" && ut(d, o, E) && (_ = Math.max(_, R), C++);
    }
    return C === 0 ? y.create(0) : y.create(_);
  }
}
class pg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = at(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = it(t, o);
    if (u)
      return c;
    const { isError: f, errorObject: m, criteriaValues: d } = ot(r);
    if (f)
      return m;
    let _ = 1 / 0, C = 0;
    for (let E = 1; E < o.length; E++) {
      const R = o[E][l];
      typeof R == "number" && ut(d, o, E) && (_ = Math.min(_, R), C++);
    }
    return C === 0 ? y.create(0) : y.create(_);
  }
}
class Ng extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = at(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = it(t, o);
    if (u)
      return c;
    const { isError: f, errorObject: m, criteriaValues: d } = ot(r);
    if (f)
      return m;
    let _ = 1, C = 0;
    for (let E = 1; E < o.length; E++) {
      const R = o[E][l];
      typeof R == "number" && ut(d, o, E) && (_ *= R, C++);
    }
    return C === 0 ? y.create(0) : y.create(_);
  }
}
class Vg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = at(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = it(t, o);
    if (u)
      return c;
    const { isError: f, errorObject: m, criteriaValues: d } = ot(r);
    if (f)
      return m;
    const _ = [];
    let C = 0, E = 0;
    for (let V = 1; V < o.length; V++) {
      const S = o[V][l];
      typeof S == "number" && ut(d, o, V) && (_.push(S), C += S, E++);
    }
    if (E <= 1)
      return g.create(h.DIV_BY_ZERO);
    const R = C / E;
    let b = 0;
    for (let V = 0; V < E; V++)
      b += (_[V] - R) ** 2;
    const p = Math.sqrt(b / (E - 1));
    return y.create(p);
  }
}
class Og extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = at(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = it(t, o);
    if (u)
      return c;
    const { isError: f, errorObject: m, criteriaValues: d } = ot(r);
    if (f)
      return m;
    const _ = [];
    let C = 0, E = 0;
    for (let V = 1; V < o.length; V++) {
      const S = o[V][l];
      typeof S == "number" && ut(d, o, V) && (_.push(S), C += S, E++);
    }
    if (E === 0)
      return g.create(h.DIV_BY_ZERO);
    const R = C / E;
    let b = 0;
    for (let V = 0; V < E; V++)
      b += (_[V] - R) ** 2;
    const p = Math.sqrt(b / E);
    return y.create(p);
  }
}
class Sg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = at(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = it(t, o);
    if (u)
      return c;
    const { isError: f, errorObject: m, criteriaValues: d } = ot(r);
    if (f)
      return m;
    let _ = 0;
    for (let C = 1; C < o.length; C++) {
      const E = o[C][l];
      typeof E == "number" && ut(d, o, C) && (_ += E);
    }
    return y.create(_);
  }
}
class Mg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = at(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = it(t, o);
    if (u)
      return c;
    const { isError: f, errorObject: m, criteriaValues: d } = ot(r);
    if (f)
      return m;
    const _ = [];
    let C = 0, E = 0;
    for (let V = 1; V < o.length; V++) {
      const S = o[V][l];
      typeof S == "number" && ut(d, o, V) && (_.push(S), C += S, E++);
    }
    if (E <= 1)
      return g.create(h.DIV_BY_ZERO);
    const R = C / E;
    let b = 0;
    for (let V = 0; V < E; V++)
      b += (_[V] - R) ** 2;
    const p = b / (E - 1);
    return y.create(p);
  }
}
class Dg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, databaseValues: o } = at(e);
    if (n)
      return s;
    const { isError: u, errorObject: c, fieldIndex: l } = it(t, o);
    if (u)
      return c;
    const { isError: f, errorObject: m, criteriaValues: d } = ot(r);
    if (f)
      return m;
    const _ = [];
    let C = 0, E = 0;
    for (let V = 1; V < o.length; V++) {
      const S = o[V][l];
      typeof S == "number" && ut(d, o, V) && (_.push(S), C += S, E++);
    }
    if (E === 0)
      return g.create(h.DIV_BY_ZERO);
    const R = C / E;
    let b = 0;
    for (let V = 0; V < E; V++)
      b += (_[V] - R) ** 2;
    const p = b / E;
    return y.create(p);
  }
}
var Xe = /* @__PURE__ */ ((a) => (a.DAVERAGE = "DAVERAGE", a.DCOUNT = "DCOUNT", a.DCOUNTA = "DCOUNTA", a.DGET = "DGET", a.DMAX = "DMAX", a.DMIN = "DMIN", a.DPRODUCT = "DPRODUCT", a.DSTDEV = "DSTDEV", a.DSTDEVP = "DSTDEVP", a.DSUM = "DSUM", a.DVAR = "DVAR", a.DVARP = "DVARP", a))(Xe || {});
const wg = [
  [Ag, Xe.DAVERAGE],
  [Eg, Xe.DCOUNT],
  [Rg, Xe.DCOUNTA],
  [bg, Xe.DGET],
  [yg, Xe.DMAX],
  [pg, Xe.DMIN],
  [Ng, Xe.DPRODUCT],
  [Vg, Xe.DSTDEV],
  [Og, Xe.DSTDEVP],
  [Sg, Xe.DSUM],
  [Mg, Xe.DVAR],
  [Dg, Xe.DVARP]
], Xa = "yyyy/mm/dd;@", Lg = "yyyy/mm/dd hh:mm", Pg = "h:mm A/P";
function pe(a) {
  const i = new Date(Date.UTC(1900, 0, 1)), e = new Date(Date.UTC(1900, 1, 28)), t = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
  let r = (t - i.getTime()) / (1e3 * 3600 * 24);
  return t > e.getTime() && (r += 1), Math.floor(r) + 1;
}
function tn(a) {
  const i = new Date(Date.UTC(1900, 0, 1, 0, 0, 0)), e = new Date(Date.UTC(1900, 1, 28, 0, 0, 0));
  let r = (a.getTime() - i.getTime()) / (1e3 * 3600 * 24);
  return a > e && (r += 1), r + 1;
}
function ae(a) {
  const i = new Date(Date.UTC(1900, 0, 1)), e = new Date(Date.UTC(1900, 1, 28));
  let t = Math.floor(a) - 1;
  return t > (e.getTime() - i.getTime()) / (1e3 * 3600 * 24) && (t -= 1), new Date(i.getTime() + t * (1e3 * 3600 * 24));
}
function Ka(a) {
  const i = new Date(Date.UTC(1900, 0, 1, 0, 0, 0)), e = new Date(Date.UTC(1900, 1, 28, 0, 0, 0));
  let t = a - 1;
  return t > (e.getTime() - i.getTime()) / (1e3 * 3600 * 24) && (t -= 1), t < 0 && (t = a), new Date(i.getTime() + t * (1e3 * 3600 * 24));
}
function Za(a) {
  if (!/^\d{4}[-/](0?[1-9]|1[012])[-/](0?[1-9]|[12][0-9]|3[01])$/.test(a))
    return !1;
  const e = a.replace(/-/g, "/").replace(/T.+/, ""), t = /* @__PURE__ */ new Date(`${e}`);
  if (Number.isNaN(t.getTime()))
    return !1;
  const r = t.getFullYear(), n = (t.getMonth() + 1).toString().padStart(2, "0"), s = t.getDate().toString().padStart(2, "0"), o = `${r}-${n}-${s}`;
  return a.replace(/\//g, "-").split("-").map((c) => c.padStart(2, "0")).join("-") === o;
}
function Yn(a) {
  return ht.parseDate(a);
}
function xg(a) {
  return ht.parseValue(a);
}
function Hn(a) {
  return ht.parseTime(a);
}
function za(a) {
  return ht.getFormatInfo(a).isDate;
}
const sc = {
  1: [6, 0],
  // Saturday, Sunday
  2: [0, 1],
  // Sunday, Monday
  3: [1, 2],
  // Monday, Tuesday
  4: [2, 3],
  // Tuesday, Wednesday
  5: [3, 4],
  // Wednesday, Thursday
  6: [4, 5],
  // Thursday, Friday
  7: [5, 6],
  // Friday, Saturday
  11: [0],
  // Sunday only
  12: [1],
  // Monday only
  13: [2],
  // Tuesday only
  14: [3],
  // Wednesday only
  15: [4],
  // Thursday only
  16: [5],
  // Friday only
  17: [6]
  // Saturday only
};
function Qr(a) {
  return !!(typeof a == "string" && /^[0|1]{7}/.test(a) || sc[Number(a)]);
}
function ac(a) {
  if (!Qr(a))
    return [];
  if (typeof a == "string" && /^[0|1]{7}/.test(a)) {
    const i = [];
    for (let e = 1; e <= a.length; e++)
      `${a[e - 1]}` == "1" && (e === a.length ? i.push(0) : i.push(e));
    return i;
  }
  return sc[Number(a)] || [];
}
function Gn(a, i, e = 1, t) {
  const r = ac(e), n = Math.floor(a), s = Math.floor(i), o = s > n ? n : s;
  let u = 0;
  const c = Math.abs(Math.floor(i) - Math.floor(a)) + 1;
  for (let l = 0; l < c; l++) {
    const f = o + l;
    if (t && t.length > 0 && t.some((d) => Math.floor(d) === f))
      continue;
    const m = or(f);
    r.includes(m) || u++;
  }
  return s >= n ? u : -u;
}
function Wn(a, i, e = 1, t) {
  const r = ac(e), n = Math.floor(a);
  let s = n, o = Math.abs(i);
  for (let u = 1; u <= o; u++) {
    const c = i < 0 ? n - u : n + u;
    if (c < 0)
      return g.create(h.NUM);
    if (t && t.length > 0 && t.some((f) => Math.floor(f) === c)) {
      o++;
      continue;
    }
    const l = or(c);
    if (r.includes(l)) {
      o++;
      continue;
    }
    s = c;
  }
  return s;
}
function H(a) {
  if (a.isError())
    return a;
  const i = a.getValue();
  if (a.isString()) {
    let e;
    if (Yn(`${i}`))
      e = Yn(`${i}`).v;
    else if (Hn(`${i}`))
      e = Hn(`${i}`).v;
    else if (q(i))
      e = +i;
    else
      return g.create(h.VALUE);
    return e instanceof Date && (e = tn(e)), +e < 0 || +e > 2958465 ? g.create(h.NUM) : +e;
  } else {
    const e = +a.getValue();
    return e < 0 || e > 2958465 ? g.create(h.NUM) : e;
  }
}
function or(a) {
  const i = Math.floor(a) === 60;
  let e = ae(a);
  const t = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate())).getTime(), r = new Date(Date.UTC(1900, 1, 28)).getTime();
  return !i && t <= r && (e = new Date(t - 24 * 3600 * 1e3)), new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate())).getUTCDay();
}
function _e(a, i, e) {
  switch (e) {
    case 0:
      return jg(a, i);
    case 1:
      return Ug(a, i);
    case 2:
      return {
        days: Math.abs(i - a),
        yearDays: 360
      };
    case 3:
      return {
        days: Math.abs(i - a),
        yearDays: 365
      };
    case 4:
      return vg(a, i);
    default:
      return {
        days: Math.abs(i - a),
        yearDays: 365
      };
  }
}
function jg(a, i) {
  const e = ae(a), t = a > 0 ? e.getUTCFullYear() : 1900, r = a > 0 ? e.getUTCMonth() + 1 : 1;
  let n = a > 0 ? e.getUTCDate() : 0, s = ae(i), o = i > 0 ? s.getUTCFullYear() : 1900, u = i > 0 ? s.getUTCMonth() + 1 : 1, c = i > 0 ? s.getUTCDate() : 0;
  r === 2 ? ae(a + 1).getUTCMonth() + 1 === 3 && (n = 30) : n === 31 && (n = 30), c === 31 && (n < 30 ? (s = ae(i + 1), o = s.getUTCFullYear(), u = s.getUTCMonth() + 1, c = s.getUTCDate()) : c = 30);
  const l = (o - t) * 360, f = i >= a ? 30 - n : -n, m = i >= a ? c : c - 30, d = (i >= a ? u - r - 1 : u - r + 1) * 30;
  return {
    days: Math.abs(l + f + m + d),
    yearDays: 360
  };
}
function Ug(a, i) {
  const e = ae(a), t = a > 0 ? e.getUTCFullYear() : 1900, r = ae(i), n = i > 0 ? r.getUTCFullYear() : 1900, s = Math.abs(i - a), o = Math.abs(n - t) + 1;
  let u, c;
  if (n < t) {
    const l = new Date(Date.UTC(n, 0, 1)), f = new Date(Date.UTC(t, 11, 31));
    u = pe(l), c = pe(f), n === 1900 && (u += 1);
  } else {
    const l = new Date(Date.UTC(t, 0, 1)), f = new Date(Date.UTC(n, 11, 31));
    u = pe(l), c = pe(f), t === 1900 && (u += 1);
  }
  return {
    days: s,
    yearDays: (c - u + 1) / o
  };
}
function vg(a, i) {
  const e = ae(a), t = a > 0 ? e.getUTCFullYear() : 1900, r = a > 0 ? e.getUTCMonth() + 1 : 1;
  let n = a > 0 ? e.getUTCDate() : 0;
  const s = ae(i), o = i > 0 ? s.getUTCFullYear() : 1900, u = i > 0 ? s.getUTCMonth() + 1 : 1;
  let c = i > 0 ? s.getUTCDate() : 0;
  n === 31 && (n = 30), c === 31 && (c = 30);
  const l = (o - t) * 360, f = i >= a ? 30 - n : -n, m = i >= a ? c : c - 30, d = (i >= a ? u - r - 1 : u - r + 1) * 30;
  return {
    days: Math.abs(l + f + m + d),
    yearDays: 360
  };
}
function Tg(a) {
  return a % 4 === 0 && a % 100 !== 0 || a % 400 === 0;
}
function Ig(a) {
  return a % 4 === 0 && a % 100 !== 0 || a % 400 === 0 || a === 1900;
}
const Bg = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Fg = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function rn(a, i) {
  return Tg(a) ? Bg[i] : Fg[i];
}
function _s(a) {
  return Ig(a) ? 366 : 365;
}
function ic(a, i) {
  switch (i) {
    case 0:
    case 2:
    case 4:
      return 360;
    case 1:
      return _s(ae(a).getUTCFullYear());
    case 3:
      return 365;
    default:
      return -1;
  }
}
function Sr(a, i, e) {
  return rn(a, i) === e;
}
function Mr(a, i) {
  let e = a.getUTCFullYear(), t = a.getUTCMonth();
  const r = a.getUTCDate();
  return Sr(e, t, r) ? (a.setUTCDate(1), a.setUTCMonth(a.getUTCMonth() + i), e = a.getUTCFullYear(), t = a.getUTCMonth(), a.setUTCDate(rn(e, t))) : a.setUTCMonth(a.getUTCMonth() + i), a;
}
class kg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, t, g.create(h.NA)), c = O(n, s, r, g.create(h.NA)), l = o.map((f, m, d) => {
      const _ = u.get(m, d), C = c.get(m, d);
      if (f.isError())
        return f;
      if (_.isError())
        return _;
      if (C.isError())
        return C;
      const { isError: E, errorObject: R, variants: b } = I(f, _, C);
      if (E)
        return R;
      const [p, V, S] = b;
      let M = Math.floor(+p.getValue());
      const D = Math.floor(+V.getValue()), w = Math.floor(+S.getValue());
      if (M < 0 || M > 9999)
        return g.create(h.NUM);
      M >= 0 && M < 1899 && (M += 1900);
      const L = new Date(M, D - 1, w), v = pe(L);
      return v < 0 ? g.create(h.NUM) : y.create(v, Xa);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
}
class $g extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    let n = e, s = t, o = r;
    if (n.isArray() && (n = n.get(0, 0)), s.isArray() && (s = s.get(0, 0)), o.isArray() && (o = o.get(0, 0)), n.isError())
      return n;
    if (s.isError())
      return s;
    if (o.isError())
      return o;
    const u = H(n);
    if (typeof u != "number")
      return u;
    const c = H(s);
    return typeof c != "number" ? c : c < u || !o.isString() ? g.create(h.NUM) : this._getResultByUnit(u, c, o);
  }
  _getResultByUnit(e, t, r) {
    const n = ae(e), s = n.getUTCFullYear(), o = n.getUTCMonth() + 1, u = n.getUTCDate(), c = ae(t), l = c.getUTCFullYear(), f = c.getUTCMonth() + 1, m = c.getUTCDate(), d = `${r.getValue()}`.toLocaleUpperCase();
    let _ = 0, C;
    switch (d) {
      case "Y":
        _ = l - s, (f < o || f === o && m < u) && (_ -= 1);
        break;
      case "M":
        _ = (l - s) * 12 + f - o, m < u && (_ -= 1);
        break;
      case "D":
        _ = Math.floor(t) - Math.floor(e);
        break;
      case "MD":
        _ = m - u, m < u && (C = new Date(Date.UTC(l, f - 1, 0)), _ += rn(C.getUTCFullYear(), C.getUTCMonth()));
        break;
      case "YM":
        _ = f - o, (f < o || f === o && m < u) && (_ += 12), m < u && (_ -= 1);
        break;
      case "YD":
        C = new Date(Date.UTC(s, f - 1, m)), (f < o || f === o && m < u) && (C = new Date(Date.UTC(s + 1, f - 1, m))), _ = Math.floor(pe(C)) - Math.floor(e);
        break;
      default:
        return g.create(h.NUM);
    }
    return y.create(_);
  }
}
class Yg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  isArgumentsIgnoreNumberPattern() {
    return !0;
  }
  calculate(e) {
    return e.isArray() ? e.mapValue((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isString()) {
      const t = `${e.getValue()}`;
      let r = Yn(t);
      if (r === null && (r = Hn(t)), r) {
        let { v: n, z: s } = r;
        if (s && za(s))
          return n instanceof Date && (n = tn(n)), y.create(Math.trunc(+n));
      }
    }
    return g.create(h.VALUE);
  }
}
class Hg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isError() ? e : e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t;
    const r = e.getValue();
    if (e.isString()) {
      if (!Za(`${r}`))
        return g.create(h.VALUE);
      t = /* @__PURE__ */ new Date(`${r}`);
    } else {
      const o = +e.getValue();
      if (o < 0)
        return g.create(h.NUM);
      if (o === 0)
        return y.create(0);
      t = ae(o);
    }
    const n = t.getDate();
    return y.create(n);
  }
}
class Gg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e), o = O(r, n, t), u = s.map((c, l, f) => {
      const m = o.get(l, f);
      if (c.isError())
        return c;
      if (m.isError())
        return m;
      const d = H(c);
      if (typeof d != "number")
        return d;
      const _ = H(m);
      if (typeof _ != "number")
        return _;
      const C = Math.floor(d) - Math.floor(_);
      return y.create(C);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
}
class Wg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : T.create(!1);
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (n.isError())
      return n;
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(h.NA)), c = O(s, o, t, g.create(h.NA)), l = O(s, o, n, g.create(h.NA)), f = u.map((m, d, _) => {
      const C = c.get(d, _);
      let E = l.get(d, _);
      if (m.isError())
        return m;
      const R = H(m);
      if (typeof R != "number")
        return R;
      if (C.isError())
        return C;
      const b = H(C);
      if (typeof b != "number")
        return b;
      if (E.isString() && (E = E.convertToNumberObjectValue()), E.isError())
        return E;
      const p = +E.getValue(), { days: V } = _e(R, b, p ? 4 : 0), S = b >= R ? V : -V;
      return y.create(S);
    });
    return s === 1 && o === 1 ? f.get(0, 0) : f;
  }
}
class Qg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e), o = O(r, n, t);
    return s.map((u, c, l) => {
      const f = o.get(c, l) || ce.create();
      if (u.isError())
        return u;
      if (f.isError())
        return f;
      if (u.isString() || u.isBoolean() || f.isString() || f.isBoolean())
        return g.create(h.VALUE);
      const m = +u.getValue();
      if (m < 0)
        return g.create(h.NUM);
      const d = Math.floor(+f.getValue()), _ = ae(m), C = _.getUTCFullYear(), E = _.getUTCMonth() + d, R = _.getUTCDate(), b = new Date(Date.UTC(C, E, R)), p = pe(b);
      return y.create(p, Xa);
    });
  }
}
class qg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e, n = t;
    if (r.isArray()) {
      const d = r.getRowCount(), _ = r.getColumnCount();
      if (d > 1 || _ > 1)
        return g.create(h.VALUE);
      r = r.get(0, 0);
    }
    if (n.isArray()) {
      const d = n.getRowCount(), _ = n.getColumnCount();
      if (d > 1 || _ > 1)
        return g.create(h.VALUE);
      n = n.get(0, 0);
    }
    if (r.isError())
      return r;
    if (n.isError())
      return n;
    const s = H(r);
    if (typeof s != "number")
      return s;
    if (n.isBoolean())
      return g.create(h.VALUE);
    const o = ae(s), u = s > 0 ? o.getUTCFullYear() : 1900, c = s > 0 ? o.getUTCMonth() : 0, l = Math.floor(+n.getValue());
    if (Number.isNaN(l))
      return g.create(h.VALUE);
    const f = new Date(Date.UTC(u, c + l + 1, 0)), m = pe(f);
    return y.create(m);
  }
}
class Xg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(1), { isError: n, errorObject: s, timestampIsReferenceObject: o, timestampObject: u, unitObject: c } = this._checkVariants(e, r);
    if (n)
      return s;
    if (u.isNull() || u.isBoolean() || u.isString() || !o && u.isNumber() && u.getPattern() !== "")
      return g.create(h.VALUE);
    let l = +u.getValue();
    const { isError: f, errorObject: m, variants: d } = I(c);
    if (f)
      return m;
    const [_] = d, C = Math.floor(+_.getValue());
    if (l < 0 || C < 1 || C > 3)
      return g.create(h.NUM);
    C === 1 && (l = l * 1e3), C === 3 && (l = l / 1e3);
    const E = new Date(Date.UTC(1970, 0, 1, 0, 0, 0, 0) + l);
    if (Number.isNaN(E.getTime())) {
      const R = 25569 + l / 864e5;
      return y.create(R);
    } else {
      const R = tn(E);
      return y.create(R, "yyyy-MM-dd AM/PM hh:mm:ss");
    }
  }
  _checkVariants(e, t) {
    const r = e.isReferenceObject(), n = t.isReferenceObject();
    let s = e;
    if (r && (s = e.toArrayValueObject()), s.isArray()) {
      const u = s.getRowCount(), c = s.getColumnCount();
      if (u > 1 || c > 1)
        return {
          isError: !0,
          errorObject: g.create(h.VALUE)
        };
      s = s.get(0, 0);
    }
    if (s.isError())
      return {
        isError: !0,
        errorObject: s
      };
    let o = t;
    if (n && (o = t.toArrayValueObject()), o.isArray()) {
      const u = o.getRowCount(), c = o.getColumnCount();
      if (u > 1 || c > 1)
        return {
          isError: !0,
          errorObject: g.create(h.VALUE)
        };
      o = o.get(0, 0);
    }
    return o.isError() ? {
      isError: !0,
      errorObject: o
    } : {
      isError: !1,
      errorObject: null,
      timestampIsReferenceObject: r,
      timestampObject: s,
      unitIsReferenceObject: n,
      unitObject: o
    };
  }
}
var Ae = /* @__PURE__ */ ((a) => (a.DATE = "DATE", a.DATEDIF = "DATEDIF", a.DATEVALUE = "DATEVALUE", a.DAY = "DAY", a.DAYS = "DAYS", a.DAYS360 = "DAYS360", a.EDATE = "EDATE", a.EOMONTH = "EOMONTH", a.EPOCHTODATE = "EPOCHTODATE", a.HOUR = "HOUR", a.ISOWEEKNUM = "ISOWEEKNUM", a.MINUTE = "MINUTE", a.MONTH = "MONTH", a.NETWORKDAYS = "NETWORKDAYS", a.NETWORKDAYS_INTL = "NETWORKDAYS.INTL", a.NOW = "NOW", a.SECOND = "SECOND", a.TIME = "TIME", a.TIMEVALUE = "TIMEVALUE", a.TO_DATE = "TO_DATE", a.TODAY = "TODAY", a.WEEKDAY = "WEEKDAY", a.WEEKNUM = "WEEKNUM", a.WORKDAY = "WORKDAY", a.WORKDAY_INTL = "WORKDAY.INTL", a.YEAR = "YEAR", a.YEARFRAC = "YEARFRAC", a))(Ae || {});
class Kg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isError() ? e : e.isArray() ? e.map((t) => t.isError() ? t : this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const t = H(e);
    if (typeof t != "number")
      return t;
    if (t === 0)
      return y.create(0);
    const n = Ka(t).getUTCHours();
    return y.create(n);
  }
}
class Zg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isError() ? e : e.isArray() ? e.map((t) => t.isError() ? t : this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const t = H(e);
    if (typeof t != "number")
      return t;
    const r = ae(t), n = t > 0 ? r.getUTCFullYear() : 1900;
    let s = new Date(Date.UTC(n, 0, 1)), o = pe(s), u = or(o), c;
    u < 1 ? c = o + 1 : u <= 4 ? c = o - (u - 1) : c = o + (11 - u), t < c && (s = new Date(Date.UTC(n - 1, 0, 1)), o = pe(s), u = or(o), u < 1 ? c = o + 1 : u <= 4 ? c = o - (u - 1) : c = o + (11 - u));
    const l = Math.ceil((t - c + 1) / 7);
    return y.create(l);
  }
}
class zg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isError() ? e : e.isArray() ? e.map((t) => t.isError() ? t : this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const t = H(e);
    if (typeof t != "number")
      return t;
    if (t === 0)
      return y.create(0);
    const n = Ka(t).getUTCMinutes();
    return y.create(n);
  }
}
class Jg extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    let t;
    const r = e.getValue();
    if (e.isString()) {
      if (!Za(`${r}`))
        return g.create(h.VALUE);
      t = /* @__PURE__ */ new Date(`${r}`);
    } else {
      const o = +e.getValue();
      if (o < 0)
        return g.create(h.NUM);
      if (o === 0)
        return y.create(1);
      t = ae(o);
    }
    const n = t.getUTCMonth() + 1;
    return y.create(n);
  }
}
class e1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    let n = e, s = t;
    if (n.isArray()) {
      const l = n.getRowCount(), f = n.getColumnCount();
      if (l > 1 || f > 1)
        return g.create(h.VALUE);
      n = n.get(0, 0);
    }
    if (n.isError())
      return n;
    if (s.isArray()) {
      const l = s.getRowCount(), f = s.getColumnCount();
      if (l > 1 || f > 1)
        return g.create(h.VALUE);
      s = s.get(0, 0);
    }
    if (s.isError())
      return s;
    if (r != null && r.isError())
      return r;
    if (n.isBoolean() || s.isBoolean())
      return g.create(h.VALUE);
    const o = H(n);
    if (typeof o != "number")
      return o;
    const u = H(s);
    if (typeof u != "number")
      return u;
    if (r)
      return this._getResultByHolidays(o, u, r);
    const c = Gn(o, u);
    return y.create(c);
  }
  _getResultByHolidays(e, t, r) {
    const n = [];
    if (r != null && r.isArray()) {
      const o = r.getRowCount(), u = r.getColumnCount();
      for (let c = 0; c < o; c++)
        for (let l = 0; l < u; l++) {
          const f = r.get(c, l);
          if (f.isBoolean())
            return g.create(h.VALUE);
          const m = H(f);
          if (typeof m != "number")
            return m;
          n.push(m);
        }
    } else {
      if (r.isBoolean())
        return g.create(h.VALUE);
      const o = H(r);
      if (typeof o != "number")
        return o;
      n.push(o);
    }
    const s = Gn(e, t, 1, n);
    return y.create(s);
  }
}
class t1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    return e.isError() ? e : t.isError() ? t : r != null && r.isError() ? r : n != null && n.isError() ? n : r != null && r.isArray() ? r.map((s) => this._handleSingleObject(e, t, s, n)) : this._handleSingleObject(e, t, r, n);
  }
  _handleSingleObject(e, t, r, n) {
    let s = e, o = t;
    if (s.isArray()) {
      const m = s.getRowCount(), d = s.getColumnCount();
      if (m > 1 || d > 1)
        return g.create(h.VALUE);
      s = s.get(0, 0);
    }
    if (s.isError())
      return s;
    if (o.isArray()) {
      const m = o.getRowCount(), d = o.getColumnCount();
      if (m > 1 || d > 1)
        return g.create(h.VALUE);
      o = o.get(0, 0);
    }
    if (o.isError())
      return o;
    let u = 1;
    if (r) {
      if (u = r.getValue(), r.isBoolean() && (u = +u), r.isString() && !Qr(u))
        return g.create(h.VALUE);
      if (!Qr(u))
        return g.create(h.NUM);
    }
    if (s.isBoolean() || o.isBoolean())
      return g.create(h.VALUE);
    const c = H(s);
    if (typeof c != "number")
      return c;
    const l = H(o);
    if (typeof l != "number")
      return l;
    if (n)
      return this._getResultByHolidays(c, l, u, n);
    const f = Gn(c, l, u);
    return y.create(f);
  }
  _getResultByHolidays(e, t, r, n) {
    const s = [];
    if (n != null && n.isArray()) {
      const u = n.getRowCount(), c = n.getColumnCount();
      for (let l = 0; l < u; l++)
        for (let f = 0; f < c; f++) {
          const m = n.get(l, f);
          if (m.isBoolean())
            return g.create(h.VALUE);
          const d = H(m);
          if (typeof d != "number")
            return d;
          s.push(d);
        }
    } else {
      if (n.isBoolean())
        return g.create(h.VALUE);
      const u = H(n);
      if (typeof u != "number")
        return u;
      s.push(u);
    }
    const o = Gn(e, t, r, s);
    return y.create(o);
  }
}
class r1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 0);
  }
  calculate() {
    const e = /* @__PURE__ */ new Date(), t = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds())), r = tn(t);
    return y.create(r, Lg);
  }
}
class n1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isError() ? e : e.isArray() ? e.map((t) => t.isError() ? t : this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const t = H(e);
    if (typeof t != "number")
      return t;
    if (t === 0)
      return y.create(0);
    const n = Ka(t).getUTCSeconds();
    return y.create(n);
  }
}
class s1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (r.isError())
      return r;
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e), u = O(n, s, t), c = O(n, s, r);
    return o.map((l, f, m) => this._calculateTime(l, u, c, f, m));
  }
  _calculateTime(e, t, r, n, s) {
    let o = e, u = t.get(n, s) || ce.create(), c = r.get(n, s) || ce.create();
    if ((o.isString() || o.isBoolean()) && (o = o.convertToNumberObjectValue()), (u.isString() || u.isBoolean()) && (u = u.convertToNumberObjectValue()), (c.isString() || c.isBoolean()) && (c = c.convertToNumberObjectValue()), o.isError())
      return o;
    if (u.isError())
      return u;
    if (c.isError())
      return c;
    let l = Math.floor(+o.getValue()), f = Math.floor(+u.getValue()), m = Math.floor(+c.getValue());
    if (l < 0 || f < 0 || m < 0 || l > 32767 || f > 32767 || m > 32767)
      return g.create(h.NUM);
    f += Math.floor(m / 60), m %= 60, l += Math.floor(f / 60), f %= 60, l %= 24;
    const _ = (l * 3600 + f * 60 + m) / 86400;
    return y.create(_, Pg);
  }
}
class a1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  isArgumentsIgnoreNumberPattern() {
    return !0;
  }
  calculate(e) {
    return e.isArray() ? e.mapValue((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isString()) {
      const t = `${e.getValue()}`, r = xg(t);
      if (r) {
        let { v: n, z: s } = r;
        if (s && za(s))
          return n instanceof Date && (n = tn(n)), y.create(Am(+n));
      }
    }
    return g.create(h.VALUE);
  }
}
class i1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e) {
    const t = e.isReferenceObject();
    let r = e;
    if (t && (r = e.toArrayValueObject()), r.isArray()) {
      const s = r.getRowCount(), o = r.getColumnCount();
      if (s > 1 || o > 1)
        return g.create(h.VALUE);
      r = r.get(0, 0);
    }
    if (r.isError() || r.isNull() || r.isBoolean() || r.isString() || !t && r.isNumber() && r.getPattern() !== "")
      return r;
    const n = +r.getValue();
    return y.create(n, "yyyy-MM-dd hh:mm:ss AM/PM");
  }
}
class o1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 0);
  }
  calculate() {
    const e = pe(/* @__PURE__ */ new Date());
    return y.create(e, Xa);
  }
}
class u1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
    A(this, "_returnTypeMap", {
      1: [1, 2, 3, 4, 5, 6, 7],
      // Sunday = 1 ~ Saturday = 7
      2: [7, 1, 2, 3, 4, 5, 6],
      // Monday = 1 ~ Sunday = 7
      3: [6, 0, 1, 2, 3, 4, 5],
      // Monday = 0 ~ Sunday = 6
      11: [7, 1, 2, 3, 4, 5, 6],
      // Monday = 1 ~ Sunday = 7
      12: [6, 7, 1, 2, 3, 4, 5],
      // Tuesday = 1 ~ Monday = 7
      13: [5, 6, 7, 1, 2, 3, 4],
      // Wednesday = 1 ~ Tuesday = 7
      14: [4, 5, 6, 7, 1, 2, 3],
      // Thursday = 1 ~ Wednesday = 7
      15: [3, 4, 5, 6, 7, 1, 2],
      // Friday = 1 ~ Thursday = 7
      16: [2, 3, 4, 5, 6, 7, 1],
      // Saturday = 1 ~ Friday = 7
      17: [1, 2, 3, 4, 5, 6, 7]
      // Sunday = 1 ~ Saturday = 7
    });
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(1);
    if (e.isError())
      return e;
    if (r.isError())
      return r;
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, r, g.create(h.NA)), c = o.map((l, f, m) => {
      const d = u.get(f, m);
      return this._handleSingleObject(l, d);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
  _handleSingleObject(e, t) {
    let r = t;
    if (e.isError())
      return e;
    if (r.isError())
      return r;
    const n = H(e);
    if (typeof n != "number")
      return n;
    if (r.isString() && (r = r.convertToNumberObjectValue(), r.isError()))
      return r;
    const s = Math.floor(+r.getValue());
    if (!this._returnTypeMap[s])
      return g.create(h.NUM);
    const o = or(n), u = this._returnTypeMap[s][o];
    return y.create(u);
  }
}
class c1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
    A(this, "_returnTypeMap", {
      1: 0,
      2: 1,
      11: 1,
      12: 2,
      13: 3,
      14: 4,
      15: 5,
      16: 6,
      17: 0,
      21: 4
    });
  }
  calculate(e, t) {
    let r = e, n = t != null ? t : y.create(1);
    if (r.isArray()) {
      const u = r.getRowCount(), c = r.getColumnCount();
      if (u > 1 || c > 1)
        return g.create(h.VALUE);
      r = r.get(0, 0);
    }
    if (r.isError())
      return r;
    if (n.isArray()) {
      const u = n.getRowCount(), c = n.getColumnCount();
      if (u > 1 || c > 1)
        return g.create(h.VALUE);
      n = n.get(0, 0);
    }
    if (n.isError())
      return n;
    if (r.isBoolean())
      return g.create(h.VALUE);
    const s = H(r);
    if (typeof s != "number")
      return s;
    if (n.isBoolean())
      return g.create(h.VALUE);
    const o = Math.floor(+n.getValue());
    return Number.isNaN(o) ? g.create(h.VALUE) : o in this._returnTypeMap ? this._getResult(s, o) : g.create(h.NUM);
  }
  _getResult(e, t) {
    const r = ae(e), n = e > 0 ? r.getUTCFullYear() : 1900;
    let s = new Date(Date.UTC(n, 0, 1)), o = pe(s), u = or(o), c;
    if (t === 21)
      u < 1 ? c = o + 1 : u <= 4 ? c = o - (u - 1) : c = o + (11 - u), e < c && (s = new Date(Date.UTC(n - 1, 0, 1)), o = pe(s), u = or(o), u < 1 ? c = o + 1 : u <= 4 ? c = o - (u - 1) : c = o + (11 - u));
    else {
      const f = this._returnTypeMap[t];
      u < f ? c = o - (u + 7 - f) : c = o - (u - f);
    }
    const l = Math.ceil((e - c + 1) / 7);
    return y.create(l);
  }
}
class l1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    let n = e, s = t;
    if (n.isArray()) {
      const l = n.getRowCount(), f = n.getColumnCount();
      if (l > 1 || f > 1)
        return g.create(h.VALUE);
      n = n.get(0, 0);
    }
    if (n.isError())
      return n;
    if (s.isArray()) {
      const l = s.getRowCount(), f = s.getColumnCount();
      if (l > 1 || f > 1)
        return g.create(h.VALUE);
      s = s.get(0, 0);
    }
    if (s.isError())
      return s;
    if (r != null && r.isError())
      return r;
    if (n.isBoolean() || s.isBoolean())
      return g.create(h.VALUE);
    const o = H(n);
    if (typeof o != "number")
      return o;
    const u = +s.getValue();
    if (Number.isNaN(u))
      return g.create(h.VALUE);
    if (r)
      return this._getResultByHolidays(o, u, r);
    const c = Wn(o, u);
    return typeof c != "number" ? c : y.create(c);
  }
  _getResultByHolidays(e, t, r) {
    const n = [];
    if (r != null && r.isArray()) {
      const o = r.getRowCount(), u = r.getColumnCount();
      for (let c = 0; c < o; c++)
        for (let l = 0; l < u; l++) {
          const f = r.get(c, l);
          if (f.isBoolean())
            return g.create(h.VALUE);
          const m = H(f);
          if (typeof m != "number")
            return m;
          n.push(m);
        }
    } else {
      if (r.isBoolean())
        return g.create(h.VALUE);
      const o = H(r);
      if (typeof o != "number")
        return o;
      n.push(o);
    }
    const s = Wn(e, t, 1, n);
    return typeof s != "number" ? s : y.create(s);
  }
}
class f1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    return e.isError() ? e : t.isError() ? t : r != null && r.isError() ? r : n != null && n.isError() ? n : r != null && r.isArray() ? r.map((s) => this._handleSingleObject(e, t, s, n)) : this._handleSingleObject(e, t, r, n);
  }
  _handleSingleObject(e, t, r, n) {
    const s = r != null ? r : y.create(1), o = this._checkArrayError(e);
    if (o.isError())
      return o;
    const u = this._checkArrayError(t);
    if (u.isError())
      return u;
    if (o.isBoolean() || u.isBoolean())
      return g.create(h.VALUE);
    const c = H(e);
    if (typeof c != "number")
      return c;
    const l = +t.getValue();
    if (Number.isNaN(l))
      return g.create(h.VALUE);
    let f = s.getValue();
    if (s.isBoolean() && (f = +f), s.isString() && (!Qr(f) || f === "1111111"))
      return g.create(h.VALUE);
    if (!Qr(f))
      return g.create(h.NUM);
    if (n)
      return this._getResultByHolidays(c, l, f, n);
    const m = Wn(c, l, f);
    return typeof m != "number" ? m : y.create(m);
  }
  _checkArrayError(e) {
    let t = e;
    if (t.isArray()) {
      const r = t.getRowCount(), n = t.getColumnCount();
      if (r > 1 || n > 1)
        return g.create(h.VALUE);
      t = t.get(0, 0);
    }
    return t.isError(), t;
  }
  _getResultByHolidays(e, t, r, n) {
    const s = [];
    if (n != null && n.isArray()) {
      const u = n.getRowCount(), c = n.getColumnCount();
      for (let l = 0; l < u; l++)
        for (let f = 0; f < c; f++) {
          const m = n.get(l, f);
          if (m.isBoolean())
            return g.create(h.VALUE);
          const d = H(m);
          if (typeof d != "number")
            return d;
          s.push(d);
        }
    } else {
      if (n.isBoolean())
        return g.create(h.VALUE);
      const u = H(n);
      if (typeof u != "number")
        return u;
      s.push(u);
    }
    const o = Wn(e, t, r, s);
    return typeof o != "number" ? o : y.create(o);
  }
}
class m1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    let t;
    const r = e.getValue();
    if (e.isString()) {
      if (!Za(`${r}`))
        return g.create(h.VALUE);
      t = /* @__PURE__ */ new Date(`${r}`);
    } else {
      const o = +r;
      if (o < 0)
        return g.create(h.NUM);
      if (o === 0)
        return y.create(1900);
      t = ae(o);
    }
    const n = t.getUTCFullYear();
    return y.create(n);
  }
}
class h1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    let n = r != null ? r : y.create(0);
    const s = rr(e);
    if (s.isError())
      return s;
    const o = rr(t);
    if (o.isError())
      return o;
    if (n = rr(n), n.isError())
      return n;
    if (s.isBoolean() || o.isBoolean() || n.isBoolean())
      return g.create(h.VALUE);
    const u = H(s);
    if (typeof u != "number")
      return u;
    const c = H(o);
    if (typeof c != "number")
      return c;
    const l = Math.floor(+n.getValue());
    if (Number.isNaN(l))
      return g.create(h.VALUE);
    if (l < 0 || l > 4)
      return g.create(h.NUM);
    const { days: f, yearDays: m } = _e(u, c, l), d = f / m;
    return y.create(d);
  }
}
const g1 = [
  [kg, Ae.DATE],
  [$g, Ae.DATEDIF],
  [Yg, Ae.DATEVALUE],
  [Hg, Ae.DAY],
  [Gg, Ae.DAYS],
  [Wg, Ae.DAYS360],
  [Qg, Ae.EDATE],
  [qg, Ae.EOMONTH],
  [Xg, Ae.EPOCHTODATE],
  [Kg, Ae.HOUR],
  [Zg, Ae.ISOWEEKNUM],
  [zg, Ae.MINUTE],
  [Jg, Ae.MONTH],
  [e1, Ae.NETWORKDAYS],
  [t1, Ae.NETWORKDAYS_INTL],
  [r1, Ae.NOW],
  [n1, Ae.SECOND],
  [s1, Ae.TIME],
  [a1, Ae.TIMEVALUE],
  [i1, Ae.TO_DATE],
  [o1, Ae.TODAY],
  [u1, Ae.WEEKDAY],
  [c1, Ae.WEEKNUM],
  [l1, Ae.WORKDAY],
  [f1, Ae.WORKDAY_INTL],
  [m1, Ae.YEAR],
  [h1, Ae.YEARFRAC]
];
class d1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull() || t.isNull())
      return g.create(h.NA);
    const { isError: r, errorObject: n, variants: s } = W(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (Number.isNaN(c) || Number.isNaN(l))
      return g.create(h.VALUE);
    if (l < 0)
      return g.create(h.NUM);
    const f = Or.besseli(c, l);
    return Number.isNaN(f) || !Number.isFinite(f) ? g.create(h.NUM) : y.create(f);
  }
}
class C1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull() || t.isNull())
      return g.create(h.NA);
    const { isError: r, errorObject: n, variants: s } = W(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (Number.isNaN(c) || Number.isNaN(l))
      return g.create(h.VALUE);
    if (l < 0)
      return g.create(h.NUM);
    const f = Or.besselj(c, l);
    return Number.isNaN(f) || !Number.isFinite(f) ? g.create(h.NUM) : y.create(f);
  }
}
class _1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull() || t.isNull())
      return g.create(h.NA);
    const { isError: r, errorObject: n, variants: s } = W(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (Number.isNaN(c) || Number.isNaN(l))
      return g.create(h.VALUE);
    if (l < 0)
      return g.create(h.NUM);
    const f = Or.besselk(c, l);
    return Number.isNaN(f) || !Number.isFinite(f) ? g.create(h.NUM) : y.create(f);
  }
}
class A1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull() || t.isNull())
      return g.create(h.NA);
    const { isError: r, errorObject: n, variants: s } = W(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (Number.isNaN(c) || Number.isNaN(l))
      return g.create(h.VALUE);
    if (l < 0)
      return g.create(h.NUM);
    const f = Or.bessely(c, l);
    return Number.isNaN(f) || !Number.isFinite(f) ? g.create(h.NUM) : y.create(f);
  }
}
class E1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`;
    if (!Ua(o))
      return g.create(h.NUM);
    let u;
    return o.length === 10 && o.substring(0, 1) === "1" ? u = Number.parseInt(o.substring(1), 2) - 512 : u = Number.parseInt(o, 2), y.create(u);
  }
}
class R1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g.create(h.NA);
    let r = 0;
    if (t) {
      const { isError: f, errorObject: m, variants: d } = W(t);
      if (f)
        return m;
      const [_] = d;
      if (r = Math.floor(+_.getValue()), Number.isNaN(r))
        return g.create(h.VALUE);
      if (r < 0 || r > 10)
        return g.create(h.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = W(e);
    if (n)
      return s;
    const [u] = o, c = `${u.getValue()}`;
    if (!Ua(c))
      return g.create(h.NUM);
    let l;
    if (c.length === 10 && c.substring(0, 1) === "1")
      l = (1099511627264 + Number.parseInt(c.substring(1), 2)).toString(16);
    else if (l = Number.parseInt(c, 2).toString(16), t) {
      if (r < l.length)
        return g.create(h.NUM);
      l = "0".repeat(r - l.length) + l;
    }
    return U.create(l.toLocaleUpperCase());
  }
}
class b1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g.create(h.NA);
    let r = 0;
    if (t) {
      const { isError: f, errorObject: m, variants: d } = W(t);
      if (f)
        return m;
      const [_] = d;
      if (r = Math.floor(+_.getValue()), Number.isNaN(r))
        return g.create(h.VALUE);
      if (r < 0 || r > 10)
        return g.create(h.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = W(e);
    if (n)
      return s;
    const [u] = o, c = `${u.getValue()}`;
    if (!Ua(c))
      return g.create(h.NUM);
    let l;
    if (c.length === 10 && c.substring(0, 1) === "1")
      l = (1073741312 + Number.parseInt(c.substring(1), 2)).toString(8);
    else if (l = Number.parseInt(c, 2).toString(8), t) {
      if (r < l.length)
        return g.create(h.NUM);
      l = "0".repeat(r - l.length) + l;
    }
    return U.create(l);
  }
}
class y1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(h.NA)), o = O(r, n, t, g.create(h.NA)), u = s.map((c, l, f) => {
      let m = c;
      if (m.isString() && (m = m.convertToNumberObjectValue()), m.isError())
        return m;
      let d = o.get(l, f);
      if (d.isString() && (d = d.convertToNumberObjectValue()), d.isError())
        return d;
      const _ = +m.getValue(), C = +d.getValue();
      if (_ < 0 || C < 0 || Math.floor(_) !== _ || Math.floor(C) !== C || _ > 281474976710655 || C > 281474976710655)
        return g.create(h.NUM);
      const E = _ & C;
      return y.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
}
class p1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(h.NA)), o = O(r, n, t, g.create(h.NA)), u = s.map((c, l, f) => {
      let m = c;
      if (m.isString() && (m = m.convertToNumberObjectValue()), m.isError())
        return m;
      let d = o.get(l, f);
      if (d.isString() && (d = d.convertToNumberObjectValue()), d.isError())
        return d;
      const _ = +m.getValue();
      let C = +d.getValue();
      if (_ < 0 || Math.floor(_) !== _ || _ > 281474976710655 || Math.abs(C) > 53)
        return g.create(h.NUM);
      C = Math.trunc(C);
      const E = Number(C >= 0 ? BigInt(_) << BigInt(C) : BigInt(_) >> BigInt(-C));
      return E > 281474976710655 ? g.create(h.NUM) : y.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
}
class N1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(h.NA)), o = O(r, n, t, g.create(h.NA)), u = s.map((c, l, f) => {
      let m = c;
      if (m.isString() && (m = m.convertToNumberObjectValue()), m.isError())
        return m;
      let d = o.get(l, f);
      if (d.isString() && (d = d.convertToNumberObjectValue()), d.isError())
        return d;
      const _ = +m.getValue(), C = +d.getValue();
      if (_ < 0 || C < 0 || Math.floor(_) !== _ || Math.floor(C) !== C || _ > 281474976710655 || C > 281474976710655)
        return g.create(h.NUM);
      const E = Number(BigInt(_) | BigInt(C));
      return y.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
}
class V1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(h.NA)), o = O(r, n, t, g.create(h.NA)), u = s.map((c, l, f) => {
      let m = c;
      if (m.isString() && (m = m.convertToNumberObjectValue()), m.isError())
        return m;
      let d = o.get(l, f);
      if (d.isString() && (d = d.convertToNumberObjectValue()), d.isError())
        return d;
      const _ = +m.getValue();
      let C = +d.getValue();
      if (_ < 0 || Math.floor(_) !== _ || _ > 281474976710655 || Math.abs(C) > 53)
        return g.create(h.NUM);
      C = Math.trunc(C);
      const E = Number(C >= 0 ? BigInt(_) >> BigInt(C) : BigInt(_) << BigInt(-C));
      return E > 281474976710655 ? g.create(h.NUM) : y.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
}
class O1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(h.NA)), o = O(r, n, t, g.create(h.NA)), u = s.map((c, l, f) => {
      let m = c;
      if (m.isString() && (m = m.convertToNumberObjectValue()), m.isError())
        return m;
      let d = o.get(l, f);
      if (d.isString() && (d = d.convertToNumberObjectValue()), d.isError())
        return d;
      const _ = +m.getValue(), C = +d.getValue();
      if (_ < 0 || C < 0 || Math.floor(_) !== _ || Math.floor(C) !== C || _ > 281474976710655 || C > 281474976710655)
        return g.create(h.NUM);
      const E = _ ^ C;
      return y.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
}
x.prototype.cos = function() {
  const a = this.toNumber();
  return new x(Math.cos(a));
};
let me = class le {
  constructor(i) {
    A(this, "_inumber", "");
    A(this, "_realNum", 0);
    A(this, "_iNum", 0);
    A(this, "_suffix", "");
    A(this, "_isError", !1);
    if (`${i}`.trim() === "") {
      this._isError = !0;
      return;
    }
    this._inumber = i, this._getImReal(), this._getImAginary(), this._getImSuffix();
  }
  static getComplex(i, e, t) {
    const r = new x(i).toSignificantDigits(15).toNumber(), n = new x(e).toSignificantDigits(15).toNumber(), s = t === "" ? "i" : t;
    let o;
    if (r === 0 && n === 0)
      o = 0;
    else if (r === 0)
      o = n === 1 ? s : `${n}${s}`;
    else if (n === 0)
      o = r;
    else {
      const u = n > 0 ? "+" : "", c = n === 1 ? s : `${n}${s}`;
      o = `${r}${u}${c}`;
    }
    return o;
  }
  static createByComplexStr(i, e, t) {
    const r = le.getComplex(i, e, t);
    return new le(r);
  }
  _getImReal() {
    if (this._inumber === 0 || this._inumber === "0") {
      this._realNum = 0;
      return;
    }
    const i = `${this._inumber}`;
    if (["i", "+i", "1i", "+1i", "-i", "-1i", "j", "+j", "1j", "+1j", "-j", "-1j"].indexOf(i) >= 0) {
      this._realNum = 0;
      return;
    }
    let e = i.indexOf("+"), t = i.indexOf("-");
    e === 0 && (e = i.indexOf("+", 1)), t === 0 && (t = i.indexOf("-", 1));
    const r = i.substring(i.length - 1, i.length), n = r === "i" || r === "j";
    if (e >= 0 || t >= 0) {
      if (!n) {
        this._isError = !0;
        return;
      }
      e >= 0 ? Number.isNaN(+i.substring(0, e)) || Number.isNaN(+i.substring(e + 1, i.length - 1)) ? this._isError = !0 : this._realNum = +i.substring(0, e) : Number.isNaN(+i.substring(0, t)) || Number.isNaN(+i.substring(t + 1, i.length - 1)) ? this._isError = !0 : this._realNum = +i.substring(0, t);
    } else
      n ? Number.isNaN(+i.substring(0, i.length - 1)) ? this._isError = !0 : this._realNum = 0 : Number.isNaN(+i) ? this._isError = !0 : this._realNum = +i;
  }
  _getImAginary() {
    if (this._isError)
      return;
    if (this._inumber === 0 || this._inumber === "0") {
      this._iNum = 0;
      return;
    }
    let i = `${this._inumber}`;
    if (["i", "j"].indexOf(i) >= 0) {
      this._iNum = 1;
      return;
    }
    i = i.replace("+i", "+1i").replace("-i", "-1i").replace("+j", "+1j").replace("-j", "-1j");
    let e = i.indexOf("+"), t = i.indexOf("-");
    e === 0 && (e = i.indexOf("+", 1)), t === 0 && (t = i.indexOf("-", 1));
    const r = i.substring(i.length - 1, i.length), n = r === "i" || r === "j";
    if (e >= 0 || t >= 0) {
      if (!n) {
        this._isError = !0;
        return;
      }
      e >= 0 ? Number.isNaN(+i.substring(0, e)) || Number.isNaN(+i.substring(e + 1, i.length - 1)) ? this._isError = !0 : this._iNum = +i.substring(e + 1, i.length - 1) : Number.isNaN(+i.substring(0, t)) || Number.isNaN(+i.substring(t + 1, i.length - 1)) ? this._isError = !0 : this._iNum = -+i.substring(t + 1, i.length - 1);
    } else
      n ? Number.isNaN(+i.substring(0, i.length - 1)) ? this._isError = !0 : this._iNum = +i.substring(0, i.length - 1) : Number.isNaN(+i) ? this._isError = !0 : this._iNum = 0;
  }
  _getImSuffix() {
    const i = `${this._inumber}`, e = i.substring(i.length - 1);
    this._suffix = e === "i" || e === "j" ? e : "";
  }
  getRealNum() {
    return this._realNum;
  }
  getINum() {
    return this._iNum;
  }
  getSuffix() {
    return this._suffix;
  }
  isError() {
    return this._isError;
  }
  toString() {
    return le.getComplex(this._realNum, this._iNum, this._suffix);
  }
  isDifferentSuffixes(i) {
    const e = i.getSuffix();
    return this._suffix === "" || e === "" ? !1 : this._suffix !== e;
  }
  Abs() {
    return x.sqrt(x.pow(this._realNum, 2).add(x.pow(this._iNum, 2))).toSignificantDigits(16).toNumber();
  }
  Argument() {
    const i = x.sqrt(x.pow(this._realNum, 2).add(x.pow(this._iNum, 2)));
    let e = x.acos(new x(this._realNum).div(i)).toSignificantDigits(16).toNumber();
    return this._iNum < 0 && (e = -e), e;
  }
  Conjugate() {
    return le.getComplex(this._realNum, -this._iNum, this._suffix);
  }
  Cos() {
    if (this._iNum) {
      const i = x.cos(this._realNum).mul(x.cosh(this._iNum)).toNumber(), e = x.sin(this._realNum).mul(x.sinh(this._iNum)).negated().toNumber();
      return le.getComplex(i, e, this._suffix);
    } else {
      const i = x.cos(this._realNum).toNumber();
      return le.getComplex(i, this._iNum, this._suffix);
    }
  }
  Cosh() {
    if (!Number.isFinite(Math.sinh(this._realNum)) || !Number.isFinite(Math.cosh(this._realNum)))
      return this._isError = !0, "";
    if (this._iNum) {
      const i = x.cosh(this._realNum).mul(x.cos(this._iNum)).toNumber(), e = x.sinh(this._realNum).mul(x.sin(this._iNum)).toNumber();
      return le.getComplex(i, e, this._suffix);
    } else {
      const i = x.cosh(this._realNum).toNumber();
      return le.getComplex(i, this._iNum, this._suffix);
    }
  }
  Cot() {
    if (this._iNum) {
      const i = x.cosh(this._iNum * 2).sub(x.cos(this._realNum * 2)), e = x.sin(this._realNum * 2).div(i).toNumber(), t = x.sinh(this._iNum * 2).div(i).negated().toNumber();
      return le.getComplex(e, t, this._suffix);
    } else {
      const i = new x(1).div(x.tan(this._realNum)).toNumber();
      return le.getComplex(i, this._iNum, this._suffix);
    }
  }
  Coth() {
    if (!Number.isFinite(Math.sinh(this._realNum)) || !Number.isFinite(Math.cosh(this._realNum)))
      return this._isError = !0, "";
    if (this._iNum) {
      const i = x.cosh(this._realNum * 2).sub(x.cos(this._iNum * 2)), e = x.sinh(this._realNum * 2).div(i).toNumber(), t = x.sin(this._iNum * 2).div(i).negated().toNumber();
      return le.getComplex(e, t, this._suffix);
    } else {
      const i = new x(1).div(x.tanh(this._realNum)).toNumber();
      return le.getComplex(i, this._iNum, this._suffix);
    }
  }
  Csc() {
    if (this._iNum) {
      const i = x.cosh(this._iNum * 2).sub(x.cos(this._realNum * 2)), e = x.sin(this._realNum).mul(x.cosh(this._iNum)).mul(2).div(i).toNumber(), t = x.cos(this._realNum).mul(x.sinh(this._iNum)).mul(-2).div(i).toNumber();
      return le.getComplex(e, t, this._suffix);
    } else {
      const i = new x(1).div(x.sin(this._realNum)).toNumber();
      return le.getComplex(i, this._iNum, this._suffix);
    }
  }
  Csch() {
    if (!Number.isFinite(Math.sinh(this._realNum)) || !Number.isFinite(Math.cosh(this._realNum)))
      return le.getComplex(0, 0, this._suffix);
    if (this._iNum) {
      const i = x.cosh(this._realNum * 2).sub(x.cos(this._iNum * 2)), e = x.sinh(this._realNum).mul(x.cos(this._iNum)).mul(2).div(i).toNumber(), t = x.cosh(this._realNum).mul(x.sin(this._iNum)).mul(-2).div(i).toNumber();
      return le.getComplex(e, t, this._suffix);
    } else {
      const i = new x(1).div(x.sinh(this._realNum)).toNumber();
      return le.getComplex(i, this._iNum, this._suffix);
    }
  }
  Div(i) {
    const e = new x(this._realNum), t = new x(this._iNum), r = new x(i.getRealNum()), n = new x(i.getINum()), s = r.mul(r).add(n.mul(n)), o = e.mul(r).add(t.mul(n)).div(s).toNumber(), u = t.mul(r).sub(e.mul(n)).div(s).toNumber(), c = this._suffix === "" ? i.getSuffix() : this._suffix;
    return le.getComplex(o, u, c);
  }
  Exp() {
    if (!Number.isFinite(Math.exp(this._realNum)))
      return this._isError = !0, "";
    const i = x.exp(this._realNum).mul(x.cos(this._iNum)).toNumber(), e = x.exp(this._realNum).mul(x.sin(this._iNum)).toNumber();
    return le.getComplex(i, e, this._suffix);
  }
  Ln() {
    const i = x.sqrt(x.pow(this._realNum, 2).add(x.pow(this._iNum, 2))), e = x.ln(i).toNumber(), t = x.acos(new x(this._realNum).div(i)).toNumber();
    return le.getComplex(e, t, this._suffix);
  }
  Log(i) {
    const e = x.sqrt(x.pow(this._realNum, 2).add(x.pow(this._iNum, 2))), t = x.ln(e);
    let r = x.acos(new x(this._realNum).div(e));
    this._iNum < 0 && (r = r.negated());
    const n = x.ln(i), s = new x(0), o = n.mul(n).add(s.mul(s));
    if (o.eq(0))
      return this._isError = !0, "";
    const u = t.mul(n).add(r.mul(s)).div(o).toNumber(), c = r.mul(n).sub(t.mul(s)).div(o).toNumber();
    return le.getComplex(u, c, this._suffix);
  }
  Power(i) {
    if (this._realNum === 0 && this._iNum === 0)
      return i > 0 ? le.getComplex(this._realNum, this._iNum, this._suffix) : (this._isError = !0, "");
    let e = x.sqrt(x.pow(this._realNum, 2).add(x.pow(this._iNum, 2))), t = x.acos(new x(this._realNum).div(e));
    this._iNum < 0 && (t = t.negated()), e = x.pow(e, i), t = t.mul(i);
    const r = x.cos(t).mul(e).toNumber(), n = x.sin(t).mul(e).toNumber();
    return !Number.isFinite(r) || !Number.isFinite(n) ? (this._isError = !0, "") : le.getComplex(r, n, this._suffix);
  }
  Product(i) {
    const e = new x(this._realNum), t = new x(this._iNum), r = new x(i.getRealNum()), n = new x(i.getINum()), s = e.mul(r).sub(t.mul(n)).toNumber(), o = e.mul(n).add(t.mul(r)).toNumber(), u = this._suffix === "" ? i.getSuffix() : this._suffix;
    return le.getComplex(s, o, u);
  }
  Sec() {
    if (this._iNum) {
      const i = x.cosh(this._iNum * 2).add(x.cos(this._realNum * 2)), e = x.cos(this._realNum).mul(x.cosh(this._iNum)).mul(2).div(i).toNumber(), t = x.sin(this._realNum).mul(x.sinh(this._iNum)).mul(2).div(i).toNumber();
      return le.getComplex(e, t, this._suffix);
    } else {
      const i = new x(1).div(x.cos(this._realNum)).toNumber();
      return le.getComplex(i, this._iNum, this._suffix);
    }
  }
  Sech() {
    if (!Number.isFinite(Math.sinh(this._realNum * 2)) || !Number.isFinite(Math.cosh(this._realNum * 2)))
      return le.getComplex(0, 0, this._suffix);
    if (this._iNum) {
      const i = x.cosh(this._realNum * 2).add(x.cos(this._iNum * 2)), e = x.cosh(this._realNum).mul(x.cos(this._iNum)).mul(2).div(i).toNumber(), t = x.sinh(this._realNum).mul(x.sin(this._iNum)).mul(-2).div(i).toNumber();
      return le.getComplex(e, t, this._suffix);
    } else {
      const i = new x(1).div(x.cosh(this._realNum)).toNumber();
      return le.getComplex(i, this._iNum, this._suffix);
    }
  }
  Sin() {
    if (this._iNum) {
      const i = x.sin(this._realNum).mul(x.cosh(this._iNum)).toNumber(), e = x.cos(this._realNum).mul(x.sinh(this._iNum)).toNumber();
      return le.getComplex(i, e, this._suffix);
    } else {
      const i = x.sin(this._realNum).toNumber();
      return le.getComplex(i, this._iNum, this._suffix);
    }
  }
  Sinh() {
    if (!Number.isFinite(Math.sinh(this._realNum)) || !Number.isFinite(Math.cosh(this._realNum)))
      return this._isError = !0, "";
    if (this._iNum) {
      const i = x.sinh(this._realNum).mul(x.cos(this._iNum)).toNumber(), e = x.cosh(this._realNum).mul(x.sin(this._iNum)).toNumber();
      return le.getComplex(i, e, this._suffix);
    } else {
      const i = x.sinh(this._realNum).toNumber();
      return le.getComplex(i, this._iNum, this._suffix);
    }
  }
  Sqrt() {
    const i = x.sqrt(x.pow(this._realNum, 2).add(x.pow(this._iNum, 2))), e = x.sqrt(i);
    let t = x.acos(new x(this._realNum).div(i));
    this._iNum < 0 && (t = t.negated());
    const r = e.mul(x.cos(t.div(2).toNumber())).toNumber(), n = e.mul(x.sin(t.div(2))).toNumber();
    return le.getComplex(r, n, this._suffix);
  }
  Sub(i) {
    const e = new x(this._realNum), t = new x(this._iNum), r = new x(i.getRealNum()), n = new x(i.getINum()), s = e.sub(r).toNumber(), o = t.sub(n).toNumber(), u = this._suffix === "" ? i.getSuffix() : this._suffix;
    return le.getComplex(s, o, u);
  }
  Sum(i) {
    const e = new x(this._realNum), t = new x(this._iNum), r = new x(i.getRealNum()), n = new x(i.getINum()), s = e.add(r).toNumber(), o = t.add(n).toNumber(), u = this._suffix === "" ? i.getSuffix() : this._suffix;
    return le.getComplex(s, o, u);
  }
  Tan() {
    if (this._iNum) {
      const i = x.cos(this._realNum * 2).add(x.cosh(this._iNum * 2)), e = x.sin(this._realNum * 2).div(i).toNumber(), t = x.sinh(this._iNum * 2).div(i).toNumber();
      return le.getComplex(e, t, this._suffix);
    } else {
      const i = x.tan(this._realNum).toNumber();
      return le.getComplex(i, this._iNum, this._suffix);
    }
  }
  Tanh() {
    if (!Number.isFinite(Math.sinh(this._realNum)) || !Number.isFinite(Math.cosh(this._realNum)))
      return this._isError = !0, "";
    if (this._iNum) {
      const i = x.cosh(this._realNum * 2).add(x.cos(this._iNum * 2)), e = x.sinh(this._realNum * 2).div(i).toNumber(), t = x.sin(this._iNum * 2).div(i).toNumber();
      return le.getComplex(e, t, this._suffix);
    } else {
      const i = x.tanh(this._realNum).toNumber();
      return le.getComplex(i, this._iNum, this._suffix);
    }
  }
};
class S1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : U.create("i"), { isError: s, errorObject: o, variants: u } = W(e, t, n);
    if (s)
      return o;
    const [c, l, f] = u, m = +c.getValue(), d = +l.getValue(), _ = `${f.getValue()}`;
    if (Number.isNaN(m) || Number.isNaN(d) || _ !== "i" && _ !== "j")
      return g.create(h.VALUE);
    const C = me.getComplex(m, d, _);
    return typeof C == "number" ? y.create(C) : U.create(C);
  }
}
class M1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
    // List of units supported by CONVERT and units defined by the International System of Units
    // [Name, Symbol, Alternate symbols, Quantity, ISU, CONVERT, Conversion ratio]
    A(this, "_units", [
      ["a.u. of action", "?", null, "action", !1, !1, 105457168181818e-48],
      ["a.u. of charge", "e", null, "electric_charge", !1, !1, 160217653141414e-33],
      ["a.u. of energy", "Eh", null, "energy", !1, !1, 435974417757576e-32],
      ["a.u. of length", "a?", null, "length", !1, !1, 529177210818182e-25],
      ["a.u. of mass", "m?", null, "mass", !1, !1, 910938261616162e-45],
      ["a.u. of time", "?/Eh", null, "time", !1, !1, 241888432650516e-31],
      ["admiralty knot", "admkn", null, "speed", !1, !0, 0.514773333],
      ["ampere", "A", null, "electric_current", !0, !1, 1],
      ["ampere per meter", "A/m", null, "magnetic_field_intensity", !0, !1, 1],
      ["ångström", "Å", ["ang"], "length", !1, !0, 1e-10],
      ["are", "ar", null, "area", !1, !0, 100],
      ["astronomical unit", "ua", null, "length", !1, !1, 149597870691667e-25],
      ["bar", "bar", null, "pressure", !1, !1, 1e5],
      ["barn", "b", null, "area", !1, !1, 1e-28],
      ["becquerel", "Bq", null, "radioactivity", !0, !1, 1],
      ["bit", "bit", ["b"], "information", !1, !0, 1],
      ["btu", "BTU", ["btu"], "energy", !1, !0, 1055.05585262],
      ["byte", "byte", null, "information", !1, !0, 8],
      ["candela", "cd", null, "luminous_intensity", !0, !1, 1],
      ["candela per square metre", "cd/m?", null, "luminance", !0, !1, 1],
      ["centigrade", "C", ["cel"], "temperature", !0, !1, 1],
      ["cubic ångström", "ang3", ["ang^3"], "volume", !1, !0, 1e-30],
      ["cubic foot", "ft3", ["ft^3"], "volume", !1, !0, 0.028316846592],
      ["cubic inch", "in3", ["in^3"], "volume", !1, !0, 16387064e-12],
      ["cubic light-year", "ly3", ["ly^3"], "volume", !1, !0, 846786664623715e-61],
      ["cubic metre", "m3", ["m^3"], "volume", !0, !0, 1],
      ["cubic mile", "mi3", ["mi^3"], "volume", !1, !0, 416818182544058e-5],
      ["cubic nautical mile", "Nmi3", ["Nmi^3"], "volume", !1, !0, 6352182208],
      ["cubic Pica", "Pica3", ["Picapt3", "Pica^3", "Picapt^3"], "volume", !1, !0, 758660370370369e-22],
      ["cubic yard", "yd3", ["yd^3"], "volume", !1, !0, 0.764554857984],
      ["cup", "cup", null, "volume", !1, !0, 2365882365e-13],
      ["dalton", "Da", ["u"], "mass", !1, !1, 166053886282828e-41],
      ["day", "d", ["day"], "time", !1, !0, 86400],
      ["degree", "°", null, "angle", !1, !1, 0.0174532925199433],
      ["dyne", "dyn", ["dy"], "force", !1, !0, 1e-5],
      ["electronvolt", "eV", ["ev"], "energy", !1, !0, 1.60217656514141],
      ["ell", "ell", null, "length", !1, !0, 1.143],
      ["erg", "erg", ["e"], "energy", !1, !0, 1e-7],
      ["fahrenheit", "F", ["fah"], "temperature", !0, !1, 1],
      ["fluid ounce", "oz", null, "volume", !1, !0, 295735295625e-16],
      ["foot", "ft", null, "length", !1, !0, 0.3048],
      ["foot-pound", "flb", null, "energy", !1, !0, 1.3558179483314],
      ["gal", "Gal", null, "acceleration", !1, !1, 0.01],
      ["gallon", "gal", null, "volume", !1, !0, 0.003785411784],
      ["gauss", "G", ["ga"], "magnetic_flux_density", !1, !0, 1],
      ["grain", "grain", null, "mass", !1, !0, 647989e-10],
      ["gram", "g", null, "mass", !1, !0, 1e-3],
      ["gray", "Gy", null, "absorbed_dose", !0, !1, 1],
      ["gross registered ton", "GRT", ["regton"], "volume", !1, !0, 2.8316846592],
      ["hectare", "ha", null, "area", !1, !0, 1e4],
      ["henry", "H", null, "inductance", !0, !1, 1],
      ["hertz", "Hz", null, "frequency", !0, !1, 1],
      ["horsepower", "HP", ["h"], "power", !1, !0, 745.69987158227],
      ["horsepower-hour", "HPh", ["hh", "hph"], "energy", !1, !0, 2684519538e-3],
      ["hour", "h", ["hr"], "time", !1, !0, 3600],
      ["imperial gallon (U.K.)", "uk_gal", null, "volume", !1, !0, 454609e-8],
      ["imperial hundredweight", "lcwt", ["uk_cwt", "hweight"], "mass", !1, !0, 50.802345],
      ["imperial quart (U.K)", "uk_qt", null, "volume", !1, !0, 0.0011365225],
      ["imperial ton", "brton", ["uk_ton", "LTON"], "mass", !1, !0, 1016.046909],
      ["inch", "in", null, "length", !1, !0, 0.0254],
      ["international acre", "uk_acre", null, "area", !1, !0, 4046.8564224],
      ["IT calorie", "cal", null, "energy", !1, !0, 4.1868],
      ["joule", "J", null, "energy", !0, !0, 1],
      ["katal", "kat", null, "catalytic_activity", !0, !1, 1],
      ["kelvin", "K", ["kel"], "temperature", !0, !0, 1],
      ["kilogram", "kg", null, "mass", !0, !0, 1],
      ["knot", "kn", null, "speed", !1, !0, 0.514444444444444],
      ["light-year", "ly", null, "length", !1, !0, 9460730472580800],
      ["litre", "L", ["l", "lt"], "volume", !1, !0, 1e-3],
      ["lumen", "lm", null, "luminous_flux", !0, !1, 1],
      ["lux", "lx", null, "illuminance", !0, !1, 1],
      ["maxwell", "Mx", null, "magnetic_flux", !1, !1, 1e-18],
      ["measurement ton", "MTON", null, "volume", !1, !0, 1.13267386368],
      ["meter per hour", "m/h", ["m/hr"], "speed", !1, !0, 27777777777778e-17],
      ["meter per second", "m/s", ["m/sec"], "speed", !0, !0, 1],
      ["meter per second squared", "m?s??", null, "acceleration", !0, !1, 1],
      ["parsec", "pc", ["parsec"], "length", !1, !0, 30856775814671900],
      ["meter squared per second", "m?/s", null, "kinematic_viscosity", !0, !1, 1],
      ["metre", "m", null, "length", !0, !0, 1],
      ["miles per hour", "mph", null, "speed", !1, !0, 0.44704],
      ["millimetre of mercury", "mmHg", null, "pressure", !1, !1, 133.322],
      ["minute", "?", null, "angle", !1, !1, 290888208665722e-18],
      ["minute", "min", ["mn"], "time", !1, !0, 60],
      ["modern teaspoon", "tspm", null, "volume", !1, !0, 5e-6],
      ["mole", "mol", null, "amount_of_substance", !0, !1, 1],
      ["morgen", "Morgen", null, "area", !1, !0, 2500],
      ["n.u. of action", "?", null, "action", !1, !1, 105457168181818e-48],
      ["n.u. of mass", "m?", null, "mass", !1, !1, 910938261616162e-45],
      ["n.u. of speed", "c?", null, "speed", !1, !1, 299792458],
      ["n.u. of time", "?/(me?c??)", null, "time", !1, !1, 128808866778687e-35],
      ["nautical mile", "M", ["Nmi"], "length", !1, !0, 1852],
      ["newton", "N", null, "force", !0, !0, 1],
      ["œrsted", "Oe ", null, "magnetic_field_intensity", !1, !1, 79.5774715459477],
      ["ohm", "Ω", null, "electric_resistance", !0, !1, 1],
      ["ounce mass", "ozm", null, "mass", !1, !0, 0.028349523125],
      ["pascal", "Pa", null, "pressure", !0, !1, 1],
      ["pascal second", "Pa?s", null, "dynamic_viscosity", !0, !1, 1],
      ["pferdestärke", "PS", null, "power", !1, !0, 735.49875],
      ["phot", "ph", null, "illuminance", !1, !1, 1e-4],
      ["pica (1/6 inch)", "pica", null, "length", !1, !0, 35277777777778e-17],
      ["pica (1/72 inch)", "Pica", ["Picapt"], "length", !1, !0, 0.00423333333333333],
      ["poise", "P", null, "dynamic_viscosity", !1, !1, 0.1],
      ["pond", "pond", null, "force", !1, !0, 980665e-8],
      ["pound force", "lbf", null, "force", !1, !0, 4.4482216152605],
      ["pound mass", "lbm", null, "mass", !1, !0, 0.45359237],
      ["quart", "qt", null, "volume", !1, !0, 946352946e-12],
      ["radian", "rad", null, "angle", !0, !1, 1],
      ["rankine", "Rank", null, "temperature", !1, !0, 1],
      ["reaumur", "Reau", null, "temperature", !1, !0, 1],
      ["second", "?", null, "angle", !1, !1, 484813681109536e-20],
      ["second", "s", ["sec"], "time", !0, !0, 1],
      ["short hundredweight", "cwt", ["shweight"], "mass", !1, !0, 45.359237],
      ["siemens", "S", null, "electrical_conductance", !0, !1, 1],
      ["sievert", "Sv", null, "equivalent_dose", !0, !1, 1],
      ["slug", "sg", null, "mass", !1, !0, 14.59390294],
      ["square ångström", "ang2", ["ang^2"], "area", !1, !0, 1e-20],
      ["square foot", "ft2", ["ft^2"], "area", !1, !0, 0.09290304],
      ["square inch", "in2", ["in^2"], "area", !1, !0, 64516e-8],
      ["square light-year", "ly2", ["ly^2"], "area", !1, !0, 895054210748189e17],
      ["square meter", "m?", null, "area", !0, !0, 1],
      ["square mile", "mi2", ["mi^2"], "area", !1, !0, 2589988110336e-6],
      ["square nautical mile", "Nmi2", ["Nmi^2"], "area", !1, !0, 3429904],
      ["square Pica", "Pica2", ["Picapt2", "Pica^2", "Picapt^2"], "area", !1, !0, 1792111111111e-17],
      ["square yard", "yd2", ["yd^2"], "area", !1, !0, 0.83612736],
      ["statute mile", "mi", null, "length", !1, !0, 1609.344],
      ["steradian", "sr", null, "solid_angle", !0, !1, 1],
      ["stilb", "sb", null, "luminance", !1, !1, 1e-4],
      ["stokes", "St", null, "kinematic_viscosity", !1, !1, 1e-4],
      ["stone", "stone", null, "mass", !1, !0, 6.35029318],
      ["tablespoon", "tbs", null, "volume", !1, !0, 147868e-10],
      ["teaspoon", "tsp", null, "volume", !1, !0, 492892e-11],
      ["tesla", "T", null, "magnetic_flux_density", !0, !0, 1],
      ["thermodynamic calorie", "c", null, "energy", !1, !0, 4.184],
      ["ton", "ton", null, "mass", !1, !0, 907.18474],
      ["tonne", "t", null, "mass", !1, !1, 1e3],
      ["U.K. pint", "uk_pt", null, "volume", !1, !0, 56826125e-11],
      ["U.S. bushel", "bushel", null, "volume", !1, !0, 0.03523907],
      ["U.S. oil barrel", "barrel", null, "volume", !1, !0, 0.158987295],
      ["U.S. pint", "pt", ["us_pt"], "volume", !1, !0, 473176473e-12],
      ["U.S. survey mile", "survey_mi", null, "length", !1, !0, 1609.347219],
      ["U.S. survey/statute acre", "us_acre", null, "area", !1, !0, 4046.87261],
      ["volt", "V", null, "voltage", !0, !1, 1],
      ["watt", "W", null, "power", !0, !0, 1],
      ["watt-hour", "Wh", ["wh"], "energy", !1, !0, 3600],
      ["weber", "Wb", null, "magnetic_flux", !0, !1, 1],
      ["yard", "yd", null, "length", !1, !0, 0.9144],
      ["year", "yr", null, "time", !1, !0, 31557600]
    ]);
    // Binary prefixes
    // [Name, Prefix power of 2 value, Previx value, Abbreviation, Derived from]
    A(this, "_binaryPrefixes", {
      Yi: ["yobi", 80, 12089258196146292e8, "Yi", "yotta"],
      Zi: ["zebi", 70, 11805916207174113e5, "Zi", "zetta"],
      Ei: ["exbi", 60, 1152921504606847e3, "Ei", "exa"],
      Pi: ["pebi", 50, 1125899906842624, "Pi", "peta"],
      Ti: ["tebi", 40, 1099511627776, "Ti", "tera"],
      Gi: ["gibi", 30, 1073741824, "Gi", "giga"],
      Mi: ["mebi", 20, 1048576, "Mi", "mega"],
      ki: ["kibi", 10, 1024, "ki", "kilo"]
    });
    // Unit prefixes
    // [Name, Multiplier, Abbreviation]
    A(this, "_unitPrefixes", {
      Y: ["yotta", 1e24, "Y"],
      Z: ["zetta", 1e21, "Z"],
      E: ["exa", 1e18, "E"],
      P: ["peta", 1e15, "P"],
      T: ["tera", 1e12, "T"],
      G: ["giga", 1e9, "G"],
      M: ["mega", 1e6, "M"],
      k: ["kilo", 1e3, "k"],
      h: ["hecto", 100, "h"],
      e: ["dekao", 10, "e"],
      d: ["deci", 0.1, "d"],
      c: ["centi", 0.01, "c"],
      m: ["milli", 1e-3, "m"],
      u: ["micro", 1e-6, "u"],
      n: ["nano", 1e-9, "n"],
      p: ["pico", 1e-12, "p"],
      f: ["femto", 1e-15, "f"],
      a: ["atto", 1e-18, "a"],
      z: ["zepto", 1e-21, "z"],
      y: ["yocto", 1e-24, "y"]
    });
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = W(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), m = `${c.getValue()}`, d = `${l.getValue()}`;
    if (Number.isNaN(f))
      return g.create(h.VALUE);
    let _, C = 1, E, R = 1;
    const { _from: b, _to: p } = this._lookupFromAndToUnits(m, d);
    if (_ = b, E = p, _ === null) {
      const { _from: S, _fromMultiplier: M } = this._lookupFromPrefix(m);
      _ = S, C = M;
    }
    if (E === null) {
      const { _to: S, _toMultiplier: M } = this._lookupToPrefix(d);
      E = S, R = M;
    }
    if (_ === null || E === null || _[3] !== E[3])
      return g.create(h.NA);
    let V;
    return _[3] === "temperature" ? (V = this._getTemperatureConversion(f, _[1], E[1]), V = +V.toFixed(2)) : V = f * _[6] * C / (E[6] * R), y.create(V);
  }
  _lookupFromAndToUnits(e, t) {
    let r = null, n = null, s;
    for (let o = 0; o < this._units.length; o++)
      s = this._units[o][2] === null ? [] : this._units[o][2], (this._units[o][1] === e || s.indexOf(e) >= 0) && (r = this._units[o]), (this._units[o][1] === t || s.indexOf(t) >= 0) && (n = this._units[o]);
    return {
      _from: r,
      _to: n
    };
  }
  _lookupFromPrefix(e) {
    let t = null, r = 1, n = e, s;
    const o = this._binaryPrefixes[e.substring(0, 2)];
    let u = this._unitPrefixes[e.substring(0, 1)];
    e.substring(0, 2) === "da" && (u = ["dekao", 10, "da"]), o ? (r = o[2], n = e.substring(2)) : u && (r = u[1], n = e.substring(u[2].length));
    for (let c = 0; c < this._units.length; c++)
      s = this._units[c][2] === null ? [] : this._units[c][2], (this._units[c][1] === n || s.indexOf(n) >= 0) && (t = this._units[c]);
    return {
      _from: t,
      _fromMultiplier: r
    };
  }
  _lookupToPrefix(e) {
    let t = null, r = 1, n = e, s;
    const o = this._binaryPrefixes[e.substring(0, 2)];
    let u = this._unitPrefixes[e.substring(0, 1)];
    e.substring(0, 2) === "da" && (u = ["dekao", 10, "da"]), o ? (r = o[2], n = e.substring(2)) : u && (r = u[1], n = e.substring(u[2].length));
    for (let c = 0; c < this._units.length; c++)
      s = this._units[c][2] === null ? [] : this._units[c][2], (this._units[c][1] === n || s.indexOf(n) >= 0) && (t = this._units[c]);
    return {
      _to: t,
      _toMultiplier: r
    };
  }
  _getTemperatureConversion(e, t, r) {
    switch (t) {
      case "C":
        return this._centigradeConversion(e, r);
      case "F":
        return this._fahrenheitConversion(e, r);
      case "K":
        return this._kelvinConversion(e, r);
      case "Rank":
        return this._rankineConversion(e, r);
      case "Reau":
        return this._reaumurConversion(e, r);
      default:
        return e;
    }
  }
  _centigradeConversion(e, t) {
    switch (t) {
      case "F":
        return e * 9 / 5 + 32;
      case "K":
        return e + 273.15;
      case "Rank":
        return (e + 273.15) * 9 / 5;
      case "Reau":
        return e * 4 / 5;
      default:
        return e;
    }
  }
  _fahrenheitConversion(e, t) {
    switch (t) {
      case "C":
        return (e - 32) * 5 / 9;
      case "K":
        return (e - 32) * 5 / 9 + 273.15;
      case "Rank":
        return e + 459.67;
      case "Reau":
        return (e - 32) * 4 / 9;
      default:
        return e;
    }
  }
  _kelvinConversion(e, t) {
    switch (t) {
      case "C":
        return e - 273.15;
      case "F":
        return (e - 273.15) * 9 / 5 + 32;
      case "Rank":
        return e * 9 / 5;
      case "Reau":
        return (e - 273.15) * 4 / 5;
      default:
        return e;
    }
  }
  _rankineConversion(e, t) {
    switch (t) {
      case "C":
        return (e - 491.67) * 5 / 9;
      case "F":
        return e - 459.67;
      case "K":
        return e * 5 / 9;
      case "Reau":
        return (e - 491.67) * 4 / 9;
      default:
        return e;
    }
  }
  _reaumurConversion(e, t) {
    switch (t) {
      case "C":
        return e * 5 / 4;
      case "F":
        return e * 9 / 4 + 32;
      case "K":
        return e * 5 / 4 + 273.15;
      case "Rank":
        return e * 9 / 4 + 491.67;
      default:
        return e;
    }
  }
}
class D1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g.create(h.NA);
    let r = 0;
    if (t) {
      const { isError: f, errorObject: m, variants: d } = W(t);
      if (f)
        return m;
      const [_] = d;
      if (r = Math.floor(+_.getValue()), Number.isNaN(r))
        return g.create(h.VALUE);
      if (r < 0 || r > 10)
        return g.create(h.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = W(e);
    if (n)
      return s;
    const [u] = o, c = Math.trunc(+u.getValue());
    if (Number.isNaN(c))
      return g.create(h.VALUE);
    if (!/^-?[0-9]{1,3}$/.test(`${c}`) || c < -512 || c > 511)
      return g.create(h.NUM);
    let l;
    if (c < 0) {
      const f = (512 + c).toString(2);
      l = `1${"0".repeat(9 - f.length)}${f}`;
    } else if (l = Number.parseInt(`${c}`, 10).toString(2), t) {
      if (r < l.length)
        return g.create(h.NUM);
      l = "0".repeat(r - l.length) + l;
    }
    return U.create(l);
  }
}
class w1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g.create(h.NA);
    let r = 0;
    if (t) {
      const { isError: f, errorObject: m, variants: d } = W(t);
      if (f)
        return m;
      const [_] = d;
      if (r = Math.floor(+_.getValue()), Number.isNaN(r))
        return g.create(h.VALUE);
      if (r < 0 || r > 10)
        return g.create(h.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = W(e);
    if (n)
      return s;
    const [u] = o, c = Math.trunc(+u.getValue());
    if (Number.isNaN(c))
      return g.create(h.VALUE);
    if (!/^-?[0-9]{1,12}$/.test(`${c}`) || c < -549755813888 || c > 549755813887)
      return g.create(h.NUM);
    let l;
    if (c < 0)
      l = (1099511627776 + c).toString(16);
    else if (l = Number.parseInt(`${c}`, 10).toString(16), t) {
      if (r < l.length)
        return g.create(h.NUM);
      l = "0".repeat(r - l.length) + l;
    }
    return U.create(l.toLocaleUpperCase());
  }
}
class L1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g.create(h.NA);
    let r = 0;
    if (t) {
      const { isError: f, errorObject: m, variants: d } = W(t);
      if (f)
        return m;
      const [_] = d;
      if (r = Math.floor(+_.getValue()), Number.isNaN(r))
        return g.create(h.VALUE);
      if (r < 0 || r > 10)
        return g.create(h.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = W(e);
    if (n)
      return s;
    const [u] = o, c = Math.trunc(+u.getValue());
    if (Number.isNaN(c))
      return g.create(h.VALUE);
    if (!/^-?[0-9]{1,9}$/.test(`${c}`) || c < -536870912 || c > 536870911)
      return g.create(h.NUM);
    let l;
    if (c < 0)
      l = (1073741824 + c).toString(8);
    else if (l = Number.parseInt(`${c}`, 10).toString(8), t) {
      if (r < l.length)
        return g.create(h.NUM);
      l = "0".repeat(r - l.length) + l;
    }
    return U.create(l);
  }
}
class P1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(0), { isError: n, errorObject: s, variants: o } = W(e, r);
    if (n)
      return s;
    const [u, c] = o, l = +u.getValue(), f = +c.getValue();
    if (Number.isNaN(l) || Number.isNaN(f))
      return g.create(h.VALUE);
    const m = l === f ? 1 : 0;
    return y.create(m);
  }
}
class x1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r;
    if (t) {
      const { isError: n, errorObject: s, variants: o } = W(e, t);
      if (n)
        return s;
      const [u, c] = o, l = +u.getValue(), f = +c.getValue();
      if (Number.isNaN(l) || Number.isNaN(f))
        return g.create(h.VALUE);
      r = nr(f) - nr(l);
    } else {
      const { isError: n, errorObject: s, variants: o } = W(e);
      if (n)
        return s;
      const [u] = o, c = +u.getValue();
      if (Number.isNaN(c))
        return g.create(h.VALUE);
      r = nr(c);
    }
    return y.create(r);
  }
}
class j1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue();
    if (Number.isNaN(o))
      return g.create(h.VALUE);
    const u = nr(o);
    return y.create(u);
  }
}
class U1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue();
    if (Number.isNaN(o))
      return g.create(h.VALUE);
    const u = Ia(o);
    return y.create(u);
  }
}
class v1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue();
    if (Number.isNaN(o))
      return g.create(h.VALUE);
    const u = Ia(o);
    return y.create(u);
  }
}
var Q = /* @__PURE__ */ ((a) => (a.BESSELI = "BESSELI", a.BESSELJ = "BESSELJ", a.BESSELK = "BESSELK", a.BESSELY = "BESSELY", a.BIN2DEC = "BIN2DEC", a.BIN2HEX = "BIN2HEX", a.BIN2OCT = "BIN2OCT", a.BITAND = "BITAND", a.BITLSHIFT = "BITLSHIFT", a.BITOR = "BITOR", a.BITRSHIFT = "BITRSHIFT", a.BITXOR = "BITXOR", a.COMPLEX = "COMPLEX", a.CONVERT = "CONVERT", a.DEC2BIN = "DEC2BIN", a.DEC2HEX = "DEC2HEX", a.DEC2OCT = "DEC2OCT", a.DELTA = "DELTA", a.ERF = "ERF", a.ERF_PRECISE = "ERF.PRECISE", a.ERFC = "ERFC", a.ERFC_PRECISE = "ERFC.PRECISE", a.GESTEP = "GESTEP", a.HEX2BIN = "HEX2BIN", a.HEX2DEC = "HEX2DEC", a.HEX2OCT = "HEX2OCT", a.IMABS = "IMABS", a.IMAGINARY = "IMAGINARY", a.IMARGUMENT = "IMARGUMENT", a.IMCONJUGATE = "IMCONJUGATE", a.IMCOS = "IMCOS", a.IMCOSH = "IMCOSH", a.IMCOT = "IMCOT", a.IMCOTH = "IMCOTH", a.IMCSC = "IMCSC", a.IMCSCH = "IMCSCH", a.IMDIV = "IMDIV", a.IMEXP = "IMEXP", a.IMLN = "IMLN", a.IMLOG = "IMLOG", a.IMLOG10 = "IMLOG10", a.IMLOG2 = "IMLOG2", a.IMPOWER = "IMPOWER", a.IMPRODUCT = "IMPRODUCT", a.IMREAL = "IMREAL", a.IMSEC = "IMSEC", a.IMSECH = "IMSECH", a.IMSIN = "IMSIN", a.IMSINH = "IMSINH", a.IMSQRT = "IMSQRT", a.IMSUB = "IMSUB", a.IMSUM = "IMSUM", a.IMTAN = "IMTAN", a.IMTANH = "IMTANH", a.OCT2BIN = "OCT2BIN", a.OCT2DEC = "OCT2DEC", a.OCT2HEX = "OCT2HEX", a))(Q || {});
class T1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g.create(h.NA);
    const r = t != null ? t : y.create(0), { isError: n, errorObject: s, variants: o } = W(e, r);
    if (n)
      return s;
    const [u, c] = o, l = +u.getValue(), f = +c.getValue();
    if (Number.isNaN(l) || Number.isNaN(f))
      return g.create(h.VALUE);
    const m = l >= f ? 1 : 0;
    return y.create(m);
  }
}
class I1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g.create(h.NA);
    let r = 0;
    if (t) {
      const { isError: d, errorObject: _, variants: C } = W(t);
      if (d)
        return _;
      const [E] = C;
      if (r = Math.floor(+E.getValue()), Number.isNaN(r))
        return g.create(h.VALUE);
      if (r < 0 || r > 10)
        return g.create(h.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = W(e);
    if (n)
      return s;
    const [u] = o, c = `${u.getValue()}`;
    if (!Ta(c))
      return g.create(h.NUM);
    const l = c.length === 10 && c.substring(0, 1).toLocaleUpperCase() === "F", f = l ? Number.parseInt(c, 16) - 1099511627776 : Number.parseInt(c, 16);
    if (f < -512 || f > 511)
      return g.create(h.NUM);
    let m;
    if (l) {
      const d = (512 + f).toString(2);
      m = `1${"0".repeat(9 - d.length)}${d}`;
    } else if (m = f.toString(2), t) {
      if (r < m.length)
        return g.create(h.NUM);
      m = "0".repeat(r - m.length) + m;
    }
    return U.create(m);
  }
}
class B1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`;
    if (!Ta(o))
      return g.create(h.NUM);
    let u = Number.parseInt(o, 16);
    return u >= 549755813888 && (u -= 1099511627776), y.create(u);
  }
}
class F1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g.create(h.NA);
    let r = 0;
    if (t) {
      const { isError: m, errorObject: d, variants: _ } = W(t);
      if (m)
        return d;
      const [C] = _;
      if (r = Math.floor(+C.getValue()), Number.isNaN(r))
        return g.create(h.VALUE);
      if (r < 0 || r > 10)
        return g.create(h.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = W(e);
    if (n)
      return s;
    const [u] = o, c = `${u.getValue()}`;
    if (!Ta(c))
      return g.create(h.NUM);
    const l = Number.parseInt(c, 16);
    if (l > 536870911 && l < 1098974756864)
      return g.create(h.NUM);
    let f;
    if (l >= 1098974756864)
      f = (l - 1098437885952).toString(8);
    else if (f = l.toString(8), t) {
      if (r < f.length)
        return g.create(h.NUM);
      f = "0".repeat(r - f.length) + f;
    }
    return U.create(f);
  }
}
class k1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me(o);
    if (u.isError())
      return g.create(h.NUM);
    const c = u.Abs();
    return y.create(c);
  }
}
class $1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me(o);
    if (u.isError())
      return g.create(h.NUM);
    const c = u.getINum();
    return y.create(c);
  }
}
class Y1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me(o);
    if (u.isError())
      return g.create(h.NUM);
    if (u.getRealNum() === 0 && u.getINum() === 0)
      return g.create(h.DIV_BY_ZERO);
    const c = u.Argument();
    return y.create(c);
  }
}
class H1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me(o);
    if (u.isError())
      return g.create(h.NUM);
    const c = u.Conjugate();
    return typeof c == "number" || q(c) ? y.create(+c) : U.create(c);
  }
}
class G1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me(o);
    if (u.isError())
      return g.create(h.NUM);
    const c = u.Cos();
    return typeof c == "number" || q(c) ? y.create(+c) : U.create(c);
  }
}
class W1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me(o);
    if (u.isError())
      return g.create(h.NUM);
    const c = u.Cosh();
    return u.isError() ? g.create(h.NUM) : typeof c == "number" || q(c) ? y.create(+c) : U.create(c);
  }
}
class Q1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me(o);
    if (u.isError() || u.getRealNum() === 0 && u.getINum() === 0)
      return g.create(h.NUM);
    const c = u.Cot();
    return typeof c == "number" || q(c) ? y.create(+c) : U.create(c);
  }
}
class q1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me(o);
    if (u.isError() || u.getRealNum() === 0 && u.getINum() === 0)
      return g.create(h.NUM);
    const c = u.Coth();
    return u.isError() ? g.create(h.NUM) : typeof c == "number" || q(c) ? y.create(+c) : U.create(c);
  }
}
class X1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me(o);
    if (u.isError() || u.getRealNum() === 0 && u.getINum() === 0)
      return g.create(h.NUM);
    const c = u.Csc();
    return typeof c == "number" || q(c) ? y.create(+c) : U.create(c);
  }
}
class K1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me(o);
    if (u.isError() || u.getRealNum() === 0 && u.getINum() === 0)
      return g.create(h.NUM);
    const c = u.Csch();
    return typeof c == "number" || q(c) ? y.create(+c) : U.create(c);
  }
}
class Z1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull() || t.isNull())
      return g.create(h.NA);
    const { isError: r, errorObject: n, variants: s } = W(e, t);
    if (r)
      return n;
    const [o, u] = s, c = `${o.getValue()}`, l = `${u.getValue()}`, f = new me(c), m = new me(l);
    if (f.isError() || m.isError() || f.isDifferentSuffixes(m) || m.getRealNum() === 0 && m.getINum() === 0)
      return g.create(h.NUM);
    const d = f.Div(m);
    return typeof d == "number" || q(d) ? y.create(+d) : U.create(d);
  }
}
class z1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me(o);
    if (u.isError())
      return g.create(h.NUM);
    const c = u.Exp();
    return u.isError() ? g.create(h.NUM) : typeof c == "number" || q(c) ? y.create(+c) : U.create(c);
  }
}
class J1 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me(o);
    if (u.isError() || u.getRealNum() === 0 && u.getINum() === 0)
      return g.create(h.NUM);
    const c = u.Ln();
    return typeof c == "number" || q(c) ? y.create(+c) : U.create(c);
  }
}
class ed extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = W(e);
    if (r)
      return n;
    const [o] = s;
    let u = t != null ? t : y.create(10);
    if (u.isArray()) {
      const R = u.getRowCount(), b = u.getColumnCount();
      if (R > 1 || b > 1)
        return g.create(h.VALUE);
      u = u.get(0, 0);
    }
    const { isError: c, errorObject: l, variants: f } = I(u);
    if (c)
      return l;
    const [m] = f, d = `${o.getValue()}`, _ = +m.getValue(), C = new me(d);
    if (C.isError() || C.getRealNum() === 0 && C.getINum() === 0 || _ <= 0)
      return g.create(h.NUM);
    const E = C.Log(_);
    return C.isError() ? g.create(h.NUM) : typeof E == "number" || q(E) ? y.create(+E) : U.create(E);
  }
}
class td extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me(o);
    if (u.isError() || u.getRealNum() === 0 && u.getINum() === 0)
      return g.create(h.NUM);
    const c = u.Log(2);
    return typeof c == "number" || q(c) ? y.create(+c) : U.create(c);
  }
}
class rd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me(o);
    if (u.isError() || u.getRealNum() === 0 && u.getINum() === 0)
      return g.create(h.NUM);
    const c = u.Log(10);
    return typeof c == "number" || q(c) ? y.create(+c) : U.create(c);
  }
}
class nd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull() || t.isNull())
      return g.create(h.NA);
    const { isError: r, errorObject: n, variants: s } = W(e, t);
    if (r)
      return n;
    const [o, u] = s, c = `${o.getValue()}`, l = new me(c);
    if (l.isError())
      return g.create(h.NUM);
    const f = +u.getValue();
    if (Number.isNaN(f))
      return g.create(h.VALUE);
    const m = l.Power(f);
    return l.isError() ? g.create(h.NUM) : typeof m == "number" || q(m) ? y.create(+m) : U.create(m);
  }
}
class sd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = "";
    for (let r = 0; r < e.length; r++) {
      if (t instanceof g)
        return t;
      const n = e[r];
      if (n.isArray()) {
        let s = !1, o;
        if (n.iterator((u) => {
          if (t = this._handleSingleObject(u, t), t instanceof g)
            return s = !0, o = t, !1;
        }), s)
          return o;
      } else
        t = this._handleSingleObject(n, t);
    }
    return t instanceof g ? t : typeof t == "number" || q(t) ? y.create(+t) : U.create(t);
  }
  _handleSingleObject(e, t) {
    let r = t;
    if (e.isError())
      return e;
    if (e.isBoolean())
      return g.create(h.VALUE);
    const n = `${e.getValue()}`;
    if (typeof t != "number" && !t) {
      const s = new me(n);
      if (s.isError())
        return g.create(h.NUM);
      r = s.toString();
    } else {
      const s = new me(t), o = new me(n);
      if (s.isError() || o.isError())
        return g.create(h.NUM);
      if (s.isDifferentSuffixes(o))
        return g.create(h.VALUE);
      r = s.Product(o);
    }
    return r;
  }
}
class ad extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me(o);
    if (u.isError())
      return g.create(h.NUM);
    const c = u.getRealNum();
    return y.create(c);
  }
}
class id extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me(o);
    if (u.isError())
      return g.create(h.NUM);
    const c = u.Sec();
    return typeof c == "number" || q(c) ? y.create(+c) : U.create(c);
  }
}
class od extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me(o);
    if (u.isError())
      return g.create(h.NUM);
    const c = u.Sech();
    return typeof c == "number" || q(c) ? y.create(+c) : U.create(c);
  }
}
class ud extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me(o);
    if (u.isError())
      return g.create(h.NUM);
    const c = u.Sin();
    return typeof c == "number" || q(c) ? y.create(+c) : U.create(c);
  }
}
class cd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me(o);
    if (u.isError())
      return g.create(h.NUM);
    const c = u.Sinh();
    return u.isError() ? g.create(h.NUM) : typeof c == "number" || q(c) ? y.create(+c) : U.create(c);
  }
}
class ld extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me(o);
    if (u.isError())
      return g.create(h.NUM);
    if (u.getRealNum() === 0 && u.getINum() === 0)
      return y.create(0);
    const c = u.Sqrt();
    return typeof c == "number" || q(c) ? y.create(+c) : U.create(c);
  }
}
class fd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull() || t.isNull())
      return g.create(h.NA);
    const { isError: r, errorObject: n, variants: s } = W(e, t);
    if (r)
      return n;
    const [o, u] = s, c = `${o.getValue()}`, l = `${u.getValue()}`, f = new me(c), m = new me(l);
    if (f.isError() || m.isError() || f.isDifferentSuffixes(m))
      return g.create(h.NUM);
    const d = f.Sub(m);
    return typeof d == "number" || q(d) ? y.create(+d) : U.create(d);
  }
}
class md extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = "";
    for (let r = 0; r < e.length; r++) {
      if (t instanceof g)
        return t;
      const n = e[r];
      if (n.isArray()) {
        let s = !1, o;
        if (n.iterator((u) => {
          if (t = this._handleSingleObject(u, t), t instanceof g)
            return s = !0, o = t, !1;
        }), s)
          return o;
      } else
        t = this._handleSingleObject(n, t);
    }
    return t instanceof g ? t : typeof t == "number" || q(t) ? y.create(+t) : U.create(t);
  }
  _handleSingleObject(e, t) {
    let r = t;
    if (e.isError())
      return e;
    if (e.isBoolean())
      return g.create(h.VALUE);
    const n = `${e.getValue()}`;
    if (typeof t != "number" && !t) {
      const s = new me(n);
      if (s.isError())
        return g.create(h.NUM);
      r = s.toString();
    } else {
      const s = new me(t), o = new me(n);
      if (s.isError() || o.isError())
        return g.create(h.NUM);
      if (s.isDifferentSuffixes(o))
        return g.create(h.VALUE);
      r = s.Sum(o);
    }
    return r;
  }
}
class hd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me(o);
    if (u.isError())
      return g.create(h.NUM);
    const c = u.Tan();
    return typeof c == "number" || q(c) ? y.create(+c) : U.create(c);
  }
}
class gd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`, u = new me(o);
    if (u.isError())
      return g.create(h.NUM);
    const c = u.Tanh();
    return u.isError() ? g.create(h.NUM) : typeof c == "number" || q(c) ? y.create(+c) : U.create(c);
  }
}
class dd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g.create(h.NA);
    let r = 0;
    if (t) {
      const { isError: d, errorObject: _, variants: C } = W(t);
      if (d)
        return _;
      const [E] = C;
      if (r = Math.floor(+E.getValue()), Number.isNaN(r))
        return g.create(h.VALUE);
      if (r < 0 || r > 10)
        return g.create(h.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = W(e);
    if (n)
      return s;
    const [u] = o, c = `${u.getValue()}`;
    if (!va(c))
      return g.create(h.NUM);
    const l = c.length === 10 && c.substring(0, 1) === "7", f = l ? Number.parseInt(c, 8) - 1073741824 : Number.parseInt(c, 8);
    if (f < -512 || f > 511)
      return g.create(h.NUM);
    let m;
    if (l) {
      const d = (512 + f).toString(2);
      m = `1${"0".repeat(9 - d.length)}${d}`;
    } else if (m = f.toString(2), t) {
      if (r < m.length)
        return g.create(h.NUM);
      m = "0".repeat(r - m.length) + m;
    }
    return U.create(m);
  }
}
class Cd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const { isError: t, errorObject: r, variants: n } = W(e);
    if (t)
      return r;
    const [s] = n, o = `${s.getValue()}`;
    if (!va(o))
      return g.create(h.NUM);
    let u = Number.parseInt(o, 8);
    return u >= 536870912 && (u -= 1073741824), y.create(u);
  }
}
class _d extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isNull())
      return g.create(h.NA);
    let r = 0;
    if (t) {
      const { isError: m, errorObject: d, variants: _ } = W(t);
      if (m)
        return d;
      const [C] = _;
      if (r = Math.floor(+C.getValue()), Number.isNaN(r))
        return g.create(h.VALUE);
      if (r < 0 || r > 10)
        return g.create(h.NUM);
    }
    const { isError: n, errorObject: s, variants: o } = W(e);
    if (n)
      return s;
    const [u] = o, c = `${u.getValue()}`;
    if (!va(c))
      return g.create(h.NUM);
    const l = Number.parseInt(c, 8);
    let f;
    if (l >= 536870912)
      f = `ff${(l + 3221225472).toString(16)}`;
    else if (f = l.toString(16), t) {
      if (r < f.length)
        return g.create(h.NUM);
      f = "0".repeat(r - f.length) + f;
    }
    return U.create(f.toLocaleUpperCase());
  }
}
const Ad = [
  [d1, Q.BESSELI],
  [C1, Q.BESSELJ],
  [_1, Q.BESSELK],
  [A1, Q.BESSELY],
  [E1, Q.BIN2DEC],
  [R1, Q.BIN2HEX],
  [b1, Q.BIN2OCT],
  [y1, Q.BITAND],
  [p1, Q.BITLSHIFT],
  [N1, Q.BITOR],
  [V1, Q.BITRSHIFT],
  [O1, Q.BITXOR],
  [S1, Q.COMPLEX],
  [M1, Q.CONVERT],
  [D1, Q.DEC2BIN],
  [w1, Q.DEC2HEX],
  [L1, Q.DEC2OCT],
  [P1, Q.DELTA],
  [x1, Q.ERF],
  [j1, Q.ERF_PRECISE],
  [U1, Q.ERFC],
  [v1, Q.ERFC_PRECISE],
  [T1, Q.GESTEP],
  [I1, Q.HEX2BIN],
  [B1, Q.HEX2DEC],
  [F1, Q.HEX2OCT],
  [k1, Q.IMABS],
  [$1, Q.IMAGINARY],
  [Y1, Q.IMARGUMENT],
  [H1, Q.IMCONJUGATE],
  [G1, Q.IMCOS],
  [W1, Q.IMCOSH],
  [Q1, Q.IMCOT],
  [q1, Q.IMCOTH],
  [X1, Q.IMCSC],
  [K1, Q.IMCSCH],
  [Z1, Q.IMDIV],
  [z1, Q.IMEXP],
  [J1, Q.IMLN],
  [ed, Q.IMLOG],
  [rd, Q.IMLOG10],
  [td, Q.IMLOG2],
  [nd, Q.IMPOWER],
  [sd, Q.IMPRODUCT],
  [ad, Q.IMREAL],
  [id, Q.IMSEC],
  [od, Q.IMSECH],
  [ud, Q.IMSIN],
  [cd, Q.IMSINH],
  [ld, Q.IMSQRT],
  [fd, Q.IMSUB],
  [md, Q.IMSUM],
  [hd, Q.IMTAN],
  [gd, Q.IMTANH],
  [dd, Q.OCT2BIN],
  [Cd, Q.OCT2DEC],
  [_d, Q.OCT2HEX]
];
var ee = /* @__PURE__ */ ((a) => (a.ACCRINT = "ACCRINT", a.ACCRINTM = "ACCRINTM", a.AMORDEGRC = "AMORDEGRC", a.AMORLINC = "AMORLINC", a.COUPDAYBS = "COUPDAYBS", a.COUPDAYS = "COUPDAYS", a.COUPDAYSNC = "COUPDAYSNC", a.COUPNCD = "COUPNCD", a.COUPNUM = "COUPNUM", a.COUPPCD = "COUPPCD", a.CUMIPMT = "CUMIPMT", a.CUMPRINC = "CUMPRINC", a.DB = "DB", a.DDB = "DDB", a.DISC = "DISC", a.DOLLARDE = "DOLLARDE", a.DOLLARFR = "DOLLARFR", a.DURATION = "DURATION", a.EFFECT = "EFFECT", a.FV = "FV", a.FVSCHEDULE = "FVSCHEDULE", a.INTRATE = "INTRATE", a.IPMT = "IPMT", a.IRR = "IRR", a.ISPMT = "ISPMT", a.MDURATION = "MDURATION", a.MIRR = "MIRR", a.NOMINAL = "NOMINAL", a.NPER = "NPER", a.NPV = "NPV", a.ODDFPRICE = "ODDFPRICE", a.ODDFYIELD = "ODDFYIELD", a.ODDLPRICE = "ODDLPRICE", a.ODDLYIELD = "ODDLYIELD", a.PDURATION = "PDURATION", a.PMT = "PMT", a.PPMT = "PPMT", a.PRICE = "PRICE", a.PRICEDISC = "PRICEDISC", a.PRICEMAT = "PRICEMAT", a.PV = "PV", a.RATE = "RATE", a.RECEIVED = "RECEIVED", a.RRI = "RRI", a.SLN = "SLN", a.SYD = "SYD", a.TBILLEQ = "TBILLEQ", a.TBILLPRICE = "TBILLPRICE", a.TBILLYIELD = "TBILLYIELD", a.VDB = "VDB", a.XIRR = "XIRR", a.XNPV = "XNPV", a.YIELD = "YIELD", a.YIELDDISC = "YIELDDISC", a.YIELDMAT = "YIELDMAT", a))(ee || {});
function As(a, i, e, t) {
  const r = Gt(a, i, e), { days: n } = _e(r, a, t);
  return n;
}
function ze(a, i, e, t) {
  let r;
  if (t === 1) {
    const n = Gt(a, i, e);
    let s = ae(n);
    s = Mr(s, 12 / e);
    const o = pe(s);
    n < 0 && e === 1 ? r = 365 : r = o - n;
  } else t === 3 ? r = 365 / e : r = 360 / e;
  return r;
}
function oc(a, i, e) {
  const t = ae(a);
  let r = ae(i);
  for (r.setUTCFullYear(t.getUTCFullYear()), r < t && r.setUTCFullYear(r.getUTCFullYear() + 1); r > t; )
    r = Mr(r, -12 / e);
  return r = Mr(r, 12 / e), pe(r);
}
function ur(a, i, e) {
  let t = 0;
  const r = ae(a);
  let n = ae(i);
  for (; n > r; )
    n = Mr(n, -12 / e), t++;
  return t;
}
function Gt(a, i, e) {
  const t = ae(a);
  let r = ae(i);
  for (r.setUTCFullYear(t.getUTCFullYear()), r < t && r.setUTCFullYear(r.getUTCFullYear() + 1); r > t; )
    r = Mr(r, -12 / e);
  return pe(r);
}
function uc(a, i, e, t, r, n) {
  const s = As(a, i, r, n), o = ze(a, i, r, n), u = ur(a, i, r), c = (o - s) / o - 1, l = t / r + 1, f = e * 100 / r;
  let m = 0, d = 0;
  for (let E = 1; E <= u; E++) {
    const R = E + c, b = f / l ** R;
    m += R * b, d += b;
  }
  const _ = u + c, C = 100 / l ** _;
  return m += _ * C, d += C, m / d / r;
}
function nn(a, i, e, t, r) {
  let n;
  if (a === 0)
    n = (e + t) / i;
  else {
    const s = (1 + a) ** i;
    n = r === 1 ? (t * a / (s - 1) + e * a / (1 - 1 / s)) / (1 + a) : t * a / (s - 1) + e * a / (1 - 1 / s);
  }
  return -n;
}
function cr(a, i, e, t, r) {
  let n;
  if (a === 0)
    n = t + e * i;
  else {
    if (a === -1 && i === 0)
      return Number.NaN;
    const s = (1 + a) ** i;
    n = r === 1 ? t * s + e * (1 + a) * (s - 1) / a : t * s + e * (s - 1) / a;
  }
  return -n;
}
function cc(a, i, e, t, r, n) {
  const s = nn(a, e, t, r, n);
  return (i === 1 ? n === 1 ? 0 : -t : n === 1 ? cr(a, i - 2, s, t, 1) - s : cr(a, i - 1, s, t, 0)) * a;
}
function lc(a, i) {
  let e = 0;
  for (let t = 1; t <= i.length; t++)
    e += i[t - 1] / (1 + a) ** t;
  return e;
}
function fc(a, i, e, t, r, n, s, o, u) {
  const c = er(e, t, u), l = ze(a, t, o, u);
  return c < l ? Ed(
    a,
    i,
    e,
    t,
    r,
    n,
    s,
    o,
    u,
    c,
    l
  ) : Rd(
    a,
    i,
    e,
    t,
    r,
    n,
    s,
    o,
    u,
    l
  );
}
function Ed(a, i, e, t, r, n, s, o, u, c, l) {
  let f = 0;
  const m = ur(a, i, o), d = er(a, t, u);
  f += s / (1 + n / o) ** (m - 1 + d / l), f += 100 * r / o * c / l / (1 + n / o) ** (d / l);
  for (let C = 2; C <= m; C++)
    f += 100 * r / o / (1 + n / o) ** (C - 1 + d / l);
  const _ = er(e, a, u);
  return f -= 100 * r / o * _ / l, f;
}
function Rd(a, i, e, t, r, n, s, o, u, c) {
  let l = 0;
  const f = ur(t, i, o), m = bd(t, a, 12 / o);
  let d;
  if (u === 2 || u === 3) {
    const b = oc(a, t, o);
    d = er(a, b, u);
  } else {
    const b = Gt(a, t, o), { days: p } = _e(b, a, u);
    d = c - p;
  }
  l += s / (1 + n / o) ** (f + m + d / c);
  const _ = ur(e, t, o);
  let C = t, E = 0, R = 0;
  for (let b = _; b >= 1; b--) {
    const p = ar(C, -12 / o, !1), V = u === 1 ? er(p, C, u) : c, S = b > 1 ? V : er(e, C, u);
    E += S / V;
    const M = e > p ? e : p, D = a < C ? a : C, w = er(M, D, u);
    R += w / V, C = p;
  }
  l += 100 * r / o * E / (1 + n / o) ** (m + d / c);
  for (let b = 1; b <= f; b++)
    l += 100 * r / o / (1 + n / o) ** (b + m + d / c);
  return l -= 100 * r / o * R, l;
}
function er(a, i, e) {
  const { days: t } = _e(a, i, e);
  return a < i ? t : 0;
}
function mc(a, i, e) {
  const t = ae(a), r = t.getUTCFullYear(), n = t.getUTCMonth(), s = t.getUTCDate(), o = Sr(r, n, s), u = ae(i), c = u.getUTCFullYear(), l = u.getUTCMonth(), f = u.getUTCDate(), m = Sr(c, l, f);
  return !(s !== f && !(o && m) || Math.abs((c - r) * 12 + (l - n)) % (12 / e) !== 0);
}
function Ur(a, i, e) {
  return Gt(a, i, e) >= 0;
}
function ar(a, i, e) {
  let t = ae(a);
  if (t = Mr(t, i), e) {
    const r = t.getUTCFullYear(), n = t.getUTCMonth(), s = rn(r, n);
    t.setUTCDate(s);
  }
  return pe(t);
}
function bd(a, i, e, t) {
  const r = ae(a), n = ae(i), s = r.getUTCFullYear(), o = r.getUTCMonth(), u = r.getUTCDate(), c = n.getUTCFullYear(), l = n.getUTCMonth(), f = n.getUTCDate(), m = Sr(s, o, u), d = !m && o !== 1 && u > 28 && u < rn(s, o) ? Sr(c, l, f) : m, _ = ar(i, 0, d);
  let C = 1 + +(i < _), E = ar(_, e, d);
  for (; !(e > 0 ? E >= i : E <= i); )
    E = ar(E, e, d), C++;
  return C;
}
function Ja(a, i) {
  let n = 1, s = 0, o = a, u;
  for (; n > 1e-7 && s < 500; ) {
    const c = (i(o + 1e-7) - i(o - 1e-7)) / 2e-7;
    u = o - i(o) / c, s++, n = Math.abs(u - o), o = u;
  }
  return Number.isNaN(o) || Math.abs(o) === 1 / 0 || s === 500 ? yd(a, i) : o;
}
function yd(a, i) {
  const r = Number.MAX_VALUE, n = -1, s = 1.6;
  let o = a - 0.01 <= n ? n + 1e-7 : a - 0.01, u = a + 0.01 >= r ? r - 1e-7 : a + 0.01, c, l, f = 0;
  if (a <= n || a >= r)
    return g.create(h.NUM);
  for (let E = 0; E < 60; E++) {
    c = o <= n ? n + 1e-7 : o, l = u >= r ? r - 1e-7 : u;
    const R = i(c), b = i(l);
    if (R * b <= 0)
      break;
    if (R * b > 0)
      o = c + s * (c - l), u = l + s * (l - c);
    else
      return g.create(h.NUM);
    if (E === 59)
      return g.create(h.NUM);
  }
  c = c, l = l;
  let m = i(c);
  const d = i(l);
  let _, C;
  if (Math.abs(m) < 1e-7 || Math.abs(d) < 1e-7)
    return g.create(h.NUM);
  do
    C = c + (l - c) / 2, _ = i(C), m * _ < 0 ? l = C : c = C, m = i(c), f++;
  while (Math.abs(_) > 1e-7 && f < 60);
  return C;
}
function pn(a, i, e, t, r, n, s) {
  const o = ur(a, i, n), u = ze(a, i, n, s), c = As(a, i, n, s);
  if (o === 1) {
    const m = u - c, d = 100 * e / n + r, _ = t / n * m / u + 1, C = 100 * e / n * c / u;
    return d / _ - C;
  }
  const l = u - c;
  let f = r / (1 + t / n) ** (o - 1 + l / u);
  for (let m = 1; m <= o; m++)
    f += 100 * e / n / (1 + t / n) ** (m - 1 + l / u);
  return f -= 100 * e / n * c / u, f;
}
function ma(a, i, e, t, r) {
  let n = 0, s = r / e;
  s >= 1 ? (s = 1, n = t === 1 ? a : 0) : n = a * (1 - s) ** (t - 1);
  const o = a * (1 - s) ** t;
  let u = 0;
  return o < i ? u = n - i : u = n - o, u < 0 && (u = 0), u;
}
class pd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 6);
    A(this, "maxParams", 8);
  }
  calculate(e, t, r, n, s, o, u, c) {
    const l = u != null ? u : y.create(0), f = c != null ? c : T.create(!0), { isError: m, errorObject: d, variants: _ } = W(e, t, r, n, s, o, l);
    if (m)
      return d;
    const [C, E, R, b, p, V, S] = _, M = H(C);
    if (typeof M != "number")
      return M;
    const D = H(E);
    if (typeof D != "number")
      return D;
    const w = H(R);
    if (typeof w != "number")
      return w;
    const L = +b.getValue(), v = +p.getValue(), j = Math.floor(+V.getValue()), k = Math.floor(+S.getValue()), G = +f.getValue();
    return Number.isNaN(L) || Number.isNaN(v) || Number.isNaN(j) || Number.isNaN(k) || Number.isNaN(G) ? g.create(h.VALUE) : L <= 0 || v <= 0 || ![1, 2, 4].includes(j) || k < 0 || k > 4 || Math.floor(M) >= Math.floor(w) ? g.create(h.NUM) : this._getResult(M, D, w, L, v, j, k, G);
  }
  _getResult(e, t, r, n, s, o, u, c) {
    let l = Gt(e, t, o);
    if (l <= 0)
      return y.create(0);
    l = Gt(r, t, o);
    const f = 12 / o, m = ae(t), d = m.getUTCFullYear(), _ = m.getUTCMonth(), C = m.getUTCDate(), E = Sr(d, _, C);
    let R = ar(t, -f, E);
    if (r > t && c)
      for (R = t; R < r; )
        R = ar(R, f, E);
    let b = e > R ? e : R, { days: p } = _e(b, r, u);
    if (l >= e) {
      const { days: L } = _e(b, r, u ? 4 : 0);
      p = L;
    }
    r < b && (p = -p);
    let V = ze(R, t, o, u), S = p / V, M = R, D = e;
    for (; M > e; ) {
      D = M, M = ar(M, -f, E), b = e > M ? e : M;
      const { days: L } = _e(b, D, u);
      if (u === 0)
        D >= b || e <= M ? p = L : p = -L, V = ze(M, D, o, u);
      else if (p = D < b ? -L : L, u === 3)
        V = 365 / o;
      else {
        const { days: v } = _e(M, D, u);
        V = D < M ? -v : v;
      }
      S += e <= M ? c ? 1 : 0 : p / V;
    }
    const w = s * n / o * S;
    return y.create(w);
  }
}
class Nd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    const o = s != null ? s : y.create(0), { isError: u, errorObject: c, variants: l } = W(e, t, r, n, o);
    if (u)
      return c;
    const [f, m, d, _, C] = l, E = H(f);
    if (typeof E != "number")
      return E;
    const R = H(m);
    if (typeof R != "number")
      return R;
    const b = +d.getValue(), p = +_.getValue(), V = Math.floor(+C.getValue());
    if (Number.isNaN(b) || Number.isNaN(p) || Number.isNaN(V))
      return g.create(h.VALUE);
    if (b <= 0 || p <= 0 || V < 0 || V > 4 || Math.floor(E) > Math.floor(R))
      return g.create(h.NUM);
    if (Math.floor(E) === Math.floor(R))
      return y.create(0);
    const { days: S, yearDays: M } = _e(E, R, V), D = p * b * S / M;
    return y.create(D);
  }
}
class Vd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 6);
    A(this, "maxParams", 7);
  }
  calculate(e, t, r, n, s, o, u) {
    const c = u != null ? u : y.create(0), { isError: l, errorObject: f, variants: m } = W(e, t, r, n, s, o, c);
    if (l)
      return f;
    const [d, _, C, E, R, b, p] = m, V = H(_);
    if (typeof V != "number")
      return V;
    const S = H(C);
    if (typeof S != "number")
      return S;
    const M = +d.getValue(), D = +E.getValue();
    let w = +R.getValue();
    const L = +b.getValue(), v = Math.floor(+p.getValue());
    return Number.isNaN(M) || Number.isNaN(D) || Number.isNaN(w) || Number.isNaN(L) || Number.isNaN(v) ? g.create(h.VALUE) : M <= 0 || D < 0 || M < D || Math.floor(V) > Math.floor(S) || w < 0 || L <= 0 || ![0, 1, 3, 4].includes(v) ? g.create(h.NUM) : (w > 1 ? w = Math.floor(w) : w = Math.ceil(w), this._getResult(M, V, S, D, w, L, v));
  }
  _getResult(e, t, r, n, s, o, u) {
    const c = e - n, l = e * o, { days: f, yearDays: m } = _e(t, r, u), d = f / m, _ = Math.ceil(c / l - d);
    if (_ < 0)
      return y.create(0);
    let C = l;
    return s === 0 ? C = l * d : s === _ ? C = c - l * (d + s - 1) : s > _ && (C = 0), y.create(C);
  }
}
class Od extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = n != null ? n : y.create(0), { isError: o, errorObject: u, variants: c } = W(e, t, r, s);
    if (o)
      return u;
    const [l, f, m, d] = c, _ = H(l);
    if (typeof _ != "number")
      return _;
    const C = H(f);
    if (typeof C != "number")
      return C;
    const E = Math.floor(+m.getValue()), R = Math.floor(+d.getValue());
    if (Number.isNaN(E) || Number.isNaN(R))
      return g.create(h.VALUE);
    if (![1, 2, 4].includes(E) || R < 0 || R > 4 || Math.floor(_) >= Math.floor(C))
      return g.create(h.NUM);
    const b = As(_, C, E, R);
    return y.create(b);
  }
}
class Sd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = n != null ? n : y.create(0), { isError: o, errorObject: u, variants: c } = W(e, t, r, s);
    if (o)
      return u;
    const [l, f, m, d] = c, _ = H(l);
    if (typeof _ != "number")
      return _;
    const C = H(f);
    if (typeof C != "number")
      return C;
    const E = Math.floor(+m.getValue()), R = Math.floor(+d.getValue());
    if (Number.isNaN(E) || Number.isNaN(R))
      return g.create(h.VALUE);
    if (![1, 2, 4].includes(E) || R < 0 || R > 4 || Math.floor(_) >= Math.floor(C))
      return g.create(h.NUM);
    const b = ze(_, C, E, R);
    return y.create(b);
  }
}
class Md extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = n != null ? n : y.create(0), { isError: o, errorObject: u, variants: c } = W(e, t, r, s);
    if (o)
      return u;
    const [l, f, m, d] = c, _ = H(l);
    if (typeof _ != "number")
      return _;
    const C = H(f);
    if (typeof C != "number")
      return C;
    const E = Math.floor(+m.getValue()), R = Math.floor(+d.getValue());
    if (Number.isNaN(E) || Number.isNaN(R))
      return g.create(h.VALUE);
    if (![1, 2, 4].includes(E) || R < 0 || R > 4 || Math.floor(_) >= Math.floor(C))
      return g.create(h.NUM);
    const b = ae(_), p = ae(C);
    for (p.setUTCFullYear(b.getUTCFullYear()), p < b && p.setUTCFullYear(p.getUTCFullYear() + 1); p > b; )
      p.setUTCMonth(p.getUTCMonth() - 12 / E);
    p.setUTCMonth(p.getUTCMonth() + 12 / E);
    const V = pe(p), { days: S } = _e(_, V, R);
    return y.create(S);
  }
}
class Dd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = n != null ? n : y.create(0), { isError: o, errorObject: u, variants: c } = W(e, t, r, s);
    if (o)
      return u;
    const [l, f, m, d] = c, _ = H(l);
    if (typeof _ != "number")
      return _;
    const C = H(f);
    if (typeof C != "number")
      return C;
    const E = Math.floor(+m.getValue()), R = Math.floor(+d.getValue());
    if (Number.isNaN(E) || Number.isNaN(R))
      return g.create(h.VALUE);
    if (![1, 2, 4].includes(E) || R < 0 || R > 4 || Math.floor(_) >= Math.floor(C))
      return g.create(h.NUM);
    const b = oc(_, C, E);
    return y.create(b);
  }
}
class wd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = n != null ? n : y.create(0), { isError: o, errorObject: u, variants: c } = W(e, t, r, s);
    if (o)
      return u;
    const [l, f, m, d] = c, _ = H(l);
    if (typeof _ != "number")
      return _;
    const C = H(f);
    if (typeof C != "number")
      return C;
    const E = Math.floor(+m.getValue()), R = Math.floor(+d.getValue());
    if (Number.isNaN(E) || Number.isNaN(R))
      return g.create(h.VALUE);
    if (![1, 2, 4].includes(E) || R < 0 || R > 4 || Math.floor(_) >= Math.floor(C) || Gt(_, C, E) < 0)
      return g.create(h.NUM);
    const p = ur(_, C, E);
    return y.create(p);
  }
}
class Ld extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = n != null ? n : y.create(0), { isError: o, errorObject: u, variants: c } = W(e, t, r, s);
    if (o)
      return u;
    const [l, f, m, d] = c, _ = H(l);
    if (typeof _ != "number")
      return _;
    const C = H(f);
    if (typeof C != "number")
      return C;
    const E = Math.floor(+m.getValue()), R = Math.floor(+d.getValue());
    if (Number.isNaN(E) || Number.isNaN(R))
      return g.create(h.VALUE);
    if (![1, 2, 4].includes(E) || R < 0 || R > 4 || Math.floor(_) >= Math.floor(C))
      return g.create(h.NUM);
    let b = Gt(_, C, E);
    return b < 0 && (b = 0), y.create(b);
  }
}
class Pd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 6);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    const { isError: u, errorObject: c, variants: l } = W(e, t, r, n, s, o);
    if (u)
      return c;
    const [f, m, d, _, C, E] = l, R = +f.getValue(), b = +m.getValue(), p = +d.getValue(), V = +_.getValue(), S = +C.getValue(), M = +E.getValue();
    return Number.isNaN(R) || Number.isNaN(b) || Number.isNaN(p) || Number.isNaN(V) || Number.isNaN(S) || Number.isNaN(M) ? g.create(h.VALUE) : R <= 0 || b <= 0 || p <= 0 || V < 1 || S < 1 || V > S || V > b || S > b || ![0, 1].includes(M) ? g.create(h.NUM) : Math.trunc(V) !== V && Math.trunc(S) !== S && Math.trunc(V) === Math.trunc(S) ? y.create(0) : this._getResult(R, b, p, V, S, M);
  }
  _getResult(e, t, r, n, s, o) {
    const u = nn(e, t, r, 0, o);
    let c = 0, l = Math.ceil(n);
    l === 1 && (o === 0 && (c = -r), l++);
    let f = !1;
    for (let m = l; m <= s; m++) {
      const d = o === 1 ? cr(e, m - 2, u, r, 1) : cr(e, m - 1, u, r, 0);
      if (d === 0) {
        f = !0;
        break;
      }
      c += o === 1 ? d - u : d;
    }
    return c *= e, (c < u * (s - n + 1) || f) && (c = u * (s - n + 1)), y.create(c);
  }
}
class xd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 6);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    const { isError: u, errorObject: c, variants: l } = W(e, t, r, n, s, o);
    if (u)
      return c;
    const [f, m, d, _, C, E] = l, R = +f.getValue(), b = +m.getValue(), p = +d.getValue(), V = +_.getValue(), S = +C.getValue(), M = +E.getValue();
    return Number.isNaN(R) || Number.isNaN(b) || Number.isNaN(p) || Number.isNaN(V) || Number.isNaN(S) || Number.isNaN(M) ? g.create(h.VALUE) : R <= 0 || b <= 0 || p <= 0 || V < 1 || S < 1 || V > S || ![0, 1].includes(M) ? g.create(h.NUM) : Math.trunc(V) !== V && Math.trunc(S) !== S && Math.trunc(V) === Math.trunc(S) ? y.create(0) : this._getResult(R, b, p, V, S, M);
  }
  _getResult(e, t, r, n, s, o) {
    const u = nn(e, t, r, 0, o);
    let c = 0, l = Math.ceil(n);
    l === 1 && (c = o === 0 ? u + r * e : u, l++);
    for (let f = l; f <= s; f++)
      c += o === 1 ? u - (cr(e, f - 2, u, r, 1) - u) * e : u - cr(e, f - 1, u, r, 0) * e;
    return y.create(c);
  }
}
class jd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 5);
    A(this, "needsLocale", !0);
  }
  calculate(e, t, r, n, s) {
    let o = s != null ? s : y.create(12);
    o.isNull() && (o = y.create(12));
    const u = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1
    ), c = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1
    ), l = O(u, c, e, g.create(h.NA)), f = O(u, c, t, g.create(h.NA)), m = O(u, c, r, g.create(h.NA)), d = O(u, c, n, g.create(h.NA)), _ = O(u, c, o, g.create(h.NA)), C = l.map((E, R, b) => {
      const p = f.get(R, b), V = m.get(R, b), S = d.get(R, b), M = _.get(R, b), { isError: D, errorObject: w, variants: L } = I(E, p, V, S, M);
      if (D)
        return w;
      const [v, j, k, G, ne] = L, z = +v.getValue(), $ = +j.getValue(), ge = +k.getValue();
      let Ce = +G.getValue();
      const be = Math.floor(+ne.getValue());
      return z < 0 || $ < 0 || ge <= 0 || Ce <= 0 || Math.floor(Ce) > Math.floor(ge) || be < 1 || be > 12 ? g.create(h.NUM) : (Ce < 1 && (Ce = 1), Ce = Math.floor(Ce), this._getResult(z, $, ge, Ce, be, R, b));
    });
    return u === 1 && c === 1 ? C.get(0, 0) : C;
  }
  _getResult(e, t, r, n, s, o, u) {
    const c = +(1 - (t / e) ** (1 / r)).toFixed(3), l = e * c * s / 12;
    let f = l, m = 0;
    const d = n === r ? r - 1 : n;
    for (let C = 2; C <= d; C++)
      m = (e - f) * c, f += m;
    let _;
    return n === 1 ? _ = l : n === r ? _ = (e - f) * c : _ = m, Number.isNaN(_) || !Number.isFinite(_) ? g.create(h.NUM) : o === 0 && u === 0 ? y.create(_, et(this.getLocale())) : y.create(_);
  }
}
class Ud extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 5);
    A(this, "needsLocale", !0);
  }
  calculate(e, t, r, n, s) {
    let o = s != null ? s : y.create(2);
    o.isNull() && (o = y.create(2));
    const u = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1
    ), c = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1
    ), l = O(u, c, e, g.create(h.NA)), f = O(u, c, t, g.create(h.NA)), m = O(u, c, r, g.create(h.NA)), d = O(u, c, n, g.create(h.NA)), _ = O(u, c, o, g.create(h.NA)), C = l.map((E, R, b) => {
      const p = f.get(R, b), V = m.get(R, b), S = d.get(R, b), M = _.get(R, b), { isError: D, errorObject: w, variants: L } = I(E, p, V, S, M);
      if (D)
        return w;
      const [v, j, k, G, ne] = L, z = +v.getValue(), $ = +j.getValue(), ge = +k.getValue(), Ce = +G.getValue(), be = +ne.getValue();
      if (z < 0 || $ < 0 || ge <= 0 || Ce <= 0 || Ce > ge || be <= 0)
        return g.create(h.NUM);
      const Ne = ma(z, $, ge, Ce, be);
      return Number.isNaN(Ne) || !Number.isFinite(Ne) ? g.create(h.NUM) : R === 0 && b === 0 ? y.create(Ne, et(this.getLocale())) : y.create(Ne);
    });
    return u === 1 && c === 1 ? C.get(0, 0) : C;
  }
}
class vd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    const o = s != null ? s : y.create(0), { isError: u, errorObject: c, variants: l } = W(e, t, r, n, o);
    if (u)
      return c;
    const [f, m, d, _, C] = l, E = H(f);
    if (typeof E != "number")
      return E;
    const R = H(m);
    if (typeof R != "number")
      return R;
    const b = +d.getValue(), p = +_.getValue(), V = Math.floor(+C.getValue());
    if (Number.isNaN(b) || Number.isNaN(p) || Number.isNaN(V))
      return g.create(h.VALUE);
    if (b <= 0 || p <= 0 || V < 0 || V > 4 || Math.floor(E) >= Math.floor(R))
      return g.create(h.NUM);
    const { days: S, yearDays: M } = _e(E, R, V), D = (p - b) / p * (M / S);
    return y.create(D);
  }
}
class Td extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = W(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue();
    let l = Math.floor(+u.getValue());
    if (Number.isNaN(c) || Number.isNaN(l))
      return g.create(h.VALUE);
    if (l < 0)
      return g.create(h.NUM);
    if (l >= 0 && l < 1)
      return g.create(h.DIV_BY_ZERO);
    l = Number.parseInt(`${l}`, 10);
    let f = Number.parseInt(`${c}`, 10);
    f += c % 1 * 10 ** Math.ceil(Math.log(l) / Math.LN10) / l;
    const m = 10 ** (Math.ceil(Math.log(l) / Math.LN2) + 1);
    return f = Math.round(f * m) / m, y.create(f);
  }
}
class Id extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = W(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue();
    let l = Math.floor(+u.getValue());
    if (Number.isNaN(c) || Number.isNaN(l))
      return g.create(h.VALUE);
    if (l < 0)
      return g.create(h.NUM);
    if (l >= 0 && l < 1)
      return g.create(h.DIV_BY_ZERO);
    l = Number.parseInt(`${l}`, 10);
    let f = Number.parseInt(`${c}`, 10);
    return f += c % 1 * 10 ** -Math.ceil(Math.log(l) / Math.LN10) * l, y.create(f);
  }
}
class Bd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 5);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    let u = o != null ? o : y.create(0);
    u.isNull() && (u = y.create(0));
    const { isError: c, errorObject: l, variants: f } = Ye(e, t, r, n, s, u);
    if (c)
      return l;
    const [m, d, _, C, E, R] = f, b = H(m);
    if (typeof b != "number")
      return b;
    const p = H(d);
    if (typeof p != "number")
      return p;
    const V = +_.getValue(), S = +C.getValue(), M = Math.floor(+E.getValue()), D = Math.floor(+R.getValue());
    if (Number.isNaN(V) || Number.isNaN(S) || Number.isNaN(M) || Number.isNaN(D))
      return g.create(h.VALUE);
    if (V < 0 || S < 0 || ![1, 2, 4].includes(M) || D < 0 || D > 4 || Math.floor(b) >= Math.floor(p) || b <= 0 || p <= 366)
      return g.create(h.NUM);
    const w = uc(b, p, V, S, M, D);
    return y.create(w);
  }
}
class Fd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = W(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue();
    let l = Math.floor(+u.getValue());
    if (Number.isNaN(c) || Number.isNaN(l))
      return g.create(h.VALUE);
    if (c <= 0 || l < 1)
      return g.create(h.NUM);
    l = Number.parseInt(`${l}`, 10);
    const f = (1 + c / l) ** l - 1;
    return y.create(f);
  }
}
class kd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 5);
    A(this, "needsLocale", !0);
  }
  calculate(e, t, r, n, s) {
    const o = n != null ? n : y.create(0), u = s != null ? s : y.create(0), c = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1
    ), l = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1
    ), f = O(c, l, e, g.create(h.NA)), m = O(c, l, t, g.create(h.NA)), d = O(c, l, r, g.create(h.NA)), _ = O(c, l, o, g.create(h.NA)), C = O(c, l, u, g.create(h.NA)), E = f.map((R, b, p) => {
      const V = m.get(b, p), S = d.get(b, p), M = _.get(b, p), D = C.get(b, p), { isError: w, errorObject: L, variants: v } = I(R, V, S, M, D);
      if (w)
        return L;
      const [j, k, G, ne, z] = v, $ = +j.getValue(), ge = +k.getValue(), Ce = +G.getValue(), be = +ne.getValue(), Ne = +z.getValue(), he = cr($, ge, Ce, be, Ne ? 1 : 0);
      return Number.isNaN(he) || !Number.isFinite(he) ? g.create(h.NUM) : b === 0 && p === 0 ? y.create(he, et(this.getLocale())) : y.create(he);
    });
    return c === 1 && l === 1 ? E.get(0, 0) : E;
  }
}
class $d extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = W(e);
    if (r)
      return n;
    const [o] = s, u = +o.getValue();
    if (Number.isNaN(u))
      return g.create(h.VALUE);
    let c = u;
    if (t.isArray()) {
      const l = t.getArrayValue().flat();
      for (let f = 0; f < l.length; f++) {
        const m = l[f];
        if (m.isBoolean())
          return g.create(h.VALUE);
        const d = +m.getValue();
        if (Number.isNaN(d))
          return g.create(h.VALUE);
        c *= 1 + d;
      }
    } else {
      if (t.isBoolean())
        return g.create(h.VALUE);
      const l = +t.getValue();
      if (Number.isNaN(l))
        return g.create(h.VALUE);
      c *= 1 + l;
    }
    return y.create(c);
  }
}
class Yd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    const o = s != null ? s : y.create(0), { isError: u, errorObject: c, variants: l } = W(e, t, r, n, o);
    if (u)
      return c;
    const [f, m, d, _, C] = l, E = H(f);
    if (typeof E != "number")
      return E;
    const R = H(m);
    if (typeof R != "number")
      return R;
    const b = +d.getValue(), p = +_.getValue(), V = Math.floor(+C.getValue());
    if (Number.isNaN(b) || Number.isNaN(p) || Number.isNaN(V))
      return g.create(h.VALUE);
    if (b <= 0 || p <= 0 || V < 0 || V > 4 || Math.floor(E) >= Math.floor(R))
      return g.create(h.NUM);
    const { days: S, yearDays: M } = _e(E, R, V), D = (p - b) / b * (M / S);
    return y.create(D);
  }
}
class Hd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 6);
    A(this, "needsLocale", !0);
  }
  calculate(e, t, r, n, s, o) {
    const u = s != null ? s : y.create(0), c = o != null ? o : y.create(0), l = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), m = O(l, f, e, g.create(h.NA)), d = O(l, f, t, g.create(h.NA)), _ = O(l, f, r, g.create(h.NA)), C = O(l, f, n, g.create(h.NA)), E = O(l, f, u, g.create(h.NA)), R = O(l, f, c, g.create(h.NA)), b = m.map((p, V, S) => {
      const M = d.get(V, S), D = _.get(V, S), w = C.get(V, S), L = E.get(V, S), v = R.get(V, S), { isError: j, errorObject: k, variants: G } = I(p, M, D, w, L, v);
      if (j)
        return k;
      const [ne, z, $, ge, Ce, be] = G, Ne = +ne.getValue(), he = +z.getValue(), Be = +$.getValue(), Ct = +ge.getValue(), jt = +Ce.getValue(), Ut = +be.getValue();
      if (he < 1 || Math.floor(he) > Math.ceil(Be))
        return g.create(h.NUM);
      const ct = cc(Ne, he, Be, Ct, jt, Ut ? 1 : 0);
      return Number.isNaN(ct) || !Number.isFinite(ct) ? g.create(h.NUM) : V === 0 && S === 0 ? y.create(ct, et(this.getLocale())) : y.create(ct);
    });
    return l === 1 && f === 1 ? b.get(0, 0) : b;
  }
}
class Gd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = t != null ? t : y.create(0.1);
    return r.isNull() && (r = y.create(0.1)), r.isArray() ? r.map((n, s, o) => this._handleSingleObject(e, n, s, o)) : this._handleSingleObject(e, r);
  }
  _handleSingleObject(e, t, r = 0, n = 0) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (e.isNull())
      return g.create(h.VALUE);
    if (!e.isArray())
      return g.create(h.NUM);
    const { _values: s, valuesHasError: o } = this._getValues(e);
    if (o)
      return g.create(h.VALUE);
    let u = t;
    if (u.isString() && (u = u.convertToNumberObjectValue(), u.isError()))
      return u;
    const c = +u.getValue(), { positive: l, negative: f } = this._checkValues(s);
    if (!l || !f)
      return g.create(h.NUM);
    const m = Ja(c, (d) => lc(d, s));
    return typeof m != "number" ? m : r === 0 && n === 0 ? y.create(m, "0%") : y.create(m);
  }
  _getValues(e) {
    const t = [];
    let r = !1;
    return e.iterator((n) => {
      const s = n;
      if (s.isError())
        return r = !0, !1;
      if (s.isNull() || s.isBoolean() || s.isString() && s.getValue() === "")
        return !0;
      const o = +s.getValue();
      if (Number.isNaN(o))
        return !0;
      t.push(o);
    }), {
      _values: t,
      valuesHasError: r
    };
  }
  _checkValues(e) {
    let t = !1, r = !1;
    for (let n = 0; n < e.length; n++)
      e[n] > 0 && (t = !0), e[n] < 0 && (r = !0);
    return {
      positive: t,
      negative: r
    };
  }
}
class Wd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(h.NA)), c = O(s, o, t, g.create(h.NA)), l = O(s, o, r, g.create(h.NA)), f = O(s, o, n, g.create(h.NA)), m = u.map((d, _, C) => {
      const E = c.get(_, C), R = l.get(_, C), b = f.get(_, C), { isError: p, errorObject: V, variants: S } = I(d, E, R, b);
      if (p)
        return V;
      const [M, D, w, L] = S, v = +M.getValue(), j = +D.getValue(), k = +w.getValue(), G = +L.getValue();
      if (k === 0)
        return g.create(h.DIV_BY_ZERO);
      const ne = G * v * (j / k - 1);
      return y.create(ne);
    });
    return s === 1 && o === 1 ? m.get(0, 0) : m;
  }
}
class Qd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 5);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    let u = o != null ? o : y.create(0);
    u.isNull() && (u = y.create(0));
    const { isError: c, errorObject: l, variants: f } = Ye(e, t, r, n, s, u);
    if (c)
      return l;
    const [m, d, _, C, E, R] = f, b = H(m);
    if (typeof b != "number")
      return b;
    const p = H(d);
    if (typeof p != "number")
      return p;
    const V = +_.getValue(), S = +C.getValue(), M = Math.floor(+E.getValue()), D = Math.floor(+R.getValue());
    if (Number.isNaN(V) || Number.isNaN(S) || Number.isNaN(M) || Number.isNaN(D))
      return g.create(h.VALUE);
    if (V < 0 || S < 0 || ![1, 2, 4].includes(M) || D < 0 || D > 4 || Math.floor(b) >= Math.floor(p))
      return g.create(h.NUM);
    let w = uc(b, p, V, S, M, D);
    return w /= 1 + S / M, y.create(w);
  }
}
class qd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { _values: n, numberValues: s, positive: o, negative: u } = this._getValues(e), c = Math.max(
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), l = Math.max(
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), f = O(c, l, t, g.create(h.NA)), m = O(c, l, r, g.create(h.NA)), d = f.map((_, C, E) => {
      const R = m.get(C, E);
      if (e.isError())
        return e;
      if (R.isError())
        return R;
      if (n.isError())
        return n;
      if (!o || !u)
        return g.create(h.DIV_BY_ZERO);
      const b = +_.getValue(), p = +R.getValue();
      if (Number.isNaN(b) || Number.isNaN(p))
        return g.create(h.VALUE);
      if (p === -1)
        return g.create(h.DIV_BY_ZERO);
      const V = this._getResult(s, b, p);
      return C === 0 && E === 0 ? y.create(V, "0%") : y.create(V);
    });
    return c === 1 && l === 1 ? d.get(0, 0) : d;
  }
  _getValues(e) {
    let t = e, r = [], n = !1, s = !1;
    if (!e.isError())
      if (e.isNull())
        t = g.create(h.VALUE);
      else if (!e.isArray())
        t = g.create(h.DIV_BY_ZERO);
      else {
        const { numberValues: o, valuesHasError: u, errorObject: c, positive: l, negative: f } = this._checkValues(e);
        u && (t = c), r = o, n = l, s = f;
      }
    return {
      _values: t,
      numberValues: r,
      positive: n,
      negative: s
    };
  }
  _checkValues(e) {
    const t = [];
    let r = !1, n = g.create(h.VALUE), s = !1, o = !1;
    return e.iterator((u) => {
      const c = u;
      if (c.isError())
        return r = !0, n = c, !1;
      if (c.isNull() || c.isBoolean() || c.isString() && c.getValue() === "")
        return !0;
      const l = +c.getValue();
      if (Number.isNaN(l))
        return !0;
      l > 0 && (s = !0), l < 0 && (o = !0), t.push(l);
    }), {
      numberValues: t,
      valuesHasError: r,
      errorObject: n,
      positive: s,
      negative: o
    };
  }
  _getResult(e, t, r) {
    const n = e.length, s = [], o = [];
    for (let d = 0; d < n; d++)
      e[d] > 0 ? o.push(e[d]) : e[d] < 0 && s.push(e[d]);
    const u = this._npv(r, e, "positive"), c = this._npv(t, e, "negative"), l = -u * (1 + r) ** n, f = c * (1 + t);
    return (l / f) ** (1 / (n - 1)) - 1;
  }
  _npv(e, t, r) {
    let n = 0;
    for (let s = 1; s <= t.length; s++) {
      const o = t[s - 1];
      (r === "positive" && o > 0 || r === "negative" && o < 0) && (n += o / (1 + e) ** s);
    }
    return n;
  }
}
class Xd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = W(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue();
    let l = Math.floor(+u.getValue());
    if (Number.isNaN(c) || Number.isNaN(l))
      return g.create(h.VALUE);
    if (c <= 0 || l < 1)
      return g.create(h.NUM);
    l = Number.parseInt(`${l}`, 10);
    const f = ((c + 1) ** (1 / l) - 1) * l;
    return y.create(f);
  }
}
class Kd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    const o = n != null ? n : y.create(0), u = s != null ? s : y.create(0), c = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1
    ), l = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1
    ), f = O(c, l, e, g.create(h.NA)), m = O(c, l, t, g.create(h.NA)), d = O(c, l, r, g.create(h.NA)), _ = O(c, l, o, g.create(h.NA)), C = O(c, l, u, g.create(h.NA)), E = f.map((R, b, p) => {
      const V = m.get(b, p), S = d.get(b, p), M = _.get(b, p), D = C.get(b, p), { isError: w, errorObject: L, variants: v } = I(R, V, S, M, D);
      if (w)
        return L;
      const [j, k, G, ne, z] = v, $ = +j.getValue(), ge = +k.getValue(), Ce = +G.getValue(), be = +ne.getValue();
      let Ne = +z.getValue();
      if (Ne = Ne ? 1 : 0, $ === 0 && ge === 0)
        return g.create(h.DIV_BY_ZERO);
      let he;
      if ($ === 0)
        he = -(Ce + be) / ge;
      else {
        const Be = ge * (1 + $ * Ne) - be * $, Ct = Ce * $ + ge * (1 + $ * Ne);
        he = Math.log(Be / Ct) / Math.log(1 + $);
      }
      return Number.isNaN(he) || !Number.isFinite(he) ? g.create(h.NUM) : y.create(he);
    });
    return c === 1 && l === 1 ? E.get(0, 0) : E;
  }
}
class Zd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
    A(this, "needsLocale", !0);
  }
  calculate(e, ...t) {
    if (e.isError())
      return e;
    const { isError: r, errorObject: n, values: s } = this._getValues(t);
    return e.isArray() ? e.map((o, u, c) => this._handleSingleObject(o, r, n, s, u, c)) : this._handleSingleObject(e, r, n, s);
  }
  _handleSingleObject(e, t, r, n, s = 0, o = 0) {
    let u = e;
    if (u.isString() && (u = u.convertToNumberObjectValue()), u.isError())
      return u;
    if (t)
      return r;
    const c = +e.getValue(), l = lc(c, n);
    return Number.isNaN(l) || Math.abs(l) === 1 / 0 ? g.create(h.DIV_BY_ZERO) : s === 0 && o === 0 ? y.create(l, et(this.getLocale())) : y.create(l);
  }
  _getValues(e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      if (n.isError())
        return {
          isError: !0,
          errorObject: n
        };
      if (n.isArray()) {
        let s = !1, o = g.create(h.VALUE);
        if (n.iterator((u) => {
          const c = u;
          if (c.isError())
            return s = !0, o = c, !1;
          if (c.isNull() || c.isBoolean() || c.isString() && c.getValue() === "")
            return !0;
          const l = +c.getValue();
          if (Number.isNaN(l))
            return !0;
          t.push(l);
        }), s)
          return {
            isError: s,
            errorObject: o
          };
      } else {
        const s = +n.getValue();
        if (Number.isNaN(s))
          return {
            isError: !0,
            errorObject: g.create(h.VALUE)
          };
        t.push(s);
      }
    }
    return {
      isError: !1,
      values: t
    };
  }
}
class zd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 8);
    A(this, "maxParams", 9);
  }
  calculate(e, t, r, n, s, o, u, c, l) {
    let f = l != null ? l : y.create(0);
    f.isNull() && (f = y.create(0));
    const { isError: m, errorObject: d, variants: _ } = Ye(e, t, r, n, s, o, u, c, f);
    if (m)
      return d;
    const [C, E, R, b, p, V, S, M, D] = _, w = H(C);
    if (typeof w != "number")
      return w;
    const L = H(E);
    if (typeof L != "number")
      return L;
    const v = H(R);
    if (typeof v != "number")
      return v;
    const j = H(b);
    if (typeof j != "number")
      return j;
    const k = +p.getValue(), G = +V.getValue(), ne = +S.getValue(), z = Math.floor(+M.getValue()), $ = Math.floor(+D.getValue());
    if (Number.isNaN(k) || Number.isNaN(G) || Number.isNaN(ne) || Number.isNaN(z) || Number.isNaN($))
      return g.create(h.VALUE);
    if (k < 0 || G < 0 || ne <= 0 || ![1, 2, 4].includes(z) || $ < 0 || $ > 4 || !this._validDate(L, j, w, v, z))
      return g.create(h.NUM);
    const ge = fc(w, L, v, j, k, G, ne, z, $);
    return y.create(ge);
  }
  _validDate(e, t, r, n, s) {
    return this._getDateCorrectOrder(e, t, r, n) && mc(e, t, s) && Ur(n, e, s);
  }
  _getDateCorrectOrder(e, t, r, n) {
    return Math.floor(e) > Math.floor(t) && Math.floor(t) > Math.floor(r) && Math.floor(r) > Math.floor(n);
  }
}
class Jd extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 8);
    A(this, "maxParams", 9);
  }
  calculate(e, t, r, n, s, o, u, c, l) {
    let f = l != null ? l : y.create(0);
    f.isNull() && (f = y.create(0));
    const { isError: m, errorObject: d, variants: _ } = Ye(e, t, r, n, s, o, u, c, f);
    if (m)
      return d;
    const [C, E, R, b, p, V, S, M, D] = _, w = H(C);
    if (typeof w != "number")
      return w;
    const L = H(E);
    if (typeof L != "number")
      return L;
    const v = H(R);
    if (typeof v != "number")
      return v;
    const j = H(b);
    if (typeof j != "number")
      return j;
    const k = +p.getValue(), G = +V.getValue(), ne = +S.getValue(), z = Math.floor(+M.getValue()), $ = Math.floor(+D.getValue());
    return Number.isNaN(k) || Number.isNaN(G) || Number.isNaN(ne) || Number.isNaN(z) || Number.isNaN($) ? g.create(h.VALUE) : k < 0 || G <= 0 || ne <= 0 || ![1, 2, 4].includes(z) || $ < 0 || $ > 4 || !this._validDate(L, j, w, v, z) ? g.create(h.NUM) : this._getResult(w, L, v, j, k, G, ne, z, $);
  }
  _validDate(e, t, r, n, s) {
    return this._getDateCorrectOrder(e, t, r, n) && mc(e, t, s) && Ur(n, e, s);
  }
  _getDateCorrectOrder(e, t, r, n) {
    return Math.floor(e) > Math.floor(t) && Math.floor(t) > Math.floor(r) && Math.floor(r) > Math.floor(n);
  }
  _getResult(e, t, r, n, s, o, u, c, l) {
    const { days: f } = _e(e, t, l), m = (s * f * 100 - (o - 100)) / ((o - 100) * 0.25 * (1 + 2 * f) + f * 100);
    function d(C) {
      return o - fc(e, t, r, n, s, C, u, c, l);
    }
    const _ = Ja(m, (C) => d(C));
    return typeof _ != "number" ? _ : y.create(_);
  }
}
class e0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 7);
    A(this, "maxParams", 8);
  }
  calculate(e, t, r, n, s, o, u, c) {
    let l = c != null ? c : y.create(0);
    l.isNull() && (l = y.create(0));
    const { isError: f, errorObject: m, variants: d } = Ye(e, t, r, n, s, o, u, l);
    if (f)
      return m;
    const [_, C, E, R, b, p, V, S] = d, M = H(_);
    if (typeof M != "number")
      return M;
    const D = H(C);
    if (typeof D != "number")
      return D;
    const w = H(E);
    if (typeof w != "number")
      return w;
    const L = +R.getValue(), v = +b.getValue(), j = +p.getValue(), k = Math.floor(+V.getValue()), G = Math.floor(+S.getValue());
    if (Number.isNaN(L) || Number.isNaN(v) || Number.isNaN(j) || Number.isNaN(k) || Number.isNaN(G))
      return g.create(h.VALUE);
    if (L < 0 || v < 0 || j <= 0 || ![1, 2, 4].includes(k) || G < 0 || G > 4 || !this._validDate(D, M, w, k))
      return g.create(h.NUM);
    const ne = this._getResult(M, D, w, L, v, j, k, G);
    return y.create(ne);
  }
  _validDate(e, t, r, n) {
    return Math.floor(e) > Math.floor(t) && Math.floor(t) > Math.floor(r) && Ur(r, e, n);
  }
  _getResult(e, t, r, n, s, o, u, c) {
    const l = this._getCoupDate(t, r, u), f = this._getFrac(r, e, l, u, c), m = this._getFrac(r, t, l, u, c), d = this._getFrac(e, t, l, u, c);
    return (o * u + 100 * n * (m - f * (1 + s * d / u))) / (s * d + u);
  }
  _getCoupDate(e, t, r) {
    const n = ae(e), s = ae(t);
    for (s.setUTCFullYear(n.getUTCFullYear()), s > n && s.setUTCFullYear(s.getUTCFullYear() - 1); s < n; )
      s.setUTCMonth(s.getUTCMonth() + 12 / r);
    return pe(s);
  }
  _getFrac(e, t, r, n, s) {
    const o = ae(e), u = ae(t), c = ae(r);
    for (c.setUTCFullYear(o.getUTCFullYear()), c < o && c.setUTCFullYear(c.getUTCFullYear() + 1); c > o; )
      c.setUTCMonth(c.getUTCMonth() - 12 / n);
    let l = pe(c);
    c.setUTCMonth(c.getUTCMonth() + 12 / n);
    let f = pe(c);
    if (f >= t) {
      const { days: p } = _e(e, t, s), V = ze(l, f, n, s);
      return p / V;
    }
    const { days: m } = _e(e, f, s), d = ze(l, f, n, s);
    let _ = m / d;
    const C = ae(f), E = ae(f);
    for (E.setUTCMonth(E.getUTCMonth() + 12 / n); E < u; )
      C.setUTCMonth(C.getUTCMonth() + 12 / n), E.setUTCMonth(E.getUTCMonth() + 12 / n), _ += 1;
    l = pe(C), f = pe(E);
    const { days: R } = _e(l, t, s), b = ze(l, f, n, s);
    return _ += R / b, _;
  }
}
class t0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 8);
    A(this, "maxParams", 9);
  }
  calculate(e, t, r, n, s, o, u, c) {
    let l = c != null ? c : y.create(0);
    l.isNull() && (l = y.create(0));
    const { isError: f, errorObject: m, variants: d } = Ye(e, t, r, n, s, o, u, l);
    if (f)
      return m;
    const [_, C, E, R, b, p, V, S] = d, M = H(_);
    if (typeof M != "number")
      return M;
    const D = H(C);
    if (typeof D != "number")
      return D;
    const w = H(E);
    if (typeof w != "number")
      return w;
    const L = +R.getValue(), v = +b.getValue(), j = +p.getValue(), k = Math.floor(+V.getValue()), G = Math.floor(+S.getValue());
    if (Number.isNaN(L) || Number.isNaN(v) || Number.isNaN(j) || Number.isNaN(k) || Number.isNaN(G))
      return g.create(h.VALUE);
    if (L < 0 || v <= 0 || j <= 0 || ![1, 2, 4].includes(k) || G < 0 || G > 4 || !this._validDate(D, M, w, k))
      return g.create(h.NUM);
    const ne = this._getResult(M, D, w, L, v, j, k, G);
    return y.create(ne);
  }
  _validDate(e, t, r, n) {
    return Math.floor(e) > Math.floor(t) && Math.floor(t) > Math.floor(r) && Ur(r, e, n);
  }
  _getResult(e, t, r, n, s, o, u, c) {
    const l = this._getCoupDate(t, r, u), f = this._getFrac(r, e, l, u, c), m = this._getFrac(r, t, l, u, c), d = this._getFrac(e, t, l, u, c);
    return (u * (o - s) + 100 * n * (m - f)) / (d * s + 100 * n * f * d / u);
  }
  _getCoupDate(e, t, r) {
    const n = ae(e), s = ae(t);
    for (s.setUTCFullYear(n.getUTCFullYear()), s > n && s.setUTCFullYear(s.getUTCFullYear() - 1); s < n; )
      s.setUTCMonth(s.getUTCMonth() + 12 / r);
    return pe(s);
  }
  _getFrac(e, t, r, n, s) {
    const o = ae(e), u = ae(t), c = ae(r);
    for (c.setUTCFullYear(o.getUTCFullYear()), c < o && c.setUTCFullYear(c.getUTCFullYear() + 1); c > o; )
      c.setUTCMonth(c.getUTCMonth() - 12 / n);
    let l = pe(c);
    c.setUTCMonth(c.getUTCMonth() + 12 / n);
    let f = pe(c);
    if (f >= t) {
      const { days: p } = _e(e, t, s), V = ze(l, f, n, s);
      return p / V;
    }
    const { days: m } = _e(e, f, s), d = ze(l, f, n, s);
    let _ = m / d;
    const C = ae(f), E = ae(f);
    for (E.setUTCMonth(E.getUTCMonth() + 12 / n); E < u; )
      C.setUTCMonth(C.getUTCMonth() + 12 / n), E.setUTCMonth(E.getUTCMonth() + 12 / n), _ += 1;
    l = pe(C), f = pe(E);
    const { days: R } = _e(l, t, s), b = ze(l, f, n, s);
    return _ += R / b, _;
  }
}
class r0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, t, g.create(h.NA)), c = O(n, s, r, g.create(h.NA)), l = o.map((f, m, d) => {
      const _ = u.get(m, d), C = c.get(m, d), { isError: E, errorObject: R, variants: b } = I(f, _, C);
      if (E)
        return R;
      const [p, V, S] = b, M = +p.getValue(), D = +V.getValue(), w = +S.getValue();
      if (M <= -1)
        return g.create(h.NUM);
      const L = (Math.log(w) - Math.log(D)) / Math.log(1 + M);
      return Number.isNaN(L) || !Number.isFinite(L) ? g.create(h.NUM) : y.create(L);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
}
class n0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 5);
    A(this, "needsLocale", !0);
  }
  calculate(e, t, r, n, s) {
    const o = n != null ? n : y.create(0), u = s != null ? s : y.create(0), c = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1
    ), l = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1
    ), f = O(c, l, e, g.create(h.NA)), m = O(c, l, t, g.create(h.NA)), d = O(c, l, r, g.create(h.NA)), _ = O(c, l, o, g.create(h.NA)), C = O(c, l, u, g.create(h.NA)), E = f.map((R, b, p) => {
      const V = m.get(b, p), S = d.get(b, p), M = _.get(b, p), D = C.get(b, p), { isError: w, errorObject: L, variants: v } = I(R, V, S, M, D);
      if (w)
        return L;
      const [j, k, G, ne, z] = v, $ = +j.getValue(), ge = +k.getValue(), Ce = +G.getValue(), be = +ne.getValue(), Ne = +z.getValue();
      if ($ <= -1)
        return g.create(h.NUM);
      const he = nn($, ge, Ce, be, Ne ? 1 : 0);
      return Number.isNaN(he) || !Number.isFinite(he) ? g.create(h.NUM) : b === 0 && p === 0 ? y.create(he, et(this.getLocale())) : y.create(he);
    });
    return c === 1 && l === 1 ? E.get(0, 0) : E;
  }
}
class s0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 6);
    A(this, "needsLocale", !0);
  }
  calculate(e, t, r, n, s, o) {
    const u = s != null ? s : y.create(0), c = o != null ? o : y.create(0), l = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), m = O(l, f, e, g.create(h.NA)), d = O(l, f, t, g.create(h.NA)), _ = O(l, f, r, g.create(h.NA)), C = O(l, f, n, g.create(h.NA)), E = O(l, f, u, g.create(h.NA)), R = O(l, f, c, g.create(h.NA)), b = m.map((p, V, S) => {
      const M = d.get(V, S), D = _.get(V, S), w = C.get(V, S), L = E.get(V, S), v = R.get(V, S), { isError: j, errorObject: k, variants: G } = I(p, M, D, w, L, v);
      if (j)
        return k;
      const [ne, z, $, ge, Ce, be] = G, Ne = +ne.getValue(), he = +z.getValue(), Be = +$.getValue(), Ct = +ge.getValue(), jt = +Ce.getValue(), Ut = +be.getValue();
      if (he < 1 || Math.floor(he) > Math.ceil(Be) || he - Be >= 1)
        return g.create(h.NUM);
      const ct = nn(Ne, Be, Ct, jt, Ut ? 1 : 0) - cc(Ne, he, Be, Ct, jt, Ut ? 1 : 0);
      return Number.isNaN(ct) || !Number.isFinite(ct) ? g.create(h.NUM) : V === 0 && S === 0 ? y.create(ct, et(this.getLocale())) : y.create(ct);
    });
    return l === 1 && f === 1 ? b.get(0, 0) : b;
  }
}
class a0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 6);
    A(this, "maxParams", 7);
  }
  calculate(e, t, r, n, s, o, u) {
    let c = u != null ? u : y.create(0);
    c.isNull() && (c = y.create(0));
    const { isError: l, errorObject: f, variants: m } = Ye(e, t, r, n, s, o, c);
    if (l)
      return f;
    const [d, _, C, E, R, b, p] = m, V = H(d);
    if (typeof V != "number")
      return V;
    const S = H(_);
    if (typeof S != "number")
      return S;
    const M = +C.getValue(), D = +E.getValue(), w = +R.getValue(), L = Math.floor(+b.getValue()), v = Math.floor(+p.getValue());
    if (Number.isNaN(M) || Number.isNaN(D) || Number.isNaN(w) || Number.isNaN(L) || Number.isNaN(v))
      return g.create(h.VALUE);
    if (M < 0 || D < 0 || w <= 0 || ![1, 2, 4].includes(L) || v < 0 || v > 4 || V >= S || !Ur(V, S, L))
      return g.create(h.NUM);
    const j = pn(V, S, M, D, w, L, v);
    return y.create(j);
  }
}
class i0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    let o = s != null ? s : y.create(0);
    o.isNull() && (o = y.create(0));
    const { isError: u, errorObject: c, variants: l } = Ye(e, t, r, n, o);
    if (u)
      return c;
    const [f, m, d, _, C] = l, E = H(f);
    if (typeof E != "number")
      return E;
    const R = H(m);
    if (typeof R != "number")
      return R;
    const b = +d.getValue(), p = +_.getValue(), V = Math.floor(+C.getValue());
    if (Number.isNaN(b) || Number.isNaN(p) || Number.isNaN(V))
      return g.create(h.VALUE);
    if (b <= 0 || p <= 0 || V < 0 || V > 4 || E >= R)
      return g.create(h.NUM);
    const { days: S, yearDays: M } = _e(E, R, V), D = p - b * p * S / M;
    return y.create(D);
  }
}
class o0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 5);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    let u = o != null ? o : y.create(0);
    u.isNull() && (u = y.create(0));
    const { isError: c, errorObject: l, variants: f } = Ye(e, t, r, n, s, u);
    if (c)
      return l;
    const [m, d, _, C, E, R] = f, b = H(m);
    if (typeof b != "number")
      return b;
    const p = H(d);
    if (typeof p != "number")
      return p;
    const V = H(_);
    if (typeof V != "number")
      return V;
    const S = +C.getValue(), M = +E.getValue(), D = Math.floor(+R.getValue());
    if (Number.isNaN(S) || Number.isNaN(M) || Number.isNaN(D))
      return g.create(h.VALUE);
    const w = this._getDateCorrectOrder(p, b, V);
    if (S < 0 || M < 0 || D < 0 || D > 4 || !w)
      return g.create(h.NUM);
    const L = ic(b, D), { days: v } = _e(b, p, D), { days: j } = _e(V, p, D), { days: k } = _e(V, b, D), G = (100 + j / L * S * 100) / (1 + v / L * M) - k / L * S * 100;
    return y.create(G);
  }
  _getDateCorrectOrder(e, t, r) {
    return Math.floor(e) > Math.floor(t) && Math.floor(t) > Math.floor(r);
  }
}
class u0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 5);
    A(this, "needsLocale", !0);
  }
  calculate(e, t, r, n, s) {
    const o = n != null ? n : y.create(0), u = s != null ? s : y.create(0), c = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1
    ), l = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1
    ), f = O(c, l, e, g.create(h.NA)), m = O(c, l, t, g.create(h.NA)), d = O(c, l, r, g.create(h.NA)), _ = O(c, l, o, g.create(h.NA)), C = O(c, l, u, g.create(h.NA)), E = f.map((R, b, p) => {
      const V = m.get(b, p), S = d.get(b, p), M = _.get(b, p), D = C.get(b, p), { isError: w, errorObject: L, variants: v } = I(R, V, S, M, D);
      if (w)
        return L;
      const [j, k, G, ne, z] = v, $ = +j.getValue(), ge = +k.getValue(), Ce = +G.getValue(), be = +ne.getValue();
      let Ne = +z.getValue();
      Ne = Ne ? 1 : 0;
      const he = $ === 0 ? -Ce * ge - be : ((1 - (1 + $) ** ge) / $ * Ce * (1 + $ * Ne) - be) / (1 + $) ** ge;
      return Number.isNaN(he) || !Number.isFinite(he) ? g.create(h.NUM) : b === 0 && p === 0 ? y.create(he, et(this.getLocale())) : y.create(he);
    });
    return c === 1 && l === 1 ? E.get(0, 0) : E;
  }
}
class c0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    const u = n != null ? n : y.create(0), c = s != null ? s : y.create(0), l = o != null ? o : y.create(0.1), f = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1,
      l.isArray() ? l.getRowCount() : 1
    ), m = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1,
      l.isArray() ? l.getColumnCount() : 1
    ), d = O(f, m, e, g.create(h.NA)), _ = O(f, m, t, g.create(h.NA)), C = O(f, m, r, g.create(h.NA)), E = O(f, m, u, g.create(h.NA)), R = O(f, m, c, g.create(h.NA)), b = O(f, m, l, g.create(h.NA)), p = d.map((V, S, M) => {
      const D = _.get(S, M), w = C.get(S, M), L = E.get(S, M), v = R.get(S, M), j = b.get(S, M), { isError: k, errorObject: G, variants: ne } = I(V, D, w, L, v, j);
      if (k)
        return G;
      const [z, $, ge, Ce, be, Ne] = ne, he = +z.getValue(), Be = +$.getValue(), Ct = +ge.getValue(), jt = +Ce.getValue();
      let Ut = +be.getValue();
      const ct = +Ne.getValue();
      if (Ut = Ut ? 1 : 0, he <= 0)
        return g.create(h.NUM);
      const pc = Be >= 0 && Ct >= 0 && jt >= 0, Nc = Be <= 0 && Ct <= 0 && jt <= 0;
      return pc || Nc ? g.create(h.NUM) : this._getResult(he, Be, Ct, jt, Ut, ct, S, M);
    });
    return f === 1 && m === 1 ? p.get(0, 0) : p;
  }
  _getResult(e, t, r, n, s, o, u, c) {
    if (Math.abs(t) < 1e-14)
      return this._computeSimpleGrowthRate(e, r, n, u, c);
    let m = o, d = Number.POSITIVE_INFINITY;
    for (let _ = 0; _ < 100; _++) {
      if (m <= -1)
        return g.create(h.NUM);
      const { value: C, derivative: E } = this._evaluateRateFunction(
        m,
        e,
        t,
        r,
        n,
        s,
        1e-10
      ), R = Math.abs(C);
      if (R < 1e-10 || Math.abs(E) < 1e-14)
        break;
      const b = this._getAdaptiveDampedStep(C, E, R, d);
      m -= b, d = R;
    }
    return !Number.isFinite(m) || m <= -1 ? g.create(h.NUM) : y.create(m, u === 0 && c === 0 ? "0%" : void 0);
  }
  _computeSimpleGrowthRate(e, t, r, n, s) {
    if (Math.sign(t) === Math.sign(r))
      return g.create(h.NUM);
    const o = (r / -t) ** (1 / e) - 1;
    return y.create(o, n === 0 && s === 0 ? "0%" : void 0);
  }
  _evaluateRateFunction(e, t, r, n, s, o, u) {
    let c, l, f;
    if (Math.abs(e) < u)
      c = n * (1 + t * e) + r * (1 + e * o) * t + s, l = n * t + r * o * t;
    else {
      f = (1 + e) ** t, c = n * f + r * (1 / e + o) * (f - 1) + s;
      const m = t * (1 + e) ** (t - 1);
      l = n * m + r * (1 / e + o) * m + r * (-1 / (e * e)) * (f - 1);
    }
    return { value: c, derivative: l };
  }
  _getAdaptiveDampedStep(e, t, r, n) {
    const s = e / t;
    return r > 1e-3 || r >= n * 0.9 ? Math.max(Math.min(s, 5), -5) : Math.max(Math.min(s, 0.5), -0.5);
  }
}
class l0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    let o = s != null ? s : y.create(0);
    o.isNull() && (o = y.create(0));
    const { isError: u, errorObject: c, variants: l } = Ye(e, t, r, n, o);
    if (u)
      return c;
    const [f, m, d, _, C] = l, E = H(f);
    if (typeof E != "number")
      return E;
    const R = H(m);
    if (typeof R != "number")
      return R;
    const b = +d.getValue(), p = +_.getValue(), V = Math.floor(+C.getValue());
    if (Number.isNaN(b) || Number.isNaN(p) || Number.isNaN(V))
      return g.create(h.VALUE);
    if (b <= 0 || p <= 0 || V < 0 || V > 4 || E >= R)
      return g.create(h.NUM);
    const { days: S, yearDays: M } = _e(E, R, V), D = b / (1 - p * S / M);
    return D < 0 ? g.create(h.NUM) : y.create(D);
  }
}
class f0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, t, g.create(h.NA)), c = O(n, s, r, g.create(h.NA)), l = o.map((f, m, d) => {
      const _ = u.get(m, d), C = c.get(m, d), { isError: E, errorObject: R, variants: b } = I(f, _, C);
      if (E)
        return R;
      const [p, V, S] = b, M = +p.getValue(), D = +V.getValue(), w = +S.getValue();
      if (M <= 0)
        return g.create(h.NUM);
      if (D === 0 && w === 0)
        return y.create(0);
      const L = (w / D) ** (1 / M) - 1;
      return Number.isNaN(L) || !Number.isFinite(L) || w / D < 0 ? g.create(h.NUM) : y.create(L);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
}
class m0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
    A(this, "needsLocale", !0);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, t, g.create(h.NA)), c = O(n, s, r, g.create(h.NA)), l = o.map((f, m, d) => {
      const _ = u.get(m, d), C = c.get(m, d);
      if (_.isError())
        return _;
      if (C.isError())
        return C;
      const E = +f.getValue(), R = +_.getValue(), b = +C.getValue();
      if (Number.isNaN(E) || Number.isNaN(R) || Number.isNaN(b))
        return g.create(h.VALUE);
      if (b === 0)
        return g.create(h.DIV_BY_ZERO);
      const p = (E - R) / b;
      return m === 0 && d === 0 ? y.create(p, et(this.getLocale())) : y.create(p);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
}
class h0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
    A(this, "needsLocale", !0);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(h.NA)), c = O(s, o, t, g.create(h.NA)), l = O(s, o, r, g.create(h.NA)), f = O(s, o, n, g.create(h.NA)), m = u.map((d, _, C) => {
      const E = c.get(_, C), R = l.get(_, C), b = f.get(_, C);
      if (E.isError())
        return E;
      if (R.isError())
        return R;
      if (b.isError())
        return b;
      const p = +d.getValue(), V = +E.getValue(), S = +R.getValue(), M = +b.getValue();
      if (Number.isNaN(p) || Number.isNaN(V) || Number.isNaN(S) || Number.isNaN(M))
        return g.create(h.VALUE);
      if (V < 0 || S <= 0 || M > S)
        return g.create(h.NUM);
      const D = (p - V) * (S - M + 1) * 2 / (S * (S + 1));
      return _ === 0 && C === 0 ? y.create(D, et(this.getLocale())) : y.create(D);
    });
    return s === 1 && o === 1 ? m.get(0, 0) : m;
  }
}
class g0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = Ye(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = H(u);
    if (typeof f != "number")
      return f;
    const m = H(c);
    if (typeof m != "number")
      return m;
    const d = +l.getValue();
    if (Number.isNaN(d))
      return g.create(h.VALUE);
    if (d <= 0 || f >= m)
      return g.create(h.NUM);
    const _ = Math.floor(m) - Math.floor(f), E = ae(f).getUTCFullYear(), R = _s(E);
    if (_ > R)
      return g.create(h.NUM);
    let b = 365 * d / (360 - d * _);
    if (_ > 182) {
      const p = 100 * (1 - d * _ / 360), V = _ / 365;
      if (b = (-V + Math.sqrt(V * V - (V * 2 - 1) * (1 - 100 / p))) / (V - 0.5), Number.isNaN(b))
        return g.create(h.NUM);
    }
    return b < 0 ? g.create(h.NUM) : y.create(b);
  }
}
class d0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
    A(this, "needsLocale", !0);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = Ye(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = H(u);
    if (typeof f != "number")
      return f;
    const m = H(c);
    if (typeof m != "number")
      return m;
    const d = +l.getValue();
    if (Number.isNaN(d))
      return g.create(h.VALUE);
    if (d <= 0 || f >= m)
      return g.create(h.NUM);
    const _ = Math.floor(m) - Math.floor(f), E = ae(f).getUTCFullYear(), R = _s(E);
    if (_ > R)
      return g.create(h.NUM);
    const b = 100 * (1 - d * _ / 360);
    return b < 0 ? g.create(h.NUM) : y.create(b, et(this.getLocale()));
  }
}
class C0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = Ye(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = H(u);
    if (typeof f != "number")
      return f;
    const m = H(c);
    if (typeof m != "number")
      return m;
    const d = +l.getValue();
    if (Number.isNaN(d))
      return g.create(h.VALUE);
    if (d <= 0 || f >= m)
      return g.create(h.NUM);
    const _ = Math.floor(m) - Math.floor(f), E = ae(f).getUTCFullYear(), R = _s(E);
    if (_ > R)
      return g.create(h.NUM);
    const b = (100 - d) / d * 360 / _;
    return y.create(b);
  }
}
class _0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 5);
    A(this, "maxParams", 7);
    A(this, "needsLocale", !0);
  }
  calculate(e, t, r, n, s, o, u) {
    let c = o != null ? o : y.create(2);
    c.isNull() && (c = y.create(2));
    let l = u != null ? u : T.create(!1);
    l.isNull() && (l = T.create(!1));
    const f = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1,
      l.isArray() ? l.getRowCount() : 1
    ), m = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1,
      l.isArray() ? l.getColumnCount() : 1
    ), d = O(f, m, e, g.create(h.NA)), _ = O(f, m, t, g.create(h.NA)), C = O(f, m, r, g.create(h.NA)), E = O(f, m, n, g.create(h.NA)), R = O(f, m, s, g.create(h.NA)), b = O(f, m, c, g.create(h.NA)), p = O(f, m, l, g.create(h.NA));
    return this._getResultArray(
      d,
      _,
      C,
      E,
      R,
      b,
      p,
      f,
      m
    );
  }
  _getResultArray(e, t, r, n, s, o, u, c, l) {
    const f = e.map((m, d, _) => {
      const C = t.get(d, _), E = r.get(d, _), R = n.get(d, _), b = s.get(d, _), p = o.get(d, _), V = u.get(d, _), { isError: S, errorObject: M, variants: D } = I(m, C, E, R, b, p, V);
      if (S)
        return M;
      const [w, L, v, j, k, G, ne] = D, z = +w.getValue(), $ = +L.getValue(), ge = +v.getValue(), Ce = +j.getValue(), be = +k.getValue(), Ne = +G.getValue(), he = +ne.getValue();
      if (z < 0 || $ < 0 || ge < 0 || Ce < 0 || be < 0 || be > ge || Ce > be || Ne < 0)
        return g.create(h.NUM);
      if (ge === 0 && Ce === 0 && be === 0)
        return g.create(h.DIV_BY_ZERO);
      const Be = this._getResult(z, $, ge, Ce, be, Ne, he);
      return d === 0 && _ === 0 ? y.create(Be, et(this.getLocale())) : y.create(Be);
    });
    return c === 1 && l === 1 ? f.get(0, 0) : f;
  }
  _getResult(e, t, r, n, s, o, u) {
    const c = Math.floor(n), l = Math.ceil(s);
    let f = 0;
    if (e < t) {
      if (n >= 1 || u)
        return f;
      const m = Math.abs(e - t);
      return f = m * (s - n) > m ? m : m * (s - n), -f;
    }
    if (u)
      for (let m = c + 1; m <= l; m++) {
        let d = ma(e, t, r, m, o);
        m === c + 1 ? d *= Math.min(s, c + 1) - n : m === l && (d *= s + 1 - l), f += d;
      }
    else {
      const m = e - this._getVdb(e, t, r, r, n, o);
      f = this._getVdb(m, t, r, r - n, s - n, o);
    }
    return f;
  }
  _getVdb(e, t, r, n, s, o) {
    const u = Math.ceil(s);
    let c = 0, l = e - t, f = 0, m = 0, d = !1;
    for (let _ = 1; _ <= u; _++) {
      if (d)
        m = f;
      else {
        const C = ma(e, t, r, _, o);
        f = l / (n - (_ - 1)), f > C ? (m = f, d = !0) : (m = C, l -= C);
      }
      _ === u && (m *= s + 1 - u), c += m;
    }
    return c;
  }
}
class A0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    if (e.isNull() || t.isNull())
      return g.create(h.NA);
    const { isError: n, errorObejct: s, _values: o, _dates: u } = this._checkErrors(e, t);
    if (n)
      return s;
    let c = r != null ? r : y.create(0.1);
    c.isNull() && (c = y.create(0.1));
    const { isError: l, errorObject: f, variants: m } = W(c);
    if (l)
      return f;
    const [d] = m, _ = +d.getValue();
    if (Number.isNaN(_))
      return g.create(h.VALUE);
    const { positive: C, negative: E } = this._checkValues(o);
    if (!C || !E || (o == null ? void 0 : o.length) !== (u == null ? void 0 : u.length) || _ < 0)
      return g.create(h.NUM);
    const R = Ja(_, (b) => this._iterF(o, u, b));
    return typeof R != "number" ? R : y.create(R);
  }
  _checkErrors(e, t) {
    if (e.isError())
      return {
        isError: !0,
        errorObejct: e
      };
    if (t.isError())
      return {
        isError: !0,
        errorObejct: t
      };
    const { isError: r, errorObejct: n, _values: s } = this._checkErrorValues(e);
    if (r)
      return {
        isError: r,
        errorObejct: n
      };
    const { isError: o, errorObejct: u, _dates: c } = this._checkErrorDates(t);
    return o ? {
      isError: o,
      errorObejct: u
    } : {
      isError: !1,
      _values: s,
      _dates: c
    };
  }
  _checkErrorValues(e) {
    const t = [];
    if (e.isArray()) {
      let r = !1, n = g.create(h.VALUE);
      return e.iterator((s) => {
        const o = s;
        if (o.isError())
          return r = !0, n = o, !1;
        if (o.isBoolean())
          return r = !0, n = g.create(h.VALUE), !1;
        const u = +o.getValue();
        if (Number.isNaN(u))
          return r = !0, n = g.create(h.VALUE), !1;
        t.push(u);
      }), r ? {
        isError: r,
        errorObejct: n
      } : t.length <= 1 ? {
        isError: !0,
        errorObejct: g.create(h.NA)
      } : {
        isError: r,
        _values: t
      };
    } else {
      const r = e.getValue();
      return e.isBoolean() || e.isString() && !q(r) ? {
        isError: !0,
        errorObejct: g.create(h.VALUE)
      } : {
        isError: !0,
        errorObejct: g.create(h.NA)
      };
    }
  }
  _checkErrorDates(e) {
    const t = [];
    if (e.isArray()) {
      let r = !1, n = g.create(h.VALUE);
      return e.iterator((s) => {
        if (s != null && s.isError())
          return r = !0, n = s, !1;
        if (s != null && s.isBoolean())
          return r = !0, n = g.create(h.VALUE), !1;
        const o = +s.getValue();
        if (Number.isNaN(o))
          return r = !0, n = g.create(h.VALUE), !1;
        if (o < 0)
          return r = !0, n = g.create(h.NUM), !1;
        t.push(Math.floor(o));
      }), r ? {
        isError: r,
        errorObejct: n
      } : t.length <= 1 ? {
        isError: !0,
        errorObejct: g.create(h.NA)
      } : {
        isError: r,
        _dates: t
      };
    } else {
      const r = e.getValue();
      return e.isBoolean() || e.isString() && !q(r) ? {
        isError: !0,
        errorObejct: g.create(h.VALUE)
      } : +r < 0 ? {
        isError: !0,
        errorObejct: g.create(h.NUM)
      } : {
        isError: !0,
        errorObejct: g.create(h.NA)
      };
    }
  }
  _checkValues(e) {
    let t = !1, r = !1;
    for (let n = 0; n < e.length; n++)
      e[n] > 0 && (t = !0), e[n] < 0 && (r = !0);
    return {
      positive: t,
      negative: r
    };
  }
  _iterF(e, t, r) {
    return e.reduce((n, s, o) => n + s / (1 + r) ** ((t[o] - t[0]) / 365), 0);
  }
}
class E0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    if (e.isNull() || t.isNull() || r.isNull())
      return g.create(h.NA);
    const { isError: n, errorObject: s, variants: o } = W(e);
    if (n)
      return s;
    const [u] = o, c = +u.getValue();
    if (Number.isNaN(c))
      return g.create(h.VALUE);
    let { isError: l, errorObejct: f, _values: m, _dates: d } = this._checkErrors(t, r);
    if (l)
      return f;
    if (m = m, d = d, c < 0 || m.length !== d.length)
      return g.create(h.NUM);
    let _ = 0;
    const C = d[0];
    for (let E = 0; E < d.length; E++) {
      const R = d[E], b = m[E];
      _ += b / (1 + c) ** ((R - C) / 365);
    }
    return y.create(_);
  }
  _checkErrors(e, t) {
    if (e.isError())
      return {
        isError: !0,
        errorObejct: e
      };
    if (t.isError())
      return {
        isError: !0,
        errorObejct: t
      };
    const { isError: r, errorObejct: n, _values: s } = this._checkErrorValues(e);
    if (r)
      return {
        isError: r,
        errorObejct: n
      };
    const { isError: o, errorObejct: u, _dates: c } = this._checkErrorDates(t);
    return o ? {
      isError: o,
      errorObejct: u
    } : {
      isError: !1,
      _values: s,
      _dates: c
    };
  }
  _checkErrorValues(e) {
    const t = [];
    if (e.isArray()) {
      let r = !1, n = g.create(h.VALUE);
      return e.iterator((s) => {
        const o = s;
        if (o.isError())
          return r = !0, n = o, !1;
        if (o.isNull() || o.isBoolean() || o.isString() && o.getValue() === "")
          return r = !0, n = g.create(h.VALUE), !1;
        const u = +o.getValue();
        if (Number.isNaN(u))
          return r = !0, n = g.create(h.VALUE), !1;
        t.push(u);
      }), r ? {
        isError: r,
        errorObejct: n
      } : {
        isError: r,
        _values: t
      };
    } else {
      if (e.isError())
        return {
          isError: !0,
          errorObejct: e
        };
      if (e.isNull() || e.isBoolean())
        return {
          isError: !0,
          errorObejct: g.create(h.VALUE)
        };
      const r = +e.getValue();
      return Number.isNaN(r) ? {
        isError: !0,
        errorObejct: g.create(h.VALUE)
      } : {
        isError: !1,
        _values: [r]
      };
    }
  }
  _checkErrorDates(e) {
    const t = [];
    if (e.isArray()) {
      let r = !1, n = g.create(h.VALUE);
      return e.iterator((s) => {
        const o = s;
        if (o.isError())
          return r = !0, n = o, !1;
        if (o.isNull() || o.isBoolean())
          return r = !0, n = g.create(h.VALUE), !1;
        const u = +o.getValue();
        if (Number.isNaN(u))
          return r = !0, n = g.create(h.VALUE), !1;
        if (u < 0)
          return r = !0, n = g.create(h.NUM), !1;
        t.push(Math.floor(u));
      }), r ? {
        isError: r,
        errorObejct: n
      } : {
        isError: r,
        _dates: t
      };
    } else {
      if (e.isError())
        return {
          isError: !0,
          errorObejct: e
        };
      if (e.isNull() || e.isBoolean())
        return {
          isError: !0,
          errorObejct: g.create(h.VALUE)
        };
      const r = +e.getValue();
      return Number.isNaN(r) ? {
        isError: !0,
        errorObejct: g.create(h.VALUE)
      } : +r < 0 ? {
        isError: !0,
        errorObejct: g.create(h.NUM)
      } : {
        isError: !1,
        _dates: [Math.floor(r)]
      };
    }
  }
}
class R0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 6);
    A(this, "maxParams", 7);
  }
  calculate(e, t, r, n, s, o, u) {
    let c = u != null ? u : y.create(0);
    c.isNull() && (c = y.create(0));
    const { isError: l, errorObject: f, variants: m } = Ye(e, t, r, n, s, o, c);
    if (l)
      return f;
    const [d, _, C, E, R, b, p] = m, V = H(d);
    if (typeof V != "number")
      return V;
    const S = H(_);
    if (typeof S != "number")
      return S;
    const M = +C.getValue(), D = +E.getValue(), w = +R.getValue(), L = Math.floor(+b.getValue()), v = Math.floor(+p.getValue());
    if (Number.isNaN(M) || Number.isNaN(D) || Number.isNaN(w) || Number.isNaN(L) || Number.isNaN(v))
      return g.create(h.VALUE);
    if (M < 0 || D <= 0 || w <= 0 || ![1, 2, 4].includes(L) || v < 0 || v > 4 || V >= S || !Ur(V, S, L))
      return g.create(h.NUM);
    const j = this._getResult(V, S, M, D, w, L, v);
    return y.create(j);
  }
  _getResult(e, t, r, n, s, o, u) {
    if (ur(e, t, o) > 1) {
      let E = r || 0.01, R = pn(e, t, r, E, s, o, u), b = R - n;
      for (let p = 0; p < 100 && Math.abs(b) > 1e-7; p++)
        R = pn(e, t, r, 1.01 * E, s, o, u), E += -b / (R - n - b) * E * 0.01, b = pn(e, t, r, E, s, o, u) - n;
      return E;
    }
    const l = As(e, t, o, u), f = ze(e, t, o, u), { days: m } = _e(e, t, u), d = n / 100 + l / f * r / o;
    return (s / 100 + r / o - d) / d * o * f / m;
  }
}
class b0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    let o = s != null ? s : y.create(0);
    o.isNull() && (o = y.create(0));
    const { isError: u, errorObject: c, variants: l } = Ye(e, t, r, n, o);
    if (u)
      return c;
    const [f, m, d, _, C] = l, E = H(f);
    if (typeof E != "number")
      return E;
    const R = H(m);
    if (typeof R != "number")
      return R;
    const b = +d.getValue(), p = +_.getValue(), V = Math.floor(+C.getValue());
    if (Number.isNaN(b) || Number.isNaN(p) || Number.isNaN(V))
      return g.create(h.VALUE);
    if (b <= 0 || p <= 0 || V < 0 || V > 4 || E >= R)
      return g.create(h.NUM);
    const { days: S, yearDays: M } = _e(E, R, V), D = (p / b - 1) / (S / M);
    return y.create(D);
  }
}
class y0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 5);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    let u = o != null ? o : y.create(0);
    u.isNull() && (u = y.create(0));
    const { isError: c, errorObject: l, variants: f } = Ye(e, t, r, n, s, u);
    if (c)
      return l;
    const [m, d, _, C, E, R] = f, b = H(m);
    if (typeof b != "number")
      return b;
    const p = H(d);
    if (typeof p != "number")
      return p;
    const V = H(_);
    if (typeof V != "number")
      return V;
    const S = +C.getValue(), M = +E.getValue(), D = Math.floor(+R.getValue());
    if (Number.isNaN(S) || Number.isNaN(M) || Number.isNaN(D))
      return g.create(h.VALUE);
    const w = this._getDateCorrectOrder(p, b, V);
    if (S < 0 || M <= 0 || D < 0 || D > 4 || !w)
      return g.create(h.NUM);
    const L = ic(b, D), { days: v } = _e(b, p, D), { days: j } = _e(V, p, D), { days: k } = _e(V, b, D), G = ((1 + j / L * S) / (M / 100 + k / L * S) - 1) / (v / L);
    return y.create(G);
  }
  _getDateCorrectOrder(e, t, r) {
    return Math.floor(e) > Math.floor(t) && Math.floor(t) > Math.floor(r);
  }
}
const p0 = [
  [pd, ee.ACCRINT],
  [Nd, ee.ACCRINTM],
  [Vd, ee.AMORLINC],
  [Od, ee.COUPDAYBS],
  [Sd, ee.COUPDAYS],
  [Md, ee.COUPDAYSNC],
  [Dd, ee.COUPNCD],
  [wd, ee.COUPNUM],
  [Ld, ee.COUPPCD],
  [Pd, ee.CUMIPMT],
  [xd, ee.CUMPRINC],
  [jd, ee.DB],
  [Ud, ee.DDB],
  [vd, ee.DISC],
  [Td, ee.DOLLARDE],
  [Id, ee.DOLLARFR],
  [Bd, ee.DURATION],
  [Fd, ee.EFFECT],
  [kd, ee.FV],
  [$d, ee.FVSCHEDULE],
  [Yd, ee.INTRATE],
  [Hd, ee.IPMT],
  [Gd, ee.IRR],
  [Wd, ee.ISPMT],
  [Qd, ee.MDURATION],
  [qd, ee.MIRR],
  [Xd, ee.NOMINAL],
  [Kd, ee.NPER],
  [Zd, ee.NPV],
  [zd, ee.ODDFPRICE],
  [Jd, ee.ODDFYIELD],
  [e0, ee.ODDLPRICE],
  [t0, ee.ODDLYIELD],
  [r0, ee.PDURATION],
  [n0, ee.PMT],
  [s0, ee.PPMT],
  [a0, ee.PRICE],
  [i0, ee.PRICEDISC],
  [o0, ee.PRICEMAT],
  [u0, ee.PV],
  [c0, ee.RATE],
  [l0, ee.RECEIVED],
  [f0, ee.RRI],
  [m0, ee.SLN],
  [h0, ee.SYD],
  [g0, ee.TBILLEQ],
  [d0, ee.TBILLPRICE],
  [C0, ee.TBILLYIELD],
  [_0, ee.VDB],
  [A0, ee.XIRR],
  [E0, ee.XNPV],
  [R0, ee.YIELD],
  [b0, ee.YIELDDISC],
  [y0, ee.YIELDMAT]
];
class N0 extends N {
  constructor() {
    super(...arguments);
    A(this, "needsReferenceObject", !0);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (r.isError())
      return r;
    if (r.isReferenceObject() && (r = r.toArrayValueObject()), r.isArray()) {
      const n = r.getRowCount(), s = r.getColumnCount();
      if (n === 1 && s === 1) {
        const o = r.get(0, 0);
        return this._handleSingleObject(o, t);
      }
      return r.map((o) => o.isError() ? o : this._handleSingleObject(o, t, !0));
    }
    return this._handleSingleObject(r, t);
  }
  _handleSingleObject(e, t, r = !1) {
    let n = t;
    if (n.isError())
      return n;
    if (!n.isReferenceObject())
      return g.create(h.NA);
    const s = n.getCurrentActiveSheetData(), { columnData: o, defaultColumnWidth: u } = s;
    n = n.toArrayValueObject();
    const c = n.getCurrentRow(), l = n.getCurrentColumn();
    n = n.getFirstCell();
    const f = `${e.getValue()}`;
    let m;
    switch (f.toLocaleLowerCase()) {
      case "address":
        return U.create(`$${Ge.chatAtABC(l)}$${c + 1}`);
      case "col":
        return y.create(l + 1);
      case "color":
        return y.create(0);
      case "contents":
        return n;
      case "filename":
        return g.create(h.VALUE);
      case "format":
        return U.create("G");
      case "parentheses":
        return y.create(0);
      case "prefix":
        return U.create("");
      case "protect":
        return y.create(1);
      case "row":
        return y.create(c + 1);
      case "type":
        return m = "v", n.isNull() && (m = "b"), n.isString() && (m = "l"), U.create(m);
      case "width":
        return this._getWidthResult(o, u, l, r);
      default:
        return g.create(h.VALUE);
    }
  }
  _getWidthResult(e, t, r, n) {
    var u;
    let s = (u = e[r]) == null ? void 0 : u.w;
    if (!s && s !== 0 && (s = t), n)
      return y.create(s);
    const o = [[s, s === t]];
    return K.createByArray(o);
  }
}
class V0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
    A(this, "_errorTypeValueMap", /* @__PURE__ */ new Map([
      [h.NULL, 1],
      [h.DIV_BY_ZERO, 2],
      [h.VALUE, 3],
      [h.REF, 4],
      [h.NAME, 5],
      [h.NUM, 6],
      [h.NA, 7],
      [h.CONNECT, 8],
      [h.CALC, 14]
    ]));
  }
  calculate(e) {
    return e.isArray() ? e.mapValue((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const t = e.getValue(), r = this._errorTypeValueMap.get(t);
    return r ? y.create(r) : g.create(h.NA);
  }
}
var Ve = /* @__PURE__ */ ((a) => (a.CELL = "CELL", a.ERROR_TYPE = "ERROR.TYPE", a.INFO = "INFO", a.ISBETWEEN = "ISBETWEEN", a.ISBLANK = "ISBLANK", a.ISDATE = "ISDATE", a.ISEMAIL = "ISEMAIL", a.ISERR = "ISERR", a.ISERROR = "ISERROR", a.ISEVEN = "ISEVEN", a.ISFORMULA = "ISFORMULA", a.ISLOGICAL = "ISLOGICAL", a.ISNA = "ISNA", a.ISNONTEXT = "ISNONTEXT", a.ISNUMBER = "ISNUMBER", a.ISODD = "ISODD", a.ISOMITTED = "ISOMITTED", a.ISREF = "ISREF", a.ISTEXT = "ISTEXT", a.ISURL = "ISURL", a.N = "N", a.NA = "NA", a.SHEET = "SHEET", a.SHEETS = "SHEETS", a.TYPE = "TYPE", a))(Ve || {});
class O0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    const o = n != null ? n : T.create(!0), u = s != null ? s : T.create(!0), { isError: c, errorObject: l, variants: f } = zr(e, t, r, o, u);
    if (c)
      return l;
    const [m, d, _, C, E] = f;
    if (C.isString() || E.isString())
      return g.create(h.VALUE);
    if (d.compare(_, ">").getValue() === !0)
      return g.create(h.NUM);
    const b = +C.getValue(), p = +E.getValue(), V = b ? ">=" : ">", S = p ? "<=" : "<";
    return m.compare(d, V).getValue() === !1 || m.compare(_, S).getValue() === !1 ? T.create(!1) : T.create(!0);
  }
}
class S0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isNull() ? T.create(!0) : e.isArray() ? e.mapValue((t) => t.isNull() ? T.create(!0) : T.create(!1)) : T.create(!1);
  }
}
class M0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    if (t.isArray()) {
      const r = t.getRowCount(), n = t.getColumnCount();
      if (r > 1 || n > 1)
        return g.create(h.VALUE);
      t = t.get(0, 0);
    }
    return t.isError() ? t : t.isNumber() && t.getPattern() !== "" ? T.create(za(t.getPattern())) : t.isString() && (Yn(`${t.getValue()}`) || Hn(`${t.getValue()}`)) ? T.create(!0) : T.create(!1);
  }
}
class D0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    if (t.isArray()) {
      const o = t.getRowCount(), u = t.getColumnCount();
      if (o > 1 || u > 1)
        return g.create(h.VALUE);
      t = t.get(0, 0);
    }
    if (t.isError())
      return t;
    if (t.isNull() || t.isBoolean() || t.isNumber())
      return T.create(!1);
    const r = `${t.getValue()}`;
    if (r.length > 254)
      return T.create(!1);
    const n = Ge.topLevelDomainCombiningString(), s = new RegExp(
      `^(?:[\\w+-]+\\.)*[\\w+-]+@[a-z0-9_-]+(?:\\.[a-z0-9_-]+)*\\.(?:${n})$`,
      "i"
    );
    return T.create(s.test(r));
  }
}
class w0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.getValue() === h.NA ? T.create(!1) : e.isError() ? T.create(!0) : e.isArray() ? e.mapValue((t) => t.getValue() === h.NA ? T.create(!1) : t.isError() ? T.create(!0) : T.create(!1)) : T.create(!1);
  }
}
class L0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isError() ? T.create(!0) : e.isArray() ? e.mapValue((t) => t.isError() ? T.create(!0) : T.create(!1)) : T.create(!1);
  }
}
class P0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    if (t.isArray()) {
      const s = t.getRowCount(), o = t.getColumnCount();
      if (s > 1 || o > 1)
        return g.create(h.VALUE);
      t = t.get(0, 0);
    }
    if (t.isError())
      return t;
    if (t.isBoolean())
      return g.create(h.VALUE);
    const r = Math.trunc(+t.getValue());
    if (Number.isNaN(r))
      return g.create(h.VALUE);
    const n = r % 2 === 0;
    return T.create(n);
  }
}
class x0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e) {
    var u;
    if (e.isError())
      return e;
    if (!e.isReferenceObject())
      return g.create(h.NA);
    const t = (u = e.getCurrentActiveSheetData()) == null ? void 0 : u.cellData.getMatrix(), { startRow: r, startColumn: n } = e.getRangePosition(), s = e.toArrayValueObject(), o = s.mapValue((c, l, f) => {
      var d;
      const m = (d = t == null ? void 0 : t[r + l]) == null ? void 0 : d[n + f];
      return m != null && m.f || m != null && m.si ? T.create(!0) : T.create(!1);
    });
    return s.getRowCount() === 1 && s.getColumnCount() === 1 ? o.get(0, 0) : o;
  }
}
class j0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isBoolean() ? T.create(!0) : e.isArray() ? e.mapValue((t) => t.isBoolean() ? T.create(!0) : T.create(!1)) : T.create(!1);
  }
}
class U0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.getValue() === h.NA ? T.create(!0) : e.isArray() ? e.mapValue((t) => t.getValue() === h.NA ? T.create(!0) : T.create(!1)) : T.create(!1);
  }
}
class v0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return !e.isArray() && !e.isString() ? T.create(!0) : e.isArray() ? e.mapValue((t) => t.isString() ? T.create(!1) : T.create(!0)) : T.create(!1);
  }
}
class T0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isNumber() ? T.create(!0) : e.isArray() ? e.mapValue((t) => t.isNumber() ? T.create(!0) : T.create(!1)) : T.create(!1);
  }
}
class I0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    if (t.isArray()) {
      const s = t.getRowCount(), o = t.getColumnCount();
      if (s > 1 || o > 1)
        return g.create(h.VALUE);
      t = t.get(0, 0);
    }
    if (t.isError())
      return t;
    if (t.isBoolean())
      return g.create(h.VALUE);
    const r = Math.trunc(+t.getValue());
    if (Number.isNaN(r))
      return g.create(h.VALUE);
    const n = r % 2 !== 0;
    return T.create(n);
  }
}
class B0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e) {
    return e.isReferenceObject() ? T.create(!0) : T.create(!1);
  }
}
class F0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isString() ? T.create(!0) : e.isArray() ? e.mapValue((t) => t.isString() ? T.create(!0) : T.create(!1)) : T.create(!1);
  }
}
class k0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    if (t.isArray()) {
      const o = t.getRowCount(), u = t.getColumnCount();
      if (o > 1 || u > 1)
        return g.create(h.VALUE);
      t = t.get(0, 0);
    }
    if (t.isError())
      return t;
    if (t.isNull() || t.isBoolean() || t.isNumber())
      return T.create(!1);
    const r = `${t.getValue()}`.replace(/^\s+|\s+$/g, "");
    if (r.length > 1e3)
      return T.create(!1);
    const n = Ge.topLevelDomainCombiningString(), s = new RegExp(
      `^(?:(?:https?|s?ftp|ftps|nfs|ssh)://+[a-z0-9_-]+(?:\\.[a-z0-9_-]+)*(?::[0-9]+)?(?:/(?:[A-Za-z0-9\\-._~!$&'()*+,;=:@]|%[A-Fa-f0-9]{2})*)*/?(?:[?#]\\S*)?|[a-z0-9_-]+(?:\\.[a-z0-9_-]+)*\\.(?:${n})(?::[0-9]+)?(?:/(?:[A-Za-z0-9\\-._~!$&'()*+,;=:@]|%[A-Fa-f0-9]{2})*)*/?(?:[?#]\\S*)?|mailto:(?:[\\w+-]+\\.)*[\\w+-]+@[a-z0-9_-]+(?:\\.[a-z0-9_-]+)*\\.(?:${n})|(?:news|aim):[%a-z0-9$_\\.+!*(),;/?#:@&~=-]+)$`,
      "i"
    );
    return T.create(s.test(r));
  }
}
class $0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    if (e.isArray() && (t = e.get(0, 0)), t.isError())
      return t;
    if (t.isString())
      return y.create(0);
    const r = +t.getValue();
    return y.create(r);
  }
}
class Y0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 0);
  }
  calculate() {
    return g.create(h.NA);
  }
}
class H0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 1);
    A(this, "needsReferenceObject", !0);
    A(this, "needsSheetsInfo", !0);
  }
  calculate(e) {
    var u;
    if (e != null && e.isError())
      return e;
    const { sheetOrder: t, sheetNameMap: r } = this.getSheetsInfo();
    if (!e) {
      const c = t.findIndex((l) => l === this.subUnitId);
      return y.create(c + 1);
    }
    if (e.isReferenceObject()) {
      const c = e.getForcedSheetId(), l = e.getDefaultSheetId(), f = t.findIndex((m) => c ? m === c : m === l);
      return y.create(f + 1);
    }
    if (e.isArray())
      return g.create(h.NA);
    const n = `${e.getValue()}`.toLocaleLowerCase(), s = (u = Object.entries(r).find(([c, l]) => l.toLocaleLowerCase() === n)) == null ? void 0 : u[0];
    if (!s)
      return g.create(h.NA);
    const o = t.findIndex((c) => c === s);
    return y.create(o + 1);
  }
}
class G0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 0);
    A(this, "needsSheetsInfo", !0);
  }
  calculate() {
    const { sheetOrder: e } = this.getSheetsInfo();
    return y.create(e.length);
  }
}
class W0 extends N {
  constructor() {
    super(...arguments);
    A(this, "needsReferenceObject", !0);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isReferenceObject()) {
      const t = e.getRowCount(), r = e.getColumnCount();
      if (t === 1 && r === 1) {
        const n = e.getFirstCell();
        if (n.isError())
          return y.create(16);
        if (n.isBoolean())
          return y.create(4);
        if (n.isString())
          return y.create(2);
        if (n.isNumber() || n.isNull())
          return y.create(1);
      } else
        return y.create(64);
    } else {
      if (e.isArray())
        return y.create(64);
      if (e.isError())
        return y.create(16);
      if (e.isBoolean())
        return y.create(4);
      if (e.isString())
        return y.create(2);
      if (e.isNumber() || e.isNull())
        return y.create(1);
    }
    return y.create(128);
  }
}
const Q0 = [
  [N0, Ve.CELL],
  [V0, Ve.ERROR_TYPE],
  [O0, Ve.ISBETWEEN],
  [S0, Ve.ISBLANK],
  [M0, Ve.ISDATE],
  [D0, Ve.ISEMAIL],
  [w0, Ve.ISERR],
  [L0, Ve.ISERROR],
  [P0, Ve.ISEVEN],
  [x0, Ve.ISFORMULA],
  [j0, Ve.ISLOGICAL],
  [U0, Ve.ISNA],
  [v0, Ve.ISNONTEXT],
  [T0, Ve.ISNUMBER],
  [I0, Ve.ISODD],
  [B0, Ve.ISREF],
  [F0, Ve.ISTEXT],
  [k0, Ve.ISURL],
  [$0, Ve.N],
  [Y0, Ve.NA],
  [H0, Ve.SHEET],
  [G0, Ve.SHEETS],
  [W0, Ve.TYPE]
];
class q0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = !0, r = !0, n = null;
    for (const s of e) {
      if (s.isError())
        return s;
      if (s.isArray()) {
        if (s.iterator((o) => {
          if (o != null && o.isError())
            return n = o, !1;
          (o != null && o.isBoolean() || o != null && o.isNumber()) && (t = t && !!o.getValue(), r = !1);
        }), n)
          return n;
      } else (s.isBoolean() || s.isNumber()) && (t = t && !!s.getValue(), r = !1);
    }
    return r ? g.create(h.VALUE) : T.create(t);
  }
}
class X0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
    A(this, "needsReferenceObject", !0);
  }
  // eslint-disable-next-line
  calculate(e, t) {
    let r = e, n = null;
    if (e.isReferenceObject() && (r = e.toArrayValueObject(), n = e), r.isError())
      return r;
    if (t.isError())
      return t;
    if (!(t.isValueObject() && t.isLambda() && t.getLambdaPrivacyVarKeys().length === 1))
      return g.create(h.VALUE);
    const s = t, o = r.isArray() ? r.getRowCount() : 1, u = r.isArray() ? r.getColumnCount() : 1;
    r = O(o, u, r);
    const c = [[]];
    for (let l = 0; l < u; l++) {
      const f = [];
      for (let _ = 0; _ < o; _++) {
        const C = r.get(_, l);
        f.push([C]);
      }
      let m = K.create({
        calculateValueList: f,
        rowCount: o,
        columnCount: 1,
        unitId: "",
        sheetId: "",
        row: 0,
        column: 0
      });
      if (n) {
        const { startRow: _, startColumn: C } = n.getRangePosition(), E = {
          startRow: _,
          startColumn: C + l,
          endRow: _ + o - 1,
          endColumn: C + l
        };
        m = this.createReferenceObject(n, E);
      }
      let d = s.execute(m);
      if (d.isArray()) {
        const _ = d.getRowCount(), C = d.getColumnCount();
        if (_ > 1 || C > 1)
          return g.create(h.CALC);
        d = d.get(0, 0);
      }
      d.isNull() && (d = y.create(0)), c[0].push(d);
    }
    return u === 1 ? c[0][0] : K.create({
      calculateValueList: c,
      rowCount: 1,
      columnCount: u,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
}
class K0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
    A(this, "needsReferenceObject", !0);
  }
  // eslint-disable-next-line
  calculate(e, t) {
    let r = e, n = null;
    if (e.isReferenceObject() && (r = e.toArrayValueObject(), n = e), r.isError())
      return r;
    if (t.isError())
      return t;
    if (!(t.isValueObject() && t.isLambda() && t.getLambdaPrivacyVarKeys().length === 1))
      return g.create(h.VALUE);
    const s = t, o = r.isArray() ? r.getRowCount() : 1, u = r.isArray() ? r.getColumnCount() : 1;
    r = O(o, u, r);
    const c = [];
    for (let l = 0; l < o; l++) {
      const f = [[]];
      for (let _ = 0; _ < u; _++) {
        const C = r.get(l, _);
        f[0].push(C);
      }
      let m = K.create({
        calculateValueList: f,
        rowCount: 1,
        columnCount: u,
        unitId: "",
        sheetId: "",
        row: 0,
        column: 0
      });
      if (n) {
        const { startRow: _, startColumn: C } = n.getRangePosition(), E = {
          startRow: _ + l,
          startColumn: C,
          endRow: _ + l,
          endColumn: C + u - 1
        };
        m = this.createReferenceObject(n, E);
      }
      let d = s.execute(m);
      if (d.isArray()) {
        const _ = d.getRowCount(), C = d.getColumnCount();
        if (_ > 1 || C > 1)
          return g.create(h.CALC);
        d = d.get(0, 0);
      }
      d.isNull() && (d = y.create(0)), c.push([d]);
    }
    return o === 1 ? c[0][0] : K.create({
      calculateValueList: c,
      rowCount: o,
      columnCount: 1,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
}
class Z0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 0);
  }
  calculate() {
    return T.create(!1);
  }
}
var Ee = /* @__PURE__ */ ((a) => (a.AND = "AND", a.BYCOL = "BYCOL", a.BYROW = "BYROW", a.FALSE = "FALSE", a.IF = "IF", a.IFERROR = "IFERROR", a.IFNA = "IFNA", a.IFS = "IFS", a.LAMBDA = "LAMBDA", a.LET = "LET", a.MAKEARRAY = "MAKEARRAY", a.MAP = "MAP", a.NOT = "NOT", a.OR = "OR", a.REDUCE = "REDUCE", a.SCAN = "SCAN", a.SWITCH = "SWITCH", a.TRUE = "TRUE", a.XOR = "XOR", a))(Ee || {});
class z0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r = T.create(!1)) {
    let n = e;
    if (e.isArray()) {
      const f = e.getRowCount(), m = e.getColumnCount();
      f === 1 && m === 1 && (n = e.get(0, 0));
    }
    if (!n.isArray())
      return this._handleSingleObject(n, t, r);
    const s = Math.max(
      n.isArray() ? n.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), o = Math.max(
      n.isArray() ? n.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), u = O(s, o, n, g.create(h.NA)), c = O(s, o, t, g.create(h.NA)), l = O(s, o, r, g.create(h.NA));
    return u.mapValue((f, m, d) => {
      const _ = c.get(m, d), C = l.get(m, d);
      return this._handleSingleObject(f, _, C);
    });
  }
  _handleSingleObject(e, t, r) {
    return e.isError() ? e : e.getValue() ? t : r;
  }
}
class J0 extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (!e.isArray())
      return e.isError() ? t : e;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e), o = O(r, n, t);
    return s.iterator((u, c, l) => {
      u != null && u.isError() && s.set(c, l, o.get(c, l));
    }), s;
  }
}
class eC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError() && e.getErrorType() !== h.NA)
      return e;
    if (t.isError())
      return t;
    if (!e.isArray())
      return e.isError() && e.getErrorType() === h.NA ? t : e;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e), o = O(r, n, t);
    return s.iterator((u, c, l) => {
      u != null && u.isError() && u.getErrorType() === h.NA && s.set(c, l, o.get(c, l));
    }), s;
  }
}
class tC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    if (e.length % 2 !== 0)
      return g.create(h.NA);
    for (let o = 0; o < e.length; o++)
      if (e[o].isError())
        return e[o];
    const t = Math.max(
      ...e.map((o) => o.isArray() ? o.getRowCount() : 1)
    ), r = Math.max(
      ...e.map((o) => o.isArray() ? o.getColumnCount() : 1)
    ), n = e.map(
      (o) => O(t, r, o, g.create(h.NA))
    ), s = n[0].map((o, u, c) => {
      for (let l = 0; l < n.length; l += 2) {
        const f = n[l].get(u, c) || ce.create(), m = n[l + 1].get(u, c) || ce.create();
        if (f.isNull())
          continue;
        if (f.isError())
          return f;
        const d = f.getValue();
        if (f.isString()) {
          if (`${d}`.toLocaleUpperCase() === "TRUE")
            return m;
          if (`${d}`.toLocaleUpperCase() === "FALSE")
            continue;
          return g.create(h.VALUE);
        }
        if (+d)
          return m.isNull() ? g.create(h.NA) : m;
      }
      return g.create(h.NA);
    });
    return t === 1 && r === 1 ? s.get(0, 0) : s;
  }
}
class rC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    return g.create(h.VALUE);
  }
}
class nC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    return g.create(h.VALUE);
  }
}
class sC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(...e) {
    const t = this.getIndexNumValue(e[0]);
    if (typeof t != "number")
      return t;
    const r = this.getIndexNumValue(e[1]);
    if (typeof r != "number")
      return r;
    if (!(e[2].isValueObject() && e[2].isLambda()))
      return g.create(h.VALUE);
    const n = e[2], s = [];
    for (let o = 0; o < t; o++) {
      s[o] == null && (s[o] = []);
      for (let u = 0; u < r; u++) {
        let c = n.execute(y.create(o + 1), y.create(u + 1));
        c.isArray() && (c = c.get(0, 0)), s[o][u] = c;
      }
    }
    return new Om(s);
  }
  isAsync() {
    return !0;
  }
}
let aC = class extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", !0);
  }
  calculate(...e) {
    const t = [];
    let r = null, n = 0, s = 0;
    for (let u = 0; u < e.length; u++) {
      const c = e[u];
      let l = c;
      if (l.isReferenceObject() && (l = c.toArrayValueObject()), l.isError())
        return l;
      if (u === e.length - 1) {
        if (!(c.isValueObject() && c.isLambda()))
          return g.create(h.VALUE);
        r = c;
      } else
        t.push(c), n = Math.max(n, l.isArray() ? l.getRowCount() : 1), s = Math.max(s, l.isArray() ? l.getColumnCount() : 1);
    }
    const o = this._getResultArray(t, r, n, s);
    return o instanceof g ? o : n === 1 && s === 1 ? o[0][0] : K.create({
      calculateValueList: o,
      rowCount: n,
      columnCount: s,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
  // eslint-disable-next-line
  _getResultArray(e, t, r, n) {
    const s = [];
    for (let o = 0; o < r; o++) {
      const u = [];
      for (let c = 0; c < n; c++) {
        const l = [];
        let f = !1;
        for (let d = 0; d < e.length; d++) {
          let _ = e[d], C = null;
          if (_.isReferenceObject() && (C = _, _ = _.toArrayValueObject()), !_.isArray())
            if (o === 0 && c === 0) {
              l.push(C || _);
              continue;
            } else {
              u.push(g.create(h.NA)), f = !0;
              break;
            }
          let E = _.get(o, c);
          if (!E) {
            u.push(g.create(h.NA)), f = !0;
            break;
          }
          if (C) {
            const { startRow: R, startColumn: b } = C.getRangePosition(), p = {
              startRow: R + o,
              startColumn: b + c,
              endRow: R + o,
              endColumn: b + c
            };
            E = this.createReferenceObject(C, p);
          }
          l.push(E);
        }
        if (f || l.length === 0)
          continue;
        let m = t.execute(...l);
        if (m.isArray()) {
          const d = m.getRowCount(), _ = m.getColumnCount();
          if (d > 1 || _ > 1)
            return g.create(h.CALC);
          m = m.get(0, 0);
        }
        m.isNull() && (m = y.create(0)), u.push(m);
      }
      s.push(u);
    }
    return s;
  }
};
class iC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    const t = +e.getValue();
    return Number.isNaN(t) ? g.create(h.VALUE) : T.create(!t);
  }
}
class oC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = !1, r = !0, n = null;
    for (const s of e) {
      if (s.isError())
        return s;
      if (s.isArray()) {
        if (s.iterator((o) => {
          if (o != null && o.isError())
            return n = o, !1;
          (o != null && o.isBoolean() || o != null && o.isNumber()) && (t = t || !!o.getValue(), r = !1);
        }), n)
          return n;
      } else (s.isBoolean() || s.isNumber()) && (t = t || !!s.getValue(), r = !1);
    }
    return r ? new g(h.VALUE) : new T(t);
  }
}
class uC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, t, r) {
    let n, s;
    e.isReferenceObject() ? (n = e.toArrayValueObject(), s = e) : (n = e, s = null);
    let o, u;
    return t.isReferenceObject() ? (o = t.toArrayValueObject(), u = t) : (o = t, u = null), n.isArray() ? n.mapValue((c) => this._handleSingleValueObject(c, o, r, s, u)) : this._handleSingleValueObject(n, o, r, s, u);
  }
  _handleSingleValueObject(e, t, r, n, s) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (r.isError())
      return r;
    if (!(r.isValueObject() && r.isLambda() && r.getLambdaPrivacyVarKeys().length === 2))
      return g.create(h.VALUE);
    const o = r, u = t.isArray() ? t.getRowCount() : 1, c = t.isArray() ? t.getColumnCount() : 1;
    let l = e;
    n && (l = n);
    for (let f = 0; f < u; f++)
      for (let m = 0; m < c; m++) {
        let d = t.isArray() ? t.get(f, m) : t;
        if (d.isError())
          return d;
        if (s) {
          const { startRow: C, startColumn: E } = s.getRangePosition(), R = {
            startRow: C + f,
            startColumn: E + m,
            endRow: C + f,
            endColumn: E + m
          };
          d = this.createReferenceObject(s, R);
        }
        let _ = o.execute(l, d);
        if (_.isError())
          return _;
        _.isNull() && (_ = y.create(0)), l = _;
      }
    return l.isReferenceObject() ? l.toArrayValueObject() : l;
  }
}
class cC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, t, r) {
    let n = e, s = null;
    e.isReferenceObject() && (n = e.toArrayValueObject(), s = e), n = n;
    let o = t, u = null;
    if (t.isReferenceObject() && (o = t.toArrayValueObject(), u = t), o = o, n.isError())
      return n;
    if (o.isError())
      return o;
    if (r.isError())
      return r;
    if (!(r.isValueObject() && r.isLambda() && r.getLambdaPrivacyVarKeys().length === 2))
      return g.create(h.VALUE);
    if (n.isArray()) {
      const c = n.getRowCount(), l = n.getColumnCount();
      if (c > 1 || l > 1)
        return g.create(h.CALC);
      n = n.get(0, 0);
    }
    return this._getResult(n, o, r, s, u);
  }
  // eslint-disable-next-line
  _getResult(e, t, r, n, s) {
    const o = [], u = t.isArray() ? t.getRowCount() : 1, c = t.isArray() ? t.getColumnCount() : 1;
    let l = e;
    n && (l = n);
    for (let f = 0; f < u; f++) {
      const m = [];
      for (let d = 0; d < c; d++) {
        if (l.isError()) {
          m.push(l);
          continue;
        }
        let _ = t.isArray() ? t.get(f, d) : t;
        if (_.isError()) {
          l = _, m.push(_);
          continue;
        }
        if (s) {
          const { startRow: E, startColumn: R } = s.getRangePosition(), b = {
            startRow: E + f,
            startColumn: R + d,
            endRow: E + f,
            endColumn: R + d
          };
          _ = this.createReferenceObject(s, b);
        }
        let C = r.execute(l, _);
        if (C.isArray()) {
          const E = C.getRowCount(), R = C.getColumnCount();
          if (E > 1 || R > 1)
            return g.create(h.CALC);
          C = C.get(0, 0);
        }
        C.isNull() && (C = y.create(0)), l = C, m.push(C);
      }
      o.push(m);
    }
    return u === 1 && c === 1 ? o[0][0] : K.create({
      calculateValueList: o,
      rowCount: u,
      columnCount: c,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
}
class lC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
  }
  calculate(e, ...t) {
    if (e.isError())
      return e;
    const r = t.length % 2 !== 0, n = r ? t[t.length - 1] : ce.create();
    return !e.isArray() && !t.some((s) => s.isArray()) ? this._handleNonArrayInputs(e, t, n, r) : this._handleArrayInputs(e, t, n, r);
  }
  _handleNonArrayInputs(e, t, r, n) {
    for (let s = 0; s < t.length - (n ? 1 : 0); s += 2) {
      const o = t[s], u = t[s + 1];
      if (!o.isNull()) {
        if (o.isError())
          return o;
        if (`${e.getValue()}`.toLocaleLowerCase() === `${o.getValue()}`.toLocaleLowerCase())
          return u.isNull() ? g.create(h.NA) : u;
      }
    }
    return r.isNull() ? g.create(h.NA) : r;
  }
  _handleArrayInputs(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      ...t.map((f) => f.isArray() ? f.getRowCount() : 1),
      r.isArray() ? r.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      ...t.map((f) => f.isArray() ? f.getColumnCount() : 1),
      r.isArray() ? r.getColumnCount() : 1
    ), u = O(s, o, e), c = t.map(
      (f) => O(s, o, f, g.create(h.NA))
    ), l = O(s, o, r, g.create(h.NA));
    return u.map((f, m, d) => {
      for (let C = 0; C < c.length - (n ? 1 : 0); C += 2) {
        const E = c[C].get(m, d) || ce.create(), R = c[C + 1].get(m, d) || ce.create();
        if (!E.isNull()) {
          if (E.isError() || f.isError())
            return E.isError() ? E : f;
          if (`${f.getValue()}`.toLocaleLowerCase() === `${E.getValue()}`.toLocaleLowerCase())
            return R.isNull() ? g.create(h.NA) : R;
        }
      }
      const _ = l.get(m, d) || ce.create();
      return _.isNull() ? g.create(h.NA) : _;
    });
  }
}
class fC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 0);
  }
  calculate() {
    return T.create(!0);
  }
}
class mC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = 0, r = !0, n = null;
    for (const s of e) {
      if (s.isError())
        return s;
      if (s.isArray()) {
        if (s.iterator((o) => {
          if (o != null && o.isError())
            return n = o, !1;
          (o != null && o.isBoolean() || o != null && o.isNumber()) && (o.getValue() && t++, r = !1);
        }), n)
          return n;
      } else (s.isBoolean() || s.isNumber()) && (s.getValue() && t++, r = !1);
    }
    return r ? g.create(h.VALUE) : T.create(t % 2 === 1);
  }
}
const hC = [
  [q0, Ee.AND],
  [X0, Ee.BYCOL],
  [K0, Ee.BYROW],
  [Z0, Ee.FALSE],
  [z0, Ee.IF],
  [J0, Ee.IFERROR],
  [eC, Ee.IFNA],
  [tC, Ee.IFS],
  [rC, Ee.LAMBDA],
  [nC, Ee.LET],
  [sC, Ee.MAKEARRAY],
  [aC, Ee.MAP],
  [iC, Ee.NOT],
  [oC, Ee.OR],
  [uC, Ee.REDUCE],
  [cC, Ee.SCAN],
  [lC, Ee.SWITCH],
  [fC, Ee.TRUE],
  [mC, Ee.XOR]
];
class gC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 5);
  }
  // eslint-disable-next-line max-lines-per-function
  calculate(e, t, r, n, s) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (r != null && r.isError())
      return r;
    if (n != null && n.isError())
      return n;
    if (s != null && s.isError())
      return s;
    const o = r != null ? r : y.create(1), u = n != null ? n : T.create(!0), c = s != null ? s : U.create(""), l = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), m = O(l, f, e, g.create(h.NA)), d = O(l, f, t, g.create(h.NA)), _ = O(l, f, o, g.create(h.NA)), C = O(l, f, u, g.create(h.NA)), E = O(l, f, c, g.create(h.NA));
    return m.map((R, b, p) => {
      const V = d.get(b, p) || g.create(h.NA), S = _.get(b, p) || g.create(h.NA), M = C.get(b, p) || g.create(h.NA), D = E.get(b, p) || g.create(h.NA);
      return R.isError() ? R : V.isError() ? V : S.isError() ? S : M.isError() ? M : D.isError() ? D : this._calculateSingleCell(R, V, S, M, D);
    });
  }
  _calculateSingleCell(e, t, r, n, s) {
    const o = Number.parseInt(`${Number(e.getValue()) - 1}`), u = Number.parseInt(`${Number(t.getValue()) - 1}`), c = Number.parseInt(`${Number(r.getValue())}`);
    if (Number.isNaN(o) || Number.isNaN(u) || Number.isNaN(c) || c < 1 || c > 4)
      return g.create(h.VALUE);
    const l = dC(c), f = this.getZeroOrOneByOneDefault(n), m = `${s.getValue()}`, d = No(m), _ = {
      startRow: o,
      startColumn: u,
      endRow: o,
      endColumn: u,
      startAbsoluteRefType: l,
      endAbsoluteRefType: l
    }, C = n && !f ? Lh(_) : Yt(_);
    return U.create(d !== "" ? `${d}!${C}` : C);
  }
}
function dC(a) {
  switch (a) {
    case 1:
      return Le.ALL;
    case 2:
      return Le.ROW;
    case 3:
      return Le.COLUMN;
    case 4:
      return Le.NONE;
    default:
      return Le.ALL;
  }
}
class CC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e) {
    return e.isReferenceObject() ? y.create(1) : g.create(h.VALUE);
  }
}
class _C extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, ...t) {
    let r = e;
    if (r.isError())
      return r;
    if (r.isReferenceObject() && (r = r.toArrayValueObject()), !r.isArray()) {
      const c = r.convertToNumberObjectValue();
      return c.isError() ? c : t[Math.trunc(+c.getValue()) - 1] || g.create(h.VALUE);
    }
    let n = r.isArray() ? r.getRowCount() : 1, s = r.isArray() ? r.getColumnCount() : 1;
    t.forEach((c, l) => {
      if (c.isArray()) {
        const f = c;
        n = Math.max(n, f.getRowCount()), s = Math.max(s, f.getColumnCount());
      } else
        n = Math.max(n, 1), s = Math.max(s, 1);
    });
    const o = O(n, s, r, g.create(h.NA)), u = t.map((c) => {
      let l = c;
      return l.isReferenceObject() && (l = l.toArrayValueObject()), O(n, s, l, g.create(h.NA));
    });
    return o.map((c, l, f) => {
      if (c.isError())
        return c;
      const m = c.convertToNumberObjectValue();
      if (m.isError())
        return m;
      const d = u[Math.trunc(+m.getValue()) - 1];
      let _ = (d == null ? void 0 : d.get(l, f)) || g.create(h.VALUE);
      return _ != null && _.isNull() && (_ = y.create(0)), _;
    });
  }
}
class AC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
  }
  calculate(e, ...t) {
    if (e.isError())
      return e;
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = [];
    for (let o = 0; o < t.length; o++) {
      let u = t[o];
      if (u.isArray()) {
        const f = u.getRowCount(), m = u.getColumnCount();
        if (f > 1 || m > 1)
          return g.create(h.VALUE);
        u = u.get(0, 0);
      }
      if (u.isString() && (u = u.convertToNumberObjectValue()), u.isError())
        return u;
      const c = Math.trunc(+u.getValue());
      if (c === 0 || Math.abs(c) > n)
        return g.create(h.VALUE);
      let l = e;
      n > 1 && (c < 0 ? l = e.slice(void 0, [c + n, c + 1 + n]) : l = e.slice(void 0, [c - 1, c]));
      for (let f = 0; f < r; f++)
        s[f] || (s[f] = []), e.isArray() ? s[f].push(l.get(f, 0)) : s[f].push(e);
    }
    return K.create({
      calculateValueList: s,
      rowCount: s.length,
      columnCount: s[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
}
class EC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
  }
  calculate(e, ...t) {
    if (e.isError())
      return e;
    const r = e.isArray() ? e.getRowCount() : 1, n = [];
    for (let s = 0; s < t.length; s++) {
      let o = t[s];
      if (o.isArray()) {
        const l = o.getRowCount(), f = o.getColumnCount();
        if (l > 1 || f > 1)
          return g.create(h.VALUE);
        o = o.get(0, 0);
      }
      if (o.isString() && (o = o.convertToNumberObjectValue()), o.isError())
        return o;
      const u = Math.trunc(+o.getValue());
      if (u === 0 || Math.abs(u) > r)
        return g.create(h.VALUE);
      let c = e;
      r > 1 && (u < 0 ? c = e.slice([u + r, u + 1 + r]) : c = e.slice([u - 1, u])), e.isArray() ? n.push(c.getArrayValue()[0]) : n.push([e]);
    }
    return K.create({
      calculateValueList: n,
      rowCount: n.length,
      columnCount: n[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
}
class RC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e == null)
      return y.create(this.column + 1);
    if (e.isError())
      return e;
    if (!e.isArray())
      return g.create(h.NA);
    const t = e.getCurrentColumn(), r = e.getColumnCount(), n = [];
    for (let o = 0; o < r; o++)
      n.push(y.create(t + o + 1));
    const s = {
      calculateValueList: [n],
      rowCount: 1,
      columnCount: r,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    };
    return K.create(s);
  }
}
class bC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isError())
      return e;
    if (e.isString() || e.isNumber() || e.isBoolean())
      return y.create(1);
    if (!e.isArray())
      return g.create(h.NA);
    const t = e.getColumnCount();
    return y.create(t);
  }
}
class yC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : y.create(0), s = e.isArray() ? e.getRowCount() : 1, o = e.isArray() ? e.getColumnCount() : 1, u = Math.max(
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), c = Math.max(
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), l = O(u, c, t, g.create(h.NA)), f = O(u, c, n, g.create(h.NA));
    if (u > 1 || c > 1)
      return l.mapValue((b, p, V) => {
        const S = f.get(p, V);
        if (e.isError())
          return e;
        if (e.isNull())
          return g.create(h.VALUE);
        const { isError: M, errorObject: D } = this._checkRowsColumns(b, S, s, o);
        return M ? D : e.isArray() ? g.create(h.VALUE) : e;
      });
    if (e.isError())
      return e;
    if (e.isNull())
      return g.create(h.VALUE);
    const m = t.isArray() ? t.get(0, 0) : t, d = n.isArray() ? n.get(0, 0) : n, { isError: _, errorObject: C, rowsValue: E, columnsValue: R } = this._checkRowsColumns(m, d, s, o);
    return _ ? C : this._getResultArray(e, E, R, s, o);
  }
  _checkRowsColumns(e, t, r, n) {
    if (e.isError())
      return {
        isError: !0,
        errorObject: e
      };
    if (t.isError())
      return {
        isError: !0,
        errorObject: t
      };
    const s = Math.trunc(+e.getValue()), o = Math.trunc(+t.getValue());
    return Number.isNaN(s) || Number.isNaN(o) ? {
      isError: !0,
      errorObject: g.create(h.VALUE)
    } : Math.abs(s) >= r || Math.abs(o) >= n ? {
      isError: !0,
      errorObject: g.create(h.CALC)
    } : {
      isError: !1,
      rowsValue: s,
      columnsValue: o
    };
  }
  _getResultArray(e, t, r, n, s) {
    const o = t >= 0 ? [t, n] : [0, n + t], u = r >= 0 ? [r, s] : [0, s + r];
    let c;
    return t === 0 && r === 0 ? c = e : t === 0 ? c = e.slice(void 0, u) : r === 0 ? c = e.slice(o, void 0) : c = e.slice(o, u), c = c.map((l) => l.isNull() ? y.create(0) : l), n - t === 1 && s - r === 1 ? c.get(0, 0) : c;
  }
}
class pC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = e.isArray() ? e.getRowCount() : 1, o = e.isArray() ? e.getColumnCount() : 1;
    let u = t, c = r != null ? r : y.create(o);
    const l = n != null ? n : g.create(h.NA);
    t.isNull() && (u = y.create(s)), c.isNull() && (c = y.create(o));
    const f = Math.max(
      u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), m = Math.max(
      u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), d = O(f, m, u, g.create(h.NA)), _ = O(f, m, c, g.create(h.NA));
    if (f > 1 || m > 1)
      return d.mapValue((M, D, w) => {
        const L = _.get(D, w);
        if (e.isError())
          return e;
        if (e.isNull())
          return g.create(h.VALUE);
        const { isError: v, errorObject: j } = this._checkRowsColumnsPadWith(M, L, l, s, o);
        return v ? j : e.isArray() ? e.get(0, 0) : e;
      });
    if (e.isError())
      return e;
    if (e.isNull())
      return g.create(h.VALUE);
    const C = u.isArray() ? u.get(0, 0) : u, E = c.isArray() ? c.get(0, 0) : c, { isError: R, errorObject: b, rowsValue: p, columnsValue: V, padWithObject: S } = this._checkRowsColumnsPadWith(C, E, l, s, o);
    return R ? b : this._getResultArray(e, p, V, S, s, o);
  }
  _checkRowsColumnsPadWith(e, t, r, n, s) {
    if (e.isError())
      return {
        isError: !0,
        errorObject: e
      };
    if (t.isError())
      return {
        isError: !0,
        errorObject: t
      };
    const o = Math.trunc(+e.getValue()), u = Math.trunc(+t.getValue());
    if (Number.isNaN(o) || Number.isNaN(u))
      return {
        isError: !0,
        errorObject: g.create(h.VALUE)
      };
    if (Math.abs(o) < n || Math.abs(u) < s)
      return {
        isError: !0,
        errorObject: g.create(h.VALUE)
      };
    let c = r;
    if (r.isArray()) {
      const l = r.getRowCount(), f = r.getColumnCount();
      if (l > 1 || f > 1)
        return {
          isError: !0,
          errorObject: g.create(h.VALUE)
        };
      c = r.get(0, 0);
    }
    return {
      isError: !1,
      rowsValue: o,
      columnsValue: u,
      padWithObject: c
    };
  }
  _getResultArray(e, t, r, n, s, o) {
    let u = [];
    e.isArray() ? u = e.map((f) => f.isNull() ? y.create(0) : f).getArrayValue() : u = [[e]];
    const c = Math.max(0, t - s), l = Math.max(0, r - o);
    for (let f = 0; f < c; f++)
      u.push(new Array(o).fill(n));
    for (let f = 0; f < l; f++)
      u.forEach((m) => {
        m.push(n);
      });
    return t === 1 && r === 1 ? u[0][0] : K.create({
      calculateValueList: u,
      rowCount: u.length,
      columnCount: u[0].length,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
}
class NC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : g.create(h.CALC);
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const s = e.isArray() ? e.getRowCount() : 1, o = e.isArray() ? e.getColumnCount() : 1, u = t.isArray() ? t.getRowCount() : 1, c = t.isArray() ? t.getColumnCount() : 1;
    return u > 1 && c > 1 || u === 1 && c !== o || c === 1 && u !== s ? g.create(h.VALUE) : s === 1 && o === 1 ? this._getResultArrayByR1C1(e, t, n) : u === 1 ? c !== o ? g.create(h.VALUE) : this._getResultArrayByR1(s, o, e, t, n) : c === 1 ? u !== s ? g.create(h.VALUE) : this._getResultArrayByC1(s, o, e, t, n) : n;
  }
  _getResultArrayByR1C1(e, t, r) {
    let n = e, s = t;
    return n.isArray() && (n = n.get(0, 0)), s.isArray() && (s = s.get(0, 0)), s.isString() && (s = s.convertToNumberObjectValue()), s.isError() ? s : +s.getValue() ? n : r;
  }
  _getResultArrayByR1(e, t, r, n, s) {
    const o = [];
    for (let u = 0; u < t; u++) {
      let c = n.get(0, u);
      if (c.isString() && (c = c.convertToNumberObjectValue()), c.isError())
        return c;
      if (+c.getValue())
        for (let f = 0; f < e; f++) {
          o[f] || (o[f] = []);
          const m = r.get(f, u);
          o[f].push(m);
        }
    }
    return o.length === 0 ? s : K.create({
      calculateValueList: o,
      rowCount: o.length,
      columnCount: o[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
  _getResultArrayByC1(e, t, r, n, s) {
    const o = [];
    for (let u = 0; u < e; u++) {
      let c = n.get(u, 0);
      if (c.isString() && (c = c.convertToNumberObjectValue()), c.isError())
        return c;
      if (!+c.getValue())
        continue;
      const f = [];
      for (let m = 0; m < t; m++) {
        const d = r.get(u, m);
        f.push(d);
      }
      o.push(f);
    }
    return o.length === 0 ? s : K.create({
      calculateValueList: o,
      rowCount: o.length,
      columnCount: o[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
}
class VC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
    A(this, "needsReferenceObject", !0);
    A(this, "needsFormulaDataModel", !0);
  }
  calculate(e) {
    var f, m;
    if (!e.isReferenceObject())
      return g.create(h.NA);
    const t = e.getUnitId(), r = e.getSheetId(), s = (m = (f = e.getUnitData()[t]) == null ? void 0 : f[r]) == null ? void 0 : m.cellData, { startRow: o, startColumn: u } = e.getRangePosition(), l = e.toArrayValueObject().mapValue((d, _, C) => {
      const E = s.getValue(o + _, u + C);
      if (E != null && E.f || E != null && E.si) {
        const R = this._formulaDataModel.getFormulaStringByCell(o + _, u + C, r, t);
        return U.create(R);
      }
      return g.create(h.NA);
    });
    return l.getRowCount() === 1 && l.getColumnCount() === 1 ? l.get(0, 0) : l;
  }
}
var re = /* @__PURE__ */ ((a) => (a.ADDRESS = "ADDRESS", a.AREAS = "AREAS", a.CHOOSE = "CHOOSE", a.CHOOSECOLS = "CHOOSECOLS", a.CHOOSEROWS = "CHOOSEROWS", a.COLUMN = "COLUMN", a.COLUMNS = "COLUMNS", a.DROP = "DROP", a.EXPAND = "EXPAND", a.FILTER = "FILTER", a.FORMULATEXT = "FORMULATEXT", a.GETPIVOTDATA = "GETPIVOTDATA", a.HLOOKUP = "HLOOKUP", a.HSTACK = "HSTACK", a.HYPERLINK = "HYPERLINK", a.IMAGE = "IMAGE", a.INDEX = "INDEX", a.INDIRECT = "INDIRECT", a.LOOKUP = "LOOKUP", a.MATCH = "MATCH", a.OFFSET = "OFFSET", a.ROW = "ROW", a.ROWS = "ROWS", a.RTD = "RTD", a.SORT = "SORT", a.SORTBY = "SORTBY", a.TAKE = "TAKE", a.TOCOL = "TOCOL", a.TOROW = "TOROW", a.TRANSPOSE = "TRANSPOSE", a.UNIQUE = "UNIQUE", a.VLOOKUP = "VLOOKUP", a.VSTACK = "VSTACK", a.WRAPCOLS = "WRAPCOLS", a.WRAPROWS = "WRAPROWS", a.XLOOKUP = "XLOOKUP", a.XMATCH = "XMATCH", a))(re || {});
class OC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    if (e.isError())
      return e;
    if (t.isError())
      return g.create(h.REF);
    if (!t.isArray() || r.isError() || n != null && n.isError())
      return g.create(h.NA);
    const s = this.getZeroOrOneByOneDefault(n);
    if (s == null)
      return g.create(h.VALUE);
    const o = this.getIndexNumValue(r);
    if (o instanceof g)
      return o;
    const u = t.slice([0, 1]), c = t.slice([o - 1, o]);
    return u == null || c == null ? g.create(h.REF) : e.isArray() ? e.map((l) => this._handleSingleObject(l, u, c, s)) : this._handleSingleObject(e, u, c, s);
  }
  _handleSingleObject(e, t, r, n) {
    return n === 0 ? this.equalSearch(e, t, r) : this.binarySearch(e, t, r);
  }
}
class SC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = Math.max(
      ...e.map((n) => n.isArray() ? n.getRowCount() : 1)
    ), r = [];
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      if (s.isError())
        return s;
      const o = s.isArray() ? s.getRowCount() : 1, u = s.isArray() ? s.getColumnCount() : 1;
      for (let c = 0; c < t; c++) {
        r[c] || (r[c] = []);
        for (let l = 0; l < u; l++) {
          let f = s;
          s.isArray() && (f = s.get(c, l)), c > o - 1 || !f ? r[c].push(g.create(h.NA)) : r[c].push(f);
        }
      }
    }
    return K.create({
      calculateValueList: r,
      rowCount: r.length,
      columnCount: r[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
}
class MC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (e.isArray() && (r = e.get(0, 0)), r.isError())
      return r;
    let n = t;
    if (t != null && t.isArray() && (n = t.get(0, 0)), n != null && n.isError())
      return n;
    let s = `${r.getValue()}`;
    r.isNull() && (s = "");
    let o = s;
    return n && (o = `${n.getValue()}`, n.isNull() ? o = "0" : n.isBoolean() && (o = o.toLocaleUpperCase())), U.create(o, {
      isHyperlink: !0,
      hyperlinkUrl: s
    });
  }
}
class DC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 5);
  }
  // eslint-disable-next-line complexity
  calculate(e, t, r, n, s) {
    const o = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t != null && t.isArray() ? t.getRowCount() : 1,
      r != null && r.isArray() ? r.getRowCount() : 1,
      n != null && n.isArray() ? n.getRowCount() : 1,
      s != null && s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t != null && t.isArray() ? t.getColumnCount() : 1,
      r != null && r.isArray() ? r.getColumnCount() : 1,
      n != null && n.isArray() ? n.getColumnCount() : 1,
      s != null && s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, e, g.create(h.NA)), l = t ? O(o, u, t, g.create(h.NA)) : void 0, f = r ? O(o, u, r, g.create(h.NA)) : void 0, m = n ? O(o, u, n, g.create(h.NA)) : void 0, d = s ? O(o, u, s, g.create(h.NA)) : void 0, _ = c.mapValue((C, E, R) => {
      if (C.isError())
        return C;
      const b = l ? l.get(E, R) : void 0;
      if (b != null && b.isError())
        return b;
      const p = f ? f.get(E, R) : void 0;
      if (p != null && p.isError())
        return p;
      const V = m ? m.get(E, R) : void 0;
      if (V != null && V.isError())
        return V;
      const S = d ? d.get(E, R) : void 0;
      return S != null && S.isError() ? S : this._handleSingleObject(C, b, p, V, S);
    });
    return o === 1 && u === 1 ? _.get(0, 0) : _;
  }
  // eslint-disable-next-line complexity
  _handleSingleObject(e, t, r, n, s) {
    if (!e.isString())
      return g.create(h.VALUE);
    const o = e.getValue();
    let u = "";
    t && (t.isBoolean() ? u = t.getValue() ? "TRUE" : "FALSE" : t.isNull() || (u = `${t.getValue()}`));
    let c = r != null ? r : y.create(0);
    if (c.isString() && (c = c.convertToNumberObjectValue()), c.isError())
      return c;
    const l = Math.abs(Math.trunc(+c.getValue()));
    if (l < 0 || l > 3 || [0, 1, 2].includes(l) && (n || s))
      return g.create(h.VALUE);
    let f = n != null ? n : y.create(0);
    if (f.isString() && (f = f.convertToNumberObjectValue()), f.isError())
      return f;
    const m = Math.ceil(+f.getValue());
    let d = s != null ? s : y.create(0);
    if (d.isString() && (d = d.convertToNumberObjectValue()), d.isError())
      return d;
    const _ = Math.ceil(+d.getValue());
    return l === 3 && m < 1 && _ < 1 ? g.create(h.VALUE) : U.create("", {
      isImage: !0,
      imageInfo: {
        source: o,
        altText: u,
        sizing: l,
        height: m,
        width: _
      }
    });
  }
}
class wC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 4);
    A(this, "needsReferenceObject", !0);
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  calculate(e, t, r, n) {
    if (e.isError())
      return e;
    const s = this._getReferenceCounts(e);
    let o = t;
    t.isReferenceObject() && (o = t.toArrayValueObject());
    let u = r;
    u != null && u.isReferenceObject() && (u = r.toArrayValueObject());
    let c = n != null ? n : y.create(1);
    c.isReferenceObject() && (c = n.toArrayValueObject());
    const l = Math.max(
      o.isArray() ? o.getRowCount() : 1,
      u != null && u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f = Math.max(
      o.isArray() ? o.getColumnCount() : 1,
      u != null && u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    );
    if (l === 1 && f === 1)
      return this._handleSingleObject(
        e,
        o.isArray() ? o.get(0, 0) : o,
        u ? u.isArray() ? u.get(0, 0) : u : void 0,
        c.isArray() ? c.get(0, 0) : c,
        s
      );
    {
      const m = O(l, f, o, g.create(h.NA)), d = u ? O(l, f, u, g.create(h.NA)) : [], _ = O(l, f, c, g.create(h.NA));
      return m.mapValue((C, E, R) => {
        const b = u ? d.get(E, R) : void 0, p = _.get(E, R), V = this._handleSingleObject(e, C, b, p, s);
        return V.isReferenceObject() ? V.getCellByPosition() : V;
      });
    }
  }
  _handleSingleObject(e, t, r, n, s) {
    let o, u, c;
    if (r) {
      const { isError: C, errorObject: E, variants: R } = I(t, r, n);
      if (C)
        return E;
      o = R[0], u = R[1], c = R[2];
    } else {
      const { isError: C, errorObject: E, variants: R } = I(t, n);
      if (C)
        return E;
      o = R[0], c = R[1];
    }
    const l = Math.floor(+c.getValue());
    if (l < 0)
      return g.create(h.VALUE);
    if (l > s.length)
      return g.create(h.REF);
    const f = s[l - 1];
    let m = 0, d = 0;
    if (f.rowCount === 1 && !r ? d = Math.floor(+o.getValue()) : (m = Math.floor(+o.getValue()), r && (d = Math.floor(+u.getValue()))), m < 0 || d < 0)
      return g.create(h.VALUE);
    if (m > f.rowCount || d > f.columnCount)
      return g.create(h.REF);
    let _ = e;
    return l > 1 && (_ = e.getCubeValues()[l - 1]), _.isReferenceObject() ? this._calculateReferenceObject(_, m, d) : this._calculateArrayObject(_, m, d);
  }
  _getReferenceCounts(e) {
    let t = [
      {
        rowCount: 1,
        columnCount: 1
      }
    ];
    return e.isReferenceObject() ? t = [
      {
        rowCount: e.getRowCount(),
        columnCount: e.getColumnCount()
      }
    ] : e.isCube() ? t = e.getCubeValues().map((r) => ({
      rowCount: r.getRowCount(),
      columnCount: r.getColumnCount()
    })) : e.isArray() && (t = [
      {
        rowCount: e.getRowCount(),
        columnCount: e.getColumnCount()
      }
    ]), t;
  }
  _calculateReferenceObject(e, t, r) {
    const { startRow: n, endRow: s, startColumn: o, endColumn: u } = e.getRangePosition();
    let c = 0, l = 0, f = 0, m = 0;
    if (t === 0 ? (c = n, l = s) : c = l = n + t - 1, r === 0 ? (f = o, m = u) : f = m = o + r - 1, c > s || f > u)
      return g.create(h.REF);
    const d = {
      startRow: c,
      startColumn: f,
      endRow: l,
      endColumn: m
    };
    return this.createReferenceObject(e, d);
  }
  _calculateArrayObject(e, t, r) {
    return !e.isArray() || t === 0 && r === 0 ? e : t === 0 ? e.slice(void 0, [r - 1, r]) : r === 0 ? e.slice([t - 1, t], void 0) : e.get(t - 1, r - 1);
  }
}
class LC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  isAddress() {
    return !0;
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t != null && t.isError())
      return t;
    let r = this.getZeroOrOneByOneDefault(t);
    r == null && (r = 1);
    let n = e;
    if (e.isArray()) {
      const s = e.getRowCount(), o = e.getColumnCount();
      if (s > 1 || o > 1)
        return e.map(() => g.create(h.VALUE));
      n = e.getFirstCell();
    }
    return this._handleSingleObject(n, r);
  }
  _handleSingleObject(e, t) {
    const r = `${e.getValue()}`;
    if (r.trim() === "")
      return g.create(h.REF);
    const n = this._convertToDefinedName(r);
    if (t === 0) {
      const f = wh(n), { range: m, sheetName: d, unitId: _ } = f, C = new xn(m);
      return C.setForcedUnitIdDirect(_), C.setForcedSheetName(d), this._setDefault(C);
    }
    if (qr(n))
      return this._setDefault(new Ma(n));
    if (_o(n))
      return this._setDefault(new wa(n));
    if (Ao(n))
      return this._setDefault(new Da(n));
    const s = br(n), { range: o, sheetName: u, unitId: c } = s;
    if (Number.isNaN(o.startRow) || o.endRow + 1 > 1048576 || Number.isNaN(o.startColumn) || o.endColumn + 1 > 16384)
      return g.create(h.REF);
    const l = new xn(o);
    return l.setForcedUnitIdDirect(c), l.setForcedSheetName(u), this._setDefault(l);
  }
  _setDefault(e) {
    return this.unitId == null || this.subUnitId == null ? g.create(h.REF) : (e.setDefaultUnitId(this.unitId), e.setDefaultSheetId(this.subUnitId), e);
  }
  /**
   * In Excel, to inject a defined name into a function that has positioning capabilities,
   * such as using the INDIRECT function to reference a named range,
   * you can write it as follows:
   * =INDIRECT("DefinedName1")
   */
  _convertToDefinedName(e) {
    const t = this.getDefinedName(e);
    if (t == null)
      return e;
    const r = t.formulaOrRefString;
    return r == null ? e : r.startsWith(Z.EQUALS) ? r.slice(1) : r;
  }
}
class PC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
    A(this, "needsExpandParams", !0);
  }
  calculate(e, t, r) {
    return e.isError() ? e : t.isError() ? g.create(h.REF) : t.isArray() ? r != null && r.isError() ? r : t.getColumnCount() === 1 || t.getRowCount() === 1 ? r != null && !r.isArray() ? g.create(h.REF) : this._handleVector(e, t, r) : this._handleArray(e, t) : g.create(h.VALUE);
  }
  _handleVector(e, t, r) {
    let n = r;
    if (n == null)
      n = t;
    else if (n.getRowCount() !== t.getRowCount() || n.getColumnCount() !== t.getColumnCount())
      return g.create(h.REF);
    return e.isArray() ? e.map((s) => this.binarySearch(s, t, n)) : this.binarySearch(e, t, n);
  }
  _handleArray(e, t) {
    const r = t.getRowCount(), n = t.getColumnCount();
    let s, o;
    return n > r ? (s = t.slice([0, 1]), o = t.slice([r - 1, r])) : (s = t.slice(void 0, [0, 1]), o = t.slice(void 0, [n - 1, n])), s == null || o == null ? g.create(h.VALUE) : e.isArray() ? e.map((u) => this.binarySearch(u, s, o)) : this.binarySearch(e, s, o);
  }
}
class xC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    if (e.isError())
      return e;
    if (t.isError())
      return g.create(h.REF);
    if (!t.isArray())
      return g.create(h.VALUE);
    const n = t.getRowCount(), s = t.getColumnCount();
    if (n !== 1 && s !== 1 || r != null && r.isError())
      return g.create(h.NA);
    const o = this.getMatchTypeValue(r);
    return o == null ? g.create(h.VALUE) : e.isArray() ? e.map((u) => this._handleSingleObject(
      u,
      t,
      o
    )) : this._handleSingleObject(
      e,
      t,
      o
    );
  }
  _handleSingleObject(e, t, r) {
    const n = e.isNull() ? y.create(0) : e, s = this._getSearchModeValue(r), o = t.orderSearch(n, s);
    if (o == null)
      return g.create(h.NA);
    if (o instanceof g)
      return o;
    const u = t.getRowCount() === 1 ? o.column + 1 : o.row + 1;
    return y.create(u);
  }
  _getSearchModeValue(e) {
    switch (e) {
      case 1:
        return xe.MIN;
      case 0:
        return xe.NORMAL;
      case -1:
        return xe.MAX;
    }
  }
}
class jC extends jr {
  constructor(e, t = []) {
    super(e);
    /**
     * 2D structure:
     * - First dimension: stored by rows
     * - Second dimension: each AreaValue within that row
     */
    A(this, "_areas", []);
    this._areas = t;
  }
  dispose() {
    this._areas.forEach((e) => {
      e.forEach((t) => t.dispose());
    }), this._areas = [], super.dispose();
  }
  // ------------------------------------------------------------
  // Area Management
  // ------------------------------------------------------------
  getAreas() {
    return this._areas;
  }
  setAreas(e) {
    this._areas = e;
  }
  /**
   * Append an area:
   * - If a single AreaValue is passed, it will be wrapped as one row.
   * - If an AreaValue[] is passed, it will be inserted as an entire row.
   */
  addArea(e) {
    Array.isArray(e) ? this._areas.push(e) : this._areas.push([e]);
  }
  /** Flatten the 2D areas to reuse 1D logic */
  _flatAreas() {
    return this._areas.flat();
  }
  // ------------------------------------------------------------
  // Multi-area identification
  // ------------------------------------------------------------
  isMultiArea() {
    return !0;
  }
  isRange() {
    return !1;
  }
  isCell() {
    return !1;
  }
  isRow() {
    return !1;
  }
  isColumn() {
    return !1;
  }
  // ------------------------------------------------------------
  // Range-related queries
  // ------------------------------------------------------------
  getRowCount() {
    let e = 0;
    for (const t of this._flatAreas())
      t.isError() || (e += t.getRowCount());
    return e;
  }
  getColumnCount() {
    let e = 0;
    for (const t of this._flatAreas())
      t.isError() || (e += t.getColumnCount());
    return e;
  }
  isExceedRange() {
    return this._flatAreas().some((e) => e.isError() ? !1 : e.isExceedRange());
  }
  setRefOffset(e = 0, t = 0) {
    super.setRefOffset(e, t), this._flatAreas().forEach((r) => {
      r.isError() || r.setRefOffset(e, t);
    });
  }
  _getReferenceArea() {
    return this._flatAreas().find((r) => !r.isError());
  }
  // ------------------------------------------------------------
  // Unit/Sheet resolution
  // ------------------------------------------------------------
  /**
   * Multi-area reference may span multiple sheets, but Excel requires
   * them to be in the same sheet for most functions. We follow Excel semantics
   * by returning the first area’s identifiers.
   */
  getUnitId() {
    var e, t;
    return (t = (e = this._getReferenceArea()) == null ? void 0 : e.getUnitId()) != null ? t : super.getUnitId();
  }
  getSheetId() {
    var e, t;
    return (t = (e = this._getReferenceArea()) == null ? void 0 : e.getSheetId()) != null ? t : super.getSheetId();
  }
  getActiveSheetRowCount() {
    var e, t;
    return (t = (e = this._getReferenceArea()) == null ? void 0 : e.getActiveSheetRowCount()) != null ? t : 0;
  }
  getActiveSheetColumnCount() {
    var e, t;
    return (t = (e = this._getReferenceArea()) == null ? void 0 : e.getActiveSheetColumnCount()) != null ? t : 0;
  }
  // ------------------------------------------------------------
  // Cell traversal
  // ------------------------------------------------------------
  /**
   * Iterate through all areas in order, flattening the multi-area into
   * a sequence of cells.
   *
   * Note: The order here is "row-major":
   *   iterate by the row order of _areas, then within each row by the area order.
   */
  iterator(e) {
    for (const t of this._areas) {
      let r = !1;
      for (const n of t) {
        if (n.isError())
          continue;
        let s = !1;
        if (n.iterator((o, u, c) => {
          const l = e(o, u, c);
          return l === !1 ? (s = !0, r = !0, !1) : l;
        }), s)
          break;
      }
      if (r)
        return;
    }
  }
  /**
   * Excel defines the "first cell" of a multi-area reference
   * as the first cell of the first area.
   */
  getFirstCell() {
    const e = this._getReferenceArea();
    return e ? e.getFirstCell() : super.getFirstCell();
  }
  // ------------------------------------------------------------
  // Conversion to Array or Cube
  // ------------------------------------------------------------
  /**
   * For multi-area, we only take the *first cell* of each area and
   * arrange them into a 2D ArrayValueObject:
   *
   * - outer `_areas` dimension => rows
   * - inner `_areas[row]` dimension => columns
   */
  toArrayValueObject() {
    var n, s;
    const e = this._areas.length;
    if (e === 0)
      return mt([], 0, 0);
    const t = (s = (n = this._areas[0]) == null ? void 0 : n.length) != null ? s : 0, r = [];
    for (let o = 0; o < e; o++) {
      const u = this._areas[o];
      if (u) {
        r[o] = r[o] || [];
        for (let c = 0; c < t; c++) {
          const l = u[c];
          if (!l)
            continue;
          if (l.isError()) {
            r[o][c] = l;
            continue;
          }
          let f = null;
          l.iterator((m) => (f = m != null ? m : null, !1)), f != null && (r[o][c] = f), r[o][c] = ce.create();
        }
      }
    }
    return mt(r, e, t);
  }
  getRangePosition() {
    const e = this._flatAreas();
    if (!e.length)
      return super.getRangePosition();
    let t = Number.POSITIVE_INFINITY, r = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY, s = Number.NEGATIVE_INFINITY;
    for (const o of e) {
      if (o.isError())
        continue;
      const { startRow: u, startColumn: c, endRow: l, endColumn: f } = o.getRangePosition();
      !Number.isFinite(u) || !Number.isFinite(c) || !Number.isFinite(l) || !Number.isFinite(f) || (u < t && (t = u), c < r && (r = c), l > n && (n = l), f > s && (s = s < f ? f : s));
    }
    return !Number.isFinite(t) || !Number.isFinite(r) || !Number.isFinite(n) || !Number.isFinite(s) ? super.getRangePosition() : {
      startRow: t,
      startColumn: r,
      endRow: n,
      endColumn: s
    };
  }
  toUnitRange() {
    return {
      range: this.getRangePosition(),
      sheetId: this.getSheetId(),
      unitId: this.getUnitId()
    };
  }
  getRangeData() {
    const e = this._flatAreas();
    if (!e.length)
      return super.getRangeData();
    let t = Number.POSITIVE_INFINITY, r = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY, s = Number.NEGATIVE_INFINITY;
    for (const o of e) {
      if (o.isError())
        continue;
      const { startRow: u, startColumn: c, endRow: l, endColumn: f } = o.getRangeData();
      !Number.isFinite(u) || !Number.isFinite(c) || !Number.isFinite(l) || !Number.isFinite(f) || (u < t && (t = u), c < r && (r = c), l > n && (n = l), f > s && (s = f));
    }
    return !Number.isFinite(t) || !Number.isFinite(r) || !Number.isFinite(n) || !Number.isFinite(s) ? super.getRangeData() : {
      startRow: t,
      startColumn: r,
      endRow: n,
      endColumn: s
    };
  }
}
class UC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 5);
    A(this, "needsReferenceObject", !0);
  }
  isAddress() {
    return !0;
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  calculate(e, t, r, n, s) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (r.isError())
      return r;
    if (n != null && n.isError())
      return n;
    if (s != null && s.isError())
      return s;
    if (!e.isReferenceObject())
      return g.create(h.VALUE);
    const o = e.getRowCount(), u = e.getColumnCount();
    let c = t;
    c.isReferenceObject() && (c = c.toArrayValueObject());
    let l = r;
    l.isReferenceObject() && (l = l.toArrayValueObject());
    let f = n != null ? n : y.create(o);
    f.isReferenceObject() && (f = f.toArrayValueObject()), f.isNull() && (f = y.create(o));
    let m = s != null ? s : y.create(u);
    m.isReferenceObject() && (m = m.toArrayValueObject()), m.isNull() && (m = y.create(u));
    const d = Math.max(
      c.isArray() ? c.getRowCount() : 1,
      l.isArray() ? l.getRowCount() : 1,
      f.isArray() ? f.getRowCount() : 1,
      m.isArray() ? m.getRowCount() : 1
    ), _ = Math.max(
      c.isArray() ? c.getColumnCount() : 1,
      l.isArray() ? l.getColumnCount() : 1,
      f.isArray() ? f.getColumnCount() : 1,
      m.isArray() ? m.getColumnCount() : 1
    );
    if (c = c, l = l, f = f, m = m, d === 1 && _ === 1)
      return c = c.isArray() ? c.get(0, 0) : c, l = l.isArray() ? l.get(0, 0) : l, f = f.isArray() ? f.get(0, 0) : f, m = m.isArray() ? m.get(0, 0) : m, this._handleSingleObject(e, c, l, f, m);
    const C = O(d, _, c, g.create(h.NA)), E = O(d, _, l, g.create(h.NA)), R = O(d, _, f, g.create(h.NA)), b = O(d, _, m, g.create(h.NA)), p = [];
    return C.iterator((V, S, M) => {
      const D = E.get(S, M), w = R.get(S, M), L = b.get(S, M);
      if (p[S] = p[S] || [], V == null) {
        p[S][M] = g.create(h.NA);
        return;
      }
      if (V.isError()) {
        p[S][M] = V;
        return;
      }
      if (D.isError()) {
        p[S][M] = D;
        return;
      }
      if (w.isError()) {
        p[S][M] = w;
        return;
      }
      if (L.isError()) {
        p[S][M] = L;
        return;
      }
      const v = this._handleSingleObject(e, V, D, w, L);
      p[S][M] = v;
    }), new jC("", p);
  }
  // eslint-disable-next-line
  _handleSingleObject(e, t, r, n, s) {
    const { startRow: o, startColumn: u } = e.getRangePosition();
    let c = t;
    if (c.isString() && (c = c.convertToNumberObjectValue()), c.isError())
      return c;
    let l = r;
    if (l.isString() && (l = l.convertToNumberObjectValue()), l.isError())
      return l;
    const f = +c.getValue(), m = +l.getValue();
    if (typeof f != "number" || typeof m != "number")
      return g.create(h.VALUE);
    const d = o + f, _ = u + m;
    if (d < 0 || _ < 0)
      return g.create(h.REF);
    const C = this.getIndexNumValue(n), E = this.getIndexNumValue(s);
    if (typeof C != "number" || typeof E != "number")
      return g.create(h.VALUE);
    if (C === 0 || E === 0)
      return g.create(h.REF);
    const R = C > 0 ? d + C - 1 : d + C + 1, b = E > 0 ? _ + E - 1 : _ + E + 1;
    if (R < 0 || b < 0)
      return g.create(h.REF);
    const p = d < R ? d : R, V = _ < b ? _ : b, S = d > R ? d : R, M = _ > b ? _ : b, D = {
      startRow: p,
      startColumn: V,
      endRow: S,
      endColumn: M
    };
    return this.createReferenceObject(e, D);
  }
}
class vC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e == null)
      return y.create(this.row + 1);
    if (e.isError())
      return e;
    if (!e.isArray())
      return g.create(h.NA);
    const t = e.getCurrentRow(), r = e.getRowCount(), n = [];
    for (let o = 0; o < r; o++)
      n.push([y.create(t + o + 1)]);
    const s = {
      calculateValueList: n,
      rowCount: r,
      columnCount: 1,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    };
    return K.create(s);
  }
}
class TC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isError())
      return e;
    if (e.isString() || e.isNumber() || e.isBoolean())
      return y.create(1);
    if (!e.isArray())
      return g.create(h.NA);
    const t = e.getRowCount();
    return y.create(t);
  }
}
class IC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    let s = t != null ? t : y.create(1);
    const o = r != null ? r : y.create(1), u = n != null ? n : T.create(!1);
    if (s.isNull() && (s = y.create(1)), u.isArray()) {
      const c = u.getRowCount(), l = u.getColumnCount();
      if (c === 1 && l === 1) {
        const f = u.get(0, 0);
        return this._handleSingleObject(e, s, o, f);
      }
      return u.map((f) => {
        const m = this._handleSingleObject(e, s, o, f);
        return m.isArray() ? m.get(0, 0) : m;
      });
    }
    return this._handleSingleObject(e, s, o, u);
  }
  _handleSingleObject(e, t, r, n) {
    if (e.isError())
      return e;
    const s = e.isArray() ? e.getRowCount() : 1, o = e.isArray() ? e.getColumnCount() : 1, u = this._checkArrayError(t);
    if (u.isError())
      return u;
    const c = Math.floor(+u.getValue());
    if (c < 1)
      return g.create(h.VALUE);
    const l = this._checkArrayError(r);
    if (l.isError())
      return l;
    const f = Math.floor(+l.getValue());
    if (f !== -1 && f !== 1)
      return g.create(h.VALUE);
    let m = n;
    if (m.isString() && (m = m.convertToNumberObjectValue()), m.isError())
      return m;
    if (!e.isArray() || s === 1 && o === 1)
      return e;
    const d = +m.getValue();
    return this._getResult(e, c, f, d, s, o);
  }
  _checkArrayError(e) {
    let t = e;
    if (t.isArray()) {
      const r = t.getRowCount(), n = t.getColumnCount();
      if (r > 1 || n > 1)
        return g.create(h.VALUE);
      t = t.get(0, 0);
    }
    return t.isString() && (t = t.convertToNumberObjectValue()), t;
  }
  _getResult(e, t, r, n, s, o) {
    if (n) {
      if (t > s)
        return g.create(h.VALUE);
      const u = e.transpose().getArrayValue();
      return u.sort(this._sort(t - 1, r)), K.create({
        calculateValueList: u,
        rowCount: u.length,
        columnCount: u[0].length || 0,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      }).transpose();
    } else {
      if (t > o)
        return g.create(h.VALUE);
      const u = e.getArrayValue();
      return u.sort(this._sort(t - 1, r)), K.create({
        calculateValueList: u,
        rowCount: u.length,
        columnCount: u[0].length || 0,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      });
    }
  }
  _sort(e, t = 1) {
    const r = Dn();
    return t === 1 ? this._sortAsc(e, r) : this._sortDesc(e, r);
  }
  _sortAsc(e, t) {
    return (r, n) => {
      const s = r[e], o = n[e];
      if (s == null || s.isNull())
        return 1;
      if (o == null || o.isNull())
        return -1;
      if (s.isError() && o.isError())
        return 0;
      if (s.isError())
        return 1;
      if (o.isError())
        return -1;
      const u = s.getValue(), c = o.getValue();
      return s.isBoolean() && u === !0 ? 1 : o.isBoolean() && c === !0 ? -1 : s.isBoolean() && u === !1 ? 1 : o.isBoolean() && c === !1 ? -1 : s.isNumber() && o.isNumber() ? +u - +c : t(
        u,
        c
      );
    };
  }
  _sortDesc(e, t) {
    return (r, n) => {
      const s = r[e], o = n[e];
      if (s == null || s.isNull())
        return 1;
      if (o == null || o.isNull())
        return -1;
      if (s.isError() && o.isError())
        return 0;
      if (s.isError())
        return -1;
      if (o.isError())
        return 1;
      const u = s.getValue(), c = o.getValue();
      return s.isBoolean() && u === !0 ? -1 : o.isBoolean() && c === !0 ? 1 : s.isBoolean() && u === !1 ? -1 : o.isBoolean() && c === !1 ? 1 : s.isNumber() && o.isNumber() ? +c - +u : t(
        c,
        u
      );
    };
  }
}
class BC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
  }
  calculate(e, ...t) {
    t.length === 1 && t.push(y.create(1));
    const r = this._getVariantsError(e, ...t), { maxRowLength: n, maxColumnLength: s } = wm(t);
    if (r.isError()) {
      const c = O(n, s, r);
      return n === 1 && s === 1 ? c.get(0, 0) : c;
    }
    const o = t.map((c, l) => l % 2 === 0 ? c : O(n, s, c, g.create(h.NA))), u = this._getResultArray(e, o, n, s);
    return n === 1 && s === 1 ? u[0][0] : K.create({
      calculateValueList: u,
      rowCount: u.length,
      columnCount: u[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
  // eslint-disable-next-line complexity
  _getVariantsError(e, ...t) {
    if (e.isError())
      return e;
    for (let u = 0; u < t.length; u++) {
      const c = t[u];
      if (c.isError())
        return c;
    }
    if (t.length < 2 || t.length % 2 !== 0)
      return g.create(h.VALUE);
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t[0].isArray() ? t[0].getRowCount() : 1, o = t[0].isArray() ? t[0].getColumnCount() : 1;
    if ((s > 1 || o > 1) && (s > 1 && o > 1 || s === 1 && o !== n || o === 1 && s !== r))
      return g.create(h.VALUE);
    for (let u = 2; u < t.length; u++) {
      if (u % 2 === 1)
        continue;
      const c = t[u].isArray() ? t[u].getRowCount() : 1, l = t[u].isArray() ? t[u].getColumnCount() : 1;
      if (c !== s || l !== o)
        return g.create(h.VALUE);
    }
    return T.create(!0);
  }
  _getResultArray(e, t, r, n) {
    const s = e.isArray() ? e.getRowCount() : 1, o = e.isArray() ? e.getColumnCount() : 1, u = t[0].isArray() ? t[0].getRowCount() : 1, c = t[0].isArray() ? t[0].getColumnCount() : 1, l = [];
    for (let f = 0; f < r; f++) {
      l[f] = [];
      for (let m = 0; m < n; m++) {
        const { isError: d, errorObject: _, byArrays: C, sortOrders: E } = this._getByArraysAndSortOrders(t, f, m, c);
        if (d) {
          l[f].push(_);
          continue;
        }
        if (!e.isArray() || s === 1 && o === 1) {
          l[f].push(e);
          continue;
        }
        let R = e.getArrayValue();
        u === 1 && c === 1 || (u === 1 ? (R = R.concat(C), R = this._transposeArray(R), R.sort(this._sort(s, E)), R = this._transposeArray(R).slice(0, s)) : c === 1 && (R = this._transposeArray(R), R = R.concat(C), R = this._transposeArray(R), R.sort(this._sort(o, E)), R = R.map((p) => p.slice(0, o))));
        const b = K.create({
          calculateValueList: R,
          rowCount: R.length,
          columnCount: R[0].length || 0,
          unitId: this.unitId,
          sheetId: this.subUnitId,
          row: this.row,
          column: this.column
        });
        if (r > 1 || n > 1) {
          l[f].push(b.get(0, 0));
          continue;
        }
        l[f].push(b);
      }
    }
    return l;
  }
  _getByArraysAndSortOrders(e, t, r, n) {
    const s = [], o = [];
    let u = !1, c = null;
    for (let l = 0; l < e.length; l++) {
      if (l % 2 === 1)
        continue;
      const f = e[l];
      let m = e[l + 1].get(t, r);
      if (m.isString() && (m = m.convertToNumberObjectValue()), m.isError()) {
        u = !0, c = m;
        break;
      }
      const d = Math.floor(+m.getValue());
      if (d !== -1 && d !== 1) {
        u = !0, c = g.create(h.VALUE);
        break;
      }
      if (o.push(d), f.isArray()) {
        let _ = f.getArrayValue();
        n === 1 && (_ = this._transposeArray(_)), s.push(_[0]);
      } else
        s.push([f]);
    }
    return {
      isError: u,
      errorObject: c,
      byArrays: s,
      sortOrders: o
    };
  }
  _transposeArray(e) {
    const t = e.length, r = e[0].length, n = [];
    for (let s = 0; s < r; s++) {
      n[s] = [];
      for (let o = 0; o < t; o++)
        n[s][o] = e[o][s];
    }
    return n;
  }
  _sort(e, t) {
    const r = Dn();
    return (n, s) => {
      let o = n[e], u = s[e], c = this._compare(o, u, t[0], r);
      if (c === 0 && t.length > 1) {
        for (let l = 1; l < t.length; l++)
          if (o = n[e + l], u = s[e + l], c = this._compare(o, u, t[l], r), c !== 0)
            return c;
      }
      return c;
    };
  }
  _compare(e, t, r, n) {
    return r === 1 ? this._asc(e, t, n) : this._desc(e, t, n);
  }
  _asc(e, t, r) {
    if (e == null || e.isNull())
      return 1;
    if (t == null || t.isNull())
      return -1;
    if (e.isError() && t.isError())
      return 0;
    if (e.isError())
      return 1;
    if (t.isError())
      return -1;
    const n = e.getValue(), s = t.getValue();
    return e.isBoolean() && n === !0 ? 1 : t.isBoolean() && s === !0 ? -1 : e.isBoolean() && n === !1 ? 1 : t.isBoolean() && s === !1 ? -1 : e.isNumber() && t.isNumber() ? +n - +s : r(
      n,
      s
    );
  }
  _desc(e, t, r) {
    if (e == null || e.isNull())
      return 1;
    if (t == null || t.isNull())
      return -1;
    if (e.isError() && t.isError())
      return 0;
    if (e.isError())
      return -1;
    if (t.isError())
      return 1;
    const n = e.getValue(), s = t.getValue();
    return e.isBoolean() && n === !0 ? -1 : t.isBoolean() && s === !0 ? 1 : e.isBoolean() && n === !1 ? -1 : t.isBoolean() && s === !1 ? 1 : e.isNumber() && t.isNumber() ? +s - +n : r(
      s,
      n
    );
  }
}
class FC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = e.isArray() ? e.getRowCount() : 1, s = e.isArray() ? e.getColumnCount() : 1;
    let o = t, u = r != null ? r : y.create(s);
    t.isNull() && (o = y.create(n)), u.isNull() && (u = y.create(s));
    const c = Math.max(
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1
    ), l = Math.max(
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1
    ), f = O(c, l, o, g.create(h.NA)), m = O(c, l, u, g.create(h.NA));
    if (c > 1 || l > 1)
      return f.mapValue((p, V, S) => {
        const M = m.get(V, S);
        if (e.isError())
          return e;
        if (e.isNull())
          return g.create(h.VALUE);
        const { isError: D, errorObject: w } = this._checkRowsColumns(p, M, n, s);
        return D ? w : e.isArray() ? g.create(h.VALUE) : e;
      });
    if (e.isError())
      return e;
    if (e.isNull())
      return g.create(h.VALUE);
    const d = o.isArray() ? o.get(0, 0) : o, _ = u.isArray() ? u.get(0, 0) : u, { isError: C, errorObject: E, rowsValue: R, columnsValue: b } = this._checkRowsColumns(d, _, n, s);
    return C ? E : this._getResultArray(e, R, b, n, s);
  }
  _checkRowsColumns(e, t, r, n) {
    if (e.isError())
      return {
        isError: !0,
        errorObject: e
      };
    if (t.isError())
      return {
        isError: !0,
        errorObject: t
      };
    let s = Math.trunc(+e.getValue()), o = Math.trunc(+t.getValue());
    return Number.isNaN(s) || Number.isNaN(o) ? {
      isError: !0,
      errorObject: g.create(h.VALUE)
    } : Math.abs(s) === 0 || Math.abs(o) === 0 ? {
      isError: !0,
      errorObject: g.create(h.CALC)
    } : (s > r && (s = r), o > n && (o = n), {
      isError: !1,
      rowsValue: s,
      columnsValue: o
    });
  }
  _getResultArray(e, t, r, n, s) {
    if (!e.isArray())
      return e;
    const o = t >= 0 ? [0, t] : [n + t, n], u = r >= 0 ? [0, r] : [s + r, s];
    let c;
    return t === n && r === s ? c = e : t === n ? c = e.slice(void 0, u) : r === s ? c = e.slice(o, void 0) : c = e.slice(o, u), c = c.map((l) => l.isNull() ? y.create(0) : l), t === 1 && r === 1 ? c.get(0, 0) : c;
  }
}
class kC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = t != null ? t : y.create(0), s = r != null ? r : T.create(!1), o = Math.max(
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, n, g.create(h.NA)), l = O(o, u, s, g.create(h.NA)), f = c.mapValue((m, d, _) => {
      const C = l.get(d, _);
      if (e.isError())
        return e;
      if (e.isNull())
        return g.create(h.VALUE);
      if (m.isError())
        return m;
      if (C.isError())
        return C;
      const E = Math.trunc(+m.getValue()), R = +C.getValue();
      if (Number.isNaN(E) || E < 0 || E > 3 || Number.isNaN(R))
        return g.create(h.VALUE);
      if (!e.isArray())
        return e;
      let b = [];
      return R ? b = this._getArrayValueByColumn(e, E) : b = this._getArrayValueByRow(e, E), b.length === 0 ? g.create(h.CALC) : o > 1 || u > 1 || b.length === 1 ? b[0] : K.create({
        calculateValueList: b.map((p) => [p]),
        rowCount: b.length,
        columnCount: 1,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      });
    });
    return o === 1 && u === 1 ? f.get(0, 0) : f;
  }
  _getArrayValueByColumn(e, t) {
    const r = e, n = r.getRowCount(), s = r.getColumnCount(), o = [];
    for (let u = 0; u < s; u++)
      for (let c = 0; c < n; c++) {
        const l = r.get(c, u);
        this._isIgnore(l, t) || o.push(l.isNull() ? y.create(0) : l);
      }
    return o;
  }
  _getArrayValueByRow(e, t) {
    const r = e, n = r.getRowCount(), s = r.getColumnCount(), o = [];
    for (let u = 0; u < n; u++)
      for (let c = 0; c < s; c++) {
        const l = r.get(u, c);
        this._isIgnore(l, t) || o.push(l.isNull() ? y.create(0) : l);
      }
    return o;
  }
  _isIgnore(e, t) {
    switch (t) {
      case 0:
        return !1;
      case 1:
        return e.isNull();
      case 2:
        return e.isError();
      case 3:
        return e.isNull() || e.isError();
      default:
        return !1;
    }
  }
}
class $C extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = t != null ? t : y.create(0), s = r != null ? r : T.create(!1), o = Math.max(
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, n, g.create(h.NA)), l = O(o, u, s, g.create(h.NA)), f = c.mapValue((m, d, _) => {
      const C = l.get(d, _);
      if (e.isError())
        return e;
      if (m.isError())
        return m;
      if (C.isError())
        return C;
      const E = Math.trunc(+m.getValue()), R = +C.getValue();
      if (Number.isNaN(E) || E < 0 || E > 3 || Number.isNaN(R) || e.isNull())
        return g.create(h.VALUE);
      if (!e.isArray())
        return e;
      let b = [];
      return R ? b = this._getArrayValueByColumn(e, E) : b = this._getArrayValueByRow(e, E), b.length === 0 ? g.create(h.CALC) : o > 1 || u > 1 || b.length === 1 ? b[0] : K.create({
        calculateValueList: [b],
        rowCount: 1,
        columnCount: b.length,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      });
    });
    return o === 1 && u === 1 ? f.get(0, 0) : f;
  }
  _getArrayValueByColumn(e, t) {
    const r = e, n = r.getRowCount(), s = r.getColumnCount(), o = [];
    for (let u = 0; u < s; u++)
      for (let c = 0; c < n; c++) {
        const l = r.get(c, u);
        this._isIgnore(l, t) || o.push(l.isNull() ? y.create(0) : l);
      }
    return o;
  }
  _getArrayValueByRow(e, t) {
    const r = e, n = r.getRowCount(), s = r.getColumnCount(), o = [];
    for (let u = 0; u < n; u++)
      for (let c = 0; c < s; c++) {
        const l = r.get(u, c);
        this._isIgnore(l, t) || o.push(l.isNull() ? y.create(0) : l);
      }
    return o;
  }
  _isIgnore(e, t) {
    switch (t) {
      case 0:
        return !1;
      case 1:
        return e.isNull();
      case 2:
        return e.isError();
      case 3:
        return e.isNull() || e.isError();
      default:
        return !1;
    }
  }
}
class YC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isError())
      return e;
    if (e.isArray()) {
      const t = e.getRowCount(), r = e.getColumnCount();
      return t === 1 && r === 1 ? e.get(0, 0) : e.transpose();
    }
    return e;
  }
}
class HC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = t != null ? t : T.create(!1), s = r != null ? r : T.create(!1), o = e.isArray() ? e.getRowCount() : 1, u = e.isArray() ? e.getColumnCount() : 1, c = Math.max(
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), l = Math.max(
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), f = O(c, l, n, g.create(h.NA)), m = O(c, l, s, g.create(h.NA)), d = f.map((_, C, E) => {
      let R = _, b = m.get(C, E);
      if (e.isError())
        return e;
      if (R.isString() && (R = R.convertToNumberObjectValue()), R.isError())
        return R;
      if (b.isString() && (b = b.convertToNumberObjectValue()), b.isError())
        return b;
      const p = +R.getValue(), V = +b.getValue();
      let S;
      return !p && o === 1 || p && u === 1 ? S = e : S = this._getResult(e, p, V), (c > 1 || l > 1) && (S != null && S.isArray()) ? S.get(0, 0) : S;
    });
    return c === 1 && l === 1 ? d.get(0, 0) : d;
  }
  _getResult(e, t, r) {
    const n = e.isArray() ? e.getRowCount() : 1, s = e.isArray() ? e.getColumnCount() : 1;
    let o = e.getArrayValue(), u = n, c = s;
    t && (o = this._transposeArray(o), u = s, c = n);
    const l = this._getRepeatRows(o, u, c);
    if (l.length > 0) {
      const f = [];
      l.forEach((m) => {
        m.forEach((d, _) => {
          (_ !== 0 || r) && f.push(d);
        });
      }), o = o.filter((m, d) => !f.includes(d));
    }
    return o.length === 0 ? g.create(h.CALC) : (t && (o = this._transposeArray(o)), K.create({
      calculateValueList: o,
      rowCount: o.length,
      columnCount: o[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    }));
  }
  _getRepeatRows(e, t, r) {
    let n = [];
    for (let s = 0; s < r; s++)
      if (s === 0) {
        const o = new Array(t).fill(null).map((u, c) => ({
          r: c,
          valueObject: e[c][s]
        }));
        n = this._getRepeatRowsByObjects(o);
      } else {
        if (n.length === 0)
          break;
        let o = [];
        n.forEach((u) => {
          const c = u.map((f) => ({
            r: f,
            valueObject: e[f][s]
          })), l = this._getRepeatRowsByObjects(c);
          o = o.concat(l);
        }), n = o;
      }
    return n;
  }
  _getRepeatRowsByObjects(e) {
    const t = /* @__PURE__ */ new Map();
    return e.forEach((r) => {
      const n = r.r, s = r.valueObject;
      let o = s.getValue();
      if (s.isNull() ? o = null : s.isString() && q(o) && (o = +o), !t.has(o))
        t.set(o, [n]);
      else {
        const u = t.get(o);
        u.push(n), t.set(o, u);
      }
    }), Array.from(t.values()).filter((r) => r.length > 1);
  }
  _transposeArray(e) {
    const t = e.length, r = e[0].length, n = [];
    for (let s = 0; s < r; s++) {
      n[s] = [];
      for (let o = 0; o < t; o++)
        n[s][o] = e[o][s];
    }
    return n;
  }
}
class GC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (!t.isArray())
      return g.create(h.VALUE);
    if (r.isError())
      return r;
    if (n != null && n.isError())
      return n;
    const s = n != null ? n : T.create(!0);
    return Ui(e) && Ui(s) && r.isArray() ? this._handleArrayColIndexNum(e, t, r, s) : this._handleNonArrayColIndexNum(e, t, r, s);
  }
  _handleArrayColIndexNum(e, t, r, n) {
    const s = e.isArray() ? e.getFirstCell() : e, o = this.getZeroOrOneByOneDefault(n);
    if (o == null)
      return g.create(h.VALUE);
    let u;
    const c = [];
    return r.iterator((l, f, m) => {
      if (l == null)
        return u = g.create(h.VALUE), !1;
      const d = this._handleTableArray(s, t, l, o);
      if (d.isError())
        return u = d, !1;
      c[f] === void 0 && (c[f] = []), c[f][m] = d;
    }), u || mt(c, c.length, c[0].length, this.unitId || "", this.subUnitId || "");
  }
  _handleNonArrayColIndexNum(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e), c = O(s, o, n);
    return u.map((l, f, m) => {
      if (l.isError())
        return l;
      const d = c.get(f, m);
      if (d == null)
        return g.create(h.VALUE);
      if (d.isError())
        return d;
      const _ = this.getZeroOrOneByOneDefault(d);
      return _ == null ? g.create(h.VALUE) : this._handleTableArray(l, t, r, _);
    });
  }
  _handleTableArray(e, t, r, n) {
    let s = this.getIndexNumValue(r);
    if (s instanceof g)
      return s;
    if (s = Math.floor(s), s < 1)
      return g.create(h.VALUE);
    const o = t.slice(void 0, [0, 1]);
    if (o == null)
      return g.create(h.VALUE);
    const u = t.slice(void 0, [s - 1, s]);
    return u == null ? g.create(h.REF) : this._handleSingleObject(e, o, u, n);
  }
  _handleSingleObject(e, t, r, n) {
    return n === 0 ? this.equalSearch(e, t, r) : this.binarySearch(e, t, r);
  }
}
class WC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = Math.max(
      ...e.map((n) => n.isArray() ? n.getColumnCount() : 1)
    ), r = [];
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      if (s.isError())
        return s;
      const o = s.isArray() ? s.getRowCount() : 1, u = s.isArray() ? s.getColumnCount() : 1;
      for (let c = 0; c < o; c++) {
        const l = [];
        for (let f = 0; f < t; f++) {
          let m = s;
          s.isArray() && (m = s.get(c, f)), f > u - 1 || !m ? l.push(g.create(h.NA)) : l.push(m);
        }
        r.push(l);
      }
    }
    return K.create({
      calculateValueList: r,
      rowCount: r.length,
      columnCount: r[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
}
class QC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    let n = r != null ? r : g.create(h.NA);
    n.isNull() && (n = g.create(h.NA));
    const s = e.isArray() ? e.getRowCount() : 1, o = e.isArray() ? e.getColumnCount() : 1, u = Math.max(
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), c = Math.max(
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), l = O(u, c, t, g.create(h.NA)), f = O(u, c, n, g.create(h.NA)), m = l.mapValue((d, _, C) => {
      const E = f.get(_, C);
      if (e.isError())
        return e;
      if (e.isNull())
        return g.create(h.VALUE);
      if (d.isError())
        return d;
      const R = Math.trunc(+d.getValue());
      if (s > 1 && o > 1 || Number.isNaN(R))
        return g.create(h.VALUE);
      if (R < 1)
        return g.create(h.NUM);
      const b = e.isArray() ? e.getArrayValue().flat() : [e], p = this._getWrapArray(b, R, E);
      return u > 1 || c > 1 || p.length === 1 && p[0].length === 1 ? p[0][0] : K.create({
        calculateValueList: p,
        rowCount: p.length,
        columnCount: p[0].length,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      });
    });
    return u === 1 && c === 1 ? m.get(0, 0) : m;
  }
  _getWrapArray(e, t, r) {
    const n = Math.ceil(e.length / t), s = n > 1 ? t : e.length, o = [];
    for (let u = 0; u < n; u++)
      for (let c = 0; c < s; c++) {
        o[c] || (o[c] = []);
        const l = u * s + c;
        l < e.length ? o[c].push(e[l].isNull() ? y.create(0) : e[l]) : o[c].push(r);
      }
    return o;
  }
}
class qC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    let n = r != null ? r : g.create(h.NA);
    n.isNull() && (n = g.create(h.NA));
    const s = e.isArray() ? e.getRowCount() : 1, o = e.isArray() ? e.getColumnCount() : 1, u = Math.max(
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), c = Math.max(
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), l = O(u, c, t, g.create(h.NA)), f = O(u, c, n, g.create(h.NA)), m = l.mapValue((d, _, C) => {
      const E = f.get(_, C);
      if (e.isError())
        return e;
      if (e.isNull())
        return g.create(h.VALUE);
      if (d.isError())
        return d;
      const R = Math.trunc(+d.getValue());
      if (s > 1 && o > 1 || Number.isNaN(R))
        return g.create(h.VALUE);
      if (R < 1)
        return g.create(h.NUM);
      const b = e.isArray() ? e.getArrayValue().flat() : [e], p = this._getWrapArray(b, R, E);
      return u > 1 || c > 1 || p.length === 1 && p[0].length === 1 ? p[0][0] : K.create({
        calculateValueList: p,
        rowCount: p.length,
        columnCount: p[0].length,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      });
    });
    return u === 1 && c === 1 ? m.get(0, 0) : m;
  }
  _getWrapArray(e, t, r) {
    const n = Math.ceil(e.length / t), s = n > 1 ? t : e.length, o = [];
    for (let u = 0; u < n; u++) {
      const c = [];
      for (let l = 0; l < s; l++) {
        const f = u * s + l;
        f < e.length ? c.push(e[f].isNull() ? y.create(0) : e[f]) : c.push(r);
      }
      o.push(c);
    }
    return o;
  }
}
class XC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 6);
  }
  // eslint-disable-next-line
  calculate(e, t, r, n, s, o) {
    let u = n != null ? n : g.create(h.NA);
    n != null && n.isNull() && (u = g.create(h.NA));
    let c = s != null ? s : y.create(0);
    s != null && s.isNull() && (c = y.create(0));
    let l = o != null ? o : y.create(1);
    if (o != null && o.isNull() && (l = y.create(1)), e.isError())
      return e;
    const f = t.isArray() ? t.getRowCount() : 1, m = t.isArray() ? t.getColumnCount() : 1, d = r.isArray() ? r.getRowCount() : 1, _ = r.isArray() ? r.getColumnCount() : 1;
    if (f !== 1 && m !== 1 || f === 1 && m > 1 && m !== _ || m === 1 && f > 1 && f !== d)
      return g.create(h.VALUE);
    if (c.isError())
      return c;
    if (l.isError())
      return l;
    const C = this.getIndexNumValue(c);
    if (C instanceof g)
      return C;
    const E = this.getIndexNumValue(l);
    return E instanceof g ? E : this._getResult(
      e,
      ea(t),
      ea(r),
      u,
      C,
      E,
      f,
      m,
      d,
      _
    );
  }
  _getResult(e, t, r, n, s, o, u, c, l, f) {
    const m = e.isArray() ? e.getRowCount() : 1, d = e.isArray() ? e.getColumnCount() : 1;
    if (m > 1 || d > 1) {
      let R;
      return u === 1 ? R = r.slice([0, 1]) : R = r.slice(void 0, [0, 1]), R == null ? g.create(h.NA) : e.map((b) => {
        const p = this._checkErrorCombination(s, o);
        if (p)
          return p;
        const V = this._handleSingleObject(b, t, R, s, o);
        return V.isError() ? n : V;
      });
    }
    const _ = e.isArray() ? e.get(0, 0) : e;
    if (c === f && u === l) {
      const R = this._checkErrorCombination(s, o);
      if (R)
        return R;
      const b = this._handleSingleObject(_, t, r, s, o);
      return b.isError() ? n : b;
    }
    let C = 0;
    c === f && (C = 1);
    const E = this._handleExpandObject(_, t, r, s, o, C);
    return E == null ? g.create(h.NA) : E;
  }
  _handleExpandObject(e, t, r, n, s, o = 0) {
    if ((s === 2 || s === -2) && n !== 2) {
      const u = Ws(s), c = Gs(n);
      return this.binarySearchExpand(
        e,
        t,
        r,
        o,
        u,
        c
      );
    }
    return n === 2 ? this.fuzzySearchExpand(e, t, r, s !== -1, o) : n === -1 || n === 1 ? this.orderSearchExpand(
      e,
      t,
      r,
      n === 1 ? xe.MAX : xe.MIN,
      s === -1,
      o
    ) : this.equalSearchExpand(e, t, r, s !== -1, o);
  }
  _handleSingleObject(e, t, r, n, s) {
    if ((s === 2 || s === -2) && n !== 2) {
      const o = Ws(s), u = Gs(n);
      return this.binarySearch(e, t, r, o, u);
    }
    return n === 2 ? this.fuzzySearch(e, t, r, s !== -1) : n === -1 || n === 1 ? this.orderSearch(
      e,
      t,
      r,
      n === 1 ? xe.MAX : xe.MIN,
      s === -1
    ) : this.equalSearch(e, t, r, s !== -1);
  }
  /**
   * Wildcard matching and binary search cannot appear at the same time
   * @param matchModeValue
   * @param searchModeValue
   * @returns
   */
  _checkErrorCombination(e, t) {
    return e === 2 && (t === -2 || t === 2) ? g.create(h.VALUE) : null;
  }
}
class KC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    let s = y.create(0);
    r && !r.isNull() && (s = r);
    let o = y.create(1);
    n && !n.isNull() && (o = n);
    const u = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1
    ), c = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1
    ), l = O(u, c, e, g.create(h.NA)), f = O(u, c, s, g.create(h.NA)), m = O(u, c, o, g.create(h.NA)), d = l.mapValue((_, C, E) => {
      if (_.isError())
        return _;
      const R = f.get(C, E), b = m.get(C, E);
      return R.isError() ? R : b.isError() ? b : this._handleSingleObject(_, t, R, b);
    });
    return u === 1 && c === 1 ? d.get(0, 0) : d;
  }
  _handleSingleObject(e, t, r, n) {
    const s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    if (s !== 1 && o !== 1)
      return g.create(h.VALUE);
    let u = r;
    if ((r.isString() || r.isBoolean() || r.isNull()) && (u = r.convertToNumberObjectValue()), u.isError())
      return u;
    let c = n;
    if ((n.isString() || n.isBoolean() || n.isNull()) && (c = n.convertToNumberObjectValue()), c.isError())
      return c;
    const l = u.getValue(), f = c.getValue();
    return ![-1, 0, 1, 2].includes(l) || ![-1, 1, 2].includes(f) ? g.create(h.VALUE) : this._getResult(e, t, l, f);
  }
  _getResult(e, t, r, n) {
    const s = ea(t);
    let o;
    if ((n === 2 || n === -2) && r !== 2) {
      const u = Ws(n), c = Gs(r);
      o = s.binarySearch(e, u, c);
    } else if (r === 2) {
      const u = s.compare(e, Y.EQUALS);
      let c;
      if (n !== -1 ? c = u.getFirstTruePosition() : c = u.getLastTruePosition(), c == null)
        return g.create(h.NA);
      o = s.getRowCount() === 1 ? c.column : c.row;
    } else if (r === -1 || r === 1) {
      const u = s.orderSearch(e, r === 1 ? xe.MAX : xe.MIN, n === -1);
      if (u == null)
        return g.create(h.NA);
      if (u instanceof g)
        return u;
      o = s.getRowCount() === 1 ? u.column : u.row;
    } else {
      const u = s.isEqual(e);
      let c;
      if (n !== -1 ? c = u.getFirstTruePosition() : c = u.getLastTruePosition(), c == null)
        return g.create(h.NA);
      o = s.getRowCount() === 1 ? c.column : c.row;
    }
    return o == null ? g.create(h.NA) : y.create(o + 1);
  }
}
const ZC = [
  [gC, re.ADDRESS],
  [CC, re.AREAS],
  [_C, re.CHOOSE],
  [AC, re.CHOOSECOLS],
  [EC, re.CHOOSEROWS],
  [RC, re.COLUMN],
  [bC, re.COLUMNS],
  [yC, re.DROP],
  [pC, re.EXPAND],
  [NC, re.FILTER],
  [VC, re.FORMULATEXT],
  [OC, re.HLOOKUP],
  [SC, re.HSTACK],
  [MC, re.HYPERLINK],
  [DC, re.IMAGE],
  [wC, re.INDEX],
  [LC, re.INDIRECT],
  [PC, re.LOOKUP],
  [xC, re.MATCH],
  [UC, re.OFFSET],
  [vC, re.ROW],
  [TC, re.ROWS],
  [IC, re.SORT],
  [BC, re.SORTBY],
  [FC, re.TAKE],
  [kC, re.TOCOL],
  [$C, re.TOROW],
  [YC, re.TRANSPOSE],
  [HC, re.UNIQUE],
  [GC, re.VLOOKUP],
  [WC, re.VSTACK],
  [QC, re.WRAPCOLS],
  [qC, re.WRAPROWS],
  [XC, re.XLOOKUP],
  [KC, re.XMATCH]
];
class zC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.abs();
  }
}
class JC extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.acos();
  }
}
class e_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.acosh();
  }
}
class t_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.isArray() ? t.map((r) => r.isError() ? r : Ki(r)) : Ki(t);
  }
}
function Ki(a) {
  let i = a.getValue();
  if (a.isBoolean() && (i = i ? 1 : 0), !Number.isFinite(i))
    return g.create(h.VALUE);
  i = Number(i);
  let e = Math.atan(1 / i);
  return i < 0 && (e += Math.PI), Number.isNaN(e) ? g.create(h.VALUE) : y.create(e);
}
class r_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.isArray() ? t.map((r) => r.isError() ? r : Zi(r)) : Zi(t);
  }
}
function Zi(a) {
  let i = a.getValue();
  if (a.isBoolean() && (i = i ? 1 : 0), !Number.isFinite(i))
    return g.create(h.VALUE);
  if (i = Number(i), Math.abs(i) <= 1)
    return g.create(h.NUM);
  const e = 1 / 2 * Math.log((i + 1) / (i - 1));
  return Number.isNaN(e) ? g.create(h.VALUE) : y.create(e);
}
const n_ = {
  1: Me.AVERAGE,
  2: Me.COUNT,
  3: Me.COUNTA,
  4: Me.MAX,
  5: Me.MIN,
  6: Me.PRODUCT,
  7: Me.STDEV_S,
  8: Me.STDEV_P,
  9: Me.SUM,
  10: Me.VAR_S,
  11: Me.VAR_P,
  12: Me.MEDIAN,
  13: Me.MODE_SNGL
};
class s_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", !0);
    A(this, "needsFilteredOutRows", !0);
    A(this, "needsFormulaDataModel", !0);
  }
  calculate(e, t, ...r) {
    const { isError: n, multiAreaRefs: s, normalRefs: o } = du(r);
    let u;
    e.isReferenceObject() ? u = e.toArrayValueObject() : u = e;
    let c;
    t.isReferenceObject() ? c = t.toArrayValueObject() : c = t;
    const l = Math.max(
      u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f = Math.max(
      u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), m = O(l, f, u, g.create(h.NA)), d = O(l, f, c, g.create(h.NA)), _ = m.mapValue((C, E, R) => {
      if (C.isError())
        return C;
      const b = d.get(E, R);
      return b.isError() ? b : s.length > 0 ? g.create(h.VALUE) : this._handleSingleObject(C, b, r, n, o);
    });
    return _.getRowCount() === 1 && _.getColumnCount() === 1 ? _.get(0, 0) : _;
  }
  _handleSingleObject(e, t, r, n, s) {
    let o = e;
    if (e.isString() && (o = e.convertToNumberObjectValue()), o.isError())
      return o;
    const u = Math.floor(+o.getValue());
    if (u < 1 || u > 19 || u >= 1 && u <= 13 && n || u >= 14 && u <= 19 && r.length !== 2)
      return g.create(h.VALUE);
    let c = t;
    if (t.isString() && (c = t.convertToNumberObjectValue()), c.isError())
      return c;
    const l = Math.floor(+c.getValue());
    if (l < 0 || l > 7)
      return g.create(h.VALUE);
    const f = this._getAggregateOptions(l);
    return u >= 14 && u <= 19 ? this._handleLargeSmallPercentileQuartile(
      u,
      f,
      r[0],
      r[1]
    ) : Eu({
      type: n_[u],
      ...f,
      formulaDataModel: this._formulaDataModel
    }, s);
  }
  _getAggregateOptions(e) {
    switch (e) {
      case 1:
        return {
          ignoreRowHidden: !0,
          ignoreErrorValues: !1,
          ignoreNested: !0
        };
      case 2:
        return {
          ignoreRowHidden: !1,
          ignoreErrorValues: !0,
          ignoreNested: !0
        };
      case 3:
        return {
          ignoreRowHidden: !0,
          ignoreErrorValues: !0,
          ignoreNested: !0
        };
      case 4:
        return {
          ignoreRowHidden: !1,
          ignoreErrorValues: !1,
          ignoreNested: !1
        };
      case 5:
        return {
          ignoreRowHidden: !0,
          ignoreErrorValues: !1,
          ignoreNested: !1
        };
      case 6:
        return {
          ignoreRowHidden: !1,
          ignoreErrorValues: !0,
          ignoreNested: !1
        };
      case 7:
        return {
          ignoreRowHidden: !0,
          ignoreErrorValues: !0,
          ignoreNested: !1
        };
      case 0:
      default:
        return {
          ignoreRowHidden: !1,
          ignoreErrorValues: !1,
          ignoreNested: !0
        };
    }
  }
  _handleLargeSmallPercentileQuartile(e, t, r, n) {
    let s;
    if (n.isReferenceObject() ? s = n.toArrayValueObject() : s = n, s.isError())
      return s;
    if (s.isArray()) {
      const c = s.getRowCount(), l = s.getColumnCount();
      if (c > 1 || l > 1)
        return g.create(h.VALUE);
      s = s.get(0, 0);
    }
    const o = mr(r, t, this._formulaDataModel);
    if (!Array.isArray(o))
      return o;
    const u = +s.getValue();
    switch (e) {
      case 14:
        return bu(o, u);
      case 15:
        return yu(o, u);
      case 16:
        return pu(o, u);
      case 17:
        return Vu(o, u);
      case 18:
        return Nu(o, u);
      case 19:
        return Ou(o, u);
      default:
        return g.create(h.VALUE);
    }
  }
}
class a_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  // eslint-disable-next-line
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isNull())
      return y.create(0);
    if (e.isBoolean() || e.isNumber())
      return g.create(h.VALUE);
    let t = e.getValue().toLocaleString().toLocaleUpperCase();
    if (t.length > 255)
      return g.create(h.VALUE);
    const r = t.startsWith("-");
    r && (t = t.slice(1));
    let n = 0;
    for (let s = 0; s < t.length; s++) {
      const o = fn.get(t[s]) || 0, u = fn.get(t[s + 1]) || 0, c = fn.get(t[s + 2]) || 0, l = fn.get(t[s + 3]) || 0;
      if (!o || c >= u && c > o || o === u && o === c && o === l || o === u / 2)
        return g.create(h.VALUE);
      o < u ? n -= o : n += o;
    }
    return y.create(r ? -n : n);
  }
}
class i_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.asin();
  }
}
class o_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.asinh();
  }
}
class u_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.atan();
  }
}
class c_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e, n = t;
    return r.isString() && (r = r.convertToNumberObjectValue()), r.isError() ? r : (n.isString() && (n = n.convertToNumberObjectValue()), n.isError() ? n : n.atan2(r));
  }
}
class l_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.atanh();
  }
}
class f_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : y.create(0);
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (n.isError())
      return n;
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(h.NA)), c = O(s, o, t, g.create(h.NA)), l = O(s, o, n, g.create(h.NA)), f = u.map((m, d, _) => {
      const C = c.get(d, _), E = l.get(d, _);
      return this._handleSingleObject(m, C, E);
    });
    return f.getRowCount() === 1 && f.getColumnCount() === 1 ? f.getArrayValue()[0][0] : f;
  }
  _handleSingleObject(e, t, r) {
    let n = e;
    if (n.isString() && (n = n.convertToNumberObjectValue()), n.isError())
      return n;
    let s = t;
    if (s.isString() && (s = s.convertToNumberObjectValue()), s.isError())
      return s;
    let o = r;
    if (o.isString() && (o = o.convertToNumberObjectValue()), o.isError())
      return o;
    const u = Math.floor(+n.getValue()), c = Math.floor(+s.getValue()), l = Math.floor(+o.getValue());
    if (u < 0 || u >= 2 ** 53 || c < 2 || c > 36 || l < 0)
      return g.create(h.NUM);
    let f = u.toString(c);
    return f.length < l && (f = new Array(l - f.length + 1).join("0") + f), U.create(f.toLocaleUpperCase());
  }
}
class m_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(h.NA)), o = O(r, n, t, g.create(h.NA)), u = s.map((c, l, f) => {
      let m = c, d = o.get(l, f);
      if (m.isString() && (m = m.convertToNumberObjectValue()), m.isError())
        return m;
      if (d.isString() && (d = d.convertToNumberObjectValue()), d.isError())
        return d;
      const _ = +m.getValue(), C = +d.getValue();
      if (_ > 0 && C < 0)
        return g.create(h.NUM);
      if (_ === 0 || C === 0)
        return y.create(0);
      const E = We(_ / C, 0) * C;
      return y.create(E);
    });
    return u.getRowCount() === 1 && u.getColumnCount() === 1 ? u.getArrayValue()[0][0] : u;
  }
}
class h_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = t != null ? t : y.create(1), s = r != null ? r : y.create(0);
    if (e.isError())
      return e;
    if (n.isError())
      return n;
    if (s.isError())
      return s;
    const o = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, e, g.create(h.NA)), l = O(o, u, n, g.create(h.NA)), f = O(o, u, s, g.create(h.NA)), m = c.map((d, _, C) => {
      let E = d, R = l.get(_, C), b = f.get(_, C);
      if (E.isString() && (E = E.convertToNumberObjectValue()), E.isError())
        return E;
      if (R.isString() && (R = R.convertToNumberObjectValue()), R.isError())
        return R;
      if (b.isString() && (b = b.convertToNumberObjectValue()), b.isError())
        return b;
      const p = +E.getValue(), V = +R.getValue(), S = +b.getValue();
      return p === 0 || V === 0 ? y.create(0) : this._getResult(p, V, S);
    });
    return o === 1 && u === 1 ? m.get(0, 0) : m;
  }
  _getResult(e, t, r) {
    let n;
    return e < 0 && r !== 0 ? n = (t < 0 ? We(Math.abs(e) / Math.abs(t), 0) : -We(Math.abs(e) / t, 0)) * t : n = (t < 0 ? -We(e / Math.abs(t), 0) : We(e / t, 0)) * t, y.create(n);
  }
}
class g_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(1);
    if (e.isError())
      return e;
    if (r.isError())
      return r;
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, r, g.create(h.NA)), c = o.map((l, f, m) => {
      let d = u.get(f, m), _ = l;
      if (_.isString() && (_ = _.convertToNumberObjectValue()), _.isError())
        return _;
      if (d.isString() && (d = d.convertToNumberObjectValue()), d.isError())
        return d;
      const C = +_.getValue(), E = +d.getValue();
      if (C === 0 || E === 0)
        return y.create(0);
      const R = (E < 0 ? -We(C / Math.abs(E), 0) : We(C / E, 0)) * E;
      return y.create(R);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
}
class d_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(h.NA)), o = O(r, n, t, g.create(h.NA)), u = s.mapValue((c, l, f) => {
      let m = c, d = o.get(l, f);
      if (m.isString() && (m = m.convertToNumberObjectValue()), d.isString() && (d = d.convertToNumberObjectValue()), m.isError())
        return m;
      if (d.isError())
        return d;
      const _ = Math.floor(+m.getValue()), C = Math.floor(+d.getValue());
      if (_ < 0 || C < 0 || _ < C)
        return g.create(h.NUM);
      const E = sr(_, C);
      return Number.isNaN(E) || !Number.isFinite(E) ? g.create(h.NUM) : y.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
}
class C_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(h.NA)), o = O(r, n, t, g.create(h.NA)), u = s.mapValue((c, l, f) => {
      let m = c, d = o.get(l, f);
      if (m.isString() && (m = m.convertToNumberObjectValue()), d.isString() && (d = d.convertToNumberObjectValue()), m.isError())
        return m;
      if (d.isError())
        return d;
      const _ = Math.floor(+m.getValue()), C = Math.floor(+d.getValue());
      if (_ < 0 || C < 0 || _ === 0 && _ < C)
        return g.create(h.NUM);
      const E = sr(_ + C - 1, _ - 1);
      return Number.isNaN(E) || !Number.isFinite(E) ? g.create(h.NUM) : y.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
}
class __ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.cos();
  }
}
class A_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.cosh();
  }
}
class E_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    return Math.abs(r) >= 2 ** 27 ? g.create(h.NUM) : r === 0 ? g.create(h.DIV_BY_ZERO) : t.tan().getReciprocal();
  }
}
class R_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : +t.getValue() === 0 ? g.create(h.DIV_BY_ZERO) : t.tanh().getReciprocal();
  }
}
class b_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    return Math.abs(r) >= 2 ** 27 ? g.create(h.NUM) : r === 0 ? g.create(h.DIV_BY_ZERO) : t.sin().getReciprocal();
  }
}
class y_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    return r === 0 ? g.create(h.DIV_BY_ZERO) : !Number.isNaN(r) && !Number.isFinite(Math.sinh(r)) ? y.create(0) : t.sinh().getReciprocal();
  }
}
class p_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(h.NA)), o = O(r, n, t, g.create(h.NA)), u = s.map((c, l, f) => {
      if (c.isError())
        return c;
      let m = o.get(l, f);
      if (m.isString() && (m = m.convertToNumberObjectValue()), m.isError())
        return m;
      const d = `${c.getValue()}`, _ = Math.floor(+m.getValue());
      if (q(d) && (+d < 0 || +d >= 2 ** 53 || !Number.isInteger(+d)) || d.toLocaleLowerCase() === "true" || d.toLocaleLowerCase() === "false" || _ < 2 || _ > 36)
        return g.create(h.NUM);
      if (d.replace(/\s/g, "") === "")
        return y.create(0);
      if (!this._isValidCharForRadix(d, _))
        return g.create(h.NUM);
      const C = Number.parseInt(d, _);
      return Number.isNaN(C) ? g.create(h.NUM) : y.create(C);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _isValidCharForRadix(e, t) {
    for (const r of e) {
      const n = r.toUpperCase().charCodeAt(0);
      if (t <= 10 && !(n >= 48 && n < 48 + t) || t > 10 && !(n >= 48 && n < 58 || n >= 65 && n < 65 + t - 10))
        return !1;
    }
    return !0;
  }
}
class N_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    if (!Number.isFinite(r))
      return g.create(h.VALUE);
    const n = r * (180 / Math.PI);
    return Number.isNaN(n) ? g.create(h.VALUE) : y.create(n);
  }
}
class V_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    if (!Number.isFinite(r))
      return g.create(h.VALUE);
    const n = (r < 0 ? -We(Math.abs(r) / 2, 0) : We(r / 2, 0)) * 2;
    return Number.isNaN(n) ? g.create(h.VALUE) : n === 0 ? y.create(0) : y.create(n);
  }
}
class O_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.exp();
  }
}
class S_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.mapValue((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = Math.floor(+t.getValue()), n = Ar(r);
    return Number.isNaN(n) || !Number.isFinite(n) ? g.create(h.NUM) : y.create(n);
  }
}
class M_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    if (e.isArray()) {
      const r = e.getRowCount(), n = e.getColumnCount();
      if (r > 1 || n > 1)
        return g.create(h.VALUE);
      t = e.get(0, 0);
    }
    return this._handleSingleObject(t);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = Math.floor(+t.getValue()), n = Ar(r, 2);
    return Number.isNaN(n) || !Number.isFinite(n) ? g.create(h.NUM) : y.create(n);
  }
}
class D_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(h.NA)), o = O(r, n, t, g.create(h.NA)), u = s.map((c, l, f) => {
      let m = o.get(l, f), d = c;
      if (d.isString() && (d = d.convertToNumberObjectValue()), d.isError())
        return d;
      if (m.isString() && (m = m.convertToNumberObjectValue()), m.isError())
        return m;
      const _ = +d.getValue(), C = +m.getValue();
      if (_ > 0 && C < 0)
        return g.create(h.NUM);
      if (_ === 0)
        return y.create(0);
      if (C === 0)
        return g.create(h.DIV_BY_ZERO);
      const E = Ze(_ / C, 0) * C;
      return y.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
}
class w_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = t != null ? t : y.create(1), s = r != null ? r : y.create(0), o = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, e, g.create(h.NA)), l = O(o, u, n, g.create(h.NA)), f = O(o, u, s, g.create(h.NA)), m = c.map((d, _, C) => {
      let E = d, R = l.get(_, C), b = f.get(_, C);
      if (E.isString() && (E = E.convertToNumberObjectValue()), E.isError())
        return E;
      if (R.isString() && (R = R.convertToNumberObjectValue()), R.isError())
        return R;
      if (b.isString() && (b = b.convertToNumberObjectValue()), b.isError())
        return b;
      const p = +E.getValue(), V = +R.getValue(), S = +b.getValue();
      if (p === 0 || V === 0)
        return y.create(0);
      let M;
      return p < 0 && S !== 0 ? M = (V < 0 ? Ze(Math.abs(p) / Math.abs(V), 0) : -Ze(Math.abs(p) / V, 0)) * V : M = (V < 0 ? -Ze(p / Math.abs(V), 0) : Ze(p / V, 0)) * V, y.create(M);
    });
    return o === 1 && u === 1 ? m.get(0, 0) : m;
  }
}
class L_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(1);
    if (e.isError())
      return e;
    if (r.isError())
      return r;
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, r, g.create(h.NA)), c = o.map((l, f, m) => {
      let d = u.get(f, m), _ = l;
      if (_.isString() && (_ = _.convertToNumberObjectValue()), _.isError())
        return _;
      if (d.isString() && (d = d.convertToNumberObjectValue()), d.isError())
        return d;
      const C = +_.getValue(), E = +d.getValue();
      if (C === 0 || E === 0)
        return y.create(0);
      const R = (E < 0 ? -Ze(C / Math.abs(E), 0) : Ze(C / E, 0)) * E;
      return y.create(R);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
}
class P_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = 0;
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      if (!n.isNull())
        if (n.isArray()) {
          let s = !1, o = g.create(h.VALUE);
          if (n.iterator((u) => {
            if (u != null && u.isNull())
              return !0;
            const { isError: c, errorObject: l, number: f } = this._handleSingleObject(u);
            if (c)
              return s = !0, o = l, !1;
            t = la(t, f);
          }), s)
            return o;
        } else {
          const { isError: s, errorObject: o, number: u } = this._handleSingleObject(n);
          if (s)
            return o;
          t = la(t, u);
        }
    }
    return y.create(t);
  }
  _handleSingleObject(e) {
    if (e.isBoolean())
      return {
        isError: !0,
        errorObject: g.create(h.VALUE),
        number: null
      };
    let t = e;
    if (e.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return {
        isError: !0,
        errorObject: t,
        number: null
      };
    const r = Math.floor(+t.getValue());
    return r < 0 || r >= 2 ** 53 ? {
      isError: !0,
      errorObject: g.create(h.NUM),
      number: null
    } : {
      isError: !1,
      errorObject: null,
      number: r
    };
  }
}
class x_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.mapValue((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = Math.floor(+t.getValue());
    return y.create(r);
  }
}
class j_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = 1, r = !0;
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      if (!s.isNull())
        if (s.isArray()) {
          let o = !1, u = g.create(h.VALUE);
          if (s.iterator((c) => {
            if (c != null && c.isNull())
              return !0;
            const { isError: l, errorObject: f, number: m } = this._handleSingleObject(c);
            if (l)
              return o = !0, u = f, !1;
            t = Qi(t, m), r = !1;
          }), o)
            return u;
        } else {
          const { isError: o, errorObject: u, number: c } = this._handleSingleObject(s);
          if (o)
            return u;
          t = Qi(t, c), r = !1;
        }
    }
    return r ? y.create(0) : Number.isNaN(t) || !Number.isFinite(t) || t >= 2 ** 53 ? g.create(h.VALUE) : y.create(t);
  }
  _handleSingleObject(e) {
    if (e.isBoolean())
      return {
        isError: !0,
        errorObject: g.create(h.VALUE),
        number: null
      };
    let t = e;
    if (e.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return {
        isError: !0,
        errorObject: t,
        number: null
      };
    const r = Math.floor(+t.getValue());
    return r < 0 ? {
      isError: !0,
      errorObject: g.create(h.NUM),
      number: null
    } : {
      isError: !1,
      errorObject: null,
      number: r
    };
  }
}
class U_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.log();
  }
}
class v_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(10);
    if (e.isError())
      return e;
    if (r.isError())
      return r;
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, r, g.create(h.NA)), c = o.map((l, f, m) => {
      let d = u.get(f, m), _ = l;
      if (_.isString() && (_ = _.convertToNumberObjectValue()), _.isError())
        return _;
      if (d.isString() && (d = d.convertToNumberObjectValue()), d.isError())
        return d;
      const C = +_.getValue(), E = +d.getValue();
      if (C <= 0 || E <= 0)
        return g.create(h.NUM);
      const R = Math.log(E);
      if (R === 0)
        return g.create(h.DIV_BY_ZERO);
      const b = Math.log(C) / R;
      return y.create(b);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
}
class T_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.log10();
  }
}
class I_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const t = e.isArray() ? e.getRowCount() : 1, r = e.isArray() ? e.getColumnCount() : 1, n = [];
    for (let o = 0; o < t; o++) {
      const u = [];
      for (let c = 0; c < r; c++) {
        let l = e.isArray() ? e.get(o, c) : e;
        if (l.isError())
          return l;
        if (l.isNull() || l.isBoolean())
          return g.create(h.VALUE);
        if (l.isString() && (l = l.convertToNumberObjectValue()), l.isError())
          return l;
        const f = +l.getValue();
        u.push(f);
      }
      n.push(u);
    }
    if (t !== r)
      return g.create(h.VALUE);
    const s = Ba(n);
    return y.create(s);
  }
}
class B_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    const t = e.isArray() ? e.getRowCount() : 1, r = e.isArray() ? e.getColumnCount() : 1, n = [];
    for (let o = 0; o < t; o++) {
      const u = [];
      for (let c = 0; c < r; c++) {
        let l = e.isArray() ? e.get(o, c) : e;
        if (l.isError())
          return l;
        if (l.isNull() || l.isBoolean())
          return g.create(h.VALUE);
        if (l.isString() && (l = l.convertToNumberObjectValue()), l.isError())
          return l;
        const f = +l.getValue();
        u.push(f);
      }
      n.push(u);
    }
    if (t !== r)
      return g.create(h.VALUE);
    const s = vh(n);
    return s === null ? g.create(h.NUM) : K.createByArray(s);
  }
}
class F_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    if (n !== s)
      return g.create(h.VALUE);
    const u = this._getMatrix(e, r, n), c = this._getMatrix(t, s, o);
    if (u instanceof g)
      return u;
    if (c instanceof g)
      return c;
    const l = Er(u, c);
    return K.createByArray(l);
  }
  _getMatrix(e, t, r) {
    const n = [];
    for (let s = 0; s < t; s++) {
      const o = [];
      for (let u = 0; u < r; u++) {
        let c = e.isArray() ? e.get(s, u) : e;
        if (c.isError())
          return c;
        if (c.isNull() || c.isBoolean())
          return g.create(h.VALUE);
        if (c.isString() && (c = c.convertToNumberObjectValue()), c.isError())
          return c;
        const l = +c.getValue();
        o.push(l);
      }
      n.push(o);
    }
    return n;
  }
}
class k_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (r.isString() && (r = r.convertToNumberObjectValue()), r.isError())
      return r;
    let n = t;
    return n.isString() && (n = n.convertToNumberObjectValue()), n.isError() ? n : r.mod(n);
  }
}
class $_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (r.isArray()) {
      const c = r.getRowCount(), l = r.getColumnCount();
      if (c > 1 || l > 1)
        return g.create(h.VALUE);
      r = r.get(0, 0);
    }
    if (r.isError())
      return r;
    let n = t;
    if (n.isArray()) {
      const c = n.getRowCount(), l = n.getColumnCount();
      if (c > 1 || l > 1)
        return g.create(h.VALUE);
      n = n.get(0, 0);
    }
    if (n.isError())
      return n;
    if (r.isBoolean() || n.isBoolean())
      return g.create(h.VALUE);
    const s = +r.getValue(), o = +n.getValue();
    if (Number.isNaN(s) || Number.isNaN(o))
      return g.create(h.VALUE);
    if (o === 0)
      return y.create(0);
    if (s > 0 && o < 0 || s < 0 && o > 0)
      return g.create(h.NUM);
    const u = kt(s / o, 0) * o;
    return y.create(u);
  }
}
class Y_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = 0, r = 1;
    for (let s = 0; s < e.length; s++) {
      const o = e[s];
      if (!o.isNull())
        if (o.isArray()) {
          let u = !1, c = g.create(h.VALUE);
          if (o.iterator((l) => {
            if (l != null && l.isNull())
              return !0;
            const { isError: f, errorObject: m, number: d } = this._handleSingleObject(l);
            if (f)
              return u = !0, c = m, !1;
            if (t += d, t > 170)
              return u = !0, c = g.create(h.NUM), !1;
            r *= Ar(d);
          }), u)
            return c;
        } else {
          const { isError: u, errorObject: c, number: l } = this._handleSingleObject(o);
          if (u)
            return c;
          if (t += l, t > 170)
            return g.create(h.NUM);
          r *= Ar(l);
        }
    }
    const n = Ar(t) / r;
    return y.create(n);
  }
  _handleSingleObject(e) {
    if (e.isBoolean())
      return {
        isError: !0,
        errorObject: g.create(h.VALUE),
        number: null
      };
    let t = e;
    if (e.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return {
        isError: !0,
        errorObject: t,
        number: null
      };
    const r = Math.floor(+t.getValue());
    return r < 0 ? {
      isError: !0,
      errorObject: g.create(h.NUM),
      number: null
    } : {
      isError: !1,
      errorObject: null,
      number: r
    };
  }
}
class H_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.getRowCount(), r = e.getColumnCount(), n = e.mapValue((s) => {
        const o = this._handleSingleObject(s);
        return o.isError() ? o : t > 1 || r > 1 ? o.get(0, 0) : o;
      });
      return t === 1 && r === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = Math.floor(+t.getValue());
    if (r <= 0)
      return g.create(h.VALUE);
    const n = [];
    for (let s = 0; s < r; s++) {
      n[s] = [];
      for (let o = 0; o < r; o++)
        n[s][o] = s === o ? 1 : 0;
    }
    return K.createByArray(n);
  }
}
class G_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    if (!Number.isFinite(r))
      return g.create(h.VALUE);
    let n = r < 0 ? -We(Math.abs(r), 0) : We(r, 0);
    return Number.isNaN(n) ? g.create(h.VALUE) : (Math.abs(n) % 2 === 0 && (r < 0 ? n-- : n++), y.create(n));
  }
}
class W_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 0);
  }
  calculate() {
    return y.create(Math.PI);
  }
}
class Q_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (r.isString() && (r = r.convertToNumberObjectValue()), r.isError())
      return r;
    let n = t;
    return n.isString() && (n = n.convertToNumberObjectValue()), n.isError() ? n : r.pow(n);
  }
}
class q_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y.create(1), r = !0;
    for (let n = 0; n < e.length; n++) {
      let s = e[n];
      if (s.isError())
        return s;
      if (s.isArray()) {
        let o = !1, u = null;
        if (s.iterator((c) => {
          if (c != null && c.isError())
            return o = !0, u = c, !1;
          if (!c || c.isNull() || c.isString() || c.isBoolean())
            return !0;
          t = t.multiply(c), r = !1;
        }), o)
          return u;
      } else {
        if (s.isNull())
          continue;
        if (s.isString() && (s = s.convertToNumberObjectValue()), s.isError())
          return s;
        t = t.multiply(s), r = !1;
      }
      if (t.isError())
        return t;
    }
    return r ? y.create(0) : t;
  }
}
class X_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = W(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = +u.getValue();
    if (Number.isNaN(c) || Number.isNaN(l))
      return g.create(h.VALUE);
    if (l === 0)
      return g.create(h.DIV_BY_ZERO);
    const f = Math.trunc(c / l);
    return y.create(f);
  }
}
class K_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    if (!Number.isFinite(r))
      return g.create(h.VALUE);
    const n = r * (Math.PI / 180);
    return Number.isNaN(n) ? g.create(h.VALUE) : y.create(n);
  }
}
class Z_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 0);
  }
  calculate() {
    return y.create(Math.random());
  }
}
class z_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 0);
    A(this, "maxParams", 5);
    A(this, "needsSheetRowColumnCount", !0);
  }
  calculate(e, t, r, n, s) {
    if (e != null && e.isError())
      return e;
    if (t != null && t.isError())
      return t;
    if (r != null && r.isError())
      return r;
    if (n != null && n.isError())
      return n;
    if (s != null && s.isError())
      return s;
    const o = e != null ? e : y.create(1), u = t != null ? t : y.create(1), c = r != null ? r : y.create(0), l = n != null ? n : y.create(1), f = s != null ? s : y.create(0);
    return this._calculateResult(o, u, c, l, f);
  }
  _calculateResult(e, t, r, n, s) {
    const o = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    );
    if (o === 1 && u === 1)
      return this._calculateSingleCell(e, t, r, n, s);
    const c = O(o, u, e, g.create(h.NA)), l = O(o, u, t, g.create(h.NA)), f = O(o, u, r, g.create(h.NA)), m = O(o, u, n, g.create(h.NA)), d = O(o, u, s, g.create(h.NA));
    return c.map((_, C, E) => {
      const R = l.get(C, E), b = f.get(C, E), p = m.get(C, E), V = d.get(C, E), S = this._handleError(_, R, b, p, V);
      if (S.errorObject)
        return S.errorObject;
      let { minValue: M, maxValue: D, wholeNumberValue: w } = S, L;
      return w ? (M = Math.ceil(M), D = Math.floor(D), L = Math.floor(Math.random() * (D - M + 1)) + M) : L = Math.random() * (D - M) + M, L < M || L > D ? g.create(h.VALUE) : y.create(L);
    });
  }
  _calculateSingleCell(e, t, r, n, s) {
    let o = e;
    o.isArray() && (o = o.get(0, 0));
    let u = t;
    u.isArray() && (u = u.get(0, 0));
    let c = r;
    c.isArray() && (c = c.get(0, 0));
    let l = n;
    l.isArray() && (l = l.get(0, 0));
    let f = s;
    f.isArray() && (f = f.get(0, 0));
    const m = this._handleError(o, u, c, l, f);
    if (m.errorObject)
      return m.errorObject;
    let { rowsValue: d, columnsValue: _, minValue: C, maxValue: E, wholeNumberValue: R } = m;
    if (R && (C = Math.ceil(C), E = Math.floor(E), C > E))
      return g.create(h.VALUE);
    const b = [];
    for (let p = 0; p < d; p++) {
      const V = [];
      for (let S = 0; S < _; S++)
        R ? V.push(Math.floor(Math.random() * (E - C + 1)) + C) : V.push(Math.random() * (E - C) + C);
      b.push(V);
    }
    return d === 1 && _ === 1 ? y.create(b[0][0]) : K.createByArray(b);
  }
  _handleError(e, t, r, n, s) {
    let o = e;
    if (o.isString() && (o = o.convertToNumberObjectValue()), o.isError())
      return {
        errorObject: o
      };
    let u = t;
    if (u.isString() && (u = u.convertToNumberObjectValue()), u.isError())
      return {
        errorObject: u
      };
    let c = r;
    if (c.isString() && (c = c.convertToNumberObjectValue()), c.isError())
      return {
        errorObject: c
      };
    let l = n;
    if (l.isString() && (l = l.convertToNumberObjectValue()), l.isError())
      return {
        errorObject: l
      };
    let f = s;
    return f.isString() && (f = f.convertToNumberObjectValue()), f.isError() ? {
      errorObject: f
    } : this._getValue(o, u, c, l, f);
  }
  _getValue(e, t, r, n, s) {
    const o = Math.floor(+e.getValue()), u = Math.floor(+t.getValue());
    if (o === 0 || u === 0)
      return {
        errorObject: g.create(h.CALC)
      };
    const c = this._rowCount - this.row, l = this._columnCount - this.column;
    if (o < 0 || u < 0 || o * u > 10 ** 7)
      return {
        errorObject: g.create(h.VALUE)
      };
    if (o > c || u > l)
      return {
        errorObject: g.create(h.REF)
      };
    const f = +r.getValue(), m = +n.getValue(), d = +s.getValue();
    return f > m ? {
      errorObject: g.create(h.VALUE)
    } : d && (!Number.isInteger(f) || !Number.isInteger(m)) ? {
      errorObject: g.create(h.VALUE)
    } : {
      rowsValue: o,
      columnsValue: u,
      minValue: f,
      maxValue: m,
      wholeNumberValue: d
    };
  }
}
class J_ extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (r.isArray()) {
      const c = r.getRowCount(), l = r.getColumnCount();
      if (c > 1 || l > 1)
        return g.create(h.VALUE);
      r = r.get(0, 0);
    }
    if (r.isError())
      return r;
    let n = t;
    if (n.isArray()) {
      const c = n.getRowCount(), l = n.getColumnCount();
      if (c > 1 || l > 1)
        return g.create(h.VALUE);
      n = n.get(0, 0);
    }
    if (n.isError())
      return n;
    if (r.isBoolean() || n.isBoolean())
      return g.create(h.VALUE);
    let s = +r.getValue(), o = +n.getValue();
    if (Number.isNaN(s) || Number.isNaN(o))
      return g.create(h.VALUE);
    if (s > o)
      return g.create(h.NUM);
    s = Math.ceil(s), o = Math.floor(o);
    const u = Math.floor(Math.random() * (o - s + 1)) + s;
    return y.create(u);
  }
}
class eA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(0), n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, r, g.create(h.NA)), c = o.mapValue((l, f, m) => {
      const d = u.get(f, m);
      return l.isError() ? l : d.isError() ? d : this._handleSingleObject(l, d);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = I(e);
    if (r)
      return n;
    const [o] = s;
    let u = Math.floor(+o.getValue()), c = t;
    if (c.isString() && (c = c.convertToNumberObjectValue(), c.isError()))
      return c;
    let l = Math.floor(+c.getValue());
    if (c.isBoolean() && (l = c.getValue() ? 0 : 4), u < 0 || u > 3999 || l < 0 || l > 4)
      return g.create(h.VALUE);
    const f = Hh[l];
    let m = f.length - 1, d = "";
    for (; u > 0; ) {
      m = this._binarySearch(u, 0, m, f);
      const _ = f[m];
      u -= _, d += Yh.get(_);
    }
    return U.create(d);
  }
  _binarySearch(e, t, r, n) {
    let s = t, o = r;
    for (; o - s > 1; ) {
      const u = Math.floor((s + o) / 2), c = n[u];
      if (c === e)
        return u;
      c > e ? o = u : s = u;
    }
    return s !== o && n[o] <= e ? o : s;
  }
}
class tA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (r.isString() && (r = r.convertToNumberObjectValue()), r.isError())
      return r;
    let n = t;
    return n.isString() && (n = n.convertToNumberObjectValue()), n.isError() ? n : r.round(n);
  }
}
class rA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(h.NA)), o = O(r, n, t, g.create(h.NA)), u = s.mapValue((c, l, f) => {
      const m = o.get(l, f);
      if (c.isError())
        return c;
      if (m.isError())
        return m;
      const { isError: d, errorObject: _, variants: C } = I(c, m);
      if (d)
        return _;
      const [E, R] = C, b = +E.getValue(), p = Math.trunc(+R.getValue()), V = this._roundBank(b, p);
      return y.create(V);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _roundBank(e, t) {
    if (t > 16)
      return e;
    if (t < -16)
      return 0;
    const r = 1e-8, n = 10 ** t, s = +(e * n).toFixed(8), o = Math.floor(s), u = s - o;
    let c = Math.round(s);
    return u > 0.5 - r && u < 0.5 + r && (c = o % 2 === 0 ? o : o + 1), t ? c / n : c;
  }
}
class nA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (r.isString() && (r = r.convertToNumberObjectValue()), r.isError())
      return r;
    let n = t;
    return n.isString() && (n = n.convertToNumberObjectValue()), n.isError() ? n : r.floor(n);
  }
}
class sA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = e;
    if (r.isString() && (r = r.convertToNumberObjectValue()), r.isError())
      return r;
    let n = t;
    return n.isString() && (n = n.convertToNumberObjectValue()), n.isError() ? n : r.ceil(n);
  }
}
class aA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    return Math.abs(r) >= 2 ** 27 ? g.create(h.NUM) : t.cos().getReciprocal();
  }
}
class iA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.map((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    let t = e;
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    return Number.isFinite(Math.cosh(r)) ? Math.abs(r) >= 2 ** 27 ? g.create(h.NUM) : t.cosh().getReciprocal() : y.create(0);
  }
}
class oA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 4);
    A(this, "needsSheetRowColumnCount", !0);
  }
  calculate(e, t, r, n) {
    let s = e, o = t != null ? t : y.create(1), u = r != null ? r : y.create(1), c = n != null ? n : y.create(1);
    s.isNull() && (s = y.create(1)), o.isNull() && (o = y.create(1)), u.isNull() && (u = y.create(1)), c.isNull() && (c = y.create(1));
    const l = Math.max(
      s.isArray() ? s.getRowCount() : 1,
      o.isArray() ? o.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f = Math.max(
      s.isArray() ? s.getColumnCount() : 1,
      o.isArray() ? o.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), m = O(l, f, s, g.create(h.NA)), d = O(l, f, o, g.create(h.NA)), _ = O(l, f, u, g.create(h.NA)), C = O(l, f, c, g.create(h.NA)), E = m.mapValue((R, b, p) => {
      const V = d.get(b, p), S = _.get(b, p), M = C.get(b, p);
      return R.isError() ? R : V.isError() ? V : S.isError() ? S : M.isError() ? M : this._getResult(R, V, S, M, l, f);
    });
    return l === 1 && f === 1 ? E.get(0, 0) : E;
  }
  _getResult(e, t, r, n, s, o) {
    const { isError: u, errorObject: c, variants: l } = I(e, t, r, n);
    if (u)
      return c;
    const [f, m, d, _] = l, C = Math.floor(+f.getValue()), E = Math.floor(+m.getValue()), R = +d.getValue(), b = +_.getValue();
    if (C < 0 || E < 0 || C * E > 10 ** 7)
      return g.create(h.VALUE);
    if (C === 0 || E === 0)
      return g.create(h.CALC);
    const p = this._rowCount - this.row, V = this._columnCount - this.column;
    if (C > p || E > V)
      return g.create(h.REF);
    const S = [];
    for (let M = 0; M < C; M++) {
      S[M] = [];
      for (let D = 0; D < E; D++)
        S[M][D] = R + (M * E + D) * b;
    }
    return s > 1 || o > 1 ? y.create(S[0][0]) : K.createByArray(S);
  }
}
class uA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    if (e.isNull() || t.isNull() || r.isNull() || n.isNull())
      return g.create(h.NA);
    const { isError: s, errorObject: o, variants: u } = W(e, t, r);
    if (s)
      return o;
    const { isError: c, errorObject: l, variants: f } = I(...u);
    if (c)
      return l;
    const [m, d, _] = f, C = +m.getValue(), E = +d.getValue(), R = +_.getValue(), b = [];
    if (n.isArray()) {
      let V = !1, S = g.create(h.VALUE);
      if (n.iterator((M) => {
        const { isError: D, errorObject: w, coefficientsObject: L } = this._handleSingleObject(M);
        if (D)
          return V = !0, S = w, !1;
        const v = +L.getValue();
        b.push(v);
      }), V)
        return S;
    } else {
      const { isError: V, errorObject: S, coefficientsObject: M } = this._handleSingleObject(n);
      if (V)
        return S;
      const D = +M.getValue();
      b.push(D);
    }
    let p = 0;
    for (let V = 0; V < b.length; V++)
      p += b[V] * C ** (E + V * R);
    return Number.isNaN(p) || !Number.isFinite(p) ? g.create(h.NUM) : y.create(p);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return {
        isError: !0,
        errorObject: e,
        coefficientsObject: null
      };
    if (e != null && e.isBoolean())
      return {
        isError: !0,
        errorObject: g.create(h.VALUE),
        coefficientsObject: null
      };
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? {
      isError: !0,
      errorObject: t,
      coefficientsObject: null
    } : {
      isError: !1,
      errorObject: null,
      coefficientsObject: t
    };
  }
}
class cA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    const { isError: t, errorObject: r, variants: n } = I(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue();
    return o > 0 ? y.create(1) : o < 0 ? y.create(-1) : y.create(0);
  }
}
class lA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.sin();
  }
}
class fA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.sinh();
  }
}
class mA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.sqrt();
  }
}
class hA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    if (t.isArray()) {
      const s = t.getRowCount(), o = t.getColumnCount();
      if (s > 1 || o > 1)
        return g.create(h.VALUE);
      t = t.get(0, 0);
    }
    if (t.isString() && (t = t.convertToNumberObjectValue()), t.isError())
      return t;
    const r = +t.getValue();
    if (r < 0)
      return g.create(h.NUM);
    const n = Math.sqrt(r * Math.PI);
    return y.create(n);
  }
}
const gA = {
  1: Me.AVERAGE,
  2: Me.COUNT,
  3: Me.COUNTA,
  4: Me.MAX,
  5: Me.MIN,
  6: Me.PRODUCT,
  7: Me.STDEV,
  8: Me.STDEVP,
  9: Me.SUM,
  10: Me.VAR,
  11: Me.VARP
};
class dA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", !0);
    A(this, "needsFilteredOutRows", !0);
    A(this, "needsFormulaDataModel", !0);
  }
  calculate(e, ...t) {
    let r;
    e.isReferenceObject() ? r = e.toArrayValueObject() : r = e;
    const { isError: n, multiAreaRefs: s, normalRefs: o } = du(t);
    if (!n && s.length > 0)
      return this._handleMultiAreaRefs(r, s, t);
    if (r.isArray()) {
      const u = r.mapValue((c) => this._handleSingleObject(c, {
        isError: n,
        refs: o
      }));
      return u.getRowCount() === 1 && u.getColumnCount() === 1 ? u.get(0, 0) : u;
    }
    return this._handleSingleObject(r, {
      isError: n,
      refs: o
    });
  }
  _handleSingleObject(e, t) {
    const { isError: r = !1, refs: n } = t;
    let s = e;
    if (e.isString() && (s = e.convertToNumberObjectValue()), s.isError())
      return s;
    if (r)
      return g.create(h.VALUE);
    let o = Math.floor(+s.getValue());
    if (o < 1 || o > 11 && o < 101 || o > 111)
      return g.create(h.VALUE);
    let u = !1;
    return o >= 101 && (o -= 100, u = !0), Eu({
      type: gA[o],
      ignoreRowHidden: u,
      ignoreErrorValues: !1,
      ignoreNested: !0,
      formulaDataModel: this._formulaDataModel
    }, n);
  }
  _handleMultiAreaRefs(e, t, r) {
    const n = e.isArray() ? e.getRowCount() : 1, s = e.isArray() ? e.getColumnCount() : 1, { multiAreaInfoMap: o, maxAreasLen: u } = this._getMultiAreaInfo(t), c = Math.max(n, u), l = [];
    for (let f = 0; f < c; f++) {
      const m = f < n ? f : n - 1, d = [];
      for (let _ = 0; _ < s; _++) {
        if (n > 1 && f >= n) {
          d.push(g.create(h.NA));
          continue;
        }
        const C = e.isArray() ? e.get(m, _) : e, E = [];
        for (let b = 0; b < r.length; b++) {
          const p = r[b], V = o.get(p);
          if (V) {
            const S = f < V.rowAreas.length ? f : V.rowAreas.length - 1, M = V.rowAreas[S];
            if (M.isError()) {
              d.push(M);
              break;
            }
            E.push(M);
            continue;
          }
          E.push(p);
        }
        const R = this._handleSingleObject(C, {
          isError: !1,
          refs: E
        });
        d.push(R);
      }
      l.push(d);
    }
    return l.length === 1 ? l[0][0] : mt(l, l.length, s);
  }
  _getMultiAreaInfo(e) {
    const t = /* @__PURE__ */ new Map();
    let r = 1;
    return e.forEach((n) => {
      const s = n.getAreas().map((o) => {
        if (!o || o.length === 0)
          return n;
        const u = o.find((c) => !c.isError());
        return u != null ? u : o[0];
      });
      t.set(n, {
        ref: n,
        rowAreas: s
      }), r = Math.max(r, s.length || 1);
    }), {
      multiAreaInfoMap: t,
      maxAreasLen: r
    };
  }
}
class CA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y.create(0);
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (n.isString() && (n = n.convertToNumberObjectValue()), n.isError() || (n.isArray() && (n = n.sum()), n.isError()))
        return n;
      if (t = t.plus(n), t.isError())
        return t;
    }
    return t;
  }
}
class _A extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, t, r) {
    if (!e.isReferenceObject() || r && !r.isReferenceObject())
      return g.create(h.VALUE);
    let n = t;
    if (t.isReferenceObject() && (n = t.toArrayValueObject()), n.isArray()) {
      const s = n.mapValue((o) => this._handleSingleObject(e, o, r));
      return s.getRowCount() === 1 && s.getColumnCount() === 1 ? s.get(0, 0) : s;
    }
    return this._handleSingleObject(e, n, r);
  }
  _handleSingleObject(e, t, r) {
    const n = e.toArrayValueObject();
    let s = os(n, t);
    s = us(s, n, t);
    const o = n.getRowCount(), u = n.getColumnCount();
    let c = n;
    if (r) {
      c = r.toArrayValueObject();
      const l = c.getRowCount(), f = c.getColumnCount();
      if (o !== l || u !== f) {
        const m = r.getRangeData();
        m.endRow = m.startRow + o - 1, m.endColumn = m.startColumn + u - 1, r.setRangeData(m), c = r.toArrayValueObject();
      }
    }
    return c.pick(s).sum();
  }
}
class AA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, ...t) {
    const {
      isError: r,
      errorObject: n,
      rangeIsDifferentSize: s,
      criteriaMaxRowLength: o,
      criteriaMaxColumnLength: u,
      targetRange: c,
      variants: l
    } = Kr(t, e);
    if (r)
      return n;
    if (s)
      return o === 1 && u === 1 ? g.create(h.VALUE) : O(o, u, g.create(h.VALUE));
    const f = Zr(l, o, u, !0);
    return this._aggregateResults(c, f);
  }
  _aggregateResults(e, t) {
    const r = t.map((n) => n.map((s) => e.pick(s).sum()));
    return r.length === 1 && r[0].length === 1 ? r[0][0] : K.create({
      calculateValueList: r,
      rowCount: r.length,
      columnCount: r[0].length,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    });
  }
}
class EA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(e, ...t) {
    if (e.isError())
      return e;
    const r = this._initArray1(e);
    if (t.length === 0)
      return r.sum();
    const n = r.getRowCount(), s = r.getColumnCount(), o = this._getResultArrayByArray1(n, s, r);
    if (o instanceof g)
      return o;
    const u = o, c = this._validateVariants(t, n, s);
    return c || this._sumProduct(u, t, n, s);
  }
  /**
   * Validate all variants:
   * - propagate first error BaseValueObject
   * - ensure array dimensions are compatible with base (rowCount/columnCount)
   * Returns an ErrorValueObject / BaseValueObject on failure, or null when OK.
   */
  _validateVariants(e, t, r) {
    for (const n of e) {
      if (n.isError())
        return n;
      if (n.isArray()) {
        const s = n, o = s.getRowCount(), u = s.getColumnCount();
        if (o !== t && u !== r)
          return g.create(h.VALUE);
      }
    }
    return null;
  }
  /**
   * Core SUMPRODUCT loop.
   * - baseArray already contains numeric values from array1
   * - variants may be scalar or array; non-number cells are treated as 0
   * - any error cell short-circuits with that error
   */
  _sumProduct(e, t, r, n) {
    let s = 0;
    for (let o = 0; o < r; o++)
      for (let u = 0; u < n; u++) {
        let c = e[o][u];
        for (let l = 0; l < t.length; l++) {
          const f = t[l], m = this._getVariantCell(f, o, u);
          if (!m)
            return g.create(h.VALUE);
          if (m.isError())
            return m;
          m.isNumber() ? c *= m.getValue() : c = 0;
        }
        s += c;
      }
    return y.create(s);
  }
  /**
   * Get the value object of a variant at (r, c).
   * - For scalar variants, returns the variant itself.
   * - For array variants, returns the cell at (r, c).
   *   If cell does not exist, returns null and let caller convert to #VALUE!.
   */
  _getVariantCell(e, t, r) {
    if (!e.isArray())
      return e;
    const s = e.get(t, r);
    return s != null ? s : null;
  }
  _initArray1(e) {
    let t = e;
    return t.isArray() || (t = K.create({
      calculateValueList: [[t]],
      rowCount: 1,
      columnCount: 1,
      unitId: "",
      sheetId: "",
      row: 0,
      column: 0
    })), t;
  }
  _getResultArrayByArray1(e, t, r) {
    const n = [];
    for (let s = 0; s < e; s++) {
      const o = [];
      for (let u = 0; u < t; u++) {
        const c = r.get(s, u);
        if (c.isError())
          return c;
        c.isNumber() ? o.push(c.getValue()) : o.push(0);
      }
      n.push(o);
    }
    return n;
  }
}
class RA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y.create(0);
    const r = y.create(2);
    for (let n = 0; n < e.length; n++) {
      let s = e[n];
      if (s.isString() && (s = s.convertToNumberObjectValue()), s.isError())
        return s;
      if (s.isArray() ? s.iterator((o) => {
        if (o == null || o.isString() || o.isBoolean() || o.isNull())
          return !0;
        if (o.isError())
          return t = o, !1;
        t = t.plus(
          o.pow(r)
        );
      }) : t = t.plus(s.pow(r)), t.isError())
        return t;
    }
    return t;
  }
}
class bA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = r * n, o = t.isArray() ? t.getRowCount() : 1, u = t.isArray() ? t.getColumnCount() : 1, c = o * u;
    if (s !== c)
      return g.create(h.NA);
    if (s === 1)
      return this._calculateSingleCell(e, t);
    {
      const l = e.flatten(), f = t.flatten();
      let m = ce.create();
      const d = [], _ = [];
      let C = 0;
      return l.iterator((E, R, b) => {
        const p = f.get(R, b);
        if (E == null || E.isString() || E.isBoolean() || E.isNull())
          return !0;
        if (E != null && E.isError())
          return m = E, !1;
        if (p == null || p.isString() || p.isBoolean() || p.isNull())
          return !0;
        if (p != null && p.isError())
          return m = p, !1;
        const V = +E.getValue(), S = +p.getValue();
        d.push(V), _.push(S), C += V ** 2 - S ** 2;
      }), m.isError() ? m : d.length === 0 || _.length === 0 ? g.create(h.DIV_BY_ZERO) : y.create(C);
    }
  }
  _calculateSingleCell(e, t) {
    let r = e;
    if (r.isArray() && (r = r.get(0, 0)), r.isError())
      return r;
    let n = t;
    if (n.isArray() && (n = n.get(0, 0)), n.isError())
      return n;
    if (r.isNull() || n.isNull())
      return g.create(h.VALUE);
    const s = +r.getValue(), o = +n.getValue();
    if (r.isString() && !q(s) || r.isBoolean() || n.isString() && !q(o) || n.isBoolean())
      return g.create(h.DIV_BY_ZERO);
    const u = s ** 2 - o ** 2;
    return y.create(u);
  }
}
class yA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = r * n, o = t.isArray() ? t.getRowCount() : 1, u = t.isArray() ? t.getColumnCount() : 1, c = o * u;
    if (s !== c)
      return g.create(h.NA);
    if (s === 1)
      return this._calculateSingleCell(e, t);
    {
      const l = e.flatten(), f = t.flatten();
      let m = ce.create();
      const d = [], _ = [];
      let C = 0;
      return l.iterator((E, R, b) => {
        const p = f.get(R, b);
        if (E == null || E.isString() || E.isBoolean() || E.isNull())
          return !0;
        if (E != null && E.isError())
          return m = E, !1;
        if (p == null || p.isString() || p.isBoolean() || p.isNull())
          return !0;
        if (p != null && p.isError())
          return m = p, !1;
        const V = +E.getValue(), S = +p.getValue();
        d.push(V), _.push(S), C += V ** 2 + S ** 2;
      }), m.isError() ? m : d.length === 0 || _.length === 0 ? g.create(h.DIV_BY_ZERO) : y.create(C);
    }
  }
  _calculateSingleCell(e, t) {
    let r = e;
    if (r.isArray() && (r = r.get(0, 0)), r.isError())
      return r;
    let n = t;
    if (n.isArray() && (n = n.get(0, 0)), n.isError())
      return n;
    if (r.isNull() || n.isNull())
      return g.create(h.VALUE);
    const s = +r.getValue(), o = +n.getValue();
    if (r.isString() && !q(s) || r.isBoolean() || n.isString() && !q(o) || n.isBoolean())
      return g.create(h.DIV_BY_ZERO);
    const u = s ** 2 + o ** 2;
    return y.create(u);
  }
}
class pA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = r * n, o = t.isArray() ? t.getRowCount() : 1, u = t.isArray() ? t.getColumnCount() : 1, c = o * u;
    if (s !== c)
      return g.create(h.NA);
    if (s === 1)
      return this._calculateSingleCell(e, t);
    {
      const l = e.flatten(), f = t.flatten();
      let m = ce.create();
      const d = [], _ = [];
      let C = 0;
      return l.iterator((E, R, b) => {
        const p = f.get(R, b);
        if (E == null || E.isString() || E.isBoolean() || E.isNull())
          return !0;
        if (E != null && E.isError())
          return m = E, !1;
        if (p == null || p.isString() || p.isBoolean() || p.isNull())
          return !0;
        if (p != null && p.isError())
          return m = p, !1;
        const V = +E.getValue(), S = +p.getValue();
        d.push(V), _.push(S), C += (V - S) ** 2;
      }), m.isError() ? m : d.length === 0 || _.length === 0 ? g.create(h.DIV_BY_ZERO) : y.create(C);
    }
  }
  _calculateSingleCell(e, t) {
    let r = e;
    if (r.isArray() && (r = r.get(0, 0)), r.isError())
      return r;
    let n = t;
    if (n.isArray() && (n = n.get(0, 0)), n.isError())
      return n;
    if (r.isNull() || n.isNull())
      return g.create(h.VALUE);
    const s = +r.getValue(), o = +n.getValue();
    if (r.isString() && !q(s) || r.isBoolean() || n.isString() && !q(o) || n.isBoolean())
      return g.create(h.DIV_BY_ZERO);
    const u = (s - o) ** 2;
    return y.create(u);
  }
}
class NA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.tan();
  }
}
class VA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    let t = e;
    return t.isString() && (t = t.convertToNumberObjectValue()), t.isError() ? t : t.tanh();
  }
}
class OA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(0), n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, r, g.create(h.NA)), c = o.map((l, f, m) => {
      let d = u.get(f, m), _ = l;
      if (_.isString() && (_ = _.convertToNumberObjectValue()), _.isError())
        return _;
      if (d.isString() && (d = d.convertToNumberObjectValue()), d.isError())
        return d;
      const C = +_.getValue(), E = +d.getValue(), R = 10 ** Math.trunc(E), b = as(C, R), p = Math.trunc(xr(C, R) + b) / R;
      return y.create(p);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
}
const SA = [
  [zC, F.ABS],
  [JC, F.ACOS],
  [e_, F.ACOSH],
  [t_, F.ACOT],
  [r_, F.ACOTH],
  [s_, F.AGGREGATE],
  [a_, F.ARABIC],
  [i_, F.ASIN],
  [o_, F.ASINH],
  [u_, F.ATAN],
  [c_, F.ATAN2],
  [l_, F.ATANH],
  [f_, F.BASE],
  [m_, F.CEILING],
  [h_, F.CEILING_MATH],
  [g_, F.CEILING_PRECISE],
  [d_, F.COMBIN],
  [C_, F.COMBINA],
  [__, F.COS],
  [A_, F.COSH],
  [E_, F.COT],
  [R_, F.COTH],
  [b_, F.CSC],
  [y_, F.CSCH],
  [p_, F.DECIMAL],
  [N_, F.DEGREES],
  [V_, F.EVEN],
  [O_, F.EXP],
  [S_, F.FACT],
  [M_, F.FACTDOUBLE],
  [D_, F.FLOOR],
  [w_, F.FLOOR_MATH],
  [L_, F.FLOOR_PRECISE],
  [P_, F.GCD],
  [x_, F.INT],
  [j_, F.LCM],
  [U_, F.LN],
  [v_, F.LOG],
  [T_, F.LOG10],
  [I_, F.MDETERM],
  [B_, F.MINVERSE],
  [F_, F.MMULT],
  [k_, F.MOD],
  [$_, F.MROUND],
  [Y_, F.MULTINOMIAL],
  [H_, F.MUNIT],
  [G_, F.ODD],
  [W_, F.PI],
  [Q_, F.POWER],
  [q_, F.PRODUCT],
  [X_, F.QUOTIENT],
  [K_, F.RADIANS],
  [Z_, F.RAND],
  [z_, F.RANDARRAY],
  [J_, F.RANDBETWEEN],
  [eA, F.ROMAN],
  [tA, F.ROUND],
  [rA, F.ROUNDBANK],
  [nA, F.ROUNDDOWN],
  [sA, F.ROUNDUP],
  [aA, F.SEC],
  [iA, F.SECH],
  [uA, F.SERIESSUM],
  [oA, F.SEQUENCE],
  [cA, F.SIGN],
  [lA, F.SIN],
  [fA, F.SINH],
  [mA, F.SQRT],
  [hA, F.SQRTPI],
  [dA, F.SUBTOTAL],
  [CA, F.SUM],
  [_A, F.SUMIF],
  [AA, F.SUMIFS],
  [EA, F.SUMPRODUCT],
  [RA, F.SUMSQ],
  [bA, F.SUMX2MY2],
  [yA, F.SUMX2PY2],
  [pA, F.SUMXMY2],
  [NA, F.TAN],
  [VA, F.TANH],
  [OA, F.TRUNC]
];
class MA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
    A(this, "_compareType", Y.EQUALS);
  }
  setCompareType(e) {
    this._compareType = e;
  }
  calculate(e, t) {
    return e.isError() ? e : t.isError() ? t : e.compare(t, this._compareType);
  }
}
class ei extends Qt {
  constructor(e) {
    super("");
    A(this, "_values", []);
    this._values = e;
  }
  static create(e) {
    return new ei(e);
  }
  isCube() {
    return !0;
  }
  dispose() {
    this._values.forEach((e) => {
      e.dispose();
    }), this._values = [];
  }
  getCubeValues() {
    return this._values;
  }
  getCubeCount() {
    return this._values.length;
  }
  sum() {
    const e = y.create(0);
    return this._values.forEach((t) => {
      e.plus(t.sum());
    }), e;
  }
  max() {
    let e = y.create(Number.NEGATIVE_INFINITY);
    return this._values.forEach((t) => {
      const r = t.max();
      e.isLessThan(r) && (e = r);
    }), e;
  }
  min() {
    let e = y.create(Number.POSITIVE_INFINITY);
    return this._values.forEach((t) => {
      const r = t.max();
      e.isGreaterThan(r) && (e = r);
    }), e;
  }
  count() {
    const e = y.create(0);
    return this._values.forEach((t) => {
      e.plus(t.count());
    }), e;
  }
  countA() {
    const e = y.create(0);
    return this._values.forEach((t) => {
      e.plus(t.countA());
    }), e;
  }
  countBlank() {
    const e = y.create(0);
    return this._values.forEach((t) => {
      e.plus(t.countBlank());
    }), e;
  }
}
class DA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      if (n.isError())
        return n;
      if (!n.isArray())
        return g.create(h.VALUE);
      t.push(n);
    }
    return ei.create(t);
  }
}
class wA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    return e.isError() ? e : t.isError() ? t : !t.isArray() && t.getValue() === 0 ? g.create(h.DIV_BY_ZERO) : e.divided(t);
  }
}
class LA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    return e.isError() ? e : t.isError() ? t : e.minus(t);
  }
}
class PA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    return e.isError() ? e : t.isError() ? t : e.multiply(t);
  }
}
class xA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    return e.isError() ? e : t.isError() ? t : e.plus(t);
  }
}
const jA = [
  [MA, ke.COMPARE],
  [wA, ke.DIVIDED],
  [LA, ke.MINUS],
  [PA, ke.MULTIPLY],
  [xA, ke.PLUS],
  [DA, ke.CUBE]
];
var P = /* @__PURE__ */ ((a) => (a.AVEDEV = "AVEDEV", a.AVERAGE = "AVERAGE", a.AVERAGE_WEIGHTED = "AVERAGE.WEIGHTED", a.AVERAGEA = "AVERAGEA", a.AVERAGEIF = "AVERAGEIF", a.AVERAGEIFS = "AVERAGEIFS", a.BETA_DIST = "BETA.DIST", a.BETA_INV = "BETA.INV", a.BINOM_DIST = "BINOM.DIST", a.BINOM_DIST_RANGE = "BINOM.DIST.RANGE", a.BINOM_INV = "BINOM.INV", a.CHISQ_DIST = "CHISQ.DIST", a.CHISQ_DIST_RT = "CHISQ.DIST.RT", a.CHISQ_INV = "CHISQ.INV", a.CHISQ_INV_RT = "CHISQ.INV.RT", a.CHISQ_TEST = "CHISQ.TEST", a.CONFIDENCE_NORM = "CONFIDENCE.NORM", a.CONFIDENCE_T = "CONFIDENCE.T", a.CORREL = "CORREL", a.COUNT = "COUNT", a.COUNTA = "COUNTA", a.COUNTBLANK = "COUNTBLANK", a.COUNTIF = "COUNTIF", a.COUNTIFS = "COUNTIFS", a.COVARIANCE_P = "COVARIANCE.P", a.COVARIANCE_S = "COVARIANCE.S", a.DEVSQ = "DEVSQ", a.EXPON_DIST = "EXPON.DIST", a.F_DIST = "F.DIST", a.F_DIST_RT = "F.DIST.RT", a.F_INV = "F.INV", a.F_INV_RT = "F.INV.RT", a.F_TEST = "F.TEST", a.FISHER = "FISHER", a.FISHERINV = "FISHERINV", a.FORECAST = "FORECAST", a.FORECAST_ETS = "FORECAST.ETS", a.FORECAST_ETS_CONFINT = "FORECAST.ETS.CONFINT", a.FORECAST_ETS_SEASONALITY = "FORECAST.ETS.SEASONALITY", a.FORECAST_ETS_STAT = "FORECAST.ETS.STAT", a.FORECAST_LINEAR = "FORECAST.LINEAR", a.FREQUENCY = "FREQUENCY", a.GAMMA = "GAMMA", a.GAMMA_DIST = "GAMMA.DIST", a.GAMMA_INV = "GAMMA.INV", a.GAMMALN = "GAMMALN", a.GAMMALN_PRECISE = "GAMMALN.PRECISE", a.GAUSS = "GAUSS", a.GEOMEAN = "GEOMEAN", a.GROWTH = "GROWTH", a.HARMEAN = "HARMEAN", a.HYPGEOM_DIST = "HYPGEOM.DIST", a.INTERCEPT = "INTERCEPT", a.KURT = "KURT", a.LARGE = "LARGE", a.LINEST = "LINEST", a.LOGEST = "LOGEST", a.LOGNORM_DIST = "LOGNORM.DIST", a.LOGNORM_INV = "LOGNORM.INV", a.MARGINOFERROR = "MARGINOFERROR", a.MAX = "MAX", a.MAXA = "MAXA", a.MAXIFS = "MAXIFS", a.MEDIAN = "MEDIAN", a.MIN = "MIN", a.MINA = "MINA", a.MINIFS = "MINIFS", a.MODE_MULT = "MODE.MULT", a.MODE_SNGL = "MODE.SNGL", a.NEGBINOM_DIST = "NEGBINOM.DIST", a.NORM_DIST = "NORM.DIST", a.NORM_INV = "NORM.INV", a.NORM_S_DIST = "NORM.S.DIST", a.NORM_S_INV = "NORM.S.INV", a.PEARSON = "PEARSON", a.PERCENTILE_EXC = "PERCENTILE.EXC", a.PERCENTILE_INC = "PERCENTILE.INC", a.PERCENTRANK_EXC = "PERCENTRANK.EXC", a.PERCENTRANK_INC = "PERCENTRANK.INC", a.PERMUT = "PERMUT", a.PERMUTATIONA = "PERMUTATIONA", a.PHI = "PHI", a.POISSON_DIST = "POISSON.DIST", a.PROB = "PROB", a.QUARTILE_EXC = "QUARTILE.EXC", a.QUARTILE_INC = "QUARTILE.INC", a.RANK_AVG = "RANK.AVG", a.RANK_EQ = "RANK.EQ", a.RSQ = "RSQ", a.SKEW = "SKEW", a.SKEW_P = "SKEW.P", a.SLOPE = "SLOPE", a.SMALL = "SMALL", a.STANDARDIZE = "STANDARDIZE", a.STDEV_P = "STDEV.P", a.STDEV_S = "STDEV.S", a.STDEVA = "STDEVA", a.STDEVPA = "STDEVPA", a.STEYX = "STEYX", a.T_DIST = "T.DIST", a.T_DIST_2T = "T.DIST.2T", a.T_DIST_RT = "T.DIST.RT", a.T_INV = "T.INV", a.T_INV_2T = "T.INV.2T", a.T_TEST = "T.TEST", a.TREND = "TREND", a.TRIMMEAN = "TRIMMEAN", a.VAR_P = "VAR.P", a.VAR_S = "VAR.S", a.VARA = "VARA", a.VARPA = "VARPA", a.WEIBULL_DIST = "WEIBULL.DIST", a.Z_TEST = "Z.TEST", a))(P || {}), ti = /* @__PURE__ */ ((a) => (a.ENCODEURL = "ENCODEURL", a.FILTERXML = "FILTERXML", a.WEBSERVICE = "WEBSERVICE", a))(ti || {});
const Wb = /* @__PURE__ */ new Set([
  // Trigonometric & Math extensions
  F.ACOT,
  F.ACOTH,
  F.ARABIC,
  F.BASE,
  F.CEILING_MATH,
  F.CEILING_PRECISE,
  F.COMBINA,
  F.COT,
  F.COTH,
  F.CSC,
  F.CSCH,
  F.DECIMAL,
  F.FLOOR_MATH,
  F.FLOOR_PRECISE,
  F.MUNIT,
  F.RANDARRAY,
  F.SEC,
  F.SECH,
  F.SEQUENCE,
  // Dynamic array functions
  re.CHOOSECOLS,
  re.CHOOSEROWS,
  re.DROP,
  re.EXPAND,
  re.FILTER,
  re.FORMULATEXT,
  re.HSTACK,
  re.SORT,
  re.SORTBY,
  re.TAKE,
  re.TOCOL,
  re.TOROW,
  re.UNIQUE,
  re.VSTACK,
  re.WRAPCOLS,
  re.WRAPROWS,
  re.XLOOKUP,
  re.XMATCH,
  // Bitwise and complex math
  Q.BITAND,
  Q.BITLSHIFT,
  Q.BITOR,
  Q.BITRSHIFT,
  Q.BITXOR,
  Q.ERF_PRECISE,
  Q.ERFC_PRECISE,
  Q.IMCOSH,
  Q.IMCOT,
  Q.IMCSC,
  Q.IMCSCH,
  Q.IMSEC,
  Q.IMSECH,
  Q.IMSINH,
  Q.IMTAN,
  // Information functions
  Ve.ISFORMULA,
  Ve.SHEET,
  Ve.SHEETS,
  // Logical extensions
  Ee.IFNA,
  Ee.IFS,
  Ee.SWITCH,
  Ee.XOR,
  // Statistical and text extensions
  P.BETA_DIST,
  P.BETA_INV,
  P.BINOM_DIST,
  P.BINOM_DIST_RANGE,
  P.BINOM_INV,
  P.CHISQ_DIST,
  P.CHISQ_DIST_RT,
  P.CHISQ_INV,
  P.CHISQ_INV_RT,
  P.CHISQ_TEST,
  P.CONFIDENCE_NORM,
  P.CONFIDENCE_T,
  P.COVARIANCE_P,
  P.COVARIANCE_S,
  P.EXPON_DIST,
  P.F_DIST,
  P.F_DIST_RT,
  P.F_INV,
  P.F_INV_RT,
  P.F_TEST,
  P.FORECAST_LINEAR,
  P.GAMMA,
  P.GAMMA_DIST,
  P.GAMMA_INV,
  P.GAMMALN_PRECISE,
  P.GAUSS,
  P.HYPGEOM_DIST,
  P.LOGNORM_DIST,
  P.LOGNORM_INV,
  P.MAXIFS,
  P.MINIFS,
  P.MODE_MULT,
  P.MODE_SNGL,
  P.NEGBINOM_DIST,
  P.NORM_DIST,
  P.NORM_INV,
  P.NORM_S_DIST,
  P.NORM_S_INV,
  P.PERCENTILE_EXC,
  P.PERCENTILE_INC,
  P.PERCENTRANK_EXC,
  P.PERCENTRANK_INC,
  P.PERMUTATIONA,
  P.PHI,
  P.POISSON_DIST,
  P.QUARTILE_EXC,
  P.QUARTILE_INC,
  P.RANK_AVG,
  P.RANK_EQ,
  P.SKEW_P,
  P.STDEV_P,
  P.STDEV_S,
  P.T_DIST,
  P.T_DIST_2T,
  P.T_DIST_RT,
  P.T_INV,
  P.T_INV_2T,
  P.T_TEST,
  P.VAR_P,
  P.VAR_S,
  P.WEIBULL_DIST,
  P.Z_TEST,
  // Text and encoding
  J.ARRAYTOTEXT,
  ti.ENCODEURL,
  J.NUMBERVALUE,
  J.TEXTAFTER,
  J.TEXTBEFORE,
  J.TEXTJOIN,
  J.TEXTSPLIT,
  J.UNICHAR,
  J.UNICODE,
  J.VALUETOTEXT,
  // Date & time
  Ae.DAYS,
  Ae.ISOWEEKNUM,
  ee.PDURATION,
  ee.RRI,
  Ee.BYCOL,
  Ee.BYROW,
  Ee.MAKEARRAY,
  Ee.MAP,
  Ee.REDUCE,
  Ee.SCAN
]);
class UA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y.create(0), r = y.create(0);
    for (let o = 0; o < e.length; o++) {
      let u = e[o];
      if (u.isString() && (u = u.convertToNumberObjectValue()), u.isError())
        return u;
      if (u.isArray()) {
        if (u = vA(u), u.isError())
          return u;
        if (e[o] = u, t = t.plus(u.sum()), t.isError())
          return t;
        r = r.plus(u.count());
      } else u.isNull() || (t = t.plus(u), r = r.plus(y.create(1)));
    }
    if (r.getValue() === 0)
      return g.create(h.NUM);
    const n = t.divided(r);
    if (n.isError())
      return n;
    let s = y.create(0);
    for (let o = 0; o < e.length; o++) {
      let u = e[o];
      if (u.isString() && (u = u.convertToNumberObjectValue()), u.isError())
        return u;
      if (u.isArray()) {
        if (s = s.plus(u.minus(n).abs().sum()), s.isError())
          return s;
      } else u.isNull() || (s = s.plus(u.minus(n).abs()));
    }
    return s.divided(r);
  }
}
function vA(a) {
  const i = [];
  i[0] = [];
  let e = null;
  return a.iterator((t, r, n) => {
    if (t != null && t.isError())
      return e = t, !1;
    t != null && t.isNumber() && i[0].push(t);
  }), e || mt(i, 1, i[0].length);
}
class TA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y.create(0), r = y.create(0);
    for (let n = 0; n < e.length; n++) {
      let s = e[n];
      if ((s.isString() || s.isBoolean()) && (s = s.convertToNumberObjectValue()), s.isError())
        return s;
      if (s.isArray()) {
        if (t = t.plus(s.sum()), t.isError())
          return t;
        r = r.plus(s.count());
      } else s.isNull() || (t = t.plus(s), r = r.plus(y.create(1)));
    }
    return t.divided(r);
  }
}
class IA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 254);
  }
  // eslint-disable-next-line
  calculate(...e) {
    let t = !1, r;
    e.length % 2 !== 0 && (t = !0, r = g.create(h.NA));
    const n = [], s = [];
    for (let o = 0; o < e.length; o += 2) {
      const u = e[o], c = u.isArray() ? u.getRowCount() : 1, l = u.isArray() ? u.getColumnCount() : 1;
      for (let _ = 0; _ < c; _++)
        for (let C = 0; C < l; C++) {
          const E = u.isArray() ? u.get(_, C) : u;
          if (E.isError())
            return E;
          if (t)
            continue;
          const R = E.isNull() ? "" : E.getValue();
          n.push(R);
        }
      if (o + 1 >= e.length)
        continue;
      const f = e[o + 1], m = f.isArray() ? f.getRowCount() : 1, d = f.isArray() ? f.getColumnCount() : 1;
      (m !== c || d !== l) && (t = !0, r = g.create(h.VALUE));
      for (let _ = 0; _ < m; _++)
        for (let C = 0; C < d; C++) {
          const E = f.isArray() ? f.get(_, C) : f;
          if (E.isError())
            return E;
          if (t)
            continue;
          const R = E.isNull() ? "" : E.getValue();
          s.push(R);
        }
    }
    return t ? r : this._getResult(n, s);
  }
  _getResult(e, t) {
    const r = e.length;
    let n = 0, s = 0;
    for (let u = 0; u < r; u++) {
      const c = e[u], l = t[u];
      if (!(typeof c != "number" && typeof l != "number")) {
        if (typeof c != "number" || typeof l != "number" || l < 0)
          return g.create(h.VALUE);
        n += c * l, s += l;
      }
    }
    if (s === 0)
      return g.create(h.DIV_BY_ZERO);
    const o = n / s;
    return y.create(o);
  }
}
class BA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y.create(0), r = y.create(0);
    for (let n = 0; n < e.length; n++) {
      let s = e[n];
      if ((s.isString() || s.isBoolean()) && (s = s.convertToNumberObjectValue()), s.isError())
        return s;
      if (s.isArray()) {
        if (s.iterator((o) => {
          if (o == null || o.isNull())
            return !0;
          let u = o;
          if (u.isString() && (u = u.convertToNumberObjectValue(), u.isError() && (u = y.create(0))), u.isBoolean() && (u = u.convertToNumberObjectValue()), u.isError())
            return t = u, !1;
          t = t.plus(u), r = r.plus(y.create(1));
        }), t.isError())
          return t;
      } else s.isNull() || (t = t.plus(s), r = r.plus(y.create(1)));
    }
    return t.divided(r);
  }
}
class FA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, t, r) {
    if (!e.isReferenceObject() || r && !r.isReferenceObject())
      return g.create(h.VALUE);
    let n = t;
    if (t.isReferenceObject() && (n = t.toArrayValueObject()), n.isArray()) {
      const s = n.mapValue((o) => this._handleSingleObject(e, o, r));
      return s.getRowCount() === 1 && s.getColumnCount() === 1 ? s.get(0, 0) : s;
    }
    return this._handleSingleObject(e, n, r);
  }
  _handleSingleObject(e, t, r) {
    const n = e.toArrayValueObject();
    let s = os(n, t);
    s = us(s, n, t);
    const o = n.getRowCount(), u = n.getColumnCount();
    let c = n;
    if (r) {
      c = r.toArrayValueObject();
      const d = c.getRowCount(), _ = c.getColumnCount();
      if (o !== d || u !== _) {
        const C = r.getRangeData();
        C.endRow = C.startRow + o - 1, C.endColumn = C.startColumn + u - 1, r.setRangeData(C), c = r.toArrayValueObject();
      }
    }
    const l = c.pick(s), f = l.sum(), m = l.count();
    return f.divided(m);
  }
}
class kA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, ...t) {
    const {
      isError: r,
      errorObject: n,
      rangeIsDifferentSize: s,
      criteriaMaxRowLength: o,
      criteriaMaxColumnLength: u,
      targetRange: c,
      variants: l
    } = Kr(t, e);
    if (r)
      return n;
    if (s)
      return o === 1 && u === 1 ? g.create(h.VALUE) : O(o, u, g.create(h.VALUE));
    const f = Zr(l, o, u, !0);
    return this._aggregateResults(c, f);
  }
  _aggregateResults(e, t) {
    const r = t.map((n) => n.map((s) => {
      const o = e.pick(s), u = o.sum(), c = o.count();
      return u.divided(c);
    }));
    return r.length === 1 && r[0].length === 1 ? r[0][0] : K.create({
      calculateValueList: r,
      rowCount: r.length,
      columnCount: r[0].length,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    });
  }
}
class $A extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    let u = s != null ? s : y.create(0), c = o != null ? o : y.create(1);
    u.isNull() && (u = y.create(0)), c.isNull() && (c = y.create(1));
    const l = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      u.isArray() ? u.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      u.isArray() ? u.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), m = O(l, f, e, g.create(h.NA)), d = O(l, f, t, g.create(h.NA)), _ = O(l, f, r, g.create(h.NA)), C = O(l, f, n, g.create(h.NA)), E = O(l, f, u, g.create(h.NA)), R = O(l, f, c, g.create(h.NA)), b = m.mapValue((p, V, S) => {
      const M = d.get(V, S), D = _.get(V, S), w = C.get(V, S), L = E.get(V, S), v = R.get(V, S);
      return this._handleSingleObject(p, M, D, w, L, v);
    });
    return l === 1 && f === 1 ? b.get(0, 0) : b;
  }
  _handleSingleObject(e, t, r, n, s, o) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (r.isError())
      return r;
    if (n.isError())
      return n;
    if (s.isError())
      return s;
    if (o.isError())
      return o;
    const { isError: u, errorObject: c, variants: l } = I(e, t, r, n, s, o);
    if (u)
      return c;
    const [f, m, d, _, C, E] = l, R = +f.getValue(), b = +m.getValue(), p = +d.getValue(), V = +_.getValue(), S = +C.getValue(), M = +E.getValue();
    if (b <= 0 || p <= 0 || R < S || R > M || S === M)
      return g.create(h.NUM);
    let D;
    return V ? D = iu((R - S) / (M - S), b, p) : D = Gh((R - S) / (M - S), b, p) / (M - S), y.create(D);
  }
}
class YA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    let s = n != null ? n : r;
    s.isNull() && (s = r);
    const o = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, e, g.create(h.NA)), l = O(o, u, t, g.create(h.NA)), f = O(o, u, r, g.create(h.NA)), m = O(o, u, s, g.create(h.NA)), d = c.mapValue((_, C, E) => {
      const R = l.get(C, E), b = f.get(C, E), p = m.get(C, E);
      return _.isError() ? _ : R.isError() ? R : b.isError() ? b : p.isError() ? p : this._handleSingleObject(_, R, b, p);
    });
    return o === 1 && u === 1 ? d.get(0, 0) : d;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = I(e, t, r, n);
    if (s)
      return o;
    const [c, l, f, m] = u, d = Math.floor(+c.getValue()), _ = +l.getValue(), C = Math.floor(+f.getValue()), E = Math.floor(+m.getValue());
    if (d < 0 || _ < 0 || _ > 1 || C < 0 || C > d || E < 0 || E < C || E > d)
      return g.create(h.NUM);
    let R = 0;
    for (let b = C; b <= E; b++)
      R += Ya(b, d, _);
    return y.create(R);
  }
}
class HA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, t, g.create(h.NA)), c = O(n, s, r, g.create(h.NA)), l = o.mapValue((f, m, d) => {
      const _ = u.get(m, d), C = c.get(m, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), m = Math.floor(+c.getValue()), d = +l.getValue();
    if (f < 0 || m < 1 || m > 10 ** 10)
      return g.create(h.NUM);
    let _;
    return d ? _ = Ha(f, m) : _ = Wh(f, m), y.create(_);
  }
}
class GA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(h.NA)), o = O(r, n, t, g.create(h.NA)), u = s.mapValue((c, l, f) => {
      const m = o.get(l, f);
      return c.isError() ? c : m.isError() ? m : this._handleSingleObject(c, m);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = I(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (c < 0 || c > 1 || l < 1 || l > 10 ** 10)
      return g.create(h.NUM);
    const f = uu(c, l);
    return Number.isNaN(f) || !Number.isFinite(f) ? g.create(h.NUM) : y.create(f);
  }
}
class WA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, t, g.create(h.NA)), c = O(n, s, r, g.create(h.NA)), l = o.mapValue((f, m, d) => {
      const _ = u.get(m, d), C = c.get(m, d);
      if (f.isError())
        return f;
      if (_.isError())
        return _;
      if (C.isError())
        return C;
      const { isError: E, errorObject: R, variants: b } = I(f, _, C);
      if (E)
        return R;
      const [p, V, S] = b, M = +p.getValue(), D = +V.getValue(), w = Math.floor(+S.getValue());
      if (M <= 0 || M >= 1 || D <= 0 || w < 1)
        return g.create(h.NUM);
      if (w === 1)
        return g.create(h.DIV_BY_ZERO);
      const L = Math.abs(ms(M / 2, w - 1) * D / Math.sqrt(w));
      return y.create(L);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
}
class QA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if (r * n === 1 || s * o === 1)
      return u.isNull() || c.isNull() ? g.create(h.VALUE) : g.create(h.DIV_BY_ZERO);
    if (r * n !== s * o)
      return g.create(h.NA);
    const {
      isError: l,
      errorObject: f,
      array1Values: m,
      array2Values: d,
      noCalculate: _
    } = st(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f : _ ? g.create(h.DIV_BY_ZERO) : this._getResult(m, d);
  }
  _getResult(e, t) {
    const r = e.length;
    let n = 0, s = 0;
    for (let d = 0; d < r; d++)
      n += e[d], s += t[d];
    const o = n / r, u = s / r;
    let c = 0, l = 0, f = 0;
    for (let d = 0; d < r; d++) {
      const _ = e[d] - o, C = t[d] - u;
      c += _ * C, l += _ ** 2, f += C ** 2;
    }
    const m = Math.sqrt(l * f);
    return m === 0 ? g.create(h.DIV_BY_ZERO) : y.create(c / m);
  }
}
class qA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y.create(0);
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      n.isError() || (n.isArray() ? t = t.plus(n.count()) : n.isString() ? n.convertToNumberObjectValue().isError() || (t = t.plus(y.create(1))) : n.isNull() || (t = t.plus(y.create(1))));
    }
    return t;
  }
}
class XA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y.create(0);
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (n.isError()) {
        t = t.plus(y.create(1));
        continue;
      }
      n.isArray() ? (n = n.countA(), t = t.plus(n)) : n.isNull() || (t = t.plus(y.create(1)));
    }
    return t;
  }
}
class KA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isError() ? e : e.getValue() === "" || e.isNull() ? y.create(1) : e.isArray() ? e.countBlank() : y.create(0);
  }
}
class ZA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, t) {
    if (!e.isReferenceObject())
      return g.create(h.VALUE);
    let r = t;
    if (t.isReferenceObject() && (r = t.toArrayValueObject()), r.isArray()) {
      const n = r.mapValue((s) => this._handleSingleObject(e, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(e, r);
  }
  _handleSingleObject(e, t) {
    const r = e.toArrayValueObject();
    let n = os(r, t);
    n = us(n, r, t);
    const s = r.pick(n);
    return this._countA(s);
  }
  _countA(e) {
    let t = y.create(0);
    return e.iterator((r) => {
      if (r == null)
        return !0;
      t = t.plusBy(1);
    }), t;
  }
}
class zA extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", !0);
  }
  calculate(...e) {
    const {
      isError: t,
      errorObject: r,
      rangeIsDifferentSize: n,
      criteriaMaxRowLength: s,
      criteriaMaxColumnLength: o,
      variants: u
    } = Kr(e);
    if (t)
      return r;
    if (n)
      return s === 1 && o === 1 ? g.create(h.VALUE) : O(s, o, g.create(h.VALUE));
    const c = Zr(u, s, o, !0);
    return this._aggregateResults(c);
  }
  _aggregateResults(e) {
    const t = e.map((r) => r.map((n) => JA(n)));
    return t.length === 1 && t[0].length === 1 ? t[0][0] : K.create({
      calculateValueList: t,
      rowCount: t.length,
      columnCount: t[0].length,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    });
  }
}
function JA(a) {
  let i = 0;
  return a.iterator((e) => {
    e != null && e.isBoolean() && e.getValue() === !0 && i++;
  }), y.create(i);
}
class eE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if ((r * n === 1 || s * o === 1) && (u.isNull() || c.isNull()))
      return g.create(h.VALUE);
    if (r * n !== s * o)
      return g.create(h.NA);
    const {
      isError: l,
      errorObject: f,
      array1Values: m,
      array2Values: d,
      noCalculate: _
    } = st(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f : _ ? g.create(h.DIV_BY_ZERO) : this._getResult(m, d);
  }
  _getResult(e, t) {
    if (e.length <= 1)
      return g.create(h.DIV_BY_ZERO);
    const r = e.length;
    let n = 0, s = 0;
    for (let l = 0; l < r; l++)
      n += e[l], s += t[l];
    const o = n / r, u = s / r;
    let c = 0;
    for (let l = 0; l < r; l++) {
      const f = e[l] - o, m = t[l] - u;
      c += f * m;
    }
    return y.create(c / (r - 1));
  }
}
class tE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = [];
    let r = 0, n = !0;
    for (let u = 0; u < e.length; u++) {
      const c = e[u];
      if (c.isArray()) {
        let l = !1, f = g.create(h.VALUE);
        if (c.iterator((m) => {
          const d = this._handleSingleObject(m);
          if (d.isError())
            return l = !0, f = d, !1;
          if (d.isNull())
            return !0;
          const _ = d.getValue();
          t.push(_), r += _, n = !1;
        }), l)
          return f;
      } else {
        const l = this._handleSingleObject(c);
        if (l.isError())
          return l;
        if (l.isNull())
          continue;
        const f = l.getValue();
        t.push(f), r += f, n = !1;
      }
    }
    if (n)
      return g.create(h.NUM);
    const s = r / t.length;
    let o = 0;
    for (let u = 0; u < t.length; u++)
      o += (t[u] - s) ** 2;
    return y.create(o);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isNull() || e.isBoolean())
      return ce.create();
    const t = e.getValue();
    return q(t) ? y.create(+t) : ce.create();
  }
}
class rE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(h.NA)), c = O(s, o, t, g.create(h.NA)), l = O(s, o, r, g.create(h.NA)), f = O(s, o, n, g.create(h.NA)), m = u.mapValue((d, _, C) => {
      const E = c.get(_, C), R = l.get(_, C), b = f.get(_, C);
      return d.isError() ? d : E.isError() ? E : R.isError() ? R : b.isError() ? b : this._handleSingleObject(d, E, R, b);
    });
    return s === 1 && o === 1 ? m.get(0, 0) : m;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = I(e, t, r, n);
    if (s)
      return o;
    const [c, l, f, m] = u, d = +c.getValue(), _ = Math.floor(+l.getValue()), C = Math.floor(+f.getValue()), E = +m.getValue();
    if (d < 0 || _ < 1 || _ > 10 ** 10 || C < 1 || C > 10 ** 10)
      return g.create(h.NUM);
    let R;
    return E ? R = Ga(d, _, C) : R = Qh(d, _, C), Number.isNaN(R) || !Number.isFinite(R) ? g.create(h.NUM) : y.create(R);
  }
}
class nE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, t, g.create(h.NA)), c = O(n, s, r, g.create(h.NA)), l = o.mapValue((f, m, d) => {
      const _ = u.get(m, d), C = c.get(m, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), m = Math.floor(+c.getValue()), d = Math.floor(+l.getValue());
    if (f < 0 || f > 1 || m < 1 || m > 10 ** 10 || d < 1 || d > 10 ** 10)
      return g.create(h.NUM);
    const _ = cu(f, m, d);
    return Number.isNaN(_) || !Number.isFinite(_) ? g.create(h.NUM) : y.create(_);
  }
}
class sE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.mapValue((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = I(e);
    if (t)
      return r;
    const [s] = n, o = s.getValue();
    if (o <= -1 || o >= 1)
      return g.create(h.NUM);
    const u = Math.log((1 + o) / (1 - o)) / 2;
    return y.create(u);
  }
}
class aE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    return e.isArray() ? e.mapValue((t) => this._handleSingleObject(t)) : this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = I(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue(), u = Math.exp(2 * o) - 1, c = Math.exp(2 * o) + 1;
    return !Number.isFinite(u) && u > 0 && !Number.isFinite(c) && c > 0 ? y.create(1) : y.create(u / c);
  }
}
class zi extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = t.isArray() ? t.getRowCount() : 1, s = t.isArray() ? t.getColumnCount() : 1, o = r.isArray() ? r.getRowCount() : 1, u = r.isArray() ? r.getColumnCount() : 1;
    let c = t;
    t.isArray() && n === 1 && s === 1 && (c = t.get(0, 0));
    let l = r;
    return r.isArray() && o === 1 && u === 1 && (l = r.get(0, 0)), e.isArray() ? e.mapValue(
      (f) => this._handleSingleObject(f, c, l, n, s, o, u)
    ) : this._handleSingleObject(e, c, l, n, s, o, u);
  }
  _handleSingleObject(e, t, r, n, s, o, u) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    if (r.isError())
      return r;
    let c = e;
    if (e.isString() && (c = e.convertToNumberObjectValue()), c.isError())
      return c;
    const l = +c.getValue();
    if ((n * s === 1 || o * u === 1) && (t.isNull() || r.isNull()))
      return g.create(h.VALUE);
    if (n * s !== o * u)
      return g.create(h.NA);
    const {
      isError: f,
      errorObject: m,
      array1Values: d,
      array2Values: _,
      noCalculate: C
    } = st(
      t,
      r,
      n * s,
      s,
      u
    );
    if (f)
      return m;
    if (C)
      return g.create(h.DIV_BY_ZERO);
    const E = lu(l, d, _);
    return Number.isFinite(E) ? y.create(E) : g.create(h.DIV_BY_ZERO);
  }
}
class iE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, values: s } = this._getValues(e);
    if (r)
      return n;
    if (e.isNull() || t.isNull())
      return g.create(h.VALUE);
    let { values: o } = this._getValues(t, !0);
    o.length === 0 && (o = [0]);
    const u = this._getNewBinsArrayValues(o), c = new Array(u.length).fill(0);
    for (let l = 0; l < s.length; l++) {
      const f = s[l], m = u.findIndex((d) => f > d.start && f <= d.end);
      c[m]++;
    }
    return K.createByArray(c.map((l) => [l]));
  }
  _getValues(e, t = !1) {
    const r = [], n = e.isArray() ? e.getRowCount() : 1, s = e.isArray() ? e.getColumnCount() : 1;
    for (let o = 0; o < n; o++)
      for (let u = 0; u < s; u++) {
        const c = e.isArray() ? e.get(o, u) : e;
        if (c.isError()) {
          if (!t)
            return {
              isError: !0,
              errorObject: c,
              values: r
            };
          continue;
        }
        if (c.isNull() || c.isBoolean())
          continue;
        const l = c.getValue();
        q(l) && r.push(+l);
      }
    return {
      isError: !1,
      errorObject: null,
      values: r
    };
  }
  _getNewBinsArrayValues(e) {
    const t = e.map((n, s) => ({
      value: n,
      index: s
    })).sort((n, s) => n.value - s.value), r = [];
    for (let n = 0; n < t.length; n++) {
      const s = t[n].index;
      if (n === 0) {
        r[s] = {
          start: -1 / 0,
          end: t[n].value
        };
        continue;
      }
      r[s] = {
        start: t[n - 1].value,
        end: t[n].value
      };
    }
    return r.push({
      start: t[t.length - 1].value,
      end: 1 / 0
    }), r;
  }
}
class oE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = I(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue();
    if (o === 0 || o < 0 && o % 1 === 0)
      return g.create(h.NUM);
    const u = yn(o);
    return Number.isNaN(u) || !Number.isFinite(u) ? g.create(h.NUM) : y.create(u);
  }
}
class Ji extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = I(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue();
    if (o <= 0)
      return g.create(h.NUM);
    const u = dt(o);
    return Math.abs(u) < 1e-15 ? y.create(0) : y.create(u);
  }
}
class uE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = I(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue(), u = Jr(o, 0, 1) - 0.5;
    return y.create(u);
  }
}
class cE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = 1, r = 0, n = !1;
    for (let o = 0; o < e.length; o++) {
      const u = e[o];
      if (u.isArray()) {
        let c = !1, l = g.create(h.VALUE);
        if (u.iterator((f) => {
          if (f != null && f.isError())
            return c = !0, l = f, !1;
          if (f != null && f.isNull() || f != null && f.isBoolean())
            return !0;
          const m = f.getValue();
          if (!q(m))
            return !0;
          +m <= 0 && (n = !0), t *= +m, r++;
        }), c)
          return l;
      } else {
        if (u.isError())
          return u;
        if (u.isString()) {
          const l = u.convertToNumberObjectValue();
          if (l.isError())
            return l;
        }
        if (u.isNull() || u.isBoolean())
          continue;
        const c = u.getValue();
        if (!q(c))
          continue;
        +c <= 0 && (n = !0), t *= +c, r++;
      }
    }
    if (r === 0 || n)
      return g.create(h.NUM);
    const s = t ** (1 / r);
    return y.create(s);
  }
}
class lE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const { isError: s, errorObject: o } = hs(e, t, r);
    if (s)
      return o;
    const u = yt(e);
    if (u instanceof g)
      return u;
    const c = this._getKnownXsValues(u, t);
    if (c instanceof g)
      return c;
    const l = this._getNewXsValues(c, r);
    if (l instanceof g)
      return l;
    let f = n != null ? n : T.create(!0);
    if (f.isArray() && (f = f.get(0, 0)), f.isString() && (f = f.convertToNumberObjectValue()), f.isError())
      return f;
    const m = +f.getValue();
    return this._getResult(u, c, l, m);
  }
  _getResult(e, t, r, n) {
    return e.length === 1 && t.length > 1 || e[0].length === 1 && t[0].length > 1 ? e.length === 1 && t.length > 1 && (n ? t.length + 1 : t.length) > e[0].length || e[0].length === 1 && t[0].length > 1 && (n ? t[0].length + 1 : t[0].length) > e.length ? g.create(h.NA) : this._getResultByMultipleVariables(e, t, r, n) : this._getResultBySimpleVariables(e, t, r, n);
  }
  _getResultByMultipleVariables(e, t, r, n) {
    const s = e.length === 1 && e[0].length > 1, o = Cs(e, t, r, n, !0);
    if (o instanceof g)
      return o;
    const { coefficients: u, newX: c } = o, l = u[0].length, f = u[0][l - 1];
    let m = [];
    for (let d = 0; d < c.length; d++) {
      m[d] = [];
      let _ = f;
      for (let C = l - 2; C >= 0; C--)
        _ *= u[0][l - 2 - C] ** c[d][C];
      m[d].push(_);
    }
    return s && (m = Rt(m)), K.createByArray(m);
  }
  _getResultBySimpleVariables(e, t, r, n) {
    const s = e.flat(), o = t.flat(), { slope: u, intercept: c } = ds(o, s, n, !0), l = r.map((f) => f.map((m) => c * u ** m));
    return K.createByArray(l);
  }
  _getKnownXsValues(e, t) {
    return !t || t.isNull() ? gs(e.length, e[0].length) : yt(t);
  }
  _getNewXsValues(e, t) {
    return !t || t.isNull() ? e : yt(t);
  }
}
class fE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = 0, r = 0, n = !1;
    for (let o = 0; o < e.length; o++) {
      const u = e[o];
      if (u.isArray()) {
        let c = !1, l = g.create(h.VALUE);
        if (u.iterator((f) => {
          if (f != null && f.isError())
            return c = !0, l = f, !1;
          if (f != null && f.isNull() || f != null && f.isBoolean())
            return !0;
          const m = f.getValue();
          if (!q(m))
            return !0;
          +m <= 0 && (n = !0), t += 1 / +m, r++;
        }), c)
          return l;
      } else {
        if (u.isError())
          return u;
        if (u.isString()) {
          const l = u.convertToNumberObjectValue();
          if (l.isError())
            return l;
        }
        if (u.isNull() || u.isBoolean())
          continue;
        const c = u.getValue();
        if (!q(c))
          continue;
        +c <= 0 && (n = !0), t += 1 / +c, r++;
      }
    }
    if (r === 0)
      return g.create(h.NA);
    if (n)
      return g.create(h.NUM);
    const s = r / t;
    return y.create(s);
  }
}
class mE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 5);
    A(this, "maxParams", 5);
  }
  calculate(e, t, r, n, s) {
    const o = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, e, g.create(h.NA)), l = O(o, u, t, g.create(h.NA)), f = O(o, u, r, g.create(h.NA)), m = O(o, u, n, g.create(h.NA)), d = O(o, u, s, g.create(h.NA)), _ = c.mapValue((C, E, R) => {
      const b = l.get(E, R), p = f.get(E, R), V = m.get(E, R), S = d.get(E, R);
      return C.isError() ? C : b.isError() ? b : p.isError() ? p : V.isError() ? V : S.isError() ? S : this._handleSingleObject(C, b, p, V, S);
    });
    return o === 1 && u === 1 ? _.get(0, 0) : _;
  }
  _handleSingleObject(e, t, r, n, s) {
    const { isError: o, errorObject: u, variants: c } = I(e, t, r, n, s);
    if (o)
      return u;
    const [l, f, m, d, _] = c, C = Math.floor(+l.getValue()), E = Math.floor(+f.getValue()), R = Math.floor(+m.getValue()), b = Math.floor(+d.getValue()), p = +_.getValue();
    if (C < 0 || C > E || C > R || C < E - b + R || E <= 0 || E > b || R <= 0 || R > b || b <= 0)
      return g.create(h.NUM);
    let V;
    return p ? V = Jh(C, E, R, b) : V = Qa(C, E, R, b), Number.isNaN(V) && (V = 0), y.create(V);
  }
}
class hE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if (r * n === 1 || s * o === 1)
      return u.isNull() || c.isNull() ? g.create(h.VALUE) : g.create(h.DIV_BY_ZERO);
    if (r * n !== s * o)
      return g.create(h.NA);
    const {
      isError: l,
      errorObject: f,
      array1Values: m,
      array2Values: d,
      noCalculate: _
    } = st(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f : _ ? g.create(h.DIV_BY_ZERO) : this._getResult(m, d);
  }
  _getResult(e, t) {
    const r = lu(0, e, t);
    return Number.isFinite(r) ? y.create(r) : g.create(h.DIV_BY_ZERO);
  }
}
class gE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = [];
    let r = 0;
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      if (s.isError())
        return s;
      if (s.isString()) {
        const c = s.convertToNumberObjectValue();
        if (c.isError())
          return c;
      }
      const o = s.isArray() ? s.getRowCount() : 1, u = s.isArray() ? s.getColumnCount() : 1;
      for (let c = 0; c < o; c++)
        for (let l = 0; l < u; l++) {
          const f = s.isArray() ? s.get(c, l) : s;
          if (f.isError())
            return f;
          if (f.isNull() || f.isBoolean())
            continue;
          const m = f.getValue();
          q(m) && (t.push(+m), r += +m);
        }
    }
    return t.length <= 3 ? g.create(h.DIV_BY_ZERO) : this._getResult(t, r);
  }
  _getResult(e, t) {
    const r = e.length, n = t / r;
    let s = 0;
    for (let l = 0; l < r; l++)
      s += (e[l] - n) ** 2;
    const o = Math.sqrt(s / (r - 1));
    if (o === 0)
      return g.create(h.DIV_BY_ZERO);
    let u = 0;
    for (let l = 0; l < r; l++)
      u += ((e[l] - n) / o) ** 4;
    const c = r * (r + 1) / ((r - 1) * (r - 2) * (r - 3)) * u - 3 * (r - 1) ** 2 / ((r - 2) * (r - 3));
    return y.create(c);
  }
}
class dE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = mr(e);
    if (t.isArray()) {
      const n = t.mapValue((s) => this._handleSingleObject(r, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(r, t);
  }
  _handleSingleObject(e, t) {
    if (!Array.isArray(e))
      return e;
    const { isError: r, errorObject: n, variants: s } = I(t);
    if (r)
      return n;
    const [o] = s, u = +o.getValue();
    return bu(e, u);
  }
}
class CE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const { isError: s, errorObject: o } = hs(e, t);
    if (s)
      return o;
    const u = yt(e);
    if (u instanceof g)
      return u;
    const c = this._getKnownXsValues(u, t);
    if (c instanceof g)
      return c;
    let l = r != null ? r : T.create(!0);
    l.isArray() && (l = l.get(0, 0));
    let f = n != null ? n : T.create(!1);
    f.isArray() && (f = f.get(0, 0));
    const { isError: m, errorObject: d, variants: _ } = I(l, f);
    if (m)
      return d;
    const [C, E] = _;
    return this._getResult(u, c, +C.getValue(), +E.getValue());
  }
  _getResult(e, t, r, n) {
    return e.length === 1 && t.length > 1 || e[0].length === 1 && t[0].length > 1 ? e.length === 1 && t.length > 1 && (r ? t.length + 1 : t.length) > e[0].length || e[0].length === 1 && t[0].length > 1 && (r ? t[0].length + 1 : t[0].length) > e.length ? g.create(h.NA) : this._getResultByMultipleVariables(e, t, r, n) : this._getResultBySimpleVariables(e, t, r, n);
  }
  _getResultByMultipleVariables(e, t, r, n) {
    const s = Cs(e, t, t, r, !1);
    if (s instanceof g)
      return s;
    const { coefficients: o, X: u, XTXInverse: c } = s;
    let l = [];
    if (n) {
      const f = e.flat(), m = f.length, d = r ? f.reduce((j, k) => j + k, 0) / m : 0, _ = c.length, C = m - _, E = o[0].length, R = new Array(E - 2).fill(h.NA), b = o[0][E - 1], p = [];
      for (let j = 0; j < u.length; j++) {
        let k = b;
        for (let G = E - 2; G >= 0; G--)
          k += o[0][E - 2 - G] * u[j][G];
        p.push(k);
      }
      let V = 0, S = 0;
      for (let j = 0; j < m; j++)
        V += (f[j] - d) ** 2, S += (f[j] - p[j]) ** 2;
      const M = V - S, D = V === 0 ? 0 : M / V, w = [];
      for (let j = _ - 1; j >= 0; j--) {
        const k = C > 0 ? Math.sqrt(S / C * c[j][j]) : 0;
        w.push(k);
      }
      if (r) {
        const j = w.shift();
        w.push(j);
      } else
        w.push(h.NA);
      const L = C > 0 ? Math.sqrt(S / C) : 0, v = C > 0 ? M / (E - 1) / (S / C) : h.NUM;
      l = [
        o[0],
        // [mn, mn-1, ..., m1, b]
        [...w],
        // [sen, sen-1, ..., se1, seb]
        [D, L, ...R],
        // [r2, sey]
        [v, C, ...R],
        // [F, df]
        [M, S, ...R]
        // [ssreg, ssresid]
      ];
    } else
      l = [
        o[0]
        // [mn, mn-1, ..., m1, b]
      ];
    return K.createByArray(l);
  }
  _getResultBySimpleVariables(e, t, r, n) {
    const s = e.flat(), o = t.flat(), { slope: u, intercept: c } = ds(o, s, r, !1);
    if (Number.isNaN(u))
      return g.create(h.NA);
    let l = [];
    if (n) {
      const f = s.length;
      let m = 0, d = 0, _ = f - 1;
      if (r) {
        let w = 0, L = 0;
        for (let v = 0; v < f; v++)
          w += s[v], L += o[v];
        m = w / f, d = L / f, _ = f - 2;
      }
      let C = 0, E = 0, R = 0;
      for (let w = 0; w < f; w++)
        C += (s[w] - m) ** 2, E += (s[w] - (u * o[w] + c)) ** 2, R += (o[w] - d) ** 2;
      const b = C - E, p = b === C ? 1 : b / C;
      let V = 0, S = 0, M = 0;
      _ > 0 && (R > 0 && (V = Math.sqrt(E / _ / R), S = Math.sqrt(E / _ * (1 / f + d ** 2 / R))), M = Math.sqrt(E / _));
      const D = _ > 0 ? b / 1 / (E / _) : h.NUM;
      r || (S = h.NA), l = [
        [u, c],
        // [m, b]
        [V, S],
        // [se, seb]
        [p, M],
        // [r2, sey]
        [D, _],
        // [F, df]
        [b, E]
        // [ssreg, ssresid]
      ];
    } else
      l = [
        [u, c]
        // [m, b]
      ];
    return K.createByArray(l);
  }
  _getKnownXsValues(e, t) {
    return !t || t.isNull() ? gs(e.length, e[0].length) : yt(t);
  }
}
class _E extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const { isError: s, errorObject: o } = hs(e, t);
    if (s)
      return o;
    const u = yt(e);
    if (u instanceof g)
      return u;
    const c = this._getKnownXsValues(u, t);
    if (c instanceof g)
      return c;
    let l = r != null ? r : T.create(!0);
    l.isArray() && (l = l.get(0, 0));
    let f = n != null ? n : T.create(!1);
    f.isArray() && (f = f.get(0, 0));
    const { isError: m, errorObject: d, variants: _ } = I(l, f);
    if (m)
      return d;
    const [C, E] = _;
    return this._getResult(u, c, +C.getValue(), +E.getValue());
  }
  _getResult(e, t, r, n) {
    return e.length === 1 && t.length > 1 || e[0].length === 1 && t[0].length > 1 ? e.length === 1 && t.length > 1 && (r ? t.length + 1 : t.length) > e[0].length || e[0].length === 1 && t[0].length > 1 && (r ? t[0].length + 1 : t[0].length) > e.length ? g.create(h.NA) : this._getResultByMultipleVariables(e, t, r, n) : this._getResultBySimpleVariables(e, t, r, n);
  }
  // eslint-disable-next-line max-lines-per-function
  _getResultByMultipleVariables(e, t, r, n) {
    const s = Cs(e, t, t, r, !0);
    if (s instanceof g)
      return s;
    const { coefficients: o, Y: u, X: c, XTXInverse: l } = s;
    let f = [];
    if (n) {
      const m = u.flat(), d = m.length, _ = r ? m.reduce((k, G) => k + G, 0) / d : 0, C = l.length, E = d - C, R = o[0].length, b = new Array(R - 2).fill(h.NA), p = o[0][R - 1], V = [];
      for (let k = 0; k < c.length; k++) {
        let G = p;
        for (let ne = R - 2; ne >= 0; ne--)
          G *= o[0][R - 2 - ne] ** c[k][ne];
        V.push(Math.log(G));
      }
      let S = 0, M = 0;
      for (let k = 0; k < d; k++)
        S += (m[k] - _) ** 2, !(!r && !Number.isFinite(V[k])) && (M += (m[k] - V[k]) ** 2);
      Number.isFinite(M) || (M = 0);
      const D = S - M, w = S === 0 ? 0 : D / S, L = [];
      for (let k = C - 1; k >= 0; k--) {
        const G = E > 0 ? Math.sqrt(M / E * l[k][k]) : 0;
        L.push(G);
      }
      if (r) {
        const k = L.shift();
        L.push(k);
      } else
        L.push(h.NA);
      const v = E > 0 ? Math.sqrt(M / E) : 0, j = E > 0 ? D / (R - 1) / (M / E) : h.NUM;
      f = [
        o[0],
        // [mn, mn-1, ..., m1, b]
        [...L],
        // [sen, sen-1, ..., se1, seb]
        [w, v, ...b],
        // [r2, sey]
        [j, E, ...b],
        // [F, df]
        [D, M, ...b]
        // [ssreg, ssresid]
      ];
    } else
      f = [
        o[0]
        // [mn, mn-1, ..., m1, b]
      ];
    return K.createByArray(f);
  }
  _getResultBySimpleVariables(e, t, r, n) {
    const s = e.flat(), o = t.flat(), { slope: u, intercept: c, Y: l } = ds(o, s, r, !0);
    if (Number.isNaN(u))
      return g.create(h.NA);
    let f = [];
    if (n) {
      const m = l.length;
      let d = 0, _ = 0, C = m - 1;
      if (r) {
        let L = 0, v = 0;
        for (let j = 0; j < m; j++)
          L += l[j], v += o[j];
        d = L / m, _ = v / m, C = m - 2;
      }
      let E = 0, R = 0, b = 0;
      for (let L = 0; L < m; L++)
        E += (l[L] - d) ** 2, R += (l[L] - Math.log(c * u ** o[L])) ** 2, b += (o[L] - _) ** 2;
      const p = E - R, V = E === 0 ? 0 : p / E;
      let S = 0, M = 0, D = 0, w = 0;
      C > 0 && (b > 0 && (S = Math.sqrt(R / C / b), M = Math.sqrt(R / C * (1 / m + _ ** 2 / b))), D = Math.sqrt(R / C), w = p / 1 / (R / C)), r || (M = h.NA), f = [
        [u, c],
        // [m, b]
        [S, M],
        // [se, seb]
        [V, D],
        // [r2, sey]
        [w, C],
        // [F, df]
        [p, R]
        // [ssreg, ssresid]
      ];
    } else
      f = [
        [u, c]
        // [m, b]
      ];
    return K.createByArray(f);
  }
  _getKnownXsValues(e, t) {
    return !t || t.isNull() ? gs(e.length, e[0].length) : yt(t);
  }
}
class AE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(h.NA)), c = O(s, o, t, g.create(h.NA)), l = O(s, o, r, g.create(h.NA)), f = O(s, o, n, g.create(h.NA)), m = u.mapValue((d, _, C) => {
      const E = c.get(_, C), R = l.get(_, C), b = f.get(_, C);
      return d.isError() ? d : E.isError() ? E : R.isError() ? R : b.isError() ? b : this._handleSingleObject(d, E, R, b);
    });
    return s === 1 && o === 1 ? m.get(0, 0) : m;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = I(e, t, r, n);
    if (s)
      return o;
    const [c, l, f, m] = u, d = +c.getValue(), _ = +l.getValue(), C = +f.getValue(), E = +m.getValue();
    if (d <= 0 || C <= 0)
      return g.create(h.NUM);
    let R;
    return E ? R = mu(d, _, C) : R = eg(d, _, C), y.create(R);
  }
}
class EE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = this._getRangeValues(e);
    if (r instanceof g)
      return r;
    const n = rr(t);
    if (n.isError())
      return n;
    const { isError: s, errorObject: o, variants: u } = I(n);
    if (s)
      return o;
    const [c] = u, l = +c.getValue();
    if (l <= 0 || l >= 1)
      return g.create(h.NUM);
    if (r.length < 2)
      return g.create(h.DIV_BY_ZERO);
    const f = 1 - l, m = r.length, d = r.reduce((R, b) => R + b, 0) / m, _ = r.reduce((R, b) => R + (b - d) ** 2, 0) / (m - 1), C = Math.sqrt(_);
    if (C <= 0)
      return g.create(h.NUM);
    const E = Math.abs(ms(f / 2, m - 1) * C / Math.sqrt(m));
    return y.create(E);
  }
  _getRangeValues(e) {
    const t = [], r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1;
    for (let s = 0; s < r; s++)
      for (let o = 0; o < n; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        u.isNull() || u.isBoolean() || u.isString() || t.push(+u.getValue());
      }
    return t;
  }
}
class RE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y.create(Number.NEGATIVE_INFINITY);
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (!n.isNull()) {
        if ((n.isString() || n.isBoolean()) && (n = n.convertToNumberObjectValue()), n.isArray() && (n = n.max()), n.isError())
          return n;
        t = this._validator(t, n);
      }
    }
    return t.getValue() === Number.NEGATIVE_INFINITY ? y.create(0) : t;
  }
  _validator(e, t) {
    const r = e.isLessThan(t);
    let n = e;
    return r.getValue() && (n = t), n;
  }
}
class bE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y.create(Number.NEGATIVE_INFINITY);
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (!n.isNull()) {
        if ((n.isString() || n.isBoolean()) && (n = n.convertToNumberObjectValue()), n.isError())
          return n;
        if (n.isArray() && n.iterator((s) => {
          let o = s;
          if ((o == null || o.isNull() || o.isString()) && (o = y.create(0)), o.isBoolean() && (o = o.convertToNumberObjectValue()), o.isError())
            return t = o, !1;
          t = this._validator(t, o);
        }), t.isError())
          return t;
        t = this._validator(t, n);
      }
    }
    return t.getValue() === Number.NEGATIVE_INFINITY ? y.create(0) : t;
  }
  _validator(e, t) {
    const r = e.isLessThan(t);
    let n = e;
    return r.getValue() && (n = t), n;
  }
}
class yE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, ...t) {
    const {
      isError: r,
      errorObject: n,
      rangeIsDifferentSize: s,
      criteriaMaxRowLength: o,
      criteriaMaxColumnLength: u,
      targetRange: c,
      variants: l
    } = Kr(t, e);
    if (r)
      return n;
    if (s)
      return o === 1 && u === 1 ? g.create(h.VALUE) : O(o, u, g.create(h.VALUE));
    const f = Zr(l, o, u, !0);
    return this._aggregateResults(c, f);
  }
  _aggregateResults(e, t) {
    const r = t.map((n) => n.map((s) => {
      const o = e.pick(s);
      return o.getColumnCount() === 0 ? K.create("0") : o.max();
    }));
    return r.length === 1 && r[0].length === 1 ? r[0][0] : K.create({
      calculateValueList: r,
      rowCount: r.length,
      columnCount: r[0].length,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    });
  }
}
class pE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      if (n.isArray()) {
        let s = !1, o = g.create(h.VALUE);
        if (n.iterator((u) => {
          if (u != null && u.isError())
            return s = !0, o = u, !1;
          if (u != null && u.isNull() || u != null && u.isBoolean())
            return !0;
          const c = u.getValue();
          if (!q(c))
            return !0;
          t.push(+c);
        }), s)
          return o;
      } else {
        if (n.isError())
          return n;
        if (n.isNull() || n.isBoolean())
          continue;
        if (n.isString()) {
          const o = n.convertToNumberObjectValue();
          if (o.isError())
            return o;
        }
        const s = n.getValue();
        if (!q(s))
          continue;
        t.push(+s);
      }
    }
    return t.length === 0 ? g.create(h.NUM) : Ru(t);
  }
}
class NE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y.create(Number.POSITIVE_INFINITY);
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (!n.isNull()) {
        if ((n.isString() || n.isBoolean()) && (n = n.convertToNumberObjectValue()), n.isArray() && (n = n.min()), n.isError())
          return n;
        t = this._validator(t, n);
      }
    }
    return t.getValue() === Number.POSITIVE_INFINITY ? y.create(0) : t;
  }
  _validator(e, t) {
    const r = e.isGreaterThan(t);
    let n = e;
    return r.getValue() && (n = t), n;
  }
}
class VE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = y.create(Number.POSITIVE_INFINITY);
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (!n.isNull()) {
        if ((n.isString() || n.isBoolean()) && (n = n.convertToNumberObjectValue()), n.isError())
          return n;
        if (n.isArray() && n.iterator((s) => {
          let o = s;
          if ((o == null || o.isNull() || o.isString()) && (o = y.create(0)), o.isBoolean() && (o = o.convertToNumberObjectValue()), o.isError())
            return t = o, !1;
          t = this._validator(t, o);
        }), t.isError())
          return t;
        t = this._validator(t, n);
      }
    }
    return t.getValue() === Number.POSITIVE_INFINITY ? y.create(0) : t;
  }
  _validator(e, t) {
    const r = e.isGreaterThan(t);
    let n = e;
    return r.getValue() && (n = t), n;
  }
}
class OE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 255);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, ...t) {
    const {
      isError: r,
      errorObject: n,
      rangeIsDifferentSize: s,
      criteriaMaxRowLength: o,
      criteriaMaxColumnLength: u,
      targetRange: c,
      variants: l
    } = Kr(t, e);
    if (r)
      return n;
    if (s)
      return o === 1 && u === 1 ? g.create(h.VALUE) : O(o, u, g.create(h.VALUE));
    const f = Zr(l, o, u, !0);
    return this._aggregateResults(c, f);
  }
  _aggregateResults(e, t) {
    const r = t.map((n) => n.map((s) => {
      const o = e.pick(s);
      return o.getColumnCount() === 0 ? K.create("0") : o.min();
    }));
    return r.length === 1 && r[0].length === 1 ? r[0][0] : K.create({
      calculateValueList: r,
      rowCount: r.length,
      columnCount: r[0].length,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    });
  }
}
class SE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = {};
    let r = 0, n = 1;
    for (let s = 0; s < e.length; s++) {
      const o = e[s];
      if (o.isError())
        return o;
      if (o.isString()) {
        const l = o.convertToNumberObjectValue();
        if (l.isError())
          return l;
      }
      const u = o.isArray() ? o.getRowCount() : 1, c = o.isArray() ? o.getColumnCount() : 1;
      for (let l = 0; l < u; l++)
        for (let f = 0; f < c; f++) {
          const m = o.isArray() ? o.get(l, f) : o;
          if (m.isError())
            return m;
          if (m.isNull() || m.isBoolean() || m.isString())
            continue;
          const d = m.getValue();
          q(d) && (t[+d] ? (t[+d].count++, t[+d].count > n && (n = t[+d].count)) : t[+d] = { count: 1, order: r++ });
        }
    }
    return r === 0 || n === 1 ? new g(h.NA) : this._getResult(t, n);
  }
  _getResult(e, t) {
    const r = Object.entries(e).filter(([n, { count: s }]) => s === t).sort((n, s) => n[1].order - s[1].order).map(([n]) => +n);
    return r.length === 1 ? y.create(r[0]) : K.createByArray(r.map((n) => [n]));
  }
}
class ME extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(h.NA)), c = O(s, o, t, g.create(h.NA)), l = O(s, o, r, g.create(h.NA)), f = O(s, o, n, g.create(h.NA)), m = u.mapValue((d, _, C) => {
      const E = c.get(_, C), R = l.get(_, C), b = f.get(_, C);
      return d.isError() ? d : E.isError() ? E : R.isError() ? R : b.isError() ? b : this._handleSingleObject(d, E, R, b);
    });
    return s === 1 && o === 1 ? m.get(0, 0) : m;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = I(e, t, r, n);
    if (s)
      return o;
    const [c, l, f, m] = u, d = Math.floor(+c.getValue()), _ = Math.floor(+l.getValue()), C = +f.getValue(), E = +m.getValue();
    if (d < 0 || _ < 1 || C <= 0 || C >= 1)
      return g.create(h.NUM);
    let R;
    return E ? R = rg(d, _, C) : R = qa(d, _, C), y.create(R);
  }
}
class DE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(h.NA)), o = O(r, n, t, g.create(h.NA)), u = s.mapValue((c, l, f) => {
      const m = o.get(l, f);
      return c.isError() ? c : m.isError() ? m : this._handleSingleObject(c, m);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = I(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = +u.getValue();
    let f;
    return l ? f = Jr(c, 0, 1) : f = hu(c, 0, 1), y.create(f);
  }
}
class wE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if (r * n === 1 || s * o === 1)
      return u.isNull() || c.isNull() ? g.create(h.VALUE) : g.create(h.DIV_BY_ZERO);
    if (r * n !== s * o)
      return g.create(h.NA);
    const {
      isError: l,
      errorObject: f,
      array1Values: m,
      array2Values: d,
      noCalculate: _
    } = st(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f : _ ? g.create(h.DIV_BY_ZERO) : this._getResult(m, d);
  }
  _getResult(e, t) {
    const r = e.length;
    let n = 0, s = 0;
    for (let d = 0; d < r; d++)
      n += e[d], s += t[d];
    const o = n / r, u = s / r;
    let c = 0, l = 0, f = 0;
    for (let d = 0; d < r; d++)
      c += (e[d] - o) * (t[d] - u), l += (e[d] - o) ** 2, f += (t[d] - u) ** 2;
    if (l === 0 || f === 0)
      return g.create(h.DIV_BY_ZERO);
    const m = c / Math.sqrt(l * f);
    return y.create(m);
  }
}
class LE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = mr(e);
    if (t.isArray()) {
      const n = t.mapValue((s) => this._handleSingleObject(r, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(r, t);
  }
  _handleSingleObject(e, t) {
    if (!Array.isArray(e))
      return e;
    const { isError: r, errorObject: n, variants: s } = I(t);
    if (r)
      return n;
    const [o] = s, u = +o.getValue();
    return Nu(e, u);
  }
}
class PE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = this._getValues(e);
    let s = r != null ? r : y.create(3);
    s.isNull() && (s = y.create(3));
    const o = Math.max(
      t.isArray() ? t.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      t.isArray() ? t.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, t, g.create(h.NA)), l = O(o, u, s, g.create(h.NA)), f = c.mapValue((m, d, _) => {
      const C = l.get(d, _);
      return m.isError() ? m : C.isError() ? C : this._handleSingleObject(n, m, C);
    });
    return o === 1 && u === 1 ? f.get(0, 0) : f;
  }
  _handleSingleObject(e, t, r) {
    if (e instanceof g)
      return e;
    const { isError: n, errorObject: s, variants: o } = I(t, r);
    if (n)
      return s;
    const [u, c] = o, l = +u.getValue(), f = Math.floor(+c.getValue()), m = e.length;
    if (m === 0 || l < e[0] || l > e[m - 1])
      return g.create(h.NA);
    if (m === 1)
      return l === e[0] ? y.create(1) : g.create(h.NA);
    let d = 0, _ = !1, C = 0;
    for (; !_ && C < m; )
      l === e[C] ? (d = (C + 1) / (m + 1), _ = !0) : l > e[C] && C + 1 < m && l < e[C + 1] && (d = (C + 1 + (l - e[C]) / (e[C + 1] - e[C])) / (m + 1), _ = !0), C++;
    return _ ? f < 1 ? g.create(h.NUM) : (d = Ze(d, f), y.create(d)) : g.create(h.NA);
  }
  _getValues(e) {
    const t = e.isArray() ? e.getRowCount() : 1, r = e.isArray() ? e.getColumnCount() : 1, n = [];
    for (let s = 0; s < t; s++)
      for (let o = 0; o < r; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        if (u.isNull() || u.isBoolean())
          continue;
        const c = u.getValue();
        q(c) && n.push(+c);
      }
    return n.sort((s, o) => s - o);
  }
}
class xE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(h.NA)), o = O(r, n, t, g.create(h.NA)), u = s.mapValue((c, l, f) => {
      const m = o.get(l, f);
      if (c.isError())
        return c;
      if (m.isError())
        return m;
      const { isError: d, errorObject: _, variants: C } = I(c, m);
      if (d)
        return _;
      const [E, R] = C, b = Math.floor(+E.getValue()), p = Math.floor(+R.getValue());
      if (b < 0 || b >= 2147483647 || p < 0 || b < p)
        return g.create(h.NUM);
      let V = 1;
      for (let S = b - p + 1; S <= b; S++)
        V *= S;
      return Number.isFinite(V) ? y.create(V) : g.create(h.NUM);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
}
class jE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(h.NA)), o = O(r, n, t, g.create(h.NA)), u = s.mapValue((c, l, f) => {
      const m = o.get(l, f);
      if (c.isError())
        return c;
      if (m.isError())
        return m;
      const { isError: d, errorObject: _, variants: C } = I(c, m);
      if (d)
        return _;
      const [E, R] = C, b = Math.floor(+E.getValue()), p = Math.floor(+R.getValue());
      if (b < 0 || b >= 2147483647 || p < 0)
        return g.create(h.NUM);
      if (b === 0)
        return p === 0 ? y.create(1) : y.create(0);
      const V = b ** p;
      return Number.isFinite(V) ? y.create(V) : g.create(h.NUM);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
}
class UE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = I(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue(), u = Math.exp(-0.5 * o * o) / Math.sqrt(2 * Math.PI);
    return y.create(u);
  }
}
class vE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const { isError: s, errorObject: o, xRangeValues: u, probRangeValues: c } = this._handleXRangeAndProbRange(e, t);
    let l = n != null ? n : r;
    n != null && n.isNull() && (l = r);
    const f = Math.max(
      r.isArray() ? r.getRowCount() : 1,
      l.isArray() ? l.getRowCount() : 1
    ), m = Math.max(
      r.isArray() ? r.getColumnCount() : 1,
      l.isArray() ? l.getColumnCount() : 1
    ), d = O(f, m, r, g.create(h.NA)), _ = O(f, m, l, g.create(h.NA)), C = d.mapValue((E, R, b) => {
      const p = _.get(R, b);
      return e.isError() ? e : t.isError() ? t : E.isError() ? E : p.isError() ? p : s ? o : this._handleSingleObject(u, c, E, p);
    });
    return f === 1 && m === 1 ? C.get(0, 0) : C;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = I(r, n);
    if (s)
      return o;
    const [c, l] = u, f = +c.getValue(), m = +l.getValue();
    if (t.reduce((_, C) => _ + C, 0) !== 1)
      return g.create(h.NUM);
    let d = 0;
    for (let _ = 0; _ < e.length; _++)
      e[_] >= f && e[_] <= m && (d += t[_]);
    return y.create(d);
  }
  // eslint-disable-next-line
  _handleXRangeAndProbRange(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return {
        isError: !0,
        errorObject: u,
        xRangeValues: [],
        probRangeValues: []
      };
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return {
        isError: !0,
        errorObject: c,
        xRangeValues: [],
        probRangeValues: []
      };
    if ((r * n === 1 || s * o === 1) && (u.isNull() || c.isNull()))
      return {
        isError: !0,
        errorObject: g.create(h.VALUE),
        xRangeValues: [],
        probRangeValues: []
      };
    if (r * n !== s * o)
      return {
        isError: !0,
        errorObject: g.create(h.NA),
        xRangeValues: [],
        probRangeValues: []
      };
    const {
      isError: l,
      errorObject: f,
      array1Values: m,
      array2Values: d,
      noCalculate: _
    } = st(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? {
      isError: !0,
      errorObject: f,
      xRangeValues: [],
      probRangeValues: []
    } : _ ? {
      isError: !0,
      errorObject: g.create(h.DIV_BY_ZERO),
      xRangeValues: [],
      probRangeValues: []
    } : {
      isError: !1,
      errorObject: null,
      xRangeValues: m,
      probRangeValues: d
    };
  }
}
class TE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = mr(e);
    if (t.isArray()) {
      const n = t.mapValue((s) => this._handleSingleObject(r, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(r, t);
  }
  _handleSingleObject(e, t) {
    if (!Array.isArray(e))
      return e;
    const { isError: r, errorObject: n, variants: s } = I(t);
    if (r)
      return n;
    const [o] = s, u = Math.floor(+o.getValue());
    return Ou(e, u);
  }
}
class IE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, t, r) {
    let n = e;
    n.isReferenceObject() && (n = n.toArrayValueObject());
    const { refHasError: s, refErrorObject: o, refNumbers: u } = this._checkRefReferenceObject(t);
    let c = r != null ? r : y.create(0);
    c.isReferenceObject() && (c = c.toArrayValueObject());
    const l = Math.max(
      n.isArray() ? n.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f = Math.max(
      n.isArray() ? n.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), m = O(l, f, n, g.create(h.NA)), d = O(l, f, c, g.create(h.NA)), _ = m.map((C, E, R) => {
      const b = d.get(E, R);
      if (!e.isReferenceObject() && e.isNull())
        return g.create(h.NA);
      if (s)
        return o;
      if (b.isError())
        return b;
      const p = +C.getValue(), V = +b.getValue();
      return Number.isNaN(p) || Number.isNaN(V) ? g.create(h.VALUE) : this._getResult(p, V, u);
    });
    return l === 1 && f === 1 ? _.get(0, 0) : _;
  }
  _getResult(e, t, r) {
    const n = r.sort((c, l) => t ? c - l : l - c);
    let s = n.indexOf(e);
    const o = [];
    for (; s >= 0; ) {
      const c = s + 1;
      o.push(c), s = n.indexOf(e, c);
    }
    if (o.length === 0)
      return g.create(h.NA);
    const u = o.reduce((c, l) => c + l, 0) / o.length;
    return y.create(u);
  }
  _checkRefReferenceObject(e) {
    let t = !1, r = g.create(h.NA);
    const n = [];
    return e.isReferenceObject() ? (e.toArrayValueObject().iterator((o) => {
      const u = o;
      if (u.isError())
        return t = !0, r = u, !1;
      if (u.isNull() || u.isBoolean())
        return !0;
      const c = +u.getValue();
      if (Number.isNaN(c))
        return !0;
      n.push(c);
    }), {
      refHasError: t,
      refErrorObject: r,
      refNumbers: n
    }) : {
      refHasError: !0,
      refErrorObject: r,
      refNumbers: n
    };
  }
}
class BE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e, t, r) {
    let n = e;
    n.isReferenceObject() && (n = n.toArrayValueObject());
    const { refHasError: s, refErrorObject: o, refNumbers: u } = this._checkRefReferenceObject(t);
    let c = r != null ? r : y.create(0);
    c.isReferenceObject() && (c = c.toArrayValueObject());
    const l = Math.max(
      n.isArray() ? n.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1
    ), f = Math.max(
      n.isArray() ? n.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1
    ), m = O(l, f, n, g.create(h.NA)), d = O(l, f, c, g.create(h.NA)), _ = m.map((C, E, R) => {
      const b = d.get(E, R);
      if (!e.isReferenceObject() && e.isNull())
        return g.create(h.NA);
      if (s)
        return o;
      if (b.isError())
        return b;
      const p = +C.getValue(), V = +b.getValue();
      if (Number.isNaN(p) || Number.isNaN(V))
        return g.create(h.VALUE);
      const M = u.sort((D, w) => V ? D - w : w - D).indexOf(p);
      return M === -1 ? g.create(h.NA) : y.create(M + 1);
    });
    return l === 1 && f === 1 ? _.get(0, 0) : _;
  }
  _checkRefReferenceObject(e) {
    let t = !1, r = g.create(h.NA);
    const n = [];
    return e.isReferenceObject() ? (e.toArrayValueObject().iterator((o) => {
      const u = o;
      if (u.isError())
        return t = !0, r = u, !1;
      if (u.isNull() || u.isBoolean())
        return !0;
      const c = +u.getValue();
      if (Number.isNaN(c))
        return !0;
      n.push(c);
    }), {
      refHasError: t,
      refErrorObject: r,
      refNumbers: n
    }) : {
      refHasError: !0,
      refErrorObject: r,
      refNumbers: n
    };
  }
}
class FE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if ((r * n === 1 || s * o === 1) && (u.isNull() || c.isNull()))
      return g.create(h.VALUE);
    if (r * n !== s * o)
      return g.create(h.NA);
    const {
      isError: l,
      errorObject: f,
      array1Values: m,
      array2Values: d,
      noCalculate: _
    } = st(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f : _ ? g.create(h.DIV_BY_ZERO) : this._getResult(m, d);
  }
  _getResult(e, t) {
    if (e.length === 0)
      return g.create(h.DIV_BY_ZERO);
    const r = e.length;
    let n = 0, s = 0;
    for (let d = 0; d < r; d++)
      n += e[d], s += t[d];
    const o = n / r, u = s / r;
    let c = 0, l = 0, f = 0;
    for (let d = 0; d < r; d++)
      c += (e[d] - o) * (t[d] - u), l += (e[d] - o) ** 2, f += (t[d] - u) ** 2;
    if (l === 0 || f === 0)
      return g.create(h.DIV_BY_ZERO);
    const m = (c / Math.sqrt(l * f)) ** 2;
    return y.create(m);
  }
}
class kE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = [];
    let r = 0;
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      if (s.isError())
        return s;
      if (s.isString()) {
        const c = s.convertToNumberObjectValue();
        if (c.isError())
          return c;
      }
      const o = s.isArray() ? s.getRowCount() : 1, u = s.isArray() ? s.getColumnCount() : 1;
      for (let c = 0; c < o; c++)
        for (let l = 0; l < u; l++) {
          const f = s.isArray() ? s.get(c, l) : s;
          if (f.isError())
            return f;
          if (f.isNull() || f.isBoolean())
            continue;
          const m = f.getValue();
          q(m) && (t.push(+m), r += +m);
        }
    }
    return t.length <= 2 ? g.create(h.DIV_BY_ZERO) : this._getResult(t, r);
  }
  _getResult(e, t) {
    const r = e.length, n = t / r;
    let s = 0;
    for (let l = 0; l < r; l++)
      s += (e[l] - n) ** 2;
    const o = Math.sqrt(s / (r - 1));
    if (o === 0)
      return g.create(h.DIV_BY_ZERO);
    let u = 0;
    for (let l = 0; l < r; l++)
      u += ((e[l] - n) / o) ** 3;
    const c = r / ((r - 1) * (r - 2)) * u;
    return y.create(c);
  }
}
class $E extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = [];
    let r = 0;
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      if (s.isError())
        return s;
      if (s.isString()) {
        const c = s.convertToNumberObjectValue();
        if (c.isError())
          return c;
      }
      const o = s.isArray() ? s.getRowCount() : 1, u = s.isArray() ? s.getColumnCount() : 1;
      for (let c = 0; c < o; c++)
        for (let l = 0; l < u; l++) {
          const f = s.isArray() ? s.get(c, l) : s;
          if (f.isError())
            return f;
          if (f.isNull() || f.isBoolean())
            continue;
          const m = f.getValue();
          q(m) && (t.push(+m), r += +m);
        }
    }
    return t.length <= 2 ? g.create(h.DIV_BY_ZERO) : this._getResult(t, r);
  }
  _getResult(e, t) {
    const r = e.length, n = t / r;
    let s = 0;
    for (let l = 0; l < r; l++)
      s += (e[l] - n) ** 2;
    const o = Math.sqrt(s / r);
    if (o === 0)
      return g.create(h.DIV_BY_ZERO);
    let u = 0;
    for (let l = 0; l < r; l++)
      u += ((e[l] - n) / o) ** 3;
    const c = u / r;
    return y.create(c);
  }
}
class YE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if (r * n === 1 || s * o === 1)
      return u.isNull() || c.isNull() ? g.create(h.VALUE) : g.create(h.DIV_BY_ZERO);
    if (r * n !== s * o)
      return g.create(h.NA);
    const {
      isError: l,
      errorObject: f,
      array1Values: m,
      array2Values: d,
      noCalculate: _
    } = st(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f : _ ? g.create(h.DIV_BY_ZERO) : this._getResult(m, d);
  }
  _getResult(e, t) {
    const r = e.length;
    let n = 0, s = 0;
    for (let m = 0; m < r; m++)
      n += e[m], s += t[m];
    const o = n / r, u = s / r;
    let c = 0, l = 0;
    for (let m = 0; m < r; m++)
      c += (e[m] - o) * (t[m] - u), l += (t[m] - u) ** 2;
    if (l === 0)
      return g.create(h.DIV_BY_ZERO);
    const f = c / l;
    return y.create(f);
  }
}
class HE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = mr(e);
    if (t.isArray()) {
      const n = t.mapValue((s) => this._handleSingleObject(r, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(r, t);
  }
  _handleSingleObject(e, t) {
    if (!Array.isArray(e))
      return e;
    const { isError: r, errorObject: n, variants: s } = I(t);
    if (r)
      return n;
    const [o] = s, u = +o.getValue();
    return yu(e, u);
  }
}
class GE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, t, g.create(h.NA)), c = O(n, s, r, g.create(h.NA)), l = o.mapValue((f, m, d) => {
      const _ = u.get(m, d), C = c.get(m, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), m = +c.getValue(), d = +l.getValue();
    if (d <= 0)
      return g.create(h.NUM);
    const _ = (f - m) / d;
    return y.create(_);
  }
}
class WE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = this.flattenArray(e, !1);
    return t.isError() ? t : t.std(1);
  }
}
class QE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = this.flattenArray(e, !1);
    return t.isError() ? t : t.std();
  }
}
class qE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1, s = t.isArray() ? t.getRowCount() : 1, o = t.isArray() ? t.getColumnCount() : 1;
    let u = e;
    if (e.isArray() && r === 1 && n === 1 && (u = e.get(0, 0)), u.isError())
      return u;
    let c = t;
    if (t.isArray() && s === 1 && o === 1 && (c = t.get(0, 0)), c.isError())
      return c;
    if ((r * n === 1 || s * o === 1) && (u.isNull() || c.isNull()))
      return g.create(h.VALUE);
    if (r * n !== s * o)
      return g.create(h.NA);
    const {
      isError: l,
      errorObject: f,
      array1Values: m,
      array2Values: d,
      noCalculate: _
    } = st(
      e,
      t,
      r * n,
      n,
      o
    );
    return l ? f : _ ? g.create(h.DIV_BY_ZERO) : this._getResult(m, d);
  }
  _getResult(e, t) {
    const r = e.length;
    if (r <= 2)
      return g.create(h.DIV_BY_ZERO);
    let n = 0, s = 0;
    for (let d = 0; d < r; d++)
      n += e[d], s += t[d];
    const o = n / r, u = s / r;
    let c = 0, l = 0, f = 0;
    for (let d = 0; d < r; d++)
      c += (e[d] - o) * (t[d] - u), l += (e[d] - o) ** 2, f += (t[d] - u) ** 2;
    if (f === 0)
      return g.create(h.DIV_BY_ZERO);
    const m = Math.sqrt((l - c ** 2 / f) / (r - 2));
    return Number.isNaN(m) || !Number.isFinite(m) ? g.create(h.NUM) : y.create(m);
  }
}
class XE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, t, g.create(h.NA)), c = O(n, s, r, g.create(h.NA)), l = o.mapValue((f, m, d) => {
      const _ = u.get(m, d), C = c.get(m, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o, f = +u.getValue(), m = Math.floor(+c.getValue()), d = +l.getValue();
    if (m < 1)
      return g.create(h.NUM);
    let _;
    return d ? _ = en(f, m) : _ = sg(f, m), Number.isNaN(_) || !Number.isFinite(_) ? g.create(h.NUM) : y.create(_);
  }
}
class KE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(h.NA)), o = O(r, n, t, g.create(h.NA)), u = s.mapValue((c, l, f) => {
      const m = o.get(l, f);
      return c.isError() ? c : m.isError() ? m : this._handleSingleObject(c, m);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = I(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (c < 0 || l < 1 || l > 10 ** 10)
      return g.create(h.NUM);
    const f = en(-c, l) * 2;
    return Number.isNaN(f) || !Number.isFinite(f) ? g.create(h.NUM) : y.create(f);
  }
}
class ZE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(h.NA)), o = O(r, n, t, g.create(h.NA)), u = s.mapValue((c, l, f) => {
      const m = o.get(l, f);
      return c.isError() ? c : m.isError() ? m : this._handleSingleObject(c, m);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = I(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (l < 1 || l > 10 ** 10)
      return g.create(h.NUM);
    const f = en(-c, l);
    return Number.isNaN(f) || !Number.isFinite(f) ? g.create(h.NUM) : y.create(f);
  }
}
class zE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(h.NA)), o = O(r, n, t, g.create(h.NA)), u = s.mapValue((c, l, f) => {
      const m = o.get(l, f);
      return c.isError() ? c : m.isError() ? m : this._handleSingleObject(c, m);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = I(e, t);
    if (r)
      return n;
    const [o, u] = s, c = +o.getValue(), l = Math.floor(+u.getValue());
    if (c <= 0 || c > 1 || l < 1 || l > 10 ** 10)
      return g.create(h.NUM);
    const f = ms(c, l);
    return Number.isNaN(f) || !Number.isFinite(f) ? g.create(h.NUM) : y.create(f);
  }
}
class JE extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const { isError: s, errorObject: o } = hs(e, t, r);
    if (s)
      return o;
    const u = yt(e);
    if (u instanceof g)
      return u;
    const c = this._getKnownXsValues(u, t);
    if (c instanceof g)
      return c;
    const l = this._getNewXsValues(c, r);
    if (l instanceof g)
      return l;
    let f = n != null ? n : T.create(!0);
    if (f.isArray() && (f = f.get(0, 0)), f.isString() && (f = f.convertToNumberObjectValue()), f.isError())
      return f;
    const m = +f.getValue();
    return this._getResult(u, c, l, m);
  }
  _getResult(e, t, r, n) {
    return e.length === 1 && t.length > 1 || e[0].length === 1 && t[0].length > 1 ? e.length === 1 && t.length > 1 && (n ? t.length + 1 : t.length) > e[0].length || e[0].length === 1 && t[0].length > 1 && (n ? t[0].length + 1 : t[0].length) > e.length ? g.create(h.NA) : this._getResultByMultipleVariables(e, t, r, n) : this._getResultBySimpleVariables(e, t, r, n);
  }
  _getResultByMultipleVariables(e, t, r, n) {
    const s = e.length === 1 && e[0].length > 1, o = Cs(e, t, r, n, !1);
    if (o instanceof g)
      return o;
    const { coefficients: u, newX: c } = o, l = u[0].length, f = u[0][l - 1];
    let m = [];
    for (let d = 0; d < c.length; d++) {
      m[d] = [];
      let _ = f;
      for (let C = l - 2; C >= 0; C--)
        _ += u[0][l - 2 - C] * c[d][C];
      m[d].push(_);
    }
    return s && (m = Rt(m)), K.createByArray(m);
  }
  _getResultBySimpleVariables(e, t, r, n) {
    const s = e.flat(), o = t.flat(), { slope: u, intercept: c } = ds(o, s, n, !1);
    if (Number.isNaN(u))
      return g.create(h.NA);
    const l = r.map((f) => f.map((m) => u * m + c));
    return K.createByArray(l);
  }
  _getKnownXsValues(e, t) {
    return !t || t.isNull() ? gs(e.length, e[0].length) : yt(t);
  }
  _getNewXsValues(e, t) {
    return !t || t.isNull() ? e : yt(t);
  }
}
class eR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = this._getValues(e);
    if (t.isArray()) {
      const n = t.mapValue((s) => this._handleSingleObject(r, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(r, t);
  }
  _handleSingleObject(e, t) {
    if (e instanceof g)
      return e;
    const { isError: r, errorObject: n, variants: s } = I(t);
    if (r)
      return n;
    const [o] = s, u = +o.getValue();
    if (u < 0 || u >= 1)
      return g.create(h.NUM);
    const c = Ze(e.length * u / 2, 0) * 2, l = e.slice(c / 2, e.length - c / 2), f = l.reduce((m, d) => m + d, 0) / l.length;
    return y.create(f);
  }
  _getValues(e) {
    const t = e.isArray() ? e.getRowCount() : 1, r = e.isArray() ? e.getColumnCount() : 1, n = [];
    for (let s = 0; s < t; s++)
      for (let o = 0; o < r; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        if (u.isNull() || u.isBoolean())
          continue;
        const c = u.getValue();
        q(c) && n.push(+c);
      }
    return n.length === 0 ? g.create(h.NUM) : n.sort((s, o) => s - o);
  }
}
class tR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = this.flattenArray(e, !1);
    return t.isError() ? t : t.var(1);
  }
}
class rR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    const t = this.flattenArray(e, !1);
    return t.isError() ? t : t.var();
  }
}
const nR = [
  [UA, P.AVEDEV],
  [TA, P.AVERAGE],
  [IA, P.AVERAGE_WEIGHTED],
  [BA, P.AVERAGEA],
  [FA, P.AVERAGEIF],
  [kA, P.AVERAGEIFS],
  [$A, P.BETA_DIST],
  [Su, P.BETA_INV],
  [Mu, P.BINOM_DIST],
  [YA, P.BINOM_DIST_RANGE],
  [Du, P.BINOM_INV],
  [HA, P.CHISQ_DIST],
  [wu, P.CHISQ_DIST_RT],
  [GA, P.CHISQ_INV],
  [Lu, P.CHISQ_INV_RT],
  [Pu, P.CHISQ_TEST],
  [xu, P.CONFIDENCE_NORM],
  [WA, P.CONFIDENCE_T],
  [QA, P.CORREL],
  [qA, P.COUNT],
  [XA, P.COUNTA],
  [KA, P.COUNTBLANK],
  [ZA, P.COUNTIF],
  [zA, P.COUNTIFS],
  [ju, P.COVARIANCE_P],
  [eE, P.COVARIANCE_S],
  [tE, P.DEVSQ],
  [Uu, P.EXPON_DIST],
  [rE, P.F_DIST],
  [vu, P.F_DIST_RT],
  [nE, P.F_INV],
  [Tu, P.F_INV_RT],
  [Iu, P.F_TEST],
  [sE, P.FISHER],
  [aE, P.FISHERINV],
  [zi, P.FORECAST],
  [zi, P.FORECAST_LINEAR],
  [iE, P.FREQUENCY],
  [oE, P.GAMMA],
  [Bu, P.GAMMA_DIST],
  [Fu, P.GAMMA_INV],
  [Ji, P.GAMMALN],
  [Ji, P.GAMMALN_PRECISE],
  [uE, P.GAUSS],
  [cE, P.GEOMEAN],
  [lE, P.GROWTH],
  [fE, P.HARMEAN],
  [mE, P.HYPGEOM_DIST],
  [hE, P.INTERCEPT],
  [gE, P.KURT],
  [dE, P.LARGE],
  [CE, P.LINEST],
  [_E, P.LOGEST],
  [AE, P.LOGNORM_DIST],
  [ku, P.LOGNORM_INV],
  [EE, P.MARGINOFERROR],
  [RE, P.MAX],
  [bE, P.MAXA],
  [yE, P.MAXIFS],
  [pE, P.MEDIAN],
  [NE, P.MIN],
  [VE, P.MINA],
  [OE, P.MINIFS],
  [SE, P.MODE_MULT],
  [$u, P.MODE_SNGL],
  [ME, P.NEGBINOM_DIST],
  [Yu, P.NORM_DIST],
  [Hu, P.NORM_INV],
  [DE, P.NORM_S_DIST],
  [Gu, P.NORM_S_INV],
  [wE, P.PEARSON],
  [LE, P.PERCENTILE_EXC],
  [Wu, P.PERCENTILE_INC],
  [PE, P.PERCENTRANK_EXC],
  [Qu, P.PERCENTRANK_INC],
  [xE, P.PERMUT],
  [jE, P.PERMUTATIONA],
  [UE, P.PHI],
  [qu, P.POISSON_DIST],
  [vE, P.PROB],
  [TE, P.QUARTILE_EXC],
  [Xu, P.QUARTILE_INC],
  [IE, P.RANK_AVG],
  [BE, P.RANK_EQ],
  [FE, P.RSQ],
  [kE, P.SKEW],
  [$E, P.SKEW_P],
  [YE, P.SLOPE],
  [HE, P.SMALL],
  [GE, P.STANDARDIZE],
  [Ku, P.STDEV_P],
  [Zu, P.STDEV_S],
  [WE, P.STDEVA],
  [QE, P.STDEVPA],
  [qE, P.STEYX],
  [XE, P.T_DIST],
  [KE, P.T_DIST_2T],
  [ZE, P.T_DIST_RT],
  [zE, P.T_INV],
  [zu, P.T_INV_2T],
  [Ju, P.T_TEST],
  [JE, P.TREND],
  [eR, P.TRIMMEAN],
  [ec, P.VAR_P],
  [tc, P.VAR_S],
  [tR, P.VARA],
  [rR, P.VARPA],
  [rc, P.WEIBULL_DIST],
  [nc, P.Z_TEST]
];
class sR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    let r = t != null ? t : y.create(0);
    if (t != null && t.isNull() && (r = y.create(0)), r.isArray()) {
      const n = r.mapValue((s) => this._handleSingleObject(e, s));
      return n.getRowCount() === 1 && n.getColumnCount() === 1 ? n.get(0, 0) : n;
    }
    return this._handleSingleObject(e, r);
  }
  _handleSingleObject(e, t) {
    const r = this._checkArray(e);
    if (r.isError())
      return r;
    const { isError: n, errorObject: s, variants: o } = I(t);
    if (n)
      return s;
    const [u] = o, c = +u.getValue(), l = e.isArray() ? e.getRowCount() : 1, f = e.isArray() ? e.getColumnCount() : 1;
    let m = "";
    for (let d = 0; d < l; d++)
      for (let _ = 0; _ < f; _++) {
        const C = e.isArray() ? e.get(d, _) : e;
        let E = `${C.getValue()}`;
        C.isNull() && (E = ""), C.isBoolean() && (E = E.toLocaleUpperCase()), C.isString() && c ? m += `"${E}"` : m += E, d === l - 1 && _ === f - 1 || (c ? _ === f - 1 ? m += ";" : m += "," : m += ", ");
      }
    return c && (m = `{${m}}`), m.length > 32767 ? g.create(h.CALC) : U.create(m);
  }
  _checkArray(e) {
    if (e.isArray()) {
      const t = e.getRowCount(), r = e.getColumnCount();
      return t > 1 || r > 1 ? e : e.get(0, 0);
    }
    return e;
  }
}
class aR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError() || e.isNull() || e.isBoolean() || e.isNumber())
      return e;
    const t = e.getValue().toLocaleString();
    let r = "";
    for (let n = 0; n < t.length; n++) {
      let s = t.charCodeAt(n);
      s === 12288 ? s = 32 : s >= 65281 && s <= 65374 && (s -= 65248), r += String.fromCharCode(s);
    }
    return U.create(r);
  }
}
class iR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = I(e);
    if (t)
      return r;
    const [s] = n, o = +s.getValue(), u = Math.abs(Number.parseInt(o.toString(), 10)), c = Number.parseFloat((Math.abs(o) - u).toFixed(2));
    let l = "";
    return u === 0 ? c !== 0 ? l = `${o < 0 ? "ลบ" : ""}${this._convertNumberToThaiText(c * 100)}สตางค์` : l = "ศูนย์บาทถ้วน" : c === 0 ? l = `${o < 0 ? "ลบ" : ""}${this._convertNumberToThaiText(u)}บาทถ้วน` : l = `${o < 0 ? "ลบ" : ""}${this._convertNumberToThaiText(u)}บาท${this._convertNumberToThaiText(c * 100)}สตางค์`, U.create(l);
  }
  _convertNumberToThaiText(e) {
    const t = ["ล้าน", "สิบ", "ร้อย", "พัน", "หมื่น", "แสน", ""], r = ["ศูนย์", "หนึ่ง", "สอง", "สาม", "สี่", "ห้า", "หก", "เจ็ด", "แปด", "เก้า"], n = ["ลบ", "บาท", "ถ้วน", "สตางค์", "ยี่", "เอ็ด", ",", " ", "฿"], s = e.toString(), o = s.length;
    let u = "";
    for (let c = o; c > 0; c--) {
      const l = Number.parseInt(s.charAt(o - c), 10);
      let f = r[l];
      const m = c > 1 ? (c - 1) % 6 : 6;
      if (m === 1 && l === 2 && (f = n[4]), l === 1)
        switch (m) {
          case 0:
          case 6:
            u += c < o ? n[5] : f;
            break;
          case 1:
            break;
          default:
            u += f;
            break;
        }
      else if (l === 0) {
        m === 0 && (u += t[m]);
        continue;
      } else
        u += f;
      u += t[m];
    }
    return u;
  }
}
const oR = Object.values(Fe).filter((a) => [
  Fe.TABLE_START,
  Fe.TABLE_ROW_START,
  Fe.TABLE_CELL_START,
  Fe.TABLE_CELL_END,
  Fe.TABLE_ROW_END,
  Fe.TABLE_END,
  Fe.CUSTOM_BLOCK
].includes(a));
class uR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = I(e);
    if (t)
      return r;
    const [s] = n, o = Math.floor(+s.getValue());
    if (o <= 0)
      return g.create(h.VALUE);
    let u = String.fromCharCode(o);
    return oR.some((c) => c === u) && (u = ""), U.create(u);
  }
}
class cR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError() || e.isBoolean() || e.isNumber())
      return e;
    if (e.isNull())
      return U.create("");
    const r = `${e.getValue()}`.replace(/[\0-\x1F]/g, "");
    return U.create(r);
  }
}
class lR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isNull())
      return g.create(h.VALUE);
    let t = e.getValue().toLocaleString();
    if (e.isBoolean() && (t = t.toLocaleUpperCase()), t === "")
      return g.create(h.VALUE);
    const r = t.charCodeAt(0);
    return y.create(r);
  }
}
class fR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = "", r = null;
    for (const n of e)
      if (n.isArray()) {
        if (n.iterator((s) => {
          if (s == null || s.isNull())
            return !0;
          if (s.isError())
            return r = s, !1;
          s.isBoolean() ? t += `${s.getValue()}`.toLocaleUpperCase() : (s.isString() || s.isNumber()) && (t += s.getValue());
        }), r)
          return r;
      } else !n.isError() && !n.isNull() && (t += n.getValue());
    return U.create(t);
  }
}
class mR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 255);
  }
  calculate(...e) {
    let t = 0, r = 0;
    e.forEach((s) => {
      if (s.isArray()) {
        const o = s;
        t = Math.max(t, o.getRowCount()), r = Math.max(r, o.getColumnCount());
      } else
        t = Math.max(t, 1), r = Math.max(r, 1);
    });
    let n = null;
    for (const s of e)
      n = O(t, r, s, g.create(h.NA)).mapValue((u, c, l) => {
        const f = n && n.get(c, l);
        if (f != null && f.isError())
          return f;
        if (u.isError())
          return u;
        let m = f == null ? void 0 : f.getValue(), d = u == null ? void 0 : u.getValue();
        f != null && f.isBoolean() && (m = `${m}`.toLocaleUpperCase()), u != null && u.isBoolean() && (d = `${d}`.toLocaleUpperCase());
        const _ = f != null && f.isNull() ? "" : m != null ? m : "", C = u != null && u.isNull() ? "" : d != null ? d : "";
        return U.create(`${_}${C}`);
      });
    return n || g.create(h.VALUE);
  }
}
class hR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isNull())
      return U.create("");
    let t = `${e.getValue()}`;
    e.isBoolean() && (t = t.toLocaleUpperCase());
    let r = "";
    for (let n = 0; n < t.length; n++) {
      const s = t.charCodeAt(n);
      s >= 33 && s <= 126 ? r += String.fromCharCode(s + 65248) : s === 32 ? r += "　" : r += t.charAt(n);
    }
    return U.create(r);
  }
}
class gR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
    A(this, "needsLocale", !0);
  }
  calculate(e, t) {
    let r = t != null ? t : y.create(2);
    r.isNull() && (r = y.create(2));
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, r, g.create(h.NA)), c = o.mapValue((l, f, m) => {
      const d = u.get(f, m);
      return l.isError() ? l : d.isError() ? d : this._handleSingleObject(l, d);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = I(e, t);
    if (r)
      return n;
    const [o, u] = s;
    let c = +o.getValue(), l = Math.trunc(+u.getValue());
    if (l > 127)
      return g.create(h.VALUE);
    l < 0 && (`${c}`.length < Math.abs(l) ? c = 0 : c = c < 0 ? -kt(Math.abs(c), l) : kt(c, l), l = 0);
    const f = ff(this.getLocale(), c, l);
    return U.create(f);
  }
}
class dR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, ce.create()), o = O(r, n, t, ce.create()), u = s.mapValue((c, l, f) => {
      const m = o.get(l, f);
      return c.isError() ? c : m.isError() ? m : this._handleSingleObject(c, m);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  _handleSingleObject(e, t) {
    if (e.isNull() || t.isNull()) {
      const o = e.isNull() && t.isNull();
      return T.create(o);
    }
    let r = `${e.getValue()}`;
    e.isBoolean() && (r = r.toLocaleUpperCase());
    let n = `${t.getValue()}`;
    t.isBoolean() && (n = n.toLocaleUpperCase());
    const s = r === n;
    return T.create(s);
  }
}
const ri = (a, i) => ht.format(a, i, { throws: !1 }), Pe = (a) => {
  let i = `${a.getValue()}`;
  return a.isNull() && (i = ""), a.isBoolean() && (i = i.toLocaleUpperCase()), a.isNumber() && (a.getPattern() !== "" ? i = ri(a.getPattern(), +a.getValue()) : i = `${Sa(+a.getValue())}`), i;
};
class CR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : y.create(1), s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(h.NA)), c = O(s, o, t, g.create(h.NA)), l = O(s, o, n, g.create(h.NA)), f = u.mapValue((m, d, _) => {
      const C = c.get(d, _), E = l.get(d, _);
      return m.isError() ? m : C.isError() ? C : E.isError() ? E : this._handleSingleObject(m, C, E);
    });
    return s === 1 && o === 1 ? f.get(0, 0) : f;
  }
  _handleSingleObject(e, t, r) {
    const n = Pe(e), s = Pe(t), { isError: o, errorObject: u, variants: c } = I(r);
    if (o)
      return u;
    const [l] = c, f = Math.floor(+l.getValue());
    if (t.isNull() || f <= 0 || f > s.length)
      return g.create(h.VALUE);
    if (e.isNull() || n.length === 0)
      return y.create(f);
    const m = s.indexOf(n, f - 1);
    return m === -1 ? g.create(h.VALUE) : y.create(m + 1);
  }
}
function ni(a) {
  let i = 0;
  for (let e = 0; e < a.length; e++)
    i += sn(a, e);
  return i;
}
function sn(a, i, e = "ltr") {
  return _R(a, i, e) > 255 ? 2 : 1;
}
function eo(a) {
  return a >= 55296 && a <= 56319;
}
function to(a) {
  return a >= 56320 && a <= 57343;
}
function ro(a, i) {
  const e = (a & 1023) << 10, t = i & 1023;
  return e + t + 65536;
}
function _R(a, i, e = "ltr") {
  const t = a.charCodeAt(i);
  if (e === "ltr" && eo(t) && i + 1 < a.length) {
    const r = a.charCodeAt(i + 1);
    if (to(r))
      return ro(t, r);
  }
  if (e === "rtl" && to(t) && i - 1 >= 0) {
    const r = a.charCodeAt(i - 1);
    if (eo(r))
      return ro(r, t);
  }
  return t;
}
class AR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : y.create(1), s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(h.NA)), c = O(s, o, t, g.create(h.NA)), l = O(s, o, n, g.create(h.NA)), f = u.mapValue((m, d, _) => {
      const C = c.get(d, _), E = l.get(d, _);
      return m.isError() ? m : C.isError() ? C : E.isError() ? E : this._handleSingleObject(m, C, E);
    });
    return s === 1 && o === 1 ? f.get(0, 0) : f;
  }
  _handleSingleObject(e, t, r) {
    const n = Pe(e), s = Pe(t), { isError: o, errorObject: u, variants: c } = I(r);
    if (o)
      return u;
    const [l] = c, f = Math.floor(+l.getValue());
    if (t.isNull() || f <= 0 || f > s.length)
      return g.create(h.VALUE);
    if (e.isNull() || n.length === 0)
      return y.create(f);
    const m = s.indexOf(n, f - 1);
    if (m === -1)
      return g.create(h.VALUE);
    const d = ni(s.substring(0, m)) + 1;
    return y.create(d);
  }
}
class ER extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    let n = t != null ? t : y.create(2);
    n.isNull() && (n = y.create(2));
    let s = r != null ? r : T.create(!1);
    s.isNull() && (s = T.create(!1));
    const o = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      s.isArray() ? s.getRowCount() : 1
    ), u = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      s.isArray() ? s.getColumnCount() : 1
    ), c = O(o, u, e, g.create(h.NA)), l = O(o, u, n, g.create(h.NA)), f = O(o, u, s, g.create(h.NA)), m = c.mapValue((d, _, C) => {
      const E = l.get(_, C), R = f.get(_, C);
      return d.isError() ? d : E.isError() ? E : R.isError() ? R : this._handleSingleObject(d, E, R);
    });
    return o === 1 && u === 1 ? m.get(0, 0) : m;
  }
  _handleSingleObject(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = I(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o;
    let f = +u.getValue(), m = Math.trunc(+c.getValue());
    const d = +l.getValue();
    if (m > 127)
      return g.create(h.VALUE);
    m < 0 && (`${f}`.length < Math.abs(m) ? f = 0 : f = f < 0 ? -kt(Math.abs(f), m) : kt(f, m), m = 0);
    let _ = d ? "###0" : "#,##0";
    m > 0 && (_ += `.${"0".repeat(m)}`);
    const C = ri(_, f);
    return U.create(C);
  }
}
class RR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(1), n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, r, g.create(h.NA)), c = o.mapValue((l, f, m) => {
      const d = u.get(f, m);
      return l.isError() ? l : d.isError() ? d : this._handleSingleObject(l, d);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
  _handleSingleObject(e, t) {
    const r = Pe(e), { isError: n, errorObject: s, variants: o } = I(t);
    if (n)
      return s;
    const [u] = o, c = Math.floor(+u.getValue());
    if (c < 0)
      return g.create(h.VALUE);
    if (e.isNull() || c === 0)
      return U.create("");
    if (c >= r.length)
      return U.create(r);
    const l = r.substring(0, c);
    return U.create(l);
  }
}
class bR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(1), n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, ce.create()), u = O(n, s, r, ce.create()), c = o.mapValue((l, f, m) => {
      const d = u.get(f, m);
      return l.isError() ? l : d.isError() ? d : this._handleSingleObject(l, d);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
  _handleSingleObject(e, t) {
    const r = Pe(e), { isError: n, errorObject: s, variants: o } = I(t);
    if (n)
      return s;
    const [u] = o, c = Math.floor(+u.getValue());
    if (c < 0)
      return g.create(h.VALUE);
    if (e.isNull() || c === 0)
      return U.create("");
    let l = 0, f = 0, m = "";
    for (; f < c && l < r.length; )
      f += sn(r, l), m += r.charAt(l), l++;
    return U.create(m);
  }
}
class yR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleText(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleText(e);
  }
  _handleSingleText(e) {
    if (e.isError())
      return e;
    const t = Pe(e);
    return y.create(t.length);
  }
}
class pR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleText(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleText(e);
  }
  _handleSingleText(e) {
    if (e.isError())
      return e;
    const t = Pe(e), r = ni(t);
    return y.create(r);
  }
}
class NR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isNull())
      return U.create("");
    const t = `${e.getValue()}`.toLocaleLowerCase();
    return U.create(t);
  }
}
class VR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, t, g.create(h.NA)), c = O(n, s, r, g.create(h.NA)), l = o.mapValue((f, m, d) => {
      const _ = u.get(m, d), C = c.get(m, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    const n = Pe(e), { isError: s, errorObject: o, variants: u } = I(t, r);
    if (s)
      return o;
    const [c, l] = u, f = Math.floor(+c.getValue()), m = Math.floor(+l.getValue());
    if (f <= 0 || m < 0)
      return g.create(h.VALUE);
    if (e.isNull() || f > n.length || m === 0)
      return U.create("");
    const d = n.substring(f - 1, f - 1 + m);
    return U.create(d);
  }
}
class OR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, t, g.create(h.NA)), c = O(n, s, r, g.create(h.NA)), l = o.mapValue((f, m, d) => {
      const _ = u.get(m, d), C = c.get(m, d);
      return f.isError() ? f : _.isError() ? _ : C.isError() ? C : this._handleSingleObject(f, _, C);
    });
    return n === 1 && s === 1 ? l.get(0, 0) : l;
  }
  _handleSingleObject(e, t, r) {
    let n = Pe(e);
    const { isError: s, errorObject: o, variants: u } = I(t, r);
    if (s)
      return o;
    const [c, l] = u, f = Math.floor(+c.getValue()), m = Math.floor(+l.getValue());
    if (f <= 0 || m < 0)
      return g.create(h.VALUE);
    if (e.isNull() || f > n.length || m === 0)
      return U.create("");
    n = n.substring(f - 1);
    let d = 0, _ = 0, C = "";
    for (; _ < m && d < n.length; )
      _ += sn(n, d), C += n.charAt(d), d++;
    return U.create(C);
  }
}
const vr = ["〇", "一", "二", "三", "四", "五", "六", "七", "八", "九"], mn = ["零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"], SR = ["", "十", "百", "千"], MR = ["", "拾", "佰", "仟"], DR = ["", "万", "亿", "兆"];
class wR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(h.NA)), o = O(r, n, t, g.create(h.NA)), u = s.mapValue((c, l, f) => {
      const m = o.get(l, f);
      return c.isError() ? c : m.isError() ? m : this._handleSingleObject(c, m);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
  // eslint-disable-next-line
  _handleSingleObject(e, t) {
    const r = e.convertToNumberObjectValue();
    if (r.isError())
      return r;
    const n = t.convertToNumberObjectValue();
    if (n.isError())
      return n;
    let s = r.getValue();
    const o = Math.trunc(n.getValue());
    if (s < 0 || ![1, 2, 3].includes(o))
      return g.create(h.NUM);
    s = Math.round(s);
    const u = s.toString(), c = u.length;
    let l = "", f = !1;
    for (let m = 0; m < c; m++) {
      const d = Number(u[m]);
      if (c === 1 && d === 0) {
        l += o === 2 ? mn[0] : vr[0];
        break;
      }
      if (o === 3) {
        l += vr[d];
        continue;
      }
      const _ = c - m - 1, C = _ % 4, E = Math.trunc(_ / 4);
      if (c >= 17 && E > 2) {
        if (l += o === 1 ? vr[d] : mn[d], E > 3)
          continue;
      } else
        d === 0 ? f = C !== 0 : (f && (l += o === 1 ? vr[0] : mn[0], f = !1), l += o === 1 ? vr[d] + SR[C] : mn[d] + MR[C]);
      C === 0 && E > 0 && u.slice(Math.max(0, m - 3), m + 1) !== "0000" && (l += DR[E]);
    }
    return U.create(l);
  }
}
class LR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 3);
  }
  isArgumentsIgnoreNumberPattern() {
    return !0;
  }
  calculate(e, t, r) {
    const n = t != null ? t : U.create("."), s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1,
      r != null && r.isArray() ? r.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1,
      r != null && r.isArray() ? r.getColumnCount() : 1
    ), u = O(s, o, e, g.create(h.NA)), c = O(s, o, n, g.create(h.NA)), l = r ? O(s, o, r, g.create(h.NA)) : void 0, f = u.mapValue((m, d, _) => {
      const C = c.get(d, _), E = r ? l.get(d, _) : void 0;
      return m.isError() ? m : C.isError() ? C : E != null && E.isError() ? E : C.isNull() || E != null && E.isNull() ? g.create(h.VALUE) : m.isNull() ? y.create(0) : this._handleSingleObject(m, C, E);
    });
    return s === 1 && o === 1 ? f.get(0, 0) : f;
  }
  // eslint-disable-next-line
  _handleSingleObject(e, t, r) {
    let n = `${e.getValue()}`;
    n = n.replace(/\s+/g, "");
    let s = `${t.getValue()}`;
    t.isBoolean() && (s = s.toLocaleUpperCase()), s = s.charAt(0);
    let o;
    if (r && (o = `${r.getValue()}`, r.isBoolean() && (o = o.toLocaleUpperCase()), o = o.charAt(0), s === o))
      return g.create(h.VALUE);
    if (n.trim() === "")
      return y.create(0);
    if (!n.match(/^\s*[+-]?\s*(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:[eE][+-]?\d+)?[ \t]*/))
      return g.create(h.VALUE);
    const u = n.split(s);
    if (u.length > 2)
      return g.create(h.VALUE);
    let c = u[0].replace(/,/g, "");
    r && (c = c.split(o).join(""));
    let l = 0;
    if (u.length === 1) {
      s === "," && (c = c.replace(/\./g, ""));
      let f = 0;
      for (; c.endsWith("%"); )
        c = c.slice(0, -1), f++;
      f > 0 ? l = +c / 100 ** f : l = +c;
    } else {
      if (!q(c))
        return g.create(h.VALUE);
      let f = u[1], m = 0;
      for (; f.endsWith("%"); )
        f = f.slice(0, -1), m++;
      const d = `${c}.${f}`;
      if (!q(d))
        return g.create(h.VALUE);
      m > 0 ? l = +d / 100 ** m : l = +d;
    }
    return Number.isNaN(l) ? g.create(h.VALUE) : y.create(l);
  }
}
class PR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError() || e.isNull() || e.isBoolean() || e.isNumber())
      return e;
    const r = e.getValue().toLocaleString().toLocaleLowerCase().replace(/(^|\b|\W|\d|_)[a-z]/g, (n) => n.toLocaleUpperCase());
    return U.create(r);
  }
}
const hc = () => [
  {
    type: 4,
    from: 48,
    to: 57
  }
], gc = () => [
  {
    type: 7,
    value: 95
  },
  {
    type: 4,
    from: 97,
    to: 122
  },
  {
    type: 4,
    from: 65,
    to: 90
  },
  {
    type: 4,
    from: 48,
    to: 57
  }
], dc = () => [
  {
    type: 7,
    value: 9
  },
  {
    type: 7,
    value: 10
  },
  {
    type: 7,
    value: 11
  },
  {
    type: 7,
    value: 12
  },
  {
    type: 7,
    value: 13
  },
  {
    type: 7,
    value: 32
  },
  {
    type: 7,
    value: 160
  },
  {
    type: 7,
    value: 5760
  },
  {
    type: 4,
    from: 8192,
    to: 8202
  },
  {
    type: 7,
    value: 8232
  },
  {
    type: 7,
    value: 8233
  },
  {
    type: 7,
    value: 8239
  },
  {
    type: 7,
    value: 8287
  },
  {
    type: 7,
    value: 12288
  },
  {
    type: 7,
    value: 65279
  }
], Cc = () => ({
  type: 3,
  set: gc(),
  not: !1
}), _c = () => ({
  type: 3,
  set: gc(),
  not: !0
}), Ac = () => ({
  type: 3,
  set: hc(),
  not: !1
}), Ec = () => ({
  type: 3,
  set: hc(),
  not: !0
}), Rc = () => ({
  type: 3,
  set: dc(),
  not: !1
}), bc = () => ({
  type: 3,
  set: dc(),
  not: !0
}), xR = () => ({
  type: 3,
  set: [
    {
      type: 7,
      value: 10
    },
    {
      type: 7,
      value: 13
    },
    {
      type: 7,
      value: 8232
    },
    {
      type: 7,
      value: 8233
    }
  ],
  not: !0
});
function jR(a) {
  const i = {
    type: 0,
    stack: []
  };
  let e = i, t = i.stack;
  const r = [], n = [];
  let s = 0;
  const o = (f) => {
    throw new SyntaxError(`Invalid regular expression: /${a}/: Nothing to repeat at column ${f - 1}`);
  }, u = vR(a);
  let c = 0, l;
  for (; c < u.length; )
    switch (l = u[c++], l) {
      case "\\":
        if (c === u.length)
          throw new SyntaxError(`Invalid regular expression: /${a}/: \\ at end of pattern`);
        switch (l = u[c++], l) {
          case "b":
            t.push({
              type: 2,
              value: "b"
            });
            break;
          case "B":
            t.push({
              type: 2,
              value: "B"
            });
            break;
          case "w":
            t.push(Cc());
            break;
          case "W":
            t.push(_c());
            break;
          case "d":
            t.push(Ac());
            break;
          case "D":
            t.push(Ec());
            break;
          case "s":
            t.push(Rc());
            break;
          case "S":
            t.push(bc());
            break;
          default:
            if (/\d/.test(l)) {
              for (; /\d/.test(u[c]) && c < u.length; )
                l += u[c++];
              const f = Number.parseInt(l, 10);
              t.push({
                type: 6,
                value: f
              }), n.push({
                reference: {
                  type: 6,
                  value: f
                },
                stack: t,
                index: t.length - 1
              });
            } else
              t.push({
                type: 7,
                value: l.charCodeAt(0)
              });
        }
        break;
      case "^":
        t.push({
          type: 2,
          value: "^"
        });
        break;
      case "$":
        t.push({
          type: 2,
          value: "$"
        });
        break;
      case "[": {
        const f = u[c] === "^";
        f && c++;
        const m = UR(u.slice(c), a);
        c += m[1], t.push({
          type: 3,
          set: m[0],
          not: f
        });
        break;
      }
      case ".":
        t.push(xR());
        break;
      case "(": {
        const f = {
          type: 1,
          stack: [],
          remember: !0
          // 默认情况下，捕获组是需要记住（捕获）的
        };
        if (u[c] === "?") {
          const m = u[c + 1];
          if (c += 2, m === "=")
            f.followedBy = !0;
          else if (m === "!")
            f.notFollowedBy = !0;
          else if (m !== ":")
            throw new SyntaxError(`Invalid regular expression: /${a}/: Invalid group, character '${m}' after '?' at column ${c - 1}`);
          f.remember = !1;
        } else
          s += 1;
        t.push(f), r.push(e), e = f, t = f.stack;
        break;
      }
      case ")":
        if (r.length === 0)
          throw new SyntaxError(`Invalid regular expression: /${a}/: Unmatched ) at column ${c - 1}`);
        e = r.pop(), t = e.options ? e.options[e.options.length - 1] : e.stack;
        break;
      case "|": {
        e.options || (e.options = [e.stack], delete e.stack);
        const f = [];
        e.options.push(f), t = f;
        break;
      }
      case "{": {
        const f = /^(\d+)(,(\d+)?)?\}/.exec(u.slice(c));
        if (f) {
          t.length === 0 && o(c);
          const m = Number.parseInt(f[1], 10), d = f[2] ? f[3] ? Number.parseInt(f[3], 10) : 1 / 0 : m;
          c += f[0].length, t.push({
            type: 5,
            min: m,
            max: d,
            value: t.pop()
          });
        } else
          t.push({
            // Assuming 123 is the character code for '{'
            type: 7,
            value: 123
          });
        break;
      }
      case "?":
        t.length === 0 && o(c), t.push({
          type: 5,
          min: 0,
          max: 1,
          value: t.pop()
        });
        break;
      case "+":
        t.length === 0 && o(c), t.push({
          type: 5,
          min: 1,
          max: 1 / 0,
          value: t.pop()
        });
        break;
      case "*":
        t.length === 0 && o(c), t.push({
          type: 5,
          min: 0,
          max: 1 / 0,
          value: t.pop()
        });
        break;
      default:
        t.push({
          type: 7,
          value: l.charCodeAt(0)
        });
    }
  if (r.length > 0)
    throw new SyntaxError(`Invalid regular expression: /${a}/: Unterminated group`);
  return TR(n, s), i;
}
function UR(a, i) {
  let e;
  const t = [], r = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(((?:\\)])|(((?:\\)?([^\]])))))|(\])|(?:\\)?([^])/g;
  for (; (e = r.exec(a)) !== null; ) {
    let n = null;
    const [, s, o, u, c, l, f, m, d, _, C] = e;
    if (s || o || u || c || l || f ? n = (() => {
      let E = {
        type: 3,
        set: [],
        not: !1
      };
      return s ? E = Cc() : o ? E = Ac() : u ? E = Rc() : c ? E = _c() : l ? E = Ec() : f && (E = bc()), E;
    })() : m && C ? n = {
      type: 4,
      from: (d || _).charCodeAt(0),
      to: C.charCodeAt(C.length - 1)
    } : e[16] && (n = {
      type: 7,
      value: e[16].charCodeAt(0)
    }), !n)
      return [t, r.lastIndex];
    t.push(n);
  }
  throw new SyntaxError(`Invalid regular expression: /${i}/: Unterminated character class`);
}
function vR(a) {
  return a.replace(
    /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g,
    (i, e, t, r, n, s, o) => {
      if (t)
        return i;
      let u;
      e ? u = 8 : r ? u = Number.parseInt(r, 16) : n ? u = Number.parseInt(n, 16) : s ? u = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?".indexOf(s) : u = {
        0: 0,
        t: 9,
        n: 10,
        v: 11,
        f: 12,
        r: 13
      }[o];
      const c = String.fromCharCode(u);
      return /[[\]{}^$.|?*+()]/.test(c) ? `\\${c}` : c;
    }
  );
}
function TR(a, i) {
  for (const e of a.reverse()) {
    const t = e.reference.value;
    if (i < t) {
      e.reference.type = 7;
      const r = t.toString();
      if (e.reference.value = Number.parseInt(r, 8), !/^[0-7]+$/.test(r)) {
        let n = 0;
        for (; r[n] !== "8" && r[n] !== "9" && n < r.length; )
          n += 1;
        if (n === 0 ? (e.reference.value = r.charCodeAt(0), n += 1) : e.reference.value = Number.parseInt(r.slice(0, n), 8), r.length > n) {
          const s = e.stack.splice(e.index + 1);
          for (const o of r.slice(n))
            e.stack.push({
              type: 7,
              value: o.charCodeAt(0)
            });
          e.stack.push(...s);
        }
      }
    }
  }
}
function si(a, i) {
  if (!IR(a))
    return {
      isError: !0,
      regExp: null
    };
  try {
    const e = new RegExp(a, i ? "ug" : "u");
    return BR(e) ? {
      isError: !1,
      regExp: e
    } : {
      isError: !0,
      regExp: null
    };
  } catch {
    return {
      isError: !0,
      regExp: null
    };
  }
}
function IR(a) {
  return !(/\(\?<=.*?\)/g.test(a) && !/\[.*?(\?<=.*?)\]/g.test(a) || /\(\?<!.*?\)/g.test(a) && !/\[.*?(\?<!.*?)\]/g.test(a));
}
function BR(a, i) {
  let t;
  Object.prototype.toString.call(a) === "[object RegExp]" ? t = a.source : a && typeof a != "string" && (t = `${a}`);
  let r;
  try {
    r = jR(t);
  } catch {
    return !1;
  }
  let n = 0;
  const s = (o, u) => {
    let c = u;
    if (o.type === 5 && (c++, n++, c > 1 || n > 25))
      return !1;
    if (o.options) {
      for (const f of o.options)
        if (!s({ stack: f }, c))
          return !1;
    }
    const l = o.stack || o.value && o.value.stack;
    if (!l)
      return !0;
    for (const f of l)
      if (!s(f, c))
        return !1;
    return !0;
  };
  return s(r, 0);
}
class FR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = zr(e, t);
    if (r)
      return n;
    const [o, u] = s;
    let c = o.getValue();
    o.isNull() && (c = ""), o.isBoolean() && (c = c ? "TRUE" : "FALSE"), c = `${c}`;
    let l = u.getValue();
    u.isNull() && (l = ""), u.isBoolean() && (l = l ? "TRUE" : "FALSE"), l = `${l}`;
    const { isError: f, regExp: m } = si(l, !1);
    if (f)
      return g.create(h.REF);
    const d = c.match(m);
    if (d === null)
      return g.create(h.NA);
    if (d.length > 1) {
      const _ = d.slice(1).map((C) => U.create(C));
      return _.length > 1 ? K.create({
        calculateValueList: [_],
        rowCount: 1,
        columnCount: _.length,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      }) : _[0];
    }
    return U.create(d[0]);
  }
}
class kR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const { isError: r, errorObject: n, variants: s } = zr(e, t);
    if (r)
      return n;
    const [o, u] = s;
    let c = o.getValue();
    o.isNull() && (c = ""), o.isBoolean() && (c = c ? "TRUE" : "FALSE"), c = `${c}`;
    let l = u.getValue();
    u.isNull() && (l = ""), u.isBoolean() && (l = l ? "TRUE" : "FALSE"), l = `${l}`;
    const { isError: f, regExp: m } = si(l, !1);
    return f ? g.create(h.REF) : c.match(m) === null ? T.create(!1) : T.create(!0);
  }
}
class $R extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const { isError: n, errorObject: s, variants: o } = zr(e, t, r);
    if (n)
      return s;
    const [u, c, l] = o;
    let f = u.getValue();
    u.isNull() && (f = ""), u.isBoolean() && (f = f ? "TRUE" : "FALSE"), f = `${f}`;
    let m = c.getValue();
    c.isNull() && (m = ""), c.isBoolean() && (m = m ? "TRUE" : "FALSE"), m = `${m}`;
    let d = l.getValue();
    l.isNull() && (d = ""), l.isBoolean() && (d = d ? "TRUE" : "FALSE"), d = `${d}`;
    const { isError: _, regExp: C } = si(m, !0);
    if (_)
      return g.create(h.REF);
    const E = f.replace(C, d);
    return U.create(E);
  }
}
class YR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(h.NA)), c = O(s, o, t, g.create(h.NA)), l = O(s, o, r, g.create(h.NA)), f = O(s, o, n, g.create(h.NA)), m = u.mapValue((d, _, C) => {
      const E = c.get(_, C), R = l.get(_, C), b = f.get(_, C);
      return d.isError() ? d : E.isError() ? E : R.isError() ? R : b.isError() ? b : this._handleSingleObject(d, E, R, b);
    });
    return s === 1 && o === 1 ? m.get(0, 0) : m;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = I(t, r);
    if (s)
      return o;
    const [c, l] = u, f = Math.floor(+c.getValue()), m = Math.floor(+l.getValue());
    if (f <= 0 || m < 0)
      return g.create(h.VALUE);
    const d = Pe(e), _ = Pe(n), C = d.substring(0, f - 1) + _ + d.substring(f - 1 + m);
    return U.create(C);
  }
}
class HR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 4);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(h.NA)), c = O(s, o, t, g.create(h.NA)), l = O(s, o, r, g.create(h.NA)), f = O(s, o, n, g.create(h.NA)), m = u.mapValue((d, _, C) => {
      const E = c.get(_, C), R = l.get(_, C), b = f.get(_, C);
      return d.isError() ? d : E.isError() ? E : R.isError() ? R : b.isError() ? b : this._handleSingleObject(d, E, R, b);
    });
    return s === 1 && o === 1 ? m.get(0, 0) : m;
  }
  _handleSingleObject(e, t, r, n) {
    const { isError: s, errorObject: o, variants: u } = I(t, r);
    if (s)
      return o;
    const [c, l] = u, f = Math.floor(+c.getValue()), m = Math.floor(+l.getValue());
    if (f <= 0 || m < 0)
      return g.create(h.VALUE);
    let d = Pe(e);
    const _ = Pe(n);
    let C = d.substring(0, f - 1);
    d = d.substring(f - 1);
    let E = 0, R = 0;
    for (; R < m && E < d.length; )
      R += sn(d, E), E++;
    return C += _ + d.substring(E), U.create(C);
  }
}
class GR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e, g.create(h.NA)), o = O(r, n, t, g.create(h.NA)), u = s.map((c, l, f) => {
      let m = o.get(l, f);
      if (c.isError())
        return c;
      let d = c.getValue();
      if (c.isNull() && (d = ""), c.isBoolean() && (d = d ? "TRUE" : "FALSE"), d += "", m.isString() && (m = m.convertToNumberObjectValue()), m.isError())
        return m;
      const _ = 32767, C = Math.floor(+m.getValue());
      if (C < 0 || C > _ / d.length)
        return g.create(h.VALUE);
      const E = d.repeat(C);
      return U.create(E);
    });
    return r === 1 && n === 1 ? u.get(0, 0) : u;
  }
}
class WR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(1), n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, r, g.create(h.NA)), c = o.mapValue((l, f, m) => {
      const d = u.get(f, m);
      return l.isError() ? l : d.isError() ? d : this._handleSingleObject(l, d);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
  _handleSingleObject(e, t) {
    const r = Pe(e), { isError: n, errorObject: s, variants: o } = I(t);
    if (n)
      return s;
    const [u] = o, c = Math.floor(+u.getValue());
    if (c < 0)
      return g.create(h.VALUE);
    if (e.isNull() || c === 0)
      return U.create("");
    if (c >= r.length)
      return U.create(r);
    const l = r.substring(r.length - c);
    return U.create(l);
  }
}
class QR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(1), n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, r, g.create(h.NA)), c = o.mapValue((l, f, m) => {
      const d = u.get(f, m);
      return l.isError() ? l : d.isError() ? d : this._handleSingleObject(l, d);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
  _handleSingleObject(e, t) {
    const r = Pe(e), { isError: n, errorObject: s, variants: o } = I(t);
    if (n)
      return s;
    const [u] = o, c = Math.floor(+u.getValue());
    if (c < 0)
      return g.create(h.VALUE);
    if (e.isNull() || c === 0)
      return U.create("");
    let l = r.length - 1, f = 0, m = "";
    for (; f < c && l >= 0; )
      f += sn(r, l, "rtl"), m = r.charAt(l) + m, l--;
    return U.create(m);
  }
}
class qR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : y.create(1), s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(h.NA)), c = O(s, o, t, g.create(h.NA)), l = O(s, o, n, g.create(h.NA)), f = u.mapValue((m, d, _) => {
      const C = c.get(d, _), E = l.get(d, _);
      return m.isError() ? m : C.isError() ? C : E.isError() ? E : this._handleSingleObject(m, C, E);
    });
    return s === 1 && o === 1 ? f.get(0, 0) : f;
  }
  _handleSingleObject(e, t, r) {
    const n = Pe(e).toLocaleUpperCase(), s = Pe(t).toLocaleUpperCase(), { isError: o, errorObject: u, variants: c } = I(r);
    if (o)
      return u;
    const [l] = c, f = Math.floor(+l.getValue());
    if (t.isNull() || f <= 0 || f > s.length)
      return g.create(h.VALUE);
    if (e.isNull() || n.length === 0)
      return y.create(f);
    const m = s.indexOf(n, f - 1);
    return m === -1 ? g.create(h.VALUE) : y.create(m + 1);
  }
}
class XR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 3);
  }
  calculate(e, t, r) {
    const n = r != null ? r : y.create(1), s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(h.NA)), c = O(s, o, t, g.create(h.NA)), l = O(s, o, n, g.create(h.NA)), f = u.mapValue((m, d, _) => {
      const C = c.get(d, _), E = l.get(d, _);
      return m.isError() ? m : C.isError() ? C : E.isError() ? E : this._handleSingleObject(m, C, E);
    });
    return s === 1 && o === 1 ? f.get(0, 0) : f;
  }
  _handleSingleObject(e, t, r) {
    const n = Pe(e).toLocaleUpperCase(), s = Pe(t).toLocaleUpperCase(), { isError: o, errorObject: u, variants: c } = I(r);
    if (o)
      return u;
    const [l] = c, f = Math.floor(+l.getValue());
    if (t.isNull() || f <= 0 || f > s.length)
      return g.create(h.VALUE);
    if (e.isNull() || n.length === 0)
      return y.create(f);
    const m = s.indexOf(n, f - 1);
    if (m === -1)
      return g.create(h.VALUE);
    const d = ni(s.substring(0, m)) + 1;
    return y.create(d);
  }
}
class KR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 4);
  }
  calculate(e, t, r, n) {
    const s = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1,
      n != null && n.isArray() ? n.getRowCount() : 1
    ), o = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1,
      n != null && n.isArray() ? n.getColumnCount() : 1
    ), u = O(s, o, e, g.create(h.NA)), c = O(s, o, t, g.create(h.NA)), l = O(s, o, r, g.create(h.NA)), f = n ? O(s, o, n, g.create(h.NA)) : void 0, m = u.mapValue((d, _, C) => {
      const E = c.get(_, C), R = l.get(_, C);
      let b = n ? f.get(_, C) : void 0;
      return d.isError() ? d : E.isError() ? E : R.isError() ? R : b != null && b.isError() ? b : b != null && b.isNull() || b != null && b.isBoolean() ? g.create(h.VALUE) : (b != null && b.isString() && (b = b.convertToNumberObjectValue()), b != null && b.isError() ? b : this._handleSingleObject(d, E, R, b));
    });
    return s === 1 && o === 1 ? m.get(0, 0) : m;
  }
  _handleSingleObject(e, t, r, n) {
    const s = this._getObjectString(e), o = this._getObjectString(t), u = this._getObjectString(r), c = n ? Math.floor(+n.getValue()) : void 0;
    if (n && c <= 0)
      return g.create(h.VALUE);
    if (o === "")
      return U.create(s);
    let l = "", f = 0;
    for (let m = 0; m < s.length; m++) {
      const d = s.substr(m, o.length);
      if (d === o || d.length === o.length && d.trim() === o.trim()) {
        if (f++, f === c) {
          l = s.substr(0, m) + u + s.substr(m + o.length);
          break;
        }
        c === void 0 && (l += u), m += o.length - 1;
      } else
        c === void 0 && (l += s[m]);
    }
    return c && f < c && (l = s), U.create(l);
  }
  _getObjectString(e) {
    let t = `${e.getValue()}`;
    return e.isNull() && (t = ""), e.isBoolean() && (t = t.toLocaleUpperCase()), t;
  }
}
class ZR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
    A(this, "needsReferenceObject", !0);
  }
  calculate(e) {
    let t = e;
    return e.isReferenceObject() && (t = e.toArrayValueObject().get(0, 0)), t.isArray() ? t.mapValue((r) => this._handleSingleObject(r)) : this._handleSingleObject(t);
  }
  _handleSingleObject(e) {
    return e.isError() ? e : e.isNull() || e.isBoolean() || e.isNumber() ? U.create("") : e;
  }
}
class zR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 2);
  }
  isArgumentsIgnoreNumberPattern() {
    return !0;
  }
  calculate(e, t) {
    if (e.isError())
      return e;
    if (t.isError())
      return t;
    const r = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      t.isArray() ? t.getRowCount() : 1
    ), n = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      t.isArray() ? t.getColumnCount() : 1
    ), s = O(r, n, e), o = O(r, n, t), u = s.map((c, l, f) => {
      if (c.isError())
        return c;
      let m = o.get(l, f) || U.create(" ");
      if (m.isError())
        return m;
      if (m.isBoolean())
        return g.create(h.VALUE);
      if (c.isBoolean())
        return c;
      let d = c.getValue();
      if (c.isNull() && (d = 0), c.isString())
        if (q(d))
          d = Number(d);
        else {
          const E = lo(`${d}`);
          E && E.v != null && typeof E.v == "number" && (d = E.v);
        }
      m.isNull() && (m = U.create(" "));
      const _ = `${m.getValue()}`, C = ri(_, d);
      return U.create(_ === " " ? C.trimEnd() : C);
    });
    return u.getRowCount() === 1 && u.getColumnCount() === 1 ? u.get(0, 0) : u;
  }
}
class JR extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    let u = !1, c = r != null ? r : y.create(1);
    c.isNull() && (u = !0, c = y.create(1));
    const l = !n, f = n != null ? n : y.create(0), m = s != null ? s : y.create(0), d = o != null ? o : g.create(h.NA), _ = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1,
      f.isArray() ? f.getRowCount() : 1,
      m.isArray() ? m.getRowCount() : 1,
      d.isArray() ? d.getRowCount() : 1
    ), C = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1,
      f.isArray() ? f.getColumnCount() : 1,
      m.isArray() ? m.getColumnCount() : 1,
      d.isArray() ? d.getColumnCount() : 1
    ), E = O(_, C, e, g.create(h.NA)), R = O(_, C, c, g.create(h.NA)), b = O(_, C, f, g.create(h.NA)), p = O(_, C, m, g.create(h.NA)), V = O(_, C, d, g.create(h.NA)), S = this._getResultArray(E, t, R, b, p, V, u, l);
    return _ === 1 && C === 1 ? S.get(0, 0) : S;
  }
  _getResultArray(e, t, r, n, s, o, u, c) {
    return e.map((f, m, d) => {
      const _ = r.get(m, d), C = n.get(m, d), E = s.get(m, d), R = o.get(m, d), b = this._checkVariantsError(f, _, C, E);
      if (b.isError())
        return b;
      const p = this._getStringValue(f), V = this._getDelimiterValue(t);
      if (V instanceof g)
        return V;
      const S = this._getVariantsNumberFloorValue(_, C, E);
      if (S instanceof g)
        return S;
      const [M, D, w] = S;
      return M === 0 || D < 0 || D > 1 || w < 0 || w > 1 ? g.create(h.VALUE) : V.includes("") ? M > 0 ? U.create(p) : U.create("") : !u && Math.abs(M) > p.length ? g.create(h.VALUE) : V.every((L) => L.length > p.length) ? g.create(h.NA) : this._getResult(p, V, M, D, w, R, c);
    });
  }
  _checkVariantsError(...e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      if (r.isError())
        return r;
    }
    return T.create(!0);
  }
  _getStringValue(e) {
    let t = `${e.getValue()}`;
    return e.isNull() && (t = ""), e.isBoolean() && (t = t.toLocaleUpperCase()), t;
  }
  _getDelimiterValue(e) {
    const t = [];
    if (e.isArray()) {
      let r = !1, n = g.create(h.VALUE);
      if (e.iterator((s) => {
        const o = s;
        if (o.isError())
          return r = !0, n = o, !1;
        t.push(this._getStringValue(o));
      }), r)
        return n;
    } else {
      if (e.isError())
        return e;
      t.push(this._getStringValue(e));
    }
    return t;
  }
  _getVariantsNumberFloorValue(...e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (n.isString() && (n = n.convertToNumberObjectValue()), n.isError())
        return n;
      const s = Math.floor(+n.getValue());
      t.push(s);
    }
    return t;
  }
  _getResult(e, t, r, n, s, o, u) {
    let c = n ? e.toLocaleLowerCase() : e;
    const l = n ? t.map((C) => C.toLocaleLowerCase()) : t;
    let f = 0, m = 0, d = 0;
    for (let C = 0; C < Math.abs(r); C++)
      if (r < 0) {
        const E = l.map((R) => ({
          index: c.lastIndexOf(R),
          length: R.length
        })).filter((R) => R.index !== -1).sort((R, b) => b.index - R.index)[0];
        if (!E)
          break;
        f = E.index, c = c.substr(0, E.index), d = E.length, m++;
      } else {
        const E = l.map((R) => ({
          index: c.indexOf(R),
          length: R.length
        })).filter((R) => R.index !== -1).sort((R, b) => R.index - b.index)[0];
        if (!E)
          break;
        f += E.index + d, c = c.substr(E.index + E.length), d = E.length, m++;
      }
    if (m && m < Math.abs(r) && u)
      return g.create(h.NA);
    if (!m || m < Math.abs(r))
      return s ? r > 0 ? U.create("") : U.create(e) : o;
    const _ = e.substr(f + d);
    return U.create(_);
  }
}
class eb extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    let u = !1, c = r != null ? r : y.create(1);
    c.isNull() && (u = !0, c = y.create(1));
    const l = !n, f = n != null ? n : y.create(0), m = s != null ? s : y.create(0), d = o != null ? o : g.create(h.NA), _ = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1,
      f.isArray() ? f.getRowCount() : 1,
      m.isArray() ? m.getRowCount() : 1,
      d.isArray() ? d.getRowCount() : 1
    ), C = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1,
      f.isArray() ? f.getColumnCount() : 1,
      m.isArray() ? m.getColumnCount() : 1,
      d.isArray() ? d.getColumnCount() : 1
    ), E = O(_, C, e, g.create(h.NA)), R = O(_, C, c, g.create(h.NA)), b = O(_, C, f, g.create(h.NA)), p = O(_, C, m, g.create(h.NA)), V = O(_, C, d, g.create(h.NA)), S = this._getResultArray(E, t, R, b, p, V, u, l);
    return _ === 1 && C === 1 ? S.get(0, 0) : S;
  }
  _getResultArray(e, t, r, n, s, o, u, c) {
    return e.map((f, m, d) => {
      const _ = r.get(m, d), C = n.get(m, d), E = s.get(m, d), R = o.get(m, d), b = this._checkVariantsError(f, _, C, E);
      if (b.isError())
        return b;
      const p = this._getStringValue(f), V = this._getDelimiterValue(t);
      if (V instanceof g)
        return V;
      const S = this._getVariantsNumberFloorValue(_, C, E);
      if (S instanceof g)
        return S;
      const [M, D, w] = S;
      return M === 0 || D < 0 || D > 1 || w < 0 || w > 1 ? g.create(h.VALUE) : V.includes("") ? M > 0 ? U.create("") : U.create(p) : !u && Math.abs(M) > p.length ? g.create(h.VALUE) : V.every((L) => L.length > p.length) ? g.create(h.NA) : this._getResult(p, V, M, D, w, R, c);
    });
  }
  _checkVariantsError(...e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      if (r.isError())
        return r;
    }
    return T.create(!0);
  }
  _getStringValue(e) {
    let t = `${e.getValue()}`;
    return e.isNull() && (t = ""), e.isBoolean() && (t = t.toLocaleUpperCase()), t;
  }
  _getDelimiterValue(e) {
    const t = [];
    if (e.isArray()) {
      let r = !1, n = g.create(h.VALUE);
      if (e.iterator((s) => {
        const o = s;
        if (o.isError())
          return r = !0, n = o, !1;
        t.push(this._getStringValue(o));
      }), r)
        return n;
    } else {
      if (e.isError())
        return e;
      t.push(this._getStringValue(e));
    }
    return t;
  }
  _getVariantsNumberFloorValue(...e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (n.isString() && (n = n.convertToNumberObjectValue()), n.isError())
        return n;
      const s = Math.floor(+n.getValue());
      t.push(s);
    }
    return t;
  }
  _getResult(e, t, r, n, s, o, u) {
    let c = n ? e.toLocaleLowerCase() : e;
    const l = n ? t.map((C) => C.toLocaleLowerCase()) : t;
    let f = 0, m = 0, d = 0;
    for (let C = 0; C < Math.abs(r); C++)
      if (r < 0) {
        const E = l.map((R) => ({
          index: c.lastIndexOf(R),
          length: R.length
        })).filter((R) => R.index !== -1).sort((R, b) => b.index - R.index)[0];
        if (!E)
          break;
        f = E.index, c = c.substr(0, E.index), m++;
      } else {
        const E = l.map((R) => ({
          index: c.indexOf(R),
          length: R.length
        })).filter((R) => R.index !== -1).sort((R, b) => R.index - b.index)[0];
        if (!E)
          break;
        f += E.index + d, c = c.substr(E.index + E.length), d = E.length, m++;
      }
    if (m && m < Math.abs(r) && u)
      return g.create(h.NA);
    if (!m || m < Math.abs(r))
      return s ? r > 0 ? U.create(e) : U.create("") : o;
    const _ = e.substr(0, f);
    return U.create(_);
  }
}
class tb extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 3);
    A(this, "maxParams", 255);
  }
  calculate(e, t, ...r) {
    const n = this._getDelimiterValues(e), s = this._getTextValues(r);
    if (t.isArray()) {
      const u = t.mapValue((c) => this._handleSingleObject(n, c, s));
      return u.getRowCount() === 1 && u.getColumnCount() === 1 ? u.get(0, 0) : u;
    }
    const o = t;
    if (o.isString()) {
      const u = `${o.getValue()}`.toLocaleUpperCase();
      if (u === "TRUE")
        return this._handleSingleObject(n, T.create(!0), s);
      if (u === "FALSE")
        return this._handleSingleObject(n, T.create(!1), s);
    }
    return this._handleSingleObject(n, t, s);
  }
  _handleSingleObject(e, t, r) {
    if (e instanceof g)
      return e;
    const { isError: n, errorObject: s, variants: o } = I(t);
    if (n)
      return s;
    if (r instanceof g)
      return r;
    const [u] = o, c = +u.getValue();
    let l = r;
    c && (l = r.filter((m) => m !== null && m !== ""));
    let f = "";
    for (let m = 0; m < l.length; m++)
      l[m] !== null && (f += l[m]), m < l.length - 1 && (f += e[m % e.length]);
    return U.create(f);
  }
  _getDelimiterValues(e) {
    const t = [], r = e.isArray() ? e.getRowCount() : 1, n = e.isArray() ? e.getColumnCount() : 1;
    for (let s = 0; s < r; s++)
      for (let o = 0; o < n; o++) {
        const u = e.isArray() ? e.get(s, o) : e;
        if (u.isError())
          return u;
        let c = `${u.getValue()}`;
        u.isNull() && (c = ""), u.isBoolean() && (c = c.toLocaleUpperCase()), t.push(c);
      }
    return t;
  }
  _getTextValues(e) {
    const t = [];
    for (const r of e) {
      const n = r.isArray() ? r.getRowCount() : 1, s = r.isArray() ? r.getColumnCount() : 1;
      for (let o = 0; o < n; o++)
        for (let u = 0; u < s; u++) {
          const c = r.isArray() ? r.get(o, u) : r;
          if (c.isError())
            return c;
          if (c.isNull()) {
            t.push(null);
            continue;
          }
          let l = `${c.getValue()}`;
          c.isBoolean() && (l = l.toLocaleUpperCase()), t.push(l);
        }
    }
    return t;
  }
}
class rb extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 2);
    A(this, "maxParams", 6);
  }
  calculate(e, t, r, n, s, o) {
    let u = r != null ? r : U.create("\\s");
    const c = n != null ? n : y.create(0), l = s != null ? s : y.create(0), f = o != null ? o : U.create(h.NA), { _variant: m, values: d } = this._getStringValues(t), { _variant: _, values: C } = this._getStringValues(u, !1);
    u = _;
    const E = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      c.isArray() ? c.getRowCount() : 1,
      l.isArray() ? l.getRowCount() : 1
    ), R = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      c.isArray() ? c.getColumnCount() : 1,
      l.isArray() ? l.getColumnCount() : 1
    ), b = O(E, R, e, g.create(h.NA)), p = O(E, R, c, g.create(h.NA)), V = O(E, R, l, g.create(h.NA)), S = this._getResultArray(
      b,
      m,
      u,
      p,
      V,
      f,
      d,
      C
    );
    return E === 1 && R === 1 ? S.get(0, 0) : S.map((M) => M.get(0, 0));
  }
  _getStringValues(e, t = !0) {
    let r = e;
    const n = [];
    if (r.isArray())
      r.iterator((s) => {
        if (s != null && s.isError())
          return r = s, !1;
        if (s != null && s.isNull() && t)
          return r = g.create(h.VALUE), !1;
        const o = this._getRegExpStringValue(s);
        if (o === "")
          return r = g.create(h.VALUE), !1;
        n.push(o);
      });
    else {
      r.isNull() && t && (r = g.create(h.VALUE));
      const s = this._getRegExpStringValue(r);
      s === "" && (r = g.create(h.VALUE)), n.push(s);
    }
    return {
      _variant: r,
      values: n
    };
  }
  _getResultArray(e, t, r, n, s, o, u, c) {
    return e.map((f, m, d) => {
      let _ = n.get(m, d), C = s.get(m, d);
      const E = this._checkVariantsError(f, t, r, _, C);
      if (E.isError())
        return E;
      if (f.isNull())
        return g.create(h.VALUE);
      let R = o;
      if (R.isArray()) {
        const M = R.getRowCount(), D = R.getColumnCount();
        if (M > 1 || D > 1)
          return g.create(h.VALUE);
        R = R.get(0, 0);
      }
      let b = `${f.getValue()}`;
      if (f.isBoolean() && (b = b.toLocaleUpperCase()), _.isString() && (_ = _.convertToNumberObjectValue(), _.isError()))
        return _;
      const p = Math.floor(+_.getValue());
      if (C.isString() && (C = C.convertToNumberObjectValue(), C.isError()))
        return C;
      const V = Math.floor(+C.getValue());
      if (V < 0 || V > 1)
        return g.create(h.VALUE);
      let S = `${R.getValue()}`;
      return R.isBoolean() && (S = S.toLocaleUpperCase()), this._getResult(b, u, c, p, V, S);
    });
  }
  _getResult(e, t, r, n, s, o) {
    const u = new RegExp(r.join("|"), `g${s ? "i" : ""}`), c = new RegExp(t.join("|"), `g${s ? "i" : ""}`), l = e.split(u);
    let f = 1, m = l.map((d) => {
      let _ = d.split(c);
      return n && (_ = _.filter((C) => C !== "")), f = Math.max(f, _.length), _;
    });
    return m = m.map((d) => {
      let _ = d;
      return _.length < f && (_ = _.concat(new Array(f - _.length).fill(o))), _;
    }), K.createByArray(m);
  }
  _checkVariantsError(...e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      if (r.isError())
        return r;
    }
    return T.create(!0);
  }
  _getRegExpStringValue(e) {
    let t = e.getValue();
    return e.isNull() && (t = "\\s"), e.isBoolean() && (t = t ? "TRUE" : "FALSE"), t += "", this._escapeRegExp(t);
  }
  _escapeRegExp(e) {
    return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
}
class nb extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isNull())
      return U.create("");
    let t = `${e.getValue()}`;
    return e.isBoolean() && (t = t.toLocaleUpperCase()), t = t.trim().replace(/\s+/g, " "), U.create(t);
  }
}
const sb = Object.values(Fe).filter((a) => [
  Fe.TABLE_START,
  Fe.TABLE_ROW_START,
  Fe.TABLE_CELL_START,
  Fe.TABLE_CELL_END,
  Fe.TABLE_ROW_END,
  Fe.TABLE_END,
  Fe.CUSTOM_BLOCK
].includes(a));
class ab extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    const { isError: t, errorObject: r, variants: n } = I(e);
    if (t)
      return r;
    const [s] = n, o = Math.floor(+s.getValue());
    if (o < 1 || o > 1114111)
      return g.create(h.VALUE);
    if (o === 1114111 || o === 1114110)
      return g.create(h.NA);
    let u = String.fromCharCode(o);
    return sb.some((c) => c === u) && (u = ""), U.create(u);
  }
}
class ib extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isNull())
      return g.create(h.VALUE);
    let t = e.getValue().toLocaleString();
    e.isBoolean() && (t = t.toLocaleUpperCase());
    const r = t.charCodeAt(0);
    return y.create(r);
  }
}
class ob extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isNull())
      return U.create("");
    const t = `${e.getValue()}`.toLocaleUpperCase();
    return U.create(t);
  }
}
class ub extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    if (e.isBoolean())
      return g.create(h.VALUE);
    let t = e;
    if (e.isString() && (t = t.convertToNumberObjectValue(), t.isError()))
      return t;
    const r = +t.getValue();
    return y.create(r);
  }
}
class cb extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 2);
  }
  calculate(e, t) {
    const r = t != null ? t : y.create(0), n = Math.max(
      e.isArray() ? e.getRowCount() : 1,
      r.isArray() ? r.getRowCount() : 1
    ), s = Math.max(
      e.isArray() ? e.getColumnCount() : 1,
      r.isArray() ? r.getColumnCount() : 1
    ), o = O(n, s, e, g.create(h.NA)), u = O(n, s, r, g.create(h.NA)), c = o.mapValue((l, f, m) => {
      const d = u.get(f, m);
      return l.isError() ? l : d.isError() ? d : this._handleSingleObject(l, d);
    });
    return n === 1 && s === 1 ? c.get(0, 0) : c;
  }
  _handleSingleObject(e, t) {
    const { isError: r, errorObject: n, variants: s } = I(t);
    if (r)
      return n;
    const [o] = s, u = Math.floor(+o.getValue());
    if (u < 0 || u > 1)
      return g.create(h.VALUE);
    if (e.isNull())
      return U.create("");
    if (e.isBoolean())
      return e;
    if (e.isNumber())
      return y.create(e.getValue());
    const c = u ? `"${e.getValue()}"` : `${e.getValue()}`;
    return U.create(c);
  }
}
const lb = [
  [aR, J.ASC],
  [sR, J.ARRAYTOTEXT],
  [iR, J.BAHTTEXT],
  [uR, J.CHAR],
  [cR, J.CLEAN],
  [lR, J.CODE],
  [fR, J.CONCAT],
  [mR, J.CONCATENATE],
  [hR, J.DBCS],
  [gR, J.DOLLAR],
  [dR, J.EXACT],
  [CR, J.FIND],
  [AR, J.FINDB],
  [ER, J.FIXED],
  [RR, J.LEFT],
  [bR, J.LEFTB],
  [yR, J.LEN],
  [pR, J.LENB],
  [NR, J.LOWER],
  [VR, J.MID],
  [OR, J.MIDB],
  [wR, J.NUMBERSTRING],
  [LR, J.NUMBERVALUE],
  [FR, J.REGEXEXTRACT],
  [kR, J.REGEXMATCH],
  [$R, J.REGEXREPLACE],
  [PR, J.PROPER],
  [YR, J.REPLACE],
  [HR, J.REPLACEB],
  [GR, J.REPT],
  [WR, J.RIGHT],
  [QR, J.RIGHTB],
  [qR, J.SEARCH],
  [XR, J.SEARCHB],
  [KR, J.SUBSTITUTE],
  [ZR, J.T],
  [zR, J.TEXT],
  [JR, J.TEXTAFTER],
  [eb, J.TEXTBEFORE],
  [tb, J.TEXTJOIN],
  [rb, J.TEXTSPLIT],
  [nb, J.TRIM],
  [ab, J.UNICHAR],
  [ib, J.UNICODE],
  [ob, J.UPPER],
  [ub, J.VALUE],
  [cb, J.VALUETOTEXT]
], fb = [];
var mb = /* @__PURE__ */ ((a) => a)(mb || {});
function no(a) {
  return a.map((i) => i.map((e) => typeof e == "number" ? Sa(e) : e));
}
function Qb(a, i = !1) {
  if (a.isReferenceObject()) {
    const e = a.toArrayValueObject().toValue();
    return i ? no(e) : e;
  } else if (a.isArray()) {
    const e = a.toValue();
    return i ? no(e) : e;
  } else if (a.isNumber()) {
    const e = a.getValue();
    return i ? Sa(e) : e;
  }
  return a.getValue();
}
class hb extends N {
  constructor() {
    super(...arguments);
    A(this, "minParams", 1);
    A(this, "maxParams", 1);
  }
  calculate(e) {
    if (e.isArray()) {
      const t = e.mapValue((r) => this._handleSingleObject(r));
      return t.getRowCount() === 1 && t.getColumnCount() === 1 ? t.get(0, 0) : t;
    }
    return this._handleSingleObject(e);
  }
  _handleSingleObject(e) {
    if (e.isError())
      return e;
    const t = Pe(e), r = encodeURIComponent(t).replace(/[!~'()*]/g, (n) => `%${n.charCodeAt(0).toString(16).toLocaleUpperCase()}`);
    return U.create(r);
  }
}
const gb = [
  [hb, ti.ENCODEURL]
];
class yc extends Se {
  constructor() {
    super(...arguments);
    A(this, "_allSubjects", []);
    A(this, "_computingStatus$", new mo(!0));
    A(this, "computingStatus$", this._computingStatus$.pipe(ho()));
    A(this, "_computingSubscription");
  }
  get computingStatus() {
    return this._computingStatus$.getValue();
  }
  dispose() {
    var e;
    super.dispose(), (e = this._computingSubscription) == null || e.unsubscribe(), this._computingStatus$.next(!0), this._computingStatus$.complete(), this._allSubjects.forEach((t) => {
      t.complete();
    });
  }
  pushComputingStatusSubject(e) {
    return this._allSubjects.push(e), this._updateComputingObservable(), {
      dispose: () => {
        const t = this._allSubjects.indexOf(e);
        t !== -1 && this._allSubjects.splice(t, 1), this._updateComputingObservable();
      }
    };
  }
  _updateComputingObservable() {
    var e;
    if ((e = this._computingSubscription) == null || e.unsubscribe(), this._allSubjects.length === 0) {
      this._computingStatus$.next(!0);
      return;
    }
    this._computingSubscription = Hc(this._allSubjects).pipe(Gc((t) => t.every((r) => r))).subscribe((t) => this._computingStatus$.next(t));
  }
}
var db = Object.getOwnPropertyDescriptor, Cb = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? db(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, so = (a, i) => (e, t) => i(e, t, a);
let ha = class extends Se {
  constructor(i, e) {
    super();
    A(this, "_computingCompleted$", new Wc((i) => {
      this._commandService.onCommandExecuted((e) => {
        if (e.id !== Sn.id) return;
        const t = e.params;
        if (t.stageInfo)
          return i.next(
            t.stageInfo.stage === tt.IDLE || t.stageInfo.stage === tt.CALCULATION_COMPLETED
          );
      });
    }).pipe(
      ho(),
      Qc()
    ));
    this._commandService = i, this._globalComputingSrv = e;
    const t = new Fc(), r = new mo(!0);
    t.add(this._globalComputingSrv.pushComputingStatusSubject(r)), t.add(this._computingCompleted$.subscribe((n) => r.next(n))), t.add(() => r.complete()), this.disposeWithMe(t);
  }
};
ha = Cb([
  so(0, lr),
  so(1, ye(yc))
], ha);
var _b = Object.getOwnPropertyDescriptor, Ab = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? _b(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, hn = (a, i) => (e, t) => i(e, t, a);
let Qn = class extends Se {
  constructor(a, i, e, t) {
    super(), this._commandService = a, this._functionService = i, this._configService = e, this._dataSyncPrimaryController = t, this._initialize();
  }
  _initialize() {
    this._registerCommands(), this._registerFunctions();
  }
  _registerCommands() {
    [
      Do,
      vs,
      wo,
      Oo,
      So,
      Sn,
      Mo,
      _a,
      Vo,
      Aa,
      Ea,
      Ra,
      ba,
      kl,
      $l,
      Lo,
      Sl
    ].forEach((a) => {
      var i;
      this._commandService.registerCommand(a), (i = this._dataSyncPrimaryController) == null || i.registerSyncingMutations(a);
    });
  }
  _registerFunctions() {
    var e;
    const a = this._configService.getConfig(pa), i = [
      ...jh,
      ...gg,
      ...dg,
      ...wg,
      ...g1,
      ...Ad,
      ...p0,
      ...Q0,
      ...hC,
      ...ZC,
      ...SA,
      ...jA,
      ...nR,
      ...lb,
      ...fb,
      ...gb
    ].concat((e = a == null ? void 0 : a.function) != null ? e : []).map((t) => {
      const r = t[0], n = t[1];
      return new r(n);
    });
    this._functionService.registerExecutors(...i);
  }
};
Qn = Ab([
  hn(0, lr),
  hn(1, Xt),
  hn(2, da),
  hn(3, kc(qc))
], Qn);
var Eb = Object.getOwnPropertyDescriptor, Rb = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Eb(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, gn = (a, i) => (e, t) => i(e, t, a);
let qn = class extends Se {
  constructor(a, i, e) {
    super(), this._commandService = a, this._dependencyManagerService = i, this._featureCalculationManagerService = e, this._initialize();
  }
  _initialize() {
    this._commandExecutedListener(), this._featureCalculationManagerServiceListener();
  }
  _featureCalculationManagerServiceListener() {
    this.disposeWithMe(
      this._featureCalculationManagerService.onChanged$.subscribe((a) => {
        const { unitId: i, subUnitId: e, featureIds: t } = a;
        this._dependencyManagerService.removeFeatureFormulaDependency(i, e, t);
      })
    );
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((a) => {
        if (a.id === Ea.id) {
          const i = a.params;
          if (i == null)
            return;
          const { featureIds: e, unitId: t, subUnitId: r } = i;
          this._dependencyManagerService.removeFeatureFormulaDependency(t, r, e);
        } else if (a.id === Aa.id) {
          const i = a.params;
          if (i == null)
            return;
          const { featureId: e, calculationParam: t } = i, { unitId: r, subUnitId: n } = t;
          this._dependencyManagerService.removeFeatureFormulaDependency(r, n, [e]);
        } else if (a.id === ba.id) {
          const i = a.params;
          if (i == null)
            return;
          this._dependencyManagerService.removeOtherFormulaDependency(i.unitId, i.subUnitId, i.formulaIdList);
        } else if (a.id === Ra.id) {
          const i = a.params;
          if (i == null)
            return;
          const e = i.formulaMap, t = [];
          Object.keys(e).forEach((r) => {
            t.push(r);
          }), this._dependencyManagerService.removeOtherFormulaDependency(i.unitId, i.subUnitId, t);
        } else if (a.id === Do.id) {
          const i = a.params.formulaData;
          Object.keys(i).forEach((e) => {
            const t = i[e];
            if (t !== void 0) {
              if (t === null) {
                this._dependencyManagerService.clearFormulaDependency(e);
                return;
              }
              Object.keys(t).forEach((r) => {
                const n = t[r];
                if (n !== void 0) {
                  if (n === null)
                    return this._dependencyManagerService.clearFormulaDependency(e, r), !0;
                  new de(n).forValue((s, o) => {
                    this._dependencyManagerService.removeFormulaDependency(e, r, s, o);
                  });
                }
              });
            }
          });
        } else a.id === _a.id && this._handleSetDefinedName(a);
      })
    );
  }
  _handleSetDefinedName(a) {
    const i = a.params;
    if (i == null)
      return;
    const { unitId: e, name: t } = i;
    this._dependencyManagerService.removeFormulaDependencyByDefinedName(e, t);
  }
};
qn = Rb([
  gn(0, lr),
  gn(1, Wr),
  gn(1, cs),
  gn(2, Wr)
], qn);
var bb = Object.getOwnPropertyDescriptor, yb = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? bb(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, ao = (a, i) => (e, t) => i(e, t, a);
let Xn = class extends Se {
  constructor(a, i) {
    super(), this._commandService = a, this._featureCalculationManagerService = i, this._initialize();
  }
  _initialize() {
    this._commandExecutedListener();
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((a) => {
        if (a.id === Aa.id) {
          const i = a.params;
          if (i == null)
            return;
          const { featureId: e, calculationParam: t } = i, { unitId: r, subUnitId: n } = t;
          this._featureCalculationManagerService.register(r, n, e, t);
        } else if (a.id === Ea.id) {
          const i = a.params;
          if (i == null)
            return;
          const { featureIds: e, unitId: t, subUnitId: r } = i;
          this._featureCalculationManagerService.remove(t, r, e);
        }
      })
    );
  }
};
Xn = yb([
  ao(0, lr),
  ao(1, Wr)
], Xn);
var pb = Object.getOwnPropertyDescriptor, Nb = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? pb(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, Ps = (a, i) => (e, t) => i(e, t, a);
let Kn = class extends Se {
  constructor(a, i, e) {
    super(), this._commandService = a, this._otherFormulaManagerService = i, this._dependencyManagerService = e, this._initialize();
  }
  _initialize() {
    this._commandExecutedListener();
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((a) => {
        if (a.id === Ra.id) {
          const i = a.params;
          if (i == null)
            return;
          const e = { [i.unitId]: { [i.subUnitId]: i.formulaMap } };
          this._otherFormulaManagerService.batchRegister(e);
        } else if (a.id === ba.id) {
          const i = a.params;
          if (i == null)
            return;
          const e = {};
          i.formulaIdList.forEach((r) => e[r] = !0);
          const t = { [i.unitId]: { [i.subUnitId]: e } };
          this._otherFormulaManagerService.batchRemove(t);
        }
      })
    );
  }
};
Kn = Nb([
  Ps(0, lr),
  Ps(1, ja),
  Ps(2, cs)
], Kn);
var Vb = Object.getOwnPropertyDescriptor, Ob = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Vb(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, io = (a, i) => (e, t) => i(e, t, a);
let Zn = class extends Se {
  constructor(a, i) {
    super(), this._commandService = a, this._superTableService = i, this._initialize();
  }
  _initialize() {
    this._commandExecutedListener();
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((a) => {
        if (a.id === _a.id) {
          const i = a.params;
          if (i == null)
            return;
          const { unitId: e, tableName: t, reference: r } = i;
          this._superTableService.registerTable(e, t, r);
        } else if (a.id === Vo.id) {
          const i = a.params;
          if (i == null)
            return;
          const { unitId: e, tableName: t } = i;
          this._superTableService.remove(e, t);
        } else if (a.id === Lo.id) {
          const i = a.params;
          if (i == null)
            return;
          const { tableOption: e, tableOptionType: t } = i;
          this._superTableService.registerTableOptionMap(e, t);
        }
      })
    );
  }
};
Zn = Ob([
  io(0, lr),
  io(1, Pr)
], Zn);
class Sb extends Se {
  constructor() {
    super(...arguments);
    A(this, "_dirtyConversionMap", /* @__PURE__ */ new Map());
  }
  dispose() {
    this._dirtyConversionMap.clear();
  }
  remove(e) {
    this._dirtyConversionMap.delete(e);
  }
  get(e) {
    return this._dirtyConversionMap.get(e);
  }
  has(e) {
    return this._dirtyConversionMap.has(e);
  }
  register(e, t) {
    this._dirtyConversionMap.set(e, t);
  }
  getDirtyConversionMap() {
    return this._dirtyConversionMap;
  }
}
const Mb = Je(
  "univer.formula.active-dirty-manager.service"
);
var Db = Object.getOwnPropertyDescriptor, wb = (a, i, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Db(i, e) : i, n = a.length - 1, s; n >= 0; n--)
    (s = a[n]) && (r = s(r) || r);
  return r;
}, oo = (a, i) => (e, t) => i(e, t, a);
const Lb = "UNIVER_ENGINE_FORMULA_PLUGIN";
var xs;
let uo = (xs = class extends $c {
  constructor(a = Vi, i, e) {
    super(), this._config = a, this._injector = i, this._configService = e;
    const { ...t } = Yc(
      {},
      Vi,
      this._config
    );
    this._configService.setConfig(pa, t);
  }
  onStarting() {
    this._initialize(), this._initializeWithOverride();
  }
  onReady() {
    var a;
    Es(this._injector, [
      [Qn],
      [Zn]
    ]), (a = this._config) != null && a.notExecuteFormula || Es(this._injector, [
      [Kn],
      [Xn],
      [qn],
      [$n]
    ]);
  }
  onRendered() {
    var a;
    (a = this._config) != null && a.notExecuteFormula || Es(this._injector, [
      [oa],
      [aa]
    ]);
  }
  _initialize() {
    const a = !this._config.notExecuteFormula, i = [
      // Services
      [Xt, { useClass: km }],
      [Lr, { useClass: Fs }],
      [Mb, { useClass: Sb }],
      [Xo, { useClass: ta }],
      [jo, { useClass: Kl }],
      [Pr, { useClass: Fl }],
      [yc],
      // Models
      [yr],
      //Controllers
      [Qn],
      [Zn],
      [ha]
    ];
    a && i.push(
      // Services
      [ja, { useClass: yh }],
      [Nt, { useClass: ra }],
      [Wt, { useClass: Hs }],
      [Wr, { useClass: bh }],
      //Controller
      [$n],
      [Kn],
      [qn],
      [Xn],
      // Calculation engine
      [Vr],
      [Gr],
      [pr],
      // AstNode factory
      [Ko],
      [vn],
      [Tn],
      [ru],
      [In],
      [Un],
      [Bn],
      [Fn],
      [kn],
      [nu]
    ), i.forEach((e) => this._injector.add(e));
  }
  _initializeWithOverride() {
    var a;
    this._injector.add([Mn, { useClass: Mn }]), (a = this._config) != null && a.notExecuteFormula || [
      [oa, { useClass: ua }],
      [cs, { useClass: Rh }],
      [aa, { useClass: ia }]
    ].forEach((e) => this._injector.add(e));
  }
}, A(xs, "pluginName", Lb), xs);
uo = wb([
  oo(1, ye(fo)),
  oo(2, da)
], uo);
export {
  Sb as ActiveDirtyManagerService,
  K as ArrayValueObject,
  Ko as AstRootNodeFactory,
  Gr as AstTreeBuilder,
  Om as AsyncArrayObject,
  Hb as AsyncCustomFunction,
  Vm as AsyncObject,
  N as BaseFunction,
  jr as BaseReferenceObject,
  Qt as BaseValueObject,
  ir as BooleanValue,
  T as BooleanValueObject,
  $n as CalculateController,
  ua as CalculateFormulaService,
  _g as CustomFunction,
  Sh as DEFAULT_INTERVAL_COUNT,
  Fr as DEFAULT_TOKEN_LAMBDA_FUNCTION_NAME,
  Nl as DEFAULT_TOKEN_LET_FUNCTION_NAME,
  Rr as DEFAULT_TOKEN_TYPE_LAMBDA_PARAMETER,
  At as DEFAULT_TOKEN_TYPE_PARAMETER,
  Ft as DEFAULT_TOKEN_TYPE_ROOT,
  Fs as DefinedNamesService,
  Eh as DependencyManagerBaseService,
  Rh as DependencyManagerService,
  kb as ENGINE_FORMULA_CYCLE_REFERENCE_COUNT,
  pa as ENGINE_FORMULA_PLUGIN_CONFIG_KEY,
  fr as ERROR_TYPE_SET,
  h as ErrorType,
  g as ErrorValueObject,
  ca as FUNCTION_NAMES_ARRAY,
  fe as FUNCTION_NAMES_COMPATIBILITY,
  Cg as FUNCTION_NAMES_CUBE,
  Xe as FUNCTION_NAMES_DATABASE,
  Ae as FUNCTION_NAMES_DATE,
  Q as FUNCTION_NAMES_ENGINEERING,
  ee as FUNCTION_NAMES_FINANCIAL,
  Ve as FUNCTION_NAMES_INFORMATION,
  Ee as FUNCTION_NAMES_LOGICAL,
  re as FUNCTION_NAMES_LOOKUP,
  F as FUNCTION_NAMES_MATH,
  P as FUNCTION_NAMES_STATISTICAL,
  J as FUNCTION_NAMES_TEXT,
  mb as FUNCTION_NAMES_UNIVER,
  ti as FUNCTION_NAMES_WEB,
  bh as FeatureCalculationManagerService,
  Hs as FormulaCurrentConfigService,
  yr as FormulaDataModel,
  ia as FormulaDependencyGenerator,
  Ms as FormulaDependencyTree,
  sa as FormulaDependencyTreeType,
  Hi as FormulaDependencyTreeVirtual,
  tt as FormulaExecuteStageType,
  Ir as FormulaExecutedStateType,
  ra as FormulaRuntimeService,
  vn as FunctionNodeFactory,
  km as FunctionService,
  Kc as FunctionType,
  yc as GlobalComputingStatusService,
  ta as HyperlinkEngineFormulaService,
  Mb as IActiveDirtyManagerService,
  oa as ICalculateFormulaService,
  Lr as IDefinedNamesService,
  cs as IDependencyManagerService,
  Wr as IFeatureCalculationManagerService,
  Wt as IFormulaCurrentConfigService,
  aa as IFormulaDependencyGenerator,
  Nt as IFormulaRuntimeService,
  Xt as IFunctionService,
  Xo as IHyperlinkEngineFormulaService,
  ja as IOtherFormulaManagerService,
  jo as ISheetRowFilteredService,
  Pr as ISuperTableService,
  Vr as Interpreter,
  Tn as LambdaNodeFactory,
  ru as LambdaParameterNodeFactory,
  xa as LambdaValueObjectObject,
  pr as Lexer,
  ie as LexerNode,
  Mn as LexerTreeBuilder,
  Wb as NEW_EXCEL_FUNCTIONS,
  ce as NullValueObject,
  y as NumberValueObject,
  Mt as OPERATOR_TOKEN_SET,
  In as OperatorNodeFactory,
  yh as OtherFormulaManagerService,
  Un as PrefixNodeFactory,
  xn as RangeReferenceObject,
  Bn as ReferenceNodeFactory,
  Sl as RegisterFunctionMutation,
  Vo as RemoveDefinedNameMutation,
  Ea as RemoveFeatureCalculationMutation,
  ba as RemoveOtherFormulaMutation,
  $l as RemoveSuperTableMutation,
  Rs as SUFFIX_TOKEN_SET,
  vs as SetArrayFormulaDataMutation,
  _a as SetDefinedNameMutation,
  Fb as SetDefinedNameMutationFactory,
  Aa as SetFeatureCalculationMutation,
  Sn as SetFormulaCalculationNotificationMutation,
  Mo as SetFormulaCalculationResultMutation,
  Oo as SetFormulaCalculationStartMutation,
  So as SetFormulaCalculationStopMutation,
  Do as SetFormulaDataMutation,
  wo as SetImageFormulaDataMutation,
  Ra as SetOtherFormulaMutation,
  kl as SetSuperTableMutation,
  Lo as SetSuperTableOptionMutation,
  Kl as SheetRowFilteredService,
  U as StringValueObject,
  Fn as SuffixNodeFactory,
  Fl as SuperTableService,
  kn as UnionNodeFactory,
  uo as UniverFormulaEnginePlugin,
  nu as ValueNodeFactory,
  Pt as ValueObjectFactory,
  Y as compareToken,
  yl as convertUnitDataToRuntime,
  wh as deserializeRangeForR1C1,
  kr as deserializeRangeWithSheet,
  br as deserializeRangeWithSheetWithCache,
  $b as extractFormulaError,
  jh as functionArray,
  gg as functionCompatibility,
  dg as functionCube,
  wg as functionDatabase,
  g1 as functionDate,
  Ad as functionEngineering,
  p0 as functionFinancial,
  Q0 as functionInformation,
  hC as functionLogical,
  ZC as functionLookup,
  SA as functionMath,
  jA as functionMeta,
  nR as functionStatistical,
  lb as functionText,
  fb as functionUniver,
  gb as functionWeb,
  Ti as generateAstNode,
  Bi as generateExecuteAstNodeData,
  gr as generateRandomDependencyTreeId,
  yi as generateStringWithSequence,
  Ib as getAbsoluteRefTypeWitString,
  _n as getAbsoluteRefTypeWithSingleString,
  Qb as getObjectValue,
  Bb as getRangeWithRefsString,
  Yb as handleNumfmtInCell,
  Ca as handleRefStringInfo,
  Jc as includeFormulaLexerToken,
  Ni as initSheetFormulaData,
  Cn as isFormulaLexerToken,
  Xc as isInDirtyRange,
  bo as isReferenceString,
  An as isReferenceStringWithEffectiveColumn,
  xl as isReferenceStrings,
  Tb as matchRefDrawToken,
  X as matchToken,
  Is as needsQuoting,
  vb as normalizeSheetName,
  Z as operatorToken,
  we as prefixToken,
  Bs as quoteSheetName,
  He as sequenceNodeType,
  Yt as serializeRange,
  Ts as serializeRangeToRefString,
  wl as serializeRangeWithSheet,
  Ll as serializeRangeWithSpreadsheet,
  bs as singleReferenceToGrid,
  ji as strip,
  Sa as stripErrorMargin,
  bi as unquoteSheetName
};
