var Et = Object.defineProperty;
var Mt = (s, a, e) => a in s ? Et(s, a, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[a] = e;
var m = (s, a, e) => Mt(s, typeof a != "symbol" ? a + "" : a, e);
import { Inject as v, ICommandService as B, IUniverInstanceService as I, Disposable as x, ObjectMatrix as Me, getIntersectRange as ot, UniverInstanceType as N, Range as U, Rectangle as w, isFormulaString as S, getOriginCellValue as Vt, Injector as be, numfmt as L, DataValidationType as T, RBush as yt, debounce as Tt, Tools as M, DataValidationStatus as b, WrapStrategy as Se, DataValidationOperator as h, dayjs as nt, DataValidationRenderMode as We, CommandType as z, IUndoRedoService as Z, sequenceExecute as Le, isRangesEqual as lt, IPermissionService as Ft, generateRandomId as Xe, toDisposable as Ke, CellValueType as Ct, RxDisposable as Nt, LifecycleService as Ot, LifecycleStages as et, bufferDebounceTime as wt, DependentOn as At, IConfigService as It, Plugin as Dt, merge as bt } from "@univerjs/core";
import { DataValidationModel as ce, DataValidatorRegistryService as G, UpdateRuleType as V, BaseDataValidator as Y, TextLengthErrorTitleMap as Lt, AddDataValidationMutation as D, RemoveDataValidationMutation as A, UpdateDataValidationMutation as y, getRuleSetting as Ut, getRuleOptions as Bt, UniverDataValidationPlugin as xt } from "@univerjs/data-validation";
import { ERROR_TYPE_SET as Pt, LexerTreeBuilder as X, isReferenceString as ut, sequenceNodeType as Ht, deserializeRangeWithSheet as Wt, deserializeRangeWithSheetWithCache as $t, operatorToken as kt } from "@univerjs/engine-formula";
import { SetRangeValuesMutation as ne, RemoveSheetMutation as dt, getSheetCommandTarget as ze, SetRangeValuesUndoMutationFactory as ct, WorksheetViewPermission as jt, RefRangeService as Qt, handleCommonDefaultRangeChangeWithEffectRefCommands as qt, SheetInterceptorService as ht, RemoveSheetCommand as Gt, CopySheetCommand as Yt, SheetsSelectionsService as mt, ClearSelectionAllCommand as Xt } from "@univerjs/sheets";
import { Subject as Ye, bufferWhen as Kt, filter as tt } from "rxjs";
import { RegisterOtherFormulaService as gt, FormulaRefRangeService as pt } from "@univerjs/sheets-formula";
var zt = Object.getOwnPropertyDescriptor, Zt = (s, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? zt(a, e) : a, i = s.length - 1, o; i >= 0; i--)
    (o = s[i]) && (r = o(r) || r);
  return r;
}, $e = (s, a) => (e, t) => a(e, t, s);
let Q = class extends x {
  constructor(a, e, t) {
    super();
    m(this, "_cacheMatrix", /* @__PURE__ */ new Map());
    m(this, "_dirtyRanges$", new Ye());
    m(this, "dirtyRanges$", this._dirtyRanges$.asObservable());
    this._commandService = a, this._univerInstanceService = e, this._sheetDataValidationModel = t, this._initDirtyRanges(), this._initSheetRemove();
  }
  _initDirtyRanges() {
    this.disposeWithMe(this._commandService.onCommandExecuted((a, e) => {
      if (a.id === ne.id && !(e != null && e.onlyLocal)) {
        const { cellValue: t, unitId: r, subUnitId: i } = a.params;
        if (t) {
          const o = new Me(t).getDataRange();
          if (o.endRow === -1) return;
          const u = this._sheetDataValidationModel.getRules(r, i).map((d) => d.ranges).flat().map((d) => ot(d, o)).filter(Boolean);
          u.length && this.markRangeDirty(r, i, u, !0);
        }
      }
    }));
  }
  _initSheetRemove() {
    this.disposeWithMe(this._commandService.onCommandExecuted((a) => {
      var e;
      if (a.id === dt.id) {
        const { unitId: t, subUnitId: r } = a.params;
        (e = this._cacheMatrix.get(t)) == null || e.delete(r);
      }
    })), this.disposeWithMe(this._univerInstanceService.unitDisposed$.subscribe((a) => {
      a.type === N.UNIVER_SHEET && this._cacheMatrix.delete(a.getUnitId());
    }));
  }
  _ensureCache(a, e) {
    let t = this._cacheMatrix.get(a);
    t || (t = /* @__PURE__ */ new Map(), this._cacheMatrix.set(a, t));
    let r = t.get(e);
    return r || (r = new Me(), t.set(e, r)), r;
  }
  ensureCache(a, e) {
    return this._ensureCache(a, e);
  }
  addRule(a, e, t) {
    this.markRangeDirty(a, e, t.ranges);
  }
  removeRule(a, e, t) {
    this._deleteRange(a, e, t.ranges);
  }
  markRangeDirty(a, e, t, r) {
    const i = this._ensureCache(a, e);
    t.forEach((o) => {
      U.foreach(o, (n, l) => {
        i.getValue(n, l) !== void 0 && i.setValue(n, l, void 0);
      });
    }), this._dirtyRanges$.next({ unitId: a, subUnitId: e, ranges: t, isSetRange: r });
  }
  _deleteRange(a, e, t) {
    const r = this._ensureCache(a, e);
    t.forEach((i) => {
      U.foreach(i, (o, n) => {
        r.realDeleteValue(o, n);
      });
    }), this._dirtyRanges$.next({ unitId: a, subUnitId: e, ranges: t });
  }
  getValue(a, e, t, r) {
    return this._ensureCache(a, e).getValue(t, r);
  }
};
Q = Zt([
  $e(0, v(B)),
  $e(1, v(I)),
  $e(2, v(ce))
], Q);
function oe(s) {
  var a, e;
  return (e = (a = s == null ? void 0 : s[0]) == null ? void 0 : a[0]) == null ? void 0 : e.v;
}
function _e(s) {
  var a;
  return (a = s == null ? void 0 : s[0]) == null ? void 0 : a[0];
}
function F(s) {
  return !Pt.has(s);
}
function he(s, a) {
  var t;
  const e = a.getValidatorItem(s);
  return (t = e == null ? void 0 : e.offsetFormulaByRange) != null ? t : !1;
}
var Jt = Object.getOwnPropertyDescriptor, ea = (s, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Jt(a, e) : a, i = s.length - 1, o; i >= 0; i--)
    (o = s[i]) && (r = o(r) || r);
  return r;
}, se = (s, a) => (e, t) => a(e, t, s);
let W = class extends x {
  constructor(a, e, t, r, i) {
    super();
    /**
     * Map of origin formula of rule
     */
    m(this, "_ruleFormulaMap", /* @__PURE__ */ new Map());
    m(this, "_ruleFormulaMap2", /* @__PURE__ */ new Map());
    this._instanceSrv = a, this._registerOtherFormulaService = e, this._dataValidationModel = t, this._dataValidationCacheService = r, this._validatorRegistryService = i, this._initFormulaResultHandler(), this._initDirtyRanges();
  }
  dispose() {
    super.dispose(), this._ruleFormulaMap.clear(), this._ruleFormulaMap2.clear();
  }
  _initFormulaResultHandler() {
    this.disposeWithMe(this._registerOtherFormulaService.formulaResult$.subscribe((a) => {
      for (const e in a) {
        const t = a[e];
        if (this._instanceSrv.getUnitType(e) === N.UNIVER_SHEET)
          for (const i in t) {
            const o = t[i], { ruleFormulaMap: n } = this._ensureMaps(e, i);
            o.forEach((l) => {
              var c, g;
              const u = n.get((c = l.extra) == null ? void 0 : c.ruleId), d = this._dataValidationModel.getRuleById(e, i, (g = l.extra) == null ? void 0 : g.ruleId);
              d && u && this._dataValidationCacheService.markRangeDirty(e, i, d.ranges);
            });
          }
      }
    }));
  }
  _ensureMaps(a, e) {
    let t = this._ruleFormulaMap.get(a), r = this._ruleFormulaMap2.get(a);
    t || (t = /* @__PURE__ */ new Map(), this._ruleFormulaMap.set(a, t)), r || (r = /* @__PURE__ */ new Map(), this._ruleFormulaMap2.set(a, r));
    let i = t.get(e);
    i || (i = /* @__PURE__ */ new Map(), t.set(e, i));
    let o = r.get(e);
    return o || (o = /* @__PURE__ */ new Map(), r.set(e, o)), { ruleFormulaMap: i, ruleFormulaMap2: o };
  }
  _registerFormula(a, e, t, r, i) {
    return this._registerOtherFormulaService.registerFormulaWithRange(a, e, r, i, { ruleId: t });
  }
  _handleDirtyRanges(a, e, t) {
    this._dataValidationModel.getRules(a, e).forEach((i) => {
      const o = i.ranges;
      w.doAnyRangesIntersect(o, t) && this.makeRuleDirty(a, e, i.uid);
    });
  }
  _initDirtyRanges() {
    this.disposeWithMe(this._dataValidationCacheService.dirtyRanges$.subscribe((a) => {
      a.isSetRange && this._handleDirtyRanges(a.unitId, a.subUnitId, a.ranges);
    }));
  }
  deleteByRuleId(a, e, t) {
    const { ruleFormulaMap: r, ruleFormulaMap2: i } = this._ensureMaps(a, e), o = this._dataValidationModel.getRuleById(a, e, t), n = r.get(t);
    if (!o || !n)
      return;
    const l = r.get(t);
    l && (r.delete(t), this._registerOtherFormulaService.deleteFormula(a, e, [l.formulaId]));
    const u = i.get(t);
    u && (i.delete(t), this._registerOtherFormulaService.deleteFormula(a, e, [u.formulaId]));
  }
  _addFormulaByRange(a, e, t, r, i, o) {
    const { ruleFormulaMap: n, ruleFormulaMap2: l } = this._ensureMaps(a, e), u = o[0].startRow, d = o[0].startColumn;
    if (r && S(r)) {
      const c = this._registerFormula(a, e, t, r, o);
      n.set(t, {
        formula: r,
        originCol: d,
        originRow: u,
        formulaId: c
      });
    }
    if (i && S(i)) {
      const c = this._registerFormula(a, e, t, i, o);
      l.set(t, {
        formula: i,
        originCol: d,
        originRow: u,
        formulaId: c
      });
    }
  }
  addRule(a, e, t) {
    if (he(t.type, this._validatorRegistryService)) {
      const { ranges: r, formula1: i, formula2: o, uid: n } = t;
      this._addFormulaByRange(a, e, n, i, o, r);
    }
  }
  async getCellFormulaValue(a, e, t, r, i) {
    var _, f;
    const { ruleFormulaMap: o } = this._ensureMaps(a, e), n = o.get(t);
    if (!n)
      return Promise.resolve(void 0);
    const l = await this._registerOtherFormulaService.getFormulaValue(a, e, n.formulaId), { originRow: u, originCol: d } = n, c = r - u, g = i - d;
    return _e((f = (_ = l == null ? void 0 : l.result) == null ? void 0 : _[c]) == null ? void 0 : f[g]);
  }
  async getCellFormula2Value(a, e, t, r, i) {
    var _, f;
    const { ruleFormulaMap2: o } = this._ensureMaps(a, e), n = o.get(t);
    if (!n)
      return Promise.resolve(void 0);
    const l = await this._registerOtherFormulaService.getFormulaValue(a, e, n.formulaId), { originRow: u, originCol: d } = n, c = r - u, g = i - d;
    return _e((f = (_ = l == null ? void 0 : l.result) == null ? void 0 : _[c]) == null ? void 0 : f[g]);
  }
  getCellFormulaValueSync(a, e, t, r, i) {
    var _, f;
    const { ruleFormulaMap: o } = this._ensureMaps(a, e), n = o.get(t);
    if (!n)
      return;
    const l = this._registerOtherFormulaService.getFormulaValueSync(a, e, n.formulaId), { originRow: u, originCol: d } = n, c = r - u, g = i - d;
    return _e((f = (_ = l == null ? void 0 : l.result) == null ? void 0 : _[c]) == null ? void 0 : f[g]);
  }
  getCellFormula2ValueSync(a, e, t, r, i) {
    var _, f;
    const { ruleFormulaMap2: o } = this._ensureMaps(a, e), n = o.get(t);
    if (!n)
      return;
    const l = this._registerOtherFormulaService.getFormulaValueSync(a, e, n.formulaId), { originRow: u, originCol: d } = n, c = r - u, g = i - d;
    return _e((f = (_ = l == null ? void 0 : l.result) == null ? void 0 : _[c]) == null ? void 0 : f[g]);
  }
  getRuleFormulaInfo(a, e, t) {
    const { ruleFormulaMap: r } = this._ensureMaps(a, e);
    return r.get(t);
  }
  makeRuleDirty(a, e, t) {
    var o, n, l, u;
    const r = (n = (o = this._ruleFormulaMap.get(a)) == null ? void 0 : o.get(e)) == null ? void 0 : n.get(t), i = (u = (l = this._ruleFormulaMap2.get(a)) == null ? void 0 : l.get(e)) == null ? void 0 : u.get(t);
    r && this._registerOtherFormulaService.markFormulaDirty(a, e, r.formulaId), i && this._registerOtherFormulaService.markFormulaDirty(a, e, i.formulaId);
  }
};
W = ea([
  se(0, I),
  se(1, v(gt)),
  se(2, v(ce)),
  se(3, v(Q)),
  se(4, v(G))
], W);
function re(s) {
  return Vt(s);
}
function ft(s) {
  var a;
  return String((a = re(s)) != null ? a : "");
}
function er(s) {
  return s.filter(Boolean).join(",");
}
function Ee(s) {
  return s.split(",").filter(Boolean);
}
function tr(s) {
  const a = re(s);
  return a == null ? "" : a.toString();
}
function Ue(s, a, e) {
  const { formula1: t, formula2: r } = a, i = a.ranges[0].startRow, o = a.ranges[0].startColumn, n = e.row - i, l = e.col - o, u = S(t) ? s.moveFormulaRefOffset(t, l, n, !0) : t, d = S(r) ? s.moveFormulaRefOffset(r, l, n, !0) : r;
  return {
    transformedFormula1: u,
    transformedFormula2: d
  };
}
var ta = Object.getOwnPropertyDescriptor, aa = (s, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? ta(a, e) : a, i = s.length - 1, o; i >= 0; i--)
    (o = s[i]) && (r = o(r) || r);
  return r;
}, at = (s, a) => (e, t) => a(e, t, s);
let le = class extends x {
  constructor(a, e) {
    super();
    // Cache structure: unitId -> subUnitId -> ruleId -> cache item
    m(this, "_cache", /* @__PURE__ */ new Map());
    this._injector = a, this._dataValidationModel = e, this._initRuleChangeListener();
  }
  _initRuleChangeListener() {
    this.disposeWithMe(
      this._dataValidationModel.ruleChange$.subscribe((a) => {
        (a.type === "remove" || a.type === "update") && this.markRuleDirty(a.unitId, a.subUnitId, a.rule.uid);
      })
    );
  }
  /**
   * Get cached list data or compute and cache it if not exists.
   */
  getOrCompute(a, e, t) {
    const r = this.getCache(a, e, t.uid);
    if (r)
      return r;
    const o = this._injector.get(q).getRuleFormulaResultSync(a, e, t.uid);
    return this.computeAndCache(a, e, t, o);
  }
  _ensureCache(a, e) {
    let t = this._cache.get(a);
    t || (t = /* @__PURE__ */ new Map(), this._cache.set(a, t));
    let r = t.get(e);
    return r || (r = /* @__PURE__ */ new Map(), t.set(e, r)), r;
  }
  /**
   * Get cached list data for a rule. Returns undefined if not cached.
   */
  getCache(a, e, t) {
    var r, i;
    return (i = (r = this._cache.get(a)) == null ? void 0 : r.get(e)) == null ? void 0 : i.get(t);
  }
  /**
   * Set cache for a rule.
   */
  setCache(a, e, t, r) {
    this._ensureCache(a, e).set(t, r);
  }
  /**
   * Mark a rule's cache as dirty (invalidate it).
   * Called when formula results change.
   */
  markRuleDirty(a, e, t) {
    var r, i;
    (i = (r = this._cache.get(a)) == null ? void 0 : r.get(e)) == null || i.delete(t);
  }
  /**
   * Clear all caches.
   */
  clear() {
    this._cache.clear();
  }
  /**
   * Compute list data from formula result and cache it.
   */
  computeAndCache(a, e, t, r) {
    var _, f, R;
    const { formula1: i = "", formula2: o = "" } = t, n = S(i) ? this._getRuleFormulaResultSet((R = (f = (_ = r == null ? void 0 : r[0]) == null ? void 0 : _.result) == null ? void 0 : f[0]) == null ? void 0 : R[0]) : Ee(i), l = o.split(","), u = n.map((E, p) => ({ label: E, color: l[p] || "" })), d = {};
    for (const E of u)
      E.color && (d[E.label] = E.color);
    const c = new Set(n), g = { list: n, listWithColor: u, colorMap: d, set: c };
    return this.setCache(a, e, t.uid, g), g;
  }
  /**
   * Extract string list from formula result cells.
   */
  _getRuleFormulaResultSet(a) {
    var t, r;
    if (!a)
      return [];
    const e = /* @__PURE__ */ new Set();
    for (let i = 0, o = a.length; i < o; i++) {
      const n = a[i];
      if (n)
        for (let l = 0, u = n.length; l < u; l++) {
          const d = n[l], c = re(d);
          if (c != null) {
            if (typeof c != "string" && typeof (d == null ? void 0 : d.s) == "object" && ((r = (t = d.s) == null ? void 0 : t.n) != null && r.pattern)) {
              e.add(L.format(d.s.n.pattern, c, { throws: !1 }));
              continue;
            }
            const g = typeof c == "string" ? c : String(c);
            F(g) && e.add(g);
          }
        }
    }
    return [...e];
  }
};
le = aa([
  at(0, v(be)),
  at(1, v(ce))
], le);
var ra = Object.getOwnPropertyDescriptor, ia = (s, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? ra(a, e) : a, i = s.length - 1, o; i >= 0; i--)
    (o = s[i]) && (r = o(r) || r);
  return r;
}, ee = (s, a) => (e, t) => a(e, t, s);
let q = class extends x {
  constructor(a, e, t, r, i, o) {
    super();
    m(this, "_formulaRuleMap", /* @__PURE__ */ new Map());
    this._instanceService = a, this._registerOtherFormulaService = e, this._dataValidationCacheService = t, this._dataValidationModel = r, this._validatorRegistryService = i, this._listCacheService = o, this._initFormulaResultHandler();
  }
  _initFormulaResultHandler() {
    this.disposeWithMe(this._registerOtherFormulaService.formulaResult$.subscribe((a) => {
      for (const e in a) {
        const t = a[e];
        if (this._instanceService.getUnitType(e) === N.UNIVER_SHEET)
          for (const i in t) {
            const o = t[i], n = this._ensureRuleFormulaMap(e, i);
            o.forEach((l) => {
              var d;
              const u = (d = l.extra) == null ? void 0 : d.ruleId;
              if (u && n.get(u)) {
                const c = this._dataValidationModel.getRuleById(e, i, u);
                c && (this._listCacheService.markRuleDirty(e, i, u), this._dataValidationCacheService.markRangeDirty(e, i, c.ranges));
              }
            });
          }
      }
    }));
  }
  _ensureRuleFormulaMap(a, e) {
    let t = this._formulaRuleMap.get(a);
    t || (t = /* @__PURE__ */ new Map(), this._formulaRuleMap.set(a, t));
    let r = t.get(e);
    return r || (r = /* @__PURE__ */ new Map(), t.set(e, r)), r;
  }
  _registerSingleFormula(a, e, t, r) {
    const i = [{ startColumn: 0, endColumn: 0, startRow: 0, endRow: 0 }];
    return this._registerOtherFormulaService.registerFormulaWithRange(a, e, t, i, { ruleId: r });
  }
  addRule(a, e, t) {
    if (!he(t.type, this._validatorRegistryService) && t.type !== T.CHECKBOX) {
      const { formula1: r, formula2: i, uid: o } = t, n = S(r), l = S(i);
      if (!n && !l)
        return;
      const u = this._ensureRuleFormulaMap(a, e), d = [void 0, void 0];
      if (n) {
        const c = this._registerSingleFormula(a, e, r, o);
        d[0] = { id: c, text: r };
      }
      if (l) {
        const c = this._registerSingleFormula(a, e, i, o);
        d[1] = { id: c, text: i };
      }
      u.set(o, d);
    }
  }
  removeRule(a, e, t) {
    const i = this._ensureRuleFormulaMap(a, e).get(t);
    if (!i)
      return;
    const [o, n] = i, l = [o == null ? void 0 : o.id, n == null ? void 0 : n.id].filter(Boolean);
    l.length && this._registerOtherFormulaService.deleteFormula(a, e, l);
  }
  getRuleFormulaResult(a, e, t) {
    const i = this._ensureRuleFormulaMap(a, e).get(t);
    if (!i)
      return Promise.resolve(null);
    const o = async (n) => n && this._registerOtherFormulaService.getFormulaValue(a, e, n.id);
    return Promise.all([
      o(i[0]),
      o(i[1])
    ]);
  }
  getRuleFormulaResultSync(a, e, t) {
    const i = this._ensureRuleFormulaMap(a, e).get(t);
    if (i)
      return i.map((o) => {
        if (o)
          return this._registerOtherFormulaService.getFormulaValueSync(a, e, o.id);
      });
  }
  getRuleFormulaInfo(a, e, t) {
    return this._ensureRuleFormulaMap(a, e).get(t);
  }
};
q = ia([
  ee(0, I),
  ee(1, v(gt)),
  ee(2, v(Q)),
  ee(3, v(ce)),
  ee(4, v(G)),
  ee(5, v(le))
], q);
class Ze {
  constructor(a, e, t, r, i = !1) {
    m(this, "_map");
    m(this, "_tree", new yt());
    m(this, "_dirty", !0);
    m(this, "_buildTree", () => {
      if (!this._dirty || this._disableTree)
        return;
      this._tree.clear();
      const a = [];
      this._map.forEach((e, t) => {
        e.forEach((r) => {
          a.push({
            minX: r.startRow,
            maxX: r.endRow,
            minY: r.startColumn,
            maxY: r.endColumn,
            ruleId: t
          });
        });
      }), this._tree.load(a), this._dirty = !1;
    });
    m(this, "_debonceBuildTree", Tt(this._buildTree, 0));
    this._unitId = e, this._subUnitId = t, this._univerInstanceService = r, this._disableTree = i, this._map = a, this._buildTree();
  }
  get _worksheet() {
    var a;
    return (a = this._univerInstanceService.getUnit(this._unitId, N.UNIVER_SHEET)) == null ? void 0 : a.getSheetBySheetId(this._subUnitId);
  }
  _addRule(a, e) {
    if (!this._worksheet)
      return;
    const t = w.mergeRanges(e.map((r) => U.transformRange(r, this._worksheet)));
    this._map.forEach((r, i) => {
      const o = w.subtractMulti(r, t);
      o.length === 0 ? this._map.delete(i) : this._map.set(i, o);
    }), this._dirty = !0, this._map.set(a, t), this._debonceBuildTree();
  }
  addRule(a) {
    this._addRule(a.uid, a.ranges);
  }
  removeRange(a) {
    if (!this._worksheet)
      return;
    const e = a.map((t) => U.transformRange(t, this._worksheet));
    this._map.forEach((t, r) => {
      const i = w.subtractMulti(t, e);
      i.length === 0 ? this._map.delete(r) : this._map.set(r, i);
    }), this._dirty = !0, this._debonceBuildTree();
  }
  _removeRule(a) {
    this._map.delete(a), this._dirty = !0, this._debonceBuildTree();
  }
  removeRule(a) {
    this._removeRule(a.uid);
  }
  updateRange(a, e) {
    this._removeRule(a), this._addRule(a, e);
  }
  addRangeRules(a) {
    a.forEach(({ id: e, ranges: t }) => {
      if (!t.length)
        return;
      let r = this._map.get(e);
      r ? (this._map.set(e, w.mergeRanges([...r, ...t])), r = this._map.get(e)) : (r = t, this._map.set(e, r)), this._map.forEach((i, o) => {
        if (o === e)
          return;
        const n = w.subtractMulti(i, t);
        n.length === 0 ? this._map.delete(o) : this._map.set(o, n);
      });
    }), this._dirty = !0, this._debonceBuildTree();
  }
  diff(a) {
    const e = [];
    let t = 0;
    return a.forEach((r, i) => {
      var l;
      const o = (l = this._map.get(r.uid)) != null ? l : [], n = r.ranges;
      o.length !== 0 && (o.length !== n.length || o.some((u, d) => !w.equals(u, n[d]))) && e.push({
        type: "update",
        ruleId: r.uid,
        oldRanges: n,
        newRanges: w.sort(o),
        rule: r
      }), o.length === 0 && (e.push({
        type: "delete",
        rule: r,
        index: i - t
      }), t++);
    }), e;
  }
  diffWithAddition(a, e) {
    const t = [];
    let r = 0;
    return a.forEach((i, o) => {
      var u;
      const n = (u = this._map.get(i.uid)) != null ? u : [], l = i.ranges;
      n.length !== 0 && (n.length !== l.length || n.some((d, c) => !w.equals(d, l[c]))) && t.push({
        type: "update",
        ruleId: i.uid,
        oldRanges: l,
        newRanges: w.sort(n),
        rule: i
      }), n.length === 0 && (t.push({
        type: "delete",
        rule: i,
        index: o - r
      }), r++);
    }), Array.from(e).forEach((i) => {
      var n;
      const o = (n = this._map.get(i.uid)) != null ? n : [];
      t.push({
        type: "add",
        rule: {
          ...i,
          ranges: w.sort(o)
        }
      });
    }), t;
  }
  clone() {
    return new Ze(
      new Map(M.deepClone(Array.from(this._map.entries()))),
      this._unitId,
      this._subUnitId,
      this._univerInstanceService,
      // disable tree on cloned matrix, cause there is no need to search
      !0
    );
  }
  getValue(a, e) {
    this._dirty && this._buildTree();
    const t = this._tree.search({
      minX: a,
      maxX: a,
      minY: e,
      maxY: e
    });
    return t.length > 0 ? t[0].ruleId : void 0;
  }
}
var sa = Object.getOwnPropertyDescriptor, oa = (s, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? sa(a, e) : a, i = s.length - 1, o; i >= 0; i--)
    (o = s[i]) && (r = o(r) || r);
  return r;
}, K = (s, a) => (e, t) => a(e, t, s);
let C = class extends x {
  constructor(a, e, t, r, i, o, n) {
    super();
    m(this, "_ruleMatrixMap", /* @__PURE__ */ new Map());
    m(this, "_validStatusChange$", new Ye());
    m(this, "_ruleChange$", new Ye());
    m(this, "ruleChange$", this._ruleChange$.asObservable());
    m(this, "validStatusChange$", this._validStatusChange$.asObservable());
    this._dataValidationModel = a, this._univerInstanceService = e, this._dataValidatorRegistryService = t, this._dataValidationCacheService = r, this._dataValidationFormulaService = i, this._dataValidationCustomFormulaService = o, this._commandService = n, this._initRuleUpdateListener(), this.disposeWithMe(() => {
      this._ruleChange$.complete(), this._validStatusChange$.complete();
    }), this._initUniverInstanceListener();
  }
  _initUniverInstanceListener() {
    this.disposeWithMe(
      this._univerInstanceService.unitDisposed$.subscribe((a) => {
        this._ruleMatrixMap.delete(a.getUnitId());
      })
    ), this.disposeWithMe(
      this._commandService.onCommandExecuted((a) => {
        if (a.id === dt.id) {
          const { unitId: e, subUnitId: t } = a.params, r = this._ruleMatrixMap.get(e);
          r && r.delete(t);
        }
      })
    );
  }
  _initRuleUpdateListener() {
    const a = this._dataValidationModel.getAll();
    for (const [e, t] of a)
      for (const [r, i] of t)
        for (const o of i)
          this._addRule(e, r, o), this._ruleChange$.next({
            type: "add",
            unitId: e,
            subUnitId: r,
            rule: o,
            source: "patched"
          });
    this.disposeWithMe(
      this._dataValidationModel.ruleChange$.subscribe((e) => {
        switch (e.type) {
          case "add":
            this._addRule(e.unitId, e.subUnitId, e.rule);
            break;
          case "update":
            this._updateRule(e.unitId, e.subUnitId, e.rule.uid, e.oldRule, e.updatePayload);
            break;
          case "remove":
            this._removeRule(e.unitId, e.subUnitId, e.rule);
            break;
        }
        this._ruleChange$.next(e);
      })
    );
  }
  _ensureRuleMatrix(a, e) {
    let t = this._ruleMatrixMap.get(a);
    t || (t = /* @__PURE__ */ new Map(), this._ruleMatrixMap.set(a, t));
    let r = t.get(e);
    return r || (r = new Ze(/* @__PURE__ */ new Map(), a, e, this._univerInstanceService), t.set(e, r)), r;
  }
  _addRuleSideEffect(a, e, t) {
    this._ensureRuleMatrix(a, e).addRule(t), this._dataValidationCacheService.addRule(a, e, t), this._dataValidationFormulaService.addRule(a, e, t), this._dataValidationCustomFormulaService.addRule(a, e, t);
  }
  _addRule(a, e, t) {
    (Array.isArray(t) ? t : [t]).forEach((i) => {
      this._addRuleSideEffect(a, e, i);
    });
  }
  _updateRule(a, e, t, r, i) {
    const o = this._ensureRuleMatrix(a, e), n = {
      ...r,
      ...i.payload
    };
    i.type === V.RANGE ? o.updateRange(t, i.payload) : i.type === V.ALL && o.updateRange(t, i.payload.ranges), this._dataValidationCacheService.removeRule(a, e, r), this._dataValidationCacheService.addRule(a, e, n), this._dataValidationFormulaService.removeRule(a, e, r.uid), this._dataValidationFormulaService.addRule(a, e, n), this._dataValidationCustomFormulaService.deleteByRuleId(a, e, t), this._dataValidationCustomFormulaService.addRule(a, e, n);
  }
  _removeRule(a, e, t) {
    this._ensureRuleMatrix(a, e).removeRule(t), this._dataValidationCacheService.removeRule(a, e, t), this._dataValidationCustomFormulaService.deleteByRuleId(a, e, t.uid);
  }
  getValidator(a) {
    return this._dataValidatorRegistryService.getValidatorItem(a);
  }
  getRuleIdByLocation(a, e, t, r) {
    return this._ensureRuleMatrix(a, e).getValue(t, r);
  }
  getRuleByLocation(a, e, t, r) {
    const i = this.getRuleIdByLocation(a, e, t, r);
    if (i)
      return this._dataValidationModel.getRuleById(a, e, i);
  }
  validator(a, e, t) {
    const { col: r, row: i, unitId: o, subUnitId: n, worksheet: l } = e, u = (f, R) => {
      t && t(f, R), R && this._validStatusChange$.next({
        unitId: o,
        subUnitId: n,
        ruleId: a.uid,
        status: f,
        row: i,
        col: r
      });
    }, d = l.getCellValueOnly(i, r), c = this.getValidator(a.type), g = l.getCellRaw(i, r), _ = re(g);
    if (c) {
      const f = this._dataValidationCacheService.ensureCache(o, n), R = f.getValue(i, r);
      return R == null ? (f.setValue(i, r, b.VALIDATING), c.validator(
        {
          value: _,
          unitId: o,
          subUnitId: n,
          row: i,
          column: r,
          worksheet: e.worksheet,
          workbook: e.workbook,
          interceptValue: re(d),
          t: g == null ? void 0 : g.t
        },
        a
      ).then((E) => {
        const p = E ? b.VALID : b.INVALID, O = f.getValue(i, r);
        p === b.VALID ? f.realDeleteValue(i, r) : f.setValue(i, r, p), u(p, R !== O);
      }), b.VALIDATING) : (u(R != null ? R : b.VALID, !1), R != null ? R : b.VALID);
    } else
      return u(b.VALID, !1), b.VALID;
  }
  getRuleObjectMatrix(a, e) {
    return this._ensureRuleMatrix(a, e);
  }
  getRuleById(a, e, t) {
    return this._dataValidationModel.getRuleById(a, e, t);
  }
  getRuleIndex(a, e, t) {
    return this._dataValidationModel.getRuleIndex(a, e, t);
  }
  getRules(a, e) {
    return [...this._dataValidationModel.getRules(a, e)];
  }
  getUnitRules(a) {
    return this._dataValidationModel.getUnitRules(a);
  }
  deleteUnitRules(a) {
    return this._dataValidationModel.deleteUnitRules(a);
  }
  getSubUnitIds(a) {
    return this._dataValidationModel.getSubUnitIds(a);
  }
  getAll() {
    return this._dataValidationModel.getAll();
  }
};
C = oa([
  K(0, v(ce)),
  K(1, I),
  K(2, v(G)),
  K(3, v(Q)),
  K(4, v(q)),
  K(5, v(W)),
  K(6, B)
], C);
const Ve = 1, ye = 0;
function rt(s, a) {
  return M.isBlank(s) ? a.t("dataValidation.validFail.value") : S(s) ? a.t("dataValidation.validFail.primitive") : "";
}
const ve = (s) => M.isDefine(s) && String(s).toLowerCase() === "true" ? "1" : String(s).toLowerCase() === "false" ? "0" : s;
class na extends Y {
  constructor() {
    super(...arguments);
    m(this, "id", T.CHECKBOX);
    m(this, "title", "dataValidation.checkbox.title");
    m(this, "operators", []);
    m(this, "scopes", ["sheet"]);
    m(this, "order", 41);
    m(this, "offsetFormulaByRange", !1);
    m(this, "_formulaService", this.injector.get(q));
    m(this, "skipDefaultFontRender", (e, t, r) => {
      const { unitId: i, subUnitId: o } = r, { formula1: n, formula2: l } = this.parseFormulaSync(e, i, o), u = `${t != null ? t : ""}`;
      return !u || u === `${n}` || u === `${l}`;
    });
  }
  validatorFormula(e, t, r) {
    const { formula1: i, formula2: o } = e, n = i === o;
    if (M.isBlank(i) && M.isBlank(o))
      return {
        success: !0
      };
    if (n)
      return {
        success: !1,
        formula1: this.localeService.t("dataValidation.validFail.checkboxEqual"),
        formula2: this.localeService.t("dataValidation.validFail.checkboxEqual")
      };
    const l = rt(i, this.localeService), u = rt(o, this.localeService);
    return {
      success: !l && !u,
      formula1: l,
      formula2: u
    };
  }
  async parseFormula(e, t, r) {
    var c, g, _, f;
    const { formula1: i = Ve, formula2: o = ye } = e, n = await this._formulaService.getRuleFormulaResult(t, r, e.uid), l = S(i) ? oe((g = (c = n == null ? void 0 : n[0]) == null ? void 0 : c.result) == null ? void 0 : g[0][0]) : i, u = S(o) ? oe((f = (_ = n == null ? void 0 : n[1]) == null ? void 0 : _.result) == null ? void 0 : f[0][0]) : o, d = F(String(l)) && F(String(u));
    return {
      formula1: ve(l),
      formula2: ve(u),
      originFormula1: l,
      originFormula2: u,
      isFormulaValid: d
    };
  }
  getExtraStyle(e, t) {
    return {
      tb: Se.CLIP
    };
  }
  parseFormulaSync(e, t, r) {
    var c, g, _, f;
    const { formula1: i = Ve, formula2: o = ye } = e, n = this._formulaService.getRuleFormulaResultSync(t, r, e.uid), l = S(i) ? oe((g = (c = n == null ? void 0 : n[0]) == null ? void 0 : c.result) == null ? void 0 : g[0][0]) : i, u = S(o) ? oe((f = (_ = n == null ? void 0 : n[1]) == null ? void 0 : _.result) == null ? void 0 : f[0][0]) : o, d = F(String(l)) && F(String(u));
    return {
      formula1: ve(l),
      formula2: ve(u),
      originFormula1: l,
      originFormula2: u,
      isFormulaValid: d
    };
  }
  async isValidType(e, t, r) {
    const { value: i, unitId: o, subUnitId: n } = e, { formula1: l, formula2: u, originFormula1: d, originFormula2: c } = await this.parseFormula(r, o, n);
    return !M.isDefine(l) || !M.isDefine(u) ? !0 : M.isDefine(i) && (String(i) === String(l) || String(i) === String(u) || String(i) === String(d != null ? d : "") || String(i) === String(c != null ? c : ""));
  }
  generateRuleErrorMessage(e) {
    return this.localeService.t("dataValidation.checkbox.error");
  }
  generateRuleName(e) {
    return this.titleStr;
  }
}
const la = {
  [h.BETWEEN]: "dataValidation.date.operators.between",
  [h.EQUAL]: "dataValidation.date.operators.equal",
  [h.GREATER_THAN]: "dataValidation.date.operators.greaterThan",
  [h.GREATER_THAN_OR_EQUAL]: "dataValidation.date.operators.greaterThanOrEqual",
  [h.LESS_THAN]: "dataValidation.date.operators.lessThan",
  [h.LESS_THAN_OR_EQUAL]: "dataValidation.date.operators.lessThanOrEqual",
  [h.NOT_BETWEEN]: "dataValidation.date.operators.notBetween",
  [h.NOT_EQUAL]: "dataValidation.date.operators.notEqual"
};
h.BETWEEN + "", h.EQUAL + "", h.GREATER_THAN + "", h.GREATER_THAN_OR_EQUAL + "", h.LESS_THAN + "", h.LESS_THAN_OR_EQUAL + "", h.NOT_BETWEEN + "", h.NOT_EQUAL + "";
const it = {
  [h.BETWEEN]: "dataValidation.date.ruleName.between",
  [h.EQUAL]: "dataValidation.date.ruleName.equal",
  [h.GREATER_THAN]: "dataValidation.date.ruleName.greaterThan",
  [h.GREATER_THAN_OR_EQUAL]: "dataValidation.date.ruleName.greaterThanOrEqual",
  [h.LESS_THAN]: "dataValidation.date.ruleName.lessThan",
  [h.LESS_THAN_OR_EQUAL]: "dataValidation.date.ruleName.lessThanOrEqual",
  [h.NOT_BETWEEN]: "dataValidation.date.ruleName.notBetween",
  [h.NOT_EQUAL]: "dataValidation.date.ruleName.notEqual",
  NONE: "dataValidation.date.ruleName.legal"
}, ua = {
  [h.BETWEEN]: "dataValidation.date.errorMsg.between",
  [h.EQUAL]: "dataValidation.date.errorMsg.equal",
  [h.GREATER_THAN]: "dataValidation.date.errorMsg.greaterThan",
  [h.GREATER_THAN_OR_EQUAL]: "dataValidation.date.errorMsg.greaterThanOrEqual",
  [h.LESS_THAN]: "dataValidation.date.errorMsg.lessThan",
  [h.LESS_THAN_OR_EQUAL]: "dataValidation.date.errorMsg.lessThanOrEqual",
  [h.NOT_BETWEEN]: "dataValidation.date.errorMsg.notBetween",
  [h.NOT_EQUAL]: "dataValidation.date.errorMsg.notEqual",
  NONE: "dataValidation.date.errorMsg.legal"
}, Be = [
  h.BETWEEN,
  h.NOT_BETWEEN
], ue = "{FORMULA1}", de = "{FORMULA2}", ke = (s) => {
  var e, t;
  if (s == null || typeof s == "boolean")
    return;
  if (typeof s == "number" || !Number.isNaN(+s))
    return +s;
  const a = (e = L.parseDate(s)) == null ? void 0 : e.v;
  return M.isDefine(a) ? a : (t = L.parseDate(nt(s).format("YYYY-MM-DD HH:mm:ss"))) == null ? void 0 : t.v;
};
class da extends Y {
  constructor() {
    super(...arguments);
    m(this, "id", T.DATE);
    m(this, "title", "dataValidation.date.title");
    m(this, "order", 40);
    m(this, "operators", [
      h.BETWEEN,
      h.EQUAL,
      h.GREATER_THAN,
      h.GREATER_THAN_OR_EQUAL,
      h.LESS_THAN,
      h.LESS_THAN_OR_EQUAL,
      h.NOT_BETWEEN,
      h.NOT_EQUAL
    ]);
    m(this, "scopes", ["sheet"]);
    m(this, "_customFormulaService", this.injector.get(W));
    m(this, "_lexerTreeBuilder", this.injector.get(X));
  }
  async parseFormula(e, t, r, i, o) {
    const n = await this._customFormulaService.getCellFormulaValue(t, r, e.uid, i, o), l = await this._customFormulaService.getCellFormula2Value(t, r, e.uid, i, o), { formula1: u, formula2: d } = e, c = F(String(n == null ? void 0 : n.v)) && F(String(l == null ? void 0 : l.v));
    return {
      formula1: ke(S(u) ? n == null ? void 0 : n.v : u),
      formula2: ke(S(d) ? l == null ? void 0 : l.v : d),
      isFormulaValid: c
    };
  }
  async isValidType(e) {
    const { interceptValue: t, value: r } = e;
    return typeof r == "number" && typeof t == "string" ? !!L.parseDate(t) : typeof t == "string" ? !!L.parseDate(t) : !1;
  }
  _validatorSingleFormula(e) {
    return !M.isBlank(e) && (S(e) || !Number.isNaN(+e) || !!(e && L.parseDate(e)));
  }
  validatorFormula(e, t, r) {
    const i = e.operator;
    if (!i)
      return {
        success: !0
      };
    const o = this._validatorSingleFormula(e.formula1), n = this.localeService.t("dataValidation.validFail.date");
    if (Be.includes(i)) {
      const u = this._validatorSingleFormula(e.formula2);
      return {
        success: o && u,
        formula1: o ? void 0 : n,
        formula2: u ? void 0 : n
      };
    }
    return {
      success: o,
      formula1: o ? void 0 : n
    };
  }
  normalizeFormula(e, t, r) {
    const { formula1: i, formula2: o, bizInfo: n } = e, l = (u) => {
      var c;
      if (!u)
        return u;
      let d;
      if (!Number.isNaN(+u))
        d = L.dateFromSerial(+u);
      else {
        const g = (c = L.parseDate(u)) == null ? void 0 : c.v;
        if (g == null)
          return "";
        d = L.dateFromSerial(g);
      }
      return nt(`${d[0]}/${d[1]}/${d[2]} ${d[3]}:${d[4]}:${d[5]}`).format(n != null && n.showTime ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD");
    };
    return {
      formula1: S(i) ? i : l(`${i}`),
      formula2: S(o) ? o : l(`${o}`)
    };
  }
  transform(e, t, r) {
    const { value: i } = e;
    return {
      ...e,
      value: ke(i)
    };
  }
  get operatorNames() {
    return this.operators.map((e) => this.localeService.t(la[e]));
  }
  generateRuleName(e) {
    var r, i;
    if (!e.operator)
      return this.localeService.t(it.NONE);
    const t = this.localeService.t(it[e.operator]).replace(ue, (r = e.formula1) != null ? r : "").replace(de, (i = e.formula2) != null ? i : "");
    return `${this.titleStr} ${t}`;
  }
  generateRuleErrorMessage(e, t) {
    if (!e.operator)
      return this.titleStr;
    const { transformedFormula1: r, transformedFormula2: i } = Ue(this._lexerTreeBuilder, e, t);
    return `${this.localeService.t(ua[e.operator]).replace(ue, r != null ? r : "").replace(de, i != null ? i : "")}`;
  }
}
h.BETWEEN + "", h.EQUAL + "", h.GREATER_THAN + "", h.GREATER_THAN_OR_EQUAL + "", h.LESS_THAN + "", h.LESS_THAN_OR_EQUAL + "", h.NOT_BETWEEN + "", h.NOT_EQUAL + "";
h.BETWEEN + "", h.EQUAL + "", h.GREATER_THAN + "", h.GREATER_THAN_OR_EQUAL + "", h.LESS_THAN + "", h.LESS_THAN_OR_EQUAL + "", h.NOT_BETWEEN + "", h.NOT_EQUAL + "";
const Te = {
  [h.BETWEEN]: "dataValidation.errorMsg.between",
  [h.EQUAL]: "dataValidation.errorMsg.equal",
  [h.GREATER_THAN]: "dataValidation.errorMsg.greaterThan",
  [h.GREATER_THAN_OR_EQUAL]: "dataValidation.errorMsg.greaterThanOrEqual",
  [h.LESS_THAN]: "dataValidation.errorMsg.lessThan",
  [h.LESS_THAN_OR_EQUAL]: "dataValidation.errorMsg.lessThanOrEqual",
  [h.NOT_BETWEEN]: "dataValidation.errorMsg.notBetween",
  [h.NOT_EQUAL]: "dataValidation.errorMsg.notEqual",
  NONE: "dataValidation.errorMsg.legal"
};
function Fe(s) {
  return +s;
}
class ca extends Y {
  constructor() {
    super(...arguments);
    m(this, "_customFormulaService", this.injector.get(W));
    m(this, "id", T.DECIMAL);
    m(this, "_lexerTreeBuilder", this.injector.get(X));
    m(this, "title", "dataValidation.decimal.title");
    m(this, "order", 20);
    m(this, "operators", [
      h.BETWEEN,
      h.EQUAL,
      h.GREATER_THAN,
      h.GREATER_THAN_OR_EQUAL,
      h.LESS_THAN,
      h.LESS_THAN_OR_EQUAL,
      h.NOT_BETWEEN,
      h.NOT_EQUAL
    ]);
    m(this, "scopes", ["sheet"]);
  }
  _isFormulaOrNumber(e) {
    return !M.isBlank(e) && (S(e) || !Number.isNaN(+e));
  }
  async isValidType(e, t, r) {
    const { value: i } = e;
    return !Number.isNaN(Fe(i));
  }
  transform(e, t, r) {
    const { value: i } = e;
    return {
      ...e,
      value: Fe(i)
    };
  }
  _parseNumber(e) {
    return e == null ? Number.NaN : +e;
  }
  async parseFormula(e, t, r, i, o) {
    const n = await this._customFormulaService.getCellFormulaValue(t, r, e.uid, i, o), l = await this._customFormulaService.getCellFormula2Value(t, r, e.uid, i, o), { formula1: u, formula2: d } = e, c = F(String(n == null ? void 0 : n.v)) && F(String(l == null ? void 0 : l.v));
    return {
      formula1: this._parseNumber(S(u) ? n == null ? void 0 : n.v : u),
      formula2: this._parseNumber(S(d) ? l == null ? void 0 : l.v : d),
      isFormulaValid: c
    };
  }
  validatorFormula(e, t, r) {
    const i = e.operator;
    if (!i)
      return {
        success: !0
      };
    const o = M.isDefine(e.formula1) && this._isFormulaOrNumber(e.formula1), n = M.isDefine(e.formula2) && this._isFormulaOrNumber(e.formula2), l = Be.includes(i), u = this.localeService.t("dataValidation.validFail.number");
    return l ? {
      success: o && n,
      formula1: o ? void 0 : u,
      formula2: n ? void 0 : u
    } : {
      success: o,
      formula1: o ? "" : u
    };
  }
  generateRuleErrorMessage(e, t) {
    if (!e.operator)
      return this.localeService.t(Te.NONE).replace("{TYPE}", this.titleStr);
    const { transformedFormula1: r, transformedFormula2: i } = Ue(this._lexerTreeBuilder, e, t);
    return `${this.localeService.t(Te[e.operator]).replace(ue, r != null ? r : "").replace(de, i != null ? i : "")}`;
  }
}
function ha(s) {
  var e, t;
  if (!s)
    return [];
  const a = /* @__PURE__ */ new Set();
  for (let r = 0, i = s.length; r < i; r++) {
    const o = s[r];
    if (o)
      for (let n = 0, l = o.length; n < l; n++) {
        const u = o[n], d = re(u);
        if (d != null) {
          if (typeof d != "string" && typeof (u == null ? void 0 : u.s) == "object" && ((t = (e = u.s) == null ? void 0 : e.n) != null && t.pattern)) {
            a.add(L.format(u.s.n.pattern, d, { throws: !1 }));
            continue;
          }
          const c = typeof d == "string" ? d : String(d);
          F(c) && a.add(c);
        }
      }
  }
  return [...a];
}
const ma = [
  "if",
  "indirect",
  "choose",
  "offset"
];
function ga(s, a) {
  if (!S(s) || ut(s.slice(1)))
    return !0;
  const t = a.sequenceNodesBuilder(s);
  return t && t.some((r) => typeof r == "object" && r.nodeType === Ht.FUNCTION && ma.indexOf(r.token.toLowerCase()) > -1);
}
function pa(s, a) {
  const { formula1: e = "", ranges: t } = s;
  if (ut(e.slice(1))) {
    const i = Wt(e.slice(1));
    if ((!i.sheetName || i.sheetName === a) && t.some((o) => w.intersects(o, i.range)))
      return !0;
  }
  return !1;
}
class _t extends Y {
  constructor() {
    super(...arguments);
    m(this, "formulaService", this.injector.get(q));
    m(this, "_lexer", this.injector.get(X));
    m(this, "_univerInstanceService", this.injector.get(I));
    m(this, "_listCacheService", this.injector.get(le));
    m(this, "order", 50);
    m(this, "offsetFormulaByRange", !1);
    m(this, "id", T.LIST);
    m(this, "title", "dataValidation.list.title");
    m(this, "operators", []);
    m(this, "scopes", ["sheet"]);
    m(this, "skipDefaultFontRender", (e) => e.renderMode !== We.TEXT);
  }
  validatorFormula(e, t, r) {
    var u, d, c;
    const i = !M.isBlank(e.formula1), o = ga((u = e.formula1) != null ? u : "", this._lexer), n = (c = (d = this._univerInstanceService.getUnit(t, N.UNIVER_SHEET)) == null ? void 0 : d.getSheetBySheetId(r)) == null ? void 0 : c.getName(), l = pa(e, n != null ? n : "");
    return {
      success: !!(i && o && !l),
      formula1: i ? o ? l ? this.localeService.t("dataValidation.validFail.listIntersects") : void 0 : this.localeService.t("dataValidation.validFail.listInvalid") : this.localeService.t("dataValidation.validFail.list")
    };
  }
  getExtraStyle(e, t, { style: r }) {
    var o;
    const i = (o = r.tb !== Se.OVERFLOW ? r.tb : Se.CLIP) != null ? o : Se.WRAP;
    if (e.type === T.LIST && (e.renderMode === We.ARROW || e.renderMode === We.TEXT)) {
      const n = this.getListWithColorMap(e), l = `${t != null ? t : ""}`, u = n[l];
      if (u)
        return {
          bg: {
            rgb: u
          },
          tb: i
        };
    }
    return {
      tb: i
    };
  }
  parseCellValue(e) {
    const t = e.toString();
    return Ee(t);
  }
  async parseFormula(e, t, r) {
    var l, u;
    const i = await this.formulaService.getRuleFormulaResult(t, r, e.uid), o = oe((u = (l = i == null ? void 0 : i[0]) == null ? void 0 : l.result) == null ? void 0 : u[0][0]);
    return {
      formula1: void 0,
      formula2: void 0,
      isFormulaValid: F(String(o))
    };
  }
  async isValidType(e, t, r) {
    const { value: i, unitId: o, subUnitId: n } = e, { formula1: l = "" } = r, u = S(l) ? this._listCacheService.getOrCompute(
      o,
      n,
      r
    ).list : Ee(l);
    return this.parseCellValue(i).every((c) => u.includes(c));
  }
  generateRuleName() {
    return this.localeService.t("dataValidation.list.name");
  }
  generateRuleErrorMessage() {
    return this.localeService.t("dataValidation.list.error");
  }
  _getUnitAndSubUnit(e, t) {
    var o, n;
    const r = (o = e ? this._univerInstanceService.getUniverSheetInstance(e) : void 0) != null ? o : this._univerInstanceService.getCurrentUnitForType(N.UNIVER_SHEET);
    if (!r) return null;
    const i = (n = t ? r.getSheetBySheetId(t) : void 0) != null ? n : r.getActiveSheet();
    return i ? {
      unitId: r.getUnitId(),
      subUnitId: i.getSheetId()
    } : null;
  }
  getList(e, t, r) {
    const i = this._getUnitAndSubUnit(t, r);
    if (!i) return [];
    const { unitId: o, subUnitId: n } = i;
    return this._listCacheService.getOrCompute(
      o,
      n,
      e
    ).list;
  }
  async getListAsync(e, t, r) {
    var d, c;
    const { formula1: i = "" } = e, o = this._getUnitAndSubUnit(t, r);
    if (!o) return [];
    const { unitId: n, subUnitId: l } = o, u = await this.formulaService.getRuleFormulaResult(n, l, e.uid);
    return S(i) ? ha((c = (d = u == null ? void 0 : u[0]) == null ? void 0 : d.result) == null ? void 0 : c[0][0]) : Ee(i);
  }
  getListWithColor(e, t, r) {
    const i = this._getUnitAndSubUnit(t, r);
    if (!i) return [];
    const { unitId: o, subUnitId: n } = i;
    return this._listCacheService.getOrCompute(
      o,
      n,
      e
    ).listWithColor;
  }
  getListWithColorMap(e, t, r) {
    const i = this._getUnitAndSubUnit(t, r);
    if (!i) return {};
    const { unitId: o, subUnitId: n } = i;
    return this._listCacheService.getOrCompute(
      o,
      n,
      e
    ).colorMap;
  }
}
class fa extends Y {
  constructor() {
    super(...arguments);
    m(this, "id", T.TEXT_LENGTH);
    m(this, "title", "dataValidation.textLength.title");
    m(this, "_lexerTreeBuilder", this.injector.get(X));
    m(this, "order", 30);
    m(this, "operators", [
      h.BETWEEN,
      h.EQUAL,
      h.GREATER_THAN,
      h.GREATER_THAN_OR_EQUAL,
      h.LESS_THAN,
      h.LESS_THAN_OR_EQUAL,
      h.NOT_BETWEEN,
      h.NOT_EQUAL
    ]);
    m(this, "scopes", ["sheet"]);
    m(this, "_customFormulaService", this.injector.get(W));
  }
  _isFormulaOrInt(e) {
    return !M.isBlank(e) && (S(e) || !Number.isNaN(+e) && Number.isInteger(+e));
  }
  validatorFormula(e, t, r) {
    const i = e.operator;
    if (!i)
      return {
        success: !1
      };
    const o = M.isDefine(e.formula1) && this._isFormulaOrInt(e.formula1), n = M.isDefine(e.formula2) && this._isFormulaOrInt(e.formula2), l = Be.includes(i), u = this.localeService.t("dataValidation.validFail.number");
    return l ? {
      success: o && n,
      formula1: o ? void 0 : u,
      formula2: n ? void 0 : u
    } : {
      success: o,
      formula1: u
    };
  }
  _parseNumber(e) {
    return e == null ? Number.NaN : +e;
  }
  async parseFormula(e, t, r, i, o) {
    const n = await this._customFormulaService.getCellFormulaValue(t, r, e.uid, i, o), l = await this._customFormulaService.getCellFormula2Value(t, r, e.uid, i, o), { formula1: u, formula2: d } = e, c = F(String(n == null ? void 0 : n.v)) && F(String(l == null ? void 0 : l.v));
    return {
      formula1: this._parseNumber(S(u) ? n == null ? void 0 : n.v : u),
      formula2: this._parseNumber(S(d) ? l == null ? void 0 : l.v : d),
      isFormulaValid: c
    };
  }
  transform(e, t, r) {
    return {
      ...e,
      value: e.value.toString().length
    };
  }
  async isValidType(e, t, r) {
    const { value: i } = e;
    return typeof i == "string" || typeof i == "number";
  }
  generateRuleErrorMessage(e, t) {
    if (!e.operator)
      return this.titleStr;
    const { transformedFormula1: r, transformedFormula2: i } = Ue(this._lexerTreeBuilder, e, t);
    return `${this.localeService.t(Lt[e.operator]).replace(ue, r != null ? r : "").replace(de, i != null ? i : "")}`;
  }
}
function vt(s) {
  var e, t;
  return s ? s.p ? !((t = (e = s.p.body) == null ? void 0 : e.dataStream) != null ? t : "").slice(0, -2).trim() : M.isBlank(s.v) : !0;
}
function xe(s, a, e, t, r = "command", i = !0) {
  const o = t.get(X), n = t.get(G), l = [], u = [], d = t.get(C), c = t.get(I), g = ze(c, { unitId: s, subUnitId: a });
  if (!g)
    return {
      redoMutations: l,
      undoMutations: u
    };
  const { worksheet: _ } = g, f = new Me();
  let R = !1;
  function E(p, O) {
    i && p.forEach(($) => {
      U.foreach($, (P, k) => {
        const H = _.getCellRaw(P, k), J = ft(H);
        (vt(H) || J === O) && !(H != null && H.p) && (R = !0, f.setValue(P, k, {
          v: O,
          p: null
        }));
      });
    });
  }
  if (e.forEach((p) => {
    switch (p.type) {
      case "delete":
        l.push({
          id: A.id,
          params: {
            unitId: s,
            subUnitId: a,
            ruleId: p.rule.uid,
            source: r
          }
        }), u.unshift({
          id: D.id,
          params: {
            unitId: s,
            subUnitId: a,
            rule: p.rule,
            index: p.index,
            source: r
          }
        });
        break;
      case "update": {
        if (he(p.rule.type, n)) {
          const $ = p.oldRanges[0].startRow, P = p.oldRanges[0].startColumn, k = p.newRanges[0].startRow, H = p.newRanges[0].startColumn, J = k - $, me = H - P, ge = S(p.rule.formula1) ? o.moveFormulaRefOffset(p.rule.formula1, me, J) : p.rule.formula1, pe = S(p.rule.formula2) ? o.moveFormulaRefOffset(p.rule.formula2, me, J) : p.rule.formula2;
          ge !== p.rule.formula1 || pe !== p.rule.formula2 || !lt(p.newRanges, p.oldRanges) ? (l.push({
            id: y.id,
            params: {
              unitId: s,
              subUnitId: a,
              ruleId: p.ruleId,
              payload: {
                type: V.ALL,
                payload: {
                  formula1: ge,
                  formula2: pe,
                  ranges: p.newRanges
                }
              }
            }
          }), u.unshift({
            id: y.id,
            params: {
              unitId: s,
              subUnitId: a,
              ruleId: p.ruleId,
              payload: {
                type: V.ALL,
                payload: {
                  formula1: p.rule.formula1,
                  formula2: p.rule.formula2,
                  ranges: p.oldRanges
                }
              }
            }
          })) : (l.push({
            id: y.id,
            params: {
              unitId: s,
              subUnitId: a,
              ruleId: p.ruleId,
              payload: {
                type: V.RANGE,
                payload: p.newRanges
              },
              source: r
            }
          }), u.unshift({
            id: y.id,
            params: {
              unitId: s,
              subUnitId: a,
              ruleId: p.ruleId,
              payload: {
                type: V.RANGE,
                payload: p.oldRanges
              },
              source: r
            }
          }));
        } else
          l.push({
            id: y.id,
            params: {
              unitId: s,
              subUnitId: a,
              ruleId: p.ruleId,
              payload: {
                type: V.RANGE,
                payload: p.newRanges
              },
              source: r
            }
          }), u.unshift({
            id: y.id,
            params: {
              unitId: s,
              subUnitId: a,
              ruleId: p.ruleId,
              payload: {
                type: V.RANGE,
                payload: p.oldRanges
              },
              source: r
            }
          });
        const O = d.getRuleById(s, a, p.ruleId);
        if (O && O.type === T.CHECKBOX) {
          const P = d.getValidator(T.CHECKBOX).parseFormulaSync(O, s, a);
          E(p.newRanges, P.formula2);
        }
        break;
      }
      case "add": {
        if (l.push({
          id: D.id,
          params: {
            unitId: s,
            subUnitId: a,
            rule: p.rule,
            source: r
          }
        }), u.unshift({
          id: A.id,
          params: {
            unitId: s,
            subUnitId: a,
            ruleId: p.rule.uid,
            source: r
          }
        }), p.rule.type === T.CHECKBOX) {
          const $ = d.getValidator(T.CHECKBOX).parseFormulaSync(p.rule, s, a);
          E(p.rule.ranges, $.originFormula2);
        }
        break;
      }
    }
  }), R) {
    const p = {
      id: ne.id,
      params: {
        unitId: s,
        subUnitId: a,
        cellValue: f.getData()
      }
    }, O = {
      id: ne.id,
      params: ct(t, p.params)
    };
    l.push(p), u.push(O);
  }
  return {
    redoMutations: l,
    undoMutations: u
  };
}
const _a = {
  type: z.COMMAND,
  id: "sheet.command.updateDataValidationRuleRange",
  handler(s, a) {
    if (!a)
      return !1;
    const { unitId: e, subUnitId: t, ranges: r, ruleId: i } = a, o = s.get(C), n = s.get(B), l = s.get(Z);
    if (!o.getRuleById(e, t, i))
      return !1;
    const d = o.getRuleObjectMatrix(e, t).clone();
    d.updateRange(i, r);
    const c = d.diff(o.getRules(e, t)), { redoMutations: g, undoMutations: _ } = xe(e, t, c, s);
    return l.pushUndoRedo({
      undoMutations: _,
      redoMutations: g,
      unitID: e
    }), Le(g, n), !0;
  }
}, va = {
  type: z.COMMAND,
  id: "sheet.command.addDataValidation",
  handler(s, a) {
    if (!a)
      return !1;
    const { unitId: e, subUnitId: t, rule: r } = a, i = s.get(C), o = s.get(B), n = s.get(Z), l = i.getRuleObjectMatrix(e, t).clone();
    l.addRule(r);
    const u = l.diff(i.getRules(e, t)), d = i.getValidator(r.type), c = {
      unitId: e,
      subUnitId: t,
      rule: {
        ...r,
        ...d == null ? void 0 : d.normalizeFormula(r, e, t)
      }
    }, { redoMutations: g, undoMutations: _ } = xe(e, t, u, s);
    return g.push({
      id: D.id,
      params: c
    }), _.unshift({
      id: A.id,
      params: {
        unitId: e,
        subUnitId: t,
        ruleId: r.uid
      }
    }), n.pushUndoRedo({
      unitID: e,
      redoMutations: g,
      undoMutations: _
    }), Le(g, o), !0;
  }
}, Ra = {
  type: z.COMMAND,
  id: "sheets.command.update-data-validation-setting",
  // eslint-disable-next-line max-lines-per-function
  handler(s, a) {
    if (!a)
      return !1;
    const e = s.get(B), t = s.get(Z), r = s.get(C), i = s.get(G), { unitId: o, subUnitId: n, ruleId: l, setting: u } = a, d = i.getValidatorItem(u.type);
    if (!d)
      return !1;
    const c = r.getRuleById(o, n, l);
    if (!c)
      return !1;
    const g = { ...c, ...u };
    if (!d.validatorFormula(g, o, n).success)
      return !1;
    const _ = {
      unitId: o,
      subUnitId: n,
      ruleId: l,
      payload: {
        type: V.SETTING,
        payload: {
          ...u,
          ...d.normalizeFormula(g, o, n)
        }
      }
    }, f = [{
      id: y.id,
      params: _
    }], R = {
      unitId: o,
      subUnitId: n,
      ruleId: l,
      payload: {
        type: V.SETTING,
        payload: Ut(c)
      }
    }, E = [{
      id: y.id,
      params: R
    }];
    if (u.type === T.CHECKBOX) {
      const O = c.ranges, $ = s.get(I), P = ze($, { unitId: o, subUnitId: n });
      if (P) {
        const k = new Me(), { worksheet: H } = P, { formula2: J = ye, formula1: me = Ve } = c, { formula2: ge = ye, formula1: pe = Ve } = u;
        let Pe = !1;
        if (O.forEach((fe) => {
          U.foreach(fe, (ie, He) => {
            const j = H.getCellRaw(ie, He), Je = ft(j);
            (vt(j) || Je === String(J)) && !(j != null && j.p) ? (k.setValue(ie, He, {
              v: ge,
              p: null
            }), Pe = !0) : Je === String(me) && !(j != null && j.p) && (k.setValue(ie, He, {
              v: pe,
              p: null
            }), Pe = !0);
          });
        }), Pe) {
          const fe = {
            id: ne.id,
            params: {
              unitId: o,
              subUnitId: n,
              cellValue: k.getData()
            }
          }, ie = {
            id: ne.id,
            params: ct(s, fe.params)
          };
          f.push(fe), E.push(ie);
        }
      }
    }
    return Le(f, e).result ? (t.pushUndoRedo({
      unitID: o,
      redoMutations: f,
      undoMutations: E
    }), !0) : !1;
  }
}, Sa = {
  type: z.COMMAND,
  id: "sheets.command.update-data-validation-options",
  handler(s, a) {
    if (!a)
      return !1;
    const e = s.get(B), t = s.get(Z), r = s.get(C), { unitId: i, subUnitId: o, ruleId: n, options: l } = a, u = r.getRuleById(i, o, n);
    if (!u)
      return !1;
    const d = {
      unitId: i,
      subUnitId: o,
      ruleId: n,
      payload: {
        type: V.OPTIONS,
        payload: l
      }
    }, c = [{
      id: y.id,
      params: d
    }], g = {
      unitId: i,
      subUnitId: o,
      ruleId: n,
      payload: {
        type: V.OPTIONS,
        payload: Bt(u)
      }
    }, _ = [{
      id: y.id,
      params: g
    }];
    return t.pushUndoRedo({
      unitID: i,
      redoMutations: c,
      undoMutations: _
    }), e.executeCommand(y.id, d), !0;
  }
}, Ea = {
  type: z.COMMAND,
  id: "sheets.command.clear-range-data-validation",
  handler(s, a) {
    if (!a)
      return !1;
    const { unitId: e, subUnitId: t, ranges: r } = a, i = s.get(B), o = s.get(I), n = ze(o, { unitId: e, subUnitId: t }), l = s.get(C);
    if (!n) return !1;
    const u = s.get(Z), d = l.getRuleObjectMatrix(e, t).clone();
    d.removeRange(r);
    const c = d.diff(l.getRules(e, t)), { redoMutations: g, undoMutations: _ } = xe(e, t, c, s);
    return u.pushUndoRedo({
      unitID: e,
      redoMutations: g,
      undoMutations: _
    }), Le(g, i).result;
  }
}, Ma = {
  type: z.COMMAND,
  id: "sheet.command.remove-all-data-validation",
  handler(s, a) {
    if (!a)
      return !1;
    const { unitId: e, subUnitId: t } = a, r = s.get(B), i = s.get(C), o = s.get(Z), n = [...i.getRules(e, t)], l = {
      unitId: e,
      subUnitId: t,
      ruleId: n.map((c) => c.uid)
    }, u = [{
      id: A.id,
      params: l
    }], d = [{
      id: D.id,
      params: {
        unitId: e,
        subUnitId: t,
        rule: n
      }
    }];
    return o.pushUndoRedo({
      redoMutations: u,
      undoMutations: d,
      unitID: e
    }), r.executeCommand(A.id, l), !0;
  }
}, Va = (s, a) => {
  const e = s.get(C), { unitId: t, subUnitId: r, ruleId: i, source: o } = a;
  if (Array.isArray(i)) {
    const l = i.map((u) => e.getRuleById(t, r, u)).filter(Boolean);
    return [{
      id: D.id,
      params: {
        unitId: t,
        subUnitId: r,
        rule: l,
        source: o
      }
    }];
  }
  return [{
    id: D.id,
    params: {
      unitId: t,
      subUnitId: r,
      rule: {
        ...e.getRuleById(t, r, i)
      },
      index: e.getRuleIndex(t, r, i)
    }
  }];
}, ya = {
  type: z.COMMAND,
  id: "sheet.command.remove-data-validation-rule",
  handler(s, a) {
    if (!a)
      return !1;
    const { unitId: e, subUnitId: t, ruleId: r } = a, i = s.get(B), o = s.get(Z), n = s.get(C), l = [{
      id: A.id,
      params: a
    }], u = [{
      id: D.id,
      params: {
        unitId: e,
        subUnitId: t,
        rule: {
          ...n.getRuleById(e, t, r)
        },
        index: n.getRuleIndex(e, t, r)
      }
    }];
    return o.pushUndoRedo({
      undoMutations: u,
      redoMutations: l,
      unitID: a.unitId
    }), i.executeCommand(A.id, a), !0;
  }
}, Ta = "SHEET_DATA_VALIDATION_PLUGIN";
var Rt = /* @__PURE__ */ ((s) => (s[s.View = 0] = "View", s[s.Edit = 1] = "Edit", s[s.ManageCollaborator = 2] = "ManageCollaborator", s[s.Print = 3] = "Print", s[s.Duplicate = 4] = "Duplicate", s[s.Comment = 5] = "Comment", s[s.Copy = 6] = "Copy", s[s.Share = 7] = "Share", s[s.Export = 8] = "Export", s[s.MoveWorksheet = 9] = "MoveWorksheet", s[s.DeleteWorksheet = 10] = "DeleteWorksheet", s[s.HideWorksheet = 11] = "HideWorksheet", s[s.RenameWorksheet = 12] = "RenameWorksheet", s[s.CreateWorksheet = 13] = "CreateWorksheet", s[s.SetWorksheetStyle = 14] = "SetWorksheetStyle", s[s.EditWorksheetCell = 15] = "EditWorksheetCell", s[s.InsertHyperlink = 16] = "InsertHyperlink", s[s.Sort = 17] = "Sort", s[s.Filter = 18] = "Filter", s[s.PivotTable = 19] = "PivotTable", s[s.FloatImg = 20] = "FloatImg", s[s.History = 21] = "History", s[s.RwHgtClWdt = 22] = "RwHgtClWdt", s[s.ViemRwHgtClWdt = 23] = "ViemRwHgtClWdt", s[s.ViewFilter = 24] = "ViewFilter", s[s.MoveSheet = 25] = "MoveSheet", s[s.DeleteSheet = 26] = "DeleteSheet", s[s.HideSheet = 27] = "HideSheet", s[s.CopySheet = 28] = "CopySheet", s[s.RenameSheet = 29] = "RenameSheet", s[s.CreateSheet = 30] = "CreateSheet", s[s.SelectProtectedCells = 31] = "SelectProtectedCells", s[s.SelectUnProtectedCells = 32] = "SelectUnProtectedCells", s[s.SetCellStyle = 33] = "SetCellStyle", s[s.SetCellValue = 34] = "SetCellValue", s[s.SetRowStyle = 35] = "SetRowStyle", s[s.SetColumnStyle = 36] = "SetColumnStyle", s[s.InsertRow = 37] = "InsertRow", s[s.InsertColumn = 38] = "InsertColumn", s[s.DeleteRow = 39] = "DeleteRow", s[s.DeleteColumn = 40] = "DeleteColumn", s[s.EditExtraObject = 41] = "EditExtraObject", s[s.Delete = 42] = "Delete", s[s.RecoverHistory = 43] = "RecoverHistory", s[s.ViewHistory = 44] = "ViewHistory", s[s.CreatePermissionObject = 45] = "CreatePermissionObject", s[s.UNRECOGNIZED = -1] = "UNRECOGNIZED", s))(Rt || {}), Fa = Object.getOwnPropertyDescriptor, Ca = (s, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Fa(a, e) : a, i = s.length - 1, o; i >= 0; i--)
    (o = s[i]) && (r = o(r) || r);
  return r;
}, je = (s, a) => (e, t) => a(e, t, s);
let Ce = class extends x {
  constructor(s, a, e) {
    super(), this._univerInstanceService = s, this._permissionService = a, this._lexerTreeBuilder = e;
  }
  getFormulaRefCheck(s) {
    var e, t;
    const a = this._lexerTreeBuilder.sequenceNodesBuilder(s);
    if (!a)
      return !0;
    for (let r = 0; r < a.length; r++) {
      const i = a[r];
      if (typeof i == "string")
        continue;
      const { token: o } = i, n = $t(o), l = this._univerInstanceService.getCurrentUnitForType(N.UNIVER_SHEET);
      let u = l.getActiveSheet();
      const d = l.getUnitId();
      if (n.sheetName) {
        if (u = l.getSheetBySheetName(n.sheetName), !u)
          return !1;
        const R = u == null ? void 0 : u.getSheetId();
        if (!this._permissionService.getPermissionPoint(new jt(d, R).id)) return !1;
      }
      if (!u)
        return !1;
      const { startRow: c, endRow: g, startColumn: _, endColumn: f } = n.range;
      for (let R = c; R <= g; R++)
        for (let E = _; E <= f; E++) {
          const p = (t = (e = u.getCell(R, E)) == null ? void 0 : e.selectionProtection) == null ? void 0 : t[0];
          if ((p == null ? void 0 : p[Rt.View]) === !1)
            return !1;
        }
    }
    return !0;
  }
};
Ce = Ca([
  je(0, I),
  je(1, Ft),
  je(2, v(X))
], Ce);
const Na = "sheets-data-validation.config", st = {};
var Oa = Object.getOwnPropertyDescriptor, wa = (s, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Oa(a, e) : a, i = s.length - 1, o; i >= 0; i--)
    (o = s[i]) && (r = o(r) || r);
  return r;
}, Qe = (s, a) => (e, t) => a(e, t, s);
let Ne = class extends x {
  constructor(a, e, t) {
    super();
    m(this, "_disposableMap", /* @__PURE__ */ new Map());
    m(this, "registerRule", (a, e, t) => {
      he(t.type, this._validatorRegistryService) && this.register(a, e, t);
    });
    this._dataValidationModel = a, this._formulaRefRangeService = e, this._validatorRegistryService = t, this._initRefRange();
  }
  _getIdWithUnitId(a, e, t) {
    return `${a}_${e}_${t}`;
  }
  // eslint-disable-next-line max-lines-per-function
  register(a, e, t) {
    const r = t.ranges, i = t.formula1, o = t.formula2, n = this._formulaRefRangeService.registerRangeFormula(a, e, r, [i != null ? i : "", o != null ? o : ""], (u) => {
      if (u.length === 0)
        return {
          undos: [{
            id: D.id,
            params: {
              unitId: a,
              subUnitId: e,
              rule: t,
              source: "patched"
            }
          }],
          redos: [{
            id: A.id,
            params: {
              unitId: a,
              subUnitId: e,
              ruleId: t.uid,
              source: "patched"
            }
          }]
        };
      const d = [], c = [], g = u[0];
      d.push({
        id: y.id,
        params: {
          unitId: a,
          subUnitId: e,
          ruleId: t.uid,
          payload: {
            type: V.ALL,
            payload: {
              ranges: g.ranges,
              formula1: g.formulas[0],
              formula2: g.formulas[1]
            }
          },
          source: "patched"
        }
      }), c.push({
        id: y.id,
        params: {
          unitId: a,
          subUnitId: e,
          ruleId: t.uid,
          payload: {
            type: V.ALL,
            payload: {
              ranges: r,
              formula1: i,
              formula2: o
            }
          },
          source: "patched"
        }
      });
      for (let _ = 1; _ < u.length; _++) {
        const f = u[_], R = Xe();
        d.push({
          id: D.id,
          params: {
            unitId: a,
            subUnitId: e,
            rule: {
              ...t,
              uid: R,
              formula1: f.formulas[0],
              formula2: f.formulas[1],
              ranges: f.ranges
            },
            source: "patched"
          }
        }), c.push({
          id: A.id,
          params: {
            unitId: a,
            subUnitId: e,
            ruleId: R,
            source: "patched"
          }
        });
      }
      return {
        undos: c,
        redos: d
      };
    }), l = this._getIdWithUnitId(a, e, t.uid);
    this._disposableMap.set(l, n);
  }
  _initRefRange() {
    const a = this._dataValidationModel.getAll();
    for (const [e, t] of a)
      for (const [r, i] of t)
        for (const o of i)
          this.registerRule(e, r, o);
    this.disposeWithMe(
      this._dataValidationModel.ruleChange$.subscribe((e) => {
        const { unitId: t, subUnitId: r, rule: i } = e;
        switch (e.type) {
          case "add": {
            const o = e.rule;
            this.registerRule(e.unitId, e.subUnitId, o);
            break;
          }
          case "remove": {
            const o = this._disposableMap.get(this._getIdWithUnitId(t, r, i.uid));
            o && o.dispose();
            break;
          }
          case "update": {
            const o = e.rule, n = this._disposableMap.get(this._getIdWithUnitId(t, r, o.uid));
            n && n.dispose(), this.registerRule(e.unitId, e.subUnitId, o);
            break;
          }
        }
      })
    ), this.disposeWithMe(Ke(() => {
      this._disposableMap.forEach((e) => {
        e.dispose();
      }), this._disposableMap.clear();
    }));
  }
};
Ne = wa([
  Qe(0, v(C)),
  Qe(1, v(pt)),
  Qe(2, v(G))
], Ne);
var Aa = Object.getOwnPropertyDescriptor, Ia = (s, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Aa(a, e) : a, i = s.length - 1, o; i >= 0; i--)
    (o = s[i]) && (r = o(r) || r);
  return r;
}, te = (s, a) => (e, t) => a(e, t, s);
let Oe = class extends x {
  constructor(a, e, t, r, i, o) {
    super();
    m(this, "_disposableMap", /* @__PURE__ */ new Map());
    m(this, "registerRule", (a, e, t) => {
      he(t.type, this._validatorRegistryService) || (this.register(a, e, t), this.registerFormula(a, e, t));
    });
    this._dataValidationModel = a, this._injector = e, this._refRangeService = t, this._dataValidationFormulaService = r, this._formulaRefRangeService = i, this._validatorRegistryService = o, this._initRefRange();
  }
  _getIdWithUnitId(a, e, t) {
    return `${a}_${e}_${t}`;
  }
  // eslint-disable-next-line max-lines-per-function
  registerFormula(a, e, t) {
    var u;
    const r = t.uid, i = this._getIdWithUnitId(a, e, r), o = (u = this._disposableMap.get(i)) != null ? u : /* @__PURE__ */ new Set(), n = (d, c) => {
      const g = this._dataValidationModel.getRuleById(a, e, r);
      if (!g)
        return { redos: [], undos: [] };
      const _ = g[d];
      if (!_ || _ === c)
        return { redos: [], undos: [] };
      const f = {
        unitId: a,
        subUnitId: e,
        ruleId: t.uid,
        payload: {
          type: V.SETTING,
          payload: {
            type: g.type,
            formula1: g.formula1,
            formula2: g.formula2,
            [d]: c
          }
        },
        source: "patched"
      }, R = {
        unitId: a,
        subUnitId: e,
        ruleId: t.uid,
        payload: {
          type: V.SETTING,
          payload: {
            type: g.type,
            formula1: g.formula1,
            formula2: g.formula2
          }
        },
        source: "patched"
      }, E = [
        {
          id: y.id,
          params: f
        }
      ], p = [
        {
          id: y.id,
          params: R
        }
      ];
      return { redos: E, undos: p };
    }, l = this._dataValidationFormulaService.getRuleFormulaInfo(a, e, r);
    if (l) {
      const [d, c] = l;
      if (d) {
        const g = this._formulaRefRangeService.registerFormula(
          a,
          e,
          d.text,
          (_) => n("formula1", _)
        );
        o.add(() => g.dispose());
      }
      if (c) {
        const g = this._formulaRefRangeService.registerFormula(
          a,
          e,
          c.text,
          (_) => n("formula2", _)
        );
        o.add(() => g.dispose());
      }
    }
  }
  register(a, e, t) {
    var l;
    const r = (u) => {
      const d = [...t.ranges], g = d.map((f) => qt(f, u)).filter((f) => !!f).flat();
      if (lt(g, d))
        return { redos: [], undos: [] };
      if (g.length) {
        const f = {
          unitId: a,
          subUnitId: e,
          ruleId: t.uid,
          payload: {
            type: V.RANGE,
            payload: g
          },
          source: "patched"
        }, R = [{ id: y.id, params: f }], E = [{
          id: y.id,
          params: {
            unitId: a,
            subUnitId: e,
            ruleId: t.uid,
            payload: {
              type: V.RANGE,
              payload: d
            },
            source: "patched"
          }
        }];
        return { redos: R, undos: E };
      } else {
        const f = { unitId: a, subUnitId: e, ruleId: t.uid }, R = [{ id: A.id, params: f }], E = Va(this._injector, f);
        return { redos: R, undos: E };
      }
    }, i = [];
    t.ranges.forEach((u) => {
      const d = this._refRangeService.registerRefRange(u, r, a, e);
      i.push(() => d.dispose());
    });
    const o = this._getIdWithUnitId(a, e, t.uid), n = (l = this._disposableMap.get(o)) != null ? l : /* @__PURE__ */ new Set();
    n.add(() => i.forEach((u) => u())), this._disposableMap.set(o, n);
  }
  _initRefRange() {
    const a = this._dataValidationModel.getAll();
    for (const [e, t] of a)
      for (const [r, i] of t)
        for (const o of i)
          this.registerRule(e, r, o);
    this.disposeWithMe(
      this._dataValidationModel.ruleChange$.subscribe((e) => {
        const { unitId: t, subUnitId: r, rule: i } = e;
        switch (e.type) {
          case "add": {
            const o = e.rule;
            this.registerRule(e.unitId, e.subUnitId, o);
            break;
          }
          case "remove": {
            const o = this._disposableMap.get(this._getIdWithUnitId(t, r, i.uid));
            o && o.forEach((n) => n());
            break;
          }
          case "update": {
            const o = e.rule, n = this._disposableMap.get(this._getIdWithUnitId(t, r, o.uid));
            n && n.forEach((l) => l()), this.registerRule(e.unitId, e.subUnitId, o);
            break;
          }
        }
      })
    ), this.disposeWithMe(Ke(() => {
      this._disposableMap.forEach((e) => {
        e.forEach((t) => t());
      }), this._disposableMap.clear();
    }));
  }
};
Oe = Ia([
  te(0, v(C)),
  te(1, v(be)),
  te(2, v(Qt)),
  te(3, v(q)),
  te(4, v(pt)),
  te(5, v(G))
], Oe);
var Da = Object.getOwnPropertyDescriptor, ba = (s, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Da(a, e) : a, i = s.length - 1, o; i >= 0; i--)
    (o = s[i]) && (r = o(r) || r);
  return r;
}, qe = (s, a) => (e, t) => a(e, t, s);
let we = class extends x {
  constructor(s, a, e) {
    super(), this._sheetInterceptorService = s, this._univerInstanceService = a, this._sheetDataValidationModel = e, this._initSheetChange();
  }
  // eslint-disable-next-line max-lines-per-function
  _initSheetChange() {
    this.disposeWithMe(
      this._sheetInterceptorService.interceptCommand({
        // eslint-disable-next-line max-lines-per-function
        getMutations: (s) => {
          var a;
          if (s.id === Gt.id) {
            const e = s.params, t = e.unitId || this._univerInstanceService.getCurrentUnitForType(N.UNIVER_SHEET).getUnitId(), r = this._univerInstanceService.getUniverSheetInstance(t);
            if (!r)
              return { redos: [], undos: [] };
            const i = e.subUnitId || ((a = r.getActiveSheet()) == null ? void 0 : a.getSheetId());
            if (!i)
              return { redos: [], undos: [] };
            const o = this._sheetDataValidationModel.getRules(t, i);
            if (o.length === 0)
              return { redos: [], undos: [] };
            const n = o.map((d) => d.uid), l = {
              unitId: t,
              subUnitId: i,
              ruleId: n,
              source: "patched"
            }, u = {
              unitId: t,
              subUnitId: i,
              rule: [...o],
              source: "patched"
            };
            return {
              redos: [{
                id: A.id,
                params: l
              }],
              undos: [{
                id: D.id,
                params: u
              }]
            };
          } else if (s.id === Yt.id) {
            const e = s.params, { unitId: t, subUnitId: r, targetSubUnitId: i } = e;
            if (!t || !r || !i)
              return { redos: [], undos: [] };
            const o = this._sheetDataValidationModel.getRules(t, r);
            if (o.length === 0)
              return { redos: [], undos: [] };
            const n = o.map((l) => ({ ...l, uid: Xe(6) }));
            return {
              redos: [
                {
                  id: D.id,
                  params: {
                    unitId: t,
                    subUnitId: i,
                    rule: n,
                    source: "patched"
                  }
                }
              ],
              undos: [
                {
                  id: A.id,
                  params: {
                    unitId: t,
                    subUnitId: i,
                    ruleId: n.map((l) => l.uid),
                    source: "patched"
                  }
                }
              ]
            };
          }
          return { redos: [], undos: [] };
        }
      })
    );
  }
};
we = ba([
  qe(0, v(ht)),
  qe(1, v(I)),
  qe(2, v(C))
], we);
class La extends Y {
  constructor() {
    super(...arguments);
    m(this, "id", T.ANY);
    m(this, "title", "dataValidation.any.title");
    m(this, "operators", []);
    m(this, "scopes", ["sheet"]);
    m(this, "order", 0);
    m(this, "offsetFormulaByRange", !1);
  }
  async parseFormula(e, t, r) {
    return {
      formula1: e.formula1,
      formula2: e.formula2,
      isFormulaValid: !0
    };
  }
  validatorFormula(e, t, r) {
    return {
      success: !0
    };
  }
  async isValidType(e, t, r) {
    return !0;
  }
  generateRuleErrorMessage(e) {
    return this.localeService.t("dataValidation.any.error");
  }
}
class Ua extends Y {
  constructor() {
    super(...arguments);
    m(this, "id", T.CUSTOM);
    m(this, "title", "dataValidation.custom.title");
    m(this, "operators", []);
    m(this, "scopes", ["sheet"]);
    m(this, "order", 60);
    m(this, "_customFormulaService", this.injector.get(W));
    m(this, "_lexerTreeBuilder", this.injector.get(X));
  }
  validatorFormula(e, t, r) {
    var u;
    const i = S(e.formula1), o = (u = e.formula1) != null ? u : "", l = this._lexerTreeBuilder.checkIfAddBracket(o) === 0 && o.startsWith(kt.EQUALS);
    return {
      success: i && l,
      formula1: i && l ? "" : this.localeService.t("dataValidation.validFail.formula")
    };
  }
  async parseFormula(e, t, r) {
    return {
      formula1: void 0,
      formula2: void 0,
      isFormulaValid: !0
    };
  }
  async isValidType(e, t, r) {
    const { column: i, row: o, unitId: n, subUnitId: l } = e, u = await this._customFormulaService.getCellFormulaValue(n, l, r.uid, o, i), d = u == null ? void 0 : u.v;
    return F(String(d)) && M.isDefine(d) && d !== "" ? u.t === Ct.BOOLEAN ? !!d : typeof d == "boolean" ? d : typeof d == "number" ? !!d : typeof d == "string" ? F(d) : !!d : !1;
  }
  generateRuleErrorMessage(e) {
    return this.localeService.t("dataValidation.custom.error");
  }
  generateRuleName(e) {
    var t;
    return this.localeService.t("dataValidation.custom.ruleName").replace("{FORMULA1}", (t = e.formula1) != null ? t : "");
  }
}
class Ba extends _t {
  constructor() {
    super(...arguments);
    m(this, "id", T.LIST_MULTIPLE);
    m(this, "title", "dataValidation.listMultiple.title");
    m(this, "offsetFormulaByRange", !1);
    m(this, "skipDefaultFontRender", () => !0);
  }
}
class xa extends Y {
  constructor() {
    super(...arguments);
    m(this, "_customFormulaService", this.injector.get(W));
    m(this, "_lexerTreeBuilder", this.injector.get(X));
    m(this, "id", T.WHOLE);
    m(this, "title", "dataValidation.whole.title");
    m(this, "order", 10);
    m(this, "operators", [
      h.BETWEEN,
      h.EQUAL,
      h.GREATER_THAN,
      h.GREATER_THAN_OR_EQUAL,
      h.LESS_THAN,
      h.LESS_THAN_OR_EQUAL,
      h.NOT_BETWEEN,
      h.NOT_EQUAL
    ]);
    m(this, "scopes", ["sheet"]);
  }
  _isFormulaOrInt(e) {
    return !M.isBlank(e) && (S(e) || !Number.isNaN(+e) && Number.isInteger(+e));
  }
  async isValidType(e, t, r) {
    const { value: i } = e, o = Fe(i);
    return !Number.isNaN(o) && Number.isInteger(o);
  }
  transform(e, t, r) {
    const { value: i } = e;
    return {
      ...e,
      value: Fe(i)
    };
  }
  _parseNumber(e) {
    return e == null ? Number.NaN : +e;
  }
  async parseFormula(e, t, r, i, o) {
    const n = await this._customFormulaService.getCellFormulaValue(t, r, e.uid, i, o), l = await this._customFormulaService.getCellFormula2Value(t, r, e.uid, i, o), { formula1: u, formula2: d } = e, c = S(u) ? n == null ? void 0 : n.v : u, g = S(d) ? l == null ? void 0 : l.v : d, _ = F(`${c}`) && F(`${g}`);
    return {
      formula1: this._parseNumber(c),
      formula2: this._parseNumber(g),
      isFormulaValid: _
    };
  }
  validatorFormula(e, t, r) {
    const i = e.operator;
    if (!i)
      return {
        success: !0
      };
    const o = M.isDefine(e.formula1) && this._isFormulaOrInt(e.formula1), n = M.isDefine(e.formula2) && this._isFormulaOrInt(e.formula2), l = Be.includes(i), u = this.localeService.t("dataValidation.validFail.number");
    return l ? {
      success: o && n,
      formula1: o ? void 0 : u,
      formula2: n ? void 0 : u
    } : {
      success: o,
      formula1: u
    };
  }
  generateRuleErrorMessage(e, t) {
    if (!e.operator)
      return this.localeService.t(Te.NONE).replace("{TYPE}", this.titleStr);
    const { transformedFormula1: r, transformedFormula2: i } = Ue(this._lexerTreeBuilder, e, t);
    return `${this.localeService.t(Te[e.operator]).replace(ue, r != null ? r : "").replace(de, i != null ? i : "")}`;
  }
}
var Pa = Object.getOwnPropertyDescriptor, Ha = (s, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Pa(a, e) : a, i = s.length - 1, o; i >= 0; i--)
    (o = s[i]) && (r = o(r) || r);
  return r;
}, ae = (s, a) => (e, t) => a(e, t, s);
let Ae = class extends Nt {
  constructor(s, a, e, t, r, i) {
    super(), this._univerInstanceService = s, this._dataValidatorRegistryService = a, this._injector = e, this._selectionManagerService = t, this._sheetInterceptorService = r, this._sheetDataValidationModel = i, this._init();
  }
  _init() {
    this._registerValidators(), this._initCommandInterceptor();
  }
  _registerValidators() {
    [
      La,
      ca,
      xa,
      fa,
      da,
      na,
      _t,
      Ba,
      Ua
    ].forEach((s) => {
      const a = this._injector.createInstance(s);
      this.disposeWithMe(this._dataValidatorRegistryService.register(a)), this.disposeWithMe(Ke(() => this._injector.delete(s)));
    });
  }
  _initCommandInterceptor() {
    this._sheetInterceptorService.interceptCommand({
      getMutations: (s) => {
        var a;
        if (s.id === Xt.id) {
          const e = this._univerInstanceService.getCurrentUnitForType(N.UNIVER_SHEET), t = e.getUnitId(), r = e.getActiveSheet();
          if (!r)
            throw new Error("No active sheet found");
          const i = r.getSheetId(), o = (a = this._selectionManagerService.getCurrentSelections()) == null ? void 0 : a.map((c) => c.range), n = this._sheetDataValidationModel.getRuleObjectMatrix(t, i).clone();
          o && n.removeRange(o);
          const l = n.diff(this._sheetDataValidationModel.getRules(t, i)), { redoMutations: u, undoMutations: d } = xe(t, i, l, this._injector, "patched");
          return {
            undos: d,
            redos: u
          };
        }
        return {
          undos: [],
          redos: []
        };
      }
    });
  }
};
Ae = Ha([
  ae(0, I),
  ae(1, v(G)),
  ae(2, v(be)),
  ae(3, v(mt)),
  ae(4, v(ht)),
  ae(5, v(C))
], Ae);
var Wa = Object.getOwnPropertyDescriptor, $a = (s, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? Wa(a, e) : a, i = s.length - 1, o; i >= 0; i--)
    (o = s[i]) && (r = o(r) || r);
  return r;
}, Re = (s, a) => (e, t) => a(e, t, s);
let Ie = class extends x {
  constructor(s, a, e, t) {
    super(), this._univerInstanceService = s, this._sheetDataValidationModel = a, this._dataValidationCacheService = e, this._lifecycleService = t, this._initRecalculate();
  }
  _initRecalculate() {
    const s = (a) => {
      if (a.length === 0)
        return;
      const e = this._univerInstanceService.getCurrentUnitForType(N.UNIVER_SHEET), t = e == null ? void 0 : e.getActiveSheet(), r = {};
      a.flat().forEach((i) => {
        r[i.unitId] || (r[i.unitId] = {}), r[i.unitId][i.subUnitId] || (r[i.unitId][i.subUnitId] = []);
        const o = this._univerInstanceService.getUnit(i.unitId, N.UNIVER_SHEET), n = o == null ? void 0 : o.getSheetBySheetId(i.subUnitId);
        n && r[i.unitId][i.subUnitId].push(...i.ranges.map((l) => U.transformRange(l, n)));
      }), Object.entries(r).forEach(([i, o]) => {
        Object.entries(o).forEach(([n, l]) => {
          (e == null ? void 0 : e.getUnitId()) === i && (t == null ? void 0 : t.getSheetId()) === n ? this.validatorRanges(i, n, l) : requestIdleCallback(() => {
            this.validatorRanges(i, n, l);
          });
        });
      });
    };
    this.disposeWithMe(this._dataValidationCacheService.dirtyRanges$.pipe(Kt(() => this._lifecycleService.lifecycle$.pipe(tt((a) => a === et.Rendered)))).subscribe(s)), this.disposeWithMe(this._dataValidationCacheService.dirtyRanges$.pipe(tt(() => this._lifecycleService.stage >= et.Rendered), wt(20)).subscribe(s));
  }
  async _validatorByCell(s, a, e, t) {
    const r = s.getUnitId(), i = a.getSheetId();
    if (!M.isDefine(e) || !M.isDefine(t))
      throw new Error(`row or col is not defined, row: ${e}, col: ${t}`);
    const o = this._sheetDataValidationModel.getRuleByLocation(r, i, e, t);
    return o ? new Promise((n) => {
      this._sheetDataValidationModel.validator(o, { unitId: r, subUnitId: i, row: e, col: t, worksheet: a, workbook: s }, (l) => {
        n(l);
      });
    }) : b.VALID;
  }
  async validatorCell(s, a, e, t) {
    const r = this._univerInstanceService.getUnit(s, N.UNIVER_SHEET);
    if (!r)
      throw new Error(`cannot find current workbook, unitId: ${s}`);
    const i = r.getSheetBySheetId(a);
    if (!i)
      throw new Error(`cannot find current worksheet, sheetId: ${a}`);
    return this._validatorByCell(r, i, e, t);
  }
  validatorRanges(s, a, e) {
    if (!e.length)
      return Promise.resolve([]);
    const t = this._univerInstanceService.getUnit(s, N.UNIVER_SHEET);
    if (!t)
      throw new Error(`cannot find current workbook, unitId: ${s}`);
    const r = t.getSheetBySheetId(a);
    if (!r)
      throw new Error(`cannot find current worksheet, sheetId: ${a}`);
    const o = this._sheetDataValidationModel.getRules(s, a).map((l) => l.ranges).flat(), n = e.map((l) => o.map((u) => ot(l, u))).flat().filter(Boolean);
    return Promise.all(n.map((l) => {
      const u = [];
      return U.foreach(l, (d, c) => {
        u.push(this._validatorByCell(t, r, d, c));
      }), Promise.all(u);
    }));
  }
  async validatorWorksheet(s, a) {
    const e = this._univerInstanceService.getUnit(s, N.UNIVER_SHEET);
    if (!e)
      throw new Error(`cannot find current workbook, unitId: ${s}`);
    const t = e.getSheetBySheetId(a);
    if (!t)
      throw new Error(`cannot find current worksheet, sheetId: ${a}`);
    const r = this._sheetDataValidationModel.getRules(s, a);
    return await Promise.all(
      r.map((i) => Promise.all(
        i.ranges.map((o) => {
          const n = [];
          return U.foreach(o, (l, u) => {
            n.push(this._validatorByCell(e, t, l, u));
          }), Promise.all(n);
        })
      ))
    ), this._dataValidationCacheService.ensureCache(s, a);
  }
  async validatorWorkbook(s) {
    const a = this._sheetDataValidationModel.getSubUnitIds(s), e = await Promise.all(a.map((r) => this.validatorWorksheet(s, r))), t = {};
    return e.forEach((r, i) => {
      t[a[i]] = r;
    }), t;
  }
  getDataValidations(s, a, e) {
    const t = this._sheetDataValidationModel.getRuleObjectMatrix(s, a), r = /* @__PURE__ */ new Set();
    return e.forEach((o) => {
      U.foreach(o, (n, l) => {
        const u = t.getValue(n, l);
        u && r.add(u);
      });
    }), Array.from(r).map((o) => this._sheetDataValidationModel.getRuleById(s, a, o)).filter(Boolean);
  }
  getDataValidation(s, a, e) {
    return this.getDataValidations(s, a, e)[0];
  }
};
Ie = $a([
  Re(0, I),
  Re(1, v(C)),
  Re(2, v(Q)),
  Re(3, v(Ot))
], Ie);
var ka = Object.defineProperty, ja = Object.getOwnPropertyDescriptor, Qa = (s, a, e) => a in s ? ka(s, a, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[a] = e, qa = (s, a, e, t) => {
  for (var r = t > 1 ? void 0 : t ? ja(a, e) : a, i = s.length - 1, o; i >= 0; i--)
    (o = s[i]) && (r = o(r) || r);
  return r;
}, Ge = (s, a) => (e, t) => a(e, t, s), St = (s, a, e) => Qa(s, typeof a != "symbol" ? a + "" : a, e);
let De = class extends Dt {
  constructor(s = st, a, e, t) {
    super(), this._config = s, this._injector = a, this._commandService = e, this._configService = t;
    const { ...r } = bt(
      {},
      st,
      this._config
    );
    this._configService.setConfig(Na, r);
  }
  onStarting() {
    [
      [Q],
      [le],
      [q],
      [W],
      [Ie],
      [C],
      [Ae],
      [Ce],
      [we],
      [Oe],
      [Ne]
    ].forEach((s) => {
      this._injector.add(s);
    }), [
      va,
      _a,
      Ra,
      Sa,
      ya,
      Ma,
      Ea
    ].forEach((s) => {
      this._commandService.registerCommand(s);
    }), this._injector.get(Q), this._injector.get(Ie), this._injector.get(Ae), this._injector.get(Ne), this._injector.get(Oe);
  }
  onReady() {
    this._injector.get(we);
  }
  onRendered() {
    this._injector.get(Ce);
  }
};
St(De, "pluginName", Ta);
St(De, "type", N.UNIVER_SHEET);
De = qa([
  At(xt),
  Ge(1, v(be)),
  Ge(2, B),
  Ge(3, It)
], De);
function ar(s) {
  const e = s.get(mt).getCurrentSelections().map((i) => i.range);
  return {
    uid: Xe(6),
    type: T.DECIMAL,
    operator: h.EQUAL,
    formula1: "100",
    ranges: e != null ? e : [{ startColumn: 0, endColumn: 0, startRow: 0, endRow: 0 }]
  };
}
const rr = "data-validation.custom-formula-input", ir = "data-validation.formula-input", sr = "data-validation.list-formula-input", or = "data-validation.checkbox-formula-input";
export {
  va as AddSheetDataValidationCommand,
  ir as BASE_FORMULA_INPUT_NAME,
  Ve as CHECKBOX_FORMULA_1,
  ye as CHECKBOX_FORMULA_2,
  or as CHECKBOX_FORMULA_INPUT_NAME,
  rr as CUSTOM_FORMULA_INPUT_NAME,
  na as CheckboxValidator,
  Ea as ClearRangeDataValidationCommand,
  Ta as DATA_VALIDATION_PLUGIN_NAME,
  Q as DataValidationCacheService,
  W as DataValidationCustomFormulaService,
  Ce as DataValidationFormulaController,
  q as DataValidationFormulaService,
  le as DataValidationListCacheService,
  da as DateValidator,
  sr as LIST_FORMULA_INPUT_NAME,
  Ba as ListMultipleValidator,
  _t as ListValidator,
  Ma as RemoveSheetAllDataValidationCommand,
  ya as RemoveSheetDataValidationCommand,
  C as SheetDataValidationModel,
  Ie as SheetsDataValidationValidatorService,
  De as UniverSheetsDataValidationPlugin,
  Sa as UpdateSheetDataValidationOptionsCommand,
  _a as UpdateSheetDataValidationRangeCommand,
  Ra as UpdateSheetDataValidationSettingCommand,
  ar as createDefaultNewRule,
  Ee as deserializeListOptions,
  Fe as getCellValueNumber,
  re as getCellValueOrigin,
  tr as getDataValidationCellValue,
  xe as getDataValidationDiffMutations,
  _e as getFormulaCellData,
  oe as getFormulaResult,
  Ue as getTransformedFormula,
  F as isLegalFormulaResult,
  er as serializeListOptions,
  ve as transformCheckboxValue
};
