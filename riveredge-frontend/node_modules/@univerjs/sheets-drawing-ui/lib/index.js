var Qr = Object.defineProperty;
var ei = (i, t, e) => t in i ? Qr(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;
var re = (i, t, e) => ei(i, typeof t != "symbol" ? t + "" : t, e);
import { precisionTo as bt, IRenderManagerService as Q, transformObjectOutOfGroup as ti, getGroupState as ni, getCurrentTypeOfRenderer as Dn, CURSOR_TYPE as ri, RENDER_CLASS_TYPE as $e, Rect as ke, ObjectType as An, DRAWING_OBJECT_LAYER_INDEX as qt, SHEET_VIEWPORT_KEY as cr } from "@univerjs/engine-render";
import { convertPositionSheetOverGridToAbsolute as ii, SheetSkeletonManagerService as X, ISheetSelectionRenderService as Ze, attachRangeWithCoord as dr, SheetCanvasPopManagerService as si, HoverManagerService as oi, IEditorBridgeService as ai, IAutoFillService as ci, EditingRenderController as di, SetCellEditVisibleOperation as Nn, PREDEFINED_HOOK_NAME as Le, COPY_TYPE as Re, discreteRangeToRange as $n, virtualizeDiscreteRanges as li, ISheetClipboardService as ui, SetZoomRatioOperation as kn, SetScrollOperation as hi, SheetPrintInterceptorService as gi, useHighlightRange as fi, getCurrentRangeDisable$ as mi } from "@univerjs/sheets-ui";
import { CommandType as q, ICommandService as Y, IUndoRedoService as Je, sequenceExecute as lr, DrawingTypeEnum as x, ArrangeTypeEnum as Mt, Inject as A, IContextService as ur, LocaleService as Te, Injector as qe, Disposable as ee, createDocumentModelWithStyle as un, ObjectRelativeFromV as xn, ObjectRelativeFromH as Wn, WrapTextType as Bn, PositionedObjectLayoutType as jn, BooleanNumber as Fn, BuildTextUtils as hn, ImageSourceType as Ce, generateRandomId as Ve, FOCUSING_COMMON_DRAWINGS as Ge, IUniverInstanceService as de, UniverInstanceType as $, Direction as ve, createIdentifier as pi, IImageIoService as hr, RxDisposable as wi, DOCS_NORMAL_EDITOR_UNIT_ID_KEY as ot, DOCS_ZEN_EDITOR_UNIT_ID_KEY as He, InterceptorEffectEnum as _i, ObjectMatrix as Si, DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY as vi, IPermissionService as Ii, UserManagerService as Ci, LifecycleService as Ri, LifecycleStages as Di, DisposableCollection as yt, fromEventSubject as bi, Tools as Ye, PRINT_CHART_COMPONENT_KEY as Mi, Rectangle as yi, FOCUSING_FX_BAR_EDITOR as Ei, EDITOR_ACTIVATED as Ti, FOCUSING_PANEL_EDITOR as Oi, DependentOn as Ui, IConfigService as Pi, Plugin as Ai, merge as Ni, registerDependencies as $i, touchDependencies as Qt } from "@univerjs/core";
import { ISheetDrawingService as se, DrawingApplyType as U, SetDrawingApplyMutation as P, SheetDrawingAnchorType as O, UniverSheetsDrawingPlugin as ki } from "@univerjs/sheets-drawing";
import { SheetInterceptorService as Vt, SheetsSelectionsService as ut, SetRangeValuesCommand as Ln, getSheetCommandTarget as ae, INTERCEPTOR_POINT as xi, InterceptCellContentPriority as Wi, WorkbookViewPermission as Vn, WorksheetViewPermission as Hn, WorkbookEditablePermission as gn, WorksheetEditPermission as fn, SetFrozenMutation as Bi, SetSelectionsOperation as ji, SetWorksheetRowAutoHeightMutation as Fi, COMMAND_LISTENER_SKELETON_CHANGE as Li, InsertRowCommand as gr, InsertColCommand as fr, RemoveRowCommand as mr, RemoveColCommand as pr, DeleteRangeMoveLeftCommand as wr, DeleteRangeMoveUpCommand as _r, InsertRangeMoveDownCommand as Sr, InsertRangeMoveRightCommand as vr, DeltaRowHeightCommand as mn, SetRowHeightCommand as pn, DeltaColumnWidthCommand as Ir, SetColWidthCommand as Cr, SetRowHiddenCommand as Rr, SetSpecificRowsVisibleCommand as Dr, SetSpecificColsVisibleCommand as br, SetColHiddenCommand as Mr, MoveColsCommand as yr, MoveRowsCommand as Er, MoveRangeCommand as Tr, SetRowVisibleMutation as Vi, SetRowHiddenMutation as Hi, SetColVisibleMutation as Yi, SetColHiddenMutation as Gi, SetWorksheetRowHeightMutation as Xi, SetWorksheetColWidthMutation as zi, SetWorksheetActiveOperation as Ki, RangeProtectionPermissionEditPoint as Zi } from "@univerjs/sheets";
import { MessageType as Se, render as Ji, unmount as qi, FormLayout as en, CheckboxGroup as Qi, Checkbox as Yn, Select as es, Button as Gn, clsx as ts, RadioGroup as ns, Radio as tn } from "@univerjs/design";
import { docDrawingPositionToTransform as Xn, ReplaceSnapshotCommand as rs, InnerPasteCommand as is } from "@univerjs/docs-ui";
import { IImageIoService as ss, IDrawingManagerService as oe, DRAWING_IMAGE_ALLOW_IMAGE_LIST as zn, DRAWING_IMAGE_COUNT_LIMIT as Kn, ImageUploadStatusType as xe, DRAWING_IMAGE_ALLOW_SIZE as Zn, getImageSize as nn, SetDrawingSelectedOperation as Ht, DRAWING_IMAGE_WIDTH_LIMIT as Jn, DRAWING_IMAGE_HEIGHT_LIMIT as qn, ImageSourceType as os, getDrawingShapeKeyByDrawingSearch as De, UniverDrawingPlugin as as } from "@univerjs/drawing";
import { ILocalFileService as cs, IMessageService as Or, IDialogService as bn, ISidebarService as ds, IClipboardInterfaceService as ls, CanvasFloatDomService as us, PrintFloatDomSingle as hs, ComponentManager as Ur, connectInjector as gs, useDependency as Ie, getMenuHiddenObservable as Yt, MenuItemType as Gt, ContextMenuPosition as rn, ContextMenuGroup as sn, RibbonInsertGroup as fs, KeyCode as Ke, IMenuManagerService as ms, IShortcutService as ps } from "@univerjs/ui";
import { DocDrawingController as ws, UniverDocsDrawingPlugin as _s } from "@univerjs/docs-drawing";
import { ImageCropperObject as Ss, COMPONENT_IMAGE_POPUP_MENU as vs, OpenImageCropOperation as Is, ImageResetSizeOperation as Cs, DrawingRenderService as Pr, DrawingCommonPanel as Rs, UniverDrawingUIPlugin as Ds } from "@univerjs/drawing-ui";
import { takeUntil as Qn, throttleTime as bs, combineLatest as at, switchMap as me, EMPTY as we, tap as er, map as pe, distinctUntilChanged as tr, Subject as on, filter as Ms, take as ys, BehaviorSubject as je, of as wn } from "rxjs";
import { jsx as L, jsxs as Xe } from "react/jsx-runtime";
import { useMemo as Fe, useRef as Es, createElement as Ar, forwardRef as Ts, useState as Ee, useCallback as Et, useEffect as Nr } from "react";
function Z(i, t, e) {
  const { from: n, to: r, flipY: s = !1, flipX: o = !1, angle: a = 0, skewX: d = 0, skewY: u = 0 } = i, c = e.getCurrent();
  if (c == null)
    return;
  const l = ii(
    c.unitId,
    c.sheetId,
    { from: n, to: r },
    e
  );
  let { left: g, top: h, width: f, height: m } = l;
  const p = e.getCurrentSkeleton(), w = p.rowHeaderWidth + p.columnTotalWidth, S = p.columnHeaderHeight + p.rowTotalHeight;
  return g + f > w && (g = w - f), h + m > S && (h = S - m), {
    flipY: s,
    flipX: o,
    angle: a,
    skewX: d,
    skewY: u,
    left: g,
    top: h,
    width: f,
    height: m
  };
}
function j(i, t) {
  const { left: e = 0, top: n = 0, width: r = 0, height: s = 0, flipY: o = !1, flipX: a = !1, angle: d = 0, skewX: u = 0, skewY: c = 0 } = i, l = t.getCellWithCoordByOffset(e, n);
  if (l == null)
    return;
  const g = {
    column: l.actualColumn,
    columnOffset: bt(e - l.startX, 1),
    row: l.actualRow,
    rowOffset: bt(n - l.startY, 1)
  }, h = t.getCellWithCoordByOffset(e + r, n + s);
  if (h == null)
    return;
  const f = {
    column: h.actualColumn,
    columnOffset: bt(e + r - h.startX, 1),
    row: h.actualRow,
    rowOffset: bt(n + s - h.startY, 1)
  };
  return {
    flipY: o,
    flipX: a,
    angle: d,
    skewX: u,
    skewY: c,
    from: g,
    to: f
  };
}
const V = {
  id: "sheet.operation.clear-drawing-transformer",
  type: q.MUTATION,
  handler: (i, t) => {
    const e = i.get(Q);
    return t.forEach((n) => {
      var r, s;
      (s = (r = e.getRenderById(n)) == null ? void 0 : r.scene.getTransformer()) == null || s.debounceRefreshControls();
    }), !0;
  }
}, ht = {
  id: "sheet.command.remove-sheet-image",
  type: q.COMMAND,
  handler: (i, t) => {
    var S, I, D;
    const e = i.get(Y), n = i.get(Je), r = i.get(Vt), s = i.get(se);
    if (!t) return !1;
    const { drawings: o } = t, a = [];
    o.forEach((v) => {
      const { unitId: C } = v;
      a.push(C);
    });
    const d = s.getBatchRemoveOp(o), { unitId: u, subUnitId: c, undo: l, redo: g, objects: h } = d, f = r.onCommandExecute({ id: ht.id, params: t }), m = { id: P.id, params: { unitId: u, subUnitId: c, op: g, objects: h, type: U.REMOVE } }, p = { id: P.id, params: { unitId: u, subUnitId: c, op: l, objects: h, type: U.INSERT } };
    return lr([...(S = f.preRedos) != null ? S : [], m, ...f.redos], e) ? (n.pushUndoRedo({
      unitID: u,
      undoMutations: [
        ...(I = f.preUndos) != null ? I : [],
        p,
        ...f.undos,
        { id: V.id, params: a }
      ],
      redoMutations: [
        ...(D = f.preRedos) != null ? D : [],
        m,
        ...f.redos,
        { id: V.id, params: a }
      ]
    }), !0) : !1;
  }
}, $r = {
  id: "sheet.command.delete-drawing",
  type: q.COMMAND,
  handler: (i) => {
    const t = i.get(Y), n = i.get(se).getFocusDrawings();
    if (n.length === 0)
      return !1;
    const r = n[0].unitId, s = n.map((o) => {
      const { unitId: a, subUnitId: d, drawingId: u, drawingType: c } = o;
      return {
        unitId: a,
        subUnitId: d,
        drawingId: u,
        drawingType: c
      };
    });
    return t.executeCommand(ht.id, {
      unitId: r,
      drawings: s
    });
  }
};
function Os(i) {
  const t = [];
  return i.forEach((e) => {
    const { parent: n, children: r } = e, { unitId: s, subUnitId: o, drawingId: a } = n, d = ni(0, 0, r.map((l) => l.transform || {})), u = r.map((l) => {
      const g = l.transform || { left: 0, top: 0 }, { unitId: h, subUnitId: f, drawingId: m } = l;
      return {
        unitId: h,
        subUnitId: f,
        drawingId: m,
        transform: {
          ...g,
          left: g.left - d.left,
          top: g.top - d.top
        },
        groupId: a
      };
    }), c = {
      unitId: s,
      subUnitId: o,
      drawingId: a,
      drawingType: x.DRAWING_GROUP,
      transform: d
    };
    t.push({
      parent: c,
      children: u
    });
  }), t;
}
function Us(i) {
  const t = [];
  return i.forEach((e) => {
    const { parent: n, children: r } = e, { unitId: s, subUnitId: o, drawingId: a, transform: d = { width: 0, height: 0 } } = n;
    if (d == null)
      return;
    const u = r.map((l) => {
      const { transform: g } = l, { unitId: h, subUnitId: f, drawingId: m } = l, p = ti(g || {}, d, d.width || 0, d.height || 0);
      return {
        unitId: h,
        subUnitId: f,
        drawingId: m,
        transform: p,
        groupId: void 0
      };
    }), c = {
      unitId: s,
      subUnitId: o,
      drawingId: a,
      drawingType: x.DRAWING_GROUP,
      transform: {
        left: 0,
        top: 0
      }
    };
    t.push({
      parent: c,
      children: u
    });
  }), t;
}
const kr = {
  id: "sheet.command.group-sheet-image",
  type: q.COMMAND,
  handler: (i, t) => {
    const e = i.get(Y), n = i.get(Je), r = i.get(se);
    if (!t) return !1;
    const s = [];
    t.forEach(({ parent: h, children: f }) => {
      s.push(h.unitId), f.forEach((m) => {
        s.push(m.unitId);
      });
    });
    const o = r.getGroupDrawingOp(t), { unitId: a, subUnitId: d, undo: u, redo: c, objects: l } = o;
    return e.syncExecuteCommand(P.id, { op: c, unitId: a, subUnitId: d, objects: l, type: U.GROUP }) ? (n.pushUndoRedo({
      unitID: a,
      undoMutations: [
        { id: P.id, params: { op: u, unitId: a, subUnitId: d, objects: Us(l), type: U.UNGROUP } },
        { id: V.id, params: s }
      ],
      redoMutations: [
        { id: P.id, params: { op: c, unitId: a, subUnitId: d, objects: l, type: U.GROUP } },
        { id: V.id, params: s }
      ]
    }), !0) : !1;
  }
}, Xt = {
  id: "sheet.command.insert-sheet-image",
  type: q.COMMAND,
  handler: (i, t) => {
    var S, I, D;
    const e = i.get(Y), n = i.get(Je), r = i.get(se), s = i.get(Vt);
    if (!t) return !1;
    const o = t.drawings, a = o.map((v) => v.unitId), d = r.getBatchAddOp(o), { unitId: u, subUnitId: c, undo: l, redo: g, objects: h } = d, f = s.onCommandExecute({ id: Xt.id, params: t }), m = { id: P.id, params: { op: g, unitId: u, subUnitId: c, objects: h, type: U.INSERT } }, p = { id: P.id, params: { op: l, unitId: u, subUnitId: c, objects: h, type: U.REMOVE } };
    return lr([...(S = f.preRedos) != null ? S : [], m, ...f.redos], e) ? (n.pushUndoRedo({
      unitID: u,
      undoMutations: [
        ...(I = f.preUndos) != null ? I : [],
        p,
        ...f.undos,
        { id: V.id, params: a }
      ],
      redoMutations: [
        ...(D = f.preRedos) != null ? D : [],
        m,
        ...f.redos,
        { id: V.id, params: a }
      ]
    }), !0) : !1;
  }
}, xr = {
  id: "sheet.command.set-drawing-arrange",
  type: q.COMMAND,
  handler: (i, t) => {
    const e = i.get(Y), n = i.get(Je);
    if (!t) return !1;
    const r = i.get(se), { unitId: s, subUnitId: o, drawingIds: a, arrangeType: d } = t, u = { unitId: s, subUnitId: o, drawingIds: a };
    let c;
    if (d === Mt.forward ? c = r.getForwardDrawingsOp(u) : d === Mt.backward ? c = r.getBackwardDrawingOp(u) : d === Mt.front ? c = r.getFrontDrawingsOp(u) : d === Mt.back && (c = r.getBackDrawingsOp(u)), c == null)
      return !1;
    const { objects: l, redo: g, undo: h } = c;
    return e.syncExecuteCommand(P.id, { op: g, unitId: s, subUnitId: o, objects: l, type: U.ARRANGE }) ? (n.pushUndoRedo({
      unitID: s,
      undoMutations: [
        { id: P.id, params: { op: h, unitId: s, subUnitId: o, objects: l, type: U.ARRANGE } }
      ],
      redoMutations: [
        { id: P.id, params: { op: g, unitId: s, subUnitId: o, objects: l, type: U.ARRANGE } }
      ]
    }), !0) : !1;
  }
}, zt = {
  id: "sheet.command.set-sheet-image",
  type: q.COMMAND,
  handler: (i, t) => {
    const e = i.get(Y), n = i.get(Je), r = i.get(se);
    if (!t) return !1;
    const { drawings: s } = t, o = r.getBatchUpdateOp(s), { unitId: a, subUnitId: d, undo: u, redo: c, objects: l } = o;
    return e.syncExecuteCommand(P.id, { unitId: a, subUnitId: d, op: c, objects: l, type: U.UPDATE }) ? (n.pushUndoRedo({
      unitID: a,
      undoMutations: [
        { id: P.id, params: { unitId: a, subUnitId: d, op: u, objects: l, type: U.UPDATE } },
        { id: V.id, params: [a] }
      ],
      redoMutations: [
        { id: P.id, params: { unitId: a, subUnitId: d, op: c, objects: l, type: U.UPDATE } },
        { id: V.id, params: [a] }
      ]
    }), !0) : !1;
  }
}, Wr = {
  id: "sheet.command.ungroup-sheet-image",
  type: q.COMMAND,
  handler: (i, t) => {
    const e = i.get(Y), n = i.get(Je), r = i.get(se);
    if (!t) return !1;
    const s = [];
    t.forEach(({ parent: h, children: f }) => {
      s.push(h.unitId), f.forEach((m) => {
        s.push(m.unitId);
      });
    });
    const o = r.getUngroupDrawingOp(t), { unitId: a, subUnitId: d, undo: u, redo: c, objects: l } = o;
    return e.syncExecuteCommand(P.id, { op: c, unitId: a, subUnitId: d, objects: l, type: U.UNGROUP }) ? (n.pushUndoRedo({
      unitID: a,
      undoMutations: [
        { id: P.id, params: { op: u, unitId: a, subUnitId: d, objects: Os(l), type: U.GROUP } },
        { id: V.id, params: s }
      ],
      redoMutations: [
        { id: P.id, params: { op: c, unitId: a, subUnitId: d, objects: l, type: U.UNGROUP } },
        { id: V.id, params: s }
      ]
    }), !0) : !1;
  }
};
var Ps = Object.getOwnPropertyDescriptor, As = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? Ps(t, e) : t, s = i.length - 1, o; s >= 0; s--)
    (o = i[s]) && (r = o(r) || r);
  return r;
}, ie = (i, t) => (e, n) => t(e, n, i);
function Ns(i, t, e) {
  const n = e * Math.PI / 180, r = Math.abs(i * Math.cos(n)) + Math.abs(t * Math.sin(n)), s = Math.abs(i * Math.sin(n)) + Math.abs(t * Math.cos(n));
  return { rotatedWidth: r, rotatedHeight: s };
}
function _n(i, t, e, n, r) {
  var S;
  const { rotatedHeight: s, rotatedWidth: o } = Ns(e, n, r), d = i.get(Q).getRenderById(t.unitId);
  if (!d)
    return !1;
  const c = (S = d.with(X).getSkeletonParam(t.subUnitId)) == null ? void 0 : S.skeleton;
  if (c == null)
    return !1;
  const l = c.getCellByIndex(t.row, t.col), g = l.mergeInfo.endX - l.mergeInfo.startX - 2, h = l.mergeInfo.endY - l.mergeInfo.startY - 2, f = o / s, p = Math.ceil(Math.min(g, h * f)) / o, w = !p || Number.isNaN(p) ? 1e-3 : p;
  return {
    width: e * w,
    height: n * w
  };
}
let dt = class extends ee {
  constructor(t, e, n, r, s, o, a, d, u, c, l, g, h) {
    super();
    re(this, "_workbookSelections");
    this._context = t, this._skeletonManagerService = e, this._commandService = n, this._selectionRenderService = r, this._imageIoService = s, this._fileOpenerService = o, this._sheetDrawingService = a, this._drawingManagerService = d, this._contextService = u, this._messageService = c, this._localeService = l, this._injector = h, this._workbookSelections = g.getWorkbookSelections(this._context.unitId), this._updateImageListener(), this._updateOrderListener(), this._groupDrawingListener(), this._focusDrawingListener();
  }
  async insertFloatImage() {
    const t = await this._fileOpenerService.openFile({
      multiple: !0,
      accept: zn.map((n) => `.${n.replace("image/", "")}`).join(",")
    }), e = t.length;
    return e > Kn ? (this._messageService.show({
      type: Se.Error,
      content: this._localeService.t("update-status.exceedMaxCount", String(Kn))
    }), !1) : e === 0 ? !1 : (t.forEach(async (n) => await this.insertFloatImageByFile(n)), !0);
  }
  async insertCellImage() {
    const e = (await this._fileOpenerService.openFile({
      multiple: !1,
      accept: zn.map((n) => `.${n.replace("image/", "")}`).join(",")
    }))[0];
    return e ? (await this._insertCellImage(e), !0) : !1;
  }
  insertCellImageByFile(t, e) {
    return this._insertCellImage(t, e);
  }
  async insertFloatImageByFile(t) {
    let e;
    try {
      e = await this._imageIoService.saveImage(t);
    } catch (S) {
      const I = S.message;
      I === xe.ERROR_EXCEED_SIZE ? this._messageService.show({
        type: Se.Error,
        content: this._localeService.t("update-status.exceedMaxSize", String(Zn / (1024 * 1024)))
      }) : I === xe.ERROR_IMAGE_TYPE ? this._messageService.show({
        type: Se.Error,
        content: this._localeService.t("update-status.invalidImageType")
      }) : I === xe.ERROR_IMAGE && this._messageService.show({
        type: Se.Error,
        content: this._localeService.t("update-status.invalidImage")
      });
    }
    if (e == null)
      return;
    const n = this._getUnitInfo(), { unitId: r, subUnitId: s } = n, { imageId: o, imageSourceType: a, source: d, base64Cache: u } = e, { width: c, height: l, image: g } = await nn(u || ""), { width: h, height: f } = this._context.scene;
    this._imageIoService.addImageSourceCache(d, a, g);
    let m = 1;
    if (c > Jn || l > qn) {
      const S = Jn / c, I = qn / l;
      m = Math.max(S, I);
    }
    const p = this._getImagePosition(c * m, l * m, h, f);
    if (p == null)
      return;
    const w = {
      unitId: r,
      subUnitId: s,
      drawingId: o,
      drawingType: x.DRAWING_IMAGE,
      imageSourceType: a,
      source: d,
      transform: Z(p, this._selectionRenderService, this._skeletonManagerService),
      sheetTransform: p
    };
    return this._commandService.executeCommand(Xt.id, {
      unitId: r,
      drawings: [w]
    });
  }
  // eslint-disable-next-line max-lines-per-function
  async _insertCellImage(t, e) {
    var I, D;
    let n;
    try {
      n = await this._imageIoService.saveImage(t);
    } catch (v) {
      const C = v.message;
      C === xe.ERROR_EXCEED_SIZE ? this._messageService.show({
        type: Se.Error,
        content: this._localeService.t("update-status.exceedMaxSize", String(Zn / (1024 * 1024)))
      }) : C === xe.ERROR_IMAGE_TYPE ? this._messageService.show({
        type: Se.Error,
        content: this._localeService.t("update-status.invalidImageType")
      }) : C === xe.ERROR_IMAGE && this._messageService.show({
        type: Se.Error,
        content: this._localeService.t("update-status.invalidImage")
      });
    }
    if (n == null)
      return !1;
    const { imageId: r, imageSourceType: s, source: o, base64Cache: a } = n, { width: d, height: u, image: c } = await nn(a || "");
    this._imageIoService.addImageSourceCache(o, s, c);
    const l = this._workbookSelections.getCurrentLastSelection();
    if (!l)
      return !1;
    let g = l.primary.actualRow, h = l.primary.actualColumn;
    l.primary.isMerged && (g = l.primary.startRow, h = l.primary.startColumn);
    const f = un("", {}), m = _n(
      this._injector,
      {
        unitId: this._context.unitId,
        subUnitId: this._context.unit.getActiveSheet().getSheetId(),
        row: g,
        col: h
      },
      d,
      u,
      0
    );
    if (!m)
      return !1;
    const p = {
      size: {
        width: m.width,
        height: m.height
      },
      positionH: {
        relativeFrom: Wn.PAGE,
        posOffset: 0
      },
      positionV: {
        relativeFrom: xn.PARAGRAPH,
        posOffset: 0
      },
      angle: 0
    }, w = {
      unitId: f.getUnitId(),
      subUnitId: f.getUnitId(),
      drawingId: r,
      drawingType: x.DRAWING_IMAGE,
      imageSourceType: s,
      source: o,
      transform: Xn(p),
      docTransform: p,
      behindDoc: Fn.FALSE,
      title: "",
      description: "",
      layoutType: jn.INLINE,
      // Insert inline drawing by default.
      wrapText: Bn.BOTH_SIDES,
      distB: 0,
      distL: 0,
      distR: 0,
      distT: 0
    }, S = hn.drawing.add({
      documentDataModel: f,
      drawings: [w],
      selection: {
        collapsed: !0,
        startOffset: 0,
        endOffset: 0
      }
    });
    return S ? (f.apply(S), this._commandService.syncExecuteCommand(Ln.id, {
      value: {
        [(I = e == null ? void 0 : e.row) != null ? I : g]: {
          [(D = e == null ? void 0 : e.col) != null ? D : h]: {
            p: f.getSnapshot(),
            t: 1
          }
        }
      },
      unitId: e == null ? void 0 : e.unitId,
      subUnitId: e == null ? void 0 : e.subUnitId
    })) : !1;
  }
  // eslint-disable-next-line max-lines-per-function
  async insertCellImageByUrl(t, e) {
    var g, h;
    const { width: n, height: r, image: s } = await nn(t || "");
    this._imageIoService.addImageSourceCache(t, Ce.URL, s);
    const o = this._workbookSelections.getCurrentLastSelection();
    if (!o)
      return !1;
    const a = un("", {}), d = _n(
      this._injector,
      {
        unitId: this._context.unitId,
        subUnitId: this._context.unit.getActiveSheet().getSheetId(),
        row: o.primary.actualRow,
        col: o.primary.actualColumn
      },
      n,
      r,
      0
    );
    if (!d)
      return !1;
    const u = {
      size: {
        width: d.width,
        height: d.height
      },
      positionH: {
        relativeFrom: Wn.PAGE,
        posOffset: 0
      },
      positionV: {
        relativeFrom: xn.PARAGRAPH,
        posOffset: 0
      },
      angle: 0
    }, c = {
      unitId: a.getUnitId(),
      subUnitId: a.getUnitId(),
      drawingId: Ve(),
      drawingType: x.DRAWING_IMAGE,
      imageSourceType: Ce.URL,
      source: t,
      transform: Xn(u),
      docTransform: u,
      behindDoc: Fn.FALSE,
      title: "",
      description: "",
      layoutType: jn.INLINE,
      // Insert inline drawing by default.
      wrapText: Bn.BOTH_SIDES,
      distB: 0,
      distL: 0,
      distR: 0,
      distT: 0
    }, l = hn.drawing.add({
      documentDataModel: a,
      drawings: [c],
      selection: {
        collapsed: !0,
        startOffset: 0,
        endOffset: 0
      }
    });
    return l ? (a.apply(l), this._commandService.syncExecuteCommand(Ln.id, {
      value: {
        [(g = e == null ? void 0 : e.row) != null ? g : o.primary.actualRow]: {
          [(h = e == null ? void 0 : e.col) != null ? h : o.primary.actualColumn]: {
            p: a.getSnapshot(),
            t: 1
          }
        }
      },
      unitId: e == null ? void 0 : e.unitId,
      subUnitId: e == null ? void 0 : e.subUnitId
    })) : !1;
  }
  _getUnitInfo() {
    const t = this._context.unit, e = t.getActiveSheet(), n = t.getUnitId(), r = e.getSheetId();
    return {
      unitId: n,
      subUnitId: r
    };
  }
  _getImagePosition(t, e, n, r) {
    const s = this._workbookSelections.getCurrentSelections();
    let o = {
      startRow: 0,
      endRow: 0,
      startColumn: 0,
      endColumn: 0
    };
    s && s.length > 0 && (o = s[s.length - 1].range);
    const a = dr(this._skeletonManagerService.getCurrent().skeleton, o);
    if (a == null)
      return;
    let { startColumn: d, startRow: u, startX: c, startY: l } = a, g = !1;
    if (c + t > n && (c = n - t, c < 0 && (c = 0, t = n), g = !0), l + e > r && (l = r - e, l < 0 && (l = 0, e = r), g = !0), g) {
      const p = this._selectionRenderService.getCellWithCoordByOffset(c, l);
      if (p == null)
        return;
      c = p.startX, l = p.startY, d = p.actualColumn, u = p.actualRow;
    }
    const h = {
      column: d,
      columnOffset: 0,
      row: u,
      rowOffset: 0
    }, f = this._selectionRenderService.getCellWithCoordByOffset(c + t, l + e);
    if (f == null)
      return;
    const m = {
      column: f.actualColumn,
      columnOffset: c + t - f.startX,
      row: f.actualRow,
      rowOffset: l + e - f.startY
    };
    return {
      from: h,
      to: m
    };
  }
  _updateOrderListener() {
    this.disposeWithMe(this._drawingManagerService.featurePluginOrderUpdate$.subscribe((t) => {
      const { unitId: e, subUnitId: n, drawingIds: r, arrangeType: s } = t;
      this._commandService.executeCommand(xr.id, {
        unitId: e,
        subUnitId: n,
        drawingIds: r,
        arrangeType: s
      });
    }));
  }
  _updateImageListener() {
    this.disposeWithMe(this._drawingManagerService.featurePluginUpdate$.subscribe((t) => {
      const e = [];
      t.length !== 0 && (t.forEach((n) => {
        const { unitId: r, subUnitId: s, drawingId: o, drawingType: a, transform: d } = n;
        if (d == null)
          return;
        const u = this._sheetDrawingService.getDrawingByParam({ unitId: r, subUnitId: s, drawingId: o });
        if (u == null || u.unitId !== this._context.unitId)
          return;
        const c = j({ ...u.transform, ...d }, this._selectionRenderService);
        if (c == null)
          return;
        const l = {
          ...n,
          transform: { ...u.transform, ...d, ...Z(c, this._selectionRenderService, this._skeletonManagerService) },
          sheetTransform: { ...c }
        };
        e.push(l);
      }), e.length > 0 && this._commandService.executeCommand(zt.id, {
        unitId: t[0].unitId,
        drawings: e
      }));
    }));
  }
  _groupDrawingListener() {
    this.disposeWithMe(this._drawingManagerService.featurePluginGroupUpdate$.subscribe((t) => {
      this._commandService.executeCommand(kr.id, t);
      const { unitId: e, subUnitId: n, drawingId: r } = t[0].parent;
      this._commandService.syncExecuteCommand(Ht.id, [{ unitId: e, subUnitId: n, drawingId: r }]);
    })), this.disposeWithMe(this._drawingManagerService.featurePluginUngroupUpdate$.subscribe((t) => {
      this._commandService.executeCommand(Wr.id, t);
    }));
  }
  _focusDrawingListener() {
    this.disposeWithMe(
      this._drawingManagerService.focus$.subscribe((t) => {
        t == null || t.length === 0 ? (this._contextService.setContextValue(Ge, !1), this._sheetDrawingService.focusDrawing([])) : (this._contextService.setContextValue(Ge, !0), this._sheetDrawingService.focusDrawing(t));
      })
    );
  }
};
dt = As([
  ie(1, A(X)),
  ie(2, Y),
  ie(3, Ze),
  ie(4, ss),
  ie(5, cs),
  ie(6, se),
  ie(7, oe),
  ie(8, ur),
  ie(9, Or),
  ie(10, A(Te)),
  ie(11, A(ut)),
  ie(12, A(qe))
], dt);
const Kt = {
  id: "sheet.command.insert-float-image",
  type: q.COMMAND,
  handler: async (i, t) => {
    var o, a;
    const e = i.get(de), n = i.get(Q), r = (o = Dn(
      $.UNIVER_SHEET,
      e,
      n
    )) == null ? void 0 : o.with(dt);
    if (!r)
      return !1;
    const s = t == null ? void 0 : t.files;
    if (s) {
      const d = s.map((u) => r.insertFloatImageByFile(u));
      return (await Promise.all(d)).every((u) => u);
    } else
      return (a = r.insertFloatImage()) != null ? a : !1;
  }
}, Mn = {
  id: "sheet.command.insert-cell-image",
  type: q.COMMAND,
  handler: (i) => {
    var n, r;
    const t = i.get(de), e = i.get(Q);
    return (r = (n = Dn(
      $.UNIVER_SHEET,
      t,
      e
    )) == null ? void 0 : n.with(dt).insertCellImage()) != null ? r : !1;
  }
}, gt = {
  id: "sheet.command.move-drawing",
  type: q.COMMAND,
  handler: (i, t) => {
    const e = i.get(Y), n = i.get(se), r = i.get(Ze), { direction: s } = t, o = n.getFocusDrawings();
    if (o.length === 0)
      return !1;
    const a = o[0].unitId, d = o.map((c) => {
      const { transform: l } = c;
      if (l == null)
        return null;
      const g = { ...l }, { left: h = 0, top: f = 0 } = l;
      return s === ve.UP ? g.top = f - 1 : s === ve.DOWN ? g.top = f + 1 : s === ve.LEFT ? g.left = h - 1 : s === ve.RIGHT && (g.left = h + 1), {
        ...c,
        transform: g,
        sheetTransform: j(g, r)
      };
    }).filter((c) => c != null);
    return e.syncExecuteCommand(zt.id, {
      unitId: a,
      drawings: d
    }) ? (e.syncExecuteCommand(V.id, [a]), !0) : !1;
  }
};
var $s = Object.getOwnPropertyDescriptor, ks = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? $s(t, e) : t, s = i.length - 1, o; s >= 0; s--)
    (o = i[s]) && (r = o(r) || r);
  return r;
}, an = (i, t) => (e, n) => t(e, n, i), ye = /* @__PURE__ */ ((i) => (i.CELL_ADDRESS = "cellAddress", i.COLUMN_VALUE = "columnValue", i))(ye || {});
const yn = pi("sheets-drawing-ui.batch-save-images.service");
function Sn(i) {
  let t = "", e = i;
  for (; e >= 0; )
    t = String.fromCharCode(e % 26 + 65) + t, e = Math.floor(e / 26) - 1;
  return t;
}
function At(i, t) {
  return `${Sn(t)}${i + 1}`;
}
function xs(i) {
  const t = At(i.startRow, i.startColumn), e = At(i.endRow, i.endColumn);
  return t === e ? t : `${t}:${e}`;
}
function nr(i) {
  var t, e, n, r;
  return !!((e = (t = i == null ? void 0 : i.p) == null ? void 0 : t.drawingsOrder) != null && e.length && ((r = (n = i == null ? void 0 : i.p) == null ? void 0 : n.drawingsOrder) == null ? void 0 : r.length) > 0);
}
function rr(i) {
  var n, r, s;
  if (!((r = (n = i.p) == null ? void 0 : n.drawingsOrder) != null && r.length) || !((s = i.p) != null && s.drawings))
    return null;
  const t = i.p.drawingsOrder[0], e = i.p.drawings[t];
  return !e || !("source" in e) || !("imageSourceType" in e) ? null : e;
}
function cn(i, t) {
  if (t === Ce.BASE64) {
    const e = i.match(/^data:image\/(\w+);/);
    if (e)
      return e[1] === "jpeg" ? "jpg" : e[1];
  }
  if (t === Ce.URL) {
    const e = i.match(/\.(\w+)(?:\?|$)/);
    if (e)
      return e[1].toLowerCase();
  }
  return "png";
}
async function ir(i, t) {
  if (t === Ce.BASE64)
    return (await fetch(i)).blob();
  if (t === Ce.URL)
    return (await fetch(i)).blob();
  throw new Error("UUID image type requires additional handling");
}
let vn = class extends ee {
  constructor(i, t, e) {
    super(), this._univerInstanceService = i, this._selectionService = t, this._imageIoService = e;
  }
  getCellImagesInSelection() {
    const i = this._univerInstanceService.getCurrentUnitForType($.UNIVER_SHEET);
    if (!i) return [];
    const t = i.getActiveSheet();
    if (!t) return [];
    const e = this._selectionService.getCurrentSelections();
    if (!e || e.length === 0) return [];
    const n = t.getCellMatrix(), r = [];
    for (const s of e) {
      const { startRow: o, endRow: a, startColumn: d, endColumn: u } = s.range;
      for (let c = o; c <= a; c++)
        for (let l = d; l <= u; l++) {
          const g = n.getValue(c, l);
          if (nr(g)) {
            const h = rr(g);
            h && r.push({
              row: c,
              col: l,
              cellAddress: At(c, l),
              source: h.source,
              imageSourceType: h.imageSourceType,
              imageId: h.drawingId
            });
          }
        }
    }
    return r;
  }
  getCellImagesFromRanges(i, t, e) {
    const n = this._univerInstanceService.getUnit(i, $.UNIVER_SHEET);
    if (!n) return [];
    const r = n.getSheetBySheetId(t);
    if (!r) return [];
    const s = r.getCellMatrix(), o = [];
    for (const a of e) {
      const { startRow: d, endRow: u, startColumn: c, endColumn: l } = a;
      for (let g = d; g <= u; g++)
        for (let h = c; h <= l; h++) {
          const f = s.getValue(g, h);
          if (nr(f)) {
            const m = rr(f);
            m && o.push({
              row: g,
              col: h,
              cellAddress: At(g, h),
              source: m.source,
              imageSourceType: m.imageSourceType,
              imageId: m.drawingId
            });
          }
        }
    }
    return o;
  }
  getDataColumns() {
    var l, g, h, f;
    const i = this._univerInstanceService.getCurrentUnitForType($.UNIVER_SHEET);
    if (!i) return [];
    const t = i.getActiveSheet();
    if (!t) return [];
    const e = this._selectionService.getCurrentSelections();
    if (!e || e.length === 0) return [];
    const n = t.getCellMatrix(), r = n.getDataRange();
    let s = 1 / 0, o = -1 / 0;
    const a = /* @__PURE__ */ new Set();
    for (const m of e) {
      s = Math.min(s, m.range.startRow), o = Math.max(o, m.range.endRow);
      for (let p = m.range.startColumn; p <= m.range.endColumn; p++)
        a.add(p);
    }
    const d = /* @__PURE__ */ new Set();
    for (let m = r.startColumn; m <= r.endColumn; m++)
      if (!a.has(m))
        for (let p = s; p <= o; p++) {
          const w = n.getValue(p, m);
          if (w && (((l = w.v) == null ? void 0 : l.toString()) || ((f = (h = (g = w.p) == null ? void 0 : g.body) == null ? void 0 : h.dataStream) == null ? void 0 : f.trim()) || "")) {
            d.add(m);
            break;
          }
        }
    const u = [], c = Array.from(d).sort((m, p) => m - p);
    for (const m of c)
      u.push({
        index: m,
        label: Sn(m)
      });
    return u;
  }
  getDataColumnsForRanges(i, t, e) {
    var h, f, m, p;
    const n = this._univerInstanceService.getUnit(i, $.UNIVER_SHEET);
    if (!n) return [];
    const r = n.getSheetBySheetId(t);
    if (!r) return [];
    const s = r.getCellMatrix(), o = s.getDataRange();
    let a = 1 / 0, d = -1 / 0;
    const u = /* @__PURE__ */ new Set();
    for (const w of e) {
      a = Math.min(a, w.startRow), d = Math.max(d, w.endRow);
      for (let S = w.startColumn; S <= w.endColumn; S++)
        u.add(S);
    }
    const c = /* @__PURE__ */ new Set();
    for (let w = o.startColumn; w <= o.endColumn; w++)
      if (!u.has(w))
        for (let S = a; S <= d; S++) {
          const I = s.getValue(S, w);
          if (I && (((h = I.v) == null ? void 0 : h.toString()) || ((p = (m = (f = I.p) == null ? void 0 : f.body) == null ? void 0 : m.dataStream) == null ? void 0 : p.trim()) || "")) {
            c.add(w);
            break;
          }
        }
    const l = [], g = Array.from(c).sort((w, S) => w - S);
    for (const w of g)
      l.push({
        index: w,
        label: Sn(w)
      });
    return l;
  }
  getSelectionRangeNotation() {
    const i = this._selectionService.getCurrentSelections();
    return !i || i.length === 0 ? "" : i.map((t) => xs(t.range)).join(", ");
  }
  getSelectionRowRange() {
    const i = this._selectionService.getCurrentSelections();
    if (!i || i.length === 0) return null;
    let t = 1 / 0, e = -1 / 0;
    for (const n of i)
      t = Math.min(t, n.range.startRow), e = Math.max(e, n.range.endRow);
    return { startRow: t, endRow: e };
  }
  getSelectionColumnIndices() {
    const i = this._selectionService.getCurrentSelections();
    if (!i || i.length === 0) return /* @__PURE__ */ new Set();
    const t = /* @__PURE__ */ new Set();
    for (const e of i)
      for (let n = e.range.startColumn; n <= e.range.endColumn; n++)
        t.add(n);
    return t;
  }
  generateFileName(i, t) {
    var s, o, a, d;
    const e = this._univerInstanceService.getCurrentUnitForType($.UNIVER_SHEET), n = cn(i.source, i.imageSourceType), r = [];
    for (const u of t.fileNameParts)
      if (u === "cellAddress")
        r.push(i.cellAddress);
      else if (u === "columnValue" && t.columnIndex !== void 0) {
        const c = e == null ? void 0 : e.getActiveSheet();
        if (c) {
          const g = c.getCellMatrix().getValue(i.row, t.columnIndex);
          if (g) {
            const h = ((s = g.v) == null ? void 0 : s.toString()) || ((d = (a = (o = g.p) == null ? void 0 : o.body) == null ? void 0 : a.dataStream) == null ? void 0 : d.trim()) || "";
            if (h) {
              const f = h.replace(/[<>:"/\\|?*]/g, "_").trim();
              f && r.push(f);
            }
          }
        }
      }
    return r.length === 0 ? `${i.cellAddress}.${n}` : `${r.join("_")}.${n}`;
  }
  generateFileNameWithContext(i, t, e, n) {
    var a, d, u, c;
    const r = this._univerInstanceService.getUnit(e, $.UNIVER_SHEET), s = cn(i.source, i.imageSourceType), o = [];
    for (const l of t.fileNameParts)
      if (l === "cellAddress")
        o.push(i.cellAddress);
      else if (l === "columnValue" && t.columnIndex !== void 0) {
        const g = r == null ? void 0 : r.getSheetBySheetId(n);
        if (g) {
          const f = g.getCellMatrix().getValue(i.row, t.columnIndex);
          if (f) {
            const m = ((a = f.v) == null ? void 0 : a.toString()) || ((c = (u = (d = f.p) == null ? void 0 : d.body) == null ? void 0 : u.dataStream) == null ? void 0 : c.trim()) || "";
            if (m) {
              const p = m.replace(/[<>:"/\\|?*]/g, "_").trim();
              p && o.push(p);
            }
          }
        }
      }
    return o.length === 0 ? `${i.cellAddress}.${s}` : `${o.join("_")}.${s}`;
  }
  async saveImages(i, t) {
    var r;
    const e = await window.showDirectoryPicker({ mode: "readwrite" }), n = /* @__PURE__ */ new Map();
    for (const s of i) {
      let o = this.generateFileName(s, t);
      const a = o.replace(/\.\w+$/, ""), d = ((r = o.match(/\.\w+$/)) == null ? void 0 : r[0]) || ".png", u = n.get(a) || 0;
      u > 0 && (o = `${a}_${u}${d}`), n.set(a, u + 1);
      try {
        const c = await this._getImageBlob(s), g = await (await e.getFileHandle(o, { create: !0 })).createWritable();
        await g.write(c), await g.close();
      } catch (c) {
        throw console.error(`Failed to save image ${o}:`, c), c;
      }
    }
  }
  async saveImagesWithContext(i, t, e, n) {
    var o;
    const r = await window.showDirectoryPicker({ mode: "readwrite" }), s = /* @__PURE__ */ new Map();
    for (const a of i) {
      let d = this.generateFileNameWithContext(a, t, e, n);
      const u = d.replace(/\.\w+$/, ""), c = ((o = d.match(/\.\w+$/)) == null ? void 0 : o[0]) || ".png", l = s.get(u) || 0;
      l > 0 && (d = `${u}_${l}${c}`), s.set(u, l + 1);
      try {
        const g = await this._getImageBlob(a), f = await (await r.getFileHandle(d, { create: !0 })).createWritable();
        await f.write(g), await f.close();
      } catch (g) {
        throw console.error(`Failed to save image ${d}:`, g), g;
      }
    }
  }
  async downloadSingleImage(i) {
    const t = cn(i.source, i.imageSourceType), e = `${i.cellAddress}.${t}`;
    try {
      const n = await this._getImageBlob(i), r = URL.createObjectURL(n), s = document.createElement("a");
      s.href = r, s.download = e, document.body.appendChild(s), s.click(), document.body.removeChild(s), URL.revokeObjectURL(r);
    } catch (n) {
      throw console.error(`Failed to download image ${e}:`, n), n;
    }
  }
  async _getImageBlob(i) {
    if (i.imageSourceType === Ce.UUID) {
      const t = await this._imageIoService.getImage(i.source);
      return ir(t, Ce.URL);
    }
    return ir(i.source, i.imageSourceType);
  }
};
vn = ks([
  an(0, de),
  an(1, A(ut)),
  an(2, hr)
], vn);
const ze = "sheet.dialog.batch-save-images", ct = {
  id: "sheet.command.save-cell-images",
  type: q.COMMAND,
  handler: async (i) => {
    const t = i.get(bn), e = i.get(yn), n = e.getCellImagesInSelection();
    if (n.length === 1)
      try {
        return await e.downloadSingleImage(n[0]), !0;
      } catch (a) {
        return console.error("Failed to download image:", a), !1;
      }
    const r = i.get(Te), s = e.getSelectionRangeNotation(), o = `${r.t("sheetImage.save.title")} (${s})`;
    return t.open({
      id: ze,
      draggable: !0,
      width: 360,
      title: { title: o },
      children: {
        label: ze
      },
      destroyOnClose: !0,
      preservePositionOnDestroy: !0,
      onClose: () => t.close(ze)
    }), !0;
  }
}, Br = "COMPONENT_SHEET_DRAWING_PANEL", jr = {
  id: "sidebar.operation.sheet-image",
  type: q.COMMAND,
  handler: async (i, t) => {
    const e = i.get(ds), n = i.get(Te), r = i.get(de), s = i.get(Y);
    if (!ae(r)) return !1;
    switch (t.value) {
      case "open":
        e.open({
          header: { title: n.t("sheetImage.panel.title") },
          children: { label: Br },
          onClose: () => {
            s.syncExecuteCommand(Ht.id, []);
          },
          width: 360
        });
        break;
      case "close":
      default:
        e.close();
        break;
    }
    return !0;
  }
}, Fr = {
  id: "sheet.operation.edit-sheet-image",
  type: q.OPERATION,
  handler: (i, t) => {
    const e = i.get(Y);
    return t == null ? !1 : (e.syncExecuteCommand(Ht.id, [t]), e.executeCommand(jr.id, { value: "open" }), !0);
  }
}, Ws = "sheets-drawing-ui.config", sr = {};
var Bs = Object.getOwnPropertyDescriptor, js = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? Bs(t, e) : t, s = i.length - 1, o; s >= 0; s--)
    (o = i[s]) && (r = o(r) || r);
  return r;
}, ce = (i, t) => (e, n) => t(e, n, i);
let Nt = class extends wi {
  constructor(t, e, n, r, s, o, a, d, u, c) {
    super();
    re(this, "_initImagePopupMenu", /* @__PURE__ */ new Set());
    this._injector = t, this._localeService = e, this._drawingManagerService = n, this._canvasPopManagerService = r, this._renderManagerService = s, this._univerInstanceService = o, this._messageService = a, this._contextService = d, this._ioService = u, this._commandService = c, this._init();
  }
  _init() {
    this._univerInstanceService.getCurrentTypeOfUnit$($.UNIVER_SHEET).pipe(Qn(this.dispose$)).subscribe((t) => this._create(t)), this._univerInstanceService.getTypeOfUnitDisposed$($.UNIVER_SHEET).pipe(Qn(this.dispose$)).subscribe((t) => this._dispose(t)), this._univerInstanceService.getAllUnitsForType($.UNIVER_SHEET).forEach((t) => this._create(t)), this._setupLoadingStatus();
  }
  _setupLoadingStatus() {
    const t = "image-upload-loading";
    let e;
    this.disposeWithMe(this._ioService.change$.subscribe((n) => {
      n > 0 && !e ? e = this._messageService.show({
        id: t,
        type: Se.Loading,
        content: `${this._localeService.t("uploadLoading.loading")}: ${n}`,
        duration: 0
      }) : n === 0 && (e == null || e.dispose(), e = void 0);
    }));
  }
  _dispose(t) {
    super.dispose();
    const e = t.getUnitId();
    this._renderManagerService.removeRender(e);
  }
  _create(t) {
    if (!t)
      return;
    const e = t.getUnitId();
    this._renderManagerService.has(e) && !this._initImagePopupMenu.has(e) && (this._popupMenuListener(e), this._initImagePopupMenu.add(e));
  }
  _hasCropObject(t) {
    const e = t.getAllObjectsByOrder();
    for (const n of e)
      if (n instanceof Ss)
        return !0;
    return !1;
  }
  _popupMenuListener(t) {
    var s;
    const e = (s = this._renderManagerService.getRenderById(t)) == null ? void 0 : s.scene;
    if (!e)
      return;
    const n = e.getTransformerByCreate();
    if (!n)
      return;
    let r;
    this.disposeWithMe(
      n.createControl$.subscribe(() => {
        if (this._contextService.setContextValue(Ge, !0), this._hasCropObject(e))
          return;
        const o = n.getSelectedObjectMap();
        if (o.size > 1) {
          r == null || r.dispose();
          return;
        }
        const a = o.values().next().value;
        if (!a)
          return;
        const d = a.oKey, u = this._drawingManagerService.getDrawingOKey(d);
        if (!u)
          return;
        const { unitId: c, subUnitId: l, drawingId: g, drawingType: h } = u, f = u.data;
        if (f && f.disablePopup)
          return;
        r == null || r.dispose();
        const m = this._canvasPopManagerService.getFeatureMenu(c, l, g, h);
        r = this.disposeWithMe(this._canvasPopManagerService.attachPopupToObject(a, {
          componentKey: vs,
          direction: "horizontal",
          offset: [2, 0],
          extraProps: {
            menuItems: m || this._getImageMenuItems(c, l, g, h)
          }
        }));
      })
    ), this.disposeWithMe(
      n.clearControl$.subscribe(() => {
        r == null || r.dispose(), this._contextService.setContextValue(Ge, !1), this._commandService.syncExecuteCommand(Ht.id, []);
      })
    ), this.disposeWithMe(
      this._contextService.contextChanged$.subscribe((o) => {
        o[Ge] === !1 && (r == null || r.dispose());
      })
    ), this.disposeWithMe(
      n.changing$.subscribe(() => {
        r == null || r.dispose();
      })
    );
  }
  _getImageMenuItems(t, e, n, r) {
    return [
      {
        label: "image-popup.edit",
        index: 0,
        commandId: Fr.id,
        commandParams: { unitId: t, subUnitId: e, drawingId: n },
        disable: r === x.DRAWING_DOM
      },
      {
        label: "image-popup.delete",
        index: 1,
        commandId: ht.id,
        commandParams: { unitId: t, drawings: [{ unitId: t, subUnitId: e, drawingId: n }] },
        disable: !1
      },
      {
        label: "image-popup.crop",
        index: 2,
        commandId: Is.id,
        commandParams: { unitId: t, subUnitId: e, drawingId: n },
        disable: r === x.DRAWING_DOM
      },
      {
        label: "image-popup.reset",
        index: 3,
        commandId: Cs.id,
        commandParams: [{ unitId: t, subUnitId: e, drawingId: n }],
        disable: r === x.DRAWING_DOM
      }
    ];
  }
};
Nt = js([
  ce(0, A(qe)),
  ce(1, A(Te)),
  ce(2, oe),
  ce(3, A(si)),
  ce(4, Q),
  ce(5, de),
  ce(6, Or),
  ce(7, ur),
  ce(8, hr),
  ce(9, Y)
], Nt);
var Fs = Object.getOwnPropertyDescriptor, Ls = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? Fs(t, e) : t, s = i.length - 1, o; s >= 0; s--)
    (o = i[s]) && (r = o(r) || r);
  return r;
}, Tt = (i, t) => (e, n) => t(e, n, i);
let In = class extends ee {
  constructor(t, e, n, r, s) {
    super();
    re(this, "_isSetCursor", !1);
    this._context = t, this._hoverManagerService = e, this._selectionsService = n, this._drawingRenderService = r, this._sheetSkeletonManagerService = s, this._initHover(), this._initImageClick();
  }
  _initHover() {
    this.disposeWithMe(this._hoverManagerService.currentRichTextNoDistinct$.pipe(bs(33)).subscribe((t) => {
      var n, r;
      let e = [];
      t !== null && (e = this._selectionsService.getWorkbookSelections(this._context.unitId).getCurrentSelections()), e.length > 0 && (t == null ? void 0 : t.unitId) === this._context.unitId && (t != null && t.drawing) && e.length === 1 && ((n = e[0].primary) == null ? void 0 : n.actualRow) === t.row && ((r = e[0].primary) == null ? void 0 : r.actualColumn) === t.col ? (this._isSetCursor = !0, this._context.scene.setCursor(ri.ZOOM_IN)) : this._isSetCursor && (this._isSetCursor = !1, this._context.scene.resetCursor());
    }));
  }
  _initImageClick() {
    this.disposeWithMe(this._hoverManagerService.currentClickedCell$.subscribe((t) => {
      var e;
      if (t != null && t.drawing && this._isSetCursor) {
        const n = t.drawing.drawing.drawingOrigin, r = (e = this._sheetSkeletonManagerService.getCurrentSkeleton()) == null ? void 0 : e.imageCacheMap.getImage(n.imageSourceType, n.source);
        if (!r) return;
        this._drawingRenderService.previewImage("preview-cell-image", r.src, r.width, r.height), this._context.scene.resetCursor(), this._isSetCursor = !1;
      }
    }));
  }
};
In = Ls([
  Tt(1, A(oi)),
  Tt(2, A(ut)),
  Tt(3, A(Pr)),
  Tt(4, A(X))
], In);
var Vs = Object.getOwnPropertyDescriptor, Hs = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? Vs(t, e) : t, s = i.length - 1, o; s >= 0; s--)
    (o = i[s]) && (r = o(r) || r);
  return r;
}, Ot = (i, t) => (e, n) => t(e, n, i);
let Cn = class extends ee {
  constructor(i, t, e, n, r) {
    super(), this._context = i, this._sheetDrawingService = t, this._drawingManagerService = e, this._sheetSelectionRenderService = n, this._sheetSkeletonManagerService = r, this._init();
  }
  _init() {
    this._drawingInitializeListener();
  }
  _drawingInitializeListener() {
    this._sheetDrawingService.initializeNotification(this._context.unitId);
    const i = this._sheetDrawingService.getDrawingDataForUnit(this._context.unitId);
    for (const t in i) {
      const e = i[t];
      for (const n in e.data) {
        const r = e.data[n];
        r.sheetTransform && (r.transform = Z(r.sheetTransform, this._sheetSelectionRenderService, this._sheetSkeletonManagerService));
      }
    }
    this._drawingManagerService.registerDrawingData(this._context.unitId, this._sheetDrawingService.getDrawingDataForUnit(this._context.unitId)), this._drawingManagerService.initializeNotification(this._context.unitId);
  }
};
Cn = Hs([
  Ot(1, se),
  Ot(2, oe),
  Ot(3, A(Ze)),
  Ot(4, A(X))
], Cn);
var Ys = Object.getOwnPropertyDescriptor, Gs = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? Ys(t, e) : t, s = i.length - 1, o; s >= 0; s--)
    (o = i[s]) && (r = o(r) || r);
  return r;
}, We = (i, t) => (e, n) => t(e, n, i);
function Lr(i, t, e) {
  var n, r, s, o;
  if (((r = (n = e == null ? void 0 : e.p) == null ? void 0 : n.body) == null ? void 0 : r.dataStream.length) === 3 && ((o = (s = e.p) == null ? void 0 : s.drawingsOrder) == null ? void 0 : o.length) === 1) {
    const a = e.p.drawings[e.p.drawingsOrder[0]], d = _n(
      i,
      {
        unitId: t.unitId,
        subUnitId: t.subUnitId,
        row: t.row,
        col: t.col
      },
      a.docTransform.size.width,
      a.docTransform.size.height,
      a.docTransform.angle
    );
    if (d)
      return a.transform.width = d.width, a.transform.height = d.height, a.docTransform.size.width = d.width, a.docTransform.size.height = d.height, a.transform.left = 0, a.transform.top = 0, a.docTransform.positionH.posOffset = 0, a.docTransform.positionV.posOffset = 0, e.p.documentStyle.pageSize.width = 1 / 0, e.p.documentStyle.pageSize.height = 1 / 0, !0;
  }
  return !1;
}
let $t = class extends ee {
  constructor(i, t, e, n, r, s) {
    super(), this._commandService = i, this._sheetInterceptorService = t, this._injector = e, this._drawingManagerService = n, this._docDrawingController = r, this._editorBridgeService = s, this._handleInitEditor(), this._initCellContentInterceptor();
  }
  _handleInitEditor() {
    this.disposeWithMe(this._editorBridgeService.visible$.subscribe((i) => {
      i.visible ? i.visible && (this._drawingManagerService.removeDrawingDataForUnit(ot), this._docDrawingController.loadDrawingDataForUnit(ot), this._drawingManagerService.initializeNotification(ot)) : this._drawingManagerService.removeDrawingDataForUnit(ot);
    })), this.disposeWithMe(this._commandService.onCommandExecuted((i) => {
      i.id === rs.id && i.params.unitId === He && (this._drawingManagerService.removeDrawingDataForUnit(He), this._docDrawingController.loadDrawingDataForUnit(He), this._drawingManagerService.initializeNotification(He));
    }));
  }
  _initCellContentInterceptor() {
    this.disposeWithMe(
      this._sheetInterceptorService.intercept(
        xi.CELL_CONTENT,
        {
          effect: _i.Style,
          priority: Wi.CELL_IMAGE,
          handler: (i, t, e) => {
            var n;
            return i != null && i.p && ((n = i.p.drawingsOrder) != null && n.length) && (i === t.rawData && (i = { ...t.rawData }), i.interceptorStyle || (i.interceptorStyle = {}), i.interceptorStyle.tr = { a: 0 }, Lr(this._injector, { unitId: t.unitId, subUnitId: t.subUnitId, row: t.row, col: t.col }, i)), e(i);
          }
        }
      )
    );
  }
};
$t = Gs([
  We(0, Y),
  We(1, A(Vt)),
  We(2, A(qe)),
  We(3, oe),
  We(4, A(ws)),
  We(5, A(ai))
], $t);
var Xs = Object.getOwnPropertyDescriptor, zs = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? Xs(t, e) : t, s = i.length - 1, o; s >= 0; s--)
    (o = i[s]) && (r = o(r) || r);
  return r;
}, or = (i, t) => (e, n) => t(e, n, i);
let kt = class extends ee {
  constructor(i, t) {
    super(), this._autoFillService = i, this._injector = t, this._initAutoFillHooks();
  }
  _initAutoFillHooks() {
    this.disposeWithMe(
      this._autoFillService.addHook({
        id: "sheet-cell-image-autofill",
        onBeforeSubmit: (i, t, e, n) => {
          new Si(n).forValue((r, s, o) => {
            Lr(this._injector, { unitId: i.unitId, subUnitId: i.subUnitId, row: r, col: s }, o);
          });
        }
      })
    );
  }
};
kt = zs([
  or(0, A(ci)),
  or(1, A(qe))
], kt);
var Ks = Object.getOwnPropertyDescriptor, Zs = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? Ks(t, e) : t, s = i.length - 1, o; s >= 0; s--)
    (o = i[s]) && (r = o(r) || r);
  return r;
}, nt = (i, t) => (e, n) => t(e, n, i);
const Js = [
  ot,
  vi,
  He
];
let xt = class extends ee {
  constructor(i, t, e, n, r) {
    super(), this._commandService = i, this._univerInstanceService = t, this._dialogService = e, this._renderManagerService = n, this._localeService = r, this._initDocImageCopyPasteHooks();
  }
  _setCellImage(i) {
    var r;
    const t = un("", {}), e = (r = Dn($.UNIVER_SHEET, this._univerInstanceService, this._renderManagerService)) == null ? void 0 : r.with(di), n = hn.drawing.add({
      documentDataModel: t,
      drawings: [i],
      selection: {
        collapsed: !0,
        startOffset: 0,
        endOffset: 0
      }
    });
    n && (t.apply(n), e && e.submitCellData(t));
  }
  _initDocImageCopyPasteHooks() {
    this.disposeWithMe(
      this._commandService.beforeCommandExecuted((i) => {
        var t, e;
        if (i.id === is.id) {
          const n = i.params, { doc: r } = n, s = this._univerInstanceService.getCurrentUnitOfType($.UNIVER_DOC);
          if (s == null || !Object.keys((t = r.drawings) != null ? t : {}).length)
            return;
          const o = s.getUnitId();
          if (Js.includes(o)) {
            if (o !== He) {
              const a = () => {
                this._dialogService.close("sheet-cell-image-copy-paste"), this._commandService.syncExecuteCommand(Nn.id, {
                  visible: !1
                });
              };
              ((e = s.getBody()) == null ? void 0 : e.dataStream) === `\r
` ? (this._commandService.syncExecuteCommand(Nn.id, {
                visible: !1
              }), this._setCellImage(Object.values(r.drawings)[0])) : this._dialogService.open({
                id: "sheet-cell-image-copy-paste",
                title: {
                  label: this._localeService.t("cell-image.pasteTitle")
                },
                children: {
                  label: this._localeService.t("cell-image.pasteContent")
                },
                width: 320,
                destroyOnClose: !0,
                onClose: a,
                showOk: !0,
                showCancel: !0,
                onOk: () => {
                  a(), this._setCellImage(Object.values(r.drawings)[0]);
                },
                onCancel: a
              });
            }
            throw new Error("Sheet cell image copy paste is not supported in this unit");
          }
        }
      })
    );
  }
};
xt = Zs([
  nt(0, Y),
  nt(1, de),
  nt(2, bn),
  nt(3, Q),
  nt(4, A(Te))
], xt);
var qs = Object.getOwnPropertyDescriptor, Qs = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? qs(t, e) : t, s = i.length - 1, o; s >= 0; s--)
    (o = i[s]) && (r = o(r) || r);
  return r;
}, rt = (i, t) => (e, n) => t(e, n, i);
const Vr = "image/png";
function eo(i) {
  const t = i.split(","), e = atob(t[1]), n = e.length, r = new Uint8Array(n);
  for (let s = 0; s < n; s++)
    r[s] = e.charCodeAt(s);
  return new Blob([r], { type: Vr });
}
function to(i) {
  const t = new ClipboardItem({ [Vr]: eo(i) });
  navigator.clipboard.write([t]).catch((e) => {
    console.error("Could not copy image using clipboard API: ", e);
  });
}
function no() {
  function i() {
    const n = document.createElement("input");
    return n.style.position = "absolute", n.style.height = "1px", n.style.width = "1px", n.style.opacity = "0", n;
  }
  const t = document.activeElement, e = i();
  return document.body.appendChild(e), e.focus(), () => {
    e.blur(), document.body.removeChild(e), t instanceof HTMLElement && t.focus();
  };
}
const ar = [
  Le.SPECIAL_PASTE_COL_WIDTH,
  Le.SPECIAL_PASTE_VALUE,
  Le.SPECIAL_PASTE_FORMAT,
  Le.SPECIAL_PASTE_FORMULA
];
let Wt = class extends ee {
  constructor(t, e, n, r, s) {
    super();
    re(this, "_copyInfo");
    this._sheetClipboardService = t, this._renderManagerService = e, this._drawingService = n, this._clipboardInterfaceService = r, this._commandService = s, this._initCopyPaste();
  }
  get _focusedDrawings() {
    return this._drawingService.getFocusDrawings();
  }
  // eslint-disable-next-line max-lines-per-function
  _initCopyPaste() {
    this._sheetClipboardService.addClipboardHook({
      id: "SHEET_IMAGE_UI_PLUGIN",
      onBeforeCopy: (t, e, n, r) => {
        this._copyInfo = null;
        const s = this._focusedDrawings;
        if (s.length > 0) {
          const [o] = s;
          if (o.drawingType !== x.DRAWING_IMAGE)
            return;
          if (r === Re.CUT) {
            const d = {
              unitId: t,
              drawings: [o]
            };
            this._commandService.executeCommand(ht.id, d);
          }
          setTimeout(() => {
            const d = no();
            o.drawingType === x.DRAWING_IMAGE && o.imageSourceType === os.BASE64 ? to(o.source) : this._clipboardInterfaceService.writeText(""), d();
          }, 200);
          const a = {
            unitId: o.unitId,
            subUnitId: o.subUnitId,
            drawings: [o]
          };
          this._copyInfo = a;
        } else {
          const o = this._createDrawingsCopyInfoByRange(t, e, n);
          this._copyInfo = o;
        }
      },
      onPasteCells: (t, e, n, r) => {
        if (!this._copyInfo)
          return { redos: [], undos: [] };
        const { copyType: s = Re.COPY, pasteType: o } = r, { range: a } = t || {}, { range: d, unitId: u, subUnitId: c } = e;
        return this._copyInfo.copyRange ? this._generateRangeDrawingsPasteMutations({ pasteType: o, unitId: u, subUnitId: c, pasteRange: d }, { copyRange: a, copyType: s }) : this._generateSingleDrawingPasteMutations({ pasteTo: e, pasteType: o }, Re.COPY);
      },
      onPastePlainText: (t, e) => ({ undos: [], redos: [] }),
      onPasteUnrecognized: (t) => this._copyInfo ? this._generateSingleDrawingPasteMutations({ pasteTo: t, pasteType: Le.DEFAULT_PASTE }, Re.COPY) : { undos: [], redos: [] },
      onPasteFiles: (t, e) => {
        if (this._copyInfo)
          return this._generateSingleDrawingPasteMutations({ pasteTo: t, pasteType: Le.DEFAULT_PASTE }, Re.COPY);
        {
          const n = e.filter((r) => r.type.includes("image"));
          if (n.length)
            return {
              undos: [],
              redos: [
                {
                  id: Kt.id,
                  params: { files: n }
                }
              ]
            };
        }
        return { undos: [], redos: [] };
      }
    });
  }
  _createDrawingsCopyInfoByRange(t, e, n) {
    var g;
    const r = (g = this._renderManagerService.getRenderById(t)) == null ? void 0 : g.with(X);
    if (!r) return;
    const s = r.attachRangeWithCoord(n);
    if (!s)
      return;
    const { startX: o, endX: a, startY: d, endY: u } = s, c = this._drawingService.getDrawingData(t, e), l = this._focusedDrawings.slice();
    if (Object.keys(c).forEach((h) => {
      const f = c[h];
      if (f.drawingType !== x.DRAWING_IMAGE)
        return;
      const { transform: m } = f;
      if (f.anchorType !== O.Both || !m)
        return;
      const { left: p = 0, top: w = 0, width: S = 0, height: I = 0 } = m, { drawingStartX: D, drawingEndX: v, drawingStartY: C, drawingEndY: _ } = {
        drawingStartX: p,
        drawingEndX: p + S,
        drawingStartY: w,
        drawingEndY: w + I
      };
      o <= D && v <= a && d <= C && _ <= u && l.push(f);
    }), l.length)
      return {
        copyRange: n,
        drawings: l,
        unitId: t,
        subUnitId: e
      };
  }
  _generateSingleDrawingPasteMutations(t, e) {
    const { pasteType: n, pasteTo: r } = t;
    if (ar.includes(n))
      return { redos: [], undos: [] };
    const { unitId: s, subUnitId: o, range: a } = r, d = this._renderManagerService.getRenderById(s), u = d == null ? void 0 : d.with(X), c = d == null ? void 0 : d.with(Ze), l = this._copyInfo;
    if (!u || !c)
      return { redos: [], undos: [] };
    const { drawings: g } = l, h = $n(a);
    return this._generateMutations(g, {
      unitId: s,
      subUnitId: o,
      isCut: e === Re.CUT,
      getTransform: (f, m) => {
        var S;
        const p = u.attachRangeWithCoord({
          startRow: h.startRow,
          endRow: h.endRow,
          startColumn: h.startColumn,
          endColumn: h.endColumn
        }), w = {
          ...f,
          left: p == null ? void 0 : p.startX,
          top: p == null ? void 0 : p.startY
        };
        return {
          transform: w,
          sheetTransform: (S = j(w, c)) != null ? S : m
        };
      }
    });
  }
  _generateMutations(t, e) {
    const {
      unitId: n,
      subUnitId: r,
      getTransform: s,
      isCut: o
    } = e, a = [], d = [], { _drawingService: u } = this;
    return t.forEach((c) => {
      const { transform: l, sheetTransform: g } = c;
      if (!l)
        return;
      const h = s(l, g), f = {
        ...c,
        unitId: n,
        subUnitId: r,
        drawingId: o ? c.drawingId : Ve(),
        transform: h.transform,
        sheetTransform: h.sheetTransform
      };
      if (o) {
        const { undo: m, redo: p, objects: w } = u.getBatchUpdateOp([f]);
        a.push({
          id: P.id,
          params: {
            unitId: n,
            subUnitId: r,
            type: U.UPDATE,
            op: p,
            objects: w
          }
        }), d.push({
          id: P.id,
          params: {
            unitId: n,
            subUnitId: r,
            type: U.UPDATE,
            op: m,
            objects: w
          }
        });
      } else {
        const { undo: m, redo: p, objects: w } = u.getBatchAddOp([f]);
        a.push({ id: P.id, params: { op: p, unitId: n, subUnitId: r, objects: w, type: U.INSERT } }), d.push({ id: P.id, params: { op: m, unitId: n, subUnitId: r, objects: w, type: U.REMOVE } });
      }
    }), { redos: a, undos: d };
  }
  // eslint-disable-next-line max-lines-per-function
  _generateRangeDrawingsPasteMutations(t, e) {
    var y;
    const {
      unitId: n,
      subUnitId: r,
      pasteType: s,
      pasteRange: o
    } = t, {
      copyRange: a,
      copyType: d
    } = e;
    if (ar.includes(s))
      return { redos: [], undos: [] };
    const u = (y = this._renderManagerService.getRenderById(n)) == null ? void 0 : y.with(X);
    if (!u || !this._copyInfo)
      return { redos: [], undos: [] };
    const { drawings: c } = this._copyInfo;
    if (!a)
      return this._generateSingleDrawingPasteMutations({
        pasteTo: { unitId: n, subUnitId: r, range: $n(o) },
        pasteType: s
      }, d);
    const { ranges: [l, g], mapFunc: h } = li([a, o]), { row: f, col: m } = h(l.startRow, l.startColumn), { row: p, col: w } = h(g.startRow, g.startColumn), S = u.attachRangeWithCoord({
      startRow: f,
      endRow: f,
      startColumn: m,
      endColumn: m
    }), I = u.attachRangeWithCoord({
      startRow: p,
      endRow: p,
      startColumn: w,
      endColumn: w
    });
    if (!S || !I || !this._copyInfo)
      return { redos: [], undos: [] };
    const D = I.startX - S.startX, v = I.startY - S.startY, C = p - f, _ = w - m;
    return this._generateMutations(c, {
      unitId: n,
      subUnitId: r,
      getTransform: (R, E) => {
        var T, M;
        return {
          transform: {
            ...R,
            left: ((T = R == null ? void 0 : R.left) != null ? T : 0) + D,
            top: ((M = R == null ? void 0 : R.top) != null ? M : 0) + v
          },
          sheetTransform: {
            ...E,
            to: {
              ...E.to,
              row: E.to.row + C,
              column: E.to.column + _
            },
            from: {
              ...E.from,
              row: E.from.row + C,
              column: E.from.column + _
            }
          }
        };
      },
      isCut: d === Re.CUT
    });
  }
};
Wt = Qs([
  rt(0, ui),
  rt(1, Q),
  rt(2, oe),
  rt(3, ls),
  rt(4, Y)
], Wt);
var ro = Object.getOwnPropertyDescriptor, io = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? ro(t, e) : t, s = i.length - 1, o; s >= 0; s--)
    (o = i[s]) && (r = o(r) || r);
  return r;
}, it = (i, t) => (e, n) => t(e, n, i);
let Bt = class extends ee {
  constructor(i, t, e, n, r) {
    super(), this._drawingManagerService = i, this._renderManagerService = t, this._permissionService = e, this._univerInstanceService = n, this._userManagerService = r, this._initDrawingVisible(), this._initDrawingEditable(), this._initViewPermissionChange(), this._initEditPermissionChange();
  }
  _initDrawingVisible() {
    const i = this._univerInstanceService.getCurrentTypeOfUnit$($.UNIVER_SHEET), t = this._userManagerService.currentUser$, e = at([i, t]);
    this.disposeWithMe(
      e.pipe(
        me(([n, r]) => n ? n.activeSheet$.pipe(
          er((s) => {
            if (!s) {
              this._drawingManagerService.setDrawingVisible(!1);
              return;
            }
            const o = n.getUnitId(), a = s.getSheetId();
            this._permissionService.composePermission([
              new Vn(o).id,
              new Hn(o, a).id
            ]).every((u) => u.value) ? this._drawingManagerService.setDrawingVisible(!0) : this._handleDrawingVisibilityFalse(n, s);
          })
        ) : (this._drawingManagerService.setDrawingVisible(!1), we))
      ).subscribe()
    );
  }
  _handleDrawingVisibilityFalse(i, t) {
    this._drawingManagerService.setDrawingVisible(!1);
    const e = i.getUnitId(), n = t.getSheetId(), r = this._drawingManagerService.getDrawingData(e, n), s = Object.values(r), o = this._renderManagerService.getRenderById(e), a = o == null ? void 0 : o.scene;
    if (!a)
      return;
    a.getAllObjectsByOrder().forEach((u) => {
      u.classType === $e.IMAGE && s.some((c) => u.oKey.includes(c.drawingId)) && a.removeObject(u);
    });
  }
  _initDrawingEditable() {
    const i = this._univerInstanceService.getCurrentTypeOfUnit$($.UNIVER_SHEET), t = this._userManagerService.currentUser$, e = at([i, t]);
    this.disposeWithMe(
      e.pipe(
        me(([n, r]) => n ? n.activeSheet$.pipe(
          er((s) => {
            if (!s) {
              this._drawingManagerService.setDrawingEditable(!1);
              return;
            }
            const o = n.getUnitId(), a = s.getSheetId();
            this._permissionService.composePermission([
              new gn(o).id,
              new fn(o, a).id
            ]).every((u) => u.value) ? this._drawingManagerService.setDrawingEditable(!0) : this._handleDrawingEditableFalse(n, s);
          })
        ) : (this._drawingManagerService.setDrawingEditable(!1), we))
      ).subscribe()
    );
  }
  _handleDrawingEditableFalse(i, t) {
    this._drawingManagerService.setDrawingEditable(!1);
    const e = i.getUnitId(), n = t.getSheetId(), r = this._drawingManagerService.getDrawingData(e, n), s = Object.values(r), o = this._renderManagerService.getRenderById(e), a = o == null ? void 0 : o.scene;
    if (!a)
      return;
    a.getAllObjectsByOrder().forEach((u) => {
      u.classType === $e.IMAGE && s.some((c) => u.oKey.includes(c.drawingId)) && a.detachTransformerFrom(u);
    });
  }
  _initViewPermissionChange() {
    const i = this._univerInstanceService.getCurrentTypeOfUnit$($.UNIVER_SHEET), t = this._userManagerService.currentUser$;
    this.disposeWithMe(
      at([i, t]).pipe(
        me(([e, n]) => e ? e.activeSheet$.pipe(
          me((r) => {
            if (!r)
              return we;
            const s = e.getUnitId(), o = r.getSheetId(), a = this._renderManagerService.getRenderById(s), d = a == null ? void 0 : a.scene;
            if (!d)
              return we;
            const u = d.getTransformerByCreate();
            return this._permissionService.composePermission$([
              new Vn(s).id,
              new Hn(s, o).id
            ]).pipe(
              pe((l) => l.every((g) => g.value)),
              tr()
            ).pipe(
              pe((l) => ({
                permission: l,
                scene: d,
                transformer: u,
                unitId: s,
                subUnitId: o
              }))
            );
          })
        ) : we)
      ).subscribe({
        next: ({ permission: e, scene: n, transformer: r, unitId: s, subUnitId: o }) => {
          this._drawingManagerService.setDrawingVisible(e);
          const a = n.getAllObjectsByOrder(), d = this._drawingManagerService.getDrawingData(s, o), u = Object.values(d);
          e ? this._drawingManagerService.addNotification(u) : (a.forEach((c) => {
            c.classType === $e.IMAGE && u.some((l) => c.oKey.includes(l.drawingId)) && n.removeObject(c);
          }), r.clearSelectedObjects());
        },
        complete: () => {
          this._drawingManagerService.setDrawingVisible(!0);
          const e = this._univerInstanceService.getCurrentUnitForType($.UNIVER_SHEET), n = e == null ? void 0 : e.getActiveSheet(), r = e == null ? void 0 : e.getUnitId(), s = n == null ? void 0 : n.getSheetId();
          if (!r || !s)
            return;
          const o = this._drawingManagerService.getDrawingData(r, s), a = Object.values(o);
          this._drawingManagerService.addNotification(a);
        }
      })
    );
  }
  _initEditPermissionChange() {
    const i = this._univerInstanceService.getCurrentTypeOfUnit$($.UNIVER_SHEET), t = this._userManagerService.currentUser$;
    this.disposeWithMe(
      at([i, t]).pipe(
        me(([e, n]) => e ? e.activeSheet$.pipe(
          me((r) => {
            if (!r)
              return we;
            const s = e.getUnitId(), o = r.getSheetId(), a = this._renderManagerService.getRenderById(s), d = a == null ? void 0 : a.scene;
            if (!d)
              return we;
            const u = d.getTransformerByCreate();
            return this._permissionService.composePermission$([
              new gn(s).id,
              new fn(s, o).id
            ]).pipe(
              pe((l) => l.every((g) => g.value)),
              tr()
            ).pipe(
              pe((l) => ({
                permission: l,
                scene: d,
                transformer: u,
                unitId: s,
                subUnitId: o
              }))
            );
          })
        ) : we)
      ).subscribe({
        next: ({ permission: e, scene: n, transformer: r, unitId: s, subUnitId: o }) => {
          this._drawingManagerService.setDrawingEditable(e);
          const a = n.getAllObjectsByOrder(), d = this._drawingManagerService.getDrawingData(s, o), u = Object.values(d);
          e ? (a.forEach((c) => {
            c.classType === $e.IMAGE && u.some((l) => c.oKey.includes(l.drawingId)) && n.attachTransformerTo(c);
          }), this._drawingManagerService.addNotification(u)) : (a.forEach((c) => {
            c.classType === $e.IMAGE && u.some((l) => c.oKey.includes(l.drawingId)) && n.detachTransformerFrom(c);
          }), r.clearSelectedObjects());
        },
        complete: () => {
          const e = this._univerInstanceService.getCurrentUnitForType($.UNIVER_SHEET);
          if (!e)
            return;
          const n = e.getUnitId(), r = e.getActiveSheet();
          if (!r)
            return;
          const s = r.getSheetId(), o = this._renderManagerService.getRenderById(n), a = o == null ? void 0 : o.scene;
          if (!a)
            return;
          const d = this._drawingManagerService.getDrawingData(n, s), u = Object.values(d);
          this._drawingManagerService.setDrawingEditable(!0), a.getAllObjectsByOrder().forEach((l) => {
            l.classType === $e.IMAGE && u.some((g) => l.oKey.includes(g.drawingId)) && a.detachTransformerFrom(l);
          });
        }
      })
    );
  }
};
Bt = io([
  it(0, oe),
  it(1, Q),
  it(2, Ii),
  it(3, de),
  it(4, A(Ci))
], Bt);
var so = Object.getOwnPropertyDescriptor, oo = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? so(t, e) : t, s = i.length - 1, o; s >= 0; s--)
    (o = i[s]) && (r = o(r) || r);
  return r;
}, be = (i, t) => (e, n) => t(e, n, i);
const ao = "univer-sheet-float-dom-";
function Hr(i, t, e, n, r, s = !1) {
  const { scaleX: o, scaleY: a } = t.getAncestorScale(), d = t.getViewport(cr.VIEW_MAIN), u = n.getFreeze(), { startColumn: c, startRow: l, xSplit: g, ySplit: h } = u, f = {
    left: !0,
    // left means the left of pic is in a viewMainLeft
    top: !0
  };
  if (!d)
    return {
      ...i,
      absolute: f
    };
  const { left: m, right: p, top: w, bottom: S } = i;
  let { top: I, left: D, viewportScrollX: v, viewportScrollY: C } = d;
  const { boundsOfViewArea: _, scrollDirectionResponse: y } = r || {}, { rowHeaderWidth: R, columnHeaderHeight: E } = e, T = {
    top: s ? 0 : E,
    left: s ? 0 : R
  };
  _ && (Ye.isDefine(T.top) && (T.top = _.top), Ye.isDefine(T.left) && (T.left = _.left)), y === "HORIZONTAL" && (C = 0), y === "VERTICAL" && (v = 0);
  let M = 0, b = 0;
  const N = e.rowStartY(l - h) + E, F = e.colStartX(c - g) + R, te = e.rowStartY(l) + E, z = e.colStartX(c) + R;
  if (g === 0)
    f.left = !1, M = (m - v) * o, b = (p - v) * o;
  else {
    const K = m - (F - R), W = p - (F - R);
    p < z ? (M = K * o, b = W * o) : m <= z && p >= z ? (M = K * o, b = Math.max(D, (p - v) * o)) : m > z && (f.left = !1, M = Math.max((m - v) * o, D), b = Math.max((p - v) * o, D));
  }
  let H = 0, G = 0;
  if (h === 0)
    f.top = !1, H = (w - C) * a, G = (S - C) * a;
  else {
    const K = w - (N - E), W = S - (N - E);
    S < te ? (H = K * a, G = W * a) : w <= te && S >= te ? (H = K * a, G = Math.max(I, (S - C) * a)) : w > te && (f.top = !1, H = Math.max((w - C) * a, I), G = Math.max((S - C) * a, I));
  }
  return M = Math.max(M, T.left), H = Math.max(H, T.top), b = Math.max(b, T.left), G = Math.max(G, T.top), {
    left: M,
    right: b,
    top: H,
    bottom: G,
    absolute: f
  };
}
const fe = (i, t, e, n, r) => {
  const { left: s, top: o, width: a, height: d, angle: u } = i, c = {
    left: s,
    right: s + a,
    top: o,
    bottom: o + d
  }, l = Hr(c, t, e, n, r), { scaleX: g, scaleY: h } = t.getAncestorScale();
  return {
    startX: l.left,
    endX: l.right,
    startY: l.top,
    endY: l.bottom,
    rotate: u,
    width: a * g,
    height: d * h,
    absolute: l.absolute
  };
};
let lt = class extends ee {
  constructor(t, e, n, r, s, o, a) {
    super();
    /**
     * for update dom container position when scrolling and zoom
     */
    re(this, "_domLayerInfoMap", /* @__PURE__ */ new Map());
    re(this, "_transformChange$", new on());
    re(this, "transformChange$", this._transformChange$.asObservable());
    re(this, "_add$", new on());
    re(this, "add$", this._add$.asObservable());
    re(this, "_remove$", new on());
    re(this, "remove$", this._remove$.asObservable());
    this._renderManagerService = t, this._univerInstanceService = e, this._commandService = n, this._drawingManagerService = r, this._canvasFloatDomService = s, this._sheetDrawingService = o, this._lifecycleService = a, this._drawingAddListener(), this._featureUpdateListener(), this._deleteListener(), this._bindScrollEvent();
  }
  _bindScrollEvent() {
    this._lifecycleService.lifecycle$.pipe(Ms((t) => t === Di.Rendered), ys(1)).subscribe(() => {
      this._scrollUpdateListener();
    });
  }
  getFloatDomInfo(t) {
    return this._domLayerInfoMap.get(t);
  }
  getFloatDomsBySubUnitId(t, e) {
    return Array.from(this._domLayerInfoMap.values()).filter((n) => n.subUnitId === e && n.unitId === t);
  }
  _getSceneAndTransformerByDrawingSearch(t) {
    if (t == null)
      return;
    const e = this._renderManagerService.getRenderById(t), n = e == null ? void 0 : e.scene;
    if (e == null || n == null)
      return null;
    const r = n.getTransformerByCreate(), s = e.engine.getCanvasElement();
    return { scene: n, transformer: r, renderUnit: e, canvas: s };
  }
  // eslint-disable-next-line max-lines-per-function
  _drawingAddListener() {
    this.disposeWithMe(
      // eslint-disable-next-line max-lines-per-function
      this._drawingManagerService.add$.subscribe((t) => {
        t.forEach((e) => {
          var K;
          const { unitId: n, subUnitId: r, drawingId: s } = e, o = ae(this._univerInstanceService, { unitId: n, subUnitId: r }), a = this._drawingManagerService.getDrawingByParam(e), d = this._univerInstanceService.getUnit(n, $.UNIVER_SHEET);
          if (!d)
            return;
          const u = d.getActiveSheet().getSheetId();
          if (!a || !o)
            return;
          const c = (K = this._renderManagerService.getRenderById(n)) == null ? void 0 : K.with(X).getSkeletonParam(r);
          if (!c)
            return;
          const { transform: l, drawingType: g, data: h } = a;
          if (g !== x.DRAWING_DOM && g !== x.DRAWING_CHART)
            return;
          const f = this._getSceneAndTransformerByDrawingSearch(n);
          if (f == null)
            return;
          const { scene: m, canvas: p } = f;
          if (l == null)
            return !0;
          if (u !== r)
            return;
          const { left: w, top: S, width: I, height: D, angle: v, flipX: C, flipY: _, skewX: y, skewY: R } = l, E = De({ unitId: n, subUnitId: r, drawingId: s }), T = m.getObject(E);
          if (T != null) {
            T.transformByState({ left: w, top: S, width: I, height: D, angle: v, flipX: C, flipY: _, skewX: y, skewY: R });
            return;
          }
          const M = {
            left: w,
            top: S,
            width: I,
            height: D,
            zIndex: this._drawingManagerService.getDrawingOrder(n, r).length - 1
          }, b = g === x.DRAWING_CHART;
          if (M.rotateEnabled = !1, b) {
            const W = h ? h.backgroundColor : "white";
            M.fill = W, h && h.border && (M.stroke = h.border), M.paintFirst = "stroke", M.strokeWidth = 1, M.borderEnabled = !1, M.radius = 8;
          }
          const N = new ke(E, M);
          b && N.setObjectType(An.CHART), m.addObject(N, qt), a.allowTransform !== !1 && m.attachTransformerTo(N);
          const F = new yt(), te = fe(N, f.renderUnit.scene, c.skeleton, o.worksheet), z = new je(te), H = `${ao}${Ve(6)}`, G = {
            dispose: F,
            rect: N,
            position$: z,
            unitId: n,
            subUnitId: r,
            id: s,
            domId: H
          };
          this._canvasFloatDomService.addFloatDom({
            position$: z,
            id: s,
            domId: H,
            componentKey: a.componentKey,
            onPointerDown: (W) => {
              p.dispatchEvent(new PointerEvent(W.type, W));
            },
            onPointerMove: (W) => {
              p.dispatchEvent(new PointerEvent(W.type, W));
            },
            onPointerUp: (W) => {
              p.dispatchEvent(new PointerEvent(W.type, W));
            },
            onWheel: (W) => {
              p.dispatchEvent(new WheelEvent(W.type, W));
            },
            data: h,
            unitId: n
          });
          const J = N.onTransformChange$.subscribeEvent(() => {
            const W = fe(N, f.renderUnit.scene, c.skeleton, o.worksheet);
            z.next(
              W
            );
          });
          F.add(() => {
            this._canvasFloatDomService.removeFloatDom(s);
          }), J && F.add(J), this._domLayerInfoMap.set(s, G);
        });
      })
    ), this.disposeWithMe(
      this._drawingManagerService.remove$.subscribe((t) => {
        t.forEach((e) => {
          var l;
          const { unitId: n, subUnitId: r, drawingId: s } = e, o = De({ unitId: n, subUnitId: r, drawingId: s }), a = this._getSceneAndTransformerByDrawingSearch(n);
          if (a == null)
            return;
          const { transformer: d, scene: u } = a, c = u.getObject(o);
          c != null && c.oKey && (d.clearControlByIds([c == null ? void 0 : c.oKey]), (l = u.getTransformer()) == null || l.clearSelectedObjects());
        });
      })
    );
  }
  _scrollUpdateListener() {
    const t = (e, n) => {
      var d;
      const r = this._getSceneAndTransformerByDrawingSearch(e), s = Array.from(this._domLayerInfoMap.keys()).map((u) => ({ id: u, ...this._domLayerInfoMap.get(u) })).filter((u) => u.subUnitId === n && u.unitId === e).map((u) => u.id), o = ae(this._univerInstanceService, { unitId: e, subUnitId: n }), a = (d = this._renderManagerService.getRenderById(e)) == null ? void 0 : d.with(X).getSkeletonParam(n);
      !r || !o || !a || s.forEach((u) => {
        const c = this._domLayerInfoMap.get(u);
        if (c) {
          const l = fe(c.rect, r.renderUnit.scene, a.skeleton, o.worksheet, c);
          c.position$.next(l);
        }
      });
    };
    this.disposeWithMe(
      this._univerInstanceService.getCurrentTypeOfUnit$($.UNIVER_SHEET).pipe(
        me((e) => e ? e.activeSheet$ : wn(null)),
        pe((e) => {
          if (!e) return null;
          const n = e.getUnitId(), r = this._renderManagerService.getRenderById(n);
          return r ? { render: r, unitId: n, subUnitId: e.getSheetId() } : null;
        }),
        me(
          (e) => e ? bi(e.render.scene.getViewport(cr.VIEW_MAIN).onScrollAfter$).pipe(pe(() => ({ unitId: e.unitId, subUnitId: e.subUnitId }))) : wn(null)
        )
      ).subscribe((e) => {
        if (!e) return;
        const { unitId: n, subUnitId: r } = e;
        t(n, r);
      })
    ), this.disposeWithMe(this._commandService.onCommandExecuted((e) => {
      if (e.id === kn.id) {
        const n = e.params, { unitId: r } = n;
        Array.from(this._domLayerInfoMap.values()).filter((o) => o.unitId === r).map((o) => o.subUnitId).forEach((o) => {
          t(r, o);
        });
      } else if (e.id === Bi.id) {
        const { unitId: n, subUnitId: r } = e.params;
        t(n, r);
      } else if (e.id === ji.id) {
        const { unitId: n, subUnitId: r } = e.params;
        t(n, r);
      }
    }));
  }
  updateFloatDomProps(t, e, n, r) {
    const s = this._domLayerInfoMap.get(n), o = this._getSceneAndTransformerByDrawingSearch(t);
    if (s && o) {
      const { scene: a } = o, d = De({ unitId: t, subUnitId: e, drawingId: n }), u = a.getObject(d);
      u && u instanceof ke && u.setProps(r);
    }
  }
  _getPosition(t, e) {
    var g;
    const { startX: n, endX: r, startY: s, endY: o } = t, a = (g = this._renderManagerService.getRenderById(e)) == null ? void 0 : g.with(Ze);
    if (a == null)
      return;
    const d = a.getCellWithCoordByOffset(n, s);
    if (d == null)
      return;
    const u = {
      column: d.actualColumn,
      columnOffset: n - d.startX,
      row: d.actualRow,
      rowOffset: s - d.startY
    }, c = a.getCellWithCoordByOffset(r, o);
    if (c == null)
      return;
    const l = {
      column: c.actualColumn,
      columnOffset: r - c.startX,
      row: c.actualRow,
      rowOffset: o - c.startY
    };
    return {
      from: u,
      to: l
    };
  }
  _featureUpdateListener() {
    this.disposeWithMe(
      this._drawingManagerService.update$.subscribe((t) => {
        t.forEach((e) => {
          const n = this._drawingManagerService.getDrawingByParam(e);
          if (!n || n.drawingType !== x.DRAWING_DOM && n.drawingType !== x.DRAWING_CHART)
            return;
          const r = {
            ...n.transform
          };
          this._transformChange$.next({ id: e.drawingId, value: r }), this._canvasFloatDomService.updateFloatDom(e.drawingId, {
            ...n
          });
          const s = this._getSceneAndTransformerByDrawingSearch(e.unitId);
          if (s && n.drawingType !== x.DRAWING_CHART) {
            const { scene: o } = s, a = this._domLayerInfoMap.get(e.drawingId);
            a != null && a.rect && (n.allowTransform === !1 ? o.detachTransformerFrom(a.rect) : o.attachTransformerTo(a.rect));
          }
        });
      })
    );
  }
  _deleteListener() {
    this.disposeWithMe(
      this._drawingManagerService.remove$.subscribe((t) => {
        t.forEach((e) => {
          this._removeDom(e.drawingId);
        });
      })
    );
  }
  // CreateFloatDomCommand --> floatDomService.addFloatDomToPosition
  addFloatDomToPosition(t, e) {
    const n = ae(this._univerInstanceService, {
      unitId: t.unitId,
      subUnitId: t.subUnitId
    });
    if (!n)
      throw new Error("cannot find current target!");
    const { unitId: r, subUnitId: s } = n, { initPosition: o, componentKey: a, data: d, allowTransform: u = !0 } = t, c = e != null ? e : Ve(), l = this._getPosition(o, r);
    if (l == null)
      return;
    const g = {
      unitId: r,
      subUnitId: s,
      drawingId: c,
      drawingType: t.type || x.DRAWING_DOM,
      componentKey: a,
      sheetTransform: l,
      transform: {
        left: o.startX,
        top: o.startY,
        width: o.endX - o.startX,
        height: o.endY - o.startY
      },
      data: d,
      allowTransform: u
    };
    return this._commandService.executeCommand(Xt.id, {
      unitId: r,
      drawings: [g]
    }), this._add$.next({ unitId: r, subUnitId: s, id: c }), {
      id: c,
      dispose: () => {
        this._removeDom(c, !0);
      }
    };
  }
  _removeDom(t, e = !1) {
    const n = this._domLayerInfoMap.get(t);
    if (!n)
      return;
    const { unitId: r, subUnitId: s } = n;
    this._domLayerInfoMap.delete(t), n.dispose.dispose();
    const o = this._getSceneAndTransformerByDrawingSearch(r);
    if (o && o.scene.removeObject(n.rect), e) {
      const a = this._drawingManagerService.getDrawingByParam({ unitId: r, subUnitId: s, drawingId: t });
      if (!a)
        return;
      const d = this._sheetDrawingService.getBatchRemoveOp([a]), { redo: u, objects: c } = d;
      this._commandService.syncExecuteCommand(P.id, { unitId: r, subUnitId: s, op: u, objects: c, type: U.REMOVE });
    }
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  addFloatDomToRange(t, e, n, r) {
    var C, _, y;
    const s = ae(this._univerInstanceService, {
      unitId: e.unitId,
      subUnitId: e.subUnitId
    });
    if (!s)
      throw new Error("cannot find current target!");
    const { unitId: o, subUnitId: a } = s, d = this._getSceneAndTransformerByDrawingSearch(o);
    if (!d) return;
    const u = this._renderManagerService.getRenderById(o);
    if (!u) return;
    const c = (C = this._renderManagerService.getRenderById(o)) == null ? void 0 : C.with(X).getWorksheetSkeleton(a);
    if (!c) return;
    const { componentKey: l, data: g, allowTransform: h = !0 } = e, f = r != null ? r : Ve(), { position: m, position$: p } = this._createRangePositionObserver(t, u, c.skeleton);
    if (this._getPosition(m, o) == null)
      return;
    const S = d.scene, { scaleX: I } = S.getAncestorScale(), D = Ut(m, n, I), v = {
      unitId: o,
      subUnitId: a,
      drawingId: f,
      drawingType: e.type || x.DRAWING_DOM,
      componentKey: l,
      transform: {
        left: D.startX,
        top: D.startY,
        width: D.width,
        height: D.height
      },
      data: g,
      allowTransform: h
    };
    {
      const { unitId: R, subUnitId: E, drawingId: T } = v, M = ae(this._univerInstanceService, { unitId: R, subUnitId: E }), b = v, N = this._univerInstanceService.getUnit(R, $.UNIVER_SHEET);
      if (!N)
        return;
      const F = N.getActiveSheet().getSheetId();
      if (!b || !M)
        return;
      const te = (_ = this._renderManagerService.getRenderById(R)) == null ? void 0 : _.with(X);
      if (!te)
        return;
      const z = te.getWorksheetSkeleton(E);
      if (!z)
        return;
      const { transform: H, drawingType: G, data: J } = b;
      if (G !== x.DRAWING_DOM && G !== x.DRAWING_CHART)
        return;
      const K = this._getSceneAndTransformerByDrawingSearch(R);
      if (K == null)
        return;
      const { scene: W, canvas: Oe } = K;
      if (H == null || F !== E)
        return;
      const { left: mt, top: pt, width: wt, height: _t, angle: Zt, flipX: Jt, flipY: St, skewX: vt, skewY: Ue } = H, It = De({ unitId: R, subUnitId: E, drawingId: T }), le = W.getObject(It);
      if (le != null) {
        le.transformByState({ left: mt, top: pt, width: wt, height: _t, angle: Zt, flipX: Jt, flipY: St, skewX: vt, skewY: Ue });
        return;
      }
      const ne = {
        left: mt,
        // from floatDomParam.transform
        top: pt,
        width: wt,
        height: _t,
        zIndex: this._drawingManagerService.getDrawingOrder(R, E).length - 1
      }, Pe = G === x.DRAWING_CHART;
      if (Pe) {
        const k = J ? J.backgroundColor : "white";
        ne.fill = k, ne.rotateEnabled = !1, J && J.border && (ne.stroke = J.border), ne.paintFirst = "stroke", ne.strokeWidth = 1, ne.borderEnabled = !1, ne.radius = 8;
      }
      const ue = new ke(It, ne);
      Pe && ue.setObjectType(An.CHART), W.addObject(ue, qt), b.allowTransform !== !1 && W.attachTransformerTo(ue);
      const he = new yt(), Ct = W.getMainViewport(), { rowHeaderWidth: Ae, columnHeaderHeight: Qe } = z.skeleton, Rt = {
        top: Qe,
        left: Ae,
        bottom: Ct.bottom,
        right: Ct.right
      }, ge = {
        dispose: he,
        rect: ue,
        boundsOfViewArea: Rt,
        domAnchor: n,
        unitId: R,
        subUnitId: E
      }, B = fe(ue, K.renderUnit.scene, z.skeleton, M.worksheet, ge), Ne = new je(B);
      ge.position$ = Ne;
      let et = {
        position$: Ne,
        id: T,
        componentKey: b.componentKey,
        onPointerDown: () => {
        },
        onPointerMove: () => {
        },
        onPointerUp: () => {
        },
        onWheel: (k) => {
          Oe.dispatchEvent(new WheelEvent(k.type, k));
        },
        data: J,
        unitId: R
      };
      e.eventPassThrough && (et = {
        ...et,
        onPointerDown: (k) => {
          Oe.dispatchEvent(new PointerEvent(k.type, k));
        },
        onPointerMove: (k) => {
          Oe.dispatchEvent(new PointerEvent(k.type, k));
        },
        onPointerUp: (k) => {
          Oe.dispatchEvent(new PointerEvent(k.type, k));
        }
      }), this._canvasFloatDomService.addFloatDom(et), this.disposeWithMe(p.subscribe((k) => {
        var Tn, On, Un, Pn;
        const En = Ut({
          startX: k.startX,
          startY: k.startY,
          endX: k.endX,
          endY: k.endY,
          width: (Tn = n.width) != null ? Tn : k.width,
          height: (On = n.height) != null ? On : k.height,
          absolute: {
            left: m.absolute.left,
            top: m.absolute.top
          }
        }, n), Zr = De({ unitId: R, subUnitId: E, drawingId: T }), Jr = new ke(Zr, {
          left: En.startX,
          top: En.startY,
          width: (Un = n.width) != null ? Un : k.width,
          height: (Pn = n.height) != null ? Pn : k.height,
          zIndex: this._drawingManagerService.getDrawingOrder(R, E).length - 1
        }), qr = fe(Jr, K.renderUnit.scene, z.skeleton, M.worksheet, ge);
        Ne.next(qr);
      }));
      const tt = (y = this._renderManagerService.getRenderById(R)) == null ? void 0 : y.with(X);
      tt == null || tt.currentSkeleton$.subscribe((k) => {
        k && z.sheetId !== k.sheetId && this._removeDom(f, !0);
      });
      const Dt = ue.onTransformChange$.subscribeEvent(() => {
        const k = fe(ue, K.renderUnit.scene, z.skeleton, M.worksheet, ge);
        Ne.next(
          k
        );
      });
      he.add(() => {
        this._canvasFloatDomService.removeFloatDom(T);
      }), Dt && he.add(Dt), this._domLayerInfoMap.set(T, ge);
    }
    return {
      id: f,
      dispose: () => {
        this._removeDom(f, !0);
      }
    };
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  addFloatDomToColumnHeader(t, e, n, r) {
    var D, v, C;
    const s = ae(this._univerInstanceService, {
      unitId: e.unitId,
      subUnitId: e.subUnitId
    });
    if (!s)
      throw new Error("cannot find current target!");
    const { unitId: o, subUnitId: a } = s;
    if (!this._getSceneAndTransformerByDrawingSearch(o)) return;
    const u = this._renderManagerService.getRenderById(o);
    if (!u) return;
    const c = (D = this._renderManagerService.getRenderById(o)) == null ? void 0 : D.with(X).getWorksheetSkeleton(a);
    if (!c) return;
    const { componentKey: l, data: g, allowTransform: h = !0 } = e, f = r != null ? r : Ve(), { position: m, position$: p } = this._createRangePositionObserver({
      startRow: 0,
      endRow: 0,
      startColumn: t,
      endColumn: t
    }, u, c.skeleton), w = m;
    if (w.startY = 0, this._getPosition(m, o) == null)
      return;
    const I = {
      unitId: o,
      subUnitId: a,
      drawingId: f,
      drawingType: e.type || x.DRAWING_DOM,
      componentKey: l,
      transform: {
        left: w.startX,
        top: w.startY,
        width: w.width,
        height: w.height
      },
      data: g,
      allowTransform: h
    };
    {
      const { unitId: _, subUnitId: y, drawingId: R } = I, E = ae(this._univerInstanceService, { unitId: _, subUnitId: y }), T = I, M = this._univerInstanceService.getUnit(_, $.UNIVER_SHEET);
      if (!M)
        return;
      const b = M.getActiveSheet().getSheetId();
      if (!T || !E)
        return;
      const N = (v = this._renderManagerService.getRenderById(_)) == null ? void 0 : v.with(X);
      if (!N)
        return;
      const F = N.getWorksheetSkeleton(y);
      if (!F)
        return;
      const { transform: te, data: z } = T, H = this._getSceneAndTransformerByDrawingSearch(_);
      if (H == null)
        return;
      const { scene: G, canvas: J } = H;
      if (te == null || b !== y)
        return;
      const { left: K, top: W, width: Oe, height: mt, angle: pt, flipX: wt, flipY: _t, skewX: Zt, skewY: Jt } = te, St = De({ unitId: _, subUnitId: y, drawingId: R }), vt = G.getObject(St);
      if (vt != null) {
        vt.transformByState({ left: K, top: W, width: Oe, height: mt, angle: pt, flipX: wt, flipY: _t, skewX: Zt, skewY: Jt });
        return;
      }
      const Ue = Ut({
        startX: w.startX,
        startY: 0,
        endX: m.endX,
        endY: m.endY,
        width: n.width,
        height: n.height,
        absolute: {
          left: m.absolute.left,
          top: m.absolute.top
        }
      }, n), It = {
        left: Ue.startX,
        top: Ue.startY,
        width: Ue.width,
        height: Ue.height,
        zIndex: this._drawingManagerService.getDrawingOrder(_, y).length - 1
      }, le = new ke(St, It);
      G.addObject(le, qt), T.allowTransform !== !1 && G.attachTransformerTo(le);
      const ne = new yt(), Pe = G.getMainViewport(), ue = {
        top: 0,
        //viewMain.top,
        left: Pe.left,
        bottom: Pe.bottom,
        right: Pe.right
      }, he = {
        dispose: ne,
        rect: le,
        // position$,
        unitId: _,
        subUnitId: y,
        boundsOfViewArea: ue,
        domAnchor: n,
        scrollDirectionResponse: "HORIZONTAL"
        /* HORIZONTAL */
      }, Ct = fe(le, H.renderUnit.scene, F.skeleton, E.worksheet, he), Ae = new je(Ct);
      he.position$ = Ae;
      let Qe = {
        position$: Ae,
        id: R,
        componentKey: T.componentKey,
        onPointerDown: () => {
        },
        onPointerMove: () => {
        },
        onPointerUp: () => {
        },
        onWheel: (B) => {
          J.dispatchEvent(new WheelEvent(B.type, B));
        },
        data: z,
        unitId: _
      };
      e.eventPassThrough && (Qe = {
        ...Qe,
        onPointerDown: (B) => {
          J.dispatchEvent(new PointerEvent(B.type, B));
        },
        onPointerMove: (B) => {
          J.dispatchEvent(new PointerEvent(B.type, B));
        },
        onPointerUp: (B) => {
          J.dispatchEvent(new PointerEvent(B.type, B));
        }
      }), this._canvasFloatDomService.addFloatDom(Qe);
      const Rt = le.onTransformChange$.subscribeEvent(() => {
        const B = fe(le, H.renderUnit.scene, F.skeleton, E.worksheet, he);
        Ae.next(
          B
        );
      });
      this.disposeWithMe(p.subscribe((B) => {
        const Ne = Ut({
          startX: B.startX,
          startY: 0,
          endX: B.endX,
          endY: B.endY,
          width: n.width,
          height: n.height,
          absolute: {
            left: m.absolute.left,
            top: m.absolute.top
          }
        }, n), et = De({ unitId: _, subUnitId: y, drawingId: R }), tt = new ke(et, {
          left: Ne.startX,
          top: 0,
          width: n.width,
          height: n.height,
          zIndex: this._drawingManagerService.getDrawingOrder(_, y).length - 1
        }), Dt = fe(tt, H.renderUnit.scene, F.skeleton, E.worksheet, he);
        Ae.next(Dt);
      }));
      const ge = (C = this._renderManagerService.getRenderById(_)) == null ? void 0 : C.with(X);
      ge == null || ge.currentSkeleton$.subscribe((B) => {
        B && c.sheetId !== B.sheetId && this._removeDom(f, !0);
      }), ne.add(() => {
        this._canvasFloatDomService.removeFloatDom(R);
      }), Rt && ne.add(Rt), this._domLayerInfoMap.set(R, he);
    }
    return {
      id: f,
      dispose: () => {
        this._removeDom(f, !0);
      }
    };
  }
  /**
   * Unlike _createCellPositionObserver, this accept a range not a single cell.
   *
   * @param initialRow
   * @param initialCol
   * @param currentRender
   * @param skeleton
   * @param activeViewport
   * @returns position of cell to canvas.
   */
  // eslint-disable-next-line max-lines-per-function
  _createRangePositionObserver(t, e, n) {
    let { startRow: r, startColumn: s } = t;
    const o = st(r, s, n), a = new je(o), d = st(t.endRow, t.endColumn, n), u = new je(d), c = () => {
      const p = st(r, s, n), w = st(t.endRow, t.endColumn, n);
      a.next(p), u.next(w);
    }, l = new yt();
    l.add(e.engine.clientRect$.subscribe(() => c())), l.add(this._commandService.onCommandExecuted((p) => {
      if (p.id === Fi.id && p.params.rowsAutoHeightInfo.findIndex((S) => S.row === r) > -1) {
        c();
        return;
      }
      (Li.indexOf(p.id) > -1 || p.id === hi.id || p.id === kn.id) && c();
    }));
    const g = (p, w) => {
      r = p, s = w, c();
    }, h = () => ({
      rotate: 0,
      width: d.right - o.left,
      height: d.bottom - o.top,
      absolute: {
        left: !0,
        top: !0
      },
      startX: o.left,
      startY: o.top,
      endX: d.right,
      endY: d.bottom
    }), f = a.pipe(
      pe((p) => {
        const w = st(t.endRow, t.endColumn, n);
        return {
          rotate: 0,
          width: w.right - p.left,
          height: w.bottom - p.top,
          absolute: {
            left: !0,
            top: !0
          },
          startX: p.left,
          startY: p.top,
          endX: w.right,
          endY: w.bottom
        };
      })
    ), m = h();
    return {
      position$: f,
      position: m,
      updateRowCol: g,
      topLeftPos$: a,
      rightBottomPos$: u,
      disposable: l
    };
  }
};
lt = oo([
  be(0, A(Q)),
  be(1, de),
  be(2, A(Y)),
  be(3, oe),
  be(4, A(us)),
  be(5, se),
  be(6, A(Ri))
], lt);
function st(i, t, e) {
  const n = e.getCellWithCoordByIndex(i, t), r = n.isMergedMainCell ? n.mergeInfo : n;
  return {
    left: r.startX,
    right: r.endX,
    top: r.startY,
    bottom: r.endY
  };
}
function Ut(i, t, e) {
  var u, c;
  e = e != null ? e : 1;
  const n = i.endX - i.startX, r = i.endY - i.startY, s = (u = t == null ? void 0 : t.width) != null ? u : n, o = (c = t == null ? void 0 : t.height) != null ? c : r;
  let a = 0, d = 0;
  if (t) {
    if (t.horizonOffsetAlign === "right") {
      const l = Pt(t.marginX, n * e);
      a = i.endX - l - s;
    } else
      a = i.startX + Pt(t.marginX, n);
    if (t.verticalOffsetAlign === "bottom") {
      const l = Pt(t.marginY, r * e);
      d = i.endY - l - o;
    } else
      d = i.startY + Pt(t.marginY, r);
  }
  return {
    rotate: 0,
    startX: a,
    startY: d,
    endX: i.endX,
    endY: i.endY,
    width: s,
    height: o,
    absolute: {
      left: i.absolute.left,
      top: i.absolute.top
    }
  };
}
function Pt(i, t) {
  if (i === void 0) return 0;
  if (typeof i == "number") return i;
  const e = Number.parseFloat(i);
  return t * e / 100;
}
const co = (i) => {
  const { floatDomInfos: t, scene: e, skeleton: n, worksheet: r } = i, s = Fe(() => t.map((o) => {
    const { width: a, height: d, angle: u, left: c, top: l } = o.transform, g = Hr(
      {
        left: c != null ? c : 0,
        right: (c != null ? c : 0) + (a != null ? a : 0),
        top: l != null ? l : 0,
        bottom: (l != null ? l : 0) + (d != null ? d : 0)
      },
      e,
      n,
      r,
      void 0,
      !0
    ), { scaleX: h, scaleY: f } = e.getAncestorScale(), m = {
      startX: g.left,
      endX: g.right,
      startY: g.top,
      endY: g.bottom,
      rotate: u,
      width: a * h,
      height: d * f,
      absolute: g.absolute
    }, p = {
      position$: new je(m),
      position: m,
      id: o.drawingId,
      componentKey: o.componentKey,
      onPointerMove: () => {
      },
      onPointerDown: () => {
      },
      onPointerUp: () => {
      },
      onWheel: () => {
      },
      unitId: o.unitId,
      data: o.data
    };
    return [o.drawingId, p];
  }), [t, e, n, r]);
  return /* @__PURE__ */ L("div", { style: { position: "absolute", top: 0, left: 0 }, children: s.map(([o, a]) => /* @__PURE__ */ L(hs, { layer: a, id: o, position: a.position }, o)) });
};
var lo = Object.getOwnPropertyDescriptor, uo = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? lo(t, e) : t, s = i.length - 1, o; s >= 0; s--)
    (o = i[s]) && (r = o(r) || r);
  return r;
}, Me = (i, t) => (e, n) => t(e, n, i);
let jt = class extends ee {
  constructor(i, t, e, n, r, s, o) {
    super(), this._sheetPrintInterceptorService = i, this._drawingRenderService = t, this._drawingManagerService = e, this._renderManagerService = n, this._canvasFloatDomManagerService = r, this._componetManager = s, this._injector = o, this._initPrinting(), this._initPrintingDom();
  }
  _initPrinting() {
    this.disposeWithMe(
      this._sheetPrintInterceptorService.interceptor.intercept(
        this._sheetPrintInterceptorService.interceptor.getInterceptPoints().PRINTING_COMPONENT_COLLECT,
        {
          handler: (i, t, e) => {
            const { unitId: n, scene: r, subUnitId: s } = t, o = this._drawingManagerService.getDrawingDataForUnit(n), a = o == null ? void 0 : o[s];
            return a && a.order.forEach((d) => {
              const u = a.data[d];
              u.drawingType !== x.DRAWING_CHART && u.drawingType !== x.DRAWING_DOM && this._drawingRenderService.renderDrawing(u, r);
            }), e();
          }
        }
      )
    ), this.disposeWithMe(
      this._sheetPrintInterceptorService.interceptor.intercept(
        this._sheetPrintInterceptorService.interceptor.getInterceptPoints().PRINTING_RANGE,
        {
          handler: (i, t, e) => {
            const { unitId: n, subUnitId: r } = t, s = this._renderManagerService.getRenderById(n);
            if (!s)
              return e(i);
            const o = s.with(X).getSkeletonParam(r);
            if (!o)
              return e(i);
            const a = this._drawingManagerService.getDrawingDataForUnit(n), d = a == null ? void 0 : a[t.subUnitId];
            if (!d)
              return e(i);
            const { scaleX: u, scaleY: c } = s.scene, l = i ? { ...i } : { startColumn: 0, endColumn: 0, endRow: 0, startRow: 0 }, g = d.order.map((h) => d.data[h]);
            return g.length ? (g.forEach((h) => {
              if (!h.groupId && h.transform && Ye.isDefine(h.transform.left) && Ye.isDefine(h.transform.top) && Ye.isDefine(h.transform.width) && Ye.isDefine(h.transform.height)) {
                const f = o.skeleton.getCellIndexByOffset(h.transform.left, h.transform.top, u, c, { x: 0, y: 0 }), m = o.skeleton.getCellIndexByOffset(h.transform.left + h.transform.width, h.transform.top + h.transform.height, u, c, { x: 0, y: 0 });
                f.column < l.startColumn && (l.startColumn = f.column), f.row < l.startRow && (l.startRow = f.row), l.endRow < m.row && (l.endRow = m.row), l.endColumn < m.column && (l.endColumn = m.column);
              }
            }), e(l)) : e(i);
          }
        }
      )
    );
  }
  _initPrintingDom() {
    this.disposeWithMe(
      this._sheetPrintInterceptorService.interceptor.intercept(
        this._sheetPrintInterceptorService.interceptor.getInterceptPoints().PRINTING_DOM_COLLECT,
        {
          handler: (i, t, e) => {
            const { unitId: n, subUnitId: r } = t, s = this._drawingManagerService.getDrawingDataForUnit(n), o = s == null ? void 0 : s[r];
            if (o) {
              const a = o.order.map((u) => {
                const c = o.data[u];
                if (c.drawingType === x.DRAWING_CHART)
                  return {
                    ...c,
                    componentKey: this._componetManager.get(Mi)
                  };
                if (c.drawingType === x.DRAWING_DOM) {
                  const l = this._sheetPrintInterceptorService.getPrintComponent(c.componentKey);
                  return {
                    ...c,
                    componentKey: this._componetManager.get(l || c.componentKey)
                  };
                }
                return null;
              }).filter(Boolean), d = gs(co, this._injector);
              return Ji(
                /* @__PURE__ */ L(d, { floatDomInfos: a, scene: t.scene, skeleton: t.skeleton, worksheet: t.worksheet }),
                t.root
              ), i == null || i.add(() => {
                qi(t.root);
              }), e(i);
            }
          }
        }
      )
    );
  }
};
jt = uo([
  Me(0, A(gi)),
  Me(1, A(Pr)),
  Me(2, oe),
  Me(3, Q),
  Me(4, A(lt)),
  Me(5, A(Ur)),
  Me(6, A(qe))
], jt);
var ho = Object.getOwnPropertyDescriptor, go = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? ho(t, e) : t, s = i.length - 1, o; s >= 0; s--)
    (o = i[s]) && (r = o(r) || r);
  return r;
}, _e = (i, t) => (e, n) => t(e, n, i);
const fo = [
  gr.id,
  fr.id,
  mr.id,
  pr.id,
  wr.id,
  _r.id,
  Sr.id,
  vr.id,
  mn.id,
  pn.id,
  Ir.id,
  Cr.id,
  Rr.id,
  Dr.id,
  br.id,
  Mr.id,
  yr.id,
  Er.id,
  Tr.id
], mo = [
  Vi.id,
  Hi.id,
  Yi.id,
  Gi.id,
  Xi.id,
  zi.id
];
let Rn = class extends ee {
  constructor(i, t, e, n, r, s, o, a, d) {
    super(), this._context = i, this._renderManagerService = t, this._commandService = e, this._selectionRenderService = n, this._skeletonManagerService = r, this._sheetInterceptorService = s, this._sheetDrawingService = o, this._drawingManagerService = a, this._univerInstanceService = d, this._sheetInterceptorListener(), this._commandListener(), this._sheetRefreshListener();
  }
  _sheetInterceptorListener() {
    this.disposeWithMe(
      this._sheetInterceptorService.interceptAfterCommand({
        /* eslint-disable-next-line complexity */
        getMutations: (i) => {
          if (!fo.includes(i.id))
            return { redos: [], undos: [] };
          if (i.params == null)
            return { redos: [], undos: [] };
          const t = i.id;
          if (t === gr.id)
            return this._moveRowInterceptor(i.params, "insert");
          if ([yr.id, Er.id, Tr.id].includes(t))
            return this._moveRangeInterceptor(i.params);
          if (t === fr.id)
            return this._moveColInterceptor(i.params, "insert");
          if (t === mr.id)
            return this._moveRowInterceptor(i.params, "remove");
          if (t === pr.id)
            return this._moveColInterceptor(i.params, "remove");
          if (t === wr.id) {
            const { range: e } = i.params;
            return this._getRangeMoveUndo(
              e,
              0
              /* deleteLeft */
            );
          } else if (t === _r.id) {
            const { range: e } = i.params;
            return this._getRangeMoveUndo(
              e,
              1
              /* deleteUp */
            );
          } else if (t === Sr.id) {
            const { range: e } = i.params;
            return this._getRangeMoveUndo(
              e,
              2
              /* insertDown */
            );
          } else if (t === vr.id) {
            const { range: e } = i.params;
            return this._getRangeMoveUndo(
              e,
              3
              /* insertRight */
            );
          } else if (t === Rr.id || t === Dr.id) {
            const e = i.params, { unitId: n, subUnitId: r, ranges: s } = e;
            return this._getDrawingUndoForRowVisible(n, r, s);
          } else if (t === br.id || t === Mr.id) {
            const e = i.params, { unitId: n, subUnitId: r, ranges: s } = e;
            return this._getDrawingUndoForColVisible(n, r, s);
          } else if (t === mn.id || t === pn.id || t === Ir.id || t === Cr.id) {
            const e = i.params, { unitId: n, subUnitId: r, ranges: s } = e, o = t === mn.id || t === pn.id;
            return this._getDrawingUndoForRowAndColSize(n, r, s, o);
          }
          return { redos: [], undos: [] };
        }
      })
    );
  }
  _getRangeMoveUndo(i, t) {
    const e = ae(this._univerInstanceService);
    if (e == null)
      return { redos: [], undos: [] };
    const n = e.unitId, r = e.subUnitId, s = [], o = [], a = this._sheetDrawingService.getDrawingData(n, r), d = [], u = [];
    if (Object.keys(a).forEach((c) => {
      const l = a[c], { updateDrawings: g, deleteDrawings: h } = this._getUpdateOrDeleteDrawings(i, t, l);
      d.push(...g), u.push(...h);
    }), d.length === 0 && u.length === 0)
      return { redos: [], undos: [] };
    if (d.length > 0) {
      const c = this._sheetDrawingService.getBatchUpdateOp(d), { undo: l, redo: g, objects: h } = c;
      s.push({ id: P.id, params: { unitId: n, subUnitId: r, op: g, objects: h, type: U.UPDATE } }), o.push({ id: P.id, params: { unitId: n, subUnitId: r, op: l, objects: h, type: U.UPDATE } });
    }
    if (u.length > 0) {
      const c = this._sheetDrawingService.getBatchRemoveOp(u), l = c.undo, g = c.redo, h = c.objects;
      s.push({ id: P.id, params: { unitId: n, subUnitId: r, op: g, objects: h, type: U.REMOVE } }), o.push({ id: P.id, params: { unitId: n, subUnitId: r, op: l, objects: h, type: U.INSERT } });
    }
    return s.push({ id: V.id, params: [n] }), o.push({ id: V.id, params: [n] }), {
      redos: s,
      undos: o
    };
  }
  _getUpdateOrDeleteDrawings(i, t, e) {
    const n = [], r = [], { sheetTransform: s, anchorType: o = O.Position, transform: a, unitId: d, subUnitId: u, drawingId: c } = e, { from: l, to: g } = s, { row: h, column: f } = l, { row: m, column: p } = g;
    if (s == null || a == null)
      return {
        updateDrawings: n,
        deleteDrawings: r
      };
    const { startRow: w, endRow: S, startColumn: I, endColumn: D } = i;
    let v = null, C = null;
    if (t === 0 && h >= w && m <= S)
      if (f >= I && p <= D)
        r.push({ unitId: d, subUnitId: u, drawingId: c });
      else {
        const _ = this._shrinkCol(s, a, I, D, o);
        v = _ == null ? void 0 : _.newSheetTransform, C = _ == null ? void 0 : _.newTransform;
      }
    else if (t === 1 && f >= I && p <= D)
      if (h >= w && m <= S)
        r.push({ unitId: d, subUnitId: u, drawingId: c });
      else {
        const _ = this._shrinkRow(s, a, w, S, o);
        v = _ == null ? void 0 : _.newSheetTransform, C = _ == null ? void 0 : _.newTransform;
      }
    else if (t === 2) {
      const _ = this._expandRow(s, a, w, S, o);
      v = _ == null ? void 0 : _.newSheetTransform, C = _ == null ? void 0 : _.newTransform;
    } else if (t === 3) {
      const _ = this._expandCol(s, a, I, D, o);
      v = _ == null ? void 0 : _.newSheetTransform, C = _ == null ? void 0 : _.newTransform;
    }
    if (v != null && C != null) {
      const _ = Z(v, this._selectionRenderService, this._skeletonManagerService);
      n.push({ ...e, sheetTransform: v, transform: _ });
    }
    return { updateDrawings: n, deleteDrawings: r };
  }
  _remainDrawingSize(i, t, e) {
    const n = j({ ...i }, this._selectionRenderService);
    n != null && t.push({
      ...e,
      sheetTransform: n
    });
  }
  // eslint-disable-next-line max-lines-per-function
  _getDrawingUndoForColVisible(i, t, e) {
    const n = this._drawingManagerService.getDrawingData(i, t), r = [], s = [];
    if (Object.keys(n).forEach((c) => {
      const l = n[c], { sheetTransform: g, transform: h, anchorType: f = O.Position } = l;
      if (f === O.None)
        this._remainDrawingSize(h, r, l);
      else {
        const { from: m, to: p } = g, { row: w, column: S } = m, { row: I, column: D } = p;
        for (let v = 0; v < e.length; v++) {
          const C = e[v], { startRow: _, endRow: y, startColumn: R, endColumn: E } = C;
          if (D < R)
            continue;
          if (f === O.Position) {
            let b = null, N = null;
            if (S >= R && S <= E) {
              const F = this._skeletonManagerService.attachRangeWithCoord({ startColumn: S, endColumn: E, startRow: m.row, endRow: p.row });
              if (F == null)
                return;
              N = { ...h, left: F.startX };
            }
            if (N != null && (b = j(N, this._selectionRenderService), b != null && N != null)) {
              r.push({ ...l, sheetTransform: b, transform: N });
              break;
            }
            this._remainDrawingSize(h, r, l);
            continue;
          }
          if (S >= R && D <= E)
            continue;
          let T = null, M = null;
          if (S >= R && S <= E) {
            const b = this._skeletonManagerService.attachRangeWithCoord({ startColumn: S, endColumn: E, startRow: m.row, endRow: p.row });
            if (b == null)
              return;
            M = {
              ...h,
              left: (b == null ? void 0 : b.startX) || 0,
              width: ((h == null ? void 0 : h.width) || 0) - b.endX + b.startX
            };
          } else if (D >= R && D <= E) {
            const b = this._skeletonManagerService.attachRangeWithCoord({ startColumn: R, endColumn: D, startRow: m.row, endRow: p.row });
            if (b == null)
              return;
            M = {
              ...h,
              left: b.startX - ((h == null ? void 0 : h.width) || 0)
            };
          } else {
            const b = this._skeletonManagerService.attachRangeWithCoord({ startColumn: R, endColumn: E, startRow: m.row, endRow: p.row });
            if (b == null)
              return;
            if (M = {
              ...h,
              width: ((h == null ? void 0 : h.width) || 0) - b.endX + b.startX
            }, T = j(M, this._selectionRenderService), T != null && M != null) {
              s.push({ ...l, sheetTransform: T, transform: M });
              break;
            }
          }
          if (M != null && (T = j(M, this._selectionRenderService)), M != null && T != null) {
            r.push({ ...l, sheetTransform: T, transform: M });
            break;
          } else
            this._remainDrawingSize(h, r, l);
        }
      }
    }), r.length === 0 && s.length === 0)
      return { redos: [], undos: [] };
    const { redos: o, undos: a } = this._createUndoAndRedoMutation(i, t, r), d = [], u = [];
    if (s.length > 0) {
      const { redos: c, undos: l } = this._createUndoAndRedoMutation(i, t, s);
      d.push(...c), u.push(...l);
    }
    return {
      redos: o,
      undos: a,
      preRedos: d,
      preUndos: u
    };
  }
  _createUndoAndRedoMutation(i, t, e) {
    const n = this._sheetDrawingService.getBatchUpdateOp(e), { undo: r, redo: s, objects: o } = n, a = [
      { id: P.id, params: { unitId: i, subUnitId: t, op: s, objects: o, type: U.UPDATE } },
      { id: V.id, params: [i] }
    ], d = [
      { id: P.id, params: { unitId: i, subUnitId: t, op: r, objects: o, type: U.UPDATE } },
      { id: V.id, params: [i] }
    ];
    return {
      redos: a,
      undos: d
    };
  }
  // eslint-disable-next-line max-lines-per-function
  _getDrawingUndoForRowVisible(i, t, e) {
    const n = this._drawingManagerService.getDrawingData(i, t), r = [], s = [];
    if (Object.keys(n).forEach((c) => {
      const l = n[c], { sheetTransform: g, transform: h, anchorType: f = O.Position } = l;
      if (f === O.None)
        this._remainDrawingSize(h, r, l);
      else {
        const { from: m, to: p } = g, { row: w, column: S } = m, { row: I, column: D } = p;
        for (let v = 0; v < e.length; v++) {
          const C = e[v], { startRow: _, endRow: y, startColumn: R, endColumn: E } = C;
          if (I < _)
            continue;
          if (f === O.Position) {
            let b = null, N = null;
            if (w >= _ && w <= y) {
              const F = this._skeletonManagerService.attachRangeWithCoord({ startColumn: m.column, endColumn: p.column, startRow: w, endRow: y });
              if (F == null)
                return;
              N = { ...h, top: F.startY };
            }
            if (N != null && (b = j(N, this._selectionRenderService), b != null && N != null)) {
              r.push({ ...l, sheetTransform: b, transform: N });
              break;
            }
            this._remainDrawingSize(h, r, l);
            continue;
          }
          if (w >= _ && I <= y)
            continue;
          let T = null, M = null;
          if (w >= _ && w <= y) {
            const b = this._skeletonManagerService.attachRangeWithCoord({ startColumn: m.column, endColumn: p.column, startRow: w, endRow: y });
            if (b == null)
              return;
            M = {
              ...h,
              top: (b == null ? void 0 : b.startY) || 0,
              height: ((h == null ? void 0 : h.height) || 0) - b.endY + b.startY
            };
          } else if (I >= _ && I <= y) {
            const b = this._skeletonManagerService.attachRangeWithCoord({ startColumn: m.column, endColumn: p.column, startRow: _, endRow: I });
            if (b == null)
              return;
            M = {
              ...h,
              top: b.startY - ((h == null ? void 0 : h.height) || 0)
            };
          } else {
            const b = this._skeletonManagerService.attachRangeWithCoord({ startColumn: m.column, endColumn: p.column, startRow: _, endRow: y });
            if (b == null)
              return;
            if (M = {
              ...h,
              height: ((h == null ? void 0 : h.height) || 0) - b.endY + b.startY
            }, T = j(M, this._selectionRenderService), T != null && M != null) {
              s.push({ ...l, sheetTransform: T, transform: M });
              break;
            }
          }
          if (M != null && (T = j(M, this._selectionRenderService)), M != null && T != null) {
            r.push({ ...l, sheetTransform: T, transform: M });
            break;
          } else
            this._remainDrawingSize(h, r, l);
        }
      }
    }), r.length === 0 && s.length === 0)
      return { redos: [], undos: [] };
    const { redos: o, undos: a } = this._createUndoAndRedoMutation(i, t, r), d = [], u = [];
    if (s.length > 0) {
      const { redos: c, undos: l } = this._createUndoAndRedoMutation(i, t, s);
      d.push(...c), u.push(...l);
    }
    return {
      redos: o,
      undos: a,
      preRedos: d,
      preUndos: u
    };
  }
  _getDrawingUndoForRowAndColSize(i, t, e, n) {
    const r = this._drawingManagerService.getDrawingData(i, t), s = [];
    return Object.keys(r).forEach((o) => {
      const a = r[o], { sheetTransform: d, transform: u, anchorType: c = O.Position } = a;
      if (c === O.None)
        this._remainDrawingSize(u, s, a);
      else {
        const { from: l, to: g } = d, { row: h, column: f } = l, { row: m, column: p } = g;
        for (let w = 0; w < e.length; w++) {
          const S = e[w], { startRow: I, endRow: D, startColumn: v, endColumn: C } = S;
          if (m < I || p < v)
            continue;
          if (c === O.Position && (h <= I && m >= D || f <= v && p >= C)) {
            this._remainDrawingSize(u, s, a);
            continue;
          }
          const _ = Z({ ...d }, this._selectionRenderService, this._skeletonManagerService);
          if (_ != null) {
            s.push({
              ...a,
              transform: _
            });
            break;
          }
        }
      }
    }), s.length === 0 ? { redos: [], undos: [] } : this._createUndoAndRedoMutation(i, t, s);
  }
  _getUnitIdAndSubUnitId(i, t) {
    let e, n;
    if (t === "insert")
      e = i.unitId, n = i.subUnitId;
    else {
      const r = ae(this._univerInstanceService);
      if (r == null)
        return;
      e = r.unitId, n = r.subUnitId;
    }
    return { unitId: e, subUnitId: n };
  }
  _moveRangeInterceptor(i) {
    var I, D;
    const { toRange: t, fromRange: e } = i, n = ae(this._univerInstanceService);
    if (!n)
      return { redos: [], undos: [] };
    const { unitId: r, subUnitId: s } = n, o = (D = (I = this._renderManagerService.getRenderById(r)) == null ? void 0 : I.with(X)) == null ? void 0 : D.getCurrentSkeleton();
    if (!o)
      return { redos: [], undos: [] };
    const a = dr(o, e);
    if (!a)
      return { redos: [], undos: [] };
    const { startX: d, endX: u, startY: c, endY: l } = a, g = this._sheetDrawingService.getDrawingData(r, s), h = [];
    Object.keys(g).forEach((v) => {
      const C = g[v];
      if (C.anchorType !== O.Both)
        return;
      const { transform: _ } = C;
      if (!_)
        return;
      const { left: y = 0, top: R = 0, width: E = 0, height: T = 0 } = _, { drawingStartX: M, drawingEndX: b, drawingStartY: N, drawingEndY: F } = {
        drawingStartX: y,
        drawingEndX: y + E,
        drawingStartY: R,
        drawingEndY: R + T
      };
      d <= M && b <= u && c <= N && F <= l && h.push(C);
    });
    const f = [], m = [], p = t.startRow - e.startRow, w = t.startColumn - e.startColumn, S = h.map((v) => {
      const C = v.sheetTransform, _ = {
        to: { ...C.to, row: C.to.row + p, column: C.to.column + w },
        from: { ...C.from, row: C.from.row + p, column: C.from.column + w }
      }, y = Z(_, this._selectionRenderService, this._skeletonManagerService);
      return {
        unitId: r,
        subUnitId: s,
        drawingId: v.drawingId,
        transform: y,
        sheetTransform: _
      };
    });
    if (S.length) {
      const v = this._sheetDrawingService.getBatchUpdateOp(S), { undo: C, redo: _, objects: y } = v;
      f.push({ id: P.id, params: { unitId: r, subUnitId: s, op: _, objects: y, type: U.UPDATE } }), m.push({ id: P.id, params: { unitId: r, subUnitId: s, op: C, objects: y, type: U.UPDATE } });
    }
    return { redos: f, undos: m };
  }
  _moveRowInterceptor(i, t) {
    const e = this._getUnitIdAndSubUnitId(i, t);
    if (e == null)
      return { redos: [], undos: [] };
    const { unitId: n, subUnitId: r } = e, { range: s } = i, o = s.startRow, a = s.endRow, d = [], u = [], c = this._sheetDrawingService.getDrawingData(n, r), l = [], g = [];
    if (Object.keys(c).forEach((h) => {
      const f = c[h], { sheetTransform: m, transform: p, anchorType: w = O.Position } = f;
      if (m == null || p == null)
        return;
      let S, I;
      if (t === "insert") {
        const v = this._expandRow(m, p, o, a, w);
        S = v == null ? void 0 : v.newSheetTransform, I = v == null ? void 0 : v.newTransform;
      } else {
        const { from: v, to: C } = m, { row: _ } = v, { row: y } = C;
        if (w === O.Both && _ >= o && y <= a)
          g.push({ unitId: n, subUnitId: r, drawingId: h });
        else {
          const R = this._shrinkRow(m, p, o, a, w);
          S = R == null ? void 0 : R.newSheetTransform, I = R == null ? void 0 : R.newTransform;
        }
      }
      if (!S || !I)
        return;
      const D = { unitId: n, subUnitId: r, drawingId: h, transform: I, sheetTransform: S };
      l.push(D);
    }), l.length === 0 && g.length === 0)
      return { redos: [], undos: [] };
    if (l.length > 0) {
      const h = this._sheetDrawingService.getBatchUpdateOp(l), { undo: f, redo: m, objects: p } = h;
      d.push({ id: P.id, params: { unitId: n, subUnitId: r, op: m, objects: p, type: U.UPDATE } }), u.push({ id: P.id, params: { unitId: n, subUnitId: r, op: f, objects: p, type: U.UPDATE } });
    }
    if (g.length > 0) {
      const h = this._sheetDrawingService.getBatchRemoveOp(g), f = h.undo, m = h.redo, p = h.objects;
      d.push({ id: P.id, params: { unitId: n, subUnitId: r, op: m, objects: p, type: U.REMOVE } }), u.push({ id: P.id, params: { unitId: n, subUnitId: r, op: f, objects: p, type: U.INSERT } });
    }
    return d.push({ id: V.id, params: [n] }), u.push({ id: V.id, params: [n] }), {
      redos: d,
      undos: u
    };
  }
  _moveColInterceptor(i, t) {
    const e = this._getUnitIdAndSubUnitId(i, t);
    if (e == null)
      return { redos: [], undos: [] };
    const { unitId: n, subUnitId: r } = e, { range: s } = i, o = s.startColumn, a = s.endColumn, d = [], u = [], c = this._sheetDrawingService.getDrawingData(n, r), l = [], g = [];
    if (Object.keys(c).forEach((h) => {
      const f = c[h], { sheetTransform: m, transform: p, anchorType: w = O.Position } = f;
      if (m == null || p == null)
        return;
      let S, I;
      if (t === "insert") {
        const v = this._expandCol(m, p, o, a, w);
        S = v == null ? void 0 : v.newSheetTransform, I = v == null ? void 0 : v.newTransform;
      } else {
        const { from: v, to: C } = m, { column: _ } = v, { column: y } = C;
        if (w === O.Both && _ >= o && y <= a)
          g.push({ unitId: n, subUnitId: r, drawingId: h });
        else {
          const R = this._shrinkCol(m, p, o, a, w);
          S = R == null ? void 0 : R.newSheetTransform, I = R == null ? void 0 : R.newTransform;
        }
      }
      if (!S || !I)
        return;
      const D = { unitId: n, subUnitId: r, drawingId: h, transform: I, sheetTransform: S };
      l.push(D);
    }), l.length === 0 && g.length === 0)
      return { redos: [], undos: [] };
    if (l.length > 0) {
      const h = this._sheetDrawingService.getBatchUpdateOp(l), { undo: f, redo: m, objects: p } = h;
      d.push({ id: P.id, params: { unitId: n, subUnitId: r, op: m, objects: p, type: U.UPDATE } }), u.push({ id: P.id, params: { unitId: n, subUnitId: r, op: f, objects: p, type: U.UPDATE } });
    }
    if (g.length > 0) {
      const h = this._sheetDrawingService.getBatchRemoveOp(g), f = h.undo, m = h.redo, p = h.objects;
      d.push({ id: P.id, params: { unitId: n, subUnitId: r, op: m, objects: p, type: U.REMOVE } }), u.push({ id: P.id, params: { unitId: n, subUnitId: r, op: f, objects: p, type: U.INSERT } });
    }
    return d.push({ id: V.id, params: [n] }), u.push({ id: V.id, params: [n] }), { redos: d, undos: u };
  }
  _expandCol(i, t, e, n, r = O.Position) {
    const s = n - e + 1, { from: o, to: a } = i, { column: d } = o, { column: u } = a;
    if (r === O.None)
      return {
        newSheetTransform: j({ ...t }, this._selectionRenderService),
        newTransform: t
      };
    let c = null, l = null;
    if (d >= e) {
      const g = this._skeletonManagerService.attachRangeWithCoord({ startColumn: e, endColumn: n, startRow: o.row, endRow: a.row });
      if (g == null)
        return;
      l = { ...t, left: (t.left || 0) + g.endX - g.startX }, c = j(l, this._selectionRenderService);
    } else if (u >= n)
      if (r === O.Both)
        c = {
          from: { ...o },
          to: { ...a, column: u + s }
        }, l = Z(c, this._selectionRenderService, this._skeletonManagerService);
      else
        return {
          newSheetTransform: j({ ...t }, this._selectionRenderService),
          newTransform: t
        };
    return c != null && l != null ? {
      newSheetTransform: c,
      newTransform: l
    } : null;
  }
  _shrinkCol(i, t, e, n, r = O.Position) {
    const s = n - e + 1, { from: o, to: a } = i, { column: d } = o, { column: u } = a;
    if (r === O.None)
      return {
        newSheetTransform: j({ ...t }, this._selectionRenderService),
        newTransform: t
      };
    let c = null, l = null;
    if (d > n)
      c = {
        from: { ...o, column: d - s },
        to: { ...a, column: u - s }
      }, l = Z(c, this._selectionRenderService, this._skeletonManagerService);
    else {
      if (d >= e && u <= n)
        return null;
      if (d < e && u > n)
        if (r === O.Both)
          c = {
            from: { ...o },
            to: { ...a, column: u - s }
          }, l = Z(c, this._selectionRenderService, this._skeletonManagerService);
        else
          return {
            newSheetTransform: j({ ...t }, this._selectionRenderService),
            newTransform: t
          };
      else if (d >= e && d <= n) {
        if (d === e)
          l = { ...t, left: (t.left || 0) - i.from.columnOffset };
        else {
          const g = this._skeletonManagerService.attachRangeWithCoord({ startColumn: e, endColumn: d - 1, startRow: o.row, endRow: a.row });
          if (g == null)
            return;
          l = { ...t, left: (t.left || 0) - g.endX + g.startX - i.from.columnOffset };
        }
        c = j(l, this._selectionRenderService);
      } else if (u >= e && u <= n && r === O.Both) {
        const g = this._skeletonManagerService.attachRangeWithCoord({
          startColumn: e - 1,
          endColumn: e - 1,
          startRow: o.row,
          endRow: a.row
        });
        if (g == null)
          return;
        c = {
          from: { ...o },
          to: { ...a, column: e - 1, columnOffset: g.endX - g.startX }
        }, l = Z(c, this._selectionRenderService, this._skeletonManagerService);
      }
    }
    return c != null && l != null ? {
      newSheetTransform: c,
      newTransform: l
    } : null;
  }
  _expandRow(i, t, e, n, r = O.Position) {
    const s = n - e + 1, { from: o, to: a } = i, { row: d } = o, { row: u } = a;
    if (r === O.None)
      return {
        newSheetTransform: j({ ...t }, this._selectionRenderService),
        newTransform: t
      };
    let c = null, l = null;
    if (d >= e) {
      const g = this._skeletonManagerService.attachRangeWithCoord({ startRow: e, endRow: n, startColumn: o.column, endColumn: a.column });
      if (g == null)
        return;
      l = { ...t, top: (t.top || 0) + g.endY - g.startY }, c = j(l, this._selectionRenderService);
    } else if (u >= n)
      if (r === O.Both)
        c = {
          from: { ...o },
          to: {
            ...a,
            row: u + s
          }
        }, l = Z(c, this._selectionRenderService, this._skeletonManagerService);
      else
        return {
          newSheetTransform: j({ ...t }, this._selectionRenderService),
          newTransform: t
        };
    return c != null && l != null ? {
      newSheetTransform: c,
      newTransform: l
    } : null;
  }
  _shrinkRow(i, t, e, n, r = O.Position) {
    const s = n - e + 1, { from: o, to: a } = i, { row: d } = o, { row: u } = a;
    if (r === O.None)
      return {
        newSheetTransform: j({ ...t }, this._selectionRenderService),
        newTransform: t
      };
    let c = null, l = null;
    if (d > n)
      c = {
        from: { ...o, row: d - s },
        to: { ...a, row: u - s }
      }, l = Z(c, this._selectionRenderService, this._skeletonManagerService);
    else {
      if (d >= e && u <= n)
        return null;
      if (d < e && u > n)
        if (r === O.Both)
          c = {
            from: { ...o },
            to: { ...a, row: u - s }
          }, l = Z(c, this._selectionRenderService, this._skeletonManagerService);
        else
          return {
            newSheetTransform: j({ ...t }, this._selectionRenderService),
            newTransform: t
          };
      else if (d >= e && d <= n) {
        if (d === e)
          l = { ...t, top: (t.top || 0) - i.from.rowOffset };
        else {
          const g = this._skeletonManagerService.attachRangeWithCoord({ startRow: e, endRow: d - 1, startColumn: o.column, endColumn: a.column });
          if (g == null)
            return;
          l = { ...t, top: (t.top || 0) - g.endY + g.startY - i.from.rowOffset };
        }
        c = j(l, this._selectionRenderService);
      } else if (u >= e && u <= n && r === O.Both) {
        const g = this._skeletonManagerService.attachRangeWithCoord({ startColumn: o.column, endColumn: o.column, startRow: e - 1, endRow: e - 1 });
        if (g == null)
          return;
        c = {
          from: { ...o },
          to: { ...a, row: e - 1, rowOffset: g.endY - g.startY }
        }, l = Z(c, this._selectionRenderService, this._skeletonManagerService);
      }
    }
    return c != null && l != null ? {
      newSheetTransform: c,
      newTransform: l
    } : null;
  }
  _commandListener() {
    this.disposeWithMe(
      // TODO@weird94: this should subscribe to the command service
      // but the skeleton changes like other render modules. These two signals are not equivalent.
      // As a temp solution, I subscribed to activate$ here.
      this._commandService.onCommandExecuted((i) => {
        if (i.id === Ki.id) {
          const { unitId: t, subUnitId: e } = i.params;
          this._updateDrawings(t, e);
        }
      })
    ), this.disposeWithMe(
      this._context.activated$.subscribe((i) => {
        const { unit: t, unitId: e } = this._context;
        if (i) {
          const n = t.getActiveSheet().getSheetId();
          this._updateDrawings(e, n);
        } else
          this._clearDrawings(e);
      })
    );
  }
  _clearDrawings(i) {
    setTimeout(() => {
      const t = this._drawingManagerService.drawingManagerData, e = [];
      Object.keys(t).forEach((n) => {
        const r = t[n];
        r != null && Object.keys(r).forEach((s) => {
          const o = r[s].data;
          o != null && Object.keys(o).forEach((a) => {
            n === i && e.push(o[a]);
          });
        });
      }), this._drawingManagerService.removeNotification(e);
    });
  }
  _updateDrawings(i, t) {
    setTimeout(() => {
      const e = this._drawingManagerService.drawingManagerData, n = [], r = [];
      Object.keys(e).forEach((s) => {
        const o = e[s];
        o != null && Object.keys(o).forEach((a) => {
          const d = o[a].data;
          d != null && Object.keys(d).forEach((u) => {
            if (s === i && a === t) {
              const c = d[u];
              c.transform = Z(c.sheetTransform, this._selectionRenderService, this._skeletonManagerService), n.push(d[u]);
            } else
              r.push(d[u]);
          });
        });
      }), this._drawingManagerService.removeNotification(r), this._drawingManagerService.addNotification(n);
    }, 0);
  }
  _sheetRefreshListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((i) => {
        mo.includes(i.id) && requestIdleCallback(() => {
          const t = i.params, { unitId: e, subUnitId: n, ranges: r } = t;
          this._refreshDrawingTransform(e, n, r);
        });
      })
    );
  }
  _refreshDrawingTransform(i, t, e) {
    const n = this._drawingManagerService.getDrawingData(i, t), r = [];
    Object.keys(n).forEach((s) => {
      const o = n[s], { sheetTransform: a, transform: d, anchorType: u = O.Position } = o;
      if (u === O.None)
        return !0;
      const { from: c, to: l } = a, { row: g, column: h } = c, { row: f, column: m } = l;
      for (let p = 0; p < e.length; p++) {
        const w = e[p], { startRow: S, endRow: I, startColumn: D, endColumn: v } = w;
        if (yi.intersects(
          {
            startRow: S,
            endRow: I,
            startColumn: D,
            endColumn: v
          },
          {
            startRow: g,
            endRow: f,
            startColumn: h,
            endColumn: m
          }
        ) || g > I || h > v) {
          const C = u === O.Position, _ = Z(a, this._selectionRenderService, this._skeletonManagerService);
          r.push({
            ...o,
            transform: {
              ..._,
              width: C ? d == null ? void 0 : d.width : _ == null ? void 0 : _.width,
              height: C ? d == null ? void 0 : d.height : _ == null ? void 0 : _.height
            }
          });
          break;
        }
      }
    }), r.length !== 0 && (this._drawingManagerService.refreshTransform(r), this._commandService.syncExecuteCommand(V.id, [i]));
  }
};
Rn = go([
  _e(1, Q),
  _e(2, Y),
  _e(3, Ze),
  _e(4, A(X)),
  _e(5, A(Vt)),
  _e(6, se),
  _e(7, oe),
  _e(8, de)
], Rn);
function Yr({ ref: i, ...t }) {
  const { icon: e, id: n, className: r, extend: s, ...o } = t, a = `univerjs-icon univerjs-icon-${n} ${r || ""}`.trim(), d = Es(`_${_o()}`);
  return Gr(e, `${n}`, {
    defIds: e.defIds,
    idSuffix: d.current
  }, {
    ref: i,
    className: a,
    ...o
  }, s);
}
function Gr(i, t, e, n, r) {
  return Ar(i.tag, {
    key: t,
    ...po(i, e, r),
    ...n
  }, (wo(i, e).children || []).map((s, o) => Gr(s, `${t}-${i.tag}-${o}`, e, void 0, r)));
}
function po(i, t, e) {
  const n = { ...i.attrs };
  e != null && e.colorChannel1 && n.fill === "colorChannel1" && (n.fill = e.colorChannel1), i.tag === "mask" && n.id && (n.id = n.id + t.idSuffix), Object.entries(n).forEach(([s, o]) => {
    s === "mask" && typeof o == "string" && (n[s] = o.replace(/url\(#(.*)\)/, `url(#$1${t.idSuffix})`));
  });
  const { defIds: r } = t;
  return !r || r.length === 0 || (i.tag === "use" && n["xlink:href"] && (n["xlink:href"] = n["xlink:href"] + t.idSuffix), Object.entries(n).forEach(([s, o]) => {
    typeof o == "string" && (n[s] = o.replace(/url\(#(.*)\)/, `url(#$1${t.idSuffix})`));
  })), n;
}
function wo(i, t) {
  var n;
  const { defIds: e } = t;
  return !e || e.length === 0 ? i : i.tag === "defs" && ((n = i.children) != null && n.length) ? {
    ...i,
    children: i.children.map((r) => typeof r.attrs.id == "string" && e && e.includes(r.attrs.id) ? {
      ...r,
      attrs: {
        ...r.attrs,
        id: r.attrs.id + t.idSuffix
      }
    } : r)
  } : i;
}
function _o() {
  return Math.random().toString(36).substring(2, 8);
}
Yr.displayName = "UniverIcon";
const So = {
  tag: "svg",
  attrs: {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 17 16",
    width: "1em",
    height: "1em"
  },
  children: [{
    tag: "path",
    attrs: {
      fill: "currentColor",
      d: "M2.35381 3.65517C2.35381 2.88198 2.98061 2.25518 3.75381 2.25518H8.10381C8.43518 2.25518 8.70381 1.98655 8.70381 1.65518C8.70381 1.3238 8.43518 1.05518 8.10381 1.05518H3.75381C2.31787 1.05518 1.15381 2.21923 1.15381 3.65517V12.3552C1.15381 13.7911 2.31787 14.9552 3.75381 14.9552H12.4538C13.8897 14.9552 15.0538 13.7911 15.0538 12.3552V8.00518C15.0538 7.6738 14.7852 7.40518 14.4538 7.40518C14.1224 7.40518 13.8538 7.6738 13.8538 8.00518V9.24469L12.3428 8.11143C11.8294 7.72642 11.1111 7.77744 10.6573 8.23119L9.11281 9.77567L6.84342 7.83047C6.34812 7.40592 5.61375 7.41815 5.13289 7.85896L2.35381 10.4064V3.65517ZM2.35381 12.0343V12.3552C2.35381 13.1284 2.98061 13.7552 3.75381 13.7552H12.4538C13.227 13.7552 13.8538 13.1284 13.8538 12.3552V10.7447L11.6228 9.07144C11.5871 9.04469 11.5373 9.04827 11.5058 9.07971L10.0266 10.5589L11.2057 11.5696C11.4573 11.7853 11.4865 12.164 11.2708 12.4156C11.0552 12.6672 10.6764 12.6964 10.4248 12.4807L6.06245 8.74157C6.02809 8.71212 5.97713 8.71296 5.94377 8.74353L2.35381 12.0343Z",
      fillRule: "evenodd",
      clipRule: "evenodd"
    }
  }, {
    tag: "path",
    attrs: {
      fill: "currentColor",
      d: "M10.3911 3.84419C10.6254 3.60988 11.0053 3.60988 11.2396 3.84419L11.8818 4.48643V1.93496C11.8818 1.60359 12.1505 1.33496 12.4818 1.33496C12.8132 1.33496 13.0818 1.60359 13.0818 1.93496V4.48676L13.7244 3.84419C13.9587 3.60988 14.3386 3.60988 14.5729 3.84419C14.8072 4.07851 14.8072 4.45841 14.5729 4.69272L12.9063 6.35939C12.6719 6.5937 12.292 6.5937 12.0577 6.35939L10.3911 4.69272C10.1568 4.45841 10.1568 4.07851 10.3911 3.84419Z"
    }
  }]
}, Xr = Ts(function(t, e) {
  return Ar(Yr, Object.assign({}, t, {
    id: "download-image-icon",
    ref: e,
    icon: So
  }));
});
Xr.displayName = "DownloadImageIcon";
function vo() {
  const i = Ie(Te), t = Ie(bn), e = Ie(yn), [n, r] = Ee([ye.CELL_ADDRESS]), [s, o] = Ee(!1), [a, d] = Ee(null), u = Fe(() => e.getCellImagesInSelection(), [e]), c = Fe(() => e.getDataColumns(), [e]), l = Fe(() => e.getSelectionRowRange(), [e]), g = c.length > 0, h = Fe(() => c.map((C) => ({
    label: C.label,
    value: String(C.index)
  })), [c]), [f, m] = Ee(
    () => h.length > 0 ? h[0].value : "0"
  ), p = Fe(() => {
    if (!n.includes(ye.COLUMN_VALUE) || !l)
      return [];
    const _ = Number(f);
    return [{
      startRow: l.startRow,
      endRow: l.endRow,
      startColumn: _,
      endColumn: _
    }];
  }, [n, f, l]);
  fi(p);
  const w = Et((C) => {
    C.length !== 0 && r(C);
  }, []), S = Et((C) => {
    m(String(C));
  }, []), I = Et(() => {
    t.close(ze);
  }, [t]), D = Et(async () => {
    if (u.length !== 0) {
      o(!0), d(null);
      try {
        await e.saveImages(u, {
          fileNameParts: n,
          columnIndex: n.includes(ye.COLUMN_VALUE) ? Number(f) : void 0
        }), t.close(ze);
      } catch (C) {
        console.error("Failed to save images:", C), d(i.t("sheetImage.save.error"));
      } finally {
        o(!1);
      }
    }
  }, [e, u, n, f, t, i]), v = n.includes(ye.COLUMN_VALUE);
  return /* @__PURE__ */ Xe("div", { className: "univer-flex univer-flex-col", children: [
    /* @__PURE__ */ L(en, { label: i.t("sheetImage.save.imageCount"), children: /* @__PURE__ */ L("div", { className: "univer-text-sm univer-text-gray-600", children: u.length }) }),
    /* @__PURE__ */ L(en, { label: i.t("sheetImage.save.fileNameConfig"), children: /* @__PURE__ */ Xe(Qi, { value: n, onChange: w, direction: "vertical", children: [
      /* @__PURE__ */ L(Yn, { value: ye.CELL_ADDRESS, disabled: !g, children: i.t("sheetImage.save.useRowCol") }),
      g && /* @__PURE__ */ L(Yn, { value: ye.COLUMN_VALUE, children: i.t("sheetImage.save.useColumnValue") })
    ] }) }),
    v && /* @__PURE__ */ L(en, { label: i.t("sheetImage.save.selectColumn"), children: /* @__PURE__ */ L(
      es,
      {
        value: f,
        options: h,
        onChange: S
      }
    ) }),
    a && /* @__PURE__ */ L("div", { className: "univer-text-xs univer-text-red-500", children: a }),
    /* @__PURE__ */ Xe(
      "div",
      {
        className: "univer-flex univer-justify-end univer-gap-2 univer-border-t univer-border-gray-200 univer-pt-3",
        children: [
          /* @__PURE__ */ L(Gn, { onClick: I, disabled: s, children: i.t("sheetImage.save.cancel") }),
          /* @__PURE__ */ L(
            Gn,
            {
              variant: "primary",
              onClick: D,
              disabled: s || u.length === 0,
              children: s ? i.t("sheetImage.save.saving") : i.t("sheetImage.save.confirm")
            }
          )
        ]
      }
    )
  ] });
}
const Io = (i) => {
  var S;
  const t = Ie(Y), e = Ie(Te), n = Ie(oe), r = Ie(Q), { drawings: s } = i, o = s[0];
  if (o == null)
    return;
  const { unitId: a } = o, d = r.getRenderById(a), u = d == null ? void 0 : d.scene;
  if (u == null)
    return;
  const c = u.getTransformerByCreate(), [l, g] = Ee(!0), h = (S = o.anchorType) != null ? S : O.Position, [f, m] = Ee(h);
  function p(I, D) {
    const v = [];
    return I.forEach((C) => {
      const { oKey: _ } = C, y = D.getDrawingOKey(_);
      if (y == null)
        return v.push(null), !0;
      const { unitId: R, subUnitId: E, drawingId: T, drawingType: M, anchorType: b, sheetTransform: N } = y;
      v.push({
        unitId: R,
        subUnitId: E,
        drawingId: T,
        anchorType: b,
        sheetTransform: N,
        drawingType: M
      });
    }), v;
  }
  Nr(() => {
    const I = c.clearControl$.subscribe((v) => {
      v === !0 && g(!1);
    }), D = c.changeStart$.subscribe((v) => {
      var y;
      const { objects: C } = v, _ = p(C, n);
      if (_.length === 0)
        g(!1);
      else if (_.length >= 1) {
        g(!0);
        const R = ((y = _[0]) == null ? void 0 : y.anchorType) || O.Position;
        m(R);
      }
    });
    return () => {
      D.unsubscribe(), I.unsubscribe();
    };
  }, []);
  function w(I) {
    m(I);
    const D = n.getFocusDrawings();
    if (D.length === 0)
      return;
    const v = D.map((C) => ({
      unitId: C.unitId,
      subUnitId: C.subUnitId,
      drawingId: C.drawingId,
      anchorType: I
    }));
    t.executeCommand(zt.id, {
      unitId: D[0].unitId,
      drawings: v
    });
  }
  return /* @__PURE__ */ Xe(
    "div",
    {
      className: ts("univer-grid univer-gap-2 univer-py-2 univer-text-gray-400", {
        "univer-hidden": !l
      }),
      children: [
        /* @__PURE__ */ L(
          "header",
          {
            className: "univer-text-gray-600 dark:!univer-text-gray-200",
            children: /* @__PURE__ */ L("div", { children: e.t("drawing-anchor.title") })
          }
        ),
        /* @__PURE__ */ L("div", { children: /* @__PURE__ */ Xe(ns, { value: f, onChange: w, direction: "vertical", children: [
          /* @__PURE__ */ L(tn, { value: O.Both, children: e.t("drawing-anchor.both") }),
          /* @__PURE__ */ L(tn, { value: O.Position, children: e.t("drawing-anchor.position") }),
          /* @__PURE__ */ L(tn, { value: O.None, children: e.t("drawing-anchor.none") })
        ] }) })
      ]
    }
  );
}, Co = () => {
  const i = Ie(oe), t = i.getFocusDrawings(), [e, n] = Ee(t);
  return Nr(() => {
    const r = i.focus$.subscribe((s) => {
      n(s);
    });
    return () => {
      r.unsubscribe();
    };
  }, []), !!(e != null && e.length) && /* @__PURE__ */ Xe("div", { className: "univer-text-sm", children: [
    /* @__PURE__ */ L(Rs, { drawings: e }),
    /* @__PURE__ */ L(Io, { drawings: e })
  ] });
}, zr = "sheet.menu.image";
function Ro(i) {
  return {
    id: zr,
    type: Gt.SUBITEMS,
    icon: "AddImageIcon",
    tooltip: "sheetImage.title",
    hidden$: Yt(i, $.UNIVER_SHEET),
    disabled$: mi(i, { workbookTypes: [gn], worksheetTypes: [fn], rangeTypes: [Zi] })
  };
}
function Do(i) {
  return {
    id: Kt.id,
    title: "sheetImage.upload.float",
    type: Gt.BUTTON,
    hidden$: Yt(i, $.UNIVER_SHEET)
  };
}
function bo(i) {
  return {
    id: Mn.id,
    title: "sheetImage.upload.cell",
    type: Gt.BUTTON,
    hidden$: Yt(i, $.UNIVER_SHEET)
  };
}
function Mo(i) {
  var t, e, n, r;
  return !!((e = (t = i == null ? void 0 : i.p) == null ? void 0 : t.drawingsOrder) != null && e.length && ((r = (n = i == null ? void 0 : i.p) == null ? void 0 : n.drawingsOrder) == null ? void 0 : r.length) > 0);
}
function yo(i, t) {
  const e = i.getActiveSheet();
  if (!e) return !1;
  const n = e.getCellMatrix(), { startRow: r, endRow: s, startColumn: o, endColumn: a } = t;
  for (let d = r; d <= s; d++)
    for (let u = o; u <= a; u++) {
      const c = n.getValue(d, u);
      if (Mo(c))
        return !0;
    }
  return !1;
}
function Eo() {
  return "showDirectoryPicker" in window;
}
function dn(i) {
  const t = i.get(de), e = i.get(ut), n = at([
    Yt(i, $.UNIVER_SHEET),
    t.getCurrentTypeOfUnit$($.UNIVER_SHEET).pipe(
      me((r) => r ? e.selectionMoveEnd$.pipe(
        pe(() => {
          if (!Eo())
            return !0;
          const s = e.getCurrentSelections();
          if (!s || s.length === 0)
            return !0;
          for (const o of s)
            if (yo(r, o.range))
              return !1;
          return !0;
        })
      ) : wn(!0))
    )
  ]).pipe(
    pe(([r, s]) => r || s)
  );
  return {
    id: ct.id,
    type: Gt.BUTTON,
    icon: "DownloadImageIcon",
    title: "sheetImage.save.menuLabel",
    hidden$: n
  };
}
const To = {
  [fs.MEDIA]: {
    [zr]: {
      order: 0,
      menuItemFactory: Ro,
      [Kt.id]: {
        order: 0,
        menuItemFactory: Do
      },
      [Mn.id]: {
        order: 1,
        menuItemFactory: bo
      }
    }
  },
  [rn.MAIN_AREA]: {
    [sn.OTHERS]: {
      [ct.id]: {
        order: 10,
        menuItemFactory: dn
      }
    }
  },
  [rn.COL_HEADER]: {
    [sn.OTHERS]: {
      [ct.id]: {
        order: 10,
        menuItemFactory: dn
      }
    }
  },
  [rn.ROW_HEADER]: {
    [sn.OTHERS]: {
      [ct.id]: {
        order: 10,
        menuItemFactory: dn
      }
    }
  }
};
function ft(i) {
  return !i.getContextValue(Ei) && !i.getContextValue(Ti) && !i.getContextValue(Oi) && i.getContextValue(Ge);
}
const Oo = {
  id: gt.id,
  description: "shortcut.drawing-move-down",
  group: "4_drawing-view",
  binding: Ke.ARROW_DOWN,
  priority: 100,
  preconditions: ft,
  staticParameters: {
    direction: ve.DOWN
  }
}, Uo = {
  id: gt.id,
  description: "shortcut.drawing-move-up",
  group: "4_drawing-view",
  binding: Ke.ARROW_UP,
  priority: 100,
  preconditions: ft,
  staticParameters: {
    direction: ve.UP
  }
}, Po = {
  id: gt.id,
  description: "shortcut.drawing-move-left",
  group: "4_drawing-view",
  binding: Ke.ARROW_LEFT,
  priority: 100,
  preconditions: ft,
  staticParameters: {
    direction: ve.LEFT
  }
}, Ao = {
  id: gt.id,
  description: "shortcut.drawing-move-right",
  group: "4_drawing-view",
  binding: Ke.ARROW_RIGHT,
  priority: 100,
  preconditions: ft,
  staticParameters: {
    direction: ve.RIGHT
  }
}, No = {
  id: $r.id,
  description: "shortcut.drawing-delete",
  group: "4_drawing-view",
  // when focusing on any other input tag do not trigger this shortcut
  preconditions: ft,
  binding: Ke.DELETE,
  mac: Ke.BACKSPACE
};
var $o = Object.getOwnPropertyDescriptor, ko = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? $o(t, e) : t, s = i.length - 1, o; s >= 0; s--)
    (o = i[s]) && (r = o(r) || r);
  return r;
}, Be = (i, t) => (e, n) => t(e, n, i);
let Ft = class extends ee {
  constructor(i, t, e, n, r, s) {
    super(), this._componentManager = i, this._menuManagerService = t, this._commandService = e, this._shortcutService = n, this._drawingManagerService = r, this._sheetsSelectionsService = s, this._init();
  }
  _initCustomComponents() {
    const i = this._componentManager;
    this.disposeWithMe(i.register(Br, Co)), this.disposeWithMe(i.register(ze, vo)), this.disposeWithMe(i.register("DownloadImageIcon", Xr));
  }
  _initMenus() {
    this._menuManagerService.mergeMenu(To);
  }
  _initCommands() {
    [
      Kt,
      Mn,
      Xt,
      ht,
      zt,
      jr,
      V,
      Fr,
      kr,
      Wr,
      gt,
      $r,
      xr,
      ct
    ].forEach((i) => this.disposeWithMe(this._commandService.registerCommand(i)));
  }
  _initShortcuts() {
    [
      // sheet drawing shortcuts
      Oo,
      Uo,
      Po,
      Ao,
      No
    ].forEach((i) => {
      this.disposeWithMe(this._shortcutService.registerShortcut(i));
    });
  }
  _init() {
    this._initCommands(), this._initCustomComponents(), this._initMenus(), this._initShortcuts();
  }
};
Ft = ko([
  Be(0, A(Ur)),
  Be(1, ms),
  Be(2, Y),
  Be(3, ps),
  Be(4, oe),
  Be(5, A(ut))
], Ft);
var xo = Object.defineProperty, Wo = Object.getOwnPropertyDescriptor, Bo = (i, t, e) => t in i ? xo(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, jo = (i, t, e, n) => {
  for (var r = n > 1 ? void 0 : n ? Wo(t, e) : t, s = i.length - 1, o; s >= 0; s--)
    (o = i[s]) && (r = o(r) || r);
  return r;
}, ln = (i, t) => (e, n) => t(e, n, i), Kr = (i, t, e) => Bo(i, typeof t != "symbol" ? t + "" : t, e);
const Fo = "SHEET_IMAGE_UI_PLUGIN";
let Lt = class extends Ai {
  constructor(i = sr, t, e, n) {
    super(), this._config = i, this._injector = t, this._renderManagerService = e, this._configService = n;
    const { menu: r, ...s } = Ni(
      {},
      sr,
      this._config
    );
    r && this._configService.setConfig("menu", r, { merge: !0 }), this._configService.setConfig(Ws, s);
  }
  onStarting() {
    $i(this._injector, [
      [lt],
      [Ft],
      [Nt],
      [jt],
      [Bt],
      [Wt],
      [$t],
      [kt],
      [xt],
      [yn, { useClass: vn }]
    ]), Qt(this._injector, [
      [lt]
    ]);
  }
  onReady() {
    Qt(this._injector, [
      [Wt],
      [xt]
    ]);
  }
  onRendered() {
    this._registerRenderModules(), Qt(this._injector, [
      [Bt],
      [jt],
      [Ft],
      [$t],
      [kt]
    ]);
  }
  onSteady() {
    this._injector.get(Nt);
  }
  _registerRenderModules() {
    [
      [dt],
      [Rn],
      [Cn],
      [In]
    ].forEach((i) => {
      this.disposeWithMe(this._renderManagerService.registerRenderModule($.UNIVER_SHEET, i));
    });
  }
};
Kr(Lt, "type", $.UNIVER_SHEET);
Kr(Lt, "pluginName", Fo);
Lt = jo([
  Ui(as, _s, Ds, ki),
  ln(1, A(qe)),
  ln(2, Q),
  ln(3, Pi)
], Lt);
export {
  vn as BatchSaveImagesService,
  V as ClearSheetDrawingTransformerOperation,
  $r as DeleteDrawingsCommand,
  Fr as EditSheetDrawingOperation,
  ye as FileNamePart,
  kr as GroupSheetDrawingCommand,
  yn as IBatchSaveImagesService,
  Kt as InsertFloatImageCommand,
  Xt as InsertSheetDrawingCommand,
  gt as MoveDrawingsCommand,
  ht as RemoveSheetDrawingCommand,
  zr as SHEETS_IMAGE_MENU_ID,
  ao as SHEET_FLOAT_DOM_PREFIX,
  ct as SaveCellImagesCommand,
  xr as SetDrawingArrangeCommand,
  zt as SetSheetDrawingCommand,
  lt as SheetCanvasFloatDomManagerService,
  dt as SheetDrawingUpdateController,
  jr as SidebarSheetDrawingOperation,
  Wr as UngroupSheetDrawingCommand,
  Lt as UniverSheetsDrawingUIPlugin,
  fe as calcSheetFloatDomPosition,
  Z as drawingPositionToTransform,
  j as transformToDrawingPosition
};
