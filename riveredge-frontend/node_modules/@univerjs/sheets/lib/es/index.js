var Ii = Object.defineProperty;
var vi = (n, e, t) => e in n ? Ii(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;
var R = (n, e, t) => vi(n, typeof e != "symbol" ? e + "" : e, t);
import { CellValueType as re, isTextFormat as Rs, isRealNum as Ds, isBooleanString as Do, willLoseNumericPrecision as Mi, CommandType as v, IUniverInstanceService as M, Tools as A, createInterceptorKey as ft, Disposable as ue, UniverInstanceType as B, InterceptorEffectEnum as he, InterceptorManager as As, toDisposable as Ne, remove as je, composeInterceptors as _i, DisposableCollection as Et, BooleanNumber as te, HorizontalAlign as xs, BorderStyleTypes as Ao, Inject as $, IResourceManagerService as Rn, RTree as yi, generateRandomId as kt, insertMatrixArray as Pn, ObjectMatrix as Y, Rectangle as O, moveMatrixArray as xo, sliceMatrixArray as $o, concatMatrixArray as Wo, spliceArray as Vo, Range as X, normalizeTextRuns as bi, isSafeNumeric as Ei, RANGE_TYPE as j, createRowColIter as ki, ICommandService as E, IUndoRedoService as V, RxDisposable as Lo, sequenceExecute as L, selectionToArray as Ui, createIdentifier as $s, IContextService as Ho, ErrorService as Vt, LocaleService as it, cellToRange as Fo, PermissionStatus as q, IPermissionService as Ze, isICellData as Bo, mapObjectMatrix as Ti, Dimension as Re, getArrayLength as jo, Direction as pe, Injector as is, queryObjectMatrix as at, CellModeEnum as Pi, IConfigService as Cn, cloneWorksheetData as Ni, mergeWorksheetSnapshotWithDefault as Oi, BorderType as de, FontWeight as Di, FontItalic as Ai, ILogService as zo, DocumentDataModel as xi, BuildTextUtils as $i, TextX as Wi, CustomCommandExecutionError as Vi, IAuthzIoService as Li, UserManagerService as Hi, LRUMap as Fi, Optional as Bi, isDefaultFormat as ji, DependentOn as zi, Plugin as Gi, merge as Ki, IS_ROW_STYLE_PRECEDE_COLUMN_STYLE as Ji, AUTO_HEIGHT_FOR_MERGED_CELLS as qi, registerDependencies as Yi, mergeOverrideWithDependencies as Xi, touchDependencies as Mn } from "@univerjs/core";
import { Subject as De, BehaviorSubject as gt, merge as jt, shareReplay as Zi, takeUntil as et, switchMap as tt, of as Ie, distinctUntilChanged as Qi, skip as Go, map as Es, first as ea, filter as oo } from "rxjs";
import { SetDefinedNameMutation as en, RemoveDefinedNameMutation as Nn, SetDefinedNameMutationFactory as ta, IDefinedNamesService as Ko, LexerTreeBuilder as na, operatorToken as sa, deserializeRangeWithSheet as oa, sequenceNodeType as ra, deserializeRangeWithSheetWithCache as ia, SetFormulaCalculationResultMutation as aa, handleNumfmtInCell as ua, stripErrorMargin as la, UniverFormulaEnginePlugin as ca } from "@univerjs/engine-formula";
import { takeUntil as ro, filter as io, map as da } from "rxjs/operators";
import { DataSyncPrimaryController as ha } from "@univerjs/rpc";
function ga(n, e, t) {
  var r, i, a;
  if (e.t) return e.t;
  if (e.v === null) return null;
  const s = n.getStyleByCell(e), o = n.getStyleByCell(t);
  if (t.t === re.FORCE_STRING) {
    if (!Rs((r = o == null ? void 0 : o.n) == null ? void 0 : r.pattern) && e.v !== void 0) {
      if (Ds(e.v))
        return re.NUMBER;
      if (Do(`${e.v}`))
        return re.BOOLEAN;
    }
    return re.FORCE_STRING;
  }
  return ma(s) ? Rs((i = s == null ? void 0 : s.n) == null ? void 0 : i.pattern) ? re.STRING : ao(e, t) : Rs((a = o == null ? void 0 : o.n) == null ? void 0 : a.pattern) ? re.STRING : ao(e, t);
}
function ao(n, e) {
  return n.v !== void 0 ? uo(n.v, n.t) : uo(e.v, e.t);
}
function ma(n) {
  var e;
  return !!((e = n == null ? void 0 : n.n) != null && e.pattern);
}
function uo(n, e) {
  return n === null ? null : typeof n == "string" ? Ds(n) ? (+n == 0 || +n == 1) && e === re.BOOLEAN ? re.BOOLEAN : e !== re.STRING && e !== re.FORCE_STRING && Mi(n) ? re.FORCE_STRING : re.NUMBER : Do(n) ? re.BOOLEAN : re.STRING : typeof n == "number" ? (n === 0 || n === 1) && e === re.BOOLEAN ? re.BOOLEAN : re.NUMBER : typeof n == "boolean" ? re.BOOLEAN : re.FORCE_STRING;
}
const We = (n, e) => {
  if (n.get(M).getUniverSheetInstance(e.unitId) == null)
    throw new Error("universheet is null error!");
  return {
    unitId: e.unitId,
    subUnitId: e.subUnitId,
    ranges: A.deepClone(e.ranges)
  };
}, ne = {
  id: "sheet.mutation.add-worksheet-merge",
  type: v.MUTATION,
  handler: (n, e) => {
    const s = n.get(M).getUniverSheetInstance(e.unitId);
    if (s == null)
      throw new Error("universheet is null error!");
    const o = s.getSheetBySheetId(e.subUnitId);
    if (!o) return !1;
    const i = o.getConfig().mergeData, a = e.ranges;
    for (let u = 0; u < a.length; u++)
      i.push(a[u]);
    return o.getSpanModel().rebuild(i), !0;
  }
}, fa = ft("CELL_CONTENT"), Ra = ft("ROW_FILTERED"), ht = {
  CELL_CONTENT: fa,
  ROW_FILTERED: Ra
};
var Ca = /* @__PURE__ */ ((n) => (n[n.DATA_VALIDATION = 9] = "DATA_VALIDATION", n[n.NUMFMT = 10] = "NUMFMT", n[n.CELL_IMAGE = 11] = "CELL_IMAGE", n))(Ca || {});
const Jo = "sheet.interceptor.range-theme-id", lo = "sheet.interceptor.ignore-range-theme";
var pa = Object.getOwnPropertyDescriptor, Sa = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? pa(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, wa = (n, e) => (t, s) => e(t, s, n);
const co = ft("BEFORE_CELL_EDIT"), Cs = ft("AFTER_CELL_EDIT"), ps = ft("VALIDATE_CELL");
let G = class extends ue {
  /** @ignore */
  constructor(e) {
    super();
    R(this, "_interceptorsByName", /* @__PURE__ */ new Map());
    R(this, "_commandInterceptors", []);
    R(this, "_rangeInterceptors", []);
    R(this, "_autoHeightInterceptors", []);
    R(this, "_beforeCommandInterceptor", []);
    R(this, "_afterCommandInterceptors", []);
    R(this, "_workbookDisposables", /* @__PURE__ */ new Map());
    R(this, "_worksheetDisposables", /* @__PURE__ */ new Map());
    R(this, "_interceptorsDirty", !1);
    R(this, "_composedInterceptorByKey", /* @__PURE__ */ new Map());
    R(this, "writeCellInterceptor", new As({
      BEFORE_CELL_EDIT: co,
      AFTER_CELL_EDIT: Cs,
      VALIDATE_CELL: ps
    }));
    this._univerInstanceService = e, this.disposeWithMe(this._univerInstanceService.getTypeOfUnitAdded$(B.UNIVER_SHEET).subscribe((t) => {
      this._interceptWorkbook(t);
    })), this.disposeWithMe(this._univerInstanceService.getTypeOfUnitDisposed$(B.UNIVER_SHEET).subscribe(
      (t) => this._disposeWorkbookInterceptor(t)
    )), this.intercept(ht.CELL_CONTENT, {
      priority: -1,
      effect: he.Style | he.Value,
      handler: (t) => t
    }), this.disposeWithMe(this.writeCellInterceptor.intercept(Cs, {
      priority: -1,
      handler: (t) => t
    })), this.disposeWithMe(this.writeCellInterceptor.intercept(co, {
      priority: -1,
      handler: (t) => t
    })), this.disposeWithMe(this.writeCellInterceptor.intercept(ps, {
      priority: -1,
      handler: (t) => t
    }));
  }
  dispose() {
    super.dispose(), this._workbookDisposables.forEach((e) => e.dispose()), this._workbookDisposables.clear(), this._worksheetDisposables.forEach((e) => e.dispose()), this._worksheetDisposables.clear(), this._interceptorsByName.clear();
  }
  // #region intercept command execution
  /**
   * Add a listener function to a specific command to add affiliated mutations. It should be called in controllers.
   *
   * Pairs with {@link onCommandExecute}.
   *
   * @param interceptor
   * @returns
   */
  interceptCommand(e) {
    if (this._commandInterceptors.includes(e))
      throw new Error("[SheetInterceptorService]: Interceptor already exists!");
    return this._commandInterceptors.push(e), this._commandInterceptors.sort((t, s) => {
      var o, r;
      return ((o = s.priority) != null ? o : 0) - ((r = t.priority) != null ? r : 0);
    }), this.disposeWithMe(Ne(() => je(this._commandInterceptors, e)));
  }
  /**
   * When command is executing, call this method to gether undo redo mutations from upper features.
   * @param command
   * @returns
   */
  onCommandExecute(e) {
    const t = this._commandInterceptors.map((s) => s.getMutations(e));
    return {
      preUndos: t.map((s) => {
        var o;
        return (o = s.preUndos) != null ? o : [];
      }).flat(),
      undos: t.map((s) => s.undos).flat(),
      preRedos: t.map((s) => {
        var o;
        return (o = s.preRedos) != null ? o : [];
      }).flat(),
      redos: t.map((s) => s.redos).flat()
    };
  }
  interceptAfterCommand(e) {
    if (this._afterCommandInterceptors.includes(e))
      throw new Error("[SheetInterceptorService]: Interceptor already exists!");
    return this._afterCommandInterceptors.push(e), this._afterCommandInterceptors.sort((t, s) => {
      var o, r;
      return ((o = s.priority) != null ? o : 0) - ((r = t.priority) != null ? r : 0);
    }), this.disposeWithMe(Ne(() => je(this._afterCommandInterceptors, e)));
  }
  afterCommandExecute(e) {
    const t = this._afterCommandInterceptors.map((s) => s.getMutations(e));
    return {
      undos: t.map((s) => s.undos).flat(),
      redos: t.map((s) => s.redos).flat()
    };
  }
  interceptAutoHeight(e) {
    if (this._autoHeightInterceptors.includes(e))
      throw new Error("[SheetInterceptorService]: Interceptor already exists!");
    return this._autoHeightInterceptors.push(e), this._autoHeightInterceptors.sort((t, s) => {
      var o, r;
      return ((o = s.priority) != null ? o : 0) - ((r = t.priority) != null ? r : 0);
    }), this.disposeWithMe(Ne(() => je(this._autoHeightInterceptors, e)));
  }
  generateMutationsOfAutoHeight(e) {
    const t = this._autoHeightInterceptors.map((s) => s.getMutations(e));
    return {
      preUndos: t.map((s) => {
        var o;
        return (o = s.preUndos) != null ? o : [];
      }).flat(),
      undos: t.map((s) => s.undos).flat(),
      preRedos: t.map((s) => {
        var o;
        return (o = s.preRedos) != null ? o : [];
      }).flat(),
      redos: t.map((s) => s.redos).flat()
    };
  }
  /**
   * Add a listener function to a specific command to determine if the command can execute mutations. It should be
   * called in controllers.
   *
   * Pairs with {@link beforeCommandExecute}.
   *
   * @param interceptor
   * @returns
   */
  interceptBeforeCommand(e) {
    if (this._beforeCommandInterceptor.includes(e))
      throw new Error("[SheetInterceptorService]: Interceptor already exists!");
    return this._beforeCommandInterceptor.push(e), this._beforeCommandInterceptor.sort((t, s) => {
      var o, r;
      return ((o = s.priority) != null ? o : 0) - ((r = t.priority) != null ? r : 0);
    }), this.disposeWithMe(Ne(() => je(this._beforeCommandInterceptor, e)));
  }
  /**
   * before command execute, call this method to get the flag of whether it can be executed the commandï¼Œ
   * @param info ICommandInfo
   * @returns Promise<boolean>
   */
  async beforeCommandExecute(e) {
    return (await Promise.all(this._beforeCommandInterceptor.map((s) => s.performCheck(e)))).every((s) => s);
  }
  // #endregion
  // #region intercept ranges - mainly for pivot table currently (2024/10/28).
  /**
   * By adding callbacks to some Ranges can get some additional mutations, such as clearing all plugin data in a certain area.
   * @param interceptor IRangeInterceptors
   * @returns IDisposable
   */
  interceptRanges(e) {
    if (this._rangeInterceptors.includes(e))
      throw new Error("[SheetInterceptorService]: Interceptor already exists!");
    return this._rangeInterceptors.push(e), this._rangeInterceptors.sort((t, s) => {
      var o, r;
      return ((o = s.priority) != null ? o : 0) - ((r = t.priority) != null ? r : 0);
    }), this.disposeWithMe(Ne(() => je(this._rangeInterceptors, e)));
  }
  generateMutationsByRanges(e) {
    const t = this._rangeInterceptors.map((s) => s.getMutations(e));
    return {
      preUndos: t.map((s) => {
        var o;
        return (o = s.preUndos) != null ? o : [];
      }).flat(),
      undos: t.map((s) => s.undos).flat(),
      preRedos: t.map((s) => {
        var o;
        return (o = s.preRedos) != null ? o : [];
      }).flat(),
      redos: t.map((s) => s.redos).flat()
    };
  }
  // #endregion
  // #region intercept on writing cell
  onWriteCell(e, t, s, o, r) {
    const i = {
      subUnitId: t.getSheetId(),
      unitId: e.getUnitId(),
      workbook: e,
      worksheet: t,
      row: s,
      col: o,
      origin: A.deepClone(r)
    };
    return this.writeCellInterceptor.fetchThroughInterceptors(Cs)(r, i);
  }
  // #endregion
  onValidateCell(e, t, s, o) {
    const r = {
      subUnitId: t.getSheetId(),
      unitId: e.getUnitId(),
      workbook: e,
      worksheet: t,
      row: s,
      col: o
    };
    return this.writeCellInterceptor.fetchThroughInterceptors(ps)(Promise.resolve(!0), r);
  }
  intercept(e, t) {
    const s = e;
    this._interceptorsByName.has(s) || this._interceptorsByName.set(s, []);
    const o = this._interceptorsByName.get(s);
    o.push(t);
    const r = o.sort((i, a) => {
      var u, l;
      return ((u = a.priority) != null ? u : 0) - ((l = i.priority) != null ? l : 0);
    });
    if (this._interceptorsDirty = !0, s === ht.CELL_CONTENT) {
      const i = he.Style | he.Value;
      this._interceptorsByName.set(`${s}-${i}`, r);
      const a = he.Style | he.Value;
      return this._interceptorsByName.set(
        `${s}-${he.Style}`,
        r.filter((u) => ((u.effect || a) & he.Style) > 0)
      ), this._interceptorsByName.set(
        `${s}-${he.Value}`,
        r.filter((u) => ((u.effect || a) & he.Value) > 0)
      ), this.disposeWithMe(Ne(() => {
        je(this._interceptorsByName.get(s), t), je(this._interceptorsByName.get(`${s}-${i}`), t), je(this._interceptorsByName.get(`${s}-${he.Style}`), t), je(this._interceptorsByName.get(`${s}-${he.Value}`), t);
      }));
    } else
      return this._interceptorsByName.set(s, r), this.disposeWithMe(Ne(() => je(this._interceptorsByName.get(s), t)));
  }
  fetchThroughInterceptors(e, t, s, o) {
    const r = t === void 0 ? e : `${e}-${t}`, i = s != null ? s : r;
    let a = this._composedInterceptorByKey.get(i);
    if (!a || this._interceptorsDirty) {
      let u = this._interceptorsByName.get(r);
      u && o && (u = u.filter(o)), a = _i(u || []), this._composedInterceptorByKey.set(i, a);
    }
    return a;
  }
  _interceptWorkbook(e) {
    const t = new Et(), s = e.getUnitId(), o = this, r = (i) => {
      const a = i.getSheetId();
      i.__interceptViewModel((u) => {
        const l = new Et();
        o._worksheetDisposables.set(ho(s, i), l), l.add(u.registerCellContentInterceptor({
          getCell(c, d, h, g, m) {
            const f = i.getCellRaw(c, d);
            return o.fetchThroughInterceptors(ht.CELL_CONTENT, h, g, m)(
              f,
              {
                unitId: s,
                subUnitId: a,
                row: c,
                col: d,
                worksheet: i,
                workbook: e,
                rawData: f
              }
            );
          }
        })), l.add(u.registerRowFilteredInterceptor({
          getRowFiltered(c) {
            return !!o.fetchThroughInterceptors(ht.ROW_FILTERED)(
              !1,
              {
                unitId: s,
                subUnitId: a,
                row: c,
                workbook: e,
                worksheet: i
              }
            );
          }
        }));
      });
    };
    e.getSheets().forEach((i) => r(i)), t.add(e.sheetCreated$.subscribe((i) => r(i))), t.add(Ne(() => e.getSheets().forEach((i) => this._disposeSheetInterceptor(s, i)))), t.add(e.sheetDisposed$.subscribe((i) => this._disposeSheetInterceptor(s, i))), this._workbookDisposables.set(s, t);
  }
  _disposeWorkbookInterceptor(e) {
    const t = e.getUnitId(), s = this._workbookDisposables.get(t);
    s && (s.dispose(), this._workbookDisposables.delete(t));
  }
  _disposeSheetInterceptor(e, t) {
    const s = ho(e, t), o = this._worksheetDisposables.get(s);
    o && (o.dispose(), this._worksheetDisposables.delete(s));
  }
};
G = Sa([
  wa(0, M)
], G);
function ho(n, e) {
  return `${n}|${e.getSheetId()}`;
}
const ge = (n) => {
  const e = {};
  return n.bg && (e.bg = { ...n.bg }), n.ol && (e.ol = { ...n.ol }), n.bd && (e.bd = { ...n.bd }), n.cl && (e.cl = { ...n.cl }), n.ht && (e.ht = n.ht), n.vt && (e.vt = n.vt), n.bl !== void 0 && (e.bl = n.bl), e;
};
function Ia(n) {
  const e = {};
  if (n.length === 1)
    return n[0];
  for (const t of n)
    t.bg && (e.bg = t.bg), t.ol && (e.ol = t.ol), t.bd && (e.bd = { ...e.bd, ...t.bd }), t.cl && (e.cl = t.cl), t.ht && (e.ht = t.ht), t.vt && (e.vt = t.vt), t.bl !== void 0 && (e.bl = t.bl);
  return e;
}
const ce = {
  wholeStyle: 1,
  headerRowStyle: 2,
  headerColumnStyle: 4,
  firstRowStyle: 8,
  secondRowStyle: 16,
  lastRowStyle: 32,
  firstColumnStyle: 128,
  secondColumnStyle: 256,
  lastColumnStyle: 512
};
class Rt {
  /**
   * @constructor
   * @param {string} name The name of the range theme style, it used to identify the range theme style.
   * @param {IRangeThemeStyleJSON} [options] The options to initialize the range theme style.
   */
  constructor(e, t) {
    R(this, "_name");
    /**
     * @property {Nullable<IRangeThemeStyleItem>} wholeStyle effect for the whole range.
     */
    R(this, "wholeStyle", null);
    /**
     * @property {Nullable<IRangeThemeStyleItem>} headerRowStyle effect for the header row.
     */
    R(this, "headerRowStyle", null);
    /**
     * @property {Nullable<IRangeThemeStyleItem>} headerColumnStyle effect for the header column.
     */
    R(this, "headerColumnStyle", null);
    /**
     * @property {Nullable<IRangeThemeStyleItem>} firstRowStyle effect for the first row.
     */
    R(this, "firstRowStyle", null);
    /**
     * @property {Nullable<IRangeThemeStyleItem>} secondRowStyle effect for the second row.
     */
    R(this, "secondRowStyle", null);
    /**
     * @property {Nullable<IRangeThemeStyleItem>} lastRowStyle effect for the last row.
     */
    R(this, "lastRowStyle", null);
    /**
     * @property {Nullable<IRangeThemeStyleItem>} firstColumnStyle effect for the first column.
     */
    R(this, "firstColumnStyle", null);
    /**
     * @property {Nullable<IRangeThemeStyleItem>} secondColumnStyle effect for the second column.
     */
    R(this, "secondColumnStyle", null);
    /**
     * @property {Nullable<IRangeThemeStyleItem>} lastColumnStyle effect for the last column.
     */
    R(this, "lastColumnStyle", null);
    /**
     * @property {Nullable<IRangeThemeStyleItem>} quickly get merge style
     */
    R(this, "_mergeCacheMap", /* @__PURE__ */ new Map());
    t && this.fromJson({ ...t, name: e }), this._name = e;
  }
  /**
   * Gets the name of the range theme style.The name is read only, and use to identifier the range theme style.
   * @returns {string} The name of the range theme style.
   */
  getName() {
    return this._name;
  }
  getWholeStyle() {
    return this.wholeStyle;
  }
  setWholeStyle(e) {
    this.wholeStyle = e, this._resetStyleCache();
  }
  getFirstRowStyle() {
    return this.firstRowStyle;
  }
  setFirstRowStyle(e) {
    this.firstRowStyle = e, this._resetStyleCache();
  }
  getSecondRowStyle() {
    return this.secondRowStyle;
  }
  setSecondRowStyle(e) {
    this.secondRowStyle = e, this._resetStyleCache();
  }
  getLastRowStyle() {
    return this.lastRowStyle;
  }
  setLastRowStyle(e) {
    this.lastRowStyle = e, this._resetStyleCache();
  }
  getFirstColumnStyle() {
    return this.firstColumnStyle;
  }
  setFirstColumnStyle(e) {
    this.firstColumnStyle = e, this._resetStyleCache();
  }
  getSecondColumnStyle() {
    return this.secondColumnStyle;
  }
  setSecondColumnStyle(e) {
    this.secondColumnStyle = e, this._resetStyleCache();
  }
  getLastColumnStyle() {
    return this.lastColumnStyle;
  }
  setLastColumnStyle(e) {
    this.lastColumnStyle = e, this._resetStyleCache();
  }
  getHeaderRowStyle() {
    return this.headerRowStyle;
  }
  setHeaderRowStyle(e) {
    this.headerRowStyle = e, this._resetStyleCache();
  }
  getHeaderColumnStyle() {
    return this.headerColumnStyle;
  }
  setHeaderColumnStyle(e) {
    this.headerColumnStyle = e, this._resetStyleCache();
  }
  getStyle(e, t, s, o, r) {
    let i = 0;
    return s && (i = i | ce.lastRowStyle), o && (i = i | ce.lastColumnStyle), e >= 0 && t >= 0 && (i = i | ce.wholeStyle), e % 2 === 1 && (i = i | (r ? ce.secondRowStyle : ce.firstRowStyle)), e % 2 === 0 && (i = i | (r ? ce.firstRowStyle : ce.secondRowStyle)), e === 0 && (i = i | ce.headerRowStyle), t === 0 && (i = i | ce.headerColumnStyle), t % 2 === 1 && (i = i | ce.firstColumnStyle), t % 2 === 0 && (i = i | ce.secondColumnStyle), i === 0 ? null : this._getMergeStyle(i);
  }
  _getMergeStyle(e) {
    let t = this._mergeCacheMap.get(e);
    return t || (t = this._mergeStyle(e), this._mergeCacheMap.set(e, t)), t;
  }
  _mergeStyle(e) {
    const t = [];
    return this.wholeStyle && e & ce.wholeStyle && t.push(this.wholeStyle), this.firstColumnStyle && e & ce.firstColumnStyle && t.push(this.firstColumnStyle), this.secondColumnStyle && e & ce.secondColumnStyle && t.push(this.secondColumnStyle), this.firstRowStyle && e & ce.firstRowStyle && t.push(this.firstRowStyle), this.secondRowStyle && e & ce.secondRowStyle && t.push(this.secondRowStyle), this.headerColumnStyle && e & ce.headerColumnStyle && t.push(this.headerColumnStyle), this.lastColumnStyle && e & ce.lastColumnStyle && t.push(this.lastColumnStyle), this.headerRowStyle && e & ce.headerRowStyle && t.push(this.headerRowStyle), this.lastRowStyle && e & ce.lastRowStyle && t.push(this.lastRowStyle), Ia(t);
  }
  _resetStyleCache() {
    this._mergeCacheMap.clear();
  }
  toJson() {
    const e = {
      name: this._name
    };
    return this.wholeStyle && (e.wholeStyle = ge(this.wholeStyle)), this.headerRowStyle && (e.headerRowStyle = ge(this.headerRowStyle)), this.headerColumnStyle && (e.headerColumnStyle = ge(this.headerColumnStyle)), this.firstRowStyle && (e.firstRowStyle = ge(this.firstRowStyle)), this.secondRowStyle && (e.secondRowStyle = ge(this.secondRowStyle)), this.lastRowStyle && (e.lastRowStyle = ge(this.lastRowStyle)), this.firstColumnStyle && (e.firstColumnStyle = ge(this.firstColumnStyle)), this.secondColumnStyle && (e.secondColumnStyle = ge(this.secondColumnStyle)), this.lastColumnStyle && (e.lastColumnStyle = ge(this.lastColumnStyle)), e;
  }
  fromJson(e) {
    this._name = e.name, e.wholeStyle && (this.wholeStyle = ge(e.wholeStyle)), e.headerRowStyle && (this.headerRowStyle = ge(e.headerRowStyle)), e.headerColumnStyle && (this.headerColumnStyle = ge(e.headerColumnStyle)), e.firstRowStyle && (this.firstRowStyle = ge(e.firstRowStyle)), e.secondRowStyle && (this.secondRowStyle = ge(e.secondRowStyle)), e.lastRowStyle && (this.lastRowStyle = ge(e.lastRowStyle)), e.firstColumnStyle && (this.firstColumnStyle = ge(e.firstColumnStyle)), e.secondColumnStyle && (this.secondColumnStyle = ge(e.secondColumnStyle)), e.lastColumnStyle && (this.lastColumnStyle = ge(e.lastColumnStyle));
  }
  dispose() {
    this._mergeCacheMap.clear();
  }
}
const va = (n, e, t) => new Rt(`light-${n}`, {
  headerRowStyle: {
    bg: {
      rgb: e
    }
  },
  firstColumnStyle: {
    bg: {
      rgb: "rgb(255, 255, 255)"
    }
  },
  secondColumnStyle: {
    bg: {
      rgb: t
    }
  },
  lastRowStyle: {
    bg: {
      rgb: e
    }
  }
}), Ma = (n, e, t) => new Rt(`middle-${n}`, {
  headerRowStyle: {
    bg: {
      rgb: e
    }
  },
  headerColumnStyle: {
    bg: {
      rgb: t
    }
  },
  secondRowStyle: {
    bg: {
      rgb: t
    }
  },
  lastRowStyle: {
    bg: {
      rgb: e
    }
  },
  lastColumnStyle: {
    bg: {
      rgb: t
    }
  }
}), _a = (n, e, t, s) => new Rt(`dark-${n}`, {
  headerRowStyle: {
    bg: {
      rgb: e
    },
    cl: {
      rgb: "rgb(255, 255, 255)"
    },
    ht: xs.CENTER,
    bl: te.TRUE
  },
  firstRowStyle: {
    bg: {
      rgb: t
    }
  },
  secondRowStyle: {
    bg: {
      rgb: s
    }
  },
  lastRowStyle: {
    bg: {
      rgb: e
    }
  }
}), ya = [
  {
    baseName: "blue",
    header: "rgb(164, 202, 254)",
    color: "rgb(225, 239, 254)"
  },
  {
    baseName: "grey",
    header: "rgb(205, 208, 216)",
    color: "rgb(238, 239, 241)"
  },
  {
    baseName: "red",
    header: "rgb(248, 180, 180)",
    color: "rgb(253, 232, 232)"
  },
  {
    baseName: "orange",
    header: "rgb(253, 186, 140)",
    color: "rgb(254, 236, 220)"
  },
  {
    baseName: "yellow",
    header: "rgb(250, 200, 21)",
    color: "rgb(255, 244, 185)"
  },
  {
    baseName: "green",
    header: "rgb(132, 225, 188)",
    color: "rgb(222, 247, 236)"
  },
  {
    baseName: "azure",
    header: "rgb(126, 220, 226)",
    color: "rgb(213, 245, 246)"
  },
  {
    baseName: "indigo",
    header: "rgb(186, 198, 248)",
    color: "rgb(233, 237, 255)"
  },
  {
    baseName: "purple",
    header: "rgb(202, 191, 253)",
    color: "rgb(237, 235, 254)"
  },
  {
    baseName: "magenta",
    header: "rgb(248, 180, 217)",
    color: "rgb(252, 232, 243)"
  }
], ba = [
  {
    baseName: "blue",
    rowHeader: "rgb(63, 131, 248)",
    colHeader: "rgb(195, 221, 253)"
  },
  {
    baseName: "grey",
    rowHeader: "rgb(95, 101, 116)",
    colHeader: "rgb(227, 229, 234)"
  },
  {
    baseName: "red",
    rowHeader: "rgb(240, 82, 82)",
    colHeader: "rgb(251, 213, 213)"
  },
  {
    baseName: "orange",
    rowHeader: "rgb(255, 90, 31)",
    colHeader: "rgb(252, 217, 189)"
  },
  {
    baseName: "yellow",
    rowHeader: "rgb(212, 157, 15)",
    colHeader: "rgb(252, 220, 106)"
  },
  {
    baseName: "green",
    rowHeader: "rgb(13, 164, 113)",
    colHeader: "rgb(188, 240, 218)"
  },
  {
    baseName: "azure",
    rowHeader: "rgb(6, 148, 162)",
    colHeader: "rgb(175, 236, 239)"
  },
  {
    baseName: "indigo",
    rowHeader: "rgb(70, 106, 247)",
    colHeader: "rgb(210, 218, 250)"
  },
  {
    baseName: "purple",
    rowHeader: "rgb(144, 97, 249)",
    colHeader: "rgb(220, 215, 254)"
  },
  {
    baseName: "magenta",
    rowHeader: "rgb(231, 70, 148)",
    colHeader: "rgb(250, 209, 232)"
  }
], Ea = [
  {
    baseName: "blue",
    rowHeader: "rgb(30, 66, 159)",
    firstRow: "rgb(195, 221, 253)",
    secondRow: "rgb(118, 169, 250)"
  },
  {
    baseName: "grey",
    rowHeader: "rgb(44, 48, 64)",
    firstRow: "rgb(227, 229, 234)",
    secondRow: "rgb(151, 157, 172)"
  },
  {
    baseName: "red",
    rowHeader: "rgb(155, 28, 28)",
    firstRow: "rgb(251, 213, 213)",
    secondRow: "rgb(249, 128, 128)"
  },
  {
    baseName: "orange",
    rowHeader: "rgb(180, 52, 3)",
    firstRow: "rgb(252, 217, 189)",
    secondRow: "rgb(255, 138, 76)"
  },
  {
    baseName: "yellow",
    rowHeader: "rgb(154, 109, 21)",
    firstRow: "rgb(252, 220, 106)",
    secondRow: "rgb(212, 157, 15)"
  },
  {
    baseName: "green",
    rowHeader: "rgb(4, 108, 78)",
    firstRow: "rgb(188, 240, 218)",
    secondRow: "rgb(49, 196, 141)"
  },
  {
    baseName: "azure",
    rowHeader: "rgb(3, 102, 114)",
    firstRow: "rgb(175, 236, 239)",
    secondRow: "rgb(22, 189, 202)"
  },
  {
    baseName: "indigo",
    rowHeader: "rgb(16, 51, 191)",
    firstRow: "rgb(210, 218, 250)",
    secondRow: "rgb(98, 128, 249)"
  },
  {
    baseName: "purple",
    rowHeader: "rgb(74, 29, 150)",
    firstRow: "rgb(220, 215, 254)",
    secondRow: "rgb(172, 148, 250)"
  },
  {
    baseName: "magenta",
    rowHeader: "rgb(153, 21, 75)",
    firstRow: "rgb(250, 209, 232)",
    secondRow: "rgb(241, 126, 184)"
  }
], ka = ya.map(({ baseName: n, header: e, color: t }) => va(n, e, t)), Ua = ba.map(({ baseName: n, rowHeader: e, colHeader: t }) => Ma(n, e, t)), Ta = Ea.map(({ baseName: n, rowHeader: e, firstRow: t, secondRow: s }) => _a(n, e, t, s)), Pa = [
  ...ka,
  ...Ua,
  ...Ta
], qo = {
  headerRowStyle: {
    bg: {
      rgb: "rgb(68,114,196)"
    },
    cl: {
      rgb: "rgb(255,255,255)"
    },
    ht: xs.CENTER,
    bl: te.TRUE
  },
  firstRowStyle: {
    bg: {
      rgb: "rgb(217,225,242)"
    }
  }
}, Na = new Rt("default", qo), Oa = new Rt("default-last-row", {
  ...qo,
  lastRowStyle: {
    bd: {
      t: {
        s: Ao.THIN,
        cl: {
          rgb: "rgb(68,114,196)"
        }
      }
    },
    ht: xs.CENTER,
    bl: te.TRUE
  }
});
class Da {
  constructor() {
    R(this, "_toggleRanges", []);
  }
  /**
   * Refresh the cache based on the given range and visibility function.
   * This method calculates toggle ranges for rows that are visible within the specified range.
   * Hidden rows are excluded from the toggle calculation.
   * @param range The range of rows to refresh (startRow and endRow are required).
   * @param visibleFunc A function to determine if a row is visible.
   */
  refresh(e, t) {
    const { startRow: s, endRow: o } = e, r = [];
    let i = 0, a = !1, u = -1;
    for (let l = s; l <= o; l++) {
      if (!t(l)) {
        i++, i % 2 === 1 ? a = !0 : (a = !1, u !== -1 && (r.push([u, l - 1]), u = -1));
        continue;
      }
      i % 2 === 1 ? a ? u === -1 && (u = l) : (a = !0, u = l) : a && (r.push([u, l - 2]), a = !1, u = -1), l === o && a && r.push([u, l]);
    }
    this._toggleRanges = r;
  }
  /**
   * This function returns the toggle ranges. Only for testing purposes. In production, you should use `getIsToggled` to check if a row is toggled.
   * @returns [IToggleRange[]] The toggle ranges calculated by the last refresh.
   */
  getToggleRanges() {
    return this._toggleRanges.concat();
  }
  /**
   * Check if the given row is toggled (odd/even state).
   * This method uses binary search to efficiently determine if the row is within a toggle range.
   * @param row The row to check.
   * @returns True if the row is toggled (odd), false otherwise (even or hidden).
   */
  getIsToggled(e) {
    let t = 0, s = this._toggleRanges.length - 1;
    for (; t <= s; ) {
      const o = Math.floor((t + s) / 2), [r, i] = this._toggleRanges[o];
      if (e < r)
        s = o - 1;
      else if (e > i)
        t = o + 1;
      else
        return !0;
    }
    return !1;
  }
}
var Aa = Object.getOwnPropertyDescriptor, xa = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? Aa(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, Ss = (n, e) => (t, s) => e(t, s, n);
const $a = "SHEET_RANGE_THEME_MODEL_PLUGIN";
let ve = class extends ue {
  constructor(e, t, s) {
    super();
    R(this, "_rangeThemeStyleMap", /* @__PURE__ */ new Map());
    R(this, "_rangeThemeStyleRuleMap", /* @__PURE__ */ new Map());
    R(this, "_rTreeCollection", /* @__PURE__ */ new Map());
    R(this, "_defaultRangeThemeMap", /* @__PURE__ */ new Map());
    /**
     * This map is used to cache zebra crossing toggle ranges for each unitId and subUnitId, IRangeThemeStyleRule id
     */
    R(this, "_zebraCrossingCacheMap", /* @__PURE__ */ new Map());
    R(this, "_rowVisibleFuncSet", /* @__PURE__ */ new Map());
    R(this, "_rangeThemeMapChanged$", new De());
    R(this, "rangeThemeMapChange$", this._rangeThemeMapChanged$.asObservable());
    this._sheetInterceptorService = e, this._resourceManagerService = t, this._univerInstanceService = s, this._registerIntercept(), this._initSnapshot(), this._initDefaultTheme();
  }
  _initDefaultTheme() {
    this.registerDefaultRangeTheme(Na), this.registerDefaultRangeTheme(Oa);
    for (const e of Pa)
      this.registerDefaultRangeTheme(e);
  }
  _ensureRangeThemeStyleMap(e) {
    return this._rangeThemeStyleMap.has(e) || this._rangeThemeStyleMap.set(e, /* @__PURE__ */ new Map()), this._rangeThemeStyleMap.get(e);
  }
  _ensureRangeThemeStyleRuleMap(e) {
    return this._rangeThemeStyleRuleMap.has(e) || this._rangeThemeStyleRuleMap.set(e, /* @__PURE__ */ new Map()), this._rangeThemeStyleRuleMap.get(e);
  }
  _ensureRTreeCollection(e) {
    return this._rTreeCollection.has(e) || this._rTreeCollection.set(e, new yi()), this._rTreeCollection.get(e);
  }
  getDefaultRangeThemeStyle(e) {
    return this._defaultRangeThemeMap.get(e);
  }
  getCustomRangeThemeStyle(e, t) {
    return this._ensureRangeThemeStyleMap(e).get(t);
  }
  _getSheetRowVisibleFuncSet(e, t) {
    this._rowVisibleFuncSet.has(e) || this._rowVisibleFuncSet.set(e, /* @__PURE__ */ new Map());
    const s = this._rowVisibleFuncSet.get(e);
    return s.has(t) || s.set(t, /* @__PURE__ */ new Set()), s.get(t);
  }
  _getSheetRowVisibleHasInit(e, t) {
    var s;
    return !!(this._rowVisibleFuncSet.has(e) && ((s = this._rowVisibleFuncSet.get(e)) != null && s.has(t)));
  }
  refreshSheetRowVisibleFuncSet(e, t) {
    const s = this._getSheetRowVisibleFuncSet(e, t);
    s.clear();
    const o = this._univerInstanceService.getUnit(e);
    if (o) {
      const r = o.getSheetBySheetId(t);
      if (r) {
        const i = r.getRowCount(), a = r.getRowManager();
        for (let u = 1; u <= i; u++)
          r.getRowVisible(u) ? a.getRowHeight(u) === 0 && s.add(u) : s.add(u);
      }
    }
  }
  _ensureZebraCrossingCache(e, t, s) {
    this._zebraCrossingCacheMap.has(e) || this._zebraCrossingCacheMap.set(e, /* @__PURE__ */ new Map());
    const o = this._zebraCrossingCacheMap.get(e);
    o.has(t) || o.set(t, /* @__PURE__ */ new Map());
    const r = o.get(t);
    return r.has(s) || r.set(s, new Da()), r.get(s);
  }
  /**
   * Register range theme styles
   * @param {string} themeName
   * @param {IRangeThemeRangeInfo} rangeInfo
   */
  registerRangeThemeRule(e, t) {
    const { unitId: s, subUnitId: o, range: r } = t, i = kt(), a = this._ensureRangeThemeStyleRuleMap(s), u = this._ensureRTreeCollection(s);
    a.set(i, { rangeInfo: t, themeName: e }), u.insert({ unitId: s, sheetId: o, range: r, id: i }), this._getSheetRowVisibleHasInit(s, o) || this.refreshSheetRowVisibleFuncSet(s, o);
    const l = this._ensureZebraCrossingCache(s, o, i), c = this._getSheetRowVisibleFuncSet(s, o);
    l.refresh(r, (d) => !c.has(d));
  }
  getRegisteredRangeThemeStyle(e) {
    const { unitId: t, subUnitId: s, range: o } = e, r = this._ensureRTreeCollection(t), i = Array.from(r.bulkSearch([{ unitId: t, sheetId: s, range: o }]));
    if (i[0]) {
      const u = this._ensureRangeThemeStyleRuleMap(t).get(i[0]);
      if (u)
        return u.themeName;
    }
  }
  refreshZebraCrossingCacheBySheet(e, t) {
    this._zebraCrossingCacheMap.has(e) || this._zebraCrossingCacheMap.set(e, /* @__PURE__ */ new Map());
    const s = this._zebraCrossingCacheMap.get(e);
    s.has(t) || s.set(t, /* @__PURE__ */ new Map());
    const o = s.get(t);
    o && o.forEach((r, i) => {
      const u = this._ensureRangeThemeStyleRuleMap(e).get(i);
      u ? r.refresh(u.rangeInfo.range, (l) => !this._getSheetRowVisibleFuncSet(e, t).has(l)) : o.delete(i);
    });
  }
  removeRangeThemeRule(e, t) {
    const { unitId: s, subUnitId: o, range: r } = t, i = this._ensureRTreeCollection(s), a = Array.from(i.bulkSearch([{ unitId: s, sheetId: o, range: r }])), u = this._ensureRangeThemeStyleRuleMap(s);
    for (let l = 0; l < a.length; l++) {
      const c = u.get(a[l]);
      if (c && c.themeName === e) {
        u.delete(a[l]), i.remove({ unitId: s, sheetId: o, range: r, id: a[l] });
        const d = this._zebraCrossingCacheMap.get(s);
        if (d) {
          const h = d.get(o);
          h && h.delete(a[l]);
        }
        break;
      }
    }
  }
  registerDefaultRangeTheme(e) {
    this._defaultRangeThemeMap.set(e.getName(), e), this._rangeThemeMapChanged$.next({ type: "add", styleName: e.getName() });
  }
  unRegisterDefaultRangeTheme(e) {
    this._defaultRangeThemeMap.delete(e), this._rangeThemeMapChanged$.next({ type: "remove", styleName: e });
  }
  getRegisteredRangeThemes() {
    return Array.from(this._defaultRangeThemeMap.keys());
  }
  /**
   * Register custom range theme style.
   * @param {string} unitId The unit id.
   * @param {RangeThemeStyle} rangeThemeStyle The range theme style.
   */
  registerRangeThemeStyle(e, t) {
    this._ensureRangeThemeStyleMap(e).set(t.getName(), t), this._rangeThemeMapChanged$.next({ type: "add", styleName: t.getName() });
  }
  /**
   *  Unregister custom range theme style.
   * @param {string} unitId The unit id.
   * @param {string} name The name of the range theme style.
   */
  unregisterRangeThemeStyle(e, t) {
    this._ensureRangeThemeStyleMap(e).delete(t), this._rangeThemeMapChanged$.next({ type: "remove", styleName: t });
  }
  /**
   * Gets all custom register themes
   * @param {string} unitId Which unit to register the range theme style.
   * @return {string[]} The array of all custom registered themes.
   */
  getALLRegisteredTheme(e) {
    return Array.from(this._ensureRangeThemeStyleMap(e).keys());
  }
  getRangeThemeStyle(e, t) {
    return this._defaultRangeThemeMap.has(t) ? this._defaultRangeThemeMap.get(t) : this._ensureRangeThemeStyleMap(e).get(t);
  }
  getCellStyle(e, t, s, o) {
    const r = { startRow: s, startColumn: o, endRow: s, endColumn: o }, i = this._ensureRTreeCollection(e), a = Array.from(i.bulkSearch([{ unitId: e, sheetId: t, range: r }]));
    if (a[0]) {
      const l = this._ensureRangeThemeStyleRuleMap(e).get(a[0]);
      if (l) {
        const { rangeInfo: c, themeName: d } = l, h = s - c.range.startRow, g = o - c.range.startColumn, m = this.getRangeThemeStyle(e, d), C = this._ensureZebraCrossingCache(e, t, a[0]).getIsToggled(s);
        if (m)
          return m.getStyle(h, g, s === c.range.endRow, o === c.range.endColumn, C);
      }
    }
  }
  _registerIntercept() {
    this.disposeWithMe(this._sheetInterceptorService.intercept(ht.CELL_CONTENT, {
      id: Jo,
      effect: he.Style,
      handler: (e, t, s) => {
        const { row: o, col: r, unitId: i, subUnitId: a } = t, u = this.getCellStyle(i, a, o, r);
        if (u) {
          const l = !e || e === t.rawData ? { ...t.rawData } : e;
          return l.themeStyle = u, s(l);
        }
        return s(e);
      }
    }));
  }
  toJson(e) {
    const t = this._ensureRangeThemeStyleRuleMap(e), s = this._ensureRangeThemeStyleMap(e);
    if (s.size === 0 && t.size === 0)
      return "{}";
    const o = {};
    t.forEach((i, a) => {
      o[a] = i;
    });
    const r = {};
    return s.forEach((i, a) => {
      r[a] = i.toJson();
    }), JSON.stringify({
      rangeThemeStyleRuleMap: o,
      rangeThemeStyleMapJson: r
    });
  }
  fromJSON(e, t) {
    const { rangeThemeStyleRuleMap: s, rangeThemeStyleMapJson: o } = t;
    s && Object.keys(s).forEach((r) => {
      const i = s[r], { themeName: a, rangeInfo: u } = i;
      a.startsWith("table") || (this.registerRangeThemeRule(a, u), this._ensureRTreeCollection(u.unitId).insert({ unitId: r, sheetId: u.subUnitId, range: u.range, id: r }));
    }), o && Object.keys(o).forEach((r) => {
      const i = o[r], a = new Rt(i.name);
      a.fromJson(i), this._ensureRangeThemeStyleMap(e).set(a.getName(), a);
    });
  }
  deleteUnitId(e) {
    this._rangeThemeStyleMap.delete(e), this._rangeThemeStyleRuleMap.delete(e), this._rTreeCollection.delete(e);
  }
  _initSnapshot() {
    this.disposeWithMe(this._resourceManagerService.registerPluginResource({
      toJson: (e) => this.toJson(e),
      parseJson: (e) => {
        if (!e)
          return {};
        try {
          return JSON.parse(e);
        } catch {
          return {};
        }
      },
      businesses: [B.UNIVER_SHEET],
      pluginName: $a,
      onLoad: (e, t) => {
        this.fromJSON(e, t);
      },
      onUnLoad: (e) => {
        this.deleteUnitId(e);
      }
    }));
  }
  dispose() {
    super.dispose(), this._rangeThemeStyleMap.clear(), this._rangeThemeStyleRuleMap.clear(), this._defaultRangeThemeMap.clear(), this._rTreeCollection.clear(), this._zebraCrossingCacheMap.clear(), this._rowVisibleFuncSet.clear();
  }
};
ve = xa([
  Ss(0, $(G)),
  Ss(1, $(Rn)),
  Ss(2, $(M))
], ve);
function Yo(n, e) {
  const { unitId: t } = e, s = t ? n.getUnit(t, B.UNIVER_SHEET) : n.getCurrentUnitOfType(B.UNIVER_SHEET);
  return s ? {
    workbook: s,
    unitId: s.getUnitId()
  } : null;
}
function P(n, e = {}) {
  const { unitId: t, subUnitId: s } = e, o = t ? n.getUnit(t, B.UNIVER_SHEET) : n.getCurrentUnitOfType(B.UNIVER_SHEET);
  if (!o) return null;
  const r = s ? o.getSheetBySheetId(s) : o.getActiveSheet(!0);
  return r ? {
    worksheet: r,
    workbook: o,
    unitId: o.getUnitId(),
    subUnitId: r.getSheetId()
  } : null;
}
function Qe(n, e) {
  const { unitId: t, subUnitId: s } = e, o = n.getUnit(t, B.UNIVER_SHEET);
  if (!o) return null;
  const r = o.getSheetBySheetId(s);
  return r ? {
    worksheet: r,
    workbook: o
  } : null;
}
const tn = {
  id: "sheet.mutation.set-worksheet-range-theme-style",
  type: v.MUTATION,
  handler: (n, e) => {
    const { unitId: t, subUnitId: s, range: o, themeName: r } = e, i = n.get(M), a = P(i), u = n.get(ve);
    return a ? (u.registerRangeThemeRule(r, { range: o, unitId: t, subUnitId: s }), !0) : !1;
  }
}, Wa = (n, e) => {
  const t = Qe(n.get(M), e);
  if (!t)
    throw new Error("[SetWorksheetRangeThemeStyleMutation]: worksheet is null error!");
  const { worksheet: s } = t;
  return {
    unitId: e.unitId,
    subUnitId: s.getSheetId(),
    range: e.range,
    themeName: e.themeName
  };
}, nn = {
  id: "sheet.mutation.remove-worksheet-range-theme-style",
  type: v.MUTATION,
  handler: (n, e) => {
    const { unitId: t, subUnitId: s, range: o, themeName: r } = e, i = n.get(M), a = P(i), u = n.get(ve);
    return a ? (u.removeRangeThemeRule(r, { range: o, unitId: t, subUnitId: s }), !0) : !1;
  }
}, Va = (n, e) => {
  const t = Qe(n.get(M), e);
  if (!t)
    throw new Error("[DeleteWorksheetRangeThemeStyleMutationFactory]: worksheet is null error!");
  const { worksheet: s } = t;
  return {
    unitId: e.unitId,
    subUnitId: s.getSheetId(),
    range: e.range,
    themeName: e.themeName
  };
}, Ws = (n, e) => {
  if (n.get(M).getUniverSheetInstance(e.unitId) == null)
    throw new Error("universheet is null error!");
  return {
    unitId: e.unitId,
    subUnitId: e.subUnitId,
    range: e.range
  };
}, ke = {
  id: "sheet.mutation.insert-row",
  type: v.MUTATION,
  handler: (n, e) => {
    var m;
    const { unitId: t, subUnitId: s, range: o, rowInfo: r } = e, a = n.get(M).getUniverSheetInstance(t);
    if (a == null)
      throw new Error("universheet is null error!");
    const u = a.getSheetBySheetId(s);
    if (u == null)
      throw new Error("worksheet is null error!");
    const l = u.getRowManager().getRowData(), c = {
      h: u.getConfig().defaultRowHeight,
      hd: 0
    }, d = o.startRow, h = o.endRow - o.startRow + 1;
    for (let f = d; f < d + h; f++)
      r ? Pn(f, (m = r[f - o.startRow]) != null ? m : c, l) : Pn(f, c, l);
    return u.setRowCount(u.getRowCount() + h), u.getCellMatrix().insertRows(o.startRow, h), !0;
  }
}, as = (n, e) => {
  if (n.get(M).getUniverSheetInstance(e.unitId) == null)
    throw new Error("universheet is null error!");
  return {
    unitId: e.unitId,
    subUnitId: e.subUnitId,
    range: e.range
  };
}, Ue = {
  id: "sheet.mutation.insert-col",
  type: v.MUTATION,
  handler: (n, e) => {
    var m;
    const s = n.get(M).getUniverSheetInstance(e.unitId);
    if (s == null)
      throw new Error("universheet is null error!");
    const o = s.getSheetBySheetId(e.subUnitId);
    if (!o) return !1;
    const r = o.getColumnManager(), { range: i, colInfo: a } = e, l = r.getColumnData(), c = i.startColumn, d = i.endColumn - i.startColumn + 1, h = o.getConfig().defaultColumnWidth;
    for (let f = c; f < c + d; f++) {
      const C = {
        w: h,
        hd: 0
      };
      a ? Pn(f, (m = a[f - i.startColumn]) != null ? m : C, l) : Pn(f, C, l);
    }
    return o.setColumnCount(o.getColumnCount() + i.endColumn - i.startColumn + 1), o.getCellMatrix().insertColumns(i.startColumn, d), !0;
  }
}, wt = {
  id: "sheet.mutation.move-range",
  type: v.MUTATION,
  handler: (n, e) => {
    const { from: t, to: s } = e;
    if (!t || !s)
      return !1;
    const r = n.get(M).getCurrentUnitForType(B.UNIVER_SHEET);
    if (!r)
      return !1;
    const i = r.getSheetBySheetId(e.from.subUnitId), a = r.getSheetBySheetId(e.to.subUnitId);
    if (!i || !a)
      return !1;
    const u = i.getCellMatrix(), l = a.getCellMatrix();
    return new Y(t.value).forValue((c, d, h) => {
      h == null ? u.realDeleteValue(c, d) : u.setValue(c, d, h);
    }), new Y(s.value).forValue((c, d, h) => {
      h == null ? l.realDeleteValue(c, d) : l.setValue(c, d, h);
    }), !0;
  }
};
function La(n, e) {
  const { unitId: t, subUnitId: s, sourceRange: o, targetRange: r } = e, i = o.startRow > r.startRow, a = o.endRow - o.startRow + 1;
  return i ? {
    unitId: t,
    subUnitId: s,
    sourceRange: O.clone(r),
    targetRange: {
      ...o,
      endRow: o.endRow + a,
      startRow: o.startRow + a
    }
  } : {
    unitId: t,
    subUnitId: s,
    targetRange: O.clone(o),
    sourceRange: {
      ...r,
      endRow: r.endRow - a,
      startRow: r.startRow - a
    }
  };
}
const Je = {
  id: "sheet.mutation.move-rows",
  type: v.MUTATION,
  handler: (n, e) => {
    const { unitId: t, subUnitId: s, sourceRange: o, targetRange: r } = e, a = n.get(M).getUniverSheetInstance(t);
    if (!a)
      throw new Error("[MoveRowMutation] univerSheet is null!");
    const u = a.getSheetBySheetId(s);
    if (!u)
      throw new Error("[MoveRowMutation] worksheet is null!");
    const l = o.startRow, c = o.endRow - o.startRow + 1, d = r.startRow, h = u.getRowManager().getRowData();
    return xo(l, c, d, h), u.getCellMatrix().moveRows(l, c, d), !0;
  }
};
function Ha(n, e) {
  const { unitId: t, subUnitId: s, sourceRange: o, targetRange: r } = e, i = o.startColumn > r.startColumn, a = o.endColumn - o.startColumn + 1;
  return i ? {
    unitId: t,
    subUnitId: s,
    sourceRange: O.clone(r),
    targetRange: {
      ...o,
      endColumn: o.endColumn + a,
      startColumn: o.startColumn + a
    }
  } : {
    unitId: t,
    subUnitId: s,
    targetRange: O.clone(o),
    sourceRange: {
      ...r,
      startColumn: r.startColumn - a,
      endColumn: r.endColumn - a
    }
  };
}
const qe = {
  id: "sheet.mutation.move-columns",
  type: v.MUTATION,
  handler: (n, e) => {
    const { unitId: t, subUnitId: s, sourceRange: o, targetRange: r } = e, a = n.get(M).getUniverSheetInstance(t);
    if (!a)
      throw new Error("[MoveColumnMutation] univerSheet is null!");
    const u = a.getSheetBySheetId(s);
    if (!u)
      throw new Error("[MoveColumnMutation] worksheet is null!");
    const l = o.startColumn, c = o.endColumn - o.startColumn + 1, d = r.startColumn, h = u.getColumnManager().getColumnData();
    return xo(l, c, d, h), u.getCellMatrix().moveColumns(l, c, d), !0;
  }
}, Fa = (n, e) => {
  const o = e.getRowManager().getRowData(), r = {}, i = n.range, a = $o(i.startRow, i.endRow, o), u = Wo(r, a);
  return {
    unitId: n.unitId,
    subUnitId: n.subUnitId,
    range: n.range,
    rowInfo: u
  };
}, Te = {
  id: "sheet.mutation.remove-rows",
  type: v.MUTATION,
  handler: (n, e) => {
    const s = n.get(M).getUniverSheetInstance(e.unitId);
    if (s == null)
      throw new Error("universheet is null error!");
    const o = s.getSheetBySheetId(e.subUnitId);
    if (!o) return !1;
    const r = e.range, a = o.getRowManager().getRowData();
    for (let c = r.startRow; c <= r.endRow; c++)
      o.getRowFiltered(c);
    const u = r.endRow - r.startRow + 1;
    return Vo(r.startRow, u, a), o.getCellMatrix().removeRows(r.startRow, u), o.setRowCount(o.getRowCount() - u), !0;
  }
}, Ba = (n, e) => {
  const s = n.get(M).getUniverSheetInstance(e.unitId);
  if (s == null)
    throw new Error("universheet is null error!");
  const o = s.getSheetBySheetId(e.subUnitId);
  if (o == null)
    throw new Error("worksheet is null error!");
  const a = o.getColumnManager().getColumnData(), u = {}, l = e.range, c = $o(l.startColumn, l.endColumn, a), d = Wo(u, c);
  return {
    unitId: e.unitId,
    subUnitId: e.subUnitId,
    range: e.range,
    colInfo: d
  };
}, Me = {
  id: "sheet.mutation.remove-col",
  type: v.MUTATION,
  handler: (n, e) => {
    const s = n.get(M).getUniverSheetInstance(e.unitId);
    if (s == null)
      throw new Error("universheet is null error!");
    const o = s.getSheetBySheetId(e.subUnitId);
    if (!o) return !1;
    const r = e.range, a = o.getColumnManager().getColumnData(), u = r.endColumn - r.startColumn + 1;
    return Vo(r.startColumn, u, a), o.setColumnCount(o.getColumnCount() - u), o.getCellMatrix().removeColumns(r.startColumn, u), !0;
  }
}, ye = (n, e) => {
  const s = n.get(M).getUniverSheetInstance(e.unitId);
  if (s == null)
    throw new Error("universheet is null error!");
  const o = s.getSheetBySheetId(e.subUnitId);
  if (o == null)
    throw new Error("worksheet is null error!");
  const i = o.getConfig().mergeData, a = e.ranges, u = [];
  for (let l = 0; l < a.length; l++)
    for (let c = i.length - 1; c >= 0; c--) {
      const d = i[c], h = a[l];
      O.intersects(d, h) && u.push(i[c]);
    }
  return {
    unitId: e.unitId,
    subUnitId: e.subUnitId,
    ranges: u
  };
}, se = {
  id: "sheet.mutation.remove-worksheet-merge",
  type: v.MUTATION,
  handler: (n, e) => {
    const s = n.get(M).getUniverSheetInstance(e.unitId);
    if (s == null)
      throw new Error("universheet is null error!");
    const o = s.getSheetBySheetId(e.subUnitId);
    if (!o) return !1;
    const i = o.getConfig().mergeData, a = e.ranges;
    for (let u = 0; u < a.length; u++)
      for (let l = i.length - 1; l >= 0; l--) {
        const c = i[l], d = a[u];
        O.intersects(c, d) && i.splice(l, 1);
      }
    return o.getSpanModel().rebuild(i), !0;
  }
}, ja = (n) => {
  const { order: e } = n, t = {};
  return Object.keys(e).forEach((s) => {
    t[e[Number(s)]] = Number(s);
  }), {
    ...n,
    order: t
  };
}, On = {
  id: "sheet.mutation.reorder-range",
  type: v.MUTATION,
  handler: (n, e) => {
    const { subUnitId: t, unitId: s, range: o, order: r } = e, u = n.get(M).getUnit(s).getSheetBySheetId(t);
    if (!u)
      return !1;
    const l = new Y();
    X.foreach(o, (d, h) => {
      if (r.hasOwnProperty(d)) {
        const g = r[d], m = A.deepClone(u.getCellRaw(g, h));
        l.setValue(d, h, m);
      }
    });
    const c = u.getCellMatrix();
    return l.forValue((d, h, g) => {
      c.setValue(d, h, g);
    }), !0;
  }
};
function za(n, e) {
  if (n == null)
    return n;
  const t = A.deepClone(n);
  if (e == null)
    return t;
  const s = {};
  return "h" in e && (s.h = t.h), "ia" in e && (s.ia = t.ia), "ah" in e && (s.ah = t.ah), "hd" in e && (s.hd = t.hd), "s" in e && (s.s = t.s), "custom" in e && (s.custom = t.custom), s;
}
function Ga(n, e) {
  if (n == null)
    return n;
  const t = A.deepClone(n);
  if (e == null)
    return t;
  const s = {};
  return "w" in e && (s.w = t.w), "hd" in e && (s.hd = t.hd), "s" in e && (s.s = t.s), "custom" in e && (s.custom = t.custom), s;
}
const Ka = (n, e) => {
  const { unitId: t, subUnitId: s, columnData: o } = n, r = {}, i = e.getColumnManager();
  for (const a in o) {
    const u = o[a], l = i.getColumn(Number(a));
    r[a] = Ga(l, u);
  }
  return {
    unitId: t,
    subUnitId: s,
    columnData: r
  };
}, zt = {
  id: "sheet.mutation.set-col-data",
  type: v.MUTATION,
  handler: (n, e) => {
    const { columnData: t } = e, s = n.get(M), o = P(s, e);
    if (!o) return !1;
    const { worksheet: r } = o, i = r.getColumnManager();
    for (const a in t) {
      const u = t[a];
      if (u == null) {
        i.removeColumn(Number(a));
        continue;
      }
      const l = i.getColumnOrCreate(Number(a));
      Object.assign(l, u);
    }
    return !0;
  }
}, Ja = (n, e) => {
  if (n.get(M).getUniverSheetInstance(e.unitId) == null)
    throw new Error("universheet is null error!");
  return {
    unitId: e.unitId,
    subUnitId: e.subUnitId,
    ranges: e.ranges
  };
}, sn = {
  id: "sheet.mutation.set-col-hidden",
  type: v.MUTATION,
  handler: (n, e) => {
    const s = n.get(M).getUniverSheetInstance(e.unitId);
    if (!s)
      return !1;
    const o = s.getSheetBySheetId(e.subUnitId).getColumnManager();
    for (let r = 0; r < e.ranges.length; r++) {
      const i = e.ranges[r];
      for (let a = i.startColumn; a < i.endColumn + 1; a++) {
        const u = o.getColumnOrCreate(a);
        u != null && (u.hd = te.TRUE);
      }
    }
    return !0;
  }
}, qa = (n, e) => {
  if (n.get(M).getUniverSheetInstance(e.unitId) == null)
    throw new Error("universheet is null error!");
  return {
    unitId: e.unitId,
    subUnitId: e.subUnitId,
    ranges: e.ranges
  };
}, on = {
  id: "sheet.mutation.set-col-visible",
  type: v.MUTATION,
  handler: (n, e) => {
    const s = n.get(M).getUniverSheetInstance(e.unitId);
    if (!s)
      return !1;
    const o = s.getSheetBySheetId(e.subUnitId).getColumnManager();
    for (let r = 0; r < e.ranges.length; r++) {
      const i = e.ranges[r];
      for (let a = i.startColumn; a < i.endColumn + 1; a++) {
        const u = o.getColumnOrCreate(a);
        u != null && (u.hd = te.FALSE);
      }
    }
    return !0;
  }
}, Gt = {
  id: "sheet.mutation.set-gridlines-color",
  type: v.MUTATION,
  handler: (n, e) => {
    const t = P(n.get(M), e);
    if (!t) return !1;
    const { worksheet: s } = t, o = s.getConfig();
    return o.gridlinesColor = e.color, !0;
  }
};
function Ya(n, e, t) {
  var i;
  const s = n.getStyleByCell(e);
  s == null && delete e.s, typeof t.s == "string" && (t.s = n.get(t.s));
  const o = kn(s, t.s ? t.s : null);
  o && (A.removeNull(o), Object.entries(o).forEach(([a, u]) => {
    typeof u == "object" && u !== null && Object.keys(u).length === 0 && delete o[a];
  })), A.isEmptyObject(o) ? delete e.s : e.s = n.setValue(o);
  const r = t.v ? `${t.v}\r
` : "";
  !t.p && e.p && (r && r !== ((i = e.p.body) == null ? void 0 : i.dataStream) ? delete e.p : Qa(e.p, t.s ? t.s : null));
}
function Xa(n, e) {
  if (!e || !Object.keys(e).length)
    return n;
  const t = A.deepClone(n != null ? n : {});
  for (const s in e)
    s === "bd" ? t[s] = Za(t[s] || {}, e[s]) : s in t || (t[s] = null);
  return t;
}
function Za(n, e) {
  if (!e || !Object.keys(e).length)
    return n;
  for (const t in e)
    t in n || (n[t] = null);
  return n;
}
function kn(n, e, t = !1) {
  if (e === null) return e;
  if (e === void 0) return n;
  const s = A.deepClone(n) || {};
  for (const o in e)
    t && ["bd", "tr", "td", "ht", "vt", "tb", "pd", "bg"].includes(o) || (o in s && o === "bd" ? s[o] = Object.assign(s[o], e[o]) : s[o] = e[o]);
  return "cl" in s && ("ul" in s && s.ul && (s.ul.cl = s.cl), "ol" in s && s.ol && (s.ol.cl = s.cl), "st" in s && s.st && (s.st.cl = s.cl)), s;
}
function Xo(n, e) {
  return n.some((t) => t.startIndex === e) ? Xo(n, e + 1) : e;
}
function Qa(n, e) {
  var i;
  if (n.body == null)
    return;
  Array.isArray(n.body.textRuns) || (n.body.textRuns = []);
  let t = 0;
  const s = [], o = ((i = n.body) == null ? void 0 : i.paragraphs) || [];
  for (const a of n.body.textRuns) {
    const { st: u, ed: l, ts: c = {} } = a;
    if (t < u) {
      const h = {
        st: t,
        ed: u
      }, g = kn({}, e, !0);
      g && A.removeNull(g), A.isEmptyObject(g) || (h.ts = g), s.push(h);
    }
    const d = kn(c, e, !0);
    d && A.removeNull(d), A.isEmptyObject(d) ? delete a.ts : a.ts = d, s.push(a), t = Xo(o, l);
  }
  const r = n.body.dataStream.endsWith(`\r
`) ? n.body.dataStream.length - 2 : n.body.dataStream.length;
  if (t < r) {
    const a = {
      st: t,
      ed: r
    }, u = kn({}, e, !0);
    u && A.removeNull(u), A.isEmptyObject(u) || (a.ts = u), s.push(a);
  }
  n.body.textRuns = bi(s);
}
function go(n, e) {
  return e.v === void 0 || e.v === null ? e.v : n === re.NUMBER ? Number(e.v) : n === re.BOOLEAN ? eu(e.v) ? 1 : 0 : n === re.STRING || n === re.FORCE_STRING ? `${e.v}` : e.v;
}
function eu(n) {
  if (typeof n == "string") {
    if (n.toUpperCase() === "TRUE")
      return !0;
    if (n.toUpperCase() === "FALSE")
      return !1;
    if (Ei(n)) {
      if (Number(n) === 0)
        return !1;
      if (Number(n) === 1)
        return !0;
    }
  }
  if (typeof n == "number") {
    if (n === 0)
      return !1;
    if (n === 1)
      return !0;
  }
  return typeof n == "boolean" ? n : null;
}
function tu(n) {
  return n == null ? null : (n.f === void 0 && (n.f = null), n.si === void 0 && (n.si = null), n.p === void 0 && (n.p = null), n.v === void 0 && (n.v = null), n.t === void 0 && (n.t = null), n.s === void 0 && (n.s = null), n.custom === void 0 && (n.custom = null), n);
}
const Ae = (n, e) => {
  const { unitId: t, subUnitId: s, cellValue: o } = e, i = n.get(M).getUniverSheetInstance(t);
  if (i == null)
    throw new Error("workbook is null error!");
  const a = i.getSheetBySheetId(s);
  if (a == null)
    throw new Error("worksheet is null error!");
  const u = a.getCellMatrix(), l = i.getStyles(), c = new Y();
  return new Y(o).forValue((h, g, m) => {
    const f = A.deepClone(u == null ? void 0 : u.getValue(h, g)) || {}, C = l.getStyleByCell(f), p = l.getStyleByCell(m);
    f.s = Xa(C, p), c.setValue(h, g, tu(f));
  }), {
    ...e,
    options: {},
    cellValue: c.getMatrix()
  };
}, ee = {
  id: "sheet.mutation.set-range-values",
  type: v.MUTATION,
  handler: (n, e) => {
    const { cellValue: t, subUnitId: s, unitId: o } = e, i = n.get(M).getUnit(o);
    if (!i)
      return !1;
    const a = i.getSheetBySheetId(s);
    if (!a)
      return !1;
    const u = a.getCellMatrix(), l = i.getStyles();
    return new Y(t).forValue((d, h, g) => {
      if (!g)
        u.realDeleteValue(d, h);
      else {
        let m = u.getValue(d, h) || {};
        m = su(g, m, l), A.isEmptyObject(m) ? u.realDeleteValue(d, h) : u.setValue(d, h, m);
      }
    }), !0;
  }
}, nu = /* @__PURE__ */ new Set(["f", "p", "si", "custom", "ref", "xf"]);
function su(n, e, t) {
  const s = ga(t, n, e);
  return Object.keys(n).forEach((o) => {
    const r = o;
    if (nu.has(r)) {
      const i = n[r];
      ou(e, r, i);
    } else r === "v" ? n.v !== void 0 && (e.v = go(s, n)) : r === "s" && Ya(t, e, n);
  }), e.v !== void 0 && (e.t = s, e.v = go(s, e)), e.v === null && (delete e.t, delete e.v), e;
}
function ou(n, e, t) {
  t === void 0 || (t === null ? delete n[e] : n[e] = t);
}
const ru = (n, e) => {
  const { unitId: t, subUnitId: s, rowData: o } = n, r = {}, i = e.getRowManager();
  for (const a in o) {
    const u = o[a], l = i.getRow(Number(a));
    r[a] = za(l, u);
  }
  return {
    unitId: t,
    subUnitId: s,
    rowData: r
  };
}, Kt = {
  id: "sheet.mutation.set-row-data",
  type: v.MUTATION,
  handler: (n, e) => {
    const { rowData: t } = e, s = n.get(M), o = P(s, e);
    if (!o) return !1;
    const { worksheet: r } = o, i = r.getRowManager();
    for (const a in t) {
      const u = t[a];
      if (u == null) {
        i.removeRow(Number(a));
        continue;
      }
      const l = i.getRowOrCreate(Number(a));
      Object.assign(l, u);
    }
    return !0;
  }
}, iu = (n, e) => {
  if (n.get(M).getUniverSheetInstance(e.unitId) == null)
    throw new Error("universheet is null error!");
  return {
    unitId: e.unitId,
    subUnitId: e.subUnitId,
    ranges: e.ranges
  };
}, Ut = {
  id: "sheet.mutation.set-row-visible",
  type: v.MUTATION,
  handler: (n, e) => {
    const s = n.get(M).getUniverSheetInstance(e.unitId);
    if (s == null)
      throw new Error("universheet is null error!");
    const o = s.getSheetBySheetId(e.subUnitId).getRowManager();
    for (let r = 0; r < e.ranges.length; r++) {
      const i = e.ranges[r];
      for (let a = i.startRow; a < i.endRow + 1; a++) {
        const u = o.getRowOrCreate(a);
        u != null && (u.hd = 0);
      }
    }
    return !0;
  }
}, au = (n, e) => {
  if (n.get(M).getUniverSheetInstance(e.unitId) == null)
    throw new Error("universheet is null error!");
  return {
    unitId: e.unitId,
    subUnitId: e.subUnitId,
    ranges: e.ranges
  };
}, Tt = {
  id: "sheet.mutation.set-row-hidden",
  type: v.MUTATION,
  handler: (n, e) => {
    const s = n.get(M).getUniverSheetInstance(e.unitId);
    if (s == null)
      throw new Error("universheet is null error!");
    const o = s.getSheetBySheetId(e.subUnitId).getRowManager();
    for (let r = 0; r < e.ranges.length; r++) {
      const i = e.ranges[r];
      for (let a = i.startRow; a < i.endRow + 1; a++) {
        const u = o.getRowOrCreate(a);
        u != null && (u.hd = 1);
      }
    }
    return !0;
  }
}, Zo = (n, e) => {
  const { unitId: t, subUnitId: s, ranges: o } = n, r = {}, i = e.getColumnManager();
  for (let a = 0; a < o.length; a++) {
    const u = o[a];
    for (let l = u.startColumn; l < u.endColumn + 1; l++)
      r[l] = i.getColumnWidth(l);
  }
  return {
    unitId: t,
    subUnitId: s,
    ranges: o,
    colWidth: r
  };
}, mt = {
  id: "sheet.mutation.set-worksheet-col-width",
  type: v.MUTATION,
  handler: (n, e) => {
    const t = n.get(M), s = P(t, e);
    if (!s) return !1;
    const { worksheet: o } = s, r = o.getColumnManager(), i = e.ranges;
    for (let a = 0; a < i.length; a++) {
      const u = i[a];
      for (let l = u.startColumn; l < u.endColumn + 1; l++)
        o.getColVisible(l) && (typeof e.colWidth == "number" ? r.setColumnWidth(l, e.colWidth) : A.isDefine(e.colWidth[l]) && r.setColumnWidth(l, e.colWidth[l]));
    }
    return !0;
  }
}, uu = (n, e) => {
  const t = Qe(n.get(M), e);
  if (!t)
    throw new Error("[SetWorksheetColumnCountUndoMutationFactory]: worksheet is null error!");
  return {
    unitId: e.unitId,
    subUnitId: e.subUnitId,
    columnCount: t.worksheet.getColumnCount()
  };
}, Jt = {
  id: "sheet.mutation.set-worksheet-column-count",
  type: v.MUTATION,
  handler: (n, e) => {
    const t = n.get(M), s = Qe(t, e);
    return s ? (s.worksheet.setColumnCount(e.columnCount), !0) : !1;
  }
}, qt = {
  id: "sheet.mutation.set-worksheet-default-style",
  type: v.MUTATION,
  handler: (n, e) => {
    const { defaultStyle: t } = e, s = n.get(M), o = P(s);
    if (!o) return !1;
    const { worksheet: r } = o;
    return r ? (r.setDefaultCellStyle(t), !0) : !1;
  }
}, lu = (n, e) => {
  const t = Qe(n.get(M), e);
  if (!t)
    throw new Error("[SetWorksheetDefaultStyleMutationFactory]: worksheet is null error!");
  const { worksheet: s } = t;
  return {
    unitId: e.unitId,
    subUnitId: s.getSheetId(),
    defaultStyle: s.getDefaultCellStyle()
  };
}, cu = (n, e) => {
  const t = Qe(n.get(M), e);
  if (!t)
    throw new Error("[SetWorksheetRowCountUndoMutationFactory]: worksheet is null error!");
  return {
    unitId: e.unitId,
    subUnitId: e.subUnitId,
    rowCount: t.worksheet.getRowCount()
  };
}, Yt = {
  id: "sheet.mutation.set-worksheet-row-count",
  type: v.MUTATION,
  handler: (n, e) => {
    const t = n.get(M), s = Qe(t, e);
    return s ? (s.worksheet.setRowCount(e.rowCount), !0) : !1;
  }
}, Qo = (n, e) => {
  var a, u;
  const { unitId: t, subUnitId: s, ranges: o } = n, r = {}, i = e.getRowManager();
  for (const { startRow: l, endRow: c } of o)
    for (let d = l; d < c + 1; d++)
      r[d] = (u = (a = i.getRow(d)) == null ? void 0 : a.h) != null ? u : e.getConfig().defaultRowHeight;
  return {
    unitId: t,
    subUnitId: s,
    ranges: o,
    rowHeight: r
  };
}, Vs = (n, e) => {
  var a;
  const { unitId: t, subUnitId: s, ranges: o } = n, r = {}, i = e.getRowManager();
  for (const { startRow: u, endRow: l } of o)
    for (let c = u; c <= l; c++)
      r[c] = (a = i.getRow(c)) == null ? void 0 : a.ia;
  return {
    unitId: t,
    subUnitId: s,
    ranges: o,
    autoHeightInfo: r
  };
}, yh = (n, e) => {
  var a, u;
  const { unitId: t, subUnitId: s, rowsAutoHeightInfo: o } = n, r = [], i = e.getRowManager();
  for (const l of o) {
    const { row: c } = l;
    r.push({
      row: c,
      autoHeight: (u = (a = i.getRow(c)) == null ? void 0 : a.ah) != null ? u : e.getConfig().defaultRowHeight
    });
  }
  return {
    unitId: t,
    subUnitId: s,
    rowsAutoHeightInfo: r
  };
}, nt = {
  id: "sheet.mutation.set-worksheet-row-height",
  type: v.MUTATION,
  handler: (n, e) => {
    const { ranges: t, rowHeight: s } = e, o = n.get(M), r = P(o, e);
    if (!r) return !1;
    const { worksheet: i } = r, a = i.getRowManager();
    for (const { startRow: u, endRow: l } of t)
      for (let c = u; c <= l; c++)
        typeof s == "number" ? a.setRowHeight(c, s) : A.isDefine(s[c]) && a.setRowHeight(c, s[c]);
    return !0;
  }
}, Fe = {
  id: "sheet.mutation.set-worksheet-row-is-auto-height",
  type: v.MUTATION,
  handler: (n, e) => {
    var a;
    const { ranges: t, autoHeightInfo: s } = e, o = n.get(M), r = P(o, e);
    if (!r) return !1;
    const i = r.worksheet.getRowManager();
    for (const { startRow: u, endRow: l } of t)
      for (let c = u; c <= l; c++) {
        const d = i.getRowOrCreate(c);
        typeof s == "number" ? d.ia = s : d.ia = (a = s[c]) != null ? a : void 0;
      }
    return !0;
  }
}, er = {
  id: "sheet.mutation.set-worksheet-row-auto-height",
  type: v.MUTATION,
  handler: (n, e) => {
    const { rowsAutoHeightInfo: t } = e, s = n.get(M), o = P(s, e);
    if (!o) return !1;
    const r = o.worksheet.getRowManager();
    for (const { row: i, autoHeight: a } of t) {
      const u = r.getRowOrCreate(i);
      u.ah = a;
    }
    return !0;
  }
}, Xt = {
  id: "sheet.mutation.toggle-gridlines",
  type: v.MUTATION,
  handler: (n, e) => {
    const t = P(n.get(M), e);
    if (!t) return !1;
    const { worksheet: s } = t, o = s.getConfig();
    return o.showGridlines = e.showGridlines, !0;
  }
}, pn = {
  id: "sheet.operation.set-worksheet-active",
  type: v.OPERATION,
  handler: (n, e) => {
    const t = n.get(M).getUniverSheetInstance(e.unitId);
    if (!t) return !1;
    const s = t.getWorksheets();
    for (const [, o] of s)
      if (o.getSheetId() === e.subUnitId)
        return t.setActiveSheet(o), !0;
    return !1;
  }
};
var du = /* @__PURE__ */ ((n) => (n.SET_WORKSHEET_ROW_HEIGHT = "sheet.mutation.set-worksheet-row-height", n.SET_WORKSHEET_ROW_IS_AUTO_HEIGHT = "sheet.mutation.set-worksheet-row-is-auto-height", n.SET_WORKSHEET_ROW_AUTO_HEIGHT = "sheet.mutation.set-worksheet-row-auto-height", n.SET_WORKSHEET_COL_WIDTH = "sheet.mutation.set-worksheet-col-width", n.SET_WORKSHEET_ACTIVE = "sheet.operation.set-worksheet-active", n.MOVE_ROWS = "sheet.mutation.move-rows", n.MOVE_COLUMNS = "sheet.mutation.move-columns", n.SET_COL_HIDDEN = "sheet.mutation.set-col-hidden", n.SET_COL_VISIBLE = "sheet.mutation.set-col-visible", n.SET_ROW_HIDDEN = "sheet.mutation.set-row-hidden", n.SET_ROW_VISIBLE = "sheet.mutation.set-row-visible", n.INSERT_COL = "sheet.mutation.insert-col", n.INSERT_ROW = "sheet.mutation.insert-row", n.REMOVE_COL = "sheet.mutation.remove-col", n.REMOVE_ROW = "sheet.mutation.remove-rows", n.TOGGLE_GRIDLINES = "sheet.mutation.toggle-gridlines", n.SET_GRIDLINES_COLOR = "sheet.mutation.set-gridlines-color", n))(du || {}), hu = /* @__PURE__ */ ((n) => (n.SET_RANGE_VALUES = "sheet.mutation.set-range-values", n.MOVE_RANGE = "sheet.mutation.move-range", n.REMOVE_WORKSHEET_MERGE = "sheet.mutation.remove-worksheet-merge", n.ADD_WORKSHEET_MERGE = "sheet.mutation.add-worksheet-merge", n.REORDER_RANGE = "sheet.mutation.reorder-range", n.SET_WORKSHEET_DEFAULT_STYLE = "sheet.mutation.set-worksheet-default-style", n.SET_ROW_DATA = "sheet.mutation.set-row-data", n.SET_COL_DATA = "sheet.mutation.set-col-data", n.SET_WORKSHEET_RANGE_THEME_STYLE = "sheet.mutation.set-worksheet-range-theme-style", n.DELETE_WORKSHEET_RANGE_THEME_STYLE = "sheet.mutation.delete-worksheet-range-theme-style", n))(hu || {});
const bh = [
  nt.id,
  Fe.id,
  er.id,
  mt.id,
  pn.id,
  Je.id,
  qe.id,
  sn.id,
  on.id,
  Tt.id,
  Ut.id,
  Ue.id,
  ke.id,
  Me.id,
  Te.id,
  Xt.id,
  Gt.id,
  Yt.id,
  Jt.id
], Eh = [
  ee.id,
  wt.id,
  se.id,
  ne.id,
  On.id,
  qt.id,
  Kt.id,
  zt.id,
  tn.id,
  nn.id
];
function kh(n) {
  switch (n.id) {
    case "sheet.mutation.set-range-values": {
      const e = n.params, t = new Y(e.cellValue).getDataRange();
      return t.endRow === -1 ? [] : e.cellValue ? [{
        unitId: e.unitId,
        subUnitId: e.subUnitId,
        range: t
      }] : [];
    }
    case "sheet.mutation.move-range": {
      const e = n.params;
      return [{
        unitId: e.unitId,
        subUnitId: e.from.subUnitId,
        range: new Y(e.from.value).getRange()
      }, {
        unitId: e.unitId,
        subUnitId: e.to.subUnitId,
        range: new Y(e.to.value).getRange()
      }];
    }
    case "sheet.mutation.remove-worksheet-merge": {
      const e = n.params;
      return e.ranges.map((t) => ({
        unitId: e.unitId,
        subUnitId: e.subUnitId,
        range: t
      }));
    }
    case "sheet.mutation.add-worksheet-merge": {
      const e = n.params;
      return e.ranges.map((t) => ({
        unitId: e.unitId,
        subUnitId: e.subUnitId,
        range: t
      }));
    }
    case "sheet.mutation.reorder-range": {
      const e = n.params;
      return [{
        unitId: e.unitId,
        subUnitId: e.subUnitId,
        range: e.range
      }];
    }
    case "sheet.mutation.set-worksheet-default-style": {
      const e = n.params;
      return [{
        unitId: e.unitId,
        subUnitId: e.subUnitId,
        range: { startRow: 0, endRow: Number.MAX_SAFE_INTEGER, startColumn: 0, endColumn: Number.MAX_SAFE_INTEGER }
      }];
    }
    case "sheet.mutation.set-row-data": {
      const e = n.params, t = Object.keys(e.rowData).map(Number);
      return t.length === 0 ? [] : [{
        unitId: e.unitId,
        subUnitId: e.subUnitId,
        range: {
          startRow: Math.min(...t),
          endRow: Math.max(...t),
          startColumn: 0,
          endColumn: Number.MAX_SAFE_INTEGER
        }
      }];
    }
    case "sheet.mutation.set-col-data": {
      const e = n.params, t = Object.keys(e.columnData).map(Number);
      return t.length === 0 ? [] : [{
        unitId: e.unitId,
        subUnitId: e.subUnitId,
        range: {
          startRow: 0,
          endRow: Number.MAX_SAFE_INTEGER,
          startColumn: Math.min(...t),
          endColumn: Math.max(...t)
        }
      }];
    }
    case "sheet.mutation.set-worksheet-range-theme-style":
    case "sheet.mutation.delete-worksheet-range-theme-style": {
      const e = n.params;
      return [{
        unitId: e.unitId,
        subUnitId: e.subUnitId,
        range: e.range
      }];
    }
    default:
      return [];
  }
}
function Uh(n, e) {
  switch (n.id) {
    case "sheet.mutation.set-worksheet-row-height":
    case "sheet.mutation.set-worksheet-row-is-auto-height": {
      const t = n.params;
      return t.ranges.map((s) => ({
        unitId: t.unitId,
        subUnitId: t.subUnitId,
        range: {
          ...s,
          rangeType: j.ROW
        }
      }));
    }
    // Note: SET_WORKSHEET_ROW_AUTO_HEIGHT has no ranges
    case "sheet.mutation.set-worksheet-row-auto-height": {
      const t = n.params;
      return t.rowsAutoHeightInfo.map((s) => ({
        unitId: t.unitId,
        subUnitId: t.subUnitId,
        range: {
          startRow: s.row,
          endRow: s.row,
          startColumn: 0,
          endColumn: e - 1,
          rangeType: j.ROW
        }
      }));
    }
    case "sheet.mutation.set-worksheet-col-width": {
      const t = n.params;
      return t.ranges.map((s) => ({
        unitId: t.unitId,
        subUnitId: t.subUnitId,
        range: {
          ...s,
          rangeType: j.COLUMN
        }
      }));
    }
    case "sheet.mutation.move-rows":
    case "sheet.mutation.move-columns": {
      const t = n.params;
      return [{
        unitId: t.unitId,
        subUnitId: t.subUnitId,
        range: t.targetRange
      }, {
        unitId: t.unitId,
        subUnitId: t.subUnitId,
        range: t.sourceRange
      }];
    }
    case "sheet.mutation.set-col-hidden":
    case "sheet.mutation.set-col-visible": {
      const t = n.params;
      return t.ranges.map((s) => ({
        unitId: t.unitId,
        subUnitId: t.subUnitId,
        range: {
          ...s,
          rangeType: j.COLUMN
        }
      }));
    }
    case "sheet.mutation.set-row-hidden":
    case "sheet.mutation.set-row-visible": {
      const t = n.params;
      return t.ranges.map((s) => ({
        unitId: t.unitId,
        subUnitId: t.subUnitId,
        range: {
          ...s,
          rangeType: j.ROW
        }
      }));
    }
    case "sheet.mutation.insert-col": {
      const t = n.params;
      return [{
        unitId: t.unitId,
        subUnitId: t.subUnitId,
        range: {
          ...t.range,
          rangeType: j.COLUMN
        }
      }];
    }
    case "sheet.mutation.insert-row": {
      const t = n.params;
      return [{
        unitId: t.unitId,
        subUnitId: t.subUnitId,
        range: {
          ...t.range,
          rangeType: j.ROW
        }
      }];
    }
    case "sheet.mutation.remove-col": {
      const t = n.params;
      return [{
        unitId: t.unitId,
        subUnitId: t.subUnitId,
        range: {
          ...t.range,
          rangeType: j.COLUMN
        }
      }];
    }
    case "sheet.mutation.remove-rows": {
      const t = n.params;
      return [{
        unitId: t.unitId,
        subUnitId: t.subUnitId,
        range: {
          ...t.range,
          rangeType: j.ROW
        }
      }];
    }
    case "sheet.mutation.toggle-gridlines":
    case "sheet.mutation.set-gridlines-color":
      return [];
    default:
      return [];
  }
}
function mo(n) {
  return n == null ? !1 : n.v !== void 0 && n.v !== null && n.v !== "" || n.p !== void 0;
}
function us(n, e) {
  return n && n.spanAnchor ? mo(e.getValue(n.spanAnchor.startRow, n.spanAnchor.startColumn)) : mo(n);
}
function gu(n, e, t, s, o) {
  const r = n.getCellMatrix(), i = n.getSpanModel().getMergedCellRange(e, t, s, o), a = new Y();
  return r.forValue((u, l) => {
    const c = r.getValue(u, l);
    c && a.setValue(u, l, c);
  }), i.forEach((u) => {
    const { startColumn: l, startRow: c, endColumn: d, endRow: h } = u;
    ki(c, h, l, d).forEach((g, m) => {
      g === c && m === l && a.setValue(g, m, {
        ...r.getValue(g, m),
        spanAnchor: { startRow: c, endRow: h, startColumn: l, endColumn: d }
      }), (g !== c || m !== l) && (a.realDeleteValue(g, m), a.setValue(g, m, {
        spanAnchor: { startRow: c, endRow: h, startColumn: l, endColumn: d }
      }));
    });
  }), a;
}
function mu(n, e, t, s) {
  const { startRow: o, startColumn: r, endRow: i } = n;
  let a = null, u = !1;
  for (let l = o; l <= i; l++) {
    const c = e.getValue(l, r - t);
    if (u = u || us(c, e), !s && u)
      break;
    c && c.spanAnchor && (a ? a = {
      startRow: Math.min(c.spanAnchor.startRow, a.startRow),
      startColumn: Math.min(c.spanAnchor.startColumn, a.startColumn),
      endRow: Math.max(c.spanAnchor.endRow, a.endRow),
      endColumn: Math.max(c.spanAnchor.endColumn, a.endColumn)
    } : a = {
      startRow: c.spanAnchor.startRow,
      startColumn: c.spanAnchor.startColumn,
      endRow: c.spanAnchor.endRow,
      endColumn: c.spanAnchor.endColumn
    });
  }
  return u ? (n.startColumn = n.startColumn - t, {
    spanAnchor: a,
    hasValue: !0,
    range: n
  }) : {
    spanAnchor: null,
    hasValue: !1,
    range: n
  };
}
function fu(n, e, t, s) {
  const { startRow: o, endColumn: r, endRow: i } = n;
  let a = null, u = !1;
  for (let l = o; l <= i; l++) {
    const c = e.getValue(l, r + t);
    if (u = u || us(c, e), !s && u)
      break;
    c && c.spanAnchor && (a ? a = {
      startRow: Math.min(c.spanAnchor.startRow, a.startRow),
      startColumn: Math.min(c.spanAnchor.startColumn, a.startColumn),
      endRow: Math.max(c.spanAnchor.endRow, a.endRow),
      endColumn: Math.max(c.spanAnchor.endColumn, a.endColumn)
    } : a = {
      startRow: c.spanAnchor.startRow,
      startColumn: c.spanAnchor.startColumn,
      endRow: c.spanAnchor.endRow,
      endColumn: c.spanAnchor.endColumn
    });
  }
  return u ? (n.endColumn = n.endColumn + t, {
    spanAnchor: a,
    hasValue: !0,
    range: n
  }) : {
    spanAnchor: null,
    hasValue: !1,
    range: n
  };
}
function Ru(n, e, t, s) {
  const { startRow: o, startColumn: r, endColumn: i } = n;
  let a = null, u = !1;
  for (let l = r; l <= i; l++) {
    const c = e.getValue(o - t, l);
    if (u = u || us(c, e), !s && u)
      break;
    c && c.spanAnchor && (a ? a = {
      startRow: Math.min(c.spanAnchor.startRow, a.startRow),
      startColumn: Math.min(c.spanAnchor.startColumn, a.startColumn),
      endRow: Math.max(c.spanAnchor.endRow, a.endRow),
      endColumn: Math.max(c.spanAnchor.endColumn, a.endColumn)
    } : a = {
      startRow: c.spanAnchor.startRow,
      startColumn: c.spanAnchor.startColumn,
      endRow: c.spanAnchor.endRow,
      endColumn: c.spanAnchor.endColumn
    });
  }
  return u ? (n.startRow = n.startRow - t, {
    spanAnchor: a,
    hasValue: !0,
    range: n
  }) : {
    spanAnchor: null,
    hasValue: !1,
    range: n
  };
}
function Cu(n, e, t, s) {
  const { startColumn: o, endColumn: r, endRow: i } = n;
  let a = null, u = !1;
  for (let l = o; l <= r; l++) {
    const c = e.getValue(i + t, l);
    if (u = u || us(c, e), !s && u)
      break;
    c && c.spanAnchor && (a ? a = {
      startRow: Math.min(c.spanAnchor.startRow, a.startRow),
      startColumn: Math.min(c.spanAnchor.startColumn, a.startColumn),
      endRow: Math.max(c.spanAnchor.endRow, a.endRow),
      endColumn: Math.max(c.spanAnchor.endColumn, a.endColumn)
    } : a = {
      startRow: c.spanAnchor.startRow,
      startColumn: c.spanAnchor.startColumn,
      endRow: c.spanAnchor.endRow,
      endColumn: c.spanAnchor.endColumn
    });
  }
  return u ? (n.endRow = n.endRow + t, {
    spanAnchor: a,
    hasValue: !0,
    range: n
  }) : {
    spanAnchor: null,
    hasValue: !1,
    range: n
  };
}
function Th(n, e, t) {
  const s = t.getMaxRows(), o = t.getMaxColumns(), r = gu(t, 0, 0, s - 1, o - 1), i = t.getSnapshot().mergeData.length > 0, { left: a, right: u, up: l, down: c } = e;
  let d = !0, h = { ...n };
  const g = [];
  for (; d; ) {
    if (d = !1, l && h.startRow !== 0) {
      const { hasValue: m, range: f, spanAnchor: C } = Ru(h, r, 1, i);
      if (C && g.push(C), m) {
        h = f, d = !0;
        continue;
      }
    }
    if (c && h.endRow !== s - 1) {
      const { hasValue: m, range: f, spanAnchor: C } = Cu(h, r, 1, i);
      if (C && g.push(C), m) {
        h = f, d = !0;
        continue;
      }
    }
    if (a && h.startColumn !== 0) {
      const { hasValue: m, range: f, spanAnchor: C } = mu(h, r, 1, i);
      if (C && g.push(C), m) {
        h = f, d = !0;
        continue;
      }
    }
    if (u && h.endColumn !== o - 1) {
      const { hasValue: m, range: f, spanAnchor: C } = fu(h, r, 1, i);
      if (C && g.push(C), m) {
        h = f, d = !0;
        continue;
      }
    }
  }
  return g.length > 0 && (h = O.union(h, ...g)), h;
}
const pu = (n) => {
  const e = new Y();
  return n.forEach((t) => {
    X.foreach(t, (s, o) => {
      e.setValue(s, o, 1);
    });
  }), e.forValue((t, s) => {
    const o = e.getValue(t - 1, s);
    o && e.setValue(t, s, o + 1);
  }), e;
}, Su = (n) => {
  const e = n;
  return e.forValue((t, s) => {
    const o = n.getValue(t - 1, s);
    o && e.setValue(t, s, o + 1);
  }), e;
}, fo = (n) => {
  const e = {
    area: 0
  }, t = (s, o) => e.area < s ? (e.area = s, e.range = o, !0) : !1;
  return n.forValue((s, o, r) => {
    let i = 1, a = r;
    t(i * a, {
      startRow: s - a + 1,
      endRow: s,
      startColumn: o,
      endColumn: o
    });
    const u = {
      startRow: s - a + 1,
      endRow: s,
      startColumn: 0,
      endColumn: o
    };
    for (let l = o - 1; l >= 0 && n.getValue(s, l); l--) {
      a = Math.min(n.getValue(s, l) || 0, a), i++;
      const c = a * i;
      u.startColumn = l, u.startRow = s - a + 1, t(c, u);
    }
  }), e;
}, wu = (n, e) => {
  X.foreach(e, (t, s) => {
    n.realDeleteValue(t, s);
  });
  for (let t = e.startColumn; t <= e.endColumn; t++) {
    const s = e.endRow + 1;
    if (n.getValue(s, t) > 0) {
      n.setValue(s, t, 1);
      let r = s + 1;
      for (; n.getValue(r, t) > 0; )
        n.setValue(r, t, n.getValue(r - 1, t) + 1), r++;
    }
  }
  return n;
}, tr = (n) => {
  const e = [];
  let t = fo(n);
  for (; t.area > 0; )
    t.range && (e.push(t.range), wu(n, t.range)), t = fo(n);
  return e;
}, nr = (n) => {
  const e = pu(n);
  return tr(e);
};
class Ph {
  constructor() {
    R(this, "_matrix", new Y());
  }
  add(...e) {
    return e.forEach((t) => {
      X.foreach(t, (s, o) => {
        this._matrix.setValue(s, o, 1);
      });
    }), this;
  }
  subtract(...e) {
    return e.forEach((t) => {
      X.foreach(t, (s, o) => {
        this._matrix.realDeleteValue(s, o);
      });
    }), this;
  }
  merge() {
    const e = Su(this._matrix);
    return tr(e);
  }
}
const Nh = 1.5, Oh = "rgba(255, 255, 255, 0.01)";
function Dh(n) {
  const { rangeWithCoord: e, primaryWithCoord: t, style: s } = n, o = {
    range: {
      startRow: e.startRow,
      startColumn: e.startColumn,
      endRow: e.endRow,
      endColumn: e.endColumn,
      rangeType: e.rangeType,
      unitId: e.unitId,
      sheetId: e.sheetId
    },
    primary: null,
    style: s
  };
  return t != null && (o.primary = Iu(t)), o;
}
function Iu(n) {
  const { actualRow: e, actualColumn: t, isMerged: s, isMergedMainCell: o } = n, { startRow: r, startColumn: i, endRow: a, endColumn: u } = n.mergeInfo;
  return {
    actualRow: e,
    actualColumn: t,
    isMerged: s,
    isMergedMainCell: o,
    startRow: r,
    startColumn: i,
    endRow: a,
    endColumn: u
  };
}
var vu = /* @__PURE__ */ ((n) => (n[n.Tab = 1] = "Tab", n[n.Comma = 2] = "Comma", n[n.Semicolon = 4] = "Semicolon", n[n.Space = 8] = "Space", n[n.Custom = 16] = "Custom", n))(vu || {});
class Mu {
  constructor() {
    R(this, "_tabCount", 0);
    R(this, "_commaCount", 0);
    R(this, "_semicolonCount", 0);
    R(this, "_spaceCount", 0);
  }
  add(e) {
    switch (e) {
      case "	":
        this._tabCount++;
        break;
      case ",":
        this._commaCount++;
        break;
      case ";":
        this._semicolonCount++;
        break;
      case " ":
        this._spaceCount++;
        break;
    }
  }
  update(e) {
    e && typeof e == "string" && (e.includes("	") && this._tabCount++, e.includes(",") && this._commaCount++, e.includes(";") && this._semicolonCount++, e.trim().includes(" ") && this._spaceCount++);
  }
  getDelimiter() {
    const e = Math.max(this._tabCount, this._commaCount, this._semicolonCount, this._spaceCount);
    return e === 0 || e === this._tabCount ? 1 : e === this._commaCount ? 2 : e === this._semicolonCount ? 4 : e === this._spaceCount ? 8 : 1;
  }
}
function _u(n, e, t) {
  const s = [];
  t !== void 0 && (n & 16) > 0 && s.push(t), (n & 1) > 0 && s.push("	"), (n & 2) > 0 && s.push(","), (n & 4) > 0 && s.push(";"), (n & 8) > 0 && s.push(" ");
  let o = "";
  for (const i of s)
    o += yu(i);
  let r = "[".concat(o, "]");
  return e && (r += "+"), new RegExp(r);
}
function yu(n) {
  return n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
const bu = (n) => {
  var t;
  return ((t = n.body) == null ? void 0 : t.dataStream.replace(/\r\n$/, "")) || "";
};
function Eu(n) {
  if (n != null) {
    if (n.p)
      return bu(n.p);
    if (n.v && typeof n.v == "string")
      return n.v;
    if (n.t && (n.t === re.FORCE_STRING || n.t === re.STRING))
      return String(n.v);
  }
}
function ku(n, e, t, s, o = !1) {
  const r = X.transformRange(e, n), { startColumn: i, startRow: a, endColumn: u, endRow: l } = r;
  if (i !== u)
    throw new Error("The range must be in the same column.");
  if (t && (t & 16) > 0 && (s === void 0 || s.length !== 1))
    throw new Error("The custom delimiter must a character.");
  const c = t === void 0, d = c ? new Mu() : null, h = [];
  for (let S = a; S <= l; S++) {
    const I = n.getCell(S, i), y = Eu(I);
    h.push(y), d && d.update(y);
  }
  const g = c ? d.getDelimiter() : t, m = _u(g, o, s);
  let f = -1, C = 0, p = 0;
  const w = [];
  for (const S of h) {
    if (S !== void 0) {
      const I = String(S).split(m);
      f < 0 ? f = I.length : f = Math.max(f, I.length), w.push(I), C = p;
    } else
      w.push(void 0);
    p++;
  }
  return {
    rs: w,
    maxLength: f === -1 ? 0 : f,
    lastRow: C
  };
}
const Uu = (n, e, t = "") => n.reduce(
  (s, o) => {
    const r = o && o[e];
    return typeof r != "string" ? (console.warn(o, `${e} is not string`), s) : (r ? (s[r] || (s[r] = []), s[r].push(o)) : s[t].push(o), s);
  },
  {}
), Tu = (n = 0) => {
  let e = n;
  return function() {
    return e++;
  };
};
function Pu(n) {
  return n == null ? !1 : n.v !== void 0 && n.v !== null && n.v !== "" || n.p !== void 0;
}
function Ah(n, e) {
  for (let t = n.startRow; t <= n.endRow; t++)
    for (let s = n.startColumn; s <= n.endColumn; s++) {
      const o = e.getCell(t, s);
      if (Pu(o))
        return { startRow: t, startColumn: s, endRow: t, endColumn: s };
    }
  return null;
}
function sr(n) {
  const e = new Y();
  return n.forEach((t) => {
    const { startRow: s, startColumn: o, endRow: r, endColumn: i } = t;
    for (let a = s; a <= r; a++)
      for (let u = o; u <= i; u++)
        e.setValue(a, u, null);
  }), e.clone();
}
function Nu(n) {
  const e = new Y();
  return n.forEach((t) => {
    const { startRow: s, startColumn: o, endRow: r, endColumn: i } = t;
    for (let a = s; a <= r; a++)
      for (let u = o; u <= i; u++)
        e.setValue(a, u, {
          v: null,
          p: null,
          f: null,
          si: null,
          custom: null
        });
  }), e.clone();
}
function Ou(n) {
  const e = new Y();
  return n.forEach((t) => {
    const { startRow: s, startColumn: o, endRow: r, endColumn: i } = t;
    for (let a = s; a <= r; a++)
      for (let u = o; u <= i; u++)
        e.setValue(a, u, {
          s: null
        });
  }), e.clone();
}
function Du(n, e, t, s) {
  const o = e.get(M), r = t ? o.getUnit(t, B.UNIVER_SHEET) : o.getCurrentUnitForType(B.UNIVER_SHEET), i = s ? r == null ? void 0 : r.getSheetBySheetId(s) : r == null ? void 0 : r.getActiveSheet();
  if (!i)
    return null;
  const { startRow: a, endRow: u, startColumn: l, endColumn: c } = n, d = [], h = [];
  for (let g = a; g <= u; g++)
    i.getRowFiltered(g) || d.push(g);
  for (let g = l; g <= c; g++)
    h.push(g);
  return {
    rows: d,
    cols: h
  };
}
function ls(n, e, t, s) {
  const o = [], r = [];
  for (const h of n) {
    const g = Du(h, e, t, s);
    g && (o.push(...g.rows), r.push(...g.cols));
  }
  const i = Array.from(new Set(o)).sort((h, g) => h - g), a = Array.from(new Set(r)).sort((h, g) => h - g), u = [];
  function l(h) {
    const g = [];
    let m = h[0];
    for (let f = 1; f < h.length; f++)
      h[f] !== h[f - 1] + 1 && (g.push([m, h[f - 1]]), m = h[f]);
    return g.push([m, h[h.length - 1]]), g;
  }
  const c = l(i), d = l(a);
  for (const [h, g] of c)
    for (const [m, f] of d)
      u.push({
        startRow: h,
        endRow: g,
        startColumn: m,
        endColumn: f
      });
  return u;
}
var Au = /* @__PURE__ */ ((n) => (n.OthersCanView = "othersCanView", n.NoOneElseCanView = "noOneElseCanView", n))(Au || {}), xu = /* @__PURE__ */ ((n) => (n.DesignedUserCanEdit = "designedUserCanEdit", n.OnlyMe = "onlyMe", n))(xu || {});
class me {
  constructor() {
    /**
     * Map<unitId, Map<subUnitId, Map<ruleId, IRangeProtectionRule>>>
     */
    R(this, "_model", /* @__PURE__ */ new Map());
    R(this, "_ruleChange$", new De());
    R(this, "ruleChange$", this._ruleChange$.asObservable());
    R(this, "_ruleRefresh$", new De());
    R(this, "ruleRefresh$", this._ruleRefresh$.asObservable());
    R(this, "_rangeRuleInitStateChange", new gt(!1));
    R(this, "rangeRuleInitStateChange$", this._rangeRuleInitStateChange.asObservable());
  }
  dispose() {
    this._ruleChange$.complete(), this._ruleRefresh$.complete();
  }
  ruleRefresh(e) {
    this._ruleRefresh$.next(e);
  }
  getRangeRuleInitState() {
    return this._rangeRuleInitStateChange.value;
  }
  changeRuleInitState(e) {
    this._rangeRuleInitStateChange.next(e);
  }
  addRule(e, t, s) {
    this._ensureRuleMap(e, t).set(s.id, s), this._ruleChange$.next({ unitId: e, subUnitId: t, rule: s, type: "add" });
  }
  deleteRule(e, t, s) {
    var r, i, a, u;
    const o = (i = (r = this._model.get(e)) == null ? void 0 : r.get(t)) == null ? void 0 : i.get(s);
    o && ((u = (a = this._model.get(e)) == null ? void 0 : a.get(t)) == null || u.delete(s), this._ruleChange$.next({ unitId: e, subUnitId: t, rule: o, type: "delete" }));
  }
  setRule(e, t, s, o) {
    var i, a;
    const r = this.getRule(e, t, s);
    r && ((a = (i = this._model.get(e)) == null ? void 0 : i.get(t)) == null || a.set(s, o), this._ruleChange$.next({ unitId: e, subUnitId: t, oldRule: r, rule: o, type: "set" }));
  }
  getRule(e, t, s) {
    var o, r;
    return (r = (o = this._model.get(e)) == null ? void 0 : o.get(t)) == null ? void 0 : r.get(s);
  }
  getSubunitRuleList(e, t) {
    var o;
    return [...(((o = this._model.get(e)) == null ? void 0 : o.get(t)) || /* @__PURE__ */ new Map()).values()];
  }
  getSubunitRuleListLength(e, t) {
    var o;
    const s = (o = this._model.get(e)) == null ? void 0 : o.get(t);
    return s ? s.size : 0;
  }
  _ensureRuleMap(e, t) {
    let s = this._model.get(e);
    s || (s = /* @__PURE__ */ new Map(), this._model.set(e, s));
    let o = s.get(t);
    return o || (o = /* @__PURE__ */ new Map(), s.set(t, o)), o;
  }
  toObject() {
    const e = {};
    return [...this._model.keys()].forEach((s) => {
      const o = this._model.get(s), r = [...o.keys()];
      e[s] = {}, r.forEach((i) => {
        const a = o.get(i);
        e[s][i] = [...a.values()];
      });
    }), e;
  }
  fromObject(e) {
    const t = /* @__PURE__ */ new Map();
    Object.keys(e).forEach((s) => {
      const o = e[s], r = /* @__PURE__ */ new Map();
      Object.keys(o).forEach((i) => {
        const a = o[i].reduce((u, l) => (u.set(l.id, l), u), /* @__PURE__ */ new Map());
        r.set(i, a);
      }), t.set(s, r);
    }), this._model = t;
  }
  deleteUnitModel(e) {
    this._model.delete(e);
  }
  createRuleId(e, t) {
    let s = kt(4);
    const o = this._ensureRuleMap(e, t);
    for (; o.has(s); )
      s = kt(4);
    return s;
  }
  getTargetByPermissionId(e, t) {
    const s = this._model.get(e);
    if (!s) return null;
    for (const [o, r] of s)
      for (const i of r.values())
        if (i.permissionId === t)
          return [e, o];
    return null;
  }
}
const xh = (n, e) => {
  const t = n.get(me), s = e.ruleIds.map((r) => t.getRule(e.unitId, e.subUnitId, r)).filter((r) => !!r);
  return { id: Be.id, params: { subUnitId: e.subUnitId, unitId: e.unitId, rules: s } };
}, ot = {
  id: "sheet.mutation.delete-range-protection",
  type: v.MUTATION,
  handler: (n, e) => {
    const { unitId: t, subUnitId: s, ruleIds: o } = e, r = n.get(me);
    return o.forEach((i) => {
      r.deleteRule(t, s, i);
    }), !0;
  }
}, $h = (n) => {
  const e = { ...n, ruleIds: n.rules.map((t) => t.id) };
  return { id: ot.id, params: e };
}, Be = {
  id: "sheet.mutation.add-range-protection",
  type: v.MUTATION,
  handler: (n, e) => {
    const { unitId: t, subUnitId: s, rules: o } = e, r = n.get(me);
    return o.forEach((i) => {
      r.addRule(t, s, i);
    }), !0;
  }
}, $u = {
  type: v.COMMAND,
  id: "sheet.command.add-range-protection",
  async handler(n, e) {
    if (!e)
      return !1;
    const t = n.get(E), s = n.get(V), o = n.get(me), { rule: r, permissionId: i } = e, { unitId: a, subUnitId: u, ranges: l, description: c, viewState: d, editState: h } = r, g = [{
      ranges: l,
      permissionId: i,
      id: o.createRuleId(a, u),
      description: c,
      unitType: r.unitType,
      unitId: a,
      subUnitId: u,
      viewState: d,
      editState: h
    }];
    if (await t.executeCommand(Be.id, {
      unitId: a,
      subUnitId: u,
      rules: g
    })) {
      const f = [{ id: Be.id, params: { unitId: a, subUnitId: u, rules: g } }], C = [{ id: ot.id, params: { unitId: a, subUnitId: u, ruleIds: g.map((p) => p.id) } }];
      s.pushUndoRedo({
        unitID: a,
        redoMutations: f,
        undoMutations: C
      });
    }
    return !0;
  }
};
var we = /* @__PURE__ */ ((n) => (n[n.MOVE_START = 0] = "MOVE_START", n[n.MOVING = 1] = "MOVING", n[n.MOVE_END = 2] = "MOVE_END", n[n.ONLY_SET = 3] = "ONLY_SET", n))(we || {});
class Wu extends ue {
  constructor(t) {
    super();
    /**
     * Selection data model for each worksheet.
     */
    R(this, "_worksheetSelections", /* @__PURE__ */ new Map());
    R(this, "_selectionMoveStart$", new De());
    R(this, "selectionMoveStart$", this._selectionMoveStart$.asObservable());
    R(this, "_selectionMoving$", new De());
    R(this, "selectionMoving$", this._selectionMoving$.asObservable());
    R(this, "_selectionMoveEnd$", new gt([]));
    R(this, "selectionMoveEnd$", this._selectionMoveEnd$.asObservable());
    R(this, "_selectionSet$", new gt([]));
    R(this, "selectionSet$", this._selectionSet$.asObservable());
    R(this, "selectionChanged$");
    R(this, "_beforeSelectionMoveEnd$", new gt([]));
    R(this, "beforeSelectionMoveEnd$", this._beforeSelectionMoveEnd$.asObservable());
    this._workbook = t, this.selectionChanged$ = jt(this._selectionMoveEnd$, this._selectionSet$);
  }
  dispose() {
    super.dispose(), this._beforeSelectionMoveEnd$.complete(), this._selectionMoveEnd$.complete(), this._selectionMoving$.complete(), this._selectionMoveStart$.complete(), this._selectionSet$.complete(), this._workbook = null;
  }
  addSelections(t, s) {
    const o = this.getSelectionsOfWorksheet(t);
    o.push(...s), this._selectionSet$.next(o);
  }
  /**
   * Set selectionDatas to _worksheetSelections, and emit selectionDatas by type.
   * @param sheetId
   * @param selectionDatas
   * @param type
   */
  setSelections(t, s = [], o) {
    switch (this.setSelectionsOfWorksheet(t, s), o) {
      case we.MOVE_START:
        this._selectionMoveStart$.next(s);
        break;
      case we.MOVING:
        this._selectionMoving$.next(s);
        break;
      case we.MOVE_END:
        this._beforeSelectionMoveEnd$.next(s), this._selectionMoveEnd$.next(s);
        break;
      case we.ONLY_SET: {
        this._selectionSet$.next(s);
        break;
      }
      default:
        this._selectionSet$.next(s);
        break;
    }
  }
  getCurrentSelections() {
    return this._getCurrentSelections();
  }
  /**
   * @deprecated use `getSelectionsOfWorksheet` instead.
   * @param sheetId
   * @returns
   */
  getSelectionOfWorksheet(t) {
    return this.getSelectionsOfWorksheet(t);
  }
  getSelectionsOfWorksheet(t) {
    return this._worksheetSelections.has(t) || this._worksheetSelections.set(t, []), this._worksheetSelections.get(t);
  }
  setSelectionsOfWorksheet(t, s) {
    this._worksheetSelections.set(t, [...s]);
  }
  deleteSheetSelection(t) {
    this._worksheetSelections.set(t, []);
  }
  /** Clear all selections in this workbook. */
  clear() {
    this._worksheetSelections.clear(), this._selectionSet$.next([]);
  }
  _getCurrentSelections() {
    return this.getSelectionsOfWorksheet(this._workbook.getActiveSheet().getSheetId());
  }
  getCurrentLastSelection() {
    const t = this._getCurrentSelections();
    return t[t.length - 1];
  }
}
var Vu = Object.getOwnPropertyDescriptor, Lu = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? Vu(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, Hu = (n, e) => (t, s) => e(t, s, n);
let z = class extends Lo {
  constructor(e) {
    super();
    /**
     * Cache cell styles for current selections, key is `${row}_${column}`.
     */
    R(this, "_cellStylesCache", /* @__PURE__ */ new Map());
    /**
     * Selection Events, usually triggered when pointerdown in spreadsheet by selection render service after selectionModel has updated.
     */
    R(this, "selectionMoveStart$");
    /**
     * Selection Events, usually triggered when pointermove in spreadsheet by selection render service after selectionModel has updated.
     */
    R(this, "selectionMoving$");
    /**
     * Selection Events, usually triggered when pointerup in spreadsheet by selection render service after selectionModel has updated.
     */
    R(this, "selectionMoveEnd$");
    /**
     * Selection Events, usually triggered when changing unit.(focus in formula editor)
     */
    R(this, "selectionSet$");
    /**
     * Selection Events, merge moveEnd$ and selectionSet$
     */
    R(this, "selectionChanged$");
    R(this, "_workbookSelections", /* @__PURE__ */ new Map());
    this._instanceSrv = e, this._init();
  }
  get _currentSelectionPos() {
    const e = this._instanceSrv.getCurrentUnitForType(B.UNIVER_SHEET);
    if (!e) return null;
    const t = e.getActiveSheet();
    return { unitId: e.getUnitId(), sheetId: t.getSheetId() };
  }
  get currentSelectionParam() {
    return this._currentSelectionPos;
  }
  _init() {
    const e = this._instanceSrv.getCurrentTypeOfUnit$(B.UNIVER_SHEET).pipe(Zi(1), et(this.dispose$));
    this.selectionMoveStart$ = e.pipe().pipe(tt((t) => t ? this._ensureWorkbookSelection(t.getUnitId()).selectionMoveStart$ : Ie())).pipe(et(this.dispose$)), this.selectionMoving$ = e.pipe(tt((t) => t ? this._ensureWorkbookSelection(t.getUnitId()).selectionMoving$ : Ie())).pipe(et(this.dispose$)), this.selectionMoveEnd$ = e.pipe(tt((t) => t ? this._ensureWorkbookSelection(t.getUnitId()).selectionMoveEnd$ : Ie([]))).pipe(et(this.dispose$)), this.selectionSet$ = e.pipe(tt((t) => t ? this._ensureWorkbookSelection(t.getUnitId()).selectionSet$ : Ie([]))).pipe(et(this.dispose$)), this.selectionChanged$ = e.pipe(tt((t) => t ? this._ensureWorkbookSelection(t.getUnitId()).selectionChanged$ : Ie([]))).pipe(
      Qi((t, s) => t.length !== s.length ? !1 : t.length === 0 && s.length === 0 ? !0 : t.every((o, r) => JSON.stringify(o) === JSON.stringify(s[r]))),
      Go(1)
    ).pipe(et(this.dispose$)), this.disposeWithMe(
      this._instanceSrv.getTypeOfUnitDisposed$(B.UNIVER_SHEET).pipe(et(this.dispose$)).subscribe((t) => {
        this._removeWorkbookSelection(t.getUnitId());
      })
    ), this.disposeWithMe(
      this.selectionChanged$.pipe(et(this.dispose$)).subscribe(() => {
        this._cellStylesCache.clear();
      })
    );
  }
  dispose() {
    super.dispose(), this._cellStylesCache.clear(), this._workbookSelections.forEach((e) => e.dispose()), this._workbookSelections.clear(), this.selectionMoveStart$ = Ie(null), this.selectionMoving$ = Ie(null), this.selectionMoveEnd$ = Ie([]), this.selectionSet$ = Ie(null), this.selectionChanged$ = Ie(null);
  }
  /**
   * Clear all selections in all workbooks.
   * invoked by prompt.controller
   */
  clear() {
    this._workbookSelections.forEach((e) => e.clear());
  }
  getCurrentSelections() {
    return this._getCurrentSelections();
  }
  getCurrentLastSelection() {
    const e = this._getCurrentSelections();
    return e == null ? void 0 : e[e.length - 1];
  }
  addSelections(e, t, s) {
    if (typeof e == "string") {
      this._ensureWorkbookSelection(e).addSelections(t, s);
      return;
    }
    const o = this._currentSelectionPos;
    if (!o)
      throw new Error("[SheetsSelectionsService]: cannot find current selection position!");
    const { unitId: r, sheetId: i } = o;
    this._ensureWorkbookSelection(r).addSelections(i, e);
  }
  setSelections(e, t, s, o) {
    if (typeof e == "string" && typeof t == "string") {
      const u = e;
      this._ensureWorkbookSelection(u).setSelections(
        t,
        s || [],
        o != null ? o : we.ONLY_SET
      );
      return;
    }
    const r = this._currentSelectionPos;
    if (!r)
      throw new Error("[SheetsSelectionsService]: cannot find current selection position!");
    const { unitId: i, sheetId: a } = r;
    if (typeof e == "object") {
      const u = e != null ? e : s, l = t != null ? t : we.ONLY_SET;
      this._ensureWorkbookSelection(i).setSelections(a, u, l);
    }
  }
  clearCurrentSelections() {
    this._getCurrentSelections().splice(0);
  }
  /**
   * Determine whether multiple current selections overlap
   *
   * @deprecated this should be extracted to an pure function
   */
  isOverlapping() {
    const e = this.getCurrentSelections();
    return e == null ? !1 : e.some(
      ({ range: t }, s) => e.some(({ range: o }, r) => s === r ? !1 : t.startRow <= o.endRow && t.endRow >= o.startRow && t.startColumn <= o.endColumn && t.endColumn >= o.startColumn)
    );
  }
  _getCurrentSelections() {
    const e = this._currentSelectionPos;
    if (!e)
      return [];
    const { unitId: t, sheetId: s } = e;
    return this._ensureWorkbookSelection(t).getSelectionsOfWorksheet(s);
  }
  getWorkbookSelections(e) {
    return this._ensureWorkbookSelection(e);
  }
  _ensureWorkbookSelection(e) {
    let t = this._workbookSelections.get(e);
    if (!t) {
      const s = this._instanceSrv.getUnit(e);
      if (!s)
        throw new Error(`[SheetsSelectionsService]: cannot resolve unit with id "${e}"!`);
      t = new Wu(s), this._workbookSelections.set(e, t);
    }
    return t;
  }
  _removeWorkbookSelection(e) {
    this._workbookSelections.delete(e);
  }
  /**
   * This method is used to get the common value of a specific cell style property in the current selections.
   * Used to determine the state related to color panels in the toolbar.
   * Because in Excel, only the color panels need to show the common color of the current selections, other properties based on the current selection primary cell.
   * Now only handles text color, fill color, border style, border color.
   */
  getCellStylesProperty(e) {
    var r;
    const t = (r = this._instanceSrv.getCurrentUnitForType(B.UNIVER_SHEET)) == null ? void 0 : r.getActiveSheet(), s = this.getCurrentSelections();
    if (!t || s.length === 0)
      return {
        isAllValuesSame: !1,
        value: null
      };
    let o = null;
    for (let i = 0; i < s.length; i++) {
      const a = s[i], { startRow: u, endRow: l, startColumn: c, endColumn: d } = a.range;
      for (let h = u; h <= l; h++)
        for (let g = c; g <= d; g++) {
          const m = `${h}_${g}`;
          let f;
          this._cellStylesCache.has(m) ? f = this._cellStylesCache.get(m) : (f = t.getComposedCellStyle(h, g), this._cellStylesCache.set(m, f));
          const C = f[e];
          if (o != null && !A.diffValue(o, C))
            return {
              isAllValuesSame: !1,
              value: null
            };
          o = C;
        }
    }
    return {
      isAllValuesSame: !0,
      value: o
    };
  }
};
z = Lu([
  Hu(0, M)
], z);
const Wh = "DISABLE_NORMAL_SELECTIONS", Vh = "SELECTIONS_ENABLED", Fu = "REF_SELECTIONS_ENABLED", Ls = {
  id: "sheet.command.clear-selection-all",
  type: v.COMMAND,
  handler: (n, e) => {
    var S;
    const t = n.get(M), s = n.get(E), o = n.get(z), r = n.get(V), i = n.get(G), a = t.getCurrentUnitForType(B.UNIVER_SHEET);
    if (!a) return !1;
    const u = (e == null ? void 0 : e.unitId) || a.getUnitId(), l = a.getActiveSheet();
    if (!l) return !1;
    const c = (e == null ? void 0 : e.subUnitId) || l.getSheetId(), d = (e == null ? void 0 : e.ranges) || ((S = o.getCurrentSelections()) == null ? void 0 : S.map((I) => I.range));
    if (!(d != null && d.length))
      return !1;
    const h = ls(d, n, u, c), g = [], m = [], f = {
      subUnitId: c,
      unitId: u,
      cellValue: sr(h)
    }, C = Ae(
      n,
      f
    );
    g.push({
      id: ee.id,
      params: f
    }), m.push({
      id: ee.id,
      params: C
    });
    const p = i.onCommandExecute({ id: Ls.id });
    return g.push(...p.redos), m.unshift(...p.undos), L(g, s) ? (r.pushUndoRedo({
      // If there are multiple mutations that form an encapsulated project, they must be encapsulated in the same undo redo element.
      // Hooks can be used to hook the code of external controllers to add new actions.
      unitID: u,
      undoMutations: m,
      redoMutations: g
    }), !0) : !1;
  }
}, Hs = {
  id: "sheet.command.clear-selection-format",
  type: v.COMMAND,
  handler: (n, e) => {
    var S;
    const t = n.get(M), s = n.get(E), o = n.get(z), r = n.get(V), i = n.get(G), a = t.getCurrentUnitForType(B.UNIVER_SHEET);
    if (!a) return !1;
    const u = (e == null ? void 0 : e.unitId) || a.getUnitId(), l = a.getActiveSheet();
    if (!l) return !1;
    const c = (e == null ? void 0 : e.subUnitId) || l.getSheetId(), d = (e == null ? void 0 : e.ranges) || ((S = o.getCurrentSelections()) == null ? void 0 : S.map((I) => I.range));
    if (!(d != null && d.length))
      return !1;
    const h = ls(d, n, u, c), g = [], m = [], f = {
      subUnitId: c,
      unitId: u,
      cellValue: Ou(h)
    }, C = Ae(
      n,
      f
    );
    g.push({
      id: ee.id,
      params: f
    }), m.push({
      id: ee.id,
      params: C
    });
    const p = i.onCommandExecute({ id: Hs.id });
    return g.push(...p.redos), m.unshift(...p.undos), L(g, s) ? (r.pushUndoRedo({
      // If there are multiple mutations that form an encapsulated project, they must be encapsulated in the same undo redo element.
      // Hooks can be used to hook the code of external controllers to add new actions.
      unitID: u,
      undoMutations: m,
      redoMutations: g
    }), !0) : !1;
  }
};
function cs(n, e, t = !0) {
  const s = e.getMatrixWithMergedCells(...Ui(n)), o = [];
  if (s.forValue((i, a, u) => {
    if (u.colSpan !== void 0 && u.rowSpan !== void 0) {
      const l = {
        startRow: i,
        startColumn: a,
        endRow: i + u.rowSpan - 1,
        endColumn: a + u.colSpan - 1
      };
      O.contains(n, l) || o.push(l);
    }
  }), o.length === 0)
    return n;
  const r = O.union(n, ...o);
  return t ? cs(r, e, t) : r;
}
function Lh(n, e, t) {
  let s = null;
  return t.getMatrixWithMergedCells(n, e, n, e).forValue((r, i, a) => (s = {
    actualRow: r,
    actualColumn: i,
    startRow: r,
    startColumn: i,
    isMerged: a.rowSpan !== void 0 || a.colSpan !== void 0,
    isMergedMainCell: a.rowSpan !== void 0 && a.colSpan !== void 0,
    endRow: r + (a.rowSpan !== void 0 ? a.rowSpan - 1 : 0),
    endColumn: i + (a.colSpan !== void 0 ? a.colSpan - 1 : 0),
    rangeType: j.NORMAL
  }, !1)), s || {
    actualColumn: e,
    actualRow: n,
    startRow: n,
    startColumn: e,
    endRow: n,
    endColumn: e,
    isMerged: !1,
    isMergedMainCell: !1,
    rangeType: j.NORMAL
  };
}
function Hh(n, e, t) {
  const { startRow: s, startColumn: o, endRow: r, endColumn: i } = n;
  return Number.isNaN(s) && (n.startRow = 0), Number.isNaN(r) && (n.endRow = e - 1), Number.isNaN(o) && (n.startColumn = 0), Number.isNaN(i) && (n.endColumn = t - 1), n;
}
function _e(n, e) {
  const t = Number.isNaN(n.startRow) ? 0 : n.startRow, s = Number.isNaN(n.startColumn) ? 0 : n.startColumn, o = e.getMergedCell(t, s);
  return o ? {
    ...o,
    actualRow: t,
    actualColumn: s,
    rangeType: j.NORMAL,
    isMerged: !0,
    isMergedMainCell: !0
  } : {
    startRow: t,
    startColumn: s,
    endRow: n.startRow,
    endColumn: n.startColumn,
    actualRow: t,
    actualColumn: s,
    rangeType: j.NORMAL,
    isMerged: !1,
    isMergedMainCell: !1
  };
}
const ut = (n, e, t) => ({
  id: ie.id,
  params: {
    unitId: e.getUnitId(),
    subUnitId: t.getSheetId(),
    reveal: !0,
    selections: [{ range: n, primary: _e(n, t) }]
  }
});
function Fh(n) {
  if (!n)
    return !1;
  const { range: e, primary: t } = n;
  return O.equals(e, t);
}
function Bu(n) {
  function e(t, s) {
    function o(r) {
      for (let i = r.startRow; i <= r.endRow; i++)
        if (!n.getRowFiltered(i))
          for (let a = r.startColumn; a <= r.endColumn; a++)
            s(i, a, r);
    }
    o(t);
  }
  return {
    forOperableEach: e
  };
}
const Ro = (n) => n.id !== Jo;
function Ct(n, e, t, s, o, r, i) {
  const a = {};
  for (let u = e; u <= t; u++)
    for (let l = s; l <= o; l++) {
      const c = r ? n.getCellWithFilteredInterceptors(i, l, lo, Ro) : n.getCellWithFilteredInterceptors(u, i, lo, Ro);
      !c || !c.s || (a[u] || (a[u] = {}), a[u][l] = { s: c.s });
    }
  for (const u in a) {
    for (const l in a[u]) {
      const c = a[u][l];
      c.s && typeof c.s == "object" && A.isEmptyObject(c.s) && delete c.s, A.isEmptyObject(c) && delete a[u][l];
    }
    A.isEmptyObject(a[u]) && delete a[u];
  }
  return a;
}
var ju = Object.getOwnPropertyDescriptor, zu = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? ju(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, Gu = (n, e) => (t, s) => e(t, s, n);
const Ku = $s("sheets-formula.ref-selections.service");
let Co = class extends z {
  constructor(n) {
    super(n);
  }
  _init() {
    const n = this._getAliveWorkbooks$().pipe(et(this.dispose$));
    this.selectionMoveStart$ = n.pipe(tt((e) => jt(...e.map((t) => t.selectionMoveStart$)))), this.selectionMoving$ = n.pipe(tt((e) => jt(...e.map((t) => t.selectionMoving$)))), this.selectionMoveEnd$ = n.pipe(tt((e) => jt(...e.map((t) => t.selectionMoveEnd$)))), this.selectionSet$ = n.pipe(tt((e) => jt(...e.map((t) => t.selectionSet$))));
  }
  dispose() {
    super.dispose(), this.selectionMoveStart$ = Ie(null), this.selectionMoving$ = Ie(null), this.selectionMoveEnd$ = Ie(null), this.selectionSet$ = Ie(null), delete this._instanceSrv, this._workbookSelections.clear();
  }
  _getAliveWorkbooks$() {
    const n = this._instanceSrv.getAllUnitsForType(B.UNIVER_SHEET);
    n.forEach((t) => this._ensureWorkbookSelection(t.getUnitId()));
    const e = new gt(n);
    return this.disposeWithMe(this._instanceSrv.getTypeOfUnitAdded$(B.UNIVER_SHEET).subscribe((t) => {
      this._ensureWorkbookSelection(t.getUnitId()), e.next([...e.getValue(), t]);
    })), this.disposeWithMe(this._instanceSrv.getTypeOfUnitDisposed$(B.UNIVER_SHEET).subscribe((t) => {
      this._removeWorkbookSelection(t.getUnitId()), e.next(e.getValue().filter((s) => s !== t));
    })), e.pipe(Es((t) => t.map((s) => this._ensureWorkbookSelection(s.getUnitId()))));
  }
};
Co = zu([
  Gu(0, M)
], Co);
function Ju(n, e) {
  const s = n.get(Ho).getContextValue(Fu);
  return n.get(s && !e ? Ku : z);
}
const ie = {
  id: "sheet.operation.set-selections",
  type: v.OPERATION,
  handler: (n, e) => {
    if (!e) return !1;
    const { selections: t, type: s, unitId: o, subUnitId: r } = e;
    return Ju(n).setSelections(o, r, [...t], s), !0;
  }
}, qu = {
  id: "sheet.command.select-range",
  type: v.COMMAND,
  handler: (n, e) => {
    if (!e) return !1;
    const { unitId: t, subUnit: s, range: o } = e, r = n.get(E), i = P(n.get(M), e);
    if (!i) return !1;
    const a = [{
      range: o,
      primary: _e(o, i.worksheet),
      style: null
    }];
    return r.syncExecuteCommand(ie.id, {
      unitId: t,
      subUnitId: s,
      selections: a
    });
  }
}, or = "sheet.command.move-range", yt = {
  type: v.COMMAND,
  id: or,
  // eslint-disable-next-line max-lines-per-function
  handler: async (n, e) => {
    var w, S;
    const t = n.get(E), s = n.get(V), o = n.get(M), r = n.get(Vt), i = n.get(it), a = n.get(G), u = P(o);
    if (!u || !await a.beforeCommandExecute({ id: yt.id, params: e }))
      return !1;
    const { worksheet: c, subUnitId: d, unitId: h } = u, g = Fs(
      n,
      { unitId: h, subUnitId: d, range: e.fromRange },
      { subUnitId: d, range: e.toRange }
    );
    if (g === null)
      return r.emit(i.t("sheets.info.acrossMergedCell")), !1;
    const m = a.onCommandExecute({
      id: yt.id,
      params: e
    }), f = [
      ...(w = m.preRedos) != null ? w : [],
      ...g.redos,
      ...m.redos,
      {
        id: ie.id,
        params: {
          unitId: h,
          subUnitId: d,
          selections: [{ range: e.toRange, primary: Yu(e.fromRange, e.toRange, c) }],
          type: we.MOVE_END
        }
      }
    ], C = [
      ...(S = m.preUndos) != null ? S : [],
      ...g.undos,
      ...m.undos,
      {
        id: ie.id,
        params: {
          unitId: h,
          subUnitId: d,
          selections: [{ range: e.fromRange, primary: _e(e.fromRange, c) }],
          type: we.MOVE_END
        }
      }
    ];
    if (L(f, t).result) {
      const { undos: I, redos: y } = a.generateMutationsOfAutoHeight({
        unitId: h,
        subUnitId: d,
        ranges: [e.fromRange, e.toRange]
      }), b = a.afterCommandExecute({
        id: yt.id,
        params: e
      });
      return L([...b.redos, ...y], t), s.pushUndoRedo({
        unitID: h,
        undoMutations: [...C, ...b.undos, ...I],
        redoMutations: [...f, ...b.redos, ...y]
      }), !0;
    }
    return !1;
  }
};
function Fs(n, e, t, s = !1) {
  const o = [], r = [], { range: i, subUnitId: a, unitId: u } = e, { range: l, subUnitId: c } = t, h = n.get(M).getUniverSheetInstance(u), g = h == null ? void 0 : h.getSheetBySheetId(c), m = h == null ? void 0 : h.getSheetBySheetId(a), f = g == null ? void 0 : g.getCellMatrix(), C = m == null ? void 0 : m.getCellMatrix();
  if (g && m && f && C) {
    const p = cs(l, g, !1);
    if (!O.equals(l, p) && !s)
      return null;
    const w = new Y(), S = new Y(), I = new Y();
    X.foreach(i, (T, k) => {
      const D = C.getValue(T, k);
      if (w.setValue(T, k, A.deepClone(D)), D) {
        const H = h == null ? void 0 : h.getStyles().get(D.s);
        I.setValue(T, k, A.deepClone(H));
      }
      S.setValue(T, k, null);
    });
    const y = new Y(), b = new Y();
    X.foreach(l, (T, k) => {
      y.setValue(T, k, A.deepClone(f.getValue(T, k)));
    }), X.foreach(i, (T, k) => {
      const D = Fo(T, k), H = O.getRelativeRange(D, i), F = O.getPositionRange(H, l), K = A.deepClone(I.getValue(T, k)), J = A.deepClone(w.getValue(T, k));
      J && K && (J.s = K), b.setValue(F.startRow, F.startColumn, J);
    });
    const N = {
      fromRange: e.range,
      toRange: t.range,
      from: {
        value: S.getMatrix(),
        subUnitId: a
      },
      to: {
        value: b.getMatrix(),
        subUnitId: c
      },
      unitId: u
    }, U = {
      fromRange: t.range,
      toRange: e.range,
      from: {
        value: w.getMatrix(),
        subUnitId: a
      },
      to: {
        value: y.getMatrix(),
        subUnitId: c
      },
      unitId: u
    };
    o.push({ id: wt.id, params: N }), r.push({ id: wt.id, params: U });
  }
  return {
    redos: o,
    undos: r
  };
}
function Yu(n, e, t) {
  const s = n.startRow, o = n.startColumn, r = t.getMergedCell(s, o), i = _e(e, t);
  if (r) {
    const a = r.endRow - r.startRow + 1, u = r.endColumn - r.startColumn + 1;
    i.endRow = i.startRow + a - 1, i.endColumn = i.startColumn + u - 1, i.actualRow = i.startRow, i.actualColumn = i.startColumn, i.isMerged = !1, i.isMergedMainCell = !0;
  }
  return i;
}
var Dn = /* @__PURE__ */ ((n) => (n[n.UNIVER_UNKNOWN = 0] = "UNIVER_UNKNOWN", n[n.UNIVER_DOC = 1] = "UNIVER_DOC", n[n.UNIVER_SHEET = 2] = "UNIVER_SHEET", n[n.UNIVER_SLIDE = 3] = "UNIVER_SLIDE", n[n.UNIVER_PROJECT = 4] = "UNIVER_PROJECT", n[n.UNRECOGNIZED = -1] = "UNRECOGNIZED", n))(Dn || {}), _ = /* @__PURE__ */ ((n) => (n[n.View = 0] = "View", n[n.Edit = 1] = "Edit", n[n.ManageCollaborator = 2] = "ManageCollaborator", n[n.Print = 3] = "Print", n[n.Duplicate = 4] = "Duplicate", n[n.Comment = 5] = "Comment", n[n.Copy = 6] = "Copy", n[n.Share = 7] = "Share", n[n.Export = 8] = "Export", n[n.MoveWorksheet = 9] = "MoveWorksheet", n[n.DeleteWorksheet = 10] = "DeleteWorksheet", n[n.HideWorksheet = 11] = "HideWorksheet", n[n.RenameWorksheet = 12] = "RenameWorksheet", n[n.CreateWorksheet = 13] = "CreateWorksheet", n[n.SetWorksheetStyle = 14] = "SetWorksheetStyle", n[n.EditWorksheetCell = 15] = "EditWorksheetCell", n[n.InsertHyperlink = 16] = "InsertHyperlink", n[n.Sort = 17] = "Sort", n[n.Filter = 18] = "Filter", n[n.PivotTable = 19] = "PivotTable", n[n.FloatImg = 20] = "FloatImg", n[n.History = 21] = "History", n[n.RwHgtClWdt = 22] = "RwHgtClWdt", n[n.ViemRwHgtClWdt = 23] = "ViemRwHgtClWdt", n[n.ViewFilter = 24] = "ViewFilter", n[n.MoveSheet = 25] = "MoveSheet", n[n.DeleteSheet = 26] = "DeleteSheet", n[n.HideSheet = 27] = "HideSheet", n[n.CopySheet = 28] = "CopySheet", n[n.RenameSheet = 29] = "RenameSheet", n[n.CreateSheet = 30] = "CreateSheet", n[n.SelectProtectedCells = 31] = "SelectProtectedCells", n[n.SelectUnProtectedCells = 32] = "SelectUnProtectedCells", n[n.SetCellStyle = 33] = "SetCellStyle", n[n.SetCellValue = 34] = "SetCellValue", n[n.SetRowStyle = 35] = "SetRowStyle", n[n.SetColumnStyle = 36] = "SetColumnStyle", n[n.InsertRow = 37] = "InsertRow", n[n.InsertColumn = 38] = "InsertColumn", n[n.DeleteRow = 39] = "DeleteRow", n[n.DeleteColumn = 40] = "DeleteColumn", n[n.EditExtraObject = 41] = "EditExtraObject", n[n.Delete = 42] = "Delete", n[n.RecoverHistory = 43] = "RecoverHistory", n[n.ViewHistory = 44] = "ViewHistory", n[n.CreatePermissionObject = 45] = "CreatePermissionObject", n[n.UNRECOGNIZED = -1] = "UNRECOGNIZED", n))(_ || {}), x = /* @__PURE__ */ ((n) => (n[n.Unkonwn = 0] = "Unkonwn", n[n.Workbook = 1] = "Workbook", n[n.Worksheet = 2] = "Worksheet", n[n.SelectRange = 3] = "SelectRange", n[n.Document = 4] = "Document", n[n.Slide = 5] = "Slide", n[n.UNRECOGNIZED = -1] = "UNRECOGNIZED", n))(x || {});
class Ve {
  constructor(e, t, s) {
    R(this, "type", x.SelectRange);
    R(this, "subType", _.Edit);
    R(this, "status", q.INIT);
    R(this, "value", !0);
    R(this, "id");
    R(this, "unitId");
    R(this, "subUnitId");
    R(this, "permissionId");
    this.unitId = e, this.subUnitId = t, this.permissionId = s, this.id = `${x.SelectRange}.${_.Edit}.${s}`;
  }
}
class Bs {
  constructor(e, t, s) {
    R(this, "type", x.SelectRange);
    R(this, "subType", _.View);
    R(this, "status", q.INIT);
    R(this, "value", !1);
    R(this, "id");
    R(this, "unitId");
    R(this, "subUnitId");
    R(this, "permissionId");
    this.unitId = e, this.subUnitId = t, this.permissionId = s, this.id = `${x.SelectRange}.${_.View}.${s}`;
  }
}
class rr {
  constructor(e) {
    R(this, "id");
    R(this, "value", !0);
    R(this, "type", x.Workbook);
    R(this, "status", q.INIT);
    R(this, "subType", _.Comment);
    this.unitId = e, this.unitId = e, this.id = `${this.type}.${_.Comment}_${e}`;
  }
}
class ir {
  constructor(e) {
    R(this, "id");
    R(this, "value", !0);
    R(this, "type", x.Workbook);
    R(this, "status", q.INIT);
    R(this, "subType", _.Copy);
    this.unitId = e, this.unitId = e, this.id = `${this.type}.${_.Copy}_${e}`;
  }
}
class Xu {
  constructor(e) {
    R(this, "id");
    R(this, "value", !0);
    R(this, "type", x.Workbook);
    R(this, "subType", _.CopySheet);
    R(this, "status", q.INIT);
    this.unitId = e, this.unitId = e, this.id = `${this.type}.${_.CopySheet}_${e}`;
  }
}
class ar {
  constructor(e) {
    R(this, "id");
    R(this, "value", !0);
    R(this, "type", x.Workbook);
    R(this, "status", q.INIT);
    R(this, "subType", _.CreatePermissionObject);
    this.unitId = e, this.unitId = e, this.id = `${this.type}.${_.CreatePermissionObject}_${e}`;
  }
}
class ur {
  constructor(e) {
    R(this, "id");
    R(this, "value", !0);
    R(this, "type", x.Workbook);
    R(this, "status", q.INIT);
    R(this, "subType", _.CreateSheet);
    this.unitId = e, this.unitId = e, this.id = `${this.type}.${_.CreateSheet}_${e}`;
  }
}
class Zu {
  constructor(e) {
    R(this, "value", !0);
    R(this, "type", x.Workbook);
    R(this, "status", q.INIT);
    R(this, "id");
    R(this, "subType", _.DeleteColumn);
    this.unitId = e, this.id = `${this.type}.${_.DeleteColumn}_${e}`;
  }
}
class Qu {
  constructor(e) {
    R(this, "value", !0);
    R(this, "type", x.Workbook);
    R(this, "status", q.INIT);
    R(this, "id");
    R(this, "subType", _.DeleteRow);
    this.unitId = e, this.id = `${this.type}.${_.DeleteRow}_${e}`;
  }
}
class lr {
  constructor(e) {
    R(this, "id");
    R(this, "value", !0);
    R(this, "type", x.Workbook);
    R(this, "status", q.INIT);
    R(this, "subType", _.DeleteSheet);
    this.unitId = e, this.unitId = e, this.id = `${this.type}.${_.DeleteSheet}_${e}`;
  }
}
class cr {
  constructor(e) {
    R(this, "id");
    R(this, "value", !0);
    R(this, "type", x.Workbook);
    R(this, "status", q.INIT);
    R(this, "subType", _.Duplicate);
    this.unitId = e, this.unitId = e, this.id = `${this.type}.${_.Duplicate}_${e}`;
  }
}
class Pe {
  constructor(e) {
    R(this, "id");
    R(this, "value", !0);
    R(this, "type", x.Workbook);
    R(this, "status", q.INIT);
    R(this, "subType", _.Edit);
    this.unitId = e, this.unitId = e, this.id = `${this.type}.${_.Edit}_${e}`;
  }
}
class dr {
  constructor(e) {
    R(this, "id");
    R(this, "value", !0);
    R(this, "type", x.Workbook);
    R(this, "status", q.INIT);
    R(this, "subType", _.Export);
    this.unitId = e, this.unitId = e, this.id = `${this.type}.${_.Export}_${e}`;
  }
}
class js {
  constructor(e) {
    R(this, "id");
    R(this, "value", !0);
    R(this, "type", x.Workbook);
    R(this, "status", q.INIT);
    R(this, "subType", _.HideSheet);
    this.unitId = e, this.unitId = e, this.id = `${this.type}.${_.HideSheet}_${e}`;
  }
}
class el {
  constructor(e) {
    R(this, "id");
    R(this, "value", !0);
    R(this, "type", x.Workbook);
    R(this, "status", q.INIT);
    R(this, "subType", _.History);
    this.unitId = e, this.unitId = e, this.id = `${this.type}.${_.History}_${e}`;
  }
}
class tl {
  constructor(e) {
    R(this, "value", !0);
    R(this, "type", x.Workbook);
    R(this, "status", q.INIT);
    R(this, "id");
    R(this, "subType", _.InsertColumn);
    this.unitId = e, this.id = `${this.type}.${_.InsertColumn}_${e}`;
  }
}
class nl {
  constructor(e) {
    R(this, "value", !0);
    R(this, "type", x.Workbook);
    R(this, "status", q.INIT);
    R(this, "id");
    R(this, "subType", _.InsertRow);
    this.unitId = e, this.id = `${this.type}.${_.InsertRow}_${e}`;
  }
}
class zs {
  constructor(e) {
    R(this, "id");
    R(this, "value", !0);
    R(this, "type", x.Workbook);
    R(this, "status", q.INIT);
    R(this, "subType", _.ManageCollaborator);
    this.unitId = e, this.unitId = e, this.id = `${this.type}.${_.ManageCollaborator}_${e}`;
  }
}
class Gs {
  constructor(e) {
    R(this, "id");
    R(this, "value", !0);
    R(this, "type", x.Workbook);
    R(this, "status", q.INIT);
    R(this, "subType", _.MoveSheet);
    this.unitId = e, this.unitId = e, this.id = `${this.type}.${_.MoveSheet}_${e}`;
  }
}
class hr {
  constructor(e) {
    R(this, "id");
    R(this, "value", !0);
    R(this, "type", x.Workbook);
    R(this, "status", q.INIT);
    R(this, "subType", _.Print);
    this.unitId = e, this.unitId = e, this.id = `${this.type}.${_.Print}_${e}`;
  }
}
class gr {
  constructor(e) {
    R(this, "id");
    R(this, "value", !0);
    R(this, "type", x.Workbook);
    R(this, "status", q.INIT);
    R(this, "subType", _.RecoverHistory);
    this.unitId = e, this.unitId = e, this.id = `${this.type}.${_.RecoverHistory}_${e}`;
  }
}
class Ks {
  constructor(e) {
    R(this, "id");
    R(this, "value", !0);
    R(this, "type", x.Workbook);
    R(this, "status", q.INIT);
    R(this, "subType", _.RenameSheet);
    this.unitId = e, this.unitId = e, this.id = `${this.type}.${_.RenameSheet}_${e}`;
  }
}
class mr {
  constructor(e) {
    R(this, "id");
    R(this, "value", !0);
    R(this, "type", x.Workbook);
    R(this, "status", q.INIT);
    R(this, "subType", _.Share);
    this.unitId = e, this.unitId = e, this.id = `${this.type}.${_.Share}_${e}`;
  }
}
class fr {
  constructor(e) {
    R(this, "id");
    R(this, "value", !0);
    R(this, "type", x.Workbook);
    R(this, "status", q.INIT);
    R(this, "subType", _.View);
    this.unitId = e, this.unitId = e, this.id = `${this.type}.${_.View}_${e}`;
  }
}
class Rr {
  constructor(e) {
    R(this, "id");
    R(this, "value", !0);
    R(this, "type", x.Workbook);
    R(this, "status", q.INIT);
    R(this, "subType", _.ViewHistory);
    this.unitId = e, this.unitId = e, this.id = `${this.type}.${_.ViewHistory}_${e}`;
  }
}
class Cr {
  constructor(e, t) {
    R(this, "value", !0);
    R(this, "type", x.Worksheet);
    R(this, "status", q.INIT);
    R(this, "id");
    R(this, "subType", _.Copy);
    this.unitId = e, this.subUnitId = t, this.id = `${this.type}.${_.Copy}_${e}_${t}`;
  }
}
class pr {
  constructor(e, t) {
    R(this, "value", !0);
    R(this, "type", x.Worksheet);
    R(this, "status", q.INIT);
    R(this, "id");
    R(this, "subType", _.DeleteColumn);
    this.unitId = e, this.subUnitId = t, this.id = `${this.type}.${_.DeleteColumn}_${e}_${t}`;
  }
}
class Sr {
  constructor(e, t) {
    R(this, "value", !0);
    R(this, "type", x.Worksheet);
    R(this, "status", q.INIT);
    R(this, "id");
    R(this, "subType", _.Delete);
    this.unitId = e, this.subUnitId = t, this.id = `${this.type}.${_.Delete}_${e}_${t}`;
  }
}
class wr {
  constructor(e, t) {
    R(this, "value", !0);
    R(this, "type", x.Worksheet);
    R(this, "status", q.INIT);
    R(this, "id");
    R(this, "subType", _.DeleteRow);
    this.unitId = e, this.subUnitId = t, this.id = `${this.type}.${_.DeleteRow}_${e}_${t}`;
  }
}
class Le {
  constructor(e, t) {
    R(this, "value", !0);
    R(this, "type", x.Worksheet);
    R(this, "status", q.INIT);
    R(this, "id");
    R(this, "subType", _.Edit);
    this.unitId = e, this.subUnitId = t, this.id = `${this.type}.${_.Edit}_${e}_${t}`;
  }
}
class Ir {
  constructor(e, t) {
    R(this, "value", !0);
    R(this, "type", x.Worksheet);
    R(this, "status", q.INIT);
    R(this, "id");
    R(this, "subType", _.EditExtraObject);
    this.unitId = e, this.subUnitId = t, this.id = `${this.type}.${_.EditExtraObject}_${e}_${t}`;
  }
}
class vr {
  constructor(e, t) {
    R(this, "value", !0);
    R(this, "type", x.Worksheet);
    R(this, "status", q.INIT);
    R(this, "id");
    R(this, "subType", _.Filter);
    this.unitId = e, this.subUnitId = t, this.id = `${this.type}.${_.Filter}_${e}_${t}`;
  }
}
class Mr {
  constructor(e, t) {
    R(this, "value", !0);
    R(this, "type", x.Worksheet);
    R(this, "status", q.INIT);
    R(this, "id");
    R(this, "subType", _.InsertColumn);
    this.unitId = e, this.subUnitId = t, this.id = `${this.type}.${_.InsertColumn}_${e}_${t}`;
  }
}
class _r {
  constructor(e, t) {
    R(this, "value", !0);
    R(this, "type", x.Worksheet);
    R(this, "status", q.INIT);
    R(this, "id");
    R(this, "subType", _.InsertHyperlink);
    this.unitId = e, this.subUnitId = t, this.id = `${this.type}.${_.InsertHyperlink}_${e}_${t}`;
  }
}
class yr {
  constructor(e, t) {
    R(this, "value", !0);
    R(this, "type", x.Worksheet);
    R(this, "status", q.INIT);
    R(this, "id");
    R(this, "subType", _.InsertRow);
    this.unitId = e, this.subUnitId = t, this.id = `${this.type}.${_.InsertRow}_${e}_${t}`;
  }
}
class br {
  constructor(e, t) {
    R(this, "value", !0);
    R(this, "type", x.Worksheet);
    R(this, "status", q.INIT);
    R(this, "id");
    R(this, "subType", _.ManageCollaborator);
    this.unitId = e, this.subUnitId = t, this.id = `${this.type}.${_.ManageCollaborator}_${e}_${t}`;
  }
}
class Er {
  constructor(e, t) {
    R(this, "value", !0);
    R(this, "type", x.Worksheet);
    R(this, "status", q.INIT);
    R(this, "id");
    R(this, "subType", _.PivotTable);
    this.unitId = e, this.subUnitId = t, this.id = `${this.type}.${_.PivotTable}_${e}_${t}`;
  }
}
class Bh {
  constructor(e, t) {
    R(this, "value", !0);
    R(this, "type", x.Worksheet);
    R(this, "status", q.INIT);
    R(this, "id");
    R(this, "subType", _.SelectProtectedCells);
    this.unitId = e, this.subUnitId = t, this.id = `${this.type}.${_.SelectProtectedCells}_${e}_${t}`;
  }
}
class jh {
  constructor(e, t) {
    R(this, "value", !0);
    R(this, "type", x.Worksheet);
    R(this, "status", q.INIT);
    R(this, "id");
    R(this, "subType", _.SelectUnProtectedCells);
    this.unitId = e, this.subUnitId = t, this.id = `${this.type}.${_.SelectUnProtectedCells}_${e}_${t}`;
  }
}
class kr {
  constructor(e, t) {
    R(this, "value", !0);
    R(this, "type", x.Worksheet);
    R(this, "status", q.INIT);
    R(this, "id");
    R(this, "subType", _.SetCellStyle);
    this.unitId = e, this.subUnitId = t, this.id = `${this.type}.${_.SetCellStyle}_${e}_${t}`;
  }
}
class An {
  constructor(e, t) {
    R(this, "value", !0);
    R(this, "type", x.Worksheet);
    R(this, "status", q.INIT);
    R(this, "id");
    R(this, "subType", _.SetCellValue);
    this.unitId = e, this.subUnitId = t, this.id = `${this.type}.${_.SetCellValue}_${e}_${t}`;
  }
}
class Zt {
  constructor(e, t) {
    R(this, "value", !0);
    R(this, "type", x.Worksheet);
    R(this, "status", q.INIT);
    R(this, "id");
    R(this, "subType", _.SetColumnStyle);
    this.unitId = e, this.subUnitId = t, this.id = `${this.type}.${_.SetColumnStyle}_${e}_${t}`;
  }
}
class Qt {
  constructor(e, t) {
    R(this, "value", !0);
    R(this, "type", x.Worksheet);
    R(this, "status", q.INIT);
    R(this, "id");
    R(this, "subType", _.SetRowStyle);
    this.unitId = e, this.subUnitId = t, this.id = `${this.type}.${_.SetRowStyle}_${e}_${t}`;
  }
}
class Ur {
  constructor(e, t) {
    R(this, "value", !0);
    R(this, "type", x.Worksheet);
    R(this, "status", q.INIT);
    R(this, "id");
    R(this, "subType", _.Sort);
    this.unitId = e, this.subUnitId = t, this.id = `${this.type}.${_.Sort}_${e}_${t}`;
  }
}
class ds {
  constructor(e, t) {
    R(this, "value", !0);
    R(this, "type", x.Worksheet);
    R(this, "status", q.INIT);
    R(this, "id");
    R(this, "subType", _.View);
    this.unitId = e, this.subUnitId = t, this.id = `${this.type}.${_.View}_${e}_${t}`;
  }
}
const Sn = {
  id: "sheet.command.set-range-values",
  type: v.COMMAND,
  handler: (n, e) => {
    var H;
    const t = n.get(E), s = n.get(V), o = n.get(M), r = n.get(z), i = n.get(G), a = n.get(Ze), u = P(o, e);
    if (!u) return !1;
    const { subUnitId: l, unitId: c, workbook: d, worksheet: h } = u, { value: g, range: m, redoUndoId: f } = e, C = m ? [m] : (H = r.getCurrentSelections()) == null ? void 0 : H.map((F) => F.range);
    if (!C || !C.length || !a.getPermissionPoint(new Le(c, l).id)) return !1;
    const p = new Y();
    let w;
    if (A.isArray(g))
      for (let F = 0; F < C.length; F++) {
        const { startRow: K, startColumn: J, endRow: ae, endColumn: oe } = C[F];
        for (let le = 0; le <= ae - K; le++)
          for (let Se = 0; Se <= oe - J; Se++)
            p.setValue(le + K, Se + J, g[le][Se]);
      }
    else if (Bo(g))
      for (let F = 0; F < C.length; F++) {
        const { startRow: K, startColumn: J, endRow: ae, endColumn: oe } = C[F];
        for (let le = K; le <= ae; le++)
          for (let Se = J; Se <= oe; Se++)
            p.setValue(le, Se, g);
      }
    else
      w = g;
    const S = { subUnitId: l, unitId: c, cellValue: w != null ? w : p.getMatrix() }, I = Ae(n, S), y = Ti(S.cellValue, (F, K) => h.getCellHeight(F, K) || void 0);
    if (!t.syncExecuteCommand(ee.id, S)) return !1;
    const { undos: N, redos: U } = i.onCommandExecute({
      id: Sn.id,
      params: S
    }), { undos: T, redos: k } = i.generateMutationsOfAutoHeight({
      unitId: c,
      subUnitId: l,
      ranges: C,
      cellHeights: new Y(y)
    });
    if (L([...U, ...k], t).result) {
      const F = ut(m != null ? m : p.getRange(), d, h);
      return s.pushUndoRedo({
        unitID: c,
        undoMutations: [
          { id: ee.id, params: I },
          ...N,
          ...T,
          F
        ],
        redoMutations: [
          { id: ee.id, params: S },
          ...U,
          ...k,
          A.deepClone(F)
        ],
        id: f
      }), !0;
    }
    return !1;
  }
};
function Tr(n, e) {
  const t = [], s = [], { unitId: o, subUnitId: r, range: i, shiftDimension: a, cellValue: u = {} } = e, l = n.get(M), c = n.get(G), d = l.getUniverSheetInstance(o), h = d == null ? void 0 : d.getSheetBySheetId(r);
  if (h) {
    const g = h.getCellMatrix(), m = g.getDataRange();
    if (i.startColumn <= m.endColumn || i.startRow <= m.endRow) {
      let S, I;
      if (a === Re.COLUMNS) {
        const b = Math.min(i.endRow, m.endRow);
        let N = 0;
        for (let T = i.startRow; T <= b; T++) {
          const k = g.getRow(T), D = k ? jo(k) - 1 : 0;
          N = Math.max(N, D);
        }
        S = {
          startRow: i.startRow,
          startColumn: i.startColumn,
          endRow: b,
          endColumn: N
        };
        const U = i.endColumn - i.startColumn + 1;
        I = {
          startRow: i.startRow,
          startColumn: S.startColumn + U,
          endRow: b,
          endColumn: S.endColumn + U
        };
      } else {
        const b = Math.min(i.endColumn, m.endColumn), N = m.endRow;
        S = {
          startRow: i.startRow,
          startColumn: i.startColumn,
          endRow: N,
          endColumn: b
        };
        const U = i.endRow - i.startRow + 1;
        I = {
          startRow: S.startRow + U,
          startColumn: i.startColumn,
          endRow: S.endRow + U,
          endColumn: b
        };
      }
      const y = Fs(
        n,
        { unitId: o, subUnitId: r, range: S },
        { subUnitId: r, range: I },
        !0
      );
      y && (t.push(...y.redos), s.push(...y.undos));
    }
    if (Object.entries(u).length === 0)
      for (let S = i.startRow; S <= i.endRow; S++) {
        u[S] || (u[S] = {});
        for (let I = i.startColumn; I <= i.endColumn; I++)
          u[S][I] = null;
      }
    const f = {
      subUnitId: r,
      unitId: o,
      cellValue: u
    }, C = Ae(
      n,
      f
    ), { undos: p, redos: w } = c.onCommandExecute({
      id: Sn.id,
      params: { ...f, range: i }
    });
    t.push({ id: ee.id, params: f }, ...w), s.push({ id: ee.id, params: C }, ...p);
  }
  return {
    redo: t,
    undo: s
  };
}
function Pr(n, e) {
  const t = [], s = [], { unitId: o, subUnitId: r, range: i, shiftDimension: a } = e, u = n.get(M), l = n.get(G), c = u.getUniverSheetInstance(o), d = c == null ? void 0 : c.getSheetBySheetId(r);
  if (d) {
    const h = d.getCellMatrix(), g = h.getDataRange(), m = {
      subUnitId: r,
      unitId: o,
      cellValue: sr([i])
    }, f = Ae(
      n,
      m
    ), C = l.onCommandExecute({
      id: Sn.id,
      params: m
    });
    if (t.push({ id: ee.id, params: m }, ...C.redos), s.push(...C.undos, {
      id: ee.id,
      params: f
    }), i.startColumn <= g.endColumn || i.startRow <= g.endRow) {
      let p = null, w = null;
      if (a === Re.COLUMNS && i.endColumn < g.endColumn) {
        const S = Math.min(i.endRow, g.endRow);
        let I = 0;
        for (let b = i.startRow; b <= S; b++) {
          const N = h.getRow(b), U = N ? jo(N) - 1 : 0;
          I = Math.max(I, U);
        }
        p = {
          startRow: i.startRow,
          startColumn: i.endColumn + 1,
          endRow: S,
          endColumn: I
        };
        const y = i.endColumn - i.startColumn + 1;
        w = {
          startRow: i.startRow,
          startColumn: p.startColumn - y,
          endRow: S,
          endColumn: p.endColumn - y
        };
      }
      if (a === Re.ROWS && i.endRow < g.endRow) {
        const S = Math.min(i.endColumn, g.endColumn), I = g.endRow;
        p = {
          startRow: i.endRow + 1,
          startColumn: i.startColumn,
          endRow: I,
          endColumn: S
        };
        const y = i.endRow - i.startRow + 1;
        w = {
          startRow: p.startRow - y,
          startColumn: i.startColumn,
          endRow: p.endRow - y,
          endColumn: S
        };
      }
      if (p && w) {
        const S = Fs(
          n,
          { unitId: o, subUnitId: r, range: p },
          { subUnitId: r, range: w },
          !0
        );
        S && (t.push(...S.redos), s.push(...S.undos));
      }
    }
  }
  return {
    redo: t,
    undo: s
  };
}
function zh(n, e, t, s, o, r) {
  const { startRow: i, endRow: a, startColumn: u, endColumn: l } = e;
  if (o === Re.ROWS) {
    const c = a - i + 1;
    for (let d = t; d >= i; d--)
      for (let h = u; h <= l; h++) {
        const g = n.getValue(d, h);
        g == null ? n.realDeleteValue(d + c, h) : n.setValue(d + c, h, g);
      }
    for (let d = a; d >= i; d--)
      for (let h = u; h <= l; h++)
        r && r[d] && r[d][h] ? n.setValue(d, h, r[d][h]) : n.realDeleteValue(d, h);
  } else if (o === Re.COLUMNS) {
    const c = l - u + 1;
    for (let d = i; d <= a; d++)
      for (let h = s; h >= u; h--) {
        const g = n.getValue(d, h);
        g == null ? n.realDeleteValue(d, h + c) : n.setValue(d, h + c, g);
      }
    for (let d = i; d <= a; d++)
      for (let h = l; h >= u; h--)
        r && r[d] && r[d][h] ? n.setValue(d, h, r[d][h]) : n.realDeleteValue(d, h);
  }
}
function Gh(n, e, t, s, o) {
  const { startRow: r, endRow: i, startColumn: a, endColumn: u } = e, l = i - r + 1, c = u - a + 1;
  if (o === Re.ROWS)
    for (let d = r; d <= t; d++)
      for (let h = a; h <= u; h++) {
        const g = n.getValue(d + l, h);
        g == null ? n.realDeleteValue(d, h) : n.setValue(d, h, g);
      }
  else if (o === Re.COLUMNS)
    for (let d = r; d <= i; d++)
      for (let h = a; h <= s; h++) {
        const g = n.getValue(d, h + c);
        g == null ? n.realDeleteValue(d, h) : n.setValue(d, h, g);
      }
}
const Nr = "sheet.command.delete-range-move-left", It = {
  type: v.COMMAND,
  id: Nr,
  handler: async (n, e) => {
    var I, y, b;
    const t = n.get(E), s = n.get(V), o = n.get(M), r = n.get(z), i = n.get(G), a = P(o);
    if (!a) return !1;
    const { worksheet: u, workbook: l, subUnitId: c, unitId: d } = a;
    let h = e == null ? void 0 : e.range;
    if (h || (h = (I = r.getCurrentLastSelection()) == null ? void 0 : I.range), !h) return !1;
    const g = {
      range: h,
      subUnitId: c,
      unitId: d,
      shiftDimension: Re.COLUMNS
    }, m = i.onCommandExecute({
      id: It.id,
      params: { range: h }
    }), { redo: f, undo: C } = Pr(
      n,
      g
    ), p = [...(y = m.preRedos) != null ? y : [], ...f], w = [...m.undos, ...C];
    if (p.push(...m.redos), p.push(ut(h, l, u)), w.push(...(b = m.preUndos) != null ? b : []), L(p, t).result) {
      const N = i.afterCommandExecute({
        id: It.id,
        params: { range: h }
      });
      return L(N.redos, t), w.push(...N.undos), p.push(...N.redos), s.pushUndoRedo({
        unitID: d,
        undoMutations: w.reverse(),
        redoMutations: p
      }), !0;
    }
    return !1;
  }
  // all subsequent mutations should succeed inorder to make the whole process succeed
  // Promise.all([]).then(() => true),
}, Or = "sheet.command.delete-range-move-up", vt = {
  type: v.COMMAND,
  id: Or,
  handler: async (n, e) => {
    var I, y, b;
    const t = n.get(E), s = n.get(V), o = n.get(M), r = n.get(z), i = n.get(G), a = P(o);
    if (!a) return !1;
    const { unitId: u, subUnitId: l, workbook: c, worksheet: d } = a;
    let h = e == null ? void 0 : e.range;
    if (h || (h = (I = r.getCurrentLastSelection()) == null ? void 0 : I.range), !h) return !1;
    const g = {
      range: h,
      subUnitId: l,
      unitId: u,
      shiftDimension: Re.ROWS
    }, m = i.onCommandExecute({
      id: vt.id,
      params: { range: h }
    }), { redo: f, undo: C } = Pr(
      n,
      g
    ), p = [...(y = m.preRedos) != null ? y : [], ...f], w = [...m.undos, ...C];
    if (p.push(...m.redos), p.push(ut(h, c, d)), w.push(...(b = m.preUndos) != null ? b : []), L(p, t).result) {
      const N = i.afterCommandExecute({
        id: vt.id,
        params: { range: h }
      });
      return L(N.redos, t), w.push(...N.undos), p.push(...N.redos), s.pushUndoRedo({
        unitID: u,
        undoMutations: w.reverse(),
        redoMutations: p
      }), !0;
    }
    return !1;
  }
  // all subsequent mutations should succeed inorder to make the whole process succeed
  // Promise.all([]).then(() => true),
}, sl = "sheet.command.insert-range-move-down", Pt = {
  type: v.COMMAND,
  id: "sheet.command.insert-range-move-down",
  // eslint-disable-next-line max-lines-per-function
  handler: async (n, e) => {
    var H, F, K;
    const t = n.get(E), s = n.get(V), o = n.get(M), r = n.get(z), i = n.get(G), a = n.get(Vt), u = n.get(it);
    if (r.isOverlapping())
      return a.emit(u.t("sheets.info.overlappingSelections")), !1;
    const l = P(o);
    if (!l) return !1;
    const { unitId: c, subUnitId: d, worksheet: h, workbook: g } = l;
    let m = e == null ? void 0 : e.range;
    if (m || (m = (H = r.getCurrentLastSelection()) == null ? void 0 : H.range), !m) return !1;
    const f = [], C = [], p = h.getCellMatrix(), w = p.getDataRange(), I = p.getSlice(w.startRow, w.endRow, m.startColumn, m.endColumn).getDataRange().endRow, y = Math.max(I + (m.endRow - m.startRow + 1) - w.endRow, 0);
    if (y > 0) {
      const J = m.startRow - 1, ae = h.getRowHeight(J), oe = {
        unitId: c,
        subUnitId: d,
        range: {
          startRow: w.endRow + 1,
          endRow: w.endRow + y,
          startColumn: w.startColumn,
          endColumn: w.endColumn
        },
        rowInfo: new Array(y).fill(void 0).map(() => ({
          h: ae,
          hd: te.FALSE
        }))
      };
      f.push({
        id: ke.id,
        params: oe
      });
      const le = Ws(
        n,
        oe
      );
      C.push({ id: Te.id, params: le });
    }
    const b = {};
    X.foreach(m, (J, ae) => {
      const oe = h.getCell(J, ae);
      oe && (b[J] || (b[J] = {}), b[J][ae] = { s: oe.s });
    });
    const N = {
      range: m,
      subUnitId: d,
      unitId: c,
      shiftDimension: Re.ROWS,
      cellValue: b
    }, { redo: U, undo: T } = Tr(
      n,
      N
    );
    f.push(...U), C.push(...T);
    const k = i.onCommandExecute({
      id: Pt.id,
      params: { range: m }
    });
    if (f.push(...k.redos), f.push(ut(m, g, h)), C.push(...(F = k.preUndos) != null ? F : []), f.unshift(...(K = k.preRedos) != null ? K : []), C.unshift(...k.undos), L(f, t)) {
      const J = i.afterCommandExecute({
        id: Pt.id,
        params: { range: m }
      });
      return L(J.redos, t), C.push(...J.undos), f.push(...J.redos), s.pushUndoRedo({
        unitID: c,
        undoMutations: C.reverse(),
        redoMutations: f
      }), !0;
    }
    return !1;
  }
  // all subsequent mutations should succeed inorder to make the whole process succeed
  // Promise.all([]).then(() => true),
}, Js = "sheet.command.insert-range-move-right", rn = {
  type: v.COMMAND,
  id: Js,
  // eslint-disable-next-line max-lines-per-function
  handler: async (n, e) => {
    var H, F, K;
    const t = n.get(E), s = n.get(V), o = n.get(M), r = n.get(z), i = n.get(G), a = n.get(Vt), u = n.get(it);
    if (r.isOverlapping())
      return a.emit(u.t("sheets.info.overlappingSelections")), !1;
    const l = P(o);
    if (!l) return !1;
    const { workbook: c, worksheet: d, unitId: h, subUnitId: g } = l;
    let m = e == null ? void 0 : e.range;
    if (m || (m = (H = r.getCurrentLastSelection()) == null ? void 0 : H.range), !m) return !1;
    const f = [], C = [], p = d.getCellMatrix(), w = p.getDataRange(), I = p.getSlice(m.startRow, m.endRow, w.startColumn, w.endColumn).getDataRange().endColumn, y = Math.max(
      I + (m.endColumn - m.startColumn + 1) - w.endColumn,
      0
    );
    if (y > 0) {
      const J = m.startColumn - 1, ae = d.getColumnWidth(J), oe = {
        unitId: h,
        subUnitId: g,
        range: {
          startRow: w.startRow + 1,
          endRow: w.endRow,
          startColumn: w.endColumn + 1,
          endColumn: w.endColumn + y
        },
        colInfo: new Array(y).fill(void 0).map(() => ({
          w: ae,
          hd: te.FALSE
        }))
      };
      f.push({
        id: Ue.id,
        params: oe
      });
      const le = as(
        n,
        oe
      );
      C.push({ id: Me.id, params: le });
    }
    const b = {};
    X.foreach(m, (J, ae) => {
      const oe = d.getCell(J, ae);
      !oe || !oe.s || (b[J] || (b[J] = {}), b[J][ae] = { s: oe.s });
    });
    const N = {
      range: m,
      subUnitId: g,
      unitId: h,
      shiftDimension: Re.COLUMNS,
      cellValue: b
    }, { redo: U, undo: T } = Tr(
      n,
      N
    );
    f.push(...U), C.push(...T);
    const k = i.onCommandExecute({
      id: rn.id,
      params: { range: m }
    });
    if (f.push(...k.redos), f.push(ut(m, c, d)), C.push(...(F = k.preUndos) != null ? F : []), f.unshift(...(K = k.preRedos) != null ? K : []), C.unshift(...k.undos), L(f, t).result) {
      const J = i.afterCommandExecute({
        id: rn.id,
        params: { range: m }
      });
      return L(J.redos, t), C.push(...J.undos), f.push(...J.redos), s.pushUndoRedo({
        unitID: h,
        undoMutations: C.reverse(),
        redoMutations: f
      }), !0;
    }
    return !1;
  }
  // all subsequent mutations should succeed in order to make the whole process succeed
  // Promise.all([]).then(() => true),
}, Dr = "sheet.command.insert-row", Ye = {
  type: v.COMMAND,
  id: Dr,
  handler: async (n, e) => {
    const t = n.get(E), s = n.get(G), { range: o, direction: r, unitId: i, subUnitId: a, cellValue: u } = e;
    return await s.beforeCommandExecute({
      id: Ye.id,
      params: e
    }) ? t.syncExecuteCommand(Ar.id, {
      range: o,
      direction: r,
      unitId: i,
      subUnitId: a,
      cellValue: u
    }) : !1;
  }
}, Ar = {
  type: v.COMMAND,
  id: "sheet.command.insert-row-by-range",
  handler: (n, e) => {
    var U, T, k, D;
    const t = n.get(E), s = n.get(V), o = n.get(M), r = n.get(G), i = P(o, e);
    if (!i) return !1;
    const { workbook: a, worksheet: u } = i, { range: l, direction: c, unitId: d, subUnitId: h, cellValue: g } = e, { startRow: m, endRow: f } = l;
    l.rangeType = j.ROW;
    const C = c === pe.UP ? m : m - 1, p = u.getRowHeight(C), w = {
      unitId: d,
      subUnitId: h,
      range: l,
      rowInfo: new Array(f - m + 1).fill(void 0).map(() => ({
        h: p,
        hd: te.FALSE
      }))
      // row height should inherit from the anchor row
    }, S = Ws(
      n,
      w
    ), I = [{ id: ke.id, params: w }], y = [{ id: Te.id, params: S }];
    g && Object.keys(g).length > 0 && I.push({
      id: ee.id,
      params: {
        unitId: d,
        subUnitId: h,
        cellValue: g
      }
    });
    const b = r.onCommandExecute({
      id: Ye.id,
      params: e
    });
    if (I.unshift(...(U = b.preRedos) != null ? U : []), I.push(...(T = b.redos) != null ? T : []), I.push(ut(l, a, u)), y.unshift(...(k = b.preUndos) != null ? k : []), y.push(...(D = b.undos) != null ? D : []), L(I, t).result) {
      const H = r.afterCommandExecute({
        id: Ye.id,
        params: e
      });
      return L(H.redos, t), I.push(...H.redos), y.push(...H.undos), s.pushUndoRedo({
        unitID: e.unitId,
        undoMutations: y,
        redoMutations: I
      }), !0;
    }
    return !1;
  }
}, ol = {
  type: v.COMMAND,
  id: "sheet.command.insert-row-before",
  handler: async (n, e) => {
    var C;
    const s = (C = n.get(z).getCurrentSelections()) == null ? void 0 : C.map((p) => p.range);
    let o;
    if ((s == null ? void 0 : s.length) === 1)
      o = s[0];
    else
      return !1;
    const r = n.get(M), i = P(r);
    if (!i) return !1;
    const { worksheet: a, subUnitId: u, unitId: l } = i, c = e.value || 0, d = o.startRow, h = o.startRow + c - 1, g = 0, m = a.getColumnCount() - 1, f = {
      unitId: l,
      subUnitId: u,
      direction: pe.UP,
      range: {
        startRow: d,
        endRow: h,
        startColumn: g,
        endColumn: m
      },
      // copy styles from the row above
      cellValue: Ct(a, d, h, g, m, !0, d - 1)
    };
    return n.get(E).executeCommand(Ye.id, f);
  }
}, rl = {
  type: v.COMMAND,
  id: "sheet.command.insert-row-after",
  handler: async (n) => {
    var f;
    const t = (f = n.get(z).getCurrentSelections()) == null ? void 0 : f.map((C) => C.range);
    let s;
    if ((t == null ? void 0 : t.length) === 1)
      s = t[0];
    else
      return !1;
    const o = n.get(M), r = P(o);
    if (!r) return !1;
    const { worksheet: i, unitId: a, subUnitId: u } = r, l = s.endRow - s.startRow + 1, c = s.endRow + 1, d = s.endRow + l, h = 0, g = i.getColumnCount() - 1, m = {
      unitId: a,
      subUnitId: u,
      direction: pe.DOWN,
      range: {
        startRow: c,
        endRow: d,
        startColumn: h,
        endColumn: g,
        rangeType: j.ROW
      },
      // copy styles from the row below
      cellValue: Ct(i, c, d, h, g, !0, s.endRow)
    };
    return n.get(E).executeCommand(Ye.id, m);
  }
}, il = {
  type: v.COMMAND,
  id: "sheet.command.insert-multi-rows-above",
  handler: async (n, e) => {
    var p;
    const s = (p = n.get(z).getCurrentSelections()) == null ? void 0 : p.map((w) => w.range);
    let o;
    if ((s == null ? void 0 : s.length) === 1)
      o = s[0];
    else
      return !1;
    const r = n.get(M), i = P(r);
    if (!i) return !1;
    const { worksheet: a, unitId: u, subUnitId: l } = i, c = e.value || 0, d = o.startRow, h = o.startRow + c - 1, g = 0, m = a.getColumnCount() - 1, f = Ct(a, d, h, g, m, !0, d - 1), C = {
      unitId: u,
      subUnitId: l,
      direction: pe.UP,
      range: {
        startRow: d,
        endRow: h,
        startColumn: g,
        endColumn: m,
        rangeType: j.ROW
      },
      // copy styles from the row above
      cellValue: f
    };
    return n.get(E).executeCommand(Ye.id, C);
  }
}, al = {
  type: v.COMMAND,
  id: "sheet.command.insert-multi-rows-after",
  handler: async (n, e) => {
    var C;
    const s = (C = n.get(z).getCurrentSelections()) == null ? void 0 : C.map((p) => p.range);
    let o;
    if ((s == null ? void 0 : s.length) === 1)
      o = s[0];
    else
      return !1;
    const r = n.get(M), i = P(r);
    if (!i) return !1;
    const { worksheet: a, unitId: u, subUnitId: l } = i, c = e.value || 0, d = o.endRow + 1, h = o.endRow + c, g = 0, m = a.getColumnCount() - 1, f = {
      unitId: u,
      subUnitId: l,
      direction: pe.DOWN,
      range: {
        startRow: d,
        endRow: h,
        startColumn: g,
        endColumn: m,
        rangeType: j.ROW
      },
      // copy styles from the row below
      cellValue: Ct(a, d, h, g, m, !0, o.endRow)
    };
    return n.get(E).executeCommand(Ye.id, f);
  }
}, xr = "sheet.command.insert-col", Xe = {
  type: v.COMMAND,
  id: xr,
  handler: async (n, e) => {
    const t = n.get(E), s = n.get(G), { range: o, direction: r, subUnitId: i, unitId: a, cellValue: u } = e;
    return await s.beforeCommandExecute({
      id: Xe.id,
      params: e
    }) ? t.syncExecuteCommand($r.id, {
      range: o,
      direction: r,
      unitId: a,
      subUnitId: i,
      cellValue: u
    }) : !1;
  }
}, $r = {
  type: v.COMMAND,
  id: "sheet.command.insert-col-by-range",
  handler: (n, e) => {
    var N, U, T, k;
    const t = n.get(E), s = n.get(V), o = n.get(M), r = n.get(G), { range: i, direction: a, subUnitId: u, unitId: l, cellValue: c } = e, { startColumn: d, endColumn: h } = e.range;
    i.rangeType = j.COLUMN;
    const g = o.getUniverSheetInstance(e.unitId), m = g.getSheetBySheetId(e.subUnitId), f = a === pe.LEFT ? d : d - 1, C = m.getColumnWidth(f), p = {
      unitId: l,
      subUnitId: u,
      range: i,
      colInfo: new Array(h - d + 1).fill(void 0).map(() => ({
        w: C,
        hd: te.FALSE
      }))
    }, w = as(
      n,
      p
    ), S = [{ id: Ue.id, params: p }], I = [{ id: Me.id, params: w }];
    c && S.push({
      id: ee.id,
      params: {
        unitId: l,
        subUnitId: u,
        cellValue: c
      }
    });
    const y = r.onCommandExecute({
      id: Xe.id,
      params: e
    });
    if (S.unshift(...(N = y.preRedos) != null ? N : []), S.push(...(U = y.redos) != null ? U : []), S.push(ut(i, g, m)), I.unshift(...(T = y.preUndos) != null ? T : []), I.push(...(k = y.undos) != null ? k : []), L(S, t).result) {
      const D = r.afterCommandExecute({
        id: Xe.id,
        params: e
      });
      return L(D.redos, t), S.push(...D.redos), I.push(...D.undos), s.pushUndoRedo({
        unitID: e.unitId,
        undoMutations: I.filter(Boolean),
        redoMutations: S.filter(Boolean)
      }), !0;
    }
    return !1;
  }
}, ul = {
  type: v.COMMAND,
  id: "sheet.command.insert-col-before",
  handler: async (n, e) => {
    const s = n.get(z).getCurrentSelections();
    let o;
    if ((s == null ? void 0 : s.length) === 1)
      o = s[0].range;
    else
      return !1;
    const r = n.get(M), i = P(r);
    if (!i) return !1;
    const { worksheet: a, unitId: u, subUnitId: l } = i, c = e.value || 0, d = o.startColumn, h = o.startColumn + c - 1, g = 0, m = a.getRowCount() - 1, f = {
      unitId: u,
      subUnitId: l,
      direction: pe.LEFT,
      range: {
        startColumn: d,
        endColumn: h,
        startRow: g,
        endRow: m,
        rangeType: j.COLUMN
      },
      // copy styles from the column before
      cellValue: Ct(a, g, m, d, h, !1, d - 1)
    };
    return n.get(E).executeCommand(Xe.id, f);
  }
}, ll = {
  type: v.COMMAND,
  id: "sheet.command.insert-col-after",
  handler: async (n) => {
    const t = n.get(z).getCurrentSelections();
    let s;
    if ((t == null ? void 0 : t.length) === 1)
      s = t[0].range;
    else
      return !1;
    const o = n.get(M), r = P(o);
    if (!r) return !1;
    const { worksheet: i, unitId: a, subUnitId: u } = r, l = s.endColumn - s.startColumn + 1, c = s.endColumn + 1, d = s.endColumn + l, h = 0, g = i.getRowCount() - 1, m = {
      unitId: a,
      subUnitId: u,
      direction: pe.RIGHT,
      range: {
        startColumn: c,
        endColumn: d,
        startRow: h,
        endRow: g
      },
      // copy styles from the column after
      cellValue: Ct(i, h, g, c, d, !1, s.endColumn)
    };
    return n.get(E).executeCommand(Xe.id, m);
  }
}, cl = {
  type: v.COMMAND,
  id: "sheet.command.insert-multi-cols-before",
  handler: async (n, e) => {
    const s = n.get(z).getCurrentSelections();
    let o;
    if ((s == null ? void 0 : s.length) === 1)
      o = s[0].range;
    else
      return !1;
    const r = n.get(M), i = P(r);
    if (!i) return !1;
    const { worksheet: a, unitId: u, subUnitId: l } = i, c = e.value || 0, d = o.startColumn, h = o.startColumn + c - 1, g = 0, m = a.getRowCount() - 1, f = {
      unitId: u,
      subUnitId: l,
      direction: pe.LEFT,
      range: {
        startColumn: d,
        endColumn: h,
        startRow: g,
        endRow: m,
        rangeType: j.COLUMN
      },
      // copy styles from the column before
      cellValue: Ct(a, g, m, d, h, !1, d - 1)
    };
    return n.get(E).executeCommand(Xe.id, f);
  }
}, dl = {
  type: v.COMMAND,
  id: "sheet.command.insert-multi-cols-right",
  handler: async (n, e) => {
    const s = n.get(z).getCurrentSelections();
    let o;
    if ((s == null ? void 0 : s.length) === 1)
      o = s[0].range;
    else
      return !1;
    const r = n.get(M), i = P(r);
    if (!i) return !1;
    const { worksheet: a, unitId: u, subUnitId: l } = i, c = e.value || 0, d = o.endColumn + 1, h = o.endColumn + c, g = 0, m = a.getRowCount() - 1, f = {
      unitId: u,
      subUnitId: l,
      direction: pe.RIGHT,
      range: {
        startColumn: d,
        endColumn: h,
        startRow: g,
        endRow: m
      },
      // copy styles from the column after
      cellValue: Ct(a, g, m, d, h, !1, o.endColumn)
    };
    return n.get(E).executeCommand(Xe.id, f);
  }
}, xn = "sheet.command.remove-row", Wr = {
  type: v.COMMAND,
  id: "sheet.command.remove-row-by-range",
  handler: (n, e) => {
    var C, p, w;
    if (!e)
      return !1;
    const t = n.get(M), s = P(t, e);
    if (!s) return !1;
    const { workbook: o, worksheet: r } = s, i = n.get(G), { range: a, unitId: u, subUnitId: l } = e, c = ls([a], n, u, l).reverse(), d = [], h = [];
    c.forEach((S) => {
      const I = [], y = [], b = {
        unitId: u,
        subUnitId: l,
        range: S
      }, N = Fa(
        b,
        r
      ), U = r.getCellMatrix().getSlice(S.startRow, S.endRow, 0, r.getColumnCount() - 1), T = {
        unitId: u,
        subUnitId: l,
        cellValue: U.getMatrix()
      };
      y.push({ id: Te.id, params: b }), I.push({ id: ke.id, params: N }), I.push({ id: ee.id, params: T }), h.push(...y), d.unshift(...I);
    });
    const g = i.onCommandExecute({
      id: xn,
      params: { range: a }
    }), m = n.get(E);
    if (L(
      [
        ...(C = g.preRedos) != null ? C : [],
        ...h,
        ...g.redos,
        ut(a, o, r)
      ],
      m
    ).result) {
      const S = i.afterCommandExecute({
        id: xn,
        params: { range: a }
      });
      return L(S.redos, m), n.get(V).pushUndoRedo({
        unitID: u,
        undoMutations: [
          ...(p = g.preUndos) != null ? p : [],
          ...d,
          ...g.undos,
          ...S.undos
        ],
        redoMutations: [
          ...(w = g.preRedos) != null ? w : [],
          ...h,
          ...g.redos,
          ...S.redos
        ]
      }), !0;
    }
    return !1;
  }
}, hs = {
  type: v.COMMAND,
  id: xn,
  handler: async (n, e) => {
    var h;
    const t = n.get(z), s = n.get(G), o = n.get(E);
    let r = e == null ? void 0 : e.range;
    if (r || (r = (h = t.getCurrentLastSelection()) == null ? void 0 : h.range), !r) return !1;
    const i = n.get(M), a = P(i);
    if (!a) return !1;
    const { worksheet: u, subUnitId: l, unitId: c } = a;
    return r = {
      ...r,
      startColumn: 0,
      endColumn: Math.max(u.getMaxColumns() - 1, 0)
    }, await s.beforeCommandExecute({
      id: hs.id,
      params: { range: r }
    }) ? o.syncExecuteCommand(Wr.id, {
      range: r,
      unitId: c,
      subUnitId: l
    }) : !1;
  }
}, $n = "sheet.command.remove-col", Vr = {
  type: v.COMMAND,
  id: "sheet.command.remove-col-by-range",
  handler: (n, e) => {
    var p, w, S;
    if (!e)
      return !1;
    const t = n.get(M), s = P(t, e);
    if (!s) return !1;
    const { workbook: o, worksheet: r } = s, i = n.get(G), { range: a, unitId: u, subUnitId: l } = e, c = {
      unitId: u,
      subUnitId: l,
      range: a
    }, d = Ba(n, c), h = r.getCellMatrix().getSlice(0, r.getRowCount() - 1, a.startColumn, a.endColumn), g = {
      unitId: u,
      subUnitId: l,
      cellValue: h.getMatrix()
    }, m = i.onCommandExecute({
      id: $n,
      params: { range: a }
    }), f = n.get(E);
    if (L(
      [
        ...(p = m.preRedos) != null ? p : [],
        { id: Me.id, params: c },
        ...m.redos,
        ut(a, o, r)
      ],
      f
    ).result) {
      const I = i.afterCommandExecute({
        id: $n,
        params: { range: a }
      });
      return L(I.redos, f), n.get(V).pushUndoRedo({
        unitID: u,
        undoMutations: [
          ...(w = m.preUndos) != null ? w : [],
          { id: Ue.id, params: d },
          { id: ee.id, params: g },
          ...m.undos,
          ...I.undos
        ],
        redoMutations: [
          ...(S = m.preRedos) != null ? S : [],
          { id: Me.id, params: c },
          ...m.redos,
          ...I.redos
        ]
      }), !0;
    }
    return !1;
  }
}, gs = {
  type: v.COMMAND,
  id: $n,
  handler: async (n, e) => {
    var h;
    const t = n.get(z), s = n.get(G), o = n.get(E);
    let r = e == null ? void 0 : e.range;
    if (r || (r = (h = t.getCurrentLastSelection()) == null ? void 0 : h.range), !r) return !1;
    const i = n.get(M), a = P(i);
    if (!a) return !1;
    const { worksheet: u, subUnitId: l, unitId: c } = a;
    return r = {
      ...r,
      startRow: 0,
      endRow: Math.max(u.getMaxRows() - 1, 0)
    }, await s.beforeCommandExecute({
      id: gs.id,
      params: { range: r }
    }) ? o.syncExecuteCommand(Vr.id, {
      range: r,
      unitId: c,
      subUnitId: l
    }) : !1;
  }
}, hl = (n, e) => {
  const t = n.get(M), { subUnitId: s, unitId: o } = e, r = Qe(t, e);
  if (!r)
    throw new Error("[RemoveSheetUndoMutationFactory]: Worksheet is null error!");
  const { workbook: i, worksheet: a } = r, u = a.getConfig();
  return {
    index: i.getConfig().sheetOrder.findIndex((d) => d === s),
    sheet: u,
    unitId: o
  };
}, Lt = {
  id: "sheet.mutation.remove-sheet",
  type: v.MUTATION,
  handler: (n, e) => {
    const t = n.get(M), { subUnitId: s, unitId: o } = e, r = t.getUniverSheetInstance(o);
    return r ? r.removeSheet(s) : !1;
  }
};
function gl(n, e) {
  return e.getMergeData().some((t) => t.startRow < n && n <= t.endRow);
}
function ml(n, e) {
  return e.getMergeData().some((t) => t.startColumn < n && n <= t.endColumn);
}
const Lr = "sheet.command.move-rows", an = {
  id: Lr,
  type: v.COMMAND,
  // eslint-disable-next-line max-lines-per-function
  handler: (n, e) => {
    var H, F;
    const t = n.get(z), {
      fromRange: { startRow: s },
      toRange: { startRow: o },
      range: r
    } = e, i = r ? [Fr(r)] : t.getCurrentSelections(), a = i == null ? void 0 : i.filter(
      (K) => K.range.rangeType === j.ROW && K.range.startRow <= s && s <= K.range.endRow
    );
    if ((a == null ? void 0 : a.length) !== 1)
      return !1;
    const u = n.get(G), l = n.get(M), c = P(l, e);
    if (!c) return !1;
    const { workbook: d, worksheet: h } = c, g = d.getUnitId(), m = h.getSheetId(), f = n.get(Vt), C = n.get(it), p = a[0].range, w = a[0].primary, S = cs(p, h, !1);
    if (!O.equals(p, S))
      return f.emit(C.t("sheets.info.partOfCell")), !1;
    if (gl(o, h))
      return f.emit(C.t("sheets.info.acrossMergedCell")), !1;
    const I = {
      ...p,
      startRow: o,
      endRow: o + p.endRow - p.startRow
    }, y = {
      unitId: g,
      subUnitId: m,
      sourceRange: p,
      targetRange: I
    }, b = La(n, y), N = n.get(E), U = u.onCommandExecute({ id: an.id, params: e }), T = [
      ...(H = U.preRedos) != null ? H : [],
      { id: Je.id, params: y }
    ], k = [
      ...(F = U.preUndos) != null ? F : [],
      { id: Je.id, params: b }
    ];
    if (w) {
      const J = o - s < 0, ae = p.endRow - p.startRow + 1, oe = J ? I : {
        ...I,
        startRow: I.startRow - ae,
        endRow: I.endRow - ae
      }, le = {
        unitId: g,
        subUnitId: m,
        type: we.MOVE_END,
        selections: [{
          range: oe,
          primary: _e(oe, h),
          style: null
        }]
      }, Se = {
        unitId: g,
        subUnitId: m,
        type: we.MOVE_END,
        selections: [{ range: p, primary: w, style: null }]
      };
      T.push({ id: ie.id, params: le }), k.push({ id: ie.id, params: Se });
    }
    if (T.push(...U.redos), k.push(...U.undos), L(T, N).result) {
      const K = u.afterCommandExecute({
        id: an.id,
        params: e
      });
      return L(K.redos, N), T.push(...K.redos), k.push(...K.undos), n.get(V).pushUndoRedo({
        unitID: g,
        undoMutations: k,
        redoMutations: T
      }), !0;
    }
    return !1;
  }
}, Hr = "sheet.command.move-cols", un = {
  id: Hr,
  type: v.COMMAND,
  // eslint-disable-next-line max-lines-per-function
  handler: (n, e) => {
    var H, F;
    const t = n.get(z), {
      fromRange: { startColumn: s },
      toRange: { startColumn: o },
      range: r
    } = e, i = r ? [Fr(r)] : t.getCurrentSelections(), a = i == null ? void 0 : i.filter(
      (K) => K.range.rangeType === j.COLUMN && K.range.startColumn <= s && s <= K.range.endColumn
    );
    if ((a == null ? void 0 : a.length) !== 1)
      return !1;
    const u = n.get(G), l = n.get(M), c = P(l, e);
    if (!c) return !1;
    const { workbook: d, worksheet: h } = c, g = d.getUnitId(), m = h.getSheetId(), f = n.get(Vt), C = n.get(it), p = a[0].range, w = a[0].primary, S = cs(p, h, !1);
    if (!O.equals(p, S))
      return f.emit(C.t("sheets.info.partOfCell")), !1;
    if (ml(o, h))
      return f.emit(C.t("sheets.info.acrossMergedCell")), !1;
    const I = {
      ...p,
      startColumn: o,
      endColumn: o + p.endColumn - p.startColumn
    }, y = {
      unitId: g,
      subUnitId: m,
      sourceRange: p,
      targetRange: I
    }, b = Ha(n, y), N = n.get(E), U = u.onCommandExecute({ id: un.id, params: e }), T = [
      ...(H = U.preRedos) != null ? H : [],
      { id: qe.id, params: y }
    ], k = [
      ...(F = U.preUndos) != null ? F : [],
      { id: qe.id, params: b }
    ];
    if (w) {
      const K = p.endColumn - p.startColumn + 1, oe = o - s < 0 ? I : {
        ...I,
        startColumn: I.startColumn - K,
        endColumn: I.endColumn - K
      }, le = {
        unitId: g,
        subUnitId: m,
        type: we.MOVE_END,
        selections: [{ range: oe, primary: _e(oe, h), style: null }]
      }, Se = {
        unitId: g,
        subUnitId: m,
        type: we.MOVE_END,
        selections: [{ range: p, primary: w, style: null }]
      };
      T.push({ id: ie.id, params: le }), k.push({ id: ie.id, params: Se });
    }
    if (T.push(...U.redos), k.push(...U.undos), L(T, N).result) {
      const K = u.afterCommandExecute({
        id: un.id,
        params: e
      });
      return L(K.redos, N), T.push(...K.redos), k.push(...K.undos), n.get(V).pushUndoRedo({
        unitID: g,
        undoMutations: k,
        redoMutations: T
      }), !0;
    }
    return !1;
  }
};
function Fr(n) {
  return {
    range: n,
    primary: null,
    style: null
  };
}
var fl = Object.getOwnPropertyDescriptor, Rl = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? fl(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, Cl = (n, e) => (t, s) => e(t, s, n);
let rt = class extends ue {
  constructor(e) {
    super();
    R(this, "_sheetSkeletonStore", /* @__PURE__ */ new Map());
    this._injector = e, this.disposeWithMe(() => {
      this._sheetSkeletonStore = /* @__PURE__ */ new Map();
    });
  }
  getSkeleton(e, t) {
    if (this._sheetSkeletonStore.has(e))
      return this._sheetSkeletonStore.get(e).get(t);
  }
  setSkeleton(e, t, s) {
    this._sheetSkeletonStore.has(e) || this._sheetSkeletonStore.set(e, /* @__PURE__ */ new Map()), this._sheetSkeletonStore.get(e).set(t, s);
  }
  deleteSkeleton(e, t) {
    this._sheetSkeletonStore.has(e) && this._sheetSkeletonStore.get(e).delete(t);
  }
};
rt = Rl([
  Cl(0, $(is))
], rt);
function qs(n, e) {
  const t = new Y();
  return n.map((s) => X.transformRange(s, e)).forEach((s) => {
    X.foreach(s, (o, r) => {
      const i = e.getCellHeight(o, r);
      i && t.setValue(o, r, i);
    });
  }), t;
}
const pl = 1e4;
function wn(n, e) {
  if (!e)
    return { suitableRanges: n, remainingRanges: [] };
  const t = e.worksheet.getColumnCount(), s = Math.ceil(pl / t), o = [], r = [], i = e.getOffsetRelativeToRowCol(0, e.scrollY).row, a = n.map((l) => {
    let c;
    return i >= l.startRow && i <= l.endRow ? c = 0 : i < l.startRow ? c = l.startRow - i : c = i - l.endRow, {
      range: l,
      distance: c,
      rowCount: l.endRow - l.startRow + 1
      // Number of rows in the range
    };
  });
  a.sort((l, c) => l.distance !== c.distance ? l.distance - c.distance : l.rowCount - c.rowCount);
  let u = 0;
  for (const l of a)
    if (u + l.rowCount <= s)
      o.push(l.range), u += l.rowCount;
    else {
      const c = s - u;
      if (c > 0) {
        const d = {
          ...l.range,
          endRow: l.range.startRow + c - 1
        }, h = {
          ...l.range,
          startRow: l.range.startRow + c
        };
        o.push(d), r.push(h), u = s;
      } else
        r.push(l.range);
    }
  return { suitableRanges: o, remainingRanges: r };
}
function Sl(n) {
  let e = 0;
  return n.forEach(() => {
    e++;
  }), e;
}
const Br = "sheet.command.reorder-range", ks = {
  id: Br,
  type: v.COMMAND,
  handler: (n, e) => {
    var S, I;
    const { subUnitId: t, unitId: s, range: o, order: r } = e, i = n.get(E), a = {
      id: On.id,
      params: {
        unitId: s,
        subUnitId: t,
        order: r,
        range: o
      }
    }, u = {
      id: On.id,
      params: ja(a.params)
    }, l = n.get(G), c = l.onCommandExecute({ id: ks.id, params: e }), d = [
      ...(S = c.preRedos) != null ? S : [],
      a,
      ...c.redos
    ], h = [
      ...(I = c.preUndos) != null ? I : [],
      u,
      ...c.undos
    ], g = L(d, i), { suitableRanges: m, remainingRanges: f } = wn([o], n.get(rt).getSkeleton(s, t)), { undos: C, redos: p } = l.generateMutationsOfAutoHeight({
      unitId: s,
      subUnitId: t,
      ranges: [o],
      autoHeightRanges: m,
      lazyAutoHeightRanges: f
    }), w = l.afterCommandExecute({ id: ks.id, params: e });
    return g.result ? (L([...w.redos, ...p], i), n.get(V).pushUndoRedo({
      unitID: s,
      undoMutations: [...h, ...w.undos, ...C],
      redoMutations: [...d, ...w.redos, ...p]
    }), !0) : !1;
  }
}, W = {
  MoveRangeCommandId: or,
  InsertRowCommandId: Dr,
  InsertColCommandId: xr,
  RemoveColCommandId: $n,
  RemoveRowCommandId: xn,
  DeleteRangeMoveLeftCommandId: Nr,
  DeleteRangeMoveUpCommandId: Or,
  InsertRangeMoveDownCommandId: sl,
  InsertRangeMoveRightCommandId: Js,
  MoveColsCommandId: Hr,
  MoveRowsCommandId: Lr,
  ReorderRangeCommandId: Br
};
var Q = /* @__PURE__ */ ((n) => (n[n.Set = 0] = "Set", n[n.Delete = 1] = "Delete", n[n.HorizontalMove = 2] = "HorizontalMove", n[n.VerticalMove = 3] = "VerticalMove", n[n.Unknown = 4] = "Unknown", n))(Q || {});
const _n = Number.MAX_SAFE_INTEGER, Ke = (n) => {
  const e = { ...n }, t = Number.isNaN(e.startRow) && Number.isNaN(e.endRow) && !Number.isNaN(e.startColumn) && !Number.isNaN(e.endColumn), s = Number.isNaN(e.startColumn) && Number.isNaN(e.endColumn) && !Number.isNaN(e.startRow) && !Number.isNaN(e.endRow);
  return (e.rangeType === j.COLUMN || t) && (e.startRow = 0, e.endRow = _n), (e.rangeType === j.ROW || s) && (e.startColumn = 0, e.endColumn = _n), e.rangeType === j.ALL && (e.startColumn = 0, e.endColumn = _n, e.startRow = 0, e.endRow = _n), e;
}, Oe = (n) => {
  let e = n.rangeType;
  return n.rangeType === j.COLUMN ? e = j.ROW : n.rangeType === j.ROW && (e = j.COLUMN), {
    startRow: n.startColumn,
    endRow: n.endColumn,
    startColumn: n.startRow,
    endColumn: n.endRow,
    rangeType: e
  };
}, Wn = (n, e, t) => {
  const s = { ...t }, o = { ...e }, r = (f, C) => {
    const p = Math.max(f.start, C.start), w = Math.min(f.end, C.end);
    return w < p ? null : { start: p, end: w };
  }, i = (f) => f.end - f.start + 1, a = (f, C) => ({
    start: f.start - C.start,
    end: f.start - C.start + f.end - f.start
  }), u = (f, C) => ({
    start: C.start + f.start,
    end: C.start + f.start + f.end - f.start
  }), l = e.start > n.start;
  if (l) {
    const f = Math.min(n.end, e.start) - n.start + 1;
    o.start -= f, o.end -= f;
  }
  const c = i(n), d = c, h = r(n, s), g = h && i(h) >= i(s);
  if (n.end < s.start)
    s.start -= c, s.end -= c;
  else if (h) {
    const f = i(h);
    if (g) {
      const C = a(s, n), p = u(C, o);
      s.start = p.start, s.end = p.end;
    } else h.start > n.start ? l ? (s.end -= f + c, s.start -= c) : s.end -= f : l ? s.end -= f : s.start > n.start && s.end > n.end ? (s.start -= c, s.end -= c + f) : s.end -= f;
  }
  const m = r(o, s);
  return g || (o.start <= s.start ? (s.start += d, s.end += d) : m && (l ? o.end <= s.start || o.start <= s.start && o.end >= s.start ? (s.start += d, s.end += d) : o.start >= s.start && o.start <= s.end && (s.end += d) : s.start < o.start && s.end > o.start ? s.end += d : (s.start >= o.end || s.start >= o.start && s.start <= o.end) && (s.end += d, s.start += d))), {
    step: s.start - t.start,
    length: i(s) - i(t)
  };
}, jr = (n, e) => {
  const { fromRange: t, toRange: s } = n.params || {};
  if (!s || !t)
    return [];
  const o = Ke(t), r = Ke(s), i = Ke(e), a = Wn(
    { start: o.startRow, end: o.endRow },
    { start: r.startRow, end: r.endRow },
    { start: i.startRow, end: i.endRow }
  );
  return a === null ? [
    {
      type: Q.Delete
    }
  ] : [
    {
      type: Q.VerticalMove,
      step: a.step || 0,
      length: a.length || 0
    }
  ];
}, wl = (n, e) => {
  const { fromRange: t, toRange: s } = n.params || {};
  if (!t || !s)
    return [e];
  const o = t.startRow, r = t.endRow - t.startRow + 1, i = s.startRow, a = new Y();
  return X.foreach(e, (l, c) => {
    a.setValue(l, c, 1);
  }), a.moveRows(o, r, i), at(a, (l) => l === 1);
}, Il = (n, e) => {
  const { range: t, order: s } = n.params || {};
  if (!t || !s)
    return [e];
  const o = new Y();
  X.foreach(e, (a, u) => {
    o.setValue(a, u, 1);
  });
  const r = new Y();
  return X.foreach(t, (a, u) => {
    var l;
    if (Object.prototype.hasOwnProperty.call(s, a)) {
      const c = s[a], d = (l = o.getValue(c, u)) != null ? l : 0;
      r.setValue(a, u, d);
    }
  }), r.forValue((a, u, l) => {
    o.setValue(a, u, l);
  }), at(o, (a) => a === 1);
}, zr = (n, e) => {
  const { fromRange: t, toRange: s } = n.params || {};
  if (!s || !t)
    return [];
  const o = Ke(t), r = Ke(s), i = Ke(e), a = Wn(
    { start: o.startColumn, end: o.endColumn },
    { start: r.startColumn, end: r.endColumn },
    { start: i.startColumn, end: i.endColumn }
  );
  return a === null ? [
    {
      type: Q.Delete
    }
  ] : [
    {
      type: Q.HorizontalMove,
      step: a.step || 0,
      length: a.length || 0
    }
  ];
}, vl = (n, e) => {
  const { fromRange: t, toRange: s } = n.params || {};
  if (!t || !s)
    return [e];
  const o = t.startColumn, r = t.endColumn - t.startColumn + 1, i = s.startColumn, a = new Y();
  return X.foreach(e, (u, l) => {
    a.setValue(u, l, 1);
  }), a.moveColumns(o, r, i), at(a, (u) => u === 1);
}, Ml = (n, e) => {
  var r, i;
  const t = (r = n.params) == null ? void 0 : r.toRange, s = (i = n.params) == null ? void 0 : i.fromRange;
  if (!t || !s)
    return [];
  const o = [];
  if (O.contains(t, e) && o.push({
    type: Q.Delete
  }), O.contains(s, e)) {
    o.push({
      type: Q.Delete
    });
    const a = O.getRelativeRange(e, s), u = O.getPositionRange(a, t);
    return [
      {
        type: Q.Set,
        range: u
      }
    ];
  }
  return o;
}, _l = (n, e) => {
  var d, h;
  const t = (d = n.params) == null ? void 0 : d.toRange, s = (h = n.params) == null ? void 0 : h.fromRange;
  if (!t || !s)
    return [e];
  if (!O.intersects(s, e) && !O.intersects(t, e))
    return [e];
  if (O.contains(s, e)) {
    const g = O.getRelativeRange(e, s);
    return [O.getPositionRange(g, t)];
  }
  const o = new Y();
  X.foreach(e, (g, m) => {
    o.setValue(g, m, 1);
  });
  const r = new Y(), i = O.getIntersects(s, e);
  i && X.foreach(i, (g, m) => {
    o.getValue(g, m) && (o.setValue(g, m, void 0), r.setValue(g, m, 1));
  });
  const a = t.startColumn - s.startColumn, u = t.startRow - s.startRow, l = {
    startColumn: t.startColumn - a,
    endColumn: t.endColumn - a,
    startRow: t.startRow - u,
    endRow: t.endRow - u
  };
  return l && X.foreach(l, (g, m) => {
    var p;
    const f = g + u, C = m + a;
    o.setValue(f, C, (p = r.getValue(g, m)) != null ? p : 0);
  }), at(o, (g) => g === 1);
}, Nt = (n, e) => {
  const t = Ke(n), s = Ke(e), o = (i) => i.endColumn - i.startColumn + 1, r = (i) => i.endRow - i.startRow + 1;
  if (t.startRow <= s.startRow && t.endRow >= s.endRow) {
    if (
      // 2
      s.startColumn < t.startColumn && s.endColumn >= t.startColumn && s.endColumn <= t.endColumn || // 6
      s.startColumn < t.startColumn && s.endColumn >= t.endColumn
    ) {
      const i = O.getIntersects(s, t);
      if (i)
        return { step: 0, length: -o(i) };
    }
    if (s.startColumn >= t.startColumn && s.endColumn <= t.endColumn && r(t) >= r(s))
      return null;
    if (s.startColumn >= t.startColumn && s.startColumn <= t.endColumn && s.endColumn > t.endColumn) {
      const i = O.getIntersects(s, t);
      if (i) {
        const a = -o(i);
        return { step: -(o(t) - o(i)), length: a };
      }
    }
    if (s.startColumn > t.endColumn)
      return { step: -o(t), length: 0 };
  }
  return { step: 0, length: 0 };
}, Gr = (n, e) => {
  var r;
  const t = (r = n.params) == null ? void 0 : r.range;
  if (!t)
    return [];
  const s = [], o = Nt(t, e);
  if (!o)
    s.push({ type: Q.Delete });
  else {
    const { step: i, length: a } = o;
    s.push({
      type: Q.HorizontalMove,
      step: i,
      length: a
    });
  }
  return s;
}, yl = (n, e, t) => {
  var i;
  const s = (i = n.params) == null ? void 0 : i.range;
  if (!s)
    return [];
  const o = [];
  if (t && t.length > 0) {
    let a = s.startRow;
    for (let u = s.startRow; u <= s.endRow; u++) {
      if (t.includes(u)) {
        if (u === a) {
          a = u + 1;
          continue;
        }
        r({
          ...s,
          startRow: a,
          endRow: u - 1
        }), a = u + 1;
        continue;
      }
      u === s.endRow && r({
        ...s,
        startRow: a,
        endRow: s.endRow
      });
    }
  } else
    r(s);
  function r(a) {
    const u = Nt(Oe(a), Oe(e));
    if (!u)
      o.push({ type: Q.Delete });
    else {
      const { step: l, length: c } = u;
      o.push({
        type: Q.VerticalMove,
        step: l,
        length: c
      });
    }
  }
  return o;
}, bl = (n, e) => {
  const { range: t, order: s } = n.params || {};
  if (!t || !s)
    return [];
  if (O.contains(t, e) && e.endRow === e.startRow) {
    const o = [], r = e.startRow;
    for (const i in s)
      if (s[i] === r) {
        const a = Number(i);
        return o.push({
          type: Q.VerticalMove,
          step: a - r,
          length: 0
        }), o;
      }
    return [];
  }
  return [];
}, Ot = (n, e) => {
  const t = Ke(n), s = Ke(e), o = (r) => r.endColumn - r.startColumn + 1;
  return t.startRow <= s.startRow && t.endRow >= s.endRow ? (
    // 2
    // Case 2: Overlap on the left side
    // Target range starts before the insert range and ends within the insert range boundaries
    // targetRange:  |----------|
    // insertRange:         |-------|
    // insertRange:
    s.startColumn < t.startColumn && s.endColumn >= t.startColumn && s.endColumn <= t.endColumn || // 6
    // Case 6: Fully overlapping on both sides
    // Target range starts before the insert range and ends after the insert range
    // targetRange:  |----------------|
    // insertRange:         |-------|
    s.startColumn < t.startColumn && s.endColumn >= t.endColumn ? { step: 0, length: o(t) } : (
      // 3
      // Case 3: Fully contained
      // Target range is completely within the insert range
      // targetRange:      |---|
      // insertRange:    |-------|
      s.startColumn >= t.startColumn && s.endColumn <= t.endColumn || // 4
      // Case 4: Overlap on the right side
      // Target range starts within the insert range and ends after the insert range
      // targetRange:         |---------|
      // insertRange:    |-------|
      s.startColumn >= t.startColumn && s.startColumn <= t.endColumn && s.endColumn > t.endColumn || //5
      // Case 5: No overlap (target range starts after the insert range ends)
      // targetRange:                |-------|
      // insertRange:    |-------|
      s.startColumn >= t.endColumn ? { step: o(t), length: 0 } : { step: 0, length: 0 }
    )
  ) : { step: 0, length: 0 };
};
function El(n, e, t) {
  const s = [];
  if (O.contains(e, t) && s.push({
    type: Q.Delete
  }), O.contains(n, t)) {
    s.push({
      type: Q.Delete
    });
    const o = O.getRelativeRange(t, n), r = O.getPositionRange(o, e);
    return [
      {
        type: Q.Set,
        range: r
      }
    ];
  }
  return s;
}
const kl = (n, e) => {
  var a;
  const t = (a = n.params) == null ? void 0 : a.range;
  if (!t)
    return [];
  const s = [], o = Ot(Oe(t), Oe(e)), { step: r, length: i } = o;
  return s.push({
    type: Q.VerticalMove,
    step: r,
    length: i
  }), s;
}, Ul = (n, e) => {
  var a;
  const t = (a = n.params) == null ? void 0 : a.range;
  if (!t)
    return [];
  const s = [], o = Ot(t, e), { step: r, length: i } = o;
  return s.push({
    type: Q.HorizontalMove,
    step: r,
    length: i
  }), s;
}, Tl = (n, e) => {
  var a;
  const t = (a = n.params) == null ? void 0 : a.range;
  if (!t)
    return [];
  const s = [], o = Ot(Oe(t), Oe(e)), { step: r, length: i } = o;
  return s.push({
    type: Q.VerticalMove,
    step: r,
    length: i
  }), s;
}, Pl = (n, e) => {
  var u;
  const t = (u = n.params) == null ? void 0 : u.range;
  if (!t)
    return [e];
  const s = t.endRow - t.startRow + 1, o = {
    ...t,
    startRow: t.startRow,
    endRow: Number.POSITIVE_INFINITY
  }, r = O.subtract(e, o), i = O.getIntersects(o, e);
  if (!i)
    return [e];
  const a = new Y();
  return r.forEach((l) => {
    X.foreach(l, (c, d) => {
      a.setValue(c, d, 1);
    });
  }), i && X.foreach(i, (l, c) => {
    a.setValue(l + s, c, 1);
  }), at(a, (l) => l === 1);
}, Nl = (n, e) => {
  var a;
  const t = (a = n.params) == null ? void 0 : a.range;
  if (!t)
    return [];
  const s = [], o = Ot(t, e), { step: r, length: i } = o;
  return s.push({
    type: Q.HorizontalMove,
    step: r,
    length: i
  }), s;
}, Ol = (n, e) => {
  var u;
  const t = (u = n.params) == null ? void 0 : u.range;
  if (!t)
    return [e];
  const s = t.endColumn - t.startColumn + 1, o = {
    ...t,
    startColumn: t.startColumn,
    endColumn: Number.POSITIVE_INFINITY
  }, r = O.subtract(e, o), i = O.getIntersects(o, e);
  if (!i)
    return [e];
  const a = new Y();
  return r.forEach((l) => {
    X.foreach(l, (c, d) => {
      a.setValue(c, d, 1);
    });
  }), i && X.foreach(i, (l, c) => {
    a.setValue(l, c + s, 1);
  }), at(a, (l) => l === 1);
}, Dl = (n, e) => {
  var r;
  const t = (r = n.params) == null ? void 0 : r.range;
  if (!t)
    return [];
  const s = [], o = Nt(t, e);
  if (!o)
    s.push({ type: Q.Delete });
  else {
    const { step: i, length: a } = o;
    s.push({
      type: Q.HorizontalMove,
      step: i,
      length: a
    });
  }
  return s;
}, Al = (n, e) => {
  var l;
  const t = (l = n.params) == null ? void 0 : l.range;
  if (!t)
    return [e];
  const s = {
    startRow: t.startRow,
    endRow: t.endRow,
    startColumn: t.startColumn,
    endColumn: Number.POSITIVE_INFINITY
  }, o = t.endColumn - t.startColumn + 1, r = O.getIntersects(t, e), i = O.subtract(e, s), a = O.getIntersects(s, e);
  if (!r && !a)
    return [e];
  const u = new Y();
  return a && X.foreach(a, (c, d) => {
    u.setValue(c, d - o, 1);
  }), r && X.foreach(r, (c, d) => {
    u.setValue(c, d - o, 0);
  }), i.forEach((c) => {
    X.foreach(c, (d, h) => {
      u.setValue(d, h, 1);
    });
  }), at(u, (c) => c === 1);
}, xl = (n, e) => {
  var r;
  const t = (r = n.params) == null ? void 0 : r.range;
  if (!t)
    return [];
  const s = [], o = Nt(Oe(t), Oe(e));
  if (!o)
    s.push({ type: Q.Delete });
  else {
    const { step: i, length: a } = o;
    s.push({
      type: Q.VerticalMove,
      step: i,
      length: a
    });
  }
  return s;
}, $l = (n, e) => {
  var l;
  const t = (l = n.params) == null ? void 0 : l.range;
  if (!t)
    return [e];
  const s = {
    ...t,
    startRow: t.startRow,
    endRow: Number.POSITIVE_INFINITY
  }, o = t.endRow - t.startRow + 1, r = O.getIntersects(t, e), i = O.subtract(e, s), a = O.getIntersects(s, e);
  if (!r && !a)
    return [e];
  const u = new Y();
  return a && X.foreach(a, (c, d) => {
    u.setValue(c - o, d, 1);
  }), r && X.foreach(r, (c, d) => {
    u.setValue(c - o, d, 0);
  }), i.forEach((c) => {
    X.foreach(c, (d, h) => {
      u.setValue(d, h, 1);
    });
  }), at(u, (c) => c === 1);
}, Wl = (n, e) => {
  var o;
  const t = (o = n.ranges) != null ? o : [n.range], s = new Y();
  return X.foreach(e, (r, i) => {
    s.setValue(r, i, 1);
  }), t.forEach((r) => {
    const i = r.startRow, u = r.endRow - i + 1;
    s.removeRows(i, u);
  }), at(s, (r) => r === 1);
}, Vl = (n, e) => {
  const t = n.params, s = t.range.startRow, o = t.range.endRow - t.range.startRow + 1;
  return e.startRow >= s ? [{
    startRow: e.startRow + o,
    endRow: e.endRow + o,
    startColumn: e.startColumn,
    endColumn: e.endColumn
  }] : e.endRow < s ? [e] : [{
    startRow: e.startRow,
    endRow: e.endRow + o,
    startColumn: e.startColumn,
    endColumn: e.endColumn
  }];
}, Ll = (n, e) => {
  const t = n.params, s = t.range.startColumn, o = t.range.endColumn - t.range.startColumn + 1;
  return e.startColumn >= s ? [{
    startRow: e.startRow,
    endRow: e.endRow,
    startColumn: e.startColumn + o,
    endColumn: e.endColumn + o
  }] : e.endColumn < s ? [e] : [{
    startRow: e.startRow,
    endRow: e.endRow,
    startColumn: e.startColumn,
    endColumn: e.endColumn + o
  }];
}, Dt = (n, e) => {
  let t = { ...e };
  return n.forEach((s) => {
    switch (s.type) {
      case Q.Delete: {
        t = null;
        break;
      }
      case Q.HorizontalMove: {
        if (!t)
          return;
        t.startColumn += s.step, t.endColumn += s.step + (s.length || 0);
        break;
      }
      case Q.VerticalMove: {
        if (!t)
          return;
        t.startRow += s.step, t.endRow += s.step + (s.length || 0);
        break;
      }
      case Q.Set: {
        t = s.range;
        break;
      }
    }
  }), t && (t.endColumn < t.startColumn || t.endRow < t.startRow) ? null : t;
}, po = (n, e) => {
  let t = [];
  switch (e.id) {
    case W.DeleteRangeMoveLeftCommandId: {
      t = Dl(e, n);
      break;
    }
    case W.DeleteRangeMoveUpCommandId: {
      t = xl(e, n);
      break;
    }
    case W.InsertColCommandId: {
      t = Ul(e, n);
      break;
    }
    case W.InsertRangeMoveDownCommandId: {
      t = Tl(e, n);
      break;
    }
    case W.InsertRangeMoveRightCommandId: {
      t = Nl(e, n);
      break;
    }
    case W.InsertRowCommandId: {
      t = kl(e, n);
      break;
    }
    case W.MoveColsCommandId: {
      t = zr(e, n);
      break;
    }
    case W.MoveRangeCommandId: {
      t = Ml(e, n);
      break;
    }
    case W.MoveRowsCommandId: {
      t = jr(e, n);
      break;
    }
    case W.RemoveColCommandId: {
      t = Gr(e, n);
      break;
    }
    case W.RemoveRowCommandId: {
      t = yl(e, n);
      break;
    }
    case W.ReorderRangeCommandId: {
      t = bl(e, n);
      break;
    }
  }
  return Dt(t, n);
}, Kh = (n, e, t) => [It.id, vt.id].includes(e.id) || Kr(e, t).some((r) => O.intersects(r, n)) ? po(n, e) : n, So = (n, e) => {
  let t = [];
  switch (e.id) {
    case W.DeleteRangeMoveLeftCommandId:
      return Al(e, n);
    case W.DeleteRangeMoveUpCommandId:
      return $l(e, n);
    case W.InsertRangeMoveDownCommandId:
      return Pl(e, n);
    case W.InsertRangeMoveRightCommandId:
      return Ol(e, n);
    case W.InsertColCommandId:
      return Ll(e, n);
    case W.InsertRowCommandId:
      return Vl(e, n);
    case W.MoveColsCommandId:
      return vl(e, n);
    case W.MoveRangeCommandId:
      return _l(e, n);
    case W.MoveRowsCommandId:
      return wl(e, n);
    case W.ReorderRangeCommandId:
      return Il(e, n);
    case W.RemoveColCommandId: {
      t = Gr(e, n);
      break;
    }
    case W.RemoveRowCommandId:
      return Wl(e.params, n);
  }
  const s = Dt(t, n);
  return s ? [s] : [];
}, Jh = (n, e, t) => [It.id, vt.id, Pt.id, Js].includes(e.id) || Kr(e, t).some((r) => O.intersects(r, n)) ? So(n, e) : n;
function Hl(n, e) {
  const { id: t, params: s } = e;
  let o = {
    length: 0,
    step: 0,
    type: Q.Unknown
  };
  switch (t) {
    case Lt.id:
      o.type = Q.Delete;
      break;
    case Je.id:
      o = Wn(
        { start: s.sourceRange.startRow, end: s.sourceRange.endRow },
        { start: s.targetRange.startRow, end: s.targetRange.endRow },
        { start: n.startRow, end: n.endRow }
      ), o.type = Q.VerticalMove;
      break;
    case qe.id:
      o = Wn(
        { start: s.sourceRange.startColumn, end: s.sourceRange.endColumn },
        { start: s.targetRange.startColumn, end: s.targetRange.endColumn },
        { start: n.startColumn, end: n.endColumn }
      ), o.type = Q.HorizontalMove;
      break;
    case Me.id:
      o = Nt(s.range, n), o ? o.type = Q.HorizontalMove : o = { step: 0, length: 0, type: Q.Delete };
      break;
    case Te.id:
      o = Nt(Oe(s.range), Oe(n)), o ? o.type = Q.VerticalMove : o = { step: 0, length: 0, type: Q.Delete };
      break;
    case ke.id:
      o = Ot(Oe(s.range), Oe(n)), o.type = Q.VerticalMove;
      break;
    case Ue.id:
      o = Ot(s.range, n), o.type = Q.HorizontalMove;
      break;
    case wt.id:
      {
        const r = s.fromRange || new Y(s.from).getRange(), i = s.toRange || new Y(s.to).getRange();
        o = El(
          r,
          i,
          n
        );
      }
      break;
  }
  return o ? Array.isArray(o) ? Dt(o, n) : Dt([o], n) : n;
}
function Kr(n, e) {
  var s, o, r, i, a, u;
  const { selectionManagerService: t } = e;
  switch (n.id) {
    case W.MoveColsCommandId: {
      const l = n.params;
      return [
        l.fromRange,
        {
          ...l.toRange,
          startColumn: l.toRange.startColumn - 0.5,
          endColumn: l.toRange.endColumn - 0.5
        }
      ];
    }
    case W.MoveRowsCommandId: {
      const l = n.params;
      return [
        l.fromRange,
        {
          ...l.toRange,
          startRow: l.toRange.startRow - 0.5,
          endRow: l.toRange.startRow - 0.5
        }
      ];
    }
    case W.MoveRangeCommandId: {
      const l = n;
      return [l.params.fromRange, l.params.toRange];
    }
    case W.InsertRowCommandId: {
      const c = n.params.range;
      return [
        {
          ...c,
          startRow: c.startRow - 0.5,
          endRow: c.endRow - 0.5
        }
      ];
    }
    case W.InsertColCommandId: {
      const c = n.params.range;
      return [
        {
          ...c,
          startColumn: c.startColumn - 0.5,
          endColumn: c.endColumn - 0.5
        }
      ];
    }
    case W.RemoveRowCommandId:
      return [n.params.range];
    case W.RemoveColCommandId:
      return [n.params.range];
    case W.DeleteRangeMoveUpCommandId:
    case W.InsertRangeMoveDownCommandId: {
      const c = ((s = n.params) == null ? void 0 : s.range) || ((r = (o = t.getCurrentSelections()) == null ? void 0 : o.map((d) => d.range)) == null ? void 0 : r[0]);
      return c ? [c] : [];
    }
    case W.DeleteRangeMoveLeftCommandId:
    case W.InsertRangeMoveRightCommandId: {
      const c = ((i = n.params) == null ? void 0 : i.range) || ((u = (a = t.getCurrentSelections()) == null ? void 0 : a.map((d) => d.range)) == null ? void 0 : u[0]);
      return c ? [c] : [];
    }
    case W.ReorderRangeCommandId: {
      const l = n, { range: c, order: d } = l.params, h = [];
      for (let g = c.startRow; g <= c.endRow; g++)
        g in d && h.push({
          startRow: g,
          endRow: g,
          startColumn: c.startColumn,
          endColumn: c.endColumn
        });
      return h;
    }
  }
}
function Fl(n) {
  switch (n.id) {
    case qe.id: {
      const e = n.params;
      return [
        e.sourceRange,
        {
          ...e.targetRange,
          startColumn: e.targetRange.startColumn - 0.5,
          endColumn: e.targetRange.startColumn - 0.5
        }
      ];
    }
    case Je.id: {
      const e = n.params;
      return [
        e.sourceRange,
        {
          ...e.targetRange,
          startRow: e.targetRange.startRow - 0.5,
          endRow: e.targetRange.startRow - 0.5
        }
      ];
    }
    case wt.id: {
      const e = n.params;
      return [new Y(e.from.value).getRange(), new Y(e.to.value).getRange()];
    }
    case Ue.id: {
      const t = n.params.range;
      return [
        {
          ...t,
          startColumn: t.startColumn - 0.5,
          endColumn: t.startColumn - 0.5
        }
      ];
    }
    case ke.id: {
      const t = n.params.range;
      return [
        {
          ...t,
          startRow: t.startRow - 0.5,
          endRow: t.startRow - 0.5
        }
      ];
    }
    case Me.id:
      return [n.params.range];
    case Te.id:
      return [n.params.range];
  }
}
function qh(n, e) {
  var o, r, i, a, u, l;
  const t = n.get(M), s = n.get(z);
  switch (e.id) {
    case W.MoveColsCommandId: {
      const c = e.params, d = P(t, {
        unitId: c.unitId,
        subUnitId: c.subUnitId
      });
      return {
        unitId: d.unitId,
        subUnitId: d.subUnitId,
        ranges: [
          c.fromRange,
          {
            ...c.toRange,
            startColumn: c.fromRange.startColumn < c.toRange.startColumn ? c.fromRange.endColumn + 1 : c.toRange.startColumn,
            endColumn: c.fromRange.startColumn < c.toRange.startColumn ? c.toRange.endColumn - 1 : c.fromRange.startColumn - 1
          }
        ]
      };
    }
    case W.MoveRowsCommandId: {
      const c = e.params, d = P(t, {
        unitId: c.unitId,
        subUnitId: c.subUnitId
      });
      return {
        unitId: d.unitId,
        subUnitId: d.subUnitId,
        ranges: [
          c.fromRange,
          {
            ...c.toRange,
            startRow: c.fromRange.startRow < c.toRange.startRow ? c.fromRange.endRow + 1 : c.toRange.startRow,
            endRow: c.fromRange.startRow < c.toRange.startRow ? c.toRange.endRow - 1 : c.fromRange.startRow - 1
          }
        ]
      };
    }
    case W.MoveRangeCommandId: {
      const c = e.params, d = P(t);
      return {
        unitId: d.unitId,
        subUnitId: d.subUnitId,
        ranges: [c.fromRange, c.toRange]
      };
    }
    case W.InsertRowCommandId: {
      const c = e.params, d = c.range;
      return {
        unitId: c.unitId,
        subUnitId: c.subUnitId,
        ranges: [
          ...d.startRow > 0 ? [{
            ...d,
            startRow: d.startRow - 1,
            endRow: d.endRow - 1
          }] : [],
          {
            ...d,
            startRow: d.startRow,
            endRow: Number.MAX_SAFE_INTEGER
          }
        ]
      };
    }
    case W.InsertColCommandId: {
      const c = e.params, d = c.range;
      return {
        unitId: c.unitId,
        subUnitId: c.subUnitId,
        ranges: [
          ...d.startColumn > 0 ? [{
            ...d,
            startColumn: d.startColumn - 1,
            endColumn: d.endColumn - 1
          }] : [],
          {
            ...d,
            startColumn: d.startColumn,
            endColumn: Number.MAX_SAFE_INTEGER
          }
        ]
      };
    }
    case W.RemoveRowCommandId: {
      const d = e.params.range, h = P(t);
      return {
        unitId: h.unitId,
        subUnitId: h.subUnitId,
        ranges: [
          d,
          {
            ...d,
            startRow: d.endRow + 1,
            endRow: Number.MAX_SAFE_INTEGER
          }
        ]
      };
    }
    case W.RemoveColCommandId: {
      const d = e.params.range, h = P(t);
      return {
        unitId: h.unitId,
        subUnitId: h.subUnitId,
        ranges: [
          d,
          {
            ...d,
            startColumn: d.endColumn + 1,
            endColumn: Number.MAX_SAFE_INTEGER
          }
        ]
      };
    }
    case W.DeleteRangeMoveUpCommandId:
    case W.InsertRangeMoveDownCommandId: {
      const c = e, d = P(t), h = ((o = c.params) == null ? void 0 : o.range) || ((i = (r = s.getCurrentSelections()) == null ? void 0 : r.map((g) => g.range)) == null ? void 0 : i[0]);
      return h ? {
        unitId: d.unitId,
        subUnitId: d.subUnitId,
        ranges: [
          h,
          {
            ...h,
            startRow: h.endRow + 1,
            endRow: Number.MAX_SAFE_INTEGER
          }
        ]
      } : {
        unitId: d.unitId,
        subUnitId: d.subUnitId,
        ranges: []
      };
    }
    case W.DeleteRangeMoveLeftCommandId:
    case W.InsertRangeMoveRightCommandId: {
      const d = ((a = e.params) == null ? void 0 : a.range) || ((l = (u = s.getCurrentSelections()) == null ? void 0 : u.map((g) => g.range)) == null ? void 0 : l[0]), h = P(t);
      return d ? {
        unitId: h.unitId,
        subUnitId: h.subUnitId,
        ranges: [
          d,
          {
            ...d,
            startColumn: d.endColumn + 1,
            endColumn: Number.MAX_SAFE_INTEGER
          }
        ]
      } : {
        unitId: h.unitId,
        subUnitId: h.subUnitId,
        ranges: []
      };
    }
    case W.ReorderRangeCommandId: {
      const c = e, { range: d, order: h } = c.params, g = [];
      for (let f = d.startRow; f <= d.endRow; f++)
        f in h && g.push({
          startRow: f,
          endRow: f,
          startColumn: d.startColumn,
          endColumn: d.endColumn
        });
      const m = P(t);
      return {
        unitId: m.unitId,
        subUnitId: m.subUnitId,
        ranges: g
      };
    }
  }
}
var Bl = Object.getOwnPropertyDescriptor, jl = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? Bl(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, yn = (n, e) => (t, s) => e(t, s, n);
const zl = ft("MERGE_REDO"), Gl = ft("MERGE_UNDO"), wo = Math.floor(Number.MAX_SAFE_INTEGER / 10);
class Kl extends ue {
  constructor(e, t, s, o, r = !1) {
    super(), this._unitId = e, this._subUnitId = t, this._range = s, this._callback = o, this._skipIntersects = r;
  }
  onMutation(e) {
    var o, r;
    if (((o = e.params) == null ? void 0 : o.unitId) !== this._unitId)
      return;
    if (e.id === wt.id) {
      const i = e.params;
      if (i.from.subUnitId !== this._subUnitId || i.to.subUnitId !== this._subUnitId)
        return;
    } else if (((r = e.params) == null ? void 0 : r.subUnitId) !== this._subUnitId)
      return;
    if (!this._range)
      return;
    if (this._skipIntersects) {
      if (e.id === Lt.id)
        return;
      const i = Fl(e);
      if (i != null && i.some((a) => O.intersects(a, this._range)))
        return;
    }
    const t = Hl(this._range, e);
    if (t && O.equals(t, this._range))
      return !1;
    const s = this._range;
    this._range = t, this._callback(s, t);
  }
}
let At = class extends ue {
  constructor(e, t, s, o) {
    super();
    R(this, "interceptor", new As({ MERGE_REDO: zl, MERGE_UNDO: Gl }));
    R(this, "_watchRanges", /* @__PURE__ */ new Set());
    R(this, "_refRangeManagerMap", /* @__PURE__ */ new Map());
    R(this, "_serializer", Jl());
    // eslint-disable-next-line max-lines-per-function
    R(this, "_onRefRangeChange", () => {
      this._sheetInterceptorService.interceptCommand({
        // eslint-disable-next-line max-lines-per-function
        getMutations: (e) => {
          const t = this._univerInstanceService.getCurrentUnitForType(B.UNIVER_SHEET).getActiveSheet(), s = Io(this._univerInstanceService), o = vo(this._univerInstanceService);
          if (!t || !s || !o)
            return { redos: [], undos: [], preRedos: [], preUndos: [] };
          const a = ((() => {
            switch (e.id) {
              case W.MoveColsCommandId: {
                const h = e.params, g = Math.min(h.fromRange.startColumn, h.toRange.startColumn);
                return this._checkRange(
                  [{ ...h.fromRange, startColumn: g, endColumn: t.getColumnCount() - 1 }],
                  s,
                  o
                );
              }
              case W.MoveRowsCommandId: {
                const h = e.params, g = Math.min(h.fromRange.startRow, h.toRange.startRow);
                return this._checkRange(
                  [{ ...h.fromRange, startRow: g, endRow: t.getRowCount() - 1 }],
                  s,
                  o
                );
              }
              case W.MoveRangeCommandId: {
                const h = e;
                return this._checkRange(
                  [h.params.fromRange, h.params.toRange],
                  s,
                  o
                );
              }
              case W.InsertRowCommandId: {
                const m = {
                  startRow: e.params.range.startRow,
                  endRow: t.getRowCount() - 1,
                  startColumn: 0,
                  endColumn: t.getColumnCount() - 1,
                  rangeType: j.ROW
                };
                return this._checkRange([m], s, o);
              }
              case W.InsertColCommandId: {
                const g = e.params.range.startColumn, m = {
                  startRow: 0,
                  endRow: t.getRowCount() - 1,
                  startColumn: g,
                  endColumn: t.getColumnCount() - 1,
                  rangeType: j.COLUMN
                };
                return this._checkRange([m], s, o);
              }
              case W.RemoveRowCommandId: {
                const m = {
                  startRow: e.params.range.startRow,
                  endRow: t.getRowCount() - 1,
                  startColumn: 0,
                  endColumn: t.getColumnCount() - 1,
                  rangeType: j.ROW
                };
                return this._checkRange([m], s, o);
              }
              case W.RemoveColCommandId: {
                const g = e.params.range.startColumn, m = {
                  startRow: 0,
                  endRow: t.getRowCount() - 1,
                  startColumn: g,
                  endColumn: t.getColumnCount() - 1,
                  rangeType: j.COLUMN
                };
                return this._checkRange([m], s, o);
              }
              case W.DeleteRangeMoveUpCommandId:
              case W.InsertRangeMoveDownCommandId: {
                const g = e.params.range || Mo(this._selectionManagerService)[0], m = {
                  startRow: g.startRow,
                  startColumn: g.startColumn,
                  endColumn: g.endColumn,
                  endRow: wo
                };
                return this._checkRange([m], s, o);
              }
              case W.DeleteRangeMoveLeftCommandId:
              case W.InsertRangeMoveRightCommandId: {
                const g = e.params.range || Mo(this._selectionManagerService)[0], m = {
                  startRow: g.startRow,
                  startColumn: g.startColumn,
                  endColumn: wo,
                  endRow: g.endRow
                };
                return this._checkRange([m], s, o);
              }
              case W.ReorderRangeCommandId: {
                const h = e, { range: g, order: m } = h.params, f = [];
                for (let C = g.startRow; C <= g.endRow; C++)
                  C in m && f.push({
                    startRow: C,
                    endRow: C,
                    startColumn: g.startColumn,
                    endColumn: g.endColumn
                  });
                return this._checkRange(f, s, o);
              }
            }
          })() || []).reduce(
            (h, g) => {
              const m = g(e);
              return h.push(m), h;
            },
            []
          ).reduce(
            (h, g) => {
              var m, f;
              return h.redos.push(...g.redos), h.undos.push(...g.undos), h.preRedos.push(...(m = g.preRedos) != null ? m : []), h.preUndos.push(...(f = g.preUndos) != null ? f : []), h;
            },
            { redos: [], undos: [], preUndos: [], preRedos: [] }
          ), u = this.interceptor.fetchThroughInterceptors(this.interceptor.getInterceptPoints().MERGE_REDO)(
            a.preRedos,
            null
          ) || [], l = this.interceptor.fetchThroughInterceptors(this.interceptor.getInterceptPoints().MERGE_REDO)(
            a.redos,
            null
          ) || [], c = this.interceptor.fetchThroughInterceptors(this.interceptor.getInterceptPoints().MERGE_UNDO)(
            a.preUndos,
            null
          ) || [], d = this.interceptor.fetchThroughInterceptors(this.interceptor.getInterceptPoints().MERGE_UNDO)(
            a.undos,
            null
          ) || [];
          return { redos: l, undos: d, preRedos: u, preUndos: c };
        }
      });
    });
    R(this, "_checkRange", (e, t, s) => {
      const o = _o(t, s), r = this._refRangeManagerMap.get(o);
      if (r) {
        const i = /* @__PURE__ */ new Set();
        return [...r.keys()].forEach((u) => {
          const l = r.get(u), c = this._serializer.deserialize(u), d = {
            ...c,
            startRow: +c.startRow,
            endRow: +c.endRow,
            startColumn: +c.startColumn,
            endColumn: +c.endColumn,
            rangeType: c.rangeType && +c.rangeType
          };
          e.some((h) => O.intersects(h, d)) && l && l.forEach((h) => {
            i.add(h);
          });
        }), [...i];
      }
      return [];
    });
    /**
     * Listens to an area and triggers a fall back when movement occurs
     * @param {IRange} range the area that needs to be monitored
     * @param {RefRangCallback} callback the callback function that is executed when the range changes
     * @param {string} [_unitId]
     * @param {string} [_subUnitId]
     * @memberof RefRangeService
     */
    R(this, "registerRefRange", (e, t, s, o) => {
      const r = s || Io(this._univerInstanceService), i = o || vo(this._univerInstanceService);
      if (!r || !i)
        return Ne(() => {
        });
      const a = _o(r, i), u = this._serializer.serialize(e);
      let l = this._refRangeManagerMap.get(a);
      l || (l = /* @__PURE__ */ new Map(), this._refRangeManagerMap.set(a, l));
      const c = l.get(u);
      return c ? c.add(t) : l.set(u, /* @__PURE__ */ new Set([t])), Ne(() => {
        const d = l.get(u);
        d && (d.delete(t), d.size || (l.delete(u), l.size || this._refRangeManagerMap.delete(a)));
      });
    });
    this._commandService = e, this._sheetInterceptorService = t, this._univerInstanceService = s, this._selectionManagerService = o, this._onRefRangeChange(), this.interceptor.intercept(this.interceptor.getInterceptPoints().MERGE_REDO, {
      priority: -1,
      handler: (r) => r
    }), this.interceptor.intercept(this.interceptor.getInterceptPoints().MERGE_UNDO, {
      priority: -1,
      handler: (r) => r
    });
  }
  watchRange(e, t, s, o, r) {
    let i;
    this._watchRanges.size === 0 && (i = this._commandService.onCommandExecuted((c) => {
      if (c.type !== v.MUTATION) return !1;
      for (const d of this._watchRanges)
        d.onMutation(c);
    }));
    const a = new Kl(e, t, s, o, r);
    this._watchRanges.add(a);
    const u = Ne(() => {
      this._watchRanges.delete(a), this._watchRanges.size === 0 && (i == null || i.dispose(), i = null);
    }), l = this.disposeWithMe(u);
    return Ne(() => {
      l.dispose(), u.dispose();
    });
  }
};
At = jl([
  yn(0, E),
  yn(1, $(G)),
  yn(2, $(M)),
  yn(3, $(z))
], At);
function Io(n) {
  return n.getCurrentUnitForType(B.UNIVER_SHEET).getUnitId();
}
function vo(n) {
  var e;
  return (e = n.getCurrentUnitForType(B.UNIVER_SHEET).getActiveSheet()) == null ? void 0 : e.getSheetId();
}
function Mo(n) {
  var e;
  return ((e = n.getCurrentSelections()) == null ? void 0 : e.map((t) => t.range)) || [];
}
function _o(n, e) {
  return `${n}_${e}`;
}
function Jl() {
  const n = ["startRow", "startColumn", "endRow", "endColumn", "rangeType"];
  return {
    deserialize: (t) => {
      const s = n.reduce(
        (r, i, a) => (r[String(a)] = i, r),
        {}
      );
      return t.split("_").reduce(
        (r, i, a) => {
          const u = String(a);
          return i && s[u] && (r[s[u]] = i), r;
        },
        {}
      );
    },
    serialize: (t) => n.reduce((s, o, r) => {
      const i = t[o];
      return i !== void 0 ? `${s}${r > 0 ? "_" : ""}${i}` : `${s}`;
    }, "")
  };
}
var ql = Object.getOwnPropertyDescriptor, Yl = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? ql(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, _t = (n, e) => (t, s) => e(t, s, n);
const Xl = [Ue.id, ke.id, Me.id, Te.id], Zl = [Je.id, qe.id];
function Jr(n, e) {
  let t = n;
  if (e !== void 0) {
    const s = [];
    for (let o = 0; o < t.length; o++) {
      const { startRow: r, endRow: i, startColumn: a, endColumn: u } = t[o];
      if (e === Re.ROWS)
        for (let l = r; l <= i; l++) {
          const c = {
            startRow: l,
            endRow: l,
            startColumn: a,
            endColumn: u
          };
          s.push(c);
        }
      else if (e === Re.COLUMNS)
        for (let l = a; l <= u; l++) {
          const c = {
            startRow: r,
            endRow: i,
            startColumn: l,
            endColumn: l
          };
          s.push(c);
        }
    }
    t = s;
  }
  return t;
}
const Ql = ft("mergeCellPermissionCheck");
let Vn = class extends ue {
  constructor(e, t, s, o, r, i) {
    super();
    R(this, "disposableCollection", new Et());
    R(this, "interceptor", new As({ MERGE_CELL_INTERCEPTOR_CHECK: Ql }));
    this._commandService = e, this._refRangeService = t, this._univerInstanceService = s, this._injector = o, this._sheetInterceptorService = r, this._selectionManagerService = i, this._onRefRangeChange(), this._initCommandInterceptor(), this._commandExecutedListener();
  }
  _initCommandInterceptor() {
    const e = this;
    this._sheetInterceptorService.interceptCommand({
      getMutations(t) {
        var s;
        switch (t.id) {
          case Ls.id:
          case Hs.id: {
            const o = e._univerInstanceService.getCurrentUnitForType(B.UNIVER_SHEET), r = o.getUnitId(), i = o == null ? void 0 : o.getActiveSheet();
            if (!i)
              return { redos: [], undos: [] };
            const a = i.getSheetId(), u = i.getConfig().mergeData, l = (s = e._selectionManagerService.getCurrentSelections()) == null ? void 0 : s.map((c) => c.range);
            if (l && l.length > 0 && l.some(
              (d) => u.some((h) => O.intersects(h, d))
            )) {
              const d = {
                unitId: r,
                subUnitId: a,
                ranges: l
              }, h = ye(e._injector, d), g = [
                { id: se.id, params: d }
              ], m = [
                { id: ne.id, params: h }
              ];
              return { redos: g, undos: m };
            }
          }
        }
        return { redos: [], undos: [] };
      }
    }), this._sheetInterceptorService.interceptRanges({
      getMutations: ({ unitId: t, subUnitId: s, ranges: o }) => {
        const r = [], i = [], a = { redos: r, undos: i };
        if (!o || !o.length)
          return a;
        const u = P(this._univerInstanceService, { unitId: t, subUnitId: s });
        if (!u)
          return a;
        const { worksheet: l } = u, d = l.getMergeData().filter((h) => o.some((g) => O.intersects(h, g)));
        return d.length ? (r.push({
          id: se.id,
          params: {
            unitId: t,
            subUnitId: s,
            ranges: d
          }
        }), i.push({
          id: ne.id,
          params: {
            unitId: t,
            subUnitId: s,
            ranges: d
          }
        }), { undos: i, redos: r }) : a;
      }
    });
  }
  refRangeHandle(e, t, s) {
    switch (e.id) {
      case W.MoveColsCommandId: {
        const o = e.params;
        return this._handleMoveColsCommand(o, t, s);
      }
      case W.MoveRowsCommandId: {
        const o = e.params;
        return this._handleMoveRowsCommand(o, t, s);
      }
      case Ye.id: {
        const o = e.params, r = o.unitId || t, i = o.subUnitId || s;
        return this._handleInsertRowCommand(o, r, i);
      }
      case Xe.id: {
        const o = e.params, r = o.unitId || t, i = o.subUnitId || s;
        return this._handleInsertColCommand(o, r, i);
      }
      case gs.id: {
        const o = e.params;
        return this._handleRemoveColCommand(o, t, s);
      }
      case hs.id: {
        const o = e.params;
        return this._handleRemoveRowCommand(o, t, s);
      }
      case yt.id: {
        const o = e.params;
        return this._handleMoveRangeCommand(o, t, s);
      }
      case rn.id: {
        const o = e.params;
        return this._handleInsertRangeMoveRightCommand(o, t, s);
      }
      case Pt.id: {
        const o = e.params;
        return this._handleInsertRangeMoveDownCommand(o, t, s);
      }
      case vt.id: {
        const o = e.params;
        return this._handleDeleteRangeMoveUpCommand(o, t, s);
      }
      case It.id: {
        const o = e.params;
        return this._handleDeleteRangeMoveLeftCommand(o, t, s);
      }
    }
    return { redos: [], undos: [] };
  }
  _onRefRangeChange() {
    const e = (t, s) => {
      const o = this._univerInstanceService.getUniverSheetInstance(t);
      if (!o)
        return;
      const r = o == null ? void 0 : o.getSheetBySheetId(s);
      if (!r)
        return;
      this.disposableCollection.dispose();
      const i = r.getMergeData(), a = (u) => this.refRangeHandle(u, t, s);
      i.forEach((u) => {
        this.disposableCollection.add(this._refRangeService.registerRefRange(u, a, t, s));
      });
    };
    this.disposeWithMe(
      this._commandService.onCommandExecuted((t) => {
        if (t.id === pn.id) {
          const s = t.params, o = s.subUnitId, r = s.unitId;
          if (!o || !r)
            return;
          e(r, o);
        }
        if (t.id === ne.id) {
          const s = t.params, o = s.subUnitId, r = s.unitId;
          if (!o || !r)
            return;
          e(s.unitId, s.subUnitId);
        }
      })
    ), this._univerInstanceService.getCurrentTypeOfUnit$(B.UNIVER_SHEET).pipe(ea((t) => !!t)).subscribe((t) => {
      const s = t.getActiveSheet();
      s && e(t.getUnitId(), s.getSheetId());
    });
  }
  _handleMoveRowsCommand(e, t, s) {
    const o = xe(this._univerInstanceService, t);
    if (!o)
      return this._handleNull();
    const r = $e(o, s);
    if (!r)
      return this._handleNull();
    const i = [...r.getMergeData()], a = { unitId: t, subUnitId: s, ranges: [] }, u = { unitId: t, subUnitId: s, ranges: [] }, { fromRange: l } = e, { startRow: c, endRow: d } = l;
    if (i.forEach((m) => {
      if (c <= m.startRow && d >= m.endRow) {
        a.ranges.push(m);
        const f = jr({ id: W.MoveRowsCommandId, params: e }, m), C = Dt(f, m);
        C && u.ranges.push(C);
      }
    }), a.ranges.length === 0)
      return this._handleNull();
    const h = ye(this._injector, a), g = We(this._injector, u);
    return {
      preRedos: [{ id: se.id, params: a }],
      redos: [{ id: ne.id, params: u }],
      preUndos: [{ id: se.id, params: g }],
      undos: [{ id: ne.id, params: h }]
    };
  }
  _handleMoveColsCommand(e, t, s) {
    const o = xe(this._univerInstanceService, t);
    if (!o)
      return this._handleNull();
    const r = $e(o, s);
    if (!r)
      return this._handleNull();
    const i = [...r.getMergeData()], a = { unitId: t, subUnitId: s, ranges: [] }, u = { unitId: t, subUnitId: s, ranges: [] }, { fromRange: l } = e, { startColumn: c, endColumn: d } = l;
    if (i.forEach((m) => {
      if (c <= m.startColumn && d >= m.endColumn) {
        a.ranges.push(m);
        const f = zr({ id: W.MoveColsCommandId, params: e }, m), C = Dt(f, m);
        C && u.ranges.push(C);
      }
    }), a.ranges.length === 0)
      return this._handleNull();
    const h = ye(this._injector, a), g = We(this._injector, u);
    return {
      preRedos: [{ id: se.id, params: a }],
      redos: [{ id: ne.id, params: u }],
      preUndos: [{ id: se.id, params: g }],
      undos: [{ id: ne.id, params: h }]
    };
  }
  _handleMoveRangeCommand(e, t, s) {
    const o = xe(this._univerInstanceService, t);
    if (!o)
      return this._handleNull();
    const r = $e(o, s);
    if (!r)
      return this._handleNull();
    const i = r.getMergeData(), a = i.filter((g) => O.intersects(g, e.fromRange)), u = i.filter((g) => O.intersects(g, e.toRange)), l = a.map((g) => O.getRelativeRange(g, e.fromRange)).map((g) => O.getPositionRange(g, e.toRange)), c = Jr(l).filter(
      (g) => !i.some((m) => O.equals(g, m))
    ), d = [
      {
        id: se.id,
        params: {
          unitId: t,
          subUnitId: s,
          ranges: a
        }
      },
      {
        id: se.id,
        params: {
          unitId: t,
          subUnitId: s,
          ranges: u
        }
      },
      {
        id: ne.id,
        params: {
          unitId: t,
          subUnitId: s,
          ranges: c
        }
      }
    ], h = [
      {
        id: se.id,
        params: {
          unitId: t,
          subUnitId: s,
          ranges: c
        }
      },
      {
        id: ne.id,
        params: {
          unitId: t,
          subUnitId: s,
          ranges: u
        }
      },
      {
        id: ne.id,
        params: {
          unitId: t,
          subUnitId: s,
          ranges: a
        }
      }
    ];
    return { redos: d, undos: h };
  }
  _handleInsertRowCommand(e, t, s) {
    const o = xe(this._univerInstanceService, t);
    if (!o)
      return this._handleNull();
    const r = $e(o, s);
    if (!r)
      return this._handleNull();
    const { range: i } = e, { startRow: a, endRow: u } = i, l = A.deepClone(r.getMergeData()).reduce((p, w) => (a > w.startRow && a <= w.endRow && p.push(w), p), []);
    if (l.length === 0)
      return this._handleNull();
    const c = A.deepClone(r.getMergeData()).reduce((p, w) => {
      if (a > w.startRow && a <= w.endRow) {
        const S = u - a + 1;
        w.endRow += S, this._checkIsMergeCell(w) && p.push(w);
      }
      return p;
    }, []), d = {
      unitId: t,
      subUnitId: s,
      ranges: l
    }, h = ye(
      this._injector,
      d
    ), g = {
      unitId: t,
      subUnitId: s,
      ranges: c
    }, m = We(
      this._injector,
      g
    ), f = [
      { id: se.id, params: d },
      { id: ne.id, params: g }
    ], C = [
      { id: se.id, params: m },
      { id: ne.id, params: h }
    ];
    return { redos: f, undos: C };
  }
  _handleInsertColCommand(e, t, s) {
    const { range: o } = e, r = xe(this._univerInstanceService, t);
    if (!r)
      return this._handleNull();
    const i = $e(r, s);
    if (!i)
      return this._handleNull();
    const { startColumn: a, endColumn: u } = o, l = A.deepClone(i.getMergeData()).reduce((p, w) => (a > w.startColumn && a <= w.endColumn && p.push(w), p), []);
    if (l.length === 0)
      return this._handleNull();
    const c = A.deepClone(i.getMergeData()).reduce((p, w) => {
      if (a > w.startColumn && a <= w.endColumn) {
        const S = u - a + 1;
        w.endColumn += S, this._checkIsMergeCell(w) && p.push(w);
      }
      return p;
    }, []), d = {
      unitId: t,
      subUnitId: s,
      ranges: l
    }, h = ye(
      this._injector,
      d
    ), g = {
      unitId: t,
      subUnitId: s,
      ranges: c
    }, m = We(
      this._injector,
      g
    ), f = [
      { id: se.id, params: d },
      { id: ne.id, params: g }
    ], C = [
      { id: se.id, params: m },
      { id: ne.id, params: h }
    ];
    return { redos: f, undos: C };
  }
  _handleRemoveColCommand(e, t, s) {
    const o = xe(this._univerInstanceService, t);
    if (!o)
      return this._handleNull();
    const r = $e(o, s);
    if (!r)
      return this._handleNull();
    const { range: i } = e, { startColumn: a, endColumn: u } = i, l = A.deepClone(r.getMergeData()).reduce((S, I) => (O.intersects(i, I) && S.push(I), S), []);
    if (l.length === 0)
      return this._handleNull();
    const c = A.deepClone(r.getMergeData()).reduce((S, I) => {
      if (O.intersects(i, I)) {
        if (a <= I.startColumn && u >= I.endColumn)
          return S;
        a >= I.startColumn && u <= I.endColumn ? I.endColumn -= u - a + 1 : a < I.startColumn ? (I.startColumn = a, I.endColumn -= u - a + 1) : u > I.endColumn && (I.endColumn = a - 1), this._checkIsMergeCell(I) && S.push(I);
      }
      return S;
    }, []), d = {
      unitId: t,
      subUnitId: s,
      ranges: l
    }, h = ye(
      this._injector,
      d
    ), g = {
      unitId: t,
      subUnitId: s,
      ranges: c
    }, m = We(
      this._injector,
      g
    ), f = [{ id: se.id, params: d }], C = [{ id: ne.id, params: g }], p = [{ id: se.id, params: m }], w = [{ id: ne.id, params: h }];
    return { preUndos: p, undos: w, preRedos: f, redos: C };
  }
  _handleRemoveRowCommand(e, t, s) {
    const { range: o } = e, r = xe(this._univerInstanceService, t);
    if (!r)
      return this._handleNull();
    const i = $e(r, s);
    if (!i)
      return this._handleNull();
    const { startRow: a, endRow: u } = o, l = A.deepClone(i.getMergeData()).reduce((S, I) => (O.intersects(o, I) && S.push(I), S), []);
    if (l.length === 0)
      return this._handleNull();
    const c = A.deepClone(i.getMergeData()).reduce((S, I) => {
      if (O.intersects(o, I)) {
        if (a <= I.startRow && u >= I.endRow)
          return S;
        a >= I.startRow && u <= I.endRow ? I.endRow -= u - a + 1 : a < I.startRow ? (I.startRow = a, I.endRow -= u - a + 1) : u > I.endRow && (I.endRow = a - 1), this._checkIsMergeCell(I) && S.push(I);
      }
      return S;
    }, []), d = {
      unitId: t,
      subUnitId: s,
      ranges: l
    }, h = ye(
      this._injector,
      d
    ), g = {
      unitId: t,
      subUnitId: s,
      ranges: c
    }, m = We(
      this._injector,
      g
    ), f = [{ id: se.id, params: d }], C = [{ id: ne.id, params: g }], p = [{ id: se.id, params: m }], w = [{ id: ne.id, params: h }];
    return { preUndos: p, undos: w, preRedos: f, redos: C };
  }
  _handleInsertRangeMoveRightCommand(e, t, s) {
    const o = xe(this._univerInstanceService, t);
    if (!o)
      return this._handleNull();
    const r = $e(o, s);
    if (!r)
      return this._handleNull();
    const i = e.range, a = r.getMaxColumns() - 1, u = r.getMergeData(), l = [], c = [];
    u.forEach((f) => {
      const { startRow: C, endRow: p, startColumn: w, endColumn: S } = i;
      if (O.intersects(
        {
          startRow: C,
          startColumn: w,
          endRow: p,
          endColumn: a
        },
        f
      ) && (l.push(f), O.contains(
        {
          startRow: C,
          startColumn: w,
          endRow: p,
          endColumn: a
        },
        f
      ))) {
        const b = S - w + 1;
        c.push({
          startRow: f.startRow,
          startColumn: f.startColumn + b,
          endRow: f.endRow,
          endColumn: f.endColumn + b
        });
      }
    });
    const d = {
      unitId: t,
      subUnitId: s,
      ranges: l
    }, h = ye(
      this._injector,
      d
    ), g = {
      unitId: t,
      subUnitId: s,
      ranges: c
    }, m = We(
      this._injector,
      g
    );
    return {
      preRedos: [
        { id: se.id, params: d }
      ],
      redos: [
        {
          id: ne.id,
          params: g
        }
      ],
      preUndos: [
        { id: se.id, params: m }
      ],
      undos: [
        {
          id: ne.id,
          params: h
        }
      ]
    };
  }
  _handleInsertRangeMoveDownCommand(e, t, s) {
    const o = xe(this._univerInstanceService, t);
    if (!o)
      return this._handleNull();
    const r = $e(o, s);
    if (!r)
      return this._handleNull();
    const i = e.range, a = r.getMaxRows() - 1, u = r.getMergeData(), l = [], c = [];
    u.forEach((S) => {
      const { startRow: I, startColumn: y, endColumn: b, endRow: N } = i;
      if (O.intersects({ startRow: I, startColumn: y, endRow: a, endColumn: b }, S) && (l.push(S), O.contains({ startRow: I, startColumn: y, endRow: a, endColumn: b }, S))) {
        const k = N - I + 1;
        c.push({
          startRow: S.startRow + k,
          startColumn: S.startColumn,
          endRow: S.endRow + k,
          endColumn: S.endColumn
        });
      }
    });
    const d = {
      unitId: t,
      subUnitId: s,
      ranges: l
    }, h = ye(
      this._injector,
      d
    ), g = {
      unitId: t,
      subUnitId: s,
      ranges: c
    }, m = We(
      this._injector,
      g
    ), f = [
      {
        id: se.id,
        params: d
      }
    ], C = [
      {
        id: ne.id,
        params: g
      }
    ], p = [
      {
        id: se.id,
        params: m
      }
    ], w = [
      {
        id: ne.id,
        params: h
      }
    ];
    return { redos: C, undos: w, preRedos: f, preUndos: p };
  }
  _handleDeleteRangeMoveUpCommand(e, t, s) {
    const o = xe(this._univerInstanceService, t);
    if (!o)
      return this._handleNull();
    const r = $e(o, s);
    if (!r)
      return this._handleNull();
    const i = e.range, a = r.getMaxRows() - 1, u = r.getMergeData(), l = [], c = [];
    u.forEach((S) => {
      const { startRow: I, startColumn: y, endColumn: b, endRow: N } = i;
      if (O.intersects({ startRow: I, startColumn: y, endRow: a, endColumn: b }, S) && (l.push(S), O.contains({ startRow: I, startColumn: y, endRow: a, endColumn: b }, S))) {
        const k = N - I + 1, D = O.moveVertical(S, -k);
        c.push(D);
      }
    });
    const d = {
      unitId: t,
      subUnitId: s,
      ranges: l
    }, h = ye(
      this._injector,
      d
    ), g = {
      unitId: t,
      subUnitId: s,
      ranges: c
    }, m = We(
      this._injector,
      g
    ), f = [
      {
        id: se.id,
        params: d
      }
    ], C = [
      {
        id: ne.id,
        params: g
      }
    ], p = [
      {
        id: se.id,
        params: m
      }
    ], w = [
      {
        id: ne.id,
        params: h
      }
    ];
    return { redos: C, undos: w, preRedos: f, preUndos: p };
  }
  _handleDeleteRangeMoveLeftCommand(e, t, s) {
    const o = xe(this._univerInstanceService, t);
    if (!o)
      return this._handleNull();
    const r = $e(o, s);
    if (!r)
      return this._handleNull();
    const i = e.range, a = r.getMaxColumns() - 1, u = r.getMergeData(), l = [], c = [];
    u.forEach((f) => {
      const { startRow: C, endRow: p, startColumn: w, endColumn: S } = i;
      if (O.intersects(
        {
          startRow: C,
          startColumn: w,
          endRow: p,
          endColumn: a
        },
        f
      ) && (l.push(f), O.contains(
        {
          startRow: C,
          startColumn: w,
          endRow: p,
          endColumn: a
        },
        f
      ))) {
        const b = S - w + 1;
        c.push({
          startRow: f.startRow,
          startColumn: f.startColumn - b,
          endRow: f.endRow,
          endColumn: f.endColumn - b
        });
      }
    });
    const d = {
      unitId: t,
      subUnitId: s,
      ranges: l
    }, h = ye(this._injector, d), g = {
      unitId: t,
      subUnitId: s,
      ranges: c
    }, m = We(this._injector, g);
    return {
      preRedos: [
        { id: se.id, params: d }
      ],
      redos: [
        {
          id: ne.id,
          params: g
        }
      ],
      undos: [
        {
          id: ne.id,
          params: h
        }
      ],
      preUndos: [
        { id: se.id, params: m }
      ]
    };
  }
  _checkIsMergeCell(e) {
    return !(e.startRow === e.endRow && e.startColumn === e.endColumn);
  }
  _handleNull() {
    return { redos: [], undos: [] };
  }
  _commandExecutedListener() {
    this.disposeWithMe(this._commandService.onCommandExecuted((e) => {
      if (Zl.includes(e.id)) {
        if (!e.params) return;
        const t = this._univerInstanceService.getUniverSheetInstance(e.params.unitId);
        if (!t) return;
        const s = t.getSheetBySheetId(e.params.subUnitId);
        if (!s) return;
        const { sourceRange: o, targetRange: r } = e.params, i = o.startColumn === r.startColumn && o.endColumn === r.endColumn, a = i ? o.endRow - o.startRow + 1 : o.endColumn - o.startColumn + 1, u = i ? o.startRow : o.startColumn, l = i ? r.startRow : r.startColumn, c = s.getConfig().mergeData, d = [];
        c.forEach((f) => {
          let { startRow: C, endRow: p, startColumn: w, endColumn: S, rangeType: I } = f;
          O.intersects(f, o) || (i ? u < C && l > p ? (C -= a, p -= a) : u > p && l <= C && (C += a, p += a) : u < w && l > S ? (w -= a, S -= a) : u > S && l <= w && (w += a, S += a)), f.startRow === f.endRow && f.startColumn === f.endColumn || d.push({ startRow: C, endRow: p, startColumn: w, endColumn: S, rangeType: I });
        }), s.setMergeData(d), this.disposableCollection.dispose();
        const { unitId: h, subUnitId: g } = e.params, m = (f) => this.refRangeHandle(f, h, g);
        d.forEach((f) => {
          this.disposableCollection.add(this._refRangeService.registerRefRange(f, m, h, g));
        });
      }
      if (Xl.includes(e.id)) {
        const t = this._univerInstanceService.getUniverSheetInstance(e.params.unitId);
        if (!t) return;
        const s = t.getSheetBySheetId(e.params.subUnitId);
        if (!s) return;
        const o = s.getConfig().mergeData, r = e.params;
        if (!r) return;
        const { range: i } = r, a = e.id.includes("row"), u = e.id.includes("insert"), l = a ? i.startRow : i.startColumn, c = a ? i.endRow : i.endColumn, d = c - l + 1, h = [];
        o.forEach((C) => {
          let { startRow: p, endRow: w, startColumn: S, endColumn: I, rangeType: y } = C;
          u ? a ? l <= p && (p += d, w += d) : l <= S && (S += d, I += d) : a ? c < p && (p -= d, w -= d) : c < S && (S -= d, I -= d), C.startRow === C.endRow && C.startColumn === C.endColumn || h.push({ startRow: p, endRow: w, startColumn: S, endColumn: I, rangeType: y });
        }), s.setMergeData(h), this.disposableCollection.dispose();
        const { unitId: g, subUnitId: m } = e.params, f = (C) => this.refRangeHandle(C, g, m);
        h.forEach((C) => {
          this.disposableCollection.add(this._refRangeService.registerRefRange(C, f, g, m));
        });
      }
    }));
  }
};
Vn = Yl([
  _t(0, $(E)),
  _t(1, $(At)),
  _t(2, $(M)),
  _t(3, $(is)),
  _t(4, $(G)),
  _t(5, $(z))
], Vn);
function xe(n, e) {
  return e ? n.getUniverSheetInstance(e) : n.getCurrentUnitForType(B.UNIVER_SHEET);
}
function $e(n, e) {
  return e ? n.getSheetBySheetId(e) : n.getActiveSheet();
}
function ec(n, e) {
  return e.some((t) => tc(n, t));
}
function tc(n, e) {
  const { startRow: t, startColumn: s, endColumn: o, endRow: r } = e, i = n.getMatrixWithMergedCells(t, s, r, o);
  let a = !1;
  return i.forValue((u, l, c) => {
    if (c && (u !== t || l !== s) && n.cellHasValue(c))
      return a = !0, !1;
  }), a;
}
function nc(n, e, t, s) {
  const o = [], r = [], i = t.getSheetId();
  return s.forEach((a) => {
    const u = sc(t, a), l = {
      unitId: e,
      subUnitId: i,
      cellValue: u.getData()
    }, c = Ae(
      n,
      l
    );
    o.push({ id: ee.id, params: c }), r.push({ id: ee.id, params: l });
  }), {
    undos: o,
    redos: r
  };
}
function sc(n, e) {
  const { startRow: t, startColumn: s, endColumn: o, endRow: r } = e, i = n.getMatrixWithMergedCells(t, s, r, o, Pi.Raw), a = new Y();
  return i.forValue((u, l, c) => {
    c && (u !== t || l !== s) && a.setValue(u, l, null);
  }), a;
}
const ms = {
  type: v.COMMAND,
  id: "sheet.command.add-worksheet-merge",
  handler: (n, e) => {
    const t = n.get(E), s = n.get(V), o = n.get(M), r = e.unitId, i = e.subUnitId, a = e.selections, u = Jr(a, e.value), l = o.getUniverSheetInstance(r).getSheetBySheetId(i), c = [], d = [], h = ec(l, u), g = {
      unitId: r,
      subUnitId: i,
      ranges: u
    }, m = {
      unitId: r,
      subUnitId: i,
      ranges: u
    };
    c.push({ id: se.id, params: g }), c.push({ id: ne.id, params: m });
    const f = ye(n, g), C = We(n, m);
    if (d.push({ id: se.id, params: C }), d.push({ id: ne.id, params: f }), h) {
      const w = nc(n, r, l, u);
      c.unshift(...w.redos), d.push(...w.undos);
    }
    return L(c, t).result ? (s.pushUndoRedo({
      unitID: r,
      undoMutations: d,
      redoMutations: c
    }), !0) : !1;
  }
}, Yh = {
  type: v.COMMAND,
  id: "sheet.command.add-worksheet-merge-all",
  handler: async (n) => {
    var l;
    const e = n.get(E), s = (l = n.get(z).getCurrentSelections()) == null ? void 0 : l.map((c) => c.range);
    if (!(s != null && s.length))
      return !1;
    const r = n.get(M).getCurrentUnitForType(B.UNIVER_SHEET);
    if (!r) return !1;
    const i = r.getActiveSheet();
    if (!i) return !1;
    const a = r.getUnitId(), u = i.getSheetId();
    return e.executeCommand(ms.id, {
      selections: s,
      unitId: a,
      subUnitId: u
    });
  }
}, Xh = {
  type: v.COMMAND,
  id: "sheet.command.add-worksheet-merge-vertical",
  handler: async (n) => {
    var l;
    const e = n.get(E), s = (l = n.get(z).getCurrentSelections()) == null ? void 0 : l.map((c) => c.range);
    if (!(s != null && s.length))
      return !1;
    const r = n.get(M).getCurrentUnitForType(B.UNIVER_SHEET);
    if (!r) return !1;
    const i = r.getActiveSheet();
    if (!i) return !1;
    const a = r.getUnitId(), u = i.getSheetId();
    return e.executeCommand(ms.id, {
      value: Re.COLUMNS,
      selections: s,
      unitId: a,
      subUnitId: u
    });
  }
}, Zh = {
  type: v.COMMAND,
  id: "sheet.command.add-worksheet-merge-horizontal",
  handler: async (n) => {
    var l;
    const e = n.get(E), s = (l = n.get(z).getCurrentSelections()) == null ? void 0 : l.map((c) => c.range);
    if (!(s != null && s.length))
      return !1;
    const r = n.get(M).getCurrentUnitForType(B.UNIVER_SHEET);
    if (!r) return !1;
    const i = r.getActiveSheet();
    if (!i) return !1;
    const a = r.getUnitId(), u = i.getSheetId();
    return e.executeCommand(ms.id, {
      value: Re.ROWS,
      selections: s,
      unitId: a,
      subUnitId: u
    });
  }
};
function Qh(n, e, t, s, o) {
  const r = n.get(M), i = P(r, { unitId: e, subUnitId: t });
  if (!i) return;
  const { worksheet: a } = i;
  if (a.getMergeData().some((d) => s.some((h) => O.intersects(h, d))))
    throw new Error("The ranges to be merged overlap with the existing merged cells");
  n.get(E).executeCommand(ms.id, {
    unitId: e,
    subUnitId: t,
    selections: s,
    defaultMerge: o
  });
}
class lt {
  constructor() {
    /**
     *
     * Map<unitId, Map<subUnitId, Map<subUnitId, IWorksheetProtectionRule>>>
     */
    R(this, "_model", /* @__PURE__ */ new Map());
    R(this, "_ruleChange", new De());
    R(this, "_ruleRefresh", new De());
    R(this, "_resetOrder", new De());
    R(this, "ruleChange$", this._ruleChange.asObservable());
    R(this, "ruleRefresh$", this._ruleRefresh.asObservable());
    R(this, "resetOrder$", this._resetOrder.asObservable());
    R(this, "_worksheetRuleInitStateChange", new gt(!1));
    R(this, "worksheetRuleInitStateChange$", this._worksheetRuleInitStateChange.asObservable());
  }
  changeRuleInitState(e) {
    this._worksheetRuleInitStateChange.next(e);
  }
  getSheetRuleInitState() {
    return this._worksheetRuleInitStateChange.value;
  }
  addRule(e, t) {
    this._ensureSubUnitMap(e).set(t.subUnitId, t), this._ruleChange.next({ unitId: e, rule: t, type: "add", subUnitId: t.subUnitId });
  }
  deleteRule(e, t) {
    var o, r, i;
    const s = (r = (o = this._model) == null ? void 0 : o.get(e)) == null ? void 0 : r.get(t);
    s && ((i = this._model.get(e)) == null || i.delete(t), this._ruleChange.next({ unitId: e, rule: s, type: "delete", subUnitId: t }));
  }
  setRule(e, t, s) {
    var r, i;
    const o = this.getRule(e, t);
    o && ((i = (r = this._model) == null ? void 0 : r.get(e)) == null || i.set(t, s), this._ruleChange.next({ unitId: e, oldRule: o, rule: s, type: "set", subUnitId: t }));
  }
  getRule(e, t) {
    var s, o;
    return (o = (s = this._model) == null ? void 0 : s.get(e)) == null ? void 0 : o.get(t);
  }
  toObject() {
    const e = {};
    return [...this._model.keys()].forEach((s) => {
      const o = this._model.get(s);
      o != null && o.size && (e[s] = [], [...o.keys()].forEach((i) => {
        const a = o.get(i);
        a && e[s].push(a);
      }));
    }), e;
  }
  fromObject(e) {
    const t = /* @__PURE__ */ new Map();
    Object.keys(e).forEach((s) => {
      const o = e[s];
      if (o != null && o.length) {
        const r = /* @__PURE__ */ new Map();
        o.forEach((i) => {
          r.set(i.subUnitId, i);
        }), t.set(s, r);
      }
    }), this._model = t;
  }
  deleteUnitModel(e) {
    this._model.delete(e);
  }
  _ensureSubUnitMap(e) {
    let t = this._model.get(e);
    return t || (t = /* @__PURE__ */ new Map(), this._model.set(e, t)), t;
  }
  ruleRefresh(e) {
    this._ruleRefresh.next(e);
  }
  resetOrder() {
    this._resetOrder.next(Math.random());
  }
  getTargetByPermissionId(e, t) {
    const s = this._model.get(e);
    if (!s) return null;
    for (const [o, r] of s)
      if (r.permissionId === t)
        return [e, o];
  }
}
const Mt = {
  id: "sheet.mutation.add-worksheet-protection",
  type: v.MUTATION,
  handler: (n, e) => {
    const t = n.get(lt), { unitId: s, rule: o } = e;
    return t.addRule(s, o), !0;
  }
}, xt = {
  id: "sheet.mutation.delete-worksheet-protection",
  type: v.MUTATION,
  handler: (n, e) => {
    const t = n.get(lt), { unitId: s, subUnitId: o } = e;
    return t.deleteRule(s, o), !0;
  }
}, oc = {
  type: v.COMMAND,
  id: "sheet.command.add-worksheet-protection",
  async handler(n, e) {
    if (!e)
      return !1;
    const t = n.get(E), s = n.get(V), { rule: o, unitId: r } = e, i = o.subUnitId;
    if (await t.executeCommand(Mt.id, {
      unitId: r,
      rule: o,
      subUnitId: o.subUnitId
    })) {
      const u = [{ id: Mt.id, params: { unitId: r, rule: o, subUnitId: o.subUnitId } }], l = [{ id: xt.id, params: { unitId: r, subUnitId: i } }];
      s.pushUndoRedo({
        unitID: r,
        redoMutations: u,
        undoMutations: l
      });
    }
    return !0;
  }
}, rc = {
  type: v.COMMAND,
  id: "sheet.command.set-worksheet-range-theme-style",
  handler: (n, e) => {
    const t = n.get(E), s = n.get(V), { unitId: o } = e, r = Wa(n, e);
    return t.syncExecuteCommand(tn.id, e) ? (s.pushUndoRedo({
      unitID: o,
      undoMutations: [{ id: nn.id, params: r }],
      redoMutations: [{ id: tn.id, params: e }]
    }), !0) : !1;
  }
}, ic = "sheet.command.append-row", ac = {
  type: v.COMMAND,
  id: ic,
  handler: (n, e) => {
    const t = n.get(E), s = n.get(V), { unitId: o, subUnitId: r, cellValue: i, insertRowNums: a, insertColumnNums: u, maxRows: l, maxColumns: c } = e, d = {
      unitId: o,
      subUnitId: r,
      cellValue: i
    }, h = Ae(
      n,
      d
    ), g = [{ id: ee.id, params: d }], m = [{ id: ee.id, params: h }];
    if (a) {
      const C = {
        unitId: o,
        subUnitId: r,
        range: {
          startRow: l,
          endRow: l,
          startColumn: 0,
          endColumn: c - 1
        }
      }, p = Ws(
        n,
        C
      );
      g.unshift({ id: ke.id, params: C }), m.push({ id: Te.id, params: p });
    }
    if (u) {
      const C = {
        unitId: o,
        subUnitId: r,
        range: {
          startRow: 0,
          endRow: l - 1,
          startColumn: c,
          endColumn: c - 1 + u
        }
      }, p = as(
        n,
        C
      );
      g.unshift({ id: Ue.id, params: C }), m.push({ id: Me.id, params: p });
    }
    return L(g, t).result ? (s.pushUndoRedo({
      unitID: o,
      undoMutations: m,
      redoMutations: g
    }), !0) : !1;
  }
}, Ys = {
  id: "sheet.command.clear-selection-content",
  type: v.COMMAND,
  handler: (n, e) => {
    var S;
    const t = n.get(M), s = n.get(E), o = n.get(z), r = n.get(V), i = n.get(G), a = t.getCurrentUnitForType(B.UNIVER_SHEET);
    if (!a) return !1;
    const u = (e == null ? void 0 : e.unitId) || a.getUnitId(), l = a.getActiveSheet();
    if (!l) return !1;
    const c = (e == null ? void 0 : e.subUnitId) || l.getSheetId(), d = (e == null ? void 0 : e.ranges) || ((S = o.getCurrentSelections()) == null ? void 0 : S.map((I) => I.range));
    if (!(d != null && d.length))
      return !1;
    const h = ls(d, n, u, c), g = {
      subUnitId: c,
      unitId: u,
      cellValue: Nu(h)
    }, m = Ae(
      n,
      g
    ), f = i.onCommandExecute({ id: Ys.id }), C = [{ id: ee.id, params: g }, ...f.redos], p = [...f.undos, { id: ee.id, params: m }];
    return L(C, s).result ? (r.pushUndoRedo({
      // If there are multiple mutations that form an encapsulated project, they must be encapsulated in the same undo redo element.
      // Hooks can be used to hook the code of external controllers to add new actions.
      unitID: u,
      undoMutations: p,
      redoMutations: C
    }), !0) : !1;
  }
}, fs = "sheets.config", qr = {
  largeSheetCellCountThreshold: 6e3,
  batchSize: 3e3
}, yo = {};
var uc = Object.getOwnPropertyDescriptor, lc = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? uc(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, bo = (n, e) => (t, s) => e(t, s, n);
let Ln = class extends ue {
  constructor(e, t) {
    super();
    R(this, "_tasks", /* @__PURE__ */ new Map());
    R(this, "_idleCallbackId", null);
    R(this, "_beforeUnloadHandler", null);
    this._commandService = e, this._univerInstanceService = t, this._setupBeforeUnloadListener(), this.disposeWithMe(() => {
      this._cancelAllTasks(), this._removeBeforeUnloadListener();
    });
  }
  /**
   * Check if there are any pending tasks
   */
  hasPendingTasks() {
    return this._tasks.size > 0;
  }
  /**
   * Get the count of pending mutations across all tasks
   */
  getPendingMutationsCount() {
    let e = 0;
    for (const t of this._tasks.values())
      e += t.mutations.length - t.currentIndex;
    return e;
  }
  /**
   * Schedule mutations to be executed during idle time
   * @param unitId - The workbook unit ID
   * @param subUnitId - The sheet ID (newly created sheet)
   * @param mutations - Remaining SetRangeValuesMutation to execute
   */
  scheduleMutations(e, t, s) {
    if (s.length === 0)
      return;
    const o = `${e}_${t}`;
    this._cancelTask(o), this._tasks.set(o, {
      unitId: e,
      subUnitId: t,
      mutations: s,
      currentIndex: 0
    }), this._scheduleNextIdle();
  }
  /**
   * Cancel scheduled mutations for a specific sheet
   * Called when the sheet is deleted
   */
  cancelScheduledMutations(e, t) {
    const s = `${e}_${t}`;
    this._cancelTask(s);
  }
  _cancelTask(e) {
    this._tasks.delete(e), this._tasks.size === 0 && this._idleCallbackId !== null && (typeof cancelIdleCallback < "u" && cancelIdleCallback(this._idleCallbackId), this._idleCallbackId = null);
  }
  _cancelAllTasks() {
    this._tasks.clear(), this._idleCallbackId !== null && (typeof cancelIdleCallback < "u" && cancelIdleCallback(this._idleCallbackId), this._idleCallbackId = null);
  }
  _scheduleNextIdle() {
    this._idleCallbackId === null && (typeof requestIdleCallback < "u" ? this._idleCallbackId = requestIdleCallback(
      (e) => this._processIdleTasks(e),
      { timeout: 1e3 * 60 }
    ) : this._idleCallbackId = setTimeout(() => {
      this._processIdleTasks({ didTimeout: !1, timeRemaining: () => 16 });
    }, 16));
  }
  _processIdleTasks(e) {
    this._idleCallbackId = null;
    for (const [t, s] of this._tasks) {
      if (!this._isSheetExist(s.unitId, s.subUnitId)) {
        this._tasks.delete(t);
        continue;
      }
      for (s.currentIndex; s.currentIndex < s.mutations.length; ) {
        if (e.timeRemaining() <= 0 && !e.didTimeout) {
          this._scheduleNextIdle();
          return;
        }
        const o = s.mutations[s.currentIndex];
        this._commandService.syncExecuteCommand(o.id, o.params, { onlyLocal: !0 }), s.currentIndex++;
      }
      this._tasks.delete(t);
    }
    this._tasks.size > 0 && this._scheduleNextIdle();
  }
  _isSheetExist(e, t) {
    const s = this._univerInstanceService.getUnit(e, B.UNIVER_SHEET);
    return s ? s.getSheetBySheetId(t) !== null : !1;
  }
  _setupBeforeUnloadListener() {
    typeof window > "u" || (this._beforeUnloadHandler = (e) => {
      if (this.hasPendingTasks())
        return e.preventDefault(), e.returnValue = "", "";
    }, window.addEventListener("beforeunload", this._beforeUnloadHandler));
  }
  _removeBeforeUnloadListener() {
    typeof window > "u" || !this._beforeUnloadHandler || (window.removeEventListener("beforeunload", this._beforeUnloadHandler), this._beforeUnloadHandler = null);
  }
};
Ln = lc([
  bo(0, E),
  bo(1, M)
], Ln);
const Yr = {
  id: "sheet.mutation.copy-worksheet-end",
  type: v.MUTATION,
  handler: () => !0
}, Xr = (n, e) => ({
  subUnitId: e.sheet.id,
  unitId: e.unitId,
  subUnitName: e.sheet.name
}), ln = {
  id: "sheet.mutation.insert-sheet",
  type: v.MUTATION,
  handler: (n, e) => {
    const t = n.get(M), { sheet: s, index: o, unitId: r, styles: i } = e, a = t.getUniverSheetInstance(r);
    return a ? (i && a.addStyles(i), a.addWorksheet(s.id, o, s)) : !1;
  }
};
function cc(n) {
  let e = 0;
  for (const t of Object.keys(n)) {
    const s = n[Number(t)];
    s && (e += Object.keys(s).length);
  }
  return e;
}
function dc(n, e, t, s) {
  const o = [];
  let r = {}, i = 0;
  for (const l in t) {
    const c = Number(l), d = t[c];
    if (!d) continue;
    const h = Object.keys(d).length;
    i > 0 && i + h > s && (o.push(r), r = {}, i = 0), r[c] = d, i += h, i >= s && (o.push(r), r = {}, i = 0);
  }
  i > 0 && o.push(r);
  const a = o.length > 0 ? o[0] : {}, u = o.slice(1).map((l) => ({
    id: ee.id,
    params: {
      unitId: n,
      subUnitId: e,
      cellValue: l,
      __splitChunk__: !0
    }
  }));
  return { firstChunkCellData: a, remainingMutations: u };
}
const Zr = "sheet.command.copy-sheet";
function hc(n, e, t, s, o, r, i) {
  var b, N;
  const u = n.get(Cn).getConfig(fs), l = {
    ...qr,
    ...u == null ? void 0 : u.largeSheetOperation
  }, c = Ni(t.getConfig());
  c.name = mc(e, r, c.name);
  const d = kt();
  c.id = d;
  const h = e.getSheetIndex(t), { cellData: g } = c, f = cc(g) >= l.largeSheetCellCountThreshold;
  let C, p = [];
  if (f) {
    const { firstChunkCellData: U, remainingMutations: T } = dc(
      s,
      d,
      g,
      l.batchSize
    ), k = { ...c, cellData: U };
    C = {
      index: h + 1,
      sheet: k,
      unitId: s
    }, p = T;
  } else
    C = {
      index: h + 1,
      sheet: c,
      unitId: s
    };
  const w = Xr(
    n,
    C
  ), S = i.onCommandExecute({
    id: Zr,
    params: { unitId: s, subUnitId: o, targetSubUnitId: c.id }
  }), I = [
    ...(b = S.preRedos) != null ? b : [],
    { id: ln.id, params: C },
    ...S.redos
  ], y = [
    ...(N = S.preUndos) != null ? N : [],
    { id: Lt.id, params: w },
    ...S.undos
  ];
  return {
    redos: I,
    undos: y,
    unitId: s,
    newSheetId: d,
    isSplit: f,
    scheduledMutations: p
  };
}
const gc = {
  type: v.COMMAND,
  id: Zr,
  handler: (n, e) => {
    const t = n.get(E), s = n.get(V), o = n.get(M), r = n.get(G), i = n.get(it), a = n.get(Ln), u = P(o, e);
    if (!u)
      return !1;
    const { workbook: l, worksheet: c, unitId: d, subUnitId: h } = u, { redos: g, undos: m, newSheetId: f, isSplit: C, scheduledMutations: p } = hc(
      n,
      l,
      c,
      d,
      h,
      i,
      r
    );
    if (L(g, t).result) {
      if (C) {
        if (s.pushUndoRedo({
          unitID: d,
          undoMutations: m,
          redoMutations: []
          // No redo for split case
        }), p.length > 0) {
          for (const S of p)
            t.syncExecuteCommand(S.id, S.params, { syncOnly: !0 });
          t.syncExecuteCommand(Yr.id, { unitId: d, subUnitId: f }, { syncOnly: !0 }), a.scheduleMutations(d, f, p);
        }
      } else
        s.pushUndoRedo({
          unitID: d,
          undoMutations: m,
          redoMutations: g
        });
      return !0;
    }
    return !1;
  }
};
function mc(n, e, t) {
  let s = `${t} ${e.t("sheets.tabs.sheetCopy", "")}`, o = 2;
  for (; n.checkSheetName(s); )
    s = `${t} ${e.t("sheets.tabs.sheetCopy", `${o}`)}`, o++;
  return s;
}
const fc = {
  type: v.COMMAND,
  id: "sheet.command.delete-range-protection",
  async handler(n, e) {
    if (!e)
      return !1;
    const t = n.get(E), s = n.get(V), { unitId: o, subUnitId: r, rule: i } = e, a = {
      unitId: o,
      subUnitId: r,
      ruleIds: [i.id]
    };
    return await t.executeCommand(ot.id, a) && s.pushUndoRedo({
      unitID: o,
      redoMutations: [{ id: ot.id, params: a }],
      undoMutations: [{ id: Be.id, params: { unitId: o, subUnitId: r, rules: [i] } }]
    }), !0;
  }
}, Rc = {
  type: v.COMMAND,
  id: "sheet.command.delete-worksheet-protection",
  handler(n, e) {
    if (!e)
      return !1;
    const t = n.get(E), s = n.get(V), { rule: o, unitId: r, subUnitId: i } = e;
    t.executeCommand(xt.id, {
      unitId: r,
      subUnitId: i
    });
    const a = [{ id: xt.id, params: { unitId: r, subUnitId: i } }], u = [{ id: Mt.id, params: { unitId: r, rule: o, subUnitId: i } }];
    return s.pushUndoRedo({
      unitID: r,
      redoMutations: a,
      undoMutations: u
    }), !0;
  }
}, Cc = {
  type: v.COMMAND,
  id: "sheet.command.remove-worksheet-range-theme-style",
  handler: (n, e) => {
    const t = n.get(E), s = n.get(V), { unitId: o } = e, r = Va(n, e);
    return t.syncExecuteCommand(nn.id, e) ? (s.pushUndoRedo({
      unitID: o,
      undoMutations: [{ id: tn.id, params: r }],
      redoMutations: [{ id: nn.id, params: e }]
    }), !0) : !1;
  }
}, pc = {
  id: "sheet.command.insert-defined-name",
  type: v.COMMAND,
  handler: (n, e) => {
    const t = n.get(E), s = n.get(V);
    if (!e) return !1;
    const o = {
      ...e
    };
    return t.syncExecuteCommand(en.id, o) ? (s.pushUndoRedo({
      unitID: e.unitId,
      undoMutations: [{ id: Nn.id, params: o }],
      redoMutations: [{ id: en.id, params: o }]
    }), !0) : !1;
  }
}, Sc = {
  id: "sheet.command.insert-sheet",
  type: v.COMMAND,
  handler: (n, e) => {
    var C;
    const t = n.get(E), s = n.get(V), o = n.get(M), r = n.get(it), i = Yo(o, { unitId: e == null ? void 0 : e.unitId });
    if (!i) return !1;
    const { unitId: a, workbook: u } = i;
    let l = u.getSheets().length;
    const c = e == null ? void 0 : e.sheet, d = c == null ? void 0 : c.id, h = Oi(c || {});
    e ? (l = (C = e.index) != null ? C : l, h.id = d || kt(), h.name = (c == null ? void 0 : c.name) || u.generateNewSheetName(`${r.t("sheets.tabs.sheet")}`)) : (h.id = kt(), h.name = u.generateNewSheetName(`${r.t("sheets.tabs.sheet")}`));
    const g = {
      index: l,
      sheet: h,
      unitId: a
    }, m = Xr(
      n,
      g
    );
    return t.syncExecuteCommand(ln.id, g) ? (s.pushUndoRedo({
      unitID: a,
      undoMutations: [{ id: Lt.id, params: m }],
      redoMutations: [{ id: ln.id, params: g }]
    }), !0) : !1;
  }
}, cn = {
  id: "sheet.mutation.register-worksheet-range-theme-style",
  type: v.MUTATION,
  handler: (n, e) => {
    const { unitId: t, rangeThemeStyleJson: s, themeName: o } = e, r = n.get(M), i = P(r), a = n.get(ve);
    if (!i) return !1;
    const u = new Rt(o, s);
    return a.registerRangeThemeStyle(t, u), !0;
  }
}, Xs = {
  id: "sheet.mutation.unregister-worksheet-range-theme-style",
  type: v.MUTATION,
  handler: (n, e) => {
    const { unitId: t, themeName: s } = e, o = n.get(M), r = P(o), i = n.get(ve);
    return r ? (i.unregisterRangeThemeStyle(t, s), !0) : !1;
  }
}, wc = {
  id: "sheet.command.register-worksheet-range-theme-style",
  type: v.COMMAND,
  handler: (n, e) => {
    if (!e)
      return !1;
    const { unitId: t, rangeThemeStyle: s } = e, o = n.get(M), r = n.get(E), i = n.get(V);
    if (!P(o)) return !1;
    const u = {
      unitId: t,
      themeName: s.getName(),
      rangeThemeStyleJson: s.toJson()
    }, l = {
      unitId: t,
      themeName: s.getName()
    };
    return r.syncExecuteCommand(cn.id, u) && i.pushUndoRedo({
      unitID: t,
      undoMutations: [{ id: Xs.id, params: l }],
      redoMutations: [{ id: cn.id, params: u }]
    }), !0;
  }
}, Qr = {
  id: "sheet.command.remove-defined-name",
  type: v.COMMAND,
  handler: (n, e) => {
    var c, d;
    const t = n.get(E), s = n.get(V), o = n.get(G);
    if (!e) return !1;
    const r = {
      ...e
    }, i = o.onCommandExecute({ id: Qr.id, params: e }), a = [
      ...(c = i.preRedos) != null ? c : [],
      { id: Nn.id, params: r },
      ...i.redos
    ], u = [
      ...(d = i.preUndos) != null ? d : [],
      { id: en.id, params: r },
      ...i.undos
    ];
    return L(a, t) ? (s.pushUndoRedo({
      unitID: e.unitId,
      undoMutations: u.filter(Boolean),
      redoMutations: a.filter(Boolean)
    }), !0) : !1;
  }
}, Zs = {
  id: "sheet.command.remove-sheet",
  type: v.COMMAND,
  handler: (n, e) => {
    var b, N;
    const t = n.get(E), s = n.get(V), o = n.get(M), r = n.get(G), i = n.get(Cn), a = P(o, e);
    if (!a) return !1;
    const { unitId: u, subUnitId: l, workbook: c, worksheet: d } = a;
    if (c.getSheets().length <= 1) return !1;
    const h = i.getConfig(fs), g = {
      ...qr,
      ...h == null ? void 0 : h.largeSheetOperation
    }, f = Sl(d.getCellMatrix()) >= g.largeSheetCellCountThreshold, C = {
      subUnitId: l,
      unitId: u,
      subUnitName: d.getName()
    }, p = f ? null : hl(n, C), w = r.onCommandExecute({
      id: Zs.id,
      params: { unitId: u, subUnitId: l }
    }), S = [...(b = w.preRedos) != null ? b : [], { id: Lt.id, params: C }, ...w.redos], I = f ? [] : [...(N = w.preUndos) != null ? N : [], { id: ln.id, params: p }, ...w.undos];
    return L(S, t).result ? (f ? s.clearUndoRedo(u) : s.pushUndoRedo({
      unitID: u,
      undoMutations: I,
      redoMutations: S
    }), !0) : !1;
  }
}, Ic = {
  type: v.COMMAND,
  id: "sheet.command.remove-worksheet-merge",
  // eslint-disable-next-line max-lines-per-function
  handler: (n, e) => {
    var D;
    const t = n.get(z), s = n.get(E), o = n.get(V), r = n.get(M), i = (e == null ? void 0 : e.ranges) || ((D = t.getCurrentSelections()) == null ? void 0 : D.map((H) => H.range));
    if (!(i != null && i.length)) return !1;
    const a = P(r);
    if (!a) return !1;
    const { subUnitId: u, unitId: l, worksheet: c } = a, d = {
      unitId: l,
      subUnitId: u,
      ranges: i
    }, g = c.getConfig().mergeData.filter((H) => i.some((F) => O.intersects(F, H)));
    if (!g.length) return !1;
    const m = ye(
      n,
      d
    ), f = t.getCurrentSelections();
    if (!(f != null && f.length)) return !1;
    const C = A.deepClone(f), p = A.deepClone(f), w = p[p.length - 1], { startRow: S, startColumn: I } = w.range;
    w.primary = {
      startRow: S,
      startColumn: I,
      endRow: S,
      endColumn: I,
      actualRow: S,
      actualColumn: I,
      isMerged: !1,
      isMergedMainCell: !1
    };
    const y = vc(c, g), b = {
      unitId: l,
      subUnitId: u,
      cellValue: y.redoParams.getMatrix()
    }, N = {
      unitId: l,
      subUnitId: u,
      cellValue: y.undoParams.getMatrix()
    }, U = [
      { id: se.id, params: m },
      { id: ee.id, params: b },
      { id: ie.id, params: { selections: p } }
    ], T = [
      { id: ne.id, params: m },
      { id: ee.id, params: N },
      { id: ie.id, params: { selections: C } }
    ];
    return L(U, s) ? (o.pushUndoRedo({
      unitID: l,
      undoMutations: T,
      redoMutations: U
    }), !0) : !1;
  }
};
function vc(n, e) {
  const t = new Y(), s = new Y();
  return e.forEach((o) => {
    const { startRow: r, startColumn: i, endColumn: a, endRow: u } = o, l = n.getCellMatrix().getValue(r, i);
    if (l != null && l.s)
      for (let c = r; c <= u; c++)
        for (let d = i; d <= a; d++)
          (c !== r || d !== i) && (t.setValue(c, d, { s: l.s }), s.setValue(c, d, null));
  }), {
    redoParams: t,
    undoParams: s
  };
}
class Ht {
  constructor() {
    R(this, "_borderInfo", {
      type: de.ALL,
      color: "#000000",
      style: Ao.THIN,
      activeBorderType: !1
    });
    R(this, "_borderInfo$", new gt(this._borderInfo));
    R(this, "borderInfo$", this._borderInfo$.asObservable());
  }
  dispose() {
    this._borderInfo$.complete();
  }
  setType(e) {
    this._borderInfo.type = e, this.setActiveBorderType(!0), this._refresh();
  }
  setColor(e) {
    this._borderInfo.color = e, this._refresh();
  }
  setStyle(e) {
    this._borderInfo.style = e, this._refresh();
  }
  setActiveBorderType(e) {
    this._borderInfo.activeBorderType = e;
  }
  getBorderInfo() {
    return this._borderInfo;
  }
  _refresh() {
    this._borderInfo$.next(this._borderInfo);
  }
}
function Hn(n, e) {
  const { startRow: t, startColumn: s, endRow: o, endColumn: r } = n;
  for (let i = t; i <= o; i++)
    for (let a = s; a <= r; a++)
      e(i, a);
}
const Qs = (n, e, t, s) => {
  const { mr: o, worksheet: r } = n;
  e.startRow < 0 || e.startColumn < 0 || Hn(e, (i, a) => {
    var c, d;
    const u = r.getMergedCell(i, a);
    let l = t;
    if (u && (t.bc_tr || t.ml_tr || t.bl_tr || t.tl_mr || t.tl_bc || t.tl_br)) {
      if (s) {
        const h = A.deepClone(
          (c = o.getValue(u.startRow, u.startColumn)) == null ? void 0 : c.s
        );
        l = h != null && h.bd ? Object.assign(h.bd, t) : t;
      }
      o.setValue(u.startRow, u.startColumn, {
        s: {
          bd: l
        }
      });
    } else {
      if (s) {
        const h = A.deepClone((d = o.getValue(i, a)) == null ? void 0 : d.s);
        l = h != null && h.bd ? Object.assign(h.bd, t) : t;
      }
      o.setValue(i, a, { s: { bd: l } });
    }
  });
}, Mc = (n) => {
  const e = {
    startRow: n.startRow - 1,
    startColumn: n.startColumn,
    endRow: n.startRow - 1,
    endColumn: n.endColumn
  }, t = {
    startRow: n.startRow,
    startColumn: n.startColumn - 1,
    endRow: n.endRow,
    endColumn: n.startColumn - 1
  }, s = {
    startRow: n.endRow + 1,
    startColumn: n.startColumn,
    endRow: n.endRow + 1,
    endColumn: n.endColumn
  }, o = {
    startRow: n.startRow,
    startColumn: n.endColumn + 1,
    endRow: n.endRow,
    endColumn: n.endColumn + 1
  }, r = {
    startRow: n.startRow,
    startColumn: n.startColumn,
    endRow: n.startRow,
    endColumn: n.endColumn
  }, i = {
    startRow: n.startRow,
    startColumn: n.startColumn,
    endRow: n.endRow,
    endColumn: n.startColumn
  }, a = {
    startRow: n.endRow,
    startColumn: n.startColumn,
    endRow: n.endRow,
    endColumn: n.endColumn
  }, u = {
    startRow: n.startRow,
    startColumn: n.endColumn,
    endRow: n.endRow,
    endColumn: n.endColumn
  };
  return {
    topRangeOut: e,
    leftRangeOut: t,
    bottomRangeOut: s,
    rightRangeOut: o,
    topRange: r,
    leftRange: i,
    bottomRange: a,
    rightRange: u
  };
};
function _c(n, e, t) {
  const { style: s, color: o, type: r } = n.getBorderInfo(), i = r === de.TOP || r === de.ALL || r === de.OUTSIDE, a = r === de.LEFT || r === de.ALL || r === de.OUTSIDE, u = r === de.BOTTOM || r === de.ALL || r === de.OUTSIDE, l = r === de.RIGHT || r === de.ALL || r === de.OUTSIDE, c = r === de.VERTICAL || r === de.ALL || r === de.INSIDE, d = r === de.HORIZONTAL || r === de.ALL || r === de.INSIDE, h = r.indexOf("tlbr") > -1, g = r.indexOf("tlbc") > -1, m = r.indexOf("tlmr") > -1, f = r.indexOf("bltr") > -1, C = r.indexOf("mltr") > -1, p = r.indexOf("bctr") > -1, w = t[0], {
    topRangeOut: S,
    leftRangeOut: I,
    bottomRangeOut: y,
    rightRangeOut: b,
    topRange: N,
    leftRange: U,
    bottomRange: T,
    rightRange: k
  } = Mc(w), D = new Y(), { worksheet: H, unitId: F, subUnitId: K } = e;
  return {
    worksheet: H,
    unitId: F,
    subUnitId: K,
    style: s,
    color: o,
    type: r,
    top: i,
    left: a,
    right: l,
    bottom: u,
    vertical: c,
    horizontal: d,
    tl_br: h,
    tl_bc: g,
    tl_mr: m,
    bl_tr: f,
    ml_tr: C,
    bc_tr: p,
    topRangeOut: S,
    leftRangeOut: I,
    bottomRangeOut: y,
    rightRangeOut: b,
    topRange: N,
    leftRange: U,
    bottomRange: T,
    rightRange: k,
    range: w,
    mr: D,
    borderStyle: {
      s,
      cl: {
        rgb: o
      }
    }
  };
}
const yc = (n) => {
  const { range: e, mr: t, borderStyle: s, vertical: o, horizontal: r, worksheet: i } = n;
  o && Hn(e, (a, u) => {
    var c, d, h;
    const l = i.getMergedCell(a, u);
    if (l) {
      const g = (c = t.getValue(l.startRow, l.startColumn)) == null ? void 0 : c.s;
      l.startColumn !== e.startColumn && t.setValue(a, u, {
        s: {
          bd: g != null && g.bd ? Object.assign(g.bd, { l: A.deepClone(s) }) : { l: A.deepClone(s) }
        }
      });
    } else {
      if (u !== e.endColumn) {
        const g = (d = t.getValue(a, u)) == null ? void 0 : d.s;
        t.setValue(a, u, {
          s: {
            bd: g != null && g.bd ? Object.assign(g.bd, { r: A.deepClone(s) }) : { r: A.deepClone(s) }
          }
        });
      }
      if (u !== e.startColumn) {
        const g = (h = t.getValue(a, u)) == null ? void 0 : h.s;
        t.setValue(a, u, {
          s: {
            bd: g != null && g.bd ? Object.assign(g.bd, { l: A.deepClone(s) }) : { l: A.deepClone(s) }
          }
        });
      }
    }
  }), r && Hn(e, (a, u) => {
    var c, d, h;
    const l = i.getMergedCell(a, u);
    if (l) {
      const g = (c = t.getValue(l.startRow, l.startColumn)) == null ? void 0 : c.s;
      l.startRow !== e.startRow && t.setValue(a, u, {
        s: {
          bd: g != null && g.bd ? Object.assign(g.bd, { t: A.deepClone(s) }) : { t: A.deepClone(s) }
        }
      });
    } else {
      if (a !== e.endRow) {
        const g = (d = t.getValue(a, u)) == null ? void 0 : d.s;
        t.setValue(a, u, {
          s: {
            bd: g != null && g.bd ? Object.assign(g.bd, { b: A.deepClone(s) }) : { b: A.deepClone(s) }
          }
        });
      }
      if (a !== e.startRow) {
        const g = (h = t.getValue(a, u)) == null ? void 0 : h.s;
        t.setValue(a, u, {
          s: {
            bd: g != null && g.bd ? Object.assign(g.bd, { t: A.deepClone(s) }) : { t: A.deepClone(s) }
          }
        });
      }
    }
  });
};
function bc(n) {
  const { borderStyle: e, tl_br: t, tl_bc: s, tl_mr: o, bl_tr: r, ml_tr: i, bc_tr: a } = n, u = (l, c, d) => {
    Qs(n, l, c, d);
  };
  t && u(n.range, { tl_br: A.deepClone(e) }, !0), s && u(n.range, { tl_bc: A.deepClone(e) }, !0), o && u(n.range, { tl_mr: A.deepClone(e) }, !0), r && u(n.range, { bl_tr: A.deepClone(e) }, !0), i && u(n.range, { ml_tr: A.deepClone(e) }, !0), a && u(n.range, { bc_tr: A.deepClone(e) }, !0);
}
const Ec = (n) => {
  const { top: e, left: t, right: s, bottom: o, borderStyle: r, bottomRange: i, topRange: a, leftRange: u, rightRange: l, bottomRangeOut: c, topRangeOut: d, leftRangeOut: h, rightRangeOut: g } = n, m = (f, C, p) => {
    Qs(n, f, C, p);
  };
  e && (m(d, { b: null }), m(a, { t: A.deepClone(r) }, !0)), o && (m(c, { t: null }), m(i, { b: A.deepClone(r) }, !0)), t && (m(h, { r: null }), m(u, { l: A.deepClone(r) }, !0)), s && (m(g, { l: null }), m(l, { r: A.deepClone(r) }, !0));
}, kc = (n) => {
  const { range: e, worksheet: t, mr: s, top: o, bottom: r, left: i, right: a, vertical: u, horizontal: l, tl_br: c, tl_bc: d, tl_mr: h, bl_tr: g, ml_tr: m, bc_tr: f, topRange: C, bottomRange: p, leftRange: w, rightRange: S, topRangeOut: I, bottomRangeOut: y, leftRangeOut: b, rightRangeOut: N } = n, U = (T, k, D) => {
    Qs(n, T, k, D);
  };
  !o && !r && !i && !a && !u && !l && !c && !d && !h && !g && !m && !f && (Hn(e, (T, k) => {
    var H, F, K, J, ae, oe, le, Se;
    const D = t.getMergedCell(T, k);
    if (D) {
      if (D.endColumn !== e.endColumn) {
        const Z = (H = s.getValue(D.startRow, D.startColumn)) == null ? void 0 : H.s;
        s.setValue(T, k, {
          s: {
            bd: Z != null && Z.bd ? Object.assign(Z.bd, { r: null }) : { r: null }
          }
        });
      }
      if (D.startColumn !== e.startColumn) {
        const Z = (F = s.getValue(D.startRow, D.startColumn)) == null ? void 0 : F.s;
        s.setValue(T, k, {
          s: {
            bd: Z != null && Z.bd ? Object.assign(Z.bd, { l: null }) : { l: null }
          }
        });
      }
      if (D.endRow !== e.endRow) {
        const Z = (K = s.getValue(D.startRow, D.startColumn)) == null ? void 0 : K.s;
        s.setValue(T, k, {
          s: {
            bd: Z != null && Z.bd ? Object.assign(Z.bd, { b: null }) : { b: null }
          }
        });
      }
      if (D.startRow !== e.startRow) {
        const Z = (J = s.getValue(D.startRow, D.startColumn)) == null ? void 0 : J.s;
        s.setValue(T, k, {
          s: {
            bd: Z != null && Z.bd ? Object.assign(Z.bd, { t: null }) : { t: null }
          }
        });
      }
    } else {
      if (k !== e.endColumn) {
        const Z = (ae = s.getValue(T, k)) == null ? void 0 : ae.s;
        s.setValue(T, k, {
          s: {
            bd: Z != null && Z.bd ? Object.assign(Z.bd, { r: null }) : { r: null }
          }
        });
      }
      if (k !== e.startColumn) {
        const Z = (oe = s.getValue(T, k)) == null ? void 0 : oe.s;
        s.setValue(T, k, {
          s: {
            bd: Z != null && Z.bd ? Object.assign(Z.bd, { l: null }) : { l: null }
          }
        });
      }
      if (T !== e.endRow) {
        const Z = (le = s.getValue(T, k)) == null ? void 0 : le.s;
        s.setValue(T, k, {
          s: {
            bd: Z != null && Z.bd ? Object.assign(Z.bd, { b: null }) : { b: null }
          }
        });
      }
      if (T !== e.startRow) {
        const Z = (Se = s.getValue(T, k)) == null ? void 0 : Se.s;
        s.setValue(T, k, {
          s: {
            bd: Z != null && Z.bd ? Object.assign(Z.bd, { t: null }) : { t: null }
          }
        });
      }
    }
  }), U(I, { b: null }), U(C, { t: null }, !0), U(y, { t: null }), U(p, { b: null }, !0), U(b, { r: null }), U(w, { l: null }, !0), U(N, { l: null }), U(S, { r: null }, !0), U(e, { tl_br: null }, !0), U(e, { tl_bc: null }, !0), U(e, { tl_mr: null }, !0), U(e, { bl_tr: null }, !0), U(e, { ml_tr: null }, !0), U(e, { bc_tr: null }, !0));
}, In = {
  id: "sheet.command.set-border",
  type: v.COMMAND,
  handler: (n, e) => {
    var p;
    const t = n.get(E), s = n.get(V), o = n.get(M), r = n.get(z), i = n.get(Ht), a = P(o, e);
    if (!a) return !1;
    const u = (e == null ? void 0 : e.ranges) || ((p = r.getCurrentSelections()) == null ? void 0 : p.map((w) => w.range));
    if (!(u != null && u.length))
      return !1;
    const { activeBorderType: l } = i.getBorderInfo();
    if (!l) return !1;
    const c = _c(i, a, u);
    yc(c), Ec(c), bc(c), kc(c);
    const { unitId: d, subUnitId: h, mr: g } = c, m = {
      unitId: d,
      subUnitId: h,
      cellValue: g.getData()
    }, f = Ae(
      n,
      m
    );
    return t.syncExecuteCommand(ee.id, m) ? (s.pushUndoRedo({
      unitID: d,
      undoMutations: [{ id: ee.id, params: f }],
      redoMutations: [{ id: ee.id, params: m }]
    }), !0) : !1;
  }
}, Uc = {
  id: "sheet.command.set-border-position",
  type: v.COMMAND,
  handler: (n, e) => {
    if (!e.value) return !1;
    const t = n.get(E);
    return n.get(Ht).setType(e.value), t.syncExecuteCommand(In.id);
  }
}, Tc = {
  id: "sheet.command.set-border-style",
  type: v.COMMAND,
  handler: (n, e) => {
    const t = n.get(E);
    return n.get(Ht).setStyle(e.value), t.syncExecuteCommand(In.id);
  }
}, Pc = {
  id: "sheet.command.set-border-color",
  type: v.COMMAND,
  handler: (n, e) => {
    const t = n.get(E);
    return n.get(Ht).setColor(e.value), t.syncExecuteCommand(In.id);
  }
}, Nc = {
  id: "sheet.command.set-border-basic",
  type: v.COMMAND,
  handler: (n, e) => {
    const { unitId: t, subUnitId: s, value: o, ranges: r } = e, { type: i, color: a, style: u } = o, l = n.get(E), c = n.get(Ht);
    return c.setType(i), a && c.setColor(a), c.setStyle(u), l.syncExecuteCommand(In.id, {
      unitId: t,
      subUnitId: s,
      ranges: r
    });
  }
}, Oc = {
  type: v.COMMAND,
  id: "sheet.command.set-col-data",
  handler: (n, e) => {
    const t = n.get(E), s = n.get(V), o = n.get(M), r = P(o, e);
    if (!r) return !1;
    const { columnData: i } = e, { unitId: a, subUnitId: u, worksheet: l } = r, c = {
      subUnitId: u,
      unitId: a,
      columnData: i
    }, d = Ka(c, l);
    return t.syncExecuteCommand(zt.id, c) ? (s.pushUndoRedo({
      unitID: a,
      undoMutations: [{ id: zt.id, params: d }],
      redoMutations: [{ id: zt.id, params: c }]
    }), !0) : !1;
  }
}, dn = {
  type: v.COMMAND,
  id: "sheet.command.set-col-visible-on-cols",
  handler: (n, e) => {
    var p, w;
    const { unitId: t, subUnitId: s, ranges: o } = e, r = n.get(G), i = n.get(E), a = n.get(M), u = P(a, { unitId: t, subUnitId: s });
    if (!u) return !1;
    const { worksheet: l } = u, c = {
      unitId: t,
      subUnitId: s,
      ranges: o
    }, d = {
      unitId: t,
      subUnitId: s,
      reveal: !0,
      selections: o.map((S) => ({ range: S, primary: _e(S, l), style: null }))
    }, h = qa(n, c), g = {
      unitId: t,
      subUnitId: s,
      selections: ti(o).map((S) => ({
        range: S,
        primary: _e(S, l),
        style: null
      }))
    }, m = L([
      { id: on.id, params: c },
      { id: ie.id, params: d }
    ], i), f = r.onCommandExecute({
      id: dn.id,
      params: e
    }), C = L([...f.redos], i);
    if (m.result && C.result) {
      const S = r.afterCommandExecute({
        id: dn.id,
        params: e
      });
      return L(S.redos, i), n.get(V).pushUndoRedo({
        unitID: t,
        undoMutations: [
          { id: sn.id, params: h },
          { id: ie.id, params: g },
          ...(p = f.undos) != null ? p : [],
          ...S.undos
        ],
        redoMutations: [
          ...(w = f.preRedos) != null ? w : [],
          { id: on.id, params: c },
          { id: ie.id, params: d },
          ...f.redos,
          ...S.redos
        ]
      }), !0;
    }
    return !0;
  }
}, ei = {
  type: v.COMMAND,
  id: "sheet.command.set-selected-cols-visible",
  handler: (n) => {
    var l;
    const e = n.get(z), t = n.get(E), s = (l = e.getCurrentSelections()) == null ? void 0 : l.map((c) => c.range).filter((c) => c.rangeType === j.COLUMN);
    if (!(s != null && s.length)) return !1;
    const o = P(n.get(M));
    if (!o) return !1;
    const { worksheet: r, unitId: i, subUnitId: a } = o, u = s.map((c) => r.getHiddenCols(c.startColumn, c.endColumn)).flat();
    return t.executeCommand(dn.id, {
      unitId: i,
      subUnitId: a,
      ranges: u
    });
  }
}, Us = {
  type: v.COMMAND,
  id: "sheet.command.set-col-hidden",
  handler: (n, e) => {
    var w, S, I, y;
    const t = n.get(z), s = n.get(G), o = n.get(M), r = n.get(E);
    let i = (w = e == null ? void 0 : e.ranges) != null && w.length ? e.ranges : (S = t.getCurrentSelections()) == null ? void 0 : S.map((b) => b.range).filter((b) => b.rangeType === j.COLUMN);
    if (!(i != null && i.length)) return !1;
    const a = P(o, e);
    if (!a) return !1;
    const { worksheet: u, unitId: l, subUnitId: c } = a;
    i = Dc(a.worksheet, i);
    const d = { unitId: l, subUnitId: c, ranges: i }, h = {
      unitId: l,
      subUnitId: c,
      selections: ti(i).map((b) => ({
        range: b,
        primary: _e(b, u),
        style: null
      }))
    }, g = Ja(n, d), m = {
      unitId: l,
      subUnitId: c,
      reveal: !0,
      selections: i.map((b) => ({
        range: b,
        primary: _e(b, u),
        style: null
      }))
    }, f = L([
      { id: sn.id, params: d },
      { id: ie.id, params: h }
    ], r), C = s.onCommandExecute({
      id: Us.id,
      params: d
    }), p = L([...C.redos], r);
    if (f.result && p.result) {
      const b = s.afterCommandExecute({
        id: Us.id,
        params: d
      });
      return L(b.redos, r), n.get(V).pushUndoRedo({
        unitID: l,
        undoMutations: [
          { id: on.id, params: g },
          { id: ie.id, params: m },
          ...(I = C.undos) != null ? I : [],
          ...b.undos
        ],
        redoMutations: [
          ...(y = C.preRedos) != null ? y : [],
          { id: sn.id, params: d },
          { id: ie.id, params: h },
          ...C.redos,
          ...b.redos
        ]
      }), !0;
    }
    return !1;
  }
};
function Dc(n, e) {
  const t = n.getRowCount() - 1, s = n.getHiddenCols(), o = [];
  return e.forEach((r) => {
    const i = s.filter((a) => a.startColumn >= r.startColumn && a.endColumn <= r.endColumn);
    if (i.length) {
      let a = r.startColumn;
      i.forEach((u) => {
        u.startColumn > a && (o.push({ startColumn: a, endColumn: u.startColumn - 1, startRow: 0, endRow: t }), a = u.endColumn + 1);
      }), a <= r.endColumn && o.push({ startColumn: a, endColumn: r.endColumn, startRow: 0, endRow: t });
    } else
      o.push(r);
  }), o;
}
function ti(n) {
  return Ac(n).map((t) => {
    const s = t.startColumn === 0 ? t.endColumn + 1 : t.startColumn - 1;
    return {
      ...t,
      startColumn: s,
      endColumn: s
    };
  });
}
function Ac(n) {
  const e = [];
  let t;
  return n.sort((s, o) => s.startColumn - o.startColumn).forEach((s) => {
    if (!t) {
      t = s;
      return;
    }
    t.endColumn === s.startColumn - 1 ? t.endColumn = s.endColumn : (e.push(t), t = s);
  }), e.push(t), e;
}
const ni = {
  id: "sheet.command.set-defined-name",
  type: v.COMMAND,
  handler: (n, e) => {
    var d, h;
    const t = n.get(E), s = n.get(V), o = n.get(G);
    if (!e) return !1;
    const r = {
      ...e
    }, i = ta(n, e), a = o.onCommandExecute({ id: ni.id, params: e }), u = [
      ...(d = a.preRedos) != null ? d : [],
      { id: Nn.id, params: i },
      { id: en.id, params: r },
      ...a.redos
    ], l = [
      ...(h = a.preUndos) != null ? h : [],
      { id: Nn.id, params: r },
      { id: en.id, params: i },
      ...a.undos
    ];
    return L(u, t) ? (s.pushUndoRedo({
      unitID: e.unitId,
      undoMutations: l.filter(Boolean),
      redoMutations: u.filter(Boolean)
    }), !0) : !1;
  }
}, si = (n, e) => {
  const s = n.get(M).getUniverSheetInstance(e.unitId);
  if (s == null)
    throw new Error("universheet is null error!");
  const o = s.getSheetBySheetId(e.subUnitId);
  if (o == null)
    throw new Error("worksheet is null error!");
  const i = o.getConfig().freeze;
  return {
    unitId: e.unitId,
    subUnitId: e.subUnitId,
    ...i
  };
}, st = {
  id: "sheet.mutation.set-frozen",
  type: v.MUTATION,
  handler: (n, e) => {
    const s = n.get(M).getUniverSheetInstance(e.unitId);
    if (s == null)
      throw new Error("universheet is null error!");
    const o = s.getSheetBySheetId(e.subUnitId);
    if (!o) return !1;
    const r = o.getConfig(), { startRow: i, startColumn: a, ySplit: u, xSplit: l } = e;
    return r.freeze = { startRow: i, startColumn: a, ySplit: u, xSplit: l }, !0;
  }
}, xc = {
  type: v.COMMAND,
  id: "sheet.command.set-frozen",
  handler: (n, e) => {
    const t = n.get(E), s = n.get(V), o = n.get(M), r = P(o, { unitId: e.unitId, subUnitId: e.subUnitId });
    if (!r) return !1;
    const { unitId: i, subUnitId: a, worksheet: u } = r, { startColumn: l, startRow: c, xSplit: d, ySplit: h } = e;
    if (c >= u.getRowCount() || l >= u.getColumnCount() || d >= u.getColumnCount() || h >= u.getRowCount())
      return !1;
    const g = {
      unitId: i,
      subUnitId: a,
      ...e
    }, m = si(n, g);
    return t.syncExecuteCommand(st.id, g) ? (s.pushUndoRedo({
      unitID: i,
      undoMutations: [{ id: st.id, params: m }],
      redoMutations: [{ id: st.id, params: g }]
    }), !0) : !1;
  }
}, $c = {
  type: v.COMMAND,
  id: "sheet.command.cancel-frozen",
  handler: (n, e) => {
    const t = n.get(E), s = n.get(M), o = n.get(V), r = P(s, { unitId: e == null ? void 0 : e.unitId, subUnitId: e == null ? void 0 : e.subUnitId });
    if (!r) return !1;
    const { unitId: i, subUnitId: a } = r, u = {
      unitId: i,
      subUnitId: a,
      startRow: -1,
      startColumn: -1,
      xSplit: 0,
      ySplit: 0
    }, l = si(n, u);
    return t.syncExecuteCommand(st.id, u) && o.pushUndoRedo({
      unitID: i,
      undoMutations: [{ id: st.id, params: l }],
      redoMutations: [{ id: st.id, params: u }]
    }), !0;
  }
}, Wc = {
  type: v.COMMAND,
  id: "sheet.command.set-gridlines-color",
  handler: (n, e) => {
    const t = n.get(E), s = n.get(V), o = n.get(M), r = P(o);
    if (!r) return !1;
    const { worksheet: i } = r, a = i.getConfig().gridlinesColor;
    if (a === (e == null ? void 0 : e.color)) return !1;
    const { unitId: u, subUnitId: l } = r, c = {
      color: e == null ? void 0 : e.color,
      unitId: u,
      subUnitId: l
    }, d = {
      color: a,
      unitId: u,
      subUnitId: l
    };
    return t.syncExecuteCommand(Gt.id, c) ? (s.pushUndoRedo({
      unitID: u,
      undoMutations: [{ id: Gt.id, params: d }],
      redoMutations: [{ id: Gt.id, params: c }]
    }), !0) : !1;
  }
}, fe = {
  id: "sheet.mutation.set-range-protection",
  type: v.MUTATION,
  handler: (n, e) => {
    const { unitId: t, subUnitId: s, rule: o, ruleId: r } = e;
    return n.get(me).setRule(t, s, r, o), !0;
  }
}, eg = (n, e) => {
  const { unitId: t, subUnitId: s, ruleId: o } = e, i = n.get(me).getRule(t, s, o);
  return i ? {
    id: fe.id,
    params: {
      ...e,
      rule: i
    }
  } : null;
}, bt = {
  id: "sheet.mutation.set-worksheet-protection",
  type: v.MUTATION,
  handler: (n, e) => {
    const { unitId: t, subUnitId: s, rule: o } = e;
    return n.get(lt).setRule(t, s, o), !0;
  }
}, Vc = {
  type: v.COMMAND,
  id: "sheet.command.set-protection",
  async handler(n, e) {
    if (!e)
      return !1;
    const t = n.get(E), s = n.get(V), o = n.get(me), { rule: r, oldRule: i } = e, { unitId: a, subUnitId: u } = r, l = [], c = [];
    return (i == null ? void 0 : i.unitType) === r.unitType ? r.unitType === x.Worksheet ? (l.push({ id: bt.id, params: { unitId: a, subUnitId: u, rule: r } }), c.push({ id: bt.id, params: { unitId: a, subUnitId: u, rule: i } })) : (l.push({ id: fe.id, params: { unitId: a, subUnitId: u, rule: r, ruleId: r.id } }), c.push({ id: fe.id, params: { unitId: a, subUnitId: u, ruleId: i.id, rule: i } })) : (i && (i.unitType === x.Worksheet ? (l.push({ id: xt.id, params: { unitId: a, subUnitId: u } }), c.push({ id: Mt.id, params: { unitId: a, rule: i, subUnitId: i.subUnitId } })) : i.unitType === x.SelectRange && (l.push({ id: ot.id, params: { unitId: a, subUnitId: u, ruleIds: [i.id] } }), c.push({ id: Be.id, params: { unitId: a, subUnitId: u, rules: [i] } }))), r.unitType === x.Worksheet ? (l.push({ id: Mt.id, params: { unitId: a, rule: r, subUnitId: r.subUnitId } }), c.unshift({ id: xt.id, params: { unitId: a, subUnitId: u } })) : r.unitType === x.SelectRange && (r.id = o.createRuleId(a, u), l.push({ id: Be.id, params: { unitId: a, subUnitId: u, rules: [r] } }), c.unshift({ id: ot.id, params: { unitId: a, subUnitId: u, ruleIds: [r.id] } }))), L(l, t) && s.pushUndoRedo({
      unitID: a,
      undoMutations: c,
      redoMutations: l
    }), !0;
  }
}, Lc = {
  type: v.COMMAND,
  id: "sheet.command.set-row-data",
  handler: (n, e) => {
    const t = n.get(E), s = n.get(V), o = n.get(M), r = P(o, e);
    if (!r) return !1;
    const { rowData: i } = e, { unitId: a, subUnitId: u, worksheet: l } = r, c = {
      subUnitId: u,
      unitId: a,
      rowData: i
    }, d = ru(c, l);
    return t.syncExecuteCommand(Kt.id, c) ? (s.pushUndoRedo({
      unitID: a,
      undoMutations: [{ id: Kt.id, params: d }],
      redoMutations: [{ id: Kt.id, params: c }]
    }), !0) : !1;
  }
}, hn = {
  type: v.COMMAND,
  id: "sheet.command.set-specific-rows-visible",
  handler: (n, e) => {
    var p, w, S;
    const { unitId: t, subUnitId: s, ranges: o } = e, r = n.get(E), i = n.get(V), a = n.get(G), u = P(n.get(M), { unitId: t, subUnitId: s });
    if (!u) return !1;
    const { worksheet: l } = u, c = { unitId: t, subUnitId: s, ranges: o }, d = {
      unitId: t,
      subUnitId: s,
      reveal: !0,
      selections: o.map((I) => ({
        range: I,
        primary: _e(I, l),
        style: null
      }))
    }, h = iu(n, c), g = {
      unitId: t,
      subUnitId: s,
      selections: ri(o).map((I) => ({
        range: I,
        primary: _e(I, l),
        style: null
      }))
    }, m = L(
      [
        { id: Ut.id, params: c },
        { id: ie.id, params: d }
      ],
      r
    ), f = a.onCommandExecute({
      id: hn.id,
      params: e
    }), C = L([...f.redos], r);
    if (m.result && C.result) {
      const I = a.afterCommandExecute({
        id: hn.id,
        params: e
      });
      return L(I.redos, r), i.pushUndoRedo({
        unitID: t,
        undoMutations: [
          ...(p = f.preUndos) != null ? p : [],
          { id: Tt.id, params: h },
          { id: ie.id, params: g },
          ...(w = f.undos) != null ? w : [],
          ...I.undos
        ],
        redoMutations: [
          ...(S = f.preRedos) != null ? S : [],
          { id: Ut.id, params: c },
          { id: ie.id, params: d },
          ...f.redos,
          ...I.redos
        ]
      }), !0;
    }
    return !0;
  }
}, oi = {
  type: v.COMMAND,
  id: "sheet.command.set-selected-rows-visible",
  handler: async (n) => {
    var c;
    const e = n.get(z), t = n.get(M), s = n.get(E), o = (c = e.getCurrentSelections()) == null ? void 0 : c.map((d) => d.range).filter((d) => d.rangeType === j.ROW);
    if (!(o != null && o.length)) return !1;
    const r = P(t);
    if (!r) return !1;
    const { worksheet: i, unitId: a, subUnitId: u } = r, l = o.map((d) => i.getHiddenRows(d.startRow, d.endRow)).flat();
    return s.executeCommand(hn.id, {
      unitId: a,
      subUnitId: u,
      ranges: l
    });
  }
}, Ts = {
  type: v.COMMAND,
  id: "sheet.command.set-rows-hidden",
  handler: (n, e) => {
    var w, S, I, y, b, N;
    const t = n.get(z), s = n.get(E), o = n.get(V), r = n.get(M), i = n.get(G);
    let a = (w = e == null ? void 0 : e.ranges) != null && w.length ? e.ranges : (S = t.getCurrentSelections()) == null ? void 0 : S.map((U) => U.range).filter((U) => U.rangeType === j.ROW);
    if (!(a != null && a.length)) return !1;
    const u = P(r, e);
    if (!u) return !1;
    a = Hc(u.worksheet, a);
    const { unitId: l, subUnitId: c, worksheet: d } = u, h = { unitId: l, subUnitId: c, ranges: a }, g = {
      unitId: l,
      subUnitId: c,
      selections: ri(a).map((U) => ({
        range: U,
        primary: _e(U, d),
        style: null
      }))
    }, m = au(n, h), f = {
      unitId: l,
      subUnitId: c,
      reveal: !0,
      selections: a.map((U) => ({
        range: U,
        primary: _e(U, d),
        style: null
      }))
    }, C = i.onCommandExecute({ id: Ts.id, params: h });
    if (L([
      ...(I = C.preRedos) != null ? I : [],
      { id: Tt.id, params: h },
      { id: ie.id, params: g },
      ...C.redos
    ], s).result) {
      const U = i.afterCommandExecute({
        id: Ts.id,
        params: h
      });
      return L(U.redos, s), o.pushUndoRedo({
        unitID: l,
        undoMutations: [
          ...(y = C.preUndos) != null ? y : [],
          { id: Ut.id, params: m },
          { id: ie.id, params: f },
          ...(b = C.undos) != null ? b : [],
          ...U.undos
        ],
        redoMutations: [
          ...(N = C.preRedos) != null ? N : [],
          { id: Tt.id, params: h },
          { id: ie.id, params: g },
          ...C.redos,
          ...U.redos
        ]
      }), !0;
    }
    return !0;
  }
};
function Hc(n, e) {
  const t = n.getMaxColumns() - 1, s = n.getHiddenRows(), o = [];
  return e.forEach((r) => {
    const i = s.filter((a) => a.startRow >= r.startRow && a.endRow <= r.endRow);
    if (i.length) {
      let a = r.startRow;
      i.forEach((u) => {
        u.startRow > a && (o.push({ startRow: a, endRow: u.startRow - 1, startColumn: 0, endColumn: t }), a = u.endRow + 1);
      }), a <= r.endRow && o.push({ startRow: a, endRow: r.endRow, startColumn: 0, endColumn: t });
    } else
      o.push(r);
  }), o;
}
function ri(n) {
  return Fc(n).map((t) => {
    const s = t.startRow === 0 ? t.endRow + 1 : t.startRow - 1;
    return {
      ...t,
      startRow: s,
      endRow: s
    };
  });
}
function Fc(n) {
  const e = [];
  let t;
  return n.sort((s, o) => s.startRow - o.startRow).forEach((s) => {
    if (!t) {
      t = s;
      return;
    }
    s.startRow === t.endRow + 1 ? t.endRow = s.endRow : (e.push(t), t = s);
  }), e.push(t), e;
}
const Bc = ["ff", "fs", "tr", "tb"], Ce = {
  type: v.COMMAND,
  id: "sheet.command.set-style",
  // eslint-disable-next-line max-lines-per-function
  handler: (n, e) => {
    var T;
    const t = n.get(M), s = P(t, e);
    if (!s) return !1;
    const { unitId: o, subUnitId: r, worksheet: i } = s, { range: a, style: u } = e, l = n.get(E), c = n.get(V), d = n.get(z), h = a ? [a] : (T = d.getCurrentSelections()) == null ? void 0 : T.map((k) => k.range);
    if (!(h != null && h.length))
      return !1;
    const g = new Y(), m = Bu(i);
    if (A.isArray(u.value))
      for (let k = 0; k < h.length; k++)
        m.forOperableEach(h[k], (D, H, F) => {
          g.setValue(D, H, {
            s: {
              [u.type]: u.value[D - F.startRow][H - F.startColumn]
            }
          });
        });
    else
      for (let k = 0; k < h.length; k++) {
        const D = {
          s: {
            [u.type]: u.value
          }
        };
        m.forOperableEach(h[k], (H, F) => g.setValue(H, F, D));
      }
    const f = {
      subUnitId: r,
      unitId: o,
      cellValue: g.getMatrix()
    }, C = n.get(rt).getSkeleton(o, r), p = Ae(
      n,
      f
    ), w = l.syncExecuteCommand(
      ee.id,
      f
    ), S = n.get(G);
    let I = [], y = [];
    if (Bc.includes(e == null ? void 0 : e.style.type)) {
      const { suitableRanges: k, remainingRanges: D } = wn(h, C), H = qs(k, i), { undos: F, redos: K } = S.generateMutationsOfAutoHeight({
        unitId: o,
        subUnitId: r,
        ranges: k,
        autoHeightRanges: k,
        lazyAutoHeightRanges: D,
        cellHeights: H
      });
      I = F, y = K;
    }
    const { undos: b, redos: N } = S.onCommandExecute({
      id: Ce.id,
      params: e
    }), U = L([...N, ...y], l);
    return w && U.result ? (c.pushUndoRedo({
      unitID: f.unitId,
      undoMutations: [{ id: ee.id, params: p }, ...b, ...I],
      redoMutations: [{ id: ee.id, params: f }, ...N, ...y]
    }), !0) : !1;
  }
}, tg = {
  type: v.COMMAND,
  id: "sheet.command.set-bold",
  handler: (n) => {
    const e = n.get(z).getCurrentLastSelection();
    if (!e) return !1;
    const t = P(n.get(M));
    if (!t) return !1;
    const { worksheet: s } = t, { actualRow: o, actualColumn: r } = e.primary, a = {
      style: {
        type: "bl",
        value: s.getRange(o, r).getFontWeight() === Di.BOLD ? te.FALSE : te.TRUE
      }
    };
    return n.get(E).syncExecuteCommand(Ce.id, a);
  }
}, ng = {
  type: v.COMMAND,
  id: "sheet.command.set-italic",
  handler: (n) => {
    const e = n.get(z).getCurrentLastSelection();
    if (!e) return !1;
    const t = P(n.get(M));
    if (!t) return !1;
    const { worksheet: s } = t;
    let o = !0;
    if (e.primary) {
      const { startRow: i, startColumn: a } = e.primary;
      o = s.getRange(i, a).getFontStyle() === Ai.ITALIC;
    }
    const r = {
      style: {
        type: "it",
        value: o ? te.FALSE : te.TRUE
      }
    };
    return n.get(E).syncExecuteCommand(Ce.id, r);
  }
}, sg = {
  type: v.COMMAND,
  id: "sheet.command.set-underline",
  handler: (n) => {
    const e = n.get(z).getCurrentLastSelection();
    if (!e) return !1;
    const t = P(n.get(M));
    if (!t) return !1;
    const { worksheet: s } = t;
    let o = !0;
    e.primary && (o = !!s.getRange(e.primary.startRow, e.primary.startColumn).getUnderline().s);
    const r = {
      style: {
        type: "ul",
        value: {
          s: o ? te.FALSE : te.TRUE
        }
      }
    };
    return n.get(E).syncExecuteCommand(Ce.id, r);
  }
}, og = {
  type: v.COMMAND,
  id: "sheet.command.set-stroke",
  handler: (n) => {
    const e = n.get(z).getCurrentLastSelection();
    if (!e) return !1;
    const t = P(n.get(M));
    if (!t) return !1;
    const { worksheet: s } = t;
    let o = !0;
    e.primary && (o = !!s.getRange(e.primary.actualRow, e.primary.actualColumn).getStrikeThrough().s);
    const r = {
      style: {
        type: "st",
        value: { s: o ? te.FALSE : te.TRUE }
      }
    };
    return n.get(E).syncExecuteCommand(Ce.id, r);
  }
}, rg = {
  type: v.COMMAND,
  id: "sheet.command.set-overline",
  handler: (n) => {
    const e = n.get(z).getCurrentLastSelection();
    if (!e) return !1;
    const t = P(n.get(M));
    if (!t) return !1;
    const { worksheet: s } = t;
    let o = !0;
    e.primary && (o = !!s.getRange(e.primary.startRow, e.primary.startColumn).getOverline().s);
    const r = {
      style: {
        type: "ol",
        value: {
          s: o ? te.FALSE : te.TRUE
        }
      }
    };
    return n.get(E).syncExecuteCommand(Ce.id, r);
  }
}, ig = {
  type: v.COMMAND,
  id: "sheet.command.set-font-family",
  handler: (n, e) => {
    if (!e)
      return !1;
    const t = n.get(E), s = {
      style: {
        type: "ff",
        value: e.value
      }
    };
    return t.syncExecuteCommand(Ce.id, s);
  }
}, ag = {
  type: v.COMMAND,
  id: "sheet.command.set-font-size",
  handler: (n, e) => {
    if (!e)
      return !1;
    const t = n.get(E), s = {
      style: {
        type: "fs",
        value: e.value
      }
    };
    return t.syncExecuteCommand(Ce.id, s);
  }
}, jc = {
  type: v.COMMAND,
  id: "sheet.command.set-text-color",
  handler: (n, e) => {
    if (!e)
      return !1;
    const t = n.get(E), s = {
      style: {
        type: "cl",
        value: {
          rgb: e.value
        }
      }
    };
    return t.syncExecuteCommand(Ce.id, s);
  }
}, zc = {
  type: v.COMMAND,
  id: "sheet.command.reset-text-color",
  handler: (n) => {
    const e = n.get(E), t = {
      style: {
        type: "cl",
        value: {
          rgb: null
          // use null to reset text color
        }
      }
    };
    return e.syncExecuteCommand(Ce.id, t);
  }
}, Gc = {
  type: v.COMMAND,
  id: "sheet.command.set-background-color",
  handler: (n, e) => {
    if (!e || !e.value)
      return !1;
    const t = n.get(E), s = {
      style: {
        type: "bg",
        value: {
          rgb: e.value
        }
      }
    };
    return t.syncExecuteCommand(Ce.id, s);
  }
}, Kc = {
  type: v.COMMAND,
  id: "sheet.command.reset-background-color",
  handler: (n) => {
    const e = n.get(E), t = {
      style: {
        type: "bg",
        value: {
          rgb: null
          // use null to reset background color
        }
      }
    };
    return e.syncExecuteCommand(Ce.id, t);
  }
}, Jc = {
  type: v.COMMAND,
  id: "sheet.command.set-vertical-text-align",
  handler: (n, e) => {
    if (!e)
      return !1;
    const t = n.get(E), s = {
      unitId: e.unitId,
      subUnitId: e.subUnitId,
      range: e.range,
      style: {
        type: "vt",
        value: e.value
      }
    };
    return t.syncExecuteCommand(Ce.id, s);
  }
}, qc = {
  type: v.COMMAND,
  id: "sheet.command.set-horizontal-text-align",
  handler: (n, e) => {
    if (!e)
      return !1;
    const t = n.get(E), s = {
      unitId: e.unitId,
      subUnitId: e.subUnitId,
      range: e.range,
      style: {
        type: "ht",
        value: e.value
      }
    };
    return t.syncExecuteCommand(Ce.id, s);
  }
}, Yc = {
  type: v.COMMAND,
  id: "sheet.command.set-text-wrap",
  handler: (n, e) => {
    if (!e)
      return !1;
    const t = n.get(E), s = {
      unitId: e.unitId,
      subUnitId: e.subUnitId,
      range: e.range,
      style: {
        type: "tb",
        value: e.value
      }
    };
    return t.syncExecuteCommand(Ce.id, s);
  }
}, Xc = {
  type: v.COMMAND,
  id: "sheet.command.set-text-rotation",
  handler: (n, e) => {
    if (!e)
      return !1;
    const t = typeof e.value == "number" ? { a: e.value } : { a: 0, v: te.TRUE }, s = n.get(E), o = {
      unitId: e.unitId,
      subUnitId: e.subUnitId,
      range: e.range,
      style: {
        type: "tr",
        value: t
      }
    };
    return s.syncExecuteCommand(Ce.id, o);
  }
}, Zc = (n, e) => {
  const r = n.get(M).getUniverSheetInstance(e.unitId).getSheetBySheetId(e.subUnitId).getConfig().tabColor;
  return {
    ...A.deepClone(e),
    color: r
  };
}, Un = {
  id: "sheet.mutation.set-tab-color",
  type: v.MUTATION,
  handler: (n, e) => {
    const t = n.get(M).getUniverSheetInstance(e.unitId);
    if (!t) return !1;
    const s = t.getSheetBySheetId(e.subUnitId);
    return s ? (s.getConfig().tabColor = e.color, !0) : !1;
  }
}, Qc = {
  type: v.COMMAND,
  id: "sheet.command.set-tab-color",
  handler: (n, e) => {
    const t = n.get(E), s = n.get(V), o = P(n.get(M));
    if (!o) return !1;
    const { unitId: r, subUnitId: i } = o, a = {
      color: e.value,
      unitId: r,
      subUnitId: i
    }, u = Zc(n, a);
    return t.syncExecuteCommand(Un.id, a) ? (s.pushUndoRedo({
      unitID: r,
      undoMutations: [{ id: Un.id, params: u }],
      redoMutations: [{ id: Un.id, params: a }]
    }), !0) : !1;
  }
}, ii = {
  id: "sheet.mutation.set-workbook-name",
  type: v.MUTATION,
  handler: (n, e) => {
    const t = n.get(M).getUnit(e.unitId, B.UNIVER_SHEET);
    return t ? (t.setName(e.name), !0) : !1;
  }
}, ai = {
  type: v.COMMAND,
  id: "sheet.command.set-workbook-name",
  handler: (n, e) => {
    var u;
    const t = n.get(E), s = n.get(G);
    if (!Yo(n.get(M), e)) return !1;
    const r = s.onCommandExecute({
      id: ai.id,
      params: e
    }), i = {
      name: e.name,
      unitId: e.unitId
    }, a = [
      ...(u = r.preRedos) != null ? u : [],
      { id: ii.id, params: i },
      ...r.redos
    ];
    return L(a, t).result;
  }
}, ed = 4, ui = {
  type: v.COMMAND,
  id: "sheet.command.set-worksheet-activate",
  handler: (n, e, t) => {
    const s = n.get(E), o = P(n.get(M), e);
    if (!o) return !1;
    const { unitId: r, subUnitId: i } = o;
    return new Promise((a) => {
      setTimeout(() => {
        const u = s.syncExecuteCommand(pn.id, {
          unitId: r,
          subUnitId: i
        }, t);
        a(u);
      }, ed);
    });
  }
}, Fn = {
  type: v.COMMAND,
  id: "sheet.command.delta-column-width",
  // eslint-disable-next-line max-lines-per-function
  handler: async (n, e) => {
    const s = n.get(z).getCurrentSelections();
    if (!(s != null && s.length))
      return !1;
    const o = n.get(E), r = n.get(V), i = P(n.get(M));
    if (!i) return !1;
    const { worksheet: a, unitId: u, subUnitId: l } = i, { anchorCol: c, deltaX: d } = e, g = a.getColumnWidth(c) + d, m = s.length === 1 && s[0].range.rangeType === j.ALL, f = s.filter((J) => J.range.rangeType === j.COLUMN), C = m ? j.ALL : f.some(({ range: J }) => {
      const { startColumn: ae, endColumn: oe } = J;
      return ae <= c && c <= oe;
    }) ? j.COLUMN : j.NORMAL;
    let p;
    if (C === j.ALL) {
      const J = a.getRowCount(), ae = new Array(a.getColumnCount()).fill(void 0).map(
        (oe, le) => ({ startRow: 0, endRow: J - 1, startColumn: le, endColumn: le })
      );
      p = {
        subUnitId: l,
        unitId: u,
        colWidth: g,
        ranges: ae
      };
    } else C === j.COLUMN ? p = {
      subUnitId: l,
      unitId: u,
      ranges: f.map((J) => O.clone(J.range)),
      colWidth: g
    } : p = {
      subUnitId: l,
      unitId: u,
      colWidth: g,
      ranges: [
        {
          startRow: 0,
          endRow: a.getMaxRows() - 1,
          startColumn: c,
          endColumn: c
        }
      ]
    };
    const w = n.get(rt).getSkeleton(u, l), { suitableRanges: S, remainingRanges: I } = wn(p.ranges, w);
    qs(S, a);
    const y = n.get(G), { undos: b, redos: N } = y.onCommandExecute({
      id: Fn.id,
      params: p
    }), U = Zo(
      p,
      a
    ), T = o.syncExecuteCommand(
      mt.id,
      p
    ), { undos: k, redos: D } = y.generateMutationsOfAutoHeight({
      unitId: u,
      subUnitId: l,
      ranges: S,
      autoHeightRanges: S,
      lazyAutoHeightRanges: I
    }), { undos: H, redos: F } = n.get(G).afterCommandExecute({
      id: Fn.id,
      params: p
    }), K = L([...N, ...F, ...D], o);
    return T && K.result && r.pushUndoRedo({
      unitID: u,
      undoMutations: [{ id: mt.id, params: U }, ...b, ...H, ...k],
      redoMutations: [{ id: mt.id, params: p }, ...N, ...F, ...D]
    }), !0;
  }
}, Bn = {
  type: v.COMMAND,
  id: "sheet.command.set-worksheet-col-width",
  handler: (n, e) => {
    var y, b, N, U;
    const t = n.get(z), s = n.get(E), o = n.get(V), r = n.get(G), i = (y = e == null ? void 0 : e.ranges) != null && y.length ? e.ranges : (b = t.getCurrentSelections()) == null ? void 0 : b.map((T) => T.range);
    if (!(i != null && i.length)) return !1;
    const a = P(n.get(M), e);
    if (!a) return !1;
    const { subUnitId: u, unitId: l, worksheet: c } = a, d = n.get(rt).getSkeleton(l, u), h = {
      subUnitId: u,
      unitId: l,
      ranges: i,
      colWidth: e.value
    }, { suitableRanges: g, remainingRanges: m } = wn(h.ranges, d);
    qs(g, c);
    const f = Zo(h, c), C = s.syncExecuteCommand(mt.id, h), { undos: p, redos: w } = r.generateMutationsOfAutoHeight({
      unitId: l,
      subUnitId: u,
      ranges: g,
      autoHeightRanges: g,
      lazyAutoHeightRanges: m
    }), S = r.onCommandExecute({
      id: Bn.id,
      params: h
    }), I = L([...S.redos, ...w], s);
    if (C && I.result) {
      const T = r.afterCommandExecute({
        id: Bn.id,
        params: h
      });
      return L(T.redos, s), o.pushUndoRedo({
        unitID: l,
        undoMutations: [
          ...(N = S.preUndos) != null ? N : [],
          { id: mt.id, params: f },
          ...S.undos,
          ...T.undos,
          ...p
        ],
        redoMutations: [
          ...(U = S.preRedos) != null ? U : [],
          { id: mt.id, params: h },
          ...S.redos,
          ...T.redos,
          ...w
        ]
      }), !0;
    }
    return !1;
  }
};
v.COMMAND;
const td = {
  type: v.COMMAND,
  id: "sheet.command.set-worksheet-column-count",
  handler: (n, e) => {
    const { unitId: t, subUnitId: s, columnCount: o } = e, r = n.get(E), i = n.get(V), a = n.get(M);
    if (!P(a, e)) return !1;
    const l = {
      unitId: t,
      subUnitId: s,
      columnCount: o
    }, c = uu(n, l);
    return r.syncExecuteCommand(Jt.id, l) ? (i.pushUndoRedo({
      unitID: t,
      undoMutations: [{ id: Jt.id, params: c }],
      redoMutations: [{ id: Jt.id, params: l }]
    }), !0) : !1;
  }
}, nd = {
  type: v.COMMAND,
  id: "sheet.command.set-worksheet-default-style",
  handler: (n, e) => {
    const t = n.get(E), s = n.get(V), { unitId: o } = e, r = lu(n, e);
    return t.syncExecuteCommand(qt.id, e) ? (s.pushUndoRedo({
      unitID: o,
      undoMutations: [{ id: qt.id, params: r }],
      redoMutations: [{ id: qt.id, params: e }]
    }), !0) : !1;
  }
}, li = (n, e) => {
  const t = Qe(n.get(M), e);
  if (!t)
    throw new Error("[SetWorksheetHideMutationFactory]: worksheet is null error!");
  const { worksheet: s } = t;
  return {
    hidden: s.isSheetHidden(),
    unitId: e.unitId,
    subUnitId: s.getSheetId()
  };
}, St = {
  id: "sheet.mutation.set-worksheet-hidden",
  type: v.MUTATION,
  handler: (n, e) => {
    const t = n.get(M).getUniverSheetInstance(e.unitId);
    if (t == null)
      return !1;
    const s = t.getSheetBySheetId(e.subUnitId);
    return s ? (s.getConfig().hidden = e.hidden, !0) : !1;
  }
}, sd = {
  type: v.COMMAND,
  id: "sheet.command.set-worksheet-hidden",
  handler: (n, e) => {
    const t = n.get(E), s = n.get(V), o = n.get(Vt), r = n.get(it), i = P(n.get(M), e);
    if (!i) return !1;
    const { workbook: a, worksheet: u, unitId: l, subUnitId: c } = i;
    if (u.getConfig().hidden === te.TRUE) return !1;
    const h = {
      unitId: l,
      subUnitId: c,
      hidden: te.TRUE
    }, g = li(n, h);
    return a.getSheets().filter((p) => p.getConfig().hidden === te.FALSE).length === 1 ? (o.emit(r.t("sheets.info.hideSheet")), !1) : t.syncExecuteCommand(St.id, h) ? (s.pushUndoRedo({
      unitID: l,
      undoMutations: [{ id: St.id, params: g }],
      redoMutations: [{ id: St.id, params: h }]
    }), !0) : !1;
  }
}, od = (n, e) => {
  const t = Qe(n.get(M), e);
  if (!t)
    throw new Error("[SetWorksheetNameMutationFactory]: worksheet is null error!");
  const { worksheet: s } = t;
  return {
    unitId: e.unitId,
    name: s.getName(),
    subUnitId: s.getSheetId()
  };
}, jn = {
  id: "sheet.mutation.set-worksheet-name",
  type: v.MUTATION,
  handler: (n, e) => {
    const t = n.get(M).getUniverSheetInstance(e.unitId);
    if (t == null)
      return !1;
    const s = t.getSheetBySheetId(e.subUnitId);
    return s ? (s.getConfig().name = e.name, !0) : !1;
  }
}, eo = {
  type: v.COMMAND,
  id: "sheet.command.set-worksheet-name",
  handler: (n, e) => {
    var m, f;
    const t = n.get(E), s = n.get(V), o = n.get(G), r = P(n.get(M), e);
    if (!r) return !1;
    const { unitId: i, subUnitId: a } = r, u = {
      subUnitId: a,
      name: e.name,
      unitId: i
    }, l = od(
      n,
      u
    ), c = o.onCommandExecute({
      id: eo.id,
      params: e
    }), d = [
      ...(m = c.preRedos) != null ? m : [],
      { id: jn.id, params: u },
      ...c.redos
    ], h = [
      ...(f = c.preUndos) != null ? f : [],
      { id: jn.id, params: l },
      ...c.undos
    ];
    return L(d, t).result ? (s.pushUndoRedo({
      unitID: i,
      undoMutations: h,
      redoMutations: d
    }), !0) : !1;
  }
}, rd = (n, e) => ({
  ...A.deepClone(e),
  toOrder: e.fromOrder,
  fromOrder: e.toOrder
}), Tn = {
  id: "sheet.mutation.set-worksheet-order",
  type: v.MUTATION,
  handler: (n, e) => {
    const t = n.get(M).getUniverSheetInstance(e.unitId);
    if (!t) return !1;
    const s = t.getConfig();
    return s.sheetOrder.splice(e.fromOrder, 1), s.sheetOrder.splice(e.toOrder, 0, e.subUnitId), !0;
  }
}, ci = {
  type: v.COMMAND,
  id: "sheet.command.set-worksheet-order",
  handler: (n, e) => {
    const t = n.get(E), s = n.get(V), o = P(n.get(M), e);
    if (!o) return !1;
    const { workbook: r, unitId: i, subUnitId: a } = o, l = {
      fromOrder: r.getConfig().sheetOrder.indexOf(a),
      toOrder: e.order,
      unitId: i,
      subUnitId: a
    }, c = rd(n, l);
    return t.syncExecuteCommand(Tn.id, l) ? (s.pushUndoRedo({
      unitID: i,
      undoMutations: [{ id: Tn.id, params: c }],
      redoMutations: [{ id: Tn.id, params: l }]
    }), !0) : !1;
  }
};
class vn {
  constructor() {
    R(this, "_model", /* @__PURE__ */ new Map());
    R(this, "_pointChange", new De());
    R(this, "pointChange$", this._pointChange.asObservable());
  }
  addRule(e) {
    this._ensureSubUnitMap(e.unitId).set(e.subUnitId, e), this._pointChange.next(e);
  }
  deleteRule(e, t) {
    var o, r, i;
    const s = (o = this._model.get(e)) == null ? void 0 : o.get(t);
    s && ((i = (r = this._model) == null ? void 0 : r.get(e)) == null || i.delete(t), this._pointChange.next(s));
  }
  getRule(e, t) {
    var s, o;
    return (o = (s = this._model) == null ? void 0 : s.get(e)) == null ? void 0 : o.get(t);
  }
  toObject() {
    const e = {};
    return [...this._model.keys()].forEach((s) => {
      const o = this._model.get(s);
      o != null && o.size && (e[s] = [], [...o.keys()].forEach((i) => {
        const a = o.get(i);
        a && e[s].push(a);
      }));
    }), e;
  }
  fromObject(e) {
    const t = /* @__PURE__ */ new Map();
    Object.keys(e).forEach((s) => {
      const o = e[s];
      if (o != null && o.length) {
        const r = /* @__PURE__ */ new Map();
        o.forEach((i) => {
          r.set(i.subUnitId, i);
        }), t.set(s, r);
      }
    }), this._model = t;
  }
  deleteUnitModel(e) {
    this._model.delete(e);
  }
  _ensureSubUnitMap(e) {
    let t = this._model.get(e);
    return t || (t = /* @__PURE__ */ new Map(), this._model.set(e, t)), t;
  }
  getTargetByPermissionId(e, t) {
    const s = this._model.get(e);
    if (!s) return null;
    for (const [o, r] of s)
      if (r.permissionId === t)
        return [e, o];
  }
}
class di {
  constructor(e, t, s) {
    R(this, "type", x.SelectRange);
    R(this, "subType", _.Delete);
    R(this, "status", q.INIT);
    R(this, "value", !0);
    R(this, "id");
    R(this, "unitId");
    R(this, "subUnitId");
    R(this, "permissionId");
    this.unitId = e, this.subUnitId = t, this.permissionId = s, this.id = `${x.SelectRange}.${_.Delete}.${s}`;
  }
}
class hi {
  constructor(e, t, s) {
    R(this, "type", x.SelectRange);
    R(this, "subType", _.ManageCollaborator);
    R(this, "status", q.INIT);
    R(this, "value", !0);
    R(this, "id");
    R(this, "unitId");
    R(this, "subUnitId");
    R(this, "permissionId");
    this.unitId = e, this.subUnitId = t, this.permissionId = s, this.id = `${x.SelectRange}.${_.ManageCollaborator}.${s}`;
  }
}
const Ee = () => [Bs, Ve, hi, di], pt = [_.Edit, _.View, _.ManageCollaborator, _.Delete], ug = (n = "unitId", e = "subUnitId", t = "permissionId") => Ee().reduce((s, o) => {
  const r = new o(n, e, t);
  return s[r.subType] = r.value, s;
}, {}), gn = () => [
  Pe,
  hr,
  rr,
  fr,
  ir,
  dr,
  zs,
  ur,
  lr,
  Ks,
  js,
  cr,
  mr,
  Gs,
  Xu,
  Rr,
  gr,
  ar,
  nl,
  tl,
  Qu,
  Zu
], id = [
  _.Edit,
  _.Print,
  _.Comment,
  _.View,
  _.Copy,
  _.Export,
  _.ManageCollaborator,
  _.CreateSheet,
  _.DeleteSheet,
  _.RenameSheet,
  _.HideSheet,
  _.Duplicate,
  _.Share,
  _.MoveSheet,
  _.CopySheet,
  _.RecoverHistory,
  _.ViewHistory,
  _.CreatePermissionObject,
  _.InsertRow,
  _.InsertColumn,
  _.DeleteRow,
  _.DeleteColumn
], be = () => [
  Le,
  ds,
  br,
  Sr
], He = () => [
  Cr,
  pr,
  wr,
  Ir,
  vr,
  Mr,
  yr,
  _r,
  Er,
  kr,
  An,
  Zt,
  Qt,
  Ur
], ws = [
  _.Copy,
  _.DeleteColumn,
  _.DeleteRow,
  _.EditExtraObject,
  _.Filter,
  _.InsertColumn,
  _.InsertRow,
  _.InsertHyperlink,
  _.PivotTable,
  _.SetCellStyle,
  _.SetCellValue,
  _.SetColumnStyle,
  _.SetRowStyle,
  _.Sort
];
var ad = Object.getOwnPropertyDescriptor, ud = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? ad(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, ct = (n, e) => (t, s) => e(t, s, n);
const ld = "SHEET_WORKSHEET_PROTECTION_PLUGIN", cd = "SHEET_WORKSHEET_PROTECTION_POINT_PLUGIN";
let zn = class extends Lo {
  constructor(n, e, t, s, o, r, i, a) {
    super(), this._permissionService = n, this._univerInstanceService = e, this._injector = t, this._worksheetProtectionRuleModel = s, this._worksheetProtectionPointRuleModel = o, this._resourceManagerService = r, this._rangeProtectionRuleModel = i, this._logService = a, this._init(), this._initRuleChange(), this._initRuleSnapshot(), this._initPointSnapshot();
  }
  _init() {
    const n = (e) => {
      const t = e.getUnitId(), s = (o) => {
        const r = o.getSheetId();
        [...be(), ...He()].forEach((i) => {
          const a = new i(t, r);
          this._permissionService.addPermissionPoint(a);
        }), this._logService.debug("[WorksheetPermissionService]", "Initialization completed", t, r);
      };
      e.getSheets().forEach((o) => {
        s(o);
      }), e.sheetCreated$.subscribe((o) => {
        s(o);
      }), e.sheetDisposed$.subscribe((o) => {
        const r = o.getSheetId();
        this._rangeProtectionRuleModel.getSubunitRuleList(t, r).forEach((a) => {
          [...Ee()].forEach((u) => {
            const l = new u(t, r, a.permissionId);
            this._permissionService.deletePermissionPoint(l.id);
          });
        }), [...be(), ...He()].forEach((a) => {
          const u = new a(t, r);
          this._permissionService.deletePermissionPoint(u.id);
        });
      });
    };
    this._univerInstanceService.getAllUnitsForType(B.UNIVER_SHEET).forEach((e) => {
      n(e);
    }), this._univerInstanceService.getTypeOfUnitAdded$(B.UNIVER_SHEET).pipe(ro(this.dispose$)).subscribe(n), this._univerInstanceService.getTypeOfUnitDisposed$(B.UNIVER_SHEET).pipe(ro(this.dispose$)).subscribe((e) => {
      e.getSheets().forEach((t) => {
        const s = e.getUnitId(), o = t.getSheetId();
        be().forEach((r) => {
          const i = new r(s, o);
          this._permissionService.deletePermissionPoint(i.id);
        });
      });
    });
  }
  _initRuleChange() {
    this.disposeWithMe(
      this._worksheetProtectionRuleModel.ruleChange$.subscribe((n) => {
        switch (n.type) {
          case "add":
            break;
          case "delete": {
            be().forEach((e) => {
              const t = new e(n.unitId, n.subUnitId);
              this._permissionService.updatePermissionPoint(t.id, !0);
            });
            break;
          }
          case "set": {
            be().forEach((e) => {
              const t = new e(n.unitId, n.subUnitId);
              this._permissionService.updatePermissionPoint(t.id, n.rule);
            });
            break;
          }
        }
      })
    );
  }
  _initRuleSnapshot() {
    const n = () => {
      const t = this._worksheetProtectionRuleModel.toObject();
      return JSON.stringify(t);
    }, e = (t) => {
      if (!t)
        return {};
      try {
        return JSON.parse(t);
      } catch {
        return {};
      }
    };
    this.disposeWithMe(
      this._resourceManagerService.registerPluginResource({
        toJson: n,
        parseJson: e,
        pluginName: ld,
        businesses: [Dn.UNIVER_SHEET],
        onLoad: (t, s) => {
          this._worksheetProtectionRuleModel.fromObject(s), Object.keys(s).forEach((o) => {
            be().forEach((r) => {
              const i = new r(t, o);
              i.value = !1, this._permissionService.addPermissionPoint(i);
            });
          }), this._worksheetProtectionRuleModel.changeRuleInitState(!0);
        },
        onUnLoad: (t) => {
          const s = this._univerInstanceService.getUnit(t);
          s && (s.getSheets().forEach((o) => {
            const r = o.getSheetId();
            [...be(), ...He()].forEach((i) => {
              const a = new i(t, r);
              this._permissionService.deletePermissionPoint(a.id);
            });
          }), gn().forEach((o) => {
            const r = new o(t);
            this._permissionService.deletePermissionPoint(r.id);
          })), this._worksheetProtectionRuleModel.deleteUnitModel(t);
        }
      })
    );
  }
  _initPointSnapshot() {
    const n = () => {
      const t = this._worksheetProtectionPointRuleModel.toObject();
      return JSON.stringify(t);
    }, e = (t) => {
      if (!t)
        return {};
      try {
        return JSON.parse(t);
      } catch {
        return {};
      }
    };
    this.disposeWithMe(
      this._resourceManagerService.registerPluginResource({
        toJson: n,
        parseJson: e,
        pluginName: cd,
        businesses: [Dn.UNIVER_SHEET],
        onLoad: (t, s) => {
          this._worksheetProtectionPointRuleModel.fromObject(s), Object.keys(s).forEach((o) => {
            He().forEach((r) => {
              const i = new r(t, o);
              this._permissionService.addPermissionPoint(i);
            });
          });
        },
        onUnLoad: (t) => {
          this._worksheetProtectionPointRuleModel.deleteUnitModel(t);
        }
      })
    );
  }
};
zn = ud([
  ct(0, $(Ze)),
  ct(1, $(M)),
  ct(2, $(is)),
  ct(3, $(lt)),
  ct(4, $(vn)),
  ct(5, $(Rn)),
  ct(6, $(me)),
  ct(7, $(zo))
], zn);
const to = {
  id: "sheet.mutation.set-worksheet-permission-points",
  type: v.MUTATION,
  handler: (n, e) => {
    const { rule: t } = e;
    return n.get(vn).addRule(t), !0;
  }
}, dd = {
  type: v.COMMAND,
  id: "sheet.command.set-worksheet-permission-points",
  async handler(n, e) {
    if (!e)
      return !1;
    const t = n.get(E), { rule: s } = e;
    return t.executeCommand(to.id, {
      rule: s,
      unitId: s.unitId,
      subUnitId: s.subUnitId
    }), !0;
  }
}, hd = {
  type: v.COMMAND,
  id: "sheet.command.set-worksheet-protection",
  async handler(n, e) {
    if (!e)
      return !1;
    const t = n.get(E), s = n.get(V), { rule: o, permissionId: r, oldRule: i } = e, { unitId: a, subUnitId: u } = o, l = { ...o, permissionId: r };
    if (await t.executeCommand(bt.id, {
      unitId: a,
      subUnitId: u,
      newRule: l
    })) {
      const d = [{ id: bt.id, params: { unitId: a, subUnitId: u, newRule: l } }], h = [{ id: bt.id, params: { unitId: a, subUnitId: u, rule: i } }];
      s.pushUndoRedo({
        unitID: a,
        redoMutations: d,
        undoMutations: h
      });
    }
    return !0;
  }
}, gd = (n, e) => {
  const r = n.get(M).getUniverSheetInstance(e.unitId).getSheetBySheetId(e.subUnitId).getConfig().rightToLeft;
  return {
    ...A.deepClone(e),
    rightToLeft: r
  };
}, Is = {
  id: "sheet.mutation.set-worksheet-right-to-left",
  type: v.MUTATION,
  handler: (n, e) => {
    const t = n.get(M).getUniverSheetInstance(e.unitId);
    if (!t) return !1;
    const s = t.getSheetBySheetId(e.subUnitId);
    if (!s) return !1;
    const o = s.getConfig();
    return o.rightToLeft = e.rightToLeft, !0;
  }
}, lg = {
  type: v.COMMAND,
  id: "sheet.command.set-worksheet-right-to-left",
  handler: async (n, e) => {
    var d;
    const t = n.get(E), s = n.get(V), o = P(n.get(M), e);
    if (!o) return !1;
    const { unitId: r, subUnitId: i } = o;
    let a = te.FALSE;
    e && (a = (d = e.rightToLeft) != null ? d : te.FALSE);
    const u = {
      rightToLeft: a,
      unitId: r,
      subUnitId: i
    }, l = gd(
      n,
      u
    );
    return t.syncExecuteCommand(
      Is.id,
      u
    ) ? (s.pushUndoRedo({
      unitID: r,
      undoMutations: [{ id: Is.id, params: l }],
      redoMutations: [
        { id: Is.id, params: u }
      ]
    }), !0) : !1;
  }
}, md = {
  type: v.COMMAND,
  id: "sheet.command.set-worksheet-row-count",
  handler: (n, e) => {
    const { unitId: t, subUnitId: s, rowCount: o } = e, r = n.get(E), i = n.get(V), a = n.get(M);
    if (!P(a, e)) return !1;
    const l = {
      unitId: t,
      subUnitId: s,
      rowCount: o
    }, c = cu(n, l);
    return r.syncExecuteCommand(Yt.id, l) ? (i.pushUndoRedo({
      unitID: t,
      undoMutations: [{ id: Yt.id, params: c }],
      redoMutations: [{ id: Yt.id, params: l }]
    }), !0) : !1;
  }
}, Gn = {
  type: v.COMMAND,
  id: "sheet.command.delta-row-height",
  // eslint-disable-next-line max-lines-per-function
  handler: async (n, e) => {
    var T, k;
    const s = n.get(z).getCurrentSelections(), o = n.get(G);
    if (!(s != null && s.length))
      return !1;
    const r = P(n.get(M));
    if (!r) return !1;
    const { worksheet: i, subUnitId: a, unitId: u } = r, { anchorRow: l, deltaY: c } = e, h = i.getRowHeight(l) + c, g = s.length === 1 && s[0].range.rangeType === j.ALL, m = s.filter((D) => D.range.rangeType === j.ROW), f = g ? j.ALL : m.some(({ range: D }) => {
      const { startRow: H, endRow: F } = D;
      return H <= l && l <= F;
    }) ? j.ROW : j.NORMAL;
    let C;
    if (f === j.ALL) {
      const D = i.getColumnCount(), H = new Array(i.getRowCount()).fill(void 0).map(
        (F, K) => ({ startRow: K, endRow: K, startColumn: 0, endColumn: D - 1 })
      );
      C = {
        subUnitId: a,
        unitId: u,
        rowHeight: h,
        ranges: H
      };
    } else f === j.ROW ? C = {
      subUnitId: a,
      unitId: u,
      ranges: m.map((D) => O.clone(D.range)),
      rowHeight: h
    } : C = {
      subUnitId: a,
      unitId: u,
      rowHeight: h,
      ranges: [
        {
          startRow: l,
          endRow: l,
          startColumn: 0,
          endColumn: i.getMaxColumns() - 1
        }
      ]
    };
    const p = Qo(C, i), w = {
      unitId: u,
      subUnitId: a,
      ranges: C.ranges,
      autoHeightInfo: te.FALSE
    }, S = Vs(w, i), I = n.get(E), y = n.get(V), b = o.onCommandExecute({
      id: Gn.id,
      params: C
    }), N = L([
      {
        id: nt.id,
        params: C
      },
      {
        id: Fe.id,
        params: w
      }
    ], I), U = L([...b.redos], I);
    if (N.result && U.result) {
      const D = o.afterCommandExecute({
        id: Gn.id,
        params: C
      });
      return L(D.redos, I), y.pushUndoRedo({
        unitID: u,
        undoMutations: [
          ...(T = b.preUndos) != null ? T : [],
          {
            id: nt.id,
            params: p
          },
          {
            id: Fe.id,
            params: S
          },
          ...b.undos,
          ...D.undos
        ],
        redoMutations: [
          ...(k = b.preRedos) != null ? k : [],
          {
            id: nt.id,
            params: C
          },
          {
            id: Fe.id,
            params: w
          },
          ...b.redos,
          ...D.redos
        ]
      }), !0;
    }
    return !1;
  }
}, Kn = {
  type: v.COMMAND,
  id: "sheet.command.set-row-height",
  // eslint-disable-next-line max-lines-per-function
  handler: (n, e) => {
    var S, I, y, b;
    const t = n.get(z), s = n.get(E), o = n.get(V), r = n.get(M), i = n.get(G), a = (S = e == null ? void 0 : e.ranges) != null && S.length ? e.ranges : (I = t.getCurrentSelections()) == null ? void 0 : I.map((N) => N.range);
    if (!(a != null && a.length))
      return !1;
    const u = P(r, e);
    if (!u) return !1;
    const { unitId: l, subUnitId: c, worksheet: d } = u, h = {
      subUnitId: c,
      unitId: l,
      ranges: a,
      rowHeight: e.value
    }, g = Qo(h, d), m = {
      unitId: l,
      subUnitId: c,
      ranges: h.ranges,
      autoHeightInfo: te.FALSE
    }, f = Vs(m, d), C = L([
      {
        id: nt.id,
        params: h
      },
      {
        id: Fe.id,
        params: m
      }
    ], s), p = i.onCommandExecute({
      id: Kn.id,
      params: h
    }), w = L([...p.redos], s);
    if (C.result && w.result) {
      const N = i.afterCommandExecute({
        id: Kn.id,
        params: h
      });
      return L(N.redos, s), o.pushUndoRedo({
        unitID: l,
        undoMutations: [
          ...(y = p.preRedos) != null ? y : [],
          {
            id: nt.id,
            params: g
          },
          {
            id: Fe.id,
            params: f
          },
          ...p.undos,
          ...N.undos
        ],
        redoMutations: [
          ...(b = p.preRedos) != null ? b : [],
          {
            id: nt.id,
            params: h
          },
          {
            id: Fe.id,
            params: m
          },
          ...p.redos,
          ...N.redos
        ]
      }), !0;
    }
    return !1;
  }
}, no = {
  type: v.COMMAND,
  id: "sheet.command.set-row-is-auto-height",
  handler: (n, e) => {
    var N, U;
    const t = n.get(E), s = n.get(V), o = n.get(z), r = n.get(M), i = P(r, e);
    if (!i) return !1;
    const { unitId: a, subUnitId: u, worksheet: l } = i, c = (N = e == null ? void 0 : e.ranges) != null && N.length ? e.ranges : (U = o.getCurrentSelections()) == null ? void 0 : U.map((T) => T.range);
    if (!(c != null && c.length))
      return !1;
    const d = {
      unitId: a,
      subUnitId: u,
      ranges: c,
      autoHeightInfo: te.TRUE
      // Hard code first, maybe it will change by the menu item in the future.
    }, h = Vs(d, l), g = t.syncExecuteCommand(
      Fe.id,
      d
    ), m = n.get(rt).getSkeleton(a, u), { suitableRanges: f, remainingRanges: C } = wn(d.ranges, m), p = n.get(G), { undos: w, redos: S } = p.generateMutationsOfAutoHeight({
      unitId: a,
      subUnitId: u,
      ranges: f,
      autoHeightRanges: f,
      lazyAutoHeightRanges: C
    }), { undos: I, redos: y } = p.onCommandExecute({
      id: no.id,
      params: d
    }), b = L([...y, ...S], t);
    return g && b.result ? (s.pushUndoRedo({
      unitID: a,
      undoMutations: [{ id: Fe.id, params: h }, ...I, ...w],
      redoMutations: [{ id: Fe.id, params: d }, ...y, ...S]
    }), !0) : !1;
  }
}, gi = {
  type: v.COMMAND,
  id: "sheet.command.set-worksheet-show",
  handler: (n, e) => {
    const { unitId: t, subUnitId: s } = e, o = n.get(E), r = n.get(V), i = n.get(M);
    if (!P(n.get(M))) return !1;
    const u = i.getCurrentUnitForType(B.UNIVER_SHEET);
    if (!u) return !1;
    const l = u.getSheetBySheetId(s);
    if (!l || l.getConfig().hidden === te.FALSE) return !1;
    const d = {
      unitId: t,
      subUnitId: s,
      hidden: te.FALSE
    }, h = li(n, d), g = o.syncExecuteCommand(St.id, d), m = {
      unitId: t,
      subUnitId: s
    }, f = o.syncExecuteCommand(
      pn.id,
      m
    );
    return g && f ? (r.pushUndoRedo({
      unitID: t,
      undoMutations: [
        { id: St.id, params: h }
        // { id: SetWorksheetActiveOperation.id, params: unActiveMutationParams },
      ],
      redoMutations: [
        // { id: SetWorksheetActiveOperation.id, params: activeSheetMutationParams },
        { id: St.id, params: d }
      ]
    }), !0) : !1;
  }
}, fd = {
  type: v.COMMAND,
  id: "sheet.command.split-text-to-columns",
  // eslint-disable-next-line max-lines-per-function
  handler: (n, e) => {
    const { unitId: t, subUnitId: s, range: o, delimiter: r, customDelimiter: i, treatMultipleDelimitersAsOne: a } = e, u = n.get(E), l = n.get(M), c = n.get(V);
    if (!P(n.get(M))) return !1;
    const h = l.getCurrentUnitForType(B.UNIVER_SHEET);
    if (!h) return !1;
    const g = h.getSheetBySheetId(s);
    if (!g) return !1;
    const { lastRow: m, rs: f, maxLength: C } = ku(g, o, r, i, a), p = g.getColumnCount(), { startColumn: w } = X.transformRange(o, g);
    if (o.startColumn !== o.endColumn)
      return !1;
    const S = [], I = [], y = w + C + 1 - p;
    if (y > 0) {
      const D = {
        unitId: t,
        subUnitId: s,
        range: {
          startRow: 0,
          endRow: g.getRowCount() - 1,
          startColumn: p - 1,
          endColumn: p - 1 + y
        }
      };
      S.push({
        id: Ue.id,
        params: D
      });
      const H = as(
        n,
        D
      );
      I.push({ id: Me.id, params: H });
    }
    const b = {
      startRow: o.startRow,
      endRow: m,
      startColumn: w,
      endColumn: w + C
    }, N = new Y();
    for (let D = b.startRow; D <= b.endRow; D++)
      for (let H = b.startColumn; H <= b.endColumn; H++) {
        const F = f[D - b.startRow];
        H === 0 && (F == null ? void 0 : F.length) === 1 ? N.setValue(D, H, g.getCell(D, H)) : N.setValue(D, H, {
          v: (F == null ? void 0 : F[H - b.startColumn]) || null,
          p: null,
          f: null,
          si: null,
          custom: null
        });
      }
    const U = {
      unitId: t,
      subUnitId: s,
      cellValue: N.clone()
    }, T = Ae(n, U);
    return S.push({
      id: ee.id,
      params: U
    }), I.unshift({
      id: ee.id,
      params: T
    }), L(S, u).result ? (c.pushUndoRedo({
      unitID: t,
      undoMutations: I,
      redoMutations: S
    }), !0) : !1;
  }
}, Rd = {
  id: "sheet.command.toggle-cell-checkbox",
  type: v.COMMAND,
  handler: (n, e) => {
    if (!e)
      return !1;
    const { unitId: t, subUnitId: s, row: o, col: r, paragraphIndex: i } = e, u = n.get(M).getUnit(t, B.UNIVER_SHEET), l = u == null ? void 0 : u.getSheetBySheetId(s), c = n.get(V), d = n.get(E);
    if (!l)
      return !1;
    const h = l.getCell(o, r);
    if (!(h != null && h.p))
      return !1;
    const g = A.deepClone(h.p), m = new xi(g), f = $i.paragraph.bullet.toggleChecklist({
      document: m,
      paragraphIndex: i
    });
    if (!f)
      return !1;
    Wi.apply(m.getBody(), f.serialize());
    const C = {
      unitId: t,
      subUnitId: s,
      cellValue: {
        [o]: {
          [r]: {
            p: g,
            t: re.STRING
          }
        }
      }
    }, p = {
      id: ee.id,
      params: C
    }, w = Ae(n, C), S = {
      id: ee.id,
      params: w
    }, I = [p], y = [S];
    return c.pushUndoRedo({
      redoMutations: I,
      undoMutations: y,
      unitID: t
    }), d.syncExecuteCommand(p.id, p.params);
  }
}, Cd = {
  type: v.COMMAND,
  id: "sheet.command.toggle-gridlines",
  handler: (n, e) => {
    const t = n.get(E), s = n.get(V), o = n.get(M), r = P(o);
    if (!r) return !1;
    const { worksheet: i } = r, a = i.getConfig().showGridlines;
    if (a === (e == null ? void 0 : e.showGridlines)) return !1;
    const { unitId: u, subUnitId: l } = r, c = {
      showGridlines: a === te.TRUE ? te.FALSE : te.TRUE,
      unitId: u,
      subUnitId: l
    }, d = {
      showGridlines: a,
      unitId: u,
      subUnitId: l
    };
    return t.syncExecuteCommand(Xt.id, c) ? (s.pushUndoRedo({
      unitID: u,
      undoMutations: [{ id: Xt.id, params: d }],
      redoMutations: [{ id: Xt.id, params: c }]
    }), !0) : !1;
  }
}, pd = {
  id: "sheet.command.unregister-worksheet-range-theme-style",
  type: v.COMMAND,
  handler: (n, e) => {
    var h;
    if (!e)
      return !1;
    const { unitId: t, themeName: s } = e, o = n.get(M), r = n.get(E), i = n.get(V), a = n.get(ve);
    if (!P(o)) return !1;
    const l = {
      unitId: t,
      themeName: s
    }, c = {
      unitId: t,
      themeName: s,
      rangeThemeStyleJson: (h = a.getRangeThemeStyle(t, s)) == null ? void 0 : h.toJson()
    };
    return r.syncExecuteCommand(cn.id, e) && i.pushUndoRedo({
      unitID: t,
      undoMutations: [{ id: cn.id, params: c }],
      redoMutations: [{ id: Xs.id, params: l }]
    }), !0;
  }
}, Sd = {
  id: "sheet.mutation.add-range-theme",
  type: v.MUTATION,
  handler: (n, e) => {
    if (!e)
      return !1;
    const { styleJSON: t, unitId: s } = e, o = n.get(ve), r = new Rt(t.name);
    return r.fromJson(t), o.registerRangeThemeStyle(s, r), !0;
  }
}, wd = {
  id: "sheet.mutation.empty",
  type: v.MUTATION,
  handler: () => !0
}, Id = {
  id: "sheet.operation.mark-dirty-row-auto-height",
  type: v.OPERATION,
  handler: () => !0
}, vd = {
  id: "sheet.operation.cancel-mark-dirty-row-auto-height",
  type: v.OPERATION,
  handler: () => !0
}, $t = $s("INumfmtService"), cg = (n, e) => {
  const t = n.get($t), { values: s, unitId: o, subUnitId: r } = e, i = [], a = [];
  Object.keys(s).forEach((l) => {
    s[l].ranges.forEach((d) => {
      X.foreach(d, (h, g) => {
        const m = t.getValue(o, r, h, g);
        m ? i.push({
          pattern: m.pattern,
          row: h,
          col: g
        }) : a.push({ startColumn: g, endColumn: g, startRow: h, endRow: h });
      });
    });
  });
  const u = [];
  if (i.length) {
    const l = Ps(o, r, i);
    Object.keys(l.values).forEach((c) => {
      const d = l.values[c];
      d.ranges = nr(d.ranges);
    }), u.push({
      id: so.id,
      params: Ps(o, r, i)
    });
  }
  return a.length && u.push({
    id: mi.id,
    params: {
      unitId: o,
      subUnitId: r,
      ranges: a
    }
  }), u;
}, so = {
  id: "sheet.mutation.set.numfmt",
  type: v.MUTATION,
  handler: (n, e) => {
    if (!e)
      return !1;
    const { values: t, refMap: s } = e, o = n.get($t), r = e.unitId, i = e.subUnitId, a = Object.keys(t).reduce(
      (u, l) => {
        const c = s[l], d = t[l].ranges;
        return c && u.push({
          ...c,
          ranges: d
        }), u;
      },
      []
    );
    return o.setValues(r, i, a), !0;
  }
}, mi = {
  id: "sheet.mutation.remove.numfmt",
  type: v.MUTATION,
  handler: (n, e) => {
    if (!e)
      return !1;
    const { unitId: t, subUnitId: s, ranges: o } = e;
    return n.get($t).deleteValues(t, s, o), !0;
  }
}, dg = (n, e) => {
  const t = n.get($t), { ranges: s, unitId: o, subUnitId: r } = e, i = [];
  if (s.forEach((u) => {
    X.foreach(u, (l, c) => {
      const d = t.getValue(o, r, l, c);
      d && i.push({
        pattern: d.pattern,
        row: l,
        col: c
      });
    });
  }), !i.length)
    return [];
  const a = Ps(o, r, i);
  return Object.keys(a.values).forEach((u) => {
    const l = a.values[u];
    l.ranges = nr(l.ranges);
  }), [{ id: so.id, params: a }];
}, Ps = (n, e, t) => {
  const s = Uu(t, "pattern"), o = {}, r = {}, i = Tu();
  return Object.keys(s).forEach((a) => {
    const u = s[a], l = i();
    o[l] = {
      pattern: a
    }, u.forEach((c) => {
      r[l] || (r[l] = { ranges: [] }), r[l].ranges.push(Fo(c.row, c.col));
    });
  }), { unitId: n, subUnitId: e, refMap: o, values: r };
}, Md = {
  id: "sheet.mutation.remove-range-theme",
  type: v.MUTATION,
  handler: (n, e) => {
    if (!e)
      return !1;
    const { styleName: t, unitId: s } = e;
    return n.get(ve).unregisterRangeThemeStyle(s, t), !0;
  }
}, _d = {
  id: "sheet.mutation.set-range-theme",
  type: v.MUTATION,
  handler: (n, e) => {
    if (!e)
      return !1;
    const { unitId: t, styleName: s, style: o } = e, i = n.get(ve).getRangeThemeStyle(t, s);
    return i && (o.headerRowStyle && i.setHeaderRowStyle(o.headerRowStyle), o.firstRowStyle && i.setFirstRowStyle(o.firstRowStyle), o.secondRowStyle && i.setSecondRowStyle(o.secondRowStyle), o.lastRowStyle && i.setLastRowStyle(o.lastRowStyle)), !0;
  }
}, yd = {
  id: "sheet.operation.scroll-to-cell",
  type: v.OPERATION,
  handler: () => !0
}, hg = (n, e, t) => {
  const o = n.get(z).getCurrentSelections(), { value: r, selections: i, unitId: a, subUnitId: u } = e;
  if (o) {
    const c = o[(o == null ? void 0 : o.length) - 1].primary;
    if (c) {
      const { actualColumn: d, actualRow: h } = c;
      let { startRow: g, startColumn: m, endRow: f, endColumn: C } = i[i.length - 1];
      if (r === Re.COLUMNS) {
        const I = t.find((y) => y.startColumn === d && y.endColumn === d && h === y.startRow);
        I && (C = I.endColumn, g = I.startRow, f = I.endRow);
      } else if (r === Re.ROWS) {
        const I = t.find((y) => y.startRow === h && y.endRow === h && d === y.startColumn);
        I && (f = I.endRow, m = I.startColumn, C = I.endColumn);
      }
      const p = {
        startRow: g,
        startColumn: m,
        endRow: f,
        endColumn: C,
        actualRow: h,
        actualColumn: d,
        isMerged: !0,
        isMergedMainCell: g === h && m === d
      }, w = o.map((I, y, b) => ({
        range: I.range,
        style: null,
        primary: y === b.length - 1 ? p : null
      })), S = {
        unitId: a,
        subUnitId: u,
        type: we.ONLY_SET,
        selections: w
      };
      return {
        id: ie.id,
        params: S
      };
    }
    return null;
  }
  return null;
}, gg = (n, e) => {
  const s = n.get(z).getCurrentSelections(), { unitId: o, subUnitId: r } = e;
  if (s && s[(s == null ? void 0 : s.length) - 1].primary) {
    const u = {
      unitId: o,
      subUnitId: r,
      type: we.ONLY_SET,
      selections: [...s]
    };
    return {
      id: ie.id,
      params: u
    };
  }
  return null;
}, bd = "maxCellsPerSheet", Ed = 3e6;
var kd = Object.getOwnPropertyDescriptor, Ud = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? kd(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, Eo = (n, e) => (t, s) => e(t, s, n);
const Td = "SHEET_DEFINED_NAME_PLUGIN", mg = "AllDefaultWorkbook";
let Jn = class extends ue {
  constructor(n, e) {
    super(), this._definedNamesService = n, this._resourceManagerService = e, this._initialize();
  }
  _initialize() {
    this._initSnapshot();
  }
  _initSnapshot() {
    const n = (t) => {
      const s = this._definedNamesService.getDefinedNameMap(t);
      return s ? JSON.stringify(s) : "";
    }, e = (t) => {
      if (!t)
        return {};
      try {
        return JSON.parse(t);
      } catch {
        return {};
      }
    };
    this.disposeWithMe(
      this._resourceManagerService.registerPluginResource({
        pluginName: Td,
        businesses: [B.UNIVER_SHEET],
        toJson: (t) => n(t),
        parseJson: (t) => e(t),
        onUnLoad: (t) => {
          this._definedNamesService.removeUnitDefinedName(t);
        },
        onLoad: (t, s) => {
          this._definedNamesService.registerDefinedNames(t, s);
        }
      })
    );
  }
};
Jn = Ud([
  Eo(0, Ko),
  Eo(1, Rn)
], Jn);
var Pd = Object.getOwnPropertyDescriptor, Nd = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? Pd(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, vs = (n, e) => (t, s) => e(t, s, n);
const Od = [
  st.id
], Dd = [
  ke.id,
  Ue.id,
  Te.id,
  Me.id,
  Je.id,
  qe.id
];
let qn = class extends ue {
  constructor(e, t, s) {
    var r, i;
    super();
    R(this, "_d", new Et());
    R(this, "_enabled", !0);
    this._univerInstanceService = e, this._commandService = t, this._configService = s;
    const o = (i = (r = this._configService.getConfig(fs)) == null ? void 0 : r.freezeSync) != null ? i : !0;
    this.setEnabled(o);
  }
  getEnabled() {
    return this._enabled;
  }
  setEnabled(e) {
    e ? this._d.dispose() : this._initOnlyLocalListener(), this._enabled = e;
  }
  _initOnlyLocalListener() {
    this._d.add(
      this._commandService.beforeCommandExecuted((e, t) => {
        Od.includes(e.id) && (t || (t = {}), t.onlyLocal = !0);
      })
    ), this._d.add(
      this._commandService.onCommandExecuted((e, t) => {
        if (Dd.includes(e.id) && (t != null && t.fromCollab)) {
          const { id: s, params: o } = e;
          s === ke.id ? this._handleInsertRowMutation(o, t) : s === Ue.id ? this._handleInsertColMutation(o, t) : s === Te.id ? this._handleRemoveRowMutation(o, t) : s === Me.id ? this._handleRemoveColMutation(o, t) : s === Je.id ? this._handleMoveRowsMutation(o, t) : s === qe.id && this._handleMoveColsMutation(o, t);
        }
      })
    );
  }
  _handleInsertRowMutation(e, t) {
    const { range: s, unitId: o, subUnitId: r } = e, i = this._getFreeze(o, r);
    if (i && s.startRow < i.startRow) {
      const a = s.endRow - s.startRow + 1, u = {
        ...i,
        startRow: Math.max(1, i.startRow + a),
        ySplit: Math.max(1, i.ySplit + a)
      };
      this._sequenceExecute(o, r, u, t);
    }
  }
  _handleInsertColMutation(e, t) {
    const { range: s, unitId: o, subUnitId: r } = e, i = this._getFreeze(o, r);
    if (i && s.startColumn < i.startColumn) {
      const a = s.endColumn - s.startColumn + 1, u = {
        ...i,
        startColumn: Math.max(1, i.startColumn + a),
        xSplit: Math.max(1, i.xSplit + a)
      };
      this._sequenceExecute(o, r, u, t);
    }
  }
  _handleRemoveRowMutation(e, t) {
    const { range: s, unitId: o, subUnitId: r } = e, i = this._getFreeze(o, r);
    if (i && s.startRow < i.startRow) {
      const a = Math.min(i.startRow, s.endRow + 1) - s.startRow, u = {
        ...i,
        startRow: Math.max(1, i.startRow - a),
        ySplit: Math.max(1, i.ySplit - a)
      };
      this._sequenceExecute(o, r, u, t);
    }
  }
  _handleRemoveColMutation(e, t) {
    const { range: s, unitId: o, subUnitId: r } = e, i = this._getFreeze(o, r);
    if (i && s.startColumn < i.startColumn) {
      const a = Math.min(i.startColumn, s.endColumn + 1) - s.startColumn, u = {
        ...i,
        startColumn: Math.max(1, i.startColumn - a),
        xSplit: Math.max(1, i.xSplit - a)
      };
      this._sequenceExecute(o, r, u, t);
    }
  }
  _handleMoveRowsMutation(e, t) {
    const { sourceRange: s, targetRange: o, unitId: r, subUnitId: i } = e, a = this._getFreeze(r, i);
    if (!a || a.startRow <= 0 || s.startRow >= a.startRow && o.startRow >= a.startRow || s.endRow < a.startRow && o.endRow < a.startRow)
      return;
    const u = s.endRow - s.startRow + 1, l = Math.max(
      Math.min(a.startRow, s.endRow + 1) - s.startRow,
      0
    ), c = { ...a };
    o.startRow >= a.startRow ? (c.startRow = Math.max(1, a.startRow - l), c.ySplit = Math.max(1, a.ySplit - l)) : (c.startRow = a.startRow + u - l, c.ySplit = a.ySplit + u - l), this._sequenceExecute(r, i, c, t);
  }
  _handleMoveColsMutation(e, t) {
    const { sourceRange: s, targetRange: o, unitId: r, subUnitId: i } = e, a = this._getFreeze(r, i);
    if (!a || a.startColumn <= 0 || s.startColumn >= a.startColumn && o.startColumn >= a.startColumn || s.endColumn < a.startColumn && o.endColumn < a.startColumn)
      return;
    const u = s.endColumn - s.startColumn + 1, l = Math.max(
      Math.min(a.startColumn, s.endColumn + 1) - s.startColumn,
      0
    ), c = { ...a };
    o.startColumn >= a.startColumn ? (c.startColumn = Math.max(1, a.startColumn - l), c.xSplit = Math.max(1, a.xSplit - l)) : (c.startColumn = a.startColumn + u - l, c.xSplit = a.xSplit + u - l), this._sequenceExecute(r, i, c, t);
  }
  _getFreeze(e, t) {
    const s = this._univerInstanceService.getUnit(e, B.UNIVER_SHEET);
    if (!s) return null;
    const o = s.getSheetBySheetId(t);
    return o ? o.getFreeze() : null;
  }
  _sequenceExecute(e, t, s, o) {
    L([
      {
        id: st.id,
        params: {
          ...s,
          unitId: e,
          subUnitId: t,
          resetScroll: !1
        }
      }
    ], this._commandService, o);
  }
};
qn = Nd([
  vs(0, $(M)),
  vs(1, E),
  vs(2, Cn)
], qn);
var Ad = Object.getOwnPropertyDescriptor, xd = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? Ad(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, ze = (n, e) => (t, s) => e(t, s, n);
let Yn = class extends ue {
  constructor(e, t, s, o, r, i, a, u, l, c) {
    super();
    R(this, "disposableCollection", new Et());
    R(this, "_triggerPermissionUIEvent$", new De());
    R(this, "triggerPermissionUIEvent$", this._triggerPermissionUIEvent$.asObservable());
    this._commandService = e, this._univerInstanceService = t, this._permissionService = s, this._selectionManagerService = o, this._rangeProtectionRuleModel = r, this._worksheetProtectionRuleModel = i, this._localeService = a, this._lexerTreeBuilder = u, this._contextService = l, this._definedNamesService = c, this._initialize();
  }
  blockExecuteWithoutPermission(e) {
    throw this._triggerPermissionUIEvent$.next(e), new Vi("have no permission");
  }
  _getPermissionCheck(e, t) {
    let s = !0, o = "";
    switch (e) {
      case Sn.id:
        Bo(t.value) && t.value.f ? (s = this._permissionCheckWithFormula(t), o = this._localeService.t("permission.dialog.formulaErr")) : s = this._permissionCheckBySetRangeValue({
          workbookTypes: [Pe],
          rangeTypes: [Ve],
          worksheetTypes: [An, Le]
        }, t);
        break;
      case Ys.id:
        s = this.permissionCheckWithRanges(
          {
            workbookTypes: [Pe],
            rangeTypes: [Ve],
            worksheetTypes: [An, Le]
          },
          t == null ? void 0 : t.ranges,
          t == null ? void 0 : t.unitId,
          t == null ? void 0 : t.subUnitId
        ), o = this._localeService.t("permission.dialog.editErr");
        break;
      case Fn.id:
      case Bn.id:
        s = this.permissionCheckWithoutRange({
          worksheetTypes: [Zt]
        }), o = this._localeService.t("permission.dialog.setRowColStyleErr");
        break;
      case Gn.id:
      case Kn.id:
      case no.id:
        s = this.permissionCheckWithoutRange({
          worksheetTypes: [Qt]
        }), o = this._localeService.t("permission.dialog.setRowColStyleErr");
        break;
      case un.id:
      case an.id:
        s = this._permissionCheckByMoveCommand(t), o = this._localeService.t("permission.dialog.moveRowColErr");
        break;
      case yt.id:
        s = this._permissionCheckByMoveRangeCommand(t), o = this._localeService.t("permission.dialog.moveRangeErr");
        break;
      case ci.id:
        s = this._permissionCheckByWorksheetCommand([Pe, Gs]), o = this._localeService.t("permission.dialog.operatorSheetErr"), s === !1 && this._worksheetProtectionRuleModel.resetOrder();
        break;
      case eo.id:
        s = this._permissionCheckByWorksheetCommand([Pe, Ks]), o = this._localeService.t("permission.dialog.operatorSheetErr"), s === !1 && this._worksheetProtectionRuleModel.resetOrder();
        break;
      case gi.id:
        {
          const { unitId: r, subUnitId: i } = t;
          s = this._permissionCheckByWorksheetCommand([Pe, js], r, i), o = this._localeService.t("permission.dialog.operatorSheetErr"), s === !1 && this._worksheetProtectionRuleModel.resetOrder();
        }
        break;
      case dn.id:
        s = this.permissionCheckWithRanges(
          {
            workbookTypes: [Pe],
            rangeTypes: [Ve],
            worksheetTypes: [Le, Zt]
          },
          t.ranges,
          t.unitId,
          t.subUnitId
        ), o = this._localeService.t("permission.dialog.setRowColStyleErr");
        break;
      case hn.id:
        s = this.permissionCheckWithRanges(
          {
            workbookTypes: [Pe],
            rangeTypes: [Ve],
            worksheetTypes: [Le, Qt]
          },
          t.ranges,
          t.unitId,
          t.subUnitId
        ), o = this._localeService.t("permission.dialog.setRowColStyleErr");
        break;
      case ei.id:
        s = this.permissionCheckWithRanges({
          workbookTypes: [Pe],
          rangeTypes: [Ve],
          worksheetTypes: [Le, Zt]
        }), o = this._localeService.t("permission.dialog.setRowColStyleErr");
        break;
      case oi.id:
        s = this.permissionCheckWithRanges({
          workbookTypes: [Pe],
          rangeTypes: [Ve],
          worksheetTypes: [Le, Qt]
        }), o = this._localeService.t("permission.dialog.setRowColStyleErr");
        break;
      case rn.id:
        s = this._permissionCheckWithInsertRangeMove("right"), o = this._localeService.t("permission.dialog.insertOrDeleteMoveRangeErr");
        break;
      case Pt.id:
        s = this._permissionCheckWithInsertRangeMove("bottom"), o = this._localeService.t("permission.dialog.insertOrDeleteMoveRangeErr");
        break;
      case It.id:
        s = this._permissionCheckWithInsertRangeMove("left"), o = this._localeService.t("permission.dialog.insertOrDeleteMoveRangeErr");
        break;
      case vt.id:
        s = this._permissionCheckWithInsertRangeMove("top"), o = this._localeService.t("permission.dialog.insertOrDeleteMoveRangeErr");
        break;
    }
    s || this.blockExecuteWithoutPermission(o);
  }
  _initialize() {
    this._commandExecutedListener();
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.beforeCommandExecuted((e) => {
        this._getPermissionCheck(e.id, e == null ? void 0 : e.params);
      })
    ), this.disposeWithMe(
      this._commandService.onCommandExecuted((e) => {
        var t;
        if (e.id === jn.id) {
          const s = e.params, { unitId: o = (t = this._univerInstanceService.getCurrentUnitForType(B.UNIVER_SHEET)) == null ? void 0 : t.getUnitId(), subUnitId: r } = s;
          if (!o || !r)
            return;
          const i = this._worksheetProtectionRuleModel.getRule(o, r), a = this._rangeProtectionRuleModel.getSubunitRuleList(o, r);
          i && this._worksheetProtectionRuleModel.ruleRefresh(i.permissionId), a.length && this._rangeProtectionRuleModel.ruleRefresh(r);
        }
      })
    );
  }
  _permissionCheckWithInsertRangeMove(e) {
    var l;
    const t = P(this._univerInstanceService);
    if (!t)
      return !1;
    const { worksheet: s, unitId: o, subUnitId: r } = t, i = A.deepClone((l = this._selectionManagerService.getCurrentLastSelection()) == null ? void 0 : l.range);
    return !(!i || (e === "top" || e === "bottom" ? i.endRow = s.getRowCount() - 1 : (e === "left" || e === "right") && (i.endColumn = s.getColumnCount() - 1), this._rangeProtectionRuleModel.getSubunitRuleList(o, r).map((c) => c.ranges).flat().some((c) => O.getIntersects(i, c))));
  }
  _permissionCheckByWorksheetCommand(e, t, s) {
    var l, c;
    const o = P(this._univerInstanceService, { unitId: t, subUnitId: s });
    if (!o)
      return !1;
    const { unitId: r, subUnitId: i } = o, a = this._worksheetProtectionRuleModel.getRule(r, i), u = this._rangeProtectionRuleModel.getSubunitRuleList(r, i).length > 0;
    return a || u ? (c = (l = this._permissionService.getPermissionPoint(new zs(r).id)) == null ? void 0 : l.value) != null ? c : !1 : this._permissionService.composePermission(e.map((d) => new d(r).id)).every((d) => d.value);
  }
  permissionCheckWithoutRange(e) {
    var h, g, m, f;
    const t = P(this._univerInstanceService);
    if (!t)
      return !1;
    const { worksheet: s, unitId: o, subUnitId: r } = t, i = this._selectionManagerService.getCurrentLastSelection();
    if (!i)
      return !0;
    const a = (g = (h = i == null ? void 0 : i.primary) == null ? void 0 : h.actualRow) != null ? g : 0, u = (f = (m = i == null ? void 0 : i.primary) == null ? void 0 : m.actualColumn) != null ? f : 0, { workbookTypes: l, worksheetTypes: c, rangeTypes: d } = e;
    return !(l && l.some((p) => {
      var I, y;
      const w = new p(o);
      return ((y = (I = this._permissionService.getPermissionPoint(w.id)) == null ? void 0 : I.value) != null ? y : !1) === !1;
    }) === !0 || c && c.some((p) => {
      var I, y;
      const w = new p(o, r);
      return ((y = (I = this._permissionService.getPermissionPoint(w.id)) == null ? void 0 : I.value) != null ? y : !1) === !1;
    }) === !0 || d && d.some((p) => {
      var b, N, U, T, k;
      const w = (N = (b = s.getCell(a, u)) == null ? void 0 : b.selectionProtection) == null ? void 0 : N[0];
      if (!(w != null && w.ruleId))
        return !1;
      const S = (U = this._rangeProtectionRuleModel.getRule(o, r, w.ruleId)) == null ? void 0 : U.permissionId;
      if (!S)
        return !1;
      const I = new p(o, r, S);
      return ((k = (T = this._permissionService.getPermissionPoint(I.id)) == null ? void 0 : T.value) != null ? k : !1) === !1;
    }) === !0);
  }
  permissionCheckWithRanges(e, t, s, o) {
    var g;
    const r = P(this._univerInstanceService);
    if (!r)
      return !1;
    const { workbook: i, worksheet: a } = r;
    s || (s = i.getUnitId()), o || (o = a.getSheetId());
    const u = t != null ? t : (g = this._selectionManagerService.getCurrentSelections()) == null ? void 0 : g.map((m) => m.range);
    if (!u)
      return !1;
    const { workbookTypes: l, worksheetTypes: c, rangeTypes: d } = e, h = [];
    return l && h.push(...l.map((m) => new m(s).id)), c && h.push(...c.map((m) => new m(s, o).id)), d && this._rangeProtectionRuleModel.getSubunitRuleList(s, o).forEach((m) => {
      u.some((C) => m.ranges.some((p) => O.intersects(p, C))) && h.push(...d.map((C) => new C(s, o, m.permissionId).id));
    }), h.length ? this._permissionService.composePermission(h).every((m) => m.value) : !0;
  }
  _permissionCheckByMoveCommand(e) {
    const t = P(this._univerInstanceService);
    if (!t)
      return !1;
    const { worksheet: s, unitId: o, subUnitId: r } = t, i = e.toRange;
    i.endRow === s.getRowCount() - 1 ? i.endColumn = i.startColumn : i.endRow = i.startRow;
    const a = this._rangeProtectionRuleModel.getSubunitRuleList(o, r).reduce((u, l) => [...u, ...l.ranges], []).filter((u) => O.intersects(u, i));
    return a.length > 0 ? !1 : (a.forEach((u) => {
      var l, c;
      for (let d = u.startRow; d <= u.endRow; d++)
        for (let h = u.startColumn; h <= u.endColumn; h++) {
          const g = (c = (l = s.getCell(d, h)) == null ? void 0 : l.selectionProtection) == null ? void 0 : c[0];
          if ((g == null ? void 0 : g[_.Edit]) === !1)
            return !1;
        }
    }), !0);
  }
  _permissionCheckByMoveRangeCommand(e) {
    const t = P(this._univerInstanceService);
    if (!t)
      return !1;
    const { worksheet: s, unitId: o, subUnitId: r } = t, i = e.toRange, a = this._rangeProtectionRuleModel.getSubunitRuleList(o, r).reduce((u, l) => [...u, ...l.ranges], []).filter((u) => O.intersects(u, i));
    return a.length > 0 ? !1 : (a.forEach((u) => {
      var l, c;
      for (let d = u.startRow; d <= u.endRow; d++)
        for (let h = u.startColumn; h <= u.endColumn; h++) {
          const g = (c = (l = s.getCell(d, h)) == null ? void 0 : l.selectionProtection) == null ? void 0 : c[0];
          if ((g == null ? void 0 : g[_.Edit]) === !1)
            return !1;
        }
    }), !0);
  }
  _permissionCheckBySetRangeValue(e, t) {
    let s = [];
    t.range ? s = [t.range] : s = [new Y(t.value).getDataRange()];
    const { unitId: o, subUnitId: r } = t;
    return this.permissionCheckWithRanges(e, s, o, r);
  }
  _permissionCheckWithFormula(e) {
    var r, i, a, u, l;
    const t = e.value, s = e.range, o = t.f;
    if (o) {
      const c = o.substring(1), d = this._univerInstanceService.getCurrentUnitForType(B.UNIVER_SHEET), h = (r = e.unitId) != null ? r : d.getUnitId(), g = this._definedNamesService.getValueByName(h, c);
      if (g) {
        let m = g.formulaOrRefString;
        m.startsWith(sa.EQUALS) && (m = m.slice(1));
        const f = m.split(",");
        for (let C = 0; C < f.length; C++) {
          const p = f[C], w = oa(p);
          if (w.sheetName) {
            const S = d.getSheetBySheetName(w.sheetName);
            if (!S)
              return !0;
            const { startRow: I, endRow: y, startColumn: b, endColumn: N } = w.range;
            for (let U = I; U <= y; U++)
              for (let T = b; T <= N; T++) {
                const k = (a = (i = S.getCell(U, T)) == null ? void 0 : i.selectionProtection) == null ? void 0 : a[0];
                if ((k == null ? void 0 : k[_.View]) === !1)
                  return !1;
              }
          }
        }
        return !0;
      } else {
        const m = this._lexerTreeBuilder.sequenceNodesBuilder(o);
        if (!m)
          return !0;
        for (let f = 0; f < m.length; f++) {
          const C = m[f];
          if (typeof C == "string" || C.nodeType !== ra.REFERENCE)
            continue;
          const { token: p } = C, w = ia(p), S = w.unitId ? this._univerInstanceService.getUnit(w.unitId) : this._univerInstanceService.getCurrentUnitForType(B.UNIVER_SHEET);
          if (!S) return !0;
          let I = w.sheetName ? S.getSheetBySheetName(w.sheetName) : S.getActiveSheet();
          const y = S.getUnitId();
          if (w.sheetName) {
            if (I = S.getSheetBySheetName(w.sheetName), !I)
              return !0;
            const k = I == null ? void 0 : I.getSheetId();
            if (!this._permissionService.getPermissionPoint(new ds(y, k).id)) return !1;
          }
          if (!I)
            return !0;
          const { startRow: b, endRow: N, startColumn: U, endColumn: T } = w.range;
          for (let k = b; k <= N; k++)
            for (let D = U; D <= T; D++) {
              const H = (l = (u = I.getCell(k, D)) == null ? void 0 : u.selectionProtection) == null ? void 0 : l[0];
              if ((H == null ? void 0 : H[_.View]) === !1)
                return !1;
            }
        }
        return !0;
      }
    }
    if (s) {
      const c = P(this._univerInstanceService);
      if (!c)
        return !1;
      const d = e.unitId || c.unitId, h = e.subUnitId || c.subUnitId, m = this._rangeProtectionRuleModel.getSubunitRuleList(d, h).filter((C) => C.ranges.some((p) => O.intersects(p, s))).map((C) => new Ve(d, h, C.permissionId).id);
      if (!this._permissionService.composePermission(m).every((C) => C.value))
        return !1;
    }
    return !0;
  }
};
Yn = xd([
  ze(0, E),
  ze(1, M),
  ze(2, Ze),
  ze(3, $(z)),
  ze(4, $(me)),
  ze(5, $(lt)),
  ze(6, $(it)),
  ze(7, $(na)),
  ze(8, Ho),
  ze(9, Ko)
], Yn);
var $d = Object.getOwnPropertyDescriptor, Wd = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? $d(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, Ft = (n, e) => (t, s) => e(t, s, n);
let mn = class extends ue {
  constructor(e, t, s, o, r) {
    super();
    R(this, "_unitPermissionInitStateChange", new gt(!1));
    R(this, "unitPermissionInitStateChange$", this._unitPermissionInitStateChange.asObservable());
    this._permissionService = e, this._univerInstanceService = t, this._rangeProtectionRuleModel = s, this._worksheetProtectionRuleModel = o, this._worksheetProtectionPointModel = r, this._init();
  }
  _init() {
    const e = (t) => {
      const s = t.getUnitId();
      gn().forEach((o) => {
        const r = new o(s);
        this._permissionService.addPermissionPoint(r);
      });
    };
    this._univerInstanceService.getAllUnitsForType(B.UNIVER_SHEET).forEach((t) => {
      e(t);
    }), this.disposeWithMe(this._univerInstanceService.getTypeOfUnitAdded$(B.UNIVER_SHEET).subscribe((t) => {
      e(t);
    })), this.disposeWithMe(this._univerInstanceService.getTypeOfUnitDisposed$(B.UNIVER_SHEET).subscribe((t) => {
      const s = t.getUnitId();
      t.getSheets().forEach((o) => {
        const r = o.getSheetId();
        this._rangeProtectionRuleModel.getSubunitRuleList(s, r).forEach((a) => {
          [...Ee()].forEach((u) => {
            const l = new u(s, r, a.permissionId);
            this._permissionService.deletePermissionPoint(l.id);
          });
        }), [...be(), ...He()].forEach((a) => {
          const u = new a(s, r);
          this._permissionService.deletePermissionPoint(u.id);
        });
      }), gn().forEach((o) => {
        const r = new o(s);
        this._permissionService.deletePermissionPoint(r.id);
      }), this._rangeProtectionRuleModel.deleteUnitModel(s), this._worksheetProtectionPointModel.deleteUnitModel(s), this._worksheetProtectionRuleModel.deleteUnitModel(s);
    }));
  }
  changeUnitInitState(e) {
    this._unitPermissionInitStateChange.next(e);
  }
};
mn = Wd([
  Ft(0, $(Ze)),
  Ft(1, $(M)),
  Ft(2, $(me)),
  Ft(3, $(lt)),
  Ft(4, $(vn))
], mn);
var Vd = Object.getOwnPropertyDescriptor, Ld = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? Vd(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, Ge = (n, e) => (t, s) => e(t, s, n);
let Xn = class extends ue {
  constructor(n, e, t, s, o, r, i, a, u, l) {
    super(), this._univerInstanceService = n, this._permissionService = e, this._authzIoService = t, this._rangeProtectionRuleModel = s, this._worksheetProtectionRuleModel = o, this._userManagerService = r, this._worksheetProtectionPointRuleModel = i, this._workbookPermissionService = a, this._undoRedoService = u, this._commandService = l;
  }
  initPermission() {
    this._initRangePermissionFromSnapshot(), this._initRangePermissionChange(), this._initWorksheetPermissionFromSnapshot(), this._initWorksheetPermissionChange(), this._initWorksheetPermissionPointsChange(), this._initWorkbookPermissionFromSnapshot(), this._initUserChange(), this._refreshPermissionByCollaCreate();
  }
  refreshRangeProtectPermission() {
    this._initRangePermissionFromSnapshot();
  }
  async _initRangePermissionFromSnapshot() {
    const n = async (e) => {
      const t = [], s = e.getUnitId(), o = e.getSheets(), r = /* @__PURE__ */ new Map();
      if (o.forEach((i) => {
        const a = i.getSheetId();
        this._rangeProtectionRuleModel.getSubunitRuleList(s, a).forEach((u) => {
          r.set(u.permissionId, u), t.push({
            objectID: u.permissionId,
            unitID: s,
            objectType: x.SelectRange,
            actions: pt
          });
        });
      }), !t.length) {
        this._rangeProtectionRuleModel.changeRuleInitState(!0);
        return;
      }
      this._authzIoService.batchAllowed(t).then((i) => {
        i.forEach((a) => {
          const u = r.get(a.objectID);
          if (u) {
            if (!this._rangeProtectionRuleModel.getRule(s, u.subUnitId, u.id))
              return;
            Ee().forEach((c) => {
              const d = new c(s, u.subUnitId, a.objectID), h = d.subType, g = a.actions.find((m) => m.action === h);
              (g == null ? void 0 : g.allowed) !== void 0 && this._permissionService.updatePermissionPoint(d.id, g.allowed);
            });
          }
        }), this._rangeProtectionRuleModel.changeRuleInitState(!0);
      });
    };
    await Promise.all(this._univerInstanceService.getAllUnitsForType(B.UNIVER_SHEET).map((e) => n(e))), this._rangeProtectionRuleModel.changeRuleInitState(!0);
  }
  _initRangePermissionChange() {
    this.disposeWithMe(
      this._rangeProtectionRuleModel.ruleChange$.subscribe((n) => {
        n.type !== "delete" ? this._authzIoService.allowed({
          objectID: n.rule.permissionId,
          unitID: n.unitId,
          objectType: x.SelectRange,
          actions: pt
        }).then((e) => {
          this._rangeProtectionRuleModel.getRule(n.unitId, n.subUnitId, n.rule.id) && (Ee().forEach((s) => {
            if (n.type === "set") {
              const { rule: u, oldRule: l } = n;
              if (u.permissionId === (l == null ? void 0 : l.permissionId))
                return;
            }
            const o = n.rule, r = new s(o.unitId, o.subUnitId, o.permissionId), i = r.subType, a = e.find((u) => u.action === i);
            a && this._permissionService.updatePermissionPoint(r.id, a.allowed);
          }), this._rangeProtectionRuleModel.ruleRefresh(n.rule.permissionId));
        }) : this._rangeProtectionRuleModel.getSubunitRuleList(n.unitId, n.subUnitId).length === 0 && (this._worksheetProtectionPointRuleModel.deleteRule(n.unitId, n.subUnitId), [...He()].forEach((t) => {
          const s = new t(n.unitId, n.subUnitId);
          this._permissionService.updatePermissionPoint(s.id, s.value);
        }));
      })
    );
  }
  async initWorkbookPermissionChange(n) {
    var t;
    const e = n || ((t = this._univerInstanceService.getCurrentUnitForType(B.UNIVER_SHEET)) == null ? void 0 : t.getUnitId());
    if (e)
      return this._authzIoService.allowed({
        objectID: e,
        objectType: x.Workbook,
        unitID: e,
        actions: id
      }).then((s) => {
        gn().forEach((o) => {
          const r = new o(e), i = r.subType, a = s.find((u) => u.action === i);
          a && this._permissionService.updatePermissionPoint(r.id, a.allowed);
        });
      });
  }
  async _initWorkbookPermissionFromSnapshot() {
    await Promise.all(this._univerInstanceService.getAllUnitsForType(B.UNIVER_SHEET).map((n) => this.initWorkbookPermissionChange(n.getUnitId()))), this._workbookPermissionService.changeUnitInitState(!0);
  }
  _initWorksheetPermissionChange() {
    this.disposeWithMe(
      this._worksheetProtectionRuleModel.ruleChange$.subscribe((n) => {
        n.type !== "delete" ? this._authzIoService.allowed({
          objectID: n.rule.permissionId,
          unitID: n.unitId,
          objectType: x.Worksheet,
          actions: pt
        }).then((e) => {
          const t = this._worksheetProtectionRuleModel.getRule(n.unitId, n.subUnitId);
          !t || t.permissionId !== n.rule.permissionId || (be().forEach((s) => {
            const o = new s(n.unitId, n.subUnitId), r = o.subType, i = e.find((a) => a.action === r);
            i && this._permissionService.updatePermissionPoint(o.id, i.allowed);
          }), this._worksheetProtectionRuleModel.ruleRefresh(n.rule.permissionId));
        }) : ([...be(), ...He()].forEach((e) => {
          const t = new e(n.unitId, n.subUnitId);
          this._permissionService.updatePermissionPoint(t.id, !0);
        }), this._worksheetProtectionPointRuleModel.deleteRule(n.unitId, n.subUnitId));
      })
    );
  }
  _initWorksheetPermissionPointsChange() {
    this.disposeWithMe(
      this._worksheetProtectionPointRuleModel.pointChange$.subscribe((n) => {
        this._authzIoService.allowed({
          objectID: n.permissionId,
          unitID: n.unitId,
          objectType: x.Worksheet,
          actions: ws
        }).then((e) => {
          const t = this._worksheetProtectionPointRuleModel.getRule(n.unitId, n.subUnitId);
          !t || t.permissionId !== n.permissionId || He().forEach((s) => {
            const o = new s(n.unitId, n.subUnitId), r = o.subType, i = e.find((a) => a.action === r);
            i && this._permissionService.updatePermissionPoint(o.id, i.allowed);
          });
        });
      })
    );
  }
  async _initWorksheetPermissionFromSnapshot() {
    const n = async (e) => {
      const t = [], s = e.getUnitId(), o = e.getSheets(), r = /* @__PURE__ */ new Map();
      if (o.forEach((i) => {
        const a = i.getSheetId(), u = this._worksheetProtectionRuleModel.getRule(s, a);
        u && (r.set(u.permissionId, u), t.push({
          objectID: u.permissionId,
          unitID: s,
          objectType: x.Worksheet,
          actions: pt
        }));
        const l = this._worksheetProtectionPointRuleModel.getRule(s, a);
        l && (r.set(l.permissionId, l), t.push({
          objectID: l.permissionId,
          unitID: s,
          objectType: x.Worksheet,
          actions: ws
        }));
      }), !t.length) {
        this._worksheetProtectionRuleModel.changeRuleInitState(!0);
        return;
      }
      this._authzIoService.batchAllowed(t).then((i) => {
        i.forEach((a) => {
          const u = r.get(a.objectID);
          if (u) {
            const l = this._worksheetProtectionRuleModel.getRule(s, u.subUnitId) || this._worksheetProtectionPointRuleModel.getRule(s, u.subUnitId);
            if (!l || l.permissionId !== a.objectID)
              return;
            [...be(), ...He()].forEach((c) => {
              const d = new c(s, u.subUnitId), h = d.subType, g = a.actions.find((m) => m.action === h);
              (g == null ? void 0 : g.allowed) !== void 0 && this._permissionService.updatePermissionPoint(d.id, g.allowed);
            });
          }
        }), this._worksheetProtectionRuleModel.changeRuleInitState(!0);
      });
    };
    await Promise.all(this._univerInstanceService.getAllUnitsForType(B.UNIVER_SHEET).map((e) => n(e))), this._worksheetProtectionRuleModel.changeRuleInitState(!0);
  }
  _initUserChange() {
    this.disposeWithMe(
      // When the user changes, the permission points are updated. The first modification needs to be filtered here because it is a Behavior type, but in fact the user information is ready when this controller is initialized.
      this._userManagerService.currentUser$.pipe(Go(1)).subscribe(() => {
        const n = this._permissionService.getAllPermissionPoint();
        this._permissionService.clearPermissionMap(), this._worksheetProtectionRuleModel.changeRuleInitState(!1), this._univerInstanceService.getAllUnitsForType(B.UNIVER_SHEET).forEach((t) => {
          const s = t.getUnitId();
          gn().forEach((o) => {
            let r = new o(s);
            n.has(r.id) && (r = n.get(r.id)), this._permissionService.addPermissionPoint(r);
          }), t.getSheets().forEach((o) => {
            const r = o.getSheetId();
            [...be(), ...He()].forEach((a) => {
              let u = new a(s, r);
              n.has(u.id) && (u = n.get(u.id)), this._permissionService.addPermissionPoint(u);
            }), this._rangeProtectionRuleModel.getSubunitRuleList(s, r).forEach((a) => {
              Ee().forEach((u) => {
                let l = new u(s, r, a.permissionId);
                n.has(l.id) && (l = n.get(l.id)), this._permissionService.addPermissionPoint(l);
              });
            });
          }), this._initWorkbookPermissionFromSnapshot(), this._initWorksheetPermissionFromSnapshot(), this._initRangePermissionFromSnapshot();
        });
      })
    );
  }
  refreshPermission(n, e) {
    const t = this._worksheetProtectionRuleModel.getTargetByPermissionId(n, e);
    let s = !1;
    if (t) {
      const [i, a] = t;
      this._authzIoService.allowed({
        objectID: e,
        unitID: n,
        objectType: x.Worksheet,
        actions: pt
      }).then((u) => {
        if (!this._worksheetProtectionRuleModel.getTargetByPermissionId(n, e))
          return;
        let c = "";
        be().forEach((d) => {
          var f;
          const h = new d(n, a), g = h.subType, m = u.find((C) => C.action === g);
          m && (((f = this._permissionService.getPermissionPoint(h.id)) == null ? void 0 : f.value) !== m.allowed && (s = !0), this._permissionService.updatePermissionPoint(h.id, m.allowed), c += `${m.action}_${m.allowed}`);
        }), this._worksheetProtectionRuleModel.ruleRefresh(`${e}_${c}`), s && this._undoRedoService.clearUndoRedo(n);
      });
    }
    const o = this._worksheetProtectionPointRuleModel.getTargetByPermissionId(n, e);
    if (o) {
      const [i, a] = o;
      this._authzIoService.allowed({
        objectID: e,
        unitID: n,
        objectType: x.Worksheet,
        actions: ws
      }).then((u) => {
        this._worksheetProtectionPointRuleModel.getTargetByPermissionId(n, e) && (He().forEach((c) => {
          var m;
          const d = new c(n, a), h = d.subType, g = u.find((f) => f.action === h);
          g && (((m = this._permissionService.getPermissionPoint(d.id)) == null ? void 0 : m.value) !== g.allowed && (s = !0), this._permissionService.updatePermissionPoint(d.id, g.allowed));
        }), s && this._undoRedoService.clearUndoRedo(n));
      });
    }
    const r = this._rangeProtectionRuleModel.getTargetByPermissionId(n, e);
    if (r) {
      const [i, a] = r;
      this._authzIoService.allowed({
        objectID: e,
        unitID: n,
        objectType: x.SelectRange,
        actions: pt
      }).then((u) => {
        if (!this._rangeProtectionRuleModel.getTargetByPermissionId(n, e))
          return;
        let c = "";
        Ee().forEach((d) => {
          var f;
          const h = new d(n, a, e), g = h.subType, m = u.find((C) => C.action === g);
          m && (((f = this._permissionService.getPermissionPoint(h.id)) == null ? void 0 : f.value) !== m.allowed && (s = !0), this._permissionService.updatePermissionPoint(h.id, m.allowed), c += `${m.action}_${m.allowed}`);
        }), this._rangeProtectionRuleModel.ruleRefresh(`${e}_${c}`), s && this._undoRedoService.clearUndoRedo(n);
      });
    }
  }
  _refreshPermissionByCollaCreate() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((n, e) => {
        if (e != null && e.fromCollab && (n.id === Be.id || n.id === Mt.id || n.id === to.id)) {
          const t = n.params;
          this._undoRedoService.clearUndoRedo(t.unitId);
        }
      })
    );
  }
};
Xn = Ld([
  Ge(0, M),
  Ge(1, Ze),
  Ge(2, Li),
  Ge(3, $(me)),
  Ge(4, $(lt)),
  Ge(5, $(Hi)),
  Ge(6, $(vn)),
  Ge(7, $(mn)),
  Ge(8, $(V)),
  Ge(9, $(E))
], Xn);
var Hd = Object.getOwnPropertyDescriptor, Fd = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? Hd(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, Ms = (n, e) => (t, s) => e(t, s, n);
let Zn = class extends ue {
  constructor(e, t, s) {
    super();
    R(this, "_zebraCacheUpdateSubject", new De());
    this._commandService = e, this._sheetRangeThemeModel = t, this._univerInstanceService = s, this._init();
  }
  _init() {
    this._initializeCommandListener(), this._initTriggerCacheUpdateListener();
  }
  /**
   * Update the zebra crossing cache for a specific unit and sub-unit.
   * @param {string} unitId - The ID of the unit.
   * @param {string} subUnitId - The ID of the sub-unit.
   */
  updateZebraCrossingCache(e, t) {
    this._zebraCacheUpdateSubject.next({ unitId: e, subUnitId: t });
  }
  _initializeCommandListener() {
    this.disposeWithMe(this._commandService.onCommandExecuted((e) => {
      const { id: t } = e;
      let s, o;
      switch (t) {
        case ke.id:
          {
            const r = e.params;
            s = r.unitId, o = r.subUnitId;
          }
          break;
        case Ut.id:
          {
            const r = e.params;
            s = r.unitId, o = r.subUnitId;
          }
          break;
        case Tt.id:
          {
            const r = e.params;
            s = r.unitId, o = r.subUnitId;
          }
          break;
        case Te.id:
          {
            const r = e.params;
            s = r.unitId, o = r.subUnitId;
          }
          break;
        case nt.id:
          {
            const r = e.params;
            s = r.unitId, o = r.subUnitId;
          }
          break;
      }
      s && o && (this._sheetRangeThemeModel.refreshSheetRowVisibleFuncSet(s, o), this._sheetRangeThemeModel.refreshZebraCrossingCacheBySheet(s, o));
    }));
  }
  _initTriggerCacheUpdateListener() {
    this.disposeWithMe(
      this._zebraCacheUpdateSubject.subscribe(({ unitId: e, subUnitId: t }) => {
        this._sheetRangeThemeModel.refreshSheetRowVisibleFuncSet(e, t), this._sheetRangeThemeModel.refreshZebraCrossingCacheBySheet(e, t);
      })
    );
  }
};
Zn = Fd([
  Ms(0, $(E)),
  Ms(1, $(ve)),
  Ms(2, $(M))
], Zn);
var Bd = Object.getOwnPropertyDescriptor, jd = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? Bd(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, ko = (n, e) => (t, s) => e(t, s, n);
let fn = class {
  constructor(n, e) {
    R(this, "_cache", new Fi(1e4));
    this._selectionProtectionRuleModel = n, this._permissionService = e, this._init();
  }
  _init() {
    this._permissionService.permissionPointUpdate$.pipe(
      io((n) => n.type === x.SelectRange),
      io((n) => Ee().some((e) => n instanceof e)),
      da((n) => n)
    ).subscribe((n) => {
      const e = this._selectionProtectionRuleModel.getSubunitRuleList(n.unitId, n.subUnitId);
      for (const t of e)
        t.permissionId === n.permissionId && t.ranges.forEach((s) => {
          X.foreach(s, (o, r) => {
            const i = this._createKey(n.unitId, n.subUnitId, o, r);
            this._cache.delete(i);
          });
        });
    }), this._selectionProtectionRuleModel.ruleChange$.subscribe((n) => {
      var e;
      n.rule.ranges.forEach((t) => {
        X.foreach(t, (s, o) => {
          const r = this._createKey(n.unitId, n.subUnitId, s, o);
          this._cache.delete(r);
        });
      }), n.type === "set" && ((e = n.oldRule) == null || e.ranges.forEach((t) => {
        X.foreach(t, (s, o) => {
          const r = this._createKey(n.unitId, n.subUnitId, s, o);
          this._cache.delete(r);
        });
      }));
    });
  }
  _createKey(n, e, t, s) {
    return `${n}_${e}_${t}_${s}`;
  }
  getCellInfo(n, e, t, s) {
    const o = this._selectionProtectionRuleModel.getSubunitRuleList(n, e), r = [];
    if (!o || !o.length)
      return r;
    const i = this._createKey(n, e, t, s), a = this._cache.get(i);
    if (a)
      return a;
    const u = [];
    for (const l of o)
      if (l.ranges.some((c) => c.startRow <= t && c.endRow >= t && c.startColumn <= s && c.endColumn >= s)) {
        const c = Ee().reduce((d, h) => {
          var f;
          const g = new h(n, e, l.permissionId), m = this._permissionService.getPermissionPoint(g.id);
          return d[g.subType] = (f = m == null ? void 0 : m.value) != null ? f : g.value, d;
        }, {});
        u.push({ ...c, ruleId: l.id, ranges: l.ranges });
      }
    return this._cache.set(i, u), u;
  }
  clear() {
    this._cache.clear();
  }
};
fn = jd([
  ko(0, $(me)),
  ko(1, $(Ze))
], fn);
var zd = Object.getOwnPropertyDescriptor, Gd = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? zd(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, _s = (n, e) => (t, s) => e(t, s, n);
let Wt = class extends ue {
  constructor(e, t, s) {
    super();
    R(this, "_cellRuleCache", /* @__PURE__ */ new Map());
    R(this, "_permissionIdCache", /* @__PURE__ */ new Map());
    R(this, "_cellInfoCache", /* @__PURE__ */ new Map());
    //  {unitId:{subUnitId:{[row/col]:{permissionId1:{edit:true},permissionId2:{edit:true},permissionId3:{edit:false}}}}}
    R(this, "_rowInfoCache", /* @__PURE__ */ new Map());
    R(this, "_colInfoCache", /* @__PURE__ */ new Map());
    this._ruleModel = e, this._permissionService = t, this._univerInstanceService = s, this._initUpdateCellRuleCache(), this._initUpdateCellInfoCache(), this._initUpdateRowColInfoCache(), this._initCache();
  }
  _initCache() {
    this._univerInstanceService.getAllUnitsForType(B.UNIVER_SHEET).forEach((e) => {
      e.getSheets().forEach((t) => {
        const s = e.getUnitId(), o = t.getSheetId();
        this.reBuildCache(s, o);
      });
    });
  }
  _initUpdateCellInfoCache() {
    this._permissionService.permissionPointUpdate$.pipe(
      oo((e) => e.type === x.SelectRange),
      Es((e) => e)
    ).subscribe((e) => {
      const { subUnitId: t, unitId: s, permissionId: o } = e, r = this._permissionIdCache.get(o);
      if (!r)
        return;
      const i = this._ruleModel.getRule(s, t, r);
      if (!i)
        return;
      const a = this._ensureCellInfoMap(s, t);
      i.ranges.forEach((u) => {
        const { startRow: l, endRow: c, startColumn: d, endColumn: h } = u;
        for (let g = l; g <= c; g++)
          for (let m = d; m <= h; m++)
            a.delete(`${g}-${m}`);
      });
    }), this._ruleModel.ruleChange$.subscribe((e) => {
      var r;
      const { unitId: t, subUnitId: s } = e, o = this._ensureCellInfoMap(t, s);
      e.rule.ranges.forEach((i) => {
        X.foreach(i, (a, u) => {
          o.delete(`${a}-${u}`);
        });
      }), e.type === "set" && ((r = e.oldRule) == null || r.ranges.forEach((i) => {
        X.foreach(i, (a, u) => {
          this._cellInfoCache.delete(`${a}-${u}`);
        });
      }));
    });
  }
  _initUpdateCellRuleCache() {
    this._ruleModel.ruleChange$.subscribe((e) => {
      const { type: t } = e;
      t === "add" ? this._addCellRuleCache(e) : t === "delete" ? this._deleteCellRuleCache(e) : (this._deleteCellRuleCache({ ...e, rule: e.oldRule }), this._addCellRuleCache(e));
    });
  }
  _ensureRuleMap(e, t) {
    let s = this._cellRuleCache.get(e);
    s || (s = /* @__PURE__ */ new Map(), this._cellRuleCache.set(e, s));
    let o = s.get(t);
    return o || (o = /* @__PURE__ */ new Map(), s.set(t, o)), o;
  }
  _ensureCellInfoMap(e, t) {
    let s = this._cellInfoCache.get(e);
    s || (s = /* @__PURE__ */ new Map(), this._cellInfoCache.set(e, s));
    let o = s.get(t);
    return o || (o = /* @__PURE__ */ new Map(), s.set(t, o)), o;
  }
  _ensureRowColInfoMap(e, t, s) {
    let o = s === "row" ? this._rowInfoCache.get(e) : this._colInfoCache.get(e);
    o || (o = /* @__PURE__ */ new Map(), s === "row" ? this._rowInfoCache.set(e, o) : this._colInfoCache.set(e, o));
    let r = o.get(t);
    return r || (r = /* @__PURE__ */ new Map(), o.set(t, r)), r;
  }
  _addCellRuleCache(e) {
    const { subUnitId: t, unitId: s, rule: o } = e, r = this._ensureRuleMap(s, t);
    o.ranges.forEach((i) => {
      const { startRow: a, endRow: u, startColumn: l, endColumn: c } = i;
      for (let d = a; d <= u; d++)
        for (let h = l; h <= c; h++)
          r.set(`${d}-${h}`, o.id);
    }), this._permissionIdCache.set(o.permissionId, o.id);
  }
  _deleteCellRuleCache(e) {
    const { subUnitId: t, unitId: s, rule: o } = e, r = this._ensureRuleMap(s, t), i = this._ensureCellInfoMap(s, t);
    o.ranges.forEach((a) => {
      const { startRow: u, endRow: l, startColumn: c, endColumn: d } = a;
      for (let h = u; h <= l; h++)
        for (let g = c; g <= d; g++)
          r.delete(`${h}-${g}`), i.delete(`${h}-${g}`);
    }), this._permissionIdCache.delete(o.permissionId);
  }
  _getSelectionActions(e, t, s) {
    var l, c, d, h, g, m, f, C, p, w, S, I;
    const o = (d = (c = this._permissionService.getPermissionPoint((l = new Ve(e, t, s.permissionId)) == null ? void 0 : l.id)) == null ? void 0 : c.value) != null ? d : !1, r = (m = (g = this._permissionService.getPermissionPoint((h = new Bs(e, t, s.permissionId)) == null ? void 0 : h.id)) == null ? void 0 : g.value) != null ? m : !1, i = (p = (C = this._permissionService.getPermissionPoint((f = new hi(e, t, s.permissionId)) == null ? void 0 : f.id)) == null ? void 0 : C.value) != null ? p : !1, a = (I = (S = this._permissionService.getPermissionPoint((w = new di(e, t, s.permissionId)) == null ? void 0 : w.id)) == null ? void 0 : S.value) != null ? I : !1;
    return {
      [_.Edit]: o,
      [_.View]: r,
      [_.ManageCollaborator]: i,
      [_.Delete]: a
    };
  }
  reBuildCache(e, t) {
    const s = this._ensureRuleMap(e, t), o = this._ensureCellInfoMap(e, t);
    s.clear(), o.clear();
    const r = this._ensureRowColInfoMap(e, t, "row"), i = this._ensureRowColInfoMap(e, t, "col");
    r.clear(), i.clear(), this._ruleModel.getSubunitRuleList(e, t).forEach((a) => {
      const u = this._getSelectionActions(e, t, a), l = {
        ...u,
        ruleId: a.id,
        ranges: a.ranges
      };
      a.ranges.forEach((c) => {
        const { startRow: d, endRow: h, startColumn: g, endColumn: m } = c;
        for (let f = d; f <= h; f++) {
          const C = r.get(`${f}`);
          C ? C.set(a.id, u) : r.set(`${f}`, /* @__PURE__ */ new Map([[a.id, u]]));
          for (let p = g; p <= m; p++) {
            s.set(`${f}-${p}`, a.id), o.set(`${f}-${p}`, l);
            const w = i.get(`${p}`);
            w ? w.set(a.id, u) : i.set(`${p}`, /* @__PURE__ */ new Map([[a.id, u]]));
          }
        }
      }), this._permissionIdCache.set(a.permissionId, a.id);
    });
  }
  getRowPermissionInfo(e, t, s, o) {
    var a;
    const r = (a = this._rowInfoCache.get(e)) == null ? void 0 : a.get(t);
    if (!r)
      return !0;
    const i = r.get(`${s}`);
    return i ? o.every((u) => {
      for (const l of i.values())
        if (l[u] === !1)
          return !1;
      return !0;
    }) : !0;
  }
  getColPermissionInfo(e, t, s, o) {
    var a;
    const r = (a = this._colInfoCache.get(e)) == null ? void 0 : a.get(t);
    if (!r)
      return !0;
    const i = r.get(`${s}`);
    return i ? o.every((u) => {
      for (const l of i.values())
        if (l[u] === !1)
          return !1;
      return !0;
    }) : !0;
  }
  _initUpdateRowColInfoCache() {
    this._permissionService.permissionPointUpdate$.pipe(
      oo((e) => e.type === x.SelectRange),
      Es((e) => e)
    ).subscribe({
      next: (e) => {
        const { subUnitId: t, unitId: s, permissionId: o } = e, r = this._permissionIdCache.get(o);
        if (!r)
          return;
        const i = this._ruleModel.getRule(s, t, r);
        if (!i)
          return;
        const a = this._ensureRowColInfoMap(s, t, "row"), u = this._ensureRowColInfoMap(s, t, "col"), l = this._getSelectionActions(s, t, i);
        i.ranges.forEach((c) => {
          const { startRow: d, endRow: h, startColumn: g, endColumn: m } = c;
          for (let f = d; f <= h; f++) {
            const C = a.get(`${f}`);
            C ? C.set(r, l) : a.set(`${f}`, /* @__PURE__ */ new Map([[r, l]]));
            for (let p = g; p <= m; p++) {
              const w = u.get(`${p}`);
              w ? w.set(r, l) : u.set(`${p}`, /* @__PURE__ */ new Map([[r, l]]));
            }
          }
        });
      }
    }), this._ruleModel.ruleChange$.subscribe((e) => {
      if (e.type === "delete") {
        const { unitId: t, subUnitId: s, rule: o } = e, r = this._ensureRowColInfoMap(t, s, "row"), i = this._ensureRowColInfoMap(t, s, "col");
        o.ranges.forEach((a) => {
          const { startRow: u, endRow: l, startColumn: c, endColumn: d } = a;
          for (let h = u; h <= l; h++) {
            const g = r.get(`${h}`);
            g == null || g.delete(o.id);
            for (let m = c; m <= d; m++) {
              const f = i.get(`${m}`);
              f == null || f.delete(o.id);
            }
          }
        });
      }
    });
  }
  getCellInfo(e, t, s, o) {
    var l, c;
    const r = this._ensureCellInfoMap(e, t), i = r.get(`${s}-${o}`);
    if (i)
      return i;
    const a = (c = (l = this._cellRuleCache.get(e)) == null ? void 0 : l.get(t)) == null ? void 0 : c.get(`${s}-${o}`);
    if (!a)
      return;
    const u = this._ruleModel.getRule(e, t, a);
    if (u) {
      const h = {
        ...this._getSelectionActions(e, t, u),
        ruleId: a,
        ranges: u.ranges
      };
      return r.set(`${s}-${o}`, h), h;
    }
  }
  deleteUnit(e) {
    this._cellRuleCache.delete(e), this._cellInfoCache.delete(e), this._rowInfoCache.delete(e), this._colInfoCache.delete(e);
    const t = this._univerInstanceService.getUnit(e);
    t == null || t.getSheets().forEach((s) => {
      const o = s.getSheetId();
      this._ruleModel.getSubunitRuleList(e, o).forEach((r) => {
        this._permissionIdCache.delete(r.permissionId);
      });
    });
  }
};
Wt = Gd([
  _s(0, $(me)),
  _s(1, $(Ze)),
  _s(2, $(M))
], Wt);
const fi = "ONLY_REGISTER_FORMULA_RELATED_MUTATIONS_KEY";
var Kd = Object.getOwnPropertyDescriptor, Jd = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? Kd(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, ys = (n, e) => (t, s) => e(t, s, n);
let Qn = class extends ue {
  // eslint-disable-next-line max-lines-per-function
  constructor(n, e, t) {
    var o;
    super(), this._commandService = n, this._configService = e, this._dataSyncPrimaryController = t, [
      ee,
      Ue,
      ke,
      ln,
      wt,
      Je,
      qe,
      Me,
      Te,
      Lt,
      se,
      mi,
      ne,
      ii,
      jn,
      so,
      On,
      wd,
      Tt,
      // formula SUBTOTAL
      Ut,
      Id,
      vd,
      Yr
    ].forEach((r) => {
      var i;
      this._commandService.registerCommand(r), (i = this._dataSyncPrimaryController) == null || i.registerSyncingMutations(r);
    }), ((o = this._configService.getConfig(fi)) != null ? o : !1) || [
      ac,
      Ls,
      Ys,
      Hs,
      gc,
      It,
      vt,
      Fn,
      Gn,
      ll,
      ul,
      cl,
      dl,
      $r,
      Xe,
      Pt,
      rn,
      rl,
      ol,
      al,
      il,
      Ar,
      Ye,
      Sc,
      un,
      yt,
      an,
      Wr,
      gs,
      Vr,
      hs,
      Zs,
      ks,
      Ic,
      Kc,
      zc,
      Gc,
      Nc,
      Pc,
      In,
      Uc,
      Tc,
      Us,
      sn,
      on,
      Bn,
      Oc,
      zt,
      xc,
      st,
      $c,
      qc,
      Sn,
      Kn,
      Ts,
      Lc,
      Kt,
      ei,
      oi,
      dn,
      hn,
      Ce,
      Qc,
      Un,
      jc,
      Xc,
      Yc,
      Jc,
      ai,
      ui,
      pn,
      sd,
      St,
      eo,
      ci,
      Tn,
      er,
      nt,
      no,
      Fe,
      mt,
      // SetWorksheetColIsAutoWidthCommand,
      md,
      Yt,
      td,
      Jt,
      qu,
      ie,
      yd,
      pc,
      Qr,
      ni,
      gi,
      Cd,
      Xt,
      Wc,
      Gt,
      // permissions range protection
      dd,
      Mt,
      bt,
      xt,
      to,
      $u,
      Vc,
      fc,
      oc,
      Rc,
      hd,
      Be,
      ot,
      fe,
      Rd,
      qt,
      nd,
      fd,
      // range theme
      nn,
      tn,
      Xs,
      cn,
      pd,
      wc,
      rc,
      Cc,
      Sd,
      _d,
      Md
    ].forEach((r) => this.disposeWithMe(this._commandService.registerCommand(r))), this._configService.setConfig(bd, Ed);
  }
};
Qn = Jd([
  ys(0, E),
  ys(1, Cn),
  ys(2, Bi(ha))
], Qn);
var qd = Object.getOwnPropertyDescriptor, Yd = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? qd(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, Uo = (n, e) => (t, s) => e(t, s, n);
let es = class extends ue {
  constructor(n, e) {
    super(), this._univerInstanceService = n, this._commandService = e, this._initialize();
  }
  _initialize() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((n) => {
        if (n.id !== aa.id)
          return;
        const e = n.params, { unitData: t } = e, s = Object.keys(t), o = [];
        for (let i = 0; i < s.length; i++) {
          const a = s[i], u = t[a];
          if (u == null)
            continue;
          const l = Object.keys(u);
          for (let c = 0; c < l.length; c++) {
            const d = l[c], h = u[d];
            if (h == null)
              continue;
            const g = this._getMergedCellData(a, d, h), m = {
              subUnitId: d,
              unitId: a,
              cellValue: g
            };
            o.push({
              id: ee.id,
              params: m
            });
          }
        }
        return o.every(
          (i) => this._commandService.executeCommand(i.id, i.params, {
            onlyLocal: !0,
            fromFormula: !0
          })
        );
      })
    );
  }
  /**
   * Priority that mainly deals with number format in unitData
   * @param unitId
   * @param sheetId
   * @param cellData
   * @returns
   */
  _getMergedCellData(n, e, t) {
    const s = this._univerInstanceService.getUniverSheetInstance(n), o = s == null ? void 0 : s.getStyles(), r = s == null ? void 0 : s.getSheetBySheetId(e), i = r == null ? void 0 : r.getCellMatrix(), a = new Y(t);
    return a.forValue((u, l, c) => {
      const d = i == null ? void 0 : i.getValue(u, l), h = ua(d, c, o);
      a.setValue(u, l, h);
    }), a.getMatrix();
  }
};
es = Yd([
  Uo(0, $(M)),
  Uo(1, E)
], es);
var Xd = Object.getOwnPropertyDescriptor, Zd = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? Xd(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, Qd = (n, e) => (t, s) => e(t, s, n);
let ts = class extends ue {
  constructor(n) {
    super(), this._sheetInterceptorService = n, this._initialize();
  }
  _initialize() {
    this._initInterceptorCellContent();
  }
  _initInterceptorCellContent() {
    this.disposeWithMe(
      this._sheetInterceptorService.intercept(ht.CELL_CONTENT, {
        priority: 11,
        effect: he.Value | he.Style,
        handler: (n, e, t) => {
          var o;
          if (!n)
            return t(n);
          const s = e.workbook.getStyles().getStyleByCell(n);
          return ji((o = s == null ? void 0 : s.n) == null ? void 0 : o.pattern) && (n == null ? void 0 : n.t) === re.NUMBER && n.v !== void 0 && n.v !== null && Ds(n.v) && ((!n || n === e.rawData) && (n = { ...e.rawData }), n.v = la(Number(n.v))), t(n);
        }
      })
    );
  }
};
ts = Zd([
  Qd(0, $(G))
], ts);
var eh = Object.getOwnPropertyDescriptor, th = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? eh(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, bn = (n, e) => (t, s) => e(t, s, n);
let ns = class extends ue {
  constructor(n, e, t, s) {
    super(), this._permissionService = n, this._worksheetProtectionRuleModel = e, this._sheetInterceptorService = t, this._rangeProtectionCache = s, this._initViewModelByRangeInterceptor(), this._initViewModelBySheetInterceptor();
  }
  _initViewModelByRangeInterceptor() {
    this.disposeWithMe(this._sheetInterceptorService.intercept(ht.CELL_CONTENT, {
      // permissions are placed at a high level to prioritize whether to filter subsequent renderings.
      priority: 999,
      effect: he.Value | he.Style,
      handler: (n, e, t) => {
        const { unitId: s, subUnitId: o, row: r, col: i } = e, a = this._rangeProtectionCache.getCellInfo(s, o, r, i);
        if (a) {
          const u = a[_.View] === !1, l = !n || n === e.rawData ? { ...e.rawData } : n;
          return l.selectionProtection = [a], u ? (delete l.s, delete l.v, delete l.p, l) : t(l);
        }
        return t(n);
      }
    }));
  }
  _initViewModelBySheetInterceptor() {
    this.disposeWithMe(this._sheetInterceptorService.intercept(ht.CELL_CONTENT, {
      // permissions are placed at a high level to prioritize whether to filter subsequent renderings.
      priority: 999,
      effect: he.Value | he.Style,
      handler: (n, e, t) => {
        var i, a, u, l, c;
        const { unitId: s, subUnitId: o } = e, r = this._worksheetProtectionRuleModel.getRule(s, o);
        if (r != null && r.permissionId) {
          const d = [{
            [_.View]: (a = (i = this._permissionService.getPermissionPoint(new ds(s, o).id)) == null ? void 0 : i.value) != null ? a : !1,
            [_.Edit]: (l = (u = this._permissionService.getPermissionPoint(new Le(s, o).id)) == null ? void 0 : u.value) != null ? l : !1
          }], h = !((c = d[0]) != null && c[_.View]), g = !n || n === e.rawData ? { ...n } : n;
          return g.hasWorksheetRule = !0, g.selectionProtection = d, h ? (delete g.s, delete g.v, delete g.p, g) : t(g);
        }
        return t(n);
      }
    }));
  }
};
ns = th([
  bn(0, Ze),
  bn(1, $(lt)),
  bn(2, $(G)),
  bn(3, $(Wt))
], ns);
const To = $s("univer.exclusive-range-service");
class nh extends ue {
  constructor() {
    super(...arguments);
    /**
     * Exclusive range data structure is as follows: unitId -> sheetId -> feature -> range
     */
    R(this, "_exclusiveRanges", /* @__PURE__ */ new Map());
    R(this, "_exclusiveRangesChange$", new De());
    R(this, "exclusiveRangesChange$", this._exclusiveRangesChange$.asObservable());
  }
  _ensureUnitMap(t) {
    return this._exclusiveRanges.has(t) || this._exclusiveRanges.set(t, /* @__PURE__ */ new Map()), this._exclusiveRanges.get(t);
  }
  _ensureSubunitMap(t, s) {
    const o = this._ensureUnitMap(t);
    return o.has(s) || o.set(s, /* @__PURE__ */ new Map()), o.get(s);
  }
  _ensureFeature(t, s, o) {
    const r = this._ensureSubunitMap(t, s);
    return r.has(o) || r.set(o, []), r.get(o);
  }
  addExclusiveRange(t, s, o, r) {
    const i = this._ensureFeature(t, s, o);
    i.push(...r), this._exclusiveRangesChange$.next({ unitId: t, subUnitId: s, ranges: i.map((a) => a.range) });
  }
  getExclusiveRanges(t, s, o) {
    var r, i;
    return (i = (r = this._exclusiveRanges.get(t)) == null ? void 0 : r.get(s)) == null ? void 0 : i.get(o);
  }
  clearExclusiveRanges(t, s, o) {
    const r = this.getExclusiveRanges(t, s, o);
    this._exclusiveRangesChange$.next({ unitId: t, subUnitId: s, ranges: (r == null ? void 0 : r.map((i) => i.range)) || [] }), this._ensureFeature(t, s, o), this._exclusiveRanges.get(t).get(s).set(o, []);
  }
  clearExclusiveRangesByGroupId(t, s, o, r) {
    const i = this.getExclusiveRanges(t, s, o);
    this._exclusiveRangesChange$.next({ unitId: t, subUnitId: s, ranges: (i == null ? void 0 : i.map((u) => u.range)) || [] });
    const a = this.getExclusiveRanges(t, s, o);
    if (a) {
      const u = a.filter((l) => l.groupId !== r);
      this._exclusiveRanges.get(t).get(s).set(o, u);
    }
  }
  getInterestGroupId(t) {
    const s = [];
    return t.forEach((o) => {
      var l;
      const r = o.range, { unitId: i, sheetId: a } = r;
      if (!i || !a) return;
      const u = (l = this._exclusiveRanges.get(i)) == null ? void 0 : l.get(a);
      if (u)
        for (const c of u.keys()) {
          const d = u.get(c);
          if (d) {
            for (const h of d)
              if (O.intersects(r, h.range)) {
                s.push(c);
                break;
              }
          }
        }
    }), s;
  }
}
var sh = Object.getOwnPropertyDescriptor, oh = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? sh(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, bs = (n, e) => (t, s) => e(t, s, n);
let Ns = class extends ue {
  constructor(n, e, t) {
    super(), this._resourceManagerService = n, this._univerInstanceService = e, this._logService = t;
  }
  getValue(n, e, t, s) {
    const o = this._univerInstanceService.getUniverSheetInstance(n);
    if (!o)
      return;
    const r = o == null ? void 0 : o.getSheetBySheetId(e);
    if (!r)
      return;
    const i = o.getStyles(), a = r.getCellRaw(t, s);
    if (a != null && a.s) {
      const u = i.get(a.s);
      if (u != null && u.n)
        return u.n;
    }
    return null;
  }
  deleteValues(n, e, t) {
    const s = this._univerInstanceService.getUniverSheetInstance(n);
    if (!s)
      return;
    const o = s == null ? void 0 : s.getSheetBySheetId(e);
    if (!o)
      return;
    const r = s.getStyles();
    t.forEach((i) => {
      X.foreach(i, (a, u) => {
        const l = o.getCellRaw(a, u);
        if (!l)
          return;
        const c = l == null ? void 0 : l.s, h = { ...c && r.get(c) || {} };
        delete h.n;
        const g = r.setValue(h);
        l.s = g;
      });
    });
  }
  setValues(n, e, t) {
    const s = this._univerInstanceService.getUniverSheetInstance(n);
    if (!s)
      return;
    const o = s == null ? void 0 : s.getSheetBySheetId(e);
    if (!o)
      return;
    const r = s.getStyles(), i = o.getCellMatrix();
    t.forEach((a) => {
      a.ranges.forEach((u) => {
        X.foreach(u, (l, c) => {
          const d = o.getCellRaw(l, c);
          if (d) {
            const g = { ...r.getStyleByCell(d) || {}, n: { pattern: a.pattern } }, m = r.setValue(g);
            d.s = m;
          } else {
            const h = { n: { pattern: a.pattern } }, g = r.setValue(h);
            g && i.setValue(l, c, { s: g });
          }
        });
      });
    });
  }
};
Ns = oh([
  bs(0, Rn),
  bs(1, M),
  bs(2, zo)
], Ns);
var rh = Object.getOwnPropertyDescriptor, ih = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? rh(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, dt = (n, e) => (t, s) => e(t, s, n);
const Po = [Ue.id, ke.id, Me.id, Te.id], No = [Je.id, qe.id];
let ss = class extends ue {
  constructor(e, t, s, o, r, i, a, u) {
    super();
    R(this, "disposableCollection", new Et());
    this._selectionProtectionRuleModel = e, this._univerInstanceService = t, this._commandService = s, this._refRangeService = o, this._selectionProtectionRenderModel = r, this._rangeProtectionCache = i, this._sheetInterceptorService = a, this._rangeProtectionRuleModel = u, this._onRefRangeChange(), this._correctPermissionRange(), this._initReBuildCache(), this._initRemoveSheet();
  }
  _onRefRangeChange() {
    const e = (s, o) => {
      const r = this._univerInstanceService.getCurrentUnitForType(B.UNIVER_SHEET);
      if (!r || !(r == null ? void 0 : r.getSheetBySheetId(o)))
        return;
      this.disposableCollection.dispose();
      const a = (l) => this.refRangeHandle(l, s, o);
      this._selectionProtectionRuleModel.getSubunitRuleList(s, o).reduce((l, c) => [...l, ...c.ranges], []).forEach((l) => {
        this.disposableCollection.add(this._refRangeService.registerRefRange(l, a, s, o));
      });
    };
    this.disposeWithMe(
      this._commandService.onCommandExecuted((s) => {
        if (s.id === ui.id) {
          const o = s.params, r = o.subUnitId, i = o.unitId;
          if (!r || !i)
            return;
          e(i, r);
        }
        if (s.id === fe.id || s.id === Be.id) {
          const o = s.params, r = o.subUnitId, i = o.unitId;
          if (!r || !i)
            return;
          e(i, r);
        }
      })
    );
    const t = this._univerInstanceService.getCurrentUnitForType(B.UNIVER_SHEET);
    if (t) {
      const s = t.getActiveSheet();
      if (!s) return;
      e(t.getUnitId(), s.getSheetId());
    }
  }
  refRangeHandle(e, t, s) {
    switch (e.id) {
      case an.id:
        return this._getRefRangeMutationsByMoveRows(e.params, t, s);
      case un.id:
        return this._getRefRangeMutationsByMoveCols(e.params, t, s);
      case Ye.id:
        return this._getRefRangeMutationsByInsertRows(e.params, t, s);
      case Xe.id:
        return this._getRefRangeMutationsByInsertCols(e.params, t, s);
      case gs.id:
        return this._getRefRangeMutationsByDeleteCols(e.params, t, s);
      case hs.id:
        return this._getRefRangeMutationsByDeleteRows(e.params, t, s);
    }
    return { redos: [], undos: [] };
  }
  _getRefRangeMutationsByDeleteCols(e, t, s) {
    const o = this._selectionProtectionRuleModel.getSubunitRuleList(t, s).filter((i) => i.ranges.some((a) => O.intersects(a, e.range))), r = e.range;
    if (o.length) {
      const i = [], a = [];
      return o.forEach((u) => {
        const l = A.deepClone(u), c = l.ranges.reduce((d, h) => {
          if (O.intersects(h, r)) {
            const g = A.deepClone(h), { startColumn: m, endColumn: f } = r;
            if (m <= g.startColumn && f >= g.endColumn)
              return d;
            m >= g.startColumn && f <= g.endColumn ? g.endColumn -= f - m + 1 : m < g.startColumn ? (g.startColumn = m, g.endColumn -= f - m + 1) : f > g.endColumn && (g.endColumn = m - 1), this._checkIsRightRange(g) && d.push(g);
          }
          return d;
        }, []);
        l.ranges = c, l.ranges.length ? (i.push({ id: fe.id, params: { unitId: t, subUnitId: s, rule: l, ruleId: u.id } }), a.push({ id: fe.id, params: { unitId: t, subUnitId: s, rule: u, ruleId: u.id } })) : (i.push({ id: ot.id, params: { unitId: t, subUnitId: s, ruleIds: [u.id] } }), a.push({ id: Be.id, params: { unitId: t, subUnitId: s, name: "", rules: [u] } }));
      }), { redos: i, undos: a };
    }
    return { undos: [], redos: [] };
  }
  _getRefRangeMutationsByDeleteRows(e, t, s) {
    const o = this._selectionProtectionRuleModel.getSubunitRuleList(t, s).filter((i) => i.ranges.some((a) => O.intersects(a, e.range))), r = e.range;
    if (o.length) {
      const i = [], a = [];
      return o.forEach((u) => {
        const l = A.deepClone(u), c = l.ranges.reduce((d, h) => {
          if (O.intersects(h, r)) {
            const g = A.deepClone(h), { startRow: m, endRow: f } = r;
            if (m <= g.startRow && f >= g.endRow)
              return d;
            m >= g.startRow && f <= g.endRow ? g.endRow -= f - m + 1 : m < g.startRow ? (g.startRow = m, g.endRow -= f - m + 1) : f > g.endRow && (g.endRow = m - 1), this._checkIsRightRange(g) && d.push(g);
          }
          return d;
        }, []);
        l.ranges = c, i.push({ id: fe.id, params: { unitId: t, subUnitId: s, rule: l, ruleId: u.id } }), a.push({ id: fe.id, params: { unitId: t, subUnitId: s, rule: u, ruleId: u.id } });
      }), { redos: i, undos: a };
    }
    return { undos: [], redos: [] };
  }
  _getRefRangeMutationsByInsertCols(e, t, s) {
    const o = e.range.startColumn, r = e.range.endColumn - e.range.startColumn + 1, i = this._selectionProtectionRuleModel.getSubunitRuleList(t, s).filter((a) => a.ranges.some((u) => o > u.startColumn && o <= u.endColumn));
    if (i.length) {
      const a = [], u = [];
      return i.forEach((l) => {
        const c = A.deepClone(l);
        let d = !1;
        c.ranges.forEach((h) => {
          o > h.startColumn && o <= h.endColumn && (h.endColumn += r, d = !0);
        }), d && (a.push({ id: fe.id, params: { unitId: t, subUnitId: s, rule: c, ruleId: l.id } }), u.push({ id: fe.id, params: { unitId: t, subUnitId: s, rule: l, ruleId: l.id } }));
      }), { redos: a, undos: u };
    }
    return { undos: [], redos: [] };
  }
  _getRefRangeMutationsByInsertRows(e, t, s) {
    const o = e.range.startRow, r = e.range.endRow - e.range.startRow + 1, i = this._selectionProtectionRuleModel.getSubunitRuleList(t, s).filter((a) => a.ranges.some((u) => o > u.startRow && o <= u.endRow));
    if (i.length) {
      const a = [], u = [];
      return i.forEach((l) => {
        const c = A.deepClone(l);
        let d = !1;
        c.ranges.forEach((h) => {
          o > h.startRow && o <= h.endRow && (h.endRow += r, d = !0);
        }), d && (a.push({ id: fe.id, params: { unitId: t, subUnitId: s, rule: c, ruleId: l.id } }), u.push({ id: fe.id, params: { unitId: t, subUnitId: s, rule: l, ruleId: l.id } }));
      }), { redos: a, undos: u };
    }
    return { undos: [], redos: [] };
  }
  _getRefRangeMutationsByMoveRows(e, t, s) {
    const o = e.toRange, r = o.startRow, i = o.endRow - o.startRow + 1, a = this._selectionProtectionRuleModel.getSubunitRuleList(t, s).filter((u) => u.ranges.some((l) => r > l.startRow && r <= l.endRow));
    if (a.length) {
      const u = [], l = [];
      return a.forEach((c) => {
        const d = A.deepClone(c), g = e.fromRange.startRow;
        let m = !1;
        d.ranges.forEach((f) => {
          r > f.startRow && r <= f.endRow && (g < f.startRow && (f.startRow = f.startRow - i, f.endRow = f.endRow - i), f.endRow += i, m = !0);
        }), m && (u.push({ id: fe.id, params: { unitId: t, subUnitId: s, rule: d, ruleId: c.id } }), l.push({ id: fe.id, params: { unitId: t, subUnitId: s, rule: c, ruleId: c.id } }));
      }), { redos: u, undos: l };
    }
    return { undos: [], redos: [] };
  }
  _getRefRangeMutationsByMoveCols(e, t, s) {
    const o = e.toRange, r = o.startColumn, i = o.endColumn - o.startColumn + 1, a = this._selectionProtectionRuleModel.getSubunitRuleList(t, s).filter((u) => u.ranges.some((l) => r > l.startColumn && r <= l.endColumn));
    if (a.length) {
      const u = [], l = [];
      return a.forEach((c) => {
        const d = A.deepClone(c), g = e.fromRange.startColumn;
        let m = !1;
        d.ranges.forEach((f) => {
          r > f.startColumn && r <= f.endColumn && (g < f.startColumn && (f.startColumn = f.startColumn - i, f.endColumn = f.endColumn - i), f.endColumn += i, m = !0);
        }), m && (u.push({ id: fe.id, params: { unitId: t, subUnitId: s, rule: d, ruleId: c.id } }), l.push({ id: fe.id, params: { unitId: t, subUnitId: s, rule: c, ruleId: c.id } }));
      }), { redos: u, undos: l };
    }
    return { undos: [], redos: [] };
  }
  _correctPermissionRange() {
    this.disposeWithMe(this._commandService.onCommandExecuted((e) => {
      if (No.includes(e.id)) {
        if (!e.params) return;
        const t = this._univerInstanceService.getCurrentUnitForType(B.UNIVER_SHEET);
        if (!t) return;
        const s = t.getSheetBySheetId(e.params.subUnitId);
        if (!s) return;
        const { sourceRange: o, targetRange: r } = e.params, i = o.startColumn === r.startColumn && o.endColumn === r.endColumn, a = i ? o.endRow - o.startRow + 1 : o.endColumn - o.startColumn + 1, u = i ? o.startRow : o.startColumn, l = i ? r.startRow : r.startColumn;
        this._selectionProtectionRuleModel.getSubunitRuleList(t.getUnitId(), s.getSheetId()).forEach((f) => {
          f.ranges.forEach((p) => {
            let { startRow: w, endRow: S, startColumn: I, endColumn: y } = p;
            O.intersects(p, o) || (i ? u < w && l > S ? (w -= a, S -= a) : u > S && l <= w && (w += a, S += a) : u < I && l > y ? (I -= a, y -= a) : u > y && l <= I && (I += a, y += a)), this._checkIsRightRange({ startRow: w, endRow: S, startColumn: I, endColumn: y }) && (p.startColumn = I, p.endColumn = y, p.startRow = w, p.endRow = S);
          });
        }), this.disposableCollection.dispose();
        const { unitId: d, subUnitId: h } = e.params, g = (f) => this.refRangeHandle(f, d, h);
        this._selectionProtectionRuleModel.getSubunitRuleList(d, h).reduce((f, C) => [...f, ...C.ranges], []).forEach((f) => {
          this.disposableCollection.add(this._refRangeService.registerRefRange(f, g, d, h));
        }), this._selectionProtectionRenderModel.clear();
      }
      if (Po.includes(e.id)) {
        const t = this._univerInstanceService.getUniverSheetInstance(e.params.unitId);
        if (!t) return;
        const s = t.getSheetBySheetId(e.params.subUnitId);
        if (!s) return;
        const o = e.params;
        if (!o) return;
        const { range: r } = o, i = e.id.includes("row"), a = e.id.includes("insert"), u = i ? r.startRow : r.startColumn, l = i ? r.endRow : r.endColumn, c = l - u + 1;
        this._selectionProtectionRuleModel.getSubunitRuleList(t.getUnitId(), s.getSheetId()).forEach((C) => {
          C.ranges.forEach((w) => {
            let { startRow: S, endRow: I, startColumn: y, endColumn: b } = w;
            a ? i ? u <= S && (S += c, I += c) : u <= y && (y += c, b += c) : i ? l < S && (S -= c, I -= c) : l < y && (y -= c, b -= c), this._checkIsRightRange({ startRow: S, endRow: I, startColumn: y, endColumn: b }) && (w.startColumn = y, w.endColumn = b, w.startRow = S, w.endRow = I);
          });
        }), this.disposableCollection.dispose();
        const { unitId: h, subUnitId: g } = e.params, m = (C) => this.refRangeHandle(C, h, g);
        this._selectionProtectionRuleModel.getSubunitRuleList(h, g).reduce((C, p) => [...C, ...p.ranges], []).forEach((C) => {
          this.disposableCollection.add(this._refRangeService.registerRefRange(C, m, h, g));
        }), this._selectionProtectionRenderModel.clear();
      }
    }));
  }
  _checkIsRightRange(e) {
    return e.startRow <= e.endRow && e.startColumn <= e.endColumn;
  }
  _initReBuildCache() {
    this.disposeWithMe(this._commandService.onCommandExecuted((e) => {
      if (Po.includes(e.id) || No.includes(e.id)) {
        const { unitId: t, subUnitId: s } = e.params;
        this._rangeProtectionCache.reBuildCache(t, s);
      }
    }));
  }
  _initRemoveSheet() {
    this._sheetInterceptorService.interceptCommand(
      {
        getMutations: (e) => {
          const t = [], s = [], o = [], r = [];
          if (e.id === Zs.id) {
            const i = e.params, a = [], u = [];
            this._rangeProtectionRuleModel.getSubunitRuleList(i.unitId, i.subUnitId).forEach((l) => {
              a.push(l.id), u.push(l);
            }), a.length && u.length && (o.push({ id: ot.id, params: { unitId: i.unitId, subUnitId: i.subUnitId, ruleIds: a } }), t.push({ id: Be.id, params: { unitId: i.unitId, subUnitId: i.subUnitId, name: "", rules: u } }));
          }
          return {
            redos: s,
            undos: t,
            preRedos: o,
            preUndos: r
          };
        }
      }
    );
  }
};
ss = ih([
  dt(0, $(me)),
  dt(1, $(M)),
  dt(2, E),
  dt(3, $(At)),
  dt(4, $(fn)),
  dt(5, $(Wt)),
  dt(6, $(G)),
  dt(7, $(me))
], ss);
var ah = Object.getOwnPropertyDescriptor, uh = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? ah(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, Bt = (n, e) => (t, s) => e(t, s, n);
const lh = "SHEET_RANGE_PROTECTION_PLUGIN";
let os = class extends ue {
  constructor(n, e, t, s, o) {
    super(), this._selectionProtectionRuleModel = n, this._permissionService = e, this._resourceManagerService = t, this._selectionProtectionCache = s, this._univerInstanceService = o, this._initSnapshot(), this._initRuleChange();
  }
  _initRuleChange() {
    this.disposeWithMe(
      this._selectionProtectionRuleModel.ruleChange$.subscribe((n) => {
        switch (n.type) {
          case "add": {
            Ee().forEach((e) => {
              const t = new e(n.unitId, n.subUnitId, n.rule.permissionId);
              this._permissionService.addPermissionPoint(t);
            });
            break;
          }
          case "delete": {
            Ee().forEach((e) => {
              const t = new e(n.unitId, n.subUnitId, n.rule.permissionId);
              this._permissionService.deletePermissionPoint(t.id);
            });
            break;
          }
          case "set": {
            n.oldRule.permissionId !== n.rule.permissionId && Ee().forEach((e) => {
              const t = new e(n.unitId, n.subUnitId, n.oldRule.permissionId);
              this._permissionService.deletePermissionPoint(t.id);
              const s = new e(n.unitId, n.subUnitId, n.rule.permissionId);
              this._permissionService.addPermissionPoint(s);
            });
            break;
          }
        }
      })
    );
  }
  _initSnapshot() {
    const n = (t) => {
      const o = this._selectionProtectionRuleModel.toObject()[t];
      return o ? JSON.stringify(o) : "";
    }, e = (t) => {
      if (!t)
        return {};
      try {
        return JSON.parse(t);
      } catch {
        return {};
      }
    };
    this.disposeWithMe(
      this._resourceManagerService.registerPluginResource({
        toJson: n,
        parseJson: e,
        pluginName: lh,
        businesses: [Dn.UNIVER_SHEET],
        onLoad: (t, s) => {
          const o = this._selectionProtectionRuleModel.toObject();
          o[t] = s, this._selectionProtectionRuleModel.fromObject(o);
          const r = [];
          Object.keys(s).forEach((i) => {
            const a = s[i];
            this._selectionProtectionRuleModel.getSubunitRuleList(t, i).forEach((u) => {
              r.push({
                objectID: u.permissionId,
                unitID: t,
                objectType: x.SelectRange,
                actions: pt
              });
            }), a.forEach((u) => {
              Ee().forEach((l) => {
                const c = new l(t, i, u.permissionId);
                c.value = !1, this._permissionService.addPermissionPoint(c);
              });
            }), this._selectionProtectionCache.reBuildCache(t, i);
          });
        },
        onUnLoad: (t) => {
          this._selectionProtectionCache.deleteUnit(t);
        }
      })
    );
  }
};
os = uh([
  Bt(0, $(me)),
  Bt(1, $(Ze)),
  Bt(2, $(Rn)),
  Bt(3, $(Wt)),
  Bt(4, $(M))
], os);
var ch = Object.getOwnPropertyDescriptor, dh = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? ch(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, hh = (n, e) => (t, s) => e(t, s, n);
let Os = class extends ue {
  constructor(n) {
    super(), this._sheetRangeThemeModel = n;
  }
  /**
   * Register a custom range theme style.
   * @param {string} unitId Which unit to register the range theme style.
   * @param {RangeThemeStyle} rangeThemeStyle The range theme style to register.
   */
  registerRangeTheme(n, e) {
    this._sheetRangeThemeModel.registerRangeThemeStyle(n, e);
  }
  removeRangeThemeRule(n, e) {
    this._sheetRangeThemeModel.removeRangeThemeRule(n, e);
  }
  /**
   * Get custom register themes name list
   * @param {string} unitId Which unit to register the range theme style.
   * @returns {string[]} The list of custom register themes name.
   */
  getALLRegisterThemes(n) {
    return this._sheetRangeThemeModel.getALLRegisteredTheme(n);
  }
  /**
   * Register range theme style to the range.
   * @param {string} themeName The defined theme name.
   * @param {IRangeThemeRangeInfo} rangeInfo The range info to apply the theme style.
   */
  registerRangeThemeStyle(n, e) {
    this._sheetRangeThemeModel.registerRangeThemeRule(n, e);
  }
  /**
   * Get applied range theme style name.
   * @param {IRangeThemeRangeInfo} rangeInfo The range info to get the applied theme style.
   * @returns {string | undefined} The applied theme style name or not exist.
   */
  getAppliedRangeThemeStyle(n) {
    return this._sheetRangeThemeModel.getRegisteredRangeThemeStyle(n);
  }
  /**
   * Get registered build-in range theme style
   */
  getRegisteredRangeThemes() {
    return this._sheetRangeThemeModel.getRegisteredRangeThemes();
  }
};
Os = dh([
  hh(0, $(ve))
], Os);
var gh = Object.defineProperty, mh = Object.getOwnPropertyDescriptor, fh = (n, e, t) => e in n ? gh(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Rh = (n, e, t, s) => {
  for (var o = s > 1 ? void 0 : s ? mh(e, t) : e, r = n.length - 1, i; r >= 0; r--)
    (i = n[r]) && (o = i(o) || o);
  return o;
}, Oo = (n, e) => (t, s) => e(t, s, n), Ri = (n, e, t) => fh(n, typeof e != "symbol" ? e + "" : e, t);
const Ch = "SHEET_PLUGIN";
let rs = class extends Gi {
  constructor(n = yo, e, t) {
    super(), this._config = n, this._injector = e, this._configService = t;
    const { ...s } = Ki(
      {},
      yo,
      this._config
    );
    this._configService.setConfig(fs, s), this._initConfig(), this._initDependencies();
  }
  _initConfig() {
    var n, e, t;
    (n = this._config) != null && n.onlyRegisterFormulaRelatedMutations && this._configService.setConfig(fi, !0), (e = this._config) != null && e.isRowStylePrecedeColumnStyle && this._configService.setConfig(Ji, !0), (t = this._config) != null && t.autoHeightForMergedCells && this._configService.setConfig(qi, !0);
  }
  _initDependencies() {
    var e;
    const n = [
      // services
      [Ht],
      [Ln],
      [z],
      [At],
      [mn],
      [$t, { useClass: Ns }],
      [G],
      [Os],
      [rt],
      // controllers
      [Qn],
      [Vn],
      [ts],
      [Jn],
      [Zn],
      [qn],
      // permission
      [zn],
      [lt],
      [vn],
      [ns],
      [Xn],
      [Yn],
      // range theme
      [ve],
      // range protection
      [fn],
      [me],
      [Wt],
      [ss],
      [os],
      [To, {
        useClass: nh,
        deps: [z]
      }]
    ];
    (e = this._config) != null && e.notExecuteFormula || n.push([es]), Yi(this._injector, Xi(n, this._config.override)), Mn(this._injector, [
      [G],
      [os],
      [To],
      [Xn],
      [qn]
    ]);
  }
  onStarting() {
    Mn(this._injector, [
      [Qn],
      [Vn],
      [mn],
      [zn],
      [ns],
      [rt]
    ]);
  }
  onRendered() {
    Mn(this._injector, [
      [$t]
    ]);
  }
  onReady() {
    Mn(this._injector, [
      [es],
      [Jn],
      [Zn],
      [ve],
      [ts],
      [fn],
      [ss],
      [At],
      [Yn]
    ]);
  }
};
Ri(rs, "pluginName", Ch);
Ri(rs, "type", B.UNIVER_SHEET);
rs = Rh([
  zi(ca),
  Oo(1, $(is)),
  Oo(2, Cn)
], rs);
const fg = {
  /**
   * The permission point for adding or editing workbook comments
   */
  WorkbookCommentPermission: rr,
  /**
   * The permission point for copy in workbook
   */
  WorkbookCopyPermission: ir,
  /**
   * The permission point for creating protect in a workbook
   */
  WorkbookCreateProtectPermission: ar,
  /**
   * The permission point for creating new sheets in a workbook
   */
  WorkbookCreateSheetPermission: ur,
  /**
   * The permission point for deleting sheets in a workbook
   */
  WorkbookDeleteSheetPermission: lr,
  /**
   * The permission point for duplicating a sheet in a workbook
   */
  WorkbookDuplicatePermission: cr,
  /**
   * The permission point for editing workbook content
   */
  WorkbookEditablePermission: Pe,
  /**
   * The permission point for exporting workbook data
   */
  WorkbookExportPermission: dr,
  /**
   * The permission point for hiding sheets in a workbook
   */
  WorkbookHideSheetPermission: js,
  /**
   * The permission point for viewing and managing workbook history
   */
  WorkbookHistoryPermission: el,
  /**
   * The permission point for managing collaborators in a workbook
   */
  WorkbookManageCollaboratorPermission: zs,
  /**
   * The permission point for moving sheets within a workbook
   */
  WorkbookMoveSheetPermission: Gs,
  /**
   * The permission point for printing a workbook
   */
  WorkbookPrintPermission: hr,
  /**
   * The permission point for recovering a previous history state of a workbook
   */
  WorkbookRecoverHistoryPermission: gr,
  /**
   * The permission point for renaming sheets in a workbook
   */
  WorkbookRenameSheetPermission: Ks,
  /**
   * The permission point for sharing a workbook with others
   */
  WorkbookSharePermission: mr,
  /**
   * The permission point for viewing the history of a workbook
   */
  WorkbookViewHistoryPermission: Rr,
  /**
   * The permission point for viewing a workbook
   */
  WorkbookViewPermission: fr,
  /**
   * The permission point for copying contents from a worksheet
   */
  WorksheetCopyPermission: Cr,
  /**
   * The permission point for deleting columns in a worksheet
   */
  WorksheetDeleteColumnPermission: pr,
  /**
   * The permission point for deleting worksheet protection rules
   */
  WorksheetDeleteProtectionPermission: Sr,
  /**
   * The permission point for deleting rows in a worksheet
   */
  WorksheetDeleteRowPermission: wr,
  /**
   * The permission point for editing extra objects (e.g. shapes) in a worksheet
   */
  WorksheetEditExtraObjectPermission: Ir,
  /**
   * The permission point for editing the content of a worksheet
   */
  WorksheetEditPermission: Le,
  /**
   * The permission point for applying filters in a worksheet
   */
  WorksheetFilterPermission: vr,
  /**
   * The permission point for inserting columns into a worksheet
   */
  WorksheetInsertColumnPermission: Mr,
  /**
   * The permission point for inserting hyperlinks in a worksheet
   */
  WorksheetInsertHyperlinkPermission: _r,
  /**
   * The permission point for inserting rows into a worksheet
   */
  WorksheetInsertRowPermission: yr,
  /**
   * The permission point for managing collaborators of a worksheet
   */
  WorksheetManageCollaboratorPermission: br,
  /**
   * The permission point for creating or modifying pivot tables in a worksheet
   */
  WorksheetPivotTablePermission: Er,
  /**
   * The permission point for setting the style of cells in a worksheet
   */
  WorksheetSetCellStylePermission: kr,
  /**
   * The permission point for setting the value of cells in a worksheet
   */
  WorksheetSetCellValuePermission: An,
  /**
   * The permission point for setting the style of columns in a worksheet
   */
  WorksheetSetColumnStylePermission: Zt,
  /**
   * The permission point for setting the style of rows in a worksheet
   */
  WorksheetSetRowStylePermission: Qt,
  /**
   * The permission point for performing sort operations on a worksheet
   */
  WorksheetSortPermission: Ur,
  /**
   * The permission point for viewing the content of a worksheet
   */
  WorksheetViewPermission: ds,
  /**
   * The permission point for editing the range protection settings
   */
  RangeProtectionPermissionEditPoint: Ve,
  /**
   * The permission point for viewing the range protection settings
   */
  RangeProtectionPermissionViewPoint: Bs
}, Rg = (n, e, t, s) => {
  const o = n.get(Ze), r = n.get(me), i = o.getPermissionPoint(new Pe(e).id);
  if (!(i != null && i.value))
    return !1;
  const a = o.getPermissionPoint(new Le(e, t).id);
  if (!(a != null && a.value))
    return !1;
  const l = r.getSubunitRuleList(e, t).filter((c) => c.ranges.some((d) => s.some((h) => O.intersects(d, h))));
  return l.length ? l.every((c) => {
    const d = c.permissionId, h = o.getPermissionPoint(new Ve(e, t, d).id);
    return !!(h != null && h.value);
  }) : !0;
}, Ci = (n, e, t, s = 1, o = !0, r = !0) => {
  const i = X.transformRange(n, e), { startRow: a, endRow: u } = i;
  let l = t.startRow - s, c = e.getMergedCell(l, t.startColumn), d = !c || c.startRow === l && c.startColumn === t.startColumn;
  for (; !e.getRowVisible(l) || !d; )
    l--, c = e.getMergedCell(l, t.startColumn), d = !c || c.startRow === l && c.startColumn === t.startColumn;
  if (l >= a)
    return { ...t, startRow: l, endRow: l };
  if (r) {
    const h = { ...t, startRow: u, endRow: u };
    return Si(n, e, h, s, o, !1);
  }
}, pi = (n, e, t, s = 1, o = !0, r = !0) => {
  const i = X.transformRange(n, e), { startRow: a, endRow: u } = i;
  let l = t.endRow + s, c = e.getMergedCell(l, t.startColumn), d = !c || c.startRow === l && c.startColumn === t.startColumn;
  for (; !e.getRowVisible(l) || !d; )
    l++, c = e.getMergedCell(l, t.startColumn), d = !c || c.startRow === l && c.startColumn === t.startColumn;
  if (l <= u)
    return { ...t, startRow: l, endRow: l };
  if (r) {
    const h = { ...t, startRow: a, endRow: a };
    return wi(n, e, h, s, o, !1);
  }
}, Si = (n, e, t, s = 1, o = !0, r = !0) => {
  const i = X.transformRange(n, e), { startColumn: a, endColumn: u } = i;
  let l = t.startColumn - s, c = e.getMergedCell(t.startRow, l), d = !c || c.startRow === t.startRow && c.startColumn === l;
  for (; !e.getColVisible(l) || !d; )
    l--, c = e.getMergedCell(t.startRow, l), d = !c || c.startRow === t.startRow && c.startColumn === l;
  if (l >= a)
    return { ...t, startColumn: l, endColumn: l };
  if (r) {
    const h = { ...t, startColumn: u, endColumn: u };
    return Ci(n, e, h, s, o, !1);
  }
}, wi = (n, e, t, s = 1, o = !0, r = !0) => {
  const i = X.transformRange(n, e), { startColumn: a, endColumn: u } = i;
  let l = t.endColumn + s, c = e.getMergedCell(t.startRow, l), d = !c || c.startRow === t.startRow && c.startColumn === l;
  for (; !e.getColVisible(l) || !d; )
    l++, c = e.getMergedCell(t.startRow, l), d = !c || c.startRow === t.startRow && c.startColumn === l;
  if (l <= u)
    return { ...t, endColumn: l, startColumn: l };
  if (r) {
    const h = { ...t, startColumn: a, endColumn: a };
    return pi(n, e, h, s, o, !1);
  }
};
function En(n, e, t) {
  let s = null;
  return t.getMatrixWithMergedCells(n, e, n, e).forValue((r, i, a) => (s = {
    actualRow: r,
    actualColumn: i,
    startRow: r,
    startColumn: i,
    isMerged: a.rowSpan !== void 0 || a.colSpan !== void 0,
    isMergedMainCell: a.rowSpan !== void 0 && a.colSpan !== void 0,
    endRow: r + (a.rowSpan !== void 0 ? a.rowSpan - 1 : 0),
    endColumn: i + (a.colSpan !== void 0 ? a.colSpan - 1 : 0),
    rangeType: j.NORMAL
  }, !1)), s || {
    actualColumn: e,
    actualRow: n,
    startRow: n,
    startColumn: e,
    endRow: n,
    endColumn: e,
    isMerged: !1,
    isMergedMainCell: !1,
    rangeType: j.NORMAL
  };
}
const ph = (n, e, t, s, o = 1) => {
  switch (s) {
    case pe.UP:
      return Ci(n, e, t, o);
    case pe.DOWN:
      return pi(n, e, t, o);
    case pe.LEFT:
      return Si(n, e, t, o);
    case pe.RIGHT:
      return wi(n, e, t, o);
  }
}, Cg = (n, e, t) => {
  let s, o = -1, r;
  for (let p = 0; p < n.length; p++)
    if (n[p].primary) {
      s = n[p], o = p, r = s.primary;
      break;
    }
  if (o === -1)
    return null;
  const i = e === pe.LEFT || e === pe.UP, a = i ? o - 1 >= 0 ? o - 1 : n.length - 1 : o + 1 < n.length ? o + 1 : 0, u = n[a];
  if (!s || !r)
    return null;
  const l = { ...r }, { startRow: c, startColumn: d, endRow: h, endColumn: g } = s.range, m = i ? l.startRow === c && l.startColumn === d : l.endRow === h && l.endColumn === g, f = m && i;
  if (!O.equals(s.range, l)) {
    const p = m ? u.range : ph(s.range, t, l, e);
    if (!p)
      return null;
    const w = f ? En(p.endRow, p.endColumn, t) : En(p.startRow, p.startColumn, t);
    return {
      startRow: w.startRow,
      startColumn: w.startColumn,
      endRow: w.endRow,
      endColumn: w.endColumn
    };
  }
  const C = f ? En(u.range.endRow, u.range.endColumn, t) : En(u.range.startRow, u.range.startColumn, t);
  return {
    startRow: C.startRow,
    startColumn: C.startColumn,
    endRow: C.endRow,
    endColumn: C.endColumn
  };
};
export {
  Cs as AFTER_CELL_EDIT,
  hg as AddMergeRedoSelectionsOperationFactory,
  We as AddMergeUndoMutationFactory,
  gg as AddMergeUndoSelectionsOperationFactory,
  $u as AddRangeProtectionCommand,
  Be as AddRangeProtectionMutation,
  Sd as AddRangeThemeMutation,
  Yh as AddWorksheetMergeAllCommand,
  ms as AddWorksheetMergeCommand,
  Zh as AddWorksheetMergeHorizontalCommand,
  ne as AddWorksheetMergeMutation,
  Xh as AddWorksheetMergeVerticalCommand,
  oc as AddWorksheetProtectionCommand,
  Mt as AddWorksheetProtectionMutation,
  ac as AppendRowCommand,
  co as BEFORE_CELL_EDIT,
  Ht as BorderStyleManagerService,
  bh as COMMAND_LISTENER_SKELETON_CHANGE,
  Eh as COMMAND_LISTENER_VALUE_CHANGE,
  $c as CancelFrozenCommand,
  vd as CancelMarkDirtyRowAutoHeightMutation,
  Ls as ClearSelectionAllCommand,
  Ys as ClearSelectionContentCommand,
  Hs as ClearSelectionFormatCommand,
  gc as CopySheetCommand,
  Yr as CopyWorksheetEndMutation,
  Wh as DISABLE_NORMAL_SELECTIONS,
  Jn as DefinedNameDataController,
  It as DeleteRangeMoveLeftCommand,
  vt as DeleteRangeMoveUpCommand,
  fc as DeleteRangeProtectionCommand,
  ot as DeleteRangeProtectionMutation,
  Rc as DeleteWorksheetProtectionCommand,
  xt as DeleteWorksheetProtectionMutation,
  Cc as DeleteWorksheetRangeThemeStyleCommand,
  nn as DeleteWorksheetRangeThemeStyleMutation,
  Va as DeleteWorksheetRangeThemeStyleMutationFactory,
  Fn as DeltaColumnWidthCommand,
  Gn as DeltaRowHeightCommand,
  xu as EditStateEnum,
  W as EffectRefRangId,
  wd as EmptyMutation,
  nh as ExclusiveRangeService,
  $h as FactoryAddRangeProtectionMutation,
  xh as FactoryDeleteRangeProtectionMutation,
  eg as FactorySetRangeProtectionMutation,
  To as IExclusiveRangeService,
  ht as INTERCEPTOR_POINT,
  $t as INumfmtService,
  Ku as IRefSelectionsService,
  ll as InsertColAfterCommand,
  ul as InsertColBeforeCommand,
  $r as InsertColByRangeCommand,
  Xe as InsertColCommand,
  Ue as InsertColMutation,
  as as InsertColMutationUndoFactory,
  pc as InsertDefinedNameCommand,
  cl as InsertMultiColsLeftCommand,
  dl as InsertMultiColsRightCommand,
  il as InsertMultiRowsAboveCommand,
  al as InsertMultiRowsAfterCommand,
  Pt as InsertRangeMoveDownCommand,
  rn as InsertRangeMoveRightCommand,
  rl as InsertRowAfterCommand,
  ol as InsertRowBeforeCommand,
  Ar as InsertRowByRangeCommand,
  Ye as InsertRowCommand,
  ke as InsertRowMutation,
  Ws as InsertRowMutationUndoFactory,
  Sc as InsertSheetCommand,
  ln as InsertSheetMutation,
  Xr as InsertSheetUndoMutationFactory,
  Ca as InterceptCellContentPriority,
  bd as MAX_CELL_PER_SHEET_KEY,
  Ql as MERGE_CELL_INTERCEPTOR_CHECK,
  Id as MarkDirtyRowAutoHeightMutation,
  Vn as MergeCellController,
  un as MoveColsCommand,
  qe as MoveColsMutation,
  Ha as MoveColsMutationUndoFactory,
  yt as MoveRangeCommand,
  wt as MoveRangeMutation,
  an as MoveRowsCommand,
  Je as MoveRowsMutation,
  La as MoveRowsMutationUndoFactory,
  Ns as NumfmtService,
  Q as OperatorType,
  fg as PermissionPointsDefinitions,
  Fu as REF_SELECTIONS_ENABLED,
  Ph as RangeMergeUtil,
  Wt as RangeProtectionCache,
  di as RangeProtectionPermissionDeleteProtectionPoint,
  Ve as RangeProtectionPermissionEditPoint,
  hi as RangeProtectionPermissionManageCollaPoint,
  Bs as RangeProtectionPermissionViewPoint,
  ss as RangeProtectionRefRangeService,
  fn as RangeProtectionRenderModel,
  me as RangeProtectionRuleModel,
  os as RangeProtectionService,
  Rt as RangeThemeStyle,
  At as RefRangeService,
  Co as RefSelectionsService,
  wc as RegisterWorksheetRangeThemeStyleCommand,
  cn as RegisterWorksheetRangeThemeStyleMutation,
  Vr as RemoveColByRangeCommand,
  gs as RemoveColCommand,
  Me as RemoveColMutation,
  Qr as RemoveDefinedNameCommand,
  ye as RemoveMergeUndoMutationFactory,
  mi as RemoveNumfmtMutation,
  Md as RemoveRangeThemeMutation,
  Wr as RemoveRowByRangeCommand,
  hs as RemoveRowCommand,
  Te as RemoveRowMutation,
  Zs as RemoveSheetCommand,
  Lt as RemoveSheetMutation,
  hl as RemoveSheetUndoMutationFactory,
  Ic as RemoveWorksheetMergeCommand,
  se as RemoveWorksheetMergeMutation,
  ks as ReorderRangeCommand,
  On as ReorderRangeMutation,
  ja as ReorderRangeUndoMutationFactory,
  Kc as ResetBackgroundColorCommand,
  zc as ResetTextColorCommand,
  mg as SCOPE_WORKBOOK_VALUE_DEFINED_NAME,
  Vh as SELECTIONS_ENABLED,
  Oh as SELECTION_CONTROL_BORDER_BUFFER_COLOR,
  Nh as SELECTION_CONTROL_BORDER_BUFFER_WIDTH,
  fs as SHEETS_PLUGIN_CONFIG_KEY,
  yd as ScrollToCellOperation,
  qu as SelectRangeCommand,
  we as SelectionMoveType,
  Gc as SetBackgroundColorCommand,
  tg as SetBoldCommand,
  Nc as SetBorderBasicCommand,
  Pc as SetBorderColorCommand,
  In as SetBorderCommand,
  Uc as SetBorderPositionCommand,
  Tc as SetBorderStyleCommand,
  Oc as SetColDataCommand,
  zt as SetColDataMutation,
  Ka as SetColDataMutationFactory,
  Us as SetColHiddenCommand,
  sn as SetColHiddenMutation,
  on as SetColVisibleMutation,
  Bn as SetColWidthCommand,
  ni as SetDefinedNameCommand,
  ig as SetFontFamilyCommand,
  ag as SetFontSizeCommand,
  xc as SetFrozenCommand,
  st as SetFrozenMutation,
  si as SetFrozenMutationFactory,
  Wc as SetGridlinesColorCommand,
  Gt as SetGridlinesColorMutation,
  qc as SetHorizontalTextAlignCommand,
  ng as SetItalicCommand,
  so as SetNumfmtMutation,
  rg as SetOverlineCommand,
  Vc as SetProtectionCommand,
  fe as SetRangeProtectionMutation,
  _d as SetRangeThemeMutation,
  Sn as SetRangeValuesCommand,
  ee as SetRangeValuesMutation,
  Ae as SetRangeValuesUndoMutationFactory,
  Lc as SetRowDataCommand,
  Kt as SetRowDataMutation,
  ru as SetRowDataMutationFactory,
  Kn as SetRowHeightCommand,
  Ts as SetRowHiddenCommand,
  Tt as SetRowHiddenMutation,
  Ut as SetRowVisibleMutation,
  ei as SetSelectedColsVisibleCommand,
  oi as SetSelectedRowsVisibleCommand,
  ie as SetSelectionsOperation,
  dn as SetSpecificColsVisibleCommand,
  hn as SetSpecificRowsVisibleCommand,
  og as SetStrikeThroughCommand,
  Ce as SetStyleCommand,
  Qc as SetTabColorCommand,
  Un as SetTabColorMutation,
  jc as SetTextColorCommand,
  Xc as SetTextRotationCommand,
  Yc as SetTextWrapCommand,
  sg as SetUnderlineCommand,
  Jc as SetVerticalTextAlignCommand,
  ai as SetWorkbookNameCommand,
  ii as SetWorkbookNameMutation,
  ui as SetWorksheetActivateCommand,
  pn as SetWorksheetActiveOperation,
  mt as SetWorksheetColWidthMutation,
  Zo as SetWorksheetColWidthMutationFactory,
  td as SetWorksheetColumnCountCommand,
  Jt as SetWorksheetColumnCountMutation,
  uu as SetWorksheetColumnCountUndoMutationFactory,
  nd as SetWorksheetDefaultStyleCommand,
  qt as SetWorksheetDefaultStyleMutation,
  lu as SetWorksheetDefaultStyleMutationFactory,
  sd as SetWorksheetHideCommand,
  St as SetWorksheetHideMutation,
  eo as SetWorksheetNameCommand,
  jn as SetWorksheetNameMutation,
  ci as SetWorksheetOrderCommand,
  Tn as SetWorksheetOrderMutation,
  dd as SetWorksheetPermissionPointsCommand,
  to as SetWorksheetPermissionPointsMutation,
  hd as SetWorksheetProtectionCommand,
  bt as SetWorksheetProtectionMutation,
  rc as SetWorksheetRangeThemeStyleCommand,
  tn as SetWorksheetRangeThemeStyleMutation,
  Wa as SetWorksheetRangeThemeStyleMutationFactory,
  lg as SetWorksheetRightToLeftCommand,
  Is as SetWorksheetRightToLeftMutation,
  er as SetWorksheetRowAutoHeightMutation,
  yh as SetWorksheetRowAutoHeightMutationFactory,
  md as SetWorksheetRowCountCommand,
  Yt as SetWorksheetRowCountMutation,
  cu as SetWorksheetRowCountUndoMutationFactory,
  nt as SetWorksheetRowHeightMutation,
  no as SetWorksheetRowIsAutoHeightCommand,
  Fe as SetWorksheetRowIsAutoHeightMutation,
  gi as SetWorksheetShowCommand,
  G as SheetInterceptorService,
  Ln as SheetLazyExecuteScheduleService,
  Yn as SheetPermissionCheckController,
  Xn as SheetPermissionInitController,
  ve as SheetRangeThemeModel,
  Os as SheetRangeThemeService,
  du as SheetSkeletonChangeType,
  rt as SheetSkeletonService,
  hu as SheetValueChangeType,
  qn as SheetsFreezeSyncController,
  z as SheetsSelectionsService,
  vu as SplitDelimiterEnum,
  fd as SplitTextToColumnsCommand,
  Rd as ToggleCellCheckboxCommand,
  Cd as ToggleGridlinesCommand,
  Xt as ToggleGridlinesMutation,
  _ as UnitAction,
  x as UnitObject,
  rs as UniverSheetsPlugin,
  pd as UnregisterWorksheetRangeThemeStyleCommand,
  Xs as UnregisterWorksheetRangeThemeStyleMutation,
  ps as VALIDATE_CELL,
  Au as ViewStateEnum,
  rr as WorkbookCommentPermission,
  ir as WorkbookCopyPermission,
  Xu as WorkbookCopySheetPermission,
  ar as WorkbookCreateProtectPermission,
  ur as WorkbookCreateSheetPermission,
  Zu as WorkbookDeleteColumnPermission,
  Qu as WorkbookDeleteRowPermission,
  lr as WorkbookDeleteSheetPermission,
  cr as WorkbookDuplicatePermission,
  Pe as WorkbookEditablePermission,
  dr as WorkbookExportPermission,
  js as WorkbookHideSheetPermission,
  el as WorkbookHistoryPermission,
  tl as WorkbookInsertColumnPermission,
  nl as WorkbookInsertRowPermission,
  zs as WorkbookManageCollaboratorPermission,
  Gs as WorkbookMoveSheetPermission,
  mn as WorkbookPermissionService,
  hr as WorkbookPrintPermission,
  gr as WorkbookRecoverHistoryPermission,
  Ks as WorkbookRenameSheetPermission,
  Wu as WorkbookSelectionModel,
  mr as WorkbookSharePermission,
  Rr as WorkbookViewHistoryPermission,
  fr as WorkbookViewPermission,
  Cr as WorksheetCopyPermission,
  pr as WorksheetDeleteColumnPermission,
  Sr as WorksheetDeleteProtectionPermission,
  wr as WorksheetDeleteRowPermission,
  Ir as WorksheetEditExtraObjectPermission,
  Le as WorksheetEditPermission,
  vr as WorksheetFilterPermission,
  Mr as WorksheetInsertColumnPermission,
  _r as WorksheetInsertHyperlinkPermission,
  yr as WorksheetInsertRowPermission,
  br as WorksheetManageCollaboratorPermission,
  zn as WorksheetPermissionService,
  Er as WorksheetPivotTablePermission,
  vn as WorksheetProtectionPointModel,
  lt as WorksheetProtectionRuleModel,
  Bh as WorksheetSelectProtectedCellsPermission,
  jh as WorksheetSelectUnProtectedCellsPermission,
  kr as WorksheetSetCellStylePermission,
  An as WorksheetSetCellValuePermission,
  Zt as WorksheetSetColumnStylePermission,
  Qt as WorksheetSetRowStylePermission,
  Ur as WorksheetSortPermission,
  ds as WorksheetViewPermission,
  Zn as ZebraCrossingCacheController,
  Qh as addMergeCellsUtil,
  Hl as adjustRangeOnMutation,
  cs as alignToMergedCellsBorders,
  pt as baseProtectionActions,
  uo as checkCellValueType,
  Rg as checkRangesEditablePermission,
  Iu as convertPrimaryWithCoordToPrimary,
  Dh as convertSelectionDataToRange,
  Ct as copyRangeStyles,
  Sl as countCells,
  Su as createTopMatrixFromMatrix,
  pu as createTopMatrixFromRanges,
  qr as defaultLargeSheetOperationConfig,
  id as defaultWorkbookPermissionPoints,
  ws as defaultWorksheetPermissionPoint,
  Th as expandToContinuousRange,
  dg as factoryRemoveNumfmtUndoMutation,
  cg as factorySetNumfmtUndoMutation,
  tr as findAllRectangle,
  Ah as findFirstNonEmptyCell,
  ut as followSelectionOperation,
  sr as generateNullCell,
  Nu as generateNullCellValue,
  Jr as getAddMergeMutationRangeByType,
  Ee as getAllRangePermissionPoint,
  gn as getAllWorkbookPermissionPoint,
  be as getAllWorksheetPermissionPoint,
  He as getAllWorksheetPermissionPointByPointPanel,
  Lh as getCellAtRowCol,
  ug as getDefaultRangePermission,
  Tr as getInsertRangeMutations,
  Fs as getMoveRangeUndoRedoMutations,
  Cg as getNextPrimaryCell,
  _e as getPrimaryForRange,
  Pr as getRemoveRangeMutations,
  Ju as getSelectionsService,
  qh as getSeparateEffectedRangesOnCommand,
  P as getSheetCommandTarget,
  Yo as getSheetCommandTargetWorkbook,
  Qe as getSheetMutationTarget,
  Uh as getSkeletonChangedEffectedRange,
  kh as getValueChangedEffectedRange,
  ls as getVisibleRanges,
  Ot as handleBaseInsertRange,
  Wn as handleBaseMoveRowsCols,
  Nt as handleBaseRemoveRange,
  So as handleCommonDefaultRangeChangeWithEffectRefCommands,
  Jh as handleCommonRangeChangeWithEffectRefCommandsSkipNoInterests,
  po as handleDefaultRangeChangeWithEffectRefCommands,
  Kh as handleDefaultRangeChangeWithEffectRefCommandsSkipNoInterests,
  Dl as handleDeleteRangeMoveLeft,
  xl as handleDeleteRangeMoveUp,
  Gh as handleDeleteRangeMutation,
  Gr as handleIRemoveCol,
  yl as handleIRemoveRow,
  Ul as handleInsertCol,
  Tl as handleInsertRangeMoveDown,
  Nl as handleInsertRangeMoveRight,
  zh as handleInsertRangeMutation,
  kl as handleInsertRow,
  zr as handleMoveCols,
  Ml as handleMoveRange,
  jr as handleMoveRows,
  Fh as isSingleCellSelection,
  nr as rangeMerge,
  Du as rangeToDiscreteRange,
  Oe as rotateRange,
  Dt as runRefRangeMutations,
  Hh as setEndForRange,
  ku as splitRangeText,
  Ps as transformCellsToRange
};
