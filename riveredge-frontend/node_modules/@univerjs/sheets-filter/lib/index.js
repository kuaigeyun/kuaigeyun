var be = Object.defineProperty;
var $e = (i, t, e) => t in i ? be(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;
var C = (i, t, e) => $e(i, typeof t != "symbol" ? t + "" : t, e);
import { createREGEXFromWildChar as me, isNumeric as Le, Disposable as U, Rectangle as te, mergeSets as K, Tools as ie, extractPureTextFromCell as Ue, CellValueType as k, ColorKit as se, UniverInstanceType as D, fromCallback as Pe, CommandType as O, IResourceManagerService as De, IUniverInstanceService as T, ICommandService as N, IUndoRedoService as J, sequenceExecute as j, ErrorService as Be, LocaleService as ze, Inject as A, Optional as He, DisposableCollection as ge, moveMatrixArray as oe, IConfigService as _e, Plugin as Ve, merge as We, touchDependencies as je, Injector as ke } from "@univerjs/core";
import { getSheetCommandTarget as H, SheetsSelectionsService as qe, isSingleCellSelection as Ge, expandToContinuousRange as Ce, SheetInterceptorService as Qe, RefRangeService as Je, ZebraCrossingCacheController as Ze, SetWorksheetActiveOperation as Ke, CopySheetCommand as Ye, RemoveSheetCommand as Xe, INTERCEPTOR_POINT as et, RemoveRowMutation as tt, InsertRowMutation as rt, SetRangeValuesMutation as nt, MoveRowsCommand as it, MoveRangeCommand as st, EffectRefRangId as le, RemoveRowCommand as ot, RemoveColCommand as lt, InsertColCommand as at, InsertRowCommand as ct, InsertColMutation as Re, RemoveColMutation as pe, MoveColsMutation as Se } from "@univerjs/sheets";
import { BehaviorSubject as $, merge as dt, filter as ut, switchMap as ht, of as ft } from "rxjs";
import { COLOR_BLACK_RGB as mt } from "@univerjs/engine-render";
import { DataSyncPrimaryController as gt } from "@univerjs/rpc";
import { IActiveDirtyManagerService as _t, ISheetRowFilteredService as Ct } from "@univerjs/engine-formula";
const Fe = "sheet.mutation.set-filter-range", we = "sheet.mutation.set-filter-criteria", ve = "sheet.mutation.remove-filter", Me = "sheet.mutation.re-calc-filter", Ee = /* @__PURE__ */ new Set([
  Fe,
  we,
  ve,
  Me
]);
var b = /* @__PURE__ */ ((i) => (i[i.VALUES = 0] = "VALUES", i[i.COLORS = 1] = "COLORS", i[i.CONDITIONS = 2] = "CONDITIONS", i))(b || {}), I = /* @__PURE__ */ ((i) => (i.EQUAL = "equal", i.GREATER_THAN = "greaterThan", i.GREATER_THAN_OR_EQUAL = "greaterThanOrEqual", i.LESS_THAN = "lessThan", i.LESS_THAN_OR_EQUAL = "lessThanOrEqual", i.NOT_EQUALS = "notEqual", i))(I || {});
const Rt = {
  operator: I.GREATER_THAN,
  fn: (i, t) => P(i) ? i > t : !1
}, pt = {
  operator: I.GREATER_THAN_OR_EQUAL,
  fn: (i, t) => P(i) ? i >= t : !1
}, St = {
  operator: I.LESS_THAN,
  fn: (i, t) => P(i) ? i < t : !1
}, Ft = {
  operator: I.LESS_THAN_OR_EQUAL,
  fn: (i, t) => P(i) ? i <= t : !1
}, wt = {
  operator: I.EQUAL,
  fn: (i, t) => P(i) ? i === t : !1
}, Oe = {
  operator: I.NOT_EQUALS,
  fn: (i, t) => {
    if (typeof t == "string") {
      if (t === " ")
        return i != null;
      const e = Ae(i);
      return e && Ot(t) ? !me(t).test(e) : e !== t;
    }
    return P(i) ? i !== t : !0;
  }
}, ye = /* @__PURE__ */ new Map([]), vt = [Rt, pt, St, Ft, wt, Oe];
vt.forEach((i) => {
  ye.set(i.operator, i);
});
function Mt(i) {
  return !!i;
}
const Et = {
  fn: (i, t) => {
    const e = Ae(i);
    return e === null ? t === "" : me(t).test(e);
  }
};
function ae(i) {
  return i ? ye.get(i) : Et;
}
function P(i) {
  return typeof i == "number";
}
function ce(i) {
  return !!(typeof i == "number" || typeof i == "string" && Le(i));
}
function Ae(i) {
  return typeof i == "boolean" || i == null ? null : typeof i == "string" ? i : i.toString();
}
function Ot(i) {
  return typeof i == "number" ? !1 : i.indexOf("*") !== -1 || i.indexOf("?") !== -1;
}
const Y = () => /* @__PURE__ */ new Set();
class q extends U {
  constructor(e, r, n) {
    super();
    C(this, "_filteredOutRows$", new $(Y()));
    /** An observable value. A set of filtered out rows. */
    C(this, "filteredOutRows$", this._filteredOutRows$.asObservable());
    // TODO: we may need to update which cols have criteria rather than simple boolean
    C(this, "_hasCriteria$", new $(!1));
    C(this, "hasCriteria$", this._hasCriteria$.asObservable());
    C(this, "_filterColumnByIndex", /* @__PURE__ */ new Map());
    C(this, "_alreadyFilteredOutRows", Y());
    C(this, "_range");
    this.unitId = e, this.subUnitId = r, this._worksheet = n;
  }
  get filteredOutRows() {
    return this._filteredOutRows$.getValue();
  }
  set filteredOutRows(e) {
    this._alreadyFilteredOutRows = e, this._filteredOutRows$.next(e);
  }
  dispose() {
    super.dispose(), this._filteredOutRows$.complete(), this._hasCriteria$.complete(), this._worksheet = null;
  }
  /**
   * Serialize this filter model to the JSON format representation.
   */
  serialize() {
    const e = {
      ref: te.clone(this._range),
      filterColumns: this._getAllFilterColumns(!0).sort(([r], [n]) => r - n).map(([r, n]) => n.serialize())
    };
    return this._alreadyFilteredOutRows && (e.cachedFilteredOut = Array.from(this._alreadyFilteredOutRows).sort()), e;
  }
  /**
   * Deserialize auto filter info to construct a `FilterModel` object.
   * @param unitId workbook id
   * @param subUnitId worksheet id
   * @param worksheet the Worksheet object
   * @param autoFilter auto filter data
   */
  static deserialize(e, r, n, s) {
    const o = new q(e, r, n);
    return o._dump(s), o;
  }
  _dump(e) {
    var r;
    this.setRange(e.ref), (r = e.filterColumns) == null || r.filter((n) => !(!n.filters && !n.colorFilters && !n.customFilters)).forEach((n) => this._setCriteriaWithoutReCalc(n.colId, n)), e.cachedFilteredOut ? (this._alreadyFilteredOutRows = new Set(e.cachedFilteredOut), this._emit()) : e.filterColumns && e.filterColumns.length > 0 && (this._reCalcAllColumns(), this._emit()), this._emitHasCriteria();
  }
  isRowFiltered(e) {
    return this._alreadyFilteredOutRows.has(e);
  }
  getRange() {
    if (!this._range)
      throw new Error("[FilterModel] could not get range before a range is set!");
    return this._range;
  }
  /**
   * Get filtered out rows except the specific column. This method is considered as "pure". In
   * another word it would not change `filteredOutRows` on `FilterModel` nor `FilterColumn`.
   * @param col
   */
  getFilteredOutRowsExceptCol(e) {
    return this._getAllFilterColumns(!0).filter(([r]) => r !== e).reduce((r, [, n]) => {
      const s = n.calc({ getAlreadyFilteredOutRows: () => r });
      return s ? K(r, s) : r;
    }, /* @__PURE__ */ new Set());
  }
  /**
   * Set range of the filter model, this would remove some `IFilterColumn`
   * if the new range not overlaps the old range.
   */
  setRange(e) {
    this._range = e, this._getAllFilterColumns(!0).forEach(([r, n]) => {
      n.setRangeAndColumn({
        startRow: e.startRow,
        endRow: e.endRow,
        startColumn: r,
        endColumn: r
      }, r);
    });
  }
  /**
   * Set or remove filter criteria on a specific row.
   */
  setCriteria(e, r, n = !1) {
    if (!this._range)
      throw new Error("[FilterModel] could not set criteria before a range is set!");
    if (!r) {
      this._removeCriteria(e), this._rebuildAlreadyFilteredOutRowsWithCache(), n && this._reCalcAllColumns(), this._emit(), this._emitHasCriteria();
      return;
    }
    this._setCriteriaWithoutReCalc(e, r), n && (this._rebuildAlreadyFilteredOutRowsWithCache(), this._getAllFilterColumns().forEach((s) => s.__clearCache()), this._reCalcWithNoCacheColumns(), this._emit(), this._emitHasCriteria());
  }
  getAllFilterColumns() {
    return this._getAllFilterColumns(!0);
  }
  getFilterColumn(e) {
    var r;
    return (r = this._filterColumnByIndex.get(e)) != null ? r : null;
  }
  reCalc() {
    this._reCalcAllColumns(), this._emit();
  }
  _getAllFilterColumns(e = !1) {
    const r = Array.from(this._filterColumnByIndex.entries());
    return e ? r : r.map(([n, s]) => s);
  }
  _reCalcAllColumns() {
    this._alreadyFilteredOutRows = Y(), this._getAllFilterColumns().forEach((e) => e.__clearCache()), this._reCalcWithNoCacheColumns();
  }
  _setCriteriaWithoutReCalc(e, r) {
    const n = this._range;
    if (!n)
      throw new Error("[FilterModel] could not set criteria before a range is set!");
    const { startColumn: s, endColumn: o } = n;
    if (e > o || e < s)
      throw new Error(`[FilterModel] could not set criteria on column ${e} which is out of range!`);
    let l;
    this._filterColumnByIndex.has(e) ? l = this._filterColumnByIndex.get(e) : (l = new yt(
      this.unitId,
      this.subUnitId,
      this._worksheet,
      r,
      { getAlreadyFilteredOutRows: () => this._alreadyFilteredOutRows }
    ), l.setRangeAndColumn(n, e), this._filterColumnByIndex.set(e, l)), l.setCriteria(r);
  }
  _removeCriteria(e) {
    const r = this._filterColumnByIndex.get(e);
    r && (r.dispose(), this._filterColumnByIndex.delete(e));
  }
  _emit() {
    this._filteredOutRows$.next(this._alreadyFilteredOutRows);
  }
  _emitHasCriteria() {
    this._hasCriteria$.next(this._filterColumnByIndex.size > 0);
  }
  _rebuildAlreadyFilteredOutRowsWithCache() {
    const e = this._getAllFilterColumns().filter((r) => r.hasCache()).reduce((r, n) => K(r, n.filteredOutRows), /* @__PURE__ */ new Set());
    this._alreadyFilteredOutRows = e;
  }
  _reCalcWithNoCacheColumns() {
    const e = this._getAllFilterColumns().filter((r) => !r.hasCache());
    for (const r of e) {
      const n = r.reCalc();
      n && (this._alreadyFilteredOutRows = K(this._alreadyFilteredOutRows, n));
    }
  }
}
class yt extends U {
  constructor(e, r, n, s, o) {
    super();
    C(this, "_filteredOutRows", null);
    /** Cache the filter function.  */
    C(this, "_filterFn", null);
    C(this, "_range", null);
    C(this, "_column", 0);
    C(this, "_filterBy", b.VALUES);
    this.unitId = e, this.subUnitId = r, this._worksheet = n, this._criteria = s, this._filterColumnContext = o;
  }
  get filteredOutRows() {
    return this._filteredOutRows;
  }
  get filterBy() {
    return this._filterBy;
  }
  dispose() {
    super.dispose(), this._filteredOutRows = null;
  }
  /**
   * @internal
   */
  __clearCache() {
    this._filteredOutRows = null;
  }
  serialize() {
    if (!this._criteria)
      throw new Error("[FilterColumn]: could not serialize without a filter column!");
    return ie.deepClone({
      ...this._criteria,
      colId: this._column
    });
  }
  hasCache() {
    return this._filteredOutRows !== null;
  }
  // The first row should be omitted!
  setRangeAndColumn(e, r) {
    this._range = e, this._column = r;
  }
  setCriteria(e) {
    this._criteria = e, this._generateFilterFn(), this._filteredOutRows = null;
  }
  getColumnData() {
    return ie.deepClone(this._criteria);
  }
  /**
   * Trigger new calculation on this `FilterModel` instance.
   *
   * @external DO NOT EVER call this method from `FilterColumn` itself. The whole process heavily relies on
   * `filteredOutByOthers`, and it is more comprehensible if we let `FilterModel` take full control over the process.
   */
  reCalc() {
    return this._filteredOutRows = this.calc(this._filterColumnContext), this._filteredOutRows;
  }
  calc(e) {
    if (!this._filterFn)
      throw new Error("[FilterColumn] cannot calculate without a filter fn!");
    if (!this._range)
      throw new Error("[FilterColumn] cannot calculate without a range!");
    if (typeof this._column != "number")
      throw new TypeError("[FilterColumn] cannot calculate without a column offset!");
    const r = this._column, n = { startColumn: r, endColumn: r, startRow: this._range.startRow + 1, endRow: this._range.endRow }, s = /* @__PURE__ */ new Set(), o = e.getAlreadyFilteredOutRows();
    for (const l of this._worksheet.iterateByColumn(n, !1, !1)) {
      const { row: a, rowSpan: c, col: u } = l;
      if (o.has(a) && (!c || c === 1))
        continue;
      if (!(this._filterBy === b.VALUES ? this._filterFn(Ue(this._worksheet.getCell(a, u))) : this._filterBy === b.COLORS ? this._filterFn(this._worksheet.getComposedCellStyle(a, u)) : this._filterFn(Ut(this._worksheet, a, u))) && (s.add(a), c))
        for (let h = 1; h < c; h++)
          s.add(a + h);
    }
    return s;
  }
  _generateFilterFn() {
    this._criteria && (this._filterFn = At(this._criteria), this._filterBy = this._criteria.filters ? b.VALUES : this._criteria.colorFilters ? b.COLORS : b.CONDITIONS);
  }
}
function At(i) {
  if (i.filters)
    return Nt(i.filters);
  if (i.colorFilters)
    return Tt(i.colorFilters);
  if (i.customFilters)
    return It(i.customFilters);
  throw new Error("[FilterModel]: other types of filters are not supported yet.");
}
function Nt(i) {
  const t = !!i.blank, e = new Set(i.filters);
  return (r) => r === void 0 || r === "" ? t : e.has(typeof r == "string" ? r : `${r}`);
}
function Tt(i) {
  if (i.cellFillColors) {
    const t = new Set(i.cellFillColors);
    return (e) => {
      var n;
      if (!e || !((n = e.bg) != null && n.rgb))
        return !!t.has(null);
      const r = new se(e.bg.rgb).toRgbString();
      return t.has(r);
    };
  }
  if (i.cellTextColors) {
    const t = new Set(i.cellTextColors);
    return (e) => {
      var n;
      if (!e || !((n = e.cl) != null && n.rgb))
        return !!t.has(mt);
      const r = new se(e.cl.rgb).toRgbString();
      return t.has(r);
    };
  }
  throw new Error("[FilterModel]: color filters are not supported yet.");
}
function It(i) {
  const t = i.customFilters.map((e) => Lt(e));
  return $t(t) ? i.and ? xt(t) : bt(t) : t[0];
}
function xt(i) {
  const [t, e] = i;
  return (r) => t(r) && e(r);
}
function bt(i) {
  const [t, e] = i;
  return (r) => t(r) || e(r);
}
function $t(i) {
  return i.length === 2;
}
function Lt(i) {
  const t = i.val;
  if (i.operator === I.NOT_EQUALS && !ce(t))
    return (n) => Oe.fn(n, t);
  if (Mt(i.operator)) {
    if (!ce(t)) return () => !1;
    const n = ae(i.operator), s = Number(t);
    return (o) => n.fn(o, s);
  }
  const e = ae(i.operator);
  return (r) => e.fn(r, t);
}
function Ut(i, t, e) {
  const r = i.getCell(t, e);
  if (!r) return null;
  const n = i.getCellRaw(t, e);
  return r && !n ? de(r) : n ? r.t === k.NUMBER && typeof r.v == "string" ? n.v : r.t === k.NUMBER ? Number(n.v) : de(n) : null;
}
function de(i) {
  var r, n;
  const t = (n = (r = i.p) == null ? void 0 : r.body) == null ? void 0 : n.dataStream;
  if (t) return t.trimEnd();
  const e = i.v;
  return typeof e == "string" ? i.t === k.BOOLEAN ? e.toUpperCase() : e : typeof e == "number" ? i.t === k.BOOLEAN ? e ? "TRUE" : "FALSE" : e : typeof e == "boolean" ? e ? "TRUE" : "FALSE" : "";
}
var Pt = Object.getOwnPropertyDescriptor, Dt = (i, t, e, r) => {
  for (var n = r > 1 ? void 0 : r ? Pt(t, e) : t, s = i.length - 1, o; s >= 0; s--)
    (o = i[s]) && (n = o(n) || n);
  return n;
}, X = (i, t) => (e, r) => t(e, r, i);
const Ne = "SHEET_FILTER_PLUGIN";
let M = class extends U {
  constructor(t, e, r) {
    super();
    C(this, "_filterModels", /* @__PURE__ */ new Map());
    C(this, "_loadedUnitId$", new $(null));
    C(this, "loadedUnitId$", this._loadedUnitId$.asObservable());
    C(this, "_errorMsg$", new $(null));
    C(this, "errorMsg$", this._errorMsg$.asObservable());
    C(this, "_activeFilterModel$", new $(null));
    /** An observable value emitting the current Workbook's active Worksheet's filter model (if there is one). */
    C(this, "activeFilterModel$", this._activeFilterModel$.asObservable());
    this._resourcesManagerService = t, this._univerInstanceService = e, this._commandService = r, this._initModel(), this._initActiveFilterModel();
  }
  /** The current Workbook's active Worksheet's filter model (if there is one). */
  get activeFilterModel() {
    return this._activeFilterModel$.getValue();
  }
  /**
   *
   * @param unitId
   * @param subUnitId
   */
  ensureFilterModel(t, e) {
    const r = this.getFilterModel(t, e);
    if (r)
      return r;
    const n = this._univerInstanceService.getUniverSheetInstance(t);
    if (!n)
      throw new Error(`[SheetsFilterService]: could not create "FilterModel" on a non-existing workbook ${t}!`);
    const s = n.getSheetBySheetId(e);
    if (!s)
      throw new Error(`[SheetsFilterService]: could not create "FilterModel" on a non-existing worksheet ${e}!`);
    const o = new q(t, e, s);
    return this._cacheFilterModel(t, e, o), o;
  }
  getFilterModel(t, e) {
    var r, n;
    return (n = (r = this._filterModels.get(t)) == null ? void 0 : r.get(e)) != null ? n : null;
  }
  removeFilterModel(t, e) {
    const r = this.getFilterModel(t, e);
    return r ? (r.dispose(), this._filterModels.get(t).delete(e), !0) : !1;
  }
  setFilterErrorMsg(t) {
    this._errorMsg$.next(t);
  }
  _updateActiveFilterModel() {
    let t;
    try {
      if (t = this._univerInstanceService.getCurrentUnitForType(D.UNIVER_SHEET), !t) {
        this._activeFilterModel$.next(null);
        return;
      }
    } catch (o) {
      console.error("[SheetsFilterService]: could not get active workbook!", o);
      return;
    }
    const e = t.getActiveSheet(!0);
    if (!e) {
      this._activeFilterModel$.next(null);
      return;
    }
    const r = e.getUnitId(), n = e.getSheetId(), s = this.getFilterModel(r, n);
    this._activeFilterModel$.next(s);
  }
  _initActiveFilterModel() {
    this.disposeWithMe(
      dt(
        // source1: executing filter related mutations
        Pe(this._commandService.onCommandExecuted.bind(this._commandService)).pipe(ut(([t]) => t.type === O.MUTATION && Ee.has(t.id))),
        // source2: activate sheet changes
        this._univerInstanceService.getCurrentTypeOfUnit$(D.UNIVER_SHEET).pipe(ht((t) => {
          var e;
          return (e = t == null ? void 0 : t.activeSheet$) != null ? e : ft(null);
        }))
      ).subscribe(() => this._updateActiveFilterModel())
    );
  }
  _serializeAutoFiltersForUnit(t) {
    const e = this._filterModels.get(t);
    if (!e)
      return "{}";
    const r = {};
    return e.forEach((n, s) => {
      r[s] = n.serialize();
    }), JSON.stringify(r);
  }
  _deserializeAutoFiltersForUnit(t, e) {
    const r = this._univerInstanceService.getUniverSheetInstance(t);
    Object.keys(e).forEach((n) => {
      const s = e[n], o = q.deserialize(t, n, r.getSheetBySheetId(n), s);
      this._cacheFilterModel(t, n, o);
    });
  }
  dispose() {
    super.dispose(), this._loadedUnitId$.complete(), this._errorMsg$.complete(), this._activeFilterModel$.complete(), this._filterModels.forEach((t) => {
      t.forEach((e) => e.dispose()), t.clear();
    }), this._filterModels.clear();
  }
  _initModel() {
    this._resourcesManagerService.registerPluginResource({
      pluginName: Ne,
      businesses: [D.UNIVER_SHEET],
      toJson: (t) => this._serializeAutoFiltersForUnit(t),
      parseJson: (t) => JSON.parse(t),
      onLoad: (t, e) => {
        this._deserializeAutoFiltersForUnit(t, e), this._loadedUnitId$.next(t), this._updateActiveFilterModel();
      },
      onUnLoad: (t) => {
        const e = this._filterModels.get(t);
        e && (e.forEach((r) => r.dispose()), this._filterModels.delete(t));
      }
    });
  }
  _cacheFilterModel(t, e, r) {
    this._filterModels.has(t) || this._filterModels.set(t, /* @__PURE__ */ new Map()), this._filterModels.get(t).set(e, r);
  }
};
M = Dt([
  X(0, De),
  X(1, T),
  X(2, N)
], M);
const R = {
  id: Fe,
  type: O.MUTATION,
  handler: (i, t) => {
    const { subUnitId: e, unitId: r, range: n } = t;
    return i.get(M).ensureFilterModel(r, e).setRange(n), !0;
  }
}, p = {
  id: we,
  type: O.MUTATION,
  handler: (i, t) => {
    const { subUnitId: e, unitId: r, criteria: n, col: s, reCalc: o = !0 } = t, a = i.get(M).getFilterModel(r, e);
    return a ? (a.setCriteria(s, n, o), !0) : !1;
  }
}, y = {
  id: ve,
  type: O.MUTATION,
  handler: (i, t) => {
    const { unitId: e, subUnitId: r } = t;
    return i.get(M).removeFilterModel(e, r);
  }
}, B = {
  id: Me,
  type: O.MUTATION,
  handler: (i, t) => {
    const { unitId: e, subUnitId: r } = t, s = i.get(M).getFilterModel(e, r);
    return s ? (s.reCalc(), !0) : !1;
  }
}, Bt = {
  id: "sheet.command.set-filter-range",
  type: O.COMMAND,
  handler: (i, t) => {
    const e = i.get(M), r = i.get(N), n = i.get(J), s = i.get(T), { unitId: o, subUnitId: l, range: a } = t;
    if (!H(s, t) || e.getFilterModel(o, l)) return !1;
    if (a.endRow === a.startRow) {
      const g = i.get(Be), _ = i.get(ze);
      return g.emit(_.t("sheets-filter.command.not-valid-filter-range")), !1;
    }
    const d = { id: R.id, params: { unitId: o, subUnitId: l, range: a } }, h = r.syncExecuteCommand(d.id, d.params);
    return h && n.pushUndoRedo({
      unitID: o,
      undoMutations: [{ id: y.id, params: { unitId: o, subUnitId: l } }],
      redoMutations: [d]
    }), h;
  }
}, zt = {
  id: "sheet.command.remove-sheet-filter",
  type: O.COMMAND,
  handler: (i, t) => {
    const e = i.get(T), r = i.get(M), n = i.get(N), s = i.get(J), o = H(e, t);
    if (!o) return !1;
    const { unitId: l, subUnitId: a } = o, c = r.getFilterModel(l, a);
    if (!c) return !1;
    const u = c == null ? void 0 : c.serialize(), d = Ht(l, a, u), h = n.syncExecuteCommand(y.id, { unitId: l, subUnitId: a });
    return h && s.pushUndoRedo({
      unitID: l,
      undoMutations: d,
      redoMutations: [{ id: y.id, params: { unitId: l, subUnitId: a } }]
    }), h;
  }
}, ar = {
  id: "sheet.command.smart-toggle-filter",
  type: O.COMMAND,
  handler: async (i) => {
    const t = i.get(T), e = i.get(M), r = i.get(N), n = t.getCurrentUnitForType(D.UNIVER_SHEET), s = n == null ? void 0 : n.getActiveSheet();
    if (!s || !n) return !1;
    const o = n.getUnitId(), l = s.getSheetId();
    if (e.getFilterModel(o, l))
      return r.executeCommand(zt.id, { unitId: o, subUnitId: l });
    const u = i.get(qe).getCurrentLastSelection();
    if (!u) return !1;
    const d = u.range, h = Ge(u) ? Ce(d, { left: !0, right: !0, up: !0, down: !0 }, s) : d;
    return r.executeCommand(Bt.id, {
      unitId: o,
      subUnitId: l,
      range: h
    });
  }
}, cr = {
  id: "sheet.command.set-filter-criteria",
  type: O.COMMAND,
  handler: (i, t) => {
    const e = i.get(M), r = i.get(N), n = i.get(J), { unitId: s, subUnitId: o, col: l, criteria: a } = t, c = e.getFilterModel(s, o);
    if (!c) return !1;
    const u = c.getRange();
    if (!u || l < u.startColumn || l > u.endColumn) return !1;
    const d = c.getFilterColumn(l), h = Wt(s, o, l, d), g = {
      id: p.id,
      params: {
        unitId: s,
        subUnitId: o,
        col: l,
        criteria: a
      }
    }, _ = r.syncExecuteCommand(g.id, g.params);
    return _ && n.pushUndoRedo({
      unitID: s,
      undoMutations: [h],
      redoMutations: [g]
    }), _;
  }
}, dr = {
  id: "sheet.command.clear-filter-criteria",
  type: O.COMMAND,
  handler: (i, t) => {
    const e = i.get(M), r = i.get(J), n = i.get(N), s = i.get(T), o = H(s, t);
    if (!o) return !1;
    const { unitId: l, subUnitId: a } = o, c = e.getFilterModel(o.unitId, o.subUnitId);
    if (!c) return !1;
    const u = c.serialize(), d = Te(l, a, u), h = Vt(l, a, u);
    return j(h, n).result ? (r.pushUndoRedo({
      unitID: l,
      undoMutations: d,
      redoMutations: h
    }), !0) : !1;
  }
}, ur = {
  id: "sheet.command.re-calc-filter",
  type: O.COMMAND,
  handler: (i, t) => {
    const e = i.get(M), r = i.get(N), n = i.get(T), s = H(n, t);
    if (!s) return !1;
    const { unitId: o, subUnitId: l } = s;
    return e.getFilterModel(s.unitId, s.subUnitId) ? r.executeCommand(B.id, { unitId: o, subUnitId: l }) : !1;
  }
};
function Ht(i, t, e) {
  const r = [], n = {
    id: R.id,
    params: {
      unitId: i,
      subUnitId: t,
      range: e.ref
    }
  };
  return r.push(n), Te(i, t, e).forEach((o) => r.push(o)), r;
}
function Te(i, t, e) {
  var n;
  const r = [];
  return (n = e.filterColumns) == null || n.forEach((s) => {
    const o = {
      id: p.id,
      params: {
        unitId: i,
        subUnitId: t,
        col: s.colId,
        criteria: s
      }
    };
    r.push(o);
  }), r;
}
function Vt(i, t, e) {
  var n;
  const r = [];
  return (n = e.filterColumns) == null || n.forEach((s) => {
    const o = {
      id: p.id,
      params: {
        unitId: i,
        subUnitId: t,
        col: s.colId,
        criteria: null
      }
    };
    r.push(o);
  }), r;
}
function Wt(i, t, e, r) {
  if (!r)
    return {
      id: p.id,
      params: {
        unitId: i,
        subUnitId: t,
        col: e,
        criteria: null
      }
    };
  const n = r.serialize();
  return {
    id: p.id,
    params: {
      unitId: i,
      subUnitId: t,
      col: e,
      criteria: n
    }
  };
}
const Ie = "sheets-filter.config", ue = {};
function jt(i, t) {
  for (let e = 0; e < i.length; e++) {
    let r = e;
    if (i[e])
      for (let n = e + 1; n < i.length; n++)
        i[r] && i[n] && t(i[r], i[n]) && (i[r] = null, r = n);
  }
  return i.filter((e) => e !== null);
}
function L(i) {
  return jt(i, (t, e) => t.id === p.id && e.id === p.id && t.params.unitId === e.params.unitId && t.params.subUnitId === e.params.subUnitId && t.params.col === e.params.col);
}
var kt = Object.getOwnPropertyDescriptor, qt = (i, t, e, r) => {
  for (var n = r > 1 ? void 0 : r ? kt(t, e) : t, s = i.length - 1, o; s >= 0; s--)
    (o = i[s]) && (n = o(n) || n);
  return n;
}, x = (i, t) => (e, r) => t(e, r, i);
let z = class extends U {
  constructor(t, e, r, n, s, o, l) {
    super();
    C(this, "_disposableCollection", new ge());
    this._commandService = t, this._sheetInterceptorService = e, this._sheetsFilterService = r, this._univerInstanceService = n, this._refRangeService = s, this._dataSyncPrimaryController = o, this._zebraCrossingCacheController = l, this._initCommands(), this._initRowFilteredInterceptor(), this._initInterceptors(), this._commandExecutedListener(), this._initErrorHandling(), this._initZebraCrossingCacheListener();
  }
  _initZebraCrossingCacheListener() {
    this.disposeWithMe(
      this._sheetsFilterService.activeFilterModel$.subscribe((t) => {
        t && this.disposeWithMe(
          t.filteredOutRows$.subscribe(() => {
            this._zebraCrossingCacheController.updateZebraCrossingCache(t.unitId, t.subUnitId);
          })
        );
      })
    );
  }
  _initCommands() {
    [
      p,
      R,
      B,
      y
    ].forEach((t) => {
      var e;
      this.disposeWithMe(this._commandService.registerCommand(t)), (e = this._dataSyncPrimaryController) == null || e.registerSyncingMutations(t);
    });
  }
  _initInterceptors() {
    this.disposeWithMe(this._sheetInterceptorService.interceptCommand({
      getMutations: (t) => this._getUpdateFilter(t)
    })), this.disposeWithMe(this._commandService.onCommandExecuted((t) => {
      if (t.id === Ke.id) {
        const e = t.params, r = e.subUnitId, n = e.unitId;
        if (!r || !n)
          return;
        this._registerRefRange(n, r);
      }
      if (t.id === R.id) {
        const e = t.params, r = e.subUnitId, n = e.unitId;
        if (!r || !n)
          return;
        this._registerRefRange(e.unitId, e.subUnitId);
      }
    })), this.disposeWithMe(this._sheetsFilterService.loadedUnitId$.subscribe((t) => {
      if (t) {
        const e = this._univerInstanceService.getUniverSheetInstance(t), r = e == null ? void 0 : e.getActiveSheet();
        r && this._registerRefRange(t, r.getSheetId());
      }
    }));
  }
  _registerRefRange(t, e) {
    var l;
    this._disposableCollection.dispose();
    const r = this._univerInstanceService.getUniverSheetInstance(t), n = r == null ? void 0 : r.getSheetBySheetId(e);
    if (!r || !n) return;
    const s = (l = this._sheetsFilterService.getFilterModel(t, e)) == null ? void 0 : l.getRange(), o = (a) => {
      switch (a.id) {
        case ct.id: {
          const c = a.params, u = c.unitId || t, d = c.subUnitId || e;
          return this._handleInsertRowCommand(c, u, d);
        }
        case at.id: {
          const c = a.params, u = c.unitId || t, d = c.subUnitId || e;
          return this.handleInsertColCommand(c.range, u, d);
        }
        case lt.id: {
          const c = a.params;
          return this.handleRemoveColCommand(c.range, t, e);
        }
        case ot.id: {
          const c = a.params;
          return this._handleRemoveRowCommand(c, t, e);
        }
        case le.MoveColsCommandId: {
          const c = a.params;
          return this.handleMoveColsCommand({
            fromRange: c.fromRange,
            toRange: c.toRange
          }, t, e);
        }
        case le.MoveRowsCommandId: {
          const c = a.params;
          return this._handleMoveRowsCommand(c, t, e);
        }
        case st.id: {
          const c = a.params;
          return this._handleMoveRangeCommand(c, t, e);
        }
      }
      return { redos: [], undos: [] };
    };
    s && this._disposableCollection.add(this._refRangeService.registerRefRange(s, o, t, e));
  }
  _getUpdateFilter(t) {
    const { id: e } = t;
    switch (e) {
      case Xe.id: {
        const r = t.params;
        return this._handleRemoveSheetCommand(r, r.unitId, r.subUnitId);
      }
      case Ye.id: {
        const r = t.params, { targetSubUnitId: n, unitId: s, subUnitId: o } = r;
        return !s || !o || !n ? this._handleNull() : this._handleCopySheetCommand(s, o, n);
      }
    }
    return {
      redos: [],
      undos: []
    };
  }
  handleInsertColCommand(t, e, r) {
    var f;
    const n = this._sheetsFilterService.getFilterModel(e, r), s = (f = n == null ? void 0 : n.getRange()) != null ? f : null;
    if (!n || !s)
      return this._handleNull();
    const { startColumn: o, endColumn: l } = s, { startColumn: a, endColumn: c } = t, u = c - a + 1;
    if (c > l)
      return this._handleNull();
    const d = [], h = [], g = a, _ = {
      unitId: e,
      subUnitId: r,
      range: {
        ...s,
        startColumn: a <= o ? o + u : o,
        endColumn: l + u
      }
    }, S = {
      unitId: e,
      subUnitId: r,
      range: s
    };
    d.push({ id: R.id, params: _ }), h.push({ id: R.id, params: S });
    const F = n.getAllFilterColumns().filter((m) => m[0] >= g);
    if (F.length !== 0) {
      const { newRange: m, oldRange: v } = this._moveCriteria(e, r, F, u);
      d.push(...v.redos, ...m.redos), h.push(...m.undos, ...v.undos);
    }
    return { redos: L(d), undos: L(h) };
  }
  _handleInsertRowCommand(t, e, r) {
    var S;
    const n = this._sheetsFilterService.getFilterModel(e, r), s = (S = n == null ? void 0 : n.getRange()) != null ? S : null;
    if (!n || !s)
      return this._handleNull();
    const { startRow: o, endRow: l } = s, { startRow: a, endRow: c } = t.range, u = c - a + 1;
    if (c > l)
      return this._handleNull();
    const d = [], h = [], g = {
      unitId: e,
      subUnitId: r,
      range: {
        ...s,
        startRow: a <= o ? o + u : o,
        endRow: l + u
      }
    }, _ = {
      unitId: e,
      subUnitId: r,
      range: s
    };
    return d.push({ id: R.id, params: g }), h.push({ id: R.id, params: _ }), {
      redos: L(d),
      undos: L(h)
    };
  }
  handleRemoveColCommand(t, e, r) {
    var F;
    const n = this._sheetsFilterService.getFilterModel(e, r), s = (F = n == null ? void 0 : n.getRange()) != null ? F : null;
    if (!n || !s)
      return this._handleNull();
    const { startColumn: o, endColumn: l } = s, { startColumn: a, endColumn: c } = t;
    if (a > l)
      return this._handleNull();
    const u = [], d = [], h = c < o ? 0 : Math.min(c, l) - Math.max(a, o) + 1, g = c - a + 1, _ = n.getAllFilterColumns();
    _.forEach((f) => {
      const [m, v] = f;
      m <= c && m >= a && (u.push({ id: p.id, params: { unitId: e, subUnitId: r, col: m, criteria: null } }), d.push({ id: p.id, params: { unitId: e, subUnitId: r, col: m, criteria: { ...v.serialize(), colId: m } } }));
    });
    const S = _.filter((f) => {
      const [m, v] = f;
      return m > c;
    });
    let w = { undos: [], redos: [] };
    if (S.length > 0) {
      const { oldRange: f, newRange: m } = this._moveCriteria(e, r, S, -g);
      w = m, u.push(...f.redos), d.unshift(...f.undos);
    }
    if (h === l - o + 1) {
      const f = {
        unitId: e,
        subUnitId: r
      };
      u.push({ id: y.id, params: f }), d.unshift({ id: R.id, params: { range: s, unitId: e, subUnitId: r } });
    } else {
      const f = o <= a ? o : h === 0 ? o - g : a, m = o <= a ? l - h : l - g, v = {
        unitId: e,
        subUnitId: r,
        range: { ...s, startColumn: f, endColumn: m }
      };
      u.push({ id: R.id, params: v }), d.unshift({ id: R.id, params: { range: s, unitId: e, subUnitId: r } }), u.push(...w.redos), d.unshift(...w.undos);
    }
    return {
      undos: d,
      redos: u
    };
  }
  _handleRemoveRowCommand(t, e, r) {
    var S;
    const n = this._sheetsFilterService.getFilterModel(e, r);
    if (!n)
      return this._handleNull();
    const s = n.getRange(), { startRow: o, endRow: l } = s, { startRow: a, endRow: c } = t.range;
    if (a > l)
      return this._handleNull();
    if (c < o)
      return {
        undos: [{ id: R.id, params: { range: s, unitId: e, subUnitId: r } }],
        redos: [{
          id: R.id,
          params: {
            range: {
              ...s,
              startRow: o - (c - a + 1),
              endRow: l - (c - a + 1)
            },
            unitId: e,
            subUnitId: r
          }
        }]
      };
    const u = [], d = [], h = n.getAllFilterColumns(), g = o <= c && o >= a;
    d.push({ id: R.id, params: { range: s, unitId: e, subUnitId: r } });
    const _ = Math.min(c, l) - Math.max(a, o) + 1;
    if (_ === l - o + 1 || g) {
      const w = {
        unitId: e,
        subUnitId: r
      };
      u.push({ id: y.id, params: w }), h.forEach((F) => {
        const [f, m] = F, v = {
          unitId: e,
          subUnitId: r,
          col: f,
          criteria: { ...m.serialize(), colId: f }
        };
        d.push({ id: p.id, params: v });
      });
    } else {
      const w = (S = this._univerInstanceService.getUniverSheetInstance(e)) == null ? void 0 : S.getSheetBySheetId(r);
      if (!w)
        return this._handleNull();
      const F = [];
      for (let E = a; E <= c; E++)
        w.getRowFiltered(E) && F.push(E);
      const f = Math.min(o, a), m = f + (l - o) - _ + F.length, v = {
        unitId: e,
        subUnitId: r,
        range: {
          ...s,
          startRow: f,
          endRow: m
        }
      };
      u.push({ id: R.id, params: v });
    }
    return {
      undos: L(d),
      redos: L(u)
    };
  }
  // eslint-disable-next-line max-lines-per-function
  handleMoveColsCommand({ fromRange: t, toRange: e }, r, n) {
    var F;
    const s = this._sheetsFilterService.getFilterModel(r, n), o = (F = s == null ? void 0 : s.getRange()) != null ? F : null;
    if (!s || !o)
      return this._handleNull();
    const { startColumn: l, endColumn: a } = o;
    if (t.endColumn < l && e.startColumn <= l || t.startColumn > a && e.endColumn > a)
      return this._handleNull();
    const c = [], u = [], d = {};
    for (let f = l; f <= a; f++)
      d[f] = {
        colIndex: f,
        filter: s.getFilterColumn(f)
      };
    oe(t.startColumn, t.endColumn - t.startColumn + 1, e.startColumn, d);
    let h = o.startColumn, g = o.endColumn;
    l >= t.startColumn && l <= t.endColumn && e.startColumn > t.startColumn && t.endColumn < a && (h = t.endColumn + 1), a >= t.startColumn && a <= t.endColumn && e.startColumn < t.startColumn && t.startColumn > l && (g = t.startColumn - 1);
    const _ = Object.keys(d).map((f) => Number(f)), S = _.find((f) => d[f].colIndex === g), w = _.find((f) => d[f].colIndex === h);
    if (_.forEach((f) => {
      var re, ne;
      const { colIndex: m, filter: v } = d[f], E = f;
      if (v) {
        if (E >= w && E <= S) {
          const Z = {
            unitId: r,
            subUnitId: n,
            col: E,
            criteria: { ...v.serialize(), colId: E }
          }, xe = {
            unitId: r,
            subUnitId: n,
            col: E,
            criteria: s.getFilterColumn(E) ? { ...(re = s.getFilterColumn(E)) == null ? void 0 : re.serialize(), colId: E } : null
          };
          c.push({ id: p.id, params: Z }), u.push({ id: p.id, params: xe });
        }
        if (!((ne = d[m]) != null && ne.filter)) {
          const Z = {
            unitId: r,
            subUnitId: n,
            col: m,
            criteria: null
          };
          c.push({ id: p.id, params: Z }), u.push({ id: p.id, params: { unitId: r, subUnitId: n, col: m, criteria: { ...v.serialize(), colId: m } } });
        }
      }
    }), l !== w || a !== S) {
      const f = {
        unitId: r,
        subUnitId: n,
        range: {
          ...o,
          startColumn: w,
          endColumn: S
        }
      };
      c.unshift({ id: R.id, params: f }), u.unshift({ id: R.id, params: { range: o, unitId: r, subUnitId: n } });
    }
    return {
      undos: u,
      redos: c
    };
  }
  _handleMoveRowsCommand(t, e, r) {
    var f;
    const n = this._sheetsFilterService.getFilterModel(e, r), s = (f = n == null ? void 0 : n.getRange()) != null ? f : null;
    if (!n || !s)
      return this._handleNull();
    const { startRow: o, endRow: l } = s, { fromRange: a, toRange: c } = t;
    if (a.endRow < o && c.startRow <= o || a.startRow > l && c.endRow > l)
      return this._handleNull();
    const u = [], d = [], h = {};
    for (let m = o; m <= l; m++)
      h[m] = {
        oldIndex: m
      };
    const g = o;
    let _ = l;
    l >= a.startRow && l <= a.endRow && c.startRow < a.startRow && a.startRow > o && (_ = a.startRow - 1), oe(a.startRow, a.endRow - a.startRow + 1, c.startRow, h);
    const S = Object.keys(h).map((m) => Number(m)), w = S.find((m) => h[m].oldIndex === _), F = S.find((m) => h[m].oldIndex === g);
    if (o !== F || l !== w) {
      const m = {
        unitId: e,
        subUnitId: r,
        range: {
          ...s,
          startRow: F,
          endRow: w
        }
      };
      u.push({ id: R.id, params: m }, { id: B.id, params: { unitId: e, subUnitId: r } }), d.push({ id: R.id, params: { range: s, unitId: e, subUnitId: r } }, { id: B.id, params: { unitId: e, subUnitId: r } });
    }
    return {
      redos: u,
      undos: d
    };
  }
  _handleMoveRangeCommand(t, e, r) {
    const { fromRange: n, toRange: s } = t, o = this._sheetsFilterService.getFilterModel(e, r);
    if (!o)
      return this._handleNull();
    const l = o.getRange();
    if (!l)
      return this._handleNull();
    const a = [], c = [];
    if (te.contains(n, l)) {
      const u = l.startRow - n.startRow, d = l.startColumn - n.startColumn, h = {
        startRow: s.startRow + u,
        startColumn: s.startColumn + d,
        endRow: s.startRow + u + (l.endRow - l.startRow),
        endColumn: s.startColumn + d + (l.endColumn - l.startColumn)
      }, g = {
        id: y.id,
        params: {
          unitId: e,
          subUnitId: r
        }
      }, _ = { id: R.id, params: { unitId: e, subUnitId: r, range: h } }, S = { id: R.id, params: { unitId: e, subUnitId: r, range: l } };
      a.push(g, _), c.push(g, S);
      const w = o.getAllFilterColumns(), F = s.startColumn - n.startColumn;
      w.forEach((f) => {
        const [m, v] = f;
        v && (a.push({ id: p.id, params: { unitId: e, subUnitId: r, col: m + F, criteria: { ...v.serialize(), colId: m + F } } }), c.push({ id: p.id, params: { unitId: e, subUnitId: r, col: m, criteria: { ...v.serialize(), colId: m } } }));
      });
    } else if (te.intersects(s, l)) {
      const u = {
        ...l,
        endRow: Math.max(l.endRow, s.endRow)
      };
      a.push({ id: R.id, params: { unitId: e, subUnitId: r, range: u } }), c.push({ id: R.id, params: { unitId: e, subUnitId: r, range: l } });
    }
    return {
      redos: a,
      undos: c
    };
  }
  _handleRemoveSheetCommand(t, e, r) {
    const n = this._sheetsFilterService.getFilterModel(e, r);
    if (!n)
      return this._handleNull();
    const s = n.getRange();
    if (!s)
      return this._handleNull();
    const o = [], l = [];
    return n.getAllFilterColumns().forEach(([c, u]) => {
      l.push({ id: p.id, params: { unitId: e, subUnitId: r, col: c, criteria: { ...u.serialize(), colId: c } } });
    }), o.push({ id: y.id, params: { unitId: e, subUnitId: r, range: s } }), l.unshift({ id: R.id, params: { range: s, unitId: e, subUnitId: r } }), {
      undos: l,
      redos: o
    };
  }
  _handleCopySheetCommand(t, e, r) {
    const n = this._sheetsFilterService.getFilterModel(t, e);
    if (!n)
      return this._handleNull();
    const s = n.getRange();
    if (!s)
      return this._handleNull();
    const o = [], l = [], a = [], c = [];
    return n.getAllFilterColumns().forEach(([d, h]) => {
      o.push({ id: p.id, params: { unitId: t, subUnitId: r, col: d, criteria: { ...h.serialize(), colId: d } } }), a.push({ id: p.id, params: { unitId: t, subUnitId: r, col: d, criteria: null } });
    }), a.push({ id: y.id, params: { unitId: t, subUnitId: r, range: s } }), o.unshift({ id: R.id, params: { range: s, unitId: t, subUnitId: r } }), {
      undos: l,
      redos: o,
      preUndos: a,
      preRedos: c
    };
  }
  _handleNull() {
    return { redos: [], undos: [] };
  }
  _initRowFilteredInterceptor() {
    this.disposeWithMe(this._sheetInterceptorService.intercept(et.ROW_FILTERED, {
      // sheet-interceptor.service.ts
      handler: (t, e) => {
        var r, n;
        return t ? !0 : (n = (r = this._sheetsFilterService.getFilterModel(
          e.unitId,
          e.subUnitId
        )) == null ? void 0 : r.isRowFiltered(e.row)) != null ? n : !1;
      }
    }));
  }
  _moveCriteria(t, e, r, n) {
    const s = {
      unitId: t,
      subUnitId: e,
      criteria: null,
      col: -1
    }, o = [], l = [], a = [], c = [];
    return r.forEach((u) => {
      const [d, h] = u;
      l.push({
        id: p.id,
        params: {
          ...s,
          col: d
        }
      }), o.push({
        id: p.id,
        params: {
          ...s,
          col: d,
          criteria: { ...h.serialize(), colId: d }
        }
      });
    }), r.forEach((u) => {
      const [d, h] = u;
      c.push({
        id: p.id,
        params: {
          ...s,
          col: d + n,
          criteria: { ...h.serialize(), colId: d + n }
        }
      }), a.push({
        id: p.id,
        params: {
          ...s,
          col: d + n,
          criteria: null
        }
      });
    }), {
      newRange: {
        redos: c,
        undos: a
      },
      oldRange: {
        redos: l,
        undos: o
      }
    };
  }
  _commandExecutedListener() {
    this.disposeWithMe(this._commandService.onCommandExecuted((t, e) => {
      var c, u;
      const { unitId: r, subUnitId: n } = t.params || {}, s = this._sheetsFilterService.getFilterModel(r, n);
      if (!s) return;
      const o = Array.from(s.filteredOutRows).sort((d, h) => d - h), l = [];
      let a = !1;
      if (t.id === tt.id) {
        const { startRow: d, endRow: h } = t.params.range, g = o.filter((_) => _ >= d && _ <= h);
        o.forEach((_) => {
          if (_ < d)
            l.push(_);
          else if (a = !0, _ <= h) {
            const S = Math.max(d, l.length ? l[l.length - 1] + 1 : d);
            l.push(S);
          } else
            l.push(_ - (h - d + 1 - g.length));
        });
      }
      if (t.id === rt.id) {
        const { startRow: d, endRow: h } = t.params.range;
        o.forEach((g) => {
          g >= d ? (a = !0, l.push(g + (h - d + 1))) : l.push(g);
        });
      }
      if (a && (s.filteredOutRows = new Set(l)), t.id === nt.id && !(e != null && e.onlyLocal)) {
        const d = this._getExtendRegion(r, n);
        if (d) {
          const h = t.params.cellValue;
          if (h)
            for (let g = d.startColumn; g <= d.endColumn; g++) {
              const _ = (c = h == null ? void 0 : h[d.startRow]) == null ? void 0 : c[g];
              if (_ && this._cellHasValue(_)) {
                const S = (u = this._univerInstanceService.getUnit(r)) == null ? void 0 : u.getSheetBySheetId(n);
                if (S) {
                  const w = Ce(d, { down: !0 }, S), F = this._sheetsFilterService.getFilterModel(r, n), f = F.getRange();
                  F.setRange({
                    ...f,
                    endRow: w.endRow
                  }), this._registerRefRange(r, n);
                }
              }
            }
        }
      }
    }));
  }
  _getExtendRegion(t, e) {
    var a;
    const r = this._sheetsFilterService.getFilterModel(t, e);
    if (!r)
      return null;
    const n = (a = this._univerInstanceService.getUnit(t)) == null ? void 0 : a.getSheetBySheetId(e);
    if (!n)
      return null;
    const s = r.getRange();
    if (!s)
      return null;
    const o = n.getRowCount() - 1, l = n.getRowManager();
    for (let c = s.endRow + 1; c <= o; c++)
      if (l.getRowRawVisible(c))
        return {
          startRow: c,
          endRow: c,
          startColumn: s.startColumn,
          endColumn: s.endColumn
        };
    return null;
  }
  _initErrorHandling() {
    this.disposeWithMe(this._commandService.beforeCommandExecuted((t) => {
      const e = t.params, r = H(this._univerInstanceService);
      if (!r) return;
      const { subUnitId: n, unitId: s } = r, o = this._sheetsFilterService.getFilterModel(s, n);
      if (!o) return;
      const l = o.getRange();
      if (t.id === it.id && e.fromRange.startRow <= l.startRow && e.fromRange.endRow < l.endRow && e.fromRange.endRow >= l.startRow)
        throw this._sheetsFilterService.setFilterErrorMsg("sheets-filter.msg.filter-header-forbidden"), new Error("[SheetsFilterController]: Cannot move header row of filter");
    }));
  }
  _cellHasValue(t) {
    const e = Object.values(t);
    return !(e.length === 0 || e.every((r) => r == null));
  }
};
z = qt([
  x(0, N),
  x(1, A(Qe)),
  x(2, A(M)),
  x(3, T),
  x(4, A(Je)),
  x(5, He(gt)),
  x(6, A(Ze))
], z);
var Gt = Object.getOwnPropertyDescriptor, Qt = (i, t, e, r) => {
  for (var n = r > 1 ? void 0 : r ? Gt(t, e) : t, s = i.length - 1, o; s >= 0; s--)
    (o = i[s]) && (n = o(n) || n);
  return n;
}, ee = (i, t) => (e, r) => t(e, r, i);
const Jt = [
  p.id,
  B.id
], Zt = [
  Re.id,
  pe.id,
  Se.id
];
let G = class extends U {
  constructor(t, e, r) {
    var s;
    super();
    C(this, "_d", new ge());
    C(this, "_visible$", new $(!1));
    C(this, "visible$", this._visible$.asObservable());
    C(this, "_enabled$", new $(!0));
    C(this, "enabled$", this._enabled$.asObservable());
    this._sheetsFilterController = t, this._commandService = e, this._configService = r;
    const n = this._configService.getConfig(Ie);
    n != null && n.enableSyncSwitch && (this._visible$.next(!0), typeof n.enableSyncSwitch == "object" && this.setEnabled((s = n.enableSyncSwitch.defaultValue) != null ? s : !0));
  }
  get visible() {
    return this._visible$.getValue();
  }
  get enabled() {
    return this._enabled$.getValue();
  }
  setEnabled(t) {
    this._enabled$.next(t), t ? this._d.dispose() : this._initOnlyLocalListener();
  }
  _initOnlyLocalListener() {
    this._d.add(
      this._commandService.beforeCommandExecuted((t, e) => {
        Jt.includes(t.id) && (e || (e = {}), e.onlyLocal = !0);
      })
    ), this._d.add(
      this._commandService.onCommandExecuted((t, e) => {
        if (Zt.includes(t.id) && (e != null && e.fromCollab)) {
          if (t.id === Re.id) {
            const { range: r, unitId: n, subUnitId: s } = t.params, { redos: o } = this._sheetsFilterController.handleInsertColCommand(r, n, s);
            j(o, this._commandService, e);
          } else if (t.id === pe.id) {
            const { range: r, unitId: n, subUnitId: s } = t.params, { redos: o } = this._sheetsFilterController.handleRemoveColCommand(r, n, s);
            j(o, this._commandService, e);
          } else if (t.id === Se.id) {
            const { sourceRange: r, targetRange: n, unitId: s, subUnitId: o } = t.params, { redos: l } = this._sheetsFilterController.handleMoveColsCommand({ fromRange: r, toRange: n }, s, o);
            j(l, this._commandService, e);
          }
        }
      })
    );
  }
};
G = Qt([
  ee(0, A(z)),
  ee(1, N),
  ee(2, _e)
], G);
var Kt = Object.getOwnPropertyDescriptor, Yt = (i, t, e, r) => {
  for (var n = r > 1 ? void 0 : r ? Kt(t, e) : t, s = i.length - 1, o; s >= 0; s--)
    (o = i[s]) && (n = o(n) || n);
  return n;
}, V = (i, t) => (e, r) => t(e, r, i);
let Q = class extends U {
  constructor(i, t, e, r) {
    super(), this._activeDirtyManagerService = i, this._sheetRowFilteredService = t, this._sheetsFilterService = e, this._univerInstanceService = r, this._initFormulaDirtyRange(), this._registerSheetRowFiltered();
  }
  _initFormulaDirtyRange() {
    Ee.forEach((i) => {
      this._activeDirtyManagerService.register(
        i,
        {
          commandId: i,
          getDirtyData: (t) => {
            const e = t.params, { unitId: r, subUnitId: n } = e;
            return {
              dirtyRanges: this._getHideRowMutation(r, n),
              clearDependencyTreeCache: {
                [r]: {
                  [n]: "1"
                }
              }
            };
          }
        }
      );
    });
  }
  _getHideRowMutation(i, t) {
    var l, a;
    const e = (l = this._sheetsFilterService.getFilterModel(i, t)) == null ? void 0 : l.getRange(), r = (a = this._univerInstanceService.getUnit(i)) == null ? void 0 : a.getSheetBySheetId(t);
    if (e == null || r == null)
      return [];
    const { startRow: n, endRow: s } = e;
    return [{
      unitId: i,
      sheetId: t,
      range: {
        startRow: n,
        startColumn: 0,
        endRow: s,
        endColumn: r.getColumnCount() - 1
      }
    }];
  }
  _registerSheetRowFiltered() {
    this._sheetRowFilteredService.register((i, t, e) => {
      var r, n;
      return (n = (r = this._sheetsFilterService.getFilterModel(i, t)) == null ? void 0 : r.isRowFiltered(e)) != null ? n : !1;
    });
  }
};
Q = Yt([
  V(0, A(_t)),
  V(1, A(Ct)),
  V(2, A(M)),
  V(3, T)
], Q);
var Xt = Object.getOwnPropertyDescriptor, er = (i, t, e, r) => {
  for (var n = r > 1 ? void 0 : r ? Xt(t, e) : t, s = i.length - 1, o; s >= 0; s--)
    (o = i[s]) && (n = o(n) || n);
  return n;
}, he = (i, t) => (e, r) => t(e, r, i), W;
let fe = (W = class extends Ve {
  constructor(i = ue, t, e) {
    super(), this._config = i, this._injector = t, this._configService = e;
    const { ...r } = We(
      {},
      ue,
      this._config
    );
    this._configService.setConfig(Ie, r);
  }
  onStarting() {
    [
      [Q],
      [M],
      [z],
      [G]
    ].forEach((i) => this._injector.add(i));
  }
  onReady() {
    je(this._injector, [
      [Q],
      [z],
      [G]
    ]);
  }
}, C(W, "type", D.UNIVER_SHEET), C(W, "pluginName", Ne), W);
fe = er([
  he(1, A(ke)),
  he(2, _e)
], fe);
export {
  dr as ClearSheetsFilterCriteriaCommand,
  I as CustomFilterOperator,
  Ee as FILTER_MUTATIONS,
  b as FilterBy,
  yt as FilterColumn,
  q as FilterModel,
  ur as ReCalcSheetsFilterCommand,
  B as ReCalcSheetsFilterMutation,
  zt as RemoveSheetFilterCommand,
  y as RemoveSheetsFilterMutation,
  Ne as SHEET_FILTER_SNAPSHOT_ID,
  Bt as SetSheetFilterRangeCommand,
  cr as SetSheetsFilterCriteriaCommand,
  p as SetSheetsFilterCriteriaMutation,
  R as SetSheetsFilterRangeMutation,
  M as SheetsFilterService,
  G as SheetsFilterSyncController,
  ar as SmartToggleSheetsFilterCommand,
  fe as UniverSheetsFilterPlugin,
  wt as equals,
  ae as getCustomFilterFn,
  Rt as greaterThan,
  pt as greaterThanOrEqualTo,
  St as lessThan,
  Ft as lessThanOrEqualTo,
  Oe as notEquals
};
