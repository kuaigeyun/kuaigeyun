import { Observable, BehaviorSubject } from 'rxjs';
import { IAccessor, IDisposable } from '../../common/di';
import { Nullable } from '../../shared/types';
import { IMutationInfo, CommandType, ICommandService } from '../command/command.service';
import { Disposable } from '../../shared/lifecycle';
import { IContextService } from '../context/context.service';
import { IUniverInstanceService } from '../instance/instance.service';
export interface IUndoRedoItem {
    /** unitID maps to unitId for UniverSheet / UniverDoc / UniverSlide */
    unitID: string;
    undoMutations: IMutationInfo[];
    redoMutations: IMutationInfo[];
    /**
     * sometimes we need an id to mark the undo-redo item
     */
    id?: string;
}
export interface IUndoRedoService {
    undoRedoStatus$: Observable<IUndoRedoStatus>;
    pushUndoRedo(item: IUndoRedoItem): void;
    /** Pitch the top redo element of the currently focused Univer document instance. */
    pitchTopUndoElement(): Nullable<IUndoRedoItem>;
    /** Pitch the top undo element of the currently focused Univer document instance. */
    pitchTopRedoElement(): Nullable<IUndoRedoItem>;
    popUndoToRedo(): void;
    popRedoToUndo(): void;
    rollback(id: string, unitId?: string): void;
    clearUndoRedo(unitId: string): void;
    /**
     * Batch undo redo elements into a single `IUndoRedoItem` util the returned `IDisposable` is called.
     *
     * @deprecated This is a temporary solution. We are going to refactor the undo redo service shortly.
     * @returns a disposable to cancel batching undo redo elements
     */
    __tempBatchingUndoRedo(unitId: string): IDisposable;
}
export interface IUndoRedoCommandBaseInfosByInterceptor {
    undos: IMutationInfo[];
    redos: IMutationInfo[];
}
export interface IUndoRedoCommandInfosByInterceptor extends IUndoRedoCommandBaseInfosByInterceptor {
    /**
     * Sometimes, mutations generated by interceptors need to ensure a certain execution order
     * PreMutations run before user's intent to make sure the undo/redo works correctly.
     */
    preUndos?: IMutationInfo[];
    preRedos?: IMutationInfo[];
}
export interface IUndoRedoCommandInfos {
    undos: IMutationInfo[];
    redos: IMutationInfo[];
}
export declare const IUndoRedoService: import('@wendellhu/redi').IdentifierDecorator<IUndoRedoService>;
export interface IUndoRedoStatus {
    undos: number;
    redos: number;
}
export declare const RedoCommandId = "univer.command.redo";
export declare const UndoCommandId = "univer.command.undo";
export declare const UndoCommand: {
    readonly type: CommandType.COMMAND;
    readonly id: "univer.command.undo";
    handler(accessor: IAccessor): boolean;
    dispose(): void;
    dispatchToHandlers(): Promise<boolean>;
};
export declare const RedoCommand: {
    readonly type: CommandType.COMMAND;
    readonly id: "univer.command.redo";
    handler(accessor: IAccessor): boolean;
    dispose(): void;
    dispatchToHandlers(): Promise<boolean>;
};
/**
 * This UndoRedoService is local.
 */
export declare class LocalUndoRedoService extends Disposable implements IUndoRedoService {
    protected readonly _univerInstanceService: IUniverInstanceService;
    protected readonly _commandService: ICommandService;
    private readonly _contextService;
    readonly undoRedoStatus$: Observable<IUndoRedoStatus>;
    protected readonly _undoRedoStatus$: BehaviorSubject<{
        undos: number;
        redos: number;
    }>;
    protected readonly _undoStacks: Map<string, IUndoRedoItem[]>;
    protected readonly _redoStacks: Map<string, IUndoRedoItem[]>;
    private _batchingStatus;
    constructor(_univerInstanceService: IUniverInstanceService, _commandService: ICommandService, _contextService: IContextService);
    pushUndoRedo(item: IUndoRedoItem): void;
    clearUndoRedo(unitID: string): void;
    pitchTopUndoElement(): Nullable<IUndoRedoItem>;
    pitchTopRedoElement(): Nullable<IUndoRedoItem>;
    private _pitchUndoElement;
    private _pitchRedoElement;
    popUndoToRedo(): void;
    popRedoToUndo(): void;
    rollback(id: string, unitID?: string): void;
    __tempBatchingUndoRedo(unitId: string): IDisposable;
    protected _updateStatus(): void;
    protected _getUndoStack(unitId: string): IUndoRedoItem[] | null;
    protected _getUndoStack(unitId: string, createAsNeeded: true): IUndoRedoItem[];
    protected _getRedoStack(unitId: string): IUndoRedoItem[] | null;
    protected _getRedoStack(unitId: string, createAsNeeded: true): IUndoRedoItem[];
    protected _getUndoStackForFocused(): IUndoRedoItem[];
    protected _getRedoStackForFocused(): IUndoRedoItem[];
    private _tryBatchingElements;
    private _getFocusedUnitId;
}
