var st = Object.defineProperty;
var rt = (t, e, n) => e in t ? st(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var b = (t, e, n) => rt(t, typeof e != "symbol" ? e + "" : e, n);
import { CellValueType as J, BorderStyleTypes as at, createREGEXFromWildChar as Z, generateRandomId as L, IUniverInstanceService as B, Inject as _, LocaleService as be, Disposable as H, CommandType as N, IUndoRedoService as A, ICommandService as D, sequenceExecute as E, ILogService as Le, IResourceManagerService as ot, Rectangle as Re, RTree as it, InterceptorEffectEnum as lt, UniverInstanceType as z, customNameCharacterCheck as ut, Injector as We, IConfigService as He, Plugin as ct, merge as dt, registerDependencies as ht, touchDependencies as Me } from "@univerjs/core";
import { getSheetCommandTarget as $, SheetInterceptorService as Ce, INTERCEPTOR_POINT as Ve, RemoveSheetCommand as gt, CopySheetCommand as mt, AddRangeThemeMutation as Pe, RemoveRangeThemeMutation as qe, SheetRangeThemeModel as Je, SheetsSelectionsService as we, InsertRowMutation as ke, RemoveRowMutation as Qe, getMoveRangeUndoRedoMutations as fe, InsertColMutation as Ye, RemoveColMutation as Ge, IExclusiveRangeService as bt, RefRangeService as wt, RemoveColCommand as ft, RemoveRowCommand as pt, InsertColCommand as St, InsertRowCommand as Rt, SheetRangeThemeService as _t, RangeThemeStyle as Ct, ZebraCrossingCacheController as Tt } from "@univerjs/sheets";
import { Subject as Y, BehaviorSubject as ze, filter as pe, switchMap as ve } from "rxjs";
import { RemoveSuperTableMutation as Fe, SetSuperTableMutation as It } from "@univerjs/engine-formula";
var M = /* @__PURE__ */ ((t) => (t.Insert = "insert", t.Delete = "delete", t))(M || {}), y = /* @__PURE__ */ ((t) => (t.Row = "row", t.Col = "column", t))(y || {}), je = /* @__PURE__ */ ((t) => (t.None = "none", t.String = "string", t.Number = "number", t.Date = "date", t.Bool = "bool", t.Checkbox = "checkbox", t.List = "list", t))(je || {}), ne = /* @__PURE__ */ ((t) => (t.manual = "manual", t.condition = "condition", t))(ne || {}), O = /* @__PURE__ */ ((t) => (t.Date = "date", t.Number = "number", t.String = "string", t.Logic = "logic", t))(O || {}), F = /* @__PURE__ */ ((t) => (t.Equal = "equal", t.NotEqual = "notEqual", t.GreaterThan = "greaterThan", t.GreaterThanOrEqual = "greaterThanOrEqual", t.LessThan = "lessThan", t.LessThanOrEqual = "lessThanOrEqual", t.Between = "between", t.NotBetween = "notBetween", t.Above = "above", t.Below = "below", t.TopN = "topN", t))(F || {}), P = /* @__PURE__ */ ((t) => (t.Equal = "equal", t.NotEqual = "notEqual", t.Contains = "contains", t.NotContains = "notContains", t.StartsWith = "startsWith", t.EndsWith = "endsWith", t))(P || {}), m = /* @__PURE__ */ ((t) => (t.Equal = "equal", t.NotEqual = "notEqual", t.After = "after", t.AfterOrEqual = "afterOrEqual", t.Before = "before", t.BeforeOrEqual = "beforeOrEqual", t.Between = "between", t.NotBetween = "notBetween", t.Today = "today", t.Yesterday = "yesterday", t.Tomorrow = "tomorrow", t.ThisWeek = "thisWeek", t.LastWeek = "lastWeek", t.NextWeek = "nextWeek", t.ThisMonth = "thisMonth", t.LastMonth = "lastMonth", t.NextMonth = "nextMonth", t.ThisQuarter = "thisQuarter", t.LastQuarter = "lastQuarter", t.NextQuarter = "nextQuarter", t.ThisYear = "thisYear", t.LastYear = "lastYear", t.NextYear = "nextYear", t.YearToDate = "yearToDate", t.Quarter = "quarter", t.Month = "month", t.M1 = "m1", t.M2 = "m2", t.M3 = "m3", t.M4 = "m4", t.M5 = "m5", t.M6 = "m6", t.M7 = "m7", t.M8 = "m8", t.M9 = "m9", t.M10 = "m10", t.M11 = "m11", t.M12 = "m12", t.Q1 = "q1", t.Q2 = "q2", t.Q3 = "q3", t.Q4 = "q4", t))(m || {}), q = /* @__PURE__ */ ((t) => (t[t.FilteredSortNone = 1] = "FilteredSortNone", t[t.FilteredSortAsc = 2] = "FilteredSortAsc", t[t.FilteredSortDesc = 3] = "FilteredSortDesc", t[t.FilterNoneSortNone = 4] = "FilterNoneSortNone", t[t.FilterNoneSortAsc = 5] = "FilterNoneSortAsc", t[t.FilterNoneSortDesc = 6] = "FilterNoneSortDesc", t))(q || {}), G = /* @__PURE__ */ ((t) => (t.Asc = "asc", t.Desc = "desc", t.None = "none", t))(G || {});
function te(t, e) {
  return `${e} ${t}`;
}
const ye = "TRUE", Ne = "FALSE", Mt = (t) => {
  var n;
  return ((n = t.body) == null ? void 0 : n.dataStream.replace(/\r\n$/, "")) || "";
};
function Ke(t) {
  if (t) {
    const { v: e, t: n, p: s } = t;
    return s ? Mt(s) : (n === J.FORCE_STRING || n === J.STRING) && e !== void 0 && e !== null ? String(e) : n === J.BOOLEAN ? e ? ye : Ne : n === J.NUMBER ? String(e) : typeof e === "boolean" ? e ? ye : Ne : e == null ? "" : String(e);
  }
  return "";
}
function vt(t, e) {
  if (t != null)
    switch (e) {
      case G.Asc:
        return q.FilteredSortAsc;
      case G.Desc:
        return q.FilteredSortDesc;
      default:
        return q.FilteredSortNone;
    }
  else
    switch (e) {
      case G.Asc:
        return q.FilterNoneSortAsc;
      case G.Desc:
        return q.FilterNoneSortDesc;
      default:
        return q.FilterNoneSortNone;
    }
}
function Ft(t) {
  return t ? t.filterType === ne.condition : !1;
}
function ds(t) {
  return t ? t.filterType === ne.manual : !1;
}
const x = {
  s: at.THIN,
  cl: {
    rgb: "rgb(95, 101, 116)"
  }
}, Xe = "sheets-table.config", De = {}, hs = {
  headerRowStyle: {
    bd: {
      t: x
    }
  },
  headerColumnStyle: {
    bd: {
      l: x
    }
  },
  lastColumnStyle: {
    bd: {
      r: x
    }
  },
  lastRowStyle: {
    bd: {
      b: x
    }
  }
}, gs = (t, e) => {
  if (t === "headerRowStyle") {
    if (!e.bd)
      return {
        ...e,
        bd: {
          t: x
        }
      };
  } else if (t === "lastRowStyle") {
    if (!e.bd)
      return {
        ...e,
        bd: {
          b: x
        }
      };
  } else if (t === "lastColumnStyle") {
    if (!e.bd)
      return {
        ...e,
        bd: {
          r: x
        }
      };
  } else if (t === "headerColumnStyle" && !e.bd)
    return {
      ...e,
      bd: {
        l: x
      }
    };
  return e;
}, yt = [
  [["#6280F9", "#FFFFFF", "#BAC6F8", "#D2DAFA"], ["#fff"]],
  [["#16BDCA", "#FFFFFF", "#EDFAFA", "#AFECEF"], ["#000"]],
  [["#31C48D", "#FFFFFF", "#F3FAF7", "#BCF0DA"], ["#fff"]],
  [["#AC94FA", "#FFFFFF", "#F6F5FF", "#EDEBFE"], ["#fff"]],
  [["#F17EBB", "#FFFFFF", "#FDF2F8", "#FCE8F3"], ["#fff"]],
  [["#F98080", "#FFFFFF", "#FDF2F2", "#FDE8E8"], ["#fff"]]
], Ze = yt.map((t, e) => {
  const [n, s] = t, [r, a, o, u] = n, [l] = s;
  return {
    name: `table-default-${e}`,
    style: {
      headerRowStyle: {
        bg: {
          rgb: r
        },
        cl: {
          rgb: l
        },
        bd: {
          t: x
        }
      },
      headerColumnStyle: {
        bd: {
          l: x
        }
      },
      firstRowStyle: {
        bg: {
          rgb: a
        }
      },
      secondRowStyle: {
        bg: {
          rgb: o
        }
      },
      lastRowStyle: {
        bg: {
          rgb: u
        },
        bd: {
          b: x
        }
      },
      lastColumnStyle: {
        bd: {
          r: x
        }
      }
    }
  };
});
class j {
  constructor(e, n) {
    b(this, "dataType");
    b(this, "id");
    b(this, "displayName");
    b(this, "formula");
    b(this, "meta");
    b(this, "style");
    this.id = e, this.displayName = n, this.dataType = je.String, this.formula = "", this.meta = {}, this.style = {};
  }
  getMeta() {
    return this.meta;
  }
  setMeta(e) {
    this.meta = e;
  }
  getDisplayName() {
    return this.displayName;
  }
  toJSON() {
    return {
      id: this.id,
      displayName: this.displayName,
      dataType: this.dataType,
      formula: this.formula,
      meta: this.meta,
      style: this.style
    };
  }
  fromJSON(e) {
    this.id = e.id, this.displayName = e.displayName, this.dataType = e.dataType, this.formula = e.formula, this.meta = e.meta, this.style = e.style;
  }
}
const Nt = (t) => t.getMonth() <= 2, Dt = (t) => {
  const e = t.getMonth();
  return e > 2 && e <= 5;
}, xt = (t) => {
  const e = t.getMonth();
  return e > 5 && e <= 8;
}, Ot = (t) => {
  const e = t.getMonth();
  return e > 8 && e <= 11;
}, Ut = (t) => t.getMonth() === 0, $t = (t) => t.getMonth() === 1, At = (t) => t.getMonth() === 2, Bt = (t) => t.getMonth() === 3, Et = (t) => t.getMonth() === 4, Lt = (t) => t.getMonth() === 5, Wt = (t) => t.getMonth() === 6, Ht = (t) => t.getMonth() === 7, Vt = (t) => t.getMonth() === 8, Pt = (t) => t.getMonth() === 9, qt = (t) => t.getMonth() === 10, Jt = (t) => t.getMonth() === 11, kt = (t, e = /* @__PURE__ */ new Date()) => t.toDateString() === e.toDateString(), Qt = (t, e = /* @__PURE__ */ new Date()) => {
  const n = new Date(e);
  return n.setDate(n.getDate() + 1), t.toDateString() === n.toDateString();
}, Yt = (t, e = /* @__PURE__ */ new Date()) => {
  const n = new Date(e);
  return n.setDate(n.getDate() - 1), t.toDateString() === n.toDateString();
}, K = (t) => {
  const e = t.getDay(), n = t.getDate() - e + (e === 0 ? -6 : 1), s = new Date(t);
  return s.setDate(n), s;
}, et = 10080 * 60 * 1e3, Gt = (t, e = /* @__PURE__ */ new Date()) => {
  const n = K(t), s = K(e);
  return n.toDateString() === s.toDateString();
}, zt = (t, e = /* @__PURE__ */ new Date()) => {
  const n = K(t), s = new Date(K(e).getTime() + et);
  return n.toDateString() === s.toDateString();
}, jt = (t, e = /* @__PURE__ */ new Date()) => {
  const n = K(t), s = new Date(K(e).getTime() - et);
  return n.toDateString() === s.toDateString();
}, Kt = (t, e = /* @__PURE__ */ new Date()) => t.getFullYear() === e.getFullYear() && t.getMonth() === e.getMonth(), Xt = (t) => {
  const e = new Date(t);
  return e.setHours(0, 0, 0, 0), e.setDate(1), e;
}, Zt = (t, e = /* @__PURE__ */ new Date()) => {
  const n = new Date(e);
  n.setHours(0, 0, 0, 0), n.setMonth(n.getMonth() + 1, 1);
  const s = new Date(n);
  s.setMonth(s.getMonth() + 1, 0);
  const r = t.getTime();
  return r >= n.getTime() && r < s.getTime();
}, en = (t, e = /* @__PURE__ */ new Date()) => {
  const n = Xt(e), s = new Date(n);
  s.setMonth(s.getMonth() + 1, 0);
  const r = t.getTime();
  return r >= n.getTime() && r < s.getTime();
}, Te = (t) => {
  const e = new Date(t);
  e.setHours(0, 0, 0, 0), e.setDate(1);
  const n = e.getMonth();
  return e.setMonth(n - n % 3), e;
}, tn = (t, e = /* @__PURE__ */ new Date()) => {
  const n = Te(e), s = new Date(n);
  s.setMonth(s.getMonth() + 3);
  const r = t.getTime();
  return r >= n.getTime() && r < s.getTime();
}, nn = (t, e = /* @__PURE__ */ new Date()) => {
  const n = Te(e), s = new Date(n);
  s.setMonth(s.getMonth() + 3);
  const r = new Date(s);
  r.setMonth(r.getMonth() + 3, 0);
  const a = t.getTime();
  return a >= s.getTime() && a < r.getTime();
}, sn = (t, e = /* @__PURE__ */ new Date()) => {
  const n = Te(e), s = new Date(n);
  s.setMonth(s.getMonth() - 3);
  const r = new Date(n);
  r.setDate(0);
  const a = t.getTime();
  return a >= s.getTime() && a < r.getTime();
}, rn = (t, e = /* @__PURE__ */ new Date()) => t.getFullYear() === e.getFullYear(), an = (t, e = /* @__PURE__ */ new Date()) => t.getFullYear() === e.getFullYear() + 1, on = (t, e = /* @__PURE__ */ new Date()) => t.getFullYear() === e.getFullYear() - 1, ln = (t, e = /* @__PURE__ */ new Date()) => {
  const n = new Date(e);
  n.setHours(0, 0, 0, 0), n.setMonth(0, 1);
  const s = t.getTime();
  return s >= n.getTime() && s < e.getTime();
};
function un(t) {
  switch (t.compareType) {
    case m.Equal: {
      const e = new Date(t.expectedValue);
      return (n) => n.getTime() === e.getTime();
    }
    case m.NotEqual: {
      const e = new Date(t.expectedValue);
      return (n) => n.getTime() !== e.getTime();
    }
    case m.After: {
      const e = new Date(t.expectedValue);
      return (n) => n.getTime() > e.getTime();
    }
    case m.Before: {
      const e = new Date(t.expectedValue);
      return (n) => n.getTime() < e.getTime();
    }
    case m.AfterOrEqual: {
      const e = new Date(t.expectedValue);
      return (n) => n.getTime() >= e.getTime();
    }
    case m.BeforeOrEqual: {
      const e = new Date(t.expectedValue);
      return (n) => n.getTime() <= e.getTime();
    }
    case m.Between:
      return (e) => {
        const [n, s] = t.expectedValue;
        return e.getTime() >= new Date(n).getTime() && e.getTime() <= new Date(s).getTime();
      };
    case m.NotBetween:
      return (e) => {
        const [n, s] = t.expectedValue;
        return e.getTime() < new Date(n).getTime() || e.getTime() > new Date(s).getTime();
      };
    case m.Today: {
      const e = t.anchorTime ? new Date(t.anchorTime) : /* @__PURE__ */ new Date();
      return (n) => kt(n, e);
    }
    case m.Yesterday: {
      const e = t.anchorTime ? new Date(t.anchorTime) : /* @__PURE__ */ new Date();
      return (n) => Yt(n, e);
    }
    case m.Tomorrow: {
      const e = t.anchorTime ? new Date(t.anchorTime) : /* @__PURE__ */ new Date();
      return (n) => Qt(n, e);
    }
    case m.ThisWeek: {
      const e = t.anchorTime ? new Date(t.anchorTime) : /* @__PURE__ */ new Date();
      return (n) => Gt(n, e);
    }
    case m.LastWeek: {
      const e = t.anchorTime ? new Date(t.anchorTime) : /* @__PURE__ */ new Date();
      return (n) => jt(n, e);
    }
    case m.NextWeek: {
      const e = t.anchorTime ? new Date(t.anchorTime) : /* @__PURE__ */ new Date();
      return (n) => zt(n, e);
    }
    case m.ThisMonth: {
      const e = t.anchorTime ? new Date(t.anchorTime) : /* @__PURE__ */ new Date();
      return (n) => Kt(n, e);
    }
    case m.LastMonth: {
      const e = t.anchorTime ? new Date(t.anchorTime) : /* @__PURE__ */ new Date();
      return (n) => en(n, e);
    }
    case m.NextMonth: {
      const e = t.anchorTime ? new Date(t.anchorTime) : /* @__PURE__ */ new Date();
      return (n) => Zt(n, e);
    }
    case m.ThisQuarter: {
      const e = t.anchorTime ? new Date(t.anchorTime) : /* @__PURE__ */ new Date();
      return (n) => tn(n, e);
    }
    case m.LastQuarter: {
      const e = t.anchorTime ? new Date(t.anchorTime) : /* @__PURE__ */ new Date();
      return (n) => sn(n, e);
    }
    case m.NextQuarter: {
      const e = t.anchorTime ? new Date(t.anchorTime) : /* @__PURE__ */ new Date();
      return (n) => nn(n, e);
    }
    case m.ThisYear: {
      const e = t.anchorTime ? new Date(t.anchorTime) : /* @__PURE__ */ new Date();
      return (n) => rn(n, e);
    }
    case m.LastYear: {
      const e = t.anchorTime ? new Date(t.anchorTime) : /* @__PURE__ */ new Date();
      return (n) => on(n, e);
    }
    case m.NextYear: {
      const e = t.anchorTime ? new Date(t.anchorTime) : /* @__PURE__ */ new Date();
      return (n) => an(n, e);
    }
    case m.YearToDate: {
      const e = t.anchorTime ? new Date(t.anchorTime) : /* @__PURE__ */ new Date();
      return (n) => ln(n, e);
    }
    case m.M1:
      return Ut;
    case m.M2:
      return $t;
    case m.M3:
      return At;
    case m.M4:
      return Bt;
    case m.M5:
      return Et;
    case m.M6:
      return Lt;
    case m.M7:
      return Wt;
    case m.M8:
      return Ht;
    case m.M9:
      return Vt;
    case m.M10:
      return Pt;
    case m.M11:
      return qt;
    case m.M12:
      return Jt;
    case m.Q1:
      return Nt;
    case m.Q2:
      return Dt;
    case m.Q3:
      return xt;
    case m.Q4:
      return Ot;
    default:
      throw new Error("Unsupported compare type");
  }
}
class cn {
  /**
   * Initializes a new instance of the Heap class.
   */
  constructor() {
    b(this, "heap");
    this.heap = [];
  }
  /**
   * Swaps the elements at the given indices in the heap.
   * @param index1 The index of the first element.
   * @param index2 The index of the second element.
   */
  swap(e, n) {
    const s = this.heap[e];
    this.heap[e] = this.heap[n], this.heap[n] = s;
  }
  /**
   * Returns the index of the parent node for the given index.
   * @param index The index of the node.
   * @returns The index of the parent node.
   */
  getParentIndex(e) {
    return Math.floor((e - 1) / 2);
  }
  /**
   * Returns the index of the left child node for the given index.
   * @param index The index of the node.
   * @returns The index of the left child node.
   */
  getLeftIndex(e) {
    return e * 2 + 1;
  }
  /**
   * Returns the index of the right child node for the given index.
   * @param index The index of the node.
   * @returns The index of the right child node.
   */
  getRightIndex(e) {
    return e * 2 + 2;
  }
  /**
   * Returns the number of elements in the heap.
   * @returns The number of elements in the heap.
   */
  size() {
    return this.heap.length;
  }
  /**
   * Returns the minimum value in the heap without removing it.
   * @returns The minimum value in the heap.
   */
  peek() {
    return this.heap[0];
  }
  /**
   * @description Returns whether the heap includes the given value.
   * @param {number} value  The value to be checked.
   * @returns {boolean} return true if the heap includes the given value
   */
  include(e) {
    return this.heap.includes(e);
  }
}
class dn extends cn {
  /**
   * Initializes a new instance of the MinHeap class.
   */
  constructor() {
    super();
  }
  /**
   * Moves the element at the given index up the heap until it satisfies the min heap property.
   * @param index The index of the element to be shifted up.
   */
  shiftUp(e) {
    if (e === 0)
      return;
    const n = this.getParentIndex(e);
    this.heap[n] > this.heap[e] && (this.swap(n, e), this.shiftUp(n));
  }
  /**
   * Moves the element at the given index down the heap until it satisfies the min heap property.
   * @param index The index of the element to be shifted down.
   */
  shiftDown(e) {
    const n = this.getLeftIndex(e), s = this.getRightIndex(e);
    this.heap[n] < this.heap[e] && (this.swap(n, e), this.shiftDown(n)), this.heap[s] < this.heap[e] && (this.swap(s, e), this.shiftDown(s));
  }
  /**
   * Inserts a new value into the min heap.
   * @param value The value to be inserted.
   */
  insert(e) {
    this.heap.push(e), this.shiftUp(this.heap.length - 1);
  }
  /**
   * Removes and returns the minimum value from the min heap.
   */
  pop() {
    this.heap[0] = this.heap.pop(), this.shiftDown(0);
  }
}
const hn = (t, e) => {
  const n = new dn();
  for (const s of t)
    n.insert(s), n.size() > e && n.pop();
  return n.heap;
}, gn = (t, e) => t > e, mn = (t, e) => t < e, bn = (t, e, n) => hn(t, e).includes(n);
function wn(t, e) {
  switch (t.compareType) {
    case F.Equal: {
      const n = Number(t.expectedValue);
      return (s) => s === n;
    }
    case F.NotEqual: {
      const n = Number(t.expectedValue);
      return (s) => s !== n;
    }
    case F.GreaterThan: {
      const n = Number(t.expectedValue);
      return (s) => s > n;
    }
    case F.GreaterThanOrEqual: {
      const n = Number(t.expectedValue);
      return (s) => s >= n;
    }
    case F.LessThan: {
      const n = Number(t.expectedValue);
      return (s) => s < n;
    }
    case F.LessThanOrEqual: {
      const n = Number(t.expectedValue);
      return (s) => s <= n;
    }
    case F.Between: {
      const [n, s] = t.expectedValue, r = Number(n), a = Number(s);
      return r > a ? (o) => o >= a && o <= r : (o) => o >= r && o <= a;
    }
    case F.NotBetween: {
      const [n, s] = t.expectedValue, r = Number(n), a = Number(s);
      return r > a ? (o) => o < a || o > r : (o) => o < r || o > a;
    }
    case F.Above: {
      const n = e.average;
      return (s) => gn(s, n);
    }
    case F.Below: {
      const n = e.average;
      return (s) => mn(s, n);
    }
    case F.TopN: {
      const n = e.list, s = Number(t.expectedValue);
      return (r) => bn(n, s, r);
    }
  }
}
const fn = (t, e) => Z(e).test(t), pn = (t, e) => !Z(e).test(t), Sn = (t, e) => Z(`*${e}*`).test(t), Rn = (t, e) => !Z(`*${e}*`).test(t), _n = (t, e) => Z(`${e}*`).test(t), Cn = (t, e) => Z(`*${e}`).test(t);
function Tn(t) {
  switch (t.compareType) {
    case P.Equal:
      return (e) => fn(e, t.expectedValue);
    case P.NotEqual:
      return (e) => pn(e, t.expectedValue);
    case P.Contains:
      return (e) => Sn(e, t.expectedValue);
    case P.NotContains:
      return (e) => Rn(e, t.expectedValue);
    case P.StartsWith:
      return (e) => _n(e, t.expectedValue);
    case P.EndsWith:
      return (e) => Cn(e, t.expectedValue);
    default:
      return console.error(`Unknown filter operator: ${t.compareType}`), (e) => !0;
  }
}
const In = /* @__PURE__ */ new Set([
  F.Above,
  F.Below,
  F.TopN
]);
m.Today, m.Yesterday, m.Tomorrow, m.ThisWeek, m.LastWeek, m.NextWeek, m.ThisMonth, m.LastMonth, m.NextMonth, m.ThisQuarter, m.LastQuarter, m.NextQuarter, m.NextYear, m.ThisYear, m.LastYear, m.YearToDate;
function tt(t) {
  return In.has(t);
}
function Mn(t, e) {
  if (tt(t.filterInfo.compareType))
    return (n) => !0;
  switch (t.filterInfo.conditionType) {
    case O.Date:
      return un(t.filterInfo);
    case O.Number:
      return wn(t.filterInfo, e);
    case O.String:
      return Tn(t.filterInfo);
    case O.Logic:
    default:
      return (n) => !0;
  }
}
function ue(t, e, n, s) {
  switch (s) {
    case O.Date: {
      const r = xe(t, e, n);
      return r ? yn(r) : null;
    }
    case O.Number:
      return xe(t, e, n);
    case O.String:
    default:
      return Fn(t, e, n);
  }
}
const vn = (t) => {
  var n;
  return ((n = t.body) == null ? void 0 : n.dataStream.replace(/\r\n$/, "")) || "";
};
function Fn(t, e, n) {
  const s = t.getCell(e, n);
  if (!s) return null;
  const { v: r, t: a, p: o } = s;
  if (o)
    return vn(o);
  if (typeof r == "string")
    return a === J.BOOLEAN ? r.toUpperCase() : r;
  if (typeof r == "number")
    return a === J.BOOLEAN ? r ? "TRUE" : "FALSE" : r;
  if (typeof r == "boolean") return r ? "TRUE" : "FALSE";
  if (r !== void 0)
    return String(r);
}
function xe(t, e, n) {
  const s = t.getCell(e, n);
  if (!s) return null;
  const { v: r, t: a, p: o } = s;
  return o ? null : typeof r == "string" && a === J.NUMBER ? Number(t.getCellRaw(e, n).v) : Number(r);
}
function yn(t) {
  const e = new Date(Date.UTC(1900, 0, 1, 0, 0, 0)), n = new Date(Date.UTC(1900, 1, 28, 0, 0, 0));
  let s = t - 1;
  return s > (n.getTime() - e.getTime()) / (1e3 * 3600 * 24) && (s -= 1), s < 0 && (s = t), new Date(e.getTime() + s * (1e3 * 3600 * 24));
}
class Oe {
  constructor() {
    b(this, "_tableColumnFilterList");
    b(this, "_tableSortInfo");
    b(this, "_filterOutRows");
    this._tableColumnFilterList = [];
  }
  setColumnFilter(e, n) {
    n ? this._tableColumnFilterList[e] = n : this._tableColumnFilterList[e] = void 0;
  }
  setSortState(e, n) {
    this._tableSortInfo = { columnIndex: e, sortState: n };
  }
  getColumnFilter(e) {
    return this._tableColumnFilterList[e];
  }
  getFilterState(e) {
    var s;
    const n = ((s = this._tableSortInfo) == null ? void 0 : s.columnIndex) === e ? this._tableSortInfo.sortState : G.None;
    return vt(this._tableColumnFilterList[e], n);
  }
  getSortState() {
    var e;
    return (e = this._tableSortInfo) != null ? e : {};
  }
  getFilterStates(e) {
    const n = [], { startColumn: s, endColumn: r } = e;
    for (let a = s; a <= r; a++)
      n.push(this.getFilterState(a - s));
    return n;
  }
  getFilterOutRows() {
    return this._filterOutRows;
  }
  doFilter(e, n) {
    const s = /* @__PURE__ */ new Set(), r = this._tableColumnFilterList;
    for (let a = 0; a < r.length; a++)
      r[a] && this.doColumnFilter(e, n, a, s);
    return this._filterOutRows = s, s;
  }
  doColumnFilter(e, n, s, r) {
    const a = this._tableColumnFilterList[s];
    if (a && e) {
      const { startRow: o, endRow: u, startColumn: l } = n, i = l + s, h = this.getExecuteFunc(e, n, s, a);
      for (let d = o; d <= u; d++) {
        const c = Ft(a) ? a.filterInfo.conditionType : O.String;
        ue(e, d, i, c) === null ? r.add(d) : h(ue(e, d, i, c)) || r.add(d);
      }
    }
  }
  _getNumberCalculatedOptions(e, n, s) {
    const { startRow: r, endRow: a, startColumn: o } = n, u = o + s, l = [];
    let i = 0, h = 0;
    for (let d = r; d <= a; d++) {
      const c = ue(e, d, u, O.Number);
      c !== null && (l.push(c), i++, h += c);
    }
    return {
      list: l,
      average: i > 0 ? h / i : 0
    };
  }
  getExecuteFunc(e, n, s, r) {
    if (r.filterType === ne.manual) {
      const a = new Set(r.values);
      return (o) => a.has(o);
    } else if (r.filterType === ne.condition) {
      const o = tt(r.filterInfo.compareType) ? this._getNumberCalculatedOptions(e, n, s) : void 0;
      return Mn(r, o);
    } else
      return (a) => !0;
  }
  toJSON() {
    return {
      tableColumnFilterList: this._tableColumnFilterList,
      tableSortInfo: this._tableSortInfo
    };
  }
  fromJSON(e) {
    var n;
    this._tableColumnFilterList = (n = e.tableColumnFilterList) != null ? n : [], e.tableSortInfo && (this._tableSortInfo = e.tableSortInfo);
  }
  dispose() {
    this._tableColumnFilterList = [];
  }
}
class Ue {
  constructor(e, n, s, r, a = {}) {
    b(this, "_id");
    b(this, "_name");
    /**
     * @property {string} tableStyleId The table style id. If the property is empty, the default style will be used.
     */
    b(this, "_tableStyleId");
    b(this, "_showHeader");
    b(this, "_showFooter");
    b(this, "_range");
    b(this, "_columns", /* @__PURE__ */ new Map());
    b(this, "_columnOrder", []);
    b(this, "tableMeta");
    b(this, "_tableFilters");
    b(this, "_subUnitId");
    this._id = e, this._range = s, this._name = n, this._tableFilters = new Oe(), this._init(r, a);
  }
  _init(e, n) {
    var o, u;
    this._tableStyleId = n == null ? void 0 : n.tableStyleId, this._showHeader = (o = n == null ? void 0 : n.showHeader) != null ? o : !0, this._showFooter = !1;
    const s = this.getRange(), r = s.startColumn, a = s.endColumn;
    for (let l = r; l <= a; l++) {
      const i = l - r;
      let h, d;
      (u = n.columns) != null && u[i] ? (h = n.columns[i].id, d = n.columns[i].displayName) : (h = L(), d = e[l - r]);
      const c = new j(h, d);
      this._columns.set(h, c), this._columnOrder.push(h);
    }
    n.filters && n.filters.forEach((i, h) => {
      i && this._tableFilters.setColumnFilter(h, i);
    });
  }
  setTableFilterColumn(e, n) {
    this._tableFilters.setColumnFilter(e, n);
  }
  getTableFilterColumn(e) {
    return this._tableFilters.getColumnFilter(e);
  }
  getTableFilters() {
    return this._tableFilters;
  }
  getTableFilterRange() {
    const e = this.getRange(), n = this.isShowHeader(), s = this.isShowFooter(), { startRow: r, startColumn: a, endRow: o, endColumn: u } = e, l = n ? r + 1 : r, i = s ? o - 1 : o;
    return {
      startRow: l,
      startColumn: a,
      endRow: i,
      endColumn: u
    };
  }
  setColumns(e) {
    this._columns.clear(), this._columnOrder = [], e.forEach((n) => {
      const s = new j(n.id, n.displayName);
      s.fromJSON(n), this._columns.set(n.id, s), this._columnOrder.push(n.id);
    });
  }
  getColumnsCount() {
    return this._columnOrder.length;
  }
  insertColumn(e, n) {
    const s = n.id;
    this._columns.set(s, n), this._columnOrder.splice(e, 0, s);
  }
  removeColumn(e) {
    const n = this._columnOrder[e];
    this._columns.delete(n), this._columnOrder.splice(e, 1);
  }
  setTableMeta(e) {
    this.tableMeta = e;
  }
  getTableMeta() {
    return this.tableMeta;
  }
  getColumn(e) {
    return this._columns.get(e);
  }
  getTableColumnByIndex(e) {
    const n = this._columnOrder[e];
    return this.getColumn(n);
  }
  getColumnNameByIndex(e) {
    var s;
    const n = this._columnOrder[e];
    return ((s = this.getColumn(n)) == null ? void 0 : s.getDisplayName()) || "";
  }
  getId() {
    return this._id;
  }
  getRangeInfo() {
    return {
      ...this._range
    };
  }
  getRange() {
    return { ...this._range };
  }
  setRange(e) {
    this._range = e;
  }
  setDisplayName(e) {
    this._name = e;
  }
  getDisplayName() {
    return this._name;
  }
  getSubunitId() {
    return this._subUnitId;
  }
  setSubunitId(e) {
    this._subUnitId = e;
  }
  getTableStyleId() {
    var e;
    return (e = this._tableStyleId) != null ? e : Ze[0].name;
  }
  setTableStyleId(e) {
    this._tableStyleId = e;
  }
  isShowHeader() {
    var e;
    return (e = this._showHeader) != null ? e : !0;
  }
  setShowHeader(e) {
    this._showHeader = e;
  }
  isShowFooter() {
    var e;
    return (e = this._showFooter) != null ? e : !1;
  }
  getTableInfo() {
    return {
      id: this._id,
      subUnitId: this._subUnitId,
      name: this._name,
      range: this.getRangeInfo(),
      meta: this.tableMeta,
      showHeader: this._showHeader,
      columns: this._columnOrder.map((e) => this._columns.get(e).toJSON())
    };
  }
  getTableConfig() {
    return {
      name: this.getDisplayName(),
      range: this.getRangeInfo(),
      options: {
        showHeader: this._showHeader,
        showFooter: this._showFooter
      },
      tableStyleId: this._tableStyleId
    };
  }
  getFilterStates(e) {
    return this._tableFilters.getFilterStates(e);
  }
  toJSON() {
    const e = [];
    return this._columns.forEach((n) => {
      e.push(n.toJSON());
    }), {
      id: this._id,
      name: this._name,
      range: this.getRangeInfo(),
      options: {
        showHeader: this._showHeader,
        showFooter: this._showFooter,
        tableStyleId: this._tableStyleId
      },
      // TODO: support filter
      filters: this._tableFilters.toJSON(),
      columns: e,
      meta: this.tableMeta
    };
  }
  fromJSON(e) {
    var s, r;
    this._id = e.id, this._name = e.name, this._range = e.range, this.tableMeta = e.meta, this._tableStyleId = e.options.tableStyleId || "", this._showHeader = (s = e.options.showHeader) != null ? s : !0, this._showFooter = (r = e.options.showFooter) != null ? r : !0, e.columns.forEach((a) => {
      const o = new j(a.id, a.displayName);
      o.fromJSON(a), this._columns.set(a.id, o), this._columnOrder.push(a.id);
    }), this._tableFilters = new Oe(), this._tableFilters.fromJSON(e.filters);
  }
  dispose() {
    this._id = "", this._name = "", this._tableStyleId = "", this._showHeader = !0, this._showFooter = !0, delete this._range, this._columns.clear(), this._columnOrder = [];
  }
}
var Nn = Object.getOwnPropertyDescriptor, Dn = (t, e, n, s) => {
  for (var r = s > 1 ? void 0 : s ? Nn(e, n) : e, a = t.length - 1, o; a >= 0; a--)
    (o = t[a]) && (r = o(r) || r);
  return r;
}, $e = (t, e) => (n, s) => e(n, s, t);
let C = class extends H {
  constructor(e, n) {
    super();
    b(this, "_tableMap");
    b(this, "_tableAdd$", new Y());
    b(this, "tableAdd$", this._tableAdd$.asObservable());
    b(this, "_tableDelete$", new Y());
    b(this, "tableDelete$", this._tableDelete$.asObservable());
    b(this, "_tableNameChanged$", new Y());
    b(this, "tableNameChanged$", this._tableNameChanged$.asObservable());
    b(this, "_tableRangeChanged$", new Y());
    b(this, "tableRangeChanged$", this._tableRangeChanged$.asObservable());
    b(this, "_tableThemeChanged$", new Y());
    b(this, "tableThemeChanged$", this._tableThemeChanged$.asObservable());
    b(this, "_tableFilterChanged$", new Y());
    b(this, "tableFilterChanged$", this._tableFilterChanged$.asObservable());
    b(this, "_tableInitStatus", new ze(!1));
    b(this, "tableInitStatus$", this._tableInitStatus.asObservable());
    this._univerInstanceService = e, this._localeService = n, this._tableMap = /* @__PURE__ */ new Map();
  }
  _ensureUnit(e) {
    return this._tableMap.has(e) || this._tableMap.set(e, /* @__PURE__ */ new Map()), this._tableMap.get(e);
  }
  getColumnHeader(e, n, s, r) {
    var d;
    const a = (d = this._univerInstanceService.getUnit(e)) == null ? void 0 : d.getSheetBySheetId(n), { startRow: o, startColumn: u, endColumn: l } = s, i = [], h = r != null ? r : "Column";
    for (let c = u; c <= l; c++)
      i.push(Ke(a == null ? void 0 : a.getCell(o, c)) || te(c - u + 1, h));
    return i;
  }
  /**
   * Add a table to univer.
   * @param {string} unitId The unit id of the table.
   * @param {string} subUnitId The subunit id of the table.
   * @param {string} name The table name, it should be unique in the unit or it will be appended with a number.
   * @param {ITableRange} range The range of the table, it contains the unit id and subunit id.
   * @param {string[]} [header] The header of the table, if not provided, it will be generated based on the range.
   * @param {string} [initId] The initial id of the table, if not provided, a random id will be generated.
   * @param {ITableOptions} [options] Other options of the table.
   * @returns {string} The table id.
   */
  addTable(e, n, s, r, a, o, u) {
    var c;
    const l = o != null ? o : L(), i = a || this.getColumnHeader(e, n, r), h = new Ue(l, s, r, i, u);
    if (h.setSubunitId(n), this._ensureUnit(e).set(l, h), this._tableAdd$.next({
      unitId: e,
      subUnitId: n,
      range: r,
      tableName: s,
      tableId: l,
      tableStyleId: u == null ? void 0 : u.tableStyleId
    }), u != null && u.filters) {
      const g = (c = this._univerInstanceService.getUnit(e)) == null ? void 0 : c.getSheetBySheetId(n);
      h.getTableFilters().doFilter(g, r), this._tableFilterChanged$.next({
        unitId: e,
        subUnitId: n,
        tableId: l
      });
    }
    return l;
  }
  addFilter(e, n, s, r) {
    const a = this.getTable(e, n);
    if (a) {
      a.getTableFilters().setColumnFilter(s, r);
      const u = a.getSubunitId();
      this._tableFilterChanged$.next({
        unitId: e,
        subUnitId: u,
        tableId: n
      });
    }
  }
  getFilterRanges(e, n) {
    const s = this._tableMap.get(e);
    if (!s)
      return [];
    const r = [];
    return s.forEach((a) => {
      a.getSubunitId() === n && a.isShowHeader() && r.push(a.getRange());
    }), r;
  }
  getSheetFilterRangeWithState(e, n) {
    const s = this._tableMap.get(e);
    if (!s)
      return [];
    const r = [];
    return s.forEach((a) => {
      a.getSubunitId() === n && a.isShowHeader() && r.push({
        tableId: a.getId(),
        range: a.getRange(),
        states: a.getFilterStates(a.getRange())
      });
    }), r;
  }
  getTable(e, n) {
    const s = this._tableMap.get(e);
    if (s)
      return s.get(n);
  }
  /**
   * Get the unique table name, in excel, the table name should be unique because it is used as a reference.
   * @param {string} unitId The unit id of the table.
   * @param {string} baseName The base name of the table.
   * @returns {string} The unique table name
   */
  getUniqueTableName(e, n) {
    const s = this._tableMap.get(e);
    if (!s)
      return n;
    const r = new Set(Array.from(s.values()).map((u) => u.getDisplayName()));
    let a = n, o = 1;
    for (; r.has(a); )
      a = `${n}-${o}`, o++;
    return a;
  }
  /**
   * Get table by unit id and table id.
   * @param {string} unitId  The unit id of the table.
   * @param {string} tableId The table id.
   * @returns {Table} The table.
   */
  getTableById(e, n) {
    return this.getTable(e, n);
  }
  getTableList(e) {
    const n = this._tableMap.get(e);
    return n ? Array.from(n.values()).map((s) => ({ ...s.getTableInfo(), unitId: e })) : [];
  }
  /**
   * Get the table list by unit id and subunit id.
   * @param {string} unitId The unit id of the table.
   * @param {string} subUnitId The subunit id of the table.
   * @returns {Table[]} The table list.
   */
  getTablesBySubunitId(e, n) {
    const s = this._tableMap.get(e);
    return s ? Array.from(s.values()).filter((r) => r.getSubunitId() === n) : [];
  }
  getTablesInfoBySubunitId(e, n) {
    return this.getTablesBySubunitId(e, n).map((s) => ({
      id: s.getId(),
      name: s.getDisplayName(),
      range: s.getRange()
    }));
  }
  deleteTable(e, n) {
    const s = this._tableMap.get(e), r = s == null ? void 0 : s.get(n);
    if (r) {
      const a = r.getTableInfo(), o = r.getTableStyleId();
      s == null || s.delete(n);
      const { subUnitId: u, range: l, name: i } = a;
      this._tableDelete$.next({
        unitId: e,
        subUnitId: u,
        tableId: n,
        range: l,
        tableName: i,
        tableStyleId: o
      });
    }
  }
  operationTableRowCol(e, n, s) {
    const r = this.getTableById(e, n);
    if (!r) return;
    const { operationType: a, rowColType: o, index: u, count: l, columnsJson: i } = s, h = r.getRange(), d = { ...h };
    if (a === M.Insert) {
      if (o === "row")
        d.endRow += l;
      else if (o === "column") {
        d.endColumn += l;
        for (let c = 0; c < l; c++) {
          const g = this._localeService.t("sheets-table.columnPrefix"), R = new j(L(), te(r.getColumnsCount() + 1 + c, g));
          i != null && i[c] && R.fromJSON(i[c]);
          const w = u + c - h.startColumn;
          r.insertColumn(w, R);
        }
      }
    } else if (o === "row")
      d.endRow -= l;
    else if (o === "column") {
      d.endColumn -= l;
      for (let c = l - 1; c >= 0; c--) {
        const g = u + c - h.startColumn;
        r.removeColumn(g);
      }
    }
    r.setRange(d), this._tableRangeChanged$.next({
      unitId: e,
      subUnitId: r.getSubunitId(),
      tableId: n,
      range: d,
      oldRange: h
    });
  }
  updateTableRange(e, n, s) {
    const r = this.getTableById(e, n);
    if (!r) return;
    const a = r.getRange(), o = s.newRange;
    if (o.startColumn < a.startColumn) {
      const u = a.startColumn - o.startColumn, l = this._localeService.t("sheets-table.columnPrefix");
      for (let i = 0; i < u; i++)
        r.insertColumn(a.startColumn, new j(L(), te(r.getColumnsCount() + 1, l)));
    } else if (o.startColumn > a.startColumn) {
      const u = o.startColumn - a.startColumn;
      for (let l = u - 1; l >= 0; l--) {
        const i = o.startColumn + l - a.startColumn;
        r.removeColumn(i);
      }
    }
    if (o.endColumn < a.endColumn) {
      const u = a.endColumn - o.endColumn;
      for (let l = u - 1; l >= 0; l--) {
        const i = o.endColumn + l - a.startColumn;
        r.removeColumn(i);
      }
    } else if (o.endColumn > a.endColumn) {
      const u = o.endColumn - a.endColumn;
      for (let l = 0; l < u; l++)
        r.insertColumn(a.endColumn, new j(L(), te(r.getColumnsCount() + 1, "Column")));
    }
    r.setRange(o), this._tableRangeChanged$.next({
      unitId: e,
      subUnitId: r.getSubunitId(),
      tableId: n,
      range: o,
      oldRange: a
    });
  }
  setTableByConfig(e, n, s) {
    var c;
    const r = this._tableMap.get(e), a = r == null ? void 0 : r.get(n);
    if (!a) return;
    const o = a.getSubunitId(), { name: u, updateRange: l, rowColOperation: i, theme: h, options: d } = s;
    if (u) {
      const g = a.getDisplayName();
      a.setDisplayName(u), this._tableNameChanged$.next({
        unitId: e,
        subUnitId: o,
        tableId: n,
        tableName: u,
        oldTableName: g
      });
    }
    if (i && this.operationTableRowCol(e, n, i), l && this.updateTableRange(e, n, l), h) {
      const g = (c = a.getTableStyleId()) != null ? c : "default";
      a.setTableStyleId(h), this._tableThemeChanged$.next({
        unitId: e,
        subUnitId: o,
        tableId: n,
        theme: h,
        oldTheme: g
      });
    }
    d && d.showHeader !== void 0 && a.setShowHeader(d.showHeader);
  }
  toJSON(e) {
    const n = {}, s = this._tableMap.get(e);
    return s && s.forEach((r) => {
      const a = r.getSubunitId();
      if (!n[a]) {
        const o = /* @__PURE__ */ new Set();
        this.getTablesBySubunitId(e, a).forEach((l) => {
          const i = l.getTableFilters().getFilterOutRows();
          if (i)
            for (const h of i)
              o.add(h);
        }), n[a] = {
          tables: [],
          tableFilteredOutRows: Array.from(o)
        };
      }
      n[a].tables.push(r.toJSON());
    }), n;
  }
  fromJSON(e, n) {
    const s = this._ensureUnit(e);
    Object.keys(n).forEach((a) => {
      const o = $(this._univerInstanceService, { unitId: e, subUnitId: a });
      if (!o)
        return;
      const u = o.worksheet;
      let l;
      n[a].tables ? l = n[a].tables : Array.isArray(n[a]) && (l = n[a]), l && l.forEach((i) => {
        const h = this.getColumnHeader(e, a, i.range), d = new Ue(i.id, i.name, i.range, h, i.options);
        if (d.setTableMeta(i.meta), i.columns.length && d.setColumns(i.columns), i.filters) {
          const c = d.getTableFilters();
          c.fromJSON(i.filters), c.doFilter(u, d.getTableFilterRange());
        }
        d.setSubunitId(a), s.set(i.id, d), this._tableAdd$.next({
          unitId: e,
          subUnitId: a,
          range: i.range,
          tableName: i.name,
          tableId: i.id
        });
      });
    }), this._tableInitStatus.next(!0);
  }
  deleteUnitId(e) {
    this._tableMap.delete(e);
  }
  dispose() {
    super.dispose(), this._tableMap.forEach((e) => {
      e.forEach((n) => n.dispose()), e.clear();
    }), this._tableMap.clear();
  }
};
C = Dn([
  $e(0, B),
  $e(1, _(be))
], C);
var xn = Object.getOwnPropertyDescriptor, On = (t, e, n, s) => {
  for (var r = s > 1 ? void 0 : s ? xn(e, n) : e, a = t.length - 1, o; a >= 0; a--)
    (o = t[a]) && (r = o(r) || r);
  return r;
}, Un = (t, e) => (n, s) => e(n, s, t);
let X = class extends H {
  constructor(t) {
    super(), this._tableManager = t;
  }
  getTableInfo(t, e) {
    const n = this._tableManager.getTable(t, e);
    if (n)
      return {
        unitId: t,
        ...n.getTableInfo()
      };
  }
  getTableList(t) {
    return this._tableManager.getTableList(t);
  }
  addTable(t, e, n, s, r, a, o) {
    return this._tableManager.addTable(t, e, n, s, r, a, o);
  }
  deleteTable(t, e, n) {
    this._tableManager.deleteTable(t, n);
  }
  getTableMeta(t, e) {
    var n;
    return (n = this._tableManager.getTable(t, e)) == null ? void 0 : n.getTableMeta();
  }
  setTableMeta(t, e, n) {
    var s;
    (s = this._tableManager.getTable(t, e)) == null || s.setTableMeta(n);
  }
  getTableColumnMeta(t, e, n) {
    var s, r;
    return (r = (s = this._tableManager.getTable(t, e)) == null ? void 0 : s.getTableColumnByIndex(n)) == null ? void 0 : r.getMeta();
  }
  selTableColumnMeta(t, e, n, s) {
    var r, a;
    (a = (r = this._tableManager.getTable(t, e)) == null ? void 0 : r.getTableColumnByIndex(n)) == null || a.setMeta(s);
  }
  addFilter(t, e, n, s) {
    this._tableManager.addFilter(t, e, n, s);
  }
  getCellValueWithConditionType(t, e, n, s = O.String) {
    return ue(t, e, n, s);
  }
};
X = On([
  Un(0, _(C))
], X);
const k = {
  id: "sheet.mutation.add-table",
  type: N.MUTATION,
  handler: (t, e) => {
    const { tableId: n, unitId: s, subUnitId: r, name: a, range: o, header: u, options: l } = e;
    return t.get(X).addTable(s, r, a, o, u, n, l), !0;
  }
}, Q = {
  id: "sheet.mutation.delete-table",
  type: N.MUTATION,
  handler: (t, e) => {
    const { unitId: n, subUnitId: s, tableId: r } = e;
    return t.get(X).deleteTable(n, s, r), !0;
  }
}, $n = {
  id: "sheet.command.add-table",
  type: N.COMMAND,
  handler: (t, e) => {
    var w;
    if (!e)
      return !1;
    const n = t.get(A), s = t.get(D), r = t.get(be), a = (w = e.id) != null ? w : L();
    let o = e.name;
    if (!o) {
      const f = t.get(C).getTableList(e.unitId).length;
      o = `${r.t("sheets-table.tablePrefix")}${f + 1}`;
    }
    const u = [], l = [], i = t.get(C), { unitId: h, subUnitId: d, range: c } = e, g = i.getColumnHeader(h, d, c, r.t("sheets-table.columnPrefix"));
    return u.push({ id: k.id, params: { ...e, tableId: a, name: o, header: g } }), l.push({ id: Q.id, params: { tableId: a, unitId: e.unitId } }), E(u, s) && n.pushUndoRedo({
      unitID: e.unitId,
      undoMutations: l,
      redoMutations: u
    }), !0;
  }
}, An = {
  id: "sheet.command.delete-table",
  type: N.COMMAND,
  handler: (t, e) => {
    if (!e)
      return !1;
    const n = t.get(A), s = t.get(D), r = t.get(C), a = t.get(Le), o = [], u = [], l = r.getTable(e.unitId, e.tableId), i = l == null ? void 0 : l.toJSON();
    return i ? (o.push({ id: Q.id, params: { ...e } }), u.push({
      id: k.id,
      params: {
        unitId: e.unitId,
        subUnitId: e.subUnitId,
        tableId: e.tableId,
        name: i.name,
        range: i.range,
        options: i.options
      }
    }), E(o, s) && n.pushUndoRedo({
      unitID: e.unitId,
      undoMutations: u,
      redoMutations: o
    }), !0) : (a.error("[TableManager]: Table not found"), !1);
  }
}, _e = {
  id: "sheet.mutation.set-table-filter",
  type: N.MUTATION,
  handler: (t, e) => {
    const { tableId: n, unitId: s, column: r, tableFilter: a } = e;
    return t.get(C).addFilter(s, n, r, a), !0;
  }
}, Bn = {
  id: "sheet.command.set-table-filter",
  type: N.COMMAND,
  handler: (t, e) => {
    if (!e)
      return !1;
    const n = t.get(A), s = t.get(D), r = e.tableId || L(), a = [], o = [];
    return a.push({ id: _e.id, params: { ...e, tableId: r } }), o.push({ id: _e.id, params: { ...e, tableId: r, tableFilter: void 0 } }), E(a, s) && n.pushUndoRedo({
      unitID: e.unitId,
      undoMutations: o,
      redoMutations: a
    }), !0;
  }
}, nt = "SHEET_TABLE_PLUGIN", re = "SHEET_TABLE", En = "table-custom";
var Ln = Object.getOwnPropertyDescriptor, Wn = (t, e, n, s) => {
  for (var r = s > 1 ? void 0 : s ? Ln(e, n) : e, a = t.length - 1, o; a >= 0; a--)
    (o = t[a]) && (r = o(r) || r);
  return r;
}, ae = (t, e) => (n, s) => e(n, s, t);
let W = class extends H {
  constructor(e, n, s, r) {
    super();
    b(this, "_tableRangeRTree", /* @__PURE__ */ new Map());
    this._univerInstanceService = e, this._sheetInterceptorService = n, this._tableManager = s, this._resourceManagerService = r, this._initSnapshot(), this._initSheetChange(), this.registerTableChangeEvent(), this.registerTableHeaderInterceptor();
  }
  getContainerTableWithRange(e, n, s) {
    const r = this._ensureTableRangeRTree(e), o = Array.from(r.bulkSearch([{ unitId: e, sheetId: n, range: s }])).find((u) => {
      const l = this._tableManager.getTable(e, String(u));
      return l ? Re.contains(l.getRange(), s) : !1;
    });
    if (o)
      return this._tableManager.getTable(e, String(o));
  }
  _ensureTableRangeRTree(e) {
    return this._tableRangeRTree.has(e) || this._tableRangeRTree.set(e, new it()), this._tableRangeRTree.get(e);
  }
  registerTableChangeEvent() {
    this.disposeWithMe(
      this._tableManager.tableAdd$.subscribe((e) => {
        const { range: n, tableId: s, unitId: r, subUnitId: a } = e;
        this._ensureTableRangeRTree(r).insert({
          unitId: r,
          sheetId: a,
          id: s,
          range: { ...n }
        });
      })
    ), this.disposeWithMe(
      this._tableManager.tableRangeChanged$.subscribe((e) => {
        const { range: n, tableId: s, unitId: r, subUnitId: a, oldRange: o } = e, u = this._ensureTableRangeRTree(r);
        u.remove({
          unitId: r,
          sheetId: a,
          id: s,
          range: { ...o }
        }), u.insert({
          unitId: r,
          sheetId: a,
          id: s,
          range: { ...n }
        });
      })
    ), this.disposeWithMe(
      this._tableManager.tableDelete$.subscribe((e) => {
        const { tableId: n, unitId: s, subUnitId: r, range: a } = e;
        this._ensureTableRangeRTree(s).remove({
          unitId: s,
          sheetId: r,
          id: n,
          range: { ...a }
        });
      })
    );
  }
  registerTableHeaderInterceptor() {
    this.disposeWithMe(
      this._sheetInterceptorService.intercept(Ve.CELL_CONTENT, {
        effect: lt.Value,
        handler: (e, n, s) => {
          const { row: r, col: a, unitId: o, subUnitId: u } = n, l = this._ensureTableRangeRTree(o);
          if ((e == null ? void 0 : e.v) === void 0 && l) {
            const h = Array.from(l.bulkSearch([{ unitId: o, sheetId: u, range: { startColumn: a, endColumn: a, startRow: r, endRow: r } }]));
            if (h.length > 0) {
              const d = this._tableManager.getTable(o, h[0]);
              if (d) {
                const c = d.getRange(), g = a - c.startColumn;
                if (c.startRow === r) {
                  const w = d.getColumnNameByIndex(g);
                  return (!e || e === n.rawData) && (e = { ...n.rawData }), e.v = w, s(e);
                }
              }
            }
          }
          return s(e);
        }
      })
    );
  }
  _toJson(e) {
    return this._tableManager.toJSON(e);
  }
  _fromJSON(e, n) {
    return this._tableManager.fromJSON(e, n);
  }
  _deleteUnitId(e) {
    this._tableManager.deleteUnitId(e);
  }
  _initSnapshot() {
    this.disposeWithMe(this._resourceManagerService.registerPluginResource({
      toJson: (e) => JSON.stringify(this._toJson(e)),
      parseJson: (e) => {
        if (!e)
          return {};
        try {
          return JSON.parse(e);
        } catch {
          return {};
        }
      },
      businesses: [z.UNIVER_SHEET],
      pluginName: nt,
      onLoad: (e, n) => {
        this._fromJSON(e, n);
      },
      onUnLoad: (e) => {
        this._deleteUnitId(e);
      }
    }));
  }
  // eslint-disable-next-line max-lines-per-function
  _initSheetChange() {
    this.disposeWithMe(
      this._sheetInterceptorService.interceptCommand({
        // eslint-disable-next-line max-lines-per-function
        getMutations: (e) => {
          var n;
          if (e.id === gt.id) {
            const s = e.params, r = s.unitId || this._univerInstanceService.getCurrentUnitOfType(z.UNIVER_SHEET).getUnitId(), a = s.subUnitId || ((n = this._univerInstanceService.getCurrentUnitOfType(z.UNIVER_SHEET).getActiveSheet()) == null ? void 0 : n.getSheetId());
            if (!r || !a)
              return { redos: [], undos: [] };
            const o = this._tableManager.getTablesBySubunitId(r, a);
            if (o.length === 0)
              return { redos: [], undos: [] };
            const u = [], l = [];
            return o.forEach((i) => {
              const h = i.toJSON();
              u.push({
                id: Q.id,
                params: {
                  unitId: r,
                  subUnitId: a,
                  tableId: h.id
                }
              }), l.push({
                id: k.id,
                params: {
                  unitId: r,
                  subUnitId: a,
                  name: h.name,
                  range: h.range,
                  tableId: h.id,
                  options: {
                    ...h.options,
                    columns: h.columns,
                    filters: h.filters.tableColumnFilterList
                  }
                }
              });
            }), { redos: u, undos: l };
          } else if (e.id === mt.id) {
            const s = e.params, { unitId: r, subUnitId: a, targetSubUnitId: o } = s;
            if (!r || !a || !o)
              return { redos: [], undos: [] };
            const u = this._tableManager.getTablesBySubunitId(r, a);
            if (u.length === 0)
              return { redos: [], undos: [] };
            const l = [], i = [];
            return u.forEach((h) => {
              const d = h.toJSON(), c = L();
              l.push({
                id: k.id,
                params: {
                  unitId: r,
                  subUnitId: o,
                  name: d.name,
                  range: {
                    ...d.range,
                    sheetId: o
                  },
                  tableId: c,
                  options: {
                    ...d.options,
                    columns: d.columns,
                    filters: d.filters.tableColumnFilterList
                  }
                }
              }), i.push({
                id: Q.id,
                params: {
                  unitId: r,
                  subUnitId: o,
                  tableId: c
                }
              });
            }), { redos: l, undos: i };
          }
          return { redos: [], undos: [] };
        }
      })
    );
  }
  dispose() {
    super.dispose(), this._tableRangeRTree.clear();
  }
};
W = Wn([
  ae(0, _(B)),
  ae(1, _(Ce)),
  ae(2, _(C)),
  ae(3, _(ot))
], W);
const S = {
  id: "sheet.mutation.set-sheet-table",
  type: N.MUTATION,
  handler: (t, e) => {
    if (!e)
      return !1;
    const { unitId: n, tableId: s, config: r } = e;
    return t.get(C).setTableByConfig(n, s, r), !0;
  }
}, Hn = {
  id: "sheet.command.add-table-theme",
  type: N.COMMAND,
  handler: (t, e) => {
    if (!e)
      return !1;
    const n = t.get(C), { unitId: s, tableId: r, themeStyle: a } = e, o = [], u = [], l = n.getTableById(s, r);
    if (!l) return !1;
    const i = l.getSubunitId();
    o.push({
      id: Pe.id,
      params: {
        unitId: s,
        subUnitId: i,
        styleJSON: a.toJson()
      }
    }), o.push({
      id: S.id,
      params: {
        unitId: s,
        subUnitId: i,
        tableId: r,
        config: {
          theme: a.getName()
        }
      }
    }), u.push({
      id: S.id,
      params: {
        unitId: s,
        subUnitId: i,
        tableId: r,
        config: {
          themeStyle: l.getTableStyleId()
        }
      }
    }), u.push({
      id: qe.id,
      params: {
        unitId: s,
        subUnitId: i,
        styleName: a.getName()
      }
    });
    const h = t.get(D);
    return E(o, h) && t.get(A).pushUndoRedo({
      unitID: s,
      undoMutations: u,
      redoMutations: o
    }), !0;
  }
}, Vn = {
  id: "sheet.command.remove-table-theme",
  type: N.COMMAND,
  handler: (t, e) => {
    if (!e)
      return !1;
    const { unitId: n, tableId: s, themeName: r } = e, a = t.get(C), o = t.get(Je), u = a.getTableById(n, s);
    if (!u) return !1;
    const l = u.getSubunitId(), i = [], h = [], d = o.getRegisteredRangeThemes().filter((f) => f == null ? void 0 : f.startsWith("table-default"));
    let g = o.getRegisteredRangeThemes().filter((f) => f == null ? void 0 : f.startsWith(En)).find((f) => f !== r);
    g || (g = d[0]), i.push({ id: S.id, params: { unitId: n, subUnitId: l, tableId: s, config: { theme: g } } }), i.push({ id: qe.id, params: { unitId: n, subUnitId: l, styleName: r } });
    const R = o.getDefaultRangeThemeStyle(r);
    R && (h.push({ id: Pe.id, params: { unitId: n, subUnitId: l, styleJSON: R.toJson() } }), h.push({ id: S.id, params: { unitId: n, subUnitId: l, tableId: s, config: { theme: r } } }));
    const w = t.get(D);
    return E(i, w) && t.get(A).pushUndoRedo({
      unitID: n,
      redoMutations: i,
      undoMutations: h
    }), !0;
  }
}, Pn = {
  id: "sheet.command.set-table-config",
  type: N.COMMAND,
  // eslint-disable-next-line max-lines-per-function
  handler: (t, e) => {
    if (!e)
      return !1;
    const { unitId: n, tableId: s, name: r, updateRange: a, rowColOperation: o, theme: u } = e, l = t.get(C), i = l.getTableById(n, s);
    if (!i) return !1;
    const h = {}, d = {}, c = t.get(be), R = t.get(B).getCurrentUnitOfType(z.UNIVER_SHEET), w = /* @__PURE__ */ new Set();
    if (R && (R.getSheets().forEach((T) => {
      w.add(T.getName());
    }), l.getTableList(n).forEach((T) => {
      w.add(T.name);
    })), r) {
      if (!ut(r, w))
        return t.get(Le).warn(c.t("sheets-table.tableNameError")), !1;
      h.name = i.getDisplayName(), d.name = r;
    }
    o && (h.rowColOperation = {
      operationType: o.operationType === M.Insert ? M.Delete : M.Insert,
      rowColType: o.rowColType,
      index: o.index,
      count: o.count
    }, d.rowColOperation = o), a && (h.updateRange = {
      newRange: i.getRange()
    }, d.updateRange = a), u && (h.theme = i.getTableStyleId(), d.theme = u);
    const p = {
      unitId: n,
      subUnitId: i.getSubunitId(),
      tableId: s,
      config: d
    };
    return t.get(D).executeCommand(S.id, p), t.get(A).pushUndoRedo({
      unitID: n,
      undoMutations: [
        {
          id: S.id,
          params: {
            unitId: n,
            subUnitId: i.getSubunitId(),
            tableId: s,
            config: h
          }
        }
      ],
      redoMutations: [
        {
          id: S.id,
          params: p
        }
      ]
    }), !0;
  }
}, qn = {
  id: "sheet.command.table-insert-row",
  type: N.COMMAND,
  handler: (t) => {
    const e = t.get(B), n = $(e);
    if (!n)
      return !1;
    const { workbook: s, worksheet: r, unitId: a, subUnitId: o } = n, l = t.get(we).getCurrentSelections();
    if (!l.length || l.length > 1)
      return !1;
    t.get(C);
    const h = l[0].range, c = t.get(W).getContainerTableWithRange(a, o, h);
    if (!c) return !1;
    const g = h.endRow - h.startRow + 1, w = r.getRowCount() - 1, p = r.getCellMatrix().getDataRange().endRow, f = [], I = [];
    if (w - p < g)
      f.push({
        id: ke.id,
        params: {
          unitId: a,
          subUnitId: o,
          range: { ...h }
        }
      }), f.push({
        id: S.id,
        params: {
          unitId: a,
          subUnitId: o,
          tableId: c.getId(),
          config: {
            updateRange: {
              newRange: {
                ...c.getRange(),
                endRow: c.getRange().endRow + g
              }
            }
          }
        }
      }), I.push({
        id: S.id,
        params: {
          unitId: a,
          subUnitId: o,
          tableId: c.getId(),
          config: {
            updateRange: {
              newRange: c.getRange()
            }
          }
        }
      }), I.push({
        id: Qe.id,
        params: {
          unitId: a,
          subUnitId: o,
          range: { ...h }
        }
      });
    else {
      const v = { ...c.getRange() };
      f.push({
        id: S.id,
        params: {
          unitId: a,
          subUnitId: o,
          tableId: c.getId(),
          config: {
            updateRange: {
              newRange: {
                ...v,
                endRow: v.endRow + g
              }
            }
          }
        }
      }), I.push({
        id: S.id,
        params: {
          unitId: a,
          subUnitId: o,
          tableId: c.getId(),
          config: {
            updateRange: {
              newRange: { ...v }
            }
          }
        }
      });
      const ee = fe(
        t,
        {
          unitId: a,
          subUnitId: o,
          range: {
            startRow: h.startRow,
            endRow: p,
            startColumn: v.startColumn,
            endColumn: v.endColumn
          }
        },
        {
          unitId: a,
          subUnitId: o,
          range: {
            startRow: h.startRow + g,
            endRow: p + g,
            startColumn: v.startColumn,
            endColumn: v.endColumn
          }
        }
      );
      ee && (f.push(...ee.redos), I.push(...ee.undos));
    }
    const U = t.get(D);
    return E(f, U) && t.get(A).pushUndoRedo({
      unitID: a,
      undoMutations: I,
      redoMutations: f
    }), !0;
  }
}, Jn = {
  id: "sheet.command.table-insert-col",
  type: N.COMMAND,
  handler: (t) => {
    const e = t.get(B), n = $(e);
    if (!n)
      return !1;
    const { worksheet: s, unitId: r, subUnitId: a } = n, u = t.get(we).getCurrentSelections();
    if (!u.length || u.length > 1)
      return !1;
    const i = u[0].range, d = t.get(W).getContainerTableWithRange(r, a, i);
    if (!d) return !1;
    const c = i.endColumn - i.startColumn + 1, R = s.getColumnCount() - 1, w = s.getCellMatrix().getDataRange().endColumn, p = [], f = [];
    if (R - w < c)
      p.push({
        id: Ye.id,
        params: {
          unitId: r,
          subUnitId: a,
          range: { ...i }
        }
      }), p.push({
        id: S.id,
        params: {
          unitId: r,
          subUnitId: a,
          tableId: d.getId(),
          config: {
            rowColOperation: {
              operationType: M.Insert,
              rowColType: y.Col,
              index: i.startColumn,
              count: c
            }
          }
        }
      }), f.push({
        id: S.id,
        params: {
          unitId: r,
          subUnitId: a,
          tableId: d.getId(),
          config: {
            rowColOperation: {
              operationType: M.Delete,
              rowColType: y.Col,
              index: i.startColumn,
              count: c
            }
          }
        }
      }), f.push({
        id: Ge.id,
        params: {
          unitId: r,
          subUnitId: a,
          range: { ...i }
        }
      });
    else {
      const T = d.getRange();
      p.push({
        id: S.id,
        params: {
          unitId: r,
          subUnitId: a,
          tableId: d.getId(),
          config: {
            rowColOperation: {
              operationType: M.Insert,
              rowColType: y.Col,
              index: i.startColumn,
              count: c
            }
          }
        }
      }), f.push({
        id: S.id,
        params: {
          unitId: r,
          subUnitId: a,
          tableId: d.getId(),
          config: {
            rowColOperation: {
              operationType: M.Delete,
              rowColType: y.Col,
              index: i.startColumn,
              count: c
            }
          }
        }
      });
      const v = fe(
        t,
        {
          unitId: r,
          subUnitId: a,
          range: {
            startRow: T.startRow,
            endRow: T.endRow,
            startColumn: i.startColumn,
            endColumn: w
          }
        },
        {
          unitId: r,
          subUnitId: a,
          range: {
            startRow: T.startRow,
            endRow: T.endRow,
            startColumn: i.startColumn + c,
            endColumn: w + c
          }
        }
      );
      v && (p.push(...v.redos), f.push(...v.undos));
    }
    const I = t.get(D);
    return E(p, I) && t.get(A).pushUndoRedo({
      unitID: r,
      undoMutations: f,
      redoMutations: p
    }), !0;
  }
}, kn = {
  id: "sheet.command.table-remove-row",
  type: N.COMMAND,
  handler: (t, e) => {
    if (!e)
      return !1;
    const n = t.get(B), s = $(n);
    if (!s)
      return !1;
    const { unitId: r, subUnitId: a } = s, u = t.get(we).getCurrentSelections();
    if (!u.length || u.length > 1)
      return !1;
    const i = u[0].range, d = t.get(W).getContainerTableWithRange(r, a, i);
    if (!d) return !1;
    const c = i.endRow - i.startRow + 1, g = [], R = [], w = d.getRange();
    g.push({
      id: S.id,
      params: {
        unitId: r,
        subUnitId: a,
        tableId: d.getId(),
        config: {
          updateRange: {
            newRange: {
              ...w,
              endRow: w.endRow - c
            }
          }
        }
      }
    }), R.push({
      id: S.id,
      params: {
        unitId: r,
        subUnitId: a,
        tableId: d.getId(),
        config: {
          updateRange: {
            newRange: { ...w }
          }
        }
      }
    });
    const f = s.worksheet.getCellMatrix().getDataRange().endRow, I = fe(
      t,
      {
        unitId: r,
        subUnitId: a,
        range: {
          startRow: i.endRow + 1,
          endRow: f,
          startColumn: w.startColumn,
          endColumn: w.endColumn
        }
      },
      {
        unitId: r,
        subUnitId: a,
        range: {
          startRow: i.startRow,
          endRow: f - c,
          startColumn: w.startColumn,
          endColumn: w.endColumn
        }
      }
    );
    I && (g.push(...I.redos), R.push(...I.undos));
    const U = t.get(D);
    return E(g, U) && t.get(A).pushUndoRedo({
      unitID: r,
      undoMutations: R,
      redoMutations: g
    }), !0;
  }
}, Qn = {
  id: "sheet.command.table-remove-col",
  type: N.COMMAND,
  handler: (t, e) => {
    if (!e)
      return !1;
    const n = t.get(B), s = $(n);
    if (!s)
      return !1;
    const { workbook: r, unitId: a, subUnitId: o } = s;
    t.get(C);
    const l = t.get(we).getCurrentSelections();
    if (!l.length || l.length > 1)
      return !1;
    const h = l[0].range, c = t.get(W).getContainerTableWithRange(a, o, h);
    if (!c) return !1;
    const g = h.endColumn - h.startColumn + 1, R = [], w = [], p = c.getRange();
    R.push({
      id: S.id,
      params: {
        unitId: a,
        subUnitId: o,
        tableId: c.getId(),
        config: {
          rowColOperation: {
            operationType: M.Delete,
            rowColType: y.Col,
            index: h.startColumn,
            count: g
          }
        }
      }
    });
    const f = [], I = h.startColumn - p.startColumn;
    for (let se = 0; se < g; se++) {
      const Ie = c.getTableInfo().columns[I + se];
      Ie && f.push(Ie);
    }
    w.push({
      id: S.id,
      params: {
        unitId: a,
        subUnitId: o,
        tableId: c.getId(),
        config: {
          rowColOperation: {
            operationType: M.Insert,
            rowColType: y.Col,
            index: h.startColumn,
            count: g,
            columnsJson: f
          }
        }
      }
    });
    const T = s.worksheet.getCellMatrix().getDataRange().endColumn, v = fe(
      t,
      {
        unitId: a,
        subUnitId: o,
        range: {
          startRow: p.startRow,
          endRow: p.endRow,
          startColumn: h.endColumn + 1,
          endColumn: T
        }
      },
      {
        unitId: a,
        subUnitId: o,
        range: {
          startRow: p.startRow,
          endRow: p.endRow,
          startColumn: h.startColumn,
          endColumn: T - g
        }
      }
    );
    v && (R.push(...v.redos), w.push(...v.undos));
    const ee = t.get(D);
    return E(R, ee) && t.get(A).pushUndoRedo({
      unitID: a,
      undoMutations: w,
      redoMutations: R
    }), !0;
  }
};
var Yn = Object.getOwnPropertyDescriptor, Gn = (t, e, n, s) => {
  for (var r = s > 1 ? void 0 : s ? Yn(e, n) : e, a = t.length - 1, o; a >= 0; a--)
    (o = t[a]) && (r = o(r) || r);
  return r;
}, Ae = (t, e) => (n, s) => e(n, s, t);
let ce = class extends H {
  constructor(t, e) {
    super(), this._tableManager = t, this._commandService = e, this._initRangeListener();
  }
  _initRangeListener() {
    this.disposeWithMe(
      this._tableManager.tableRangeChanged$.subscribe((t) => {
        const { tableId: e, unitId: n } = t, s = this._tableManager.getTableById(n, e);
        s && this._updateSuperTable(n, s);
      })
    ), this.disposeWithMe(
      this._tableManager.tableAdd$.subscribe((t) => {
        const { tableId: e, unitId: n } = t, s = this._tableManager.getTableById(n, e);
        s && this._updateSuperTable(n, s);
      })
    ), this.disposeWithMe(
      this._tableManager.tableDelete$.subscribe((t) => {
        const { unitId: e, tableName: n } = t;
        this._commandService.executeCommand(Fe.id, {
          unitId: e,
          tableName: n
        });
      })
    ), this.disposeWithMe(
      this._tableManager.tableNameChanged$.subscribe((t) => {
        const { tableId: e, unitId: n, oldTableName: s } = t;
        this._commandService.executeCommand(Fe.id, {
          unitId: n,
          tableName: s
        });
        const r = this._tableManager.getTableById(n, e);
        r && this._updateSuperTable(n, r);
      })
    );
  }
  _updateSuperTable(t, e) {
    const n = e.getTableInfo(), s = n.name, r = n.columns, a = /* @__PURE__ */ new Map();
    r.forEach((o, u) => {
      a.set(o.displayName, u);
    }), this._commandService.executeCommand(It.id, {
      unitId: t,
      tableName: s,
      reference: {
        range: n.range,
        sheetId: n.subUnitId,
        titleMap: a
      }
    });
  }
};
ce = Gn([
  Ae(0, _(C)),
  Ae(1, D)
], ce);
var zn = Object.getOwnPropertyDescriptor, jn = (t, e, n, s) => {
  for (var r = s > 1 ? void 0 : s ? zn(e, n) : e, a = t.length - 1, o; a >= 0; a--)
    (o = t[a]) && (r = o(r) || r);
  return r;
}, Be = (t, e) => (n, s) => e(n, s, t);
let de = class extends H {
  constructor(t, e) {
    super(), this._tableManager = t, this._exclusiveRangeService = e, this._initRangeListener();
  }
  _initRangeListener() {
    this.disposeWithMe(
      this._tableManager.tableRangeChanged$.subscribe((t) => {
        const { range: e, tableId: n, unitId: s, subUnitId: r } = t;
        this._exclusiveRangeService.clearExclusiveRangesByGroupId(s, r, re, n), this._exclusiveRangeService.addExclusiveRange(s, r, re, [{
          range: { ...e },
          groupId: n
        }]);
      })
    ), this.disposeWithMe(
      this._tableManager.tableAdd$.subscribe((t) => {
        const { tableId: e, unitId: n, subUnitId: s, range: r } = t;
        this._exclusiveRangeService.addExclusiveRange(n, s, re, [{
          range: { ...r },
          groupId: e
        }]);
      })
    ), this.disposeWithMe(
      this._tableManager.tableDelete$.subscribe((t) => {
        const { tableId: e, unitId: n, subUnitId: s } = t;
        this._exclusiveRangeService.clearExclusiveRangesByGroupId(n, s, re, e);
      })
    );
  }
};
de = jn([
  Be(0, _(C)),
  Be(1, _(bt))
], de);
var Kn = Object.getOwnPropertyDescriptor, Xn = (t, e, n, s) => {
  for (var r = s > 1 ? void 0 : s ? Kn(e, n) : e, a = t.length - 1, o; a >= 0; a--)
    (o = t[a]) && (r = o(r) || r);
  return r;
}, V = (t, e) => (n, s) => e(n, s, t);
let he = class extends H {
  constructor(t, e, n, s, r, a, o) {
    super(), this._commandService = t, this._refRangeService = e, this._univerInstanceService = n, this._injector = s, this._sheetInterceptorService = r, this._tableManager = a, this._localeService = o, this._initCommandInterceptor(), this._initCommandListener();
  }
  _initCommandInterceptor() {
    const t = this;
    this._sheetInterceptorService.interceptCommand({
      getMutations(e) {
        const n = { redos: [], undos: [] }, { id: s, params: r } = e;
        switch (s) {
          case Rt.id:
            return t._generateTableMutationWithInsertRow(r);
          case St.id:
            return t._generateTableMutationWithInsertCol(r);
          case pt.id:
            return t._generateTableMutationWithRemoveRow(r);
          case ft.id:
            return t._generateTableMutationWithRemoveCol(r);
        }
        return n;
      }
    });
  }
  _generateTableMutationWithInsertRow(t) {
    const e = [], n = [], s = $(this._univerInstanceService);
    if (!s)
      return { undos: e, redos: n };
    const { unitId: r, subUnitId: a } = s, o = this._tableManager.getTablesBySubunitId(r, a);
    if (!o.length)
      return { undos: e, redos: n };
    const { range: u } = t;
    return o.forEach((l) => {
      const i = l.getRange();
      if (u.startRow > i.startRow && u.startRow <= i.endRow) {
        const h = u.endRow - u.startRow + 1;
        n.push({
          id: S.id,
          params: {
            unitId: r,
            subUnitId: a,
            tableId: l.getId(),
            config: {
              updateRange: {
                newRange: {
                  ...i,
                  endRow: i.endRow + h
                }
              }
            }
          }
        }), e.push({
          id: S.id,
          params: {
            unitId: r,
            subUnitId: a,
            tableId: l.getId(),
            config: {
              updateRange: {
                newRange: {
                  ...i
                }
              }
            }
          }
        });
      }
    }), { undos: e, redos: n };
  }
  _generateTableMutationWithInsertCol(t) {
    const e = [], n = [], s = $(this._univerInstanceService);
    if (!s)
      return { undos: e, redos: n };
    const { unitId: r, subUnitId: a } = s, o = this._tableManager.getTablesBySubunitId(r, a);
    if (!o.length)
      return { undos: e, redos: n };
    const { range: u } = t;
    return o.forEach((l) => {
      const i = l.getRange();
      if (u.startColumn > i.startColumn && u.startColumn <= i.endColumn) {
        const h = u.endColumn - u.startColumn + 1;
        n.push({
          id: S.id,
          params: {
            unitId: r,
            subUnitId: a,
            tableId: l.getId(),
            config: {
              rowColOperation: {
                operationType: M.Insert,
                rowColType: y.Col,
                index: u.startColumn,
                count: h
              }
            }
          }
        }), e.push({
          id: S.id,
          params: {
            unitId: r,
            subUnitId: a,
            tableId: l.getId(),
            config: {
              rowColOperation: {
                operationType: M.Delete,
                rowColType: y.Col,
                index: u.startColumn,
                count: h
              }
            }
          }
        });
      }
    }), { undos: e, redos: n };
  }
  _generateTableMutationWithRemoveRow(t) {
    const e = [], n = [], s = [], r = [], a = $(this._univerInstanceService);
    if (!a)
      return { undos: e, redos: n, preRedos: s, preUndos: r };
    const { unitId: o, subUnitId: u } = a, l = this._tableManager.getTablesBySubunitId(o, u);
    if (!l.length)
      return { undos: e, redos: n, preRedos: s, preUndos: r };
    const { range: i } = t, h = i.endRow - i.startRow + 1;
    return l.forEach((d) => {
      const c = d.getRange();
      if (Re.intersects(c, i))
        if (i.startRow <= c.startRow && i.endRow >= c.startRow) {
          s.push({
            id: Q.id,
            params: {
              unitId: o,
              subUnitId: u,
              tableId: d.getId()
            }
          });
          const g = d.toJSON();
          e.push({
            id: k.id,
            params: {
              unitId: o,
              subUnitId: u,
              tableId: g.id,
              name: g.name,
              range: g.range,
              options: g.options
            }
          });
        } else i.startRow > c.startRow && i.startRow <= c.endRow ? (n.push({
          id: S.id,
          params: {
            unitId: o,
            subUnitId: u,
            tableId: d.getId(),
            config: {
              updateRange: {
                newRange: {
                  ...c,
                  endRow: c.endRow - h
                }
              }
            }
          }
        }), e.push({
          id: S.id,
          params: {
            unitId: o,
            subUnitId: u,
            tableId: d.getId(),
            config: {
              updateRange: {
                newRange: {
                  ...c
                }
              }
            }
          }
        })) : i.startRow < c.endRow && i.endRow >= c.endRow && (n.push({
          id: S.id,
          params: {
            unitId: o,
            subUnitId: u,
            tableId: d.getId(),
            config: {
              updateRange: {
                newRange: {
                  ...c,
                  endRow: i.startRow - 1
                }
              }
            }
          }
        }), e.push({
          id: S.id,
          params: {
            unitId: o,
            subUnitId: u,
            tableId: d.getId(),
            config: {
              updateRange: {
                newRange: {
                  ...c
                }
              }
            }
          }
        }));
    }), { undos: e, redos: n, preRedos: s, preUndos: r };
  }
  _generateTableMutationWithRemoveCol(t) {
    const e = [], n = [], s = [], r = [], a = $(this._univerInstanceService);
    if (!a)
      return { undos: e, redos: n, preRedos: s, preUndos: r };
    const { unitId: o, subUnitId: u } = a, l = this._tableManager.getTablesBySubunitId(o, u);
    if (!l.length)
      return { undos: e, redos: n, preRedos: s, preUndos: r };
    const { range: i } = t, h = i.endColumn - i.startColumn + 1;
    return l.forEach((d) => {
      const c = d.getRange();
      if (Re.intersects(c, i)) {
        if (i.startColumn <= c.startColumn && i.endColumn >= c.endColumn) {
          s.push({
            id: Q.id,
            params: {
              unitId: o,
              subUnitId: u,
              tableId: d.getId()
            }
          });
          const g = d.toJSON(), { startRow: R, startColumn: w, endColumn: p } = g.range, f = this._univerInstanceService.getUnit(o), I = f == null ? void 0 : f.getSheetBySheetId(u);
          if (!I)
            return { undos: e, redos: n, preRedos: s, preUndos: r };
          const U = [];
          for (let T = w; T <= p; T++)
            U.push(Ke(I == null ? void 0 : I.getCell(R, T)) || te(T - w + 1, this._localeService.t("sheets-table.columnPrefix")));
          e.push({
            id: k.id,
            params: {
              unitId: o,
              subUnitId: u,
              tableId: g.id,
              name: g.name,
              header: U,
              range: g.range,
              options: g.options
            }
          });
        } else if (i.startColumn <= c.startColumn && i.endColumn >= c.startColumn) {
          const g = i.endColumn - c.startColumn + 1;
          n.push({
            id: S.id,
            params: {
              unitId: o,
              subUnitId: u,
              tableId: d.getId(),
              config: {
                rowColOperation: {
                  operationType: M.Delete,
                  rowColType: y.Col,
                  index: c.startColumn,
                  count: g
                }
              }
            }
          });
          const R = [];
          for (let w = 0; w < g; w++) {
            const p = d.getTableColumnByIndex(w);
            p && R.push(p.toJSON());
          }
          e.push({
            id: S.id,
            params: {
              unitId: o,
              subUnitId: u,
              tableId: d.getId(),
              config: {
                rowColOperation: {
                  operationType: M.Insert,
                  rowColType: y.Col,
                  index: c.startColumn,
                  count: g,
                  columnsJson: R
                }
              }
            }
          });
        } else if (i.startColumn > c.startColumn && i.endColumn > c.endColumn) {
          const g = c.endColumn - i.startColumn + 1;
          n.push({
            id: S.id,
            params: {
              unitId: o,
              subUnitId: u,
              tableId: d.getId(),
              config: {
                rowColOperation: {
                  operationType: M.Delete,
                  rowColType: y.Col,
                  index: i.startColumn,
                  count: g
                }
              }
            }
          });
          const R = [], w = i.startColumn - c.startColumn;
          for (let p = 0; p < g; p++) {
            const f = d.getTableColumnByIndex(p + w);
            f && R.push(f.toJSON());
          }
          e.push({
            id: S.id,
            params: {
              unitId: o,
              subUnitId: u,
              tableId: d.getId(),
              config: {
                rowColOperation: {
                  operationType: M.Insert,
                  rowColType: y.Col,
                  index: i.startColumn,
                  count: h,
                  columnsJson: R
                }
              }
            }
          });
        } else if (i.startColumn > c.startColumn && i.endColumn <= c.endColumn) {
          n.push({
            id: S.id,
            params: {
              unitId: o,
              subUnitId: u,
              tableId: d.getId(),
              config: {
                rowColOperation: {
                  operationType: M.Delete,
                  rowColType: y.Col,
                  index: i.startColumn,
                  count: h
                }
              }
            }
          });
          const g = [], R = i.startColumn - c.startColumn;
          for (let w = 0; w < h; w++) {
            const p = d.getTableColumnByIndex(w + R);
            p && g.push(p.toJSON());
          }
          e.push({
            id: S.id,
            params: {
              unitId: o,
              subUnitId: u,
              tableId: d.getId(),
              config: {
                rowColOperation: {
                  operationType: M.Insert,
                  rowColType: y.Col,
                  index: i.startColumn,
                  count: h,
                  columnsJson: g
                }
              }
            }
          });
        }
      }
    }), { undos: e, redos: n, preRedos: s, preUndos: r };
  }
  _initCommandListener() {
    this._commandService.onCommandExecuted((t) => {
      if (t.id === ke.id) {
        const e = t.params, { unitId: n, subUnitId: s, range: r } = e, a = r.endRow - r.startRow + 1;
        this._tableManager.getTablesBySubunitId(n, s).forEach((u) => {
          const l = u.getRange();
          r.startRow <= l.startRow && this._tableManager.updateTableRange(n, u.getId(), {
            newRange: {
              ...l,
              startRow: l.startRow + a,
              endRow: l.endRow + a
            }
          });
        });
      } else if (t.id === Ye.id) {
        const e = t.params, { unitId: n, subUnitId: s, range: r } = e, a = r.endColumn - r.startColumn + 1;
        this._tableManager.getTablesBySubunitId(n, s).forEach((u) => {
          const l = u.getRange();
          r.startColumn <= l.startColumn && this._tableManager.updateTableRange(n, u.getId(), {
            newRange: {
              ...l,
              startColumn: l.startColumn + a,
              endColumn: l.endColumn + a
            }
          });
        });
      } else if (t.id === Qe.id) {
        const e = t.params, { unitId: n, subUnitId: s, range: r } = e, a = r.endRow - r.startRow + 1;
        this._tableManager.getTablesBySubunitId(n, s).forEach((u) => {
          const l = u.getRange();
          r.startRow < l.startRow && this._tableManager.updateTableRange(n, u.getId(), {
            newRange: {
              ...l,
              startRow: l.startRow - a,
              endRow: l.endRow - a
            }
          });
        });
      } else if (t.id === Ge.id) {
        const e = t.params, { unitId: n, subUnitId: s, range: r } = e, a = r.endColumn - r.startColumn + 1;
        this._tableManager.getTablesBySubunitId(n, s).forEach((u) => {
          const l = u.getRange();
          r.startColumn < l.startColumn && this._tableManager.updateTableRange(n, u.getId(), {
            newRange: {
              ...l,
              startColumn: l.startColumn - a,
              endColumn: l.endColumn - a
            }
          });
        });
      }
    });
  }
};
he = Xn([
  V(0, _(D)),
  V(1, _(wt)),
  V(2, _(B)),
  V(3, _(We)),
  V(4, _(Ce)),
  V(5, _(C)),
  V(6, _(be))
], he);
var Zn = Object.getOwnPropertyDescriptor, es = (t, e, n, s) => {
  for (var r = s > 1 ? void 0 : s ? Zn(e, n) : e, a = t.length - 1, o; a >= 0; a--)
    (o = t[a]) && (r = o(r) || r);
  return r;
}, oe = (t, e) => (n, s) => e(n, s, t);
let ge = class extends H {
  constructor(e, n, s, r) {
    super();
    b(this, "_defaultThemeIndex", 0);
    b(this, "_allThemes", []);
    this._tableManager = e, this._sheetRangeThemeService = n, this._sheetRangeThemeModel = s, this._configService = r, this._initUserTableTheme(), this.registerTableChangeEvent(), this._initDefaultTableTheme();
  }
  registerTableChangeEvent() {
    this.disposeWithMe(
      this._tableManager.tableAdd$.subscribe((e) => {
        const { range: n, tableId: s, unitId: r, subUnitId: a, tableStyleId: o } = e, u = this._tableManager.getTable(r, s), l = o || this._allThemes[this._defaultThemeIndex].name;
        u.setTableStyleId(l), this._sheetRangeThemeService.registerRangeThemeStyle(l, {
          unitId: r,
          subUnitId: a,
          range: { ...n }
        });
      })
    ), this.disposeWithMe(
      this._tableManager.tableRangeChanged$.subscribe((e) => {
        const { range: n, oldRange: s, tableId: r, unitId: a, subUnitId: o } = e, u = this._tableManager.getTable(a, r);
        let l = u.getTableStyleId();
        l || (l = this._allThemes[this._defaultThemeIndex].name, u.setTableStyleId(l)), this._sheetRangeThemeService.removeRangeThemeRule(l, {
          unitId: a,
          subUnitId: o,
          range: { ...s }
        }), this._sheetRangeThemeService.registerRangeThemeStyle(l, {
          unitId: a,
          subUnitId: o,
          range: { ...n }
        });
      })
    ), this.disposeWithMe(
      this._tableManager.tableThemeChanged$.subscribe((e) => {
        const { theme: n, oldTheme: s, tableId: r, unitId: a, subUnitId: o } = e, l = this._tableManager.getTable(a, r).getRange();
        this._sheetRangeThemeService.removeRangeThemeRule(s, {
          unitId: a,
          subUnitId: o,
          range: { ...l }
        }), this._sheetRangeThemeService.registerRangeThemeStyle(n, {
          unitId: a,
          subUnitId: o,
          range: { ...l }
        });
      })
    ), this.disposeWithMe(
      this._tableManager.tableDelete$.subscribe((e) => {
        const { range: n, unitId: s, subUnitId: r, tableStyleId: a = this._allThemes[this._defaultThemeIndex].name } = e;
        this._sheetRangeThemeService.removeRangeThemeRule(a, {
          unitId: s,
          subUnitId: r,
          range: { ...n }
        });
      })
    );
  }
  _initUserTableTheme() {
    const e = this._configService.getConfig(Xe) || {}, n = e.defaultThemeIndex || 0, s = e.userThemes || [];
    this._defaultThemeIndex = n, this._allThemes = s.concat(Ze);
  }
  _initDefaultTableTheme() {
    for (let e = 0; e < this._allThemes.length; e++) {
      const { name: n, style: s } = this._allThemes[e], r = new Ct(n, s);
      this._sheetRangeThemeModel.registerDefaultRangeTheme(r);
    }
  }
  dispose() {
    super.dispose(), this._allThemes = [], this._defaultThemeIndex = 0;
  }
};
ge = es([
  oe(0, _(C)),
  oe(1, _(_t)),
  oe(2, _(Je)),
  oe(3, He)
], ge);
var ts = Object.getOwnPropertyDescriptor, ns = (t, e, n, s) => {
  for (var r = s > 1 ? void 0 : s ? ts(e, n) : e, a = t.length - 1, o; a >= 0; a--)
    (o = t[a]) && (r = o(r) || r);
  return r;
}, ie = (t, e) => (n, s) => e(n, s, t);
let me = class extends H {
  constructor(e, n, s, r) {
    super();
    b(this, "_tableFilteredOutRows$", new ze(/* @__PURE__ */ new Set()));
    b(this, "tableFilteredOutRows$", this._tableFilteredOutRows$.asObservable());
    b(this, "_subscription", null);
    this._tableManager = e, this._sheetInterceptorService = n, this._univerInstanceService = s, this._zebraCrossingCacheController = r, this.registerFilterChangeEvent(), this.initTableHiddenRowIntercept(), this._initFilteredOutRows();
  }
  get tableFilteredOutRows() {
    return this._tableFilteredOutRows$.value;
  }
  set tableFilteredOutRows(e) {
    this._tableFilteredOutRows$.next(e);
  }
  initTableHiddenRowIntercept() {
    this.disposeWithMe(this._sheetInterceptorService.intercept(Ve.ROW_FILTERED, {
      // sheetnext,interceptor
      priority: 100,
      handler: (e, n, s) => {
        if (e) return !0;
        const r = this.tableFilteredOutRows.has(n.row);
        return r ? !0 : s(r);
      }
    }));
  }
  _initFilteredOutRows() {
    this._tableManager.tableInitStatus$.pipe(
      pe((e) => e),
      ve(() => this._univerInstanceService.getCurrentTypeOfUnit$(z.UNIVER_SHEET)),
      pe((e) => e != null),
      ve((e) => e.activeSheet$),
      pe((e) => e != null)
    ).subscribe(() => {
      const e = $(this._univerInstanceService);
      if (!e)
        return;
      const { unitId: n, subUnitId: s } = e;
      this.tableFilteredOutRows.clear(), this._tableManager.getTablesBySubunitId(n, s).forEach((a) => {
        const o = a.getTableFilters().getFilterOutRows();
        if (o)
          for (const u of o)
            this.tableFilteredOutRows.add(u);
      });
    });
  }
  registerFilterChangeEvent() {
    this.disposeWithMe(
      this._tableManager.tableFilterChanged$.subscribe((e) => {
        var i;
        const { unitId: n, subUnitId: s, tableId: r } = e, a = (i = this._univerInstanceService.getUnit(n)) == null ? void 0 : i.getSheetBySheetId(s), o = this._tableManager.getTable(n, r);
        if (!a || !o)
          return;
        this.tableFilteredOutRows.clear(), o.getTableFilters().doFilter(a, o.getTableFilterRange()), this._tableManager.getTablesBySubunitId(n, s).forEach((h) => {
          const d = h.getTableFilters().getFilterOutRows();
          if (d)
            for (const c of d)
              this.tableFilteredOutRows.add(c);
        }), this._zebraCrossingCacheController.updateZebraCrossingCache(n, s);
      })
    );
  }
  dispose() {
    var e;
    super.dispose(), (e = this._subscription) == null || e.unsubscribe();
  }
};
me = ns([
  ie(0, _(C)),
  ie(1, _(Ce)),
  ie(2, _(B)),
  ie(3, _(Tt))
], me);
var ss = Object.getOwnPropertyDescriptor, rs = (t, e, n, s) => {
  for (var r = s > 1 ? void 0 : s ? ss(e, n) : e, a = t.length - 1, o; a >= 0; a--)
    (o = t[a]) && (r = o(r) || r);
  return r;
}, Se = (t, e) => (n, s) => e(n, s, t), le;
let Ee = (le = class extends ct {
  constructor(t = De, e, n, s) {
    super(), this._config = t, this._injector = e, this._configService = n, this._commandService = s;
    const { ...r } = dt(
      {},
      De,
      this._config
    );
    this._configService.setConfig(Xe, r), this._initRegisterCommand();
  }
  onStarting() {
    ht(this._injector, [
      [C],
      [ge],
      [W],
      [X],
      [me],
      [de],
      [he],
      [ce]
    ]);
  }
  onReady() {
    Me(this._injector, [
      [ce],
      [de],
      [he],
      [ge],
      [W],
      [X],
      [me]
    ]), Me(this._injector, [
      [C]
    ]);
  }
  _initRegisterCommand() {
    [
      $n,
      k,
      An,
      Q,
      _e,
      Bn,
      Pn,
      S,
      Hn,
      Vn,
      qn,
      Jn,
      kn,
      Qn
    ].forEach((t) => this._commandService.registerCommand(t));
  }
}, b(le, "pluginName", nt), b(le, "type", z.UNIVER_SHEET), le);
Ee = rs([
  Se(1, _(We)),
  Se(2, He),
  Se(3, _(D))
], Ee);
export {
  $n as AddSheetTableCommand,
  k as AddSheetTableMutation,
  Hn as AddTableThemeCommand,
  An as DeleteSheetTableCommand,
  Q as DeleteSheetTableMutation,
  Vn as RemoveTableThemeCommand,
  En as SHEET_TABLE_CUSTOM_THEME_PREFIX,
  Pn as SetSheetTableCommand,
  Bn as SetSheetTableFilterCommand,
  _e as SetSheetTableFilterMutation,
  S as SetSheetTableMutation,
  Jn as SheetTableInsertColCommand,
  qn as SheetTableInsertRowCommand,
  Qn as SheetTableRemoveColCommand,
  kn as SheetTableRemoveRowCommand,
  X as SheetTableService,
  q as SheetsTableButtonStateEnum,
  W as SheetsTableController,
  G as SheetsTableSortStateEnum,
  je as TableColumnDataTypeEnum,
  ne as TableColumnFilterTypeEnum,
  O as TableConditionTypeEnum,
  m as TableDateCompareTypeEnum,
  C as TableManager,
  F as TableNumberCompareTypeEnum,
  P as TableStringCompareTypeEnum,
  Ee as UniverSheetsTablePlugin,
  hs as customEmptyThemeWithBorderStyle,
  Ft as isConditionFilter,
  ds as isManualFilter,
  gs as processStyleWithBorderStyle
};
