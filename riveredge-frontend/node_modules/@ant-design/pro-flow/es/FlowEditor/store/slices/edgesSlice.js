import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
var _excluded = ["type"];
import { convertEdgeChange } from "../../utils/convertChange";
import { generateEdgeId } from "../../utils/edge";
import isEqual from 'fast-deep-equal';
import { edgesReducer } from "../reducers/edge";
export var edgesSlice = function edgesSlice(set, get) {
  return {
    internalUpdateEdges: function internalUpdateEdges(flattenEdges, payload) {
      var _get$onFlattenEdgesCh, _get;
      set({
        flattenEdges: flattenEdges
      }, false, payload);
      (_get$onFlattenEdgesCh = (_get = get()).onFlattenEdgesChange) === null || _get$onFlattenEdgesCh === void 0 || _get$onFlattenEdgesCh.call(_get, flattenEdges);
    },
    dispatchEdges: function dispatchEdges(payload) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
          recordHistory: true
        },
        _ref$recordHistory = _ref.recordHistory,
        recordHistory = _ref$recordHistory === void 0 ? true : _ref$recordHistory;
      var type = payload.type,
        res = _objectWithoutProperties(payload, _excluded);
      var _get2 = get(),
        beforeEdgesChange = _get2.beforeEdgesChange,
        onEdgesChange = _get2.onEdgesChange,
        afterEdgesChange = _get2.afterEdgesChange,
        internalUpdateEdges = _get2.internalUpdateEdges,
        yjsDoc = _get2.yjsDoc;
      var changes = convertEdgeChange(payload);
      var flattenEdges = edgesReducer(get().flattenEdges, payload);
      if (isEqual(flattenEdges, get().flattenEdges)) return;
      if (beforeEdgesChange && !beforeEdgesChange(changes)) {
        return;
      }
      if (onEdgesChange) {
        onEdgesChange(changes);
      }
      if (afterEdgesChange) {
        afterEdgesChange(changes);
      }
      internalUpdateEdges(flattenEdges, {
        type: "dispatchFlattenEdges/".concat(type),
        payload: res
      });
      if (recordHistory) {
        yjsDoc.recordHistoryData({
          flattenEdges: flattenEdges
        }, {
          type: 'edge',
          name: payload.type,
          timestamp: Date.now()
        });
      }
    },
    addEdge: function addEdge(edge) {
      get().dispatchEdges({
        type: 'addEdge',
        edge: edge
      });
    },
    addEdges: function addEdges(edges, options) {
      var _edges = Array.isArray(edges) ? edges.reduce(function (acc, edge) {
        acc[edge.id] = edge;
        return acc;
      }, {}) : edges;
      get().dispatchEdges({
        type: 'addEdges',
        edges: _edges
      }, options);
    },
    updateEdgesOnConnection: function updateEdgesOnConnection(connection) {
      var source = connection.source,
        target = connection.target,
        sourceHandle = connection.sourceHandle,
        targetHandle = connection.targetHandle;
      if (!source || !target) return;
      var edgeId = generateEdgeId(source, target, sourceHandle, targetHandle);
      var edge = {
        id: edgeId,
        source: source,
        target: target,
        sourceHandle: sourceHandle,
        targetHandle: targetHandle
      };
      get().dispatchEdges({
        type: 'addEdge',
        edge: edge
      });
      return edge;
    },
    updateEdgesOnEdgeChange: function updateEdgesOnEdgeChange(changes) {
      changes.forEach(function (e) {
        switch (e.type) {
          case 'remove':
            get().deselectElement(e.id);
            get().dispatchEdges({
              type: 'deleteEdge',
              id: e.id
            });
        }
      });
    },
    deleteEdge: function deleteEdge(id) {
      get().deselectElement(id);
      get().dispatchEdges({
        type: 'deleteEdge',
        id: id
      });
    },
    deleteEdges: function deleteEdges(ids) {
      ids.forEach(function (id) {
        get().deselectElement(id);
        get().dispatchEdges({
          type: 'deleteEdge',
          id: id
        });
      });
    },
    updateEdgeData: function updateEdgeData(id, newData) {
      var deepReplace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var options = arguments.length > 3 ? arguments[3] : undefined;
      get().dispatchEdges({
        type: 'updateEdgeData',
        id: id,
        newData: newData,
        deepReplace: deepReplace
      }, options);
    },
    updateEdge: function updateEdge(id, edgeData, options) {
      get().dispatchEdges({
        type: 'updateEdge',
        id: id,
        edge: edgeData
      }, options);
    },
    handleEdgesChange: function handleEdgesChange(changes) {
      var _get3 = get(),
        dispatchEdges = _get3.dispatchEdges,
        onElementSelectChange = _get3.onElementSelectChange,
        beforeEdgesChange = _get3.beforeEdgesChange,
        onEdgesChange = _get3.onEdgesChange,
        afterEdgesChange = _get3.afterEdgesChange,
        deselectElement = _get3.deselectElement;
      changes.forEach(function (c) {
        switch (c.type) {
          case 'add':
            dispatchEdges({
              type: 'addEdge',
              edge: c.item
            });
            break;
          case 'remove':
            deselectElement(c.id);
            dispatchEdges({
              type: 'deleteEdge',
              id: c.id
            });
            break;
          case 'select':
            if (beforeEdgesChange && !beforeEdgesChange(changes)) {
              return;
            }
            if (onEdgesChange) {
              onEdgesChange(changes);
            }
            onElementSelectChange(c.id, c.selected);
            if (afterEdgesChange) {
              afterEdgesChange(changes);
            }
        }
      });
    }
  };
};