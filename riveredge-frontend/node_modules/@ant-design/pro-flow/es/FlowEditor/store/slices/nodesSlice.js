import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
var _excluded = ["type"];
import isEqual from 'fast-deep-equal';
import { convertNodeChange } from "../../utils/convertChange";
import { nodeReducer } from "../reducers/node";

/**
 * 公共节点操作接口
 */

export var nodesSlice = function nodesSlice(set, get) {
  return {
    internalUpdateNodes: function internalUpdateNodes(flattenNodes, payload) {
      var _get$onFlattenNodesCh, _get;
      if (isEqual(flattenNodes, get().flattenNodes)) return;
      set({
        flattenNodes: flattenNodes
      }, false, payload);
      (_get$onFlattenNodesCh = (_get = get()).onFlattenNodesChange) === null || _get$onFlattenNodesCh === void 0 || _get$onFlattenNodesCh.call(_get, flattenNodes);
    },
    dispatchNodes: function dispatchNodes(payload) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
          recordHistory: true
        },
        _ref$recordHistory = _ref.recordHistory,
        recordHistory = _ref$recordHistory === void 0 ? true : _ref$recordHistory;
      var _get2 = get(),
        beforeNodesChange = _get2.beforeNodesChange,
        onNodesChange = _get2.onNodesChange,
        afterNodesChange = _get2.afterNodesChange,
        internalUpdateNodes = _get2.internalUpdateNodes,
        yjsDoc = _get2.yjsDoc;
      var type = payload.type,
        res = _objectWithoutProperties(payload, _excluded);
      var changes = convertNodeChange(payload);
      var flattenNodes = nodeReducer(get().flattenNodes, payload);
      if (isEqual(flattenNodes, get().flattenNodes)) return;
      if (beforeNodesChange && !beforeNodesChange(changes)) {
        return;
      }
      if (onNodesChange) {
        onNodesChange(changes);
      }
      if (afterNodesChange) {
        afterNodesChange(changes);
      }
      internalUpdateNodes(flattenNodes, {
        type: "dispatchFlattenNodes/".concat(type),
        payload: res
      });
      if (recordHistory) {
        yjsDoc.recordHistoryData({
          flattenNodes: flattenNodes
        }, {
          type: 'nodes',
          name: payload.type,
          timestamp: Date.now()
        });
      }
    },
    updateNodeMeta: function updateNodeMeta(id, key, value, options) {
      get().dispatchNodes({
        type: 'updateNodeMeta',
        id: id,
        key: key,
        value: value
      }, options);
    },
    updateNodeState: function updateNodeState(id, key, value, options) {
      get().dispatchNodes({
        type: 'updateNodeState',
        id: id,
        key: key,
        value: value
      }, options);
    },
    updateNodeContent: function updateNodeContent(id, key, value, options) {
      get().dispatchNodes({
        type: 'updateNodeContent',
        id: id,
        key: key,
        value: value
      }, options);
    },
    updateNodeData: function updateNodeData(id, newData) {
      var deepReplace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var options = arguments.length > 3 ? arguments[3] : undefined;
      get().dispatchNodes({
        type: 'updateNodeData',
        id: id,
        newData: newData,
        deepReplace: deepReplace
      }, options);
    },
    addNode: function addNode(node) {
      get().dispatchNodes({
        type: 'addNode',
        node: node
      });
    },
    addNodes: function addNodes(nodes, options) {
      var _nodes = Array.isArray(nodes) ? nodes.reduce(function (acc, node) {
        acc[node.id] = node;
        return acc;
      }, {}) : nodes;
      get().dispatchNodes({
        type: 'addNodes',
        nodes: _nodes
      }, options);
    },
    deleteNode: function deleteNode(id) {
      get().deselectElement(id);
      get().dispatchNodes({
        type: 'deleteNode',
        id: id
      });
    },
    deleteNodes: function deleteNodes(ids) {
      ids.forEach(function (id) {
        get().deselectElement(id);
        get().dispatchNodes({
          type: 'deleteNode',
          id: id
        });
      });
    },
    handleNodesChange: function handleNodesChange(changes) {
      var _get3 = get(),
        dispatchNodes = _get3.dispatchNodes,
        onElementSelectChange = _get3.onElementSelectChange,
        deselectElement = _get3.deselectElement,
        beforeNodesChange = _get3.beforeNodesChange,
        onNodesChange = _get3.onNodesChange,
        afterNodesChange = _get3.afterNodesChange;
      changes.forEach(function (c) {
        switch (c.type) {
          case 'add':
            dispatchNodes({
              type: 'addNode',
              node: c.item
            });
            break;
          case 'position':
            // 结束拖拽时，会触发一次 position，此时 dragging 为 false
            if (!c.dragging) break;
            dispatchNodes({
              type: 'updateNodePosition',
              position: c.position,
              id: c.id
            });
            break;
          case 'remove':
            deselectElement(c.id);
            dispatchNodes({
              type: 'deleteNode',
              id: c.id
            });
            break;
          case 'select':
            if (beforeNodesChange && !beforeNodesChange(changes)) {
              return;
            }
            if (onNodesChange) {
              onNodesChange(changes);
            }
            onElementSelectChange(c.id, c.selected);
            if (afterNodesChange) {
              afterNodesChange(changes);
            }
        }
      });
    }
  };
};