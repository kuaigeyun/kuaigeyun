import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _typeof from "@babel/runtime/helpers/esm/typeof";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { produce } from 'immer';
import { merge } from 'lodash-es';
export var edgesReducer = function edgesReducer(state, payload) {
  switch (payload.type) {
    case 'addEdge':
      return produce(state, function (draftState) {
        draftState[payload.edge.id] = payload.edge;
      });
    case 'addEdges':
      return produce(state, function (draftState) {
        var edges = payload.edges;
        if (!edges) return;
        if (Array.isArray(edges)) {
          edges.forEach(function (edge) {
            draftState[edge.id] = edge;
          });
        } else if (_typeof(edges) === 'object') {
          Object.keys(edges).forEach(function (id) {
            if (!draftState[id]) {
              draftState[id] = edges[id];
            }
          });
        }
      });
    case 'updateEdge':
      return produce(state, function (draftState) {
        var id = payload.id,
          edge = payload.edge;
        draftState[id] = _objectSpread(_objectSpread({}, draftState[id]), edge);
      });
    case 'updateEdgeData':
      return produce(state, function (draftState) {
        var newData = payload.newData,
          id = payload.id,
          deepReplace = payload.deepReplace;
        draftState[id] = _objectSpread(_objectSpread({}, draftState[id]), {}, {
          data: newData
        });
        if (!draftState[id]) return;
        var edge = draftState[id];
        if (!deepReplace) {
          draftState[id] = _objectSpread(_objectSpread(_objectSpread({}, draftState[id]), edge), {}, {
            data: merge(edge.data, newData)
          });
        } else {
          draftState[id] = _objectSpread(_objectSpread(_objectSpread({}, draftState[id]), edge), {}, {
            data: _objectSpread(_objectSpread({}, edge.data), newData)
          });
        }
      });
    case 'deleteEdge':
      return produce(state, function (draftState) {
        delete draftState[payload.id];
      });
    case 'createEdgeFromConnection':
      return produce(state, function (draftState) {
        var edge = payload.edge;
        draftState[edge.id] = edge;
      });
    default:
      return state;
  }
};