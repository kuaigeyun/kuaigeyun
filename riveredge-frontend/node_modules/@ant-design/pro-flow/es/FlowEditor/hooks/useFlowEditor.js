import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
var _excluded = ["yjsDoc", "flattenEdges", "selectedKeys", "onFlattenNodesChange", "onEdgesChange", "onFlattenEdgesChange", "onNodesChange", "beforeNodesChange", "afterNodesChange", "onViewPortChange", "onNodesTreeChange", "onSelectionChange", "onElementSelectChange", "updateEdgesOnEdgeChange", "updateEdgesOnConnection", "internalUpdateEdges", "internalUpdateNodes", "internalUpdateSelection"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { useMemoizedFn } from 'ahooks';
import { useCallback, useMemo } from 'react';
import { useReactFlow } from 'reactflow';
import { useStoreApi } from "../store";
export var useFlowEditor = function useFlowEditor() {
  var storeApi = useStoreApi();
  var reactFlowInstance = useReactFlow();

  /* eslint-disable @typescript-eslint/no-unused-vars */
  var _storeApi$getState = storeApi.getState(),
    yjsDoc = _storeApi$getState.yjsDoc,
    flattenEdges = _storeApi$getState.flattenEdges,
    selectedKeys = _storeApi$getState.selectedKeys,
    onFlattenNodesChange = _storeApi$getState.onFlattenNodesChange,
    onEdgesChange = _storeApi$getState.onEdgesChange,
    onFlattenEdgesChange = _storeApi$getState.onFlattenEdgesChange,
    onNodesChange = _storeApi$getState.onNodesChange,
    beforeNodesChange = _storeApi$getState.beforeNodesChange,
    afterNodesChange = _storeApi$getState.afterNodesChange,
    onViewPortChange = _storeApi$getState.onViewPortChange,
    onNodesTreeChange = _storeApi$getState.onNodesTreeChange,
    onSelectionChange = _storeApi$getState.onSelectionChange,
    onElementSelectChange = _storeApi$getState.onElementSelectChange,
    updateEdgesOnEdgeChange = _storeApi$getState.updateEdgesOnEdgeChange,
    updateEdgesOnConnection = _storeApi$getState.updateEdgesOnConnection,
    internalUpdateEdges = _storeApi$getState.internalUpdateEdges,
    internalUpdateNodes = _storeApi$getState.internalUpdateNodes,
    internalUpdateSelection = _storeApi$getState.internalUpdateSelection,
    instance = _objectWithoutProperties(_storeApi$getState, _excluded);
  /* eslint-enable */

  var getFlattenNodes = useMemoizedFn(function () {
    return storeApi.getState().flattenNodes;
  });
  var getFlattenEdges = useMemoizedFn(function () {
    return storeApi.getState().flattenEdges;
  });
  var getSelectedKeys = useMemoizedFn(function () {
    return storeApi.getState().selectedKeys;
  });
  var screenToFlowPosition = useCallback(function (position) {
    if (!reactFlowInstance) return {
      x: 0,
      y: 0
    };
    return reactFlowInstance.screenToFlowPosition(position);
  }, [reactFlowInstance]);
  return useMemo(function () {
    return _objectSpread(_objectSpread({}, instance), {}, {
      screenToFlowPosition: screenToFlowPosition,
      getFlattenNodes: getFlattenNodes,
      getSelectedKeys: getSelectedKeys,
      getFlattenEdges: getFlattenEdges
    });
  }, [instance]);
};