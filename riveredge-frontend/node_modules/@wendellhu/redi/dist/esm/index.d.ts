//#region src/dependencyLookUp.d.ts
interface SkipSelfDecorator {
  (): any;
  new (): SkipSelfDecorator;
}
/**
 * when resolving this dependency, skip the current injector
 */
declare const SkipSelf: SkipSelfDecorator;
interface SelfDecorator {
  (): any;
  new (): SelfDecorator;
}
/**
 * when resolving this dependency, only search the current injector
 */
declare const Self: SelfDecorator;
//#endregion
//#region src/error.d.ts
declare class RediError extends Error {
  constructor(message: string);
}
//#endregion
//#region src/types.d.ts
declare enum Quantity {
  MANY = "many",
  OPTIONAL = "optional",
  REQUIRED = "required",
}
declare enum LookUp {
  SELF = "self",
  SKIP_SELF = "skipSelf",
}
//#endregion
//#region src/dependencyQuantity.d.ts
interface ManyDecorator {
  (id?: DependencyIdentifier<any>): any;
  new (): ManyDecorator;
}
declare const Many: ManyDecorator;
interface OptionalDecorator {
  (id?: DependencyIdentifier<any>): any;
  new (): OptionalDecorator;
}
declare const Optional: OptionalDecorator;
interface InjectDecorator {
  (id: DependencyIdentifier<any>): any;
  new (): InjectDecorator;
}
declare const Inject: InjectDecorator;
//#endregion
//#region src/dependencyWithNew.d.ts
interface ToSelfDecorator {
  (): any;
  new (): ToSelfDecorator;
}
/**
 * Always initialize a new instance of that dependency instead of getting the
 * cached instance from the injector.
 */
declare const WithNew: ToSelfDecorator;
//#endregion
//#region src/dependencyItem.d.ts
interface Ctor<T> {
  new (...args: any[]): T;
  name: string;
}
declare function isCtor<T>(thing: unknown): thing is Ctor<T>;
interface DependencyItemHooks<T> {
  onInstantiation?: (instance: T) => void;
}
interface ClassDependencyItem<T> extends DependencyItemHooks<T> {
  useClass: Ctor<T>;
  lazy?: boolean;
}
declare function isClassDependencyItem<T>(thing: unknown): thing is ClassDependencyItem<T>;
type FactoryDepModifier = typeof Self | typeof SkipSelf | typeof Optional | typeof Many | typeof WithNew;
type FactoryDep<T> = [...FactoryDepModifier[], DependencyIdentifier<T>] | DependencyIdentifier<T>;
interface FactoryDependencyItem<T> extends DependencyItemHooks<T> {
  useFactory: (...deps: any[]) => T;
  dynamic?: true;
  deps?: FactoryDep<any>[];
}
declare function isFactoryDependencyItem<T>(thing: unknown): thing is FactoryDependencyItem<T>;
interface ValueDependencyItem<T> extends DependencyItemHooks<T> {
  useValue: T;
}
declare function isValueDependencyItem<T>(thing: unknown): thing is ValueDependencyItem<T>;
/**
 * Reuse an existing dependency. You can consider it as an alias to another dependency.
 */
interface ExistingDependencyItem<T> extends DependencyItemHooks<T> {
  /**
   * The identifier of the existing dependency.
   */
  useExisting: DependencyIdentifier<T>;
}
interface AsyncDependencyItem<T> extends DependencyItemHooks<T> {
  useAsync: () => Promise<T | Ctor<T> | [DependencyIdentifier<T>, SyncDependencyItem<T>]>;
}
declare function isAsyncDependencyItem<T>(thing: unknown): thing is AsyncDependencyItem<T>;
declare const AsyncHookSymbol: unique symbol;
interface AsyncHook<T> {
  __symbol: typeof AsyncHookSymbol;
  whenReady: () => Promise<T>;
}
declare function isAsyncHook<T>(thing: unknown): thing is AsyncHook<T>;
type SyncDependencyItem<T> = ClassDependencyItem<T> | FactoryDependencyItem<T> | ExistingDependencyItem<T> | ValueDependencyItem<T>;
type DependencyItem<T> = SyncDependencyItem<T> | AsyncDependencyItem<T>;
//#endregion
//#region src/dependencyForwardRef.d.ts
interface ForwardRef<T> {
  unwrap: () => Ctor<T>;
}
declare function forwardRef<T>(wrapper: () => Ctor<T>): ForwardRef<T>;
//#endregion
//#region src/dependencyIdentifier.d.ts
declare const IdentifierDecoratorSymbol: unique symbol;
interface IdentifierDecorator<T> {
  [IdentifierDecoratorSymbol]: true;
  (...args: any[]): void;
  decoratorName: string;
  toString: () => string;
  type: T;
}
type DependencyIdentifier<T> = string | Ctor<T> | ForwardRef<T> | IdentifierDecorator<T>;
//#endregion
//#region src/decorators.d.ts
/**
 * Create a dependency identifier
 *
 * @param id name of the identifier
 * @returns Identifier that could also be used as a decorator
 */
declare function createIdentifier<T>(id: string): IdentifierDecorator<T>;
/**
 * @internal
 */
//#endregion
//#region src/dispose.d.ts
interface IDisposable {
  dispose: () => void;
}
declare function isDisposable(thing: unknown): thing is IDisposable;
//#endregion
//#region src/dependencyCollection.d.ts
type DependencyPair<T> = [DependencyIdentifier<T>, DependencyItem<T>];
type DependencyClass<T> = [Ctor<T>];
type Dependency<T = any> = DependencyPair<T> | DependencyClass<T>;
type DependencyWithInstance<T = any> = [Ctor<T> | DependencyIdentifier<T>, T];
type DependencyOrInstance<T = any> = Dependency<T> | DependencyWithInstance<T>;
//#endregion
//#region src/dependencyDeclare.d.ts
/**
 * Register dependencies on a class.
 *
 * @param registerTarget The target constructor
 * @param deps Dependencies
 * @param startIndex The start index of the dependencies. Default is 0. When you want to set dependencies on a class
 * that has custom parameters, you should set `startIndex` to the count of these custom parameters.
 */
declare function setDependencies<U>(registerTarget: Ctor<U>, deps: FactoryDep<any>[], startIndex?: number): void;
//#endregion
//#region src/injector.d.ts
interface IAccessor {
  get: Injector['get'];
  has: Injector['has'];
}
declare class Injector {
  private readonly parent;
  private readonly dependencyCollection;
  private readonly resolvedDependencyCollection;
  private readonly children;
  private resolutionOngoing;
  private disposingCallbacks;
  private disposed;
  /**
   * Create a new `Injector` instance
   * @param dependencies Dependencies that should be resolved by this injector instance.
   * @param parent Optional parent injector.
   */
  constructor(dependencies?: Dependency[], parent?: Injector | null);
  /**
   * Add a callback function that will be triggered when the Injector is disposed.
   * Please note that when you callback is invoked, the injector is already disposed and
   * you will not be able to interact with this Injector any more.
   *
   * @param {() => void} callback The callback function that will be invoked when
   * the Injector is disposed.
   * @returns A disposable that will remove the callback.
   */
  onDispose(callback: () => void): IDisposable;
  /**
   * Create a child inject with a set of dependencies.
   * @param dependencies Dependencies that should be resolved by the newly created child injector.
   * @returns The child injector.
   */
  createChild(dependencies?: Dependency[]): Injector;
  /**
   * Dispose the injector and all dependencies held by this injector. Note that its child injectors will dispose first.
   */
  dispose(): void;
  private deleteSelfFromParent;
  /**
   * Add a dependency or its instance into injector. It would throw an error if the dependency
   * has already been instantiated.
   *
   * @param dependency The dependency or an instance that would be add in the injector.
   */
  add<T>(dependency: DependencyOrInstance<T>): void;
  /**
   * Replace an injection mapping for interface-based injection. It would throw an error if the dependency
   * has already been instantiated.
   *
   * @param dependency The dependency that will replace the already existed dependency.
   */
  replace<T>(dependency: DependencyPair<T>): void;
  /**
   * Delete a dependency from an injector. It would throw an error when the deleted dependency
   * has already been instantiated.
   *
   * @param identifier The identifier of the dependency that is supposed to be deleted.
   */
  delete<T>(identifier: DependencyIdentifier<T>): void;
  /**
   * Invoke a function with dependencies injected. The function could only get dependency from the injector
   * and other methods are not accessible for the function.
   *
   * @param cb the function to be executed
   * @param args arguments to be passed into the function
   * @returns the return value of the function
   */
  invoke<T, P extends any[] = []>(cb: (accessor: IAccessor, ...args: P) => T, ...args: P): T;
  /**
   * Check if the injector could initialize a dependency.
   *
   * @param id Identifier of the dependency
   */
  has<T>(id: DependencyIdentifier<T>): boolean;
  get<T>(id: DependencyIdentifier<T>, lookUp?: LookUp): T;
  get<T>(id: DependencyIdentifier<T>, quantity: Quantity.MANY, lookUp?: LookUp): T[];
  get<T>(id: DependencyIdentifier<T>, quantity: Quantity.OPTIONAL, lookUp?: LookUp): T | null;
  get<T>(id: DependencyIdentifier<T>, quantity: Quantity.REQUIRED, lookUp?: LookUp): T;
  get<T>(id: DependencyIdentifier<T>, quantity?: Quantity, lookUp?: LookUp): T[] | T | null;
  get<T>(id: DependencyIdentifier<T>, quantityOrLookup?: Quantity | LookUp, lookUp?: LookUp): T[] | T | null;
  private _get;
  /**
   * Get a dependency in the async way.
   */
  getAsync<T>(id: DependencyIdentifier<T>): Promise<T>;
  /**
   * Instantiate a class. The created instance would not be held by the injector.
   */
  createInstance<T extends unknown[], U extends unknown[], C>(ctor: new (...args: [...T, ...U]) => C, ...customArgs: T): C;
  private _resolveDependency;
  private _resolveExisting;
  private _resolveValueDependency;
  private _resolveClass;
  private _resolveClassImpl;
  private _resolveFactory;
  private _resolveAsync;
  private _resolveAsyncImpl;
  private getValue;
  private createDependency;
  private markNewResolution;
  private markResolutionCompleted;
  private _ensureInjectorNotDisposed;
}
//#endregion
export { AsyncDependencyItem, AsyncHook, ClassDependencyItem, Ctor, Dependency, DependencyIdentifier, DependencyItem, DependencyPair, FactoryDependencyItem, IAccessor, IDisposable, IdentifierDecorator, Inject, Injector, LookUp, Many, Optional, Quantity, RediError, Self, SkipSelf, SyncDependencyItem, ValueDependencyItem, WithNew, createIdentifier, forwardRef, isAsyncDependencyItem, isAsyncHook, isClassDependencyItem, isCtor, isDisposable, isFactoryDependencyItem, isValueDependencyItem, setDependencies };
//# sourceMappingURL=index.d.ts.map