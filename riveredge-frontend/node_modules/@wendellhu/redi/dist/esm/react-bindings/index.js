import { Injector, Quantity, RediError } from "@wendellhu/redi";
import React, { createContext, useContext, useEffect, useLayoutEffect, useMemo, useRef, useState } from "react";
import { jsx } from "react/jsx-runtime";

//#region src/react-bindings/reactContext.tsx
const RediContext = createContext({ injector: null });
RediContext.displayName = "RediContext";
const RediProvider = RediContext.Provider;
const RediConsumer = RediContext.Consumer;

//#endregion
//#region src/react-bindings/reactComponent.tsx
function RediInjector(props) {
	const { children, dependencies } = props;
	const childInjectorRef = useRef(null);
	useEffect(() => () => childInjectorRef.current?.dispose(), []);
	return /* @__PURE__ */ jsx(RediConsumer, { children: (context) => {
		let childInjector;
		/* istanbul ignore next -- @preserve */
		if (childInjectorRef.current) childInjector = childInjectorRef.current;
		else {
			childInjector = context.injector ? context.injector.createChild(dependencies) : new Injector(dependencies);
			childInjectorRef.current = childInjector;
		}
		return /* @__PURE__ */ jsx(RediProvider, {
			value: { injector: childInjector },
			children
		});
	} });
}
/**
* @param Comp
* @param injector
* @returns A component type that can be rendered.
*/
function connectInjector(Comp, injector) {
	return function ComponentWithInjector(props) {
		return /* @__PURE__ */ jsx(RediProvider, {
			value: { injector },
			children: /* @__PURE__ */ jsx(Comp, { ...props })
		});
	};
}
function connectDependencies(Comp, dependencies) {
	return function ComponentWithInjector(props) {
		return /* @__PURE__ */ jsx(RediInjector, {
			dependencies,
			children: /* @__PURE__ */ jsx(Comp, { ...props })
		});
	};
}

//#endregion
//#region src/react-bindings/reactDecorators.ts
var ClassComponentNotInRediContextError = class extends RediError {
	constructor(component) {
		super(`You should make "RediContext" as ${component.constructor.name}'s default context type. If you want to use multiple context, please check this on React doc site. https://reactjs.org/docs/context.html#classcontexttype`);
	}
};
function WithDependency(id, quantity, lookUp) {
	return function() {
		return { get() {
			const thisComponent = this;
			const context = thisComponent.context;
			if (!context || !context.injector) throw new ClassComponentNotInRediContextError(thisComponent);
			const injector = context.injector;
			const thing = injector.get(id, quantity || Quantity.REQUIRED, lookUp);
			return thing;
		} };
	};
}

//#endregion
//#region src/react-bindings/reactHooks.tsx
var HooksNotInRediContextError = class extends RediError {
	constructor() {
		super("Using dependency injection outside of a RediContext.");
	}
};
function useInjector() {
	const injectionContext = useContext(RediContext);
	if (!injectionContext.injector) throw new HooksNotInRediContextError();
	return injectionContext.injector;
}
function useDependency(id, quantityOrLookUp, lookUp) {
	const injector = useInjector();
	return useMemo(() => injector.get(id, quantityOrLookUp, lookUp), [
		id,
		quantityOrLookUp,
		lookUp
	]);
}

//#endregion
//#region src/react-bindings/reactRx.tsx
function unwrap(o) {
	if (typeof o === "function") return o();
	return o;
}
/**
* Subscribe to an observable and return its value. The component will re-render when the observable emits a new value.
*
* @param observable An observable or a function that returns an observable
* @param defaultValue The default value of the observable. It the `observable` can omit an initial value, this value will be neglected.
* @param shouldHaveSyncValue If the observable should have a sync value. If it does not have a sync value, an error will be thrown.
* @param deps A dependency array to decide if we should re-subscribe when the `observable` is a function.
* @returns Value or null.
*/
function useObservable(observable, defaultValue, shouldHaveSyncValue, deps) {
	if (typeof observable === "function" && !deps) throw new RediError("Expected deps to be provided when observable is a function!");
	const observableRef = useRef(null);
	const receivedSyncValueRef = useRef(false);
	const subscribedRef = useRef(false);
	const destObservable = useMemo(() => observable, [...typeof deps !== "undefined" ? deps : [observable]]);
	const [_, setRenderCounter] = useState(0);
	const valueRef = useRef((() => {
		let innerDefaultValue;
		if (destObservable) {
			const sub = unwrap(destObservable).subscribe((value) => {
				receivedSyncValueRef.current = true;
				innerDefaultValue = value;
			});
			sub.unsubscribe();
		}
		return innerDefaultValue ?? defaultValue;
	})());
	useLayoutEffect(() => {
		subscribedRef.current = false;
		let subscription = null;
		if (destObservable) {
			observableRef.current = unwrap(destObservable);
			subscription = observableRef.current.subscribe((value) => {
				if (receivedSyncValueRef.current && !subscribedRef.current && value === valueRef.current) {
					subscribedRef.current = true;
					return;
				}
				subscribedRef.current = true;
				valueRef.current = value;
				setRenderCounter((prev) => prev + 1);
			});
		}
		return () => subscription?.unsubscribe();
	}, [destObservable]);
	if (shouldHaveSyncValue && !receivedSyncValueRef.current) throw new Error("[redi]: Expect `shouldHaveSyncValue` but not getting a sync value!");
	return valueRef.current;
}
/**
* subscribe to a signal that emits whenever data updates and re-render
*
* @param update$ a signal that the data the functional component depends has updated
*/
function useUpdateBinder(update$) {
	const [, dumpSet] = useState(0);
	useEffect(() => {
		const subscription = update$.subscribe(() => dumpSet((prev) => prev + 1));
		return () => subscription.unsubscribe();
	}, []);
}

//#endregion
//#region src/react-bindings/publicApi.ts
const __REDI_CONTEXT_LOCK__ = "REDI_CONTEXT_LOCK";
const isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
const globalObject = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global !== "undefined" && global;
if (!globalObject[__REDI_CONTEXT_LOCK__]) globalObject[__REDI_CONTEXT_LOCK__] = true;
else if (!isNode) console.error("[redi]: \"RediContext\" is already created. You may import \"RediContext\" from different paths. Use \"import { RediContext } from '@wendellhu/redi/react-bindings'; instead.\"");

//#endregion
export { RediConsumer, RediContext, RediProvider, WithDependency, connectDependencies, connectInjector, useDependency, useInjector, useObservable, useUpdateBinder };
//# sourceMappingURL=index.js.map