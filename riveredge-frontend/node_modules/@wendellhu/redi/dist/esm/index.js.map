{"version":3,"file":"index.js","names":["thing: any","thing: unknown","id: DependencyIdentifier<T>","message: string","index: number","target: Ctor<any>","registerTarget: Ctor<T>","registerTarget: Ctor<U>","identifier: DependencyIdentifier<T>","paramIndex: number","quantity: Quantity","lookUp?: LookUp","descriptor: DependencyDescriptor<T>","id: string","_key: string","target: Ctor<any>","index: number","lookUp: LookUp","target: Ctor<T>","_key: string","SkipSelf: SkipSelfDecorator","Self: SelfDecorator","quantity: Quantity.OPTIONAL | Quantity.REQUIRED","id: DependencyIdentifier<any>","actual: number","quantity: Quantity","length: number","arr: T[]","target: Ctor<any>","index: number","id?: DependencyIdentifier<T>","registerTarget: Ctor<T>","_key: string","Many: ManyDecorator","Optional: OptionalDecorator","Inject: InjectDecorator","deps?: FactoryDep<any>[]","lookUp: LookUp | undefined","modifier: FactoryDepModifier","registerTarget: Ctor<U>","deps: FactoryDep<any>[]","wrapper: () => Ctor<T>","thing: unknown","id: DependencyIdentifier<T>","target: Ctor<any>","index: number","withNew: boolean","target: Ctor<T>","_key: string","WithNew: ToSelfDecorator","thing: unknown","thing: Dependency<T>","ResolvingStack: DependencyIdentifier<any>[]","id: DependencyIdentifier<unknown>","toInstantiate: Ctor<any> | DependencyIdentifier<any>","id: DependencyIdentifier<any>","index: number","id","dependencies: Dependency[]","ctorOrId: Ctor<T> | DependencyIdentifier<T>","val?: DependencyItem<T>","id: DependencyIdentifier<T>","quantity: Quantity","val: DependencyItem<any>","val: T | null","runWhenIdle: (\n  callback: (idle?: IdleDeadline) => void,\n  timeout?: number,\n) => DisposableCallback","timeout?","handle: number","dummyIdle: IdleDeadline","executor: () => T","err: any","id: DependencyIdentifier<T>","dependencies?: Dependency[]","parent: Injector | null","callback: () => void","dependency: DependencyOrInstance<T>","dependency: DependencyPair<T>","identifier: DependencyIdentifier<T>","cb: (accessor: IAccessor, ...args: P) => T","accessor: IAccessor","id: DependencyIdentifier<D>","quantityOrLookup?: Quantity | LookUp","lookUp?: LookUp","withNew?: boolean","quantity: Quantity","ctor: new (...args: [...T, ...U]) => C","item: DependencyItem<T>","result: T | AsyncHook<T>","e: unknown","item: ExistingDependencyItem<T>","item: ValueDependencyItem<T>","id: DependencyIdentifier<T> | null","item: ClassDependencyItem<T>","shouldCache: boolean","thing: T","target: any","key: string | number | symbol","thing","_target: any","value: any","resolvedArgs: any[]","error: unknown","item: FactoryDependencyItem<T>","item: AsyncDependencyItem<T>","asyncLoader: AsyncHook<T>","ret: T","item","ret: (T | AsyncHook<T>)[] | T | AsyncHook<T> | null","globalObject: any"],"sources":["../../src/dependencyIdentifier.ts","../../src/dependencyItem.ts","../../src/error.ts","../../src/types.ts","../../src/decorators.ts","../../src/dependencyLookUp.ts","../../src/dependencyQuantity.ts","../../src/dependencyDescriptor.ts","../../src/dependencyDeclare.ts","../../src/dependencyForwardRef.ts","../../src/dependencyWithNew.ts","../../src/dispose.ts","../../src/dependencyCollection.ts","../../src/idleValue.ts","../../src/injector.ts","../../src/publicApi.ts"],"sourcesContent":["import type { ForwardRef } from './dependencyForwardRef';\nimport type { Ctor } from './dependencyItem';\n\nexport const IdentifierDecoratorSymbol = Symbol('$$IDENTIFIER_DECORATOR');\n\nexport interface IdentifierDecorator<T> {\n  [IdentifierDecoratorSymbol]: true;\n\n  // call signature of an decorator\n  (...args: any[]): void;\n\n  decoratorName: string;\n\n  toString: () => string;\n\n  type: T;\n}\n\nexport function isIdentifierDecorator<T>(\n  thing: any,\n): thing is IdentifierDecorator<T> {\n  return thing && thing[IdentifierDecoratorSymbol] === true;\n}\n\nexport type DependencyIdentifier<T> =\n  | string\n  | Ctor<T>\n  | ForwardRef<T>\n  | IdentifierDecorator<T>;\n\nexport type NormalizedDependencyIdentifier<T> = Exclude<\n  DependencyIdentifier<T>,\n  ForwardRef<T>\n>;\n","import type { DependencyIdentifier } from './dependencyIdentifier';\nimport type { Self, SkipSelf } from './dependencyLookUp';\nimport type { Many, Optional } from './dependencyQuantity';\nimport type { WithNew } from './dependencyWithNew';\nimport { IdentifierDecoratorSymbol } from './dependencyIdentifier';\n\nexport interface Ctor<T> {\n  new (...args: any[]): T;\n\n  name: string;\n}\nexport function isCtor<T>(thing: unknown): thing is Ctor<T> {\n  return typeof thing === 'function';\n}\n\nexport interface DependencyItemHooks<T> {\n  onInstantiation?: (instance: T) => void;\n}\n\nexport interface ClassDependencyItem<T> extends DependencyItemHooks<T> {\n  useClass: Ctor<T>;\n  lazy?: boolean;\n}\nexport function isClassDependencyItem<T>(\n  thing: unknown,\n): thing is ClassDependencyItem<T> {\n  if (thing && typeof (thing as any).useClass !== 'undefined') {\n    return true;\n  }\n\n  return false;\n}\n\nexport type FactoryDepModifier =\n  | typeof Self\n  | typeof SkipSelf\n  | typeof Optional\n  | typeof Many\n  | typeof WithNew;\n\nexport type FactoryDep<T> =\n  | [...FactoryDepModifier[], DependencyIdentifier<T>]\n  | DependencyIdentifier<T>;\n\nexport interface FactoryDependencyItem<T> extends DependencyItemHooks<T> {\n  useFactory: (...deps: any[]) => T;\n  dynamic?: true;\n  deps?: FactoryDep<any>[];\n}\nexport function isFactoryDependencyItem<T>(\n  thing: unknown,\n): thing is FactoryDependencyItem<T> {\n  if (thing && typeof (thing as any).useFactory !== 'undefined') {\n    return true;\n  }\n\n  return false;\n}\n\nexport interface ValueDependencyItem<T> extends DependencyItemHooks<T> {\n  useValue: T;\n}\nexport function isValueDependencyItem<T>(\n  thing: unknown,\n): thing is ValueDependencyItem<T> {\n  if (thing && typeof (thing as any).useValue !== 'undefined') {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Reuse an existing dependency. You can consider it as an alias to another dependency.\n */\nexport interface ExistingDependencyItem<T> extends DependencyItemHooks<T> {\n  /**\n   * The identifier of the existing dependency.\n   */\n  useExisting: DependencyIdentifier<T>;\n}\nexport function isExistingDependencyItem<T>(\n  thing: unknown,\n): thing is ExistingDependencyItem<T> {\n  if (thing && typeof (thing as any).useExisting !== 'undefined') {\n    return true;\n  }\n\n  return false;\n}\n\nexport interface AsyncDependencyItem<T> extends DependencyItemHooks<T> {\n  useAsync: () => Promise<\n    T | Ctor<T> | [DependencyIdentifier<T>, SyncDependencyItem<T>]\n  >;\n}\nexport function isAsyncDependencyItem<T>(\n  thing: unknown,\n): thing is AsyncDependencyItem<T> {\n  if (thing && typeof (thing as any).useAsync !== 'undefined') {\n    return true;\n  }\n\n  return false;\n}\n\nexport const AsyncHookSymbol = Symbol('AsyncHook');\nexport interface AsyncHook<T> {\n  __symbol: typeof AsyncHookSymbol;\n  whenReady: () => Promise<T>;\n}\nexport function isAsyncHook<T>(thing: unknown): thing is AsyncHook<T> {\n  if (thing && (thing as any).__symbol === AsyncHookSymbol) {\n    // FIXME@wzhudev: should not be undefined but a symbol here\n    return true;\n  }\n\n  return false;\n}\n\nexport type SyncDependencyItem<T> =\n  | ClassDependencyItem<T>\n  | FactoryDependencyItem<T>\n  | ExistingDependencyItem<T>\n  | ValueDependencyItem<T>;\n\nexport type DependencyItem<T> = SyncDependencyItem<T> | AsyncDependencyItem<T>;\n\nexport function prettyPrintIdentifier<T>(id: DependencyIdentifier<T>): string {\n  return isCtor(id) && !(id as any)[IdentifierDecoratorSymbol]\n    ? id.name\n    : id.toString();\n}\n","export class RediError extends Error {\n  constructor(message: string) {\n    super(`[redi]: ${message}`);\n  }\n}\n","export enum Quantity {\n  MANY = 'many',\n  OPTIONAL = 'optional',\n  REQUIRED = 'required',\n}\n\nexport enum LookUp {\n  SELF = 'self',\n  SKIP_SELF = 'skipSelf',\n}\n","import type { DependencyDescriptor } from './dependencyDescriptor';\nimport type {\n  DependencyIdentifier,\n  IdentifierDecorator,\n} from './dependencyIdentifier';\nimport type { Ctor } from './dependencyItem';\nimport type { LookUp } from './types';\nimport { IdentifierDecoratorSymbol } from './dependencyIdentifier';\nimport { prettyPrintIdentifier } from './dependencyItem';\nimport { RediError } from './error';\nimport { Quantity } from './types';\n\nexport const TARGET = Symbol('$$TARGET');\nexport const DEPENDENCIES = Symbol('$$DEPENDENCIES');\n\nclass DependencyDescriptorNotFoundError extends RediError {\n  constructor(index: number, target: Ctor<any>) {\n    const msg = `Could not find dependency registered on the ${index} (indexed) parameter of the constructor of \"${prettyPrintIdentifier(\n      target,\n    )}\".`;\n\n    super(msg);\n  }\n}\n\nexport class RequiredDecoratorMissusedError extends RediError {\n  constructor(target: Ctor<any>, index: number) {\n    const msg = `It seems that you forgot to provide a parameter to @Required() on the ${\n      index\n    }th parameter of \"${prettyPrintIdentifier(target)}\"`;\n\n    super(msg);\n  }\n}\n\nexport class IdentifierUndefinedError extends RediError {\n  constructor(target: Ctor<any>, index: number) {\n    const msg = `It seems that you register \"undefined\" as dependency on the ${\n      index\n    }th parameter of \"${prettyPrintIdentifier(\n      target,\n    )}\". Please make sure that there is not cyclic dependency among your TypeScript files, or consider using \"forwardRef\". For more info please visit our website https://redi.wendell.fun/docs/faq#could-not-find-dependency-registered-on`;\n\n    super(msg);\n  }\n}\n\n/**\n * @internal\n */\nexport function getDependencies<T>(\n  registerTarget: Ctor<T>,\n): DependencyDescriptor<any>[] {\n  const target = registerTarget as any;\n  return target[DEPENDENCIES] || [];\n}\n\n/**\n * @internal\n */\nexport function getDependencyByIndex<T>(\n  registerTarget: Ctor<T>,\n  index: number,\n): DependencyDescriptor<any> {\n  const allDependencies = getDependencies(registerTarget);\n  const dep = allDependencies.find(\n    (descriptor) => descriptor.paramIndex === index,\n  );\n\n  if (!dep) {\n    throw new DependencyDescriptorNotFoundError(index, registerTarget);\n  }\n\n  return dep;\n}\n\n/**\n * @internal\n */\nexport function setDependency<T, U>(\n  registerTarget: Ctor<U>,\n  identifier: DependencyIdentifier<T>,\n  paramIndex: number,\n  quantity: Quantity = Quantity.REQUIRED,\n  lookUp?: LookUp,\n): void {\n  const descriptor: DependencyDescriptor<T> = {\n    paramIndex,\n    identifier,\n    quantity,\n    lookUp,\n    withNew: false,\n  };\n\n  // sometimes identifier could be 'undefined' if user meant to pass in an ES class\n  // this is related to how classes are transpiled\n  if (typeof identifier === 'undefined') {\n    throw new IdentifierUndefinedError(registerTarget, paramIndex);\n  }\n\n  const target = registerTarget as any;\n  // deal with inheritance, subclass need to declare dependencies on its on\n  if (target[TARGET] === target) {\n    target[DEPENDENCIES].push(descriptor);\n  } else {\n    target[DEPENDENCIES] = [descriptor];\n    target[TARGET] = target;\n  }\n}\n\nconst knownIdentifiers = new Set<string>();\nconst cachedIdentifiers = new Map<string, IdentifierDecorator<any>>();\n\n/**\n * Create a dependency identifier\n *\n * @param id name of the identifier\n * @returns Identifier that could also be used as a decorator\n */\nexport function createIdentifier<T>(id: string): IdentifierDecorator<T> {\n  if (knownIdentifiers.has(id)) {\n    console.error(\n      `Identifier \"${id}\" already exists. Returning the cached identifier decorator.`,\n    );\n    return cachedIdentifiers.get(id)!;\n  }\n\n  const decorator = (<any>(\n    function (registerTarget: Ctor<T>, _key: string, index: number): void {\n      setDependency(registerTarget, decorator, index);\n    }\n  )) as IdentifierDecorator<T>;\n\n  decorator.decoratorName = id;\n  decorator.toString = () => decorator.decoratorName;\n  decorator[IdentifierDecoratorSymbol] = true;\n\n  knownIdentifiers.add(id);\n  cachedIdentifiers.set(id, decorator);\n\n  return decorator;\n}\n\n/**\n * @internal\n */\n/* istanbul ignore next */\nexport function TEST_ONLY_clearKnownIdentifiers(): void {\n  knownIdentifiers.clear();\n  cachedIdentifiers.clear();\n}\n","import type { Ctor } from './dependencyItem';\nimport { getDependencyByIndex } from './decorators';\nimport { LookUp } from './types';\n\nfunction changeLookup(target: Ctor<any>, index: number, lookUp: LookUp) {\n  const descriptor = getDependencyByIndex(target, index);\n  descriptor.lookUp = lookUp;\n}\n\nfunction lookupDecoratorFactoryProducer(lookUp: LookUp) {\n  return function DecoratorFactory<T>(this: any) {\n    if (this instanceof DecoratorFactory) {\n      return this;\n    }\n\n    return function (target: Ctor<T>, _key: string, index: number) {\n      changeLookup(target, index, lookUp);\n    };\n  } as any;\n}\n\ninterface SkipSelfDecorator {\n  (): any;\n  new (): SkipSelfDecorator;\n}\n/**\n * when resolving this dependency, skip the current injector\n */\nexport const SkipSelf: SkipSelfDecorator = lookupDecoratorFactoryProducer(\n  LookUp.SKIP_SELF,\n);\n\ninterface SelfDecorator {\n  (): any;\n  new (): SelfDecorator;\n}\n/**\n * when resolving this dependency, only search the current injector\n */\nexport const Self: SelfDecorator = lookupDecoratorFactoryProducer(LookUp.SELF);\n","import type { DependencyIdentifier } from './dependencyIdentifier';\nimport type { Ctor } from './dependencyItem';\nimport {\n  getDependencyByIndex,\n  RequiredDecoratorMissusedError,\n  setDependency,\n} from './decorators';\nimport { prettyPrintIdentifier } from './dependencyItem';\nimport { RediError } from './error';\nimport { Quantity } from './types';\n\nfunction mapQuantityToNumber(\n  quantity: Quantity.OPTIONAL | Quantity.REQUIRED,\n): string {\n  if (quantity === Quantity.OPTIONAL) {\n    return '0 or 1';\n  } else {\n    return '1';\n  }\n}\n\nexport class QuantityCheckError extends RediError {\n  constructor(\n    id: DependencyIdentifier<any>,\n    public readonly quantity: Quantity.OPTIONAL | Quantity.REQUIRED,\n    public readonly actual: number,\n  ) {\n    let msg = `Expect ${mapQuantityToNumber(quantity)} dependency item(s) for id \"${prettyPrintIdentifier(\n      id,\n    )}\" but get ${actual}.`;\n\n    if (actual === 0) {\n      msg += ' Did you forget to register it?';\n    }\n\n    if (actual > 1) {\n      msg += ' You register it more than once.';\n    }\n\n    super(msg);\n  }\n}\n\nexport function checkQuantity(\n  id: DependencyIdentifier<any>,\n  quantity: Quantity,\n  length: number,\n): void {\n  if (\n    (quantity === Quantity.OPTIONAL && length > 1) ||\n    (quantity === Quantity.REQUIRED && length !== 1)\n  ) {\n    throw new QuantityCheckError(id, quantity, length);\n  }\n}\n\nexport function retrieveQuantity<T>(quantity: Quantity, arr: T[]): T[] | T {\n  if (quantity === Quantity.MANY) {\n    return arr;\n  } else {\n    return arr[0];\n  }\n}\n\nfunction changeQuantity(target: Ctor<any>, index: number, quantity: Quantity) {\n  const descriptor = getDependencyByIndex(target, index);\n  descriptor.quantity = quantity;\n}\n\nfunction quantifyDecoratorFactoryProducer(quantity: Quantity) {\n  return function decoratorFactory<T>(\n    // typescript would remove `this` after transpilation\n    // this line just declare the type of `this`\n    this: any,\n    id?: DependencyIdentifier<T>,\n  ) {\n    if (this instanceof decoratorFactory) {\n      return this;\n    }\n\n    return function (registerTarget: Ctor<T>, _key: string, index: number) {\n      if (id) {\n        setDependency(registerTarget, id, index, quantity);\n      } else {\n        if (quantity === Quantity.REQUIRED) {\n          throw new RequiredDecoratorMissusedError(registerTarget, index);\n        }\n\n        changeQuantity(registerTarget, index, quantity);\n      }\n    };\n  } as any;\n}\n\ninterface ManyDecorator {\n  (id?: DependencyIdentifier<any>): any;\n  new (): ManyDecorator;\n}\nexport const Many: ManyDecorator = quantifyDecoratorFactoryProducer(\n  Quantity.MANY,\n);\n\ninterface OptionalDecorator {\n  (id?: DependencyIdentifier<any>): any;\n  new (): OptionalDecorator;\n}\nexport const Optional: OptionalDecorator = quantifyDecoratorFactoryProducer(\n  Quantity.OPTIONAL,\n);\n\ninterface InjectDecorator {\n  (id: DependencyIdentifier<any>): any;\n  new (): InjectDecorator;\n}\nexport const Inject: InjectDecorator = quantifyDecoratorFactoryProducer(\n  Quantity.REQUIRED,\n);\n","import type { DependencyIdentifier } from './dependencyIdentifier';\nimport type { FactoryDep, FactoryDepModifier } from './dependencyItem';\nimport { Self, SkipSelf } from './dependencyLookUp';\nimport { Many, Optional } from './dependencyQuantity';\nimport { LookUp, Quantity } from './types';\n\nexport interface DependencyDescriptor<T> {\n  paramIndex: number;\n  identifier: DependencyIdentifier<T>;\n  quantity: Quantity;\n  lookUp?: LookUp;\n  withNew: boolean;\n}\n\n/**\n * describes dependencies of a IDependencyItem\n */\nexport interface Dependencies {\n  dependencies: DependencyDescriptor<any>[];\n}\n\nexport function normalizeFactoryDeps(\n  deps?: FactoryDep<any>[],\n  startIndex = 0,\n): DependencyDescriptor<any>[] {\n  if (!deps) {\n    return [];\n  }\n\n  return deps.map((dep, index) => {\n    index += startIndex;\n\n    if (!Array.isArray(dep)) {\n      return {\n        paramIndex: index,\n        identifier: dep,\n        quantity: Quantity.REQUIRED,\n        withNew: false,\n      };\n    }\n\n    const modifiers = dep.slice(0, dep.length - 1) as FactoryDepModifier[];\n    const identifier = dep[dep.length - 1] as DependencyIdentifier<any>;\n\n    let lookUp: LookUp | undefined;\n    let quantity = Quantity.REQUIRED;\n    let withNew = false;\n\n    (modifiers as FactoryDepModifier[]).forEach(\n      (modifier: FactoryDepModifier) => {\n        if (modifier instanceof Self) {\n          lookUp = LookUp.SELF;\n        } else if (modifier instanceof SkipSelf) {\n          lookUp = LookUp.SKIP_SELF;\n        } else if (modifier instanceof Optional) {\n          quantity = Quantity.OPTIONAL;\n        } else if (modifier instanceof Many) {\n          quantity = Quantity.MANY;\n        } /* if  (modifier instanceof WithNew) */ else {\n          withNew = true;\n        }\n      },\n    );\n\n    return {\n      paramIndex: index,\n      identifier: identifier as DependencyIdentifier<any>,\n      quantity,\n      lookUp,\n      withNew,\n    };\n  });\n}\n","import type { Ctor, FactoryDep } from './dependencyItem';\nimport { setDependency } from './decorators';\nimport { normalizeFactoryDeps } from './dependencyDescriptor';\n\n/**\n * Register dependencies on a class.\n *\n * @param registerTarget The target constructor\n * @param deps Dependencies\n * @param startIndex The start index of the dependencies. Default is 0. When you want to set dependencies on a class\n * that has custom parameters, you should set `startIndex` to the count of these custom parameters.\n */\nexport function setDependencies<U>(\n  registerTarget: Ctor<U>,\n  deps: FactoryDep<any>[],\n  startIndex = 0,\n): void {\n  const normalizedDescriptors = normalizeFactoryDeps(deps, startIndex);\n  normalizedDescriptors.forEach((descriptor) => {\n    setDependency(\n      registerTarget,\n      descriptor.identifier,\n      descriptor.paramIndex,\n      descriptor.quantity,\n      descriptor.lookUp,\n    );\n  });\n}\n","import type {\n  DependencyIdentifier,\n  NormalizedDependencyIdentifier,\n} from './dependencyIdentifier';\nimport type { Ctor } from './dependencyItem';\n\nexport interface ForwardRef<T> {\n  unwrap: () => Ctor<T>;\n}\n\nexport function forwardRef<T>(wrapper: () => Ctor<T>): ForwardRef<T> {\n  return {\n    unwrap: wrapper,\n  };\n}\n\nexport function isForwardRef<T = any>(thing: unknown): thing is ForwardRef<T> {\n  return !!thing && typeof (thing as any).unwrap === 'function';\n}\n\nexport function normalizeForwardRef<T>(\n  id: DependencyIdentifier<T>,\n): NormalizedDependencyIdentifier<T> {\n  if (isForwardRef(id)) {\n    return id.unwrap();\n  }\n\n  return id;\n}\n","import type { Ctor } from './dependencyItem';\nimport { getDependencyByIndex } from './decorators';\n\nfunction changeToSelf(target: Ctor<any>, index: number, withNew: boolean) {\n  const descriptor = getDependencyByIndex(target, index);\n  descriptor.withNew = withNew;\n}\n\nfunction withNewDecoratorFactoryProducer(withNew: boolean) {\n  return function DecoratorFactory<T>(this: any) {\n    if (this instanceof DecoratorFactory) {\n      return this;\n    }\n\n    return function (target: Ctor<T>, _key: string, index: number) {\n      changeToSelf(target, index, withNew);\n    };\n  } as any;\n}\n\ninterface ToSelfDecorator {\n  (): any;\n  new (): ToSelfDecorator;\n}\n\n/**\n * Always initialize a new instance of that dependency instead of getting the\n * cached instance from the injector.\n */\nexport const WithNew: ToSelfDecorator = withNewDecoratorFactoryProducer(true);\n","export interface IDisposable {\n  dispose: () => void;\n}\n\nexport function isDisposable(thing: unknown): thing is IDisposable {\n  return !!thing && typeof (thing as any).dispose === 'function';\n}\n","import type { DependencyIdentifier } from './dependencyIdentifier';\nimport type { Ctor, DependencyItem } from './dependencyItem';\nimport type { IDisposable } from './dispose';\nimport { isIdentifierDecorator } from './dependencyIdentifier';\nimport { prettyPrintIdentifier } from './dependencyItem';\nimport { checkQuantity, retrieveQuantity } from './dependencyQuantity';\nimport { isDisposable } from './dispose';\nimport { RediError } from './error';\nimport { Quantity } from './types';\n\nexport type DependencyPair<T> = [DependencyIdentifier<T>, DependencyItem<T>];\nexport type DependencyClass<T> = [Ctor<T>];\nexport type Dependency<T = any> = DependencyPair<T> | DependencyClass<T>;\nexport type DependencyWithInstance<T = any> = [\n  Ctor<T> | DependencyIdentifier<T>,\n  T,\n];\nexport type DependencyOrInstance<T = any> =\n  | Dependency<T>\n  | DependencyWithInstance<T>;\n\nexport function isBareClassDependency<T>(\n  thing: Dependency<T>,\n): thing is DependencyClass<T> {\n  return thing.length === 1;\n}\n\nconst ResolvingStack: DependencyIdentifier<any>[] = [];\n\nexport function pushResolvingStack(id: DependencyIdentifier<unknown>) {\n  ResolvingStack.push(id);\n}\n\nexport function popupResolvingStack() {\n  ResolvingStack.pop();\n}\n\nexport function clearResolvingStack() {\n  ResolvingStack.length = 0;\n}\n\nexport class DependencyNotFoundForModuleError extends RediError {\n  constructor(\n    toInstantiate: Ctor<any> | DependencyIdentifier<any>,\n    id: DependencyIdentifier<any>,\n    index: number,\n  ) {\n    const msg = `Cannot find \"${prettyPrintIdentifier(id)}\" registered by any injector. It is the ${index}th param of \"${\n      isIdentifierDecorator(toInstantiate)\n        ? prettyPrintIdentifier(toInstantiate)\n        : (toInstantiate as Ctor<any>).name\n    }\".`;\n\n    super(msg);\n  }\n}\n\nexport class DependencyNotFoundError extends RediError {\n  constructor(id: DependencyIdentifier<any>) {\n    const msg = `Cannot find \"${prettyPrintIdentifier(id)}\" registered by any injector. The stack of dependencies is: \"${ResolvingStack.map((id) => prettyPrintIdentifier(id)).join(' -> ')}\".`;\n\n    super(msg);\n\n    clearResolvingStack();\n  }\n}\n\n/**\n * Store unresolved dependencies in an injector.\n *\n * @internal\n */\nexport class DependencyCollection implements IDisposable {\n  private readonly dependencyMap = new Map<\n    DependencyIdentifier<any>,\n    DependencyItem<any>[]\n  >();\n\n  constructor(dependencies: Dependency[]) {\n    this.normalizeDependencies(dependencies).map((pair) =>\n      this.add(pair[0], pair[1]),\n    );\n  }\n\n  public add<T>(ctor: Ctor<T>): void;\n  public add<T>(id: DependencyIdentifier<T>, val: DependencyItem<T>): void;\n  public add<T>(\n    ctorOrId: Ctor<T> | DependencyIdentifier<T>,\n    val?: DependencyItem<T>,\n  ): void {\n    if (typeof val === 'undefined') {\n      val = { useClass: ctorOrId as Ctor<T>, lazy: false };\n    }\n\n    let arr = this.dependencyMap.get(ctorOrId);\n    if (typeof arr === 'undefined') {\n      arr = [];\n      this.dependencyMap.set(ctorOrId, arr);\n    }\n    arr.push(val);\n  }\n\n  public delete<T>(id: DependencyIdentifier<T>): void {\n    this.dependencyMap.delete(id);\n  }\n\n  // public get<T>(id: DependencyIdentifier<T>): DependencyItem<T>;\n  public get<T>(\n    id: DependencyIdentifier<T>,\n    quantity: Quantity.REQUIRED,\n  ): DependencyItem<T>;\n  public get<T>(\n    id: DependencyIdentifier<T>,\n    quantity: Quantity.MANY,\n  ): DependencyItem<T>[];\n  public get<T>(\n    id: DependencyIdentifier<T>,\n    quantity: Quantity.OPTIONAL,\n  ): DependencyItem<T> | null;\n  public get<T>(\n    id: DependencyIdentifier<T>,\n    quantity: Quantity,\n  ): DependencyItem<T> | DependencyItem<T>[] | null;\n  public get<T>(\n    id: DependencyIdentifier<T>,\n    quantity: Quantity,\n  ): DependencyItem<T> | DependencyItem<T>[] | null {\n    const ret = this.dependencyMap.get(id)!;\n\n    checkQuantity(id, quantity, ret.length);\n    return retrieveQuantity(quantity, ret);\n  }\n\n  public has<T>(id: DependencyIdentifier<T>): boolean {\n    return this.dependencyMap.has(id);\n  }\n\n  public dispose(): void {\n    this.dependencyMap.clear();\n  }\n\n  /**\n   * normalize dependencies to `DependencyItem`\n   */\n  private normalizeDependencies(\n    dependencies: Dependency[],\n  ): DependencyPair<any>[] {\n    return dependencies.map((dependency) => {\n      const id = dependency[0];\n      let val: DependencyItem<any>;\n      if (isBareClassDependency(dependency)) {\n        val = {\n          useClass: dependency[0],\n          lazy: false,\n        };\n      } else {\n        val = dependency[1];\n      }\n\n      return [id, val];\n    });\n  }\n}\n\n/**\n * Store resolved dependencies.\n *\n * @internal\n */\nexport class ResolvedDependencyCollection implements IDisposable {\n  private readonly resolvedDependencies = new Map<\n    DependencyIdentifier<any>,\n    any[]\n  >();\n\n  public add<T>(id: DependencyIdentifier<T>, val: T | null): void {\n    let arr = this.resolvedDependencies.get(id);\n    if (typeof arr === 'undefined') {\n      arr = [];\n      this.resolvedDependencies.set(id, arr);\n    }\n\n    arr.push(val);\n  }\n\n  public has<T>(id: DependencyIdentifier<T>): boolean {\n    return this.resolvedDependencies.has(id);\n  }\n\n  public get<T>(\n    id: DependencyIdentifier<T>,\n    quantity: Quantity.OPTIONAL,\n  ): T | null;\n  public get<T>(id: DependencyIdentifier<T>, quantity: Quantity.REQUIRED): T;\n  public get<T>(id: DependencyIdentifier<T>, quantity: Quantity.MANY): T[];\n  public get<T>(\n    id: DependencyIdentifier<T>,\n    quantity: Quantity,\n  ): T[] | T | null;\n  public get<T>(\n    id: DependencyIdentifier<T>,\n    quantity: Quantity,\n  ): T | T[] | null {\n    const ret = this.resolvedDependencies.get(id);\n\n    if (!ret) {\n      throw new DependencyNotFoundError(id);\n    }\n\n    checkQuantity(id, quantity, ret.length);\n\n    if (quantity === Quantity.MANY) {\n      return ret;\n    } else {\n      return ret[0];\n    }\n  }\n\n  public dispose(): void {\n    Array.from(this.resolvedDependencies.values()).forEach((items) => {\n      items.forEach((item) => (isDisposable(item) ? item.dispose() : void 0));\n    });\n\n    this.resolvedDependencies.clear();\n  }\n}\n","import type { IDisposable } from './dispose';\n\nexport interface IdleDeadline {\n  readonly didTimeout: boolean;\n  timeRemaining: () => DOMHighResTimeStamp;\n}\n\nexport type DisposableCallback = () => void;\n\n/**\n * this run the callback when CPU is idle. Will fallback to setTimeout if\n * the browser doesn't support requestIdleCallback\n */\n// eslint-disable-next-line import/no-mutable-exports\nexport let runWhenIdle: (\n  callback: (idle?: IdleDeadline) => void,\n  timeout?: number,\n) => DisposableCallback;\n\n// declare global variables because apparently the type file doesn't have it, for now\ndeclare function requestIdleCallback(\n  callback: (args: IdleDeadline) => void,\n  options?: { timeout: number },\n): number;\ndeclare function cancelIdleCallback(handle: number): void;\n\n// use an IIFE to set up runWhenIdle\n(function () {\n  // this API is not available in Node.js, so we need to ignore it in tests\n  /* istanbul ignore next -- @preserve */\n  if (\n    typeof requestIdleCallback !== 'undefined' &&\n    typeof cancelIdleCallback !== 'undefined'\n  ) {\n    // use native requestIdleCallback\n    runWhenIdle = (runner, timeout?) => {\n      const handle: number = requestIdleCallback(\n        runner,\n        typeof timeout === 'number' ? { timeout } : undefined,\n      );\n\n      let disposed = false;\n      return () => {\n        if (disposed) return;\n\n        disposed = true;\n        cancelIdleCallback(handle);\n      };\n    };\n  } else {\n    // use setTimeout as hack\n    const dummyIdle: IdleDeadline = Object.freeze({\n      didTimeout: true,\n      /* istanbul ignore next */\n      timeRemaining() {\n        return 15;\n      },\n    });\n\n    runWhenIdle = (runner) => {\n      const handle = setTimeout(() => runner(dummyIdle));\n      let disposed = false;\n      return () => {\n        if (disposed) {\n          return;\n        }\n\n        disposed = true;\n        clearTimeout(handle);\n      };\n    };\n  }\n})();\n\n/**\n * a wrapper of a executor so it can be evaluated when it's necessary or the CPU is idle\n *\n * the type of the returned value of the executor would be T\n */\nexport class IdleValue<T> implements IDisposable {\n  private readonly executor: () => void;\n  private readonly disposeIdleCallback: () => void;\n\n  private didRun = false;\n  private value?: T;\n  private error?: Error;\n\n  constructor(executor: () => T) {\n    this.executor = () => {\n      try {\n        this.value = executor();\n      } catch (err: any) {\n        this.error = err;\n      } finally {\n        this.didRun = true;\n      }\n    };\n\n    this.disposeIdleCallback = runWhenIdle(() => this.executor());\n  }\n\n  hasRun(): boolean {\n    return this.didRun;\n  }\n\n  dispose(): void {\n    this.disposeIdleCallback();\n  }\n\n  getValue(): T {\n    if (!this.didRun) {\n      this.disposeIdleCallback();\n      this.executor();\n    }\n\n    if (this.error) throw this.error;\n\n    return this.value!;\n  }\n}\n","import type {\n  Dependency,\n  DependencyOrInstance,\n  DependencyPair,\n} from './dependencyCollection';\nimport type { DependencyIdentifier } from './dependencyIdentifier';\nimport type {\n  AsyncDependencyItem,\n  AsyncHook,\n  ClassDependencyItem,\n  Ctor,\n  DependencyItem,\n  ExistingDependencyItem,\n  FactoryDependencyItem,\n  ValueDependencyItem,\n} from './dependencyItem';\nimport type { IDisposable } from './dispose';\nimport { getDependencies } from './decorators';\nimport {\n  DependencyCollection,\n  DependencyNotFoundError,\n  DependencyNotFoundForModuleError,\n  popupResolvingStack,\n  pushResolvingStack,\n  ResolvedDependencyCollection,\n} from './dependencyCollection';\nimport { normalizeFactoryDeps } from './dependencyDescriptor';\nimport { normalizeForwardRef } from './dependencyForwardRef';\nimport {\n  AsyncHookSymbol,\n  isAsyncDependencyItem,\n  isAsyncHook,\n  isClassDependencyItem,\n  isCtor,\n  isExistingDependencyItem,\n  isFactoryDependencyItem,\n  isValueDependencyItem,\n  prettyPrintIdentifier,\n} from './dependencyItem';\nimport { QuantityCheckError } from './dependencyQuantity';\nimport { RediError } from './error';\nimport { IdleValue } from './idleValue';\nimport { LookUp, Quantity } from './types';\n\nconst MAX_RESOLUTIONS_QUEUED = 300;\n\nconst NotInstantiatedSymbol = Symbol('$$NOT_INSTANTIATED_SYMBOL');\n\nclass CircularDependencyError<T> extends RediError {\n  constructor(id: DependencyIdentifier<T>) {\n    super(\n      `Detecting cyclic dependency. The last identifier is \"${prettyPrintIdentifier(\n        id,\n      )}\".`,\n    );\n  }\n}\n\nclass InjectorAlreadyDisposedError extends RediError {\n  constructor() {\n    super('Injector cannot be accessed after it was disposed.');\n  }\n}\n\nclass AsyncItemReturnAsyncItemError<T> extends RediError {\n  constructor(id: DependencyIdentifier<T>) {\n    super(\n      `Async item \"${prettyPrintIdentifier(id)}\" returns another async item.`,\n    );\n  }\n}\n\nclass GetAsyncItemFromSyncApiError<T> extends RediError {\n  constructor(id: DependencyIdentifier<T>) {\n    super(\n      `Cannot get async item \"${prettyPrintIdentifier(id)}\" from sync api.`,\n    );\n  }\n}\n\nclass AddDependencyAfterResolutionError<T> extends RediError {\n  constructor(id: DependencyIdentifier<T>) {\n    super(\n      `Cannot add dependency \"${prettyPrintIdentifier(\n        id,\n      )}\" after it is already resolved.`,\n    );\n  }\n}\n\nclass DeleteDependencyAfterResolutionError<T> extends RediError {\n  constructor(id: DependencyIdentifier<T>) {\n    super(\n      `Cannot delete dependency \"${prettyPrintIdentifier(\n        id,\n      )}\" when it is already resolved.`,\n    );\n  }\n}\n\nexport interface IAccessor {\n  get: Injector['get'];\n  has: Injector['has'];\n}\n\nexport class Injector {\n  private readonly dependencyCollection: DependencyCollection;\n  private readonly resolvedDependencyCollection: ResolvedDependencyCollection;\n\n  private readonly children: Injector[] = [];\n\n  private resolutionOngoing = 0;\n\n  private disposingCallbacks = new Set<() => void>();\n\n  private disposed = false;\n\n  /**\n   * Create a new `Injector` instance\n   * @param dependencies Dependencies that should be resolved by this injector instance.\n   * @param parent Optional parent injector.\n   */\n  constructor(\n    dependencies?: Dependency[],\n    private readonly parent: Injector | null = null,\n  ) {\n    this.dependencyCollection = new DependencyCollection(dependencies || []);\n    this.resolvedDependencyCollection = new ResolvedDependencyCollection();\n\n    if (parent) {\n      parent.children.push(this);\n    }\n  }\n\n  /**\n   * Add a callback function that will be triggered when the Injector is disposed.\n   * Please note that when you callback is invoked, the injector is already disposed and\n   * you will not be able to interact with this Injector any more.\n   *\n   * @param {() => void} callback The callback function that will be invoked when\n   * the Injector is disposed.\n   * @returns A disposable that will remove the callback.\n   */\n  public onDispose(callback: () => void): IDisposable {\n    this.disposingCallbacks.add(callback);\n    return { dispose: () => this.disposingCallbacks.delete(callback) };\n  }\n\n  /**\n   * Create a child inject with a set of dependencies.\n   * @param dependencies Dependencies that should be resolved by the newly created child injector.\n   * @returns The child injector.\n   */\n  public createChild(dependencies?: Dependency[]): Injector {\n    this._ensureInjectorNotDisposed();\n\n    return new Injector(dependencies, this);\n  }\n\n  /**\n   * Dispose the injector and all dependencies held by this injector. Note that its child injectors will dispose first.\n   */\n  public dispose(): void {\n    // Dispose child injectors first.\n    this.children.forEach((c) => c.dispose());\n    this.children.length = 0;\n\n    // Call `dispose` method on each instantiated dependencies if they are `IDisposable` and clear collections.\n    this.dependencyCollection.dispose();\n    this.resolvedDependencyCollection.dispose();\n\n    // Detach itself from parent.\n    this.deleteSelfFromParent();\n\n    this.disposed = true;\n\n    this.disposingCallbacks.forEach((callback) => callback());\n    this.disposingCallbacks.clear();\n  }\n\n  private deleteSelfFromParent(): void {\n    if (this.parent) {\n      const index = this.parent.children.indexOf(this);\n      this.parent.children.splice(index, 1);\n    }\n  }\n\n  /**\n   * Add a dependency or its instance into injector. It would throw an error if the dependency\n   * has already been instantiated.\n   *\n   * @param dependency The dependency or an instance that would be add in the injector.\n   */\n  public add<T>(dependency: DependencyOrInstance<T>): void {\n    this._ensureInjectorNotDisposed();\n\n    const identifierOrCtor = dependency[0];\n    const item = dependency[1];\n\n    if (this.resolvedDependencyCollection.has(identifierOrCtor)) {\n      throw new AddDependencyAfterResolutionError(identifierOrCtor);\n    }\n\n    if (typeof item === 'undefined') {\n      // Add dependency\n      this.dependencyCollection.add(identifierOrCtor as Ctor<T>);\n    } else if (\n      isAsyncDependencyItem(item) ||\n      isClassDependencyItem(item) ||\n      isValueDependencyItem(item) ||\n      isFactoryDependencyItem(item)\n    ) {\n      // Add dependency\n      this.dependencyCollection.add(\n        identifierOrCtor,\n        item as DependencyItem<T>,\n      );\n    } else {\n      // Add instance\n      this.resolvedDependencyCollection.add(identifierOrCtor, item as T);\n    }\n  }\n\n  /**\n   * Replace an injection mapping for interface-based injection. It would throw an error if the dependency\n   * has already been instantiated.\n   *\n   * @param dependency The dependency that will replace the already existed dependency.\n   */\n  public replace<T>(dependency: DependencyPair<T>): void {\n    this._ensureInjectorNotDisposed();\n\n    const identifier = dependency[0];\n    if (this.resolvedDependencyCollection.has(identifier)) {\n      throw new AddDependencyAfterResolutionError(identifier);\n    }\n\n    this.dependencyCollection.delete(identifier);\n    this.dependencyCollection.add(identifier, dependency[1]);\n  }\n\n  /**\n   * Delete a dependency from an injector. It would throw an error when the deleted dependency\n   * has already been instantiated.\n   *\n   * @param identifier The identifier of the dependency that is supposed to be deleted.\n   */\n  public delete<T>(identifier: DependencyIdentifier<T>): void {\n    this._ensureInjectorNotDisposed();\n\n    if (this.resolvedDependencyCollection.has(identifier)) {\n      throw new DeleteDependencyAfterResolutionError(identifier);\n    }\n\n    this.dependencyCollection.delete(identifier);\n  }\n\n  /**\n   * Invoke a function with dependencies injected. The function could only get dependency from the injector\n   * and other methods are not accessible for the function.\n   *\n   * @param cb the function to be executed\n   * @param args arguments to be passed into the function\n   * @returns the return value of the function\n   */\n  invoke<T, P extends any[] = []>(\n    cb: (accessor: IAccessor, ...args: P) => T,\n    ...args: P\n  ): T {\n    this._ensureInjectorNotDisposed();\n\n    const accessor: IAccessor = {\n      get: <D>(\n        id: DependencyIdentifier<D>,\n        quantityOrLookup?: Quantity | LookUp,\n        lookUp?: LookUp,\n      ) => {\n        return this._get(id, quantityOrLookup, lookUp);\n      },\n\n      has: <D>(id: DependencyIdentifier<D>): boolean => {\n        return this.has(id);\n      },\n    };\n\n    return cb(accessor, ...args);\n  }\n\n  /**\n   * Check if the injector could initialize a dependency.\n   *\n   * @param id Identifier of the dependency\n   */\n  public has<T>(id: DependencyIdentifier<T>): boolean {\n    return this.dependencyCollection.has(id) || this.parent?.has(id) || false;\n  }\n\n  public get<T>(id: DependencyIdentifier<T>, lookUp?: LookUp): T;\n  public get<T>(\n    id: DependencyIdentifier<T>,\n    quantity: Quantity.MANY,\n    lookUp?: LookUp,\n  ): T[];\n  public get<T>(\n    id: DependencyIdentifier<T>,\n    quantity: Quantity.OPTIONAL,\n    lookUp?: LookUp,\n  ): T | null;\n  public get<T>(\n    id: DependencyIdentifier<T>,\n    quantity: Quantity.REQUIRED,\n    lookUp?: LookUp,\n  ): T;\n  public get<T>(\n    id: DependencyIdentifier<T>,\n    quantity?: Quantity,\n    lookUp?: LookUp,\n  ): T[] | T | null;\n  public get<T>(\n    id: DependencyIdentifier<T>,\n    quantityOrLookup?: Quantity | LookUp,\n    lookUp?: LookUp,\n  ): T[] | T | null;\n  /**\n   * Get dependency instance(s).\n   *\n   * @param id Identifier of the dependency\n   * @param quantityOrLookup @link{Quantity} or @link{LookUp}\n   * @param lookUp @link{LookUp}\n   */\n  public get<T>(\n    id: DependencyIdentifier<T>,\n    quantityOrLookup?: Quantity | LookUp,\n    lookUp?: LookUp,\n  ): T[] | T | null {\n    this._ensureInjectorNotDisposed();\n\n    const newResult = this._get(id, quantityOrLookup, lookUp);\n    if (\n      (Array.isArray(newResult) && newResult.some((r) => isAsyncHook(r))) ||\n      isAsyncHook(newResult)\n    ) {\n      throw new GetAsyncItemFromSyncApiError(id);\n    }\n\n    return newResult as T | T[] | null;\n  }\n\n  private _get<T>(\n    id: DependencyIdentifier<T>,\n    quantityOrLookup?: Quantity | LookUp,\n    lookUp?: LookUp,\n    withNew?: boolean,\n  ): T[] | T | AsyncHook<T> | null {\n    let quantity: Quantity = Quantity.REQUIRED;\n    if (\n      quantityOrLookup === Quantity.REQUIRED ||\n      quantityOrLookup === Quantity.OPTIONAL ||\n      quantityOrLookup === Quantity.MANY\n    ) {\n      quantity = quantityOrLookup as Quantity;\n    } else {\n      lookUp = quantityOrLookup as LookUp;\n    }\n\n    if (!withNew) {\n      // see if the dependency is already resolved, return it and check quantity\n      // if the dependency is not registered, it will return null or [] based on the quantity\n      const cachedResult = this.getValue(id, quantity, lookUp);\n      if (cachedResult !== NotInstantiatedSymbol) {\n        return cachedResult;\n      }\n    }\n\n    // see if the dependency can be instantiated by itself or its parent\n    const shouldCache = !withNew;\n    return this.createDependency(id, quantity, lookUp, shouldCache) as\n      | T[]\n      | T\n      | AsyncHook<T>\n      | null;\n  }\n\n  /**\n   * Get a dependency in the async way.\n   */\n  public getAsync<T>(id: DependencyIdentifier<T>): Promise<T> {\n    this._ensureInjectorNotDisposed();\n\n    const cachedResult = this.getValue(id, Quantity.REQUIRED);\n    if (cachedResult !== NotInstantiatedSymbol) {\n      return Promise.resolve(cachedResult as T);\n    }\n\n    const newResult = this.createDependency(id, Quantity.REQUIRED);\n    if (!isAsyncHook(newResult)) {\n      return Promise.resolve(newResult as T);\n    }\n\n    return newResult.whenReady();\n  }\n\n  /**\n   * Instantiate a class. The created instance would not be held by the injector.\n   */\n  public createInstance<T extends unknown[], U extends unknown[], C>(\n    ctor: new (...args: [...T, ...U]) => C,\n    ...customArgs: T\n  ): C {\n    this._ensureInjectorNotDisposed();\n\n    return this._resolveClassImpl(\n      {\n        useClass: ctor as Ctor<C>,\n      },\n      ...customArgs,\n    );\n  }\n\n  private _resolveDependency<T>(\n    id: DependencyIdentifier<T>,\n    item: DependencyItem<T>,\n    shouldCache = true,\n  ): T | AsyncHook<T> {\n    let result: T | AsyncHook<T>;\n\n    pushResolvingStack(id);\n\n    try {\n      if (isValueDependencyItem(item)) {\n        result = this._resolveValueDependency(\n          id,\n          item as ValueDependencyItem<T>,\n        );\n      } else if (isFactoryDependencyItem(item)) {\n        result = this._resolveFactory(\n          id,\n          item as FactoryDependencyItem<T>,\n          shouldCache,\n        );\n      } else if (isClassDependencyItem(item)) {\n        result = this._resolveClass(\n          id,\n          item as ClassDependencyItem<T>,\n          shouldCache,\n        );\n      } else if (isExistingDependencyItem(item)) {\n        result = this._resolveExisting(id, item as ExistingDependencyItem<T>);\n      } else {\n        result = this._resolveAsync(id, item as AsyncDependencyItem<T>);\n      }\n\n      popupResolvingStack();\n    } catch (e: unknown) {\n      popupResolvingStack();\n      throw e;\n    }\n\n    return result;\n  }\n\n  private _resolveExisting<T>(\n    id: DependencyIdentifier<T>,\n    item: ExistingDependencyItem<T>,\n  ): T {\n    const thing = this.get(item.useExisting);\n    this.resolvedDependencyCollection.add(id, thing);\n    return thing;\n  }\n\n  private _resolveValueDependency<T>(\n    id: DependencyIdentifier<T>,\n    item: ValueDependencyItem<T>,\n  ): T {\n    const thing = item.useValue;\n    this.resolvedDependencyCollection.add(id, thing);\n    return thing;\n  }\n\n  private _resolveClass<T>(\n    id: DependencyIdentifier<T> | null,\n    item: ClassDependencyItem<T>,\n    shouldCache: boolean,\n  ): T {\n    let thing: T;\n\n    if (item.lazy) {\n      const idle = new IdleValue<T>(() => {\n        this._ensureInjectorNotDisposed();\n        return this._resolveClassImpl(item);\n      });\n\n      thing = new Proxy(Object.create(null), {\n        get(target: any, key: string | number | symbol): any {\n          if (key in target) {\n            return target[key]; // such as toString\n          }\n\n          // this seems not necessary\n          // // hack checking if it's a async loader\n          // if (key === 'whenReady') {\n          //   return undefined;\n          // }\n\n          const thing = idle.getValue();\n\n          let property = (thing as any)[key];\n          if (typeof property !== 'function') {\n            return property;\n          }\n\n          property = property.bind(thing);\n          target[key] = property;\n\n          return property;\n        },\n        set(_target: any, key: string | number | symbol, value: any): boolean {\n          (idle.getValue() as any)[key] = value;\n          return true;\n        },\n      });\n    } else {\n      thing = this._resolveClassImpl(item);\n    }\n\n    if (id && shouldCache) {\n      this.resolvedDependencyCollection.add(id, thing);\n    }\n\n    return thing;\n  }\n\n  private _resolveClassImpl<T>(\n    item: ClassDependencyItem<T>,\n    ...extraParams: any[]\n  ) {\n    const Ctor = item.useClass;\n    this.markNewResolution(Ctor);\n\n    const declaredDependencies = getDependencies(Ctor)\n      .sort((a, b) => a.paramIndex - b.paramIndex)\n      .map((descriptor) => ({\n        ...descriptor,\n        identifier: normalizeForwardRef(descriptor.identifier),\n      }));\n\n    const resolvedArgs: any[] = [];\n\n    for (const dep of declaredDependencies) {\n      // recursive happens here\n      try {\n        const thing = this._get(\n          dep.identifier,\n          dep.quantity,\n          dep.lookUp,\n          dep.withNew,\n        );\n        resolvedArgs.push(thing);\n      } catch (error: unknown) {\n        if (\n          error instanceof DependencyNotFoundError ||\n          (error instanceof QuantityCheckError && error.actual === 0)\n        ) {\n          throw new DependencyNotFoundForModuleError(\n            Ctor,\n            dep.identifier,\n            dep.paramIndex,\n          );\n        }\n\n        throw error;\n      }\n    }\n\n    let args = [...extraParams];\n    const firstDependencyArgIndex =\n      declaredDependencies.length > 0\n        ? declaredDependencies[0].paramIndex\n        : args.length;\n\n    if (args.length !== firstDependencyArgIndex) {\n      console.warn(\n        `[redi]: Expect ${firstDependencyArgIndex} custom parameter(s) of ${prettyPrintIdentifier(Ctor)} but get ${\n          args.length\n        }.`,\n      );\n\n      const delta = firstDependencyArgIndex - args.length;\n      if (delta > 0) {\n        args = [...args, ...Array.from({ length: delta }).fill(undefined)];\n      } else {\n        args = args.slice(0, firstDependencyArgIndex);\n      }\n    }\n\n    const thing = new Ctor(...args, ...resolvedArgs);\n\n    item?.onInstantiation?.(thing);\n\n    this.markResolutionCompleted();\n\n    return thing;\n  }\n\n  private _resolveFactory<T>(\n    id: DependencyIdentifier<T>,\n    item: FactoryDependencyItem<T>,\n    shouldCache: boolean,\n  ): T {\n    this.markNewResolution(id);\n\n    const declaredDependencies = normalizeFactoryDeps(item.deps);\n\n    const resolvedArgs: any[] = [];\n    for (const dep of declaredDependencies) {\n      try {\n        const thing = this._get(\n          dep.identifier,\n          dep.quantity,\n          dep.lookUp,\n          dep.withNew,\n        );\n        resolvedArgs.push(thing);\n      } catch (error: unknown) {\n        if (\n          error instanceof DependencyNotFoundError ||\n          (error instanceof QuantityCheckError && error.actual === 0)\n        ) {\n          throw new DependencyNotFoundForModuleError(\n            id,\n            dep.identifier,\n            dep.paramIndex,\n          );\n        }\n\n        // should throw the error (user should handle it)\n        throw error;\n      }\n    }\n\n    const thing = item.useFactory.apply(null, resolvedArgs);\n\n    if (shouldCache) {\n      this.resolvedDependencyCollection.add(id, thing);\n    }\n\n    this.markResolutionCompleted();\n\n    item?.onInstantiation?.(thing);\n\n    return thing;\n  }\n\n  private _resolveAsync<T>(\n    id: DependencyIdentifier<T>,\n    item: AsyncDependencyItem<T>,\n  ): AsyncHook<T> {\n    const asyncLoader: AsyncHook<T> = {\n      __symbol: AsyncHookSymbol,\n      whenReady: () => this._resolveAsyncImpl(id, item),\n    };\n    return asyncLoader;\n  }\n\n  private _resolveAsyncImpl<T>(\n    id: DependencyIdentifier<T>,\n    item: AsyncDependencyItem<T>,\n  ): Promise<T> {\n    return item.useAsync().then((thing) => {\n      // check if another promise has been resolved,\n      // do not resolve the async item twice\n      const resolvedCheck = this.getValue(id);\n      if (resolvedCheck !== NotInstantiatedSymbol) {\n        return resolvedCheck as T;\n      }\n\n      let ret: T;\n      if (Array.isArray(thing)) {\n        const item = thing[1];\n        if (isAsyncDependencyItem(item)) {\n          throw new AsyncItemReturnAsyncItemError(id);\n        } else {\n          ret = this._resolveDependency(id, item) as T;\n        }\n      } else if (isCtor(thing)) {\n        ret = this._resolveClassImpl({\n          useClass: thing,\n          onInstantiation: item.onInstantiation,\n        });\n      } else {\n        ret = thing;\n      }\n\n      this.resolvedDependencyCollection.add(id, ret);\n\n      return ret;\n    });\n  }\n\n  private getValue<T>(\n    id: DependencyIdentifier<T>,\n    quantity: Quantity = Quantity.REQUIRED,\n    lookUp?: LookUp,\n  ): null | T | T[] | typeof NotInstantiatedSymbol {\n    const onSelf = () => {\n      if (\n        this.dependencyCollection.has(id) &&\n        !this.resolvedDependencyCollection.has(id)\n      ) {\n        return NotInstantiatedSymbol;\n      }\n\n      return this.resolvedDependencyCollection.get(id, quantity);\n    };\n\n    const onParent = () => {\n      if (this.parent) {\n        return this.parent.getValue(id, quantity);\n      } else {\n        if (quantity === Quantity.OPTIONAL) {\n          return null;\n        } else if (quantity === Quantity.MANY) {\n          return [];\n        }\n\n        throw new QuantityCheckError(id, Quantity.REQUIRED, 0);\n      }\n    };\n\n    if (lookUp === LookUp.SKIP_SELF) {\n      return onParent();\n    }\n\n    if (id === Injector) {\n      return this as unknown as T;\n    }\n\n    if (lookUp === LookUp.SELF) {\n      return onSelf();\n    }\n\n    if (\n      this.resolvedDependencyCollection.has(id) ||\n      this.dependencyCollection.has(id)\n    ) {\n      return onSelf();\n    }\n\n    return onParent();\n  }\n\n  private createDependency<T>(\n    id: DependencyIdentifier<T>,\n    quantity: Quantity,\n    lookUp?: LookUp,\n    shouldCache = true,\n  ): null | T | T[] | AsyncHook<T> | (T | AsyncHook<T>)[] {\n    const onSelf = () => {\n      const registrations = this.dependencyCollection.get(id, quantity)!;\n\n      let ret: (T | AsyncHook<T>)[] | T | AsyncHook<T> | null = null;\n      if (Array.isArray(registrations)) {\n        ret = registrations.map((dependencyItem) =>\n          this._resolveDependency(id, dependencyItem, shouldCache),\n        );\n      } else {\n        ret = this._resolveDependency(id, registrations, shouldCache);\n      }\n\n      return ret;\n    };\n\n    const onParent = () => {\n      if (this.parent) {\n        return this.parent.createDependency(\n          id,\n          quantity,\n          undefined,\n          shouldCache,\n        );\n      } else {\n        if (quantity === Quantity.OPTIONAL) {\n          return null;\n        } else if (quantity === Quantity.MANY) {\n          return [];\n        }\n\n        pushResolvingStack(id);\n        throw new DependencyNotFoundError(id);\n      }\n    };\n\n    if (lookUp === LookUp.SKIP_SELF) {\n      return onParent();\n    }\n\n    if (this.dependencyCollection.has(id)) {\n      return onSelf();\n    }\n\n    return onParent();\n  }\n\n  private markNewResolution<T>(id: DependencyIdentifier<T>): void {\n    this.resolutionOngoing += 1;\n\n    if (this.resolutionOngoing >= MAX_RESOLUTIONS_QUEUED) {\n      throw new CircularDependencyError(id);\n    }\n  }\n\n  private markResolutionCompleted(): void {\n    this.resolutionOngoing -= 1;\n  }\n\n  private _ensureInjectorNotDisposed(): void {\n    if (this.disposed) {\n      throw new InjectorAlreadyDisposedError();\n    }\n  }\n}\n","/* eslint-disable node/prefer-global/process */\n\nexport { createIdentifier } from './decorators';\nexport type { Dependency, DependencyPair } from './dependencyCollection';\nexport { setDependencies } from './dependencyDeclare';\nexport { forwardRef } from './dependencyForwardRef';\nexport {\n  type DependencyIdentifier,\n  type IdentifierDecorator,\n} from './dependencyIdentifier';\nexport {\n  type AsyncDependencyItem,\n  type AsyncHook,\n  type ClassDependencyItem,\n  type Ctor,\n  type DependencyItem,\n  type FactoryDependencyItem,\n  isAsyncDependencyItem,\n  isAsyncHook,\n  isClassDependencyItem,\n  isCtor,\n  isFactoryDependencyItem,\n  isValueDependencyItem,\n  type SyncDependencyItem,\n  type ValueDependencyItem,\n} from './dependencyItem';\nexport { Self, SkipSelf } from './dependencyLookUp';\nexport { Inject, Many, Optional } from './dependencyQuantity';\nexport { WithNew } from './dependencyWithNew';\nexport { type IDisposable, isDisposable } from './dispose';\nexport { RediError } from './error';\nexport { type IAccessor, Injector } from './injector';\nexport { LookUp, Quantity } from './types';\n\nconst globalObject: any =\n  (typeof globalThis !== 'undefined' && globalThis) ||\n  (typeof window !== 'undefined' && window) ||\n  // eslint-disable-next-line no-restricted-globals\n  (typeof global !== 'undefined' && global);\n\nconst __REDI_GLOBAL_LOCK__ = 'REDI_GLOBAL_LOCK';\nconst isNode =\n  typeof process !== 'undefined' &&\n  process.versions != null &&\n  process.versions.node != null;\n\nif (globalObject[__REDI_GLOBAL_LOCK__]) {\n  if (!isNode) {\n    console.error(`[redi]: You are loading scripts of redi more than once! This may cause undesired behavior in your application.\nMaybe your dependencies added redi as its dependency and bundled redi to its dist files. Or you import different versions of redi.\nFor more info please visit our website: https://redi.wendell.fun/en-US/docs/faq#import-scripts-of-redi-more-than-once`);\n  }\n} else {\n  globalObject[__REDI_GLOBAL_LOCK__] = true;\n}\n"],"mappings":"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"}