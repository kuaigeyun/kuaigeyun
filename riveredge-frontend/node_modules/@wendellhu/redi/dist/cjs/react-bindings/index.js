//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
const __wendellhu_redi = __toESM(require("@wendellhu/redi"));
const react = __toESM(require("react"));
const react_jsx_runtime = __toESM(require("react/jsx-runtime"));

//#region src/react-bindings/reactContext.tsx
const RediContext = (0, react.createContext)({ injector: null });
RediContext.displayName = "RediContext";
const RediProvider = RediContext.Provider;
const RediConsumer = RediContext.Consumer;

//#endregion
//#region src/react-bindings/reactComponent.tsx
function RediInjector(props) {
	const { children, dependencies } = props;
	const childInjectorRef = (0, react.useRef)(null);
	(0, react.useEffect)(() => () => childInjectorRef.current?.dispose(), []);
	return /* @__PURE__ */ (0, react_jsx_runtime.jsx)(RediConsumer, { children: (context) => {
		let childInjector;
		/* istanbul ignore next -- @preserve */
		if (childInjectorRef.current) childInjector = childInjectorRef.current;
		else {
			childInjector = context.injector ? context.injector.createChild(dependencies) : new __wendellhu_redi.Injector(dependencies);
			childInjectorRef.current = childInjector;
		}
		return /* @__PURE__ */ (0, react_jsx_runtime.jsx)(RediProvider, {
			value: { injector: childInjector },
			children
		});
	} });
}
/**
* @param Comp
* @param injector
* @returns A component type that can be rendered.
*/
function connectInjector(Comp, injector) {
	return function ComponentWithInjector(props) {
		return /* @__PURE__ */ (0, react_jsx_runtime.jsx)(RediProvider, {
			value: { injector },
			children: /* @__PURE__ */ (0, react_jsx_runtime.jsx)(Comp, { ...props })
		});
	};
}
function connectDependencies(Comp, dependencies) {
	return function ComponentWithInjector(props) {
		return /* @__PURE__ */ (0, react_jsx_runtime.jsx)(RediInjector, {
			dependencies,
			children: /* @__PURE__ */ (0, react_jsx_runtime.jsx)(Comp, { ...props })
		});
	};
}

//#endregion
//#region src/react-bindings/reactDecorators.ts
var ClassComponentNotInRediContextError = class extends __wendellhu_redi.RediError {
	constructor(component) {
		super(`You should make "RediContext" as ${component.constructor.name}'s default context type. If you want to use multiple context, please check this on React doc site. https://reactjs.org/docs/context.html#classcontexttype`);
	}
};
function WithDependency(id, quantity, lookUp) {
	return function() {
		return { get() {
			const thisComponent = this;
			const context = thisComponent.context;
			if (!context || !context.injector) throw new ClassComponentNotInRediContextError(thisComponent);
			const injector = context.injector;
			const thing = injector.get(id, quantity || __wendellhu_redi.Quantity.REQUIRED, lookUp);
			return thing;
		} };
	};
}

//#endregion
//#region src/react-bindings/reactHooks.tsx
var HooksNotInRediContextError = class extends __wendellhu_redi.RediError {
	constructor() {
		super("Using dependency injection outside of a RediContext.");
	}
};
function useInjector() {
	const injectionContext = (0, react.useContext)(RediContext);
	if (!injectionContext.injector) throw new HooksNotInRediContextError();
	return injectionContext.injector;
}
function useDependency(id, quantityOrLookUp, lookUp) {
	const injector = useInjector();
	return (0, react.useMemo)(() => injector.get(id, quantityOrLookUp, lookUp), [
		id,
		quantityOrLookUp,
		lookUp
	]);
}

//#endregion
//#region src/react-bindings/reactRx.tsx
function unwrap(o) {
	if (typeof o === "function") return o();
	return o;
}
/**
* Subscribe to an observable and return its value. The component will re-render when the observable emits a new value.
*
* @param observable An observable or a function that returns an observable
* @param defaultValue The default value of the observable. It the `observable` can omit an initial value, this value will be neglected.
* @param shouldHaveSyncValue If the observable should have a sync value. If it does not have a sync value, an error will be thrown.
* @param deps A dependency array to decide if we should re-subscribe when the `observable` is a function.
* @returns Value or null.
*/
function useObservable(observable, defaultValue, shouldHaveSyncValue, deps) {
	if (typeof observable === "function" && !deps) throw new __wendellhu_redi.RediError("Expected deps to be provided when observable is a function!");
	const observableRef = (0, react.useRef)(null);
	const receivedSyncValueRef = (0, react.useRef)(false);
	const subscribedRef = (0, react.useRef)(false);
	const destObservable = (0, react.useMemo)(() => observable, [...typeof deps !== "undefined" ? deps : [observable]]);
	const [_, setRenderCounter] = (0, react.useState)(0);
	const valueRef = (0, react.useRef)((() => {
		let innerDefaultValue;
		if (destObservable) {
			const sub = unwrap(destObservable).subscribe((value) => {
				receivedSyncValueRef.current = true;
				innerDefaultValue = value;
			});
			sub.unsubscribe();
		}
		return innerDefaultValue ?? defaultValue;
	})());
	(0, react.useLayoutEffect)(() => {
		subscribedRef.current = false;
		let subscription = null;
		if (destObservable) {
			observableRef.current = unwrap(destObservable);
			subscription = observableRef.current.subscribe((value) => {
				if (receivedSyncValueRef.current && !subscribedRef.current && value === valueRef.current) {
					subscribedRef.current = true;
					return;
				}
				subscribedRef.current = true;
				valueRef.current = value;
				setRenderCounter((prev) => prev + 1);
			});
		}
		return () => subscription?.unsubscribe();
	}, [destObservable]);
	if (shouldHaveSyncValue && !receivedSyncValueRef.current) throw new Error("[redi]: Expect `shouldHaveSyncValue` but not getting a sync value!");
	return valueRef.current;
}
/**
* subscribe to a signal that emits whenever data updates and re-render
*
* @param update$ a signal that the data the functional component depends has updated
*/
function useUpdateBinder(update$) {
	const [, dumpSet] = (0, react.useState)(0);
	(0, react.useEffect)(() => {
		const subscription = update$.subscribe(() => dumpSet((prev) => prev + 1));
		return () => subscription.unsubscribe();
	}, []);
}

//#endregion
//#region src/react-bindings/publicApi.ts
const __REDI_CONTEXT_LOCK__ = "REDI_CONTEXT_LOCK";
const isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
const globalObject = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global !== "undefined" && global;
if (!globalObject[__REDI_CONTEXT_LOCK__]) globalObject[__REDI_CONTEXT_LOCK__] = true;
else if (!isNode) console.error("[redi]: \"RediContext\" is already created. You may import \"RediContext\" from different paths. Use \"import { RediContext } from '@wendellhu/redi/react-bindings'; instead.\"");

//#endregion
exports.RediConsumer = RediConsumer;
exports.RediContext = RediContext;
exports.RediProvider = RediProvider;
exports.WithDependency = WithDependency;
exports.connectDependencies = connectDependencies;
exports.connectInjector = connectInjector;
exports.useDependency = useDependency;
exports.useInjector = useInjector;
exports.useObservable = useObservable;
exports.useUpdateBinder = useUpdateBinder;
//# sourceMappingURL=index.js.map