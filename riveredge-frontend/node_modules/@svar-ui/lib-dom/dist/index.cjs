'use strict';

// src/locate.ts
function locate(el, attr = "data-id") {
  let node = el;
  if (!node.tagName && el.target)
    node = el.target;
  while (node) {
    if (node.getAttribute) {
      const id3 = node.getAttribute(attr);
      if (id3) return node;
    }
    node = node.parentNode;
  }
  return null;
}
function locateAttr(el, attr = "data-id") {
  const node = locate(el, attr);
  if (node) return node.getAttribute(attr);
  return null;
}
function locateID(el, attr = "data-id") {
  const node = locate(el, attr);
  if (node) {
    return id(node.getAttribute(attr));
  }
  return null;
}
function locateNode(el, node) {
  let n = el;
  while (n) {
    if (n === node) {
      return true;
    }
    n = n?.parentNode;
  }
  return null;
}
function id(value) {
  if (typeof value === "string") {
    const t = value * 1;
    if (!isNaN(t)) return t;
  }
  return value;
}

// src/env.ts
function getEnv() {
  return {
    detect: () => true,
    addEvent: function(node, event, handler) {
      node.addEventListener(event, handler);
      return () => node.removeEventListener(event, handler);
    },
    addGlobalEvent: function(event, handler) {
      document.addEventListener(event, handler);
      return () => document.removeEventListener(event, handler);
    },
    getTopNode: function() {
      return window.document.body;
    }
  };
}
var env = getEnv();
function setEnv(update) {
  Object.assign(env, update);
}

// src/delegateClick.ts
function delegateEvent(node, handlers, event) {
  function handleEvent(ev) {
    const node2 = locate(ev);
    if (!node2) return;
    const id3 = id(node2.dataset.id);
    if (typeof handlers === "function") return handlers(id3, ev);
    let action;
    let test = ev.target;
    while (test != node2) {
      action = test.dataset ? test.dataset.action : null;
      if (action) {
        if (handlers[action]) {
          handlers[action](id3, ev);
          return;
        }
      }
      test = test.parentNode;
    }
    if (handlers[event]) handlers[event](id3, ev);
  }
  env.addEvent(node, event, handleEvent);
}
function delegateClick(node, handlers) {
  delegateEvent(node, handlers, "click");
  if (handlers.dblclick) delegateEvent(node, handlers.dblclick, "dblclick");
}

// src/array.ts
function remove(items, node) {
  for (let i = items.length - 1; i >= 0; i--) {
    if (items[i] === node) {
      items.splice(i, 1);
      break;
    }
  }
}

// src/clickOutside.ts
var activationDate = /* @__PURE__ */ new Date();
var skipNext = false;
var outsideHandlers = [];
var outsideListners = [];
var handleOutsideClick = (event) => {
  if (skipNext) {
    skipNext = false;
    return;
  }
  for (let i = outsideListners.length - 1; i >= 0; i--) {
    const { node, date, props } = outsideListners[i];
    if (date > activationDate) continue;
    if (!node.contains(event.target) && node !== event.target) {
      if (props.callback) props.callback(event);
      if (props.modal || event.defaultPrevented) break;
    }
  }
};
var handleMouseDown = (event) => {
  activationDate = /* @__PURE__ */ new Date();
  skipNext = true;
  for (let i = outsideListners.length - 1; i >= 0; i--) {
    const { node } = outsideListners[i];
    if (!node.contains(event.target) && node !== event.target) {
      skipNext = false;
      break;
    }
  }
};
function clickOutside(node, props) {
  if (!outsideHandlers.length) {
    outsideHandlers = [
      env.addGlobalEvent("click", handleOutsideClick, node),
      env.addGlobalEvent("contextmenu", handleOutsideClick, node),
      env.addGlobalEvent("mousedown", handleMouseDown, node)
    ];
  }
  if (typeof props !== "object") {
    props = { callback: props };
  }
  const pack = { node, date: /* @__PURE__ */ new Date(), props };
  outsideListners.push(pack);
  return {
    destroy() {
      remove(outsideListners, pack);
      if (!outsideListners.length) {
        outsideHandlers.forEach((e) => e());
        outsideHandlers = [];
      }
    }
  };
}

// src/positioning.ts
var isBottom = (mode) => mode.indexOf("bottom") !== -1;
var isLeft = (mode) => mode.indexOf("left") !== -1;
var isRight = (mode) => mode.indexOf("right") !== -1;
var isTop = (mode) => mode.indexOf("top") !== -1;
var isFit = (mode) => mode.indexOf("fit") !== -1;
var isOverlap = (mode) => mode.indexOf("overlap") !== -1;
var isCenter = (mode) => {
  return mode.split("-").every((v) => ["center", "fit"].indexOf(v) > -1);
};
var getAlign = (mode) => {
  const match = mode.match(/(start|center|end)/);
  return match ? match[0] : null;
};
function getMaxIndex(p, ap) {
  let zi = 0;
  const top = env.getTopNode(p);
  while (p) {
    if (p === top) break;
    const pos2 = getComputedStyle(p)["position"];
    if (pos2 === "absolute" || pos2 === "relative" || pos2 === "fixed") {
      zi = parseInt(getComputedStyle(p)["zIndex"]) || 0;
    }
    p = p.parentNode;
    if (p === ap) break;
  }
  return zi;
}
var x;
var y;
var width;
var pos;
function calculatePosition(self, parent, at = "bottom", left = 0, top = 0) {
  if (!self) return null;
  x = left;
  y = top;
  width = "auto";
  let z = 0;
  let fixLeft = 0;
  const body = getAbsParent(self);
  const cont = isOverlap(at) ? env.getTopNode(self) : body;
  if (!body) return null;
  const bodyRect = body.getBoundingClientRect();
  const selfRect = self.getBoundingClientRect();
  const contRect = cont.getBoundingClientRect();
  const contStyle = window.getComputedStyle(cont);
  const border = {
    left: 0,
    top: 0,
    bottom: 0,
    right: 0
  };
  for (const key in border) {
    const style = `border-${key}-width`;
    border[key] = parseFloat(contStyle.getPropertyValue(style));
  }
  if (parent) {
    const zi = getMaxIndex(parent, body);
    z = Math.max(zi + 1, 20);
  }
  if (parent) {
    pos = parent.getBoundingClientRect();
    if (isFit(at)) width = pos.width + "px";
    if (at !== "point") {
      if (isCenter(at)) {
        if (isFit(at)) {
          x = 0;
        } else {
          x = contRect.width / 2;
          fixLeft = 1;
        }
        y = (contRect.height - selfRect.height) / 2;
      } else {
        const fix = isOverlap(at) ? 0 : 1;
        x = isRight(at) ? pos.right + fix : pos.left - fix;
        y = isBottom(at) ? pos.bottom + 1 : pos.top;
        const align = getAlign(at);
        if (align) {
          if (isRight(at) || isLeft(at)) {
            if (align === "center") y -= (selfRect.height - pos.height) / 2;
            else if (align === "end") y -= selfRect.height - pos.height;
          } else if (isBottom(at) || isTop(at)) {
            if (align === "center") x -= (selfRect.width - pos.width) / 2;
            else if (align === "end") x -= selfRect.width - pos.width;
            if (!isOverlap(at)) x += 1;
          }
        }
      }
    }
  } else pos = { left, right: left, top, bottom: top };
  const isCorner = (isLeft(at) || isRight(at)) && (isBottom(at) || isTop(at));
  if (isLeft(at)) {
    fixLeft = 2;
  }
  const dxL = x - selfRect.width - contRect.left;
  if (parent && isLeft(at) && !isCorner && dxL < 0) {
    x = pos.right;
    fixLeft = 0;
  }
  const dxR = x + selfRect.width * (1 - fixLeft / 2) - contRect.right;
  if (dxR > 0) {
    if (!isRight(at)) {
      x = contRect.right - border.right - selfRect.width;
    } else {
      const dx = pos.left - contRect.x - selfRect.width;
      if (parent && !isOverlap(at) && !isCorner && dx >= 0) {
        x = pos.left - selfRect.width;
      } else {
        x -= dxR + border.right;
      }
    }
  }
  if (fixLeft) {
    x = Math.round(x - selfRect.width * fixLeft / 2);
  }
  const needSwap = dxL < 0 || dxR > 0 || !isCorner;
  if (isTop(at)) {
    y = pos.top - selfRect.height;
    if (parent && y < contRect.y && needSwap) {
      y = pos.bottom;
    }
  }
  const dy = y + selfRect.height - contRect.bottom;
  if (dy > 0) {
    if (parent && isBottom(at) && needSwap) {
      y -= selfRect.height + pos.height + 1;
    } else {
      y -= dy + border.bottom;
    }
  }
  x -= bodyRect.left + border.left;
  y -= bodyRect.top + border.top;
  x = Math.max(x, 0) + cont.scrollLeft;
  y = Math.max(y, 0) + cont.scrollTop;
  width = width || "auto";
  return { x, y, z, width };
}
function getAbsParent(el) {
  const top = env.getTopNode(el);
  if (el) el = el.parentElement;
  while (el) {
    const pos2 = getComputedStyle(el)["position"];
    if (el === top || pos2 === "relative" || pos2 === "absolute" || pos2 === "fixed")
      return el;
    el = el.parentNode;
  }
  return null;
}

// src/common.ts
var id2 = (/* @__PURE__ */ new Date()).valueOf();
function uid() {
  id2 += 1;
  return id2;
}

// src/hotkeys.ts
var ScreenKeys = class {
  constructor() {
    this.store = /* @__PURE__ */ new Map();
  }
  configure(hotkeys2, node) {
    this.node = node;
    for (const hotkey in hotkeys2) {
      if (hotkeys2[hotkey]) {
        const hotkeyFormatted = hotkey.toLowerCase().replace(/[ ]/g, "");
        const handler = hotkeys2[hotkey];
        this.store.set(hotkeyFormatted, handler);
      }
    }
  }
};
var chain = [];
var hotkeys = {
  subscribe: (v) => {
    init_once();
    const t = new ScreenKeys();
    chain.push(t);
    v(t);
    return () => {
      const ind = chain.findIndex((a) => a === t);
      if (ind >= 0) chain.splice(ind, 1);
    };
  }
};
var ready = false;
function init_once() {
  if (ready) return;
  ready = true;
  document.addEventListener("keydown", (ev) => {
    if (chain.length && (ev.ctrlKey || ev.altKey || ev.metaKey || ev.shiftKey || ev.key.length > 1 || ev.key === " ")) {
      const code = [];
      if (ev.ctrlKey) code.push("ctrl");
      if (ev.altKey) code.push("alt");
      if (ev.metaKey) code.push("meta");
      if (ev.shiftKey) code.push("shift");
      let evKey = ev.code.replace("Key", "").toLocaleLowerCase();
      if (ev.key === " ") {
        evKey = "space";
      }
      code.push(evKey);
      const key = code.join("+");
      for (let i = chain.length - 1; i >= 0; i--) {
        const target = chain[i];
        const handler = target.store.get(key) || target.store.get(evKey);
        if (handler && target.node.contains(ev.target)) {
          handler(ev, { key, evKey });
        }
      }
    }
  });
}

// src/dates.ts
function toFixed(num) {
  if (num < 10) return "0" + num;
  return num.toString();
}
function toFixedMs(num) {
  const temp = toFixed(num);
  return temp.length == 2 ? "0" + temp : temp;
}
function getDuodecade(year) {
  const start = Math.floor(year / 11) * 11;
  return {
    start,
    end: start + 11
  };
}
function getWeekNumber(ndate, weekStart = 1) {
  let nday = ndate.getDay();
  if (nday === 0) {
    nday = 7;
  }
  nday = (nday - weekStart + 7) % 7;
  const first_thursday = new Date(ndate.valueOf());
  first_thursday.setDate(ndate.getDate() + (3 - nday));
  const year_number = first_thursday.getFullYear();
  const ordinal_date = Math.floor(
    (first_thursday.getTime() - new Date(year_number, 0, 1).getTime()) / 864e5
  );
  return 1 + Math.floor(ordinal_date / 7);
}
var emptyAmPm = ["", ""];
function date2str(mask, date, locale2) {
  switch (mask) {
    case "%d":
      return toFixed(date.getDate());
    case "%m":
      return toFixed(date.getMonth() + 1);
    case "%j":
      return date.getDate();
    case "%n":
      return date.getMonth() + 1;
    case "%y":
      return toFixed(date.getFullYear() % 100);
    case "%Y":
      return date.getFullYear();
    case "%D":
      return locale2.dayShort[date.getDay()];
    case "%l":
      return locale2.dayFull[date.getDay()];
    case "%M":
      return locale2.monthShort[date.getMonth()];
    case "%F":
      return locale2.monthFull[date.getMonth()];
    case "%h":
      return toFixed((date.getHours() + 11) % 12 + 1);
    case "%g":
      return (date.getHours() + 11) % 12 + 1;
    case "%G":
      return date.getHours();
    case "%H":
      return toFixed(date.getHours());
    case "%i":
      return toFixed(date.getMinutes());
    case "%a":
      return ((date.getHours() > 11 ? locale2.pm : locale2.am) || emptyAmPm)[0];
    case "%A":
      return ((date.getHours() > 11 ? locale2.pm : locale2.am) || emptyAmPm)[1];
    case "%s":
      return toFixed(date.getSeconds());
    case "%S":
      return toFixedMs(date.getMilliseconds());
    case "%W":
      return toFixed(getWeekNumber(date));
    case "%w":
      return toFixed(getWeekNumber(date, locale2.weekStart ?? 1));
    case "%c": {
      let str = date.getFullYear() + "";
      str += "-" + toFixed(date.getMonth() + 1);
      str += "-" + toFixed(date.getDate());
      str += "T";
      str += toFixed(date.getHours());
      str += ":" + toFixed(date.getMinutes());
      str += ":" + toFixed(date.getSeconds());
      return str;
    }
    case "%Q":
      return Math.floor(date.getMonth() / 3) + 1;
    default:
      return mask;
  }
}
var formatFlags = /%[a-zA-Z]/g;
function dateToString(format, locale2) {
  if (typeof format == "function") return format;
  return function(date) {
    if (!date) return "";
    if (!date.getMonth) date = new Date(date);
    return format.replace(
      formatFlags,
      (s) => date2str(s, date, locale2)
    );
  };
}

// src/locale.ts
function isObject(a) {
  return a && typeof a === "object" && !Array.isArray(a);
}
function extend(a, b) {
  for (const key in b) {
    const from = b[key];
    if (isObject(a[key]) && isObject(from)) {
      a[key] = extend(
        { ...a[key] },
        b[key]
      );
    } else {
      a[key] = b[key];
    }
  }
  return a;
}
function locale(words) {
  return {
    getGroup(group) {
      const block = words[group];
      return (key) => {
        return block ? block[key] || key : key;
      };
    },
    getRaw() {
      return words;
    },
    extend(values, optional) {
      if (!values) return this;
      let data;
      if (optional) {
        data = extend({ ...values }, words);
      } else {
        data = extend({ ...words }, values);
      }
      return locale(data);
    }
  };
}

// src/salesforce.ts
var salesForceEnv = {
  detect() {
    if (typeof window === "undefined") return false;
    return (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      !!window["Sfdc"] || // eslint-disable-next-line @typescript-eslint/no-explicit-any
      !!window["$A"] || // eslint-disable-next-line @typescript-eslint/no-explicit-any
      !!window["Aura"] || "$shadowResolver$" in document.body
    );
  },
  addGlobalEvent: function(event, handler, rel) {
    const d = salesForceEnv.getTopNode(rel);
    d.addEventListener(event, handler);
    return () => d.removeEventListener(event, handler);
  },
  getTopNode: function(rel) {
    return rel.closest('[data-wx-root="true"]');
  }
};

exports.calculatePosition = calculatePosition;
exports.clickOutside = clickOutside;
exports.dateToString = dateToString;
exports.delegateClick = delegateClick;
exports.delegateEvent = delegateEvent;
exports.env = env;
exports.getAbsParent = getAbsParent;
exports.getDuodecade = getDuodecade;
exports.hotkeys = hotkeys;
exports.id = id;
exports.locale = locale;
exports.locate = locate;
exports.locateAttr = locateAttr;
exports.locateID = locateID;
exports.locateNode = locateNode;
exports.salesForceEnv = salesForceEnv;
exports.setEnv = setEnv;
exports.uid = uid;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map