'use strict';

// src/helpers.ts
var iid = (/* @__PURE__ */ new Date()).valueOf();
var uid = () => iid++;
function tempID() {
  return "temp://" + iid++;
}
function isTempID(v) {
  return typeof v === "string" && v.length === 20 && parseInt(v.substr(7)) > 1e12;
}
function isSameObject(left, right) {
  if (Object.keys(left).length !== Object.keys(right).length) return false;
  for (const key in right) {
    const v = left[key];
    const nv = right[key];
    if (!isSame(v, nv)) return false;
  }
  return true;
}
function isSame(v, nv) {
  const primitiveValue = typeof v === "number" || typeof v === "string" || typeof v === "boolean" || v === null;
  if (primitiveValue) return v === nv;
  if (typeof v !== typeof nv) return false;
  if ((v === null || nv === null) && v !== nv) return false;
  if (v instanceof Date && nv instanceof Date && v.getTime() !== nv.getTime())
    return false;
  if (typeof v === "object") {
    if (Array.isArray(v) && Array.isArray(nv)) {
      if (v.length !== nv.length) return false;
      for (let i = v.length - 1; i >= 0; i--) {
        if (!isSame(v[i], nv[i])) return false;
      }
      return true;
    } else {
      return isSameObject(v, nv);
    }
  }
  return v === nv;
}
function deepCopy(obj) {
  if (typeof obj !== "object") return obj;
  if (obj === null) return obj;
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof Array) return obj.map(deepCopy);
  const out = {};
  for (const key in obj) {
    out[key] = deepCopy(obj[key]);
  }
  return out;
}

// src/DataArray.ts
var _DataArray = class {
  constructor(raw) {
    this._data = raw;
    this._pool = /* @__PURE__ */ new Map();
    for (let i = 0; i < raw.length; i++) {
      const obj = raw[i];
      this._pool.set(obj.id, obj);
    }
  }
  add(raw) {
    raw = { id: uid(), ...raw };
    this._data.push(raw);
    this._pool.set(raw.id, raw);
  }
  update(id, raw) {
    const index = this._data.findIndex((link) => link.id == id);
    const old = this._data[index];
    const updated = { ...old, ...raw };
    this._data[index] = updated;
    this._pool.set(updated.id, updated);
  }
  remove(id) {
    this._data = this._data.filter((a) => a.id != id);
    this._pool.delete(id);
  }
  filter(cb) {
    this._data = this._data.filter((x) => {
      const check = cb(x);
      if (!check) this._pool.delete(x.id);
      return check;
    });
  }
  byId(id) {
    return this._pool.get(id);
  }
  map(cb) {
    return this._data.map(cb);
  }
  forEach(cb) {
    this._data.forEach(cb);
  }
};

// src/DataTree.ts
var DataTree = class {
  constructor(raw) {
    const top = {
      id: 0,
      $level: 0,
      data: [],
      parent: null
    };
    const items = /* @__PURE__ */ new Map();
    items.set(0, top);
    this._pool = items;
    if (raw && raw.length) this.parse(raw, 0);
  }
  parse(raw, parent) {
    const items = this._pool;
    for (let i = 0; i < raw.length; i++) {
      const obj = raw[i];
      obj.parent = obj.parent || parent;
      obj.data = null;
      items.set(obj.id, obj);
    }
    for (let i = 0; i < raw.length; i++) {
      const obj = raw[i];
      const temp = items.get(obj.parent);
      if (temp) {
        if (!temp.data) temp.data = [];
        temp.data.push(obj);
      }
    }
    const top = items.get(parent);
    this.setLevel(top, top.$level + 1, false);
  }
  add(raw, index) {
    const parent = this._pool.get(raw.parent || 0);
    raw.$level = parent.$level + 1;
    this._pool.set(raw.id, raw);
    if (parent.data) {
      if (index === -1) parent.data = [...parent.data, raw];
      else insertElement(parent, index, raw);
    } else parent.data = [raw];
  }
  addAfter(raw, after) {
    if (!after) {
      return this.add(raw, -1);
    }
    const node = this.byId(after);
    const parent = this.byId(node.parent);
    const index = indexById(parent, node.id) + 1;
    raw.parent = parent.id;
    raw.$level = parent.$level + 1;
    this.add(raw, index);
  }
  remove(id) {
    const obj = this._pool.get(id);
    this._remove(obj);
    const parent = this._pool.get(obj.parent);
    parent.data = parent.data.filter((a) => a.id != id);
    this._clearBranch(parent);
  }
  _remove(obj) {
    if (obj.data) {
      obj.data.forEach((i) => this._remove(i));
    }
    this._pool.delete(obj.id);
  }
  update(id, values) {
    let obj = this._pool.get(id);
    const branch = this._pool.get(obj.parent);
    const index = indexById(branch, obj.id);
    obj = { ...obj, ...values };
    if (branch && index >= 0) {
      branch.data[index] = obj;
      branch.data = [...branch.data];
    }
    this._pool.set(obj.id, obj);
  }
  move(id, mode, target) {
    const now = this._pool.get(id);
    const dropChild = mode === "child";
    const tobj = this._pool.get(target);
    const tLevel = tobj.$level + (dropChild ? 1 : 0);
    if (!now || !tobj) return;
    const parent = this._pool.get(now.parent);
    const newParent = dropChild ? tobj : this._pool.get(tobj.parent);
    if (!newParent.data) newParent.data = [];
    const index = indexById(parent, now.id);
    deleteElement(parent, index);
    const newIndex = dropChild ? newParent.data.length : indexById(newParent, tobj.id) + (mode === "after" ? 1 : 0);
    insertElement(newParent, newIndex, now);
    if (parent.id === newParent.id && index === newIndex) return null;
    now.parent = newParent.id;
    if (now.$level !== tLevel) {
      now.$level = tLevel;
      this.setLevel(now, tLevel + 1, true);
    }
    this.update(now.id, now);
    this._clearBranch(parent);
  }
  _clearBranch(obj) {
    if (obj.data && !obj.data.length) {
      if (obj.open) delete obj.open;
      this.update(obj.id, { data: null });
    }
  }
  toArray() {
    const out = [];
    const kids = this._pool.get(0).data;
    if (kids) toArray(kids, out);
    return out;
  }
  byId(id) {
    return this._pool.get(id);
  }
  getBranch(id) {
    return this._pool.get(id).data;
  }
  forEach(cb) {
    this._pool.forEach((value, key) => {
      if (key !== 0) cb(value);
    });
  }
  eachChild(cb, parent) {
    const p = this.byId(parent);
    if (!p || !p.data) return;
    p.data.forEach((child, index) => {
      cb(this.byId(child.id), index);
      this.eachChild(cb, child.id);
    });
  }
  setLevel(root, level, copy) {
    if (!root.data) return;
    root.data = root.data.map((child) => {
      if (copy) {
        child = { ...child };
        this._pool.set(child.id, child);
      }
      child.$level = level;
      if (child.data) this.setLevel(child, level + 1, copy);
      return child;
    });
  }
};
function toArray(line, out) {
  line.forEach((a) => {
    out.push(a);
    if (a.open === true) {
      toArray(a.data, out);
    }
  });
}
function deleteElement(obj, index) {
  const newData = [...obj.data];
  newData.splice(index, 1);
  obj.data = newData;
}
function insertElement(obj, index, item) {
  const newData = [...obj.data];
  newData.splice(index, 0, item);
  obj.data = newData;
}
function indexById(parentNode, id) {
  return parentNode?.data.findIndex(
    (child) => child.id === id
  );
}

// src/Store.ts
var STORE_SET_SILENT = 2;
var Store = class {
  constructor(config) {
    if (config) {
      this._writable = config.writable;
      this._async = config.async;
    }
    this._values = {};
    this._state = {};
  }
  setState(data, mode = 0) {
    const signals = {};
    this._wrapProperties(
      data,
      this._state,
      this._values,
      "",
      signals,
      mode
    );
    return signals;
  }
  getState() {
    return this._values;
  }
  getReactive() {
    return this._state;
  }
  _wrapProperties(data, state, values, parent, signals, mode) {
    for (const key in data) {
      const os = state[key];
      const ov = values[key];
      const nv = data[key];
      if (os) {
        if (ov === nv && typeof nv !== "object") continue;
        if (nv instanceof Date) {
          if (ov instanceof Date && ov.getTime() === nv.getTime()) continue;
        }
      }
      const fullKey = parent + (parent ? "." : "") + key;
      if (os) {
        if (os.__parse(nv, fullKey, signals, mode)) values[key] = nv;
        if (mode & STORE_SET_SILENT) signals[fullKey] = os.__trigger;
        else os.__trigger();
      } else {
        if (nv && nv.__reactive) {
          state[key] = this._wrapNested(nv, nv, fullKey, signals);
        } else {
          state[key] = this._wrapWritable(nv);
        }
        values[key] = nv;
      }
      signals[fullKey] = signals[fullKey] || null;
    }
  }
  _wrapNested(data, values, fullKey, signals) {
    const state = this._wrapWritable(data);
    this._wrapProperties(data, state, values, fullKey, signals, 0);
    state.__parse = (v, fullKey2, signals2, mode) => {
      this._wrapProperties(v, state, values, fullKey2, signals2, mode);
      return false;
    };
    return state;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _wrapWritable(val) {
    const ss = [];
    const __triggerSync = function() {
      for (let i = 0; i < ss.length; i++) {
        ss[i](val);
      }
    };
    const __trigger = () => {
      if (ss.length) {
        if (this._async) setTimeout(__triggerSync, 1);
        else __triggerSync();
      }
    };
    const subscribe = (fn) => {
      ss.push(fn);
      if (this._async) setTimeout(fn, 1, val);
      else fn(val);
      return () => {
        const i = ss.indexOf(fn);
        if (i >= 0) ss.splice(i, 1);
      };
    };
    const __parse = function(v) {
      val = v;
      return true;
    };
    return {
      subscribe,
      __trigger,
      __parse
    };
  }
};
function markReactive(t, nested) {
  Object.defineProperty(t, "__reactive", {
    value: true,
    enumerable: false,
    writable: false
  });
  if (nested === true) {
    for (const key in t) {
      const sub = t[key];
      if (typeof sub === "object" && sub !== null) {
        markReactive(sub, true);
      }
    }
  }
  return t;
}

// src/DataRouter.ts
var DataRouter = class {
  constructor(s, r, p, b) {
    if (typeof s === "function") this._setter = s;
    else this._setter = s.setState.bind(s);
    this._routes = r;
    this._parsers = p;
    this._prev = {};
    this._triggers = /* @__PURE__ */ new Map();
    this._sources = /* @__PURE__ */ new Map();
    this._routes.forEach((a) => {
      a.in.forEach((k) => {
        const arr = this._triggers.get(k) || [];
        arr.push(a);
        this._triggers.set(k, arr);
      });
      a.out.forEach((k) => {
        const h = this._sources.get(k) || {};
        a.in.forEach((i) => h[i] = true);
        this._sources.set(k, h);
      });
    });
    this._routes.forEach((a) => {
      a.length = Math.max(
        ...a.in.map((key) => _calckSize(key, this._sources, 1))
      );
    });
    this._bus = b;
  }
  init(cfg) {
    const next = {};
    for (const key in cfg) {
      if (this._prev[key] !== cfg[key]) {
        const parser = this._parsers[key];
        next[key] = parser ? parser(cfg[key]) : cfg[key];
      }
    }
    this._prev = this._prev ? { ...this._prev, ...cfg } : { ...cfg };
    this.setState(next);
    if (this._bus) this._bus.exec("init-state", next);
  }
  setStateAsync(updates) {
    const signals = this._setter(updates, STORE_SET_SILENT);
    if (this._async) {
      Object.assign(this._async.signals, signals);
    } else {
      this._async = {
        signals,
        timer: setTimeout(this._applyState.bind(this), 1)
      };
    }
    return signals;
  }
  _applyState() {
    const obj = this._async;
    if (!obj) return;
    this._async = null;
    this._triggerUpdates(obj.signals, []);
    for (const key in obj.signals) {
      const h = obj.signals[key];
      if (h) h();
    }
  }
  setState(updates, ctx = []) {
    const signals = this._setter(updates);
    this._triggerUpdates(signals, ctx);
    return signals;
  }
  _triggerUpdates(signals, ctx) {
    const keys = Object.keys(signals);
    const needExec = !ctx.length;
    ctx = ctx || [];
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const trgs = this._triggers.get(key);
      if (trgs) {
        trgs.forEach((a) => {
          if (ctx.indexOf(a) == -1) {
            ctx.push(a);
          }
        });
      }
    }
    if (needExec) {
      this._execNext(ctx);
    }
  }
  _execNext(ctx) {
    while (ctx.length) {
      ctx.sort((a, b) => a.length < b.length ? 1 : -1);
      const next = ctx[ctx.length - 1];
      ctx.splice(ctx.length - 1);
      next.exec(ctx);
    }
  }
};
function _calckSize(key, sources, prev) {
  const next = sources.get(key);
  if (!next) return prev;
  const sizes = Object.keys(next).map((a) => _calckSize(a, sources, prev + 1));
  return Math.max(...sizes);
}

// src/EventBus.ts
var EventBus = class {
  constructor() {
    this._nextHandler = null;
    this._handlers = {};
    this._tag = /* @__PURE__ */ new WeakMap();
    this.exec = this.exec.bind(this);
  }
  on(name, handler, config) {
    let prev = this._handlers[name];
    if (!prev) {
      prev = this._handlers[name] = [handler];
    } else {
      if (config && config.intercept) prev.unshift(handler);
      else prev.push(handler);
    }
    if (config && config.tag) this._tag.set(handler, config.tag);
  }
  intercept(name, handler, config) {
    this.on(name, handler, { ...config, intercept: true });
  }
  detach(tag) {
    for (const key in this._handlers) {
      const stack = this._handlers[key];
      for (let i = stack.length - 1; i >= 0; i--) {
        if (this._tag.get(stack[i]) === tag) {
          stack.splice(i, 1);
        }
      }
    }
  }
  async exec(name, ev) {
    const stack = this._handlers[name];
    if (stack) {
      for (let i = 0; i < stack.length; i++) {
        const res = stack[i](ev);
        if (res === false) return;
        if (res && res.then) {
          const res2 = await res;
          if (res2 === false) return;
        }
      }
    }
    if (this._nextHandler) await this._nextHandler.exec(name, ev);
    return ev;
  }
  setNext(next) {
    return this._nextHandler = next;
  }
};

// src/EventResolver.ts
var EventResolver = class {
  constructor(key) {
    this._key = key;
    this._nextHandler = null;
    this.exec = this.exec.bind(this);
  }
  async exec(name, ev) {
    if (ev && ev[this._key]) await ev[this._key](ev);
    if (this._nextHandler) {
      await this._nextHandler.exec(name, ev);
    }
    return ev;
  }
  setNext(next) {
    return this._nextHandler = next;
  }
};

// src/EventBusRouter.ts
var EventBusRouter = class {
  constructor(dispatch) {
    this._nextHandler = null;
    this._dispatch = dispatch;
    this.exec = this.exec.bind(this);
  }
  async exec(name, ev) {
    this._dispatch(name, ev);
    if (this._nextHandler) await this._nextHandler.exec(name, ev);
    return ev;
  }
  setNext(next) {
    return this._nextHandler = next;
  }
};

exports.DataArray = _DataArray;
exports.DataRouter = DataRouter;
exports.DataTree = DataTree;
exports.EventBus = EventBus;
exports.EventBusRouter = EventBusRouter;
exports.EventResolver = EventResolver;
exports.Store = Store;
exports.deepCopy = deepCopy;
exports.isSame = isSame;
exports.isTempID = isTempID;
exports.markReactive = markReactive;
exports.tempID = tempID;
exports.uid = uid;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map