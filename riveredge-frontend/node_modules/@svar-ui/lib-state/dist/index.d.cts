interface IStringHash<T> {
    [key: string]: T;
}
type TDataBlock = {
    in: string[];
    out: string[];
    exec: (ctx: TDataConfig) => void;
    length?: number;
};
type Parser = (val: any) => any;
type TDataConfig = TDataBlock[];
type TParserHash = IStringHash<Parser>;
type TID = number | string;
interface IHasID {
    id?: TID;
}
interface IEventConfig {
    intercept?: boolean;
    tag?: number | string | symbol;
}
interface IHasIDAndParent {
    id?: TID;
    parent: TID;
    $level: number;
    data?: IHasIDAndParent[];
    open?: boolean;
}
type TDispatch<T> = <A extends keyof T>(action: A, data: T[A]) => void;
interface DataHash {
    [key: string]: any;
}
interface IWritable<T> {
    subscribe: (fn: (v: T) => void) => void;
    update: (fn: (v: T) => T) => void;
    set: (val: T) => void;
}
type TTrigger<T> = (v: T) => void;
type SomeCallback = () => void;
type TAsyncSignals = {
    [key: string]: SomeCallback | null;
};
interface IPublicWritable<T> {
    subscribe: (fn: TTrigger<T>) => void;
    __trigger(): void;
    __parse: (val: T, key: string, signals: TAsyncSignals, mode: TStateMode) => void;
}
type TWritableCreator = (val: any) => IWritable<typeof val>;
interface IEventBus<T> {
    exec(name: keyof T, ev: T[keyof T]): Promise<T[keyof T]>;
    setNext(next: IEventBus<T>): IEventBus<T>;
}
type ToReactive<Type> = {
    [Property in keyof Type]: IWritable<Type[Property]>;
};
type TStateMode = number;
type CommonEvent = {
    [key: string]: any;
};

declare class _DataArray<T extends IHasID> {
    private _pool;
    private _data;
    constructor(raw: T[]);
    add(raw: T): void;
    update(id: TID, raw: T): void;
    remove(id: TID): void;
    filter(cb: (value: T) => boolean): void;
    byId(id: TID): T;
    map<D>(cb: (value: T, index: number, array: T[]) => D): D[];
    forEach(cb: (value: T, index: number, array: T[]) => void): void;
}

declare class DataTree<T extends IHasIDAndParent> {
    _pool: Map<TID, T>;
    constructor(raw?: T[]);
    parse(raw: T[], parent: TID): void;
    add(raw: T, index: number): void;
    addAfter(raw: T, after: TID): void;
    remove(id: TID): void;
    _remove(obj: T): void;
    update<Data>(id: TID, values: Data): void;
    move(id: TID, mode: string, target: TID): void;
    private _clearBranch;
    toArray(): T[];
    byId(id: TID): T;
    getBranch(id: TID): T[];
    forEach(cb: (value: T) => void): void;
    eachChild(cb: (value: T, index: number) => void, parent: TID): void;
    setLevel(root: IHasIDAndParent, level: number, copy: boolean): void;
}

declare class EventBus<T, A extends keyof T> {
    private _handlers;
    protected _nextHandler: IEventBus<T>;
    protected _tag: WeakMap<{
        (v: T[A]): void | boolean | Promise<boolean>;
    }, number | string | symbol>;
    constructor();
    on(name: A, handler: (v: T[A]) => void | boolean | Promise<boolean>, config?: IEventConfig): void;
    intercept(name: A, handler: (v: T[A]) => void | boolean | Promise<boolean>, config?: IEventConfig): void;
    detach(tag: number | string | symbol): void;
    exec(name: A, ev: T[A]): Promise<T[A]>;
    setNext(next: IEventBus<T>): IEventBus<T>;
}

type TSetter<T> = (data: Partial<T>, mode?: TStateMode) => TAsyncSignals;
type TStoreLike<T> = {
    setState: TSetter<T>;
};
declare class DataRouter<T, D, E> {
    private _setter;
    private _routes;
    private _triggers;
    private _sources;
    private _prev;
    private _parsers;
    private _bus;
    private _async;
    constructor(s: TSetter<T> | TStoreLike<T>, r: TDataConfig, p: TParserHash, b?: EventBus<E, keyof E>);
    init(cfg: Partial<D>): void;
    setStateAsync(updates: Partial<T>): TAsyncSignals;
    _applyState(): void;
    setState(updates: Partial<T>, ctx?: TDataConfig): TAsyncSignals;
    private _triggerUpdates;
    private _execNext;
}

type TState<Type> = {
    [Property in keyof Type]: IPublicWritable<Type[Property]>;
};
type StoreConfig = {
    writable: TWritableCreator;
    async: boolean;
};
declare class Store<T extends DataHash> {
    private _state;
    private _values;
    private _writable;
    private _async;
    constructor(config: StoreConfig);
    setState(data: Partial<T>, mode?: TStateMode | TDataConfig): TAsyncSignals;
    getState(): T;
    getReactive(): TState<T>;
    private _wrapProperties;
    private _wrapNested;
    private _wrapWritable;
}
declare function markReactive<T>(t: T, nested?: boolean): T;

declare class EventResolver<T> implements IEventBus<T> {
    private _key;
    protected _nextHandler: IEventBus<T>;
    constructor(key: string);
    exec(name: keyof T, ev: CommonEvent): Promise<T[keyof T]>;
    setNext(next: IEventBus<T>): IEventBus<T>;
}

declare class EventBusRouter<T> implements IEventBus<T> {
    private _dispatch;
    protected _nextHandler: IEventBus<T>;
    constructor(dispatch: TDispatch<T>);
    exec(name: keyof T, ev: CommonEvent): Promise<T[keyof T]>;
    setNext(next: IEventBus<T>): IEventBus<T>;
}

declare const uid: () => number;
declare function tempID(): string;
declare function isTempID(v: string | number): boolean;
declare function isSame(v: any, nv: any): boolean;
declare function deepCopy<T>(obj: T): T;

export { _DataArray as DataArray, DataRouter, DataTree, EventBus, EventBusRouter, EventResolver, type IEventBus, type IEventConfig, type IPublicWritable, type IWritable, Store, type TDataConfig, type TDispatch, type TID, type TWritableCreator, type ToReactive, deepCopy, isSame, isTempID, markReactive, tempID, uid };
