'use strict';

var libState = require('@svar-ui/lib-state');

// src/RestDataProvider.ts
var cantSendYet = Symbol();
var SYNC = 0;
var NOTSENT = 1;
var SENDING = 2;
var ActionQueue = class {
  constructor() {
    this.reset(true);
  }
  reset(ids = false) {
    this._awaitAddingQueue = [];
    this._queue = {};
    this._waitPull = {};
    this._status = [];
    if (ids) {
      this._idPool = {};
      this._backId = [];
    }
  }
  resolve(id, type) {
    const col = this._backId[type];
    if (typeof col === "undefined") return id;
    const tID = col[id];
    return typeof tID === "undefined" ? id : tID;
  }
  getSync() {
    const t = this._awaitAddingQueue;
    if (!t.length) return SYNC;
    for (let i = 0; i < t.length; i++) {
      if (!t[i].sent) return NOTSENT;
    }
    return SENDING;
  }
  waitSync() {
    return new Promise((resolve) => {
      if (this.getSync() === SYNC) resolve();
      else this._status.push(resolve);
    });
  }
  getId(id) {
    return this._idPool[id] || (libState.isTempID(id) ? null : id);
  }
  waitId(id) {
    return new Promise((resolve) => {
      const sid = this.getId(id);
      if (sid !== null) resolve(sid);
      const warr = this._waitPull[id] || [];
      warr.push(resolve);
      this._waitPull[id] = warr;
    });
  }
  add(action, data, proc) {
    return new Promise((resolve, reject) => {
      proc = { ...proc, resolve, reject };
      if (proc.debounce) {
        const qid = `${action}"/"${data.id}`;
        const item = this._queue[qid];
        if (item) {
          proc.resolve = (v) => {
            item.resolve(v);
            resolve(v);
          };
          proc.reject = (e) => {
            item.reject(e);
            reject();
          };
          clearTimeout(item.timer);
        }
        this._queue[qid] = proc;
        proc.timer = setTimeout(() => {
          this.tryExec(action, data, proc);
        }, proc.debounce);
        return;
      }
      this.tryExec(action, data, proc);
    });
  }
  tryExec(action, data, proc, finish) {
    const ready = this.exec(action, data, proc, finish);
    if (ready === null) {
      if (!finish) this._awaitAddingQueue.push({ action, data, proc });
      return false;
    }
    ready.then(
      (res) => {
        const check = res && res.id && res.id != data.id && libState.isTempID(data.id);
        if (check) {
          this._idPool[data.id] = res.id;
          if (this._waitPull[data.id]) {
            this._waitPull[data.id].forEach((v) => v(res.id));
            delete this._waitPull[data.id];
          }
          if (proc.kind) {
            let t = this._backId[proc.kind];
            if (!t) t = this._backId[proc.kind] = {};
            t[res.id] = data.id;
          }
        }
        data.response = res;
        proc.resolve(true);
        if (finish) finish();
        if (check) this.execQueue();
      },
      (e) => {
        if (finish) finish();
        proc.reject(e);
      }
    );
    return true;
  }
  exec(action, data, proc, finish) {
    const correctData = this.correctID(data, proc.ignoreID ? data.id : null);
    if (correctData === cantSendYet) {
      return null;
    }
    let res;
    try {
      res = proc.handler(correctData, action, data);
    } catch (e) {
      finish();
      proc.reject(e);
    }
    return res;
  }
  correctID(obj, ignore) {
    let copy = null;
    for (const key in obj) {
      const test = obj[key];
      if (typeof test === "object") {
        const after = this.correctID(test, ignore);
        if (after !== test) {
          if (after === cantSendYet) {
            return cantSendYet;
          }
          if (copy === null) {
            copy = { ...obj };
          }
          copy[key] = after;
        }
      } else if (libState.isTempID(test)) {
        const hasRealID = this._idPool[test];
        if (hasRealID) {
          if (copy === null) {
            copy = { ...obj };
          }
          copy[key] = hasRealID;
        } else if (!ignore) {
          return cantSendYet;
        }
      }
    }
    return copy || obj;
  }
  execQueue() {
    this._awaitAddingQueue.forEach((a) => {
      if (!a.sent) {
        const finish = () => this._finishQueue(a);
        if (this.tryExec(a.action, a.data, a.proc, finish)) a.sent = true;
      }
    });
  }
  _finishQueue(a) {
    this._awaitAddingQueue = this._awaitAddingQueue.filter((v) => v !== a);
    if (!this._awaitAddingQueue.length && this._status.length) {
      const temp = [...this._status];
      this._status = [];
      temp.forEach((resolve) => resolve());
    }
  }
};

// src/RestDataProvider.ts
var Rest = class extends libState.EventBus {
  constructor(url, config) {
    super();
    this._customHeaders = {};
    this._batchQueue = [];
    this._batchTimeout = null;
    this._url = url;
    this._batchUrl = config?.batchURL;
    this._queue = new ActionQueue();
    const handlers = this.getHandlers();
    for (const x in handlers) {
      this.on(x, (ev) => {
        if (!ev.skipProvider)
          return this._queue.add(x, ev, handlers[x]);
      });
    }
  }
  getHandlers() {
    return {};
  }
  setHeaders(headers) {
    this._customHeaders = headers;
  }
  getQueue() {
    return this._queue;
  }
  async send(url, method, data, customHeaders = {}) {
    if (this._batchUrl && method !== "GET") {
      return this.sendBatchRequest(url, method, data, customHeaders);
    } else {
      return this.sendRequest(url, method, data, customHeaders);
    }
  }
  async sendBatchRequest(url, method, data, customHeaders) {
    return new Promise((resolve) => {
      this._batchQueue.push({
        url,
        method,
        data,
        resolve
      });
      if (this._batchTimeout) {
        clearTimeout(this._batchTimeout);
      }
      this._batchTimeout = setTimeout(async () => {
        const currentQueue = [...this._batchQueue];
        this._batchQueue = [];
        if (currentQueue.length > 1) {
          const batchData = currentQueue.map((req) => ({
            url: req.url,
            method: req.method,
            data: {
              ...req.data
            }
          }));
          const results = await this.sendRequest(
            this._batchUrl,
            "POST",
            batchData
          );
          currentQueue.forEach((q, i) => q.resolve(results[i]));
        } else {
          const result = await this.sendRequest(
            url,
            method,
            data,
            customHeaders
          );
          resolve(result);
        }
      }, 10);
    });
  }
  toPayload(obj) {
    return JSON.stringify(obj);
  }
  async sendRequest(url, method, data, customHeaders = {}) {
    const headers = {
      "Content-Type": "application/json",
      ...customHeaders,
      ...this._customHeaders
    };
    const req = {
      method,
      headers
    };
    if (data) {
      req.body = typeof data === "object" ? this.toPayload(data) : data;
    }
    const slash = this._url.charAt(-1) === "/" || url[0] === "/" ? "" : "/";
    return fetch(`${this._url}${slash}${url || ""}`, req).then(
      (res) => res.json()
    );
  }
};
var DataProvider = class extends libState.EventBus {
  constructor(handlers) {
    super();
    this._queue = new ActionQueue();
    for (const x in handlers) {
      this.on(x, (ev) => {
        const handler = handlers[x];
        const pack = typeof handler === "function" ? { handler } : handler;
        if (!ev.skipProvider)
          return this._queue.add(x, ev, pack);
      });
    }
  }
  getQueue() {
    return this._queue;
  }
};
function _addToUrl(url, ...parts) {
  if (!parts.length) return url;
  parts.forEach((part) => {
    if (typeof part === "undefined" || part === null || part === "") return;
    const pstr = part.toString();
    url += (url.endsWith("/") ? "" : "/") + (pstr.startsWith("/") ? pstr.slice(1) : encodeURIComponent(pstr));
  });
  return url;
}
var RestURL = class _RestURL {
  constructor(url, headers) {
    this._url = url;
    this._headers = headers || {};
  }
  async fetch(url, method, headers, data) {
    const response = await fetch(
      url,
      method === "GET" ? { headers } : {
        method,
        headers,
        body: data ? JSON.stringify(data) : ""
      }
    );
    const result = await response.json();
    return result;
  }
  path(...parts) {
    return new _RestURL(_addToUrl(this._url, ...parts), this._headers);
  }
  headers(headers) {
    return new _RestURL(this._url, { ...this._headers, ...headers });
  }
  async get(url) {
    return this.fetch(_addToUrl(this._url, url), "GET", this._headers, null);
  }
  async add(data) {
    return this.fetch(
      this._url,
      "POST",
      {
        "Content-Type": "application/json",
        ...this._headers
      },
      data
    );
  }
  async update(data, url) {
    if (url && libState.isTempID(url)) return;
    return this.fetch(
      _addToUrl(this._url, url),
      "PUT",
      {
        "Content-Type": "application/json",
        ...this._headers
      },
      data
    );
  }
  async delete(url) {
    if (url && libState.isTempID(url)) return;
    return this.fetch(
      _addToUrl(this._url, url),
      "DELETE",
      this._headers,
      null
    );
  }
  async save(action, data, url) {
    switch (action) {
      case "add": {
        return this.add(data);
      }
      case "update": {
        return this.update(data, url);
      }
      case "delete": {
        return this.delete(url);
      }
    }
  }
};

exports.ActionQueue = ActionQueue;
exports.DataProvider = DataProvider;
exports.NOTSENT = NOTSENT;
exports.Rest = Rest;
exports.RestURL = RestURL;
exports.SENDING = SENDING;
exports.SYNC = SYNC;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map