import { EventBus, TID as TID$1 } from '@svar-ui/lib-state';

type Action = {
    ignoreID?: boolean;
    debounce?: number;
    handler: Handler;
};
type ActionMap<T> = {
    [P in keyof T]?: Action;
};
type DataObj = {
    [key: string]: any;
};
type Handler = (data: DataObj, action: string, ev: any) => Promise<any>;
type HandlerConfig = {
    resolve?: (v: boolean) => void;
    reject?: (e: any) => void;
    timer?: number;
    kind?: number;
    debounce?: number;
    ignoreID?: boolean;
    handler: Handler;
};
type DataProviderConfig = {
    [key: string]: HandlerConfig | Handler;
};
type RestDataProviderConfig = {
    batchURL?: string;
};
type TID = string | number;
type ServerResponse = {
    id?: TID;
};

declare const SYNC = 0;
declare const NOTSENT = 1;
declare const SENDING = 2;
declare class ActionQueue {
    private _awaitAddingQueue;
    private _queue;
    private _idPool;
    private _backId;
    private _status;
    private _waitPull;
    constructor();
    reset(ids?: boolean): void;
    resolve(id: TID, type: number): TID;
    getSync(): number;
    waitSync(): Promise<void>;
    getId(id: TID): TID | null;
    waitId(id: TID): Promise<TID>;
    add(action: string, data: DataObj, proc: HandlerConfig): Promise<boolean>;
    tryExec(action: string, data: DataObj, proc: HandlerConfig, finish?: () => void): boolean;
    exec(action: string, data: DataObj, proc: HandlerConfig, finish?: () => void): Promise<ServerResponse> | null;
    correctID(obj: DataObj, ignore: TID): DataObj | symbol;
    execQueue(): void;
    private _finishQueue;
}

declare class Rest<T> extends EventBus<T, keyof T> {
    private _queue;
    private _customHeaders;
    protected _url: string;
    protected _batchUrl?: string;
    private _batchQueue;
    private _batchTimeout;
    constructor(url?: string, config?: Partial<RestDataProviderConfig>);
    getHandlers(): ActionMap<T>;
    setHeaders(headers: Record<string, string>): void;
    getQueue(): ActionQueue;
    send(url: string, method: string, data?: object, customHeaders?: Record<string, string>): Promise<T>;
    private sendBatchRequest;
    protected toPayload(obj: object): string;
    protected sendRequest<T>(url: string, method: string, data?: string | object, customHeaders?: Record<string, string>): Promise<T>;
}

declare class DataProvider<T> extends EventBus<T, keyof T> {
    private _queue;
    constructor(handlers: DataProviderConfig);
    getQueue(): ActionQueue;
}

declare class RestURL<T, R> {
    private _url;
    private _headers;
    constructor(url: string, headers?: Record<string, string>);
    protected fetch<X>(url: string, method: string, headers: Record<string, string>, data: T): Promise<X>;
    path(...parts: TID$1[]): RestURL<T, R>;
    headers(headers: Record<string, string>): RestURL<T, R>;
    get(url?: TID$1): Promise<T>;
    add(data: T): Promise<R>;
    update(data: T, url?: TID$1): Promise<R>;
    delete(url?: TID$1): Promise<R>;
    save(action: string, data: T, url?: TID$1): Promise<R>;
}

export { type ActionMap, ActionQueue, DataProvider, NOTSENT, Rest, type RestDataProviderConfig, RestURL, SENDING, SYNC };
