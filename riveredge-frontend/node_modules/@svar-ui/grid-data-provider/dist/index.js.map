{"version":3,"file":"index.js","sources":["../../node_modules/@wx/lib-state/dist/index.js","../../node_modules/@wx/lib-data-provider/dist/index.js","../src/RestDataProvider.ts"],"sourcesContent":["// src/helpers.ts\nvar iid = (/* @__PURE__ */ new Date()).valueOf();\nvar uid = () => iid++;\nfunction tempID() {\n  return \"temp://\" + iid++;\n}\nfunction isTempID(v) {\n  return typeof v === \"string\" && v.length === 20 && parseInt(v.substr(7)) > 1e12;\n}\nfunction isSameObject(left, right) {\n  if (Object.keys(left).length !== Object.keys(right).length) return false;\n  for (const key in right) {\n    const v = left[key];\n    const nv = right[key];\n    if (!isSame(v, nv)) return false;\n  }\n  return true;\n}\nfunction isSame(v, nv) {\n  const primitiveValue = typeof v === \"number\" || typeof v === \"string\" || typeof v === \"boolean\" || v === null;\n  if (primitiveValue) return v === nv;\n  if (typeof v !== typeof nv) return false;\n  if ((v === null || nv === null) && v !== nv) return false;\n  if (v instanceof Date && nv instanceof Date && v.getTime() !== nv.getTime())\n    return false;\n  if (typeof v === \"object\") {\n    if (Array.isArray(v) && Array.isArray(nv)) {\n      if (v.length !== nv.length) return false;\n      for (let i = v.length - 1; i >= 0; i--) {\n        if (!isSame(v[i], nv[i])) return false;\n      }\n      return true;\n    } else {\n      return isSameObject(v, nv);\n    }\n  }\n  return v === nv;\n}\nfunction deepCopy(obj) {\n  if (typeof obj !== \"object\") return obj;\n  if (obj === null) return obj;\n  if (obj instanceof Date) return new Date(obj);\n  if (obj instanceof Array) return obj.map(deepCopy);\n  const out = {};\n  for (const key in obj) {\n    out[key] = deepCopy(obj[key]);\n  }\n  return out;\n}\n\n// src/DataArray.ts\nvar _DataArray = class {\n  constructor(raw) {\n    this._data = raw;\n    this._pool = /* @__PURE__ */ new Map();\n    for (let i = 0; i < raw.length; i++) {\n      const obj = raw[i];\n      this._pool.set(obj.id, obj);\n    }\n  }\n  add(raw) {\n    raw = { id: uid(), ...raw };\n    this._data.push(raw);\n    this._pool.set(raw.id, raw);\n  }\n  update(id, raw) {\n    const index = this._data.findIndex((link) => link.id == id);\n    const old = this._data[index];\n    const updated = { ...old, ...raw };\n    this._data[index] = updated;\n    this._pool.set(updated.id, updated);\n  }\n  remove(id) {\n    this._data = this._data.filter((a) => a.id != id);\n    this._pool.delete(id);\n  }\n  filter(cb) {\n    this._data = this._data.filter((x) => {\n      const check = cb(x);\n      if (!check) this._pool.delete(x.id);\n      return check;\n    });\n  }\n  byId(id) {\n    return this._pool.get(id);\n  }\n  map(cb) {\n    return this._data.map(cb);\n  }\n  forEach(cb) {\n    this._data.forEach(cb);\n  }\n};\n\n// src/DataTree.ts\nvar DataTree = class {\n  constructor(raw) {\n    const top = {\n      id: 0,\n      $level: 0,\n      data: [],\n      parent: null\n    };\n    const items = /* @__PURE__ */ new Map();\n    items.set(0, top);\n    this._pool = items;\n    if (raw && raw.length) this.parse(raw, 0);\n  }\n  parse(raw, parent) {\n    const items = this._pool;\n    for (let i = 0; i < raw.length; i++) {\n      const obj = raw[i];\n      obj.parent = obj.parent || parent;\n      obj.data = null;\n      items.set(obj.id, obj);\n    }\n    for (let i = 0; i < raw.length; i++) {\n      const obj = raw[i];\n      const temp = items.get(obj.parent);\n      if (temp) {\n        if (!temp.data) temp.data = [];\n        temp.data.push(obj);\n      }\n    }\n    const top = items.get(parent);\n    this.setLevel(top, top.$level + 1, false);\n  }\n  add(raw, index) {\n    const parent = this._pool.get(raw.parent || 0);\n    raw.$level = parent.$level + 1;\n    this._pool.set(raw.id, raw);\n    if (parent.data) {\n      if (index === -1) parent.data = [...parent.data, raw];\n      else insertElement(parent, index, raw);\n    } else parent.data = [raw];\n  }\n  addAfter(raw, after) {\n    if (!after) {\n      return this.add(raw, -1);\n    }\n    const node = this.byId(after);\n    const parent = this.byId(node.parent);\n    const index = indexById(parent, node.id) + 1;\n    raw.parent = parent.id;\n    raw.$level = parent.$level + 1;\n    this.add(raw, index);\n  }\n  remove(id) {\n    const obj = this._pool.get(id);\n    this._remove(obj);\n    const parent = this._pool.get(obj.parent);\n    parent.data = parent.data.filter((a) => a.id != id);\n    this._clearBranch(parent);\n  }\n  _remove(obj) {\n    if (obj.data) {\n      obj.data.forEach((i) => this._remove(i));\n    }\n    this._pool.delete(obj.id);\n  }\n  update(id, values) {\n    let obj = this._pool.get(id);\n    const branch = this._pool.get(obj.parent);\n    const index = indexById(branch, obj.id);\n    obj = { ...obj, ...values };\n    if (branch && index >= 0) {\n      branch.data[index] = obj;\n      branch.data = [...branch.data];\n    }\n    this._pool.set(obj.id, obj);\n  }\n  move(id, mode, target) {\n    const now = this._pool.get(id);\n    const dropChild = mode === \"child\";\n    const tobj = this._pool.get(target);\n    const tLevel = tobj.$level + (dropChild ? 1 : 0);\n    if (!now || !tobj) return;\n    const parent = this._pool.get(now.parent);\n    const newParent = dropChild ? tobj : this._pool.get(tobj.parent);\n    if (!newParent.data) newParent.data = [];\n    const index = indexById(parent, now.id);\n    deleteElement(parent, index);\n    const newIndex = dropChild ? newParent.data.length : indexById(newParent, tobj.id) + (mode === \"after\" ? 1 : 0);\n    insertElement(newParent, newIndex, now);\n    if (parent.id === newParent.id && index === newIndex) return null;\n    now.parent = newParent.id;\n    if (now.$level !== tLevel) {\n      now.$level = tLevel;\n      this.setLevel(now, tLevel + 1, true);\n    }\n    this.update(now.id, now);\n    this._clearBranch(parent);\n  }\n  _clearBranch(obj) {\n    if (obj.data && !obj.data.length) {\n      if (obj.open) delete obj.open;\n      this.update(obj.id, { data: null });\n    }\n  }\n  toArray() {\n    const out = [];\n    const kids = this._pool.get(0).data;\n    if (kids) toArray(kids, out);\n    return out;\n  }\n  byId(id) {\n    return this._pool.get(id);\n  }\n  getBranch(id) {\n    return this._pool.get(id).data;\n  }\n  forEach(cb) {\n    this._pool.forEach((value, key) => {\n      if (key !== 0) cb(value);\n    });\n  }\n  eachChild(cb, parent) {\n    const p = this.byId(parent);\n    if (!p || !p.data) return;\n    p.data.forEach((child, index) => {\n      cb(this.byId(child.id), index);\n      this.eachChild(cb, child.id);\n    });\n  }\n  setLevel(root, level, copy) {\n    if (!root.data) return;\n    root.data = root.data.map((child) => {\n      if (copy) {\n        child = { ...child };\n        this._pool.set(child.id, child);\n      }\n      child.$level = level;\n      if (child.data) this.setLevel(child, level + 1, copy);\n      return child;\n    });\n  }\n};\nfunction toArray(line, out) {\n  line.forEach((a) => {\n    out.push(a);\n    if (a.open === true) {\n      toArray(a.data, out);\n    }\n  });\n}\nfunction deleteElement(obj, index) {\n  const newData = [...obj.data];\n  newData.splice(index, 1);\n  obj.data = newData;\n}\nfunction insertElement(obj, index, item) {\n  const newData = [...obj.data];\n  newData.splice(index, 0, item);\n  obj.data = newData;\n}\nfunction indexById(parentNode, id) {\n  return parentNode?.data.findIndex(\n    (child) => child.id === id\n  );\n}\n\n// src/Store.ts\nvar STORE_SET_SILENT = 2;\nvar Store = class {\n  constructor(config) {\n    if (config) {\n      this._writable = config.writable;\n      this._async = config.async;\n    }\n    this._values = {};\n    this._state = {};\n  }\n  setState(data, mode = 0) {\n    const signals = {};\n    this._wrapProperties(\n      data,\n      this._state,\n      this._values,\n      \"\",\n      signals,\n      mode\n    );\n    return signals;\n  }\n  getState() {\n    return this._values;\n  }\n  getReactive() {\n    return this._state;\n  }\n  _wrapProperties(data, state, values, parent, signals, mode) {\n    for (const key in data) {\n      const os = state[key];\n      const ov = values[key];\n      const nv = data[key];\n      if (os) {\n        if (ov === nv && typeof nv !== \"object\") continue;\n        if (nv instanceof Date) {\n          if (ov instanceof Date && ov.getTime() === nv.getTime()) continue;\n        }\n      }\n      const fullKey = parent + (parent ? \".\" : \"\") + key;\n      if (os) {\n        if (os.__parse(nv, fullKey, signals, mode)) values[key] = nv;\n        if (mode & STORE_SET_SILENT) signals[fullKey] = os.__trigger;\n        else os.__trigger();\n      } else {\n        if (nv && nv.__reactive) {\n          state[key] = this._wrapNested(nv, nv, fullKey, signals);\n        } else {\n          state[key] = this._wrapWritable(nv);\n        }\n        values[key] = nv;\n      }\n      signals[fullKey] = signals[fullKey] || null;\n    }\n  }\n  _wrapNested(data, values, fullKey, signals) {\n    const state = this._wrapWritable(data);\n    this._wrapProperties(data, state, values, fullKey, signals, 0);\n    state.__parse = (v, fullKey2, signals2, mode) => {\n      this._wrapProperties(v, state, values, fullKey2, signals2, mode);\n      return false;\n    };\n    return state;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _wrapWritable(val) {\n    const ss = [];\n    const __triggerSync = function() {\n      for (let i = 0; i < ss.length; i++) {\n        ss[i](val);\n      }\n    };\n    const __trigger = () => {\n      if (ss.length) {\n        if (this._async) setTimeout(__triggerSync, 1);\n        else __triggerSync();\n      }\n    };\n    const subscribe = (fn) => {\n      ss.push(fn);\n      if (this._async) setTimeout(fn, 1, val);\n      else fn(val);\n      return () => {\n        const i = ss.indexOf(fn);\n        if (i >= 0) ss.splice(i, 1);\n      };\n    };\n    const __parse = function(v) {\n      val = v;\n      return true;\n    };\n    return {\n      subscribe,\n      __trigger,\n      __parse\n    };\n  }\n};\nfunction markReactive(t, nested) {\n  Object.defineProperty(t, \"__reactive\", {\n    value: true,\n    enumerable: false,\n    writable: false\n  });\n  if (nested === true) {\n    for (const key in t) {\n      const sub = t[key];\n      if (typeof sub === \"object\" && sub !== null) {\n        markReactive(sub, true);\n      }\n    }\n  }\n  return t;\n}\n\n// src/DataRouter.ts\nvar DataRouter = class {\n  constructor(s, r, p, b) {\n    if (typeof s === \"function\") this._setter = s;\n    else this._setter = s.setState.bind(s);\n    this._routes = r;\n    this._parsers = p;\n    this._prev = {};\n    this._triggers = /* @__PURE__ */ new Map();\n    this._sources = /* @__PURE__ */ new Map();\n    this._routes.forEach((a) => {\n      a.in.forEach((k) => {\n        const arr = this._triggers.get(k) || [];\n        arr.push(a);\n        this._triggers.set(k, arr);\n      });\n      a.out.forEach((k) => {\n        const h = this._sources.get(k) || {};\n        a.in.forEach((i) => h[i] = true);\n        this._sources.set(k, h);\n      });\n    });\n    this._routes.forEach((a) => {\n      a.length = Math.max(\n        ...a.in.map((key) => _calckSize(key, this._sources, 1))\n      );\n    });\n    this._bus = b;\n  }\n  init(cfg) {\n    const next = {};\n    for (const key in cfg) {\n      if (this._prev[key] !== cfg[key]) {\n        const parser = this._parsers[key];\n        next[key] = parser ? parser(cfg[key]) : cfg[key];\n      }\n    }\n    this._prev = this._prev ? { ...this._prev, ...cfg } : { ...cfg };\n    this.setState(next);\n    if (this._bus) this._bus.exec(\"init-state\", next);\n  }\n  setStateAsync(updates) {\n    const signals = this._setter(updates, STORE_SET_SILENT);\n    if (this._async) {\n      Object.assign(this._async.signals, signals);\n    } else {\n      this._async = {\n        signals,\n        timer: setTimeout(this._applyState.bind(this), 1)\n      };\n    }\n    return signals;\n  }\n  _applyState() {\n    const obj = this._async;\n    if (!obj) return;\n    this._async = null;\n    this._triggerUpdates(obj.signals, []);\n    for (const key in obj.signals) {\n      const h = obj.signals[key];\n      if (h) h();\n    }\n  }\n  setState(updates, ctx = []) {\n    const signals = this._setter(updates);\n    this._triggerUpdates(signals, ctx);\n    return signals;\n  }\n  _triggerUpdates(signals, ctx) {\n    const keys = Object.keys(signals);\n    const needExec = !ctx.length;\n    ctx = ctx || [];\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const trgs = this._triggers.get(key);\n      if (trgs) {\n        trgs.forEach((a) => {\n          if (ctx.indexOf(a) == -1) {\n            ctx.push(a);\n          }\n        });\n      }\n    }\n    if (needExec) {\n      this._execNext(ctx);\n    }\n  }\n  _execNext(ctx) {\n    while (ctx.length) {\n      ctx.sort((a, b) => a.length < b.length ? 1 : -1);\n      const next = ctx[ctx.length - 1];\n      ctx.splice(ctx.length - 1);\n      next.exec(ctx);\n    }\n  }\n};\nfunction _calckSize(key, sources, prev) {\n  const next = sources.get(key);\n  if (!next) return prev;\n  const sizes = Object.keys(next).map((a) => _calckSize(a, sources, prev + 1));\n  return Math.max(...sizes);\n}\n\n// src/EventBus.ts\nvar EventBus = class {\n  constructor() {\n    this._nextHandler = null;\n    this._handlers = {};\n    this._tag = /* @__PURE__ */ new WeakMap();\n    this.exec = this.exec.bind(this);\n  }\n  on(name, handler, config) {\n    let prev = this._handlers[name];\n    if (!prev) {\n      prev = this._handlers[name] = [handler];\n    } else {\n      if (config && config.intercept) prev.unshift(handler);\n      else prev.push(handler);\n    }\n    if (config && config.tag) this._tag.set(handler, config.tag);\n  }\n  intercept(name, handler, config) {\n    this.on(name, handler, { ...config, intercept: true });\n  }\n  detach(tag) {\n    for (const key in this._handlers) {\n      const stack = this._handlers[key];\n      for (let i = stack.length - 1; i >= 0; i--) {\n        if (this._tag.get(stack[i]) === tag) {\n          stack.splice(i, 1);\n        }\n      }\n    }\n  }\n  async exec(name, ev) {\n    const stack = this._handlers[name];\n    if (stack) {\n      for (let i = 0; i < stack.length; i++) {\n        const res = stack[i](ev);\n        if (res === false) return;\n        if (res && res.then) {\n          const res2 = await res;\n          if (res2 === false) return;\n        }\n      }\n    }\n    if (this._nextHandler) await this._nextHandler.exec(name, ev);\n    return ev;\n  }\n  setNext(next) {\n    return this._nextHandler = next;\n  }\n};\n\n// src/EventResolver.ts\nvar EventResolver = class {\n  constructor(key) {\n    this._key = key;\n    this._nextHandler = null;\n    this.exec = this.exec.bind(this);\n  }\n  async exec(name, ev) {\n    if (ev && ev[this._key]) await ev[this._key](ev);\n    if (this._nextHandler) {\n      await this._nextHandler.exec(name, ev);\n    }\n    return ev;\n  }\n  setNext(next) {\n    return this._nextHandler = next;\n  }\n};\n\n// src/EventBusRouter.ts\nvar EventBusRouter = class {\n  constructor(dispatch) {\n    this._nextHandler = null;\n    this._dispatch = dispatch;\n    this.exec = this.exec.bind(this);\n  }\n  async exec(name, ev) {\n    this._dispatch(name, ev);\n    if (this._nextHandler) await this._nextHandler.exec(name, ev);\n    return ev;\n  }\n  setNext(next) {\n    return this._nextHandler = next;\n  }\n};\n\nexport { _DataArray as DataArray, DataRouter, DataTree, EventBus, EventBusRouter, EventResolver, Store, deepCopy, isSame, isTempID, markReactive, tempID, uid };\n//# sourceMappingURL=index.js.map\n//# sourceMappingURL=index.js.map","import { isTempID, EventBus } from '@wx/lib-state';\n\n// src/RestDataProvider.ts\nvar cantSendYet = Symbol();\nvar SYNC = 0;\nvar NOTSENT = 1;\nvar SENDING = 2;\nvar ActionQueue = class {\n  constructor() {\n    this.reset(true);\n  }\n  reset(ids = false) {\n    this._awaitAddingQueue = [];\n    this._queue = {};\n    this._waitPull = {};\n    this._status = [];\n    if (ids) {\n      this._idPool = {};\n      this._backId = [];\n    }\n  }\n  resolve(id, type) {\n    const col = this._backId[type];\n    if (typeof col === \"undefined\") return id;\n    const tID = col[id];\n    return typeof tID === \"undefined\" ? id : tID;\n  }\n  getSync() {\n    const t = this._awaitAddingQueue;\n    if (!t.length) return SYNC;\n    for (let i = 0; i < t.length; i++) {\n      if (!t[i].sent) return NOTSENT;\n    }\n    return SENDING;\n  }\n  waitSync() {\n    return new Promise((resolve) => {\n      if (this.getSync() === SYNC) resolve();\n      else this._status.push(resolve);\n    });\n  }\n  getId(id) {\n    return this._idPool[id] || (isTempID(id) ? null : id);\n  }\n  waitId(id) {\n    return new Promise((resolve) => {\n      const sid = this.getId(id);\n      if (sid !== null) resolve(sid);\n      const warr = this._waitPull[id] || [];\n      warr.push(resolve);\n      this._waitPull[id] = warr;\n    });\n  }\n  add(action, data, proc) {\n    return new Promise((resolve, reject) => {\n      proc = { ...proc, resolve, reject };\n      if (proc.debounce) {\n        const qid = `${action}\"/\"${data.id}`;\n        const item = this._queue[qid];\n        if (item) {\n          proc.resolve = (v) => {\n            item.resolve(v);\n            resolve(v);\n          };\n          proc.reject = (e) => {\n            item.reject(e);\n            reject();\n          };\n          clearTimeout(item.timer);\n        }\n        this._queue[qid] = proc;\n        proc.timer = setTimeout(() => {\n          this.tryExec(action, data, proc);\n        }, proc.debounce);\n        return;\n      }\n      this.tryExec(action, data, proc);\n    });\n  }\n  tryExec(action, data, proc, finish) {\n    const ready = this.exec(action, data, proc, finish);\n    if (ready === null) {\n      if (!finish) this._awaitAddingQueue.push({ action, data, proc });\n      return false;\n    }\n    ready.then(\n      (res) => {\n        const check = res && res.id && res.id != data.id && isTempID(data.id);\n        if (check) {\n          this._idPool[data.id] = res.id;\n          if (this._waitPull[data.id]) {\n            this._waitPull[data.id].forEach((v) => v(res.id));\n            delete this._waitPull[data.id];\n          }\n          if (proc.kind) {\n            let t = this._backId[proc.kind];\n            if (!t) t = this._backId[proc.kind] = {};\n            t[res.id] = data.id;\n          }\n        }\n        data.response = res;\n        proc.resolve(true);\n        if (finish) finish();\n        if (check) this.execQueue();\n      },\n      (e) => {\n        if (finish) finish();\n        proc.reject(e);\n      }\n    );\n    return true;\n  }\n  exec(action, data, proc, finish) {\n    const correctData = this.correctID(data, proc.ignoreID ? data.id : null);\n    if (correctData === cantSendYet) {\n      return null;\n    }\n    let res;\n    try {\n      res = proc.handler(correctData, action, data);\n    } catch (e) {\n      finish();\n      proc.reject(e);\n    }\n    return res;\n  }\n  correctID(obj, ignore) {\n    let copy = null;\n    for (const key in obj) {\n      const test = obj[key];\n      if (typeof test === \"object\") {\n        const after = this.correctID(test, ignore);\n        if (after !== test) {\n          if (after === cantSendYet) {\n            return cantSendYet;\n          }\n          if (copy === null) {\n            copy = { ...obj };\n          }\n          copy[key] = after;\n        }\n      } else if (isTempID(test)) {\n        const hasRealID = this._idPool[test];\n        if (hasRealID) {\n          if (copy === null) {\n            copy = { ...obj };\n          }\n          copy[key] = hasRealID;\n        } else if (!ignore) {\n          return cantSendYet;\n        }\n      }\n    }\n    return copy || obj;\n  }\n  execQueue() {\n    this._awaitAddingQueue.forEach((a) => {\n      if (!a.sent) {\n        const finish = () => this._finishQueue(a);\n        if (this.tryExec(a.action, a.data, a.proc, finish)) a.sent = true;\n      }\n    });\n  }\n  _finishQueue(a) {\n    this._awaitAddingQueue = this._awaitAddingQueue.filter((v) => v !== a);\n    if (!this._awaitAddingQueue.length && this._status.length) {\n      const temp = [...this._status];\n      this._status = [];\n      temp.forEach((resolve) => resolve());\n    }\n  }\n};\n\n// src/RestDataProvider.ts\nvar Rest = class extends EventBus {\n  constructor(url, config) {\n    super();\n    this._customHeaders = {};\n    this._batchQueue = [];\n    this._batchTimeout = null;\n    this._url = url;\n    this._batchUrl = config?.batchURL;\n    this._queue = new ActionQueue();\n    const handlers = this.getHandlers();\n    for (const x in handlers) {\n      this.on(x, (ev) => {\n        if (!ev.skipProvider)\n          return this._queue.add(x, ev, handlers[x]);\n      });\n    }\n  }\n  getHandlers() {\n    return {};\n  }\n  setHeaders(headers) {\n    this._customHeaders = headers;\n  }\n  getQueue() {\n    return this._queue;\n  }\n  async send(url, method, data, customHeaders = {}) {\n    if (this._batchUrl && method !== \"GET\") {\n      return this.sendBatchRequest(url, method, data, customHeaders);\n    } else {\n      return this.sendRequest(url, method, data, customHeaders);\n    }\n  }\n  async sendBatchRequest(url, method, data, customHeaders) {\n    return new Promise((resolve) => {\n      this._batchQueue.push({\n        url,\n        method,\n        data,\n        resolve\n      });\n      if (this._batchTimeout) {\n        clearTimeout(this._batchTimeout);\n      }\n      this._batchTimeout = setTimeout(async () => {\n        const currentQueue = [...this._batchQueue];\n        this._batchQueue = [];\n        if (currentQueue.length > 1) {\n          const batchData = currentQueue.map((req) => ({\n            url: req.url,\n            method: req.method,\n            data: {\n              ...req.data\n            }\n          }));\n          const results = await this.sendRequest(\n            this._batchUrl,\n            \"POST\",\n            batchData\n          );\n          currentQueue.forEach((q, i) => q.resolve(results[i]));\n        } else {\n          const result = await this.sendRequest(\n            url,\n            method,\n            data,\n            customHeaders\n          );\n          resolve(result);\n        }\n      }, 10);\n    });\n  }\n  toPayload(obj) {\n    return JSON.stringify(obj);\n  }\n  async sendRequest(url, method, data, customHeaders = {}) {\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      ...customHeaders,\n      ...this._customHeaders\n    };\n    const req = {\n      method,\n      headers\n    };\n    if (data) {\n      req.body = typeof data === \"object\" ? this.toPayload(data) : data;\n    }\n    const slash = this._url.charAt(-1) === \"/\" || url[0] === \"/\" ? \"\" : \"/\";\n    return fetch(`${this._url}${slash}${url || \"\"}`, req).then(\n      (res) => res.json()\n    );\n  }\n};\nvar DataProvider = class extends EventBus {\n  constructor(handlers) {\n    super();\n    this._queue = new ActionQueue();\n    for (const x in handlers) {\n      this.on(x, (ev) => {\n        const handler = handlers[x];\n        const pack = typeof handler === \"function\" ? { handler } : handler;\n        if (!ev.skipProvider)\n          return this._queue.add(x, ev, pack);\n      });\n    }\n  }\n  getQueue() {\n    return this._queue;\n  }\n};\nfunction _addToUrl(url, ...parts) {\n  if (!parts.length) return url;\n  parts.forEach((part) => {\n    if (typeof part === \"undefined\" || part === null || part === \"\") return;\n    const pstr = part.toString();\n    url += (url.endsWith(\"/\") ? \"\" : \"/\") + (pstr.startsWith(\"/\") ? pstr.slice(1) : encodeURIComponent(pstr));\n  });\n  return url;\n}\nvar RestURL = class _RestURL {\n  constructor(url, headers) {\n    this._url = url;\n    this._headers = headers || {};\n  }\n  async fetch(url, method, headers, data) {\n    const response = await fetch(\n      url,\n      method === \"GET\" ? { headers } : {\n        method,\n        headers,\n        body: data ? JSON.stringify(data) : \"\"\n      }\n    );\n    const result = await response.json();\n    return result;\n  }\n  path(...parts) {\n    return new _RestURL(_addToUrl(this._url, ...parts), this._headers);\n  }\n  headers(headers) {\n    return new _RestURL(this._url, { ...this._headers, ...headers });\n  }\n  async get(url) {\n    return this.fetch(_addToUrl(this._url, url), \"GET\", this._headers, null);\n  }\n  async add(data) {\n    return this.fetch(\n      this._url,\n      \"POST\",\n      {\n        \"Content-Type\": \"application/json\",\n        ...this._headers\n      },\n      data\n    );\n  }\n  async update(data, url) {\n    if (url && isTempID(url)) return;\n    return this.fetch(\n      _addToUrl(this._url, url),\n      \"PUT\",\n      {\n        \"Content-Type\": \"application/json\",\n        ...this._headers\n      },\n      data\n    );\n  }\n  async delete(url) {\n    if (url && isTempID(url)) return;\n    return this.fetch(\n      _addToUrl(this._url, url),\n      \"DELETE\",\n      this._headers,\n      null\n    );\n  }\n  async save(action, data, url) {\n    switch (action) {\n      case \"add\": {\n        return this.add(data);\n      }\n      case \"update\": {\n        return this.update(data, url);\n      }\n      case \"delete\": {\n        return this.delete(url);\n      }\n    }\n  }\n};\n\nexport { ActionQueue, DataProvider, NOTSENT, Rest, RestURL, SENDING, SYNC };\n//# sourceMappingURL=index.js.map\n//# sourceMappingURL=index.js.map","import { Rest } from \"@wx/lib-data-provider\";\nimport type { ActionMap } from \"@wx/lib-data-provider\";\nimport type { TMethodsConfig } from \"@wx/grid-store\";\n\nexport default class RestDataProvider<T> extends Rest<TMethodsConfig> {\n\tprivate _normalize: any;\n\tconstructor(url: string, normalize?: any) {\n\t\tsuper(url);\n\t\tthis._normalize = normalize;\n\t}\n\tgetHandlers(): ActionMap<TMethodsConfig> {\n\t\treturn {\n\t\t\t\"add-row\": {\n\t\t\t\tignoreID: true,\n\t\t\t\thandler: (ev: TMethodsConfig[\"add-row\"]) => {\n\t\t\t\t\tconst d = this.send(\"\", \"POST\", ev);\n\t\t\t\t\tif (!this._normalize) return d;\n\t\t\t\t\treturn d.then(obj => {\n\t\t\t\t\t\tthis._normalize(obj);\n\t\t\t\t\t\treturn obj;\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"delete-row\": {\n\t\t\t\thandler: (ev: TMethodsConfig[\"delete-row\"]) => {\n\t\t\t\t\treturn this.send(`/${ev.id}`, \"DELETE\");\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"update-row\": {\n\t\t\t\thandler: (ev: TMethodsConfig[\"update-row\"]) => {\n\t\t\t\t\treturn this.send(`/${ev.id}`, \"PUT\", ev);\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"update-cell\": {\n\t\t\t\thandler: (ev: TMethodsConfig[\"update-cell\"]) => {\n\t\t\t\t\treturn this.send(`/${ev.id}`, \"PATCH\", {\n\t\t\t\t\t\tkey: ev.column,\n\t\t\t\t\t\tvalue: ev.value.toString(),\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t}\n\n\tgetData(): Promise<T[]> {\n\t\tconst d = this.send<T[]>(\"\", \"GET\");\n\t\tif (!this._normalize) return d;\n\n\t\treturn d.then(obj => {\n\t\t\tif (this._normalize) obj.forEach(this._normalize);\n\t\t\treturn obj;\n\t\t});\n\t}\n}\n"],"names":[],"mappings":"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","x_google_ignoreList":[0,1]}