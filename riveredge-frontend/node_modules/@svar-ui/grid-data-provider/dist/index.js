// src/helpers.ts
(/* @__PURE__ */ new Date()).valueOf();
function isTempID(v) {
  return typeof v === "string" && v.length === 20 && parseInt(v.substr(7)) > 1e12;
}

// src/EventBus.ts
var EventBus = class {
  constructor() {
    this._nextHandler = null;
    this._handlers = {};
    this._tag = /* @__PURE__ */ new WeakMap();
    this.exec = this.exec.bind(this);
  }
  on(name, handler, config) {
    let prev = this._handlers[name];
    if (!prev) {
      prev = this._handlers[name] = [handler];
    } else {
      if (config && config.intercept) prev.unshift(handler);
      else prev.push(handler);
    }
    if (config && config.tag) this._tag.set(handler, config.tag);
  }
  intercept(name, handler, config) {
    this.on(name, handler, { ...config, intercept: true });
  }
  detach(tag) {
    for (const key in this._handlers) {
      const stack = this._handlers[key];
      for (let i = stack.length - 1; i >= 0; i--) {
        if (this._tag.get(stack[i]) === tag) {
          stack.splice(i, 1);
        }
      }
    }
  }
  async exec(name, ev) {
    const stack = this._handlers[name];
    if (stack) {
      for (let i = 0; i < stack.length; i++) {
        const res = stack[i](ev);
        if (res === false) return;
        if (res && res.then) {
          const res2 = await res;
          if (res2 === false) return;
        }
      }
    }
    if (this._nextHandler) await this._nextHandler.exec(name, ev);
    return ev;
  }
  setNext(next) {
    return this._nextHandler = next;
  }
};

// src/RestDataProvider.ts
var cantSendYet = Symbol();
var SYNC = 0;
var NOTSENT = 1;
var SENDING = 2;
var ActionQueue = class {
  constructor() {
    this.reset(true);
  }
  reset(ids = false) {
    this._awaitAddingQueue = [];
    this._queue = {};
    this._waitPull = {};
    this._status = [];
    if (ids) {
      this._idPool = {};
      this._backId = [];
    }
  }
  resolve(id, type) {
    const col = this._backId[type];
    if (typeof col === "undefined") return id;
    const tID = col[id];
    return typeof tID === "undefined" ? id : tID;
  }
  getSync() {
    const t = this._awaitAddingQueue;
    if (!t.length) return SYNC;
    for (let i = 0; i < t.length; i++) {
      if (!t[i].sent) return NOTSENT;
    }
    return SENDING;
  }
  waitSync() {
    return new Promise((resolve) => {
      if (this.getSync() === SYNC) resolve();
      else this._status.push(resolve);
    });
  }
  getId(id) {
    return this._idPool[id] || (isTempID(id) ? null : id);
  }
  waitId(id) {
    return new Promise((resolve) => {
      const sid = this.getId(id);
      if (sid !== null) resolve(sid);
      const warr = this._waitPull[id] || [];
      warr.push(resolve);
      this._waitPull[id] = warr;
    });
  }
  add(action, data, proc) {
    return new Promise((resolve, reject) => {
      proc = { ...proc, resolve, reject };
      if (proc.debounce) {
        const qid = `${action}"/"${data.id}`;
        const item = this._queue[qid];
        if (item) {
          proc.resolve = (v) => {
            item.resolve(v);
            resolve(v);
          };
          proc.reject = (e) => {
            item.reject(e);
            reject();
          };
          clearTimeout(item.timer);
        }
        this._queue[qid] = proc;
        proc.timer = setTimeout(() => {
          this.tryExec(action, data, proc);
        }, proc.debounce);
        return;
      }
      this.tryExec(action, data, proc);
    });
  }
  tryExec(action, data, proc, finish) {
    const ready = this.exec(action, data, proc, finish);
    if (ready === null) {
      if (!finish) this._awaitAddingQueue.push({ action, data, proc });
      return false;
    }
    ready.then(
      (res) => {
        const check = res && res.id && res.id != data.id && isTempID(data.id);
        if (check) {
          this._idPool[data.id] = res.id;
          if (this._waitPull[data.id]) {
            this._waitPull[data.id].forEach((v) => v(res.id));
            delete this._waitPull[data.id];
          }
          if (proc.kind) {
            let t = this._backId[proc.kind];
            if (!t) t = this._backId[proc.kind] = {};
            t[res.id] = data.id;
          }
        }
        data.response = res;
        proc.resolve(true);
        if (finish) finish();
        if (check) this.execQueue();
      },
      (e) => {
        if (finish) finish();
        proc.reject(e);
      }
    );
    return true;
  }
  exec(action, data, proc, finish) {
    const correctData = this.correctID(data, proc.ignoreID ? data.id : null);
    if (correctData === cantSendYet) {
      return null;
    }
    let res;
    try {
      res = proc.handler(correctData, action, data);
    } catch (e) {
      finish();
      proc.reject(e);
    }
    return res;
  }
  correctID(obj, ignore) {
    let copy = null;
    for (const key in obj) {
      const test = obj[key];
      if (typeof test === "object") {
        const after = this.correctID(test, ignore);
        if (after !== test) {
          if (after === cantSendYet) {
            return cantSendYet;
          }
          if (copy === null) {
            copy = { ...obj };
          }
          copy[key] = after;
        }
      } else if (isTempID(test)) {
        const hasRealID = this._idPool[test];
        if (hasRealID) {
          if (copy === null) {
            copy = { ...obj };
          }
          copy[key] = hasRealID;
        } else if (!ignore) {
          return cantSendYet;
        }
      }
    }
    return copy || obj;
  }
  execQueue() {
    this._awaitAddingQueue.forEach((a) => {
      if (!a.sent) {
        const finish = () => this._finishQueue(a);
        if (this.tryExec(a.action, a.data, a.proc, finish)) a.sent = true;
      }
    });
  }
  _finishQueue(a) {
    this._awaitAddingQueue = this._awaitAddingQueue.filter((v) => v !== a);
    if (!this._awaitAddingQueue.length && this._status.length) {
      const temp = [...this._status];
      this._status = [];
      temp.forEach((resolve) => resolve());
    }
  }
};

// src/RestDataProvider.ts
var Rest = class extends EventBus {
  constructor(url, config) {
    super();
    this._customHeaders = {};
    this._batchQueue = [];
    this._batchTimeout = null;
    this._url = url;
    this._batchUrl = config?.batchURL;
    this._queue = new ActionQueue();
    const handlers = this.getHandlers();
    for (const x in handlers) {
      this.on(x, (ev) => {
        if (!ev.skipProvider)
          return this._queue.add(x, ev, handlers[x]);
      });
    }
  }
  getHandlers() {
    return {};
  }
  setHeaders(headers) {
    this._customHeaders = headers;
  }
  getQueue() {
    return this._queue;
  }
  async send(url, method, data, customHeaders = {}) {
    if (this._batchUrl && method !== "GET") {
      return this.sendBatchRequest(url, method, data, customHeaders);
    } else {
      return this.sendRequest(url, method, data, customHeaders);
    }
  }
  async sendBatchRequest(url, method, data, customHeaders) {
    return new Promise((resolve) => {
      this._batchQueue.push({
        url,
        method,
        data,
        resolve
      });
      if (this._batchTimeout) {
        clearTimeout(this._batchTimeout);
      }
      this._batchTimeout = setTimeout(async () => {
        const currentQueue = [...this._batchQueue];
        this._batchQueue = [];
        if (currentQueue.length > 1) {
          const batchData = currentQueue.map((req) => ({
            url: req.url,
            method: req.method,
            data: {
              ...req.data
            }
          }));
          const results = await this.sendRequest(
            this._batchUrl,
            "POST",
            batchData
          );
          currentQueue.forEach((q, i) => q.resolve(results[i]));
        } else {
          const result = await this.sendRequest(
            url,
            method,
            data,
            customHeaders
          );
          resolve(result);
        }
      }, 10);
    });
  }
  toPayload(obj) {
    return JSON.stringify(obj);
  }
  async sendRequest(url, method, data, customHeaders = {}) {
    const headers = {
      "Content-Type": "application/json",
      ...customHeaders,
      ...this._customHeaders
    };
    const req = {
      method,
      headers
    };
    if (data) {
      req.body = typeof data === "object" ? this.toPayload(data) : data;
    }
    const slash = this._url.charAt(-1) === "/" || url[0] === "/" ? "" : "/";
    return fetch(`${this._url}${slash}${url || ""}`, req).then(
      (res) => res.json()
    );
  }
};

class RestDataProvider extends Rest {
  _normalize;
  constructor(url, normalize) {
    super(url);
    this._normalize = normalize;
  }
  getHandlers() {
    return {
      "add-row": {
        ignoreID: true,
        handler: (ev) => {
          const d = this.send("", "POST", ev);
          if (!this._normalize) return d;
          return d.then((obj) => {
            this._normalize(obj);
            return obj;
          });
        }
      },
      "delete-row": {
        handler: (ev) => {
          return this.send(`/${ev.id}`, "DELETE");
        }
      },
      "update-row": {
        handler: (ev) => {
          return this.send(`/${ev.id}`, "PUT", ev);
        }
      },
      "update-cell": {
        handler: (ev) => {
          return this.send(`/${ev.id}`, "PATCH", {
            key: ev.column,
            value: ev.value.toString()
          });
        }
      }
    };
  }
  getData() {
    const d = this.send("", "GET");
    if (!this._normalize) return d;
    return d.then((obj) => {
      if (this._normalize) obj.forEach(this._normalize);
      return obj;
    });
  }
}

export { RestDataProvider };
//# sourceMappingURL=index.js.map
