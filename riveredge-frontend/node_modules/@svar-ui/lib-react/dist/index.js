import { useState, useRef, useEffect } from 'react';
import { hotkeys, env, locate, id } from '@svar-ui/lib-dom';

// src/hooks.ts
function useWritableProp(propValue) {
  const [value, setValue] = useState(propValue);
  const prevPropRef = useRef(propValue);
  useEffect(() => {
    if (prevPropRef.current !== propValue) {
      if (Array.isArray(prevPropRef.current) && Array.isArray(propValue) && prevPropRef.current.length === 0 && propValue.length === 0)
        return;
      prevPropRef.current = propValue;
      setValue(propValue);
    }
  }, [propValue]);
  return [value, setValue];
}
function useWritable(writable2, initialValue, name) {
  const [state, setState] = useState(() => initialValue);
  if (!writable2) console.warn(`Writable ${name} is not defined`);
  useEffect(() => {
    if (!writable2) return;
    const unsubscribe = writable2.subscribe((newValue) => {
      setState(() => newValue);
    });
    return unsubscribe;
  }, [writable2]);
  return state;
}
function useStore(store, name) {
  const s = store.getState();
  const r = store.getReactiveState();
  return useWritable(r[name], s[name], name);
}
function useStoreLater(store, name) {
  const [state, setState] = useState(() => null);
  useEffect(() => {
    if (!store) return;
    const r = store.getReactiveState();
    const wr = r ? r[name] : null;
    if (!wr) return;
    const unsubscribe = wr.subscribe((newValue) => setState(() => newValue));
    return unsubscribe;
  }, [store, name]);
  return state;
}
function useWritableWithCounter(writable2, initialValue) {
  const state = useRef(initialValue);
  state.current = initialValue;
  const [counter, setCounter] = useState(1);
  useEffect(() => {
    const unsubscribe = writable2.subscribe((newValue) => {
      state.current = newValue;
      setCounter((v) => v + 1);
    });
    return unsubscribe;
  }, [writable2]);
  return [state.current, counter];
}
function useStoreWithCounter(store, name) {
  const s = store.getState();
  const r = store.getReactiveState();
  return useWritableWithCounter(r[name], s[name]);
}
function useHotkeys(keys, nodeRef) {
  useEffect(() => {
    const node = nodeRef.current;
    if (!node) return;
    return hotkeys.subscribe((sk) => {
      sk.configure(keys, node);
    });
  }, [hotkeys, nodeRef]);
}

// src/helpers.ts
function snippet(name, arg) {
  if (typeof name === "function") {
    if (typeof arg === "object") {
      return name(arg);
    } else {
      return name();
    }
  }
  return name;
}
function directive(result) {
  if (result && typeof result === "object" && typeof result.destroy === "function") {
    return result.destroy;
  }
}
function styleObject(text) {
  const out = {};
  text.split(";").forEach((x) => {
    const [k, v] = x.split(":");
    if (v) {
      let n = k.trim();
      if (n.indexOf("-")) n = n.replace(/-([a-z])/g, (_, c) => c.toUpperCase());
      out[n] = v.trim();
    }
  });
  return out;
}
function tick() {
  return new Promise((resolve) => {
    requestAnimationFrame(() => {
      setTimeout(resolve, 0);
    });
  });
}

// src/writable.ts
function writable(value) {
  let _value = value;
  let listeners = [];
  const subscribe = (cb) => {
    listeners.push(cb);
    cb(_value);
  };
  const unsubscribe = (cb) => {
    listeners = listeners.filter((l) => l !== cb);
  };
  const update = (cb) => {
    _value = cb(_value);
    listeners.forEach((l) => l(_value));
  };
  const set = (v) => {
    _value = v;
    listeners.forEach((l) => l(_value));
  };
  return {
    subscribe,
    unsubscribe,
    set,
    update
  };
}
function delegateEvent(node, handlers, event) {
  function handleEvent(ev) {
    const node2 = locate(ev);
    if (!node2) return;
    const id$1 = id(node2.dataset.id);
    if (typeof handlers === "function") return handlers(id$1, ev);
    let action;
    let test = ev.target;
    while (test != node2) {
      action = test.dataset ? test.dataset.action : null;
      if (action) {
        if (handlers[action]) {
          handlers[action](id$1, ev);
          return;
        }
      }
      test = test.parentNode;
    }
    if (handlers[event]) handlers[event](id$1, ev);
  }
  return env.addEvent(node, event, handleEvent);
}
function delegateClick(node, handlers) {
  const result = [delegateEvent(node, handlers, "click")];
  if (handlers.dblclick)
    result.push(delegateEvent(node, handlers.dblclick, "dblclick"));
  return () => {
    result.forEach((r) => r());
  };
}

export { delegateClick, delegateEvent, directive, snippet, styleObject, tick, useHotkeys, useStore, useStoreLater, useStoreWithCounter, useWritable, useWritableProp, useWritableWithCounter, writable };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map