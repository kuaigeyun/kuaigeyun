import { Base } from './base.js';
export class Charset extends Base {
    constructor(...inputs) {
        super();
        this.data = [];
        for (const input of inputs) {
            if (input instanceof Charset) {
                this.data.push(...input.data);
            }
            else {
                this.data.push(normalize(input));
            }
        }
        this._unique();
    }
    union(...inputs) {
        return new Charset(this, ...inputs);
    }
    subtract(...inputs) {
        const currentData = this.data.slice();
        const newData = [];
        let subtractIndex = 0;
        const { data: subtractData } = new Charset(...inputs);
        while (currentData.length !== 0) {
            const dataUnit = currentData.shift();
            const [start, end] = dataUnit;
            let isDone;
            do {
                isDone = true;
                const subtractDataUnit = subtractData[subtractIndex];
                if (subtractDataUnit === undefined) {
                    newData.push(dataUnit);
                    break;
                }
                const [subtractStart, subtractEnd] = subtractDataUnit;
                if (subtractEnd < start) {
                    // front + no overlap
                    isDone = false;
                    subtractIndex++;
                }
                else if (end < subtractStart) {
                    // back + no overlap
                    newData.push(dataUnit);
                }
                else if (subtractStart <= start && subtractEnd < end) {
                    // front overlap
                    subtractIndex++;
                    currentData.unshift([subtractEnd + 1, end]);
                }
                else if (start < subtractStart && subtractEnd < end) {
                    // central overlap
                    subtractIndex++;
                    newData.push([start, subtractStart - 1]);
                    currentData.unshift([subtractEnd + 1, end]);
                }
                else if (start < subtractStart && end <= subtractEnd) {
                    // back overlap
                    newData.push([start, subtractStart - 1]);
                } // else: entire overlap
            } while (!isDone);
        }
        return new Charset(...newData);
    }
    intersect(...inputs) {
        return this.subtract(this.subtract(...inputs));
    }
    _isEmpty() {
        return this.data.length === 0;
    }
    _toString(flags) {
        return rangesToString(this.data, flags);
    }
    _unique() {
        this.data.sort(compare);
        const newData = [];
        let lastDataUnit = null;
        for (const dataUnit of this.data) {
            if (lastDataUnit === null || lastDataUnit[1] + 1 < dataUnit[0]) {
                newData.push(dataUnit);
                lastDataUnit = dataUnit;
            }
            else {
                newData.splice(-1, 1, [
                    Math.min(dataUnit[0], lastDataUnit[0]),
                    Math.max(dataUnit[1], lastDataUnit[1]),
                ]);
                lastDataUnit = newData[newData.length - 1];
            }
        }
        this.data = newData;
    }
}
export const charset = (...inputs) => new Charset(...inputs);
function charCode(char) {
    if (char.length !== 1) {
        const display = `${char.length} (${JSON.stringify(char)})`;
        throw new Error(`Expected length = 1, but received ${display}.`);
    }
    return char.charCodeAt(0);
}
function normalize(rawInput) {
    if (typeof rawInput === 'number' && (rawInput < 0 || rawInput > 0x10ffff)) {
        throw new Error(`Invalid unicode code point detected: ${rawInput < 0 ? rawInput : `0x${rawInput.toString(16)}`}`);
    }
    const [normalized] = [rawInput]
        .map(_ => (typeof _ !== 'object' ? [_, _] : _))
        .map(_ => _.map(u => (typeof u === 'string' ? charCode(u) : u)));
    return normalized;
}
function compare(a, b) {
    return a[0] - b[0];
}
function rangesToString(ranges, flags = '') {
    if (flags.includes('u')) {
        return normalToPattern(ranges, true);
    }
    const { normal, surrogate } = splitRanges(ranges);
    const patterns = [];
    if (normal.length !== 0) {
        patterns.push(normalToPattern(normal, false));
    }
    patterns.push(...surrogateToPatterns(surrogate));
    return patterns.join('|');
}
function normalToPattern(normal, hasUnicodeFlag) {
    const ranges = normal.map(([start, end]) => start === end
        ? unicode(start, hasUnicodeFlag)
        : `${unicode(start, hasUnicodeFlag)}-${unicode(end, hasUnicodeFlag)}`);
    return `[${ranges.join('')}]`;
}
function surrogateToPatterns(surrogate) {
    const patterns = [];
    if (surrogate.entire.data.length !== 0) {
        const h = surrogate.entire.toString();
        const l = `[${[56320 /* SurrogateLimit.MinL */, 57343 /* SurrogateLimit.MaxL */]
            .map(_ => unicode(_, false))
            .join('-')}]`;
        patterns.push(`${h}${l}`);
    }
    for (const { h: rawH, l: lCharset } of surrogate.partial) {
        const h = unicode(rawH, false);
        const l = lCharset.toString();
        patterns.push(`${h}${l}`);
    }
    return patterns;
}
function splitRanges(data) {
    const normal = [];
    const surrogateRanges = [];
    for (let i = 0; i < data.length; i++) {
        const dataUnit = data[i];
        const [start, end] = dataUnit;
        if (start >= 65536 /* SurrogateLimit.Min */) {
            surrogateRanges.push(...data.slice(i));
            break;
        }
        if (end >= 65536 /* SurrogateLimit.Min */) {
            normal.push([start, 65536 /* SurrogateLimit.Min */ - 1]);
            surrogateRanges.push([0x10000, end], ...data.slice(i + 1));
            break;
        }
        normal.push(dataUnit);
    }
    return { normal, surrogate: splitSurrogateRanges(surrogateRanges) };
}
function splitSurrogateRanges(ranges) {
    const entire = [];
    const partial = [];
    for (const [start, end] of ranges) {
        const startPair = surrogatePair(start);
        const endPair = surrogatePair(end);
        if (startPair.h === endPair.h) {
            addPartialRange(startPair.h, startPair.l, endPair.l);
            continue;
        }
        if (startPair.l === 56320 /* SurrogateLimit.MinL */) {
            addEntireRange(startPair.h);
        }
        else {
            addPartialRange(startPair.h, startPair.l, 57343 /* SurrogateLimit.MaxL */);
        }
        for (let h = startPair.h + 1; h < endPair.h; h++) {
            addEntireRange(h);
        }
        if (endPair.l === 57343 /* SurrogateLimit.MaxL */) {
            addEntireRange(endPair.h);
        }
        else {
            addPartialRange(endPair.h, 56320 /* SurrogateLimit.MinL */, endPair.l);
        }
    }
    return {
        entire: new Charset(...entire),
        partial: partial.map(({ h, l }) => ({ h, l: new Charset(...l) })),
    };
    function addEntireRange(h) {
        entire.push(h);
    }
    function addPartialRange(h, start, end) {
        const lastPartial = partial[partial.length - 1];
        if (lastPartial !== undefined && lastPartial.h === h) {
            lastPartial.l.push([start, end]);
        }
        else {
            partial.push({ h, l: [[start, end]] });
        }
    }
}
// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
function surrogatePair(codepoint) {
    return {
        h: Math.floor((codepoint - 0x10000) / 0x400) + 0xd800,
        l: ((codepoint - 0x10000) % 0x400) + 0xdc00,
    };
}
function unicode(char, hasUnicodeFlag) {
    const hex = char.toString(16);
    return hasUnicodeFlag
        ? `\\u{${hex}}`
        : `\\u${'0'.repeat(4 - hex.length)}${hex}`;
}
