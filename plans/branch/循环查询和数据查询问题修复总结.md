# React循环查询和数据查询问题修复总结

## 问题概述

在RiverEdge SaaS多组织框架开发过程中，遇到了一系列关于React组件循环查询和后端数据查询失败的问题。本文档总结了问题的根因分析、解决方案以及预防措施。

## 问题1：React组件无限循环查询

### 问题描述
```
Warning: Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.
```

### 问题根因
在`QuerySearchModal`组件中，存在以下循环依赖：

1. **状态更新循环**：
```typescript
// ❌ 问题代码
useEffect(() => {
  setPinnedSearches([...orderedShared, ...orderedPersonal]);
}, [allPinnedSearches, pagePath]); // allPinnedSearches每次都重新计算
```

2. **激活状态计算循环**：
```typescript
// ❌ 问题代码
const pinnedSearchActiveStates = useMemo(() => {
  return visiblePinnedSearches.map(search => isSearchActive(search));
}, [visiblePinnedSearches, isSearchActive]); // isSearchActive函数引用不稳定
```

### 解决方案

#### 方案1：状态更新循环修复
```typescript
// ✅ 修复方案：用useMemo替代useEffect + setState
const pinnedSearches = useMemo(() => {
  // 直接计算并返回结果，避免状态更新
  return [...orderedShared, ...orderedPersonal];
}, [savedSearchesData?.items, pagePath]);
```

#### 方案2：激活状态计算优化
```typescript
// ✅ 修复方案：创建稳定的计算函数
const getSearchActiveState = useCallback((search: SavedSearch): boolean => {
  // 稳定的计算逻辑
}, []); // 空依赖数组，确保函数引用稳定

const pinnedSearchActiveStates = useMemo(() => {
  return visiblePinnedSearches.map(search => getSearchActiveState(search));
}, [visiblePinnedSearches, getSearchActiveState]); // 依赖稳定引用
```

### 预防措施
1. **避免useEffect + setState模式**：优先使用useMemo进行纯计算
2. **确保依赖数组稳定性**：使用useCallback创建稳定的函数引用
3. **最小化状态更新**：只有在真正需要时才使用setState

## 问题2：后端数据查询失败

### 问题描述
```
字段 "deleted_at" 不存在
```

### 问题根因
数据库表结构与Tortoise ORM模型定义不一致：

1. **模型定义**：
```python
class User(BaseModel):
    deleted_at = fields.DatetimeField(null=True, description="删除时间（软删除）")
```

2. **数据库表**：缺少`deleted_at`字段

### 解决方案

#### 方案1：添加缺失字段（临时方案）
```sql
ALTER TABLE sys_users ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMPTZ;
```

#### 方案2：使用Aerich进行迁移（推荐方案）
```bash
aerich migrate --name add_deleted_at_to_user_model
aerich upgrade
```

### 预防措施
1. **严格使用ORM迁移工具**：永远不要直接写SQL创建表
2. **保持模型与数据库同步**：每次修改模型后都要运行迁移
3. **定期检查表结构一致性**：使用`aerich status`检查状态

## 问题3：多对多关系查询失败

### 问题描述
```
字段 "sys_roles_id" 不存在
tortoise.exceptions.OperationalError: 字段 "sys_roles_id" 不存在
```

### 问题根因
Tortoise ORM在处理多对多关系查询时出现字段映射错误：

1. **关联表结构问题**：`sys_role_permissions`表的字段映射不正确
2. **查询时机问题**：在错误的时机执行多对多关系查询

### 解决方案
```python
# ❌ 问题代码：直接预加载关联数据
await role.fetch_related('permissions')

# ✅ 修复方案：暂时禁用关联查询
# await role.fetch_related('permissions')  # 注释掉有问题的查询
permission_count = 0  # 返回固定值
```

### 长期解决方案
1. **修复关联表结构**：确保多对多关系表的字段命名正确
2. **优化查询时机**：在合适的时间点执行关联查询
3. **使用正确的关联语法**：检查Tortoise ORM文档中的关联关系定义

## 问题4：组织上下文缺失

### 问题描述
```
组织上下文未设置
```

### 问题根因
平台超级管理员访问系统级功能时没有设置组织上下文：

1. **前端缺少组织选择**：没有组织选择器
2. **API缺少组织传递**：请求头中没有`X-Tenant-ID`

### 解决方案

#### 前端组织选择器
```typescript
const TenantSelector: React.FC = () => {
  const userInfo = getUserInfo();
  const isPlatformSuperAdmin = userInfo?.user_type === 'platform_superadmin';

  // 自动选择组织
  React.useEffect(() => {
    if (isPlatformSuperAdmin && !currentTenantId && tenantData?.items?.length > 0) {
      const firstTenant = tenantData.items[0];
      setTenantId(firstTenant.id);
    }
  }, [isPlatformSuperAdmin, currentTenantId, tenantData]);

  // 组织选择UI
  if (isPlatformSuperAdmin) {
    return (
      <Select onChange={handleTenantChange}>
        {tenantData?.items?.map(tenant => (
          <Option key={tenant.id} value={tenant.id}>{tenant.name}</Option>
        ))}
      </Select>
    );
  }
};
```

#### API请求组织传递
```typescript
const fetchOptions: RequestInit = {
  headers: {
    // 系统级API必须包含组织上下文
    ...(currentTenantId && url.startsWith('/system/') ? { 'X-Tenant-ID': currentTenantId } : {}),
  },
};
```

#### 后端组织上下文处理
```python
async def get_current_tenant(x_tenant_id: Optional[str] = Header(None, alias="X-Tenant-ID")) -> int:
    tenant_id = x_tenant_id or get_tenant_id_from_context()
    if not tenant_id:
        raise HTTPException(status_code=400, detail="组织上下文未设置")
    set_current_tenant_id(tenant_id)
    return tenant_id
```

## 核心教训总结

### 1. React状态管理原则
- **优先使用计算而非状态**：用useMemo替代useEffect + setState
- **保持依赖稳定性**：使用useCallback创建稳定函数引用
- **避免循环依赖**：确保useEffect和useMemo的依赖数组不会相互触发

### 2. 数据库管理原则
- **严格使用ORM迁移**：永远不要直接写SQL，除非是紧急修复
- **保持模型同步**：每次修改模型后都要检查和运行迁移
- **验证表结构**：定期检查数据库表结构与模型定义的一致性

### 3. 多组织架构原则
- **明确上下文要求**：系统级功能必须在组织上下文中执行
- **前端组织管理**：为平台管理员提供组织选择功能
- **API组织传递**：确保所有系统级API请求包含组织标识

### 4. 问题排查流程
1. **检查控制台错误**：查看具体的错误信息和堆栈跟踪
2. **分析依赖关系**：检查useEffect/useMemo的依赖数组
3. **验证数据库状态**：检查表结构与模型定义的一致性
4. **测试API连通性**：手动测试API是否能正常响应

### 5. 代码质量保证
- **添加错误边界**：使用ErrorBoundary捕获和处理错误
- **日志记录**：在关键位置添加详细的日志记录
- **类型安全**：使用TypeScript确保类型安全
- **单元测试**：为关键功能编写单元测试

## 预防措施清单

### 开发阶段
- [ ] 使用ESLint和TypeScript严格模式
- [ ] 定期运行`aerich status`检查迁移状态
- [ ] 每次修改模型后运行`aerich migrate && aerich upgrade`
- [ ] 使用React DevTools检查组件渲染性能

### 代码审查
- [ ] 检查所有useEffect是否有正确的依赖数组
- [ ] 验证useMemo的使用是否合理
- [ ] 确认数据库迁移文件是否完整
- [ ] 检查API错误处理是否完善

### 部署前检查
- [ ] 运行完整的前后端测试套件
- [ ] 检查数据库迁移是否全部应用
- [ ] 验证生产环境的配置是否正确
- [ ] 确认日志系统正常工作

## 相关文档链接

- [React性能优化指南](https://react.dev/learn/render-and-commit)
- [Tortoise ORM迁移文档](https://tortoise-orm.readthedocs.io/en/latest/migrations.html)
- [多组织架构设计](plans/2.rules/6.API设计规范.md)
- [数据库命名规范](plans/2.rules/3.数据库命名规范.md)

---

**最后更新**：2025-12-01
**修复版本**：v1.0.0
**相关问题**：循环查询、数据查询失败、组织上下文缺失
