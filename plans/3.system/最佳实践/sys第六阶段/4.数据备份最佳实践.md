# 数据备份最佳实践

## 📋 模块概述

**模块名称**：数据备份（Data Backup）  
**优先级**：⭐⭐⭐（中优先级）  
**预计时间**：2 周  
**依赖**：Inngest（定时备份任务）、文件管理（备份文件存储）

**功能范围**：
- 数据备份管理（创建备份、恢复备份、备份列表、删除备份）
- Inngest 定时备份任务（全量备份、增量备份）
- 备份策略配置（备份频率、保留策略）
- 数据恢复服务（从备份文件恢复数据库）

**核心特点**：
- ✅ **基于 Inngest**：使用 Inngest 定时触发器执行备份任务
- ✅ **多种备份类型**：支持全量备份、增量备份
- ✅ **备份策略**：支持配置备份频率、保留策略
- ✅ **数据恢复**：支持从备份文件恢复数据库

---

## 🔍 库选择评估

### 数据备份实现方案

**结论**：✅ **使用自定义实现 + Inngest 定时任务 + pg_dump（推荐）**

#### 方案一：自定义实现 + Inngest + pg_dump ⭐⭐⭐⭐⭐（强烈推荐）

**优势**：
- ✅ 功能完整，支持全量和增量备份
- ✅ Inngest 定时任务，支持灵活的备份策略
- ✅ pg_dump 是 PostgreSQL 官方工具，稳定可靠
- ✅ 多租户隔离天然支持（tenant_id 字段）
- ✅ 完全符合框架规范（命名、注释、代码风格）

**劣势**：
- ⚠️ 需要调用命令行工具，需要系统权限
- ⚠️ 备份文件可能很大，需要足够的存储空间

**适用场景**：
- ✅ 需要定时自动备份
- ✅ 需要灵活的备份策略
- ✅ 需要多租户数据隔离

**实现复杂度**：⭐⭐⭐（中等，2 周可完成）

---

## 🗄️ 数据库设计

### 数据备份表（root_data_backups）

```sql
CREATE TABLE root_data_backups (
    id SERIAL PRIMARY KEY,
    uuid VARCHAR(36) NOT NULL UNIQUE,        -- 业务ID（UUID，对外暴露，安全且唯一）
    tenant_id INTEGER NOT NULL,
    
    -- 备份基本信息
    name VARCHAR(200) NOT NULL,             -- 备份名称
    backup_type VARCHAR(20) NOT NULL,       -- 备份类型（full-全量、incremental-增量）
    backup_scope VARCHAR(20) NOT NULL,      -- 备份范围（all-全部、tenant-组织、table-表）
    backup_tables TEXT[],                    -- 备份表列表（如果 scope 为 table）
    
    -- 备份文件信息
    file_path VARCHAR(500),                  -- 备份文件路径（关联文件管理）
    file_uuid VARCHAR(36),                   -- 备份文件UUID（关联文件管理）
    file_size BIGINT,                        -- 备份文件大小（字节）
    
    -- 备份状态
    status VARCHAR(20) NOT NULL,             -- 备份状态（pending、running、success、failed）
    inngest_run_id VARCHAR(100),            -- Inngest 运行ID（关联备份任务）
    started_at TIMESTAMP,                   -- 备份开始时间
    completed_at TIMESTAMP,                  -- 备份完成时间
    error_message TEXT,                      -- 错误信息
    
    -- 标准字段
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL,
    
    -- 索引
    INDEX idx_root_data_backups_tenant_id (tenant_id),
    INDEX idx_root_data_backups_uuid (uuid),
    INDEX idx_root_data_backups_backup_type (backup_type),
    INDEX idx_root_data_backups_backup_scope (backup_scope),
    INDEX idx_root_data_backups_status (status),
    INDEX idx_root_data_backups_created_at (created_at)
);
```

**设计要点**：
- ✅ **混合ID方案**：`id`（自增ID，内部使用）+ `uuid`（UUID，对外暴露）
- ✅ `backup_type` 字段标识备份类型（full、incremental）
- ✅ `backup_scope` 字段标识备份范围（all、tenant、table）
- ✅ `file_uuid` 字段关联文件管理模块
- ✅ `status` 字段标识备份状态（pending、running、success、failed）
- ✅ `inngest_run_id` 字段关联 Inngest 任务
- ✅ 软删除支持（`deleted_at`）

---

## 🔧 后端实现

### 1. 创建数据库模型

**文件位置**：`riveredge-backend/src/tree_root/models/data_backup.py`

参考第四阶段的模型格式创建。

### 2. 创建 Schema

**文件位置**：`riveredge-backend/src/tree_root/schemas/data_backup.py`

参考第四阶段的 Schema 格式创建。

### 3. 创建 Service

**文件位置**：`riveredge-backend/src/tree_root/services/data_backup_service.py`

```python
"""
数据备份管理服务模块

提供数据备份的 CRUD 操作和备份恢复功能。
"""

import subprocess
import os
from typing import Optional, List
from datetime import datetime
from pathlib import Path

from tree_root.models.data_backup import DataBackup
from tree_root.schemas.data_backup import DataBackupCreate, DataBackupUpdate
from soil.exceptions.exceptions import NotFoundError, ValidationError
from soil.infrastructure.database.database import get_db_config


class DataBackupService:
    """
    数据备份管理服务类
    
    提供数据备份的 CRUD 操作和备份恢复功能。
    """
    
    @staticmethod
    async def create_backup(
        tenant_id: int,
        data: DataBackupCreate
    ) -> DataBackup:
        """
        创建备份任务
        
        Args:
            tenant_id: 组织ID
            data: 备份创建数据
            
        Returns:
            DataBackup: 创建的备份对象
        """
        backup = DataBackup(
            tenant_id=tenant_id,
            **data.model_dump()
        )
        backup.status = "pending"
        await backup.save()
        
        # TODO: 通过 Inngest 触发备份任务
        # from tree_root.inngest.client import inngest_client
        # from inngest import Event
        # await inngest_client.send_event(
        #     event=Event(
        #         name="backup/execute",
        #         data={
        #             "tenant_id": tenant_id,
        #             "backup_id": str(backup.uuid),
        #             "backup_type": data.backup_type,
        #             "backup_scope": data.backup_scope
        #         }
        #     )
        # )
        
        return backup
    
    @staticmethod
    async def execute_backup(
        tenant_id: int,
        backup_uuid: str
    ) -> dict:
        """
        执行备份（由 Inngest 函数调用）
        
        Args:
            tenant_id: 组织ID
            backup_uuid: 备份UUID
            
        Returns:
            dict: 备份结果
        """
        backup = await DataBackupService.get_backup_by_uuid(tenant_id, backup_uuid)
        
        # 更新状态为运行中
        backup.status = "running"
        backup.started_at = datetime.now()
        await backup.save()
        
        try:
            # 获取数据库配置
            db_config = get_db_config()
            
            # 生成备份文件路径
            backup_dir = Path("backups")
            backup_dir.mkdir(exist_ok=True)
            backup_filename = f"backup_{backup.uuid}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.sql"
            backup_filepath = backup_dir / backup_filename
            
            # 构建 pg_dump 命令
            cmd = [
                "pg_dump",
                "-h", db_config.get("host", "localhost"),
                "-p", str(db_config.get("port", 5432)),
                "-U", db_config.get("user", "postgres"),
                "-d", db_config.get("database", "riveredge"),
                "-f", str(backup_filepath)
            ]
            
            # 如果备份范围是组织，需要添加筛选条件
            if backup.backup_scope == "tenant":
                # 全量备份，但可以后续过滤
                pass
            elif backup.backup_scope == "table":
                # 备份指定表
                if backup.backup_tables:
                    cmd.extend(["-t", ",".join(backup.backup_tables)])
            
            # 执行备份
            env = os.environ.copy()
            env["PGPASSWORD"] = db_config.get("password", "")
            
            result = subprocess.run(
                cmd,
                env=env,
                capture_output=True,
                text=True
            )
            
            if result.returncode != 0:
                raise Exception(f"备份失败: {result.stderr}")
            
            # 获取备份文件大小
            file_size = backup_filepath.stat().st_size
            
            # 更新备份记录
            backup.status = "success"
            backup.completed_at = datetime.now()
            backup.file_path = str(backup_filepath)
            backup.file_size = file_size
            await backup.save()
            
            # TODO: 上传备份文件到文件管理模块
            # file_uuid = await upload_backup_file(backup_filepath)
            # backup.file_uuid = file_uuid
            # await backup.save()
            
            return {
                "success": True,
                "file_path": str(backup_filepath),
                "file_size": file_size
            }
        except Exception as e:
            # 更新备份状态为失败
            backup.status = "failed"
            backup.completed_at = datetime.now()
            backup.error_message = str(e)
            await backup.save()
            
            return {
                "success": False,
                "error": str(e)
            }
    
    @staticmethod
    async def restore_backup(
        tenant_id: int,
        backup_uuid: str
    ) -> dict:
        """
        恢复备份
        
        Args:
            tenant_id: 组织ID
            backup_uuid: 备份UUID
            
        Returns:
            dict: 恢复结果
        """
        backup = await DataBackupService.get_backup_by_uuid(tenant_id, backup_uuid)
        
        if backup.status != "success":
            raise ValidationError("备份未完成，无法恢复")
        
        if not backup.file_path:
            raise ValidationError("备份文件不存在")
        
        try:
            # 获取数据库配置
            db_config = get_db_config()
            
            # 构建 pg_restore 命令
            cmd = [
                "psql",
                "-h", db_config.get("host", "localhost"),
                "-p", str(db_config.get("port", 5432)),
                "-U", db_config.get("user", "postgres"),
                "-d", db_config.get("database", "riveredge"),
                "-f", backup.file_path
            ]
            
            # 执行恢复
            env = os.environ.copy()
            env["PGPASSWORD"] = db_config.get("password", "")
            
            result = subprocess.run(
                cmd,
                env=env,
                capture_output=True,
                text=True
            )
            
            if result.returncode != 0:
                raise Exception(f"恢复失败: {result.stderr}")
            
            return {
                "success": True,
                "message": "数据恢复成功"
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }
```

### 4. 创建 Inngest 函数

**文件位置**：`riveredge-backend/src/tree_root/inngest/functions/data_backup.py`

```python
"""
数据备份 Inngest 函数

定时执行数据备份任务。
"""

from inngest import Inngest, Event
from inngest.functions import Step
from typing import Dict, Any

inngest = Inngest(app_id="riveredge")

@inngest.create_function(
    id="data-backup-full",
    name="全量数据备份",
    trigger=inngest.TriggerCron(cron="0 2 * * *")  # 每天凌晨2点
)
async def full_backup_function(event: Event) -> Dict[str, Any]:
    """
    全量数据备份函数
    
    每天凌晨2点执行全量备份。
    """
    # 获取所有组织
    # tenants = await get_all_tenants()
    
    # 为每个组织创建全量备份任务
    # for tenant in tenants:
    #     await Step.run(
    #         f"backup-tenant-{tenant.id}",
    #         lambda: create_full_backup(tenant.id)
    #     )
    
    return {"success": True}

@inngest.create_function(
    id="data-backup-incremental",
    name="增量数据备份",
    trigger=inngest.TriggerCron(cron="0 * * * *")  # 每小时
)
async def incremental_backup_function(event: Event) -> Dict[str, Any]:
    """
    增量数据备份函数
    
    每小时执行增量备份。
    """
    # 实现增量备份逻辑
    return {"success": True}
```

### 5. 创建 API

**文件位置**：`riveredge-backend/src/tree_root/api/data_backups/data_backups.py`

参考第四阶段的 API 格式创建，包含：
- `POST /`：创建备份任务
- `GET /`：获取备份列表
- `GET /{uuid}`：获取备份详情
- `POST /{uuid}/restore`：恢复备份
- `DELETE /{uuid}`：删除备份
- `GET /{uuid}/download`：下载备份文件

### 6. 数据库迁移

**文件位置**：`riveredge-backend/migrations/models/XX_YYYYMMDDHHMMSS_create_data_backups.py`

参考第四阶段的迁移文件格式创建。

---

## 🌐 API 设计

### 数据备份管理 API

**路由前缀**：`/api/v1/system/data-backups`

**接口列表**：
1. `POST /` - 创建备份任务
2. `GET /` - 获取备份列表（支持筛选）
3. `GET /{uuid}` - 获取备份详情
4. `POST /{uuid}/restore` - 恢复备份
5. `DELETE /{uuid}` - 删除备份
6. `GET /{uuid}/download` - 下载备份文件

---

## 🎨 前端页面设计

### 数据备份页面

**页面路径**：`pages/system/data-backups/list/index.tsx`

**核心功能**：
1. 备份列表展示（UniTable，支持筛选）
2. 创建备份（手动创建备份，选择备份类型和范围）
3. 备份详情（查看备份信息、备份日志）
4. 恢复备份（选择备份文件恢复数据库，需确认）
5. 下载备份（下载备份文件）
6. 删除备份（删除备份记录和文件）
7. 备份策略配置（配置定时备份任务、保留策略）

**布局规范**：
- ✅ 使用 `UniTable` 组件展示列表
- ✅ 使用高级搜索（`showAdvancedSearch={true}`）
- ✅ 使用 `searchFormValues` 获取搜索条件
- ✅ 创建备份使用 Modal + ProForm
- ✅ 恢复备份使用 Popconfirm 确认

---

## ⚠️ 重要注意事项

### 1. 备份安全注意事项

**要点**：
- 备份文件应该加密存储（可选）
- 备份文件应该存储在安全的位置
- 备份权限控制，只有管理员可以创建和恢复备份
- 恢复备份前需要确认，防止误操作

### 2. 备份性能注意事项

**要点**：
- 全量备份可能耗时较长，应该异步执行
- 增量备份需要记录上次备份位置
- 备份文件可能很大，需要足够的存储空间
- 备份文件应该定期清理，避免占用过多空间

### 3. 备份策略注意事项

**要点**：
- 全量备份频率：建议每天一次
- 增量备份频率：建议每小时一次
- 备份保留策略：建议保留最近7天的全量备份和最近24小时的增量备份
- 备份文件清理：自动清理过期备份文件

### 4. 多租户支持

**要点**：
- 备份按组织隔离（tenant_id）
- 组织级备份只备份该组织的数据
- 全量备份可以备份所有组织的数据
- 恢复备份时需要验证组织权限

---

## 📚 相关文档

- [Inngest 集成指南.md](../sys第四阶段/Inngest集成指南.md)
- [前端页面布局规范.md](./前端页面布局规范.md)
- [系统级功能文件结构规划.md](./系统级功能文件结构规划.md)
- [建设进度.md](./建设进度.md)

---

**最后更新**：2025-01-XX

