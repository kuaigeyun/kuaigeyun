# 文件管理最佳实践

## 📋 模块概述

**模块名称**：文件管理（File Management）  
**优先级**：⭐⭐⭐⭐（高优先级）  
**预计时间**：1-2 周  
**依赖**：无（独立功能）

**功能范围**：
- 文件上传（单文件、多文件、拖拽上传）
- 文件下载（直接下载、预览下载）
- 文件删除（单个删除、批量删除）
- 文件列表（分页、搜索、筛选）
- 文件预览（双模式：简单预览 + kkFileView 预览，可配置）
- 文件存储（本地存储或对象存储）

**预览模式**：
- ✅ **简单预览**（默认）：支持 PDF、图片、文本等常见格式，无需额外服务
- ✅ **kkFileView 预览**（可选）：支持 23+ 种格式，需要独立部署 Java 服务
- ✅ **配置开关**：在系统参数设置中可开启/关闭 kkFileView 预览

**kkFileView 开源协议**：
- ✅ **Apache License 2.0**（Apache 许可证 2.0）
- ✅ **商业友好**：允许商业使用、修改和分发
- ✅ **宽松许可证**：只需保留原始许可证声明和版权声明
- ✅ **无限制使用**：可用于商业项目，无需支付许可费用
- 📚 **官方信息**：[kkFileView GitHub](https://github.com/kekingcn/kkFileView) | [kkFileView Gitee](https://gitee.com/kekingcn/file-online-preview)

---

## 🔍 库选择评估

### 文件管理实现方案

**结论**：✅ **使用自定义实现 + kkFileView（推荐）**

#### 方案一：自定义实现 + kkFileView ⭐⭐⭐⭐⭐（强烈推荐）

**优势**：
- ✅ 功能完整，支持文件上传、下载、删除、预览
- ✅ kkFileView 支持 23+ 种文件格式在线预览
- ✅ 与 FastAPI 完美集成（使用 aiofiles 异步文件操作）
- ✅ 多租户隔离天然支持（tenant_id 字段）
- ✅ 完全符合框架规范（命名、注释、代码风格）
- ✅ 支持本地存储和对象存储（可扩展）

**劣势**：
- ⚠️ kkFileView 需要独立部署（Java 服务）
- ⚠️ 需要自己实现文件存储逻辑

**适用场景**：
- ✅ 需要文件在线预览功能
- ✅ 需要多租户文件隔离
- ✅ 需要完全符合项目规范

**实现复杂度**：⭐⭐（中等，1-2 周可完成）

---

#### 方案二：Python 生态文件预览方案 ⭐⭐⭐（可选，但不如 kkFileView）

**Python 生态中的文件预览库**：

**1. LibreOffice + subprocess** ⭐⭐⭐
- ✅ 支持 Office 文档转换为 PDF/图片
- ✅ 开源免费
- ⚠️ 需要安装 LibreOffice（体积大，~200MB+）
- ⚠️ 需要调用命令行工具（性能较低）
- ⚠️ 不支持在线预览，需要先转换

**2. PyMuPDF (fitz)** ⭐⭐⭐⭐
- ✅ 优秀的 PDF 处理库
- ✅ 支持 PDF 渲染为图片
- ✅ 性能好，纯 Python 实现
- ❌ 仅支持 PDF 格式

**3. python-docx + openpyxl + python-pptx** ⭐⭐⭐
- ✅ 支持 Word、Excel、PowerPoint 文档读取
- ✅ 可以提取文本内容
- ❌ 不支持完整预览（只能提取文本，不能渲染格式）
- ❌ 需要组合多个库，实现复杂

**4. Pillow** ⭐⭐⭐
- ✅ 支持多种图片格式
- ✅ 性能好
- ❌ 仅支持图片格式

**Python 方案总结**：
- ❌ **没有完全等同于 kkFileView 的库**
- ⚠️ 需要组合多个库才能实现类似功能
- ⚠️ 实现复杂度高（需要文档转换、格式处理、前端渲染等）
- ⚠️ 性能不如 kkFileView（需要先转换再预览）
- ⚠️ 功能完整性不如 kkFileView（支持的格式较少）

**结论**：Python 生态中的文件预览方案功能分散，需要组合多个库，实现复杂度和维护成本都较高，不如直接使用 kkFileView。

---

#### 方案三：使用第三方库 ⭐⭐（不推荐）

**调研结果**：
- ❌ FastAPI 生态中没有专门的文件管理库
- ❌ Django 生态有 `django-filebrowser`，但不适用于 FastAPI
- ❌ 其他通用库功能过于复杂，不符合简单需求

**结论**：文件管理功能相对简单，使用第三方库反而增加复杂度，不推荐。

---

### 最终推荐方案

**推荐**：✅ **使用自定义实现 + kkFileView**

**理由**：
1. ✅ **功能完整**，自定义实现成本适中（1-2 周）
2. ✅ **kkFileView 支持多种格式**（23+ 种格式），满足文件预览需求
3. ✅ **kkFileView 是成熟方案**，Python 生态中没有完全等同的库
4. ✅ **多租户是核心需求**，自定义实现天然支持
5. ✅ **完全符合框架规范**，代码风格统一
6. ✅ **维护成本低**，团队完全掌控代码

**Python 生态替代方案评估**：
- ❌ **没有完全等同于 kkFileView 的库**
- ⚠️ Python 方案需要组合多个库（LibreOffice、PyMuPDF、python-docx 等）
- ⚠️ 实现复杂度高，维护成本高
- ⚠️ 功能完整性不如 kkFileView（支持的格式较少）
- ✅ **结论**：继续使用 kkFileView，虽然需要 Java 服务，但功能完整、成熟稳定

---

## 🗄️ 数据库设计

### 文件表（root_files）

```sql
CREATE TABLE root_files (
    id SERIAL PRIMARY KEY,
    uuid VARCHAR(36) NOT NULL UNIQUE,        -- 业务ID（UUID，对外暴露，安全且唯一）
    tenant_id INTEGER NOT NULL,
    
    -- 文件基本信息
    name VARCHAR(255) NOT NULL,            -- 文件名称（原始文件名）
    original_name VARCHAR(255) NOT NULL,    -- 原始文件名
    file_path VARCHAR(500) NOT NULL,        -- 文件存储路径
    file_size BIGINT NOT NULL,              -- 文件大小（字节）
    file_type VARCHAR(100),                -- 文件类型（MIME类型）
    file_extension VARCHAR(20),            -- 文件扩展名
    preview_url VARCHAR(500),               -- 预览URL（kkFileView）
    
    -- 文件分类和标签
    category VARCHAR(50),                  -- 文件分类（可选）
    tags TEXT,                              -- 文件标签（JSON数组，可选）
    description TEXT,                       -- 文件描述（可选）
    
    -- 文件状态
    is_active BOOLEAN DEFAULT TRUE,        -- 是否启用
    upload_status VARCHAR(20) DEFAULT 'completed',  -- 上传状态（uploading, completed, failed）
    
    -- 标准字段
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL,
    
    -- 索引
    INDEX idx_root_files_tenant_id (tenant_id),
    INDEX idx_root_files_uuid (uuid),
    INDEX idx_root_files_category (category),
    INDEX idx_root_files_file_type (file_type),
    INDEX idx_root_files_created_at (created_at),
    INDEX idx_root_files_upload_status (upload_status)
);
```

**设计要点**：
- ✅ **混合ID方案**：`id`（自增ID，内部使用）+ `uuid`（UUID，对外暴露）
- ✅ `file_path` 存储文件在服务器上的路径
- ✅ `preview_url` 存储 kkFileView 预览地址
- ✅ `upload_status` 支持上传状态跟踪（断点续传、上传失败处理）
- ✅ `category` 和 `tags` 支持文件分类和标签管理
- ✅ 软删除支持（`deleted_at`）

---

## 🐍 后端模型设计

### 文件模型（File）

```python
# riveredge-backend/src/tree_root/models/file.py
from tortoise.models import Model
from tortoise import fields
from typing import Optional
from .base import BaseModel


class File(BaseModel):
    """
    文件模型
    
    用于管理组织内的文件，支持文件上传、下载、预览、删除等功能。
    支持多组织隔离，每个组织的文件相互独立。
    
    注意：继承自 BaseModel，自动包含 uuid、tenant_id、created_at、updated_at 字段。
    """
    id = fields.IntField(pk=True, description="文件ID（主键，自增ID，内部使用）")
    # uuid 字段由 BaseModel 提供
    # tenant_id 字段由 BaseModel 提供
    
    name = fields.CharField(max_length=255, description="文件名称（原始文件名）")
    original_name = fields.CharField(max_length=255, description="原始文件名")
    file_path = fields.CharField(max_length=500, description="文件存储路径")
    file_size = fields.BigIntField(description="文件大小（字节）")
    file_type = fields.CharField(max_length=100, null=True, description="文件类型（MIME类型）")
    file_extension = fields.CharField(max_length=20, null=True, description="文件扩展名")
    preview_url = fields.CharField(max_length=500, null=True, description="预览URL（kkFileView）")
    
    category = fields.CharField(max_length=50, null=True, description="文件分类（可选）")
    tags = fields.JSONField(null=True, description="文件标签（JSON数组，可选）")
    description = fields.TextField(null=True, description="文件描述（可选）")
    
    is_active = fields.BooleanField(default=True, description="是否启用")
    upload_status = fields.CharField(max_length=20, default="completed", description="上传状态")
    
    class Meta:
        table = "root_files"
        indexes = [
            ("tenant_id",),
            ("category",),
            ("file_type",),
            ("upload_status",),
        ]
    
    def __str__(self):
        return f"{self.name} ({self.file_size} bytes)"
```

---

## 📝 Schema 设计

### 文件 Schema

```python
# riveredge-backend/src/tree_root/schemas/file.py
from pydantic import BaseModel, Field, ConfigDict
from typing import Optional, List
from datetime import datetime
from uuid import UUID


class FileBase(BaseModel):
    """文件基础 Schema"""
    name: str = Field(..., max_length=255, description="文件名称")
    original_name: str = Field(..., max_length=255, description="原始文件名")
    file_path: str = Field(..., max_length=500, description="文件存储路径")
    file_size: int = Field(..., description="文件大小（字节）")
    file_type: Optional[str] = Field(None, max_length=100, description="文件类型")
    file_extension: Optional[str] = Field(None, max_length=20, description="文件扩展名")
    preview_url: Optional[str] = Field(None, max_length=500, description="预览URL")
    category: Optional[str] = Field(None, max_length=50, description="文件分类")
    tags: Optional[List[str]] = Field(None, description="文件标签")
    description: Optional[str] = Field(None, description="文件描述")
    is_active: bool = Field(True, description="是否启用")
    upload_status: str = Field("completed", max_length=20, description="上传状态")


class FileCreate(FileBase):
    """创建文件 Schema（通常由上传接口自动创建）"""
    pass


class FileUpdate(BaseModel):
    """更新文件 Schema"""
    name: Optional[str] = Field(None, max_length=255, description="文件名称")
    category: Optional[str] = Field(None, max_length=50, description="文件分类")
    tags: Optional[List[str]] = Field(None, description="文件标签")
    description: Optional[str] = Field(None, description="文件描述")
    is_active: Optional[bool] = Field(None, description="是否启用")


class FileResponse(FileBase):
    """文件响应 Schema"""
    uuid: UUID = Field(..., description="文件UUID")
    tenant_id: int = Field(..., description="组织ID")
    created_at: datetime = Field(..., description="创建时间")
    updated_at: datetime = Field(..., description="更新时间")
    
    model_config = ConfigDict(from_attributes=True)


class FileListResponse(BaseModel):
    """文件列表响应 Schema"""
    items: List[FileResponse] = Field(..., description="文件列表")
    total: int = Field(..., description="总数")
    page: int = Field(..., description="当前页")
    page_size: int = Field(..., description="每页数量")
```

---

## 🔧 Service 层设计

### 文件服务（FileService）

**核心功能**：
1. 文件上传（单文件、多文件）
2. 文件下载（生成下载URL）
3. 文件删除（单个删除、批量删除）
4. 文件列表（分页、搜索、筛选）
5. 文件预览（双模式：简单预览 + kkFileView 预览）
6. kkFileView 集成（预览URL生成、权限验证）
7. 预览模式配置（从系统参数读取配置）

**关键实现要点**：
- ✅ 使用 `aiofiles` 进行异步文件操作
- ✅ 文件存储路径：`/uploads/{tenant_id}/{year}/{month}/{filename}`
- ✅ **简单预览**：支持 PDF（PDF.js）、图片（直接显示）、文本（代码高亮）
- ✅ **kkFileView 预览**：预览URL生成：`{kkfileview_url}/onlinePreview?url={file_url}&token={token}`
- ✅ 预览模式选择：从系统参数 `file.kkfileview.enabled` 读取配置
- ✅ 文件权限验证：预览URL包含token，后端验证权限
- ✅ 文件类型检测：使用 `python-magic`（可选）或文件扩展名

---

## 🌐 API 设计

### 文件管理 API

**路由前缀**：`/api/tree-root/files`

**接口列表**：
1. `POST /upload` - 上传文件（单文件）
2. `POST /upload/multiple` - 上传文件（多文件）
3. `GET /list` - 获取文件列表（分页、搜索、筛选）
4. `GET /{uuid}` - 获取文件详情
5. `GET /{uuid}/download` - 下载文件
6. `GET /{uuid}/preview` - 获取预览信息（根据配置返回简单预览或 kkFileView 预览URL）
7. `GET /{uuid}/preview/simple` - 获取简单预览URL（直接文件访问）
8. `GET /{uuid}/preview/kkfileview` - 获取 kkFileView 预览URL
9. `PUT /{uuid}` - 更新文件信息
10. `DELETE /{uuid}` - 删除文件
11. `POST /batch-delete` - 批量删除文件
12. `GET /kkfileview/health` - kkFileView 健康检查
13. `GET /preview-mode` - 获取当前预览模式配置

---

## 🎨 前端页面设计

### 文件管理页面

**页面路径**：`pages/system/files/list/index.tsx`

**核心功能**：
1. 文件列表展示（UniTable，支持表格、卡片视图）
2. 文件上传（拖拽上传、点击上传）
3. 文件下载（直接下载）
4. 文件预览（打开预览URL）
5. 文件删除（单个删除、批量删除）
6. 文件搜索和筛选（按名称、类型、分类）

**布局规范**：
- ✅ 使用 `UniTable` 组件展示列表
- ✅ 使用高级搜索（`showAdvancedSearch={true}`）
- ✅ 使用 `searchFormValues` 获取搜索条件
- ✅ 上传按钮在左侧工具栏
- ✅ 导入导出按钮在右侧工具栏

---

## ⚠️ 重要注意事项

### 1. 吸取第一、第二阶段经验教训

**必须遵守的规范**：
1. ✅ **禁止假设和猜测**：必须直接查看实际代码，使用完全相同的值
2. ✅ **禁止擅作主张**：只做用户明确要求的事，不做额外"优化"
3. ✅ **数据库迁移规范**：必须使用 Aerich 迁移系统，禁止直接使用 SQL
4. ✅ **前端搜索规范**：必须使用高级搜索（`showAdvancedSearch={true}`），使用 `searchFormValues` 获取搜索条件
5. ✅ **UniTable 规范**：`request` 函数必须接收四个参数：`(params, sort, _filter, searchFormValues)`

### 2. 双预览模式设计

#### 2.1 预览模式配置

**系统参数配置**：
- **参数键**：`file.kkfileview.enabled`
- **参数类型**：`boolean`
- **默认值**：`false`（默认使用简单预览）
- **描述**：是否启用 kkFileView 预览（启用后支持 23+ 种格式，需要独立部署 Java 服务）

**配置位置**：
- 系统参数管理页面：`/system/system-parameters`
- 参数键：`file.kkfileview.enabled`
- 参数值：`true`（启用）或 `false`（禁用）

#### 2.2 简单预览实现

**支持格式**：
- ✅ **PDF**：使用 PDF.js 在前端渲染
- ✅ **图片**：JPG、PNG、GIF、WebP、BMP 等（直接显示）
- ✅ **文本**：TXT、MD、LOG、代码文件等（代码高亮）
- ✅ **视频**：MP4、WebM、OGG 等（HTML5 video 标签）
- ✅ **音频**：MP3、WAV、OGG 等（HTML5 audio 标签）

**实现方式**：
- 简单预览通过直接访问文件URL实现，前端根据文件类型选择渲染方式
- 无需额外服务，适合常见格式的快速预览

#### 2.3 预览模式选择逻辑

**后端服务**：
```python
# 根据系统参数配置选择预览模式
kkfileview_enabled = await get_parameter("file.kkfileview.enabled")
if kkfileview_enabled:
    # 使用 kkFileView 预览
    preview_url = generate_kkfileview_url(...)
else:
    # 使用简单预览
    preview_url = generate_simple_preview_url(...)
```

**前端组件**：
- 统一预览组件根据后端返回的 `preview_mode` 字段选择渲染方式
- `preview_mode: "simple"` → 使用简单预览组件
- `preview_mode: "kkfileview"` → 使用 kkFileView 预览组件（iframe）

### 3. kkFileView 集成实现流程

#### 3.1 完整工作流程

**流程图**：
```
用户上传文件
    ↓
后端保存文件到存储（本地/OSS）
    ↓
生成文件记录（保存到数据库）
    ↓
用户点击预览
    ↓
后端生成预览URL（包含token）
    ↓
前端打开预览URL（iframe嵌入kkFileView）
    ↓
kkFileView 请求文件（通过URL或代理）
    ↓
kkFileView 转换文件格式（Office→PDF/图片）
    ↓
kkFileView 返回预览页面
    ↓
前端显示预览内容
```

#### 2.2 详细实现步骤

**步骤1：kkFileView 服务部署**

```bash
# 方式一：Docker 部署（推荐）
docker run -d \
  --name kkfileview \
  -p 8012:8012 \
  keking/kkfileview:latest

# 方式二：Java 服务部署
# 下载 JAR 包并运行
java -jar kkFileView-4.1.0.jar
```

**步骤2：后端预览URL生成服务**

```python
# riveredge-backend/src/tree_root/services/file_preview_service.py
import httpx
from typing import Optional
from datetime import datetime, timedelta
import jwt
from soil.config import settings

class FilePreviewService:
    """
    文件预览服务
    
    负责生成 kkFileView 预览URL，并处理权限验证。
    """
    
    def __init__(self):
        self.kkfileview_url = settings.KKFILEVIEW_URL  # http://localhost:8012
        self.token_secret = settings.SECRET_KEY  # JWT密钥
    
    async def generate_preview_url(
        self,
        file_uuid: str,
        file_path: str,
        tenant_id: int,
        file_name: str,
    ) -> str:
        """
        生成文件预览URL
        
        Args:
            file_uuid: 文件UUID
            file_path: 文件存储路径（可以是本地路径或URL）
            tenant_id: 组织ID
            file_name: 文件名称
            
        Returns:
            预览URL（包含权限验证token）
        """
        # 1. 生成预览token（包含文件UUID、组织ID、过期时间）
        token = self._generate_preview_token(
            file_uuid=file_uuid,
            tenant_id=tenant_id,
            expires_in=3600  # 1小时过期
        )
        
        # 2. 构建文件访问URL（如果文件在私有存储，需要通过代理）
        file_url = self._build_file_url(file_path, tenant_id, file_uuid)
        
        # 3. 构建预览URL
        # kkFileView 预览URL格式：/onlinePreview?url={file_url}&token={token}
        preview_url = (
            f"{self.kkfileview_url}/onlinePreview"
            f"?url={file_url}"
            f"&token={token}"
        )
        
        return preview_url
    
    def _generate_preview_token(
        self,
        file_uuid: str,
        tenant_id: int,
        expires_in: int = 3600
    ) -> str:
        """
        生成预览token（JWT格式）
        
        Token 包含：
        - file_uuid: 文件UUID
        - tenant_id: 组织ID
        - exp: 过期时间
        """
        payload = {
            "file_uuid": file_uuid,
            "tenant_id": tenant_id,
            "exp": datetime.utcnow() + timedelta(seconds=expires_in),
            "iat": datetime.utcnow(),
        }
        
        token = jwt.encode(payload, self.token_secret, algorithm="HS256")
        return token
    
    def _build_file_url(
        self,
        file_path: str,
        tenant_id: int,
        file_uuid: str
    ) -> str:
        """
        构建文件访问URL
        
        如果文件在私有存储，需要通过代理URL访问。
        如果文件在公共存储，可以直接使用文件URL。
        """
        # 方式1：文件在公共存储（OSS等），直接使用文件URL
        if file_path.startswith("http://") or file_path.startswith("https://"):
            return file_path
        
        # 方式2：文件在私有存储，通过代理URL访问
        # 生成文件下载代理URL（包含权限验证）
        base_url = settings.BASE_URL  # http://localhost:9000
        proxy_url = (
            f"{base_url}/api/v1/system/files/{file_uuid}/download"
            f"?token={self._generate_preview_token(file_uuid, tenant_id)}"
        )
        
        return proxy_url
    
    async def verify_preview_token(self, token: str) -> dict:
        """
        验证预览token
        
        Returns:
            token 解码后的数据（包含 file_uuid、tenant_id 等）
        """
        try:
            payload = jwt.decode(token, self.token_secret, algorithms=["HS256"])
            return payload
        except jwt.ExpiredSignatureError:
            raise ValueError("预览token已过期")
        except jwt.InvalidTokenError:
            raise ValueError("预览token无效")
    
    async def check_health(self) -> bool:
        """
        检查 kkFileView 服务健康状态
        """
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{self.kkfileview_url}/health",
                    timeout=5.0
                )
                return response.status_code == 200
        except Exception:
            return False
```

**步骤3：后端API接口**

```python
# riveredge-backend/src/tree_root/api/files/files.py
from fastapi import APIRouter, Depends, HTTPException
from tree_root.services.file_preview_service import FilePreviewService
from tree_root.models.file import File
from soil.auth import get_current_user

router = APIRouter()

@router.get("/{uuid}/preview")
async def get_file_preview(
    uuid: str,
    current_user: User = Depends(get_current_user),
):
    """
    获取文件预览URL
    
    流程：
    1. 查询文件记录
    2. 验证用户权限（确保用户属于同一组织）
    3. 生成预览URL
    4. 返回预览URL
    """
    # 1. 查询文件
    file = await File.get(uuid=uuid, tenant_id=current_user.tenant_id)
    
    if not file:
        raise HTTPException(status_code=404, detail="文件不存在")
    
    # 2. 验证权限（可以根据业务需求扩展）
    if not file.is_active:
        raise HTTPException(status_code=403, detail="文件已禁用")
    
    # 3. 生成预览URL
    preview_service = FilePreviewService()
    preview_url = await preview_service.generate_preview_url(
        file_uuid=file.uuid,
        file_path=file.file_path,
        tenant_id=file.tenant_id,
        file_name=file.name,
    )
    
    # 4. 更新文件预览URL（可选，用于缓存）
    file.preview_url = preview_url
    await file.save()
    
    return {
        "preview_url": preview_url,
        "file_name": file.name,
        "file_type": file.file_type,
    }

@router.get("/{uuid}/download")
async def download_file(
    uuid: str,
    token: str,
    current_user: User = Depends(get_current_user),
):
    """
    文件下载代理（用于kkFileView访问私有文件）
    
    流程：
    1. 验证token
    2. 查询文件
    3. 返回文件流
    """
    # 1. 验证token
    preview_service = FilePreviewService()
    try:
        payload = await preview_service.verify_preview_token(token)
        file_uuid = payload.get("file_uuid")
        tenant_id = payload.get("tenant_id")
    except ValueError as e:
        raise HTTPException(status_code=403, detail=str(e))
    
    # 2. 查询文件
    file = await File.get(uuid=file_uuid, tenant_id=tenant_id)
    
    if not file:
        raise HTTPException(status_code=404, detail="文件不存在")
    
    # 3. 返回文件流
    from fastapi.responses import FileResponse
    return FileResponse(
        path=file.file_path,
        filename=file.original_name,
        media_type=file.file_type,
    )
```

**步骤4：前端预览组件**

```typescript
// riveredge-frontend/src/tree-stem/components/FilePreview/index.tsx
import React, { useState } from 'react';
import { Modal, Button, Spin } from 'antd';
import { EyeOutlined } from '@ant-design/icons';
import { apiRequest } from '@/services/apiRequest';

interface FilePreviewProps {
  fileUuid: string;
  fileName: string;
  fileType?: string;
  visible?: boolean;
  onClose?: () => void;
}

export const FilePreview: React.FC<FilePreviewProps> = ({
  fileUuid,
  fileName,
  fileType,
  visible = false,
  onClose,
}) => {
  const [previewUrl, setPreviewUrl] = useState<string>('');
  const [loading, setLoading] = useState(false);

  React.useEffect(() => {
    if (visible && fileUuid) {
      loadPreviewUrl();
    }
  }, [visible, fileUuid]);

  const loadPreviewUrl = async () => {
    setLoading(true);
    try {
      const response = await apiRequest<{ preview_url: string }>(
        `/api/v1/system/files/${fileUuid}/preview`
      );
      setPreviewUrl(response.preview_url);
    } catch (error) {
      console.error('获取预览URL失败:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Modal
      title={fileName}
      open={visible}
      onCancel={onClose}
      footer={null}
      width="90%"
      style={{ top: 20 }}
      destroyOnClose
    >
      {loading ? (
        <div style={{ textAlign: 'center', padding: '50px' }}>
          <Spin size="large" />
        </div>
      ) : (
        <iframe
          src={previewUrl}
          style={{
            width: '100%',
            height: 'calc(100vh - 200px)',
            border: 'none',
          }}
          title={fileName}
        />
      )}
    </Modal>
  );
};

// 预览按钮组件
export const FilePreviewButton: React.FC<{
  fileUuid: string;
  fileName: string;
  fileType?: string;
}> = ({ fileUuid, fileName, fileType }) => {
  const [visible, setVisible] = useState(false);

  return (
    <>
      <Button
        type="link"
        icon={<EyeOutlined />}
        onClick={() => setVisible(true)}
      >
        预览
      </Button>
      <FilePreview
        fileUuid={fileUuid}
        fileName={fileName}
        fileType={fileType}
        visible={visible}
        onClose={() => setVisible(false)}
      />
    </>
  );
};
```

**步骤5：文件列表中使用预览**

```typescript
// riveredge-frontend/src/tree-stem/pages/system/files/list/index.tsx
import { FilePreviewButton } from '@/components/FilePreview';

const columns = [
  // ... 其他列
  {
    title: '操作',
    key: 'action',
    render: (_: any, record: File) => (
      <Space>
        <FilePreviewButton
          fileUuid={record.uuid}
          fileName={record.name}
          fileType={record.file_type}
        />
        {/* 其他操作按钮 */}
      </Space>
    ),
  },
];
```

#### 2.3 kkFileView 工作原理

**kkFileView 内部流程**：
```
1. 接收预览请求（/onlinePreview?url=xxx&token=xxx）
    ↓
2. 验证token（可选，如果配置了权限验证）
    ↓
3. 下载文件（通过URL或代理）
    ↓
4. 检测文件类型
    ↓
5. 根据文件类型选择转换器：
   - Office文档 → LibreOffice转换 → PDF/图片
   - PDF → 直接渲染
   - 图片 → 直接显示
   - 代码文件 → 语法高亮
   - 压缩包 → 解压并展示文件列表
    ↓
6. 生成预览HTML页面
    ↓
7. 返回预览页面给前端
```

#### 2.4 配置说明

**后端配置**（`settings.py`）：
```python
# kkFileView 配置
KKFILEVIEW_URL = "http://localhost:8012"  # kkFileView 服务地址
KKFILEVIEW_TIMEOUT = 30  # 预览超时时间（秒）
KKFILEVIEW_CACHE_ENABLED = True  # 是否启用预览缓存
```

**kkFileView 配置**（`application.properties`）：
```properties
# 服务端口
server.port=8012

# 文件存储路径（临时文件）
file.dir=/tmp/kkfileview

# 预览服务地址
base.url=http://localhost:8012

# 是否启用token验证（可选）
token.enable=false
token.secret=your-secret-key
```

#### 2.5 注意事项

**部署要求**：
- ✅ kkFileView 需要独立部署（Java 服务）
- ✅ 需要配置 kkFileView 服务地址
- ✅ 需要配置预览权限验证（token生成和验证）

**预览URL生成**：
- ✅ 预览URL格式：`{kkfileview_url}/onlinePreview?url={file_url}&token={token}`
- ✅ token 包含文件UUID、组织ID、过期时间等信息
- ✅ 后端需要验证token，确保预览权限

**文件访问方式**：
- ✅ **公共存储**：文件URL直接暴露，kkFileView直接访问
- ✅ **私有存储**：通过代理URL访问，后端验证权限后返回文件流

**性能优化**：
- ✅ 预览结果缓存（kkFileView自动缓存）
- ✅ 预览服务负载均衡（多实例部署）
- ✅ 大文件分片预览（kkFileView支持）
- ✅ 预览服务健康检查（定期检查服务状态）

### 3. 文件存储注意事项

**存储路径**：
- 本地存储：`/uploads/{tenant_id}/{year}/{month}/{filename}`
- 对象存储（OSS）：`{bucket}/{tenant_id}/{year}/{month}/{filename}`

**文件命名**：
- 使用UUID作为文件名，避免文件名冲突
- 保留原始文件名在 `original_name` 字段

**文件大小限制**：
- 默认最大文件大小：100MB（可配置）
- 大文件上传支持断点续传（可选）

---

## 📚 相关文档

- [前端页面布局规范.md](./前端页面布局规范.md)
- [系统级功能文件结构规划.md](./系统级功能文件结构规划.md)
- [建设进度.md](./建设进度.md)

---

**最后更新**：2025-01-XX

