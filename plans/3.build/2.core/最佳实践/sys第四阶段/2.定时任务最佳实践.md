# 定时任务最佳实践

## 📋 模块概述

**模块名称**：定时任务（Scheduled Task Management）  
**优先级**：⭐⭐⭐（中优先级）  
**预计时间**：2-3 周  
**依赖**：无（独立功能）

**功能范围**：
- 定时任务定义（任务名称、类型、触发器配置、任务配置）
- 定时任务管理（CRUD、启动/停止）
- 定时任务执行（基于 Inngest 定时触发器）
- 定时任务监控（执行日志、状态跟踪）

**核心特点**：
- ✅ **完全基于 Inngest**：替代 APScheduler，所有定时任务都通过 Inngest 执行
- ✅ **支持多种触发器**：cron、interval、date
- ✅ **任务持久化**：任务状态保存在 Inngest 数据库中
- ✅ **任务监控**：通过 Inngest API 监控任务执行状态

---

## 🔍 库选择评估

### 定时任务实现方案

**结论**：✅ **完全基于 Inngest，替代 APScheduler（推荐）**

#### 方案一：完全基于 Inngest ⭐⭐⭐⭐⭐（强烈推荐）

**优势**：
- ✅ 完全替代 APScheduler，统一使用 Inngest
- ✅ 支持 cron、interval、date 触发器
- ✅ 支持任务持久化和重试
- ✅ 支持任务监控和日志
- ✅ 多租户隔离天然支持（tenant_id 字段）
- ✅ 完全符合框架规范（命名、注释、代码风格）

**劣势**：
- ⚠️ 需要集成 Inngest 服务

**适用场景**：
- ✅ 需要定时任务功能
- ✅ 需要任务持久化和重试
- ✅ 需要任务监控和日志
- ✅ 需要多租户任务隔离

**实现复杂度**：⭐⭐⭐（中等，2-3 周可完成）

---

#### 方案二：使用 APScheduler ⭐⭐（不推荐）

**劣势**：
- ❌ 与 Inngest 功能重复
- ❌ 需要维护两套任务调度系统
- ❌ 不符合统一使用 Inngest 的原则

**结论**：已由 Inngest 替代，不推荐使用。

---

### 最终推荐方案

**推荐**：✅ **完全基于 Inngest，替代 APScheduler**

**理由**：
1. ✅ **统一使用 Inngest**，避免维护多套任务调度系统
2. ✅ **功能完整**，支持所有定时任务需求
3. ✅ **多租户是核心需求**，Inngest 天然支持
4. ✅ **完全符合框架规范**，代码风格统一
5. ✅ **维护成本低**，统一技术栈

---

## 🗄️ 数据库设计

### 定时任务表（root_scheduled_tasks）

```sql
CREATE TABLE root_scheduled_tasks (
    id SERIAL PRIMARY KEY,
    uuid VARCHAR(36) NOT NULL UNIQUE,        -- 业务ID（UUID，对外暴露，安全且唯一）
    tenant_id INTEGER NOT NULL,
    
    -- 任务基本信息
    name VARCHAR(100) NOT NULL,              -- 任务名称
    code VARCHAR(50) NOT NULL,                -- 任务代码（唯一，用于程序识别）
    description TEXT,                         -- 任务描述
    type VARCHAR(20) NOT NULL,               -- 任务类型（python_script、api_call等）
    
    -- 触发器配置
    trigger_type VARCHAR(20) NOT NULL,       -- 触发器类型（cron、interval、date）
    trigger_config JSONB NOT NULL,           -- 触发器配置（JSON格式）
    
    -- 任务配置
    task_config JSONB NOT NULL,              -- 任务配置（JSON格式）
    
    -- Inngest 关联
    inngest_function_id VARCHAR(100),        -- Inngest 函数ID（关联 Inngest 函数）
    
    -- 任务状态
    is_active BOOLEAN DEFAULT TRUE,          -- 是否启用
    is_running BOOLEAN DEFAULT FALSE,        -- 是否正在运行
    last_run_at TIMESTAMP NULL,              -- 最后运行时间
    last_run_status VARCHAR(20),             -- 最后运行状态（success、failed）
    last_error TEXT,                          -- 最后错误信息
    
    -- 标准字段
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL,
    
    -- 索引
    CONSTRAINT uk_root_scheduled_tasks_tenant_code UNIQUE (tenant_id, code),
    INDEX idx_root_scheduled_tasks_tenant_id (tenant_id),
    INDEX idx_root_scheduled_tasks_uuid (uuid),
    INDEX idx_root_scheduled_tasks_code (code),
    INDEX idx_root_scheduled_tasks_type (type),
    INDEX idx_root_scheduled_tasks_trigger_type (trigger_type),
    INDEX idx_root_scheduled_tasks_is_active (is_active),
    INDEX idx_root_scheduled_tasks_created_at (created_at)
);
```

**设计要点**：
- ✅ **混合ID方案**：`id`（自增ID，内部使用）+ `uuid`（UUID，对外暴露）
- ✅ `trigger_type` 字段标识触发器类型（cron、interval、date）
- ✅ `trigger_config` 字段使用 JSONB 存储触发器配置
- ✅ `task_config` 字段使用 JSONB 存储任务配置
- ✅ `inngest_function_id` 关联 Inngest 函数
- ✅ `tenant_id + code` 唯一约束，确保组织内任务代码唯一
- ✅ 软删除支持（`deleted_at`）

**触发器配置示例**：

**Cron 触发器**：
```json
{
  "cron": "0 0 * * *"
}
```

**Interval 触发器**：
```json
{
  "seconds": 300
}
```

**Date 触发器**：
```json
{
  "at": "2025-01-01T00:00:00Z"
}
```

**任务配置示例**：

**Python 脚本任务**：
```json
{
  "script": "print('Hello, World!')"
}
```

**API 调用任务**：
```json
{
  "url": "https://api.example.com/endpoint",
  "method": "POST",
  "headers": {
    "Content-Type": "application/json"
  },
  "data": {
    "key": "value"
  }
}
```

---

## 🐍 后端模型设计

### 定时任务模型（ScheduledTask）

```python
# riveredge-backend/src/tree_root/models/scheduled_task.py
from tortoise.models import Model
from tortoise import fields
from typing import Optional, Dict, Any
from .base import BaseModel


class ScheduledTask(BaseModel):
    """
    定时任务模型
    
    用于定义和管理组织内的定时任务，所有任务都通过 Inngest 执行。
    支持多组织隔离，每个组织的任务相互独立。
    
    注意：继承自 BaseModel，自动包含 uuid、tenant_id、created_at、updated_at 字段。
    """
    id = fields.IntField(pk=True, description="任务ID（主键，自增ID，内部使用）")
    # uuid 字段由 BaseModel 提供
    # tenant_id 字段由 BaseModel 提供
    
    name = fields.CharField(max_length=100, description="任务名称")
    code = fields.CharField(max_length=50, description="任务代码（唯一，用于程序识别）")
    description = fields.TextField(null=True, description="任务描述")
    type = fields.CharField(max_length=20, description="任务类型（python_script、api_call等）")
    
    trigger_type = fields.CharField(max_length=20, description="触发器类型（cron、interval、date）")
    trigger_config = fields.JSONField(description="触发器配置（JSON格式）")
    
    task_config = fields.JSONField(description="任务配置（JSON格式）")
    
    inngest_function_id = fields.CharField(max_length=100, null=True, description="Inngest 函数ID")
    
    is_active = fields.BooleanField(default=True, description="是否启用")
    is_running = fields.BooleanField(default=False, description="是否正在运行")
    last_run_at = fields.DatetimeField(null=True, description="最后运行时间")
    last_run_status = fields.CharField(max_length=20, null=True, description="最后运行状态")
    last_error = fields.TextField(null=True, description="最后错误信息")
    
    class Meta:
        table = "root_scheduled_tasks"
        indexes = [
            ("tenant_id", "code"),  # 唯一索引
            ("type",),
            ("trigger_type",),
            ("is_active",),
        ]
        unique_together = [("tenant_id", "code")]
    
    def __str__(self):
        return f"{self.name} ({self.trigger_type})"
```

---

## 🔧 Inngest 集成

### 1. 动态注册 Inngest 函数

**文件位置**：`riveredge-backend/src/tree_root/services/scheduled_task_service.py`

```python
from inngest import Inngest, Event
from typing import Dict, Any
import httpx

inngest = Inngest(app_id="riveredge")

async def register_scheduled_task(task: ScheduledTask) -> str:
    """
    注册定时任务到 Inngest
    
    根据任务的触发器配置，动态创建 Inngest 函数。
    """
    # 根据触发器类型创建触发器
    if task.trigger_type == "cron":
        trigger = inngest.TriggerCron(cron=task.trigger_config["cron"])
    elif task.trigger_type == "interval":
        trigger = inngest.TriggerInterval(seconds=task.trigger_config["seconds"])
    elif task.trigger_type == "date":
        trigger = inngest.TriggerDate(at=task.trigger_config["at"])
    else:
        raise ValueError(f"Unknown trigger type: {task.trigger_type}")
    
    # 创建 Inngest 函数
    @inngest.create_function(
        id=f"scheduled-task-{task.uuid}",
        name=task.name,
        trigger=trigger,
        retries=3,
        retry_delay=inngest.RetryDelay(seconds=60)
    )
    async def task_executor(event: Event) -> Dict[str, Any]:
        """
        任务执行器
        
        根据任务类型执行任务。
        """
        tenant_id = event.data.get("tenant_id")
        task_uuid = event.data.get("task_uuid")
        task_type = event.data.get("task_type")
        task_config = event.data.get("task_config")
        
        try:
            if task_type == "api_call":
                # 执行 API 调用
                async with httpx.AsyncClient() as client:
                    response = await client.request(
                        method=task_config["method"],
                        url=task_config["url"],
                        headers=task_config.get("headers", {}),
                        json=task_config.get("data", {})
                    )
                    return {
                        "success": True,
                        "status_code": response.status_code,
                        "response": response.json()
                    }
            elif task_type == "python_script":
                # 执行 Python 脚本
                # 注意：需要安全执行脚本，防止代码注入
                exec(task_config["script"])
                return {"success": True}
            else:
                return {"success": False, "error": "Unknown task type"}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    # 注册函数到 Inngest
    function_id = await inngest.register_function(task_executor)
    
    return function_id
```

### 2. 任务执行监控

**文件位置**：`riveredge-backend/src/tree_root/services/scheduled_task_service.py`

```python
import httpx

async def get_task_status(run_id: str) -> Dict[str, Any]:
    """
    查询任务执行状态
    
    通过 Inngest API 查询任务执行状态。
    """
    async with httpx.AsyncClient() as client:
        response = await client.get(
            f"http://localhost:8288/api/v1/runs/{run_id}",
            headers={"Authorization": "Bearer your-token"}
        )
        return response.json()

async def get_task_logs(run_id: str) -> List[Dict[str, Any]]:
    """
    查询任务执行日志
    
    通过 Inngest API 查询任务执行日志。
    """
    async with httpx.AsyncClient() as client:
        response = await client.get(
            f"http://localhost:8288/api/v1/runs/{run_id}/logs",
            headers={"Authorization": "Bearer your-token"}
        )
        return response.json()
```

---

## 🌐 API 设计

### 定时任务管理 API

**路由前缀**：`/api/tree-root/scheduled-tasks`

**接口列表**：
1. `POST /` - 创建定时任务（自动注册到 Inngest）
2. `GET /list` - 获取定时任务列表（分页、搜索、筛选）
3. `GET /{uuid}` - 获取定时任务详情
4. `PUT /{uuid}` - 更新定时任务（自动更新 Inngest 函数）
5. `DELETE /{uuid}` - 删除定时任务（自动从 Inngest 注销）
6. `POST /{uuid}/start` - 启动定时任务
7. `POST /{uuid}/stop` - 停止定时任务
8. `GET /{uuid}/status` - 获取任务执行状态
9. `GET /{uuid}/logs` - 获取任务执行日志

---

## 🎨 前端页面设计

### 定时任务管理页面

**页面路径**：`pages/system/scheduled-tasks/list/index.tsx`

**核心功能**：
1. 定时任务列表展示（UniTable，支持表格视图）
2. 定时任务创建/编辑（Modal + ProForm，根据触发器类型动态渲染配置表单）
3. 定时任务启动/停止（启动、停止任务）
4. 定时任务监控（查看执行状态、执行日志）
5. 定时任务删除（单个删除、批量删除）
6. 定时任务搜索和筛选（按名称、类型、触发器类型）

**布局规范**：
- ✅ 使用 `UniTable` 组件展示列表
- ✅ 使用高级搜索（`showAdvancedSearch={true}`）
- ✅ 使用 `searchFormValues` 获取搜索条件
- ✅ 创建/编辑使用 Modal + ProForm
- ✅ 执行日志使用 Drawer 展示

---

## ⚠️ 重要注意事项

### 1. 吸取第一、第二、第三阶段经验教训

**必须遵守的规范**：
1. ✅ **禁止假设和猜测**：必须直接查看实际代码，使用完全相同的值
2. ✅ **禁止擅作主张**：只做用户明确要求的事，不做额外"优化"
3. ✅ **数据库迁移规范**：必须使用 Aerich 迁移系统，禁止直接使用 SQL
4. ✅ **前端搜索规范**：必须使用高级搜索（`showAdvancedSearch={true}`），使用 `searchFormValues` 获取搜索条件
5. ✅ **UniTable 规范**：`request` 函数必须接收四个参数：`(params, sort, _filter, searchFormValues)`

### 2. Inngest 集成注意事项

**动态注册**：
- 创建任务时自动注册到 Inngest
- 更新任务时自动更新 Inngest 函数
- 删除任务时自动从 Inngest 注销

**任务执行**：
- 所有任务执行都通过 Inngest 函数
- 任务执行状态通过 Inngest 运行ID跟踪
- 任务执行日志通过 Inngest API 查询

**多租户支持**：
- 所有 Inngest 函数必须包含 `tenant_id` 参数
- 任务执行时自动隔离组织数据
- 任务监控按组织过滤

**安全注意事项**：
- Python 脚本执行需要安全沙箱，防止代码注入
- API 调用需要验证 URL，防止 SSRF 攻击
- 任务配置需要验证，防止恶意配置

---

## 📚 相关文档

- [Inngest 集成指南.md](./Inngest集成指南.md)
- [前端页面布局规范.md](./前端页面布局规范.md)
- [系统级功能文件结构规划.md](./系统级功能文件结构规划.md)
- [建设进度.md](./建设进度.md)

---

**最后更新**：2025-01-XX

