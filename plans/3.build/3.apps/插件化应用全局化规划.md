# 插件化应用全局化规划方案

## 📋 问题背景

在插件化开发中，不同插件（如 MES、ERP）之间会存在边界交叉的情况，例如：
- **订单**：MES 需要生产订单，ERP 需要销售订单，两者可能共享订单基础信息
- **基础资料**：物料、客户、供应商等基础数据可能被多个插件共享
- **业务流程**：订单从 ERP 流转到 MES 进行生产，再流转回 ERP 进行结算

## 🎯 全局化规划原则

### 1. 分层设计原则

```
┌─────────────────────────────────────────┐
│         核心层 (Core Layer)              │
│  - 共享数据模型定义                      │
│  - 共享服务接口                          │
│  - 共享业务规则                          │
└─────────────────────────────────────────┘
                    ↑
        ┌───────────┴───────────┐
        │                       │
┌───────▼──────┐      ┌────────▼────────┐
│  插件层      │      │   插件层        │
│  (MES)       │      │   (ERP)         │
│  - 扩展数据  │      │   - 扩展数据     │
│  - 业务逻辑  │      │   - 业务逻辑     │
└──────────────┘      └─────────────────┘
```

### 2. 职责划分原则

#### 核心层职责（Core Layer）
- **共享数据模型**：定义跨插件共享的基础数据模型
- **共享服务接口**：定义跨插件调用的服务接口
- **共享业务规则**：定义跨插件的业务规则和约束
- **数据一致性**：保证跨插件数据的一致性

#### 插件层职责（Plugin Layer）
- **扩展数据模型**：在核心模型基础上扩展插件特有的字段
- **业务逻辑实现**：实现插件特有的业务逻辑
- **插件特有功能**：实现插件独有的功能

### 3. 边界管理原则

#### 数据边界
- **核心数据**：放在 `core` 模块，所有插件共享
- **插件数据**：放在 `seed-插件名` 模块，插件独有
- **关联数据**：通过外键关联，保持数据一致性

#### 功能边界
- **核心功能**：放在 `core` 模块，提供基础服务
- **插件功能**：放在 `seed-插件名` 模块，实现业务逻辑
- **接口契约**：通过接口定义功能边界，插件实现接口

## 🏗️ 架构设计方案

### 1. 数据模型分层设计

#### 方案一：核心表 + 插件扩展表（推荐）

```python
# core/models/order.py - 核心订单表（所有插件共享）
class Order(Model):
    """订单核心表"""
    uuid = fields.UUIDField(pk=True)
    tenant_id = fields.IntField()
    order_no = fields.CharField(max_length=100)  # 订单号
    order_type = fields.CharField(max_length=50)  # 订单类型：sales/production/purchase
    customer_id = fields.UUIDField(null=True)  # 客户ID（关联核心客户表）
    status = fields.CharField(max_length=50)  # 订单状态
    total_amount = fields.DecimalField(max_digits=10, decimal_places=2)
    created_at = fields.DatetimeField(auto_now_add=True)
    updated_at = fields.DatetimeField(auto_now=True)
    
    class Meta:
        table = "core_orders"
        indexes = [
            Index(fields=["tenant_id", "order_no"]),
            Index(fields=["tenant_id", "order_type"]),
        ]

# seed-mes/models/order.py - MES 订单扩展表
class MESOrderExtension(Model):
    """MES 订单扩展表"""
    uuid = fields.UUIDField(pk=True)
    tenant_id = fields.IntField()
    order_id = fields.UUIDField()  # 关联核心订单表
    production_line_id = fields.UUIDField(null=True)  # 生产线ID
    planned_start_time = fields.DatetimeField(null=True)  # 计划开始时间
    planned_end_time = fields.DatetimeField(null=True)  # 计划结束时间
    actual_start_time = fields.DatetimeField(null=True)  # 实际开始时间
    actual_end_time = fields.DatetimeField(null=True)  # 实际结束时间
    
    class Meta:
        table = "seed_mes_order_extensions"
        indexes = [
            Index(fields=["tenant_id", "order_id"]),
        ]

# seed-erp/models/order.py - ERP 订单扩展表
class ERPOrderExtension(Model):
    """ERP 订单扩展表"""
    uuid = fields.UUIDField(pk=True)
    tenant_id = fields.IntField()
    order_id = fields.UUIDField()  # 关联核心订单表
    sales_person_id = fields.UUIDField(null=True)  # 销售人员ID
    delivery_address = fields.TextField(null=True)  # 配送地址
    payment_terms = fields.CharField(max_length=100, null=True)  # 付款条件
    
    class Meta:
        table = "seed_erp_order_extensions"
        indexes = [
            Index(fields=["tenant_id", "order_id"]),
        ]
```

**优点**：
- 核心数据统一管理，保证数据一致性
- 插件可以独立扩展，不影响其他插件
- 查询灵活，可以单独查询核心数据或关联查询扩展数据

**缺点**：
- 需要关联查询时性能可能略低（可通过索引优化）
- 需要维护外键关系

#### 方案二：单表继承（不推荐）

```python
# 所有字段放在一个表中，通过 order_type 区分
class Order(Model):
    # 核心字段
    uuid = fields.UUIDField(pk=True)
    order_no = fields.CharField(max_length=100)
    order_type = fields.CharField(max_length=50)  # mes/erp
    
    # MES 字段（MES 订单时使用）
    production_line_id = fields.UUIDField(null=True)
    planned_start_time = fields.DatetimeField(null=True)
    
    # ERP 字段（ERP 订单时使用）
    sales_person_id = fields.UUIDField(null=True)
    delivery_address = fields.TextField(null=True)
```

**缺点**：
- 表结构臃肿，大量 null 字段
- 插件耦合度高，难以独立扩展
- 违反单一职责原则

### 2. 服务接口分层设计

#### 核心服务接口（Core Service Interface）

```python
# core/interfaces/order_service.py
from abc import ABC, abstractmethod
from typing import List, Optional
from core.schemas.order import OrderCreate, OrderUpdate, OrderResponse

class IOrderService(ABC):
    """订单服务接口（核心层定义）"""
    
    @abstractmethod
    async def create_order(self, data: OrderCreate) -> OrderResponse:
        """创建订单"""
        pass
    
    @abstractmethod
    async def get_order(self, order_id: str) -> Optional[OrderResponse]:
        """获取订单"""
        pass
    
    @abstractmethod
    async def update_order(self, order_id: str, data: OrderUpdate) -> OrderResponse:
        """更新订单"""
        pass
    
    @abstractmethod
    async def list_orders(self, filters: dict) -> List[OrderResponse]:
        """查询订单列表"""
        pass
```

#### 核心服务实现（Core Service Implementation）

```python
# core/services/order_service.py
from core.interfaces.order_service import IOrderService
from core.models.order import Order
from core.repositories.order_repository import OrderRepository

class OrderService(IOrderService):
    """订单服务实现（核心层）"""
    
    def __init__(self, repository: OrderRepository):
        self.repository = repository
    
    async def create_order(self, data: OrderCreate) -> OrderResponse:
        """创建订单（核心逻辑）"""
        # 1. 验证订单号唯一性
        # 2. 创建订单记录
        # 3. 返回订单信息
        pass
    
    async def get_order(self, order_id: str) -> Optional[OrderResponse]:
        """获取订单（核心逻辑）"""
        # 1. 查询订单
        # 2. 返回订单信息
        pass
```

#### 插件服务扩展（Plugin Service Extension）

```python
# seed-mes/services/order_service.py
from core.services.order_service import OrderService
from core.interfaces.order_service import IOrderService
from seed_mes.models.order_extension import MESOrderExtension

class MESOrderService(OrderService):
    """MES 订单服务（扩展核心服务）"""
    
    async def create_order(self, data: OrderCreate) -> OrderResponse:
        """创建 MES 订单（扩展核心逻辑）"""
        # 1. 调用核心服务创建订单
        order = await super().create_order(data)
        
        # 2. 创建 MES 扩展数据
        extension = await MESOrderExtension.create(
            order_id=order.uuid,
            production_line_id=data.production_line_id,
            # ...
        )
        
        # 3. 返回完整订单信息（包含扩展数据）
        return OrderResponse(
            **order.dict(),
            mes_extension=extension.dict()
        )
    
    async def start_production(self, order_id: str):
        """开始生产（MES 特有功能）"""
        # MES 特有的业务逻辑
        pass
```

### 3. 数据访问层设计

#### 核心仓储接口（Core Repository Interface）

```python
# core/repositories/order_repository.py
from abc import ABC, abstractmethod
from typing import List, Optional
from core.models.order import Order

class IOrderRepository(ABC):
    """订单仓储接口"""
    
    @abstractmethod
    async def create(self, order: Order) -> Order:
        """创建订单"""
        pass
    
    @abstractmethod
    async def get_by_id(self, order_id: str) -> Optional[Order]:
        """根据ID获取订单"""
        pass
    
    @abstractmethod
    async def get_by_order_no(self, order_no: str) -> Optional[Order]:
        """根据订单号获取订单"""
        pass
    
    @abstractmethod
    async def list(self, filters: dict) -> List[Order]:
        """查询订单列表"""
        pass
```

#### 核心仓储实现（Core Repository Implementation）

```python
# core/repositories/order_repository.py
from tortoise.queryset import QuerySet
from core.models.order import Order

class OrderRepository(IOrderRepository):
    """订单仓储实现"""
    
    async def create(self, order: Order) -> Order:
        """创建订单"""
        return await Order.create(**order.dict())
    
    async def get_by_id(self, order_id: str) -> Optional[Order]:
        """根据ID获取订单"""
        return await Order.get_or_none(uuid=order_id)
    
    async def get_by_order_no(self, order_no: str) -> Optional[Order]:
        """根据订单号获取订单"""
        return await Order.get_or_none(order_no=order_no)
    
    async def list(self, filters: dict) -> List[Order]:
        """查询订单列表"""
        queryset = Order.all()
        
        # 应用过滤条件
        if filters.get('order_type'):
            queryset = queryset.filter(order_type=filters['order_type'])
        if filters.get('status'):
            queryset = queryset.filter(status=filters['status'])
        
        return await queryset
```

## 📊 全局化规划实施步骤

### 第一阶段：核心数据模型定义

1. **识别共享数据**
   - 订单（Order）
   - 物料（Material）
   - 客户（Customer）
   - 供应商（Supplier）
   - 仓库（Warehouse）
   - 等...

2. **设计核心数据模型**
   - 在 `core/models/` 中定义核心数据模型
   - 使用 `core_` 前缀命名表
   - 包含所有插件共享的字段

3. **定义数据访问接口**
   - 在 `core/repositories/` 中定义仓储接口
   - 在 `core/services/` 中定义服务接口

### 第二阶段：插件扩展设计

1. **识别插件特有数据**
   - MES：生产计划、工艺路线、设备状态等
   - ERP：销售计划、财务数据、成本核算等

2. **设计插件扩展模型**
   - 在 `seed-插件名/models/` 中定义扩展模型
   - 使用 `seed_插件名_` 前缀命名表
   - 通过外键关联核心表

3. **实现插件服务扩展**
   - 继承核心服务接口
   - 扩展插件特有功能

### 第三阶段：接口契约定义

1. **定义核心接口**
   - 在 `core/interfaces/` 中定义接口
   - 使用抽象基类（ABC）定义接口契约

2. **实现核心服务**
   - 在 `core/services/` 中实现核心服务
   - 实现接口定义的基础功能

3. **插件服务扩展**
   - 插件继承核心服务
   - 扩展插件特有功能

### 第四阶段：依赖管理

1. **定义插件依赖**
   - 在 `manifest.json` 中定义插件依赖
   - 明确插件对核心模块的依赖关系

2. **版本管理**
   - 核心接口版本管理
   - 插件版本兼容性检查

## 🔧 实施建议

### 1. 数据模型设计建议

**核心表设计原则**：
- 只包含所有插件共享的字段
- 使用通用字段名，避免业务特定命名
- 预留扩展字段（JSON 字段）用于未来扩展

**插件扩展表设计原则**：
- 通过外键关联核心表
- 只包含插件特有的字段
- 使用插件前缀命名，避免冲突

### 2. 服务接口设计建议

**核心服务接口**：
- 定义通用的 CRUD 操作
- 定义通用的业务规则
- 使用依赖注入，便于测试和扩展

**插件服务扩展**：
- 继承核心服务，复用基础功能
- 扩展插件特有功能
- 保持接口一致性

### 3. 依赖管理建议

**插件依赖声明**：
```json
{
  "name": "seed-mes",
  "version": "1.0.0",
  "dependencies": {
    "core": ">=1.0.0",
    "seed-erp": ">=1.0.0"  // 可选依赖
  }
}
```

**版本兼容性**：
- 核心接口使用语义化版本（Semantic Versioning）
- 插件声明对核心版本的要求
- 运行时检查版本兼容性

### 4. 数据一致性保证

**事务管理**：
- 核心数据和扩展数据在同一事务中操作
- 使用数据库事务保证数据一致性

**数据校验**：
- 核心层定义数据校验规则
- 插件层扩展数据校验规则

## 📝 最佳实践

### 1. 命名规范

**核心表命名**：
- 表名：`core_orders`、`core_materials`、`core_customers`
- 模型名：`Order`、`Material`、`Customer`

**插件表命名**：
- 表名：`seed_mes_order_extensions`、`seed_erp_order_extensions`
- 模型名：`MESOrderExtension`、`ERPOrderExtension`

### 2. 代码组织

**核心层代码组织**：
```
core/
├── models/          # 核心数据模型
├── repositories/    # 核心仓储实现
├── services/        # 核心服务实现
├── interfaces/      # 核心服务接口
└── schemas/         # 核心数据模式
```

**插件层代码组织**：
```
seed-mes/
├── models/          # MES 扩展模型
├── repositories/    # MES 仓储实现
├── services/        # MES 服务实现（继承核心服务）
└── schemas/         # MES 数据模式
```

### 3. 测试策略

**核心层测试**：
- 单元测试：测试核心服务逻辑
- 集成测试：测试核心数据访问

**插件层测试**：
- 单元测试：测试插件服务扩展逻辑
- 集成测试：测试插件与核心的集成

## 🎯 总结

插件化应用的全局化规划需要遵循以下原则：

1. **分层设计**：核心层定义共享资源，插件层扩展特有功能
2. **职责划分**：明确核心层和插件层的职责边界
3. **接口契约**：通过接口定义功能边界，保证插件独立性
4. **数据一致性**：通过事务和校验保证跨插件数据一致性
5. **依赖管理**：明确插件依赖关系，管理版本兼容性

通过以上规划，可以实现：
- ✅ 插件独立开发和部署
- ✅ 共享资源统一管理
- ✅ 跨插件数据一致性
- ✅ 插件间松耦合
- ✅ 易于扩展和维护

